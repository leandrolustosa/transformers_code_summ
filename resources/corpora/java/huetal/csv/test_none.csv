code	desc
private int currentdepth ( ) { try { integer onebased = ( ( integer ) depth_field . get ( this ) ) ; return onebased - _num ; } catch ( illegalaccessexception e ) { throw new assertionerror ( e ) ; } }	returns a 0 - based depth within the object graph of the current object being serialized .
public static int unionsize ( long [ ] x , long [ ] y ) { final int lx = x . length , ly = y . length ; final int min = ( lx < ly ) ? lx : ly ; int i = _num , res = _num ; for ( ; i < min ; i ++ ) { res += long . bitcount ( x [ i ] | y [ i ] ) ; } for ( ; i < lx ; i ++ ) { res += long . bitcount ( x [ i ] ) ; } for ( ; i < ly ; i ++ ) { res += long . bitcount ( y [ i ] ) ; } return res ; }	compute the union size of two bitsets .
@ override public void closingok ( ) { list < adduserfields . attributespec > specs = new arraylist < adduserfields . attributespec > ( ) ; for ( int i = _num ; i < m_listmodel . size ( ) ; i ++ ) { adduserfields . attributespec a = ( adduserfields . attributespec ) m_listmodel . elementat ( i ) ; specs . add ( a ) ; } if ( m_modifyl != null ) { m_modifyl . setmodifiedstatus ( adduserfieldscustomizer . this , _bool ) ; } m_filter . setattributespecs ( specs ) ; }	actions to perform when the user has closed the dialog with the ok button .
public string tostring ( ) { stringbuffer text = new stringbuffer ( ) ; if ( ( m_classattribute == null ) ) { return _str ; } try { text . append ( _str ) ; text . append ( _str + m_kernel . tostring ( ) + _str ) ; for ( int i = _num ; i < m_classattribute . numvalues ( ) ; i ++ ) { for ( int j = i + _num ; j < m_classattribute . numvalues ( ) ; j ++ ) { text . append ( _str + m_classattribute . value ( i ) + _str + m_classattribute . value ( j ) + _str ) ; text . append ( m_classifiers [ i ] [ j ] ) ; if ( m_fitlogisticmodels ) { text . append ( _str ) ; if ( m_classifiers [ i ] [ j ] . m_logistic == null ) { text . append ( _str ) ; } else { text . append ( m_classifiers [ i ] [ j ] . m_logistic ) ; } } text . append ( _str ) ; } } } catch ( exception e ) { return _str ; } return text . tostring ( ) ; }	prints out the classifier .
public final sector union ( sector that ) { if ( that == null ) return this ; angle minlat = this . minlatitude ; angle maxlat = this . maxlatitude ; angle minlon = this . minlongitude ; angle maxlon = this . maxlongitude ; if ( that . minlatitude . degrees < this . minlatitude . degrees ) minlat = that . minlatitude ; if ( that . maxlatitude . degrees > this . maxlatitude . degrees ) maxlat = that . maxlatitude ; if ( that . minlongitude . degrees < this . minlongitude . degrees ) minlon = that . minlongitude ; if ( that . maxlongitude . degrees > this . maxlongitude . degrees ) maxlon = that . maxlongitude ; return new sector ( minlat , maxlat , minlon , maxlon ) ; }	returns a new sector whose angles are the extremes of the this sector and another.
private static boolean isdoubleequal ( double value , double valuetocompare ) { return ( math . abs ( value - valuetocompare ) < _num ) ; }	checks if is double values are equal .
public void testintvaluepos ( ) { string a = _str ; bigdecimal anumber = new bigdecimal ( a ) ; int result = - _num ; asserttrue ( _str , anumber . intvalue ( ) == result ) ; }	integer value of a positive bigdecimal.
private void walk ( file directory , int depth , collection < t > results ) throws ioexception { checkifcancelled ( directory , depth , results ) ; if ( handledirectory ( directory , depth , results ) ) { handledirectorystart ( directory , depth , results ) ; int childdepth = depth + _num ; if ( depthlimit < _num || childdepth <= depthlimit ) { checkifcancelled ( directory , depth , results ) ; file [ ] childfiles = filter == null ? directory . listfiles ( ) : directory . listfiles ( filter ) ; childfiles = filterdirectorycontents ( directory , depth , childfiles ) ; if ( childfiles == null ) { handlerestricted ( directory , childdepth , results ) ; } else { for ( file childfile : childfiles ) { if ( childfile . isdirectory ( ) ) { walk ( childfile , childdepth , results ) ; } else { checkifcancelled ( childfile , childdepth , results ) ; handlefile ( childfile , childdepth , results ) ; checkifcancelled ( childfile , childdepth , results ) ; } } } } handledirectoryend ( directory , depth , results ) ; } checkifcancelled ( directory , depth , results ) ; }	main recursive method to examine the directory hierarchy .
public static object [ ] ordinalarray ( tupleset tuples , string field ) { return ordinalarray ( tuples , field , defaultliteralcomparator . getinstance ( ) ) ; }	get a sorted array containing all column values for a given tuple iterator and field .
public void testdivideexceptioninvalidrm ( ) { string a = _str ; int ascale = _num ; string b = _str ; int bscale = _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; try { anumber . divide ( bnumber , _num ) ; fail ( _str ) ; } catch ( illegalargumentexception e ) { assertequals ( _str , _str , e . getmessage ( ) ) ; } }	divide with invalid rounding mode.
@ override public void datasetchanged ( datasetchangeevent event ) { super . datasetchanged ( event ) ; if ( this . subplots == null ) { return ; } xydataset dataset = null ; if ( event . getdataset ( ) instanceof xydataset ) { dataset = ( xydataset ) event . getdataset ( ) ; } for ( xyplot subplot : this . subplots ) { if ( subplot . indexof ( dataset ) >= _num ) { subplot . configurerangeaxes ( ) ; } } }	receives notification of a change to the plot ' s dataset.
public boolean onscheduleaslibrary ( config config , config runtime , ischeduler scheduler , packingplan packing ) { boolean ret = _bool ; try { scheduler . initialize ( config , runtime ) ; ret = scheduler . onschedule ( packing ) ; if ( ret ) { ret = schedulerutils . setlibschedulerlocation ( runtime , scheduler , _bool ) ; } else { log . severe ( _str ) ; } } finally { scheduler . close ( ) ; } return ret ; }	invoke the onscheduler ( ) in ischeduler directly as a library.
public static boolean isstringtype ( type t ) { return t . equals ( reftype . v ( _str ) ) ; }	returns true if specified type is java.
private void validatesqlstatement ( string sql , int jdbcstatementindex ) { assert . istrue ( stringutils . isnotblank ( sql ) , _str + jdbcstatementindex + _str ) ; }	validates the given sql statement where its position in the list of statement is the given index.
public static long [ ] valuesof ( long [ ] array ) { long [ ] dest = new long [ array . length ] ; for ( int i = _num ; i < array . length ; i ++ ) { dest [ i ] = long . valueof ( array [ i ] ) ; } return dest ; }	converts to object array .
@ override public boolean istraceenabled ( ) { return logger . isloggable ( level . finest ) ; }	is this logger instance enabled for the finest level ?.
private static void usemissile ( player player ) { stackableitem projectilesitem = null ; if ( player . getrangeweapon ( ) != null ) { projectilesitem = player . getammunition ( ) ; } if ( projectilesitem == null ) { projectilesitem = player . getmissileifnotholdingotherweapon ( ) ; } if ( projectilesitem != null ) { projectilesitem . removeone ( ) ; } }	remove an used up missile from an attacking player .
public tcpmatcher ( final networkconfig config ) { super ( config ) ; }	creates a new matcher for running coap over tcp .
private int determinemaxlevelrec ( int level , node v ) { int newlevel = level ; for ( edge e = v . getfirstoutedge ( ) ; e != null ; e = v . getnextoutedge ( e ) ) { newlevel = math . max ( newlevel , determinemaxlevelrec ( level , e . gettarget ( ) ) + _num ) ; } return newlevel ; }	recursively does the work.
protected void requestpasscodeconfirmation ( ) { clearboxes ( ) ; mpasscodehdr . settext ( r . string . pass_code_reenter_your_pass_code ) ; mpasscodehdrexplanation . setvisibility ( view . invisible ) ; mconfirmingpasscode = _bool ; }	ask to the user for retyping the pass code just entered before saving it as the current pass code .
private void addworkerfailed ( worker w ) { final reentrantlock mainlock = this . mainlock ; mainlock . lock ( ) ; try { if ( w != null ) workers . remove ( w ) ; decrementworkercount ( ) ; tryterminate ( ) ; } finally { mainlock . unlock ( ) ; } }	rolls back the worker thread creation . - removes worker from workers , if present - decrements worker count - rechecks for termination , in case the existence of this worker was holding up termination.
public void testinsert4 ( ) throws sqlexception { databasecreator . fillsimpletable1 ( conn ) ; statement . execute ( _str + databasecreator . simple_table2 + _str + databasecreator . simple_table1 ) ; resultset r = statement . executequery ( _str + databasecreator . simple_table2 + _str + databasecreator . simple_table1 + _str ) ; r . next ( ) ; assertequals ( _str , _num , r . getint ( _num ) ) ; r . close ( ) ; }	insertfunctionalitytest # testinsert4 ( ).
private synchronized void putmapentry ( string localid , mapentry entry ) { if ( ! islocalid ( localid ) ) { throw new illegalstateexception ( _str + localid + _str ) ; } jsonobject json = new jsonobject ( ) ; try { json . put ( _str , entry . retaincount ) ; if ( entry . objectid != null ) { json . put ( _str , entry . objectid ) ; } } catch ( jsonexception je ) { throw new illegalstateexception ( _str , je ) ; } file file = new file ( diskpath , localid ) ; if ( ! diskpath . exists ( ) ) { diskpath . mkdirs ( ) ; } try { parsefileutils . writejsonobjecttofile ( file , json ) ; } catch ( ioexception e ) { } }	writes one entry to the local id map on disk .
public void endelement ( string namespaceuri , string localname , string name ) throws org . xml . sax . saxexception { if ( m_inentityref ) return ; m_prefixmap . popnamespaces ( m_elemcontext . m_currentelemdepth , null ) ; try { final java . io . writer writer = m_writer ; if ( m_elemcontext . m_starttagopen ) { if ( m_tracer != null ) super . firestartelem ( m_elemcontext . m_elementname ) ; int nattrs = m_attributes . getlength ( ) ; if ( nattrs > _num ) { processattributes ( m_writer , nattrs ) ; m_attributes . clear ( ) ; } if ( m_spacebeforeclose ) writer . write ( _str ) ; else writer . write ( _str ) ; } else { if ( m_cdatatagopen ) closecdata ( ) ; if ( shouldindent ( ) ) indent ( m_elemcontext . m_currentelemdepth - _num ) ; writer . write ( _str ) ; writer . write ( _str ) ; writer . write ( name ) ; writer . write ( _str ) ; } } catch ( ioexception e ) { throw new saxexception ( e ) ; } if ( ! m_elemcontext . m_starttagopen && m_doindent ) { m_ispreserve = m_preserves . isempty ( ) ? _bool : m_preserves . pop ( ) ; } m_isprevtext = _bool ; if ( m_tracer != null ) super . fireendelem ( name ) ; m_elemcontext = m_elemcontext . m_prev ; }	receive notification of the end of an element .
public static void f ( string msg , object ... args ) { if ( ! allowwtf ) return ; stacktraceelement caller = getcallerstacktraceelement ( ) ; string tag = generatetag ( caller ) ; if ( slevel > level_fatal ) { return ; } if ( args . length > _num ) { msg = string . format ( msg , args ) ; } log . wtf ( tag , msg ) ; }	send a fatal error log message.
public void deleteleaves ( string name ) { for ( int i = _num ; i < _leaves . size ( ) ; i ++ ) { catalogtreeleaf leaf = _leaves . get ( i ) ; if ( name . equals ( leaf . getname ( ) ) ) { _leaves . remove ( i ) ; } } }	leaves can be used for many - to - many relations.
public string tostring ( ) { final stringbuffer s = new stringbuffer ( ) ; final int size = size ( ) ; for ( int i = _num ; i < size ; i ++ ) s . append ( getint ( i ) ) ; return s . tostring ( ) ; }	returns a string representation of this vector.
protected boolean validate ( final char [ ] component , final int soffset , int eoffset , final bitset generous ) { if ( eoffset == - _num ) { eoffset = component . length - _num ; } for ( int i = soffset ; i <= eoffset ; i ++ ) { if ( ! generous . get ( component [ i ] ) ) { return _bool ; } } return _bool ; }	validate the uri characters within a specific component.
public boolean removeshutdownhook ( thread hook ) { securitymanager sm = system . getsecuritymanager ( ) ; if ( sm != null ) { sm . checkpermission ( runtimepermissioncollection . shutdown_hooks_permission ) ; } if ( hook == null ) throw new nullpointerexception ( _str ) ; if ( vmstate > _num ) { throw new illegalstateexception ( ) ; } synchronized ( hookslist ) { return hookslist . remove ( hook ) ; } }	de - registers a previously - registered virtual - machine shutdown hook .
public boolean boundscroll ( ) { float curscroll = getstackscroll ( ) ; float newscroll = getboundedstackscroll ( curscroll ) ; if ( float . compare ( newscroll , curscroll ) != _num ) { setstackscroll ( newscroll ) ; return _bool ; } return _bool ; }	bounds the current scroll if necessary.
public void waitforvolumestobevisible ( cgrequestparams request ) { scan ( request . getcopies ( ) , request . getrsets ( ) ) ; }	scans all sites until all volumes involved in the recoverpoint protection are visible.
protected void startadditionalservices ( final cache cache , final map < string , object > options ) throws exception { }	this method is called immediately following cache creation in the spawned process , but prior to setting the running flag in the status file.
public void updateview ( ) { if ( finputelement != null && fparentcomposite != null ) { indicatorviewstate oldstate = fstatemap . get ( finputelement ) ; boolean reload = ffilestoreoad . contains ( finputelement ) ; if ( reload || oldstate == null ) { jsonobject jsonobject = droidsafepluginutilities . parseindicatorfile ( finputelement ) ; if ( jsonobject == null ) return ; ffilestoreoad . remove ( finputelement ) ; fstate = new indicatorviewstate ( finputelement , jsonobject , getsecurityspec ( ) , oldstate ) ; fstatemap . put ( finputelement , fstate ) ; } else { fstate = oldstate ; } setpartname ( fstate . indicatortype ) ; showpage ( page_viewer ) ; ftreeviewer . setinput ( fstate . jsonobject ) ; if ( ftreeviewer . getsorter ( ) == null ) sortbyfield ( getsortbyfield ( ) ) ; } else { setpartname ( default_part_name ) ; } }	update the content of the outline view .
@ override public void paint ( graphics g ) { g . drawimage ( image , _num , _num , this ) ; if ( ! paintcalled ) { paintcalled = _bool ; synchronized ( this ) { notifyall ( ) ; } } }	paints the image on the window .
@ override public boolean connectionallowed ( string eventname ) { if ( m_listenees . containskey ( eventname ) ) { return _bool ; } return _bool ; }	returns true if , at this time , the object will accept a connection with respect to the named event.
public boolean isprefixed ( ) { return name . indexof ( _str ) >= _num ; }	it returns true if the attribute is prefixed ( used the " : " character ) .
public void releaseanyconnection ( connection connection ) throws sqlexception { try { connection . close ( ) ; } catch ( exception ex ) { throw new runtimeexception ( ex ) ; } }	release a non - shard - specific connection .
public quickactionview addactions ( collection < action > actions ) { checkshown ( ) ; mactions . addall ( actions ) ; return this ; }	adds a collection of actions to the quickactionview.
public void addseriesrenderer ( int index , simpleseriesrenderer renderer ) { mrenderers . add ( index , renderer ) ; }	adds a simple renderer to the multiple renderer .
public static boolean copystream ( inputstream is , outputstream os , copylistener listener , int buffersize ) throws ioexception { int current = _num ; int total = is . available ( ) ; if ( total <= _num ) { total = default_image_total_size ; } final byte [ ] bytes = new byte [ buffersize ] ; int count ; if ( shouldstoploading ( listener , current , total ) ) return _bool ; while ( ( count = is . read ( bytes , _num , buffersize ) ) != - _num ) { os . write ( bytes , _num , count ) ; current += count ; if ( shouldstoploading ( listener , current , total ) ) return _bool ; } os . flush ( ) ; return _bool ; }	copies stream , fires progress events by listener , can be interrupted by listener .
private float calcangle ( float value ) { return value / mdata . getyvaluesum ( ) * _num ; }	calculates the needed angle for a given value.
public synchronized void returnbuf ( byte [ ] buf ) { if ( buf == null || buf . length > msizelimit ) { return ; } mbuffersbylastuse . add ( buf ) ; int pos = collections . binarysearch ( mbuffersbysize , buf , buf_comparator ) ; if ( pos < _num ) { pos = - pos - _num ; } mbuffersbysize . add ( pos , buf ) ; mcurrentsize += buf . length ; trim ( ) ; }	returns a buffer to the pool , throwing away old buffers if the pool would exceed its allotted size .
protected < t extends abstractoptionvalue < ? , ? > > abstractoptions ( function < t , t > valuefilter , abstractoptions baseoptions , iterable < t > values ) { requirenonnull ( baseoptions , _str ) ; requirenonnull ( valuefilter , _str ) ; requirenonnull ( values , _str ) ; valuemap = new identityhashmap < > ( baseoptions . valuemap ) ; putall ( valuefilter , streamsupport . stream ( values . spliterator ( ) , _bool ) ) ; }	creates a new instance .
public charseq concat ( charseq another ) { return new charseq ( str + another . str ) ; }	append string of the given charseq to this charseq.
@ override protected void doget ( httpservletrequest req , httpservletresponse resp ) throws servletexception , ioexception { resp . setcontenttype ( _str ) ; printwriter sendtoclient = resp . getwriter ( ) ; for ( video v : this . videos ) { sendtoclient . write ( v . getname ( ) + _str + v . geturl ( ) + _str ) ; } }	this method processes all of the http get requests routed to the servlet by the web container.
protected void notifystatechange ( int oldstate , int newstate ) { mstate = newstate ; if ( oldstate != newstate ) { firepropertychange ( _str , integer . valueof ( oldstate ) , integer . valueof ( newstate ) ) ; } }	change the stored state value and do notification , but don ' t change anything in the hardware.
public void test_getorder ( ) { assertequals ( _str , biginteger . valueof ( _num ) , ecps . getorder ( ) ) ; }	test for getorder ( ) method.
private void formatandlogthrowable ( logginglevel level , color color , string msg , throwable t ) { if ( ! use_colors ) { formatandlogthrowable ( level , msg , t ) ; return ; } if ( photonlogger . level . id < level . id ) { return ; } localdatetime datetime = localdatetime . now ( ) ; string formatted = formatlogline ( level , datetime , msg ) ; loggingservice . logthrowable ( datetime , t , formatted , color ) ; }	formats and logs a message with a throwable .
public static string constructqueuerediskey ( string queuename , string shardname , int priority , pinlaterjobstate state ) { return string . format ( _str , pinlater_queue_key_prefix , shardname , queuename , priority , state . getvalue ( ) ) ; }	constructs the redis queue sorted set key name given a queue name , shard id and priority .
public static string decodecharset ( string s , string charset ) { if ( s == null ) { return null ; } try { byte buf [ ] = s . getbytes ( ascii_charset ) ; return ( new string ( buf , _num , buf . length , charset ) ) ; } catch ( unsupportedencodingexception uee ) { return s ; } }	decodes the string into specified charset.
public void addrestricteddomain ( string domainname ) { if ( stringutils . isempty ( domainname ) ) { return ; } if ( restricteddomains == null ) { restricteddomains = new arraylist < > ( ) ; } restricteddomains . add ( domainname ) ; }	adds specified domain name to the list of restricted domains.
stoppablereadlock ( readwritelock lock , cancelcriterion stopper ) { this . lock = lock . readlock ( ) ; this . stopper = stopper ; }	create a new read lock from the given lock.
public void testisautoincrement ( ) { try { assertfalse ( rsmd . isautoincrement ( _num ) ) ; } catch ( sqlexception e1 ) { fail ( _str + e1 . getmessage ( ) ) ; e1 . printstacktrace ( ) ; } try { conn . close ( ) ; rsmd . getschemaname ( _num ) ; fail ( _str ) ; } catch ( sqlexception e ) { } }	tests fail : always returns false , failing statements commented out.
public static void copy ( byte [ ] in , outputstream out ) throws ioexception { assert . notnull ( in , _str ) ; assert . notnull ( out , _str ) ; out . write ( in ) ; }	copy the contents of the given byte array to the given outputstream.
public boolean isempty ( ) { return items . isempty ( ) ; }	returns true whether this page doesn ' t contain items , returns false if it does .
private static native boolean renderframe ( int [ ] pixels , long giffileinptr , int [ ] metadata ) ;	decodes a frame if needed .
public static boolean isvalidncname ( string ncname ) { if ( ncname . length ( ) == _num ) return _bool ; char ch = ncname . charat ( _num ) ; if ( isncnamestart ( ch ) == _bool ) return _bool ; for ( int i = _num ; i < ncname . length ( ) ; i ++ ) { ch = ncname . charat ( i ) ; if ( isncname ( ch ) == _bool ) { return _bool ; } } return _bool ; }	check to see if a string is a valid ncname according to [ 4 ] from the xml namespaces 1 . 0 recommendation.
public repeatedfieldbuilder < mtype , btype , itype > addmessage ( mtype message ) { if ( message == null ) { throw new nullpointerexception ( ) ; } ensuremutablemessagelist ( ) ; messages . add ( message ) ; if ( builders != null ) { builders . add ( null ) ; } onchanged ( ) ; incrementmodcounts ( ) ; return this ; }	appends the specified element to the end of this list .
protected void preparedataset ( ) { dataset1 = arrays . aslist ( new string [ ] { _str , _str , _str } ) ; dataset2 = arrays . aslist ( new string [ ] { _str , _str , _str } ) ; dataset3 = arrays . aslist ( new string [ ] { _str , _str , _str , _str } ) ; }	prepare the dataset required for running test cases.
private serviceregistrar [ ] buildserviceregistrar ( ) { int k = _num ; serviceregistrar [ ] proxys = new serviceregistrar [ proxyregset . size ( ) ] ; iterator iter = proxyregset . iterator ( ) ; while ( iter . hasnext ( ) ) { proxyreg reg = ( proxyreg ) iter . next ( ) ; proxys [ k ++ ] = reg . proxy ; } return proxys ; }	returns array of serviceregistrar created from the proxyregset.
private static boolean checkvalue ( string val ) throws malformedobjectnameexception { if ( val == null ) throw new nullpointerexception ( _str ) ; final int len = val . length ( ) ; if ( len == _num ) return _bool ; final char [ ] s = val . tochararray ( ) ; final int [ ] result = parsevalue ( s , _num ) ; final int endvalue = result [ _num ] ; final boolean value_pattern = result [ _num ] == _num ; if ( endvalue < len ) throw new malformedobjectnameexception ( _str + s [ endvalue ] + _str ) ; return value_pattern ; }	check if the supplied value is a valid value .
private synchronized void rebuildjournal ( ) throws ioexception { if ( journalwriter != null ) { journalwriter . close ( ) ; } writer writer = new bufferedwriter ( new filewriter ( journalfiletmp ) , io_buffer_size ) ; writer . write ( magic ) ; writer . write ( _str ) ; writer . write ( version_1 ) ; writer . write ( _str ) ; writer . write ( integer . tostring ( appversion ) ) ; writer . write ( _str ) ; writer . write ( integer . tostring ( valuecount ) ) ; writer . write ( _str ) ; writer . write ( _str ) ; for ( entry entry : lruentries . values ( ) ) { if ( entry . currenteditor != null ) { writer . write ( dirty + _str + entry . key + _str ) ; } else { writer . write ( clean + _str + entry . key + entry . getlengths ( ) + _str ) ; } } writer . close ( ) ; journalfiletmp . renameto ( journalfile ) ; journalwriter = new bufferedwriter ( new filewriter ( journalfile , _bool ) , io_buffer_size ) ; }	creates a new journal that omits redundant information.
public void remove ( ) throws recurrenceinfoexception { list < recurrencerule > ruleslist = new arraylist < recurrencerule > ( ) ; ruleslist . addall ( rruleslist ) ; ruleslist . addall ( eruleslist ) ; try { for ( recurrencerule rule : ruleslist ) rule . remove ( ) ; info . remove ( ) ; } catch ( recurrenceruleexception rre ) { throw new recurrenceinfoexception ( rre . getmessage ( ) , rre ) ; } catch ( genericentityexception gee ) { throw new recurrenceinfoexception ( gee . getmessage ( ) , gee ) ; } }	removes the recurrence from persistant store .
public void addnodesindocorder ( dtmiterator iterator , xpathcontext support ) { if ( ! m_mutable ) throw new runtimeexception ( xslmessages . createxpathmessage ( xpatherrorresources . er_nodesetdtm_not_mutable , null ) ) ; int node ; while ( dtm . null != ( node = iterator . nextnode ( ) ) ) { addnodeindocorder ( node , support ) ; } }	copy nodelist members into this nodelist , adding in document order.
protected boolean needtorefetchdata ( ) { long now = system . currenttimemillis ( ) ; long last = lastdatafetchtime ; if ( ( last + fetchintervalmillis ) < now ) { lastdatafetchtime = now ; return _bool ; } return _bool ; }	fetches data if it hasn ' t been fetched in a while .
@ override public documenttype createdocumenttype ( string qualifiedname , string publicid , string systemid ) { checkqname ( qualifiedname ) ; return new documenttypeimpl ( null , qualifiedname , publicid , systemid ) ; }	introduced in dom level 2.
public byte [ ] tobytes ( ) { try { bytearrayoutputstream out = new bytearrayoutputstream ( ) ; _field . store ( out , null ) ; return out . tobytearray ( ) ; } catch ( ioexception e ) { throw new illegalstateexception ( e ) ; } }	serializes this nested object into byte [ ].
@ suppresswarnings ( _str ) public static < e extends enum < ? extends style . hascssname > > e fromstylename ( final string stylename , final class < e > enumclass , final e defaultvalue ) { if ( stylename == null || enumclass == null ) { return defaultvalue ; } for ( final enum < ? extends style . hascssname > constant : enumclass . getenumconstants ( ) ) { final style . hascssname anenum = ( style . hascssname ) constant ; final string cssclass = anenum . getcssname ( ) ; if ( cssclass != null && stylehelper . containsstyle ( stylename , cssclass ) ) { return ( e ) anenum ; } } return defaultvalue ; }	returns first enum constant found in at space - separated list of style names .
@ hleunimplemented @ hlefunction ( nid = _num , version = _num , checkinsideinterrupt = _bool ) public int scempegnextavcrpau ( @ checkargument ( _str ) int mpeg , int streamuid ) { if ( ! streammap . containskey ( streamuid ) ) { log . warn ( string . format ( _str , streamuid ) ) ; return - _num ; } int result = hlempeggetavcau ( null ) ; if ( result != _num ) { if ( log . isdebugenabled ( ) ) { log . debug ( string . format ( _str , result ) ) ; } return result ; } videoframecount ++ ; startedmpeg = _bool ; return _num ; }	scempegnextavcrpau - skip one video frame.
private map < uri , exportmask > createexportmaskmap ( set < uri > placedmasks ) { map < uri , exportmask > exportmaskmap = new hashmap < > ( ) ; iterator < exportmask > exportmaskiterator = dbclient . queryiterativeobjects ( exportmask . class , placedmasks , _bool ) ; while ( exportmaskiterator . hasnext ( ) ) { exportmask exportmask = exportmaskiterator . next ( ) ; exportmaskmap . put ( exportmask . getid ( ) , exportmask ) ; } return exportmaskmap ; }	given a set of exportmask uris , return a map of exportmask uri to exportmask object.
public immutablearray2 < k > insert ( int index , k obj ) { int len = length + _num ; int newlen = len ; boolean extendable ; if ( index == len - _num ) { atomicboolean x = canextend ; if ( x != null ) { canextend = null ; if ( array . length > index && x . getandset ( _bool ) ) { array [ index ] = obj ; return new immutablearray2 < k > ( array , len , _bool ) ; } } extendable = _bool ; newlen = len + _num ; } else { extendable = _bool ; } @ suppresswarnings ( _str ) k [ ] a2 = ( k [ ] ) new object [ newlen ] ; datautils . copywithgap ( array , a2 , length , index ) ; a2 [ index ] = obj ; return new immutablearray2 < k > ( a2 , len , extendable ) ; }	insert an entry at this index .
public void writenoscale ( image c , component i ) { if ( page == null ) { newpage ( ) ; } int x = x0 + width - ( c . getwidth ( null ) + charwidth ) ; int y = y0 + ( linenum * lineheight ) + lineascent ; if ( page != null && pagenum >= prfirst ) { page . drawimage ( c , x , y , c . getwidth ( null ) , c . getheight ( null ) , null ) ; } }	write a graphic to the printout.
public void putdocumentincache ( int n , source source ) { int cachednode = getnode ( source ) ; if ( dtm . null != cachednode ) { if ( ! ( cachednode == n ) ) throw new runtimeexception ( _str + _str + source . getsystemid ( ) ) ; return ; } if ( null != source . getsystemid ( ) ) { m_sourcetree . addelement ( new sourcetree ( n , source . getsystemid ( ) ) ) ; } }	put the source tree root node in the document cache.
private void updateprogress ( string progresslabel , int progress ) { if ( myhost != null && ( ( progress != previousprogress ) || ( ! progresslabel . equals ( previousprogresslabel ) ) ) ) { myhost . updateprogress ( progresslabel , progress ) ; } previousprogress = progress ; previousprogresslabel = progresslabel ; }	used to communicate a progress update between a plugin tool and the main whitebox user interface .
public static void copy ( inputstream is , resource out , boolean closeis ) throws ioexception { outputstream os = null ; try { os = tobufferedoutputstream ( out . getoutputstream ( ) ) ; } catch ( ioexception ioe ) { ioutil . closeel ( os ) ; throw ioe ; } copy ( is , os , closeis , _bool ) ; }	copy a input resource to a output resource.
public string fadeaudio ( string path , string type , double fadeinlength , double stoptime , double fadeoutlength ) throws ioexception { final list < string > curves = arrays . aslist ( new string [ ] { _str , _str , _str , _str , _str } ) ; if ( ! curves . contains ( type ) ) { throw new runtimeexception ( _str + type ) ; } file file = new file ( path ) ; string outfile = file . getcanonicalpath ( ) + _str ; arraylist < string > cmd = new arraylist < string > ( ) ; cmd . add ( soxbin ) ; cmd . add ( path ) ; cmd . add ( outfile ) ; cmd . add ( _str ) ; cmd . add ( type ) ; cmd . add ( fadeinlength + _str ) ; if ( stoptime != - _num ) cmd . add ( stoptime + _str ) ; if ( fadeoutlength != - _num ) cmd . add ( fadeoutlength + _str ) ; try { int rc = execsox ( cmd , callback ) ; if ( rc != _num ) { outfile = null ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } return outfile ; }	fade audio file sox < path > outfile fade < type > < fadeinlength > < stoptime > < fadeoutlength >.
@ override public void draw ( canvas canvas ) { super . draw ( canvas ) ; if ( medgeglowtop != null ) { final int scrollx = getscrollx ( ) ; if ( ! medgeglowtop . isfinished ( ) ) { final int restorecount = canvas . save ( ) ; final int toppadding = mlistpadding . top + mglowpaddingtop ; final int bottompadding = mlistpadding . bottom + mglowpaddingbottom ; final int height = getheight ( ) - toppadding - bottompadding ; int edgex = math . min ( _num , scrollx + mfirstpositiondistanceguess ) ; canvas . rotate ( - _num ) ; canvas . translate ( - getheight ( ) + toppadding , edgex ) ; medgeglowtop . setsize ( height , height ) ; if ( medgeglowtop . draw ( canvas ) ) { invalidate ( ) ; } canvas . restoretocount ( restorecount ) ; } if ( ! medgeglowbottom . isfinished ( ) ) { final int restorecount = canvas . save ( ) ; final int toppadding = mlistpadding . left + mglowpaddingtop ; final int bottompadding = mlistpadding . right + mglowpaddingbottom ; final int height = getheight ( ) - toppadding - bottompadding ; final int width = getwidth ( ) ; int edgex = math . max ( width , scrollx + mlastpositiondistanceguess ) ; canvas . rotate ( _num ) ; canvas . translate ( - toppadding , - edgex ) ; medgeglowbottom . setsize ( height , height ) ; if ( medgeglowbottom . draw ( canvas ) ) { invalidate ( ) ; } canvas . restoretocount ( restorecount ) ; } } }	todo : to be implemented.
public static classproperties loadproperties ( class [ ] cls , properties properties , boolean inherit ) { classproperties cp = new classproperties ( properties ) ; for ( class c : cls ) { cp . load ( c , inherit ) ; } return cp ; }	for all the classes , loads all properties from each class annotations for the given platform .
public void testcase20 ( ) { byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num } ; byte rbytes [ ] = { _num , _num , _num , _num , _num , _num , _num } ; int bsign = _num ; biginteger anumber = biginteger . zero ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . add ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	add a number to zero.
private static void fixgpstimestamp ( xmpnode exifschema ) throws xmpexception { xmpnode gpsdatetime = xmpnodeutils . findchildnode ( exifschema , _str , _bool ) ; if ( gpsdatetime == null ) { return ; } try { xmpdatetime bingpsstamp ; xmpdatetime binotherdate ; bingpsstamp = xmputils . converttodate ( gpsdatetime . getvalue ( ) ) ; if ( bingpsstamp . getyear ( ) != _num || bingpsstamp . getmonth ( ) != _num || bingpsstamp . getday ( ) != _num ) { return ; } xmpnode otherdate = xmpnodeutils . findchildnode ( exifschema , _str , _bool ) ; if ( otherdate == null ) { otherdate = xmpnodeutils . findchildnode ( exifschema , _str , _bool ) ; } binotherdate = xmputils . converttodate ( otherdate . getvalue ( ) ) ; calendar cal = bingpsstamp . getcalendar ( ) ; cal . set ( calendar . year , binotherdate . getyear ( ) ) ; cal . set ( calendar . month , binotherdate . getmonth ( ) ) ; cal . set ( calendar . day_of_month , binotherdate . getday ( ) ) ; bingpsstamp = new xmpdatetimeimpl ( cal ) ; gpsdatetime . setvalue ( xmputils . convertfromdate ( bingpsstamp ) ) ; } catch ( xmpexception e ) { return ; } }	fixes the gps timestamp in exif .
protected boolean cellconsumeseventtype ( cell < ? > cell , string eventtype ) { set < string > consumedevents = cell . getconsumedevents ( ) ; return consumedevents != null && consumedevents . contains ( eventtype ) ; }	check if a cell consumes the specified event type .
public int read ( ) throws ioexception { int b0 = finputstream . read ( ) ; if ( b0 > _num ) { throw new ioexception ( localizer . getmessage ( _str , integer . tostring ( b0 ) ) ) ; } return b0 ; }	read a single character.
protected void create_y_axis ( int i ) { log . e ( _str , i + _str ) ; float ver_height = ( ( graphheight / label_size ) * i ) + border ; if ( i == largest_value_set . size ( ) - _num ) canvas . drawline ( horstart , ver_height , width - ( border ) , ver_height , paint ) ; else canvas . drawline ( horstart , ver_height , border , ver_height , paint ) ; paint . setcolor ( color . black ) ; int y_labels = ( int ) size - _num - i ; string y_labels = string . format ( _str , y_labels * y_axis_ratio ) ; paint . settextalign ( paint . align . right ) ; canvas . drawtext ( y_labels , horstart - _num , ver_height - _num , paint ) ; paint . settextalign ( paint . align . left ) ; }	this function is used to plot the y axis and its breakdown with value . uses drawline ( ) method to create the y axis and lines to show breakdown of y axis and drawtext ( ) method to plot labels related with breakdowns.
public long max ( ) { return deltamax . get ( ) ; }	get running - maximum time - delta , in nanoseconds .
public void print ( file file ) throws ioexception { checkexec ( ) ; securitymanager sm = system . getsecuritymanager ( ) ; if ( sm != null ) { sm . checkprintjobaccess ( ) ; } checkactionsupport ( action . print ) ; checkfilevalidation ( file ) ; peer . print ( file ) ; }	prints a file with the native desktop printing facility , using the associated application ' s print command .
public void extend ( rulegrounding other ) { if ( other . isfailed ( ) ) { groundings . clear ( ) ; return ; } extend ( other . getalternatives ( ) ) ; }	extends the existing groundings with the alternative groundings.
@ override public string expect ( pattern pattern ) { final string token = read ( pattern ) ; if ( token == null ) { throw new parserexception ( _str + pattern . pattern ( ) + _str + document ) ; } return token ; }	this will attempt to read string matching the given pattern from the document at the current point indicated by the cursor.
public void testgettabletypesorder ( ) throws exception { databasemetadata dmd = con . getmetadata ( ) ; resultset rs = dmd . gettabletypes ( ) ; string previoustype = _str ; while ( rs . next ( ) ) { string type = rs . getstring ( _num ) ; asserttrue ( type . compareto ( previoustype ) >= _num ) ; previoustype = type ; } rs . close ( ) ; }	test for bug [ 974036 ] bug in 0 . 8rc1 databasemetadata method gettabletypes ( ).
private filechannel updatecache ( string filepath ) { filechannel filechannel = filenameandstreamcache . get ( filepath ) ; try { if ( null == filechannel ) { fileinputstream stream = new fileinputstream ( filepath ) ; filechannel = stream . getchannel ( ) ; filenameandstreamcache . put ( filepath , filechannel ) ; } } catch ( ioexception e ) { logger . error ( e , e . getmessage ( ) ) ; } return filechannel ; }	this method will be used to check whether stream is already present in cache or not for filepath if not present then create it and then add to cache , other wise get from cache.
public void removeswipelistener ( swipelistener listener ) { if ( mlisteners == null ) { return ; } mlisteners . remove ( listener ) ; }	removes a listener from the set of listeners.
private static string descriptorforfieldsignature ( string signature ) { return signature . replace ( _str , _str ) ; }	returns what the serialization specification calls " descriptor " given a field signature .
public void addparameters ( final namevaluepair [ ] parameters ) { log . trace ( _str ) ; if ( parameters == null ) { log . warn ( _str ) ; } else { super . clearrequestbody ( ) ; for ( int i = _num ; i < parameters . length ; i ++ ) { params . add ( parameters [ i ] ) ; } } }	adds an array of parameters to be used in the post request body.
@ pure public atom annotationinterfacetoannotationclass ( ) { byte [ ] annotationclassname_tmp = new byte [ val . length + _num ] ; system . arraycopy ( val , _num , annotationclassname_tmp , _num , val . length - _num ) ; annotationclassname_tmp [ val . length - _num ] = _str ; annotationclassname_tmp [ val . length ] = _str ; annotationclassname_tmp [ val . length + _num ] = _str ; return atom . findorcreateutf8atom ( annotationclassname_tmp ) ; }	creates an annotation name from a class name.
public boolean resourcesupportar ( integer id ) { if ( id == null ) { return _bool ; } return resourcesupportar ( id . intvalue ( ) ) ; }	checks whether a given resource id supports advanced reservations or not .
public static map < string , object > createelectronictext ( dispatchcontext dctx , map < string , ? extends object > context ) { map < string , object > result = createelectronictextmethod ( dctx , context ) ; return result ; }	a service wrapper for the createelectronictextmethod method.
public patternguardexpr ( string namespace , string name , expression [ ] parameters , patternexpr guarded ) { this ( namespace , name , arrays . aslist ( parameters ) , guarded ) ; }	ctor - for use to create a pattern expression tree , without pattern child expression .
public static int intersectlineline ( line2d a , line2d b , point2d intersect ) { double a1x = a . getx1 ( ) , a1y = a . gety1 ( ) ; double a2x = a . getx2 ( ) , a2y = a . gety2 ( ) ; double b1x = b . getx1 ( ) , b1y = b . gety1 ( ) ; double b2x = b . getx2 ( ) , b2y = b . gety2 ( ) ; return intersectlineline ( a1x , a1y , a2x , a2y , b1x , b1y , b2x , b2y , intersect ) ; }	compute the intersection of two line segments .
public static set updateandgetremovableocs ( set origset , set removeocs ) { set returnocs = removeocs ; if ( removeocs != null && ! removeocs . isempty ( ) ) { returnocs = new hashset ( ) ; iterator itr1 = origset . iterator ( ) ; while ( itr1 . hasnext ( ) ) { string origoc = ( string ) itr1 . next ( ) ; iterator itr2 = removeocs . iterator ( ) ; while ( itr2 . hasnext ( ) ) { string removeoc = ( string ) itr2 . next ( ) ; if ( origoc . equalsignorecase ( removeoc ) ) { returnocs . add ( origoc ) ; break ; } } } origset . removeall ( returnocs ) ; } return returnocs ; }	method which removes the specified object class from original set and returns the set of object classes that were removed .
public static int unixtimestamp ( ) { return ( int ) ( system . currenttimemillis ( ) / _num ) ; }	get the seconds since 1970 - 01 - 01 00 : 00 : 00 utc.
public boolean ispdflicense ( ) { string key = getsummary ( ) ; return key != null && key . length ( ) > _num ; }	is there a pdf license.
protected void drawgridbackground ( canvas c ) { if ( mdrawgridbackground ) { c . drawrect ( mviewporthandler . getcontentrect ( ) , mgridbackgroundpaint ) ; } if ( mdrawborders ) { c . drawrect ( mviewporthandler . getcontentrect ( ) , mborderpaint ) ; } }	draws the grid background.
public zipstreamimpl openreadimpl ( pathimpl path ) throws ioexception { string pathname = path . getpath ( ) ; return openreadimpl ( pathname ) ; }	opens a stream to an entry in the jar .
private static char [ ] zzunpackcmap ( string packed ) { char [ ] map = new char [ _num ] ; int i = _num ; int j = _num ; while ( i < _num ) { int count = packed . charat ( i ++ ) ; char value = packed . charat ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > _num ) ; } return map ; }	unpacks the compressed character translation table .
@ override public void ontmpfilescopied ( resultcode result ) { dismissloadingdialog ( ) ; finish ( ) ; }	process the result of copyanduploadcontenturistask.
static workqueue commonsubmitterqueue ( ) { forkjoinpool p ; workqueue [ ] ws ; int m ; submitter z ; return ( ( z = submitters . get ( ) ) != null && ( p = commonpool ) != null && ( ws = p . workqueues ) != null && ( m = ws . length - _num ) >= _num ) ? ws [ m & z . seed & sqmask ] : null ; }	returns common pool queue for a thread that has submitted at least one task .
private boolean isfieldpackageprivate ( element attribute ) { set < modifier > modifiers = attribute . getmodifiers ( ) ; return ! modifiers . contains ( public ) && ! modifiers . contains ( protected ) && ! modifiers . contains ( private ) ; }	checks if the given field has package - private visibility.
public void testdivideroundhalfuppos ( ) { string a = _str ; int ascale = - _num ; string b = _str ; int bscale = _num ; string c = _str ; int resscale = - _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; bigdecimal result = anumber . divide ( bnumber , resscale , bigdecimal . round_half_up ) ; assertequals ( _str , c , result . tostring ( ) ) ; assertequals ( _str , resscale , result . scale ( ) ) ; }	divide : rounding mode is round_half_up , result is positive ; distance = - 1.
public static string convertcodes ( string string ) { if ( string == null ) return string ; int current = _num ; char [ ] cs = string . tochararray ( ) ; stringbuilder sb = new stringbuilder ( ) ; for ( char c : cs ) { if ( current <= cs . length && c == _str ) { char tc = character . tolowercase ( cs [ current + _num ] ) ; if ( tc == _str || tc == _str || tc == _str || tc == _str || tc == _str || tc == _str || tc == _str || tc == _str || tc == _str || tc == _str || tc == _str || tc == _str || tc == _str || tc == _str || tc == _str || tc == _str || tc == _str || tc == _str || tc == _str || tc == _str || tc == _str ) { sb . append ( _str ) ; } else { sb . append ( c ) ; } } else { sb . append ( c ) ; } current ++ ; } return sb . tostring ( ) ; }	converts all color and format codes.
private void loadtext ( inputstream is ) { bufferedreader reader ; string line ; unitlist = new arraylist ( ) ; unittypeslist = new arraylist ( ) ; if ( is == null ) { throw new error ( _str ) ; } reader = new bufferedreader ( new inputstreamreader ( is ) ) ; try { line = reader . readline ( ) ; linecount ++ ; while ( line != null ) { if ( ! line . startswith ( _str ) ) { parseandadd ( line , reader ) ; } line = reader . readline ( ) ; } reader . close ( ) ; units = new databaseclusterunit [ unitlist . size ( ) ] ; units = ( databaseclusterunit [ ] ) unitlist . toarray ( units ) ; unitlist = null ; unittypes = new unittype [ unittypeslist . size ( ) ] ; unittypes = ( unittype [ ] ) unittypeslist . toarray ( unittypes ) ; unittypeslist = null ; } catch ( ioexception e ) { throw new error ( e . getmessage ( ) + _str + linecount ) ; } finally { } }	loads the database from the given input stream .
private float calculateselectorradius ( ) { if ( mfselectorradius == _num ) { int nheight = mselectedview . getheight ( ) ; int nwidth = mselectedview . getwidth ( ) ; int nlargerside = math . max ( nwidth , nheight ) ; mfselectorradius = ( ( nlargerside ^ _num ) / _num ) ; } return mfselectorradius ; }	calculate selector radius the selector radius can be calculated by a simple math calculation of the larger side .
private int measurewidth ( int measurespec ) { int result ; int specmode = measurespec . getmode ( measurespec ) ; int specsize = measurespec . getsize ( measurespec ) ; if ( specmode == measurespec . exactly ) { result = specsize ; } else { result = ( int ) mtextpaint . measuretext ( mtext ) + getpaddingleft ( ) + getpaddingright ( ) ; if ( specmode == measurespec . at_most ) { result = math . min ( result , specsize ) ; } } return result ; }	determines the width of this view.
public void test_getputbytearray ( ) { final int capacity = _num ; final bytearraybuffer buf = new bytearraybuffer ( capacity ) ; assertequals ( ( byte ) _num , buf . getbyte ( _num ) ) ; assertequals ( ( byte ) _num , buf . getbyte ( capacity - _num ) ) ; final int pos = _num ; for ( int i = _num ; i < limit ; i ++ ) { final byte [ ] expected = new byte [ r . nextint ( capacity - _num ) ] ; r . nextbytes ( expected ) ; buf . put ( pos , expected ) ; assertequals ( _num , bytesutil . comparebyteswithlenandoffset ( _num , expected . length , expected , pos , expected . length , buf . array ( ) ) ) ; final byte [ ] actual = new byte [ expected . length ] ; buf . get ( pos , actual ) ; asserttrue ( bytesutil . bytesequal ( expected , actual ) ) ; } assertequals ( ( byte ) _num , buf . getbyte ( _num ) ) ; assertequals ( ( byte ) _num , buf . getbyte ( pos + capacity - _num ) ) ; }	test bulk get / put byte [ ] methods .
@ override public void onadded ( final rpobject object ) { if ( isuser ( object ) ) { if ( object . has ( _str ) ) { adminlevel = object . getint ( _str ) ; } } }	an object was added .
private string local_number ( ) throws parseexception { stringbuilder s = new stringbuilder ( ) ; if ( debug ) dbg_enter ( _str ) ; try { int lc = _num ; while ( lexer . hasmorechars ( ) ) { char la = lexer . lookahead ( _num ) ; if ( la == _str || la == _str || la == _str || la == _str || la == _str || la == _str || lexer . ishexdigit ( la ) ) { lexer . consume ( _num ) ; s . append ( la ) ; lc ++ ; } else if ( lc > _num ) break ; else throw createparseexception ( _str + la ) ; } return s . tostring ( ) ; } finally { if ( debug ) dbg_leave ( _str ) ; } }	parser for the local phone # .
public void pathvaluestopixel ( list < path > paths ) { for ( int i = _num ; i < paths . size ( ) ; i ++ ) { pathvaluetopixel ( paths . get ( i ) ) ; } }	transforms multiple paths will all matrices .
public static byte [ ] decode ( string s ) { return decode ( s . tochararray ( ) ) ; }	decodes a byte array from base64 format.
public static void checkstate ( boolean expression , object errormessage ) { if ( exoplayerlibraryinfo . assertions_enabled && ! expression ) { throw new illegalstateexception ( string . valueof ( errormessage ) ) ; } }	ensures the truth of an expression involving the state of the calling instance .
public static void slideinfromtopanimator ( @ nonnull list < animator > animators , @ nonnull view view , recyclerview recyclerview ) { alphaanimator ( animators , view , _num ) ; animators . add ( objectanimator . offloat ( view , _str , - recyclerview . getmeasuredheight ( ) > > _num , _num ) ) ; if ( flexibleadapter . debug ) log . v ( tag , _str ) ; }	item will slide from top of the screen to its natural position .
mutablebiginteger ( mutablebiginteger val ) { intlen = val . intlen ; value = arrays . copyofrange ( val . value , val . offset , val . offset + intlen ) ; }	construct a new mutablebiginteger with a magnitude equal to the specified mutablebiginteger .
@ requestmapping ( value = _str ) public void ssobindingerror ( locale locale , @ pathvariable ( value = _str ) string tenant , httpservletresponse response ) throws ioexception { logger . info ( _str + locale . tostring ( ) + _str + tenant ) ; ssodefaulttenanterror ( locale , response ) ; }	handle request sent with a wrong binding.
public checkpointmanager ( networkparameters params , @ nullable inputstream inputstream ) throws ioexception { this . params = checknotnull ( params ) ; if ( inputstream == null ) inputstream = openstream ( params ) ; checknotnull ( inputstream ) ; inputstream = new bufferedinputstream ( inputstream ) ; inputstream . mark ( _num ) ; int first = inputstream . read ( ) ; inputstream . reset ( ) ; if ( first == binary_magic . charat ( _num ) ) datahash = readbinary ( inputstream ) ; else if ( first == textual_magic . charat ( _num ) ) datahash = readtextual ( inputstream ) ; else throw new ioexception ( _str ) ; }	loads the checkpoints from the given stream.
public indexsegmentindex ( irawstore store , checkpoint checkpoint , indexmetadata metadata , boolean readonly ) { super ( store , checkpoint , metadata , readonly ) ; }	load from the store .
private string liveness ( ) { boolean isclosed = _bool ; try { if ( isclosed ( ) ) { isclosed = _bool ; } } catch ( sqlexception s ) { isclosed = _bool ; } if ( isclosed ) { return _str ; } return _str ; }	provides a string representation of whether this connection is closed or not.
private static void insertvalue ( final map < string , list < string > > paramsmap , final string paramval , final string parametername ) { if ( paramval != null ) { list < string > list = new arraylist < > ( ) ; list . add ( paramval ) ; paramsmap . put ( parametername , list ) ; } }	puts the given parameter value into a new list object then adds it to the map .
public dimension minimumlayoutsize ( container target ) { dimension size ; synchronized ( this ) { checkcontainer ( target ) ; checkrequests ( ) ; size = new dimension ( xtotal . minimum , ytotal . minimum ) ; } insets insets = target . getinsets ( ) ; size . width = ( int ) math . min ( ( long ) size . width + ( long ) insets . left + ( long ) insets . right , integer . max_value ) ; size . height = ( int ) math . min ( ( long ) size . height + ( long ) insets . top + ( long ) insets . bottom , integer . max_value ) ; return size ; }	returns the minimum dimensions needed to lay out the components contained in the specified target container .
public boolean select ( int position ) { view v = malllist . get ( position ) ; if ( mmultichoiceadapter != null ) { performvibrate ( ) ; performselect ( v , position , _bool ) ; return _bool ; } return _bool ; }	select a view from position in the adapter.
@ override public enumeration < option > listoptions ( ) { vector < option > result = new vector < option > ( ) ; result . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; result . addall ( collections . list ( super . listoptions ( ) ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
@ override public void ignorablewhitespace ( xmlstring text , augmentations augs ) throws xniexception { if ( ! fincludeignorablewhitespace || ffilterreject ) { return ; } if ( ! fdefernodeexpansion ) { node child = fcurrentnode . getlastchild ( ) ; if ( child != null && child . getnodetype ( ) == node . text_node ) { text textnode = ( text ) child ; textnode . appenddata ( text . tostring ( ) ) ; } else { text textnode = fdocument . createtextnode ( text . tostring ( ) ) ; if ( fdocumentimpl != null ) { textimpl textnodeimpl = ( textimpl ) textnode ; textnodeimpl . setignorablewhitespace ( _bool ) ; } fcurrentnode . appendchild ( textnode ) ; } } else { int txt = fdeferreddocumentimpl . createdeferredtextnode ( text . tostring ( ) , _bool ) ; fdeferreddocumentimpl . appendchild ( fcurrentnodeindex , txt ) ; } }	ignorable whitespace . for this method to be called , the document source must have some way of determining that the text containing only whitespace characters should be considered ignorable . for example , the validator can determine if a length of whitespace characters in the document are ignorable based on the element content model .
private static final void waitforeditortobeactive ( ieditorpart internalfileeditor , iworkbenchpage page ) { long start = system . currenttimemillis ( ) ; long end = start ; do { end = system . currenttimemillis ( ) ; } while ( page . getactiveeditor ( ) != internalfileeditor && ( end - start ) < _num ) ; if ( page . getactiveeditor ( ) != internalfileeditor ) logger . warn ( _str ) ; }	get editor for provided file , returns once editor is active or after timeout.
private solution largestobjectivevalue ( int objective , population population ) { solution largest = null ; double value = double . negative_infinity ; for ( solution solution : population ) { if ( solution . getobjective ( objective ) > value ) { largest = solution ; value = solution . getobjective ( objective ) ; } } return largest ; }	returns the solution with the largest objective value for the given objective .
public static int convertlatmtoy ( int latm ) { long v = math . round ( ( mercator . max_y - mercator . lat2y ( latm / latlon_to_latlonm ) ) * max_ap_units / ( mercator . max_y * _num ) ) ; if ( v > max_ap_units ) return max_ap_units ; if ( v < _num ) return - _num ; return ( int ) v ; }	returns the y position based on latitude.
public void registercallbackhandler ( smsobjectlistener changelistener ) throws smsexception { objectlistener = changelistener ; if ( ! notificationinitialized ) { string notificationflag = systemproperties . get ( notification_property , _str ) ; if ( notificationflag . equalsignorecase ( _str ) ) { try { url url = webtopnaming . getnotificationurl ( ) ; pllclient . addnotificationhandler ( jaxrpcutil . sms_service , new smsnotificationhandler ( ) ) ; client . send ( _str , url . tostring ( ) , null , null ) ; if ( debug . messageenabled ( ) ) { debug . message ( _str + _str + url ) ; } } catch ( exception e ) { if ( debug . warningenabled ( ) ) { debug . warning ( _str + _str + e . getmessage ( ) + _str ) ; } startpollingthreadifenabled ( getcachepollinginterval ( ) ) ; } } else { startpollingthreadifenabled ( getcachepollinginterval ( ) ) ; } notificationinitialized = _bool ; } }	registration for event change notifications . only smsnotificationmanager would be calling this method to register itself.
public static nsobject parse ( inputstream in ) throws parseexception , ioexception { byte [ ] buf = propertylistparser . readall ( in ) ; in . close ( ) ; return parse ( buf ) ; }	parses an ascii property list from an input stream .
protected double currentscorefunction ( ) { double score = _num ; for ( int i = _num ; i < this . values [ this . currentvar1 ] . length ; i ++ ) { for ( int j = _num ; j < this . values [ this . currentvar2 ] . length ; j ++ ) { score -= this . currentcounts [ this . currentvar1 ] [ this . currentvar2 ] [ i ] [ j ] * math . log ( this . currentpi [ i ] [ j ] ) ; } } return score ; }	function to be minimized : - loglikelihood.
public grammaticalityestimator ( set filenames , int iminchar , int imaxchar , int icharwindow , int iminword , int imaxword , int iwordwindow ) { imincharngram = iminchar ; imaxcharngram = imaxchar ; iminwordngram = iminword ; imaxwordngram = imaxword ; iworddist = iwordwindow ; ichardist = icharwindow ; distrodocs = new treemap < integer , distributiondocument > ( ) ; distroworddocs = new treemap < integer , distributionworddocument > ( ) ; stringbuffer sb = new stringbuffer ( ) ; iterator itexts = filenames . iterator ( ) ; while ( itexts . hasnext ( ) ) { string sfile = ( string ) itexts . next ( ) ; try { bufferedreader bf = new bufferedreader ( new filereader ( sfile ) ) ; string stmp ; while ( ( stmp = bf . readline ( ) ) != null ) sb . append ( stmp ) ; bf . close ( ) ; } catch ( filenotfoundexception ex ) { ex . printstacktrace ( system . err ) ; } catch ( ioexception ex ) { ex . printstacktrace ( system . err ) ; } sb . append ( ( char ) _num ) ; } fulltextdatastring = sb . tostring ( ) ; for ( int icnt = imincharngram ; icnt <= imaxcharngram ; icnt ++ ) { distrodocs . put ( icnt , new distributiondocument ( ichardist , icnt ) ) ; } for ( int icnt = iminwordngram ; icnt <= imaxwordngram ; icnt ++ ) { distroworddocs . put ( icnt , new distributionworddocument ( iworddist , icnt ) ) ; } }	creates a new instance of grammaticalityestimator , using a given set of documents for training .
private int checkzonelink ( spannablestringbuilder out , string in , int start ) { int pos = start + _num ; stringbuilder temp = new stringbuilder ( ) ; string targetstring = in . substring ( pos , math . min ( in . length ( ) , pos + _num ) ) ; boolean previsdash = _bool ; for ( int i = _num ; i < targetstring . length ( ) ; i ++ ) { char c = targetstring . charat ( i ) ; if ( ( c >= _str && c <= _str ) || ( c >= _str && c <= _str ) ) { temp . append ( c ) ; previsdash = _bool ; } else if ( c == _str ) { if ( i == _num ) { return - _num ; } if ( previsdash ) { temp . deletecharat ( temp . length ( ) - _num ) ; break ; } temp . append ( c ) ; previsdash = _bool ; } else { if ( previsdash ) { temp . deletecharat ( temp . length ( ) - _num ) ; } break ; } } string zone = temp . tostring ( ) ; if ( zone . length ( ) < _num || zone . equalsignorecase ( _str ) ) { return - _num ; } out . append ( zone ) ; return pos + zone . length ( ) - _num ; }	change this should review zone . java.
public static void checkvalid ( double [ ] x ) { for ( double v : x ) { if ( double . isnan ( v ) ) { throw new runtimeexception ( _str + v ) ; } } }	loop and ensure all elements are non - infiite and non - nan , throws an exception if one is.
protected void processconnectionevent ( connectionevent event ) { for ( enumeration < connectionlistener > e = connectionlisteners . elements ( ) ; e . hasmoreelements ( ) ; ) { connectionlistener l = e . nextelement ( ) ; switch ( event . gettype ( ) ) { case connectionevent . connected : l . connected ( ( connectedevent ) event ) ; break ; case connectionevent . disconnected : l . disconnected ( ( disconnectedevent ) event ) ; break ; case connectionevent . packet_received : l . packetreceived ( ( packetreceivedevent ) event ) ; break ; } } }	processes game events occurring on this connection by dispatching them to any registered gamelistener objects .
public double percentage ( constantrange range ) { sortedset < constant > sorted = values ( ) ; sortedset < constant > contained = new treeset < constant > ( ) ; constant prev = null ; for ( constant pct : sorted ) { if ( range . contains ( pct ) ) contained . add ( pct ) ; else if ( contained . isempty ( ) ) prev = pct ; } if ( contained . size ( ) == _num ) return _num ; double prevpercent = prev == null ? _num : pcts . get ( prev ) ; return pcts . get ( contained . last ( ) ) - prevpercent ; }	gets the percent of values within the specified value range .
public static void closequiet ( @ nullable closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( ioexception ignored ) { } } }	closes resource without reporting any error .
@ override public void releaseluceepagecontext ( pagecontext pc , boolean register ) { if ( pc . getid ( ) < _num ) return ; pc . release ( ) ; threadlocalpagecontext . release ( ) ; runningpcs . remove ( integer . valueof ( pc . getid ( ) ) ) ; if ( pcs . size ( ) < _num && pc . getrequesttimeoutexception ( ) == null ) pcs . push ( pc ) ; }	similar to the releasepagecontext method , but take lucee pagecontext as entry.
public void addeventlistener ( sipdialogeventlistener newlistener ) { eventlisteners . add ( newlistener ) ; }	adds a new event listener to this dialog .
private boolean journalrebuildrequired ( ) { final int redundantopcompactthreshold = _num ; return redundantopcount >= redundantopcompactthreshold && redundantopcount >= lruentries . size ( ) ; }	we only rebuild the journal when it will halve the size of the journal and eliminate at least 2000 ops .
private static byte [ ] stringtobytearray ( string str ) { if ( str == null ) { return null ; } byte [ ] srcbyte = str . getbytes ( ) ; int srclength = srcbyte . length ; byte [ ] result = new byte [ srclength + _num ] ; system . arraycopy ( srcbyte , _num , result , _num , srclength ) ; result [ srclength ] = _num ; return result ; }	returns this java string as a null - terminated byte array.
public static properties loadproperties ( classloader classloader , string classpathresource ) { return loadproperties ( null , classpathresource ) ; }	atomically load the properties file at the given location within the designated class loader .
@ override public boolean equals ( object o ) { if ( o instanceof graph ) { return string . equals ( o . tostring ( ) ) ; } return _bool ; }	returns true if the object is a graph with the same content .
public final static namevaluepair parsenamevaluepair ( final string value , headervalueparser parser ) throws parseexception { if ( value == null ) { throw new illegalargumentexception ( _str ) ; } if ( parser == null ) parser = saveheadervalueparser . default ; chararraybuffer buffer = new chararraybuffer ( value . length ( ) ) ; buffer . append ( value ) ; saveparsercursor cursor = new saveparsercursor ( _num , value . length ( ) ) ; return parser . parsenamevaluepair ( buffer , cursor ) ; }	parses a name - value - pair with the given parser .
private void pullevent ( ) { final int newscrollvalue ; final int itemdimension ; final float initialmotionvalue , lastmotionvalue ; switch ( getpulltorefreshscrolldirection ( ) ) { case horizontal : initialmotionvalue = minitialmotionx ; lastmotionvalue = mlastmotionx ; break ; case vertical : default : initialmotionvalue = minitialmotiony ; lastmotionvalue = mlastmotiony ; break ; } switch ( mcurrentmode ) { case pull_from_end : newscrollvalue = math . round ( math . max ( initialmotionvalue - lastmotionvalue , _num ) / friction ) ; itemdimension = getfootersize ( ) ; break ; case pull_from_start : default : newscrollvalue = math . round ( math . min ( initialmotionvalue - lastmotionvalue , _num ) / friction ) ; itemdimension = getheadersize ( ) ; break ; } setheaderscroll ( newscrollvalue ) ; if ( newscrollvalue != _num && ! isrefreshing ( ) ) { float scale = math . abs ( newscrollvalue ) / ( float ) itemdimension ; switch ( mcurrentmode ) { case pull_from_end : mfooterlayout . onpull ( scale ) ; break ; case pull_from_start : default : mheaderlayout . onpull ( scale ) ; break ; } if ( mstate != state . pull_to_refresh && itemdimension >= math . abs ( newscrollvalue ) ) { setstate ( state . pull_to_refresh ) ; } else if ( mstate == state . pull_to_refresh && itemdimension < math . abs ( newscrollvalue ) ) { setstate ( state . release_to_refresh ) ; } } }	actions a pull event.
private static mappingobject objectat ( pcallocation loc , mappingobject [ ] [ ] map ) { return map [ loc . getline ( ) ] [ loc . getcolumn ( ) ] ; }	returns the mappingobject at the location in map indicated by loc .
public string parse ( file file , json m ) { try { template template = gettemplate ( file ) ; if ( template != null ) { stringwriter w = new stringwriter ( ) ; bufferedwriter writer = new bufferedwriter ( w ) ; template . merge ( new velocitycontext ( m ) , writer ) ; writer . flush ( ) ; writer . close ( ) ; return w . tostring ( ) ; } } catch ( exception e ) { log . error ( e . getmessage ( ) , e ) ; } return null ; }	parse the file to string with the json.
private linkedlist < diff > diff_main ( string text1 , string text2 , boolean checklines , long deadline ) { if ( text1 == null || text2 == null ) { throw new illegalargumentexception ( _str ) ; } linkedlist < diff > diffs ; if ( text1 . equals ( text2 ) ) { diffs = new linkedlist < diff > ( ) ; if ( text1 . length ( ) != _num ) { diffs . add ( new diff ( operation . equal , text1 ) ) ; } return diffs ; } int commonlength = diff_commonprefix ( text1 , text2 ) ; string commonprefix = text1 . substring ( _num , commonlength ) ; text1 = text1 . substring ( commonlength ) ; text2 = text2 . substring ( commonlength ) ; commonlength = diff_commonsuffix ( text1 , text2 ) ; string commonsuffix = text1 . substring ( text1 . length ( ) - commonlength ) ; text1 = text1 . substring ( _num , text1 . length ( ) - commonlength ) ; text2 = text2 . substring ( _num , text2 . length ( ) - commonlength ) ; diffs = diff_compute ( text1 , text2 , checklines , deadline ) ; if ( commonprefix . length ( ) != _num ) { diffs . addfirst ( new diff ( operation . equal , commonprefix ) ) ; } if ( commonsuffix . length ( ) != _num ) { diffs . addlast ( new diff ( operation . equal , commonsuffix ) ) ; } diff_cleanupmerge ( diffs ) ; return diffs ; }	find the differences between two texts.
public repository ( string domain , boolean fairlock ) { lock = new reentrantreadwritelock ( fairlock ) ; domaintb = new hashmap < string , map < string , namedobject > > ( _num ) ; if ( domain != null && domain . length ( ) != _num ) this . domain = domain . intern ( ) ; else this . domain = servicename . domain ; domaintb . put ( this . domain , new hashmap < string , namedobject > ( ) ) ; }	construct a new repository with the given default domain .
public int counttokens ( ) { int count = _num ; boolean intoken = _bool ; for ( int i = position , length = string . length ( ) ; i < length ; i ++ ) { if ( delimiters . indexof ( string . charat ( i ) , _num ) >= _num ) { if ( returndelimiters ) count ++ ; if ( intoken ) { count ++ ; intoken = _bool ; } } else { intoken = _bool ; } } if ( intoken ) count ++ ; return count ; }	returns the number of unprocessed tokens remaining in the string .
public static synchronized void indexdocument ( codeindexdocument codeindexdocument ) throws ioexception { queue < codeindexdocument > queue = new concurrentlinkedqueue < > ( ) ; queue . add ( codeindexdocument ) ; indexdocuments ( queue ) ; queue = null ; }	possibly better in ultra low memory environments ? reuses the above method by creating a queue with one element and passes it in .
protected void resetcommon ( ) throws xniexception { int count = fcommoncomponents . size ( ) ; for ( int i = _num ; i < count ; i ++ ) { xmlcomponent c = ( xmlcomponent ) fcommoncomponents . get ( i ) ; c . reset ( this ) ; } }	reset all common components before parsing.
protected void handle ( exception exception , string title , string message ) { utils . handleerror ( getshell ( ) , exception , title , message ) ; }	shows the given errors to the user .
private void readobject ( objectinputstream in ) throws ioexception , classnotfoundexception { in . defaultreadobject ( ) ; i18n = environment . geti18n ( ) ; beancontextchildsupport = new beancontextchildsupport ( this ) ; }	handle serialization a little bit better , replacing the i18n and beancontextchildsupport .
private void paintforegroundenabled ( graphics2d g , int width , int height ) { shape s = decodearrowpath ( width , height ) ; g . setpaint ( enabledcolor ) ; g . fill ( s ) ; }	paint the arrow in enabled state .
private static void logthrow ( level level , string classname , string methodname , string message , object [ ] args , throwable thrown ) { java . util . logging . logrecord lr = new java . util . logging . logrecord ( level , message ) ; lr . setloggername ( logger . getname ( ) ) ; lr . setsourceclassname ( classname ) ; lr . setsourcemethodname ( methodname ) ; lr . setparameters ( args ) ; lr . setthrown ( thrown ) ; logger . log ( lr ) ; }	logs a thrown exception .
public void testtobigintegerzero ( ) { string a = _str ; biginteger bnumber = new biginteger ( _str ) ; bigdecimal anumber = new bigdecimal ( a ) ; biginteger result = anumber . tobiginteger ( ) ; asserttrue ( _str , result . equals ( bnumber ) ) ; }	convert a small bigdecimal to biginteger.
public void onaccuracychanged ( sensor sensor , int accuracy ) { if ( sensor . gettype ( ) != sensor . type_accelerometer ) { return ; } if ( this . status == accellistener . stopped ) { return ; } this . accuracy = accuracy ; }	called when the accuracy of the sensor has changed .
public boolean allowstrailingarguments ( ) { return allowstrailingarguments ; }	indicates whether this sub - command will allow unnamed trailing arguments.
@ androidonly ( _str + _str ) public void testsetmaxcrlnumberljava_math_biginteger ( ) { x509crlselector selector = new x509crlselector ( ) ; biginteger maxcrl = new biginteger ( _str ) ; testcrl crl = new testcrl ( maxcrl ) ; selector . setmaxcrlnumber ( null ) ; asserttrue ( _str , selector . match ( crl ) ) ; selector . setmaxcrlnumber ( maxcrl ) ; asserttrue ( _str , selector . match ( crl ) ) ; selector . setmaxcrlnumber ( new biginteger ( _str ) ) ; assertfalse ( _str , selector . match ( crl ) ) ; }	setmaxcrlnumber ( biginteger maxcrl ) method testing.
private void evaluatepopup ( mouseevent e ) { if ( e . ispopuptrigger ( ) ) { jpopupmenu menu = createbookmarkpopupmenu ( ) ; if ( menu != null ) { menu . show ( this , e . getx ( ) , e . gety ( ) ) ; } } }	checks if the given mouse event is a popup trigger and creates a new popup menu if necessary .
private boolean removetask ( task t , int min ) { for ( int i = tasks . size ( ) ; -- i >= min ; ) { if ( tasks . get ( i ) == t ) { tasks . remove ( i ) ; if ( i < firstpending ) { firstpending -- ; for ( int j = threads . size ( ) ; -- j >= _num ; ) { taskthread thread = threads . get ( j ) ; if ( thread . task == t ) { if ( thread != thread . currentthread ( ) ) thread . interrupt ( ) ; break ; } } } return _bool ; } } return _bool ; }	remove a task if it has index > = min.
public void test_dividebigdecimalroundingmodehalf_up ( ) { string a = _str ; string b = _str ; roundingmode rm = roundingmode . half_up ; string c = _str ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) ) ; bigdecimal result = anumber . divide ( bnumber , rm ) ; assertequals ( _str , c , result . tostring ( ) ) ; }	java . math . bigdecimal # divide ( java . math . bigdecimal , java . math . roundingmode ) divide ( bigdecimal , roundingmode ).
protected void ensurepathexists ( string path ) { string [ ] paths = path . split ( _str ) ; stringbuffer spath = new stringbuffer ( _str ) ; for ( string temp : paths ) { if ( stringutils . isblank ( temp ) ) { continue ; } spath . append ( temp ) ; ensureexists ( spath . tostring ( ) , null , acl , createmode . persistent ) ; spath . append ( _str ) ; } }	ensures that the given path exists with no data , the current acl and no flags.
public class < ? > loadclass ( string name , boolean resolve ) throws classnotfoundexception { int i = name . lastindexof ( _str ) ; if ( i != - _num ) { securitymanager sm = system . getsecuritymanager ( ) ; if ( sm != null ) { sm . checkpackageaccess ( name . substring ( _num , i ) ) ; } } if ( ucp . knowntonotexist ( name ) ) { class < ? > c = findloadedclass ( name ) ; if ( c != null ) { if ( resolve ) { resolveclass ( c ) ; } return c ; } throw new classnotfoundexception ( name ) ; } return ( super . loadclass ( name , resolve ) ) ; }	override loadclass so we can checkpackageaccess .
private int measureshort ( int measurespec ) { int result ; int specmode = measurespec . getmode ( measurespec ) ; int specsize = measurespec . getsize ( measurespec ) ; if ( specmode == measurespec . exactly ) { result = specsize ; } else { result = ( int ) ( _num * mradius + getpaddingtop ( ) + getpaddingbottom ( ) + _num ) ; if ( specmode == measurespec . at_most ) { result = math . min ( result , specsize ) ; } } return result ; }	determines the height of this view.
private boolean islistchildunderclipped ( float x , float y ) { final view listchild = findlistchildunder ( x , y ) ; return listchild != null && isdescendantclipped ( listchild ) ; }	this only checks clipping along the bottom edge .
rules ( workspace workspace ) { this . root = workspace . getroot ( ) ; this . teamhook = workspace . getteamhook ( ) ; }	creates a new scheduling rule factory for the given workspace.
public static void writebytearraytofile ( file file , byte [ ] data , boolean append ) throws ioexception { outputstream out = null ; try { out = openoutputstream ( file , append ) ; out . write ( data ) ; out . close ( ) ; } finally { ioutils . closequietly ( out ) ; } }	writes a byte array to a file creating the file if it does not exist .
public void add ( @ nonnull t item ) { synchronized ( lock ) { if ( items == null ) { items = new arraylist < > ( ) ; } items . add ( item ) ; } if ( notifyonchange ) { notifyiteminserted ( items . size ( ) ) ; } }	adds the specified item to the end of the list.
private void checkpendingcustommessages ( ) { if ( joiningnodes . isempty ( ) && islocalnodecoordinator ( ) ) { tcpdiscoverycustomeventmessage msg ; while ( ( msg = pendingcustommsgs . poll ( ) ) != null ) { processcustommessage ( msg ) ; if ( msg . verified ( ) ) msghist . add ( msg ) ; } } }	checks and flushes custom event messages if no nodes are attempting to join the grid .
private static int determineconsecutivedigitcount ( charsequence msg , int startpos ) { int count = _num ; int len = msg . length ( ) ; int idx = startpos ; if ( idx < len ) { char ch = msg . charat ( idx ) ; while ( isdigit ( ch ) && idx < len ) { count ++ ; idx ++ ; if ( idx < len ) { ch = msg . charat ( idx ) ; } } } return count ; }	determines the number of consecutive characters that are encodable using numeric compaction .
protected int parseandaddnode ( xmlresourceparser parser , hashmap < string , tagparser > tagparsermap , arraylist < long > screenids ) throws xmlpullparserexception , ioexception { if ( tag_include . equals ( parser . getname ( ) ) ) { final int resid = getattributeresourcevalue ( parser , attr_workspace , _num ) ; if ( resid != _num ) { return parselayout ( resid , screenids ) ; } else { return _num ; } } mvalues . clear ( ) ; parsecontainerandscreen ( parser , mtemp ) ; final long container = mtemp [ _num ] ; final long screenid = mtemp [ _num ] ; mvalues . put ( favorites . container , container ) ; mvalues . put ( favorites . screen , screenid ) ; mvalues . put ( favorites . cellx , converttodistancefromend ( getattributevalue ( parser , attr_x ) , mcolumncount ) ) ; mvalues . put ( favorites . celly , converttodistancefromend ( getattributevalue ( parser , attr_y ) , mrowcount ) ) ; tagparser tagparser = tagparsermap . get ( parser . getname ( ) ) ; if ( tagparser == null ) { if ( logd ) log . d ( tag , _str + parser . getname ( ) ) ; return _num ; } long newelementid = tagparser . parseandadd ( parser ) ; if ( newelementid >= _num ) { if ( ! screenids . contains ( screenid ) && container == favorites . container_desktop ) { screenids . add ( screenid ) ; } return _num ; } return _num ; }	parses the current node and returns the number of elements added .
private float calculatescrambleimageheightmultiplier ( float multiplier ) { switch ( currentpuzzle ) { case puzzleutils . type_777 : case puzzleutils . type_666 : case puzzleutils . type_555 : case puzzleutils . type_222 : case puzzleutils . type_444 : case puzzleutils . type_333 : return ( multiplier / _num ) * _num ; case puzzleutils . type_clock : return multiplier / _num ; case puzzleutils . type_mega : return ( multiplier / _num ) ; case puzzleutils . type_pyra : return ( float ) ( multiplier / math . sqrt ( _num ) ) ; case puzzleutils . type_skewb : return ( multiplier / _num ) * _num ; case puzzleutils . type_square1 : return multiplier ; } return multiplier ; }	calculates scramble image height multiplier to respect aspect ratio.
public void testnumericscalars ( ) throws exception { objectmapper m = new objectmapper ( ) ; m . enabledefaulttyping ( ) ; assertequals ( _str , m . writevalueasstring ( new object [ ] { integer . valueof ( _num ) } ) ) ; assertequals ( _str , m . writevalueasstring ( new object [ ] { long . valueof ( _num ) } ) ) ; assertequals ( _str , m . writevalueasstring ( new object [ ] { double . valueof ( _num ) } ) ) ; assertequals ( _str , m . writevalueasstring ( new object [ ] { float . valueof ( _num ) } ) ) ; }	unit test to verify that limited number of core types do not include type information , even if declared as object . this is only done for types that json scalar values natively map to : string , integer and boolean ( and nulls never have type information ).
protected void closecallbacksexceptlistener ( ) { closecachecallback ( getcacheloader ( ) ) ; closecachecallback ( getcachewriter ( ) ) ; closecachecallback ( getevictioncontroller ( ) ) ; }	the listener is not closed until after the afterregiondestroy event.
private static int indexof ( object o , object [ ] elements , int index , int fence ) { if ( o == null ) { for ( int i = index ; i < fence ; i ++ ) if ( elements [ i ] == null ) return i ; } else { for ( int i = index ; i < fence ; i ++ ) if ( o . equals ( elements [ i ] ) ) return i ; } return - _num ; }	static version of indexof , to allow repeated calls without needing to re - acquire array each time .
private void populateprofiles ( final profilelist profiles ) { profilescombobox . removeallitems ( ) ; for ( profile p : profiles ) { profilescombobox . additem ( p ) ; } final int count = profilescombobox . getitemcount ( ) ; if ( count != _num ) { profilescombobox . setselectedindex ( count - _num ) ; } }	populate the profiles combobox and select the default .
private long checkfileheader ( bufferedfiledatainput bfdi ) throws replicatorexception , interruptedexception { int magic = _num ; short major = _num ; short minor = _num ; try { bfdi . waitavailable ( header_length , header_wait_millis ) ; magic = bfdi . readint ( ) ; major = bfdi . readshort ( ) ; minor = bfdi . readshort ( ) ; baseseqno = bfdi . readlong ( ) ; } catch ( ioexception e ) { throw new thlexception ( _str + file . getabsolutepath ( ) , e ) ; } if ( magic != magic_number ) throw new thlexception ( _str + file . getabsolutepath ( ) + _str ) ; if ( major != major_version ) throw new thlexception ( _str + file . getabsolutepath ( ) + _str ) ; if ( minor != minor_version ) logger . warn ( _str + file . getabsolutepath ( ) + _str + major + _str + minor + _str + major_version + _str + minor_version ) ; return baseseqno ; }	read the file header and return the log sequence number stored in the file header .
public float realabsolute ( ) { return math . abs ( mleft ) ; }	absolute value of real component.
public static string map2oid ( string algname ) { return alg2oidmap . get ( algname . touppercase ( locale . us ) ) ; }	returns oid for algname.
@ override public generator < icircle > construct ( string [ ] args ) { return new uniformgenerator ( double . valueof ( args [ _num ] ) ) ; }	provide reflective behavior to construct instance of generator given an array of string arguments .
private boolean yy_refill ( ) throws java . io . ioexception { if ( yy_startread > _num ) { system . arraycopy ( yy_buffer , yy_startread , yy_buffer , _num , yy_endread - yy_startread ) ; yy_endread -= yy_startread ; yy_currentpos -= yy_startread ; yy_markedpos -= yy_startread ; yy_pushbackpos -= yy_startread ; yy_startread = _num ; } if ( yy_currentpos >= yy_buffer . length ) { char newbuffer [ ] = new char [ yy_currentpos * _num ] ; system . arraycopy ( yy_buffer , _num , newbuffer , _num , yy_buffer . length ) ; yy_buffer = newbuffer ; } int numread = yy_reader . read ( yy_buffer , yy_endread , yy_buffer . length - yy_endread ) ; if ( numread < _num ) { return _bool ; } else { yy_endread += numread ; return _bool ; } }	refills the input buffer .
protected void processmouseevent ( mouseevent e ) { if ( myinplacecomponent != null && ( mouseevent . mouse_pressed == e . getid ( ) || mouseevent . mouse_released == e . getid ( ) ) ) { finishediting ( _bool ) ; } super . processmouseevent ( e ) ; }	when there is an inplace editor we " listen " all mouse event and finish editing by any mouse_pressed or mouse_released event.
protected void addmodule ( map < class < ? extends ifloodlightservice > , ifloodlightmodule > modulemap , collection < ifloodlightmodule > modulelist , ifloodlightmodule module ) { collection < class < ? extends ifloodlightservice > > servs = moduleservicemap . get ( module ) ; if ( servs != null ) { for ( class < ? extends ifloodlightservice > c : servs ) modulemap . put ( c , module ) ; } modulelist . add ( module ) ; }	add a module to the set of modules to load and register its services.
protected boolean hasalltables ( ) throws couldntloaddataexception , invaliddatabaseexception { navilogger . info ( _str ) ; final int counter = postgresqlhelpers . gettablecount ( getconnection ( ) , lists . newarraylist ( tables ) ) ; if ( counter == _num ) { return _bool ; } else if ( counter == tables . length ) { return _bool ; } else { throw new invaliddatabaseexception ( string . format ( _str , counter , tables . length ) ) ; } }	makes sure that all required binnavi database tables exist.
public list < string > classify ( list < list < feature > > features ) throws cleartkprocessingexception { string [ ] [ ] featurestringarray = tostrings ( features ) ; pipe pipe = transducer . getinputpipe ( ) ; instance instance = new instance ( featurestringarray , null , null , null ) ; instance = pipe . instancefrom ( instance ) ; sequence < ? > data = ( sequence < ? > ) instance . getdata ( ) ; sequence < ? > untypedsequence = transducer . transduce ( data ) ; sequence < string > sequence = reflectionutil . uncheckedcast ( untypedsequence ) ; list < string > returnvalues = new arraylist < string > ( ) ; for ( int i = _num ; i < sequence . size ( ) ; i ++ ) { string encodedoutcome = sequence . get ( i ) ; returnvalues . add ( outcomeencoder . decode ( encodedoutcome ) ) ; } return returnvalues ; }	this method classifies several instances at once.
public void onbindheaderviewholder ( recyclerview . viewholder holder , int position ) { onbindheaderviewholder ( holder , position , collections . emptylist ( ) ) ; }	bind header with provided viewholder at specified position.
private void updatelinelist ( ) { if ( horizontallineradiobutton . isselected ( ) ) { sethorizontallineselected ( ) ; } else { setverticallineselected ( ) ; } updatebuttonstates ( ) ; }	updates the displayed list of lines .
public void rectangle ( double x , double y , double halfwidth , double halfheight ) { if ( halfwidth < _num ) throw new illegalargumentexception ( _str ) ; if ( halfheight < _num ) throw new illegalargumentexception ( _str ) ; double xs = scalex ( x ) ; double ys = scaley ( y ) ; double ws = factorx ( _num * halfwidth ) ; double hs = factory ( _num * halfheight ) ; if ( ws <= _num && hs <= _num ) pixel ( x , y ) ; else offscreen . draw ( new rectangle2d . double ( xs - ws / _num , ys - hs / _num , ws , hs ) ) ; draw ( ) ; }	draws a rectangle of given half width and half height , centered on ( x , y ) .
protected final void refreshloadingviewssize ( ) { final int maximumpullscroll = ( int ) ( getmaximumpullscroll ( ) * _num ) ; int pleft = getpaddingleft ( ) ; int ptop = getpaddingtop ( ) ; int pright = getpaddingright ( ) ; int pbottom = getpaddingbottom ( ) ; switch ( getpulltorefreshscrolldirection ( ) ) { case horizontal : if ( mmode . showheaderloadinglayout ( ) ) { mheaderlayout . setwidth ( maximumpullscroll ) ; pleft = - maximumpullscroll ; } else { pleft = _num ; } if ( mmode . showfooterloadinglayout ( ) ) { mfooterlayout . setwidth ( maximumpullscroll ) ; pright = - maximumpullscroll ; } else { pright = _num ; } break ; case vertical : if ( mmode . showheaderloadinglayout ( ) ) { mheaderlayout . setheight ( maximumpullscroll ) ; ptop = - maximumpullscroll ; } else { ptop = _num ; } if ( mmode . showfooterloadinglayout ( ) ) { mfooterlayout . setheight ( maximumpullscroll ) ; pbottom = - maximumpullscroll ; } else { pbottom = _num ; } break ; } if ( debug ) { log . d ( log_tag , string . format ( _str , pleft , ptop , pright , pbottom ) ) ; } setpadding ( pleft , ptop , pright , pbottom ) ; }	re - measure the loading views height , and adjust internal padding as necessary.
public void replacesplitelement ( int aindex , fragment asplitelement ) { splits . set ( aindex , asplitelement ) ; }	replaces a split element with another one.
private void startitemlist ( stringbuilder result , string rootid ) { result . append ( _str + _str + rootid + _str ) ; }	called to start an item list .
private static int numinitialsplits ( long numrecords ) { final int maxsplits = _num ; final long recordspersplit = _num ; return ( int ) math . min ( maxsplits , numrecords / recordspersplit + _num ) ; }	pick a number of initial splits based on the number of records expected to be processed .
public void mouseclicked ( mouseevent e ) { if ( e . getclickcount ( ) > _num ) { system . gc ( ) ; } }	invoked when the mouse has been clicked on a component .
private static string [ ] scanforsources ( final file sourcedir , final set < string > sourceincludes , final set < string > sourceexcludes ) { final directoryscanner ds = new directoryscanner ( ) ; ds . setfollowsymlinks ( _bool ) ; ds . setbasedir ( sourcedir ) ; ds . setincludes ( sourceincludes . toarray ( new string [ sourceincludes . size ( ) ] ) ) ; ds . setexcludes ( sourceexcludes . toarray ( new string [ sourceexcludes . size ( ) ] ) ) ; ds . adddefaultexcludes ( ) ; try { ds . scan ( ) ; } catch ( illegalstateexception e ) { return new string [ _num ] ; } return ds . getincludedfiles ( ) ; }	scans a single source dir for sources and includes only the files whose name match the patterns in sourceincludes and excludes all files whose names match the patterns in sourceexcludes.
private boolean hasnextpostponed ( ) { return ! postponedroutes . isempty ( ) ; }	returns true if there is another postponed route to try .
public boolean hassingleelement ( ) { return mselectedwidgets . size ( ) == _num ; }	check if the selection has a single element.
public igfspath ( uri uri ) { a . notnull ( uri , _str ) ; path = normalizepath ( uri . getpath ( ) ) ; }	constructs a path from an uri.
public int toint ( element el , string attributename ) { return caster . tointvalue ( el . getattribute ( attributename ) , integer . min_value ) ; }	reads a xml element attribute ans cast it to a int value.
public static string readfully ( reader reader ) throws ioexception { try { stringwriter writer = new stringwriter ( ) ; char [ ] buffer = new char [ _num ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - _num ) { writer . write ( buffer , _num , count ) ; } return writer . tostring ( ) ; } finally { reader . close ( ) ; } }	returns the remainder of ' reader ' as a string , closing it when done .
public void addgetters ( int assignedpropertynumber , string propertyname ) { for ( eventtype type : knowntypes ) { eventpropertygetter getter = type . getgetter ( propertyname ) ; variantpropertygetterrow row = allgetters . get ( type ) ; if ( row == null ) { synchronized ( this ) { row = new variantpropertygetterrow ( type , new eventpropertygetter [ assignedpropertynumber + _num ] ) ; allgetters . put ( type , row ) ; } } row . addgetter ( assignedpropertynumber , getter ) ; } properties . add ( propertyname ) ; }	adds the getters for a property that is identified by a property number which indexes into array of getters per type .
protected void markused ( entry entry ) { entry . lastused = system . nanotime ( ) ; }	marks the specified entry as used by setting its last used time to the current time in nanoseconds .
@ override public string execute ( ) { return success ; }	default : just returns " success ".
private void handlestateleft ( inetaddress endpoint , string [ ] pieces ) { assert pieces . length >= _num ; collection < token > tokens = gettokensfor ( endpoint ) ; if ( logger . isdebugenabled ( ) ) logger . debug ( _str , endpoint , tokens ) ; excise ( tokens , endpoint , extractexpiretime ( pieces ) ) ; }	handle node leaving the ring . this will happen when a node is decommissioned.
public static void register ( string algorithmuri , class < ? extends signaturealgorithmspi > implementingclass ) throws algorithmalreadyregisteredexception , classnotfoundexception , xmlsignatureexception { javautils . checkregisterpermission ( ) ; if ( log . isloggable ( java . util . logging . level . fine ) ) { log . log ( java . util . logging . level . fine , _str + algorithmuri + _str + implementingclass ) ; } class < ? extends signaturealgorithmspi > registeredclass = algorithmhash . get ( algorithmuri ) ; if ( registeredclass != null ) { object exargs [ ] = { algorithmuri , registeredclass } ; throw new algorithmalreadyregisteredexception ( _str , exargs ) ; } algorithmhash . put ( algorithmuri , implementingclass ) ; }	registers implementing class of the transform algorithm with algorithmuri.
@ suppresswarnings ( _str ) public keyvaluepersistencesettings ( file settingsfile ) { inputstream in ; try { in = new fileinputstream ( settingsfile ) ; } catch ( ioexception e ) { throw new igniteexception ( _str + settingsfile . getabsolutepath ( ) , e ) ; } init ( loadsettings ( in ) ) ; }	constructs ignite cache key / value persistence settings .
public boolean containswordbreakingchar ( final @ nonnull charsequence input ) { if ( ! textutils . isempty ( input ) ) { for ( int i = _num ; i < input . length ( ) ; i ++ ) { char c = input . charat ( i ) ; if ( iswordbreakingchar ( c ) ) { return _bool ; } } } return _bool ; }	returns true if the input string contains a word - breaking character .
private void checkinteriorintersections ( ) { for ( iterator i = segstrings . iterator ( ) ; i . hasnext ( ) ; ) { segmentstring ss0 = ( segmentstring ) i . next ( ) ; for ( iterator j = segstrings . iterator ( ) ; j . hasnext ( ) ; ) { segmentstring ss1 = ( segmentstring ) j . next ( ) ; checkinteriorintersections ( ss0 , ss1 ) ; } } }	checks all pairs of segments for intersections at an interior point of a segment.
public synchronized boolean removeelement ( object object ) { int index ; if ( ( index = indexof ( object , _num ) ) == - _num ) { return _bool ; } removeelementat ( index ) ; return _bool ; }	removes the first occurrence , starting at the beginning and moving towards the end , of the specified object from this vector.
private < t > unaryoperator < t > compose ( unaryoperator < t > before , unaryoperator < t > after ) { return null ; }	compose two functions together into a single function.
private void addcdccolspecs ( arraylist < columnspec > cdcspecs , onerowchange cdcrowchangedata ) { int cdcpos = cdcspecs . size ( ) ; if ( cdccolumnsatfront ) cdcpos = _num ; columnspec spec = cdcrowchangedata . new columnspec ( ) ; spec . setindex ( cdcpos + _num ) ; spec . setname ( _str ) ; spec . settype ( java . sql . types . varchar ) ; spec . setlength ( _num ) ; cdcspecs . add ( cdcpos , spec ) ; spec = cdcrowchangedata . new columnspec ( ) ; spec . setindex ( cdcpos + _num + _num ) ; spec . setname ( _str ) ; spec . settype ( java . sql . types . timestamp ) ; cdcspecs . add ( cdcpos + _num , spec ) ; spec = cdcrowchangedata . new columnspec ( ) ; spec . setindex ( cdcpos + _num + _num ) ; spec . setname ( _str ) ; spec . settype ( java . sql . types . bigint ) ; cdcspecs . add ( cdcpos + _num , spec ) ; }	add cdc column specifications .
public static string converttojavafieldname ( string name ) { int dotindex = name . indexof ( _str ) ; if ( dotindex >= _num ) { name = name . substring ( _num , dotindex ) ; } string [ ] split = name . split ( _str ) ; stringbuilder out = new stringbuilder ( ) ; boolean first = _bool ; for ( string section : split ) { if ( first ) { first = _bool ; out . append ( section ) ; } else { out . append ( stringutil . capitalize ( section ) ) ; } } return out . tostring ( ) ; }	utility method to convert a variable name into java field name .
public static secretkeys generatekey ( ) throws generalsecurityexception { fixprng ( ) ; keygenerator keygen = keygenerator . getinstance ( cipher ) ; keygen . init ( aes_key_length_bits ) ; secretkey confidentialitykey = keygen . generatekey ( ) ; byte [ ] integritykeybytes = randombytes ( hmac_key_length_bits / _num ) ; secretkey integritykey = new secretkeyspec ( integritykeybytes , hmac_algorithm ) ; return new secretkeys ( confidentialitykey , integritykey ) ; }	a function that generates random aes & hmac keys and prints out exceptions but doesn ' t throw them since none should be encountered.
public static void checkargument ( boolean expression , @ nullable object errormessage ) { if ( ! expression ) { throw new illegalargumentexception ( string . valueof ( errormessage ) ) ; } }	ensures the truth of an expression involving one or more parameters to the calling method .
protected void execute ( string [ ] sqls , sqlitedatabase db ) { string throwsql = _str ; try { if ( sqls != null ) { for ( string sql : sqls ) { throwsql = sql ; db . execsql ( baseutility . changecase ( sql ) ) ; } } } catch ( sqlexception e ) { throw new databasegenerateexception ( databasegenerateexception . sql_error + throwsql ) ; } }	use the parameter sqlitedatabase to execute the passing sqls.
private synchronized void rebuildjournal ( ) throws ioexception { if ( journalwriter != null ) { journalwriter . close ( ) ; } writer writer = new bufferedwriter ( new outputstreamwriter ( new fileoutputstream ( journalfiletmp ) , util . us_ascii ) ) ; try { writer . write ( magic ) ; writer . write ( _str ) ; writer . write ( version_1 ) ; writer . write ( _str ) ; writer . write ( integer . tostring ( appversion ) ) ; writer . write ( _str ) ; writer . write ( integer . tostring ( valuecount ) ) ; writer . write ( _str ) ; writer . write ( _str ) ; for ( entry entry : lruentries . values ( ) ) { if ( entry . currenteditor != null ) { writer . write ( dirty + _str + entry . key + _str ) ; } else { writer . write ( clean + _str + entry . key + entry . getlengths ( ) + _str ) ; } } } finally { writer . close ( ) ; } if ( journalfile . exists ( ) ) { renameto ( journalfile , journalfilebackup , _bool ) ; } renameto ( journalfiletmp , journalfile , _bool ) ; journalfilebackup . delete ( ) ; journalwriter = new bufferedwriter ( new outputstreamwriter ( new fileoutputstream ( journalfile , _bool ) , util . us_ascii ) ) ; }	creates a new journal that omits redundant information.
private void refreshdonebutton ( boolean done ) { butdone . settext ( done ? messages . getstring ( _str ) : messages . getstring ( _str ) ) ; }	refreshes the done button.
private void createmigrationtaskpage ( ) { migrationtaskeditor migrationtaskeditor = new migrationtaskeditor ( migrationtask , getcontainer ( ) ) ; int index = addpage ( migrationtaskeditor . getcontrol ( ) ) ; setpagetext ( index , _str ) ; tasklisteners . add ( migrationtaskeditor ) ; }	create the basic editor .
private void expand ( int i ) { if ( count + i <= buf . length ) { return ; } byte [ ] newbuf = mpool . getbuf ( ( count + i ) * _num ) ; system . arraycopy ( buf , _num , newbuf , _num , count ) ; mpool . returnbuf ( buf ) ; buf = newbuf ; }	ensures there is enough space in the buffer for the given number of additional bytes .
public static int toipv4address ( string ipaddress ) { if ( ipaddress == null ) throw new illegalargumentexception ( _str + _str ) ; string [ ] octets = ipaddress . split ( _str ) ; if ( octets . length != _num ) throw new illegalargumentexception ( _str + _str ) ; int result = _num ; for ( int i = _num ; i < _num ; ++ i ) { int oct = integer . valueof ( octets [ i ] ) ; if ( oct > _num || oct < _num ) throw new illegalargumentexception ( _str + _str ) ; result |= oct << ( ( _num - i ) * _num ) ; } return result ; }	accepts an ipv4 address of the form xxx.
public void closecursor ( cursor cursor ) { cursor . close ( ) ; cursormap . remove ( integer . valueof ( cursor . getcursorid ( ) ) ) ; }	close the given cursor and remove it from the map.
private boolean hasnext ( pattern pattern ) { if ( ! hasnext ( ) ) { return _bool ; } matcher matcher = pattern . matcher ( gservalue . substring ( pos , length ) ) ; return matcher . find ( ) ; }	determines if the remaining gser string matches the provided pattern .
void pushint ( int i ) { switch ( i ) { case - _num : mv . visitinsn ( iconst_m1 ) ; return ; case _num : mv . visitinsn ( iconst_0 ) ; return ; case _num : mv . visitinsn ( iconst_1 ) ; return ; case _num : mv . visitinsn ( iconst_2 ) ; return ; case _num : mv . visitinsn ( iconst_3 ) ; return ; case _num : mv . visitinsn ( iconst_4 ) ; return ; case _num : mv . visitinsn ( iconst_5 ) ; return ; } if ( i >= byte . min_value && i <= byte . max_value ) { mv . visitintinsn ( bipush , i ) ; return ; } if ( i >= short . min_value && i <= short . max_value ) { mv . visitintinsn ( sipush , i ) ; return ; } mv . visitldcinsn ( integer . valueof ( i ) ) ; }	push i onto our operand stack.
public static string xmlnode ( string name , string attributes , string content , boolean indent ) { string start = attributes == null ? name : name + attributes ; if ( content == null ) { return _str + start + _str ; } if ( indent && content . indexof ( _str ) >= _num ) { content = _str + indent ( content ) ; } return _str + start + _str + content + _str + name + _str ; }	create an xml node with optional attributes and content.
public void add ( int position , @ nonnull t item ) { synchronized ( lock ) { if ( items == null ) { items = new arraylist < > ( ) ; } items . add ( position , item ) ; } if ( notifyonchange ) { notifyiteminserted ( position ) ; } }	adds the specified item to the list with the specified position.
void notifyfailure ( throwable exception ) { synchronized ( waitobject ) { iscomplete = _bool ; if ( exception instanceof mqttexception ) { pendingexception = ( mqttexception ) exception ; } else { pendingexception = new mqttexception ( exception ) ; } waitobject . notifyall ( ) ; if ( exception instanceof mqttexception ) { lastexception = ( mqttexception ) exception ; } if ( listener != null ) { listener . onfailure ( this , exception ) ; } } }	notify unsuccessful completion of the operation.
public static void transform ( streamsource src , streamsource stylesheet , fop fop ) throws fopexception { result res = new saxresult ( fop . getdefaulthandler ( ) ) ; try { transformerfactory factory = transformerfactory . newinstance ( ) ; transformer transformer ; if ( stylesheet == null ) { transformer = factory . newtransformer ( ) ; } else { transformer = factory . newtransformer ( stylesheet ) ; } transformer . seturiresolver ( new localresolver ( transformer . geturiresolver ( ) ) ) ; transformer . transform ( src , res ) ; } catch ( exception e ) { throw new fopexception ( e ) ; } }	transform an xsl - fo streamsource to the specified output format .
public list < string > splitstringwithdefaultdelimiterescaped ( string inputstring ) { string delimiter = configurationhelper . getproperty ( configurationvalue . field_data_delimiter ) ; string escapechar = configurationhelper . getproperty ( configurationvalue . field_data_delimiter_escape_char ) ; list < string > splitstring = new arraylist < > ( ) ; if ( stringutils . isnotblank ( inputstring ) ) { string regex = _str + pattern . quote ( escapechar ) + _str + pattern . quote ( delimiter ) ; for ( string s : inputstring . split ( regex ) ) { splitstring . add ( s . replace ( escapechar + delimiter , delimiter ) ) ; } } return splitstring ; }	splits the input string based on the default delimiter , and also escapes delimiter .
protected final boolean readavailableblocking ( ) throws ioexception { char [ ] buffer = mybuffer ; stringbuilder token = mytextbuffer ; token . setlength ( _num ) ; boolean read = _bool ; int n ; while ( ( n = myreader . read ( buffer ) ) > _num ) { if ( myscheduledsubmitter != null ) myscheduledsubmitter . cancel ( _bool ) ; read = _bool ; synchronized ( mytextbuffer ) { processline ( buffer , token , n ) ; } myscheduledsubmitter = myexecutorservice . submit ( mytokensubmitter ) ; } submittoken ( ) ; return read ; }	reads data with blocking.
public void deleteobligation ( final obligation obligation , int basicblockid ) throws obligationacquiredorreleasedinloopexception { map < obligationset , state > updatedstatemap = new hashmap < obligationset , state > ( ) ; for ( iterator < state > i = stateiterator ( ) ; i . hasnext ( ) ; ) { state state = i . next ( ) ; checkcircularity ( state , obligation , basicblockid ) ; obligationset obligationset = state . getobligationset ( ) ; obligationset . remove ( obligation ) ; if ( ! obligationset . isempty ( ) ) { updatedstatemap . put ( obligationset , state ) ; } } replacemap ( updatedstatemap ) ; }	remove an obligation from every state in the stateset .
private void clipviewontheright ( rect curviewbound , float curviewwidth , int right ) { curviewbound . right = ( int ) ( right - mclippadding ) ; curviewbound . left = ( int ) ( curviewbound . right - curviewwidth ) ; }	set bounds for the right textview including clip padding .
public contentimpl createcompoundpackagecontent ( oleblobimpl blob , string prettyname , string classname , string typename , bytebuffer blobbb , int datablocklen ) { return new compoundcontentimpl ( blob , prettyname , classname , typename , blobbb . position ( ) , datablocklen ) ; }	creates a nes compoundcontent for the given blob information .
protected boolean checkcoverage ( ) { int i ; int n ; int [ ] count ; range r ; string attrindex ; subspaceclusterdefinition cl ; count = new int [ getnumattributes ( ) ] ; for ( i = _num ; i < getnumattributes ( ) ; i ++ ) { for ( n = _num ; n < getclusters ( ) . length ; n ++ ) { cl = ( subspaceclusterdefinition ) getclusters ( ) [ n ] ; r = new range ( cl . getattrindexrange ( ) ) ; r . setupper ( getnumattributes ( ) ) ; if ( r . isinrange ( i ) ) { count [ i ] ++ ; } } } attrindex = _str ; for ( i = _num ; i < count . length ; i ++ ) { if ( count [ i ] == _num ) { if ( attrindex . length ( ) != _num ) { attrindex += _str ; } attrindex += ( i + _num ) ; } } if ( attrindex . length ( ) != _num ) { throw new illegalargumentexception ( _str + _str + attrindex + _str ) ; } return _bool ; }	checks , whether all attributes are covered by cluster definitions and returns true in that case .
private set < integer > findvalues ( string string ) { set < integer > results = new treeset < integer > ( ) ; for ( string str : string . split ( _str ) ) { if ( ! str . equals ( _str ) ) { results . add ( findvalue ( str ) ) ; } } return results ; }	search for a string in the enumeration .
private static int indexof ( object [ ] array , int len , object elt ) { for ( int i = _num ; i < len ; i ++ ) { if ( elt . equals ( array [ i ] ) ) return i ; } return - _num ; }	returns the first index of elt in the array if < len , else - 1 .
@ deprecated public void append ( final string name , final string value ) { list < string > l = map . get ( name ) ; if ( l != null ) { l . add ( value ) ; } else { l = lists . newarraylist ( value ) ; map . put ( name , l ) ; } }	add a new value for name.
public boolean equals ( object obj ) { if ( obj == this ) { return _bool ; } if ( ! ( obj instanceof certificate ) ) { return _bool ; } certificate object = ( certificate ) obj ; try { return arrays . equals ( getencoded ( ) , object . getencoded ( ) ) ; } catch ( certificateencodingexception e ) { return _bool ; } }	compares the argument to this certificate.
public statement between ( object former , object later ) { statement . append ( _str ) ; append ( former ) ; statement . append ( _str ) ; append ( later ) ; return this ; }	appending the between operator clause .
public byte [ ] encode1 ( final string s ) { final bytearraybuffer tmp = new bytearraybuffer ( s . length ( ) ) ; final int nwritten = uc . encode ( s , tmp ) ; final int npack = longpacker . getbytelength ( nwritten ) ; final byte [ ] a = new byte [ npack + nwritten ] ; final dataoutputbuffer dob = new dataoutputbuffer ( _num , a ) ; try { dob . packlong ( nwritten ) ; dob . append ( tmp . array ( ) , _num , tmp . pos ( ) ) ; return a ; } finally { try { dob . close ( ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } } }	encode a unicode string .
public static map < object , long > valuehistogram ( geotimeserie gts ) { map < object , long > occurrences = new hashmap < object , long > ( ) ; for ( int i = _num ; i < gts . values ; i ++ ) { object value = gtshelper . valueatindex ( gts , i ) ; if ( ! occurrences . containskey ( value ) ) { occurrences . put ( value , _num ) ; } else { occurrences . put ( value , _num + occurrences . get ( value ) ) ; } } if ( gtshelper . isbucketized ( gts ) && gts . bucketcount != gts . values ) { occurrences . put ( null , ( long ) ( gts . bucketcount - gts . values ) ) ; } return occurrences ; }	build an occurrence count by value for the given time serie .
private void computeweights ( node node ) { int wsum = _num ; for ( node child : node . children ) { computeweights ( child ) ; wsum += child . weight ; } node . weight = math . max ( _num , wsum ) ; }	recursively assign node weights .
public searcher ( ) throws ioexception { searcher = new indexsearcher ( directoryreader . open ( fsdirectory . open ( paths . get ( index_dir ) ) ) ) ; parser = new queryparser ( content_field , new standardanalyzer ( ) ) ; }	creates a new instance of searchengine.
public querystringquerybuilder field ( string field ) { if ( fields == null ) { fields = new arraylist < > ( ) ; } fields . add ( field ) ; return this ; }	adds a field to run the query string against .
public static < r , a , b > completionstage < r > combine ( completionstage < a > a , completionstage < b > b , bifunction < a , b , r > function ) { return a . thencombine ( b , function ) ; }	combines multiple stages by applying a function .
protected string buildcreateschemastatement ( ) throws replicatorexception { return null ; }	return a statement that will create the schema , null if no create schema can be given.
public void testnegposfirstshorter ( ) { byte abytes [ ] = { - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { - _num , _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , - _num , _num , _num , - _num , - _num } ; int asign = - _num ; int bsign = _num ; byte rbytes [ ] = { _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , - _num , _num , _num , - _num , _num , _num , - _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . and ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	and for a negative and a positive numbers ; the first is shorter.
public streaminfomanager ( twitchapi api , streaminfolistener listener ) { this . listener = listener ; this . api = api ; pendingrequests = new hashmap < > ( ) ; invalidstreaminfo = new streaminfo ( _str , listener ) ; invalidstreaminfo . setrequested ( ) ; }	create a new manager object .
public sentence assentence ( ) { return sentence . newconjunction ( sentences ) ; }	returns the list of sentences in the knowledge base chained together as a single sentence .
public boolean ispronoun ( ) { return typestring . contains ( suffix_pronoun ) ; }	determine if the expression is a pronoun .
protected void appendshorttype ( stringbuilder sb , fieldtype fieldtype , int fieldwidth ) { sb . append ( _str ) ; }	output the sql type for a java short .
public static vector tokenizestring ( string source , string separator ) { if ( separator . length ( ) == _num ) { return tokenizestring ( source , separator . charat ( _num ) ) ; } vector tokenized = new vector ( ) ; int len = source . length ( ) ; stringbuilder buf = new stringbuilder ( ) ; for ( int iter = _num ; iter < len ; iter ++ ) { char current = source . charat ( iter ) ; if ( separator . indexof ( current ) > - _num ) { if ( buf . length ( ) > _num ) { tokenized . addelement ( buf . tostring ( ) ) ; buf = new stringbuilder ( ) ; } } else { buf . append ( current ) ; } } if ( buf . length ( ) > _num ) { tokenized . addelement ( buf . tostring ( ) ) ; } return tokenized ; }	breaks a string to multiple strings ( similar to string tokenizer ).
private void backupfavorites ( backupdataoutput data ) throws ioexception { contentresolver cr = mcontext . getcontentresolver ( ) ; cursor cursor = cr . query ( favorites . content_uri , favorite_projection , getuserselectionarg ( ) , null , null ) ; try { cursor . movetoposition ( - _num ) ; while ( cursor . movetonext ( ) ) { final long id = cursor . getlong ( id_index ) ; final long updatetime = cursor . getlong ( id_modified ) ; key key = getkey ( key . favorite , id ) ; mkeys . add ( key ) ; final string backupkey = keytobackupkey ( key ) ; if ( ! mexistingkeys . contains ( backupkey ) || updatetime >= mlastbackuprestoretime ) { writerowtobackup ( key , packfavorite ( cursor ) , data ) ; } else { if ( debug ) log . d ( tag , _str + id ) ; } } } finally { cursor . close ( ) ; } }	write all modified favorites to the data stream .
public void update ( ) { if ( lasttime != - _num ) { long delta = system . nanotime ( ) - lasttime ; rollingaverage . addvalue ( delta ) ; } lasttime = system . nanotime ( ) ; }	update the fps counter . < p / > call this method every frame !.
public list < validationerrormessage > validate ( ) { errormessageids . clear ( ) ; if ( paymentproduct == null ) { throw new nullpointerexception ( _str ) ; } for ( paymentproductfield field : paymentproduct . getpaymentproductfields ( ) ) { if ( ! isfieldinaccountonfileandnotaltered ( field ) ) { errormessageids . addall ( field . validatevalue ( getvalue ( field . getid ( ) ) ) ) ; } } return errormessageids ; }	validates all fields based on their value and their validationrules if a field is prefilled from the account on file , but it has been altered , it will be validated .
keystorestate ( ) { }	create an empty state .
cryptoresult ( final t result , final list < k > masterkeys , final ciphertextheaders headers ) { result_ = result ; masterkeys_ = collections . unmodifiablelist ( masterkeys ) ; headers_ = headers ; encryptioncontext_ = headers_ . getencryptioncontextmap ( ) ; }	note , does not make a defensive copy of any of the data .
public void statechanged ( changeevent e ) { if ( ignoreupdate ) { return ; } double value = ( double ) ( _num - setpointslider . getvalue ( ) ) / _num ; setsetpoint ( value ) ; sim . setsetpoint ( value ) ; }	handle a change in the slider by updating the dataset value.
public static string [ ] parsedelimitedlist ( string list , char delimiter ) { string delim = _str + delimiter ; stringtokenizer st = new stringtokenizer ( list + delim + _str , delim , _bool ) ; arraylist < string > v = new arraylist < string > ( ) ; string lasttoken = _str ; string word = _str ; while ( st . hasmoretokens ( ) ) { string tok = st . nexttoken ( ) ; if ( lasttoken != null ) { if ( tok . equals ( delim ) ) { word = word + lasttoken ; if ( lasttoken . equals ( delim ) ) tok = null ; } else { if ( ! word . equals ( _str ) ) v . add ( word ) ; word = _str ; } } lasttoken = tok ; } return v . toarray ( new string [ _num ] ) ; }	parse a list of substrings separated by a given delimiter . the delimiter can also appear in substrings ( just double them ) : parsedelimitedstring ( " this | is " , ' | ' ) returns [ " this " , " is " ] parsedelimitedstring ( " this | | is " , ' | ' ) returns [ " this | is " ].
private void initializelayout ( ) { gridlayout gl = new gridlayout ( _num , _num ) ; gl . setvgap ( _num ) ; setlayout ( gl ) ; add ( new jlabel ( _str ) ) ; add ( frozendd ) ; add ( new jlabel ( _str ) ) ; add ( tfupbound ) ; add ( new jlabel ( _str ) ) ; add ( tflowbound ) ; add ( new jlabel ( _str ) ) ; add ( tfincrement ) ; add ( new jlabel ( _str ) ) ; add ( tfdelay ) ; setborder ( borderfactory . createemptyborder ( _num , _num , _num , _num ) ) ; }	lays out the panel.
@ override public boolean isrunning ( ) { return ( frame != null && frame . isvisible ( ) ) ; }	returns true if the gui is started and not paused , and false otherwise .
public static mosaicdefinition createmosaicdefinition ( final account creator ) { return createmosaicdefinition ( creator , utils . createmosaicid ( _str , _str ) , createmosaicproperties ( ) ) ; }	creates a default mosaic definition .
public result result ( sqlnode node , collection < clause > clauses , relnode rel ) { final string alias2 = sqlvalidatorutil . getalias ( node , - _num ) ; final string alias3 = alias2 != null ? alias2 : _str ; final string alias4 = sqlvalidatorutil . uniquify ( alias3 , aliasset , sqlvalidatorutil . expr_suggester ) ; final string alias5 = alias2 == null || ! alias2 . equals ( alias4 ) ? alias4 : null ; return new result ( node , clauses , alias5 , collections . singletonlist ( pair . of ( alias4 , rel . getrowtype ( ) ) ) ) ; }	creates a result based on a single relational expression .
private static void _trustallhttpscertificates ( ) { sslcontext context ; if ( _trustmanagers == null ) { _trustmanagers = new trustmanager [ ] { new fakex509trustmanager ( ) } ; } try { context = sslcontext . getinstance ( _str ) ; context . init ( null , _trustmanagers , new securerandom ( ) ) ; } catch ( generalsecurityexception gse ) { throw new illegalstateexception ( gse . getmessage ( ) ) ; } httpsurlconnection . setdefaultsslsocketfactory ( context . getsocketfactory ( ) ) ; }	set the default x509 trust manager to an instance of a fake class that trust all certificates , even the self - signed ones .
private static boolean isinneedofform ( uicomponent component ) { return ( component instanceof actionsource || component instanceof actionsource2 || component instanceof editablevalueholder ) ; }	is the component in need of a form .
private void addinternallisteners ( ) { cbdistribution . additemlistener ( cbitemlistener ) ; }	adds all internal listeners.
public static double safesqrt ( double x ) { return ( x < _num ? - math . sqrt ( - x ) : math . sqrt ( x ) ) ; }	the " safe " square root of the input value , handling negative values by simply making them positive and then negating the return value .
public static long runmultithreaded ( iterable < callable < ? > > calls , gridtestsafethreadfactory threadfactory ) throws exception { if ( ! busylock . enterbusy ( ) ) throw new illegalstateexception ( _str ) ; collection < thread > threads = new arraylist < > ( ) ; long time ; try { for ( callable < ? > call : calls ) threads . add ( threadfactory . newthread ( call ) ) ; time = system . currenttimemillis ( ) ; for ( thread t : threads ) t . start ( ) ; } finally { busylock . leavebusy ( ) ; } for ( thread t : threads ) t . join ( ) ; time = system . currenttimemillis ( ) - time ; threadfactory . checkerror ( ) ; return time ; }	runs callable tasks each in separate threads .
private void bappend ( char ch ) { try { mbuff [ ++ mbuffidx ] = ch ; } catch ( exception exp ) { char buff [ ] = new char [ mbuff . length << _num ] ; system . arraycopy ( mbuff , _num , buff , _num , mbuff . length ) ; mbuff = buff ; mbuff [ mbuffidx ] = ch ; } }	appends a character to parser ' s buffer .
public void initializeownerreferencesforfield ( statemanager sm , fieldmetadata fmd ) { if ( fmd . getassociationtype ( ) == fieldmetadata . one_to_many ) { collection < ? > collection = ( collection < ? > ) sm . fetch ( fmd . getindex ( ) ) ; if ( collection != null ) { for ( object item : collection ) { if ( item != null ) { _relationsmanager . setownerstatemanagerforpersistentinstance ( item , sm , fmd ) ; } } } } else if ( fmd . getassociationtype ( ) == fieldmetadata . one_to_one || fmd . isembeddedpc ( ) ) { object value = sm . fetch ( fmd . getindex ( ) ) ; if ( value != null ) { _relationsmanager . setownerstatemanagerforpersistentinstance ( value , sm , fmd ) ; } } }	sets the provided state manager as the owner for the provided field value .
public string buildunionsubquery ( string typediscriminatorcolumn , string [ ] unioncolumns , set < string > columnspresentintable , int computedcolumnsoffset , string typediscriminatorvalue , string selection , string groupby , string having ) { int unioncolumnscount = unioncolumns . length ; string [ ] projectionin = new string [ unioncolumnscount ] ; for ( int i = _num ; i < unioncolumnscount ; i ++ ) { string unioncolumn = unioncolumns [ i ] ; if ( unioncolumn . equals ( typediscriminatorcolumn ) ) { projectionin [ i ] = _str + typediscriminatorvalue + _str + typediscriminatorcolumn ; } else if ( i <= computedcolumnsoffset || columnspresentintable . contains ( unioncolumn ) ) { projectionin [ i ] = unioncolumn ; } else { projectionin [ i ] = _str + unioncolumn ; } } return buildquery ( projectionin , selection , groupby , having , null , null ) ; }	construct a select statement suitable for use in a group of select statements that will be joined through union operators in buildunionquery .
public node ( coordinate pt ) { this ( pt , new directededgestar ( ) ) ; }	constructs a node with the given location .
public synchronized void increase ( ) { if ( accuracy > _num ) { long timepassed = system . currenttimemillis ( ) - lastadded ; if ( timepassed > accuracy ) { clearup ( ) ; if ( count > _num ) { data . addfirst ( lastadded + accuracy ) ; } lastadded = system . currenttimemillis ( ) ; count = _num ; } count ++ ; } else { clearup ( ) ; data . addfirst ( system . currenttimemillis ( ) ) ; } }	adds an element to the counter or caches it to be added .
public void revert ( final virtualfile root , final list < filepath > files ) throws vcsexception { for ( list < string > paths : vcsfileutil . chunkpaths ( root , files ) ) { gitsimplehandler handler = new gitsimplehandler ( myproject , root , gitcommand . checkout ) ; handler . addparameters ( _str ) ; handler . endoptions ( ) ; handler . addparameters ( paths ) ; handler . run ( ) ; } }	reverts the list of files we are passed .
public static float [ ] concatallfloat ( float [ ] ... arrays ) { int totallength = _num ; final int subarraycount = arrays . length ; for ( int i = _num ; i < subarraycount ; ++ i ) { totallength += arrays [ i ] . length ; } float [ ] result = arrays . copyof ( arrays [ _num ] , totallength ) ; int offset = arrays [ _num ] . length ; for ( int i = _num ; i < subarraycount ; ++ i ) { system . arraycopy ( arrays [ i ] , _num , result , offset , arrays [ i ] . length ) ; offset += arrays [ i ] . length ; } return result ; }	concatenates a list of float arrays into a single array .
public taggedvalueiterator ( final string aline , final boolean attemptfirstword , final string ... tags ) { this . aline = aline ; this . attemptfirstword = attemptfirstword ; this . tags = tags ; tagpos = _num ; nextresult = getnextresult ( ) ; if ( attemptfirstword ) { int a = _num ; while ( a < aline . length ( ) ) { if ( aline . charat ( a ) == _str || aline . charat ( a ) == _str || character . iswhitespace ( aline . charat ( a ) ) ) a ++ ; else break ; } int b = a + _num ; while ( b < aline . length ( ) ) { if ( character . isletterordigit ( aline . charat ( b ) ) || aline . charat ( b ) == _str ) b ++ ; else break ; } if ( b - a > _num ) { nextresult = aline . substring ( a , b ) ; } tagpos = b ; } }	iterator over all values following an occurrence of tag in aline . example : aline = gi | 4444 | gi | 5555 and tag = gi | with return 4444 and then 5555 value consists of letters , digits or underscore.
public void ascendtree ( ) { if ( null != parentpath ) { parentpath . append ( parent_path ) ; return ; } file parenttree = calcparenttree ( ) ; if ( null != parenttree ) { treefile = parenttree ; return ; } parentpath = new stringbuilder ( providelastname ( ) ) ; parentpath . append ( parent_path ) ; }	move higher in the tree , beyond even an apparent root of tree .
public boolean canread ( ) { return _is != null ; }	returns true if there ' s an associated file .
void writeto ( byte [ ] b , int off ) { system . arraycopy ( buf , _num , b , off , count ) ; }	writes the contents of the internal buffer to the given array starting at the given offset.
void onitemdismissed ( final int position ) { final t removed = mdata . get ( position ) ; final boolean wasremoved = remove ( position ) ; if ( wasremoved && mdatachangelistener != null ) { mdatachangelistener . onitemremoved ( removed , position ) ; } }	dismisses item from the given position .
public static double normalpdf ( double x , double variance , double meanvalue ) { double standarddeviation = math . sqrt ( variance ) ; return ( _num / ( standarddeviation * math . sqrt ( _num * math . pi ) ) ) * math . pow ( math . e , - ( ( x - meanvalue ) * ( x - meanvalue ) ) / ( _num * variance ) ) ; }	calculate a normal probability density function ( pdf ) based on a variance and mean value.
public static object [ ] sortcopy ( object [ ] objects , comparer comparer ) { int len = objects . length ; object [ ] copy = new object [ len ] ; system . arraycopy ( objects , _num , copy , _num , len ) ; sort ( copy , comparer ) ; return copy ; }	sorts an array of strings , returning a new array with the sorted items.
public synchronized void addzoomlistener ( zoomlistener listener ) { mzoomlisteners . add ( listener ) ; }	adds a new zoom listener .
private void clearregisters ( instruction start , instruction end ) { for ( instruction p = start ; ; p = p . nextinstructionincodeorder ( ) ) { for ( enumeration < operand > ops = p . getoperands ( ) ; ops . hasmoreelements ( ) ; ) { operand op = ops . nextelement ( ) ; if ( op instanceof registeroperand ) { registeroperand rop = ( registeroperand ) op ; cleardepgraphnodeforregister ( rop . getregister ( ) ) ; } } if ( p == end ) break ; } for ( enumeration < register > e = genericphysicaldefuse . enumerateallimplicitdefuses ( ir ) ; e . hasmoreelements ( ) ; ) { register r = e . nextelement ( ) ; cleardepgraphnodeforregister ( r ) ; } }	initialize ( clear ) the dnode field in register for all registers in this basic block by setting them to null.
public void fireannotationselected ( workflowannotation anno ) { list < workflowannotation > list = new linkedlist < > ( ) ; list . add ( anno ) ; fireannotationschanged ( annotationevent . selected_annotation_changed , list ) ; }	fire when an annotation has been selected .
public boolean verifyserverevidencemessage ( biginteger serverm2 ) throws cryptoexception { if ( ( this . a == null ) || ( this . m1 == null ) || ( this . s == null ) ) { throw new cryptoexception ( _str + _str ) ; } biginteger computedm2 = srp6util . calculatem2 ( digest , n , a , m1 , s ) ; if ( computedm2 . equals ( serverm2 ) ) { this . m2 = serverm2 ; return _bool ; } return _bool ; }	authenticates the server evidence message m2 received and saves it only if correct .
public void handletext ( string text ) { if ( skippingcharacters > _num ) { if ( skippingcharacters >= text . length ( ) ) { skippingcharacters -= text . length ( ) ; return ; } else { text = text . substring ( skippingcharacters ) ; skippingcharacters = _num ; } } if ( rtfdestination != null ) { rtfdestination . handletext ( text ) ; return ; } warning ( _str ) ; }	handles any pure text ( containing no control characters ) in the input stream.
public final boolean remove ( final uri serviceuri ) { boolean modified = _bool ; synchronized ( this ) { if ( aliases . remove ( serviceuri ) != null ) { modified = _bool ; } final servicefactory factory = services . remove ( serviceuri ) ; if ( factory != null ) { modified = _bool ; if ( factory instanceof customservicefactory ) { customservices . remove ( factory ) ; } } } return modified ; }	remove a service from the registry and / or set of known aliases .
@ nullable private static string referencetoattribute ( string attrib , boolean includedummies ) { while ( attrib . startswith ( _str ) ) { attrib = attrib . substring ( _num ) ; } if ( attrib . startswith ( _str ) ) { if ( includedummies ) { attrib = attrib . substring ( _num ) ; } else return null ; } if ( ! stringutil . startswithchar ( attrib , _str ) ) { return null ; } attrib = attrib . substring ( _num ) ; if ( stringutil . startswithchar ( attrib , _str ) ) { string cleanattribute = null ; for ( int i = _num ; i < attrib . length ( ) ; i ++ ) { char currchar = attrib . charat ( i ) ; if ( currchar == _str || currchar == _str ) { cleanattribute = null ; break ; } else if ( currchar == _str ) { cleanattribute = attrib . substring ( _num , i ) ; break ; } } attrib = cleanattribute ; } else { for ( int i = _num ; i < attrib . length ( ) ; i ++ ) { char currchar = attrib . charat ( i ) ; if ( currchar == _str || currchar == _str || currchar == _str ) { attrib = attrib . substring ( _num , i ) ; break ; } } } return attrib ; }	removes each two leading ' \ ' , removes leading $ , removes { } examples : $ qqq - > qqq \ $ qqq - > qqq if dummy attributes are collected too , null otherwise \ \ $ qqq - > qqq $ { qqq } - > qqq.
public escapedwriter ( writer fos ) { super ( fos ) ; }	constructs an escapedwriter around the given writer .
public boolean isexpired ( final date date ) { if ( date == null ) { throw new illegalargumentexception ( _str ) ; } return ( cookieexpirydate != null && cookieexpirydate . gettime ( ) <= date . gettime ( ) ) ; }	returns true if this cookie has expired .
public void record ( recordbuilderimpl recordbuilder ) { storebitmap ( recordbuilder ) ; outputstream viewhierarchydump = null ; try { viewhierarchydump = malbum . openviewhierarchyfile ( recordbuilder . getname ( ) ) ; mviewhierarchy . deflate ( recordbuilder . getview ( ) , viewhierarchydump ) ; malbum . addrecord ( recordbuilder ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } finally { if ( viewhierarchydump != null ) { try { viewhierarchydump . close ( ) ; } catch ( ioexception e ) { log . e ( _str , _str , e ) ; } } } }	records the recordbuilderimpl , and verifies if required.
protected boolean iscorrectmethod ( method method , object [ ] args ) { return ( proxysignature . equals ( method . getname ( ) ) && args . length == _num ) ; }	compare the method that was called to the intended method when the osxadapter instance was created ( e.
public void testcase17 ( ) { byte abytes [ ] = { - _num , _num , _num , _num , _num , - _num , _num , - _num , _num , _num } ; byte bbytes [ ] = { _num , - _num , _num , _num , _num } ; int asign = _num ; int bsign = _num ; byte rbytes [ ] = { _num , - _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . remainder ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	remainder of division of two positive numbers.
public metadata . property . builder clear ( ) { metadata_property_builder _defaults = new metadata . property . builder ( ) ; type = _defaults . type ; boxedtype = _defaults . boxedtype ; name = _defaults . name ; capitalizedname = _defaults . capitalizedname ; allcapsname = _defaults . allcapsname ; gettername = _defaults . gettername ; codegenerator = _defaults . codegenerator ; fullycheckedcast = _defaults . fullycheckedcast ; accessorannotations . clear ( ) ; _unsetproperties . clear ( ) ; _unsetproperties . addall ( _defaults . _unsetproperties ) ; return ( metadata . property . builder ) this ; }	resets the state of this builder .
public static float r_distance ( vec3 a , vec3 b ) { float x = a . m [ _num ] - b . m [ _num ] ; float y = a . m [ _num ] - b . m [ _num ] ; float z = a . m [ _num ] - b . m [ _num ] ; float result = ( float ) math . sqrt ( x * x + y * y + z * z ) ; return result ; }	\ brief distance ( vec3 a , vec3 b ).
public void checkbackupinfo ( final file backupinfofile , boolean backupinmultivdc ) { try ( inputstream fis = new fileinputstream ( backupinfofile ) ) { properties properties = new properties ( ) ; properties . load ( fis ) ; checkversion ( properties ) ; checkhosts ( properties , backupinmultivdc ) ; } catch ( ioexception ex ) { log . warn ( _str , ex ) ; } }	checks version and ips.
static string tolowercase ( string s ) { int len = s . length ( ) ; stringbuilder sb = null ; for ( int i = _num ; i < len ; i ++ ) { char c = s . charat ( i ) ; if ( ( c >= _str && c <= _str ) || ( c == _str ) ) { if ( sb != null ) sb . append ( c ) ; } else if ( ( c >= _str && c <= _str ) || ( c == _str ) ) { if ( sb != null ) sb . append ( c ) ; } else if ( c >= _str && c <= _str ) { if ( sb == null ) { sb = new stringbuilder ( len ) ; sb . append ( s , _num , i ) ; } sb . append ( ( char ) ( c - case_diff ) ) ; } else { throw new illegalargumentexception ( _str ) ; } } return sb == null ? s : sb . tostring ( ) ; }	convert to lower case , and check that all chars are ascii alphanumeric , ' - ' or '.
public void testconstructorsignbytesnegative3 ( ) { byte abytes [ ] = { - _num , _num , _num } ; int asign = - _num ; byte rbytes [ ] = { - _num , _num , - _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = anumber . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , anumber . signum ( ) ) ; }	create a negative number from a sign and an array of bytes.
public static byte [ ] buildopuscomment ( string comment ) { byte [ ] data = new byte [ _num + comment . length ( ) ] ; writeopuscomment ( data , _num , comment ) ; return data ; }	builds and returns a opus comment .
public static void assertprops ( uniformpair < eventbean > received , string [ ] propertynames , object [ ] expectedinsert , object [ ] expectedremoved ) { assertprops ( received . getfirst ( ) , propertynames , expectedinsert ) ; assertprops ( received . getsecond ( ) , propertynames , expectedremoved ) ; }	assert that the property values of a new event and a removed event match the expected insert and removed values .
public int size ( ) { return al . size ( ) ; }	returns the number of elements in this set .
public static string touppercase ( string src ) { if ( src == null ) { return null ; } else { return src . touppercase ( ) ; } }	safely convert the string to uppercase .
public final iterator < knowledgeedge > requirededgesiterator ( ) { set < knowledgeedge > edges = new hashset < > ( ) ; for ( orderedpair < set < mynode > > o : requiredrulesspecs ) { final set < mynode > first = o . getfirst ( ) ; for ( mynode s1 : first ) { final set < mynode > second = o . getsecond ( ) ; for ( mynode s2 : second ) { if ( ! s1 . equals ( s2 ) ) { edges . add ( new knowledgeedge ( s1 . getname ( ) , s2 . getname ( ) ) ) ; } } } } return edges . iterator ( ) ; }	iterator over the knowledgeedge ' s representing required edges .
@ deprecated public void unlock ( lockstate < t > lockstate ) { if ( lockstate == null ) { throw new illegalargumentexception ( _str ) ; } if ( lockstate . setlock != this ) { throw new illegalargumentexception ( _str ) ; } if ( lockstate . thread != thread . currentthread ( ) ) { throw new illegalargumentexception ( _str ) ; } threadset . remove ( thread . currentthread ( ) ) ; for ( reentrantlock lock : lockstate . locks ) { lock . unlock ( ) ; } }	unlocks the objects acquired from locking.
public static string formatjavadocbox ( string text ) { requirenonnull ( text ) ; return formattextbox ( text , java_doc_width , javadoc_words , java_doc_single_line_words ) ; }	creates and returns a string formatted so it will fit in a box suitable for a java doc header .
private static string forcenumberstringtotwodigits ( string text ) { while ( text . length ( ) < _num ) { text = _str + text ; } if ( text . length ( ) > _num ) { text = text . substring ( text . length ( ) - _num , text . length ( ) ) ; } return text ; }	forcenumberstringtotwodigits , this takes a string of digits , and forces it to be two digits long.
public void adddropitem ( final string name , final double probability , final int min , final int max ) { dropsitems . add ( new dropitem ( name , probability , min , max ) ) ; }	adds a named item to the list of items that will be dropped on dead if cleardropitemlist hasn ' t been called first , this will change all creatures of this kind .
public static < e extends identifiable > list < e > findbyprimarykeys ( entitymanager em , list < biginteger > ids , class < e > type ) { requireargument ( em != null , _str ) ; requireargument ( ids != null && ! ids . isempty ( ) , _str ) ; requireargument ( type != null , _str ) ; typedquery < e > query = em . createnamedquery ( _str , type ) ; query . sethint ( _str , _str ) ; try { query . setparameter ( _str , ids ) ; query . setparameter ( _str , _bool ) ; return query . getresultlist ( ) ; } catch ( noresultexception ex ) { return new arraylist < > ( _num ) ; } }	finds jpa entities by their primary keys .
private void loadworkflow ( properties ctx , int ad_workflow_id , httpsession sess ) { mworkflow wf = new mworkflow ( ctx , ad_workflow_id , null ) ; mwfnode [ ] nodes = wf . getnodes ( _bool , env . getcontextasint ( ctx , _str ) ) ; mwfnode wfn = null ; arraylist nodes_id = new arraylist ( ) ; for ( int i = _num ; i < nodes . length ; i ++ ) { wfn = nodes [ i ] ; nodes_id . add ( new integer ( wfn . getad_wf_node_id ( ) ) ) ; } int imagemap [ ] [ ] = generateimagemap ( nodes_id ) ; sess . setattribute ( workflow , wf ) ; sess . setattribute ( nodes , nodes ) ; sess . setattribute ( nodes_id , nodes_id ) ; sess . setattribute ( image_map , imagemap ) ; sess . setattribute ( active_node , new integer ( - _num ) ) ; }	load workflw and initialize the session attributes .
public int hashcode ( ) { int h = hash ; if ( h == - _num ) { try { h = arrays . hashcode ( x509certimpl . getencodedinternal ( this ) ) ; } catch ( certificateexception e ) { h = _num ; } hash = h ; } return h ; }	returns a hashcode value for this certificate from its encoded form .
public void removefromtags ( string removetag ) { tags . remove ( removetag ) ; firepropertychange ( tag , null , removetag ) ; firepropertychange ( tags_as_string , null , removetag ) ; }	removes the from tags .
public static boolean verify ( byte [ ] data , byte [ ] signature , byte [ ] pub ) { preconditions . checkargument ( data . length == _num && signature . length <= _num && pub . length <= _num ) ; bytebuffer bytebuff = nativeecdsabuffer . get ( ) ; if ( bytebuff == null ) { bytebuff = bytebuffer . allocatedirect ( _num + _num + _num + _num ) ; bytebuff . order ( byteorder . nativeorder ( ) ) ; nativeecdsabuffer . set ( bytebuff ) ; } bytebuff . rewind ( ) ; bytebuff . put ( data ) ; bytebuff . putint ( signature . length ) ; bytebuff . putint ( pub . length ) ; bytebuff . put ( signature ) ; bytebuff . put ( pub ) ; return secp256k1_ecdsa_verify ( bytebuff ) == _num ; }	verifies the given secp256k1 signature in native code . calling when enabled = = false is undefined ( probably library not loaded ).
protected void deletedirectory ( file webappfile ) { if ( webappfile . isdirectory ( ) ) { file [ ] children = webappfile . listfiles ( ) ; for ( file element : children ) { deletedirectory ( element ) ; } webappfile . delete ( ) ; } else { webappfile . delete ( ) ; } }	recursively delete the webapp directory .
@ suppresswarnings ( _str ) static public void assertsameiteratoranyorder ( final object [ ] expected , final iterator actual ) { assertsameiteratoranyorder ( _str , expected , actual ) ; }	verifies that the iterator visits the specified objects in some arbitrary ordering and that the iterator is exhausted once all expected objects have been visited.
public static string formattingfinishedpercentage ( final rolloutgroup rolloutgroup , final float finishedpercentage ) { float tmpfinishedpercentage = _num ; switch ( rolloutgroup . getstatus ( ) ) { case ready : case scheduled : case error : tmpfinishedpercentage = _num ; break ; case finished : tmpfinishedpercentage = _num ; break ; case running : tmpfinishedpercentage = finishedpercentage ; break ; default : break ; } return string . format ( _str , tmpfinishedpercentage ) ; }	formats the finished percentage of a rollout group into a string with one digit after comma .
public static string generatehostname ( string vmname , string hostid ) { string hostname = vmname + _str + hostid ; preconditions . checkstate ( hostname . equals ( hostname . tolowercase ( ) ) , _str ) ; return hostname ; }	generates the hostname for a node .
protected void transferfromfile ( file idfile ) throws ioexception { try ( bufferedreader br = new bufferedreader ( new filereader ( idfile ) ) ) { string line ; while ( ( line = br . readline ( ) ) != null ) { line = line . trim ( ) ; if ( line . length ( ) > _num ) { transfer ( line ) ; } } } }	transfer all the sequences listed in the supplied file , interpreting entries appropriately .
private static string unwrap ( string expression ) { if ( expression . startswith ( _str ) ) { expression = expression . substring ( expression . indexof ( _str ) + _num , expression . length ( ) - _num ) ; if ( expression . endswith ( _str ) ) { expression = expression . substring ( _num , expression . lastindexof ( _str ) ) ; } else { expression = expression . substring ( _num , expression . lastindexof ( _str ) ) ; } } return expression ; }	removes the outermost property from a nested getter expression.
public boolean areallsegmentpresent ( int datasetsize ) { return mpiesegmentlist . size ( ) == datasetsize ; }	if we have all piechart config then there is no point in reloading it.
protected int drawnexteventtimediff ( ) { int timediff = msginterval [ _num ] == msginterval [ _num ] ? _num : rng . nextint ( msginterval [ _num ] - msginterval [ _num ] ) ; return msginterval [ _num ] + timediff ; }	generates a ( random ) time difference between two events.
private int createlines ( string text , int insertposition , int offset ) { int count = _num ; int start = _num ; delimiterinfo delimiterinfo = nextdelimiterinfo ( text , _num ) ; while ( delimiterinfo != null && delimiterinfo . delimiterindex > - _num ) { int index = delimiterinfo . delimiterindex + ( delimiterinfo . delimiterlength - _num ) ; if ( insertposition + count >= flines . size ( ) ) flines . add ( new line ( offset + start , offset + index , delimiterinfo . delimiter ) ) ; else flines . add ( insertposition + count , new line ( offset + start , offset + index , delimiterinfo . delimiter ) ) ; ++ count ; start = index + _num ; delimiterinfo = nextdelimiterinfo ( text , start ) ; } if ( start < text . length ( ) ) { if ( insertposition + count < flines . size ( ) ) { line l = ( line ) flines . get ( insertposition + count ) ; int delta = text . length ( ) - start ; l . offset -= delta ; l . length += delta ; } else { flines . add ( new line ( offset + start , offset + text . length ( ) - _num , null ) ) ; ++ count ; } } return count ; }	creates the line structure for the given text.
public static double sqrt ( double x ) { return math . sqrt ( x ) ; }	returns the positive square root of the specified value .
private resultpointsandtransitions transitionsbetween ( resultpoint from , resultpoint to ) { int fromx = ( int ) from . getx ( ) ; int fromy = ( int ) from . gety ( ) ; int tox = ( int ) to . getx ( ) ; int toy = ( int ) to . gety ( ) ; boolean steep = math . abs ( toy - fromy ) > math . abs ( tox - fromx ) ; if ( steep ) { int temp = fromx ; fromx = fromy ; fromy = temp ; temp = tox ; tox = toy ; toy = temp ; } int dx = math . abs ( tox - fromx ) ; int dy = math . abs ( toy - fromy ) ; int error = - dx > > _num ; int ystep = fromy < toy ? _num : - _num ; int xstep = fromx < tox ? _num : - _num ; int transitions = _num ; boolean inblack = image . get ( steep ? fromy : fromx , steep ? fromx : fromy ) ; for ( int x = fromx , y = fromy ; x != tox ; x += xstep ) { boolean isblack = image . get ( steep ? y : x , steep ? x : y ) ; if ( isblack != inblack ) { transitions ++ ; inblack = isblack ; } error += dy ; if ( error > _num ) { if ( y == toy ) { break ; } y += ystep ; error -= dx ; } } return new resultpointsandtransitions ( from , to , transitions ) ; }	counts the number of black / white transitions between two points , using something like bresenham ' s algorithm .
public static string tobits ( final long x ) { final stringbuilder sb = new stringbuilder ( ) ; long t = x ; for ( int i = _num ; i < _num ; i ++ ) { if ( ( i & _num ) == _num && i > _num ) { sb . append ( _str ) ; } sb . append ( t < _num ? _str : _str ) ; t = t << _num ; } assert t == _num ; return sb . tostring ( ) ; }	convert a number into a bit string with separators between each group of 8 .
public static final byte [ ] encodeurl ( bitset urlsafe , byte [ ] bytes ) { if ( bytes == null ) { return null ; } if ( urlsafe == null ) { urlsafe = www_form_url ; } bytearrayoutputstream buffer = new bytearrayoutputstream ( ) ; for ( int i = _num ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b < _num ) { b = _num + b ; } if ( urlsafe . get ( b ) ) { if ( b == _str ) { b = _str ; } buffer . write ( b ) ; } else { buffer . write ( _str ) ; char hex1 = character . touppercase ( character . fordigit ( ( b > > _num ) & _num , _num ) ) ; char hex2 = character . touppercase ( character . fordigit ( b & _num , _num ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } } return buffer . tobytearray ( ) ; }	encodes an array of bytes into an array of url safe 7 - bit characters.
public messagetokenizer ( idiscordclient client , string content ) { if ( content == null ) throw new illegalargumentexception ( _str ) ; if ( content . length ( ) == _num ) throw new illegalargumentexception ( _str ) ; if ( client == null ) throw new illegalargumentexception ( _str ) ; this . content = content ; this . client = client ; stepforward ( _num ) ; }	initializes with the string contents .
public void await ( int id ) throws interruptedexception { if ( parties == _num ) return ; final boolean startcondition = competitioncondition ; int competingfor = ( locks . length * _num - _num - id ) / _num ; while ( competingfor >= _num ) { final lock node = locks [ competingfor ] ; if ( node . trylock ( ) ) { synchronized ( node ) { while ( competitioncondition == startcondition ) node . wait ( ) ; } node . unlock ( ) ; wakeuptarget ( competingfor * _num + _num ) ; wakeuptarget ( competingfor * _num + _num ) ; return ; } else { if ( competingfor == _num ) break ; competingfor = ( competingfor - _num ) / _num ; } } competitioncondition = ! competitioncondition ; wakeuptarget ( _num ) ; }	waits for all threads to reach this barrier .
private void loadtranslationscacheifempty ( ) { if ( translationcache . isempty ( ) ) { for ( objecttranslation translation : translations ) { if ( translation . getlocale ( ) != null && translation . getproperty ( ) != null && ! stringutils . isempty ( translation . getvalue ( ) ) ) { string key = objecttranslation . getcachekey ( translation . getlocale ( ) , translation . getproperty ( ) ) ; translationcache . put ( key , translation . getvalue ( ) ) ; } } } }	populates the translationscache map unless it is already populated .
public navmousemode ( boolean shouldconsumeevents ) { super ( modeid , shouldconsumeevents ) ; setmodecursor ( cursor . getpredefinedcursor ( cursor . crosshair_cursor ) ) ; rectattributes . setlinepaint ( color . gray ) ; rectattributes . setmattingpaint ( color . light_gray ) ; rectattributes . setmatted ( _bool ) ; }	construct a navmousemode . lets you set the consume mode . if the events are consumed , then a mouseevent is sent only to the first mapmouselistener that successfully processes the event . if they are not consumed , then all of the listeners get a chance to act on the event .
public void addevent ( simevent newevent ) { newevent . setserial ( serial ++ ) ; sortedset . add ( newevent ) ; }	adds a new event to the queue.
public static void stoptimer ( string name ) { long stoptime = system . nanotime ( ) ; long starttime = opentimers . remove ( name ) ; if ( starttime == null ) { throw new illegalargumentexception ( _str ) ; } summarystatistics statistics = data . get ( name ) ; if ( statistics == null ) { statistics = new summarystatistics ( ) ; data . put ( name , statistics ) ; } statistics . addvalue ( stoptime - starttime ) ; }	stops the timer with the specified name .
public string tostringsummary ( ) { int resultsetlength ; string result ; string titles ; int i ; int j ; if ( m_nonsigwins == null ) return _str ; resultsetlength = _num + math . max ( ( int ) ( math . log ( getcolcount ( ) ) / math . log ( _num ) ) , ( int ) ( math . log ( getrowcount ( ) ) / math . log ( _num ) ) ) ; result = _str ; titles = _str ; result += _str ; result += _str + _str ; result += _str ; result += _str ; for ( i = _num ; i < getcolcount ( ) ; i ++ ) { if ( getcolhidden ( i ) ) continue ; titles += _str ; result += _str ; titles += _str + utils . padleft ( _str + getsummarytitle ( i ) , resultsetlength * _num + _num ) ; } result += _str ; result += titles + _str ; for ( i = _num ; i < getcolcount ( ) ; i ++ ) { if ( getcolhidden ( i ) ) continue ; for ( j = _num ; j < getcolcount ( ) ; j ++ ) { if ( getcolhidden ( j ) ) continue ; if ( j == _num ) result += ( char ) ( ( int ) _str + i % _num ) ; if ( j == i ) result += _str ; else result += _str + m_nonsigwins [ i ] [ j ] + _str + m_wins [ i ] [ j ] + _str ; } result += _str ; } result += _str ; return result ; }	returns the summary as string .
public static file createtemppath ( string path ) throws ioexception { string sep = file . separator ; file tempdir = new file ( system . getproperty ( _str ) + sep + path ) ; if ( ! tempdir . exists ( ) ) if ( ! tempdir . mkdirs ( ) ) { boolean status = tempdir . delete ( ) ; throw new ioexception ( _str + tempdir + _str + status ) ; } tempdir . deleteonexit ( ) ; return tempdir ; }	create a hierarchy of directories ( a path ) in the designated temp dir.
public void hspan ( double start , double end , paint color , string legend ) { legendtext legendtext = new legendtext ( color , legend ) ; comments . add ( legendtext ) ; plotelements . add ( new hspan ( start , end , color , legendtext ) ) ; }	draws a horizontal span into the graph and optionally adds a legend .
public stateinteractive extent_to_whole_connections ( ) { set < brditem > selected_items = new treeset < brditem > ( ) ; for ( brditem curr_item : items_list ) { if ( curr_item instanceof brdconnectable ) { selected_items . addall ( curr_item . get_connection_items ( ) ) ; } } if ( selected_items . isempty ( ) ) { return return_state ; } items_list = selected_items ; actlog_start_scope ( logfilescope . extend_to_whole_connections ) ; filter ( ) ; i_brd . repaint ( ) ; return this ; }	select also all items belonging to any connection of the current selected items .
public static ikeybuilder newinstance ( int capacity , collatorenum collatorchoice , locale locale , object strength , decompositionenum mode ) { if ( collatorchoice == collatorenum . ascii ) { return new keybuilder ( capacity ) ; } if ( locale == null ) { locale = locale . getdefault ( ) ; if ( log . isinfoenabled ( ) ) log . info ( _str + locale . getdisplayname ( ) ) ; } final boolean icu = collatorchoice == collatorenum . icu ; if ( icu && ! defaultkeybuilderfactory . isicuavailable ( ) ) { throw new unsupportedoperationexception ( defaultkeybuilderfactory . icu_not_available ) ; } final byte [ ] buf = createbuffer ( capacity ) ; final int len = _num ; switch ( collatorchoice ) { case icu : return new keybuilder ( new icusortkeygenerator ( locale , strength , mode ) , len , buf ) ; case jdk : return new keybuilder ( new jdksortkeygenerator ( locale , strength , mode ) , len , buf ) ; default : throw new unsupportedoperationexception ( _str + collatorchoice ) ; } }	create a new instance that optionally supports unicode sort keys .
private list < node > possibleparents ( node x , list < node > nodes , iknowledge knowledge ) { list < node > possibleparents = new linkedlist < > ( ) ; string _x = x . getname ( ) ; for ( node z : nodes ) { string _z = z . getname ( ) ; if ( possibleparentof ( _z , _x , knowledge ) ) { possibleparents . add ( z ) ; } } return possibleparents ; }	removes from the list of nodes any that cannot be parents of x given the background knowledge .
protected void configurefromproperties ( inputstream is , string rootdirectory ) throws ioexception { properties props = new properties ( ) ; props . load ( is ) ; props . put ( root_dir_path_property , rootdirectory ) ; string oldprefix = getpropertyprefix ( ) ; setproperties ( null , props ) ; setpropertyprefix ( oldprefix ) ; }	called with an input stream for a properties file , used for reading tiles.
connection opennewconnection ( ) throws sqlexception { connection newconn = drivermanager . getconnection ( url , user , password ) ; if ( url . startswith ( _str ) ) { try ( statement s = newconn . createstatement ( ) ) { } } else if ( url . startswith ( _str ) ) { try ( statement s = newconn . createstatement ( ) ) { s . execute ( _str ) ; } } return newconn ; }	open a new database connection.
@ override public void addrelations ( task task , iterable < objectid > projectids , string fieldname ) { list < project > newprojectlist = new linkedlist < > ( ) ; iterable < project > projectstoadd = projectrepository . findall ( projectids , null ) ; for ( project project : projectstoadd ) { newprojectlist . add ( project ) ; } try { if ( propertyutils . getproperty ( task , fieldname ) != null ) { iterable < project > projects = ( iterable < project > ) propertyutils . getproperty ( task , fieldname ) ; for ( project project : projects ) { newprojectlist . add ( project ) ; } } } catch ( exception e ) { throw new runtimeexception ( e ) ; } try { propertyutils . setproperty ( task , fieldname , newprojectlist ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } taskrepository . save ( task ) ; }	a simple implementation of the addrelations method which presents the general concept of the method.
protected void dofloodbddp ( long pinswitch , ofpacketin pi , floodlightcontext cntx ) { topologyinstance ti = getcurrentinstance ( _bool ) ; set < long > switches = ti . getswitchesinopenflowdomain ( pinswitch ) ; if ( switches == null ) { switches = new hashset < long > ( ) ; switches . add ( pinswitch ) ; } for ( long sid : switches ) { iofswitch sw = floodlightprovider . getswitch ( sid ) ; if ( sw == null ) continue ; collection < short > enabledports = sw . getenabledportnumbers ( ) ; if ( enabledports == null ) continue ; set < short > ports = new hashset < short > ( ) ; ports . addall ( enabledports ) ; set < short > portsknowntotopo = ti . getportswithlinks ( sid ) ; if ( portsknowntotopo != null ) { for ( short p : portsknowntotopo ) { nodeporttuple npt = new nodeporttuple ( sid , p ) ; if ( ti . isbroadcastdomainport ( npt ) == _bool ) { ports . remove ( p ) ; } } } set < short > portstoeliminate = getportstoeliminateforbddp ( sid ) ; if ( portstoeliminate != null ) { ports . removeall ( portstoeliminate ) ; } if ( pinswitch == sid ) { ports . remove ( pi . getinport ( ) ) ; } domultiactionpacketout ( pi . getpacketdata ( ) , sw , ports , cntx ) ; } }	the bddp packets are forwarded out of all the ports out of an openflowdomain.
public void sleepmillis ( final long millis ) { try { thread . sleep ( millis ) ; } catch ( final interruptedexception e ) { logger . error ( e , e ) ; } }	waits the specified number of milliseconds .
private static void verifywritesetnotfound ( final btree btree ) { log . info ( _str ) ; for ( int i = _num ; i < _num ; i ++ ) { if ( btree . contains ( i ) ) { throw new runtimeexception ( _str + i ) ; } } }	verify that the write set is not found ( no keys in [ 0 : 1000 ) ) .
private double calculateentropy ( double ... masses ) { double res = _num ; for ( double d : masses ) { res -= ( d == _num ) ? _num : d * math . log ( d ) ; } return res / log2 ; }	calculates the entropy corresponding to the input masses .
public static boolean isvalidnmtoken ( string nmtoken ) { if ( nmtoken . length ( ) == _num ) return _bool ; for ( int i = _num ; i < nmtoken . length ( ) ; i ++ ) { char ch = nmtoken . charat ( i ) ; if ( ! isname ( ch ) ) { return _bool ; } } return _bool ; }	check to see if a string is a valid nmtoken according to [ 7 ] in the xml 1 . 0 recommendation.
private static double parsedoublevalue ( string parsestring , string opentag , string closetag , datatypevalidationexception exception ) throws datatypevalidationexception { string tagvalue ; tagvalue = parsestringvalue ( parsestring , opentag , closetag , exception ) ; double doublevalue ; try { doublevalue = double . parsedouble ( tagvalue ) ; } catch ( numberformatexception e ) { throw e ; } return doublevalue ; }	parses out and converts the text located between first occurrences of the open and closed tags into double .
public void putstring ( string s ) throws arrayindexoutofboundsexception , unsupportedencodingexception { byte [ ] bytes = s . getbytes ( _str ) ; int length = bytes . length ; int endat = m_index + length + _num ; if ( endat > m_content . length ) throw new arrayindexoutofboundsexception ( endat + _str + m_content . length ) ; system . arraycopy ( bytes , _num , m_content , m_index , length ) ; m_index += length ; m_content [ m_index ++ ] = _str ; debugappendstring ( s ) ; }	place a string into the message ( using utf - 8 encoding ).
public void addrtcplistener ( rtcpeventlistener listener ) { listeners . addelement ( listener ) ; }	add a rtcp event listener.
@ override protected void ensurenumberofcolumns ( int numberofcolumns ) { if ( data . length >= numberofcolumns ) { return ; } double [ ] newdata = new double [ numberofcolumns ] ; system . arraycopy ( data , _num , newdata , _num , data . length ) ; data = newdata ; }	creates a new array of the given size if necessary and copies the data into the new array .
@ override public void error ( string domain , string key , xmlparseexception exception ) throws xniexception { if ( ferrorhandler != null ) { saxparseexception saxexception = createsaxparseexception ( exception ) ; try { ferrorhandler . error ( saxexception ) ; } catch ( saxparseexception e ) { throw createxmlparseexception ( e ) ; } catch ( saxexception e ) { throw createxniexception ( e ) ; } } }	reports an error . errors are non - fatal and usually signify that the document is invalid with respect to its grammar ( s ) .
public static boolean connect ( filedescriptor fd , inetaddress inetaddress , int port ) throws socketexception { try { return iobridge . connect ( fd , inetaddress , port , _num ) ; } catch ( sockettimeoutexception ex ) { throw new assertionerror ( ex ) ; } }	connects socket ' fd ' to ' inetaddress ' on ' port ' , with no timeout.
public boolean iswhitespace ( int nodehandle ) { int type = getnodetype ( nodehandle ) ; node node = getnode ( nodehandle ) ; if ( text_node == type || cdata_section_node == type ) { faststringbuffer buf = stringbufferpool . get ( ) ; while ( node != null ) { buf . append ( node . getnodevalue ( ) ) ; node = logicalnextdomtextnode ( node ) ; } boolean b = buf . iswhitespace ( _num , buf . length ( ) ) ; stringbufferpool . free ( buf ) ; return b ; } return _bool ; }	determine if the string - value of a node is whitespace.
public cstatuspanel ( final backenddebuggerprovider debuggerprovider ) { super ( new borderlayout ( ) ) ; preconditions . checknotnull ( debuggerprovider , _str ) ; m_label . setforeground ( color . black ) ; add ( m_label ) ; m_synchronizer = new cstatuslabelsynchronizer ( m_label , debuggerprovider ) ; }	creates a new status panel .
@ override public boolean open ( string access ) { if ( access . equals ( _str ) ) { try { istream = new fileimageinputstream ( new file ( filepath ) ) ; parser = new labelparser ( ) ; metadata = parser . parseheader ( istream ) ; istream . close ( ) ; istream = null ; } catch ( ioexception e ) { try { istream . close ( ) ; } catch ( exception x ) { } return ( _bool ) ; } } return ( super . open ( access ) ) ; }	open the pds file .
void deregisterspring ( spring spring ) { if ( spring == null ) { throw new illegalargumentexception ( _str ) ; } mactivesprings . remove ( spring ) ; mspringregistry . remove ( spring . getid ( ) ) ; }	deregisters a spring from this basespringsystem , so it won ' t be iterated anymore.
@ nullable public string filename ( ) { return javalogger . filename ( delegate ) ; }	returns current log file .
public static bnode parsebnode ( string ntriplesbnode , valuefactory valuefactory ) throws illegalargumentexception { if ( ntriplesbnode . startswith ( _str ) ) { return valuefactory . createbnode ( ntriplesbnode . substring ( _num ) ) ; } else { throw new illegalargumentexception ( _str + ntriplesbnode ) ; } }	parses an n - triples bnode , creates an object for it using the supplied valuefactory and returns this object .
public void resetpsrs ( ) { pilotrolls . removeallelements ( ) ; }	resets the psr list .
public static void sort ( byte [ ] array ) { dualpivotquicksort . sort ( array ) ; }	sorts the specified array in ascending numerical order .
public void closepopup ( ) { if ( openedsubpopup != null ) { openedsubpopup . closepopup ( ) ; } removefromparent ( ) ; }	close this popup menu .
public void freeobject ( int id ) { if ( cacheid == id ) { cacheid = - _num ; cache = null ; } map . remove ( id ) ; }	remove an object from the map .
private void stretchviewvertically ( view view , int crosssize ) { layoutparams lp = ( layoutparams ) view . getlayoutparams ( ) ; int newheight = crosssize - lp . topmargin - lp . bottommargin ; newheight = math . max ( newheight , _num ) ; view . measure ( measurespec . makemeasurespec ( view . getmeasuredwidth ( ) , measurespec . exactly ) , measurespec . makemeasurespec ( newheight , measurespec . exactly ) ) ; }	expand the view vertically to the size of the crosssize ( considering the view margins ).
public static inetaddress hextoinet6address ( string addrhexstring ) throws illegalargumentexception { try { return numerictoinetaddress ( string . format ( _str , addrhexstring . substring ( _num , _num ) , addrhexstring . substring ( _num , _num ) , addrhexstring . substring ( _num , _num ) , addrhexstring . substring ( _num , _num ) , addrhexstring . substring ( _num , _num ) , addrhexstring . substring ( _num , _num ) , addrhexstring . substring ( _num , _num ) , addrhexstring . substring ( _num , _num ) ) ) ; } catch ( exception e ) { log . e ( _str , _str + addrhexstring + _str + e ) ; throw new illegalargumentexception ( e ) ; } }	convert a 32 char hex string into a inet6address . throws a runtime exception if the string isn ' t 32 chars , isn ' t hex or can ' t be made into an inet6address.
public void trackfailure ( ) { retrytime = utils . currenttimemillis ( ) + ( long ) backoff ; backoff = math . min ( backoff * params . multiplier , params . maximum ) ; }	track a failure - multiply the back off interval by the multiplier.
public double readdouble ( ) throws ioexception { return primitivetypes . readdouble ( ) ; }	reads a double ( 64 bit ) from the source stream .
private boolean isatmaximum ( adjustable bar ) { return ( bar . getvalue ( ) + bar . getvisibleamount ( ) >= bar . getmaximum ( ) ) ; }	check if a scroll bar is at its maximum value .
public boolean matchescs ( string seq ) { return queue . startswith ( seq , pos ) ; }	case sensitive match test .
protected void parseandaddmaptileset ( url tilesetproperties ) throws ioexception , malformedurlexception { properties descprops = new properties ( ) ; logger logger = getlogger ( ) ; logger . info ( _str ) ; inputstream descurlstream = tilesetproperties . openstream ( ) ; descprops . load ( descurlstream ) ; logger . info ( _str + tilesetproperties . tostring ( ) + _str + descprops . tostring ( ) ) ; maptileset mts = createmaptilesetfromproperties ( descprops ) ; if ( mts != null && mts . allgood ( ) ) { string mtsname = mts . getname ( ) ; maptilesets . put ( mts . getname ( ) , mts ) ; logger . info ( _str + mtsname + _str ) ; } descurlstream . close ( ) ; }	given a url to a properties file describing a maptileset , create it and add it to the list .
protected date compute ( double value ) { if ( double . isnan ( value ) ) { return null ; } long datelong = ( long ) value ; date date = new date ( datelong ) ; calendar cal = calendar . getinstance ( ) ; cal . settime ( date ) ; return cal . gettime ( ) ; }	computes the result for one input double value .
public void enablepan ( bluetoothadapter adapter ) { if ( mpan == null ) mpan = ( bluetoothpan ) connectproxy ( adapter , bluetoothprofile . pan ) ; assertnotnull ( mpan ) ; long start = system . currenttimemillis ( ) ; mpan . setbluetoothtethering ( _bool ) ; long stop = system . currenttimemillis ( ) ; asserttrue ( mpan . istetheringon ( ) ) ; writeoutput ( string . format ( _str , ( stop - start ) ) ) ; }	enables pan tethering on the local device and checks to make sure that tethering is enabled .
private int distbetweenpoints ( int x1 , int z1 , int x2 , int z2 , boolean ballowdiags ) { int w = math . abs ( x2 - x1 ) ; int h = math . abs ( z2 - z1 ) ; if ( ballowdiags ) { if ( w < h ) w = _num ; else h = _num ; } return w + h + _num ; }	calculate the number of cells on the shortest path between ( x1 , z1 ) and ( x2 , z2 ).
public url ( string protocol , string host , int port , string file , urlstreamhandler handler ) throws malformedurlexception { if ( port < - _num ) { throw new malformedurlexception ( _str + port ) ; } if ( protocol == null ) { throw new nullpointerexception ( _str ) ; } if ( host != null && host . contains ( _str ) && host . charat ( _num ) != _str ) { host = _str + host + _str ; } this . protocol = protocol ; this . host = host ; this . port = port ; file = urlutils . authoritysafepath ( host , file ) ; int hash = file . indexof ( _str ) ; if ( hash != - _num ) { this . file = file . substring ( _num , hash ) ; this . ref = file . substring ( hash + _num ) ; } else { this . file = file ; } fixurl ( _bool ) ; if ( handler == null ) { setupstreamhandler ( ) ; if ( streamhandler == null ) { throw new malformedurlexception ( _str + protocol ) ; } } else { streamhandler = handler ; } }	creates a new url of the given component parts.
private workflow . method createvolumesmethod ( uri systemuri , uri pooluri , list < uri > volumeuris , virtualpoolcapabilityvalueswrapper capabilities ) { return new workflow . method ( _str , systemuri , pooluri , volumeuris , capabilities ) ; }	return a workflow . method for createvolumes .
public filecommandinfo ( int fd , string command , int result , string parameters ) { this ( _bool , fd , command , result , parameters ) ; }	example : 0x1001 , " close " , 0x0 , " ".
public void init ( guimanualherblore manual ) { for ( manualwidgetbase widget : widgets ) widget . init ( manual ) ; }	initializes the widgets in this page.
private static sslsocketfactory trustallhosts ( httpsurlconnection connection ) { sslsocketfactory oldfactory = connection . getsslsocketfactory ( ) ; try { sslcontext sc = sslcontext . getinstance ( _str ) ; sc . init ( null , trustallcerts , new java . security . securerandom ( ) ) ; sslsocketfactory newfactory = sc . getsocketfactory ( ) ; connection . setsslsocketfactory ( newfactory ) ; } catch ( exception e ) { log . e ( log_tag , e . getmessage ( ) , e ) ; } return oldfactory ; }	this function will install a trust manager that will blindly trust all ssl certificates.
public final double samplemax ( ) { return _activecountmax . getandset ( _activecount . get ( ) ) ; }	sample the active count.
@ get public representation usercodeform ( ) throws oauth2restletexception , invalidgrantexception , notfoundexception , serverexception { final oauth2request request = requestfactory . create ( getrequest ( ) ) ; if ( request . getparameter ( oauth2constants . devicecode . user_code ) != null ) { return verify ( null ) ; } else { return gettemplaterepresentation ( form , request , null ) ; } }	handles get requests to the oauth2 device / user endpoint , returning a form to allow the user to submit their user code.
public void testmissionnameconstruction ( ) { string xml = _str ; xml += createstartmissionxml ( _str , _str ) ; xml += createendmissionxml ( ) ; inputstream missioninputstream = new bytearrayinputstream ( xml . getbytes ( ) ) ; string missionname = null ; try { missionname = missionparser . getmissionname ( missioninputstream ) ; } catch ( missionparseexception e ) { e . printstacktrace ( ) ; } assert . assertequals ( _str , missionname ) ; }	test for correct reading of a mission name .
@ override public boolean equals ( object other ) { if ( other == this ) { return _bool ; } if ( other instanceof zoneoffsettransition ) { zoneoffsettransition d = ( zoneoffsettransition ) other ; return transition . equals ( d . transition ) && offsetbefore . equals ( d . offsetbefore ) && offsetafter . equals ( d . offsetafter ) ; } return _bool ; }	checks if this object equals another.
public void release ( ) { super . release ( ) ; init ( ) ; }	releases any resources we may have ( or inherit ).
public void close ( ) { while ( ! mreceivers . isempty ( ) ) { mcontext . unregisterreceiver ( mreceivers . remove ( _num ) ) ; } if ( moutputwriter != null ) { try { moutputwriter . close ( ) ; } catch ( ioexception e ) { log . w ( mtag , _str , e ) ; } } }	closes the utility instance and unregisters any broadcastreceivers .
private void resolvefiles ( list < string > classpaths , map < string , string > files , string [ ] paths , string prefix ) { for ( string path : paths ) { string relativepath = filehandler . getname ( path ) ; if ( prefix != null ) { relativepath = filehandler . append ( prefix , relativepath ) ; } if ( classpaths != null ) { classpaths . add ( relativepath ) ; } if ( filehandler . isdirectory ( path ) ) { string [ ] children = filehandler . getchildren ( path ) ; if ( children != null && children . length != _num ) { resolvefiles ( null , files , children , relativepath ) ; } } else { files . put ( relativepath , path ) ; } } }	resolves all files it finds into a map , with relative paths as the key and absolute path as the value .
public void testgetinstance ( ) throws exception { try { exemptionmechanism . getinstance ( ( string ) null , _str ) ; fail ( _str ) ; } catch ( nosuchproviderexception pe ) { } try { exemptionmechanism . getinstance ( _str , ( string ) null ) ; fail ( _str ) ; } catch ( illegalargumentexception e ) { } }	javax / crypto / exemptionmechanism # getinstance ( string algorithm , string provider ) checks exception order.
public synchronized void reloadconfiguration ( ) { properties = null ; finalparameters . clear ( ) ; }	reload configuration from previously added resources.
protected void removemessageprocessor ( messageprocessor oldmessageprocessor ) { synchronized ( messageprocessors ) { if ( messageprocessors . remove ( oldmessageprocessor ) ) { oldmessageprocessor . stop ( ) ; } } }	removes a messageprocessor from this sipstack .
x509issuerserial ( x509certificate cert ) { this ( cert . getissuerx500principal ( ) , cert . getserialnumber ( ) ) ; }	construct an x509issuerserial from an x509certificate .
private void addtoset ( objectxmlpersist persist , ifile file , string setname ) throws ioexception , coreexception { collection < graphedgematcherdescriptor > updateset = loadedgematchers ( persist , file ) ; persistupdatedbundle ( persist , file , updateset , setname ) ; }	add the set to an existing file .
public void putbytes ( byte [ ] bytes ) { ensurecapacity ( bytes . length ) ; system . arraycopy ( bytes , _num , this . bytebuffer , this . position , bytes . length ) ; this . position += bytes . length ; }	put an array of bytes in the buffer .
public static string arraytodelimitedstring ( object [ ] arr , string delim ) { if ( arr == null ) { return _str ; } stringbuffer sb = new stringbuffer ( ) ; for ( int i = _num ; i < arr . length ; i ++ ) { if ( i > _num ) { sb . append ( delim ) ; } sb . append ( arr [ i ] ) ; } return sb . tostring ( ) ; }	convenience method to return a string array as a delimited ( e.
public void clearall ( ) { final list < encodedimage > old ; synchronized ( this ) { old = new arraylist < > ( mmap . values ( ) ) ; mmap . clear ( ) ; } for ( int i = _num ; i < old . size ( ) ; i ++ ) { encodedimage encodedimage = old . get ( i ) ; if ( encodedimage != null ) { encodedimage . close ( ) ; } } }	removes all items from the stagingarea .
public static compierecolor parse ( string attributes ) { compierecolor cc = new compierecolor ( ) ; try { if ( attributes != null && attributes . length ( ) > _num ) cc . parseattributres ( attributes ) ; } catch ( exception e ) { log . severe ( _str + attributes + _str + e . tostring ( ) ) ; } return cc ; }	parse attributes and return adempierecolor.
public synchronized static luastate newluastate ( ) { int i = getnextstateindex ( ) ; luastate l = new luastate ( i ) ; states . add ( i , l ) ; return l ; }	method that creates a new instance of luastate.
static long checkpreamblesize ( memory mem ) { final long cap = mem . getcapacity ( ) ; if ( cap < _num ) { thrownotbigenough ( cap , _num ) ; } final long pre0 = mem . getlong ( _num ) ; final int prelongs = ( int ) ( pre0 & _num ) ; final int required = math . max ( prelongs << _num , _num ) ; if ( cap < required ) { thrownotbigenough ( cap , required ) ; } return pre0 ; }	checks memory for capacity to hold the preamble and returns the first 8 bytes .
public int read ( ) throws ioexception { if ( inputstream == null ) { reopen ( ) ; } count ( _num ) ; return inputstream . read ( ) ; }	read from the file .
public void limit ( double x1 , double y1 , double x2 , double y2 ) { clip [ _num ] = math . max ( clip [ _num ] , x1 ) ; clip [ _num ] = math . max ( clip [ _num ] , y1 ) ; clip [ _num ] = math . min ( clip [ _num ] , x2 ) ; clip [ _num ] = math . min ( clip [ _num ] , y2 ) ; }	limit the clip such that it fits within the specified region .
public void shutdown ( ) { final long begin = system . currenttimemillis ( ) ; log . info ( _str ) ; log . info ( _str + gettaskcount ( scheduledpool ) + _str ) ; log . info ( _str + gettaskcount ( instantpool ) + _str ) ; log . info ( _str + gettaskcount ( longrunningpool ) + _str ) ; log . info ( _str + ( workstealingpool . getqueuedtaskcount ( ) + workstealingpool . getqueuedsubmissioncount ( ) ) + _str ) ; scheduledpool . shutdown ( ) ; instantpool . shutdown ( ) ; longrunningpool . shutdown ( ) ; workstealingpool . shutdown ( ) ; boolean success = _bool ; try { success |= awaittermination ( _num ) ; scheduledpool . setexecuteexistingdelayedtasksaftershutdownpolicy ( _bool ) ; scheduledpool . setcontinueexistingperiodictasksaftershutdownpolicy ( _bool ) ; success |= awaittermination ( _num ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } log . info ( _str + success + _str + ( system . currenttimemillis ( ) - begin ) + _str ) ; log . info ( _str + gettaskcount ( scheduledpool ) + _str ) ; log . info ( _str + gettaskcount ( instantpool ) + _str ) ; log . info ( _str + gettaskcount ( longrunningpool ) + _str ) ; log . info ( _str + ( workstealingpool . getqueuedtaskcount ( ) + workstealingpool . getqueuedsubmissioncount ( ) ) + _str ) ; workstealingpool . shutdownnow ( ) ; }	shutdown all thread pools .
public static collection < inetaddress > toinetaddresses ( collection < string > addrs , collection < string > hostnames ) throws ignitecheckedexception { set < inetaddress > res = new hashset < > ( addrs . size ( ) ) ; iterator < string > hostnamesit = hostnames . iterator ( ) ; for ( string addr : addrs ) { string hostname = hostnamesit . hasnext ( ) ? hostnamesit . next ( ) : null ; inetaddress inetaddr = null ; if ( ! f . isempty ( hostname ) ) { try { inetaddr = inetaddress . getbyname ( hostname ) ; } catch ( unknownhostexception ignored ) { } } if ( inetaddr == null || inetaddr . isloopbackaddress ( ) ) { try { inetaddr = inetaddress . getbyname ( addr ) ; } catch ( unknownhostexception ignored ) { } } if ( inetaddr != null ) res . add ( inetaddr ) ; } if ( res . isempty ( ) ) throw new ignitecheckedexception ( _str + addrs + _str + hostnames + _str ) ; return res ; }	returns tha list of resolved inet addresses.
public static string removenewlinechars ( string s ) { string retstring = null ; if ( ( s != null ) && ( s . length ( ) > _num ) && ( s . indexof ( _str ) != - _num ) ) { char [ ] chars = s . tochararray ( ) ; int len = chars . length ; stringbuffer sb = new stringbuffer ( len ) ; for ( int i = _num ; i < len ; i ++ ) { char c = chars [ i ] ; if ( c != _str ) { sb . append ( c ) ; } } retstring = sb . tostring ( ) ; } else { retstring = s ; } return retstring ; }	removes new line charactors .
void calculatecounters ( ) { if ( ! isdbavailable ( ) ) return ; long time = system . currenttimemillis ( ) ; int total = _num ; write . lock ( ) ; try { countresetfeedsandcategories ( ) ; total += countfeedswithunread ( ) ; countcategorieswithunread ( ) ; countspecialcategories ( total ) ; } finally { write . unlock ( ) ; } log . i ( tag , string . format ( _str , total , ( system . currenttimemillis ( ) - time ) ) ) ; }	set unread counters for feeds and categories according to real amount of unread articles.
protected void appendhtml ( final stringbuilder sbuf , final char ch ) { switch ( ch ) { case _str : sbuf . append ( _str ) ; break ; case _str : sbuf . append ( _str ) ; break ; case _str : sbuf . append ( _str ) ; break ; default : sbuf . append ( ch ) ; break ; } }	append a character to a buffer , escaping html meta - characters when needed .
private collection < var > migratecolumns ( sqltable currenttable ) { list < var > vars = new arraylist < > ( ) ; string tabletype = currenttable . getentitytype ( ) ; map < string , resourcetype . datatype > columns = currenttable . getcolumns ( ) ; map < string , string > foreigncolumns = currenttable . getforeignkeycolumns ( ) ; for ( string column : columns . keyset ( ) ) { resourcetype . datatype columntype = columns . get ( column ) ; if ( foreigncolumns . containskey ( column ) ) { vars . addall ( migrateasrelation ( tabletype , column , foreigncolumns . get ( column ) ) ) ; } else { vars . addall ( migrateasresource ( tabletype , columntype , column ) ) ; } } return vars ; }	loop through each of the columns in the given table , migrating each as a resource or relation .
public int retrieverowcount ( string tablename ) throws sqlexception { resultset rs = null ; int rowcount = - _num ; try { rs = statement . executequery ( _str + tablename ) ; rs . next ( ) ; rowcount = rs . getint ( _num ) ; } finally { if ( rs != null ) { rs . close ( ) ; } } return rowcount ; }	does a count on a given table .
public jarmodifier ( file jarfile ) throws jarexception , ioexception { this . jarfile = jarfile ; jarfile jar = new jarfile ( jarfile ) ; enumeration < ? extends jarentry > enumerator = jar . entries ( ) ; while ( enumerator . hasmoreelements ( ) ) { jarentry currententry = ( jarentry ) enumerator . nextelement ( ) ; jarentry resetentry = new jarentry ( currententry . getname ( ) ) ; jarentries . put ( currententry . getname ( ) , resetentry ) ; } string manifestpath = meta_inf + seperator + _str ; jarentry jarentry = jar . getjarentry ( manifestpath ) ; if ( jarentry != null ) { enumeration < jarentry > entries = jar . entries ( ) ; while ( entries . hasmoreelements ( ) ) { jarentry = ( jarentry ) entries . nextelement ( ) ; if ( manifestpath . equalsignorecase ( jarentry . getname ( ) ) ) { break ; } else { jarentry = null ; } } } manifest manifest = new manifest ( ) ; if ( jarentry != null ) { manifest . read ( jar . getinputstream ( jarentry ) ) ; } this . manifest = manifest ; jar . close ( ) ; }	creates a new jarmodifier with the given archive to be modified.
@ override public int addattribute ( attribute a ) { if ( a == null ) { throw new illegalargumentexception ( _str ) ; } else { int index = - _num ; attribute original = a ; a = ( attribute ) a . clone ( ) ; if ( unusedcolumnlist . size ( ) > _num ) { synchronized ( unusedcolumnlist ) { if ( unusedcolumnlist . size ( ) > _num ) { index = unusedcolumnlist . remove ( _num ) ; attributes . set ( index , a ) ; } else { index = attributes . size ( ) ; attributes . add ( a ) ; } } } else { index = attributes . size ( ) ; attributes . add ( a ) ; } a . settableindex ( index ) ; original . settableindex ( index ) ; return index ; } }	adds the attribute to the list of attributes assigning it a free column index.
default b with ( string key , int value ) { return with ( key , integer . tostring ( value ) ) ; }	associate the given value with the specified key .
public static < x > void sorttopn ( x [ ] array , int offset , int limit , comparator < ? super x > comp ) { partitiontopn ( array , offset , limit , comp ) ; arrays . sort ( array , offset , ( int ) math . min ( ( long ) offset + limit , array . length ) , comp ) ; }	find the top limit values using given comparator and place them as in a full array sort , in descending order .
protected boolean isservertransaction ( ) { return this instanceof sipservertransaction ; }	a shortcut way of telling if we are a server transaction .
object addmarkedoccurrencehighlight ( int start , int end , markoccurrenceshighlightpainter p ) throws badlocationexception { document doc = textarea . getdocument ( ) ; textui mapper = textarea . getui ( ) ; highlightinfo i = new layeredhighlightinfo ( ) ; i . painter = p ; i . p0 = doc . createposition ( start ) ; i . p1 = doc . createposition ( end - _num ) ; markedoccurrences . add ( i ) ; mapper . damagerange ( textarea , start , end ) ; return i ; }	adds a special " marked occurrence " highlight .
public static void readfully ( inputstream in , byte buf [ ] , int off , int len ) throws ioexception { int toread = len ; while ( toread > _num ) { int ret = in . read ( buf , off , toread ) ; if ( ret < _num ) { throw new ioexception ( _str ) ; } toread -= ret ; off += ret ; } }	does the readfully based on the input read .
public static void assumetrue ( booleansupplier assumptionsupplier , supplier < string > messagesupplier ) throws testabortedexception { if ( ! assumptionsupplier . getasboolean ( ) ) { throwtestabortedexception ( messagesupplier . get ( ) ) ; } }	validate the given assumption .
public static string addtocartbulk ( httpservletrequest request , httpservletresponse response ) { string categoryid = request . getparameter ( _str ) ; shoppingcart cart = getcartobject ( request ) ; delegator delegator = ( delegator ) request . getattribute ( _str ) ; localdispatcher dispatcher = ( localdispatcher ) request . getattribute ( _str ) ; shoppingcarthelper carthelper = new shoppingcarthelper ( delegator , dispatcher , cart ) ; string controldirective ; map < string , object > result ; map < string , object > parammap = utilhttp . getparametermap ( request ) ; string catalogid = catalogworker . getcurrentcatalogid ( request ) ; result = carthelper . addtocartbulk ( catalogid , categoryid , parammap ) ; controldirective = processresult ( result , request ) ; if ( controldirective . equals ( error ) ) { return _str ; } else { return _str ; } }	adds all products in a category according to quantity request parameter for each ; if no parameter for a certain product in the category , or if quantity is 0 , do not add.
public void addfrequentset ( frequentitemset itemset ) { frequentsets . add ( itemset ) ; maximumsetsize = math . max ( itemset . getnumberofitems ( ) , maximumsetsize ) ; }	adds a frequent item set to this container.
private int skipfrompeekbuffer ( int length ) { int bytesskipped = math . min ( peekbufferlength , length ) ; updatepeekbuffer ( bytesskipped ) ; return bytesskipped ; }	skips from the peek buffer .
protected workflow . method createremovevolumesfromcgmethod ( uri vplexuri , uri cguri , list < uri > vplexvolumeuris ) { return new workflow . method ( remove_volumes_from_cg_step , vplexuri , cguri , vplexvolumeuris ) ; }	a method that creates the workflow method for removing vplex volumes from a consistency group .
private static int showurlsprompt ( component parent , list < string > urls ) { string text = _str ; for ( string url : urls ) { url = spliturl ( url ) ; text += url + _str ; } string okoption = _str ; if ( urls . size ( ) > _num ) { okoption = _str + urls . size ( ) + _str ; } string [ ] options = { okoption , _str } ; if ( urls . size ( ) == _num ) { options = new string [ ] { okoption , _str , _str } ; } int chosenoption = joptionpane . showoptiondialog ( parent , text , _str , joptionpane . ok_cancel_option , joptionpane . question_message , null , options , _num ) ; return chosenoption ; }	actually show the dialog that contain the given urls and give the user the option to open the url , copy it or cancel the dialog .
int convertmouse ( mouseevent event ) { int result ; if ( panelfont == null ) return ( no_mouse ) ; int coloff = event . getx ( ) - grid_width - panel_margin ; int colnum = coloff / horizstep ; int colrem = coloff % horizstep ; if ( ( colnum >= panelcolumns ) || ( colrem < text_margin ) || ( colrem > ( horizstep - grid_width - text_margin ) ) ) { return ( no_mouse ) ; } int rowoff = event . gety ( ) - grid_width - panel_margin ; int rownum = rowoff / vertistep ; int rowrem = rowoff % vertistep ; if ( ( rowrem < text_margin ) || ( rowrem > ( vertistep - grid_width - text_margin ) ) ) { return ( no_mouse ) ; } result = cornerindex + ( rownum * panelcolumns ) + colnum ; if ( result >= cellcount ) return ( no_mouse ) ; return ( result ) ; }	convert mouse . convert mouse coordinates to a cell index . return < no_mouse > if the mouse is not well - centered on a defined character .
private static string computeregexstring ( string originalstring , string oldname , string newname ) { stringbuilder builder = new stringbuilder ( originalstring . length ( ) ) ; string oldnameornewnameregex = string . format ( _str , pattern . quote ( oldname ) , pattern . quote ( newname ) ) ; int i = originalstring . indexof ( oldname ) ; if ( i >= _num ) { int previ = _num ; while ( i >= _num ) { builder . append ( pattern . quote ( originalstring . substring ( previ , i ) ) ) ; builder . append ( oldnameornewnameregex ) ; previ = i ; i = originalstring . indexof ( oldname , i + oldname . length ( ) ) ; } builder . append ( pattern . quote ( originalstring . substring ( previ + oldname . length ( ) , originalstring . length ( ) ) ) ) ; } return builder . tostring ( ) ; }	computes a regular expression string where each instance of the old name can be fulfilled by either the old name or new name .
public synchronized string generatecallidentifier ( string address ) { string date = long . tostring ( system . currenttimemillis ( ) + callidcounter ++ + rand . nextlong ( ) ) ; byte cid [ ] = digester . digest ( date . getbytes ( ) ) ; string cidstring = utils . tohexstring ( cid ) ; return cidstring + _str + address ; }	generate a call identifier.
int parsehour ( string source , char patternchar , int offset ) throws parseexception { int min = ( patternchar == hour_1_letter || patternchar == hour12_1_letter ) ? _num : _num ; int max = ( ( patternchar == hour_letter || patternchar == hour_1_letter ) ? _num : _num ) + min ; return parsenumber ( source , offset , _str , min , max ) - min ; }	parse a hour value.
public void dohistory ( keyevent e ) { if ( e . getsource ( ) == m_input ) { switch ( e . getkeycode ( ) ) { case keyevent . vk_up : if ( m_historypos > _num ) { m_historypos -- ; string command = m_commandhistory . elementat ( m_historypos ) ; m_input . settext ( command ) ; } break ; case keyevent . vk_down : if ( m_historypos < m_commandhistory . size ( ) ) { m_historypos ++ ; string command = _str ; if ( m_historypos < m_commandhistory . size ( ) ) { command = m_commandhistory . elementat ( m_historypos ) ; } m_input . settext ( command ) ; } break ; default : break ; } } }	changes the currently displayed command line when certain keys are pressed.
public static referencebinding [ ] substitute ( substitution substitution , referencebinding [ ] originaltypes ) { if ( originaltypes == null ) return null ; referencebinding [ ] substitutedtypes = originaltypes ; for ( int i = _num , length = originaltypes . length ; i < length ; i ++ ) { referencebinding originaltype = originaltypes [ i ] ; typebinding substitutedtype = substitute ( substitution , originaltype ) ; if ( ! ( substitutedtype instanceof referencebinding ) ) { return null ; } if ( substitutedtype != originaltype ) { if ( substitutedtypes == originaltypes ) { system . arraycopy ( originaltypes , _num , substitutedtypes = new referencebinding [ length ] , _num , i ) ; } substitutedtypes [ i ] = ( referencebinding ) substitutedtype ; } else if ( substitutedtypes != originaltypes ) { substitutedtypes [ i ] = originaltype ; } } return substitutedtypes ; }	returns an array of types , where original types got substituted given a substitution.
private static collection < tcptransport > allknowntransports ( ) { set < tcptransport > s ; synchronized ( localendpoints ) { s = new hashset < tcptransport > ( localendpoints . size ( ) ) ; for ( linkedlist < tcpendpoint > eplist : localendpoints . values ( ) ) { tcpendpoint ep = eplist . getfirst ( ) ; s . add ( ep . transport ) ; } } return s ; }	returns the current list of known transports.
public void requestsecondsuntilidlelockout ( ) { operations . add ( passwordpolicystateoperationtype . get_seconds_until_idle_lockout ) ; }	returns the seconds until idle lockout .
@ requestmapping ( value = _str , method = { requestmethod . get } ) @ responsebody private static list < string > showhivedatabases ( ) throws ioexception { ihiveclient hiveclient = hiveclientfactory . gethiveclient ( ) ; list < string > results = null ; try { results = hiveclient . gethivedbnames ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; throw new ioexception ( e ) ; } return results ; }	show all databases in hive.
public void testnegnegfirstshorter ( ) { byte abytes [ ] = { - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { - _num , _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , - _num , _num , _num , - _num , - _num } ; int asign = - _num ; int bsign = - _num ; byte rbytes [ ] = { - _num , _num , - _num , - _num , - _num , _num , _num , _num , _num , - _num , - _num , _num , - _num , - _num , _num , - _num , - _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . and ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , result . signum ( ) ) ; }	and for two negative numbers ; the first is shorter.
private static double hackyadjuster ( double f ) { double tmp = math . sqrt ( _num - f ) ; return ( f <= _num ) ? tmp : tmp + ( _num * ( f - _num ) ) ; }	this hackyadjuster is tightly coupled with the width of the confidence interval normally specified with number of standard deviations.
private static object fromstring ( string s ) throws ioexception , classnotfoundexception { byte [ ] data = base64 . decode ( s , base64 . default ) ; objectinputstream ois = new objectinputstream ( new bytearrayinputstream ( data ) ) ; object o = ois . readobject ( ) ; ois . close ( ) ; return o ; }	read the object from base64 string .
private boolean copydocument ( searchdocument newdocument , searchdocument document , map < string , set < string > > removedproperties ) { boolean mutated = _bool ; for ( string oldfieldname : document . getpropertynames ( ) ) { newdocument . addproperty ( oldfieldname ) ; list < string > oldvalues = document . getproperty ( oldfieldname ) ; if ( oldvalues != null ) { set < string > objectsremoved = ( removedproperties != null ) ? removedproperties . get ( oldfieldname ) : null ; for ( string oldvalue : oldvalues ) { if ( ( objectsremoved != null ) && ( objectsremoved . contains ( oldvalue ) ) ) { mutated = _bool ; } else { addproperty ( oldfieldname , oldvalue , newdocument ) ; } } } } return mutated ; }	creates a copy of the old document ; updating the retrieved document instance works ok for stored properties but indexed data gets lost when doing an indexwriter.
public svdmatrix ( matrix arg ) { this ( arg , _bool , _bool , _bool ) ; }	construct the singular value decomposition.
public void unlockforclear ( internaldistributedmember locker ) { synchronized ( this . clearlocksync ) { internaldistributedsystem instance = internaldistributedsystem . getanyinstance ( ) ; if ( instance != null && logger . isdebugenabled ( ) ) { logger . debug ( _str , locker , system . identityhashcode ( this ) ) ; } if ( this . lockowner != null && ! locker . equals ( this . lockowner ) ) { if ( instance != null && logger . isdebugenabled ( ) ) { logger . debug ( _str , lockowner ) ; } return ; } unlockversiongeneration ( locker ) ; } }	unlocks version generation for clear ( ) operations.
public unicastref ( ) { }	create a new ( empty ) unicast remote reference .
private static int lastindexof ( object o , @ notnull object [ ] elements , int index ) { if ( o == null ) { for ( int i = index ; i >= _num ; i -- ) { if ( elements [ i ] == null ) { return i ; } } } else { for ( int i = index ; i >= _num ; i -- ) { if ( o . equals ( elements [ i ] ) ) { return i ; } } } return - _num ; }	static version of lastindexof .
public void write ( bytebuffer buffer ) throws ioexception { buffer . position ( _num ) ; if ( mfilechannel . size ( ) + buffer . capacity ( ) < mmaxsize ) { while ( buffer . hasremaining ( ) ) { mfilechannel . write ( buffer ) ; } updatewavefilesize ( ) ; } else { int remaining = ( int ) ( mmaxsize - mfilechannel . size ( ) ) ; remaining -= ( int ) ( remaining % maudioformat . getframesize ( ) ) ; byte [ ] bytes = buffer . array ( ) ; bytebuffer current = bytebuffer . wrap ( arrays . copyof ( bytes , remaining ) ) ; bytebuffer next = bytebuffer . wrap ( arrays . copyofrange ( bytes , remaining , bytes . length ) ) ; while ( current . hasremaining ( ) ) { mfilechannel . write ( current ) ; } updatewavefilesize ( ) ; rollover ( ) ; while ( next . hasremaining ( ) ) { mfilechannel . write ( next ) ; } updatewavefilesize ( ) ; } }	writes the buffer contents to the file.
public static double dmod_d ( double lhs , double rhs ) { return rhs != _num ? lhs - rhs * math . floor ( lhs / rhs ) : double . nan ; }	take modulo for double numbers according to lua math , and return a double result .
public void testmaxless ( ) { byte abytes [ ] = { _num , _num , _num , - _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , _num , _num } ; int asign = _num ; int bsign = _num ; byte rbytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . max ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } asserttrue ( _str , result . signum ( ) == _num ) ; }	max ( biginteger val ).
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m_iothread . isalive ( ) && m_state != idle ) { wait ( ) ; } } catch ( interruptedexception ex ) { } } else { notifyall ( ) ; } }	function used to stop code that calls accepttrainingset.
public void move ( mouseevent e ) { point2d pnt = getprojectionpoint ( e ) ; int x = ( int ) pnt . getx ( ) ; int y = ( int ) pnt . gety ( ) ; if ( poly . getrendertype ( ) == omgraphic . rendertype_offset ) { gpm = new offsetgrabpoint ( x , y ) ; gpm . clear ( ) ; } else { gpm = gpo ; gpm . clear ( ) ; gpm . set ( x , y ) ; } addpolygrabpointstoogp ( gpm ) ; movingpoint = gpm ; }	called to set the offsetgrabpoint to the current mouse location , and update the offsetgrabpoint with all the other grabpoint locations , so everything can shift smoothly.
public floatbuffer put ( float [ ] src , int srcoffset , int floatcount ) { arrays . checkoffsetandcount ( src . length , srcoffset , floatcount ) ; if ( floatcount > remaining ( ) ) { throw new bufferoverflowexception ( ) ; } for ( int i = srcoffset ; i < srcoffset + floatcount ; ++ i ) { put ( src [ i ] ) ; } return this ; }	writes floats from the given float array , starting from the specified offset , to the current position and increases the position by the number of floats written .
public static boolean containip ( int cidrprefix , int cidrmaskbits , int ip ) { boolean matched = _bool ; int bitstoshift = _num - cidrmaskbits ; if ( bitstoshift > _num ) { cidrprefix = cidrprefix > > bitstoshift ; ip = ip > > bitstoshift ; cidrprefix = cidrprefix << bitstoshift ; ip = ip << bitstoshift ; } if ( cidrprefix != ip ) { matched = _bool ; } return matched ; }	check whether the cidr address contains the ip address.
protected static boolean lock ( string servicename , object name ) { distributedlockservice service = distributedlockservice . getservicenamed ( servicename ) ; boolean locked = service . lock ( name , _num , - _num ) ; return boolean . valueof ( locked ) ; }	accessed via reflection . do not remove.
protected int checkknowncookie ( ) { int retval = _num ; debug . message ( _str , adaptive ) ; httpservletrequest req = gethttpservletrequest ( ) ; if ( req != null ) { cookie cookie = cookieutils . getcookiefromreq ( req , knowncookiename ) ; if ( cookie != null ) { if ( knowncookievalue . equalsignorecase ( cookieutils . getcookievalue ( cookie ) ) ) { retval = knowncookiescore ; } } } if ( knowncookievalue == null ) { knowncookievalue = _str ; } if ( knowncookiesave ) { postauthnmap . put ( _str , knowncookiename ) ; postauthnmap . put ( _str , knowncookievalue ) ; } if ( ! knowncookieinvert ) { retval = knowncookiescore - retval ; } return retval ; }	check to see if the client has a cookie with optional value.
public file [ ] selectimportfiles ( final string title , boolean multipleselection , filenameextensionfilter [ ] filenameextensionfilters ) { if ( boolean . parseboolean ( system . getproperty ( _str , boolean . tostring ( ostype . ismac ( ) ) ) ) ) { filedialog importdialog = filedialogs . get ( title ) ; if ( importdialog == null ) { importdialog = new filedialog ( this , title , filedialog . load ) ; filedialogs . put ( title , importdialog ) ; } importdialog . setvisible ( _bool ) ; if ( importdialog . getfile ( ) != null ) { return new file [ ] { new file ( importdialog . getdirectory ( ) , importdialog . getfile ( ) ) } ; } } else { jfilechooser importchooser = filechoosers . get ( title ) ; if ( importchooser == null ) { importchooser = new jfilechooser ( utils . getcwd ( ) ) ; importchooser . setmultiselectionenabled ( multipleselection ) ; for ( filenameextensionfilter filenameextensionfilter : filenameextensionfilters ) { importchooser . setfilefilter ( filenameextensionfilter ) ; } importchooser . setdialogtitle ( title ) ; filechoosers . put ( title , importchooser ) ; } int returnval = importchooser . showopendialog ( this ) ; if ( returnval == jfilechooser . approve_option ) { if ( importchooser . ismultiselectionenabled ( ) ) { return importchooser . getselectedfiles ( ) ; } else { return new file [ ] { importchooser . getselectedfile ( ) } ; } } } return null ; }	use the native file dialog on the mac because the swing one is bad.
public gt_metagenerated_item ( string aunlocalized , short aoffset , short aitemamount ) { super ( aunlocalized ) ; setcreativetab ( gregtech_api . tab_gregtech_materials ) ; sethassubtypes ( _bool ) ; setmaxdamage ( _num ) ; menableditems = new bitset ( aitemamount ) ; mvisibleitems = new bitset ( aitemamount ) ; moffset = ( short ) math . min ( _num , aoffset ) ; mitemamount = ( short ) math . min ( aitemamount , _num - moffset ) ; miconlist = new iicon [ aitemamount ] [ _num ] ; sinstances . put ( getunlocalizedname ( ) , this ) ; }	creates the item using these parameters .
public static byte [ ] readfully ( inputstream in ) throws ioexception { try { return readfullynoclose ( in ) ; } finally { in . close ( ) ; } }	returns a byte [ ] containing the remainder of ' in ' , closing it when done .
public static parsedsql parsesqlstatement ( string sql ) { set < string > namedparameters = new hashset < string > ( ) ; parsedsql parsedsql = new parsedsql ( sql ) ; char [ ] statement = sql . tochararray ( ) ; int namedparametercount = _num ; int unnamedparametercount = _num ; int totalparametercount = _num ; int i = _num ; while ( i < statement . length ) { int skiptoposition = skipcommentsandquotes ( statement , i ) ; if ( i != skiptoposition ) { if ( skiptoposition >= statement . length ) { break ; } i = skiptoposition ; } char c = statement [ i ] ; if ( c == _str || c == _str ) { int j = i + _num ; if ( j < statement . length && statement [ j ] == _str && c == _str ) { i = i + _num ; continue ; } while ( j < statement . length && ! isparameterseparator ( statement [ j ] ) ) { j ++ ; } if ( j - i > _num ) { string parameter = sql . substring ( i + _num , j ) ; if ( ! namedparameters . contains ( parameter ) ) { namedparameters . add ( parameter ) ; namedparametercount ++ ; } parsedsql . addnamedparameter ( parameter , i , j ) ; totalparametercount ++ ; } i = j - _num ; } else { if ( c == _str ) { unnamedparametercount ++ ; totalparametercount ++ ; } } i ++ ; } parsedsql . setnamedparametercount ( namedparametercount ) ; parsedsql . setunnamedparametercount ( unnamedparametercount ) ; parsedsql . settotalparametercount ( totalparametercount ) ; return parsedsql ; }	parse the sql statement and locate any placeholders or named parameters.
final void putlong ( int offset , long value ) { unsafe . putlong ( offset + address , value ) ; }	writes a long at the specified offset from this native object ' s base address .
public boolean onevent ( actionresult result ) { synchronized ( this ) { string requestid = result . getresponseinfo ( ) . mrequestid ; if ( requestid == null ) { return _bool ; } boolean eventremoved = mrequestids . remove ( requestid ) ; if ( eventremoved ) { class key = null ; for ( class type : mlastrequestidbytype . keyset ( ) ) { if ( requestid . equals ( mlastrequestidbytype . get ( type ) ) ) { key = type ; break ; } } if ( key != null ) { mlastrequestidbytype . remove ( key ) ; } } return eventremoved ; } }	required method to be called if you are using requestkeeper to funnel your requests .
public static string gensalt ( int log_rounds , securerandom random ) { stringbuffer rs = new stringbuffer ( ) ; byte rnd [ ] = new byte [ bcrypt_salt_len ] ; random . nextbytes ( rnd ) ; rs . append ( _str ) ; if ( log_rounds < _num ) { rs . append ( _str ) ; } if ( log_rounds > _num ) { throw new illegalargumentexception ( _str ) ; } rs . append ( integer . tostring ( log_rounds ) ) ; rs . append ( _str ) ; rs . append ( encode_base64 ( rnd , rnd . length ) ) ; return rs . tostring ( ) ; }	generate a salt for use with the bcrypt.
public void checkkey ( object key ) throws partitionedregionexception { if ( ! hashash ) { return ; } if ( key == null ) { return ; } int expected = key . hashcode ( ) ; if ( expected == keyhash ) { return ; } throw new partitionedregionexception ( _str + expected + _str + keyhash ) ; }	if possible , validate the given key ' s hashcode against any that was returned by the peer .
public stringbuffer numbertostring ( final string strnumbertoconvert ) { string strnumber = _str , signbit = _str ; if ( strnumbertoconvert . startswith ( _str ) ) { strnumber = _str + strnumbertoconvert . substring ( _num , strnumbertoconvert . length ( ) ) ; signbit = _str ; } else strnumber = _str + strnumbertoconvert ; final decimalformat dft = new decimalformat ( _str ) ; final string strtemp = _str + dft . format ( double . parsedouble ( strnumber ) ) ; stringbuffer strbnumber = new stringbuffer ( strtemp ) ; final int intlen = strbnumber . length ( ) ; for ( int i = intlen - _num ; i > _num ; i = i - _num ) strbnumber . insert ( i , _str ) ; if ( signbit . equals ( _str ) ) strbnumber = strbnumber . insert ( _num , _str ) ; return strbnumber ; }	function to format amount into to indaian rupees format.
private void runinitscriptifrequired ( string url , connection connection ) throws sqlexception { matcher matcher = initscript_matching_pattern . matcher ( url ) ; if ( matcher . matches ( ) ) { string initscriptpath = matcher . group ( _num ) ; try { url resource = resources . getresource ( initscriptpath ) ; string sql = resources . tostring ( resource , charsets . utf_8 ) ; scriptutils . executesqlscript ( connection , initscriptpath , sql ) ; } catch ( ioexception | illegalargumentexception e ) { logger . warn ( _str , initscriptpath ) ; throw new sqlexception ( _str + initscriptpath , e ) ; } catch ( scriptexception e ) { logger . error ( _str , initscriptpath , e ) ; throw new sqlexception ( _str + initscriptpath , e ) ; } } }	run an init script from the classpath .
private static int parseint ( string value , int beginindex , int endindex ) throws numberformatexception { if ( beginindex < _num || endindex > value . length ( ) || beginindex > endindex ) { throw new numberformatexception ( value ) ; } int i = beginindex ; int result = _num ; int digit ; if ( i < endindex ) { digit = character . digit ( value . charat ( i ++ ) , _num ) ; if ( digit < _num ) { throw new numberformatexception ( _str + value ) ; } result = - digit ; } while ( i < endindex ) { digit = character . digit ( value . charat ( i ++ ) , _num ) ; if ( digit < _num ) { throw new numberformatexception ( _str + value ) ; } result *= _num ; result -= digit ; } return - result ; }	parse an integer located between 2 given offsets in a string.
public static void println ( object x ) { out . println ( x ) ; }	prints an object to this output stream and then terminates the line .
public static void checkfinite ( final double [ ] val ) throws mathillegalargumentexception { for ( int i = _num ; i < val . length ; i ++ ) { final double x = val [ i ] ; if ( double . isinfinite ( x ) || double . isnan ( x ) ) { throw new mathillegalargumentexception ( localizedcoreformats . not_finite_number , x ) ; } } }	check that all the elements are real numbers .
private void initkeyboardbuttons ( keyboardview view ) { mbuttons = new arraylist < > ( ) ; mbuttons . add ( ( keyboardbuttonview ) view . findviewbyid ( r . id . pin_code_button_0 ) ) ; mbuttons . add ( ( keyboardbuttonview ) view . findviewbyid ( r . id . pin_code_button_1 ) ) ; mbuttons . add ( ( keyboardbuttonview ) view . findviewbyid ( r . id . pin_code_button_2 ) ) ; mbuttons . add ( ( keyboardbuttonview ) view . findviewbyid ( r . id . pin_code_button_3 ) ) ; mbuttons . add ( ( keyboardbuttonview ) view . findviewbyid ( r . id . pin_code_button_4 ) ) ; mbuttons . add ( ( keyboardbuttonview ) view . findviewbyid ( r . id . pin_code_button_5 ) ) ; mbuttons . add ( ( keyboardbuttonview ) view . findviewbyid ( r . id . pin_code_button_6 ) ) ; mbuttons . add ( ( keyboardbuttonview ) view . findviewbyid ( r . id . pin_code_button_7 ) ) ; mbuttons . add ( ( keyboardbuttonview ) view . findviewbyid ( r . id . pin_code_button_8 ) ) ; mbuttons . add ( ( keyboardbuttonview ) view . findviewbyid ( r . id . pin_code_button_9 ) ) ; mbuttons . add ( ( keyboardbuttonview ) view . findviewbyid ( r . id . pin_code_button_clear ) ) ; for ( view button : mbuttons ) { button . setonclicklistener ( this ) ; } }	init the keyboard buttons ( onclicklistener ).
public static boolean isautonew ( properties ctx , int windowno ) { if ( ctx == null ) throw new illegalargumentexception ( _str ) ; string s = getcontext ( ctx , windowno , _str , _bool ) ; if ( s != null ) { if ( s . equals ( _str ) ) return _bool ; else return _bool ; } return isautonew ( ctx ) ; }	is window auto new record ( if not set use default ).
private static string findrelativepath ( string filepath , string dirpath ) { string relpath ; if ( ! dirpath . endswith ( file . separator ) ) { dirpath = dirpath + file . separator ; } if ( filepath . startswith ( dirpath ) ) { relpath = filepath . substring ( dirpath . length ( ) ) ; } else { relpath = filepath ; } return relpath ; }	determine the path to the file relative to the given directory path .
public void resetsingleton ( ) { root = null ; tmpfilecounter . set ( _num ) ; accessedfiles . clear ( ) ; shouldallthrowioexception = _bool ; classesthatshouldthrowioexception . clear ( ) ; synchronized ( leakingresources ) { for ( leakingresource resource : leakingresources ) { try { resource . release ( ) ; } catch ( exception e ) { logger . warn ( _str + e . getmessage ( ) , e ) ; } } leakingresources . clear ( ) ; } }	reset the internal state of this singleton.
public void testandnotnegnegfirstlonger ( ) { byte abytes [ ] = { - _num , _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , - _num , _num , _num , - _num , - _num } ; byte bbytes [ ] = { - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = - _num ; int bsign = - _num ; byte rbytes [ ] = { _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . andnot ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	andnot for two negative numbers ; the first is longer.
public static string generatestringofcharacters ( int count ) { stringbuilder sb = new stringbuilder ( ) ; for ( int i = _num ; i < count ; i ++ ) { sb . append ( characters . charat ( ( int ) ( math . random ( ) * characters . length ( ) ) ) ) ; } return sb . tostring ( ) ; }	creates a random string which only consists of letters.
private exchangeratemanager ( ) { if ( system . getproperty ( _str ) == null ) throw new unsupportedoperationexception ( _str ) ; addknownrates ( ) ; }	constructs a new exchangeratemanager and initialises the most used rates.
public void removeattribute ( string name ) { if ( name != null ) if ( attributeslist != null ) { for ( int i = _num ; i < attributeslist . size ( ) ; i ++ ) { object o = attributeslist . elementat ( i ) ; if ( o instanceof attributefield ) { attributefield a = ( attributefield ) o ; try { string n = a . getname ( ) ; if ( n != null ) { if ( name . equals ( n ) ) { attributeslist . remove ( a ) ; } } } catch ( sdpparseexception e ) { } } } } }	removes the attribute specified by the value parameter .
@ override public void evict ( string key ) { key = safetykey ( key ) ; final file file = new file ( cachedirectory , key ) ; file . delete ( ) ; }	delete the object previously saved .
public static boolean isuniquecontrainterror ( exception e ) { if ( db . ispostgresql ( ) ) return issqlstate ( e , _str ) ; return iserrorcode ( e , _num ) ; }	check if unique constraint exception ( aka ora - 00001 ).
configurationerror ( string msg , exception x ) { super ( msg ) ; this . exception = x ; }	construct a new instance with the specified detail string and exception .
void addfillcomponents ( container panel , int [ ] cols , int [ ] rows ) { dimension filler = new dimension ( _num , _num ) ; boolean filled_cell_11 = _bool ; cellconstraints cc = new cellconstraints ( ) ; if ( cols . length > _num && rows . length > _num ) { if ( cols [ _num ] == _num && rows [ _num ] == _num ) { panel . add ( box . createrigidarea ( filler ) , cc . xy ( _num , _num ) ) ; filled_cell_11 = _bool ; } } for ( int index = _num ; index < cols . length ; index ++ ) { if ( cols [ index ] == _num && filled_cell_11 ) { continue ; } panel . add ( box . createrigidarea ( filler ) , cc . xy ( cols [ index ] , _num ) ) ; } for ( int index = _num ; index < rows . length ; index ++ ) { if ( rows [ index ] == _num && filled_cell_11 ) { continue ; } panel . add ( box . createrigidarea ( filler ) , cc . xy ( _num , rows [ index ] ) ) ; } }	adds fill components to empty cells in the first row and first column of the grid.
private void insertusedcontextprefixes ( ) { int unknownprefixescount = unknownprefixesinxmlliteral . size ( ) ; if ( unknownprefixescount > _num ) { stringbuilder contextprefixes = new stringbuilder ( _num ) ; elementinfo topelement = peekstack ( ) ; for ( int i = _num ; i < unknownprefixescount ; i ++ ) { string prefix = unknownprefixesinxmlliteral . get ( i ) ; string namespace = topelement . getnamespace ( prefix ) ; if ( namespace != null ) { appendnamespacedecl ( contextprefixes , prefix , namespace ) ; } } int endoffirststarttag = charbuf . indexof ( _str ) ; charbuf . insert ( endoffirststarttag , contextprefixes . tostring ( ) ) ; } unknownprefixesinxmlliteral . clear ( ) ; }	inserts prefix mappings from an xml literal ' s context for all prefixes that are used in the xml literal and that are not defined in the xml literal itself .
public void addputtimenanos ( long duration ) { puttimenanos . addandget ( duration ) ; if ( delegate != null ) delegate . addputtimenanos ( duration ) ; }	increments the put time accumulator .
public static list < integer > precomputehashes ( byte [ ] data , long tweak ) { arraylist < integer > list = new arraylist < > ( max_hash_funcs ) ; for ( int i = _num ; i < max_hash_funcs ; ++ i ) { list . add ( murmurhash3bit ( i , data , tweak ) ) ; } return list ; }	precompute hashes used to set mask bits for a data .
public int elevationat ( float lat , float lon ) { if ( frame_is_valid == _bool ) { if ( lat >= dsi . sw_lat && lat <= dsi . ne_lat && lon >= dsi . sw_lon && lon <= dsi . ne_lon ) { int lat_index = math . round ( ( lat - dsi . sw_lat ) * _num / uhl . lat_post_interval ) ; int lon_index = math . round ( ( lon - dsi . sw_lon ) * _num / uhl . lon_post_interval ) ; if ( elevations [ lon_index ] == null ) readdatarecord ( lon_index ) ; return ( int ) elevations [ lon_index ] [ lat_index ] ; } } return - _num ; }	the elevation at the closest sw post to the given lat / lon.
observedobject createobservedobject ( objectname object ) { return new observedobject ( object ) ; }	factory method for observedobject creation .
private void deletechildren ( element container ) { while ( container . haschildnodes ( ) ) { container . removechild ( container . getlastchild ( ) ) ; } }	delete the children of the element.
private void saveinitialchildstate ( facescontext facescontext , uicomponent component ) { if ( component instanceof editablevalueholder && ! component . istransient ( ) ) { string clientid = component . getclientid ( facescontext ) ; savedstate state = new savedstate ( ) ; initialchildstate . put ( clientid , state ) ; state . populate ( ( editablevalueholder ) component ) ; } iterator < uicomponent > iterator = component . getfacetsandchildren ( ) ; while ( iterator . hasnext ( ) ) { savechildstate ( facescontext , iterator . next ( ) ) ; } }	recursively create the initial state for the given component .
public boolean is_overlap ( ) { set < brditem > start_contacts = get_start_contacts ( ) ; set < brditem > end_contacts = get_end_contacts ( ) ; for ( brditem end_contact : end_contacts ) { if ( start_contacts . contains ( end_contact ) ) return _bool ; } return _bool ; }	looks , if this trace is connected to the same object at its start and its end point.
static object ensurenotnull ( location location , object value ) { if ( value == null ) { throw new evalexception ( location , _str ) ; } return value ; }	ensure the given value is not null and return it .
public static final arraylist readlistxml ( inputstream in ) throws xmlpullparserexception , ioexception { xmlpullparser parser = xml . newpullparser ( ) ; parser . setinput ( in , null ) ; return ( arraylist ) readvaluexml ( parser , new string [ _num ] ) ; }	read an arraylist from an inputstream containing xml.
private static string padright ( string s , int minlength ) { return string . format ( _str + minlength + _str , s ) ; }	adds padding to the end of a string with a repeating character if the string ' s length is less than the minimum length.
@ override public enumeration < string > enumeratemeasures ( ) { vector < string > newvector = new vector < string > ( _num ) ; newvector . addelement ( _str ) ; return newvector . elements ( ) ; }	returns an enumeration of the additional measure names.
protected synchronized void onsendtaskcompleted ( recordbuffer < r > buffer ) { logger . trace ( _str , name ( ) , buffer ) ; activesendtasks . decrementandget ( ) ; }	this method should not raise any exceptions .
public void addpreferencesbutton ( ) { jbutton prefsbutton = new jbutton ( _str ) ; prefsbutton . sethideactiontext ( _bool ) ; prefsbutton . setaction ( rasterplotactions . getpropertiesdialogaction ( this ) ) ; buttonpanel . add ( prefsbutton ) ; }	add button for showing preferences .
public void clearunused ( configimpl config ) { systemout . printdate ( config . getoutwriter ( ) , _str + size ( ) + _str + maxsize + _str ) ; if ( size ( ) > maxsize ) { object [ ] keys = keys ( ) ; longkeylist list = new longkeylist ( ) ; for ( int i = _num ; i < keys . length ; i ++ ) { pagesource ps = getpagesource ( keys [ i ] , _bool ) ; long updatetime = ps . getlastaccesstime ( ) ; if ( updatetime + timeout < system . currenttimemillis ( ) ) { long add = ( ( ps . getaccesscount ( ) - _num ) * _num ) ; if ( add > timeout ) add = timeout ; list . add ( updatetime + add , keys [ i ] ) ; } } while ( size ( ) > maxsize ) { object key = list . shift ( ) ; if ( key == null ) break ; remove ( key ) ; } } }	clear unused pages from page pool.
public static gridfield [ ] createfields ( properties ctx , int windowno , int tabno , int ad_tab_id ) { arraylist < gridfieldvo > listvo = new arraylist < gridfieldvo > ( ) ; int ad_window_id = _num ; boolean readonly = _bool ; string sql = gridfieldvo . getsql ( ctx ) ; preparedstatement pstmt = null ; try { pstmt = db . preparestatement ( sql , null ) ; pstmt . setint ( _num , ad_tab_id ) ; resultset rs = pstmt . executequery ( ) ; while ( rs . next ( ) ) { gridfieldvo vo = gridfieldvo . create ( ctx , windowno , tabno , ad_window_id , ad_tab_id , readonly , rs ) ; listvo . add ( vo ) ; } rs . close ( ) ; pstmt . close ( ) ; pstmt = null ; } catch ( exception e ) { log . log ( level . severe , sql , e ) ; } try { if ( pstmt != null ) pstmt . close ( ) ; pstmt = null ; } catch ( exception e ) { pstmt = null ; } gridfield [ ] retvalue = new gridfield [ listvo . size ( ) ] ; for ( int i = _num ; i < listvo . size ( ) ; i ++ ) retvalue [ i ] = new gridfield ( ( gridfieldvo ) listvo . get ( i ) ) ; return retvalue ; }	create fields . used by apanel . cmd_find and viewer . cmd_find.
public shortinterleavedraster ( samplemodel samplemodel , databuffer databuffer , point origin ) { this ( samplemodel , databuffer , new rectangle ( origin . x , origin . y , samplemodel . getwidth ( ) , samplemodel . getheight ( ) ) , origin , null ) ; }	constructs a shortinterleavedraster with the given samplemodel and databuffer.
private void copycarbondatafiletocarbonstorepath ( string localfilename ) throws carbondatawriterexception { long copystarttime = system . currenttimemillis ( ) ; logger . info ( _str + localfilename + _str + carbondatadirectorypath ) ; try { carbonfile localcarbonfile = filefactory . getcarbonfile ( localfilename , filefactory . getfiletype ( localfilename ) ) ; string carbonfilepath = carbondatadirectorypath + localfilename . substring ( localfilename . lastindexof ( file . separator ) ) ; copylocalfiletocarbonstore ( carbonfilepath , localfilename , carboncommonconstants . bytebuffer_size , getmaxofblockandfilesize ( filesizeinbytes , localcarbonfile . getsize ( ) ) ) ; } catch ( ioexception e ) { throw new carbondatawriterexception ( _str ) ; } logger . info ( _str + localfilename + _str + ( system . currenttimemillis ( ) - copystarttime ) ) ; }	this method will copy the given file to carbon store location.
@ override public boolean flingbackward ( selector obj , boolean isvertical ) throws uiobjectnotfoundexception { uiscrollable scrollable = new uiscrollable ( obj . touiselector ( ) ) ; if ( isvertical ) scrollable . setasverticallist ( ) ; else scrollable . setashorizontallist ( ) ; return scrollable . flingbackward ( ) ; }	performs a backwards fling action with the default number of fling steps ( 5 ).
protected static double todouble ( string s ) { try { return double . parsedouble ( s ) ; } catch ( exception e ) { testcase . fail ( _str + s + _str + throwabletostring ( e ) ) ; return double . nan ; } }	attempts to parse the string as double.
public void addlistener ( final ifilterpanellistener < t > listener ) { m_listeners . addlistener ( listener ) ; }	adds a listener that is notified about changes in the filter .
public boolean isstable ( ) { return myfeatures . contains ( feature_stable ) ; }	returns true if gapis is considered stable ( non - experimental ) :.
public static void calctextsize ( paint paint , string demotext , fsize outputfsize ) { rect r = mcalctextsizerect ; r . set ( _num , _num , _num , _num ) ; paint . gettextbounds ( demotext , _num , demotext . length ( ) , r ) ; outputfsize . width = r . width ( ) ; outputfsize . height = r . height ( ) ; }	calculates the approximate size of a text , depending on a demo text avoid repeated calls ( e.
protected void performdefaults ( ) { super . performdefaults ( ) ; initializevalues ( ) ; verifyvalidation ( ) ; }	defaults was clicked . restore the svn preferences to their default values.
public string tostring ( ) { final stringbuilder buf = new stringbuilder ( _str ) ; for ( int i = _num , end = _pos - _num ; i < end ; i ++ ) { buf . append ( _data [ i ] ) ; buf . append ( _str ) ; } if ( size ( ) > _num ) { buf . append ( _data [ _pos - _num ] ) ; } buf . append ( _str ) ; return buf . tostring ( ) ; }	returns a string representation of the list , front to back .
public static void write ( int x1 , int y1 , image image , int image_width , int image_height , linkproperties properties , dataoutputstream dos ) throws ioexception , interruptedexception { int [ ] pixels = new int [ image_width * image_height ] ; pixelgrabber pixelgrabber = new pixelgrabber ( image , _num , _num , image_width , image_height , pixels , _num , image_width ) ; pixelgrabber . grabpixels ( ) ; linkraster . write ( x1 , y1 , image_width , image_height , pixels , properties , dos ) ; }	write an image , x / y placement with an imageicon .
public void statechanged ( changeevent evt ) { int scale = slider . getvalue ( ) ; value . settext ( _str + string . valueof ( scale ) ) ; size . settext ( _str + ( width * scale ) + _str + ( height * scale ) + _str ) ; preview . repaint ( ) ; }	monitor changes to the scale slider .
public static void writetofile ( string content , file dstfile ) throws ioexception { bufferedwriter bufferedwriter = new bufferedwriter ( new filewriter ( dstfile , _bool ) ) ; bufferedwriter . write ( content ) ; bufferedwriter . close ( ) ; }	save string into the file.
public static boolean isfileurl ( url url ) { string protocol = url . getprotocol ( ) ; return ( url_protocol_file . equals ( protocol ) || url_protocol_vfsfile . equals ( protocol ) || url_protocol_vfs . equals ( protocol ) ) ; }	determine whether the given url points to a resource in the file system , that is , has protocol " file " , " vfsfile " or " vfs " .
private void updatestatus ( string relaystate , int currentstatus ) { integer tmp = ( integer ) currentstatusmap . get ( relaystate ) ; if ( tmp != null ) { int previousstatus = tmp . intvalue ( ) ; switch ( previousstatus ) { case logout_succeeded_status : if ( currentstatus > previousstatus ) { currentstatusmap . put ( relaystate , new integer ( currentstatus ) ) ; } break ; case logout_failed_status : if ( currentstatus < logout_failed_status ) { currentstatusmap . put ( relaystate , new integer ( logout_partial_status ) ) ; } break ; default : break ; } } else { currentstatusmap . put ( relaystate , new integer ( currentstatus ) ) ; } }	updates logout status based on current status and what stored in the internal map .
public static int [ ] oidstrtoints ( string oid ) throws ioexception { int length = oid . length ( ) ; if ( oid . charat ( length - _num ) == _str ) { throw new ioexception ( _str + oid ) ; } int [ ] result = new int [ length / _num + _num ] ; int number = _num ; for ( int i = _num ; i < length ; i ++ ) { int value = _num ; int pos = i ; for ( ; i < length ; i ++ ) { char ch = oid . charat ( i ) ; if ( ( ch < _str ) || ( ch > _str ) ) { break ; } value = _num * value + ( ch - _str ) ; } if ( i == pos ) { throw new ioexception ( _str + oid ) ; } result [ number ++ ] = value ; if ( i == length ) { break ; } char ch = oid . charat ( i ) ; if ( ch != _str ) { throw new ioexception ( _str + oid ) ; } } if ( number < _num ) { throw new ioexception ( _str + oid ) ; } return arrays . copyofrange ( result , _num , number ) ; }	converts oid into array of ints .
public static set < string > listservers ( ssotoken ssotoken , string sitename ) throws smsexception , ssoexception , configurationexception { set < string > members = new hashset < > ( ) ; string siteid = getsiteid ( ssotoken , sitename ) ; if ( siteid != null ) { set < string > allservers = serverconfiguration . getservers ( ssotoken ) ; for ( string svr : allservers ) { if ( serverconfiguration . belongtosite ( ssotoken , svr , sitename ) ) { members . add ( svr ) ; } } } return members ; }	returns the server instance names that belong to a site .
public static genericobjecteditordialog createdialog ( container parent ) { return createdialog ( parent , null ) ; }	creates a modal dialog for the parent .
public static boolean containsinlinefeatures ( styledlayerdescriptor sld ) { if ( sld != null ) { for ( styledlayer layer : sld . layers ( ) ) { if ( layer instanceof userlayer ) { userlayer userlayer = ( userlayer ) layer ; if ( userlayer . getinlinefeaturedatastore ( ) != null ) { return _bool ; } } } } return _bool ; }	checks to see if sld contains inline features .
public byte decodebuffer ( inputstream in ) [ ] throws ioexception { bytearrayoutputstream outstream = new bytearrayoutputstream ( ) ; decodebuffer ( in , outstream ) ; return ( outstream . tobytearray ( ) ) ; }	decode the contents of the inputstream into a buffer .
public static void runfinalization ( ) { runtime . runfinalization ( ) ; }	provides a hint to the virtual machine that it would be useful to attempt to perform any outstanding object finalizations .
private void displayallstringdefinedinstringxml ( ) { simpleiconfonttextview textview = ( simpleiconfonttextview ) findviewbyid ( r . id . text_view_1 ) ; list < string > list = new arraylist < > ( ) ; list . add ( getstring ( r . string . gems_logo ) ) ; string text = textutils . join ( _str , list ) ; textview . settext ( text ) ; }	display the string defined in the string xml file : iconfont_string . xml.
public static void checkhttprequestlength ( httpservletrequest request ) throws servletexception { int maxcontentlength = samlutils . getmaxcontentlength ( ) ; if ( maxcontentlength != _num ) { int length = request . getcontentlength ( ) ; if ( length == - _num ) { throw new servletexception ( bundle . getstring ( _str ) ) ; } if ( length > maxcontentlength ) { if ( debug . messageenabled ( ) ) { debug . message ( _str + _str + length ) ; } throw new servletexception ( bundle . getstring ( _str ) ) ; } } }	checks content length of a http request to avoid dos attack.
public void addforeignkeyconstraint ( string name , string sourcefield , string targetfield , string targettable ) { foreignkeyconstraint foreignkey = new foreignkeyconstraint ( name , sourcefield , targetfield , targettable ) ; addforeignkeyconstraint ( foreignkey ) ; }	public : add a foreign key constraint to the table.
@ override public void oncreate ( bundle savedinstancestate ) { super . oncreate ( savedinstancestate ) ; mhandler = new handler ( ) ; setcontentview ( r . layout . voice_recognition ) ; button speakbutton = ( button ) findviewbyid ( r . id . btn_speak ) ; mlist = ( listview ) findviewbyid ( r . id . list ) ; msupportedlanguageview = ( spinner ) findviewbyid ( r . id . supported_languages ) ; packagemanager pm = getpackagemanager ( ) ; list < resolveinfo > activities = pm . queryintentactivities ( new intent ( recognizerintent . action_recognize_speech ) , _num ) ; if ( activities . size ( ) != _num ) { speakbutton . setonclicklistener ( this ) ; } else { speakbutton . setenabled ( _bool ) ; speakbutton . settext ( _str ) ; } refreshvoicesettings ( ) ; }	called with the activity is first created .
public void push ( notification notification , notificationresponselistener listener ) { final string notificationtopic = notification . gettopic ( ) ; final string topic = notificationtopic == null ? defaulttopic : notificationtopic ; request req = utils . buildrequest ( client , topic , notification , gateway ) ; semaphore . acquireuninterruptibly ( ) ; req . send ( new responselistener ( semaphore , notification , listener ) ) ; }	sends a notification to the apple push notification service .
private static void appendjsonpair ( stringbuilder json , string key , string value ) throws unsupportedencodingexception { boolean isvaluenumeric = _bool ; try { if ( value . equals ( _str ) || ! value . endswith ( _str ) ) { double . parsedouble ( value ) ; isvaluenumeric = _bool ; } } catch ( numberformatexception e ) { isvaluenumeric = _bool ; } if ( json . charat ( json . length ( ) - _num ) != _str ) { json . append ( _str ) ; } json . append ( escapejson ( key ) ) ; json . append ( _str ) ; if ( isvaluenumeric ) { json . append ( value ) ; } else { json . append ( escapejson ( value ) ) ; } }	appends a json encoded key / value pair to the given string builder .
public void updatefromresource ( ) { for ( string resource : resources ) { inputstream is = classloader . getsystemresourceasstream ( resource ) ; linkedhashmap < entrytype , linkedhashmap < string , configentry > > parseresult = parse ( is ) ; for ( entrytype type : mymap . keyset ( ) ) { linkedhashmap < string , configentry > datamappings = mymap . get ( type ) ; linkedhashmap < string , configentry > resourcemappings = parseresult . get ( type ) ; linkedhashmap < string , configentry > tempmappings = new linkedhashmap < string , configentry > ( ) ; linkedhashset < string > keys = new linkedhashset < string > ( ) ; keys . addall ( datamappings . keyset ( ) ) ; keys . addall ( resourcemappings . keyset ( ) ) ; for ( string key : keys ) { if ( resourcemappings . containskey ( key ) ) { tempmappings . put ( key , resourcemappings . get ( key ) ) ; } else { tempmappings . put ( key , datamappings . get ( key ) ) ; } } mymap . put ( type , tempmappings ) ; } } }	maintains order of all keys , but overwrites all data keys with values from resources .
private void deselect ( final int index , final boolean shouldfireevents ) { checkwidget ( ) ; if ( index < _num || index >= items . size ( ) ) { return ; } final dlitem item = selection . remove ( index ) ; if ( shouldfireevents ) { fireselectionevent ( item ) ; } final list < dlitem > deselecteditems = new arraylist < dlitem > ( ) ; item . setlastaction ( last_action . deselection ) ; deselecteditems . add ( item ) ; if ( shouldfireevents ) { fireselectionchangeevent ( deselecteditems ) ; } redrawtables ( ) ; }	deselects the item at the given zero - relative index in the receiver.
public boolean isleaf ( object nd ) { node node = ( node ) nd ; return ! node . haschildnodes ( ) ; }	gets the leaf attribute of the domtreemodel object.
public void addlistener ( listener listener ) { mlisteners . add ( listener ) ; notifyservicediscovered ( mmatchingdrones ) ; }	add a listener all callbacks of the interface listener will be called within this function should be called in the main thread.
@ override boolean equals ( object obj ) ;	checks if this date - time is equal to another date - time , including the chronology.
private double [ ] parsevector ( string s ) { string [ ] entries = whitespace_pattern . split ( s ) ; double [ ] d = new double [ entries . length ] ; for ( int i = _num ; i < entries . length ; i ++ ) { try { d [ i ] = parseutil . parsedouble ( entries [ i ] ) ; } catch ( numberformatexception e ) { throw new abortexception ( _str ) ; } } return d ; }	parse a string into a vector . todo : move this into utility package ?.
@ override public void writeexternal ( objectoutput out ) throws ioexception { super . writeexternal ( out ) ; out . writedouble ( knndistance ) ; }	calls the super method and writes the knn distance of this entry to the specified stream .
public sessionwrapper ( session ses ) { this . ses = ses ; this . time = system . currenttimemillis ( ) ; }	creates instance of cassandra driver session wrapper .
public static list < batchresponse > postwithsinglerequest ( final requestspecification requestspec , final responsespecification responsespec , final batchrequest br ) { final list < batchrequest > batchrequests = new arraylist < > ( ) ; batchrequests . add ( br ) ; final string jsonifiedrequest = batchhelper . tojsonstring ( batchrequests ) ; final list < batchresponse > response = batchhelper . postbatchrequestswithoutenclosingtransaction ( requestspec , responsespec , jsonifiedrequest ) ; assert . assertnotnull ( response ) ; assert . asserttrue ( response . size ( ) > _num ) ; return response ; }	returns a batchresponse based on the given batchrequest , by posting the request to the server .
public file programdirectory ( ) { return programdirectory ; }	returns the directory in which the main program is located .
@ override public void clearroutesensors ( ) { _controlsensorlist = new arraylist < > ( ) ; }	method to delete all control sensors from this route.
public static keystore_type fromstring ( string x ) throws configurationexception { for ( keystore_type currenttype : keystore_type . values ( ) ) { if ( x . equalsignorecase ( currenttype . tostring ( ) ) ) return currenttype ; } throw new configurationexception ( messageformat . format ( _str , x ) ) ; }	converts a string into the corresponding keystore_type.
public objectmapper nextlevel ( objectmapper level ) { objectmapper previous = levelstack . peek ( ) ; levelstack . push ( level ) ; return previous ; }	sets the new current nested level and pushes old current nested level down the stack returns that level .
protected static int todigit ( final char ch , final int index ) throws hexdecodeexception { final int digit = character . digit ( ch , _num ) ; if ( digit == - _num ) { throw new hexdecodeexception ( _str + ch + _str + index ) ; } return digit ; }	converts a hexadecimal character to an integer .
public jsonobject tojson ( ) throws jsonexception { jsonobject json = new jsonobject ( ) ; jsonarray jpods = new jsonarray ( ) ; for ( diasporapod pod : pods ) { jpods . put ( pod . tojson ( ) ) ; } json . put ( _str , jpods ) ; json . put ( _str , system . currenttimemillis ( ) ) ; return json ; }	convert diasporapodlist to json.
public static keystore load ( file keystorefile , password password ) throws cryptoexception , filenotfoundexception { keystoretype keystoretype = null ; try { keystoretype = cryptofileutil . detectkeystoretype ( new fileinputstream ( keystorefile ) ) ; } catch ( filenotfoundexception ex ) { throw ex ; } catch ( ioexception ex ) { throw new cryptoexception ( res . getstring ( _str ) , ex ) ; } if ( keystoretype == null ) { return null ; } return load ( keystorefile , password , keystoretype ) ; }	load a keystore , auto - detecting the type , from a file accessed by a password .
@ override public void removepropertychangelistener ( propertychangelistener pcl ) { m_pcsupport . removepropertychangelistener ( pcl ) ; }	remove a property change listener.
@ visiblefortesting static boolean isprecachingenabled ( context context ) { sharedpreferences prefs = preferencemanager . getdefaultsharedpreferences ( context ) ; return prefs . getboolean ( pref_is_precaching_enabled , _bool ) ; }	returns true if precaching is able to run.
public void and ( longbitset other ) { int pos = math . min ( numwords , other . numwords ) ; while ( -- pos >= _num ) { bits [ pos ] &= other . bits [ pos ] ; } if ( numwords > other . numwords ) { arrays . fill ( bits , other . numwords , numwords , _num ) ; } }	this = this and other.
@ override public boolean equals ( object obj ) { if ( this == obj ) return _bool ; if ( ! ( obj instanceof principalentry ) ) return _bool ; principalentry that = ( principalentry ) obj ; return ( principalclass . equals ( that . principalclass ) && principalname . equals ( that . principalname ) ) ; }	test for equality between the specified object and this object.
public boolean isvalidlockdownprofile ( ) { try { return _bool ; } catch ( illegalargumentexception e ) { log . w ( tag , _str , e ) ; return _bool ; } }	test if profile is valid for lockdown , which requires ipv4 address for both server and dns.
public static boolean isextension ( string filename , string [ ] extensions ) { if ( filename == null ) { return _bool ; } if ( extensions == null || extensions . length == _num ) { return indexofextension ( filename ) == - _num ; } string fileext = getextension ( filename ) ; for ( string extension : extensions ) { if ( fileext . equals ( extension ) ) { return _bool ; } } return _bool ; }	checks whether the extension of the filename is one of those specified.
public fromclause ( stream streamone , outerjoinqualifier outerjoinqualifier , stream streamtwo ) { this ( streamone ) ; add ( streamtwo ) ; outerjoinqualifiers . add ( outerjoinqualifier ) ; }	ctor for an outer join between two streams .
private static void decodeansix12segment ( bitsource bits , stringbuilder result ) throws formatexception { int [ ] cvalues = new int [ _num ] ; do { if ( bits . available ( ) == _num ) { return ; } int firstbyte = bits . readbits ( _num ) ; if ( firstbyte == _num ) { return ; } parsetwobytes ( firstbyte , bits . readbits ( _num ) , cvalues ) ; for ( int i = _num ; i < _num ; i ++ ) { int cvalue = cvalues [ i ] ; if ( cvalue == _num ) { result . append ( _str ) ; } else if ( cvalue == _num ) { result . append ( _str ) ; } else if ( cvalue == _num ) { result . append ( _str ) ; } else if ( cvalue == _num ) { result . append ( _str ) ; } else if ( cvalue < _num ) { result . append ( ( char ) ( cvalue + _num ) ) ; } else if ( cvalue < _num ) { result . append ( ( char ) ( cvalue + _num ) ) ; } else { throw formatexception . getformatinstance ( ) ; } } } while ( bits . available ( ) > _num ) ; }	see iso 16022 : 2006 , 5.
public static kdbdatabase createkdbdatabase ( credentials credentials , kdbheader kdbheader , inputstream inputstream ) throws ioexception { datainput datainput = new littleendiandatainputstream ( inputstream ) ; checksignature ( datainput ) ; deserializeheader ( kdbheader , datainput ) ; inputstream decryptedinputstream = kdbheader . createdecryptedinputstream ( credentials . getkey ( ) , inputstream ) ; messagedigest digest = encryption . getmessagedigestinstance ( ) ; digestinputstream digestinputstream = new digestinputstream ( decryptedinputstream , digest ) ; datainput = new littleendiandatainputstream ( digestinputstream ) ; kdbdatabase kdbdatabase = new kdbdatabase ( ) ; kdbgroup lastgroup = ( kdbgroup ) kdbdatabase . getrootgroup ( ) ; for ( long group = _num ; group < kdbheader . getgroupcount ( ) ; group ++ ) { lastgroup = deserializegroup ( lastgroup , datainput ) ; } for ( long entry = _num ; entry < kdbheader . getentrycount ( ) ; entry ++ ) { deserializeentry ( kdbdatabase , datainput ) ; } if ( ! arrays . equals ( digest . digest ( ) , kdbheader . getcontenthash ( ) ) ) { throw new illegalstateexception ( _str ) ; } digestinputstream . close ( ) ; return kdbdatabase ; }	construct a kdb database from the supplied inputstream .
private diffpart decodeadd ( final int blocksize_s , final int blocksize_l ) throws unsupportedencodingexception , decodingexception { if ( blocksize_s < _num || blocksize_l < _num ) { throw new decodingexception ( _str + blocksize_s + _str + blocksize_l ) ; } int s = r . read ( blocksize_s ) ; int l = r . read ( blocksize_l ) ; bytearrayoutputstream output = new bytearrayoutputstream ( ) ; for ( int i = _num ; i < l ; i ++ ) { output . write ( r . readbyte ( ) ) ; } diffpart part = new diffpart ( diffaction . insert ) ; part . setstart ( s ) ; part . settext ( output . tostring ( wikipedia_encoding ) ) ; return part ; }	decodes an add operation .
public void sort ( ) { arrays . sort ( v , _num , size ( ) ) ; }	sorts the array in place.
public void rebuildpanel ( ) { if ( activeworker != null && ! activeworker . isdone ( ) ) { activeworker . cancel ( _bool ) ; } panelimages . removeall ( ) ; panelimages . revalidate ( ) ; scrollpane . repaint ( ) ; activeworker = new imageloader ( mediafiles ) ; activeworker . execute ( ) ; }	trigger to rebuild the panel.
protected void processbytes ( byte [ ] buf , int off , int len ) { nbytesin += len ; if ( len < _num || state . isdone ( ) ) return ; if ( state == state . row_ready ) throw new pngjinputexception ( _str ) ; if ( inf . needsdictionary ( ) || ! inf . needsinput ( ) ) throw new runtimeexception ( _str ) ; inf . setinput ( buf , off , len ) ; if ( iscallbackmode ( ) ) { while ( inflatedata ( ) ) { int nextrowlen = processrowcallback ( ) ; preparefornextrow ( nextrowlen ) ; if ( isdone ( ) ) processdonecallback ( ) ; } } else inflatedata ( ) ; }	feeds the inflater with the compressed bytes in poll mode , the caller should not call repeatedly this , without consuming first , checking isdatareadyforconsumer ( ).
@ override protected string tostring ( file obj ) { return obj . getabsolutepath ( ) ; }	turns an object into a string for storing in the props .
public final void gotonextpage ( ) { final boolean islastpage = viewpager . getcurrentitem ( ) == ( pages . size ( ) - _num ) ; if ( ! islastpage ) { viewpager . setcurrentitem ( viewpager . getcurrentitem ( ) + _num , _bool ) ; } }	navigates to the next page ( if not already there ) .
private static inputstream nullinputstream ( ) throws nullpointerexception { if ( currenttimemillis ( ) > _num ) { return null ; } throw new nullpointerexception ( ) ; }	the following two methods exist because in , out , and err must be initialized to null.
public list < typeid < ? > > aslist ( ) { return collections . unmodifiablelist ( arrays . aslist ( types ) ) ; }	returns an immutable list .
private static void deleterules ( list < string > batchlist , list < rule > rulestodelete ) { string deletestatement = _str + rules_table + _str ; for ( rule rule : rulestodelete ) { batchlist . add ( string . format ( deletestatement , rule . getuid ( ) ) ) ; } }	the sql commands to be added to the batchlist for deleting the rules in rulestodelete .
public boolean isvisited ( object element ) { return myvisitedelements . containskey ( element ) ; }	returns true if this element was already visited .
public awsiotconnection ( abstractawsiotclient client ) { this . client = client ; }	instantiates a new connection object .
public static < t > completablefuture < t > exceptionallycompletedfuture ( throwable throwable ) { final completablefuture < t > future = new completablefuture < t > ( ) ; future . completeexceptionally ( throwable ) ; return future ; }	returns a new completablefuture that is already exceptionally completed with the given exception .
protected void initforecasterrors ( arraylist < float > model , timeseries . datasequence data ) { double sumerr = _num ; double sumabserr = _num ; double sumabspercenterr = _num ; double sumerrsquared = _num ; int processedpoints = _num ; int n = data . size ( ) ; for ( int i = _num ; i < n ; i ++ ) { double error = model . get ( i ) - data . get ( i ) . value ; sumerr += error ; sumabserr += math . abs ( error ) ; sumabspercenterr += math . abs ( error / data . get ( i ) . value ) ; sumerrsquared += error * error ; processedpoints ++ ; } this . bias = sumerr / processedpoints ; this . mad = sumabserr / processedpoints ; this . mape = sumabspercenterr / processedpoints ; this . mse = sumerrsquared / processedpoints ; this . sae = sumabserr ; errorsinit = _bool ; }	initializes all errors given the model .
public boolean checkmodifiers ( mouseevent e ) { return e . getmodifiers ( ) == modifiers ; }	check the mouse event modifiers against the instance member modifiers.
public void emitretainedvars ( generatejsvisitor gen ) { if ( ! retainedvars . isempty ( ) ) { gen . out ( _str ) ; boolean first = _bool ; for ( string varname : retainedvars ) { if ( ! first ) { gen . out ( _str ) ; } first = _bool ; gen . out ( varname ) ; } gen . endline ( _bool ) ; retainedvars . clear ( ) ; } }	writes all retained variables to the output of the specified generator , then clears them .
public uri ( string scheme , string authority , string path , string query , string fragment ) throws urisyntaxexception { if ( scheme != null && path != null && ! path . isempty ( ) && path . charat ( _num ) != _str ) { throw new urisyntaxexception ( path , _str ) ; } stringbuilder uri = new stringbuilder ( ) ; if ( scheme != null ) { uri . append ( scheme ) ; uri . append ( _str ) ; } if ( authority != null ) { uri . append ( _str ) ; authority_encoder . appendencoded ( uri , authority ) ; } if ( path != null ) { path_encoder . appendencoded ( uri , path ) ; } if ( query != null ) { uri . append ( _str ) ; all_legal_encoder . appendencoded ( uri , query ) ; } if ( fragment != null ) { uri . append ( _str ) ; all_legal_encoder . appendencoded ( uri , fragment ) ; } parseuri ( uri . tostring ( ) , _bool ) ; }	creates a new uri instance of the given unencoded component parts .
public list < structuredtranslation > kbestextractonhg ( hypergraph hg , int topn ) { resetstate ( ) ; if ( hg == null || hg . goalnode == null ) { return emptylist ( ) ; } final list < structuredtranslation > kbest = new arraylist < > ( topn ) ; for ( int k = _num ; k <= topn ; k ++ ) { structuredtranslation translation = getkthstructuredtranslation ( hg . goalnode , k ) ; if ( translation == null ) { break ; } kbest . add ( translation ) ; } return kbest ; }	this is an entry point for extracting k - best hypotheses as structuredtranslation objects.
@ override public int read ( ) throws ioexception { synchronized ( lock ) { checknotclosed ( ) ; if ( pos != count ) { return str . charat ( pos ++ ) ; } return - _num ; } }	reads a single character from the source string and returns it as an integer with the two higher - order bytes set to 0.
public static boolean issnapshotfullcopysupported ( uri blocksnapuri , dbclient dbclient ) { blocksnapshot blockobj = dbclient . queryobject ( blocksnapshot . class , blocksnapuri ) ; storagesystem storage = dbclient . queryobject ( storagesystem . class , blockobj . getstoragecontroller ( ) ) ; return ( storage != null && ( storage . deviceistype ( type . openstack ) || storage . deviceistype ( type . vnxblock ) || storage . deviceistype ( type . ibmxiv ) || storage . deviceistype ( type . vmax ) ) ) ; }	check if the storage system type is openstack , vnxblock , vmax or ibmxiv.
public iterable < servicedescriptor > listservices ( ) { arraylist < servicedescriptor > servicedescriptors = new arraylist < servicedescriptor > ( ) ; for ( filedescriptor filedescriptor : filedescriptors ) { servicedescriptors . addall ( filedescriptor . getservices ( ) ) ; } return servicedescriptors ; }	lists all of the services found in the file descriptors.
private string stripcodevaluesentences ( string string ) { return string . replaceall ( _str , _str ) ; }	returns a string with lines sentences of the following form removed : this result code corresponds to the ldap result code value of & # x7b ; & # x40 ; code 0 & # x7d ; .
public void testdivideroundhalfevenneg2 ( ) { string a = _str ; int ascale = _num ; string b = _str ; int bscale = _num ; string c = _str ; int resscale = - _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; bigdecimal result = anumber . divide ( bnumber , resscale , bigdecimal . round_half_even ) ; assertequals ( _str , c , result . tostring ( ) ) ; assertequals ( _str , resscale , result . scale ( ) ) ; }	divide : rounding mode is round_half_even , result is negative ; equidistant.
public static double quantile ( double p , double alpha , double beta ) { if ( double . isnan ( alpha ) || double . isnan ( beta ) || double . isnan ( p ) || alpha < _num || beta < _num ) { return double . nan ; } if ( p < _num || p > _num ) { return double . nan ; } if ( p == _num ) { return _num ; } if ( p == _num ) { return _num ; } if ( p > _num ) { return _num - rawquantile ( _num - p , beta , alpha , logbeta ( beta , alpha ) ) ; } else { return rawquantile ( p , alpha , beta , logbeta ( alpha , beta ) ) ; } }	compute quantile ( inverse cdf ) for beta distributions .
public boolean validate ( string cert , string signeddata , string signature ) throws nosuchalgorithmexception , ioexception , exception { byte [ ] certbytes = base64 . decode ( cert ) ; byte [ ] signeddatabytes = base64 . decode ( signeddata ) ; byte [ ] signaturebytes = base64 . decode ( signature ) ; return validate ( certbytes , signeddatabytes , signaturebytes ) ; }	example implementation . it only knows to verify sha256withec algorithm .
public int size ( ) { return seq . size ( ) ; }	return the number of objects in this sequence .
public void testaddservletrunasrole ( ) throws exception { string xml = webapp_test_header + _str + _str + _str + _str + _str ; webxml webxml = webxmlio . parsewebxml ( new bytearrayinputstream ( xml . getbytes ( _str ) ) , getentityresolver ( ) ) ; webxmlutils . addservletrunasrolename ( webxml , _str , _str ) ; string rolename = webxmlutils . getservletrunasrolename ( webxml , _str ) ; assertequals ( _str , rolename ) ; }	tests that a run - as role - name can be added to a servlet .
public void testcase15 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = - _num ; int bsign = - _num ; byte rbytes [ ] = { - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . subtract ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( - _num , result . signum ( ) ) ; }	subtract two negative numbers of different length.
public multitermquery ( final string field ) { this . field = objects . requirenonnull ( field , _str ) ; }	constructs a query matching terms that cannot be represented with a single term .
public static void printline ( object message ) { if ( ! isdisabled ( ) ) { printline ( string . valueof ( message ) ) ; } }	prints the message passed as a non - string object and a new line .
public void accumulate ( taggedlogapientity entity ) throws exception { aggregateapientity current = root ; for ( string groupby : groupbys ) { string tagv = locategroupbyfield ( groupby , entity ) ; if ( tagv == null || tagv . isempty ( ) ) { tagv = unassigned_groupby_root_field_name ; } map < string , aggregateapientity > children = current . getentitylist ( ) ; if ( children . get ( tagv ) == null ) { children . put ( tagv , factory . create ( ) ) ; current . setnumdirectdescendants ( current . getnumdirectdescendants ( ) + _num ) ; } aggregateapientity child = children . get ( tagv ) ; if ( counting ) count ( child ) ; for ( string sumfunctionfield : sumfunctionfields ) { sum ( child , entity , sumfunctionfield ) ; } current = child ; } }	currently only group by tags groupbys ' first item always is site , which is a reserved field.
public void testinvalidxml ( ) throws exception { testinvalidgpx ( invalid_xml_gpx ) ; }	test an invalid xml input .
public string tostring ( boolean expand ) { stringbuilder acc = new stringbuilder ( ) ; tostring ( acc , _num , expand ) ; return acc . tostring ( ) ; }	convert a re to a string .
public static boolean isaccessorpair ( tmember member , tmember member2 ) { return ( member instanceof tgetter && member2 instanceof tsetter ) || ( member instanceof tsetter && member2 instanceof tgetter ) ; }	returns true if one of the members is a getter and the other one is a setter.
public static dateformat createutcdateformatter ( string dateformat ) { dateformat formatter = new simpledateformat ( dateformat ) ; formatter . settimezone ( timezone . gettimezone ( _str ) ) ; return formatter ; }	creates a dateformat that assumes the incoming date is in utc time .
public void writelinkedkml ( final string filename , final kmltype kml ) { if ( filename . equals ( _str ) ) { throw new illegalargumentexception ( _str ) ; } if ( filename . equals ( _str ) ) { throw new illegalargumentexception ( _str ) ; } writekml ( filename , kml ) ; }	adds the specified kml - object to the file .
string destinationfilepath ( ) { return destinationfilepath ; }	get destination file path of this download request .
@ override public void refreshusersorgroupslistfromserver ( ) { showloadingdialog ( getstring ( r . string . common_loading ) ) ; getsharewithusersasynctask gettask = new getsharewithusersasynctask ( this ) ; object [ ] params = { getfile ( ) , getaccount ( ) , getstoragemanager ( ) } ; gettask . execute ( params ) ; }	get users and groups from the server to fill in the " share with " list.
public bootpanel ( ) { initcomponents ( ) ; }	creates new form bootpanel.
private list < header > defaultheaders ( ) { dateformat dateformat = new simpledateformat ( _str ) ; list < header > headers = new arraylist < > ( ) ; headers . add ( new basicheader ( _str , dateformat . format ( new date ( ) ) ) ) ; return headers ; }	create default headers for server response .
public aemparsys clear ( ) { list < webelement > list = currentscope . findelements ( by . cssselector ( selector_for_component_in_parsys ) ) ; list . foreach ( null ) ; return this ; }	remove all components in parsys .
protected requesthandle sendrequest ( defaulthttpclient client , httpcontext httpcontext , httpurirequest urirequest , string contenttype , responsehandlerinterface responsehandler , context context ) { if ( contenttype != null ) { urirequest . setheader ( _str , contenttype ) ; } responsehandler . setrequestheaders ( urirequest . getallheaders ( ) ) ; responsehandler . setrequesturi ( urirequest . geturi ( ) ) ; future < ? > request = threadpool . submit ( new asynchttprequest ( client , httpcontext , urirequest , responsehandler ) ) ; if ( context != null ) { list < weakreference < future < ? > > > requestlist = requestmap . get ( context ) ; if ( requestlist == null ) { requestlist = new linkedlist < weakreference < future < ? > > > ( ) ; requestmap . put ( context , requestlist ) ; } requestlist . add ( new weakreference < future < ? > > ( request ) ) ; } return new requesthandle ( request ) ; }	puts a new request in queue as a new thread in pool to be executed.
private void registernewclient ( jsonobject jdata ) { client newclient = gson . fromjson ( jdata , client . class ) ; if ( newclient . isvalid ( ) ) { addclient ( newclient ) ; broadcastnewclient ( newclient ) ; sendclientlist ( newclient ) ; } else { logger . log ( level . warning , _str ) ; } }	create client from given json data , add client to client list , broadcast newly registered client to all previously registered clients and send client list to new client .
@ override public void parse ( inputstream in , string baseuri ) throws ioexception , rdfparseexception , rdfhandlerexception { if ( in == null ) { throw new illegalargumentexception ( _str ) ; } if ( baseuri == null ) { throw new illegalargumentexception ( _str ) ; } inputsource inputsource = new inputsource ( new bominputstream ( in , _bool ) ) ; inputsource . setsystemid ( baseuri ) ; parse ( inputsource ) ; }	parses the data from the supplied inputstream , using the supplied baseuri to resolve any relative uri references .
public static date parsedate ( string datevalue , collection dateformats ) throws dateparseexception { if ( datevalue == null ) { throw new illegalargumentexception ( _str ) ; } if ( dateformats == null ) { dateformats = default_patterns ; } if ( datevalue . length ( ) > _num && datevalue . startswith ( _str ) && datevalue . endswith ( _str ) ) { datevalue = datevalue . substring ( _num , datevalue . length ( ) - _num ) ; } simpledateformat dateparser = null ; final iterator formatiter = dateformats . iterator ( ) ; while ( formatiter . hasnext ( ) ) { final string format = ( string ) formatiter . next ( ) ; if ( dateparser == null ) { dateparser = new simpledateformat ( format , locale . us ) ; dateparser . settimezone ( timezone . gettimezone ( _str ) ) ; } else { dateparser . applypattern ( format ) ; } try { return dateparser . parse ( datevalue ) ; } catch ( final parseexception pe ) { } } throw new dateparseexception ( _str + datevalue ) ; }	parses the date value using the given date formats .
public jsonobject remove ( string name ) { if ( name == null ) { throw new nullpointerexception ( _str ) ; } int index = indexof ( name ) ; if ( index != - _num ) { table . remove ( index ) ; names . remove ( index ) ; values . remove ( index ) ; } return this ; }	removes a member with the specified name from this object.
edgemap < block > findloops ( deque < block > code , map < block , block > idom , setmap < block , edge > pred ) { edgemap < block > loops = new edgemap < block > ( ) ; for ( block b : code ) for ( edge s : b . succ ( ) ) if ( isloop ( s , idom ) ) { verbosestatus ( _str + s ) ; block h = s . to ; set < block > loop = loops . get ( h ) ; set < block > work = new treeset < block > ( ) ; for ( edge p : pred . get ( h ) ) { if ( isloop ( p , idom ) && ! loop . contains ( p . from ) && p . from != h ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } while ( ! work . isempty ( ) ) { block x = getblock ( work ) ; for ( edge p : pred . get ( x ) ) { if ( p . from != h && ! loop . contains ( p . from ) ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } } } return loops ; }	loop code layout the loop is defined by the back edge from t - > h.
private void generatehivetestfiles ( ) throws filenotfoundexception { try ( printwriter writera = new printwriter ( new file ( testworkdir , _str ) ) ; printwriter writerb = new printwriter ( new file ( testworkdir , _str ) ) ) { char sep = _str ; int idb = _num ; int ida = _num ; int v = _num ; for ( int i = _num ; i < _num ; i ++ ) { writera . print ( ida ++ ) ; writera . print ( sep ) ; writera . println ( idb ) ; writerb . print ( idb ++ ) ; writerb . print ( sep ) ; writerb . println ( v += _num ) ; writerb . print ( idb ++ ) ; writerb . print ( sep ) ; writerb . println ( v += _num ) ; } writera . flush ( ) ; writerb . flush ( ) ; } }	generates two data files to join its with hive .
public void renameeditorpanel ( editor panel ) { if ( panelslist . size ( ) == _num ) { return ; } for ( int i = _num ; i < panelslist . size ( ) ; i ++ ) { object o = panelslist . get ( i ) ; if ( o == panel ) { jcheckboxmenuitem r = ( jcheckboxmenuitem ) panelssubmenu . getitem ( i ) ; r . settext ( panel . gettitle ( ) ) ; return ; } } }	rename an editor type panel in show panels sub menu.
private boolean fitsassingleline ( int col ) { return ( col + singlelinewidth ( ) <= pcaltlagen . wrapcolumn ) || ( bodyformulas . sf == null && ( prcdformulas == null || prcdformulas . size ( ) == _num ) ) ; }	returns true iff format ( col ) should return a single - line version of the formula .
@ override protected void before ( ) throws throwable { previousthreads = thread . getallstacktraces ( ) ; }	override to set up your specific external resource .
public void sphericaltoworld ( vector3 vec ) { if ( pjunprojected == null ) { string projstr = _str + projinfo . getsemimajoraxis ( ) + _str + projinfo . getsemiminoraxis ( ) + _str ; pjunprojected = proj4 . newinstance ( projstr ) ; } if ( pjprojected == null ) { pjprojected = proj4 . newinstance ( proj4string ) ; } try { vec . toarray ( coord ) ; coord [ _num ] = math . toradians ( coord [ _num ] ) ; coord [ _num ] = math . toradians ( coord [ _num ] ) ; pjunprojected . transform ( pjprojected , coord ) ; vec . setx ( coord [ _num ] ) ; vec . sety ( coord [ _num ] ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }	convert lon / lat ( degree ) coordinate to virtual world coordinates .
public string replace ( charsequence target , charsequence replacement ) { if ( target == null ) { throw new nullpointerexception ( _str ) ; } if ( replacement == null ) { throw new nullpointerexception ( _str ) ; } string targetstring = target . tostring ( ) ; int matchstart = indexof ( targetstring , _num ) ; if ( matchstart == - _num ) { return this ; } string replacementstring = replacement . tostring ( ) ; int targetlength = targetstring . length ( ) ; if ( targetlength == _num ) { int resultlength = count + ( count + _num ) * replacementstring . length ( ) ; stringbuilder result = new stringbuilder ( resultlength ) ; result . append ( replacementstring ) ; int end = offset + count ; for ( int i = offset ; i != end ; ++ i ) { result . append ( value [ i ] ) ; result . append ( replacementstring ) ; } return result . tostring ( ) ; } stringbuilder result = new stringbuilder ( count ) ; int searchstart = _num ; do { result . append ( value , offset + searchstart , matchstart - searchstart ) ; result . append ( replacementstring ) ; searchstart = matchstart + targetlength ; } while ( ( matchstart = indexof ( targetstring , searchstart ) ) != - _num ) ; result . append ( value , offset + searchstart , count - searchstart ) ; return result . tostring ( ) ; }	copies this string replacing occurrences of the specified target sequence with another sequence.
public static string encodeurl ( final string str ) { return encode ( str , _str ) ; }	encode a string for html requests.
public void drawrenderedimage ( renderedimage img , affinetransform xform ) { if ( img == null ) { return ; } mprintmetrics . drawimage ( this , img ) ; mdrawingarea . addinfinite ( ) ; }	draws an image , applying a transform from image space into user space before drawing.
private void skiptoendofline ( ) { for ( ; pos < in . length ( ) ; pos ++ ) { char c = in . charat ( pos ) ; if ( c == _str || c == _str ) { pos ++ ; break ; } } }	advances the position until after the next newline character.
public independencetest indtestsubset ( list vars ) { return null ; }	creates a new indtestcramert instance for a subset of the variables .
@ override public void acton ( file f ) { bufferedreader reader = null ; try { reader = new bufferedreader ( new filereader ( f ) ) ; announceseedsfromreader ( reader ) ; } catch ( filenotfoundexception fnf ) { logger . log ( level . severe , _str , fnf ) ; } finally { ioutils . closequietly ( reader ) ; } }	treat the given file as a source of additional seeds , announcing to seedlisteners .
public static string formatmillis ( int millis ) { string result = _str ; int hr = millis / _num ; millis %= _num ; int min = millis / _num ; millis %= _num ; int sec = millis / _num ; if ( hr > _num ) { result += hr + _str ; } if ( min >= _num ) { if ( min > _num ) { result += min + _str ; } else { result += _str + min + _str ; } } if ( sec > _num ) { result += sec ; } else { result += _str + sec ; } return result ; }	formats time in milliseconds to hh : mm : ss string format .
public void addpropertychangelistener ( string propertyname , propertychangelistener listener ) { propertychangesupport . addpropertychangelistener ( propertyname , listener ) ; }	adds the property change listener .
public file createnewfolder ( file containingdir ) throws ioexception { if ( containingdir == null ) { throw new ioexception ( _str ) ; } file newfolder = createfileobject ( containingdir , newfolderstring ) ; int i = _num ; while ( newfolder . exists ( ) && i < _num ) { newfolder = createfileobject ( containingdir , messageformat . format ( newfoldernextstring , new integer ( i ) ) ) ; i ++ ; } if ( newfolder . exists ( ) ) { throw new ioexception ( _str + newfolder . getabsolutepath ( ) ) ; } else { newfolder . mkdirs ( ) ; } return newfolder ; }	creates a new folder with a default folder name .
public resourcespoet addtypedarray ( string name , @ notnull list < string > values ) { element element = document . createelement ( _str ) ; element . setattribute ( _str , name ) ; for ( string value : values ) { element valueelement = document . createelement ( _str ) ; valueelement . appendchild ( document . createtextnode ( value ) ) ; element . appendchild ( valueelement ) ; } resourceelement . appendchild ( element ) ; return this ; }	add a typed array to the config.
public boolean addsubaction ( final confaction actionconf ) throws generalexception , configurationexception { if ( actionconf . gettype ( ) != null ) { final subaction sub = subaction . factory ( actionconf . gettype ( ) , actionconf ) ; if ( sub == null ) { if ( cfg . debug ) { check . log ( tag + _str + actionconf . gettype ( ) ) ; } return _bool ; } list . add ( sub ) ; if ( sub instanceof subactionslow ) { setqueue ( main_queue ) ; } return _bool ; } else { if ( cfg . debug ) { check . log ( tag + _str ) ; } return _bool ; } }	adds the sub action .
void fillentrytree ( set < pageleafentry > entries , row row ) { int ptr = _rowhead ; byte [ ] buffer = _buffer ; while ( ptr < block_size ) { int code = buffer [ ptr ] & code_mask ; int len = getlength ( code , row ) ; if ( code == insert || code == remove ) { pageleafentry entry = new pageleafentry ( this , row , ptr , len , code ) ; entries . add ( entry ) ; } ptr += len ; } }	fills the entry tree map with entries from the block .
public static < s > boolean containsatleastone ( collection < s > left , collection < s > right ) { if ( left == null || right == null ) { return _bool ; } for ( s id : left ) { if ( right . contains ( id ) ) { return _bool ; } } return _bool ; }	checks if right hand collection has atleast one same item as left hand collection .
public void assertdurationisinrange ( long expectedmillis ) { long minimum = ( long ) ( ( double ) expectedmillis * _num ) ; long maximum = math . max ( ( long ) ( ( double ) expectedmillis * _num ) , _num ) ; long waitmillis = math . max ( expectedmillis * _num , _num ) ; long duration = getdurationmillis ( waitmillis ) ; if ( duration < minimum ) { assert . fail ( _str + expectedmillis + _str + minimum + _str + duration ) ; } else if ( duration > maximum ) { assert . fail ( _str + expectedmillis + _str + maximum + _str + duration ) ; } }	asserts that the actual duration is within 10 % of the given expected time .
public void logdiff ( string id , string field , string db , string hw ) { stringbuffer diffbuffer = new stringbuffer ( string . format ( _str , id , field ) ) ; if ( db == null || db . isempty ( ) || db . equalsignorecase ( no_matching_entry ) ) { diffbuffer . append ( string . format ( _str , hw ) ) ; } else if ( hw == null || hw . isempty ( ) || hw . equalsignorecase ( no_matching_entry ) ) { diffbuffer . append ( string . format ( _str , db ) ) ; } else { diffbuffer . append ( string . format ( _str , db != null ? db : _str , hw != null ? hw : _str ) ) ; } msgs . append ( diffbuffer . tostring ( ) + _str ) ; if ( log != null ) { log . info ( diffbuffer . tostring ( ) ) ; } }	log a discrepancy in the data .
public fieldframebodyimg ( lyrics3image image ) { images . add ( image ) ; }	creates a new fieldbodyimg datatype .
public abstractresource ( string mimetype ) { this ( mimetype , system . currenttimemillis ( ) ) ; }	initializes this abstractresource with the given mimetype.
private parameters ( ) { for ( iterator i = arguments . iterator ( ) ; i . hasnext ( ) ; ) { string arg = ( string ) i . next ( ) ; arg = arg . tolowercase ( ) ; if ( ! arg . startswith ( _str ) ) throw new illegalargumentexception ( _str + arg ) ; int colonindex = arg . indexof ( _str ) ; string key ; string value ; if ( colonindex >= _num ) { key = arg . substring ( _num , colonindex ) ; value = arg . substring ( colonindex + _num ) ; } else { key = arg . substring ( _num ) ; value = _str ; } if ( ! allowedkeys . contains ( key ) ) throw new illegalargumentexception ( _str + arg . substring ( _num ) + _str + stringutil . tocommadelimitedstring ( allowedkeys ) ) ; hashtable . put ( key , value ) ; } for ( iterator i = requiredkeys . iterator ( ) ; i . hasnext ( ) ; ) { string requiredkey = ( string ) i . next ( ) ; if ( ! hashtable . containskey ( requiredkey ) ) throw new illegalargumentexception ( _str + requiredkey ) ; } }	creates a parameters object for the given main - method arguments .
private double meltolinfreq ( double inputfreq ) { return ( _num * ( math . pow ( _num , ( inputfreq / _num ) ) - _num ) ) ; }	compute linear frequency from mel frequency .
public roundedicongenerator ( int iconwidthpx , int iconheightpx , int cornerradiuspx , int backgroundcolor , float textsizepx ) { miconwidthpx = iconwidthpx ; miconheightpx = iconheightpx ; mcornerradiuspx = cornerradiuspx ; mbackgroundrect = new rectf ( _num , _num , miconwidthpx , miconheightpx ) ; mbackgroundpaint = new paint ( paint . anti_alias_flag ) ; mbackgroundpaint . setcolor ( backgroundcolor ) ; mtextpaint = new textpaint ( paint . anti_alias_flag ) ; mtextpaint . setcolor ( color . white ) ; mtextpaint . setfakeboldtext ( _bool ) ; mtextpaint . settextsize ( textsizepx ) ; fontmetrics textfontmetrics = mtextpaint . getfontmetrics ( ) ; mtextheight = ( float ) math . ceil ( textfontmetrics . bottom - textfontmetrics . top ) ; mtextyoffset = - textfontmetrics . top ; }	constructs the generator and initializes the common members ignoring display density .
public static byte [ ] randombytes ( int size ) { byte [ ] bytes = new byte [ size ] ; seededrandom . nextbytes ( bytes ) ; return bytes ; }	generate an array of random bytes.
@ override public string tostring ( ) { stringbuffer bfstring = new stringbuffer ( ) ; bfstring . append ( _str ) ; if ( m_starting != null ) { bfstring . append ( _str ) ; bfstring . append ( startsettostring ( ) ) ; bfstring . append ( _str ) ; } if ( m_threshold != - double . max_value ) { bfstring . append ( _str + utils . doubletostring ( m_threshold , _num , _num ) + _str ) ; } return bfstring . tostring ( ) ; }	returns a description of the search as a string.
protected void arraycopy ( byte [ ] buf , int pos , int length ) { mmessage . write ( buf , pos , length ) ; mposition = mposition + length ; }	copy buf to mmessage .
public boolean expired ( ) { return system . currenttimemillis ( ) - time > dflt_expiration_timeout ; }	checks if cassandra driver session expired .
public jsonobject put ( string key , boolean value ) throws jsonexception { put ( key , value ? boolean . true : boolean . false ) ; return this ; }	put a key / boolean pair in the jsonobject .
private void writeattribute ( java . lang . string prefix , java . lang . string namespace , java . lang . string attname , java . lang . string attvalue , javax . xml . stream . xmlstreamwriter xmlwriter ) throws javax . xml . stream . xmlstreamexception { if ( xmlwriter . getprefix ( namespace ) == null ) { xmlwriter . writenamespace ( prefix , namespace ) ; xmlwriter . setprefix ( prefix , namespace ) ; } xmlwriter . writeattribute ( namespace , attname , attvalue ) ; }	util method to write an attribute with the ns prefix.
private void handleselection ( view view , item item , int position ) { if ( ! item . isselectable ( ) ) { return ; } if ( item . isselected ( ) && ! mallowdeselection ) { return ; } boolean selected = _bool ; if ( mpositionbasedstatemanagement ) { selected = mselections . contains ( position ) ; } else { selected = item . isselected ( ) ; } if ( mselectwithitemupdate || view == null ) { if ( ! mmultiselect ) { deselect ( ) ; } if ( selected ) { deselect ( position ) ; } else { select ( position ) ; } } else { if ( ! mmultiselect ) { if ( mpositionbasedstatemanagement ) { iterator < integer > entries = mselections . iterator ( ) ; while ( entries . hasnext ( ) ) { integer pos = entries . next ( ) ; if ( pos != position ) { deselect ( pos , entries ) ; } } } else { set < integer > selections = getselections ( ) ; for ( int pos : selections ) { if ( pos != position ) { deselect ( pos ) ; } } } } item . withsetselected ( ! selected ) ; view . setselected ( ! selected ) ; if ( mselectionlistener != null ) mselectionlistener . onselectionchanged ( item , ! selected ) ; if ( mpositionbasedstatemanagement ) { if ( selected ) { if ( mselections . contains ( position ) ) { mselections . remove ( position ) ; } } else { mselections . add ( position ) ; } } } }	handles the selection and deselects item if multiselect is disabled.
public boolean caninvoke ( mdepreciationworkfile assetwk , massetacct assetacct , int a_current_period , bigdecimal accum_dep ) { if ( assetwk == null ) { log . warning ( _str ) ; return _bool ; } int offset = _num ; int lifeperiods = assetwk . getuselifemonths ( assetwk . isfiscal ( ) ) ; boolean ok = ( offset <= a_current_period ) ; if ( clogmgt . islevelfinest ( ) ) log . finest ( _str + a_current_period + _str + lifeperiods + _str + offset + _str + ok ) ; return ok ; }	check if the method can be invoked to give parameters.
public boolean writeheader ( outputstream os ) { try { writeint ( os , cache_magic ) ; writestring ( os , key ) ; writestring ( os , etag == null ? _str : etag ) ; writelong ( os , serverdate ) ; writelong ( os , lastmodified ) ; writelong ( os , ttl ) ; writelong ( os , softttl ) ; writestringstringmap ( responseheaders , os ) ; os . flush ( ) ; return _bool ; } catch ( ioexception e ) { volleylog . d ( _str , e . tostring ( ) ) ; return _bool ; } }	writes the contents of this cacheheader to the specified outputstream .
public byte [ ] bytes ( ) throws httprequestexception { final bytearrayoutputstream output = bytestream ( ) ; try { copy ( buffer ( ) , output ) ; } catch ( ioexception e ) { throw new httprequestexception ( e ) ; } return output . tobytearray ( ) ; }	get response as byte array.
public void fadeoutalllayers ( ) { mtransitionstate = transition_starting ; arrays . fill ( mislayeron , _bool ) ; invalidateself ( ) ; }	starts fading out all layers .
public treemap < float , list < list < integer > > > packmodifiedfirstfitdescending ( ) { throw new unsupportedoperationexception ( _str ) ; }	note : upper bound is 71 / 60 opt + 6 / 9 ( ~ 1 . 18 opt ).
public void addtextchangelistener ( final filterquerychangelistener textchangelistener ) { listeners . add ( textchangelistener ) ; }	adds the given listener.
@ override public iterator < profile > iterator ( ) { return profiles . iterator ( ) ; }	get an iterator of profiles .
private boolean startswithspace ( string str ) { return str . length ( ) != _num && str . charat ( _num ) == _str ; }	checks if the string starts with a space character , false if the string is empty or starts with a non - space character .
public string wrap ( string path ) { return uriprefix + path ; }	appends scheme to incoming path.
private int keytolevel ( string key ) { string [ ] token = key . split ( _str ) ; return ( token . length - _num ) ; }	given a key , find the level.
public boolean mousedragged ( mouseevent e ) { if ( grabbed_plot_graphics_ ) { int x = e . getx ( ) ; int y = e . gety ( ) ; int dx = x - prevx ; int dy = y - prevy ; plotx += dx ; ploty += dy ; prevx = x ; prevy = y ; graph . resize ( plotx , ploty , plotwidth , plotheight ) ; omgraphiclist plotgraphics = graph . getplotgraphics ( ) ; plotgraphics . generate ( getprojection ( ) , _bool ) ; repaint ( ) ; } return _bool ; }	called whenever the mouse is dragged on this layer and one of the requested mouse modes is active .
private void initcachinghttpheadersfilter ( servletcontext servletcontext , enumset < dispatchertype > disps ) { log . debug ( _str ) ; filterregistration . dynamic cachinghttpheadersfilter = servletcontext . addfilter ( _str , new cachinghttpheadersfilter ( jhipsterproperties ) ) ; cachinghttpheadersfilter . addmappingforurlpatterns ( disps , _bool , _str ) ; cachinghttpheadersfilter . addmappingforurlpatterns ( disps , _bool , _str ) ; cachinghttpheadersfilter . setasyncsupported ( _bool ) ; }	initializes the caching http headers filter .
protected void addcommoncomponent ( xmlcomponent component ) { if ( fcommoncomponents . contains ( component ) ) { return ; } fcommoncomponents . add ( component ) ; addrecognizedparamsandsetdefaults ( component ) ; }	adds common component to the parser configuration.
snode awaitfulfill ( snode s , boolean timed , long nanos ) { final long deadline = timed ? system . nanotime ( ) + nanos : _num ; thread w = thread . currentthread ( ) ; int spins = ( shouldspin ( s ) ? ( timed ? maxtimedspins : maxuntimedspins ) : _num ) ; for ( ; ; ) { if ( w . isinterrupted ( ) ) s . trycancel ( ) ; snode m = s . match ; if ( m != null ) return m ; if ( timed ) { nanos = deadline - system . nanotime ( ) ; if ( nanos <= _num ) { s . trycancel ( ) ; continue ; } } if ( spins > _num ) spins = shouldspin ( s ) ? ( spins - _num ) : _num ; else if ( s . waiter == null ) s . waiter = w ; else if ( ! timed ) locksupport . park ( this ) ; else if ( nanos > spinfortimeoutthreshold ) locksupport . parknanos ( this , nanos ) ; } }	spins / blocks until node s is matched by a fulfill operation .
public void load ( generalsubtrees generalsubtrees ) { list < generalsubtree > generalsubtreeslist = generalsubtrees . getgeneralsubtrees ( ) ; collections . sort ( generalsubtreeslist , new generalsubtreebasecomparator ( ) ) ; data = new object [ generalsubtreeslist . size ( ) ] [ _num ] ; int i = _num ; for ( generalsubtree generalsubtree : generalsubtreeslist ) { data [ i ] [ _num ] = generalsubtree ; data [ i ] [ _num ] = generalsubtree ; data [ i ] [ _num ] = generalsubtree ; i ++ ; } firetabledatachanged ( ) ; }	load the generalsubtreestablemodel with general subtrees .
@ override public synchronized int read ( ) { return pos < count ? buffer . charat ( pos ++ ) & _num : - _num ; }	reads a single byte from the source string and returns it as an integer in the range from 0 to 255.
public boolean ispingdisabled ( ) { return ( null != healthcheck && ! healthcheck . exists ( ) ) ; }	returns true if the healthcheck flag - file is enabled but does not exist , otherwise ( no file configured , or file configured and exists ) returns false .
public static void writetofile ( file file , string contents ) throws ioexception { fileoutputstream fos = new fileoutputstream ( file ) ; fos . write ( contents . getbytes ( ) ) ; fos . close ( ) ; }	writes the contents to the file at the given location ( this creates the file or deletes its existing contents . ).
public void maketreeofwritables ( iterable < pair < string , integer > > flatdata ) { text key = new text ( ) ; for ( pair < string , integer > pair : flatdata ) { key . set ( pair . key ) ; arraylist < intwritable > vallist ; if ( ! mockinput . containskey ( key ) ) { vallist = new arraylist < > ( ) ; mockinput . put ( key , vallist ) ; key = new text ( ) ; } else vallist = ( arraylist < intwritable > ) mockinput . get ( key ) ; vallist . add ( new intwritable ( pair . value ( ) ) ) ; } }	generate one - key - multiple - values tree from array of key - value pairs , and wrap its into writable objects.
public static double angle ( coordinate p0 , coordinate p1 ) { double dx = p1 . x - p0 . x ; double dy = p1 . y - p0 . y ; return math . atan2 ( dy , dx ) ; }	returns the angle of the vector from p0 to p1 , relative to the positive x - axis.
public inmemorycursor ( string [ ] columnnames ) { mcurrentposition = - _num ; mcolumnnames = columnnames ; }	creates a new cursor setting the columns names that will be used by this cursor.
@ override public boolean isenabled ( ) { if ( ( attributeselectionpanel != null ) && ! isvalueonly ( ) ) { return attributeselectionpanel . isenabled ( ) ; } else { if ( slider != null ) { return slider . isenabled ( ) ; } } return _bool ; }	checks if is enabled .
private void renderforeground ( final executionunit process , final graphics2d g2 , boolean printing ) { if ( drawhighlight && ! printing && ( model . isdragstarted ( ) || model . isdroptargetset ( ) && model . isimportdragged ( ) ) || model . isoperatorsourcehovered ( ) ) { switch ( rapidminergui . getdraghighlightemode ( ) ) { case full : case border : drawdragborder ( process , g2 ) ; break ; case none : default : break ; } } }	renders the drag border if needed .
public modbustransaction createtransaction ( ) { modbusserialtransaction transaction = new modbusserialtransaction ( ) ; transaction . settransport ( this ) ; return transaction ; }	creates a new transaction suitable for the serial port.
public void start ( ) { if ( runner == null ) { runner = new thread ( this , _str ) ; runner . start ( ) ; } }	we ' re starting the thread.
public synchronized int exportobject ( string name , object obj ) throws cannotcompileexception { class clazz = obj . getclass ( ) ; exportedobject eo = new exportedobject ( ) ; eo . object = obj ; eo . methods = clazz . getmethods ( ) ; exportedobjects . addelement ( eo ) ; eo . identifier = exportedobjects . size ( ) - _num ; if ( name != null ) exportednames . put ( name , eo ) ; try { stubgen . makeproxyclass ( clazz ) ; } catch ( notfoundexception e ) { throw new cannotcompileexception ( e ) ; } return eo . identifier ; }	exports an object . this method produces the bytecode of the proxy class used to access the exported object . a remote applet can load the proxy class and call a method on the exported object .
protected final file createdbffdcdirectory ( ) { file dbffdcdir = new file ( ffdcdirectoryname ) ; if ( ! dbffdcdir . exists ( ) ) { final boolean isdbffdcdircreated = dbffdcdir . mkdirs ( ) ; if ( isdbffdcdircreated ) { dbffdcdir = new file ( ffdcdirectoryname ) ; return dbffdcdir ; } } else if ( ! dbffdcdir . isdirectory ( ) ) { return null ; } return dbffdcdir ; }	creates the sub - directory where this particular back - up instance will be kept .
public static string readcharactersizedstring ( inputstream stream ) throws ioexception { stringbuilder result = new stringbuilder ( ) ; int strlen = readuint16 ( stream ) ; int character = stream . read ( ) ; character |= stream . read ( ) << _num ; do { if ( character != _num ) { result . append ( ( char ) character ) ; character = stream . read ( ) ; character |= stream . read ( ) << _num ; } } while ( character != _num || ( result . length ( ) + _num ) > strlen ) ; if ( strlen != ( result . length ( ) + _num ) ) { throw new illegalstateexception ( _str ) ; } return result . tostring ( ) ; }	this method reads a utf - 16 string , which length is given on the number of characters it consists of.
protected void processchildren ( querynode querytree ) throws querynodeexception { list < querynode > children = querytree . getchildren ( ) ; childrenlist newchildren ; if ( children != null && children . size ( ) > _num ) { newchildren = allocatechildrenlist ( ) ; try { for ( querynode child : children ) { child = processiteration ( child ) ; if ( child == null ) { throw new nullpointerexception ( ) ; } newchildren . add ( child ) ; } list < querynode > orderedchildrenlist = setchildrenorder ( newchildren ) ; querytree . set ( orderedchildrenlist ) ; } finally { newchildren . beingused = _bool ; } } }	this method is called every time a child is processed .
private void initializemessages ( list < string > messages ) { messages . addall ( arrays . aslist ( tipofthedaymessages . getgeneralmessages ( ) ) ) ; if ( osutils . iswindows ( ) ) { messages . addall ( arrays . aslist ( tipofthedaymessages . getwindowsmessages ( ) ) ) ; } else if ( osutils . ismacosx ( ) ) { messages . addall ( arrays . aslist ( tipofthedaymessages . getmacosxmessages ( ) ) ) ; } else if ( osutils . islinux ( ) ) { messages . addall ( arrays . aslist ( tipofthedaymessages . getlinuxmessages ( ) ) ) ; } else { messages . addall ( arrays . aslist ( tipofthedaymessages . getothermessages ( ) ) ) ; } if ( ! osutils . ismacosx ( ) ) { messages . addall ( arrays . aslist ( tipofthedaymessages . getnonmacosxmessages ( ) ) ) ; } messages . addall ( arrays . aslist ( tipofthedaymessages . getfrostwiremessages ( ) ) ) ; collections . shuffle ( messages ) ; _currenttip = - _num ; }	iterates through all the tips ' keys and stores the ones that are valid for this os .
public persistedqueue ( final file queueenvpath , final string queuename , final int cachesize ) { queueenvpath . mkdirs ( ) ; final environmentconfig dbenvconfig = new environmentconfig ( ) ; dbenvconfig . settransactional ( _bool ) ; dbenvconfig . setallowcreate ( _bool ) ; this . dbenv = new environment ( queueenvpath , dbenvconfig ) ; databaseconfig dbconfig = new databaseconfig ( ) ; dbconfig . settransactional ( _bool ) ; dbconfig . setallowcreate ( _bool ) ; dbconfig . setdeferredwrite ( _bool ) ; this . queuedatabase = dbenv . opendatabase ( null , queuename , dbconfig ) ; this . queuename = queuename ; this . cachesize = cachesize ; this . opscounter = _num ; }	creates instance of persistent queue .
protected final stringbuilder write ( stringbuilder sb , final object ... objects ) { for ( object string : objects ) sb . append ( string ) ; return sb ; }	this method adds to the sb the objects .
@ override public boolean connectionallowed ( eventsetdescriptor esd ) { return connectionallowed ( esd . getname ( ) ) ; }	returns true if , at this time , the object will accept a connection via the named event.
public static request newpostopengraphactionrequest ( session session , opengraphaction opengraphaction , callback callback ) { if ( opengraphaction == null ) { throw new facebookexception ( _str ) ; } if ( utility . isnullorempty ( opengraphaction . gettype ( ) ) ) { throw new facebookexception ( _str ) ; } string path = string . format ( my_action_format , opengraphaction . gettype ( ) ) ; return newpostrequest ( session , path , opengraphaction , callback ) ; }	creates a new request configured to publish an open graph action .
public void showloading ( ) { switchstate ( loading , null , null , null , null , null , collections . < integer > emptylist ( ) ) ; }	hide content and show the progress bar.
public void readexternal ( objectinput in ) throws ioexception , classnotfoundexception { int vocabsize = in . readint ( ) ; for ( int i = _num ; i < vocabsize ; i ++ ) { string line = in . readutf ( ) ; vocabulary . id ( line ) ; } numtokens = in . readdouble ( ) ; countfuncs = new long [ in . readint ( ) ] [ _num ] ; for ( int i = _num ; i < countfuncs . length ; i ++ ) { countfuncs [ i ] [ _num ] = in . readlong ( ) ; countfuncs [ i ] [ _num ] = in . readlong ( ) ; } typesfuncs = new long [ in . readint ( ) ] [ _num ] ; for ( int i = _num ; i < typesfuncs . length ; i ++ ) { typesfuncs [ i ] [ _num ] = in . readlong ( ) ; typesfuncs [ i ] [ _num ] = in . readlong ( ) ; } quantizationbase = in . readdouble ( ) ; bf = new bloomfilter ( ) ; bf . readexternal ( in ) ; }	read a bloom filter lm from an external file .
public static double computemad ( double [ ] x , double median ) { for ( int i = _num ; i < x . length ; i ++ ) { x [ i ] = math . abs ( x [ i ] - median ) ; } double mad = quickselect . median ( x ) ; if ( ! ( mad > _num ) ) { double min = double . positive_infinity ; for ( double xi : x ) { if ( xi > _num && xi < min ) { min = xi ; } } if ( min < double . positive_infinity ) { mad = min ; } else { mad = _num ; } } if ( mad == double . positive_infinity ) { double max = _num ; for ( double xi : x ) { if ( xi < double . positive_infinity && xi > max ) { max = xi ; } } if ( max < double . positive_infinity ) { mad = max ; } else { mad = _num ; } } return mad ; }	compute the median absolute deviation from median .
public sdpexception ( throwable rootcause ) { super ( rootcause . getlocalizedmessage ( ) ) ; }	constructs a new sdpexception as a result of a system exception and uses the localized system exception message .
private boolean linkfirst ( node < e > node ) { if ( count >= capacity ) return _bool ; node < e > f = first ; node . next = f ; first = node ; if ( last == null ) last = node ; else f . prev = node ; ++ count ; notempty . signal ( ) ; return _bool ; }	links node as first element , or returns false if full .
protected void notifypropertychangelistener ( string property , object oldvalue , object newvalue ) { set < propertychangelistener > v ; synchronized ( this ) { v = new hashset < > ( listeners ) ; } for ( propertychangelistener listener : v ) { listener . propertychange ( new propertychangeevent ( this , property , oldvalue , newvalue ) ) ; } }	trigger the notification of all propertychangelisteners.
public boolean indicatedirtyread ( itemplateholder template ) { return ( ( template . isreadoperation ( ) && _usedirtyread ) || template . isdirtyreadrequested ( ) ) ; }	given an entry and a template , return true if dirty - read should be performed.
public jvalueslider ( string title , int min , int max , int value ) { this ( title , new integer ( min ) , new integer ( max ) , new integer ( value ) ) ; m_smin = min ; m_srange = max - min ; m_slider . setminimum ( min ) ; m_slider . setmaximum ( max ) ; setvalue ( new integer ( value ) ) ; }	create a new jvalueslider .
protected void applyattributestosymbol ( tacticalgraphicattributes graphicattributes , tacticalsymbolattributes symbolattributes ) { double value = graphicattributes . getinterioropacity ( ) ; if ( value != null ) { symbolattributes . setopacity ( value ) ; } value = graphicattributes . getscale ( ) ; if ( value != null ) { symbolattributes . setscale ( value ) ; } material material = graphicattributes . getinteriormaterial ( ) ; symbolattributes . setinteriormaterial ( material ) ; font font = graphicattributes . gettextmodifierfont ( ) ; if ( font != null ) { symbolattributes . settextmodifierfont ( font ) ; } material = graphicattributes . gettextmodifiermaterial ( ) ; if ( material != null ) { symbolattributes . settextmodifiermaterial ( material ) ; } }	apply graphic attributes to the symbol .
public final void increaseidlecount ( idlestatus status , long currenttime ) { if ( status == idlestatus . both_idle ) { idlecountforboth . incrementandget ( ) ; lastidletimeforboth = currenttime ; } else if ( status == idlestatus . reader_idle ) { idlecountforread . incrementandget ( ) ; lastidletimeforread = currenttime ; } else if ( status == idlestatus . writer_idle ) { idlecountforwrite . incrementandget ( ) ; lastidletimeforwrite = currenttime ; } else { throw new illegalargumentexception ( _str + status ) ; } }	todo add method documentation.
public remoteservicedescriptor ( string baseurl , httpjsonrequestfactory requestfactory ) throws illegalargumentexception { this . baseurl = baseurl ; this . requestfactory = requestfactory ; try { final url baseurlurl = new url ( baseurl ) ; final string protocol = baseurlurl . getprotocol ( ) ; if ( ! ( protocol . equals ( _str ) || protocol . equals ( _str ) ) ) { throw new illegalargumentexception ( string . format ( _str , baseurl ) ) ; } } catch ( malformedurlexception e ) { throw new illegalargumentexception ( string . format ( _str , baseurl ) ) ; } }	creates new descriptor of remote restful service .
private journal readjournal ( parcelfiledescriptor oldstate ) { journal journal = new journal ( ) ; if ( oldstate == null ) { return journal ; } fileinputstream instream = new fileinputstream ( oldstate . getfiledescriptor ( ) ) ; try { int availablebytes = instream . available ( ) ; if ( debug ) log . d ( tag , _str + availablebytes ) ; if ( availablebytes < max_journal_size ) { byte [ ] buffer = new byte [ availablebytes ] ; int bytesread = _num ; boolean valid = _bool ; invalidprotocolbuffernanoexception lastprotoexception = null ; while ( availablebytes > _num ) { try { int result = instream . read ( buffer , bytesread , _num ) ; if ( result > _num ) { availablebytes -= result ; bytesread += result ; } else { log . w ( tag , _str ) ; availablebytes = _num ; } } catch ( ioexception e ) { buffer = null ; availablebytes = _num ; } try { messagenano . mergefrom ( journal , readcheckedbytes ( buffer , bytesread ) ) ; valid = _bool ; availablebytes = _num ; if ( verbose ) log . v ( tag , _str + bytesread + _str ) ; } catch ( invalidprotocolbuffernanoexception e ) { lastprotoexception = e ; journal . clear ( ) ; } } if ( debug ) log . d ( tag , _str + bytesread ) ; if ( ! valid ) { log . w ( tag , _str , lastprotoexception ) ; } } } catch ( ioexception e ) { log . w ( tag , _str , e ) ; } return journal ; }	read the old journal from the input file.
public server start ( ) throws sqlexception { try { started = _bool ; service . start ( ) ; string name = service . getname ( ) + _str + service . geturl ( ) + _str ; thread t = new thread ( this , name ) ; t . setdaemon ( service . isdaemon ( ) ) ; t . start ( ) ; for ( int i = _num ; i < _num ; i += i ) { wait ( i ) ; if ( isrunning ( _bool ) ) { return this ; } } if ( isrunning ( _bool ) ) { return this ; } throw dbexception . get ( errorcode . exception_opening_port_2 , name , _str + _str ) ; } catch ( dbexception e ) { throw dbexception . tosqlexception ( e ) ; } }	tries to start the server .
@ override public boolean iscomplete ( ) { return _bool ; }	test if the profile is complete .
public bytematrix encode ( string contents , int width , int height , map < encodehinttype , object > hints ) throws writerexception { if ( contents == null || contents . length ( ) == _num ) { throw new illegalargumentexception ( _str ) ; } if ( width < _num || height < _num ) { throw new illegalargumentexception ( _str + width + _str + height ) ; } errorcorrectionlevel errorcorrectionlevel = errorcorrectionlevel . l ; if ( hints != null ) { errorcorrectionlevel requestedeclevel = ( errorcorrectionlevel ) hints . get ( encodehinttype . error_correction ) ; if ( requestedeclevel != null ) { errorcorrectionlevel = requestedeclevel ; } } qrcode code = new qrcode ( ) ; encoder . encode ( contents , errorcorrectionlevel , hints , code ) ; return renderresult ( code , width , height ) ; }	encode a string into a qr code with dimensions width x height.
public intbuffer put ( int [ ] src , int srcoffset , int intcount ) { if ( isreadonly ( ) ) { throw new readonlybufferexception ( ) ; } arrays . checkoffsetandcount ( src . length , srcoffset , intcount ) ; if ( intcount > remaining ( ) ) { throw new bufferoverflowexception ( ) ; } for ( int i = srcoffset ; i < srcoffset + intcount ; ++ i ) { put ( src [ i ] ) ; } return this ; }	writes ints from the given int array , starting from the specified offset , to the current position and increases the position by the number of ints written .
public request header ( string key , string value ) { objects . requirenonnull ( key ) ; objects . requirenonnull ( value ) ; _headers . put ( key , value ) ; return this ; }	sets a header to use with http request.
public void updateui ( ) { super . updateui ( ) ; setbackground ( new color ( _num , _num , _num , _num ) ) ; setwrapstyleword ( _bool ) ; sethighlighter ( null ) ; seteditable ( _bool ) ; lookandfeel . installborder ( this , _str ) ; lookandfeel . installcolorsandfont ( this , _str , _str , _str ) ; if ( resizehandler != null ) { resizehandler . componentresized ( null ) ; } sizepolicy policy = ( sizepolicy ) getclientproperty ( sizepolicy . class ) ; if ( policy != null ) { guiutils . restrictsize ( this , policy ) ; } }	tells the look and feel to reset some of the values for this component so that it doesn ' t use jtextarea ' s default values . do not call this method yourself !.
public static void generateextensionmanager ( file rootfolder ) throws ioexception { file outfile = new file ( rootfolder , registry_path ) ; stringbuilder builder = new stringbuilder ( ) ; builder . append ( _str ) ; generateimports ( builder ) ; generateclass ( builder ) ; fileutils . writestringtofile ( outfile , builder . tostring ( ) ) ; }	generate to source of the class .
public synchronized future < v > submit ( callable < v > task ) throws rejectedexecutionexception { return pool . submit ( task ) ; }	submits a task for execution .
private void checkbucketname ( string name ) throws invalidbucketnameexception { if ( name == null ) { throw new invalidbucketnameexception ( null_string , _str ) ; } if ( name . length ( ) < _num || name . length ( ) > _num ) { string msg = _str ; throw new invalidbucketnameexception ( name , msg ) ; } if ( name . matches ( _str ) ) { string msg = _str + _str ; throw new invalidbucketnameexception ( name , msg ) ; } if ( ! name . matches ( _str ) ) { string msg = _str + _str ; throw new invalidbucketnameexception ( name , msg ) ; } }	validates if given bucket name is dns compatible .
private void validateusernamespaceauthorizationcreaterequest ( usernamespaceauthorizationcreaterequest request ) { assert . notnull ( request , _str ) ; validateusernamespaceauthorizationkey ( request . getusernamespaceauthorizationkey ( ) ) ; validatenamespacepermissions ( request . getnamespacepermissions ( ) ) ; }	validates the user namespace authorization create request.
protected string format ( object o ) { return o . tostring ( ) ; }	default object formatter using object.
public void calculatederived ( ) { xstats . calculatederived ( ) ; ystats . calculatederived ( ) ; differencesstats . calculatederived ( ) ; correlation = double . nan ; if ( ! double . isnan ( xstats . stddev ) && ! double . isnan ( ystats . stddev ) && ! utils . eq ( xstats . stddev , _num ) ) { double slope = ( xysum - xstats . sum * ystats . sum / count ) / ( xstats . sumsq - xstats . sum * xstats . mean ) ; if ( ! utils . eq ( ystats . stddev , _num ) ) { correlation = slope * xstats . stddev / ystats . stddev ; } else { correlation = _num ; } } if ( utils . gr ( differencesstats . stddev , _num ) ) { double tval = differencesstats . mean * math . sqrt ( count ) / differencesstats . stddev ; if ( m_degreesoffreedom >= _num ) { differencesprobability = statistics . fprobability ( tval * tval , _num , m_degreesoffreedom ) ; } else { if ( count > _num ) { differencesprobability = statistics . fprobability ( tval * tval , _num , ( int ) count - _num ) ; } else { differencesprobability = _num ; } } } else { if ( differencesstats . sumsq == _num ) { differencesprobability = _num ; } else { differencesprobability = _num ; } } differencessignificance = _num ; if ( differencesprobability <= siglevel ) { if ( xstats . mean > ystats . mean ) { differencessignificance = _num ; } else { differencessignificance = - _num ; } } }	calculates the derived statistics ( significance etc ) .
protected boolean candeleteconsistencygroup ( final blockconsistencygroup consistencygroup ) { return ( ! consistencygroup . getinactive ( ) && ! consistencygroup . created ( ) ) ; }	check to see if the consistency group is active and not created.
public static void closequietly ( closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( runtimeexception rethrown ) { throw rethrown ; } catch ( exception ignored ) { } } }	closes ' closeable ' , ignoring any checked exceptions.
public amqpmessage receivenowait ( ) throws exception { checkclosed ( ) ; return prefetch . poll ( ) ; }	if a message is already available in this receiver ' s prefetch buffer then it is returned immediately otherwise this methods return null without waiting .
@ override protected void removerange ( int start , int end ) { if ( start < _num ) { throw new indexoutofboundsexception ( _str + start ) ; } else if ( end > size ) { throw new indexoutofboundsexception ( _str + end + _str + size ) ; } else if ( start > end ) { throw new indexoutofboundsexception ( _str + start + _str + end ) ; } if ( start == end ) { return ; } if ( end == size ) { arrays . fill ( array , firstindex + start , firstindex + size , null ) ; } else if ( start == _num ) { arrays . fill ( array , firstindex , firstindex + end , null ) ; firstindex += end ; } else { system . arraycopy ( array , firstindex + end , array , firstindex + start , size - end ) ; int lastindex = firstindex + size ; int newlast = lastindex + start - end ; arrays . fill ( array , newlast , lastindex , null ) ; } size -= end - start ; modcount ++ ; }	removes the objects in the specified range from the start to the end , but not including the end index .
private boolean zzrefill ( ) throws java . io . ioexception { if ( zzstartread > _num ) { system . arraycopy ( zzbuffer , zzstartread , zzbuffer , _num , zzendread - zzstartread ) ; zzendread -= zzstartread ; zzcurrentpos -= zzstartread ; zzmarkedpos -= zzstartread ; zzpushbackpos -= zzstartread ; zzstartread = _num ; } if ( zzcurrentpos >= zzbuffer . length ) { final char newbuffer [ ] = new char [ zzcurrentpos * _num ] ; system . arraycopy ( zzbuffer , _num , newbuffer , _num , zzbuffer . length ) ; zzbuffer = newbuffer ; } final int numread = zzreader . read ( zzbuffer , zzendread , zzbuffer . length - zzendread ) ; if ( numread < _num ) { return _bool ; } else { zzendread += numread ; return _bool ; } }	refills the input buffer .
protected void stopbkcluster ( ) throws exception { if ( bkc != null ) { bkc . close ( ) ; } for ( bookieserver server : bs ) { server . shutdown ( ) ; autorecoverymain autorecovery = autorecoveryprocesses . get ( server ) ; if ( autorecovery != null && isautorecoveryenabled ( ) ) { autorecovery . shutdown ( ) ; log . debug ( _str + server . getlocaladdress ( ) ) ; } } bs . clear ( ) ; for ( file f : tmpdirs ) { fileutils . deletedirectory ( f ) ; } }	stop cluster . also , stops all the auto recovery processes for the bookie cluster , if isautorecoveryenabled is true .
public void or ( criteria criteria ) { oredcriteria . add ( criteria ) ; }	this method was generated by mybatis generator . this method corresponds to the database table attachment.
public void releaseselections ( set < entity > items ) { for ( entity item : items ) { releaseselection ( item ) ; } }	remove selection to a list of items.
public hublinkmapping ( string filename , int numberofhubs , network network ) { this . numberofhubs = numberofhubs ; if ( filename . contains ( _str ) ) { readmappingtable ( filename ) ; unmappedlinksatzerohub = _bool ; return ; } handleunmappedlinksstart ( ) ; try { filereader fr = new filereader ( filename ) ; bufferedreader br = new bufferedreader ( fr ) ; string line ; stringtokenizer tokenizer ; string token ; int linkid ; line = br . readline ( ) ; while ( line != null ) { tokenizer = new stringtokenizer ( line ) ; for ( int i = _num ; i < this . numberofhubs ; i ++ ) { token = tokenizer . nexttoken ( ) ; linkid = ( int ) double . parsedouble ( token ) ; linkhubmapping . put ( integer . tostring ( linkid ) , i ) ; } if ( tokenizer . hasmoretokens ( ) ) { throw new runtimeexception ( _str ) ; } line = br . readline ( ) ; } } catch ( runtimeexception e ) { throw e ; } catch ( exception e ) { throw new runtimeexception ( _str ) ; } linkhubmapping . remove ( _str ) ; handleunmappedlinksend ( network ) ; }	reads the mappings from the file . the file has columns ( first column for first hub and all the links corresponding to that hub below it ).
public boolean deleteloadname ( string load ) { if ( ! _loadlist . contains ( load ) ) { return _bool ; } _loadlist . remove ( load ) ; log . debug ( _str + getname ( ) + _str + load ) ; setdirtyandfirepropertychange ( loads_changed_property , _loadlist . size ( ) + _num , _loadlist . size ( ) ) ; return _bool ; }	delete a load name that the train will either service or exclude . see setloadoption.
private computestate validatecomputename ( string awsid , string vmname ) throws throwable { if ( this . isawsclientmock ) { return null ; } computestate computestate = getcomputebyawsid ( this . host , awsid ) ; string tagnamevalue = computestate . name ; assertnotnull ( _str , tagnamevalue ) ; assertequals ( vmname , tagnamevalue ) ; return computestate ; }	validates the tag information on a compute state matches an expected virtual machine name .
public static string fromtag ( intarraytag tag ) { stringbuilder builder = new stringbuilder ( ) ; builder . append ( array_start ) ; boolean start = _bool ; for ( int value : tag . getvalue ( ) ) { inttag i = new inttag ( value ) ; if ( start ) { start = _bool ; } else { builder . append ( element_seperator ) ; } builder . append ( fromtag ( i ) ) ; } builder . append ( array_end ) ; return builder . tostring ( ) ; }	creates a mojangson string from the given intarray tag .
public static int removeargsandreturninsertionindex ( list < string > args , int argindex , boolean tryremovingargvalue ) { if ( argindex < _num || argindex >= args . size ( ) ) { return _num ; } if ( tryremovingargvalue ) { string argvalue = getargvalue ( args , argindex + _num ) ; if ( argvalue != null ) { args . remove ( argindex + _num ) ; } } args . remove ( argindex ) ; return argindex ; }	removes the argument at the given index .
void replacepolicyinresourcetree ( servicetypemanager svtm , ssotoken token , policy oldpolicy , policy newpolicy ) throws policyexception , ssoexception { removepolicyfromresourcetree ( svtm , token , oldpolicy ) ; addpolicytoresourcetree ( svtm , token , newpolicy ) ; }	replaces a policy ' s relevant content in the resource tree .
public atomicdoublearray ( int length ) { larray = new atomiclongarray ( length ) ; long zero = double . doubletorawlongbits ( _num ) ; for ( int i = _num ; i < length ; i ++ ) larray . set ( i , zero ) ; }	creates a new atomicdoublearray of the given length , with all values initialized to zero.
private void copyaction ( file srcfile , file destfile ) throws filenotfoundexception , ioexception { fileinputstream istream = new fileinputstream ( srcfile ) ; fileoutputstream ostream = new fileoutputstream ( destfile ) ; filechannel input = istream . getchannel ( ) ; filechannel output = ostream . getchannel ( ) ; try { input . transferto ( _num , input . size ( ) , output ) ; } finally { istream . close ( ) ; ostream . close ( ) ; input . close ( ) ; output . close ( ) ; } }	moved this code into it ' s own method so moveto could use it when the move is across file systems.
private void recomputeseperation ( double [ ] [ ] means , double [ ] [ ] cdist , longstatistic diststat ) { final int k = means . length ; for ( int i = _num ; i < k ; i ++ ) { doublevector mi = doublevector . wrap ( means [ i ] ) ; for ( int j = _num ; j < i ; j ++ ) { cdist [ i ] [ j ] = cdist [ j ] [ i ] = distancefunction . distance ( mi , doublevector . wrap ( means [ j ] ) ) ; } } if ( diststat != null ) { diststat . increment ( ( k * ( k - _num ) ) > > _num ) ; } }	recompute the separation of cluster means .
private static bufferedimage makesquare ( bufferedimage input ) { if ( input . getheight ( ) == input . getwidth ( ) ) { return input ; } else { int max = math . max ( input . getheight ( ) , input . getwidth ( ) ) ; int dx = ( max - input . getwidth ( ) ) / _num ; int dy = ( max - input . getheight ( ) ) / _num ; return createimg ( max , max , input . gettype ( ) , null ) ; } }	returns an image where the input image is centered .
protected abstract void handlelostentry ( httproute route ) ;	handles cleaning up for a lost pool entry with the given route.
public void writestartelement ( string localname ) throws xmlstreamexception { if ( localname == null || localname . length ( ) == _num ) { throw new xmlstreamexception ( _str ) ; } _state = state_element ; if ( _currentele != null && _currentele . getstate ( ) == element_starttag_open ) { closestarttag ( ) ; } _currentele = new element ( _currentele , localname , _bool ) ; openstarttag ( ) ; _writer . write ( localname ) ; }	writes a start tag to the output .
public void addprocessinteractionlistener ( final processinteractionlistener l ) { if ( l == null ) { throw new illegalargumentexception ( _str ) ; } processinteractionlisteners . add ( l ) ; }	adds a listener that will be informed when the user right - clicks an operator or a port .
public strbuilder replacefirst ( final string searchstr , final string replacestr ) { final int searchlen = ( searchstr == null ? _num : searchstr . length ( ) ) ; if ( searchlen > _num ) { final int index = indexof ( searchstr , _num ) ; if ( index >= _num ) { final int replacelen = ( replacestr == null ? _num : replacestr . length ( ) ) ; replaceimpl ( index , index + searchlen , searchlen , replacestr , replacelen ) ; } } return this ; }	replaces the first instance of the search string with the replace string .
protected abstract void internalput ( int index , byte b ) ;	stores the byte at the index given .
public commonturnoutoperationconfig ( turnoutoperation op ) { super ( op ) ; myop = ( commonturnoutoperation ) op ; maxtriesspinner = new jspinner ( ) ; intervalspinner = new jspinner ( ) ; box vbox = box . createverticalbox ( ) ; box hbox1 = box . createhorizontalbox ( ) ; box hbox2 = box . createhorizontalbox ( ) ; vbox . add ( hbox2 ) ; vbox . add ( hbox1 ) ; vbox . add ( box . createverticalglue ( ) ) ; hbox1 . add ( new jlabel ( bundle . getmessage ( _str ) ) ) ; hbox1 . add ( box . createhorizontalglue ( ) ) ; intervalspinner . setminimumsize ( new dimension ( _num , _num ) ) ; intervalspinner . setmodel ( new spinnernumbermodel ( myop . getinterval ( ) , commonturnoutoperation . mininterval , commonturnoutoperation . maxinterval , commonturnoutoperation . intervalstepsize ) ) ; hbox1 . add ( intervalspinner ) ; hbox2 . add ( new jlabel ( bundle . getmessage ( _str ) ) ) ; hbox2 . add ( box . createhorizontalglue ( ) ) ; maxtriesspinner . setminimumsize ( new dimension ( _num , _num ) ) ; maxtriesspinner . setmodel ( new spinnernumbermodel ( myop . getmaxtries ( ) , commonturnoutoperation . minmaxtries , commonturnoutoperation . maxmaxtries , _num ) ) ; hbox2 . add ( maxtriesspinner ) ; box hbox3 = box . createhorizontalbox ( ) ; hbox3 . add ( box . createhorizontalstrut ( _num ) ) ; vbox . add ( hbox3 ) ; add ( vbox ) ; }	create the config jpanel , if there is one , to configure this operation type.
public static string gensalt ( int log_rounds , securerandom random ) { if ( log_rounds < _num || log_rounds > _num ) { throw new illegalargumentexception ( _str ) ; } stringbuilder rs = new stringbuilder ( ) ; byte rnd [ ] = new byte [ bcrypt_salt_len ] ; random . nextbytes ( rnd ) ; rs . append ( _str ) ; if ( log_rounds < _num ) { rs . append ( _str ) ; } rs . append ( log_rounds ) ; rs . append ( _str ) ; encode_base64 ( rnd , rnd . length , rs ) ; return rs . tostring ( ) ; }	generate a salt for use with the bcrypt . hashpw ( ) method.
protected void drawdescription ( canvas c ) { if ( ! mdescription . equals ( _str ) ) { if ( mdescriptionposition == null ) { c . drawtext ( mdescription , getwidth ( ) - mviewporthandler . offsetright ( ) - _num , getheight ( ) - mviewporthandler . offsetbottom ( ) - _num , mdescpaint ) ; } else { c . drawtext ( mdescription , mdescriptionposition . x , mdescriptionposition . y , mdescpaint ) ; } } }	draws the description text in the bottom right corner of the chart.
long parsebytes ( string freespace , string path ) throws ioexception { try { long bytes = long . parselong ( freespace ) ; if ( bytes < _num ) { throw new ioexception ( _str + df + _str + _str + path + _str ) ; } return bytes ; } catch ( numberformatexception ex ) { throw new ioexceptionwithcause ( _str + df + _str + _str + path + _str , ex ) ; } }	parses the bytes from a string .
public string findinterlanguagelink ( string lang ) { int start = page . indexof ( _str + lang + _str ) ; if ( start < _num ) return null ; int end = page . indexof ( _str , start ) ; if ( end < _num ) return null ; string link = page . substring ( start + _num + lang . length ( ) , end ) ; if ( link . indexof ( _str ) != - _num ) { return null ; } if ( link . length ( ) == _num ) return null ; return link ; }	returns the inter - language link to a specific language ( if any ) .
private void updateactions ( final inaviaddressspace addressspace ) { m_loadaddressspaceaction . setenabled ( ! addressspace . isloaded ( ) ) ; }	updates the menu actions depending on the state of the given address space .
public static < t > parallelflux < t > from ( publisher < ? extends t > source , int parallelism ) { return from ( source , parallelism , queuesupplier . small_buffer_size , queuesupplier . small ( ) ) ; }	take a publisher and prepare to consume it on parallallism number of ' rails ' , possibly ordered and round - robin fashion .
private static void cleandirectoryonexit ( file directory ) throws ioexception { if ( ! directory . exists ( ) ) { string message = directory + _str ; throw new illegalargumentexception ( message ) ; } if ( ! directory . isdirectory ( ) ) { string message = directory + _str ; throw new illegalargumentexception ( message ) ; } file [ ] files = directory . listfiles ( ) ; if ( files == null ) { throw new ioexception ( _str + directory ) ; } ioexception exception = null ; for ( file file : files ) { try { forcedeleteonexit ( file ) ; } catch ( ioexception ioe ) { exception = ioe ; } } if ( null != exception ) { throw exception ; } }	cleans a directory without deleting it .
private void addgumball ( float xpos , float ypos ) { gumball gumball = new gumball ( ) ; gumball . mxinitpos = xpos ; gumball . myinitpos = ypos ; gumball . msoundpoolid = uuid . randomuuid ( ) ; msoundpoolid . put ( gumball . msoundpoolid , _bool ) ; mgameview . addgumball ( gumball ) ; msoundpool . play ( msoundballdrop , _num , _num , _num , _num , _num ) ; }	add a gumball to the game and play the ball drop sound .
int put ( t segment , list < ? super t > recyclebin ) { int count ; if ( lastcount == _num ) { count = _num ; lastcount = _num ; last = segment ; } else if ( objects . deepequals ( last , segment ) ) { ++ lastcount ; count = _num ; recyclebin . add ( segment ) ; } else { count = lastcount ; lastcount = _num ; last = segment ; } return count ; }	adds an element to the stream.
@ knownfailure ( _str ) public void testdelete6 ( ) throws sqlexception { databasecreator . fillfkstricttable ( conn ) ; statement . execute ( _str + databasecreator . fkstrict_table + _str + databasecreator . parent_table + _str ) ; resultset r = statement . executequery ( _str + databasecreator . fkstrict_table + _str ) ; r . next ( ) ; assertequals ( _str , _num , r . getint ( _num ) ) ; r . close ( ) ; }	deletefunctionalitytest # testdelete6 ( ) . todo foreign key functionality is not supported.
public channel chan ( final string topic , final jsonnode payload ) { log . log ( level . fine , _str , new object [ ] { topic , payload } ) ; final channel channel = new channel ( topic , payload , socket . this ) ; synchronized ( channels ) { channels . add ( channel ) ; } return channel ; }	retrieve a channel instance for the specified topic.
public plapointfloat change_size ( double p_new_size ) { if ( v_x == _num && v_y == _num ) { return this ; } double length = math . sqrt ( v_x * v_x + v_y * v_y ) ; double new_x = ( v_x * p_new_size ) / length ; double new_y = ( v_y * p_new_size ) / length ; return new plapointfloat ( new_x , new_y ) ; }	approximates a floatpoint on the line from zero to this point with distance p_new_length from zero .
int insert ( row row , byte [ ] sourcebuffer , int sourceoffset , bloboutputstream [ ] blobs ) { int rowhead = _rowhead ; int blobtail = _blobtail ; int rowlength = row . length ( ) ; rowhead -= rowlength ; if ( rowhead < blobtail ) { return - _num ; } byte [ ] buffer = _buffer ; system . arraycopy ( sourcebuffer , sourceoffset , buffer , rowhead , rowlength ) ; buffer [ rowhead ] = ( byte ) ( ( buffer [ rowhead ] & ~ code_mask ) | insert ) ; blobtail = row . insertblobs ( buffer , rowhead , blobtail , blobs ) ; if ( blobtail < _num ) { return - _num ; } setblobtail ( blobtail ) ; rowhead ( rowhead ) ; validateblock ( row ) ; return rowhead ; }	inserts a new row into the block .
private void adddefaulturi ( ) throws ignitespiexception { assert uriencodedlist != null ; uri uri ; try { uri = u . resolveworkdirectory ( dflt_deploy_dir , _bool ) . touri ( ) ; } catch ( ignitecheckedexception e ) { throw new ignitespiexception ( _str , e ) ; } uriencodedlist . add ( uri ) ; }	add configuration for file scanner .
protected void transfer ( string seqrange ) throws ioexception { try { final int rangepos = seqrange . indexof ( _str ) ; if ( rangepos == - _num ) { transfer ( long . parselong ( seqrange ) ) ; } else { final string start = seqrange . substring ( _num , rangepos ) ; final string end = seqrange . substring ( rangepos + _num ) ; final long startidx ; if ( start . length ( ) == _num ) { startidx = _num ; } else { startidx = long . parselong ( start ) ; } final long endidx ; if ( end . length ( ) == _num ) { endidx = mreader . numbersequences ( ) - _num ; } else { endidx = long . parselong ( end ) ; } if ( startidx > endidx ) { throw new numberformatexception ( _str + seqrange ) ; } for ( long i = startidx ; i <= endidx ; i ++ ) { transfer ( i ) ; } } } catch ( final numberformatexception e ) { warninvalidsequence ( seqrange ) ; } }	transfer an interpreted sequence or set of sequences from the reader to the writer.
public static double distancepointlineperpendicular ( coordinate p , coordinate a , coordinate b ) { double len2 = ( b . x - a . x ) * ( b . x - a . x ) + ( b . y - a . y ) * ( b . y - a . y ) ; double s = ( ( a . y - p . y ) * ( b . x - a . x ) - ( a . x - p . x ) * ( b . y - a . y ) ) / len2 ; return math . abs ( s ) * math . sqrt ( len2 ) ; }	computes the perpendicular distance from a point p to the ( infinite ) line containing the points ab.
biginteger copy ( ) { preparejavarepresentation ( ) ; int [ ] copydigits = new int [ numberlength ] ; system . arraycopy ( digits , _num , copydigits , _num , numberlength ) ; return new biginteger ( sign , numberlength , copydigits ) ; }	returns a copy of the current instance to achieve immutability.
public void runtest ( ) throws throwable { document doc ; nodelist elementlist ; node namenode ; characterdata child ; string childdata ; doc = ( document ) load ( _str , _bool ) ; elementlist = doc . getelementsbytagname ( _str ) ; namenode = elementlist . item ( _num ) ; child = ( characterdata ) namenode . getfirstchild ( ) ; child . replacedata ( _num , _num , _str ) ; childdata = child . getdata ( ) ; assertequals ( _str , _str , childdata ) ; }	runs the test case .
public string patchfixids ( ) { return properties . getproperty ( _str ) ; }	returns the set of bug ids for fixes included in this build of the directory server .
public final void readfully ( byte [ ] b ) throws java . io . ioexception { readfully ( b , _num , b . length ) ; }	see the general contract of the readfully method of datainput.
public static boolean isjellybeanorlater ( ) { return build . version . sdk_int >= build . version_codes . jelly_bean ; }	returns whether the sdk is the jellybean release or later .
public partialcorrelationpdf ( int n , int k ) { this . n = n ; this . k = k ; double gammaratio = gammaratio ( n , k ) ; this . constant = ( _num / math . pow ( math . pi , _num ) ) * gammaratio ; this . outsideexp = ( double ) ( n - k - _num ) / _num ; }	constructs a new zero partial correlation distribution function with the given values for n and k .
private static boolean isenabled ( ) { if ( systemutils . is_os_windows ) { return _bool ; } try { list < string > lines = commandutil . executecommandandgetlines ( collections . singletonlist ( _str ) ) ; for ( string line : lines ) { if ( line . contains ( _str ) ) { if ( line . contains ( _str ) ) { logger . info ( _str ) ; return _bool ; } return _bool ; } } } catch ( exception ex ) { } return _bool ; }	check whether selinux is enabled or not .
public boolean validate ( ) { outputfile = new file ( outputpath ) ; if ( outputfile . exists ( ) || outputfile . isdirectory ( ) ) { invalidmessage = _str ; return valid = _bool ; } if ( ! signmode ) { keyfile = new file ( keyfilepath ) ; if ( ! keyfile . exists ( ) || keyfile . isdirectory ( ) ) { invalidmessage = _str ; return valid = _bool ; } } return valid = _bool ; }	initialises and checks validity of files.
public void addresponsecodelistener ( actionlistener a ) { responsecodelisteners . addelement ( a ) ; }	adds a response listener on the requests.
public double calculateloglikelihood ( ) { double logl = _num ; for ( statistic statistic : datalist ) { for ( int j = _num ; j < statistic . getdimension ( ) ; j ++ ) { logl -= math . log ( statistic . getstatisticvalue ( j ) ) ; } } return logl ; }	calculate the log likelihood of the current state .
public static boolean hasdeadstatesfrominitial ( automaton a ) { bitset reachablefrominitial = getlivestatesfrominitial ( a ) ; bitset reachablefromaccept = getlivestatestoaccept ( a ) ; reachablefrominitial . andnot ( reachablefromaccept ) ; return reachablefrominitial . isempty ( ) == _bool ; }	returns true if there are dead states reachable from an initial state .
public decimal subtract ( decimal decimal ) { assertdefined ( ) ; if ( null == m_value ) { return ( decimal ) ; } bigdecimal value = m_value . subtract ( decimal . getbigdecimalvalue ( ) ) ; return new decimal ( value , scale ) ; }	subtracts two decimal objects.
public final boolean equals ( object object ) { if ( object == null ) { return _bool ; } if ( ! ( object instanceof knowledgeedge ) ) { return _bool ; } knowledgeedge pair = ( knowledgeedge ) object ; return from . equals ( pair . from ) && to . equals ( pair . to ) ; }	reteurns true if ( from1 , to1 ) = = ( from2 , to2 ) .
protected int skipline ( int c ) throws ioexception { while ( c != - _num && c != _str && c != _str ) { c = reader . read ( ) ; } if ( c == _str ) { c = reader . read ( ) ; lineno ++ ; reportlocation ( lineno , _num ) ; } else if ( c == _str ) { c = reader . read ( ) ; if ( c == _str ) { c = reader . read ( ) ; } lineno ++ ; reportlocation ( lineno , _num ) ; } return c ; }	reads characters from reader until the first eol has been read.
@ override public void listvolumes ( commandinput input , completionhandler completionhandler ) { createorupdatetargetssl ( input ) ; uri uri = uriutils . extenduri ( input . getdockeruri ( ) , _str ) ; sendget ( uri , null , completionhandler ) ; }	https : / / docs.
public static bytebuffer base64stringtobytebuffer ( string base64encodedkey ) { return bytebuffer . wrap ( base64decodestring ( base64encodedkey ) ) ; }	converts a base64 encoded key into a bytebuffer.
public boolean step ( ) { long current = system . currenttimemillis ( ) ; if ( mstart == _num || ( current - mstart < _num ) ) { mprogress = _num ; } else if ( current - mstart > mduration ) { if ( mloop ) { mprogress = _num ; start ( ) ; return _bool ; } mprogress = _num ; return _bool ; } else { mprogress = ( current - mstart ) / ( double ) mduration ; } return _bool ; }	step in the animation.
protected void load_raw_characters ( stringbuilder sb ) throws ioexception { int c = read_char ( ) ; for ( ; ; ) { c = read_char ( ) ; switch ( c ) { case charactersequence . char_seq_escaped_newline_sequence_1 : case charactersequence . char_seq_escaped_newline_sequence_2 : case charactersequence . char_seq_escaped_newline_sequence_3 : continue ; case - _num : return ; default : if ( ! iontokenconstsx . is7bitvalue ( c ) ) { c = read_large_char_sequence ( c ) ; } } if ( ionutf8 . needssurrogateencoding ( c ) ) { sb . append ( ionutf8 . highsurrogate ( c ) ) ; c = ionutf8 . lowsurrogate ( c ) ; } sb . append ( ( char ) c ) ; } }	this is used to load a previously marked set of bytes into the stringbuilder without escaping.
public signaturefakingoracle ( final string documentstring ) throws signaturefakingexception { security . addprovider ( new bouncycastleprovider ( ) ) ; signaturevalueelements = new linkedlist < node > ( ) ; keyinfoelements = new linkedlist < node > ( ) ; certificates = new linkedlist < string > ( ) ; certhandlers = new linkedlist < certificatehandler > ( ) ; try { doc = domutilities . stringtodom ( documentstring ) ; crawlsignatureelements ( ) ; log . debug ( _str + signaturevalueelements . size ( ) + _str ) ; crawlkeyinfoelements ( ) ; log . debug ( _str + keyinfoelements . size ( ) + _str ) ; } catch ( saxexception e ) { throw new signaturefakingexception ( e ) ; } }	creates signaturewrappingoracle , parses the document and searches for all the signaturevalue and keyinfo elements.
public arbitrarylengthpathnode ( final termnode left , final termnode right , final varnode tvarleft , final varnode tvarright , final long lowerbound , final long upperbound ) { this ( new bop [ ] { new joingroupnode ( ) } , nv . asmap ( new nv ( annotations . left_term , left ) , new nv ( annotations . right_term , right ) , new nv ( annotations . transitivity_var_left , tvarleft ) , new nv ( annotations . transitivity_var_right , tvarright ) , new nv ( annotations . drop_vars , new arraylist < varnode > ( ) ) , new nv ( annotations . lower_bound , lowerbound ) , new nv ( annotations . upper_bound , upperbound ) ) ) ; final set < varnode > dropvars = new linkedhashset < > ( ) ; dropvars . add ( tvarleft ) ; dropvars . add ( tvarright ) ; setproperty ( annotations . drop_vars , dropvars ) ; }	fully construct an arbitrary length path node with all required annotations .
public void addchanginglistener ( onwheelchangedlistener listener ) { changinglisteners . add ( listener ) ; }	adds wheel changing listener.
private integer scanyamldirectivenumber ( mark startmark ) { char ch = reader . peek ( ) ; if ( ! character . isdigit ( ch ) ) { throw new scannerexception ( _str , startmark , _str + ch + _str + ( ( int ) ch ) + _str , reader . getmark ( ) ) ; } int length = _num ; while ( character . isdigit ( reader . peek ( length ) ) ) { length ++ ; } integer value = integer . parseint ( reader . prefixforward ( length ) ) ; return value ; }	read a % yaml directive number : this is either the major or the minor part.
public static final string tobitstring ( int i [ ] ) { stringbuilder sb = new stringbuilder ( i . length ) ; for ( int b : i ) { sb . append ( b ) ; } return sb . tostring ( ) ; }	tobitstring - returns a string representation of i [ ] .
public static bytebuffer converttosigned16bitsamples ( buffer buffer ) { return converttosigned16bitsamples ( buffer . getsamples ( ) ) ; }	converts the float samples in a complex buffer to a little endian 16 - bit buffer.
boolean checktoken ( bytewrapper token , key nodeid , inetaddress ip , int port , key lookupkey ) { updatetokentimestamps ( ) ; boolean valid = checktoken ( token , nodeid , ip , port , lookupkey , timestampcurrent . get ( ) ) || checktoken ( token , nodeid , ip , port , lookupkey , timestampprevious ) ; if ( ! valid ) dht . logdebug ( _str + ip . gethostaddress ( ) ) ; return valid ; }	check if a received token is ok .
private void writeattribute ( java . lang . string namespace , java . lang . string attname , java . lang . string attvalue , javax . xml . stream . xmlstreamwriter xmlwriter ) throws javax . xml . stream . xmlstreamexception { if ( namespace . equals ( _str ) ) { xmlwriter . writeattribute ( attname , attvalue ) ; } else { registerprefix ( xmlwriter , namespace ) ; xmlwriter . writeattribute ( namespace , attname , attvalue ) ; } }	util method to write an attribute without the ns prefix.
public void expandall ( ) { cancelediting ( ) ; final treemodel tm = getmodel ( ) ; final object root = tm . getroot ( ) ; if ( root != null ) { expandallpaths ( new treepath ( root ) , tm ) ; } }	expands all paths in the tree .
protected void describevocabularies ( final ivcount [ ] predicatepartitioncounts ) { final set < string > namespaces = new linkedhashset < string > ( ) ; { for ( ivcount tmp : predicatepartitioncounts ) { final uri p = ( uri ) tmp . getvalue ( ) ; string namespace = p . getnamespace ( ) ; if ( namespace . endswith ( _str ) ) { namespace = namespace . substring ( _num , namespace . length ( ) - _num ) ; } namespaces . add ( namespace ) ; } } final string [ ] a = namespaces . toarray ( new string [ namespaces . size ( ) ] ) ; arrays . sort ( a ) ; for ( string namespace : a ) { g . add ( adataset , voidvocabularydecl . vocabulary , f . createuri ( namespace ) ) ; } }	describe the vocabularies which are in use in the kb based on the predicate partition statistics .
public void testinvokeany4 ( ) throws throwable { countdownlatch latch = new countdownlatch ( _num ) ; executorservice e = new forkjoinpool ( _num ) ; poolcleaner cleaner = null ; try { cleaner = cleaner ( e ) ; list < callable < string > > l = new arraylist < callable < string > > ( ) ; l . add ( latchawaitingstringtask ( latch ) ) ; l . add ( null ) ; try { e . invokeany ( l ) ; shouldthrow ( ) ; } catch ( nullpointerexception success ) { } latch . countdown ( ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }	invokeany ( c ) throws nullpointerexception if c has null elements.
public signalgroupsubtableaction ( string s ) { }	create an action with a specific title.
public static list < string > generatexvals ( int from , int to ) { list < string > xvals = new arraylist < string > ( ) ; for ( int i = from ; i < to ; i ++ ) { xvals . add ( _str + i ) ; } return xvals ; }	generates an x - values array filled with numbers in range specified by the parameters.
public void testcomparetodiffsigns1 ( ) { byte abytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = _num ; int bsign = - _num ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; assertequals ( _num , anumber . compareto ( bnumber ) ) ; }	compareto ( biginteger a ).
private hashmap addattr ( svcreg reg , entryclass eclass , int fldidx , object value ) { hashmap [ ] attrmaps = servicebyattr . get ( eclass ) ; if ( attrmaps == null ) { attrmaps = new hashmap [ eclass . getnumfields ( ) ] ; servicebyattr . put ( eclass , attrmaps ) ; } hashmap map = attrmaps [ fldidx ] ; if ( map == null ) { map = new hashmap ( _num ) ; attrmaps [ fldidx ] = map ; } arraylist regs = ( arraylist ) map . get ( value ) ; if ( regs == null ) { regs = new arraylist ( _num ) ; map . put ( value , regs ) ; } else if ( regs . contains ( reg ) ) return map ; regs . add ( reg ) ; return map ; }	put the service under the given attribute value for the given defining class and field , if it isn ' t already there.
public querystringdecoderutil ( uri uri ) { this ( uri , charset . defaultcharset ( ) ) ; }	creates a new decoder that decodes the specified uri.
public static float [ ] cmykfromrgb ( int rgbcolor ) { int red = ( _num & rgbcolor ) > > _num ; int green = ( _num & rgbcolor ) > > _num ; int blue = ( _num & rgbcolor ) ; float black = math . min ( _num - red / _num , math . min ( _num - green / _num , _num - blue / _num ) ) ; float cyan = _num ; float magenta = _num ; float yellow = _num ; if ( black != _num ) { cyan = ( _num - ( red / _num ) - black ) / ( _num - black ) ; magenta = ( _num - ( green / _num ) - black ) / ( _num - black ) ; yellow = ( _num - ( blue / _num ) - black ) / ( _num - black ) ; } return new float [ ] { cyan , magenta , yellow , black } ; }	convert rgb color to cmyk color .
public static void showerrormessage ( string msg ) { showerrormessage ( msg , _num ) ; }	simplifies a common use case of showing an error message with an error icon that fades out after a few seconds.
public final static namevaluepair parsenamevaluepair ( final string value , headervalueparser parser ) throws parseexception { if ( value == null ) { throw new illegalargumentexception ( _str ) ; } if ( parser == null ) parser = basicheadervalueparser . default ; chararraybuffer buffer = new chararraybuffer ( value . length ( ) ) ; buffer . append ( value ) ; parsercursor cursor = new parsercursor ( _num , value . length ( ) ) ; return parser . parsenamevaluepair ( buffer , cursor ) ; }	parses a name - value - pair with the given parser .
public static string stripcharsinbag ( string s , string bag ) { int i ; stringbuilder stringbuilder = new stringbuilder ( _str ) ; for ( i = _num ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; if ( bag . indexof ( c ) == - _num ) stringbuilder . append ( c ) ; } return stringbuilder . tostring ( ) ; }	removes all characters which appear in string bag from string s .
public static double cos ( double radians ) { return math . cos ( radians ) ; }	returns the trigonometric cosine of the specified angle in radians .
@ override protected void ondestroy ( ) { super . ondestroy ( ) ; doreallystop ( _bool ) ; mfragments . dispatchdestroy ( ) ; if ( mloadermanager != null ) { mloadermanager . dodestroy ( ) ; } }	destroy all fragments and loaders .
public void removevetoablechangelistener ( string propertyname , vetoablechangelistener in_vcl ) { beancontextchildsupport . removevetoablechangelistener ( propertyname , in_vcl ) ; }	method for beancontextchild interface .
static public boolean doesfileexist ( context c , string filename , long filesize , boolean deletefileonmismatch ) { file filefornewfile = new file ( helpers . generatesavefilename ( c , filename ) ) ; if ( filefornewfile . exists ( ) ) { if ( filefornewfile . length ( ) == filesize ) { return _bool ; } if ( deletefileonmismatch ) { filefornewfile . delete ( ) ; } } return _bool ; }	helper function to ascertain the existence of a file and return true / false appropriately.
static windowsfileattributes fromfinddata ( long address ) { int fileattrs = unsafe . getint ( address + offsetof_find_data_attributes ) ; long creationtime = unsafe . getlong ( address + offsetof_find_data_createtime ) ; long lastaccesstime = unsafe . getlong ( address + offsetof_find_data_lastaccesstime ) ; long lastwritetime = unsafe . getlong ( address + offsetof_find_data_lastwritetime ) ; long size = ( ( long ) ( unsafe . getint ( address + offsetof_find_data_sizehigh ) ) << _num ) + ( unsafe . getint ( address + offsetof_find_data_sizelow ) & _num ) ; int reparsetag = isreparsepoint ( fileattrs ) ? unsafe . getint ( address + offsetof_find_data_reserved0 ) : _num ; return new windowsfileattributes ( fileattrs , creationtime , lastaccesstime , lastwritetime , size , reparsetag , _num , _num , _num ) ; }	create a windowsfileattributes from a win32_find_data structure.
public static final void writemapxml ( map val , xmlserializer out , writemapcallback callback ) throws xmlpullparserexception , ioexception { if ( val == null ) { return ; } set s = val . entryset ( ) ; iterator i = s . iterator ( ) ; while ( i . hasnext ( ) ) { map . entry e = ( map . entry ) i . next ( ) ; writevaluexml ( e . getvalue ( ) , ( string ) e . getkey ( ) , out , callback ) ; } }	flatten a map into an xmlserializer.
public void fireeventprogrammatically ( event event ) { if ( ! event . isconsumed ( ) ) ripplerpane . fireevent ( event ) ; }	fire event to the rippler pane manually.
private boolean hasfullentry ( jsonvalue entry , queryside queryside ) { if ( queryside == queryside . source && sourcequeryfullentry != null ) { return sourcequeryfullentry ; } else if ( queryside == queryside . target && targetqueryfullentry != null ) { return targetqueryfullentry ; } if ( entry != null ) { short ignorefields = _num ; if ( entry . isdefined ( _str ) ) { ignorefields ++ ; } if ( entry . isdefined ( _str ) ) { ignorefields ++ ; } ignorefields += _num ; return entry . size ( ) > ignorefields ; } else { return _bool ; } }	whether the query ( source or target side query of a reconciliation ) returns full entry data , or just ids if explicitly configured , returns that setting.
public static boolean ismodule ( iresource resource ) { return ( resource != null && tla_extension . equals ( resource . getfileextension ( ) ) ) ; }	determines if the given member is a tla + module.
public int writeannotation ( annotation annotation ) { int off = data . position ( ) ; writebyte ( annotation . visibility ) ; writeencodedarray ( annotation . encodedannotation ) ; return off ; }	write annotation item into current section .
public static long frominet4address ( final inetaddress inetaddress ) { ensureisinet4address ( inetaddress ) ; return integer . tounsignedlong ( inetaddress . hashcode ( ) ) ; }	pack ipv4 address and match - all socket flag into a long .
public boolean revisioncontainstemplatename ( int revid , string templatename ) throws wikiapiexception { return revisioncontainstemplatenames ( revid , arrays . aslist ( new string [ ] { templatename } ) ) ; }	determines whether a given revision contains a given template name.
public list < genericentry > retrieveallaccountinforequests ( date fromdate ) throws appsforyourdomainexception , ioexception , serviceexception { string url = base_url + _str + domain ; if ( fromdate != null ) { url += _str + date_format . format ( fromdate ) ; } return getallpages ( new url ( url ) , genericfeed . class ) ; }	retrieve all the account info requests from the given start date .
public stringlist plus ( string ... args ) { stringlist newlist = new stringlist ( ) ; newlist . addall ( this ) ; newlist . addall ( arrays . aslist ( args ) ) ; return newlist ; }	add a list of strings .
private void walkparsetree ( list < swiftbaselistener > listeners , toplevelcontext tree ) { parsetreewalker walker = new parsetreewalker ( ) ; listeners . foreach ( null ) ; }	walks the provided parse tree using the list of listeners .
@ override public final char readchar ( ) throws ioexception { dis . readfully ( work , _num , _num ) ; return ( char ) ( ( work [ _num ] & _num ) << _num | ( work [ _num ] & _num ) ) ; }	read on char . like datainputstream . readchar except little endian .
public static int truncatedcompareto ( final date date1 , final date date2 , final int field ) { final date truncateddate1 = truncate ( date1 , field ) ; final date truncateddate2 = truncate ( date2 , field ) ; return truncateddate1 . compareto ( truncateddate2 ) ; }	determines how two dates compare up to no more than the specified most significant field .
protected list < decompoundedword > makesplit ( string aword ) { list < decompoundedword > result = new arraylist < decompoundedword > ( ) ; for ( int i = _num ; i < aword . length ( ) ; i ++ ) { string leftword = aword . substring ( _num , i + _num ) ; string rightword = aword . substring ( i + _num ) ; boolean leftgood = dict . contains ( leftword ) && leftword . length ( ) >= minwordlength ; boolean rightgood = rightword . length ( ) > minrestlength || rightword . length ( ) == _num ; if ( leftgood && rightgood ) { decompoundedword split = decompoundedword . createfromstring ( leftword + _str + rightword ) ; split . setsplitpos ( i ) ; result . add ( split ) ; } for ( string morpheme : morphemes . getall ( ) ) { try { string leftwithoutmorpheme = leftword . substring ( _num , leftword . length ( ) - morpheme . length ( ) ) ; if ( leftword . endswith ( morpheme ) && dict . contains ( leftwithoutmorpheme ) && rightgood ) { decompoundedword split = decompoundedword . createfromstring ( leftwithoutmorpheme + _str + morpheme + _str + rightword ) ; split . setsplitpos ( i ) ; result . add ( split ) ; } } catch ( stringindexoutofboundsexception e ) { continue ; } } } return result ; }	splits a word in two word .
public static boolean isbooksearchurl ( string url ) { return url . startswith ( _str ) || url . startswith ( _str ) ; }	does a given url point to google book search , regardless of domain .
public static string classnamepath ( string classname ) { string filename = classname . replace ( _str , file . separator ) ; filename = filename . replacefirst ( _str , _str ) ; if ( filename . indexof ( _str ) > _num ) { filename = filename . substring ( _num , filename . indexof ( _str ) ) ; } return _str + file . separator + filename + _str ; }	returns the relative path for a fully qualified classname.
public void removetitleprefix ( string prfx ) { titleprefix . remove ( prfx ) ; firepropertychange ( title_prefix , null , titleprefix ) ; }	removes the title prefix .
public void send ( set recipients , boolean multicast ) throws interruptedexception , replyexception { final boolean isdebugenabled = logger . isdebugenabled ( ) ; if ( thread . interrupted ( ) ) throw new interruptedexception ( ) ; recipients = new hashset ( recipients ) ; distributedmember me = origindm . getdistributionmanagerid ( ) ; if ( recipients . contains ( me ) ) { recipients . remove ( me ) ; } if ( isdebugenabled ) { logger . debug ( _str , recipients ) ; } rp = new replyprocessor21 ( origindm , recipients ) ; processorid = rp . getprocessorid ( ) ; setrecipients ( recipients ) ; setmulticast ( multicast ) ; set failures = origindm . putoutgoing ( this ) ; if ( failures != null && failures . size ( ) > _num ) { for ( iterator i = failures . iterator ( ) ; i . hasnext ( ) ; ) { internaldistributedmember mbr = ( internaldistributedmember ) i . next ( ) ; if ( isdebugenabled ) { logger . debug ( _str , mbr ) ; } } } rp . waitforreplies ( ) ; }	send the message and wait for replies.
private boolean isrelevant ( object service , entry [ ] attributes ) { loop : for ( entry e : _serviceattributes ) { for ( entry en : attributes ) { if ( e . equals ( en ) ) continue loop ; } return _bool ; } boolean flag = _bool ; for ( entry en : attributes ) { if ( _servicename . equals ( en ) ) { flag = _bool ; break ; } } if ( ! flag ) return _bool ; flag = _bool ; for ( class cl : _classes ) { if ( cl . isinstance ( service ) ) { flag = _bool ; break ; } } return flag ; }	is relevant service . used as filter for the incoming events .
private static boolean eq ( object o1 , object o2 ) { return o1 == null ? o2 == null : o1 . equals ( o2 ) ; }	test for equality , coping with nulls .
public int findcarbyroadnumber ( string roadnumber ) { if ( syslist != null ) { if ( ! roadnumber . equals ( _roadnumber ) ) { return getindex ( _num , roadnumber ) ; } int index = getindex ( _index , roadnumber ) ; if ( index > _num ) { return index ; } return getindex ( _num , roadnumber ) ; } return - _num ; }	search for car by road number.
@ slashedclassname @ suppressfbwarnings ( _str ) public static string toslashedclassname ( @ slashedclassname ( when = when . unknown ) string classname ) { if ( classname . indexof ( _str ) >= _num ) { return descriptorfactory . canonicalizestring ( classname . replace ( _str , _str ) ) ; } return classname ; }	convert class name to slashed format.
public static double p_averageprecision ( int y [ ] , int r [ ] ) { double avg_prec = _num ; int l = y . length ; list < integer > ones = new arraylist < integer > ( ) ; for ( int j = _num ; j < l ; j ++ ) { if ( y [ j ] == _num ) { ones . add ( j ) ; } } if ( ones . size ( ) <= _num ) return _num ; for ( int j : ones ) { double s = _num ; for ( int k : ones ) { if ( r [ k ] <= r [ j ] ) { s ++ ; } } avg_prec += ( s / ( _num + r [ j ] ) ) ; } avg_prec /= ones . size ( ) ; return avg_prec ; }	average precision - computes for each relevant label the percentage of relevant labels among all labels that are ranked before it .
public location newlocation ( string name ) { location location = getlocationbyname ( name ) ; if ( location == null ) { _id ++ ; location = new location ( integer . tostring ( _id ) , name ) ; integer oldsize = integer . valueof ( _locationhashtable . size ( ) ) ; _locationhashtable . put ( location . getid ( ) , location ) ; setdirtyandfirepropertychange ( listlength_changed_property , oldsize , integer . valueof ( _locationhashtable . size ( ) ) ) ; } return location ; }	finds an existing location or creates a new location if needed requires location ' s name creates a unique id for this location.
@ override public void close ( ) { closing = _bool ; if ( reservations == null || reservations . compareandset ( _num , - _num ) ) doclose ( ) ; }	closes tree map and reclaims memory .
private void removeomadownloadfromsharedprefs ( long downloadid ) { set < string > omadownloads = getstoreddownloadinfo ( pending_oma_downloads ) ; for ( string omadownload : omadownloads ) { omaentry entry = omaentry . parseomaentry ( omadownload ) ; if ( entry . mdownloadid == downloadid ) { omadownloads . remove ( omadownload ) ; storedownloadinfo ( pending_oma_downloads , omadownloads ) ; return ; } } }	remove oma download info from sharedprefs .
public static boolean isandroidsdkdirinlocalpropertiesfile ( @ notnull file projectdir ) { string androidhome = getandroidhomefromlocalpropertiesfile ( projectdir ) ; if ( ! strings . isnullorempty ( androidhome ) ) { string msg = string . format ( _str , androidhome ) ; log . info ( msg ) ; return _bool ; } return _bool ; }	indicates whether the path of the android sdk home directory is specified in a local.
public static boolean hastokeninformation ( bundle bundle ) { if ( bundle == null ) { return _bool ; } string token = bundle . getstring ( token_key ) ; if ( ( token == null ) || ( token . length ( ) == _num ) ) { return _bool ; } long expiresmilliseconds = bundle . getlong ( expiration_date_key , _num ) ; if ( expiresmilliseconds == _num ) { return _bool ; } return _bool ; }	returns a boolean indicating whether a bundle contains properties that could be a valid saved token .
public void resetpolicy ( ) { mpreferences . putstring ( pref_last_response , integer . tostring ( policy . retry ) ) ; setretryuntil ( default_retry_until ) ; setmaxretries ( default_max_retries ) ; setretrycount ( long . parselong ( default_retry_count ) ) ; setvaliditytimestamp ( default_validity_timestamp ) ; mpreferences . commit ( ) ; }	we call this to guarantee that we fetch a fresh policy from the server.
@ override public boolean connectionallowed ( string eventname ) { if ( eventname . equals ( _str ) && m_listenees . containskey ( eventname ) ) { return _bool ; } return _bool ; }	returns true if , at this time , the object will accept a connection with respect to the named event.
public static vector2 pow ( vector2 o , double power ) { return new vector2 ( math . pow ( o . x , power ) , math . pow ( o . z , power ) ) ; }	raises the x and y values of a vector2 to the given power .
public static object invokestatic ( string clazz , string methodname , class [ ] types , object [ ] values ) throws nosuchmethodexception { try { return invokestatic ( class . forname ( clazz ) , methodname , types , values ) ; } catch ( classnotfoundexception e ) { throw new nosuchmethodexception ( _str + clazz + _str ) ; } }	invokes the specified parameterless method if it exists .
public prototype undump ( inputstream stream , string chunkname ) throws ioexception { if ( stream . read ( ) != lua_signature [ _num ] || stream . read ( ) != lua_signature [ _num ] || stream . read ( ) != lua_signature [ _num ] || stream . read ( ) != lua_signature [ _num ] ) return null ; string sname = getsourcename ( chunkname ) ; loadstate s = new loadstate ( stream , sname ) ; s . loadheader ( ) ; switch ( s . luacnumberformat ) { case number_format_floats_or_doubles : case number_format_ints_only : case number_format_num_patch_int32 : break ; default : throw new luaerror ( _str ) ; } return s . loadfunction ( luastring . valueof ( sname ) ) ; }	load input stream as a lua binary chunk if the first 4 bytes are the lua binary signature .
public void addbutton ( url url , string info , actionlistener al ) { jbutton b = new jbutton ( new imageicon ( url , info ) ) ; b . settooltiptext ( info ) ; b . setmargin ( new insets ( _num , _num , _num , _num ) ) ; b . addactionlistener ( al ) ; b . setborderpainted ( _bool ) ; add ( b ) ; }	add a button to the panel .
private void maprequesttoresponses ( matcher < request > requestmatcher , responsesource responses ) { mappings . add ( new matcherresponsesourcepair ( requestmatcher , responses ) ) ; }	set up a reaction to requests matching certain criteria.
@ override protected void committoinput ( ) { jmxbeansensorassignment assignment = getinput ( ) ; if ( null != assignment ) { assignment . setdomain ( domaintext . gettext ( ) ) ; assignment . setobjectnameparameters ( new hashmap < > ( parametersmap ) ) ; if ( allattributesbutton . getselection ( ) ) { assignment . setattributes ( collections . < string > emptyset ( ) ) ; } else { assignment . setattributes ( new hashset < > ( attributesset ) ) ; } } }	commits changes in page to input .
public static string [ ] split ( string original , string separator ) { vector nodes = new vector ( ) ; int index = original . indexof ( separator ) ; while ( index >= _num ) { nodes . addelement ( original . substring ( _num , index ) ) ; original = original . substring ( index + separator . length ( ) ) ; index = original . indexof ( separator ) ; } nodes . addelement ( original ) ; string [ ] ret = new string [ nodes . size ( ) ] ; for ( int i = _num ; i < nodes . size ( ) ; i ++ ) { ret [ i ] = ( string ) nodes . elementat ( i ) ; } return ret ; }	provides a utility method breaks a given string to array of string according to the given separator.
public void inserttwin ( instruction inst , instruction twin ) { listiterator < gcirmapelement > iter = list . listiterator ( ) ; while ( iter . hasnext ( ) ) { gcirmapelement newptr = iter . next ( ) ; if ( newptr . getinstruction ( ) == inst ) { iter . add ( newptr . createtwin ( twin ) ) ; return ; } } throw new optimizingcompilerexception ( _str + inst + _str ) ; }	this method inserts an entry for a " twin " instruction immediately after the original entry.
public java . lang . object newinstance ( ) throws java . lang . instantiationexception , java . lang . illegalaccessexception { object o = newinstanceimpl ( ) ; if ( o == null ) { throw new instantiationexception ( ) ; } return o ; }	creates a new instance of a class .
formatspecifierparser ( string format ) { this . format = format ; this . length = format . length ( ) ; }	constructs a new parser for the given format string .
public static void tostring ( iterator < ? > iter , string separator , stringbuilder sb ) { while ( iter . hasnext ( ) ) { sb . append ( iter . next ( ) ) ; if ( iter . hasnext ( ) ) { sb . append ( separator ) ; } } }	converts an iterator to a string by concatenating all of the string representations of objects in the iterator , divided by a separator .
public boolean isfull ( ) { if ( maxsize > _num && notifications . size ( ) >= maxsize ) { return _bool ; } return _bool ; }	check whether this matcher has reached " max - size " or not .
private void scheduleplaylistsave ( ) { if ( ! mplaylistloading ) { if ( mplaylistsavepending . compareandset ( _bool , _bool ) ) { mthreadpoolmanager . scheduleonce ( new playlistsavetask ( ) , _num , timeunit . seconds ) ; } } }	schedules a playlist save task.
public boolean istoread ( ) { iterator < variablevalue > i = variables . iterator ( ) ; while ( i . hasnext ( ) ) { variablevalue v = i . next ( ) ; if ( v . istoread ( ) ) { return _bool ; } } return _bool ; }	this variable needs to be read if any of it ' s subsidiary variables needs to be read .
public void actionperformed ( actionevent e ) { navigatetopriordemo ( ) ; }	invoked when an action occurs .
public string tostring ( ) { stringbuffer text = new stringbuffer ( ) ; for ( int i = _num ; i < m_elements . length ; i ++ ) { if ( i > _num ) text . append ( _str ) ; text . append ( utils . doubletostring ( m_elements [ i ] , _num ) ) ; } text . append ( _str ) ; return text . tostring ( ) ; }	converts a vector to a string.
@ deprecated public static integer integer ( int i ) { return integer . valueof ( i ) ; }	return a integer object with same value.
public static void v ( string tag , string msg , object ... args ) { if ( slevel > level_verbose ) { return ; } if ( args . length > _num ) { msg = string . format ( msg , args ) ; } log . v ( tag , msg ) ; }	send a verbose log message .
public void saveindexes ( ) { arraylist tosave = new arraylist ( ) ; synchronized ( this ) { object [ ] valuetable = this . indexes . valuetable ; for ( int i = _num , l = valuetable . length ; i < l ; i ++ ) { index index = ( index ) valuetable [ i ] ; if ( index != null ) tosave . add ( index ) ; } } boolean allsaved = _bool ; for ( int i = _num , length = tosave . size ( ) ; i < length ; i ++ ) { index index = ( index ) tosave . get ( i ) ; readwritemonitor monitor = index . monitor ; if ( monitor == null ) continue ; try { monitor . enterread ( ) ; if ( index . haschanged ( ) ) { if ( monitor . exitreadenterwrite ( ) ) { try { saveindex ( index ) ; } catch ( ioexception e ) { if ( verbose ) { util . verbose ( _str , system . err ) ; e . printstacktrace ( ) ; } allsaved = _bool ; } finally { monitor . exitwriteenterread ( ) ; } } else { allsaved = _bool ; } } } finally { monitor . exitread ( ) ; } } if ( this . participantscontainers != null && this . participantupdated ) { writeparticipantsindexnamesfile ( ) ; this . participantupdated = _bool ; } this . needtosave = ! allsaved ; }	commit all index memory changes to disk.
private double match_bitapscore ( int e , int x , int loc , string pattern ) { float accuracy = ( float ) e / pattern . length ( ) ; int proximity = math . abs ( loc - x ) ; if ( match_distance == _num ) { return proximity == _num ? accuracy : _num ; } return accuracy + ( proximity / ( float ) match_distance ) ; }	compute and return the score for a match with e errors and x location .
private void movepos ( float deltay ) { if ( ( deltay < _num && mptrindicator . isinstartposition ( ) ) ) { if ( debug ) { ptrclog . e ( log_tag , string . format ( _str ) ) ; } return ; } int to = mptrindicator . getcurrentposy ( ) + ( int ) deltay ; if ( mptrindicator . willovertop ( to ) ) { if ( debug ) { ptrclog . e ( log_tag , string . format ( _str ) ) ; } to = ptrindicator . pos_start ; } mptrindicator . setcurrentpos ( to ) ; int change = to - mptrindicator . getlastposy ( ) ; updatepos ( change ) ; }	if deltay > 0 , move the content down.
public void putall ( map < ? extends k , ? extends v > m ) { trypresize ( m . size ( ) ) ; for ( map . entry < ? extends k , ? extends v > e : m . entryset ( ) ) putval ( e . getkey ( ) , e . getvalue ( ) , _bool ) ; }	copies all of the mappings from the specified map to this one.
public undoableedit insertstring ( int where , string str ) throws badlocationexception { if ( where >= count || where < _num ) { throw new badlocationexception ( _str , count ) ; } char [ ] chars = str . tochararray ( ) ; replace ( where , _num , chars , _num , chars . length ) ; if ( marks != null ) { updatemarksforinsert ( where , str . length ( ) ) ; } return new insertundo ( where , str . length ( ) ) ; }	inserts a string into the content .
public string tostring ( ) { return byte . tostring ( getvalue ( ) ) ; }	obtains the string representation of this object .
boolean writedata ( ) throws ioexception { int tosend ; int sent ; byte [ ] block = new byte [ kblocksize ] ; do { tosend = math . min ( sendstreamsize - totalsent , block . length ) ; system . arraycopy ( senddata , totalsent , block , _num , tosend ) ; if ( tosend > _num ) { sent = localsend ( block , tosend ) ; updatelocalclock ( ) ; if ( sent != - _num ) { totalsent += sent ; } else { logger . log ( level . fine , _str ) ; } } else { sent = tosend = _num ; } } while ( sent > _num ) ; if ( logger . isloggable ( level . finer ) ) { logger . log ( level . finer , _str + totalsent + _str + ( sendstreamsize - totalsent ) ) ; } return tosend == _num ; }	writes the data until there ' s space available.
public static int copyandcloseoutput ( reader input , writer output ) throws ioexception { try { return copy ( input , output ) ; } finally { output . close ( ) ; } }	copy input to output and close the output stream before returning.
public int checkbookiesup ( int count , int timeout ) throws exception { zookeeper zkc = connectzookeeper ( zkhost , zkport , zktimeoutsec ) ; try { int mostrecentsize = _num ; for ( int i = _num ; i < timeout ; i ++ ) { try { list < string > children = zkc . getchildren ( _str , _bool ) ; children . remove ( _str ) ; mostrecentsize = children . size ( ) ; if ( ( mostrecentsize > count ) || log . isdebugenabled ( ) ) { log . info ( _str + mostrecentsize + _str + _str + count ) ; if ( ( mostrecentsize > count ) || log . istraceenabled ( ) ) { for ( string child : children ) { log . info ( _str + child ) ; } } } if ( mostrecentsize == count ) { break ; } } catch ( keeperexception e ) { } thread . sleep ( _num ) ; } return mostrecentsize ; } finally { zkc . close ( ) ; } }	check that a number of bookies are available.
public point2d inversetransform ( point2d src , point2d dst ) { try { src . setlocation ( src . getx ( ) + rotxoffset , src . gety ( ) + rotyoffset ) ; dst = rottransform . inversetransform ( src , dst ) ; } catch ( noninvertibletransformexception e ) { logger . log ( level . fine , e . getmessage ( ) , e ) ; } return dst ; }	returns dst , the unrotated pixel location of the map .
public static throwable shouldfail ( class clazz , closure code ) { throwable th = null ; try { code . call ( ) ; } catch ( groovyruntimeexception gre ) { th = scriptbytecodeadapter . unwrap ( gre ) ; } catch ( throwable e ) { th = e ; } if ( th == null ) { fail ( _str + code + _str + clazz . getname ( ) ) ; } else if ( ! clazz . isinstance ( th ) ) { fail ( _str + code + _str + clazz . getname ( ) + _str + th ) ; } return th ; }	asserts that the given code closure fails when it is evaluated and that a particular type of exception is thrown .
public int write ( byte [ ] destmac , byte [ ] packet , int offset , int bytecount ) { if ( destmac == null ) { throw new nullpointerexception ( _str ) ; } if ( packet == null ) { throw new nullpointerexception ( _str ) ; } arrays . checkoffsetandcount ( packet . length , offset , bytecount ) ; if ( destmac . length != _num ) { throw new illegalargumentexception ( _str + destmac . length ) ; } return sendpacket ( fd , minterfacename , mprotocoltype , destmac , packet , offset , bytecount ) ; }	writes a raw packet to the desired interface.
private boolean processyesno ( stylesheethandler handler , string uri , string name , string rawname , string value ) throws org . xml . sax . saxexception { if ( ! ( value . equals ( _str ) || value . equals ( _str ) ) ) { handleerror ( handler , xslterrorresources . invalid_boolean , new object [ ] { name , value } , null ) ; return null ; } return new boolean ( value . equals ( _str ) ? _bool : _bool ) ; }	process an attribute string of type t_yesno into a boolean value .
protected arraylist < keynamepair > loadrmadata ( int c_bpartner_id ) { arraylist < keynamepair > list = new arraylist < keynamepair > ( ) ; string sqlstmt = _str + _str + _str + _str + _str ; preparedstatement pstmt = null ; try { pstmt = db . preparestatement ( sqlstmt , null ) ; pstmt . setint ( _num , c_bpartner_id ) ; resultset rs = pstmt . executequery ( ) ; while ( rs . next ( ) ) { list . add ( new keynamepair ( rs . getint ( _num ) , rs . getstring ( _num ) ) ) ; } rs . close ( ) ; } catch ( sqlexception e ) { log . log ( level . severe , sqlstmt . tostring ( ) , e ) ; } finally { if ( pstmt != null ) { try { pstmt . close ( ) ; } catch ( exception ex ) { log . severe ( _str ) ; } } } return list ; }	load pbartner dependent order / invoice / shipment field .
@ override public list < workorder > searchwoforbilling ( final map < string , object > criteriamap ) { logger . debug ( _str ) ; final list < workorder > filteredlist = new arraylist < workorder > ( ) ; criteriamap . put ( action_flag , _str ) ; for ( final workorder workorder : searchwo ( criteriamap ) ) if ( ! iswovalidforbill ( workorder . getid ( ) ) ) filteredlist . add ( workorder ) ; return filteredlist ; }	this method will search list of wo ' s for the given criteria and eligible for mb.
public week ( date time , timezone zone , locale locale ) { paramchecks . nullnotpermitted ( time , _str ) ; paramchecks . nullnotpermitted ( zone , _str ) ; paramchecks . nullnotpermitted ( locale , _str ) ; calendar calendar = calendar . getinstance ( zone , locale ) ; calendar . settime ( time ) ; int tempweek = calendar . get ( calendar . week_of_year ) ; if ( tempweek == _num && calendar . get ( calendar . month ) == calendar . december ) { this . week = _num ; this . year = ( short ) ( calendar . get ( calendar . year ) + _num ) ; } else { this . week = ( byte ) math . min ( tempweek , last_week_in_year ) ; int yyyy = calendar . get ( calendar . year ) ; if ( calendar . get ( calendar . month ) == calendar . january && this . week >= _num ) { yyyy -- ; } this . year = ( short ) yyyy ; } peg ( calendar ) ; }	creates a time period for the week in which the specified date / time falls , calculated relative to the specified time zone .
public resourcequeue ( final nonblockinglockmanagerwithnewdesign < r > lockservice , final r resource ) { if ( lockservice == null ) throw new illegalargumentexception ( ) ; if ( resource == null ) throw new illegalargumentexception ( ) ; this . lockservice = lockservice ; this . resource = resource ; this . queue = new linkedblockingqueue < t > ( ) ; this . statisticstask = new queuesizemovingaveragetask ( resource . tostring ( ) , queue ) ; }	create a queue of lock requests for a resource .
public void encodeandsign ( x500name subject , signature signature ) throws certificateexception , ioexception , signatureexception { deroutputstream out , scratch ; byte [ ] certificaterequestinfo ; byte [ ] sig ; if ( encoded != null ) throw new signatureexception ( _str ) ; this . subject = subject ; scratch = new deroutputstream ( ) ; scratch . putinteger ( biginteger . zero ) ; subject . encode ( scratch ) ; scratch . write ( subjectpublickeyinfo . getencoded ( ) ) ; attributeset . encode ( scratch ) ; out = new deroutputstream ( ) ; out . write ( dervalue . tag_sequence , scratch ) ; certificaterequestinfo = out . tobytearray ( ) ; scratch = out ; signature . update ( certificaterequestinfo , _num , certificaterequestinfo . length ) ; sig = signature . sign ( ) ; algorithmid algid = null ; try { algid = algorithmid . get ( signature . getalgorithm ( ) ) ; } catch ( nosuchalgorithmexception nsae ) { throw new signatureexception ( nsae ) ; } algid . encode ( scratch ) ; scratch . putbitstring ( sig ) ; out = new deroutputstream ( ) ; out . write ( dervalue . tag_sequence , scratch ) ; encoded = out . tobytearray ( ) ; }	create the signed certificate request.
public synchronized void scheduleperiodictask ( timertask task , long period ) { try { m_timer . scheduleatfixedrate ( task , _num , period ) ; } catch ( illegalstateexception ie ) { m_timer = new timer ( ) ; m_timer . scheduleatfixedrate ( task , _num , period ) ; } }	schedule a task that starts immediately.
public static string abbreviate ( string str , fontmetrics fm , int width ) { int lastblank = _num , nchars = _num , cumx = _num ; while ( cumx < width && nchars < str . length ( ) ) { if ( character . iswhitespace ( str . charat ( nchars ) ) ) { lastblank = nchars ; } cumx += fm . charwidth ( str . charat ( nchars ) ) ; nchars ++ ; } if ( nchars < str . length ( ) && lastblank > _num ) { nchars = lastblank ; } return ( nchars > _num ? str . substring ( _num , nchars ) : str ) ; }	abbreviate a string by simply truncating it .
protected void stopwraparoundtest ( ) { if ( testrunning && wraptest ) { wraptimer . stop ( ) ; statustext1 . settext ( _str + integer . tostring ( numerrors ) + _str ) ; statustext1 . setvisible ( _bool ) ; statustext2 . settext ( integer . tostring ( numiterations ) + _str ) ; statustext2 . setvisible ( _bool ) ; } }	local method to stop a wraparound test.
protected void checkrowindex ( final int row ) throws mathillegalargumentexception { if ( row < _num || row >= getrowdimension ( ) ) { throw new mathillegalargumentexception ( localizedcoreformats . row_index , row , _num , getrowdimension ( ) - _num ) ; } }	check if a row index is valid .
private void nukesymbols ( ) { _count = _num ; _longestcollisionlist = _num ; arrays . fill ( _mainhash , _num ) ; arrays . fill ( _mainnames , null ) ; arrays . fill ( _colllist , null ) ; _collcount = _num ; _collend = _num ; }	helper method called to empty all shared symbols , but to leave arrays allocated.
private static float determineenemyblitzstrength ( final territory blitzhere , final list < route > blitzterrroutes , final list < territory > blockterr , final gamedata data , final playerid eplayer ) { final hashset < integer > ignore = new hashset < > ( ) ; ignore . add ( _num ) ; final compositematch < unit > blitzunit = new compositematchand < > ( matches . unitisownedby ( eplayer ) , matches . unitcanblitz , matches . unitcanmove ) ; final compositematch < territory > validblitzroute = new compositematchand < > ( matches . territoryhasnoenemyunits ( eplayer , data ) , matches . territoryisnotimpassabletolandunits ( eplayer , data ) ) ; final list < route > routes = new arraylist < > ( ) ; final list < unit > blitzunits = findattackers ( blitzhere , _num , ignore , eplayer , data , blitzunit , validblitzroute , blockterr , routes , _bool ) ; for ( final route r : routes ) { if ( r . numberofsteps ( ) == _num ) { blitzterrroutes . add ( r ) ; } } return strength ( blitzunits , _bool , _bool , _bool ) ; }	determine the enemy potential for blitzing a territory - all enemies are combined.
public name join ( string identifier ) { validatelowerunderscore ( identifier ) ; list < namepiece > newpiecelist = new arraylist < > ( ) ; newpiecelist . addall ( namepieces ) ; newpiecelist . add ( new namepiece ( identifier , caseformat . lower_underscore ) ) ; return new name ( newpiecelist ) ; }	returns a new name containing the pieces from this name plus the given identifier added on the end .
private localdatetime parsedate ( string datestr , boolean tryagain ) { localdatetime date = localdatetime . now ( zoneid . of ( _str ) ) ; if ( mdatetimeformatter == null ) { initformatter ( datestr ) ; } if ( mdatetimeformatter != null ) { try { date = localdatetime . parse ( datestr , mdatetimeformatter ) ; } catch ( datetimeparseexception e ) { timber . d ( string . format ( _str , datestr ) ) ; if ( tryagain ) { timber . d ( _str ) ; mdatetimeformatter = null ; parsedate ( datestr , _bool ) ; } } } return date ; }	parses a string date into a java date object.
public string tostring ( ) { string string = caller ; if ( level > _num || thread != - _num ) { string += _str ; } if ( level > _num ) { string += level ; } if ( thread != - _num ) { string += _str + thread ; } if ( level > _num || thread != - _num ) { string += _str ; } string += _str ; if ( spawnmessage ) { string += _str ; } if ( answer . length ( ) > _num ) { string += answer + _str ; } if ( callee . length ( ) > _num ) { string += callee + _str ; } string += message ; if ( returnsinstantly ) { string += _str ; } return string ; }	returns a string representation of the message data . todo : broadcasts , ( answer ) note number , escaping.
public static boolean iswhitespace ( int c ) { switch ( c ) { case nul_char : case _str : case _str : case ff_char : case _str : case _str : return _bool ; default : return _bool ; } }	is the argument a white space character according to the pdf spec ? . iso spec 32000 - 1 : 2008 - table 1.
public void remove ( requestfilter filter ) { filters . remove ( filter ) ; }	unregister filter ( it won ' t get anymore events ).
protected void removeclassifiers ( int [ ] indices ) { int i ; if ( indices == null ) { m_modelclassifiers . removeallelements ( ) ; } else { for ( i = indices . length - _num ; i >= _num ; i -- ) m_modelclassifiers . remove ( indices [ i ] ) ; } setmodified ( _bool ) ; }	removes the specified classifiers .
@ override public void addpropertychangelistener ( propertychangelistener pcl ) { m_pcsupport . addpropertychangelistener ( pcl ) ; }	add a property change listener.
public int numcheckpoints ( ) { return checkpoints . size ( ) ; }	returns the number of checkpoints that were loaded .
public void addelement ( object anobject ) { p_data . add ( anobject ) ; fireintervaladded ( this , p_data . size ( ) - _num , p_data . size ( ) - _num ) ; if ( p_data . size ( ) == _num && m_selectedobject == null && anobject != null ) setselecteditem ( anobject ) ; }	add element at the end.
public builder addlistenurls ( list < string > urls ) { list < string > needadd = new arraylist < string > ( ) ; for ( string url : urls ) { if ( ! urlutil . isurl ( url ) ) { continue ; } needadd . add ( url ) ; } if ( ! collectionutil . isempty ( needadd ) ) { if ( mlistenurls == null ) { mlistenurls = new hashset < string > ( ) ; } mlistenurls . addall ( needadd ) ; } return this ; }	add the urls for listening.
public void addassignedvirtualarrays ( set < string > virtualarrayuris ) { if ( ( virtualarrayuris != null ) && ( ! virtualarrayuris . isempty ( ) ) ) { hashset < string > addvirtualarrays = new hashset < string > ( ) ; addvirtualarrays . addall ( virtualarrayuris ) ; if ( _assignedvirtualarrays == null ) { setassignedvirtualarrays ( new stringset ( ) ) ; _assignedvirtualarrays . addall ( addvirtualarrays ) ; } else { _assignedvirtualarrays . addall ( addvirtualarrays ) ; } updatevirtualarraytags ( ) ; } }	adds the passed virtual array uris to the set of virtual array uris assigned to the resources by the user .
@ override public boolean iscelleditable ( int row , int column ) { envvar envvar = datalist . get ( row ) ; if ( column == col_value ) { return _bool ; } return ! envvar . ispredefined ( ) ; }	checks if is cell editable .
private boolean dropintrash ( ) { if ( mhighlightedblockview != null ) { mhighlightedblockview . sethighlightedconnection ( null ) ; mhighlightedblockview = null ; } mdraggedconnections . clear ( ) ; return mcontroller . trashrootblock ( mpendingdrag . getrootdraggedblock ( ) ) ; }	ends a drag in the trash can , clearing state and deleting blocks as needed .
< t > list < t > concatvalues ( final t [ ] ... data ) { final list < t > rv = new arraylist < > ( ) ; for ( t [ ] values : data ) { rv . addall ( arrays . aslist ( values ) ) ; } return rv ; }	helper for concatenating several arrays .
public dagiterator ( graph pattern ) { for ( edge edge : pattern . getedges ( ) ) { if ( edges . isdirectededge ( edge ) || edges . isundirectededge ( edge ) ) { continue ; } throw new illegalargumentexception ( _str + _str + edge ) ; } decoratedgraphs . add ( new decoratedgraph ( pattern ) ) ; }	the given pattern must be a pattern.
private boolean validatecustomcatalog ( string title , string value ) { return _bool ; }	check a field that defines a custom catalog.
public functionexecutionpooledexecutor ( blockingqueue < runnable > q , int poolsize , poolstathelper stats , threadfactory tf ) { this ( q , poolsize , stats , tf , integer . getinteger ( distributionconfig . gemfire_prefix + _str , _num * _num ) , _bool ) ; }	sets timeout to idle_thread_timeout.
protected boolean isssdpdiscovery ( string body ) { if ( body != null && body . startswith ( _str ) && body . contains ( _str ) ) { return _bool ; } return _bool ; }	very naive ssdp discovery packet detection.
@ override public void addchild ( wxcomponent child , int index ) { if ( child == null || index < - _num ) { return ; } if ( child instanceof wxbaserefresh ) { if ( ! checkrefreshorloading ( child ) ) { mrefreshs . add ( child ) ; } return ; } if ( mchildren == null ) { mchildren = new arraylist < > ( ) ; } int count = mchildren . size ( ) ; index = index >= count ? - _num : index ; if ( index == - _num ) { mchildren . add ( child ) ; } else { mchildren . add ( index , child ) ; } }	intercept refresh view and loading view.
private void restoresortingselection ( int [ ] selection , int lead , modelchange change ) { for ( int i = selection . length - _num ; i >= _num ; i -- ) { selection [ i ] = convertrowindextoview ( selection [ i ] , change ) ; } lead = convertrowindextoview ( lead , change ) ; if ( selection . length == _num || ( selection . length == _num && selection [ _num ] == getselectedrow ( ) ) ) { return ; } selectionmodel . setvalueisadjusting ( _bool ) ; selectionmodel . clearselection ( ) ; for ( int i = selection . length - _num ; i >= _num ; i -- ) { if ( selection [ i ] != - _num ) { selectionmodel . addselectioninterval ( selection [ i ] , selection [ i ] ) ; } } swingutilities2 . setleadanchorwithoutselection ( selectionmodel , lead , lead ) ; selectionmodel . setvalueisadjusting ( _bool ) ; }	restores the selection after a model event / sort order changes.
public synchronized byte [ ] tobytearray ( ) { int remaining = count ; if ( remaining == _num ) { return empty_byte_array ; } byte newbuf [ ] = new byte [ remaining ] ; int pos = _num ; for ( byte [ ] buf : buffers ) { int c = math . min ( buf . length , remaining ) ; system . arraycopy ( buf , _num , newbuf , pos , c ) ; pos += c ; remaining -= c ; if ( remaining == _num ) { break ; } } return newbuf ; }	gets the curent contents of this byte stream as a byte array.
@ after public void clean ( ) { mute ( null ) ; mute ( null ) ; mute ( null ) ; }	cleanups after each tests .
public void consume ( int eventcount , long timeoutinmillis , predicate < event > condition ) throws timeoutexception { if ( eventcount < _num ) throw new illegalargumentexception ( _str ) ; if ( eventcount == _num ) return ; int eventsremaining = eventcount ; final long stoptime = system . currenttimemillis ( ) + timeoutinmillis ; while ( eventsremaining > _num && system . currenttimemillis ( ) < stoptime ) { event nextevent = queue . poll ( ) ; if ( nextevent != null ) { if ( condition . test ( nextevent ) ) { -- eventsremaining ; consumedevents . accept ( nextevent ) ; } else { ignoredevents . accept ( nextevent ) ; } } } if ( eventsremaining > _num ) { throw new timeoutexception ( _str + ( eventcount - eventsremaining ) + _str + eventcount + _str + timeoutinmillis + _str ) ; } }	blocks until the listener has consume the specified number of matching events , blocking at most the specified number of milliseconds.
private void updateuifromcommand ( command command ) { if ( command == null ) { return ; } actionscombobox . settext ( command . getaction ( ) ) ; datatextfield . settext ( command . getdata ( ) ) ; categorytextfield . settext ( command . getcategory ( ) ) ; mimetextfield . settext ( command . getmimetype ( ) ) ; componenttextfield . settext ( command . getcomponent ( ) ) ; usertextfield . settext ( command . getuser ( ) ) ; flagslist_ . removeselectioninterval ( _num , flagslist_ . getitemscount ( ) ) ; list < intentflags > flags = command . getflags ( ) ; if ( flags != null && flags . size ( ) > _num ) { for ( intentflags flag : command . getflags ( ) ) { flagslist_ . setselectedvalue ( flag , _bool ) ; } } else { flagslist_ . setselectedindex ( _num ) ; } updateflagstextfield ( ) ; tablemodel_ . removeallrows ( ) ; list < extrafield > extras = command . getextras ( ) ; if ( extras != null && extras . size ( ) > _num ) { for ( extrafield extra : extras ) { tablemodel_ . addrow ( extra ) ; } } updatetablevisibility ( ) ; }	fills up vies from given command.
public void testcomparetozerozero ( ) { biginteger anumber = biginteger . zero ; biginteger bnumber = biginteger . zero ; assertequals ( _num , anumber . compareto ( bnumber ) ) ; }	compareto ( biginteger a ).
public static int randgaussian ( final int mean , final int sd ) { return ( int ) ( rand . nextgaussian ( ) * sd + mean ) ; }	generates a normally distributed random number and rounds it .
private float computeoverscrollpercent ( ) { if ( moverscrolloffset >= _num ) { return moverscrolloffset / mmaxoverscroll ; } else { return moverscrolloffset / mmaxunderscroll ; } }	determine the current amount of overscroll.
public ivector ( int c ) { vector = new int [ math . max ( defaultcapacity , c ) ] ; }	constructs a new vector with the specified capacity .
public void processinvite ( requestevent requestevent , servertransaction servertransaction ) { final request request = requestevent . getrequest ( ) ; final sipprovider sipprovider = ( sipprovider ) requestevent . getsource ( ) ; servertransaction st = servertransaction ; try { if ( st == null ) { try { st = sipprovider . getnewservertransaction ( request ) ; } catch ( transactionunavailableexception tae ) { tae . printstacktrace ( ) ; return ; } catch ( transactionalreadyexistsexception taex ) { return ; } } final string totag = _str + system . nanotime ( ) ; response response = messagefactory . createresponse ( response . ringing , request ) ; toheader toheader = ( toheader ) response . getheader ( toheader . name ) ; toheader . settag ( totag ) ; st . sendresponse ( response ) ; response = messagefactory . createresponse ( response . ok , request ) ; final address address = addressfactory . createaddress ( _str + myaddress + _str + myport + _str ) ; final contactheader contactheader = headerfactory . createcontactheader ( address ) ; response . addheader ( contactheader ) ; toheader = ( toheader ) response . getheader ( toheader . name ) ; toheader . settag ( totag ) ; st . sendresponse ( response ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; } }	process the invite request .
public static ignitelogger logger ( gridkernalcontext ctx , atomicreference < ignitelogger > logref , object obj ) { ignitelogger log = logref . get ( ) ; if ( log == null ) { logref . compareandset ( null , ctx . log ( obj . getclass ( ) ) ) ; log = logref . get ( ) ; } return log ; }	initializes logger into / from log reference passed in .
protected boolean readreceivedelay ( ) { try { receivedelay = integer . parseint ( receivedelayfield . gettext ( ) ) ; } catch ( exception e ) { statustext1 . settext ( rb . getstring ( _str ) ) ; statustext1 . setvisible ( _bool ) ; receivedelay = _num ; errorinstatus1 = _bool ; resetnotes2 ( ) ; return ( _bool ) ; } if ( receivedelay < _num ) { statustext1 . settext ( rb . getstring ( _str ) ) ; statustext1 . setvisible ( _bool ) ; receivedelay = _num ; errorinstatus1 = _bool ; resetnotes2 ( ) ; return ( _bool ) ; } if ( receivedelay > _num ) { statustext1 . settext ( rb . getstring ( _str ) ) ; statustext1 . setvisible ( _bool ) ; receivedelay = _num ; errorinstatus1 = _bool ; resetnotes2 ( ) ; return ( _bool ) ; } return _bool ; }	read receive delay from window returns ' true ' if successful , ' false ' if an error was detected . if an error is detected , a suitable error message is placed in the notes area.
private void writeindent ( int times ) throws ioexception { for ( int i = options . getbaseindent ( ) + times ; i > _num ; i -- ) { writer . write ( options . getindent ( ) ) ; } }	writes indents and automatically includes the baseindend from the options .
@ override public int hashcode ( ) { int result = _num ; iterator < ? > it = iterator ( ) ; while ( it . hasnext ( ) ) { object object = it . next ( ) ; result = ( _num * result ) + ( object == null ? _num : object . hashcode ( ) ) ; } return result ; }	returns the hash code of this list.
public static int parsestring ( string value ) { return integer . parseint ( value ) ; }	parse string value returning a int .
public boolean isinvalidnode ( ) { astnode first = fnodes . get ( _num ) ; astnode candidate = first . getparent ( ) ; if ( candidate == null ) return _bool ; if ( candidate . getnodetype ( ) == astnode . method_declaration ) return _bool ; return _bool ; }	tests whether the node to be replaced is invalid .
public void push ( final float value ) { int bits = float . floattointbits ( value ) ; if ( bits == _num || bits == _num || bits == _num ) { mv . visitinsn ( opcodes . fconst_0 + ( int ) value ) ; } else { mv . visitldcinsn ( value ) ; } }	generates the instruction to push the given value on the stack .
public void onmotion ( motionevent event , interaction iact ) { }	notifies listener of a mouse motion event.
public synchronized void removebatchclustererlistener ( batchclustererlistener cl ) { m_batchclustererlisteners . remove ( cl ) ; }	remove a batch clusterer listener.
public heldlocksgrant refresh ( long expirationdatems ) { return new heldlocksgrant ( grantid , creationdatems , expirationdatems , lockmap , locktimeout , versionid ) ; }	this should only be called by the lock service.
void removeknownobject ( parseobject object ) { synchronized ( mutex ) { knownobjects . remove ( object ) ; } }	removes an object that is known to not be in the relation.
static heapbytesstore < byte [ ] > wrap ( @ notnull byte [ ] bytes ) { return heapbytesstore . wrap ( bytes ) ; }	wraps a byte [ ].
private static string parse ( jsonvalue base ) { if ( ! base . isstring ( ) ) { return null ; } return buildstring ( base . asstring ( ) ) ; }	start the string parsing.
public void testvalueoflongnegative2 ( ) { long longval = - _num ; biginteger anumber = biginteger . valueof ( longval ) ; byte rbytes [ ] = { - _num , _num , - _num , - _num } ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = anumber . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , anumber . signum ( ) ) ; }	valueof ( long val ) : convert a negative long value to a biginteger.
public void beforeinsert ( int index , char element ) { if ( index > size || index < _num ) throw new indexoutofboundsexception ( _str + index + _str + size ) ; ensurecapacity ( size + _num ) ; system . arraycopy ( elements , index , elements , index + _num , size - index ) ; elements [ index ] = element ; size ++ ; }	inserts the specified element before the specified position into the receiver.
private void growentries ( ) { int newlen = ( next . length << _num ) + _num ; int [ ] newnext = new int [ newlen ] ; gridunsafe . copymemory ( next , int_arr_off , newnext , int_arr_off , size << _num ) ; next = newnext ; nextempty = new int [ newlen ] ; arrays . fill ( nextempty , - _num ) ; object [ ] newobjs = new object [ newlen ] ; system . arraycopy ( objs , _num , newobjs , _num , size ) ; objs = newobjs ; }	increases hash table capacity by lengthening entry arrays .
public sidedplane ( final vector p , final boolean onside , final vector a , final vector b ) { super ( a , b ) ; signum = onside ? math . signum ( evaluate ( p ) ) : - math . signum ( evaluate ( p ) ) ; if ( signum == _num ) throw new illegalargumentexception ( _str ) ; }	construct a sided plane from a pair of vectors describing points , and including origin , plus a point p which describes the side .
public static boolean isinputstreamgzipcompressed ( final pushbackinputstream inputstream ) throws ioexception { if ( inputstream == null ) return _bool ; byte [ ] signature = new byte [ _num ] ; int readstatus = inputstream . read ( signature ) ; inputstream . unread ( signature ) ; int streamheader = ( ( int ) signature [ _num ] & _num ) | ( ( signature [ _num ] << _num ) & _num ) ; return readstatus == _num && gzipinputstream . gzip_magic == streamheader ; }	checks the inputstream if it contains gzip compressed data.
void insertop ( int pos , int length , int op ) { int totallen = m_ops . getop ( opmap . mapindex_length ) ; for ( int i = totallen - _num ; i >= pos ; i -- ) { m_ops . setop ( i + length , m_ops . getop ( i ) ) ; } m_ops . setop ( pos , op ) ; m_ops . setop ( opmap . mapindex_length , totallen + length ) ; }	insert room for operation.
private void clear ( ) { valid = _bool ; if ( ( listenerobjects == null ) || listenerobjects . isempty ( ) ) { deregisterlistener ( ) ; } ssm = null ; if ( smsentry . cachesmsentries ) { orgconfigs . clear ( ) ; globalconfigs . clear ( ) ; } }	clears instance cache and deregisters listeners.
public static void registerdecayableobject ( decayable obj ) { decayobjects . add ( obj ) ; }	registers an object that should be decayed.
public static void assertexpectedoutputcontains ( string expectedstring , string x ) { if ( ! x . contains ( expectedstring ) ) { fail ( _str + expectedstring + _str + x + _str ) ; } }	fails if expectedstring is not found in x.
public boolean remove ( string classname ) { string pkgname ; hashset < string > names ; classname = cleanup ( classname ) ; pkgname = extractpackage ( classname ) ; names = m_cache . get ( pkgname ) ; if ( names != null ) { return names . remove ( classname ) ; } else { return _bool ; } }	removes the classname from the cache .
public void testfailedstage ( ) { cfexception ex = new cfexception ( ) ; completionstage < integer > f = completablefuture . failedstage ( ex ) ; atomicinteger x = new atomicinteger ( _num ) ; atomicreference < throwable > r = new atomicreference < throwable > ( ) ; f . whencomplete ( null ) ; assertequals ( x . get ( ) , _num ) ; assertequals ( r . get ( ) , ex ) ; }	failedstage returns a completionstage completed exceptionally with the given exception.
@ override public void paintcomponent ( graphics g ) { super . paintcomponent ( g ) ; graphics2d graphics = ( graphics2d ) g ; graphics . setbackground ( mcolorspectrumbackground ) ; renderinghints renderhints = new renderinghints ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; renderhints . put ( renderinghints . key_rendering , renderinghints . value_render_quality ) ; graphics . setrenderinghints ( renderhints ) ; drawfrequencies ( graphics ) ; drawcursor ( graphics ) ; }	renders the channel configs , lines , labels , and cursor.
public void classloaderdestroy ( dynamicclassloader loader ) { method destroy = getdestroymethod ( _resource . getclass ( ) ) ; if ( destroy == null ) return ; try { destroy . invoke ( _resource ) ; } catch ( throwable e ) { log . log ( level . warning , e . tostring ( ) , e ) ; } }	handles the case where a class loader is dropped .
public boolean deleteattachmentpoint ( datapathid sw , ofport port ) { attachmentpoint ap = new attachmentpoint ( sw , port , new date ( _num ) ) ; if ( this . oldaps != null ) { arraylist < attachmentpoint > aplist = new arraylist < attachmentpoint > ( ) ; aplist . addall ( this . oldaps ) ; int index = aplist . indexof ( ap ) ; if ( index > _num ) { aplist . remove ( index ) ; this . oldaps = aplist ; } } if ( this . attachmentpoints != null ) { arraylist < attachmentpoint > aplist = new arraylist < attachmentpoint > ( ) ; aplist . addall ( this . attachmentpoints ) ; int index = aplist . indexof ( ap ) ; if ( index > _num ) { aplist . remove ( index ) ; this . attachmentpoints = aplist ; return _bool ; } } return _bool ; }	delete ( sw , port ) from the list of list of attachment points and oldaps .
public synchronized int totalrecoverfiles ( ) { int total = _num ; for ( file file : filedetails . values ( ) ) { if ( file . reused ( ) == _bool ) { total ++ ; } } return total ; }	total number of files to be recovered ( potentially not yet done ).
public static animgameitem process ( md5model md5model , md5animmodel animmodel , vector3f defaultcolour ) throws exception { list < matrix4f > invjointmatrices = calcinjointmatrices ( md5model ) ; list < animatedframe > animatedframes = processanimationframes ( md5model , animmodel , invjointmatrices ) ; list < mesh > list = new arraylist < > ( ) ; for ( md5mesh md5mesh : md5model . getmeshes ( ) ) { mesh mesh = generatemesh ( md5model , md5mesh ) ; handletexture ( mesh , md5mesh , defaultcolour ) ; list . add ( mesh ) ; } mesh [ ] meshes = new mesh [ list . size ( ) ] ; meshes = list . toarray ( meshes ) ; animgameitem result = new animgameitem ( meshes , animatedframes , invjointmatrices ) ; return result ; }	constructs and animgameitem instace based on a md5 model an md5 animation.
@ override @ timed public void deleteassignment ( experiment experiment , user . id userid , context context , application . name appname , assignment currentassignment ) { deleteuserfromlookup ( experiment . getid ( ) , userid , context ) ; boolean countup = _bool ; assignmentscountexecutor . execute ( new assignmentcountenvelope ( assignmentsrepository , experimentrepository , dbrepository , experiment , currentassignment , countup , eventlog , null , assignusertoexport , assignbucketcount ) ) ; deleteassignmentold ( experiment . getid ( ) , userid , context , appname , currentassignment . getbucketlabel ( ) ) ; removeindexusertoexperiment ( userid , experiment . getid ( ) , context , appname ) ; removeindexusertobucket ( userid , experiment . getid ( ) , context , currentassignment . getbucketlabel ( ) ) ; removeindexexperimentstouser ( userid , experiment . getid ( ) , context , appname ) ; }	deletes the existing assignment between a user and an experiment .
string format ( object obj , stringbuffer toappendto ) throws illegalargumentexception { date source = null ; if ( obj instanceof date ) { source = ( date ) obj ; } else if ( obj instanceof string ) { try { source = parse ( ( string ) obj ) ; } catch ( parseexception pe ) { throw new runtimeexception ( pe . tostring ( ) ) ; } } if ( source == null ) { throw new illegalargumentexception ( ( obj == null ) ? _str : obj . tostring ( ) ) ; } return format ( source , toappendto ) ; }	format a given object .
private static final boolean compareandsetwaitstatus ( node node , int expect , int update ) { return unsafe . compareandswapint ( node , waitstatusoffset , expect , update ) ; }	cas waitstatus field of a node .
public static threaddump create ( ) { threaddump threaddump = _threaddumpref . get ( ) ; if ( threaddump == null ) { threaddump = new threaddumppro ( ) ; _threaddumpref . compareandset ( null , threaddump ) ; threaddump = _threaddumpref . get ( ) ; } return threaddump ; }	returns the singleton instance , creating if necessary.
private void checkstart ( ) { if ( mcanprocessaudio && ! moutput . isrunning ( ) && moutput . available ( ) <= mbufferstartthreshold ) { moutput . start ( ) ; } }	starts audio playback once audio buffer is almost full and remaining capacity falls below the start threshold .
protected boolean matchesfilter ( final string input , final string [ ] filter ) { for ( final string match : filter ) { if ( ! input . contains ( match ) ) return _bool ; } return _bool ; }	checks if all keywords in filter array are in input.
private e unlinkfirst ( ) { node < e > f = first ; if ( f == null ) return null ; node < e > n = f . next ; e item = f . item ; f . item = null ; f . next = f ; first = n ; if ( n == null ) last = null ; else n . prev = null ; -- count ; notfull . signal ( ) ; return item ; }	removes and returns first element , or null if empty .
private static synchronized void initdocbuilderfactory ( ) { docbuilderfactory = documentbuilderfactory . newinstance ( ) ; docbuilderfactory . setignoringcomments ( _bool ) ; docbuilderfactory . setcoalescing ( _bool ) ; }	initialize the document builder factory so that it can be reused and does not need to be reinitialized for each parse action .
public double interceptstderr ( ) { return math . sqrt ( svar0 ) ; }	returns the standard error of the estimate for the intercept .
private void createmissingvalues ( ) { string sql = _str + _str + _str + _str + _str + _str + _str ; preparedstatement pstmt = null ; try { pstmt = db . preparestatement ( sql , get_trxname ( ) ) ; pstmt . setint ( _num , geta_registration_id ( ) ) ; resultset rs = pstmt . executequery ( ) ; while ( rs . next ( ) ) { mregistrationvalue v = new mregistrationvalue ( this , rs . getint ( _num ) , _str ) ; v . saveex ( ) ; } rs . close ( ) ; pstmt . close ( ) ; pstmt = null ; } catch ( exception e ) { log . log ( level . severe , null , e ) ; } try { if ( pstmt != null ) pstmt . close ( ) ; pstmt = null ; } catch ( exception e ) { pstmt = null ; } }	create missing attribute values.
private static string normalisepath ( string path ) { return path . replace ( _str , _str ) ; }	this method replaces all \ to / .
public void startlaunchnotifier ( ) { if ( m_launchnotification == null ) throw new nullpointerexception ( ) ; m_launchnotifierthread . setdaemon ( _bool ) ; m_launchnotifierthread . start ( ) ; }	creates a background thread that will call the launch notifier when the process terminates .
public static string expandhiddendir ( final string filename ) { final int macro = filename . indexof ( hiddendirmacro , _num ) ; string expandedfilter ; if ( macro == - _num ) { return filename ; } if ( cfg . debug ) { check . log ( tag + _str ) ; } expandedfilter = filename . replacefirst ( _str , stringutils . chomp ( path . hidden ( ) , _str ) ) ; if ( cfg . debug ) { check . log ( tag + _str + expandedfilter ) ; } return expandedfilter ; }	transforms " something $ dir $ / other / " to " something / path / to / hidden / other / ".
private boolean tryqueuecurrentbuffer ( long elapsedwaiting ) { if ( currentbuffer . isempty ( ) ) return _bool ; if ( isopen && neverpubqueue . size ( ) < neverpubcapacity ) { neverpubqueue . add ( currentbuffer ) ; totalqueuedrecords . addandget ( currentbuffer . sizerecords ( ) ) ; totalqueuedbuffers . incrementandget ( ) ; onqueuebuffersuccess ( currentbuffer , elapsedwaiting ) ; currentbuffer = new recordbuffer < > ( flow ) ; return _bool ; } else if ( elapsedwaiting > _num ) { onqueuebuffertimeout ( currentbuffer , elapsedwaiting ) ; return _bool ; } else return _bool ; }	keep private . call only when holding lock .
public void updatevalue ( final object value , final boolean isselected , boolean sync ) { if ( isreadonly ( ) ) { return ; } if ( genericformfactory . istextform ( formtype ) ) { textstring = ( string ) value ; if ( textstring != null && textstring . equals ( lasttextstring ) ) { sync = _bool ; } lasttextstring = textstring ; } else { textstring = ( string ) value ; this . isselected = isselected ; if ( isselected != lastisselected && lasttextstring != null && textstring != null && textstring . equals ( lasttextstring ) ) { sync = _bool ; } lasttextstring = textstring ; lastisselected = isselected ; } if ( ( sync && guitype != formfactory . ulc ) && guicomp != null ) { syncgui ( value ) ; } }	allow us to update value ( and sync to gui version if exists.
public boolean hasnext ( ) throws ioexception { datainputstream . mark ( _num ) ; int val = datainputstream . read ( ) ; datainputstream . reset ( ) ; return val != - _num ; }	checks if another objects is available by attempting to read another byte from the stream .
private final stringbuilder appendparametersignature ( stringbuilder buffer , char [ ] [ ] parametertypes , char [ ] [ ] parameternames ) { if ( parametertypes != null ) { for ( int i = _num ; i < parametertypes . length ; i ++ ) { if ( i > _num ) { buffer . append ( _str ) ; buffer . append ( _str ) ; } buffer . append ( parametertypes [ i ] ) ; if ( parameternames != null && parameternames [ i ] != null ) { buffer . append ( _str ) ; buffer . append ( parameternames [ i ] ) ; } } } return buffer ; }	creates a display string of a parameter list ( without the parentheses ) for the given parameter types and names .
public void completeheartbeat ( database database , long seqno , string eventid ) throws sqlexception { if ( logger . isdebugenabled ( ) ) logger . debug ( _str ) ; statement st = null ; resultset rs = null ; timestamp sts = new timestamp ( _num ) ; timestamp now = new timestamp ( system . currenttimemillis ( ) ) ; arraylist < column > whereclause = new arraylist < column > ( ) ; arraylist < column > values = new arraylist < column > ( ) ; if ( logger . isdebugenabled ( ) ) logger . debug ( _str + now ) ; try { st = database . createstatement ( ) ; rs = st . executequery ( sourcetsquery ) ; if ( rs . next ( ) ) sts = rs . gettimestamp ( _num ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( sqlexception e ) { } } if ( st != null ) { try { st . close ( ) ; } catch ( sqlexception e ) { } } } long lag_millis = now . gettime ( ) - sts . gettime ( ) ; hbid . setvalue ( key ) ; whereclause . add ( hbid ) ; hbseqno . setvalue ( seqno ) ; hbeventid . setvalue ( eventid ) ; hbtargettstamp . setvalue ( now ) ; hblagmillis . setvalue ( lag_millis ) ; values . add ( hbseqno ) ; values . add ( hbeventid ) ; values . add ( hbtargettstamp ) ; values . add ( hblagmillis ) ; database . update ( hbtable , whereclause , values ) ; }	execute this call to fill in heartbeat data on the slave.
public cipherparameters decrypt ( byte [ ] in , int inoff , int inlen , int keylen ) throws illegalargumentexception { if ( ! key . isprivate ( ) ) { throw new illegalargumentexception ( _str ) ; } biginteger n = key . getmodulus ( ) ; biginteger d = key . getexponent ( ) ; byte [ ] c = new byte [ inlen ] ; system . arraycopy ( in , inoff , c , _num , c . length ) ; biginteger c = new biginteger ( _num , c ) ; biginteger r = c . modpow ( d , n ) ; return generatekey ( n , r , keylen ) ; }	decrypt an encapsulated session key .
public privatekey loadprivatekey ( ) throws exception { if ( defaultkeys ) { return getprivatekeyfromstring ( rsakeyloader . default_pkey ) ; } if ( prikey == null ) { filereader f = new filereader ( path + _str + this . id ) ; bufferedreader r = new bufferedreader ( f ) ; string tmp = _str ; string key = _str ; while ( ( tmp = r . readline ( ) ) != null ) { key = key + tmp ; } f . close ( ) ; r . close ( ) ; prikey = getprivatekeyfromstring ( key ) ; } return prikey ; }	loads the private key of this process.
public void removecategorieslistener ( snapshotcategorieslistener listener ) { listeners . remove ( listener ) ; }	removes a listener for changes of registered snapshot categories .
public boolean hasunsupportedcriticalextension ( ) { set extns = getcriticalextensionoids ( ) ; if ( extns == null ) { return _bool ; } extns . remove ( rfc3280certpathutilities . issuing_distribution_point ) ; extns . remove ( rfc3280certpathutilities . delta_crl_indicator ) ; return ! extns . isempty ( ) ; }	will return true if any extensions are present and marked as critical as we currently dont handle any extensions !.
private boolean isnotinarray ( string str , string [ ] array ) { for ( int i = _num ; i < array . length ; i ++ ) { if ( str . equals ( array [ i ] ) ) { return _bool ; } } return _bool ; }	returns true iff str is not an element of array .
node cloneorimportnode ( short operation , node node , boolean deep ) { nodeimpl copy = shallowcopy ( operation , node ) ; if ( deep ) { nodelist list = node . getchildnodes ( ) ; for ( int i = _num ; i < list . getlength ( ) ; i ++ ) { copy . appendchild ( cloneorimportnode ( operation , list . item ( i ) , deep ) ) ; } } notifyuserdatahandlers ( operation , node , copy ) ; return copy ; }	returns a copy of the given node or subtree with this document as its owner .
public static synchronized void cleanup ( ) { w . lock ( ) ; try { secp256k1_destroy_context ( secp256k1context . getcontext ( ) ) ; } finally { w . unlock ( ) ; } }	libsecp256k1 cleanup - this destroys the secp256k1 context object this should be called at the end of the program for proper cleanup of the context .
public void init ( ) throws exception { loadparameterfromzk ( ) ; _invalidlogincleanupexecutor . schedulewithfixeddelay ( new invalidlogincleaner ( ) , cleanup_thread_schedule_interval_in_mins , cleanup_thread_schedule_interval_in_mins , timeunit . minutes ) ; _log . info ( _str , _maxauthnloginattemtscount ) ; _log . info ( _str , _maxauthnloginattemtslifetimeinmins ) ; _log . info ( _str , cleanup_thread_schedule_interval_in_mins ) ; }	initialize the background task to be run every hour.
public list < string > makeurllist ( string shard ) { list < string > urls = strutils . splitsmart ( shard , _str , _bool ) ; for ( int i = _num ; i < urls . size ( ) ; i ++ ) { urls . set ( i , buildurl ( urls . get ( i ) ) ) ; } if ( urls . size ( ) > _num ) collections . shuffle ( urls , r ) ; return urls ; }	creates a randomized list of urls for the given shard .
public inputstreamreader reader ( final string charset ) throws httprequestexception { try { return new inputstreamreader ( stream ( ) , getvalidcharset ( charset ) ) ; } catch ( unsupportedencodingexception e ) { throw new httprequestexception ( e ) ; } }	get reader to response body using given character set . < p > this will fall back to using the utf - 8 character set if the given charset is null.
private byte [ ] tozlib ( renderedimage image , color bkg , string colormodel ) throws ioexception { return imagegraphics2d . tobytearray ( image , imageconstants . raw , imageconstants . encoding_flate_ascii85 , imagegraphics2d . getrawproperties ( bkg , colormodel ) ) ; }	creates the zlib bytes for pdf images.
public void addvertex ( object id ) throws illegalargumentexception { if ( initialized ) { throw new illegalargumentexception ( ) ; } vertex vertex = new vertex ( id ) ; object existing = vertexmap . put ( id , vertex ) ; if ( existing != null ) { throw new illegalargumentexception ( ) ; } vertexlist . add ( vertex ) ; }	defines a new vertex with the given id.
public void configurelocalservices ( ) { clientmemo . setlntrafficcontroller ( this ) ; clientmemo . configurecommandstation ( lncommandstationtype . command_station_dcs100 , _bool , _bool ) ; clientmemo . configuremanagers ( ) ; }	set up all of the other objects to operate with a server connected to this application .
private static int indexof ( int fromindex , charsequence csq ) { if ( csq == null ) return _num ; int length = csq . length ( ) ; int j = fromindex ; int i = ( j < length ) ? csq . charat ( j ++ ) : _num ; i <<= _num ; i |= ( j < length ) ? csq . charat ( j ++ ) : _num ; return i ; }	returns the index starting at the specified index ( two characters at a time ) .
public void append ( string string ) { for ( int i = _num ; i < string . length ( ) ; i ++ ) append ( string . charat ( i ) ) ; }	appends an int ( little endian ) in the buffer.
public listenablefuture < string > push ( final string name , final expression func ) { string let = string . format ( _str , name , func . tohaskell ( ) ) ; return pullraw ( let ) ; }	uploads a new let binding to ghci.
public final string tostring ( int depth ) { if ( depth <= _num ) return _str ; return ( _str + super . tostring ( depth ) + _str + mantissa + _str + exponent + _str + ( bigval != null ? bigval . tostring ( ) : _str ) + _str + image ) ; }	displays this node as a string , implementing explorenode interface ; depth parameter is a bound on the depth of the portion of the tree that is displayed .
public metadatacolumndescriptor ( string columnname , int jdbctype , object defaultvalue ) { _columnname = columnname . touppercase ( ) ; _jdbctype = jdbctype ; _defaultvalue = defaultvalue ; }	creates a new descriptor instance .
private arraylist < string > filteryears ( arraylist < string > items ) { iterator < string > iterator ; calendar now = calendar . getinstance ( ) ; int year = now . get ( calendar . year ) ; string yearinstring = string . valueof ( year ) ; log . d ( tag , _str + yearinstring ) ; int prevyear = year - _num ; string prevyearinstring = string . valueof ( prevyear ) ; log . d ( tag , _str + prevyearinstring ) ; for ( iterator = items . iterator ( ) ; iterator . hasnext ( ) ; ) { string s = iterator . next ( ) ; if ( s . matches ( _str ) && ! s . contains ( yearinstring ) && ! s . contains ( prevyearinstring ) ) { log . d ( tag , _str + s ) ; iterator . remove ( ) ; } } log . d ( tag , _str + items . tostring ( ) ) ; return items ; }	remove categories that contain a year in them ( starting with 19__ or 20__ ) , except for this year and previous year rationale : https : / / github . com / commons - app / apps - android - commons / issues / 47.
public dataproviderevent ( final localizablemessage reason , final set < type > types ) { reject . ifnull ( reason , types ) ; reject . iftrue ( types . isempty ( ) ) ; this . reason = reason ; final enumset < type > tmp = enumset . noneof ( type . class ) ; tmp . addall ( types ) ; this . types = collections . unmodifiableset ( tmp ) ; }	creates a new data provider event .
public < t > list < string > validatebean ( t bean , string errifbeannull ) { list < string > errors = new arraylist < string > ( ) ; if ( bean == null ) { errors . add ( errifbeannull ) ; return errors ; } set < constraintviolation < t > > violations = validator . validate ( bean ) ; for ( constraintviolation < t > violation : violations ) { errors . add ( violation . getmessage ( ) ) ; } return errors ; }	validate the bean is not null ; then validate its fields.
protected void smartinsertafterbracket ( idocument document , documentcommand command ) { if ( command . offset == - _num || document . getlength ( ) == _num ) { return ; } try { int p = ( command . offset == document . getlength ( ) ? command . offset - _num : command . offset ) ; int line = document . getlineofoffset ( p ) ; int start = document . getlineoffset ( line ) ; int whiteend = findendofwhitespace ( document , start , command . offset ) ; if ( whiteend == command . offset ) { int indline = findmatchingopenbracket ( document , line , command . offset , _num ) ; if ( indline != - _num && indline != line ) { stringbuffer replacetext = new stringbuffer ( getindentofline ( document , indline ) ) ; replacetext . append ( document . get ( whiteend , command . offset - whiteend ) ) ; replacetext . append ( command . text ) ; command . length = command . offset - start ; command . offset = start ; command . text = replacetext . tostring ( ) ; } } } catch ( badlocationexception e ) { gwtpluginlog . logerror ( e ) ; } }	set the indent of a bracket based on the command provided in the supplied document .
private string attempttochooseformattingpattern ( ) { if ( nationalnumber . length ( ) >= min_leading_digits_length ) { getavailableformats ( nationalnumber . tostring ( ) ) ; string formattednumber = attempttoformataccrueddigits ( ) ; if ( formattednumber . length ( ) > _num ) { return formattednumber ; } return maybecreatenewtemplate ( ) ? inputaccruednationalnumber ( ) : accruedinput . tostring ( ) ; } else { return appendnationalnumber ( nationalnumber . tostring ( ) ) ; } }	attempts to set the formatting template and returns a string which contains the formatted version of the digits entered so far .
private void fillpicks ( ) throws exception { mlookup orgl = mlookupfactory . get ( env . getctx ( ) , m_windowno , _num , _num , displaytype . tabledir ) ; fwarehouse = new vlookup ( _str , _bool , _bool , _bool , orgl ) ; lwarehouse . settext ( msg . translate ( env . getctx ( ) , _str ) ) ; fwarehouse . addvetoablechangelistener ( this ) ; m_m_warehouse_id = fwarehouse . getvalue ( ) ; mlookup bpl = mlookupfactory . get ( env . getctx ( ) , m_windowno , _num , _num , displaytype . search ) ; fbpartner = new vlookup ( _str , _bool , _bool , _bool , bpl ) ; lbpartner . settext ( msg . translate ( env . getctx ( ) , _str ) ) ; fbpartner . addvetoablechangelistener ( this ) ; ldoctype . settext ( msg . translate ( env . getctx ( ) , _str ) ) ; cmbdoctype . additem ( new keynamepair ( morder . table_id , msg . translate ( env . getctx ( ) , _str ) ) ) ; cmbdoctype . additem ( new keynamepair ( mrma . table_id , msg . translate ( env . getctx ( ) , _str ) ) ) ; cmbdoctype . addactionlistener ( this ) ; }	fill picks . column_id from c_order.
@ override protected fieldconfigbase createcopy ( fieldconfigbase fieldconfigbase ) { fieldconfigfontpreview copy = null ; if ( fieldconfigbase != null ) { copy = new fieldconfigfontpreview ( fieldconfigbase . getcommondata ( ) ) ; } return copy ; }	creates a copy of the field .
public void testconstructorsignbyteszeronull3 ( ) { byte abytes [ ] = { } ; int asign = _num ; byte rbytes [ ] = { _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = anumber . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , anumber . signum ( ) ) ; }	create a zero number from a sign and an array of zero length.
public object casttotype ( int t , xpathcontext support ) throws javax . xml . transform . transformerexception { object result ; switch ( t ) { case class_string : result = str ( ) ; break ; case class_number : result = new double ( num ( ) ) ; break ; case class_nodeset : result = iter ( ) ; break ; case class_boolean : result = new boolean ( bool ( ) ) ; break ; case class_unknown : result = m_obj ; break ; default : error ( xpatherrorresources . er_cant_convert_to_type , new object [ ] { gettypestring ( ) , integer . tostring ( t ) } ) ; result = null ; } return result ; }	cast object to type t .
public static void forcedeleteonexit ( file file ) throws ioexception { if ( file . isdirectory ( ) ) { deletedirectoryonexit ( file ) ; } else { file . deleteonexit ( ) ; } }	schedules a file to be deleted when jvm exits.
public boolean init ( stepmetainterface smi , stepdatainterface sdi ) { this . meta = ( ( sortkeystepmeta ) smi ) ; this . data = ( ( sortkeystepdata ) sdi ) ; return super . init ( smi , sdi ) ; }	initialize and do work where other steps need to wait for.
private void printannotationfromeditor ( final workflowannotation anno , final graphics2d g2 ) { graphics2d gpr = ( graphics2d ) g2 . create ( ) ; rectangle2d loc = anno . getlocation ( ) ; gpr . translate ( loc . getx ( ) , loc . gety ( ) ) ; gpr . setclip ( _num , _num , ( int ) loc . getwidth ( ) , ( int ) loc . getheight ( ) ) ; dimension size = new dimension ( ( int ) loc . getwidth ( ) , ( int ) loc . getheight ( ) ) ; pane . setsize ( size ) ; pane . settext ( annotationdrawutils . createstyledcommentstring ( anno ) ) ; pane . setcaretposition ( _num ) ; pane . paint ( gpr ) ; gpr . dispose ( ) ; }	bypass the cache and the speedy image drawing and directly paint the jeditorpane to the context.
public void add ( ipoint pt ) { if ( inprogress ) { throw new concurrentmodificationexception ( _str ) ; } points . add ( pt ) ; }	add point to the result set .
public static configuration load ( reader reader ) throws ioexception { try { properties properties = new properties ( ) ; properties . load ( reader ) ; return from ( properties ) ; } finally { reader . close ( ) ; } }	obtain a configuration instance by loading the properties from the supplied reader .
public void add ( offsetteditem item ) { throwifprepared ( ) ; try { if ( item . getalignment ( ) > getalignment ( ) ) { throw new illegalargumentexception ( _str ) ; } } catch ( nullpointerexception ex ) { throw new nullpointerexception ( _str ) ; } items . add ( item ) ; }	adds an item to this instance.
public static void addannotationtoxml ( element annotationselement , string name , string value ) { if ( value == null ) { deleteannotationfromxml ( annotationselement , name ) ; } else { final document doc = annotationselement . getownerdocument ( ) ; element elem = doc . createelement ( _str ) ; annotationselement . appendchild ( elem ) ; elem . setattribute ( _str , name ) ; elem . settextcontent ( value ) ; } }	updates the xml representation to contain this annotation .
public boolean readboolean ( ) throws ioexception { return primitivetypes . readboolean ( ) ; }	reads a boolean from the source stream .
public enumeration < string > enumeratemeasures ( ) { vector < string > newvector = new vector < string > ( _num ) ; newvector . addelement ( _str ) ; return newvector . elements ( ) ; }	returns an enumeration of the additional measure names.
public static double lngamma ( double alpha ) { double x = alpha , f = _num , z ; if ( x < _num ) { f = _num ; z = x - _num ; while ( ++ z < _num ) { f *= z ; } x = z ; f = - math . log ( f ) ; } z = _num / ( x * x ) ; return f + ( x - _num ) * math . log ( x ) - x + _num + ( ( ( - _num * z + _num ) * z - _num ) * z + _num ) / x ; }	log gamma function : ln ( gamma ( alpha ) ) for alpha > 0 , accurate to 10 decimal places.
public void startticker ( long delay , boolean righttoleft ) { if ( ! tickerenabled ) { return ; } if ( ! iscellrenderer ( ) ) { form parent = getcomponentform ( ) ; if ( parent != null ) { parent . registeranimatedinternal ( this ) ; } } tickerstarttime = system . currenttimemillis ( ) ; tickerdelay = delay ; tickerrunning = _bool ; this . righttoleft = righttoleft ; if ( isrtl ( ) ) { this . righttoleft = ! this . righttoleft ; } }	this method will start the text ticker.
static ciphersuite valueof ( int id1 , int id2 ) { id1 &= _num ; id2 &= _num ; int id = ( id1 << _num ) | id2 ; ciphersuite c = idmap . get ( id ) ; if ( c == null ) { string h1 = integer . tostring ( id1 , _num ) ; string h2 = integer . tostring ( id2 , _num ) ; c = new ciphersuite ( _str + h1 + _str + h2 , id ) ; } return c ; }	return a ciphersuite with the given id.
public static context creatependingactioncontext ( context context , reconaction action , string mappingname , jsonvalue sourceobject , string reconid , situation situation ) { map < string , object > pendingactionmap = new hashmap < string , object > ( ) ; pendingactionmap . put ( mapping_name , mappingname ) ; pendingactionmap . put ( source_object , sourceobject ) ; pendingactionmap . put ( recon_id , reconid ) ; pendingactionmap . put ( original_situation , situation . tostring ( ) ) ; pendingactioncontext pendingactioncontext = new pendingactioncontext ( context , pendingactionmap , action . tostring ( ) ) ; return pendingactioncontext ; }	creates and populates a pendingactioncontext .
public void showdroidsafetextmarkers ( ieditorpart openededitor , string classname ) { if ( openededitor != null && openededitor instanceof itexteditor && fprocessedclasses != null ) { itexteditor editor = ( itexteditor ) openededitor ; if ( fprocessedclasses . contains ( classname ) ) { if ( fclassesneedupdate . contains ( classname ) ) { classmarkerprocessor classprocessor = get ( classname ) ; classprocessor . updatetaintmarkers ( editor ) ; fclassesneedupdate . remove ( classname ) ; } } else { fprocessedclasses . add ( classname ) ; map < string , map < intrange , map < string , set < calllocationmodel > > > > classtainteddatamap = ftainteddatamap . get ( classname ) ; map < string , set < intrange > > classunreachablemethodmap = funreachablesourcemethodmap . get ( classname ) ; if ( classtainteddatamap != null || classunreachablemethodmap != null ) { ieditorinput input = editor . geteditorinput ( ) ; if ( input instanceof fileeditorinput ) { classmarkerprocessor classprocessor = get ( classname ) ; classprocessor . showdroidsafetextmarkers ( editor ) ; } } } } }	displays the annotations of the droidsafe text markers for the given class name in the given java editor .
private static void resolvenewexpression ( newexpression objsubjectexpression , hashset < string > objtypesset ) { classreference objclassref = objsubjectexpression . getclassreference ( ) ; if ( null == objclassref || null == objclassref . getfqn ( ) ) { objtypesset . add ( types . strresolvingabortedonpsilevel ) ; return ; } objtypesset . add ( objclassref . getfqn ( ) ) ; }	will resolve type of new expression.
private static list < size > pickuptothree ( list < size > sizes ) { list < size > result = new arraylist < size > ( ) ; size largest = sizes . get ( _num ) ; result . add ( largest ) ; size lastsize = largest ; for ( size size : sizes ) { double targetarea = math . pow ( _num , result . size ( ) ) * area ( largest ) ; if ( area ( size ) < targetarea ) { if ( ! result . contains ( lastsize ) && ( targetarea - area ( lastsize ) < area ( size ) - targetarea ) ) { result . add ( lastsize ) ; } else { result . add ( size ) ; } } lastsize = size ; if ( result . size ( ) == _num ) { break ; } } if ( result . size ( ) < _num && ! result . contains ( lastsize ) ) { result . add ( lastsize ) ; } return result ; }	given a list of sizes of a similar aspect ratio , it tries to pick evenly spaced out options.
private boolean verifylogrecord ( string [ ] record , int macpos ) throws exception { stringbuilder data = new stringbuilder ( ) ; for ( int m = _num ; m < record . length - _num ; m ++ ) { data . append ( record [ m ] ) ; } curmac = record [ macpos ] ; verified = helper . verifymac ( data . tostring ( ) , helper . tobytearray ( curmac ) ) ; return verified ; }	verifies the passed logrecord to check for tampering .
public static void copytoclipboard ( transferable t ) { clipboardhelper . copytoclipboard ( t ) ; }	copies the given transferable to the system ' s clipboard .
public static string formatpercent ( int downloadsize , int filesize ) { float num = ( float ) downloadsize / filesize ; float percent = ( ( float ) ( int ) ( num * _num ) ) / _num ; return string . valueof ( percent + _str ) ; }	format the download percent.
private void updateactions ( ) { string selectedtext = getselectedtext ( ) ; if ( selectedtext == null ) selectedtext = _str ; boolean stuffselected = ! selectedtext . equals ( _str ) ; boolean allselected = selectedtext . equals ( gettext ( ) ) ; undo_action . setenabled ( isenabled ( ) && iseditable ( ) && isundoavailable ( ) ) ; cut_action . setenabled ( isenabled ( ) && iseditable ( ) && stuffselected ) ; copy_action . setenabled ( isenabled ( ) && stuffselected ) ; paste_action . setenabled ( isenabled ( ) && iseditable ( ) && ispasteavailable ( ) ) ; delete_action . setenabled ( isenabled ( ) && stuffselected ) ; select_all_action . setenabled ( isenabled ( ) && ! allselected ) ; }	updates the actions in each text just before showing the popup menu .
public static < t > collection < t > makeimmutable ( collection < t > mutablecollection ) { collection < t > newcollection ; try { @ suppresswarnings ( _str ) class < collection < t > > cls = ( class < collection < t > > ) mutablecollection . getclass ( ) ; newcollection = cls . newinstance ( ) ; } catch ( instantiationexception | illegalaccessexception e ) { throw new illegalstateexception ( e ) ; } for ( t element : mutablecollection ) { newcollection . add ( utils . makeimmutable ( element ) ) ; } return collections . unmodifiablecollection ( newcollection ) ; }	a recursive call to make a collection and all it ' s values immutable .
public synchronized void trackheximages ( ihex hex , mediatracker tracker ) { image base = hextoimagecache . get ( hex ) ; list < image > superimgs = hextoimagelistcache . get ( hex ) ; list < image > orthoimgs = ortholistcache . get ( hex ) ; tracker . addimage ( base , _num ) ; if ( superimgs != null ) { for ( iterator < image > i = superimgs . iterator ( ) ; i . hasnext ( ) ; ) { tracker . addimage ( i . next ( ) , _num ) ; } } if ( orthoimgs != null ) { for ( iterator < image > i = orthoimgs . iterator ( ) ; i . hasnext ( ) ; ) { tracker . addimage ( i . next ( ) , _num ) ; } } }	adds all images associated with the hex to the specified tracker.
public static date parsetext ( string datestr ) { try { return msimpletextformat . parse ( datestr ) ; } catch ( parseexception e ) { e . printstacktrace ( ) ; throw new runtimeexception ( _str ) ; } }	parse string to datetime.
public boolean isprocessed ( trace trace , node node , direction direction ) { boolean ret = _bool ; if ( processor . getnodetype ( ) == node . gettype ( ) && processor . getdirection ( ) == direction ) { if ( urifilter == null || urifilter . test ( node . geturi ( ) ) ) { ret = _bool ; } } if ( log . isloggable ( level . finest ) ) { log . finest ( _str + trace + _str + node + _str + direction + _str + ret ) ; } return ret ; }	this method checks that this processor matches the supplied business txn name and node details .
@ override public synchronized void poweronselftest ( ) throws error { for ( iterator < waveformsynthesizer > it = waveformsynthesizers . iterator ( ) ; it . hasnext ( ) ; ) { waveformsynthesizer ws = it . next ( ) ; ws . poweronselftest ( ) ; } }	perform a power - on self test by processing some example input data .
private quadedge [ ] fetchtriangletovisit ( quadedge edge , stack edgestack , boolean includeframe , set visitededges ) { quadedge curr = edge ; int edgecount = _num ; boolean isframe = _bool ; do { triedges [ edgecount ] = curr ; if ( isframeedge ( curr ) ) isframe = _bool ; quadedge sym = curr . sym ( ) ; if ( ! visitededges . contains ( sym ) ) edgestack . push ( sym ) ; visitededges . add ( curr ) ; edgecount ++ ; curr = curr . lnext ( ) ; } while ( curr != edge ) ; if ( isframe && ! includeframe ) return null ; return triedges ; }	stores the edges for a visited triangle.
public collection enginegeneratecrls ( inputstream instream ) throws crlexception { crl crl ; list crls = new arraylist ( ) ; while ( ( crl = enginegeneratecrl ( instream ) ) != null ) { crls . add ( crl ) ; } return crls ; }	returns a ( possibly empty ) collection view of the crls read from the given input stream instream.
public void deleteentityconfig ( string realm , string federationid ) throws wsfederationmetaexception { if ( federationid == null ) { return ; } if ( realm == null ) { realm = _str ; } string [ ] objs = { federationid , realm } ; try { map oldattrs = configinst . getconfiguration ( realm , federationid ) ; set oldvalues = ( set ) oldattrs . get ( attr_entity_config ) ; if ( oldvalues == null || oldvalues . isempty ( ) ) { logutil . error ( level . info , logutil . no_entity_descriptor_delete_entity_config , objs , null ) ; throw new wsfederationmetaexception ( _str , objs ) ; } idpssoconfigelement idpconfig = getidpssoconfig ( realm , federationid ) ; if ( idpconfig != null ) { removefromcircleoftrust ( idpconfig , realm , federationid ) ; } spssoconfigelement spconfig = getspssoconfig ( realm , federationid ) ; if ( spconfig != null ) { removefromcircleoftrust ( spconfig , realm , federationid ) ; } set attr = new hashset ( ) ; attr . add ( attr_entity_config ) ; configinst . deleteconfiguration ( realm , federationid , attr ) ; logutil . access ( level . info , logutil . entity_config_deleted , objs , null ) ; wsfederationmetacache . putentityconfig ( realm , federationid , null ) ; } catch ( configurationexception e ) { debug . error ( _str , e ) ; string [ ] data = { e . getmessage ( ) , federationid , realm } ; logutil . error ( level . info , logutil . config_error_delete_entity_config , data , null ) ; throw new wsfederationmetaexception ( e ) ; } }	deletes the extended entity configuration under the realm .
public static synchronized datasourceviewsmanager sharedinstance ( ) { if ( sharedinstance == null ) sharedinstance = new datasourceviewsmanager ( ) ; return sharedinstance ; }	returns singleton instance of datasourceviewsmanager .
public string tag ( string inner , string c1 , string c2 ) { boolean color = ( ( attr & attr_color ) == attr_color ) && toastbootstrap . color ; string s = _str ; if ( color ) s += _str + c1 + _str ; s += inner ; if ( color ) s += _str + c2 + _str ; s += _str ; if ( color ) s += _str + c1 + _str ; return color ? pretty . format ( s ) : s ; }	return a tag , maybe formatted with color.
private final string loadxmldefinition ( ) { final cache cache = cachefactory . getanyinstance ( ) ; final stringwriter stringwriter = new stringwriter ( ) ; final printwriter printwriter = new printwriter ( stringwriter ) ; cachexmlgenerator . generate ( cache , printwriter , _bool , _bool , _bool ) ; printwriter . close ( ) ; return loadxmldefinition ( stringwriter . tostring ( ) ) ; }	use the cachexmlgenerator to create xml from the entity associated with the current cache .
private long id ( httpservletrequest request ) { long id = null ; string pathinfo = request . getpathinfo ( ) ; if ( pathinfo != null && pathinfo . length ( ) > _num ) { string idstring = pathinfo . substring ( _num ) ; id = long . valueof ( idstring ) ; } return id ; }	extract id from the http request .
public void uncompress ( ) { data . position ( _num ) ; inflaterinputstream inflater = new inflaterinputstream ( data . asinputstream ( ) ) ; byte [ ] buffer = new byte [ _num ] ; iobuffer tmp = iobuffer . allocate ( _num ) ; tmp . setautoexpand ( _bool ) ; try { while ( inflater . available ( ) > _num ) { int decompressed = inflater . read ( buffer ) ; if ( decompressed <= _num ) { break ; } tmp . put ( buffer , _num , decompressed ) ; } } catch ( ioexception e ) { tmp . free ( ) ; throw new runtimeexception ( _str , e ) ; } finally { if ( inflater != null ) { try { inflater . close ( ) ; } catch ( ioexception e1 ) { } } } data . free ( ) ; data = tmp ; data . flip ( ) ; prepareio ( ) ; }	decompress contents using zlib .
public void poll ( final tcpsocketstatisticshandler handler ) { this . statisticshandler = handler ; try { fileloader . load ( ) ; final bytebuffer buffer = fileloader . getbuffer ( ) ; lineparser . reset ( ) ; lineparser . handletoken ( buffer , buffer . position ( ) , buffer . limit ( ) ) ; } finally { this . statisticshandler = null ; } monitoredsockets . purgeentriesolderthan ( updatecount ) ; updatecount ++ ; }	read from monitored file , report any changed values for monitored socket statistics.
@ override public void close ( ) throws ioexception { synchronized ( lock ) { if ( ! isclosed ( ) ) { in . close ( ) ; buf = null ; } } }	closes this reader . this implementation closes the buffered source reader and releases the buffer . nothing is done if this reader has already been closed .
public int compareto ( charbuffer otherbuffer ) { int compareremaining = ( remaining ( ) < otherbuffer . remaining ( ) ) ? remaining ( ) : otherbuffer . remaining ( ) ; int thispos = position ; int otherpos = otherbuffer . position ; char thisbyte , otherbyte ; while ( compareremaining > _num ) { thisbyte = get ( thispos ) ; otherbyte = otherbuffer . get ( otherpos ) ; if ( thisbyte != otherbyte ) { return thisbyte < otherbyte ? - _num : _num ; } thispos ++ ; otherpos ++ ; compareremaining -- ; } return remaining ( ) - otherbuffer . remaining ( ) ; }	compare the remaining chars of this buffer to another char buffer ' s remaining chars .
public urbansimzonecsvwriterv2 ( string matsim4opustempdirectory , string matsimoutputdirectory ) { this . matsim4opustempdirectory = matsim4opustempdirectory ; this . matsimoutputdirectory = matsimoutputdirectory ; try { log . info ( _str ) ; zonewriter = ioutils . getbufferedwriter ( matsim4opustempdirectory + file_name ) ; log . info ( _str + matsim4opustempdirectory + file_name + _str ) ; zonewriter . write ( labels . zone_id + _str + labels . accessibility_by_freespeed + _str + labels . accessibility_by_car + _str + labels . accessibility_by_bike + _str + labels . accessibility_by_walk + _str + labels . accessibility_by_pt ) ; zonewriter . newline ( ) ; log . info ( _str ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }	writes the header for zones csv file.
@ override public void agg ( object newval ) { if ( newval instanceof byte [ ] ) { bytebuffer buffer = bytebuffer . wrap ( ( byte [ ] ) newval ) ; buffer . rewind ( ) ; while ( buffer . hasremaining ( ) ) { aggval += buffer . getlong ( ) ; count += buffer . getdouble ( ) ; firsttime = _bool ; } return ; } aggval += ( long ) newval ; count ++ ; firsttime = _bool ; }	average aggregate function which will add all the aggregate values and it will increment the total count every time , for average value.
private static policynotification extractpolicynotification ( string xml ) throws policyevaluationexception { policynotification policynotification = null ; try { string notificationdatablock = getnotificationdatablock ( xml ) ; if ( notificationdatablock != null ) { document doc = xmlutils . getxmldocument ( new bytearrayinputstream ( notificationdatablock . getbytes ( ) ) ) ; node rootnode = xmlutils . getrootnode ( doc , node_policy_service ) ; if ( rootnode != null ) { node notificationnode = xmlutils . getchildnode ( rootnode , node_policy_notification ) ; if ( notificationnode != null ) { policynotification = policynotification . parsexml ( notificationnode ) ; } else { debug . error ( _str + _str + _str ) ; throw new policyevaluationexception ( resbundleutils . rbname , _str , null , null ) ; } } else { debug . error ( _str + _str ) ; } } else { debug . error ( _str + _str + _str ) ; } } catch ( exception xe ) { debug . error ( _str , xe ) ; throw new policyevaluationexception ( resbundleutils . rbname , _str , null , xe ) ; } return policynotification ; }	returns the notification xml node.
public synchronized void flush ( ) throws ioexception { checknotclosed ( ) ; trimtosize ( ) ; journalwriter . flush ( ) ; }	force buffered operations to the filesystem .
private object findparcel ( @ nonnull byte [ ] objectarray , @ nonnull string classname ) { try { class classtmp = getclassforname ( classname ) ; constructor declaredconstructor = classtmp . getdeclaredconstructor ( parcel . class ) ; declaredconstructor . setaccessible ( _bool ) ; return declaredconstructor . newinstance ( wearbustools . bytetoparcel ( objectarray ) ) ; } catch ( exception e ) { log . d ( wearbustools . buswear_tag , _str + e . getmessage ( ) ) ; } return null ; }	attempts to locate the class specified by classname to instantiate with the given objectarray.
private static final string decodefieldname ( final string pxmlfieldname ) { stringbuilder str = new stringbuilder ( ) ; int fieldnamelength = pxmlfieldname . length ( ) ; char currentchar ; for ( int i = _num ; i < fieldnamelength ; i ++ ) { currentchar = pxmlfieldname . charat ( i ) ; if ( currentchar == _str ) { str . append ( character . touppercase ( pxmlfieldname . charat ( ++ i ) ) ) ; } else { str . append ( currentchar ) ; } } return str . tostring ( ) ; }	decodes a field name from xml notation ( e.
public boolean isloginset ( ) { return ( username != null && ( password != null && ! username . equals ( _str ) && ! password . equals ( _str ) ) ) || oauth ; }	return true if either login / pass is set or if oauth is enabled.
public void addcontentitem ( contentitem contentitem ) { if ( contentitems == null ) { contentitems = new arraylist < contentitem > ( ) ; } contentitems . add ( contentitem ) ; }	adds a content item .
public static string canonicalizeclassname ( string name ) { string classname = name . replace ( _str , _str ) ; classname = classname . replace ( _str , _str ) ; if ( classname . startswith ( _str ) ) classname = classname . substring ( _num ) ; if ( classname . endswith ( _str ) ) classname = classname . substring ( _num , classname . length ( ) - _num ) ; return classname ; }	create a proper class name from a messy thing.
public static final void pause ( final int milliseconds ) { if ( milliseconds >= _num || logger . isdebugenabled ( ) ) { logger . info ( _str , milliseconds ) ; } final long target = system . currenttimemillis ( ) + milliseconds ; try { for ( ; ; ) { long msleft = target - system . currenttimemillis ( ) ; if ( msleft <= _num ) { break ; } thread . sleep ( msleft ) ; } } catch ( interruptedexception e ) { assert . fail ( _str , e ) ; } }	pause for the specified milliseconds.
public boolean ishighlightwithinvisibleedge ( ) { return highlightwithinvisibleedge ; }	indicates if neighbor nodes with edges currently not visible still get highlighted .
private configuration preparejobforcancelling ( ) throws exception { preparefile ( _str , _num ) ; executedtasks . set ( _num ) ; cancelledtasks . set ( _num ) ; failmapperid . set ( _num ) ; splitscount . set ( _num ) ; configuration cfg = new configuration ( ) ; setupfilesystems ( cfg ) ; job job = job . getinstance ( cfg ) ; job . setoutputkeyclass ( text . class ) ; job . setoutputvalueclass ( intwritable . class ) ; job . setmapperclass ( cancellingtestmapper . class ) ; job . setnumreducetasks ( _num ) ; job . setinputformatclass ( informat . class ) ; fileinputformat . setinputpaths ( job , new path ( _str + gettestgridname ( _num ) + _str ) ) ; fileoutputformat . setoutputpath ( job , new path ( _str + gettestgridname ( _num ) + _str ) ) ; job . setjarbyclass ( getclass ( ) ) ; return job . getconfiguration ( ) ; }	prepare job with mappers to cancel .
public void removechanginglistener ( onwheelchangedlistener listener ) { changinglisteners . remove ( listener ) ; }	removes wheel changing listener.
protected void generatefields ( ) { for ( iterator < element > iterator = melements . iterator ( ) ; iterator . hasnext ( ) ; ) { element element = iterator . next ( ) ; if ( ! element . used ) { iterator . remove ( ) ; continue ; } psifield [ ] fields = mclass . getfields ( ) ; boolean duplicatefield = _bool ; for ( psifield field : fields ) { string name = field . getname ( ) ; if ( name != null && name . equals ( element . getfieldname ( ) ) ) { duplicatefield = _bool ; break ; } } if ( duplicatefield ) { iterator . remove ( ) ; continue ; } mclass . add ( mfactory . createfieldfromtext ( _str + element . name + _str + element . getfieldname ( ) + _str , mclass ) ) ; } }	create fields for injections inside main class.
public boolean isflying ( ) { return ( flythroughdialog != null ) ; }	determine if in flight.
public synchronized void init ( ) { channelfactory = new nioclientsocketchannelfactory ( executors . newcachedthreadpool ( ) , executors . newcachedthreadpool ( ) ) ; datagramchannelfactory = new niodatagramchannelfactory ( executors . newcachedthreadpool ( ) ) ; timer = new hashedwheeltimer ( ) ; }	initialize ; cached threadpool is safe as it is releasing resources automatically if idle.
public static string removepattern ( final string source , final string regex ) { return replacepattern ( source , regex , stringutils . empty ) ; }	removes each substring of the source string that matches the given regular expression using the dotall option .
private void consumenestedscroll ( int dxunconsumed , int dyunconsumed , int dxfinalunconsumed , int dyfinalunconsumed ) { if ( moverscrolleffect == overscrolleffect . bounce && dyfinalunconsumed != _num ) { munconsumedoverscrolloffset += - dyfinalunconsumed ; int maxoffset = moverscrolloffsetlimit ; if ( munconsumedoverscrolloffset > _num ) { munconsumedoverscrolloffset = math . min ( maxoffset , munconsumedoverscrolloffset ) ; } else if ( munconsumedoverscrolloffset < _num ) { munconsumedoverscrolloffset = math . max ( - maxoffset , munconsumedoverscrolloffset ) ; } setscrollingoffset ( getunconsumedscrollingoffset ( ) ) ; } pulledgeeffects ( dxunconsumed , dyunconsumed ) ; }	consume the final unconsumed nested scroll after all behaviors done .
private void retrievewaypoints ( searchquery query , arraylist < waypoint > waypoints ) { string querylikeselection2 = _str + query . textquery + _str ; string [ ] waypointselectionargs = new string [ ] { querylikeselection2 , querylikeselection2 , querylikeselection2 } ; cursor cursor = null ; try { cursor = providerutils . getwaypointcursor ( waypoint_selection_query , waypointselectionargs , waypoint_selection_order , max_scored_waypoints ) ; if ( cursor != null ) { waypoints . ensurecapacity ( cursor . getcount ( ) ) ; while ( cursor . movetonext ( ) ) { waypoint waypoint = providerutils . createwaypoint ( cursor ) ; if ( locationutils . isvalidlocation ( waypoint . getlocation ( ) ) ) { waypoints . add ( waypoint ) ; } } } } finally { if ( cursor != null ) { cursor . close ( ) ; } } }	retrieves waypoints matching the given query from the database .
void release ( ) { imageloader . cancelpendingrequests ( ) ; loading = new boolean [ noxitems . size ( ) ] ; }	cancels all the pending noxitem downloads to the imageloader .
public int size ( ) { final reentrantlock lock = this . lock ; lock . lock ( ) ; try { return count ; } finally { lock . unlock ( ) ; } }	returns the number of elements in this deque .
public void add ( string name , long cnt ) { if ( _values == null ) { _values = new arraylist < > ( _num ) ; } _values . add ( new count ( this , name , cnt ) ) ; }	insert at the end of the list.
void closedialog ( ) ;	closes dialog ( if opened ) .
public mediaconfig createchannelfileattachment ( string file , mediaconfig config ) { config . addcredentials ( this ) ; string xml = postfile ( this . url + _str , file , config . name , config . toxml ( ) ) ; element root = parse ( xml ) ; if ( root == null ) { return null ; } try { mediaconfig media = new mediaconfig ( ) ; media . parsexml ( root ) ; return media ; } catch ( exception exception ) { this . exception = sdkexception . parsefailure ( exception ) ; throw this . exception ; } }	create a new file / image / media attachment for a chat channel .
public void addparam ( astnode param ) { assertnotnull ( param ) ; if ( params == null ) { params = new arraylist < astnode > ( ) ; } params . add ( param ) ; param . setparent ( this ) ; }	adds a parameter to the function parameter list.
deleteevent ( @ nonnull jsonobject json ) throws jsonexception { super ( type_delete , json ) ; if ( textutils . isempty ( mblockid ) ) { throw new jsonexception ( typename_delete + _str + json_block_id ) ; } moldxml = json . optstring ( json_old_value ) ; jsonarray ids = json . getjsonarray ( json_ids ) ; int count = ids . length ( ) ; list < string > temp = new arraylist < > ( count ) ; for ( int i = _num ; i < count ; ++ i ) { temp . add ( ids . getstring ( i ) ) ; } mids = collections . unmodifiablelist ( temp ) ; }	constructs a deleteevent from the json serialized representation .
public static boolean isfullcopyrestorable ( volume volume , dbclient dbclient ) { boolean result = _bool ; string replicastate = volume . getreplicastate ( ) ; if ( isvolumefullcopy ( volume , dbclient ) && replicastate != null && ! replicastate . isempty ( ) ) { replicationstate state = replicationstate . getenumvalue ( replicastate ) ; if ( state != null && state == replicationstate . synchronized ) { result = _bool ; } } return result ; }	check if the full copy volume could be restored .
private final static string [ ] readqdstrings ( string string , int [ ] pos ) throws namingexception { return readqdescrs ( string , pos ) ; }	dstring = 1 * utf8 qdstring = whsp " ' " dstring " ' " whsp qdstringlist = [ qdstring * ( qdstring ) ] qdstrings = qdstring / ( whsp " ( " qdstringlist " ) " whsp ).
private static boolean isbuffertoolarge ( bytebuffer buf ) { return isbuffertoolarge ( buf . capacity ( ) ) ; }	returns true if the buffer is too large to be added to the buffer cache , false otherwise .
public static void resetindexbuffertime ( ) { safe_query_time . set ( _num ) ; }	only for test purposes this should not be called from any product code . calls from product code will possibly cause continous reevaluation ( performance issue ) or incorrect query results ( functional issue ).
protected abstract adminresponse createresponse ( distributionmanager dm ) ;	must return a proper response to this request .
protected boolean checkexternalstorageandnotify ( string filename ) { if ( filename != null && filename . startswith ( _str ) ) { alertdownloadfailure ( r . string . download_no_sdcard_dlg_title ) ; return _bool ; } string status = environment . getexternalstoragestate ( ) ; if ( ! status . equals ( environment . media_mounted ) ) { int title ; if ( status . equals ( environment . media_shared ) ) { title = r . string . download_sdcard_busy_dlg_title ; } else { title = r . string . download_no_sdcard_dlg_title ; } alertdownloadfailure ( title ) ; return _bool ; } return _bool ; }	check the external storage and notify user on error .
public static string plnoun ( final int quantity , final string noun ) { final string enoun = fullform ( noun ) ; if ( quantity == _num ) { return singular ( enoun ) ; } else { return plural ( noun ) ; } }	returns either the plural or singular form of the given noun , depending on the quantity .
public boolean verifyxmlsignature ( org . w3c . dom . element element , java . lang . string certalias ) throws xmlsignatureexception { return verifyxmlsignature ( element , def_id_attribute , certalias ) ; }	verify the signature of the xml document.
public void add ( video video ) { videolist . add ( video ) ; notifydatasetchanged ( ) ; }	adds a video to the adapter and notify the change .
private static boolean isinhorizontaltargetzone ( float x , float y , float handlexstart , float handlexend , float handley , float targetradius ) { if ( x > handlexstart && x < handlexend && math . abs ( y - handley ) <= targetradius ) { return _bool ; } return _bool ; }	determines if the specified coordinate is in the target touch zone for a horizontal bar handle .
public void readtransportsystems ( final int [ ] columnsindices , final bufferedreader reader ) throws ioexception { string line = reader . readline ( ) ; while ( line != null && line . length ( ) > _num ) { line = reader . readline ( ) ; } }	reads the transport systems of the visum file.
private boolean hasprefix ( byte [ ] nal ) { if ( nal [ _num ] == _num && nal [ _num ] == _num && nal [ _num ] == _num && nal [ _num ] == _num ) return _bool ; else return _bool ; }	makes sure the nal has a header or not .
private void unsharemain ( ) { int [ ] old = _mainhash ; int len = _mainhash . length ; _mainhash = new int [ len ] ; system . arraycopy ( old , _num , _mainhash , _num , len ) ; _mainhashshared = _bool ; }	method that needs to be called , if the main hash structure is ( may be ) shared . this happens every time something is added , even if addition is to the collision list ( since collision list index comes from lowest 8 bits of the primary hash entry ).
public componentconfigbuilder additeminmultifield ( string multifieldlabel , int index , string itemtype , string itemlabel , string value ) { string type = string . format ( _str , index , itemtype ) ; string label = string . format ( _str , multifieldlabel , itemlabel ) ; config . add ( new configurationentry ( currenttab , type , label , value ) ) ; return this ; }	adds multifield entry , equivalent of : | tab_name | multifield # index # itemtype | multifieldlabel # itemlabel | value |.
public int size ( ) { return names . size ( ) ; }	returns the number of members ( name / value pairs ) in this object .
public static imultipoint [ ] randompoints ( int n , int d , int scale ) { imultipoint points [ ] = new imultipoint [ n ] ; for ( int i = _num ; i < n ; i ++ ) { stringbuilder sb = new stringbuilder ( ) ; for ( int j = _num ; j < d ; j ++ ) { sb . append ( rgen . nextdouble ( ) * scale ) ; if ( j < d - _num ) { sb . append ( _str ) ; } } points [ i ] = new hyperpoint ( sb . tostring ( ) ) ; } return points ; }	generate array of n d - dimensional points whose coordinates are values in the range 0.
private void parseparameters ( string parameters ) { log . v ( _str , _str + _str + parameters ) ; if ( parameters != null ) { int i ; do { i = parameters . indexof ( _str ) ; if ( i < _num ) { parseparameter ( parameters ) ; } else { parseparameter ( parameters . substring ( _num , i ) ) ; parameters = parameters . substring ( i + _num ) ; } } while ( i >= _num ) ; } }	parses a comma - separated list of authentification scheme parameters .
public void addhttpsessiontoken ( string site , string token ) { if ( ! site . contains ( _str ) ) { site = site + ( _str ) ; } httpsessiontokensset sitetokens = sessiontokens . get ( site ) ; if ( sitetokens == null ) { sitetokens = new httpsessiontokensset ( ) ; sessiontokens . put ( site , sitetokens ) ; } log . info ( _str + site + _str + token ) ; sitetokens . addtoken ( token ) ; unmarkremoveddefaultsessiontoken ( site , token ) ; }	adds a new session token for a particular site .
public gradledistribution deserializefromstring ( string distributionstring ) { preconditions . checknotnull ( distributionstring ) ; string localinstallationprefix = _str ; if ( distributionstring . startswith ( localinstallationprefix ) && distributionstring . endswith ( _str ) ) { string localinstallationdir = distributionstring . substring ( localinstallationprefix . length ( ) , distributionstring . length ( ) - _num ) ; return gradledistribution . forlocalinstallation ( new file ( localinstallationdir ) ) ; } string remotedistributionprefix = _str ; if ( distributionstring . startswith ( remotedistributionprefix ) && distributionstring . endswith ( _str ) ) { string remotedistributionuri = distributionstring . substring ( remotedistributionprefix . length ( ) , distributionstring . length ( ) - _num ) ; return gradledistribution . forremotedistribution ( createuri ( remotedistributionuri ) ) ; } string versionprefix = _str ; if ( distributionstring . startswith ( versionprefix ) && distributionstring . endswith ( _str ) ) { string version = distributionstring . substring ( versionprefix . length ( ) , distributionstring . length ( ) - _num ) ; return gradledistribution . forversion ( version ) ; } string wrapperstring = _str ; if ( distributionstring . equals ( wrapperstring ) ) { return gradledistribution . frombuild ( ) ; } string message = string . format ( _str , distributionstring ) ; throw new runtimeexception ( message ) ; }	deserializes the gradle distribution from the the given string representation .
public double meterstopixels ( ) { double screencenterlat = screentopleft . latitude - screensize . latitude / _num ; double meterstolon = _num / ( util . lon_to_meters_at_equator * math . cos ( screencenterlat / _num * math . pi ) ) ; return screensize . longitude / windowwidth * meterstolon ; }	returns the ratio of meters to pixels at the center of the screen.
public boolean sendviadatasocket ( byte [ ] bytes , int start , int len ) { if ( dataoutputstream == null ) { log . i ( tag , _str ) ; return _bool ; } if ( len == _num ) { return _bool ; } try { dataoutputstream . write ( bytes , start , len ) ; } catch ( ioexception e ) { log . i ( tag , _str ) ; log . i ( tag , e . tostring ( ) ) ; return _bool ; } localdatasocket . reporttraffic ( len ) ; return _bool ; }	sends a byte array over the already - established data socket.
private void pushcontext ( basecontext c ) { contextstack . push ( c ) ; }	add a new parsing context onto the parse context stack .
@ override public void bookmarksorhistorypicker ( comboviews startview ) { if ( mtabcontrol . getcurrentwebview ( ) == null ) { return ; } if ( isincustomactionmode ( ) ) { endactionmode ( ) ; } bundle extras = new bundle ( ) ; extras . putboolean ( browserbookmarkspage . extra_disable_window , ! mtabcontrol . cancreatenewtab ( ) ) ; mui . showcomboview ( startview , extras ) ; }	open the go page .
public fst ( string filename , string encoding , boolean verbose ) throws ioexception { fileinputstream fis = new fileinputstream ( filename ) ; try { loadheaderless ( fis , encoding , verbose ) ; } finally { fis . close ( ) ; } }	initialise the finite state transducer .
public static double [ ] normalizezscore ( double [ ] x ) { double mn = mean ( x , _num ) ; double sd = standarddeviation ( x , _num ) ; for ( int i = _num ; i < x . length ; i ++ ) if ( ! double . isnan ( x [ i ] ) ) x [ i ] = ( x [ i ] - mn ) / sd ; return x ; }	calcualtes x_i = ( x_i - mean ( x ) ) / std ( x ) this function can deal with nans.
void addlocation ( string location ) { if ( flocationlist . contains ( location ) ) { return ; } flocationlist . add ( location ) ; ftableviewer . refresh ( ) ; ftableviewer . setchecked ( location , _bool ) ; ftableviewer . setselection ( new structuredselection ( location ) ) ; validatelocations ( ) ; }	adds the given location to the table.
public javaformatter ( string linedelimiter , int initialindentlevel , boolean usecodeformatter , ijavaproject project ) { flinedelimiter = linedelimiter ; fusecodeformatter = usecodeformatter ; finitialindentlevel = initialindentlevel ; fproject = project ; }	creates a javaformatter with the target line delimiter .
public string encode ( final string pstring , final string charset ) throws encoderexception { if ( pstring == null ) { return null ; } try { return encodetext ( pstring , charset ) ; } catch ( unsupportedencodingexception e ) { throw new encoderexception ( e . getmessage ( ) ) ; } }	encodes a string into its quoted - printable form using the specified charset.
private static void checkpathneed ( ) { if ( samplinginterval == - _num ) { lastpreloadtime = readmorepaths ( ) ; } if ( ! double . isnan ( lastpreloadtime ) && simclock . gettime ( ) >= lastpreloadtime - ( samplinginterval * min_ahead_intervals ) ) { for ( int i = _num ; i < nrofpreload && ! double . isnan ( lastpreloadtime ) ; i ++ ) { lastpreloadtime = readmorepaths ( ) ; } } }	checks if more paths should be preloaded and preloads them if needed .
public boolean isinputcolumnnameallowed ( string columnname ) { if ( columnname == null || columnname . length ( ) == _num ) return _bool ; getinputcolumnnames ( _bool ) ; for ( int i = _num ; i < m_inputcolumnnames . length ; i ++ ) { if ( columnname . equals ( m_inputcolumnnames [ i ] ) ) return _bool ; } return _bool ; }	is input column name allowed.
public static int rgb ( string hex ) { int color = ( int ) long . parselong ( hex . replace ( _str , _str ) , _num ) ; int r = ( color > > _num ) & _num ; int g = ( color > > _num ) & _num ; int b = ( color > > _num ) & _num ; return color . rgb ( r , g , b ) ; }	converts the given hex - color - string to rgb .
@ override public void addpropertychangelistener ( string name , propertychangelistener pcl ) { m_bcsupport . addpropertychangelistener ( name , pcl ) ; }	add a property change listener to this bean.
public void testemptyornullblob ( ) throws exception { try { preparedstatement stmt = connection . preparestatement ( _str ) ; try { stmt . setint ( _num , _num ) ; stmt . setbytes ( _num , new byte [ _num ] ) ; int insertedcount = stmt . executeupdate ( ) ; asserttrue ( _str , insertedcount == _num ) ; stmt . setint ( _num , _num ) ; stmt . setnull ( _num , types . binary ) ; insertedcount = stmt . executeupdate ( ) ; asserttrue ( _str , insertedcount == _num ) ; } finally { stmt . close ( ) ; } stmt = connection . preparestatement ( _str ) ; stmt . setint ( _num , _num ) ; try { resultset rs = stmt . executequery ( ) ; asserttrue ( _str , rs . next ( ) ) ; asserttrue ( _str , arrays . equals ( rs . getbytes ( _num ) , new byte [ _num ] ) ) ; rs . close ( ) ; stmt . setint ( _num , _num ) ; rs = stmt . executequery ( ) ; asserttrue ( _str , rs . next ( ) ) ; asserttrue ( _str , rs . getobject ( _num ) == null ) ; rs . close ( ) ; } finally { stmt . close ( ) ; } } catch ( exception ex ) { ex . printstacktrace ( ) ; throw ex ; } }	test if driver returns correctly empty and null blobs .
private synchronized void rebuildjournal ( ) throws ioexception { if ( journalwriter != null ) { journalwriter . close ( ) ; } writer writer = new bufferedwriter ( new outputstreamwriter ( new fileoutputstream ( journalfiletmp ) , utils . us_ascii ) ) ; try { writer . write ( magic ) ; writer . write ( _str ) ; writer . write ( version_1 ) ; writer . write ( _str ) ; writer . write ( integer . tostring ( appversion ) ) ; writer . write ( _str ) ; writer . write ( integer . tostring ( valuecount ) ) ; writer . write ( _str ) ; writer . write ( _str ) ; for ( entry entry : lruentries . values ( ) ) { if ( entry . currenteditor != null ) { writer . write ( dirty + _str + entry . key + _str ) ; } else { writer . write ( clean + _str + entry . key + entry . getlengths ( ) + _str ) ; } } } finally { writer . close ( ) ; } if ( journalfile . exists ( ) ) { renameto ( journalfile , journalfilebackup , _bool ) ; } renameto ( journalfiletmp , journalfile , _bool ) ; journalfilebackup . delete ( ) ; journalwriter = new bufferedwriter ( new outputstreamwriter ( new fileoutputstream ( journalfile , _bool ) , utils . us_ascii ) ) ; }	creates a new journal that omits redundant information.
public void testcase22 ( ) { byte bbytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num } ; byte rbytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num } ; int bsign = - _num ; biginteger anumber = biginteger . zero ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . subtract ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _num , result . signum ( ) ) ; }	subtract a number from zero.
@ suppresswarnings ( _str ) public void restore ( string filename ) throws ioexception , classnotfoundexception { objectinputstream ois = new objectinputstream ( new fileinputstream ( filename ) ) ; locations = ( map < v , point > ) ois . readobject ( ) ; ois . close ( ) ; initializelocations ( ) ; locked = _bool ; firestatechanged ( ) ; }	restore the graph vertex locations from a file.
public void waitfordata ( ) { if ( this . initialized ) { return ; } waitoninitialization ( this . initializationlatchaftergetinitialimage ) ; }	wait until data is ready in this region.
private void blackmanharris4smin ( int size ) { int start = ( windowfunction . length - size ) / _num ; int stop = ( windowfunction . length + size ) / _num ; double scale = _num / ( double ) size / _num ; for ( int i = _num ; start < stop ; start ++ , i ++ ) windowfunction [ i ] = scale * ( _num - _num * math . cos ( twopi * i / size ) + _num * math . cos ( _num * twopi * i / size ) - _num * math . cos ( _num * twopi * i / size ) ) ; }	fill an array with the values of a minimum 4 - sample blackman - harris window function.
private byte [ ] calculatecmskeychecksum ( byte [ ] key ) { byte [ ] result = new byte [ _num ] ; sha1 . update ( key , _num , key . length ) ; sha1 . dofinal ( digest , _num ) ; system . arraycopy ( digest , _num , result , _num , _num ) ; return result ; }	some key wrap algorithms make use of the key checksum defined in cms [ cms - algorithms ].
public int hashcode ( ) { return _lowernick . hashcode ( ) ; }	returns the hash code of this user object .
public boolean incrementreceived ( ) { long diff = system . currenttimemillis ( ) - starttime ; if ( diff >= _num ) { packetspersecond = intervalpackets ; starttime = system . currenttimemillis ( ) ; intervalpackets = _num ; return _bool ; } else { intervalpackets ++ ; } this . receivedpackets ++ ; return _bool ; }	used for incrementing the number of packets received from the client.
sentence parsesentence ( final string text , final conversationcontext ctx ) { if ( isempty ( ) ) { return conversationparser . parse ( text , ctx ) ; } string txt = text . trim ( ) ; final sentence sentence = new sentenceimplementation ( ctx , txt ) ; txt = conversationparser . detectsentencetype ( txt , sentence ) ; if ( typematching ) { readtypematchexpressions ( txt , ctx , sentence ) ; } else if ( exactmatching ) { readsimpleexpressions ( txt , ctx , sentence ) ; } else if ( similarmatching ) { readsimpleexpressions ( txt , ctx , sentence ) ; } else if ( jokermatching ) { readjokerexpressions ( txt , ctx , sentence ) ; } else if ( caseinsensitive ) { readsimpleexpressions ( txt , ctx , sentence ) ; } return sentence ; }	parse the given text string and create a sentence object using the current matching flags .
public kafkacluster usingdirectory ( file datadir ) { if ( running ) throw new illegalstateexception ( _str ) ; if ( datadir != null && datadir . exists ( ) && ! datadir . isdirectory ( ) && ! datadir . canwrite ( ) && ! datadir . canread ( ) ) { throw new illegalargumentexception ( _str ) ; } this . datadir = datadir ; return this ; }	set the parent directory where the brokers logs and server ' s logs and snapshots will be kept .
void onconsumefinished ( purchase purchase , iabresult result ) ;	called to notify that a consumption has finished .
protected boolean checkprosodicposition ( element currentrulepart , string prosodicpositiontype ) { namednodemap attnodes = currentrulepart . getattributes ( ) ; for ( int z = _num ; z < attnodes . getlength ( ) ; z ++ ) { node el = attnodes . item ( z ) ; string currentatt = el . getnodename ( ) ; string currentval = el . getnodevalue ( ) ; if ( currentatt . equals ( _str ) ) { if ( ! currentval . startswith ( _str ) ) { if ( ! prosodicpositiontype . equals ( currentval ) ) return _bool ; } else { currentval = currentval . substring ( _num , currentval . length ( ) ) ; if ( prosodicpositiontype . equals ( currentval ) ) return _bool ; } } } return _bool ; }	checks rule part with tag " prosodicposition " ; there is only the " type " attribute right now : checks if prosodic position of a token is the same as the value of the type attribute in the rule ; values : prenuclear , nuclearparagraphfinal , nuclearparagraphnonfinal , postnuclear.
public static bigdecimal parsebigdecimalforentity ( string bigdecimalstring ) throws numberformatexception { if ( bigdecimalstring == null ) { return null ; } bigdecimalstring = bigdecimalstring . trim ( ) ; bigdecimalstring = bigdecimalstring . replaceall ( _str , _str ) ; if ( bigdecimalstring . length ( ) < _num ) { return null ; } return new bigdecimal ( bigdecimalstring ) ; }	return nulls for empty strings , as the entity engine can deal with nulls.
public static void registeroperators ( string name , inputstream operatorsxml , classloader classloader ) { registeroperators ( name , operatorsxml , classloader , null ) ; }	registers all operators from a given xml input stream.
private void dopermissionworkbeforeandroidm ( @ nonnull activity activity , @ nonnull string [ ] permissions , @ nullable permissionsresultaction action ) { for ( string perm : permissions ) { if ( action != null ) { if ( ! mpermissions . contains ( perm ) ) { action . onresult ( perm , permissions . not_found ) ; } else if ( activitycompat . checkselfpermission ( activity , perm ) != packagemanager . permission_granted ) { action . onresult ( perm , permissions . denied ) ; } else { action . onresult ( perm , permissions . granted ) ; } } } }	when request permissions on devices before android m ( android 6 . 0 , api level 23 ) do the granted or denied work directly according to the permission status.
public void deletesubgroupcontainers ( set groupcontainers ) throws amexception , ssoexception { iterator iter = groupcontainers . iterator ( ) ; while ( iter . hasnext ( ) ) { string groupcontainerdn = ( string ) iter . next ( ) ; amgroupcontainer groupcontainer = new amgroupcontainerimpl ( token , groupcontainerdn ) ; groupcontainer . delete ( ) ; } }	deletes sub group containers in this group container .
public glowtask ( plugin owner , runnable task , boolean sync , long delay , long period ) { super ( task , null ) ; taskid = nexttaskid . getandincrement ( ) ; description = task . tostring ( ) ; this . owner = owner ; this . delay = delay ; this . period = period ; counter = _num ; this . sync = sync ; }	creates a new task with the specified number of ticks between consecutive calls to execute ( ) .
public static void init ( string [ ] args ) { try { compiler . initcompiler ( args ) ; if ( vm . buildforadaptivesystem && vm . buildwithbasebootimagecompiler ) { optcompiler . initcompiler ( args ) ; } } catch ( throwable e ) { while ( e != null ) { e . printstacktrace ( ) ; e = e . getcause ( ) ; } } }	initialize boot image compiler .
static native boolean opendev ( ) ;	open fm device , call before power up.
int sendnextbyte ( ) { int result = _num ; try { long tdiff = interbytetime - ( ( system . currenttimemillis ( ) - lastrxtime ) * _num ) ; if ( tdiff > _num ) { log . debug ( _str + tdiff + _str ) ; thread . sleep ( tdiff / _num , ( int ) ( tdiff % _num ) ) ; } } catch ( interruptedexception ex ) { log . error ( _str + ex . tostring ( ) ) ; } if ( currtxcharpos >= currtxtgm . length ) { result = dequeuetelegram ( ) ; } if ( result == _num ) { writechar ( currtxtgm [ currtxcharpos ++ ] , _bool ) ; if ( currtxcharpos >= currtxtgm . length ) { setprotstat ( protstatus . receiving ) ; } } return result ; }	send next available byte.
public static string encode ( serializable o ) { bytearrayoutputstream bos = new bytearrayoutputstream ( ) ; try { objectoutputstream oos = new objectoutputstream ( bos ) ; try { oos . writeobject ( o ) ; oos . flush ( ) ; } finally { oos . close ( ) ; } return base64 . encodebytes ( bos . tobytearray ( ) ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }	encode a object to a base64 string.
public static map < string , object > createimage ( dispatchcontext dctx , map < string , ? extends object > context ) { map < string , object > result = createimagemethod ( dctx , context ) ; return result ; }	a service wrapper for the createimagemethod method.
public void addprofiles ( @ nonnull iprofile ... profiles ) { if ( maccountheaderbuilder . mprofiles == null ) { maccountheaderbuilder . mprofiles = new arraylist < > ( ) ; } collections . addall ( maccountheaderbuilder . mprofiles , iddistributor . checkids ( profiles ) ) ; maccountheaderbuilder . updateheaderandlist ( ) ; }	add new profiles to the existing list of profiles.
private static boolean isidentifiername ( string k ) { int n = k . length ( ) ; if ( n == _num ) { return _bool ; } if ( ! character . isjavaidentifierstart ( k . charat ( _num ) ) ) { return _bool ; } for ( int i = _num ; i < n ; ++ i ) { if ( ! character . isjavaidentifierpart ( k . charat ( i ) ) ) { return _bool ; } } return _bool ; }	an ecmascript identifiername is an identifier or reserved word.
static boolean lessthanunsignedlong ( long x1 , long x2 ) { return ( x1 + long . min_value ) < ( x2 + long . min_value ) ; }	returns true if x1 is less than x2 , when both values are treated as unsigned long .
private void movesinglenode ( object source , point newpoint ) { displaynode node = ( displaynode ) source ; int deltax = newpoint . x - clickpoint . x ; int deltay = newpoint . y - clickpoint . y ; int newx = node . getlocation ( ) . x + deltax ; int newy = node . getlocation ( ) . y + deltay ; node . setlocation ( newx , newy ) ; }	move a single , unselected node .
public static < t > list < t > tolist ( t obj1 , t obj2 , t obj3 ) { list < t > list = new linkedlist < t > ( ) ; list . add ( obj1 ) ; list . add ( obj2 ) ; list . add ( obj3 ) ; return list ; }	create a list from passed objx parameters.
public void addmacrorecord ( macrorecord record ) { if ( record != null ) macrorecords . add ( record ) ; }	adds a macro record to this macro .
public builder addemail ( email email ) { emails . add ( email ) ; return this ; }	adds or updates a emil of an existing user if the.
public static hashprovider best ( hashparameters params ) { return best ( params , enumset . of ( hashsupport . stateful ) ) ; }	returns the best hash provider supporting at least a stateful implementation of a hash function with the given parameters .
public byte [ ] readrawbytes ( final int size ) throws ioexception { if ( size < _num ) { throw invalidprotocolbuffernanoexception . negativesize ( ) ; } if ( bufferpos + size > currentlimit ) { skiprawbytes ( currentlimit - bufferpos ) ; throw invalidprotocolbuffernanoexception . truncatedmessage ( ) ; } if ( size <= buffersize - bufferpos ) { final byte [ ] bytes = new byte [ size ] ; system . arraycopy ( buffer , bufferpos , bytes , _num , size ) ; bufferpos += size ; return bytes ; } else { throw invalidprotocolbuffernanoexception . truncatedmessage ( ) ; } }	read a fixed size of bytes from the input .
static boolean pairsum ( int ar [ ] , int x ) { arrays . sort ( ar ) ; int len = ar . length ; for ( int i = _num , j = len - _num ; i < j ; ) { if ( ar [ i ] + ar [ j ] == x ) { return _bool ; } else if ( ar [ i ] + ar [ j ] < x ) { i ++ ; } else { j -- ; } } return _bool ; }	using sorting . if we use merge sort or heap sort then ( - ) ( nlogn ) in worst case . if we use quick sort then o ( n ^ 2 ) in worst case .
public synchronized void loadfromfile ( ) { entries . clear ( ) ; path file = paths . get ( filename ) ; try ( bufferedreader reader = files . newbufferedreader ( file , charset ) ) { string line ; do { line = reader . readline ( ) ; addressbookentry parsedentry = parseline ( line ) ; if ( parsedentry != null ) { entries . put ( parsedentry . getname ( ) , parsedentry ) ; } } while ( line != null ) ; } catch ( ioexception ex ) { logger . warning ( _str + ex . getlocalizedmessage ( ) ) ; } logger . info ( _str + entries . size ( ) + _str + filename ) ; scancategories ( ) ; }	loads the addressbook from file .
public boolean remove ( final int position ) { final adaptertransaction removetransaction = new removetransaction < > ( this , position ) ; final boolean success = removetransaction . perform ( ) ; mtransactions . offer ( removetransaction ) ; return success ; }	removes item from the given position .
private void encodetypes ( list < type > types , map < string , object > m , string key , declaration from ) { if ( types == null || types . isempty ( ) ) return ; list < map < string , object > > sats = new arraylist < > ( types . size ( ) ) ; for ( type st : types ) { sats . add ( typemap ( st , from ) ) ; } m . put ( key , sats ) ; }	encodes the list of types and puts them under the specified key in the map .
public static void clearassertioninformation ( ) { _assertinfos . clear ( ) ; _assertoccured = _bool ; }	clears internal assertion information storage.
public void build ( string code , string customstatus ) { try { if ( customstatus != null ) { result . put ( resources . getstring ( r . string . intent_extra_status ) , customstatus ) ; } else { result . put ( resources . getstring ( r . string . intent_extra_status ) , resources . getstring ( r . string . shared_pref_default_status ) ) ; } result . put ( resources . getstring ( r . string . intent_extra_code ) , code ) ; operationlistresult . put ( result ) ; } catch ( jsonexception e ) { log . e ( tag , _str + e . tostring ( ) ) ; } }	add operation results to the array to be returned .
public static operator generatebranchplan ( akibaninformationschema ais , table table ) { final operator indexscan = generateindexscan ( ais , table ) ; final schema schema = schemacache . globalschema ( ais ) ; primarykey pkey = table . getprimarykeyincludinginternal ( ) ; indexrowtype indextype = schema . indexrowtype ( pkey . getindex ( ) ) ; return generatebranchplan ( table , indexscan , indextype ) ; }	scan a group starting with primary key of a table , then get all of the children ( if any ).
protected void addtomaintenancequeue ( nodeporttuple npt ) { if ( maintenancequeue . contains ( npt ) == _bool ) { maintenancequeue . add ( npt ) ; } }	add a switch port to maintenance queue .
public long startstack ( ) { return long . parselong ( fields [ _num ] ) ; }	the address of the start ( i.
public boolean match ( mimetype other ) { if ( this == other ) return _bool ; if ( type != null && other . type != null && ! type . equals ( other . type ) ) return _bool ; if ( subtype != null && other . subtype != null && ! subtype . equals ( other . subtype ) ) return _bool ; return _bool ; }	checks if given mimetype is covered by current mimetype.
@ override public boolean isarmed ( ) { return other . isarmed ( ) ; }	all these methods simply delegate to the " other " model that is being decorated .
public encodertestsuitebuilder valid ( int min , int max ) { _valid . set ( min , max + _num ) ; _invalid . clear ( min , max + _num ) ; _encoded . clear ( min , max + _num ) ; return this ; }	tells the builder that a range of code - points is valid .
public static boolean isjavascriptenabled ( httpservletrequest request ) { httpsession session = request . getsession ( ) ; boolean javascriptenabled = ( boolean ) session . getattribute ( _str ) ; if ( javascriptenabled != null ) { return javascriptenabled . booleanvalue ( ) ; } return _bool ; }	returns true if the user has javascript enabled .
public boolean equals ( object obj ) { if ( this == obj ) return _bool ; if ( obj instanceof ecfieldfp ) { return ( p . equals ( ( ( ecfieldfp ) obj ) . p ) ) ; } return _bool ; }	compares this prime finite field for equality with the specified object .
public string name ( ) { return thename ; }	returns the name of this element type .
private static string checksummd5 ( string data ) { messagedigest md5 = null ; try { md5 = messagedigest . getinstance ( _str ) ; } catch ( nosuchalgorithmexception ex ) { throw new runtimeexception ( _str , ex ) ; } return hexencode ( md5 . digest ( data . getbytes ( ) ) ) ; }	md5 version of the " h ( ) " function from rfc2617 .
public static boolean validskinspecfile ( string filename ) { file file = new file ( configuration . skinsdir ( ) , filename ) ; if ( ! file . exists ( ) || ! file . isfile ( ) ) { return _bool ; } documentbuilderfactory dbf = documentbuilderfactory . newinstance ( ) ; try { documentbuilder builder = dbf . newdocumentbuilder ( ) ; document doc = builder . parse ( file ) ; nodelist listofcomponents = doc . getelementsbytagname ( ui_element ) ; if ( listofcomponents . getlength ( ) > _num ) { return _bool ; } else { return _bool ; } } catch ( exception e ) { return _bool ; } }	checks whether the given path points to a file that is a valid skin specification .
public strbuilder insert ( final int index , final object obj ) { if ( obj == null ) { return insert ( index , nulltext ) ; } return insert ( index , obj . tostring ( ) ) ; }	inserts the string representation of an object into this builder.
@ override public void handlemousemoved ( chartcanvas canvas , mouseevent e ) { if ( ! canvas . istooltipenabled ( ) ) { return ; } string text = gettooltiptext ( canvas , e . getx ( ) , e . gety ( ) ) ; canvas . settooltip ( text , e . getscreenx ( ) , e . getscreeny ( ) ) ; }	handles a mouse moved event by updating the tooltip .
private boolean loadunpackedumd ( string filename ) throws ioexception , generaljpcspexception { if ( doumdbuffering ) { return _bool ; } file file = new file ( filename ) ; if ( file . exists ( ) ) { randomaccessfile raf = new randomaccessfile ( file , _str ) ; filechannel rochannel = raf . getchannel ( ) ; bytebuffer readbuffer = rochannel . map ( filechannel . mapmode . read_only , _num , ( int ) rochannel . size ( ) ) ; emulator . load ( _str , readbuffer ) ; raf . close ( ) ; log . info ( _str ) ; return _bool ; } return _bool ; }	don ' t call this directly , see loadumd ( file file ).
public boolean disablevmax3compression ( uri blockobjecturi , storagesystem storagesystem ) { virtualpool virtualpool = null ; storagepool storagepool = null ; volume volume = null ; if ( uriutil . istype ( blockobjecturi , volume . class ) ) { volume = _dbclient . queryobject ( volume . class , blockobjecturi ) ; } else if ( uriutil . istype ( blockobjecturi , blocksnapshot . class ) ) { blocksnapshot snapshot = _dbclient . queryobject ( blocksnapshot . class , blockobjecturi ) ; volume = _dbclient . queryobject ( volume . class , snapshot . getparent ( ) ) ; } else if ( uriutil . istype ( blockobjecturi , blockmirror . class ) ) { blockmirror mirror = _dbclient . queryobject ( blockmirror . class , blockobjecturi ) ; virtualpool = _dbclient . queryobject ( virtualpool . class , mirror . getvirtualpool ( ) ) ; storagepool = _dbclient . queryobject ( storagepool . class , mirror . getpool ( ) ) ; } if ( volume != null ) { virtualpool = _dbclient . queryobject ( virtualpool . class , volume . getvirtualpool ( ) ) ; storagepool = _dbclient . queryobject ( storagepool . class , volume . getpool ( ) ) ; } return ( checkifprovidersupportscompressionoperations ( storagesystem ) && ! virtualpool . getcompressionenabled ( ) && storagepool . getcompressionenabled ( ) ) ; }	this method is will check if the storage pool associated with the volume supports compression.
public static latlon rhumbendposition ( latlon p , double rhumbazimuthradians , double pathlengthradians ) { if ( p == null ) { throw new illegalargumentexception ( _str ) ; } return rhumbendposition ( p , angle . fromradians ( rhumbazimuthradians ) , angle . fromradians ( pathlengthradians ) ) ; }	computes the location on a rhumb line with the given starting location , rhumb azimuth , and arc distance along the line .
private static int indexof ( object [ ] array , object elt ) { return indexof ( array , array . length , elt ) ; }	returns the first index of elt in the array , else - 1 .
public dimension maximumlayoutsize ( container target ) { return new dimension ( integer . max_value , integer . max_value ) ; }	returns the maximum dimensions for this layout given the components in the specified target container .
public static string readstream ( inputstream in ) { bufferedreader reader = new bufferedreader ( new inputstreamreader ( in ) ) ; stringbuilder sb = new stringbuilder ( ) ; string line = null ; try { while ( ( line = reader . readline ( ) ) != null ) { sb . append ( line + _str ) ; } } catch ( ioexception e ) { freshairlog . e ( _str , e ) ; } finally { try { in . close ( ) ; } catch ( ioexception e ) { } try { reader . close ( ) ; } catch ( ioexception e ) { } } return sb . tostring ( ) ; }	utility method for pulling plain text from an inputstream object.
public void update ( long n ) { uncounted . addandget ( n ) ; }	update the moving average with a new value .
private void logexpiration ( entry e ) { if ( e . renewalsdone ( ) ) { logger . log ( level . fine , _str , e . lease ) ; } else { logger . log ( levels . failed , _str , e . lease ) ; } }	logs a lease expiration , distinguishing between expected and premature expirations .
void removeripple ( ripple ripple ) { final ripple [ ] ripples = mexitingripples ; final int count = mexitingripplescount ; final int index = getrippleindex ( ripple ) ; if ( index >= _num ) { system . arraycopy ( ripples , index + _num , ripples , index , count - ( index + _num ) ) ; ripples [ count - _num ] = null ; mexitingripplescount -- ; invalidateself ( ) ; } }	removes a ripple from the exiting ripple list .
protected final void writes ( bytebuffer buf , string text ) { if ( text == null ) { buf . putchar ( _str ) ; } else { final int len = text . length ( ) ; for ( int i = _num ; i < len ; i ++ ) { buf . putchar ( text . charat ( i ) ) ; } buf . putchar ( _str ) ; } }	write string to buffer.
protected sourcerecords consumerecordsbytopic ( int numrecords ) throws interruptedexception { sourcerecords records = new sourcerecords ( ) ; consumerecords ( numrecords , null ) ; return records ; }	try to consume and capture exactly the specified number of records from the connector .
@ override public boolean equals ( object o ) { if ( this == o ) { return _bool ; } if ( ! ( o instanceof prototypesize ) ) { return _bool ; } prototypesize size = ( prototypesize ) o ; return prototype . equals ( size . prototype ) ; }	indicates whether some other constantsize is " equal to " this one .
private static int compareversion ( string versionstr1 , string versionstr2 ) { if ( versionstr1 == null ) { throw new mlcontextexception ( _str ) ; } if ( versionstr2 == null ) { throw new mlcontextexception ( _str ) ; } scanner scanner1 = null ; scanner scanner2 = null ; try { scanner1 = new scanner ( versionstr1 ) ; scanner2 = new scanner ( versionstr2 ) ; scanner1 . usedelimiter ( _str ) ; scanner2 . usedelimiter ( _str ) ; while ( scanner1 . hasnextint ( ) && scanner2 . hasnextint ( ) ) { int version1 = scanner1 . nextint ( ) ; int version2 = scanner2 . nextint ( ) ; if ( version1 < version2 ) { return - _num ; } else if ( version1 > version2 ) { return _num ; } } return scanner1 . hasnextint ( ) ? _num : _num ; } finally { scanner1 . close ( ) ; scanner2 . close ( ) ; } }	compare two version strings ( ie , " 1.
public static boolean isvalidvector ( vector2f vector ) { if ( vector == null ) { return _bool ; } if ( float . isnan ( vector . x ) || float . isnan ( vector . y ) ) { return _bool ; } if ( float . isinfinite ( vector . x ) || float . isinfinite ( vector . y ) ) { return _bool ; } return _bool ; }	check a vector . . . if it is null or its floats are nan or infinite , return false . else return true .
public boolean isobsessional ( ) { return typestring . contains ( suffix_obsessional ) ; }	determine if the expression is a obsessional one .
@ edu . umd . cs . findbugs . annotations . suppressfbwarnings ( value = _str , justification = _str ) public void changelocospeed ( dccthrottle t , block blk , float speed ) { if ( blk == referenced && speed == desiredspeedstep ) { return ; } float blocklength = blk . getlengthmm ( ) ; if ( blk == referenced ) { distanceremaining = distanceremaining - getdistancetravelled ( _throttle . getisforward ( ) , _throttle . getspeedsetting ( ) , ( ( float ) ( system . nanotime ( ) - lasttimetimerstarted ) / _num ) ) ; blocklength = distanceremaining ; log . debug ( _str ) ; } else { referenced = blk ; } changelocospeed ( t , blocklength , speed ) ; }	set speed of a throttle to a speeed set by a float , using the block for the length details.
public boolean remove ( object targetchild ) { return remove ( targetchild , _bool ) ; }	removes a child from this beancontext.
private void notifyclassobservers ( classdescriptor classdescriptor ) { for ( iclassobserver observer : classobserverlist ) { observer . observeclass ( classdescriptor ) ; } }	notify all iclassobservers that we are visiting given class .
public void dup2 ( ) { mv . visitinsn ( opcodes . dup2 ) ; }	generates a dup2 instruction .
static boolean isappxml ( string mime ) { return mime != null && ( mime . equals ( _str ) || mime . equals ( _str ) || mime . equals ( _str ) || mime . startswith ( _str ) && mime . endswith ( _str ) ) ; }	indicates if the mime type belongs to the application xml family .
public static nativepage createnativepageforurl ( string url , nativepage candidatepage , tab tab , tabmodelselector tabmodelselector , activity activity ) { return createnativepageforurl ( url , candidatepage , tab , tabmodelselector , activity , tab . isincognito ( ) ) ; }	returns a nativepage for displaying the given url if the url is a valid chrome - native url , or null otherwise.
protected void throwparseexception ( parseexception e ) throws parseexception { if ( locator != null ) { string elementlocation = _str ; if ( curhandler != null ) { elementlocation += _str + curhandler . qname ; } string location = _str + string . valueof ( locator . getlinenumber ( ) ) + _str + string . valueof ( locator . getcolumnnumber ( ) ) + elementlocation + _str ; logutils . logexception ( logger , level . fine , location , e ) ; throw new parseexception ( location + e . getmessage ( ) , e ) ; } else { logutils . logexception ( logger , level . fine , null , e ) ; throw e ; } }	throws a parse exception with line / column information .
public customeditor ( ) { setlayout ( new borderlayout ( ) ) ; add ( m_label , borderlayout . center ) ; m_deletebut . addactionlistener ( m_inneractionlistener ) ; m_editbut . addactionlistener ( m_inneractionlistener ) ; m_upbut . addactionlistener ( m_inneractionlistener ) ; m_downbut . addactionlistener ( m_inneractionlistener ) ; m_addbut . addactionlistener ( m_inneractionlistener ) ; m_elementlist . addlistselectionlistener ( m_innerselectionlistener ) ; m_elementlist . addmouselistener ( m_innermouselistener ) ; m_addbut . settooltiptext ( _str ) ; m_deletebut . settooltiptext ( _str ) ; m_editbut . settooltiptext ( _str ) ; m_upbut . settooltiptext ( _str ) ; m_downbut . settooltiptext ( _str ) ; }	sets up the array editor .
public memoidone ( function < ? super input , ? extends output > fn , bipredicate < input , input > equality ) { fn_ = objects . requirenonnull ( fn ) ; equality_ = objects . requirenonnull ( equality ) ; }	create a new memoidone , using the supplied transformation function .
public static eptype singlevalue ( class singlevaluetype ) { if ( singlevaluetype != null && singlevaluetype . isarray ( ) ) { return new classmultivaluedeptype ( singlevaluetype , singlevaluetype . getcomponenttype ( ) ) ; } return new classeptype ( singlevaluetype ) ; }	indicate that the expression return type is a single ( non - enumerable ) value of the given type.
private static class < ? > convertfieldtype ( string fieldtype ) { if ( fieldtypemap . containskey ( fieldtype ) ) { return fieldtypemap . get ( fieldtype ) ; } return null ; }	convert field type from string to a class type .
void addxmlelementaftertokenindex ( int lasttokenindex , xmlelement element , boolean addafternewline ) throws exception { addxmlelementaftertokenindex ( lasttokenindex , element , addafternewline , _bool ) ; }	adds the given xmlelement after the token whoes index matches the given lasttokenindex value.
public static map < string , object > findcontentparents ( dispatchcontext dctx , map < string , ? extends object > context ) { map < string , object > results = fastmap . newinstance ( ) ; list < object > parentlist = fastlist . newinstance ( ) ; results . put ( _str , parentlist ) ; localdispatcher dispatcher = dctx . getdispatcher ( ) ; string contentid = ( string ) context . get ( _str ) ; string contentassoctypeid = ( string ) context . get ( _str ) ; string direction = ( string ) context . get ( _str ) ; if ( utilvalidate . isempty ( direction ) ) { direction = _str ; } map < string , object > traversmap = fastmap . newinstance ( ) ; traversmap . put ( _str , contentid ) ; traversmap . put ( _str , direction ) ; traversmap . put ( _str , contentassoctypeid ) ; try { map < string , object > thisresults = dispatcher . runsync ( _str , traversmap ) ; string errormsg = serviceutil . geterrormessage ( thisresults ) ; if ( utilvalidate . isnotempty ( errormsg ) ) { debug . logerror ( _str + errormsg , module ) ; return serviceutil . returnerror ( errormsg ) ; } map < string , object > nodemap = utilgenerics . checkmap ( thisresults . get ( _str ) ) ; walkparenttree ( nodemap , parentlist ) ; } catch ( genericserviceexception e ) { return serviceutil . returnfailure ( e . getmessage ( ) ) ; } return results ; }	this is a generic service for traversing a content tree , typical of a blog response tree.
public dictionary ( directory tempdir , string tempfilenameprefix , inputstream affix , list < inputstream > dictionaries , boolean ignorecase ) throws ioexception , parseexception { this . ignorecase = ignorecase ; this . needsinputcleaning = ignorecase ; this . needsoutputcleaning = _bool ; flaglookup . add ( new bytesref ( ) ) ; path aff = files . createtempfile ( temppath , _str , _str ) ; outputstream out = new bufferedoutputstream ( files . newoutputstream ( aff ) ) ; inputstream aff1 = null ; inputstream aff2 = null ; boolean success = _bool ; try { final byte [ ] buffer = new byte [ _num * _num ] ; int len ; while ( ( len = affix . read ( buffer ) ) > _num ) { out . write ( buffer , _num , len ) ; } out . close ( ) ; aff1 = new bufferedinputstream ( files . newinputstream ( aff ) ) ; string encoding = getdictionaryencoding ( aff1 ) ; charsetdecoder decoder = getjavaencoding ( encoding ) ; aff2 = new bufferedinputstream ( files . newinputstream ( aff ) ) ; readaffixfile ( aff2 , decoder ) ; intsequenceoutputs o = intsequenceoutputs . getsingleton ( ) ; builder < intsref > b = new builder < > ( fst . input_type . byte4 , o ) ; readdictionaryfiles ( tempdir , tempfilenameprefix , dictionaries , decoder , b ) ; words = b . finish ( ) ; aliases = null ; morphaliases = null ; success = _bool ; } finally { ioutils . closewhilehandlingexception ( out , aff1 , aff2 ) ; if ( success ) { files . delete ( aff ) ; } else { ioutils . deletefilesignoringexceptions ( aff ) ; } } }	creates a new dictionary containing the information read from the provided inputstreams to hunspell affix and dictionary files.
public void collapsebuilding ( building bldg ) { buildings . removeelement ( bldg ) ; enumeration < coords > bldgcoords = bldg . getcoords ( ) ; while ( bldgcoords . hasmoreelements ( ) ) { final coords coords = bldgcoords . nextelement ( ) ; collapsebuilding ( coords ) ; } }	the given building has collapsed.
@ rpcmethod public void detachiso ( string vmid , boolean isdeletefile , asyncmethodcallback < host . asyncclient . detach_iso_call > handler ) throws rpcexception { ensureclient ( ) ; detachisorequest detachisorequest = new detachisorequest ( vmid ) ; detachisorequest . setdelete_file ( isdeletefile ) ; clientproxy . settimeout ( detach_iso_timeout_ms ) ; logger . info ( _str , vmid , gethostip ( ) , detachisorequest ) ; try { clientproxy . detach_iso ( detachisorequest , handler ) ; } catch ( texception e ) { throw new rpcexception ( e . getmessage ( ) ) ; } }	this method performs an asynchronous thrift call to detach an iso from a vm.
private string readnfcerrormsg ( bytebuffer reply ) throws ioexception { int errortype = reply . getint ( ) ; int errorcode = reply . getint ( ) ; int msglen = reply . getint ( ) ; if ( msglen == _num ) { return _str ; } bytebuffer msgbuffer = bytebuffer . allocate ( msglen ) ; readfully ( msgbuffer ) ; string errormsg = new string ( msgbuffer . array ( ) , _num , msglen - _num , charsets . us_ascii ) ; return string . format ( _str , errortype , errorcode , errormsg ) ; }	read nfc error from reply message .
private void show ( boolean show ) { if ( show ) { if ( mxfade != null ) { mxfade . cancel ( ) ; } mstate = state_pie ; mcurrentitem = null ; pieitem root = getroot ( ) ; for ( pieitem openitem : mopen ) { if ( openitem . hasitems ( ) ) { for ( pieitem item : openitem . getitems ( ) ) { item . setselected ( _bool ) ; } } } mlabel . settext ( _str ) ; mopen . clear ( ) ; mopen . add ( root ) ; layoutpie ( ) ; fadein ( ) ; } else { mstate = state_idle ; mtapmode = _bool ; if ( mxfade != null ) { mxfade . cancel ( ) ; } if ( mlabel != null ) { mlabel . settext ( _str ) ; } } setvisible ( show ) ; mhandler . sendemptymessage ( show ? msg_open : msg_close ) ; }	guaranteed has center set.
private synchronized void persistprofileandnotifychange ( authnprovider modifiedprovider , boolean newobject ) { modifiedprovider . setlastmodified ( system . currenttimemillis ( ) ) ; if ( newobject ) { _dbclient . createobject ( modifiedprovider ) ; } else { _dbclient . persistobject ( modifiedprovider ) ; } notifychange ( ) ; }	update the timestamp and notify.
public void addundoableaction ( undoableaction action ) { undostack . push ( action ) ; redostack . removeallelements ( ) ; }	add a new undoable action .
public intarraylist ( int [ ] data ) { array = new int [ ( int ) ( data . length * _num ) + _num ] ; size = data . length ; system . arraycopy ( data , _num , array , _num , size ) ; }	constructs a list containing the elements of the specified array.
private void addpingtimedata ( long sample ) { lastpingtimeslock . lock ( ) ; try { if ( lastpingtimes == null ) { lastpingtimes = new long [ ping_moving_average_window ] ; arrays . fill ( lastpingtimes , sample ) ; } else { system . arraycopy ( lastpingtimes , _num , lastpingtimes , _num , lastpingtimes . length - _num ) ; lastpingtimes [ lastpingtimes . length - _num ] = sample ; } } finally { lastpingtimeslock . unlock ( ) ; } }	adds a ping time sample to the averaging window .
public stringbuilder encodebody ( stringbuilder buffer ) { return buffer . append ( contentencoding ) ; }	canonical encoding of body of the header .
protected void teardown ( ) { try { ds . close ( ) ; sds . close ( ) ; } catch ( exception e ) { } }	tears down the fixture , for example , close a network connection.
public string substring ( string subject , int start , int stop ) { if ( stop == - _num || stop >= subject . length ( ) ) { return subject . substring ( start ) ; } return subject . substring ( start , stop ) ; }	get a substring from a string.
public void removecustomsashformlistener ( icustomsashformlistener listener ) { if ( customsashformlisteners != null ) { customsashformlisteners . remove ( listener ) ; } }	removes the custom sashform listener .
public static void writestringtofile ( file file , string data ) throws ioexception { writestringtofile ( file , data , charset . defaultcharset ( ) , _bool ) ; }	writes a string to a file creating the file if it does not exist using the default encoding for the vm .
protected void deletesessionvariables ( string sessionid , string ... varnames ) { if ( sessionid . equals ( _str ) ) { return ; } key key = keyfactory . newkey ( sessionid ) ; transaction transaction = datastore . newtransaction ( ) ; try { entity stateentity = transaction . get ( key ) ; entity . builder builder = entity . builder ( stateentity ) ; stringbuilder delnames = new stringbuilder ( ) ; for ( string varname : varnames ) { delnames . append ( varname + _str ) ; builder = builder . remove ( varname ) ; } datastore . update ( builder . build ( ) ) ; } catch ( nullpointerexception e ) { } finally { if ( transaction . active ( ) ) { transaction . rollback ( ) ; } } }	delete a value stored in the project ' s datastore .
@ override public string tostring ( ) { stringbuilder sb = new stringbuilder ( _num ) ; format ( ( getyear ( ) + _num ) , _num , sb ) ; sb . append ( _str ) ; format ( ( getmonth ( ) + _num ) , _num , sb ) ; sb . append ( _str ) ; format ( getdate ( ) , _num , sb ) ; return sb . tostring ( ) ; }	produces a string representation of the date in sql format.
@ override public void close ( ) throws ioexception { if ( mbuffercount > _num ) { try { mqueue . write ( mbuffer , _num , mbuffercount ) ; } catch ( interruptedexception e ) { throw new ioexception ( _str ) ; } mbuffercount = _num ; } mqueue . close ( ) ; try { mthread . join ( ) ; } catch ( interruptedexception e ) { throw new ioexception ( _str ) ; } finally { super . close ( ) ; } checkexception ( ) ; }	this also io errors that happened in the gzip thread .
public static int parsestringasint ( string in ) throws indexparsefieldexception { try { return integer . parseint ( in ) ; } catch ( numberformatexception e ) { throw new indexparsefieldexception ( in , e ) ; } }	parses a string as a int .
public void writeall ( resultset rs , boolean includecolumnnames , boolean trim ) throws sqlexception , ioexception { if ( includecolumnnames ) { writecolumnnames ( rs ) ; } while ( rs . next ( ) ) { writenext ( resultservice . getcolumnvalues ( rs , trim ) ) ; } }	writes the entire resultset to a csv file.
public void testspecialcase1 ( ) { byte abytes [ ] = { - _num , - _num , - _num , - _num } ; byte bbytes [ ] = { _num , - _num , - _num , - _num } ; int asign = - _num ; int bsign = - _num ; byte rbytes [ ] = { - _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . and ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , result . signum ( ) ) ; }	test for a special case.
private static void verifydevice ( idevice d , long mac , short vlan , integer ip , long swid , int port ) { assertnotnull ( d ) ; assertequals ( macaddress . of ( mac ) , d . getmacaddress ( ) ) ; if ( vlan == null ) assertarrayequals ( new vlanvid [ ] { vlanvid . ofvlan ( - _num ) } , d . getvlanid ( ) ) ; else assertarrayequals ( new vlanvid [ ] { vlanvid . ofvlan ( vlan ) } , d . getvlanid ( ) ) ; if ( ip == null ) assertarrayequals ( new ipv4address [ ] { ipv4address . of ( _num ) } , d . getipv4addresses ( ) ) ; else assertarrayequals ( new ipv4address [ ] { ipv4address . of ( ip ) } , d . getipv4addresses ( ) ) ; switchport expectedap = new switchport ( datapathid . of ( swid ) , ofport . of ( port ) ) ; assertarrayequals ( new switchport [ ] { expectedap } , d . getattachmentpoints ( ) ) ; }	verify that the given device exactly matches the given fields.
public zonerulesbuilder addwindow ( zoneoffset standardoffset , localdatetime until , timedefinition untildefinition ) { objects . requirenonnull ( standardoffset , _str ) ; objects . requirenonnull ( until , _str ) ; objects . requirenonnull ( untildefinition , _str ) ; tzwindow window = new tzwindow ( standardoffset , until , untildefinition ) ; if ( windowlist . size ( ) > _num ) { tzwindow previous = windowlist . get ( windowlist . size ( ) - _num ) ; window . validatewindoworder ( previous ) ; } windowlist . add ( window ) ; return this ; }	adds a window to the builder that can be used to filter a set of rules.
public hashtable < ipoint , list < ilinesegment > > intersections ( iterator < ilinesegment > it ) { collection < ilinesegment > c = new arraylist < ilinesegment > ( ) ; while ( it . hasnext ( ) ) { c . add ( it . next ( ) ) ; } return intersections ( c . toarray ( new ilinesegment [ ] { } ) ) ; }	compute the intersection of all segments when given an iterator of segments .
public boolean isttfnativefont ( ) { return ttf ; }	indicates if this is a ttf native font that can be derived and manipulated . this is true for a font loaded from file ( ttf ) or using the native : font name.
private void registerproviders ( ) { final devmachine devmachine = appcontext . getdevmachine ( ) ; if ( devmachine == null ) { return ; } final set < macro > providers = getmacros ( devmachine ) ; checknotnull ( providers ) ; if ( providers . isempty ( ) ) { return ; } providerregistry . register ( providers ) ; }	register macro providers which returns the implementation .
public longmap ( int initialcapacity , float loadfactor ) { if ( initialcapacity < _num ) throw new illegalargumentexception ( _str + initialcapacity ) ; if ( capacity > _num << _num ) throw new illegalargumentexception ( _str + initialcapacity ) ; capacity = mathutils . nextpoweroftwo ( initialcapacity ) ; if ( loadfactor <= _num ) throw new illegalargumentexception ( _str + loadfactor ) ; this . loadfactor = loadfactor ; threshold = ( int ) ( capacity * loadfactor ) ; mask = capacity - _num ; hashshift = _num - integer . numberoftrailingzeros ( capacity ) ; stashcapacity = math . max ( _num , ( int ) math . ceil ( math . log ( capacity ) ) + _num ) ; pushiterations = math . max ( math . min ( capacity , _num ) , ( int ) math . sqrt ( capacity ) / _num ) ; keytable = new long [ capacity + stashcapacity ] ; valuetable = ( v [ ] ) new object [ keytable . length ] ; }	creates a new map with the specified initial capacity and load factor.
protected asn1set ( asn1encodable obj ) { set . addelement ( obj ) ; }	create a sequence containing one object.
protected void populatestreamblob ( int testid , byte [ ] basecontent , int requiredsize ) throws sqlexception { final byte [ ] testbytes = generateblobcontent ( basecontent , requiredsize ) ; try ( fbdatabase db = createdatabaseconnection ( ) ) { listener = new simplestatementlistener ( ) ; transaction = gettransaction ( db ) ; try { statement = db . createstatement ( transaction ) ; statement . addstatementlistener ( listener ) ; final blobparameterbuffer blobparameterbuffer = db . createblobparameterbuffer ( ) ; blobparameterbuffer . addargument ( blobparameterbuffer . type , blobparameterbuffer . type_stream ) ; final fbblob blob = db . createblobforoutput ( transaction , blobparameterbuffer ) ; blob . open ( ) ; int byteswritten = _num ; while ( byteswritten < testbytes . length ) { byte [ ] buffer = new byte [ math . min ( blob . getmaximumsegmentsize ( ) , testbytes . length - byteswritten ) ] ; system . arraycopy ( testbytes , byteswritten , buffer , _num , buffer . length ) ; blob . putsegment ( buffer ) ; byteswritten += buffer . length ; } blob . close ( ) ; statement . prepare ( insert_blob_table ) ; final datatypecoder datatypecoder = db . getdatatypecoder ( ) ; fieldvalue param1 = new fieldvalue ( datatypecoder . encodeint ( testid ) ) ; fieldvalue param2 = new fieldvalue ( datatypecoder . encodelong ( blob . getblobid ( ) ) ) ; statement . execute ( rowvalue . of ( param1 , param2 ) ) ; statement . close ( ) ; } finally { transaction . commit ( ) ; } } }	populates a stream blob for testing .
private static long signfrombit_anticyclic ( final double value ) { return double . doubletorawlongbits ( value ) > > _num | _num ; }	redefined here , to avoid cyclic dependency with ( strict ) fastmath .
public void addnearkey ( keycacheobject key , gridcachesharedcontext ctx ) throws ignitecheckedexception { nearkeys . add ( key ) ; }	adds a near key .
private void analyzeclassfields ( string classname , int action ) { try { class < ? > dynamicclass = class . forname ( classname ) ; field [ ] fields = dynamicclass . getdeclaredfields ( ) ; for ( field field : fields ) { if ( isprivateandnonprimitive ( field ) ) { onetoanyconditions ( classname , field , action ) ; manytoanyconditions ( classname , field , action ) ; } } } catch ( classnotfoundexception ex ) { ex . printstacktrace ( ) ; throw new databasegenerateexception ( databasegenerateexception . class_not_found + classname ) ; } }	introspection of the passed in class.
protected boolean islevelenabled ( int loglevel ) { return ( loglevel >= currentloglevel ) ; }	is the given log level currently enabled ?.
public static void loadall ( final jframe parent , final idebugger debugger , final iaddress offset , final int size ) { checkarguments ( parent , debugger , offset ) ; final cdumpallwaiter waiter = new cdumpallwaiter ( debugger , offset , size ) ; cprogressdialog . showendless ( parent , _str + _str , waiter ) ; if ( waiter . getexception ( ) != null ) { cutilityfunctions . logexception ( waiter . getexception ( ) ) ; final string innermessage = _str + _str ; final string innerdescription = cutilityfunctions . createdescription ( string . format ( _str , offset . tohexstring ( ) ) , new string [ ] { _str } , new string [ ] { _str } ) ; navierrordialog . show ( parent , innermessage , innerdescription , waiter . getexception ( ) ) ; } }	loads all data of a memory section .
public void testsetattributenodens1 ( ) throws throwable { document doc ; element element ; attr attribute1 ; attr attribute2 ; attr attrnode ; string attrname ; string attrns ; namednodemap attributes ; int length ; doc = ( document ) load ( _str , builder ) ; element = doc . createelementns ( _str , _str ) ; attribute1 = doc . createattributens ( _str , _str ) ; attribute2 = doc . createattributens ( _str , _str ) ; attribute2 . setvalue ( _str ) ; element . setattributenodens ( attribute1 ) ; element . setattributenodens ( attribute2 ) ; attrnode = element . getattributenodens ( _str , _str ) ; attrname = attrnode . getnodename ( ) ; attrns = attrnode . getnamespaceuri ( ) ; assertequals ( _str , _str , attrname ) ; assertequals ( _str , _str , attrns ) ; attributes = element . getattributes ( ) ; length = ( int ) attributes . getlength ( ) ; assertequals ( _str , _num , length ) ; }	runs the test case .
public boolean iscritical ( ) { return _bool ; }	is this a critical command that can only be executed when no other command is running ?.
public static string findedittable ( string tables ) { if ( ! stringutils . isempty ( tables ) ) { int spacepos = tables . indexof ( _str ) ; int commapos = tables . indexof ( _str ) ; if ( spacepos > _num && ( spacepos < commapos || commapos < _num ) ) { return tables . substring ( _num , spacepos ) ; } else if ( commapos > _num && ( commapos < spacepos || spacepos < _num ) ) { return tables . substring ( _num , commapos ) ; } return tables ; } else { throw new illegalstateexception ( _str ) ; } }	finds the name of the first table , which is editable .
public void writeoperationscarfile ( ) { makebackupfile ( defaultoperationsfilename ( ) ) ; try { if ( ! checkfile ( defaultoperationsfilename ( ) ) ) { java . io . file file = new java . io . file ( defaultoperationsfilename ( ) ) ; java . io . file parentdir = file . getparentfile ( ) ; if ( ! parentdir . exists ( ) ) { if ( ! parentdir . mkdir ( ) ) { log . error ( _str ) ; } } if ( file . createnewfile ( ) ) { log . debug ( _str ) ; } } writefile ( defaultoperationsfilename ( ) ) ; } catch ( exception e ) { log . error ( _str + e ) ; } }	store the all of the operation car objects in the default place , including making a backup if needed.
private boolean hasnewfollowers ( list < follower > followers ) { return ! followers . isempty ( ) && followers . get ( _num ) . newfollower ; }	checks if this has new followers.
private void ontrackpointelementstart ( attributes attributes ) throws saxexception { string latitude = attributes . getvalue ( att_lat ) ; string longitude = attributes . getvalue ( att_lon ) ; if ( latitude == null || longitude == null ) { throw new saxexception ( createerrormessage ( _str ) ) ; } try { latitudevalue = double . parsedouble ( latitude ) ; longitudevalue = double . parsedouble ( longitude ) ; } catch ( numberformatexception e ) { throw new saxexception ( createerrormessage ( _str + latitude + _str + longitude ) , e ) ; } }	on track point element start .
protected final void firepropertychange ( propertychangeevent evt ) { pcs . firepropertychange ( evt ) ; }	fire an existing propertychangeevent to any registered listeners.
static int checkdesc ( final string desc , final int start , final boolean canbevoid ) { if ( desc == null || start >= desc . length ( ) ) { throw new illegalargumentexception ( _str ) ; } int index ; switch ( desc . charat ( start ) ) { case _str : if ( canbevoid ) { return start + _num ; } else { throw new illegalargumentexception ( _str + desc ) ; } case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : return start + _num ; case _str : index = start + _num ; while ( index < desc . length ( ) && desc . charat ( index ) == _str ) { ++ index ; } if ( index < desc . length ( ) ) { return checkdesc ( desc , index , _bool ) ; } else { throw new illegalargumentexception ( _str + desc ) ; } case _str : index = desc . indexof ( _str , start ) ; if ( index == - _num || index - start < _num ) { throw new illegalargumentexception ( _str + desc ) ; } try { checkinternalname ( desc , start + _num , index , null ) ; } catch ( illegalargumentexception unused ) { throw new illegalargumentexception ( _str + desc ) ; } return index + _num ; default : throw new illegalargumentexception ( _str + desc ) ; } }	checks that a the given substring is a valid type descriptor .
public static void sortfields ( fieldbinding [ ] sortedfields , int left , int right ) { arrays . sort ( sortedfields , left , right , field_comparator ) ; }	sort the field array using a quicksort.
private void drawbackground ( final graphics g ) { g . setcolor ( m_bgcoloroffset ) ; g . fillrect ( - m_firstcolumn * m_charwidth , _num , m_offsetviewwidth , getheight ( ) ) ; }	draws the background of the view .
public void adduniqueattribute ( final string elementname , final string attrname ) { if ( ( elementname != null ) && ( attrname != null ) ) { _uniqueelementattrmap . put ( elementname , attrname ) ; } }	add unique attribute to the element which will force elements to be identical .
private static deletevmresponse checkdeletevmresponse ( deletevmresponse deletevmresponse ) throws rpcexception { logger . info ( _str , deletevmresponse ) ; switch ( deletevmresponse . getresult ( ) ) { case ok : break ; case system_error : throw new systemerrorexception ( deletevmresponse . geterror ( ) ) ; case vm_not_found : throw new vmnotfoundexception ( deletevmresponse . geterror ( ) ) ; case vm_not_powered_off : throw new vmnotpoweredoffexception ( deletevmresponse . geterror ( ) ) ; default : throw new rpcexception ( string . format ( _str , deletevmresponse . getresult ( ) ) ) ; } return deletevmresponse ; }	this method validates a deletevmresponse object , raising an exception if the response reflects an operation failure .
public void runtest ( ) throws throwable { document doc ; nodelist elementlist ; node namenode ; characterdata child ; doc = ( document ) load ( _str , _bool ) ; elementlist = doc . getelementsbytagname ( _str ) ; namenode = elementlist . item ( _num ) ; child = ( characterdata ) namenode . getfirstchild ( ) ; { boolean success = _bool ; try { child . deletedata ( _num , _num ) ; } catch ( domexception ex ) { success = ( ex . code == domexception . index_size_err ) ; } asserttrue ( _str , success ) ; } }	runs the test case .
public void limittransandscale ( matrix matrix , rectf content ) { float [ ] vals = new float [ _num ] ; matrix . getvalues ( vals ) ; float curtransx = vals [ matrix . mtrans_x ] ; float curscalex = vals [ matrix . mscale_x ] ; float curtransy = vals [ matrix . mtrans_y ] ; float curscaley = vals [ matrix . mscale_y ] ; mscalex = math . max ( mminscalex , curscalex ) ; mscaley = math . max ( mminscaley , curscaley ) ; float width = _num ; float height = _num ; if ( content != null ) { width = content . width ( ) ; height = content . height ( ) ; } float maxtransx = - width * ( mscalex - _num ) ; float newtransx = math . min ( math . max ( curtransx , maxtransx - mtransoffsetx ) , mtransoffsetx ) ; float maxtransy = height * ( mscaley - _num ) ; float newtransy = math . max ( math . min ( curtransy , maxtransy + mtransoffsety ) , - mtransoffsety ) ; vals [ matrix . mtrans_x ] = newtransx ; vals [ matrix . mscale_x ] = mscalex ; vals [ matrix . mtrans_y ] = newtransy ; vals [ matrix . mscale_y ] = mscaley ; matrix . setvalues ( vals ) ; }	limits the maximum scale and x translation of the given matrix.
public blazevaluefactory valuefactory ( ) { return vf ; }	return the factory used to round - trip between tinkerpop values and rdf values .
public statefulrefreshtoken ( jsonvalue token ) throws invalidgrantexception { super ( token ) ; if ( ! oauth_refresh_token . equals ( gettokenname ( ) ) ) { throw new invalidgrantexception ( _str + gettokenid ( ) ) ; } }	constructs a new refreshtoken backed with the data in the specified jsonvalue .
public void putstyle ( string styleid , styleselector styleselector ) { try { int id = integer . parseint ( styleid ) ; mmaxstyleid = math . max ( mmaxstyleid , id ) ; } catch ( numberformatexception e ) { } mstyles . put ( styleid , styleselector ) ; }	put the styleselector ( style or stylemap ) in the list of shared styles , associated to its styleid.
private static string extractclientname ( string clientid , string host ) { string hostexcludedid = _str ; if ( ( isipv6 ( host ) || isipv4 ( host ) ) && clientid . startswith ( host ) ) { hostexcludedid = clientid . substring ( host . length ( ) ) ; } else { int firstdotindex = host . indexof ( _str ) ; if ( firstdotindex != - _num ) { string hostshortname = host . substring ( _num , firstdotindex ) ; hostexcludedid = clientid . substring ( hostshortname . length ( ) ) ; } } string vmpidandkindregex = _str ; string regex = _str ; string name = not_available ; string temp = hostexcludedid ; int openindex = temp . indexof ( _str ) ; if ( openindex != - _num ) { regex = vmpidandkindregex + regex ; } if ( temp . matches ( regex ) ) { string [ ] splitted = temp . split ( _str ) ; name = splitted [ splitted . length - _num ] ; } return name ; }	excludes the host name from the client id and returns the string.
public static < t > fastfuture < t > fromcompletablefuture ( final completablefuture < t > cf ) { final fastfuture < t > f = new fastfuture < > ( ) ; cf . thenaccept ( null ) ; cf . exceptionally ( null ) ; return f ; }	internal conversion method to convert completablefutures to fastfuture .
public static boolean isplaceaction ( inventoryaction action ) { switch ( action ) { case swap_with_cursor : case place_one : case place_all : case place_some : return _bool ; } return _bool ; }	check if a given inventoryaction involves placing items into the slot .
private list < view > addview ( view view , list < view > cache ) { if ( cache == null ) { cache = new linkedlist < view > ( ) ; } cache . add ( view ) ; return cache ; }	adds view to specified cache.
public static byte [ ] readinputstream ( inputstream i ) throws ioexception { bytearrayoutputstream b = new bytearrayoutputstream ( ) ; copy ( i , b ) ; return b . tobytearray ( ) ; }	converts a small input stream to a byte array.
public void playmedia ( boolean showplayerwindow ) { string filename = stopandpreparefilename ( ) ; if ( filename . length ( ) > _num ) { mplayermediator mplayermediator = mplayermediator . instance ( ) ; if ( mplayermediator != null ) { mplayermediator . showplayerwindow ( showplayerwindow ) ; } mplayer . open ( filename , getadjustedvolume ( ) ) ; } notifystate ( getstate ( ) ) ; }	force showing or not the media player window.
public static string toutf8string ( string s ) { return new string ( s . getbytes ( ) , charset . forname ( panboxconstants . standard_charset ) ) ; }	string conversion into standard charset.
public static int encodecacheflags ( collection < gridclientcacheflag > flagset ) { int bits = _num ; if ( flagset . contains ( gridclientcacheflag . skip_store ) ) bits |= _num ; return bits ; }	encodes cache flags to bit map .
public void add ( datasource source , boolean visible ) { add ( data . size ( ) , source , visible ) ; }	adds a new data series to the plot .
@ override public void addvalue ( double value , double weight ) { m_weightedsum += value * weight ; m_weightedsumsquared += value * value * weight ; m_sumofweights += weight ; if ( m_tm . get ( value ) == null ) { m_tm . put ( value , weight ) ; } else { m_tm . put ( value , m_tm . get ( value ) + weight ) ; } }	adds a value to the density estimator .
private jpanel buildrow ( final string string , final jcheckbox checkbox ) { final jpanel panel = new jpanel ( new borderlayout ( ) ) ; panel . add ( new jlabel ( string ) , borderlayout . west ) ; panel . add ( checkbox , borderlayout . east ) ; checkbox . additemlistener ( m_checkboxlistener ) ; return panel ; }	builds a checkbox row .
private static synchronized string formatandparse ( simpledateformat formatdate , simpledateformat parsedate , string text ) { try { date date = parsedate . parse ( text ) ; string result = formatdate . format ( date ) ; return result ; } catch ( parseexception e ) { logger . warning ( _str + text ) ; } return _str ; }	synchronized because simpledatformat aren ' t thread safe.
public static boolean ischildgroup ( string group ) { return group . indexof ( group_delimiter ) != - _num ; }	indicates if a group is a child group , a non - top - level data group in a set of nested data groups ( e.
private void throwarrayindexoutofboundsexception ( int itemindex ) { throw new arrayindexoutofboundsexception ( _str + _str + spaceitems . size ( ) + _str + itemindex ) ; }	throw array index out of bounds exception.
private locusinfo createnextuncoveredlocusinfo ( final locus stopbeforelocus ) { while ( lastreferencesequence <= stopbeforelocus . getsequenceindex ( ) && lastreferencesequence <= referencesequencemask . getmaxsequenceindex ( ) ) { if ( lastreferencesequence == stopbeforelocus . getsequenceindex ( ) && lastposition + _num >= stopbeforelocus . getposition ( ) ) { return null ; } final int nextbit = referencesequencemask . nextposition ( lastreferencesequence , lastposition ) ; if ( nextbit == - _num ) { if ( lastreferencesequence == stopbeforelocus . getsequenceindex ( ) ) { lastposition = stopbeforelocus . getposition ( ) ; return null ; } lastreferencesequence ++ ; lastposition = _num ; } else if ( lastreferencesequence < stopbeforelocus . getsequenceindex ( ) || nextbit < stopbeforelocus . getposition ( ) ) { lastposition = nextbit ; return new locusinfo ( getreferencesequence ( lastreferencesequence ) , lastposition ) ; } else if ( nextbit >= stopbeforelocus . getposition ( ) ) { return null ; } } return null ; }	create the next relevant zero - coverage locusinfo.
public void globalconfigchanged ( string servicename , string version , string groupname , string servicecomponent , int changetype ) { }	this method will be invoked when a service ' s global configuation data has been changed.
public static void launchemailintent ( final activity activity , string addr , string text ) { log . i ( log_tag , _str + activity . getlocalclassname ( ) ) ; intent emailintent = new intent ( intent . action_send ) ; emailintent . putextra ( intent . extra_email , new string [ ] { addr } ) ; emailintent . settype ( _str ) ; packagemanager emailpackagemanager = activity . getpackagemanager ( ) ; list < resolveinfo > emailresolveinfos = emailpackagemanager . queryintentactivities ( emailintent , _num ) ; if ( emailresolveinfos . size ( ) > _num ) { activity . startactivity ( emailintent ) ; } }	launch an email intent if the device is capable .
public int count ( ) { return n ; }	returns the number of data values .
public void add ( int position , t item ) { mdata . add ( position , item ) ; notifyiteminserted ( position ) ; }	insert a item associated with the specified position of adapter.
public void addtranslator ( classpool cp , translator t ) throws notfoundexception , cannotcompileexception { source = cp ; translator = t ; t . start ( cp ) ; }	adds a translator , which is called whenever a class is loaded .
public void writelechars ( string s ) throws ioexception { int length = s . length ( ) ; for ( int i = _num ; i < length ; i ++ ) { int c = s . charat ( i ) ; out . write ( c & _num ) ; out . write ( ( c > > > _num ) & _num ) ; } written += length * _num ; }	writes a string in little endian.
public static string readline ( ) { string line ; try { line = scanner . nextline ( ) ; } catch ( nosuchelementexception e ) { line = null ; } return line ; }	reads and returns the next line , excluding the line separator if present .
@ deprecated public boolean isvalid ( string regex ) { if ( regex == null ) { return _bool ; } pattern pattern = pattern . compile ( regex ) ; matcher matcher = pattern . matcher ( gettext ( ) ) ; return matcher . matches ( ) ; }	if the main text matches the regex.
public void writetofile ( string filename ) { gridutils . writespatialgridtable ( this , filename ) ; }	just for debugging convenience.
public void addfooterview ( view v , object data , boolean isselectable ) { fixedviewinfo info = new fixedviewinfo ( ) ; info . view = v ; info . data = data ; info . isselectable = isselectable ; mfooterviewinfos . add ( info ) ; if ( madapter != null && mdatasetobserver != null ) { mdatasetobserver . onchanged ( ) ; } }	add a fixed view to appear at the bottom of the list.
public void addclosehook ( closehook hook ) { if ( closehooks == null ) { closehooks = new arraylist < > ( ) ; } closehooks . add ( hook ) ; }	add a close callback hook.
public void rejectedexecution ( runnable r , threadpoolexecutor e ) { if ( ! e . isshutdown ( ) ) { r . run ( ) ; } }	executes task r in the caller ' s thread , unless the executor has been shut down , in which case the task is discarded .
private void updaterange ( double x , double y ) { mminx = math . min ( mminx , x ) ; mmaxx = math . max ( mmaxx , x ) ; mminy = math . min ( mminy , y ) ; mmaxy = math . max ( mmaxy , y ) ; }	updates the range on both axes .
static boolean checkstandardupceanchecksum ( charsequence s ) throws formatexception { int length = s . length ( ) ; if ( length == _num ) { return _bool ; } int sum = _num ; for ( int i = length - _num ; i >= _num ; i -= _num ) { int digit = ( int ) s . charat ( i ) - ( int ) _str ; if ( digit < _num || digit > _num ) { throw formatexception . getformatinstance ( ) ; } sum += digit ; } sum *= _num ; for ( int i = length - _num ; i >= _num ; i -= _num ) { int digit = ( int ) s . charat ( i ) - ( int ) _str ; if ( digit < _num || digit > _num ) { throw formatexception . getformatinstance ( ) ; } sum += digit ; } return sum % _num == _num ; }	computes the upc / ean checksum on a string of digits , and reports whether the checksum is correct or not .
public void readconfig ( string filename ) throws filenotfoundexception { if ( filename == null || filename . equals ( _str ) ) return ; readconfig ( new filereader ( filename ) ) ; }	read the specified file and parse the configuration .
private void applytradingbonus ( player player ) { player . incrementtradescore ( ) ; }	rewards player for a successfull trade.
public static string slurpurlnoexceptions ( url u ) { try { return slurpurl ( u ) ; } catch ( exception e ) { e . printstacktrace ( ) ; return null ; } }	returns all the text at the given url .
private static void createcombinedtrace ( final tracelist newtrace , final list < tracelist > traces , final set < breakpointaddress > addresses ) { final set < breakpointaddress > visitedaddresses = new linkedhashset < breakpointaddress > ( ) ; for ( final tracelist trace : traces ) { for ( final itraceevent event : trace ) { final breakpointaddress address = event . getoffset ( ) ; if ( ! addresses . contains ( address ) ) { continue ; } if ( visitedaddresses . contains ( address ) ) { continue ; } visitedaddresses . add ( address ) ; newtrace . addevent ( event ) ; } } }	fills a combined trace from the events of multiple input traces .
public void interruptall ( ) { synchronized ( knownactortasks ) { for ( future < void > ft : knownactortasks ) { ft . cancel ( _bool ) ; } threadguard . interruptall ( ) ; } }	ensure that any guarded regions are interrupted .
@ suppresswarnings ( _str ) public void registerdefaultdevicetypes ( ) { final hashmap < string , string > deviceslist = defaultplatform . getdeviceservicemap ( ) ; for ( hashmap . entry < string , string > entry : deviceslist . entryset ( ) ) { string key = entry . getkey ( ) ; string value = entry . getvalue ( ) ; try { registerdeviceservice ( ( class < deviceservice > ) class . forname ( key ) , ( class < discoveryprovider > ) class . forname ( value ) ) ; } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } } }	registers a commonly - used set of deviceservices with discoverymanager.
private static void removedependencysubsets ( string swclocation , map < string , set < string > > dependencymap , swcdependencyinfoimpl depinfo ) { set < string > removeset = new hashset < string > ( ) ; swcexternalscriptinfo externalinfo = depinfo . getswcexternalscriptinfo ( swclocation ) ; map < string , set < string > > externalsbyswc = new hashmap < string , set < string > > ( ) ; for ( string swcdependlocation : dependencymap . get ( swclocation ) ) { for ( string swcdependlocation2 : dependencymap . get ( swclocation ) ) { if ( swcdependlocation . equals ( swcdependlocation2 ) ) continue ; set < string > externalscripts = externalsbyswc . get ( swcdependlocation ) ; set < string > externalscripts2 = externalsbyswc . get ( swcdependlocation2 ) ; if ( externalscripts == null ) { externalscripts = externalinfo . getexternalscripts ( swcdependlocation ) ; externalsbyswc . put ( swcdependlocation , externalscripts ) ; } if ( externalscripts2 == null ) { externalscripts2 = externalinfo . getexternalscripts ( swcdependlocation2 ) ; externalsbyswc . put ( swcdependlocation2 , externalscripts2 ) ; } if ( externalscripts2 . size ( ) > externalscripts . size ( ) && externalscripts2 . containsall ( externalscripts ) ) { removeset . add ( swcdependlocation ) ; break ; } } } set < string > dependencyset = dependencymap . get ( swclocation ) ; dependencyset . removeall ( removeset ) ; }	look at the dependency information and remove swc dependencies that are subsets of other swc dependencies .
private void drawticks ( canvas canvas , double min , double max , double minangle , double maxangle , int centerx , int centery , double longradius , double shortradius , double ticks , paint paint , boolean labels ) { for ( double i = min ; i <= max ; i += ticks ) { double angle = getangleforvalue ( i , minangle , maxangle , min , max ) ; double sinvalue = math . sin ( angle ) ; double cosvalue = math . cos ( angle ) ; int x1 = math . round ( centerx + ( float ) ( shortradius * sinvalue ) ) ; int y1 = math . round ( centery + ( float ) ( shortradius * cosvalue ) ) ; int x2 = math . round ( centerx + ( float ) ( longradius * sinvalue ) ) ; int y2 = math . round ( centery + ( float ) ( longradius * cosvalue ) ) ; canvas . drawline ( x1 , y1 , x2 , y2 , paint ) ; if ( labels ) { paint . settextalign ( align . left ) ; if ( x1 <= x2 ) { paint . settextalign ( align . right ) ; } string text = i + _str ; if ( math . round ( i ) == ( long ) i ) { text = ( long ) i + _str ; } canvas . drawtext ( text , x1 , y1 , paint ) ; } } }	draws the chart tick lines .
public static < t , k , l extends list < t > > bifunction < partition < t , k , l > , t , boolean > alwaysinsert ( ) { return null ; }	returns an insertion policy that indicates the tuple is to be inserted into the partition .
public void testfindspringopenldap ( ) { ldapproxy proxy = getldapopenldap ( ) ; list result = null ; try { result = proxy . find ( getldapsearchvo ( _str , ldapconstants . no_search_limit , null , null , null , ldapscopeconstants . scope_subtree ) ) ; } catch ( exception e ) { } assertnotnull ( result ) ; assertequals ( _num , result . size ( ) ) ; }	test de busqueda open ldap.
public void testconstructorstringradix8 ( ) { string value = _str ; int radix = _num ; byte rbytes [ ] = { _num , - _num , - _num , - _num , - _num , _num , _num } ; biginteger anumber = new biginteger ( value , radix ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = anumber . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , anumber . signum ( ) ) ; }	create a positive number from a string value and radix 8 .
private static boolean inencoding ( char ch , string encoding ) { boolean isinencoding ; try { char carray [ ] = new char [ _num ] ; carray [ _num ] = ch ; string s = new string ( carray ) ; byte [ ] barray = s . getbytes ( encoding ) ; isinencoding = inencoding ( ch , barray ) ; } catch ( exception e ) { isinencoding = _bool ; if ( encoding == null ) isinencoding = _bool ; } return isinencoding ; }	this is heart of the code that determines if a given character is in the given encoding.
public void delete ( ssotoken token , string dn ) throws smsexception , ssoexception { for ( string entry : subentries ( token , dn , _str , _num , _bool , _bool ) ) { debug . message ( _str , entry ) ; delete ( token , getnamingattribute ( ) + _str + entry + _str + dn ) ; } for ( string suborg : searchsuborgnames ( token , dn , _str , _num , _bool , _bool , _bool ) ) { debug . message ( _str , suborg ) ; delete ( token , suborg ) ; } delete ( token . getprincipal ( ) , dn ) ; objectchanged ( dn , delete ) ; }	delete the entry in the directory . this will delete sub - entries also !.
private void removehighlights ( ) { if ( textarea != null ) { rsyntaxtextareahighlighter h = ( rsyntaxtextareahighlighter ) textarea . gethighlighter ( ) ; for ( int i = _num ; i < tags . size ( ) ; i ++ ) { h . removemarkoccurrenceshighlight ( tags . get ( i ) ) ; } } tags . clear ( ) ; }	removes all highlights added to the text area by this listener .
private static < t extends abstractblockbase < t > > void enqueuesuccessors ( t block , priorityqueue < t > worklist , bitset visitedblocks ) { for ( t successor : block . getsuccessors ( ) ) { if ( ! visitedblocks . get ( successor . getid ( ) ) ) { visitedblocks . set ( successor . getid ( ) ) ; worklist . add ( successor ) ; } } }	add successor blocks into the given work list if they are not already marked as visited .
public void addrole ( string role ) { if ( role != null ) { roles . add ( role ) ; } }	add a role to this user .
public cmodulescheckboxpanel ( final cmodulestablemodel modulestablemodel ) { super ( new borderlayout ( ) ) ; final jcheckbox checkbox = new jcheckbox ( _str ) ; checkbox . additemlistener ( new internalcheckboxlistener ( ) ) ; add ( checkbox ) ; m_modulestablemodel = modulestablemodel ; }	creates the checkbox panel to control if full paths should be shown in the modules table .
public qdate ( ) { this ( _gmttimezone ) ; }	creates the date for gmt .
protected void responsesent ( streamresponsemessage responsemessage ) { if ( syncprotocol != null ) syncprotocol . responsesent ( responsemessage ) ; }	must be called by a subclass after the response has been successfully sent to the client .
protected tuple < blobstoreindexshardsnapshots , integer > buildblobstoreindexshardsnapshots ( map < string , blobmetadata > blobs ) { int latest = - _num ; for ( string name : blobs . keyset ( ) ) { if ( name . startswith ( snapshot_index_prefix ) ) { try { int gen = integer . parseint ( name . substring ( snapshot_index_prefix . length ( ) ) ) ; if ( gen > latest ) { latest = gen ; } } catch ( numberformatexception ex ) { logger . warn ( _str , name ) ; } } } if ( latest >= _num ) { try { return new tuple < > ( indexshardsnapshotsformat . read ( blobcontainer , integer . tostring ( latest ) ) , latest ) ; } catch ( ioexception e ) { logger . warn ( _str , e , snapshot_index_prefix + latest ) ; } } list < snapshotfiles > snapshots = new arraylist < > ( ) ; for ( string name : blobs . keyset ( ) ) { try { blobstoreindexshardsnapshot snapshot = null ; if ( name . startswith ( snapshot_prefix ) ) { snapshot = indexshardsnapshotformat . readblob ( blobcontainer , name ) ; } else if ( name . startswith ( legacy_snapshot_prefix ) ) { snapshot = indexshardsnapshotlegacyformat . readblob ( blobcontainer , name ) ; } if ( snapshot != null ) { snapshots . add ( new snapshotfiles ( snapshot . snapshot ( ) , snapshot . indexfiles ( ) ) ) ; } } catch ( ioexception e ) { logger . warn ( _str , e , name ) ; } } return new tuple < > ( new blobstoreindexshardsnapshots ( snapshots ) , - _num ) ; }	loads all available snapshots in the repository.
public forumpostconfig createreply ( forumpostconfig config ) { config . addcredentials ( this ) ; string xml = post ( this . url + _str , config . toxml ( ) ) ; element root = parse ( xml ) ; if ( root == null ) { return null ; } try { forumpostconfig reply = new forumpostconfig ( ) ; reply . parsexml ( root ) ; return reply ; } catch ( exception exception ) { this . exception = sdkexception . parsefailure ( exception ) ; throw this . exception ; } }	create a reply to a forum post.
public boolean isarmed ( ) { return other . isarmed ( ) ; }	all these methods simply delegate to the " other " model that is being decorated .
public static attribkey forhtmlattrib ( elkey el , string localname ) { return new attribkey ( el , html_ns , localname ) ; }	looks up an attribute key by element and local name .
sparsearray ( class < l > lineararraytype , int [ ] rowindices , int [ ] colindices , l realvalues , l imagvalues , int numrows , int numcols ) { validateusersuppliedparameters ( lineararraytype , rowindices , colindices , realvalues , imagvalues ) ; _basecomponenttype = lineararraytype . getcomponenttype ( ) ; _outputarraytype = ( class < l [ ] > ) arrayutils . getarrayclass ( _basecomponenttype , _num ) ; map < sparsekey , sparsevalue > sparsemap = createsparsemap ( lineararraytype , rowindices , colindices , realvalues , imagvalues , numrows , numcols ) ; _numrows = numrows ; _numcols = numcols ; arraylist < sparsekey > keys = new arraylist < sparsekey > ( sparsemap . keyset ( ) ) ; collections . sort ( keys ) ; _rowindices = new int [ keys . size ( ) ] ; _colindices = new int [ keys . size ( ) ] ; _linearindices = new int [ keys . size ( ) ] ; _realvalues = lineararraytype . cast ( array . newinstance ( _basecomponenttype , keys . size ( ) ) ) ; _imagvalues = imagvalues == null ? null : lineararraytype . cast ( array . newinstance ( _basecomponenttype , keys . size ( ) ) ) ; for ( int i = _num ; i < keys . size ( ) ; i ++ ) { sparsekey key = keys . get ( i ) ; _rowindices [ i ] = key . row ; _colindices [ i ] = key . col ; _linearindices [ i ] = key . linearindex ; sparsevalue value = sparsemap . get ( key ) ; setsparsevalue ( value , _realvalues , _imagvalues , i ) ; } }	data provided by a user ; this data needs to be validated and processed .
public static tuple max ( tupleset tuples , string field , comparator cmp ) { if ( tuples instanceof table ) { table table = ( table ) tuples ; columnmetadata md = table . getmetadata ( field ) ; return table . gettuple ( md . getmaximumrow ( ) ) ; } else { return max ( tuples . tuples ( ) , field , cmp ) ; } }	get the tuple with the maximum data field value .
protected void updateradiolinks ( ) { m_cvbut . setenabled ( _bool ) ; m_cvtext . setenabled ( m_cvbut . isselected ( ) ) ; m_cvlab . setenabled ( m_cvbut . isselected ( ) ) ; m_seedtext . setenabled ( m_cvbut . isselected ( ) ) ; m_seedlab . setenabled ( m_cvbut . isselected ( ) ) ; if ( m_attributeevaluatoreditor . getvalue ( ) instanceof attributetransformer ) { m_cvbut . setselected ( _bool ) ; m_cvbut . setenabled ( _bool ) ; m_cvtext . setenabled ( _bool ) ; m_cvlab . setenabled ( _bool ) ; m_seedtext . setenabled ( _bool ) ; m_seedlab . setenabled ( _bool ) ; m_trainbut . setselected ( _bool ) ; } }	updates the enabled status of the input fields and labels .
private string idstring ( int id1 , int id2 ) { return _str + integer . tohexstring ( id2 & _num ) + _str + integer . tohexstring ( id1 & _num ) + _str + ( ( id2 & _num ) * _num + ( id1 & _num ) ) + _str ; }	convert throttle id to a human friendly format .
public etagcache resetstats ( ) { hits . set ( _num ) ; misses . set ( _num ) ; return this ; }	reset stats tracked for cache hits and misses.
public void testothertostringdefault ( ) { numberconverter converter = makeconverter ( ) ; assertequals ( _str , _str , converter . convert ( string . class , new stringbuffer ( _str ) ) ) ; }	convert other - - > string ( default conversion ).
private void removeitematint ( int index , boolean updatechildrenonmenuviews ) { if ( ( index < _num ) || ( index >= mitems . size ( ) ) ) return ; mitems . remove ( index ) ; if ( updatechildrenonmenuviews ) onitemschanged ( _bool ) ; }	remove the item at the given index and optionally forces menu views to update .
public void testshiftright3 ( ) { byte abytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = _num ; int number = _num ; byte rbytes [ ] = { _num , _num , _num , - _num , - _num , - _num , _num , - _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . shiftright ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	shiftright ( int n ) , 0 < n < 32.
private void showfilterdialog ( filter filter ) { int sortorder = madapter . getcount ( ) - _num ; if ( filter == null ) { editfilteractivity . createnewfilter ( getactivity ( ) , sortorder ) ; } else { editfilteractivity . editfilter ( getactivity ( ) , filter , sortorder ) ; } }	shows the filter dialog.
public static int numpixelsbetween ( int x1 , int y1 , int x2 , int y2 ) { return ( int ) math . sqrt ( math . pow ( ( double ) ( x1 - x2 ) , _num ) + math . pow ( ( double ) ( y1 - y2 ) , _num ) ) ; }	little math utility that both tools use , that just implements the pythagorean theorem to do the number of pixels between two screen points .
static boolean allowspopup ( formobject formobject ) { switch ( formobject . getparameterconstant ( pdfdictionary . subtype ) ) { case pdfdictionary . text : case pdfdictionary . square : case pdfdictionary . highlight : case pdfdictionary . underline : case pdfdictionary . strickout : case pdfdictionary . stamp : return _bool ; default : return _bool ; } }	utility method to check if formobject should have a popup.
public static localgitrepo fromcurrentdir ( string remoteurl ) throws validationexception { git git ; file gitdir = new file ( _str ) ; try { git = git . open ( gitdir ) ; } catch ( repositorynotfoundexception rnfe ) { string fullpathofcurrentdir = pathof ( gitdir ) ; file gitroot = getgitrootifitexistsinoneoftheparentdirectories ( new file ( fullpathofcurrentdir ) ) ; string summary ; list < string > messages = new arraylist < string > ( ) ; if ( gitroot == null ) { summary = _str ; messages . add ( summary ) ; messages . add ( fullpathofcurrentdir + _str ) ; } else { summary = _str ; messages . add ( summary ) ; messages . add ( fullpathofcurrentdir + _str ) ; messages . add ( _str + pathof ( gitroot ) ) ; } throw new validationexception ( summary , messages ) ; } catch ( exception e ) { throw new validationexception ( _str + pathof ( gitdir ) + _str , arrays . aslist ( _str , e . tostring ( ) ) ) ; } return new localgitrepo ( git , remoteurl ) ; }	uses the current working dir to open the git repository .
public static vector2 min ( vector2 o1 , vector2 o2 ) { return new vector2 ( math . min ( o1 . x , o2 . x ) , math . min ( o1 . z , o2 . z ) ) ; }	returns a vector2 containing the smallest x and y values .
public void addtestcall ( genericaccessibleobject < ? > call ) throws illegalargumentexception { inputs . checknull ( call ) ; testmethods . add ( call ) ; }	add a test call.
public void serialize ( kxmlserializer serializer ) throws ioexception { mdeviceinfo . serialize ( serializer ) ; serializehostinfo ( serializer ) ; serializetestsummary ( serializer ) ; monkeytag . serialize ( serializer ) ; list < testpackageresult > pkgs = new arraylist < testpackageresult > ( mpackagemap . values ( ) ) ; collections . sort ( pkgs , new pkgcomparator ( ) ) ; for ( testpackageresult r : pkgs ) { r . serialize ( serializer ) ; } }	serialize the test results to xml .
private void verifyblockmirrormigration ( ) throws exception { log . info ( _str ) ; iterator < blockmirror > blockmirroritr = _dbclient . queryiterativeobjects ( blockmirror . class , blockmirroruris ) ; list < blockobject > blockobjects = new arraylist < blockobject > ( ) ; while ( blockmirroritr . hasnext ( ) ) { blockobjects . add ( blockmirroritr . next ( ) ) ; } verifyblockobjects ( blockobjects ) ; }	verify the blockmirror objects have been migrated correctly .
public logformatter ( logger log ) { if ( log == null ) log = logger . getlogger ( logger . global_logger_name ) ; level lvl = null ; while ( log != null ) { lvl = log . getlevel ( ) ; if ( lvl != null ) break ; log = log . getparent ( ) ; } ; if ( lvl == null ) lvl = level . warning ; this . level = lvl ; }	create a log formatter around a given logger.
public synchronized void removetextlistener ( textlistener cl ) { m_textlisteners . remove ( cl ) ; }	remove a text listener.
private element createidpentitydescriptor ( boolean exportprivatedata ) throws exception { element entele = doc . createelementns ( null , samlnames . entdescriptor ) ; string id = idmclient . getentityid ( tenantname ) ; string alias = idmclient . getlocalidpalias ( tenantname ) ; if ( id == null ) { id = tenantname ; } entele . setattribute ( samlnames . entid , id ) ; element idpsso = createidpssodescriptor ( exportprivatedata ) ; entele . appendchild ( idpsso ) ; if ( exportprivatedata ) { if ( alias == null || alias . isempty ( ) ) { alias = id ; } element orgele = createorganization ( tenantname , tenantname , alias , samlnames . english ) ; entele . appendchild ( orgele ) ; } return entele ; }	create extension element of entitydescriptor in dom .
public void clear ( ) { infoqueue . clear ( ) ; while ( ! dataqueue . isempty ( ) ) { allocator . release ( dataqueue . remove ( ) ) ; } totalbytesdropped = _num ; totalbyteswritten = _num ; lastallocation = null ; lastallocationoffset = allocationlength ; }	clears the buffer , returning all allocations to the allocator .
public void applycamera ( gl2 gl ) { gl . glmatrixmode ( gl2 . gl_projection ) ; gl . glloadidentity ( ) ; glu . gluperspective ( _num , width / ( float ) height , _num , _num ) ; eye [ _num ] = ( float ) math . sin ( theta ) * _num ; eye [ _num ] = _num ; eye [ _num ] = ( float ) math . cos ( theta ) * _num ; glu . glulookat ( eye [ _num ] , eye [ _num ] , eye [ _num ] , _num , _num , _num , _num , _num , _num ) ; gl . glmatrixmode ( gl2 . gl_modelview ) ; gl . glloadidentity ( ) ; gl . glviewport ( _num , _num , width , height ) ; }	apply the camera settings .
public static resultset pointtable ( double x , double y ) { geometryfactory factory = new geometryfactory ( ) ; simpleresultset rs = new simpleresultset ( ) ; rs . addcolumn ( _str , types . java_object , _str , _num , _num ) ; rs . addrow ( factory . createpoint ( new coordinate ( x , y ) ) ) ; return rs ; }	this method is called via reflection from the database .
public void addtoexistingvolumesifabsent ( map < string , integer > volumewwns ) { if ( _existingvolumes == null ) { _existingvolumes = new stringmap ( ) ; } for ( string wwn : volumewwns . keyset ( ) ) { string normalizedwwn = blockobject . normalizewwn ( wwn ) ; if ( ! _existingvolumes . containskey ( normalizedwwn ) && ( _useraddedvolumes == null || ! _useraddedvolumes . containskey ( normalizedwwn ) ) ) { string hlustr = exportgroup . lun_unassigned_str ; integer hlu = volumewwns . get ( normalizedwwn ) ; if ( hlu != null ) { hlustr = hlu . tostring ( ) ; } _existingvolumes . put ( normalizedwwn , hlustr ) ; } } }	this method will add to the existing volumes list only those members that don ' t already exist in either the existing or user - created volume list .
public pathimpl createtempfile ( string prefix , string suffix ) throws ioexception { if ( prefix == null || prefix . length ( ) == _num ) prefix = _str ; if ( suffix == null ) suffix = _str ; synchronized ( lock ) { for ( int i = _num ; i < _num ; i ++ ) { int r = math . abs ( ( int ) randomutil . getrandomlong ( ) ) ; pathimpl file = lookup ( prefix + r + suffix ) ; if ( file . createnewfile ( ) ) return file ; } } throw new ioexception ( _str ) ; }	creates a unique temporary file as a child of this directory .
static map < targettype , list < typecompound > > partitionbytargettype ( collection < typecompound > annos , list < typecompound > unmatched , targettype ... targettypes ) { final map < targettype , list < typecompound > > targettypetoannos = new hashmap < > ( ) ; for ( targettype targettype : targettypes ) { targettypetoannos . put ( targettype , new arraylist < typecompound > ( _num ) ) ; } for ( final typecompound anno : annos ) { final list < typecompound > annoset = targettypetoannos . get ( anno . getposition ( ) . type ) ; if ( annoset != null ) { annoset . add ( anno ) ; } else if ( unmatched != null ) { unmatched . add ( anno ) ; } } return targettypetoannos ; }	use a map to partition annotations with the given targettypes into lists , where each target type is a key in the output map . any annotation that does not have one of these target types will be added to unmatched.
public void load ( ) { try { if ( filechannel == null ) { filechannel = filechannel . open ( path , standardopenoption . read ) ; } filechannel . position ( _num ) ; buffer . clear ( ) ; tmp . clear ( ) ; while ( filechannel . read ( tmp ) > _num ) { tmp . flip ( ) ; if ( tmp . remaining ( ) > buffer . capacity ( ) - buffer . position ( ) ) { final bytebuffer next = bytebuffer . allocatedirect ( math . max ( buffer . capacity ( ) * _num , tmp . remaining ( ) ) ) ; buffer . flip ( ) ; next . put ( buffer ) ; buffer = next ; } buffer . put ( tmp ) ; tmp . clear ( ) ; } buffer . flip ( ) ; } catch ( final ioexception e ) { throw new uncheckedioexception ( e ) ; } }	opens a channel to the specified path if it does not already exist.
private void onhpchange ( final int amount ) { if ( user . squareddistanceto ( x , y ) < hearing_distance_sq ) { if ( amount > _num ) { addtextindicator ( _str + amount , notificationtype . positive ) ; } else { addtextindicator ( string . valueof ( amount ) , notificationtype . negative ) ; } } }	called when entity adjusts hp .
@ notnull private file resolvename ( @ notnull string name ) throws ioexception { file file ; if ( name . startswith ( root ) ) { file = new file ( mytemplaterootfolder , name . substring ( root . length ( ) ) ) ; } else if ( mylasttemplatefolders != null ) { file = new file ( mylasttemplatefolders . peek ( ) , name ) ; } else { file = new file ( mytemplaterootfolder , name ) ; } return file . getcanonicalfile ( ) ; }	resolve a freemarker name reference .
public void inittooltip ( ) { if ( ttmanager == null ) { ttmanager = tooltipmanager . sharedinstance ( ) ; ttmanager . registercomponent ( map ) ; ttmanager . setenabled ( _bool ) ; return ; } if ( map != null ) { map . settooltiptext ( null ) ; } }	this method should be called to initialize the tooltip status so that an old tooltip doesn ' t remain when a layer starts listening to mouse events .
public static string [ ] decodearray ( string encodedarray ) { string [ ] items = encodedarray . split ( _str ) ; arraylist < string > list = new arraylist < string > ( ) ; for ( int i = _num ; i < items . length ; i ++ ) { string item = items [ i ] ; item = gsub ( _str , _str , item ) ; if ( ! item . equals ( _str ) ) { list . add ( item ) ; } } return list . toarray ( new string [ list . size ( ) ] ) ; }	decodes a string generated by encodearray .
public boolean computeangleoffset ( ) { if ( mfinished ) { return _bool ; } long systemclock = animationutils . currentanimationtimemillis ( ) ; long timepassed = systemclock - mstarttime ; if ( timepassed < mduration ) { switch ( mmode ) { case scroll_mode : float sc = ( float ) timepassed / mduration ; mcurrangle = mstartangle + math . round ( mdeltaangle * sc ) ; break ; case fling_mode : float timepassedseconds = timepassed / _num ; float distance ; if ( mvelocity < _num ) { distance = mcoeffvelocity * mvelocity * timepassedseconds - ( mdeceleration * timepassedseconds * timepassedseconds / _num ) ; } else { distance = - mcoeffvelocity * mvelocity * timepassedseconds - ( mdeceleration * timepassedseconds * timepassedseconds / _num ) ; } mcurrangle = mstartangle - math . signum ( mvelocity ) * math . round ( distance ) ; break ; } return _bool ; } else { mfinished = _bool ; return _bool ; } }	call this when you want to know the new location.
public long sigignore ( ) { return long . parselong ( fields [ _num ] ) ; }	the bitmap of ignored signals , displayed as a decimal number.
private static byte [ ] generateseed ( ) { try { final bytearrayoutputstream seedbuffer = new bytearrayoutputstream ( ) ; final dataoutputstream seedbufferout = new dataoutputstream ( seedbuffer ) ; seedbufferout . writelong ( system . currenttimemillis ( ) ) ; seedbufferout . writelong ( system . nanotime ( ) ) ; seedbufferout . writeint ( process . mypid ( ) ) ; seedbufferout . writeint ( process . myuid ( ) ) ; seedbufferout . write ( build_fingerprint_and_device_serial ) ; seedbufferout . close ( ) ; return seedbuffer . tobytearray ( ) ; } catch ( final ioexception e ) { throw new securityexception ( _str , e ) ; } }	generates a device - and invocation - specific seed to be mixed into the linux prng .
public string render ( valueexpr theexpr ) throws exception { theexpr . visit ( this ) ; return mbuffer . tostring ( ) ; }	return the rendering of the valueexpr object.
public void stopsampling ( ) { if ( msamplingcounter . decrementandget ( ) == _num ) { mhandler . stopsamplingthread ( ) ; addfinalsample ( ) ; } }	finish sampling and prevent further changes to the connectionclass until another timer is started .
public static final void reversewinding ( list < vector2 > points ) { if ( points == null ) throw new nullpointerexception ( messages . getstring ( _str ) ) ; int size = points . size ( ) ; if ( size == _num || size == _num ) return ; collections . reverse ( points ) ; }	reverses the order of the polygon points within the given list.
public dsigncsr ( jframe parent , pkcs10certificationrequest pkcs10csr , file csrfile , privatekey signprivatekey , keypairtype signkeypairtype , x509certificate verificationcertificate , provider provider ) throws cryptoexception { super ( parent , dialog . modalitytype . document_modal ) ; this . pkcs10csr = pkcs10csr ; this . csrfile = csrfile ; this . signprivatekey = signprivatekey ; this . signkeypairtype = signkeypairtype ; this . verificationcertificate = verificationcertificate ; this . provider = provider ; settitle ( res . getstring ( _str ) ) ; initcomponents ( ) ; }	creates a new dsigncsr dialog for a pkcs # 10 formatted csr .
protected static void init ( ) { string notificationfactoryclassname = null ; try { notificationfactoryclassname = system . getproperty ( notification_factory_name ) ; } catch ( securityexception e ) { throw new runtimeexception ( e ) ; } if ( notificationfactoryclassname != null ) { class < ? > nfc ; try { nfc = class . forname ( notificationfactoryclassname ) ; factory = ( inotificationmanagerfactory ) nfc . newinstance ( ) ; } catch ( classnotfoundexception | instantiationexception | illegalaccessexception e ) { throw new runtimeexception ( e ) ; } } else { factory = new syslognotificationfactory ( ) ; } }	a simple mechanism to initialize factory with dynamic binding.
private int awaitdone ( boolean timed , long nanos ) throws interruptedexception { final long deadline = timed ? system . nanotime ( ) + nanos : _num ; waitnode q = null ; boolean queued = _bool ; for ( ; ; ) { if ( thread . interrupted ( ) ) { removewaiter ( q ) ; throw new interruptedexception ( ) ; } int s = state ; if ( s > completing ) { if ( q != null ) q . thread = null ; return s ; } else if ( s == completing ) thread . yield ( ) ; else if ( q == null ) q = new waitnode ( ) ; else if ( ! queued ) queued = unsafe . compareandswapobject ( this , waitersoffset , q . next = waiters , q ) ; else if ( timed ) { nanos = deadline - system . nanotime ( ) ; if ( nanos <= _num ) { removewaiter ( q ) ; return state ; } locksupport . parknanos ( this , nanos ) ; } else locksupport . park ( this ) ; } }	awaits completion or aborts on interrupt or timeout .
public static double clamp ( double value , double low , double high ) { return math . min ( math . max ( value , low ) , high ) ; }	clamp a value to be within the provided range .
public static string parsevolumehostdirectory ( string volume ) { if ( stringutils . isempty ( volume ) ) { return volume ; } if ( ! volume . contains ( host_container_dir_delimiter ) ) { return volume ; } string [ ] hostcontainerdir = volume . split ( host_container_dir_delimiter ) ; if ( hostcontainerdir . length != _num ) { throw new illegalargumentexception ( _str ) ; } string hostdir = hostcontainerdir [ _num ] ; return hostdir ; }	parses volume host directory only .
private string fmttime ( double time ) { return utilities . pad ( timeformatter . format ( time ) + _str , _num ) ; }	formats times into a standard format .
@ override public synchronized object [ ] toarray ( ) { object [ ] result = new object [ elementcount ] ; system . arraycopy ( elementdata , _num , result , _num , elementcount ) ; return result ; }	returns a new array containing all elements contained in this vector .
public static string right ( string s , int width , char fillchar ) { if ( s . length ( ) >= width ) { return s ; } stringbuffer sb = new stringbuffer ( width ) ; for ( int i = width - s . length ( ) ; -- i >= _num ; ) { sb . append ( fillchar ) ; } sb . append ( s ) ; return sb . tostring ( ) ; }	right justify a string .
public synchronized boolean addall ( collection < ? extends e > c ) { modcount ++ ; object [ ] a = c . toarray ( ) ; int numnew = a . length ; ensurecapacityhelper ( elementcount + numnew ) ; system . arraycopy ( a , _num , elementdata , elementcount , numnew ) ; elementcount += numnew ; return numnew != _num ; }	appends all of the elements in the specified collection to the end of this vector , in the order that they are returned by the specified collection ' s iterator.
@ override public void update ( defaultapplicationstate transstate ) { newcheckpoint ( transstate . getstate ( ) , transstate . getstatehash ( ) , transstate . getlastcheckpointcid ( ) ) ; setlastcheckpointcid ( transstate . getlastcheckpointcid ( ) ) ; }	updates this log , according to the information contained in the transferablestate object.
public static byte [ ] stringtoutf8bytes ( string string ) { int len = string . length ( ) ; byte [ ] bytes = new byte [ len * _num ] ; int outat = _num ; for ( int i = _num ; i < len ; i ++ ) { char c = string . charat ( i ) ; if ( ( c != _num ) && ( c < _num ) ) { bytes [ outat ] = ( byte ) c ; outat ++ ; } else if ( c < _num ) { bytes [ outat ] = ( byte ) ( ( ( c > > _num ) & _num ) | _num ) ; bytes [ outat + _num ] = ( byte ) ( ( c & _num ) | _num ) ; outat += _num ; } else { bytes [ outat ] = ( byte ) ( ( ( c > > _num ) & _num ) | _num ) ; bytes [ outat + _num ] = ( byte ) ( ( ( c > > _num ) & _num ) | _num ) ; bytes [ outat + _num ] = ( byte ) ( ( c & _num ) | _num ) ; outat += _num ; } } byte [ ] result = new byte [ outat ] ; system . arraycopy ( bytes , _num , result , _num , outat ) ; return result ; }	converts a string into its java - style utf - 8 form.
private list < pair < string , object > > topairlist ( final map < string , object > bindings ) { final list < pair < string , object > > blist = new arraylist < pair < string , object > > ( ) ; for ( final map . entry < string , object > pair : bindings . entryset ( ) ) { blist . add ( new pair < string , object > ( pair . getkey ( ) , pair . getvalue ( ) ) ) ; } return blist ; }	converts a hash map of bindings to a list of binding pairs .
@ override public boolean validatelabel ( string label ) { objects . requirenonnull ( label , _str ) ; return ! labels . contains ( label ) ; }	checks the given label can be added / removed to / from a vertex .
public void addmessageobserver ( final messageobserver observer ) { if ( observer == null ) { throw new nullpointerexception ( ) ; } else if ( messageobservers == null ) { initmessageobserverlist ( ) ; } messageobservers . add ( observer ) ; }	adds the specified message observer .
public void show ( char initialchar ) { initialstring = initialstring . append ( initialchar ) ; show ( ) ; if ( swt . getplatform ( ) != _str ) { setedittext ( initialstring . tostring ( ) ) ; } }	performs show and sets the edit string to be the initial character or string.
private static void byte2hex ( byte b , stringbuffer buf ) { int high = ( ( b & _num ) > > _num ) ; int low = ( b & _num ) ; buf . append ( hex_digits [ high ] ) ; buf . append ( hex_digits [ low ] ) ; }	description of the method.
public e remove ( int index ) { hashcodeuptodate = _bool ; modcount ++ ; e oldvalue = elementdata ( index ) ; int nummoved = size - index - _num ; if ( nummoved > _num ) system . arraycopy ( elementdata , index + _num , elementdata , index , nummoved ) ; elementdata [ -- size ] = null ; return oldvalue ; }	removes the element at the specified position in this list.
public static doublevector rnorm ( int n , double mean , double sd , random random ) { if ( sd < _num ) throw new illegalargumentexception ( _str ) ; if ( sd == _num ) return new doublevector ( n , mean ) ; doublevector v = new doublevector ( n ) ; for ( int i = _num ; i < n ; i ++ ) v . set ( i , ( random . nextgaussian ( ) + mean ) / sd ) ; return v ; }	generates a sample of a normal distribution .
protected void warningoccurred ( int code ) { cblock . lock ( ) ; try { if ( ( code < _num ) || ( code > max_warning ) ) { throw new internalerror ( _str ) ; } processwarningoccurred ( _str , integer . tostring ( code ) ) ; } finally { cblock . unlock ( ) ; } }	called by the native code or other classes to signal a warning.
public boolean isknownsub ( string subname ) { return known_subs . contains ( subname ) ; }	checks if sub is indexed .
public string diff_text1 ( linkedlist < diff > diffs ) { stringbuilder text = new stringbuilder ( ) ; for ( diff adiff : diffs ) { if ( adiff . operation != operation . insert ) { text . append ( adiff . text ) ; } } return text . tostring ( ) ; }	compute and return the source text ( all equalities and deletions ) .
public boolean isstored ( ) { return integer . signum ( id ) != - _num ; }	determines whether the view was previously stored to the database .
public static biginteger sizeofdirectoryasbiginteger ( file directory ) { checkdirectory ( directory ) ; final file [ ] files = directory . listfiles ( ) ; if ( files == null ) { return biginteger . zero ; } biginteger size = biginteger . zero ; for ( final file file : files ) { try { if ( ! issymlink ( file ) ) { size = size . add ( biginteger . valueof ( sizeof ( file ) ) ) ; } } catch ( ioexception ioe ) { } } return size ; }	counts the size of a directory recursively ( sum of the length of all files ) .
public boolean issearchlightbit ( int bit ) { if ( nodetype != smini ) { log . error ( _str ) ; return ( _bool ) ; } if ( ( bit < _num ) || ( bit > _num ) ) { log . error ( _str + integer . tostring ( bit ) ) ; return ( _bool ) ; } if ( locsearchlightbits [ bit ] == _num ) { return ( _bool ) ; } return ( _bool ) ; }	query searchlightbits by bit number ( smini only ) bit - bitnumber of the either bit of an oscillating search light bit pair note : returns ' true ' if bit is an oscillating searchlightbit , otherwise ' false ' is returned.
public agefilefilter ( date cutoffdate , boolean acceptolder ) { this ( cutoffdate . gettime ( ) , acceptolder ) ; }	constructs a new age file filter for files on any one side of a certain cutoff date .
public void calcmajortick ( ) { majortick = _num ; majortickcount = ( int ) math . round ( log10 ( maxtick / mintick ) ) + _num ; }	calculate the optimum major tick distance .
public boolean next ( ) throws genericdatasourceexception { try { return _rs . next ( ) ; } catch ( sqlexception sqle ) { throw new genericdatasourceexception ( _str + _sql , sqle ) ; } }	test if there more records available.
public void put ( string sample , hiddenattribute attribute , object value ) { put ( sample , attribute . tostring ( ) , value ) ; }	put a value in the table.
public boolean unsetordering ( object first , object second ) { digraphnode firstponode = ( digraphnode ) ponodes . get ( first ) ; digraphnode secondponode = ( digraphnode ) ponodes . get ( second ) ; return firstponode . removeedge ( secondponode ) || secondponode . removeedge ( firstponode ) ; }	removes any ordering between two nodes .
public string convertswftohtml ( inputstream in ) throws exception { stringwriter out1 = new stringwriter ( ) ; output = new printwriter ( out1 ) ; tagparser parser = new tagparser ( this ) ; swfreader reader = new swfreader ( parser , in ) ; reader . readfile ( ) ; in . close ( ) ; sizecount = reader . size ; final string ret = _str + ( headerstr . isempty ( ) ? _str : _str + headerstr + _str ) + out1 . tostring ( ) + _str ; return ret ; }	parses swf input and extracts text and wrap it as html.
public void write ( classfile classfile , file f ) throws ioexception { fileoutputstream f_out = new fileoutputstream ( f ) ; try { write ( classfile , f_out ) ; } finally { f_out . close ( ) ; } }	write a classfile data structure to a file .
public connection ( final inetsocketaddress peeraddress ) { this ( peeraddress , ( handshaker ) null ) ; }	creates a new connection to a given peer .
protected static vector converttovector ( final object [ ] anarray ) { if ( anarray == null ) { return null ; } final vector v = new vector ( anarray . length ) ; for ( final object element : anarray ) { v . addelement ( element ) ; } return v ; }	returns a vector that contains the same objects as the array .
protected synchronized void notifyversion ( sprogversion v ) { ver = v ; for ( sprogversionlistener listener : getcopyoflisteners ( ) ) { try { listener . notifyversion ( ver ) ; versionlisteners . remove ( listener ) ; } catch ( exception e ) { log . warn ( _str + listener + _str + e ) ; } } }	notify all registered listeners of the sprog version.
protected void acceptdrop ( int dropoperation ) { droptargetcontextpeer peer = getdroptargetcontextpeer ( ) ; if ( peer != null ) { peer . acceptdrop ( dropoperation ) ; } }	called to signal that the drop is acceptable using the specified operation.
public void clear ( ) { oredcriteria . clear ( ) ; orderbyclause = null ; distinct = _bool ; }	this method was generated by mybatis generator . this method corresponds to the database table help_tip.
@ override public string tostring ( ) { string result ; result = super . tostring ( ) ; if ( m_capabilitiesfilter != null ) { initcapabilities ( ) ; if ( m_capabilities != null ) { if ( m_capabilities . supportsmaybe ( m_capabilitiesfilter ) && ! m_capabilities . supports ( m_capabilitiesfilter ) ) { result = _str + maybe_support + _str + result + _str ; } else if ( ! m_capabilities . supports ( m_capabilitiesfilter ) ) { result = _str + no_support + _str + result + _str ; } } } return result ; }	returns a string representation of this treenode .
public date modifieddate ( string path ) throws illegalstateexception , ioexception , ftpillegalreplyexception , ftpexception { synchronized ( lock ) { if ( ! connected ) { throw new illegalstateexception ( _str ) ; } if ( ! authenticated ) { throw new illegalstateexception ( _str ) ; } communication . sendftpcommand ( _str + path ) ; ftpreply r = communication . readftpreply ( ) ; touchautonooptimer ( ) ; if ( ! r . issuccesscode ( ) ) { throw new ftpexception ( r ) ; } string [ ] messages = r . getmessages ( ) ; if ( messages . length != _num ) { throw new ftpillegalreplyexception ( ) ; } else { try { return mdtm_date_format . parse ( messages [ _num ] ) ; } catch ( parseexception e ) { throw new ftpillegalreplyexception ( ) ; } } } }	this method asks and returns the last modification date of a file or directory .
public boolean importpkcs8 ( ) { return jrbpkcs8 . isselected ( ) ; }	has the user chosen to import from pkcs # 8 private key and certificate file combination ?.
public controlflowgraph run ( compilationunittree root , processingenvironment env , methodtree tree , classtree classtree ) { underlyingast underlyingast = new cfgmethod ( tree , classtree ) ; return run ( root , env , underlyingast ) ; }	build the control flow graph of a method .
private boolean isvalidengine ( ) { if ( hasflag ( ~ ( clan_engine | tank_engine | large_engine | superheavy_engine | support_vee_engine ) ) ) { problem . append ( _str + engineflags ) ; return _bool ; } if ( hasflag ( support_vee_engine ) && ( enginetype != steam ) && ( enginetype != combustion_engine ) && ( enginetype != battery ) && ( enginetype != fuel_cell ) && ( enginetype != solar ) && ( enginetype != fission ) && ( enginetype != normal_engine ) && ( enginetype != none ) ) { problem . append ( _str ) ; return _bool ; } if ( ( ( ( int ) math . ceil ( enginerating / _num ) > engine_ratings . length ) || ( enginerating < _num ) ) && ! hasflag ( support_vee_engine ) ) { problem . append ( _str + enginerating ) ; return _bool ; } if ( ( enginerating > _num ) && ! hasflag ( support_vee_engine ) ) { engineflags |= large_engine ; } switch ( enginetype ) { case combustion_engine : case normal_engine : case xl_engine : case xxl_engine : case fuel_cell : case none : case maglev : case battery : case solar : break ; case compact_engine : if ( hasflag ( large_engine ) ) { problem . append ( messages . getstring ( _str ) ) ; return _bool ; } break ; case light_engine : case fission : if ( hasflag ( clan_engine ) ) { problem . append ( messages . getstring ( _str ) ) ; return _bool ; } break ; default : problem . append ( _str + enginetype ) ; return _bool ; } return _bool ; }	sanity checks the engine , no negative ratings , and similar checks .
static public void assertequals ( string message , float expected , float actual , float delta ) { if ( float . isinfinite ( expected ) ) { if ( ! ( expected == actual ) ) failnotequals ( message , new float ( expected ) , new float ( actual ) ) ; } else if ( ! ( math . abs ( expected - actual ) <= delta ) ) failnotequals ( message , new float ( expected ) , new float ( actual ) ) ; }	asserts that two floats are equal concerning a delta.
private void calculated ( double [ ] b ) { int length = mextremalindices . size ( ) - _num ; md = new double [ length ] ; for ( int k = _num ; k < length ; k ++ ) { md [ k ] = b [ k ] * ( mgrid . getcosinefrequencygrid ( ) [ mextremalindices . get ( k ) ] - mgrid . getcosinefrequencygrid ( ) [ mextremalindices . get ( length ) ] ) ; } }	calculates the set of d values for the current extremal index set . implements oppenheim / schafer discrete time signal processing , 3e , 2016 , equation 116c.
private static properties loadproperties ( string propertiesfile ) { properties properties = new properties ( ) ; try ( inputstream is = new fileinputstream ( propertiesfile ) ) { properties . load ( is ) ; } catch ( ioexception e ) { throw new runtimeexception ( _str , e ) ; } return properties ; }	loads properties from a properties file on the local filesystem .
public texteditor replaceall ( pattern pattern , replacement replacement ) { matcher m = pattern . matcher ( text ) ; int lastindex = _num ; stringbuilder sb = new stringbuilder ( ) ; while ( m . find ( ) ) { sb . append ( text . subsequence ( lastindex , m . start ( ) ) ) ; sb . append ( replacement . replacement ( m ) ) ; lastindex = m . end ( ) ; } sb . append ( text . subsequence ( lastindex , text . length ( ) ) ) ; text = sb ; return this ; }	replace all occurrences of the pattern.
public map < string , map < string , string > > list ( string servicename ) { map < string , map < string , string > > results = new hashmap < string , map < string , string > > ( ) ; serviceinfo [ ] infos = jmdns . list ( _str + servicename + _str ) ; for ( serviceinfo info : infos ) { _log . info ( _str , info ) ; final string [ ] hostaddrs = info . gethostaddresses ( ) ; final stringbuffer buf = new stringbuffer ( ) ; for ( string hostaddr : hostaddrs ) { buf . append ( hostaddr ) ; buf . append ( _str ) ; } final string key = buf . tostring ( ) ; _log . info ( _str , key ) ; final map < string , string > values = new hashmap < string , string > ( ) ; for ( enumeration < string > e = info . getpropertynames ( ) ; e . hasmoreelements ( ) ; ) { final string prop = e . nextelement ( ) ; final string value = new string ( info . getpropertybytes ( prop ) ) ; _log . info ( _str , prop , value ) ; values . put ( prop , value ) ; } if ( values . isempty ( ) ) { _log . warn ( _str , key ) ; } results . put ( key , values . isempty ( ) ? null : values ) ; } return results ; }	list published node ( s ) configuration in the network via multicast.
@ suppresswarnings ( { _str } ) @ override default lazyfuturestream < u > concat ( final stream < ? extends u > other ) { return fromstream ( stream . concat ( streamsupport . stream ( spliterators . spliteratorunknownsize ( iterator ( ) , spliterator . ordered ) , _bool ) , streamsupport . stream ( spliterators . spliteratorunknownsize ( other . iterator ( ) , spliterator . ordered ) , _bool ) ) ) ; }	concatenate two streams . / / ( 1 , 2 , 3 , 4 , 5 , 6 ) lazyfuturestream . of ( 1 , 2 , 3 ) . concat ( lazyfuturestream . of ( 4 , 5 , 6 ) ).
@ override public void readexternal ( objectinput in ) throws ioexception { path = igfsutils . readpath ( in ) ; blocksize = in . readint ( ) ; grpblocksize = in . readlong ( ) ; len = in . readlong ( ) ; props = u . readstringmap ( in ) ; accesstime = in . readlong ( ) ; modificationtime = in . readlong ( ) ; flags = in . readbyte ( ) ; }	reads object from data input .
public standardxyitemlabelgenerator ( ) { this ( default_item_label_format , numberformat . getnumberinstance ( ) , numberformat . getnumberinstance ( ) ) ; }	creates an item label generator using default number formatters .
public vector2 ( double direction ) { this . x = math . cos ( direction ) ; this . y = math . sin ( direction ) ; }	creates a unit length vector in the given direction .
public double adjustedpow10 ( double val ) { boolean negflag = ( val < _num ) ; if ( negflag ) { val = - val ; } double res ; if ( val < _num ) { res = ( math . pow ( _num , val + _num ) - _num ) / _num ; } else { res = math . pow ( _num , val ) ; } return negflag ? ( - res ) : res ; }	returns an adjusted power of 10 value for graphing purposes.
@ override public void clear ( ) { columnlist . foreach ( null ) ; }	clears all the data from this table.
public boolean islastinvoice ( ) { string cm = getcostingmethod ( ) ; return cm != null && cm . equals ( costingmethod_lastinvoice ) ; }	is last invoice costing method.
public static void proxyport ( final int port ) { final string portvalue = integer . tostring ( port ) ; setproperty ( _str , portvalue ) ; setproperty ( _str , portvalue ) ; }	set the ' http.
public static string fetchclustername ( string clustercgname ) { string clustername = null ; if ( clustercgname != null && ! clustercgname . isempty ( ) ) { string [ ] tmp = clustercgname . split ( splitter ) ; clustername = tmp [ _num ] ; } return clustername ; }	parses out the cluster name from the combined cluster / cg name .
private void fetchmyservicecardsfromserver ( ) { retrocallback retrocallback ; retrocallback = new retrocallback ( this ) ; retrocallback . setrequestid ( httpconstants . apiresponsecodes . get_my_services ) ; retrocallbacklist . add ( retrocallback ) ; myeloapi . getmyservicecards ( retrocallback ) ; }	helper http function to get list of my service cards .
public dviewasymmetrickeyfields ( jdialog parent , string title , rsapublickey rsapublickey ) { super ( parent , title , dialog . modalitytype . document_modal ) ; key = rsapublickey ; initfields ( ) ; }	creates new dviewasymmetrickeyfields dialog .
public list < colourchange > sampleconditionalmigrationevents2 ( int parentcolour , double parentheight , int childcolour , double childheight , double [ ] m ) { list < colourchange > colourchanges = new arraylist < colourchange > ( ) ; if ( parentheight < childheight ) { throw new illegalargumentexception ( _str + parentheight + _str + childheight + _str ) ; } try { int currentcolour = parentcolour ; double currentheight = parentheight ; while ( _bool ) { colourchange nextevent = randomconditionalmigrationevent ( currentcolour , currentheight , childcolour , childheight , m ) ; currentheight = nextevent . gettime ( ) ; currentcolour = nextevent . getcolourabove ( ) ; colourchanges . add ( nextevent ) ; } } catch ( noeventexception nee ) { } reversecolourchangelist ( colourchanges , parentcolour ) ; return colourchanges ; }	samples migration events on a two - coloured branch , conditional on colours at both ends migration process is forwards in ( natural ) time , so we are going down the tree.
public static boolean isattribute ( object objvalue ) { if ( objvalue instanceof string ) { string stringvalue = ( string ) objvalue ; if ( stringvalue . startswith ( attribute_start ) && stringvalue . endswith ( attribute_end ) ) { return _bool ; } } return _bool ; }	checks if string is actually an attribute .
public static string decodeascii ( final byte [ ] key , final int off , final int len ) { final byte [ ] b = new byte [ len ] ; system . arraycopy ( key , off , b , _num , len ) ; for ( int i = _num ; i < len ; i ++ ) { b [ i ] = decodebyte ( b [ i ] ) ; } try { return new string ( b , _str ) ; } catch ( unsupportedencodingexception e ) { throw new runtimeexception ( e ) ; } }	decodes an ascii string from a key .
@ override public void valuechanged ( treeselectionevent e ) { if ( preventevent ) { return ; } if ( mainframe != null ) { list < operator > selectedoperators = getselectedoperators ( ) ; if ( selectedoperators != null && ! selectedoperators . isempty ( ) ) { mainframe . selectoperators ( selectedoperators ) ; } } }	this method will be invoked after a user selection of an operator in the tree.
public synchronized void removepropertychangelistener ( propertychangelistener listener ) { listeners . remove ( listener ) ; }	removes a property change listener .
final boolean transferaftercancelledwait ( node node ) { if ( compareandsetwaitstatus ( node , node . condition , _num ) ) { enq ( node ) ; return _bool ; } while ( ! isonsyncqueue ( node ) ) thread . yield ( ) ; return _bool ; }	transfers node , if necessary , to sync queue after a cancelled wait.
private static intent createshareintent ( context context , final string sharetext ) { final intent shareintent = new intent ( intent . action_send ) ; shareintent . putextra ( android . content . intent . extra_subject , context . getstring ( r . string . share_subject ) ) ; shareintent . putextra ( android . content . intent . extra_text , sharetext ) ; shareintent . settype ( _str ) ; return shareintent ; }	creates a share intent.
public static < u > atomicintegerfieldupdater < u > newupdater ( class < u > tclass , string fieldname ) { if ( unsafeholder . isavailable ( ) ) { return new atomicintegerfieldupdaterimpl < u > ( tclass , fieldname ) ; } return atomicintegerfieldupdater . newupdater ( tclass , fieldname ) ; }	creates an updater for objects with the given field.
public map < string , object > convertdatatoobjects ( map < string , string > data ) { map < string , object > results = new hashmap < > ( ) ; if ( data != null ) { for ( string key : data . keyset ( ) ) { results . put ( key , data . get ( key ) ) ; } } return results ; }	internal conversion . this is needed to support the current springboot actuator auditeventrepository interface.
private static pair < string , string > offsetlsr ( final long offset , final itranslationenvironment environment , final list < reilinstruction > instructions , final string registernodevalue1 , final string registernodevalue2 , final string immediatenodevalue ) { final string address = environment . getnextvariablestring ( ) ; final string tmpvar1 = environment . getnextvariablestring ( ) ; final string tmpvar2 = environment . getnextvariablestring ( ) ; final string index = environment . getnextvariablestring ( ) ; long baseoffset = offset ; instructions . add ( reilhelpers . createbsh ( baseoffset ++ , dw , registernodevalue2 , dw , _str + immediatenodevalue , qw , tmpvar1 ) ) ; instructions . add ( reilhelpers . createand ( baseoffset ++ , qw , tmpvar1 , dw , dwordbitmask , dw , index ) ) ; instructions . add ( reilhelpers . createadd ( baseoffset ++ , dw , registernodevalue1 , dw , index , dw , tmpvar2 ) ) ; instructions . add ( reilhelpers . createand ( baseoffset ++ , dw , tmpvar2 , dw , dwordbitmask , dw , address ) ) ; return new pair < string , string > ( address , registernodevalue1 ) ; }	operation : [ < rn > , + / - < rm > , lsr # < shift_imm > ] 0b01 / lsr / if shift_imm = = 0 then / lsr # 32 / index = 0 else index = rm logical_shift_right shift_imm if u = = 1 then address = rn + index else / u = = 0 / address = rn - index.
public static rowlimitspec buildrowlimitspec ( esperepl2grammarparser . rowlimitcontext ctx ) { object numrows ; object offset ; if ( ctx . o != null ) { numrows = parsenumorvariableident ( ctx . n1 , ctx . i1 ) ; offset = parsenumorvariableident ( ctx . n2 , ctx . i2 ) ; } else if ( ctx . c != null ) { offset = parsenumorvariableident ( ctx . n1 , ctx . i1 ) ; numrows = parsenumorvariableident ( ctx . n2 , ctx . i2 ) ; } else { numrows = parsenumorvariableident ( ctx . n1 , ctx . i1 ) ; offset = null ; } integer numrowsint = null ; string numrowsvariable = null ; if ( numrows instanceof string ) { numrowsvariable = ( string ) numrows ; } else { numrowsint = ( integer ) numrows ; } integer offsetint = null ; string offsetvariable = null ; if ( offset instanceof string ) { offsetvariable = ( string ) offset ; } else { offsetint = ( integer ) offset ; } return new rowlimitspec ( numrowsint , offsetint , numrowsvariable , offsetvariable ) ; }	builds a row limit specification .
public final int first_common_layer ( brditem p_other ) { int max_first_layer = math . max ( first_layer ( ) , p_other . first_layer ( ) ) ; int min_last_layer = math . min ( last_layer ( ) , p_other . last_layer ( ) ) ; if ( max_first_layer > min_last_layer ) { return - _num ; } return max_first_layer ; }	returns the first layer , where both this item and p_other have a shape.
public itemstack removeitems ( itemstack drive , itemstack stack , int amountwanted ) { if ( getmaxkilobits ( drive ) == - _num ) return null ; int stored = getamountstored ( drive , stack ) ; int amountgiven = math . min ( amountwanted , stored ) ; if ( amountgiven > _num ) { setamountstored ( drive , stack , stored - amountgiven ) ; stack . stacksize += amountgiven ; markdirty ( drive ) ; } return stack ; }	take as many items as possible , up to the passed limit , from a drive into the given stack.
public void saveindexes ( ) { arraylist tosave = new arraylist ( ) ; synchronized ( this ) { object [ ] valuetable = this . indexes . valuetable ; for ( int i = _num , l = valuetable . length ; i < l ; i ++ ) { index index = ( index ) valuetable [ i ] ; if ( index != null ) tosave . add ( index ) ; } } boolean allsaved = _bool ; for ( int i = _num , length = tosave . size ( ) ; i < length ; i ++ ) { index index = ( index ) tosave . get ( i ) ; readwritemonitor monitor = index . monitor ; if ( monitor == null ) continue ; try { monitor . enterread ( ) ; if ( index . haschanged ( ) ) { if ( monitor . exitreadenterwrite ( ) ) { try { saveindex ( index ) ; } catch ( ioexception e ) { if ( jobmanager . verbose ) { util . verbose ( _str , system . err ) ; e . printstacktrace ( ) ; } allsaved = _bool ; } finally { monitor . exitwriteenterread ( ) ; } } else { allsaved = _bool ; } } } finally { monitor . exitread ( ) ; } } if ( this . participantscontainers != null && this . participantupdated ) { writeparticipantsindexnamesfile ( ) ; this . participantupdated = _bool ; } this . needtosave = ! allsaved ; }	commit all index memory changes to disk.
public void additem ( artist artist , int position ) { if ( artist == null ) throw new nullpointerexception ( _str ) ; if ( position < getitemcount ( ) || position > getitemcount ( ) ) throw new illegalargumentexception ( _str ) ; artists . add ( position , artist ) ; notifyiteminserted ( position ) ; }	add item in determined index.
public process executeasync ( final commandline command , map < string , string > environment ) throws ioexception { if ( workingdirectory != null && ! workingdirectory . exists ( ) ) { throw new ioexception ( workingdirectory + _str ) ; } return executeinternal ( command , environment , workingdirectory , streamhandler , null ) ; }	methods for starting asynchronous execution .
public void expandandselectifexists ( repositorylocation location ) { if ( location . parent ( ) != null ) { expandifexists ( location . parent ( ) , location . getname ( ) ) ; } else { expandifexists ( location , null ) ; } scrollpathtovisible ( getselectionpath ( ) ) ; }	expands the tree to select the given entry if it exists .
public void nexttoken ( ) { previousline = line ; previouscolumn = column ; while ( pos < matcher . regionstart ( ) ) { if ( text . charat ( pos ) == _str ) { ++ line ; column = _num ; } else { ++ column ; } ++ pos ; } if ( matcher . regionstart ( ) == matcher . regionend ( ) ) { currenttoken = _str ; } else { matcher . usepattern ( token ) ; if ( matcher . lookingat ( ) ) { currenttoken = matcher . group ( ) ; matcher . region ( matcher . end ( ) , matcher . regionend ( ) ) ; } else { currenttoken = string . valueof ( text . charat ( pos ) ) ; matcher . region ( pos + _num , matcher . regionend ( ) ) ; } skipwhitespace ( ) ; } }	advance to the next token .
public static void saveprovisioningvalidity ( context context , long validity ) { if ( validity <= _num ) { return ; } long next = system . currenttimemillis ( ) + validity ; sharedpreferences preferences = context . getsharedpreferences ( androidregistryfactory . rcs_prefs_name , activity . mode_private ) ; sharedpreferences . editor editor = preferences . edit ( ) ; editor . putlong ( registry_provisioning_validity , validity ) ; editor . putlong ( registry_provisioning_expiration , next ) ; editor . commit ( ) ; }	save the provisioning validity in shared preferences.
public void encode ( outputstream out ) throws ioexception { deroutputstream tmp = new deroutputstream ( ) ; if ( this . extensionvalue == null ) { this . extensionid = pkixextensions . reasoncode_id ; this . critical = _bool ; encodethis ( ) ; } super . encode ( tmp ) ; out . write ( tmp . tobytearray ( ) ) ; }	write the extension to the deroutputstream .
public void createclusterasync ( final string projectid , final clustercreatespec clustercreatespec , final futurecallback < task > responsecallback ) throws ioexception { string path = string . format ( _str , getbasepath ( ) , projectid ) ; createobjectasync ( path , serializeobjectasjson ( clustercreatespec ) , responsecallback ) ; }	create a cluster in the specified project .
public static dereferencealiasespolicy valueof ( final int intvalue ) { if ( intvalue < _num || intvalue >= elements . length ) { return null ; } return elements [ intvalue ] ; }	returns the alias dereferencing policy having the specified integer value as defined in rfc 4511 section 4.
public void testgetnameditemns2 ( ) throws throwable { document doc ; namednodemap attributes ; node element ; attr attribute ; nodelist elementlist ; string attrname ; doc = ( document ) load ( _str , builder ) ; elementlist = doc . getelementsbytagnamens ( _str , _str ) ; element = elementlist . item ( _num ) ; attributes = element . getattributes ( ) ; attribute = ( attr ) attributes . getnameditemns ( _str , _str ) ; attrname = attribute . getnodename ( ) ; assertequals ( _str , _str , attrname ) ; }	runs the test case .
public static void writeunsafe ( packetoutputstream out , string value , boolean nobackslashescapes ) throws ioexception { byte [ ] bytes = value . getbytes ( _str ) ; out . writeunsafe ( quote ) ; writebytesescapedunsafe ( out , bytes , bytes . length , nobackslashescapes ) ; out . writeunsafe ( quote ) ; }	write string in text format without checking buffer size .
public void add ( final samrecord read , final int position ) { recordandoffsets . add ( new recordandoffset ( read , position ) ) ; }	accumulate info for one read at the locus .
private sha256hash calculatehash ( ) { try { bytearrayoutputstream bos = new unsafebytearrayoutputstream ( header_size ) ; writeheader ( bos ) ; return new sha256hash ( utils . reversebytes ( doubledigest ( bos . tobytearray ( ) ) ) ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }	calculates the block hash by serializing the block and hashing the resulting bytes .
private void addpropertytype ( uri p , resource t ) { owlproperty prop = getproperty ( p ) ; if ( t . equals ( owl . transitiveproperty ) ) { prop . settransitive ( ) ; } else if ( t . equals ( owl . symmetricproperty ) ) { prop . setsymmetric ( ) ; } else if ( t . equals ( owl2 . asymmetricproperty ) ) { prop . setasymmetric ( ) ; } else if ( t . equals ( owl . functionalproperty ) ) { prop . setfunctional ( ) ; } else if ( t . equals ( owl . inversefunctionalproperty ) ) { prop . setinversefunctional ( ) ; } else if ( t . equals ( owl2 . irreflexiveproperty ) ) { prop . setirreflexive ( ) ; } }	add a particular characteristic to a property .
public static void equals ( object object1 , object object2 ) { checkassertion ( object1 . equals ( object2 ) , null ) ; }	asserts that given object1 equals object2 .
public static string writeactionstostring ( ofinstructionwriteactions inst , logger log ) throws exception { return actionutils . actionstostring ( inst . getactions ( ) , log ) ; }	convert an ofinstructionwriteactions to string form.
protected void preaddinterruptibly ( object o ) throws interruptedexception { }	called before the specified object is added to this queue .
public static string encodelines ( byte [ ] in , int ioff , int ilen , int linelen , string lineseparator ) { int blocklen = ( linelen * _num ) / _num ; if ( blocklen <= _num ) throw new illegalargumentexception ( ) ; int lines = ( ilen + blocklen - _num ) / blocklen ; int buflen = ( ( ilen + _num ) / _num ) * _num + lines * lineseparator . length ( ) ; stringbuilder buf = new stringbuilder ( buflen ) ; int ip = _num ; while ( ip < ilen ) { int l = math . min ( ilen - ip , blocklen ) ; buf . append ( encode ( in , ioff + ip , l ) ) ; buf . append ( lineseparator ) ; ip += l ; } return buf . tostring ( ) ; }	encodes a byte array into base 64 format and breaks the output into lines .
private odatafeed readfeedlogperf ( string query , map < string , string > params ) throws ioexception , odataexception { long delta_time = system . currenttimemillis ( ) ; odatafeed feed = client . readfeed ( query , params ) ; log ( level . debug , _str + query + _str + delta_time + _str ) ; return feed ; }	logs how much time an odata command consumed .
final int rllong ( datainputstream dis ) throws ioexception { int b1 , b2 , b3 , b4 ; int i = _num ; i = dis . readint ( ) ; b1 = ( i & _num ) << _num ; b2 = ( i & _num ) << _num ; b3 = ( i & _num ) > > _num ; b4 = ( i & _num ) > > > _num ; i = ( b1 | b2 | b3 | b4 ) ; return i ; }	rllong protected helper method to read 64 bits and changing the order of each bytes .
public void testshiftright4 ( ) { byte abytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = _num ; int number = _num ; byte rbytes [ ] = { _num , _num , - _num , _num , - _num , - _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . shiftright ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	shiftright ( int n ) , n > 32.
public dependencies resolvefromfile ( file file , string classname , sootclass sc ) { dexlibwrapper wrapper = cache . get ( file ) ; if ( wrapper == null ) { wrapper = new dexlibwrapper ( file ) ; cache . put ( file , wrapper ) ; wrapper . initialize ( ) ; } dependencies deps = wrapper . makesootclass ( sc , classname ) ; addsourcefiletag ( sc , _str + file . getname ( ) ) ; return deps ; }	resolve the class contained in file into the passed soot class .
public static string buildresponseurl ( string tenant , logoutstate logoutstate ) { string retval = null ; logoutresponse samlresponse = logoutstate . generateresponsefortenant ( tenant , logoutstate . getmessagesource ( ) , logoutstate . getlocale ( ) ) ; if ( samlresponse != null ) { log . info ( _str + samlresponse . tostring ( ) ) ; retval = logoutstate . generateresponseurlfortenant ( samlresponse , tenant ) ; } return retval ; }	helper method to generate logoutresponse redirect url.
public static void assertlabel ( int [ ] path , string text ) { if ( verbose ) { log ( _str + tostring ( path ) + _str + text + _str ) ; } label l = ( label ) getcomponentbypath ( path ) ; assertbool ( l != null , _str + text ) ; assertbool ( text == l . gettext ( ) || text . equals ( l . gettext ( ) ) , ( _str + l . gettext ( ) ) + _str + text ) ; }	asserts that we have a label with the given text baring the given name.
private void interpolateresultlist ( arraylist < pathparser . pathdatanode > list ) { if ( list == null || list . size ( ) <= _num ) return ; float [ ] [ ] listpenpos = pathnodeutils . calculatepenposition ( list ) ; arraylist < pathparser . pathdatanode > sublist = new arraylist < > ( ) ; int size = list . size ( ) ; pathparser . pathdatanode currentnode = null ; int i = _num ; while ( i < size - _num ) { currentnode = list . get ( i ) ; if ( ! isinterpolatablecommand ( currentnode . mtype ) ) { i ++ ; continue ; } boolean validsequence = _bool ; int k = i ; for ( int j = i ; j < size && validsequence ; j ++ ) { if ( currentnode . mtype == list . get ( j ) . mtype ) { k = j ; if ( ! arrays . equals ( currentnode . mparams , list . get ( j ) . mparams ) ) break ; } else validsequence = _bool ; } if ( k - i > _num ) { interpolatesublist ( list . sublist ( i , k + _num ) ) ; } i ++ ; } }	apply interpolation on the result list ( where possible ).
private void inittokenizer ( streamtokenizer tokenizer ) { tokenizer . resetsyntax ( ) ; tokenizer . whitespacechars ( _num , ( _str - _num ) ) ; tokenizer . wordchars ( _str , _str ) ; tokenizer . whitespacechars ( _str , _str ) ; tokenizer . whitespacechars ( _str , _str ) ; tokenizer . commentchar ( _str ) ; tokenizer . whitespacechars ( _str , _str ) ; tokenizer . quotechar ( _str ) ; tokenizer . quotechar ( _str ) ; tokenizer . eolissignificant ( _bool ) ; }	initializes the stream tokenizer.
protected void illegalmessagereceived ( ofmessage m ) { string msg = getswitchstatemessage ( m , _str ) ; throw new switchstateexception ( msg ) ; }	we have an ofmessage we didn ' t expect given the current state and we want to treat this as an error . we currently throw an exception that will terminate the connection however , we could be more forgiving.
protected void run_threadsizeloop ( ) throws exception { for ( int i = _num ; i <= _num ; i += _num ) { setnumworkers ( i ) ; try { thread . sleep ( _num * _num ) ; } catch ( interruptedexception e ) { } } }	a simple method to do nothing very much.
protected boolean read ( ) { if ( ! nreuseheader ) { debug . message ( _str , _str ) ; return readheader ( ) ; } byte [ ] tempdata = new byte [ ndatasize - nfieldoffset ] ; int nreadbytes = pomodule . read ( tempdata , _num , tempdata . length ) ; system . arraycopy ( pachdata , nfieldoffset , tempdata , _num , tempdata . length ) ; if ( nreadbytes != ( int ) ( ndatasize - nfieldoffset ) && nreadbytes == - _num ) { return _bool ; } else if ( nreadbytes != ( int ) ( ndatasize - nfieldoffset ) ) { debug . error ( _str ) ; return _bool ; } return _bool ; }	read a record of data from the file , and parse the header to build a field list for the record ( or reuse the existing one if reusing headers ).
@ override public boolean lock ( ) { try { if ( ! filefactory . isfileexist ( location , filefactory . getfiletype ( tmppath ) ) ) { filefactory . mkdirs ( location , filefactory . getfiletype ( tmppath ) ) ; } string lockfilepath = location + carboncommonconstants . file_separator + lockfile ; if ( ! filefactory . isfileexist ( lockfilepath , filefactory . getfiletype ( location ) ) ) { filefactory . createnewlockfile ( lockfilepath , filefactory . getfiletype ( location ) ) ; } fileoutputstream = new fileoutputstream ( lockfilepath ) ; channel = fileoutputstream . getchannel ( ) ; try { filelock = channel . trylock ( ) ; } catch ( overlappingfilelockexception e ) { return _bool ; } if ( null != filelock ) { return _bool ; } else { return _bool ; } } catch ( ioexception e ) { return _bool ; } }	lock api for locking of the file channel of the lock file .
public void open ( int port ) throws ioexception { connection = new datagramsocket ( port ) ; connection . setsotimeout ( timeout ) ; }	open the datagram connection.
public string globalinfo ( ) { return _str + _str ; }	returns a string describing this split evaluator.
public mlresults execute ( script script ) { scriptexecutor scriptexecutor = new scriptexecutor ( sparkmonitoringutil ) ; scriptexecutor . setexplain ( explain ) ; scriptexecutor . setexplainlevel ( explainlevel ) ; scriptexecutor . setstatistics ( statistics ) ; scriptexecutor . setinit ( scripthistorystrings . isempty ( ) ) ; return execute ( script , scriptexecutor ) ; }	execute a dml or pydml script .
public void disable ( richformatterfeature feature ) { features . remove ( feature ) ; }	disable a specific feature on this rich formatter .
public void removeeventlistener ( zwaveeventlistener eventlistener ) { synchronized ( zwaveeventlisteners ) { zwaveeventlisteners . remove ( eventlistener ) ; } }	remove a listener for zwave events to this controller .
private static double pythontime ( ) { return system . currenttimemillis ( ) / _num ; }	returns the current millis the same way as python does since this is what ' s stored in the replay files * yay * .
@ safevarargs public final void add ( t ... newitems ) { add ( arrays . aslist ( newitems ) ) ; }	add new items to the table .
public static string quoteifjavakeyword ( string name ) { return jvmmoduleutil . quoteifjavakeyword ( name ) ; }	prefixes the given name with a dollar ( $ ) if it is a java keyword.
public static recipe fromcursor ( cursor cursor ) { recipe recipe = new recipe ( null ) ; for ( int c = _num ; c < cursor . getcolumncount ( ) ; c ++ ) { string columnname = cursor . getcolumnname ( c ) ; if ( columnname . equals ( recipetable . id_column ) ) { recipe . id = cursor . getstring ( c ) ; } else if ( columnname . equals ( recipetable . title_column ) ) { recipe . settitle ( cursor . getstring ( c ) ) ; } else if ( columnname . equals ( recipetable . description_column ) ) { recipe . setdescription ( cursor . getstring ( c ) ) ; } else if ( columnname . equals ( recipetable . photo_column ) ) { recipe . setphoto ( cursor . getstring ( c ) ) ; } else if ( columnname . equals ( recipetable . prep_time_column ) ) { recipe . setpreptime ( cursor . getstring ( c ) ) ; } } return recipe ; }	static helper method for populating attributes from a database cursor .
public static void checkstate ( boolean expression , @ nullable object errormessage ) { if ( ! expression ) { throw new illegalstateexception ( string . valueof ( errormessage ) ) ; } }	ensures the truth of an expression involving the state of the calling instance , but not involving any parameters to the calling method .
private static < t , id > void adddroptablestatements ( databasetype databasetype , tableinfo < t , id > tableinfo , list < string > statements ) { list < string > statementsbefore = new arraylist < string > ( ) ; list < string > statementsafter = new arraylist < string > ( ) ; for ( fieldtype fieldtype : tableinfo . getfieldtypes ( ) ) { databasetype . dropcolumnarg ( fieldtype , statementsbefore , statementsafter ) ; } stringbuilder sb = new stringbuilder ( _num ) ; sb . append ( _str ) ; databasetype . appendescapedentityname ( sb , tableinfo . gettablename ( ) ) ; sb . append ( _str ) ; statements . addall ( statementsbefore ) ; statements . add ( sb . tostring ( ) ) ; statements . addall ( statementsafter ) ; }	generate and return the list of statements to drop a database table .
public boolean islocked ( ) { return ! queue . isempty ( ) ; }	true iff a lock is granted .
public long cguest_time ( ) { return long . parselong ( fields [ _num ] ) ; }	( since linux 2.
private static classinfo findorcreateclass ( string t ) { if ( ! t . endswith ( _str ) ) { return classinfo . findorcreateclass ( t ) ; } else { string basetype = t . substring ( _num , t . indexof ( _str ) ) ; int level = ( t . length ( ) - t . indexof ( _str ) ) / _num ; string s = _str ; for ( int i = _num ; i < level ; ++ i ) s += _str ; if ( basetype . equals ( _str ) ) s += _str ; else if ( basetype . equals ( _str ) ) s += _str ; else s += _str + basetype + _str ; return classinfo . findorcreateclass ( s ) ; } }	convert pscout - style type name to canonical form.
private void resetnotes ( ) { if ( errorinstatus1 ) { if ( editmode ) { statustext1 . settext ( editstatus1 ) ; } else { statustext1 . settext ( stdstatus1 ) ; } errorinstatus1 = _bool ; } resetnotes2 ( ) ; }	method to reset the notes error after error display.
@ hlefunction ( nid = _num , version = _num ) public int scertcsettick ( tpointer timeaddr , tpointer64 ticksaddr ) { long ticks = ticksaddr . getvalue ( ) - rtcmagicoffset ; scepspdatetime time = scepspdatetime . frommicros ( ticks ) ; time . write ( timeaddr ) ; return _num ; }	set a psptime struct based on ticks .
public static void write ( file file , charsequence data , charset encoding , boolean append ) throws ioexception { string str = data == null ? null : data . tostring ( ) ; writestringtofile ( file , str , encoding , append ) ; }	writes a charsequence to a file creating the file if it does not exist .
private void populatenavdrawer ( ) { mnavdraweritems . clear ( ) ; mnavdraweritems . add ( navdrawer_item_home ) ; mnavdraweritems . add ( navdrawer_item_separator ) ; mnavdraweritems . add ( navdrawer_item_my_following ) ; mnavdraweritems . add ( navdrawer_item_my_shots ) ; mnavdraweritems . add ( navdrawer_item_my_buckets ) ; mnavdraweritems . add ( navdrawer_item_my_projects ) ; mnavdraweritems . add ( navdrawer_item_my_teams ) ; mnavdraweritems . add ( navdrawer_item_my_likes ) ; mnavdraweritems . add ( navdrawer_item_separator_special ) ; mnavdraweritems . add ( navdrawer_item_settings ) ; createnavdraweritems ( ) ; }	populates the navigation drawer with the appropriate items .
public void runtest ( ) throws throwable { document doc ; nodelist elementlist ; node namenode ; characterdata child ; string childvalue ; int childlength ; doc = ( document ) load ( _str , _bool ) ; elementlist = doc . getelementsbytagname ( _str ) ; namenode = elementlist . item ( _num ) ; child = ( characterdata ) namenode . getfirstchild ( ) ; childvalue = child . getdata ( ) ; childlength = childvalue . length ( ) ; assertequals ( _str , _num , childlength ) ; }	runs the test case .
public static byte [ ] valuesof ( byte [ ] array ) { byte [ ] dest = new byte [ array . length ] ; for ( int i = _num ; i < array . length ; i ++ ) { dest [ i ] = byte . valueof ( array [ i ] ) ; } return dest ; }	converts to object array .
public void auditcallhome ( operationtypeenum audittype , string operationalstatus , string description , object ... descparams ) { _auditmgr . recordauditlog ( null , null , event_service_type , audittype , system . currenttimemillis ( ) , operationalstatus , description , descparams ) ; }	record audit log for callhome service.
public static float mean ( float [ ] data , int startindex , int endindex ) { float mean = _num ; int total = _num ; startindex = math . max ( startindex , _num ) ; startindex = math . min ( startindex , data . length - _num ) ; endindex = math . max ( endindex , _num ) ; endindex = math . min ( endindex , data . length - _num ) ; if ( startindex > endindex ) startindex = endindex ; for ( int i = startindex ; i <= endindex ; i ++ ) { if ( float . isnan ( data [ i ] ) ) throw new illegalargumentexception ( _str ) ; mean += data [ i ] ; total ++ ; } mean /= total ; return mean ; }	compute the mean of all elements in the array.
public static string constructntptime ( long date ) { long ntptime = _num ; long starttime = ( date / seconds_to_milliseconds_conversion_rate ) + ntptime ; return string . valueof ( starttime ) ; }	construct an ntp time from a date in milliseconds.
protected mediatype selectmediatype ( serverwebexchange exchange , list < mediatype > producibletypes ) { list < mediatype > acceptabletypes = getacceptabletypes ( exchange ) ; producibletypes = getproducibletypes ( exchange , producibletypes ) ; set < mediatype > compatiblemediatypes = new linkedhashset < > ( ) ; for ( mediatype acceptable : acceptabletypes ) { for ( mediatype producible : producibletypes ) { if ( acceptable . iscompatiblewith ( producible ) ) { compatiblemediatypes . add ( selectmorespecificmediatype ( acceptable , producible ) ) ; } } } list < mediatype > result = new arraylist < > ( compatiblemediatypes ) ; mediatype . sortbyspecificityandquality ( result ) ; for ( mediatype mediatype : compatiblemediatypes ) { if ( mediatype . isconcrete ( ) ) { return mediatype ; } else if ( mediatype . equals ( mediatype . all ) || mediatype . equals ( media_type_application_all ) ) { return mediatype . application_octet_stream ; } } return null ; }	select the best media type for the current request through a content negotiation algorithm .
public void paintborder ( component c , graphics g , int x , int y , int width , int height ) { if ( ! ( c instanceof jpopupmenu ) ) { return ; } font origfont = g . getfont ( ) ; color origcolor = g . getcolor ( ) ; jpopupmenu popup = ( jpopupmenu ) c ; string title = popup . getlabel ( ) ; if ( title == null ) { return ; } g . setfont ( font ) ; fontmetrics fm = swingutilities2 . getfontmetrics ( popup , g , font ) ; int fontheight = fm . getheight ( ) ; int descent = fm . getdescent ( ) ; int ascent = fm . getascent ( ) ; point textloc = new point ( ) ; int stringwidth = swingutilities2 . stringwidth ( popup , fm , title ) ; textloc . y = y + ascent + text_spacing ; textloc . x = x + ( ( width - stringwidth ) / _num ) ; g . setcolor ( background ) ; g . fillrect ( textloc . x - text_spacing , textloc . y - ( fontheight - descent ) , stringwidth + ( _num * text_spacing ) , fontheight - descent ) ; g . setcolor ( foreground ) ; swingutilities2 . drawstring ( popup , g , title , textloc . x , textloc . y ) ; motifgraphicsutils . drawgroove ( g , x , textloc . y + text_spacing , width , groove_height , shadowcolor , highlightcolor ) ; g . setfont ( origfont ) ; g . setcolor ( origcolor ) ; }	paints the border for the specified component with the specified position and size .
public void ensurecapacity ( int mincap ) { if ( mincap > array . length ) { int newcap = ( ( array . length * _num ) > > _num ) + _num ; int [ ] olddata = array ; array = new int [ newcap < mincap ? mincap : newcap ] ; system . arraycopy ( olddata , _num , array , _num , size ) ; } }	increases the capacity of this arraylist instance , if necessary , to ensure that it can hold at least the number of elements specified by the minimum capacity argument .
public void invalidateandunmap ( bytebuffer ... bufs ) throws ioexception { if ( cleaner != null ) { invalidated = _bool ; barrier . lazyset ( _num ) ; thread . yield ( ) ; for ( bytebuffer b : bufs ) { cleaner . freebuffer ( resourcedescription , b ) ; } } }	invalidates this guard and unmaps ( if supported ) .
public int adddir ( file file ) { if ( ! file . exists ( ) ) { return _num ; } string [ ] names = getnames ( getfiles ( file , _str ) ) ; loadclass ( file , names ) ; return _num ; }	adds new locations for command classes.
private boolean ismineshafterpresent ( ) { try { class . forname ( _str ) ; return _bool ; } catch ( exception e ) { return _bool ; } }	check if mineshafter is present . if it is , we need to bypass it to send post requests.
@ override public boolean equals ( object obj ) { if ( obj == this ) { return _bool ; } if ( ! ( obj instanceof bubblexyitemlabelgenerator ) ) { return _bool ; } if ( ! super . equals ( obj ) ) { return _bool ; } bubblexyitemlabelgenerator that = ( bubblexyitemlabelgenerator ) obj ; if ( ! objectutilities . equal ( this . zformat , that . zformat ) ) { return _bool ; } if ( ! objectutilities . equal ( this . zdateformat , that . zdateformat ) ) { return _bool ; } return _bool ; }	tests this object for equality with an arbitrary object .
public static boolean haselementchild ( node node ) { nodelist nl = node . getchildnodes ( ) ; node child = null ; int length = nl . getlength ( ) ; for ( int i = _num ; i < length ; i ++ ) { child = nl . item ( i ) ; if ( child . getnodetype ( ) == node . element_node ) { return _bool ; } } return _bool ; }	checks if a node has a child of element type .
public void delitem ( int index ) { synchronized ( getmenutreelock ( ) ) { if ( selectedindex == index ) { selectitem ( null , _bool ) ; } else if ( selectedindex > index ) { selectedindex -- ; } if ( index < items . size ( ) ) { items . remove ( index ) ; } else { if ( log . isloggable ( platformlogger . level . fine ) ) { log . fine ( _str + index + _str + items . size ( ) ) ; } } } updatesize ( ) ; }	removes item at the specified index from items vector .
public static int countcssprimitivenames ( ) { return all_primitive_property_names . size ( ) ; }	returns a count of all css primitive ( non - shorthand ) properties known to this class .
public void printstring ( string v ) throws ioexception { printstring ( v , _num , v . length ( ) ) ; }	prints a string to the stream , encoded as utf - 8.
private void checkpermission ( object object , namespacepermissionenum [ ] permissions , list < accessdeniedexception > accessdeniedexceptions ) { if ( object != null ) { if ( object instanceof collection ) { collection < ? > collection = ( collection < ? > ) object ; for ( object element : collection ) { checkpermission ( element , permissions , accessdeniedexceptions ) ; } } else if ( object instanceof string ) { try { checkpermission ( ( string ) object , permissions ) ; } catch ( accessdeniedexception accessdeniedexception ) { accessdeniedexceptions . add ( accessdeniedexception ) ; } } else { throw new illegalstateexception ( string . format ( _str , string . class , collection . class , object . getclass ( ) ) ) ; } } }	checks the current user ' s permissions against the given object which may represent a single or multiple namespaces.
private void displayallstringdefinedinstringxml ( ) { simpleiconfonttextview textview = ( simpleiconfonttextview ) findviewbyid ( r . id . text_view_2 ) ; list < string > list = new arraylist < > ( ) ; list . add ( getstring ( r . string . cubeicon_gems_logo ) ) ; list . add ( getstring ( r . string . cubeicon_android ) ) ; list . add ( getstring ( r . string . cubeicon_heart ) ) ; string text = textutils . join ( _str , list ) ; textview . settext ( text ) ; }	display the string defined in the string xml file : iconfont_string . xml.
private static intent createmapactivityintent ( context context , urlspan [ ] urlspans ) { for ( int span_i = _num ; span_i < urlspans . length ; span_i ++ ) { urlspan urlspan = urlspans [ span_i ] ; string urlstring = urlspan . geturl ( ) ; if ( urlstring . startswith ( geo_prefix ) ) { intent geointent = new intent ( intent . action_view , uri . parse ( urlstring ) ) ; geointent . addflags ( intent . flag_activity_new_task ) ; return geointent ; } } return null ; }	create an intent to take the user to maps , using the first map link available.
private stringbuilder generateparameters ( ) { stringbuilder parameters = new stringbuilder ( ) ; if ( filtermap == null && expandparameters == null ) { return parameters ; } parameters . append ( _str ) ; int filterparametercounter = _num ; if ( filtermap != null && ! filtermap . isempty ( ) ) { parameters . append ( filter_prefix ) ; for ( map . entry < string , string > filterentry : filtermap . entryset ( ) ) { parameters . append ( string . format ( _str , filterentry . getkey ( ) , filterentry . getvalue ( ) ) ) ; if ( ++ filterparametercounter < filtermap . size ( ) ) { parameters . append ( _str ) ; } } if ( expandparameters != null ) { parameters . append ( _str ) ; } } if ( expandparameters != null ) { parameters . append ( expand_prefix ) ; iterator iterator = expandparameters . iterator ( ) ; parameters . append ( string . format ( _str , iterator . next ( ) ) ) ; while ( iterator . hasnext ( ) ) { parameters . append ( string . format ( _str , iterator . next ( ) ) ) ; } } return parameters ; }	returns a stringbuilder that is consisted of filtering and expanding parameters that in turn are appended to the query string used for odata client.
public void writeexif ( bitmap bmap , outputstream exifoutstream ) throws ioexception { if ( bmap == null || exifoutstream == null ) { throw new illegalargumentexception ( null_argument_string ) ; } outputstream s = getexifwriterstream ( exifoutstream ) ; bmap . compress ( bitmap . compressformat . jpeg , _num , s ) ; s . flush ( ) ; }	writes the tags from this exifinterface object into a jpeg compressed bitmap , removing prior exif tags .
public void removeattribute ( int index ) { if ( index >= _num && index < length ) { if ( index < length - _num ) { system . arraycopy ( data , ( index + _num ) * _num , data , index * _num , ( length - index - _num ) * _num ) ; } index = ( length - _num ) * _num ; data [ index ++ ] = null ; data [ index ++ ] = null ; data [ index ++ ] = null ; data [ index ++ ] = null ; data [ index ] = null ; length -- ; } else { badindex ( index ) ; } }	remove an attribute from the list .
public static @ checkfornull @ slashedclassname string fromfieldsignature ( string signature ) { if ( signature . charat ( _num ) != _str ) { return null ; } return signature . substring ( _num , signature . length ( ) - _num ) ; }	converts from signature to slashed class name ( e.
private void paintpreview ( int dx , int dy , float zoomfactor ) { if ( image != null ) { graphics2d g2 = ( graphics2d ) getgraphics ( ) ; ucolor bg = renderer . getbackgroundcolor ( ) ; g2 . setbackground ( new color ( bg . getred ( ) , bg . getgreen ( ) , bg . getblue ( ) , bg . getalpha ( ) ) ) ; int newwidth = math . round ( image . getwidth ( null ) * zoomfactor ) ; int newheight = ( int ) math . round ( image . getheight ( null ) * zoomfactor ) ; g2 . drawimage ( image , dx , dy , newwidth , newheight , null ) ; if ( dx > _num ) g2 . clearrect ( _num , _num , dx , getheight ( ) ) ; else g2 . clearrect ( getwidth ( ) + dx , _num , getwidth ( ) , getheight ( ) ) ; if ( dy > _num ) g2 . clearrect ( _num , _num , getwidth ( ) , dy ) ; else g2 . clearrect ( _num , getheight ( ) + dy , getwidth ( ) , getheight ( ) ) ; } }	draws the off - screen image if exists at position ( dx , dy ) scaled by the specified factor .
@ requirespermission ( manifest . permission . camera ) public camerasource start ( ) throws ioexception { synchronized ( mcameralock ) { if ( mcamera != null ) { return this ; } mcamera = createcamera ( ) ; if ( build . version . sdk_int >= build . version_codes . honeycomb ) { mdummysurfacetexture = new surfacetexture ( dummy_texture_name ) ; mcamera . setpreviewtexture ( mdummysurfacetexture ) ; } else { mdummysurfaceview = new surfaceview ( mcontext ) ; mcamera . setpreviewdisplay ( mdummysurfaceview . getholder ( ) ) ; } mcamera . startpreview ( ) ; mprocessingthread = new thread ( mframeprocessor ) ; mframeprocessor . setactive ( _bool ) ; mprocessingthread . start ( ) ; } return this ; }	opens the camera and starts sending preview frames to the underlying detector.
public synchronized void clear ( ) { mcategories . clear ( ) ; mvalues . clear ( ) ; }	removes all the existing values from the series .
public static list < list < double > > partitionvariable ( list < double > arr , int chunk ) { int count = _num ; list < list < double > > ret = new arraylist < list < double > > ( ) ; while ( count < arr . size ( ) ) { list < double > sublist = arr . sublist ( count , count + chunk ) ; count += chunk ; ret . add ( sublist ) ; } for ( list < double > lists : ret ) { if ( lists . size ( ) < chunk ) ret . remove ( lists ) ; } return ret ; }	this will partition the given whole variable data applytransformtodestination in to the specified chunk number .
private static void updatewindowui ( window window ) { swingutilities . updatecomponenttreeui ( window ) ; window ownedwins [ ] = window . getownedwindows ( ) ; for ( window ownedwin : ownedwins ) { updatewindowui ( ownedwin ) ; } }	updates the ui of the passed in window and all its children .
public void clearresults ( ) { if ( resultlist != null ) { resultlist . clear ( ) ; madapter . notifydatasetchanged ( ) ; } listener . onsearchcleared ( ) ; }	clear all the results.
public arraylist < constraintwidget > findwidgets ( widgetcontainer container , int x , int y , int width , int height ) { arraylist < constraintwidget > found = new arraylist < > ( ) ; rectangle area = new rectangle ( x , y , width , height ) ; for ( constraintwidget widget : container . getchildren ( ) ) { widgetcompanion companion = ( widgetcompanion ) widget . getcompanionwidget ( ) ; widgetdecorator decorator = companion . getwidgetdecorator ( widgetdecorator . blueprint_style ) ; if ( ! decorator . isvisible ( ) ) { continue ; } rectangle bounds = new rectangle ( widget . getdrawx ( ) , widget . getdrawy ( ) , widget . getwidth ( ) , widget . getheight ( ) ) ; if ( area . intersects ( bounds ) ) { found . add ( widget ) ; } } return found ; }	gather all the widgets contained in the area specified and return them as an array , taking the decorator visibility in account.
public final void printsymbol ( charsequence text ) throws ioexception { if ( text == null ) { appendascii ( _str ) ; } else if ( text . length ( ) == _num ) { throw new emptysymbolexception ( ) ; } else if ( symbolneedsquoting ( text , _bool ) ) { appendascii ( _str ) ; printcodepoints ( text , symbol_escape_codes ) ; appendascii ( _str ) ; } else { appendascii ( text ) ; } }	print an ion symbol type . this method will check if symbol needs quoting.
public static shoppingcartitem makeitem ( integer cartlocation , genericvalue product , bigdecimal selectedamount , bigdecimal quantity , bigdecimal unitprice , timestamp reservstart , bigdecimal reservlength , bigdecimal reservpersons , timestamp shipbeforedate , timestamp shipafterdate , map < string , genericvalue > additionalproductfeatureandappls , map < string , object > attributes , string prodcatalogid , productconfigwrapper configwrapper , string itemtype , shoppingcart . shoppingcartitemgroup itemgroup , localdispatcher dispatcher , shoppingcart cart , boolean triggerexternalopsbool , boolean triggerpricerulesbool , genericvalue parentproduct , boolean skipinventorychecks , boolean skipproductchecks ) throws cartitemmodifyexception { return makeitem ( cartlocation , product , selectedamount , quantity , unitprice , reservstart , reservlength , reservpersons , null , null , shipbeforedate , shipafterdate , additionalproductfeatureandappls , attributes , prodcatalogid , configwrapper , itemtype , itemgroup , dispatcher , cart , triggerexternalopsbool , triggerpricerulesbool , parentproduct , skipinventorychecks , skipproductchecks ) ; }	makes a shoppingcartitem and adds it to the cart.
@ override public string tostring ( ) { map < assignment , double > sortedtable = inferenceutils . getnbest ( table , math . max ( table . size ( ) , _num ) ) ; string str = _str ; for ( entry < assignment , double > entry : sortedtable . entryset ( ) ) { string prob = stringutils . getshortform ( entry . getvalue ( ) ) ; str += _str + entry . getkey ( ) + _str + prob + _str ; } return ( str . length ( ) > _num ) ? str . substring ( _num , str . length ( ) - _num ) : str ; }	returns a string representation of the probability table.
protected final void updatebordertext ( final string text ) { preconditions . checknotnull ( text , _str ) ; m_titledborder . settitle ( text ) ; updateui ( ) ; }	updates the border text of the component .
private void addclasses ( class < ? > [ ] classes , hashset < class < ? > > result , string fieldname ) { if ( classes == null || classes . length == _num ) error . classesabsent ( fieldname , configuredclass ) ; for ( class < ? > classe : classes ) result . add ( classe ) ; }	adds to the result parameter all classes that aren ' t present in it.
public void resetreferences ( ) { if ( _refs != null ) _refs . clear ( ) ; }	resets the references for streaming .
public static biginteger decodempi ( byte [ ] mpi , boolean haslength ) { byte [ ] buf ; if ( haslength ) { int length = ( int ) readuint32be ( mpi , _num ) ; buf = new byte [ length ] ; system . arraycopy ( mpi , _num , buf , _num , length ) ; } else buf = mpi ; if ( buf . length == _num ) return biginteger . zero ; boolean isnegative = ( buf [ _num ] & _num ) == _num ; if ( isnegative ) buf [ _num ] &= _num ; biginteger result = new biginteger ( buf ) ; return isnegative ? result . negate ( ) : result ; }	mpi encoded numbers are produced by the openssl bn_bn2mpi function.
public void schemachanged ( string servicename , string version ) { synchronized ( maprealmtoformat ) { maprealmtoformat . remove ( root ) ; } }	this method will be invoked when a service ' s schema has been changed .
public void sort ( dtmiterator v , vector keys , xpathcontext support ) throws javax . xml . transform . transformerexception { m_keys = keys ; int n = v . getlength ( ) ; vector nodes = new vector ( ) ; for ( int i = _num ; i < n ; i ++ ) { nodecompareelem elem = new nodecompareelem ( v . item ( i ) ) ; nodes . addelement ( elem ) ; } vector scratchvector = new vector ( ) ; mergesort ( nodes , scratchvector , _num , n - _num , support ) ; for ( int i = _num ; i < n ; i ++ ) { v . setitem ( ( ( nodecompareelem ) nodes . elementat ( i ) ) . m_node , i ) ; } v . setcurrentpos ( _num ) ; }	given a vector of nodes , sort each node according to the criteria in the keys .
protected datetimedata parse ( string str ) throws schemadatetimeexception { datetimedata date = new datetimedata ( str , this ) ; int len = str . length ( ) ; date . year = year ; date . day = day ; if ( str . charat ( _num ) != _str || str . charat ( _num ) != _str ) { throw new schemadatetimeexception ( _str + str ) ; } int stop = _num ; date . month = parseint ( str , _num , stop ) ; if ( str . length ( ) >= stop + _num && str . charat ( stop ) == _str && str . charat ( stop + _num ) == _str ) { stop += _num ; } if ( stop < len ) { if ( ! isnextcharutcsign ( str , stop , len ) ) { throw new schemadatetimeexception ( _str + str ) ; } else { gettimezone ( str , date , stop , len ) ; } } validatedatetime ( date ) ; saveunnormalized ( date ) ; if ( date . utc != _num && date . utc != _str ) { normalize ( date ) ; } date . position = _num ; return date ; }	parses , validates and computes normalized version of gmonth object.
private void addtoqueue ( serialmessage serialmessage ) { if ( serialmessage == null ) { return ; } if ( ! msgqueue . contains ( serialmessage ) && msgqueue . remainingcapacity ( ) > _num ) { msgqueue . add ( serialmessage ) ; } sendmessage ( ) ; }	move the messages to the queue.
private dbid stringtodbid ( string query ) { return dbidutil . importinteger ( integer . valueof ( query ) ) ; }	parse a string into a dbid .
@ override public final void writeshort ( int v ) throws ioexception { work [ _num ] = ( byte ) v ; work [ _num ] = ( byte ) ( v > > _num ) ; dis . write ( work , _num , _num ) ; }	write short , 16 - bits.
final public void println ( long v ) { writer out = this . out ; if ( out == null ) return ; print ( v ) ; try { out . write ( _newline , _num , _newline . length ) ; } catch ( ioexception e ) { log . log ( level . fine , e . tostring ( ) , e ) ; } }	prints a long followed by a newline .
public thriftservicemetadata ( class < ? > servicetype ) { requirenonnull ( servicetype , _str ) ; interfaces = init ( null , collections . singleton ( servicetype ) ) ; }	creates a new instance from a single thrift service interface .
public writableraster createcompatiblewritableraster ( int w , int h ) { if ( w <= _num || h <= _num ) { throw new rasterformatexception ( _str + ( ( w <= _num ) ? _str : _str ) ) ; } samplemodel sm = samplemodel . createcompatiblesamplemodel ( w , h ) ; return new bytepackedraster ( sm , new point ( _num , _num ) ) ; }	creates a raster with the same layout but using a different width and height , and with new zeroed data arrays .
public static response invalidentity ( constraintviolationexception e ) { stringbuilder errormessage = new stringbuilder ( ) ; boolean firstpass = _bool ; for ( constraintviolation error : e . getconstraintviolations ( ) ) { if ( ! firstpass ) { errormessage . append ( _str ) ; } errormessage . append ( string . format ( _str , error . getpropertypath ( ) , error . getmessage ( ) , error . getinvalidvalue ( ) ) ) ; firstpass = _bool ; } externalexception externalexception = new externalexception ( errorcode . invalid_entity , errormessage . tostring ( ) , null ) ; return externalexception ( externalexception ) ; }	return an error response generated by a validation failure , invalid json , etc .
public string checkstartblock ( int mode ) { if ( log . isdebugenabled ( ) ) log . debug ( _str + getdisplayname ( ) + _str ) ; blockorder bo = _orders . get ( _num ) ; oblock block = bo . getblock ( ) ; string msg = block . allocate ( this ) ; if ( msg != null ) { return msg ; } msg = bo . setpath ( this ) ; if ( msg != null ) { return msg ; } int state = block . getstate ( ) ; if ( ( state & oblock . dark ) != _num || _temprunblind ) { msg = bundle . getmessage ( _str , block . getdisplayname ( ) ) ; } else if ( ( state & oblock . occupied ) == _num ) { if ( mode == mode_learn ) { msg = _str ; } else { msg = _str ; } msg = bundle . getmessage ( msg , gettrainname ( ) , block . getdisplayname ( ) ) ; } else { trackertableaction . stoptrackerin ( block ) ; } return msg ; }	check start block for occupied for start of run.
public void init ( string prefix , java . net . url url ) { try { java . io . inputstream in = url . openstream ( ) ; properties props = new properties ( ) ; props . load ( in ) ; init ( getlayers ( prefix , props ) ) ; } catch ( java . net . malformedurlexception murle ) { logger . warning ( _str + url + _str ) ; } catch ( java . io . ioexception e ) { logger . warning ( _str ) ; } }	initialize the layerhandler by having it construct it ' s layers from a url containing an openmap.
boolean suppressedby ( dnsincoming msg ) { try { for ( dnsrecord answer : msg . getallanswers ( ) ) { if ( suppressedby ( answer ) ) { return _bool ; } } return _bool ; } catch ( arrayindexoutofboundsexception e ) { logger . log ( level . warning , _str + msg + _str , e ) ; return _bool ; } }	true if this record is suppressed by the answers in a message .
public static properties createproperties ( final map < string , string > map ) { properties properties = new properties ( ) ; if ( ! ( map == null || map . isempty ( ) ) ) { for ( entry < string , string > entry : map . entryset ( ) ) { properties . setproperty ( entry . getkey ( ) , entry . getvalue ( ) ) ; } } return properties ; }	creates an properties object initialized with the value from the given map . < p >.
public node selectfirst ( string query ) { list < node > selectednodes = select ( query ) ; if ( selectednodes . isempty ( ) ) { return null ; } return selectednodes . get ( _num ) ; }	selects nodes using css3 selector query and returns the very first one .
public static string [ ] stringarrayfromproperties ( properties p , string propname , string tok ) { string [ ] ret = null ; string raw = p . getproperty ( propname ) ; if ( raw != null && raw . length ( ) > _num ) { try { stringtokenizer token = new stringtokenizer ( raw , tok ) ; int numpaths = token . counttokens ( ) ; ret = new string [ numpaths ] ; for ( int i = _num ; i < numpaths ; i ++ ) { ret [ i ] = token . nexttoken ( ) ; } return ret ; } catch ( java . util . nosuchelementexception e ) { e . printstacktrace ( ) ; } } return ret ; }	takes a string of representing token separated properties and returns an array of parsed strings.
private static int comparelocales ( locale primary , locale other ) { final string lang = primary . getlanguage ( ) ; if ( ( lang == null ) || ! lang . equals ( other . getlanguage ( ) ) ) { return _num ; } final string country = primary . getcountry ( ) ; if ( ( country == null ) || ! country . equals ( other . getcountry ( ) ) ) { return _num ; } final string variant = primary . getvariant ( ) ; if ( ( variant == null ) || ! variant . equals ( other . getvariant ( ) ) ) { return _num ; } return _num ; }	compares a locale against a primary locale.
void queryreadresult ( preparedstatement prep ) throws sqlexception { resultset rs = prep . executequery ( ) ; resultsetmetadata meta = rs . getmetadata ( ) ; int columncount = meta . getcolumncount ( ) ; while ( rs . next ( ) ) { for ( int i = _num ; i < columncount ; i ++ ) { rs . getstring ( i + _num ) ; } } }	execute a query and read all rows .
public static < v > boolean adddistinctentry ( list < v > sourcelist , v entry ) { return ( sourcelist != null && ! sourcelist . contains ( entry ) ) ? sourcelist . add ( entry ) : _bool ; }	add distinct entry to list.
public boolean equals ( object obj ) { if ( obj instanceof msort ) { msort ms = ( msort ) obj ; if ( data == ms . data ) return _bool ; } return _bool ; }	equal ( based on data , ignores index ).
public static void endtransaction ( final cconnection connection ) throws sqlexception { endtransaction ( connection . getconnection ( ) ) ; }	commits and finishes a formerly started transaction .
public ccrossreferencespanel ( ) { super ( new borderlayout ( ) ) ; m_table . setselectionmode ( listselectionmodel . single_selection ) ; add ( new jscrollpane ( m_table ) ) ; m_table . addmouselistener ( new internalmouselistener ( ) ) ; }	creates a new panel object .
private void doublecapacity ( ) { int p = head ; int n = elements . length ; int r = n - p ; int newcapacity = n << _num ; if ( newcapacity < _num ) throw new illegalstateexception ( _str ) ; object [ ] a = new object [ newcapacity ] ; system . arraycopy ( elements , p , a , _num , r ) ; system . arraycopy ( elements , _num , a , r , p ) ; elements = a ; head = _num ; tail = n ; }	double the capacity of this deque.
private void changeopenamdebugfolder ( string newopenamdebugfolder ) { systempropertiesmanager . initializeproperties ( debugconstants . config_debug_directory , newopenamdebugfolder ) ; }	change the debug logs folder.
protected string computefullurl ( url baseurl , string link ) { if ( link == null || link . length ( ) == _num ) { return null ; } if ( ! link . startswith ( _str ) ) { if ( link . startswith ( _str ) ) { link = baseurl . getprotocol ( ) + _str + baseurl . getauthority ( ) + link ; } else { if ( link . contains ( _str ) ) { return null ; } string path = baseurl . getpath ( ) ; if ( ! path . endswith ( _str ) ) { int sep = path . lastindexof ( _str ) ; string file = path . substring ( sep + _num ) ; if ( file . contains ( _str ) || file . contains ( _str ) ) path = path . substring ( _num , sep ) ; } link = baseurl . getprotocol ( ) + _str + baseurl . getauthority ( ) + path + _str + link ; } } link = normalizeurlending ( link ) ; string l = link . tolowercase ( locale . root ) ; if ( l . endswith ( _str ) || l . endswith ( _str ) || l . endswith ( _str ) || l . endswith ( _str ) ) { return null ; } return link ; }	computes the full url based on a base url and a possibly relative link found in the href param of an html anchor .
private void loadmanifest ( ) { if ( _ismanifestread ) return ; synchronized ( this ) { if ( _ismanifestread ) return ; try { _manifest = _jarpath . getmanifest ( ) ; if ( _manifest == null ) return ; attributes attr = _manifest . getmainattributes ( ) ; if ( attr != null ) addmanifestpackage ( _str , attr ) ; map < string , attributes > entries = _manifest . getentries ( ) ; for ( map . entry < string , attributes > entry : entries . entryset ( ) ) { string pkg = entry . getkey ( ) ; attr = entry . getvalue ( ) ; if ( attr == null ) continue ; addmanifestpackage ( pkg , attr ) ; } } catch ( ioexception e ) { log . log ( level . warning , e . tostring ( ) , e ) ; } finally { _ismanifestread = _bool ; } } }	reads the jar ' s manifest .
public referencebinding [ ] converttorawtypes ( referencebinding [ ] originaltypes , boolean forceerasure , boolean forcerawenclosingtype ) { if ( originaltypes == null ) return null ; referencebinding [ ] convertedtypes = originaltypes ; for ( int i = _num , length = originaltypes . length ; i < length ; i ++ ) { referencebinding originaltype = originaltypes [ i ] ; referencebinding convertedtype = ( referencebinding ) converttorawtype ( forceerasure ? originaltype . erasure ( ) : originaltype , forcerawenclosingtype ) ; if ( convertedtype != originaltype ) { if ( convertedtypes == originaltypes ) { system . arraycopy ( originaltypes , _num , convertedtypes = new referencebinding [ length ] , _num , i ) ; } convertedtypes [ i ] = convertedtype ; } else if ( convertedtypes != originaltypes ) { convertedtypes [ i ] = originaltype ; } } return convertedtypes ; }	convert an array of types in raw forms.
public void addcolumn ( int idx , column column ) { if ( column != null ) { columns . add ( idx , column ) ; } }	adds the given column at the specified position .
public void readdata ( datainput din ) throws ioexception { reference = din . readunsignedshort ( ) ; andmask = din . readunsignedshort ( ) ; ormask = din . readunsignedshort ( ) ; }	readdata - - dummy function.
boolean removedisplay ( display display ) { return m_displays . remove ( display ) ; }	remove a display from this visualization .
public double nextgaussian ( ) { if ( mhavenextnextgaussian ) { mhavenextnextgaussian = _bool ; return mnextnextgaussian ; } else { double v1 , v2 , s ; do { v1 = _num * nextdouble ( ) - _num ; v2 = _num * nextdouble ( ) - _num ; s = v1 * v1 + v2 * v2 ; } while ( s >= _num || s == _num ) ; final double multiplier = strictmath . sqrt ( - _num * strictmath . log ( s ) / s ) ; mnextnextgaussian = v2 * multiplier ; mhavenextnextgaussian = _bool ; return v1 * multiplier ; } }	return the next gaussian see knuth , acp , section 3.
private void fireevent ( final irunningquery q ) { if ( q == null ) throw new illegalargumentexception ( ) ; if ( listeners . isempty ( ) ) { return ; } final irunningquerylistener [ ] a = listeners . toarray ( new irunningquerylistener [ _num ] ) ; for ( irunningquerylistener l : a ) { final irunningquerylistener listener = l ; try { listener . notify ( q ) ; } catch ( throwable t ) { if ( innercause . isinnercause ( t , interruptedexception . class ) ) { throw new runtimeexception ( t ) ; } log . error ( t , t ) ; } } }	send an event to all registered listeners .
private void updatecontactheaderport ( int localport , sipmessage message ) { if ( message != null && message . getcontactheader ( ) != null ) { contactheader contactheader = message . getcontactheader ( ) ; address contactaddress = contactheader . getaddress ( ) ; contactaddress . setport ( localport ) ; } }	update port of contact header to reflect local port.
public static androidhttpclient newinstance ( string useragent ) { return newinstance ( useragent , null ) ; }	create a new httpclient with reasonable defaults ( which you can update ) .
@ nullable gridcachemvcccandidate addentry ( gridlocalcacheentry entry ) throws gridcacheentryremovedexception { gridcachemvcccandidate c = entry . addlocal ( threadid , lockver , null , null , timeout , ! intx ( ) , intx ( ) , implicitsingle ( ) , _bool ) ; entries . add ( entry ) ; if ( c == null && timeout < _num ) { if ( log . isdebugenabled ( ) ) log . debug ( _str + entry ) ; onfailed ( ) ; return null ; } if ( c != null ) { entry . readylocal ( c ) ; } return c ; }	adds entry to future .
@ override public void visitvertex ( streetrouter . state state ) { integer edgeidx = state . backedge ; if ( ! ( edgeidx == null || edgeidx == - _num ) ) { edgestore . edge edge = edgestore . getcursor ( edgeidx ) ; geojsonfeature feature = new geojsonfeature ( edge . getgeometry ( ) ) ; feature . addproperty ( _str , state . weight ) ; feature . addproperty ( _str , state . streetmode ) ; feature . addproperty ( _str , state . backedge ) ; features . add ( feature ) ; } }	saves current state geometry mode and weight as geojson feature properties in list of features . it is used in full state graph when debugging.
public void test_bsbm_q1_nosolutions ( ) throws exception { final testhelper helper = new testhelper ( _str , _str , new string [ ] { } , _str ) ; assertsamejoinorder ( new int [ ] { _num , _num , _num , _num , _num } , helper ) ; }	test of bsbm q1 against an empty data set.
public static void deletefileorlog ( file file ) { if ( ! file . delete ( ) ) { logger . warn ( failed_deleting_file + file . getpath ( ) ) ; } }	delete a file from the file system or log the failure if unable to delete it .
public synchronized void remove ( int index ) { super . remove ( index ) ; mmaxvalues . remove ( index ) ; }	removes existing values from the series .
public gitlabgroupmember addgroupmember ( gitlabgroup group , gitlabuser user , gitlabaccesslevel accesslevel ) throws ioexception { return addgroupmember ( group . getid ( ) , user . getid ( ) , accesslevel ) ; }	add a group member .
protected logger ( string name , string resourcebundlename ) { super ( name , resourcebundlename ) ; }	protected method to construct a logger for a named subsystem.
@ override public void increment ( double coord , short val ) { int bin = getbinnr ( coord ) ; if ( bin < _num ) { if ( size - bin > data . length ) { short [ ] tmpdata = new short [ growsize ( data . length , size - bin ) ] ; system . arraycopy ( data , _num , tmpdata , - bin , size ) ; data = tmpdata ; } else { system . arraycopy ( data , _num , data , - bin , size ) ; arrays . fill ( data , _num , - bin , ( short ) _num ) ; } data [ _num ] = val ; assert ( data . length >= size - bin ) ; offset -= bin ; size -= bin ; } else if ( bin >= data . length ) { short [ ] tmpdata = new short [ growsize ( data . length , bin + _num ) ] ; system . arraycopy ( data , _num , tmpdata , _num , size ) ; tmpdata [ bin ] = val ; data = tmpdata ; size = bin + _num ; max = double . max_value ; } else { if ( bin >= size ) { size = bin + _num ; } data [ bin ] += val ; } }	increment the value of a bin .
public static void checkargument ( boolean expression , object errormessage ) { if ( ! expression ) { throw new illegalargumentexception ( string . valueof ( errormessage ) ) ; } }	ensures the truth of an expression involving one or more parameters to the calling method .
default document putall ( map < ? extends charsequence , object > fields ) { if ( fields != null ) { for ( map . entry < ? extends charsequence , object > entry : fields . entryset ( ) ) { set ( entry . getkey ( ) , entry . getvalue ( ) ) ; } } return this ; }	sets on this object all key / value pairs from the supplied map.
private boolean containsignorecase ( list < string > stringlist , string match ) { for ( string s : stringlist ) { if ( s . equalsignorecase ( match ) ) { return _bool ; } } return _bool ; }	checks if a list of string contains a string while ignoring case.
public static double computemad ( double [ ] x , double median ) { for ( int i = _num ; i < x . length ; i ++ ) { x [ i ] = math . abs ( x [ i ] - median ) ; } double mad = quickselect . median ( x ) ; if ( ! ( mad > _num ) ) { double min = double . positive_infinity ; for ( double xi : x ) { if ( xi > _num && xi < min ) { min = xi ; } } if ( min < double . positive_infinity ) { mad = min ; } else { mad = _num ; } } return mad ; }	compute the median absolute deviation from median .
private static < t > void initializeknownplugins ( final t plugininterface , final ipluginregistry < iplugin < t > > registry , final list < pluginconfigitem > xmlpluginorder , final list < pair < iplugin < t > , pluginstatus > > validatedplugins , final list < pair < iplugin < t > , exception > > initializedplugins , final set < long > processedplugins ) { for ( final pluginconfigitem pt : xmlpluginorder ) { processedplugins . add ( pt . getguid ( ) ) ; final iplugin < t > plugin = findplugin ( validatedplugins , pt . getguid ( ) ) ; if ( plugin != null ) { if ( pt . isload ( ) ) { initializeplugin ( plugin , plugininterface , registry , initializedplugins ) ; } else { registry . adddisabledplugin ( plugin , disabledpluginreason . notloaded ) ; } } } }	loads the plugins that are configured in the configuration file .
public static void sessionstop ( ) { if ( mprocess == null ) return ; mprocess . destroy ( ) ; mprocess = null ; }	stops the superuser session.
public static void keepalive ( final boolean keepalive ) { setproperty ( _str , boolean . tostring ( keepalive ) ) ; }	set the ' http.
public static request newuploadvideorequest ( session session , file file , callback callback ) throws filenotfoundexception { parcelfiledescriptor descriptor = parcelfiledescriptor . open ( file , parcelfiledescriptor . mode_read_only ) ; bundle parameters = new bundle ( _num ) ; parameters . putparcelable ( file . getname ( ) , descriptor ) ; return new request ( session , my_videos , parameters , httpmethod . post , callback ) ; }	creates a new request configured to upload a photo to the user ' s default photo album.
private static byte [ ] readcheckedbytes ( byte [ ] buffer , int datasize ) throws invalidprotocolbuffernanoexception { checkedmessage wrapper = new checkedmessage ( ) ; messagenano . mergefrom ( wrapper , buffer , _num , datasize ) ; crc32 checksum = new crc32 ( ) ; checksum . update ( wrapper . payload ) ; if ( wrapper . checksum != checksum . getvalue ( ) ) { throw new invalidprotocolbuffernanoexception ( _str ) ; } return wrapper . payload ; }	unwrap a proto message from a checkedmessage , verifying the checksum .
private multicastsocket createsocket ( ) throws ioexception { multicastsocket sock = new multicastsocket ( mcastport ) ; sock . setloopbackmode ( _bool ) ; if ( sockitf != null ) sock . setinterface ( sockitf ) ; if ( sock . getloopbackmode ( ) ) u . warn ( log , _str + _str ) ; sock . joingroup ( mcastgrp ) ; if ( ttl != - _num ) sock . settimetolive ( ttl ) ; return sock ; }	creates multicast socket and joins multicast group .
protected void checkselectedsubsetmetadata ( examplesetmetadata subsetmetadata ) { }	can be overridden to check the selected attributes for compatibility .
private void validatewill ( string dest , object payload ) { if ( ( dest == null ) || ( payload == null ) ) { throw new illegalargumentexception ( ) ; } mqtttopic . validate ( dest , _bool ) ; }	validates the will fields .
public berinputstream ( inputstream in , int initialsize ) throws ioexception { this . in = in ; buffer = new byte [ initialsize ] ; next ( ) ; if ( length != indefinit_length ) { if ( buffer . length < ( length + offset ) ) { byte [ ] newbuffer = new byte [ length + offset ] ; system . arraycopy ( buffer , _num , newbuffer , _num , offset ) ; buffer = newbuffer ; } } else { isindefinedlength = _bool ; throw new asn1exception ( _str ) ; } }	creates stream for decoding .
private member nextmember ( member . type type ) { return new testmember ( type , new address ( _str , ++ port ) , new address ( _str , port + _num ) ) ; }	returns the next server address .
protected void encodelinesuffix ( outputstream astream ) throws ioexception { pstream . println ( ) ; }	encode the suffix that ends every output line.
boolean issystemfont ( ) { return systemfont ; }	checks if this is a system font.
public void addtobeloaded ( final string url ) { if ( tobeloaded == null ) { tobeloaded = new arraylist < string > ( ) ; } if ( stringutils . isnotblank ( url ) ) { tobeloaded . add ( url ) ; } }	this methods allows to indicate if the resource must be obtained.
default document putall ( iterator < field > fields ) { while ( fields . hasnext ( ) ) { field field = fields . next ( ) ; setvalue ( field . getname ( ) , field . getvalue ( ) ) ; } return this ; }	sets on this object all name / value pairs from the supplied object.
public appraisegitreviewclient ( repository repo ) { this . repo = repo ; this . author = new personident ( repo ) ; }	creates a new client for the given git repository .
public rootblockview ( final boolean rootblock0 , final bytebuffer buf , final checksumutility checker ) throws rootblockexception { if ( buf == null ) throw new illegalargumentexception ( ) ; if ( buf . remaining ( ) != sizeof_root_block ) { throw new illegalargumentexception ( _str + sizeof_root_block + _str + buf . remaining ( ) ) ; } this . buf = buf . asreadonlybuffer ( ) ; this . rootblock0 = rootblock0 ; switch ( getstoretype ( ) ) { case rw : { am = new rwaddressmanager ( null ) ; break ; } case worm : { final int offsetbits = getoffsetbits ( ) ; am = new wormaddressmanager ( offsetbits ) ; break ; } default : throw new rootblockexception ( _str + getstoretype ( ) ) ; } if ( checker == null ) { log . warn ( _str ) ; } this . checker = checker ; valid ( ) ; }	create a new read - only view from the supplied buffer .
protected soaprequest createsoaprequest ( final string methodname , final soapmethodrequestwriter requestwriter ) { final postmethod method = new postmethod ( endpoint . tostring ( ) ) ; method . setcontentchunked ( _bool ) ; setrequestheaders ( method , methodname ) ; final soaprequestentity requestentity = buildrequestentity ( methodname , requestwriter ) ; requestentity . setsoapheaderprovider ( soapheaderprovider ) ; final bufferedsoaprequestentity bufferedentity = new bufferedsoaprequestentity ( requestentity ) ; method . setrequestentity ( bufferedentity ) ; return new soaprequest ( method , requestentity ) ; }	create a soap request for the given method name.
@ suppresswarnings ( _str ) @ test public void innerenum ( ) { class < ? > pc = playingcard . class ; list < enum < ? > > include = new arraylist < > ( ) ; list < enum < ? > > exclude = new arraylist < > ( ) ; for ( class < ? > c : pc . getdeclaredclasses ( ) ) { int mods = c . getmodifiers ( ) ; if ( c . isenum ( ) ) { if ( modifier . ispublic ( mods ) ) { include . addall ( aslist ( c . getenumconstants ( ) ) ) ; } else { exclude . addall ( aslist ( c . getenumconstants ( ) ) ) ; } } } set < typedoperation > actual = getconcreteoperations ( pc ) ; assertequals ( _str , include . size ( ) + _num , actual . size ( ) ) ; for ( enum < ? > e : include ) { asserttrue ( _str + e . name ( ) + _str , actual . contains ( createenumoperation ( e ) ) ) ; } for ( enum < ? > e : exclude ) { assertfalse ( _str + e . name ( ) + _str , actual . contains ( createenumoperation ( e ) ) ) ; } }	innerenum tests that reflection.
public string touri ( ) { chararraybuffer buffer = new chararraybuffer ( _num ) ; buffer . append ( this . schemename ) ; buffer . append ( _str ) ; buffer . append ( this . hostname ) ; if ( this . port != - _num ) { buffer . append ( _str ) ; buffer . append ( integer . tostring ( this . port ) ) ; } return buffer . tostring ( ) ; }	return the host uri , as a string .
public void testwildcardsdoesnotneedtwodots ( ) throws exception { string cert = _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str ; certificatefactory cf = certificatefactory . getinstance ( _str ) ; inputstream in = new bytearrayinputstream ( cert . getbytes ( _str ) ) ; x509certificate x509 = ( x509certificate ) cf . generatecertificate ( in ) ; mysslsession session = new mysslsession ( new x509certificate [ ] { x509 } ) ; hostnameverifier verifier = httpsurlconnection . getdefaulthostnameverifier ( ) ; asserttrue ( verifier . verify ( _str , session ) ) ; }	earlier implementations of android ' s hostname verifier required that wildcard names wouldn ' t match " *.
public static boolean intargetdir ( file file ) { return intargetdir ( file . topath ( ) ) ; }	verify that the supplied file or directory is within the target directory .
public final boolean skipany ( char c , charsequence csq ) { int i = index ; int n = csq . length ( ) ; for ( ; ( i < n ) && ( csq . charat ( i ) == c ) ; i ++ ) { } if ( i == index ) return _bool ; index = i ; return _bool ; }	moves this cursor forward until it points to a character different from the specified character .
public synchronized boolean removeall ( collection c ) { object [ ] elements = getarray ( ) ; int len = elements . length ; if ( len != _num ) { int newlen = _num ; object [ ] temp = new object [ len ] ; for ( int i = _num ; i < len ; ++ i ) { object element = elements [ i ] ; if ( ! c . contains ( element ) ) temp [ newlen ++ ] = element ; } if ( newlen != len ) { setarray ( copyofrange ( temp , _num , newlen , object [ ] . class ) ) ; return _bool ; } } return _bool ; }	removes from this list all of its elements that are contained in the specified collection.
private final boolean compareandsettail ( node expect , node update ) { return unsafe . compareandswapobject ( this , tailoffset , expect , update ) ; }	cas tail field . used only by enq .
public phone createphone ( string value ) { phonefield phoneimpl = new phonefield ( ) ; try { phoneimpl . setvalue ( value ) ; } catch ( sdpexception s ) { s . printstacktrace ( ) ; } return phoneimpl ; }	returns phone object with the specified value .
private listresourcebundle loadresourcebundle ( string resourcebundle ) throws missingresourceexception { m_resourcebundlename = resourcebundle ; locale locale = getlocale ( ) ; listresourcebundle lrb ; try { resourcebundle rb = resourcebundle . getbundle ( m_resourcebundlename , locale ) ; lrb = ( listresourcebundle ) rb ; } catch ( missingresourceexception e ) { try { lrb = ( listresourcebundle ) resourcebundle . getbundle ( m_resourcebundlename , new locale ( _str , _str ) ) ; } catch ( missingresourceexception e2 ) { throw new missingresourceexception ( _str + m_resourcebundlename , m_resourcebundlename , _str ) ; } } m_resourcebundle = lrb ; return lrb ; }	return a named resourcebundle for a particular locale.
private set < string > returnremotepoolsassociatedwithremotecopysettings ( map < string , list < string > > remotecopysettings , set < string > pooluris ) { set < string > remotepooluris = new hashset < string > ( ) ; for ( entry < string , list < string > > entry : remotecopysettings . entryset ( ) ) { virtualpool vpool = _objectcache . queryobject ( virtualpool . class , uri . create ( entry . getkey ( ) ) ) ; if ( null == vpool ) { remotepooluris . addall ( pooluris ) ; } else if ( null != vpool . getusematchedpools ( ) && vpool . getusematchedpools ( ) ) { if ( null != vpool . getmatchedstoragepools ( ) ) { remotepooluris . addall ( vpool . getmatchedstoragepools ( ) ) ; } } else if ( null != vpool . getassignedstoragepools ( ) ) { remotepooluris . addall ( vpool . getassignedstoragepools ( ) ) ; } } return remotepooluris ; }	choose pools based on remote vpool ' s matched or assigned pools.
private string converttohtml ( final string string ) { return _str + string . replaceall ( _str , _str ) + _str ; }	converts text to html , by transforming \ n to < br / >.
private synchronized void addlock ( filelock lock ) throws overlappingfilelockexception { long lockend = lock . position ( ) + lock . size ( ) ; for ( filelock existinglock : locks ) { if ( existinglock . position ( ) > lockend ) { break ; } if ( existinglock . overlaps ( lock . position ( ) , lock . size ( ) ) ) { throw new overlappingfilelockexception ( ) ; } } locks . add ( lock ) ; }	add a new pending lock to the manager.
public static void uf7 ( double [ ] x , double [ ] f , int nx ) { int count1 = _num ; int count2 = _num ; double sum1 = _num ; double sum2 = _num ; double yj ; for ( int j = _num ; j <= nx ; j ++ ) { yj = x [ j - _num ] - math . sin ( _num * pi * x [ _num ] + j * pi / nx ) ; if ( j % _num == _num ) { sum2 += yj * yj ; count2 ++ ; } else { sum1 += yj * yj ; count1 ++ ; } } yj = math . pow ( x [ _num ] , _num ) ; f [ _num ] = yj + _num * sum1 / ( double ) count1 ; f [ _num ] = _num - yj + _num * sum2 / ( double ) count2 ; }	evaluates the uf7 problem .
private void reloadmodelwithnewvalue ( final long newvalue ) { final long newvalueasprimitive = newvalue == null ? getmodelupdateperiod ( ) : newvalue ; for ( final propertychangelistener listener : modelupdateperiodlisteners ) { final propertychangeevent event = new propertychangeevent ( this , _str , getmodelupdateperiod ( ) , newvalueasprimitive ) ; listener . propertychange ( event ) ; } }	notify all listeners about cacheperiod property changed.
public static final string movetoucistring ( move m ) { string ret = squaretostring ( m . from ) ; ret += squaretostring ( m . to ) ; switch ( m . promoteto ) { case piece . wqueen : case piece . bqueen : ret += _str ; break ; case piece . wrook : case piece . brook : ret += _str ; break ; case piece . wbishop : case piece . bbishop : ret += _str ; break ; case piece . wknight : case piece . bknight : ret += _str ; break ; default : break ; } return ret ; }	convert a move object to uci string format .
public image createacceleratedimage ( component target , int width , int height ) { colormodel model = getcolormodel ( transparency . opaque ) ; writableraster wr = model . createcompatiblewritableraster ( width , height ) ; return new offscreenimage ( target , model , wr , model . isalphapremultiplied ( ) ) ; }	creates a new managed image of the given width and height that is associated with the target component .
public void displaystate ( ) { printwriter xout = context . get ( log . outkey ) ; xout . println ( _str + fileobjecthistory ) ; xout . println ( _str + opentypenames ) ; xout . println ( _str + generatedsourcenames ) ; xout . println ( _str + generatedclasses . keyset ( ) ) ; xout . println ( _str + aggregategeneratedsourcenames ) ; xout . println ( _str + aggregategeneratedclassnames ) ; }	debugging function to display internal state .
public static void writestringtowriter ( string string , writer writer ) throws ioexception { bufferedwriter bw = new bufferedwriter ( writer ) ; try { bw . write ( string ) ; } finally { bw . close ( ) ; } }	writes given string to given writer.
private void ensurecapacity ( int n ) { if ( n <= _num ) { return ; } int max ; if ( data == null || data . length == _num ) { max = _num ; } else if ( data . length >= n * _num ) { return ; } else { max = data . length ; } while ( max < n * _num ) { max *= _num ; } string newdata [ ] = new string [ max ] ; if ( length > _num ) { system . arraycopy ( data , _num , newdata , _num , length * _num ) ; } data = newdata ; }	ensure the internal array ' s capacity .
public final void decref ( ) throws ioexception { ensureopen ( ) ; final int rc = refcount . decrementandget ( ) ; if ( rc == _num ) { boolean success = _bool ; try { doclose ( ) ; closed = _bool ; success = _bool ; } finally { if ( ! success ) { refcount . incrementandget ( ) ; } } } else if ( rc < _num ) { throw new illegalstateexception ( _str + rc + _str ) ; } }	expert : decreases the refcount of this taxonomyreader instance.
public static x500name x500principaltox500name ( x500principal principal ) { return x500name . getinstance ( ksex500namestyle . instance , principal . getencoded ( ) ) ; }	convert an x . 500 principal to an x . 500 name .
private void assertdescribedresource ( final bigdatavalue describedresource , final idescribecache describecache , final testhelper h ) { final graph actualgraph = describecache . lookup ( describedresource . getiv ( ) ) ; assertnotnull ( actualgraph ) ; final set < statement > expectedgraph = getexpecteddescription ( describedresource , h ) ; h . comparegraphs ( new hashset < statement > ( actualgraph ) , expectedgraph ) ; for ( statement stmt : actualgraph ) { asserttrue ( stmt instanceof bigdatastatement ) ; final bigdatastatement st = ( bigdatastatement ) stmt ; assertnotnull ( st . s ( ) ) ; assertnotnull ( st . p ( ) ) ; assertnotnull ( st . o ( ) ) ; if ( st . getcontext ( ) != null ) { assertnotnull ( st . c ( ) ) ; } } }	assert that a resource is described by the cache .
public boolean isflat ( ) { return type_flat . equals ( gettype ( ) ) ; }	flat background type ( default ).
@ deprecated private list < charsequence > buildlimitednetworkslist ( ) { final context context = getactivity ( ) ; final arraylist < charsequence > limited = lists . newarraylist ( ) ; if ( hassubscription ( context ) ) { final string subscriberid = getactivesubscriberid ( context ) ; if ( mpolicyeditor . haslimitedpolicy ( buildtemplatemobileall ( subscriberid ) ) ) { limited . add ( gettext ( r . string . data_usage_list_mobile ) ) ; } if ( mpolicyeditor . haslimitedpolicy ( buildtemplatemobile3glower ( subscriberid ) ) ) { limited . add ( gettext ( r . string . data_usage_tab_3g ) ) ; } if ( mpolicyeditor . haslimitedpolicy ( buildtemplatemobile4g ( subscriberid ) ) ) { limited . add ( gettext ( r . string . data_usage_tab_4g ) ) ; } } if ( mpolicyeditor . haslimitedpolicy ( buildtemplatewifiwildcard ( ) ) ) { limited . add ( gettext ( r . string . data_usage_tab_wifi ) ) ; } if ( mpolicyeditor . haslimitedpolicy ( buildtemplateethernet ( ) ) ) { limited . add ( gettext ( r . string . data_usage_tab_ethernet ) ) ; } return limited ; }	build list of currently limited networks , which defines when background data is restricted .
public int evalrpn ( string [ ] tokens ) { if ( tokens == null || tokens . length == _num ) return _num ; stack < string > s = new stack < string > ( ) ; int len = tokens . length ; for ( int i = _num ; i < len ; i ++ ) { string cur = tokens [ i ] ; if ( isoperator ( cur ) ) { int t2 = integer . parseint ( s . pop ( ) ) ; int t1 = integer . parseint ( s . pop ( ) ) ; int res = calculate ( t1 , t2 , cur ) ; s . push ( integer . tostring ( res ) ) ; } else s . push ( cur ) ; } return integer . valueof ( s . peek ( ) ) ; }	assign a priority for each operators use a stack to store them note the numbers can be negative we evaluate the expression left - to - right and push operands onto the stack until we encounter an operator , which we pop the top two values from the stack.
public synchronized void addallseries ( list < xyseries > series ) { mseries . addall ( series ) ; }	adds all the provided xy series to the list .
private static void exit ( string errmsg , options options , int exitcode ) { if ( errmsg != null ) echo ( _str + errmsg ) ; string runner = system . getproperty ( ignite_prog_name , _str ) ; int space = runner . indexof ( _str ) ; runner = runner . substring ( _num , space == - _num ? runner . length ( ) : space ) ; if ( options != null ) { helpformatter formatter = new helpformatter ( ) ; formatter . printhelp ( runner , options ) ; } system . exit ( exitcode ) ; }	exists with optional error message , usage show and exit code .
@ override public int compare ( newsplitemittedterm term1 , newsplitemittedterm term2 ) { return term1 . compareto ( term2 ) ; }	compares term key 1 to term key 2.
public aabb merge ( aabb other ) { minx = math . min ( minx , other . minx ) ; maxx = math . max ( maxx , other . maxx ) ; miny = math . min ( miny , other . miny ) ; maxy = math . max ( maxy , other . maxy ) ; minz = math . min ( minz , other . minz ) ; maxz = math . max ( maxz , other . maxz ) ; return this ; }	computes an aabb that contains both this and other and stores it in this .
public static string generateautotag ( int stackoffset ) { stacktraceelement [ ] currentstack = getcurrentstack ( ) ; stacktraceelement element = currentstack [ stackoffset ] ; string classname = element . getclassname ( ) ; string pkgpath [ ] = classname . split ( _str ) ; if ( pkgpath . length > _num ) { classname = pkgpath [ pkgpath . length - _num ] ; } stringbuilder sbinnerclass = new stringbuilder ( ) ; int index ; string strloop = classname ; while ( ( index = strloop . lastindexof ( _str ) ) != - _num ) { string piece = strloop . substring ( index + _num ) ; sbinnerclass . insert ( _num , piece ) ; if ( ! piece . matches ( _str ) ) { break ; } sbinnerclass . insert ( _num , _str ) ; strloop = strloop . substring ( _num , index ) ; } if ( sbinnerclass . length ( ) > _num && sbinnerclass . charat ( _num ) == _str ) { sbinnerclass . deletecharat ( _num ) ; } string innerclassname = sbinnerclass . tostring ( ) ; if ( textutils . isdigitsonly ( innerclassname ) ) { innerclassname = null ; } return textutils . isempty ( innerclassname ) ? classname : innerclassname ; }	generate auto tag for logs .
public void flushpending ( ) throws saxexception { if ( m_needtocallstartdocument ) { startdocumentinternal ( ) ; m_needtocallstartdocument = _bool ; } if ( m_elemcontext . m_starttagopen ) { closestarttag ( ) ; m_elemcontext . m_starttagopen = _bool ; } if ( m_cdatatagopen ) { closecdata ( ) ; m_cdatatagopen = _bool ; } if ( m_writer != null ) { try { m_writer . flush ( ) ; } catch ( ioexception e ) { } } }	this method flushes any pending events , which can be startdocument ( ) closing the opening tag of an element , or closing an open cdata section .
@ postconstruct public void init ( ) { configurationviews . add ( defaultdistributionsettypelayout ) ; configurationviews . add ( authenticationconfigurationview ) ; configurationviews . add ( pollingconfigurationview ) ; }	init method adds all configuration views to the list of views .
public extendedtype ( int nodetype , string namespace , string localname ) { this . nodetype = nodetype ; this . namespace = namespace ; this . localname = localname ; this . hash = nodetype + namespace . hashcode ( ) + localname . hashcode ( ) ; }	create an extendedtype object from node type , namespace and local name.
private static void validatenewaddition ( vector paths , expressionowner owner , locpathiterator path ) throws runtimeexception { assertion ( owner . getexpression ( ) == path , _str ) ; int n = paths . size ( ) ; for ( int i = _num ; i < n ; i ++ ) { expressionowner ew = ( expressionowner ) paths . elementat ( i ) ; assertion ( ew != owner , _str ) ; assertion ( ew . getexpression ( ) != path , _str ) ; } }	validate some assumptions about the new locpathiterator and it ' s owner and the state of the list .
@ override public void start ( ) { for ( int i = _num ; i < threadcount ; ++ i ) { set < systemstreampartition > threadssps = new hashset < systemstreampartition > ( ) ; for ( systemstreampartition ssp : ssps ) { if ( math . abs ( ssp . hashcode ( ) ) % threadcount == i ) { threadssps . add ( ssp ) ; } } thread thread = new thread ( new mocksystemconsumerrunnable ( threadssps ) , _str + i ) ; thread . setdaemon ( _bool ) ; threads . add ( thread ) ; thread . start ( ) ; } }	assign systemstreampartitions to all of the threads , and start them up to begin simulating consuming messages .
public void undo ( ) { try { if ( undomanager != null ) undomanager . undoorredo ( ) ; } catch ( cannotundoexception ignored ) { } catch ( cannotredoexception ignored ) { } }	undoes the last action .
public void removecolumn ( column column ) { if ( column != null ) { columns . remove ( column ) ; } }	removes the given column .
public string info ( ) { stringbuilder sb = new stringbuilder ( _str + tablesize + _str + elements + _str + loadfactor + _str + threshold ) ; sb . append ( _str + numempty ) ; int size = _num ; int min = elements ; int max = - _num ; for ( int i = _num ; i < tablesize ; i ++ ) { linkedlist < string > list = bins [ i ] ; if ( list != null ) { int sz = list . size ( ) ; size += sz ; if ( sz < min ) { min = sz ; } if ( sz > max ) { max = sz ; } } } float avg = size ; int base = ( tablesize - numempty ) ; if ( base == _num ) { sb . append ( _str ) ; sb . append ( _str ) ; sb . append ( _str ) ; } else { avg /= base ; sb . append ( _str + avg ) ; sb . append ( _str + min ) ; sb . append ( _str + max ) ; } return sb . tostring ( ) ; }	return single line of output .
public boolean peeksample ( mediacodec . bufferinfo out_bufferinfo ) { update ( ) ; boolean result = _bool ; if ( ! mavailableoutputbuffers . isempty ( ) ) { int index = mavailableoutputbuffers . peek ( ) ; mediacodec . bufferinfo info = moutputbufferinfo [ index ] ; out_bufferinfo . set ( info . offset , info . size , info . presentationtimeus , info . flags ) ; result = _bool ; } return result ; }	performs a peek ( ) operation in the queue to extract media info for the buffer ready to be released i.
@ override public abstractscannedresult scanblocklet ( blockschunkholder blockschunkholder ) throws queryexecutionexception { try { fillscannedresult ( blockschunkholder ) ; } catch ( filterunsupportedexception e ) { throw new queryexecutionexception ( e . getmessage ( ) ) ; } return scannedresult ; }	below method will be used to process the block.
@ override public int hashcode ( ) { return subconditions . hashcode ( ) - operator . hashcode ( ) ; }	returns the hashcode for the condition.
public void balancesegments ( ) { macctschemaelement [ ] elements = m_acctschema . getacctschemaelements ( ) ; for ( int i = _num ; i < elements . length ; i ++ ) { macctschemaelement ase = elements [ i ] ; if ( ase . isbalanced ( ) ) balancesegment ( ase . getelementtype ( ) ) ; } }	balance all segments . - for all balancing segments - for all segment values - if balance < > 0 create dueto / duefrom line overwriting the segment value.
public annotationdrawer ( final annotationsmodel model , final processrenderermodel renderermodel ) { this . model = model ; this . renderermodel = renderermodel ; this . displaycache = new hashmap < > ( ) ; this . cachedid = new hashmap < > ( ) ; pane = new jeditorpane ( _str , _str ) ; pane . setborder ( null ) ; pane . setopaque ( _bool ) ; }	creates a new drawer for the specified model and decorator .
public boolean hasuserpartitions ( ) { return ! useroutput . isempty ( ) ; }	retrieves if user partitions are present.
@ override public void insertstring ( final int offs , final string str , final attributeset attr ) { if ( offs < _num ) { return ; } if ( str . length ( ) > _num ) { int i ; for ( i = _num ; i < str . length ( ) ; i ++ ) { if ( str . charat ( i ) == _str ) { remainingtextstring = str . substring ( i + _num ) ; remainingtextattr = attr ; inputkeylistener . keypressed ( new keyevent ( new container ( ) , keyevent . key_pressed , _num , _num , keyevent . vk_enter , _str ) ) ; break ; } else { insertchar ( offs + i , _str + str . charat ( i ) ) ; } } } else if ( str . length ( ) == _num ) { insertchar ( offs , str ) ; } }	insert a string of source code to be highlighted to the document.
protected int readcodepoint ( ) throws ioexception { int next = reader . read ( ) ; if ( character . ishighsurrogate ( ( char ) next ) ) { next = character . tocodepoint ( ( char ) next , ( char ) reader . read ( ) ) ; } return next ; }	reads the next unicode code point .
public static int putint ( byte [ ] bytes , int offset , int val ) { if ( littleendian ) { val = integer . reversebytes ( val ) ; } theunsafe . putint ( bytes , offset + byte_array_base_offset , val ) ; return offset + bytes . sizeof_int ; }	put an int value out to the specified byte array position in big - endian format .
public item ( drawable symbol , string labeltext , font font ) { double fontsize = font . getsize2d ( ) ; setlayout ( new edgelayout ( fontsize , _num ) ) ; this . symbol = symbol ; add ( symbol , location . west ) ; label = new label ( labeltext ) ; label . setfont ( font ) ; label . setalignmentx ( _num ) ; label . setalignmenty ( _num ) ; add ( label , location . center ) ; }	creates a new item object with the specified data source and text .
void tag ( string tag ) ;	set a one - time tag for use on the next logging call .
public int consume ( ) { int consumedamount ; if ( math . abs ( left ) < math . abs ( getregen ( ) ) ) { consumedamount = left ; left = _num ; } else { consumedamount = getregen ( ) ; left -= getregen ( ) ; } return consumedamount ; }	consumes a part of this item .
public fromclause add ( outerjoinqualifier outerjoinqualifier ) { outerjoinqualifiers . add ( outerjoinqualifier ) ; return this ; }	adds an outer join descriptor that defines how the streams are related via outer joins.
private static final file [ ] encode ( string src ) { if ( src == null || src . length ( ) == _num ) { return ( new file [ _num ] ) ; } stringtokenizer tokenizer = new stringtokenizer ( src , _str ) ; file [ ] dirs = new file [ tokenizer . counttokens ( ) ] ; for ( int i = _num ; i < dirs . length ; i ++ ) { dirs [ i ] = new file ( tokenizer . nexttoken ( ) ) ; } return dirs ; }	splits the string into an array.
public e poll ( long timeout , timeunit unit ) throws interruptedexception { long nanos = unit . tonanos ( timeout ) ; final reentrantlock lock = this . lock ; lock . lockinterruptibly ( ) ; long t = now ( ) ; tenantqueue . item item = null ; try { for ( ; ; ) { tenantqueue q = nextqueue ( t ) ; if ( q == null ) { if ( nanos <= _num ) return null ; else nanos = available . awaitnanos ( nanos ) ; } else { long delay = q . next - t ; if ( delay <= _num ) { item = q . poll ( t ) ; return item == null ? null : item . element ; } if ( nanos <= _num ) return null ; if ( nanos < delay || leader != null ) nanos = available . awaitnanos ( nanos ) ; else { thread thisthread = thread . currentthread ( ) ; leader = thisthread ; try { long timeleft = available . awaitnanos ( delay ) ; nanos -= delay - timeleft ; } finally { if ( leader == thisthread ) leader = null ; } } } t = system . nanotime ( ) ; } } finally { if ( leader == null && hasnext ( ) ) available . signal ( ) ; lock . unlock ( ) ; done ( item , t ) ; } }	retrieves and removes the head of this queue , waiting if necessary until an element with an expired delay is available on this queue , or the specified wait time expires .
public void addswipelistener ( swipelistener listener ) { if ( mlisteners == null ) { mlisteners = new arraylist < swipelistener > ( ) ; } mlisteners . add ( listener ) ; }	add a callback to be invoked when a swipe event is sent to this view .
public int size ( ) { return patterns . size ( ) ; }	size of the cluster .
public static void writeuint8 ( outputstream theos , int thevalue ) throws ioexception { theos . write ( thevalue ) ; }	writes a " uint8 " in wsp format to the given output stream .
public void testcase11 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = _num ; int bsign = - _num ; byte rbytes [ ] = { _num , _num , _num , _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . add ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	add two numbers of different length and sign.
@ override public void addheader ( final string header , final string value ) { mheadersoptions . add ( new headeroption ( header , value ) ) ; }	adds a header to this request .
public void store ( ) throws samlexception { try { keyprovider . store ( ) ; } catch ( keystoreexception e ) { throw new samlexception ( e . getmessage ( ) ) ; } catch ( certificateexception e ) { throw new samlexception ( e . getmessage ( ) ) ; } catch ( nosuchalgorithmexception e ) { throw new samlexception ( e . getmessage ( ) ) ; } catch ( ioexception e ) { throw new samlexception ( e . getmessage ( ) ) ; } }	store the keystore changes.
static void appendtopointerhierarchy ( final basetype type , final basetype pointer ) { preconditions . checknotnull ( type , _str ) ; preconditions . checknotnull ( pointer , _str ) ; preconditions . checkargument ( type != pointer , _str ) ; preconditions . checkargument ( pointer . pointedtoby != type , _str ) ; preconditions . checkargument ( type . pointsto != pointer , _str ) ; pointer . pointsto = type ; type . pointedtoby = pointer ; }	appends a base type to the pointer hierarchy just below parent , e.
public static void sort ( long [ ] a ) { dosort ( a , _num , a . length - _num ) ; }	sorts the specified array into ascending numerical order .
public string tostring ( ) { return _str + string . format ( _str , valuesimilarity * _num ) + _str + string . format ( _str , containmentsimilarity * _num ) + _str + string . format ( _str , sizesimilarity * _num ) ; }	return a string representation of this object , describing all aspects of similarity .
public optional < t > last ( ) { iterator < t > iterator = iterator ( ) ; t value = null ; while ( iterator . hasnext ( ) ) value = iterator . next ( ) ; return optional . of ( value ) ; }	convert an iterable stream into one last item of the stream .
public static void threadsleep ( long millis ) { try { thread . sleep ( millis ) ; } catch ( interruptedexception ex ) { log . e ( _str , stringutils . exceptionstacktracetostring ( ex ) ) ; } }	makes the thread sleep for some time.
public int indexof ( node elem , int index ) { runto ( - _num ) ; if ( null == m_map ) return - _num ; for ( int i = index ; i < m_firstfree ; i ++ ) { node node = m_map [ i ] ; if ( ( null != node ) && node . equals ( elem ) ) return i ; } return - _num ; }	searches for the first occurence of the given argument , beginning the search at index , and testing for equality using the equals method .
static boolean ispackageaccess ( final int modifiers ) { return ( modifiers & access_test ) == _num ; }	returns whether a given set of modifiers implies package access .
public void write ( final string filename ) { printstream stream ; try { stream = new printstream ( new file ( filename ) ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; return ; } write ( stream ) ; stream . close ( ) ; }	writes the gathered data tab - separated into a text file .
managedwindowdecorator ( window window , string windowid ) { this . window = window ; name = _str + windowid ; }	create a managed window decorator with an identity for a window .
@ override public void write ( byte [ ] b , int off , int len ) throws ioexception { while ( len > _num ) { int c = math . min ( len , decoderin . remaining ( ) ) ; decoderin . put ( b , off , c ) ; processinput ( _bool ) ; len -= c ; off += c ; } if ( writeimmediately ) { flushoutput ( ) ; } }	write bytes from the specified byte array to the stream .
public static void log ( string message , object ... args ) { if ( loggingenabled ) { log . d ( tag , args . length == _num ? message : string . format ( message , args ) ) ; } }	send a log message if logging is enabled .
protected void processupdates ( queue < deviceupdate > updates ) { if ( updates == null ) return ; deviceupdate update = null ; while ( null != ( update = updates . poll ( ) ) ) { if ( logger . istraceenabled ( ) ) { logger . trace ( _str , update ) ; } if ( update . change == deviceupdate . change . delete ) { devicesyncmanager . removedevice ( update . device ) ; } else { devicesyncmanager . storedevice ( update . device ) ; } list < idevicelistener > listeners = devicelisteners . getorderedlisteners ( ) ; notifylisteners ( listeners , update ) ; } }	send update notifications to listeners.
boolean handleremotecanrebalance ( long size ) { return _bool ; }	checks if this partitionedregiondatastore has the capacity to handle the rebalancing size .
public static file tosldfile ( final file file ) { final string path = file . getabsolutepath ( ) ; final string base = path . substring ( _num , path . length ( ) - _num ) ; string newpath = base + _str ; file sld = new file ( newpath ) ; if ( sld . exists ( ) ) { return sld ; } newpath = base + _str ; sld = new file ( newpath ) ; if ( sld . exists ( ) ) { return sld ; } return null ; }	figure out if a valid sld file is available .
private string insertproperties ( string template , map < string , string > properties ) { for ( entry < string , string > entry : properties . entryset ( ) ) { template = template . replace ( entry . getkey ( ) , entry . getvalue ( ) ) ; } return template ; }	inserts properties to the template .
public static void changefont ( jcomponent comp , int style ) { font font = comp . getfont ( ) ; comp . setfont ( font . derivefont ( style ) ) ; }	change the font style of a component.
public void drawcontours ( mat img , color color ) { drawing . drawcontours ( img , contours , color ) ; }	draw contours matched by the blob detector.
public static void savex509cert ( string certstr , file certfile ) throws ioexception { bufferedwriter writer = new bufferedwriter ( new filewriter ( certfile ) ) ; writer . write ( begin_cert ) ; writer . newline ( ) ; writer . write ( certstr ) ; writer . newline ( ) ; writer . write ( end_cert ) ; writer . newline ( ) ; writer . close ( ) ; }	save a certificate to a file in base 64 binary format with begin and end strings.
public void clearoncentralpositionchangedlistener ( ) { moncentralpositionchangedlisteners . clear ( ) ; }	clear all listeners that listening the central item of the list changes event .
public static object invokestatic ( class clazz , string methodname ) throws nosuchmethodexception { try { method method = clazz . getmethod ( methodname , new class [ _num ] ) ; object result = method . invoke ( null , new object [ _num ] ) ; return result ; } catch ( illegalaccessexception e ) { throw new nosuchmethodexception ( methodname + _str ) ; } catch ( invocationtargetexception e ) { throw new internalerror ( e . getmessage ( ) ) ; } }	invokes the specified accessible parameterless method if it exists .
@ deprecated public boolean isfillbelowline ( ) { return mfillbelowline . size ( ) > _num ; }	returns if the chart should be filled below the line .
public void onpatchserviceresult ( boolean isupgradepatch ) { if ( ! isretryenable ) { tinkerlog . w ( tag , _str ) ; return ; } if ( ! isupgradepatch ) { tinkerlog . w ( tag , _str ) ; return ; } if ( retryinfofile . exists ( ) ) { sharepatchfileutil . safedeletefile ( retryinfofile ) ; } if ( temppatchfile . exists ( ) ) { sharepatchfileutil . safedeletefile ( temppatchfile ) ; } }	if we receive any result , we can delete the temp retry info file.
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return note_id ; case _num : return class_name ; case _num : return interpreter_context ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public static boolean isstanza ( packet packet ) { if ( packet instanceof message ) return _bool ; if ( packet instanceof iq ) return _bool ; if ( packet instanceof presence ) return _bool ; return _bool ; }	returns true if the packet is a stanza as defined in rfc - 6121 - a message , iq or presence packet .
@ override public int execute ( final formobject form , final int type , final string code , final int eventtype , final char keypressed ) { int messagecode = actionhandler . nomessage ; if ( code instanceof string ) { final string js = code ; final string [ ] args = jsfunction . converttoarray ( js ) ; final string command = args [ _num ] ; if ( command . startswith ( _str ) ) { messagecode = handleafcommands ( form , command , js , args , eventtype , keypressed ) ; } } return messagecode ; }	execute javascript and reset forms values.
private boolean needsupdate ( long bundleversion , string beanversion ) { if ( beanversion . contains ( _str ) ) { log . i ( tag , _str + bundleversion ) ; log . i ( tag , _str + beanversion ) ; return _bool ; } else { try { long parsedversion = long . parselong ( beanversion . split ( _str ) [ _num ] ) ; log . i ( tag , _str + bundleversion ) ; log . i ( tag , _str + parsedversion ) ; if ( bundleversion > parsedversion ) { return _bool ; } else { log . i ( tag , _str ) ; } } catch ( numberformatexception e ) { log . e ( tag , _str + beanversion ) ; fail ( beanerror . unparsable_fw_version ) ; } } return _bool ; }	helper function to determine whether a bean needs a fw update given a specific bundle version.
public void clear ( facescontext facescontext , map < string , object > viewmap ) { if ( logger . isloggable ( level . finest ) ) { logger . log ( level . finest , _str ) ; } map < string , viewscopecontextobject > contextmap = getcontextmap ( facescontext , viewmap ) ; if ( contextmap != null ) { destroybeans ( viewmap , contextmap ) ; } }	clear the given view map .
public void loadlogicaltableswithgranularities ( map < string , tablegroup > namegroupmap , set < ? extends granularity > validgrains , resourcedictionaries dictionaries ) { for ( map . entry < string , tablegroup > entry : namegroupmap . entryset ( ) ) { string logicaltablename = entry . getkey ( ) ; tablegroup group = entry . getvalue ( ) ; loadlogicaltablewithgranularities ( logicaltablename , group , validgrains , dictionaries ) ; } }	load several logical tables into the logicaldictionary.
protected int readblock ( ) { blocksize = read ( ) ; int n = _num ; if ( blocksize > _num ) { try { int count = _num ; while ( n < blocksize ) { count = in . read ( block , n , blocksize - n ) ; if ( count == - _num ) break ; n += count ; } } catch ( ioexception e ) { } if ( n < blocksize ) { status = status_format_error ; } } return n ; }	reads next variable length block from input .
@ override public void addnewsubscription ( final subscription newsubscription ) { final string clientid = newsubscription . getclientid ( ) ; list < clienttopiccouple > clientsubscriptions = subscriptions . get ( clientid ) ; if ( clientsubscriptions == null ) { clientsubscriptions = new arraylist < > ( ) ; subscriptions . put ( clientid , clientsubscriptions ) ; } clientsubscriptions . add ( newsubscription . asclienttopiccouple ( ) ) ; }	add a new subscription to the session .
public x509certpathimpl ( list < ? extends java . security . cert . certificate > certs ) throws certificateexception { super ( _str ) ; final int size = certs . size ( ) ; certificates = new arraylist < x509certificate > ( size ) ; for ( int i = _num ; i < size ; i ++ ) { final java . security . cert . certificate cert = certs . get ( i ) ; if ( ! ( cert instanceof x509certificate ) ) { throw new certificateexception ( _str + i + _str ) ; } certificates . add ( ( x509certificate ) cert ) ; } }	creates an instance of x.
public process ( final string xmlstring ) throws ioexception , xmlexception { initcontext ( ) ; stringreader in = new stringreader ( xmlstring ) ; readprocess ( in ) ; in . close ( ) ; }	reads an process configuration from an xml string .
public consultopologyfraction ( ) { this . url = default_url ; }	construct a default fraction using the default agent url of http : / / localhost : 8500 / .
protected string buildqualifierregex ( string qualifiervalue ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( _str ) ; sb . append ( qualifiervalue ) ; sb . append ( _str ) ; return sb . tostring ( ) ; }	just used for like and not_like.
public string shortenname ( string name , int desiredlength ) { int originallength = name . length ( ) ; if ( ( desiredlength <= _num ) || ( originallength <= desiredlength ) ) { return name ; } int delta = originallength - desiredlength ; int startcut = desiredlength / _num ; stringbuffer result = new stringbuffer ( ) ; result . append ( name . substring ( _num , startcut ) ) ; if ( ( ( startcut == _num ) || ( name . charat ( startcut - _num ) != _str ) ) && ( ( startcut + delta + _num == originallength ) || ( name . charat ( startcut + delta + _num ) != _str ) ) ) { result . append ( _str ) ; } result . append ( name . substring ( startcut + delta + _num , originallength ) ) ; return result . tostring ( ) ; }	generates a version of the name that has at most the specified length .
public static color blend ( color color1 , color color2 , double weight ) { double w2 = mathutils . limit ( weight , _num , _num ) ; double w1 = _num - w2 ; int r = ( int ) math . round ( w1 * color1 . getred ( ) + w2 * color2 . getred ( ) ) ; int g = ( int ) math . round ( w1 * color1 . getgreen ( ) + w2 * color2 . getgreen ( ) ) ; int b = ( int ) math . round ( w1 * color1 . getblue ( ) + w2 * color2 . getblue ( ) ) ; int a = ( int ) math . round ( w1 * color1 . getalpha ( ) + w2 * color2 . getalpha ( ) ) ; return new color ( r , g , b , a ) ; }	linearly blends two colors with a defined weight .
public long kstkeip ( ) { return long . parselong ( fields [ _num ] ) ; }	the current eip ( instruction pointer ) .
private void decideuilookandfeel ( mainoptions options ) { try { boolean systemplaf = _bool ; systemplaf = options . system_plaf ; string systemplafreq = system . getenv ( _str ) ; if ( systemplafreq != null && systemplafreq . equalsignorecase ( _str ) ) systemplaf = _bool ; if ( systemplaf ) uimanager . setlookandfeel ( uimanager . getsystemlookandfeelclassname ( ) ) ; } catch ( exception exc ) { exc . printstacktrace ( ) ; } }	normally the look and feel should be the standard one , java , allow to set the systemplaf to have the system look and feel.
public static bufferedimage tobufferedimage ( image img , int type ) { if ( img instanceof bufferedimage ) { return ( bufferedimage ) img ; } bufferedimage bimage = new bufferedimage ( img . getwidth ( null ) , img . getheight ( null ) , type ) ; graphics2d bgr = bimage . creategraphics ( ) ; bgr . drawimage ( img , _num , _num , null ) ; bgr . dispose ( ) ; return bimage ; }	converts a given image into a bufferedimage.
private jsonarray readarray ( ) throws jsonexception { jsonarray result = new jsonarray ( ) ; boolean hastrailingseparator = _bool ; while ( _bool ) { switch ( nextcleaninternal ( ) ) { case - _num : throw syntaxerror ( _str ) ; case _str : if ( hastrailingseparator ) { result . put ( null ) ; } return result ; case _str : case _str : result . put ( null ) ; hastrailingseparator = _bool ; continue ; default : pos -- ; } result . put ( nextvalue ( ) ) ; switch ( nextcleaninternal ( ) ) { case _str : return result ; case _str : case _str : hastrailingseparator = _bool ; continue ; default : throw syntaxerror ( _str ) ; } } }	reads a sequence of values and the trailing closing brace ' ] ' of an array.
public list < node > listavailableterminals ( class < ? > type ) { list < node > result = new arraylist < node > ( ) ; for ( node node : availablenodes ) { if ( ( node . getnumberofarguments ( ) == _num ) && type . isassignablefrom ( node . getreturntype ( ) ) ) { result . add ( node ) ; } } return result ; }	returns the list of all available terminal nodes with the given return type .
public void removesensorselectionlistener ( sensorselectionlistener listener ) { listenerlist . remove ( sensorselectionlistener . class , listener ) ; }	remove the specified sensor selection listener .
public void write ( int c ) throws ioexception { if ( _output == null ) throw new ioexception ( _str ) ; _output . append ( ( char ) c ) ; }	writes the 16 low - order bits of the given integer value ; the 16 high - order bits are ignored .
private static void testdexclassloader ( ) { classloader dexclassloader = getdexclassloader ( ) ; class anotherclass ; try { anotherclass = dexclassloader . loadclass ( _str ) ; } catch ( classnotfoundexception cnfe ) { throw new runtimeexception ( _str ) ; } object another ; try { another = anotherclass . newinstance ( ) ; } catch ( illegalaccessexception ie ) { throw new runtimeexception ( _str , ie ) ; } catch ( instantiationexception ie ) { throw new runtimeexception ( _str , ie ) ; } dexclassloader . getresource ( _str ) ; }	create a class loader , explicitly specifying the source dex and the location for the optimized dex .
public void register ( gridcachettlmanager mgr ) { synchronized ( mux ) { if ( cleanupworker == null ) startcleanupworker ( ) ; mgrs . add ( mgr ) ; } }	register ttl manager of cache for periodical check on expired entries .
public static java . sql . time tosqltime ( int hour , int minute , int second ) { java . util . date newdate = todate ( _num , _num , _num , hour , minute , second ) ; if ( newdate != null ) { return new java . sql . time ( newdate . gettime ( ) ) ; } else { return null ; } }	makes a java . sql . time from separate ints for hour , minute , and second .
public void initializekeystore ( ) { try { logger logger = ( com . sun . identity . log . logger ) logger . getlogger ( logname ) ; resetcurrentfilelist ( logname ) ; addtocurrentfilelist ( logname , logname , logname ) ; string logpath = lmanager . getproperty ( logconstants . log_location ) ; if ( ! logpath . endswith ( _str ) ) logpath += _str ; string filename = logname ; string loggerfilename = logpath + prefix + _str + filename ; string verifierfilename = logpath + prefix + _str + filename ; debug . message ( logname + _str + loggerfilename ) ; debug . message ( logname + _str + verifierfilename ) ; helper . initializesecureloghelper ( loggerfilename , logpassword , verifierfilename , logpassword ) ; debug . message ( logname + _str ) ; helper . initializeverifier ( verifierfilename , logpassword , verpassword ) ; debug . message ( logname + _str ) ; } catch ( exception e ) { debug . error ( logname + _str , e ) ; } }	initialize logger key store.
private native byte [ ] imagedatatoplatformimagebytes ( byte [ ] imagedata , int width , int height , long format ) ;	returns a byte array which contains data special for the given format and for the given image data .
public static string cleanfolderstackingmarkers ( string filename ) { if ( ! stringutils . isempty ( filename ) ) { matcher m = folderstackingpattern . matcher ( filename ) ; if ( m . matches ( ) ) { return m . group ( _num ) + m . group ( _num ) ; } } return filename ; }	clean stacking markers . < br > same logic as detection , but just returning string w / o.
public void discard ( serviceregistrar reg ) { synchronized ( registrars ) { if ( terminated ) { throw new illegalstateexception ( _str ) ; } if ( reg == null ) return ; senddiscarded ( reg , null ) ; } }	discard a registrar from the set of registrars already discovered.
public boolean isfinalstate ( int state ) { return ( state < _num ) ? _bool : ffinalstateflags [ state ] ; }	check whether the given state is one of the final states.
public static string generatescalemarkers ( int proteinlength , int maxnumscalemarkers ) { if ( maxnumscalemarkers < _num ) { maxnumscalemarkers = _num ; } int scale = calcscale ( proteinlength , maxnumscalemarkers ) ; stringbuilder sb = new stringbuilder ( _str ) ; int index = _num ; int numremaining = proteinlength ; while ( index <= proteinlength ) { index += scale ; numremaining -= scale ; sb . append ( _str ) ; if ( ( numremaining > _num ) && ( numremaining < scale ) ) { if ( numremaining < ( scale / _num ) ) { sb . append ( proteinlength ) ; break ; } } if ( index >= proteinlength ) { sb . append ( proteinlength ) ; } else { sb . append ( index ) ; } } return sb . tostring ( ) ; }	generate a string of comma - separated numbers that will be used to mark the scale of the match diagram .
public void writefigtreeblock ( map < string , object > settings ) throws ioexception { writer . println ( _str ) ; for ( string key : settings . keyset ( ) ) { object value = settings . get ( key ) ; writer . println ( _str + key + _str + createstring ( value ) + _str ) ; } writer . println ( _str ) ; }	writes a ' figtree ' block .
public int hashcode ( ) { return font . hashcode ( ) ^ glyphs . length ; }	as a concrete subclass of object that implements equality , this must implement hashcode .
public boolean equals ( object obj ) { if ( obj == this ) { return _bool ; } if ( obj instanceof map == _bool ) { return _bool ; } map map = ( map ) obj ; if ( map . size ( ) != size ( ) ) { return _bool ; } mapiterator it = mapiterator ( ) ; try { while ( it . hasnext ( ) ) { object key = it . next ( ) ; object value = it . getvalue ( ) ; if ( value == null ) { if ( map . get ( key ) != null || map . containskey ( key ) == _bool ) { return _bool ; } } else { if ( value . equals ( map . get ( key ) ) == _bool ) { return _bool ; } } } } catch ( classcastexception ignored ) { return _bool ; } catch ( nullpointerexception ignored ) { return _bool ; } return _bool ; }	compares this map with another .
@ override public void doctypedecl ( string rootelement , string publicid , string systemid , augmentations augs ) throws xniexception { findtd = _bool ; try { if ( flexicalhandler != null ) { flexicalhandler . startdtd ( rootelement , publicid , systemid ) ; } } catch ( saxexception e ) { throw new xniexception ( e ) ; } if ( fdeclhandler != null ) { fdeclaredattrs = new symbolhash ( ) ; } }	notifies of the presence of the doctype line in the document .
public void writeexif ( byte [ ] jpeg , string exifoutfilename ) throws filenotfoundexception , ioexception { if ( jpeg == null || exifoutfilename == null ) { throw new illegalargumentexception ( null_argument_string ) ; } outputstream s = null ; try { s = getexifwriterstream ( exifoutfilename ) ; s . write ( jpeg , _num , jpeg . length ) ; s . flush ( ) ; } catch ( ioexception e ) { closesilently ( s ) ; throw e ; } s . close ( ) ; }	writes the tags from this exifinterface object into a jpeg image , removing prior exif tags .
public void cleanstart ( ) { connection conn = getconnection ( _bool , _bool ) ; if ( conn == null ) throw new illegalstateexception ( _str ) ; dropdatabase ( conn ) ; createuser ( conn ) ; createdatabase ( conn ) ; try { if ( conn != null ) conn . close ( ) ; } catch ( sqlexception e2 ) { log . log ( level . severe , _str , e2 ) ; } conn = null ; }	clean start - drop & re - create db.
static templatemodelexception newmethodarginvalidvalueexception ( string methodname , int argidx , object ... details ) { return new _templatemodelexception ( methodname , _str , integer . valueof ( argidx + _num ) , _str , details ) ; }	the type of the argument was good , but it ' s value wasn ' t .
public static byte [ ] compressforzlib ( string stringtocompress ) { byte [ ] returnvalues = null ; try { returnvalues = compressforzlib ( stringtocompress . getbytes ( _str ) ) ; } catch ( unsupportedencodingexception uee ) { uee . printstacktrace ( ) ; } return returnvalues ; }	zlib compress 2 byte.
private void loadmap ( string extension , string mimetype ) { if ( ! mimetypetoextensionmap . containskey ( mimetype ) ) { mimetypetoextensionmap . put ( mimetype , extension ) ; } extensiontomimetypemap . put ( extension , mimetype ) ; if ( isimagetype ( mimetype ) ) { imagemimetypeset . add ( mimetype ) ; } }	load an entry into the map .
public void startdtd ( string name , string publicid , string systemid ) throws org . xml . sax . saxexception { }	report the start of dtd declarations , if any.
private string converttimestamp ( ) { string result = timestampformat . replaceall ( valid_dateformat_char_pattern + _str , _str ) ; result = result . replaceall ( pattern . quote ( _str ) , _str ) ; return result ; }	helper method that will convert timestamp format to a pattern.
public static string encode ( byte [ ] bytes ) { int len = bytes . length ; final stringbuffer encoded = new stringbuffer ( ( len + _num ) / _num * _num ) ; int i = _num ; int j = len ; while ( j >= _num ) { encoded . append ( to64 ( ( ( ( bytes [ i ] & _num ) << _num ) | ( int ) ( ( bytes [ i + _num ] & _num ) << _num ) | ( int ) ( bytes [ i + _num ] & _num ) ) , _num ) ) ; i += _num ; j -= _num ; } if ( j == _num ) { encoded . append ( to64 ( ( ( bytes [ i ] & _num ) << _num ) | ( ( bytes [ i + _num ] & _num ) ) , _num ) ) ; } if ( j == _num ) { encoded . append ( to64 ( ( ( bytes [ i ] & _num ) ) , _num ) ) ; } return encoded . tostring ( ) ; }	encodes an array of byte into a string of printable ascii characters using a base - 64 encoding .
final public void print ( double v ) { writer out = this . out ; if ( out == null ) return ; try { string s = string . valueof ( v ) ; out . write ( s , _num , s . length ( ) ) ; } catch ( ioexception e ) { log . log ( level . fine , e . tostring ( ) , e ) ; } }	prints a double followed by a newline .
public string tostring ( ) { stringbuffer result = new stringbuffer ( ipaddress . tostring ( ) ) ; result . append ( _str ) ; result . append ( extendednetworkprefix ) ; return result . tostring ( ) ; }	convert the ip range into a string representation .
private static boolean containschroot ( string zkhost ) { return zkhost . contains ( _str ) ; }	validates if zkhost contains a chroot.
public static void ondatabase ( mongoclient client , string dbname , consumer < mongodatabase > dboperation ) { if ( contains ( client . listdatabasenames ( ) , dbname ) ) { dboperation . accept ( client . getdatabase ( dbname ) ) ; } }	perform the given operation on the database with the given name , only if that database exists .
protected int createhashcode ( ) { int result = uri . hashcode ( ) ^ prefix . hashcode ( ) ; if ( result == _num ) { result = _num ; } return result ; }	factory method to create the hashcode allowing derived classes to change the behaviour.
public static placeholderfragment newinstance ( int sectionnumber ) { placeholderfragment fragment = new placeholderfragment ( ) ; bundle args = new bundle ( ) ; args . putint ( arg_section_number , sectionnumber ) ; fragment . setarguments ( args ) ; return fragment ; }	returns a new instance of this fragment for the given section number .
public string importtrl ( string directory , int ad_client_id , string ad_language , string trl_table ) { string filename = directory + file . separator + trl_table + _str + ad_language + _str ; log . info ( filename ) ; file in = new file ( filename ) ; if ( ! in . exists ( ) ) { string msg = _str + filename ; log . log ( level . severe , msg ) ; return msg ; } try { translationhandler handler = new translationhandler ( ad_client_id ) ; saxparserfactory factory = saxparserfactory . newinstance ( ) ; saxparser parser = factory . newsaxparser ( ) ; parser . parse ( in , handler ) ; log . info ( _str + handler . getupdatecount ( ) ) ; return msg . getmsg ( m_ctx , _str ) + _str + handler . getupdatecount ( ) ; } catch ( exception e ) { log . log ( level . severe , _str , e ) ; return e . tostring ( ) ; } }	import translation . uses translationhandler to update translation.
public resultfilereader ( problem problem , file file ) throws ioexception { super ( ) ; this . problem = problem ; reader = new bufferedreader ( new filereader ( file ) ) ; line = reader . readline ( ) ; }	constructs a result file reader for reading the approximation sets from the specified result file .
@ override public void onfailure ( imqtttoken asyncactiontoken , throwable exception ) { exception . printstacktrace ( ) ; log . e ( _str , _str + exception . getmessage ( ) ) ; ondisconnect ( _bool ) ; }	called when there was an error connecting.
@ override public boolean exclude ( string identifier ) { return blacklist . contains ( identifier ) ; }	checks if the given identifier should be excluded .
public static boolean checkcommunicationerror ( exception exc ) { throwable rootcause = solrexception . getrootcause ( exc ) ; boolean wascommerror = ( rootcause instanceof connectexception || rootcause instanceof connecttimeoutexception || rootcause instanceof nohttpresponseexception || rootcause instanceof socketexception ) ; return wascommerror ; }	determine if a request to solr failed due to a communication error , which is generally retry - able .
public boolean isreliable ( ) { return _bool ; }	returns " true " as this is a reliable transport .
private void push ( final int type ) { if ( outputstack == null ) { outputstack = new int [ _num ] ; } int n = outputstack . length ; if ( outputstacktop >= n ) { int [ ] t = new int [ math . max ( outputstacktop + _num , _num * n ) ] ; system . arraycopy ( outputstack , _num , t , _num , n ) ; outputstack = t ; } outputstack [ outputstacktop ++ ] = type ; int top = owner . inputstacktop + outputstacktop ; if ( top > owner . outputstackmax ) { owner . outputstackmax = top ; } }	pushes a new type onto the output frame stack .
static private string short_max_plus ( ) { long tempvalue = short . max_value + _num ; return string . valueof ( tempvalue ) ; }	get the max value plus one for a short.
public void firepropertychange ( string name , object oldvalue , object newvalue ) { beancontextchildsupport . firepropertychange ( name , oldvalue , newvalue ) ; }	method for beancontextchild interface.
public static string encode ( string value ) { value = value . replace ( _str , _str ) ; value = value . replace ( _str , _str ) ; value = value . replace ( _str , _str ) ; value = value . replace ( _str , _str ) ; value = value . replace ( _str , _str ) ; value = value . replace ( _str , _str ) ; return value ; }	html encodes value to avoid xss attacks . & = & amp ; < = & lt ; > = & gt ; " = & quot ; ' = & # x27 ; / = & # x2f ;.
public void createdatabaseentitiesforstoragepolicytesting ( ) { createdatabaseentitiesforstoragepolicytesting ( abstractservicetest . storage_policy_namespace_cd , arrays . aslist ( abstractservicetest . storage_policy_rule_type ) , abstractservicetest . bdef_namespace , abstractservicetest . bdef_name , arrays . aslist ( abstractservicetest . format_file_type_code ) , arrays . aslist ( abstractservicetest . storage_name ) , arrays . aslist ( abstractservicetest . storage_name_2 ) ) ; }	create and persist database entities required for storage policy service testing .
private pdfpage createpage ( int pagenum , pdfobject pageobj ) throws ioexception { int rotation = _num ; rectf mediabox = null ; rectf cropbox = null ; pdfobject mediaboxobj = getinheritedvalue ( pageobj , _str ) ; if ( mediaboxobj != null ) { mediabox = parserect ( mediaboxobj ) ; } pdfobject cropboxobj = getinheritedvalue ( pageobj , _str ) ; if ( cropboxobj != null ) { cropbox = parserect ( cropboxobj ) ; } pdfobject rotateobj = getinheritedvalue ( pageobj , _str ) ; if ( rotateobj != null ) { rotation = rotateobj . getintvalue ( ) ; } rectf bbox = ( ( cropbox == null ) ? mediabox : cropbox ) ; return new pdfpage ( pagenum , bbox , rotation , cache ) ; }	create a pdf page object by finding the relevant inherited properties.
static map addelementtomap ( string key , set values , map tomap ) { if ( ( key != null ) && ( tomap != null ) ) { tomap . put ( key , values ) ; } return tomap ; }	adds a key / value pair to a map.
public void savebootprop ( ) throws ioexception { if ( ! bootprop . equals ( bootproporg ) ) { final string propfile = jarfolder + _str ; final outputstream os = new fileoutputstream ( propfile ) ; try { bootprop . store ( os , _str ) ; } finally { os . close ( ) ; } } }	saves modified boot properties to disk .
private int append ( filesystem fs , configuration conf , path src , printwriter writer , int currentrecordnumber ) throws ioexception { bufferedreader reader = new bufferedreader ( new inputstreamreader ( fs . open ( src ) ) ) ; try { string line = reader . readline ( ) ; while ( line != null ) { if ( line . startswith ( _str ) ) { line = _str + currentrecordnumber ++ ; } writer . println ( line ) ; line = reader . readline ( ) ; } return currentrecordnumber ; } finally { reader . close ( ) ; } }	appends two files and updates the recno counter.
public packetoutputstream writetimestamplength ( final calendar calendar , timestamp ts , boolean fractionalseconds ) { assurebuffercapacity ( fractionalseconds ? _num : _num ) ; buffer . put ( ( byte ) ( fractionalseconds ? _num : _num ) ) ; buffer . putshort ( ( short ) calendar . get ( calendar . year ) ) ; buffer . put ( ( byte ) ( ( calendar . get ( calendar . month ) + _num ) & _num ) ) ; buffer . put ( ( byte ) ( calendar . get ( calendar . day_of_month ) & _num ) ) ; buffer . put ( ( byte ) calendar . get ( calendar . hour_of_day ) ) ; buffer . put ( ( byte ) calendar . get ( calendar . minute ) ) ; buffer . put ( ( byte ) calendar . get ( calendar . second ) ) ; if ( fractionalseconds ) { buffer . putint ( ts . getnanos ( ) / _num ) ; } return this ; }	write timestamp in binary format .
public int difference ( string s1 , string s2 ) throws encoderexception { return soundexutils . difference ( this , s1 , s2 ) ; }	encodes the strings and returns the number of characters in the two encoded strings that are the same.
public static string morpha ( string text , boolean tags ) { if ( text . isempty ( ) ) { return _str ; } string [ ] textparts = whitespace . split ( text ) ; stringbuilder result = new stringbuilder ( ) ; try { for ( string textpart : textparts ) { morpha morpha = new morpha ( new stringreader ( textpart ) , tags ) ; if ( result . length ( ) != _num ) { result . append ( _str ) ; } result . append ( morpha . next ( ) ) ; } } catch ( error e ) { return text ; } catch ( java . io . ioexception e ) { return text ; } return result . tostring ( ) ; }	run the morpha algorithm on the specified string .
public static void deletefile ( file file ) throws adeusageexception { if ( ! file . delete ( ) ) { throw new adeusageexception ( failed_deleting_file + file . getpath ( ) ) ; } }	delete a file from file system .
public shape createcheckmark ( final int x , final int y , final int w , final int h ) { double xf = w / _num ; double hf = h / _num ; path . reset ( ) ; path . moveto ( x , y + _num * hf ) ; path . lineto ( x + _num * xf , y + _num * hf ) ; path . lineto ( x + _num * xf , y + _num * hf ) ; path . lineto ( x + _num * xf , y ) ; path . lineto ( x + _num * xf , y ) ; path . lineto ( x + _num * xf , y + _num * hf ) ; path . closepath ( ) ; return path ; }	return a path for a check mark .
@ override public synchronized void initialize ( ) { if ( ! mrootdirectory . exists ( ) ) { if ( ! mrootdirectory . mkdirs ( ) ) { volleylog . e ( _str , mrootdirectory . getabsolutepath ( ) ) ; } return ; } file [ ] files = mrootdirectory . listfiles ( ) ; if ( files == null ) { return ; } for ( file file : files ) { fileinputstream fis = null ; try { fis = new fileinputstream ( file ) ; cacheheader entry = cacheheader . readheader ( fis ) ; entry . size = file . length ( ) ; putentry ( entry . key , entry ) ; } catch ( ioexception e ) { if ( file != null ) { file . delete ( ) ; } } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( ioexception ignored ) { } } } }	initializes the diskbasedcache by scanning for all files currently in the specified root directory.
public tcpchannelclient ( executorservice executor , tcpchannelevents eventlistener , string ip , int port ) { this . executor = executor ; executorthreadcheck = new threadutils . threadchecker ( ) ; executorthreadcheck . detachthread ( ) ; this . eventlistener = eventlistener ; inetaddress address ; try { address = inetaddress . getbyname ( ip ) ; } catch ( unknownhostexception e ) { reporterror ( _str ) ; return ; } if ( address . isanylocaladdress ( ) ) { socket = new tcpsocketserver ( address , port ) ; } else { socket = new tcpsocketclient ( address , port ) ; } socket . start ( ) ; }	initializes the tcpchannelclient . if ip is a local ip address , starts a listening server on that ip . if not , instead connects to the ip .
protected void cutselectedbean ( ) { if ( debug . debugging ( _str ) ) debug . output ( _str ) ; if ( selectedbean == null || selectedbeanlocation == null ) { if ( debug . debugging ( _str ) ) debug . output ( _str + selectedbean ) ; if ( debug . debugging ( _str ) ) debug . output ( _str + selectedbeanlocation ) ; clearselection ( ) ; return ; } try { serbean = new bytearrayoutputstream ( ) ; objectoutputstream oos = new objectoutputstream ( serbean ) ; oos . writeobject ( selectedbean ) ; } catch ( exception e ) { e . printstacktrace ( ) ; clearselection ( ) ; if ( debug . debugging ( _str ) ) debug . output ( _str ) ; return ; } cutbean = selectedbean ; selectedbeanbox . showcut ( selectedbean ) ; if ( debug . debugging ( _str ) ) debug . output ( _str ) ; }	this method is called when the user chooses to cut a bean by some means such by by pressing ctrl - x.
public removermanager track ( remover remover ) { if ( handlers == null ) { handlers = new arraylist < > ( ) ; } handlers . add ( remover ) ; return this ; }	tracks a new handler so that it can be removed in bulk .
public void actionperformed ( java . awt . event . actionevent e ) { object source = e . getsource ( ) ; if ( ! ( source instanceof jmenuitem ) ) return ; jmenuitem mi = ( jmenuitem ) source ; string name = mi . gettext ( ) ; omgraphichandlerlayer targetlayer = ( omgraphichandlerlayer ) layers . get ( name ) ; if ( targetlayer == null ) { debug . message ( _str , _str + _str + name ) ; return ; } targetlayer . doaction ( ( omgraphic ) transferdata , new omaction ( omaction . update_graphic_mask ) ) ; }	invoked when an action from the popup menu occurs .
private void addentry ( ) { model . addnewentry ( ) ; removebutton . setenabled ( _bool ) ; }	adds a new colour map entry .
private void ensuresize ( ) { if ( children == empty_children ) { children = new fpnode [ _num ] ; return ; } int newsize = children . length == _num ? initial_size : ( children . length << _num ) ; children = arrays . copyof ( children , newsize ) ; }	ensure we have enough storage .
public uuid ( long mostsigbits , long leastsigbits ) { this . mostsigbits = mostsigbits ; this . leastsigbits = leastsigbits ; init ( ) ; }	< p > constructs an instance with the specified bits .
public static prettyprint indentwithspaces ( int number ) { if ( number < _num ) { throw new illegalargumentexception ( _str ) ; } char [ ] chars = new char [ number ] ; arrays . fill ( chars , _str ) ; return new prettyprint ( chars ) ; }	print every value on a separate line.
private static void renderhandler ( facescontext context , uicomponent component , collection < clientbehaviorcontext . parameter > params , string handlername , object handlervalue , string behavioreventname , string submittarget , boolean needssubmit , boolean includeexec ) throws ioexception { responsewriter writer = context . getresponsewriter ( ) ; string userhandler = getnonemptyuserhandler ( handlervalue ) ; list < clientbehavior > behaviors = getclientbehaviors ( component , behavioreventname ) ; if ( ( null != behaviors ) && ( behaviors . size ( ) > _num ) && util . componentisdisabled ( component ) ) { behaviors = null ; } if ( params == null ) { params = collections . emptylist ( ) ; } string handler = null ; switch ( gethandlertype ( behaviors , params , userhandler , needssubmit , includeexec ) ) { case user_handler_only : handler = userhandler ; break ; case single_behavior_only : handler = getsinglebehaviorhandler ( context , component , behaviors . get ( _num ) , params , behavioreventname , submittarget , needssubmit ) ; break ; case submit_only : handler = getsubmithandler ( context , component , params , submittarget , _bool ) ; break ; case chain : handler = getchainedhandler ( context , component , behaviors , params , behavioreventname , userhandler , submittarget , needssubmit ) ; break ; default : assert ( _bool ) ; } writer . writeattribute ( handlername , handler , null ) ; }	renders a handler script , which may require chaining together the user - specified event handler , any scripts required by attached behaviors , and also possibly the mojarra.
public string constructtsdbmetricname ( ) { stringbuilder sb = new stringbuilder ( getscope ( ) ) ; if ( _namespace != null && ! _namespace . isempty ( ) ) { sb . append ( getnamespace ( ) ) ; } return sb . tostring ( ) ; }	constructs a native tsdb metric name for this metric .
@ override protected void registernewselector ( ) throws ioexception { synchronized ( selector ) { set < selectionkey > keys = selector . keys ( ) ; selector newselector = null ; if ( selectorprovider == null ) { newselector = selector . open ( ) ; } else { newselector = selectorprovider . openselector ( ) ; } for ( selectionkey key : keys ) { selectablechannel ch = key . channel ( ) ; niosession session = ( niosession ) key . attachment ( ) ; selectionkey newkey = ch . register ( newselector , key . interestops ( ) , session ) ; session . setselectionkey ( newkey ) ; } selector . close ( ) ; selector = newselector ; } }	in the case we are using the java select ( ) method , this method is used to trash the buggy selector and create a new one , registering all the sockets on it .
public void testcase4 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = _num ; int bsign = _num ; byte rbytes [ ] = { _num , _num , _num , - _num , _num , _num , _num , _num , - _num , _num , _num , _num , - _num , _num , - _num , - _num , - _num , _num , _num , - _num , - _num , - _num , - _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . multiply ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	multiply two positive numbers of different length.
protected synchronized void received ( int responsecode , string stream , string json ) { followerinfo result = parsefollowers ( stream , json ) ; if ( result != null ) { noerror ( stream ) ; cached . put ( stream , result ) ; if ( type == follower . type . follower ) { listener . receivedfollowers ( result ) ; if ( hasnewfollowers ( result . followers ) ) { listener . newfollowers ( result ) ; } } else if ( type == follower . type . subscriber ) { listener . receivedsubscribers ( result ) ; } requested . add ( stream ) ; } else { string errormessage = _str ; if ( responsecode == _num ) { errormessage = _str ; error ( stream , _num ) ; } else if ( responsecode == _num ) { errormessage = _str ; error ( stream , _num ) ; } else if ( responsecode == _num || responsecode == _num ) { errormessage = _str ; error ( stream , _num ) ; } else if ( responsecode == _num ) { errormessage = _str ; error ( stream , _num ) ; } else { errormessage = _str ; error ( stream , _num ) ; } followerinfo errorresult = new followerinfo ( type , stream , errormessage ) ; cached . put ( stream , errorresult ) ; if ( type == follower . type . follower ) { listener . receivedfollowers ( errorresult ) ; } else if ( type == follower . type . subscriber ) { listener . receivedsubscribers ( errorresult ) ; } } }	received data from the api , so parse it or handle a possible error , then give it to the listener .
public static < t > list < t > select ( connection connection , string rawsqlquery , rowprocessor < t > rowprocessor , object ... parameters ) throws ioexception , sqlexception { preparedstatement stmt = null ; resultset rs = null ; try { stmt = connection . preparestatement ( rawsqlquery ) ; for ( int index = _num ; index < parameters . length ; index ++ ) { jdbcutils . bindparameter ( stmt , index + _num , parameters [ index ] ) ; } rs = stmt . executequery ( ) ; list < t > result = lists . newlinkedlist ( ) ; while ( rs . next ( ) ) { result . add ( rowprocessor . process ( rs ) ) ; } return result ; } finally { jdbcutils . closeresultset ( rs ) ; jdbcutils . closestatement ( stmt ) ; } }	retrieve all the rows satisfying the given sql query .
public static long nowinnanos ( ) { return system . nanotime ( ) ; }	current time from some arbitrary time base in the past , counting in nanoseconds , and not affected by settimeofday or similar system clock changes.
public void test_clone ( ) { format fm = new mockformat ( ) ; format fmc = ( format ) fm . clone ( ) ; assertequals ( fm . getclass ( ) , fmc . getclass ( ) ) ; }	java . text . format # clone ( ) test of method java . text . format # clone ( ) . compare of internal variables of cloned objects .
public future < syncreply > sendrequest ( int xid , syncmessage request ) throws remotestoreexception { ensureconnected ( ) ; remotesyncfuture future = new remotesyncfuture ( xid , connectiongeneration ) ; futuremap . put ( integer . valueof ( xid ) , future ) ; if ( futuremap . size ( ) > max_pending_requests ) { synchronized ( futurenotify ) { while ( futuremap . size ( ) > max_pending_requests ) { try { futurenotify . wait ( ) ; } catch ( interruptedexception e ) { throw new remotestoreexception ( _str , e ) ; } } } } channel . writeandflush ( request ) ; return future ; }	send a request to the server and generate a future for the eventual reply . note that this call can block if there is no active connection while a new connection is re - established or if the maximum number of requests is already pending.
public static boolean isempty ( string str ) { return ( null == str || _num == str . length ( ) ) ; }	is null or its length is 0.
public void enabledependency ( capability c ) { if ( donotcheckcapabilities ( ) ) { return ; } if ( c == capability . nominal_attributes ) { enabledependency ( capability . binary_attributes ) ; } else if ( c == capability . binary_attributes ) { enabledependency ( capability . unary_attributes ) ; } else if ( c == capability . unary_attributes ) { enabledependency ( capability . empty_nominal_attributes ) ; } else if ( c == capability . nominal_class ) { enabledependency ( capability . binary_class ) ; } m_dependencies . add ( c ) ; }	enables the dependency flag for the given capability enabling nominal_attributes also enables binary_attributes , unary_attributes and empty_nominal_attributes.
public ivariable [ ] extractrobotdebugvariables ( final int stacktraceid , final map < string , object > newvariables ) { final robotdebugvariablescontext currentvariablescontext = findcurrentvariablescontext ( stacktraceid ) ; map < string , ivariable > previousvariablesmap = initpreviousvariablesstate ( currentvariablescontext ) ; final map < string , ivariable > nonglobalvariablesmap = new linkedhashmap < > ( ) ; if ( previousvariablesmap == null ) { initnewnonglobalvariables ( newvariables , nonglobalvariablesmap ) ; } else { initvariablescomparingwithpreviousstate ( newvariables , previousvariablesmap , nonglobalvariablesmap ) ; } final linkedlist < ivariable > currentvariableslist = createcurrentvariableslist ( nonglobalvariablesmap ) ; savecurrentvariablesstate ( stacktraceid , currentvariablescontext , nonglobalvariablesmap ) ; return currentvariableslist . toarray ( new ivariable [ currentvariableslist . size ( ) ] ) ; }	extract and sort variables for given stacktrace level.
public resourcespoet addinteger ( string name , string value ) { element bool = document . createelement ( _str ) ; bool . setattribute ( _str , name ) ; bool . appendchild ( document . createtextnode ( string . valueof ( value ) ) ) ; resourceelement . appendchild ( bool ) ; return this ; }	add an integer to the config.
public static string mapfullwidthlettertohalfwidth ( string text ) { }	convert full - width letters in chinese fonts to normal half - width letters in ansi charset.
private static < t > void assertcollectionequalsnoorder ( collection < t > expected , collection < t > actual ) { string msg = string . format ( _str , expected . tostring ( ) , actual . tostring ( ) ) ; assertequals ( msg , expected . size ( ) , actual . size ( ) ) ; for ( t e : expected ) { if ( ! actual . contains ( e ) ) { msg = string . format ( _str + _str , e , expected , actual ) ; fail ( msg ) ; } } }	test whether two collections contains the same elements , regardless of the order in which the elements appear in the collections.
private static boolean hasresponsebody ( int requestmethod , int responsecode ) { return requestmethod != request . method . head && ! ( httpstatus . sc_continue <= responsecode && responsecode < httpstatus . sc_ok ) && responsecode != httpstatus . sc_no_content && responsecode != httpstatus . sc_not_modified ; }	checks if a response message contains a body .
public int availableinprocess ( ) { return math . max ( _num , maxinprocess - pending . size ( ) ) ; }	a connection can only have so many things in process happening on it at once , where " in process " refers to the maximum number of in - process requests less the number of pending responses .
public void add ( double x ) { cell [ ] as ; long b , v ; int m ; cell a ; if ( ( as = cells ) != null || ! casbase ( b = base , double . doubletorawlongbits ( double . longbitstodouble ( b ) + x ) ) ) { boolean uncontended = _bool ; if ( as == null || ( m = as . length - _num ) < _num || ( a = as [ getprobe ( ) & m ] ) == null || ! ( uncontended = a . cas ( v = a . value , double . doubletorawlongbits ( double . longbitstodouble ( v ) + x ) ) ) ) doubleaccumulate ( x , null , uncontended ) ; } }	adds the given value .
public boolean shouldexecuteaction ( ) { if ( delay <= _num ) { return _bool ; } long timepassed = system . currenttimemillis ( ) - lastactionexecuted ; if ( timepassed > delay * _num ) { lastactionexecuted = system . currenttimemillis ( ) ; return _bool ; } return _bool ; }	checks whether an action should currently be executed , based on the required delay.
public static int movebyword ( string text , int column , boolean forward , boolean returncursoratend ) { int curcolumn = column ; int length = text . length ( ) ; int direction = forward ? _num : - _num ; boolean farwordend = ( ( direction == _num && returncursoratend ) || ( direction == - _num && ! returncursoratend ) ) ; boolean foundearlymatch = _bool ; if ( ! unicodeutils . iswhitespace ( text . charat ( curcolumn ) ) ) { curcolumn = skipnonwhitespacesimilar ( text , curcolumn , forward ) ; if ( farwordend && curcolumn - direction != column ) { curcolumn -= direction ; foundearlymatch = _bool ; } } if ( ! foundearlymatch && curcolumn >= _num && curcolumn < length ) { curcolumn = skipwhitespace ( text , curcolumn , forward ) ; if ( farwordend && curcolumn >= _num && curcolumn < length ) { curcolumn = skipnonwhitespacesimilar ( text , curcolumn , forward ) - direction ; } } if ( curcolumn < _num || curcolumn >= length ) { return - _num ; } return curcolumn ; }	jumps to the previous or next best match given the parameters below.
protected void handleordefermessage ( distributionmessage msg ) { synchronized ( startuplock ) { if ( beingsick || playingdead ) { if ( msg . containsregioncontentchange ( ) || msg instanceof partitionmessagewithdirectreply ) { startupmessages . add ( new startupevent ( msg ) ) ; return ; } } if ( ! processingevents ) { startupmessages . add ( new startupevent ( msg ) ) ; return ; } } dispatchmessage ( msg ) ; }	dispatch the distribution message , or place it on the startup queue .
public boolean zoneexportremovevolumes ( list < networkzoningparam > zoningparams , collection < uri > volumeuris , string stepid ) { networkzoningparam zoningparam = zoningparams . get ( _num ) ; _log . info ( string . format ( _str , zoningparam . getexportgroupdisplay ( ) , volumeuris . tostring ( ) ) ) ; return dozoneexportmasksdelete ( zoningparams , volumeuris , stepid ) ; }	removes the indicated volumes from the zones given by the zoning parameters.
private void shutdown ( ) { if ( nbestlistwriter != null ) { logger . info ( _str ) ; nbestlistwriter . close ( ) ; } if ( alignmentwriter != null ) { logger . info ( _str ) ; alignmentwriter . close ( ) ; } }	free resources and cleanup .
@ override public void painticon ( component c , graphics g , int x , int y ) { painter painter = ( painter ) uimanager . get ( prefix + _str + key ) ; if ( painter != null ) { jcomponent jc = ( c instanceof jcomponent ) ? ( jcomponent ) c : null ; graphics2d gfx = ( graphics2d ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }	implements the standard icon interface ' s painticon method as the standard synth stub passes null for the context and this will cause us to not paint any thing , so we override here so that we can paint the enabled state if no synth context is available.
protected void zoomimagetoposition ( float scale , float centerx , float centery , long durationms ) { if ( scale > getmaxscale ( ) ) { scale = getmaxscale ( ) ; } final float oldscale = getcurrentscale ( ) ; final float deltascale = scale - oldscale ; post ( mzoomimagetopositionrunnable = new zoomimagetoposition ( cropimageview . this , durationms , oldscale , deltascale , centerx , centery ) ) ; }	this method changes image scale ( animating zoom for given duration ) , related to given center ( x , y ) .
public list < map < string , string > > list ( database conn ) throws sqlexception { resultset rs = null ; statement statement = conn . createstatement ( ) ; list < map < string , string > > shardtochannels = new arraylist < map < string , string > > ( ) ; try { rs = statement . executequery ( select ) ; while ( rs . next ( ) ) { map < string , string > shard = new hashmap < string , string > ( ) ; shard . put ( shardchanneltable . shard_id_col , rs . getstring ( shardchanneltable . shard_id_col ) ) ; shard . put ( shardchanneltable . channel_col , rs . getstring ( shardchanneltable . channel_col ) ) ; shardtochannels . add ( shard ) ; } } finally { close ( rs ) ; close ( statement ) ; } return shardtochannels ; }	return a list of currently known shard / channel assignments .
public boolean ishidden ( file f ) { string name = f . getname ( ) ; if ( ( name != null ) && ! name . equals ( _str ) && ( name . charat ( _num ) == _str ) ) { return boolean . true ; } else { return boolean . false ; } }	whether the file is hidden or not.
private boolean scrollviewcanscrollvertically ( scrollview scrollview , int direction ) { final int offset = math . max ( _num , scrollview . getscrolly ( ) ) ; final int range = computeverticalscrollrange ( scrollview ) - scrollview . getheight ( ) ; if ( range == _num ) return _bool ; if ( direction < _num ) { return offset > _num ; } else { return offset < range - _num ; } }	copy from scrollview ( api level > = 14 ).
public jarinfo loadjar ( ) throws ioexception { zipinputstream zis = null ; manifest mf = null ; boolean empty = _bool ; try { zis = new zipinputstream ( jarstream ) ; zipentry ent = null ; while ( ( ent = zis . getnextentry ( ) ) != null ) { empty = _bool ; string name = ent . getname ( ) ; if ( manifest . ismanifestname ( name ) ) { bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; byte buffer [ ] = new byte [ _num ] ; for ( ; ; ) { int len = zis . read ( buffer ) ; if ( len < _num ) { break ; } baos . write ( buffer , _num , len ) ; } byte [ ] buf = baos . tobytearray ( ) ; mf = new manifest ( buf ) ; } } } catch ( ioexception ex ) { throw ex ; } catch ( throwable th ) { th . printstacktrace ( ) ; throw new ioexception ( _str + th ) ; } finally { if ( zis != null ) { try { zis . close ( ) ; } catch ( exception ex ) { } } } if ( empty ) { throw new ioexception ( _str ) ; } jarinfo ji = createjarinfo ( mf ) ; return ji ; }	load the classes , resources , etc .
public void invalidatetitlesortable ( ) { for ( movie movie : new arraylist < > ( movielist ) ) { movie . cleartitlesortable ( ) ; } }	invalidate the title sortable upon changes to the sortable prefixes.
public void addrow ( assignment head , double prob ) { if ( prob < _num || prob > _num ) { return ; } headvars . addall ( head . getvariables ( ) ) ; table . put ( head , prob ) ; }	adds a new row to the probability table , assuming no conditional assignment.
public byte [ ] createjarfromfilecontent ( final string filename , final string content ) throws ioexception { bytearrayoutputstream bytearrayoutputstream = new bytearrayoutputstream ( ) ; jaroutputstream jaroutputstream = new jaroutputstream ( bytearrayoutputstream ) ; jarentry entry = new jarentry ( filename ) ; entry . settime ( system . currenttimemillis ( ) ) ; jaroutputstream . putnextentry ( entry ) ; jaroutputstream . write ( content . getbytes ( ) ) ; jaroutputstream . closeentry ( ) ; jaroutputstream . close ( ) ; return bytearrayoutputstream . tobytearray ( ) ; }	create a jar using the given file contents and with the given file name .
private boolean goto ( long day , boolean animate , boolean setselected , boolean forcescroll ) { if ( setselected ) { mselectedday . settimeinmillis ( day ) ; } mtempday . settimeinmillis ( day ) ; final int position = getpositionfromday ( day ) ; view child ; int i = _num ; int top = _num ; do { child = getchildat ( i ++ ) ; if ( child == null ) { break ; } top = child . gettop ( ) ; } while ( top < _num ) ; int selectedposition ; if ( child != null ) { selectedposition = getpositionforview ( child ) ; } else { selectedposition = _num ; } if ( setselected ) { madapter . setselectedday ( mselectedday ) ; } if ( position != selectedposition || forcescroll ) { setmonthdisplayed ( mtempday ) ; mpreviousscrollstate = onscrolllistener . scroll_state_fling ; if ( animate ) { smoothscrolltopositionfromtop ( position , list_top_offset , goto_scroll_duration ) ; return _bool ; } else { postsetselection ( position ) ; } } else if ( setselected ) { setmonthdisplayed ( mselectedday ) ; } return _bool ; }	this moves to the specified time in the view.
public boolean search ( v v ) { int h = hashmethod . hash ( v ) ; linkedlist < v > list = ( linkedlist < v > ) table [ h ] ; if ( list == null ) { return _bool ; } return list . contains ( v ) ; }	search for the desired value in the hashtable . < p > only succeeds if v overrides the equals ( object o ) method.
public void closejdbcconnection ( connection conn ) { try { if ( conn != null ) { conn . close ( ) ; } } catch ( sqlexception sqle ) { subclasslogwrapper ( _str ) ; } }	closes database connection and logs if an error is encountered.
@ override public void messageitemdetails ( string strclass , string item , string description , string [ ] msgoption , int [ ] msgnumber , int defaultoption ) { hashmap < integer , string > options = new hashmap < > ( msgoption . length ) ; for ( int i = _num ; i < msgoption . length ; i ++ ) { options . put ( msgnumber [ i ] , msgoption [ i ] ) ; } messageitemdetails ( strclass , description , item , options , defaultoption ) ; }	add descriptive details about a specific message box , so that if it needs to be reset in the preferences , then it is easily identifiable.
public void addlistener ( colormaplistener listener ) { listeners . add ( listener ) ; }	add a color map listener.
protected void computepdists ( relation < o > relation , knnquery < o > knn , writabledoubledatastore pdists ) { finiteprogress prdsprogress = log . isverbose ( ) ? new finiteprogress ( _str , relation . size ( ) , log ) : null ; for ( dbiditer iditer = relation . iterdbids ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { final knnlist neighbors = knn . getknnfordbid ( iditer , kreach + _num ) ; int ks = _num ; double ssum = _num ; for ( doubledbidlistiter neighbor = neighbors . iter ( ) ; neighbor . valid ( ) && ks < kreach ; neighbor . advance ( ) ) { if ( dbidutil . equal ( neighbor , iditer ) ) { continue ; } final double d = neighbor . doublevalue ( ) ; ssum += d * d ; ks ++ ; } double pdist = ks > _num ? math . sqrt ( ssum / ks ) : _num ; pdists . putdouble ( iditer , pdist ) ; log . incrementprocessed ( prdsprogress ) ; } log . ensurecompleted ( prdsprogress ) ; }	compute the probabilistic distances used by loop .
private static string appendifmissing ( final string str , final charsequence suffix , final boolean ignorecase , final charsequence ... suffixes ) { if ( str == null || isempty ( suffix ) || endswith ( str , suffix , ignorecase ) ) { return str ; } if ( suffixes != null && suffixes . length > _num ) { for ( final charsequence s : suffixes ) { if ( endswith ( str , s , ignorecase ) ) { return str ; } } } return str + suffix . tostring ( ) ; }	appends the suffix to the end of the string if the string does not already end in the suffix .
private jsonarray requestallfilesystems ( ) throws ioexception , jsonexception { jsonarray ret = new jsonarray ( ) ; for ( filesystem fs : filesystems ) { ret . put ( fs . getrootentry ( ) ) ; } return ret ; }	requests a filesystem in which to store application data .
externalproblem ( process process ) { this ( process . getinputstream ( ) , process . getoutputstream ( ) ) ; redirectstream . redirect ( process . geterrorstream ( ) , system . err ) ; }	constructs an external problem using the specified process .
protected static boolean networkmonitorexist ( string nwmonname ) { string classmethod = _str ; if ( debug . messageenabled ( ) ) { debug . message ( classmethod + _str + nwmonname ) ; } if ( ( nwmonname == null ) || ( nwmonname . length ( ) == _num ) ) { if ( debug . warningenabled ( ) ) { debug . warning ( classmethod + _str ) ; } return _bool ; } set < string > ntwstats = networkmonitor . getinstancenames ( ) ; string ss = nwmonname . tolowercase ( ) ; if ( ntwstats . contains ( ss ) ) { return _bool ; } else { return _bool ; } }	return whether the specified network monitor has been instantiated in the entitlements service yet.
public void andwith ( list < querypredicate > predicates ) { children . addall ( predicates ) ; }	adds multiple predicates that much be met by the vertices .
public void addroll ( mmrandom rng ) { int result = rng . randomint ( this . faces ) + this . min ; all . addelement ( new integer ( result ) ) ; this . total += result ; if ( keep != - _num && all . size ( ) >= keep ) { this . total = _num ; collections . sort ( all , collections . reverseorder ( ) ) ; for ( int i = _num ; i < keep ; i ++ ) { this . total += all . get ( i ) ; } } }	add the result from the given rng source .
public boolean checkcanonicaluseroptions ( ) { boolean result ; optionhandler handler ; string [ ] useroptions ; string [ ] useroptionscheck ; print ( _str ) ; try { handler = getdefaulthandler ( ) ; handler . setoptions ( getuseroptions ( ) ) ; if ( getdebug ( ) ) { print ( _str ) ; } useroptions = handler . getoptions ( ) ; if ( getdebug ( ) ) { println ( printoptions ( useroptions ) ) ; } if ( getdebug ( ) ) { println ( _str ) ; } handler . setoptions ( useroptions . clone ( ) ) ; if ( getdebug ( ) ) { println ( _str ) ; } useroptionscheck = handler . getoptions ( ) ; compareoptions ( useroptions , useroptionscheck ) ; println ( _str ) ; result = _bool ; } catch ( exception e ) { println ( _str ) ; result = _bool ; if ( getdebug ( ) ) { println ( e ) ; } } return result ; }	checks whether the user - supplied options stay the same after settting , getting and re - setting again.
public static void closequietly ( final closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( final runtimeexception rethrown ) { throw rethrown ; } catch ( final exception ignored ) { } } }	closes ' closeable ' , ignoring any checked exceptions.
public static void pushencryptedmessage ( final textsecureenvelope envelope ) { while ( _bool ) { try { queue . put ( envelope ) ; return ; } catch ( final interruptedexception e ) { } } }	adds an encrypted message to the queue.
public static int randomrangeint ( int min , int max ) { return ( int ) ( math . random ( ) < _num ? ( ( _num - math . random ( ) ) * ( max - min ) + min ) : ( math . random ( ) * ( max - min ) + min ) ) ; }	returns a random integer between the value min and the value max .
public void test_simpleprematureclose ( ) { striterator iter = new striterator ( m_data . iterator ( ) ) ; int i = _num ; while ( iter . hasnext ( ) ) { iter . next ( ) ; if ( ++ i == _num ) { iter . close ( ) ; asserttrue ( ! iter . hasnext ( ) ) ; } } asserttrue ( ! iter . isopen ( ) ) ; asserttrue ( i == _num ) ; }	test that striterator returns false for hasnext ( ) after close ( ).
public void pushdrawlist ( pspgelist list ) { synchronized ( drawlistqueue ) { drawlistqueue . add ( list ) ; } }	called from pspge module.
private void populatetasklist ( volume source , map < blockmirror , volume > groupmirrorsourcemap , tasklist tasklist , string taskid , resourceoperationtypeenum operationtype ) { set < uri > groupset = new hashset < uri > ( ) ; addtask ( tasklist , source , taskid , operationtype ) ; for ( entry < blockmirror , volume > entry : groupmirrorsourcemap . entryset ( ) ) { blockmirror mirror = entry . getkey ( ) ; volume mirrorsource = entry . getvalue ( ) ; if ( source . isincg ( ) && null != tasklist . gettasklist ( ) ) { groupset . add ( mirrorsource . getconsistencygroup ( ) ) ; } } list < blockconsistencygroup > groups = _dbclient . queryobject ( blockconsistencygroup . class , groupset ) ; for ( blockconsistencygroup group : groups ) { addtask ( tasklist , group , taskid , operationtype ) ; } }	populate the given tasklist with tasks .
public static tuple max ( iterator tuples , string field , comparator cmp ) { tuple t = null , tmp ; object min = null ; if ( tuples . hasnext ( ) ) { t = ( tuple ) tuples . next ( ) ; min = t . get ( field ) ; } while ( tuples . hasnext ( ) ) { tmp = ( tuple ) tuples . next ( ) ; object obj = tmp . get ( field ) ; if ( cmp . compare ( obj , min ) > _num ) { t = tmp ; min = obj ; } } return t ; }	get the tuple with the maximum data field value .
public string clusterdefinitionstiptext ( ) { return _str ; }	returns the tip text for this property.
public void testconstructorsignbytespositive1 ( ) { byte abytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num } ; int asign = _num ; byte rbytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = anumber . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , anumber . signum ( ) ) ; }	create a positive number from a sign and an array of bytes.
public void fling ( int startx , int starty , int velocityx , int velocityy , int minx , int maxx , int miny , int maxy , int overx , int overy ) { if ( mflywheel && ! isfinished ( ) ) { float oldvelocityx = mscrollerx . mcurrvelocity ; float oldvelocityy = mscrollery . mcurrvelocity ; if ( math . signum ( velocityx ) == math . signum ( oldvelocityx ) && math . signum ( velocityy ) == math . signum ( oldvelocityy ) ) { velocityx += oldvelocityx ; velocityy += oldvelocityy ; } } mmode = fling_mode ; mscrollerx . fling ( startx , velocityx , minx , maxx , overx ) ; mscrollery . fling ( starty , velocityy , miny , maxy , overy ) ; }	start scrolling based on a fling gesture.
public void addlistener ( navigatorlistener listener ) { listeners . add ( listener ) ; }	add listener to listener list.
public void closestream ( ) { carbonutil . closestreams ( stream ) ; executorservice . shutdown ( ) ; }	below method will be used to close streams.
public double patience ( int k , f f , int n ) { double pf = p ( f ) ; binomialdistribution dist = new binomialdistribution ( null , n , pf ) ; double p0 = math . pow ( _num - pf , n ) ; return _num - ( dist . cumulativeprobability ( k - _num ) - p0 ) / ( _num - p0 ) ; }	return the patience , i.
public static list seriesnamelistfromdataarray ( object [ ] [ ] data ) { int seriescount = data . length ; list seriesnamelist = new java . util . arraylist ( seriescount ) ; for ( int i = _num ; i < seriescount ; i ++ ) { seriesnamelist . add ( _str + ( i + _num ) ) ; } return seriesnamelist ; }	utility method for automatically generating series names .
@ override public int read ( char b [ ] , int off , int len ) throws ioexception { ensureopen ( ) ; if ( ( off < _num ) || ( off > b . length ) || ( len < _num ) || ( ( off + len ) > b . length ) || ( ( off + len ) < _num ) ) { throw new indexoutofboundsexception ( ) ; } else if ( len == _num ) { return _num ; } if ( pos >= count ) { return - _num ; } if ( pos + len > count ) { len = count - pos ; } if ( len <= _num ) { return _num ; } system . arraycopy ( buf , pos , b , off , len ) ; pos += len ; return len ; }	reads characters into a portion of an array .
public static void f ( string tag , string msg , object ... args ) { if ( slevel > level_fatal ) { return ; } if ( args . length > _num ) { msg = string . format ( msg , args ) ; } log . wtf ( tag , msg ) ; }	send a fatal error log message.
private static void expandnumberat ( string numberstring , int startindex , wordrelation wordrelation ) { expandnumber ( numberstring . substring ( startindex , numberstring . length ( ) ) , wordrelation ) ; }	returns the number string list of the given string starting at the given index.
public static boolean nullequals ( string s1 , string s2 ) { return ( s1 == null ? s2 == null : s1 . equals ( s2 ) ) ; }	equals ( ) with two strings where either could be null.
@ override public void run ( ) { multipleobjectsbundle data = generator . loaddata ( ) ; if ( log . isverbose ( ) ) { log . verbose ( _str ) ; } try { if ( outputfile . exists ( ) && log . isverbose ( ) ) { log . verbose ( _str + outputfile + _str + _str ) ; } try ( outputstreamwriter outstream = new filewriter ( outputfile , _bool ) ) { writeclusters ( outstream , data ) ; } } catch ( ioexception e ) { throw new abortexception ( _str , e ) ; } if ( log . isverbose ( ) ) { log . verbose ( _str ) ; } }	runs the wrapper with the specified arguments .
private boolean usedallrule17directors ( set < string > allocateddirectors , portallocationcontext context ) { set < string > rule17directors = getrule17directors ( context ) ; for ( string director : allocateddirectors ) { rule17directors . remove ( director ) ; } return rule17directors . isempty ( ) ; }	returns true if already used all the rule17 directors .
public void stop ( ) { synchronized ( privateinstancelock ) { if ( connectionacceptthread == null ) { return ; } } isstopped . set ( _bool ) ; try { connectionacceptthread . interrupt ( ) ; connectionacceptthread . join ( ) ; } catch ( interruptedexception e ) { } try { serversocket . close ( ) ; } catch ( ioexception e ) { } }	stops the communicator . all open connections to the remote server will be terminated . once this method has been called , the communicator cannot be restarted .
private static string expandsystemidstricton ( string systemid , string basesystemid ) throws uri . malformeduriexception { uri systemuri = new uri ( systemid , _bool ) ; if ( systemuri . isabsoluteuri ( ) ) { return systemid ; } uri baseuri = null ; if ( basesystemid == null || basesystemid . length ( ) == _num ) { baseuri = getuserdir ( ) ; } else { baseuri = new uri ( basesystemid , _bool ) ; if ( ! baseuri . isabsoluteuri ( ) ) { baseuri . absolutize ( getuserdir ( ) ) ; } } systemuri . absolutize ( baseuri ) ; return systemuri . tostring ( ) ; }	helper method for expandsystemid ( string , string , boolean ) : string.
public static void free ( dmessage msg ) { int index = size2index ( msg . getsize ( ) ) ; msg . clear ( ) ; if ( index < _num ) ; else if ( m_cache [ index ] != null ) ; else m_cache [ index ] = msg ; }	put a dmessage into the cache for reuse.
public boolean equalsignorecase ( final strbuilder other ) { if ( this == other ) { return _bool ; } if ( this . size != other . size ) { return _bool ; } final char thisbuf [ ] = this . buffer ; final char otherbuf [ ] = other . buffer ; for ( int i = size - _num ; i >= _num ; i -- ) { final char c1 = thisbuf [ i ] ; final char c2 = otherbuf [ i ] ; if ( c1 != c2 && character . touppercase ( c1 ) != character . touppercase ( c2 ) ) { return _bool ; } } return _bool ; }	checks the contents of this builder against another to see if they contain the same character content ignoring case .
protected static long convertuuidtolong ( uuid uuid ) { if ( uuid == null ) { return null ; } long converteduuid ; if ( uuid . version ( ) == _num ) { converteduuid = uuid . timestamp ( ) ; } else { converteduuid = uuid . getmostsignificantbits ( ) ; } return converteduuid ; }	converts a uuid to a long for bucketing purposes.
public void addvmarguments ( string vmargumentname , string vmargumentvalue ) { vmargumentdata vmarg = new vmargumentdata ( vmargumentname , vmargumentvalue ) ; vmset . add ( vmarg ) ; }	adds the given vm argument .
private void applyto ( classvisitor v , field f ) { if ( log . isloggingon ( ) ) { log . logline ( string . format ( _str , f . togenericstring ( ) ) ) ; } v . visit ( f ) ; }	apply a visitor to a field .
public void testcomparetoequalneg ( ) { byte abytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , _num , _num } ; int asign = - _num ; int bsign = - _num ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; assertequals ( _num , anumber . compareto ( bnumber ) ) ; }	compareto ( biginteger a ).
public void testscreenshot ( ) throws exception { log . d ( log_tag , _str ) ; screenshotstubactivity activity = getactivity ( ) ; assertnotnull ( activity ) ; file screenshotdir = getscreenshotdir ( ) ; newscreenshotobserver observer = new newscreenshotobserver ( screenshotdir . getabsolutepath ( ) ) ; observer . startwatching ( ) ; takescreenshot ( ) ; if ( observer . getcreatedpath ( ) == null ) { synchronized ( observer ) { observer . wait ( screen_wait_time_sec * _num ) ; } } assertnotnull ( string . format ( _str , screen_wait_time_sec ) , observer . getcreatedpath ( ) ) ; file screenshotfile = new file ( screenshotdir , observer . getcreatedpath ( ) ) ; try { asserttrue ( string . format ( _str , screenshotfile . getname ( ) ) , screenshotfile . isfile ( ) ) ; asserttrue ( string . format ( _str , screenshotfile . getname ( ) ) , isvalidimage ( screenshotfile ) ) ; } finally { screenshotfile . delete ( ) ; } }	a simple test for screenshots that launches an activity , injects the key event combo to trigger the screenshot , and verifies the screenshot was taken successfully .
public taskresourcerep unlinktargetvolumesfromsnapshotsession ( uri snapsessionuri , snapshotsessionunlinktargetsparam param ) { return unlinktargetvolumesfromsnapshotsession ( snapsessionuri , param , operationtypeenum . unlink_snapshot_session_target ) ; }	implements a request to unlink the passed targets from the blocksnapshotsession instance with the passed uri .
private list reverse ( list seq ) { linkedlist newseq = new linkedlist ( ) ; for ( iterator i = seq . iterator ( ) ; i . hasnext ( ) ; ) { directededge de = ( directededge ) i . next ( ) ; newseq . addfirst ( de . getsym ( ) ) ; } return newseq ; }	reverse the sequence . this requires reversing the order of the diredges , and flipping each diredge as well.
protected locpathiterator changeparttoref ( final qname uniquepseudovarname , walkingiterator wi , final int numsteps , final boolean isglobal ) { variable var = new variable ( ) ; var . setqname ( uniquepseudovarname ) ; var . setisglobal ( isglobal ) ; if ( isglobal ) { elemtemplateelement elem = getelemfromexpression ( wi ) ; stylesheetroot root = elem . getstylesheetroot ( ) ; vector vars = root . getvariablesandparamscomposed ( ) ; var . setindex ( vars . size ( ) - _num ) ; } axeswalker walker = wi . getfirstwalker ( ) ; for ( int i = _num ; i < numsteps ; i ++ ) { assertion ( null != walker , _str ) ; walker = walker . getnextwalker ( ) ; } if ( null != walker ) { filterexprwalker few = new filterexprwalker ( wi ) ; few . setinnerexpression ( var ) ; few . exprsetparent ( wi ) ; few . setnextwalker ( walker ) ; walker . setprevwalker ( few ) ; wi . setfirstwalker ( few ) ; return wi ; } else { filterexpriteratorsimple feis = new filterexpriteratorsimple ( var ) ; feis . exprsetparent ( wi . exprgetparent ( ) ) ; return feis ; } }	change a given number of steps to a single variable reference .
@ deprecated @ override public string readline ( ) throws ioexception { stringbuilder b = new stringbuilder ( _num ) ; int chr ; while ( ( chr = read ( ) ) >= _num ) { if ( chr != _str ) { b . append ( ( char ) chr ) ; } else { return b . tostring ( ) ; } } return b . tostring ( ) ; }	emulate the deprecated datainputstream.
private void addtoscene ( final node items ) { collection . add ( items ) ; }	adds items to scene , ensuring we are on the fx thread.
public string documentationhomepageurl ( ) { return properties . getproperty ( _str ) ; }	returns the url of the product home page .
public static boolean hastaxonomyinfo ( sequencesreader reader ) { final file taxonfile = new file ( reader . path ( ) , taxonomy_file ) ; final file mappingfile = new file ( reader . path ( ) , taxonomy_to_sequence_file ) ; if ( taxonfile . exists ( ) && mappingfile . exists ( ) ) { return _bool ; } else if ( taxonfile . exists ( ) || mappingfile . exists ( ) ) { throw new notalkbackslimexception ( _str ) ; } else { return _bool ; } }	returns true if the supplied reader contains taxonomy information.
public void removeselectionlistener ( final selectionlistener listener ) { checkwidget ( ) ; if ( listener == null ) { swt . error ( swt . error_null_argument ) ; } listofselectionlisteners . remove ( listener ) ; }	removes the listener from the collection of listeners who will be notified when the control is selected by the user .
public void replace ( classnode type , int n ) { remove ( n ) ; push ( type ) ; }	replace n top level elements with new element of given type.
public void handlebutton1request ( requestinvocationevent event ) throws modelcontrolexception { submitcycle = _bool ; entitiesmodel model = ( entitiesmodel ) getmodel ( ) ; ampropertysheet prop = ( ampropertysheet ) getchild ( property_attribute ) ; string universalid = ( string ) getpagesessionattribute ( universal_id ) ; try { map oldvalues = model . getattributevalues ( universalid , _bool ) ; map values = prop . getattributevalues ( oldvalues , _bool , model ) ; string currealm = ( string ) getpagesessionattribute ( amadminconstants . current_realm ) ; model . modifyentity ( currealm , universalid , values ) ; setinlinealertmessage ( ccalert . type_info , _str , _str ) ; } catch ( amconsoleexception e ) { setinlinealertmessage ( ccalert . type_error , _str , e . getmessage ( ) ) ; } forwardto ( ) ; }	handles create realm request .
private node deletemax ( node x ) { if ( x . right == null ) return x . left ; x . right = deletemax ( x . right ) ; x . size = _num + size ( x . left ) + size ( x . right ) ; x . height = _num + math . max ( height ( x . left ) , height ( x . right ) ) ; return balance ( x ) ; }	removes the largest key and associated value from the given subtree .
public void clear ( ) { final reentrantlock lock = this . lock ; lock . lock ( ) ; try { for ( node < e > f = first ; f != null ; ) { f . item = null ; node < e > n = f . next ; f . prev = null ; f . next = null ; f = n ; } first = last = null ; count = _num ; notfull . signalall ( ) ; } finally { lock . unlock ( ) ; } }	atomically removes all of the elements from this deque.
protected void onprogress ( int itemcount , int size ) { }	called every time when command makes some little progress . can be mapped to async progress - bar.
private treenode ( long nodevalue , snmpmibagent agent , treenode sup ) { this . nodevalue = nodevalue ; this . parent = sup ; agents . addelement ( agent ) ; }	only the treenode class can create an instance of treenode.
public week ( date time ) { this ( time , timezone . getdefault ( ) , locale . getdefault ( ) ) ; }	creates a time period for the week in which the specified date / time falls , using the default time zone and locale ( the locale can affect the day - of - the - week that marks the beginning of the week , as well as the minimal number of days in the first week of the year ) .
public codeattribute createcode ( ) { codeattribute code = new codeattribute ( ) ; for ( int i = _num ; i < _attributes . size ( ) ; i ++ ) { attribute attr = _attributes . get ( i ) ; if ( attr instanceof codeattribute ) return ( codeattribute ) attr ; } return null ; }	create the code attribute .
public binaryout ( string filename ) { try { outputstream os = new fileoutputstream ( filename ) ; out = new bufferedoutputstream ( os ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }	initializes a binary output stream from a file .
protected objectstreamclass readclassdescriptor ( ) throws ioexception , classnotfoundexception { objectstreamclass newclassdesc = new objectstreamclass ( ) ; string name = input . readutf ( ) ; if ( name . length ( ) == _num ) { throw new ioexception ( _str ) ; } newclassdesc . setname ( name ) ; newclassdesc . setserialversionuid ( input . readlong ( ) ) ; newclassdesc . setflags ( input . readbyte ( ) ) ; if ( descriptorhandle == - _num ) { descriptorhandle = nexthandle ( ) ; } registerobjectread ( newclassdesc , descriptorhandle , _bool ) ; readfielddescriptors ( newclassdesc ) ; return newclassdesc ; }	reads a class descriptor from the source stream .
public static boolean createnewfile ( file targetfile ) { if ( targetfile . exists ( ) ) targetfile . delete ( ) ; try { return targetfile . createnewfile ( ) ; } catch ( ioexception e ) { return _bool ; } }	create a new file , if the file exists , delete and create again .
public void testzeroone ( ) { byte abytes [ ] = { _num } ; byte bbytes [ ] = { _num } ; int asign = _num ; int bsign = _num ; byte rbytes [ ] = { _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . or ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	or for zero and one.
protected int executepreparestatement ( list < column > columns , preparedstatement statement ) throws sqlexception { int bindno = _num ; for ( column c : columns ) { setcolumnvalue ( statement , bindno , c ) ; bindno ++ ; } return statement . executeupdate ( ) ; }	executes a prepared statement using values supplied as arguments .
public config ( samlauthorityconfiguration samlauthorityconfig , tokenrestrictions tokenrestrictions , collection < list < certificate > > validcerts , long clocktolerance , collection < idpconfig > inexternalidps ) { validate . notnull ( samlauthorityconfig ) ; validate . notnull ( tokenrestrictions ) ; validate . notempty ( validcerts ) ; list < certificate > authoritycert = samlauthorityconfig . getsigningcertificatechain ( ) ; boolean authoritycertinvalidcerts = _bool ; for ( list < certificate > currentchain : validcerts ) { validate . notempty ( currentchain ) ; validate . nonullelements ( currentchain ) ; if ( ! authoritycertinvalidcerts && currentchain . equals ( authoritycert ) ) { authoritycertinvalidcerts = _bool ; } } validate . istrue ( authoritycertinvalidcerts , _str ) ; validate . istrue ( clocktolerance >= _num ) ; this . samlauthorityconfig = samlauthorityconfig ; this . validcerts = validcerts ; this . clocktolerance = clocktolerance ; this . tokenrestrictions = tokenrestrictions ; hashmap < string , idpconfig > idpsset = new hashmap < string , idpconfig > ( ) ; if ( inexternalidps != null ) { for ( idpconfig conf : inexternalidps ) { if ( conf != null ) { idpsset . put ( conf . getentityid ( ) , conf ) ; } } } this . externalidps = collections . unmodifiablemap ( idpsset ) ; }	creates a new configuration.
public static void checknotempty ( string string ) { if ( string . isempty ( ) ) { throw new nullpointerexception ( ) ; } }	ensures that an string reference passed as a parameter to the calling method is not empty .
public void cancelunnamedtasks ( ) { if ( unnamedtaskexecutor != null ) { unnamedtaskexecutor . shutdownnow ( ) ; } }	cancel all open and running unnamed tasks.
public static double [ ] minmax ( list < double > values ) { if ( values . size ( ) == _num ) { return new double [ _num ] ; } double min = values . get ( _num ) ; double max = min ; int length = values . size ( ) ; for ( int i = _num ; i < length ; i ++ ) { double value = values . get ( i ) ; min = math . min ( min , value ) ; max = math . max ( max , value ) ; } return new double [ ] { min , max } ; }	calculate the minimum and maximum values out of a list of doubles .
public criteria createcriteria ( ) { criteria criteria = createcriteriainternal ( ) ; if ( oredcriteria . size ( ) == _num ) { oredcriteria . add ( criteria ) ; } return criteria ; }	this method was generated by mybatis generator . this method corresponds to the database table trash.
private char readescapecharacter ( ) throws ioexception { if ( pos == limit && ! fillbuffer ( _num ) ) { throw syntaxerror ( _str ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case _str : if ( pos + _num > limit && ! fillbuffer ( _num ) ) { throw syntaxerror ( _str ) ; } char result = _num ; for ( int i = pos , end = i + _num ; i < end ; i ++ ) { char c = buffer [ i ] ; result <<= _num ; if ( c >= _str && c <= _str ) { result += ( c - _str ) ; } else if ( c >= _str && c <= _str ) { result += ( c - _str + _num ) ; } else if ( c >= _str && c <= _str ) { result += ( c - _str + _num ) ; } else { throw new numberformatexception ( _str + new string ( buffer , pos , _num ) ) ; } } pos += _num ; return result ; case _str : return _str ; case _str : return _str ; case _str : return _str ; case _str : return _str ; case _str : return _str ; case _str : linenumber ++ ; linestart = pos ; case _str : case _str : case _str : case _str : return escaped ; default : throw syntaxerror ( _str ) ; } }	unescapes the character identified by the character or characters that immediately follow a backslash.
private void updateparamsforauth ( string [ ] authnames , list < pair > queryparams , map < string , string > headerparams ) { for ( string authname : authnames ) { authentication auth = authentications . get ( authname ) ; if ( auth == null ) throw new runtimeexception ( _str + authname ) ; auth . applytoparams ( queryparams , headerparams ) ; } }	update query and header parameters based on authentication settings .
private void fixspannedwithspaces ( spannablestringbuilder builder , int widthmeasurespec , int heightmeasurespec ) { long startfix = system . currenttimemillis ( ) ; fixingresult result = addspacesaroundspansuntilfixed ( builder , widthmeasurespec , heightmeasurespec ) ; if ( result . fixed ) { removeunneededspaces ( widthmeasurespec , heightmeasurespec , builder , result ) ; } else { fallbacktostring ( widthmeasurespec , heightmeasurespec ) ; } long fixduration = system . currenttimemillis ( ) - startfix ; logger . d ( tag , _str + fixduration ) ; }	add spaces around spans until the text is fixed , and then removes the unneeded spaces.
private void removebookmarktrackingicons ( ) { if ( trackingicons != null ) { for ( iterator i = trackingicons . iterator ( ) ; i . hasnext ( ) ; ) { guttericonimpl ti = ( guttericonimpl ) i . next ( ) ; if ( ti . geticon ( ) == bookmarkicon ) { i . remove ( ) ; } } } }	removes all bookmark tracking icons .
public simplemetricgroup ( groupname name , stream < ? extends metric > i ) { this ( name , i . collect ( collectors . < metric > tolist ( ) ) ) ; }	create a metric group with the given metrics .
public boolean isinside ( point point ) { return bounds . contains ( point ) ; }	returns true if the point is inside this sprite.
private void resolveprotocols ( classloader loader ) { serviceloader < protocolmanagerfactory > serviceloader = serviceloader . load ( protocolmanagerfactory . class , loader ) ; loadprotocolmanagerfactories ( serviceloader ) ; }	finds protocol support from a given classloader .
public static list < inetaddress > hostaddresses ( ) { list < inetaddress > addrlist = new arraylist < > ( ) ; enumeration < networkinterface > ifcs = null ; try { ifcs = networkinterface . getnetworkinterfaces ( ) ; } catch ( socketexception ex ) { log . error ( _str , ex ) ; } if ( ifcs != null ) { while ( ifcs . hasmoreelements ( ) ) { networkinterface ifc = ifcs . nextelement ( ) ; try { if ( ifc . isup ( ) ) { enumeration < inetaddress > addresses = ifc . getinetaddresses ( ) ; while ( addresses . hasmoreelements ( ) ) { inetaddress address = addresses . nextelement ( ) ; if ( ! address . isloopbackaddress ( ) && ! address . islinklocaladdress ( ) ) { addrlist . add ( address ) ; } } } } catch ( socketexception ex ) { log . error ( _str , ifc . tostring ( ) , ex ) ; } } } return addrlist ; }	a list of the non - loopback , non - link - local ip addresses of the host , or null if none found .
public final static int caculateinsamplesize ( bitmapfactory . options options , int rqsw , int rqsh ) { final int height = options . outheight ; final int width = options . outwidth ; int insamplesize = _num ; if ( rqsw == _num || rqsh == _num ) return _num ; if ( height > rqsh || width > rqsw ) { final int heightratio = math . round ( ( float ) height / ( float ) rqsh ) ; final int widthratio = math . round ( ( float ) width / ( float ) rqsw ) ; insamplesize = heightratio < widthratio ? heightratio : widthratio ; } return insamplesize ; }	caculate the bitmap samplesize.
public boolean hasstatus ( final statusid status ) { return statuses . contains ( status ) ; }	check if the entity has a certain status .
@ override public string tostring ( ) { return _str + _str + instancelist + _str + outcomelist + _str + weightlist + _str + sequenceids + _str + sequencepositions + _str + addinganotherinstancesallowed + _str + totalnonnullfeaturescount + _str ; }	primarily for debug purposes.
static synchronized void computeprf_sslv3 ( byte [ ] out , byte [ ] secret , byte [ ] seed ) { if ( sha == null ) { init ( ) ; } int pos = _num ; int iteration = _num ; byte [ ] digest ; while ( pos < out . length ) { byte [ ] pref = new byte [ iteration ] ; arrays . fill ( pref , ( byte ) ( _num + iteration ++ ) ) ; sha . update ( pref ) ; sha . update ( secret ) ; sha . update ( seed ) ; md5 . update ( secret ) ; md5 . update ( sha . digest ( ) ) ; digest = md5 . digest ( ) ; if ( pos + _num > out . length ) { system . arraycopy ( digest , _num , out , pos , out . length - pos ) ; pos = out . length ; } else { system . arraycopy ( digest , _num , out , pos , _num ) ; pos += _num ; } } }	computes the value of sslv3 pseudo random function .
public void addchannelmap ( channelmap channelmap ) { if ( ! mchannelmaps . contains ( channelmap ) ) { mchannelmaps . add ( channelmap ) ; int index = mchannelmaps . indexof ( channelmap ) ; fireintervaladded ( this , index , index ) ; broadcast ( new channelmapevent ( channelmap , event . add ) ) ; } }	adds the channel map to this model.
@ override public boolean add ( e o ) { if ( null == o ) { throw new nullpointerexception ( ) ; } if ( offer ( o ) ) { return _bool ; } throw new illegalstateexception ( ) ; }	adds an element to the queue .
public object putresource ( object key , object value ) { return ( objectcache . put ( key , value ) ) ; }	return the resource for the specified key.
public uidrange [ ] parseuidrange ( ) throws decodingexception { charactervalidator validator = new messagesetcharvalidator ( ) ; string nextword = consumeword ( validator , _bool ) ; int commapos = nextword . indexof ( _str ) ; if ( commapos == - _num ) { return new uidrange [ ] { parseuidrange ( nextword ) } ; } arraylist < uidrange > rangelist = new arraylist < uidrange > ( ) ; int pos = _num ; while ( commapos != - _num ) { string range = nextword . substring ( pos , commapos ) ; uidrange set = parseuidrange ( range ) ; rangelist . add ( set ) ; pos = commapos + _num ; commapos = nextword . indexof ( _str , pos ) ; } string range = nextword . substring ( pos ) ; rangelist . add ( parseuidrange ( range ) ) ; list < uidrange > merged = uidrange . mergeranges ( rangelist ) ; return merged . toarray ( new uidrange [ merged . size ( ) ] ) ; }	reads a " message set " argument , and parses into an idset . this also support the use of $ as sequence - set as stated in searchres rfc5182.
private string replacesuffix ( string value , string toreplace , string changeto ) { string vvalue ; if ( ( value == null ) || ( toreplace == null ) || ( changeto == null ) ) { return value ; } vvalue = removesuffix ( value , toreplace ) ; if ( value . equals ( vvalue ) ) { return value ; } else { return vvalue + changeto ; } }	replace a string suffix by another.
private void executeclaimedtask ( claimedtask claimedtask ) { if ( ! claimedtask . setstarttime ( new date ( ) ) ) { _log . info ( _str , claimedtask . gettask ( ) ) ; return ; } scanrangetask task = claimedtask . gettask ( ) ; boolean releasetask = _bool ; try { _scanworkflow . renewscanrangetasks ( immutablelist . of ( task ) , queue_renew_ttl ) ; releasetask = asyncrangescan ( task ) ; } finally { unclaimtask ( claimedtask , releasetask ) ; _backgroundservice . submit ( _startscansifavailablerunnable ) ; } }	executes a previously claimed scan range task .
private static boolean createnavidirectory ( ) { final file dir = new file ( confighelper . getconfigurationdirectory ( constants . company_name , constants . project_name ) ) ; return dir . exists ( ) || dir . mkdir ( ) ; }	creates the configuration directory if it does not already exist .
public void updatebuttonactionperformed ( ) { if ( ! readreceivedelay ( ) ) { return ; } if ( ! readpulsewidth ( ) ) { return ; } if ( ! checkconsistency ( ) ) { return ; } if ( curnode . getnodetype ( ) != nodetype ) { curnode . setnodetype ( nodetype ) ; } setnodeparameters ( ) ; changednode = _bool ; editmode = _bool ; curnode = null ; addbutton . setvisible ( _bool ) ; editbutton . setvisible ( _bool ) ; deletebutton . setvisible ( _bool ) ; donebutton . setvisible ( _bool ) ; updatebutton . setvisible ( _bool ) ; cancelbutton . setvisible ( _bool ) ; nodeaddrfield . setvisible ( _bool ) ; nodeaddrstatic . setvisible ( _bool ) ; statustext2 . settext ( stdstatus2 ) ; statustext3 . settext ( stdstatus3 ) ; statustext1 . settext ( rb . getstring ( _str ) + _str + integer . tostring ( nodeaddress ) ) ; errorinstatus1 = _bool ; }	method to handle update button.
public static class toclass ( classfile cf , classloader loader , protectiondomain domain ) throws cannotcompileexception { try { byte [ ] b = tobytecode ( cf ) ; method method ; object [ ] args ; if ( domain == null ) { method = defineclass1 ; args = new object [ ] { cf . getname ( ) , b , new integer ( _num ) , new integer ( b . length ) } ; } else { method = defineclass2 ; args = new object [ ] { cf . getname ( ) , b , new integer ( _num ) , new integer ( b . length ) , domain } ; } return toclass2 ( method , loader , args ) ; } catch ( runtimeexception e ) { throw e ; } catch ( java . lang . reflect . invocationtargetexception e ) { throw new cannotcompileexception ( e . gettargetexception ( ) ) ; } catch ( exception e ) { throw new cannotcompileexception ( e ) ; } }	loads a class file by a given class loader .
public iterator < target > targetiterator ( ) { return targetlist . iterator ( ) ; }	iterate over target objects representing control flow targets and their edge types .
private void fitsizeofscrolledcontent ( ) { point p = scrollcomposite . getsize ( ) ; main . setsize ( main . computesize ( p . x , swt . default ) ) ; }	fits the width of the main composite to the same width scrolled composite was given .
public int hashcode ( ) { return name . hashcode ( ) ; }	returns the hash code value for this entry .
private static map < string , snmpoid > buildpoolindexmap ( snmpcacheddata cached ) { if ( cached == null ) return collections . emptymap ( ) ; final snmpoid [ ] indexes = cached . indexes ; final object [ ] datas = cached . datas ; final int len = indexes . length ; final map < string , snmpoid > m = new hashmap < > ( len ) ; for ( int i = _num ; i < len ; i ++ ) { final snmpoid index = indexes [ i ] ; if ( index == null ) continue ; final memorypoolmxbean mpm = ( memorypoolmxbean ) datas [ i ] ; if ( mpm == null ) continue ; final string name = mpm . getname ( ) ; if ( name == null ) continue ; m . put ( name , index ) ; } return m ; }	builds a map pool - name = > pool - index from the snmptablehandler of the jvmmempooltable.
public dcryptostrength ( jframe parent ) throws cryptoexception { super ( parent , res . getstring ( _str ) , modalitytype . document_modal ) ; initcomponents ( ) ; }	creates a new dcryptostrength dialog where the parent is a frame .
private component createseparator ( ) { jseparator sep = new jseparator ( swingconstants . vertical ) ; sep . setpreferredsize ( new dimension ( _num , _num ) ) ; sep . setminimumsize ( new dimension ( _num , _num ) ) ; return sep ; }	creates a vertical separator for visually separating status bar elements.
public void add ( final t object ) { synchronized ( mlock ) { mlist . add ( object ) ; } notifydatasetchanged ( ) ; }	adds the specified object at the end of the array .
public void build ( realmresults < t > results ) { int xindex = _num ; for ( t object : results ) { mvalues . add ( buildentryfromresultobject ( object , xindex ++ ) ) ; } }	rebuilds the dataset based on the given realmresults .
public byte [ ] generatesignature ( ) throws cryptoexception , datalengthexception { contentdigest . dofinal ( mdash , mdash . length - hlen - slen ) ; if ( slen != _num ) { random . nextbytes ( salt ) ; system . arraycopy ( salt , _num , mdash , mdash . length - slen , slen ) ; } byte [ ] h = new byte [ hlen ] ; contentdigest . update ( mdash , _num , mdash . length ) ; contentdigest . dofinal ( h , _num ) ; block [ block . length - slen - _num - hlen - _num ] = _num ; system . arraycopy ( salt , _num , block , block . length - slen - hlen - _num , slen ) ; byte [ ] dbmask = maskgeneratorfunction1 ( h , _num , h . length , block . length - hlen - _num ) ; for ( int i = _num ; i != dbmask . length ; i ++ ) { block [ i ] ^= dbmask [ i ] ; } block [ _num ] &= ( _num > > ( ( block . length * _num ) - embits ) ) ; system . arraycopy ( h , _num , block , block . length - hlen - _num , hlen ) ; block [ block . length - _num ] = trailer ; byte [ ] b = cipher . processblock ( block , _num , block . length ) ; clearblock ( block ) ; return b ; }	generate a signature for the message we ' ve been loaded with using the key we were initialised with .
public void testnegposfirstlonger ( ) { byte abytes [ ] = { - _num , _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , - _num , _num , _num , - _num , - _num } ; byte bbytes [ ] = { - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = - _num ; int bsign = _num ; byte rbytes [ ] = { _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . and ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	and for a negative and a positive numbers ; the first is longer.
@ override public void write ( byte [ ] b , int off , int len ) { if ( ( off < _num ) || ( off > b . length ) || ( len < _num ) || ( ( off + len ) > b . length ) || ( ( off + len ) < _num ) ) { throw new indexoutofboundsexception ( ) ; } else if ( len == _num ) { return ; } synchronized ( this ) { int newcount = count + len ; int remaining = len ; int inbufferpos = count - filledbuffersum ; while ( remaining > _num ) { int part = math . min ( remaining , currentbuffer . length - inbufferpos ) ; system . arraycopy ( b , off + len - remaining , currentbuffer , inbufferpos , part ) ; remaining -= part ; if ( remaining > _num ) { neednewbuffer ( newcount ) ; inbufferpos = _num ; } } count = newcount ; } }	write the bytes to byte array .
public static void openfileintent ( context context , file openfile ) { if ( context != null && openfile . exists ( ) ) { try { intent intent = getfileintent ( context , openfile ) ; context . startactivity ( intent ) ; } catch ( exception e ) { globalutils . logthis ( tag , _str , e ) ; } } }	open file using intent.
public static java . sql . date tosqldate ( string date ) { java . util . date newdate = todate ( date , _str ) ; if ( newdate != null ) { return new java . sql . date ( newdate . gettime ( ) ) ; } else { return null ; } }	converts a date string into a java.
public static int round ( final float value ) { final int bits = float . floattorawintbits ( value ) ; final int biasedexp = bits > > _num & _num ; final int shift = _num - _num + max_float_exponent - biasedexp ; if ( ( shift & - _num ) == _num ) { int extendedmantissa = _num | bits & _num ; if ( bits < _num ) { extendedmantissa = - extendedmantissa ; } return ( extendedmantissa > > shift ) + _num > > _num ; } else { return ( int ) value ; } }	might have different semantics than math.
public static plaintext plain ( short text ) { return plain ( integer . tostring ( text ) ) ; }	creates a new plaintext component with the given short.
public attributeinfo copy ( constpool newcp , map classnames ) { copier copier = new copier ( info , constpool , newcp , classnames ) ; try { copier . parameters ( ) ; return new parameterannotationsattribute ( newcp , getname ( ) , copier . close ( ) ) ; } catch ( exception e ) { throw new runtimeexception ( e . tostring ( ) ) ; } }	copies this attribute and returns a new copy .
private string createcomponentchanges ( ) { stringbuilder builder = new stringbuilder ( ) ; for ( servicecatalogdiff servicecatalogdiff : difflist ) { builder . append ( createapichanges ( servicecatalogdiff ) ) ; } return builder . tostring ( ) ; }	construct details of api changes by service and component name.
public static synchronized void it ( string description , unsafeblock block ) { it ( description , identity ( ) , block ) ; }	defines a new example .
public static boolean iswritable ( final file file , final boolean makedirs ) { if ( file == null ) { log . e ( fileutils . class , _str ) ; return _bool ; } final string fileparentdir = file . getparent ( ) ; if ( ! textutils . isempty ( fileparentdir ) ) { final file filedir = new file ( fileparentdir ) ; if ( ! filedir . exists ( ) ) { if ( makedirs ) return makedirsforfile ( file ) ; else return _bool ; } } boolean iswritable = _bool ; if ( file . exists ( ) ) iswritable = file . canwrite ( ) ; else { try { iswritable = file . createnewfile ( ) ; } catch ( ioexception e ) { } if ( iswritable ) iswritable = file . delete ( ) ; } return iswritable ; }	method checks if file could be written / deleted or created.
public string tostring ( ) { return oid . tostring ( ) ; }	returns a string representation of the oid ' s integer components in dot separated notation .
public void read ( bytecodeparser in ) throws ioexception { int length = in . readint ( ) ; _maxstack = in . readshort ( ) ; _maxlocals = in . readshort ( ) ; int codelength = in . readint ( ) ; _code = new byte [ codelength ] ; in . read ( _code , _num , codelength ) ; int exncount = in . readshort ( ) ; for ( int i = _num ; i < exncount ; i ++ ) { exceptionitem exn = new exceptionitem ( ) ; exn . setstart ( in . readshort ( ) & _num ) ; exn . setend ( in . readshort ( ) & _num ) ; exn . sethandler ( in . readshort ( ) & _num ) ; exn . settype ( in . readshort ( ) & _num ) ; _exceptions . add ( exn ) ; } int attrcount = in . readshort ( ) ; for ( int i = _num ; i < attrcount ; i ++ ) { attribute attr = in . parseattribute ( ) ; _attributes . add ( attr ) ; } }	writes the field to the output .
public void testskip ( ) throws exception { byte [ ] data = new byte [ ] { - _num , - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num } ; testinputstream tis = new testinputstream ( data ) ; cipherinputstream cis = new cipherinputstream ( tis , new nullcipher ( ) ) ; int expected = data . length ; byte [ ] result = new byte [ expected ] ; int skipped = ( int ) cis . skip ( _num ) ; int ind = skipped ; int got = skipped + cis . read ( result , _num , _num ) ; while ( _bool ) { for ( int j = _num ; j < got - ind ; j ++ ) { if ( result [ j ] != data [ ind + j ] ) { fail ( _str + _str + data [ ind + j ] + _str + result [ j ] ) ; } } if ( got == expected ) { break ; } else if ( got > expected ) { fail ( _str + _str + _str ) ; } else { ind = got ; got += cis . read ( result , _num , _num ) ; } } if ( ( got = cis . read ( result , _num , _num ) ) != - _num ) { fail ( _str + _str + got + _str ) ; } }	skip ( long n ) method testing.
void addstring ( int c ) { if ( strpos == str . length ) { char newstr [ ] = new char [ str . length + _num ] ; system . arraycopy ( str , _num , newstr , _num , str . length ) ; str = newstr ; } str [ strpos ++ ] = ( char ) c ; }	add a char to the string buffer .
@ override public int hashcode ( ) { return oid . hashcode ( ) ; }	returns the hash code for this name form.
public choleskydecomposition ( matrix arg ) { double [ ] [ ] a = arg . getarray ( ) ; n = arg . getrowdimension ( ) ; l = new double [ n ] [ n ] ; isspd = ( arg . getcolumndimension ( ) == n ) ; for ( int j = _num ; j < n ; j ++ ) { double [ ] lrowj = l [ j ] ; double d = _num ; for ( int k = _num ; k < j ; k ++ ) { double [ ] lrowk = l [ k ] ; double s = _num ; for ( int i = _num ; i < k ; i ++ ) { s += lrowk [ i ] * lrowj [ i ] ; } lrowj [ k ] = s = ( a [ j ] [ k ] - s ) / l [ k ] [ k ] ; d = d + s * s ; isspd = isspd & ( a [ k ] [ j ] == a [ j ] [ k ] ) ; } d = a [ j ] [ j ] - d ; isspd = isspd & ( d > _num ) ; l [ j ] [ j ] = math . sqrt ( math . max ( d , _num ) ) ; for ( int k = j + _num ; k < n ; k ++ ) { l [ j ] [ k ] = _num ; } } }	cholesky algorithm for symmetric and positive definite matrix .
protected void findcandidatecrossings ( s2point a , s2point b , list < integer > candidatecrossings ) { preconditions . checkstate ( indexcomputed ) ; arraylist < s2cellid > cover = lists . newarraylist ( ) ; getcovering ( a , b , _bool , cover ) ; set < integer > uniqueset = new hashset < integer > ( ) ; getedgesinparentcells ( cover , uniqueset ) ; getedgesinchildrencells ( a , b , cover , uniqueset ) ; candidatecrossings . clear ( ) ; candidatecrossings . addall ( uniqueset ) ; }	appends to " candidatecrossings " all edge references which may cross the given edge.
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return true_as_of_secs ; case _num : return source ; case _num : return system ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public repositorylocation ( string repositoryname , string [ ] pathcomponents ) throws malformedrepositorylocationexception { if ( repositoryname == null || repositoryname . isempty ( ) ) { throw new malformedrepositorylocationexception ( _str ) ; } if ( pathcomponents == null ) { throw new malformedrepositorylocationexception ( _str ) ; } for ( string pathcomp : pathcomponents ) { if ( pathcomp == null || pathcomp . isempty ( ) ) { throw new malformedrepositorylocationexception ( _str ) ; } } this . repositoryname = repositoryname ; this . path = pathcomponents ; }	creates a repositorylocation for a given repository and a set of path components which will be concatenated by a / .
public void addproperty ( string key , string value ) { carbonproperties . setproperty ( key , value ) ; }	this method will be used to add a new property.
protected javaelementdelta createdeltatree ( ijavaelement element , javaelementdelta delta ) { javaelementdelta childdelta = delta ; arraylist ancestors = getancestors ( element ) ; if ( ancestors == null ) { if ( equalsandsameparent ( delta . getelement ( ) , getelement ( ) ) ) { this . kind = delta . kind ; this . changeflags = delta . changeflags ; this . movedtohandle = delta . movedtohandle ; this . movedfromhandle = delta . movedfromhandle ; } } else { for ( int i = _num , size = ancestors . size ( ) ; i < size ; i ++ ) { ijavaelement ancestor = ( ijavaelement ) ancestors . get ( i ) ; javaelementdelta ancestordelta = new javaelementdelta ( ancestor ) ; ancestordelta . addaffectedchild ( childdelta ) ; childdelta = ancestordelta ; } } return childdelta ; }	creates the nested delta deltas based on the affected element its delta , and the root of this delta tree.
@ override public string tostring ( ) { return gettitle ( ) ; }	tostring . used for jcombobox in movie editor.
public int size ( ) { if ( hmap == null ) { return _num ; } return hmap . size ( ) ; }	return the size of the embedded map.
public static string replace ( string instring , string oldpattern , string newpattern ) { if ( ! haslength ( instring ) || ! haslength ( oldpattern ) || newpattern == null ) { return instring ; } stringbuilder sb = new stringbuilder ( ) ; int pos = _num ; int index = instring . indexof ( oldpattern ) ; int patlen = oldpattern . length ( ) ; while ( index >= _num ) { sb . append ( instring . substring ( pos , index ) ) ; sb . append ( newpattern ) ; pos = index + patlen ; index = instring . indexof ( oldpattern , pos ) ; } sb . append ( instring . substring ( pos ) ) ; return sb . tostring ( ) ; }	replace all occurrences of a substring within a string with another string .
public boolean coordinateinzone ( id < activityfacility > zoneid , coord coordinate ) { point point = mgc . xy2point ( coordinate . getx ( ) , coordinate . gety ( ) ) ; return pointinzone ( zoneid , point ) ; }	determines if a given coordinate lies within a selected zone . the shape of the zone is defined by the respective zone geometry in the shape file.
public string associatortiptext ( ) { return _str ; }	returns the tip text for this property.
public xwaveslabelfilereader ( reader reader ) throws ioexception { this . reader = new bufferedreader ( reader ) ; parselabels ( ) ; reader . close ( ) ; }	read data from a label file .
public static double parsedoubledefault ( string s , double def ) { if ( s == null ) { return def ; } try { return double . parsedouble ( s ) ; } catch ( numberformatexception e ) { return def ; } }	parses a double safely , returning a default if nothing can be sanely parsed from it .
public static void registerapp ( int application , string appname ) throws appidexception { if ( ( application & app_id_mask ) != application ) { throw new invalidappidvalueexception ( application ) ; } string oldapp = appidmap . putifabsent ( application , appname ) ; if ( oldapp != null && ! oldapp . equals ( appname ) ) { throw new appidinuseexception ( application , oldapp , appname ) ; } }	a lame attempt to prevent duplicate application id.
public boolean putprofile ( profile profile ) { return putprofile ( profile , _bool ) ; }	create or update a profile for a remote counterpart .
public void print ( char c ) { writer . print ( c ) ; }	prints the given char.
public void initblockviews ( ) { if ( mworkspaceview != null ) { list < block > rootblocks = mworkspace . getrootblocks ( ) ; connectionmanager connmanager = mworkspace . getconnectionmanager ( ) ; for ( int i = _num ; i < rootblocks . size ( ) ; i ++ ) { blockgroup bg = mviewfactory . buildblockgrouptree ( rootblocks . get ( i ) , connmanager , mtouchhandler ) ; mworkspaceview . addview ( bg ) ; } } }	recursively initialize views for all the blocks in the model and add them to the view .
protected void clearalltrails ( ssotokenid tokenid ) { boolean removed = _bool ; string key = tokenid . tostring ( ) ; synchronized ( maptokenids ) { removed = ( maptokenids . remove ( key ) != null ) ; } }	clears all registered page trails of a given single sign on token id.
public dnetscapecarevocationurl ( jdialog parent , byte [ ] value ) throws ioexception { super ( parent ) ; settitle ( res . getstring ( _str ) ) ; initcomponents ( ) ; prepopulatewithvalue ( value ) ; }	creates a new dnetscapecarevocationurl dialog .
public static int [ ] parsenumberlist ( string liststr , int minval , int maxval , boolean allowzero ) { int [ ] values ; if ( liststr . indexof ( _str ) < _num ) { values = new int [ _num ] ; values [ _num ] = parseintrange ( liststr , minval , maxval , allowzero ) ; } else { string [ ] valuestrs = liststr . split ( _str ) ; int len = valuestrs . length ; values = new int [ len ] ; for ( int i = _num ; i < len ; i ++ ) { values [ i ] = parseintrange ( valuestrs [ i ] , minval , maxval , allowzero ) ; } } return values ; }	parses a comma - separated list of integers , with range - checking .
public directoryorfilenotfoundexception ( string entity , string name ) { super ( string . format ( _errormessage , entity , name ) ) ; }	constructs a new exception with detailed error message .
void scramble ( ) { initialsize = getsize ( ) ; int a [ ] = new int [ initialsize . height / _num ] ; double f = initialsize . width / ( double ) a . length ; for ( int i = a . length ; -- i >= _num ; ) { a [ i ] = ( int ) ( i * f ) ; } for ( int i = a . length ; -- i >= _num ; ) { int j = ( int ) ( i * math . random ( ) ) ; int t = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = t ; } arr = a ; }	fill the array with random numbers from 0.
public static sipheader parsesipheader ( string header ) throws parseexception { int start = _num ; int end = header . length ( ) - _num ; try { while ( header . charat ( start ) <= _num ) start ++ ; while ( header . charat ( end ) <= _num ) end -- ; } catch ( arrayindexoutofboundsexception e ) { throw new parseexception ( _str , _num ) ; } stringbuilder buffer = new stringbuilder ( end + _num ) ; int i = start ; int linestart = start ; boolean endofline = _bool ; while ( i <= end ) { char c = header . charat ( i ) ; if ( c == _str || c == _str ) { if ( ! endofline ) { buffer . append ( header . substring ( linestart , i ) ) ; endofline = _bool ; } } else { if ( endofline ) { endofline = _bool ; if ( c == _str || c == _str ) { buffer . append ( _str ) ; linestart = i + _num ; } else { linestart = i ; } } } i ++ ; } buffer . append ( header . substring ( linestart , i ) ) ; buffer . append ( _str ) ; headerparser hp = parserfactory . createparser ( buffer . tostring ( ) ) ; if ( hp == null ) throw new parseexception ( _str , _num ) ; return hp . parse ( ) ; }	parse an individual sip message header from a string .
private static int convertsrgbtolinearrgb ( int color ) { float input , output ; input = color / _num ; if ( input <= _num ) { output = input / _num ; } else { output = ( float ) math . pow ( ( input + _num ) / _num , _num ) ; } return math . round ( output * _num ) ; }	helper function to convert a color component in srgb space to linear rgb space.
public void recordbeginning ( ) { final string msg = _str + mmodulename + _str + mrunid ; musagemessages . add ( msg ) ; diagnostic . developerlog ( msg ) ; mclient . recordbeginning ( mmodulename , mrunid ) ; }	records a start usage logging message to whichever logging endpoint is configured.
static float rotatey ( float px , float py , float cx , float cy , float angleindegrees ) { double angle = math . toradians ( angleindegrees ) ; return ( float ) ( math . sin ( angle ) * ( px - cx ) + math . cos ( angle ) * ( py - cy ) + cy ) ; }	rotate point p around center point c .
public boolean ispronounceable ( string word ) { string lowercaseword = word . tolowercase ( ) ; return ( prefixfsm . accept ( lowercaseword ) && suffixfsm . accept ( lowercaseword ) ) ; }	returns true if the given word is pronounceable.
public void addsplitedges ( list edgelist ) { addendpoints ( ) ; iterator it = iterator ( ) ; edgeintersection eiprev = ( edgeintersection ) it . next ( ) ; while ( it . hasnext ( ) ) { edgeintersection ei = ( edgeintersection ) it . next ( ) ; edge newedge = createsplitedge ( eiprev , ei ) ; edgelist . add ( newedge ) ; eiprev = ei ; } }	creates new edges for all the edges that the intersections in this list split the parent edge into.
public ioutils ( ) { super ( ) ; }	instances should not be constructed in standard programming .
public membasedcache ( int maxcachesizeinbytes ) { mmaxcachesizeinbytes = maxcachesizeinbytes ; mdataentries = new linkedhashmap < string , cacheheader > ( _num , _num , _bool ) ; }	constructs an instance of the membasedcache .
public void updatemaxtextwidths ( float requiredwidth , float matchcontentswidth ) { mmaxrequiredwidth = math . max ( mmaxrequiredwidth , requiredwidth ) ; mmaxmatchcontentswidth = math . max ( mmaxmatchcontentswidth , matchcontentswidth ) ; }	updates the max text width values for the suggestions .
public void enableoverview ( boolean b ) { if ( overviewitem != null ) { overviewitem . setenabled ( b ) ; } }	enable / disable the overview menu .
public void mouseentered ( mouseevent e ) { if ( debug . debugging ( _str ) ) { debug . output ( getid ( ) + _str ) ; } super . mouseentered ( e ) ; autozoom = _bool ; }	handle a mouseentered mouselistener event.
public pageofcollections fetchpage ( pageofcollections page , solrzkclient zkclient ) throws keeperexception , interruptedexception { list < string > children = getcollections ( zkclient ) ; page . selected = children ; if ( page . start == _num && page . rows == - _num && page . filter == null && children . size ( ) > _num ) { page . rows = _num ; page . start = _num ; } if ( page . filtertype == filtertype . name && page . filter != null ) children = page . applynamefilter ( children ) ; if ( page . filtertype != filtertype . status ) page . selectpage ( children ) ; return page ; }	gets the requested page of collections after applying filters and offsets .
public void accept ( final annotationvisitor av ) { if ( av != null ) { if ( values != null ) { for ( int i = _num ; i < values . size ( ) ; i += _num ) { string name = ( string ) values . get ( i ) ; object value = values . get ( i + _num ) ; accept ( av , name , value ) ; } } av . visitend ( ) ; } }	makes the given visitor visit this annotation .
public idsquerybuilder addids ( string ... ids ) { values . addall ( arrays . aslist ( ids ) ) ; return this ; }	adds ids to the filter .
private void stop ( httpservletrequest request , httpservletresponse response ) throws ioexception { printwriter out = response . getwriter ( ) ; string label = request . getparameter ( _str ) ; monitor mon = removemon ( label , null , default_units ) ; if ( mon == null ) { out . println ( error + _str ) ; } else { mon . stop ( ) ; out . println ( ok + _str + mon ) ; } }	stop a previously started monitor if it exists .
public static string normalizeurl ( string requesturl ) throws oauthexception { if ( ( requesturl == null ) || ( requesturl . length ( ) == _num ) ) { throw new oauthexception ( _str ) ; } uri uri ; try { uri = new uri ( requesturl ) ; } catch ( urisyntaxexception e ) { throw new oauthexception ( e ) ; } string authority = uri . getauthority ( ) ; string scheme = uri . getscheme ( ) ; if ( authority == null || scheme == null ) { throw new oauthexception ( _str ) ; } authority = authority . tolowercase ( ) ; scheme = scheme . tolowercase ( ) ; if ( ( scheme . equals ( _str ) && uri . getport ( ) == _num ) || ( scheme . equals ( _str ) && uri . getport ( ) == _num ) ) { int index = authority . lastindexof ( _str ) ; if ( index >= _num ) { authority = authority . substring ( _num , index ) ; } } return scheme + _str + authority + uri . getrawpath ( ) ; }	calculates the normalized request url , as per section 9.
public void invoke ( inputstream is , outputstream os , serializerfactory serializerfactory ) throws exception { boolean isdebug = _bool ; if ( isdebuginvoke ( ) ) { isdebug = _bool ; printwriter dbg = createdebugprintwriter ( ) ; hessiandebuginputstream dis = new hessiandebuginputstream ( is , dbg ) ; dis . starttop2 ( ) ; is = dis ; hessiandebugoutputstream dos = new hessiandebugoutputstream ( os , dbg ) ; dos . starttop2 ( ) ; os = dos ; } hessianinputfactory . headertype header = _inputfactory . readheader ( is ) ; abstracthessianinput in ; abstracthessianoutput out ; switch ( header ) { case call_1_reply_1 : in = _hessianfactory . createhessianinput ( is ) ; out = _hessianfactory . createhessianoutput ( os ) ; break ; case call_1_reply_2 : in = _hessianfactory . createhessianinput ( is ) ; out = _hessianfactory . createhessian2output ( os ) ; break ; case hessian_2 : in = _hessianfactory . createhessian2input ( is ) ; in . readcall ( ) ; out = _hessianfactory . createhessian2output ( os ) ; break ; default : throw new illegalstateexception ( header + _str ) ; } if ( serializerfactory != null ) { in . setserializerfactory ( serializerfactory ) ; out . setserializerfactory ( serializerfactory ) ; } try { invoke ( _service , in , out ) ; } finally { in . close ( ) ; out . close ( ) ; if ( isdebug ) os . close ( ) ; } }	invoke the object with the request from the input stream .
private void commitlocaltransaction ( ) throws commitfailedexception { if ( _tx == null ) { return ; } if ( _logger . isloggable ( level . finest ) ) { _logger . log ( level . finest , _str + _tx ) ; } try { _tx . commit ( ) ; } catch ( exception e ) { if ( _logger . isloggable ( level . severe ) ) { _logger . log ( level . severe , _str + _tx , e ) ; } throw new commitfailedexception ( e ) ; } }	commits the local transaction .
public static entry addobjectclass ( entry entry ) { attribute attribute = entry . getattribute ( coretokenconstants . object_class ) ; if ( attribute == null ) { entry . addattribute ( coretokenconstants . object_class , coretokenconstants . fr_core_token ) ; } return entry ; }	only adds the objectclass if it hasn ' t already been added .
@ suppresswarnings ( _str ) public list < boundary > populatearea ( final long wardid ) { hierarchytype htype = heirarchytypeservice . gethierarchytypebyname ( hierarchytypename ) ; ; list < boundary > arealist = new linkedlist < boundary > ( ) ; final boundarytype childboundarytype = boundarytypeservice . getboundarytypebynameandhierarchytype ( _str , htype ) ; final boundary parentboundary = boundaryservice . getboundarybyid ( wardid ) ; arealist = new linkedlist ( crossheirarchyservice . getcrosshierarchychildrens ( parentboundary , childboundarytype ) ) ; logger . info ( _str + arealist . tostring ( ) ) ; return arealist ; }	populate the area list by ward.
private static string readname ( datainputstream dis , byte data [ ] ) throws ioexception { int c = dis . readunsignedbyte ( ) ; if ( ( c & _num ) == _num ) { c = ( ( c & _num ) << _num ) + dis . readunsignedbyte ( ) ; hashset < integer > jumps = new hashset < integer > ( ) ; jumps . add ( c ) ; return readname ( data , c , jumps ) ; } if ( c == _num ) { return _str ; } byte b [ ] = new byte [ c ] ; dis . readfully ( b ) ; string s = idn . tounicode ( new string ( b ) ) ; string t = readname ( dis , data ) ; if ( t . length ( ) > _num ) { s = s + _str + t ; } return s ; }	parse a domain name starting at the current offset and moving the input stream pointer past this domain name ( even if cross references occure ) .
public simplestring concat ( final char c ) { byte [ ] bytes = new byte [ data . length + _num ] ; system . arraycopy ( data , _num , bytes , _num , data . length ) ; bytes [ data . length ] = ( byte ) ( c & _num ) ; bytes [ data . length + _num ] = ( byte ) ( c > > _num & _num ) ; return new simplestring ( bytes ) ; }	concatenates a simplestring and a char.
public static double probtologodds ( double prob ) { if ( gr ( prob , _num ) || ( sm ( prob , _num ) ) ) { throw new illegalargumentexception ( _str + _str + prob ) ; } double p = small + ( _num - _num * small ) * prob ; return math . log ( p / ( _num - p ) ) ; }	returns the log - odds for a given probabilitiy .
private void signalnotempty ( ) { final reentrantlock takelock = this . takelock ; takelock . lock ( ) ; try { notempty . signal ( ) ; } finally { takelock . unlock ( ) ; } }	signals a waiting take.
public void deepfill ( marynode spectree ) { tree = spectree ; numberofleaves = _num ; sortnode ( _num , tree ) ; }	fill a tree which specifies a feature hierarchy but no corresponding units .
public int nodecount ( ) { return nodes == null ? _num : nodes . size ( ) ; }	return the number of nodes in the is way.
public void addtoglobalblacklist ( string host ) { addtoglobalblacklist ( host , system . currenttimemillis ( ) + this . globalblacklisttimeout ) ; }	adds a host to the blacklist .
public boolean addnode ( lop node ) { if ( nodes . contains ( node ) ) return _bool ; nodes . add ( node ) ; return _bool ; }	method to add a node to the dag .
private void writeobject ( java . io . objectoutputstream s ) throws java . io . ioexception { s . defaultwriteobject ( ) ; for ( node < k , v > n = findfirst ( ) ; n != null ; n = n . next ) { v v = n . getvalidvalue ( ) ; if ( v != null ) { s . writeobject ( n . key ) ; s . writeobject ( v ) ; } } s . writeobject ( null ) ; }	saves this map to a stream ( that is , serializes it ) .
public static final double sigma ( double a ) { return _num / ( _num + math . exp ( - a ) ) ; }	sigmoid / logistic function.
public void insertorrefresh ( final kbucketentry newentry ) { if ( newentry == null ) return ; list < kbucketentry > entriesref = entries ; for ( kbucketentry existing : entriesref ) { if ( existing . equals ( newentry ) ) { existing . mergeintimestamps ( newentry ) ; return ; } if ( existing . matchiporid ( newentry ) ) { dht . loginfo ( _str + newentry + _str + existing + _str ) ; return ; } } if ( newentry . verifiedreachable ( ) ) { if ( entriesref . size ( ) < dhtconstants . max_entries_per_bucket ) { modifymainbucket ( null , newentry ) ; return ; } if ( replacebadentry ( newentry ) ) return ; kbucketentry youngest = entriesref . get ( entriesref . size ( ) - _num ) ; if ( youngest . getcreationtime ( ) > newentry . getcreationtime ( ) || newentry . getrtt ( ) * _num < youngest . getrtt ( ) ) { modifymainbucket ( youngest , newentry ) ; insertinreplacementbucket ( youngest ) ; return ; } } insertinreplacementbucket ( newentry ) ; }	notify bucket of new incoming packet from a node , perform update or insert existing nodes where appropriate.
public void translate ( double x , double y ) { currenttransform . translate ( x , y ) ; try { writetransform ( new affinetransform ( _num , _num , _num , _num , x , y ) ) ; } catch ( ioexception e ) { handleexception ( e ) ; } }	translates the current transform . calls writetransform ( transform ).
private void writeobject ( objectoutputstream oos ) throws ioexception { oos . defaultwriteobject ( ) ; boolean writefont = ( f != omtext . default_font ) ; oos . writeboolean ( writefont ) ; if ( writefont ) { oos . writeobject ( f . getname ( ) ) ; oos . writeint ( f . getsize ( ) ) ; oos . writeint ( f . getstyle ( ) ) ; } writestroke ( oos , stroke , omgraphic . basic_stroke ) ; writestroke ( oos , textmattestroke , default_text_matte_stroke ) ; }	write this object to a stream .
private static void writespaces ( writer out , int amt ) throws ioexception { while ( amt > _num ) { out . write ( _str ) ; amt -- ; } }	writes the given number of spaces to the given writer .
public static double relativeoverlap ( spatialcomparable box1 , spatialcomparable box2 ) { final int dim = assertsamedimensionality ( box1 , box2 ) ; double overlap = _num ; double vol1 = _num ; double vol2 = _num ; for ( int i = _num ; i < dim ; i ++ ) { final double box1min = box1 . getmin ( i ) ; final double box1max = box1 . getmax ( i ) ; final double box2min = box2 . getmin ( i ) ; final double box2max = box2 . getmax ( i ) ; final double omax = math . min ( box1max , box2max ) ; final double omin = math . max ( box1min , box2min ) ; if ( omax <= omin ) { return _num ; } overlap *= omax - omin ; vol1 *= box1max - box1min ; vol2 *= box2max - box2min ; } return overlap / ( vol1 + vol2 ) ; }	computes the volume of the overlapping box between two spatialcomparables and return the relation between the volume of the overlapping box and the volume of both spatialcomparable .
protected void handleautodraw ( ) { if ( istoolitemselected ( toolbaritemkey . auto_draw ) ) { onautodraw ( ) ; } }	if auto draw is enabled , a draw request is sent.
protected final void _loadtohaveatleast ( int minavailable ) throws ioexception { if ( _inputstream == null ) { throw _constructerror ( _str + minavailable + _str ) ; } int amount = _inputend - _inputptr ; _currinputprocessed += _inputptr ; if ( amount > _num && _inputptr > _num ) { system . arraycopy ( _inputbuffer , _inputptr , _inputbuffer , _num , amount ) ; _inputend = amount ; } else { _inputend = _num ; } _inputptr = _num ; while ( _inputend < minavailable ) { int count = _inputstream . read ( _inputbuffer , _inputend , _inputbuffer . length - _inputend ) ; if ( count < _num ) { _closeinput ( ) ; if ( count == _num ) { throw new ioexception ( _str + amount + _str ) ; } throw _constructerror ( _str + minavailable + _str + minavailable + _str ) ; } _inputend += count ; } }	helper method that will try to load at least specified number bytes in input buffer , possible moving existing data around if necessary.
public z21message ( byte [ ] a , int l ) { super ( string . valueof ( a ) ) ; setbinary ( _bool ) ; }	this ctor interprets the byte array as a sequence of characters to send .
private methoddescriptor [ ] sortmethoddescriptors ( methoddescriptor [ ] methoddescriptors ) { return methodsorter != null ? methodsorter . sortmethoddescriptors ( methoddescriptors ) : methoddescriptors ; }	as of this writing , this is only used for testing if method order really doesn ' t mater .
public static properties parsepropertylist ( string list ) throws propertystringformatexception { return parsepropertylist ( list , propertyseparators , keyvalueseparators ) ; }	take a property list , defined in a single string , and return a properties object.
public boolean packagehasannotation ( annotation annotation ) { try { package pkg = type . getpackage ( ) ; if ( pkg == null ) { return _bool ; } string classname = pkg . getname ( ) + _str ; class < ? > packagetype = class . forname ( classname ) ; annotationaccessor accessor = new annotationaccessor ( supportedannotations , packagetype , ignoreannotationfailure ) ; return accessor . typehas ( annotation ) ; } catch ( classnotfoundexception e ) { return _bool ; } }	determines whether the package in which t resides has a particular annotation .
private string buildtooltip ( final ctaggedgraphnodescontainernode node ) { final stringbuilder tooltip = new stringbuilder ( _str ) ; boolean first = _bool ; for ( final navinode graphnode : node . getgraphnodes ( ) ) { if ( ! first ) { tooltip . append ( _str ) ; } tooltip . append ( cnodesdisplaystring . getdisplaystring ( graphnode ) ) ; first = _bool ; } return tooltip + _str ; }	generates the tooltip shown when the cursor hovers over a tag tree node that represents a container of graph nodes .
public boolean removeonitemclicklistener ( onitemclicklistener itemclicklistener ) { return clicklisteners . remove ( itemclicklistener ) ; }	remove item click listener from this view.
@ override protected int lookforselectableposition ( int position , boolean lookdown ) { final listadapter adapter = madapter ; if ( adapter == null || isintouchmode ( ) ) { return invalid_position ; } final int count = adapter . getcount ( ) ; if ( ! mareallitemsselectable ) { if ( lookdown ) { position = math . max ( _num , position ) ; while ( position < count && ! adapter . isenabled ( position ) ) { position ++ ; } } else { position = math . min ( position , count - _num ) ; while ( position >= _num && ! adapter . isenabled ( position ) ) { position -- ; } } if ( position < _num || position >= count ) { return invalid_position ; } return position ; } else { if ( position < _num || position >= count ) { return invalid_position ; } return position ; } }	find a position that can be selected ( i.
public static string padright ( final string s , final int length ) { final int pad = length - s . length ( ) ; return pad > _num ? s + getspacestring ( pad ) : s ; }	pad a string on the right with spaces till it is at least the specified length .
private static string [ ] collationmatchingrulenames ( final list < string > localenames , final int numsuffix , final string symbolicsuffix ) { final list < string > names = new arraylist < > ( ) ; for ( string localename : localenames ) { if ( symbolicsuffix . isempty ( ) ) { names . add ( localename ) ; } else { names . add ( localename + _str + numsuffix ) ; names . add ( localename + _str + symbolicsuffix ) ; } } return names . toarray ( new string [ names . size ( ) ] ) ; }	build the complete list of names for a collation matching rule .
public static boolean iscachesafe ( class < ? > clazz , classloader classloader ) { assert . notnull ( clazz , _str ) ; classloader target = clazz . getclassloader ( ) ; if ( target == null ) { return _bool ; } classloader cur = classloader ; if ( cur == target ) { return _bool ; } while ( cur != null ) { cur = cur . getparent ( ) ; if ( cur == target ) { return _bool ; } } return _bool ; }	check whether the given class is cache - safe in the given context , i.
public void write ( printstream out ) { write ( out , table ) ; }	writes the algorithm ' s internal representation as text .
static part from ( string encoded , string decoded ) { if ( encoded == null ) { return null ; } if ( encoded . length ( ) == _num ) { return empty ; } if ( decoded == null ) { return null ; } if ( decoded . length ( ) == _num ) { return empty ; } return new part ( encoded , decoded ) ; }	creates a part from the encoded and decoded strings .
private int [ ] createepochmonths ( int epochday , int minyear , int maxyear , map < integer , int [ ] > years ) { int nummonths = ( maxyear - minyear + _num ) * _num + _num ; int epochmonth = _num ; int [ ] epochmonths = new int [ nummonths ] ; minmonthlength = integer . max_value ; maxmonthlength = integer . min_value ; for ( int year = minyear ; year <= maxyear ; year ++ ) { int [ ] months = years . get ( year ) ; for ( int month = _num ; month < _num ; month ++ ) { int length = months [ month ] ; epochmonths [ epochmonth ++ ] = epochday ; if ( length < _num || length > _num ) { throw new illegalargumentexception ( _str + minyear ) ; } epochday += length ; minmonthlength = math . min ( minmonthlength , length ) ; maxmonthlength = math . max ( maxmonthlength , length ) ; } } epochmonths [ epochmonth ++ ] = epochday ; if ( epochmonth != epochmonths . length ) { throw new illegalstateexception ( _str + epochmonth + _str + epochmonths . length ) ; } return epochmonths ; }	converts the map of year to month lengths ranging from minyear to maxyear into a linear contiguous array of epochdays.
private static string descriptortointernalname ( string descriptor ) { switch ( descriptor . charat ( _num ) ) { case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : return descriptor ; case _str : return classdescriptortointernalname ( descriptor ) ; default : throw new illegalargumentexception ( _str + descriptor ) ; } }	convert a non - method type descriptor into an internal type .
public subscription register ( object mbean , mbeandescription description ) { return register ( mbean , description . getmbeanname ( getnextid ( ) ) ) ; }	register the given mbean based on the given description.
void checkafterunmarshalled ( ) { assertequals ( shortval . shortvalue ( ) , _num ) ; assertequals ( longval , _num ) ; assertnull ( aarr ) ; assertnull ( strval ) ; assertequals ( doubleval , _num ) ; }	checks correctness of the state after unmarshalling .
public void put ( int key , e value ) { int i = containerhelpers . binarysearch ( mkeys , msize , key ) ; if ( i >= _num ) { mvalues [ i ] = value ; } else { i = ~ i ; if ( i < msize && mvalues [ i ] == deleted ) { mkeys [ i ] = key ; mvalues [ i ] = value ; return ; } if ( mgarbage && msize >= mkeys . length ) { gc ( ) ; i = ~ containerhelpers . binarysearch ( mkeys , msize , key ) ; } if ( msize >= mkeys . length ) { int n = containerhelpers . idealintarraysize ( msize + _num ) ; int [ ] nkeys = new int [ n ] ; object [ ] nvalues = new object [ n ] ; system . arraycopy ( mkeys , _num , nkeys , _num , mkeys . length ) ; system . arraycopy ( mvalues , _num , nvalues , _num , mvalues . length ) ; mkeys = nkeys ; mvalues = nvalues ; } if ( msize - i != _num ) { system . arraycopy ( mkeys , i , mkeys , i + _num , msize - i ) ; system . arraycopy ( mvalues , i , mvalues , i + _num , msize - i ) ; } mkeys [ i ] = key ; mvalues [ i ] = value ; msize ++ ; } }	adds a mapping from the specified key to the specified value , replacing the previous mapping from the specified key if there was one .
@ override public < r > completablefuture < r > collect ( final supplier < r > supplier , final biconsumer < r , ? super t > accumulator , final biconsumer < r , r > combiner ) { return completablefuture . supplyasync ( null , exec ) ; }	asynchronously perform a stream collection.
@ suppresswarnings ( _str ) protected object fromreflectiontype ( final object value ) { fielddescriptor descriptor = getdescriptor ( ) ; if ( descriptor . isrepeated ( ) ) { if ( descriptor . getjavatype ( ) == fielddescriptor . javatype . message || descriptor . getjavatype ( ) == fielddescriptor . javatype . enum ) { final list result = new arraylist ( ) ; for ( final object element : ( list ) value ) { result . add ( singularfromreflectiontype ( element ) ) ; } return result ; } else { return value ; } } else { return singularfromreflectiontype ( value ) ; } }	convert from the type used by the reflection accessors to the type used by native accessors.
public void registermanufacturerspecificbuilder ( int companyid , admanufacturerspecificbuilder builder ) { if ( companyid < _num || _num < companyid ) { string message = string . format ( _str , companyid ) ; throw new illegalargumentexception ( message ) ; } if ( builder == null ) { return ; } integer key = integer . valueof ( companyid ) ; list < admanufacturerspecificbuilder > builders = mmsbuilders . get ( key ) ; if ( builders == null ) { builders = new arraylist < admanufacturerspecificbuilder > ( ) ; mmsbuilders . put ( key , builders ) ; } builders . add ( _num , builder ) ; }	register a builder for the company id.
public static reilgraph copyreilcode ( final window parent , final inavicodenode node ) { final reiltranslator < inaviinstruction > translator = new reiltranslator < inaviinstruction > ( ) ; try { return translator . translate ( new standardenvironment ( ) , node ) ; } catch ( final internaltranslationexception e ) { cutilityfunctions . logexception ( e ) ; final string message = _str + _str ; final string description = cutilityfunctions . createdescription ( string . format ( _str , node . getaddress ( ) ) , new string [ ] { _str } , new string [ ] { _str + _str } ) ; navierrordialog . show ( parent , message , description , e ) ; } return null ; }	copy reil code for node.
private static void applyoverrides ( ) { inputstream stream = getcontenttypespropertiesstream ( ) ; if ( stream == null ) { return ; } try { try { properties overrides = new properties ( ) ; overrides . load ( stream ) ; for ( map . entry < object , object > entry : overrides . entryset ( ) ) { string extension = ( string ) entry . getkey ( ) ; string mimetype = ( string ) entry . getvalue ( ) ; add ( mimetype , extension ) ; } } finally { stream . close ( ) ; } } catch ( ioexception ignored ) { } }	this isn ' t what the ri does.
public static string tostring ( reader reader , long timeout ) throws ioexception { stringwriter sw = new stringwriter ( _num ) ; copy ( tobufferedreader ( reader ) , sw , timeout ) ; sw . close ( ) ; return sw . tostring ( ) ; }	reads string data from a reader.
private static float computesimilarity ( lane a , lane b ) { int same = _num ; int diff = _num ; int firstcoordinate = math . max ( a . getfirstnongapposition ( ) , b . getfirstnongapposition ( ) ) ; int lastcoordinate = math . min ( a . getlastnongapposition ( ) , b . getlastnongapposition ( ) ) ; for ( int i = firstcoordinate ; i <= lastcoordinate ; i ++ ) { char cha = a . charat ( i ) ; char chb = b . charat ( i ) ; if ( character . isletter ( cha ) && character . isletter ( chb ) ) { if ( character . tolowercase ( cha ) == character . tolowercase ( ( chb ) ) ) same ++ ; else diff ++ ; } } return math . max ( same > _num ? _num : _num , same - _num * diff ) ; }	computes the similarity of two sequences.
private void forceoverflow ( ) { forceoverflow ( ) ; }	gratuitous and stupid recursion.
public int find ( string string ) { if ( string == null ) { return - _num ; } for ( int i = _num ; i != m_stringoffsets . length ; ++ i ) { int offset = m_stringoffsets [ i ] ; int length = getshort ( m_strings , offset ) ; if ( length != string . length ( ) ) { continue ; } int j = _num ; for ( ; j != length ; ++ j ) { offset += _num ; if ( string . charat ( j ) != getshort ( m_strings , offset ) ) { break ; } } if ( j == length ) { return i ; } } return - _num ; }	finds index of the string.
public string prepoperand ( string label , datatype dt , valuetype vt , boolean literal ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( label ) ; sb . append ( lop . datatype_prefix ) ; sb . append ( dt ) ; sb . append ( lop . valuetype_prefix ) ; sb . append ( vt ) ; sb . append ( lop . literal_prefix ) ; sb . append ( literal ) ; return sb . tostring ( ) ; }	method to prepare instruction operand with given parameters .
public static list < spacetime > divideconquerbrownianbridge ( multivariatenormaldistribution normal , spacetime start , spacetime end , int depth , int maxtries , spacetimerejector rejector ) { list < spacetime > points = new linkedlist < spacetime > ( ) ; points . add ( start ) ; points . add ( end ) ; stop = _bool ; if ( divideconquerbrownianbridge ( normal , _num , points , depth , maxtries , rejector ) == ( _num << ( depth - _num ) ) ) { return points ; } stop = _bool ; return null ; }	divide and conquer brownian bridge ; not thread - safe ! ! ! ! !.
public static ejbjarxmlversion valueof ( documenttype doctype ) throws nullpointerexception { return valueof ( doctype . getpublicid ( ) ) ; }	returns the version corresponding to the given document type .
public static list < double > mergecoords ( list < double > x , list < double > y ) { if ( x . size ( ) != y . size ( ) ) throw new illegalargumentexception ( _str ) ; list < double > ret = new arraylist < > ( ) ; for ( int i = _num ; i < x . size ( ) ; i ++ ) { ret . add ( x . get ( i ) ) ; ret . add ( y . get ( i ) ) ; } return ret ; }	this will merge the coordinates of the given coordinate system .
public static void print ( int x ) { out . print ( x ) ; out . flush ( ) ; }	prints an integer to standard output and flushes standard output .
public void copytext ( ) { int end , start ; end = selectedcharfield . getselectionend ( ) ; start = selectedcharfield . getselectionstart ( ) ; selectedcharfield . selectall ( ) ; selectedcharfield . copy ( ) ; selectedcharfield . select ( start , end ) ; }	copy text . copy all sample text to the system clipboard . remember the current caret position ( selection ) and restore that afterwards .
public void handlebutton1request ( requestinvocationevent event ) throws modelcontrolexception { try { authpropertiesmodel model = ( authpropertiesmodel ) getmodel ( ) ; map original = model . getvalues ( ) ; ampropertysheet ps = ( ampropertysheet ) getchild ( property_attribute ) ; model . setvalues ( ps . getattributevalues ( original , _bool , model ) ) ; setinlinealertmessage ( ccalert . type_info , _str , _str ) ; } catch ( amconsoleexception a ) { setinlinealertmessage ( ccalert . type_error , _str , a . getmessage ( ) ) ; } forwardto ( ) ; }	handles save button request .
private void builddescriptionpanel ( final composite parent ) { descriptionlabel = new styledtext ( parent , swt . read_only ) ; descriptionlabel . settext ( _str ) ; descriptionlabel . setlayoutdata ( new griddata ( griddata . fill , griddata . fill , _bool , _bool , _num , _num ) ) ; }	build the description panel.
public httpmethodclient ( ) { this ( _num , _num , _num * _num ) ; }	creates a new http method client with default timeouts .
public iso9796d2psssigner ( asymmetricblockcipher cipher , digest digest , int saltlength , boolean implicit ) { this . cipher = cipher ; this . digest = digest ; this . hlen = digest . getdigestsize ( ) ; this . saltlength = saltlength ; if ( implicit ) { trailer = trailer_implicit ; } else { integer trailerobj = ( integer ) trailermap . get ( digest . getalgorithmname ( ) ) ; if ( trailerobj != null ) { trailer = trailerobj . intvalue ( ) ; } else { throw new illegalargumentexception ( _str ) ; } } }	generate a signer for the with either implicit or explicit trailers for iso9796 - 2 , scheme 2 or 3 .
string decodetextvalue ( byte [ ] data ) throws ioexception { boolean iscompressed = ( ( data . length > _num ) && ( data [ _num ] == text_compression_header [ _num ] ) && ( data [ _num ] == text_compression_header [ _num ] ) ) ; if ( iscompressed ) { stringbuilder textbuf = new stringbuilder ( data . length ) ; int datastart = text_compression_header . length ; int dataend = datastart ; boolean incompressedmode = _bool ; while ( dataend < data . length ) { if ( data [ dataend ] == ( byte ) _num ) { decodetextsegment ( data , datastart , dataend , incompressedmode , textbuf ) ; incompressedmode = ! incompressedmode ; ++ dataend ; datastart = dataend ; } else { ++ dataend ; } } decodetextsegment ( data , datastart , dataend , incompressedmode , textbuf ) ; return textbuf . tostring ( ) ; } return decodeuncompressedtext ( data , getcharset ( ) ) ; }	decodes a compressed or uncompressed text value .
private < s , t > set < t > extract ( final collection < s > collection , final extractor < s , t > extractor ) { final set < t > values = new hashset < t > ( collection . size ( ) ) ; for ( final s instance : collection ) { values . add ( extractor . getvalue ( instance ) ) ; } return values ; }	extract a set of a defined type from the passed collection using the given extractor .
public static boolean iszte ( ) { return sbuildmodel . startswith ( _str ) ; }	whether the stack is running on a zte device.
static public string normalizetoencoding ( string origstring_ , charset encoding_ ) { string normstring = origstring_ ; charsetencoder encoder = encoding_ . newencoder ( ) ; if ( ! encoder . canencode ( origstring_ ) ) { final int length = origstring_ . length ( ) ; char [ ] normseq = new char [ ( origstring_ . length ( ) ) ] ; int charnum = _num ; for ( int offset = _num ; offset < length ; ) { pair < character , integer > replacement = normalizecodepoint ( origstring_ , encoding_ , offset ) ; character replacedchar = replacement . getfirst ( ) ; int codepoint = replacement . getsecond ( ) ; if ( null != replacedchar ) { normseq [ charnum ] = replacedchar ; charnum ++ ; } offset += character . charcount ( codepoint ) ; } normstring = new string ( normseq ) ; } return normstring ; }	tries to normalize string to specified encoding.
private fastconcurrentskiplistmap . node < k , v > lonode ( ) { if ( lo == null ) return m . findfirst ( ) ; else if ( loinclusive ) return m . findnear ( lo , m . gt | m . eq ) ; else return m . findnear ( lo , m . gt ) ; }	returns lowest node . this node might not be in range , so most usages need to check bounds.
public int size ( ) { return m_sets . size ( ) ; }	get the number of item sets .
public line3d ( stack < vector3 > points , float thickness , int [ ] colors , boolean createvbos ) { super ( ) ; mpoints = points ; mlinethickness = thickness ; mcolors = colors ; if ( colors != null && colors . length != points . size ( ) ) throw new runtimeexception ( _str ) ; init ( createvbos ) ; }	creates a line primitive with a specified color for each point .
public static byte [ ] asunsignedbytearray ( biginteger value ) { byte [ ] bytes = value . tobytearray ( ) ; if ( bytes [ _num ] == _num ) { byte [ ] tmp = new byte [ bytes . length - _num ] ; system . arraycopy ( bytes , _num , tmp , _num , tmp . length ) ; return tmp ; } return bytes ; }	return the passed in value as an unsigned byte array .
public static float approximatelength ( float controlpoints [ ] [ ] ) { float length = _num ; for ( int i = _num ; i < controlpoints . length - _num ; i ++ ) { float xdif = controlpoints [ i + _num ] [ _num ] - controlpoints [ i ] [ _num ] ; float ydif = controlpoints [ i + _num ] [ _num ] - controlpoints [ i ] [ _num ] ; float zdif = controlpoints [ i + _num ] [ _num ] - controlpoints [ i ] [ _num ] ; length += math . sqrt ( xdif * xdif + ydif * ydif + zdif * zdif ) ; } return length ; }	compute an approximate length of a bezier curve given the control points .
protected int mapdragoperationfrommodifiers ( mouseevent e ) { int mods = e . getmodifiersex ( ) ; int btns = mods & buttonmask ; if ( ! ( btns == inputevent . button1_down_mask || btns == inputevent . button2_down_mask ) ) { return dndconstants . action_none ; } return sundragsourcecontextpeer . convertmodifierstodropaction ( mods , getsourceactions ( ) ) ; }	determine the drop action from the event.
public updateclause addassignment ( expression expression ) { assignments . add ( new assignment ( expression ) ) ; return this ; }	adds a property to set to the clause .
private boolean stepvalue ( ) { while ( _bool ) { if ( iter != null && iter . hasnext ( ) ) { svcs = ( arraylist ) iter . next ( ) ; svcidx = svcs . size ( ) ; return _bool ; } if ( ! stepclass ( ) ) return _bool ; if ( iter == null ) return _bool ; } }	step to the next hashmap value , if any , reset svcs and svcidx , and return false if everything exhausted .
private arraylist < iconmarker > createiconmarkers ( ) { final arraylist < iconmarker > iconmarkers = new arraylist < > ( locations . length ) ; iconmarkers . add ( new iconmarker ( locations [ _num ] , r . drawable . bread , r . drawable . bread_c ) ) ; iconmarkers . add ( new iconmarker ( locations [ _num ] , r . drawable . butcher , r . drawable . butcher_c ) ) ; iconmarkers . add ( new iconmarker ( locations [ _num ] , r . drawable . fruits , r . drawable . fruits_c ) ) ; iconmarkers . add ( new iconmarker ( locations [ _num ] , r . drawable . grocery , r . drawable . grocery_c ) ) ; iconmarkers . add ( new iconmarker ( locations [ _num ] , r . drawable . patisserie , r . drawable . patisserie_c ) ) ; return iconmarkers ; }	icons courtesy of https : / / mapicons.
public void hasnetworkconnection ( networkrequestchecklistener listener ) { if ( hasnetworkconnection ( ) ) { testnetworkrequest ( listener ) ; } else { listener . onnoresponse ( ) ; } }	utility method which checks current network connection state , but will also try to perform test network request , in order to determine if user can actually perform any network operation .
public void assignthreadforsubscriber ( @ nonnull object subscriber ) { looper looper = looper . mylooper ( ) ; if ( looper != null ) { msubscribersdefaultthreads . put ( new identityweakreferencekey < > ( subscriber ) , looper != looper . getmainlooper ( ) ? new handler ( looper ) : muithreadhandler ) ; } else { msubscribersdefaultthreads . remove ( new identityweakreferencekey < > ( subscriber ) ) ; } }	assign current thread to the subscriber object.
private void validatedynamicattribute ( set dynamicset ) throws policyexception { if ( debug . messageenabled ( ) ) { debug . message ( _str + _str + dynamicset ) ; } responseattrnames = new hashset ( ) ; repoattrnames = new hashset ( ) ; responseattrtorepoattr = new hashmap ( ) ; if ( debug . messageenabled ( ) ) { debug . message ( _str + _str + validdynamicattrnames ) ; } set dynamicattrs = ( ( set ) properties . get ( dynamic_attribute ) ) ; if ( debug . messageenabled ( ) ) { debug . message ( _str + _str + dynamicattrs ) ; } iterator dynamicattrsiter = dynamicattrs . iterator ( ) ; while ( dynamicattrsiter . hasnext ( ) ) { string attr = ( string ) dynamicattrsiter . next ( ) ; if ( ! validdynamicattrnames . contains ( attr ) ) { if ( debug . warningenabled ( ) ) { debug . warning ( _str + _str + _str + attr ) ; } continue ; } string [ ] attrnames = parsedynamicattrname ( attr ) ; string responseattrname = attrnames [ _num ] ; string repoattrname = attrnames [ _num ] ; responseattrnames . add ( responseattrname ) ; repoattrnames . add ( repoattrname ) ; addtoresponseattrtorepoattrmap ( responseattrname , repoattrname ) ; if ( debug . messageenabled ( ) ) { debug . message ( _str + _str + _str + responseattrname + _str + repoattrname ) ; } } if ( debug . messageenabled ( ) ) { debug . message ( _str + _str + responseattrtorepoattr ) ; debug . message ( _str + _str ) ; } }	this method validates the dynamic_attribute data for format and caches parsed responseattrnames , repoattrnames strings in the set need to be in " responseattr = repoattr " format else , throws policyexception.
public static boolean typecheck ( class type , object instance ) { return type . isassignablefrom ( instance . getclass ( ) ) || iswrapperinstance ( type , instance ) ; }	check if an object is an instance of a given class , or , if the class is a primitive type , if the object is an instance of the wrapper class for that primitive ( e.
public synchronized void init ( ) { arraylist < warrant > templist = new arraylist < warrant > ( ) ; list < string > systemnamelist = _manager . getsystemnamelist ( ) ; iterator < string > iter = systemnamelist . iterator ( ) ; while ( iter . hasnext ( ) ) { warrant w = _manager . getbysystemname ( iter . next ( ) ) ; if ( ! _warlist . contains ( w ) ) { w . addpropertychangelistener ( this ) ; } else { _warlist . remove ( w ) ; } templist . add ( w ) ; } for ( int i = _num ; i < _warlist . size ( ) ; i ++ ) { warrant w = _warlist . get ( i ) ; if ( ! _warnx . contains ( w ) ) { w . removepropertychangelistener ( this ) ; } } for ( int i = _num ; i < _warnx . size ( ) ; i ++ ) { templist . add ( _warnx . get ( i ) ) ; } _warlist = templist ; }	preserve current listeners so that there is no gap to miss a propertychange.
public void addcommand ( command cmd , int offset ) { menubar . addcommand ( cmd , offset ) ; }	adds a command to the menu bar softkeys or into the menu dialog , this version of add allows us to place a command in an arbitrary location.
public boolean connect ( final string address ) { if ( mbluetoothadapter == null || address == null ) { log . w ( tag , _str ) ; return _bool ; } if ( mbluetoothdeviceaddress != null && address . equals ( mbluetoothdeviceaddress ) && mbluetoothgatt != null ) { log . d ( tag , _str ) ; if ( mbluetoothgatt . connect ( ) ) { mconnectionstate = state_connecting ; return _bool ; } else { return _bool ; } } final bluetoothdevice device = mbluetoothadapter . getremotedevice ( address ) ; if ( device == null ) { log . w ( tag , _str ) ; return _bool ; } mbluetoothgatt = device . connectgatt ( this , _bool , mgattcallback ) ; log . d ( tag , _str ) ; mbluetoothdeviceaddress = address ; mconnectionstate = state_connecting ; return _bool ; }	connects to the gatt server hosted on the bluetooth le device .
private double normaldens ( double x , double mean , double stddev ) { double diff = x - mean ; return ( _num / ( m_normconst * stddev ) ) * math . exp ( - ( diff * diff / ( _num * stddev * stddev ) ) ) ; }	density function of normal distribution .
private static void drawshape ( gl2 gl , shape s ) { pathiterator it = s . getpathiterator ( new affinetransform ( ) , shapeflatness ) ; float [ ] lastmoveto = new float [ _num ] ; float [ ] f = new float [ _num ] ; while ( ! it . isdone ( ) ) { int res = it . currentsegment ( f ) ; switch ( res ) { case pathiterator . seg_close : glpanel . v ( gl , lastmoveto [ _num ] , lastmoveto [ _num ] ) ; break ; case pathiterator . seg_moveto : glpanel . v ( gl , f [ _num ] , f [ _num ] ) ; system . arraycopy ( f , _num , lastmoveto , _num , _num ) ; break ; case pathiterator . seg_lineto : glpanel . v ( gl , f [ _num ] , f [ _num ] ) ; break ; case pathiterator . seg_cubicto : cubiccurve2d c = new cubiccurve2d . float ( lastmoveto [ _num ] , lastmoveto [ _num ] , f [ _num ] , f [ _num ] , f [ _num ] , f [ _num ] , f [ _num ] , f [ _num ] ) ; drawshape ( gl , c ) ; break ; default : throw new error ( _str + _str + res ) ; } it . next ( ) ; } }	draw the given shape on the given opengl object .
@ override protected void teardown ( ) throws namingexception , jmsexception { namingenumeration < binding > iter = context . listbindings ( _str ) ; while ( iter . hasmore ( ) ) { binding binding = iter . next ( ) ; object connfactory = binding . getobject ( ) ; if ( connfactory instanceof activemqconnectionfactory ) { } } }	stops all existing activemqconnectionfactory in context .
protected list < uri > load ( final inputstream in ) throws saxexception , ioexception { saxparser saxparser ; final saxparserfactory factory = saxparserfactory . newinstance ( ) ; try { saxparser = factory . newsaxparser ( ) ; } catch ( final parserconfigurationexception ex ) { throw new saxexception ( ex ) ; } groups = new linkedlist < uri > ( ) ; saxparser . parse ( in , this ) ; return groups ; }	load and returns the list of files .
public final void lazyset ( long newvalue ) { unsafe . putorderedlong ( this , valueoffset , newvalue ) ; }	eventually sets to the given value .
private static list < object > createequalitykey ( node node ) { list < object > values = new arraylist < object > ( ) ; values . add ( node . getnodetype ( ) ) ; values . add ( node . getnodename ( ) ) ; values . add ( node . getlocalname ( ) ) ; values . add ( node . getnamespaceuri ( ) ) ; values . add ( node . getprefix ( ) ) ; values . add ( node . getnodevalue ( ) ) ; for ( node child = node . getfirstchild ( ) ; child != null ; child = child . getnextsibling ( ) ) { values . add ( child ) ; } switch ( node . getnodetype ( ) ) { case document_type_node : documenttypeimpl doctype = ( documenttypeimpl ) node ; values . add ( doctype . getpublicid ( ) ) ; values . add ( doctype . getsystemid ( ) ) ; values . add ( doctype . getinternalsubset ( ) ) ; values . add ( doctype . getentities ( ) ) ; values . add ( doctype . getnotations ( ) ) ; break ; case element_node : element element = ( element ) node ; values . add ( element . getattributes ( ) ) ; break ; } return values ; }	returns a list of objects such that two nodes are equal if their lists are equal.
@ deprecated public static string collection2string ( collection < ? > in , string separator ) { if ( in == null ) { return null ; } return iterator2string ( in . iterator ( ) , separator ) ; }	this concatenates the elements of a collection in a string.
public static byte [ ] decodebase64 ( string base64str ) { return datatypeconverter . parsebase64binary ( base64str ) ; }	decodes a base 64 encoded string into byte array .
protected void removeallpremovedrops ( ) { for ( premoveinfo info : premoves . toarray ( new premoveinfo [ _num ] ) ) { if ( info . ispremovedrop ) { premoves . remove ( info ) ; } } }	removes all of the premove drops from premoves .
public void testclearbitzero ( ) { byte abytes [ ] = { _num } ; int asign = _num ; int number = _num ; byte rbytes [ ] = { _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . clearbit ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	clearbit ( int n ) outside zero.
public void stop ( ) { _throttle . setspeedsetting ( - _num ) ; _throttle . setspeedsetting ( _num ) ; stoplabel . seticon ( stopicon ) ; stoplabel . seticontextgap ( _gap ) ; pack ( ) ; }	perform an emergency stop.
public void encode ( outputstream out ) throws ioexception { deroutputstream tmp = new deroutputstream ( ) ; dnname . encode ( tmp ) ; out . write ( tmp . tobytearray ( ) ) ; }	encode the name in der form to the stream .
public void makedirty ( ) { betachanged = _bool ; newmode = _bool ; precisionchanged = _bool ; regressioninterface . makedirty ( instance ) ; }	forces a complete recalculation of the likelihood next time getlikelihood is called.
private arraylist < e > toarraylist ( ) { arraylist < e > list = new arraylist < e > ( ) ; for ( node < e > p = first ( ) ; p != null ; p = succ ( p ) ) { e item = p . item ; if ( item != null ) list . add ( item ) ; } return list ; }	creates an array list and fills it with elements of this list.
public boolean remove ( httpconnection connection ) { timevalues times = connectiontotimes . remove ( connection ) ; if ( times == null ) { log . warn ( _str ) ; return _bool ; } else { return system . currenttimemillis ( ) <= times . timeexpires ; } }	removes the given connection from the list of connections to be closed when idle.
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
private list < string > split ( string prefix ) { list < string > parts = new arraylist < string > ( ) ; int bracketcount = _num ; boolean inquotes = _bool ; int lastindex = _num ; for ( int i = _num ; i < prefix . length ( ) ; i ++ ) { char c = prefix . charat ( i ) ; if ( c == _str ) { bracketcount ++ ; continue ; } else if ( c == _str ) { inquotes = ! inquotes ; continue ; } else if ( c == _str ) { bracketcount -- ; if ( bracketcount < _num ) { throw new runtimeexception ( _str + prefix ) ; } continue ; } if ( c == _str && ! inquotes && bracketcount == _num ) { parts . add ( prefix . substring ( lastindex , i ) ) ; lastindex = i + _num ; } } if ( lastindex < prefix . length ( ) - _num && ! inquotes && bracketcount == _num ) { parts . add ( prefix . substring ( lastindex ) ) ; } return parts ; }	given some dot separated prefix , split on the colons that are not within quotes , and not within brackets .
public static long lowerhextounsignedlong ( string lowerhex ) { int length = lowerhex . length ( ) ; if ( length < _num || length > _num ) throw isntlowerhexlong ( lowerhex ) ; int i = length > _num ? length - _num : _num ; long result = _num ; for ( ; i < length ; i ++ ) { char c = lowerhex . charat ( i ) ; result <<= _num ; if ( c >= _str && c <= _str ) { result |= c - _str ; } else if ( c >= _str && c <= _str ) { result |= c - _str + _num ; } else { throw isntlowerhexlong ( lowerhex ) ; } } return result ; }	parses a 1 to 32 character lower - hex string with no prefix into an unsigned long , tossing any bits higher than 64 .
public static double sampleskewstandarderror ( int size ) { int n = size ; return math . sqrt ( _num * n * ( n - _num ) / ( ( n - _num ) * ( n + _num ) * ( n + _num ) ) ) ; }	return the standard error of the sample skew.
public void load ( list < policyqualifierinfo > policyqualifierinfo ) { policyqualifierinfo [ ] policyqualifierinfoarray = policyqualifierinfo . toarray ( new policyqualifierinfo [ policyqualifierinfo . size ( ) ] ) ; arrays . sort ( policyqualifierinfoarray , new policyqualifierinfocomparator ( ) ) ; data = new object [ policyqualifierinfoarray . length ] [ _num ] ; int i = _num ; for ( policyqualifierinfo policyqualinfo : policyqualifierinfoarray ) { data [ i ] [ _num ] = policyqualinfo ; i ++ ; } firetabledatachanged ( ) ; }	load the policyqualifierinfotablemodel with policy qualifier info .
public void runscript ( reader reader ) throws ioexception , sqlexception { try { boolean originalautocommit = connection . getautocommit ( ) ; try { if ( originalautocommit != this . autocommit ) { connection . setautocommit ( this . autocommit ) ; } runscript ( connection , reader ) ; } finally { connection . setautocommit ( originalautocommit ) ; } } catch ( ioexception | sqlexception e ) { throw e ; } catch ( exception e ) { throw new runtimeexception ( _str + e , e ) ; } }	runs an sql script ( read in using the reader parameter ).
markersegment findmarkersegment ( class cls , boolean first ) { if ( first ) { iterator iter = markersequence . iterator ( ) ; while ( iter . hasnext ( ) ) { markersegment seg = ( markersegment ) iter . next ( ) ; if ( cls . isinstance ( seg ) ) { return seg ; } } } else { listiterator iter = markersequence . listiterator ( markersequence . size ( ) ) ; while ( iter . hasprevious ( ) ) { markersegment seg = ( markersegment ) iter . previous ( ) ; if ( cls . isinstance ( seg ) ) { return seg ; } } } return null ; }	returns the first or last markersegment object in the list of the given class , or null if none is found .
default filterable < t > removeall ( final t ... values ) { return removeall ( stream . of ( values ) ) ; }	remove all supplied elements from this filterable.
public void reset ( boolean clear ) { gotversion = _bool ; gotheaderlength = _bool ; gotheader = _bool ; gotbody = _bool ; gotbodyboundary = _bool ; headerlength = _num ; bodylength = _num ; bodybytesreceived = _num ; if ( clear ) { bufferoffset = _num ; buffer . clear ( ) ; bodyfile = null ; if ( bodystream != null ) { try { bodystream . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } bodystream = null ; } } }	reset the state of the receiver in preparation for a new sessionmessage .
void removeat ( final int removeindex ) { final object [ ] items = this . items ; if ( removeindex == takeindex ) { items [ takeindex ] = null ; takeindex = inc ( takeindex ) ; count -- ; if ( itrs != null ) itrs . elementdequeued ( ) ; } else { final int putindex = this . putindex ; for ( int i = removeindex ; ; ) { int next = inc ( i ) ; if ( next != putindex ) { items [ i ] = items [ next ] ; i = next ; } else { items [ i ] = null ; this . putindex = i ; break ; } } count -- ; if ( itrs != null ) itrs . removedat ( removeindex ) ; } notfull . signal ( ) ; }	deletes item at array index removeindex.
private void saveandclose ( boolean save ) { content . setenabled ( _bool ) ; if ( timer != null ) { timer . cancel ( ) ; timer = null ; } if ( timernextsync != null ) { timernextsync . cancel ( ) ; timernextsync = null ; } if ( save ) { log . d ( log_tag , _str ) ; savedata ( null ) ; } else { log . d ( log_tag , _str ) ; } intent data = new intent ( ) ; data . setaction ( intent . action_view ) ; data . putextra ( param_note , note ) ; data . putextra ( param_note_position , noteposition ) ; setresult ( result_ok , data ) ; finish ( ) ; }	saves all changes and closes the activity.
public static uri addmessage ( contentresolver resolver , string address , string body , string subject , long date , boolean deliveryreport , long threadid ) { final uri content_uri = uri . parse ( _str ) ; return addmessagetouri ( resolver , content_uri , address , body , subject , date , _bool , deliveryreport , threadid ) ; }	add an sms to the out box .
public static < t > void blockingsubscribeprint ( observable < t > observable , string name ) { countdownlatch latch = new countdownlatch ( _num ) ; subscribeprint ( observable . finallydo ( null ) , name ) ; try { latch . await ( ) ; } catch ( interruptedexception e ) { } }	subscribes to an observable , printing all its emissions.
public static final double calcnicenumber ( final double range , final boolean round ) { double nicefraction ; double exponent = math . floor ( math . log10 ( range ) ) ; double fraction = range / math . pow ( _num , exponent ) ; if ( round ) { if ( double . compare ( fraction , _num ) < _num ) { nicefraction = _num ; } else if ( double . compare ( fraction , _num ) < _num ) { nicefraction = _num ; } else if ( double . compare ( fraction , _num ) < _num ) { nicefraction = _num ; } else { nicefraction = _num ; } } else { if ( double . compare ( fraction , _num ) <= _num ) { nicefraction = _num ; } else if ( double . compare ( fraction , _num ) <= _num ) { nicefraction = _num ; } else if ( double . compare ( fraction , _num ) <= _num ) { nicefraction = _num ; } else { nicefraction = _num ; } } return nicefraction * math . pow ( _num , exponent ) ; }	returns a " nicescaling " number approximately equal to the range.
private static final boolean copyheader ( string name , string fromreq , stringbuffer buf ) { int start = fromreq . indexof ( name ) ; if ( start != - _num ) { int end = fromreq . indexof ( _str , start ) ; if ( end != - _num ) { buf . append ( fromreq . subsequence ( start - _num , end ) ) ; return _bool ; } } return _bool ; }	copies a header from a request.
public void sendmetric ( final string name , final double value ) { logger . debug ( string . format ( _str , name , value ) ) ; if ( telemetryclient != null ) { telemetryclient . trackmetric ( name , value ) ; } }	call sendmetric to track the new value of the named metric .
default document putall ( iterable < field > fields , predicate < charsequence > acceptablefieldnames ) { for ( field field : fields ) { if ( acceptablefieldnames . test ( field . getname ( ) ) ) { setvalue ( field . getname ( ) , field . getvalue ( ) ) ; } } return this ; }	attempts to copy all of the acceptable fields from the source and set on this document , overwriting any existing values .
public static url findresourcebase ( string baseresource , classloader loader ) { url url = loader . getresource ( baseresource ) ; return findresourcebase ( url , baseresource ) ; }	find the classpath url for a specific classpath resource.
public string toepl ( epstatementformatter formatter ) { stringwriter writer = new stringwriter ( ) ; toepl ( formatter , writer ) ; return writer . tostring ( ) ; }	rendering using the provided formatter .
public boolean isspecified ( int index ) { if ( ( index < _num ) || ( index >= mlength ) ) { throw new arrayindexoutofboundsexception ( _str ) ; } string str = mitems [ ( index << _num ) + _num ] ; return ( ( str != null ) ? ( str . charat ( _num ) == _str ) : _bool ) ; }	returns true unless the attribute value was provided by dtd defaulting .
public statarchivereader ( string archivename ) throws ioexception { this ( new file [ ] { new file ( archivename ) } , null , _bool ) ; }	creates a statarchivereader that will read the named archive file .
private static void initadbsocketaddr ( ) { try { sadbserverport = getadbserverport ( ) ; inetaddress hostaddr = inetaddress . getbyname ( default_adb_host ) ; ssocketaddr = new inetsocketaddress ( hostaddr , sadbserverport ) ; } catch ( unknownhostexception e ) { } }	instantiates ssocketaddr with the address of the host ' s adb process .
public int read ( long fileoffset , byte [ ] buffer , int offset , int length ) throws ioexception { _file . seek ( fileoffset ) ; return _file . read ( buffer , offset , length ) ; }	reads a block from a given location .
private boolean matchesanytag ( string tagname ) { return tagnames . contains ( tagname ) ; }	tries to match tagname to known tag names .
default void shutdown ( ) { platform . exit ( ) ; }	shuts down the application by delegating service cleanups to the application thread .
public boolean isexpanded ( int row ) { treeui tree = getui ( ) ; if ( tree != null ) { treepath path = tree . getpathforrow ( this , row ) ; if ( path != null ) { boolean value = expandedstate . get ( path ) ; return ( value != null && value . booleanvalue ( ) ) ; } } return _bool ; }	returns true if the node at the specified display row is currently expanded .
private static int labelend ( string s ) { int colonindex = s . indexof ( _str ) ; int semicolonindex = s . indexof ( _str ) ; if ( ( semicolonindex == - _num ) || ( colonindex < semicolonindex ) ) { return colonindex ; } else { return - _num ; } }	determines the position in the string where a label that might be contained ends.
public void addlistener ( animatorlistener listener ) { if ( mlisteners == null ) { mlisteners = new arraylist < animatorlistener > ( ) ; } mlisteners . add ( listener ) ; }	adds a listener to the set of listeners that are sent events through the life of an animation , such as start , repeat , and end .
public httpmethodinfo ( method method , object handler , object [ ] args , multivaluedmap < string , object > formparameters , response responder ) { this . method = method ; this . handler = handler ; this . args = arrays . copyof ( args , args . length ) ; this . formparameters = formparameters ; this . responder = responder ; }	construct httpmethodinfo object for a handler method that does not support streaming .
public static boolean equals ( byte [ ] [ ] field1 , byte [ ] [ ] field2 ) { int index1 = _num ; int length1 = field1 == null ? _num : field1 . length ; int index2 = _num ; int length2 = field2 == null ? _num : field2 . length ; while ( _bool ) { while ( index1 < length1 && field1 [ index1 ] == null ) { index1 ++ ; } while ( index2 < length2 && field2 [ index2 ] == null ) { index2 ++ ; } boolean atendof1 = index1 >= length1 ; boolean atendof2 = index2 >= length2 ; if ( atendof1 && atendof2 ) { return _bool ; } else if ( atendof1 != atendof2 ) { return _bool ; } else if ( ! arrays . equals ( field1 [ index1 ] , field2 [ index2 ] ) ) { return _bool ; } index1 ++ ; index2 ++ ; } }	checks repeated bytes field equality.
private void drawtext ( int x1 , int y1 , int s , boolean e_or_n , graphics g ) { color oldcolor = g . getcolor ( ) ; g . setpaintmode ( ) ; if ( m_fontcolor == null ) { g . setcolor ( color . black ) ; } else { g . setcolor ( m_fontcolor ) ; } string st ; if ( e_or_n ) { edge e = m_edges [ s ] . m_edge ; for ( int noa = _num ; ( st = e . getline ( noa ) ) != null ; noa ++ ) { g . drawstring ( st , ( m_edges [ s ] . m_width - m_fontsize . stringwidth ( st ) ) / _num + x1 , y1 + ( noa + _num ) * m_fontsize . getheight ( ) ) ; } } else { node e = m_nodes [ s ] . m_node ; for ( int noa = _num ; ( st = e . getline ( noa ) ) != null ; noa ++ ) { g . drawstring ( st , ( m_nodes [ s ] . m_width - m_fontsize . stringwidth ( st ) ) / _num + x1 , y1 + ( noa + _num ) * m_fontsize . getheight ( ) ) ; } } g . setcolor ( oldcolor ) ; }	draws the text for either an edge or a node .
public void update ( list < race > races ) { if ( currentrace == null ) { return ; } if ( races . contains ( currentrace ) ) { setrace ( races . get ( races . indexof ( currentrace ) ) ) ; } }	give this list of races , whereas the dialog picks out the one it currently has open ( if present ) .
public boolean required ( ) { return _parametermetadata . contains ( metadata . required ) ; }	indicates whether the parameter is required.
protected void senddatatoreceiver ( resultreceiver receiver , intent originalintent , serializable data ) { if ( receiver != null && data != null ) { bundle bundle = new bundle ( ) ; bundle . putparcelable ( servicereceiver . extra_original_intent , originalintent ) ; bundle . putserializable ( servicereceiver . extra_data , data ) ; receiver . send ( servicereceiver . status_data , bundle ) ; } }	sends data to the receiver , usually the creator of the service intent .
public void print ( printwriter output , int w , int d ) { decimalformat format = new decimalformat ( ) ; format . setdecimalformatsymbols ( new decimalformatsymbols ( locale . us ) ) ; format . setminimumintegerdigits ( _num ) ; format . setmaximumfractiondigits ( d ) ; format . setminimumfractiondigits ( d ) ; format . setgroupingused ( _bool ) ; print ( output , format , w + _num ) ; }	print the matrix to the output stream.
public static < e > set < e > newsetfrommap ( map < e , boolean > map ) { if ( map . isempty ( ) ) { return new setfrommap < e > ( map ) ; } throw new illegalargumentexception ( ) ; }	answers a set backed by a map.
public void removebiometype ( biomedictionary . type type ) { arraylist < biomegenbase > entrylist = new arraylist < biomegenbase > ( ) ; entrylist . addall ( arrays . aslist ( biomedictionary . getbiomesfortype ( type ) ) ) ; for ( biomegenbase biome : entrylist ) { iterator < biomeentry > iterator = allowedbiomes . iterator ( ) ; while ( iterator . hasnext ( ) ) { if ( biomedictionary . arebiomesequivalent ( iterator . next ( ) . biome , biome ) ) iterator . remove ( ) ; } } }	removes all biomes of this type from the list of biomes allowed to generate.
static sizerequirements calculatetiledrequirements ( layoutiterator iter , sizerequirements r ) { long minimum = _num ; long maximum = _num ; long preferred = _num ; int lastmargin = _num ; int totalspacing = _num ; int n = iter . getcount ( ) ; for ( int i = _num ; i < n ; i ++ ) { iter . setindex ( i ) ; int margin0 = lastmargin ; int margin1 = ( int ) iter . getleadingcollapsespan ( ) ; totalspacing += math . max ( margin0 , margin1 ) ; preferred += ( int ) iter . getpreferredspan ( _num ) ; minimum += iter . getminimumspan ( _num ) ; maximum += iter . getmaximumspan ( _num ) ; lastmargin = ( int ) iter . gettrailingcollapsespan ( ) ; } totalspacing += lastmargin ; totalspacing += _num * iter . getborderwidth ( ) ; minimum += totalspacing ; preferred += totalspacing ; maximum += totalspacing ; if ( r == null ) { r = new sizerequirements ( ) ; } r . minimum = ( minimum > integer . max_value ) ? integer . max_value : ( int ) minimum ; r . preferred = ( preferred > integer . max_value ) ? integer . max_value : ( int ) preferred ; r . maximum = ( maximum > integer . max_value ) ? integer . max_value : ( int ) maximum ; return r ; }	calculate the requirements needed to tile the requirements given by the iterator that would be tiled.
public static void writepaddedinteger ( writer out , long value , int size ) throws ioexception { int intvalue = ( int ) value ; if ( intvalue == value ) { writepaddedinteger ( out , intvalue , size ) ; } else if ( size <= _num ) { out . write ( long . tostring ( value ) ) ; } else { if ( value < _num ) { out . write ( _str ) ; if ( value != long . min_value ) { value = - value ; } else { for ( ; size > _num ; size -- ) { out . write ( _str ) ; } out . write ( _str ) ; return ; } } int digits = ( int ) ( math . log ( value ) / log_10 ) + _num ; for ( ; size > digits ; size -- ) { out . write ( _str ) ; } out . write ( long . tostring ( value ) ) ; } }	converts an integer to a string , prepended with a variable amount of ' 0 ' pad characters , and writes it to the given writer.
private static ldapfilter createorfilter ( filterset filterset ) throws ldapexception , ioexception { list < jaxbelement < ? > > list = filterset . getfiltergroup ( ) ; arraylist < rawfilter > filters = new arraylist < > ( list . size ( ) ) ; for ( jaxbelement < ? > filter : list ) { filters . add ( createfilter ( filter ) ) ; } return ldapfilter . createorfilter ( filters ) ; }	returns a new or search filter with the provided filter components .
private void sendblob ( string index , byte [ ] blob ) { sendinstruction ( new guacamoleinstruction ( _str , index , datatypeconverter . printbase64binary ( blob ) ) ) ; }	injects a " blob " instruction into the outbound guacamole protocol stream , as if sent by the connected client.
protected void definelabels ( ) { labelsvalues = calclabels ( ) ; if ( handlevalues ) labels = getlabelsfromvalues ( ) ; else labels = getlabelsfromdata ( ) ; nlabels = labels . size ( ) ; }	defines what will be the axis labels.
public static set < interval > mergeintervaltoset ( set < interval > intervals , interval intervaltomerge ) { linkedhashset < interval > copyoforiginalset = new linkedhashset < > ( intervals ) ; copyoforiginalset . add ( intervaltomerge ) ; return mergeintervalset ( copyoforiginalset ) ; }	merge an interval into the given interval set .
public static string dropwhile ( gstring self , @ closureparams ( value = fromstring . class , conflictresolutionstrategy = pickfirstresolver . class , options = { _str , _str } ) closure condition ) { return dropwhile ( self . tostring ( ) , condition ) ; }	a gstring variant of the equivalent charsequence method .
public void addnode ( topologicalnode node ) { nodelist . add ( node ) ; }	adds an topological node to this graph .
public void printtext ( string text ) { view . print ( text , text . endswith ( _str ) ) ; for ( actiondelegate actiondelegate : actiondelegates ) { actiondelegate . onconsoleoutput ( this ) ; } }	print text in the console .
@ override public void trim ( ) { if ( counter < x . length ) { int [ ] y = new int [ counter ] ; system . arraycopy ( x , _num , y , _num , counter ) ; x = y ; resizevalues ( counter ) ; } }	trims the data row to the number of actually used elements .
private void divide ( int [ ] idx , double [ ] data , arraylist < int [ ] > ret , int start , int end , int depth ) { if ( depth == _num ) { int [ ] a = arrays . copyofrange ( idx , start , end ) ; arrays . sort ( a ) ; ret . add ( a ) ; return ; } final int count = end - start ; if ( count == _num ) { for ( int j = _num << depth ; j > _num ; -- j ) { ret . add ( new int [ _num ] ) ; } return ; } double m = _num ; for ( int i = start ; i < end ; i ++ ) { m += data [ i ] ; } m /= count ; int pos = arrays . binarysearch ( data , start , end , m ) ; if ( pos >= _num ) { final int opt = ( start + end ) > > _num ; while ( data [ pos ] == m ) { if ( pos < opt ) { pos ++ ; } else if ( pos > opt ) { pos -- ; } else { break ; } } } else { pos = ( - pos - _num ) ; } divide ( idx , data , ret , start , pos , depth - _num ) ; divide ( idx , data , ret , pos , end , depth - _num ) ; }	recursive call to further subdivide the array .
void assertthreadsstayalive ( long millis , thread ... threads ) { try { delay ( millis ) ; for ( thread thread : threads ) asserttrue ( thread . isalive ( ) ) ; } catch ( interruptedexception fail ) { threadfail ( _str ) ; } }	checks that the threads do not terminate within the given millisecond delay .
public abstractworkermanager ( string id ) { _id = id ; _status = new workermanagerstatus ( ) ; setexecutionmode ( execution_mode . non_serial ) ; setupexecutor ( ) ; }	set the identifier of the process.
@ onmessage public void onmessage ( string message , session session ) { callinternal ( _str , session , message ) ; }	on message received handler.
public final boolean insert_via ( brdviainfo p_via_info , plapointint p_location , netnoslist p_net_no_arr , int p_trace_clearance_class_no , int [ ] p_trace_pen_halfwidth_arr , int p_max_recursion_depth , int p_max_via_recursion_depth , int p_pull_tight_accuracy , int p_pull_tight_time_limit ) { shove_fail_clear ( ) ; changed_area_clear ( ) ; boolean r_ok = shove_via_algo . shove_via_insert ( p_via_info , p_location , p_net_no_arr , p_trace_clearance_class_no , p_trace_pen_halfwidth_arr , p_max_recursion_depth , p_max_via_recursion_depth ) ; if ( ! r_ok ) return _bool ; netnoslist opt_net_no_arr = p_max_recursion_depth <= _num ? p_net_no_arr : netnoslist . empty ; timelimitstoppable t_limit = new timelimitstoppable ( s_prevent_endless_loop ) ; changed_area_optimize ( opt_net_no_arr , p_pull_tight_accuracy , null , t_limit , null ) ; return _bool ; }	shoves aside traces , so that a via with the input parameters can be inserted without clearance violations.
boolean thresholdexceeded ( final set < ibindingset > distinctprojectionbuffer , final int distinctprojectionbufferthreshold , final list < ibindingset > incomingbindingsbuffer , final int incomingbindingsbufferthreshold ) { return distinctprojectionbuffer . size ( ) >= distinctprojectionbufferthreshold || incomingbindingsbuffer . size ( ) >= incomingbindingsbufferthreshold ; }	returns true if , for one of the buffers , the threshold has been exceeded .
public static byte [ ] tobytearray ( string str ) { int len = str . length ( ) ; stringtokenizer st = new stringtokenizer ( str , _str ) ; string [ ] newstrarray = new string [ st . counttokens ( ) ] ; int j = _num ; while ( st . hasmoretokens ( ) ) { newstrarray [ j ] = st . nexttoken ( ) ; j ++ ; } byte [ ] ret = new byte [ newstrarray . length ] ; int tmp ; for ( int i = _num ; i < newstrarray . length ; i ++ ) { tmp = integer . parseint ( newstrarray [ i ] , _num ) ; ret [ i ] = ( byte ) ( tmp - _num ) ; } return ret ; }	converts a given hex string separated by colons to a byte array .
int maxlength ( ) { fontmetrics fm = getfontmetrics ( getfont ( ) ) ; int m = _num ; int end = items . size ( ) ; for ( int i = _num ; i < end ; i ++ ) { int l = fm . stringwidth ( ( ( string ) items . elementat ( i ) ) ) ; m = math . max ( m , l ) ; } return m ; }	return the length of the largest item in the list.
public void write ( final char chars [ ] , final int start , final int length ) throws java . io . ioexception { if ( m_writer != null ) m_writer . write ( chars , start , length ) ; int lengthx3 = ( length << _num ) + length ; if ( lengthx3 >= buf_length ) { flushbuffer ( ) ; setbuffersize ( _num * lengthx3 ) ; } if ( lengthx3 > buf_length - count ) { flushbuffer ( ) ; } final int n = length + start ; for ( int i = start ; i < n ; i ++ ) { final char c = chars [ i ] ; if ( c < _num ) buf [ count ++ ] = ( byte ) ( c ) ; else if ( c < _num ) { buf [ count ++ ] = ( byte ) ( _num + ( c > > _num ) ) ; buf [ count ++ ] = ( byte ) ( _num + ( c & _num ) ) ; } else { buf [ count ++ ] = ( byte ) ( _num + ( c > > _num ) ) ; buf [ count ++ ] = ( byte ) ( _num + ( ( c > > _num ) & _num ) ) ; buf [ count ++ ] = ( byte ) ( _num + ( c & _num ) ) ; } } }	write a portion of an array of characters .
public plapointint round_to_the_left ( pladirection p_dir ) { plapointfloat dir = p_dir . to_float ( ) ; double rounded_x ; if ( dir . v_y > _num ) { rounded_x = math . floor ( v_x ) ; } else if ( dir . v_y < _num ) { rounded_x = math . ceil ( v_x ) ; } else { rounded_x = math . round ( v_x ) ; } double rounded_y ; if ( dir . v_x > _num ) { rounded_y = math . ceil ( v_y ) ; } else if ( dir . v_x < _num ) { rounded_y = math . floor ( v_y ) ; } else { rounded_y = math . round ( v_y ) ; } return new plapointint ( rounded_x , rounded_y ) ; }	rounds this point , so that if this point is on the left side of any directed line with direction p_dir , the result point will also be on the left side .
protected httphost determineproxy ( httphost target , httprequest request , httpcontext context ) throws httpexception { proxyselector psel = this . proxyselector ; if ( psel == null ) psel = proxyselector . getdefault ( ) ; if ( psel == null ) return null ; uri targeturi = null ; try { targeturi = new uri ( target . touri ( ) ) ; } catch ( urisyntaxexception usx ) { throw new httpexception ( _str + target , usx ) ; } list < proxy > proxies = psel . select ( targeturi ) ; proxy p = chooseproxy ( proxies , target , request , context ) ; httphost result = null ; if ( p . type ( ) == proxy . type . http ) { if ( ! ( p . address ( ) instanceof inetsocketaddress ) ) { throw new httpexception ( _str + p . address ( ) ) ; } final inetsocketaddress isa = ( inetsocketaddress ) p . address ( ) ; result = new httphost ( gethost ( isa ) , isa . getport ( ) ) ; } return result ; }	determines a proxy for the given target .
private void addreference ( final int sourceposition , final int referenceposition ) { if ( srcandrefpositions == null ) { srcandrefpositions = new int [ _num ] ; } if ( referencecount >= srcandrefpositions . length ) { int [ ] a = new int [ srcandrefpositions . length + _num ] ; system . arraycopy ( srcandrefpositions , _num , a , _num , srcandrefpositions . length ) ; srcandrefpositions = a ; } srcandrefpositions [ referencecount ++ ] = sourceposition ; srcandrefpositions [ referencecount ++ ] = referenceposition ; }	adds a forward reference to this label.
public object [ ] toarray ( ) { return arrays . copyof ( elementdata , size ) ; }	returns an array containing all of the elements in this list in proper sequence ( from first to last element ).
public boolean isrunning ( ) { return mthread != null && mthread . isalive ( ) ; }	indicates whether the server is currently running .
public static byte [ ] unwrapvcf ( file sourcefile , file tmpfile ) throws filenotfoundexception , ioexception { ziparchiveinputstream in = null ; fileoutputstream fos = null ; string hmacstring = null ; try { in = new ziparchiveinputstream ( new fileinputstream ( sourcefile ) ) ; archiveentry entry ; in . getnextentry ( ) ; fos = new fileoutputstream ( tmpfile ) ; ioutils . copy ( in , fos ) ; entry = in . getnextentry ( ) ; hmacstring = entry . getname ( ) ; return utils . hextobytes ( hmacstring ) ; } catch ( stringindexoutofboundsexception e ) { logger . error ( _str + hmacstring + _str , e ) ; throw e ; } catch ( exception e ) { logger . error ( _str , e ) ; throw e ; } finally { if ( fos != null ) { fos . flush ( ) ; fos . close ( ) ; } if ( in != null ) { in . close ( ) ; } } }	method extracts the vcf file stored within the zipped import file to the given destination file.
public boolean registeruser ( string username , string password , string uri ) throws dataaccessexception { if ( checkusernameexists ( username ) ) { return _bool ; } storeuser ( username , password , uri ) ; return _bool ; }	attempts to register the username , password combination.
public select ( @ nonnull string ... columns ) { if ( columns == null ) { throw new nullpointerexception ( _str ) ; } if ( columns . length == _num ) throw new illegalargumentexception ( _str ) ; stringbuilder builder = new stringbuilder ( _str ) ; for ( int i = _num ; i < columns . length ; i ++ ) { builder . append ( columns [ i ] ) ; if ( i != ( columns . length - _num ) ) builder . append ( _str ) ; } sql = builder . tostring ( ) ; }	create a < code > select column1 , column2 ,.
public static synchronized mbeaninfo testcompliance ( final class < ? > baseclass , class < ? > mbeaninterface ) throws notcompliantmbeanexception { if ( mbeaninterface == null ) mbeaninterface = getstandardmbeaninterface ( baseclass ) ; reflectutil . checkpackageaccess ( mbeaninterface ) ; mbeanintrospector < ? > introspector = standardmbeanintrospector . getinstance ( ) ; return getclassmbeaninfo ( introspector , baseclass , mbeaninterface ) ; }	basic method for testing if a given class is a jmx compliant standard mbean.
public static set < string > tostringset ( templatesequencemodel seqmodel ) throws templatemodelexception { set < string > set = new hashset < string > ( ) ; for ( int i = _num ; i < seqmodel . size ( ) ; i ++ ) { set . add ( getasstringnonescaping ( ( templatescalarmodel ) seqmodel . get ( i ) ) ) ; } return set ; }	to string set . < p > warn : bypasses auto - escaping , caller handles . ( e . g . the object wrapper used to rewrap the result ) .
public jkssignaturetoken ( inputstream ksstream , string kspassword ) { try { keystore = keystore . getinstance ( keystore . getdefaulttype ( ) ) ; password = ( kspassword == null ) ? null : kspassword . tochararray ( ) ; keystore . load ( ksstream , password ) ; } catch ( exception e ) { throw new dssexception ( e ) ; } finally { if ( ksstream != null ) { try { ksstream . close ( ) ; } catch ( ioexception e ) { logger . error ( e . getmessage ( ) , e ) ; } } } }	creates a signaturetokenconnection with the provided inputstream to java keystore file and password .
protected void writelocation ( string loc ) throws ioexception { hadannotations |= ( loc != null ) ; locout . writeobject ( loc ) ; }	overrides marshaloutputstream . writelocation implementation to write annotations to the location stream .
protected int __offset ( int vtable_offset ) { int vtable = bb_pos - bb . getint ( bb_pos ) ; return vtable_offset < bb . getshort ( vtable ) ? bb . getshort ( vtable + vtable_offset ) : _num ; }	look up a field in the vtable .
public static string selecttext ( xpathexpression expr , node context ) { try { return ( string ) expr . evaluate ( context , xpathconstants . string ) ; } catch ( xpathexpressionexception e ) { throw new xmlexception ( e ) ; } }	evaluates the xpath expression as text .
public static httpheaders toarmeria ( io . netty . handler . codec . http . httpheaders inheaders ) { if ( inheaders . isempty ( ) ) { return httpheaders . empty_headers ; } final httpheaders out = new defaulthttpheaders ( _bool , inheaders . size ( ) ) ; toarmeria ( inheaders , out ) ; return out ; }	converts the specified netty http / 1 headers into armeria http / 2 headers .
public static int calculatermslevel ( short [ ] audiodata , int numframes ) { long lsum = _num ; int numread = _num ; for ( short s : audiodata ) { lsum = lsum + s ; numread ++ ; if ( numread == numframes ) break ; } double davg = lsum / numframes ; double summeansquare = _num ; numread = _num ; for ( short anaudiodata : audiodata ) { summeansquare = summeansquare + math . pow ( anaudiodata - davg , _num ) ; numread ++ ; if ( numread == numframes ) break ; } double averagemeansquare = summeansquare / numframes ; return ( int ) ( math . pow ( averagemeansquare , _num ) + _num ) ; }	calculates the rms audio level from the provided short sample extract.
private void initprogram ( ) { gluseprogram ( this . program ) ; vec3arrayuniform = glgetuniformlocation ( this . program , _str ) ; chosenuniform = glgetuniformlocation ( this . program , _str ) ; gluseprogram ( _num ) ; }	initialize the shader program .
public boolean enginecontainsalias ( string alias ) { return entries . containskey ( alias . tolowercase ( locale . english ) ) ; }	checks if the given alias exists in this keystore .
public void invertselectedrelations ( ) { iselection selection = viewer . getselection ( ) ; if ( ! ( selection instanceof istructuredselection ) ) { return ; } istructuredselection structuredselection = ( istructuredselection ) selection ; collection < relation > inverse = computeinverserelations ( gettablerelations ( ) , structuredselection ) ; structuredselection nextselection = new structuredselection ( inverse . toarray ( ) ) ; viewer . setselection ( nextselection , _bool ) ; }	invert the set of relations selected in the table.
public void testfloatvalueneg ( ) { string a = _str ; bigdecimal anumber = new bigdecimal ( a ) ; float result = - _num ; asserttrue ( _str , anumber . floatvalue ( ) == result ) ; }	float value of a negative bigdecimal.
public void bindkeystore ( final keystoreservice keystoreservice ) { this . keystore = keystoreservice ; }	binds the keystore to the truststore service.
protected void drawconnectorcenters ( canvas c ) { list < connection > connections = mblock . getallconnections ( ) ; paint paint = new paint ( ) ; paint . setstyle ( paint . style . fill ) ; for ( int i = _num ; i < connections . size ( ) ; i ++ ) { connection conn = connections . get ( i ) ; if ( conn . indragmode ( ) ) { if ( conn . isconnected ( ) ) { paint . setcolor ( color . red ) ; } else { paint . setcolor ( color . magenta ) ; } } else { if ( conn . isconnected ( ) ) { paint . setcolor ( color . green ) ; } else { paint . setcolor ( color . cyan ) ; } } mtempworkspacepoint . set ( conn . getposition ( ) . x - mblock . getposition ( ) . x , conn . getposition ( ) . y - mblock . getposition ( ) . y ) ; mhelper . workspacetovirtualviewdelta ( mtempworkspacepoint , mtempconnectionposition ) ; if ( mhelper . usertl ( ) ) { mtempconnectionposition . x += mblockviewsize . x ; } c . drawcircle ( mtempconnectionposition . x , mtempconnectionposition . y , _num , paint ) ; } }	this is a developer testing function subclasses can call to draw dots at the model ' s location of all connections on this block.
private static boolean ismerge ( instructionhandle handle ) { if ( handle . hastargeters ( ) ) { instructiontargeter [ ] targeterlist = handle . gettargeters ( ) ; for ( instructiontargeter targeter : targeterlist ) { if ( targeter instanceof branchinstruction ) { return _bool ; } } } return _bool ; }	determine whether or not the given instruction is a control flow merge .
private synchronized void loadtrustmanager ( ) { try { trustmanagerfactory tmf = trustmanagerfactory . getinstance ( x509_algorithm ) ; tmf . init ( keystore ) ; for ( trustmanager trustmanager : tmf . gettrustmanagers ( ) ) { if ( trustmanager instanceof x509trustmanager ) { defaultviprtrustmanager = ( x509trustmanager ) trustmanager ; log . debug ( _str ) ; break ; } } log . info ( _str , defaultviprtrustmanager . getacceptedissuers ( ) . length ) ; } catch ( generalsecurityexception e ) { log . error ( e . getmessage ( ) , e ) ; } }	loads the trust manager using the vipr keystore .
private boolean isoutsidedocelem ( ) { return ( null == m_docfrag ) && m_elemstack . size ( ) == _num && ( null == m_currentnode || m_currentnode . getnodetype ( ) == node . document_node ) ; }	tell if the current node is outside the document element .
public threadpool ( string name , int poolsize ) { this . poolsize = poolsize ; this . poolname = name ; tasklist = new linkedlist < runnable > ( ) ; threads = new workerthread [ poolsize ] ; createthreads ( ) ; }	constructs a thread pool with given parameters .
private static object invokeordie ( final method method , final object object , final object ... params ) { try { return method . invoke ( object , params ) ; } catch ( illegalaccessexception e ) { throw new runtimeexception ( _str + _str , e ) ; } catch ( invocationtargetexception e ) { final throwable cause = e . getcause ( ) ; if ( cause instanceof runtimeexception ) { throw ( runtimeexception ) cause ; } else if ( cause instanceof error ) { throw ( error ) cause ; } else { throw new runtimeexception ( _str , cause ) ; } } }	calls invoke and throws a runtimeexception if it fails .
public void clear ( ) { this . normal = null ; this . depth = _num ; }	clears the penetration information .
public final void addhelpertextcolor ( @ colorint final int color ) { if ( ! helpertextcolors . contains ( color ) ) { helpertextcolors . add ( color ) ; verifypasswordstrength ( ) ; } }	adds a new helper text color , which should be used to highlight the helper text , which indicates the password strength .
public void advancetonextminute ( ) { }	hook function overridden in instrumentedraptorworker b / efore advancing to the next minute.
listbasedtokenstream ( attributesource attributesource , list < attributesource > tokens ) { super ( attributesource . getattributefactory ( ) ) ; this . tokens = tokens ; addattributes ( attributesource ) ; }	creates a new listbasedtokenstream which uses the given tokens as its token source .
@ suppresswarnings ( _str ) protected class resolveclass ( objectstreamclass classdesc ) throws ioexception , classnotfoundexception { string cname = classdesc . getname ( ) ; return classfinder . resolveclass ( cname , this . loader ) ; }	use the given classloader rather than using the system class.
public map < string , object > makevalid ( map < string , ? extends object > source , string mode ) { return makevalid ( source , mode , _bool , null ) ; }	creates a new map based from an existing map with just valid parameters.
public static int find ( byte [ ] a , int fromindex , int toindex , byte [ ] key ) { int result = - _num ; int sublen = key . length ; int maxpos , first , sp = _num ; maxpos = math . min ( toindex , a . length ) - sublen ; for ( first = fromindex ; sp != sublen && first <= maxpos ; first ++ ) { first = find ( a , first , maxpos , key [ _num ] ) ; if ( ( first < _num ) || ( first > maxpos ) ) { break ; } for ( sp = _num ; sp < sublen ; sp ++ ) { if ( a [ first + sp ] != key [ sp ] ) { sp = sublen ; } } } if ( sublen == _num ) { result = _num ; } else if ( sp == sublen ) { result = ( first - _num ) ; } return result ; }	look for a sequence of bytes in a byte array .
private void addsyntheticedge ( collection < graphedge > result , graphedge original , graphnode head , graphnode tail ) { result . add ( new graphedge ( head , tail , original . getrelation ( ) ) ) ; }	synthesize a new edge , and add it to the result.
public void addstates ( state [ ] s ) { for ( int i = _num ; i < s . length ; i ++ ) states . addelement ( s [ i ] ) ; }	append states to the state vector .
private synchronized void readobject ( java . io . objectinputstream s ) throws ioexception , classnotfoundexception { s . defaultreadobject ( ) ; init ( getmask ( actions ) ) ; }	readobject is called to restore the state of the servicepermission from a stream .
private static byte [ ] windowsregenumkeyex1 ( int hkey , int subkeyindex , int maxkeylength ) { byte [ ] result = windowsregenumkeyex ( hkey , subkeyindex , maxkeylength ) ; if ( result != null ) { return result ; } else { long sleeptime = init_sleep_time ; for ( int i = _num ; i < max_attempts ; i ++ ) { try { thread . sleep ( sleeptime ) ; } catch ( interruptedexception e ) { return result ; } sleeptime *= _num ; result = windowsregenumkeyex ( hkey , subkeyindex , maxkeylength ) ; if ( result != null ) { return result ; } } } return result ; }	retries regenumkeyex ( ) max_attempts times before giving up .
public tasker addtask ( task task ) { tasks . add ( task ) ; lastaddedtask = task ; return this ; }	add a new task.
private void initcomputeprogram ( ) { gluseprogram ( computeprogram ) ; intbuffer workgroupsize = bufferutils . createintbuffer ( _num ) ; glgetprogramiv ( computeprogram , gl_compute_work_group_size , workgroupsize ) ; workgroupsizex = workgroupsize . get ( _num ) ; workgroupsizey = workgroupsize . get ( _num ) ; timeuniform = glgetuniformlocation ( computeprogram , _str ) ; blendfactoruniform = glgetuniformlocation ( computeprogram , _str ) ; bouncecountuniform = glgetuniformlocation ( computeprogram , _str ) ; intbuffer params = bufferutils . createintbuffer ( _num ) ; int loc = glgetuniformlocation ( computeprogram , _str ) ; glgetuniformiv ( computeprogram , loc , params ) ; framebufferimagebinding = params . get ( _num ) ; loc = glgetuniformlocation ( computeprogram , _str ) ; glgetuniformiv ( computeprogram , loc , params ) ; worldpositionimagebinding = params . get ( _num ) ; loc = glgetuniformlocation ( computeprogram , _str ) ; glgetuniformiv ( computeprogram , loc , params ) ; worldnormalimagebinding = params . get ( _num ) ; gluseprogram ( _num ) ; }	initialize the compute shader .
public void sort ( ) { throwifimmutable ( ) ; if ( ! sorted ) { arrays . sort ( values , _num , size ) ; sorted = _bool ; } }	sorts the elements in the list in - place .
public static object objectfrombytebuffer ( byte [ ] buffer ) throws exception { if ( buffer == null ) return null ; bytearrayinputstream instream = new bytearrayinputstream ( buffer ) ; objectinputstream in = new objectinputstreamext ( instream ) ; object retval = in . readobject ( ) ; in . close ( ) ; return retval ; }	creates an object from a byte buffer .
public string generategroupname ( string policyname , set < string > existinggroupnames , string parentgroupname ) { int count = _num ; string format = null ; while ( count <= existinggroupnames . size ( ) ) { if ( _num == count ) { format = string . format ( _str , policyname ) ; } else { format = string . format ( _str , policyname , count ) ; } string generatedgroupname = generate ( parentgroupname , format , smisconstants . mask_name_delimiter , smisconstants . max_storage_group_name_length ) ; if ( ! existinggroupnames . contains ( generatedgroupname ) ) { return generatedgroupname ; } count ++ ; } return generate ( parentgroupname , string . format ( _str , policyname ) , smisconstants . mask_name_delimiter , smisconstants . max_storage_group_name_length ) ; }	todo : vmax3 customized names generate group names which doesn ' t exist in array already .
public static void assertcolumntypes ( resultset rs , int [ ] expectedtypes ) throws sqlexception { resultsetmetadata rsmd = rs . getmetadata ( ) ; int actualcols = rsmd . getcolumncount ( ) ; assertequals ( _str , expectedtypes . length , rsmd . getcolumncount ( ) ) ; for ( int i = _num ; i < actualcols ; i ++ ) { assertequals ( _str + ( i + _num ) , expectedtypes [ i ] , rsmd . getcolumntype ( i + _num ) ) ; } }	test method from apache derby project class org.
public defaultactiongroup ( @ notnull anaction ... actions ) { this ( arrays . aslist ( actions ) ) ; }	creates an action group containing the specified actions .
public int add ( t dl , int row ) { _list . add ( row , dl ) ; firetablerowsinserted ( row , row ) ; return row ; }	adds a dataline to the list at a row.
private void pushterm ( bytesref text ) throws ioexception { int limit = math . min ( lastterm . length ( ) , text . length ) ; int pos = _num ; while ( pos < limit && lastterm . byteat ( pos ) == text . bytes [ text . offset + pos ] ) { pos ++ ; } for ( int i = lastterm . length ( ) - _num ; i >= pos ; i -- ) { int prefixtopsize = pending . size ( ) - prefixstarts [ i ] ; if ( prefixtopsize >= minitemsinblock ) { writeblocks ( i + _num , prefixtopsize ) ; prefixstarts [ i ] -= prefixtopsize - _num ; } } if ( prefixstarts . length < text . length ) { prefixstarts = arrayutil . grow ( prefixstarts , text . length ) ; } for ( int i = pos ; i < text . length ; i ++ ) { prefixstarts [ i ] = pending . size ( ) ; } lastterm . copybytes ( text ) ; }	pushes the new term to the top of the stack , and writes new blocks .
public numericliteral ( object x ) { if ( x instanceof number ) { m_number = ( number ) x ; m_type = typelib . getprimitivetype ( m_number . getclass ( ) ) ; } else { throw new illegalargumentexception ( _str ) ; } }	create a new numericliteral .
private final boolean compareandsethead ( node update ) { return unsafe . compareandswapobject ( this , headoffset , null , update ) ; }	cas head field . used only by enq .
protected set < dependencykind > removedependency ( node n ) { set < dependencykind > removedkinds = new hashset < > ( ) ; for ( dependencykind dk : dependencykind . values ( ) ) { set < node > depsbykind = deps . get ( dk ) ; if ( depsbykind == null ) continue ; if ( depsbykind . remove ( n ) ) { removedkinds . add ( dk ) ; } } return removedkinds ; }	remove a dependency , regardless of its kind .
public static < k , v > concurrentmap < k , v > newconcurrentmapwithaggressiveconcurrency ( ) { return new concurrenthashmap < > ( _num , _num , aggressiveconcurrencylevel ) ; }	creates a new chm with an aggressive concurrency level , aimed at high concurrent update rate long living maps .
@ override public boolean connectionallowed ( string eventname ) { if ( m_listenee != null || ! eventname . equals ( _str ) ) { return _bool ; } return _bool ; }	returns true if , at this time , the object will accept a connection with respect to the named event.
protected char skipallwhitespace ( reader r ) throws ioexception { char c ; do { c = ( char ) r . read ( ) ; } while ( character . iswhitespace ( c ) && c != ( char ) - _num ) ; return c ; }	skips all consecutive whitespace characters from reader.
public iterator enumerateliteralresultattributes ( ) { return ( null == m_avts ) ? null : m_avts . iterator ( ) ; }	compiling templates requires that we be able to list the avts added 9 / 5 / 2000 to support compilation experiment.
public map < string , string > parse ( final string str , char separator ) { if ( str == null ) { return new hashmap < > ( ) ; } return parse ( str . tochararray ( ) , separator ) ; }	extracts a map of name / value pairs from the given string.
public priorityqueue ( collection < ? extends e > c ) { if ( c instanceof priorityqueue ) { getfrompriorityqueue ( ( priorityqueue < ? extends e > ) c ) ; } else if ( c instanceof sortedset ) { getfromsortedset ( ( sortedset < ? extends e > ) c ) ; } else { initsize ( c ) ; addall ( c ) ; } }	constructs a priority queue that contains the elements of a collection.
private string resourceid ( ) { return subschemapath . isempty ( ) ? null : lastschemanodename ( ) ; }	gets the resource id.
@ override public boolean isinitial ( ) { return init ; }	returns a boolean flag indicating if the state is initial ( just starting ).
public static string denormalize ( final charsequence self ) { if ( lineseparator == null ) { final stringwriter sw = new stringwriter ( _num ) ; try { final bufferedwriter bw = new bufferedwriter ( sw ) ; bw . newline ( ) ; bw . flush ( ) ; lineseparator = sw . tostring ( ) ; } catch ( ioexception ioe ) { lineseparator = _str ; } } final int len = self . length ( ) ; if ( len < _num ) { return self . tostring ( ) ; } final stringbuilder sb = new stringbuilder ( ( _num * len ) / _num ) ; int i = _num ; charsequence cs = ( self instanceof gstring ) ? self . tostring ( ) : self ; while ( i < len ) { final char ch = cs . charat ( i ++ ) ; switch ( ch ) { case _str : sb . append ( lineseparator ) ; if ( ( i < len ) && ( cs . charat ( i ) == _str ) ) { ++ i ; } break ; case _str : sb . append ( lineseparator ) ; break ; default : sb . append ( ch ) ; break ; } } return sb . tostring ( ) ; }	return a charsequence with lines ( separated by lf , cr / lf , or cr ) terminated by the platform specific line separator .
public static void performsaveas ( string schemaprefixfilename , string selfilepath , containerconfig containerconfig ) { try { file filewithdefaultconfiguration = createcontainerschemafile ( schemaprefixfilename , selfilepath ) ; updatefile ( containerconfig , filewithdefaultconfiguration . getpath ( ) , schemaprefixfilename ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }	save content of containerconfig instance into xml file ( schema or configuration ) .
public boolean isaborted ( ) { return isaborted . get ( ) ; }	returns whether the printng was aborted using this printingstatus.
public void append ( int key , e value ) { if ( msize != _num && key <= mkeys [ msize - _num ] ) { put ( key , value ) ; return ; } if ( mgarbage && msize >= mkeys . length ) { gc ( ) ; } int pos = msize ; if ( pos >= mkeys . length ) { int n = idealintarraysize ( pos + _num ) ; int [ ] nkeys = new int [ n ] ; object [ ] nvalues = new object [ n ] ; system . arraycopy ( mkeys , _num , nkeys , _num , mkeys . length ) ; system . arraycopy ( mvalues , _num , nvalues , _num , mvalues . length ) ; mkeys = nkeys ; mvalues = nvalues ; } mkeys [ pos ] = key ; mvalues [ pos ] = value ; msize = pos + _num ; }	puts a key / value pair into the array , optimizing for the case where the key is greater than all existing keys in the array .
public void testskip ( ) throws ioexception { byte [ ] data = new byte [ _num * _num ] ; byte [ ] gzipped = gzipoutputstreamtest . gzip ( data ) ; gzipinputstream in = new gzipinputstream ( new bytearrayinputstream ( gzipped ) ) ; long totalskipped = _num ; long count ; do { count = in . skip ( long . max_value ) ; totalskipped += count ; } while ( count > _num ) ; assertequals ( data . length , totalskipped ) ; in . close ( ) ; }	http : / / b / 3042574 gzipinputstream . skip ( ) causing crc failures.
private support_testwebdata ( string path , string type ) { file file = new file ( path ) ; testlength = file . length ( ) ; testlastmodified = file . lastmodified ( ) ; testname = file . getname ( ) ; testtype = type ; testdir = file . isdirectory ( ) ; bytearrayoutputstream out = new bytearrayoutputstream ( ) ; fileinputstream in = null ; try { in = new fileinputstream ( file ) ; while ( in . available ( ) > _num ) { out . write ( in . read ( ) ) ; } in . close ( ) ; out . flush ( ) ; test0data = out . tobytearray ( ) ; out . close ( ) ; test0dataavailable = _bool ; return ; } catch ( exception e ) { e . printstacktrace ( ) ; } finally { try { if ( in != null ) { in . close ( ) ; } if ( out != null ) { out . close ( ) ; } } catch ( ioexception e ) { } } }	creates a data package with information used by the server when responding to requests.
public static void print ( boolean x ) { out . print ( x ) ; out . flush ( ) ; }	prints a boolean to standard output and flushes standard output .
public ipcsharedmemoryspace ( string tokfilename , int writerpid , int readerpid , int size , boolean reader , ignitelogger parent ) throws ignitecheckedexception { assert size > _num : _str ; log = parent . getlogger ( ipcsharedmemoryspace . class ) ; opsize = size ; shmemptr = ipcsharedmemoryutils . allocatesystemresources ( tokfilename , size , debug && log . isdebugenabled ( ) ) ; shmemid = ipcsharedmemoryutils . sharedmemoryid ( shmemptr ) ; semid = ipcsharedmemoryutils . semaphoreid ( shmemptr ) ; isreader = reader ; this . tokfilename = tokfilename ; this . readerpid = readerpid ; this . writerpid = writerpid ; if ( debug && log . isdebugenabled ( ) ) log . debug ( _str + this ) ; }	this will allocate system resources for the space .
@ override public void close ( ) { try { if ( connection != null ) { connection . close ( ) ; } } catch ( sqlexception e ) { e . printstacktrace ( ) ; } }	close the jdbc connection.
public version addqualifier ( string qualifier ) { list < string > newqualifiers = new arraylist < > ( this . qualifiers ) ; newqualifiers . add ( qualifier ) ; return new version ( major , minor , patch , newqualifiers . toarray ( new string [ newqualifiers . size ( ) ] ) ) ; }	creates a new version object from the current one , but append a new qualifier to it .
public int loadsigned16 ( int addr ) { return loadsigned16 ( addr , accesssource . code ) ; }	perform a 16bit load where the sign extended result fills the return value.
public static string arraytohexstring ( byte [ ] array ) { return arraytohexstring ( array , _num , array . length ) ; }	helper method to convert a byte [ ] array ( such as a msgid ) to a hex string.
public static void unregisterbaggagehandler ( baggagehandler handler ) { handlers . remove ( handler ) ; }	remove an existing baggage handler that was previously registered.
public defaultheatmapdataset ( int xsamples , int ysamples , double minx , double maxx , double miny , double maxy ) { if ( xsamples < _num ) { throw new illegalargumentexception ( _str ) ; } if ( ysamples < _num ) { throw new illegalargumentexception ( _str ) ; } if ( double . isinfinite ( minx ) || double . isnan ( minx ) ) { throw new illegalargumentexception ( _str ) ; } if ( double . isinfinite ( maxx ) || double . isnan ( maxx ) ) { throw new illegalargumentexception ( _str ) ; } if ( double . isinfinite ( miny ) || double . isnan ( miny ) ) { throw new illegalargumentexception ( _str ) ; } if ( double . isinfinite ( maxy ) || double . isnan ( maxy ) ) { throw new illegalargumentexception ( _str ) ; } this . xsamples = xsamples ; this . ysamples = ysamples ; this . minx = minx ; this . maxx = maxx ; this . miny = miny ; this . maxy = maxy ; this . zvalues = new double [ xsamples ] [ ] ; for ( int x = _num ; x < xsamples ; x ++ ) { this . zvalues [ x ] = new double [ ysamples ] ; } }	creates a new dataset where all the z - values are initially 0.
public static void assertequalsanyorder ( eventbean [ ] [ ] expected , eventbean [ ] [ ] actual ) { if ( comparearraysize ( expected , actual ) ) { return ; } int nummatches = _num ; boolean [ ] foundreceived = new boolean [ actual . length ] ; for ( eventbean [ ] expectedobject : expected ) { boolean found = _bool ; for ( int i = _num ; i < actual . length ; i ++ ) { if ( foundreceived [ i ] ) { continue ; } boolean match = compareequalsexactorder ( actual [ i ] , expectedobject ) ; if ( match ) { found = _bool ; nummatches ++ ; foundreceived [ i ] = _bool ; break ; } } if ( ! found ) { log . error ( _str + arrays . tostring ( expectedobject ) ) ; log . error ( _str + arrays . tostring ( actual ) ) ; } scopetesthelper . asserttrue ( found ) ; } scopetesthelper . assertequals ( nummatches , expected . length ) ; }	compare two 2 - dimensional event arrays .
private void collecttext ( ) { if ( textnodecount > _num ) { firsttextnode . settext ( textbuffer . tostring ( ) ) ; } textnodecount = _num ; }	this method breaks concatenation mode . as a side effect it copies the concatenated string to the first text node.
@ suppresswarnings ( { _str , _str } ) public static < t extends annotation > t unproxy ( t annotation ) { function unproxyfunction = getunproxyfunction ( annotation . annotationtype ( ) ) ; return ( t ) unproxyfunction . apply ( annotation ) ; }	convert java proxy annotation to specialized implementation , used to speedup equals / hashcode / tostring methods .
public static list < node > parseexpression ( context context , hashset < string > confignamespaces , string text ) { return parseexpression ( context , confignamespaces , text , _num , _bool ) ; }	this method should be used to parse an expression , like " a = b ".
public void addtickmarksection ( final section section ) { if ( null == section ) return ; tickmarksections . add ( section ) ; collections . sort ( tickmarksections , new sectioncomparator ( ) ) ; fireupdateevent ( redraw_event ) ; }	adds the given section to the list of tickmark sections .
protected static double calcq_i ( double f , double lambda ) { return lambda * math . exp ( - lambda * f ) ; }	compute q_i ( exponential distribution , inliers ).
void flush ( ) { printstream . flush ( ) ; }	flush any io to disk.
public charbuffer delete ( int start , int end ) { int length = length ( ) ; if ( start < _num || end < start || length < start ) throw new stringindexoutofboundsexception ( ) ; end = math . min ( length , end ) ; int tail = length - end ; char [ ] buffer = buffer ( ) ; for ( int i = _num ; i < tail ; i ++ ) { buffer [ start + i ] = buffer [ end + i ] ; } length ( length - ( end - start ) ) ; return this ; }	deletes characters from the buffer .
public void addplotter ( final plotter plotter ) { plotters . add ( plotter ) ; }	add a plotter to the graph , which will be used to plot entries.
node < k , v > findnear ( k kkey , int rel ) { comparable < ? super k > key = comparable ( kkey ) ; for ( ; ; ) { node < k , v > b = findpredecessor ( key ) ; node < k , v > n = b . next ; for ( ; ; ) { if ( n == null ) return ( ( rel & lt ) == _num || b . isbaseheader ( ) ) ? null : b ; node < k , v > f = n . next ; if ( n != b . next ) break ; object v = n . value ; if ( v == null ) { n . helpdelete ( b , f ) ; break ; } if ( v == n || b . value == null ) break ; int c = key . compareto ( n . key ) ; if ( ( c == _num && ( rel & eq ) != _num ) || ( c < _num && ( rel & lt ) == _num ) ) return n ; if ( c <= _num && ( rel & lt ) != _num ) return b . isbaseheader ( ) ? null : b ; b = n ; n = f ; } } }	utility for ceiling , floor , lower , higher methods .
public void addlistener ( speedrunslivelistener listener ) { listeners . add ( listener ) ; }	adds a listener that receives the data and error messages .
public boolean find ( int start ) { if ( start < _num || start > input . length ( ) ) { throw new indexoutofboundsexception ( _str + start + _str + input . length ( ) ) ; } synchronized ( this ) { matchfound = findimpl ( address , input , start , matchoffsets ) ; } return matchfound ; }	returns true if there is another match in the input , starting from the given position.
public int action ( string fault , string action ) { integer current = get ( fault ) ; if ( current == null ) throw new illegalargumentexception ( fault ) ; boolean no = action . startswith ( _str ) ; if ( no ) action = action . substring ( _num ) ; integer bit = getaction ( action ) ; if ( bit == null ) throw new illegalargumentexception ( action ) ; int old = current . intvalue ( ) ; int mask = bit . intvalue ( ) ; int n = ( old & ( ~ mask ) ) ; n = ( no ) ? n : ( n | mask ) ; put ( fault , new integer ( n ) ) ; return n ; }	sets the action bits as appropriate for the given fault and action.
public static boolean containswhitespace ( charsequence str ) { if ( ! haslength ( str ) ) { return _bool ; } int strlen = str . length ( ) ; for ( int i = _num ; i < strlen ; i ++ ) { if ( character . iswhitespace ( str . charat ( i ) ) ) { return _bool ; } } return _bool ; }	check whether the given charsequence contains any whitespace characters .
public static < t > t decodefrombase64 ( coder < t > coder , string encodedvalue ) throws coderexception { return decodefromsafestream ( coder , new bytearrayinputstream ( base64 . decodebase64 ( encodedvalue ) ) , coder . context . outer ) ; }	parses a value from a base64 - encoded string using the given coder .
public void validate ( set setdata ) throws validationexception { for ( iterator iter = setdata . iterator ( ) ; iter . hasnext ( ) ; ) { performvalidation ( ( string ) iter . next ( ) ) ; } }	performs validation on a set of string .
public string add ( object ... values ) { double result = _num ; for ( int i = _num ; i < values . length ; i ++ ) { result += functionhandler . getdouble ( values [ i ] ) ; } return double . tostring ( result ) ; }	adds all values together.
public list < string > listmydbs ( string owner , boolean restricted ) { connection conn = null ; try { conn = getconnection ( ) ; return listmydbs ( conn , owner , restricted ) ; } catch ( exception ex ) { logger . log ( level . severe , _str , ex ) ; } finally { dbutils . close ( conn ) ; } return null ; }	list database groups the specific user has provided passwords.
protected void dofunction ( float [ ] inputs , int inputoffset , float [ ] outputs , int outputoffset ) { float input = inputs [ inputoffset ] ; for ( int i = _num ; i < getnumoutputs ( ) ; i ++ ) { outputs [ i + outputoffset ] = getc0 ( i ) + ( float ) ( math . pow ( input , getn ( ) ) * ( getc1 ( i ) - getc0 ( i ) ) ) ; } }	calculate the function value for the input . for each output ( j ) , the function value is : c0 ( j ) + x ^ n * ( c1 ( j ) - c0 ( j ) ).
public void put ( string key , long value ) { if ( key != null ) { urlparams . put ( key , string . valueof ( value ) ) ; } }	adds a long value to the request .
public int compare ( object o1 , object o2 ) { return comparator . compare ( o1 , o2 ) ; }	call the comparator on the column.
public void addcheckboxactionlistener ( actionlistener al ) { m_enabledistributedexperiment . addactionlistener ( al ) ; }	enable objects to listen for changes to the check box.
private rect calcbounds ( int index , paint paint ) { rect bounds = new rect ( ) ; charsequence title = gettitle ( index ) ; bounds . right = ( int ) paint . measuretext ( title , _num , title . length ( ) ) ; bounds . bottom = ( int ) ( paint . descent ( ) - paint . ascent ( ) ) ; return bounds ; }	calculate the bounds for a view ' s title.
gf256poly addorsubtract ( gf256poly other ) { if ( ! field . equals ( other . field ) ) { throw new illegalargumentexception ( _str ) ; } if ( iszero ( ) ) { return other ; } if ( other . iszero ( ) ) { return this ; } int [ ] smallercoefficients = this . coefficients ; int [ ] largercoefficients = other . coefficients ; if ( smallercoefficients . length > largercoefficients . length ) { int [ ] temp = smallercoefficients ; smallercoefficients = largercoefficients ; largercoefficients = temp ; } int [ ] sumdiff = new int [ largercoefficients . length ] ; int lengthdiff = largercoefficients . length - smallercoefficients . length ; system . arraycopy ( largercoefficients , _num , sumdiff , _num , lengthdiff ) ; for ( int i = lengthdiff ; i < largercoefficients . length ; i ++ ) { sumdiff [ i ] = gf256 . addorsubtract ( smallercoefficients [ i - lengthdiff ] , largercoefficients [ i ] ) ; } return new gf256poly ( field , sumdiff ) ; }	gf addition or subtraction ( they are identical for a gf ( 2 ^ n ).
@ override public string tostring ( ) { stringbuffer sb = new stringbuffer ( ) ; sb . append ( type ) ; sb . append ( _str ) ; sb . append ( subtype ) ; for ( string name : attributes . keyset ( ) ) { if ( inferredcharset && attr_charset . equals ( name ) ) { continue ; } sb . append ( _str ) ; sb . append ( name ) ; sb . append ( _str ) ; string value = attributes . get ( name ) ; matcher tokenmatcher = token_pattern . matcher ( value ) ; if ( tokenmatcher . matches ( ) ) { sb . append ( value ) ; } else { sb . append ( _str + value + _str ) ; } } return sb . tostring ( ) ; }	generates the content - type value.
public static long firstfieldoffset ( class clazz ) { long minsize = roundupto8 ( headersize ( clazz ) ) ; while ( clazz != object . class ) { for ( field f : clazz . getdeclaredfields ( ) ) { if ( ( f . getmodifiers ( ) & modifier . static ) == _num ) { long offset = unsafe . objectfieldoffset ( f ) ; if ( offset < minsize ) { minsize = offset ; } } } clazz = clazz . getsuperclass ( ) ; } return minsize ; }	returns the offset of the first field in the range [ headersize , sizeof ] .
public static void w ( string tag , string msg , object ... args ) { if ( slevel > level_warning ) { return ; } if ( args . length > _num ) { msg = string . format ( msg , args ) ; } log . w ( tag , msg ) ; }	send a warning log message.
public final v extractfirst ( ) { if ( size ( ) > _num ) { if ( gwt . isscript ( ) ) { v ret = jsarray . get ( _num ) ; jsarray . remove ( _num ) ; return ret ; } else { return javaarray . remove ( _num ) ; } } return null ; }	retrieve the first element and remove it from the list.
@ override public void actionperformed ( actionevent event ) { string command = event . getactioncommand ( ) ; if ( command . equals ( _str ) ) { attemptlabelfontselection ( ) ; } else if ( command . equals ( _str ) ) { attemptmodifylabelpaint ( ) ; } else if ( command . equals ( _str ) ) { attemptticklabelfontselection ( ) ; } }	handles user interaction with the property panel .
@ androidonly ( _str ) public void test_unwrap_bytebuffer bytebuffer_04 ( ) { string host = _str ; int port = _num ; bytebuffer bbs = bytebuffer . allocate ( _num ) ; bytebuffer [ ] bbd = { bytebuffer . allocate ( _num ) , bytebuffer . allocate ( _num ) , bytebuffer . allocate ( _num ) } ; sslengine sse = getengine ( host , port ) ; try { sse . unwrap ( bbs , bbd ) ; fail ( _str ) ; } catch ( illegalstateexception iobe ) { } catch ( exception e ) { fail ( e + _str ) ; } }	javax . net . ssl . sslengine # unwrap ( bytebuffer src , bytebuffer [ ] dsts ) illegalstateexception should be thrown .
public static void upgradeserverinstance ( ssotoken ssotoken , string instancename , string instanceid , map < string , string > upgradedvalues ) throws smsexception , ssoexception , configurationexception , ioexception { serviceconfig sc = getserverconfig ( ssotoken , instancename ) ; if ( sc != null ) { map map = sc . getattributes ( ) ; map . remove ( attr_parent_site_id ) ; set newset = getpropertiesset ( upgradedvalues ) ; map . put ( attr_server_config , newset ) ; sc . setattributes ( map ) ; } else { throw new configurationexception ( _str + _str ) ; } }	upgrades a server instance .
public static < t > t instance ( class < t > clazz ) { try { return clazz . newinstance ( ) ; } catch ( instantiationexception | illegalaccessexception e ) { throw new illegalstateexception ( e ) ; } }	creates a new instance of the class represented by the given class object.
private void pop ( final string desc ) { char c = desc . charat ( _num ) ; if ( c == _str ) { pop ( ( type . getargumentsandreturnsizes ( desc ) > > _num ) - _num ) ; } else if ( c == _str || c == _str ) { pop ( _num ) ; } else { pop ( _num ) ; } }	pops a type from the output frame stack .
public genericsipmsrpsession createmsrpsession ( contactid contact , string featuretag , string [ ] accepttypes , string [ ] acceptwrappedtypes ) { if ( slogger . isactivated ( ) ) { slogger . info ( _str + contact ) ; } return new originatingsipmsrpsession ( this , contact , featuretag , mrcssettings , system . currenttimemillis ( ) , mcontactmanager , accepttypes , acceptwrappedtypes ) ; }	initiate a msrp session.
public forumpostconfig create ( forumpostconfig config ) { config . addcredentials ( this ) ; string xml = post ( this . url + _str , config . toxml ( ) ) ; element root = parse ( xml ) ; if ( root == null ) { return null ; } try { forumpostconfig post = new forumpostconfig ( ) ; post . parsexml ( root ) ; return post ; } catch ( exception exception ) { this . exception = sdkexception . parsefailure ( exception ) ; throw this . exception ; } }	create a new forum post.
protected void drawmark ( graphics2d g2 , float x , float y , color color ) { rectangle2d bounds = mark . getbounds2d ( ) ; float w = ( float ) bounds . getwidth ( ) ; float h = ( float ) bounds . getheight ( ) ; x = x - ( w / _num ) ; y = y - ( h / _num ) ; g2 . translate ( x , y ) ; if ( color == null ) { if ( markfillpaint != null ) { g2 . setpaint ( markfillpaint ) ; g2 . fill ( mark ) ; } } else { g2 . setpaint ( color ) ; g2 . fill ( mark ) ; } g2 . setpaint ( markpaint ) ; g2 . setstroke ( markstroke ) ; g2 . draw ( mark ) ; g2 . translate ( - x , - y ) ; rectangle2d rect = new rectangle2d . float ( x , y , w , h ) ; markbounds . add ( rect ) ; }	draw a mark transforming co - ordinates to each axis.
public void componentresized ( componentevent e ) { if ( logger . isloggable ( level . fine ) ) { logger . fine ( _str + getwidth ( ) + _str + getheight ( ) ) ; } projection . setwidth ( getwidth ( ) ) ; projection . setheight ( getheight ( ) ) ; fireprojectionchanged ( ) ; }	componentlistener interface method . should not be called directly . invoked when component has been resized , and kicks off a projection change .
public static string bytearraytohexstring ( byte [ ] block , int offset , int length ) { stringbuffer buf = new stringbuffer ( ) ; int len = block . length ; length = length + offset ; if ( ( len < length ) ) { length = len ; } for ( int i = _num + offset ; i < length ; i ++ ) { byte2hex ( block [ i ] , buf ) ; if ( i < length - _num ) { buf . append ( _str ) ; } } return buf . tostring ( ) ; }	description of the method.
private void changevalue ( abstractstoragelabel < object > label , object newvalue ) { if ( ! objects . equals ( label . getvalue ( ) , newvalue ) ) { synchronized ( labeleditlisteners ) { for ( labeleditlistener listener : labeleditlisteners ) { listener . prelabelvaluechange ( label ) ; } } label . setvalue ( newvalue ) ; synchronized ( labeleditlisteners ) { for ( labeleditlistener listener : labeleditlisteners ) { listener . postlabelvaluechange ( label ) ; } } } }	reforms the value change and informs the listeners .
public void write ( byte [ ] b , int offset , int length ) throws ioexception { if ( entry . getmethod ( ) == deflated ) { if ( length > _num ) { if ( ! def . finished ( ) ) { def . setinput ( b , offset , length ) ; while ( ! def . needsinput ( ) ) { deflate ( ) ; } } } } else { writeout ( b , offset , length ) ; written += length ; } crc . update ( b , offset , length ) ; }	writes bytes to zip entry .
public void updatepoint ( float x , float y ) { if ( math . sqrt ( x * x + y * y ) > _num ) if ( listener != null ) { listener . onanglechangedlistener ( getangle ( x , - y ) ) ; } }	update the gravity point only if a the gravity vector is longer than the threshold.
public final void quietlyjoin ( ) { dojoin ( ) ; }	joins this task , without returning its result or throwing its exception.
@ override public int clampviewpositionhorizontal ( view child , int left , int dx ) { if ( mdraggedview == null ) { return _num ; } final int leftbound = _num - max_overflow - ( mcolumnsizeside / _num ) ; final int rightbound = getwidth ( ) + max_overflow + ( mcolumnsizeside / _num ) ; return math . min ( math . max ( left , leftbound ) , rightbound ) ; }	override method used to configure the horizontal drag.
httprequestwrapper ( httpservletrequest request ) { super ( request ) ; }	constructs a request object wrapping the given request .
private int converttopanelx ( double xval ) { double temp = ( xval - m_minx ) / m_rangex ; temp = temp * m_panelwidth ; return ( int ) temp ; }	convert an x coordinate from the instance space to the panel space .
public void forward ( httpserverrequest request ) { forward ( request , null ) ; }	handles the request and forwards it to the hook specific destination .
private set < string > primarykeys ( preparedstatement stmt , string owner , string tbl ) throws sqlexception { set < string > pkcols = new hashset < > ( ) ; stmt . setstring ( _num , owner ) ; stmt . setstring ( _num , tbl ) ; try ( resultset pkrs = stmt . executequery ( ) ) { while ( pkrs . next ( ) ) pkcols . add ( pkrs . getstring ( _num ) ) ; } return pkcols ; }	retrieve primary key columns .
public static long readuint32 ( inputstream stream ) throws ioexception { long result = _num ; for ( int i = _num ; i <= _num ; i += _num ) { result |= ( long ) stream . read ( ) << i ; } return result ; }	reads 4 bytes from stream and interprets them as uint32 . < br >.
private token toprefixtoken ( ileafnode leaf ) { lexer lexer = new internaln4jslexer ( ) ; string text = leaf . gettext ( ) ; string prefix = text . substring ( _num , endoffset - leaf . gettotaloffset ( ) ) ; antlrstringstream stream = new antlrstringstream ( prefix ) ; lexer . setcharstream ( stream ) ; token nexttoken = lexer . nexttoken ( ) ; return new commontoken ( nexttoken . gettype ( ) , nexttoken . gettext ( ) ) ; }	produce an antlr token for the prefix of the given leaf that overlaps the requested region.
protected void add ( csvrecord record ) { records . add ( objects . requirenonnull ( record ) ) ; }	adds the given record to this data .
private void scheduledenqueuesend ( ) { schedulerqueuesize . decrementandget ( ) ; scheduled . set ( _bool ) ; enqueuesendwitherrorlogging ( ) ; }	decrements the scheduled queue counter and enqueues the request .
private e awaitmatch ( node s , node pred , e e , boolean timed , long nanos ) { final long deadline = timed ? system . nanotime ( ) + nanos : _num ; thread w = thread . currentthread ( ) ; int spins = - _num ; threadlocalrandom randomyields = null ; for ( ; ; ) { object item = s . item ; if ( item != e ) { s . forgetcontents ( ) ; return linkedtransferqueue . < e > cast ( item ) ; } if ( ( w . isinterrupted ( ) || ( timed && nanos <= _num ) ) && s . casitem ( e , s ) ) { unsplice ( pred , s ) ; return e ; } if ( spins < _num ) { if ( ( spins = spinsfor ( pred , s . isdata ) ) > _num ) randomyields = threadlocalrandom . current ( ) ; } else if ( spins > _num ) { -- spins ; if ( randomyields . nextint ( chained_spins ) == _num ) thread . yield ( ) ; } else if ( s . waiter == null ) { s . waiter = w ; } else if ( timed ) { nanos = deadline - system . nanotime ( ) ; if ( nanos > _num ) locksupport . parknanos ( this , nanos ) ; } else { locksupport . park ( this ) ; } } }	spins / yields / blocks until node s is matched or caller gives up .
public static string join ( char [ ] self , string separator ) { stringbuilder buffer = new stringbuilder ( ) ; boolean first = _bool ; if ( separator == null ) separator = _str ; for ( char next : self ) { if ( first ) { first = _bool ; } else { buffer . append ( separator ) ; } buffer . append ( next ) ; } return buffer . tostring ( ) ; }	concatenates the string representation of each items in this array , with the given string as a separator between each item .
private < t > bindingamp < t > findobjectbinding ( key < t > key ) { objects . requirenonnull ( key ) ; if ( key . qualifiers ( ) . length != _num ) { throw new illegalargumentexception ( ) ; } return ( bindingamp ) findbinding ( key . of ( object . class , key . qualifiers ( ) [ _num ] ) ) ; }	returns an object producer .
private void initcomputeprogram ( ) { gluseprogram ( computeprogram ) ; intbuffer workgroupsize = bufferutils . createintbuffer ( _num ) ; glgetprogramiv ( computeprogram , gl_compute_work_group_size , workgroupsize ) ; workgroupsizex = workgroupsize . get ( _num ) ; workgroupsizey = workgroupsize . get ( _num ) ; timeuniform = glgetuniformlocation ( computeprogram , _str ) ; blendfactoruniform = glgetuniformlocation ( computeprogram , _str ) ; lightradiusuniform = glgetuniformlocation ( computeprogram , _str ) ; intbuffer props = bufferutils . createintbuffer ( _num ) ; intbuffer params = bufferutils . createintbuffer ( _num ) ; props . put ( _num , gl_buffer_binding ) ; int objectsresourceindex = glgetprogramresourceindex ( computeprogram , gl_shader_storage_block , _str ) ; glgetprogramresourceiv ( computeprogram , gl_shader_storage_block , objectsresourceindex , props , null , params ) ; objectsssbobinding = params . get ( _num ) ; int trianglesresourceindex = glgetprogramresourceindex ( computeprogram , gl_shader_storage_block , _str ) ; glgetprogramresourceiv ( computeprogram , gl_shader_storage_block , trianglesresourceindex , props , null , params ) ; trianglesssbobinding = params . get ( _num ) ; int loc = glgetuniformlocation ( computeprogram , _str ) ; glgetuniformiv ( computeprogram , loc , params ) ; framebufferimagebinding = params . get ( _num ) ; loc = glgetuniformlocation ( computeprogram , _str ) ; glgetuniformiv ( computeprogram , loc , params ) ; worldpositionimagebinding = params . get ( _num ) ; loc = glgetuniformlocation ( computeprogram , _str ) ; glgetuniformiv ( computeprogram , loc , params ) ; worldnormalimagebinding = params . get ( _num ) ; gluseprogram ( _num ) ; }	initialize the compute shader .
public boolean iftaskcompletedsuccessorfailurefromresponse ( responseonsingerequest myresponse ) { boolean iscompleted = _bool ; try { if ( myresponse == null || myresponse . isfailobtainresponse ( ) ) { return iscompleted ; } string responsebody = myresponse . getresponsebody ( ) ; if ( responsebody . matches ( successregex ) || responsebody . matches ( failureregex ) ) { iscompleted = _bool ; } } catch ( exception t ) { logger . error ( _str + t ) ; } return iscompleted ; }	if task completed success or failure from response .
public void centerhorizontal ( arraylist < integer > nodes ) { if ( m_bneedsundoaction ) { addundoaction ( new centerhorizontalaction ( nodes ) ) ; } int nminy = - _num ; int nmaxy = - _num ; for ( int inode = _num ; inode < nodes . size ( ) ; inode ++ ) { int ny = getpositiony ( nodes . get ( inode ) ) ; if ( ny < nminy || inode == _num ) { nminy = ny ; } if ( ny > nmaxy || inode == _num ) { nmaxy = ny ; } } for ( int inode = _num ; inode < nodes . size ( ) ; inode ++ ) { int nnode = nodes . get ( inode ) ; m_npositiony . set ( nnode , ( nminy + nmaxy ) / _num ) ; } }	center set of nodes half way between left and right most node in the list.
protected void appendtext ( final string text ) { if ( text != null ) { textbody . append ( text ) ; } }	append text to the outgoing email body .
public void onrestoreinstancestate ( bundle savedinstancestate ) { mselectedpositions . addall ( savedinstancestate . getintegerarraylist ( tag ) ) ; log . d ( tag , _str + mselectedpositions ) ; }	restores the previous state of the selection on the items .
public hour ( int hour , day day ) { paramchecks . nullnotpermitted ( day , _str ) ; this . hour = ( byte ) hour ; this . day = day ; peg ( calendar . getinstance ( ) ) ; }	constructs a new hour .
public void undo ( ) { if ( -- m_tempundoindex < _num ) { m_tempundoindex = m_tempundofiles . length - _num ; } if ( m_tempundofiles [ m_tempundoindex ] != null ) { abstractfileloader loader = converterutils . getloaderforfile ( m_tempundofiles [ m_tempundoindex ] ) ; try { loader . setfile ( m_tempundofiles [ m_tempundoindex ] ) ; setinstancesfromfile ( loader ) ; } catch ( exception e ) { e . printstacktrace ( ) ; m_log . logmessage ( e . tostring ( ) ) ; joptionpane . showmessagedialog ( preprocesspanel . this , _str + e . tostring ( ) , _str , joptionpane . error_message ) ; } m_tempundofiles [ m_tempundoindex ] = null ; } int temp = m_tempundoindex - _num ; if ( temp < _num ) { temp = m_tempundofiles . length - _num ; } m_undobut . setenabled ( m_tempundofiles [ temp ] != null ) ; }	reverts to the last backed up version of the dataset .
public static boolean isconnectedusingwifi ( ) { context context = feapp . getappcontext ( ) ; connectivitymanager cm = ( connectivitymanager ) context . getsystemservice ( context . connectivity_service ) ; networkinfo ni = cm . getactivenetworkinfo ( ) ; return ni != null && ni . isconnected ( ) == _bool && ni . gettype ( ) == connectivitymanager . type_wifi ; }	checks to see if we are connected using wifi.
public void close ( ) throws ioexception { if ( writer != null ) writer . flushbuffer ( ) ; }	done with this responsewriter.
public boolean isempty ( ) { return extordering . isempty ( ) ; }	return true if there are no extension present in this generator .
public process ( final file file , final progresslistener progresslistener ) throws ioexception , xmlexception { this . processlocation = new fileprocesslocation ( file ) ; initcontext ( ) ; reader in = null ; try { in = new inputstreamreader ( new fileinputstream ( file ) , _str ) ; readprocess ( in , progresslistener ) ; } catch ( ioexception e ) { throw e ; } finally { if ( in != null ) { in . close ( ) ; } } }	creates a new process from the given process file.
public static string extractmusicidfrommediaid ( @ nonnull string mediaid ) { int pos = mediaid . indexof ( leaf_separator ) ; if ( pos >= _num ) { return mediaid . substring ( pos + _num ) ; } return null ; }	extracts unique musicid from the mediaid.
public void testgetscope ( ) throws exception { identity i = new identitystub ( _str ) ; assertnull ( i . getscope ( ) ) ; identityscope s = identityscope . getsystemscope ( ) ; identity i2 = new identitystub ( _str , s ) ; assertsame ( s , i2 . getscope ( ) ) ; }	verify identity . getscope ( ) returns identity ' s scope.
public object [ ] buildparameters ( object [ ] firstparameters , method method , class < ? extends annotation > annotationtype ) { int parameterslength = method . getparametertypes ( ) . length ; if ( firstparameters . length > _num && parameterslength < _num ) { throw new repositorymethodexception ( string . format ( _str , annotationtype ) ) ; } int parameterstoresolve = parameterslength - firstparameters . length ; object [ ] additionalparameters = new object [ parameterstoresolve ] ; for ( int i = firstparameters . length ; i < parameterslength ; i ++ ) { additionalparameters [ i - firstparameters . length ] = parameterprovider . provide ( method , i ) ; } return concatenate ( firstparameters , additionalparameters ) ; }	build a list of parameters that can be provided to a method .
@ override public boolean contains ( s2cell cell ) { return contains ( cell . id ( ) ) ; }	this is a fast operation ( logarithmic in the size of the cell union ) .
public simplexnoisegenerator ( random rand ) { super ( rand ) ; offsetw = rand . nextdouble ( ) * _num ; }	creates a seeded simplex noise generator with the given random.
public static long [ ] values ( long [ ] array ) { long [ ] dest = new long [ array . length ] ; for ( int i = _num ; i < array . length ; i ++ ) { long v = array [ i ] ; if ( v != null ) { dest [ i ] = v . longvalue ( ) ; } } return dest ; }	converts to primitive array .
@ override public void processnewlines ( string [ ] lines ) { for ( string line : lines ) { if ( line . startswith ( _str ) ) { continue ; } if ( line . contains ( _str ) ) { myisfilemissing = _bool ; return ; } string [ ] values = line . split ( line_split_regex ) ; if ( values . length < index_of_tx_bytes ) { continue ; } try { int lineuid = integer . parseint ( values [ index_of_uid ] ) ; if ( myuid == lineuid ) { int temprxbytes = integer . parseint ( values [ index_of_rx_bytes ] ) ; int temptxbytes = integer . parseint ( values [ index_of_tx_bytes ] ) ; if ( temprxbytes < _num || temptxbytes < _num ) { log . warning ( string . format ( _str , temprxbytes , temptxbytes , line ) ) ; continue ; } myrxbytes += temprxbytes ; mytxbytes += temptxbytes ; } } catch ( numberformatexception e ) { log . warning ( string . format ( _str , values [ index_of_uid ] , values [ index_of_rx_bytes ] , values [ index_of_tx_bytes ] , line ) ) ; } } }	processes the stats line to sum up all network stats belonging to the uid .
protected void initlookup ( ) { m_lookup = new hashmap ( ) ; for ( int i = _num ; i < m_names . length ; ++ i ) { m_lookup . put ( m_names [ i ] , new integer ( i ) ) ; } }	lazily construct the lookup table for this schema.
public string tostring ( ) { string str = _str ; string followedby = _str ; int lasttype = - _num ; string laststring = _str ; int singlescount = _num ; for ( enumeration e = formatconstraints . elements ( ) ; e . hasmoreelements ( ) ; ) { formatconstraint constraint = ( formatconstraint ) e . nextelement ( ) ; if ( constraint . count == formatconstraint . count_exactly_one ) { if ( lasttype != - _num ) { if ( lasttype != constraint . type ) { str += followedby + singlescount + laststring ; followedby = _str ; singlescount = _num ; lasttype = constraint . type ; laststring = constraint . tostring ( ) ; } else { singlescount ++ ; } } else { lasttype = constraint . type ; laststring = constraint . tostring ( ) ; singlescount = _num ; } } else { if ( lasttype != - _num ) { str += followedby + singlescount + laststring ; followedby = _str ; lasttype = - _num ; singlescount = _num ; laststring = _str ; } str += followedby + constraint . tostring ( ) ; followedby = _str ; } } if ( lasttype != - _num ) { str += followedby + singlescount + laststring ; } return str ; }	a printout of a user - friendly string describing the format.
public void readdata ( datainput din ) throws ioexception { din . readshort ( ) ; count = din . readunsignedshort ( ) ; registers = new inputregister [ count ] ; for ( int i = _num ; i < count ; i ++ ) { registers [ i ] = new simpleinputregister ( din . readshort ( ) ) ; } }	readdata - - input the modbus message from din.
public void adjustindentation ( int delta ) { if ( delta < _num ) { indentationlevel = math . max ( _num , indentationlevel + delta ) ; } else { indentationlevel += delta ; } }	adjusts the current indentation level of this log stream .
public int capacity ( ) { return capacity . get ( ) ; }	retrieves the maximum capacity of the map .
protected static token do_code_string ( ) throws java . io . ioexception { stringbuffer result = new stringbuffer ( ) ; advance ( ) ; advance ( ) ; while ( ! ( next_char == _str && next_char2 == _str ) ) { if ( next_char == eof_char ) { emit_error ( _str ) ; break ; } result . append ( new character ( ( char ) next_char ) ) ; advance ( ) ; } advance ( ) ; advance ( ) ; return new str_token ( sym . code_string , result . tostring ( ) ) ; }	swallow up a code string.
public string random ( object omin , object omax ) { int min = functionhandler . getint ( omin ) ; int max = functionhandler . getint ( omax ) ; if ( max > min ) { return integer . tostring ( rnd . nextint ( max - min ) + min ) ; } return _str ; }	returns a random number between min ( inclusive ) and max ( exclusive ).
public void test_reopen01 ( ) { final irawstore store = new simplememoryrawstore ( ) ; final btree btree ; { indexmetadata md = new indexmetadata ( uuid . randomuuid ( ) ) ; md . setbranchingfactor ( _num ) ; btree = btree . create ( store , md ) ; } asserttrue ( btree . isopen ( ) ) ; btree . close ( ) ; assertfalse ( btree . isopen ( ) ) ; try { btree . close ( ) ; fail ( _str + illegalstateexception . class ) ; } catch ( illegalstateexception ex ) { if ( log . isinfoenabled ( ) ) log . info ( _str + ex ) ; } assertnotnull ( btree . getroot ( ) ) ; asserttrue ( btree . isopen ( ) ) ; }	test close on a new tree - should force the root to the store since a new root is dirty ( if empty ).
public static file searchpaths ( iterable < ? extends file > paths , string relfile ) { for ( file path : paths ) { file f = new file ( path , relfile ) ; if ( f . exists ( ) ) { return path ; } } return null ; }	given a relative file path and a list of " search paths " returns the search path where the file was located.
public boolean hasunsupportedcriticalextension ( ) { set extns = getcriticalextensionoids ( ) ; return extns != null && ! extns . isempty ( ) ; }	will return true if any extensions are present and marked as critical as we currently don ' t handle any extensions !.
@ override public stringbuffer format ( double value , stringbuffer buffer , fieldposition field ) { for ( int i = choicelimits . length - _num ; i >= _num ; i -- ) { if ( choicelimits [ i ] <= value ) { return buffer . append ( choiceformats [ i ] ) ; } } return choiceformats . length == _num ? buffer : buffer . append ( choiceformats [ _num ] ) ; }	appends the string associated with the range in which the specified double value fits to the specified string buffer .
private void loadconfigurationfromjvmparameters ( ) { string repositoryproperty = system . getproperty ( repository_property ) ; if ( null != repositoryproperty ) { string [ ] repositoryiphost = repositoryproperty . split ( _str ) ; if ( repositoryiphost . length == _num ) { string repositoryip = repositoryiphost [ _num ] ; string repositoryport = repositoryiphost [ _num ] ; if ( stringutils . isnotblank ( repositoryip ) && stringutils . isnotblank ( repositoryport ) ) { log . info ( _str + repositoryip + _str + repositoryport ) ; try { int port = integer . parseint ( repositoryport ) ; setrepository ( repositoryip , port ) ; } catch ( exception e ) { log . warn ( _str , e ) ; } } } } string agentname = system . getproperty ( agent_name_property ) ; if ( stringutils . isnotblank ( agentname ) ) { try { log . info ( _str + agentname ) ; setagentname ( agentname ) ; } catch ( exception e ) { log . warn ( _str , e ) ; } } else { try { setagentname ( default_agent_name ) ; } catch ( storageexception e ) { log . warn ( _str , e ) ; } } }	checks if the jvm parameters have the repository and agent information .
public boolean softsignin ( ) throws ioexception { if ( url == null ) { throw new illegalstateexception ( _str ) ; } checkresolvehost ( ) ; if ( sessionid != null ) { if ( checkauthorized ( getauthcheckurl ( sessionid ) ) ) { logger . fine ( _str + sessionid ) ; return _bool ; } else { sessionid = null ; } } long id = loadsessionid ( ) ; if ( id == _num ) { return _bool ; } boolean authorized = checkauthorized ( getauthcheckurl ( id ) ) ; if ( authorized ) { logger . info ( _str + id ) ; this . sessionid = id ; } return authorized ; }	if the user can be authenticated due to an existing session id , do so.
private void testviewalterandcommandcache ( ) throws sqlexception { deletedb ( _str ) ; connection conn = getconnection ( _str ) ; statement stat = conn . createstatement ( ) ; stat . execute ( _str ) ; stat . execute ( _str ) ; stat . execute ( _str ) ; stat . execute ( _str ) ; stat . execute ( _str ) ; resultset rs = stat . executequery ( _str ) ; asserttrue ( rs . next ( ) ) ; assertequals ( _num , rs . getint ( _num ) ) ; stat . execute ( _str ) ; rs = stat . executequery ( _str ) ; asserttrue ( rs . next ( ) ) ; assertequals ( _num , rs . getint ( _num ) ) ; conn . close ( ) ; deletedb ( _str ) ; }	make sure that when we change a view , that change in reflected in other sessions command cache .
protected static boolean approxunit ( final stringbuilder sbuf , final int amount , final int size , final string name ) { int count = amount / size ; int remainder ; if ( count == _num ) { return _bool ; } remainder = amount - ( count * size ) ; if ( remainder >= ( size * _num / _num ) ) { count ++ ; sbuf . append ( count ) ; } else if ( remainder >= ( size * _num / _num ) ) { count ++ ; sbuf . append ( _str ) ; sbuf . append ( count ) ; } else if ( remainder >= ( size * _num / _num ) ) { sbuf . append ( _str ) ; sbuf . append ( count ) ; sbuf . append ( _str ) ; count = _num ; } else if ( remainder >= ( size * _num / _num ) ) { sbuf . append ( _str ) ; sbuf . append ( count ) ; } else { sbuf . append ( count ) ; } sbuf . append ( _str ) ; sbuf . append ( grammar . plnoun ( count , name ) ) ; return _bool ; }	for a given amount and unit size , generate the approximate value .
public static element createelement ( document doc , string tag , string nsuri , string prefix ) { string qname = ( prefix == null || prefix . length ( ) == _num ) ? tag : prefix + _str + tag ; return doc . createelementns ( nsuri , qname ) ; }	creates an element in the specified namespace , with the specified tag and namespace prefix .
public static void modifyfile ( file file , function < string , string > modifier ) throws ioexception { string content = new string ( files . tobytearray ( file ) , standardcharsets . utf_8 ) ; string result = modifier . apply ( content ) ; files . write ( result . getbytes ( standardcharsets . utf_8 ) , file ) ; }	modifies the given file in place .
private void state2 ( ) throws ioexception { int [ ] selectionids = readlist ( new file ( fileprefix + _str ) ) ; int [ ] archivedids = readlist ( new file ( fileprefix + _str ) ) ; int [ ] variationids = new int [ lambda ] ; if ( selectionids . length != mu ) { throw new ioexception ( _str ) ; } updatepopulation ( archivedids ) ; clearfile ( new file ( fileprefix + _str ) ) ; clearfile ( new file ( fileprefix + _str ) ) ; list < solution > offspring = new arraylist < solution > ( ) ; for ( int i = _num ; i < mu ; i += variation . getarity ( ) ) { solution [ ] parents = new solution [ variation . getarity ( ) ] ; for ( int j = _num ; j < variation . getarity ( ) ; j ++ ) { parents [ j ] = solutions . get ( selectionids [ i + j ] ) ; } offspring . addall ( arrays . aslist ( variation . evolve ( parents ) ) ) ; } if ( offspring . size ( ) != lambda ) { throw new ioexception ( _str ) ; } evaluateall ( offspring ) ; for ( int i = _num ; i < lambda ; i ++ ) { variationids [ i ] = addtopopulation ( offspring . get ( i ) ) ; } writepopulation ( new file ( fileprefix + _str ) , variationids ) ; }	the commands to execute when in state 2 .
public void testlistoptions ( ) { if ( m_optiontester . getoptionhandler ( ) != null ) { if ( ! m_optiontester . checklistoptions ( ) ) fail ( _str ) ; } }	tests the listing of the options.
protected double lltoworldreturninglon ( double lat , double lon , point2d lp ) { double phi_deg = lat ; double phi = projmath . degtorad ( phi_deg ) ; double lamba_deg = lon ; double lamba = projmath . degtorad ( lamba_deg ) ; double dlamda = lamba - lamdaf ; if ( dlamda > math . pi ) { dlamda -= moremath . two_pi_d ; } else if ( dlamda < - math . pi ) { dlamda += moremath . two_pi_d ; } double e = ellps . ecc ; double r = _num ; if ( ! moremath . approximately_equal ( math . abs ( phi ) , moremath . half_pi , eps10 ) ) { double t = lambtsfn ( phi , math . sin ( phi ) , e ) ; r = ellps . radius * f * math . pow ( t , n ) ; } double theta = n * dlamda ; double easting = falseeasting + r * math . sin ( theta - alpha ) ; double northing = falsenorthing + rf - r * math . cos ( theta - alpha ) ; lp . setlocation ( easting , northing ) ; return dlamda ; }	lltoworld that returns normalized longitude in radians , to be used for more calculations in some methods.
protected void notifysizechanged ( float width , float height , int orientation ) { }	notifies when the size or the orientation of the view has actually changed .
protected boolean removeturntable ( layoutturntable o ) { if ( ! nowarnturntable ) { int selectedvalue = joptionpane . showoptiondialog ( this , rb . getstring ( _str ) , bundle . getmessage ( _str ) , joptionpane . yes_no_cancel_option , joptionpane . question_message , null , new object [ ] { bundle . getmessage ( _str ) , bundle . getmessage ( _str ) , rb . getstring ( _str ) } , bundle . getmessage ( _str ) ) ; if ( selectedvalue == _num ) { return ( _bool ) ; } if ( selectedvalue == _num ) { nowarnturntable = _bool ; } } if ( selectedobject == o ) { selectedobject = null ; } if ( prevselectedobject == o ) { prevselectedobject = null ; } for ( int j = _num ; j < o . getnumberrays ( ) ; j ++ ) { tracksegment t = o . getrayconnectordered ( j ) ; if ( t != null ) { substituteanchor ( o . getraycoordsindexed ( j ) , o , t ) ; } } for ( int i = _num ; i < turntablelist . size ( ) ; i ++ ) { layoutturntable lx = turntablelist . get ( i ) ; if ( lx == o ) { turntablelist . remove ( i ) ; o . remove ( ) ; setdirty ( _bool ) ; repaint ( ) ; return ( _bool ) ; } } return ( _bool ) ; }	remove a layout turntable.
@ override public final void endelement ( final string ns , final string lname , final string qname ) throws saxexception { string name = lname == null || lname . length ( ) == _num ? qname : lname ; rule r = ( rule ) rules . match ( match ) ; if ( r != null ) { r . end ( name ) ; } int slash = match . lastindexof ( _str ) ; if ( slash >= _num ) { match = match . substring ( _num , slash ) ; } else { match = _str ; } }	process notification of the end of an xml element being reached .
public indarray asmatrix ( bufferedimage image ) { if ( channels == _num ) { return tobgr ( image ) ; } else { image = scalingifneed ( image , _bool ) ; int w = image . getwidth ( ) ; int h = image . getheight ( ) ; indarray ret = nd4j . create ( h , w ) ; for ( int i = _num ; i < h ; i ++ ) { for ( int j = _num ; j < w ; j ++ ) { ret . putscalar ( new int [ ] { i , j } , image . getrgb ( i , j ) ) ; } } return ret ; } }	convert an bufferedimage to a matrix.
public filesystemutils ( ) { super ( ) ; }	instances should not be constructed in standard programming .
public int scheduledqueuesize ( ) { return schedulerqueuesize . get ( ) ; }	get the total number of scheduled requests .
public dgeneralnamechooser ( jframe parent , string title , generalname generalname ) { super ( parent , title , modalitytype . document_modal ) ; initcomponents ( generalname ) ; }	constructs a new dgeneralnamechooser dialog .
public void destroyscene ( ) { clearanimations ( ) ; clearcameras ( ) ; clearlights ( ) ; clearplugins ( ) ; clearchildren ( ) ; clearframecallbacks ( ) ; }	clears any references the scene is holding for its contents.
private void addlimitedmitrejoin ( linesegment offset0 , linesegment offset1 , double distance , double mitrelimit ) { coordinate basept = seg0 . p1 ; double ang0 = angle . angle ( basept , seg0 . p0 ) ; double ang1 = angle . angle ( basept , seg1 . p1 ) ; double angdiff = angle . anglebetweenoriented ( seg0 . p0 , basept , seg1 . p1 ) ; double angdiffhalf = angdiff / _num ; double midang = angle . normalize ( ang0 + angdiffhalf ) ; double mitremidang = angle . normalize ( midang + math . pi ) ; double mitredist = mitrelimit * distance ; double beveldelta = mitredist * math . abs ( math . sin ( angdiffhalf ) ) ; double bevelhalflen = distance - beveldelta ; double bevelmidx = basept . x + mitredist * math . cos ( mitremidang ) ; double bevelmidy = basept . y + mitredist * math . sin ( mitremidang ) ; coordinate bevelmidpt = new coordinate ( bevelmidx , bevelmidy ) ; linesegment mitremidline = new linesegment ( basept , bevelmidpt ) ; coordinate bevelendleft = mitremidline . pointalongoffset ( _num , bevelhalflen ) ; coordinate bevelendright = mitremidline . pointalongoffset ( _num , - bevelhalflen ) ; if ( side == position . left ) { seglist . addpt ( bevelendleft ) ; seglist . addpt ( bevelendright ) ; } else { seglist . addpt ( bevelendright ) ; seglist . addpt ( bevelendleft ) ; } }	adds a limited mitre join connecting the two reflex offset segments.
static byte [ ] discardnonbase64 ( byte [ ] data ) { byte groomeddata [ ] = new byte [ data . length ] ; int bytescopied = _num ; for ( int i = _num ; i < data . length ; i ++ ) { if ( isbase64 ( data [ i ] ) ) { groomeddata [ bytescopied ++ ] = data [ i ] ; } } byte packeddata [ ] = new byte [ bytescopied ] ; system . arraycopy ( groomeddata , _num , packeddata , _num , bytescopied ) ; return packeddata ; }	discards any characters outside of the base64 alphabet , per the requirements on page 25 of rfc 2045 - " any characters outside of the base64 alphabet are to be ignored in base64 encoded data . ".
public void testmultiplydiffscaleposneg ( ) { string a = _str ; int ascale = _num ; string b = _str ; int bscale = - _num ; string c = _str ; int cscale = _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; bigdecimal result = anumber . multiply ( bnumber ) ; assertequals ( _str , c , result . tostring ( ) ) ; assertequals ( _str , cscale , result . scale ( ) ) ; }	multiply two numbers of different scales.
private static long limitduration ( long leaseduration , long limit ) { if ( leaseduration == lease . any || leaseduration > limit ) leaseduration = limit ; else if ( leaseduration < _num ) throw new illegalargumentexception ( _str ) ; return leaseduration ; }	limit leaseduration by limit , and check for negative value .
static string pathtocookiepath ( string path ) { if ( path == null ) { return _str ; } int lastslash = path . lastindexof ( _str ) ; return path . substring ( _num , lastslash + _num ) ; }	returns a cookie - safe path by truncating everything after the last " / ".
public static string formatsimpledecimal ( double d ) { return simpleformat . format ( d ) ; }	returns string from double formatted to decimalformat ( " # # # . # # " ).
protected abstractcategoryitemlabelgenerator ( string labelformat , dateformat formatter ) { paramchecks . nullnotpermitted ( labelformat , _str ) ; paramchecks . nullnotpermitted ( formatter , _str ) ; this . labelformat = labelformat ; this . numberformat = null ; this . percentformat = numberformat . getpercentinstance ( ) ; this . dateformat = formatter ; this . nullvaluestring = _str ; }	creates a label generator with the specified date formatter .
static long makeid ( snmpoid oid ) { long id = _num ; long [ ] arcs = oid . longvalue ( _bool ) ; id |= arcs [ _num ] << _num ; id |= arcs [ _num ] << _num ; id |= arcs [ _num ] << _num ; id |= arcs [ _num ] << _num ; id |= arcs [ _num ] << _num ; id |= arcs [ _num ] << _num ; id |= arcs [ _num ] << _num ; id |= arcs [ _num ] ; return id ; }	translate an oid to a thread id.
private void cacheattribute ( string attrid , byte [ ] [ ] values ) { string cachekey = name + _str + attrid ; valuecache . put ( cachekey , values ) ; }	add the values to the cache .
void read ( reader policy ) throws parsingexception , ioexception { if ( ! ( policy instanceof bufferedreader ) ) { policy = new bufferedreader ( policy ) ; } st = new streamtokenizer ( policy ) ; st . resetsyntax ( ) ; st . wordchars ( _str , _str ) ; st . wordchars ( _str , _str ) ; st . wordchars ( _str , _str ) ; st . wordchars ( _str , _str ) ; st . wordchars ( _str , _str ) ; st . wordchars ( _str , _str ) ; st . wordchars ( _num + _num , _num ) ; st . whitespacechars ( _num , _str ) ; st . commentchar ( _str ) ; st . quotechar ( _str ) ; st . quotechar ( _str ) ; st . lowercasemode ( _bool ) ; st . ordinarychar ( _str ) ; st . slashslashcomments ( _bool ) ; st . slashstarcomments ( _bool ) ; st . parsenumbers ( ) ; hashtable < string , vector < string > > processedpermissions = null ; lookahead = st . nexttoken ( ) ; while ( lookahead != streamtokenizer . tt_eof ) { if ( peek ( _str ) ) { grantentry ge = parsegrantentry ( processedpermissions ) ; if ( ge != null ) grantentries . addelement ( ge ) ; } else { throw new parsingexception ( st . lineno ( ) , _str + _str ) ; } match ( _str ) ; } }	reads a policy configuration using a reader object . < p >.
protected void injectintovolumeinformationcontainer ( map < string , stringset > volumeinformation , string infokey , string altkey , ciminstance volumeinstance ) { object value = getcimpropertyvalue ( volumeinstance , infokey ) ; if ( null == value ) { value = getcimpropertyvalue ( volumeinstance , altkey ) ; } string charactersticname = supportedvolumeinformation . getvolumeinformation ( infokey ) ; if ( null != value && null != charactersticname ) { stringset valueset = new stringset ( ) ; if ( value instanceof string ) { valueset . add ( value . tostring ( ) ) ; } else if ( value instanceof string [ ] ) { valueset . addall ( arrays . aslist ( ( string [ ] ) value ) ) ; } volumeinformation . put ( charactersticname , valueset ) ; } }	extract value from provider for given volume info key , and then get its name and use that to inject to map .
@ override public void ondetachedfromrecyclerview ( recyclerview recyclerview ) { super . ondetachedfromrecyclerview ( recyclerview ) ; mattachedrecyclerviewpool . remove ( recyclerview ) ; }	implementation of adapter . ondetachedfromrecyclerview ( recyclerview ) < p > called when this expandablerecycleradapter is detached from a recyclerview .
private void loadfile ( string filename , abstractfileloader ... loaders ) { arffsortedtablemodel model ; this . m_filename = filename ; createtitle ( ) ; if ( filename . equals ( _str ) ) { model = null ; } else { model = new arffsortedtablemodel ( filename , loaders ) ; model . setshowattributeindex ( getshowattributeindex ( ) ) ; } m_tablearff . setmodel ( model ) ; setchanged ( _bool ) ; createname ( ) ; }	loads the specified file into the table.
public static inputstream trygzipinput ( inputstream in ) throws ioexception { if ( ! in . marksupported ( ) ) { pushbackinputstream pb = new pushbackinputstream ( in , _num ) ; in = pb ; byte [ ] magic = { _num , _num } ; pb . read ( magic ) ; pb . unread ( magic ) ; if ( magic [ _num ] == _num && magic [ _num ] == - _num ) { return new gzipinputstream ( pb ) ; } return in ; } in . mark ( _num ) ; boolean isgzip = ( in . read ( ) == _num && in . read ( ) == - _num ) ; in . reset ( ) ; if ( isgzip ) { in = new gzipinputstream ( in ) ; } return in ; }	try to open a stream as gzip , if it starts with the gzip magic.
@ override public int hashcode ( ) { if ( location != null ) return location . hashcode ( ) ; else return _num ; }	returns the hash code value for this object .
public static query newprefixquery ( string field , inetaddress value , int prefixlength ) { if ( value == null ) { throw new illegalargumentexception ( _str ) ; } if ( prefixlength < _num || prefixlength > _num * value . getaddress ( ) . length ) { throw new illegalargumentexception ( _str + prefixlength + _str ) ; } byte lower [ ] = value . getaddress ( ) ; byte upper [ ] = value . getaddress ( ) ; for ( int i = prefixlength ; i < _num * lower . length ; i ++ ) { int m = _num << ( _num - ( i & _num ) ) ; lower [ i > > _num ] &= ~ m ; upper [ i > > _num ] |= m ; } try { return newrangequery ( field , inetaddress . getbyaddress ( lower ) , inetaddress . getbyaddress ( upper ) ) ; } catch ( unknownhostexception e ) { throw new assertionerror ( e ) ; } }	create a prefix query for matching a cidr network range .
public static subject createamidentitysubject ( policymanager pm , amidentity user ) throws policyexception { subjecttypemanager mgr = pm . getsubjecttypemanager ( ) ; subject subject = mgr . getsubject ( _str ) ; set < string > set = new hashset < string > ( ) ; set . add ( user . getuniversalid ( ) ) ; subject . setvalues ( set ) ; return subject ; }	returns a subject for the given amidentity .
protected void expandfor ( int index , double d ) { if ( index < size ) return ; int oldsize = size , capacity = vector . length ; size = index + _num ; if ( capacity >= size ) return ; while ( capacity < size ) capacity *= _num ; double [ ] t = new double [ capacity ] ; system . arraycopy ( vector , _num , t , _num , oldsize ) ; if ( d != _num ) arrays . fill ( t , oldsize , size , d ) ; vector = t ; }	makes sure the capacity and size of the vector can accomodate the given index.
private void donormalcommandlinelist ( list < string > commandlinelist , list < string > jointoptions , path classpath ) { commandlinelist . add ( _str ) ; commandlinelist . add ( classpath . tostring ( ) ) ; if ( jointcompilation ) { commandlinelist . add ( _str ) ; commandlinelist . addall ( jointoptions ) ; } if ( destdir != null ) { commandlinelist . add ( _str ) ; commandlinelist . add ( destdir . getpath ( ) ) ; } if ( encoding != null ) { commandlinelist . add ( _str ) ; commandlinelist . add ( encoding ) ; } if ( stacktrace ) { commandlinelist . add ( _str ) ; } if ( parameters ) { commandlinelist . add ( _str ) ; } if ( useindy ) { commandlinelist . add ( _str ) ; } if ( scriptbaseclass != null ) { commandlinelist . add ( _str ) ; commandlinelist . add ( scriptbaseclass ) ; } if ( configscript != null ) { commandlinelist . add ( _str ) ; commandlinelist . add ( configscript ) ; } }	add " groovyc " parameters to the commandlinelist , based on the ant configuration .
private synchronized void loadheximage ( ihex hex ) { hextileset . assignmatch ( hex , boardview ) ; hextileset . trackheximages ( hex , tracker ) ; }	loads the image ( s ) for this hex into the tracker .
public void triangulate ( pointset ps ) { _triangulations . clear ( ) ; _triangulations . add ( ps ) ; start ( ) ; }	triangulate a pointset with eventual constraints.
public string base64urlencode ( byte [ ] data ) { string encodeddata = new string ( base64 . encode ( data , base64 . url_safe ) ) ; encodeddata = encodeddata . replace ( _str , _str ) ; encodeddata = encodeddata . replace ( _str , _str ) ; return encodeddata ; }	encodes a string with base64url encoding it also removes characters which must be removed according to the jose spec : http : / / tools.
private void writejavafieldspec ( javafieldspec spec , document document , element parentelement ) { element parameter = document . createelement ( _str ) ; parameter . appendchild ( parentelement ) ; parameter . setattribute ( _str , spec . getpackagename ( ) ) ; parameter . setattribute ( _str , spec . getclassname ( ) ) ; parameter . setattribute ( _str , spec . getfieldname ( ) ) ; }	writes out a source / sink specification object for java static fields.
private void readobject ( objectinputstream s ) throws ioexception , classnotfoundexception { s . defaultreadobject ( ) ; init ( getmask ( actions ) ) ; }	readobject is called to restore the state of the filepermission from a stream .
@ override public synchronized void parse ( reader reader , string baseuri ) throws ioexception , rdfparseexception , rdfhandlerexception { if ( reader == null ) { throw new illegalargumentexception ( _str ) ; } if ( baseuri == null ) { throw new illegalargumentexception ( _str ) ; } inputsource inputsource = new inputsource ( reader ) ; inputsource . setsystemid ( baseuri ) ; parse ( inputsource ) ; }	parses the data from the supplied reader , using the supplied baseuri to resolve any relative uri references .
private string excludedestinationstatement ( string text ) { int idx = - _num ; if ( ( idx = text . indexof ( _str ) ) != - _num ) { text = text . substring ( _num , idx ) ; } return text ; }	parses the specified string to return the portion not containing the destination statement.
protected static final string addescapes ( string str ) { stringbuilder retval = new stringbuilder ( ) ; char ch ; for ( int i = _num ; i < str . length ( ) ; i ++ ) { switch ( str . charat ( i ) ) { case _num : continue ; case _str : retval . append ( _str ) ; continue ; case _str : retval . append ( _str ) ; continue ; case _str : retval . append ( _str ) ; continue ; case _str : retval . append ( _str ) ; continue ; case _str : retval . append ( _str ) ; continue ; case _str : retval . append ( _str ) ; continue ; case _str : retval . append ( _str ) ; continue ; case _str : retval . append ( _str ) ; continue ; default : if ( ( ch = str . charat ( i ) ) < _num || ch > _num ) { string s = _str + integer . tostring ( ch , _num ) ; retval . append ( _str + s . substring ( s . length ( ) - _num , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . tostring ( ) ; }	replaces unprintable characters by their escaped ( or unicode escaped ) equivalents in the given string.
public static void addfile ( string s ) throws ioexception { file f = new file ( s ) ; addfile ( f ) ; }	adds a file to the classpath .
@ safevarargs public final void insert ( int rowindex , t ... newitems ) { insert ( rowindex , arrays . aslist ( newitems ) ) ; }	insert new records at a specified index .
@ deprecated public void put ( collection < integer > data ) { for ( integer value : data ) { final int val = value . intvalue ( ) ; min = val < min ? val : min ; max = val > max ? val : max ; } }	process a whole collection of integer values.
public intbuffer majorversionbuffer ( ) { int [ ] holder = new int [ _num ] ; holder [ _num ] = getmajorversion ( ) ; intbuffer ib = intbuffer . wrap ( holder ) ; ib . limit ( _num ) ; return ib ; }	return an intbuffer that accesses the major version number.
public createindexrequest source ( xcontentbuilder source ) { return source ( source . bytes ( ) ) ; }	sets the settings and mappings as a single source .
public static byte [ ] createdatatosign ( byte [ ] digest ) { byte [ ] prefix = getdigestinfoprefix ( digest ) ; byte [ ] digestinfo = new byte [ prefix . length + digest . length ] ; system . arraycopy ( prefix , _num , digestinfo , _num , prefix . length ) ; system . arraycopy ( digest , _num , digestinfo , prefix . length , digest . length ) ; return digestinfo ; }	creates data to be signed from the digest .
public httprequest ifmodifiedsince ( final long value ) { connection . setifmodifiedsince ( value ) ; return this ; }	set the ' if - modified - since ' request header to the given value.
public static string tmpjournal ( ) { final file file = code . wrapthrow ( null ) ; file . deleteonexit ( ) ; return file . getabsolutepath ( ) ; }	create a tmp journal file for test cases .
public static object newinstance ( class < ? > cl , int [ ] dims ) { if ( dims . length == _num ) { dims = new int [ ] { _num } ; } return array . newinstance ( cl , dims ) ; }	allocate an array dynamically.
public void playtogether ( collection < animator > items ) { if ( items != null && items . size ( ) > _num ) { mneedssort = _bool ; builder builder = null ; for ( animator anim : items ) { if ( builder == null ) { builder = play ( anim ) ; } else { builder . with ( anim ) ; } } } }	sets up this animatorset to play all of the supplied animations at the same time .
protected static void printerrormessage ( exception e ) { if ( e instanceof abortexception ) { loggingconfiguration . setverbose ( level . verbose ) ; log . verbose ( e . getmessage ( ) ) ; } else if ( e instanceof unspecifiedparameterexception ) { log . error ( e . getmessage ( ) ) ; } else if ( e instanceof parameterexception ) { log . error ( e . getmessage ( ) ) ; } else { log . exception ( e ) ; } }	print an error message for the given error .
public string requeststatistics ( ) { sb . setlength ( _num ) ; makestringbuffer ( sb ) ; return sb . tostring ( ) ; }	a method for other parts of the application to get stats the command processor uses this to report stats on request.
private void applyl1reg ( final double eta_t , vec x ) { if ( lambda1 > _num ) { l1u += eta_t * lambda1 ; for ( int k = _num ; k < ws . length ; k ++ ) { final vec w_k = ws [ k ] ; final double [ ] l1q_k = l1q [ k ] ; for ( indexvalue iv : x ) { final int i = iv . getindex ( ) ; final double z = w_k . get ( i ) ; double neww_i = _num ; if ( z > _num ) neww_i = math . max ( _num , z - ( l1u + l1q_k [ i ] ) ) ; else if ( z < _num ) neww_i = math . min ( _num , z + ( l1u - l1q_k [ i ] ) ) ; l1q_k [ i ] += ( neww_i - z ) ; w_k . set ( i , neww_i ) ; } } } }	applies l1 regularization to the model.
@ override public void keypressed ( keyevent e ) { synchronized ( keylock ) { keysdown . add ( e . getkeycode ( ) ) ; } }	this method cannot be called directly .
public static string slurpurlnoexceptions ( url u , string encoding ) { try { return slurpurl ( u , encoding ) ; } catch ( exception e ) { e . printstacktrace ( ) ; return null ; } }	returns all the text at the given url .
public static moveparticipant [ ] loadmoveparticipants ( refactoringstatus status , refactoringprocessor processor , object element , movearguments arguments , iparticipantdescriptorfilter filter , string [ ] affectednatures , sharableparticipants shared ) { refactoringparticipant [ ] participants = fgmoveextensions . getparticipants ( status , processor , element , arguments , filter , affectednatures , shared ) ; moveparticipant [ ] result = new moveparticipant [ participants . length ] ; system . arraycopy ( participants , _num , result , _num , participants . length ) ; return result ; }	loads the move participants for the given element .
private long [ ] determinepreferencevector ( relation < v > relation , modifiabledbids [ ] neighborids , stringbuilder msg ) { if ( strategy . equals ( strategy . apriori ) ) { return determinepreferencevectorbyapriori ( relation , neighborids , msg ) ; } else if ( strategy . equals ( strategy . max_intersection ) ) { return determinepreferencevectorbymaxintersection ( neighborids , msg ) ; } else { throw new illegalstateexception ( _str ) ; } }	determines the preference vector according to the specified neighbor ids .
private void paintforegrounddisabled ( graphics2d g , int width , int height ) { shape s = decodearrowpath ( width , height ) ; g . setpaint ( disabledcolor ) ; g . fill ( s ) ; }	paint the arrow in disabled state .
public void testflipbitnegativeinside1 ( ) { byte abytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = - _num ; int number = _num ; byte rbytes [ ] = { - _num , _num , - _num , - _num , _num , _num , - _num , - _num , - _num , - _num , _num , _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . flipbit ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , result . signum ( ) ) ; }	flipbit ( int n ) inside a negative number.
private void onuser ( @ notnull tlabsuser absuser ) { user currentuser = null ; user user = null ; if ( absuser instanceof tluser ) { final tluser tluser = ( tluser ) absuser ; if ( tluser . ismutualcontact ( ) ) { currentuser = ( user ) databasemanager . getuserbyid ( tluser . getid ( ) ) ; user = onusercontact ( currentuser , tluser ) ; } else if ( tluser . isdeleted ( ) ) { currentuser = ( user ) databasemanager . getuserbyid ( tluser . getid ( ) ) ; user = onuserdelete ( currentuser , tluser ) ; } else if ( tluser . iscontact ( ) ) { currentuser = ( user ) databasemanager . getuserbyid ( tluser . getid ( ) ) ; user = onuserrequest ( currentuser , tluser ) ; } else if ( tluser . isself ( ) || ! tluser . isbot ( ) ) { currentuser = ( user ) databasemanager . getuserbyid ( tluser . getid ( ) ) ; user = onuserforeign ( currentuser , tluser ) ; } else { botlogger . info ( logtag , _str ) ; } } if ( ( currentuser == null ) && ( user != null ) ) { databasemanager . adduser ( user ) ; } else if ( user != null ) { databasemanager . updateuser ( user ) ; } }	add a user to database.
@ override public boolean hasnext ( ) { log . log ( level . fine , _str ) ; boolean result = ( nextevent != null ) ; log . log ( level . fine , _str , result ) ; return result ; }	check if there are more events.
public static xmpmeta extractxmpmeta ( inputstream is ) { list < section > sections = parse ( is , _bool ) ; if ( sections == null ) { return null ; } for ( section section : sections ) { if ( hasxmpheader ( section . data ) ) { int end = getxmpcontentend ( section . data ) ; byte [ ] buffer = new byte [ end - xmp_header_size ] ; system . arraycopy ( section . data , xmp_header_size , buffer , _num , buffer . length ) ; try { xmpmeta result = xmpmetafactory . parsefrombuffer ( buffer ) ; return result ; } catch ( xmpexception e ) { log . d ( tag , _str , e ) ; return null ; } } } return null ; }	extracts xmpmeta from a jpeg image file stream .
private void initialize ( modelvalidator validator , mclient client ) { if ( client == null ) m_globalvalidators . add ( validator ) ; m_validators . add ( validator ) ; validator . initialize ( this , client ) ; }	initialize and add validator.
void crossover ( bayesnetrepresentation other ) { boolean [ ] bits = new boolean [ m_bits . length ] ; for ( int i = _num ; i < m_bits . length ; i ++ ) { bits [ i ] = m_bits [ i ] ; } int icrossoverpoint = m_bits . length ; do { for ( int i = icrossoverpoint ; i < m_bits . length ; i ++ ) { m_bits [ i ] = bits [ i ] ; } icrossoverpoint = m_random . nextint ( m_bits . length ) ; for ( int i = icrossoverpoint ; i < m_bits . length ; i ++ ) { m_bits [ i ] = other . m_bits [ i ] ; } } while ( hascycles ( ) ) ; calcglobalscore ( ) ; }	apply cross - over operation to bayesnet calculate score and as a side effect sets bayesnet parent sets .
public void reset ( ) { enginereset ( ) ; state = initial ; }	resets the digest for further use .
public perspective createuserperspective ( final string name , final boolean show ) { perspective perspective = model . addperspective ( name , _bool ) ; perspective . store ( context ) ; if ( show ) { showperspective ( name ) ; } return perspective ; }	creates a user - defined perspectives , and possibly switches to this new perspective immediately.
public static double phred ( double error ) { return - _num * math . log10 ( error ) ; }	get a phred - scaled quality value corresponding to the supplied error rate .
public static string of ( ctclass type ) { stringbuffer sbuf = new stringbuffer ( ) ; todescriptor ( sbuf , type ) ; return sbuf . tostring ( ) ; }	returns the descriptor representing the given type .
public abstract string encode ( ) ;	get the string encoded version of this object.
@ safevarargs public final token < tokentype > expect ( tokentype ... expected ) throws simpleparserexception { if ( hastype ( expected ) ) return this ; throw new simpleparserexception ( line , column , _str + arrays . tostring ( expected ) + _str + tostring ( ) ) ; }	ensures that this token has one of the given expected types .
public void testupdate3 ( ) { int newvalue1 = - _num ; int newvalue2 = - _num ; string updatequery = _str + databasecreator . test_table1 + _str + newvalue1 + _str + newvalue2 ; try { int num = statement . executeupdate ( updatequery ) ; assertequals ( _str , numberofrecords , num ) ; string selectquery = _str + databasecreator . test_table1 ; resultset result = statement . executequery ( selectquery ) ; while ( result . next ( ) ) { } result . close ( ) ; } catch ( sqlexception e ) { fail ( _str + e . getmessage ( ) ) ; } }	updatefunctionalitytest # testupdate3 ( ) . updates values in a several columns in the table.
public void testsetnull ( ) throws exception { preparedstatement stmt = connection . preparestatement ( _str ) ; try { stmt . setint ( _num , _num ) ; stmt . setbytes ( _num , null ) ; stmt . executeupdate ( ) ; stmt . setint ( _num , _num ) ; stmt . setbinarystream ( _num , null , _num ) ; stmt . executeupdate ( ) ; stmt . setint ( _num , _num ) ; stmt . setstring ( _num , null ) ; stmt . executeupdate ( ) ; } finally { stmt . close ( ) ; } }	this method checks if we correctly handle assigning null values to blobs .
@ deprecated public boolean isassignablefrom ( type from ) { if ( from == null ) { return _bool ; } if ( type . equals ( from ) ) { return _bool ; } if ( type instanceof class < ? > ) { return rawtype . isassignablefrom ( gson types . getrawtype ( from ) ) ; } else if ( type instanceof parameterizedtype ) { return isassignablefrom ( from , ( parameterizedtype ) type , new hashmap < string , type > ( ) ) ; } else if ( type instanceof genericarraytype ) { return rawtype . isassignablefrom ( gson types . getrawtype ( from ) ) && isassignablefrom ( from , ( genericarraytype ) type ) ; } else { throw buildunexpectedtypeerror ( type , class . class , parameterizedtype . class , genericarraytype . class ) ; } }	check if this type is assignable from the given type .
egdemanddetails insertpenalty ( final bigdecimal chqbouncepenalty , final module module ) { egdemanddetails demanddetail = null ; if ( chqbouncepenalty != null && chqbouncepenalty . compareto ( bigdecimal . zero ) > _num ) { final installment currinstallment = getcurrentinstallment ( module ) ; final egdemandreasonmaster egdemandreasonmaster = demandgenericdao . getdemandreasonmasterbycode ( demandrsn_code_chq_bounce_penalty , module ) ; if ( egdemandreasonmaster == null ) throw new applicationruntimeexception ( _str ) ; final egdemandreason egdemandreason = demandgenericdao . getdmdreasonbydmdreasonmsterinstallandmod ( egdemandreasonmaster , currinstallment , module ) ; if ( egdemandreason == null ) throw new applicationruntimeexception ( _str ) ; demanddetail = egdemanddetails . fromreasonandamounts ( chqbouncepenalty , egdemandreason , bigdecimal . zero ) ; } return demanddetail ; }	method used to insert penalty in egdemanddetail table.
public sampleinfo ( bytebuffer bb ) throws ioexception { numberofchannels = bb . getint ( ) ; samplerate = bb . getint ( ) ; coeffmin = bb . getfloat ( ) ; coeffrange = bb . getfloat ( ) ; postemphasis = bb . getfloat ( ) ; residualfold = bb . getint ( ) ; }	constructs a sample info from the given byte buffer .
public void handlemaintenance ( operation maintop ) { performpendingrequestmaintenance ( ) ; checkandschedulesynchronization ( this . cachedgroupstate . membershipupdatetimemicros ) ; maintop . complete ( ) ; }	invoked by parent during its maintenance interval.
public < t > t time ( callable < t > event ) throws exception { final long starttime = clock . tick ( ) ; try { return event . call ( ) ; } finally { update ( clock . tick ( ) - starttime ) ; } }	times and records the duration of event .
public static boolean ispostjdk7 ( string bytecodeversion ) { return jdk7 . equals ( bytecodeversion ) || jdk8 . equals ( bytecodeversion ) ; }	checks if the specified bytecode version string represents a jdk 1.
public putindextemplaterequest mapping ( string type , object ... source ) { mapping ( type , putmappingrequest . buildfromsimplifieddef ( type , source ) ) ; return this ; }	a specialized simplified mapping source method , takes the form of simple properties definition : ( " field1 " , " type = string , store = true " ) .
private inputstream findtemplate ( string path , string template ) { try { file file = new file ( path , template ) ; if ( file . canread ( ) ) { return new bufferedinputstream ( new fileinputstream ( file . getabsolutepath ( ) ) ) ; } else { return null ; } } catch ( filenotfoundexception fnfe ) { return null ; } }	try to find a template given a normalized path .
@ override public synchronized void initialize ( ) { if ( ! mrootdirectory . exists ( ) ) { if ( ! mrootdirectory . mkdirs ( ) ) { volleylog . e ( _str , mrootdirectory . getabsolutepath ( ) ) ; } return ; } file [ ] files = mrootdirectory . listfiles ( ) ; if ( files == null ) { return ; } for ( file file : files ) { bufferedinputstream fis = null ; try { fis = new bufferedinputstream ( new fileinputstream ( file ) ) ; cacheheader entry = cacheheader . readheader ( fis ) ; entry . size = file . length ( ) ; putentry ( entry . key , entry ) ; } catch ( ioexception e ) { if ( file != null ) { file . delete ( ) ; } } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( ioexception ignored ) { } } } }	initializes the diskbasedcache by scanning for all files currently in the specified root directory.
public void addlistener ( circularprogressviewlistener listener ) { if ( listener != null ) listeners . add ( listener ) ; }	register a circularprogressviewlistener with this view.
public sitestatuscheckthreadimpl ( ) { super ( ) ; urlcheckers = new hashmap ( ) ; }	constructs a sitestatuscheckthreadimpl object based on the configured parameter com.
@ override public void render ( final int type , final graphics2d g2 , final float scaling , final boolean isformglyph ) { glyphdisplay . setscalingvalues ( _num , _num , scaling ) ; final float oldglyphscale = glyphscale ; if ( isformglyph ) { glyphscale = scaling * glyphscale ; } affinetransform aff = null ; if ( glyphscale != _num ) { aff = g2 . gettransform ( ) ; g2 . scale ( glyphscale , glyphscale ) ; } glyphdisplay . setg2 ( g2 ) ; glyphdisplay . paint ( null , null , null ) ; if ( aff != null ) { g2 . settransform ( aff ) ; } glyphscale = oldglyphscale ; }	draw the t3 glyph.
public list < string > reset ( list < string > replace ) { arraylist < string > copy = new arraylist < string > ( retainedvars . size ( ) ) ; copy . addall ( retainedvars ) ; retainedvars . clear ( ) ; if ( replace != null ) { retainedvars . addall ( replace ) ; } return copy ; }	replaces the list of retained vars with the specified list , returning the old list.
protected void release ( ) { appcontext tempappcontext = null ; synchronized ( grabreleasesynchronizer ) { if ( usagecount > _num ) { -- usagecount ; } else { synchronized ( threadgroupsynchronizer ) { tempappcontext = resetappcontext ( ) ; } } } if ( tempappcontext != null ) { try { tempappcontext . dispose ( ) ; } catch ( illegalthreadstateexception e ) { } } }	release this appletclassloader and its threadgroup / appcontext.
public synchronized void deletealltables ( ) { list < string > tablenames = new arraylist < string > ( tablelookup . keyset ( ) ) ; for ( string s : tablenames ) { deletetable ( s ) ; } }	delete all tables from this database .
public petcategory findone ( string id ) { log . debug ( _str , id ) ; petcategory petcategory = petcategoryrepository . findone ( uuid . fromstring ( id ) ) ; return petcategory ; }	get one petcategory by id .
private void markremoveddefaultsessiontoken ( string site , string token ) { if ( removeddefaulttokens == null ) removeddefaulttokens = new hashmap < > ( _num ) ; hashset < string > removedset = removeddefaulttokens . get ( site ) ; if ( removedset == null ) { removedset = new hashset < > ( _num ) ; removeddefaulttokens . put ( site , removedset ) ; } removedset . add ( token ) ; }	marks a default session token as removed for a particular site .
public exchange ( final request request , final origin origin ) { this . currentrequest = request ; this . origin = origin ; this . timestamp = system . currenttimemillis ( ) ; }	creates a new exchange with the specified request and origin .
public static float computediscardalpha ( float amount , float range ) { if ( math . abs ( amount ) < _num ) return _num ; float t = amount / range ; t = mathutils . clamp ( t , - _num , _num ) ; return _num - math . abs ( t ) ; }	computes the alpha value of the tab based on its discard status .
public static final filetime unixtimetofiletime ( long utime ) { return filetime . from ( utime , timeunit . seconds ) ; }	converts " standard unix time " ( in seconds , utc / gmt ) to filetime.
public static ciphertextivmac encrypt ( string plaintext , secretkeys secretkeys , string encoding ) throws unsupportedencodingexception , generalsecurityexception { return encrypt ( plaintext . getbytes ( encoding ) , secretkeys ) ; }	generates a random iv and encrypts this plain text with the given key.
public void removeaddress ( addressentity address ) { addresses . remove ( address ) ; }	removes the given address from this user.
@ override protected void onmeasure ( int widthmeasurespec , int heightmeasurespec ) { int widthspecmode = measurespec . getmode ( widthmeasurespec ) ; int heightspecmode = measurespec . getmode ( heightmeasurespec ) ; int parentwidth = measurespec . getsize ( widthmeasurespec ) ; int parentheight = measurespec . getsize ( heightmeasurespec ) ; boolean resizewidth = widthspecmode != measurespec . exactly ; boolean resizeheight = heightspecmode != measurespec . exactly ; int width = parentwidth ; int height = parentheight ; if ( swidth > _num && sheight > _num ) { if ( resizewidth && resizeheight ) { width = swidth ( ) ; height = sheight ( ) ; } else if ( resizeheight ) { height = ( int ) ( ( ( ( double ) sheight ( ) / ( double ) swidth ( ) ) * width ) ) ; } else if ( resizewidth ) { width = ( int ) ( ( ( ( double ) swidth ( ) / ( double ) sheight ( ) ) * height ) ) ; } } width = math . max ( width , getsuggestedminimumwidth ( ) ) ; height = math . max ( height , getsuggestedminimumheight ( ) ) ; setmeasureddimension ( width , height ) ; }	measures the width and height of the view , preserving the aspect ratio of the image displayed if wrap_content is used.
protected void fireendelem ( string name ) throws org . xml . sax . saxexception { if ( m_tracer != null ) { flushmywriter ( ) ; m_tracer . firegenerateevent ( serializertrace . eventtype_endelement , name , ( attributes ) null ) ; } }	to fire off the end element trace event.
private boolean verifymigratefromproducthome ( string migratefromproducthome ) throws installexception { if ( migratefromproducthome == null || migratefromproducthome . length ( ) == _num ) { debug . log ( _str + _str ) ; console . println ( localizedmessage . get ( loc_hr_msg_migrate_none_found ) ) ; return _bool ; } if ( ! migratefromproducthome . equals ( configutil . gethomepath ( ) ) ) { debug . log ( _str + _str + migratefromproducthome + _str + configutil . gethomepath ( ) ) ; string translatefile = migratefromproducthome + migratefrominstfinderstore . getrelativetranslatefile ( ) ; if ( ! fileutils . isfilevalid ( translatefile ) ) { console . println ( localizedmessage . get ( loc_hr_msg_migrate_none_found ) ) ; return _bool ; } } else { debug . log ( _str + _str ) ; throw new installexception ( localizedmessage . get ( loc_dr_err_product_already_migrated ) ) ; } return _bool ; }	check if the product home input by the user has the locator file of the product to be migrated from .
public spanned [ ] history ( ) { int i = _num ; spanned [ ] array = new spanned [ history . size ( ) ] ; for ( string s : history ) { if ( s != null ) { array [ i ] = html . fromhtml ( s ) ; i ++ ; } } return array ; }	generate an array of spanned items representing the history of this connection .
public static string format ( string message , object [ ] arguments ) { return messageformat . format ( message , arguments ) ; }	formats the given string with the given argument .
private void insertprosodysettings ( utterance utterance , element element ) { element prosody = ( element ) domutils . getancestor ( element , maryxml . prosody ) ; if ( prosody == null ) { return ; } element voice = ( element ) domutils . getancestor ( element , maryxml . voice ) ; if ( voice != null && domutils . isancestor ( prosody , voice ) ) { return ; } element paragraph = ( element ) domutils . getancestor ( element , maryxml . paragraph ) ; if ( paragraph != null && domutils . isancestor ( prosody , paragraph ) ) { return ; } for ( string att : prosody_attributes ) { string val = prosody . getattribute ( att ) ; if ( ! val . equals ( _str ) ) { utterance . setstring ( att , val ) ; } } }	for a given element , extract essential settings defined by the closest ancestor prosody element and save them into the utterance.
public static boolean createfolder ( @ suppresswarnings ( _str ) context mcontext , string path , string foldername ) { file sdcardroot = new file ( path , foldername ) ; if ( ! sdcardroot . exists ( ) ) { return sdcardroot . mkdir ( ) ; } return _bool ; }	use to create folder in your directory.
private void translatematrixafterrotate ( int axis , float trans , float previmagesize , float imagesize , int prevviewsize , int viewsize , int drawablesize ) { if ( imagesize < viewsize ) { m [ axis ] = ( viewsize - ( drawablesize * m [ matrix . mscale_x ] ) ) * _num ; } else if ( trans > _num ) { m [ axis ] = - ( ( imagesize - viewsize ) * _num ) ; } else { float percentage = ( math . abs ( trans ) + ( _num * prevviewsize ) ) / previmagesize ; m [ axis ] = - ( ( percentage * imagesize ) - ( viewsize * _num ) ) ; } }	after rotating , the matrix needs to be translated.
private charsequence createtickertext ( string title , string body ) { spannablestringbuilder spannablestringbuilder = new spannablestringbuilder ( ) ; spannablestringbuilder . append ( title ) ; spannablestringbuilder . append ( _str ) ; spannablestringbuilder . append ( body ) ; spannablestringbuilder . setspan ( new stylespan ( android . graphics . typeface . bold ) , _num , title . length ( ) , spannable . span_inclusive_inclusive ) ; return spannablestringbuilder ; }	creates the ticker text for a notification having | title | and | body |.
private void addprotocolifnotexists ( set < string > protocols , string protocoltype ) { if ( ! protocols . contains ( protocoltype ) ) { protocols . add ( protocoltype ) ; } }	verify whether protocoltype already exists or not.
public string tostring ( ) { stringbuilder result = new stringbuilder ( ) ; result . append ( _str ) ; result . append ( klazz . getname ( ) ) ; result . append ( _str ) ; for ( int i = _num ; i < elements . length ; ++ i ) { if ( i != _num ) { result . append ( _str ) ; } result . append ( elements [ i ] ) ; } result . append ( _str ) ; return result . tostring ( ) ; }	provides detailed description of this annotation instance , including all member name - values pairs .
void add ( object key ) { table . put ( key , key ) ; }	adds an object to this set .
public configuration loadconfigfromresource ( resource resource ) { propertiesconfiguration result = new propertiesconfiguration ( ) ; try { result . load ( resource . getinputstream ( ) ) ; return result ; } catch ( configurationexception | ioexception e ) { log . error ( configuration_load_error . format ( resource . getfilename ( ) ) , e ) ; throw new systemconfigexception ( configuration_load_error . format ( resource . getfilename ( ) ) , e ) ; } }	build a configuration object from a resource , processing it as a properties file .
public final void log ( string filename , int linenumber , string method , string tag , int level , string message ) { final logmessage lm = new logmessage ( logmessage . logmsg_type_log , nextsequencenumber . getandincrement ( ) ) ; lm . addint16 ( level , logmessage . part_key_level ) ; if ( filename != null ) { lm . addstring ( filename , logmessage . part_key_filename ) ; if ( linenumber != _num ) lm . addint32 ( linenumber , logmessage . part_key_linenumber ) ; } if ( method != null ) lm . addstring ( method , logmessage . part_key_functionname ) ; if ( tag != null && ! tag . isempty ( ) ) lm . addstring ( tag , logmessage . part_key_tag ) ; lm . addstring ( message , logmessage . part_key_message ) ; log ( lm ) ; }	log a message with full information ( if provided ).
protected size2d drawvertical ( graphics2d g2 , rectangle2d chartarea ) { double startx ; double topspace = _num ; double bottomspace = _num ; double leftspace = _num ; double rightspace = _num ; double w = getwidth ( ) ; double h = getheight ( ) ; rectangleinsets padding = getpadding ( ) ; if ( padding != null ) { topspace = padding . calculatetopoutset ( h ) ; bottomspace = padding . calculatebottomoutset ( h ) ; leftspace = padding . calculateleftoutset ( w ) ; rightspace = padding . calculaterightoutset ( w ) ; } if ( getposition ( ) == rectangleedge . left ) { startx = chartarea . getx ( ) + leftspace ; } else { startx = chartarea . getmaxx ( ) - rightspace - w ; } verticalalignment alignment = getverticalalignment ( ) ; double starty = _num ; if ( alignment == verticalalignment . center ) { starty = chartarea . getminy ( ) + topspace + chartarea . getheight ( ) / _num - h / _num ; } else if ( alignment == verticalalignment . top ) { starty = chartarea . getminy ( ) + topspace ; } else if ( alignment == verticalalignment . bottom ) { starty = chartarea . getmaxy ( ) - bottomspace - h ; } g2 . drawimage ( this . image , ( int ) startx , ( int ) starty , ( int ) w , ( int ) h , null ) ; return new size2d ( chartarea . getwidth ( ) + leftspace + rightspace , h + topspace + bottomspace ) ; }	draws the title on a java 2d graphics device ( such as the screen or a printer ) .
private static final publickey constructpublickey ( byte [ ] encodedkey , string encodedkeyalgorithm ) throws invalidkeyexception , nosuchalgorithmexception { publickey key = null ; try { keyfactory keyfactory = keyfactory . getinstance ( encodedkeyalgorithm , sunjce . getinstance ( ) ) ; x509encodedkeyspec keyspec = new x509encodedkeyspec ( encodedkey ) ; key = keyfactory . generatepublic ( keyspec ) ; } catch ( nosuchalgorithmexception nsae ) { try { keyfactory keyfactory = keyfactory . getinstance ( encodedkeyalgorithm ) ; x509encodedkeyspec keyspec = new x509encodedkeyspec ( encodedkey ) ; key = keyfactory . generatepublic ( keyspec ) ; } catch ( nosuchalgorithmexception nsae2 ) { throw new nosuchalgorithmexception ( _str + _str + encodedkeyalgorithm + _str ) ; } catch ( invalidkeyspecexception ikse2 ) { invalidkeyexception ike = new invalidkeyexception ( _str ) ; ike . initcause ( ikse2 ) ; throw ike ; } } catch ( invalidkeyspecexception ikse ) { invalidkeyexception ike = new invalidkeyexception ( _str ) ; ike . initcause ( ikse ) ; throw ike ; } return key ; }	construct a public key from its encoding .
public int numhits ( string query ) throws parseexception , ioexception { integer count ; if ( ( count = ( integer ) m_hitcountcache . get ( query ) ) == null ) { hits hits = search ( query ) ; count = new integer ( hits . length ( ) ) ; m_hitcountcache . put ( query , count ) ; } return count . intvalue ( ) ; }	return the result count for the given search query.
public static boolean expressionistrue ( double leftside , operator operator , double rightside ) { final string expression = leftside + operator . getmathematicaloperator ( ) + rightside ; return expressionistrue ( expression ) ; }	evaluates whether an expression is true or false .
public mockresponse addheader ( string name , object value ) { return addheader ( name + _str + string . valueof ( value ) ) ; }	adds a new header with the name and value.
@ override public completablefuture < optional < t > > max ( final comparator < ? super t > comparator ) { return completablefuture . supplyasync ( null , exec ) ; }	perform an asyncrhonous min operation.
final public void println ( char v ) { writer out = this . out ; if ( out == null ) return ; try { out . write ( v ) ; out . write ( _newline , _num , _newline . length ) ; } catch ( ioexception e ) { log . log ( level . fine , e . tostring ( ) , e ) ; } }	prints a character followed by a newline .
public void test_write_correctrejection_emptyrecord ( ) { final irawstore store = getstore ( ) ; try { try { store . write ( bytebuffer . wrap ( new byte [ ] { } ) ) ; fail ( _str + illegalargumentexception . class ) ; } catch ( illegalargumentexception ex ) { if ( log . isinfoenabled ( ) ) log . info ( _str + ex ) ; } try { final bytebuffer buf = bytebuffer . wrap ( new byte [ _num ] ) ; buf . position ( buf . limit ( ) ) ; store . write ( buf ) ; fail ( _str + illegalargumentexception . class ) ; } catch ( illegalargumentexception ex ) { if ( log . isinfoenabled ( ) ) log . info ( _str + ex ) ; } } finally { store . destroy ( ) ; } }	test verifies correct rejection of a write operation when the caller supplies an empty buffer ( no bytes remaining ) .
public synchronized void commit ( ) { synchronized ( mutex ) { map < column , set < interval > > temp = workingintervals ; workingintervals = collections . synchronizedmap ( new linkedhashmap < > ( ) ) ; availableintervalsref . set ( collections . unmodifiablemap ( new linkedhashmap < > ( temp ) ) ) ; super . columns = new linkedhashset < > ( temp . keyset ( ) ) ; } }	swaps the actual cache with the built - up temporary cache and creates a fresh , empty temporary cache .
public void testupdate7 ( ) { string updatequery = _str + databasecreator . test_table1 + _str + databasecreator . test_table2 + _str ; try { int num = statement . executeupdate ( updatequery ) ; int expectedupdated = _num ; assertequals ( _str , expectedupdated , num ) ; string selectquery = _str + databasecreator . test_table1 ; resultset result = statement . executequery ( selectquery ) ; while ( result . next ( ) ) { } result . close ( ) ; } catch ( sqlexception e ) { fail ( _str + e . getmessage ( ) ) ; } }	updatefunctionalitytest # testupdate7 ( ) . updates records in the table using subquery in update command.
public static string extractindentstring ( string line , int tabwidth , int indentwidth ) { if ( tabwidth < _num || indentwidth < _num || line == null ) { throw new illegalargumentexception ( ) ; } int size = line . length ( ) ; int end = _num ; int spaceequivs = _num ; int characters = _num ; for ( int i = _num ; i < size ; i ++ ) { char c = line . charat ( i ) ; if ( c == _str ) { spaceequivs = calculatespaceequivalents ( tabwidth , spaceequivs ) ; characters ++ ; } else if ( isindentchar ( c ) ) { spaceequivs ++ ; characters ++ ; } else { break ; } if ( spaceequivs >= indentwidth ) { end += characters ; characters = _num ; if ( indentwidth == _num ) { spaceequivs = _num ; } else { spaceequivs = spaceequivs % indentwidth ; } } } if ( end == _num ) { return util . empty_string ; } else if ( end == size ) { return line ; } else { return line . substring ( _num , end ) ; } }	returns the leading indentation string of the given line.
private static string dogetfullpath ( string filename , boolean includeseparator ) { if ( filename == null ) { return null ; } int prefix = getprefixlength ( filename ) ; if ( prefix < _num ) { return null ; } if ( prefix >= filename . length ( ) ) { if ( includeseparator ) { return getprefix ( filename ) ; } else { return filename ; } } int index = indexoflastseparator ( filename ) ; if ( index < _num ) { return filename . substring ( _num , prefix ) ; } int end = index + ( includeseparator ? _num : _num ) ; if ( end == _num ) { end ++ ; } return filename . substring ( _num , end ) ; }	does the work of getting the path .
private static boolean addifmatches ( list < string > container , string statusline , char x , char y ) { if ( matches ( statusline , x , y ) ) { final string filename = statusline . substring ( _num ) ; if ( ! container . contains ( filename ) ) { container . add ( filename ) ; } return _bool ; } return _bool ; }	adds files to container if they matched to template .
public void testdivideroundhalfdownneg2 ( ) { string a = _str ; int ascale = _num ; string b = _str ; int bscale = _num ; string c = _str ; int resscale = - _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; bigdecimal result = anumber . divide ( bnumber , resscale , bigdecimal . round_half_down ) ; assertequals ( _str , c , result . tostring ( ) ) ; assertequals ( _str , resscale , result . scale ( ) ) ; }	divide : rounding mode is round_half_up , result is negative ; equidistant.
public static string encodefromstring ( string plain , string charset ) throws coderexception , unsupportedencodingexception { return encode ( plain . getbytes ( charset ) ) ; }	encodes a string to base64 string.
public void slide ( slide slide ) { if ( slide == slide . up ) { if ( ! ispanelshown ( ) ) { int position = _num ; if ( items != null ) { position = items . size ( ) / _num ; } slideup ( position ) ; } } else { hidepanelpickerui ( ) ; } }	slide the panel to the desired direction .
public drawerbuilder addstickydraweritems ( @ nonnull idraweritem ... stickydraweritems ) { if ( this . mstickydraweritems == null ) { this . mstickydraweritems = new arraylist < > ( ) ; } collections . addall ( this . mstickydraweritems , iddistributor . checkids ( stickydraweritems ) ) ; return this ; }	add a initial draweritem or a draweritem array for the stickydrawerfooter.
public boolean isdebuggingfinest ( ) { return logger . isloggable ( level . finest ) ; }	test whether to log ' debug ' at ' finest ' level.
public void reset ( ) { ns . removeallelements ( ) ; ks . setlength ( _num ) ; cur = tt . root ; run ( ) ; }	resets the iterator to its initial state .
@ layoutlibdelegate static float sin ( float angle ) { return ( float ) math . sin ( angle ) ; }	returns the closest float approximation of the sine of the argument .
public byte [ ] extractdata ( byte [ ] stegodata , string stegofilename , byte [ ] origsigdata ) throws openstegoexception { return null ; }	method to extract the message from the stego data.
public static string makerelatedsessionid ( string encryptedid , sessionid prototype ) throws sessionexception { prototype . parsesessionstring ( ) ; return makesessionid ( encryptedid , prototype . getextension ( ) , prototype . tail ) ; }	generates encoded session id string which uses the same extensions and tail part as prototype session id , but a different encrypted id.
public static generalpath cardinalspline ( float pts [ ] , int start , int npoints , float slack , boolean closed ) { generalpath path = new generalpath ( ) ; path . moveto ( pts [ start ] , pts [ start + _num ] ) ; return cardinalspline ( path , pts , start , npoints , slack , closed , _num , _num ) ; }	compute a cardinal spline , a series of cubic bezier splines smoothly connecting a set of points.
public boolean matches ( string seq ) { return queue . regionmatches ( _bool , pos , seq , _num , seq . length ( ) ) ; }	tests if the next characters on the queue match the sequence.
public static int compare ( comparable c1 , comparable c2 , boolean nullgreater ) { if ( c1 == c2 ) { return _num ; } else if ( c1 == null ) { return ( nullgreater ? _num : - _num ) ; } else if ( c2 == null ) { return ( nullgreater ? - _num : _num ) ; } return c1 . compareto ( c2 ) ; }	null safe comparison of comparables .
public boolean checkrootbysuperuserapk ( ) { file suapk = new file ( su_apk ) ; if ( suapk != null && suapk . exists ( ) ) { return _bool ; } return _bool ; }	returns true if the device contains superuser.
int addexpression ( expression expression ) ;	adds a new expression to the database .
public static < e > e syncrest ( final iterator < ? extends object > iterator , final callable < e > task ) throws exception { if ( iterator . hasnext ( ) ) { synchronized ( iterator . next ( ) ) { return syncrest ( iterator , task ) ; } } else { return task . call ( ) ; } }	recursively synchronizes on the components in the provided iterator and executes the provided task if there are no more components .
private static component findbyname ( container root , string componentname ) { if ( verbose ) { log ( _str + root + _str + componentname + _str ) ; } int count = root . getcomponentcount ( ) ; for ( int iter = _num ; iter < count ; iter ++ ) { component c = root . getcomponentat ( iter ) ; string n = c . getname ( ) ; if ( n != null && n . equals ( componentname ) ) { return c ; } if ( c instanceof container ) { c = findbyname ( ( container ) c , componentname ) ; if ( c != null ) { return c ; } } } return null ; }	finds a component with the given name , works even with ui ' s that weren ' t created with the gui builder.
public boolean isfingerprint ( classtemplate classtemplate ) { return fingerprintclass . equals ( classtemplate . getimplementingclass ( ) ) ; }	tests if a template contains methods with signatures that are required by the filter object.
public void writefield ( final string name , final float value ) throws java . io . ioexception { writefield ( name , float . tostring ( value ) ) ; }	writes an float field value .
private list extractcolumnkeys ( string line ) { list keys = new java . util . arraylist ( ) ; int fieldindex = _num ; int start = _num ; for ( int i = _num ; i < line . length ( ) ; i ++ ) { if ( line . charat ( i ) == this . fielddelimiter ) { if ( fieldindex > _num ) { string key = line . substring ( start , i ) ; keys . add ( removestringdelimiters ( key ) ) ; } start = i + _num ; fieldindex ++ ; } } string key = line . substring ( start , line . length ( ) ) ; keys . add ( removestringdelimiters ( key ) ) ; return keys ; }	extracts the column keys from a string .
protected void drawrhombus ( int x , int y , int w , int h , color fillcolor , paint fillpaint , color pencolor , boolean shadow ) { int halfwidth = w / _num ; int halfheight = h / _num ; polygon rhombus = new polygon ( ) ; rhombus . addpoint ( x + halfwidth , y ) ; rhombus . addpoint ( x + w , y + halfheight ) ; rhombus . addpoint ( x + halfwidth , y + h ) ; rhombus . addpoint ( x , y + halfheight ) ; drawpolygon ( rhombus , fillcolor , fillpaint , pencolor , shadow ) ; }	draws a rhombus ( aka.
private void convertandfillbytebufferlisttobytearraylist ( list < byte [ ] > dictionaryvalues , list < bytebuffer > dictionaryvaluebufferlist ) { for ( bytebuffer buffer : dictionaryvaluebufferlist ) { int length = buffer . limit ( ) ; byte [ ] value = new byte [ length ] ; buffer . get ( value , _num , value . length ) ; dictionaryvalues . add ( value ) ; } }	this method will convert and fill list of byte buffer to list of byte array.
static object instantiate ( class < ? > sibling , string classname ) throws instantiationexception , illegalaccessexception , classnotfoundexception { classloader cl = sibling . getclassloader ( ) ; class < ? > cls = classfinder . findclass ( classname , cl ) ; return cls . newinstance ( ) ; }	try to create an instance of a named class.
private byte [ ] generatederivedkey ( int bytesneeded ) { byte [ ] buf = new byte [ digest . getdigestsize ( ) ] ; byte [ ] key = new byte [ bytesneeded ] ; int offset = _num ; for ( ; ; ) { digest . update ( password , _num , password . length ) ; digest . update ( salt , _num , salt . length ) ; digest . dofinal ( buf , _num ) ; int len = ( bytesneeded > buf . length ) ? buf . length : bytesneeded ; system . arraycopy ( buf , _num , key , offset , len ) ; offset += len ; bytesneeded -= len ; if ( bytesneeded == _num ) { break ; } digest . reset ( ) ; digest . update ( buf , _num , buf . length ) ; } return key ; }	the derived key function , the ith hash of the password and the salt .
public void testsystemrunfinalizationreturnsevenifqueueisnonempty ( ) throws exception { atomicinteger count = new atomicinteger ( ) ; atomicboolean keepgoing = new atomicboolean ( _bool ) ; createchainedfinalizer ( count , keepgoing ) ; while ( count . get ( ) == _num ) { thread . sleep ( _num ) ; finalizationtester . inducefinalization ( ) ; } keepgoing . set ( _bool ) ; asserttrue ( count . get ( ) > _num ) ; }	make sure that system.
public synchronized void show ( bundle options ) { if ( debug ) log . d ( tag , _str + mkeyguardview ) ; boolean enablescreenrotation = shouldenablescreenrotation ( ) ; maybecreatekeyguardlocked ( enablescreenrotation , _bool , options ) ; maybeenablescreenrotation ( enablescreenrotation ) ; final int visflags = view . status_bar_disable_home ; if ( debug ) log . v ( tag , _str + integer . tohexstring ( visflags ) + _str ) ; mkeyguardhost . setsystemuivisibility ( visflags ) ; mviewmanager . updateviewlayout ( mkeyguardhost , mwindowlayoutparams ) ; mkeyguardhost . setvisibility ( view . visible ) ; mkeyguardview . show ( ) ; mkeyguardview . requestfocus ( ) ; }	show the keyguard . will handle creating and attaching to the view manager lazily .
public static int computestringwidth ( fontmetrics fm , string str ) { return swingutilities2 . stringwidth ( null , fm , str ) ; }	compute the width of the string using a font with the specified " metrics " ( sizes ) .
private boolean passessanitycheck ( accessibilityevent event ) { final charsequence aftertext = geteventtext ( event ) ; final charsequence beforetext = event . getbeforetext ( ) ; if ( ( event . getaddedcount ( ) == _num ) && ( event . getremovedcount ( ) == beforetext . length ( ) ) ) { return _bool ; } if ( aftertext == null || beforetext == null ) { return _bool ; } final int diff = ( event . getaddedcount ( ) - event . getremovedcount ( ) ) ; return ( ( beforetext . length ( ) + diff ) == aftertext . length ( ) ) ; }	checks whether the event ' s reported properties match its actual properties , e.
public void actionperformed ( actionevent ae ) { string command = ae . getactioncommand ( ) ; if ( command == displaypalettecmd ) { if ( debug . debugging ( _str ) ) { debug . output ( getname ( ) + _str ) ; } showpalette ( ) ; } else if ( command == hidepalettecmd ) { if ( debug . debugging ( _str ) ) { debug . output ( getname ( ) + _str ) ; } hidepalette ( ) ; } else if ( command == displaypropertiescmd ) { inspector inspector = new inspector ( ) ; inspector . inspectpropertyconsumer ( this ) ; } }	the default actionperformed method for layer.
public static string tostring ( localdate data ) { return data == null ? _str : data . format ( formatter ( _str ) ) ; }	converte localdatetime para string no formato dd / mm / yyyy.
@ jsoncreator public datasourcemetadata ( @ jsonproperty ( _str ) string name , @ jsonproperty ( _str ) map < string , string > properties , @ jsonproperty ( _str ) list < datasegment > segments ) { this . name = name ; this . properties = collections . unmodifiablemap ( properties ) ; this . segments = collections . unmodifiablelist ( segments ) ; }	store the full metadata for a druid data source , mainly as a list of segments .
public email createemail ( string value ) { emailfield emailimpl = new emailfield ( ) ; try { emailimpl . setvalue ( value ) ; } catch ( sdpexception s ) { s . printstacktrace ( ) ; } return emailimpl ; }	returns email object with the specified value .
public addresslookup ( string serverurl , string serialno , string password ) { this . serverurl = serverurl . trim ( ) ; this . clientid = serialno . trim ( ) ; this . accesscode = password . trim ( ) ; }	creates a new instance of addresslookup .
public void addchangelistener ( changelistener l ) { m_changelisteners . add ( l ) ; }	adds a changelistener to the panel.
public node ( string permission , boolean value , boolean override , long expireat , string server , string world , contextset contexts ) { if ( permission == null || permission . equals ( _str ) ) { throw new illegalargumentexception ( _str ) ; } if ( server != null && ( server . equalsignorecase ( _str ) || server . equals ( _str ) ) ) { server = null ; } if ( world != null && world . equals ( _str ) ) { world = null ; } if ( world != null && server == null ) { server = _str ; } this . permission = permission ; this . value = value ; this . override = override ; this . expireat = expireat ; this . server = server ; this . world = world ; this . contexts = contexts == null ? contextset . empty ( ) : contexts . makeimmutable ( ) ; }	make an immutable node instance.
public cell ( int rowspan , int colspan ) { this . rowspan = math . max ( rowspan , _num ) ; this . colspan = math . max ( colspan , _num ) ; }	creates a cell which takes a custom amount of cell spaces in the table .
@ override public void openelement ( string tagname ) { xmlelement newelement = new xmlelement ( ) ; newelement . setname ( tagname ) ; current . addchild ( newelement ) ; stack . push ( current ) ; current = newelement ; }	puts a new element into the dom document.
public format ( string pformatstring ) { string formatvars [ ] = pformatstring . split ( _str ) ; mid = integer . parseint ( formatvars [ _num ] ) ; }	construct this object from one of the strings in the " fmt_list " parameter.
public boolean equals ( object interval ) { if ( intervals == null ) { return _bool ; } return intervals . contains ( interval ) ; }	determine the matching test.
public static string relativetoabsolute ( string baseurl , string relativeurl ) { if ( relativeurl . startswith ( _str ) ) { return geturlprotocol ( baseurl ) + _str + geturlhost ( baseurl ) + relativeurl ; } else { return geturlprotocol ( baseurl ) + _str + geturlhost ( baseurl ) + geturlbasepath ( baseurl ) + relativeurl ; } }	converts a relative url e.
public void start ( ) { if ( setstate ( enumset . of ( taskstate . initial , taskstate . queued ) , taskstate . running ) ) { dht . logdebug ( _str + tostring ( ) ) ; starttime = system . currenttimemillis ( ) ; try { serializedupdate . run ( ) ; } catch ( exception e ) { dht . log ( e , loglevel . error ) ; } } }	start the task , to be used when a task is queued .
public journalindex ( final irawstore store , final checkpoint checkpoint , final indexmetadata metadata , final boolean readonly ) { super ( store , checkpoint , metadata , readonly ) ; }	load from the store .
private void closefile ( ) { if ( plogstream != null ) { try { plogstream . close ( ) ; logger . info ( _str + plogfilename + _str ) ; } catch ( ioexception e ) { logger . warn ( _str + plogfilename ) ; } finally { plogstream = null ; } } }	close plog file . this operation is idempotent to allow convenient cleanup at thread exit .
private void parsefirstconsonant ( ) { iterator iter = alfirstconsonants . iterator ( ) ; while ( iter . hasnext ( ) ) { string strfirstcon = ( string ) iter . next ( ) ; if ( strsyllable . startswith ( strfirstcon , icurpos ) ) { strfirstconsonant = strfirstcon ; icurpos += strfirstcon . length ( ) ; return ; } } strfirstconsonant = zero ; }	parses the first consonant .
private buddypanelcontroller ( ) { buddypanel = new jpanel ( ) ; buddypanel . setlayout ( new sboxlayout ( sboxlayout . vertical ) ) ; model = new buddylistmodel ( ) ; jlist < buddy > list = new buddypanel ( model ) ; buddypanel . add ( list , slayout . expand_x ) ; }	creates a new buddypanelcontroller .
public static testresult execjavac ( string tocompile , file dir , string jflextestversion ) { project p = new project ( ) ; javac javac = new javac ( ) ; path path = new path ( p , dir . tostring ( ) ) ; javac . setproject ( p ) ; javac . setsrcdir ( path ) ; javac . setdestdir ( dir ) ; javac . settarget ( javaversion ) ; javac . setsource ( javaversion ) ; javac . setsourcepath ( new path ( p , _str ) ) ; javac . setincludes ( tocompile ) ; path classpath = javac . createclasspath ( ) ; classpath . setpath ( system . getproperty ( _str ) + _str + jflextestversion + _str + jflextestversion + _str ) ; bytearrayoutputstream out = new bytearrayoutputstream ( ) ; printstream outsafe = system . err ; system . seterr ( new printstream ( out ) ) ; try { javac . execute ( ) ; return new testresult ( out . tostring ( ) , _bool ) ; } catch ( buildexception e ) { return new testresult ( e + system . getproperty ( _str ) + out . tostring ( ) , _bool ) ; } finally { system . seterr ( outsafe ) ; } }	call javac on tocompile in input dir.
private final boolean parkandcheckinterrupt ( ) { locksupport . park ( this ) ; return thread . interrupted ( ) ; }	convenience method to park and then check if interrupted.
public static clplatform [ ] listgpupoweredplatforms ( ) { clplatform [ ] platforms = listplatforms ( ) ; list < clplatform > out = new arraylist < clplatform > ( platforms . length ) ; for ( clplatform platform : platforms ) { if ( platform . listgpudevices ( _bool ) . length > _num ) out . add ( platform ) ; } return out . toarray ( new clplatform [ out . size ( ) ] ) ; }	list the opencl implementations that contain at least one gpu device .
public actionrequesthelper dependson ( actionrequesthelper dependency ) { mdependencies . add ( dependency ) ; return this ; }	this request will execute after the dependency completes .
static boolean isdate ( object obj ) { return obj instanceof date && obj . getclass ( ) == date . class ; }	check whether this object is a date .
public static string toxml ( final config toconvert , boolean prettyxml ) throws jaxbexception , ioexception { string retval = _str ; try ( stringwriter writer = new stringwriter ( ) ) { toxml ( toconvert , writer , prettyxml ) ; retval = writer . tostring ( ) ; return retval ; } }	converts config to xml ,.
private static list < vector2d > buildquadrilateral ( final vector2d ... points ) { list < vector2d > quadrilateral = new arraylist < vector2d > ( ) ; for ( vector2d p : points ) { if ( ! quadrilateral . contains ( p ) ) { quadrilateral . add ( p ) ; } } return quadrilateral ; }	build the convex quadrilateral with the found corner points ( with min / max x / y coordinates ) .
private void heapifyup ( int twopos , comparable < object > cur ) { while ( twopos > _num ) { final int parent = ( twopos - _num ) > > > _num ; comparable < object > par = twoheap [ parent ] ; if ( cur . compareto ( par ) <= _num ) { break ; } twoheap [ twopos ] = par ; twopos = parent ; } twoheap [ twopos ] = cur ; }	heapify - up method for 2 - ary heap .
public void insert ( string key , char val ) { int len = key . length ( ) + _num ; if ( freenode + len > eq . length ) { redimnodearrays ( eq . length + block_size ) ; } char strkey [ ] = new char [ len -- ] ; key . getchars ( _num , len , strkey , _num ) ; strkey [ len ] = _num ; root = insert ( root , strkey , _num , val ) ; }	branches are initially compressed , needing one node per key plus the size of the string key.
void fullyunlock ( ) { takelock . unlock ( ) ; putlock . unlock ( ) ; }	unlock to allow both puts and takes .
private static boolean issubformat ( string filename ) { for ( string ext : sub_extensions ) { if ( filename . contains ( _str + ext ) ) { return _bool ; } } return _bool ; }	test if file is subtitle format.
void write ( environment env , dataoutputstream out , constantpool tab ) throws ioexception { out . writebyte ( constant_nameandtype ) ; out . writeshort ( tab . index ( name ) ) ; out . writeshort ( tab . index ( type ) ) ; }	write the constant to the output stream.
public static void initializeproperties ( properties properties , boolean reset , boolean withdefaults ) { properties defaultprop = null ; if ( withdefaults ) { ssotoken apptoken = accesscontroller . doprivileged ( admintokenaction . getinstance ( ) ) ; defaultprop = serverconfiguration . getdefaults ( apptoken ) ; } propertiesholder oldprops ; propertiesholder newprops ; do { oldprops = propertiesholderref . get ( ) ; final properties combined = new properties ( ) ; if ( defaultprop != null ) { combined . putall ( defaultprop ) ; } if ( ! reset ) { combined . putall ( oldprops . properties ) ; } combined . putall ( properties ) ; newprops = new propertiesholder ( maps . fromproperties ( combined ) ) ; } while ( ! propertiesholderref . compareandset ( oldprops , newprops ) ) ; }	initializes the properties to be used by openam.
public void addnetworklistener ( final networklistener listener ) { networklisteners . add ( listener ) ; }	register a network listener .
public static void appendcontentprefix ( httpservletrequest request , appendable urlbuffer ) throws ioexception { appendcontentprefix ( request , urlbuffer , null ) ; }	appends content prefix to buffer.
public void adderrorlistener ( final errorlistener errorlistener ) { if ( errorlisteners == null ) { errorlisteners = new arraylist < errorlistener > ( ) ; } errorlisteners . add ( errorlistener ) ; }	add an error listener .
private void validateclassname ( string classname ) { string nvalue = classname . trim ( ) ; if ( ! nvalue . matches ( class_re ) ) { throw propertyexception . illegalpropertyvalueexception ( this , classname ) ; } }	do some basic checks to make sure the string representation is valid .
public static void importbasetypes ( final cconnection connection , final int rawmoduleid , final int moduleid ) throws sqlexception { final string query = _str + ctablenames . base_types_table + _str + moduleid + _str + _str + string . format ( ctablenames . raw_base_types , rawmoduleid ) ; connection . executeupdate ( query , _bool ) ; final string updatesequence = string . format ( _str + _str , ctablenames . base_types_table , ctablenames . base_types_table ) ; connection . executequery ( updatesequence , _bool ) ; }	imports the base types .
@ suppresswarnings ( _str ) public object readmatrixold ( element node ) throws exception { weka . core . matrix matrix ; weka . core . matrix . matrix matrixnew ; if ( debug ) { trace ( new throwable ( ) , node . getattribute ( att_name ) ) ; } m_currentnode = node ; matrixnew = ( weka . core . matrix . matrix ) readmatrix ( node ) ; matrix = new weka . core . matrix ( matrixnew . getarraycopy ( ) ) ; return matrix ; }	builds the matrix ( old ) from the given dom node .
public void recordfilesystemoperation ( dbclient dbclient , operationtypeenum optype , operation . status status , object ... extparam ) { try { boolean opstatus = ( operation . status . ready == status ) ? _bool : _bool ; string evtype ; evtype = optype . getevtype ( opstatus ) ; string evdesc = optype . getdescription ( ) ; string opstage = auditlogmanager . auditop_end ; _logger . info ( _str , optype . tostring ( ) , evtype . tostring ( ) + _str + evdesc ) ; uri uri = ( uri ) extparam [ _num ] ; recordbournefilesystemevent ( dbclient , evtype , status , evdesc , uri ) ; auditfile ( dbclient , optype , opstatus , opstage , uri . tostring ( ) ) ; } catch ( exception e ) { _logger . error ( _str , optype . tostring ( ) , e ) ; } }	record filesystem related event and audit.
public coretokenexception ( int errorcode ) { this . errorcode = errorcode ; this . message = getlocalizedmessage ( locale . getdefault ( ) ) ; }	creates a core token service exception .
public dexaminessl ( jframe parent , kseframe kseframe ) { super ( parent , res . getstring ( _str ) , dialog . modalitytype . document_modal ) ; this . kseframe = kseframe ; initcomponents ( ) ; }	creates new dexaminessl dialog .
private static list < string > computedynamicvmargs ( ijavaproject javaproject ) { arraylist < string > out = new arraylist < string > ( ) ; string devjarpath = maybegetdevjarpath ( javaproject ) ; if ( devjarpath . length ( ) > _num ) { out . add ( _str + devjarpath + _str ) ; } return out ; }	dynamic vm args common to both computejunitdynamicvmargsaslist and computecompiledynamicvmargsaslist .
static void normalize ( stringbuilder number ) { string normalizednumber = normalize ( number . tostring ( ) ) ; number . replace ( _num , number . length ( ) , normalizednumber ) ; }	normalizes a string of characters representing a phone number.
public double [ ] skipto ( final int index ) throws mathillegalargumentexception { if ( index == _num ) { arrays . fill ( x , _num ) ; } else { final int i = index - _num ; final long graycode = i ^ ( i > > _num ) ; for ( int j = _num ; j < dimension ; j ++ ) { long result = _num ; for ( int k = _num ; k <= bits ; k ++ ) { final long shift = graycode > > ( k - _num ) ; if ( shift == _num ) { break ; } final long ik = shift & _num ; result ^= ik * direction [ j ] [ k ] ; } x [ j ] = result ; } } count = index ; return nextvector ( ) ; }	skip to the i - th point in the sobol sequence.
public void removeorganizationconfiguration ( string orgname , string groupname , boolean checklegacymode ) throws smsexception , ssoexception { if ( ( groupname == null ) || groupname . length ( ) == _num ) { groupname = smsutils . default ; } string orgdn = dnmapper . orgnametodn ( orgname ) ; validatescm ( ) ; string odn = scm . constructserviceconfigdn ( groupname , createserviceconfig . org_config_node , orgdn ) ; cachedsmsentry centry = cachedsmsentry . getinstance ( token , odn ) ; if ( centry . isnewentry ( ) ) { return ; } if ( checklegacymode && servicemanager . iscoexistencemode ( ) && groupname . equalsignorecase ( smsutils . default ) ) { orgconfigviaamsdk amsdk = new orgconfigviaamsdk ( token , dnmapper . realmnametoamsdkname ( orgdn ) , orgdn ) ; amsdk . unassignservice ( servicename ) ; } if ( ! centry . isnewentry ( ) ) { smsentry entry = centry . getclonedsmsentry ( ) ; entry . delete ( token ) ; centry . refresh ( entry ) ; } }	deletes the organization ' s group configuration data .
public void removegrouplistener ( final grouplistener listener ) { grouplisteners . remove ( listener ) ; }	remove a group listener .
public setchangelogmapping ( string source , string taskname , int changelogpartitionnumber ) { super ( source ) ; settype ( type ) ; setkey ( taskname ) ; putmessagevalue ( changelog_value_key , string . valueof ( changelogpartitionnumber ) ) ; }	the change log mapping message is used to store changelog partition information for a given task name .
@ override protected string extractkey ( final string name ) { final string key = unescape ( name . substring ( _num , name . length ( ) - _num ) ) ; return key . equals ( _str ) ? null : key ; }	given a filename , the unescape method returns the key which originated it .
private static float spacing ( motionevent event ) { float x = event . getx ( _num ) - event . getx ( _num ) ; float y = event . gety ( _num ) - event . gety ( _num ) ; return ( float ) math . sqrt ( x * x + y * y ) ; }	returns the distance between two pointer touch points.
@ suppresswarnings ( _str ) public static < k , v > void transformstringmap ( map < string , string > original , map < k , v > map , class < k > keyclass , class < v > valueclass ) throws preferenceexception { method parsekeymethod = findparsemethod ( keyclass ) ; method parsevaluemethod = findparsemethod ( valueclass ) ; if ( ( null != parsekeymethod ) && ( null != parsevaluemethod ) ) { for ( map . entry < string , string > totransformentry : original . entryset ( ) ) { try { object transformedkey = parsekeymethod . invoke ( null , totransformentry . getkey ( ) ) ; object transformedvalue = parsevaluemethod . invoke ( null , totransformentry . getvalue ( ) ) ; if ( keyclass . isassignablefrom ( transformedkey . getclass ( ) ) && valueclass . isassignablefrom ( transformedvalue . getclass ( ) ) ) { map . put ( ( k ) transformedkey , ( v ) transformedvalue ) ; } } catch ( exception e ) { throw new preferenceexception ( _str + keyclass . getname ( ) + _str + valueclass . getname ( ) + _str , e ) ; } } } else if ( null == parsekeymethod ) { throw new preferenceexception ( _str + keyclass . getname ( ) + _str + valueclass . getname ( ) + _str + _str + keyclass . getname ( ) + _str ) ; } else { throw new preferenceexception ( _str + keyclass . getname ( ) + _str + valueclass . getname ( ) + _str + _str + valueclass . getname ( ) + _str ) ; } }	transforms all the strings key / value pairs in the original map to the given class key / value pairs and adds them to the given resulting map .
public componentmanager ( collection < sequence > generalseeds ) { set < sequence > seedset = new linkedhashset < > ( generalseeds . size ( ) ) ; seedset . addall ( generalseeds ) ; this . gralseeds = collections . unmodifiableset ( seedset ) ; gralcomponents = new sequencecollection ( seedset ) ; }	create a component manager , initially populated with the given sequences , which are considered seed sequences .
public synchronized void deleteobservers ( ) { observers . clear ( ) ; }	removes all observers from the list of observers .
public static byte [ ] unsynchronize ( byte [ ] abysource ) { bytearrayinputstream input = new bytearrayinputstream ( abysource ) ; bytearrayoutputstream output = new bytearrayoutputstream ( abysource . length ) ; int count = _num ; while ( input . available ( ) > _num ) { int firstbyte = input . read ( ) ; count ++ ; output . write ( firstbyte ) ; if ( ( firstbyte & mpegframeheader . sync_byte1 ) == mpegframeheader . sync_byte1 ) { if ( input . available ( ) > _num ) { input . mark ( _num ) ; int secondbyte = input . read ( ) ; if ( ( secondbyte & mpegframeheader . sync_byte2 ) == mpegframeheader . sync_byte2 ) { if ( logger . isloggable ( level . finest ) ) { logger . finest ( _str + count ) ; } output . write ( _num ) ; } else if ( secondbyte == _num ) { if ( logger . isloggable ( level . finest ) ) { logger . finest ( _str + count ) ; } output . write ( _num ) ; } input . reset ( ) ; } } } if ( ( abysource [ abysource . length - _num ] & mpegframeheader . sync_byte1 ) == mpegframeheader . sync_byte1 ) { logger . finest ( _str ) ; output . write ( _num ) ; } return output . tobytearray ( ) ; }	unsynchronize an array of bytes , this should only be called if the decision has already been made to unsynchronize the byte array in order to prevent a media player from incorrectly interpreting the contents of a tag , all $ ff bytes followed by a byte with value > = 224 must be followed by a $ 00 byte ( thus , $ ff $ f0 sequences become $ ff $ 00 $ f0 ) . additionally because unsynchronisation is being applied any existing $ ff $ 00 have to be converted to $ ff $ 00 $ 00.
private byte [ ] calculategeneralencryptionkey ( byte [ ] userpassword , byte [ ] firstdocidvalue , int keybitlength , int revision , byte [ ] ovalue , int pvalue , boolean encryptmetadata ) throws generalsecurityexception { final byte [ ] paddedpassword = padpassword ( userpassword ) ; messagedigest md5 = createmd5digest ( ) ; md5 . reset ( ) ; md5 . update ( paddedpassword ) ; md5 . update ( ovalue ) ; md5 . update ( ( byte ) ( pvalue & _num ) ) ; md5 . update ( ( byte ) ( ( pvalue > > _num ) & _num ) ) ; md5 . update ( ( byte ) ( ( pvalue > > _num ) & _num ) ) ; md5 . update ( ( byte ) ( pvalue > > _num ) ) ; if ( firstdocidvalue != null ) { md5 . update ( firstdocidvalue ) ; } if ( revision >= _num && ! encryptmetadata ) { for ( int i = _num ; i < _num ; ++ i ) { md5 . update ( ( byte ) _num ) ; } } byte [ ] hash = md5 . digest ( ) ; final int keylen = revision == _num ? _num : ( keybitlength / _num ) ; final byte [ ] key = new byte [ keylen ] ; if ( revision >= _num ) { for ( int i = _num ; i < _num ; ++ i ) { md5 . update ( hash , _num , key . length ) ; digestto ( md5 , hash ) ; } } system . arraycopy ( hash , _num , key , _num , key . length ) ; return key ; }	determine what the general encryption key is , given a configuration.
public messagecapture ( final logger logger , final boolean captureentity ) { this ( logger , captureentity , _bool ) ; }	builds a new messagecapture .
public static final byte [ ] unzip ( byte [ ] in ) throws ioexception { bytearrayoutputstream outstream = new bytearrayoutputstream ( expected_compression_ratio * in . length ) ; gzipinputstream instream = new gzipinputstream ( new bytearrayinputstream ( in ) ) ; byte [ ] buf = new byte [ buf_size ] ; while ( _bool ) { int size = instream . read ( buf ) ; if ( size <= _num ) break ; outstream . write ( buf , _num , size ) ; } outstream . close ( ) ; return outstream . tobytearray ( ) ; }	returns an gunzipped copy of the input array .
public static void insertintocombo ( jcombobox combo , object item ) { mutablecomboboxmodel model = ( mutablecomboboxmodel ) combo . getmodel ( ) ; if ( model . getsize ( ) == _num ) { model . insertelementat ( item , _num ) ; return ; } object o = model . getelementat ( _num ) ; if ( o . equals ( item ) ) { return ; } model . removeelement ( item ) ; model . insertelementat ( item , _num ) ; combo . setselectedindex ( _num ) ; }	insert the given item into the combo box , and set it as first selected item.
public synchronized object co_entry_pause ( int thiscoroutine ) throws java . lang . nosuchmethodexception { if ( ! m_activeids . get ( thiscoroutine ) ) throw new java . lang . nosuchmethodexception ( ) ; while ( m_nextcoroutine != thiscoroutine ) { try { wait ( ) ; } catch ( java . lang . interruptedexception e ) { } } return m_yield ; }	in the standard coroutine architecture , coroutines are identified by their method names and are launched and run up to their first yield by simply resuming them ; its ' s presumed that this recognizes the not - already - running case and does the right thing.
private boolean pythonerrorin ( string output ) { boolean iserror = _bool ; string [ ] outputmultiline = output . split ( _str ) ; matcher errormatcher ; for ( string row : outputmultiline ) { errormatcher = errorinlastline . matcher ( row ) ; if ( errormatcher . find ( ) == _bool ) { iserror = _bool ; break ; } } return iserror ; }	checks if there is a syntax error or an exception.
public static string numbertostring ( number number ) throws jsonexception { if ( number == null ) { throw new jsonexception ( _str ) ; } double doublevalue = number . doublevalue ( ) ; json . checkdouble ( doublevalue ) ; if ( number . equals ( negative_zero ) ) { return _str ; } long longvalue = number . longvalue ( ) ; if ( doublevalue == ( double ) longvalue ) { return long . tostring ( longvalue ) ; } return number . tostring ( ) ; }	encodes the number as a json string .
public static map < string , string > strtomap ( string str , string delim , boolean trim , string pairsseparator ) { if ( str == null ) return null ; map < string , string > decodedmap = new hashmap < string , string > ( ) ; list < string > elements = split ( str , delim ) ; pairsseparator = pairsseparator == null ? _str : pairsseparator ; for ( string s : elements ) { list < string > e = split ( s , pairsseparator ) ; if ( e . size ( ) != _num ) { continue ; } string name = e . get ( _num ) ; string value = e . get ( _num ) ; if ( trim ) { if ( name != null ) { name = name . trim ( ) ; } if ( value != null ) { value = value . trim ( ) ; } } try { decodedmap . put ( urldecoder . decode ( name , _str ) , urldecoder . decode ( value , _str ) ) ; } catch ( unsupportedencodingexception e1 ) { debug . logerror ( e1 , module ) ; } } return decodedmap ; }	creates a map from a name / value pair string.
public set < t > keyset ( ) { return collections . unmodifiableset ( map . keyset ( ) ) ; }	the item keys contained in the map .
public void onstart ( ) { if ( maudiomirrorbuffer == null ) { maudiomirrorbuffer = new byte [ _num ] ; } if ( mstreamer != null ) { mstreamer . start ( ) ; } if ( minsecurestreamer != null ) { minsecurestreamer . start ( ) ; } }	called when the playback service starts.
@ suppresswarnings ( _str ) public propagationimp ( stack < compositetransaction > lineage , boolean serial , long timeout ) { serial_ = serial ; lineage_ = ( stack < compositetransaction > ) lineage . clone ( ) ; timeout_ = timeout ; }	construct a new instance .
public nativerunner ( file eclipsec ) { this . eclipsec = objects . requirenonnull ( eclipsec ) ; }	pass it the location of the launcher file .
private static string indent ( final int height ) { return corebasebop . indent ( height ) ; }	returns a string that may be used to indent a dump of the nodes in the tree .
public static calendar reducecalendar ( calendar calendar ) { calendar . set ( calendar . millisecond , _num ) ; calendar . set ( calendar . second , _num ) ; calendar . set ( calendar . minute , _num ) ; calendar . set ( calendar . hour , _num ) ; calendar . set ( calendar . hour_of_day , _num ) ; return calendar ; }	sets the supplied calendar object with 0 values for fields lower than days.
public static string surround ( string string , string prefix , string suffix ) { if ( string . startswith ( prefix ) == _bool ) { string = prefix + string ; } if ( string . endswith ( suffix ) == _bool ) { string += suffix ; } return string ; }	surrounds the string with provided prefix and suffix if such missing from string .
public static coordinate ptnotinlist ( coordinate [ ] testpts , coordinate [ ] pts ) { for ( int i = _num ; i < testpts . length ; i ++ ) { coordinate testpt = testpts [ i ] ; if ( ! isinlist ( testpt , pts ) ) return testpt ; } return null ; }	finds a point in a list of points which is not contained in another list of points.
public static string trimorpad ( string str , int length , char padchar ) { string result ; if ( str == null ) { result = _str ; } else { result = str ; } if ( result . length ( ) > length ) { return result . substring ( _num , length ) ; } while ( result . length ( ) < length ) { result += padchar ; } return result ; }	trims or pads this string , so it has this exact length .
void scheduletotimerpool ( ) { if ( sessionpollerpool . ispollingenabled ( ) ) { long timeouttime = ( session . getlatestrefreshtime ( ) + ( session . getmaxidletime ( ) * _num ) ) * _num ; if ( sessionpollerpool . getcachebasedpolling ( ) ) { timeouttime = math . min ( ( session . getlatestrefreshtime ( ) + ( session . getmaxcachingtime ( ) * _num ) ) * _num , timeouttime ) ; } rescheduleifwilltimeoutbeforeexecution ( timeouttime ) ; } else { if ( ( sessionpollerpool . issessioncleanupenabled ( ) ) && willexpire ( session . getmaxsessiontime ( ) ) ) { long timeouttime = ( session . getlatestrefreshtime ( ) + ( session . getmaxsessiontime ( ) * _num ) ) * _num ; rescheduleifwilltimeoutbeforeexecution ( timeouttime ) ; } } }	schedule this culler to be run , based on the state of the session .
public cipherparameters decrypt ( byte [ ] in , int keylen ) { return decrypt ( in , _num , in . length , keylen ) ; }	decrypt an encapsulated session key .
private static void logosinfo ( ) { logger . appendlog ( _str + cfg . getos ( ) ) ; logger . appendlog ( _str + os . getosname ( ) ) ; logger . appendlog ( _str + os . platform ( ) ) ; logger . appendlog ( _str + system . getproperty ( _str ) ) ; logger . appendlog ( _str + hostinfo . availablecpus ( ) ) ; logger . appendlog ( _str + hostinfo . getmaxmemory ( ) + _str ) ; }	log system informations to the log file this have no effect on the software it ' s here for logging purpose.
private void beforevalue ( ) throws jsonexception { if ( stack . isempty ( ) ) { return ; } scope context = peek ( ) ; if ( context == scope . empty_array ) { replacetop ( scope . nonempty_array ) ; newline ( ) ; } else if ( context == scope . nonempty_array ) { out . append ( _str ) ; newline ( ) ; } else if ( context == scope . dangling_key ) { out . append ( indent == null ? _str : _str ) ; replacetop ( scope . nonempty_object ) ; } else if ( context != scope . null ) { throw new jsonexception ( _str ) ; } }	inserts any necessary separators and whitespace before a literal value , inline array , or inline object.
public static byte [ ] hash ( string input ) { if ( ! textutils . isempty ( input ) ) { try { byte [ ] inputbytes = input . getbytes ( _str ) ; return hash ( inputbytes ) ; } catch ( unsupportedencodingexception e ) { log . e ( tag , _str + input + _str + e . getmessage ( ) , e ) ; } } return null ; }	created sha256 of input.
public static string generatetransportzonenativeguid ( string transporttype , string devicetype , string fabricid ) { return string . format ( _str , transporttype , _devicetypemap . get ( devicetype ) , fabricid ) ; }	the format of this native guid is transporttype + devicetype + fabricwwn.
public void testaddservletwithnameandjspfile ( ) throws exception { string xml = webapp_test_header + _str + _str ; webxml webxml = webxmlio . parsewebxml ( new bytearrayinputstream ( xml . getbytes ( _str ) ) , getentityresolver ( ) ) ; webxmlutils . addjspfile ( webxml , _str , _str ) ; asserttrue ( webxmlutils . hasservlet ( webxml , _str ) ) ; }	tests whether a single servlet can be added using the method that takes a string for the servlet name and a string for the jsp file .
@ override public boolean equalsvalue ( final object other ) { return objects . equals ( this . value , other ) ; }	indicates whether some other object is " equal to " the value.
public static void error ( string msg , throwable t ) { debuginst . debug ( idebug . error , msg , t ) ; }	error level debug message.
public void removeeventlistener ( siptransactioneventlistener oldlistener ) { eventlisteners . remove ( oldlistener ) ; }	removed an event listener from this transaction .
public static executionsystem newexecutionsystem ( uri uri , map < string , ? > env ) throws ioexception { return newexecutionsystem ( uri , env , null ) ; }	creates a new execution system for the specified uri.
public static boolean iscommand ( ielementtype type ) { return type == sqftypes . command_token || type == sqftypes . command || type == sqftypes . case || type == sqftypes . case_command ; }	return true if the given type refers to a command , false otherwise.
public void send ( xtracereport report ) { outgoing . offer ( report ) ; }	enqueues the provided report to be sent by the reporting thread.
@ contract ( pure = _bool ) public static boolean startswithconcatenation ( @ notnull string string , @ notnull string ... prefixes ) { int offset = _num ; for ( string prefix : prefixes ) { int prefixlen = prefix . length ( ) ; if ( ! string . regionmatches ( offset , prefix , _num , prefixlen ) ) { return _bool ; } offset += prefixlen ; } return _bool ; }	equivalent to string . startswith ( prefixes [ 0 ] + prefixes [ 1 ] + . . . ) but avoids creating an object for concatenation .
public void testorderedbydatatype ( ) throws exception { int lasttype = integer . min_value ; while ( typeinfors . next ( ) ) { string name = typeinfors . getstring ( _str ) ; int type = typeinfors . getint ( _str ) ; asserttrue ( _str + type + _str + name + _str + lasttype , type >= lasttype ) ; lasttype = type ; } }	check types ordered by data type .
public boolean firemapmouseclicked ( mouseevent evt ) { if ( debug ) { logger . fine ( _str ) ; } clickhappened = _bool ; boolean consumed = _bool ; evt = new mapmouseevent ( getparentmode ( ) , evt ) ; if ( prioritylistener != null && evt . getclickcount ( ) > _num ) { prioritylistener . mouseclicked ( evt ) ; consumed = _bool ; } prioritylistener = null ; if ( proxy == null || evt . isshiftdown ( ) || ( proxydistributionmask & proxy_distrib_mouse_clicked ) > _num ) { iterator < mapmouselistener > it = iterator ( ) ; while ( it . hasnext ( ) && ! consumed ) { mapmouselistener target = it . next ( ) ; consumed = target . mouseclicked ( evt ) && consumeevents ; if ( consumed ) { prioritylistener = target ; } } } boolean ignoreconsumed = ! consumed || ( consumed && ( ( proxydistributionmask & proxy_ack_consumed_mouse_clicked ) == _num ) ) ; if ( proxy != null && ignoreconsumed && ! evt . isshiftdown ( ) ) { proxy . mouseclicked ( evt ) ; consumed = _bool ; } return consumed ; }	handle a mouseclicked mouselistener event.
public static string formatsqlvalues ( string ... values ) { stringbuilder builder = new stringbuilder ( _str ) ; for ( int i = _num ; i < values . length ; i ++ ) { if ( i > _num ) { builder . append ( _str ) ; } builder . append ( _str ) ; builder . append ( escapesqlstring ( values [ i ] ) ) ; builder . append ( _str ) ; } builder . append ( _str ) ; return builder . tostring ( ) ; }	formats an array of values as a sql values like ( ' value1 ' , ' value2 ' ,.
protected void paintcontentbordertopedge ( graphics g , int x , int y , int w , int h , boolean drawbroken , rectangle selrect , boolean iscontentborderpainted ) { if ( iscontentborderpainted ) { g . setcolor ( selecthighlight ) ; g . fillrect ( x , y , w - _num , _num ) ; } }	draws the top edge of the border around the content area.
public void analyzeallitandwriteresults ( ) { runresultsloader rundir = new runresultsloader ( rundirectory , null ) ; printstream stream ; try { stream = new printstream ( new file ( outputdir + _str ) ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; return ; } string header = _str ; stream . println ( header ) ; double totalttit ; double [ ] avgroutettsit ; int [ ] routeusersit ; for ( int i = _num ; i <= lastiteration ; i ++ ) { log . info ( _str + i + _str + lastiteration + _str ) ; string eventsfilename = rundir . geteventsfilename ( i ) ; eventsmanager eventsmanager = new eventsmanagerimpl ( ) ; ttanalyzebraess handler = new ttanalyzebraess ( ) ; eventsmanager . addhandler ( handler ) ; matsimeventsreader reader = new matsimeventsreader ( eventsmanager ) ; reader . readfile ( eventsfilename ) ; totalttit = handler . gettotaltt ( ) ; avgroutettsit = handler . calculateavgroutetts ( ) ; routeusersit = handler . getrouteusers ( ) ; stringbuffer line = new stringbuffer ( ) ; line . append ( i + _str + totalttit ) ; for ( int j = _num ; j < _num ; j ++ ) { line . append ( _str + routeusersit [ j ] ) ; } for ( int j = _num ; j < _num ; j ++ ) { line . append ( _str + avgroutettsit [ j ] ) ; } stream . println ( line . tostring ( ) ) ; } stream . close ( ) ; log . info ( lastiteration + _str ) ; }	analyzes all iterations in terms of route choice and travel time.
public int executeupdate ( string sql ) throws sqlexception { return util . truncateandconverttoint ( executelargeupdate ( sql ) ) ; }	execute a sql insert , update or delete statement.
@ layoutlibdelegate static long currentthreadtimemillis ( ) { return system . currenttimemillis ( ) ; }	returns milliseconds running in the current thread .
public static entry makeentry ( list < string > ldiflines ) { return makeentry ( ldiflines . toarray ( new string [ ldiflines . size ( ) ] ) ) ; }	builds an entry from the provided lines of ldif .
void clearparserhighlights ( ) { for ( int i = _num ; i < parserhighlights . size ( ) ; i ++ ) { object tag = parserhighlights . get ( i ) ; if ( tag instanceof layeredhighlightinfo ) { layeredhighlightinfo lhi = ( layeredhighlightinfo ) tag ; if ( lhi . width > _num && lhi . height > _num ) { textarea . repaint ( lhi . x , lhi . y , lhi . width , lhi . height ) ; } } else { highlightinfo info = ( highlightinfo ) tag ; textui ui = textarea . getui ( ) ; ui . damagerange ( textarea , info . getstartoffset ( ) , info . getendoffset ( ) ) ; } } parserhighlights . clear ( ) ; }	removes all parser highlights .
@ override public final short readshort ( ) throws ioexception { dis . readfully ( work , _num , _num ) ; return ( short ) ( ( work [ _num ] & _num ) << _num | ( work [ _num ] & _num ) ) ; }	read short , 16 - bits.
public int format ( int val , byte [ ] buf , int off , int len ) { if ( val == integer . min_value ) { if ( len > byteformatter . number_base ) { return format ( _str , buf , off , len ) ; } else { truncationfiller ( buf , off , len ) ; return off + len ; } } int pos = math . abs ( val ) ; int ndig = _num ; int dmax = byteformatter . number_base ; while ( ndig < byteformatter . number_base && pos >= dmax ) { ndig ++ ; dmax *= byteformatter . number_base ; } if ( val < _num ) { ndig ++ ; } if ( ndig > len || ndig > buf . length - off ) { truncationfiller ( buf , off , len ) ; return off + len ; } off += ndig ; int xoff = off - _num ; do { buf [ xoff ] = byteformatter . digits [ pos % byteformatter . number_base ] ; xoff -- ; pos /= byteformatter . number_base ; } while ( pos > _num ) ; if ( val < _num ) { buf [ xoff ] = ( byte ) _str ; } return off ; }	format an int into an existing array .
public void append ( char c [ ] ) { int maxlength = buffer . length - pos ; if ( c . length < maxlength ) { system . arraycopy ( c , _num , buffer , pos , c . length ) ; pos += c . length ; } else { system . arraycopy ( c , _num , buffer , pos , maxlength ) ; curr . next = new entity ( buffer ) ; curr = curr . next ; length += buffer . length ; buffer = new char [ ( buffer . length > c . length - maxlength ) ? buffer . length : c . length - maxlength ] ; if ( c . length > maxlength ) { system . arraycopy ( c , maxlength , buffer , _num , c . length - maxlength ) ; pos = c . length - maxlength ; } else { pos = _num ; } } }	method to appennd a charr array to the buffer.
public static boolean haspermission ( security security , genericvalue userlogin , genericvalue orderheader ) { if ( userlogin == null || orderheader == null ) return _bool ; if ( security . hasentitypermission ( _str , _str , userlogin ) ) { return _bool ; } else if ( security . hasentitypermission ( _str , _str , userlogin ) ) { list < genericvalue > orderroles = null ; try { orderroles = orderheader . getrelated ( _str , utilmisc . tomap ( _str , userlogin . getstring ( _str ) ) , null , _bool ) ; } catch ( genericentityexception e ) { debug . logerror ( e , _str , module ) ; } if ( utilvalidate . isnotempty ( orderroles ) ) { return _bool ; } } return _bool ; }	checks to see if this user has read permission on the specified order.
private boolean isannotation ( ) { return implinterfaces . contains ( _str ) ; }	sees if the class under test is actually an annotation .
public final boolean isexceptionhandlerequivalent ( basicblock other ) { if ( exceptionhandlers != other . exceptionhandlers ) { enumeration < basicblock > e1 = getexceptionhandlers ( ) ; enumeration < basicblock > e2 = other . getexceptionhandlers ( ) ; while ( e1 . hasmoreelements ( ) ) { if ( ! e2 . hasmoreelements ( ) ) return _bool ; if ( e1 . nextelement ( ) != e2 . nextelement ( ) ) return _bool ; } if ( e2 . hasmoreelements ( ) ) return _bool ; } return _bool ; }	compare the in scope exception handlers of two blocks .
public int checksum ( ) { return calculatechecksum ( compile_checksum . tostring ( ) ) ; }	this value is good for naming the cache file .
public boolean longlabel ( ) { return fstate . longlabel ; }	returns true if long labels are uses in the indicator display .
public secretblock ( mario player , group parent , int stagezone , float xpos , float ypos , float yolowidth , image ... hitstate ) { super ( block_collision_data , xpos , ypos , _num , _num , ( image ) null ) ; this . hitstate = hitstate [ _num ] ; yoloview = new imageview ( hitstate [ _num ] ) ; yoloview . setfitwidth ( yolowidth ) ; this . parent = parent ; zone = stagezone ; }	constructs a single secretblock ( tile which generates one - ups in original game , but " yolo " image in this game ) .
public static boolean installnormal ( context context , string filepath ) { intent i = new intent ( intent . action_view ) ; file file = new file ( filepath ) ; if ( ! file . exists ( ) || ! file . isfile ( ) || file . length ( ) <= _num ) { return _bool ; } i . setdataandtype ( uri . parse ( _str + filepath ) , _str ) ; i . addflags ( intent . flag_activity_new_task ) ; context . startactivity ( i ) ; return _bool ; }	install package normal by system intent.
private void createinsertlist ( final iitem item , list < iitem > templist , list < iitem > insertlist , int depth , int removed ) { if ( ! templist . contains ( item ) ) { templist . add ( item ) ; if ( depth == _num ) { insertlist . add ( item ) ; } if ( item . getitems ( ) != null ) { depth ++ ; for ( iitem child : item . getitems ( ) ) { createinsertlist ( child , templist , insertlist , depth , removed ) ; } } } else { insertlist . remove ( item ) ; removed ++ ; } }	recursive helper method for createinsertlist.
@ suppresswarnings ( _str ) public int readoutlinefilemetadata ( final pdfobject outlinesobj , final pdfobjectreader currentpdffile ) { final int count = outlinesobj . getint ( pdfdictionary . count ) ; final pdfobject firstobj = outlinesobj . getdictionary ( pdfdictionary . first ) ; currentpdffile . checkresolved ( firstobj ) ; if ( firstobj != null ) { final element root = outlinedataxml . createelement ( _str ) ; outlinedataxml . appendchild ( root ) ; final int level = _num ; readoutlinelevel ( root , currentpdffile , firstobj , level , _bool ) ; } return count ; }	read the outline data.
private int decoderunlength ( int k ) { if ( ( k & _num ) == _num ) { return ( ( k > > > _num ) & _num ) ^ _num ; } else { return integer . numberofleadingzeros ( k << p + ( _num - sp ) ) + _num ; } }	more of less the opposite of the encoding function but just for getting out run lengths .
private static byte [ ] streamtobytes ( inputstream in , int length ) throws ioexception { byte [ ] bytes = new byte [ length ] ; int count ; int pos = _num ; while ( pos < length && ( ( count = in . read ( bytes , pos , length - pos ) ) != - _num ) ) { pos += count ; } if ( pos != length ) { throw new ioexception ( _str + length + _str + pos + _str ) ; } return bytes ; }	reads the contents of an inputstream into a byte [ ] .
public noduplicatevalueglobalconstraint ( abstractparameter < ? , ? > ... parameters ) { this . parameters = arrays . aslist ( parameters ) ; }	constructs a not - equal - value global parameter constraint.
@ suppresswarnings ( _str ) public rhythmoverlay inflateoverlay ( string configstring ) { list < string > configstrings = arrays . aslist ( configstring . split ( _str ) ) ; return inflateoverlayinternal ( configstrings , collections . empty_map , _num ) ; }	inflate a single overlay from overlay configuration string according to the syntax spec .
public static revocationhash bruteforcehash ( byte [ ] seed , byte [ ] target , int maxchildtries , int maxsiblingtries ) { for ( int i = _num ; i < maxchildtries ; i ++ ) { for ( int j = _num ; j < maxsiblingtries ; j ++ ) { revocationhash test = hashderivation . calculaterevocationhash ( seed , _num , j ) ; if ( arrays . equals ( test . getsecrethash ( ) , target ) ) { return new revocationhash ( i , j , test . getsecret ( ) , test . getsecrethash ( ) ) ; } } seed = tools . hashsecret ( seed ) ; } return null ; }	the other party has breached the contract and submitted an old channel transaction .
public fancyloader ( classloader parent ) { super ( parent ) ; try { mdexclass = parent . loadclass ( _str ) ; } catch ( classnotfoundexception cnfe ) { } }	construct fancyloader , grabbing a reference to the dexfile class if we ' re running under dalvik .
public boolean issourcemodified ( resource resource ) { boolean modified = _bool ; string filename = resource . getname ( ) ; string path = ( string ) templatepaths . get ( filename ) ; file currentfile = null ; for ( int i = _num ; currentfile == null && i < paths . size ( ) ; i ++ ) { string testpath = ( string ) paths . get ( i ) ; file testfile = new file ( testpath , filename ) ; if ( testfile . canread ( ) ) { currentfile = testfile ; } } file file = new file ( path , filename ) ; if ( currentfile == null || ! file . exists ( ) ) { } else if ( currentfile . equals ( file ) && file . canread ( ) ) { modified = ( file . lastmodified ( ) != resource . getlastmodified ( ) ) ; } return modified ; }	how to keep track of all the modified times across the paths.
protected void flip ( buffercapabilities . flipcontents flipaction ) { if ( peer != null ) { image backbuffer = getbackbuffer ( ) ; if ( backbuffer != null ) { peer . flip ( _num , _num , backbuffer . getwidth ( null ) , backbuffer . getheight ( null ) , flipaction ) ; } } else { throw new illegalstateexception ( _str ) ; } }	flipping moves the contents of the back buffer to the front buffer , either by copying or by moving the video pointer .
protected void loadvalue ( string svalue ) { try { value = byte . parsebyte ( svalue . trim ( ) ) ; } catch ( numberformatexception nfe ) { reverttodefault ( ) ; } }	load value from property string value.
public static map < string , string > allnamespaces ( soapelement ele ) { map < string , string > nslist = new treemap < string , string > ( ) ; log . trace ( _str + ele . getnodename ( ) ) ; allnamespaces ( ele , nslist ) ; log . trace ( _str + nslist ) ; return nslist ; }	returns a list of all namespaces below an element ( recursive ).
private void drawhook ( canvas canvas ) { path hookpath = new path ( ) ; double sweepangle = math . pi / _num * _num ; float y = ( float ) math . sin ( sweepangle ) * ( getbigcircleradius ( ) ) + rectf . height ( ) / _num ; float x = ( float ) math . cos ( sweepangle ) * ( getbigcircleradius ( ) ) + rectf . width ( ) / _num ; float i = getbigcircleradius ( ) / _num ; hookpath . addroundrect ( new rectf ( i + i / _num , i + i / _num , i + i / _num + _num , i + i + i / _num ) , _num , _num , path . direction . ccw ) ; hookpath . addroundrect ( new rectf ( i + i / _num , ( i + i + i / _num ) - _num , i + i / _num + i + i , i + i + i / _num + _num ) , _num , _num , path . direction . ccw ) ; matrix matrix = new matrix ( ) ; matrix . reset ( ) ; int restorecount = canvas . getsavecount ( ) ; hookpath . close ( ) ; canvas . rotate ( - _num , rectf . centerx ( ) , rectf . centery ( ) ) ; canvas . drawpath ( hookpath , mhookpaint ) ; canvas . restoretocount ( restorecount ) ; }	there is some bug and it ' s not perfect . so we should improve this path for our projection.
public static byte [ ] tobytearray ( bitmap bitmap , bitmap . compressformat format , int quality ) { bytearrayoutputstream out = null ; try { out = new bytearrayoutputstream ( ) ; bitmap . compress ( format , quality , out ) ; return out . tobytearray ( ) ; } finally { closeableutils . close ( out ) ; } }	compress the bitmap to the byte array as the specified format and quality .
public void continuebuttonactionperformed ( java . awt . event . actionevent e ) { if ( testrunning && testsuspended ) { testsuspended = _bool ; if ( wraptest ) { statustext1 . settext ( _str ) ; statustext1 . setvisible ( _bool ) ; } } }	method to handle continue button in diagnostic frame.
@ hlefunction ( nid = _num , version = _num ) public int scenetadhocptpflush ( @ checkargument ( _str ) int id , int timeout , int nonblock ) { return _num ; }	wait for data in the buffer to be sent.
public void reset ( ) { displaycache . clear ( ) ; cachedid . clear ( ) ; }	resets the drawer and its caches .
private void copydirectory ( file source , file dest ) throws ioexception { for ( file f : source . listfiles ( ) ) { file sourcefile = new file ( source , f . getname ( ) ) ; file destfile = new file ( dest , f . getname ( ) ) ; if ( f . isdirectory ( ) ) { destfile . mkdirs ( ) ; copydirectory ( sourcefile , destfile ) ; } else copyfile ( sourcefile , destfile ) ; } }	copy an entire directory from one location to another.
private synchronized void rebuildjournal ( ) throws ioexception { if ( mjournalwriter != null ) { mjournalwriter . close ( ) ; } writer writer = new bufferedwriter ( new filewriter ( mjournalfiletmp ) , io_buffer_size ) ; writer . write ( magic ) ; writer . write ( _str ) ; writer . write ( version_1 ) ; writer . write ( _str ) ; writer . write ( integer . tostring ( mappversion ) ) ; writer . write ( _str ) ; writer . write ( _str ) ; for ( cacheentry cacheentry : mlruentries . values ( ) ) { if ( cacheentry . isunderedit ( ) ) { writer . write ( saction_list [ action_dirty ] + _str + cacheentry . getkey ( ) + _str + cacheentry . getsize ( ) + _str ) ; } else { writer . write ( saction_list [ action_clean ] + _str + cacheentry . getkey ( ) + _str + cacheentry . getsize ( ) + _str ) ; } } writer . close ( ) ; mjournalfiletmp . renameto ( mjournalfile ) ; mjournalwriter = new bufferedwriter ( new filewriter ( mjournalfile , _bool ) , io_buffer_size ) ; }	creates a new journal that omits redundant information.
private void recordlogdata ( ) { try { int size = mrecordingdata . size ( ) ; if ( size == _num ) { return ; } vector < string > recordingdata = new vector < > ( mrecordingdata ) ; file logdir = constants . getrecorddir ( this ) ; logdir . mkdirs ( ) ; file logfile = new file ( logdir , mrecordingfilename ) ; filewriter logfilewriter = new filewriter ( logfile , _bool ) ; for ( int i = _num ; i < size ; i ++ ) { logfilewriter . append ( recordingdata . elementat ( i ) + _str ) ; mrecordingdata . removeelementat ( _num ) ; } recordingdata . removeallelements ( ) ; logfilewriter . close ( ) ; } catch ( exception e ) { log . e ( log_tag , _str + e . tostring ( ) ) ; } }	save log data to file.
private static list < command > loadrewrites ( string str ) { assert str != null ; list < command > commands = new arraylist < > ( ) ; for ( string line : str . split ( _str ) ) { addline ( commands , line ) ; } return commands ; }	loads the rewrites from tab - separated values .
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addall ( collections . list ( super . listoptions ( ) ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
@ override public stateconnection oncloseread ( ) { connectionprotocol request = request ( ) ; if ( request != null ) { request . oncloseread ( ) ; } _sequenceclose . set ( _sequenceread . get ( ) ) ; if ( _sequenceflush . get ( ) < _sequenceclose . get ( ) ) { _isclosepending . set ( _bool ) ; if ( _sequenceflush . get ( ) < _sequenceclose . get ( ) ) { return stateconnection . close_read_s ; } else { _isclosepending . set ( _bool ) ; return stateconnection . close ; } } else { return stateconnection . close ; } }	called by reader thread on reader end of file .
public void httprequest ( httprequestevent e ) throws java . io . ioexception { string request = e . getrequest ( ) ; if ( debug . debugging ( _str ) ) { debug . output ( _str + request + _str ) ; } if ( request . charat ( _num ) == _str ) { request = request . substring ( _num , request . length ( ) ) ; } int index = _num ; index = request . indexof ( _str ) ; if ( index != - _num ) { request = request . substring ( index + _num , request . length ( ) ) ; debug . message ( _str , _str ) ; } else { debug . message ( _str , _str ) ; } try { iserver . handlerequest ( request , e . getoutputstream ( ) ) ; } catch ( ioexception ioe ) { debug . error ( _str + ioe . getmessage ( ) ) ; } catch ( maprequestformatexception exception ) { string message = _str + exception . getmessage ( ) + _str + errormessage ; httpconnection . writehttpresponse ( e . getoutputstream ( ) , httpconnection . content_plain , message ) ; } }	invoked when an http request is received .
public void testconstructorbytesnegative2 ( ) { byte abytes [ ] = { - _num , _num , _num } ; byte rbytes [ ] = { - _num , _num , _num } ; biginteger anumber = new biginteger ( abytes ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = anumber . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , anumber . signum ( ) ) ; }	create a negative number from an array of bytes.
public string format ( double val ) { decimalformat df = getdoubleformat ( ) ; if ( df != null ) { return df . format ( val ) ; } return double . tostring ( val ) ; }	formats the given double values .
public void removepositions ( collection < integer > positions ) { arraylist < integer > positionslist = new arraylist < integer > ( positions ) ; collections . sort ( positionslist ) ; collections . reverse ( positionslist ) ; for ( int position : positionslist ) { mitems . remove ( position ) ; } notifydatasetchanged ( ) ; }	removes all elements at the specified positions in the list.
private void resetshapebounds ( ) { roundrectangle2d . double rrect = ( roundrectangle2d . double ) shape ; rrect . setroundrect ( _num , _num , getbounds ( ) . width - _num , getbounds ( ) . height - _num , _num , _num ) ; }	rests the boundaries of the shape which is drawn as the rubberband.
public static colour attempttogetascolour ( string part ) { colour col = null ; try { col = colour . valueof ( part . touppercase ( ) ) ; } catch ( exception e ) { } return col ; }	attempt to parse string as a colour.
public int rank ( ) { double eps = math . pow ( _num , - _num ) ; double tol = math . max ( m , n ) * s [ _num ] * eps ; int r = _num ; for ( int i = _num ; i < s . length ; i ++ ) { if ( s [ i ] > tol ) { r ++ ; } } return r ; }	effective numerical matrix rank.
public static void executerandommodifiablevariablemodification ( modifiablevariableholder object ) { field field = object . getrandommodifiablevariablefield ( ) ; executemodifiablevariablemodification ( object , field ) ; }	picks a random modifiable variable and executes a random modification on this variable .
public static boolean save ( file file , string content ) { boolean result ; bufferedwriter writer ; writer = null ; try { writer = new bufferedwriter ( new filewriter ( file ) ) ; writer . write ( content ) ; writer . flush ( ) ; result = _bool ; } catch ( exception e ) { e . printstacktrace ( ) ; result = _bool ; } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( exception e ) { } } } return result ; }	saves the content to a file .
private void deleteoldtemp ( file filecfg ) { bufferedreader reader = null ; try { int count = _num ; reader = new bufferedreader ( new filereader ( filecfg ) ) ; string sline ; while ( ( sline = reader . readline ( ) ) != null ) { file file = new file ( sline ) ; if ( ! file . exists ( ) ) { continue ; } if ( file . delete ( ) ) { count ++ ; } else { hsdeleteonexit . add ( file ) ; } } logdebug ( logarea . config , _str , count , filecfg . getabsolutepath ( ) ) ; } catch ( ioexception e ) { } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( ioexception e ) { } } } }	deletes temporary files listed in the file.
public void flush ( ) { final bigdatasailrepositoryconnection cxn = tltx . get ( ) ; if ( cxn != null ) { code . wrapthrow ( null ) ; } }	flush the statement buffers to the indices without committing .
@ override public bufferedimage jpegtorgbimage ( final byte [ ] data , final int ww , final int hh , final int px , final int py ) { bufferedimage image = null ; raster ras = jpegdecoder . getrasterfromjpeg ( data , _str ) ; if ( ras != null ) { ras = cleanupraster ( ras , px , py , componentcount ) ; final int w = ras . getwidth ( ) ; final int h = ras . getheight ( ) ; final databufferbyte rgb = ( databufferbyte ) ras . getdatabuffer ( ) ; image = createimage ( w , h , rgb . getdata ( ) ) ; } return image ; }	convert data stream to srgb image.
public void despawn ( visibleobject object ) { despawn ( object , _bool ) ; }	despawn visibleobject , object will become invisible and object position will become invalid.
public string eventtopic ( string eventid ) { if ( eventid == null ) { eventid = _str ; } return evttopic . replace ( _str , eventid ) ; }	get the mqtt topic for an device event .
public matchresult match ( ) { if ( ! matchsuccessful ) { throw new illegalstateexception ( ) ; } return matcher . tomatchresult ( ) ; }	returns the result of the last matching operation.
@ suppresswarnings ( _str ) public static void createprojectconstraint ( zipfile zip , project aproject , repositoryservice arepository ) throws ioexception { for ( enumeration zipenumerate = zip . entries ( ) ; zipenumerate . hasmoreelements ( ) ; ) { zipentry entry = ( zipentry ) zipenumerate . nextelement ( ) ; string entryname = normalizeentryname ( entry ) ; if ( entryname . startswith ( constraints ) ) { string filename = filenameutils . getname ( entry . getname ( ) ) ; constraintset constraintset = new constraintset ( ) ; constraintset . setproject ( aproject ) ; constraintset . setname ( filename ) ; arepository . createconstraintset ( constraintset ) ; arepository . writeconstraintset ( constraintset , zip . getinputstream ( entry ) ) ; log . info ( _str + filename + _str + aproject . getname ( ) + _str + aproject . getid ( ) + _str ) ; } } }	copy constraints from the exported project.
public string decode ( string pstring ) throws decoderexception { if ( pstring == null ) { return null ; } try { return decode ( pstring , getdefaultcharset ( ) ) ; } catch ( unsupportedencodingexception e ) { throw new decoderexception ( e . getmessage ( ) ) ; } }	decodes a url safe string into its original form using the default string charset.
public operation copyto ( extent target ) { blocktransformextent extent = new blocktransformextent ( original , transform , worlddata . getblockregistry ( ) ) ; forwardextentcopy copy = new forwardextentcopy ( extent , original . getregion ( ) , original . getorigin ( ) , target , original . getorigin ( ) ) ; copy . settransform ( transform ) ; return copy ; }	create an operation to copy from the original clipboard to the given extent .
@ callersensitive public class < ? > forclass ( ) { if ( cl == null ) { return null ; } requireinitialized ( ) ; if ( system . getsecuritymanager ( ) != null ) { class < ? > caller = reflection . getcallerclass ( ) ; if ( reflectutil . needspackageaccesscheck ( caller . getclassloader ( ) , cl . getclassloader ( ) ) ) { reflectutil . checkpackageaccess ( cl ) ; } } return cl ; }	return the class in the local vm that this version is mapped to.
private void pathstylehelper ( string style , string offset ) { if ( style == null ) { return ; } if ( style . equals ( _str ) ) { strokepaint . setpatheffect ( null ) ; return ; } stringtokenizer st = new stringtokenizer ( style , _str ) ; int count = st . counttokens ( ) ; float [ ] intervals = new float [ ( count & _num ) == _num ? count * _num : count ] ; float max = _num ; float current = _num ; int i = _num ; while ( st . hasmoretokens ( ) ) { intervals [ i ++ ] = current = tofloat ( st . nexttoken ( ) , current ) ; max += current ; } for ( int start = _num ; i < intervals . length ; i ++ , start ++ ) { max += intervals [ i ] = intervals [ start ] ; } float off = _num ; if ( offset != null ) { try { off = float . parsefloat ( offset ) % max ; } catch ( numberformatexception e ) { } } strokepaint . setpatheffect ( new dashpatheffect ( intervals , off ) ) ; }	set the path style ( if any ) stroke - dasharray = " n1 , n2 ,.
private float colortoangle ( int color ) { float [ ] colors = new float [ _num ] ; color . colortohsv ( color , colors ) ; return ( float ) math . toradians ( - colors [ _num ] ) ; }	convert a color to an angle .
private size parseoldboundedsize ( string token , boolean setmax ) { int semicolonindex = token . indexof ( _str ) ; string sizetoken1 = token . substring ( _num , semicolonindex ) ; string sizetoken2 = token . substring ( semicolonindex + _num , token . length ( ) - _num ) ; size size1 = parseatomicsize ( sizetoken1 ) ; size size2 = parseatomicsize ( sizetoken2 ) ; if ( isconstant ( size1 ) ) { if ( size2 instanceof sizes . componentsize ) { return new boundedsize ( size2 , setmax ? null : size1 , setmax ? size1 : null ) ; } throw new illegalargumentexception ( _str ) ; } if ( isconstant ( size2 ) ) { return new boundedsize ( size1 , setmax ? null : size2 , setmax ? size2 : null ) ; } throw new illegalargumentexception ( _str ) ; }	parses an encoded compound size and sets the size fields.
builder addencodedqueryparameter ( string encodedname , string encodedvalue ) { if ( encodedname == null ) throw new illegalargumentexception ( _str ) ; if ( encodedquerynamesandvalues == null ) encodedquerynamesandvalues = new arraylist < > ( ) ; encodedquerynamesandvalues . add ( canonicalize ( encodedname , query_component_encode_set , _bool , _bool ) ) ; encodedquerynamesandvalues . add ( encodedvalue != null ? canonicalize ( encodedvalue , query_component_encode_set , _bool , _bool ) : null ) ; return this ; }	adds the pre - encoded query parameter to this url ' s query string .
private static a createimagelink ( string ad_language , string name , string js_command , boolean enabled , boolean pressed ) { a img = new a ( _str , createimage ( ad_language , name ) ) ; if ( ! pressed || ! enabled ) img . setid ( _str ) ; else img . setid ( _str ) ; if ( js_command == null ) js_command = _str ; if ( js_command . length ( ) > _num && enabled ) { if ( js_command . startswith ( _str ) ) img . setonclick ( js_command ) ; else img . setonclick ( _str + name + _str + js_command + _str ) ; } img . setclass ( _str ) ; img . setonmouseover ( _str + name + _str ) ; img . setonmouseout ( _str ) ; img . setonblur ( _str ) ; return img ; }	create image with name , id of button_name and set p_command onclick.
public namespace ( principaluser creator , string qualifier , principaluser owner , set < principaluser > users ) { super ( creator ) ; setqualifier ( qualifier ) ; setowner ( owner ) ; if ( users != null && ! users . isempty ( ) ) { setusers ( users ) ; } adduser ( owner ) ; }	creates a new namespace object .
public final int decrementandget ( ) { return unsafe . getandaddint ( this , valueoffset , - _num ) - _num ; }	atomically decrements by one the current value .
public void update ( long dt , float ratioy ) { double step = _num * math . pi / points_per_circle ; angle += dt * bubble_d_angle ; float fromx = startx + ( float ) ( _num * math . sin ( angle ) ) ; float tox = fromx + size ; float fromy = this . fromy + dt * speed ; float toy = fromy + size ; centery += dt * virtualspeed ; getcolor ( ) [ _num ] = ( top_y - centery / top_y ) ; vertexbuffer . put ( _num , utils . normalizegl ( _num , fromx , tox ) ) ; vertexbuffer . put ( _num , utils . normalizegl ( centery * ratioy , fromy , toy ) ) ; for ( int i = _num ; i <= points_per_circle ; i ++ ) { vertexbuffer . put ( coords_per_vertex * i , utils . normalizegl ( ( float ) math . sin ( - math . pi + step * i ) , fromx , tox ) ) ; vertexbuffer . put ( coords_per_vertex * i + _num , utils . normalizegl ( ( float ) math . cos ( - math . pi + step * i ) * ratioy , fromy , toy ) ) ; } this . fromy = fromy ; }	update position of bubble .
public final void clear ( ) { if ( gwt . isscript ( ) ) { jsarray . clear ( ) ; } else { javaarray . clear ( ) ; } }	remove all elements on this list.
void fullylock ( ) { putlock . lock ( ) ; takelock . lock ( ) ; }	locks to prevent both puts and takes .
@ override public synchronized void clear ( ) { file [ ] files = mrootdirectory . listfiles ( ) ; if ( files != null ) { for ( file file : files ) { file . delete ( ) ; } } mentries . clear ( ) ; volleylog . d ( _str ) ; }	clears the cache . deletes all cached files from disk .
private void updatepodcastpublicationdateandlastmediaurl ( episode episode , podcast podcast ) { date podcastpublicationdate = podcast . getpublicationdate ( ) ; boolean episodepubdateismorerecent = episode . getpublicationdate ( ) != null && ( podcastpublicationdate == null || podcastpublicationdate . before ( episode . getpublicationdate ( ) ) ) ; if ( episodepubdateismorerecent ) { podcast . setpublicationdate ( episode . getpublicationdate ( ) ) ; podcast . setlastepisodemediaurl ( episode . getmediaurl ( ) ) ; } }	set the podcast ' s publication date to the episode ' s if it is more recent.
private void removeouruis ( ) { for ( string uiname : ui_list ) { uidefaults . remove ( uiname + _str ) ; } }	use our ui delegate for the specified ui control type .
public void makeimmutable ( ) { }	makes the object immutable.
public static < o > knnquery < o > precomputedknnquery ( database database , relation < o > relation , distancequery < o > dq , int k ) { knnquery < o > knnq = database . getknnquery ( dq , k , databasequery . hint_heavy_use , databasequery . hint_optimized_only , databasequery . hint_no_cache ) ; if ( knnq instanceof preprocessorknnquery ) { return knnq ; } materializeknnpreprocessor < o > preproc = new materializeknnpreprocessor < > ( relation , dq . getdistancefunction ( ) , k ) ; preproc . initialize ( ) ; return preproc . getknnquery ( dq , k ) ; }	get ( or create ) a precomputed knn query for the database .
public static sortedset < integer > adjustposition ( set < integer > positions , int startposition , int endposition , int adjustby ) { sortedset < integer > newpositions = new treeset < > ( ) ; for ( integer entry : positions ) { int position = entry ; if ( position < startposition || position > endposition ) { newpositions . add ( position ) ; } else if ( adjustby > _num ) { newpositions . add ( position + adjustby ) ; } else if ( adjustby < _num ) { if ( position > startposition + adjustby && position <= startposition ) { ; } else { newpositions . add ( position + adjustby ) ; } } } return newpositions ; }	internal method to handle the selections if items are added / removed.
private static void addid ( final stringbuilder buf , final byte [ ] id ) { buf . append ( _str ) ; boolean backslash = _bool ; for ( final byte b : id ) { buf . append ( ( char ) ( b & _num ) ) ; if ( b == _str && backslash ) { buf . append ( _str ) ; } else { backslash = b == _str ; } } buf . append ( _str ) ; }	appends the given id to the given buffer , followed by " \ \ e ".
private resolvedmigration createavailablemigration ( int version ) { resolvedmigration migration = new resolvedmigration ( ) ; migration . setversion ( migrationversion . fromversion ( integer . tostring ( version ) ) ) ; migration . setdescription ( _str ) ; migration . setscript ( _str ) ; migration . settype ( migrationtype . cql ) ; return migration ; }	creates a new available migration with this version .
public void comment ( string data ) throws saxexception { m_docisempty = _bool ; final int length = data . length ( ) ; if ( length > m_charsbuff . length ) { m_charsbuff = new char [ length * _num + _num ] ; } data . getchars ( _num , length , m_charsbuff , _num ) ; comment ( m_charsbuff , _num , length ) ; }	receive notification of a comment .
public boolean drawimage ( image img , affinetransform xform , imageobserver observer ) { if ( img == null ) { return _bool ; } if ( xform == null || xform . isidentity ( ) ) { return drawimage ( img , _num , _num , null , observer ) ; } if ( ishidpiimage ( img ) ) { final int w = img . getwidth ( null ) ; final int h = img . getheight ( null ) ; final affinetransform tx = new affinetransform ( transform ) ; transform ( xform ) ; boolean result = drawhidpiimage ( img , _num , _num , w , h , _num , _num , w , h , null , observer ) ; transform . settransform ( tx ) ; invalidatetransform ( ) ; return result ; } try { return imagepipe . transformimage ( this , img , xform , observer ) ; } catch ( invalidpipeexception e ) { try { revalidateall ( ) ; return imagepipe . transformimage ( this , img , xform , observer ) ; } catch ( invalidpipeexception e2 ) { return _bool ; } } finally { surfacedata . markdirty ( ) ; } }	draw an image , applying a transform from image space into user space before drawing.
public void begindisplay ( displayevent event ) throws modelcontrolexception { super . begindisplay ( event , _bool ) ; resetbuttonstate ( tbl_button_delete ) ; agentsmodel model = ( agentsmodel ) getmodel ( ) ; string agenttype = getdisplayidtype ( ) ; object [ ] param = { agenttype } ; ptmodel . setpagetitletext ( model . getlocalizedstring ( _str + agenttype ) ) ; ptmodel . setpagetitlehelpmessage ( model . getlocalizedstring ( _str + agenttype + _str ) ) ; tblmodel . settitle ( messageformat . format ( model . getlocalizedstring ( _str ) , param ) ) ; tblmodel . settitlelabel ( messageformat . format ( model . getlocalizedstring ( _str ) , param ) ) ; tblmodel . setsummary ( messageformat . format ( model . getlocalizedstring ( _str ) , param ) ) ; tblgroupmodel . settitle ( messageformat . format ( model . getlocalizedstring ( _str ) , param ) ) ; tblgroupmodel . settitlelabel ( messageformat . format ( model . getlocalizedstring ( _str ) , param ) ) ; tblgroupmodel . setsummary ( messageformat . format ( model . getlocalizedstring ( _str ) , param ) ) ; getagentnames ( ) ; ccbutton b = ( ccbutton ) getchild ( tbl_button_delete ) ; b . setdisabled ( _bool ) ; b = ( ccbutton ) getchild ( tbl_button_delete_group ) ; b . setdisabled ( _bool ) ; }	sets the agent title and populates the agent and agent group action table .
public void select_all ( ) { arrays . fill ( sel_array , _bool ) ; }	selects all item types .
public nvpbuilder addraw ( final string name , final string value ) { npv . put ( name , value ) ; return this ; }	add raw name value pair .
@ override public int length ( ) { return set . size ( ) ; }	returns the set length.
public final long readunsignedint ( ) throws ioexception { mposition += _num ; d . readfully ( w , _num , _num ) ; return ( ( long ) ( w [ _num ] ) << _num | ( w [ _num ] & _num ) << _num | ( w [ _num ] & _num ) << _num | ( w [ _num ] & _num ) ) & _num ; }	like datainputstream . readint except little endian and for unsigned integers .
public list < countryro > viewaddresscountryoptions ( final shoppingcart cart , final shop shop , final string addresstype ) { final list < country > countries = addressbookfacade . getallcountries ( shop . getcode ( ) , addresstype ) ; return map ( countries , countryro . class , country . class ) ; }	common address book function .
public void addpauselistener ( animatorpauselistener listener ) { if ( mpauselisteners == null ) { mpauselisteners = new arraylist < animatorpauselistener > ( ) ; } mpauselisteners . add ( listener ) ; }	adds a pause listener to this animator .
@ override public void makeimmutable ( ) { if ( mutable ) { if ( attrs != null ) { iterator iter = attrs . iterator ( ) ; while ( iter . hasnext ( ) ) { attribute attr = ( attribute ) iter . next ( ) ; attr . makeimmutable ( ) ; } attrs = collections . unmodifiablelist ( attrs ) ; } if ( encattrs != null ) { encattrs = collections . unmodifiablelist ( encattrs ) ; } mutable = _bool ; } }	makes the object immutable .
public void addcomponent ( t component ) { components . add ( component ) ; }	adds a component to the composite .
public static uiresult openurl ( uri uri ) { return openurl ( uri . tostring ( ) ) ; }	launch url in a new window .
public final void invalidateline ( int line ) { repaint ( _num , textarea . linetoy ( line ) + fm . getmaxdescent ( ) + fm . getleading ( ) , getwidth ( ) , fm . getheight ( ) ) ; }	marks a line as needing a repaint .
public bytebandedraster ( samplemodel samplemodel , point origin ) { this ( samplemodel , samplemodel . createdatabuffer ( ) , new rectangle ( origin . x , origin . y , samplemodel . getwidth ( ) , samplemodel . getheight ( ) ) , origin , null ) ; }	constructs a bytebandedraster with the given samplemodel.
private void initialize ( uri p_other ) { m_scheme = p_other . getscheme ( ) ; m_userinfo = p_other . getuserinfo ( ) ; m_host = p_other . gethost ( ) ; m_port = p_other . getport ( ) ; m_path = p_other . getpath ( ) ; m_querystring = p_other . getquerystring ( ) ; m_fragment = p_other . getfragment ( ) ; }	initialize all fields of this uri from another uri .
private e unlinklast ( ) { node < e > l = last ; if ( l == null ) return null ; node < e > p = l . prev ; e item = l . item ; l . item = null ; l . prev = l ; last = p ; if ( p == null ) first = null ; else p . next = null ; -- count ; notfull . signal ( ) ; return item ; }	removes and returns last element , or null if empty .
static boolean isrefreshnotificationregistered ( notificationlistener client , refreshnotificationtype type ) { boolean isregistered = _bool ; map < refreshnotificationtype , integer > notifications = null ; synchronized ( refreshclients ) { notifications = ( map < refreshnotificationtype , integer > ) refreshclients . get ( client ) ; } if ( notifications != null ) { integer timernotificationid = notifications . get ( type ) ; if ( timernotificationid != null ) { isregistered = _bool ; } } return isregistered ; }	verifies a refresh notification for the specified client mbean . if notification is not registered , then returns a false.
private collection < string > readprocessoutput ( process proc ) throws ioexception { bufferedreader rdr = new bufferedreader ( new inputstreamreader ( proc . getinputstream ( ) ) ) ; collection < string > res = new arraylist < > ( ) ; string s ; while ( ( s = rdr . readline ( ) ) != null ) res . add ( s ) ; return res ; }	reads process output line - by - line .
public void fillheaderandfooter ( final httpservletrequest request , final httpservletresponse response , final map < string , object > datamodel ) throws exception { fillheader ( request , response , datamodel ) ; fillfooter ( datamodel ) ; }	fills header and footer .
public void addoperand ( ispacepredicate operand ) { if ( _operandslist == null ) _operandslist = new arraylist < ispacepredicate > ( ) ; _operandslist . add ( operand ) ; }	adds an operand at the end of the current operands list .
public bigdecimal calculatetotalcollectedamt ( final billreceiptinfo bri , final list < egbilldetails > billdetlist ) throws invalidaccountheadexception { return bri . gettotalamount ( ) ; }	called to calculate the total receipt amount i , e the amount which has been paid for the bill from the billreceiptinfo the amount will be calculated.
public void skip ( int count ) throws ioexception { int skipcount = math . min ( limit - position , count ) ; while ( _bool ) { position += skipcount ; count -= skipcount ; if ( count == _num ) break ; skipcount = math . min ( count , capacity ) ; require ( skipcount ) ; } }	discards the specified number of bytes .
public void removeallims ( ) { ims . clear ( ) ; }	removes all im ' s from this user.
static string escapestringforascii ( string s ) { string out = _str ; char [ ] carray = s . tochararray ( ) ; for ( int i = _num ; i < carray . length ; i ++ ) { char c = carray [ i ] ; if ( c > _num ) { out += _str ; string hex = integer . tohexstring ( c ) ; while ( hex . length ( ) < _num ) hex = _str + hex ; out += hex ; } else if ( c == _str ) { out += _str ; } else if ( c == _str ) { out += _str ; } else if ( c == _str ) { out += _str ; } else if ( c == _str ) { out += _str ; } else if ( c == _str ) { out += _str ; } else if ( c == _str ) { out += _str ; } else { out += c ; } } return out ; }	escapes a string for use in ascii property lists .
public void copyreader ( string encoding , reader r ) throws ioexception { super . setcontentencoding ( encoding ) ; string s = readstring ( r ) ; content = s . getbytes ( encoding ) ; }	set the content by copying characters from the given reader and converting them into bytes using the specified encoding .
private void cleardictionarycache ( ) { map < string , dictionary > dictionarycaches = surrogatekeygen . getdictionarycaches ( ) ; list < dictionary > reversedictionaries = new arraylist < > ( dictionarycaches . values ( ) ) ; for ( int i = _num ; i < reversedictionaries . size ( ) ; i ++ ) { dictionary dictionary = reversedictionaries . get ( i ) ; dictionary . clear ( ) ; } }	this method will clear the dictionary access count so that any unused column can be removed from the cache.
public static string totypestring ( object [ ] arguments , int maxsize ) { if ( arguments == null ) { return _str ; } stringbuilder argbuf = new stringbuilder ( ) ; for ( int i = _num ; i < arguments . length ; i ++ ) { if ( maxsize != - _num && argbuf . length ( ) > maxsize ) { argbuf . append ( _str ) ; break ; } else { if ( i > _num ) { argbuf . append ( _str ) ; } argbuf . append ( arguments [ i ] != null ? typename ( arguments [ i ] ) : _str ) ; } } return argbuf . tostring ( ) ; }	a helper method to format the arguments types as a comma - separated list .
public boolean renamefile ( file oldfile , file newfile ) { synchronized ( filecache ) { if ( oldfile . renameto ( newfile ) ) { validatefilecache ( ) ; return _bool ; } return _bool ; } }	renames a file in the underlying file system .
public future < ? > execute ( cameracommand command ) { if ( mclosed ) { return futures . immediatefuture ( null ) ; } synchronized ( mlock ) { if ( mexecutor == null ) { mexecutor = mexecutorprovider . get ( ) ; } checknotnull ( mexecutor ) ; return mexecutor . submit ( new commandrunnable ( command ) ) ; } }	executes the given command , returning a future to indicate its status and allow ( interruptible ) cancellation .
public static enumset < kindname > kindnames ( int kind ) { enumset < kindname > kinds = enumset . noneof ( kindname . class ) ; if ( ( kind & val ) != _num ) kinds . add ( ( ( kind & val ) == var ) ? kindname . var : kindname . val ) ; if ( ( kind & mth ) != _num ) kinds . add ( kindname . method ) ; if ( ( kind & typ ) != _num ) kinds . add ( kindname . class ) ; if ( ( kind & pck ) != _num ) kinds . add ( kindname . package ) ; return kinds ; }	a set of kindname ( s ) representing a set of symbol ' s kinds .
public int length ( ) { return text . length ( ) ; }	retruns the length of the text.
public static string serializedigestresponse ( map < string , string > parammap ) { stringbuilder sb = new stringbuilder ( _str ) ; boolean prefixcomma = _bool ; for ( map . entry < string , string > entry : parammap . entryset ( ) ) { if ( ! prefixcomma ) { prefixcomma = _bool ; } else { sb . append ( _str ) ; } sb . append ( entry . getkey ( ) ) ; sb . append ( _str ) ; sb . append ( entry . getvalue ( ) ) ; } return sb . tostring ( ) ; }	serialize a parameter map into a digest response.
public void populatecombos ( activity activity , final listener listener ) { list < string > services = getservices ( activity . getpackagemanager ( ) ) ; populatecombos ( activity , services , listener ) ; }	collect together the languages supported by the given services and call back once done .
protected jsonencoding findencoding ( mediatype mediatype , multivaluedmap < string , object > httpheaders ) { return jsonencoding . utf8 ; }	helper method to use for determining desired output encoding.
static bufferedimage convertimage ( bufferedimage image ) { switch ( image . gettype ( ) ) { case bufferedimage . type_int_argb_pre : return image ; case bufferedimage . type_4byte_abgr : image . coercedata ( _bool ) ; return image ; } bufferedimage convertedimage = new bufferedimage ( image . getwidth ( ) , image . getheight ( ) , bufferedimage . type_int_argb_pre ) ; graphics2d g = convertedimage . creategraphics ( ) ; g . setcolor ( new java . awt . color ( _num , _num , _num , _num ) ) ; g . fillrect ( _num , _num , image . getwidth ( ) , image . getheight ( ) ) ; g . drawimage ( image , _num , _num , null ) ; g . dispose ( ) ; return convertedimage ; }	converts the given image into a format for quick upload to the gpu .
public long start ( ) { starttime = system . currenttimemillis ( ) ; return starttime ; }	start the stop watch .
public void next ( ) { if ( iterator . hasnext ( ) ) { view currentview = iterator . next ( ) ; if ( isusingdefaultlistener ( ) ) currentview . setonclicklistener ( null ) ; if ( iterator . nextindex ( ) < mviews . size ( ) ) { view nextview = mviews . get ( iterator . nextindex ( ) ) ; if ( isusingdefaultlistener ( ) ) nextview . setonclicklistener ( listener ) ; controlleranimator animator = getdefaultforwardanimation ( ) ; animator . setoldview ( currentview ) ; animator . setnewview ( nextview ) ; currentview . startanimation ( animator ) ; if ( iterator . nextindex ( ) == mviews . size ( ) - _num ) if ( hascontrollerlistener ( ) ) mlistener . onendreached ( ) ; } else { if ( mloop ) { iterator = mviews . listiterator ( ) ; view nextview = mviews . get ( _num ) ; if ( musedefaultlistener ) nextview . setonclicklistener ( listener ) ; controlleranimator animator = getdefaultforwardanimation ( ) ; animator . setoldview ( currentview ) ; animator . setnewview ( nextview ) ; currentview . startanimation ( animator ) ; } } } }	go to the next view.
private boolean ishhsign ( string str ) { boolean sign = _bool ; try { char r = ( char ) integer . parseint ( str , _num ) ; } catch ( numberformatexception e ) { sign = _bool ; } return sign ; }	dmitri ilyin : makes sure if the string is hh encoded sign .
public void simulatemethod ( sootmethod method , referencevariable thisvar , referencevariable returnvar , referencevariable params [ ] ) { string subsignature = method . getsubsignature ( ) ; if ( subsignature . equals ( _str ) ) { sun_misc_unsafe_allocateinstance ( method , thisvar , returnvar , params ) ; return ; } { defaultmethod ( method , thisvar , returnvar , params ) ; return ; } }	implements the abstract method simulatemethod.
public void cacheresolvedmethod ( class clas , class [ ] types , method method ) { if ( interpreter . debug ) interpreter . debug ( _str + clas + _str + method ) ; signaturekey sk = new signaturekey ( clas , method . getname ( ) , types ) ; if ( modifier . isstatic ( method . getmodifiers ( ) ) ) resolvedstaticmethods . put ( sk , method ) ; else resolvedobjectmethods . put ( sk , method ) ; }	cache a resolved ( possibly overloaded ) method based on the argument types used to invoke it , subject to classloader change.
public void testsetbittoppositive ( ) { byte abytes [ ] = { _num , - _num , _num , _num , - _num , _num , _num } ; int asign = _num ; int number = _num ; byte rbytes [ ] = { _num , - _num , _num , - _num , _num , _num , - _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . setbit ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	setbit ( int n ) the leftmost bit in a positive number.
private void destroybeans ( map < string , object > viewmap , map < string , viewscopecontextobject > contextmap ) { arraylist < string > removalnamelist = new arraylist < > ( ) ; if ( contextmap != null ) { for ( map . entry < string , viewscopecontextobject > entry : contextmap . entryset ( ) ) { string passivationcapableid = entry . getkey ( ) ; contextual contextual = beanmanager . getpassivationcapablebean ( passivationcapableid ) ; viewscopecontextobject contextobject = entry . getvalue ( ) ; creationalcontext creationalcontext = beanmanager . createcreationalcontext ( contextual ) ; contextual . destroy ( viewmap . get ( contextobject . getname ( ) ) , creationalcontext ) ; removalnamelist . add ( contextobject . getname ( ) ) ; } iterator < string > removalnames = removalnamelist . iterator ( ) ; while ( removalnames . hasnext ( ) ) { string name = removalnames . next ( ) ; viewmap . remove ( name ) ; } contextmap . clear ( ) ; } }	destroy the view scoped beans for the given view and context map .
public static void close ( @ checkfornull outputstream outputstream ) { if ( outputstream == null ) { return ; } try { outputstream . close ( ) ; } catch ( ioexception e ) { } }	close given outputstream , ignoring any resulting exception .
@ override public node item ( int index ) { return ( nodes != null && index < nodes . size ( ) ) ? ( node ) ( nodes . get ( index ) ) : null ; }	retrieve an item from the map by 0 - based index .
private int chartovisiblewidth ( char c , @ jdkconstants . fontstyle int fonttype , int currentx ) { if ( c == _str ) { return _num ; } if ( c == _str ) { return editorutil . nexttabstop ( currentx , this ) - currentx ; } return editorutil . charwidth ( c , fonttype , this ) ; }	allows to answer how much width requires given char to be represented on a screen .
public static void createdir ( file target ) throws adeusageexception { if ( ! target . exists ( ) && ! target . mkdir ( ) && ! target . exists ( ) ) { throw new adeusageexception ( _str + target . getpath ( ) ) ; } }	create directory if not already exists . throw an exception upon failure.
public gtsencoder ( long basetimestamp ) { this . basetimestamp = basetimestamp ; this . stream = new bytearrayoutputstream ( ) ; this . wrappingkey = null ; }	create an encoder using the given timestamp as its base.
public static string encode ( final coordinate [ ] coords ) { long lastlat = _num ; long lastlng = _num ; final stringbuffer result = new stringbuffer ( ) ; for ( final coordinate point : coords ) { long lat = math . round ( point . y * _num ) ; long lng = math . round ( point . x * _num ) ; long dlat = lat - lastlat ; long dlng = lng - lastlng ; encode ( dlat , result ) ; encode ( dlng , result ) ; lastlat = lat ; lastlng = lng ; } return result . tostring ( ) ; }	encodes a sequence of latlngs into an encoded path string .
private void extractweightvalues ( list < synapse > synapses ) { int exweights = _num ; int inweights = _num ; for ( synapse s : synapses ) { double w = s . getstrength ( ) ; if ( w > _num ) { exweights ++ ; } else { inweights ++ ; } } weights [ _num ] = new double [ exweights ] ; weights [ _num ] = new double [ inweights ] ; exweights = _num ; inweights = _num ; if ( weights [ _num ] . length != _num ) { for ( synapse s : synapses ) { double w = s . getstrength ( ) ; if ( w > _num ) { weights [ _num ] [ exweights ++ ] = w ; } else { weights [ _num ] [ inweights ++ ] = w ; } } } }	extracts weight values and organizes them by synapse type ( inhibitory or excitatory ).
@ override public void close ( ) { try { flush ( ) ; } catch ( amlogexception ale ) { debug . error ( tablename + _str + ale . getmessage ( ) ) ; } if ( conn != null ) { try { conn . close ( ) ; } catch ( sqlexception ce ) { debug . error ( tablename + _str , ce ) ; } } stopbuffertimer ( ) ; }	flush any buffered messages and close the current output stream .
public boolean contains ( list < integer > hashes ) { iterator < integer > ni = hashes . iterator ( ) ; for ( int i = _num ; i < hashfunctions ; ++ i ) { if ( ! testbit ( ( int ) ( ( ni . next ( ) & _num ) % ( filter . length * _num ) ) ) ) { return _bool ; } } return _bool ; }	check if the filter contains data with precomputed hashes .
private void ensurecapacity ( int additionaldata ) { if ( ( this . position + additionaldata ) > this . bytebuffer . length ) { int newlength = ( int ) ( this . bytebuffer . length * _num ) ; if ( newlength < ( this . bytebuffer . length + additionaldata ) ) { newlength = this . bytebuffer . length + ( int ) ( additionaldata * _num ) ; } if ( newlength < this . bytebuffer . length ) { newlength = this . bytebuffer . length + additionaldata ; } byte [ ] newbytes = new byte [ newlength ] ; system . arraycopy ( this . bytebuffer , _num , newbytes , _num , this . bytebuffer . length ) ; this . bytebuffer = newbytes ; } }	ensure that there are additionaldata bytes available in the buffer.
public boolean isvalidnumber ( phonenumber number ) { string regioncode = getregioncodefornumber ( number ) ; return isvalidnumberforregion ( number , regioncode ) ; }	tests whether a phone number matches a valid pattern.
private string trimurl ( string uri ) { if ( uri == null ) return _str ; if ( uri . endswith ( _str ) ) uri = uri . substring ( _num , uri . length ( ) - _num ) ; return uri ; }	trim the url , by removing an extra ' / ' at the end of the url and also make it lowercase < p >.
public pair < integer , list < long > > next ( ) { try { classesprocessed ++ ; integer key = iterator . next ( ) ; long pos = classificationblockrma2 . getpos ( key ) ; int count = classificationblockrma2 . getsum ( key ) ; classdumpreader . seek ( pos ) ; list < long > list = new linkedlist < > ( ) ; for ( int i = _num ; i < count ; i ++ ) list . add ( classdumpreader . readlong ( ) ) ; return new pair < > ( key , list ) ; } catch ( exception e ) { basic . caught ( e ) ; error = _bool ; return null ; } }	returns the next element in the iteration .
public static string addalpha ( string originalcolor , double alpha ) { long alphafixed = math . round ( alpha * _num ) ; string alphahex = long . tohexstring ( alphafixed ) ; if ( alphahex . length ( ) == _num ) { alphahex = _str + alphahex ; } originalcolor = originalcolor . replace ( _str , _str + alphahex ) ; return originalcolor ; }	adds alpha to a hex color.
public void stop ( ) { server . stop ( _num ) ; }	stop the web server .
final void copyintolocalstate ( operand [ ] _localstate ) { localstate = new operand [ _localstate . length ] ; system . arraycopy ( _localstate , _num , localstate , _num , _localstate . length ) ; setlocalknown ( ) ; }	save a shallow copy of the given local variable state into this .
protected object attemptreadresponse ( connection cnx ) throws exception { message msg = createresponsemessage ( ) ; if ( msg != null ) { msg . setcomms ( cnx . getsocket ( ) , cnx . getinputstream ( ) , cnx . getoutputstream ( ) , cnx . getcommbuffer ( ) , cnx . getstats ( ) ) ; if ( msg instanceof chunkedmessage ) { try { return processresponse ( msg , cnx ) ; } finally { msg . unsetcomms ( ) ; processsecurebytes ( cnx , msg ) ; } } else { try { msg . recv ( ) ; } finally { msg . unsetcomms ( ) ; processsecurebytes ( cnx , msg ) ; } return processresponse ( msg , cnx ) ; } } else { return null ; } }	attempts to read a response to this operation by reading it from the given connection , and returning it .
public synchronized boolean add ( e e , boolean hasnext ) { while ( minternalqueue . size ( ) >= mmaxsize && ! mclosed ) { notifyall ( ) ; try { wait ( timeout ) ; } catch ( interruptedexception e1 ) { mclosed = _bool ; programstate . checkabort ( ) ; throw new illegalstateexception ( _str , e1 ) ; } programstate . checkabort ( ) ; } if ( mclosed ) { return _bool ; } final boolean wasempty = minternalqueue . isempty ( ) ; mhasnext = hasnext ; minternalqueue . add ( e ) ; if ( wasempty ) { notifyall ( ) ; } return _bool ; }	add method which also set whether there is a next value.
public translatablecomponent ( ) { }	construct new empty translatablecomponent .
public void addpart ( int index , pdupart part ) { if ( null == part ) { throw new nullpointerexception ( ) ; } putparttomaps ( part ) ; mparts . add ( index , part ) ; }	inserts the specified part at the specified position .
public strbuilder insert ( int index , boolean value ) { validateindex ( index ) ; if ( value ) { ensurecapacity ( size + _num ) ; system . arraycopy ( buffer , index , buffer , index + _num , size - index ) ; buffer [ index ++ ] = _str ; buffer [ index ++ ] = _str ; buffer [ index ++ ] = _str ; buffer [ index ] = _str ; size += _num ; } else { ensurecapacity ( size + _num ) ; system . arraycopy ( buffer , index , buffer , index + _num , size - index ) ; buffer [ index ++ ] = _str ; buffer [ index ++ ] = _str ; buffer [ index ++ ] = _str ; buffer [ index ++ ] = _str ; buffer [ index ] = _str ; size += _num ; } return this ; }	inserts the value into this builder .
public boolean hasnatureandweapon ( nature nature , string weapon ) { return this . nature == nature && ( ( weapon == null && this . weapon == null ) || ( weapon != null && weapon . equals ( this . weapon ) ) ) ; }	check if this painter has the given nature an weapon .
public void dump ( string infomsg ) { storage . getonlinemembers ( ) ; storage . getofflinemembers ( ) ; storage . getofflineandequalmembers ( ) ; storage . getmyinitializingid ( ) ; storage . getmypersistentid ( ) ; final stringbuilder buf = new stringbuilder ( _num ) ; if ( infomsg != null ) { buf . append ( infomsg ) ; buf . append ( _str ) ; } buf . append ( _str ) ; buf . append ( storage . getmypersistentid ( ) ) ; buf . append ( _str ) ; buf . append ( storage . getmyinitializingid ( ) ) ; buf . append ( _str ) ; for ( persistentmemberid id : storage . getonlinemembers ( ) ) { buf . append ( _str ) ; buf . append ( id ) ; buf . append ( _str ) ; } buf . append ( _str ) ; for ( persistentmemberid id : storage . getofflinemembers ( ) ) { buf . append ( _str ) ; buf . append ( id ) ; buf . append ( _str ) ; } buf . append ( _str ) ; for ( persistentmemberid id : storage . getofflineandequalmembers ( ) ) { buf . append ( _str ) ; buf . append ( id ) ; buf . append ( _str ) ; } logger . debug ( buf . tostring ( ) ) ; }	callers should have already verified that debug output is enabled .
public synchronized void open ( ) { }	open the device ( done automatically ).
@ notnull private optional < typeconversion > findconversionfromdbvalue ( @ notnull type source , @ notnull type target ) { if ( isassignable ( target , source ) ) return optional . of ( typeconversion . identity ( ) ) ; optional < typeconversion > directconversion = typeconversionregistry . findconversionfromdbvalue ( source , target ) ; if ( directconversion . ispresent ( ) ) return directconversion ; optional < typeconversion > arrayconversion = findarrayconversion ( source , target ) ; if ( arrayconversion . ispresent ( ) ) return arrayconversion ; optional < typeconversion > optionalconversion = findoptionalconversion ( source , target ) ; if ( optionalconversion . ispresent ( ) ) return optionalconversion ; optional < typeconversion > enumconversion = findenumconversion ( target ) ; if ( enumconversion . ispresent ( ) ) return enumconversion ; return optional . empty ( ) ; }	returns conversion for converting value of source to target , or returns null if there ' s no such conversion .
private boolean advanceapiupto ( treeset < areapanelinfo > sortedapitree , areapanelinfo api , int time ) { areapanel ap = api . ap ( ) ; timetree roottt = ap . gettimetree ( ) ; timetree tt = roottt . getencompassigtimetreeormaxtimetreebeforetime ( time , _bool ) ; if ( tt == null || tt . id == api . currttid ) return _bool ; sortedapitree . remove ( api ) ; if ( api . settt ( tt , integer . max_value ) ) sortedapitree . add ( api ) ; return _bool ; }	moves api to the latest value before time .
@ requestmapping ( value = { _str , _str } , method = requestmethod . post ) @ responsebody public restwrapper update ( @ modelattribute ( _str ) @ valid userroles userroles , bindingresult bindingresult , principal principal ) { restwrapper restwrapper = null ; if ( bindingresult . haserrors ( ) ) { bindingresulterror bindingresulterror = new bindingresulterror ( ) ; return bindingresulterror . errormessage ( bindingresult ) ; } try { com . wipro . ats . bdre . md . dao . jpa . userroles jpauserroles = new com . wipro . ats . bdre . md . dao . jpa . userroles ( ) ; jpauserroles . setuserroleid ( userroles . getuserroleid ( ) ) ; jpauserroles . setrole ( userroles . getrole ( ) ) ; users users = new users ( ) ; users . setusername ( userroles . getusername ( ) ) ; jpauserroles . setusers ( users ) ; userrolesdao . update ( jpauserroles ) ; restwrapper = new restwrapper ( userroles , restwrapper . ok ) ; logger . info ( _str + userroles . getuserroleid ( ) + _str + principal . getname ( ) + userroles ) ; } catch ( exception e ) { logger . error ( e ) ; restwrapper = new restwrapper ( e . getmessage ( ) , restwrapper . error ) ; } return restwrapper ; }	this method calls proc updateuserroles and updates the values.
private void sendrequestoption ( ) throws ioexception { string request = _str + mparameters . host + _str + mparameters . port + mparameters . path + _str + addheaders ( ) ; log . i ( tag , request . substring ( _num , request . indexof ( _str ) ) ) ; moutputstream . write ( request . getbytes ( _str ) ) ; response . parseresponse ( mbufferedreader ) ; }	forges and sends the options request.
@ override public result docomparisontest ( final properties properties ) throws exception { final long timeout = long . parselong ( properties . getproperty ( testoptions . timeout ) ) ; final int nresources = integer . parseint ( properties . getproperty ( testoptions . nresources ) ) ; final int minlocks = integer . parseint ( properties . getproperty ( testoptions . min_locks ) ) ; final int maxlocks = integer . parseint ( properties . getproperty ( testoptions . max_locks ) ) ; final int ntrials = integer . parseint ( properties . getproperty ( testoptions . ntrials ) ) ; final int keylen = integer . parseint ( properties . getproperty ( testoptions . keylen ) ) ; final int nops = integer . parseint ( properties . getproperty ( testoptions . nops ) ) ; final double failurerate = double . parsedouble ( properties . getproperty ( testoptions . failure_rate ) ) ; result result = doconcurrentclienttest ( journal , timeout , nresources , minlocks , maxlocks , ntrials , keylen , nops , failurerate ) ; return result ; }	setup and run a test .
public void adddelete ( iresource delete ) { if ( fdelete == null ) fdelete = new arraylist < iresource > ( _num ) ; fdelete . add ( delete ) ; if ( fignorecount == _num ) { internaladd ( new deletedescription ( delete ) ) ; } }	adds the given resource to the list of resources to be deleted .
public static double max ( final double a , final double b ) { if ( a > b ) { return a ; } if ( a < b ) { return b ; } if ( a != b ) { return double . nan ; } long bits = double . doubletorawlongbits ( a ) ; if ( bits == _num ) { return b ; } return a ; }	compute the maximum of two values.
public void addcontainer ( imagecontainer container ) { mcontainers . add ( container ) ; }	adds another imagecontainer to the list of those interested in the results of the request .
@ override public void writeexternal ( objectoutput out ) throws ioexception { super . writeexternal ( out ) ; out . writeobject ( approximation ) ; }	calls the super method and writes the polynomial approximation of the knn distances of this entry to the specified stream .
public void add ( string methodname , list < expression > parameters ) { chain . add ( new dotexpressionitem ( methodname , parameters , _bool ) ) ; }	add a method to the chain of methods after the dot .
public static request request ( ) { return threadlocal . get ( ) ; }	get the current request , which is specific to the current thread .
public static string createhash ( string password ) throws nosuchalgorithmexception , invalidkeyspecexception { return createhash ( password . tochararray ( ) ) ; }	returns a salted pbkdf2 hash of the password .
private void schedulecommercial ( int length ) { long delay = commercialdelay . getsettingvalue ( ) ; if ( delay == null ) { setcommercialresult ( _str ) ; clearcommercialbuttonsselection ( ) ; } else { scheduledcommercialtime = system . currenttimemillis ( ) + delay * _num ; scheduledcommerciallength = length ; update ( ) ; } }	schedules a commercial of the given length to be run after the delay currently set in the delay input field .
public int hashcode ( ) { long bits = double . doubletolongbits ( m00 ) ; bits = bits * _num + double . doubletolongbits ( m01 ) ; bits = bits * _num + double . doubletolongbits ( m02 ) ; bits = bits * _num + double . doubletolongbits ( m10 ) ; bits = bits * _num + double . doubletolongbits ( m11 ) ; bits = bits * _num + double . doubletolongbits ( m12 ) ; return ( ( ( int ) bits ) ^ ( ( int ) ( bits > > _num ) ) ) ; }	returns the hashcode for this transform .
public void unsubscribe ( awsiotmessage message ) throws awsiotexception { try { unsubscribetopic ( message ) ; } catch ( awsiotretryableexception e ) { if ( client . getmaxofflinequeuesize ( ) > _num && unsubscribequeue . size ( ) < client . getmaxofflinequeuesize ( ) ) { unsubscribequeue . add ( message ) ; } else { logger . info ( _str + message . gettopic ( ) ) ; throw new awsiotexception ( e ) ; } } }	the actual unsubscribe method exposed by this class .
public static boolean isdigitalunix ( ) { return osname . indexof ( _str ) > - _num ; }	is operating system digital unix ?.
public void clientdisconnect ( ) { try { outhttpapp responsestream = _responsestream ; if ( responsestream != null ) { responsestream . close ( ) ; } } catch ( exception e ) { log . log ( level . finer , e . tostring ( ) , e ) ; } connectiontcp conn = conntcp ( ) ; if ( conn != null ) { conn . clientdisconnect ( ) ; } killkeepalive ( _str ) ; }	called when the client has disconnected.
public boolean endswith ( name n ) { if ( n instanceof compoundname ) { return ( impl . endswith ( n . size ( ) , n . getall ( ) ) ) ; } else { return _bool ; } }	determines whether a compound name is a suffix of this compound name.
private int calculatetotalheight ( float starsize , int numberofstars , float starsseparation , boolean padding ) { return math . round ( starsize ) + ( padding ? getpaddingtop ( ) + getpaddingbottom ( ) : _num ) ; }	calculates total height to occupy based on several parameters.
@ suppresswarnings ( _str ) private static boolean isregex ( string s ) { try { pattern . compile ( s ) ; } catch ( patternsyntaxexception e ) { return _bool ; } return _bool ; }	this method is a copy of regexutil.
private static boolean hasspecializedhandlerintents ( context context , intent intent ) { try { packagemanager pm = context . getpackagemanager ( ) ; list < resolveinfo > handlers = pm . queryintentactivities ( intent , packagemanager . get_resolved_filter ) ; if ( handlers == null || handlers . size ( ) == _num ) { return _bool ; } for ( resolveinfo resolveinfo : handlers ) { intentfilter filter = resolveinfo . filter ; if ( filter == null ) continue ; if ( filter . countdataauthorities ( ) == _num || filter . countdatapaths ( ) == _num ) continue ; if ( resolveinfo . activityinfo == null ) continue ; return _bool ; } } catch ( runtimeexception e ) { log . e ( tag , _str ) ; } return _bool ; }	used to check whether there is a specialized handler for a given intent .
public static void flush ( ) { clearbuffer ( ) ; try { out . flush ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }	flush standard output , padding 0s if number of bits written so far is not a multiple of 8 .
private string attachfootertotext ( string content ) throws messagingexception , ioexception { stringbuilder builder = new stringbuilder ( content ) ; ensuretrailingcarriagereturn ( content , builder ) ; builder . append ( getfootertext ( ) ) ; return builder . tostring ( ) ; }	prepends the content of the mimepart as text to the existing footer.
public static sentence make ( final connective connective , final sentence ... children2 ) { return make ( connective , arrays . aslist ( children2 ) ) ; }	conjoin a list of sentences.
public final void testisstatepreserved1 ( ) { byte [ ] encodedkey = new byte [ ] { ( byte ) _num , ( byte ) _num , ( byte ) _num , ( byte ) _num } ; encodedkeyspec meks = new myencodedkeyspec ( encodedkey ) ; encodedkey [ _num ] = ( byte ) _num ; byte [ ] ek = meks . getencoded ( ) ; asserttrue ( ek [ _num ] == ( byte ) _num ) ; }	tests that internal state of the object can not be modified by modifying initial array value.
public synchronized void init ( ) { init = _bool ; for ( string mapname : store . getmapnames ( ) ) { if ( mapname . startswith ( _str ) ) { mvmap < object , integer > temp = opentempmap ( mapname ) ; store . removemap ( temp ) ; } } synchronized ( undolog ) { if ( undolog . size ( ) > _num ) { for ( long key : undolog . keyset ( ) ) { int transactionid = gettransactionid ( key ) ; opentransactions . set ( transactionid ) ; } } } }	initialize the store . this is needed before a transaction can be opened . if the transaction store is corrupt , this method can throw an exception , in which case the store can only be used for reading .
public static tdoubledoublehashmap createcumulativehistogram ( tdoubledoublehashmap histogram ) { double [ ] keys = histogram . keys ( ) ; arrays . sort ( keys ) ; double sum = _num ; for ( double key : keys ) { double val = histogram . get ( key ) ; sum += val ; histogram . put ( key , sum ) ; } return histogram ; }	creates a cumulative histogram where each bin height is the sum of the previous bin ' s height and the current bin ' s height .
public synchronized void updateiconsforpkg ( string packagename , userhandlecompat user ) { removeiconsforpkg ( packagename , user ) ; try { packageinfo info = mpackagemanager . getpackageinfo ( packagename , packagemanager . get_uninstalled_packages ) ; long userserial = musermanager . getserialnumberforuser ( user ) ; for ( launcheractivityinfocompat app : mlauncherapps . getactivitylist ( packagename , user ) ) { addicontodbandmemcache ( app , info , userserial ) ; } } catch ( namenotfoundexception e ) { log . d ( tag , _str , e ) ; return ; } }	updates the entries related to the given package in memory and persistent db .
protected datetimedata parse ( string str ) throws schemadatetimeexception { datetimedata date = new datetimedata ( str , this ) ; int len = str . length ( ) ; int end = indexof ( str , _num , len , _str ) ; int dateend = getdate ( str , _num , end , date ) ; gettime ( str , end + _num , len , date ) ; if ( dateend != end ) { throw new runtimeexception ( str + _str + _str ) ; } validatedatetime ( date ) ; saveunnormalized ( date ) ; if ( date . utc != _num && date . utc != _str ) { normalize ( date ) ; } return date ; }	parses , validates and computes normalized version of datetime object.
void addattributevalues ( string attrname , set values ) throws smsexception { if ( attrname != null && values != null && ! values . isempty ( ) ) { map attrs = getattributes ( ) ; set origvalues = ( set ) attrs . get ( attrname ) ; set newvalues = new hashset ( values ) ; if ( origvalues != null && ! origvalues . isempty ( ) ) { newvalues . addall ( origvalues ) ; } map newattrs = new hashmap ( ) ; newattrs . put ( attrname , newvalues ) ; setattributes ( newattrs ) ; } }	adds attributes to amsdk organization.
public void test_parkuntil_3 ( ) throws exception { cyclicbarrier barrier = new cyclicbarrier ( _num ) ; parker parker = new parker ( barrier , _bool , _num ) ; thread parkerthread = new thread ( parker ) ; unsafe . unpark ( parkerthread ) ; parkerthread . start ( ) ; parker . assertdurationisinrange ( _num ) ; parkerthread . join ( ) ; }	test the case where the thread is preemptively unparked .
segmentmanager commitindex ( long commitindex ) { this . commitindex = math . max ( this . commitindex , commitindex ) ; return this ; }	sets the log commit index .
public void finishfragments ( ) { for ( fragment comment : closingfragments ) { finishfragment ( comment ) ; } closingfragments . clear ( ) ; }	sets all the closing fragments into finished state .
private final void _writeutf8segments ( byte [ ] utf8 , int offset , int totallen ) throws ioexception , jsongenerationexception { do { int len = math . min ( _outputmaxcontiguous , totallen ) ; _writeutf8segment ( utf8 , offset , len ) ; offset += len ; totallen -= len ; } while ( totallen > _num ) ; }	method called when utf - 8 encoded ( but not yet escaped ! ) content is not guaranteed to fit in the output buffer after escaping ; as such , we just need to chunk writes .
public static string hextostringnoexception ( final string data ) { try { return conversionutils . arraytostring ( hex . decodehex ( data . tochararray ( ) ) ) ; } catch ( decoderexception e ) { return _str ; } }	converts the given hex string into a plain string .
public collection < node > matchingscenariosandexamples ( final feature feature ) { final list < scenariodefinition > allscenarios = feature . getscenariodefinitions ( ) ; final list < node > matchingscenariosandexamples = new linkedlist < node > ( ) ; for ( final scenariodefinition scenario : allscenarios ) { final set < tag > alltagsforscenario = new hashset < tag > ( scenario . gettags ( ) ) ; alltagsforscenario . addall ( feature . gettags ( ) ) ; if ( scenario instanceof scenariooutline ) { matchingscenariosandexamples . addall ( matchingexamples ( ( scenariooutline ) scenario , alltagsforscenario ) ) ; } else { if ( matches ( alltagsforscenario ) ) { matchingscenariosandexamples . add ( scenario ) ; } } } return matchingscenariosandexamples ; }	find the scenarios that match the required tags in the feature .
public static string rate2speed ( double rate ) { return number_format0 . format ( rate ) + _str + general_unit_kbpsec ; }	converts an rate into a human readable and localized kb / s speed .
public long next ( ) { long result = - _num ; if ( cache < _num && bufferelements > _num ) { result = getnextfrombuffer ( ) ; bufferelements -- ; } else { result = cache ; cache = - _num ; } if ( ! cs . isempty ( ) ) { long first = cs . first ( ) ; if ( result > first || result == - _num ) { cs . remove ( first ) ; cache = result ; result = first ; } } if ( result == - _num ) { throw new nosuchelementexception ( ) ; } assert . check ( previous < result , ec . general ) ; previous = result ; readelements ++ ; return result ; }	returns the next element in the iteration .
public boolean issetqueuesize ( ) { return __isset_bit_vector . get ( __queuesize_isset_id ) ; }	returns true if field queuesize is set ( has been assigned a value ) and false otherwise.
private static string tostring ( double coeff ) { final string c = double . tostring ( coeff ) ; if ( c . endswith ( _str ) ) { return c . substring ( _num , c . length ( ) - _num ) ; } else { return c ; } }	creates a string representing a coefficient , removing ".
public static final indexcreatedevent createtestindexcreationstatuswithbulkdatahit ( ) { indexcreatedevent toreturn = new indexcreatedevent ( uuid . randomuuid ( ) , new date ( ) , new date ( ) , createtestindexwithbulkdatahit ( ) , _num , _num ) ; toreturn . calculatevalues ( ) ; return toreturn ; }	creates at test indexcreatedevent .
public boolean validate ( string value , string rule ) { return ( value . equalsignorecase ( rule ) ) ; }	determines whether the specified string is a valid boolean value.
public string findurifromdoc ( int owner ) { int n = m_sourcetree . size ( ) ; for ( int i = _num ; i < n ; i ++ ) { sourcetree stree = ( sourcetree ) m_sourcetree . elementat ( i ) ; if ( owner == stree . m_root ) return stree . m_url ; } return null ; }	given a document , find the url associated with that document .
static public final int random ( int start , int end ) { return start + random . nextint ( end - start + _num ) ; }	returns a random number between start ( inclusive ) and end ( inclusive ) .
public boolean offer ( e event , int taskid ) throws interruptedexception { assertnotdone ( ) ; if ( predicate . match ( event ) ) { this . matched [ taskid ] = _bool ; for ( boolean match : matched ) { if ( ! match ) return _bool ; } responsequeue . put ( new eventholder ( event ) ) ; done = _bool ; return _bool ; } else return _bool ; }	offer an event to this watch instance.
private static algorithmparameterspec algorithmparameterspec ( ) { final securerandom random = new securerandom ( ) ; final byte [ ] bytes = new byte [ ccaes . block ] ; random . nextbytes ( bytes ) ; return new ivparameterspec ( bytes ) ; }	create algorithmparameterspec with the block size .
protected boolean istokenchar ( char ch ) { if ( character . isletterordigit ( ch ) ) return _bool ; if ( character . isisocontrol ( ch ) ) return _bool ; if ( ishttpseparator ( ch ) ) return _bool ; return _bool ; }	checks whether a character is a valid token character.
public void drawlinesandpoints ( graphics2d g2d , arraylist < comparablelabel > ordereddateset , hashmap < comparablelabel , integer > datapoints , long ymaxmark ) { int sectionwidth = this . graphwidth / ordereddateset . size ( ) ; int xoffset = sectionwidth / _num ; int yprevvalue ; int ycurrentvalue ; float prevoffsetperc ; float currentoffsetperc ; g2d . setcolor ( this . linecolor ) ; for ( int i = _num ; i < ordereddateset . size ( ) ; i ++ ) { if ( i != _num ) { yprevvalue = datapoints . get ( ordereddateset . get ( i - _num ) ) ; ycurrentvalue = datapoints . get ( ordereddateset . get ( i ) ) ; prevoffsetperc = yprevvalue / ( float ) ymaxmark ; currentoffsetperc = ycurrentvalue / ( float ) ymaxmark ; g2d . drawline ( this . graphleft + ( i - _num ) * sectionwidth + xoffset , this . graphbottom - math . round ( prevoffsetperc * this . graphheight ) , this . graphleft + i * sectionwidth + xoffset , math . round ( this . graphbottom - currentoffsetperc * this . graphheight ) ) ; } else { ycurrentvalue = datapoints . get ( ordereddateset . get ( i ) ) ; currentoffsetperc = ycurrentvalue / ( float ) ymaxmark ; g2d . filloval ( this . graphleft + ( i ) * sectionwidth + xoffset - this . pointradius , this . graphbottom - math . round ( currentoffsetperc * this . graphheight ) - this . pointradius , this . pointradius * _num , this . pointradius * _num ) ; } } }	draws the datapoints and the lines connecting the datapoints on the line graph.
@ suppresslint ( _str ) public void elementtype ( string name , int model , int memberof , int flags ) { elementtype e = new elementtype ( name , model , memberof , flags , this ) ; theelementtypes . put ( name . tolowercase ( ) , e ) ; if ( memberof == m_root ) theroot = e ; }	add or replace an element type for this schema .
public static string makelogtag ( class cls ) { return makelogtag ( cls . getsimplename ( ) ) ; }	don ' t use this when obfuscating class names !.
final public void println ( string s ) { writer out = this . out ; if ( out == null ) return ; try { if ( s == null ) out . write ( _nullchars , _num , _nullchars . length ) ; else out . write ( s , _num , s . length ( ) ) ; out . write ( _newline , _num , _newline . length ) ; } catch ( ioexception e ) { log . log ( level . fine , e . tostring ( ) , e ) ; } }	writes a string followed by a newline .
private static uri refraguri ( uri uri , string frag ) throws urisyntaxexception { return new uri ( uri . getscheme ( ) , uri . getschemespecificpart ( ) , frag ) ; }	return a new uri with a different fragment .
@ override public void paint ( final ppaintcontext ppc ) { final paint paint = getpaint ( ) ; if ( paint != null ) { final graphics2d g2 = ppc . getgraphics ( ) ; final pbounds bounds = getunionofchildrenbounds ( null ) ; if ( fillbackground ) { g2 . setpaint ( backgroundcolor ) ; g2 . fillrect ( ( int ) bounds . getx ( ) - outlinepadding , ( int ) bounds . gety ( ) - outlinepadding , ( int ) bounds . getwidth ( ) + _num * outlinepadding , ( int ) bounds . getheight ( ) + _num * outlinepadding ) ; } if ( drawoutline ) { g2 . setpaint ( linecolor ) ; g2 . drawroundrect ( ( int ) bounds . getx ( ) - outlinepadding , ( int ) bounds . gety ( ) - outlinepadding , ( int ) bounds . getwidth ( ) + _num * outlinepadding , ( int ) bounds . getheight ( ) + _num * outlinepadding , rounding_width_height , rounding_width_height ) ; } } }	change the default paint to fill an expanded bounding box based on its children ' s bounds .
public final synchronized byte [ ] tobytearray ( ) { bytearrayoutputstream baos = null ; dataoutputstream dos = null ; try { baos = new bytearrayoutputstream ( _num ) ; dos = new dataoutputstream ( baos ) ; game . writetostream ( dos ) ; dos . flush ( ) ; return baos . tobytearray ( ) ; } catch ( ioexception e ) { return null ; } finally { if ( dos != null ) try { dos . close ( ) ; } catch ( ioexception ex ) { } if ( baos != null ) try { baos . close ( ) ; } catch ( ioexception ex ) { } } }	serialize to byte array .
public void addimport ( @ notnull psielement importable , @ notnull psifile file , @ nullable pyimportelement importelement ) { myimports . add ( new importcandidateholder ( importable , file , importelement , null ) ) ; }	adds another import source .
protected final void drawarrowhead ( graphics2d g , int x , int y , int sgn ) { g . setstroke ( strokes . getstroke ( stroketype . solid , _num ) ) ; int size = diagram ( ) . arrowsize ; switch ( headtype ) { case closed : polygon p = new polygon ( new int [ ] { x , x + sgn * size , x + sgn * size , x } , new int [ ] { y , y - size , y + size , y } , _num ) ; g . fillpolygon ( p ) ; break ; case open : g . drawline ( x , y , x + sgn * size , y - size ) ; g . drawline ( x , y , x + sgn * size , y + size ) ; break ; case rounded : int left = sgn == - _num ? x - _num * size : x ; int top = y - size ; g . fillarc ( left , top , size * _num , size * _num , _num , sgn * _num ) ; } }	draws the head of a message arrow onto the diagram display .
public void classloaderinit ( dynamicclassloader loader ) { envloaderlistener listener = _listenerref . get ( ) ; if ( listener != null ) listener . classloaderinit ( loader ) ; }	handles the case where a class loader is activated .
private object [ ] unmarshalparameterschecked ( deserializationchecker checker , method method , marshalinputstream in ) throws ioexception , classnotfoundexception { int callid = methodcallidcount . getandincrement ( ) ; mychecker mychecker = new mychecker ( checker , method , callid ) ; in . setstreamchecker ( mychecker ) ; try { class < ? > [ ] types = method . getparametertypes ( ) ; object [ ] values = new object [ types . length ] ; for ( int i = _num ; i < types . length ; i ++ ) { mychecker . setindex ( i ) ; values [ i ] = unmarshalvalue ( types [ i ] , in ) ; } mychecker . end ( callid ) ; return values ; } finally { in . setstreamchecker ( null ) ; } }	unmarshal parameters for the given method of the given instance over the given marshalinputstream.
private void loaddatafromservice ( ) { list < exceptionsensordata > exdata = null ; if ( ( null != fromdate ) && ( null != todate ) ) { exdata = dataaccessservice . getungroupedexceptionoverview ( template , limit , fromdate , todate , resultcomparator ) ; } else { exdata = dataaccessservice . getungroupedexceptionoverview ( template , limit , resultcomparator ) ; } exceptionsensordata . clear ( ) ; if ( null != exdata ) { exceptionsensordata . addall ( exdata ) ; } }	reloads the data from the service .
public static string createresourcename ( string resource , locale locale , boolean removeextension ) { string resourcename = resource ; if ( removeextension ) { if ( resourcename . endswith ( _str ) ) { resourcename = resourcename . replace ( _str , _str ) ; } else if ( resourcename . endswith ( _str ) ) { resourcename = resourcename . replace ( _str , _str ) ; } } if ( locale != null ) { if ( utilvalidate . isnotempty ( locale . tostring ( ) ) ) { resourcename = resourcename + _str + locale ; } } return resourcename ; }	create a localized resource name based on a resource name and a locale .
public static string tostring ( object [ ] objects , displayable renderer ) { if ( objects == null ) return _str ; stringbuffer buffer = new stringbuffer ( _num ) ; for ( int i = _num ; i < objects . length ; i ++ ) { if ( i > _num ) buffer . append ( _str ) ; buffer . append ( renderer . displaystring ( objects [ i ] ) ) ; } return buffer . tostring ( ) ; }	converts an array of objects into string .
void drawicon ( graphics g , int ax , int ay , int aw , int ah , float align , component c ) { int gap = islefttoright ? - ( img . geticonwidth ( ) + bulletgap ) : ( aw + bulletgap ) ; int x = ax + gap ; int y = math . max ( ay , ay + ( int ) ( align * ah ) - img . geticonheight ( ) ) ; img . painticon ( c , g , x , y ) ; }	draws the bullet icon specified by the list - style - image argument .
public int syncquery ( string query ) { long start = system . currenttimemillis ( ) ; int modified = execute ( _str , update_count_response , query ) ; log . debug ( _str , system . currenttimemillis ( ) - start , modified ) ; return modified ; }	synchronizes the rdf repository ' s representation of an entity to be exactly the provided statements .
public static void fullreset ( ) { resetruntime ( ) ; synchronized ( readproperties ) { readproperties . clear ( ) ; } }	fully reset the state , not only the one related to latest test case execution.
private bufferedimage tobufferedimage ( final image image ) { if ( image instanceof bufferedimage ) { return ( bufferedimage ) image ; } if ( image instanceof volatileimage ) { volatileimage volatileimage = ( volatileimage ) image ; return volatileimage . getsnapshot ( ) ; } graphicsenvironment graphicsenvironment = graphicsenvironment . getlocalgraphicsenvironment ( ) ; graphicsdevice graphicsdevice = graphicsenvironment . getdefaultscreendevice ( ) ; graphicsconfiguration graphicsconfiguration = graphicsdevice . getdefaultconfiguration ( ) ; bufferedimage bufferedimage = graphicsconfiguration . createcompatibleimage ( image . getwidth ( null ) , image . getheight ( null ) ) ; graphics2d g = bufferedimage . creategraphics ( ) ; g . drawimage ( image , _num , _num , null ) ; g . dispose ( ) ; return bufferedimage ; }	convert the specified image to a bufferedimage , if necessary .
public final boolean iscancelled ( ) { if ( cancelled ) { pass ( _str , cancelled ) ; } else { fail ( _str ) ; } return cancelled ; }	returns true if this testsubscriber has been cancelled .
public void remove ( directededge de ) { outedges . remove ( de ) ; }	drops a member of this directededgestar .
@ override public boolean eventgeneratable ( string eventname ) { if ( m_listenee == null ) { return _bool ; } if ( ! eventname . equals ( _str ) && ! eventname . equals ( _str ) ) { return _bool ; } if ( m_listenee instanceof datasource ) { if ( m_listenee instanceof eventconstraints ) { eventconstraints ec = ( eventconstraints ) m_listenee ; return ec . eventgeneratable ( eventname ) ; } } if ( m_listenee instanceof trainingsetproducer ) { if ( m_listenee instanceof eventconstraints ) { eventconstraints ec = ( eventconstraints ) m_listenee ; if ( ! eventname . equals ( _str ) ) { return _bool ; } if ( ! ec . eventgeneratable ( _str ) ) { return _bool ; } } } if ( m_listenee instanceof testsetproducer ) { if ( m_listenee instanceof eventconstraints ) { eventconstraints ec = ( eventconstraints ) m_listenee ; if ( ! eventname . equals ( _str ) ) { return _bool ; } if ( ! ec . eventgeneratable ( _str ) ) { return _bool ; } } } return _bool ; }	returns true if , at the current time , the named event could be generated .
@ override protected void onmessageonproducerthread ( t msg ) { _lock . lock ( ) ; try { if ( _pending . isempty ( ) ) { _queue . schedule ( _flushrunnable , _interval , _timeunit ) ; } _pending . add ( msg ) ; } finally { _lock . unlock ( ) ; } }	receives message and batches as needed .
public builder untildate ( date date ) { untildate = query_date . format ( date ) ; return this ; }	returns tweets generated before the given date.
private boolean isinthumbrange ( float touchx , double normalizedthumbvalue ) { return math . abs ( touchx - normalizedtoscreen ( normalizedthumbvalue ) ) <= mthumbhalfwidth ; }	decides if given x - coordinate in screen space needs to be interpreted as " within " the normalized thumb x - coordinate .
public static void cleanupallfiles ( filesystem filesystem , string baseuri ) throws ioexception { try { if ( filesystem != null ) { path rootdir = new path ( baseuri ) ; filestatus [ ] files = filesystem . liststatus ( rootdir ) ; for ( filestatus file : files ) { filesystem . delete ( file . getpath ( ) , _bool ) ; } } } catch ( exception e ) { log . error ( _str ) ; } }	deletes all files in a container.
@ override public boolean canbecollidedwith ( ) { return _bool ; }	returns true if other entities should be prevented from moving through this entity .
public void update ( long duration , timeunit unit ) { update ( unit . tonanos ( duration ) ) ; }	adds a recorded duration .
public void submit ( string queuename , dispatchertask dispatchertask ) { synchronized ( syncroot ) { dispatchertaskrunner currenttaskrunner = currenttasksmap . get ( queuename ) ; if ( currenttaskrunner == null ) { currenttaskrunner = new dispatchertaskrunner ( queuename , dispatchertask ) ; currenttasksmap . put ( queuename , currenttaskrunner ) ; executorservice . execute ( currenttaskrunner ) ; } else { enqueuenexttask ( queuename , dispatchertask ) ; } } }	submits task to the specific queue.
public static executor createtaskdistributor ( ) { return executors . newcachedthreadpool ( createthreadfactory ( thread . norm_priority , _str ) ) ; }	creates default implementation of task distributor.
public void dump ( writer writer ) { printwriter pw = new printwriter ( new bufferedwriter ( writer ) ) ; pw . println ( _str ) ; pw . println ( _str ) ; pw . println ( _str + ( int ) audioformat . getsamplerate ( ) ) ; pw . println ( _str + samples . length / _num ) ; pw . println ( _str + audioformat . getchannels ( ) ) ; if ( samples != null ) { for ( int i = _num ; i < samples . length ; i += _num ) { pw . println ( waveutils . bytestoshort ( samples [ i ] , samples [ i + _num ] ) ) ; } } pw . flush ( ) ; }	dumps the wave out to the given stream.
public void addfieldbuffered ( veditor editor , gridfield mfield ) { wrap = mfield != null ? ! mfield . issameline ( ) : _bool ; if ( preveditor != null && prevfield != null ) addfield ( preveditor , prevfield ) ; preveditor = editor ; prevfield = mfield ; }	add field and label to buffer and push buffered field to panel.
public expandroomfreespaceincomplete add_incomplete_expansion_room ( shapetile p_shape , int p_layer , shapetile p_contained_shape ) { expandroomfreespaceincomplete new_room = new expandroomfreespaceincomplete ( p_shape , p_layer , p_contained_shape ) ; incomplete_expansion_rooms . add ( new_room ) ; return new_room ; }	creates a new freespaceexpansionroom and adds it to the room list.
static double computedesiredellipsoidmagnitude ( final planetmodel planetmodel , final double x , final double y , final double z ) { return _num / math . sqrt ( x * x * planetmodel . inverseabsquared + y * y * planetmodel . inverseabsquared + z * z * planetmodel . inversecsquared ) ; }	compute the desired magnitude of a unit vector projected to a given planet model .
public static string trim ( charsequence s ) { if ( s == null ) { return null ; } matcher m = strimpattern . matcher ( s ) ; return m . replaceall ( _str ) ; }	trims the string , removing all whitespace at the beginning and end of the string.
private void validatevnxfilesmisprovidermandatorydetails ( storagesystemrequestparam param ) { argvalidator . checkfieldvalidip ( param . getsmisproviderip ( ) , _str ) ; argvalidator . checkfieldnotnull ( param . getsmisportnumber ( ) , _str ) ; argvalidator . checkfieldrange ( param . getsmisportnumber ( ) , _num , _num , _str ) ; argvalidator . checkfieldnotempty ( param . getsmisusername ( ) , _str ) ; argvalidator . checkfieldnotempty ( param . getsmispassword ( ) , _str ) ; }	validates smi - s provider attributes of the vnxfile as it is a mandatory fields for indications.
private artlocateresult calculate_next_trace ( boolean p_layer_changed , boolean p_at_fanout_end ) { collection < plapointfloat > corner_list = new linkedlist < plapointfloat > ( ) ; corner_list . add ( current_from_point ) ; if ( ! p_at_fanout_end ) { plapointfloat adjusted_start_corner = adjust_start_corner ( ) ; if ( adjusted_start_corner != current_from_point ) { plapointfloat add_corner = calculate_additional_corner ( current_from_point , adjusted_start_corner , _bool , angle_restriction ) ; corner_list . add ( add_corner ) ; corner_list . add ( adjusted_start_corner ) ; previous_from_point = current_from_point ; current_from_point = adjusted_start_corner ; } } plapointfloat prev_corner = current_from_point ; for ( int c_limit = _num ; c_limit < _num ; c_limit ++ ) { collection < plapointfloat > next_corners = calculate_next_trace_corners ( ) ; if ( next_corners . isempty ( ) ) break ; for ( plapointfloat curr_next_corner : next_corners ) { if ( curr_next_corner == prev_corner ) continue ; corner_list . add ( curr_next_corner ) ; previous_from_point = current_from_point ; current_from_point = curr_next_corner ; prev_corner = curr_next_corner ; } } int next_layer = current_trace_layer ; if ( p_layer_changed ) { current_from_door_index = current_target_door_index + _num ; expandroomcomplete next_room = backtrack_array [ current_from_door_index ] . next_room ; if ( next_room != null ) { next_layer = next_room . get_layer ( ) ; } } plapointintalist rounded_corner_list = new plapointintalist ( corner_list . size ( ) ) ; plapointint prev_point = null ; for ( plapointfloat a_float : corner_list ) { plapointint curr_point = a_float . round ( ) ; if ( curr_point . equals ( prev_point ) ) continue ; rounded_corner_list . add ( curr_point ) ; prev_point = curr_point ; } artlocateresult result = new artlocateresult ( rounded_corner_list , current_trace_layer ) ; current_trace_layer = next_layer ; return result ; }	calculates the next trace trace of the connection under construction .
public static < valuet > bytebuffer tobytebuffer ( valuet obj ) throws ioexception { byte [ ] bytes = null ; bytearrayoutputstream bos = null ; objectoutputstream oos = null ; try { bos = new bytearrayoutputstream ( ) ; oos = new objectoutputstream ( bos ) ; oos . writeobject ( obj ) ; oos . flush ( ) ; bytes = bos . tobytearray ( ) ; } finally { if ( oos != null ) { oos . close ( ) ; } if ( bos != null ) { bos . close ( ) ; } } return bytebuffer . wrap ( bytes ) ; }	serialize object to a bytebuffer object .
void writebytes ( channelhandlercontext ctx , bytebuf bytes ) ;	executed upon sending a packet away.
@ override protected sensor createnewsensor ( string systemname , string username ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str + systemname + _str + username ) ; } sensor s ; string sname = serialaddress . normalizesystemname ( systemname ) ; if ( sname . equals ( _str ) ) { log . error ( _str + systemname ) ; return null ; } s = getbysystemname ( sname ) ; if ( s != null ) { log . error ( _str + systemname ) ; return null ; } string altname = serialaddress . convertsystemnametoalternate ( sname ) ; s = getbysystemname ( altname ) ; if ( s != null ) { log . error ( _str + systemname + _str + altname + _str ) ; return null ; } int bit = serialaddress . getbitfromsystemname ( sname ) ; if ( ( bit <= _num ) || ( bit >= sensorspernode ) ) { log . error ( _str + integer . tostring ( bit ) + _str + integer . tostring ( sensorspernode - _num ) ) ; return null ; } if ( username == null ) { s = new serialsensor ( sname ) ; } else { s = new serialsensor ( sname , username ) ; } serialnode node = serialaddress . getnodefromsystemname ( sname ) ; if ( node == null ) { log . warn ( _str + sname + _str ) ; return s ; } node . registersensor ( s , bit ) ; if ( log . isdebugenabled ( ) ) { log . debug ( _str + s . getsystemname ( ) + _str + node ) ; } return s ; }	create a new sensor if all checks are passed system name is normalized to ensure uniqueness .
private double [ ] max ( double [ ] distances1 , double [ ] distances2 ) { if ( distances1 . length != distances2 . length ) { throw new runtimeexception ( _str ) ; } double [ ] result = new double [ distances1 . length ] ; for ( int i = _num ; i < distances1 . length ; i ++ ) { result [ i ] = math . max ( distances1 [ i ] , distances2 [ i ] ) ; } return result ; }	returns an array that holds the maximum values of the both specified arrays in each index .
public void fill_shape ( plapointfloat [ ] p_points , graphics p_g , color p_color , double p_translucency_factor ) { if ( p_color == null ) return ; graphics2d g2 = ( graphics2d ) p_g ; polygon draw_polygon = new polygon ( ) ; for ( int index = _num ; index < p_points . length ; index ++ ) { point2d curr_corner = coordinate_transform . board_to_screen ( p_points [ index ] ) ; draw_polygon . addpoint ( ( int ) math . round ( curr_corner . getx ( ) ) , ( int ) math . round ( curr_corner . gety ( ) ) ) ; } g2 . setcolor ( p_color ) ; set_translucency ( g2 , p_translucency_factor ) ; g2 . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; g2 . fill ( draw_polygon ) ; }	fill the interior of the polygon shape represented by p_points .
public void writeexif ( inputstream jpegstream , outputstream exifoutstream ) throws ioexception { if ( jpegstream == null || exifoutstream == null ) { throw new illegalargumentexception ( null_argument_string ) ; } outputstream s = getexifwriterstream ( exifoutstream ) ; doexifstreamio ( jpegstream , s ) ; s . flush ( ) ; }	writes the tags from this exifinterface object into a jpeg stream , removing prior exif tags .
private static void decodebase256segment ( bitsource bits , stringbuilder result , collection < byte [ ] > bytesegments ) throws formatexception { int codewordposition = _num + bits . getbyteoffset ( ) ; int d1 = unrandomize255state ( bits . readbits ( _num ) , codewordposition ++ ) ; int count ; if ( d1 == _num ) { count = bits . available ( ) / _num ; } else if ( d1 < _num ) { count = d1 ; } else { count = _num * ( d1 - _num ) + unrandomize255state ( bits . readbits ( _num ) , codewordposition ++ ) ; } if ( count < _num ) { throw formatexception . getformatinstance ( ) ; } byte [ ] bytes = new byte [ count ] ; for ( int i = _num ; i < count ; i ++ ) { if ( bits . available ( ) < _num ) { throw formatexception . getformatinstance ( ) ; } bytes [ i ] = ( byte ) unrandomize255state ( bits . readbits ( _num ) , codewordposition ++ ) ; } bytesegments . add ( bytes ) ; try { result . append ( new string ( bytes , _str ) ) ; } catch ( unsupportedencodingexception uee ) { throw new illegalstateexception ( _str + uee ) ; } }	see iso 16022 : 2006 , 5.
public void gotocurrentday ( ) { int monthdifference = flexiblecalendarhelper . getmonthdifference ( displayyear , displaymonth ) ; calendar cal = calendar . getinstance ( ) ; selecteddateitem . setday ( cal . get ( calendar . day_of_month ) ) ; selecteddateitem . setmonth ( cal . get ( calendar . month ) ) ; selecteddateitem . setyear ( cal . get ( calendar . year ) ) ; if ( disableautodateselection ) { this . userselecteditem = selecteddateitem . clone ( ) ; } if ( monthdifference != _num ) { resetadapters = _bool ; if ( monthdifference < _num ) { monthinfpageradapter . setfakecount ( lastposition ) ; monthinfpageradapter . notifydatasetchanged ( ) ; } shouldoverridecomputeddate = _bool ; movetoposition ( monthdifference ) ; } else { flexiblecalendargridadapter currentlyvisibleadapter = monthviewpageradapter . getmonthadapteratposition ( lastposition % monthviewpageradapter . views_in_pager ) ; currentlyvisibleadapter . notifydatasetchanged ( ) ; } }	move the position to today ' s date.
public static byte [ ] toipv4addressbytes ( int ipaddress ) { return new byte [ ] { ( byte ) ( ipaddress > > > _num ) , ( byte ) ( ipaddress > > > _num ) , ( byte ) ( ipaddress > > > _num ) , ( byte ) ipaddress } ; }	accepts an ipv4 address in the form of an integer and returns the corresponding byte array .
public boolean isvalidtemplate ( ) { return isvalidtemplate ( template ) ; }	validates this template to see if its valid for plugin v3.
public object take ( ) throws interruptedexception , forcereattemptexception { throw new unsupportedoperationexception ( ) ; }	it removes the first key from the queue .
@ suppresswarnings ( { _str } ) public static double normalcdf ( double y ) { double f , h ; int j ; double dcphi , x , z , f1 , f2 , f3 , f4 , f5 ; x = y ; if ( math . abs ( x ) > _num ) { dcphi = _num ; } else { j = ( int ) math . floor ( math . abs ( x ) * _num + _num ) ; z = j * _num ; h = math . abs ( x ) - z ; f = r [ j ] ; f1 = f * z - _num ; f2 = f + z * f1 ; f3 = f1 * _num + z * f2 ; f4 = f2 * _num + z * f3 ; f5 = f3 * _num + z * f4 ; dcphi = f + h * ( f1 * _num + h * ( f2 * _num + h * ( f3 * _num + h * ( f4 * _num + h * f5 ) ) ) ) / _num ; dcphi = dcphi * _num * math . exp ( x * - _num * x ) ; } if ( x < _num ) { return dcphi ; } else { return ( _num - dcphi ) ; } }	normal cumulative distribution function ( the value which results by integrating the normal distribution function from negative infinity up to y ) .
private void destroy ( ) { if ( log . isloggable ( level . finest ) ) { log . finest ( this + _str ) ; } try { _socket . forceshutdown ( ) ; } catch ( throwable e ) { } try { closeconnection ( ) ; } catch ( throwable e ) { log . log ( level . finer , e . tostring ( ) , e ) ; } _port . removeconnection ( this ) ; }	destroy kills the connection and drops it from the connection pool . destroy should only occur if the connection state machine has failed or.
int atom ( ) throws resyntaxexception { int ret = node ( re . op_atom , _num ) ; int lenatom = _num ; atomloop : while ( idx < len ) { if ( ( idx + _num ) < len ) { char c = pattern . charat ( idx + _num ) ; if ( pattern . charat ( idx ) == _str ) { int idxescape = idx ; escape ( ) ; if ( idx < len ) { c = pattern . charat ( idx ) ; } idx = idxescape ; } switch ( c ) { case _str : case _str : case _str : case _str : if ( lenatom != _num ) { break atomloop ; } } } switch ( pattern . charat ( idx ) ) { case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : break atomloop ; case _str : case _str : case _str : case _str : if ( lenatom == _num ) { syntaxerror ( _str ) ; } break atomloop ; case _str : { int idxbeforeescape = idx ; int c = escape ( ) ; if ( ( c & esc_mask ) == esc_mask ) { idx = idxbeforeescape ; break atomloop ; } emit ( ( char ) c ) ; lenatom ++ ; } break ; default : emit ( pattern . charat ( idx ++ ) ) ; lenatom ++ ; break ; } } if ( lenatom == _num ) { internalerror ( ) ; } instruction [ ret + re . offsetopdata ] = ( char ) lenatom ; return ret ; }	absorb an atomic character string.
public static < t > unaryoperator < list < t > > from ( collection < string > commandlineudids , function < t , icloud . mbsbackup > mbsbackup , function < icloud . mbsbackup , string > formatter , printer out , inputstream in ) { return commandlineudids . isempty ( ) ? new user ( mbsbackup , out , in , formatter ) : new udid ( mbsbackup , out , in , new arraylist < > ( commandlineudids ) ) ; }	returns a new instance.
public boolean isnetworkconnected ( ) { connectivitymanager connectivitymanager = ( connectivitymanager ) getsystemservice ( connectivity_service ) ; networkinfo networkinfo = connectivitymanager . getactivenetworkinfo ( ) ; return networkinfo != null && networkinfo . isconnectedorconnecting ( ) ; }	check the current active network is available .
@ override public void ontabclosing ( long time , int id ) { reset ( ) ; forceanimationtofinish ( ) ; tabmodel model = mtabmodelselector . getmodelfortabid ( id ) ; if ( model != null ) { mclosedtab = createlayouttab ( id , model . isincognito ( ) , no_close_button , no_title ) ; mclosedtab . setborderalpha ( _num ) ; mlayouttabs = new layouttab [ ] { mclosedtab } ; updatecachevisibleids ( new linkedlist < integer > ( arrays . aslist ( id ) ) ) ; } else { mlayouttabs = null ; mclosedtab = null ; } super . ontabclosing ( time , id ) ; }	set up for the tab closing animation.
public void put ( string name , string supported , string authscheme , string level , boolean isdefault ) { samlv2authcontext c = new samlv2authcontext ( ) ; c . name = name ; c . supported = supported ; if ( authscheme . length ( ) != _num && authscheme != null ) { int index = authscheme . lastindexof ( _str ) ; c . value = authscheme . substring ( index + _num ) ; c . key = authscheme . substring ( _num , index ) ; } else { c . value = _str ; c . key = _str ; } c . level = level ; c . isdefault = isdefault ; collections . put ( name , c ) ; }	adds samlv2authcontext to the collection .
public final void close ( lsserverpacket closepacket , boolean forced ) { synchronized ( guard ) { if ( iswritedisabled ( ) ) { return ; } log . debug ( _str + closepacket + _str ) ; pendingclose = _bool ; isforcedclosing = forced ; sendmsgqueue . clear ( ) ; sendmsgqueue . addlast ( closepacket ) ; enablewriteinterest ( ) ; } }	its guaranted that closepacket will be sent before closing connection , but all past and future packets wont.
private void replacecollapsededges ( ) { list newedges = new arraylist ( ) ; for ( iterator it = edgelist . iterator ( ) ; it . hasnext ( ) ; ) { edge e = ( edge ) it . next ( ) ; if ( e . iscollapsed ( ) ) { it . remove ( ) ; newedges . add ( e . getcollapsededge ( ) ) ; } } edgelist . addall ( newedges ) ; }	if edges which have undergone dimensional collapse are found , replace them with a new edge which is a l edge.
public void timingevent ( float fraction ) { current . x = ( int ) ( start . x + ( end . x - start . x ) * fraction ) ; current . y = ( int ) ( start . y + ( end . y - start . y ) * fraction ) ; track . setcarposition ( current ) ; }	timingtarget implementation : calculate and set the current car position based on the animation fraction.
public seaglasstitlepane ( jrootpane rootpane , seaglassrootpaneui ui ) { this . rootpane = rootpane ; this . rootpaneui = ui ; rootparent = ( rootpanecontainer ) rootpane . getparent ( ) ; installtitlepane ( ) ; }	creates a new seaglasstitlepane object .
public string tostring ( ) { stringbuilder s = new stringbuilder ( ) ; for ( item item : this ) s . append ( item + _str ) ; return s . tostring ( ) ; }	returns a string representation of this queue .
public void writelong ( long value ) throws ioexception { checkwriteprimitivetypes ( ) ; primitivetypes . writelong ( value ) ; }	writes a long ( 64 bit ) to the target stream .
public static list < string > expandwildcards ( iterable < file > dirs , list < string > names , backend forbackend ) { list < string > result = new arraylist < string > ( names . size ( ) ) ; for ( string name : names ) { expandwildcard ( result , dirs , name , forbackend ) ; } return result ; }	given a list of source directories and a list of module names that possibly contain wildcards it returns a expanded list of module names of modules that were actually found in the given source directories.
public static charset forname ( string charsetname ) { return forname ( charsetname , null ) ; }	safely gets charset for the specified name.
public nsnumber ( int i ) { doublevalue = longvalue = i ; type = integer ; }	creates an integer number .
public static void dump ( string message , stacktraceelement [ ] stacktrace ) { dump ( message , arrays . aslist ( stacktrace ) ) ; }	dumps the given message and stack to the system error console .
public void execquery ( string sql , execquerycallbackfunctionif alistener ) throws genericentityexception { if ( _connection == null ) { getconnection ( ) ; } try { if ( debug . verboseon ( ) ) debug . logverbose ( _str + sql , module ) ; executequery ( sql ) ; boolean keepgoing = _bool ; while ( keepgoing && _rs . next ( ) ) { keepgoing = alistener . processnextrow ( _rs ) ; } if ( _manualtx ) { _connection . commit ( ) ; } } catch ( sqlexception sqle ) { debug . logwarning ( _str + sql + _str , module ) ; debug . logwarning ( sqle . getmessage ( ) , module ) ; throw new genericentityexception ( _str + _sql , sqle ) ; } finally { close ( ) ; } }	execute a query based on the sql string given . for each record of the resultset return , execute a callback function.
private name cachename ( string sig ) { stringbuilder buf = new stringbuilder ( ) ; if ( sig . startswith ( _str ) ) { buf = buf . append ( _str ) ; while ( sig . startswith ( _str ) ) { buf = buf . append ( target . syntheticnamechar ( ) ) ; sig = sig . substring ( _num ) ; } if ( sig . startswith ( _str ) ) { sig = sig . substring ( _num , sig . length ( ) - _num ) ; } } else { buf = buf . append ( _str + target . syntheticnamechar ( ) ) ; } buf = buf . append ( sig . replace ( _str , target . syntheticnamechar ( ) ) ) ; return names . fromstring ( buf . tostring ( ) ) ; }	the name of the variable to cache t.
@ override public boolean eisset ( int featureid ) { switch ( featureid ) { case eippackage . conditional_route__condition : return condition_edefault == null ? condition != null : ! condition_edefault . equals ( condition ) ; case eippackage . conditional_route__channel : return channel != null ; } return super . eisset ( featureid ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
public static native string maplibraryname ( string libname ) ;	maps a library name into a platform - specific string representing a native library .
public matcher next ( ) throws ioexception { readahead ( ) ; if ( matches == null ) { throw new nosuchelementexception ( ) ; } matcher matcher = matches . next ( ) ; if ( discard ) { pattern pattern = matcher . pattern ( ) ; for ( int n = _num ; n < patterns . length ; n ++ ) { if ( patterns [ n ] == pattern ) { patterns [ n ] = null ; break ; } } } return matcher ; }	returns the next match from the character stream.
@ calledonlyby ( amidstthread . fragment_loader ) public void processqueues ( ) { dimension dimension = dimensionsetting . get ( ) ; updatelayermanager ( dimension ) ; processrecyclequeue ( ) ; fragment fragment ; while ( ( fragment = loadingqueue . poll ( ) ) != null ) { loadfragment ( dimension , fragment ) ; dimension = dimensionsetting . get ( ) ; updatelayermanager ( dimension ) ; processrecyclequeue ( ) ; } layermanager . clearinvalidatedlayers ( ) ; }	it is important that the dimension setting is the same while a fragment is loaded by different fragment loaders.
default fielddeclaration addprivatefield ( class < ? > typeclass , string name ) { return addfield ( typeclass , name , modifier . private ) ; }	add a private field to this.
void reconstructprivatesubrs ( int font , indexbaseitem [ ] fdprivatebase , offsetitem [ ] fdsubrs ) { for ( int i = _num ; i < fonts [ font ] . fdprivatelengths . length ; i ++ ) { if ( fdsubrs [ i ] != null && fonts [ font ] . privatesubrsoffset [ i ] >= _num ) { outputlist . addlast ( new subrmarkeritem ( fdsubrs [ i ] , fdprivatebase [ i ] ) ) ; if ( newlsubrsindex [ i ] != null ) outputlist . addlast ( new rangeitem ( new randomaccessfileorarray ( rasfactory . createsource ( newlsubrsindex [ i ] ) ) , _num , newlsubrsindex [ i ] . length ) ) ; } } }	function adds the new lsubrs dicts ( only for the fds used ) to the list.
public boolean matchchomp ( string seq ) { if ( matches ( seq ) ) { pos += seq . length ( ) ; return _bool ; } else { return _bool ; } }	tests if the queue matches the sequence ( as with match ) , and if they do , removes the matched string from the queue .
public void initgl ( ) { meglcore = new eglcore ( null , eglcore . flag_recordable | eglcore . flag_try_gles3 ) ; mwindowsurface = new windowsurface ( meglcore , msurfacetexture ) ; mwindowsurface . makecurrent ( ) ; mrecordsurface = new windowsurface ( meglcore , mmediarecorder . getsurface ( ) , _bool ) ; initglcomponents ( ) ; }	initialize all necessary components for gles rendering , creating window surfaces for drawing the preview as well as the surface that will be used by mediarecorder for recording.
void clear ( ) { if ( mviewtypecount == _num ) { final arraylist < view > scrap = mcurrentscrap ; final int scrapcount = scrap . size ( ) ; for ( int i = _num ; i < scrapcount ; i ++ ) { removedetachedview ( scrap . remove ( scrapcount - _num - i ) , _bool ) ; } } else { final int typecount = mviewtypecount ; for ( int i = _num ; i < typecount ; i ++ ) { final arraylist < view > scrap = mscrapviews [ i ] ; final int scrapcount = scrap . size ( ) ; for ( int j = _num ; j < scrapcount ; j ++ ) { removedetachedview ( scrap . remove ( scrapcount - _num - j ) , _bool ) ; } } } if ( mtransientstateviews != null ) { mtransientstateviews . clear ( ) ; } }	clears the scrap heap .
protected void contributetokenrequestparameters ( final querystring bodyparameters ) { }	allows subclasses to augment the request to the token endpoint with additional parameters .
public int read ( char cbuf [ ] , int off , int len ) { int k ; if ( position >= document . getlength ( ) ) { return - _num ; } k = len ; if ( ( position + k ) >= document . getlength ( ) ) k = document . getlength ( ) - ( int ) position ; if ( off + k >= cbuf . length ) k = cbuf . length - off ; try { document . gettext ( ( int ) position , k , segment ) ; position += k ; system . arraycopy ( segment . array , segment . offset , cbuf , off , k ) ; return k ; } catch ( badlocationexception ble ) { return - _num ; } }	reads characters into a portion of an array .
builder addlenient ( string line ) { int index = line . indexof ( _str , _num ) ; if ( index != - _num ) { return addlenient ( line . substring ( _num , index ) , line . substring ( index + _num ) ) ; } else if ( line . startswith ( _str ) ) { return addlenient ( _str , line . substring ( _num ) ) ; } else { return addlenient ( _str , line ) ; } }	add a header line without any validation.
public static void mergenodechildren ( treenode node ) { defaultmutabletreenode masternode = ( defaultmutabletreenode ) node ; for ( int i = _num ; i < masternode . getchildcount ( ) ; i ++ ) { defaultmutabletreenode child = ( defaultmutabletreenode ) masternode . getchildat ( i ) ; if ( ! child . isleaf ( ) ) { mergehelputilities . mergenodechildren ( default_merge_type , child ) ; } } }	merge node children . merge the children of a node according to the merging rules of the parent . each subclass must implement this method.
public void testnegatenegative ( ) { string a = _str ; int ascale = _num ; string c = _str ; int cscale = _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal cnumber = new bigdecimal ( new biginteger ( c ) , cscale ) ; assertequals ( _str , cnumber , anumber . negate ( ) ) ; }	negate ( ) for a negative bigdecimal.
private static object createandbinditem ( parameteraccess parameters , class < ? > itemtype ) { try { object value = itemtype . newinstance ( ) ; bind ( value , parameters ) ; return value ; } catch ( instantiationexception | illegalaccessexception e ) { throw new bindingexception ( _str + itemtype , e ) ; } }	creates and binds the parameters to a new item .
public simplesetuppanel ( experiment exp ) { this ( ) ; setexperiment ( exp ) ; }	creates the setup panel with the supplied initial experiment .
public static void addlistener ( listener listener ) { listeners . addlast ( listener ) ; }	adds a listener of memory copying events .
private static void processargs ( string [ ] args ) { for ( int i = _num ; i < args . length ; i ++ ) { string arg = args [ i ] ; if ( arg . equals ( _str ) ) { outputdir = args [ ++ i ] ; } else if ( arg . equals ( _str ) ) { unicodedata = args [ ++ i ] ; } else if ( arg . equals ( _str ) ) { language = args [ ++ i ] ; } else if ( arg . equals ( _str ) ) { country = args [ ++ i ] ; } else if ( arg . equals ( _str ) ) { valiant = args [ ++ i ] ; } else { usage ( ) ; } } localename = getlocalename ( ) ; }	parses the specified arguments and sets up the variables .
public static boolean iszoningrequired ( dbclient dbclient , virtualarray nh ) { if ( nh . getautosanzoning ( ) == _bool ) { _log . info ( _str + nh . getlabel ( ) ) ; return _bool ; } return networkutil . arenetworksystemdiscovered ( dbclient ) ; }	looks at the varray to see if zoning is disabled , and looks to make sure that there is at least one active networksystem registered .
private void initxmltree ( ) throws exception { updatefilteredtokens ( ) ; arraylist elements = getelements ( getfilteredtokens ( ) ) ; if ( elements . size ( ) > _num ) { throw new exception ( _str ) ; } setrootelement ( ( xmlelement ) elements . get ( _num ) ) ; }	creats an in - memory xml tree based on the parsed tokens in this document .
public boolean hasnamevalue ( string name ) { return namevaluemap . containskey ( name . tolowercase ( ) ) ; }	returns a boolean telling if this namevaluelist has a record with this name.
public boolean startswith ( charseq prefix ) { return str . startswith ( prefix . str ) ; }	tests whether this charseq starts with the specified prefix.
public boolean containswindow ( class < ? > windowclass ) { return ( getwindow ( windowclass ) != null ) ; }	checks , whether an instance of the given window class is already in the window list .
protected final void firepropertychange ( string propertyname , long oldvalue , long newvalue ) { firepropertychange ( propertyname , long . valueof ( oldvalue ) , long . valueof ( newvalue ) ) ; }	support for reporting bound property changes for integer properties.
public void fadetolayer ( int index ) { mtransitionstate = transition_starting ; arrays . fill ( mislayeron , _bool ) ; mislayeron [ index ] = _bool ; invalidateself ( ) ; }	starts fading to the specified layer .
public static int hashcode ( boolean [ ] field ) { return field == null || field . length == _num ? _num : arrays . hashcode ( field ) ; }	computes the hash code of a repeated boolean field.
public abstractsurfaceobject ( abstractsurfaceobject source ) { super ( source ) ; this . visible = source . visible ; this . uniqueid = nextuniqueid ( ) ; this . lastmodifiedtime = system . currenttimemillis ( ) ; this . enablebatchpicking = source . enablebatchpicking ; }	creates a shallow copy of the specified source shape .
public sootmethodandclass parsesootmethodstring ( string parsestring ) { if ( ! parsestring . startswith ( _str ) || ! parsestring . endswith ( _str ) ) { throw new illegalargumentexception ( _str + parsestring + _str ) ; } string name = _str ; string classname = _str ; string returntype = _str ; pattern pattern = pattern . compile ( _str ) ; matcher matcher = pattern . matcher ( parsestring ) ; if ( matcher . find ( ) ) { classname = matcher . group ( _num ) ; } pattern = pattern . compile ( _str ) ; matcher = pattern . matcher ( parsestring ) ; if ( matcher . find ( ) ) { returntype = matcher . group ( _num ) ; parsestring = parsestring . substring ( matcher . end ( _num ) ) ; } pattern = pattern . compile ( _str ) ; matcher = pattern . matcher ( parsestring ) ; if ( matcher . find ( ) ) { name = matcher . group ( _num ) ; } list < string > paramlist = new arraylist < string > ( ) ; pattern = pattern . compile ( _str ) ; matcher = pattern . matcher ( parsestring ) ; if ( matcher . find ( ) ) { string params = matcher . group ( _num ) ; for ( string param : params . split ( _str ) ) paramlist . add ( param . trim ( ) ) ; } return new sootmethodandclass ( name , classname , returntype , paramlist ) ; }	parses a string in soot representation , for example : < soot.
@ override public void startup ( ) throws exception { log . d ( mary . log , _str ) ; list < string > voicenames = maryproperties . getlist ( _str ) ; for ( string voicename : voicenames ) { long time = system . currenttimemillis ( ) ; voice unitselvoice = new unitselectionvoice ( voicename , this ) ; log . d ( mary . log , _str + unitselvoice + _str ) ; voice . registervoice ( unitselvoice ) ; long newtime = system . currenttimemillis ( ) - time ; log . i ( mary . log , _str + voicename + _str + newtime + _str ) ; } log . i ( mary . log , _str ) ; }	start up the waveform synthesizer.
public int findstartofcolumn ( int column ) { if ( column == mcolumns ) return getspaceused ( ) ; int currentcolumn = _num ; int currentcharindex = _num ; while ( _bool ) { int newcharindex = currentcharindex ; char c = mtext [ newcharindex ++ ] ; boolean ishigh = character . ishighsurrogate ( c ) ; int codepoint = ishigh ? character . tocodepoint ( c , mtext [ newcharindex ++ ] ) : c ; int wcwidth = wcwidth . width ( codepoint ) ; if ( wcwidth > _num ) { currentcolumn += wcwidth ; if ( currentcolumn == column ) { while ( newcharindex < mspaceused ) { if ( character . ishighsurrogate ( mtext [ newcharindex ] ) ) { if ( wcwidth . width ( character . tocodepoint ( mtext [ newcharindex ] , mtext [ newcharindex + _num ] ) ) <= _num ) { newcharindex += _num ; } else { break ; } } else if ( wcwidth . width ( mtext [ newcharindex ] ) <= _num ) { newcharindex ++ ; } else { break ; } } return newcharindex ; } else if ( currentcolumn > column ) { return currentcharindex ; } } currentcharindex = newcharindex ; } }	note that the column may end of second half of wide character .
public static color decode ( string color , color defaultcolor ) { if ( color == null ) { return defaultcolor ; } color c = getnamedcolor ( color ) ; if ( c == null ) { try { c = color . decode ( color ) ; } catch ( numberformatexception ex ) { return defaultcolor ; } } return c ; }	decodes an html color and turns it into a color object.
public static linkedlist < marymodule > modulesrequiredforprocessing ( marydatatype sourcetype , marydatatype targettype , locale locale , voice voice ) { if ( ! registrationcomplete ) throw new illegalstateexception ( _str ) ; if ( sourcetype == null ) throw new nullpointerexception ( _str ) ; if ( targettype == null ) throw new nullpointerexception ( _str ) ; linkedlist < marydatatype > seentypes = new linkedlist < marydatatype > ( ) ; seentypes . add ( sourcetype ) ; return modulesrequiredforprocessing ( sourcetype , targettype , locale , voice , seentypes ) ; }	a method for determining the list of modules required to transform the given source data type into the requested target data type.
public double distance ( vector o ) { return math . sqrt ( numberconversions . square ( x - o . x ) + numberconversions . square ( y - o . y ) + numberconversions . square ( z - o . z ) ) ; }	get the distance between this vector and another.
public static long calculateelapsedgc ( ) { long timemillis = _num ; for ( garbagecollectormxbean gcbean : gcbeans ) { timemillis += gcbean . getcollectiontime ( ) ; } return timemillis ; }	ask each gc bean for its elapsed collection time.
public void close ( ) { }	flush and close the underlying java.
public static < v > int adddistinctlist ( list < v > sourcelist , list < v > entrylist ) { if ( sourcelist == null || isempty ( entrylist ) ) { return _num ; } int sourcecount = sourcelist . size ( ) ; for ( v entry : entrylist ) { if ( ! sourcelist . contains ( entry ) ) { sourcelist . add ( entry ) ; } } return sourcelist . size ( ) - sourcecount ; }	add all distinct entry to list1 from list2.
public void startobject ( int numfields ) { notnested ( ) ; if ( vtable == null || vtable . length < numfields ) vtable = new int [ numfields ] ; vtable_in_use = numfields ; arrays . fill ( vtable , _num , vtable_in_use , _num ) ; nested = _bool ; object_start = offset ( ) ; }	start encoding a new object in the buffer.
private map < string , string > producestream ( string topic ) { list < producerrecord < string , string > > messages = new arraylist < > ( event_cnt ) ; map < string , string > keyvalmap = new hashmap < > ( ) ; for ( int evt = _num ; evt < event_cnt ; evt ++ ) { long runtime = system . currenttimemillis ( ) ; string key = topic + _str + string . valueof ( evt ) ; string msg = runtime + string . valueof ( evt ) ; messages . add ( new producerrecord < > ( topic , key , msg ) ) ; keyvalmap . put ( key , msg ) ; } kafkabroker . sendmessages ( messages ) ; return keyvalmap ; }	sends messages to kafka .
public static string stringofchar ( char ch , int count ) { stringbuffer buf = new stringbuffer ( ) ; for ( int i = _num ; i < count ; i ++ ) { buf . append ( ch ) ; } return buf . tostring ( ) ; }	returns a string of the given length consisting entirely of the given character.
private void addconnectionview ( connection connection ) { platformimpl . runandwait ( null ) ; }	add a view for the given connection to the pipeline view.
public static void trim ( charsequence atext , int [ ] aspan ) { int begin = aspan [ _num ] ; int end = aspan [ _num ] - _num ; charsequence data = atext ; while ( ( begin < ( data . length ( ) - _num ) ) && trimchar ( data . charat ( begin ) ) ) { begin ++ ; } while ( ( end > _num ) && trimchar ( data . charat ( end ) ) ) { end -- ; } end ++ ; aspan [ _num ] = begin ; aspan [ _num ] = end ; }	remove trailing or leading whitespace from the annotation .
public void addscriptfinishedlistener ( scriptexecutionlistener l ) { m_finishedlisteners . add ( l ) ; }	adds the given listener to its internal list .
public void onconsumefinished ( purchase purchase , iabresult result ) ;	called to notify that a consumption has finished .
public void test_getputbytearray ( ) { final int size = _num ; final idatarecord buf = new fixedbytearraybuffer ( size ) ; assertequals ( ( byte ) _num , buf . getbyte ( _num ) ) ; assertequals ( ( byte ) _num , buf . getbyte ( size - _num ) ) ; final int pos = _num ; for ( int i = _num ; i < limit ; i ++ ) { final byte [ ] expected = new byte [ r . nextint ( size - _num ) ] ; r . nextbytes ( expected ) ; buf . put ( pos , expected ) ; assertequals ( _num , bytesutil . comparebyteswithlenandoffset ( _num , expected . length , expected , pos , expected . length , buf . array ( ) ) ) ; final byte [ ] actual = new byte [ expected . length ] ; buf . get ( pos , actual ) ; asserttrue ( bytesutil . bytesequal ( expected , actual ) ) ; } assertequals ( ( byte ) _num , buf . getbyte ( _num ) ) ; assertequals ( ( byte ) _num , buf . getbyte ( pos + size - _num ) ) ; }	test of the simple forms of the bulk get / put methods .
public static double [ ] concatalldouble ( double [ ] ... arrays ) { int totallength = _num ; final int subarraycount = arrays . length ; for ( int i = _num ; i < subarraycount ; ++ i ) { totallength += arrays [ i ] . length ; } double [ ] result = arrays . copyof ( arrays [ _num ] , totallength ) ; int offset = arrays [ _num ] . length ; for ( int i = _num ; i < subarraycount ; ++ i ) { system . arraycopy ( arrays [ i ] , _num , result , offset , arrays [ i ] . length ) ; offset += arrays [ i ] . length ; } return result ; }	concatenates a list of double arrays into a single array .
private t [ ] ensurecapacity ( int mincapacity ) { if ( tmp . length < mincapacity ) { int newsize = mincapacity ; newsize |= newsize > > _num ; newsize |= newsize > > _num ; newsize |= newsize > > _num ; newsize |= newsize > > _num ; newsize |= newsize > > _num ; newsize ++ ; if ( newsize < _num ) newsize = mincapacity ; else newsize = math . min ( newsize , a . length > > > _num ) ; t [ ] newarray = ( t [ ] ) new object [ newsize ] ; tmp = newarray ; } return tmp ; }	ensures that the external array tmp has at least the specified number of elements , increasing its size if necessary.
public synchronized void add ( string category , double minvalue , double maxvalue ) { super . add ( category , minvalue ) ; mmaxvalues . add ( maxvalue ) ; }	adds new values to the series .
public void cont ( int sessionnumber ) throws exception { this . maxsessionnumber = math . max ( this . maxsessionnumber , sessionnumber ) ; testelements . add ( new continuationelement ( sessionnumber ) ) ; }	adds a continuation . to allow one thread to be used for testing .
public static double calcrotationangleindegrees ( pointf centerpt , pointf targetpt ) { double theta = math . atan2 ( targetpt . y - centerpt . y , targetpt . x - centerpt . x ) ; double angle = math . todegrees ( theta ) ; if ( angle < _num ) { angle += _num ; } return angle ; }	calculates the angle from centerpt to targetpt in degrees.
public int countin ( charsequence sequence ) { int count = _num ; for ( int i = _num ; i < sequence . length ( ) ; i ++ ) { if ( matches ( sequence . charat ( i ) ) ) { count ++ ; } } return count ; }	returns the number of matching characters found in a character sequence .
public deltacrlindicatorextension ( int crlnum ) throws ioexception { super ( pkixextensions . deltacrlindicator_id , _bool , biginteger . valueof ( crlnum ) , name , label ) ; }	creates a delta crl indicator extension with the integer value.
public static void v ( string tag , string s , object ... args ) { if ( log . verbose >= loglevel ) log . v ( tag , string . format ( s , args ) ) ; }	verbose log message with printf formatting .
static private double calclogprob ( int numappear , double mu ) { final double sigma = calcsigmafrommu ( mu ) ; final double lognumappear = math . log ( numappear ) ; final double overmu = math . max ( lognumappear - mu , _num ) ; final double res = - ( _num / _num ) * ( overmu * overmu ) / ( sigma * sigma ) - s_logsqrttwopi - math . log ( sigma ) ; assert ( res <= _num ) ; return res ; }	calculate the log probability given the message ' s logarithm is normally distributed.
@ override public softwarepidcontroller withtolerance ( double tolerance ) { target = target . withtolerance ( math . abs ( tolerance ) ) ; return this ; }	sets the absolute tolerance for this controller .
protected final void dragdropfinished ( final boolean success , final int operations , final int x , final int y ) { dragsourceevent event = new dragsourcedropevent ( getdragsourcecontext ( ) , operations & sourceactions , success , x , y ) ; eventdispatcher dispatcher = new eventdispatcher ( dispatch_finish , event ) ; suntoolkit . invokelateronappcontext ( suntoolkit . targettoappcontext ( getcomponent ( ) ) , dispatcher ) ; startsecondaryeventloop ( ) ; setnativecontext ( _num ) ; dragimage = null ; dragimageoffset = null ; }	upcall from native code via implemented class ( do ).
@ override public byte [ ] write ( internallog log ) throws ioexception { final byte [ ] rowkey = rowkeybuilder . buildrowkey ( log ) ; final put p = new put ( rowkey ) ; populatecolumnvalues ( p , log ) ; tbl . put ( p ) ; final list < byte [ ] > indexrowkeys = log . getindexrowkeys ( ) ; if ( indexrowkeys != null ) { writeindexes ( rowkey , indexrowkeys ) ; } return rowkey ; }	todo need think about if multi - put is necessary , by checking if autoflush works.
private void insertintodynamictable ( int index , header entry ) { headerlist . add ( entry ) ; int delta = entry . hpacksize ; if ( index != - _num ) { delta -= dynamictable [ dynamictableindex ( index ) ] . hpacksize ; } if ( delta > maxdynamictablebytecount ) { cleardynamictable ( ) ; return ; } int bytestorecover = ( dynamictablebytecount + delta ) - maxdynamictablebytecount ; int entriesevicted = evicttorecoverbytes ( bytestorecover ) ; if ( index == - _num ) { if ( headercount + _num > dynamictable . length ) { header [ ] doubled = new header [ dynamictable . length * _num ] ; system . arraycopy ( dynamictable , _num , doubled , dynamictable . length , dynamictable . length ) ; nextheaderindex = dynamictable . length - _num ; dynamictable = doubled ; } index = nextheaderindex -- ; dynamictable [ index ] = entry ; headercount ++ ; } else { index += dynamictableindex ( index ) + entriesevicted ; dynamictable [ index ] = entry ; } dynamictablebytecount += delta ; }	index = = - 1 when new .
protected static string extractsecretaccesskey ( string s3uri ) { return s3uri . substring ( s3uri . indexof ( _str , s3uri . indexof ( _str ) + _num ) + _num , s3uri . indexof ( _str ) ) ; }	extracts the secretaccesskey from the given uri.
private void dial ( string contactinformation , boolean makethecall , boolean usephonespeaker ) { if ( contactinformation . equals ( _str ) ) { string lastrecipient = recipientcmd . getlastrecipientnumber ( ) ; string lastrecipientname = recipientcmd . getlastrecipientname ( ) ; if ( lastrecipient != null ) { dodial ( lastrecipientname , lastrecipient , makethecall , usephonespeaker ) ; } else { send ( _str ) ; } } else { resolvedcontact resolvedcontact = mcontactsresolver . resolvecontact ( contactinformation , contactsresolver . type_all ) ; if ( resolvedcontact == null ) { send ( r . string . chat_no_match_for , contactinformation ) ; } else if ( resolvedcontact . isdistinct ( ) ) { dodial ( resolvedcontact . getname ( ) , resolvedcontact . getnumber ( ) , makethecall , usephonespeaker ) ; } else { askformoredetails ( resolvedcontact . getcandidates ( ) ) ; } } }	dial the specified contact.
public void addsafeclass ( sootclass clz ) { safeclasses . add ( clz . getname ( ) ) ; }	denote that all methods of a class are safe .
private boolean activelisthasroom ( ) { int maxdownloads = _num ; return mactivelist . size ( ) < maxdownloads ; }	check if there is room in the active list .
public boolean isrunning ( ) { return this . running ; }	return whether the stop watch is currently running .
protected static map < string , step > parse ( class < ? extends rslpstemmerbase > clazz , string resource ) { try { inputstream is = clazz . getresourceasstream ( resource ) ; linenumberreader r = new linenumberreader ( new inputstreamreader ( is , standardcharsets . utf_8 ) ) ; map < string , step > steps = new hashmap < > ( ) ; string step ; while ( ( step = readline ( r ) ) != null ) { step s = parsestep ( r , step ) ; steps . put ( s . name , s ) ; } r . close ( ) ; return steps ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }	parse a resource file into an rslp stemmer description .
public string bettostring ( ) { final stringbuilder sb = new stringbuilder ( ) ; sb . append ( amount ) ; sb . append ( _str ) ; sb . append ( itemname ) ; sb . append ( _str ) ; sb . append ( target ) ; return sb . tostring ( ) ; }	converts the bet into a string .
public void test_nonemptyjournal ( ) throws ioexception , interruptedexception , executionexception { final file out = file . createtempfile ( getname ( ) , options . jnl ) ; try { final journal src = getstore ( getproperties ( ) ) ; try { if ( ! ( src . getbufferstrategy ( ) instanceof ihabufferstrategy ) ) { return ; } src . write ( getrandomdata ( _num ) ) ; src . commit ( ) ; try { final isnapshotfactory snapshotfactory = new mysnapshotfactory ( getname ( ) , _bool ) ; final future < isnapshotresult > f = src . snapshot ( snapshotfactory ) ; final isnapshotresult snapshotresult = f . get ( ) ; final file snapshotfile = snapshotresult . getfile ( ) ; try { final journal tmp = opensnapshot ( snapshotresult ) ; assertequals ( src . getrootblockview ( ) , tmp . getrootblockview ( ) ) ; tmp . destroy ( ) ; } finally { if ( snapshotfile . exists ( ) ) { snapshotfile . delete ( ) ; } } } catch ( illegalargumentexception ex ) { log . info ( _str + ex ) ; } } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }	verifies exception if there are no commits on the journal ( the lastcommittime will be zero which does not identify a valid commit point ) .
private boolean checkmatchip ( map < string , object > rows ) { boolean matchether = _bool ; string val = ( string ) rows . get ( staticflowentrypusher . column_dl_type ) ; if ( val != null ) { int type = _num ; if ( val . startswith ( _str ) ) { type = integer . parseint ( val . substring ( _num ) , _num ) ; } else { try { type = integer . parseint ( val ) ; } catch ( numberformatexception e ) { } } if ( type == _num ) matchether = _bool ; } if ( ( rows . containskey ( staticflowentrypusher . column_nw_dst ) || rows . containskey ( staticflowentrypusher . column_nw_src ) || rows . containskey ( staticflowentrypusher . column_nw_proto ) || rows . containskey ( staticflowentrypusher . column_nw_tos ) ) && ( matchether == _bool ) ) return _bool ; return _bool ; }	checks to see if the user matches ip information without checking for the correct ether - type ( 2048 ) .
public static double powquick ( double value , double power ) { if ( use_jdk_math ) { return strict_math ? strictmath . pow ( value , power ) : math . pow ( value , power ) ; } return fastmath . exp ( power * fastmath . logquick ( value ) ) ; }	quick pow , with a max relative error of about 3.
private string classtoentrypath ( class < ? > clazz ) { string name = _str ; class < ? > parent ; while ( ( parent = clazz . getenclosingclass ( ) ) != null ) { name = _str + clazz . getsimplename ( ) + name ; clazz = parent ; } return classnametoentrypath ( clazz . getcanonicalname ( ) + name ) ; }	utility method to get the jar entry path from a class name.
public static string write ( posmikheevcounter counter ) { return posbaselinecounter . write ( counter ) ; }	write an instance of posmikheevcounter class to json format.
private map < string , annotationmirror > annosinpackage ( packageelement packageelement ) { return createimportedannotationsmap ( elementfilter . typesin ( packageelement . getenclosedelements ( ) ) ) ; }	all annotations defined in the package.
public osmelement pastefrom ( ) { list < way > ways = storage . getways ( ) ; list < node > nodes = storage . getnodes ( ) ; if ( mode == mode . cut ) { reset ( ) ; if ( ways != null && ways . size ( ) == _num ) { way w = ways . get ( _num ) ; w . setstate ( savedstate ) ; for ( node nd : w . getnodes ( ) ) { log . d ( _str , _str + nd . getosmid ( ) ) ; nd . setstate ( savedndstate . get ( nd ) ) ; } return w ; } else if ( nodes != null && nodes . size ( ) == _num ) { node n = nodes . get ( _num ) ; n . setstate ( savedstate ) ; return n ; } } else { if ( ways != null && ways . size ( ) == _num ) { return ways . get ( _num ) ; } else if ( nodes != null && nodes . size ( ) == _num ) { return nodes . get ( _num ) ; } } return null ; }	returns whatever is in the clipboard.
public final void updatecursor ( ) { updatepending . set ( _bool ) ; updatecursorimpl ( ) ; }	sets the cursor to correspond the component currently under mouse.
public static boolean ismiddlemousebutton ( mouseevent anevent ) { return ( ( anevent . getmodifiersex ( ) & inputevent . button2_down_mask ) != _num || anevent . getbutton ( ) == mouseevent . button2 ) ; }	returns true if the mouse event specifies the middle mouse button .
public void addsuccessmessage ( final string successmessage ) { successmessagelist . add ( successmessage ) ; }	adds a success message into the list .
private void startstoppedchanged ( ) { clock . setstartstopped ( startstoppedcheckbox . isselected ( ) ) ; changed = _bool ; }	method to handle start stopped check box change.
public void close ( ) throws ioexception { try { debug . message ( _str , _str ) ; if ( debug . debugging ( _str ) ) { thread . sleep ( _num ) ; } if ( inputstream != null ) inputstream . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } inputstream = null ; }	closes the underlying file.
public static long nextlogsegmentsequencenumber ( list < logsegmentmetadata > segmentlistdesc ) { int lastassignedlogsegmentidx = - _num ; long lastassignedlogsegmentseqno = null ; long nextlogsegmentseqno = null ; for ( int i = _num ; i < segmentlistdesc . size ( ) ; i ++ ) { logsegmentmetadata metadata = segmentlistdesc . get ( i ) ; if ( logsegmentmetadata . supportslogsegmentsequenceno ( metadata . getversion ( ) ) ) { lastassignedlogsegmentseqno = metadata . getlogsegmentsequencenumber ( ) ; lastassignedlogsegmentidx = i ; break ; } } if ( null != lastassignedlogsegmentseqno ) { nextlogsegmentseqno = lastassignedlogsegmentseqno + lastassignedlogsegmentidx + _num ; } return nextlogsegmentseqno ; }	assign next log segment sequence number based on a decreasing list of log segments .
public static void assertspecificlang ( string specificlang ) throws xmpexception { if ( specificlang == null || specificlang . length ( ) == _num ) { throw new xmpexception ( _str , xmperror . badparam ) ; } }	asserts that a specific language is set .
public int onblockexploded ( ) { return ( int ) ( fusetime / _num + math . random ( ) * fusetime / _num ) ; }	called when the block for of this explosive is destroy by an explosion.
@ override public boolean hasqueuedreaderthreads ( ) { return readerlock . hasqueuedthreads ( ) ; }	returns whether there are threads waiting for read access to the guacamole instruction stream .
public long inactivetimemillis ( ) { return system . currenttimemillis ( ) - lasttimemillis ; }	returns the number of milliseconds this session has been inactive .
public static void check ( boolean cond , object value ) { if ( ! cond ) error ( string . valueof ( value ) ) ; }	equivalent to assert cond : value ;.
public void adddefinition ( icosdefinition cosdef ) throws umsexception { if ( ! ( cosdef instanceof directcosdefinition ) ) { string msg = i18n . getstring ( iumsconstants . invalid_cosdefinition ) ; throw new umsexception ( msg ) ; } string [ ] cosattributes = cosdef . getcosattributes ( ) ; abstractcollection alist = ( abstractcollection ) arrays . aslist ( icosdefinition . qualifiers ) ; for ( int i = _num ; i < cosattributes . length ; i ++ ) { string cosattribute = null ; string qualifier = null ; stringtokenizer st = new stringtokenizer ( cosattributes [ i ] ) ; if ( st . hasmoretokens ( ) ) { cosattribute = st . nexttoken ( ) ; } if ( cosattribute == null ) { string msg = i18n . getstring ( iumsconstants . invalid_cos_attribute_qualifier ) ; throw new umsexception ( msg ) ; } if ( st . hasmoretokens ( ) ) qualifier = st . nexttoken ( ) ; if ( qualifier == null ) { qualifier = icosdefinition . qualifiers [ icosdefinition . default ] ; cosdef . removecosattribute ( cosattribute ) ; cosdef . addcosattribute ( cosattribute , icosdefinition . default ) ; } if ( ! alist . contains ( qualifier ) ) { string msg = i18n . getstring ( iumsconstants . invalid_cos_attribute_qualifier ) ; throw new umsexception ( msg ) ; } } persistentobject po = ( persistentobject ) cosdef ; _parentobject . addchild ( po ) ; }	this method adds a cos definition to the persistent store.
public static sourcedataquality fromxml ( element domelement ) { nodelist fields = domelement . getchildnodes ( ) ; int fieldscount = fields . getlength ( ) ; string fieldname ; string fieldvaluestring ; node fieldnode ; sourcedataquality result = new sourcedataquality ( ) ; for ( int i = _num ; i != fieldscount ; i ++ ) { fieldnode = fields . item ( i ) ; if ( fieldnode . getnodetype ( ) == node . element_node ) { fieldname = fieldnode . getnodename ( ) ; node fieldvaluenode = fieldnode . getfirstchild ( ) ; if ( fieldvaluenode != null ) { fieldvaluestring = fieldvaluenode . getnodevalue ( ) ; } else { fieldvaluestring = _str ; } if ( fieldname . equals ( xml_element_quality_code ) ) { result . qualitycode = short . parseshort ( fieldvaluestring ) ; } else if ( fieldname . equals ( xml_element_quality_desc ) ) { result . description = fieldvaluestring ; } } } return result ; }	create a sourcedataquality object from its xml representation.
qname toqname ( class < ? > outputclass ) { string localpart ; string namespaceuri ; if ( outputclass . isannotationpresent ( xmlrootelement . class ) ) { xmlrootelement annotation = outputclass . getannotation ( xmlrootelement . class ) ; localpart = annotation . name ( ) ; namespaceuri = annotation . namespace ( ) ; } else if ( outputclass . isannotationpresent ( xmltype . class ) ) { xmltype annotation = outputclass . getannotation ( xmltype . class ) ; localpart = annotation . name ( ) ; namespaceuri = annotation . namespace ( ) ; } else { throw new illegalargumentexception ( _str + outputclass + _str + _str ) ; } if ( jaxb_default_annotation_value . equals ( localpart ) ) { localpart = classutils . getshortnameasproperty ( outputclass ) ; } if ( jaxb_default_annotation_value . equals ( namespaceuri ) ) { package outputclasspackage = outputclass . getpackage ( ) ; if ( outputclasspackage != null && outputclasspackage . isannotationpresent ( xmlschema . class ) ) { xmlschema annotation = outputclasspackage . getannotation ( xmlschema . class ) ; namespaceuri = annotation . namespace ( ) ; } else { namespaceuri = xmlconstants . null_ns_uri ; } } return new qname ( namespaceuri , localpart ) ; }	returns the qualified name for the given class , according to the mapping rules in the jaxb specification .
private static string generatejwt ( string secret , string jwtid , string iss , integer ttl , map < string , string > claims ) throws hmacexception { try { return signjwt ( secret , jwtid , ttl , iss , claims ) ; } catch ( joseexception e ) { e . printstacktrace ( ) ; throw new hmacexception ( _str , e ) ; } }	generate a new signed jwt.
public void exportsymbols ( string [ ] exportnames , symbol [ ] symbols ) { if ( exportedsymbols == null ) { exportedsymbols = new arraylist ( ) ; } for ( int i = _num ; i < exportnames . length && i < symbols . length ; i ++ ) { exportedsymbols . add ( new exportedsymbol ( symbols [ i ] , exportnames [ i ] ) ) ; } }	export a number of symbols with the given names so that other movies can import and use them.
static boolean isfulfilling ( int m ) { return ( m & fulfilling ) != _num ; }	returns true if m has fulfilling bit set .
@ override public synchronized void adddatasourcelistener ( datasourcelistener dsl ) { m_datasourcelisteners . addelement ( dsl ) ; if ( m_format != null ) { datasetevent e = new datasetevent ( this , m_format ) ; dsl . acceptdataset ( e ) ; } }	add a datasource listener.
public static annotationmirror findeffectiveannotationinhierarchy ( final qualifierhierarchy qualifierhierarchy , final annotatedtypemirror tosearch , final annotationmirror top ) { return findeffectiveannotationinhierarchy ( qualifierhierarchy , tosearch , top , _bool ) ; }	when comparing types against the bounds of a type variable , we may encounter other type variables , wildcards , and intersections in those bounds.
public boolean tofail ( ) { lifecyclestate state ; synchronized ( this ) { state = _state ; if ( state . isafterdestroying ( ) ) { return _bool ; } _state = failed ; _lastchangetime = currenttime . currenttime ( ) ; } if ( _log != null && _log . isloggable ( _level ) ) _log . log ( _level , _str + _name ) ; notifylisteners ( state , failed ) ; _failcount ++ ; return _bool ; }	changes to the failed state .
private static void read ( inputstream in , byte [ ] buf , int pos , int n ) throws ioexception { int read = _num ; int res = _num ; while ( read < n ) { res = in . read ( buf , read + pos , n - read ) ; if ( res > _num ) { read += res ; } else { throw new ioexception ( _str + read + _str + n ) ; } } }	read at least the specified amount of bytes , and place them in the input buffer .
public double evaluate ( vectorinstance x , vectorinstance y ) throws exception { vectorinstance diff = x . subtract ( y ) ; double result = - m_gamma * diff . dotproduct ( diff ) ; return math . exp ( result ) ; }	compute the result of the kernel evaluation on the supplied vectors.
void parsefinish ( ) { mchildren = mcurrentgroup . getchildren ( ) ; }	ensure there is at least one animation for every path in group ( linking them by names ) build the " current " path based on the first group.
void cancelincludedonly ( ) { if ( ! _showallinput ) { _inputallbutton . doclick ( ) ; } if ( ! _showalloutput ) { _outputallbutton . doclick ( ) ; } if ( ! _showallalign ) { _alignallbutton . doclick ( ) ; } }	cancels included only option.
list < entry > killall ( boolean rootincluded ) { list < entry > killed = new arraylist < > ( rootincluded ? entries . size ( ) : entries . size ( ) - _num ) ; entry entry ; for ( int i = entries . size ( ) - _num ; i > ( rootincluded ? - _num : _num ) ; i -- ) { entry = entries . get ( i ) ; if ( entry . dead ) continue ; entry . dead = _bool ; if ( i != _num ) { killed . add ( entry ) ; } } return killed ; }	kill all , including root or not the returned entries don ' t include the root entry though.
public static void createerrordialog ( final string title , final string message ) { final alert alert = new alert ( alerttype . error ) ; alert . settitle ( title ) ; alert . setcontenttext ( message ) ; alert . setheadertext ( null ) ; alert . showandwait ( ) ; }	shows an error dialog .
public static string checkindexheadersuffix ( datainput in , string expectedsuffix ) throws ioexception { int suffixlength = in . readbyte ( ) & _num ; byte suffixbytes [ ] = new byte [ suffixlength ] ; in . readbytes ( suffixbytes , _num , suffixbytes . length ) ; string suffix = new string ( suffixbytes , _num , suffixbytes . length , standardcharsets . utf_8 ) ; if ( ! suffix . equals ( expectedsuffix ) ) { throw new corruptindexexception ( _str + expectedsuffix + _str + suffix , in ) ; } return suffix ; }	expert : just reads and verifies the suffix of an index header.
protected void tag ( string tag , arraylist names , arraylist values , int nattr , boolean close ) { spacing ( ) ; m_out . print ( _str ) ; m_out . print ( tag ) ; for ( int i = _num ; i < nattr ; ++ i ) { m_out . print ( _str ) ; m_out . print ( ( string ) names . get ( i ) ) ; m_out . print ( _str ) ; m_out . print ( _str ) ; escapestring ( ( string ) values . get ( i ) ) ; m_out . print ( _str ) ; } if ( close ) m_out . print ( _str ) ; m_out . print ( _str ) ; println ( ) ; if ( ! close ) { m_tagstack . add ( tag ) ; } }	internal method for printing a tag with attributes .
public static string parsediskstring ( string input ) { string delims = _str ; string [ ] tokens = input . split ( delims ) ; return tokens [ _num ] ; }	get the disk name out from the input string .
private static boolean istrusted ( object obj , trustverifier . context ctx ) throws remoteexception { object saved = state . get ( ) ; try { state . set ( obj ) ; return ctx . istrustedobject ( obj ) ; } finally { state . set ( saved ) ; } }	returns result of calling ctx.
public static persistentsearchrequestcontrol newcontrol ( final boolean iscritical , final boolean changesonly , final boolean returnecs , final persistentsearchchangetype ... changetypes ) { reject . ifnull ( ( object ) changetypes ) ; return newcontrol ( iscritical , changesonly , returnecs , arrays . aslist ( changetypes ) ) ; }	creates a new persistent search request control .
private void connectequalized ( synapsegroup synapsegroup ) { currentorderingindices = new int [ sourceneurons . length ] ; int numconnectspersrc ; int expectednumsyns ; if ( synapsegroup . isrecurrent ( ) && ! selfconnectionallowed ) { numconnectspersrc = ( int ) ( connectiondensity * ( sourceneurons . length - _num ) ) ; } else { numconnectspersrc = ( int ) ( connectiondensity * targetneurons . length ) ; } expectednumsyns = numconnectspersrc * sourceneurons . length ; synapsegroup . preallocatesynapses ( expectednumsyns ) ; for ( int i = _num , n = sourceneurons . length ; i < n ; i ++ ) { currentorderingindices [ i ] = numconnectspersrc ; neuron src = sourceneurons [ i ] ; neuron tar ; for ( int j = _num ; j < numconnectspersrc ; j ++ ) { tar = targetneurons [ sparseordering [ i ] [ j ] ] ; synapse s = new synapse ( src , tar ) ; synapsegroup . addnewsynapse ( s ) ; } } }	populates the synapse group with synapses by making individual synaptic connections between the neurons in the synapse group ' s source and target groups.
public static number multiply ( character left , character right ) { return multiply ( integer . valueof ( left ) , right ) ; }	multiply two characters . the ordinal values of the characters are used in the multiplication ( the ordinal value is the unicode value which for simple character sets is the ascii value ) .
public static string normalize ( final charsequence self ) { final string s = self . tostring ( ) ; int nx = s . indexof ( _str ) ; if ( nx < _num ) { return s ; } final int len = s . length ( ) ; final stringbuilder sb = new stringbuilder ( len ) ; int i = _num ; do { sb . append ( s , i , nx ) ; sb . append ( _str ) ; if ( ( i = nx + _num ) >= len ) break ; if ( s . charat ( i ) == _str ) { if ( ++ i >= len ) break ; } nx = s . indexof ( _str , i ) ; } while ( nx > _num ) ; sb . append ( s , i , len ) ; return sb . tostring ( ) ; }	return a string with linefeeds and carriage returns normalized to linefeeds .
public void addzonechangelistener ( zonechangelistener listener ) { zonechangelisteners . add ( listener ) ; }	add a listener to be called when the player changes zone .
public void write ( final int b ) throws ioexception { if ( m_store == null ) { throw new illegalstateexception ( err_no_store ) ; } if ( m_issaved ) { throw new illegalstateexception ( err_already_saved ) ; } if ( m_count == m_blobthreshold && ! m_writinghdr ) { if ( m_blobheader == null ) { m_blobheader = new arraylist < integer > ( ) ; } final int curaddr = ( int ) m_store . alloc ( m_buf , m_count , m_context ) ; m_blobheader . add ( curaddr ) ; m_count = _num ; } m_buf [ m_count ++ ] = ( byte ) b ; m_byteswritten ++ ; }	write a single byte this is the one place where the blob threshold is handled and its done one byte at a time so should be easy enough , we no longer store continuation addresses , instead we allocate blob allocations via a blob header block .
public startlistener ( object resource ) { _resource = resource ; }	creates the new start listener .
public list < t > asflatlist ( ) { list < t > list = new arraylist < t > ( ) ; for ( int i = _num ; i < getrowcount ( ) ; i ++ ) { for ( int j = _num ; j < getcolumncount ( ) ; j ++ ) { list . add ( getlogicalvalueat ( i , j ) ) ; } } return list ; }	returns the contents of the table as a flat list .
@ beta public void reset ( ) { schedulershook . set ( null ) ; }	reset any explicit or default - set hooks.
public static string hashkeyfordisk ( string key ) { string cachekey ; try { final messagedigest mdigest = messagedigest . getinstance ( _str ) ; mdigest . update ( key . getbytes ( ) ) ; cachekey = bytestohexstring ( mdigest . digest ( ) ) ; } catch ( nosuchalgorithmexception e ) { cachekey = string . valueof ( key . hashcode ( ) ) ; } return cachekey ; }	a hashing method that changes a string ( like a url ) into a hash suitable for using as a disk filename .
public void recordtimestamp ( ) { long curtimestamp = system . currenttimemillis ( ) ; if ( usedfields > _num ) { long diff = curtimestamp - lastvalue ; if ( usedfields == diffs . length ) { long removedvalue = diffs [ curposition ] ; diffs [ curposition ] = diff ; calculatenewaverage ( removedvalue , diff , _bool ) ; shiftend ( ) ; } else { calculatenewaverage ( _num , diff , _bool ) ; diffs [ curposition ] = diff ; shiftend ( ) ; } } else if ( lastvalue != - _num ) { long diff = curtimestamp - lastvalue ; currentaverage = _num ; diffs [ curposition ] = diff ; calculatenewaverage ( _num , diff , _bool ) ; shiftend ( ) ; } lastvalue = curtimestamp ; }	adds a value and calculates the new average of differences between the values within the window size provided at creation .
@ aftermethod public void teardown ( ) throws exception { throwable t = threadfailure . getandset ( null ) ; if ( t != null ) { if ( t instanceof error ) throw ( error ) t ; else if ( t instanceof runtimeexception ) throw ( runtimeexception ) t ; else if ( t instanceof exception ) throw ( exception ) t ; else { assertionfailederror afe = new assertionfailederror ( t . tostring ( ) ) ; afe . initcause ( t ) ; throw afe ; } } if ( thread . interrupted ( ) ) teardownfail ( _str ) ; checkforkjoinpoolthreadleaks ( ) ; }	extra checks that get done for all test cases.
public void parse ( string string ) { if ( string == null ) { throw new nullpointerexception ( _str ) ; } int buffersize = math . max ( min_buffer_size , math . min ( default_buffer_size , string . length ( ) ) ) ; try { parse ( new stringreader ( string ) , buffersize ) ; } catch ( ioexception exception ) { throw new runtimeexception ( exception ) ; } }	parses the given input string.
protected double defaultmaxradius ( ) { return math . sqrt ( _num ) ; }	returns the default max radius.
public char [ ] tochararray ( ) { char [ ] newvalue = new char [ count ] ; system . arraycopy ( buf , _num , newvalue , _num , count ) ; return newvalue ; }	returns a copy of the input data .
@ override protected int sizependingworkers ( ) { return _pendingworkers . size ( ) ; }	the size of pending workers.
public void insert ( component component , int index ) { if ( index < _num ) { throw new illegalargumentexception ( _str ) ; } int nitems = getcomponentcount ( ) ; vector < component > tempitems = new vector < component > ( ) ; for ( int i = index ; i < nitems ; i ++ ) { tempitems . addelement ( getcomponent ( index ) ) ; remove ( index ) ; } add ( component ) ; for ( component tempitem : tempitems ) { add ( tempitem ) ; } }	inserts the specified component into the menu at a given position .
public static list < string > unescape ( string source , char escapechar , char [ ] specialcharacters , char splitcharacter , int splitlimit ) { list < string > result = new linkedlist < > ( ) ; stringbuilder b = new stringbuilder ( ) ; boolean readescape = _bool ; int indexcount = - _num ; for ( char c : source . tochararray ( ) ) { indexcount ++ ; if ( readescape ) { boolean found = _bool ; if ( c == splitcharacter ) { found = _bool ; b . append ( c ) ; } else if ( c == escapechar ) { found = _bool ; b . append ( c ) ; } else { for ( char s : specialcharacters ) { if ( s == c ) { found = _bool ; b . append ( c ) ; break ; } } } if ( ! found ) { throw new illegalargumentexception ( _str + source + _str + c + _str ) ; } readescape = _bool ; } else if ( c == escapechar ) { readescape = _bool ; } else if ( c == splitcharacter ) { readescape = _bool ; result . add ( b . tostring ( ) ) ; if ( splitlimit != - _num ) { if ( result . size ( ) == splitlimit - _num ) { result . add ( source . substring ( indexcount + _num ) ) ; return result ; } } b = new stringbuilder ( ) ; } else { readescape = _bool ; b . append ( c ) ; } } result . add ( b . tostring ( ) ) ; return result ; }	splits the string at every split character unless escaped.
@ override public string append ( string path , inputstream is ) throws malformedurlexception , ioexception , authenticationexception { string resp = null ; ensurevalidtoken ( ) ; string spec = messageformat . format ( _str , urlutil . encodepath ( path ) , this . principal ) ; string redirecturl = null ; httpurlconnection conn = authenticatedurl . openconnection ( new url ( new url ( httpfsurl ) , spec ) , token ) ; conn . setrequestmethod ( _str ) ; conn . setinstancefollowredirects ( _bool ) ; conn . connect ( ) ; logger . info ( _str + conn . getheaderfield ( _str ) ) ; resp = result ( conn , _bool ) ; if ( conn . getresponsecode ( ) == _num ) redirecturl = conn . getheaderfield ( _str ) ; conn . disconnect ( ) ; if ( redirecturl != null ) { conn = authenticatedurl . openconnection ( new url ( redirecturl ) , token ) ; conn . setrequestmethod ( _str ) ; conn . setdooutput ( _bool ) ; conn . setdoinput ( _bool ) ; conn . setusecaches ( _bool ) ; conn . setrequestproperty ( _str , _str ) ; final int _size = is . available ( ) ; conn . setrequestproperty ( _str , _str + _size ) ; conn . setfixedlengthstreamingmode ( _size ) ; conn . connect ( ) ; outputstream os = conn . getoutputstream ( ) ; copy ( is , os ) ; is . close ( ) ; os . close ( ) ; resp = result ( conn , _bool ) ; conn . disconnect ( ) ; } return resp ; }	curl - i - x post " http : / / < host > : < port > / webhdfs / v1 / < path > ? op = append [ & buffersize = < int > ] ".
public economyconcurrenthashmap ( map < ? extends k , ? extends v > m , ihashentryhandler < k , v > handler ) { this ( math . max ( ( int ) ( m . size ( ) / default_load_factor ) + _num , default_initial_capacity ) , default_load_factor , default_concurrency_level , handler ) ; putall ( m ) ; }	creates a new map with the same mappings as the given map.
void addrule ( string [ ] selector , attributeset declaration , boolean islinked ) { int n = selector . length ; stringbuilder sb = new stringbuilder ( ) ; sb . append ( selector [ _num ] ) ; for ( int counter = _num ; counter < n ; counter ++ ) { sb . append ( _str ) ; sb . append ( selector [ counter ] ) ; } string selectorname = sb . tostring ( ) ; style rule = getstyle ( selectorname ) ; if ( rule == null ) { style altrule = addstyle ( selectorname , null ) ; synchronized ( this ) { selectormapping mapping = getrootselectormapping ( ) ; for ( int i = n - _num ; i >= _num ; i -- ) { mapping = mapping . getchildselectormapping ( selector [ i ] , _bool ) ; } rule = mapping . getstyle ( ) ; if ( rule == null ) { rule = altrule ; mapping . setstyle ( rule ) ; refreshresolvedrules ( selectorname , selector , rule , mapping . getspecificity ( ) ) ; } } } if ( islinked ) { rule = getlinkedstyle ( rule ) ; } rule . addattributes ( declaration ) ; }	adds a rule into the stylesheet .
public builder appendreaddata ( byte [ ] data ) { assertions . checkstate ( data != null && data . length > _num ) ; segments . add ( new segment ( data , null ) ) ; return this ; }	appends to the underlying data .
private boolean islatestdsskeystore ( tslparserresult parseresult ) { list < string > englishschemeinformationuris = parseresult . getenglishschemeinformationuris ( ) ; return englishschemeinformationuris . contains ( ojurl ) ; }	this method checks if the oj url is still correct.
private synchronized void initresourcebundle ( string resourcebundlename ) { string current = this . resourcebundlename ; if ( current != null ) { if ( current . equals ( resourcebundlename ) ) { return ; } else { throw new illegalargumentexception ( _str + resourcebundlename + _str + current + _str ) ; } } if ( resourcebundlename != null ) { this . resourcebundle = loadresourcebundle ( resourcebundlename ) ; this . resourcebundlename = resourcebundlename ; } }	initializes this logger ' s resource bundle .
public layergraphicwarehousesupport ( ) { initdrawingattributes ( ) ; graphics = new omgraphiclist ( ) ; graphics . settraversemode ( omgraphiclist . last_added_on_top ) ; }	construct an object , initializes graphiclist.
public boolean matchesnamingconvension ( ) { return packagename . matches ( java_package_convension ) ; }	check whether the package name match standard java package name conventions .
void rememberfactory ( string host , rmisocketfactory factory ) { synchronized ( successtable ) { while ( hostlist . size ( ) >= maxrememberedhosts ) { successtable . remove ( hostlist . elementat ( _num ) ) ; hostlist . removeelementat ( _num ) ; } hostlist . addelement ( host ) ; successtable . put ( host , factory ) ; } }	remember a successful factory for connecting to host.
public char next ( ) { return pos < in . length ( ) ? in . charat ( pos ++ ) : _str ; }	returns the next available character , or the null character ' \ 0 ' if all input has been exhausted.
private map . entry < k , v > doremovefirstentry ( ) { for ( node < k , v > b , n ; ; ) { if ( ( n = ( b = head . node ) . next ) == null ) return null ; node < k , v > f = n . next ; if ( n != b . next ) continue ; object v = n . value ; if ( v == null ) { n . helpdelete ( b , f ) ; continue ; } if ( ! n . casvalue ( v , null ) ) continue ; if ( ! n . appendmarker ( f ) || ! b . casnext ( n , f ) ) findfirst ( ) ; clearindextofirst ( ) ; @ suppresswarnings ( _str ) v vv = ( v ) v ; return new abstractmap . simpleimmutableentry < k , v > ( n . key , vv ) ; } }	removes first entry ; returns its snapshot .
public computetaskcancelledexception ( throwable cause ) { this ( cause . getmessage ( ) , cause ) ; }	creates new task cancellation exception given throwable as a cause and source of error message .
public static int normalize ( char [ ] src , int srcstart , int srclimit , char [ ] dest , int deststart , int destlimit , mode mode , int options ) { int length = mode . normalize ( src , srcstart , srclimit , dest , deststart , destlimit , options ) ; if ( length <= ( destlimit - deststart ) ) { return length ; } else { throw new indexoutofboundsexception ( integer . tostring ( length ) ) ; } }	normalize a string . the string will be normalized according the the specified normalization mode and options .
private void removeobsoleteelements ( list < string > names , map < string , view > sharedelements , list < string > elementstoremove ) { if ( elementstoremove . size ( ) > _num ) { names . removeall ( elementstoremove ) ; for ( string elementtoremove : elementstoremove ) { sharedelements . remove ( elementtoremove ) ; } } }	removes obsolete elements from names and shared elements .
public void removeaction ( networkupdateaction action ) { actionlist . remove ( action ) ; for ( updatemanagerlistener listener : listeners ) { listener . actionremoved ( action ) ; } }	completely remove an action .
public static double bufferdistanceerror ( int quadsegs ) { double alpha = math . pi / _num / quadsegs ; return _num - math . cos ( alpha / _num ) ; }	computes the maximum distance error due to a given level of approximation to a true arc .
public pair < string , string > next ( ) { try { currentheaderposition = nextheaderposition ; string readheader = nextline ; nextheaderposition += readheader . length ( ) + endoflinebytes ; readheader = _str + readheader . substring ( _num ) ; string readsequence = r . readline ( ) ; nextheaderposition += readsequence . length ( ) + endoflinebytes ; string comments = r . readline ( ) ; nextheaderposition += comments . length ( ) + endoflinebytes ; if ( comments . startswith ( _str ) ) { string qualityvalues = r . readline ( ) ; nextheaderposition += qualityvalues . length ( ) + endoflinebytes ; } nextline = r . readline ( ) ; return new pair < > ( readheader , readsequence ) ; } catch ( ioexception e ) { basic . caught ( e ) ; } return null ; }	gets next fasta record.
public void add ( character character ) { elements . add ( character == null ? jsonnull . instance : new jsonprimitive ( character ) ) ; }	adds the specified character to self .
public static boolean isvalidifd ( int ifdid ) { return ifdid == ifdid . type_ifd_0 || ifdid == ifdid . type_ifd_1 || ifdid == ifdid . type_ifd_exif || ifdid == ifdid . type_ifd_interoperability || ifdid == ifdid . type_ifd_gps ; }	returns true if the given ifd is a valid ifd .
public void removechild ( group thegroup ) { mchildren . remove ( thegroup ) ; }	remove a child from this group.
protected storageport checkportexistsindb ( string nativeguid ) throws ioexception { storageport port = null ; list < storageport > portindb = customqueryutility . getactivestorageportbynativeguid ( _dbclient , nativeguid ) ; if ( portindb != null && ! portindb . isempty ( ) ) { port = portindb . get ( _num ) ; } return port ; }	check if port exists in db .
public void appendsplitelement ( fragment asplit ) { splits . add ( asplit ) ; }	adds a split element at the end.
public osmhandler ( mapbuilder meconsumer ) { osmelementprocessor = new osmelementprocessor ( null , meconsumer ) ; }	creates a new instance .
public void close ( ) throws ioexception { flushbits ( ) ; out . close ( ) ; }	description of the method.
public respokedirectconnection directconnection ( ) { if ( null != directconnectionreference ) { return directconnectionreference . get ( ) ; } else { return null ; } }	get the active direct connection with this endpoint ( if any ).
private string appendnationalnumber ( string nationalnumber ) { int prefixbeforenationalnumberlength = prefixbeforenationalnumber . length ( ) ; if ( shouldaddspaceafternationalprefix && prefixbeforenationalnumberlength > _num && prefixbeforenationalnumber . charat ( prefixbeforenationalnumberlength - _num ) != separator_before_national_number ) { return new string ( prefixbeforenationalnumber ) + separator_before_national_number + nationalnumber ; } else { return prefixbeforenationalnumber + nationalnumber ; } }	combines the national number with any prefix ( idd / + and country code or national prefix ) that was collected.
public void cut ( ) { copy ( ) ; deleteselectedobjects ( ) ; }	cut to the clipboard .
public void stop ( ) { setledon ( _bool ) ; if ( null != blinkfuture ) { blinkfuture . cancel ( _bool ) ; } if ( null != blinkservice ) { blinkservice . shutdownnow ( ) ; } }	calling this method will stop all threads.
public synchronized void release ( ) { index . clear ( ) ; }	releases resources in the index .
public void configure ( ) { if ( cmdprefix != null ) { prefix = cmdprefix . split ( _str ) ; } }	configure the helper . this must called before executing any commands .
protected void writetransform ( affinetransform t ) throws ioexception { pagestream . matrix ( t ) ; }	write the given transformation matrix to the file .
public void testsignumpositive ( ) { string a = _str ; int ascale = _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; assertequals ( _str , _num , anumber . signum ( ) ) ; }	signum ( ) for a positive bigdecimal.
public painterchain prependpainter ( painter p ) { painter [ ] newchain = new painter [ chain . length + _num ] ; system . arraycopy ( chain , _num , newchain , _num , chain . length ) ; newchain [ _num ] = p ; return new painterchain ( newchain ) ; }	creates a new chain based on the existing chain with the new element added at the beginning.
@ nullable private operator . kind parseoperator ( tokenstream tokens ) { if ( tokens . has ( _str ) ) { tokens . next ( ) ; tokens . expect ( _str ) ; return operator . kind . equals ; } if ( tokens . has ( _str ) ) { tokens . next ( ) ; tokens . expect ( _str ) ; return operator . kind . not_equals ; } if ( tokens . has ( _str ) ) { tokens . next ( ) ; if ( tokens . has ( _str ) ) { tokens . next ( ) ; return operator . kind . less_equal ; } return operator . kind . less ; } if ( tokens . has ( _str ) ) { tokens . next ( ) ; if ( tokens . has ( _str ) ) { tokens . next ( ) ; return operator . kind . greater_equal ; } return operator . kind . greater ; } return null ; }	check for and get an operator kind .
@ override public boolean dragto ( selector obj , selector destobj , int steps ) throws uiobjectnotfoundexception , notimplementedexception { return dragto ( device . findobject ( obj . touiselector ( ) ) , destobj , steps ) ; }	drags this object to a destination uiobject.
private void queueupsyncs ( final cursor contactscursor ) { contactsyncentry syncentry = null ; while ( contactscursor . movetonext ( ) ) { if ( syncentry == null ) { syncentry = new contactsyncentry ( upload_batch_size ) ; } final string number = contactscursor . getstring ( contactscursor . getcolumnindex ( contactscontract . commondatakinds . phone . number ) ) ; final string name = contactscursor . getstring ( contactscursor . getcolumnindex ( contactscontract . commondatakinds . phone . display_name ) ) ; if ( ! textutils . isempty ( number ) ) { syncentry . addnumber ( numbertonational ( number ) ) ; syncentry . addname ( name ) ; if ( syncentry . isfull ( ) ) { logger . d ( tag , _str ) ; msyncqueue . add ( syncentry ) ; syncentry = null ; } } } }	method that hashes contacts and syncs them to server.
public synchronized void removeseries ( int index ) { mseries . remove ( index ) ; }	removes the xy series from the list .
public static void addglue ( jcomponent b , int layout ) { b . add ( getaxis ( b , layout ) == boxlayout . x_axis ? box . createhorizontalglue ( ) : box . createverticalglue ( ) ) ; }	add a glue , or variable spacing , to a ui component.
public static void writeresulttofile ( result result , string fname ) throws exception { printwriter outer = new printwriter ( new bufferedwriter ( new filewriter ( fname ) ) ) ; outer . write ( result . tostring ( ) ) ; outer . close ( ) ; }	writeresulttofile - - write a result ' result ' out in plain text format to file ' fname ' .
private jmxprovider ( ) { }	don ' t let anyone instantiate this class .
protected void writeblockletinfotofile ( list < blockletinfocolumnar > infolist , filechannel channel , string filepath ) throws carbondatawriterexception { try { long currentposition = channel . size ( ) ; carbonfooterwriter writer = new carbonfooterwriter ( filepath ) ; filefooter convertfilemeta = carbonmetadatautil . convertfilefooter ( infolist , localcardinality . length , localcardinality , thriftcolumnschemalist , segmentproperties ) ; fillblockindexinfodetails ( infolist , convertfilemeta . getnum_rows ( ) , filepath , currentposition ) ; writer . writefooter ( convertfilemeta , currentposition ) ; } catch ( ioexception e ) { throw new carbondatawriterexception ( _str , e ) ; } }	this method will write metadata at the end of file file format in thrift format.
private static void rendertree ( tree tree , int indent , boolean parentlabelnull , boolean firstsibling , boolean leftsiblingpreterminal , boolean toplevel , stringbuilder sb ) { boolean suppressindent = ( parentlabelnull || ( firstsibling && tree . ispreterminal ( ) ) || ( leftsiblingpreterminal && tree . ispreterminal ( ) ) ) ; if ( suppressindent ) { sb . append ( _str ) ; } else { if ( ! toplevel ) { sb . append ( _str ) ; } for ( int i = _num ; i < indent ; i ++ ) { sb . append ( _str ) ; } } if ( tree . isleaf ( ) || tree . ispreterminal ( ) ) { renderflat ( tree , sb ) ; return ; } sb . append ( _str ) ; sb . append ( tree . getlabel ( ) ) ; renderchildren ( tree . getchildren ( ) , indent + _num , _bool , sb ) ; sb . append ( _str ) ; }	display a node , implementing penn treebank style layout.
public static stringbuffer replaceregex ( stringbuffer original , string regex , string replace , boolean case_insensitive ) { int flags = _num ; if ( case_insensitive ) flags = pattern . case_insensitive ; pattern p = pattern . compile ( regex , flags ) ; matcher m = p . matcher ( original ) ; stringbuffer newsb = new stringbuffer ( ) ; boolean result = m . find ( ) ; while ( result ) { m . appendreplacement ( newsb , replace ) ; result = m . find ( ) ; } m . appendtail ( newsb ) ; return newsb ; }	run regex expression against original string.
public boolean equalschars ( string a , int ai , string b , int bi , boolean ignorecase ) { char ca = a . charat ( ai ) ; char cb = b . charat ( bi ) ; if ( ignorecase ) { ca = character . touppercase ( ca ) ; cb = character . touppercase ( cb ) ; } return ca == cb ; }	compare two characters in a string .
private void adjustbackingfilelength ( byte [ ] buffer , long index ) throws ioexception { if ( buffer == null || buffer . length == _num ) { throw new ioexception ( _str ) ; } long newsize = fheader . headersize ( ) + ( index * chunk_enc_size ) + chunk_iv_size + buffer . length + chunk_tlen ; if ( newsize > reallength ( ) ) { backingrandomaccessfile . setlength ( newsize ) ; } }	helper methods which adjusts the actual length of the backing file for caching.
private static collection < collection < dsnnetpin > > create_ordered_subnets ( collection < dsnnetpin > p_pin_list ) { collection < collection < dsnnetpin > > result = new linkedlist < collection < dsnnetpin > > ( ) ; if ( p_pin_list . isempty ( ) ) { return result ; } iterator < dsnnetpin > it = p_pin_list . iterator ( ) ; dsnnetpin prev_pin = it . next ( ) ; while ( it . hasnext ( ) ) { dsnnetpin next_pin = it . next ( ) ; set < dsnnetpin > curr_subnet_pin_list = new java . util . treeset < dsnnetpin > ( ) ; curr_subnet_pin_list . add ( prev_pin ) ; curr_subnet_pin_list . add ( next_pin ) ; result . add ( curr_subnet_pin_list ) ; prev_pin = next_pin ; } return result ; }	creates a sequence of subnets with 2 pins from p_pin_list.
private static string createjsmethodinvocationexpression ( string methodname , boolean isstatic , string ... paramnames ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( isstatic ? wnd : this ) ; sb . append ( _str ) ; sb . append ( methodname ) ; sb . append ( _str ) ; for ( int i = _num ; i < paramnames . length ; i ++ ) { if ( i != _num ) { sb . append ( _str ) ; } sb . append ( paramnames [ i ] ) ; } sb . append ( _str ) ; return sb . tostring ( ) ; }	creates a jsni method invocation expression .
public void dodoubleclickaction ( ) { dodoubleclickaction ( null ) ; }	launches an dialog allowing the user to pick a new name for this variable , where no constraints are placed on the name .
public static node serializableinstance ( ) { return new graphnode ( _str ) ; }	generates a simple exemplar of this class to test serialization .
protected void droptables ( list < string > droptablenames , sqlitedatabase db ) { if ( droptablenames != null && ! droptablenames . isempty ( ) ) { string [ ] droptablesqls = new string [ droptablenames . size ( ) ] ; for ( int i = _num ; i < droptablesqls . length ; i ++ ) { droptablesqls [ i ] = generatedroptablesql ( droptablenames . get ( i ) ) ; } execute ( droptablesqls , db ) ; } }	drop the tables by the passing table name .
private segment createdisksegment ( segmentdescriptor descriptor ) { file segmentfile = segmentfile . createsegmentfile ( name , storage . directory ( ) , descriptor . id ( ) , descriptor . version ( ) ) ; buffer buffer = filebuffer . allocate ( segmentfile , math . min ( default_buffer_size , descriptor . maxsegmentsize ( ) ) , integer . max_value ) ; descriptor . copyto ( buffer ) ; segment segment = new segment ( new segmentfile ( segmentfile ) , buffer . slice ( ) , descriptor , createindex ( descriptor ) , new offsetpredicate ( ) , serializer . clone ( ) , this ) ; logger . debug ( _str , segment ) ; return segment ; }	creates a new segment .
public boolean exists ( string email ) { for ( person person : people ) { if ( email . equals ( person . getemail ( ) ) ) { return _bool ; } } return _bool ; }	given an email checks if the person exists in the manager .
private double maxignorenan ( double a , double b ) { if ( double . isnan ( a ) ) { return b ; } if ( double . isnan ( b ) ) { return a ; } else { return math . max ( a , b ) ; } }	a function to find the maximum of two values , but ignoring any double.
public void crabdowndirblockformodification ( blockid blk ) { locktbl . xlock ( blk , txnum ) ; writenindexblks . add ( blk ) ; }	sets exclusive lock on the directory block when crabbing down for modification .
private static void removereferencetoconnection ( final httpconnectionwithreference connection ) { synchronized ( reference_to_connection_source ) { reference_to_connection_source . remove ( connection . reference ) ; } }	removes the reference being stored for the given connection.
public boolean matchesword ( ) { return ! isempty ( ) && character . isletterordigit ( queue . charat ( pos ) ) ; }	test if the queue matches a word character ( letter or digit ) .
public vacuumenvironment ( ) { random r = new random ( ) ; envstate = new vacuumenvironmentstate ( _num == r . nextint ( _num ) ? locationstate . clean : locationstate . dirty , _num == r . nextint ( _num ) ? locationstate . clean : locationstate . dirty ) ; }	constructs a vacuum environment with two locations , in which dirt is placed at random .
public void generate ( batchenvironment env , classdefinition cdef , file destdir ) { remoteclass remoteclass = remoteclass . forclass ( env , cdef ) ; if ( remoteclass == null ) return ; rmigenerator gen ; try { gen = new rmigenerator ( env , cdef , destdir , remoteclass , version ) ; } catch ( classnotfound e ) { env . error ( _num , _str , e . name ) ; return ; } gen . generate ( ) ; }	generate the source files for the stub and / or skeleton classes needed by rmi for the given remote implementation class .
public baseviewholder addonlongclicklistener ( int viewid ) { itemchildlongclickviewids . add ( viewid ) ; return this ; }	add long click view id.
public void remove ( final creaturerespawnpoint point ) { respawnpoints . remove ( point ) ; }	remove a creature respawn point from the zone .
public photo ( file d , file f ) throws ioexception , numberformatexception { extendedexifinterface exif = new extendedexifinterface ( f . tostring ( ) ) ; string lonstr = exif . getattribute ( exifinterface . tag_gps_longitude ) ; if ( lonstr == null ) { throw new ioexception ( _str ) ; } float lonf = converttodegree ( lonstr ) ; string lonref = exif . getattribute ( exifinterface . tag_gps_longitude_ref ) ; if ( lonref != null && ! lonref . equals ( _str ) ) { lonf = - lonf ; } float latf = converttodegree ( exif . getattribute ( exifinterface . tag_gps_latitude ) ) ; string latref = exif . getattribute ( exifinterface . tag_gps_latitude_ref ) ; if ( latref != null && ! latref . equals ( _str ) ) { latf = - latf ; } lat = ( int ) ( latf * _num ) ; lon = ( int ) ( lonf * _num ) ; log . d ( _str , _str + lat + _str + lon ) ; ref = d . getabsolutepath ( ) + _str + f . getname ( ) ; string dir = exif . getattribute ( extendedexifinterface . tag_gps_img_direction ) ; if ( dir != null ) { direction = ( int ) double . parsedouble ( dir ) ; directionref = exif . getattribute ( extendedexifinterface . tag_gps_img_direction_ref ) ; log . d ( _str , _str + dir + _str + direction + _str + directionref ) ; } }	create a bug from an osb gpx xml wpt element .
public static long bytestolong ( final byte [ ] bytes ) { final bytebuffer buffer = bytebuffer . allocate ( _num ) ; buffer . put ( bytes , _num , _num ) ; buffer . flip ( ) ; return buffer . getlong ( ) ; }	converts an array of 8 bytes into a long .
protected int unicodeescapelexer ( int c ) throws ioexception { int ret = _num ; c = in . read ( ) ; code . clear ( ) ; try { for ( int i = _num ; i < _num ; i ++ ) { c = in . read ( ) ; if ( isendoffile ( c ) || isendofline ( c ) ) { throw new numberformatexception ( _str ) ; } code . append ( ( char ) c ) ; } ret = integer . parseint ( code . tostring ( ) , _num ) ; } catch ( numberformatexception e ) { throw new ioexception ( _str + getlinenumber ( ) + _str + code . tostring ( ) + _str + e . tostring ( ) ) ; } return ret ; }	decodes unicode escapes . interpretation of " \ \ uxxxx " escape sequences where xxxx is a hex - number .
@ override public void mouseentered ( mouseevent evt ) { delegate . mousemoved ( evt ) ; }	pass mouseevent straight through to delegate.
public static string removeformatting ( string line ) { int length = line . length ( ) ; stringbuilder buffer = new stringbuilder ( ) ; for ( int i = _num ; i < length ; i ++ ) { char ch = line . charat ( i ) ; if ( ch != _str && ch != _str && ch != _str && ch != _str ) buffer . append ( ch ) ; } return buffer . tostring ( ) ; }	remove formatting from a line of irc text .
public void testnegposfirstshorter ( ) { string numa = _str ; string numb = _str ; string res = _str ; biginteger anumber = new biginteger ( numa ) ; biginteger bnumber = new biginteger ( numb ) ; biginteger result = anumber . xor ( bnumber ) ; asserttrue ( res . equals ( result . tostring ( ) ) ) ; }	xor for two negative numbers ; the first is shorter.
public void print ( ) { object [ ] iterchargingtimes = chargingtimes . toarray ( ) ; arrays . sort ( iterchargingtimes ) ; for ( int i = _num ; i < iterchargingtimes . length ; i ++ ) { chargelog curitem = ( chargelog ) iterchargingtimes [ i ] ; curitem . print ( ) ; } }	just prints out sorted after the time ( starting with 0 : 00 ) note : this is not the order in which the charging happened .
public boolean isempty ( ) { return rdns . isempty ( ) ; }	determines whether this ldap name is empty.
private void writelocalcsv ( medtronicsensorrecord mostrecentdata , context context ) { try { if ( mostrecentdata == null || mostrecentdata . bgvalue == null ) log . debug ( _str ) ; else log . debug ( _str + mostrecentdata . bgvalue ) ; objectoutputstream oos = new objectoutputstream ( new fileoutputstream ( new file ( context . getfilesdir ( ) , _str ) ) ) ; oos . writeobject ( mostrecentdata ) ; oos . flush ( ) ; oos . close ( ) ; } catch ( exception e ) { log . e ( tag , _str , e ) ; log . error ( _str , e ) ; } }	this method saves a file with the last record read from the device.
public serviceconfig createorganizationconfig ( string orgname , map attrs ) throws smsexception , ssoexception { validatessm ( ) ; serviceschemaimpl ss = ssm . getschema ( schematype . organization ) ; if ( ss == null ) { string [ ] args = { servicename } ; throw ( new smsexception ( iumsconstants . ums_bundle_name , _str , args ) ) ; } string orgdn = dnmapper . orgnametodn ( orgname ) ; createserviceconfig . checkbasenodesfororg ( token , orgdn , servicename , version ) ; string orgdn = scm . constructserviceconfigdn ( smsutils . default , createserviceconfig . org_config_node , orgdn ) ; try { cachedsmsentry centry = cachedsmsentry . getinstance ( token , orgdn ) ; if ( centry . isdirty ( ) ) { centry . refresh ( ) ; } if ( centry . isnewentry ( ) ) { createserviceconfig . createsubconfigentry ( token , orgdn , ss , null , null , attrs , orgname ) ; if ( servicemanager . iscoexistencemode ( ) ) { string smsdn = dnmapper . orgnametodn ( orgname ) ; orgconfigviaamsdk amsdk = new orgconfigviaamsdk ( token , dnmapper . realmnametoamsdkname ( smsdn ) , smsdn ) ; amsdk . assignservice ( servicename ) ; } } else if ( attrs != null && ! attrs . isempty ( ) ) { serviceconfig sc = getorganizationconfig ( orgname , null ) ; sc . setattributes ( attrs ) ; } } catch ( servicealreadyexistsexception slee ) { } return ( getorganizationconfig ( orgname , null ) ) ; }	creates organization configuration for the default instance of the service given configuration attributes .
public void deleteauthenticationdomain ( string realm , string cotname ) throws amconsoleexception { string [ ] param = { realm , cotname } ; logevent ( _str , param ) ; try { circleoftrustmanager manager = getcircleoftrustmanager ( ) ; manager . deletecircleoftrust ( realm , cotname ) ; logevent ( _str , param ) ; } catch ( cotexception e ) { string strerror = geterrorstring ( e ) ; string [ ] paramsex = { realm , cotname , strerror } ; logevent ( _str , paramsex ) ; throw new amconsoleexception ( strerror ) ; } }	deletes an authentication domain ( circle of trust ) within a given realm .
protected void addsourcecoderemark ( testsolution testsolution , element element , string messagecode , evidenceelement evidenceelement ) { if ( evidenceelement != null ) { collection < evidenceelement > evidenceelementlist = new arraylist < > ( ) ; evidenceelementlist . add ( evidenceelement ) ; processremarkservice . addsourcecoderemarkonelement ( testsolution , element , messagecode , evidenceelementlist ) ; } else { processremarkservice . addsourcecoderemarkonelement ( testsolution , element , messagecode ) ; } }	add a sourcecoderemark on the given element with a preset evidence element collection.
void eventpremodify ( actiontype type , long position , boolean issingle ) { if ( type != currentactiontype || ! issingle || system . currenttimemillis ( ) - previoustime > merge_time || ( type == actiontype . insert || type == actiontype . overwrite ) && actionexclusiveend ( ) != position || type == actiontype . delete && actionposition ( ) != position && actionposition ( ) - _num != position ) { startaction ( type , issingle ) ; } else { isbackspace = actionposition ( ) > position ; } if ( issingle && type == actiontype . insert ) { updatenewrange ( position ) ; previoustime = system . currenttimemillis ( ) ; } }	user event : single / block delete / insert / overwrite . called before any change has been done.
void saveasync ( documententity entity , consumer < documententity > callback ) throws executeasyncqueryexception , unsupportedoperationexception ;	saves an entity asynchronously.
public boolean marksupported ( ) { return finputstream . marksupported ( ) ; }	tell whether this stream supports the mark ( ) operation .
public string resolveparentrelationname ( string parentname , object parent , string childname , object child ) { return parentname ; }	follow the most conventional pattern , returns the parentname unchanged .
public bytecolumn ( int nrows , int capacity , byte defaultvalue ) { super ( byte . class , new byte ( defaultvalue ) ) ; if ( capacity < nrows ) { throw new illegalargumentexception ( _str ) ; } m_values = new byte [ capacity ] ; arrays . fill ( m_values , defaultvalue ) ; m_size = nrows ; }	create a new intcolumn .
public relnode convertselect ( sqlselect select , boolean top ) { final sqlvalidatorscope selectscope = validator . getwherescope ( select ) ; final blackboard bb = createblackboard ( selectscope , null , top ) ; convertselectimpl ( bb , select ) ; return bb . root ; }	converts a select statement ' s parse tree into a relational expression .
public static object executescript ( string filepath , string functionname , map < string , object > context ) { return executescript ( filepath , functionname , context , new object [ ] { context } ) ; }	executes the script at the specified location and returns the result .
public xerceshtml2documentbuilderfactory ( documentbuildersetting [ ] settings ) throws domtestincompatibleexception { super ( settings ) ; try { classloader classloader = classloader . getsystemclassloader ( ) ; class htmlbuilderclass = classloader . loadclass ( _str ) ; htmlbuilderconstructor = htmlbuilderclass . getconstructor ( no_classes ) ; gethtmldocumentmethod = htmlbuilderclass . getmethod ( _str , no_classes ) ; class htmldomimpl = classloader . loadclass ( _str ) ; method method = htmldomimpl . getmethod ( _str , no_classes ) ; domimpl = ( domimplementation ) method . invoke ( null , no_objects ) ; class saxfactoryclass = classloader . loadclass ( _str ) ; factory = ( saxparserfactory ) saxfactoryclass . newinstance ( ) ; } catch ( invocationtargetexception ex ) { throw new domtestincompatibleexception ( ex . gettargetexception ( ) , null ) ; } catch ( exception ex ) { throw new domtestincompatibleexception ( ex , null ) ; } if ( settings != null ) { for ( int i = _num ; i < settings . length ; i ++ ) { } } try { factory . newsaxparser ( ) ; } catch ( parserconfigurationexception ex ) { throw new domtestincompatibleexception ( ex , null ) ; } catch ( saxexception ex ) { throw new domtestincompatibleexception ( ex , null ) ; } }	creates a implementation of domtestdocumentbuilderfactory using org.
private static string formatsamplerate ( int rate ) { return mhz_formatter . format ( ( double ) rate / _num ) ; }	formats the rate in hertz for display as megahertz.
public final boolean isclosed ( ) { return closed . get ( ) ; }	checks whether this closeableiteration has been closed .
void start ( ) { this . running = _bool ; thread thread = new thread ( this , _str + hashcode ( ) ) ; thread . setdaemon ( _bool ) ; thread . start ( ) ; }	start the network listening thread .
typesimplifier ( types typeutils , string packagename , set < typemirror > types , typemirror base ) { this . typeutils = typeutils ; set < typemirror > typesplusbase = new typemirrorset ( types ) ; if ( base != null ) { typesplusbase . add ( base ) ; } set < typemirror > referenced = referencedclasstypes ( typeutils , typesplusbase ) ; set < typemirror > defined = nonprivatedeclaredtypes ( typeutils , base ) ; this . imports = findimports ( typeutils , packagename , referenced , defined ) ; }	makes a new simplifier for the given package and set of types .
public static byte [ ] escape ( final byte [ ] bytes ) { final byte [ ] temp = new byte [ _num * bytes . length ] ; int currentposition = _num ; for ( final byte b : bytes ) { if ( b == escape_char ) { temp [ currentposition ++ ] = escape_char ; temp [ currentposition ++ ] = replacement_char ; } else if ( b == delimiter ) { temp [ currentposition ++ ] = escape_char ; temp [ currentposition ++ ] = escape_char ; } else { temp [ currentposition ++ ] = b ; } } final byte [ ] escaped = new byte [ currentposition ] ; system . arraycopy ( temp , _num , escaped , _num , currentposition ) ; return escaped ; }	escapes the provided string so that it no longer contains the constants.
public final native string name ( ) ;	human readable name of the mode , such as " c + + " .
public static string tostring ( document hostdoc ) throws ioexception { try { stringwriter out = new stringwriter ( ) ; domsource domsource = new domsource ( hostdoc ) ; streamresult streamresult = new streamresult ( out ) ; transformerfactory tf = transformerfactory . newinstance ( ) ; transformer serializer = tf . newtransformer ( ) ; serializer . setoutputproperty ( outputkeys . encoding , enc . name ( ) ) ; serializer . setoutputproperty ( outputkeys . method , _str ) ; serializer . setoutputproperty ( outputkeys . indent , _str ) ; serializer . setoutputproperty ( outputkeys . doctype_public , htmldomutil . html_strict ) ; serializer . transform ( domsource , streamresult ) ; return out . tostring ( ) ; } catch ( transformerexception e ) { ioexception r = new ioexception ( _str ) ; r . initcause ( e ) ; throw r ; } }	convert a document to a string , assuming later encoding to utf - 8 .
public mongoclient clientformembers ( serveraddress ... seeds ) { list < serveraddress > addresses = new arraylist < > ( ) ; for ( serveraddress seedaddress : seeds ) { if ( seedaddress != null ) addresses . add ( seedaddress ) ; } return clientformembers ( addresses ) ; }	obtain a client connection to the replica set or cluster.
public static boolean stringtobooleanvalue ( string str ) throws expressionexception { str = stringutil . tolowercase ( str . trim ( ) ) ; if ( str . equals ( _str ) || str . equals ( _str ) ) return _bool ; else if ( str . equals ( _str ) || str . equals ( _str ) ) return _bool ; throw new casterexception ( _str + str + _str ) ; }	cast a string to a boolean value ( primitive value type ).
public boolean hasmorework ( ) { return ! worklist . isempty ( ) ; }	are there more work list items ?.
protected synchronized void enginesetseed ( byte [ ] seed ) { if ( seed == null ) { throw new nullpointerexception ( _str ) ; } if ( state == next_bytes ) { system . arraycopy ( copies , hashcopy_offset , this . seed , hash_offset , extraframe_offset ) ; } state = set_seed ; if ( seed . length != _num ) { updateseed ( seed ) ; } }	changes current seed by supplementing a seed argument to the current seed , if this already set ; the argument is used as first seed otherwise.
public void generateclassfile ( outputstream os ) { classwriter cw = new sootasmclasswriter ( classwriter . compute_frames ) ; cv = cw ; generatebytecode ( ) ; try { os . write ( cw . tobytearray ( ) ) ; } catch ( ioexception e ) { throw new runtimeexception ( _str , e ) ; } }	outputs the bytecode generated as a class file.
private static boolean usecompactfontformat ( map < string , object > args , int compatibilityversion ) { string value = ( string ) args . get ( embedascff ) ; boolean usecff = _bool ; if ( compatibilityversion < mxmlconfiguration . version_4_0 ) usecff = _bool ; if ( value != null ) { usecff = boolean . parseboolean ( value . trim ( ) ) ; } return usecff ; }	the cff flag determines whether font information should be embedded in the compact font format using swf tag definefont4 .
public static void main ( string [ ] args ) { new generatortester ( args ) ; }	test the image generator .
private string mosesize ( string feature ) { if ( joshuaconfiguration . moses ) { if ( feature . startswith ( _str ) || feature . startswith ( _str ) ) return feature . replace ( _str , _str ) ; } return feature ; }	moses requires the pattern.
public static int calctextheight ( paint paint , string demotext ) { rect r = new rect ( ) ; paint . gettextbounds ( demotext , _num , demotext . length ( ) , r ) ; return r . height ( ) ; }	calculates the approximate height of a text , depending on a demo text avoid repeated calls ( e.
private void checkshutdown ( ) { synchronized ( mux ) { if ( isbeingshutdown ) throw new rejectedexecutionexception ( _str ) ; } }	checks if service is being shutdown .
private static final void checkqueuefordependenciesandexecuteunblockedtasks ( ) { list < progressthread > toremove = new linkedlist < > ( ) ; synchronized ( lock ) { for ( progressthread pg : queuedthreads ) { if ( ! pg . isblockedbydependencies ( ) ) { if ( ! pg . iswaiting ( ) ) { toremove . add ( pg ) ; executor . execute ( pg . makewrapper ( ) ) ; } } } } for ( progressthread pg : toremove ) { synchronized ( lock ) { queuedthreads . remove ( pg ) ; } } }	checks the currently queued tasks if there are ones which are no longer blocked by dependencies and executes them .
private static short callshortmethodv ( jnienvironment env , int objjref , int methodid , address argaddress ) throws exception { if ( tracejni ) vm . syswrite ( _str ) ; runtimeentrypoints . checkjnicountdowntogc ( ) ; try { object obj = env . getjniref ( objjref ) ; object returnobj = jnihelpers . invokewithvararg ( obj , methodid , argaddress , typereference . short , _bool ) ; return reflection . unwrapshort ( returnobj ) ; } catch ( throwable unexpected ) { if ( tracejni ) unexpected . printstacktrace ( system . err ) ; env . recordexception ( unexpected ) ; return _num ; } }	callshortmethodv : invoke a virtual method that returns a short value.
public void fireindexedpropertychange ( string propertyname , int index , boolean oldvalue , boolean newvalue ) { if ( oldvalue != newvalue ) { fireindexedpropertychange ( propertyname , index , boolean . valueof ( oldvalue ) , boolean . valueof ( newvalue ) ) ; } }	fires a property change of a boolean property with the given name.
protected void removemarkers ( ) { for ( int i = markerimage . size ( ) ; i > _num ; i -- ) { locoicon il = markerimage . get ( i - _num ) ; if ( ( il != null ) && ( il . isactive ( ) ) ) { markerimage . remove ( i - _num ) ; il . remove ( ) ; il . dispose ( ) ; setdirty ( _bool ) ; } } super . removemarkers ( ) ; repaint ( ) ; }	remove marker icons from panel.
public ielementtype capturestring ( ) { charsequence buffer = getbuffer ( ) ; int currentposition = gettokenend ( ) ; settokenstart ( currentposition ) ; int bufferend = getbufferend ( ) ; char openquote = buffer . charat ( currentposition ) ; char closequote = regexblock . getquoteclosechar ( openquote ) ; boolean quotesdiffer = openquote != closequote ; boolean isescaped = _bool ; int quotesdepth = _num ; currentposition ++ ; while ( currentposition < bufferend ) { char currentchar = buffer . charat ( currentposition ) ; if ( ! isescaped && quotesdepth == _num && currentchar == closequote ) { break ; } if ( ! isescaped && quotesdiffer ) { if ( currentchar == openquote ) { quotesdepth ++ ; } else if ( currentchar == closequote ) { quotesdepth -- ; } } isescaped = ! isescaped && currentchar == _str ; currentposition ++ ; } if ( currentposition < bufferend ) { currentposition ++ ; } settokenend ( currentposition ) ; perlstringlexer stringlexer = getstringlexer ( ) ; popstate ( ) ; preparsedtokenslist . addall ( lexcurrenttoken ( stringlexer ) ) ; return getpreparsedtoken ( ) ; }	captures string token from current position according to the current lexical state.
public static string tolocalizedinteger ( long value ) { return number_format0 . format ( value ) ; }	this static method converts the passed in number into a localizable representation of an integer , with digit grouping using locale dependant separators .
public void testparseclienthandshake ( ) throws exception { for ( int splitpos = _num ; splitpos < _num ; splitpos ++ ) { log . info ( _str + splitpos ) ; bytebuffer tmp = clienthandshakepacket ( ) ; bytebuffer [ ] split = split ( tmp , splitpos ) ; gridniosession ses = new mockniosession ( ) ; ses . addmeta ( marshaller . ordinal ( ) , new gridclientoptimizedmarshaller ( ) ) ; gridtcprestparser parser = new gridtcprestparser ( _bool ) ; collection < gridclientmessage > lst = new arraylist < > ( _num ) ; for ( bytebuffer buf : split ) { gridclientmessage r ; while ( buf . hasremaining ( ) && ( r = parser . decode ( ses , buf ) ) != null ) lst . add ( r ) ; asserttrue ( _str , buf . remaining ( ) == _num ) ; } assertequals ( _num , lst . size ( ) ) ; gridclienthandshakerequest req = ( gridclienthandshakerequest ) f . first ( lst ) ; assertnotnull ( req ) ; assertequals ( u . bytestoshort ( new byte [ ] { _num , _num } , _num ) , req . version ( ) ) ; } }	tests correct parsing of client handshake packets .
public void runtest ( ) throws throwable { document doc ; nodelist elementlist ; node namenode ; characterdata child ; string childdata ; doc = ( document ) load ( _str , _bool ) ; elementlist = doc . getelementsbytagname ( _str ) ; namenode = elementlist . item ( _num ) ; child = ( characterdata ) namenode . getfirstchild ( ) ; child . deletedata ( _num , _num ) ; childdata = child . getdata ( ) ; assertequals ( _str , _str , childdata ) ; }	runs the test case .
void checkframevalue ( final object value ) { if ( value == opcodes . top || value == opcodes . integer || value == opcodes . float || value == opcodes . long || value == opcodes . double || value == opcodes . null || value == opcodes . uninitialized_this ) { return ; } if ( value instanceof string ) { checkinternalname ( ( string ) value , _str ) ; return ; } if ( ! ( value instanceof label ) ) { throw new illegalargumentexception ( _str + value ) ; } else { usedlabels . add ( ( label ) value ) ; } }	checks a stack frame value .
public static template create ( string value ) { if ( settings . isfunction ( value ) ) { return new functionaltemplate ( value ) ; } if ( graph . isrelational ( value ) ) { try { return new relationaltemplate ( value ) ; } catch ( exception e ) { log . warning ( _str + value + _str ) ; return new stringtemplate ( value ) ; } } else if ( regextemplate . ispossibleregex ( value ) ) { try { if ( arithmetictemplate . isarithmeticexpression ( value ) ) { return new arithmetictemplate ( value ) ; } return new regextemplate ( value ) ; } catch ( patternsyntaxexception e ) { log . warning ( _str + value + _str ) ; return new stringtemplate ( value ) ; } } else { return new stringtemplate ( value ) ; } }	creates a new template based on the string value.
protected boolean customshouldtakefocus ( ) { if ( customarea instanceof label ) { return _bool ; } if ( customarea instanceof clabel ) { return ( customarea . getstyle ( ) & swt . no_focus ) > _num ; } return _bool ; }	return whether or not we should apply the workaround where we take focus for the default button or if that should be determined by the dialog.
public void init ( privatekey key ) { try { if ( signature != null ) { signature . initsign ( key ) ; } else if ( cipher != null ) { cipher . init ( cipher . encrypt_mode , key ) ; } } catch ( invalidkeyexception e ) { throw new alertexception ( alertprotocol . bad_certificate , new sslexception ( _str , e ) ) ; } }	initiate signature type by private key.
private map < string , list < zone > > selectzonesforinitiatorsandports ( networklite network , map < string , list < zone > > wwntozones , map < string , storageport > initiatorportsmap ) { map < string , list < zone > > filteredmap = new hashmap < string , list < zone > > ( ) ; zone zone = null ; list < zone > zones = null ; for ( string initiatorwwn : wwntozones . keyset ( ) ) { for ( string portwwn : initiatorportsmap . keyset ( ) ) { zone = _networkscheduler . selectexistingzoneforinitiatorport ( network , initiatorwwn , portwwn , wwntozones . get ( initiatorwwn ) ) ; if ( zone != null ) { zones = filteredmap . get ( initiatorwwn ) ; if ( zones == null ) { zones = new arraylist < > ( ) ; filteredmap . put ( initiatorwwn , zones ) ; } zones . add ( zone ) ; } } } return filteredmap ; }	given the map of all existing zones for a set on initiators and ports , this function selects the zones that should be used by vipr .
public static boolean isextension ( string filename , collection < string > extensions ) { if ( filename == null ) return _bool ; if ( extensions == null || extensions . isempty ( ) ) return indexofextension ( filename ) == - _num ; string fileext = getextension ( filename ) ; for ( string extension : extensions ) { if ( fileext . equals ( extension ) ) return _bool ; } return _bool ; }	checks whether the extension of the filename is one of those specified.
private void writejarpostresource ( element postresourceel , string path ) { postresourceel . setattribute ( _str , jar_resource_set ) ; postresourceel . setattribute ( _str , path . replace ( _str , _str ) ) ; }	write jar post resource.
public void closefile ( ) throws ioexception { file . close ( ) ; file = null ; }	close the file . the file may later be re - opened using openfile .
public typedeventlistener ( eventlistener < e > wrappedlistener , class < e > eventclass ) { this . eventclass = eventclass ; this . wrappedlistener = wrappedlistener ; }	constructs a new single typed event listener .
public static list < ? extends node > childnodelist ( node node ) { if ( node == null ) return null ; list < node > nodes = new linkedlist < node > ( ) ; do { if ( node . getnodetype ( ) == node . element_node || node . getnodetype ( ) == node . comment_node ) { nodes . add ( node ) ; } } while ( ( node = node . getnextsibling ( ) ) != null ) ; return nodes ; }	return a list of node objects that have the given name and are immediate children of the given element ; if name is null , all child elements will be included .
public static corleone context ( string jobcontext ) { if ( jobcontext == null || jobcontext . equals ( _str ) ) { throw new illegalargumentexception ( _str ) ; } contexts . clear ( ) ; contexts . add ( jobcontext ) ; return getinstance ( ) ; }	provides a corleone instance to work on the given context .
public static double info ( int counts [ ] ) { int total = _num ; double x = _num ; for ( int count : counts ) { x -= xlogx ( count ) ; total += count ; } return x + xlogx ( total ) ; }	computes entropy for an array of integers .
public void addmethod ( sootmethod m ) { checklevel ( signatures ) ; if ( m . isdeclared ( ) ) throw new runtimeexception ( _str + m . getname ( ) ) ; if ( subsigtomethods . get ( m . getnumberedsubsignature ( ) ) != null ) { throw new runtimeexception ( _str + m . getsubsignature ( ) + _str + this + _str ) ; } subsigtomethods . put ( m . getnumberedsubsignature ( ) , m ) ; methodlist . add ( m ) ; m . setdeclared ( _bool ) ; m . setdeclaringclass ( this ) ; }	adds the given method to this class .
private void addreplicationfactor ( operation op ) { op . addrequestheader ( operation . replication_quorum_header , operation . replication_quorum_header_value_all ) ; }	authorization related operations should take effect on all replicas , before they complete . this method adds a special header that sets the quorum level to all available nodes , avoiding a race where a client can reach a node that has not yet received latest authorization changes , even if it received success from this auth helper class.
private static frame showinitialsplash ( ) { frame splashframe = null ; image image = null ; url imageurl = getchosensplashurl ( ) ; if ( imageurl != null ) { try { image = imageio . read ( imageurl ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } if ( image != null ) { splashframe = awtsplashwindow . splash ( image ) ; } } return splashframe ; }	shows the initial splash window .
protected void decodelinesuffix ( pushbackinputstream instream , outputstream outstream ) throws ioexception { int c ; while ( _bool ) { c = instream . read ( ) ; if ( c == - _num ) { throw new cestreamexhausted ( ) ; } if ( c == _str ) { break ; } if ( c == _str ) { c = instream . read ( ) ; if ( ( c != _str ) && ( c != - _num ) ) { instream . unread ( c ) ; } break ; } } }	find the end of the line for the next operation . the following sequences are recognized as end - of - line cr , cr lf , or lf.
public void addtransaction ( sipservertransaction servertransaction ) throws ioexception { if ( isloggingenabled ( ) ) stacklogger . logdebug ( _str + servertransaction ) ; servertransaction . map ( ) ; addtransactionhash ( servertransaction ) ; }	add a new server transaction to the set of existing transactions.
private float spacing ( motionevent event ) { float x = event . getx ( _num ) - event . getx ( _num ) ; float y = event . gety ( _num ) - event . gety ( _num ) ; return ( float ) math . sqrt ( x * x + y * y ) ; }	determine the space between the first two fingers.
public boolean containspoly ( sootmethod method ) { return getmethod ( method ) != null ; }	search for polymorphic containment based on inheritance of receiver and arguments .
public jktagmapping ( final string sourceqname , final string targetqname , final jknamespace namespace ) { logger . info ( string . format ( _str , sourceqname , targetqname ) ) ; this . sourceqname = sourceqname ; this . targetqname = targetqname ; this . namespace = namespace ; this . auto = _bool ; }	instantiates a new jk tag mapping .
private void selectattributesetinstance ( ) { int m_warehouse_id = getm_warehouse_id ( ) ; int m_product_id = getm_product_id ( ) ; if ( m_product_id <= _num ) return ; mproduct product = mproduct . get ( getctx ( ) , m_product_id ) ; mwarehouse wh = mwarehouse . get ( getctx ( ) , m_warehouse_id ) ; string title = product . get_translation ( mproduct . columnname_name ) + _str + wh . get_translation ( mwarehouse . columnname_name ) ; pattributeinstance pai = new pattributeinstance ( m_frame , title , m_warehouse_id , _num , m_product_id , _num ) ; if ( pai . getm_attributesetinstance_id ( ) != - _num ) { fattrsetinstance_id . settext ( pai . getm_attributesetinstancename ( ) ) ; fattrsetinstance_id . setvalue ( new integer ( pai . getm_attributesetinstance_id ( ) ) ) ; } else { fattrsetinstance_id . setvalue ( integer . valueof ( _num ) ) ; } }	filter by attribute set instance.
private void ensurefileopen ( ) { if ( savingdisabled ) { log . e ( tag , _str ) ; return ; } if ( savefilestream != null ) return ; file savefile = new file ( ctx . getfilesdir ( ) , savefile ) ; try { fileoutputstream fileoutput = null ; dataoutputstream out = null ; if ( savefile . exists ( ) ) { fileoutput = ctx . openfileoutput ( savefile , context . mode_append ) ; out = new dataoutputstream ( new bufferedoutputstream ( fileoutput ) ) ; } else { fileoutput = ctx . openfileoutput ( savefile , context . mode_private ) ; out = new dataoutputstream ( new bufferedoutputstream ( fileoutput ) ) ; out . writeint ( trackpoint . format_version ) ; savedtrackpoints = _num ; } savefilestream = out ; } catch ( exception e ) { marksavingbroken ( _str , e ) ; } }	opens the savefilestream if necessary.
public void test_canonicalizingcache ( ) { final properties properties = getproperties ( ) ; properties . setproperty ( abstracttransactionservice . options . min_release_age , _str ) ; final journal journal = new journal ( properties ) ; try { final long committime0 = journal . commit ( ) ; asserttrue ( committime0 != _num ) ; final icommitrecord commitrecord0 = journal . getcommitrecord ( committime0 ) ; assertequals ( commitrecord0 , journal . getcommitrecord ( ) ) ; journal . write ( bytebuffer . wrap ( new byte [ ] { _num , _num , _num } ) ) ; final long committime1 = journal . commit ( ) ; asserttrue ( committime1 != _num ) ; final icommitrecord commitrecord1 = journal . getcommitrecord ( committime1 ) ; assertequals ( commitrecord1 , journal . getcommitrecord ( ) ) ; asserttrue ( commitrecord0 == journal . getcommitrecord ( committime1 - _num ) ) ; asserttrue ( commitrecord1 == journal . getcommitrecord ( committime1 + _num ) ) ; asserttrue ( commitrecord1 == journal . getcommitrecord ( committime1 + _num ) ) ; } finally { journal . destroy ( ) ; } }	test verifies that exact match and find always return the same reference for the same commit record ( at least as long as the test holds a hard reference to the commit record of interest ) .
public static void print ( object x ) { out . print ( x ) ; out . flush ( ) ; }	prints an object to standard output and flushes standard output .
@ override public void stop ( runnable arg0 ) { stop ( ) ; arg0 . run ( ) ; }	smart lifecycle stop implementation.
protected int read ( inputstream inputstream , byte [ ] buffer , char divider ) throws ioexception { int index = _num ; do { byte readbyte = ( byte ) ( _num & inputstream . read ( ) ) ; if ( readbyte == - _num || readbyte == ( byte ) divider ) { return index ; } buffer [ index ] = readbyte ; index ++ ; } while ( index < buffer . length ) ; return index ; }	reads bytes from a given file reader until either a certain character is read , the buffer is completely filled or the end of file is reached .
private static void generategraphfile ( transmeta transmeta , string graphfile ) throws graphgeneratorexception { dataoutputstream dos = null ; try { string xml = transmeta . getxml ( ) ; dos = new dataoutputstream ( new fileoutputstream ( new file ( graphfile ) ) ) ; dos . write ( xml . getbytes ( carboncommonconstants . default_charset ) ) ; } catch ( kettleexception kettelexception ) { throw new graphgeneratorexception ( _str , kettelexception ) ; } catch ( filenotfoundexception e ) { throw new graphgeneratorexception ( _str , e ) ; } catch ( unsupportedencodingexception ue ) { throw new graphgeneratorexception ( _str , ue ) ; } catch ( ioexception ioe ) { throw new graphgeneratorexception ( _str , ioe ) ; } finally { if ( dos != null ) { try { dos . close ( ) ; } catch ( ioexception e ) { e . getmessage ( ) ; } } } }	generate the graph file.
public static void closeoutputstream ( outputstream stream , string tag ) { if ( stream != null ) { try { stream . close ( ) ; } catch ( ioexception e ) { log . e ( tag , _str + e ) ; } } }	close a bytearrayoutputstream passed in .
public void addpropertychangelistener ( string propertyname , propertychangelistener in_pcl ) { beancontextchildsupport . addpropertychangelistener ( propertyname , in_pcl ) ; }	method for beancontextchild interface.
public boolean isexpired ( ) { return this . ttl < system . currenttimemillis ( ) ; }	true if the entry is expired .
private void loaduserinfointoactionbar ( ) { if ( ! textutils . isempty ( mwithuserimage ) ) { utils . loadcircularimage ( getactivity ( ) , mwithimageview , mwithuserimage , avatarbitmaptransformation . avatarsize . normal ) ; } }	loads the user image into the action bar profile pic.
public static direction directionforarrowkey ( keyevent e ) { int index = math . max ( _num , math . min ( e . getkeycode ( ) , keyevent . vk_down ) - keyevent . vk_left ) ; return direction . values ( ) [ index ] ; }	returns a direction corresponding to the specified arrow key.
public tracegraph ( collection < span > spans ) { this . spansbyparent = new spansbyparent ( spans ) ; this . spansbytracerid = new spansbytracerid ( spans ) ; }	create a new tracegraph.
public boolean ispersistent ( ) { return m_persist ; }	indicates if the tooltip will stay persistent on the screen to support interaction within the tooltip component .
public static java . util . date todate ( string monthstr , string daystr , string yearstr , string hourstr , string minutestr , string secondstr ) { int month , day , year , hour , minute , second ; try { month = integer . parseint ( monthstr ) ; day = integer . parseint ( daystr ) ; year = integer . parseint ( yearstr ) ; hour = integer . parseint ( hourstr ) ; minute = integer . parseint ( minutestr ) ; second = integer . parseint ( secondstr ) ; } catch ( exception e ) { return null ; } return todate ( month , day , year , hour , minute , second ) ; }	makes a date from separate strings for month , day , year , hour , minute , and second .
protected void handlemesosfailure ( string taskid ) { int attempt = taskutils . getattemptfortaskid ( taskid ) ; basecontainer container = containersinfo . get ( taskutils . getcontainerindexfortaskid ( taskid ) ) ; boolean hasattemptsleft = attempt < container . retries ; if ( hasattemptsleft ) { log . warning ( string . format ( _str , container . name , attempt + _num ) ) ; string newtaskid = taskutils . gettaskid ( container . name , attempt + _num ) ; schedulenewtask ( newtaskid ) ; } else { log . severe ( _str + attempt ) ; } }	restart a failed task unless exceeding the retires limitation.
public static file findconfiginworkingdirectory ( ) { for ( final string suffix : suffixes ) { final file configfile = new file ( system . getproperty ( _str ) , prefix + suffix ) ; if ( configfile . isfile ( ) ) { return configfile ; } } return null ; }	finds a log4j configuration file in the current working directory.
protected boolean attempttoaddword ( word word ) { double additionallength = word . getwordwidth ( ) ; additionallength += ! words . isempty ( ) ? spacesize : _num ; if ( currentlinelength + additionallength <= maxlength || maxlength == - _num ) { words . add ( word ) ; currentlinelength += additionallength ; return _bool ; } else { return _bool ; } }	attempt to add a word to the line.
@ override public boolean onpreferenceclick ( preference preference ) { if ( preference == mplayexample ) { getsampletext ( ) ; return _bool ; } return _bool ; }	called when mplayexample is clicked.
public void readwwwauthenticateheader ( string header ) { if ( header != null ) { misdigestauthentication = header . startswith ( httpdigestmd5authentication . http_digest_schema ) ; if ( ! misdigestauthentication ) { return ; } string value = getvalue ( header , _str ) ; mdigest . setrealm ( value ) ; value = getvalue ( header , _str ) ; mdigest . setopaque ( value ) ; value = getvalue ( header , _str ) ; mdigest . setqop ( value ) ; value = getvalue ( header , _str ) ; mdigest . setnextnonce ( value ) ; } }	read the www - authenticate header.
public static string valueof ( boolean value ) { return value != null ? string . valueof ( value ) : null ; }	returns the string value of the given boolean.
public void testsendreceive ( ) throws exception { messages . clear ( ) ; for ( int i = _num ; i < data . length ; i ++ ) { message message = session . createtextmessage ( data [ i ] ) ; message . setstringproperty ( _str , data [ i ] ) ; message . setintproperty ( _str , i ) ; if ( verbose ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str + message + _str + data [ i ] ) ; } } sendtoproducer ( producer , producerdestination , message ) ; messagesent ( ) ; } assertmessagesarereceived ( ) ; log . info ( _str + data . length + _str ) ; }	sends and consumes the messages .
public void addlive ( boolean live ) { query . append ( _str + live ) ; }	adds + live to the query.
public static string tostring ( uri uri , charset encoding ) throws ioexception { return tostring ( uri . tourl ( ) , charsets . tocharset ( encoding ) ) ; }	gets the contents at the given uri .
public boolean exists ( string key ) { return exists ( key , _bool ) ; }	check existence of config section element.
public allocationsite ( int line , int column ) { synchronized ( sites ) { this . id = sites . size ( ) ; sites . add ( this ) ; } this . line = line ; this . column = column ; }	create an allocation site for a given source code line / column .
public boolean drawimage ( image img , affinetransform xform , imageobserver obs ) { return mgraphics . drawimage ( img , xform , obs ) ; }	draws an image , applying a transform from image space into user space before drawing.
public final static int parseint ( char [ ] digitchars , int offset , int len ) { int num = digitchars [ offset ] - _str ; len += offset ; if ( ++ offset < len ) { num = ( num * _num ) + ( digitchars [ offset ] - _str ) ; if ( ++ offset < len ) { num = ( num * _num ) + ( digitchars [ offset ] - _str ) ; if ( ++ offset < len ) { num = ( num * _num ) + ( digitchars [ offset ] - _str ) ; if ( ++ offset < len ) { num = ( num * _num ) + ( digitchars [ offset ] - _str ) ; if ( ++ offset < len ) { num = ( num * _num ) + ( digitchars [ offset ] - _str ) ; if ( ++ offset < len ) { num = ( num * _num ) + ( digitchars [ offset ] - _str ) ; if ( ++ offset < len ) { num = ( num * _num ) + ( digitchars [ offset ] - _str ) ; if ( ++ offset < len ) { num = ( num * _num ) + ( digitchars [ offset ] - _str ) ; } } } } } } } } return num ; }	fast method for parsing integers that are known to fit into regular 32 - bit signed int type . this means that length is between 1 and 9 digits ( inclusive ) < p > note : public to let unit tests call it.
public activitymonitorsample ( ) { initcomponents ( ) ; owneraradio . setactioncommand ( _str ) ; ownerbradio . setactioncommand ( _str ) ; ownercradio . setactioncommand ( _str ) ; indicatora . setactivityowner ( _str ) ; indicatorb . setactivityowner ( _str ) ; indicatorc . setactivityowner ( _str ) ; jactivitywindow . getinstance ( ) ; }	creates new form activitymonitorsample.
public static latlon [ ] greatcircleextremelocations ( latlon location , angle azimuth ) { if ( location == null ) { throw new illegalargumentexception ( _str ) ; } if ( azimuth == null ) { throw new illegalargumentexception ( _str ) ; } double lat0 = location . getlatitude ( ) . radians ; double az = azimuth . radians ; double tandistance = - math . tan ( lat0 ) / math . cos ( az ) ; double distance = math . atan ( tandistance ) ; angle extremedistance1 = angle . fromradians ( distance + ( math . pi / _num ) ) ; angle extremedistance2 = angle . fromradians ( distance - ( math . pi / _num ) ) ; return new latlon [ ] { greatcircleendposition ( location , azimuth , extremedistance1 ) , greatcircleendposition ( location , azimuth , extremedistance2 ) } ; }	returns two locations with the most extreme latitudes on the great circle with the given starting location and azimuth .
private void initcheckbox ( checkboxpreference checkbox , boolean checked , boolean enabled ) { checkbox . setchecked ( checked ) ; checkbox . setenabled ( enabled ) ; }	initialize the service activation checkbox.
private void paintcheckiconenabledandselected ( graphics2d g , int width , int height ) { shape s = shapegenerator . createcheckmark ( _num , _num , width , height ) ; g . setpaint ( iconenabledselected ) ; g . fill ( s ) ; }	paint the check mark in enabled state .
public static int findurisplitindex ( string uri ) { int urilength = uri . length ( ) ; int idx = urilength - _num ; for ( ; idx >= _num ; idx -- ) { if ( ! turtleutil . isnamechar ( uri . charat ( idx ) ) ) { break ; } } idx ++ ; for ( ; idx < urilength ; idx ++ ) { if ( turtleutil . isnamestartchar ( uri . charat ( idx ) ) ) { break ; } } if ( ! turtleutil . isnameendchar ( uri . charat ( urilength - _num ) ) ) { return - _num ; } if ( idx > _num && idx < urilength ) { return idx ; } return - _num ; }	tries to find an index where the supplied uri can be split into a namespace and a local name that comply with the serialization constraints of the turtle format .
private void writelog ( string cmd ) { try { if ( m_writer == null ) { file file = file . createtempfile ( _str , _str ) ; m_writer = new printwriter ( new filewriter ( file ) ) ; log . info ( file . tostring ( ) ) ; } m_writer . println ( cmd ) ; m_writer . flush ( ) ; } catch ( exception e ) { log . severe ( e . tostring ( ) ) ; } }	write to file log.
public void reload ( string why ) { mfullphotopaths = mrootdir . list ( mediascanner . jpg_filename_filter ) ; if ( ( mfullphotopaths != null ) && ( mfullphotopaths . length == _num ) ) { mfullphotopaths = null ; log . i ( global . log_context , mdebugprefix + why + _str + mrootdir + _str + _num ) ; } else if ( mfullphotopaths != null ) { if ( global . debugenabled ) { log . i ( global . log_context , mdebugprefix + why + _str + mrootdir + _str + mfullphotopaths . length ) ; } string parentdirstring = mrootdir . getabsolutepath ( ) ; for ( int i = _num ; i < mfullphotopaths . length ; i ++ ) { mfullphotopaths [ i ] = parentdirstring + _str + mfullphotopaths [ i ] ; } } }	refreshlocal files from inital path.
dnsrecord ( string name , dnsrecordtype type , dnsrecordclass recordclass , boolean unique , int ttl ) { super ( name , type , recordclass , unique ) ; this . _ttl = ttl ; this . _created = system . currenttimemillis ( ) ; }	create a dnsrecord with a name , type , class , and ttl .
public static string block ( stream < string > rows ) { return block ( rows . collect ( joining ( nl ( ) ) ) ) ; }	indents the specified text , surrounds it with brackets and put the content on a separate line .
protected void addcontentspectoelement ( xmlelementdecl elementdecl ) { if ( ( fdepth == _num || ( fdepth == _num && elementdecl . type == xmlelementdecl . type_mixed ) ) && fnodeindexstack != null ) { if ( elementdecl . type == xmlelementdecl . type_mixed ) { int pcdata = adduniqueleafnode ( null ) ; if ( fnodeindexstack [ _num ] == - _num ) { fnodeindexstack [ _num ] = pcdata ; } else { fnodeindexstack [ _num ] = addcontentspecnode ( xmlcontentspec . contentspecnode_choice , pcdata , fnodeindexstack [ _num ] ) ; } } setcontentspecindex ( fcurrentelementindex , fnodeindexstack [ fdepth ] ) ; } }	adds the content spec to the given element declaration .
private void growspine ( ) { spine = new int [ ( spine . length << _num ) + _num ] ; threshold = ( int ) ( spine . length * loadfactor ) ; arrays . fill ( spine , - _num ) ; for ( int i = _num ; i < size ; i ++ ) { insert ( objs [ i ] , i ) ; } }	expands the hash " spine " - - equivalent to increasing the number of buckets in a conventional hash table .
public void reconnect ( ) { if ( opened && ! allowconnectionrecovery ) { return ; } reconnectwait thread = new reconnectwait ( ) ; thread . start ( ) ; try { thread . join ( ) ; } catch ( interruptedexception e ) { log . error ( _str + e . getmessage ( ) ) ; } if ( ! opened ) { log . error ( _str ) ; } else { log . info ( _str + getcurrentportname ( ) ) ; resetupconnection ( ) ; } }	attempts to reconnect to a failed server.
public collection < gridportrecord > records ( ) { synchronized ( recs ) { return collections . unmodifiablecollection ( new arraylist < > ( recs ) ) ; } }	returns unmodifiable collections of records .
@ override public string tostring ( ) { return buf . tostring ( ) ; }	returns the signature that was built by this signature writer .
public boolean haschangeevent ( string name ) { if ( var != null ) { list < metadata > mdlist = var . getmetadata ( standarddefs . md_changeevent ) ; if ( mdlist != null ) { for ( int i = _num , size = mdlist . size ( ) ; i < size ; i ++ ) { metadata md = mdlist . get ( i ) ; if ( name . equals ( md . getvalue ( _num ) ) ) { return _bool ; } } } } return _bool ; }	[ changeevent ] todo why just on var ? should it be returned for getter / setter props ?.
protected void resetxml11 ( ) throws xniexception { int count = fxml11components . size ( ) ; for ( int i = _num ; i < count ; i ++ ) { xmlcomponent c = ( xmlcomponent ) fxml11components . get ( i ) ; c . reset ( this ) ; } }	reset all components before parsing and namespace context.
public float distancetoothercircle ( circle circle ) { return ( float ) math . abs ( math . sqrt ( math . pow ( circle . center . x - center . x , _num ) + math . pow ( circle . center . y - center . y , _num ) ) ) ; }	distance between circle center.
public simplecommand ( string commandname , string ... args ) { this ( commandname , ( argument ) null ) ; arraylist < argument > arglist = new arraylist < argument > ( ) ; for ( string arg : args ) arglist . add ( new argument ( arg ) ) ; _arguments = arglist . toarray ( new argument [ _num ] ) ; }	constructs a simplecommand from the given command name and the list of arguments .
private void grow ( ) { m_allocatedsize *= _num ; boolean newvector [ ] = new boolean [ m_allocatedsize ] ; system . arraycopy ( m_values , _num , newvector , _num , m_index + _num ) ; m_values = newvector ; }	grows the size of the stack.
public string converttolowercase ( string table ) { return table . tolowercase ( ) ; }	returns the given string in lowercase.
public pickinggraphmouseplugin ( int selectionmodifiers , int addtoselectionmodifiers ) { super ( selectionmodifiers ) ; this . addtoselectionmodifiers = addtoselectionmodifiers ; this . lenspaintable = new lenspaintable ( ) ; this . cursor = cursor . getpredefinedcursor ( cursor . hand_cursor ) ; }	create an instance with overides.
public int [ ] breadthfirstsearch ( int intialvalue , ibfstraversable < n > traversable , int firstvalue , iintegerbfsnextvalueiterator < n > nextvalueiterator , list < integer > sourcesindex ) { int [ ] results = new int [ nodes . length ] ; arrays . fill ( results , intialvalue ) ; boolean [ ] alreadyscanned = new boolean [ nodes . length ] ; arrays . fill ( alreadyscanned , _bool ) ; set < integer > currentnodesindex = new hashset < > ( sourcesindex ) ; iterativeintegerbreadthfirstsearch ( results , alreadyscanned , currentnodesindex , firstvalue , _num , traversable , nextvalueiterator ) ; return results ; }	breadth - first search implementation for integers.
public viewrefrender ( viewrender < t > view , class < t > type , int priority ) { objects . requirenonnull ( view ) ; _view = view ; _type = type ; _priority = priority ; }	creates the view and analyzes the type.
public void checknumberargs ( int argnum ) throws wrongnumberargsexception { if ( argnum < _num ) reportwrongnumberargs ( ) ; }	check that the number of arguments passed to this function is correct .
private boolean announce ( string [ ] groups ) { if ( datapackets == null || ! lastlocator . equals ( mylocator ) || ! arrays . equals ( lastgroups , groups ) ) { list < datagrampacket > packets = new arraylist < datagrampacket > ( ) ; discovery disco ; try { disco = getdiscovery ( multicastannouncementconstraints . chooseprotocolversion ( ) ) ; } catch ( discoveryprotocolexception e ) { throw new assertionerror ( e ) ; } encodeiterator ei = disco . encodemulticastannouncement ( new multicastannouncement ( announcementseqno ++ , mylocator . gethost ( ) , mylocator . getport ( ) , groups , myserviceid ) , multicastannouncementconstraints . getmulticastmaxpacketsize ( default_max_packet_size ) , multicastannouncementconstraints . getunfulfilledconstraints ( ) ) ; while ( ei . hasnext ( ) ) { try { packets . addall ( arrays . aslist ( ei . next ( ) ) ) ; } catch ( exception e ) { logger . log ( ( e instanceof unsupportedconstraintexception ) ? levels . handled : level . info , _str + _str , e ) ; } } lastlocator = mylocator ; lastgroups = groups ; datapackets = packets . toarray ( new datagrampacket [ packets . size ( ) ] ) ; } try { send ( datapackets ) ; } catch ( interruptedioexception e ) { return _bool ; } return _bool ; }	announce membership in the specified groups , and return false if interrupted , otherwise return true.
public drawingattributes ( ) { propertychangesupport = new propertychangesupport ( this ) ; }	create a drawingattributes with the default settings - clear fill paint and pattern , sold black edge line of width 1 .
public void close ( ) { scanner . close ( ) ; }	closes this input stream .
static void createpolicytree ( string configname , string configid , serviceconfigmanager scm , string org ) throws nopermissionexception , policyexception , ssoexception { try { serviceconfig pconfig = scm . getorganizationconfig ( org , null ) ; if ( pconfig == null ) { scm . createorganizationconfig ( org , null ) ; pconfig = scm . getorganizationconfig ( org , null ) ; } pconfig . addsubconfig ( configname , configid , _num , null ) ; } catch ( servicealreadyexistsexception se ) { if ( debug . messageenabled ( ) ) { debug . message ( _str + configname + _str + configid + _str + org ) ; } } catch ( smsexception e ) { string [ ] objs = { org } ; if ( e . getexceptioncode ( ) == smsexception . status_no_permission ) { throw ( new nopermissionexception ( resbundleutils . rbname , _str , null ) ) ; } else { throw ( new policyexception ( resbundleutils . rbname , _str , objs , e ) ) ; } } }	creates the policy tree , ou = policy , ou = services ,.
private void rollbackmethodforcreatesnapshot ( boolean issnapshotcreated , boolean isdummylunpathadded , hdsapiclient hdsapiclient , storagesystem storage , uri snapshot ) throws exception { if ( isdummylunpathadded ) { log . info ( _str ) ; hdsprotectionoperations . removedummylunpath ( storage , snapshot ) ; } if ( issnapshotcreated ) { log . info ( _str ) ; blocksnapshot snapshotobj = dbclient . queryobject ( blocksnapshot . class , snapshot ) ; string systemobjectid = hdsutils . getsystemobjectid ( storage ) ; string logicalunitobjid = hdsutils . getlogicalunitobjectid ( snapshotobj . getnativeid ( ) , storage ) ; hdsapiclient . deletesnapshotvolume ( systemobjectid , logicalunitobjid , storage . getmodel ( ) ) ; } }	roll back method to clean up stale snapshot volume on storage system.
public static int convertstringtotimeseconds ( string time ) { int result = _num ; if ( time . endswith ( _str ) ) { int hourstoadd = integer . valueof ( stringutils . remove ( time , _str ) ) ; result = ( _num * _num ) * hourstoadd ; } else if ( time . endswith ( _str ) ) { int minstoadd = integer . valueof ( stringutils . remove ( time , _str ) ) ; result = _num * minstoadd ; } else if ( time . endswith ( _str ) ) { int secstoadd = integer . valueof ( stringutils . remove ( time , _str ) ) ; result = secstoadd ; } return result ; }	converts a string denoting an amount of time into seconds . strings are expected to follow this form where # equals a digit : # m the following are permitted for denoting time : h = hours , m = minutes , s = seconds.
public void detach ( appcompatactivity activity ) { attrviewmaps . remove ( activity . hashcode ( ) ) ; }	this method should be called in activity ondestroy method.
public void readprefs ( sharedpreferences settings , actionfactory factory ) { boolean visible = _bool ; string actionid = settings . getstring ( _str + name + _str , _str ) ; mainaction = factory . getaction ( actionid ) ; if ( mainaction != null ) visible = _bool ; menuactions . clear ( ) ; for ( int i = _num ; i < maxmenuactions ; i ++ ) { actionid = settings . getstring ( _str + name + _str + ( i + _num ) , _str ) ; uiaction a = factory . getaction ( actionid ) ; if ( a != null ) visible = _bool ; menuactions . add ( a ) ; } if ( button != null ) button . setvisibility ( visible ? view . visible : view . gone ) ; }	update button actions from preferences settings .
public boolean addtoactivelist ( downloadinforunnable downloadinforunnable ) { return activelisthasroom ( ) && mactivelist . add ( downloadinforunnable ) ; }	tries to add a download object to the active list.
private void addexprtotla ( tlaexpr expr ) { vector sv = expr . tostringvector ( ) ; vector exprmapping = expr . tomappingvector ( ) ; int indent = tlacodenextline . length ( ) ; int nextline = _num ; if ( indent != _num ) { mappingobject . shiftmappingvector ( exprmapping , indent ) ; tlacodenextline = tlacodenextline + ( ( string ) sv . elementat ( _num ) ) ; mappingvectornextline . addall ( ( vector ) exprmapping . elementat ( _num ) ) ; nextline = _num ; if ( sv . size ( ) > _num ) { endcurrentlineoftla ( ) ; } } if ( sv . size ( ) > _num ) { string spaces = nspaces ( indent ) ; while ( nextline < sv . size ( ) - _num ) { tlacode . addelement ( spaces + ( ( string ) sv . elementat ( nextline ) ) ) ; mappingvector . addelement ( ( vector ) exprmapping . elementat ( nextline ) ) ; nextline ++ ; } tlacodenextline = spaces + ( ( string ) sv . elementat ( nextline ) ) ; mappingvectornextline = ( vector ) exprmapping . elementat ( nextline ) ; } else if ( indent == _num ) { tlacodenextline = tlacodenextline + ( ( string ) sv . elementat ( _num ) ) ; mappingvectornextline . addall ( ( vector ) exprmapping . elementat ( _num ) ) ; } }	adds the expression to tlacode / tlacodenextline and its mapping to mappingvector / mappingvectornextline.
private boolean isuppercasecamelcasehunk ( string hunk ) { if ( hunk . length ( ) < _num ) return _bool ; for ( int i = _num ; i < hunk . length ( ) ; i ++ ) { if ( ! islegalchar ( hunk . charat ( i ) ) ) return _bool ; } return _bool ; }	true if hunk is longer than 1 character and all letters in the hunk are uppercase.
public void type ( string string ) { for ( int i = _num ; i < string . length ( ) ; i ++ ) { char c = string . charat ( i ) ; type ( c ) ; } }	simulate keyboard type to type out a string.
public boolean providesidentifier ( ) { return _bool ; }	simple registration doesn ' t implement authentication services .
static void removeredundantaffix ( translatorutils . icontain icontain , list < string > strlist ) { if ( strlist . size ( ) <= _num ) { return ; } int w = _num ; for ( string str : strlist ) { if ( w == _num || ! icontain . containfunc ( str , strlist . get ( w - _num ) ) ) { strlist . set ( w , str ) ; w ++ ; } } strlist = strlist . sublist ( _num , w ) ; }	this function ensures that prefix / suffix sets aren ' t redundant.
public static int nextint ( int n ) { random random = getrandom ( ) ; int value = random . nextint ( n ) ; if ( ! _istest ) _freerandomlist . free ( random ) ; return value ; }	returns the next random int .
protected void doresumeupdates ( ) { calendar cal = calendar . getinstance ( locale . getdefault ( ) ) ; mfirstdayofweek = cal . getfirstdayofweek ( ) - _num ; mshowweeknumber = _bool ; updateheader ( ) ; goto ( mselectedday . tomillis ( _bool ) , _bool , _bool , _bool ) ; madapter . setselectedday ( mselectedday ) ; mtodayupdater . run ( ) ; }	updates the user preference fields.
private void storelastused ( ) { put ( last_use , ( int ) ( system . currenttimemillis ( ) / _num ) ) ; }	store current system time as the last used.
private boolean cancontain ( elementcontainmentinfo child , elementcontainmentinfo top , int topindex ) { int childtypes = child . types ; int contents = top . contents ; int transparencyallowed = childtypes & ( top . transparenttocontents & ~ contents ) ; for ( int containerindex = topindex - _num ; transparencyallowed != _num ; -- containerindex ) { if ( containerindex < _num ) { contents |= transparencyallowed ; break ; } elementcontainmentinfo container = openelements . get ( containerindex ) ; contents |= transparencyallowed & container . contents ; transparencyallowed = transparencyallowed & container . transparenttocontents & ~ contents ; } return ( contents & childtypes ) != _num ; }	takes into account transparency when figuring out what can be contained .
public static int [ ] extractarcs ( asn1objectidentifier oid ) throws invalidobjectidexception { string oidstr = oid . getid ( ) ; stringtokenizer strtokcnt = new stringtokenizer ( oidstr , _str , _bool ) ; int arccount = strtokcnt . counttokens ( ) ; stringtokenizer strtok = new stringtokenizer ( oidstr , _str , _bool ) ; boolean expectdelimiter = _bool ; int [ ] arcs = new int [ arccount ] ; int i = _num ; while ( strtok . hasmoretokens ( ) ) { string token = strtok . nexttoken ( ) ; if ( expectdelimiter && ( ! token . equals ( _str ) || ! strtok . hasmoretokens ( ) ) ) { throw new invalidobjectidexception ( res . getstring ( _str ) ) ; } else if ( ! expectdelimiter ) { try { arcs [ i ] = integer . parseint ( token ) ; if ( arcs [ i ] < _num ) { throw new invalidobjectidexception ( res . getstring ( _str ) ) ; } i ++ ; } catch ( numberformatexception ex ) { throw new invalidobjectidexception ( res . getstring ( _str ) ) ; } } expectdelimiter = ! expectdelimiter ; } return arcs ; }	extract the arcs from an object identifier .
public void testisduplicatestring ( ) { int count = _num ; activemqmessageaudit audit = new activemqmessageaudit ( ) ; idgenerator idgen = new idgenerator ( ) ; list < string > list = new arraylist < > ( ) ; for ( int i = _num ; i < count ; i ++ ) { string id = idgen . generateid ( ) ; list . add ( id ) ; assertfalse ( audit . isduplicate ( id ) ) ; } list < string > windowlist = list . sublist ( list . size ( ) - _num - audit . getauditdepth ( ) , list . size ( ) - _num ) ; for ( string id : windowlist ) { asserttrue ( _str + id , audit . isduplicate ( id ) ) ; } }	test case for isduplicate.
protected void updatestatsforconditionaldensityestimator ( conditionaldensityestimator classifier , instance classmissing , double classvalue ) throws exception { if ( m_priorestimator == null ) { setnumericpriorsfrombuffer ( ) ; } m_sumschemeentropy -= classifier . logdensity ( classmissing , classvalue ) * classmissing . weight ( ) / utils . log2 ; m_sumpriorentropy -= m_priorestimator . logdensity ( classvalue ) * classmissing . weight ( ) / utils . log2 ; }	updates stats for conditional density estimator based on current test instance .
@ override public boolean accept ( file f ) { if ( f != null ) { if ( f . isdirectory ( ) ) { return _bool ; } string extension = getextension ( f ) ; if ( extension != null && filters . get ( getextension ( f ) ) != null ) { return _bool ; } ; } return _bool ; }	return true if this file should be shown in the directory pane , false if it shouldn ' t.
public void testcase3 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num } ; byte rbytes [ ] = { _num , _num , _num , _num , _num , _num , _num } ; int asign = _num ; int bsign = - _num ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . add ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	add two numbers of the same length.
@ override public pollresult startpoll ( pollcontroller conn ) { if ( ! _lifecycle . isactive ( ) ) { log . warning ( this + _str ) ; return pollresult . closed ; } socketbar socket = conn . getsocket ( ) ; if ( socket == null ) { log . warning ( this + _str + conn ) ; return pollresult . closed ; } selectablechannel selchannel = socket . selectablechannel ( ) ; if ( selchannel == null ) { log . warning ( this + _str + socket ) ; return pollresult . closed ; } _connectioncount . incrementandget ( ) ; _activecount . incrementandget ( ) ; _registerqueue . offer ( conn ) ; return pollresult . start ; }	adds a keepalive connection .
@ override public void incrementaccesscount ( ) { accesscount . incrementandget ( ) ; }	this method will increment the access count for a column by 1 whenever a column is getting used in query or incremental data load.
public static boolean comparedoubles ( double a , double b ) { if ( double . isnan ( a ) && double . isnan ( b ) ) return _bool ; if ( ! double . isinfinite ( a ) && ! double . isinfinite ( b ) ) return math . abs ( a - b ) <= epsilon ; return a == b ; }	compares two doubles for equality .
public static byte [ ] bitmaptobyte ( bitmap b ) { bytearrayoutputstream o = new bytearrayoutputstream ( ) ; b . compress ( bitmap . compressformat . png , _num , o ) ; return o . tobytearray ( ) ; }	convert bitmap to byte array.
public configurecoerceiveparsingdialog_nb ( coerciveparsing coerciveparsing ) { this . coerciveparsing = coerciveparsing ; initcomponents ( ) ; final iteratemodel numberoftagsiterator = coerciveparsing . getnumberoftagsiterator ( ) ; configureiteratemodel_nb2 . setstartat ( string . valueof ( numberoftagsiterator . getstartat ( ) ) ) ; configureiteratemodel_nb2 . setstopat ( string . valueof ( numberoftagsiterator . getstopat ( ) ) ) ; configureiteratemodel_nb2 . setincrement ( string . valueof ( numberoftagsiterator . getincrement ( ) ) ) ; configureiteratemodel_nb2 . setiteratestrategie ( numberoftagsiterator . getiteratestrategie ( ) ) ; list < string > tagnames = arrays . aslist ( coerciveparsing . gettagnames ( ) ) ; configurestringlist_nb1 . setstringlist ( tagnames ) ; }	creates new form configurecoerceiveparsingdialog_nb.
public static double logofbase ( double number , int base ) { return math . log ( number ) / math . log ( base ) ; }	gets the log at a certain base of a number .
public static void uf6 ( double [ ] x , double [ ] f , int nx ) { int count1 = _num ; int count2 = _num ; double sum1 = _num ; double sum2 = _num ; double prod1 = _num ; double prod2 = _num ; double yj ; double hj ; double pj ; double n = _num ; double e = _num ; for ( int j = _num ; j <= nx ; j ++ ) { yj = x [ j - _num ] - math . sin ( _num * pi * x [ _num ] + j * pi / nx ) ; pj = math . cos ( _num * yj * pi / math . sqrt ( j + _num ) ) ; if ( j % _num == _num ) { sum2 += yj * yj ; prod2 *= pj ; count2 ++ ; } else { sum1 += yj * yj ; prod1 *= pj ; count1 ++ ; } } hj = _num * ( _num / n + e ) * math . sin ( _num * n * pi * x [ _num ] ) ; if ( hj < _num ) { hj = _num ; } f [ _num ] = x [ _num ] + hj + _num * ( _num * sum1 - _num * prod1 + _num ) / ( double ) count1 ; f [ _num ] = _num - x [ _num ] + hj + _num * ( _num * sum2 - _num * prod2 + _num ) / ( double ) count2 ; }	evaluates the uf6 problem .
public filesaverdescriptor ( @ notnull string title , @ notnull string description , string ... extensions ) { super ( _bool , _bool , _bool , _bool , _bool , _bool ) ; settitle ( title ) ; setdescription ( description ) ; this . extensions = arrays . aslist ( extensions ) ; }	constructs save dialog properties.
protected int readblock ( ) { blocksize = read ( ) ; int n = _num ; if ( blocksize > _num ) { try { int count ; while ( n < blocksize ) { count = blocksize - n ; rawdata . get ( block , n , count ) ; n += count ; } } catch ( final exception e ) { log . w ( tag , _str , e ) ; status = status_format_error ; } } return n ; }	reads next variable length block from input .
public void addrun ( final run run ) { runs . add ( run ) ; run . setid ( runidcounter ++ ) ; }	will add the run to the list .
void copyinto ( converter [ ] converters ) { system . arraycopy ( iconverters , _num , converters , _num , iconverters . length ) ; }	copies all the converters in the set to the given array .
@ override public boolean addoutputsensor ( string sensorname , int state ) { outputsensor outputsensor = new outputsensor ( sensorname ) ; if ( ! outputsensor . setstate ( state ) ) { return _bool ; } _outputsensorlist . add ( outputsensor ) ; return _bool ; }	add an output sensor to this route.
public void init ( socketchannel channel ) { _channel = channel ; _readbuffer . clear ( ) ; _readbuffer . flip ( ) ; _needsflush = _bool ; }	initialize the socketstream with a new socket .
public void reset ( ) { timber . i ( _str ) ; mcurrentplayer . reset ( ) ; mnextplayer . reset ( ) ; mqueue = collections . emptylist ( ) ; mqueueindex = _num ; mrequestedseekposition = _num ; mplaywhenprepared = _bool ; }	resets both mediaplayers , and clears the queue.
@ override public expected < t > ifpresent ( final consumer < ? super t > consumer ) { if ( this . value != null ) consumer . accept ( this . value ) ; return this ; }	if a value is present , invoke the consumer with the value .
protected void sendintensity ( double intensity ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str + intensity + _str + _str + lastoutputstep + _str + maxdimstep ) ; } int newstep = ( int ) math . round ( intensity * maxdimstep ) ; if ( ( newstep < _num ) || ( newstep > maxdimstep ) ) { log . error ( _str + newstep + _str + intensity ) ; } if ( newstep == _num ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str + intensity + _str ) ; } return ; } x10sequence out = new x10sequence ( ) ; out . addextdata ( housecode , devicecode , x10sequence . extcmd_dim , newstep ) ; tc . sendx10sequence ( out , null ) ; lastoutputstep = newstep ; if ( log . isdebugenabled ( ) ) { log . debug ( _str + intensity + _str + x10sequence . housevaluetotext ( housecode ) + _str + devicecode + _str + newstep ) ; } }	send a dim / bright commands to the x10 hardware to reach a specific intensity.
public static float readfloat ( ) { return scanner . nextfloat ( ) ; }	reads the next token from standard input , parses it as a float , and returns the float .
public glowscheduler ( glowserver server , worldscheduler worlds ) { this . server = server ; this . worlds = worlds ; inticktaskcondition = worlds . getadvancecondition ( ) ; tickendrun = null ; primarythread = thread . currentthread ( ) ; }	creates a new task scheduler .
public void test_fill iiii ( ) { int val = integer . max_value ; int d [ ] = new int [ _num ] ; arrays . fill ( d , _num , d . length , val ) ; for ( int i = _num ; i < _num ; i ++ ) asserttrue ( _str , ! ( d [ i ] == val ) ) ; for ( int i = _num ; i < d . length ; i ++ ) asserttrue ( _str , d [ i ] == val ) ; try { arrays . fill ( d , _num , _num , val ) ; fail ( _str ) ; } catch ( illegalargumentexception e ) { } try { arrays . fill ( d , - _num , _num , val ) ; fail ( _str ) ; } catch ( arrayindexoutofboundsexception e ) { } try { arrays . fill ( d , _num , d . length + _num , val ) ; fail ( _str ) ; } catch ( arrayindexoutofboundsexception e ) { } }	java . util . arrays # fill ( int [ ] , int , int , int ).
private int calculatelayoutwidth ( int widthsize , int mode ) { initresourcesifnecessary ( ) ; itemslayout . setlayoutparams ( new layoutparams ( layoutparams . wrap_content , layoutparams . wrap_content ) ) ; itemslayout . measure ( measurespec . makemeasurespec ( widthsize , measurespec . unspecified ) , measurespec . makemeasurespec ( _num , measurespec . unspecified ) ) ; int width = itemslayout . getmeasuredwidth ( ) ; if ( mode == measurespec . exactly ) { width = widthsize ; } else { width += _num * padding ; width = math . max ( width , getsuggestedminimumwidth ( ) ) ; if ( mode == measurespec . at_most && widthsize < width ) { width = widthsize ; } } itemslayout . measure ( measurespec . makemeasurespec ( width - _num * padding , measurespec . exactly ) , measurespec . makemeasurespec ( _num , measurespec . unspecified ) ) ; return width ; }	calculates control width and creates text layouts.
public void delete ( ) throws ioexception { close ( ) ; utils . deletecontents ( directory ) ; }	closes the cache and deletes all of its stored values.
@ override public boolean execute ( @ notnull psielement pe , @ notnull resolvestate state ) { if ( pe instanceof psivariable ) { final psivariable pvar = ( psivariable ) pe ; if ( ! mystaticsensitiveflag || ! mystaticscopeflag || pvar . hasmodifierproperty ( psimodifier . static ) ) { if ( check ( pvar , state ) ) { myresultlist . add ( pvar ) ; } } } return _bool ; }	always return true since we wanna get all vars in scope.
public void characters ( char [ ] ch , int start , int length ) throws saxexception { try { stopterminator ( ) ; if ( w == null ) return ; int end = start + length ; for ( int i = start ; i < end ; i ++ ) { char c = ch [ i ] ; switch ( c ) { case _str : w . write ( _str ) ; break ; case _str : w . write ( _str ) ; break ; case _str : w . write ( _str ) ; break ; case _str : case _str : case _str : w . write ( c ) ; break ; default : if ( canencode ( c ) ) { w . write ( c ) ; } else { w . write ( _str ) ; w . write ( integer . tostring ( c ) ) ; w . write ( _str ) ; } break ; } } } catch ( ioexception e ) { throw new saxexception ( e ) ; } }	inserts a string of characters into the document .
public static string tohumanreadablestring ( final string iso8601duration ) { string str = _str ; if ( iso8601duration . matches ( _str ) ) { str = _str ; } else { string hours = gethours ( iso8601duration ) , minutes = getminutes ( iso8601duration ) , seconds = getseconds ( iso8601duration ) ; if ( hours != null ) { str = hours ; if ( minutes != null && minutes . length ( ) == _num ) { minutes = _str + minutes ; } } if ( str . isempty ( ) ) str = minutes ; else str += _str + minutes ; if ( str . isempty ( ) ) str = seconds ; else str += _str + seconds ; } return str ; }	converts the supplies iso 8601 duration into a human readable string.
@ override public ichatmessage sendmessage ( final string text ) throws remoteexception { if ( textutils . isempty ( text ) ) { throw new serverapiillegalargumentexception ( _str ) ; } int messagelength = text . length ( ) ; int maxmessagelength = mrcssettings . getmaxgroupchatmessagelength ( ) ; if ( messagelength > maxmessagelength ) { throw new serverapiillegalargumentexception ( _str + messagelength + _str + maxmessagelength + _str ) ; } if ( ! isallowedtosendmessage ( ) ) { throw new serverapipermissiondeniedexception ( _str ) ; } try { mimservice . removegroupchatcomposingstatus ( mchatid ) ; long timestamp = system . currenttimemillis ( ) ; final chatmessage msg = chatutils . createtextmessage ( null , text , timestamp , timestamp ) ; chatmessagepersistedstorageaccessor persistedstorage = new chatmessagepersistedstorageaccessor ( mmessaginglog , msg . getmessageid ( ) , msg . getremotecontact ( ) , text , msg . getmimetype ( ) , mchatid , direction . outgoing ) ; addoutgoinggroupchatmessage ( msg , content . status . queued , content . reasoncode . unspecified ) ; if ( ! mchatservice . isgroupchatactive ( mchatid ) ) { mchatservice . setgroupchatstateandreasoncode ( mchatid , groupchat . state . started , groupchat . reasoncode . unspecified ) ; } mimservice . trytodequeuegroupchatmessagesandgroupfiletransfers ( mchatid ) ; return new chatmessageimpl ( persistedstorage ) ; } catch ( serverapibaseexception e ) { if ( ! e . shouldnotbelogged ( ) ) { slogger . error ( exceptionutil . getfullstacktrace ( e ) ) ; } throw e ; } catch ( exception e ) { slogger . error ( exceptionutil . getfullstacktrace ( e ) ) ; throw new serverapigenericexception ( e ) ; } }	sends a text message to the group.
public java . lang . string tostring ( ) { return tostring ( value ) ; }	returns a string object representing this long ' s value.
void remove ( tcpserverthread t ) { running . remove ( t ) ; }	remove a thread from the list .
public docknodeeventhandler ( node node ) { this . node = node ; }	creates a default dock node event handler that will help this dock pane track the current docking area .
private int readsourcetolog ( settings settings ) { string sourcetolog = settings . get ( index_indexing_slowlog_max_source_chars_to_log , _str ) ; try { return integer . parseint ( sourcetolog , _num ) ; } catch ( numberformatexception e ) { return booleans . parseboolean ( sourcetolog , _bool ) ? integer . max_value : _num ; } }	reads how much of the source to log.
private void deletecurrentlicensefileondisk ( ) { file licensefile = new file ( licenseconstants . license_file_path ) ; if ( licensefile . exists ( ) ) { licensefile . delete ( ) ; } }	deletes current version of license file in / tmp / . license.
@ deprecated public static networkparameters testnet ( ) { return testnet3params . get ( ) ; }	alias for testnet3params . get ( ) , use that instead .
@ override public void run ( ) { synchronized ( msync ) { mrequeststop = _bool ; mrequestdrain = _num ; msync . notify ( ) ; } final boolean isrunning = _bool ; boolean localrequeststop ; boolean localrequestdrain ; while ( isrunning ) { synchronized ( msync ) { localrequeststop = mrequeststop ; localrequestdrain = ( mrequestdrain > _num ) ; if ( localrequestdrain ) mrequestdrain -- ; } if ( localrequeststop ) { drain ( ) ; signalendofinputstream ( ) ; drain ( ) ; release ( ) ; break ; } if ( localrequestdrain ) { drain ( ) ; } else { synchronized ( msync ) { try { msync . wait ( ) ; } catch ( final interruptedexception e ) { break ; } } } } if ( debug ) log . d ( tag , _str ) ; synchronized ( msync ) { mrequeststop = _bool ; miscapturing = _bool ; } }	encoding loop on private thread.
public final void readfromstream ( datainputstream dis , int version ) throws ioexception , chessparseerror { event = dis . readutf ( ) ; site = dis . readutf ( ) ; date = dis . readutf ( ) ; round = dis . readutf ( ) ; white = dis . readutf ( ) ; black = dis . readutf ( ) ; startpos = textio . readfen ( dis . readutf ( ) ) ; currentpos = new position ( startpos ) ; timecontrol = dis . readutf ( ) ; if ( version >= _num ) { whitetimecontrol = dis . readutf ( ) ; blacktimecontrol = dis . readutf ( ) ; } else { whitetimecontrol = _str ; blacktimecontrol = _str ; } int ntags = dis . readint ( ) ; tagpairs . clear ( ) ; for ( int i = _num ; i < ntags ; i ++ ) { tagpair tp = new tagpair ( ) ; tp . tagname = dis . readutf ( ) ; tp . tagvalue = dis . readutf ( ) ; tagpairs . add ( tp ) ; } rootnode = new node ( ) ; node . readfromstream ( dis , rootnode ) ; currentnode = rootnode ; int pathlen = dis . readint ( ) ; for ( int i = _num ; i < pathlen ; i ++ ) goforward ( dis . readint ( ) ) ; updatelistener ( ) ; }	de - serialize from input stream .
public rect updatefastscrollerbounds ( baserecyclerview rv , int lasttouchy ) { minvalidaterect . set ( mbgbounds ) ; if ( isvisible ( ) ) { int edgepadding = rv . getmaxscrollbarwidth ( ) ; int bgpadding = ( mbgoriginalsize - mtextbounds . height ( ) ) / _num ; int bgheight = mbgoriginalsize ; int bgwidth = math . max ( mbgoriginalsize , mtextbounds . width ( ) + ( _num * bgpadding ) ) ; if ( utilities . isrtl ( mres ) ) { mbgbounds . left = rv . getbackgroundpadding ( ) . left + ( _num * rv . getmaxscrollbarwidth ( ) ) ; mbgbounds . right = mbgbounds . left + bgwidth ; } else { mbgbounds . right = rv . getwidth ( ) - rv . getbackgroundpadding ( ) . right - ( _num * rv . getmaxscrollbarwidth ( ) ) ; mbgbounds . left = mbgbounds . right - bgwidth ; } mbgbounds . top = lasttouchy - ( int ) ( fast_scroll_overlay_y_offset_factor * bgheight ) ; mbgbounds . top = math . max ( edgepadding , math . min ( mbgbounds . top , rv . getheight ( ) - edgepadding - bgheight ) ) ; mbgbounds . bottom = mbgbounds . top + bgheight ; } else { mbgbounds . setempty ( ) ; } minvalidaterect . union ( mbgbounds ) ; return minvalidaterect ; }	updates the bounds for the fast scroller .
public dnetscapecapolicyurl ( jdialog parent ) { super ( parent ) ; settitle ( res . getstring ( _str ) ) ; initcomponents ( ) ; }	creates a new dnetscapecapolicyurl dialog .
public static path createdirectory ( final path parent , final string foldername ) { final file file = new file ( parent . tofile ( ) , foldername ) ; if ( ! file . exists ( ) ) { if ( ! file . mkdir ( ) ) { throw new runtimeexception ( _str + parent + _str + foldername + _str ) ; } } file . deleteonexit ( ) ; return file . topath ( ) ; }	creates a new directory with the given parent folder and folder name.
public static boolean iswindows8 ( ) { return osname . indexof ( _str ) > - _num && ( osversion . equals ( _str ) || osversion . equals ( _str ) ) ; }	is operating system windows 8 or 8 . 1 ?.
protected set < functioninterface > findunusedfunctions ( set < unitinterface > units ) { set < functioninterface > allfunctions = new hashset < functioninterface > ( ) ; set < functioninterface > usedfunctions = new hashset < functioninterface > ( ) ; for ( unitinterface unit : units ) { list < functioninterface > unitfunctions = getunitfunctions ( unit ) ; allfunctions . addall ( unitfunctions ) ; for ( functioninterface unitfunction : unitfunctions ) { for ( functioninterface usedfunction : unitfunction . getcalledfunctions ( ) ) { usedfunctions . add ( usedfunction ) ; } } } allfunctions . removeall ( usedfunctions ) ; return allfunctions ; }	find unused functions in a unit.
private static void additemstolist ( int startindex , int endindex ) { for ( int i = startindex ; i < endindex ; i ++ ) { values . add ( new integer ( i ) ) ; } }	adds the items to the list.
public static synchronized list < proxy > noproxylist ( ) { if ( noproxylist == null ) { arraylist < proxy > list = new arraylist < proxy > ( _num ) ; list . add ( proxy . no_proxy ) ; noproxylist = collections . unmodifiablelist ( list ) ; } return noproxylist ; }	gets an unmodifiable proxy list that will have as it ' s only entry an direct proxy .
public void addincludes ( string [ ] definitions ) { addstrings ( includes , definitions ) ; addstrings ( linker_more , includes , definitions ) ; newlinkeroptionsaftercompile . add ( includes ) ; }	adds a list of definitions to the existing list of definitions .
protected void add ( double value , int group ) { if ( ( group < _num ) || ( group >= numberofgroups ) ) { throw new illegalargumentexception ( ) ; } data . add ( new rankedobservation ( value , group ) ) ; }	adds a new observation with the specified value and group .
public void tallyvariant ( vcfheader header , vcfrecord rec ) { tallyvariant ( rec , header . getsamplenames ( ) ) ; }	add the given vcf record to the statistics.
public int read ( byte [ ] b , int off , int len ) throws ioexception { if ( closed ) { throw new ioexception ( _str ) ; } if ( eof ) { return - _num ; } if ( pos >= chunksize ) { nextchunk ( ) ; if ( eof ) { return - _num ; } } len = math . min ( len , chunksize - pos ) ; int count = in . read ( b , off , len ) ; pos += count ; return count ; }	read some bytes from the stream .
public ldifentryreader ( final string ... ldiflines ) { super ( arrays . aslist ( ldiflines ) ) ; }	creates a new ldif entry reader which will read lines of ldif from the provided array of ldif lines .
public void updatepresoninfo ( ) { this . leftperson = person2leavingpersoninfo . get ( this . personid ) ; this . enteredperson = person2enteringpersoninfo . get ( this . personid ) ; }	a person may re - appear on the same link .
public mymap remove ( int position ) { mymap mm = null ; if ( position >= _num && position < getitemcount ( ) ) { mm = mymaps . remove ( position ) ; notifyitemremoved ( position ) ; } return mm ; }	remove item at the given position.
public void presentlicenses ( boolean preaccept ) { licenseset licenses = licensemodule . getrequiredlicenses ( ) ; if ( preaccept ) { licenses . acceptall ( ) ; } else { for ( license license : licenses ) { if ( license . isaccepted ( ) ) { continue ; } user . show ( _str ) ; user . show ( license . getlicensetext ( ) ) ; string input = user . ask ( _str ) ; if ( input != null && yes . startswith ( input . tolowercase ( ) ) ) { license . accept ( ) ; } else { license . reject ( ) ; } } } }	present the licenses to the user - if the preaccept parameter is set , then simply display them through system.
public void addgeokey ( xtifffield geokey ) { geokeyindex . put ( new integer ( geokey . gettag ( ) ) , geokey ) ; hasgeokeys = _bool ; }	add an existing geokey to the directory .
public static geotimeserie detect ( geotimeserie gts , int alphabetsize , int wordlen , int windowlen , collection < string > patterns , boolean standardizepaa ) throws warpscriptexception { geotimeserie gtspatterns = gtshelper . bsax ( gts , alphabetsize , wordlen , windowlen , standardizepaa ) ; gtshelper . sort ( gtspatterns ) ; geotimeserie detected = new geotimeserie ( gts . lastbucket , gts . bucketcount , gts . bucketspan , _num ) ; detected . setmetadata ( gts . getmetadata ( ) ) ; int lastidx = - _num ; for ( int i = _num ; i < gtspatterns . values ; i ++ ) { if ( ! patterns . contains ( gtspatterns . stringvalues [ i ] ) ) { continue ; } for ( int j = _num ; j < windowlen ; j ++ ) { if ( i + j > lastidx ) { lastidx = i + j ; gtshelper . setvalue ( detected , gtshelper . tickatindex ( gts , lastidx ) , gtshelper . locationatindex ( gts , lastidx ) , gtshelper . elevationatindex ( gts , lastidx ) , gtshelper . valueatindex ( gts , lastidx ) , _bool ) ; } } } return detected ; }	detect patterns in a geo time serie instance.
private stringbuilder debugdumpcandidates ( stringbuilder msg , list < ? extends itemset > candidates , vectorfieldtypeinformation < bitvector > meta ) { msg . append ( _str ) ; for ( itemset itemset : candidates ) { msg . append ( _str ) ; itemset . appendto ( msg , meta ) ; msg . append ( _str ) ; } return msg ; }	debug method : output all itemsets .
public static final void writebooleanarrayxml ( boolean [ ] val , string name , xmlserializer out ) throws xmlpullparserexception , java . io . ioexception { if ( val == null ) { out . starttag ( null , _str ) ; out . endtag ( null , _str ) ; return ; } out . starttag ( null , _str ) ; if ( name != null ) { out . attribute ( null , _str , name ) ; } final int n = val . length ; out . attribute ( null , _str , integer . tostring ( n ) ) ; for ( int i = _num ; i < n ; i ++ ) { out . starttag ( null , _str ) ; out . attribute ( null , _str , boolean . tostring ( val [ i ] ) ) ; out . endtag ( null , _str ) ; } out . endtag ( null , _str ) ; }	flatten a boolean [ ] into an xmlserializer.
public void addoutboundrule ( final outboundrule outboundrule ) { outboundrule . setid ( outboundruleidcounter ++ ) ; outboundrules . add ( outboundrule ) ; }	will add the rule to the rules list .
public skype ( string username , string password ) { this . username = username ; this . password = password ; }	builds a new skype connection without connecting to anything .
private void stopdrag ( motionevent ev ) { mtouchmode = touch_mode_idle ; final boolean commitchange = ev . getaction ( ) == motionevent . action_up && isenabled ( ) ; final boolean oldstate = ischecked ( ) ; final boolean newstate ; if ( commitchange ) { mvelocitytracker . computecurrentvelocity ( _num ) ; final float xvel = mvelocitytracker . getxvelocity ( ) ; if ( math . abs ( xvel ) > mminflingvelocity ) { newstate = viewutils . islayoutrtl ( this ) ? ( xvel < _num ) : ( xvel > _num ) ; } else { newstate = gettargetcheckedstate ( ) ; } } else { newstate = oldstate ; } if ( newstate != oldstate ) { playsoundeffect ( soundeffectconstants . click ) ; } setchecked ( newstate ) ; cancelsupertouch ( ev ) ; }	called from ontouchevent to end a drag operation .
private void addflags ( int newflags ) { flags = getlayoutflags ( ) | newflags ; }	or newflags with existing flags.
public static string matchcertificate ( keystore keystore , x509certificate cert ) throws cryptoexception { try { for ( enumeration aliases = keystore . aliases ( ) ; aliases . hasmoreelements ( ) ; ) { string alias = ( string ) aliases . nextelement ( ) ; if ( keystore . iscertificateentry ( alias ) ) { x509certificate compcert = x509certutil . convertcertificate ( keystore . getcertificate ( alias ) ) ; if ( cert . equals ( compcert ) ) { return alias ; } } } return null ; } catch ( keystoreexception ex ) { throw new cryptoexception ( res . getstring ( _str ) , ex ) ; } }	check whether or not a trusted certificate in the supplied keystore matches the supplied x.
void purgelastarticles ( int amounttopurge ) { if ( ! isdbavailable ( ) ) return ; long time = system . currenttimemillis ( ) ; string query = _str + table_articles + _str + ( utils . article_limit - amounttopurge + _str ) ; safelydeletearticles ( query , null ) ; log . d ( tag , _str + ( system . currenttimemillis ( ) - time ) + _str ) ; }	delete given amount of last updated articles from db.
public void reclaimviews ( list < view > views ) { int childcount = getchildcount ( ) ; recyclerlistener listener = mrecycler . mrecyclerlistener ; for ( int i = _num ; i < childcount ; i ++ ) { view child = getchildat ( i ) ; twowayabslistview . layoutparams lp = ( twowayabslistview . layoutparams ) child . getlayoutparams ( ) ; if ( lp != null && mrecycler . shouldrecycleviewtype ( lp . viewtype ) ) { views . add ( child ) ; if ( listener != null ) { listener . onmovedtoscrapheap ( child ) ; } } } mrecycler . reclaimscrapviews ( views ) ; removeallviewsinlayout ( ) ; }	move all views ( excluding headers and footers ) held by this twowayabslistview into the supplied list.
proxyverifier ( txnmanager serverproxy , uuid proxyid ) { if ( ! ( serverproxy instanceof remotemethodcontrol ) ) { throw new unsupportedoperationexception ( _str ) ; } else if ( ! ( serverproxy instanceof trustequivalence ) ) { throw new unsupportedoperationexception ( _str + _str ) ; } else if ( proxyid == null ) { throw new illegalargumentexception ( _str ) ; } this . serverproxy = ( remotemethodcontrol ) serverproxy ; this . proxyid = proxyid ; }	returns a verifier for the smart proxies of the specified mahalo server proxy .
public void paint ( graphics g ) { g . translate ( _num , translatey ) ; super . paint ( g ) ; }	displays our component in the location ( 0 , translatey ).
private void beforekey ( ) throws jsonexception { scope context = peek ( ) ; if ( context == scope . nonempty_object ) { out . append ( _str ) ; } else if ( context != scope . empty_object ) { throw new jsonexception ( _str ) ; } newline ( ) ; replacetop ( scope . dangling_key ) ; }	inserts any necessary separators and whitespace before a name.
public static void transfer ( inputstream in , outputstream out , int buffersize ) throws ioexception { byte [ ] buffer = new byte [ buffersize ] ; int bytesread ; while ( ( bytesread = in . read ( buffer ) ) != - _num ) { out . write ( buffer , _num , bytesread ) ; } }	copies data from an input stream to an output stream using a buffer of specified size .
public void testfiledirectory ( ) throws exception { properties properties = loadproperties ( _str ) ; assertequals ( _str , properties . getproperty ( _str ) ) ; }	test the configuration files option with copying of subdirectory as - is .
private static long addandcheck ( long a , long b , localizable pattern ) throws mathruntimeexception { final long result = a + b ; if ( ! ( ( a ^ b ) < _num || ( a ^ result ) >= _num ) ) { throw new mathruntimeexception ( pattern , a , b ) ; } return result ; }	add two long integers , checking for overflow .
private void serializecompactrdfgeneralqualifier ( int indent , xmpnode node ) throws ioexception , xmpexception { write ( _str ) ; writenewline ( ) ; serializecanonicalrdfproperty ( node , _bool , _bool , indent + _num ) ; for ( iterator iq = node . iteratequalifier ( ) ; iq . hasnext ( ) ; ) { xmpnode qualifier = ( xmpnode ) iq . next ( ) ; serializecanonicalrdfproperty ( qualifier , _bool , _bool , indent + _num ) ; } }	serializes the general qualifier .
private jcheckbox addcheckbox ( string text , container container ) { jcheckbox checkbox = new jcheckbox ( text ) ; checkbox . setalignmentx ( component . left_alignment ) ; checkbox . setborder ( borderfactory . createemptyborder ( _num , _num , _num , _num ) ) ; container . add ( checkbox ) ; return checkbox ; }	adds a preconfigured jcheckbox to the specified container , setting its alignment constraint to left and adding an empty padding border .
public void push ( ) { state . cliprgn = g . getclipbounds ( ) ; stack . push ( state ) ; state = ( graphicsstate ) state . clone ( ) ; }	push the current graphics state onto the stack.
public static void dropindex ( connection conn , string schema , string table ) throws sqlexception { init ( conn ) ; preparedstatement prep = conn . preparestatement ( _str + schema + _str ) ; prep . setstring ( _num , schema ) ; prep . setstring ( _num , table ) ; resultset rs = prep . executequery ( ) ; if ( ! rs . next ( ) ) { return ; } int indexid = rs . getint ( _num ) ; prep = conn . preparestatement ( _str + schema + _str ) ; prep . setint ( _num , indexid ) ; prep . execute ( ) ; createordroptrigger ( conn , schema , table , _bool ) ; prep = conn . preparestatement ( _str + schema + _str ) ; while ( _bool ) { prep . setint ( _num , indexid ) ; int deleted = prep . executeupdate ( ) ; if ( deleted == _num ) { break ; } } prep = conn . preparestatement ( _str + schema + _str + _str + schema + _str ) ; while ( _bool ) { int deleted = prep . executeupdate ( ) ; if ( deleted == _num ) { break ; } } }	drop an existing full text index for a table.
public e peek ( ) { if ( isempty ( ) ) { return null ; } return elements [ _num ] ; }	gets but does not remove the head of the queue .
public synchronized int add ( iaudioprocessor processor ) { processors . add ( processor ) ; buildfinalprocessor ( ) ; return processors . indexof ( processor ) ; }	adds a processor to the internal processor queue .
public scriptbuilder data ( int index , byte [ ] data ) { byte [ ] copy = arrays . copyof ( data , data . length ) ; int opcode ; if ( data . length == _num ) { opcode = op_0 ; } else if ( data . length == _num ) { byte b = data [ _num ] ; if ( b >= _num && b <= _num ) opcode = script . encodetoopn ( b ) ; else opcode = _num ; } else if ( data . length < op_pushdata1 ) { opcode = data . length ; } else if ( data . length < _num ) { opcode = op_pushdata1 ; } else if ( data . length < _num ) { opcode = op_pushdata2 ; } else { throw new runtimeexception ( _str ) ; } return addchunk ( index , new scriptchunk ( opcode , copy ) ) ; }	adds a copy of the given byte array as a data element ( i.
public void initialize ( map configparams ) { string delimiterconfig = ( string ) configparams . get ( policyconfig . resource_comparator_delimiter ) ; if ( delimiterconfig != null ) { this . delimiter = delimiterconfig ; } string caseconfig = ( string ) configparams . get ( policyconfig . resource_comparator_case_sensitive ) ; if ( caseconfig != null ) { if ( caseconfig . equals ( _str ) ) { this . casesensitive = _bool ; } else if ( caseconfig . equals ( _str ) ) { this . casesensitive = _bool ; } else { this . casesensitive = _bool ; } } string wildcardconfig = ( string ) configparams . get ( policyconfig . resource_comparator_wildcard ) ; if ( wildcardconfig != null ) { this . wildcard = wildcardconfig ; } string onelevelwildcardconfig = ( string ) configparams . get ( policyconfig . resource_comparator_one_level_wildcard ) ; if ( onelevelwildcardconfig != null ) { this . onelevelwildcard = onelevelwildcardconfig ; } if ( debug . messageenabled ( ) ) { debug . message ( _str + _str + delimiter + _str + wildcard + _str + onelevelwildcard + _str + caseconfig ) ; } onelevelwildcardlength = onelevelwildcard . length ( ) ; wildcardlength = wildcard . length ( ) ; if ( onelevelwildcard . indexof ( wildcard ) != - _num ) { wildcardembedded = _bool ; } else { wildcardembedded = _bool ; } if ( wildcard . indexof ( onelevelwildcard ) != - _num ) { onelevelwildcardembedded = _bool ; } else { onelevelwildcardembedded = _bool ; } if ( debug . messageenabled ( ) ) { debug . message ( _str + wildcardembedded + _str + onelevelwildcardembedded ) ; } return ; }	initializes the resource name with configuration information , usally set by the administrators.
protected void deleteleastusedentry ( ) { try { poollock . lock ( ) ; basicpoolentry entry = freeconnections . remove ( ) ; if ( entry != null ) { deleteentry ( entry ) ; } else if ( log . isdebugenabled ( ) ) { log . debug ( _str ) ; } } finally { poollock . unlock ( ) ; } }	delete an old , free pool entry to make room for a new one.
private string convertlessthanonethousand ( int number ) { string sofar ; if ( number % _num < _num ) { sofar = numnames [ number % _num ] ; number /= _num ; } else { sofar = numnames [ number % _num ] ; number /= _num ; string s = integer . tostring ( number ) ; if ( s . endswith ( _str ) && ! sofar . equals ( _str ) ) sofar = _str + sofar . trim ( ) ; else if ( sofar . equals ( _str ) ) sofar = tensnames [ number % _num ] + sofar ; else sofar = tensnames [ number % _num ] + _str + sofar ; number /= _num ; } if ( number == _num ) return tensnames [ number % _num ] + sofar ; if ( number > _num ) sofar = _str + sofar ; if ( number == _num && ! sofar . equals ( _str ) ) number = _num ; return numnames [ number ] + _str + sofar ; }	convert less than one thousand.
public static boolean isembeddedbase64image ( string uri ) { return ( uri != null && uri . startswith ( _str ) ) ; }	detect if an uri represents an embedded base 64 image .
void changestate ( int newstate ) { int oldstate ; synchronized ( statelock ) { if ( state == newstate ) return ; oldstate = state ; state = newstate ; statelock . notifyall ( ) ; } sendstatechangenotification ( oldstate , newstate ) ; }	for internal use only .
private int parselinklabel ( ) { string m = match ( link_label ) ; return m == null ? _num : m . length ( ) ; }	attempt to parse a link label , returning number of characters parsed .
public static string readfileasstring ( file file ) throws filenotfoundexception { return readfileasstring ( file . getabsolutepath ( ) ) ; }	devuelve el contenido de un file como string.
protected void onexception ( final wroruntimeexception e ) { throw e ; }	invoked when an unexpected exception occurred during processing.
public synchronized void checkaccess ( licensecheckercallback callback ) { if ( mpolicy . allowaccess ( ) ) { log . i ( tag , _str ) ; callback . allow ( policy . licensed ) ; } else { licensevalidator validator = new licensevalidator ( mpolicy , new nulldevicelimiter ( ) , callback , generatenonce ( ) , mpackagename , mversioncode ) ; if ( mservice == null ) { log . i ( tag , _str ) ; try { boolean bindresult = mcontext . bindservice ( new intent ( new string ( base64 . decode ( _str ) ) ) , this , context . bind_auto_create ) ; if ( bindresult ) { mpendingchecks . offer ( validator ) ; } else { log . e ( tag , _str ) ; handleserviceconnectionerror ( validator ) ; } } catch ( securityexception e ) { callback . applicationerror ( licensecheckercallback . error_missing_permission ) ; } catch ( base64decoderexception e ) { e . printstacktrace ( ) ; } } else { mpendingchecks . offer ( validator ) ; runchecks ( ) ; } } }	checks if the user should have access to the app.
public void close ( ) { if ( ! isopen ) return ; log . d ( tag , _str ) ; loadinglock . lock ( ) ; try { save ( ) ; if ( savefilestream != null ) { savinghelper . close ( savefilestream ) ; savefilestream = null ; } savingdisabled = _bool ; isopen = _bool ; log . i ( tag , _str ) ; } finally { loadinglock . unlock ( ) ; } }	saves and closes the track.
protected int selectoperator ( ) { lastupdate ++ ; if ( ( lastupdate >= update_window ) || ( probabilities == null ) ) { lastupdate = _num ; probabilities = getoperatorprobabilities ( ) ; } double rand = prng . nextdouble ( ) ; double sum = _num ; for ( int i = _num ; i < operators . size ( ) ; i ++ ) { sum += probabilities [ i ] ; if ( sum > rand ) { return i ; } } throw new illegalstateexception ( ) ; }	returns the index of one of the available operators randomly selected using the probabilities .
@ override public list chunkstring ( string stochunk ) { integer [ ] ires = splitpointsbydelimiterlist ( stochunk , getdelimiters ( ) ) ; string [ ] sres = splitstringbydelimiterpoints ( stochunk , ires ) ; return arrays . aslist ( sres ) ; }	returns a list of string chunks , derived from a given string .
public static string convertbooleanarrtostring ( boolean [ ] nodictionarydimsmapping ) { stringbuilder builder = new stringbuilder ( ) ; int index = _num ; for ( ; index < nodictionarydimsmapping . length ; index ++ ) { builder . append ( nodictionarydimsmapping [ index ] ) ; builder . append ( carboncommonconstants . coma_spc_character ) ; } int lastindex = builder . lastindexof ( carboncommonconstants . coma_spc_character ) ; string str = - _num != lastindex ? builder . substring ( _num , lastindex ) : builder . tostring ( ) ; return str ; }	this method will convert boolean [ ] to string with comma separated.
public bytebuffer decodebuffertobytebuffer ( string inputstring ) throws ioexception { return bytebuffer . wrap ( decodebuffer ( inputstring ) ) ; }	decode the contents of the string into a bytebuffer .
public void clear ( ) { m_model . clear ( ) ; setbuttons ( null ) ; }	clears the content of the panel.
public static int brighter ( int c ) { int r = red ( c ) , g = green ( c ) , b = blue ( c ) ; int i = ( int ) ( _num / ( _num - scale ) ) ; if ( r == _num && g == _num && b == _num ) { return rgba ( i , i , i , alpha ( c ) ) ; } if ( r > _num && r < i ) r = i ; if ( g > _num && g < i ) g = i ; if ( b > _num && b < i ) b = i ; return rgba ( math . min ( _num , ( int ) ( r / scale ) ) , math . min ( _num , ( int ) ( g / scale ) ) , math . min ( _num , ( int ) ( b / scale ) ) , alpha ( c ) ) ; }	get a brighter shade of an input color .
public void shutdown ( ) { running = _bool ; if ( networkthreads != null ) { for ( networkthread n : networkthreads ) { n . stopped = _bool ; } } networkthreads = null ; synchronized ( lock ) { lock . notifyall ( ) ; } }	shuts down the network thread , this will trigger failures if you have network requests.
public serialmessage ( byte [ ] a ) { super ( string . valueof ( a ) ) ; setbinary ( _bool ) ; }	this ctor interprets the byte array as a sequence of characters to send .
@ override @ suppresswarnings ( _str ) public void completed ( int bytestransferred , boolean caninvokedirect ) { if ( bytestransferred == _num ) { bytestransferred = - _num ; } else { updatebuffers ( bytestransferred ) ; } releasebuffers ( ) ; synchronized ( result ) { if ( result . isdone ( ) ) return ; enablereading ( ) ; if ( scatteringread ) { result . setresult ( ( v ) long . valueof ( bytestransferred ) ) ; } else { result . setresult ( ( v ) integer . valueof ( bytestransferred ) ) ; } } if ( caninvokedirect ) { invoker . invokeunchecked ( result ) ; } else { invoker . invoke ( result ) ; } }	executed when the i / o has completed.
public void writegolomb ( int divisor , int value ) { int q = value / divisor ; for ( int i = _num ; i < q ; i ++ ) { writebit ( _num ) ; } writebit ( _num ) ; int r = value - q * divisor ; int bit = _num - integer . numberofleadingzeros ( divisor - _num ) ; if ( r < ( ( _num << bit ) - divisor ) ) { bit -- ; } else { r += ( _num << bit ) - divisor ; } for ( ; bit >= _num ; bit -- ) { writebit ( ( r > > > bit ) & _num ) ; } }	write the golomb code of a value .
public void addforce ( force f ) { if ( f . isitemforce ( ) ) { if ( iforces . length == iflen ) { force [ ] newf = new force [ iflen + _num ] ; system . arraycopy ( iforces , _num , newf , _num , iforces . length ) ; iforces = newf ; } iforces [ iflen ++ ] = f ; } if ( f . isspringforce ( ) ) { if ( sforces . length == sflen ) { force [ ] newf = new force [ sflen + _num ] ; system . arraycopy ( sforces , _num , newf , _num , sforces . length ) ; sforces = newf ; } sforces [ sflen ++ ] = f ; } }	add a new force function to the simulator .
private static metricvalue number_to_metric_value_ ( number elem ) { if ( elem == null ) return metricvalue . empty ; final string num = elem . tostring ( ) ; try { return metricvalue . fromintvalue ( long . parselong ( num ) ) ; } catch ( numberformatexception ex ) { } try { return metricvalue . fromdblvalue ( double . parsedouble ( num ) ) ; } catch ( numberformatexception ex ) { } return metricvalue . fromstrvalue ( num ) ; }	work around for google gson parser emitting numbers as ' lazily parsed ' numbers .
public boolean overlaps ( string sequence , int start , int end ) { if ( start == missing || end == missing || end < start ) { throw new illegalargumentexception ( ) ; } if ( ! msequence . equals ( sequence ) ) { return _bool ; } if ( ( mend != missing && start >= mend ) || ( end <= mstart ) ) { return _bool ; } return _bool ; }	test whether the specified range overlaps the current region.
public okapibm25 ( double k1 , double b ) { if ( double . isnan ( k1 ) || double . isinfinite ( k1 ) || k1 < _num ) throw new illegalargumentexception ( _str + k1 ) ; this . k1 = k1 ; if ( double . isnan ( b ) || b < _num || b > _num ) throw new illegalargumentexception ( _str + b ) ; this . b = b ; }	creates a new okapi object.
protected void prepare ( ) { for ( processinfoparameter para : getparameter ( ) ) { string name = para . getparametername ( ) ; if ( para . getparameter ( ) == null ) ; else if ( name . equals ( param_m_warehouse_id ) ) p_m_warehouse_id = para . getparameterasint ( ) ; else log . log ( level . severe , _str + name ) ; } p_c_invoice_id = getrecord_id ( ) ; }	prepare - e . g . , get parameters .
public boolean isconfigured ( ) { log . debug ( _str + url ) ; return url != null && ! url . isempty ( ) ; }	method to quickly indicate if the service is not configured .
public static string [ ] commadelimitedlisttostringarray ( string str ) { return delimitedlisttostringarray ( str , _str ) ; }	convert a csv list into an array of strings .
@ override public byte [ ] readbytearray ( string filepath , long offset , int length ) { filechannel filechannel = updatecache ( filepath ) ; bytebuffer bytebffer = read ( filechannel , length , offset ) ; return bytebffer . array ( ) ; }	this method will be used to read the byte array from file based on offset and length ( number of bytes ) need to read.
private static void fatalerror ( jnienvironment env , address messageaddress ) { if ( tracejni ) vm . syswrite ( _str ) ; runtimeentrypoints . checkjnicountdowntogc ( ) ; try { vm . syswrite ( jnigenerichelpers . createstringfromc ( messageaddress ) ) ; system . exit ( exit_status_jni_trouble ) ; } catch ( throwable unexpected ) { if ( tracejni ) unexpected . printstacktrace ( system . err ) ; system . exit ( exit_status_recursively_shutting_down ) ; } }	fatalerror : print a message and terminate the vm.
public boolean makebackupfile ( string directory , file file ) { if ( file == null ) { log . info ( _str ) ; } else if ( file . canwrite ( ) ) { string backupfullname = directory + file . separator + createfilenamewithdate ( file . getname ( ) ) ; if ( log . isdebugenabled ( ) ) { log . debug ( _str + backupfullname ) ; } file backupfile = findfile ( backupfullname ) ; if ( backupfile != null ) { if ( backupfile . delete ( ) ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str + backupfullname ) ; } } } else { backupfile = new file ( backupfullname ) ; } file parentdir = backupfile . getparentfile ( ) ; if ( ! parentdir . exists ( ) ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str + parentdir . getname ( ) ) ; } if ( ! parentdir . mkdirs ( ) ) { log . error ( _str ) ; return _bool ; } } if ( file . renameto ( new file ( backupfullname ) ) ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str + backupfullname ) ; } } else { if ( log . isdebugenabled ( ) ) { log . debug ( _str + backupfullname ) ; } return _bool ; } } return _bool ; }	move original file to backup directory .
public final void pushpair ( int v1 , int v2 ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapsize = m_blocksize ; } else { if ( ( m_firstfree + _num ) >= m_mapsize ) { m_mapsize += m_blocksize ; int newmap [ ] = new int [ m_mapsize ] ; system . arraycopy ( m_map , _num , newmap , _num , m_firstfree ) ; m_map = newmap ; } } m_map [ m_firstfree ] = v1 ; m_map [ m_firstfree + _num ] = v2 ; m_firstfree += _num ; }	push a pair of nodes into the stack.
public void removestorage ( ) throws backupexception { logger . debug ( _str + datadirspec . getabsolutepath ( ) ) ; processhelper . exec ( _str , rmcmd ) ; }	clears storage in preparation for restore operation .
private void appendcontainerconfig ( dockerslavetemplate slavetemplate , createcontainercmd containerconfig ) { map < string , string > labels = containerconfig . getlabels ( ) ; if ( labels == null ) { labels = new hashmap < > ( ) ; } labels . put ( docker_cloud_label , getdisplayname ( ) ) ; labels . put ( docker_template_label , slavetemplate . getid ( ) ) ; containerconfig . withlabels ( labels ) ; }	cloud specific container config options.
readonlygamesettings ( ) { }	constructs game settings with default parameters.
public void deleteusers ( set users ) throws amexception , ssoexception { iterator iter = users . iterator ( ) ; while ( iter . hasnext ( ) ) { string userdn = ( string ) iter . next ( ) ; amuser user = new amuserimpl ( super . token , userdn ) ; user . delete ( ) ; } }	removes users from the organization .
@ override public boolean accept ( file file ) { string name = file . getname ( ) ; for ( string wildcard : wildcards ) { if ( filenameutils . wildcardmatch ( name , wildcard , casesensitivity ) ) { return _bool ; } } return _bool ; }	checks to see if the filename matches one of the wildcards .
public void removeregion ( region r ) { regions . remove ( r ) ; }	include a region in the model.
public static void silentcloseinputstream ( inputstream is ) { try { if ( is != null ) { is . close ( ) ; } } catch ( ioexception e ) { log . w ( log_tag , _str , e ) ; } }	a utility function to close an input stream without raising an exception .
@ override public void startelement ( string uri , string localname , string qname , attributes attributes ) throws saxexception { if ( requestid == null && localname . equals ( _str ) ) { requestid = attributes . getvalue ( _str ) ; } super . startelement ( uri , localname , qname , attributes ) ; }	this function fetches the requestid value of the batchrequest xml element and call the default implementation ( super ) .
public void stop ( int timeout ) throws interruptedexception { if ( ! isclosed . compareandset ( _bool , _bool ) ) { return ; } list < websocket > socketstoclose = null ; synchronized ( connections ) { socketstoclose = new arraylist < websocket > ( connections ) ; } for ( websocket ws : socketstoclose ) { ws . close ( closeframe . going_away ) ; } synchronized ( this ) { if ( selectorthread != null ) { if ( thread . currentthread ( ) != selectorthread ) { } if ( selectorthread != thread . currentthread ( ) ) { if ( socketstoclose . size ( ) > _num ) selectorthread . join ( timeout ) ; selectorthread . interrupt ( ) ; selectorthread . join ( ) ; } } } }	closes all connected clients sockets , then closes the underlying serversocketchannel , effectively killing the server socket selectorthread , freeing the port the server was bound to and stops all internal workerthreads.
public storage ( ) { this ( new file ( gettemporarystoragedirectorystring ( ) ) ) ; }	creates new instance of storage for storing temporary data.
protected void calculateitemwidth ( categoryplot plot , rectangle2d dataarea , int rendererindex , categoryitemrendererstate state ) { categoryaxis domainaxis = getdomainaxis ( plot , rendererindex ) ; categorydataset dataset = plot . getdataset ( rendererindex ) ; if ( dataset != null ) { int columns = dataset . getcolumncount ( ) ; int rows = state . getvisibleseriescount ( ) >= _num ? state . getvisibleseriescount ( ) : dataset . getrowcount ( ) ; double space = _num ; plotorientation orientation = plot . getorientation ( ) ; if ( orientation == plotorientation . horizontal ) { space = dataarea . getheight ( ) ; } else if ( orientation == plotorientation . vertical ) { space = dataarea . getwidth ( ) ; } double maxwidth = space * getmaximumitemwidth ( ) ; double categorymargin = _num ; double currentitemmargin = _num ; if ( columns > _num ) { categorymargin = domainaxis . getcategorymargin ( ) ; } if ( rows > _num ) { currentitemmargin = getitemmargin ( ) ; } double used = space * ( _num - domainaxis . getlowermargin ( ) - domainaxis . getuppermargin ( ) - categorymargin - currentitemmargin ) ; if ( ( rows * columns ) > _num ) { state . setbarwidth ( math . min ( used / ( rows * columns ) , maxwidth ) ) ; } else { state . setbarwidth ( math . min ( used , maxwidth ) ) ; } } }	calculates the bar width and stores it in the renderer state .
@ requirespermission ( manifest . permission . camera ) public camerasource start ( ) throws ioexception { synchronized ( mcameralock ) { if ( mcamera != null ) { return this ; } mcamera = createcamera ( ) ; if ( build . version . sdk_int >= build . version_codes . honeycomb ) { mdummysurfacetexture = new surfacetexture ( dummy_texture_name ) ; mcamera . setpreviewtexture ( mdummysurfacetexture ) ; } else { mdummysurfaceview = new surfaceview ( mcontext ) ; mcamera . setpreviewdisplay ( mdummysurfaceview . getholder ( ) ) ; } mcamera . startpreview ( ) ; issafetotakepicture = _bool ; mprocessingthread = new thread ( mframeprocessor ) ; mframeprocessor . setactive ( _bool ) ; mprocessingthread . start ( ) ; } return this ; }	opens the camera and starts sending preview frames to the underlying detector.
public void addbreakpointlistener ( final breakpointlistener listener ) { breakpointlisteners . add ( listener ) ; }	adds a breakpoint listener .
public void update ( graphics g ) { if ( isshowing ( ) ) { if ( ! ( peer instanceof lightweightpeer ) ) { g . clearrect ( _num , _num , width , height ) ; } paint ( g ) ; } }	updates the container . this forwards the update to any lightweight components that are children of this container . if this method is reimplemented , super . update ( g ) should be called so that lightweight components are properly rendered . if a child component is entirely clipped by the current clipping setting in g , update ( ) will not be forwarded to that child .
private void releasewaiters ( int phase ) { qnode q ; thread t ; atomicreference < qnode > head = ( phase & _num ) == _num ? evenq : oddq ; while ( ( q = head . get ( ) ) != null && q . phase != ( int ) ( root . state > > > phase_shift ) ) { if ( head . compareandset ( q , q . next ) && ( t = q . thread ) != null ) { q . thread = null ; locksupport . unpark ( t ) ; } } }	removes and signals threads from queue for phase .
public static dateformat todatetimeformat ( string datetimeformat , timezone tz , locale locale ) { dateformat df = null ; if ( utilvalidate . isempty ( datetimeformat ) ) { df = dateformat . getdatetimeinstance ( dateformat . short , dateformat . medium , locale ) ; } else { df = new simpledateformat ( datetimeformat , locale == null ? locale . getdefault ( ) : locale ) ; } df . settimezone ( tz ) ; return df ; }	returns an initialized dateformat object .
public static void printstacktrace ( throwable e ) { try { debug . printstacktrace ( e ) ; } catch ( throwable f ) { e . printstacktrace ( ) ; } }	used in environments where full debug may not be available.
@ override public void visittype ( typeelement e , void p ) { scan ( e . gettypeparameters ( ) , p ) ; checkcamelcase ( e , _bool ) ; super . visittype ( e , p ) ; return null ; }	check the name of a type and its enclosed elements and type parameters .
public block ( boolean multipush ) { this ( multipush , _str , null , arrays . aslist ( _str , _str ) ) ; }	create a new block with default style at ( startx , starty ).
private double poisson ( double x ) { return math . exp ( - m_lambda + ( x * math . log ( m_lambda ) ) - logfac ( x ) ) ; }	returns value for poisson distribution.
protected expression findexpression ( string source ) { if ( source != null && source . length ( ) > _num ) { source = source . trim ( ) ; if ( source . length ( ) == _num ) { return null ; } string leftside = source ; string rightside = null ; connector op = findop ( leftside ) ; if ( op != null ) { rightside = op . getrightside ( leftside ) ; leftside = leftside . substring ( _num , op . sourceloc ) ; expression leftexpression = findexpression ( leftside ) ; expression rightexpression = findexpression ( rightside ) ; if ( leftexpression != null ) { op . addexpr ( leftexpression ) ; } if ( rightexpression != null ) { op . addexpr ( rightexpression ) ; } return op ; } op = findminiop ( leftside ) ; if ( op != null ) { rightside = op . getrightside ( leftside ) ; leftside = leftside . substring ( _num , op . sourceloc ) ; expression leftexpression = findexpression ( leftside ) ; expression rightexpression = findexpression ( rightside ) ; if ( leftexpression != null ) { op . addexpr ( leftexpression ) ; } if ( rightexpression != null ) { op . addexpr ( rightexpression ) ; } return op ; } if ( logger . isloggable ( level . finer ) ) { logger . finer ( _str + source ) ; } return findmathop ( source ) ; } return null ; }	recursive parsing statement . keys on connectors ( and , or ) and builds expressions based on those . then looks for mini connectors ( and , or ) and builds on those . of course , there might just be one expression here , one that is separated by an operator .
void putchannel ( final storedclientchannel channel ) { putchannel ( channel , _bool ) ; }	adds the given channel to this set of stored states , broadcasting the contract and refund transactions when the channel expires and notifies the wallet of an update to this wallet extension.
private void deletefilesindir ( file dir ) { for ( file child : dir . listfiles ( ) ) { child . delete ( ) ; } }	deletes all files in a folder.
@ suppresswarnings ( _str ) public static void pipeinputtooutputstream ( inputstream in , file fileout , boolean ignoreerrors ) throws ioexception { if ( fileout == null ) { logger . error ( _str ) ; if ( ! ignoreerrors ) { throw new ioexception ( _str ) ; } } else { file parent = fileout . getparentfile ( ) ; if ( parent != null && ! parent . exists ( ) ) { parent . mkdirs ( ) ; } outputstream filestream = null ; try { filestream = new fileoutputstream ( fileout ) ; pipeinputtooutputstream ( in , filestream , _bool , ignoreerrors ) ; } catch ( ioexception e ) { if ( filestream != null ) { try { filestream . close ( ) ; } catch ( ioexception ex ) { logger . error ( _str , ex . getmessage ( ) ) ; } } if ( ! ignoreerrors ) { throw e ; } } } }	convenient way of sending data from an input stream to an output file in the most efficient way possible.
@ suppresslint ( _str ) void release ( ) { assert ( mprocessingthread . getstate ( ) == state . terminated ) ; mdetector . release ( ) ; mdetector = null ; }	releases the underlying receiver.
public static string trimleadingcharacter ( string str , char leadingcharacter ) { if ( ! haslength ( str ) ) { return str ; } stringbuilder sb = new stringbuilder ( str ) ; while ( sb . length ( ) > _num && sb . charat ( _num ) == leadingcharacter ) { sb . deletecharat ( _num ) ; } return sb . tostring ( ) ; }	trim all occurrences of the supplied leading character from the given string .
public e take ( ) throws interruptedexception { final reentrantlock lock = this . lock ; lock . lockinterruptibly ( ) ; long t = now ( ) ; tenantqueue . item item = null ; try { for ( ; ; ) { tenantqueue q = nextqueue ( t ) ; if ( q == null ) available . await ( ) ; else { long delay = q . next - t ; if ( delay <= _num ) { item = q . poll ( t ) ; return item == null ? null : item . element ; } else if ( leader != null ) available . await ( ) ; else { thread thisthread = thread . currentthread ( ) ; leader = thisthread ; try { available . awaitnanos ( delay ) ; } finally { if ( leader == thisthread ) leader = null ; } } } t = system . nanotime ( ) ; } } finally { if ( leader == null && hasnext ( ) ) available . signal ( ) ; lock . unlock ( ) ; done ( item , t ) ; } }	retrieves and removes the head of this queue , waiting if necessary until an element with an expired delay is available on this queue .
public boolean threadsafetimeout ( long delaytime , timeunit unit , action0 action ) { boolean scheduled = _bool ; thread currentthread = thread . currentthread ( ) ; if ( currentthread . equals ( dutythread ) ) { timerwheel . newtimeout ( delaytime , unit , null ) ; } else { scheduled = actions . offer ( null ) ; } return scheduled ; }	schedules timeout on the timerwheel in a thread - safe manner.
void submit ( processanddisplayimagetask task ) { initexecutorsifneed ( ) ; taskexecutorforcachedimages . execute ( task ) ; }	submits task to execution pool.
void addattributeselection ( string exp ) { int index = exp . indexof ( _str ) ; string value = null ; int constraint = attstring . equals ; if ( index != - _num ) { if ( index == _num ) { settagid ( tag_css_illegal_selector ) ; return ; } int opindex = index ; char c = exp . charat ( index - _num ) ; if ( c == _str ) { constraint = attstring . contains_word ; opindex -- ; } else if ( c == _str ) { constraint = attstring . begins_with ; opindex -- ; } value = exp . substring ( index + _num ) ; if ( ( ( value . startswith ( _str ) ) && ( value . endswith ( _str ) ) ) || ( ( value . startswith ( _str ) ) && ( value . endswith ( _str ) ) ) ) { value = value . substring ( _num , value . length ( ) - _num ) ; } exp = exp . substring ( _num , opindex ) ; } if ( attributeselections == null ) { attributeselections = new vector ( ) ; } attributeselections . addelement ( new attstring ( exp , constraint , value ) ) ; }	adds the given attribute selection.
private void createleftover ( ) { int linelengthbytes = currentlastbytepos + _num ; if ( linelengthbytes > _num ) { leftover = new byte [ linelengthbytes ] ; system . arraycopy ( data , _num , leftover , _num , linelengthbytes ) ; } else { leftover = null ; } currentlastbytepos = - _num ; }	creates the buffer containing any left over bytes .
public value sample ( ) { int index = sampler . nextint ( actionvalues . size ( ) ) ; if ( actionvaluesasarray == null ) { actionvaluesasarray = actionvalues . toarray ( new value [ actionvalues . size ( ) ] ) ; } return actionvaluesasarray [ index ] ; }	returns a sample point for the action , assuming a uniform distribution over the action values.
@ override public void channelclosed ( channelhandlercontext channelhandlercontext , channelstateevent channelstateevent ) throws exception { curr_conns . decrementandget ( ) ; channelgroup . remove ( channelhandlercontext . getchannel ( ) ) ; }	on close we manage some statistics , and remove this connection from the channel group .
private static void configureheadlesssimulation ( ) { system . setproperty ( _str , _str ) ; gama . setheadlessmode ( ) ; }	load in headless mode a specified model and create an experiment.
public static boolean isnextwindow ( uri id ) { return id == null || next . equals ( id ) ; }	determines if this id corresponds to the ' next ' execution window .
public static boolean isvisible ( class < ? > clazz , classloader classloader ) { if ( classloader == null ) { return _bool ; } try { class < ? > actualclass = classloader . loadclass ( clazz . getname ( ) ) ; return ( clazz == actualclass ) ; } catch ( classnotfoundexception ex ) { return _bool ; } }	check whether the given class is visible in the given classloader .
public byte [ ] remove ( queueevent event ) throws keeperexception , interruptedexception { timercontext time = stats . time ( dir + _str ) ; try { string path = event . getid ( ) ; string responsepath = dir + _str + response_prefix + path . substring ( path . lastindexof ( _str ) + _num ) ; if ( zookeeper . exists ( responsepath , _bool ) ) { zookeeper . setdata ( responsepath , event . getbytes ( ) , _bool ) ; } byte [ ] data = zookeeper . getdata ( path , null , null , _bool ) ; zookeeper . delete ( path , - _num , _bool ) ; return data ; } finally { time . stop ( ) ; } }	remove the event and save the response into the other path .
public propertyxmlbuilder ( serviceschema serviceschema , ammodel model , set attributeschemas ) throws smsexception , ssoexception { this . model = model ; this . servicename = serviceschema . getservicename ( ) ; getserviceresourcebundle ( serviceschema ) ; if ( servicebundle != null ) { maptypetoattributeschema = new hashmap ( attributeschemas . size ( ) * _num ) ; maptypetoattributeschema . put ( null_type , attributeschemas ) ; } }	returns a xml for displaying attribute in property sheet .
public boolean is ( string arg , boolean allowabbr ) { if ( name . equalsignorecase ( arg ) ) { return _bool ; } if ( allowabbr && arg . length ( ) == _num ) { if ( arg . charat ( _num ) == c ) { return _bool ; } } return _bool ; }	returns true if the atg string matches the name of the arg , or , if allowabbr is true , returns true if the arg length is one and it matches the first letter of the arg name .
static public void addall ( list < string > list , string [ ] array ) { for ( string item : array ) list . add ( item ) ; }	adds all items in the specific array to the specific list .
void remove ( supercardtoast supercardtoast ) { mlist . remove ( supercardtoast ) ; }	removes a supercardtoast from the list .
public void test_vmstat_header_and_data_parse ( ) { final pattern pattern = vmstatcollector . pattern ; final string header = _str ; final string data = _str ; { final string [ ] fields = pattern . split ( header . trim ( ) , _num ) ; for ( int i = _num ; i < fields . length ; i ++ ) { if ( log . isinfoenabled ( ) ) log . info ( _str + i + _str + fields [ i ] + _str ) ; } assertfield ( header , fields , _num , _str ) ; assertfield ( header , fields , _num , _str ) ; assertfield ( header , fields , _num , _str ) ; assertfield ( header , fields , _num , _str ) ; assertfield ( header , fields , _num , _str ) ; assertfield ( header , fields , _num , _str ) ; assertfield ( header , fields , _num , _str ) ; assertfield ( header , fields , _num , _str ) ; } { final string [ ] fields = pattern . split ( data . trim ( ) , _num ) ; assertfield ( data , fields , _num , _str ) ; assertfield ( data , fields , _num , _str ) ; assertfield ( data , fields , _num , _str ) ; assertfield ( data , fields , _num , _str ) ; assertfield ( data , fields , _num , _str ) ; assertfield ( data , fields , _num , _str ) ; assertfield ( data , fields , _num , _str ) ; assertfield ( data , fields , _num , _str ) ; } }	test based on some sample data .
public static secretkeys generatekeyfrompassword ( string password , string salt ) throws generalsecurityexception { return generatekeyfrompassword ( password , base64 . decode ( salt , base64_flags ) ) ; }	a function that generates password - based aes & hmac keys.
private string partiallyescapeassertionvalue ( string assertionvalue ) { stringbuilder sb = new stringbuilder ( assertionvalue . length ( ) ) ; for ( int j = _num ; j < assertionvalue . length ( ) ; j ++ ) { char c = assertionvalue . charat ( j ) ; if ( c == _str ) { sb . append ( c ) ; } else { sb . append ( filter . escapeassertionvalue ( string . valueof ( c ) ) ) ; } } return sb . tostring ( ) ; }	escapes the provided assertion value according to the ldap standard.
protected boolean filterleftoverview ( viewgroup parent , int childindex ) { parent . removeviewat ( childindex ) ; return _bool ; }	filter the child view at index and remove it if appropriate .
protected boolean declalreadydeclared ( string prefix ) { int startdecls = m_contextindexes . peek ( ) ; java . util . vector prefixmappings = m_prefixmappings ; int ndecls = prefixmappings . size ( ) ; for ( int i = startdecls ; i < ndecls ; i += _num ) { string prefixdecl = ( string ) prefixmappings . elementat ( i ) ; if ( prefixdecl == null ) continue ; if ( prefixdecl . equals ( prefix ) ) return _bool ; } return _bool ; }	check if a declaration has already been made for a given prefix .
@ override public void step ( messagelogger logger ) { try { addagent ( ) ; env . step ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }	executes one simulation step .
public static attackstatus calculatephysicalstatus ( creature attacker , creature attacked , boolean ismainhand ) { return calculatephysicalstatus ( attacker , attacked , ismainhand , _num , _num , _bool , _bool ) ; }	manage attack status rate.
public t vertexprocessor ( final biconsumer < vertex , map < string , object > > vertexprocessor ) { this . vertexprocessor = optional . ofnullable ( vertexprocessor ) ; return extendingclass . cast ( this ) ; }	the function supplied here may be called more than once per vertex depending on the implementation .
synchronized boolean release ( ) { d ( _str ) ; if ( state == busy ) { state = idle ; idlesince = system . currenttimemillis ( ) ; return _bool ; } else { return _bool ; } }	changes the state of a connectiondesc from busy to idle and records the current time so that we will know how long it has been idle .
private void validatereplicaavailability ( slice slice , string shard , string collectionname , int count ) { if ( slice != null ) { collection < replica > allreplicasforshard = slice . getreplicas ( ) ; if ( allreplicasforshard == null ) { throw new solrexception ( solrexception . errorcode . bad_request , _str + shard + _str + collectionname ) ; } if ( allreplicasforshard . size ( ) == _num ) { throw new solrexception ( solrexception . errorcode . bad_request , _str + shard + _str + collectionname + _str ) ; } if ( allreplicasforshard . size ( ) <= count ) { throw new solrexception ( solrexception . errorcode . bad_request , _str + shard + _str + collectionname + _str + count + _str + allreplicasforshard . size ( ) + _str ) ; } } }	validate if there is less replicas than requested to remove . also error out if there is only one replica available.
default classdeclaration asclass ( ) { throw new unsupportedoperationexception ( string . format ( _str , this ) ) ; }	return this as a classdeclaration or throw unsupportedoperationexception .
private static string partitionspectoname ( map < string , string > spec ) { stringbuilder sb = new stringbuilder ( ) ; for ( map . entry < string , string > entry : spec . entryset ( ) ) { if ( sb . length ( ) != _num ) { sb . append ( _str ) ; } sb . append ( entry . getkey ( ) + _str + entry . getvalue ( ) ) ; } return sb . tostring ( ) ; }	converts a map of partition key - value pairs to a name.
public static inputstream toinputstream ( charsequence input , charset encoding ) { return toinputstream ( input . tostring ( ) , encoding ) ; }	convert the specified charsequence to an input stream , encoded as bytes using the specified character encoding .
public void testhitendafterfind ( ) { hitendtest ( _bool , _str , _str , _str , _bool ) ; hitendtest ( _bool , _str , _str , _str , _bool ) ; hitendtest ( _bool , _str , _str , _str , _bool ) ; hitendtest ( _bool , _str , _str , _str , _bool ) ; hitendtest ( _bool , _str , _str , _str , _bool ) ; hitendtest ( _bool , _str , _str , _str , _bool ) ; string floatregex = gethexfloatregex ( ) ; hitendtest ( _bool , _str , floatregex , double . tohexstring ( - _num ) , _bool ) ; hitendtest ( _bool , _str , floatregex , _str + double . tohexstring ( double . nan ) + _str , _bool ) ; hitendtest ( _bool , _str , floatregex , double . tohexstring ( - _num ) + _str , _bool ) ; hitendtest ( _bool , _str , floatregex , _str + double . tohexstring ( double . min_value ) + _str , _bool ) ; hitendtest ( _bool , _str , _str , _str , _bool ) ; hitendtest ( _bool , _str , _str , _str , _bool ) ; }	regression test for harmony - 4396.
@ modifying @ transactional public void deletecheque ( @ pathvariable long chequeid ) { chequerepository . delete ( chequeid ) ; photorepository . deletebychequeid ( chequeid . tostring ( ) ) ; }	method deletecheque remove cheque from db by id.
public static synchronized double partialcorrelation ( tetradmatrix submatrix ) { try { tetradmatrix inverse = submatrix . inverse ( ) ; double a = - _num * inverse . get ( _num , _num ) ; double v0 = inverse . get ( _num , _num ) ; double v1 = inverse . get ( _num , _num ) ; double b = math . sqrt ( v0 * v1 ) ; return a / b ; } catch ( exception e ) { e . printstacktrace ( ) ; return double . nan ; } }	assumes that the given covariance matrix was extracted in such a way that the order of the variables ( in either direction ) is x , y , z1 ,.
public void addcolumn ( string name , string expr ) { expression ex = expressionparser . parse ( expr ) ; throwable t = expressionparser . geterror ( ) ; if ( t != null ) { throw new runtimeexception ( t ) ; } else { addcolumn ( name , ex ) ; } }	add a derived column to this table , using an expression instance to dynamically calculate the column data values .
public void addputandgettimenanos ( long duration ) { puttimenanos . addandget ( duration ) ; gettimenanos . addandget ( duration ) ; if ( delegate != null ) delegate . addputandgettimenanos ( duration ) ; }	increments put and get time accumulators .
private float checksaturationvalid ( final float val ) { float tempval = val ; if ( val > _num ) { tempval = _num ; } if ( val < _num ) { tempval = _num ; } return tempval ; }	check whether the specified saturation is valid or not .
string parse ( string cellstr , int layoutconstant ) { return cellstr . split ( layoutconstants . cell_ptrn ) [ layoutconstant ] ; }	utility method to parse a cell definition for a particular value .
public void pseudopropertychange ( string propname , object old , object n ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str + getsystemname ( ) + _str + propname + _str + n . tostring ( ) ) ; } firepropertychange ( propname , old , n ) ; }	call for circuit builder to make icon color changes for its gui.
public static string runcmd ( file directory , list < string > cmd , string errormessage ) throws exception { processbuilder pb = new processbuilder ( cmd ) ; pb . directory ( directory ) ; pb . redirecterrorstream ( _bool ) ; process p = pb . start ( ) ; string s ; stringbuilder sb = new stringbuilder ( ) ; bufferedreader stdout = new bufferedreader ( new inputstreamreader ( p . getinputstream ( ) ) ) ; while ( ( s = stdout . readline ( ) ) != null ) { logger . info ( s ) ; sb . append ( s ) ; sb . append ( _str ) ; } string sbs = sb . tostring ( ) ; int exitvalue = p . waitfor ( ) ; if ( exitvalue != _num ) throw new exception ( errormessage + _str + exitvalue + _str + sbs ) ; return sbs ; }	run command cmd in separate process in directory.
@ override public selectablechannel selectablechannel ( ) { return socketchannel ; }	returns the socketchannel underlying this socketcommchannel.
public void test_constructoriiiiii ( ) { date d1 = new date ( _num , _num , _num , _num , _num , _num ) ; date d2 = new date ( _num + d1 . gettimezoneoffset ( ) * _num * _num + _num * _num * _num + _num * _num + _num ) ; asserttrue ( _str , d1 . equals ( d2 ) ) ; }	java . util . date # date ( int , int , int , int , int , int ).
public static string fromtag ( bytearraytag tag ) { stringbuilder builder = new stringbuilder ( ) ; builder . append ( array_start ) ; boolean start = _bool ; for ( byte value : tag . getvalue ( ) ) { bytetag b = new bytetag ( value ) ; if ( start ) { start = _bool ; } else { builder . append ( element_seperator ) ; } builder . append ( fromtag ( b ) ) ; } builder . append ( array_end ) ; return builder . tostring ( ) ; }	creates a mojangson string from the given bytearray tag .
@ override protected void addchooserfilters ( jfilechooser chooser ) { javax . swing . filechooser . filenameextensionfilter filter = new javax . swing . filechooser . filenameextensionfilter ( bundle . getmessage ( _str , _str ) , _str , _str ) ; chooser . addchoosablefilefilter ( new javax . swing . filechooser . filenameextensionfilter ( _str , _str ) ) ; chooser . addchoosablefilefilter ( new javax . swing . filechooser . filenameextensionfilter ( _str , _str ) ) ; chooser . addchoosablefilefilter ( filter ) ; chooser . setfilefilter ( filter ) ; }	add filter ( s ) for possible types to the input file chooser .
private static byte [ ] windowsregenumvalue1 ( int hkey , int valueindex , int maxvaluenamelength ) { byte [ ] result = windowsregenumvalue ( hkey , valueindex , maxvaluenamelength ) ; if ( result != null ) { return result ; } else { long sleeptime = init_sleep_time ; for ( int i = _num ; i < max_attempts ; i ++ ) { try { thread . sleep ( sleeptime ) ; } catch ( interruptedexception e ) { return result ; } sleeptime *= _num ; result = windowsregenumvalue ( hkey , valueindex , maxvaluenamelength ) ; if ( result != null ) { return result ; } } } return result ; }	retries regenumvalueex ( ) max_attempts times before giving up .
public static datetime parserfc822 ( string str ) throws parseexception { date date ; synchronized ( datetimeformat822 ) { try { date = datetimeformat822 . parse ( str ) ; } catch ( java . text . parseexception e ) { throw new parseexception ( e ) ; } } return new datetime ( date ) ; }	parses the value as an rfc 822 date / time .
public model validatemodel ( dataset dataset , uri shapesgraphuri , resource minseverity , boolean validateshapes , function < rdfnode , string > labelfunction , progressmonitor monitor ) throws interruptedexception { if ( dataset . getdefaultmodel ( ) == null ) { throw new illegalargumentexception ( _str ) ; } model shapesmodel = dataset . getnamedmodel ( shapesgraphuri . tostring ( ) ) ; if ( monitor != null ) { monitor . subtask ( _str ) ; } list < property > constraintproperties = shaclutil . getallconstraintproperties ( validateshapes ) ; map < resource , list < shconstraint > > map = buildshape2constraintsmap ( shapesmodel , dataset . getdefaultmodel ( ) , constraintproperties , validateshapes ) ; if ( monitor != null ) { monitor . subtask ( _str ) ; } if ( monitor != null ) { monitor . begintask ( _str + map . size ( ) + _str , map . size ( ) ) ; } model results = jenautil . creatememorymodel ( ) ; results . setnsprefixes ( dataset . getdefaultmodel ( ) ) ; for ( resource shape : map . keyset ( ) ) { for ( shconstraint constraint : map . get ( shape ) ) { validateconstraintforshape ( dataset , shapesgraphuri , minseverity , constraint , shape , results , labelfunction , monitor ) ; if ( monitor != null ) { monitor . worked ( _num ) ; if ( monitor . iscanceled ( ) ) { throw new interruptedexception ( ) ; } } } } return results ; }	validates all resources in a given model , which is expected to be the default graph of a given dataset .
public pdfpage addannotation ( pdfannotation annotation ) { return addannotation ( - _num , annotation , _bool ) ; }	adds specified annotation to the end of annotations array and tagged it.
public static string findpreferredidp ( string realm , httpservletrequest request ) { if ( request == null ) { return null ; } string succinctid = request . getparameter ( ifsconstants . provider_id_key ) ; if ( ( succinctid == null ) || succinctid . length ( ) == _num ) { debug . message ( _str ) ; return null ; } succinctid = succinctid . trim ( ) ; string preferredsuccinctid = null ; stringtokenizer st = new stringtokenizer ( succinctid , _str ) ; while ( st . hasmoretokens ( ) ) { preferredsuccinctid = st . nexttoken ( ) ; if ( ( preferredsuccinctid . length ( ) < _num ) && st . hasmoretokens ( ) ) { preferredsuccinctid = preferredsuccinctid + _str + st . nexttoken ( ) ; } } preferredsuccinctid = samlutils . bytearraytostring ( base64 . decode ( preferredsuccinctid ) ) ; return getprovideridfromsuccinctid ( realm , preferredsuccinctid ) ; }	finds the preferred idp from the httpservletrequest .
private void checkandcreatedirectory ( final string directoryname ) { try { final file dir = new file ( directoryname ) ; if ( ! dir . exists ( ) && dir . mkdirs ( ) ) { _logger . debug ( _str ) ; } } catch ( exception ex ) { _logger . error ( _str , ex . getmessage ( ) ) ; } }	verify whether directory already exists or not.
@ safevarargs public final assertsubscriber < t > assertvalueswith ( consumer < t > ... expectations ) { if ( ! valuesstorage ) { throw new illegalstateexception ( _str ) ; } final int expectedvaluecount = expectations . length ; if ( expectedvaluecount != values . size ( ) ) { throw new assertionerror ( _str + expectedvaluecount + _str + valuecount , null ) ; } for ( int i = _num ; i < expectedvaluecount ; i ++ ) { consumer < t > consumer = expectations [ i ] ; t actualvalue = values . get ( i ) ; consumer . accept ( actualvalue ) ; } return this ; }	assert the specified values have been received in the declared order.
private boolean journalrebuildrequired ( ) { final int redundant_op_compact_threshold = _num ; return redundantopcount >= redundant_op_compact_threshold && redundantopcount >= lruentries . size ( ) ; }	we only rebuild the journal when it will halve the size of the journal and eliminate at least 2000 ops .
final public void println ( float v ) { string s = string . valueof ( v ) ; write ( s , _num , s . length ( ) ) ; println ( ) ; }	prints a float followed by a newline .
private static translationresult extractregister ( final itranslationenvironment environment , final long offset , final string subregister ) throws internaltranslationexception { final arraylist < reilinstruction > instructions = new arraylist < reilinstruction > ( ) ; final string parentregister = getparentregister ( subregister ) ; final operandsize archsize = environment . getarchitecturesize ( ) ; if ( ishigher8bitregister ( subregister ) ) { final string maskresult = environment . getnextvariablestring ( ) ; final string shiftresult = environment . getnextvariablestring ( ) ; instructions . add ( reilhelpers . createand ( offset , archsize , parentregister , operandsize . word , _str , operandsize . word , maskresult ) ) ; instructions . add ( reilhelpers . createbsh ( offset + _num , operandsize . word , maskresult , operandsize . word , _str , operandsize . byte , shiftresult ) ) ; return new translationresult ( shiftresult , operandsize . byte , translationresulttype . register , null , instructions , offset ) ; } else { final operandsize subregistersize = getregistersize ( subregister ) ; final string mask = string . valueof ( translationhelpers . getallbitsmask ( subregistersize ) ) ; final string result = environment . getnextvariablestring ( ) ; instructions . add ( reilhelpers . createand ( offset , archsize , parentregister , subregistersize , mask , subregistersize , result ) ) ; return new translationresult ( result , subregistersize , translationresulttype . register , null , instructions , offset ) ; } }	extracts a subregister ( like ax , al , ah ) from a parent register ( like eax ).
public void onloginfailure ( map requestparamsmap , httpservletrequest req , httpservletresponse res ) throws authenticationexception { debug . message ( _str ) ; }	post processing on failed authentication .
public interceptor [ ] buildmethodinterceptors ( method method ) { interceptors before = method . getannotation ( interceptors . class ) ; return before != null ? createinterceptors ( before ) : null_interceptor_array ; }	build interceptors of method.
static void removeallphis ( ir ir ) { for ( instruction s = ir . firstinstructionincodeorder ( ) , sentinel = ir . lastinstructionincodeorder ( ) , nextinstr = null ; s != sentinel ; s = nextinstr ) { nextinstr = s . nextinstructionincodeorder ( ) ; if ( phi . conforms ( s ) ) s . remove ( ) ; } }	remove all phi instructions from the ir .
protected int counttoken ( string token , string target ) { int tokenindex = _num ; int count = _num ; while ( tokenindex != - _num ) { tokenindex = target . indexof ( token , tokenindex ) ; if ( tokenindex > - _num ) { tokenindex ++ ; count ++ ; } } return count ; }	returns the number of times the token appears in the target .
private map < testcase , set < testfitnessfunction > > initializecoveragemapfromtests ( list < testcase > tests ) { map < testcase , set < testfitnessfunction > > testtogoals = new linkedhashmap < > ( ) ; for ( testcase test : tests ) { testtogoals . put ( test , filtersupportedgoals ( new linkedhashset < > ( test . getcoveredgoals ( ) ) ) ) ; } return testtogoals ; }	builds the name map based on coverage goal stored as covered in each of the tests.
public interceptor [ ] buildrouteinterceptors ( interceptor [ ] defaultinters , interceptor [ ] resourceinters , class < ? extends resource > resourceclass , interceptor [ ] methodinters , method method ) { list < interceptor > allinters = new arraylist < interceptor > ( ) ; for ( interceptor defaultinter : defaultinters ) { allinters . add ( defaultinter ) ; } for ( interceptor resourceinter : resourceinters ) { allinters . add ( resourceinter ) ; } for ( interceptor methodinter : methodinters ) { allinters . add ( methodinter ) ; } class < ? extends interceptor > [ ] resourceclears = getresourceclears ( resourceclass ) ; class < ? extends interceptor > [ ] methodclears = getmethodclears ( method ) ; if ( ( resourceclears != null && resourceclears . length > _num ) || ( methodclears != null && methodclears . length > _num ) ) { for ( int i = _num ; i < allinters . size ( ) ; i ++ ) { i = clearinterceptor ( allinters , resourceclears , i ) ; i = clearinterceptor ( allinters , methodclears , i ) ; } } return allinters . toarray ( new interceptor [ allinters . size ( ) ] ) ; }	build interceptors of action.
public static boolean checkgmlfootprint ( string footprint ) { try { configuration configuration = new gmlconfiguration ( ) ; parser parser = new parser ( configuration ) ; geometry geom = ( geometry ) parser . parse ( new inputsource ( new stringreader ( footprint ) ) ) ; if ( ! geom . isempty ( ) && ! geom . isvalid ( ) ) { logger . error ( _str ) ; return _bool ; } } catch ( exception e ) { logger . error ( _str + e . getmessage ( ) ) ; return _bool ; } return _bool ; }	check gml footprint validity.
public static void main ( string [ ] args ) { double prebuffer = double . parsedouble ( args [ _num ] ) ; double postbuffer = double . parsedouble ( args [ _num ] ) ; run ( args [ _num ] , args [ _num ] , args [ _num ] , args [ _num ] , prebuffer , postbuffer ) ; }	creates a timetable ( network change events file ).
public static double quantile ( double p , double k , double theta , double shift ) { return math . exp ( gammadistribution . quantile ( p , k , theta ) ) + shift ; }	compute probit ( inverse cdf ) for loggamma distributions .
public static cipherparameters makepbemacparameters ( bcpbekey pbekey , algorithmparameterspec spec ) { if ( ( spec == null ) || ! ( spec instanceof pbeparameterspec ) ) { throw new illegalargumentexception ( _str ) ; } pbeparameterspec pbeparam = ( pbeparameterspec ) spec ; pbeparametersgenerator generator = makepbegenerator ( pbekey . gettype ( ) , pbekey . getdigest ( ) ) ; byte [ ] key = pbekey . getencoded ( ) ; cipherparameters param ; if ( pbekey . shouldtrywrongpkcs12 ( ) ) { key = new byte [ _num ] ; } generator . init ( key , pbeparam . getsalt ( ) , pbeparam . getiterationcount ( ) ) ; param = generator . generatederivedmacparameters ( pbekey . getkeysize ( ) ) ; for ( int i = _num ; i != key . length ; i ++ ) { key [ i ] = _num ; } return param ; }	generate a pbe based key suitable for a mac algorithm , the key size is chosen according the mac size , or the hashing algorithm , whichever is greater .
public orioneditorinit ( final texteditorconfiguration configuration , final codeassistantfactory codeassistantfactory , final quickassistassistant quickassist , final orioneditorpresenter texteditor ) { this . configuration = configuration ; this . codeassistantfactory = codeassistantfactory ; this . quickassist = quickassist ; this . texteditor = texteditor ; }	the quick assist assistant .
final void putbyte ( int offset , byte value ) { unsafe . putbyte ( offset + address , value ) ; }	writes a byte at the specified offset from this native object ' s base address .
public final void addvalidationerror ( string error ) { validationerrors . add ( error ) ; }	add a new validation error to the accumulating validation errors.
public static void parseoptionsettingto ( string optionsetting , map < string , string > dst ) { int eqindex = optionsetting . indexof ( _str ) ; if ( eqindex == - _num ) { throw new internalerror ( _str + optionsetting ) ; } dst . put ( optionsetting . substring ( _num , eqindex ) , optionsetting . substring ( eqindex + _num ) ) ; }	parses a given option setting string to a map of settings .
public biginteger generateclientcredentials ( byte [ ] salt , byte [ ] identity , byte [ ] password ) { this . x = srp6util . calculatex ( digest , n , salt , identity , password ) ; this . a = selectprivatevalue ( ) ; this . a = g . modpow ( a , n ) ; return a ; }	generates client ' s credentials given the client ' s salt , identity and password.
public void build ( solrcore core , solrindexsearcher searcher ) throws ioexception { log . info ( _str + name + _str ) ; dictionary = dictionaryfactory . create ( core , searcher ) ; lookup . build ( dictionary ) ; if ( storedir != null ) { file target = getstorefile ( ) ; if ( ! lookup . store ( new fileoutputstream ( target ) ) ) { log . error ( _str ) ; } else { log . info ( _str + target . getabsolutepath ( ) ) ; } } }	build the underlying lucene suggester.
public void start ( string json ) { guidedtoursteps . clear ( ) ; guidedtourconfiguration configuration = dtofactory . createdtofromjson ( json , guidedtourconfiguration . class ) ; log . setdebugmode ( configuration . getdebugmode ( ) ) ; this . guidedtoursteps = configuration . getsteps ( ) ; this . tourname = configuration . getname ( ) ; if ( this . tourname == null || tourname . isempty ( ) ) { tourname = _str ; } this . haswelcomestep = configuration . gethaswelcomestep ( ) ; starttour ( ) ; }	loads the given json data and start the tour.
private static void runrandomtest ( final int wordlength , final int bytepadding , final int wordcount ) { final long seed = randomlong ( ) ; final random random = new random ( seed ) ; final random verificationrandom = new random ( seed ) ; final long wordmask ; if ( wordlength == _num ) { wordmask = ~ _num ; } else { wordmask = ( _num << wordlength ) - _num ; } final bigendianascendingwordserializer serializer = new bigendianascendingwordserializer ( wordlength , wordcount , bytepadding ) ; for ( int i = _num ; i < wordcount ; i ++ ) { final long value = random . nextlong ( ) & wordmask ; serializer . writeword ( value ) ; } final byte [ ] bytes = serializer . getbytes ( ) ; final bigendianascendingworddeserializer deserializer = new bigendianascendingworddeserializer ( wordlength , bytepadding , bytes ) ; assertequals ( deserializer . totalwordcount ( ) , wordcount ) ; for ( int i = _num ; i < wordcount ; i ++ ) { assertequals ( deserializer . readword ( ) , ( verificationrandom . nextlong ( ) & wordmask ) ) ; } }	runs a test which serializes and deserializes random word values .
public void addlistener ( t listener ) { if ( listener == null ) { throw new nullpointerexception ( ) ; } listeners . add ( listener ) ; }	registers a listener to receive events .
private float clampmag ( float value , float absmin , float absmax ) { final float absvalue = math . abs ( value ) ; if ( absvalue < absmin ) return _num ; if ( absvalue > absmax ) return value > _num ? absmax : - absmax ; return value ; }	clamp the magnitude of value for absmin and absmax.
@ override public void handleclick ( int x , int y , plotrenderinginfo info ) { }	handles a ' click ' on the plot by updating the anchor values.
private void adjustbcindex ( instruction barrier ) { normalmethod source = barrier . position ( ) . method ; if ( source . isforosrspecialization ( ) ) { barrier . adjustbytecodeindex ( - source . getosrprologuelength ( ) ) ; } }	the osrbarrier instruction is not in ir , so the bc index was not adjusted in osr_adjustbcindex .
@ override public string tostring ( ) { stringbuilder risul = new stringbuilder ( _num ) ; risul . append ( _str ) ; risul . append ( _str ) ; return risul . tostring ( ) ; }	used to have some meaningful info on this object mostly used for beanshell.
public static long [ ] interpose ( long [ ] vector , int vectorlen , int offset , int len ) { long [ ] updated = create ( vectorlen + len ) ; int idx = offset > > _num ; system . arraycopy ( vector , _num , updated , _num , idx ) ; if ( idx < vector . length ) { int delta = offset & _num ; updated [ idx ] |= vector [ idx ] & maskbelow ( delta ) ; } copy ( vector , offset , updated , offset + len , vectorlen - offset ) ; return updated ; }	returns a copy of the vector , with an empty bit range inserted at the specified location .
public static file createtemporarydirectory ( string prefix ) { while ( _bool ) { string candidatename = prefix + temporary_directory_prng . nextint ( ) ; file result = new file ( system . getproperty ( _str ) , candidatename ) ; if ( result . mkdir ( ) ) { return result ; } } }	creates a unique new temporary directory under " java.
task < void > synchronizeallauthdataasync ( ) { map < string , map < string , string > > authdata ; synchronized ( mutex ) { if ( ! iscurrentuser ( ) ) { return task . forresult ( null ) ; } authdata = getauthdata ( ) ; } list < task < void > > tasks = new arraylist < > ( authdata . size ( ) ) ; for ( string authtype : authdata . keyset ( ) ) { tasks . add ( synchronizeauthdataasync ( authtype ) ) ; } return task . whenall ( tasks ) ; }	ensures that all auth sources have auth data ( e.
public static element createelementinencryptionspace ( document doc , string elementname ) { if ( doc == null ) { throw new runtimeexception ( _str ) ; } if ( ( xencprefix == null ) || ( xencprefix . length ( ) == _num ) ) { return doc . createelementns ( encryptionconstants . encryptionspecns , elementname ) ; } return doc . createelementns ( encryptionconstants . encryptionspecns , xencprefix + _str + elementname ) ; }	creates an element in the xml encryption specification namespace .
void scrapactiveviews ( ) { final view [ ] activeviews = mactiveviews ; final boolean multiplescraps = mviewtypecount > _num ; arraylist < view > scrapviews = mcurrentscrap ; final int count = activeviews . length ; for ( int i = count - _num ; i >= _num ; i -- ) { final view victim = activeviews [ i ] ; if ( victim != null ) { final layoutparams lp = ( layoutparams ) victim . getlayoutparams ( ) ; activeviews [ i ] = null ; final boolean scraphastransientstate = viewcompat . hastransientstate ( victim ) ; int viewtype = lp . viewtype ; if ( ! shouldrecycleviewtype ( viewtype ) || scraphastransientstate ) { if ( viewtype != item_view_type_header_or_footer || scraphastransientstate ) { removedetachedview ( victim , _bool ) ; } if ( scraphastransientstate ) { if ( mtransientstateviews == null ) { mtransientstateviews = new sparsearraycompat < view > ( ) ; } mtransientstateviews . put ( mfirstactiveposition + i , victim ) ; } continue ; } if ( multiplescraps ) { scrapviews = mscrapviews [ viewtype ] ; } lp . position = mfirstactiveposition + i ; scrapviews . add ( victim ) ; } } prunescrapviews ( ) ; }	move all views remaining in mactiveviews to mscrapviews .
private void drawwind ( canvas canvas , float y , float xoffset ) { float cof = ( mscreenwidth + xoffset ) / ( loading_animation_coefficient / slow_down_animation_coefficient ) ; float time = mloadinganimationtime ; if ( mlastanimationtime - mloadinganimationtime > _num ) { minversedirection = _bool ; time = ( loading_animation_coefficient / slow_down_animation_coefficient ) - mloadinganimationtime ; } else { mnewwindset = _bool ; minversedirection = _bool ; } float x = ( mscreenwidth - ( time * cof ) ) + xoffset - mwindlinewidth ; float xend = x + mwindlinewidth ; canvas . drawline ( x , y , xend , y , mwindpaint ) ; }	draw wind on loading animation.
private boolean hasproxysettings ( properties settings ) { string proxyhost = settings . getproperty ( _str , null ) ; return proxyhost != null && proxyhost . length ( ) > _num ; }	checks if we have proxy configuration settings in the properties .
public boolean equalsdefault ( ) { return ( double . doubletolongbits ( value ) == _num ) ; }	check if the expression is equal to its default static value.
public static map < string , string > parsekeyandvaluetomap ( string source , boolean ignorespace ) { return parsekeyandvaluetomap ( source , default_key_and_value_separator , default_key_and_value_pair_separator , ignorespace ) ; }	parse key - value pairs to map , ignore empty key.
@ override protected void onsizechanged ( int w , int h , int oldw , int oldh ) { super . onsizechanged ( w , h , oldw , oldh ) ; setupbounds ( w , h ) ; setuppaints ( ) ; invalidate ( ) ; }	use onsizechanged instead of onattachedtowindow to get the dimensions of the view , because this method is called after measuring the dimensions of match_parent & wrap_content.
private void neednewbuffer ( int newcount ) { if ( currentbufferindex < buffers . size ( ) - _num ) { filledbuffersum += currentbuffer . length ; currentbufferindex ++ ; currentbuffer = buffers . get ( currentbufferindex ) ; } else { int newbuffersize ; if ( currentbuffer == null ) { newbuffersize = newcount ; filledbuffersum = _num ; } else { newbuffersize = math . max ( currentbuffer . length << _num , newcount - filledbuffersum ) ; filledbuffersum += currentbuffer . length ; } currentbufferindex ++ ; currentbuffer = new byte [ newbuffersize ] ; buffers . add ( currentbuffer ) ; } }	makes a new buffer available either by allocating a new one or re - cycling an existing one .
@ nullable public static websiteaddress create ( string originorhostorpattern ) { if ( originorhostorpattern == null || originorhostorpattern . isempty ( ) ) { return null ; } if ( originorhostorpattern . startswith ( any_subdomain_pattern ) ) { string origin = null ; string scheme = null ; string host = originorhostorpattern . substring ( any_subdomain_pattern . length ( ) ) ; boolean omitprotocolandport = _bool ; return new websiteaddress ( originorhostorpattern , origin , scheme , host , omitprotocolandport ) ; } if ( originorhostorpattern . indexof ( scheme_suffix ) != - _num ) { uri uri = uri . parse ( originorhostorpattern ) ; string origin = trimtrailingbackslash ( originorhostorpattern ) ; boolean omitprotocolandport = http_scheme . equals ( uri . getscheme ( ) ) && ( uri . getport ( ) == - _num || uri . getport ( ) == _num ) ; return new websiteaddress ( originorhostorpattern , origin , uri . getscheme ( ) , uri . gethost ( ) , omitprotocolandport ) ; } string origin = null ; string scheme = null ; boolean omitprotocolandport = _bool ; return new websiteaddress ( originorhostorpattern , origin , scheme , originorhostorpattern , omitprotocolandport ) ; }	creates a new websiteaddress from | originorhostorpattern | .
public void test_filter_001 ( ) throws ioexception { final file basefile = file . createtempfile ( getname ( ) , _str ) ; try { final string basename = basefile . tostring ( ) ; final nameandextensionfilter logfilter = new nameandextensionfilter ( basename , _str ) ; assertsamefiles ( new file [ ] { } , logfilter . getfiles ( ) ) ; } finally { basefile . delete ( ) ; } }	test verifies that no files are found using a guarenteed unique basename .
public void resettelemissileattacks ( ) { pendingtelemissileattacks . removeallelements ( ) ; }	resets the pending rams list .
public int addpadding ( byte [ ] in , int inoff ) { byte code = ( byte ) ( in . length - inoff ) ; while ( inoff < ( in . length - _num ) ) { in [ inoff ] = ( byte ) random . nextint ( ) ; inoff ++ ; } in [ inoff ] = code ; return code ; }	add the pad bytes to the passed in block , returning the number of bytes added .
public void addcommands ( pdfpage page , matrix extra ) { synchronized ( commands ) { addpush ( ) ; if ( extra != null ) { addxform ( extra ) ; } commands . addall ( page . getcommands ( ) ) ; addpop ( ) ; } updateimages ( ) ; }	add a collection of commands to the page list.
public string tostring ( ) { stringbuffer sb = new stringbuffer ( ) ; char [ ] separator = { _str , _str } ; int n = rows . length ; for ( int i = _num ; i < n ; i ++ ) { separator [ _num ] = _str ; for ( int j = _num ; j <= i ; j ++ ) { sb . append ( separator ) ; sb . append ( rows [ i ] [ j ] ) ; separator [ _num ] = _str ; } sb . append ( _str ) ; sb . append ( _str ) ; } return sb . tostring ( ) ; }	returns a string representation of the system .
public void addlast ( statementsequence statements ) { if ( statements != null ) { sequence . addall ( statements . sequence ) ; } }	adds a sequence of statements to the end of this sequence when the sequence object is not null , otherwise does nothing .
private void notifyactivitystatechanged ( bundle bundle ) { if ( ! mrecords . isempty ( ) ) { log . d ( tag , _str + mrecords . size ( ) ) ; synchronized ( mrecords ) { iterator < record > iterator = mrecords . iterator ( ) ; while ( iterator . hasnext ( ) ) { record record = ( record ) iterator . next ( ) ; fmradiolistener listener = record . mcallback ; if ( listener == null ) { iterator . remove ( ) ; return ; } listener . oncallback ( bundle ) ; } } } }	call back from service to activity.
public double elasticity ( final double spot ) { final double val = value ( ) ; final double del = delta ( spot ) ; if ( val > constants . ql_epsilon ) return del / val * spot ; else if ( math . abs ( del ) < constants . ql_epsilon ) return _num ; else if ( del > _num ) return double . max_value ; else return double . min_value ; }	sensitivity in percent to a percent change in the underlying spot price .
private byte [ ] entitytobytes ( httpentity entity , request request ) throws ioexception , servererror { poolingbytearrayoutputstream bytes = new poolingbytearrayoutputstream ( mpool , ( int ) entity . getcontentlength ( ) ) ; byte [ ] buffer = null ; try { inputstream in = entity . getcontent ( ) ; if ( in == null ) { throw new servererror ( ) ; } buffer = mpool . getbuf ( _num ) ; int progress = _num ; int count ; while ( ( count = in . read ( buffer ) ) != - _num ) { bytes . write ( buffer , _num , count ) ; progress += count ; request . progressupdate ( progress ) ; } return bytes . tobytearray ( ) ; } finally { try { entity . consumecontent ( ) ; } catch ( ioexception e ) { vincilog . d ( _str ) ; } mpool . returnbuf ( buffer ) ; bytes . close ( ) ; } }	reads the contents of httpentity into a byte [ ] .
@ override public foo fetchbyuuid_first ( string uuid , orderbycomparator < foo > orderbycomparator ) { list < foo > list = findbyuuid ( uuid , _num , _num , orderbycomparator ) ; if ( ! list . isempty ( ) ) { return list . get ( _num ) ; } return null ; }	returns the first foo in the ordered set where uuid = & # 63 ; .
public static float rounddecimal ( float value ) { return rounddecimal ( value , math . log10 ( int_precision ) ) ; }	static method to round a float value to the number of decimal places defined by decimal_places .
@ assistedinject public runnerimpl ( @ notnull runnerlocalizationconstant locale , @ notnull runnercounter runnercounter , @ notnull getenvironmentsutil util , @ notnull @ assisted runoptions runoptions , @ notnull @ assisted scope environmentscope , @ nullable @ assisted string environmentname ) { this . runoptions = runoptions ; this . ram = runoptions . getmemorysize ( ) ; this . title = runner_name + runnercounter . getrunnernumber ( ) + ( environmentname == null ? _str : _str + getcorrectname ( environmentname ) ) ; this . activetab = locale . runnertabconsole ( ) ; this . status = in_queue ; this . scope = environmentscope ; creationtime = system . currenttimemillis ( ) ; string environmentid = runoptions . getenvironmentid ( ) ; if ( environmentid == null || environmentid . startswith ( _str ) ) { this . type = util . gettype ( ) ; } else { this . type = util . getcorrectcategoryname ( runoptions . getenvironmentid ( ) ) ; } if ( environmentid != null ) { runoptions . setenvironmentid ( environmentid ) ; } }	this runner needs runner options ( user configurations ) and environment name ( inputted by user ).
public static boolean iswindowsme ( ) { return osname . indexof ( _str ) > - _num && osversion . equals ( _str ) ; }	is operating system windows me ?.
private string datetostring ( date input ) { if ( input == null ) { return null ; } else { return input . tostring ( ) ; } }	converts the input to a string with special missing value handling.
private static int componentsize ( component component , formspec formspec , int cellsize , formlayout . measure minmeasure , formlayout . measure prefmeasure ) { if ( formspec == null ) { return prefmeasure . sizeof ( component ) ; } else if ( formspec . getsize ( ) == sizes . minimum ) { return minmeasure . sizeof ( component ) ; } else if ( formspec . getsize ( ) == sizes . preferred ) { return prefmeasure . sizeof ( component ) ; } else { return math . min ( cellsize , prefmeasure . sizeof ( component ) ) ; } }	computes and returns the pixel size of the given component using the given form specification , measures , and cell size .
public static boolean issameelementtype ( astnode node1 , astnode node2 ) { return node1 != null && node2 != null && node1 . getelementtype ( ) == node1 . getelementtype ( ) ; }	checks if ielementtype of both nodes are the same.
public void appenddatato ( stringbuilder stringbuilder ) { stringbuilder . append ( buffer ) ; }	appends this node ' s text content to the given builder .
public static string tostring ( long l ) { if ( l < numbers_min || l > numbers_max ) { return long . tostring ( l , _num ) ; } return numbers [ ( int ) l ] ; }	cast a long value to a string.
@ override public synchronized void reset ( ) { pos = _num ; }	resets this stream to the beginning of the source string .
public static int readsinglebyte ( inputstream in ) throws ioexception { byte [ ] buffer = new byte [ _num ] ; int result = in . read ( buffer , _num , _num ) ; return ( result != - _num ) ? buffer [ _num ] & _num : - _num ; }	implements inputstream . read ( int ) in terms of inputstream . read ( byte [ ] , int , int ) . inputstream assumes that you implement inputstream . read ( int ) and provides default implementations of the others , but often the opposite is more efficient .
public static void write ( file file , charsequence data ) throws ioexception { write ( file , data , charset . defaultcharset ( ) , _bool ) ; }	writes a charsequence to a file creating the file if it does not exist using the default encoding for the vm .
protected boolean isidpproxyenabled ( fsauthnrequest authnrequest ) throws fsexception { if ( authnrequest . getminorversion ( ) != ifsconstants . ff_12_protocol_minor_version ) { return _bool ; } fsscoping scoping = authnrequest . getscoping ( ) ; if ( scoping != null && scoping . getproxycount ( ) == _num ) { return _bool ; } string enabledstring = idffmetautils . getfirstattributevaluefromconfig ( spconfig , ifsconstants . enable_idp_proxy ) ; if ( enabledstring != null && enabledstring . equalsignorecase ( _str ) ) { return _bool ; } else { return _bool ; } }	checks if the identity provider is configured for proxying the authentication requests for a requesting service provider .
private void compileprolog ( objectid prolog , file tempdir ) throws ioexception , compileexception { file temprules = copytotempfile ( prolog , tempdir ) ; try { compiler comp = new compiler ( ) ; comp . prologtojavasource ( temprules . getpath ( ) , tempdir . getpath ( ) ) ; } finally { temprules . delete ( ) ; } }	creates a copy of rules.
public spring removealllisteners ( ) { mlisteners . clear ( ) ; return this ; }	remove all of the listeners.
public selectioninputdialog ( window owner , string key , boolean editable , t [ ] selectionvalues , t initialselectionvalue , inputvalidator < t > inputvalidator , object ... keyarguments ) { this ( owner , key , selectionvalues , initialselectionvalue , inputvalidator , keyarguments ) ; combobox . seteditable ( editable ) ; }	create a selectioninputdialog whose combobox can be editable .
public void build ( solrcore core , solrindexsearcher searcher ) throws ioexception { log . info ( _str ) ; dictionary = dictionaryfactory . create ( core , searcher ) ; lookup . build ( dictionary ) ; if ( storedir != null ) { file target = new file ( storedir , factory . storefilename ( ) ) ; if ( ! lookup . store ( new fileoutputstream ( target ) ) ) { log . error ( _str ) ; } else { log . info ( _str + target . getabsolutepath ( ) ) ; } } }	build the underlying lucene suggester.
public static string convertclassnametoresourcepath ( string classname ) { assert . notnull ( classname , _str ) ; return classname . replace ( _str , _str ) ; }	convert a " . " - based fully qualified class name to a " / " - based resource path .
public uri ( string scheme , string schemespecificpart , string fragment ) throws urisyntaxexception { stringbuilder uri = new stringbuilder ( ) ; if ( scheme != null ) { uri . append ( scheme ) ; uri . append ( _str ) ; } if ( schemespecificpart != null ) { all_legal_encoder . appendencoded ( uri , schemespecificpart ) ; } if ( fragment != null ) { uri . append ( _str ) ; all_legal_encoder . appendencoded ( uri , fragment ) ; } parseuri ( uri . tostring ( ) , _bool ) ; }	creates a new uri instance of the given unencoded component parts .
private int addtopopulation ( solution solution ) { int id = nextfreeid ( ) ; solutions . put ( id , solution ) ; return id ; }	adds the specified solution to the population , returning its assigned identifier .
public byte [ ] tobytearray ( ) { return arrays . copyof ( buf , cnt ) ; }	creates a newly allocated byte array.
public void creatediskasync ( final string projectid , final diskcreatespec diskcreatespec , final futurecallback < task > responsecallback ) throws ioexception { final string path = string . format ( _str , getbasepath ( ) , projectid ) ; createobjectasync ( path , serializeobjectasjson ( diskcreatespec ) , responsecallback ) ; }	create a disk in the specified project .
@ override public boolean domainmatch ( final string host , final string domain ) { return host . endswith ( domain ) ; }	performs domain - match as described in the netscape draft .
public synchronized void disableattribute ( string name ) { enabledattributes . removeelement ( name ) ; }	disables all the attribute change notifications the attribute name of which equals the specified attribute name to be sent to the listener.
public void push ( final handle handle ) { mv . visitldcinsn ( handle ) ; }	generates the instruction to push a handle on the stack .
@ deprecated public static string encodepostbody ( bundle parameters , string boundary ) { if ( parameters == null ) return _str ; stringbuilder sb = new stringbuilder ( ) ; for ( string key : parameters . keyset ( ) ) { object parameter = parameters . get ( key ) ; if ( ! ( parameter instanceof string ) ) { continue ; } sb . append ( _str + key + _str + ( string ) parameter ) ; sb . append ( _str + _str + boundary + _str ) ; } return sb . tostring ( ) ; }	generate the multi - part post body providing the parameters and boundary string.
public static ifitsheader lookup ( string key ) { int keylength = key . length ( ) ; if ( keylength > _num && character . isdigit ( key . charat ( keylength - _num ) ) ) { stringbuilder builder = new stringbuilder ( ) ; for ( int index = _num ; index < keylength ; index ++ ) { char character = key . charat ( index ) ; if ( character . isdigit ( character ) ) { if ( builder . charat ( builder . length ( ) - _num ) != _str ) { builder . append ( _str ) ; } } else { builder . append ( character ) ; } } return standard_keys . get ( builder . tostring ( ) ) ; } return standard_keys . get ( key ) ; }	lookup a string key in the standard key sets .
@ override public void write ( kryo kryo , output output ) { int size = index . size ( ) ; output . writeint ( size + _num , _bool ) ; for ( int i = _num ; i < size ; ++ i ) { string s = index . get ( i ) ; if ( s == null ) { throw new runtimeexception ( _str + integer . tostring ( i ) ) ; } output . writestring ( s ) ; } }	custom serializer . follows kryo ' s stringarrayserializer example .
public final objectproperty < control > togglenodeproperty ( ) { return this . togglenode ; }	* public properties *.
private static int decodeoctets ( int i , bytebuffer bb , stringbuilder sb ) { if ( bb . limit ( ) == _num && ( bb . get ( _num ) & _num ) < _num ) { sb . append ( ( char ) bb . get ( _num ) ) ; return i + _num ; } else { charbuffer cb = utf_8_charset . decode ( bb ) ; sb . append ( cb . tostring ( ) ) ; return i + bb . limit ( ) * _num - _num ; } }	decodes octets to characters using the utf - 8 decoding and appends the characters to a stringbuffer .
public arrayfieldvector ( fieldvector < t > v1 , t [ ] v2 ) throws nullargumentexception { mathutils . checknotnull ( v1 ) ; mathutils . checknotnull ( v2 ) ; field = v1 . getfield ( ) ; final t [ ] v1data = ( v1 instanceof arrayfieldvector ) ? ( ( arrayfieldvector < t > ) v1 ) . data : v1 . toarray ( ) ; data = matharrays . buildarray ( field , v1data . length + v2 . length ) ; system . arraycopy ( v1data , _num , data , _num , v1data . length ) ; system . arraycopy ( v2 , _num , data , v1data . length , v2 . length ) ; }	construct a vector by appending one vector to another vector .
public void reverse ( ) { final arraylist < animator > animators = manimatedvectorstate . manimators ; final int size = animators . size ( ) ; for ( int i = _num ; i < size ; i ++ ) { final animator animator = animators . get ( i ) ; if ( canreverse ( animator ) ) { reverse ( animator ) ; } else { log . w ( log_tag , _str ) ; } } }	reverses ongoing animations or starts pending animations in reverse.
public void start ( ) { if ( slogger . isactivated ( ) ) { slogger . info ( _str ) ; } mcleanupexecutor = executors . newsinglethreadexecutor ( ) ; if ( ! mobserverisregistered ) { mcontactscontractobserver = new contactscontractobserver ( new handler ( ) ) ; mcontactscontractcursor = mcontentresolver . query ( phone . content_uri , null , null , null , null ) ; cursorutil . assertcursorisnotnull ( mcontactscontractcursor , phone . content_uri ) ; mcontactscontractcursor . registercontentobserver ( mcontactscontractobserver ) ; mobserverisregistered = _bool ; } }	start address book monitoring.
protected final void firevetoablechange ( string propertyname , double oldvalue , double newvalue ) throws propertyvetoexception { firevetoablechange ( propertyname , double . valueof ( oldvalue ) , double . valueof ( newvalue ) ) ; }	support for reporting changes for constrained integer properties.
public void testlmdirichlet ( ) throws ioexception { float p = ( freq + _num * ( total_term_freq + _num ) / ( number_of_field_tokens + _num ) ) / ( doc_len + _num ) ; float a = _num / ( doc_len + _num ) ; float gold = ( float ) ( math . log ( p / ( a * ( total_term_freq + _num ) / ( number_of_field_tokens + _num ) ) ) + math . log ( a ) ) ; correctnesstestcore ( new lmdirichletsimilarity ( ) , gold ) ; }	correctness test for the dirichlet lm model .
public void onsinksreceived ( string sourceurn , list < mediasink > sinks ) { msinks . put ( sourceurn , sinks ) ; nativeonsinksreceived ( mnativemediarouterandroid , sourceurn , sinks . size ( ) ) ; }	called when the sinks found by the media route provider for the particular | sourceurn | have changed .
public user toentity ( userdto dto ) { return toentity ( dto , _num ) ; }	converts the passed dto to a user.
protected void writeexternalforeignkeydropstmt ( table table , foreignkey foreignkey , stringbuilder ddl ) { writetablealterstmt ( table , ddl ) ; ddl . append ( _str ) ; printidentifier ( getforeignkeyname ( table , foreignkey ) , ddl ) ; printendofstatement ( ddl ) ; }	generates the statement to drop a foreignkey constraint from the database using an alter table statement .
public void obtain ( long timeout_ms ) throws ioexception , interruptedexception , timeoutexception { long quit_time = system . currenttimemillis ( ) + timeout_ms ; if ( filelock != null && filelock . isvalid ( ) ) { return ; } do { try { filelock = filetolock . trylock ( ) ; return ; } catch ( overlappingfilelockexception e ) { thread . sleep ( _num ) ; } } while ( system . currenttimemillis ( ) < quit_time ) ; throw new timeoutexception ( ) ; }	locks the file , with a timeout ( non - blocking ) .
@ deprecated public void pointtodata ( data o ) throws fitsexception { o . fillheader ( this ) ; }	create a header which points to the given data object .
@ notnull protected virtualfile [ ] collectaffectedfiles ( @ notnull project project , @ notnull virtualfile [ ] files ) { list < virtualfile > affectedfiles = new arraylist < virtualfile > ( files . length ) ; projectlevelvcsmanager projectlevelvcsmanager = projectlevelvcsmanager . getinstance ( project ) ; for ( virtualfile file : files ) { if ( ! file . isdirectory ( ) && projectlevelvcsmanager . getvcsfor ( file ) instanceof gitvcs ) { affectedfiles . add ( file ) ; } else if ( file . isdirectory ( ) && isrecursive ( ) ) { addchildren ( project , affectedfiles , file ) ; } } return vfsutilcore . tovirtualfilearray ( affectedfiles ) ; }	given a list of action - target files , returns all the files that should be subject to the action does not keep directories , but recursively adds directory contents.
public void updateposition ( particle particle , long elapsedtime ) { vector3f speed = particle . getspeed ( ) ; float delta = elapsedtime / _num ; float dx = speed . x * delta ; float dy = speed . y * delta ; float dz = speed . z * delta ; vector3f pos = particle . getposition ( ) ; particle . setposition ( pos . x + dx , pos . y + dy , pos . z + dz ) ; }	updates a particle position.
protected void update ( int length ) { ticklabelvalues . clear ( ) ; ticklabels . clear ( ) ; ticklabelpositions . clear ( ) ; if ( scale . islogscaleenabled ( ) ) { updateticklabelforlogscale ( length ) ; } else { updateticklabelforlinearscale ( length ) ; } updatetickvisibility ( ) ; updateticklabelmaxlengthandheight ( ) ; }	updates the tick labels .
private static boolean iswithinbounds ( visualposition targetposition , visualposition startposition , visualposition endposition ) { return targetposition . line >= startposition . line && targetposition . line <= endposition . line && targetposition . column >= startposition . column && targetposition . column <= endposition . column ; }	allows to answer if particular visual position belongs to visual rectangle identified by the given visual position of its top - left and bottom - right corners .
static public void assertstatementindicesconsistent ( final abstracttriplestore db , final int maxerrors ) { if ( log . isinfoenabled ( ) ) log . info ( _str ) ; final atomicinteger nerrs = new atomicinteger ( _num ) ; final int from , to ; if ( db . getspokeyarity ( ) == _num ) { from = spokeyorder . first_triple_index ; to = spokeyorder . last_triple_index ; } else { from = spokeyorder . first_quad_index ; to = spokeyorder . last_quad_index ; } for ( int i = from ; i <= to ; i ++ ) { for ( int j = from ; j <= to ; j ++ ) { if ( i <= j ) { continue ; } assertsamestatements ( db , spokeyorder . valueof ( i ) , spokeyorder . valueof ( j ) , nerrs , maxerrors ) ; } } assertequals ( _num , nerrs . get ( ) ) ; }	validates that the same statements are found in each of the statement indices .
public void show ( @ idres final int itemid ) { map . add ( itemid ) ; navigation . invalidatebadge ( itemid ) ; }	request to display a new badge over the passed menu item id.
public options put ( string option , integer value ) { if ( value == null ) { return remove ( option ) ; } options . put ( option , value . tostring ( ) ) ; return this ; }	put an option integer value .
private int determinetargetpage ( int currentpage , float pageoffset , int velocity , int deltax ) { int targetpage ; if ( math . abs ( deltax ) > flingdistance && math . abs ( velocity ) > minimumvelocity ) { if ( virtualpos < _num ) { targetpage = velocity > _num ? currentpage : currentpage + _num ; } else { targetpage = velocity > _num ? currentpage + _num : currentpage ; } } else { final float truncator = currentpage >= currentitem ? _num : _num ; targetpage = ( int ) ( currentpage + pageoffset + truncator ) ; } if ( items . size ( ) > _num ) { final iteminfo firstitem = items . get ( _num ) ; final iteminfo lastitem = items . get ( items . size ( ) - _num ) ; targetpage = math . max ( firstitem . position , math . min ( targetpage , lastitem . position ) ) ; } if ( targetpage > currentpage && oncardchangelistener != null ) { oncardchangelistener . oncarddismissed ( currentpage , virtualpos > _num ) ; } return targetpage ; }	figure out what the target page would be given current scroll and velocity .
protected string form ( objectmatrix1d matrix , int index , former formatter ) { object value = matrix . get ( index ) ; if ( value == null ) return _str ; return string . valueof ( value ) ; }	converts a given cell to a string ; no alignment considered .
public void clone ( vector3f source ) { system . arraycopy ( source . points , _num , points , _num , _num ) ; }	clone the input vector so that this vector has the same values .
public static string toregex ( string glob , string separator ) { checknotnull ( separator , _str ) ; checkargument ( separator . length ( ) == _num , _str , separator ) ; return toregex ( glob , separator . charat ( _num ) ) ; }	converts the given glob pattern into a regular expression .
protected void forcenoloss ( boolean value ) { }	should the data of this tile be forced to case no data loss.
public static string [ ] splitwithoutescaped ( string str , char separatorchar , boolean retainempty ) { int len = str . length ( ) ; if ( len == _num ) { return new string [ _num ] ; } list < string > list = new arraylist < string > ( ) ; int i = _num ; int start = _num ; boolean match = _bool ; while ( i < len ) { if ( str . charat ( i ) == _str ) { match = _bool ; i += _num ; } else if ( str . charat ( i ) == separatorchar ) { if ( retainempty || match ) { list . add ( str . substring ( start , i ) ) ; match = _bool ; } start = ++ i ; } else { match = _bool ; i ++ ; } } if ( retainempty || match ) { list . add ( str . substring ( start , i ) ) ; } return list . toarray ( new string [ list . size ( ) ] ) ; }	does not take into account escaped separators.
public void testsplitescapedsemicolons ( ) { properties inner = propertyutils . splitpropertiesonsemicolon ( propertyutils . escapebackslashesifnotnull ( _str ) ) ; assertequals ( _num , inner . size ( ) ) ; assertequals ( _str , inner . getproperty ( _str ) ) ; assertequals ( _str , inner . getproperty ( _str ) ) ; assertequals ( _str , inner . getproperty ( _str ) ) ; assertequals ( _str , inner . getproperty ( _str ) ) ; }	test split of escaped semicolons .
public static void removeobjectatoffset ( object [ ] sourcearray , object [ ] destinationarray , int offset ) { system . arraycopy ( sourcearray , _num , destinationarray , _num , offset ) ; system . arraycopy ( sourcearray , offset + _num , destinationarray , offset , sourcearray . length - offset - _num ) ; }	removes the object at the source array offset and copies all other objects to the destination array.
@ suppresswarnings ( _str ) public dictionaryadapter ( context context , file dbpath , string dbname , string defaulttable ) { mcontext = context ; mdbname = dbname ; mdefaulttable = defaulttable ; mdbpath = dbpath ; mdbfile = new file ( dbpath , mdbname ) ; if ( mdbfile . exists ( ) ) { open ( ) ; } }	open the database if it exists or create it if it doesn ' t.
public boolean istabassociatedwithnondestroyedactivity ( boolean isincognito , int tabid ) { list < weakreference < activity > > activities = applicationstatus . getrunningactivities ( ) ; for ( weakreference < activity > ref : activities ) { activity activity = ref . get ( ) ; if ( activity != null && isvalidactivity ( isincognito , activity . getintent ( ) ) && gettabidfromintent ( activity . getintent ( ) ) == tabid && ! isactivitydestroyed ( activity ) ) { return _bool ; } } return _bool ; }	check if the tab is associated with an activity that hasn ' t been destroyed.
httpstreamwrapper ( httpstream stream ) throws ioexception { _stream = stream ; }	create a new http stream .
public boolean handlefile ( file file ) { if ( debug ) { logger . fine ( _str + file . getabsolutepath ( ) ) ; } filenames . add ( file ) ; return _bool ; }	when a file is found , add it .
public boolean lookslikenumbercoming ( ) { if ( n >= s . length ( ) ) return _bool ; return character . isdigit ( s . charat ( n ) ) ; }	peeks the next char , without gobbling it.
public partialhull ( ipoint first , ipoint second ) { points . add ( first ) ; points . add ( second ) ; }	construct the initial partial hull .
public short readshort ( ) throws ioexception { return primitivetypes . readshort ( ) ; }	reads a short ( 16 bit ) from the source stream .
public void print ( int inum ) { print ( string . valueof ( inum ) ) ; }	prints the string representation of the specified integer to the target .
public static < nodetype extends iviewnode < ? > > zyproximitynode < ? > createproximitynode ( final graph2d graph , final zygraphnode < ? > attachednode , final int degree , final boolean isincoming ) { preconditions . checknotnull ( graph , _str ) ; preconditions . checknotnull ( attachednode , _str ) ; final zylabelcontent labelcontent = new zylabelcontent ( null ) ; labelcontent . addlinecontent ( new zylinecontent ( string . valueof ( degree ) , new font ( _str , font . plain , _num ) , null ) ) ; final zyproximitynoderealizer < nodetype > r = new zyproximitynoderealizer < nodetype > ( labelcontent ) ; final node node = graph . createnode ( r ) ; @ suppresswarnings ( _str ) final zyproximitynode < nodetype > infonode = new zyproximitynode < nodetype > ( node , r , ( zygraphnode < nodetype > ) attachednode , isincoming ) ; final zynodedata < zyproximitynode < nodetype > > data = new zynodedata < zyproximitynode < nodetype > > ( infonode ) ; r . setuserdata ( data ) ; return infonode ; }	creates a proximity browsing node .
public static boolean iszoningrequired ( dbclient dbclient , uri varrayuri ) { if ( varrayuri != null ) { virtualarray nh = dbclient . queryobject ( virtualarray . class , varrayuri ) ; if ( nh != null ) { return iszoningrequired ( dbclient , nh ) ; } } return _bool ; }	looks at the varray to see if zoning is disabled , and looks to make sure that there is at least one active networksystem registered .
public void reply ( list < string > responseheaders , boolean out ) throws ioexception { assert ( ! thread . holdslock ( spdystream . this ) ) ; boolean outfinished = _bool ; synchronized ( this ) { if ( responseheaders == null ) { throw new nullpointerexception ( _str ) ; } if ( islocallyinitiated ( ) ) { throw new illegalstateexception ( _str ) ; } if ( this . responseheaders != null ) { throw new illegalstateexception ( _str ) ; } this . responseheaders = responseheaders ; if ( ! out ) { this . out . finished = _bool ; outfinished = _bool ; } } connection . writesynreply ( id , outfinished , responseheaders ) ; }	sends a reply to an incoming stream .
protected ccanimation ( string name , float delay , arraylist < ccspriteframe > frames ) { delay_ = delay ; name_ = name ; frames_ = new arraylist < ccspriteframe > ( ) ; if ( frames != null ) frames_ . addall ( frames ) ; }	initializes a ccanimation with a name , delay and an array of ccspriteframes .
private void navigatetodump ( ) { treepath currentpath = tree . getselectionpath ( ) ; tree . setselectionpath ( currentpath . getparentpath ( ) ) ; tree . scrollpathtovisible ( currentpath . getparentpath ( ) ) ; }	navigate to root node of currently active dump.
public synchronized void addmessages ( arraylist < smsmmsmessage > newmessages ) { if ( newmessages != null ) { messages . addall ( _num , newmessages ) ; updatemessagecount ( ) ; } }	add a list of new messages to the end of the current message list .
public static cache . entry makerandomcacheentry ( byte [ ] data , boolean isexpired , boolean needsrefresh ) { random random = new random ( ) ; cache . entry entry = new cache . entry ( ) ; if ( data != null ) { entry . data = data ; } else { entry . data = new byte [ random . nextint ( _num ) ] ; } entry . etag = string . valueof ( random . nextlong ( ) ) ; entry . serverdate = random . nextlong ( ) ; entry . ttl = isexpired ? _num : long . max_value ; entry . softttl = needsrefresh ? _num : long . max_value ; return entry ; }	makes a random cache entry .
public int swap ( ) { if ( ! egl . eglswapbuffers ( egldisplay , eglsurface ) ) { return egl . eglgeterror ( ) ; } return egl10 . egl_success ; }	display the current render surface .
public static list < window > windows ( string words , int windowsize ) { stringtokenizer tokenizer = new stringtokenizer ( words ) ; list < string > list = new arraylist < string > ( ) ; while ( tokenizer . hasmoretokens ( ) ) list . add ( tokenizer . nexttoken ( ) ) ; return windows ( list , windowsize ) ; }	constructs a list of window of size windowsize.
public static string buildpath ( jsonpath jsonpath ) { list < string > urlparts = new linkedlist < > ( ) ; jsonpath currentjsonpath = jsonpath ; string pathpart ; do { if ( currentjsonpath instanceof relationshipspath ) { pathpart = relationship_mark + separator + currentjsonpath . getelementname ( ) ; } else if ( currentjsonpath instanceof fieldpath ) { pathpart = currentjsonpath . getelementname ( ) ; } else { pathpart = currentjsonpath . getelementname ( ) ; if ( currentjsonpath . getids ( ) != null ) { pathpart += separator + mergeids ( currentjsonpath . getids ( ) ) ; } } urlparts . add ( pathpart ) ; currentjsonpath = currentjsonpath . getparentresource ( ) ; } while ( currentjsonpath != null ) ; collections . reverse ( urlparts ) ; return separator + stringutils . join ( separator , urlparts ) + separator ; }	creates a path using the provided jsonpath structure .
private static object add ( final object array , final int index , final object element , final class < ? > clss ) { if ( array == null ) { if ( index != _num ) { throw new indexoutofboundsexception ( _str + index + _str ) ; } object joinedarray = array . newinstance ( clss , _num ) ; array . set ( joinedarray , _num , element ) ; return joinedarray ; } int length = array . getlength ( array ) ; if ( index > length || index < _num ) { throw new indexoutofboundsexception ( _str + index + _str + length ) ; } object result = array . newinstance ( clss , length + _num ) ; system . arraycopy ( array , _num , result , _num , index ) ; array . set ( result , index , element ) ; if ( index < length ) { system . arraycopy ( array , index , result , index + _num , length - index ) ; } return result ; }	underlying implementation of add ( array , index , element ) methods.
public double doublevalue ( ) { return d . doublevalue ( ) ; }	get the double value corresponding to the instance .
public string tomatlab ( ) { stringbuffer result ; int i ; int n ; result = new stringbuffer ( ) ; result . append ( _str ) ; for ( i = _num ; i < getrowdimension ( ) ; i ++ ) { if ( i > _num ) { result . append ( _str ) ; } for ( n = _num ; n < getcolumndimension ( ) ; n ++ ) { if ( n > _num ) { result . append ( _str ) ; } result . append ( double . tostring ( get ( i , n ) ) ) ; } } result . append ( _str ) ; return result . tostring ( ) ; }	converts the matrix into a single line matlab string : matrix is enclosed by parentheses , rows are separated by semicolon and single cells by blanks , e.
public fileinputreader ( file f ) throws ioexception { if ( debug . debugging ( _str ) ) { debug . output ( _str + f . getabsolutepath ( ) ) ; } name = f . getname ( ) ; absolutepath = f . getabsolutepath ( ) ; inputfile = init ( f ) ; }	constructs a new binaryfile with the specified file as the input.
public static objectoutputstream newobjectoutputstream ( path self ) throws ioexception { return new objectoutputstream ( files . newoutputstream ( self ) ) ; }	create an object output stream for this path .
@ override public set < k > keyset ( ) { hashset < k > set = new hashset < k > ( ) ; for ( segment < k , v > s : segments ) { set . addall ( s . keyset ( ) ) ; } return set ; }	get the set of keys for resident entries .
public void add ( final certificatevalidity certificatevalidity ) { certificatevaliditylist . add ( certificatevalidity ) ; }	this method allows to add a candidate for the signing certificate .
public void addpolicylistener ( policylistener policylistener ) { policycache . addpolicylistener ( policylistener ) ; }	adds a policy listener that would be notified whenever a policy is added , removed or changed.
public static result verify ( string sid , string code ) { string id = _str + sid ; code c = ( code ) cache . get ( id ) ; if ( c == null ) { log . warn ( _str + sid ) ; return result . badcode ; } else if ( ! x . issame ( code , c . code ) ) { log . warn ( _str + c . code + _str + code ) ; return result . badcode ; } else if ( c . expired < system . currenttimemillis ( ) ) { log . warn ( _str + c . expired ) ; return result . expired ; } return result . ok ; }	verify the code associated.
private scriptengine newscriptengine ( file file ) throws scriptexception { string filename = file . getname ( ) ; int index = filename . lastindexof ( _str ) ; if ( ( index < _num ) || ( index >= filename . length ( ) - _num ) ) { throw new scriptexception ( _str ) ; } string extension = filename . substring ( index + _num ) ; scriptenginemanager manager = new scriptenginemanager ( ) ; scriptengine engine = manager . getenginebyextension ( extension ) ; if ( engine == null ) { throw new scriptexception ( _str + extension ) ; } return engine ; }	returns a new scripting engine for the scripting language identified by the file name extension .
protected static inavirawmodule findrawmodule ( final int rawmoduleid , final list < inavirawmodule > rawmodules ) { preconditions . checkargument ( rawmoduleid > _num , _str , rawmoduleid ) ; preconditions . checknotnull ( rawmodules , _str ) ; for ( final inavirawmodule rawmodule : rawmodules ) { if ( rawmodule . getid ( ) == rawmoduleid ) { return rawmodule ; } } throw new illegalstateexception ( _str ) ; }	returns the raw module with the given id .
public static object extracttypechecked ( list < object > args , int i , class clazz , function < list < object > , object > extractfunc ) { if ( args . size ( ) < i + _num ) { return null ; } else if ( clazz . isinstance ( args . get ( i ) ) ) { return extractfunc . apply ( args ) ; } else { return null ; } }	extract type - checked value from an argument list using the specified type check and extraction function.
@ override public japanesedate dateyearday ( int prolepticyear , int dayofyear ) { return new japanesedate ( localdate . ofyearday ( prolepticyear , dayofyear ) ) ; }	obtains a local date in japanese calendar system from the proleptic - year and day - of - year fields.
private pair < entry , char [ ] > recoverentry ( keystore ks , string alias , char [ ] pstore , char [ ] pkey ) throws exception { if ( ks . containsalias ( alias ) == _bool ) { messageformat form = new messageformat ( rb . getstring ( _str ) ) ; object [ ] source = { alias } ; throw new exception ( form . format ( source ) ) ; } passwordprotection pp = null ; entry entry ; try { entry = ks . getentry ( alias , pp ) ; pkey = null ; } catch ( unrecoverableentryexception une ) { if ( p11keystore . equalsignorecase ( ks . gettype ( ) ) || keystoreutil . iswindowskeystore ( ks . gettype ( ) ) ) { throw une ; } if ( pkey != null ) { pp = new passwordprotection ( pkey ) ; entry = ks . getentry ( alias , pp ) ; } else { try { pp = new passwordprotection ( pstore ) ; entry = ks . getentry ( alias , pp ) ; pkey = pstore ; } catch ( unrecoverableentryexception une2 ) { if ( p12keystore . equalsignorecase ( ks . gettype ( ) ) ) { throw une2 ; } else { pkey = getkeypasswd ( alias , null , null ) ; pp = new passwordprotection ( pkey ) ; entry = ks . getentry ( alias , pp ) ; } } } } return pair . of ( entry , pkey ) ; }	recovers entry associated with given alias .
urlclassloader newloader ( url base ) { return new urlclassloader ( new url [ ] { base } ) ; }	creates a class loader with the given base url as its classpath .
public void testminunequal1 ( ) { string a = _str ; int ascale = _num ; string b = _str ; int bscale = _num ; string c = _str ; int cscale = _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; bigdecimal cnumber = new bigdecimal ( new biginteger ( c ) , cscale ) ; assertequals ( _str , cnumber , anumber . min ( bnumber ) ) ; }	min ( ) for unequal bigdecimals.
public wiser ( ) { this . server = new smtpserver ( new simplemessagelisteneradapter ( this ) ) ; }	create a new smtp server with this class as the listener.
protected static int [ ] concat ( @ nullable int [ ] arr , int ... obj ) { int [ ] newarr ; if ( arr == null || arr . length == _num ) newarr = obj ; else { newarr = arrays . copyof ( arr , arr . length + obj . length ) ; system . arraycopy ( obj , _num , newarr , arr . length , obj . length ) ; } return newarr ; }	concatenates elements to an int array .
public void truckcamera ( float size ) { movetoposition ( - ( float ) ( targetxoff + ( size * math . sin ( math . toradians ( zrot - _num ) ) ) ) , - ( float ) ( targetyoff + ( size * math . cos ( math . toradians ( zrot - _num ) ) ) ) ) ; }	change camera position horizontally ( left or right ) .
public void shutdown ( ) { scheduledexecutorservice . shutdownnow ( ) ; }	shut down the health checker .
public builder clear ( ) { localebuilder . clear ( ) ; return this ; }	resets the builder to its initial , empty state .
public static string deflate ( string previous , string current ) { if ( previous == null ) return current ; stringbuilder buf = new stringbuilder ( ) ; int start1 = _num ; int start2 = _num ; while ( start1 < previous . length ( ) && start2 < current . length ( ) ) { int end1 = start1 ; int end2 = start2 ; while ( end1 <= previous . length ( ) && end2 <= current . length ( ) ) { int c1 = ( end1 < previous . length ( ) ? previous . charat ( end1 ) : _str ) ; int c2 = ( end2 < current . length ( ) ? current . charat ( end2 ) : _str ) ; if ( c1 == c2 ) { if ( c1 == _str ) { buf . append ( _str ) ; break ; } else { end1 ++ ; end2 ++ ; } } else { while ( end1 < previous . length ( ) && previous . charat ( end1 ) != _str ) { end1 ++ ; } while ( end2 < current . length ( ) && current . charat ( end2 ) != _str ) { end2 ++ ; } for ( int i = start2 ; i < end2 ; i ++ ) buf . append ( current . charat ( i ) ) ; break ; } } start1 = end1 + _num ; start2 = end2 + _num ; if ( start2 < current . length ( ) ) buf . append ( _str ) ; } return buf . tostring ( ) ; }	deflate current sam line by replacing all fields that equalovershorterofboth previous line by an ampersand.
protected int splitlistindex ( list < pair < double , integer > > s ) { return s . size ( ) / _num ; }	determines which index to use as the splitting index for the vp radius.
public static void e ( string tag , string msg , object ... args ) { if ( slevel > level_error ) { return ; } if ( args . length > _num ) { msg = string . format ( msg , args ) ; } log . e ( tag , msg ) ; }	send an error log message.
public static synchronized void addpropertychangelistener ( propertychangelistener l ) { if ( ! listeners . contains ( l ) ) { listeners . add ( l ) ; } }	register for notification on changes to specific types.
private static void cleandirectory ( file path ) { if ( path == null ) return ; if ( path . exists ( ) ) { for ( file f : path . listfiles ( ) ) { if ( f . isdirectory ( ) ) cleandirectory ( f ) ; f . delete ( ) ; } } }	recursive remove all from directory.
private gridcacheversion minversion ( iterable < ignitetxentry > entries , gridcacheversion min , igniteinternaltx tx ) { for ( ignitetxentry txentry : entries ) { gridcacheentryex cached = txentry . cached ( ) ; assert txentry . isread ( ) || ! cached . obsolete ( tx . xidversion ( ) ) : _str + cached + _str + tx + _str ; for ( gridcachemvcccandidate cand : cached . remotemvccsnapshot ( ) ) if ( min == null || cand . version ( ) . isless ( min ) ) min = cand . version ( ) ; } return min ; }	go through all candidates for entries involved in transaction and find their min version.
public dimensionedscalar ( string fieldvalue ) throws illegalargumentexception { super ( _str , _str ) ; matcher matcher = pattern . matcher ( fieldvalue ) ; if ( matcher . find ( ) ) { string name = matcher . group ( _num ) ; string dimensions = matcher . group ( _num ) ; string value = matcher . group ( _num ) ; setname ( name ) ; setvalue ( value ) ; this . dimensions = new dimensions ( dimensions ) ; } else { throw new dictionaryexception ( _str + fieldvalue + _str ) ; } }	la stringa contiene il value del field di cui bisogna fare il parsing per estrarre valore e unita ' di misura.
public void characters ( char ch [ ] , int start , int length ) throws saxexception { m_valuebuffer . append ( ch , start , length ) ; }	characters read from xml are assigned to a variable , based on the current m_context.
protected double computestddev ( instance inst , matrix k ) throws exception { double kappa = m_kernel . eval ( - _num , - _num , inst ) + m_deltasquared ; double s = _num ; int n = m_l . length ; for ( int i = _num ; i < n ; i ++ ) { double t = _num ; for ( int j = _num ; j < n ; j ++ ) { t -= k . get ( j , _num ) * ( i > j ? m_l [ i ] [ j ] : m_l [ j ] [ i ] ) ; } s += t * k . get ( i , _num ) ; } double sigma = m_delta ; if ( kappa > s ) { sigma = math . sqrt ( kappa - s ) ; } return sigma ; }	computes standard deviation for given instance , without transforming target back into original space .
protected void initialize ( properties p ) { }	sub - classes can override to initialize other properties .
public void add ( int index , int element ) { checkrangeincludingendpoint ( index ) ; ensurecapacity ( size + _num ) ; int numtomove = size - index ; system . arraycopy ( array , index , array , index + _num , numtomove ) ; array [ index ] = element ; size ++ ; }	inserts the specified element at the specified position in this list.
public multiplexmanager ( datastore ... datastores ) { this . datastores = arrays . aslist ( datastores ) ; }	create a single datastore to handle provided managers within a single transaction .
public boolean matchesrawnamepattern ( object item ) { string prefix = patternmatcher . getpattern ( ) ; string text = getelementname ( item ) ; if ( text == null ) return _bool ; int textlength = text . length ( ) ; int prefixlength = prefix . length ( ) ; if ( textlength < prefixlength ) { return _bool ; } for ( int i = prefixlength - _num ; i >= _num ; i -- ) { if ( character . tolowercase ( prefix . charat ( i ) ) != character . tolowercase ( text . charat ( i ) ) ) return _bool ; } return _bool ; }	general method for matching raw name pattern.
public static @ nonnull < t > t valueordefault ( @ nullable t value , @ nonnull t defaultvalue ) { return value == null ? defaultvalue : value ; }	returns a value if that value is not null , or a specified default value otherwise .
protected abstract int comparetolastmsg ( pair < k , v > tuplekeyvalue , pair < byte [ ] , byte [ ] > lastreceivedkeyvalue ) ;	compare the incoming tuple with the last received message in kafka .
public void paintcomponent ( graphics g ) { g . drawimage ( track , _num , _num , null ) ; graphics2d g2d = ( graphics2d ) g . create ( ) ; g2d . translate ( carposition . x , carposition . y ) ; g2d . rotate ( math . toradians ( carrotation ) ) ; g2d . translate ( - ( carposition . x ) , - ( carposition . y ) ) ; g2d . drawimage ( car , carposition . x - carwhalf , carposition . y - carhhalf , null ) ; }	render the track and car.
public static java . sql . time tosqltime ( string time ) { java . util . date newdate = todate ( _str , time ) ; if ( newdate != null ) { return new java . sql . time ( newdate . gettime ( ) ) ; } else { return null ; } }	converts a time string into a java.
public string chooseserveralias ( string keytype , principal [ ] issuers , socket socket ) { return defaultx509km . chooseserveralias ( keytype , issuers , socket ) ; }	returns an alias to authenticate the server side of a secure socket given the public key type and the list of certificate issuer authorities recognized by the peer ( if any ) .
public static double pdf ( double x , double shape , double scale , double factor ) { if ( x <= _num ) return _num ; final double a = math . exp ( shape * math . log ( scale ) - ( shape + _num ) * math . log ( x ) - ( scale / x ) - gammafunction . lngamma ( shape ) ) ; return factor * a ; }	probability density function of the gamma distribution.
public string charge ( properties ctx , int windowno , gridtab mtab , gridfield mfield , object value ) { integer c_charge_id = ( integer ) value ; if ( c_charge_id == null || c_charge_id . intvalue ( ) == _num ) return _str ; string sql = _str ; preparedstatement pstmt = null ; resultset rs = null ; try { pstmt = db . preparestatement ( sql , null ) ; pstmt . setint ( _num , c_charge_id . intvalue ( ) ) ; rs = pstmt . executequery ( ) ; if ( rs . next ( ) ) { mtab . setvalue ( _str , rs . getbigdecimal ( _num ) ) ; } } catch ( sqlexception e ) { log . log ( level . severe , sql , e ) ; return e . getlocalizedmessage ( ) ; } finally { db . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } return tax ( ctx , windowno , mtab , mfield , value ) ; }	invoice batch line - charge . - updates priceentered from charge calles tax.
protected array < actor > parse ( ) { actors = gdxarrays . newarray ( actor . class ) ; invokeprelisteners ( actors ) ; final stringbuilder builder = new stringbuilder ( ) ; while ( templatereader . hasnextcharacter ( ) ) { final char character = templatereader . nextcharacter ( ) ; if ( character == syntax . getargumentopening ( ) ) { processargument ( ) ; } else if ( character == syntax . gettagopening ( ) ) { if ( isnextcharactercommentopening ( ) ) { processcomment ( ) ; continue ; } if ( currentparenttag != null ) { currentparenttag . handledatabetweentags ( builder ) ; } strings . clearbuilder ( builder ) ; processtag ( builder ) ; } else { builder . append ( character ) ; } } if ( currentparenttag != null ) { throwerror ( _str + currentparenttag . gettagname ( ) + _str ) ; } invokeportlisteners ( actors ) ; return actors ; }	does the actual parsing.
public void testabandcbbrokernetwork ( ) throws exception { bridgebrokers ( _str , _str ) ; bridgebrokers ( _str , _str ) ; startallbrokers ( ) ; destination dest = createdestination ( _str , _bool ) ; messageconsumer clienta = createconsumer ( _str , dest ) ; messageconsumer clientb = createconsumer ( _str , dest ) ; messageconsumer clientc = createconsumer ( _str , dest ) ; thread . sleep ( _num ) ; sendmessages ( _str , dest , message_count ) ; sendmessages ( _str , dest , message_count ) ; sendmessages ( _str , dest , message_count ) ; messageidlist msgsa = getconsumermessages ( _str , clienta ) ; messageidlist msgsb = getconsumermessages ( _str , clientb ) ; messageidlist msgsc = getconsumermessages ( _str , clientc ) ; msgsa . waitformessagestoarrive ( message_count ) ; msgsb . waitformessagestoarrive ( message_count * _num ) ; msgsc . waitformessagestoarrive ( message_count ) ; assertequals ( message_count , msgsa . getmessagecount ( ) ) ; assertequals ( message_count * _num , msgsb . getmessagecount ( ) ) ; assertequals ( message_count , msgsc . getmessagecount ( ) ) ; }	brokera - > brokerb < - brokerc.
public void flush ( ) throws ioexception { wsputil . writeuint8 ( os_ , _num ) ; writepublicidentifier ( os_ , publicid_ ) ; wsputil . writeuintvar ( os_ , wapconstants . mib_enum_utf_8 ) ; writestringtable ( os_ ) ; wbxmlbody_ . close ( ) ; wbxmlbody_ . writeto ( os_ ) ; os_ . flush ( ) ; }	writes the wbxml to stream .
public static void discard ( ) { current . remove ( ) ; }	discards any active baggage currently in this thread.
private token toasitoken ( ileafnode leaf ) { if ( leaf . ishidden ( ) ) { return newsemicolontoken ( leaf ) ; } else { if ( ! leafnodes . hasnext ( ) ) { int tokentype = tokentypemapper . getinternaltokentype ( leaf ) ; int semicolontokentype = tokentypemapper . getinternaltokentype ( semicolon ) ; if ( tokentype == semicolontokentype ) { return new commontoken ( semicolontokentype , leaf . gettext ( ) ) ; } if ( leaf . gettotalendoffset ( ) == endoffset ) { leafnodes = iterators . emptyiterator ( ) ; return new commontoken ( tokentype , leaf . gettext ( ) ) ; } next = new commontoken ( semicolontokentype , leaf . gettext ( ) ) ; return new commontoken ( tokentype , leaf . gettext ( ) ) ; } else if ( leaf . getgrammarelement ( ) == rightcurlyinblock || leaf . getgrammarelement ( ) == rightcurlyinarrowexpression ) { int tokentype = tokentypemapper . getinternaltokentype ( leaf ) ; next = new commontoken ( tokentype ) ; return new commontoken ( tokentypemapper . getinternaltokentype ( semicolon ) , leaf . gettext ( ) ) ; } else { return newsemicolontoken ( leaf ) ; } } }	produces either one or two tokens from the given leaf which represents a location where the production parser inserted a semicolon .
@ override public packetbuffer write ( packetbuffer buf ) { values . foreach ( null ) ; return buf ; }	writes this packet to the given buffer.
public final void registerfiletype ( @ notnull filetype type , @ nonnls @ nullable string ... defaultassociatedextensions ) { list < filenamematcher > matchers = new arraylist < filenamematcher > ( ) ; if ( defaultassociatedextensions != null ) { for ( string extension : defaultassociatedextensions ) { matchers . add ( new extensionfilenamematcher ( extension ) ) ; } } registerfiletype ( type , matchers ) ; }	registers a file type .
public int parseint ( string localeformattedinteger ) { return integer . parseint ( localeformattedinteger ) ; }	parses an integer based on locale conventions.
public static requestsecuritytokenresponse parsexml ( string xml ) throws wsfederationexception { document doc = xmlutils . todomdocument ( xml , debug ) ; element root = doc . getdocumentelement ( ) ; return new requestsecuritytokenresponse ( root ) ; }	returns requestsecuritytokenresponse object based on the xml document received from server.
@ override public void requestresources ( samzaresourcerequest resourcerequest ) { final int default_priority = _num ; log . info ( _str + resourcerequest . getpreferredhost ( ) + _str + resourcerequest . getcontainerid ( ) ) ; int memorymb = resourcerequest . getmemorymb ( ) ; int cpucores = resourcerequest . getnumcores ( ) ; string containerlabel = yarnconfig . getcontainerlabel ( ) ; string preferredhost = resourcerequest . getpreferredhost ( ) ; resource capability = resource . newinstance ( memorymb , cpucores ) ; priority priority = priority . newinstance ( default_priority ) ; amrmclient . containerrequest issuedrequest ; if ( preferredhost . equals ( _str ) ) { log . info ( _str + preferredhost ) ; issuedrequest = new amrmclient . containerrequest ( capability , null , null , priority , _bool , containerlabel ) ; } else { log . info ( _str + preferredhost ) ; issuedrequest = new amrmclient . containerrequest ( capability , new string [ ] { preferredhost } , null , priority , _bool , containerlabel ) ; } synchronized ( lock ) { requestsmap . put ( resourcerequest , issuedrequest ) ; amclient . addcontainerrequest ( issuedrequest ) ; } }	request resources for running container processes .
private collection < extracteditemscollection > filteritemsbylevel ( player player , list < extracteditemscollection > itemscollections ) { int playerlevel = player . getlevel ( ) ; collection < extracteditemscollection > result = new arraylist < extracteditemscollection > ( ) ; for ( extracteditemscollection collection : itemscollections ) { if ( collection . getminlevel ( ) > playerlevel ) { continue ; } if ( collection . getmaxlevel ( ) > _num && collection . getmaxlevel ( ) < playerlevel ) { continue ; } result . add ( collection ) ; } return result ; }	add to result collection only items witch suits player ' s level.
public static int binarysearchfloor ( long [ ] a , long key , boolean inclusive , boolean stayinbounds ) { int index = arrays . binarysearch ( a , key ) ; index = index < _num ? - ( index + _num ) : ( inclusive ? index : ( index - _num ) ) ; return stayinbounds ? math . max ( _num , index ) : index ; }	returns the index of the largest value in an array that is less than ( or optionally equal to ) a specified key.
public boolean add ( symbol sym ) throws internal_error { object previous ; not_null ( sym ) ; previous = _all . put ( sym . name ( ) , sym ) ; return previous == null ; }	add a single symbol to the set .
protected static final string addescapes ( string str ) { stringbuffer retval = new stringbuffer ( ) ; char ch ; for ( int i = _num ; i < str . length ( ) ; i ++ ) { switch ( str . charat ( i ) ) { case _num : continue ; case _str : retval . append ( _str ) ; continue ; case _str : retval . append ( _str ) ; continue ; case _str : retval . append ( _str ) ; continue ; case _str : retval . append ( _str ) ; continue ; case _str : retval . append ( _str ) ; continue ; case _str : retval . append ( _str ) ; continue ; case _str : retval . append ( _str ) ; continue ; case _str : retval . append ( _str ) ; continue ; default : if ( ( ch = str . charat ( i ) ) < _num || ch > _num ) { string s = _str + integer . tostring ( ch , _num ) ; retval . append ( _str + s . substring ( s . length ( ) - _num , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . tostring ( ) ; }	replaces unprintable characters by their escaped ( or unicode escaped ) equivalents in the given string.
public final int size ( ) { if ( gwt . isscript ( ) ) { return jsarray . size ( ) ; } else { return javaarray . size ( ) ; } }	return the list size.
public static long longfrombase64 ( string value ) { int pos = _num ; long longval = base64values [ value . charat ( pos ++ ) ] ; int len = value . length ( ) ; while ( pos < len ) { longval <<= _num ; longval |= base64values [ value . charat ( pos ++ ) ] ; } return longval ; }	decode a base64 string into a long value .
public list < localtime > bottom ( int n ) { list < localtime > bottom = new arraylist < > ( ) ; int [ ] values = data . tointarray ( ) ; intarrays . parallelquicksort ( values ) ; for ( int i = _num ; i < n && i < values . length ; i ++ ) { bottom . add ( packedlocaltime . aslocaltime ( values [ i ] ) ) ; } return bottom ; }	returns the smallest ( " bottom " ) n values in the column.
public double sumoutlinkauthorityscore ( page page ) { list < string > outlinks = page . getoutlinks ( ) ; double authscore = _num ; for ( int i = _num ; i < outlinks . size ( ) ; i ++ ) { page outlink = ptable . get ( outlinks . get ( i ) ) ; if ( outlink != null ) { authscore += outlink . authority ; } } return authscore ; }	calculate the hub score of a page by summing the authority scores of that page ' s outlinks .
public synchronized void end ( ) { graphicstobedrawn . close ( ) ; if ( currentgraphics != null ) { graphicsdrawn . append ( currentgraphics ) ; } graphicsdrawn . closewhenempty ( ) ; if ( printerjobthread != null && printerjobthread . isalive ( ) ) { try { printerjobthread . join ( ) ; } catch ( interruptedexception e ) { } } }	ends the print job and does any necessary cleanup .
public list < filestatus > browse ( string filepath ) throws exception { log . info ( _str + filepath + _str + hdfsendpoint ) ; filesystem hdfsfilesystem = null ; filestatus [ ] liststatus ; try { configuration config = createconfig ( ) ; hdfsfilesystem = getfilesystem ( config ) ; path path = new path ( filepath ) ; liststatus = hdfsfilesystem . liststatus ( path ) ; } catch ( exception ex ) { log . error ( _str + filepath , ex . getmessage ( ) ) ; throw new exception ( _str + ex . getmessage ( ) ) ; } finally { if ( hdfsfilesystem != null ) hdfsfilesystem . close ( ) ; } return arrays . aslist ( liststatus ) ; }	brows the files for the specific path.
public void append ( charsequence s ) { text . append ( s ) ; }	add a string to the end of the buffer .
public eipmodelwizardinitialobjectcreationpage ( string pageid ) { super ( pageid ) ; }	pass in the selection . < ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
private void unwrapdata ( ) throws ignitecheckedexception , sslexception { if ( log . isdebugenabled ( ) ) log . debug ( _str ) ; innetbuf . flip ( ) ; sslengineresult res = unwrap0 ( ) ; innetbuf . compact ( ) ; checkstatus ( res ) ; renegotiateifneeded ( res ) ; }	unwraps user data to the application buffer .
public boolean isattributespecified ( int attributehandle ) { int type = getnodetype ( attributehandle ) ; if ( dtm . attribute_node == type ) { attr attr = ( attr ) getnode ( attributehandle ) ; return attr . getspecified ( ) ; } return _bool ; }	5 . [ specified ] a flag indicating whether this attribute was actually specified in the start - tag of its element , or was defaulted from the dtd .
private static void checkpermission ( ) throws securityexception { securitymanager sm = system . getsecuritymanager ( ) ; if ( sm != null ) { sm . checkpermission ( new jodatimepermission ( _str ) ) ; } }	checks whether the provider may be changed using permission ' currenttime.
private void storepassword ( string password ) { if ( isstore && sharedstate != null ) { sharedstate . put ( getpwdkey ( ) , password ) ; } }	stores password into shared state map.
void deletechild ( policynode childnode ) { if ( isimmutable ) { throw new illegalstateexception ( _str ) ; } mchildren . remove ( childnode ) ; }	deletes the specified child node of this node , if it exists .
public void testfloatvaluepluszero ( ) { string a = _str ; bigdecimal anumber = new bigdecimal ( a ) ; int zero = _num ; float result = anumber . floatvalue ( ) ; asserttrue ( _str , float . floattointbits ( result ) == zero ) ; }	float value of a small positive bigdecimal.
public externalprocessresult awaitterminationandresult ( int timeoutms , boolean destroyonerror ) throws interruptedexception , timeoutexception , operationcancellation , ioexception { awaittermination ( timeoutms , destroyonerror ) ; return new externalprocessresult ( process . exitvalue ( ) , getstdoutbytes ( ) , getstderrbytes ( ) ) ; }	awaits for successful process termination , as well as successful termination of reader threads , throws an exception otherwise ( and destroys the process ) .
public void refreshinheritedmethods ( set modifiedsuperexpandos ) { for ( iterator i = modifiedsuperexpandos . iterator ( ) ; i . hasnext ( ) ; ) { expandometaclass superexpando = ( expandometaclass ) i . next ( ) ; if ( superexpando != this ) { refreshinheritedmethods ( superexpando ) ; } } }	called from expandometaclasscreationhandle in the registry if it exists to set up inheritance handling.
@ override protected void failed ( ) { relation . setcanceled ( _bool ) ; super . failed ( ) ; }	marks the relation as canceled and invokes the the handler ' s failed ( ) method .
private void changeannotationdocumentstate ( sourcedocument asourcedocument , user auser , annotationdocumentstatetransition aannotationdocumentstatetransition ) { annotationdocument annotationdocument = repository . getannotationdocument ( asourcedocument , auser ) ; annotationdocument . setstate ( annotationdocumentstatetransition . transition ( aannotationdocumentstatetransition ) ) ; try { repository . createannotationdocument ( annotationdocument ) ; } catch ( ioexception e ) { log . info ( _str ) ; } }	change the state of an annotation document . used to re - open closed documents.
boolean removeedge ( sparseedge e ) { boolean removededge = edges . remove ( e ) ; boolean removedneighbour = neighbours . remove ( e . getopposite ( this ) ) ; if ( removededge && removedneighbour ) return _bool ; else if ( ! removededge && ! removedneighbour ) return _bool ; else throw new runtimeexception ( _str ) ; }	disconnects this vertex from an edge .
protected void longkeypress ( int keycode ) { }	if this component is focused this method is invoked when the user presses and holds the key.
public boolean hasdescendant ( pattern pattern ) { queue < bnode > nodestoprocess = new linkedlist < bnode > ( ) ; nodestoprocess . add ( this ) ; while ( ! nodestoprocess . isempty ( ) ) { bnode currentnode = nodestoprocess . poll ( ) ; for ( bnode descendantnode : currentnode . getoutputnodes ( ) ) { matcher matcher = pattern . matcher ( descendantnode . getid ( ) ) ; if ( matcher . matches ( ) ) { return _bool ; } if ( ! nodestoprocess . contains ( descendantnode ) ) { nodestoprocess . add ( descendantnode ) ; } } } return _bool ; }	returns true if at there exists at least one descendant whose identifier matches the regular expression pattern , and false otherwise.
public int filewrite ( long handle , byte [ ] buffer , int offset , int count ) { if ( ( offset | count ) < _num || offset > buffer . length || buffer . length - offset < count ) { throw new arrayindexoutofboundsexception ( _str + buffer . length + _str + offset + _str + count ) ; } if ( count == _num ) { return _num ; } byte [ ] data = buffer ; if ( offset > _num ) { data = new byte [ count ] ; system . arraycopy ( buffer , offset , data , _num , count ) ; } intout byteswrittenout = new intout ( ) ; try { checkresult ( libimobiledevice . afc_file_write ( getref ( ) , handle , data , count , byteswrittenout ) ) ; int byteswritten = byteswrittenout . getvalue ( ) ; return byteswritten ; } finally { byteswrittenout . delete ( ) ; } }	writes a given number of bytes to a file .
private static void generatefiles ( ) { string [ ] classnames ; resourcebundle rules , info ; info = resourcebundle . getbundle ( _str , new locale ( language , country , valiant ) , breakiteratorrbcontrol . instance ) ; classnames = info . getstringarray ( _str ) ; rules = resourcebundle . getbundle ( _str , new locale ( language , country , valiant ) , breakiteratorrbcontrol . instance ) ; if ( info . containskey ( _str ) ) { generatedatafile ( info . getstring ( _str ) , rules . getstring ( _str ) , classnames [ _num ] ) ; } if ( info . containskey ( _str ) ) { generatedatafile ( info . getstring ( _str ) , rules . getstring ( _str ) , classnames [ _num ] ) ; } if ( info . containskey ( _str ) ) { generatedatafile ( info . getstring ( _str ) , rules . getstring ( _str ) , classnames [ _num ] ) ; } if ( info . containskey ( _str ) ) { generatedatafile ( info . getstring ( _str ) , rules . getstring ( _str ) , classnames [ _num ] ) ; } }	generate data files whose names are included in sun.
public static boolean iscglibproxy ( object object ) { return classutils . iscglibproxyclass ( object . getclass ( ) ) ; }	check whether the given object is a cglib proxy .
private float [ ] calculateimageindents ( ) { mtempmatrix . reset ( ) ; mtempmatrix . setrotate ( - getcurrentangle ( ) ) ; float [ ] unrotatedimagecorners = arrays . copyof ( mcurrentimagecorners , mcurrentimagecorners . length ) ; float [ ] unrotatedcropboundscorners = rectutils . getcornersfromrect ( mcroprect ) ; mtempmatrix . mappoints ( unrotatedimagecorners ) ; mtempmatrix . mappoints ( unrotatedcropboundscorners ) ; rectf unrotatedimagerect = rectutils . traptorect ( unrotatedimagecorners ) ; rectf unrotatedcroprect = rectutils . traptorect ( unrotatedcropboundscorners ) ; float deltaleft = unrotatedimagerect . left - unrotatedcroprect . left ; float deltatop = unrotatedimagerect . top - unrotatedcroprect . top ; float deltaright = unrotatedimagerect . right - unrotatedcroprect . right ; float deltabottom = unrotatedimagerect . bottom - unrotatedcroprect . bottom ; float indents [ ] = new float [ _num ] ; indents [ _num ] = ( deltaleft > _num ) ? deltaleft : _num ; indents [ _num ] = ( deltatop > _num ) ? deltatop : _num ; indents [ _num ] = ( deltaright < _num ) ? deltaright : _num ; indents [ _num ] = ( deltabottom < _num ) ? deltabottom : _num ; mtempmatrix . reset ( ) ; mtempmatrix . setrotate ( getcurrentangle ( ) ) ; mtempmatrix . mappoints ( indents ) ; return indents ; }	first , un - rotate image and crop rectangles ( make image rectangle axis - aligned ).
public void testbug10630 ( ) throws exception { connection conn2 = null ; statement stmt2 = null ; try { conn2 = getconnectionwithprops ( ( properties ) null ) ; stmt2 = conn2 . createstatement ( ) ; conn2 . close ( ) ; stmt2 . getwarnings ( ) ; fail ( _str ) ; } catch ( sqlexception sqlex ) { assertequals ( sqlerror . sql_state_illegal_argument , sqlex . getsqlstate ( ) ) ; } finally { if ( stmt2 != null ) { stmt2 . close ( ) ; } if ( conn2 != null ) { conn2 . close ( ) ; } } }	tests fix for bug # 10630 , statement.
public static boolean equals ( boolean [ ] field1 , boolean [ ] field2 ) { if ( field1 == null || field1 . length == _num ) { return field2 == null || field2 . length == _num ; } else { return arrays . equals ( field1 , field2 ) ; } }	checks repeated boolean field equality ; null - value and 0 - length fields are considered equal .
public void tofront ( final workflowannotation anno ) { if ( anno == null ) { throw new illegalargumentexception ( _str ) ; } synchronized ( lock ) { if ( annotationsdraworder . remove ( anno ) ) { annotationsdraworder . add ( anno ) ; } if ( annotationseventorder . remove ( anno ) ) { annotationseventorder . add ( _num , anno ) ; } } }	bring the given annotation to the front.
public synchronized void addframe ( final image image , final long frameduration ) { totalduration += frameduration ; frames . add ( new animframe ( image , totalduration ) ) ; }	adds an image to the animation with the specified duration ( time to display the image ) .
public static string printcodepointasstring ( int codepoint ) { stringbuilder builder = new stringbuilder ( _num ) ; builder . append ( _str ) ; try { printstringcodepoint ( builder , codepoint ) ; } catch ( ioexception e ) { throw new error ( e ) ; } builder . append ( _str ) ; return builder . tostring ( ) ; }	builds a string denoting an ascii - encoded ion string , with double - quotes surrounding a single unicode code point .
private void cleanupminidumpfile ( ) { if ( ! crashfilemanager . trymarkasuploaded ( mfiletoupload ) ) { log . w ( tag , _str + mfiletoupload + _str ) ; if ( ! mfiletoupload . delete ( ) ) { log . w ( tag , _str + mfiletoupload ) ; } } }	mark file we just uploaded for cleanup later.
boolean closeoutbound ( ) throws sslexception { if ( sslengine == null || sslengine . isoutbounddone ( ) ) { return _bool ; } sslengine . closeoutbound ( ) ; createoutnetbuffer ( _num ) ; sslengineresult result ; for ( ; ; ) { result = sslengine . wrap ( emptybuffer . buf ( ) , outnetbuffer . buf ( ) ) ; if ( result . getstatus ( ) == sslengineresult . status . buffer_overflow ) { outnetbuffer . capacity ( outnetbuffer . capacity ( ) << _num ) ; outnetbuffer . limit ( outnetbuffer . capacity ( ) ) ; } else { break ; } } if ( result . getstatus ( ) != sslengineresult . status . closed ) { throw new sslexception ( _str + result ) ; } outnetbuffer . flip ( ) ; return _bool ; }	start ssl shutdown process .
@ nullable private static bitmap extractthumbnail ( bitmap source , int width , int height ) { return extractthumbnail ( source , width , height , options_none ) ; }	creates a centered bitmap of the desired size .
private void writepkginfo ( ) throws buildexception { file pkginfo = new file ( mcontentsdir , _str ) ; printwriter writer = null ; try { writer = new printwriter ( new bufferedwriter ( new filewriter ( pkginfo ) ) ) ; writer . print ( bundleproperties . getcfbundlepackagetype ( ) ) ; writer . println ( bundleproperties . getcfbundlesignature ( ) ) ; writer . flush ( ) ; } catch ( ioexception ex ) { throw new buildexception ( _str + ex ) ; } finally { mfileutils . close ( writer ) ; } }	write the pkginfo file into the application bundle.
public eventbean [ ] toarray ( ) { if ( firstevent == null ) { return new eventbean [ _num ] ; } if ( additionalevents == null ) { return new eventbean [ ] { firstevent } ; } eventbean [ ] events = new eventbean [ _num + additionalevents . size ( ) ] ; events [ _num ] = firstevent ; int count = _num ; for ( eventbean theevent : additionalevents ) { events [ count ] = theevent ; count ++ ; } return events ; }	returns an array holding the collected events .
private byte [ ] decode ( derinputstream in ) throws ioexception { dervalue val = in . getdervalue ( ) ; byte [ ] derencoding = val . tobytearray ( ) ; derencoding [ _num ] = dervalue . tag_setof ; derinputstream derin = new derinputstream ( derencoding ) ; dervalue [ ] dervals = derin . getset ( _num , _bool ) ; pkcs9attribute attrib ; objectidentifier oid ; boolean reuseencoding = _bool ; for ( int i = _num ; i < dervals . length ; i ++ ) { try { attrib = new pkcs9attribute ( dervals [ i ] ) ; } catch ( parsingexception e ) { if ( ignoreunsupportedattributes ) { reuseencoding = _bool ; continue ; } else { throw e ; } } oid = attrib . getoid ( ) ; if ( attributes . get ( oid ) != null ) throw new ioexception ( _str + oid ) ; if ( permittedattributes != null && ! permittedattributes . containskey ( oid ) ) throw new ioexception ( _str + oid + _str ) ; attributes . put ( oid , attrib ) ; } return reuseencoding ? derencoding : generatederencoding ( ) ; }	decode this set of pkcs9 attributes from the contents of its der encoding.
stringvector processprefix_list ( stylesheethandler handler , string uri , string name , string rawname , string value ) throws org . xml . sax . saxexception { stringtokenizer tokenizer = new stringtokenizer ( value , _str ) ; int nstrings = tokenizer . counttokens ( ) ; stringvector strings = new stringvector ( nstrings ) ; for ( int i = _num ; i < nstrings ; i ++ ) { string prefix = tokenizer . nexttoken ( ) ; string url = handler . getnamespaceforprefix ( prefix ) ; if ( prefix . equals ( constants . attrval_default_prefix ) || url != null ) strings . addelement ( prefix ) ; else throw new org . xml . sax . saxexception ( xslmessages . createmessage ( xslterrorresources . er_cant_resolve_nsprefix , new object [ ] { prefix } ) ) ; } return strings ; }	process an attribute string of type t_prefixlist into a vector of prefixes that may be resolved to urls .
@ override public categoricalresults clone ( ) { categoricalresults copy = new categoricalresults ( n ) ; copy . probabilities = arrays . copyof ( probabilities , probabilities . length ) ; return copy ; }	creates a deep clone of this.
private static stringbuilder dump ( stringbuilder _lbuffer , long value ) { for ( int j = _num ; j < _num ; j ++ ) { _lbuffer . append ( _hexcodes [ ( int ) ( value > > _shifts [ j ] ) & _num ] ) ; } return _lbuffer ; }	dump a long value into a stringbuilder .
private boolean typespecialchar ( char c ) { switch ( c ) { case _str : controller . keypress ( keyevent . vk_tab ) ; controller . keyrelease ( keyevent . vk_tab ) ; return _bool ; case _str : controller . keypress ( keyevent . vk_enter ) ; controller . keyrelease ( keyevent . vk_enter ) ; return _bool ; default : return _bool ; } }	simulate keyboard to type out a special character.
protected static boolean eq ( object o1 , object o2 ) { return o1 == null ? o2 == null : o1 . equals ( o2 ) ; }	helper method to check for equality between two object , including null checks .
public static boolean hasmimetype ( string mimetype ) { if ( mimetype == null || mimetype . isempty ( ) ) { return _bool ; } return mimetypetoextensionmap . containskey ( mimetype ) ; }	returns true if the given mime type has an entry in the map .
public iterable < notification > skip ( @ nonnull final iterable < notification > notifications , final long startid , final boolean inclusive , final int limitsize ) { objects . requirenonnull ( notifications ) ; final int position = indexof ( notifications , startid ) ; if ( position == - _num ) { return iterables . limit ( notifications , limitsize ) ; } if ( inclusive ) { return iterables . limit ( iterables . skip ( notifications , position ) , limitsize ) ; } return iterables . limit ( iterables . skip ( notifications , position + _num ) , limitsize ) ; }	returns an iterable that skips forward to a given notification id then only returns count more notifications . if the given notification id is not found.
public boolean writedata ( pdxwriter writer , object obj ) { if ( isrelevant ( obj . getclass ( ) ) ) { writedata ( writer , obj , getclassinfo ( obj . getclass ( ) ) ) ; return _bool ; } return _bool ; }	using the given pdxwriter , write out the relevant fields for the object instance passed in .
protected final void writec ( bytebuffer buf , int value ) { buf . put ( ( byte ) value ) ; }	write byte to buffer .
public boolean isempty ( ) { return priorityqueue . isempty ( ) ; }	is queue is empty.
public viterbipoint ( item item ) { this . item = item ; }	creates a viterbipoint for the given item.
protected void paintcontentborderbottomedge ( graphics g , int x , int y , int w , int h , boolean drawbroken , rectangle selrect , boolean iscontentborderpainted ) { if ( iscontentborderpainted ) { g . setcolor ( darkshadow ) ; g . fillrect ( x , y + h - _num , w - _num , _num ) ; } }	draws the bottom edge of the border around the content area.
private void emitlistadd ( method method , string fieldname , stringbuilder builder ) { builder . append ( _str ) ; builder . append ( getlistaddername ( fieldname ) ) ; builder . append ( _str ) ; builder . append ( gettypeargumentimplname ( ( parameterizedtype ) method . getgenericreturntype ( ) , _num ) ) ; builder . append ( _str ) ; builder . append ( getensurename ( fieldname ) ) ; builder . append ( _str ) ; builder . append ( fieldname ) ; builder . append ( _str ) ; builder . append ( _str ) ; }	emits an add method to add to a list.
public rsapublickey parsepempublickey ( string pem ) throws generalsecurityexception { try { byte [ ] bs = decodeasciiarmoredpem ( pem ) ; bytebuffer data = bytebuffer . wrap ( bs ) ; final asn1object ob = asn1parser . parseasn1 ( data ) ; final list < asn1object > seq = asn1objecttosequence ( ob , _num ) ; final biginteger modulus = asn1objecttobigint ( seq . get ( _num ) ) ; final biginteger exponent = asn1objecttobigint ( seq . get ( _num ) ) ; return createkeyfrommodulusandexponent ( modulus , exponent ) ; } catch ( illegalargumentexception e ) { throw new invalidkeyexception ( ) ; } }	parse a pkcs1 pem encoded rsa public key into the modulus / exponent components and construct a new rsapublickey.
public static < t > parallelpublisher < t > from ( publisher < ? extends t > source , boolean ordered , int parallelism ) { return from ( source , ordered , parallelism , px . buffersize ( ) , px . defaultqueuesupplier ( px . buffersize ( ) ) ) ; }	take a publisher and prepare to consume it on parallallism number of ' rails ' , possibly ordered and round - robin fashion .
public long next ( long starttime , long fromtime , long currentcount ) { if ( starttime == _num ) starttime = recurrenceutil . now ( ) ; if ( fromtime == _num ) fromtime = starttime ; if ( getendtime ( ) != _num && getendtime ( ) <= recurrenceutil . now ( ) ) return _num ; debug . logverbose ( _str , module ) ; if ( getcount ( ) != - _num && currentcount >= getcount ( ) ) return _num ; debug . logverbose ( _str , module ) ; boolean isseeking = _bool ; long nextruntime = _num ; long seektime = fromtime ; int loopprotection = _num ; int maxloop = ( _num * _num * _num * _num * _num ) ; while ( isseeking && loopprotection < maxloop ) { date nextrun = getnextfreq ( starttime , seektime ) ; seektime = nextrun . gettime ( ) ; if ( validbyrule ( nextrun ) ) { isseeking = _bool ; nextruntime = nextrun . gettime ( ) ; } loopprotection ++ ; } return nextruntime ; }	returns the next recurrence of this rule .
public void addtoqueue ( var var ) { addtoqueue ( collections . singleton ( var ) ) ; }	add a single var to the queue.
public string canonicalize ( string simpleurl ) { string resulturl = simpleurl ; if ( simpleurl . startswith ( _str ) ) { resulturl = _str + simpleurl ; } else if ( simpleurl . startswith ( _str ) ) { resulturl = _str + simpleurl ; } else if ( simpleurl . startswith ( _str ) ) { resulturl = _str + simpleurl ; } else if ( ! hasprotocolname ( simpleurl ) ) { if ( issimplehostname ( simpleurl ) ) { simpleurl = _str + simpleurl + _str ; } resulturl = _str + simpleurl ; } return resulturl ; }	given a possibly abbreviated url ( missing a protocol name , typically ) , this method ' s job is to transform that url into a canonical form , by including a protocol name and additional syntax , if necessary.
public string read ( string filename ) throws ioexception { return procfile . readfile ( string . format ( _str , pid , filename ) ) ; }	read the contents of a file in / proc / [ pid ] / [ filename ] .
private long calculateanimationduration ( float initialvelocity , float displacement ) { return mathutils . clamp ( math . round ( math . abs ( _num * displacement / initialvelocity ) ) , minimum_animation_duration_ms , maximum_animation_duration_ms ) ; }	calculates the animation duration given the | initialvelocity | and a desired | displacement | .
private static double norm ( final double [ ] v ) { double agg = _num ; for ( int i = _num ; i < v . length ; i ++ ) { agg += ( v [ i ] * v [ i ] ) ; } return math . sqrt ( agg ) ; }	returns the norm l2 . sqrt ( sum_i ( v_i ^ 2 ) ).
private int measureheight ( int measurespec ) { float result ; int specmode = measurespec . getmode ( measurespec ) ; int specsize = measurespec . getsize ( measurespec ) ; if ( specmode == measurespec . exactly ) { result = specsize ; } else { result = mpaintselected . getstrokewidth ( ) + getpaddingtop ( ) + getpaddingbottom ( ) ; if ( specmode == measurespec . at_most ) { result = math . min ( result , specsize ) ; } } return ( int ) ( ( float ) math . ceil ( result ) ) ; }	determines the height of this view.
public void add ( int i , int data ) { if ( _length + _num > _capacity ) ensurecapacity ( _length + _num ) ; system . arraycopy ( _buffer , i , _buffer , i + _num , _length - i ) ; _buffer [ i ] = ( byte ) data ; _length += _num ; }	inserts a byte array.
private double mean ( double [ ] vec ) { double result = _num ; for ( int i = _num ; i < vec . length ; i ++ ) result += vec [ i ] ; return result / vec . length ; }	the mean of the values in the double array.
private sprite ( float xpos , float ypos , float xvel , float yvel , image ... sprites ) { if ( sprites != null ) spriteframe = new imageview ( sprites [ _num ] ) ; playerstates . addall ( arrays . aslist ( sprites ) ) ; spriteframe . settranslatex ( xpos ) ; spriteframe . settranslatey ( ypos ) ; this . xpos = xpos ; this . ypos = ypos ; this . xvel = xvel ; this . yvel = yvel ; }	used internally to create common functions between motion and stationary sprite .
public void close ( ) { out . close ( ) ; }	closes the output stream .
protected static synctoken createsynctoken ( string datestring , @ nullable string uuid ) { try { return new synctoken ( db_date_format . parse ( datestring ) , uuid ) ; } catch ( parseexception e ) { throw new runtimeexception ( e ) ; } }	creates a sync token , and converts any thrown exceptions to runtimeexceptions so it can be used for static fields .
private static boolean equalshandlesnulls ( object a , object b ) { return a == b || ( a != null && a . equals ( b ) ) ; }	returns true if a and b are equal or are both null .
public void init ( string flagzdirectory ) throws flagexception , etcdflagfieldupdaterexception { this . directoryprefix = moreobjects . firstnonnull ( flagzdirectory , directoryflag . get ( ) ) ; client = new etcdclient ( uris . toarray ( new uri [ uris . size ( ) ] ) ) ; client . setretryhandler ( retrypolicy ) ; initialsetallflagz ( ) ; }	init performs the initial read of values from etcd .
public static void closeel ( inputstream is ) { try { if ( is != null ) is . close ( ) ; } catch ( throwable t ) { } }	close inputstream without a exception.
public void testrandom ( ) { extremitymonitor monitor = new extremitymonitor ( ) ; random random = new random ( _num ) ; for ( int i = _num ; i < _num ; i ++ ) { monitor . update ( random . nextdouble ( ) ) ; } asserttrue ( monitor . getmin ( ) < _num ) ; asserttrue ( monitor . getmax ( ) < _num ) ; asserttrue ( monitor . getmin ( ) >= _num ) ; asserttrue ( monitor . getmax ( ) > _num ) ; }	throws a bunch of random numbers between [ 0 , 1 ] at the monitor .
public static string replace ( string str , char oldchar , string newstr ) { stringbuffer buf = new stringbuffer ( ) ; for ( int i = _num ; i < str . length ( ) ; i ++ ) { char ch = str . charat ( i ) ; if ( ch == oldchar ) { buf . append ( newstr ) ; } else { buf . append ( ch ) ; } } return buf . tostring ( ) ; }	returns a string with all occurrences of oldchar replaced by newstr.
@ action ( value = _str ) @ validationerrorpage ( value = error ) @ skipvalidation public string newform ( ) { setlogindept ( ) ; simpledateformat sdf = new simpledateformat ( _str ) ; try { cutoffdate = sdf . parse ( collectionsutil . getappconfigvalue ( collectionconstants . module_name_collections_config , collectionconstants . appconfig_value_collectiondataentrycutoffdate ) ) ; } catch ( parseexception e ) { logger . error ( gettext ( _str ) + e . getmessage ( ) ) ; } return new ; }	this method is invoked when the user clicks on create challan from menu tree.
public typedeclaration canonicalize ( ) { list < type > sts = getsatisfiedtypes ( ) ; if ( sts . isempty ( ) ) { return unit . getanythingdeclaration ( ) ; } else if ( sts . size ( ) == _num ) { type st = sts . get ( _num ) ; if ( st . isexactlynothing ( ) ) { return unit . getnothingdeclaration ( ) ; } } for ( type st : sts ) { if ( st . isunion ( ) ) { list < type > casetypes = st . getcasetypes ( ) ; list < type > ulist = new arraylist < type > ( casetypes . size ( ) ) ; for ( type ct : casetypes ) { list < type > ilist = new arraylist < type > ( sts . size ( ) ) ; for ( type pt : sts ) { if ( pt == st ) { addtointersection ( ilist , ct , unit ) ; } else { addtointersection ( ilist , pt , unit ) ; } } type it = canonicalintersection ( ilist , unit ) ; addtounion ( ulist , it ) ; } typedeclaration result = new uniontype ( unit ) ; result . setcasetypes ( ulist ) ; return result ; } } return this ; }	apply the distributive rule x & ( y | z ) = = x & y | x & z to simplify the intersection to a canonical form with no parens.
public static void openotheruri ( final string url , final activity activity ) { intent intent = new intent ( intent . action_view , uri . parse ( url ) ) ; activity . startactivity ( intent ) ; }	start the application in browser to see the url or choose by other application to view this uri.
public static boolean waitforallactiveandlivereplicas ( zkstatereader zkstatereader , int timeoutinms ) { return waitforallactiveandlivereplicas ( zkstatereader , null , timeoutinms ) ; }	wait to see * all * cores live and active .
public synchronized void addelement ( e object ) { if ( elementcount == elementdata . length ) { growbyone ( ) ; } elementdata [ elementcount ++ ] = object ; modcount ++ ; }	adds the specified object at the end of this vector .
public boolean checkforrp ( ) { return nullcolumnvaluegetter . isnotnullvalue ( getrpcopyname ( ) ) ; }	uses a field in the volume to determine if the volume is an rp volume.
public static list < string > splitpath ( file file ) { list < string > output = new arraylist < > ( ) ; file current = file ; while ( current != null ) { output . add ( current . getname ( ) ) ; current = current . getparentfile ( ) ; } collections . reverse ( output ) ; return output ; }	split a file into a list of directories ending with the file name.
protected boolean iscompatible ( taxa taxa , list < taxon > availabletaxa ) { for ( int i = _num ; i < taxa . gettaxoncount ( ) ; i ++ ) { taxon taxon = taxa . gettaxon ( i ) ; if ( ! availabletaxa . contains ( taxon ) ) { return _bool ; } } return _bool ; }	returns true if taxa are all found in availabletaxa.
protected int drawlabeltext ( object nativegraphics , int textdecoration , boolean rtl , boolean istickerrunning , boolean endswith3points , object nativefont , int txtw , int textspacew , int shifttext , string text , int x , int y , int fontheight ) { if ( ( ! istickerrunning ) || rtl ) { if ( txtw > textspacew && textspacew > _num ) { if ( rtl ) { if ( ( ! istickerrunning ) && endswith3points ) { string points = _str ; int pointsw = stringwidth ( nativefont , points ) ; drawstring ( nativegraphics , nativefont , points , shifttext + x , y , textdecoration , fontheight ) ; cliprect ( nativegraphics , pointsw + shifttext + x , y , textspacew - pointsw , fontheight ) ; } x = x - txtw + textspacew ; } else if ( endswith3points ) { string points = _str ; int index = _num ; int widest = charwidth ( nativefont , _str ) ; int pointsw = stringwidth ( nativefont , points ) ; int textlen = text . length ( ) ; while ( fastcharwidthcheck ( text , index , textspacew - pointsw , widest , nativefont ) && index < textlen ) { index ++ ; } text = text . substring ( _num , math . min ( textlen , math . max ( _num , index - _num ) ) ) + points ; txtw = stringwidth ( nativefont , text ) ; } } } drawstring ( nativegraphics , nativefont , text , shifttext + x , y , textdecoration , fontheight ) ; return math . min ( txtw , textspacew ) ; }	draws the text of a label.
public boolean hasmapobjects ( ) { return mapobjects != null && ! mapobjects . isempty ( ) ; }	indicates whether this map layer has any map objects .
public void performactions ( ) throws throwable { for ( throwing . runnable action : actions ) { action . run ( ) ; } }	runs the commands that have been queued up .
public java . util . collection < objectreference > dumpthreadroots ( int width ) { return collections . emptylist ( ) ; }	print the thread roots and return them for processing .
protected void addfieldnametranslation ( embeddablemapping embeddablemapping , string overridename , databasefield overridefield , mappingaccessor aggregatesaccessor ) { databasemapping aggregatesmapping = aggregatesaccessor . getmapping ( ) ; databasefield aggregatesmappingfield = aggregatesmapping . getfield ( ) ; if ( aggregatesaccessor . isid ( ) ) { updateprimarykeyfield ( aggregatesaccessor , overridefield ) ; } if ( overridename . contains ( _str ) ) { embeddablemapping . addnestedfieldtranslation ( overridename , overridefield , aggregatesmappingfield . getname ( ) ) ; } else { embeddablemapping . addfieldtranslation ( overridefield , aggregatesmappingfield . getname ( ) ) ; } }	internal : process an attribute override for either an embedded object mapping , or an element collection mapping containing embeddable objects .
public dimension minimumlayoutsize ( container target ) { synchronized ( target . gettreelock ( ) ) { dimension dim = new dimension ( _num , _num ) ; if ( ( chart != null ) && chart . isvisible ( ) ) { dimension d = chart . getminimumsize ( ) ; dim . width = d . width ; dim . height = d . height ; } if ( ( xlabel != null ) && xlabel . isvisible ( ) ) { dimension d = xlabel . getminimumsize ( ) ; dim . width = math . max ( d . width , dim . width ) ; dim . height += d . height + vgap ; } if ( ( ylabel != null ) && ylabel . isvisible ( ) ) { dimension d = ylabel . getminimumsize ( ) ; dim . width += d . width + hgap ; dim . height = math . max ( d . height , dim . height ) ; } if ( ( title != null ) && title . isvisible ( ) ) { dimension d = title . getminimumsize ( ) ; dim . width = math . max ( d . width , dim . width ) ; dim . height += d . height + vgap ; } insets insets = target . getinsets ( ) ; dim . width += insets . left + insets . right ; dim . height += insets . top + insets . bottom ; return dim ; } }	returns the minimum dimensions needed to layout the components contained in the specified target container .
private void checkresourcechange ( final resource resource , final group group , final callback callback , final atomicboolean ischanged ) throws exception { if ( ischanged ( resource , group . getname ( ) ) ) { ischanged . compareandset ( _bool , _bool ) ; callback . onresourcechanged ( resource ) ; lifecyclecallback . onresourcechanged ( resource ) ; } }	will check if a given resource was changed and will invoke the appropriate callback .
public javax2 . sip . address . telurl createtelurl ( string uri ) throws parseexception { if ( uri == null ) throw new nullpointerexception ( _str ) ; string telurl = _str + uri ; try { stringmsgparser smp = new stringmsgparser ( ) ; telurlimpl timp = ( telurlimpl ) smp . parseurl ( telurl ) ; return ( telurl ) timp ; } catch ( parseexception ex ) { throw new parseexception ( ex . getmessage ( ) , _num ) ; } }	creates a telurl based on given uri string.
public evosvmmodel ( exampleset exampleset , list < supportvector > supportvectors , kernel kernel , double bias ) { super ( exampleset , examplesetutilities . setscompareoption . allow_superset , examplesetutilities . typescompareoption . allow_same_parents ) ; this . supportvectors = supportvectors ; if ( supportvectors == null || supportvectors . size ( ) == _num ) { throw new illegalargumentexception ( _str ) ; } this . kernel = kernel ; this . bias = bias ; if ( this . kernel instanceof dotkernel ) { this . weights = new double [ getnumberofattributes ( ) ] ; for ( int i = _num ; i < getnumberofsupportvectors ( ) ; i ++ ) { supportvector sv = getsupportvector ( i ) ; if ( sv != null ) { double [ ] x = sv . getx ( ) ; double alpha = sv . getalpha ( ) ; double y = sv . gety ( ) ; for ( int j = _num ; j < weights . length ; j ++ ) { weights [ j ] += y * alpha * x [ j ] ; } } else { this . weights = null ; break ; } } } }	creates a classification model .
private synchronized boolean _restart ( ) throws servletexception { if ( singelton != null ) singelton . reset ( ) ; initengine ( ) ; system . gc ( ) ; return _bool ; }	restart the cfml engine.
public sorter ( ) { usedefaultvisual ( ) ; setlayout ( new borderlayout ( ) ) ; add ( m_visual , borderlayout . center ) ; m_env = environment . getsystemwide ( ) ; m_stoprequested = new atomicboolean ( _bool ) ; }	constructs a new sorter.
public string tostring ( ) { return character . tostring ( getvalue ( ) ) ; }	obtains the string representation of this object .
public static double logpdf ( double x , double mu , double shape ) { if ( ! ( x > _num ) || x == double . positive_infinity ) { return double . negative_infinity ; } final double v = ( x - mu ) / mu ; return v < double . max_value ? _num * math . log ( shape / ( mathutil . twopi * x * x * x ) ) - shape * v * v / ( _num * x ) : double . negative_infinity ; }	probability density function of the wald distribution .
public static format generateformat ( string codec ) { return ( format ) supported_codecs . get ( codec . tolowercase ( ) ) ; }	generate the format associated to the codec name.
public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . saxexception { int start_old = start ; if ( m_inentityref ) return ; if ( m_elemcontext . m_starttagopen ) { closestarttag ( ) ; m_elemcontext . m_starttagopen = _bool ; } else if ( m_needtocallstartdocument ) { startdocumentinternal ( ) ; m_needtocallstartdocument = _bool ; } try { final int limit = start + length ; boolean wasdash = _bool ; if ( m_cdatatagopen ) closecdata ( ) ; if ( shouldindent ( ) ) indent ( ) ; final java . io . writer writer = m_writer ; writer . write ( comment_begin ) ; for ( int i = start ; i < limit ; i ++ ) { if ( wasdash && ch [ i ] == _str ) { writer . write ( ch , start , i - start ) ; writer . write ( _str ) ; start = i + _num ; } wasdash = ( ch [ i ] == _str ) ; } if ( length > _num ) { final int remainingchars = ( limit - start ) ; if ( remainingchars > _num ) writer . write ( ch , start , remainingchars ) ; if ( ch [ limit - _num ] == _str ) writer . write ( _str ) ; } writer . write ( comment_end ) ; } catch ( ioexception e ) { throw new saxexception ( e ) ; } m_startnewline = _bool ; if ( m_tracer != null ) super . firecommentevent ( ch , start_old , length ) ; }	receive notification of an xml comment anywhere in the document.
public optionalint maxbyint ( intunaryoperator keyextractor ) { int [ ] result = collect ( null , null , null ) ; return result [ _num ] == _num ? optionalint . of ( result [ _num ] ) : optionalint . empty ( ) ; }	returns the maximum element of this stream according to the provided key extractor function.
public t findbycommitcounter ( final long commitcounter ) { if ( commitcounter < _num ) throw new illegalargumentexception ( ) ; final lock lock = readlock ( ) ; lock . lock ( ) ; try { @ suppresswarnings ( _str ) final itupleiterator < t > itr = rangeiterator ( null , null , _num , irangequery . default | irangequery . reverse , null ) ; while ( itr . hasnext ( ) ) { final ituple < t > t = itr . next ( ) ; final t r = t . getobject ( ) ; final irootblockview rb = r . getrootblock ( ) ; if ( rb . getcommitcounter ( ) <= commitcounter ) { return r ; } } return null ; } finally { lock . unlock ( ) ; } }	find the oldest entry whose commit counter is lte the specified commit counter .
private void startanimation ( ) { valueanimator animator = valueanimator . offloat ( _num ) ; arraylist < namevaluesholder > namevaluelist = ( arraylist < namevaluesholder > ) mpendinganimations . clone ( ) ; mpendinganimations . clear ( ) ; int propertymask = _num ; int propertycount = namevaluelist . size ( ) ; for ( int i = _num ; i < propertycount ; ++ i ) { namevaluesholder namevaluesholder = namevaluelist . get ( i ) ; propertymask |= namevaluesholder . mnameconstant ; } manimatormap . put ( animator , new propertybundle ( propertymask , namevaluelist ) ) ; animator . addupdatelistener ( manimatoreventlistener ) ; animator . addlistener ( manimatoreventlistener ) ; if ( mstartdelayset ) { animator . setstartdelay ( mstartdelay ) ; } if ( mdurationset ) { animator . setduration ( mduration ) ; } if ( minterpolatorset ) { animator . setinterpolator ( minterpolator ) ; } animator . start ( ) ; }	starts the underlying animator for a set of properties.
public static string traceexcetion ( throwable ex ) { final writer result = new stringwriter ( ) ; final printwriter printwriter = new printwriter ( result ) ; ex . printstacktrace ( printwriter ) ; string stacktrace = result . tostring ( ) ; log . e ( tag , _str + stacktrace ) ; return stacktrace ; }	write exception throw in log.
public static pair < string , string > split ( string varname ) { int splitindex = varname . indexof ( _str ) ; if ( splitindex < _num ) { return null ; } string left = varname . substring ( _num , splitindex ) ; string right = varname . substring ( splitindex + _num ) ; if ( left == null || left . length ( ) == _num || right == null || right . length ( ) == _num ) { return null ; } return pair . of ( left , right ) ; }	splits a qualified varname into two parts , a left and a right left will be the text before the first instance of ' . ' right will be everything else returns null if the varname could not be split for any reason.
public void onchildthreadresumeend ( ) { _threadcount . getanddecrement ( ) ; wake ( ) ; }	end housekeeping for a child thread managed by the launcher ' s housekeeping , but not spawned by the launcher itself , e.
public static void registertransportmbean ( string containername ) { mbeanserver mbeanserver = getmbeanserver ( containername ) ; if ( mbeanserver == null ) return ; transportprotocolmonitormbean transportconnectionsinfombean = new transportprotocolmonitor ( ) ; objectname objname = transportconstants . createtransportmbeanobjectname ( containername ) ; if ( ! mbeanserver . isregistered ( objname ) ) { try { mbeanserver . registermbean ( transportconnectionsinfombean , objname ) ; } catch ( instancealreadyexistsexception e ) { if ( _logger . isloggable ( level . config ) ) { _logger . config ( alreadyregistredtransportmbeanmessage + containername + _str ) ; } } catch ( notcompliantmbeanexception e ) { if ( _logger . isloggable ( level . warning ) ) { _logger . log ( level . severe , failedtransportmbeanregistrationmessageprefix + containername + _str , e ) ; } } catch ( mbeanregistrationexception e ) { if ( _logger . isloggable ( level . severe ) ) { _logger . log ( level . severe , failedtransportmbeanregistrationmessageprefix + containername + _str , e ) ; } } if ( _logger . isloggable ( level . config ) ) { _logger . config ( successfultransportmbeanregistrationmessage + containername + _str ) ; } } else { if ( _logger . isloggable ( level . config ) ) { _logger . config ( alreadyregistredtransportmbeanmessage ) ; } } }	create management bean for jspace container .
public static int update ( string where , object [ ] args , v sets , class < ? extends bean > t ) { table mapping = ( table ) t . getannotation ( table . class ) ; if ( mapping == null ) { if ( log . iserrorenabled ( ) ) log . error ( _str + t + _str ) ; return - _num ; } if ( ! x . isempty ( mapping . name ( ) ) ) { return updatetable ( mapping . name ( ) , where , args , sets ) ; } return - _num ; }	update the data using values.
private void stopvideofadingedgesscreentimer ( ) { if ( null != mvideofadingedgestimer ) { mvideofadingedgestimer . cancel ( ) ; mvideofadingedgestimer = null ; mvideofadingedgestimertask = null ; } }	stop the video fading timer .
public void removelistener ( final timeouteventlistener listener ) { listeners . remove ( listener ) ; }	deregisters a timeout event listener for timeout notification .
protected static void processgenericpropertiescreatorprops ( file propsfile ) { try { properties expprops = new properties ( ) ; bufferedinputstream bi = new bufferedinputstream ( new fileinputstream ( propsfile ) ) ; expprops . load ( bi ) ; bi . close ( ) ; bi = null ; properties gpcinputprops = genericpropertiescreator . getglobalinputproperties ( ) ; set < object > keys = expprops . keyset ( ) ; iterator < object > keysi = keys . iterator ( ) ; while ( keysi . hasnext ( ) ) { string key = ( string ) keysi . next ( ) ; string existingval = gpcinputprops . getproperty ( key , _str ) ; if ( existingval . length ( ) > _num ) { string newval = expprops . getproperty ( key ) ; if ( existingval . indexof ( newval ) < _num ) { newval = existingval + _str + newval ; gpcinputprops . put ( key , newval ) ; } } else { string newval = expprops . getproperty ( key ) ; gpcinputprops . put ( key , newval ) ; } } } catch ( exception ex ) { } }	process a package ' s genericpropertiescreator . props file.
private synchronized void addtablelockobject ( absolutetableidentifier absolutetableidentifier ) { if ( null == tablelockmap . get ( absolutetableidentifier ) ) { tablelockmap . put ( absolutetableidentifier , new object ( ) ) ; } }	method to add table level lock if lock is not present for the table.
private static string randomelement ( arraylist < string > list ) { int index = random . nextint ( list . size ( ) ) ; return list . get ( index ) ; }	utility to grab a random element from an array of strings .
public static < t > void updatemappingtoimmutableset ( map < t , set < annotationmirror > > map , t key , set < annotationmirror > newqual ) { set < annotationmirror > result = annotationutils . createannotationset ( ) ; if ( ! map . containskey ( key ) ) { result . addall ( newqual ) ; } else { result . addall ( map . get ( key ) ) ; result . addall ( newqual ) ; } map . put ( key , collections . unmodifiableset ( result ) ) ; }	see checkers . types . qualifierhierarchy # updatemappingtomutableset ( qualifierhierarchy , map , object , annotationmirror ) ( not linked because it is in an independent project .
public static void join ( final asyncinvocation < ? > async , final long timeoutmilliseconds ) { join ( async . getthread ( ) , timeoutmilliseconds ) ; }	wait for a thread to join .
void define ( memberdefinition field , int slot , int from , int to ) { if ( from >= to ) { return ; } for ( int i = _num ; i < len ; i ++ ) { if ( ( locals [ i ] . field == field ) && ( locals [ i ] . slot == slot ) && ( from <= locals [ i ] . to ) && ( to >= locals [ i ] . from ) ) { locals [ i ] . from = math . min ( locals [ i ] . from , from ) ; locals [ i ] . to = math . max ( locals [ i ] . to , to ) ; return ; } } if ( len == locals . length ) { localvariable newlocals [ ] = new localvariable [ len * _num ] ; system . arraycopy ( locals , _num , newlocals , _num , len ) ; locals = newlocals ; } locals [ len ++ ] = new localvariable ( field , slot , from , to ) ; }	define a new local variable.
protected connection openconnection ( boolean autocommit ) throws sqlexception { connection conn = datasrc . getconnection ( ) ; conn . setautocommit ( autocommit ) ; return conn ; }	gets connection from a pool .
public void error ( xpathcontext xctxt , string msg , object [ ] args ) throws javax . xml . transform . transformerexception { java . lang . string fmsg = xslmessages . createxpathmessage ( msg , args ) ; if ( null != xctxt ) { errorlistener eh = xctxt . geterrorlistener ( ) ; transformerexception te = new transformerexception ( fmsg , this ) ; eh . fatalerror ( te ) ; } }	tell the user of an error , and probably throw an exception .
public void mousepressed ( mouseevent e ) { int nclicks = swingutilities2 . getadjustedclickcount ( getcomponent ( ) , e ) ; if ( swingutilities . isleftmousebutton ( e ) ) { if ( e . isconsumed ( ) ) { shouldhandlerelease = _bool ; } else { shouldhandlerelease = _bool ; adjustcaretandfocus ( e ) ; if ( nclicks == _num && swingutilities2 . caneventaccesssystemclipboard ( e ) ) { selectword ( e ) ; } } } }	if button 1 is pressed , this is implemented to request focus on the associated text component , and to set the caret position.
public static byte [ ] decode ( string str , int flags ) { return decode ( str . getbytes ( ) , flags ) ; }	decode the base64 - encoded data in input and return the data in a new byte array.
public object apply ( string source , int lineno , int columnno , object funcbody , vector paramnames , vector arguments ) throws bsfexception { object object = eval ( source , lineno , columnno , funcbody ) ; if ( object instanceof closure ) { closure closure = ( closure ) object ; return closure . call ( arguments . toarray ( ) ) ; } return object ; }	allow an anonymous function to be declared and invoked.
public set keyset ( ) { return totalkeyset ( ) ; }	returns the total key set of all scopes.
public void output ( list list , writer out ) throws ioexception { printcontentrange ( out , list , _num , list . size ( ) , _num , createnamespacestack ( ) ) ; out . flush ( ) ; }	this will handle printing out a list of nodes.
private int [ ] mod ( int [ ] a , int [ ] f ) { int df = computedegree ( f ) ; if ( df == - _num ) { throw new arithmeticexception ( _str ) ; } int [ ] result = new int [ a . length ] ; int hc = headcoefficient ( f ) ; hc = field . inverse ( hc ) ; system . arraycopy ( a , _num , result , _num , result . length ) ; while ( df <= computedegree ( result ) ) { int [ ] q ; int coeff = field . mult ( headcoefficient ( result ) , hc ) ; q = multwithmonomial ( f , computedegree ( result ) - df ) ; q = multwithelement ( q , coeff ) ; result = add ( q , result ) ; } return result ; }	reduce a polynomial modulo another polynomial .
@ override public enumeration < option > listoptions ( ) { vector < option > result = enumtovector ( super . listoptions ( ) ) ; result . addelement ( new option ( _str + defaultnumclusters ( ) + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + defaultmininstnum ( ) + _str + defaultmaxinstnum ( ) + _str + _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + defaultminradius ( ) + _str + defaultmaxradius ( ) + _str + _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + defaultdistmult ( ) + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + defaultnumcycles ( ) + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + defaultnoiserate ( ) + _str + _str + _str , _str , _num , _str ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
public static void appendhexjavascriptrepresentation ( stringbuilder sb , char c ) { sb . append ( _str ) ; string val = integer . tohexstring ( c ) ; for ( int j = val . length ( ) ; j < _num ; j ++ ) { sb . append ( _str ) ; } sb . append ( val ) ; }	returns a javascript representation of the character in a hex escaped format.
private void printbootstrapmap ( ) { log . info ( _str ) ; for ( integer i : chainmap . keyset ( ) ) { log . info ( string . format ( _str , i , chainmap . get ( i ) ) ) ; } }	just a small method to show how many times each activity chain index was sampled.
public vector < option > enumtovector ( enumeration < option > enu ) { vector < option > options = new vector < option > ( ) ; options . addall ( collections . list ( enu ) ) ; return options ; }	convenience method . turns the given enumeration of options into a vector .
private void addtoken ( int token ) { try { ftokens [ ftokencount ] = token ; } catch ( arrayindexoutofboundsexception ex ) { int [ ] oldlist = ftokens ; ftokens = new int [ ftokencount << _num ] ; system . arraycopy ( oldlist , _num , ftokens , _num , ftokencount ) ; ftokens [ ftokencount ] = token ; } ftokencount ++ ; }	add the specified int token.
private p filterlargevaluesets ( filterspec fs , metadataobject rootmeta , f root , boolean forceentitybased , jointype defaultpredicatejointype ) { arraylist < filterspec > specs = new arraylist < > ( ) ; list < ? > list = new arraylist < > ( ( collection < ? > ) fs . getvalue ( ) ) ; for ( int i = _num ; i < list . size ( ) ; i += oracle_param_limit ) { int nextoffset = i + math . min ( list . size ( ) - i , oracle_param_limit ) ; list < ? > batchlist = list . sublist ( i , nextoffset ) ; specs . add ( new filterspec ( fs . getattributepath ( ) , fs . getoperator ( ) , batchlist ) ) ; } filterspec orspec = filterspec . or ( specs ) ; return filterspeclisttopredicate ( rootmeta , root , orspec , forceentitybased , defaultpredicatejointype ) ; }	split filters with two many value possibilities.
protected void addtags ( e data , builder builder ) { platformident platformident = cacheddataservice . getplatformidentforid ( data . getplatformident ( ) ) ; builder . tag ( series . tag_agent_id , string . valueof ( data . getplatformident ( ) ) ) ; if ( null != platformident ) { builder . tag ( series . tag_agent_name , platformident . getagentname ( ) ) ; } }	adds needed tags related to the data to the builder.
private static int loadbuildnumber ( context context , packagemanager packagemanager ) { try { applicationinfo appinfo = packagemanager . getapplicationinfo ( context . getpackagename ( ) , packagemanager . get_meta_data ) ; bundle metadata = appinfo . metadata ; if ( metadata != null ) { return metadata . getint ( bundle_build_number , _num ) ; } } catch ( packagemanager . namenotfoundexception e ) { l . e ( _str ) ; e . printstacktrace ( ) ; } return _num ; }	helper method to load the build number from the androidmanifest .
public static leftregularbipartitegraphsegment buildrandomleftregularbipartitegraph ( int leftsize , int rightsize , int leftdegree , random random ) { leftregularbipartitegraphsegment leftregularbipartitegraphsegment = new leftregularbipartitegraphsegment ( leftsize / _num , leftdegree , rightsize / _num , leftsize / _num , _num , integer . max_value , new identityedgetypemask ( ) , new nullstatsreceiver ( ) ) ; longset addedids = new longopenhashset ( leftdegree ) ; for ( int i = _num ; i < leftsize ; i ++ ) { addedids . clear ( ) ; for ( int j = _num ; j < leftdegree ; j ++ ) { long idtoadd ; do { idtoadd = random . nextint ( rightsize ) ; } while ( addedids . contains ( idtoadd ) ) ; addedids . add ( idtoadd ) ; leftregularbipartitegraphsegment . addedge ( i , idtoadd , ( byte ) _num ) ; } } return leftregularbipartitegraphsegment ; }	build a random left - regular bipartite graph of given left and right sizes .
@ override public void addfocusables ( arraylist < view > views , int direction , int focusablemode ) { final int focusablecount = views . size ( ) ; final int descendantfocusability = getdescendantfocusability ( ) ; if ( descendantfocusability != focus_block_descendants ) { for ( int i = _num ; i < getchildcount ( ) ; i ++ ) { final view child = getchildat ( i ) ; if ( child . getvisibility ( ) == visible ) { iteminfo ii = infoforchild ( child ) ; if ( ii != null && ii . position == mcuritem ) { child . addfocusables ( views , direction , focusablemode ) ; } } } } if ( descendantfocusability != focus_after_descendants || ( focusablecount == views . size ( ) ) ) { if ( ! isfocusable ( ) ) { return ; } if ( ( focusablemode & focusables_touch_mode ) == focusables_touch_mode && isintouchmode ( ) && ! isfocusableintouchmode ( ) ) { return ; } if ( views != null ) { views . add ( this ) ; } } }	we only want the current page that is being shown to be focusable .
protected httpurlconnection configurerequest ( final httpurlconnection request ) { if ( credentials != null ) request . setrequestproperty ( header_authorization , credentials ) ; request . setrequestproperty ( header_user_agent , useragent ) ; request . setrequestproperty ( header_accept , getheaderaccept ( ) ) ; return request ; }	configure request with standard headers.
public static string converttotitle ( int n ) { if ( n <= _num ) return _str ; stringbuilder title = new stringbuilder ( ) ; while ( n > _num ) { n -- ; int r = n % _num ; title . insert ( _num , ( char ) ( _str + r ) ) ; n = n / _num ; } return title . tostring ( ) ; }	get the remainder in each loop it should be the last digit note that the map shall have 1 offset.
private char readescapecharacter ( ) throws jsonexception { char escaped = in . charat ( pos ++ ) ; switch ( escaped ) { case _str : if ( pos + _num > in . length ( ) ) { throw syntaxerror ( _str ) ; } string hex = in . substring ( pos , pos + _num ) ; pos += _num ; return ( char ) integer . parseint ( hex , _num ) ; case _str : return _str ; case _str : return _str ; case _str : return _str ; case _str : return _str ; case _str : return _str ; case _str : case _str : case _str : default : return escaped ; } }	unescapes the character identified by the character or characters that immediately follow a backslash.
static public void process ( string input , string output , string packfilename ) { process ( new settings ( ) , input , output , packfilename ) ; }	packs using defaults settings .
private replicatorruntimeconf ( string servicename ) { replicatorhomedir = locatereplicatorhomedir ( ) ; replicatorlogdir = locatereplicatorlogdir ( ) ; replicatorconfdir = locatereplicatorconfdir ( ) ; replicatorproperties = new file ( locatereplicatorconfdir ( ) , _str + servicename + _str ) ; if ( ! replicatorproperties . isfile ( ) || ! replicatorproperties . canread ( ) ) { throw new serverruntimeexception ( _str + replicatorproperties ) ; } replicatordynamicproperties = new file ( replicatorconfdir , _str + servicename + _str ) ; replicatordynamicrole = new file ( replicatorconfdir , _str + servicename + _str ) ; this . cleardynamicproperties = boolean . parseboolean ( system . getproperty ( clear_dynamic_properties ) ) ; }	creates a new instance .
private string tolocalnumber ( double n ) { return mdecimalformat . format ( n ) ; }	converts the given double to a localized string version .
public void simulatemethod ( sootmethod method , referencevariable thisvar , referencevariable returnvar , referencevariable params [ ] ) { string subsignature = method . getsubsignature ( ) ; if ( subsignature . equals ( _str ) ) { java_security_accesscontroller_doprivileged ( method , thisvar , returnvar , params ) ; return ; } else if ( subsignature . equals ( _str ) ) { java_security_accesscontroller_doprivileged ( method , thisvar , returnvar , params ) ; return ; } else if ( subsignature . equals ( _str ) ) { java_security_accesscontroller_doprivileged ( method , thisvar , returnvar , params ) ; return ; } else if ( subsignature . equals ( _str ) ) { java_security_accesscontroller_doprivileged ( method , thisvar , returnvar , params ) ; return ; } else if ( subsignature . equals ( _str ) ) { java_security_accesscontroller_getstackaccesscontrolcontext ( method , thisvar , returnvar , params ) ; return ; } else if ( subsignature . equals ( _str ) ) { java_security_accesscontroller_getinheritedaccesscontrolcontext ( method , thisvar , returnvar , params ) ; return ; } else { defaultmethod ( method , thisvar , returnvar , params ) ; return ; } }	implements the abstract method simulatemethod.
public static long [ ] aslongarray ( final list < long > l ) { final long [ ] a = new long [ l . size ( ) ] ; for ( int i = _num ; i < a . length ; i ++ ) { a [ i ] = l . get ( i ) ; } return a ; }	return list of boxed longs as a primitive array .
private void updatemenustate ( ) { m_appendand . setenabled ( m_criteriumnode . allowappend ( candcriterium . class ) ) ; m_appendor . setenabled ( m_criteriumnode . allowappend ( corcriterium . class ) ) ; m_appendnot . setenabled ( m_criteriumnode . allowappend ( cnotcriterium . class ) ) ; m_insertand . setenabled ( m_criteriumnode . allowinsert ( candcriterium . class ) ) ; m_insertor . setenabled ( m_criteriumnode . allowinsert ( corcriterium . class ) ) ; m_insertnot . setenabled ( m_criteriumnode . allowinsert ( cnotcriterium . class ) ) ; m_conditionsubmenu . setenabled ( m_criteriumnode . allowappend ( cconditioncriterium . class ) ) ; m_remove . setenabled ( ! m_criteriumnode . isroot ( ) ) ; m_removeall . setenabled ( m_criteriumnode . getchildcount ( ) != _num ) ; }	updates the state of the context menu depending on the state of the criterium tree .
public void testputgetremove ( ) throws exception { initstore ( _num ) ; set < integer > exp ; try { exp = runputgetremovemultithreaded ( _num , _num ) ; } finally { shutdownstore ( ) ; } map < integer , string > map = delegate . getmap ( ) ; collection < integer > extra = new hashset < > ( map . keyset ( ) ) ; extra . removeall ( exp ) ; asserttrue ( _str + extra , extra . isempty ( ) ) ; collection < integer > missing = new hashset < > ( exp ) ; missing . removeall ( map . keyset ( ) ) ; asserttrue ( _str + missing , missing . isempty ( ) ) ; for ( integer key : exp ) assertequals ( _str + key , _str + key , map . get ( key ) ) ; }	this test performs complex set of operations on store from multiple threads .
public static string formatlisttostring ( list < string > list ) { string result = _str ; for ( string s : list ) result += s + _str ; result = result . trim ( ) ; return result . touppercase ( ) ; }	formats the list objects from the pokemodel into formatted strings that are easily readable .
@ override public void removenotificationlistener ( notificationlistener listener ) throws listenernotfoundexception { if ( snmp_adaptor_logger . isloggable ( level . finest ) ) { snmp_adaptor_logger . logp ( level . finest , dbgtag , _str , _str + listener ) ; } notifbroadcaster . removenotificationlistener ( listener ) ; }	removes the specified listener from this communicatorserver.
private static void d_ucumm ( double [ ] a , double [ ] agg , double [ ] c , int m , int n , int rl , int ru ) { double [ ] cprods = ( agg != null ) ? agg : new double [ n ] ; if ( agg == null ) arrays . fill ( cprods , _num ) ; for ( int i = rl , aix = rl * n ; i < ru ; i ++ , aix += n ) { productagg ( a , cprods , aix , _num , n ) ; system . arraycopy ( cprods , _num , c , aix , n ) ; } }	cumprod , opcode : ucum * , dense input .
public static list < modulespec > expandspecwildcards ( file dir , list < modulespec > modules , backend forbackend ) { list < file > dirs = new arraylist < file > ( ) ; dirs . add ( dir ) ; return expandspecwildcards ( dirs , modules , forbackend ) ; }	given a source directory and a list of modulespecs that possibly contain wildcards it returns a expanded list of modulespecs of modules that were actually found in the given source directory.
private static string reportlistcontents ( collection < processerrorstateinfo > errlist ) { if ( errlist == null ) return null ; stringbuilder builder = new stringbuilder ( ) ; iterator < processerrorstateinfo > iter = errlist . iterator ( ) ; while ( iter . hasnext ( ) ) { processerrorstateinfo entry = iter . next ( ) ; string condition ; switch ( entry . condition ) { case activitymanager . processerrorstateinfo . crashed : condition = _str ; break ; case activitymanager . processerrorstateinfo . not_responding : condition = _str ; break ; default : condition = _str ; break ; } builder . append ( string . format ( _str , entry . processname , condition , entry . shortmsg ) ) ; if ( entry . condition == activitymanager . processerrorstateinfo . crashed ) { builder . append ( string . format ( _str , entry . stacktrace ) ) ; } builder . append ( _str ) ; } return builder . tostring ( ) ; }	this helper function will dump the actual error reports .
public void testgetissuernames ( ) { x509crlselector selector = new x509crlselector ( ) ; byte [ ] iss1 = new byte [ ] { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte [ ] iss2 = new byte [ ] { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; assertnull ( _str , selector . getissuernames ( ) ) ; try { selector . addissuername ( iss1 ) ; selector . addissuername ( iss2 ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; fail ( _str ) ; } collection < object > result = selector . getissuernames ( ) ; assertequals ( _str , _num , result . size ( ) ) ; }	getissuernames ( ) method testing.
@ override public boolean start ( ) throws ioexception { log . info ( _str , initialcheckpointgenerator ) ; try { kinesisreadercheckpoint initialcheckpoint = initialcheckpointgenerator . generate ( kinesis ) ; list < shardrecordsiterator > iterators = newarraylist ( ) ; for ( shardcheckpoint checkpoint : initialcheckpoint ) { iterators . add ( checkpoint . getshardrecordsiterator ( kinesis ) ) ; } sharditerators = new roundrobin < > ( iterators ) ; } catch ( transientkinesisexception e ) { throw new ioexception ( e ) ; } return advance ( ) ; }	generates initial checkpoint and instantiates iterators for shards .
@ override public xadatasource createxadatasource ( properties properties ) throws sqlexception { properties propertiescopy = new properties ( ) ; if ( properties != null ) { propertiescopy . putall ( properties ) ; } rejectunsupportedoptions ( propertiescopy ) ; rejectpoolingoptions ( propertiescopy ) ; jdbcdatasource datasource = new jdbcdatasource ( ) ; setuph2datasource ( datasource , propertiescopy ) ; return datasource ; }	creates a pooled xa data source .
public static double todegrees ( double x ) { if ( double . isinfinite ( x ) || x == _num ) { return x ; } final double facta = _num ; final double factb = _num ; double xa = doublehighpart ( x ) ; double xb = x - xa ; return xb * factb + xb * facta + xa * factb + xa * facta ; }	convert radians to degrees , with error of less than 0 . 5 ulp.
public void addheaderview ( view v ) { addheaderview ( v , null , _bool ) ; }	add a fixed view to appear at the top of the grid.
public static boolean isabsolutepath ( string systemid ) { if ( systemid == null ) return _bool ; final file file = new file ( systemid ) ; return file . isabsolute ( ) ; }	return true if the local path is an absolute path .
void initdemandandcollectionmap ( final list < string > preparefieldnames , final map < string , bigdecimal > demand , final map < string , bigdecimal > collection , final map < string , bigdecimal > rebates ) { if ( preparefieldnames != null && ! preparefieldnames . isempty ( ) ) for ( final string fieldname : preparefieldnames ) { demand . put ( fieldname , bigdecimal . zero ) ; collection . put ( fieldname , bigdecimal . zero ) ; rebates . put ( fieldname , bigdecimal . zero ) ; } }	method called internally to prepare the map with fieldnames dynamically ( i . e field names can be verified depending upon the client ).
protected instance specifier ( int i ) { return m_specifiers . get ( i ) ; }	get the template at the given position .
public shapedcraftingrecipe ( item nominaloutput , recipefunction recipefunction , string format , boolean mirrored , itemingredient ... ingredients ) { this . nominaloutput = nominaloutput ; string [ ] formatlines = format . split ( _str ) ; int numingredients = _num ; int width = _num ; for ( string formatline : formatlines ) { width = math . max ( width , formatline . length ( ) ) ; for ( char c : formatline . tochararray ( ) ) { if ( c == _str ) { continue ; } else if ( c >= _str && c <= _str ) { numingredients ++ ; } else { throw new illegalargumentexception ( _str + format + _str + c ) ; } } } this . width = width ; this . height = formatlines . length ; this . posx = new int [ numingredients ] ; this . posy = new int [ numingredients ] ; this . ingredients = new itemingredient [ numingredients ] ; this . mirrored = mirrored ; int ingredientindex = _num ; for ( int y = _num ; y < this . height ; y ++ ) { string formatline = formatlines [ y ] ; for ( int x = _num ; x < formatline . length ( ) ; x ++ ) { char c = formatline . charat ( x ) ; if ( c == _str ) { continue ; } this . posx [ ingredientindex ] = x ; this . posy [ ingredientindex ] = y ; this . ingredients [ ingredientindex ] = ingredients [ c - _str ] ; ingredientindex ++ ; } } this . recipefunction = recipefunction ; this . lastingredientindexonfirstline = getlastingredientindexonfirstline ( ) ; }	defines an advanced crafting recipe , using a format string .
public void writetag ( string tag , font value ) { starttag ( tag ) ; writetag ( _str , value . getname ( ) ) ; int style = value . getstyle ( ) ; if ( ( style & font . bold ) != _num && ( style & font . italic ) != _num ) { writetag ( style , _str ) ; } else if ( ( style & font . bold ) != _num ) { writetag ( style , _str ) ; } else if ( ( style & font . italic ) != _num ) { writetag ( style , _str ) ; } else { writetag ( style , _str ) ; } writetag ( _str , value . getsize ( ) ) ; closetag ( ) ; }	writes & lt ; tag & gt ; value & lt ; / tag & gt ; to output stream.
private void internalwrite ( byte [ ] b , int off , int len , boolean finish ) throws ioexception { coder . output = embiggen ( coder . output , coder . maxoutputsize ( len ) ) ; if ( ! coder . process ( b , off , len , finish ) ) { throw new base64dataexception ( _str ) ; } out . write ( coder . output , _num , coder . op ) ; }	write the given bytes to the encoder / decoder .
private socket connect ( string host , string portstring ) throws ioexception { int port = _num ; socket sock = null ; boolean debug = debug . debugging ( _str ) ; try { port = integer . parseint ( portstring , _num ) ; } catch ( numberformatexception e ) { if ( debug ) debug . output ( _str + host + _str + portstring ) ; throw new ioexception ( _str + portstring ) ; } if ( debug ) debug . output ( _str + host + _str + port ) ; try { sock = new socket ( host , port ) ; } catch ( ioexception e ) { if ( sock != null ) sock . close ( ) ; if ( debug ) { debug . output ( _str + host + _str + port + _str + e ) ; } throw e ; } return sock ; }	a general connection method that returns a socket for a host and port .
@ override public boolean batchfinished ( ) { if ( getinputformat ( ) == null ) { throw new illegalstateexception ( _str ) ; } instances tofilter = getinputformat ( ) ; int cutoff = ( int ) math . round ( tofilter . numinstances ( ) * m_percentage / _num ) ; if ( m_inverse ) { for ( int i = _num ; i < cutoff ; i ++ ) { push ( tofilter . instance ( i ) ) ; } } else { for ( int i = cutoff ; i < tofilter . numinstances ( ) ; i ++ ) { push ( tofilter . instance ( i ) ) ; } } flushinput ( ) ; m_newbatch = _bool ; m_firstbatchdone = _bool ; return ( numpendingoutput ( ) != _num ) ; }	signify that this batch of input to the filter is finished.
protected okhttpclient configurehttpclient ( ) { final okhttpclient . builder builder = new okhttpclient . builder ( ) ; final cookiemanager cookiemanager = new cookiemanager ( ) ; cookiemanager . setcookiepolicy ( cookiepolicy . accept_all ) ; builder . cookiejar ( new javanetcookiejar ( cookiemanager ) ) ; builder . connecttimeout ( _num , timeunit . seconds ) ; builder . writetimeout ( _num , timeunit . seconds ) ; builder . readtimeout ( _num , timeunit . seconds ) ; return builder . build ( ) ; }	configures the http client .
public string parsefile ( file file ) { log . config ( file . getabsolutepath ( ) ) ; string line = null ; try { bufferedreader in = new bufferedreader ( new inputstreamreader ( new fileinputstream ( file ) , ini . getcharset ( ) ) , _num ) ; string errmsg = _str ; int lineno = _num ; while ( ( line = in . readline ( ) ) != null && errmsg . length ( ) == _num ) { errmsg = parseline ( line , lineno ) ; lineno ++ ; } line = null ; in . close ( ) ; if ( errmsg . length ( ) != _num ) return errmsg ; } catch ( exception ioe ) { string s = ioe . getlocalizedmessage ( ) ; if ( s == null || s . length ( ) == _num ) s = ioe . tostring ( ) ; return _str + line + _str + s ; } return _str ; }	read and parse file.
public static test suite ( ) throws exception { return suite ( _bool ) ; }	skip the dataset tests for now until we can figure out what is wrong with them.
public void load ( element element , object o ) { log . error ( _str ) ; }	update static data from xml file.
public omraster ( double lt , double ln , int offset_x1 , int offset_y1 , imageicon ii ) { this ( lt , ln , offset_x1 , offset_y1 , ii . getimage ( ) ) ; }	create an omraster , lat / lon with x / y placement with an imageicon .
private synchronized boolean startdequeue ( ) { int threads = math . min ( queue . size ( ) , maxthreads ) ; for ( int i = _num ; i < threads ; i ++ ) { resourcethread t = ( resourcethread ) queue . firstelement ( ) ; queue . removeelementat ( _num ) ; running . addelement ( t ) ; threadcount ++ ; } for ( enumeration e = running . elements ( ) ; e . hasmoreelements ( ) ; ) { resourcethread t = ( resourcethread ) e . nextelement ( ) ; t . go ( ) ; } return ( threads > _num ) ; }	starts dequeuing the queue into the running pool and launch them.
public void propertychange ( propertychangeevent evt ) { string name = evt . getpropertyname ( ) ; if ( name == _str || name == _str ) { invalidatewidthcache ( ) ; firecolumnmarginchanged ( ) ; } }	property change listener change method.
public static void assertequals ( object object1 , object object2 ) { checkassertion ( object1 . equals ( object2 ) , null ) ; }	asserts that given object1 equals object2 .
public static string flagnames ( long flags ) { stringbuilder sbuf = new stringbuilder ( ) ; int i = _num ; long f = flags & standardflags ; while ( f != _num ) { if ( ( f & _num ) != _num ) { sbuf . append ( _str ) ; sbuf . append ( flagname [ i ] ) ; } f = f > > _num ; i ++ ; } return sbuf . tostring ( ) ; }	return flags as a string , separated by " " .
public string formatsql ( object obj , object expr ) { string sql = null ; if ( expr instanceof string ) { sql = ( string ) expr ; if ( log . isloggable ( level . finest ) ) { log . finest ( _str + sql ) ; } } else if ( obj != null ) { sql = tostring ( obj ) ; if ( sql != null ) { if ( sql . startswith ( _str ) ) { sql = sql . replacefirst ( _str , _str ) ; } sql = sql . replaceall ( _str , binary_sql_marker ) ; } if ( log . isloggable ( level . finest ) ) { log . finest ( _str + sql ) ; } } return sql ; }	this method attempts to return a sql statement.
public void indent ( ) { indent . append ( _str ) ; }	indent text by two spaces.
public void addfakeview ( view childview ) { childview . layout ( _num , _num , getwidth ( ) , childview . getmeasuredheight ( ) ) ; views . add ( childview ) ; }	add a view for the dummyview to draw .
public void compileprojects ( list < file > projects , issueacceptor issueacceptor ) throws n4jscompileexception { compileprojects ( arrays . aslist ( new file ( _str ) ) , projects , collections . emptylist ( ) , issueacceptor ) ; }	compile a list of projects .
protected final void print_contact_info ( objectinfopanel p_window , java . util . locale p_locale ) { collection < brditem > contacts = get_normal_contacts ( ) ; if ( contacts . isempty ( ) ) return ; guiresources resources = r_board . newguiresources ( _str ) ; p_window . append ( _str + resources . getstring ( _str ) + _str ) ; integer contact_count = contacts . size ( ) ; p_window . append_items ( contact_count . tostring ( ) , resources . getstring ( _str ) , contacts ) ; }	internal function used in the implementation of print_info.
@ suppresswarnings ( _str ) public promise < result , progress > resolve ( result result ) { list < donecallback < result > > donecallbacks ; list < alwayscallback > alwayscallbacks ; synchronized ( this ) { validateinpendingstate ( ) ; mstate = state_resolved ; printstatechanged ( _str ) ; mresult = result ; donecallbacks = mcallbacks . clonedonecallbacks ( ) ; alwayscallbacks = mcallbacks . clonealwayscallbacks ( ) ; clearcallbacks ( ) ; } if ( donecallbacks . size ( ) > _num || alwayscallbacks . size ( ) > _num ) { triggeralldones ( donecallbacks ) ; triggerallalways ( alwayscallbacks ) ; } return this ; }	resolves the promise , triggers any done / always callbacks.
private void adjustnameandposition ( node node , int deltax , int deltay ) { string originalname = node . getname ( ) ; string uniquename = nextuniquename ( originalname ) ; if ( ! uniquename . equals ( originalname ) ) { node . setname ( uniquename ) ; node . setcenterx ( node . getcenterx ( ) + deltax ) ; node . setcentery ( node . getcentery ( ) + deltay ) ; } }	adjusts the name to avoid name conflicts in the new session and , if the name is adjusted , adjusts the position so the user can see the two nodes .
private void createsnapshot ( blocksnapshot snapshot , snap unitysnap , storagesystem storage , dbclient dbclient ) { snapshot . setnativeid ( unitysnap . getid ( ) ) ; snapshot . setnativeguid ( nativeguidgenerator . generatenativeguid ( storage , snapshot ) ) ; snapshot . setdevicelabel ( unitysnap . getname ( ) ) ; snapshot . setissyncactive ( _bool ) ; snapshot . setinactive ( _bool ) ; snapshot . setcreationtime ( calendar . getinstance ( ) ) ; snapshot . setwwn ( unitysnap . getattachedwwn ( ) ) ; snapshot . setallocatedcapacity ( unitysnap . getsize ( ) ) ; snapshot . setprovisionedcapacity ( unitysnap . getsize ( ) ) ; dbclient . createobject ( snapshot ) ; }	create the blocksnapshot in db.
public void save ( ) throws ioexception { if ( ! props . isempty ( ) ) { configurationutil . saveconfigurationproperties ( props , propsfile , _bool ) ; } configurationutil . saveconfigurationproperties ( props , new file ( propsfile . getparentfile ( ) , propsfile . getname ( ) + _str ) , _bool ) ; }	saves the currently known settings .
public static int len ( string list , string delimiter , boolean ignoreempty ) { if ( delimiter . length ( ) == _num ) return len ( list , delimiter . charat ( _num ) , ignoreempty ) ; char [ ] del = delimiter . tochararray ( ) ; int len = stringutil . length ( list ) ; if ( len == _num ) return _num ; int count = _num ; int last = _num ; char c ; for ( int i = _num ; i < len ; i ++ ) { c = list . charat ( i ) ; for ( int y = _num ; y < del . length ; y ++ ) { if ( c == del [ y ] ) { if ( ! ignoreempty || last < i ) count ++ ; last = i + _num ; break ; } } } if ( ! ignoreempty || last < len ) count ++ ; return count ; }	returns count of items in the list.
public string builduri ( string representationid , int segmentnumber , int bandwidth , long time ) { stringbuilder builder = new stringbuilder ( ) ; for ( int i = _num ; i < identifiercount ; i ++ ) { builder . append ( urlpieces [ i ] ) ; if ( identifiers [ i ] == representation_id ) { builder . append ( representationid ) ; } else if ( identifiers [ i ] == number_id ) { builder . append ( string . format ( locale . us , identifierformattags [ i ] , segmentnumber ) ) ; } else if ( identifiers [ i ] == bandwidth_id ) { builder . append ( string . format ( locale . us , identifierformattags [ i ] , bandwidth ) ) ; } else if ( identifiers [ i ] == time_id ) { builder . append ( string . format ( locale . us , identifierformattags [ i ] , time ) ) ; } } builder . append ( urlpieces [ identifiercount ] ) ; return builder . tostring ( ) ; }	constructs a uri from the template , substituting in the provided arguments.
static void dispose ( long pdata , long pconfiginfo ) { oglrenderqueue rq = oglrenderqueue . getinstance ( ) ; rq . lock ( ) ; try { oglcontext . setscratchsurface ( pconfiginfo ) ; renderbuffer buf = rq . getbuffer ( ) ; rq . ensurecapacityandalignment ( _num , _num ) ; buf . putint ( dispose_surface ) ; buf . putlong ( pdata ) ; rq . flushnow ( ) ; } finally { rq . unlock ( ) ; } }	disposes the native resources associated with the given oglsurfacedata ( referenced by the pdata parameter ).
private void writekanjiresourcefile ( file file ) throws ioexception { fileoutputstream output = null ; kanjiescapeoutputstream kanji = null ; outputstreamwriter writer = null ; bufferedwriter w = null ; try { output = new fileoutputstream ( file ) ; kanji = new kanjiescapeoutputstream ( output ) ; writer = new outputstreamwriter ( kanji ) ; w = new bufferedwriter ( writer ) ; w . write ( _sb . tostring ( ) ) ; } finally { util . close ( w ) ; util . close ( writer ) ; util . close ( kanji ) ; util . close ( output ) ; } }	handle japanese encoding - by toshimm .
public scannerexception ( file file , errormessages message ) { this ( file , errormessages . get ( message ) , message , - _num , - _num ) ; }	creates a new scannerexception for a file with a message only .
void rendernormal ( ) { glenable ( gl_depth_test ) ; gluseprogram ( this . normalprogram ) ; gluniformmatrix4fv ( viewmatrixuniform , _bool , viewmatrix . get ( matrixbuffer ) ) ; gluniformmatrix4fv ( projmatrixuniform , _bool , projmatrix . get ( matrixbuffer ) ) ; gluniformmatrix3fv ( normalmatrixuniform , _bool , normalmatrix . get ( matrixbuffer ) ) ; glbindframebufferext ( gl_framebuffer_ext , fbo ) ; glclear ( gl_color_buffer_bit | gl_depth_buffer_bit ) ; glbindbuffer ( gl_array_buffer , this . cubevbo ) ; glenablevertexattribarray ( _num ) ; glvertexattribpointer ( _num , _num , gl_float , _bool , _num , _num ) ; glenablevertexattribarray ( _num ) ; glvertexattribpointer ( _num , _num , gl_float , _bool , _num , normalsoffset ) ; gldrawarrays ( gl_triangles , _num , numvertices ) ; gldisablevertexattribarray ( _num ) ; gldisablevertexattribarray ( _num ) ; glbindbuffer ( gl_array_buffer , _num ) ; glbindframebufferext ( gl_framebuffer_ext , _num ) ; gluseprogram ( _num ) ; }	render the normals into a texture .
private < t extends cwlresource > list < t > lookforresources ( cwlresourcetype type , class < t > clazz ) { list < t > resources = getrequirements ( type , clazz ) ; if ( resources == null || resources . size ( ) == _num ) { resources = gethints ( type , clazz ) ; } return resources ; }	find all resources by type.
private void calcyvaluesum ( ) { myvaluesum = _num ; for ( int i = _num ; i < myvals . size ( ) ; i ++ ) { entry e = myvals . get ( i ) ; if ( e != null ) myvaluesum += math . abs ( e . getval ( ) ) ; } }	calculates the sum of all y - values.
@ override public boolean release ( int decrement ) { if ( isempty ) { return _bool ; } if ( decrement < _num ) { throw new illegalstateexception ( string . format ( _str , decrement , toverbosestring ( ) ) ) ; } final int refcnt = ledger . decrement ( decrement ) ; if ( baseallocator . debug ) { historicallog . recordevent ( _str , decrement , refcnt + decrement ) ; } if ( refcnt < _num ) { throw new illegalstateexception ( string . format ( _str , id , toverbosestring ( ) ) ) ; } return refcnt == _num ; }	release the provided number of reference counts .
int listsize ( ) { int result = memsize ( ) ; for ( iterator it = iterator ( ) ; it . hasnext ( ) ; ) { astnode child = ( astnode ) it . next ( ) ; result += child . treesize ( ) ; } return result ; }	returns an estimate of the memory footprint in bytes of this node list and all its subtrees .
public connectiontcp findconnectionbythreadid ( long threadid ) { for ( porttcp listener : getports ( ) ) { connectiontcp conn = listener . findconnectionbythreadid ( threadid ) ; if ( conn != null ) return conn ; } return null ; }	finds the tcpconnection given the threadid.
public uniformdistribution estimate ( double min , double max , final int count ) { double grow = ( count > _num ) ? _num * ( max - min ) / ( count - _num ) : _num ; return new uniformdistribution ( math . max ( min - grow , - double . max_value ) , math . min ( max + grow , double . max_value ) ) ; }	estimate from simple characteristics .
public static repositorymetadata readfrom ( streaminput in ) throws ioexception { string name = in . readstring ( ) ; string type = in . readstring ( ) ; settings settings = settings . readsettingsfromstream ( in ) ; return new repositorymetadata ( name , type , settings ) ; }	reads repository metadata from stream input.
public static boolean isprimitivedatatype ( iri datatype ) { return datatype . equals ( xmlschema . duration ) || datatype . equals ( xmlschema . datetime ) || datatype . equals ( xmlschema . time ) || datatype . equals ( xmlschema . date ) || datatype . equals ( xmlschema . gyearmonth ) || datatype . equals ( xmlschema . gyear ) || datatype . equals ( xmlschema . gmonthday ) || datatype . equals ( xmlschema . gday ) || datatype . equals ( xmlschema . gmonth ) || datatype . equals ( xmlschema . string ) || datatype . equals ( xmlschema . boolean ) || datatype . equals ( xmlschema . base64binary ) || datatype . equals ( xmlschema . hexbinary ) || datatype . equals ( xmlschema . float ) || datatype . equals ( xmlschema . decimal ) || datatype . equals ( xmlschema . double ) || datatype . equals ( xmlschema . anyuri ) || datatype . equals ( xmlschema . qname ) || datatype . equals ( xmlschema . notation ) ; }	checks whether the supplied datatype is a primitive xml schema datatype .
protected void appendline ( jcomponent c ) { c . setalignmentx ( _num ) ; contents . add ( c ) ; }	handle gui layout details during construction .
public void postprocess ( ) { if ( foreigncolumnname != null ) { foreignautorefresh = _bool ; } if ( foreignautorefresh && maxforeignautorefreshlevel == databasefield . no_max_foreign_auto_refresh_level_specified ) { maxforeignautorefreshlevel = databasefield . default_max_foreign_auto_refresh_level ; } }	process the settings when we are going to consume them .
public boolean contains ( node s ) { runto ( - _num ) ; if ( null == m_map ) return _bool ; for ( int i = _num ; i < m_firstfree ; i ++ ) { node node = m_map [ i ] ; if ( ( null != node ) && node . equals ( s ) ) return _bool ; } return _bool ; }	tell if the table contains the given node .
private void persistnewtemp ( file filecfg ) { if ( hsdeleteonexit . size ( ) == _num ) { logdebug ( logarea . config , _str ) ; filecfg . delete ( ) ; return ; } logdebug ( logarea . config , _str , hsdeleteonexit . size ( ) , filecfg . getabsolutepath ( ) ) ; bufferedwriter writer = null ; try { writer = new bufferedwriter ( new filewriter ( filecfg ) ) ; for ( file file : hsdeleteonexit ) { if ( ! file . delete ( ) ) { string f = file . getcanonicalpath ( ) ; writer . write ( f ) ; writer . newline ( ) ; logwarn ( logarea . jar , _str , f ) ; } } } catch ( ioexception e ) { } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( ioexception e ) { } } } }	creates file with temporary files list.
public void addwritten ( byte [ ] value ) { writesetlock . lock ( ) ; writeset . add ( new timestampvaluepair ( ets , value ) ) ; writesetlock . unlock ( ) ; }	add a value that shall be written to the writeset.
public void load ( entity unit ) throws illegalargumentexception { if ( ! canload ( unit ) ) { throw new illegalargumentexception ( _str + unit . getshortname ( ) + _str ) ; } currentspace -= _num ; troops . addelement ( unit . getid ( ) ) ; }	load the given unit .
private void processworkerexit ( worker w , boolean completedabruptly ) { if ( completedabruptly ) decrementworkercount ( ) ; final reentrantlock mainlock = this . mainlock ; mainlock . lock ( ) ; try { completedtaskcount += w . completedtasks ; workers . remove ( w ) ; } finally { mainlock . unlock ( ) ; } tryterminate ( ) ; int c = ctl . get ( ) ; if ( runstatelessthan ( c , stop ) ) { if ( ! completedabruptly ) { int min = allowcorethreadtimeout ? _num : corepoolsize ; if ( min == _num && ! workqueue . isempty ( ) ) min = _num ; if ( workercountof ( c ) >= min ) return ; } addworker ( null , _bool ) ; } }	performs cleanup and bookkeeping for a dying worker.
public void finish ( ) throws ioexception { if ( ! def . finished ( ) ) { def . finish ( ) ; while ( ! def . finished ( ) ) { int len = def . deflate ( buf , _num , buf . length ) ; if ( def . finished ( ) && len <= buf . length - trailer_size ) { writetrailer ( buf , len ) ; len = len + trailer_size ; out . write ( buf , _num , len ) ; return ; } if ( len > _num ) out . write ( buf , _num , len ) ; } byte [ ] trailer = new byte [ trailer_size ] ; writetrailer ( trailer , _num ) ; out . write ( trailer ) ; } }	finishes writing compressed data to the output stream without closing the underlying stream.
public boolean free ( t obj ) { atomicinteger topref = _top ; while ( _bool ) { final int top = topref . get ( ) ; if ( _capacity <= top ) { return _bool ; } boolean isfree = _freestack . compareandset ( top , null , obj ) ; topref . compareandset ( top , top + _num ) ; if ( isfree ) { return _bool ; } } }	frees the object . if the free list is full , the object will be garbage collected .
public static boolean hasbinding ( injector injector , key < ? > key ) { binding < ? > binding = getbinding ( injector , key ) ; return binding != null ; }	returns true if a binding exists for the given key.
private openreplicatormanagermbean createinternalservice ( string servicename ) throws replicatorexception { logger . info ( _str + servicename ) ; try { openreplicatormanager orm = new openreplicatormanager ( servicename ) ; orm . setrmihost ( managerrmihost ) ; orm . setrmiport ( managerrmiport ) ; orm . sethosttimezone ( hosttimezone ) ; orm . setreplicatortimezone ( replicatortimezone ) ; orm . advertiseinternal ( ) ; orm . setsecurityinfo ( this . securityinfo ) ; return ( openreplicatormanagermbean ) orm ; } catch ( exception e ) { throw new replicatorexception ( string . format ( _str , servicename ) , e ) ; } }	creates a replication service that will run as a thread internal to the replicationservicemanager .
public static checkindex . status checkindex ( directory dir ) throws ioexception { return checkindex ( dir , _bool ) ; }	this runs the checkindex tool on the index in.
public taggedoutputstream ( outputstream proxy ) { super ( proxy ) ; }	creates a tagging decorator for the given output stream .
public list < mtype > build ( ) { isclean = _bool ; if ( ! ismessageslistmutable && builders == null ) { return messages ; } boolean allmessagesinsync = _bool ; if ( ! ismessageslistmutable ) { for ( int i = _num ; i < messages . size ( ) ; i ++ ) { message message = messages . get ( i ) ; singlefieldbuilder < mtype , btype , itype > builder = builders . get ( i ) ; if ( builder != null ) { if ( builder . build ( ) != message ) { allmessagesinsync = _bool ; break ; } } } if ( allmessagesinsync ) { return messages ; } } ensuremutablemessagelist ( ) ; for ( int i = _num ; i < messages . size ( ) ; i ++ ) { messages . set ( i , getmessage ( i , _bool ) ) ; } messages = collections . unmodifiablelist ( messages ) ; ismessageslistmutable = _bool ; return messages ; }	builds the list of messages from the builder and returns them .
public static void putshort ( long addr , short val ) { if ( unaligned ) unsafe . putshort ( addr , val ) ; else putshortbybyte ( addr , val , big_endian ) ; }	stores given short value.
public static byte [ ] hashtwice ( byte [ ] input , int offset , int length ) { messagedigest digest = newdigest ( ) ; digest . update ( input , offset , length ) ; return digest . digest ( digest . digest ( ) ) ; }	calculates the sha - 256 hash of the given byte range , and then hashes the resulting hash again .
public pronounceablefsm ( url url , boolean scanfromfront ) throws ioexception { this . scanfromfront = scanfromfront ; inputstream is = utilities . getinputstream ( url ) ; loadtext ( is ) ; is . close ( ) ; }	constructs a pronounceablefsm with information in the given url .
public object put ( string key , object value ) { final int len = key . length ( ) ; if ( len > m_charbuffer . length ) { m_charbuffer = new char [ len ] ; } node node = m_root ; for ( int i = _num ; i < len ; i ++ ) { node nextnode = node . m_nextchar [ character . tolowercase ( key . charat ( i ) ) ] ; if ( nextnode != null ) { node = nextnode ; } else { for ( ; i < len ; i ++ ) { node newnode = new node ( ) ; if ( m_lowercaseonly ) { node . m_nextchar [ character . tolowercase ( key . charat ( i ) ) ] = newnode ; } else { node . m_nextchar [ character . touppercase ( key . charat ( i ) ) ] = newnode ; node . m_nextchar [ character . tolowercase ( key . charat ( i ) ) ] = newnode ; } node = newnode ; } break ; } } object ret = node . m_value ; node . m_value = value ; return ret ; }	put an object into the trie for lookup .
@ override public void makeimmutable ( ) { if ( ismutable ) { if ( authnstatements != null ) { int length = authnstatements . size ( ) ; for ( int i = _num ; i < length ; i ++ ) { authnstatement authn = ( authnstatement ) authnstatements . get ( i ) ; authn . makeimmutable ( ) ; } authnstatements = collections . unmodifiablelist ( authnstatements ) ; } if ( authzdecisionstatements != null ) { int length = authzdecisionstatements . size ( ) ; for ( int i = _num ; i < length ; i ++ ) { authzdecisionstatement authz = ( authzdecisionstatement ) authzdecisionstatements . get ( i ) ; authz . makeimmutable ( ) ; } authzdecisionstatements = collections . unmodifiablelist ( authzdecisionstatements ) ; } if ( attributestatements != null ) { int length = attributestatements . size ( ) ; for ( int i = _num ; i < length ; i ++ ) { attributestatement attr = ( attributestatement ) attributestatements . get ( i ) ; attr . makeimmutable ( ) ; } attributestatements = collections . unmodifiablelist ( attributestatements ) ; } if ( statements != null ) { statements = collections . unmodifiablelist ( statements ) ; } if ( conditions != null ) { conditions . makeimmutable ( ) ; } if ( issuer != null ) { issuer . makeimmutable ( ) ; } if ( subject != null ) { subject . makeimmutable ( ) ; } if ( advice != null ) { advice . makeimmutable ( ) ; } ismutable = _bool ; } }	makes the object immutable.
@ override public string findlibrary ( string name ) { string systemname = system . maplibraryname ( name ) ; arraylist < loader > loaders = getloaders ( ) ; for ( int i = _num ; i < loaders . size ( ) ; i ++ ) { loader loader = loaders . get ( i ) ; path path = loader . getpath ( systemname ) ; if ( path != null && path . canread ( ) ) { return path . getnativepath ( ) ; } path = loader . getpath ( _str + systemname ) ; if ( path != null && path . canread ( ) ) { return path . getnativepath ( ) ; } } for ( int i = _num ; i < _nativepath . size ( ) ; i ++ ) { path path = _nativepath . get ( i ) ; if ( path . canread ( ) ) return path . getnativepath ( ) ; } return super . findlibrary ( name ) ; }	returns the full library path for the name .
public void removecomponentlistener ( final componentupdatelistener listener ) { componentlisteners . remove ( listener ) ; }	removes a component listener from this instance .
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return appkey ; case _num : return send_time ; case _num : return load_info ; case _num : return status ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public static boolean isempty ( charsequence text ) { return text == null || text . length ( ) == _num ; }	returns true if the string is null or 0 - length .
protected byte [ ] assertencodedecode ( final igangliametadatamessage decl , final igangliamessage expected ) { if ( expected == null ) throw new illegalargumentexception ( ) ; final xdroutputbuffer xdr = new xdroutputbuffer ( igangliadefaults . buffer_size ) ; final gangliamessageencoder31 messageencoder = new gangliamessageencoder31 ( ) ; final gangliamessagedecoder31 messagedecoder = new gangliamessagedecoder31 ( ) ; if ( expected . ismetricrequest ( ) ) { messageencoder . writerequest ( xdr , ( igangliarequestmessage ) expected ) ; } else if ( expected . ismetricmetadata ( ) ) { messageencoder . writemetadata ( xdr , ( igangliametadatamessage ) expected ) ; } else if ( expected . ismetricvalue ( ) ) { if ( decl == null ) throw new illegalargumentexception ( _str ) ; messageencoder . writemetric ( xdr , decl , ( igangliametricmessage ) expected ) ; } else { throw new assertionerror ( ) ; } final igangliamessage actual = messagedecoder . decode ( xdr . getbuffer ( ) , _num , xdr . getlength ( ) ) ; assertequals ( _str , expected , actual ) ; final byte [ ] actualdata = new byte [ xdr . getlength ( ) ] ; system . arraycopy ( xdr . getbuffer ( ) , _num , actualdata , _num , actualdata . length ) ; return actualdata ; }	verify that we can encode and decode a record .
private boolean isindexable ( string term ) { return ( term . length ( ) < _num ) && ( term . length ( ) > _num ) ; }	checks a term if it can be processed indexed .
private void sendresponse ( string status , string mime , properties header , inputstream data ) { try { if ( status == null ) throw new error ( _str ) ; outputstream out = mysocket . getoutputstream ( ) ; printwriter pw = new printwriter ( out ) ; pw . print ( _str + status + _str ) ; if ( mime != null ) pw . print ( _str + mime + _str ) ; if ( header == null || header . getproperty ( _str ) == null ) pw . print ( _str + gmtfrmt . format ( new date ( ) ) + _str ) ; if ( header != null ) { enumeration e = header . keys ( ) ; while ( e . hasmoreelements ( ) ) { string key = ( string ) e . nextelement ( ) ; string value = header . getproperty ( key ) ; pw . print ( key + _str + value + _str ) ; } } pw . print ( _str ) ; pw . flush ( ) ; if ( data != null ) { byte [ ] buff = new byte [ _num ] ; while ( _bool ) { int read = data . read ( buff , _num , _num ) ; if ( read <= _num ) break ; out . write ( buff , _num , read ) ; } } out . flush ( ) ; out . close ( ) ; if ( data != null ) data . close ( ) ; } catch ( ioexception ioe ) { try { mysocket . close ( ) ; } catch ( throwable t ) { } } }	sends given response to the socket .
public static string decode ( string encoded , amencryption encr ) { if ( checkcaller ( ) ) { try { issecuritypermission isp = new issecuritypermission ( _str , _str ) ; if ( securitymanager != null ) { securitymanager . checkpermission ( isp ) ; } } catch ( securityexception e ) { debug debug = debug . getinstance ( _str ) ; debug . error ( _str + _str , e ) ; return null ; } } if ( encoded == null || encoded . length ( ) == _num ) { return ( null ) ; } byte [ ] encdata = null ; encdata = base64 . decode ( encoded . trim ( ) ) ; if ( encdata == null ) { return null ; } byte [ ] rawdata = encr . decrypt ( encdata ) ; if ( rawdata == null ) { return ( null ) ; } string answer = null ; try { answer = new string ( rawdata , _str ) ; } catch ( unsupportedencodingexception uue ) { debug debug = debug . getinstance ( _str ) ; debug . error ( _str , uue ) ; answer = new string ( rawdata ) ; } return ( answer ) ; }	decode an encoded string.
protected void waitforshutdownsignal ( ) throws interruptedexception { if ( mutexwaiting == null ) mutexwaiting = new object ( ) ; try { synchronized ( mutexwaiting ) { mutexwaiting . wait ( ) ; } } catch ( interruptedexception e ) { if ( ! shutdown ) throw e ; } }	causes the current thread to block until signalshutdown is called.
public void addconnection ( connection connection ) { if ( connection == null ) throw new illegalargumentexception ( _str ) ; synchronized ( connectionslock ) { connection [ ] newconnections = new connection [ connections . length + _num ] ; newconnections [ _num ] = connection ; system . arraycopy ( connections , _num , newconnections , _num , connections . length ) ; connections = newconnections ; } connection . addlistener ( invokelistener ) ; if ( trace ) trace ( _str , _str + connection ) ; }	allows the remote end of the specified connection to access objects registered in this objectspace .
public double distance ( point2d pt ) { final double x_distance = ( pt . getx ( ) - x ) * ( pt . getx ( ) - x ) ; final double y_distance = ( pt . gety ( ) - y ) * ( pt . gety ( ) - y ) ; return math . sqrt ( x_distance + y_distance ) ; }	returns the euclidean distance between a specified point and this point .
private static int converttoint ( string value , int defaultvalue ) { string trim = value . trim ( ) ; if ( trim . length ( ) == _num ) { return defaultvalue ; } return integer . parseint ( trim ) ; }	convert a string to an int treating empty strings as the default value .
public chainiterable < t > additem ( @ notnull t item ) { return ( chainiterable < t > ) super . add ( collections . < t > singleton ( item ) ) ; }	convenience : add an item wrapping it into a singleiterable behind the scenes .
private void updatestateview ( int itcount , collection < individual < double > > gen ) { platform . runlater ( null ) ; simpanectrl . waitafterstep ( ) ; }	caution : while the background thread should be slowed down , updates of the gui have to be done in the gui thread !.
@ override public void run ( ) { try { for ( ; ; ) { int n = portgetn ( port , bufferaddress , max_event_count ) ; assert n > _num ; long address = bufferaddress ; for ( int i = _num ; i < n ; i ++ ) { boolean shutdown = processevent ( address ) ; if ( shutdown ) return ; address += sizeof_port_event ; } } } catch ( unixexception x ) { x . printstacktrace ( ) ; } }	poller main loop . blocks on port_getn waiting for events and then processes them .
@ override public list < string > allkeys ( ) { list < string > namefiles = new arraylist < > ( ) ; file [ ] files = cachedirectory . listfiles ( ) ; if ( files == null ) return namefiles ; for ( file file : files ) { if ( file . isfile ( ) ) { namefiles . add ( file . getname ( ) ) ; } } return namefiles ; }	retrieve the names from all files in dir.
public dialoguerecorder ( dialoguesystem system ) { this . settings = system . getsettings ( ) ; }	creates a new dialogue recorder for the dialogue system.
private string generateuniquefutureid ( ) { return string . valueof ( midcounter . getandincrement ( ) ) ; }	generates unique id for requestfuture .
private static final void reschedulemissedalarms ( contentresolver cr , context context , alarmmanagerinterface manager ) { long now = system . currenttimemillis ( ) ; long ancient = now - dateutils . day_in_millis ; string [ ] projection = new string [ ] { calendarcontract . calendaralerts . alarm_time } ; if ( build . version . sdk_int >= _num && contextcompat . checkselfpermission ( context , manifest . permission . read_calendar ) != packagemanager . permission_granted ) { log . d ( tag , _str ) ; return ; } cursor cursor = cr . query ( calendaralerts . content_uri , projection , where_reschedule_missed_alarms , ( new string [ ] { long . tostring ( now ) , long . tostring ( ancient ) , long . tostring ( now ) } ) , sort_order_alarmtime_asc ) ; if ( cursor == null ) { return ; } if ( debug ) { log . d ( tag , _str + cursor . getcount ( ) ) ; } try { long alarmtime = - _num ; while ( cursor . movetonext ( ) ) { long newalarmtime = cursor . getlong ( _num ) ; if ( alarmtime != newalarmtime ) { if ( debug ) { log . w ( tag , _str + newalarmtime ) ; } alertutils . schedulealarm ( context , manager , newalarmtime ) ; alarmtime = newalarmtime ; } } } finally { cursor . close ( ) ; } }	searches the calendaralerts table for alarms that should have fired but have not and then reschedules them.
public void addname ( string name ) { m_names . add ( name ) ; }	add a column name to this projection .
@ override default completablefuture < optionaldouble > mindouble ( final todoublefunction < ? super t > fn ) { return completablefuture . supplyasync ( null , getexec ( ) ) ; }	perform an asynchronous min operation.
private boolean tostate ( lifecyclestate newstate ) { lifecyclestate state ; synchronized ( this ) { state = _state ; _state = newstate ; _lastchangetime = currenttime . currenttime ( ) ; } if ( _log != null && _log . isloggable ( _lowlevel ) ) { _log . log ( _lowlevel , newstate + _str + _name ) ; } notifylisteners ( state , newstate ) ; return _bool ; }	changes to the next state .
@ override protected string datetostring ( datetimedata date ) { stringbuffer message = new stringbuffer ( _num ) ; message . append ( _str ) ; message . append ( _str ) ; append ( message , date . month , _num ) ; append ( message , ( char ) date . utc , _num ) ; return message . tostring ( ) ; }	converts month object representation to string.
private void addtest ( test newtest ) { if ( m_rulelist == null ) { m_rulelist = new arraylist < test > ( ) ; } m_rulelist . add ( newtest ) ; }	adds the given test to the list.
public void swap ( int i , int j ) { x . asserttrue ( i < list . size ( ) ) ; x . asserttrue ( j < list . size ( ) ) ; list . set ( i , list . set ( j , list . get ( i ) ) ) ; }	swaps in place the elements at the specified positions in the specified list.
private list < namevaluepair > buildiptparameters ( ipt ipt , string organisationkey ) { list < namevaluepair > data = new arraylist < namevaluepair > ( ) ; if ( ipt != null && organisationkey != null ) { data . add ( new basicnamevaluepair ( _str , stringutils . trimtoempty ( organisationkey ) ) ) ; data . add ( new basicnamevaluepair ( _str , stringutils . trimtoempty ( ipt . getname ( ) ) ) ) ; data . add ( new basicnamevaluepair ( _str , stringutils . trimtoempty ( ipt . getdescription ( ) ) ) ) ; data . add ( new basicnamevaluepair ( _str , stringutils . trimtoempty ( ipt . getprimarycontacttype ( ) ) ) ) ; data . add ( new basicnamevaluepair ( _str , stringutils . trimtoempty ( ipt . getprimarycontactname ( ) ) ) ) ; data . add ( new basicnamevaluepair ( _str , stringutils . trimtoempty ( ipt . getprimarycontactemail ( ) ) ) ) ; data . add ( new basicnamevaluepair ( _str , service_type_rss ) ) ; data . add ( new basicnamevaluepair ( _str , getrssfeedurl ( ) ) ) ; } else { log . debug ( _str ) ; } return data ; }	populate a list of name value pairs used in the common ws requests for ipt registrations and updates .
public static < t , u extends closeable > t withcloseable ( u self , @ closureparams ( value = firstparam . class ) closure < t > action ) throws ioexception { try { t result = action . call ( self ) ; closeable temp = self ; self = null ; temp . close ( ) ; return result ; } finally { defaultgroovymethodssupport . closewithwarning ( self ) ; } }	allows this closeable to be used within the closure , ensuring that it is closed once the closure has been executed and before this method returns .
public static boolean ismatch ( string actualstring , linkedlist patterns , char wildcard ) { boolean matched = _bool ; for ( listiterator iter = patterns . listiterator ( _num ) ; iter . hasnext ( ) ; ) { if ( ismatch ( actualstring , ( string ) iter . next ( ) , wildcard ) ) { matched = _bool ; break ; } } return matched ; }	check whether the string matches the pattern .
public synchronized void addserver ( serverlocation location , string [ ] groups , serverload initialload , long loadpollinterval ) { servergroupmap . put ( location , groups ) ; loadholder connectionload = new loadholder ( location , initialload . getconnectionload ( ) , initialload . getloadperconnection ( ) , loadpollinterval ) ; addgroups ( connectionloadmap , groups , connectionload ) ; loadholder queueload = new loadholder ( location , initialload . getsubscriptionconnectionload ( ) , initialload . getloadpersubscriptionconnection ( ) , loadpollinterval ) ; addgroups ( queueloadmap , groups , queueload ) ; updateload ( location , initialload ) ; }	add a new server to the load snapshot .
public void addleaf ( catalogtreeleaf leaf ) { _leaves . add ( leaf ) ; }	append leaf to the end of the leaves list.
private static string stamptostring ( long tstamp , string formatmask ) { stringbuilder sb = new stringbuilder ( _num ) ; formatter fmt = new formatter ( sb , locale . us ) ; int [ ] pieces = new int [ numidx ] ; componenttime . unpackbits ( tstamp , pieces ) ; fmt . format ( formatmask , pieces [ yidx ] , pieces [ midx ] , pieces [ didx ] , pieces [ hidx ] , pieces [ iidx ] , pieces [ sidx ] , pieces [ uidx ] ) ; fmt . close ( ) ; return ( sb . tostring ( ) ) ; }	convenience method for converting component time longs to strings.
public httprequest contentlength ( final string value ) { return contentlength ( integer . parseint ( value ) ) ; }	set the ' content - length ' request header to the given value.
public boolean draw ( canvas canvas ) { update ( ) ; final float centerx = mbounds . centerx ( ) ; final float centery = mbounds . height ( ) - mradius ; canvas . scale ( _num , math . min ( mglowscaley , _num ) * mbaseglowscale , centerx , _num ) ; final float displacement = math . max ( _num , math . min ( mdisplacement , _num ) ) - _num ; float translatex = mbounds . width ( ) * displacement / _num ; mpaint . setalpha ( ( int ) ( _num * mglowalpha ) ) ; canvas . drawcircle ( centerx + translatex , centery , mradius , mpaint ) ; boolean onelastframe = _bool ; if ( mstate == state_recede && mglowscaley == _num ) { mstate = state_idle ; onelastframe = _bool ; } return mstate != state_idle || onelastframe ; }	draw into the provided canvas.
public vnxecommandjob modifylunasync ( lunmodifyparam param , string resourceid ) { stringbuilder urlbld = new stringbuilder ( url_resource ) ; urlbld . append ( resourceid ) ; urlbld . append ( url_lun_modify_action ) ; _url = urlbld . tostring ( ) ; return postrequestasync ( param ) ; }	modify lun ( export / unexport / expand etc ) in async mode.
public string replace ( charsequence target , charsequence replacement ) { if ( target == null ) { throw new nullpointerexception ( _str ) ; } if ( replacement == null ) { throw new nullpointerexception ( _str ) ; } string ts = target . tostring ( ) ; int index = indexof ( ts , _num ) ; if ( index == - _num ) return this ; string rs = replacement . tostring ( ) ; stringbuilder buffer = new stringbuilder ( count ) ; int tl = target . length ( ) ; int tail = _num ; do { buffer . append ( value , offset + tail , index - tail ) ; buffer . append ( rs ) ; tail = index + tl ; } while ( ( index = indexof ( ts , tail ) ) != - _num ) ; buffer . append ( value , offset + tail , count - tail ) ; return buffer . tostring ( ) ; }	copies this string replacing occurrences of the specified target sequence with another sequence.
public void delete ( ) throws ioexception { close ( ) ; deletecontents ( directory ) ; }	closes the cache and deletes all of its stored values.
public boolean similarto ( object o ) { if ( o == null ) { return _bool ; } if ( ! ( o instanceof semanticconcept ) ) { return _bool ; } semanticconcept otherconcept = ( semanticconcept ) o ; hashset < integer > synset_intersection = new hashset < integer > ( this . synsets ) ; synset_intersection . retainall ( otherconcept . synsets ) ; if ( ! synset_intersection . isempty ( ) ) { return _bool ; } hashset < string > concept_intersection = new hashset < string > ( this . concepts ) ; concept_intersection . retainall ( otherconcept . concepts ) ; return ! concept_intersection . isempty ( ) ; }	semanticconcepts are similar if they share a synset or a concept.
public void jgoogleanalyticstracker ( final string eventtype , final string version , final string trackerid ) { final jgoogleanalyticstracker tracker = new jgoogleanalyticstracker ( _str , version , trackerid ) ; final focuspoint focuspoint = new focuspoint ( eventtype . tolowercase ( ) ) ; tracker . trackasynchronously ( focuspoint ) ; }	google analytics usage tracking.
protected final tuple addinternal ( tuple t ) { if ( m_tuples . add ( t ) ) { return t ; } else { return null ; } }	adds a tuple without firing a notification .
public void put ( song song ) { if ( ! msongs . contains ( song ) ) { msongs . add ( song ) ; } }	adds a song to the adapter.
@ notnull public psiquery childrennamed ( @ notnull final class < ? extends psinamedelement > clazz , @ notnull final string name ) { final list < psielement > result = new arraylist < psielement > ( ) ; for ( final psielement element : mypsielements ) { for ( final psinamedelement child : psitreeutil . findchildrenoftype ( element , clazz ) ) { if ( name . equals ( child . getname ( ) ) ) { result . add ( child ) ; } } } return new psiquery ( result . toarray ( new psielement [ result . size ( ) ] ) ) ; }	filter children by name and class.
private void emitmapput ( method method , string fieldname , stringbuilder builder ) { builder . append ( _str ) ; builder . append ( getmapputtername ( fieldname ) ) ; builder . append ( _str ) ; builder . append ( gettypeargumentimplname ( ( parameterizedtype ) method . getgenericreturntype ( ) , _num ) ) ; builder . append ( _str ) ; builder . append ( getensurename ( fieldname ) ) ; builder . append ( _str ) ; builder . append ( fieldname ) ; builder . append ( _str ) ; builder . append ( _str ) ; }	emits a put method to put a value into a map.
@ override public boolean equals ( object o ) { return o . hashcode ( ) == hashcode ( ) ; }	returns true if the object is a complex effect with an identical content.
@ override public string tostring ( ) { if ( getuserobject ( ) instanceof tvshow ) { tvshow tvshow = ( tvshow ) getuserobject ( ) ; return tvshow . gettitle ( ) ; } return super . tostring ( ) ; }	provides the right name of the node for display .
private arraylist < string > parsejson ( string text ) { text = text . substring ( text . indexof ( _str ) + size_of_events , text . indexof ( _str ) ) ; arraylist < string > events = new arraylist < string > ( ) ; if ( text . isempty ( ) ) { return events ; } int startindex = _num , endindex = _num ; while ( endindex != - _num ) { endindex = text . indexof ( _str , startindex + delimiter_size ) ; string eventtext = ( endindex == - _num ? text . substring ( startindex ) : text . substring ( startindex , endindex ) ) ; pattern pattern = pattern . compile ( _str ) ; matcher matcher = pattern . matcher ( eventtext ) ; eventtext = matcher . replaceall ( _str ) ; pattern = pattern . compile ( _str ) ; matcher = pattern . matcher ( eventtext ) ; if ( matcher . find ( ) ) { eventtext = matcher . replacefirst ( matcher . group ( _num ) + _str ) ; } eventtext = _str + eventtext ; startindex = endindex + _num ; events . add ( eventtext ) ; } collections . reverse ( events ) ; return events ; }	parse json - formatted list of events / births / deaths from wikipedia , extract list of events and split the events into a string array of individual events.
@ override public void removetablemodellistener ( tablemodellistener l ) { m_listeners . remove ( l ) ; }	removes a listener from the list that is notified each time a change to the data model occurs.
public strbuilder replace ( int startindex , int endindex , string replacestr ) { endindex = validaterange ( startindex , endindex ) ; int insertlen = ( replacestr == null ? _num : replacestr . length ( ) ) ; replaceimpl ( startindex , endindex , endindex - startindex , replacestr , insertlen ) ; return this ; }	replaces a portion of the string builder with another string.
public static void addpermissionrecursive ( path path , posixfilepermission permission ) throws ioexception { changepermissionsrecursive ( path , permissionchange . add , collections . singleton ( permission ) ) ; }	recursively adds a permission to a directory .
private void runtimeouttask ( ) { while ( isactive ( ) ) { reaptimeouts ( ) ; try { thread . sleep ( _timeoutreapinterval ) ; } catch ( exception e ) { } } }	running process accepting connections .
public idevice learnentity ( long macaddress , short vlan , integer ipv4address , long switchdpid , integer switchport , boolean processupdates ) { list < idevicelistener > listeners = devicelisteners . getorderedlisteners ( ) ; if ( ! processupdates ) { devicelisteners . clearlisteners ( ) ; } vlanvid v ; ipv4address i ; datapathid d ; ofport p ; if ( vlan != null && vlan . shortvalue ( ) <= _num ) vlan = null ; if ( ipv4address != null && ipv4address == _num ) ipv4address = null ; if ( vlan == null ) { v = vlanvid . ofvlan ( - _num ) ; } else { v = vlanvid . ofvlan ( vlan ) ; } if ( ipv4address == null ) { i = ipv4address . none ; } else { i = ipv4address . of ( ipv4address ) ; } if ( switchdpid == null ) { d = datapathid . of ( _num ) ; } else { d = datapathid . of ( switchdpid . longvalue ( ) ) ; } if ( switchport == null ) { p = ofport . zero ; } else { p = ofport . of ( switchport ) ; } idevice res = learndevicebyentity ( new entity ( macaddress . of ( macaddress ) , v , i , d , p , new date ( ) ) ) ; if ( listeners != null ) { for ( idevicelistener listener : listeners ) { devicelisteners . addlistener ( _str , listener ) ; } } return res ; }	learn a device using the given characteristics .
public static boolean isvalidtypesignature ( string sig , boolean allowvoid ) { int len = sig . length ( ) ; return checktypesignature ( sig , _num , len , allowvoid ) == len ; }	returns true if the given type signature is valid , false if it is not .
public void testcase19 ( ) { byte abytes [ ] = { - _num , _num , _num , _num , _num , - _num , _num , - _num , _num , _num } ; byte bbytes [ ] = { _num , - _num , _num , _num , _num } ; int asign = _num ; int bsign = - _num ; byte rbytes [ ] = { _num , - _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . remainder ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	remainder of division of two numbers of different signs.
public static boolean hasvisiblechildren ( actiongroup group , presentationfactory factory , actionmanager actionmanager , perspectivemanager perspectivemanager ) { actionevent event = new actionevent ( factory . getpresentation ( group ) , actionmanager , perspectivemanager ) ; for ( action anaction : group . getchildren ( event ) ) { if ( anaction == null ) { log . error ( utils . class , _str + group + _str + factory . getpresentation ( group ) ) ; continue ; } if ( anaction instanceof separator ) { continue ; } final presentation presentation = factory . getpresentation ( anaction ) ; anaction . update ( new actionevent ( presentation , actionmanager , perspectivemanager ) ) ; if ( anaction instanceof actiongroup ) { actiongroup childgroup = ( actiongroup ) anaction ; if ( childgroup . ispopup ( ) ) { if ( ! presentation . isvisible ( ) ) { continue ; } } if ( hasvisiblechildren ( childgroup , factory , actionmanager , perspectivemanager ) ) { return _bool ; } } else if ( presentation . isvisible ( ) ) { return _bool ; } } return _bool ; }	returns true if action group has visible children .
private static void checkargreferences ( string typesnippet , int numberofargs ) { matcher argrefmatcher = arg_ref_pattern . matcher ( typesnippet ) ; while ( argrefmatcher . find ( ) ) { int index = integer . parseint ( argrefmatcher . group ( _num ) , _num ) - _num ; preconditions . checkargument ( index >= _num , _str , argrefmatcher . group ( _num ) ) ; preconditions . checkargument ( index < numberofargs , _str , argrefmatcher . group ( _num ) ) ; } }	check that all % d references in the given type snippet are within bounds .
public void randomize ( ) { randomizeincomingweights ( ) ; normalizeincomingweights ( ) ; }	randomize and normalize weights .
public static void saveasimage ( int x , int y , int width , int height , string path , compressformat compressformat , int quality ) throws filenotfoundexception { bitmap bmp = getpixelsfrombuffer ( x , y , width , height ) ; try { file file = new file ( path ) ; try { file . createnewfile ( ) ; } catch ( ioexception e1 ) { e1 . printstacktrace ( ) ; } fileoutputstream fos = new fileoutputstream ( file ) ; bmp . compress ( compressformat , quality , fos ) ; try { fos . flush ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } try { fos . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } catch ( filenotfoundexception e ) { throw ( e ) ; } }	saves the pixels from the buffer on the sd card .
private boolean isfilevalid ( file file , string methodname ) { if ( file == null ) { log . printconcatline ( name , _str , methodname , _str ) ; return _bool ; } string filename = file . getname ( ) ; if ( filename == null || filename . length ( ) == _num ) { log . printconcatline ( name , _str + methodname , _str ) ; return _bool ; } return _bool ; }	check if the file is valid or not.
public void removesrcclass ( sootclass clz ) { srcclasses . remove ( clz . getname ( ) ) ; }	remove a class from the list of src classes .
private void updaterange ( double value ) { mminvalue = math . min ( mminvalue , value ) ; mmaxvalue = math . max ( mmaxvalue , value ) ; }	updates the values range .
jsonstringer close ( scope empty , scope nonempty , string closebracket ) throws jsonexception { scope context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new jsonexception ( _str ) ; } stack . remove ( stack . size ( ) - _num ) ; if ( context == nonempty ) { newline ( ) ; } out . append ( closebracket ) ; return this ; }	closes the current scope by appending any necessary whitespace and the given bracket .
public void append ( byte [ ] bytes ) { append ( bytes , _num , bytes . length ) ; }	append specified bytes to the buffer.
public static boolean enoughspaceonphone ( long updatesize ) { return getrealsizeonphone ( ) > updatesize ; }	checks if there is enough space on phone self.
public void cancelbuttonactionperformed ( ) { editmode = _bool ; curnode = null ; addbutton . setvisible ( _bool ) ; editbutton . setvisible ( _bool ) ; deletebutton . setvisible ( _bool ) ; donebutton . setvisible ( _bool ) ; updatebutton . setvisible ( _bool ) ; cancelbutton . setvisible ( _bool ) ; nodeaddrfield . setvisible ( _bool ) ; nodeaddrstatic . setvisible ( _bool ) ; statustext1 . settext ( stdstatus1 ) ; statustext2 . settext ( stdstatus2 ) ; statustext3 . settext ( stdstatus3 ) ; }	method to handle cancel button.
public void addattribute ( attributedcharacteriterator . attribute attribute , object value ) { if ( attribute == null ) { throw new nullpointerexception ( _str ) ; } if ( text . isempty ( ) ) { throw new illegalargumentexception ( _str ) ; } list < range > ranges = attributemap . get ( attribute ) ; if ( ranges == null ) { ranges = new arraylist < range > ( _num ) ; attributemap . put ( attribute , ranges ) ; } else { ranges . clear ( ) ; } ranges . add ( new range ( _num , text . length ( ) , value ) ) ; }	applies a given attribute to this string .
private object stringtovalue ( object oldvalue , string newvalue ) throws replicatorexception { if ( oldvalue instanceof string ) { return newvalue ; } else if ( oldvalue instanceof integer ) { return integer . valueof ( newvalue ) ; } else if ( oldvalue instanceof serialblob ) { try { return databasehelper . getsafeblob ( newvalue . getbytes ( ) ) ; } catch ( sqlexception e ) { throw new replicatorexception ( _str + e , e ) ; } } else { return newvalue ; } }	converts string back to correct ( previous ) data type .
public string tozstring ( ) { stringbuilder buffer = new stringbuilder ( _num ) ; try { printz ( buffer ) ; } catch ( ioexception e ) { throw new runtimeexception ( _str , e ) ; } return buffer . tostring ( ) ; }	returns the string representation ( in ion format ) of this timestamp in utc .
public void recordstate ( dialoguestate state , string name ) { states . put ( name , state ) ; if ( ! listmodel . contains ( name ) ) { int position = name . contains ( current ) ? _num : math . min ( _num , listmodel . size ( ) ) ; listmodel . add ( position , name ) ; } }	records a dialogue state in the component and makes it available for display in the network selection list on the left side.
public int writeutf8 ( final charsequence chars , int off , int len ) { if ( len > remaining ( ) ) { return writeutf8slow ( chars , off , len ) ; } final block block = current ; int limit = block . limit ; char ch = _str ; int octets = _num ; while ( len > _num ) { ch = chars . charat ( off ) ; if ( ch >= utf8_2_octet_min_value ) { break ; } block . data [ limit ++ ] = ( byte ) ch ; octets ++ ; off ++ ; len -- ; } block . limit = limit ; if ( len > _num ) { if ( ch < utf8_3_octet_min_value ) { return octets + writeutf8upto2byte ( chars , off , len ) ; } if ( ch >= low_surrogate_first && ch <= low_surrogate_last ) { throw new illegalargumentexception ( _str + ch ) ; } if ( ch >= high_surrogate_first && ch <= high_surrogate_last ) { return octets + writeutf8slow ( chars , off , len ) ; } return octets + writeutf8upto3byte ( chars , off , len ) ; } return octets ; }	returns the number of octets written .
public geoserverwpsclient ( geoserverconnection connection ) { this . connection = connection ; }	instantiates a new geo server wps client .
static boolean verifyzipfile ( file file ) { try { zipfile zipfile = new zipfile ( file ) ; try { zipfile . close ( ) ; return _bool ; } catch ( ioexception e ) { log . w ( tag , _str + file . getabsolutepath ( ) ) ; } } catch ( zipexception ex ) { log . w ( tag , _str + file . getabsolutepath ( ) + _str , ex ) ; } catch ( ioexception ex ) { log . w ( tag , _str + file . getabsolutepath ( ) , ex ) ; } return _bool ; }	returns whether the file is a valid zip file .
long cleanup ( long now ) { int inuseconnectioncount = _num ; int idleconnectioncount = _num ; realconnection longestidleconnection = null ; long longestidledurationns = long . min_value ; synchronized ( this ) { for ( iterator < realconnection > i = connections . iterator ( ) ; i . hasnext ( ) ; ) { realconnection connection = i . next ( ) ; if ( pruneandgetallocationcount ( connection , now ) > _num ) { inuseconnectioncount ++ ; continue ; } idleconnectioncount ++ ; long idledurationns = now - connection . idleatnanos ; if ( idledurationns > longestidledurationns ) { longestidledurationns = idledurationns ; longestidleconnection = connection ; } } if ( longestidledurationns >= this . keepalivedurationns || idleconnectioncount > this . maxidleconnections ) { connections . remove ( longestidleconnection ) ; } else if ( idleconnectioncount > _num ) { return keepalivedurationns - longestidledurationns ; } else if ( inuseconnectioncount > _num ) { return keepalivedurationns ; } else { cleanuprunning = _bool ; return - _num ; } } closequietly ( longestidleconnection . socket ( ) ) ; return _num ; }	performs maintenance on this pool , evicting the connection that has been idle the longest if either it has exceeded the keep alive limit or the idle connections limit.
public stateinfo ( ) { }	creates a new stateinfo .
public boolean compare ( object expected , object current ) { if ( current != null ) { equal = current . equals ( expected ) ; } else if ( expected != null ) { equal = expected . equals ( _num ) ; } return equal ; }	this is used to compare the expected and current versions of the class.
private static byte [ ] generateseed ( ) { try { bytearrayoutputstream seedbuffer = new bytearrayoutputstream ( ) ; dataoutputstream seedbufferout = new dataoutputstream ( seedbuffer ) ; seedbufferout . writelong ( system . currenttimemillis ( ) ) ; seedbufferout . writelong ( system . nanotime ( ) ) ; seedbufferout . writeint ( process . mypid ( ) ) ; seedbufferout . writeint ( process . myuid ( ) ) ; seedbufferout . write ( build_fingerprint_and_device_serial ) ; seedbufferout . close ( ) ; return seedbuffer . tobytearray ( ) ; } catch ( ioexception e ) { throw new securityexception ( _str , e ) ; } }	generates a device - and invocation - specific seed to be mixed into the linux prng .
boolean needtocheckexclude ( ) { return _bool ; }	return whether we need to check namespace prefixes against and exclude result prefixes list .
public static byte [ ] decode ( string hexa ) throws coderexception { if ( hexa == null ) { throw new coderexception ( _str ) ; } if ( ( hexa . length ( ) % _num ) != _num ) { throw new coderexception ( _str ) ; } int tamarray = hexa . length ( ) / _num ; byte [ ] retorno = new byte [ tamarray ] ; for ( int i = _num ; i < tamarray ; i ++ ) { retorno [ i ] = hextobyte ( hexa . substring ( i * _num , i * _num + _num ) ) ; } return retorno ; }	decodes back a string to a byte array.
private list < usernamespaceauthorization > createusernamespaceauthorizationsfromentities ( list < usernamespaceauthorizationentity > usernamespaceauthorizationentities ) { list < usernamespaceauthorization > usernamespaceauthorizations = new arraylist < > ( ) ; for ( usernamespaceauthorizationentity usernamespaceauthorizationentity : usernamespaceauthorizationentities ) { usernamespaceauthorizations . add ( createusernamespaceauthorizationfromentity ( usernamespaceauthorizationentity ) ) ; } return usernamespaceauthorizations ; }	creates a list of user namespace authorizations from the list of persisted entities .
private void readheader ( ) throws openstegoexception { this . dataheader = new dctdataheader ( this , this . config ) ; }	method to read header data from the input stream.
protected void drawtext ( string text1 , string text2 , int x , int y , canvas c ) { if ( textpaint == null ) { paint p = new paint ( ) ; p . settypeface ( robotolighttypeface . getinstance ( context ) ) ; p . setcolor ( textcolor ) ; p . settextsize ( _num * pixeldensity ) ; this . textpaint = p ; } float w = textpaint . measuretext ( text1 , _num , text1 . length ( ) ) ; int offset = ( int ) w / _num ; c . drawtext ( text1 , x - offset , y + ( _num * pixeldensity ) , textpaint ) ; w = textpaint . measuretext ( text2 , _num , text2 . length ( ) ) ; offset = ( int ) w / _num ; c . drawtext ( text2 , x - offset , y + ( _num * pixeldensity ) , textpaint ) ; }	draw the text under the graphics.
public boolean islessthenorequalto ( percent percent ) { assertdefined ( ) ; bigdecimal thisvalue = notnull ( this ) ; bigdecimal parameter = notnull ( percent ) ; return ( thisvalue . compareto ( parameter ) <= _num ) ; }	compares two percent objects .
public object clone ( ) throws clonenotsupportedexception { predicatednodetest clone = ( predicatednodetest ) super . clone ( ) ; if ( ( null != this . m_proximitypositions ) && ( this . m_proximitypositions == clone . m_proximitypositions ) ) { clone . m_proximitypositions = new int [ this . m_proximitypositions . length ] ; system . arraycopy ( this . m_proximitypositions , _num , clone . m_proximitypositions , _num , this . m_proximitypositions . length ) ; } if ( clone . m_lpi == this ) clone . m_lpi = ( locpathiterator ) clone ; return clone ; }	get a cloned prdicatednodetest .
public static boolean pointoutsideprefsize ( jtable table , int row , int column , point p ) { if ( table . convertcolumnindextomodel ( column ) != _num || row == - _num ) { return _bool ; } tablecellrenderer tcr = table . getcellrenderer ( row , column ) ; object value = table . getvalueat ( row , column ) ; component cell = tcr . gettablecellrenderercomponent ( table , value , _bool , _bool , row , column ) ; dimension itemsize = cell . getpreferredsize ( ) ; rectangle cellbounds = table . getcellrect ( row , column , _bool ) ; cellbounds . width = itemsize . width ; cellbounds . height = itemsize . height ; assert ( p . x >= cellbounds . x && p . y >= cellbounds . y ) ; return p . x > cellbounds . x + cellbounds . width || p . y > cellbounds . y + cellbounds . height ; }	returns true if the given point is outside the preferredsize of the item at the given row of the table.
public builder addsourcefolder ( @ nonnull file folder ) { folderstoscan . add ( folder ) ; return this ; }	root folder for labels - > documents . each subfolder name will be presented as label , and contents of this folder will be represented as labelleddocument , with label attached.
public method suspendsrdfgroupmethod ( final uri systemuri , final remotedirectorgroup group , final list < uri > sourcevolumes , final list < uri > targetvolumes ) { return new workflow . method ( suspend_srdf_group_method , systemuri , group , sourcevolumes , targetvolumes ) ; }	returns a workflow . method for suspending srdf group.
@ override public double calculatem ( double delta , double epsilon ) { double i = _num ; while ( conf ( i , delta ) > epsilon / _num ) { i = i + _num ; } if ( i > _num ) { i = i - _num ; } while ( conf ( i , delta ) > ( epsilon / _num ) ) { i ++ ; } return math . ceil ( i ) ; }	calculates the m - value needed for the gss algorithm .
public static serversocket createserversocket ( int port , inetaddress bindaddress ) throws ioexception { serversocket socket = null ; if ( sysproperties . enable_anonymous_tls ) { removeanonfromlegacyalgorithms ( ) ; } setkeystore ( ) ; serversocketfactory f = sslserversocketfactory . getdefault ( ) ; sslserversocket securesocket ; if ( bindaddress == null ) { securesocket = ( sslserversocket ) f . createserversocket ( port ) ; } else { securesocket = ( sslserversocket ) f . createserversocket ( port , _num , bindaddress ) ; } securesocket . setenabledprotocols ( disablessl ( securesocket . getenabledprotocols ( ) ) ) ; if ( sysproperties . enable_anonymous_tls ) { string [ ] list = enableanonymous ( securesocket . getenabledciphersuites ( ) , securesocket . getsupportedciphersuites ( ) ) ; securesocket . setenabledciphersuites ( list ) ; } socket = securesocket ; return socket ; }	create a secure server socket.
public void printbytes ( byte [ ] data , int offset , int length ) throws ioexception { int i ; for ( ; length >= _num ; length -= _num ) { int chunk = ( ( ( data [ offset ] & _num ) << _num ) + ( ( data [ offset + _num ] & _num ) << _num ) + ( data [ offset + _num ] & _num ) ) ; os . write ( base64encode ( chunk > > _num ) ) ; os . write ( base64encode ( chunk > > _num ) ) ; os . write ( base64encode ( chunk > > _num ) ) ; os . write ( base64encode ( chunk ) ) ; offset += _num ; } if ( length == _num ) { int chunk = ( ( data [ offset ] & _num ) << _num ) + ( data [ offset + _num ] & _num ) ; os . write ( base64encode ( chunk > > _num ) ) ; os . write ( base64encode ( chunk > > _num ) ) ; os . write ( base64encode ( chunk ) ) ; os . write ( _str ) ; } else if ( length == _num ) { int chunk = data [ offset ] & _num ; os . write ( base64encode ( chunk > > _num ) ) ; os . write ( base64encode ( chunk ) ) ; os . write ( _str ) ; os . write ( _str ) ; } }	prints a byte array to the stream , properly encoded in base64 .
public void deletevvset ( string nativeid ) throws exception { _log . info ( _str ) ; clientresponse clientresp = null ; final string path = messageformat . format ( uri_delete_cg , nativeid ) ; _log . info ( _str + path ) ; try { clientresp = delete ( path ) ; if ( clientresp == null ) { _log . error ( _str ) ; throw new hp3parexception ( _str ) ; } else if ( clientresp . getstatus ( ) != _num ) { string errresp = getresponsedetails ( clientresp ) ; throw new hp3parexception ( errresp ) ; } else { _log . info ( _str ) ; } } catch ( exception e ) { throw e ; } finally { if ( clientresp != null ) { clientresp . close ( ) ; } _log . info ( _str ) ; } }	delete a vv set or consistency group.
private int findkeycommentindex ( string keyname ) { for ( int i = _num ; i < keyvalcomments . size ( ) ; i ++ ) { string t = keyvalcomments . get ( i ) ; string targetedkey = _str + keyname + _str ; if ( t . startswith ( targetedkey ) ) { return i ; } } if ( log . isdebugenabled ( ) ) { log . debug ( _str + keyname ) ; } return - _num ; }	finds the index of the specified key within the array containing key / value comments.
public boolean isexpired ( ) { return ( cookieexpirydate != null && cookieexpirydate . gettime ( ) <= system . currenttimemillis ( ) ) ; }	returns true if this cookie has expired .
public static boolean isaddtohomeintentsupported ( context context ) { packagemanager pm = context . getpackagemanager ( ) ; intent i = new intent ( install_shortcut ) ; list < resolveinfo > receivers = pm . querybroadcastreceivers ( i , packagemanager . get_intent_filters ) ; return ! receivers . isempty ( ) ; }	utility method to check if a shortcut can be added to the home screen .
inmemoryentrystore ( ) { entries = maps . newhashmap ( ) ; toplevelentries = sets . newhashset ( ) ; children = hashmultimap . create ( ) ; }	creates a new inmemoryentrystore which provides constant time storage and retrieval of entries by id or parent id .
public classannotator ( url [ ] codebase , properties props ) { if ( props != null ) properties . putall ( props ) ; setannotationurls ( codebase ) ; }	constructs a new classannotator for the specified codebase urls.
public int next ( ) { return mix ( gen . getandincrement ( ) ) ; }	produce the next identifier .
public inputstream put ( final urlconnection connection , final boolean flushcacheonclose ) { final string key = getkey ( connection ) ; if ( key == null ) return null ; if ( ! iscacheable ( ( httpurlconnection ) connection ) ) try { cache . remove ( key ) ; return null ; } catch ( ioexception e ) { return null ; } string etag = connection . getheaderfield ( header_etag ) ; if ( etag == null || etag . length ( ) == _num ) return null ; editor editor ; try { editor = cache . edit ( key ) ; } catch ( ioexception e ) { return null ; } if ( editor == null ) return null ; try { editor . set ( etag , etag ) ; } catch ( ioexception e ) { try { editor . abort ( ) ; } catch ( ioexception ignored ) { } return null ; } inputstream input ; try { input = connection . getinputstream ( ) ; if ( ! ( input instanceof inflaterinputstream ) && encoding_gzip . equals ( connection . getheaderfield ( header_content_encoding ) ) ) input = new gzipinputstream ( input ) ; } catch ( ioexception e ) { return null ; } outputstream output ; try { output = editor . newoutputstream ( body ) ; } catch ( ioexception e ) { return null ; } if ( output != null ) return new cachestream ( input , output , editor , this , flushcacheonclose ) ; else return null ; }	create stream that will be cached after it is read.
public static string [ ] parsetitle ( string title ) { string v [ ] = { _str , _str } ; if ( title == null ) return v ; pattern p = pattern . compile ( _str , pattern . case_insensitive ) ; matcher m = p . matcher ( title ) ; if ( m . find ( ) ) { v [ _num ] = m . group ( _num ) ; v [ _num ] = m . group ( _num ) ; } else { v [ _num ] = title ; } return v ; }	return a 2 element array . 0 = title ; 1 = date parses the title in the format title year or title ( year ).
public string sel ( ) { return mselection . tostring ( ) ; }	returns the selection produced by this object .
public double calculateexcitatoryratio ( ) { excitatoryratio = exsynapseset . size ( ) / ( double ) size ( ) ; if ( double . isnan ( excitatoryratio ) ) { return _num ; } return excitatoryratio ; }	if a randomize operation changes the ratio of excitatory to inhibitory synapses , this method can be called to change the excitatoryratio to reflect this value.
public void rootremoved ( isvnrepositorylocation root ) { iterator it = listeners . iterator ( ) ; while ( it . hasnext ( ) ) { irepositorylistener listener = ( irepositorylistener ) it . next ( ) ; listener . repositoryremoved ( root ) ; } }	a repository root has been removed .
public synchronized void insert ( double _priority , object _data ) { numelements ++ ; if ( numelements == queue . length ) { priorityqueuenode [ ] tmp = new priorityqueuenode [ ( int ) ( queue . length * _num ) ] ; system . arraycopy ( queue , _num , tmp , _num , queue . length ) ; for ( int i = queue . length ; i < tmp . length ; i ++ ) { tmp [ i ] = new priorityqueuenode ( ) ; } queue = tmp ; } queue [ numelements ] . data = _data ; queue [ numelements ] . priority = _priority ; reheapify ( numelements ) ; }	insert the object passed with the priority value passed.
protected message ( ) { }	creates a new message with no specified message type .
protected string wraplinuxcommand ( string command ) throws ioexception , interruptedexception { string setgroup = _str + getgid ( ) + _str + getgid ( ) + _str + getgid ( ) + _str ; string setuser = _str + getuid ( ) + _str + getuid ( ) + _str + getgid ( ) + _str ; string chowncommand = _str ; return setgroup + _str + setuser + _str + chowncommand + _str + command + _str + chowncommand ; }	wrap the given command into a command with chown . also add group / user that match host environment if not exists.
public abstractdmlquery parsesqlquery ( sqlquery sqlquery , ispaceproxy space ) throws sqlexception { abstractdmlquery query = ( abstractdmlquery ) getqueryfromcache ( getuniquekey ( sqlquery ) ) ; try { if ( query == null ) { if ( _logger . isloggable ( level . fine ) ) { _logger . fine ( _str ) ; } sqlparser parser = initparser ( sqlquery . getquery ( ) ) ; query = parse ( parser ) ; query . settablename ( sqlquery . gettypename ( ) ) ; query . validatequery ( space ) ; if ( ! query . isprepared ( ) && ! query . containssubqueries ( ) ) query . build ( ) ; addquerytocache ( getuniquekey ( sqlquery ) , query ) ; if ( ! query . isprepared ( ) ) return query ; } query = query . clone ( ) ; return query ; } catch ( sqlexception sqlex ) { if ( _logger . isloggable ( level . fine ) ) { _logger . log ( level . fine , _str + sqlquery . getquery ( ) + _str , sqlex ) ; } throw sqlex ; } catch ( throwable t ) { if ( _logger . isloggable ( level . fine ) ) { _logger . log ( level . fine , _str + sqlquery . getquery ( ) + _str , t ) ; } sqlexception sqlex = new sqlexception ( _str + sqlquery . getquery ( ) + _str + t , _str , - _num ) ; sqlex . initcause ( t ) ; throw sqlex ; } }	the main method to handle the query.
private int indexofelementinlevel ( int element , int level [ ] ) throws exception { for ( int i = _num ; i < level . length ; i ++ ) { if ( level [ i ] == element ) { return i ; } } throw new exception ( _str + m_nodes . get ( element ) . id + _str + _str ) ; }	returns the index of an element in a level.
public int size ( ) { return _attrs . size ( ) ; }	get the number of attributes in the attribute set.
public string consumetagname ( ) { int start = pos ; while ( ! isempty ( ) && ( matchesword ( ) || matchesany ( _str , _str , _str ) ) ) pos ++ ; return queue . substring ( start , pos ) ; }	consume an tag name off the queue ( word or : , _ , - ).
public void deepsort ( int [ ] setfeaturesequence ) { featuresequence = setfeaturesequence ; numberofleaves = _num ; tree = new marynode ( _num , featurevectors . length ) ; sortnode ( _num , tree ) ; }	launches a deep sort on the array of feature vectors.
public void removelisteners ( ) { listeners . clear ( ) ; }	remove all existing listeners .
public string decrypt ( string sciphertext ) { int nlen = ( sciphertext . length ( ) > > _num ) & ~ _num ; if ( nlen < blowfishecb . blocksize ) return null ; byte [ ] cbciv = new byte [ blowfishecb . blocksize ] ; int nnumofbytes = binconverter . binhextobytes ( sciphertext , cbciv , _num , _num , blowfishecb . blocksize ) ; if ( nnumofbytes < blowfishecb . blocksize ) return null ; m_bfish . setcbciv ( cbciv ) ; nlen -= blowfishecb . blocksize ; if ( nlen == _num ) return _str ; byte [ ] buf = new byte [ nlen ] ; nnumofbytes = binconverter . binhextobytes ( sciphertext , buf , blowfishecb . blocksize * _num , _num , nlen ) ; if ( nnumofbytes < nlen ) return null ; m_bfish . decrypt ( buf ) ; int npadbyte = buf [ buf . length - _num ] & _num ; if ( ( npadbyte > _num ) || ( npadbyte < _num ) ) npadbyte = _num ; nnumofbytes -= npadbyte ; if ( nnumofbytes < _num ) return _str ; return binconverter . bytearraytouncstring ( buf , _num , nnumofbytes ) ; }	decrypts a hexbin string ( handling is case sensitive ).
public static double l_rankloss ( int y [ ] , int r [ ] ) { int l = y . length ; arraylist < integer > ti = new arraylist < integer > ( ) ; arraylist < integer > fi = new arraylist < integer > ( ) ; for ( int j = _num ; j < l ; j ++ ) { if ( y [ j ] == _num ) { ti . add ( j ) ; } else { fi . add ( j ) ; } } if ( ! ti . isempty ( ) && ! fi . isempty ( ) ) { int c = _num ; for ( int k : ti ) { for ( int l : fi ) { if ( position ( k , r ) < position ( l , r ) ) { c ++ ; } } } return ( double ) c / ( double ) ( ti . size ( ) * fi . size ( ) ) ; } else { return _num ; } }	rank loss - the average fraction of labels which are not correctly ordered.
private double addrecursively ( arraylist < double [ ] > hull , hierarchy < cluster < model > > hier , cluster < model > clus ) { final dbids ids = clus . getids ( ) ; double weight = ids . size ( ) ; for ( dbiditer iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { double [ ] projp = proj . fastprojectdatatorenderspace ( rel . get ( iter ) ) ; if ( projp [ _num ] != projp [ _num ] || projp [ _num ] != projp [ _num ] ) { continue ; } hull . add ( projp ) ; } for ( iter < cluster < model > > iter = hier . iterchildren ( clus ) ; iter . valid ( ) ; iter . advance ( ) ) { weight += _num * addrecursively ( hull , hier , iter . get ( ) ) ; } return weight ; }	recursively add a cluster and its children .
public void attributeupdate ( printserviceattributeevent psae ) { log . fine ( _str + psae ) ; }	print service attribute listener .
public static boolean decodetofile ( string datatodecode , string filename ) { boolean success = _bool ; base64 . outputstream bos = null ; try { bos = new base64 . outputstream ( new java . io . fileoutputstream ( filename ) , base64 . decode ) ; bos . write ( datatodecode . getbytes ( preferred_encoding ) ) ; success = _bool ; } catch ( java . io . ioexception e ) { success = _bool ; } finally { try { bos . close ( ) ; } catch ( exception e ) { } } return success ; }	convenience method for decoding data to a file .
public void evict ( ) throws exception { assertopen ( ) ; boolean isempty ; synchronized ( this ) { isempty = pool . isempty ( ) ; } if ( ! isempty ) { if ( softminevictableidletimemillis > _num ) { int numtoevict = getnumidle ( ) - getminidle ( ) ; evict ( system . currenttimemillis ( ) - softminevictableidletimemillis , numtoevict ) ; } if ( minevictableidletimemillis > _num ) { int numtoevict = getnumidle ( ) ; evict ( system . currenttimemillis ( ) - minevictableidletimemillis , numtoevict ) ; } } }	make one pass of the idle object evictor .
protected void generaterandompopulation ( int population_size ) { logger . debug ( _str ) ; for ( int i = _num ; i < population_size ; i ++ ) { t individual = chromosomefactory . getchromosome ( ) ; for ( fitnessfunction < ? > fitnessfunction : this . fitnessfunctions ) { individual . addfitness ( fitnessfunction ) ; } population . add ( individual ) ; if ( isfinished ( ) ) break ; } logger . debug ( _str + population . size ( ) + _str ) ; }	generate random population of given size.
public session ( ) { long uptime = system . currenttimemillis ( ) ; mmainhandler = new handler ( looper . getmainlooper ( ) ) ; mtimestamp = ( uptime / _num ) << _num & ( ( ( uptime - ( ( uptime / _num ) * _num ) ) > > _num ) / _num ) ; morigin = _str ; try { ssignal . await ( ) ; } catch ( interruptedexception e ) { } }	creates a streaming session that can be customized by adding tracks .
public list < visitante > listar ( ) { list < visitante > dados = new arraylist < > ( ) ; try { string sql = _str ; stm = conector . preparestatement ( sql ) ; rs = stm . executequery ( sql ) ; while ( rs . next ( ) ) { dados . add ( new visitante ( rs . getint ( _num ) , rs . getstring ( _num ) , rs . getstring ( _num ) , rs . getstring ( _num ) , rs . getstring ( _num ) , rs . getstring ( _num ) , tempo . todate ( rs . gettimestamp ( _num ) ) , rs . getstring ( _num ) , rs . getstring ( _num ) ) ) ; } stm . close ( ) ; rs . close ( ) ; } catch ( sqlexception ex ) { mensagem . erro ( _str + ex ) ; } return dados ; }	consultar todos visitantes cadastrdos na base de dados.
private void assertallfromtbl1 ( statement stmt , string [ ] ones , short [ ] twos ) throws sqlexception { resultset rs = stmt . executequery ( _str ) ; int i = _num ; for ( ; rs . next ( ) ; i ++ ) { asserttrue ( i < ones . length ) ; assertequals ( ones [ i ] , rs . getstring ( _str ) ) ; assertequals ( twos [ i ] , rs . getshort ( _str ) ) ; } asserttrue ( i == ones . length ) ; }	asserts that the expected values can be selected from the test table .
@ override public writer append ( char value ) { builder . append ( value ) ; return this ; }	append a single character to this writer .
private void insertbefore ( instruction [ ] list , instruction s ) { for ( instruction x : list ) { s . insertbefore ( x ) ; } }	inserts each instruction in a list before another instruction .
public static builder newbuilder ( ) { return new builder ( ) ; }	creates a new persistent subscription settings builder .
public int countarray ( string [ ] array ) { return array . length ; }	counts the size of an array .
private void processunprocessed ( ) { boolean clean_processings = boolean . getboolean ( _str ) ; logger . info ( _str + _str + clean_processings + _str ) ; productservice . processunprocessed ( ! clean_processings ) ; }	run recovery of stopped scanners.
public double [ ] popy ( double x_ [ ] ) { return popy ( new double [ ] [ ] { x_ } ) [ _num ] ; }	forward pass - given input x_ , get output y_ .
public void gotoframe ( int framenumber ) throws ioexception { print ( _str , new string [ ] { integer . tostring ( framenumber ) } ) ; }	description of the method.
public void delete ( string name ) throws ioexception { if ( name . equalsignorecase ( subject_name ) ) { names = null ; } else { throw new ioexception ( _str + _str ) ; } encodethis ( ) ; }	delete the attribute value .
public void pushelemattributeset ( elemattributeset attrset ) { m_attrsetstack . push ( attrset ) ; }	push an executing attribute set , so we can check for recursive attribute definitions .
private void finishscrollstacks ( ) { cancelanimation ( this , property . stack_snap ) ; final int currentmodelindex = gettabstackindex ( ) ; float delta = math . abs ( currentmodelindex + mrenderedscrolloffset ) ; float target = - currentmodelindex ; if ( delta != _num ) { long duration = fling_min_duration + ( long ) math . abs ( delta * getfullscrolldistance ( ) / mflingspeed ) ; addtoanimation ( this , property . stack_snap , mrenderedscrolloffset , target , duration , _num ) ; } else { setproperty ( property . stack_snap , target ) ; if ( mtemporaryselectedstack != null ) { mtabmodelselector . selectmodel ( mtemporaryselectedstack ) ; mtemporaryselectedstack = null ; } } }	animate to the final position of the stack.
public geodistancebuilder addunboundedfrom ( string key , double from ) { ranges . add ( new range ( key , from , null ) ) ; return this ; }	add a new range with no upper bound .
private void sendresponse ( document doc , messagefactory messagefactory , string contenttype , httpservletresponse res ) throws ioexception , soapexception { soapmessage reply = messagefactory . createmessage ( ) ; soapheader header = reply . getsoapheader ( ) ; header . detachnode ( ) ; soapbody replybody = reply . getsoapbody ( ) ; res . setheader ( _str , contenttype ) ; replybody . adddocument ( doc ) ; reply . savechanges ( ) ; outputstream os = res . getoutputstream ( ) ; reply . writeto ( os ) ; os . flush ( ) ; }	send a response back to the client.
public static string replacechars ( string str , string oldchars , char newchar ) { int pos = indexofchars ( str , oldchars ) ; if ( pos == - _num ) { return str ; } stringbuilder buf = new stringbuilder ( str ) ; do { buf . setcharat ( pos , newchar ) ; pos = indexofchars ( str , oldchars , pos + _num ) ; } while ( pos != - _num ) ; return buf . tostring ( ) ; }	like string . replace ( ) except that it accepts any number of old chars . replaces any occurrances of ' oldchars ' in ' str ' with ' newchar ' . example : replacechars ( " hello , world ! " , " h , ! " , ' ' ) returns " ello world ".
public final charsequence yytext ( ) { return zzbuffer . subsequence ( zzstartread , zzmarkedpos ) ; }	returns the text matched by the current regular expression .
public static string canonicalizepath ( string path , boolean discardrelativeprefix ) { int segmentstart = _num ; int deletablesegments = _num ; for ( int i = _num ; i <= path . length ( ) ; ) { int nextsegmentstart ; if ( i == path . length ( ) ) { nextsegmentstart = i ; } else if ( path . charat ( i ) == _str ) { nextsegmentstart = i + _num ; } else { i ++ ; continue ; } if ( i == segmentstart + _num && path . regionmatches ( segmentstart , _str , _num , _num ) ) { path = path . substring ( _num , segmentstart ) + path . substring ( nextsegmentstart ) ; i = segmentstart ; } else if ( i == segmentstart + _num && path . regionmatches ( segmentstart , _str , _num , _num ) ) { if ( deletablesegments > _num || discardrelativeprefix ) { deletablesegments -- ; int prevsegmentstart = path . lastindexof ( _str , segmentstart - _num ) + _num ; path = path . substring ( _num , prevsegmentstart ) + path . substring ( nextsegmentstart ) ; i = segmentstart = prevsegmentstart ; } else { i ++ ; segmentstart = i ; } } else { if ( i > _num ) { deletablesegments ++ ; } i ++ ; segmentstart = i ; } } return path ; }	returns the path will relative path segments like ".
public inmemorymessageexchangestore ( final networkconfig config , tokenprovider tokenprovider ) { if ( config == null ) { throw new nullpointerexception ( _str ) ; } if ( tokenprovider == null ) { throw new nullpointerexception ( _str ) ; } this . tokenprovider = tokenprovider ; this . config = config ; }	creates a new store for configuration values .
public static void next ( ) { try { if ( musicplaybackservice != null ) { musicplaybackservice . next ( ) ; } } catch ( final remoteexception ignored ) { } }	changes to the next track.
private void drawbitmapwithstroke ( canvas canvas , bitmap bitmap , int centerx , int centery , float radius , paint drawpaint ) { drawpaint . setstyle ( paint . style . fill ) ; float strokeradius = radius + mradiusstrokewidth ; drawpaint . setxfermode ( new porterduffxfermode ( porterduff . mode . clear ) ) ; canvas . drawcircle ( centerx , centery , strokeradius , drawpaint ) ; drawpaint . setxfermode ( null ) ; final int halfbitmapwidth = bitmap . getwidth ( ) / _num ; final int halfbitmapheight = bitmap . getheight ( ) / _num ; bitmapshader bitmapshader = new bitmapshader ( bitmap , shader . tilemode . repeat , shader . tilemode . repeat ) ; matrix shadermatrix = new matrix ( ) ; float minsize = bitmap . getwidth ( ) > bitmap . getheight ( ) ? bitmap . getheight ( ) : bitmap . getwidth ( ) ; float scale = radius * _num / minsize ; shadermatrix . setscale ( scale , scale ) ; shadermatrix . posttranslate ( centerx - ( halfbitmapwidth * scale ) , centery - ( halfbitmapheight * scale ) ) ; bitmapshader . setlocalmatrix ( shadermatrix ) ; drawpaint . setshader ( bitmapshader ) ; canvas . drawcircle ( centerx , centery , radius , drawpaint ) ; drawpaint . setshader ( null ) ; }	draw single bitmap with the giving centerx , centery and radius.
public mqttdevice mqttdevice ( ) { return mqttdevice ; }	get the application ' s mqttdevice.
public abbalockingdetector startcollecting ( ) { thread = new thread ( this , _str ) ; thread . setdaemon ( _bool ) ; thread . start ( ) ; return this ; }	start collecting locking data .
protected object readobjectoverride ( ) throws optionaldataexception , classnotfoundexception , ioexception { if ( input == null ) { return null ; } throw new ioexception ( ) ; }	method to be overridden by subclasses to read the next object from the source stream .
public float tometers ( double pixels ) { return ( float ) ( pixels * meters_per_pixels ) ; }	converts pixels to meters.
boolean addtobuffer ( char c ) throws ioexception { int len = sb . length ( ) ; if ( len == _num && c != char_lt ) return _bool ; sb . append ( c ) ; if ( ++ len >= mintaglen ) { boolean isclosingtag = ( len >= _num && sb . charat ( _num ) == char_sl ) ; string substr ; if ( isclosingtag ) substr = sb . substring ( _num ) ; else substr = sb . substring ( _num ) ; for ( int i = _num ; i < exclude_tags . length ; i ++ ) { if ( substr . equalsignorecase ( exclude_tags [ i ] ) ) { if ( isclosingtag ) { depthdec ( i ) ; printbuffer ( ) ; lastchar = _num ; } else { depthinc ( i ) ; } } } } return _bool ; }	checks if a character is part of an open html tag or close html tag , and if so adds it to the buffer , otherwise returns false .
public static double length ( double x , double y , double z ) { return math . sqrt ( x * x + y * y + z * z ) ; }	computes the length of a vector.
private cache createcache ( ) throws cacheexception { final properties props = new properties ( ) ; props . setproperty ( locators , _str ) ; props . setproperty ( mcast_port , _str ) ; return cachefactory . create ( distributedsystem . connect ( props ) ) ; }	creates the cache instance for the test.
public attributelistpanel ( ) { m_table . setselectionmode ( listselectionmodel . single_selection ) ; m_table . setcolumnselectionallowed ( _bool ) ; m_table . setpreferredscrollableviewportsize ( new dimension ( _num , _num ) ) ; setlayout ( new borderlayout ( ) ) ; add ( new jscrollpane ( m_table ) , borderlayout . center ) ; }	creates the attribute selection panel with no initial instances .
private environment ( ) { throw contractutils . unreachable ( ) ; }	make sure nobody can instantiate the class.
public void removephoto ( photoentity photo ) { photos . remove ( photo ) ; }	removes the given photo from this user.
public static int binarysearch ( double [ ] array , int startindex , int endindex , double value ) { checkindexforbinarysearch ( array . length , startindex , endindex ) ; long longbits = double . doubletolongbits ( value ) ; int low = startindex , mid = - _num , high = endindex - _num ; while ( low <= high ) { mid = ( low + high ) > > > _num ; if ( lessthan ( array [ mid ] , value ) ) { low = mid + _num ; } else if ( longbits == double . doubletolongbits ( array [ mid ] ) ) { return mid ; } else { high = mid - _num ; } } if ( mid < _num ) { int insertpoint = endindex ; for ( int index = startindex ; index < endindex ; index ++ ) { if ( value < array [ index ] ) { insertpoint = index ; } } return - insertpoint - _num ; } return - mid - ( lessthan ( value , array [ mid ] ) ? _num : _num ) ; }	performs a binary search for the specified element in a part of the specified sorted array .
public static void compute ( double minscore , double toppercent , double maxexpected , float minpercentidentity , ireadblock readblock , string classificationname , bitset activematchesforclassification ) { activematchesforclassification . clear ( ) ; for ( int i = _num ; i < readblock . getnumberofavailablematchblocks ( ) ; i ++ ) { final imatchblock matchblock = readblock . getmatchblock ( i ) ; if ( ! matchblock . isignore ( ) && matchblock . getbitscore ( ) >= minscore && matchblock . getexpected ( ) <= maxexpected && matchblock . getpercentidentity ( ) >= minpercentidentity ) { if ( matchblock . getid ( classificationname ) > _num ) activematchesforclassification . set ( i ) ; } } float bestscore = _num ; for ( int i = activematchesforclassification . nextsetbit ( _num ) ; i != - _num ; i = activematchesforclassification . nextsetbit ( i + _num ) ) { final imatchblock matchblock = readblock . getmatchblock ( i ) ; float score = matchblock . getbitscore ( ) ; if ( score > bestscore ) bestscore = score ; } applytoppercentfilter ( toppercent , bestscore , minpercentidentity , readblock , activematchesforclassification ) ; }	get the set of matches active for the given read.
public e [ ] toarray ( e [ ] a ) { if ( a . length != array . length ( ) ) { throw new elasticsearchgenerationexception ( _str ) ; } for ( int i = _num ; i < array . length ( ) ; i ++ ) { a [ i ] = array . get ( i ) ; } return a ; }	copies the content of the underlying atomic array to a normal one .
synchronized public void failon ( failure fail ) { if ( failures == null ) { failures = new arraylist < > ( ) ; } failures . add ( fail ) ; }	add a failure object to the list of objects to be evaluated at every potential failure point.
public void dump_stack ( ) { if ( stack == null ) { debug_message ( _str ) ; return ; } debug_message ( _str ) ; for ( int i = _num ; i < stack . size ( ) ; i ++ ) { debug_message ( _str + ( ( symbol ) stack . elementat ( i ) ) . sym + _str + ( ( symbol ) stack . elementat ( i ) ) . parse_state ) ; } debug_message ( _str ) ; }	dump the parse stack for debugging purposes .
private static set < string > createcategoriesset ( set < string > categories ) { set < string > result = new hashset < > ( ) ; for ( string cat : categories ) { result . add ( stringutil . tolowercase ( cat ) ) ; } return result ; }	creates a new set with the given categories , making them all lowercase in the process.
public void loadlistener ( string serverkey ) throws genericserviceexception { server server = servers . get ( serverkey ) ; if ( server == null ) throw new genericserviceexception ( _str ) ; loadlistener ( serverkey , server ) ; }	load a jms message listener .
public void upload ( file file , long restartat , ftpdatatransferlistener listener ) throws illegalstateexception , filenotfoundexception , ioexception , ftpillegalreplyexception , ftpexception , ftpdatatransferexception , ftpabortedexception { if ( ! file . exists ( ) ) { throw new filenotfoundexception ( file . getabsolutepath ( ) ) ; } inputstream inputstream = null ; try { inputstream = new fileinputstream ( file ) ; } catch ( ioexception e ) { throw new ftpdatatransferexception ( e ) ; } try { upload ( file . getname ( ) , inputstream , restartat , restartat , listener ) ; } catch ( illegalstateexception e ) { throw e ; } catch ( ioexception e ) { throw e ; } catch ( ftpillegalreplyexception e ) { throw e ; } catch ( ftpexception e ) { throw e ; } catch ( ftpdatatransferexception e ) { throw e ; } catch ( ftpabortedexception e ) { throw e ; } finally { if ( inputstream != null ) { try { inputstream . close ( ) ; } catch ( throwable t ) { ; } } } }	this method uploads a file to the remote server.
public sslsocket createsslsocket ( socket socket ) throws ioexception { sslsocketfactory sf = ( ( sslsocketfactory ) sslsocketfactory . getdefault ( ) ) ; inetsocketaddress remoteaddress = ( inetsocketaddress ) socket . getremotesocketaddress ( ) ; sslsocket s = ( sslsocket ) ( sf . createsocket ( socket , remoteaddress . gethostname ( ) , socket . getport ( ) , _bool ) ) ; s . setuseclientmode ( _bool ) ; s . setenabledciphersuites ( s . getsupportedciphersuites ( ) ) ; return s ; }	create a ssl socket that wraps the existing socket.
private string formatnode ( rightthreadedbinarynode < t > node ) { rightthreadedbinarynode < t > n ; stringbuilder response = new stringbuilder ( _str ) ; if ( ( n = node . getleftson ( ) ) != null ) { response . append ( formatnode ( n ) ) ; } response . append ( node . tostring ( ) ) ; if ( ( n = node . getrightson ( ) ) != null ) { response . append ( formatnode ( n ) ) ; } response . append ( _str ) ; return response . tostring ( ) ; }	format the node , recursively .
public static void unregistermbean ( class < ? > mbeaninterface ) { mbeanserver mbs = managementfactory . getplatformmbeanserver ( ) ; try { objectname name = generatembeanobjectname ( mbeaninterface ) ; if ( mbs . isregistered ( name ) ) { logger . info ( _str + name . tostring ( ) ) ; mbs . unregistermbean ( name ) ; } else { logger . warn ( _str + name . tostring ( ) ) ; } } catch ( exception e ) { throw new serverruntimeexception ( _str + mbeaninterface , e ) ; } }	server helper method to register a jmx mbean.
public void writeexif ( inputstream jpegstream , string exifoutfilename ) throws filenotfoundexception , ioexception { if ( jpegstream == null || exifoutfilename == null ) { throw new illegalargumentexception ( null_argument_string ) ; } outputstream s = null ; try { s = getexifwriterstream ( exifoutfilename ) ; doexifstreamio ( jpegstream , s ) ; s . flush ( ) ; } catch ( ioexception e ) { closesilently ( s ) ; throw e ; } s . close ( ) ; }	writes the tags from this exifinterface object into a jpeg stream , removing prior exif tags .
public void sort ( comparator < ? super t > comparator ) { synchronized ( mlock ) { if ( moriginalvalues != null ) { collections . sort ( moriginalvalues , comparator ) ; } else { collections . sort ( mobjects , comparator ) ; } } if ( mnotifyonchange ) notifydatasetchanged ( ) ; }	sorts the content of this adapter using the specified comparator .
static boolean causedbyrde ( diskaccessexception dae ) { boolean result = _bool ; if ( dae != null ) { throwable cause = dae . getcause ( ) ; while ( cause != null ) { if ( cause instanceof regiondestroyedexception ) { result = _bool ; break ; } cause = cause . getcause ( ) ; } } return result ; }	return true if dae was caused by a regiondestroyedexception.
public jsonarray add ( string value ) { values . add ( json . value ( value ) ) ; return this ; }	appends the json representation of the specified string to the end of this array .
public magicvariablesargumentsbundle ( @ nonnull map < string , string > arguments , @ nonnull map < string , string > variables , string layername , @ nonnull displaymetrics metrics ) { super ( arguments , metrics ) ; mvariables = variables ; mlayernameprefix = _str + layername . replace ( _str , _str ) + _str ; }	create a new simple arguments bundle implementation from provided key - & gt ; value map .
@ hleunimplemented @ hlefunction ( nid = _num , version = _num ) public int sceusbcamsetupvideoex ( pspusbcamsetupvideoexparam usbcamsetupvideoexparam , tpointer workarea , int workareasize ) { this . workarea = workarea . getaddress ( ) ; this . workareasize = workareasize ; resolution = convertresolutionextoresolution ( usbcamsetupvideoexparam . resolution ) ; framerate = usbcamsetupvideoexparam . framerate ; whitebalance = usbcamsetupvideoexparam . wb ; saturation = usbcamsetupvideoexparam . saturation ; brightness = usbcamsetupvideoexparam . brightness ; contrast = usbcamsetupvideoexparam . contrast ; sharpness = usbcamsetupvideoexparam . sharpness ; imageeffectmode = usbcamsetupvideoexparam . effectmode ; framesize = usbcamsetupvideoexparam . framesize ; evlevel = usbcamsetupvideoexparam . evlevel ; if ( ! setupvideo ( ) ) { log . warn ( string . format ( _str ) ) ; return scekernelerrors . error_usbcam_not_ready ; } return _num ; }	set ups the parameters for video capture ( with more options ).
public list < user > loadalldeepfromcursor ( cursor cursor ) { int count = cursor . getcount ( ) ; list < user > list = new arraylist < user > ( count ) ; if ( cursor . movetofirst ( ) ) { if ( identityscope != null ) { identityscope . lock ( ) ; identityscope . reserveroom ( count ) ; } try { do { list . add ( loadcurrentdeep ( cursor , _bool ) ) ; } while ( cursor . movetonext ( ) ) ; } finally { if ( identityscope != null ) { identityscope . unlock ( ) ; } } } return list ; }	reads all available rows from the given cursor and returns a list of new imageto objects .
public static date convertiso8601todate ( string datestring ) throws parseexception { dateformat dateformat = new simpledateformat ( _str ) ; date date = dateformat . parse ( datestring ) ; return date ; }	method that converts a an iso 8601 string to java date.
public static document createdom ( inputstream is ) throws parserconfigurationexception , saxexception , ioexception { documentbuilderfactory dbf = documentbuilderfactory . newinstance ( ) ; dbf . setvalidating ( _bool ) ; dbf . setignoringcomments ( _bool ) ; dbf . setignoringelementcontentwhitespace ( _bool ) ; dbf . setnamespaceaware ( _bool ) ; dbf . setfeature ( xmlconstants . feature_secure_processing , _bool ) ; dbf . setfeature ( disallow_doctype_decl , _bool ) ; dbf . setfeature ( external_general_entities , _bool ) ; dbf . setfeature ( external_parameter_entities , _bool ) ; dbf . setfeature ( load_external_dtd , _bool ) ; documentbuilder db = null ; db = dbf . newdocumentbuilder ( ) ; db . setentityresolver ( new nullresolver ( ) ) ; db . seterrorhandler ( new samlparsererrorhandler ( ) ) ; return db . parse ( is ) ; }	create dom from iostream .
public string tostring ( ) { return double . tostring ( getvalue ( ) ) ; }	obtains the string representation of this object .
public void resetcount ( ) { msgcnt . set ( _num ) ; }	resets counter to zero .
public void scheduleatfixedrate ( timertask task , date when , long period ) { if ( period <= _num || when . gettime ( ) < _num ) { throw new illegalargumentexception ( ) ; } long delay = when . gettime ( ) - system . currenttimemillis ( ) ; scheduleimpl ( task , delay , period , _bool ) ; }	schedule a task for repeated fixed - rate execution after a specific time has been reached .
void decodeattributebody ( byte [ ] attributevalue , char offset , char length ) throws stunexception { realm = new byte [ length ] ; system . arraycopy ( attributevalue , offset , realm , _num , length ) ; }	copies the value of the realm attribute from the specified attributevalue .
public static void copyassets ( context context , string assetsfilename , file file , string mode ) throws ioexception , interruptedexception { string abi = build . cpu_abi ; string libraryname ; if ( abi . equalsignorecase ( _str ) ) { libraryname = _str ; } else if ( abi . equalsignorecase ( _str ) ) { libraryname = _str ; } else if ( abi . contains ( _str ) ) { libraryname = _str ; } else { return ; } assetmanager manager = context . getassets ( ) ; final inputstream is = manager . open ( libraryname + _str + assetsfilename ) ; copyfile ( file , is , mode ) ; }	copy file in assets into destination file.
public boolean is_same ( object obj ) { if ( this == obj ) return _bool ; if ( obj == null ) return _bool ; if ( getclass ( ) != obj . getclass ( ) ) return _bool ; housenumber other = ( housenumber ) obj ; if ( number == null ) { if ( name == null ) { if ( other . name != null ) return _bool ; } else if ( ! name . equals ( other . name ) ) return _bool ; } else if ( ! number . equals ( other . number ) ) return _bool ; if ( street == null ) { if ( other . street != null ) return _bool ; } else if ( ! street . equals ( other . street ) ) return _bool ; return _bool ; }	check if address are content identical if number are equals and street ( if number is null , we look at the name ).
public static double nextup ( double d ) { if ( d == double . positive_infinity ) return d ; else { d += _num ; return double . longbitstodouble ( double . doubletorawlongbits ( d ) + ( ( d >= _num ) ? + _num : - _num ) ) ; } }	replacement for the math.
public int threewaydistance ( key k1 , key k2 ) { byte [ ] h0 = hash ; byte [ ] h1 = k1 . hash ; byte [ ] h2 = k2 . hash ; int mmi = mismatch ( h1 , h2 ) ; if ( mmi == - _num ) return _num ; int h = byte . tounsignedint ( h0 [ mmi ] ) ; int a = byte . tounsignedint ( h1 [ mmi ] ) ; int b = byte . tounsignedint ( h2 [ mmi ] ) ; return integer . compareunsigned ( a ^ h , b ^ h ) ; }	compares the distance of two keys relative to this one using the xor metric.
static byte [ ] discardwhitespace ( byte [ ] data ) { byte groomeddata [ ] = new byte [ data . length ] ; int bytescopied = _num ; for ( int i = _num ; i < data . length ; i ++ ) { switch ( data [ i ] ) { case ( byte ) _str : case ( byte ) _str : case ( byte ) _str : case ( byte ) _str : break ; default : groomeddata [ bytescopied ++ ] = data [ i ] ; } } byte packeddata [ ] = new byte [ bytescopied ] ; system . arraycopy ( groomeddata , _num , packeddata , _num , bytescopied ) ; return packeddata ; }	discards any whitespace from a base - 64 encoded block .
public asyncselector ( ) throws ioexception { this ( selector . open ( ) ) ; }	construct asyncselector with brand new selector.
public void removechildat ( int index ) { if ( ( index < _num ) || ( children == null ) || ( index >= children . size ( ) ) ) { throw new arrayindexoutofboundsexception ( ) ; } element child = ( element ) children . get ( index ) ; child . setparent ( null ) ; children . remove ( index ) ; }	removes the child at the given index.
private linkedlist < diff > diff_bisectsplit ( string text1 , string text2 , int x , int y , long deadline ) { string text1a = text1 . substring ( _num , x ) ; string text2a = text2 . substring ( _num , y ) ; string text1b = text1 . substring ( x ) ; string text2b = text2 . substring ( y ) ; linkedlist < diff > diffs = diff_main ( text1a , text2a , _bool , deadline ) ; linkedlist < diff > diffsb = diff_main ( text1b , text2b , _bool , deadline ) ; diffs . addall ( diffsb ) ; return diffs ; }	given the location of the ' middle snake ' , split the diff in two parts and recurse .
private void paint ( painter p , synthcontext ctx , graphics g , int x , int y , int w , int h , affinetransform transform ) { if ( p != null ) { if ( g instanceof graphics2d ) { graphics2d gfx = ( graphics2d ) g ; if ( transform != null ) { gfx . transform ( transform ) ; } gfx . translate ( x , y ) ; p . paint ( gfx , ctx . getcomponent ( ) , w , h ) ; gfx . translate ( - x , - y ) ; if ( transform != null ) { try { gfx . transform ( transform . createinverse ( ) ) ; } catch ( noninvertibletransformexception e ) { e . printstacktrace ( ) ; } } } else { bufferedimage img = new bufferedimage ( w , h , bufferedimage . type_int_argb ) ; graphics2d gfx = img . creategraphics ( ) ; if ( transform != null ) { gfx . transform ( transform ) ; } p . paint ( gfx , ctx . getcomponent ( ) , w , h ) ; gfx . dispose ( ) ; g . drawimage ( img , x , y , null ) ; img = null ; } } }	paint the provided painter using the provided transform at the specified position and size.
static void loaddirectory ( file file , modulecandidate candidate ) throws ioexception { file [ ] files = file . listfiles ( ) ; if ( files != null ) for ( file f : files ) loadsubdirectory ( file , f , candidate ) ; }	load a module candidate from a directory.
public static boolean hassuppressed ( @ nullable throwable t , @ nullable class < ? extends throwable > cls ) { if ( t == null || cls == null ) return _bool ; if ( t . getsuppressed ( ) != null ) { for ( throwable th : t . getsuppressed ( ) ) { if ( cls . isassignablefrom ( th . getclass ( ) ) ) return _bool ; if ( hassuppressed ( th , cls ) ) return _bool ; } } return _bool ; }	checks if passed throwable has given class in one of the suppressed exceptions .
static int writevarlong ( outputstream out , long x ) throws ioexception { int len = _num ; while ( ( x & ~ _num ) != _num ) { out . write ( ( byte ) ( _num | ( x & _num ) ) ) ; x >>>= _num ; len ++ ; } out . write ( ( byte ) x ) ; return ++ len ; }	write a variable size long value .
protected void engineupdate ( byte b ) throws signatureexception { messagedigest . update ( b ) ; needsreset = _bool ; }	updates the data to be signed or verified using the specified byte .
private void writeobject ( java . io . objectoutputstream s ) throws java . io . ioexception { final reentrantlock lock = this . lock ; lock . lock ( ) ; try { s . defaultwriteobject ( ) ; for ( node < e > p = first ; p != null ; p = p . next ) s . writeobject ( p . item ) ; s . writeobject ( null ) ; } finally { lock . unlock ( ) ; } }	saves this deque to a stream ( that is , serializes it ) .
private boolean checkifinitiatorforrpbeforemigration ( initiator initiator ) { if ( initiator == null ) { return _bool ; } boolean isrp = _bool ; if ( nullcolumnvaluegetter . isnullvalue ( initiator . gethostname ( ) ) || ! nullcolumnvaluegetter . isnulluri ( initiator . gethost ( ) ) ) { isrp = _bool ; } log . debug ( _str + ( isrp ? _str : _str ) ) ; return isrp ; }	check if the passed in initiator is for rp.
@ override public collection < serialmessage > initialize ( boolean refresh ) { arraylist < serialmessage > result = new arraylist < serialmessage > ( ) ; if ( issupportrequestsupported == _bool && ( refresh == _bool || initialisedone == _bool ) && getversion ( ) > _num ) { result . add ( getsupportedmessage ( ) ) ; } return result ; }	initializes the meter command class.
public static dmlconfig readconfigurationfile ( string configpath ) throws parseexception , filenotfoundexception { dmlconfig config = new dmlconfig ( ) ; if ( configpath != null ) { try { config = new dmlconfig ( configpath , _bool ) ; } catch ( filenotfoundexception fnfe ) { log . error ( _str + configpath + _str ) ; throw fnfe ; } catch ( parseexception e ) { throw e ; } } else { try { config = new dmlconfig ( default_systemml_config_filepath , _bool ) ; } catch ( filenotfoundexception fnfe ) { log . info ( _str + _str ) ; config = new dmlconfig ( ) ; } catch ( parseexception e ) { throw e ; } } return config ; }	start with the internal default settings , then merge in the settings from any specified configuration file , if available.
default b withdefault ( string key , int value ) { return withdefault ( key , integer . tostring ( value ) ) ; }	if there is no field with the specified key , then associate the given value with the specified key .
private string [ ] combineresultsfrommultiplereads ( string [ ] buffer , string [ ] lastread ) { string [ ] t = new string [ buffer . length + lastread . length ] ; system . arraycopy ( buffer , _num , t , _num , buffer . length ) ; system . arraycopy ( lastread , _num , t , buffer . length , lastread . length ) ; return t ; }	for multi line records this method combines the current result with the result from previous read ( s ) .
private static boolean isretina ( ) { if ( systeminfo . isapplejvm ) { return hasappleretinadevice ( ) ; } if ( systeminfo . ismac ) { graphicsenvironment e = graphicsenvironment . getlocalgraphicsenvironment ( ) ; graphicsdevice [ ] devices = e . getscreendevices ( ) ; for ( graphicsdevice device : devices ) { if ( isoraclemacretinadevice ( device ) ) { return _bool ; } } } return _bool ; }	checks that at least one retina device is present.
public void poln ( object o ) throws ioexception { po ( o . tostring ( ) ) ; pln ( ) ; }	indent out ; write object ; end current line .
public activityresolveinfo ( resolveinfo resolveinfo ) { this . resolveinfo = resolveinfo ; }	creates a new instance .
private static pair < string , string > postindexedlsr ( final long offset , final itranslationenvironment environment , final list < reilinstruction > instructions , final string registernodevalue1 , final string registernodevalue2 , final string immediatenodevalue ) { final string address = environment . getnextvariablestring ( ) ; final string tmpvar1 = environment . getnextvariablestring ( ) ; final string tmpvar2 = environment . getnextvariablestring ( ) ; final string index = environment . getnextvariablestring ( ) ; long baseoffset = offset ; instructions . add ( reilhelpers . createstr ( baseoffset ++ , dw , registernodevalue1 , dw , address ) ) ; instructions . add ( reilhelpers . createbsh ( baseoffset ++ , dw , registernodevalue2 , dw , _str + immediatenodevalue , qw , tmpvar1 ) ) ; instructions . add ( reilhelpers . createand ( baseoffset ++ , qw , tmpvar1 , dw , dwordbitmask , dw , index ) ) ; instructions . add ( reilhelpers . createadd ( baseoffset ++ , dw , registernodevalue1 , dw , index , dw , tmpvar2 ) ) ; instructions . add ( reilhelpers . createand ( baseoffset ++ , dw , tmpvar2 , dw , dwordbitmask , dw , registernodevalue1 ) ) ; return new pair < string , string > ( address , registernodevalue1 ) ; }	operation : [ < rn > ] , + / - < rm > , lsr # < shift_imm > address = rn 0b01 / lsr / if shift_imm = = 0 then / lsr # 32 / index = 0 else index = rm logical_shift_right shift_imm if conditionpassed ( cond ) then if u = = 1 then rn = rn + index else / u = = 0 / rn = rn - index.
private void endformals ( ) { if ( hasformals ) { hasformals = _bool ; buf . append ( _str ) ; } }	ends the formal type parameters section of the signature .
public boolean nextissep ( ) { if ( character . isletterordigit ( str . charat ( currentposition ) ) ) return _bool ; else return _bool ; }	tells if there is a digit or a letter character ahead .
private string extractprojectnamefromuri ( @ notnull string uri ) { int indexfinishprojectname = uri . lastindexof ( _str ) ; int indexstartprojectname = uri . lastindexof ( _str ) != - _num ? uri . lastindexof ( _str ) + _num : ( uri . lastindexof ( _str ) + _num ) ; if ( indexstartprojectname != _num && indexstartprojectname < indexfinishprojectname ) { return uri . substring ( indexstartprojectname , indexfinishprojectname ) ; } if ( indexstartprojectname != _num ) { return uri . substring ( indexstartprojectname ) ; } return _str ; }	gets project name from uri .
public final void addreference ( object ref ) { refset . add ( ref ) ; }	adds the given object to the set of hard references , which will prevent that object from being disposed until the queue has been flushed completely.
private void resetnotes2 ( ) { if ( errorinstatus2 ) { if ( editmode ) { statustext1 . settext ( editstatus2 ) ; } else { statustext2 . settext ( stdstatus2 ) ; } errorinstatus2 = _bool ; } }	reset the second line of notes area.
public requirementsbuilder addrequireproperty ( string name , requirementsbuilder builder ) { addproperty ( name , builder ) ; requiredproperties . add ( name ) ; return this ; }	add a required property of type object .
private cell detectandaddhit ( float x , float y ) { final cell cell = checkfornewhit ( x , y ) ; if ( cell != null ) { cell fillingapcell = null ; final arraylist < cell > pattern = mpattern ; if ( ! pattern . isempty ( ) ) { final cell lastcell = pattern . get ( pattern . size ( ) - _num ) ; int drow = cell . row - lastcell . row ; int dcolumn = cell . column - lastcell . column ; int fillinrow = lastcell . row ; int fillincolumn = lastcell . column ; if ( math . abs ( drow ) == _num && math . abs ( dcolumn ) != _num ) { fillinrow = lastcell . row + ( ( drow > _num ) ? _num : - _num ) ; } if ( math . abs ( dcolumn ) == _num && math . abs ( drow ) != _num ) { fillincolumn = lastcell . column + ( ( dcolumn > _num ) ? _num : - _num ) ; } fillingapcell = cell . of ( fillinrow , fillincolumn ) ; } if ( fillingapcell != null && ! mpatterndrawlookup [ fillingapcell . row ] [ fillingapcell . column ] ) { addcelltopattern ( fillingapcell ) ; } addcelltopattern ( cell ) ; if ( menablehapticfeedback ) { performhapticfeedback ( hapticfeedbackconstants . virtual_key , hapticfeedbackconstants . flag_ignore_view_setting | hapticfeedbackconstants . flag_ignore_global_setting ) ; } return cell ; } return null ; }	determines whether the point x , y will add a new point to the current pattern ( in addition to finding the cell , also makes heuristic choices such as filling in gaps based on current pattern ) .
public headrule ( string dir , string rule ) { string [ ] tmp = p_tagsets . split ( rule ) ; int i , size = tmp . length ; b_r2l = dir . equals ( dir_right_to_left ) ; a_tagsets = new headtagset [ size ] ; for ( i = _num ; i < size ; i ++ ) a_tagsets [ i ] = new headtagset ( tmp [ i ] ) ; }	constructs a new headrule by decoding the specific head tagsets .
public void testnegposfirstshorter ( ) { byte abytes [ ] = { - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { - _num , _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , - _num , _num , _num , - _num , - _num } ; int asign = - _num ; int bsign = _num ; byte rbytes [ ] = { - _num , _num , _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . or ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , result . signum ( ) ) ; }	or for two negative numbers ; the first is shorter.
@ override public < t > future < t > submit ( callable < t > task ) { synchronized ( this ) { active . incrementandget ( ) ; long timeout = _num ; while ( queue . remainingcapacity ( ) == _num ) { try { if ( timeout <= giveuptime ) { thread . sleep ( default_sleep ) ; timeout += default_sleep ; } else { throw new runtimeexception ( _str ) ; } } catch ( interruptedexception e ) { throw new runtimeexception ( e ) ; } } return super . submit ( task ) ; } }	this is a thread safe way to avoid rejection exception.
public void testsubtractmathcontextdiffscaleposneg ( ) { string a = _str ; int ascale = _num ; string b = _str ; int bscale = - _num ; string c = _str ; int cscale = - _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; mathcontext mc = new mathcontext ( _num , roundingmode . down ) ; bigdecimal result = anumber . subtract ( bnumber , mc ) ; assertequals ( _str , c , result . tostring ( ) ) ; assertequals ( _str , cscale , result . scale ( ) ) ; }	subtract two numbers of different scales using mathcontext ; the first is positive.
protected xsqlda allocatexsqlda ( rowdescriptor rowdescriptor ) { if ( rowdescriptor == null || rowdescriptor . getcount ( ) == _num ) { final xsqlda xsqlda = new xsqlda ( _num ) ; xsqlda . sqld = xsqlda . sqln = _num ; return xsqlda ; } final xsqlda xsqlda = new xsqlda ( rowdescriptor . getcount ( ) ) ; for ( int idx = _num ; idx < rowdescriptor . getcount ( ) ; idx ++ ) { final fielddescriptor fielddescriptor = rowdescriptor . getfielddescriptor ( idx ) ; final xsqlvar xsqlvar = xsqlda . sqlvar [ idx ] ; xsqlvar . sqltype = ( short ) ( fielddescriptor . gettype ( ) | _num ) ; xsqlvar . sqlsubtype = ( short ) fielddescriptor . getsubtype ( ) ; xsqlvar . sqlscale = ( short ) fielddescriptor . getscale ( ) ; xsqlvar . sqllen = ( short ) fielddescriptor . getlength ( ) ; xsqlvar . sqlind = new shortbyreference ( ) ; final int requireddatasize = fielddescriptor . isvarying ( ) ? fielddescriptor . getlength ( ) + _num : fielddescriptor . getlength ( ) + _num ; xsqlvar . sqldata = new memory ( requireddatasize ) ; } return xsqlda ; }	creates an xsqlda , populates type information and allocates memory for the sqldata fields .
public static void overwrite ( long [ ] vector , long val , int offset , int len ) { int idx = offset > > _num ; int bitidx = offset & _num ; int truncatedvallen = math . min ( len , _num - bitidx ) ; vector [ idx ] &= ~ ( maskbelow ( truncatedvallen ) << bitidx ) ; vector [ idx ] |= val << bitidx ; if ( len != truncatedvallen ) { long mask = maskbelow ( len - truncatedvallen ) ; vector [ idx + _num ] &= ~ mask ; vector [ idx + _num ] |= ( val > > > truncatedvallen ) ; } }	overwrites a bit range within the vector .
public static boolean isempty ( string string ) { if ( null == string ) return _bool ; return string . equals ( empty ) ; }	check if the given string is empty or null.
public void addscrollviewlistener ( wxscrollviewlistener scrollviewlistener ) { if ( ! mscrollviewlisteners . contains ( scrollviewlistener ) ) { mscrollviewlisteners . add ( scrollviewlistener ) ; } }	add listener for scrollview .
callbacks trygetcallbacks ( callbacks oldcallbacks ) { synchronized ( mlock ) { if ( mstopped ) { return null ; } if ( mcallbacks == null ) { return null ; } final callbacks callbacks = mcallbacks . get ( ) ; if ( callbacks != oldcallbacks ) { return null ; } if ( callbacks == null ) { log . w ( tag , _str ) ; return null ; } return callbacks ; } }	gets the callbacks object.
public void beginupdatememoryused ( long bytesused , boolean willsendevent ) ;	called at the beginning of updatememoryused .
@ override public point translatejava2dtoscreen ( point2d java2dpoint ) { insets insets = getinsets ( ) ; int x = ( int ) ( java2dpoint . getx ( ) * this . scalex + insets . left ) ; int y = ( int ) ( java2dpoint . gety ( ) * this . scaley + insets . top ) ; return new point ( x , y ) ; }	translates a java2d point on the chart to a screen location .
private void updatetrafficprojections ( ) { list < airmaptraffic > updated = new arraylist < > ( ) ; for ( airmaptraffic traffic : alltraffic ) { if ( traffic . getgroundspeedkt ( ) > - _num && traffic . gettrueheading ( ) > - _num ) { alltraffic . remove ( traffic ) ; coordinate projected = projectedcoordinate ( traffic ) ; traffic . setcoordinate ( projected ) ; traffic . setshowalert ( _bool ) ; alltraffic . add ( traffic ) ; updated . add ( traffic ) ; } } notifyupdated ( updated ) ; }	update all the traffic projections based on their heading and ground speed.
public static void logstacktrace ( level level , throwable throwable ) { logstacktrace ( level , throwable , null ) ; }	logs the stack trace for the given throwable if logger is initialized else prints the stack trace using system.
@ override public int read ( ) throws ioexception { int ch = super . read ( ) ; if ( ch != - _num ) { branch . write ( ch ) ; } return ch ; }	reads a single byte from the proxied input stream and writes it to the associated output stream .
public static string decodebcd ( final short bcd ) { return string . format ( _str , ( bcd & _num ) > > _num , bcd & _num ) ; }	decodes a binary - coded decimal into a string and returns it .
public void drawbackground ( graphics g ) { g . fillrect ( _num , _num , getwidth ( ) , getheight ( ) ) ; }	assume that the graphics has been set with the paint / color needed , just render the shape of the background .
public void put ( int key , int value ) { int i = binarysearch ( mkeys , _num , msize , key ) ; if ( i >= _num ) { mvalues [ i ] = value ; } else { i = ~ i ; if ( msize >= mkeys . length ) { int n = math . max ( msize + _num , mkeys . length * _num ) ; int [ ] nkeys = new int [ n ] ; int [ ] nvalues = new int [ n ] ; system . arraycopy ( mkeys , _num , nkeys , _num , mkeys . length ) ; system . arraycopy ( mvalues , _num , nvalues , _num , mvalues . length ) ; mkeys = nkeys ; mvalues = nvalues ; } if ( msize - i != _num ) { system . arraycopy ( mkeys , i , mkeys , i + _num , msize - i ) ; system . arraycopy ( mvalues , i , mvalues , i + _num , msize - i ) ; } mkeys [ i ] = key ; mvalues [ i ] = value ; msize ++ ; } }	adds a mapping from the specified key to the specified value , replacing the previous mapping from the specified key if there was one .
public void addlayouteditor ( layouteditor panel ) { if ( panels . size ( ) > _num ) { for ( int i = _num ; i < panels . size ( ) ; i ++ ) { layouteditor ed = panels . get ( i ) ; if ( ed == panel ) { return ; } } } panels . add ( panel ) ; }	keeps track of layouteditor panels that are using this layoutblock.
void triggerwildcardexpander ( final collection < file > allfiles , final wildcardcontext wildcardcontext ) throws ioexception { log . debug ( _str , allfiles ) ; if ( allfiles . isempty ( ) ) { final string message = string . format ( _str , wildcardcontext . getwildcard ( ) ) ; log . warn ( message ) ; throw new ioexception ( message ) ; } if ( wildcardexpanderhandler != null ) { try { wildcardexpanderhandler . apply ( allfiles ) ; } catch ( final ioexception e ) { throw e ; } catch ( final exception e ) { log . debug ( _str , e ) ; throw new ioexception ( _str + e . getmessage ( ) ) ; } } }	uses the wildcardexpanderhandler to process all found files and directories .
@ post @ consumes ( { mediatype . application_xml , mediatype . application_json } ) @ produces ( { mediatype . application_xml , mediatype . application_json } ) @ checkpermission ( roles = { role . tenant_admin } ) @ path ( _str ) public ipinterfacerestrep createipinterface ( @ pathparam ( _str ) uri id , ipinterfacecreateparam createparam ) throws databaseexception { host host = queryobject ( host . class , id , _bool ) ; validateipinterfacedata ( createparam , null ) ; ipinterface ipinterface = new ipinterface ( ) ; ipinterface . sethost ( host . getid ( ) ) ; ipinterface . setid ( uriutil . createid ( ipinterface . class ) ) ; populateipinterface ( createparam , ipinterface ) ; _dbclient . createobject ( ipinterface ) ; auditop ( operationtypeenum . create_host_ipinterface , _bool , null , ipinterface . auditparameters ( ) ) ; return map ( ipinterface ) ; }	creates a new ip interface for a host .
protected list < ieditproposal > collecteditproposals ( ) { list < ieditproposal > proposals = new arraylist < ieditproposal > ( ) ; view selectedview = getselectedview ( ) ; if ( selectedview != null ) { if ( proposalproviders != null ) { for ( ieditproposalprovider provider : proposalproviders ) { for ( ieditproposal editproposal : provider . getproposals ( selectedview ) ) { if ( editproposal . isapplicable ( ) ) proposals . add ( editproposal ) ; } } } } return proposals ; }	collects all edit proposals from contained poroposal providers .
public extensionquery ( string pluginid , string extensionpointname , string attributename ) { this . pluginid = extensionpointname . contains ( _str ) ? null : pluginid ; this . extensionpointname = extensionpointname ; this . attributename = attributename ; }	create a new instance .
private void ensurenamespaceexists ( result result ) { dockerimage image = dockerimage . fromimagename ( result . name ) ; if ( image . getnamespace ( ) == null ) { result . name = string . format ( _str , default_namespace , image . getrepository ( ) ) ; } }	ensures that an image name has a namespace prefix.
public static < k , v > map < k , v > of ( k k1 , v v1 , k k2 , v v2 , k k3 , v v3 , k k4 , v v4 , k k5 , v v5 ) { map map = of ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; map . put ( k3 , v3 ) ; map . put ( k4 , v4 ) ; map . put ( k5 , v5 ) ; return map ; }	returns map containing the given entries .
public void testfilteredclassifier ( ) { instances data ; int i ; if ( m_filteredclassifier == null ) { return ; } try { data = getfilteredclassifierdata ( ) ; m_filteredclassifier . buildclassifier ( data ) ; for ( i = _num ; i < data . numinstances ( ) ; i ++ ) { m_filteredclassifier . classifyinstance ( data . instance ( i ) ) ; } } catch ( exception e ) { fail ( _str + e . tostring ( ) ) ; } }	tests the filter in conjunction with the filteredclassifier.
public static string upperfirstchar ( string string ) { if ( string == null ) return null ; if ( string . length ( ) <= _num ) return string . tolowercase ( ) ; stringbuilder sb = new stringbuilder ( string ) ; sb . setcharat ( _num , character . touppercase ( sb . charat ( _num ) ) ) ; return sb . tostring ( ) ; }	changes the first letter of the passed string to upper case .
protected int chooserandomindexbasedonproportions ( double [ ] proportionarray , random random ) { double probsum ; double val ; int index ; double sum ; probsum = utils . sum ( proportionarray ) ; val = random . nextdouble ( ) * probsum ; index = _num ; sum = _num ; while ( ( sum <= val ) && ( index < proportionarray . length ) ) { sum += proportionarray [ index ++ ] ; } return index - _num ; }	returns a random index based on the given proportions.
private void checkwidth ( final int [ ] rect ) { final int x1 = rect [ _num ] ; final int y2 = rect [ _num ] ; final int y1 = y2 + rect [ _num ] ; final int x2 = x1 + rect [ _num ] ; if ( x1 < pagex1 ) { pagex1 = x1 ; } if ( x2 > pagex2 ) { pagex2 = x2 ; } if ( y1 > pagey1 ) { pagey1 = y1 ; } if ( y2 < pagey2 ) { pagey2 = y2 ; } }	track actual size of shape.
@ notnull public static map < radcomponent , list < radcomponent > > groupsiblings ( @ notnull list < ? extends radcomponent > components ) { map < radcomponent , list < radcomponent > > siblinglists = new hashmap < radcomponent , list < radcomponent > > ( ) ; if ( components . isempty ( ) ) { return siblinglists ; } if ( components . size ( ) == _num ) { radcomponent component = components . get ( _num ) ; siblinglists . put ( component . getparent ( ) , collections . singletonlist ( component ) ) ; return siblinglists ; } for ( radcomponent component : components ) { radcomponent parent = component . getparent ( ) ; list < radcomponent > children = siblinglists . get ( parent ) ; if ( children == null ) { children = new arraylist < radcomponent > ( ) ; siblinglists . put ( parent , children ) ; } children . add ( component ) ; } return siblinglists ; }	partitions the given list of components into a map where each value is a list of siblings , in the same order as in the original list , and where the keys are the parents ( or null for the components that do not have a parent ).
private int countnonnewline ( string str , int off , int len ) { for ( int cnt = _num ; cnt < len ; cnt ++ ) { final int pos = off + cnt ; if ( str . charat ( pos ) == unix_newline ) { return cnt ; } if ( str . charat ( pos ) == carriage_return ) { return cnt ; } } return len ; }	count the number of non - newline characters before first newline in the string .
private static int convertspantosparsegrid ( int curix , int span , treeset < integer > indexes ) { int lastix = curix + span ; int retspan = _num ; for ( integer ix : indexes ) { if ( ix <= curix ) continue ; if ( ix >= lastix ) break ; retspan ++ ; } return retspan ; }	spanning is specified in the uncompressed grid number.
@ override public boolean equals ( object otherrules ) { if ( this == otherrules ) { return _bool ; } if ( otherrules instanceof zonerules ) { zonerules other = ( zonerules ) otherrules ; return arrays . equals ( standardtransitions , other . standardtransitions ) && arrays . equals ( standardoffsets , other . standardoffsets ) && arrays . equals ( savingsinstanttransitions , other . savingsinstanttransitions ) && arrays . equals ( walloffsets , other . walloffsets ) && arrays . equals ( lastrules , other . lastrules ) ; } return _bool ; }	checks if this set of rules equals another.
public string description ( ) { stringbuilder sb = new stringbuilder ( ) ; if ( iscombo ( ) ) { int i = _num ; for ( newcomboleg leg : m_combolegs ) { if ( i ++ > _num ) { sb . append ( _str ) ; } sb . append ( leg . tostring ( ) ) ; } } else { sb . append ( m_symbol ) ; app ( sb , m_sectype ) ; app ( sb , m_exchange ) ; if ( m_exchange != null && m_exchange . equals ( _str ) && m_primaryexch != null ) { app ( sb , m_primaryexch ) ; } app ( sb , m_expiry ) ; if ( m_strike != _num ) { app ( sb , m_strike ) ; } if ( m_right != right . none ) { app ( sb , m_right ) ; } } return sb . tostring ( ) ; }	returns a text description that can be used for display .
public void addclaimedsignerrole ( final string claimedsignerrole ) { if ( ( claimedsignerrole == null ) || ( claimedsignerrole . length ( ) == _num ) ) { throw new nullpointerexception ( _str ) ; } if ( claimedsignerroles == null ) { claimedsignerroles = new arraylist < string > ( ) ; } claimedsignerroles . add ( claimedsignerrole ) ; }	adds a claimed signer role.
@ suppresswarnings ( _str ) @ gwtincompatible ( _str ) public static < k extends object , v extends object > void writemap ( map < k , v > map , objectoutputstream stream ) throws ioexception { stream . writeint ( map . size ( ) ) ; for ( map . entry < k , v > entry : map . entryset ( ) ) { stream . writeobject ( entry . getkey ( ) ) ; stream . writeobject ( entry . getvalue ( ) ) ; } }	stores the contents of a map in an output stream , as part of serialization.
protected void sleep ( int sleepmillis , int sleepnanos ) throws interruptedexception { thread . sleep ( sleepmillis , sleepnanos ) ; }	sub classes ( tests basically ) can use this to override how the sleep is being done.
public static void restorepreviousoutanderrstream ( ) { if ( ! alreadymuted ) { return ; } system . setout ( latestout ) ; system . seterr ( latesterr ) ; alreadymuted = _bool ; }	allow again printing to previous streams that were muted.
public static biginteger crt ( list < biginteger > congs , list < biginteger > moduli ) { biginteger [ ] cs = arrayconverter . convertlisttoarray ( congs ) ; biginteger [ ] ms = arrayconverter . convertlisttoarray ( moduli ) ; return crt ( cs , ms ) ; }	computes chinese reminder theorem : x = = congs [ i ] mod moduli [ i ].
private int measureheight ( int measurespec ) { int result = _num ; int specmode = measurespec . getmode ( measurespec ) ; int specsize = measurespec . getsize ( measurespec ) ; mascent = ( int ) mtextpaint . ascent ( ) ; if ( specmode == measurespec . exactly ) { result = specsize ; } else { result = ( int ) ( - mascent + mtextpaint . descent ( ) ) + getpaddingtop ( ) + getpaddingbottom ( ) ; if ( specmode == measurespec . at_most ) { result = math . min ( result , specsize ) ; } } return result ; }	determines the height of this view.
public bytevector putbytearray ( final byte [ ] b , final int off , final int len ) { if ( length + len > data . length ) { enlarge ( len ) ; } if ( b != null ) { system . arraycopy ( b , off , data , length , len ) ; } length += len ; return this ; }	puts an array of bytes into this byte vector.
protected < t extends taskservicedocument < e > , e extends enum < e > > t waitfortaskcompletion ( string documentselflink , class < t > type ) throws throwable { return waitforpropertyvalue ( documentselflink , type , taskservicedocument . field_name_task_stage , arrays . aslist ( taskstage . finished , taskstage . failed , taskstage . cancelled ) , _bool , waitforstagechangecountlonger ( ) ) ; }	waits until the given task completes and returns its final state .
public action ( string content , int priority ) { this . content = content . trim ( ) ; this . priority = priority ; }	creates a new action object with specified content and line number .
private list < endisland > findsurroundingislands ( int chunkx , int chunky , int chunksperfragmentx , int chunksperfragmenty ) { list < endisland > result = new linkedlist < endisland > ( ) ; for ( int y = - surrounding_chunks ; y <= chunksperfragmenty + surrounding_chunks ; y ++ ) { for ( int x = - surrounding_chunks ; x <= chunksperfragmentx + surrounding_chunks ; x ++ ) { endisland island = trycreateendisland ( chunkx + x , chunky + y ) ; if ( island != null ) { result . add ( island ) ; } } } return result ; }	returns a list of all islands that might be touching a chunk - area .
void insertfunction2 ( bytebuffer bb ) { int basesec = ( int ) ( windowid > > _num ) ; bb . putint ( basesec ) ; integer operid = operatorid ; for ( int i = _num ; i < _num ; i ++ ) { byte num = ( byte ) ( operid > > _num * ( _num - i ) ) ; bb . put ( num ) ; } bb . putshort ( ( short ) ( windowid & _num ) ) ; for ( int i = _num ; i < _num ; i ++ ) { byte num = ( byte ) ( tupleid > > _num * ( _num - i ) ) ; bb . put ( num ) ; } }	4b basesec | 3b operatorid | 2b windowid | 3b tupleid.
private static boolean calculategap ( rectangle a , rectangle b , rectangle gap ) { if ( a . intersects ( b ) ) { gap . width = _num ; return _bool ; } int ax1 = a . x ; int ax2 = a . x + a . width ; int ay1 = a . y ; int ay2 = a . y + a . height ; int bx1 = b . x ; int bx2 = b . x + b . width ; int by1 = b . y ; int by2 = b . y + b . height ; int xoverlap = math . min ( ax2 , bx2 ) - math . max ( ax1 , bx1 ) ; int yoverlap = math . min ( ay2 , by2 ) - math . max ( ay1 , by1 ) ; if ( xoverlap <= _num && yoverlap <= _num ) { gap . width = _num ; return _bool ; } if ( xoverlap > _num ) { gap . x = math . max ( ax1 , bx1 ) ; gap . y = ( ay1 > by1 ) ? by2 : ay2 ; gap . width = xoverlap ; gap . height = - yoverlap ; } if ( yoverlap > _num ) { gap . x = ( ax1 > bx1 ) ? bx2 : ax2 ; gap . y = math . max ( ay1 , by1 ) ; gap . width = - xoverlap ; gap . height = yoverlap ; } return _bool ; }	calculate the gap rectangle between two rectangles.
public boolean nexttile ( ) throws modelcontrolexception { boolean movedtorow = super . nexttile ( ) ; if ( movedtorow ) { curtile = gettileindex ( ) ; setdisplayfieldvalue ( txt_parent_index , parentidx ) ; setdisplayfieldvalue ( txt_choice , choices [ curtile ] ) ; setdisplayfieldvalue ( txt_index , integer . tostring ( curtile ) ) ; } return movedtorow ; }	moves the current tile position to the next available tile .
public boolean hasmyomerbooster ( ) { for ( mounted mequip : getmisc ( ) ) { misctype mtype = ( misctype ) mequip . gettype ( ) ; if ( mtype . hasflag ( misctype . f_masc ) && ! mequip . isinoperable ( ) ) { return _bool ; } } return _bool ; }	does this ba mount a myomer booster ?.
public static boolean isintentavailable ( context context , string action ) { final packagemanager packagemanager = context . getpackagemanager ( ) ; final intent intent = new intent ( action ) ; log . d ( mp_tag , _str + action ) ; list < resolveinfo > list = packagemanager . queryintentservices ( intent , packagemanager . match_default_only ) ; return list . size ( ) > _num ; }	indicates whether the specified action can be used as an intent.
@ knownfailure ( _str ) public void test_wrap_02 ( ) throws sslexception { string host = _str ; int port = _num ; bytebuffer bb = bytebuffer . allocate ( _num ) ; bytebuffer [ ] bba = { bytebuffer . allocate ( _num ) , bytebuffer . allocate ( _num ) , bytebuffer . allocate ( _num ) } ; sslengine sse = getengine ( host , port ) ; sse . setuseclientmode ( _bool ) ; try { sse . wrap ( bba , - _num , _num , bb ) ; fail ( _str ) ; } catch ( indexoutofboundsexception iobe ) { } try { sse . wrap ( bba , _num , - _num , bb ) ; fail ( _str ) ; } catch ( indexoutofboundsexception iobe ) { } try { sse . wrap ( bba , bba . length + _num , bba . length , bb ) ; fail ( _str ) ; } catch ( indexoutofboundsexception iobe ) { } try { sse . wrap ( bba , _num , bba . length + _num , bb ) ; fail ( _str ) ; } catch ( indexoutofboundsexception iobe ) { } }	javax . net . ssl . sslengine # wrap ( bytebuffer [ ] srcs , int offset , int length , bytebuffer dst ) exception case : indexoutofboundsexception should be thrown .
private void sendconnectrequest ( ) throws ioexception { int port = url . getport ( ) ; requests . set ( _num , http_connect + _str + connectrequesturi ( url ) + _str + httpversion , null ) ; requests . setifnotset ( _str , useragent ) ; string host = url . gethost ( ) ; if ( port != - _num && port != url . getdefaultport ( ) ) { host += _str + string . valueof ( port ) ; } requests . setifnotset ( _str , host ) ; requests . setifnotset ( _str , acceptstring ) ; if ( http . gethttpkeepaliveset ( ) ) { requests . setifnotset ( _str , _str ) ; } setpreemptiveproxyauthentication ( requests ) ; if ( logger . isloggable ( platformlogger . level . fine ) ) { logger . fine ( requests . tostring ( ) ) ; } http . writerequests ( requests , null ) ; }	send a connect request for establishing a tunnel to proxy server.
private boolean isselfsigned ( x509certificate cert ) { return signedby ( cert , cert ) ; }	returns true if the certificate is self - signed , false otherwise .
@ requestmapping ( value = { _str , _str } , method = requestmethod . put ) @ responsebody public restwrapper insert ( @ modelattribute ( _str ) @ valid userroles userroles , bindingresult bindingresult , principal principal ) { restwrapper restwrapper = null ; if ( bindingresult . haserrors ( ) ) { bindingresulterror bindingresulterror = new bindingresulterror ( ) ; return bindingresulterror . errormessage ( bindingresult ) ; } try { com . wipro . ats . bdre . md . dao . jpa . userroles jpauserroles = new com . wipro . ats . bdre . md . dao . jpa . userroles ( ) ; jpauserroles . setuserroleid ( userroles . getuserroleid ( ) ) ; jpauserroles . setrole ( userroles . getrole ( ) ) ; users users = new users ( ) ; users . setusername ( userroles . getusername ( ) ) ; jpauserroles . setusers ( users ) ; integer userrolesid = userrolesdao . insert ( jpauserroles ) ; userroles . setuserroleid ( userrolesid ) ; restwrapper = new restwrapper ( userroles , restwrapper . ok ) ; logger . info ( _str + userroles . getuserroleid ( ) + _str + principal . getname ( ) + userroles ) ; } catch ( exception e ) { logger . error ( e ) ; restwrapper = new restwrapper ( e . getmessage ( ) , restwrapper . error ) ; } return restwrapper ; }	this method calls proc insertuserroles and adds a record in userroles table.
public set < wordtoken > nearestwords ( final int distance , final wordtoken ... start ) { return nearestwords ( distance , null , arrays . aslist ( start ) ) ; }	find the nearest neighbours within dependency distance links of the provided start dependencies .
public derutctime ( date time ) { simpledateformat datef = new simpledateformat ( _str ) ; datef . settimezone ( new simpletimezone ( _num , _str ) ) ; this . time = strings . tobytearray ( datef . format ( time ) ) ; }	base constructer from a java.
public void add ( string category , string [ ] titles , double [ ] values ) { mcategories . add ( category ) ; mtitles . add ( titles ) ; mvalues . add ( values ) ; }	adds a new value to the series .
public void rewind ( ) { synchronized ( used ) { for ( parameterpair pair : used ) { current . addparameter ( pair . option , pair . value ) ; } used . clear ( ) ; } }	rewind the configuration to the initial situation.
public list < interval > merge ( list < interval > intervals ) { list < interval > res = new arraylist < > ( ) ; if ( intervals == null || intervals . size ( ) == _num ) { return res ; } collections . sort ( intervals , null ) ; interval prev = null ; for ( interval i : intervals ) { if ( prev == null || prev . end < i . start ) { res . add ( i ) ; prev = i ; } else if ( i . end > prev . end ) { prev . end = i . end ; } } return res ; }	sort and merge , o ( nlogn ) time.
private string formattype ( object typerep ) { stringtokenizer tokenizer = new stringtokenizer ( typerep . tostring ( ) , _str , _bool ) ; stringbuilder sb = new stringbuilder ( ) ; while ( tokenizer . hasmoretokens ( ) ) { string token = tokenizer . nexttoken ( ) ; if ( token . length ( ) == _num || token . lastindexof ( _str ) == - _num ) sb . append ( token ) ; else { int index = token . lastindexof ( _str ) ; sb . append ( token . substring ( index + _num ) ) ; } } return sb . tostring ( ) ; }	outputs the simple name of the type.
@ notnull public static string sha1 ( @ notnull file keystorefile ) throws exception { return sha1 ( keystorefile , null , null ) ; }	get the sha1 hash of the first signing certificate inside a keystore , encoded as base16 ( each byte separated by ' : ' ) .
@ override public void pandomainaxes ( double panrange , plotrenderinginfo info , point2d source ) { xyplot subplot = findsubplot ( info , source ) ; if ( subplot == null ) { return ; } if ( ! subplot . isdomainpannable ( ) ) { return ; } plotrenderinginfo subplotinfo = info . getsubplotinfo ( info . getsubplotindex ( source ) ) ; if ( subplotinfo == null ) { return ; } for ( int i = _num ; i < subplot . getdomainaxiscount ( ) ; i ++ ) { valueaxis domainaxis = subplot . getdomainaxis ( i ) ; if ( domainaxis != null ) { domainaxis . pan ( panrange ) ; } } }	pans all domain axes by the specified percentage .
private void init ( ) { startcontroller = new pourstartcontroller ( ) ; startcontroller . setcheckview ( this ) ; wavecontroller = new wavecontroller ( ) ; wavecontroller . setcheckview ( this ) ; pourfinishcontroller finishcontroller = new pourfinishcontroller ( ) ; finishcontroller . setcheckview ( this ) ; tickcontroller tickcontroller = new tickcontroller ( ) ; tickcontroller . setcheckview ( this ) ; list < basecontroller > finishcontrollers = new arraylist < > ( ) ; finishcontrollers . add ( finishcontroller ) ; finishcontrollers . add ( tickcontroller ) ; this . finishcontrollers = finishcontrollers ; }	basic animations to build the liquidbutton.
private jlabel createiconlabel ( jcheckbox checkbox ) { checkbox . setopaque ( _bool ) ; checkbox . setsize ( checkbox . getminimumsize ( ) ) ; image image = new bufferedimage ( checkbox . getwidth ( ) , checkbox . getheight ( ) , transparency . translucent ) ; graphics g = image . getgraphics ( ) ; checkbox . paint ( g ) ; g . dispose ( ) ; return new jlabel ( new imageicon ( image ) ) ; }	creates an image of the checkbox and puts it in a label .
public void closewindow ( ) { windowevent ev = new windowevent ( frame , windowevent . window_closing ) ; frame . dispatchevent ( ev ) ; }	closes the window ( and opendial ) .
public void enginedeleteentry ( string alias ) throws keystoreexception { synchronized ( entries ) { entries . remove ( alias . tolowercase ( locale . english ) ) ; } }	deletes the entry identified by the given alias from this keystore .
public disjointsets ( int numelements ) { array = new int [ numelements ] ; arrays . fill ( array , - _num ) ; }	construct a disjoint sets object .
public final void printclusters ( printwriter out , list < clusterdata > clusterdata , int [ ] matindextomsginternalid ) throws adeexception { if ( m_finalclusters == null ) { updateclusters ( clusterdata , matindextomsginternalid ) ; } for ( map . entry < string , collection < integer > > entry : m_finalclusters . entryset ( ) ) { final string n = entry . getkey ( ) ; final collection < integer > c = entry . getvalue ( ) ; out . printf ( _str , n ) ; for ( int m : c ) { out . printf ( _str , matindextomsginternalid [ m ] ) ; } out . println ( ) ; } }	prints out the cluster information .
protected void addtogui ( jpanel gui , jtextfield b , string cmd ) { b . setactioncommand ( cmd ) ; b . addactionlistener ( this ) ; gui . add ( b ) ; }	adds a feature to the gui attribute of the e00layer object.
public synchronized void remove ( int index ) { mcategories . remove ( index ) ; mvalues . remove ( index ) ; }	removes an existing value from the series .
static tokenstream wrap ( string fieldname , analyzer indexanalyzer , string content , char splitchar ) throws ioexception { if ( indexanalyzer . getoffsetgap ( fieldname ) != _num ) { throw new illegalargumentexception ( _str + fieldname + _str ) ; } int splitcharidx = content . indexof ( splitchar ) ; if ( splitcharidx == - _num ) { return indexanalyzer . tokenstream ( fieldname , content ) ; } tokenstream subtokenstream = indexanalyzer . tokenstream ( fieldname , content . substring ( _num , splitcharidx ) ) ; return new multivaluetokenstream ( subtokenstream , fieldname , indexanalyzer , content , splitchar , splitcharidx ) ; }	note : the caller must remember to close the tokenstream eventually .
public final boolean check_trace ( polyline p_polyline , int p_half_width , int p_layer , netnoslist p_net_no_arr , int p_clearance_class_no , int p_max_recursion_depth , int p_max_via_recursion_depth , int p_max_spring_over_recursion_depth ) { awtreeshapesearch search_tree = search_tree_manager . get_default_tree ( ) ; int compensated_half_width = p_half_width + search_tree . get_clearance_compensation ( p_clearance_class_no , p_layer ) ; arraylist < shapetile > trace_shapes = p_polyline . offset_shapes ( compensated_half_width , _num , p_polyline . corner_count ( ) ) ; for ( int index = _num ; index < trace_shapes . size ( ) ; ++ index ) { shapetile curr_trace_shape = trace_shapes . get ( index ) ; brdfromside from_side = new brdfromside ( p_polyline , index + _num , curr_trace_shape ) ; boolean check_shove_ok = shove_trace_algo . shove_trace_check ( curr_trace_shape , from_side , null , p_layer , p_net_no_arr , p_clearance_class_no , p_max_recursion_depth , p_max_via_recursion_depth , p_max_spring_over_recursion_depth , null ) ; if ( ! check_shove_ok ) return _bool ; } return _bool ; }	checks , if a trace polyline with the input parameters can be inserted while shoving aside obstacle traces and vias .
public static void delete ( file fileorfolder ) throws ioexception { if ( fileorfolder != null ) delete ( fileorfolder . topath ( ) ) ; }	a method that will delete a file or folder.
public static double [ ] expandarrayd ( int buffersize , double [ ] currentarray ) { if ( currentarray == null ) { return new double [ buffersize * _num ] ; } int length = currentarray . length ; double [ ] ret = new double [ length + buffersize * _num ] ; system . arraycopy ( currentarray , _num , ret , _num , length ) ; return ret ; }	create an array to hold double data for 3d polygons and lines .
protected int encode ( double value , double lower , double upper , int nbits ) { if ( value < lower ) return _num ; int maxval = ( int ) ( math . pow ( _num , nbits ) - _num ) ; if ( value >= upper ) return maxval ; return ( int ) ( ( value - lower ) * ( ( maxval - _num ) / ( upper - lower ) ) ) ; }	encode value as an nbits unsigned integer.
public long skipbytes ( long n ) throws ioexception { long count = _num ; long gotsofar = _num ; if ( inputstream == null ) { reopen ( ) ; if ( inputstream == null ) { reopen ( ) ; throw new ioexception ( _str ) ; } } while ( count < n ) { gotsofar = inputstream . skip ( n - count ) ; if ( gotsofar == _num ) { debug . error ( _str + n + _str ) ; break ; } count += gotsofar ; } count ( ( int ) count ) ; return count ; }	skip over n bytes in the input file.
private void createlock ( ) throws ioexception { synchronized ( lockablefilewriter . class ) { if ( ! lockfile . createnewfile ( ) ) { throw new ioexception ( _str + lockfile . getabsolutepath ( ) + _str ) ; } lockfile . deleteonexit ( ) ; } }	creates the lock file .
public void handletbldsattributemaplisthrefactionrequest ( requestinvocationevent event ) throws modelcontrolexception { try { map values = getvalues ( ) ; onbeforesaveprofile ( values ) ; setpagesessionattribute ( property_attribute , ( hashmap ) values ) ; wsppservicedsattributemaplisteditviewbean vb = ( wsppservicedsattributemaplisteditviewbean ) getviewbean ( wsppservicedsattributemaplisteditviewbean . class ) ; unlockpagetrail ( ) ; passpgsessionmap ( vb ) ; vb . populatevalues ( ( string ) getdisplayfieldvalue ( _str ) ) ; vb . forwardto ( getrequestcontext ( ) ) ; } catch ( amconsoleexception e ) { setinlinealertmessage ( ccalert . type_error , _str , e . getmessage ( ) ) ; forwardto ( ) ; } }	handles edit ldap attribute mapping request .
private v doget ( object key ) { if ( key == null ) throw new nullpointerexception ( ) ; comparator < ? super k > cmp = comparator ; outer : for ( ; ; ) { for ( node < k , v > b = findpredecessor ( key , cmp ) , n = b . next ; ; ) { object v ; int c ; if ( n == null ) break outer ; node < k , v > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . helpdelete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( ( c = cpr ( cmp , key , n . key ) ) == _num ) { @ suppresswarnings ( _str ) v vv = ( v ) v ; return vv ; } if ( c < _num ) break outer ; b = n ; n = f ; } } return null ; }	gets value for key . almost the same as findnode , but returns the found value ( to avoid retries during re - reads ).
void handleswfloadedevent ( swfloadedevent e ) { dumpswfloadedline ( e ) ; }	called when a swf has been loaded by the player.
private void quickreply ( ) { quickreplysmsmessage = smspopuppager . getactivemessage ( ) ; quickreply ( quickreplysmsmessage . getreplytext ( ) ) ; }	show the quick reply dialog , resetting the text in the edittext and storing the current smsmmsmessage ( in case another message comes in ).
@ override protected synchronized void write ( long offset , byte [ ] b ) throws ioexception { if ( bytebuffer != null ) { bytebuffer . position ( ( int ) offset ) ; bytebuffer . put ( b ) ; } else { throw new ioexception ( _str + getpath ( ) + _str ) ; } }	writes bytes to the underlying rrd file on the disk.
public boolean haschanged ( ) { return system . identityhashcode ( config ) != initialhash ; }	checks if the config has changed since it was loaded .
void fixcompatibility ( view root ) { queue < view > queue = new linkedlist < view > ( ) ; queue . add ( root ) ; view view = null ; while ( ( view = queue . poll ( ) ) != null ) { if ( view instanceof viewgroup ) { viewgroup group = ( viewgroup ) view ; for ( int i = _num ; i < group . getchildcount ( ) ; i ++ ) { queue . add ( group . getchildat ( i ) ) ; } } } }	iterate through each view in the view hiearchy and implement standout specific compatibility workarounds.
protected abstract set < socketaddress > bindinternal ( list < ? extends socketaddress > localaddresses ) throws exception ;	starts the acceptor , and register the given addresses.
public void substituteheader ( int state , string header ) throws authloginexception { if ( debug . messageenabled ( ) ) { debug . message ( _str + state + _str + header ) ; } if ( state > statelength ) { throw new authloginexception ( bundlename , _str , new object [ ] { new integer ( state ) } ) ; } callback [ ] ext = getcallback ( state ) ; if ( ext . length <= _num ) { throw new authloginexception ( bundlename , _str , null ) ; } if ( ( header != null ) && ( header . length ( ) != _num ) ) { pagepropertiescallback pc = ( pagepropertiescallback ) ( ( callback [ ] ) internal . get ( state - _num ) ) [ _num ] ; pc . setheader ( header ) ; } }	use this method to replace the header text from the xml file with new text.
public static service createservice ( patterntimetable timetable ) { calendar calendar = new calendar ( ) ; calendar . monday = timetable . monday ? _num : _num ; calendar . tuesday = timetable . tuesday ? _num : _num ; calendar . wednesday = timetable . wednesday ? _num : _num ; calendar . thursday = timetable . thursday ? _num : _num ; calendar . friday = timetable . friday ? _num : _num ; calendar . saturday = timetable . saturday ? _num : _num ; calendar . sunday = timetable . sunday ? _num : _num ; stringbuilder namebuilder = new stringbuilder ( _str ) ; namebuilder . append ( timetable . monday ? _str : _str ) ; namebuilder . append ( timetable . monday ? _str : _str ) ; namebuilder . append ( timetable . monday ? _str : _str ) ; namebuilder . append ( timetable . monday ? _str : _str ) ; namebuilder . append ( timetable . monday ? _str : _str ) ; namebuilder . append ( timetable . monday ? _str : _str ) ; namebuilder . append ( timetable . monday ? _str : _str ) ; service service = new service ( namebuilder . tostring ( ) ) ; calendar . start_date = _num ; calendar . end_date = _num ; service . calendar = calendar ; return service ; }	creates a gtfs - lib service object based on the information in the given patterntimetable , which is usually part of a modification deserialized from json .
public boolean remove ( imageinfo object ) { final int location = getlocation ( object ) ; final boolean removed = data . remove ( object ) ; notifyitemremoved ( location ) ; return removed ; }	removes the first occurrence of the specified object from the data .
public t allowedusers ( user ... users ) { list < user > userslist = arrays . aslist ( users ) ; this . userpredicate = null ; return instance ( ) ; }	allow a list of users to use this menu.
vplexdistributeddeviceinfo finddistributeddevice ( string devicename ) throws vplexapiexception { return finddistributeddevice ( devicename , _bool ) ; }	finds the distributed device with the passed name .
static copystate readcopystate ( datainput in ) throws ioexception { byte [ ] infosbytes = new byte [ in . readvint ( ) ] ; in . readbytes ( infosbytes , _num , infosbytes . length ) ; long gen = in . readvlong ( ) ; long version = in . readvlong ( ) ; map < string , filemetadata > files = readfilesmetadata ( in ) ; int count = in . readvint ( ) ; set < string > completedmergefiles = new hashset < > ( ) ; for ( int i = _num ; i < count ; i ++ ) { completedmergefiles . add ( in . readstring ( ) ) ; } long primarygen = in . readvlong ( ) ; return new copystate ( files , version , gen , infosbytes , completedmergefiles , primarygen , null ) ; }	pulls copystate off the wire.
public void notifytasks ( ) { if ( tracker . shouldinterrupttask ( ) ) { for ( thread t : threadmap . values ( ) ) { t . interrupt ( ) ; } } }	interrupts currently running tasks .
public requestparams ( object ... keysandvalues ) { int len = keysandvalues . length ; if ( len % _num != _num ) throw new illegalargumentexception ( _str ) ; for ( int i = _num ; i < len ; i += _num ) { string key = string . valueof ( keysandvalues [ i ] ) ; string val = string . valueof ( keysandvalues [ i + _num ] ) ; put ( key , val ) ; } }	constructs a new requestparams instance and populate it with multiple initial key / value string param .
public boolean confirmoverwrite ( final file file ) { string message = _str + file . getname ( ) + _str ; object [ ] options = { _str , _str } ; return joptionpane . yes_option == joptionpane . showoptiondialog ( null , message , _str , joptionpane . default_option , joptionpane . warning_message , null , options , options [ _num ] ) ; }	ask user whether to overwrite the give existing file .
public tvshowupdatedatasourcetask ( string datasource ) { super ( bundle . getstring ( _str ) + _str + datasource + _str ) ; tvshowlist = tvshowlist . getinstance ( ) ; datasources = new arraylist < > ( _num ) ; datasources . add ( datasource ) ; }	instantiates a new scrape task - to update a single datasource.
public int findline ( int offset ) { int line = linestarts . length - _num ; while ( ( linestarts [ line ] > offset ) && ( line > _num ) ) { line -- ; } return line ; }	line in the original source file for the given offset .
public void clear ( ) { set < sensor > oldselection = new hashset < sensor > ( selection ) ; selection . clear ( ) ; if ( ! oldselection . isempty ( ) ) { fireselectionchanged ( oldselection , selection ) ; } }	clear this sensor selection model .
public object newnonmovablearray ( class < ? > componenttype , int length ) { return array . newinstance ( componenttype , length ) ; }	returns an array allocated in an area of the java heap where it will never be moved.
private void loadfilerecursively ( string path , map < string , thriftfileelement > loadedfiles ) throws ioexception { thriftfileelement element = null ; file dir = null ; file file = findfirstexisting ( path , null ) ; if ( file != null ) { file = file . getcanonicalfile ( ) ; if ( loadedfiles . containskey ( file . getabsolutepath ( ) ) ) { return ; } dir = file . getparentfile ( ) ; element = loadsinglefile ( file . getparentfile ( ) , file . getname ( ) ) ; } if ( element == null ) { throw new filenotfoundexception ( _str + path + _str + includepaths ) ; } loadedfiles . put ( file . getabsolutepath ( ) , element ) ; immutablelist < includeelement > includes = element . includes ( ) ; if ( includes . size ( ) > _num ) { includepaths . addfirst ( dir ) ; for ( includeelement include : includes ) { if ( ! include . iscpp ( ) ) { loadfilerecursively ( include . path ( ) , loadedfiles ) ; } } includepaths . removefirst ( ) ; } }	loads and parses a thrift file and all files included ( both directly and transitively ) by it .
public void assureproxyok ( ) { if ( socket . isclosed ( ) ) { restart ( ) ; } }	assure that proxy is in a stable status .
@ override public boolean add ( imessage message ) { return add ( message , _bool ) ; }	this adds a message object to the internal message cache .
public key ( byte [ ] hash ) { if ( hash . length != sha1_hash_length ) { throw new illegalargumentexception ( _str + hash . length ) ; } system . arraycopy ( hash , _num , this . hash , _num , sha1_hash_length ) ; }	creates a key with this hash.
public static int [ ] concatallint ( int [ ] ... arrays ) { int totallength = _num ; final int subarraycount = arrays . length ; for ( int i = _num ; i < subarraycount ; ++ i ) { totallength += arrays [ i ] . length ; } int [ ] result = arrays . copyof ( arrays [ _num ] , totallength ) ; int offset = arrays [ _num ] . length ; for ( int i = _num ; i < subarraycount ; ++ i ) { system . arraycopy ( arrays [ i ] , _num , result , offset , arrays [ i ] . length ) ; offset += arrays [ i ] . length ; } return result ; }	concatenates a list of int arrays into a single array .
private static roadpermission roadflagcomparision ( way iosmway , string newtag , string newvalue , enumset < edgestore . edgeflag > forwardexpected , enumset < edgestore . edgeflag > backwardexpected ) { way osmway = new way ( ) ; stringjoiner stringjoiner = new stringjoiner ( _str ) ; for ( osmentity . tag tag : iosmway . tags ) { osmway . addtag ( tag . key , tag . value ) ; stringjoiner . add ( tag . key + _str + tag . value ) ; } if ( newtag != null && newvalue != null ) { osmway . addtag ( newtag , newvalue ) ; stringjoiner . add ( newtag + _str + newvalue ) ; } set < edgestore . edgeflag > forwardfiltered ; set < edgestore . edgeflag > backwardfiltered ; roadpermission roadpermission = traversalpermissionlabeler . getpermissions ( osmway ) ; forwardfiltered = filterflags ( roadpermission . forward ) ; backwardfiltered = filterflags ( roadpermission . backward ) ; string tags = _str + stringjoiner . tostring ( ) ; assertequals ( tags , forwardexpected , forwardfiltered ) ; assertequals ( tags , backwardexpected , backwardfiltered ) ; return roadpermission ; }	makes comparision of way with osmway tags and newtag with newvalue and compares forward and backward permissions with expected permissions copy of osmway is made since otherwise tags would be changed.
public byte [ ] readbytes ( ) throws ioexception { int len = readint ( ) ; if ( len == - _num ) { return null ; } byte [ ] b = datautils . newbytes ( len ) ; in . readfully ( b ) ; return b ; }	read a byte array .
protected int chunksize ( int n ) { int power = ( n == _num || n == _num ) ? initialchunkpower : math . min ( initialchunkpower + n - _num , abstractspinedbuffer . max_chunk_power ) ; return _num << power ; }	how big should the nth chunk be ?.
public string userelativepathtiptext ( ) { return _str ; }	tip text suitable for displaying int the gui.
public joiner join ( class < ? extends dataobject > clazz , string alias , uri ... ids ) { return join ( clazz , alias , new arraylist < uri > ( arrays . aslist ( ids ) ) ) ; }	starts a new query not related to a previous class query .
public void closefile ( ) { closefile ( _bool ) ; }	closes the current tab.
public list < interface > showinterface ( ) throws networkdevicecontrollerexception { list < interface > interfaces = new arraylist < interface > ( ) ; sshprompt [ ] prompts = { sshprompt . pound , sshprompt . greater_than } ; stringbuilder buf = new stringbuilder ( ) ; sshprompt prompt = sendwaitfor ( mdsdialogproperties . getstring ( _str ) , _num , prompts , buf ) ; string [ ] lines = getlines ( buf ) ; string [ ] regex = { mdsdialogproperties . getstring ( _str ) , mdsdialogproperties . getstring ( _str ) , mdsdialogproperties . getstring ( _str ) , mdsdialogproperties . getstring ( _str ) , mdsdialogproperties . getstring ( _str ) , mdsdialogproperties . getstring ( _str ) } ; string [ ] groups = new string [ _num ] ; interface intf = null ; for ( string line : lines ) { int index = match ( line , regex , groups ) ; switch ( index ) { case _num : intf = new interface ( groups [ _num ] ) ; intf . setstatus ( groups [ _num ] ) ; interfaces . add ( intf ) ; break ; case _num : intf . setdescription ( groups [ _num ] ) ; break ; case _num : intf . setwwpn ( groups [ _num ] ) ; break ; case _num : intf . setmode ( groups [ _num ] ) ; intf . setfcid ( groups [ _num ] ) ; break ; case _num : intf . setvsan ( groups [ _num ] ) ; break ; case _num : intf . setmode ( groups [ _num ] ) ; break ; } } return interfaces ; }	issues the " show interface " command and collects in information into a list of interfaces.
protected void cleardatalists ( int obdservice ) { switch ( obdservice ) { case obd_svc_data : case obd_svc_freezeframe : pidsupported . clear ( ) ; pidpvs . clear ( ) ; break ; case obd_svc_read_codes : case obd_svc_pendingcodes : case obd_svc_permacodes : tcodes . clear ( ) ; break ; case obd_svc_veh_info : pidsupported . clear ( ) ; vidpvs . clear ( ) ; break ; } }	clear data lists for selected service.
public quadedge makeedge ( vertex o , vertex d ) { quadedge q = quadedge . makeedge ( o , d ) ; quadedges . add ( q ) ; return q ; }	creates a new quadedge , recording it in the edges list .
public static void sortseqs ( list < string > seqs ) { collections . sort ( seqs , null ) ; }	sort n string sequence list .
default b with ( string key , long value ) { return with ( key , long . tostring ( value ) ) ; }	associate the given value with the specified key .
private void listdirectory ( file directory , relativedirectory subdirectory , set < javafileobject . kind > filekinds , boolean recurse , listbuffer < javafileobject > resultlist ) { file d = subdirectory . getfile ( directory ) ; if ( ! casemapcheck ( d , subdirectory ) ) return ; file [ ] files = d . listfiles ( ) ; if ( files == null ) return ; if ( sortfiles != null ) arrays . sort ( files , sortfiles ) ; for ( file f : files ) { string fname = f . getname ( ) ; if ( f . isdirectory ( ) ) { if ( recurse && sourceversion . isidentifier ( fname ) ) { listdirectory ( directory , new relativedirectory ( subdirectory , fname ) , filekinds , recurse , resultlist ) ; } } else { if ( isvalidfile ( fname , filekinds ) ) { javafileobject fe = new regularfileobject ( this , fname , new file ( d , fname ) ) ; resultlist . append ( fe ) ; } } } }	insert all files in subdirectory subdirectory of directory directory which match filekinds into resultlist.
private shape decodeedge ( int width , int height ) { path . reset ( ) ; path . moveto ( width - _num , _num ) ; path . lineto ( width - _num , height - _num ) ; path . lineto ( width - _num , height - _num ) ; path . lineto ( _num , height - _num ) ; return path ; }	create the button edge shape .
public void dispose ( ) throws iabasyncinprogressexception { synchronized ( masyncinprogresslock ) { if ( masyncinprogress ) { throw new iabasyncinprogressexception ( _str + _str + masyncoperation + _str ) ; } } logdebug ( _str ) ; msetupdone = _bool ; if ( mserviceconn != null ) { logdebug ( _str ) ; if ( mcontext != null ) mcontext . unbindservice ( mserviceconn ) ; } mdisposed = _bool ; mcontext = null ; mserviceconn = null ; mservice = null ; mpurchaselistener = null ; }	dispose of object , releasing resources.
private void testscenario ( string aconfiguration , boolean anexpectinganexception , list < method > amethodstocall ) throws exception { if ( amethodstocall . isempty ( ) ) { testscenario ( aconfiguration , anexpectinganexception , ( method ) null ) ; } else { for ( method mymethod : amethodstocall ) { testscenario ( aconfiguration , anexpectinganexception , mymethod ) ; } } }	load an element with default configuration and call tostring.
private static file createreservediskcachedir ( context context ) { file cachedir = storageutils . getcachedirectory ( context , _bool ) ; file individualdir = new file ( cachedir , _str ) ; if ( individualdir . exists ( ) || individualdir . mkdir ( ) ) { cachedir = individualdir ; } return cachedir ; }	creates reserve disk cache folder which will be used if primary disk cache folder becomes unavailable.
public boolean hasbeencalled ( string resourcename ) { return uris . contains ( resourcename ) ; }	checks if a resource has been requested using the short name of the resource .
@ override public void readexternal ( objectinput in ) throws ioexception , classnotfoundexception { super . readexternal ( in ) ; isleaf = in . readboolean ( ) ; numentries = in . readint ( ) ; }	reads the id of this node , the numentries and the entries array from the specified stream .
public objidmap ( ) { this ( _num , _num ) ; }	creates a new , empty map with the default initial capacity ( 11 buckets ) and load factor ( 0.
public criteria or ( ) { criteria criteria = createcriteriainternal ( ) ; oredcriteria . add ( criteria ) ; return criteria ; }	this method was generated by mybatis generator . this method corresponds to the database table company.
public static connectionfactory newfailoverconnectionpool ( set < ldapurl > servers , string username , char [ ] password , int maxsize , int heartbeatinterval , string heartbeattimeunit , options ldapoptions ) { list < connectionfactory > factories = new arraylist < connectionfactory > ( servers . size ( ) ) ; for ( ldapurl ldapurl : servers ) { connectionfactory cf = connections . newfixedconnectionpool ( newconnectionfactory ( ldapurl , username , password , heartbeatinterval , heartbeattimeunit , ldapoptions ) , maxsize ) ; factories . add ( cf ) ; } return loadbalancefactories ( factories ) ; }	creates a new connection pool that is capable to failover to the servers defined in case there is an error .
public printfformat ( final string fmtarg ) throws illegalargumentexception { this ( locale . getdefault ( ) , fmtarg ) ; }	constructs an array of control specifications possibly preceded , separated , or followed by ordinary strings.
public static void initcause ( throwable throwable , throwable cause ) { if ( init_cause_method != null ) { try { init_cause_method . invoke ( throwable , new object [ ] { cause } ) ; } catch ( exception e ) { } } }	if we ' re running on jdk 1.
public messagepropertykey ( string description , integer ordinal ) { this . description = description ; this . ordinal = ordinal ; }	creates a parameterized instance .
private node addwaiter ( node mode ) { node node = new node ( thread . currentthread ( ) , mode ) ; node pred = tail ; if ( pred != null ) { node . prev = pred ; if ( compareandsettail ( pred , node ) ) { pred . next = node ; return node ; } } enq ( node ) ; return node ; }	creates and enqueues node for current thread and given mode .
private void assertbounded ( sortedset < string > deserialized , boolean bounded ) { if ( bounded ) { try { deserialized . add ( _str ) ; fail ( ) ; } catch ( illegalargumentexception expected ) { } } else { asserttrue ( deserialized . add ( _str ) ) ; asserttrue ( deserialized . remove ( _str ) ) ; } }	regrettably , serializing a treeset causes it to forget its bounds.
public void paintborder ( component c , graphics g , int x , int y , int width , int height ) { jcomponent comp = ( c instanceof jcomponent ) ? ( jcomponent ) c : null ; if ( g instanceof graphics2d ) { graphics2d g2 = ( graphics2d ) g ; g2 . translate ( x , y ) ; paint ( g2 , comp , width , height ) ; g2 . translate ( - x , - y ) ; } else { bufferedimage img = new bufferedimage ( img_size , img_size , bufferedimage . type_int_argb ) ; graphics2d g2 = ( graphics2d ) img . getgraphics ( ) ; paint ( g2 , comp , width , height ) ; g2 . dispose ( ) ; imagescalinghelper . paint ( g , x , y , width , height , img , insets , insets , imagescalinghelper . painttype . paint9_stretch , imagescalinghelper . paint_all ) ; } }	paints the border for the specified component with the specified position and size .
@ suppresswarnings ( { _str , _str } ) public static linebylinefileinputoperator restorecheckpoint ( linebylinefileinputoperator checkpointoper , bytearrayoutputstream bos ) throws exception { kryo kryo = new kryo ( ) ; input linput = new input ( bos . tobytearray ( ) ) ; linebylinefileinputoperator oper = kryo . readobject ( linput , checkpointoper . getclass ( ) ) ; linput . close ( ) ; return oper ; }	restores the checkpointed operator .
private static byte [ ] readclass ( final inputstream is , boolean close ) throws ioexception { if ( is == null ) { throw new ioexception ( _str ) ; } try { byte [ ] b = new byte [ is . available ( ) ] ; int len = _num ; while ( _bool ) { int n = is . read ( b , len , b . length - len ) ; if ( n == - _num ) { if ( len < b . length ) { byte [ ] c = new byte [ len ] ; system . arraycopy ( b , _num , c , _num , len ) ; b = c ; } return b ; } len += n ; if ( len == b . length ) { int last = is . read ( ) ; if ( last < _num ) { return b ; } byte [ ] c = new byte [ b . length + _num ] ; system . arraycopy ( b , _num , c , _num , len ) ; c [ len ++ ] = ( byte ) last ; b = c ; } } } finally { if ( close ) { is . close ( ) ; } } }	reads the bytecode of a class .
private static synchronized boolean issupportedimpl ( httpcallerinfo hci ) { if ( supported == null ) { supported = new hashmap < string , boolean > ( ) ; cache = new hashmap < string , negotiator > ( ) ; } string hostname = hci . host ; hostname = hostname . tolowercase ( ) ; if ( supported . containskey ( hostname ) ) { return supported . get ( hostname ) ; } negotiator neg = negotiator . getnegotiator ( hci ) ; if ( neg != null ) { supported . put ( hostname , _bool ) ; cache . put ( hostname , neg ) ; return _bool ; } else { supported . put ( hostname , _bool ) ; return _bool ; } }	find out if the httpcallerinfo supports negotiate protocol.
public cprojectconfiguration ( final inaviproject project , final listenerprovider < iprojectlistener > listeners , final sqlprovider provider , final int projectid , final string name , final string description , final date creationdate , final date modificationdate , final list < debuggertemplate > assigneddebuggers ) { m_project = project ; m_listeners = listeners ; m_provider = provider ; m_id = projectid ; m_name = name ; m_description = description ; m_creationdate = new date ( creationdate . gettime ( ) ) ; m_modificationdate = new date ( modificationdate . gettime ( ) ) ; m_assigneddebuggers = new arraylist < debuggertemplate > ( assigneddebuggers ) ; }	creates a new configuration object .
public shape charttoscreenshape ( shape s ) { generalpath p = new generalpath ( ) ; transform inverse = transform . maketranslation ( getabsolutex ( ) , getabsolutey ( ) ) ; if ( currenttransform != null ) { inverse . concatenate ( currenttransform ) ; } p . append ( s . getpathiterator ( inverse ) , _bool ) ; return p ; }	converts a screen coordinate spaced shape to the same shape in the chart coordinate space.
@ override public void addshutdownwindow ( final window window ) { if ( m_isshutdown ) { closewindow ( window ) ; return ; } synchronized ( this ) { if ( m_isshutdown ) { closewindow ( window ) ; return ; } m_windowstocloseonshutdown . add ( window ) ; } }	add a latch that will be released when the game shuts down .
public performancelogger ( ) { time1 = system . currenttimemillis ( ) ; }	instantiates a new performance logger .
public authrequest authenticate ( list discoveries , string returntourl ) throws consumerexception , messageexception { return authenticate ( discoveries , returntourl , returntourl ) ; }	builds a authentication request message for the user specified in the discovery information provided as a parameter.
public hash ( string hex ) { if ( hex . length ( ) != _num ) { throw new illegalargumentexception ( _str ) ; } this . bytes = byteutils . reverse ( byteutils . fromhex ( hex ) ) ; }	create a hash from a hexadecimal representation of the digest note that this is in the reverse byte order of the internal binary representation .
private string [ ] diff_halfmatchi ( string longtext , string shorttext , int i ) { string seed = longtext . substring ( i , i + longtext . length ( ) / _num ) ; int j = - _num ; string best_common = _str ; string best_longtext_a = _str , best_longtext_b = _str ; string best_shorttext_a = _str , best_shorttext_b = _str ; while ( ( j = shorttext . indexof ( seed , j + _num ) ) != - _num ) { int prefixlength = diff_commonprefix ( longtext . substring ( i ) , shorttext . substring ( j ) ) ; int suffixlength = diff_commonsuffix ( longtext . substring ( _num , i ) , shorttext . substring ( _num , j ) ) ; if ( best_common . length ( ) < suffixlength + prefixlength ) { best_common = shorttext . substring ( j - suffixlength , j ) + shorttext . substring ( j , j + prefixlength ) ; best_longtext_a = longtext . substring ( _num , i - suffixlength ) ; best_longtext_b = longtext . substring ( i + prefixlength ) ; best_shorttext_a = shorttext . substring ( _num , j - suffixlength ) ; best_shorttext_b = shorttext . substring ( j + prefixlength ) ; } } if ( best_common . length ( ) * _num >= longtext . length ( ) ) { return new string [ ] { best_longtext_a , best_longtext_b , best_shorttext_a , best_shorttext_b , best_common } ; } else { return null ; } }	does a substring of shorttext exist within longtext such that the substring is at least half the length of longtext ?.
public boolean isnumericalrun ( string pin ) { final int len = pin . length ( ) ; int prevdigit = character . digit ( pin . charat ( _num ) , _num ) ; int prevdiff = integer . max_value ; boolean isrun = _bool ; for ( int i = _num ; isrun && i < len ; i ++ ) { final int digit = character . digit ( pin . charat ( i ) , _num ) ; final int diff = digit - prevdigit ; if ( prevdiff != integer . max_value && diff != prevdiff ) { isrun = _bool ; } prevdiff = diff ; prevdigit = digit ; } return isrun ; }	tests the string to see if it contains a numeric run.
public static int uritype ( string uri ) { if ( uri . indexof ( _str ) != - _num ) { return abs_uri ; } else if ( uri . startswith ( _str ) ) { return root_rel_uri ; } else { return noroot_rel_uri ; } }	returns the type of a uri : abs_uri root_rel_uri noroot_rel_uri.
public static void addglue ( jcomponent b , boolean horiz ) { b . add ( horiz ? box . createhorizontalglue ( ) : box . createverticalglue ( ) ) ; }	add a glue , or variable spacing , to a ui component.
public static boolean isresourcereference ( string str ) { return str . startswith ( big_quote_left ) && str . endswith ( big_quote_right ) && str . charat ( _num ) == at . charat ( _num ) ; }	return the str is resource reference or not .
public boolean leave ( ) throws keeperexception , interruptedexception { zookeeper . delete ( rootpath + _str + name , _num ) ; while ( _bool ) { synchronized ( mutex ) { list < string > list = zookeeper . getchildren ( rootpath , _bool ) ; if ( list . size ( ) > _num ) { mutex . wait ( ) ; } else { return _bool ; } } } }	wait until all nodes leave barrier.
public enumeration < ? extends principal > members ( ) { vector < principal > v = new vector < principal > ( _num ) ; v . addelement ( this ) ; return v . elements ( ) ; }	returns an enumeration which contains the subnet mask .
public selectclause addwithasprovidedname ( string propertyname , string asname ) { selectlist . add ( new selectclauseexpression ( new propertyvalueexpression ( propertyname ) , asname ) ) ; return this ; }	adds a single property name and an " as " - asname for the column .
public void addinterface ( string interfacename ) { short interfaceindex = itsconstantpool . addclass ( interfacename ) ; itsinterfaces . add ( short . valueof ( interfaceindex ) ) ; }	add an interface implemented by this class.
public static string cutfromindexof ( string string , string substring ) { int i = string . indexof ( substring ) ; if ( i != - _num ) { string = string . substring ( i ) ; } return string ; }	cuts the string from the first index of provided substring to the end .
private response requesthttpgetfromregistry ( string url ) throws registryexception { try { response resp = http . get ( url ) ; if ( resp != null && resp . content != null ) { return resp ; } else { throw new registryexception ( type . bad_response , _str ) ; } } catch ( classcastexception e ) { throw new registryexception ( type . bad_response , e ) ; } catch ( connectexception e ) { throw new registryexception ( type . proxy , e ) ; } catch ( unknownhostexception e ) { try { http . get ( _str ) ; } catch ( exception e1 ) { throw new registryexception ( type . no_internet , e1 ) ; } throw new registryexception ( type . site_down , e ) ; } catch ( ioexception e ) { throw new registryexception ( type . io_error , e ) ; } catch ( urisyntaxexception e ) { throw new registryexception ( type . bad_request , _str + ( ( url != null ) ? url : _str ) ) ; } }	executes an http get request against the gbif registry.
public void testiterator ( ) throws interruptedexception { linkedblockingqueue q = populatedqueue ( size ) ; iterator it = q . iterator ( ) ; while ( it . hasnext ( ) ) { assertequals ( it . next ( ) , q . take ( ) ) ; } }	iterator iterates through all elements.
public void init ( remoteauthenticateduser currentuser ) { this . currentuser = currentuser ; }	creates a new sharedconnectiondirectory which exposes share keys as connections.
public static void invokefinalize ( object o ) throws throwable { o . finalize ( ) ; }	call the object finalize method on the given object.
private void removetvshow ( tvshow tvshow ) { synchronized ( root ) { tvshowtreenode child = ( tvshowtreenode ) nodemap . get ( tvshow ) ; defaultmutabletreenode parent = root ; if ( child != null ) { int index = getindexofchild ( parent , child ) ; nodemap . remove ( tvshow ) ; for ( tvshowepisode episode : new arraylist < > ( tvshow . getepisodes ( ) ) ) { nodemap . remove ( episode ) ; episode . removepropertychangelistener ( propertychangelistener ) ; } tvshow . removepropertychangelistener ( propertychangelistener ) ; child . removeallchildren ( ) ; child . removefromparent ( ) ; if ( index > - _num ) { treemodelevent event = new treemodelevent ( this , parent . getpath ( ) , new int [ ] { index } , new object [ ] { child } ) ; for ( treemodellistener listener : listeners ) { try { listener . treenodesremoved ( event ) ; } catch ( nullpointerexception | arrayindexoutofboundsexception npe ) { } } } } } }	removes the tv show .
private compliancefeature checkencryptpolicy ( org . wso2 . emm . agent . beans . operation operation ) { boolean encryptstatus = ( devicepolicymanager . getstorageencryptionstatus ( ) != devicepolicymanager . encryption_status_unsupported && devicepolicymanager . getstorageencryptionstatus ( ) != devicepolicymanager . encryption_status_inactive ) ; if ( ( operation . isenabled ( ) && encryptstatus ) || ( ! operation . isenabled ( ) && ! encryptstatus ) ) { policy . setcompliance ( _bool ) ; } else { policy . setcompliance ( _bool ) ; policy . setmessage ( resources . getstring ( r . string . error_encrypt_policy ) ) ; } return policy ; }	checks device encrypt policy on the device ( device external storage encryption ) .
public static int instanceof ( object o , class < ? > c ) { if ( o == null ) return false ; return c . isassignablefrom ( o . getclass ( ) ) ? true : false ; }	replacement function for the java instanceof instruction , which returns a distance integer.
@ override public void add ( int location , e object ) { insertelementat ( object , location ) ; }	adds the specified object into this vector at the specified location.
private long cacheresponseage ( ) { long apparentreceivedage = serveddate != null ? math . max ( _num , receivedresponsemillis - serveddate . gettime ( ) ) : _num ; long receivedage = ageseconds != - _num ? math . max ( apparentreceivedage , seconds . tomillis ( ageseconds ) ) : apparentreceivedage ; long responseduration = receivedresponsemillis - sentrequestmillis ; long residentduration = nowmillis - receivedresponsemillis ; return receivedage + responseduration + residentduration ; }	returns the current age of the response , in milliseconds.
private static int arrayindex ( int i ) { return ( i > > shift_per_word ) ; }	returns the array element holding the bit value for the given integer.
protected static void invalidateswitchpoints ( ) { if ( log_enabled ) { log . info ( _str ) ; } synchronized ( indyinterface . class ) { switchpoint old = switchpoint ; switchpoint = new switchpoint ( ) ; switchpoint . invalidateall ( new switchpoint [ ] { old } ) ; } }	callback for constant meta class update change.
public vdcconfig toconfigparam ( properties vdcinfo ) { log . info ( _str , vdcinfo . getproperty ( geoservicejob . vdc_short_id ) ) ; vdcconfig vdcconfig = new vdcconfig ( ) ; vdcconfig . setid ( uriutil . uri ( vdcinfo . getproperty ( geoservicejob . operated_vdc_id ) ) ) ; vdcconfig . setshortid ( vdcinfo . getproperty ( geoservicejob . vdc_short_id ) ) ; vdcconfig . setsecretkey ( vdcinfo . getproperty ( geoservicejob . vdc_secrete_key ) ) ; string name = vdcinfo . getproperty ( geoservicejob . vdc_name ) ; if ( ( name != null ) && ( ! name . isempty ( ) ) ) { vdcconfig . setname ( name ) ; } string description = vdcinfo . getproperty ( geoservicejob . vdc_description ) ; if ( ( description != null ) && ( ! description . isempty ( ) ) ) { vdcconfig . setdescription ( description ) ; } string endpnt = vdcinfo . getproperty ( geoservicejob . vdc_api_endpoint ) ; if ( endpnt != null ) { vdcconfig . setapiendpoint ( endpnt ) ; } vdcconfig . setgeocommandendpoint ( vdcinfo . getproperty ( geoservicejob . vdc_geocommand_endpoint ) ) ; vdcconfig . setgeodataendpoint ( vdcinfo . getproperty ( geoservicejob . vdc_geodata_endpoint ) ) ; return vdcconfig ; }	build vdcconfig for a vdc for syncvdcconfig call.
protected osxadapter ( string proxysignature , object target , method handler ) { this . proxysignature = proxysignature ; this . targetobject = target ; this . targetmethod = handler ; }	each osxadapter has the name of the eawt method it intends to listen for ( handleabout , for example ) , the object that will ultimately perform the task , and the method to be called on that object .
private double prediction ( instance inst ) { double [ ] normalizedinstance = normalizedinstance ( inst ) ; double normalizedprediction = prediction ( normalizedinstance ) ; return denormalizedprediction ( normalizedprediction ) ; }	output the prediction made by this perceptron on the given instance.
protected object finish ( map settings ) throws wizardexception { return provider . finish ( settings ) ; }	instantiate whatever object ( if any ) the wizard creates from its gathered data .
public boolean isvalidattachmentpoint ( datapathid switchdpid , ofport switchport ) { if ( topology . isattachmentpointport ( switchdpid , switchport ) == _bool ) return _bool ; if ( suppressaps . contains ( new switchport ( switchdpid , switchport ) ) ) return _bool ; return _bool ; }	check whether the given attachment point is valid given the current topology.
protected void fireclusterchange ( long timestamp , string type , string message ) { if ( listeners != null && ! listeners . isempty ( ) ) { clusterevent event = new clusterevent ( this , timestamp , type , message ) ; vector targets ; synchronized ( this ) { targets = ( vector ) listeners . clone ( ) ; } enumeration e = targets . elements ( ) ; while ( e . hasmoreelements ( ) ) { clustereventlistener l = ( clustereventlistener ) e . nextelement ( ) ; l . changecluster ( event ) ; } } }	fire a clusterchangeevent to all registered listeners.
public batchedimagerequest ( request < ? > request , imagecontainer container ) { mrequest = request ; mcontainers . add ( container ) ; }	constructs a new batchedimagerequest object.
public int rgbfor ( int pixel ) { return surfacetype . rgbfor ( pixel , colormodel ) ; }	returns the argb representation for the specified integer value which is packed in the format of the associated colormodel .
private boolean checkforcarry ( final char [ ] ca1 , final int icarry ) { boolean carry = _bool ; if ( icarry < ca1 . length ) { if ( ca1 [ icarry ] == _str || ca1 [ icarry ] == _str || ca1 [ icarry ] == _str || ca1 [ icarry ] == _str ) { carry = _bool ; } else if ( ca1 [ icarry ] == _str ) { int ii = icarry + _num ; for ( ; ii < ca1 . length ; ii ++ ) { if ( ca1 [ ii ] != _str ) { break ; } } carry = ii < ca1 . length ; if ( ! carry && icarry > _num ) { carry = ( ca1 [ icarry - _num ] == _str || ca1 [ icarry - _num ] == _str || ca1 [ icarry - _num ] == _str || ca1 [ icarry - _num ] == _str || ca1 [ icarry - _num ] == _str ) ; } } } return carry ; }	check to see if the digits that are going to be truncated because of the precision should force a round in the preceding digits .
protected void addbottomcomponent ( component bottomcomponent ) { c . weighty = _num ; layout . setconstraints ( bottomcomponent , c ) ; contentpanel . add ( bottomcomponent ) ; }	subclasses might add an additional component here which is seen during all steps , e.
public static boolean deletedirectoryfiles ( set < string > inputfilepathsandnames ) { if ( ( inputfilepathsandnames == null ) ) { return _bool ; } boolean didsuccessfullydeleteallfiles = _bool ; try { for ( string filepathandname : inputfilepathsandnames ) { file file = new file ( filepathandname ) ; if ( ! file . isdirectory ( ) ) { boolean deletesuccess = deletefile ( filepathandname ) ; if ( ! deletesuccess ) { logger . debug ( _str + filepathandname + _str ) ; didsuccessfullydeleteallfiles = _bool ; } } } } catch ( exception e ) { logger . debug ( e . tostring ( ) + system . lineseparator ( ) + stacktrace . getstringfromstacktrace ( e ) ) ; return _bool ; } return didsuccessfullydeleteallfiles ; }	this is a quiet method.
public static file createtempdir ( file dir , boolean cleanup ) throws ioexception { if ( ! dir . mkdirs ( ) && ! dir . exists ( ) ) { throw new ioexception ( string . format ( _str , dir . tostring ( ) ) ) ; } if ( cleanup ) { addcleanuphook ( dir . topath ( ) ) ; } return dir ; }	create directory that is automatically cleaned up after the jvm shuts down through use of a runtime shutdown hook .
public void emitinit ( ) { out . append ( _str ) ; out . append ( constname ( ) ) ; out . append ( _str ) ; out . append ( name ) ; out . append ( _str ) ; nl ( ) ; nextchunk ( ) ; }	emit declaration of decoded member and open first chunk .
public static string readcookieignorespecialcharacters ( httpservletrequest request , string cookiename ) { string cs = request . getheader ( _str ) ; if ( cs == null ) return null ; int start = cs . indexof ( cookiename ) ; if ( start < _num ) return null ; cs = cs . substring ( start + _num + cookiename . length ( ) ) ; int end = cs . indexof ( _str ) ; if ( end > _num ) { cs = cs . substring ( _num , end ) ; } return cs ; }	read all cookies from the request ' s ' cookie ' header , and parse it based on cookie version 1.
protected final void merge ( @ notnull set < localresourcerepository > visited , @ notnull resourcetype type , @ notnull setmultimap < string , string > seenqualifiers , @ notnull listmultimap < string , resourceitem > result ) { if ( visited . contains ( this ) ) { return ; } visited . add ( this ) ; domerge ( visited , type , seenqualifiers , result ) ; }	if this repository has not already been visited , merge its items of the given type into result .
private byte [ ] translatetransferablestring ( string str , long format ) throws ioexception { long lformat = long . valueof ( format ) ; string charset = getbestcharsetfortextformat ( lformat , null ) ; string eoln = ( string ) nativeeolns . get ( lformat ) ; if ( eoln != null ) { int length = str . length ( ) ; stringbuffer buffer = new stringbuffer ( length * _num ) ; for ( int i = _num ; i < length ; i ++ ) { if ( str . startswith ( eoln , i ) ) { buffer . append ( eoln ) ; i += eoln . length ( ) - _num ; continue ; } char c = str . charat ( i ) ; if ( c == _str ) { buffer . append ( eoln ) ; } else { buffer . append ( c ) ; } } str = buffer . tostring ( ) ; } byte [ ] bytes = str . getbytes ( charset ) ; integer terminators = ( integer ) nativeterminators . get ( lformat ) ; if ( terminators != null ) { int numterminators = terminators . intvalue ( ) ; byte [ ] terminatedbytes = new byte [ bytes . length + numterminators ] ; system . arraycopy ( bytes , _num , terminatedbytes , _num , bytes . length ) ; for ( int i = bytes . length ; i < terminatedbytes . length ; i ++ ) { terminatedbytes [ i ] = _num ; } bytes = terminatedbytes ; } return bytes ; }	translation function for converting string into a byte array.
private byte [ ] createpreviewbuffer ( size previewsize ) { int bitsperpixel = imageformat . getbitsperpixel ( imageformat . nv21 ) ; long sizeinbits = previewsize . getheight ( ) * previewsize . getwidth ( ) * bitsperpixel ; int buffersize = ( int ) math . ceil ( sizeinbits / _num ) + _num ; byte [ ] bytearray = new byte [ buffersize ] ; bytebuffer buffer = bytebuffer . wrap ( bytearray ) ; if ( ! buffer . hasarray ( ) || ( buffer . array ( ) != bytearray ) ) { throw new illegalstateexception ( _str ) ; } mbytestobytebuffer . put ( bytearray , buffer ) ; return bytearray ; }	creates one buffer for the camera preview callback.
public void add ( int pos , box b ) { children . add ( pos , b ) ; b . parent = this ; b . elderparent = elderparent ; }	inserts the given box at the given position in the list of child boxes .
public position createposition ( int offset ) throws badlocationexception { while ( queue . poll ( ) != null ) { unusedmarks ++ ; } if ( unusedmarks > math . max ( _num , ( marks . size ( ) / _num ) ) ) { removeunusedmarks ( ) ; } int g0 = getgapstart ( ) ; int g1 = getgapend ( ) ; int index = ( offset < g0 ) ? offset : offset + ( g1 - g0 ) ; search . index = index ; int sortindex = findsortindex ( search ) ; markdata m ; stickyposition position ; if ( sortindex < marks . size ( ) && ( m = marks . elementat ( sortindex ) ) . index == index && ( position = m . getposition ( ) ) != null ) { } else { position = new stickyposition ( ) ; m = new markdata ( index , position , queue ) ; position . setmark ( m ) ; marks . insertelementat ( m , sortindex ) ; } return position ; }	creates a position within the content that will track change as the content is mutated .
public static string pad ( string string , int n , string padding , boolean right ) { if ( n < _num ) { n = _num ; } if ( n < string . length ( ) ) { return string . substring ( _num , n ) ; } else if ( n == string . length ( ) ) { return string ; } char paddingchar ; if ( padding == null || padding . length ( ) == _num ) { paddingchar = _str ; } else { paddingchar = padding . charat ( _num ) ; } stringbuilder buff = new stringbuilder ( n ) ; n -= string . length ( ) ; if ( right ) { buff . append ( string ) ; } for ( int i = _num ; i < n ; i ++ ) { buff . append ( paddingchar ) ; } if ( ! right ) { buff . append ( string ) ; } return buff . tostring ( ) ; }	pad a string . this method is used for the sql function rpad and lpad .
private final void resetdtx ( affinetransform at ) { fsref = null ; dtx = at ; invdtx = null ; if ( ! dtx . isidentity ( ) ) { try { invdtx = dtx . createinverse ( ) ; } catch ( noninvertibletransformexception e ) { } } if ( gti != null ) { gti . strikesref = null ; } }	change the dtx for the strike refs we use.
public static void addactivitylistener ( activitylistener listener ) { if ( listener != null ) { starttracking ( ) ; listeners . add ( listener ) ; } }	adds a listener that will be informed one time about user activity , then removed .
public void addmutedusername ( final string username , final date mutetill ) { if ( isusernamemuted ( username ) ) { removemutedusername ( username ) ; } timestamp mutetillts = null ; if ( mutetill != null ) { mutetillts = new timestamp ( mutetill . gettime ( ) ) ; } s_logger . fine ( _str + username ) ; final connection con = database . getconnection ( ) ; try { final preparedstatement ps = con . preparestatement ( _str ) ; ps . setstring ( _num , username ) ; ps . settimestamp ( _num , mutetillts ) ; ps . execute ( ) ; ps . close ( ) ; con . commit ( ) ; } catch ( final sqlexception sqle ) { if ( sqle . geterrorcode ( ) == _num ) { s_logger . info ( _str + username + _str + sqle . getmessage ( ) ) ; return ; } s_logger . log ( level . severe , _str + username , sqle ) ; throw new illegalstateexception ( sqle . getmessage ( ) ) ; } finally { dbutil . closeconnection ( con ) ; } }	mute the given username.
private response < bitmap > doparse ( networkresponse response ) { byte [ ] data = response . data ; log . d ( _str , _str ) ; bitmapfactory . options decodeoptions = new bitmapfactory . options ( ) ; bitmap bitmap = null ; log . d ( _str , _str ) ; decodeoptions . injustdecodebounds = _bool ; bitmapfactory . decodebytearray ( data , _num , data . length , decodeoptions ) ; int actualwidth = decodeoptions . outwidth ; int actualheight = decodeoptions . outheight ; int desiredwidth = getresizeddimension ( mmaxwidth , mmaxheight , actualwidth , actualheight , mscaletype ) ; int desiredheight = getresizeddimension ( mmaxheight , mmaxwidth , actualheight , actualwidth , mscaletype ) ; decodeoptions . injustdecodebounds = _bool ; decodeoptions . insamplesize = findbestsamplesize ( actualwidth , actualheight , desiredwidth , desiredheight ) ; bitmap tempbitmap = bitmapfactory . decodebytearray ( data , _num , data . length , decodeoptions ) ; if ( tempbitmap != null && ( tempbitmap . getwidth ( ) > desiredwidth || tempbitmap . getheight ( ) > desiredheight ) ) { bitmap = bitmap . createscaledbitmap ( tempbitmap , desiredwidth , desiredheight , _bool ) ; tempbitmap . recycle ( ) ; } else { bitmap = tempbitmap ; } if ( bitmap == null ) { return response . error ( new parseerror ( response ) ) ; } else { return response . success ( bitmap , httpheaderparser . parsecacheheaders ( response ) ) ; } }	the real guts of parsenetworkresponse.
public void applycomponentorientation ( componentorientation o ) { possiblyfixcursor ( o . islefttoright ( ) ) ; super . applycomponentorientation ( o ) ; }	overridden to ensure that the cursor for this component is appropriate for the orientation .
public boolean isempty ( ) { return mselectedwidgets . isempty ( ) ; }	check if the selection is empty.
public void close ( ) throws ioexception { if ( ! closed ) { try { finish ( ) ; } finally { out . close ( ) ; closed = _bool ; } } }	writes any remaining uncompressed data to the output stream and closes the underlying output stream .
protected abstract c newparcelableadapterinstance ( list < object > items ) ;	create a new instance of your parcelableadapter using the provided list of items .
public static void nextbytes ( byte [ ] bytes ) { wasaccessed = _bool ; for ( int i = _num ; i < bytes . length ; ) for ( int rnd = nextint ( ) , n = math . min ( bytes . length - i , _num ) ; n -- > _num ; rnd >>= _num ) bytes [ i ++ ] = ( byte ) rnd ; }	replacement function for nextbytes.
protected void drawlowfarout ( double aradius , graphics2d g2 , double xx , double m ) { double side = aradius * _num ; g2 . draw ( new line2d . double ( xx - side , m - side , xx + side , m - side ) ) ; g2 . draw ( new line2d . double ( xx - side , m - side , xx , m ) ) ; g2 . draw ( new line2d . double ( xx + side , m - side , xx , m ) ) ; }	draws a triangle to indicate the presence of far out values .
public boolean isjavalibraryclass ( ) { if ( name . startswith ( _str ) || name . startswith ( _str ) || name . startswith ( _str ) || name . startswith ( _str ) || name . startswith ( _str ) || name . startswith ( _str ) ) return _bool ; return _bool ; }	sometimes we need to know which class is a jdk class.
private set < objectname > objectnamesfromfilterednamedobjects ( set < namedobject > list , queryexp query ) { set < objectname > result = new hashset < objectname > ( ) ; if ( query == null ) { for ( namedobject no : list ) { result . add ( no . getname ( ) ) ; } } else { final mbeanserver oldserver = queryeval . getmbeanserver ( ) ; query . setmbeanserver ( server ) ; try { for ( namedobject no : list ) { boolean res ; try { res = query . apply ( no . getname ( ) ) ; } catch ( exception e ) { res = _bool ; } if ( res ) { result . add ( no . getname ( ) ) ; } } } finally { query . setmbeanserver ( oldserver ) ; } } return result ; }	applies the specified queries to the set of namedobjects .
private boolean checktouchslop ( view child , float dx , float dy ) { if ( child == null ) { return _bool ; } final boolean checkhorizontal = mcallback . getviewhorizontaldragrange ( child ) > _num ; final boolean checkvertical = mcallback . getviewverticaldragrange ( child ) > _num ; if ( checkhorizontal && checkvertical ) { return dx * dx + dy * dy > mtouchslop * mtouchslop ; } else if ( checkhorizontal ) { return math . abs ( dx ) > mtouchslop ; } else if ( checkvertical ) { return math . abs ( dy ) > mtouchslop ; } return _bool ; }	check if we ' ve crossed a reasonable touch slop for the given child view.
private element createendpoint ( string name , string attrbinding , string attrlocation , string attrresponselocation ) throws domexception { if ( name == null ) { throw new illegalargumentexception ( _str ) ; } if ( attrbinding == null ) { throw new illegalargumentexception ( _str ) ; } if ( attrlocation == null ) { throw new illegalargumentexception ( _str ) ; } element endpt = doc . createelement ( name ) ; endpt . setattribute ( samlnames . binding , attrbinding ) ; endpt . setattribute ( samlnames . location , attrlocation ) ; if ( attrresponselocation != null ) { endpt . setattribute ( samlnames . resploc , attrresponselocation ) ; } return endpt ; }	create end point element in dom .
public string tostring ( ) { stringbuffer buffer = new stringbuffer ( ) ; buffer . append ( tostring ( getclass ( ) ) ) ; buffer . append ( _str ) ; buffer . append ( isusedefault ( ) ) ; buffer . append ( _str ) ; buffer . append ( uselocaleformat ) ; if ( pattern != null ) { buffer . append ( _str ) ; buffer . append ( pattern ) ; } if ( locale != null ) { buffer . append ( _str ) ; buffer . append ( locale ) ; } buffer . append ( _str ) ; return buffer . tostring ( ) ; }	provide a string representation of this number converter .
public void test_multipleresourcelocking_resources10_locktries10 ( ) throws exception { final properties properties = new properties ( ) ; properties . setproperty ( testoptions . nthreads , _str ) ; properties . setproperty ( testoptions . ntasks , _str ) ; properties . setproperty ( testoptions . nresources , _str ) ; properties . setproperty ( testoptions . min_locks , _str ) ; properties . setproperty ( testoptions . max_locks , _str ) ; properties . setproperty ( testoptions . max_lock_tries , _str ) ; properties . setproperty ( testoptions . predeclare_locks , _str ) ; properties . setproperty ( testoptions . sort_lock_requests , _str ) ; properties . setproperty ( testoptions . timeout , long . tostring ( _num * _num ) ) ; docomparisontest ( properties ) ; }	test where each operation locks one or more resources.
public void startelement ( string namespaceuri , string localname , string qname , attributes atts ) throws org . xml . sax . saxexception { throw new stopparseexception ( ) ; }	the spec notes that " the xml - stylesheet processing instruction is allowed only in the prolog of an xml document.
public synchronized byte [ ] tobytearray ( ) { byte [ ] newarray = new byte [ count ] ; system . arraycopy ( buf , _num , newarray , _num , count ) ; return newarray ; }	returns the contents of this bytearrayoutputstream as a byte array.
calendar tocalendar ( string value , string pattern , locale locale ) { calendar calendar = null ; try { dateformat format = ( locale == null ) ? new simpledateformat ( pattern ) : new simpledateformat ( pattern , locale ) ; format . setlenient ( _bool ) ; format . parse ( value ) ; calendar = format . getcalendar ( ) ; } catch ( exception e ) { fail ( _str + value + _str + pattern + _str + e . tostring ( ) ) ; } return calendar ; }	parse a string value to a calendar.
private byte [ ] convertbitmaptobytes ( final bitmap bitmap ) { int size = bitmap . getrowbytes ( ) * bitmap . getheight ( ) ; bytearrayoutputstream out = new bytearrayoutputstream ( size ) ; try { if ( bitmap . compress ( bitmap . compressformat . png , _num , out ) ) { return out . tobytearray ( ) ; } if ( slogger . isactivated ( ) ) { slogger . debug ( _str ) ; } return null ; } finally { closeableutils . trytoclose ( out ) ; } }	converts the specified bitmap to a byte array .
private static void savetemplate ( file parentdir , filetemplatebase template , final string lineseparator ) throws ioexception { final file templatefile = new file ( parentdir , encodefilename ( template . getname ( ) , template . getextension ( ) ) ) ; fileoutputstream fileoutputstream ; try { fileoutputstream = new fileoutputstream ( templatefile ) ; } catch ( filenotfoundexception e ) { fileutil . delete ( templatefile ) ; fileoutputstream = new fileoutputstream ( templatefile ) ; } outputstreamwriter outputstreamwriter = new outputstreamwriter ( fileoutputstream , charsettoolkit . utf8_charset ) ; string content = template . gettext ( ) ; if ( ! lineseparator . equals ( _str ) ) { content = stringutil . convertlineseparators ( content , lineseparator ) ; } outputstreamwriter . write ( content ) ; outputstreamwriter . close ( ) ; fileoutputstream . close ( ) ; }	save template to file.
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addall ( collections . list ( super . listoptions ( ) ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public void addcomposite ( transformtreenode node ) { parts . add ( node ) ; }	adds a composite operation to the transform node.
protected static void postprocessflood ( ihex [ ] hexset , int modifier ) { int n ; ihex field ; iterrainfactory f = terrains . getterrainfactory ( ) ; for ( n = _num ; n < hexset . length ; n ++ ) { field = hexset [ n ] ; int elev = field . getlevel ( ) - modifier ; if ( ( elev == _num ) && ! ( field . containsterrain ( terrains . water ) ) && ! ( field . containsterrain ( terrains . pavement ) ) ) { field . addterrain ( f . createterrain ( terrains . swamp , _num ) ) ; } else if ( elev < _num ) { if ( elev < - _num ) { elev = - _num ; } field . removeallterrains ( ) ; field . addterrain ( f . createterrain ( terrains . water , - elev ) ) ; field . setlevel ( modifier ) ; } } }	flood negative hex levels shoreline / salt marshes effect works best with more elevation.
private static void expand2digitnumber ( string numberstring , wordrelation wordrelation , item tokenitem ) { if ( numberstring . charat ( _num ) == _str ) { if ( numberstring . charat ( _num ) == _str ) { } else { string number = digit2num [ numberstring . charat ( _num ) - _str ] ; wordrelation . addword ( tokenitem , number ) ; } } else if ( numberstring . charat ( _num ) == _str ) { string number = digit2enty [ numberstring . charat ( _num ) - _str ] ; wordrelation . addword ( tokenitem , number ) ; } else if ( numberstring . charat ( _num ) == _str ) { string number = digit2teen [ numberstring . charat ( _num ) - _str ] ; wordrelation . addword ( tokenitem , number ) ; } else { string enty = digit2enty [ numberstring . charat ( _num ) - _str ] ; wordrelation . addword ( tokenitem , enty ) ; expanddigits ( numberstring . substring ( _num , numberstring . length ( ) ) , wordrelation , tokenitem ) ; } }	expands a two - digit string into a list of english words .
protected int indexof ( string buffer , int start , int end , char ch ) { for ( int i = start ; i < end ; i ++ ) { if ( buffer . charat ( i ) == ch ) { return i ; } } return - _num ; }	computes index of given char within stringbuffer.
public factory ( javacmessages messages , string prefix ) { this . prefix = prefix ; this . formatter = new basicdiagnosticformatter ( messages ) ; defaulterrorflags = enumset . of ( diagnosticflag . mandatory ) ; }	create a new diagnostic factory .
@ override protected boolean isfrontierempty ( ) { cleanupfrontier ( ) ; updatemetrics ( frontier . size ( ) ) ; return frontier . isempty ( ) ; }	pops nodes of already explored states from the head of the frontier and checks whether there are still some nodes left .
@ override public boolean isenabled ( ) { if ( ( attributeselectionpanel != null ) && ! isvalueonly ( ) ) { return attributeselectionpanel . isenabled ( ) ; } else { if ( this . crscombobox != null ) { return crscombobox . isenabled ( ) ; } } return _bool ; }	checks if is enabled .
public static double variance ( double [ ] x , double mean ) { double var = _num ; int count = x . length ; for ( double ax : x ) { if ( double . isnan ( ax ) ) { count -- ; } else { double diff = ax - mean ; var += diff * diff ; } } if ( count < _num ) { count = _num ; } else { count = count - _num ; } return var / ( double ) count ; }	compute variance ( ml estimator ).
private void stashrequestuser ( requestandresponse requestandresponse ) { if ( requestandresponse . wasuseralreadystashed ) { return ; } requestandresponse . wasuseralreadystashed = _bool ; final user user = dblogic . getuserbyid ( geteffectiveuserid ( requestandresponse ) ) ; if ( user != null ) { requestandresponse . userisadmin = user . getisadmin ( ) ; requestandresponse . userisaccountclosed = user . getisaccountclosed ( ) ; requestandresponse . useroptions = user . getoptions ( ) ; } else { requestandresponse . useroptions = _str ; } }	stashes user information in the requestandresponse to reduce the number of queries and transactions .
@ override public void sendlocationlist ( ) { list < location > locationlist = lm . getlocationsbynamelist ( ) ; arraylist < attribute > location ; for ( location loc : locationlist ) { location = new arraylist < attribute > ( _num ) ; location . add ( new attribute ( locations , loc ) ) ; try { sendmessage ( location ) ; } catch ( ioexception ioe ) { log . debug ( _str + loc . getname ( ) ) ; } } }	send a list of locations known by operations to the client.
protected void serializetext ( text node ) throws saxexception { if ( fnextisraw ) { fnextisraw = _bool ; fserializer . processinginstruction ( javax . xml . transform . result . pi_disable_output_escaping , _str ) ; dispatachchars ( node ) ; fserializer . processinginstruction ( javax . xml . transform . result . pi_enable_output_escaping , _str ) ; } else { boolean bdispatch = _bool ; if ( ( ffeatures & wellformed ) != _num ) { istextwellformed ( node ) ; } boolean iselementcontentwhitespace = _bool ; if ( fislevel3dom ) { iselementcontentwhitespace = node . iselementcontentwhitespace ( ) ; } if ( iselementcontentwhitespace ) { if ( ( ffeatures & elem_content_whitespace ) != _num ) { bdispatch = _bool ; } } else { bdispatch = _bool ; } if ( ! applyfilter ( node , nodefilter . show_text ) ) { return ; } if ( bdispatch ) { dispatachchars ( node ) ; } } }	serializes an text node .
@ override public boolean isinsidesoftwrap ( @ notnull visualposition visual ) { return isinsidesoftwrap ( visual , _bool ) ; }	allows to answer if given visual position points to soft wrap - introduced virtual space .
public boolean isvalid ( world world ) { return _bool ; }	used to determine if a task is valid.
public void clear ( ) { arrays . fill ( ritems , _num , rsize , null ) ; arrays . fill ( pitems , _num , psize , null ) ; rsize = _num ; psize = _num ; }	clear both rendering and picking queues .
private parseposition next ( final parseposition pos ) { pos . setindex ( pos . getindex ( ) + _num ) ; return pos ; }	convenience method to advance parse position by 1.
public final ac growprio ( int p ) { return growprio ( p , curix ) ; }	specifies the current row / column ' s grow priority.
private int flush ( int offset ) { try { _os . write ( _buffer , _num , offset ) ; _offset = _num ; return _num ; } catch ( ioexception e ) { throw new h3exceptionout ( e ) ; } }	flush the buffer and set the offset to zero .
protected string generatesectionlabel ( piedataset dataset , comparable key ) { string result = null ; if ( dataset != null ) { object [ ] items = createitemarray ( dataset , key ) ; result = messageformat . format ( this . labelformat , items ) ; } return result ; }	generates a label for a pie section .
public synchronized void removegraphlistener ( graphlistener cl ) { m_graphlisteners . remove ( cl ) ; }	remove a graph listener.
abstract protected void dofadein ( ) ;	fade in then play this audiosource.
public void exec ( string description , string [ ] basecommand ) throws backupexception { exec ( description , basecommand , null , null , null , _bool , _bool ) ; }	convenience method to execute command without providing input or output .
public int increment ( int offset ) { charsequence txt = gettext ( ) ; int i ; if ( txt != null ) { try { i = integer . parseint ( txt . tostring ( ) ) ; } catch ( numberformatexception e ) { i = _num ; } } else { i = _num ; } i = i + offset ; settext ( string . valueof ( i ) ) ; return i ; }	increment the numeric badge label.
public static serviceconfiguration create ( inputstream instream ) throws ioexception , illegalargumentexception { try { checknotnull ( instream ) ; properties properties = new properties ( ) ; properties . load ( instream ) ; return ( create ( properties ) ) ; } finally { if ( instream != null ) { instream . close ( ) ; } } }	creates serviceconfiguration and loads it with populated attribute values loaded from provided inputstream property file .
protected int [ ] splitsentence ( string sentence ) { string [ ] w = sentence . split ( _str ) ; int [ ] words = new int [ w . length ] ; for ( int i = _num ; i < w . length ; i ++ ) words [ i ] = vocabulary . id ( w [ i ] ) ; return words ; }	splits a sentence ( on white space ) , then looks up the integer representations of each word using the supplied symbol table .
public static boolean isfailure ( list < action > actions ) { return actions . isempty ( ) ; }	checks whether a list of actions is empty .
public void addtodictionary ( string s ) { if ( ! getautocomplete ( ) ) return ; if ( dict == null ) { setup ( ) ; this . dict = createdefaultdictionary ( ) ; } dict . addentry ( s . trim ( ) ) ; }	adds the specified string to the underlying dictionary.
public static int [ ] [ ] deep_copy ( int m [ ] [ ] ) { int [ ] [ ] c = new int [ m . length ] [ ] ; for ( int i = _num ; i < c . length ; i ++ ) { c [ i ] = arrays . copyof ( m [ i ] , m [ i ] . length ) ; } return c ; }	deep copy - make a deep copy of m [ ] [ ] .
public final boolean checktag ( int identifier ) { return arrays . binarysearch ( identifiers [ _num ] , identifier ) >= _num ; }	tests whether one of choice alternatives has the same identifier or not .
public void waitformessagetoarrive ( ) { log . info ( _str ) ; long start = system . currenttimemillis ( ) ; synchronized ( messages ) { try { while ( hasreceivedmessage ( ) ) { messages . wait ( _num ) ; } } catch ( interruptedexception e ) { log . info ( _str + e ) ; } } long end = system . currenttimemillis ( ) - start ; log . info ( _str + end + _str ) ; }	use to wait for a single message to arrive .
public date ( string date ) { string [ ] fields = date . split ( _str ) ; if ( fields . length != _num ) { throw new illegalargumentexception ( _str ) ; } month = integer . parseint ( fields [ _num ] ) ; day = integer . parseint ( fields [ _num ] ) ; year = integer . parseint ( fields [ _num ] ) ; if ( ! isvalid ( month , day , year ) ) throw new illegalargumentexception ( _str ) ; }	initializes new date specified as a string in form mm / dd / yyyy .
public static void copy ( file src , file dst ) throws ioexception { if ( src . isdirectory ( ) ) { ensuredirectoryexists ( dst ) ; string [ ] fileslist = src . list ( ) ; for ( string file : fileslist ) { file srcfile = new file ( src , file ) ; file destfile = new file ( dst , file ) ; copy ( srcfile , destfile ) ; } } else { copyfile ( src , dst ) ; } }	copy file object from one place to another.
public mapobjects ( pokemongo api ) { this . api = api ; }	instantiates a new map objects .
@ override public byte [ ] read ( int length ) throws ioexception { if ( length > available ( ) ) { throw new endofbufferexception ( ) ; } byte [ ] res = new byte [ length ] ; system . arraycopy ( buffer , read_pos , res , _num , length ) ; read_pos = read_pos + length ; return res ; }	reads vector of opaque values.
public string encode ( string pstring ) throws encoderexception { if ( pstring == null ) { return null ; } try { return encode ( pstring , getdefaultcharset ( ) ) ; } catch ( unsupportedencodingexception e ) { throw new encoderexception ( e . getmessage ( ) ) ; } }	encodes a string into its url safe form using the default string charset.
public void testsortsaccordingnumberofattributes ( ) throws exception { xppdom dom1 = xppfactory . builddom ( _str ) ; xppdom dom2 = xppfactory . builddom ( _str ) ; assertequals ( - _num , comparator . compare ( dom1 , dom2 ) ) ; assertequals ( _str , xpath . get ( ) ) ; assertequals ( _num , comparator . compare ( dom2 , dom1 ) ) ; assertequals ( _str , xpath . get ( ) ) ; }	tests comparison of different number of attributes .
public inspacepredicate ( object ... values ) { _invalues = new hashset < object > ( ) ; for ( object value : values ) { _invalues . add ( value ) ; } }	creates an in predicate using the specified values .
private static void delete ( file f ) { if ( f . isdirectory ( ) ) { for ( file c : f . listfiles ( ) ) { delete ( c ) ; } } if ( ! f . delete ( ) ) { printstream err = system . err ; err . println ( _str + f ) ; } }	recursively deletes a file that may represent a directory .
protected list < string > preparesortkeystatements ( list < sortkey > sortkeys ) { list < string > keys = new arraylist < string > ( ) ; for ( int i = _num ; i < sortkeys . size ( ) ; i ++ ) { sortkey sortkey = sortkeys . get ( i ) ; keys . add ( explicitmapping . getdbcolumnname ( sortkey . getfield ( ) ) + ( sortkey . isascendingorder ( ) ? _str : _str ) ) ; } return keys ; }	loops through sort keys constructing the key statements .
public static string experimentertostring ( ofinstructionexperimenter inst , logger log ) { return long . tostring ( inst . getexperimenter ( ) ) ; }	convert an ofinstructionexperimenter to string form.
public static void printmagnitudes ( ) { printmagnitudes ( system . out ) ; }	prints the relative magnitudes of the collected timer data to the standard output stream .
private optional < curatorframework > createclient ( string zookeeperurl ) { if ( stringutils . isnotblank ( zookeeperurl ) ) { curatorframework client = configurationsutils . getclient ( zookeeperurl ) ; client . start ( ) ; return optional . of ( client ) ; } else { return optional . empty ( ) ; } }	creates a zookeeper client .
public static string addcvdescription ( string tooltip , string cvdescription , string mask ) { string descstring = cvdescription ; string temp = getmaskdescription ( mask ) ; if ( temp . length ( ) > _num ) { descstring = descstring + _str + temp ; } if ( paneprogframe . getshowcvnumbers ( ) && ( descstring != null ) ) { if ( tooltip == null ) { tooltip = descstring ; } else { tooltip = addtexthtmlaware ( tooltip , _str + descstring + _str ) ; } } else if ( tooltip == null ) { tooltip = _str ; } return tooltip ; }	optionally add cv numbers and bit numbers to tool tip text based on roster preferences setting.
public final static int readrawuntil ( final stringbuilder out , final string in , final int start , final char end ) { int pos = start ; while ( pos < in . length ( ) ) { final char ch = in . charat ( pos ) ; if ( ch == end ) { break ; } out . append ( ch ) ; pos ++ ; } return ( pos == in . length ( ) ) ? - _num : pos ; }	reads characters until the end character is encountered , ignoring escape sequences .
private static void converttohtml40 ( attributeset from , mutableattributeset to ) { enumeration keys = from . getattributenames ( ) ; string value = _str ; while ( keys . hasmoreelements ( ) ) { object key = keys . nextelement ( ) ; if ( key instanceof css . attribute ) { value = value + _str + key + _str + from . getattribute ( key ) + _str ; } else { to . addattribute ( key , from . getattribute ( key ) ) ; } } if ( value . length ( ) > _num ) { to . addattribute ( html . attribute . style , value ) ; } }	copies the given attributeset to a new set , converting any css attributes found to arguments of an html style attribute .
public synchronized void close ( ) throws ioexception { if ( in == null ) return ; in . close ( ) ; in = null ; buf = null ; }	closes this input stream and releases any system resources associated with the stream.
public void updateamount ( ) { setamt ( gettotalamount ( ) ) ; }	updates the amount on the document.
public void testcreationunique ( ) { instances data ; arraylist < attribute > atts ; string relname ; relname = _str ; atts = new arraylist < attribute > ( ) ; atts . add ( new attribute ( _str ) ) ; atts . add ( new attribute ( _str ) ) ; atts . add ( new attribute ( _str , _str ) ) ; atts . add ( new attribute ( _str , new arraylist < string > ( arrays . aslist ( new string [ ] { _str , _str , _str } ) ) ) ) ; atts . add ( new attribute ( _str , new arraylist < string > ( arrays . aslist ( new string [ ] { _str , _str } ) ) ) ) ; atts . add ( new attribute ( _str , ( arraylist < string > ) null ) ) ; data = new instances ( relname , atts , _num ) ; assertequals ( _str , relname , data . relationname ( ) ) ; assertequals ( _str , atts . size ( ) , data . numattributes ( ) ) ; }	tests the creation of a dataset ( unique attribute names ) .
public string evaluate ( xpathcontext xctxt , int context , org . apache . xml . utils . prefixresolver nsnode ) throws javax . xml . transform . transformerexception { if ( null != m_simplestring ) { return m_simplestring ; } else if ( null != m_parts ) { final faststringbuffer buf = getbuffer ( ) ; string out = null ; int n = m_parts . size ( ) ; try { for ( int i = _num ; i < n ; i ++ ) { avtpart part = ( avtpart ) m_parts . elementat ( i ) ; part . evaluate ( xctxt , buf , context , nsnode ) ; } out = buf . tostring ( ) ; } finally { if ( use_object_pool ) { stringbufferpool . free ( buf ) ; } else { buf . setlength ( _num ) ; } } return out ; } else { return _str ; } }	evaluate the avt and return a string .
public static byte [ ] readdex ( file file ) throws ioexception { return readdex ( file . topath ( ) ) ; }	read the dex file from file , if the file is a zip file , it will return the content of classes.
public void addupdatelistener ( animatorupdatelistener listener ) { if ( mupdatelisteners == null ) { mupdatelisteners = new arraylist < animatorupdatelistener > ( ) ; } mupdatelisteners . add ( listener ) ; }	adds a listener to the set of listeners that are sent update events through the life of an animation.
public void runcommercial ( string stream , int length ) { if ( stream == null || stream . isempty ( ) ) { commercialresult ( stream , _str , twitchapi . requestresult . failed ) ; } else { string channel = _str + stream ; if ( ischannelopen ( channel ) ) { g . printline ( channel , _str + length + _str ) ; } else { g . printline ( _str + length + _str + stream + _str ) ; } api . runcommercial ( stream , settings . getstring ( _str ) , length ) ; } }	tries to run a commercial on the given stream with the given length.
public void addsubtree ( int index , list < node > children ) { list < nodedescriptor > nodedescriptors = converttreenodeshelper ( children ) ; roots . addchildren ( index , nodedescriptors ) ; list < node > nodes = new arraylist < > ( ) ; for ( nodedescriptor child : nodedescriptors ) { nodes . add ( child . getnode ( ) ) ; } if ( ! nodes . isempty ( ) ) { fireevent ( new storeaddevent ( index , nodes ) ) ; } }	imports a list of subtrees at the given position in the root of the tree .
void generatewhile ( tree . whilestatement that ) { tree . whileclause whileclause = that . getwhileclause ( ) ; list < varholder > vars = specialconditionsandblock ( whileclause . getconditionlist ( ) , whileclause . getblock ( ) , _str , _bool ) ; for ( varholder v : vars ) { v . forget ( ) ; } }	generates js code for a whilestatement .
public static double igamma ( double a , double x ) { double coef = ( math . exp ( - x ) * math . pow ( x , a ) ) / gamma ( a ) ; double sum = _num ; for ( int i = _num ; i < _num ; i ++ ) { sum += ( gamma ( a ) / gamma ( a + _num + ( double ) i ) ) * math . pow ( x , ( double ) i ) ; } return ( coef * sum ) ; }	calculates the incomplete gamma function for two doubles.
public void initializeactiveslotslist ( string slots ) { if ( activeslotslist == null ) { activeslotslist = new arraylist < string > ( ) ; } for ( string s : slots . split ( _str ) ) { activeslotslist . add ( s ) ; } }	add slots to list where slotactivateditem can be activated when equipped .
private static string convertactiontypetointent ( ramlactiontype actiontype , boolean istargetcollection ) { switch ( actiontype ) { case delete : return _str ; case get : return _str ; case post : if ( istargetcollection ) { return _str ; } case put : return _str ; case patch : return _str ; default : return _str ; } }	attempts to convert the http verb into a textual representation of intent based on rest conventions.
public static string hide ( final string key ) { return ishidden ( key ) ? key : hidden_prefix . concat ( key ) ; }	turn the provided key into a hidden key.
private synchronized imqtttoken removemqtttoken ( bundle data ) { string activitytoken = data . getstring ( mqttserviceconstants . callback_activity_token ) ; if ( activitytoken != null ) { int tokennumber = integer . parseint ( activitytoken ) ; imqtttoken token = tokenmap . get ( tokennumber ) ; tokenmap . delete ( tokennumber ) ; return token ; } return null ; }	get a token identified by a string , and remove it from our map.
public static boolean isexplicitalltype ( string [ ] types ) { return types != null && types . length == _num && all . equals ( types [ _num ] ) ; }	identifies whether the array containing type names given as argument explicitly refers to all types the empty or null array doesn ' t explicitly map to all types.
private string readuntil ( char [ ] delimiter , boolean returntext ) throws ioexception , xmlpullparserexception { int start = position ; stringbuilder result = null ; if ( returntext && text != null ) { result = new stringbuilder ( ) ; result . append ( text ) ; } search : while ( _bool ) { if ( position + delimiter . length > limit ) { if ( start < position && returntext ) { if ( result == null ) { result = new stringbuilder ( ) ; } result . append ( buffer , start , position - start ) ; } if ( ! fillbuffer ( delimiter . length ) ) { checkrelaxed ( unexpected_eof ) ; type = comment ; return null ; } start = position ; } for ( int i = _num ; i < delimiter . length ; i ++ ) { if ( buffer [ position + i ] != delimiter [ i ] ) { position ++ ; continue search ; } } break ; } int end = position ; position += delimiter . length ; if ( ! returntext ) { return null ; } else if ( result == null ) { return stringpool . get ( buffer , start , end - start ) ; } else { result . append ( buffer , start , end - start ) ; return result . tostring ( ) ; } }	reads text until the specified delimiter is encountered.
private config ( ) { throw new assertionerror ( _str ) ; }	this class cannot be instantiated .
public boolean isleaf ( ) { return children == null || children . isempty ( ) ; }	true , if the node is a leaf .
private boolean isvalid ( charsequence text ) { for ( int i = _num ; i < text . length ( ) ; i ++ ) { char c = text . charat ( i ) ; boolean valid = c == _num || c == _num || c == _num || ( c >= _num && c <= _num ) || ( c >= _num && c <= _num ) ; if ( ! valid ) { return _bool ; } } return _bool ; }	returns true if all of the characters in the text are permitted for use in xml documents .
public static void interrupt ( final thread thread ) { if ( thread != null ) { thread . interrupt ( ) ; } }	interrupts the specified thread , guarding against null . < p / >.
private void writeobject ( java . io . objectoutputstream s ) throws java . io . ioexception { s . defaultwriteobject ( ) ; s . writeint ( attrs . size ( ) ) ; enumeration < attribute > attrenum = attrs . elements ( ) ; while ( attrenum . hasmoreelements ( ) ) { s . writeobject ( attrenum . nextelement ( ) ) ; } }	overridden to avoid exposing implementation details .
public static container east ( component east ) { return container . enclosein ( new borderlayout ( ) , east , borderlayout . east ) ; }	convenience method that creates a border layout container and places the given component in the east.
public static object [ ] putall ( ) { region region = cache . getregion ( region . separator + region_name ) ; assertnotnull ( region ) ; try { map map = new linkedhashmap ( ) ; map . put ( putall_key1 , putall_value1 ) ; map . put ( putall_key2 , putall_value2 ) ; map . put ( putall_key3 , putall_value3 ) ; map . put ( putall_key4 , putall_value4 ) ; map . put ( putall_key5 , putall_value5 ) ; region . putall ( map , _str ) ; eventid [ ] evids = new eventid [ _num ] ; evids [ _num ] = putalleventid1 ; evids [ _num ] = putalleventid2 ; evids [ _num ] = putalleventid3 ; evids [ _num ] = putalleventid4 ; evids [ _num ] = putalleventid5 ; assertnotnull ( evids [ _num ] ) ; assertnotnull ( evids [ _num ] ) ; assertnotnull ( evids [ _num ] ) ; assertnotnull ( evids [ _num ] ) ; assertnotnull ( evids [ _num ] ) ; return evids ; } catch ( exception e ) { fail ( _str + e ) ; } return null ; }	does an update and return the eventid generated . eventid is caught in the listener and stored in a static variable.
public void loadlayout ( file ofile , boolean newtab ) { loadlayout ( ofile , newtab , _bool ) ; }	load a layout from a file . supports loading binary and xml serialized flow files.
public void track ( file file , object marker , filedeletestrategy deletestrategy ) { if ( file == null ) { throw new nullpointerexception ( _str ) ; } addtracker ( file . getpath ( ) , marker , deletestrategy ) ; }	track the specified file , using the provided marker , deleting the file when the marker instance is garbage collected.
public static string separatorstounix ( string path ) { if ( path == null || path . indexof ( windows_separator ) == - _num ) { return path ; } return path . replace ( windows_separator , unix_separator ) ; }	converts all separators to the unix separator of forward slash .
public boolean hasparameter ( string name ) { return _parameters . hasparameter ( name ) ; }	checks if the extension contains a parameter .
@ override public long freememory ( long windowid ) throws ioexception { long size = keystream . datasizeuptowindow ( windowid ) + valuestream . datasizeuptowindow ( windowid ) ; windowsforfreememory . add ( windowid ) ; return size ; }	free memory up to the given windowid this method will be called by another thread.
public static boolean issql99nonreservedkeyword ( string identifier ) { if ( identifier == null ) { throw new nullpointerexception ( _str ) ; } return arrays . binarysearch ( sql99_non_reserved , identifier . touppercase ( ) ) >= _num ; }	returns true if the given identifier is a sql - 99 non - reserved keyword .
@ suppresswarnings ( _str ) public static < t > void sort ( list < t > list , comparator < ? super t > comparator ) { t [ ] array = list . toarray ( ( t [ ] ) new object [ list . size ( ) ] ) ; arrays . sort ( array , comparator ) ; int i = _num ; listiterator < t > it = list . listiterator ( ) ; while ( it . hasnext ( ) ) { it . next ( ) ; it . set ( array [ i ++ ] ) ; } }	sorts the specified list using the specified comparator.
@ override public long handlecommit ( final long committime ) { if ( error != null ) throw new indexinconsistenterror ( error ) ; final irootblockview view = journal . getrootblockview ( ) ; final bytebuffer rbv = view . asreadonlybuffer ( ) ; final bytebuffer bb = bytebuffer . allocate ( rbv . capacity ( ) ) ; for ( int i = _num ; i < rbv . capacity ( ) ; i ++ ) { bb . put ( rbv . get ( ) ) ; } bb . flip ( ) ; return journal . write ( bb ) ; }	write the current root block to the journal and return its address to be stored in the commitrecord .
public boolean isappendtaskname ( ) { return appendtaskname ; }	checks if the appendtaskname flag is set .
public static final string tostring ( string str ) { if ( str == null ) return _str ; bytearrayoutputstream buffer = new bytearrayoutputstream ( ) ; tobytearray ( buffer , str ) ; return buffer . tostring ( ) ; }	provides a java string literal representing the parameter string.
public static cache . entry makerandomcacheentry ( byte [ ] data , boolean isexpired , boolean needsrefresh ) { random random = new random ( ) ; cache . entry entry = new cache . entry ( ) ; if ( data != null ) { entry . data = data ; } else { entry . data = new byte [ random . nextint ( _num ) ] ; } entry . etag = string . valueof ( random . nextlong ( ) ) ; entry . lastmodified = random . nextlong ( ) ; entry . ttl = isexpired ? _num : long . max_value ; entry . softttl = needsrefresh ? _num : long . max_value ; return entry ; }	makes a random cache entry .
public static double max ( double [ ] data ) { double max = double . nan ; for ( int i = _num ; i < data . length ; i ++ ) { if ( double . isnan ( data [ i ] ) ) continue ; if ( double . isnan ( max ) || data [ i ] > max ) max = data [ i ] ; } return max ; }	find the maximum of all elements in the array , ignoring elements that are nan .
private static boolean isstartelement ( string line ) { int first = line . lastindexof ( _str ) ; int last = line . lastindexof ( _str ) ; if ( last < first ) { return _bool ; } else { int firstend = line . lastindexof ( _str ) ; int lastend = line . lastindexof ( _str ) ; if ( ( firstend != first ) && ( ( lastend + _num ) != last ) ) { return _bool ; } } return _bool ; }	tries to find out if the line finishes with an element start.
long readlong ( ) throws ioexception { return ( ( ( long ) _is . read ( ) << _num ) | ( ( long ) _is . read ( ) << _num ) | ( ( long ) _is . read ( ) << _num ) | ( ( long ) _is . read ( ) << _num ) | ( ( long ) _is . read ( ) << _num ) | ( ( long ) _is . read ( ) << _num ) | ( ( long ) _is . read ( ) << _num ) | ( ( long ) _is . read ( ) ) ) ; }	parses a 64 - bit int .
@ override public instance remove ( int index ) { return m_instances . remove ( index ) ; }	removes the instance at the given position .
protected static string extractaccesskey ( string s3uri ) { return s3uri . substring ( s3uri . indexof ( _str ) + _num , s3uri . indexof ( _str , s3uri . indexof ( _str ) + _num ) ) ; }	extracts the accesskey from the given uri.
public boolean dotransaction ( db db , object threadstate ) throws workloadexception { boolean ret = _bool ; long st = system . nanotime ( ) ; string op = operationchooser . nextstring ( ) ; if ( op . compareto ( _str ) == _num ) { ret = dotransactionread ( db ) ; } else if ( op . compareto ( _str ) == _num ) { ret = dotransactionupdate ( db ) ; } else if ( op . compareto ( _str ) == _num ) { ret = dotransactioninsert ( db ) ; } else if ( op . compareto ( _str ) == _num ) { ret = dotransactionscan ( db ) ; } else { ret = dotransactionreadmodifywrite ( db ) ; } long en = system . nanotime ( ) ; _measurements . measure ( _operations . get ( op ) , ( int ) ( ( en - st ) / _num ) ) ; if ( ret ) _measurements . reportreturncode ( _operations . get ( op ) , - _num ) ; else { _measurements . reportreturncode ( _operations . get ( op ) , _num ) ; } actualopcount . addandget ( _num ) ; return ret ; }	do one transaction operation.
public tostringhelper addvalue ( boolean value ) { return addholder ( string . valueof ( value ) ) ; }	adds an unnamed value to the formatted output .
public static void copyexcept ( object src , object dst , int oldsize , int removeindex ) { if ( removeindex > _num && oldsize > _num ) { system . arraycopy ( src , _num , dst , _num , removeindex ) ; } if ( removeindex < oldsize ) { system . arraycopy ( src , removeindex + _num , dst , removeindex , oldsize - removeindex - _num ) ; } }	copy the elements of an array , and remove one element .
public sitemonitor ( string [ ] urllist ) { siteurllist = urllist ; }	constructs a webtopnaming $ sitemonitor object with the provided site urls .
private set unioniprange ( byte [ ] ipwithsubmask1 , byte [ ] ipwithsubmask2 ) { set set = new hashset ( ) ; if ( arrays . areequal ( ipwithsubmask1 , ipwithsubmask2 ) ) { set . add ( ipwithsubmask1 ) ; } else { set . add ( ipwithsubmask1 ) ; set . add ( ipwithsubmask2 ) ; } return set ; }	calculates the union if two ip ranges .
public optional < blazevertex > vertex ( final string vertexid ) { try ( final closeableiterator < vertex > it = vertices ( vertexid ) ) { final optional < blazevertex > v = it . hasnext ( ) ? optional . of ( ( blazevertex ) it . next ( ) ) : optional . empty ( ) ; if ( it . hasnext ( ) ) { throw new illegalstateexception ( _str + vertexid ) ; } return v ; } }	lookup a vertex by id .
public static long addandget ( atomiclong current , long toadd ) { long u , r ; do { r = current . get ( ) ; if ( r == long . max_value ) { return long . max_value ; } u = addcap ( r , toadd ) ; } while ( ! current . compareandset ( r , u ) ) ; return u ; }	concurrent addition bound to long.
private void start ( httpservletrequest request , httpservletresponse response ) throws ioexception { string label = request . getparameter ( _str ) ; string detail = request . getparameter ( _str ) ; monkey key = getmonkey ( label , detail , default_units ) ; startmon ( key ) ; printwriter out = response . getwriter ( ) ; out . println ( ok + _str + label ) ; }	start a monitor by providing a summary label and optionally a detail string.
public double norm ( ) { double sum = _num ; for ( int i = _num ; i < components . length ; i ++ ) sum += components [ i ] * components [ i ] ; return math . sqrt ( sum ) ; }	computes the norm of a vector .
public static double p_harmonic ( int y [ ] [ ] , int ypred [ ] [ ] ) { int allmissings = _num ; int n = y . length ; double loss = _num ; for ( int i = _num ; i < n ; i ++ ) { if ( allmissing ( y [ i ] ) ) { allmissings ++ ; continue ; } double curloss = p_harmonic ( y [ i ] , ypred [ i ] ) ; if ( double . isnan ( curloss ) ) { allmissings ++ ; continue ; } loss += curloss ; } return loss / ( double ) ( n - allmissings ) ; }	harmonic accuracy - - average over all labels.
public void writeentry ( ccacheoutputstream cos ) throws ioexception { cos . write16 ( adtype ) ; cos . write32 ( addata . length ) ; cos . write ( addata , _num , addata . length ) ; }	writes the entry ' s data fields in fcc format to an output stream .
public closeableanimatedbitmap ( list < bitmap > bitmaps , list < integer > durations , resourcereleaser < bitmap > resourcereleaser ) { preconditions . checknotnull ( bitmaps ) ; preconditions . checkstate ( bitmaps . size ( ) >= _num , _str ) ; mbitmaps = new arraylist < > ( ) ; mbitmapreferences = new arraylist < > ( ) ; for ( bitmap bitmap : bitmaps ) { mbitmapreferences . add ( closeablereference . of ( bitmap , resourcereleaser ) ) ; mbitmaps . add ( bitmap ) ; } mdurations = preconditions . checknotnull ( durations ) ; preconditions . checkstate ( mdurations . size ( ) == mbitmaps . size ( ) , _str ) ; }	creates a new instance of a closeablestaticbitmap .
public static string readlabelfile ( string entryseparator , boolean ensureinitialboundary , string trfname ) throws ioexception { bufferedreader lab = new bufferedreader ( new filereader ( trfname ) ) ; try { xwaveslabelfilereader xlds = new xwaveslabelfilereader ( trfname ) ; string result = stringutils . join ( entryseparator , xlds . getlabelsymbols ( ) ) ; if ( ensureinitialboundary && result . charat ( _num ) != _str ) { result = _str + entryseparator + result ; } return result ; } finally { lab . close ( ) ; } }	this reads in a label file and returns a string of the phonetic symbols , separated by the entry separator character entryseparator .
converterset add ( converter converter , converter [ ] removed ) { converter [ ] converters = iconverters ; int length = converters . length ; for ( int i = _num ; i < length ; i ++ ) { converter existing = converters [ i ] ; if ( converter . equals ( existing ) ) { if ( removed != null ) { removed [ _num ] = null ; } return this ; } if ( converter . getsupportedtype ( ) == existing . getsupportedtype ( ) ) { converter [ ] copy = new converter [ length ] ; for ( int j = _num ; j < length ; j ++ ) { if ( j != i ) { copy [ j ] = converters [ j ] ; } else { copy [ j ] = converter ; } } if ( removed != null ) { removed [ _num ] = existing ; } return new converterset ( copy ) ; } } converter [ ] copy = new converter [ length + _num ] ; system . arraycopy ( converters , _num , copy , _num , length ) ; copy [ length ] = converter ; if ( removed != null ) { removed [ _num ] = null ; } return new converterset ( copy ) ; }	returns a copy of this set , with the given converter added.
private void parse ( ) throws saxexception { xstream xstream = ( xstream ) properties . get ( configured_xstream_property ) ; if ( xstream == null ) { xstream = new xstream ( ) ; } final list < ? > source = ( list < ? > ) properties . get ( source_object_list_property ) ; if ( source == null || source . isempty ( ) ) { throw new saxexception ( _str + source_object_list_property + _str ) ; } try { startdocument ( _bool ) ; for ( final object name : source ) { xstream . marshal ( name , this ) ; } enddocument ( _bool ) ; } catch ( final streamexception e ) { if ( e . getcause ( ) instanceof saxexception ) { throw ( saxexception ) e . getcause ( ) ; } else { throw new saxexception ( e ) ; } } }	serializes the java objects of the configured list into a flow of sax events .
private sortedmap < messageuid , maildirmessagename > truncatemap ( map < messageuid , maildirmessagename > map , messageuid from , messageuid to ) { treemap < messageuid , maildirmessagename > sortedmap ; if ( map instanceof treemap < ? , ? > ) sortedmap = ( treemap < messageuid , maildirmessagename > ) map ; else sortedmap = new treemap < messageuid , maildirmessagename > ( map ) ; if ( to != null ) return sortedmap . submap ( from , to . next ( ) ) ; return sortedmap . tailmap ( from ) ; }	sorts the given map and returns a subset which is constricted by a lower and an upper limit .
public void dumpindex ( boolean showbounds ) throws ioexception { byte ixrecord [ ] = new byte [ spatial_index_record_length ] ; int recnum = _num ; if ( shpfilename == null ) { return ; } binarybufferedfile ssx = new binarybufferedfile ( ssx ( shpfilename ) ) ; ssx . seek ( _num ) ; while ( _bool ) { int result = ssx . read ( ixrecord , _num , spatial_index_record_length ) ; if ( result <= _num ) { logger . info ( _str + recnum + _str ) ; break ; } else { recnum ++ ; int offset = readbeint ( ixrecord , _num ) ; int length = readbeint ( ixrecord , _num ) ; logger . info ( _str + recnum + _str + offset + _str + length + ( showbounds ? ( _str + readledouble ( ixrecord , _num ) + _str + readledouble ( ixrecord , _num ) + _str + readledouble ( ixrecord , _num ) + _str + readledouble ( ixrecord , _num ) ) : _str ) ) ; } } ssx . close ( ) ; }	displays the contents of this index .
private static boolean compareparam ( string jdiffparam , type reflectionparamtype ) { if ( jdiffparam == null ) { return _bool ; } string reflectionparam = typetostring ( reflectionparamtype ) ; if ( jdiffparam . equals ( reflectionparam ) ) { return _bool ; } int jdiffparamendoffset = jdiffparam . indexof ( _str ) ; int reflectionparamendoffset = reflectionparam . indexof ( _str ) ; if ( jdiffparamendoffset != - _num && reflectionparamendoffset != - _num ) { jdiffparam = jdiffparam . substring ( _num , jdiffparamendoffset ) ; reflectionparam = reflectionparam . substring ( _num , reflectionparamendoffset ) ; return jdiffparam . equals ( reflectionparam ) ; } return _bool ; }	compares the parameter from the api and the parameter from reflection .
public static void randomnumber ( int [ ] num , int n ) { for ( int j = _num ; j < n ; j ++ ) { num [ j ] = ( int ) ( math . random ( ) * _num ) ; } }	generate random number of size n directly into num.
private static string escapejson ( string text ) { stringbuilder builder = new stringbuilder ( ) ; builder . append ( _str ) ; for ( int index = _num ; index < text . length ( ) ; index ++ ) { char chr = text . charat ( index ) ; switch ( chr ) { case _str : case _str : builder . append ( _str ) ; builder . append ( chr ) ; break ; case _str : builder . append ( _str ) ; break ; case _str : builder . append ( _str ) ; break ; case _str : builder . append ( _str ) ; break ; case _str : builder . append ( _str ) ; break ; default : if ( chr < _str ) { string t = _str + integer . tohexstring ( chr ) ; builder . append ( _str + t . substring ( t . length ( ) - _num ) ) ; } else { builder . append ( chr ) ; } break ; } } builder . append ( _str ) ; return builder . tostring ( ) ; }	escape a string to create a valid json string.
public void writeto ( outputstream out ) throws ioexception { bytestring [ ] cachedflushbuffers ; byte [ ] cachedbuffer ; int cachedbufferpos ; synchronized ( this ) { cachedflushbuffers = flushedbuffers . toarray ( new bytestring [ flushedbuffers . size ( ) ] ) ; cachedbuffer = buffer ; cachedbufferpos = bufferpos ; } for ( bytestring bytestring : cachedflushbuffers ) { bytestring . writeto ( out ) ; } out . write ( copyarray ( cachedbuffer , cachedbufferpos ) ) ; }	writes the complete contents of this byte array output stream to the specified output stream argument .
private void checkheadingshierarchy ( elements elements , testsolutionhandler testsolutionhandler ) { if ( elements . isempty ( ) ) { testsolutionhandler . addtestsolution ( testsolution . not_applicable ) ; return ; } testsolution checkresult = testsolution . passed ; iterator < element > iter = elements . iterator ( ) ; element element = iter . next ( ) ; int indexofreference = getheaderindex ( element ) ; int currentindex ; int previousindex = indexofreference ; element elementofreference = element ; element previouselement = element ; while ( iter . hasnext ( ) ) { element = iter . next ( ) ; currentindex = getheaderindex ( element ) ; if ( currentindex != - _num ) { if ( currentindex - previousindex >= _num ) { checkresult = testsolution . failed ; addsourcecoderemark ( testsolution . failed , element , header_not_hierarchically_well_defined_msg , getevidenceelement ( previous_h_tag_index_ee , getevidenceelementmsg ( previousindex , previouselement ) ) ) ; } else if ( currentindex < indexofreference ) { checkresult = testsolution . failed ; addsourcecoderemark ( testsolution . failed , element , header_not_hierarchically_well_defined_msg , getevidenceelement ( first_h_tag_index_ee , getevidenceelementmsg ( indexofreference , elementofreference ) ) ) ; } previousindex = currentindex ; previouselement = element ; } } testsolutionhandler . addtestsolution ( checkresult ) ; }	this methods checks whether the headings hierarchy is well - structured.
public iterator < jsonelement > iterator ( ) { return elements . iterator ( ) ; }	returns an iterator to navigate the elements of the array.
public void mousewheelmoved ( mousewheelevent e ) { boolean accepted = checkmodifiers ( e ) ; if ( accepted == _bool ) { visualizationviewer < ? , ? > vv = ( visualizationviewer < ? , ? > ) e . getsource ( ) ; point2d mouse = e . getpoint ( ) ; point2d center = vv . getcenter ( ) ; int amount = e . getwheelrotation ( ) ; if ( zoomatmouse ) { if ( amount > _num ) { scaler . scale ( vv , in , mouse ) ; } else if ( amount < _num ) { scaler . scale ( vv , out , mouse ) ; } } else { if ( amount > _num ) { scaler . scale ( vv , in , center ) ; } else if ( amount < _num ) { scaler . scale ( vv , out , center ) ; } } e . consume ( ) ; vv . repaint ( ) ; } }	zoom the display in or out , depending on the direction of the mouse wheel motion .
protected void assertfuncequals ( final string ... inputs ) throws exception { solrqueryrequest req = req ( ) ; try { assertfuncequals ( req , inputs ) ; } finally { req . close ( ) ; } }	the function name for val parser coverage checking is extracted from the first input.
public boolean equivalent ( imfmarkertype other ) { if ( other == null ) { return _bool ; } boolean result = _bool ; result &= offset . equals ( other . getoffset ( ) ) ; result &= label . equivalent ( other . getlabel ( ) ) ; return result ; }	a method to determine the equivalence of any two markers .
public static arraylist < long > loadworkspacescreensdb ( context context ) { final contentresolver contentresolver = context . getcontentresolver ( ) ; final uri screensuri = launchersettings . workspacescreens . content_uri ; final cursor sc = contentresolver . query ( screensuri , null , null , null , launchersettings . workspacescreens . screen_rank ) ; arraylist < long > screenids = new arraylist < long > ( ) ; try { final int idindex = sc . getcolumnindexorthrow ( launchersettings . workspacescreens . _id ) ; while ( sc . movetonext ( ) ) { try { screenids . add ( sc . getlong ( idindex ) ) ; } catch ( exception e ) { launcher . adddumplog ( tag , _str + _str + e , _bool ) ; } } } finally { if ( sc != null ) { sc . close ( ) ; } } return screenids ; }	loads the workspace screen ids in an ordered list .
private boolean renderoutput ( node node , internalcontextadapter context , writer writer ) throws ioexception , methodinvocationexception , resourcenotfoundexception { string arg = _str ; if ( node == null ) { rsvc . error ( _str ) ; return _bool ; } object value = node . value ( context ) ; if ( value == null ) { rsvc . error ( _str ) ; return _bool ; } arg = value . tostring ( ) ; resource resource = null ; try { resource = rsvc . getcontent ( arg , getinputencoding ( context ) ) ; } catch ( resourcenotfoundexception rnfe ) { rsvc . error ( _str + arg + _str + context . getcurrenttemplatename ( ) + _str + getline ( ) + _str + getcolumn ( ) + _str ) ; throw rnfe ; } catch ( exception e ) { rsvc . error ( _str + arg + _str + context . getcurrenttemplatename ( ) + _str + getline ( ) + _str + getcolumn ( ) + _str + e ) ; } if ( resource == null ) return _bool ; writer . write ( ( string ) resource . getdata ( ) ) ; return _bool ; }	does the actual rendering of the included file.
protected string e ( string s ) throws exception { return fmt . format ( parser . parse ( s , null ) ) ; }	macro : expected : parses s , fmts.
public matrix4 multiplybyscale ( double xscale , double yscale , double zscale ) { double [ ] m = this . m ; m [ _num ] *= xscale ; m [ _num ] *= xscale ; m [ _num ] *= xscale ; m [ _num ] *= xscale ; m [ _num ] *= yscale ; m [ _num ] *= yscale ; m [ _num ] *= yscale ; m [ _num ] *= yscale ; m [ _num ] *= zscale ; m [ _num ] *= zscale ; m [ _num ] *= zscale ; m [ _num ] *= zscale ; return this ; }	multiplies this matrix by a scale matrix with specified values .
public void changestate ( ) { linked = ! linked ; link = linked ? linkedimic . getimage ( ) : unlinkedimic . getimage ( ) ; repaint ( ) ; }	changes the lock icon ' s image to whatever it currently is not.
public static geometry bufferbysegments ( geometry g , double distance ) { geometry segs = linehandlingfunctions . extractsegments ( g ) ; double posdist = math . abs ( distance ) ; geometry segbuf = bufferbycomponents ( segs , posdist ) ; if ( distance < _num ) return g . difference ( segbuf ) ; return g . union ( segbuf ) ; }	buffer polygons by buffering the individual boundary segments and either unioning or differencing them .
public void recordendtime ( ) { int msdiff = ( int ) ( system . currenttimemillis ( ) - _currentrequeststarttime . get ( ) ) ; _log . info ( _str , msdiff ) ; updateorresetreqrspavglsthr ( updateorresetreqrspavglstmin ( msdiff , _bool ) , _bool ) ; updateminmaxreqrspms ( msdiff ) ; if ( msdiff >= suspiscious_rsp_time_ms ) { _alertlog . warn ( messageformat . format ( _str , msdiff ) ) ; } _currentrequeststarttime . remove ( ) ; }	computes the response time of the request that just finished for the local thread and updates the request response average in the last minute , and propagates to the request response per minute per hour counter.
private boolean isaccessibleusertokibana ( set < string > filters ) { if ( filters . contains ( _str ) ) { return _bool ; } return _bool ; }	check if an user has auth to kibana.
public boolean clear ( ) { try { list . clear ( ) ; firetabledatachanged ( ) ; } catch ( exception e ) { return _bool ; } return _bool ; }	remove all entries from the table list .
public static final int typeindex ( class type ) { class [ ] list = primitivetypes ; int n = list . length ; for ( int i = _num ; i < n ; i ++ ) if ( list [ i ] == type ) return i ; throw new runtimeexception ( _str + type . getname ( ) ) ; }	returns an index for accessing arrays in this class .
public boolean load ( file fi ) throws jmriconfigurexmlexception { return load ( fi , _bool ) ; }	load a file . < p > handles problems locally to the extent that it can , by routing them to the creationerrorencountered method .
public string parametertostring ( object param ) { if ( param == null ) { return _str ; } else if ( param instanceof date ) { return formatdate ( ( date ) param ) ; } else if ( param instanceof collection ) { stringbuilder b = new stringbuilder ( ) ; for ( object o : ( collection ) param ) { if ( b . length ( ) > _num ) { b . append ( _str ) ; } b . append ( string . valueof ( o ) ) ; } return b . tostring ( ) ; } else { return string . valueof ( param ) ; } }	format the given parameter object into string .
private void calculategridsizes ( float numbersradius , float xcenter , float ycenter , float textsize , float [ ] textgridheights , float [ ] textgridwidths ) { float offset1 = numbersradius ; float offset2 = numbersradius * ( ( float ) math . sqrt ( _num ) ) / _num ; float offset3 = numbersradius / _num ; mpaint . settextsize ( textsize ) ; ycenter -= ( mpaint . descent ( ) + mpaint . ascent ( ) ) / _num ; textgridheights [ _num ] = ycenter - offset1 ; textgridwidths [ _num ] = xcenter - offset1 ; textgridheights [ _num ] = ycenter - offset2 ; textgridwidths [ _num ] = xcenter - offset2 ; textgridheights [ _num ] = ycenter - offset3 ; textgridwidths [ _num ] = xcenter - offset3 ; textgridheights [ _num ] = ycenter ; textgridwidths [ _num ] = xcenter ; textgridheights [ _num ] = ycenter + offset3 ; textgridwidths [ _num ] = xcenter + offset3 ; textgridheights [ _num ] = ycenter + offset2 ; textgridwidths [ _num ] = xcenter + offset2 ; textgridheights [ _num ] = ycenter + offset1 ; textgridwidths [ _num ] = xcenter + offset1 ; }	using the trigonometric unit circle , calculate the positions that the text will need to be drawn at based on the specified circle radius.
public synchronized void flush ( ) throws ioexception { checknotclosed ( ) ; trimtosize ( ) ; trimtofilecount ( ) ; journalwriter . flush ( ) ; }	force buffered operations to the filesystem .
private final string [ ] _expandseennames ( string [ ] oldshared ) { int len = oldshared . length ; string [ ] newshared ; if ( len == _num ) { newshared = _smilebufferrecycler . allocseennamesbuffer ( ) ; if ( newshared == null ) { newshared = new string [ smilebufferrecycler . default_name_buffer_length ] ; } } else if ( len == smileconstants . max_shared_names ) { newshared = oldshared ; _seennamecount = _num ; } else { int newsize = ( len == smilebufferrecycler . default_string_value_buffer_length ) ? _num : smileconstants . max_shared_names ; newshared = new string [ newsize ] ; system . arraycopy ( oldshared , _num , newshared , _num , oldshared . length ) ; } return newshared ; }	method called to try to expand shared name area to fit one more potentially shared string . if area is already at its biggest size , will just clear the area ( by setting next - offset to 0 ).
public void addrequestproperty ( string key , string value ) { if ( connected ) throw new illegalstateexception ( _str ) ; if ( key == null ) throw new nullpointerexception ( _str ) ; if ( requests == null ) requests = new messageheader ( ) ; requests . add ( key , value ) ; }	adds a general request property specified by a key - value pair.
servermember update ( address clientaddress , instant time ) { if ( clientaddress != null ) { this . clientaddress = clientaddress ; if ( time . isafter ( updated ) ) { this . updated = assert . notnull ( time , _str ) ; } } return this ; }	updates the member client address .
public static boolean isorglevelonly ( int ad_client_id , int ad_table_id ) { boolean share = isshared ( ad_client_id , ad_table_id ) ; if ( share != null ) return ! share . booleanvalue ( ) ; return _bool ; }	is table org level only.
public runnable decrementasrunnable ( ) { return mdecrementrunnable ; }	convenience method to decrement this trigger as a runnable .
@ override public void actionperformed ( actionevent event ) { string command = event . getactioncommand ( ) ; if ( command . equals ( _str ) ) { attemptmodifybackgroundpaint ( ) ; } }	handles user interactions with the panel .
public byte [ ] serializetobuffer ( object o ) throws ioexception { bytearrayoutputstream bufout = new bytearrayoutputstream ( ) ; try { serialize ( bufout , o ) ; bufout . flush ( ) ; return bufout . tobytearray ( ) ; } finally { bufout . close ( ) ; } }	serializes the object into a byte buffer .
modulepointer resolve ( string modname ) { return ( modulepointer ) context . get ( modname ) ; }	find the modulepointer that the string modname resolves to ; return null if either modname is not found in the context or if it is found and resolves to null , i.
public void addcertstore ( certstore store ) { if ( store == null ) { return ; } if ( certstores == null ) { certstores = new arraylist < certstore > ( ) ; } certstores . add ( store ) ; }	adds a certificate store to the list of certificate stores that are used to find certificates and crls .
public narclassloader ( final file narworkingdirectory ) throws classnotfoundexception , ioexception { super ( new url [ _num ] ) ; this . narworkingdirectory = narworkingdirectory ; updateclasspath ( narworkingdirectory ) ; }	construct a nar class loader .
public block block ( ) { return block ; }	returns the basic block indicated by this node .
public static typebinding [ ] substitute ( substitution substitution , typebinding [ ] originaltypes ) { if ( originaltypes == null ) return null ; typebinding [ ] substitutedtypes = originaltypes ; for ( int i = _num , length = originaltypes . length ; i < length ; i ++ ) { typebinding originaltype = originaltypes [ i ] ; typebinding substitutedparameter = substitute ( substitution , originaltype ) ; if ( substitutedparameter != originaltype ) { if ( substitutedtypes == originaltypes ) { system . arraycopy ( originaltypes , _num , substitutedtypes = new typebinding [ length ] , _num , i ) ; } substitutedtypes [ i ] = substitutedparameter ; } else if ( substitutedtypes != originaltypes ) { substitutedtypes [ i ] = originaltype ; } } return substitutedtypes ; }	returns an array of types , where original types got substituted given a substitution.
private boolean checkifscrolling ( float [ ] lastpoints , motionevent ev ) { float [ ] point = new float [ _num ] ; point [ _num ] = ev . getrawx ( ) ; point [ _num ] = ev . getrawy ( ) ; float delta = getdistance ( lastpoints , point ) ; return math . abs ( delta ) > mslop ; }	checks to see if the user is currently scrolling the menu .
public void testmergeonefilterintodocumentwithsamefilter ( ) throws exception { string srcxml = _str + _str + _str + _str + _str + _str ; webxml srcwebxml = webxmlio . parsewebxml ( new bytearrayinputstream ( srcxml . getbytes ( _str ) ) , null ) ; webxml mergewebxml = webxmlio . parsewebxml ( new bytearrayinputstream ( srcxml . getbytes ( _str ) ) , null ) ; webxmlmerger merger = new webxmlmerger ( srcwebxml ) ; merger . mergefilters ( mergewebxml ) ; asserttrue ( webxmlutils . hasfilter ( srcwebxml , _str ) ) ; }	tests whether a single filter in the merge descriptor is ignored because a filter with the same name already exists in the source descriptor .
public edge ( s src , symbol symbol , s dest ) { this . src = src ; this . symbol = symbol ; this . dest = dest ; this . srcitem = src . getfirstitem ( ) ; this . hashcache = calchashcode ( ) ; }	edge which leads to another non - accepting state .
public void push ( final type value ) { if ( value == null ) { mv . visitinsn ( opcodes . aconst_null ) ; } else { switch ( value . getsort ( ) ) { case type . boolean : mv . visitfieldinsn ( opcodes . getstatic , _str , _str , cldesc ) ; break ; case type . char : mv . visitfieldinsn ( opcodes . getstatic , _str , _str , cldesc ) ; break ; case type . byte : mv . visitfieldinsn ( opcodes . getstatic , _str , _str , cldesc ) ; break ; case type . short : mv . visitfieldinsn ( opcodes . getstatic , _str , _str , cldesc ) ; break ; case type . int : mv . visitfieldinsn ( opcodes . getstatic , _str , _str , cldesc ) ; break ; case type . float : mv . visitfieldinsn ( opcodes . getstatic , _str , _str , cldesc ) ; break ; case type . long : mv . visitfieldinsn ( opcodes . getstatic , _str , _str , cldesc ) ; break ; case type . double : mv . visitfieldinsn ( opcodes . getstatic , _str , _str , cldesc ) ; break ; default : mv . visitldcinsn ( value ) ; } } }	generates the instruction to push the given value on the stack .
public extendedtextlabel createextended ( font font , coremetrics lm , decoration decorator , int start , int limit ) { if ( start >= limit || start < linestart || limit > linelimit ) { throw new illegalargumentexception ( _str + start + _str + limit ) ; } int level = linebidi == null ? _num : linebidi . getlevelat ( start - linestart ) ; int linedir = ( linebidi == null || linebidi . baseislefttoright ( ) ) ? _num : _num ; int layoutflags = flags & ~ _num ; if ( ( level & _num ) != _num ) layoutflags |= _num ; if ( ( linedir & _num ) != _num ) layoutflags |= _num ; textsource source = new standardtextsource ( text , start , limit - start , linestart , linelimit - linestart , level , layoutflags , font , frc , lm ) ; return new extendedtextsourcelabel ( source , decorator ) ; }	create an extended glyph array for the text between start and limit .
public static string rightpad ( string s , int minlength , char filling ) { int ln = s . length ( ) ; if ( minlength <= ln ) { return s ; } stringbuilder res = new stringbuilder ( minlength ) ; res . append ( s ) ; int dif = minlength - ln ; for ( int i = _num ; i < dif ; i ++ ) { res . append ( filling ) ; } return res . tostring ( ) ; }	pads the string at the right with the specified character until it reaches the desired length.
public final boolean issupported ( string feature , string version ) { return implementation . hasfeature ( feature , version ) ; }	ask whether we support a given dom feature.
public void clear ( ) { fullylock ( ) ; try { for ( node < e > p , h = head ; ( p = h . next ) != null ; h = p ) { h . next = h ; p . item = null ; } head = last ; if ( count . getandset ( _num ) == capacity ) notfull . signal ( ) ; } finally { fullyunlock ( ) ; } }	atomically removes all of the elements from this queue.
private static string readquoteddescriptor ( final substringreader reader , final boolean allowcompatchars ) throws decodeexception { int length = _num ; reader . skipwhitespaces ( ) ; try { char c = reader . read ( ) ; if ( c != _str ) { throw decodeexception . error ( err_attr_syntax_expected_quote_at_pos1 . get ( reader . pos ( ) - _num , c ) ) ; } reader . mark ( ) ; while ( ( c = reader . read ( ) ) != _str ) { if ( length == _num && ! isalpha ( c ) ) { throw decodeexception . error ( err_attr_syntax_illegal_char_in_string_oid1 . get ( c , reader . pos ( ) - _num ) ) ; } if ( ! iskeychar ( c , allowcompatchars ) ) { throw decodeexception . error ( err_attr_syntax_illegal_char_in_string_oid1 . get ( c , reader . pos ( ) - _num ) ) ; } length ++ ; } reader . reset ( ) ; final string descr = reader . read ( length ) ; reader . read ( ) ; return descr ; } catch ( final stringindexoutofboundsexception e ) { throw decodeexception . error ( err_attr_syntax_truncated_value1 . get ( ) ) ; } }	reads the value of a string enclosed in single quotes , skipping over the quotes and any leading spaces .
public string tocsv ( ) { stringbuilder builder = new stringbuilder ( ) ; builder . append ( _str ) ; builder . append ( _str ) ; for ( t predicted : classes ) { builder . append ( string . format ( _str , predicted ) ) ; } builder . append ( _str ) ; string firstcolumnlabel = _str ; for ( t actual : classes ) { builder . append ( firstcolumnlabel ) ; firstcolumnlabel = _str ; builder . append ( string . format ( _str , actual ) ) ; for ( t predicted : classes ) { builder . append ( getcount ( actual , predicted ) ) ; builder . append ( _str ) ; } builder . append ( getactualtotal ( actual ) ) ; builder . append ( _str ) ; } builder . append ( _str ) ; for ( t predicted : classes ) { builder . append ( getpredictedtotal ( predicted ) ) ; builder . append ( _str ) ; } builder . append ( _str ) ; return builder . tostring ( ) ; }	outputs the confusionmatrix as comma - separated values for easy import into spreadsheets.
public void testcase9 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = _num ; int bsign = _num ; byte rbytes [ ] = { _num , _num , _num , _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . subtract ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _num , result . signum ( ) ) ; }	subtract two positive numbers of different length.
public object assignidvalue ( object data , number val , objectcache objectcache ) throws sqlexception { object idval = datapersister . convertidnumber ( val ) ; if ( idval == null ) { throw new sqlexception ( _str + datapersister + _str + this ) ; } else { assignfield ( data , idval , _bool , objectcache ) ; return idval ; } }	assign an id value to this field .
public static void writeswappedinteger ( outputstream output , int value ) throws ioexception { output . write ( ( byte ) ( ( value > > _num ) & _num ) ) ; output . write ( ( byte ) ( ( value > > _num ) & _num ) ) ; output . write ( ( byte ) ( ( value > > _num ) & _num ) ) ; output . write ( ( byte ) ( ( value > > _num ) & _num ) ) ; }	writes a " int " value to an outputstream.
public final boolean isopen ( ) { return closed . get ( ) == _bool ; }	returns true if this lock is still open ie.
public static map < string , object > performfindlist ( dispatchcontext dctx , map < string , object > context ) { integer viewsize = ( integer ) context . get ( _str ) ; if ( viewsize == null ) viewsize = integer . valueof ( _num ) ; context . put ( _str , viewsize ) ; integer viewindex = ( integer ) context . get ( _str ) ; if ( viewindex == null ) viewindex = integer . valueof ( _num ) ; context . put ( _str , viewindex ) ; map < string , object > result = performfind ( dctx , context ) ; int start = viewindex . intvalue ( ) * viewsize . intvalue ( ) ; list < genericvalue > list = null ; integer listsize = _num ; try { entitylistiterator it = ( entitylistiterator ) result . get ( _str ) ; list = it . getpartiallist ( start + _num , viewsize ) ; listsize = it . getresultssizeafterpartiallist ( ) ; it . close ( ) ; } catch ( exception e ) { debug . loginfo ( _str + e , module ) ; } result . put ( _str , listsize ) ; result . put ( _str , list ) ; result . remove ( _str ) ; return result ; }	same as performfind but now returning a list instead of an iterator extra parameters viewindex : startpage of the partial list ( 0 = first page ) viewsize : the length of the page ( number of records ) extra output parameter : listsize : size of the totallist list : the list itself .
public static string soaptostring ( soapelement element ) { return domtostring ( element . getownerdocument ( ) ) ; }	converts a javax . xml . soap . soapelement to a string can be used for soapui requests be carefull : to convert a soapmessage sm , you must use sm . getsoappart ( ) . getenvelope ( ) ;.
@ override public void close ( ) throws ioexception { try { out . close ( ) ; } finally { lockfile . delete ( ) ; } }	closes the file writer and deletes the lockfile ( if possible ) .
public static void init ( context context ) { if ( cameramanager == null ) { cameramanager = new cameramanager ( context ) ; } }	initializes this static object with the context of the calling activity .
@ override public boolean equals ( object x , object y ) throws hibernateexception { if ( x == null ) { return y == null ; } return x . equals ( y ) ; }	compare two instances of the class mapped by this type for persistence " equality ".
@ override public final void writeboolean ( boolean v ) throws ioexception { dis . writeboolean ( v ) ; }	write a booleans as one byte .
public void train ( set < string > sfilenames ) { iterator < string > ifile = sfilenames . iterator ( ) ; while ( ifile . hasnext ( ) ) { string stext = utils . loadfiletostring ( ifile . next ( ) ) ; train ( stext ) ; } }	train the statistics of the chunker from a given file set .
public void testfindspringopenldapwithlimit ( ) { ldapproxy proxy = getldapopenldap ( ) ; list result = null ; int limit = _num ; try { result = proxy . find ( getldapsearchvo ( _str , limit , _str , _str , null , ldapscopeconstants . scope_subtree ) ) ; } catch ( exception e ) { } assertnotnull ( result ) ; if ( result != null ) { assertequals ( limit , result . size ( ) ) ; } }	test de busqueda open ldap con limite.
public printfformat ( string fmtarg ) throws illegalargumentexception { this ( locale . getdefault ( ) , fmtarg ) ; }	constructs an array of control specifications possibly preceded , separated , or followed by ordinary strings.
static double svd_pythag ( double a , double b ) { double p , r , s , t , u , temp ; p = svd_dmax ( math . abs ( a ) , math . abs ( b ) ) ; if ( p != _num ) { temp = svd_dmin ( math . abs ( a ) , math . abs ( b ) ) / p ; r = temp * temp ; t = _num + r ; while ( t != _num ) { s = r / t ; u = _num + _num * s ; p *= u ; temp = s / u ; r *= temp * temp ; t = _num + r ; } } return p ; }	funtions used - - - - - - - - - - - - - utility dmax , dmin.
public static void writefixint32 ( final outputstream output , final int val ) throws ioexception { output . write ( ( val > > > _num ) & _num ) ; output . write ( ( val > > > _num ) & _num ) ; output . write ( ( val > > > _num ) & _num ) ; output . write ( val & _num ) ; }	write a fixed - width 32 bit integer in network byte order ( big - endian ) .
public static void queuecubeload ( icubicworld world , cubeio loader , cubeproviderserver cache , int x , int y , int z , consumer < cube > runnable ) { queuedcube key = new queuedcube ( x , y , z , world ) ; asynccubeioprovider task = cubetasks . get ( key ) ; if ( task == null ) { task = new asynccubeioprovider ( key , loader ) ; task . addcallback ( runnable ) ; cubetasks . put ( key , task ) ; pool . execute ( task ) ; } else { task . addcallback ( runnable ) ; } column loadedcolumn ; if ( ( loadedcolumn = cache . getloadedcolumn ( x , z ) ) == null ) { cache . asyncgetcolumn ( x , z , iproviderextras . requirement . light , null ) ; } else { task . setcolumn ( loadedcolumn ) ; } }	queue a cube load , running the specified callback when the load has finished.
public static boolean isobjectavailablenow ( final boolean enabled , final date availablefrom , final date availableto , final date now ) { if ( ! enabled ) { return _bool ; } if ( availablefrom != null && now . before ( availablefrom ) ) { return _bool ; } if ( availableto != null && now . after ( availableto ) ) { return _bool ; } return _bool ; }	check availability of an object .
public void buttonclicked ( actionevent e ) ;	invoked when the button part is clicked .
private long loadlargestmessageid ( ) { releasemessage releasemessage = releasemessagerepository . findtopbyorderbyiddesc ( ) ; return releasemessage == null ? _num : releasemessage . getid ( ) ; }	find largest message id as the current start point.
public void removechangelistener ( changelistener l ) { if ( listeners == null ) return ; listeners . remove ( l ) ; }	removes a changelistener from this loader .
public static requestlog dump ( ) { requestlog current = rlog . get ( ) ; requestlog copy = new requestlog ( current ) ; current . clear ( ) ; rlog . remove ( ) ; return copy ; }	exports a snapshot of the request log of the current thread and also resets the request log for that thread .
public static string urldecode ( string str ) { try { return ( urldecoder . decode ( str , _str ) ) ; } catch ( exception e ) { return ( _str ) ; } }	description of the method.
public void testgettables ( ) throws exception { databasemetadata dmd = con . getmetadata ( ) ; resultset rs = dmd . gettables ( null , null , null , null ) ; assertnotnull ( rs ) ; rs . close ( ) ; }	test for bug [ 998765 ] exception with sybase and metadata . gettables ( ).
public void addall ( collection < ? extends t > collection ) { if ( meventdelegate != null ) meventdelegate . adddata ( collection == null ? _num : collection . size ( ) ) ; if ( collection != null && collection . size ( ) != _num ) { synchronized ( mlock ) { mobjects . addall ( collection ) ; } } if ( mnotifyonchange ) notifydatasetchanged ( ) ; }	adds the specified collection at the end of the array .
public static void resetcurrentfilelist ( string logname ) { currentfilelist . remove ( prefix + logname ) ; }	reset the current file list for the logger .
void initcomposestate ( ) { m_composestate = new composestate ( ) ; }	initialize a new composestate .
@ override public abstract list < jtoolbar > createtoolbars ( application a , @ nullable view p ) ;	creates toolbars for the application .
public static date parsedate ( string datevalue ) throws dateparseexception { return parsedate ( datevalue , null , null ) ; }	parses a date value.
public regexfilefilter ( string pattern , iocase casesensitivity ) { if ( pattern == null ) { throw new illegalargumentexception ( _str ) ; } int flags = _num ; if ( casesensitivity != null && ! casesensitivity . iscasesensitive ( ) ) { flags = pattern . case_insensitive ; } this . pattern = pattern . compile ( pattern , flags ) ; }	construct a new regular expression filter with the specified flags case sensitivity .
public static synchronized resultset executequery ( string sqlstatement ) { logger . trace ( string . format ( _str , sqlstatement ) ) ; resultset r = null ; final statement s = getstatement ( ) ; if ( s == null ) { logger . error ( _str ) ; return null ; } try { r = s . executequery ( sqlstatement ) ; logger . trace ( _str + ( null == r ) ) ; return r ; } catch ( throwable t ) { surfacethrowable ( string . format ( _str , sqlstatement ) , t ) ; cleanup ( s , r ) ; } return null ; }	this method is a thin wrapper for jdbc executequery ( ).
public void write ( byte [ ] buf ) throws ioexception { output . write ( buf ) ; byteswritten += buf . length ; }	counts the written bytes .
public static string urlencode ( @ nullable string s ) { if ( s == null ) { return _str ; } try { return urlencoder . encode ( s , _str ) ; } catch ( unsupportedencodingexception e ) { throw new assertionerror ( _str ) ; } }	url - encodes a nullable string , catching the useless exception that never happens .
public currency read ( string symbol ) { return currency . getinstance ( symbol ) ; }	this method is used to convert the string value given to an appropriate representation.
public static float parsefloat ( string s ) { if ( positive_infinity . equals ( s ) ) { return float . positive_infinity ; } else if ( negative_infinity . equals ( s ) ) { return float . negative_infinity ; } else if ( nan . equals ( s ) ) { return float . nan ; } else { s = trimplussign ( s ) ; return float . parsefloat ( s ) ; } }	parses the supplied xsd : float string and returns its value .
public object newinstance ( class javacontentinterface ) throws jaxbexception { if ( javacontentinterface == null ) { throw new jaxbexception ( messages . format ( messages . ci_not_null ) ) ; } try { class c = gi . getdefaultimplementation ( javacontentinterface ) ; if ( c == null ) throw new jaxbexception ( messages . format ( messages . missing_interface , javacontentinterface ) ) ; return c . newinstance ( ) ; } catch ( exception e ) { throw new jaxbexception ( e ) ; } }	create an instance of the specified java content interface .
public void requestpasswordforsharevialink ( boolean createshare ) { sharepassworddialogfragment dialog = sharepassworddialogfragment . newinstance ( mfile , createshare ) ; dialog . show ( getfragmentmanager ( ) , sharepassworddialogfragment . password_fragment ) ; }	starts a dialog that requests a password to the user to protect a share link .
private void forceoutofmemory ( ) { arraylist junk = new arraylist ( ) ; for ( ; ; ) { junk . add ( new long [ _num ] ) ; } }	allocate objects until death.
@ override public synchronized void put ( string key , entry entry ) { pruneifneeded ( entry . data . length ) ; file file = getfileforkey ( key ) ; try { bufferedoutputstream fos = new bufferedoutputstream ( new fileoutputstream ( file ) ) ; cacheheader e = new cacheheader ( key , entry ) ; boolean success = e . writeheader ( fos ) ; if ( ! success ) { fos . close ( ) ; volleylog . d ( _str , file . getabsolutepath ( ) ) ; throw new ioexception ( ) ; } fos . write ( entry . data ) ; fos . close ( ) ; putentry ( key , e ) ; return ; } catch ( ioexception e ) { } boolean deleted = file . delete ( ) ; if ( ! deleted ) { volleylog . d ( _str , file . getabsolutepath ( ) ) ; } }	puts the entry with the specified key into the cache .
public static double enlargementscaled ( spatialcomparable exist , spatialcomparable addit , double scale ) { final int dim = assertsamedimensionality ( exist , addit ) ; double v1 = _num ; double v2 = _num ; for ( int i = _num ; i < dim ; i ++ ) { final double emin = exist . getmin ( i ) ; final double emax = exist . getmax ( i ) ; final double amin = addit . getmin ( i ) ; final double amax = addit . getmax ( i ) ; final double min = math . min ( emin , amin ) ; final double max = math . max ( emax , amax ) ; v1 *= ( max - min ) * scale ; v2 *= ( emax - emin ) * scale ; } return v2 - v1 ; }	compute the enlargement obtained by adding an object to an existing object .
public void intersection ( rectangle2d r ) { if ( status == invalid ) return ; if ( status == empty ) { setclip ( r ) ; status = inuse ; return ; } clip [ _num ] = math . max ( clip [ _num ] , r . getminx ( ) ) ; clip [ _num ] = math . max ( clip [ _num ] , r . getminy ( ) ) ; clip [ _num ] = math . min ( clip [ _num ] , r . getmaxx ( ) ) ; clip [ _num ] = math . min ( clip [ _num ] , r . getmaxy ( ) ) ; }	intersect this clip with another region.
public boolean cangetint ( ) { return canget ( int . class ) ; }	indicates if convenience get method can be called without an exception being thrown for the int type .
private node addconditionwaiter ( ) { node t = lastwaiter ; if ( t != null && t . waitstatus != node . condition ) { unlinkcancelledwaiters ( ) ; t = lastwaiter ; } node node = new node ( thread . currentthread ( ) , node . condition ) ; if ( t == null ) firstwaiter = node ; else t . nextwaiter = node ; lastwaiter = node ; return node ; }	adds a new waiter to wait queue .
void clear ( ) ;	clears the ring buffer but moving the read position to the write position.
@ tcb static string stripbannedcodeunits ( string s ) { int safelimit = longestprefixofgoodcodeunits ( s ) ; if ( safelimit < _num ) { return s ; } stringbuilder sb = new stringbuilder ( s ) ; stripbannedcodeunits ( sb , safelimit ) ; return sb . tostring ( ) ; }	returns the portion of its input that consists of xml safe chars .
public static void assertlinewiseequals ( string message , string expected , string actual ) { try ( scanner expectedscanner = new scanner ( expected ) ; scanner actualscanner = new scanner ( actual ) ) { string expectedline = null ; string actualline = null ; int linecounter = _num ; while ( expectedscanner . hasnextline ( ) ) { expectedline = expectedscanner . nextline ( ) ; if ( actualscanner . hasnextline ( ) ) { actualline = actualscanner . nextline ( ) ; } else { fail ( _str + linecounter + _str + expectedline ) ; } assertequals ( _str + linecounter + _str + message + _str + expected + _str + actual , expectedline , actualline ) ; ++ linecounter ; } } }	compares a string linewise , i.
private void warning ( string msg , throwable th ) { warning ( msg ) ; th . printstacktrace ( ) ; }	used internally to log a message about the class at level warning , in case an exception was thrown.
public string fullform ( final string str , final string lowstring ) { string ret = lowstring ; prefixentry found = prefixmap . get ( str ) ; if ( found != null ) { ret = found . prefixsingular + ret ; } else { for ( prefixentry entry : prefixendlist ) { if ( str . endswith ( entry . keyword ) ) { ret = grammar . addprefixifnotalreadythere ( ret , entry . prefixsingular , entry . prefixplural ) ; break ; } } } return ret ; }	prefix one of the registered nouns with an expression like " piece of " .
public void clearpasswordexpirationwarnedtime ( ) { operations . add ( passwordpolicystateoperationtype . clear_password_expiration_warned_time ) ; }	clears the password expiration warned time .
private static locale strip ( locale locale ) { string language = locale . getlanguage ( ) ; string country = locale . getcountry ( ) ; string variant = locale . getvariant ( ) ; if ( ! variant . isempty ( ) ) { variant = _str ; } else if ( ! country . isempty ( ) ) { country = _str ; } else if ( ! language . isempty ( ) ) { language = _str ; } else { return null ; } return new locale ( language , country , variant ) ; }	returns a locale with the most - specific field removed , or null if this locale had an empty language , country and variant .
private void appendtimezone ( stringbuffer buffer , int count , boolean generaltimezone ) { if ( generaltimezone ) { timezone tz = calendar . gettimezone ( ) ; boolean daylight = ( calendar . get ( calendar . dst_offset ) != _num ) ; int style = count < _num ? timezone . short : timezone . long ; if ( ! formatdata . customzonestrings ) { buffer . append ( tz . getdisplayname ( daylight , style , formatdata . locale ) ) ; return ; } string custom = timezonenames . getdisplayname ( formatdata . zonestrings , tz . getid ( ) , daylight , style ) ; if ( custom != null ) { buffer . append ( custom ) ; return ; } } appendnumerictimezone ( buffer , count , generaltimezone ) ; }	append a representation of the time zone of ' calendar ' to ' buffer ' .
public void removelisteners ( ) { if ( globallistener != null ) { try { invokerhelper . invokemethod ( currentobject , _str , globallistener ) ; } catch ( exception e ) { } globallistener = null ; } if ( locallistener != null ) { try { invokerhelper . invokemethod ( currentobject , _str , new object [ ] { propertyname , locallistener } ) ; } catch ( exception e ) { } locallistener = null ; } if ( syntheticfullbinding != null ) { syntheticfullbinding . unbind ( ) ; } }	remove listeners , believing that our bould flags are accurate and it removes only as declared .
public static string padleft ( string str , int totalchars ) { if ( str == null ) str = _str ; stringbuilder sb = new stringbuilder ( ) ; for ( int i = _num ; i < totalchars - str . length ( ) ; i ++ ) { sb . append ( _str ) ; } sb . append ( str ) ; return sb . tostring ( ) ; }	pads the given string to the left with spaces to ensure that it ' s at least totalchars long .
public void showscores ( boolean flag ) { mshowscores = flag ; swingutilities . invokelater ( null ) ; }	set whether to show scores on the plot lines.
public static void write ( file file , charsequence data , boolean append ) throws ioexception { write ( file , data , charset . defaultcharset ( ) , append ) ; }	writes a charsequence to a file creating the file if it does not exist using the default encoding for the vm .
protected double kernelhelper ( int n , char [ ] s , int endindexs , char [ ] t , int endindext ) { if ( n <= _num ) { return getreturnvalue ( n ) ; } if ( math . min ( endindexs + _num , endindext + _num ) < n ) { return getreturnvalue ( n ) ; } int adr = _num ; if ( m_userecursioncache ) { adr = m_multx * n + m_multy * endindexs + m_multz * endindext ; if ( cachekhk [ adr % maxcache ] == adr + _num ) { return cachekh [ adr % maxcache ] ; } } double result = _num ; result = m_lambda * kernelhelper ( n , s , endindexs - _num , t , endindext ) + kernelhelper2 ( n , s , endindexs , t , endindext ) ; if ( m_userecursioncache ) { cachekhk [ adr % maxcache ] = adr + _num ; cachekh [ adr % maxcache ] = result ; } return result ; }	the kernel helper function , called k ' in [ 1 ] and [ 2 ] .
protected connection openh2connection ( boolean autocommit ) throws sqlexception { system . setproperty ( _str , _str ) ; string dbname = _str ; connection conn = drivermanager . getconnection ( _str + dbname + _str ) ; conn . setautocommit ( autocommit ) ; return conn ; }	gets connection from a pool .
private void emitclear ( string fieldname , stringbuilder builder ) { builder . append ( _str ) ; builder . append ( getclearname ( fieldname ) ) ; builder . append ( _str ) ; builder . append ( getensurename ( fieldname ) ) ; builder . append ( _str ) ; builder . append ( fieldname ) ; builder . append ( _str ) ; builder . append ( _str ) ; }	emits a method to clear a list or map.
protected void startrecoarding ( ) { coordinates . clear ( ) ; enabled = _bool ; }	start recording the gesture.
public void addinputmethodlistener ( inputmethodlistener l ) { m_textpane . addinputmethodlistener ( l ) ; }	add input method listener.
public void addfooterview ( view v , object data , boolean isselectable ) { fixedviewinfo info = new fixedviewinfo ( ) ; info . view = v ; info . data = data ; info . isselectable = isselectable ; mfooterviewinfos . add ( info ) ; if ( madapter != null && mobserver != null ) { mobserver . onchanged ( ) ; } }	add a fixed view to appear at the bottom of the list.
public static void load ( string url ) { string driver = getdriver ( url ) ; if ( driver != null ) { loaduserclass ( driver ) ; } }	load the driver class for the given url , if the database url is known .
public void adddocument ( document d ) { if ( ! m_readmode ) { try { writer . adddocument ( d ) ; m_hitcountcache . clear ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } else { throw new illegalstateexception ( _str + _str ) ; } }	add a document to the lucene search index .
protected void putcommand ( final class commandclass , final string [ ] names ) { check . istrue ( names . length > _num , _str ) ; _commandstocanonicalnames . put ( commandclass , names [ _num ] ) ; for ( int i = _num ; i < names . length ; i ++ ) { _aliasestocommands . put ( names [ i ] , commandclass ) ; } }	add a command in the hash map .
protected void writecolumnautoincrementstmt ( table table , column column , stringbuilder ddl ) { ddl . append ( _str ) ; }	prints that the column is an auto increment column .
private void savegcmdata ( ) { try { sharedpreferences preferences = getsharedpreferences ( ) ; sharedpreferences . editor editor = preferences . edit ( ) ; editor . putstring ( prefs_pusher_app_id_key , mpusherappid ) ; editor . putstring ( prefs_pusher_url_key , mpusherurl ) ; editor . putstring ( prefs_pusher_file_tag_key , mpusherbasefiletag ) ; editor . commit ( ) ; } catch ( exception e ) { log . e ( log_tag , _str + e . getlocalizedmessage ( ) ) ; } }	save the gcm info to the preferences.
public void writeblocklight ( bytebuf output ) { output . writebytes ( blocklight . gethandle ( ) ) ; }	write the block light to a buffer.
public string search ( ) throws exception { executequery ( ) ; return success ; }	execute a fulltextsearch from the request parameters.
public string next ( pattern pattern ) { checkopen ( ) ; checknotnull ( pattern ) ; matchsuccessful = _bool ; savecurrentstatus ( ) ; if ( ! settokenregion ( ) ) { recoverpreviousstatus ( ) ; throw new nosuchelementexception ( ) ; } matcher . usepattern ( pattern ) ; if ( ! matcher . matches ( ) ) { recoverpreviousstatus ( ) ; throw new inputmismatchexception ( ) ; } matchsuccessful = _bool ; return matcher . group ( ) ; }	returns the next token if it matches the specified pattern.
public void addnewduration ( long duration ) { callsnumber . incrementandget ( ) ; total . addandget ( duration ) ; synchronized ( lock ) { if ( duration < minimum . longvalue ( ) ) { minimum . set ( duration ) ; } if ( duration > maximum . longvalue ( ) ) { maximum . set ( duration ) ; } } }	add a new operation duration to this class . total is updated and calls is incremented.
private void paintbackgroundsolid ( graphics2d g , jcomponent c , int x , int y , int width , int height ) { color color = c . getbackground ( ) ; if ( type == commoncontrolstate . disabled ) { color = new color ( color . getred ( ) , color . getgreen ( ) , color . getblue ( ) , _num ) ; } shape s = shapegenerator . createroundrectangle ( x - _num , y - _num , width + _num , height + _num , cornersize . border ) ; g . setpaint ( color ) ; g . fill ( s ) ; if ( ispaintlineseperators ( c ) ) { paintlineseparator ( g , c , width , height ) ; } }	paint the background of an uneditable control , e.
public static void addattributedefaultvalues ( string servicename , string subschemaname , string schematype , string attributename , set defaultvalues ) throws upgradeexception { string classmethod = _str ; if ( debug . messageenabled ( ) ) { debug . message ( classmethod + _str ) ; debug . message ( _str + servicename + _str + attributename ) ; } serviceschema ss = getserviceschema ( servicename , subschemaname , schematype ) ; try { map attributedefaults = ss . getattributedefaults ( ) ; set oldattrvalues = ( set ) attributedefaults . get ( attributename ) ; set newattrvalues = ( ( oldattrvalues == null ) || oldattrvalues . isempty ( ) ) ? new hashset ( ) : new hashset ( oldattrvalues ) ; newattrvalues . addall ( defaultvalues ) ; ss . setattributedefaults ( attributename , newattrvalues ) ; } catch ( ssoexception ssoe ) { throw new upgradeexception ( _str ) ; } catch ( smsexception sme ) { throw new upgradeexception ( _str + _str ) ; } }	adds default values to an existing attribute.
private string encodeproduct ( ) { stringbuffer tokens = new stringbuffer ( ) ; listiterator it = producttokens . listiterator ( ) ; while ( it . hasnext ( ) ) { tokens . append ( ( string ) it . next ( ) ) ; } return tokens . tostring ( ) ; }	return canonical form . pmusgrave - put a space between products ( preserves format of header ).
public boolean ismetadatamodifiedsincelastpublication ( ) { return metadatamodifiedsincelastpublication ; }	called from manage resource page .
public options resourcedirs ( list < file > value ) { resourcedirs . clear ( ) ; resourcedirs . addall ( value ) ; return this ; }	sets the list of directories where the resources come from.
private static classnode maketype ( classnode cn , boolean usingclass ) { if ( usingclass ) { classnode clazztype = class_type . getplainnodereference ( ) ; clazztype . setgenericstypes ( new genericstype [ ] { new genericstype ( cn ) } ) ; return clazztype ; } else { return cn ; } }	wrap type in class & lt ; & gt ; if usingclass = = true.
void pushimporturl ( string hrefurl ) { m_importstack . push ( hrefurl ) ; }	push an import href onto the stylesheet stack .
protected string tomessage ( map < string , string > results ) { stringbuilder builder = new stringbuilder ( ) ; if ( results != null ) { for ( map . entry < string , string > entry : results . entryset ( ) ) { builder . append ( entry . getkey ( ) + _str + entry . getvalue ( ) + _str ) ; } } return builder . tostring ( ) ; }	returns a formatted string of the results .
public testtree sort ( ) { collections . sort ( suites ) ; suites . foreach ( null ) ; return this ; }	sorts the encapsulated test suites by their name in alphabetic order , then returns with the current ( sorted ) instance .
public static eventbean [ ] addtoarray ( eventbean [ ] array , collection < eventbean > eventstoadd ) { eventbean [ ] newarray = new eventbean [ array . length + eventstoadd . size ( ) ] ; system . arraycopy ( array , _num , newarray , _num , array . length ) ; int counter = array . length ; for ( eventbean eventtoadd : eventstoadd ) { newarray [ counter ++ ] = eventtoadd ; } return newarray ; }	expand the array passed in by the multiple elements to add .
public synchronized void add ( string name , long threadid ) { if ( mfinished ) { throw new illegalstateexception ( _str ) ; } mmarkers . add ( new marker ( name , threadid , systemclock . elapsedrealtime ( ) ) ) ; }	adds a marker to this log with the specified name .
public static string replace ( string a , string b , string c ) { stringbuilder result = new stringbuilder ( c . length ( ) ) ; int i = _num ; int j = c . indexof ( a ) ; while ( j >= i ) { result . append ( c . substring ( i , j ) ) ; result . append ( b ) ; i = j + a . length ( ) ; j = c . indexof ( a , i ) ; } result . append ( c . substring ( i , c . length ( ) ) ) ; return result . tostring ( ) ; }	replaces a with b in c .
private void reflectmembervariablesinfinalbutton ( ) { final boolean lastpagereached = ( viewpager . getcurrentitem ( ) + _num ) == pages . size ( ) ; final boolean buttonshouldbeinvisible = ! lastpagereached || finalbuttondisabled ; final boolean buttoniscurrentlyinvisible = finalbutton . getvisibility ( ) == view . invisible ; final boolean shouldupdatebutton = buttonshouldbeinvisible != buttoniscurrentlyinvisible ; if ( shouldupdatebutton ) { final animator buttonanimator = buttonshouldbeinvisible ? buttonanimatorfactory . newfinalbuttondisappearanimator ( finalbutton ) : buttonanimatorfactory . newfinalbuttonappearanimator ( finalbutton ) ; if ( buttonshouldbeinvisible ) { disablebutton ( buttonanimator , finalbutton ) ; } else { enablebutton ( buttonanimator , finalbutton ) ; } } }	enables or disables the final button , so that it matches the current member variables .
public void testdecoder6 ( ) { boolean res ; string originalappidname = mappidname ; int originalcontenttypevalue = mcontenttypevalue ; random rd = new random ( ) ; for ( int i = _num ; i < oma_application_id_names . length ; i ++ ) { mappidname = oma_application_id_names [ i ] ; mcontenttypevalue = rd . nextint ( _num ) ; byte [ ] pdu = createpdu ( _num ) ; wsptypedecoder pdudecoder = new wsptypedecoder ( pdu ) ; res = pdudecoder . seekxwapapplicationid ( mwspheaderstart , mwspheaderstart + mwspheaderlen - _num ) ; asserttrue ( res ) ; int index = ( int ) pdudecoder . getvalue32 ( ) ; res = pdudecoder . decodexwapapplicationid ( index ) ; asserttrue ( res ) ; log . d ( log_tag , _str + mappidname + _str + pdudecoder . getvaluestring ( ) + _str ) ; asserttrue ( mappidname . equals ( pdudecoder . getvaluestring ( ) ) ) ; } mappidname = originalappidname ; mcontenttypevalue = originalcontenttypevalue ; }	wsptypedecoder test , decode string appid test.
public final void removeall ( ) { actionlist . clear ( ) ; constraintslist . clear ( ) ; needsorting = _bool ; }	removes all children actions ( separators as well ) from the group .
private static boolean iswritable ( @ nonnull final file file ) { boolean isexisting = file . exists ( ) ; try { fileoutputstream output = new fileoutputstream ( file , _bool ) ; try { output . close ( ) ; } catch ( ioexception e ) { } } catch ( java . io . filenotfoundexception e ) { return _bool ; } boolean result = file . canwrite ( ) ; if ( ! isexisting ) { file . delete ( ) ; } return result ; }	check is a file is writable.
public gmpublishingpriority ( ) { }	creates a gm : publishing_priority tag .
private relyingparty validaterelyingparty ( httpservletrequest request , string tenantname ) { validate . notnull ( request , _str ) ; validate . notempty ( tenantname , _str ) ; defaultidmaccessorfactory idmfactory = new defaultidmaccessorfactory ( ) ; validate . notnull ( idmfactory , _str ) ; idmaccessor idmaccessor = idmfactory . getidmaccessor ( ) ; idmaccessor . settenant ( tenantname ) ; string encodedentityid = request . getparameter ( shared . relyingparty_entityid ) ; if ( encodedentityid == null || encodedentityid . isempty ( ) ) { logger . error ( _str ) ; return null ; } string rpentityid = new string ( base64 . decode ( encodedentityid ) ) ; relyingparty rp = idmaccessor . getrelyingpartybyurl ( rpentityid ) ; if ( rp != null ) { return rp ; } else { logger . error ( _str + rpentityid ) ; return null ; } }	this method validates the relying party .
public void rotatez ( double theta ) { matrix3d tmp = new matrix3d ( ) ; double c = math . cos ( theta ) ; double s = math . sin ( theta ) ; tmp . set ( _num , _num , c ) ; tmp . set ( _num , _num , - s ) ; tmp . set ( _num , _num , s ) ; tmp . set ( _num , _num , c ) ; premultiply ( tmp ) ; }	rotate transformation about the z axis.
public servicehost startfactory ( service instanceservice ) { final class < ? extends service > serviceclass = instanceservice . getclass ( ) ; return startfactory ( serviceclass , null ) ; }	starts a default factory service for the given instance service.
void wakeout ( ) { onavailable outflow = _outflow ; if ( outflow == null ) { return ; } if ( _creditsin <= _queue . head ( ) ) { return ; } stateoutpipe stateold ; stateoutpipe statenew ; do { stateold = _stateoutref . get ( ) ; if ( ! stateold . isfull ( ) ) { return ; } statenew = stateold . towake ( ) ; } while ( ! _stateoutref . compareandset ( stateold , statenew ) ) ; try ( outboxamp outbox = outboxamp . currentorcreate ( _outref . services ( ) ) ) { objects . requirenonnull ( outbox ) ; pipewakeoutmessage < t > msg = new pipewakeoutmessage < > ( outbox , _outref , this , outflow ) ; outbox . offer ( msg ) ; } }	notify the reader of available space in the pipe.
public static int columnsnumber ( char c , int x , int prevx , int plainspacesize ) { if ( c != _str ) { return _num ; } int result = ( x - prevx ) / plainspacesize ; if ( ( x - prevx ) % plainspacesize > _num ) { result ++ ; } return result ; }	allows to answer how many columns are necessary for representation of the given char on a screen .
private optional ( t value ) { this . value = objects . requirenonnull ( value ) ; }	constructs an instance with the value present .
public kafkamessagelistenercontainer ( consumerfactory < k , v > consumerfactory , containerproperties containerproperties , topicpartitioninitialoffset ... topicpartitions ) { super ( containerproperties ) ; assert . notnull ( consumerfactory , _str ) ; this . consumerfactory = consumerfactory ; if ( topicpartitions != null ) { this . topicpartitions = arrays . copyof ( topicpartitions , topicpartitions . length ) ; } else { this . topicpartitions = containerproperties . gettopicpartitions ( ) ; } }	construct an instance with the supplied configuration properties and specific topics / partitions / initialoffsets .
public void enginedeleteentry ( string alias ) throws keystoreexception { key k = ( key ) keys . remove ( alias ) ; certificate c = ( certificate ) certs . remove ( alias ) ; if ( c != null ) { chaincerts . remove ( new certid ( c . getpublickey ( ) ) ) ; } if ( k != null ) { string id = ( string ) localids . remove ( alias ) ; if ( id != null ) { c = ( certificate ) keycerts . remove ( id ) ; } if ( c != null ) { chaincerts . remove ( new certid ( c . getpublickey ( ) ) ) ; } } }	this is not quite complete - we should follow up on the chain , a bit tricky if a certificate appears in more than one chain.
private string tostring ( matcher m , int group ) { return ( group == _num ) ? _str : m . group ( group ) ; }	captures the group passed in by matching against a pattern .
public plalineint translate_by ( plavectorint p_vector ) { if ( p_vector . equals ( plavectorint . zero ) ) return this ; plapointint new_a = point_a . translate_by ( p_vector ) ; plapointint new_b = point_b . translate_by ( p_vector ) ; return new plalineint ( new_a , new_b ) ; }	translates the line by p_vector.
@ suppresswarnings ( _str ) final void reject ( runnable command ) { handler . rejectedexecution ( command , this ) ; }	invokes the rejected execution handler for the given command.
private int calculatemenumargin ( ) { windowmanager wm = ( windowmanager ) getsystemservice ( context . window_service ) ; display display = wm . getdefaultdisplay ( ) ; point size = new point ( ) ; display . getsize ( size ) ; int height = size . y ; return ( int ) math . round ( height * menu_margin_relative_modifier ) ; }	method that calculates space left for edittext when format text panel is visible.
public void addram ( attackaction ea ) { pendingrams . addelement ( ea ) ; processgameevent ( new gamenewactionevent ( this , ea ) ) ; }	adds a pending ramming attack to the list for this phase .
public static list < integer > createcolors ( resources r , int [ ] colors ) { list < integer > result = new arraylist < integer > ( ) ; for ( int i : colors ) { result . add ( r . getcolor ( i ) ) ; } return result ; }	turn an array of resource - colors ( contains resource - id integers ) into an array list of actual color integers.
public void testconfigfileproperty ( ) throws exception { file confighome = new file ( configuration . gethome ( ) ) ; asserttrue ( _str , confighome . exists ( ) && confighome . isdirectory ( ) ) ; file existingfile = createfile ( confighome , _str , _str ) ; assertequals ( _str , readfile ( existingfile ) ) ; string filename = _str ; string filecontents = _str ; file file = createfile ( configfiledirectory , filename , filecontents ) ; fileconfig configfile = new fileconfig ( ) ; configfile . setfile ( getabsolutepath ( file ) ) ; configfile . settofile ( _str ) ; configfile . setoverwrite ( _bool ) ; configfile . setconfigfile ( _bool ) ; configuration . setproperty ( _str , _str ) ; configuration . setconfigfileproperty ( configfile ) ; configuration . doconfigure ( null ) ; file copiedfile = new file ( configuration . gethome ( ) + _str ) ; asserttrue ( _str , copiedfile . exists ( ) ) ; assertequals ( _str , readfile ( copiedfile ) ) ; }	test configuration file property .
protected byte [ ] generatesalt ( ) { return header . getbytes ( constants . utf8 ) ; }	generate the random salt bytes if required .
public void addlistener ( final projectorlistener projectorlistener ) { if ( listeners == null ) { listeners = new arraylist < projectorlistener > ( ) ; } listeners . add ( projectorlistener ) ; }	add a projector listener .
protected tupleexpr selectnexttupleexpr ( list < tupleexpr > expressions , map < tupleexpr , double > cardinalitymap , map < tupleexpr , list < var > > varsmap , map < var , integer > varfreqmap , set < string > boundvars ) { tupleexpr result = null ; if ( expressions . size ( ) > _num ) { double lowestcardinality = double . positive_infinity ; for ( tupleexpr tupleexpr : expressions ) { double cardinality = gettupleexprcardinality ( tupleexpr , cardinalitymap , varsmap , varfreqmap , boundvars ) ; if ( cardinality < lowestcardinality || result == null ) { lowestcardinality = cardinality ; result = tupleexpr ; } } } else { result = expressions . get ( _num ) ; } return result ; }	selects from a list of tuple expressions the next tuple expression that should be evaluated.
public static void writebcdnumber ( outputstream os , string number ) throws ioexception { int bcd = _num ; int n = _num ; for ( int i = _num ; i < number . length ( ) ; i ++ ) { switch ( number . charat ( i ) ) { case _str : bcd |= _num ; break ; case _str : bcd |= _num ; break ; case _str : bcd |= _num ; break ; case _str : bcd |= _num ; break ; case _str : bcd |= _num ; break ; case _str : bcd |= _num ; break ; case _str : bcd |= _num ; break ; case _str : bcd |= _num ; break ; case _str : bcd |= _num ; break ; case _str : bcd |= _num ; break ; case _str : bcd |= _num ; break ; case _str : bcd |= _num ; break ; case _str : bcd |= _num ; break ; case _str : bcd |= _num ; break ; } n ++ ; if ( n == _num ) { os . write ( bcd ) ; n = _num ; bcd = _num ; } else { bcd >>= _num ; } } if ( n == _num ) { bcd |= _num ; os . write ( bcd ) ; } }	writes the given phonenumber to the stream ( bcd coded ).
public void addmessage ( string message ) { messages . addlast ( message ) ; if ( messages . size ( ) > max_history ) { messages . removefirst ( ) ; } pointer = messages . size ( ) ; }	add a message to the history.
@ visiblefortesting protected void startexecutor ( final int container ) { log . info ( _str + container ) ; final process containerexecutor = startexecutorprocess ( container ) ; processtocontainer . put ( containerexecutor , container ) ; log . info ( _str + container ) ; startexecutormonitor ( container , containerexecutor ) ; }	start the executor for the given container.
public static date stringtodate ( string s , dateformat formatter ) { try { return formatter . parse ( s ) ; } catch ( parseexception e ) { return null ; } }	convert a date time string ( e.
public void accept ( abstractreporter r ) { r . teststart ( this ) ; r . browserinfoentry ( browserinfoentry ) ; iterator < logentry > entryiterator = logentries . iterator ( ) ; while ( entryiterator . hasnext ( ) ) { logentry entry = entryiterator . next ( ) ; if ( ! entryiterator . hasnext ( ) ) { entry . setlast ( _bool ) ; } visit ( entry , r ) ; } r . testend ( this ) ; }	implementation of visitor pattern.
private void loadlatestextensionversions ( ) { try { list < extension > all = registrymanager . getextensions ( ) ; if ( ! all . isempty ( ) ) { setlatestextensionversions ( getlatestversions ( all ) ) ; } } catch ( registryexception e ) { string msg = registryexception . logregistryexception ( e . gettype ( ) , this ) ; warnings . addstartuperror ( msg ) ; log . error ( msg ) ; msg = gettext ( _str , new string [ ] { cfg . getregistryurl ( ) } ) ; warnings . addstartuperror ( msg ) ; log . error ( msg ) ; } finally { if ( getlatestextensionversions ( ) == null ) { setlatestextensionversions ( new arraylist < extension > ( ) ) ; } } }	reload the list of registered extensions , loading only the latest extension versions .
protected void startnode ( node node ) throws org . xml . sax . saxexception { if ( node instanceof locator ) { locator loc = ( locator ) node ; flocator . setcolumnnumber ( loc . getcolumnnumber ( ) ) ; flocator . setlinenumber ( loc . getlinenumber ( ) ) ; flocator . setpublicid ( loc . getpublicid ( ) ) ; flocator . setsystemid ( loc . getsystemid ( ) ) ; } else { flocator . setcolumnnumber ( _num ) ; flocator . setlinenumber ( _num ) ; } switch ( node . getnodetype ( ) ) { case node . document_type_node : serializedoctype ( ( documenttype ) node , _bool ) ; break ; case node . comment_node : serializecomment ( ( comment ) node ) ; break ; case node . document_fragment_node : break ; case node . document_node : break ; case node . element_node : serializeelement ( ( element ) node , _bool ) ; break ; case node . processing_instruction_node : serializepi ( ( processinginstruction ) node ) ; break ; case node . cdata_section_node : serializecdatasection ( ( cdatasection ) node ) ; break ; case node . text_node : serializetext ( ( text ) node ) ; break ; case node . entity_reference_node : serializeentityreference ( ( entityreference ) node , _bool ) ; break ; default : } }	start processing given node.
public void testclearbitnegativeinside2 ( ) { byte abytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = - _num ; int number = _num ; byte rbytes [ ] = { - _num , _num , - _num , - _num , _num , _num , - _num , - _num , - _num , - _num , _num , - _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . clearbit ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , result . signum ( ) ) ; }	clearbit ( int n ) inside a negative number.
public void testcomparegreaterscale2 ( ) { string a = _str ; int ascale = _num ; string b = _str ; int bscale = _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; int result = - _num ; assertequals ( _str , result , anumber . compareto ( bnumber ) ) ; }	compare to a number of an greater scale.
public int read ( ) throws ioexception { int val ; if ( ( val = is . read ( ) ) < _num ) { return - _num ; } if ( bo == _str ) { val = ( char ) ( ( val << _num ) | ( is . read ( ) & _num ) ) ; } else { val = ( char ) ( ( is . read ( ) << _num ) | ( val & _num ) ) ; } return val ; }	reads a single character .
public void cancelautocompletion ( ) { if ( incompletion ) { textfield . settext ( textbefore ) ; textfield . setcaretposition ( caretposbefore ) ; prevcompletion = null ; prevcompletionindex = _num ; incompletion = _bool ; } }	cancels the current completion , which means the state of the text is returned to what it was before completion and the info popup is closed if necessary .
public enumeration < option > listoptions ( ) { vector < option > result = new vector < option > ( ) ; result . add ( new option ( _str , _str , _num , _str ) ) ; result . addall ( collections . list ( super . listoptions ( ) ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
public clientpropertiesbuilder withproxyhostname ( string proxyhostname ) { properties . setproperty ( client_service_proxy_host_name , proxyhostname ) ; return this ; }	if a proxy is used to access the odata web service this specifies it ' s host name / ip address .
public static void verifysettermethods ( class < ? > clazz , mappedfield ... fields ) { string methodname = null ; string fieldname = null ; class < ? > fieldtype = null ; try { for ( mappedfield field : fields ) { fieldname = field . getname ( ) ; fieldtype = field . gettype ( ) ; string customset = field . setmethod ( ) ; if ( ! isnull ( customset ) && ! customset . equals ( constants . default_accessor_value ) ) try { clazz . getmethod ( customset , fieldtype ) ; field . setmethod ( customset ) ; continue ; } catch ( exception e ) { error . custommethod ( _str , customset , clazz ) ; } methodname = mset ( fieldname ) ; clazz . getmethod ( methodname , fieldtype ) ; field . setmethod ( methodname ) ; } } catch ( exception e ) { error . method ( methodname , fieldname , clazz ) ; } }	verifies that the setter methods are compliant with the naming convention .
private e dequeue ( ) { final object [ ] items = this . items ; @ suppresswarnings ( _str ) e x = ( e ) items [ takeindex ] ; items [ takeindex ] = null ; takeindex = inc ( takeindex ) ; count -- ; if ( itrs != null ) itrs . elementdequeued ( ) ; notfull . signal ( ) ; return x ; }	extracts element at current take position , advances , and signals.
static public string randompositivefloat ( int whole , int decimal ) { stringbuilder output = new stringbuilder ( ) ; output . append ( rnd . nextint ( _num ) + _num ) ; for ( int i = _num ; i < whole - _num ; i ++ ) { output . append ( rnd . nextint ( _num ) ) ; } output . append ( _str ) ; for ( int i = _num ; i < decimal ; i ++ ) { output . append ( rnd . nextint ( _num ) ) ; } return output . tostring ( ) ; }	get a random , positive float.
public void resettextboxindexesexcept ( set < integer > excludedlist ) { set < integer > unusedtextboxindexes = new hashset < integer > ( points . gettextboxindexes ( ) ) ; unusedtextboxindexes . removeall ( excludedlist ) ; for ( integer index : unusedtextboxindexes ) { points . removetextbox ( index ) ; } }	resets all textbox indexes except those which are contained in the excludedlist.
public idevice learnentity ( long macaddress , short vlan , integer ipv4address , long switchdpid , integer switchport , boolean processupdates ) { list < idevicelistener > listeners = devicelisteners . getorderedlisteners ( ) ; if ( ! processupdates ) { devicelisteners . clearlisteners ( ) ; } if ( vlan != null && vlan . shortvalue ( ) <= _num ) vlan = null ; if ( ipv4address != null && ipv4address == _num ) ipv4address = null ; idevice res = learndevicebyentity ( new entity ( macaddress , vlan , ipv4address , switchdpid , switchport , new date ( ) ) ) ; if ( listeners != null ) { for ( idevicelistener listener : listeners ) { devicelisteners . addlistener ( _str , listener ) ; } } return res ; }	learn a device using the given characteristics .
public double [ ] levelzerodata ( ) { list < buffer > levelzerobuffers = buffermap . get ( _num ) ; int length = _num ; for ( buffer buffer : levelzerobuffers ) { if ( ! buffer . hascapacity ( ) ) { length += buffer . size ; } else { length += buffer . next ; } } int pos = _num ; int currlen ; final double [ ] out = new double [ length ] ; for ( buffer buffer : levelzerobuffers ) { if ( ! buffer . hascapacity ( ) ) { currlen = buffer . size ; } else { currlen = buffer . next ; } system . arraycopy ( buffer . data , _num , out , pos , currlen ) ; pos += currlen ; } return out ; }	returns a fresh copy of all data from level 0 buffers .
public string [ ] showversion ( ) throws networkdevicecontrollerexception { string [ ] returnval = new string [ _num ] ; sshprompt [ ] prompts = { sshprompt . mds_pound , sshprompt . mds_greater_than } ; stringbuilder buf = new stringbuilder ( ) ; sshprompt prompt = sendwaitfor ( mdsdialogproperties . getstring ( _str ) , _num , prompts , buf ) ; string [ ] lines = getlines ( buf ) ; string [ ] regex = { mdsdialogproperties . getstring ( _str ) , mdsdialogproperties . getstring ( _str ) , mdsdialogproperties . getstring ( _str ) } ; string [ ] groups = new string [ _num ] ; for ( string line : lines ) { int index = match ( line , regex , groups ) ; switch ( index ) { case _num : returnval [ _num ] = groups [ _num ] ; break ; case _num : returnval [ _num ] = groups [ _num ] ; break ; case _num : returnval [ _num ] = groups [ _num ] ; break ; } } return returnval ; }	returns the device type and software version.
public static int countmatches ( string string , char c ) { int n = _num ; for ( char tc : string . tochararray ( ) ) { if ( c == tc ) n ++ ; } return n ; }	counts the amount of times a certain character is part of a string.
private imageicon addcolor ( imageicon icon , color color ) { if ( icon == null || color == null ) { return icon ; } bufferedimage newimage = new bufferedimage ( icon . geticonwidth ( ) , icon . geticonwidth ( ) , bufferedimage . type_int_argb ) ; graphics g = newimage . getgraphics ( ) ; g . setcolor ( color ) ; g . drawimage ( icon . getimage ( ) , _num , _num , color , null ) ; g . dispose ( ) ; return new imageicon ( newimage ) ; }	adds a background color to the given icon , if an icon and color is actually given , otherwise the original icon is returned .
public static byte [ ] readalllimited ( inputstream instr , int limit ) throws ioexception { bytearrayoutputstream buf = new bytearrayoutputstream ( ) ; pipealllimited ( instr , limit , buf ) ; return buf . tobytearray ( ) ; }	read from instr up to a maximum number of bytes , throwing an exception if more the maximum amount of requested data is available .
protected string searchfor ( final string target , string start ) { return searchfor ( target , null , start ) ; }	searches for the given target directory starting in the " plugins " subdirectory of the given location.
private int validatepreloadorder ( cacheconfiguration [ ] cfgs ) throws ignitecheckedexception { int maxorder = _num ; for ( cacheconfiguration cfg : cfgs ) { int rebalanceorder = cfg . getrebalanceorder ( ) ; if ( rebalanceorder > _num ) { if ( cfg . getcachemode ( ) == local ) throw new ignitecheckedexception ( _str + _str + u . maskname ( cfg . getname ( ) ) ) ; if ( cfg . getrebalancemode ( ) == cacherebalancemode . none ) throw new ignitecheckedexception ( _str + _str + u . maskname ( cfg . getname ( ) ) + _str + cfg . getrebalancemode ( ) + _str + cfg . getrebalanceorder ( ) + _str ) ; maxorder = math . max ( maxorder , rebalanceorder ) ; } else if ( rebalanceorder < _num ) throw new ignitecheckedexception ( _str + _str + u . maskname ( cfg . getname ( ) ) + _str + rebalanceorder + _str ) ; } return maxorder ; }	checks that preload - order - dependant caches has sync or async preloading mode .
public void execute ( ) { mplayer . setloopmode ( mdoloop ) ; mthread = new thread ( this , _str ) ; mthread . start ( ) ; }	creates a new thread , and starts execution of the player .
@ override public void removeenvvar ( envvar envvar ) { if ( envvar != null ) { envvarlist . remove ( envvar ) ; } }	removes the environment variable .
static private string calcthreshold ( double scorethreshold , double lambda ) { final double logprobthreshold = math . log ( _num - scorethreshold / _num ) ; int maxnum = _num ; if ( calclogprob ( maxnum , lambda ) > logprobthreshold ) { return _str ; } int minnum = _num ; while ( minnum < maxnum ) { final int midnum = ( maxnum + minnum ) / _num ; final boolean passthreshold = calclogprob ( midnum , lambda ) <= logprobthreshold ; if ( passthreshold ) { maxnum = midnum ; } else { if ( midnum == minnum ) { break ; } minnum = midnum ; } } return integer . tostring ( maxnum ) ; }	calculates the minimal number of instances required to achieve a score as high as the given scorethreshold for the given lambda .
private scope peek ( ) throws jsonexception { if ( stack . isempty ( ) ) { throw new jsonexception ( _str ) ; } return stack . get ( stack . size ( ) - _num ) ; }	returns the value on the top of the stack .
public void testissigned ( ) { try { assertfalse ( rsmd . issigned ( _num ) ) ; } catch ( sqlexception e1 ) { fail ( _str + e1 . getmessage ( ) ) ; e1 . printstacktrace ( ) ; } try { rsmd . issigned ( _num ) ; fail ( _str ) ; } catch ( sqlexception e ) { } }	tests fail : always returns false.
public static int indexoflastseparator ( string filename ) { if ( filename == null ) return - _num ; int lastunixpos = filename . lastindexof ( unix_separator ) ; int lastwindowspos = filename . lastindexof ( windows_separator ) ; return math . max ( lastunixpos , lastwindowspos ) ; }	returns the index of the last directory separator character.
public static boolean pointinview ( view v , float localx , float localy , float slop ) { return localx >= - slop && localy >= - slop && localx < ( v . getwidth ( ) + slop ) && localy < ( v . getheight ( ) + slop ) ; }	utility method to determine whether the given point , in local coordinates , is inside the view , where the area of the view is expanded by the slop factor.
private static type [ ] unrollbounds ( final map < typevariable < ? > , type > typearguments , final type [ ] bounds ) { type [ ] result = bounds ; int i = _num ; for ( ; i < result . length ; i ++ ) { final type unrolled = unrollvariables ( typearguments , result [ i ] ) ; if ( unrolled == null ) { result = arrayutils . remove ( result , i -- ) ; } else { result [ i ] = unrolled ; } } return result ; }	local helper method to unroll variables in a type bounds array .
public void deletequota ( string id ) throws isilonexception { delete ( _baseurl . resolve ( uri_quotas ) , id , _str ) ; }	delete a smart quota.
public static map < string , string > createbasicauthheader ( string username , string password , map < string , string > headermap ) { if ( headermap == null ) headermap = new hashmap < > ( ) ; string credentials = username + _str + password ; string base64encodedcredentials = base64 . encodetostring ( credentials . getbytes ( ) , base64 . no_wrap ) ; headermap . put ( _str , _str + base64encodedcredentials ) ; return headermap ; }	method to create a basic http base64 encrypted authentication header.
private void addextententry ( ) { extentmodel . addnewentry ( ) ; removeextentbutton . setenabled ( _bool ) ; }	adds a new extent entry .
private transportnetwork checkcached ( string networkid ) { try { string filename = networkid + _str + r5version . version + _str ; file cachelocation = new file ( cachedir , networkid + _str + r5version . version + _str ) ; if ( cachelocation . exists ( ) ) log . info ( _str , cachelocation ) ; else { log . info ( _str , cachelocation ) ; if ( sourcebucket != null ) { log . info ( _str ) ; s3object tn ; try { tn = s3 . getobject ( sourcebucket , filename ) ; } catch ( amazonserviceexception ex ) { log . info ( _str ) ; return null ; } cachedir . mkdirs ( ) ; log . info ( _str , cachelocation ) ; fileoutputstream fos = new fileoutputstream ( cachelocation ) ; inputstream is = tn . getobjectcontent ( ) ; try { bytestreams . copy ( is , fos ) ; } finally { is . close ( ) ; fos . close ( ) ; } } else { log . info ( _str ) ; return null ; } } log . info ( _str , cachelocation ) ; fileinputstream fis = new fileinputstream ( cachelocation ) ; try { return transportnetwork . read ( fis ) ; } finally { fis . close ( ) ; } } catch ( exception e ) { log . error ( _str , e ) ; return null ; } }	if this transport network is already built and cached , fetch it quick.
void readfile ( file file ) throws org . jdom2 . jdomexception , java . io . ioexception { xmlfile xf = new xmlfile ( ) { } ; xf . rootfromfile ( file ) ; }	ask sax to read and verify a file.
public boolean isallgranted ( ) { int count = _num ; for ( int i = _num ; i < mperms . size ( ) ; i ++ ) { if ( mperms . get ( muserpermission . get ( i ) ) == packagemanager . permission_granted ) count ++ ; } return count == mperms . size ( ) ; }	is all granted boolean .
protected void execute ( runnable evt ) { executor . execute ( evt ) ; }	fires a event on the executor thread.
private void sendnextmessageovernetwork ( ) throws exception { rawdata raw = outgoing . take ( ) ; if ( raw == null ) throw new nullpointerexception ( ) ; sendnext ( raw ) ; }	get the next message from the outgoing queue and send it over the network .
public void addattributefor ( final field field ) { fieldtouseasattribute . add ( field ) ; }	tells this mapper to use an attribute for this field .
public boolean issessiontoken ( string token ) { synchronized ( sessiontokens ) { return sessiontokens . contains ( token ) ; } }	checks if is session token .
public static double rootmeanssquarederror ( double [ ] real , double [ ] predicted ) { double ret = _num ; for ( int i = _num ; i < real . length ; i ++ ) { ret += math . pow ( ( real [ i ] - predicted [ i ] ) , _num ) ; } return math . sqrt ( ret / real . length ) ; }	this returns the root mean squared error of two data sets.
public void export ( bytebuffer buf ) { buf . putint ( seqid ) ; if ( info . isrowblockenabled ( ) ) buf . putint ( nrows ) ; export ( primarykey , buf ) ; for ( bytearray cb : cellblocks ) { export ( cb , buf ) ; } }	write data to given buffer , like serialize.
private hashmap < string , object > createaccdetailmap ( string glcode , bigdecimal debitamount , bigdecimal creditamount ) { hashmap < string , object > accountdetailmap = new hashmap < string , object > ( ) ; accountdetailmap . put ( voucherconstant . glcode , glcode ) ; accountdetailmap . put ( voucherconstant . debitamount , debitamount ) ; accountdetailmap . put ( voucherconstant . creditamount , creditamount ) ; accountdetailmap . put ( voucherconstant . functioncode , getfunctionarycode ( ) ) ; return accountdetailmap ; }	creates account details map.
private void rotateright ( node < k , v > root ) { node < k , v > pivot = root . left ; node < k , v > right = root . right ; node < k , v > pivotleft = pivot . left ; node < k , v > pivotright = pivot . right ; root . left = pivotright ; if ( pivotright != null ) { pivotright . parent = root ; } replaceinparent ( root , pivot ) ; pivot . right = root ; root . parent = pivot ; root . height = math . max ( right != null ? right . height : _num , pivotright != null ? pivotright . height : _num ) + _num ; pivot . height = math . max ( root . height , pivotleft != null ? pivotleft . height : _num ) + _num ; }	rotates the subtree so that its root ' s left child is the new root .
private void updateradiolinks ( ) { m_advancedatasetfirst . setenabled ( m_generatorpropertypanel . geteditoractive ( ) ) ; m_advanceiteratorfirst . setenabled ( m_generatorpropertypanel . geteditoractive ( ) ) ; if ( m_exp != null ) { if ( ! m_generatorpropertypanel . geteditoractive ( ) ) { m_exp . setadvancedatasetfirst ( _bool ) ; } else { m_exp . setadvancedatasetfirst ( m_advancedatasetfirst . isselected ( ) ) ; } } }	updates the primary loop iteration control of the experiment.
public void update ( long value ) { count . incrementandget ( ) ; sample . update ( value ) ; setmax ( value ) ; setmin ( value ) ; sum . getandadd ( value ) ; updatevariance ( value ) ; }	adds a recorded value .
@ override public void drawseries ( canvas canvas , paint paint , list < float > points , xyseriesrenderer renderer , float yaxisvalue , int seriesindex , int startindex ) { paint . setcolor ( renderer . getcolor ( ) ) ; paint . setstyle ( style . fill ) ; int length = points . size ( ) ; xyvalueseries series = ( xyvalueseries ) mdataset . getseriesat ( seriesindex ) ; double max = series . getmaxvalue ( ) ; double coef = max_bubble_size / max ; for ( int i = _num ; i < length ; i += _num ) { double size = series . getvalue ( startindex + i / _num ) * coef + min_bubble_size ; drawcircle ( canvas , paint , points . get ( i ) , points . get ( i + _num ) , ( float ) size ) ; } }	the graphical representation of a series .
public static void checkclasssignature ( final string signature ) { int pos = _num ; if ( getchar ( signature , _num ) == _str ) { pos = checkformaltypeparameters ( signature , pos ) ; } pos = checkclasstypesignature ( signature , pos ) ; while ( getchar ( signature , pos ) == _str ) { pos = checkclasstypesignature ( signature , pos ) ; } if ( pos != signature . length ( ) ) { throw new illegalargumentexception ( signature + _str + pos ) ; } }	checks a class signature .
public static byte [ ] select ( string appid , string suffix ) { string cardletaid = fidesmo_aid_prefix + appid + suffix ; return select ( cardletaid ) ; }	builds the select command apdu from a cardlet ' s app id : - builds the cardlet ' s aid appending the fidesmo prefix and a suffix - builds the command concatenating the header , aid lenght and aid.
void internaladdrootentry ( projectcomparisonentry entry ) { entries . add ( entry ) ; }	should only be invoked from projectcomparisonentry.
public static source fromurl ( url url , charset cs ) throws ioexception { uri uri ; try { uri = url . touri ( ) ; } catch ( urisyntaxexception e ) { throw new ioexception ( _str , e ) ; } try ( inputstream is = url . openstream ( ) ) { return fromstream ( is , uri , cs ) ; } }	creates a new source object from a url.
public void testmergeoneservletintodocumentwithanotherservlet ( ) throws exception { string srcxml = _str + _str + _str + _str + _str + _str ; webxml srcwebxml = webxmlio . parsewebxml ( new bytearrayinputstream ( srcxml . getbytes ( _str ) ) , null ) ; string mergexml = _str + _str + _str + _str + _str + _str ; webxml mergewebxml = webxmlio . parsewebxml ( new bytearrayinputstream ( mergexml . getbytes ( _str ) ) , null ) ; webxmlmerger merger = new webxmlmerger ( srcwebxml ) ; merger . merge ( mergewebxml ) ; asserttrue ( webxmlutils . hasservlet ( srcwebxml , _str ) ) ; asserttrue ( webxmlutils . hasservlet ( srcwebxml , _str ) ) ; }	tests whether a single servlet is correctly merged into a descriptor that already contains the definition of an other servlet .
public re extractre ( ) throws interruptedexception { arden ( ) ; if ( ! coeffs . isempty ( ) ) { throw new runtimeexception ( _str ) ; } return unionres ( terms ) ; }	extract the regular expression associated with this recursive production.
@ deprecated public static void runfinalizersonexit ( boolean run ) { finalizeonexit = run ; }	sets the flag that indicates whether all objects are finalized when the vm is about to exit.
public void addresult ( amidentity id , map attrs ) { searchresults . add ( id ) ; resultsmap . put ( id , attrs ) ; }	adds an amidentity object to this search result .
public < t extends intentionaction & localquickfix > void registerbatchfix ( @ notnull t fix , @ nullable textrange range , @ nullable final highlightdisplaykey key ) { if ( range == null ) { range = new textrange ( mystartoffset , myendoffset ) ; } if ( mybatchfixes == null ) { mybatchfixes = new arraylist < quickfixinfo > ( ) ; } mybatchfixes . add ( new quickfixinfo ( fix , range , key ) ) ; }	registers a quickfix which would be available during batch mode only , in particular during com.
protected void createfile ( zipentry entry ) { ipath pathname = new path ( entry . getname ( ) ) ; zipentry parent ; if ( pathname . segmentcount ( ) == _num ) { parent = root ; } else { parent = ( zipentry ) directoryentrycache . get ( pathname . removelastsegments ( _num ) ) ; } addtochildren ( parent , entry ) ; }	creates a new file zip entry with the specified name .
public void testhasattributes1 ( ) throws throwable { document doc ; nodelist addrlist ; node addrnode ; boolean state ; doc = ( document ) load ( _str , builder ) ; addrlist = doc . getelementsbytagname ( _str ) ; addrnode = addrlist . item ( _num ) ; state = addrnode . hasattributes ( ) ; assertfalse ( _str , state ) ; }	runs the test case .
public void startdocument ( xmllocator locator , string encoding , namespacecontext namespacecontext , augmentations augs ) throws xniexception { fnamespacecontext = namespacecontext ; try { if ( fdocumenthandler != null ) { if ( locator != null ) { fdocumenthandler . setdocumentlocator ( new locatorproxy ( locator ) ) ; } fdocumenthandler . startdocument ( ) ; } if ( fcontenthandler != null ) { if ( locator != null ) { fcontenthandler . setdocumentlocator ( new locatorproxy ( locator ) ) ; } fcontenthandler . startdocument ( ) ; } } catch ( saxexception e ) { throw new xniexception ( e ) ; } }	the start of the document .
@ override public string dumpwindowhierarchy ( boolean compressed ) { device . setcompressedlayoutheirarchy ( compressed ) ; try { bytearrayoutputstream os = new bytearrayoutputstream ( ) ; device . dumpwindowhierarchy ( os ) ; os . close ( ) ; return os . tostring ( _str ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } finally { device . setcompressedlayoutheirarchy ( _bool ) ; } return null ; }	helper method used for debugging to dump the current window ' s layout hierarchy .
public void registerobserver ( rulechangesobserver observer ) { observers . add ( observer ) ; }	registers an observer to be notified on routing rules changes .
private void sendupdateheartbeats ( ) { heartbeatservicelocal heartbeat = _bartender . getheartbeatlocal ( ) ; if ( heartbeat != null ) { heartbeat . updateheartbeats ( ) ; } }	send a heartbeat with the updated pods to other servers in the cluster.
public void serialize ( string name , byte [ ] message , outputstream out ) throws ioexception { byte [ ] header = new byte [ _num + command_len + _num + _num ] ; uint32tobytearraybe ( params . getpacketmagic ( ) , header , _num ) ; for ( int i = _num ; i < name . length ( ) && i < command_len ; i ++ ) { header [ _num + i ] = ( byte ) ( name . codepointat ( i ) & _num ) ; } utils . uint32tobytearrayle ( message . length , header , _num + command_len ) ; byte [ ] hash = doubledigest ( message ) ; system . arraycopy ( hash , _num , header , _num + command_len + _num , _num ) ; out . write ( header ) ; out . write ( message ) ; if ( log . isdebugenabled ( ) ) log . debug ( _str , name , bytestohexstring ( header ) + bytestohexstring ( message ) ) ; }	writes message to to the output stream .
public sslengine initsslengine ( boolean client ) throws exception { keystore keystore = loadkeystore ( properties . sslkeystorepath ( ) , properties . sslkeystorepassword ( ) ) ; keymanagerfactory keymanagerfactory = keymanagerfactory . getinstance ( keymanagerfactory . getdefaultalgorithm ( ) ) ; keymanagerfactory . init ( keystore , keystorekeypass ( properties ) ) ; keystore truststore ; if ( properties . ssltruststorepath ( ) != null ) { logger . debug ( _str ) ; truststore = loadkeystore ( properties . ssltruststorepath ( ) , properties . ssltruststorepassword ( ) ) ; } else { truststore = keystore ; logger . debug ( _str ) ; } trustmanagerfactory trustmanagerfactory = trustmanagerfactory . getinstance ( trustmanagerfactory . getdefaultalgorithm ( ) ) ; trustmanagerfactory . init ( truststore ) ; keymanager [ ] keymanagers = keymanagerfactory . getkeymanagers ( ) ; trustmanager [ ] trustmanagers = trustmanagerfactory . gettrustmanagers ( ) ; sslcontext sslcontext = sslcontext . getinstance ( _str ) ; sslcontext . init ( keymanagers , trustmanagers , null ) ; sslengine sslengine = sslcontext . createsslengine ( ) ; sslengine . setuseclientmode ( client ) ; sslengine . setwantclientauth ( _bool ) ; sslengine . setenabledprotocols ( sslengine . getsupportedprotocols ( ) ) ; sslengine . setenabledciphersuites ( sslengine . getsupportedciphersuites ( ) ) ; sslengine . setenablesessioncreation ( _bool ) ; return sslengine ; }	initializes an ssl engine .
public getbufferedrandomaccesssource ( irandomaccesssource source ) { this . source = source ; this . getbuffer = new byte [ ( int ) math . min ( math . max ( source . length ( ) / _num , _num ) , _num ) ] ; this . getbufferstart = - _num ; this . getbufferend = - _num ; }	constructs a new offsetrandomaccesssource.
public argparser ( string pname ) { programname = pname ; args = new vector ( ) ; args . add ( new helparg ( ) ) ; }	create a parser for the named program.
public void testsetbitzero ( ) { byte abytes [ ] = { _num } ; int asign = _num ; int number = _num ; byte rbytes [ ] = { _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . setbit ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	setbit ( int n ) outside zero.
public static void savexstream ( file saveto , object model , instances header ) throws exception { vector < object > v = new vector < object > ( ) ; v . add ( model ) ; if ( header != null ) { v . add ( header ) ; } v . trimtosize ( ) ; xstream . write ( saveto . getabsolutepath ( ) , v ) ; }	save a model in xstream deep object serialized xml form .
private void sortandcollapse ( ) { collections . sort ( mspans ) ; maddssincesort = _num ; iterator iter = mspans . iterator ( ) ; span span = null ; if ( iter . hasnext ( ) ) { span = ( span ) iter . next ( ) ; } while ( iter . hasnext ( ) ) { span nextspan = ( span ) iter . next ( ) ; if ( span . subsume ( nextspan ) ) { iter . remove ( ) ; } else { span = nextspan ; } } }	sort the spans in ascending order by their start position.
public int splitrandomly ( arraymodifiabledbids ind , int begin , int end , doubledatastore tpro , random rand ) { final int nele = end - begin ; dbidarrayiter it = ind . iter ( ) ; double rs = tpro . doublevalue ( it . seek ( begin + rand . nextint ( nele ) ) ) ; int minind = begin , maxind = end - _num ; while ( minind < maxind ) { double currele = tpro . doublevalue ( it . seek ( minind ) ) ; if ( currele > rs ) { while ( minind < maxind && tpro . doublevalue ( it . seek ( maxind ) ) > rs ) { maxind -- ; } if ( minind == maxind ) { break ; } ind . swap ( minind , maxind ) ; maxind -- ; } minind ++ ; } if ( minind == end - _num ) { minind = ( begin + end ) > > > _num ; } return minind ; }	split the data set randomly .
public static string noprefix ( string path , string prefix ) { objects . requirenonnull ( path , _str ) ; objects . requirenonnull ( prefix , _str ) ; return path . startswith ( prefix ) ? path . substring ( prefix . length ( ) ) : path ; }	drops a prefix from a path if it exists or returns original path if prefix does not match .
protected void publish ( ) throws mqttexception , ioexception { sampleclientpub = new sampleasynccallback ( url , clientidpub , cleansession , quietmode , username , password ) ; if ( sampleclientpub != null ) { string topic = _str ; int qos = _num ; string message = _str ; try { sampleclientpub . publish ( topic , qos , message . getbytes ( ) ) ; } catch ( throwable e ) { e . printstacktrace ( ) ; } } }	publish / send a message to an mqtt server.
public void remove ( iadaptable a ) { children . remove ( a ) ; }	adds the given adaptable object to this list .
public static intstream concat ( intstream a , intstream b ) { objects . requirenonnull ( a ) ; objects . requirenonnull ( b ) ; spliterator . ofint split = new streams . concatspliterator . ofint ( a . spliterator ( ) , b . spliterator ( ) ) ; intstream stream = streamsupport . intstream ( split , a . isparallel ( ) || b . isparallel ( ) ) ; return stream . onclose ( streams . composedclose ( a , b ) ) ; }	creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream.
public boolean equals ( string expected , string actual ) { return framework . equals ( expected , actual ) ; }	compares the values of actual and expected .
public loginconfiguration forceauth ( string forceauthreqparam ) { forceauth = boolean . parseboolean ( forceauthreqparam ) ; return this ; }	sets the request ' s forceauth parameter .
public userconfig fetch ( userconfig config ) { config . addcredentials ( this ) ; string xml = post ( this . url + _str , config . toxml ( ) ) ; element root = parse ( xml ) ; if ( root == null ) { return null ; } try { userconfig user = new userconfig ( ) ; user . parsexml ( root ) ; return user ; } catch ( exception exception ) { this . exception = sdkexception . parsefailure ( exception ) ; throw this . exception ; } }	fetch the user details for the user credentials.
@ methoddesc ( description = _str , usage = _str ) public void stop ( ) throws exception { try { handleeventsynchronous ( new stopevent ( ) ) ; if ( donelatch != null ) { donelatch . countdown ( ) ; } } catch ( exception e ) { logger . error ( _str , e ) ; throw new exception ( e . tostring ( ) ) ; } }	stop replicator node manager jmx service .
@ override public void pushmessageasync ( message msg ) throws org . apache . thrift . texception { pushmessagesync ( msg ) ; return ; }	the implementation for pushmessageasync ( ) function .
public boolean writecharacteristic ( string address , string serviceuuid , string characteristicuuid , byte [ ] value ) { bluetoothgatt bluetoothgatt = mbluetoothgattmap . get ( address ) ; if ( bluetoothgatt != null ) { bluetoothgattservice service = bluetoothgatt . getservice ( uuid . fromstring ( serviceuuid ) ) ; bluetoothgattcharacteristic characteristic = service . getcharacteristic ( uuid . fromstring ( characteristicuuid ) ) ; characteristic . setvalue ( value ) ; return bluetoothgatt . writecharacteristic ( characteristic ) ; } return _bool ; }	write data to characteristic , and send to remote bluetooth le device .
public string linkformessage ( protoelement element ) { if ( isexternalfile ( element . getfile ( ) ) ) { string fullname = element . getfullname ( ) ; return string . format ( _str , fullname , fullname ) ; } else { string simplename = element . getsimplename ( ) ; return string . format ( _str , simplename , simplename ) ; } }	returns the jsdoc format of link to the element .
public static < t > arraylist < t > read ( inputstream filestream , string charsetname , itransformer < string , t > transformer ) throws filenotfoundexception { scanner scanner = new scanner ( filestream , charsetname ) ; arraylist < t > list = new arraylist < > ( ) ; while ( scanner . hasnextline ( ) ) { string line = scanner . nextline ( ) ; list . add ( transformer . transform ( line ) ) ; } scanner . close ( ) ; return list ; }	this function reads an inputstream line - by - line and converts each line into an object using a transformer that is passed as a parameter .
public boolean remove ( jsonelement element ) { return elements . remove ( element ) ; }	removes the first occurrence of the specified element from this array , if it is present.
public tsink < byte [ ] > sendbytes ( tstream < byte [ ] > stream ) { objects . requirenonnull ( stream , _str ) ; return sendbinary ( stream , null ) ; }	send a stream ' s byte [ ] tuples in a websocket binary message .
private void sortbrokeritems ( brokeritem [ ] brokeritems , int sorttype ) { arrays . sort ( brokeritems , brokeritem . getcomparatorybytype ( sorttype ) ) ; }	perform sorting according to sort type.
protected boolean needtoescapexmlspecialcharacters ( string hostentityid , string remoteentityid , string realm ) { return _bool ; }	decides whether it needs to escape xml special characters for attribute values or not .
private void updatepathconstraints ( testchromosome test ) { list < branchcondition > pathcondition = concolicexecution . getsymbolicpath ( test ) ; pathconditions . put ( test , pathcondition ) ; }	calculate and store path constraints for an individual.
public void test_journal_oneindexnodata ( ) throws ioexception , interruptedexception , executionexception { final file out = file . createtempfile ( getname ( ) , options . jnl ) ; try { final journal src = getstore ( getproperties ( ) ) ; try { final string name = _str ; src . registerindex ( new indexmetadata ( name , uuid . randomuuid ( ) ) ) ; src . commit ( ) ; final future < journal > f = src . compact ( out ) ; final journal newjournal = f . get ( ) ; try { assertnotnull ( newjournal . getindex ( name ) ) ; abstractbtreetestcase . assertsamebtree ( src . getindex ( name ) , newjournal . getindex ( name ) ) ; } finally { newjournal . destroy ( ) ; } } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }	test of a journal on which a single index has been register ( and the journal committed ) but no data was written onto the index .
public static boolean p2ploader ( classloader ldr ) { return ldr instanceof griddeploymentinfo ; }	checks if class loader is an internal p2p class loader .
private static string removesubtrailers ( string decodedsubject ) { int substringstart = _num ; int substringend = decodedsubject . length ( ) ; int originalsize = decodedsubject . length ( ) ; int curpos = originalsize - _num ; while ( _bool ) { char c = decodedsubject . charat ( curpos -- ) ; if ( c == ws ) { substringend -- ; } else { if ( substringend > fwd_parens . length ( ) && decodedsubject . endswith ( fwd_parens ) ) { substringend -= fwd_parens . length ( ) ; } break ; } } decodedsubject = decodedsubject . substring ( substringstart , substringend ) ; return decodedsubject ; }	remove the remove_subj_trailers subj - trailer = " ( fwd ) " / wsp.
boolean nextsource ( ) throws ioexception { if ( msourceit . hasnext ( ) ) { final inputstream is = msourceit . next ( ) ; if ( is == null ) { msource = null ; return _bool ; } else { msource = new bufferedinputstream ( is , fileutils . buffered_stream_size ) ; } msourceclosed = _bool ; minputbufferposition = _num ; minputbufferlength = _num ; mbufferlength = _num ; mbufferposition = _num ; return _bool ; } if ( msource != null ) { msource . close ( ) ; } msource = null ; return _bool ; }	step to the next input stream .
public static byte [ ] bitmaptobytes ( bitmap bm ) { byte [ ] bytes = null ; if ( bm != null ) { bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; bm . compress ( bitmap . compressformat . png , _num , baos ) ; bytes = baos . tobytearray ( ) ; } return bytes ; }	bitmap transfer to bytes.
public static string inflate ( string name ) { return inflate ( name , gprefix ) ; }	inflate a short name into a full gdata uri using gprefix ( ending in " # " ).
public void addpriorityhandler ( warninghandler handler ) { _priorityhandlers . add ( handler ) ; }	add a warning event handler.
public void printlenstring ( string v ) throws ioexception { if ( v == null ) { os . write ( _num ) ; os . write ( _num ) ; } else { int len = v . length ( ) ; os . write ( len > > _num ) ; os . write ( len ) ; printstring ( v , _num , len ) ; } }	prints a string to the stream , encoded as utf - 8 with preceeding length.
private void writeattr ( string name , string val ) throws ioexception { writeattr ( name , val , _bool ) ; }	writes the xml attribute name / val.
final private string syntaxdef2syntaxdesc ( attributes attrs ) throws namingexception { stringbuffer syntaxdesc = new stringbuffer ( _str ) ; attribute attr = null ; int count = _num ; attr = attrs . get ( numericoid_id ) ; if ( attr != null ) { syntaxdesc . append ( writenumericoid ( attr ) ) ; count ++ ; } else { throw new configurationexception ( _str + _str ) ; } attr = attrs . get ( desc_id ) ; if ( attr != null ) { syntaxdesc . append ( writeqdstring ( attr ) ) ; count ++ ; } if ( count < attrs . size ( ) ) { string attrid = null ; for ( namingenumeration < ? extends attribute > ae = attrs . getall ( ) ; ae . hasmoreelements ( ) ; ) { attr = ae . next ( ) ; attrid = attr . getid ( ) ; if ( attrid . equals ( numericoid_id ) || attrid . equals ( desc_id ) ) { continue ; } else { syntaxdesc . append ( writeqdstrings ( attr ) ) ; } } } syntaxdesc . append ( _str ) ; return syntaxdesc . tostring ( ) ; }	translate attributes that describe an attribute syntax definition into the string description as defined in rfc 2252 .
@ override public void write ( buffer buffer , boolean isend ) throws ioexception { if ( _s == null ) { buffer . free ( ) ; return ; } try { _needsflush = _bool ; if ( buffer . isdirect ( ) ) { _totalwritebytes += buffer . length ( ) ; _s . write ( buffer . direct ( ) ) ; return ; } _totalwritebytes += buffer . length ( ) ; while ( buffer . length ( ) > _num ) { _writebuffer . clear ( ) ; buffer . read ( _writebuffer ) ; _writebuffer . flip ( ) ; _s . write ( _writebuffer ) ; } } catch ( ioexception e ) { ioexception exn = clientdisconnectexception . create ( this + _str + e , e ) ; try { close ( ) ; } catch ( ioexception e1 ) { } throw exn ; } finally { buffer . free ( ) ; } }	writes an nio buffer to the socket .
private static void skipmembervalue ( int tag , bytebuffer buf ) { switch ( tag ) { case _str : buf . getint ( ) ; break ; case _str : skipannotation ( buf , _bool ) ; break ; case _str : skiparray ( buf ) ; break ; default : buf . getshort ( ) ; } }	skips the annotation member value at the current position in the specified byte buffer.
protected void recursivenestedjoin ( eventbean lookupevent , int nestingorderindex , eventbean [ ] currentpath , collection < eventbean [ ] > result , exprevaluatorcontext exprevaluatorcontext ) { list < eventbean [ ] > nestedresult = new linkedlist < eventbean [ ] > ( ) ; execnode nestedexecnode = childnodes . get ( nestingorderindex ) ; nestedexecnode . process ( lookupevent , currentpath , nestedresult , exprevaluatorcontext ) ; boolean islaststream = ( nestingorderindex == nestingorderlength - _num ) ; if ( ! islaststream ) { for ( eventbean [ ] row : nestedresult ) { eventbean lookup = row [ nestedstreams [ nestingorderindex ] ] ; recursivenestedjoin ( lookup , nestingorderindex + _num , row , result , exprevaluatorcontext ) ; } return ; } for ( eventbean [ ] row : nestedresult ) { result . add ( row ) ; } }	recursive method to run through all child nodes and , for each result set tuple returned by a child node , execute the inner child of the child node until there are no inner child nodes .
public string generateminimalmatsimconfig ( ) { config config = new config ( ) ; configgroup ippcm = config . createmodule ( matrixbasedptrouterconfiggroup . group_name ) ; ippcm . addparam ( matrixbasedptrouterconfiggroup . pt_stops , this . ptstops ) ; ippcm . addparam ( matrixbasedptrouterconfiggroup . using_pt_stops , _str ) ; ippcm . addparam ( matrixbasedptrouterconfiggroup . pt_travel_times_and_distances_switch , this . usetraveltimesanddistances ) ; changemodeconfiggroup changemodeconfig = configutils . addorgetmodule ( config , changemodeconfiggroup . config_module , changemodeconfiggroup . class ) ; string [ ] str = { _str , _str } ; changemodeconfig . setmodes ( str ) ; return writeconfigfile ( config ) ; }	generates the external matsim config file with the specified parameter settings.
public recordedrequest takerequest ( ) throws interruptedexception { return requestqueue . take ( ) ; }	awaits the next http request , removes it , and returns it.
private int convertlocationtocolumn ( int x , int y ) { if ( cellwidth > _num ) { if ( layoutorientation == jlist . vertical ) { return _num ; } insets insets = list . getinsets ( ) ; int col ; if ( islefttoright ) { col = ( x - insets . left ) / cellwidth ; } else { col = ( list . getwidth ( ) - x - insets . right - _num ) / cellwidth ; } if ( col < _num ) { return _num ; } else if ( col >= columncount ) { return columncount - _num ; } return col ; } return _num ; }	returns the closest column to the passed in location .
public static list < file > findfilesindir ( file directory , filenamefilter filter ) { vector < file > files = new vector < file > ( ) ; file [ ] entries = directory . listfiles ( ) ; for ( file entry : entries ) { if ( filter == null || filter . accept ( directory , entry . getname ( ) ) ) { files . add ( entry ) ; } if ( entry . isdirectory ( ) ) { files . addall ( findfilesindir ( entry , filter ) ) ; } } return files ; }	given a java . io . file representing a directory , list all the files underneath that directory matching the given filenamefilter .
public string generatedrop ( string table ) { stringbuffer result = new stringbuffer ( ) ; result . append ( _str ) ; result . append ( table ) ; result . append ( _str ) ; return result . tostring ( ) ; }	generate the drop statement for a table .
private void registerchildlisteners ( ) { iterator < propertychangelistener > iter = fchildlisteners . iterator ( ) ; while ( iter . hasnext ( ) ) { propertychangelistener listener = iter . next ( ) ; listener . register ( ) ; } }	register the child listeners on the child preference stores .
boolean isscrolloutofbounds ( ) { return float . compare ( getscrollamountoutofbounds ( mstackscrollp ) , _num ) != _num ; }	returns whether the specified scroll is out of bounds.
public list < instruction > reduceinstructions ( final list < instruction > instructions ) { lock . lock ( ) ; try { this . instructions = instructions ; stacksizesimulator . buildstacksizes ( instructions ) ; return reduceinstructionsinternal ( instructions ) ; } finally { lock . unlock ( ) ; } }	returns all instructions which are somewhat " relevant " for the returned object of the method.
protected boolean islockedlocally ( uuid newownerid ) { return thisnode . equals ( getownernode ( ) ) || thisnode . equals ( newownerid ) ; }	checks if latest call to acquire / release was called on this node.
private boolean trytomove ( float deltay ) { if ( ( deltay > _num && mcurrentpos == _num ) ) { if ( debug ) { log . d ( log_tag , string . format ( _str ) ) ; } return _bool ; } if ( ( deltay < _num && mcurrentpos == - mheaderheight ) ) { if ( debug ) { log . d ( log_tag , string . format ( _str ) ) ; } return _bool ; } int to = mcurrentpos + ( int ) deltay ; if ( to < - mheaderheight ) { if ( debug ) { log . d ( log_tag , string . format ( _str ) ) ; } to = - mheaderheight ; } if ( to > _num ) { if ( debug ) { log . d ( log_tag , string . format ( _str ) ) ; } to = _num ; } return moveto ( to ) ; }	if deltay > 0 , trytomove the content down.
public void testcomparenegneg2 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , _num , _num } ; int asign = - _num ; int bsign = - _num ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; assertequals ( _num , anumber . compareto ( bnumber ) ) ; }	compareto ( biginteger a ).
@ override public boolean deleteleftword ( ) { minputconnection . beginbatchedit ( ) ; if ( minputconnection . getselectedtext ( _num ) != null ) { minputconnection . committext ( _str , _num ) ; } else { charsequence beforecursor = minputconnection . gettextbeforecursor ( max_deletable_context , _num ) ; if ( beforecursor != null ) { int beforecursorlength = beforecursor . length ( ) ; matcher m = whitespace_and_token . matcher ( beforecursor ) ; int lastindex = _num ; while ( m . find ( ) ) { lastindex = beforecursorlength == m . end ( ) ? m . start ( ) : m . end ( ) ; } if ( lastindex > _num ) { minputconnection . deletesurroundingtext ( beforecursorlength - lastindex , _num ) ; } else if ( beforecursorlength < max_deletable_context ) { minputconnection . deletesurroundingtext ( beforecursorlength , _num ) ; } } } minputconnection . endbatchedit ( ) ; return _bool ; }	deletes all characters up to the leftmost whitespace from the cursor ( including the whitespace ).
public static double cdf ( double val , double rate ) { if ( val < _num ) { return _num ; } return _num - math . exp ( - rate * val ) ; }	cumulative density , static version.
public static dataset readcontinuous ( file file , char delimiter ) throws ioexception { return readincontinuousdata ( file , delimiter , collections . singleton ( _str ) ) ; }	read in continuous dataset .
public static string generatenativeguidforstorageportfromindication ( string sourceinstancesystemname , string portnetworkid ) { string [ ] splitedstring = sourceinstancesystemname . split ( constants . path_delimiter_regex ) ; return string . format ( _str , splitedstring [ _num ] , splitedstring [ _num ] , portnetworkid ) ; }	fc port value from indication sourceinstancesystemname : symmetrix + 000198700406 + fa - 1e iscsi port value from indication sourceinstancesystemname : symmetrix + 000198700406 + se - 1g.
protected boolean arepathscontiguous ( treepath [ ] paths ) { if ( rowmapper == null || paths . length < _num ) return _bool ; else { bitset bitset = new bitset ( _num ) ; int anindex , counter , min ; int pathcount = paths . length ; int validcount = _num ; treepath [ ] temppath = new treepath [ _num ] ; temppath [ _num ] = paths [ _num ] ; min = rowmapper . getrowsforpaths ( temppath ) [ _num ] ; for ( counter = _num ; counter < pathcount ; counter ++ ) { if ( paths [ counter ] != null ) { temppath [ _num ] = paths [ counter ] ; int [ ] rows = rowmapper . getrowsforpaths ( temppath ) ; if ( rows == null ) { return _bool ; } anindex = rows [ _num ] ; if ( anindex == - _num || anindex < ( min - pathcount ) || anindex > ( min + pathcount ) ) return _bool ; if ( anindex < min ) min = anindex ; if ( ! bitset . get ( anindex ) ) { bitset . set ( anindex ) ; validcount ++ ; } } } int maxcounter = validcount + min ; for ( counter = min ; counter < maxcounter ; counter ++ ) if ( ! bitset . get ( counter ) ) return _bool ; } return _bool ; }	returns true if the paths are contiguous , or this object has no rowmapper .
public faststringreader ( string s ) { this . str = s ; this . length = s . length ( ) ; }	creates a new string reader .
public querystringquerybuilder field ( string field , float boost ) { if ( fields == null ) { fields = new arraylist < > ( ) ; } fields . add ( field ) ; if ( fieldsboosts == null ) { fieldsboosts = new objectfloathashmap < > ( ) ; } fieldsboosts . put ( field , boost ) ; return this ; }	adds a field to run the query string against with a specific boost .
public static string nowdatestring ( string format ) { simpledateformat df = new simpledateformat ( format ) ; return df . format ( new date ( ) ) ; }	return a string formatted as format.
protected void initstreambuffersize ( ) { string streambuffersizeparam = getinitparameter ( _str ) ; setstreambuffersize ( ( streambuffersizeparam == null ) ? default_stream_buffer_size : integer . parseint ( streambuffersizeparam ) ) ; if ( isdebug ( ) ) { log ( _str + getstreambuffersize ( ) ) ; } }	initializer for property streambuffersize .
public void registersensor ( sensor s , int i ) { if ( ( i < _num ) || ( i > ( ( numinputcards ( ) * bitspercard ) - _num ) ) || ( i > maxsensors ) ) { log . error ( _str + integer . tostring ( i + _num ) ) ; return ; } hasactivesensors = _bool ; if ( sensorarray [ i ] == null ) { sensorarray [ i ] = s ; if ( lastusedsensor < i ) { lastusedsensor = i ; } } else { log . warn ( _str + integer . tostring ( ( getnodeaddress ( ) * serialsensormanager . sensorsperua ) + i + _num ) ) ; } }	the numbers here are 0 to maxsensors , not 1 to maxsensors .
public static number asnumber ( string value , supplier < number > defaultvalueprovider ) { if ( value != null ) { try { return short . valueof ( value ) ; } catch ( numberformatexception e1 ) { try { return integer . valueof ( value ) ; } catch ( numberformatexception e2 ) { try { return long . valueof ( value ) ; } catch ( numberformatexception e3 ) { try { return float . valueof ( value ) ; } catch ( numberformatexception e4 ) { try { return double . valueof ( value ) ; } catch ( numberformatexception e5 ) { try { return new biginteger ( value ) ; } catch ( numberformatexception e6 ) { try { return new bigdecimal ( value ) ; } catch ( numberformatexception e7 ) { } } } } } } } } return defaultvalueprovider != null ? defaultvalueprovider . get ( ) : null ; }	parse the supplied string as a number .
public final void sample ( ) { long sum = _sum . getandset ( _num ) ; int count = _count . getandset ( _num ) ; if ( count != _num ) _value = sum / ( double ) count ; else _value = _num ; }	return the probe ' s next sample .
private string applyreplacement ( final bidimap replacement , string contents ) { for ( object key : replacement . keyset ( ) ) { string attributename = ( string ) key ; string attributeinitials = ( string ) replacement . get ( key ) ; contents = contents . replaceall ( jsonserialisation . jsonattributename ( attributename ) , jsonserialisation . jsonattributename ( attributeinitials ) ) ; } return contents ; }	perform the keyword substitution .
public keyimpl ( kerberosprincipal principal , char [ ] password , string algorithm ) { try { principalname princ = new principalname ( principal . getname ( ) ) ; encryptionkey key = new encryptionkey ( password , princ . getsalt ( ) , algorithm ) ; this . keybytes = key . getbytes ( ) ; this . keytype = key . getetype ( ) ; } catch ( krbexception e ) { throw new illegalargumentexception ( e . getmessage ( ) ) ; } }	constructs a keyimpl from a password .
@ override public string tostring ( ) { string result = _str ; result += getcompatibilitystate ( ) ; if ( m_instances == null ) { result += _str ; } else { result += _str + utils . backquotechars ( m_instances . relationname ( ) ) ; } return result ; }	gets a text descrption of the result producer .
public static void process ( list < packages > pkglist ) throws exception { init ( ) ; string [ ] temps = templates . split ( _str ) ; string [ ] vmfiles = new string [ temps . length ] ; for ( int i = _num ; i < temps . length ; i ++ ) { vmfiles [ i ] = temps [ i ] + _str ; } for ( packages pkg : pkglist ) { for ( string vmfile : vmfiles ) { generator ( vmfile , pkg ) ; } } }	process main logic for create file.
public boolean check ( final direction dir , final boolean facing ) { if ( this . dir != dir ) { return _bool ; } if ( this . facing != facing ) { return _bool ; } final long now = system . currenttimemillis ( ) ; if ( now >= expiration ) { return _bool ; } expiration = now + delay ; return _bool ; }	check if a new direction matches the existing one , and if so , reset the expiration point .
private void parse ( string path ) throws exception { if ( path != null ) { count = path . length ( ) ; data = new char [ count ] ; path . getchars ( _num , count , data , _num ) ; } path ( ) ; }	this method is used to parse the provided xpath expression.
public void recordvariable ( string typedesc , string varname , int varno , symboltable tbl ) throws compileerror { char c ; int dim = _num ; while ( ( c = typedesc . charat ( dim ) ) == _str ) ++ dim ; int type = memberresolver . desctotype ( c ) ; string cname = null ; if ( type == class ) { if ( dim == _num ) cname = typedesc . substring ( _num , typedesc . length ( ) - _num ) ; else cname = typedesc . substring ( dim + _num , typedesc . length ( ) - _num ) ; } declarator decl = new declarator ( type , cname , dim , varno , new symbol ( varname ) ) ; tbl . append ( varname , decl ) ; }	makes the given variable name available .
protected synchronized void readdontverify ( ) throws ioexception , fileencryptionexception { if ( backingrandomaccessfile . length ( ) < headersize ( ) ) { throw new fileencryptionexception ( _str ) ; } long oldpos = backingrandomaccessfile . getfilepointer ( ) ; backingrandomaccessfile . seek ( _num ) ; byte [ ] header_data = new byte [ headersize ( ) - fileheader . auth_tag_size ] ; backingrandomaccessfile . read ( header_data ) ; backingrandomaccessfile . seek ( oldpos ) ; datainputstream istream = new datainputstream ( new bytearrayinputstream ( header_data ) ) ; byte [ ] tmpmagic = new byte [ panbox_file_magic . length ] ; istream . read ( tmpmagic ) ; if ( ! arrays . equals ( tmpmagic , panbox_file_magic ) ) { throw new fileencryptionexception ( _str ) ; } byte [ ] tmpversion = new byte [ panbox_file_version . length ] ; istream . read ( tmpversion ) ; if ( ! arrays . equals ( tmpversion , panbox_file_version ) ) { throw new fileencryptionexception ( _str + panbox_file_version . tostring ( ) ) ; } this . sharekeyversion = istream . readint ( ) ; istream . close ( ) ; }	reads magic + share key version without verification.
private boolean ismediatypesupported ( string media ) { for ( int i = _num ; i < supported_media_types . length ; i ++ ) { if ( media . equalsignorecase ( supported_media_types [ i ] ) ) { return _bool ; } } return _bool ; }	returns true if the specified css media type is unsupported , false otherwise.
private void export_dependencies ( jcas jcas ) { dependencies = new linkedhashmap < token , list < dependency > > ( ) ; list < token > nongoverned = new arraylist < token > ( nodes . keyset ( ) ) ; for ( dependency dependency : select ( jcas , dependency . class ) ) { token governor = dependency . getgovernor ( ) ; token dependent = dependency . getdependent ( ) ; list < dependency > l = dependencies . get ( governor ) ; if ( l == null ) { dependencies . put ( governor , new arraylist < dependency > ( ) ) ; l = dependencies . get ( governor ) ; } l . add ( dependency ) ; nongoverned . remove ( dependent ) ; } for ( token t : nongoverned ) { traversedependents ( t , _str , - _num ) ; writetofile ( _str , componentid , _str , _str , _str ) ; componentid ++ ; } }	traverse the dependency structure beginning from all " roots " , i.
public static char [ ] fix83600 ( char [ ] signature ) { if ( signature == null || signature . length < _num ) return signature ; return signature . removecapture ( signature ) ; }	todo this is a temporary workaround for https : / / bugs.
public static boolean isnetworkavailable ( context context ) { connectivitymanager connectivitymanager = ( connectivitymanager ) context . getsystemservice ( context . connectivity_service ) ; networkinfo info = connectivitymanager . getactivenetworkinfo ( ) ; return info != null && info . isconnected ( ) ; }	returns network availability status .
public static string randomregexpishstring ( random r ) { return randomregexpishstring ( r , _num ) ; }	returns a string thats " regexpish " ( contains lots of operators typically found in regular expressions ) if you call this enough times , you might get a valid regex !.
public list < expectedpartitionvalueentity > createexpectedpartitionvalueentities ( string partitionkeygroupname , list < string > expectedpartitionvalues ) { partitionkeygroupentity partitionkeygroupentity = partitionkeygroupdao . getpartitionkeygroupbyname ( partitionkeygroupname ) ; if ( partitionkeygroupentity == null ) { partitionkeygroupentity = partitionkeygroupdaotesthelper . createpartitionkeygroupentity ( partitionkeygroupname ) ; } list < expectedpartitionvalueentity > expectedpartitionvalueentities = new arraylist < > ( ) ; for ( string expectedpartitionvalue : expectedpartitionvalues ) { expectedpartitionvalueentity expectedpartitionvalueentity = new expectedpartitionvalueentity ( ) ; expectedpartitionvalueentity . setpartitionkeygroup ( partitionkeygroupentity ) ; expectedpartitionvalueentity . setpartitionvalue ( expectedpartitionvalue ) ; expectedpartitionvalueentities . add ( expectedpartitionvaluedao . saveandrefresh ( expectedpartitionvalueentity ) ) ; } return expectedpartitionvalueentities ; }	creates and persists specified partition value entities.
public string tostring ( ) { return text ( ) ; }	returns the text of this gpathresult .
public static lowmemorywatcher register ( @ notnull runnable runnable ) { return new lowmemorywatcher ( runnable ) ; }	registers a runnable to run on low memory events.
public void writedata ( dataoutput dout ) throws ioexception { dout . write ( getmessage ( ) ) ; }	writedata - - output the completed modbus message to dout.
public object extracthardref ( object o ) { softreference w = ( softreference ) o ; if ( w != null ) { return w . get ( ) ; } return null ; }	extracts the hard reference from the soft / weak reference given.
public static string formatlong ( long number ) { return intformat . format ( number ) ; }	formats a long value.
public static void uncontribute ( componentaddon component ) { contributedcomponents . remove ( component ) ; if ( currentaddon != null ) { component . uninitialize ( currentaddon ) ; } }	removes the contribution of the given addon.
public synchronized int copydirect ( int pageid , outputstream out ) throws ioexception { byte [ ] buffer = new byte [ pagesize ] ; if ( pageid >= pagecount ) { return - _num ; } file . seek ( ( long ) pageid << pagesizeshift ) ; file . readfullydirect ( buffer , _num , pagesize ) ; readcount ++ ; out . write ( buffer , _num , pagesize ) ; return pageid + _num ; }	copy the next page to the output stream .
public void writerawbytes ( final byte [ ] value , int offset , int length ) throws ioexception { if ( limit - position >= length ) { system . arraycopy ( value , offset , buffer , position , length ) ; position += length ; } else { throw new outofspaceexception ( position , limit ) ; } }	write part of an array of bytes .
private void assertbackupstatus ( final backupstatus backupstatus ) { map < distributedmember , set < persistentid > > backupmap = backupstatus . getbackedupdiskstores ( ) ; assertfalse ( backupmap . isempty ( ) ) ; for ( distributedmember member : backupmap . keyset ( ) ) { for ( persistentid id : backupmap . get ( member ) ) { assertnotnull ( id . gethost ( ) ) ; assertnotnull ( id . getuuid ( ) ) ; assertnotnull ( id . getdirectory ( ) ) ; } } }	used to confirm valid backupstatus data . confirms fix for defect # 45657.
@ requestmapping ( value = _str ) public void metadataerror ( locale locale , @ pathvariable ( value = _str ) string tenant , httpservletresponse response ) throws ioexception { logger . info ( _str , locale . tostring ( ) , tenant ) ; metadatadefaulttenantbindingerror ( locale , response ) ; }	handle request sent with a wrong binding.
public synchronized void checkstate ( state ... requiredstates ) throws illegalstateexception { for ( state requiredstate : requiredstates ) { if ( requiredstate . equals ( currentstate ) ) { return ; } } throw new illegalstateexception ( string . format ( locale . us , _str , lists . newarraylist ( requiredstates ) , currentstate ) ) ; }	checks that the machine is in one of the given states.
public void sortmovies ( ) { synchronized ( movies ) { utils . sortlist ( movies , movie_set_comparator ) ; movieids . clear ( ) ; for ( movie movie : movies ) { movieids . add ( movie . getdbid ( ) ) ; } } firepropertychange ( _str , null , movies ) ; }	sort movies inside this movie set by using either the sort title , release date or year .
public keyvaluelistparser ( string pairdelimiterregex , string keyvaldelimiterregex ) { pairdelimiter = pattern . compile ( pairdelimiterregex ) ; keyvaldelimiter = pattern . compile ( keyvaldelimiterregex ) ; }	create a parser that uses the given regexes to parse a list of key value pairs .
private synchronized boolean pollstatsbroker ( destination queue ) { statsmessagelistener . setdestination ( queue ) ; timestamp timestamp = new timestamp ( system . currenttimemillis ( ) ) ; logger . debug ( _str + getqueuename ( queue ) + _str + timestamp ) ; jmstemplate . execute ( stats_broker_destination + getqueuename ( queue ) , new producercallbackimpl ( statsqueue ) ) ; try { thread . sleep ( _num * _num ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } return statsmessagelistener . getstats ( ) != null ; }	poll the statistics broker plugin.
public file makeacceptable ( file pathname ) { if ( accept ( pathname ) ) { return pathname ; } else { return new file ( pathname . getpath ( ) + _str + defaultextension ) ; } }	appends the extension to the filename , in case it is missing .
private static boolean edgeintersectscellboundary ( s2point a , s2point b , s2cell cell ) { s2point [ ] vertices = new s2point [ _num ] ; for ( int i = _num ; i < _num ; ++ i ) { vertices [ i ] = cell . getvertex ( i ) ; } for ( int i = _num ; i < _num ; ++ i ) { s2point frompoint = vertices [ i ] ; s2point topoint = vertices [ ( i + _num ) % _num ] ; if ( lenientcrossing ( a , b , frompoint , topoint ) ) { return _bool ; } } return _bool ; }	returns true if the edge and the cell ( including boundary ) intersect .
protected void updateoverlaycontents ( lookat lookat , camera camera ) { latview . settext ( formatlatitude ( lookat . latitude ) ) ; lonview . settext ( formatlongitude ( lookat . longitude ) ) ; altview . settext ( formataltitude ( camera . altitude ) ) ; }	displays navigator state information in the status overlay views .
public string jstypename ( typeref typeref ) { switch ( typeref . getkind ( ) ) { case type_message : return _str ; case type_enum : return _str ; default : { string name = primitive_type_names . get ( typeref . getkind ( ) ) ; if ( ! strings . isnullorempty ( name ) ) { return name ; } throw new illegalargumentexception ( _str + typeref . getkind ( ) ) ; } } }	returns the name of js type for the given typeref .
public statemachine createstatemachine ( statemachinedefinition statemachinedefinition ) { final map < eventdefinition , eventdata > eventdatamap = statemachinedefinition . geteventdatamap ( ) ; set < event > allevents = createallevents ( eventdatamap ) ; set < statedefinition > statedefinitions = statemachinedefinition . getstates ( ) ; set < state > states = new hashset < > ( ) ; for ( statedefinition statedefinition : statedefinitions ) { state state = convertstatedefinitiontostate ( statedefinition ) ; states . add ( state ) ; } statemachine statemachine = new statemachine ( statemachinedefinition . getversion ( ) , statemachinedefinition . getname ( ) , statemachinedefinition . getdescription ( ) , states , statemachinedefinition . getcorrelationid ( ) ) ; statemachinesdao . create ( statemachine ) ; for ( event event : allevents ) { event . setstatemachineinstanceid ( statemachine . getid ( ) ) ; eventpersistenceservice . persistevent ( event ) ; } for ( state state : statemachine . getstates ( ) ) { auditdao . create ( new auditrecord ( statemachine . getid ( ) , state . getid ( ) , _num , status . initialized , null , null ) ) ; } return statemachine ; }	converts state machine definition to state machine domain object and saves in db .
public void dispose ( ) { clearlisteners ( ) ; if ( attributes != null ) { attributes . clear ( ) ; } removed ( null ) ; }	method called when layer detects that it has been removed from maphandler , assumes it ' s being thrown away.
private void readobject ( objectinputstream in ) throws ioexception , classnotfoundexception { in . defaultreadobject ( ) ; registrarid = new serviceid ( in ) ; if ( server == null ) { throw new invalidobjectexception ( _str ) ; } }	reads the default serializable field value for this instance , followed by the registrar ' s service id encoded as specified by the serviceid.
public shape triangle_right ( float x , float y , float height ) { m_path . reset ( ) ; m_path . moveto ( x , y + height ) ; m_path . lineto ( x + height , y + height / _num ) ; m_path . lineto ( x , y ) ; m_path . closepath ( ) ; return m_path ; }	returns a right - pointing triangle of the given dimenisions .
public static terminal find ( string with_name ) { if ( with_name == null ) return null ; else return ( terminal ) _all . get ( with_name ) ; }	lookup a terminal by name string .
public layoutblock createnewlayoutblock ( string systemname , string username ) { layoutblock block = null ; if ( username == null || username . equals ( _str ) ) { log . error ( _str ) ; return null ; } block = getbyusername ( username ) ; if ( block != null ) { return null ; } string sname = _str ; if ( systemname == null ) { boolean found = _bool ; while ( found ) { sname = _str + blknum ; blknum ++ ; block = getbysystemname ( sname ) ; if ( block == null ) { found = _bool ; } } } else { block = getbysystemname ( ( systemname . touppercase ( ) ) ) ; if ( block != null ) { return null ; } sname = systemname . touppercase ( ) ; } block = new layoutblock ( sname , username ) ; register ( block ) ; return block ; }	method to create a new layoutblock if the layoutblock does not exist returns null if a layoutblock with the same systemname or username already exists , or if there is trouble creating a new layoutblock.
@ override public void modifynonstaticjpedalparameters ( final map values ) throws pdfexception { options . set ( values ) ; if ( values . containskey ( jpedalsettings . display_background ) ) { } }	allow user to alter certain values in software such as colour , please note all color and text highlighting values are static and common across the jvm.
public static string escaperegex ( final string regex ) { matcher match = regex_chars . matcher ( regex ) ; return match . replaceall ( _str ) ; }	this function will escape special characters within a string to ensure that the string will not be parsed as a regular expression.
public charbuffer ( string string ) { int length = string . length ( ) ; int capacity = length + min_capacity ; init ( new char [ capacity ] , _num , length ) ; string . getchars ( _num , length , buffer ( ) , _num ) ; }	constructs a char buffer with the given initial string.
private void updatepromovisibility ( float percentage ) { if ( ispromoavailable ( ) ) { mpromovisible = _bool ; mpromoheightpx = math . round ( mathutils . clamp ( percentage * mpromocontentheightpx , _num , mpromocontentheightpx ) ) ; mpromoopacity = percentage ; } else { mpromovisible = _bool ; mpromoheightpx = _num ; mpromoopacity = _num ; } }	updates the ui state for opt out promo .
private valuegeometry ( byte [ ] bytes , geometry geometry ) { this . bytes = bytes ; this . geometry = geometry ; this . hashcode = arrays . hashcode ( bytes ) ; }	create a new geometry objects .
@ override public void do_after_propagation ( ) { for ( heapinsintervalmanager im : new_pts . values ( ) ) { im . flush ( ) ; } new_pts = new hashmap < allocnode , heapinsintervalmanager > ( ) ; }	remember to clean the is_new flag.
static boolean isexist ( string libname , int version ) { string file = _targetsofile ( libname , version ) ; file a = new file ( file ) ; return a . exists ( ) ; }	tell whether the so is extracted .
private void finishcommon ( ) { if ( ! unknownsubjects . isempty ( ) ) { if ( statements . isempty ( ) && restoredstatements . isempty ( ) ) { throw new badsubjectexception ( unknownsubjects . keyset ( ) , uris ) ; } else { log . info ( _str , unknownsubjects . keyset ( ) , uris . entitydata ( ) , uris . entity ( ) ) ; } } if ( revisionid == null ) { throw new containedexception ( _str + statements ) ; } if ( lastmodified == null ) { throw new containedexception ( _str + statements ) ; } for ( pair < uri , literal > datastatement : datastatements ) { statements . add ( new statementimpl ( entityuriimpl , datastatement . getleft ( ) , datastatement . getright ( ) ) ) ; } statements . addall ( restoredstatements ) ; }	perform all munge completion tasks that are required no matter the configuration.
public static final void showguimessage ( final string user_message , final bufferedimage image , final string title ) { if ( image == null ) { return ; } final imagepanel display = new imagepanel ( image ) ; display . setlayout ( new borderlayout ( ) ) ; if ( user_message != null ) { display . add ( new jlabel ( user_message ) , borderlayout . south ) ; } final int width = image . getwidth ( ) ; final int height = image . getheight ( ) ; display . setsize ( new dimension ( width + _num , height + _num ) ) ; joptionpane . showconfirmdialog ( contentpane , display , title , joptionpane . default_option , joptionpane . plain_message ) ; }	display message if in gui mode.
private void dyninit ( ) { }	dynamic init . table layout , visual , listener.
@ override public path call ( ) throws exception { final set < filevisitoption > options ; if ( followlinks ) { options = enumset . of ( filevisitoption . follow_links ) ; } else { options = enumset . noneof ( filevisitoption . class ) ; } logger . info ( string . format ( _str , path ) ) ; try { files . walkfiletree ( path , options , maxdepth , this ) ; } catch ( ioexception e ) { logger . log ( level . severe , string . format ( _str , path ) , e ) ; throw e ; } logger . info ( string . format ( _str , path ) ) ; return path ; }	recursively walks the file tree of a directory .
private void baselinelayout ( int origin , int size ) { int ascent ; int descent ; if ( baselineanchoredtotop ) { ascent = prefascent ; descent = size - ascent ; } else { ascent = size - prefdescent ; descent = prefdescent ; } for ( spring spring : springs ) { alignment alignment = spring . getalignment ( ) ; if ( alignment == null || alignment == alignment . baseline ) { int baseline = spring . getbaseline ( ) ; if ( baseline >= _num ) { int springmax = spring . getmaximumsize ( vertical ) ; int springpref = spring . getpreferredsize ( vertical ) ; int height = springpref ; int y ; switch ( spring . getbaselineresizebehavior ( ) ) { case constant_ascent : y = origin + ascent - baseline ; height = math . min ( descent , springmax - baseline ) + baseline ; break ; case constant_descent : height = math . min ( ascent , springmax - springpref + baseline ) + ( springpref - baseline ) ; y = origin + ascent + ( springpref - baseline ) - height ; break ; default : y = origin + ascent - baseline ; break ; } spring . setsize ( vertical , y , height ) ; } else { setchildsize ( spring , vertical , origin , size ) ; } } else { setchildsize ( spring , vertical , origin , size ) ; } } }	lays out springs that have a baseline along the baseline.
public static int readint ( final jsonarray jsonarray , final int index , final boolean required , final boolean notnull ) throws jsonexception { if ( required ) { return jsonarray . getint ( index ) ; } if ( notnull && jsonarray . isnull ( index ) ) { throw new jsonexception ( string . format ( locale . us , null_value_format_array , index ) ) ; } int value = _num ; if ( ! jsonarray . isnull ( index ) ) { value = jsonarray . getint ( index ) ; } return value ; }	reads the int value from the json array for specified index.
public void addpropertychangelistener ( propertychangelistener pcl ) { m_pcsupport . addpropertychangelistener ( pcl ) ; }	add a property change listener.
private void unregisterdependent ( preference dependent ) { if ( mdependents != null ) { mdependents . remove ( dependent ) ; } }	removes a dependent preference on this preference .
private void validatestoragepolicyselection ( storagepolicyselection storagepolicyselection ) { assert . notnull ( storagepolicyselection , _str ) ; businessobjectdatahelper . validatebusinessobjectdatakey ( storagepolicyselection . getbusinessobjectdatakey ( ) , _bool , _bool ) ; storagepolicyhelper . validatestoragepolicykey ( storagepolicyselection . getstoragepolicykey ( ) ) ; assert . notnull ( storagepolicyselection . getstoragepolicyversion ( ) , _str ) ; }	validates the storage policy selection.
@ override public string tostring ( ) { stringbuffer text = new stringbuffer ( ) ; if ( m_cobwebtree == null ) { return _str ; } else { m_cobwebtree . dumptree ( _num , text ) ; return _str + m_numbermerges + _str + m_numbersplits + _str + numberofclusters ( ) + _str + text . tostring ( ) + _str ; } }	returns a description of the clusterer as a string .
public static object toarray ( collection < ? > collection , class < ? > componenttype ) { if ( componenttype . isprimitive ( ) ) { object array = array . newinstance ( componenttype , collection . size ( ) ) ; int index = _num ; for ( object value : collection ) { array . set ( array , index ++ , value ) ; } return array ; } return collection . toarray ( ( object [ ] ) array . newinstance ( componenttype , collection . size ( ) ) ) ; }	returns a new array of the given component type ( possibly a java primitive ) that is a copy of the content of the given collection .
gradleexception formatviolationsfor ( formatter formatter , list < file > problemfiles ) throws ioexception { return new gradleexception ( diffmessageformatter . messagefor ( this , formatter , problemfiles ) ) ; }	returns an exception which indicates problem files nicely .
public void labeldistances ( hypergraph < v , e > graph , v root ) { labeldistances ( graph , collections . singleton ( root ) ) ; }	computes the distances of all the node from the specified root node.
public int position ( ) { return linebuffer == null ? _num : linebuffer . length ( ) ; }	gets the current column position of this log stream .
public void addfrequency ( frequency frequency ) { frequencies . add ( frequency ) ; }	adds a new frequency.
public final static headerelement parseheaderelement ( final string value , headervalueparser parser ) throws parseexception { if ( value == null ) { throw new illegalargumentexception ( _str ) ; } if ( parser == null ) parser = saveheadervalueparser . default ; chararraybuffer buffer = new chararraybuffer ( value . length ( ) ) ; buffer . append ( value ) ; saveparsercursor cursor = new saveparsercursor ( _num , value . length ( ) ) ; return parser . parseheaderelement ( buffer , cursor ) ; }	parses an element with the given parser .
public static list < interval > sliceintervals ( interval interval , timegrain timegrain ) { datetime intervalend = interval . getend ( ) ; datetime slicestart = interval . getstart ( ) ; datetime periodstart = timegrain . roundfloor ( slicestart ) ; if ( ! slicestart . equals ( periodstart ) ) { log . info ( _str , interval , timegrain , periodstart ) ; throw new illegalargumentexception ( _str + periodstart ) ; } list < interval > intervalslices = new arraylist < > ( ) ; while ( slicestart . isbefore ( intervalend ) ) { datetime sliceend = datetimeutils . addtimegrain ( slicestart , timegrain ) ; interval slicedinterval = new interval ( slicestart , sliceend ) ; if ( ! interval . contains ( slicedinterval ) ) { log . info ( _str , interval , timegrain ) ; throw new illegalargumentexception ( _str ) ; } intervalslices . add ( slicedinterval ) ; slicestart = sliceend ; } log . debug ( _str , interval , intervalslices . size ( ) , timegrain ) ; return intervalslices ; }	slices the intervals into smaller intervals of the timegrain duration .
public boolean isgerund ( ) { return typestring . startswith ( verb_gerund ) ; }	determine if the expression contains a verb in gerund form .
protected void error ( string msg , exception e ) throws org . xml . sax . saxexception { saxsourcelocator locator = getlocator ( ) ; errorlistener handler = m_stylesheetprocessor . geterrorlistener ( ) ; transformerexception pe ; if ( ! ( e instanceof transformerexception ) ) { pe = ( null == e ) ? new transformerexception ( msg , locator ) : new transformerexception ( msg , locator , e ) ; } else pe = ( transformerexception ) e ; if ( null != handler ) { try { handler . error ( pe ) ; } catch ( transformerexception te ) { throw new org . xml . sax . saxexception ( te ) ; } } else throw new org . xml . sax . saxexception ( pe ) ; }	tell the user of an error , and probably throw an exception .
private jsonobject createrequest ( map < string , object > headers , string uri , httpmethod method , jsonobject payload ) { jsonobject request = new jsonobject ( ) ; jsonarray jsonheaders = new jsonarray ( ) ; headers . foreach ( null ) ; request . put ( _str , jsonheaders ) ; request . put ( _str , uri ) ; request . put ( _str , method . tostring ( ) ) ; request . put ( _str , payload ) ; return request ; }	creates a new request with the given parameters .
public void runtest ( ) throws throwable { document doc ; nodelist elementlist ; node namenode ; characterdata child ; doc = ( document ) load ( _str , _bool ) ; elementlist = doc . getelementsbytagname ( _str ) ; namenode = elementlist . item ( _num ) ; child = ( characterdata ) namenode . getfirstchild ( ) ; { boolean success = _bool ; try { child . replacedata ( - _num , _num , _str ) ; } catch ( domexception ex ) { success = ( ex . code == domexception . index_size_err ) ; } asserttrue ( _str , success ) ; } }	runs the test case .
private long downloadtlogfiles ( file tmptlogdir , long latestgeneration ) throws exception { log . info ( _str + tlogfilestodownload ) ; tlogfilesdownloaded = collections . synchronizedlist ( new arraylist < > ( ) ) ; long bytesdownloaded = _num ; boolean status = tmptlogdir . mkdirs ( ) ; if ( ! status ) { throw new solrexception ( solrexception . errorcode . server_error , _str + tmptlogdir . getname ( ) ) ; } for ( map < string , object > file : tlogfilestodownload ) { string saveas = ( string ) ( file . get ( alias ) == null ? file . get ( name ) : file . get ( alias ) ) ; localfilefetcher = new localfsfilefetcher ( tmptlogdir , file , saveas , tlog_file , latestgeneration ) ; currentfile = file ; localfilefetcher . fetchfile ( ) ; bytesdownloaded += localfilefetcher . getbytesdownloaded ( ) ; tlogfilesdownloaded . add ( new hashmap < > ( file ) ) ; } return bytesdownloaded ; }	download all the tlog files to the temp tlog directory .
static windowsfileattributes readattributes ( long handle ) throws windowsexception { nativebuffer buffer = nativebuffers . getnativebuffer ( sizeof_file_information ) ; try { long address = buffer . address ( ) ; getfileinformationbyhandle ( handle , address ) ; int reparsetag = _num ; int fileattrs = unsafe . getint ( address + offsetof_file_information_attributes ) ; if ( isreparsepoint ( fileattrs ) ) { int size = maximum_reparse_data_buffer_size ; nativebuffer reparsebuffer = nativebuffers . getnativebuffer ( size ) ; try { deviceiocontrolgetreparsepoint ( handle , reparsebuffer . address ( ) , size ) ; reparsetag = ( int ) unsafe . getlong ( reparsebuffer . address ( ) ) ; } finally { reparsebuffer . release ( ) ; } } return fromfileinformation ( address , reparsetag ) ; } finally { buffer . release ( ) ; } }	reads the attributes of an open file.
protected void addallforreplay ( collection < participant > participants ) { iterator < participant > it = participants . iterator ( ) ; while ( it . hasnext ( ) ) { participant p = it . next ( ) ; replaycompletion ( p ) ; } }	utility method for subclasses .
public static jpanel createcheckbox ( string boxlabel , string [ ] buttons , boolean [ ] checked , actionlistener al ) { jpanel jp = createpalettejpanel ( boxlabel ) ; for ( int j = _num ; j < buttons . length ; j ++ ) { jcheckbox jcb = new jcheckbox ( buttons [ j ] ) ; jcb . setactioncommand ( integer . tostring ( j ) ) ; if ( al != null ) jcb . addactionlistener ( al ) ; jcb . setselected ( checked [ j ] ) ; jp . add ( jcb ) ; } return jp ; }	create a panel containing a checkbox .
public static double assignprobabilitiestoinstances ( relation < ? extends numbervector > relation , list < ? extends emclustermodel < ? > > models , writabledatastore < double [ ] > probclusterigivenx ) { final int k = models . size ( ) ; double emsum = _num ; for ( dbiditer iditer = relation . iterdbids ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { numbervector vec = relation . get ( iditer ) ; double [ ] probabilities = new double [ k ] ; { int i = _num ; for ( emclustermodel < ? > m : models ) { probabilities [ i ] = m . estimatedensity ( vec ) ; ++ i ; } } double priorprobability = _num ; for ( int i = _num ; i < k ; i ++ ) { priorprobability += probabilities [ i ] ; } double logp = math . max ( math . log ( priorprobability ) , min_loglikelihood ) ; emsum += ( logp == logp ) ? logp : _num ; double [ ] clusterprobabilities = new double [ k ] ; if ( priorprobability > _num ) { for ( int i = _num ; i < k ; i ++ ) { clusterprobabilities [ i ] = probabilities [ i ] / priorprobability ; } } probclusterigivenx . put ( iditer , clusterprobabilities ) ; } return emsum / relation . size ( ) ; }	assigns the current probability values to the instances in the database and compute the expectation value of the current mixture of distributions.
public static string asstring ( uri value ) { return value != null ? value . tostring ( ) : null ; }	gets the value of the uri as a string , returns null if the uri is null .
public kernel ( int offset , double [ ] values ) { this . values = arrays . copyof ( values , values . length ) ; this . offset = offset ; }	creates a new kernel object with the specified offset and values .
private void initializeworklist ( ) { for ( gvcongruenceclass c : b ) { if ( c . size ( ) == _num ) { continue ; } iterator < valuegraphvertex > i = c . iterator ( ) ; valuegraphvertex first = i . next ( ) ; while ( i . hasnext ( ) ) { valuegraphvertex v = i . next ( ) ; if ( ! checkcongruence ( first , v ) ) { worklist . push ( c ) ; break ; } } } }	initialize the work list.
@ override protected void beforemodellinked ( eobject model , idiagnosticconsumer diagnosticsconsumer ) { importednamesadapter adapter = importednamesadapter . find ( model . eresource ( ) ) ; if ( adapter != null ) adapter . clear ( ) ; unionmemberscope . clearcachedcomposedmembers ( model ) ; }	removes the imported names before linking and cleans other caches attached to the ast .
protected abstract void addfile ( string relativefilename ) throws commandexception ;	runs the dvcs command for adding a new file , e.
public void treeexpanded ( treeexpansionevent event ) { inspectorwindow . updateview ( director . all ) ; }	called whenever an item in the tree has been expanded .
public boolean hasitem ( t object ) { synchronized ( mlock ) { return source . contains ( object ) ; } }	determine if the object provide is in this adapter.
private static boolean versionmatches ( integer v1 , int v2 ) { if ( v1 == null || v1 == _num || v2 == _num ) { return _bool ; } return v1 . equals ( v2 ) ; }	determines if a kvno matches another kvno.
protected void onfailedclosingurlconnection ( urlconnection urlconnection , ioexception cause ) { }	override if you want to get notified if the url connection fails to close.
private void onschemacomplextype ( element schemacomplextype , datatypeelementfactory elementfactory ) { iterator < element > iter = schemacomplextype . elementiterator ( xsd_attribute ) ; while ( iter . hasnext ( ) ) { element xsdattribute = iter . next ( ) ; string name = xsdattribute . attributevalue ( _str ) ; qname qname = getqname ( name ) ; xsdatatype datatype = datatypeforxsdattribute ( xsdattribute ) ; if ( datatype != null ) { elementfactory . setattributexsdatatype ( qname , datatype ) ; } } element schemasequence = schemacomplextype . element ( xsd_sequence ) ; if ( schemasequence != null ) { onchildelements ( schemasequence , elementfactory ) ; } element schemachoice = schemacomplextype . element ( xsd_choice ) ; if ( schemachoice != null ) { onchildelements ( schemachoice , elementfactory ) ; } element schemaall = schemacomplextype . element ( xsd_all ) ; if ( schemaall != null ) { onchildelements ( schemaall , elementfactory ) ; } }	processes an xml schema & lt ; complextypegt ; tag.
private void pushannotatorsref ( string values ) { annotatorsref . push ( annotatorsref . peek ( ) ) ; setannotatorsref ( values ) ; }	pushes a new level of annotators references and base the new one on the given values .
public string versioncompact ( ) { return properties . getproperty ( _str ) ; }	returns the compact version string for this product , suitable for use in path names and similar cases .
private void sequencequery ( queryentry entry , serversessioncontext session , completablefuture < queryresponse > future ) { if ( entry . getsequence ( ) > session . getcommandsequence ( ) ) { session . registersequencequery ( entry . getsequence ( ) , null ) ; } else { indexquery ( entry , future ) ; } }	sequences the given query .
private boolean expungestaleentries ( ) { if ( size == _num ) return _bool ; object r ; boolean result = _bool ; while ( ( r = queue . poll ( ) ) != null ) { result = _bool ; entry e = ( entry ) r ; int h = e . hash ; int i = indexfor ( h , table . length ) ; entry prev = table [ i ] ; entry p = prev ; while ( p != null ) { entry next = p . next ; if ( p == e ) { if ( prev == e ) table [ i ] = next ; else prev . next = next ; e . next = null ; size -- ; break ; } prev = p ; p = next ; } } return result ; }	expunge stale entries from the table .
public static < t > list < t > rest ( list < t > l ) { return l . sublist ( _num , l . size ( ) ) ; }	get a sublist of all of the elements in the list except for first .
public static list < integer > createranges ( int ... startends ) { assert startends . length % _num == _num ; arraylist < integer > ret = new arraylist < integer > ( ) ; for ( int si = _num ; si < startends . length ; si ++ ) { final int start = startends [ si ++ ] ; final int end = startends [ si ] ; assert end >= start ; ret . ensurecapacity ( ret . size ( ) + ( ( end - start ) + _num ) ) ; for ( int i = start ; i <= end ; i ++ ) { ret . add ( new integer ( i ) ) ; } } return ret ; }	create a list of integers consisting of the ranges defined by the provided argument e.
@ after public void teardown ( ) { webclient . closeallwindows ( ) ; }	tear down after testing .
public void findandundo ( object someobj ) { if ( someobj instanceof com . bbn . openmap . mapbean ) { logger . fine ( _str ) ; mapbean map = getmapbean ( ) ; if ( map != null && map == ( mapbean ) someobj ) { setmapbean ( null ) ; } } }	look at the object received in a maphandler status message and disconnect from it if necessary .
public timestamp recalculateestimatedcompletiondate ( long priority , timestamp startdate ) { if ( exist ( ) ) { getproductionrunroutingtasks ( ) ; if ( quantity == null ) getquantity ( ) ; timestamp enddate = null ; for ( iterator < genericvalue > iter = productionrunroutingtasks . iterator ( ) ; iter . hasnext ( ) ; ) { genericvalue routingtask = iter . next ( ) ; if ( priority . compareto ( routingtask . getlong ( _str ) ) <= _num ) { long totaltime = productionrun . getestimatedtasktime ( routingtask , quantity , dispatcher ) ; enddate = techdataservices . addforward ( techdataservices . gettechdatacalendar ( routingtask ) , startdate , totaltime ) ; routingtask . set ( _str , startdate ) ; routingtask . set ( _str , enddate ) ; startdate = enddate ; } } return enddate ; } else { return null ; } }	recalculated the estimatedcompletiondate property.
public void adddocumenttype ( documenttype documenttype ) { mdocumenttypes . add ( documenttype ) ; }	add a document type to the document type list .
public boolean tableexists ( databasemetadata dbmetadata , string tablename ) throws sqlexception { return ( tableexistscasesensitive ( dbmetadata , tablename ) || tableexistscasesensitive ( dbmetadata , tablename . touppercase ( locale . us ) ) || tableexistscasesensitive ( dbmetadata , tablename . tolowercase ( locale . us ) ) ) ; }	checks database metadata to see if a table exists.
public void testhasattributes1 ( ) throws throwable { document doc ; element element ; nodelist elementlist ; boolean hasattributes ; doc = ( document ) load ( _str , builder ) ; elementlist = doc . getelementsbytagname ( _str ) ; element = ( element ) elementlist . item ( _num ) ; hasattributes = element . hasattributes ( ) ; assertfalse ( _str , hasattributes ) ; elementlist = doc . getelementsbytagname ( _str ) ; element = ( element ) elementlist . item ( _num ) ; hasattributes = element . hasattributes ( ) ; asserttrue ( _str , hasattributes ) ; }	runs the test case .
private static position nexttokenpos ( position pos , token [ ] [ ] spec ) { if ( pos == null ) { return null ; } int nextitem = pos . item + _num ; if ( ( nextitem < spec [ pos . line ] . length ) && ( ( pos . line < pcalend . line ) || ( nextitem < pcalend . item ) ) ) { return new position ( pos . line , nextitem ) ; } int nextline = pos . line + _num ; while ( ( nextline < spec . length ) && ( spec [ nextline ] . length == _num ) ) { nextline ++ ; } if ( ( nextline < spec . length ) && ( ( nextline < pcalend . line ) || ( ( nextline == pcalend . line ) && ( _num < pcalend . item ) ) ) ) { return new position ( nextline , _num ) ; } return null ; }	returns the position of the next token after position pos in specification spec if that token exists and is in the pluscal algorithm ; otherwise , it returns null.
public void update ( gl10 gl ) { if ( taskqueue . size ( ) > _num ) { glresorcetask res ; while ( ( res = taskqueue . poll ( ) ) != null ) { res . perform ( gl ) ; } } }	method is called from update cycle , perform all tasks in gl thread.
public static double [ ] hpdinterval ( double proportion , double [ ] x , int [ ] indices ) { double minrange = double . max_value ; int hpdindex = _num ; final int diff = ( int ) math . round ( proportion * ( double ) x . length ) ; for ( int i = _num ; i <= ( x . length - diff ) ; i ++ ) { final double minvalue = x [ indices [ i ] ] ; final double maxvalue = x [ indices [ i + diff - _num ] ] ; final double range = math . abs ( maxvalue - minvalue ) ; if ( range < minrange ) { minrange = range ; hpdindex = i ; } } return new double [ ] { x [ indices [ hpdindex ] ] , x [ indices [ hpdindex + diff - _num ] ] } ; }	determine the highest posterior density for a list of values.
private void checkifdirectoriesexist ( file [ ] disk_dirs ) { diskstorefactoryimpl . checkifdirectoriesexist ( disk_dirs ) ; }	checks if directories exist.
public void addporttoalreadyallocatedcontext ( storageport port , storagehadomain hadomain , storagesystem . type arraytype , string switchname ) { string engine = getengine ( port , hadomain , arraytype ) ; if ( engine != null ) { _alreadyallocatedengines . add ( engine ) ; } string directortype = getdirectortype ( arraytype , hadomain ) ; if ( directortype != null ) { _alreadyallocateddirectortypes . add ( directortype ) ; } string director = getdirector ( port , hadomain ) ; if ( director != null ) { _alreadyallocateddirectors . add ( director ) ; } string cpu = getcpu ( port , hadomain , arraytype ) ; if ( cpu != null ) { _alreadyallocatedcpus . add ( cpu ) ; } if ( switchname != null ) { _alreadyallocatedswitches . add ( switchname ) ; } }	allocates existing ports to the already allocated context ( only ).
public string convert ( ) { if ( s == null ) { try { bytearrayinputstream bs = new bytearrayinputstream ( bytes ) ; datainputstream d = new datainputstream ( bs ) ; string buf = d . readutf ( ) ; shashcode = buf . hashcode ( ) ; return buf ; } catch ( ioexception e ) { return _str ; } } return s ; }	converts internal representation into an actual string .
public static void writelistoflongs ( list list , boolean haslongids , dataoutput out ) throws ioexception { if ( list == null ) { out . writeint ( - _num ) ; } else { out . writeint ( list . size ( ) ) ; out . writeboolean ( haslongids ) ; for ( iterator it = list . iterator ( ) ; it . hasnext ( ) ; ) { long l = ( long ) it . next ( ) ; if ( haslongids ) { out . writelong ( l . longvalue ( ) ) ; } else { out . writeint ( ( int ) l . longvalue ( ) ) ; } } } }	write a set of long objects.
public boolean isdefined ( object attrname ) { return table . containskey ( attrname ) ; }	tells whether a given attribute is defined .
private void showpreloadingstage ( ) { stage preloadingstage = new stage ( stagestyle . undecorated ) ; preloadingstage . initowner ( primarystage ) ; preloadingstage . setscene ( new preloadingscene ( ) ) ; preloadingstage . show ( ) ; primarystage . setonshowing ( null ) ; }	shows preloading stage with scene while fxgl is being configured .
@ override public void clear ( ) { if ( elementcount > _num ) { elementcount = _num ; arrays . fill ( elementdata , null ) ; modcount ++ ; while ( referencequeue . poll ( ) != null ) { } } }	removes all mappings from this map , leaving it empty .
public v remove ( object key ) { int hash = hash ( key . hashcode ( ) ) ; segment < k , v > s = segmentforhash ( hash ) ; return s == null ? null : s . remove ( key , hash , null ) ; }	removes the key ( and its corresponding value ) from this map.
public void test_copystream_fullblock ( ) throws ioexception { final string id = _str ; final int version = _num ; random r = new random ( ) ; final byte [ ] expected = new byte [ block_size ] ; r . nextbytes ( expected ) ; assertequals ( _str , expected . length , repo . copystream ( id , version , new bytearrayinputstream ( expected ) ) ) ; assertequals ( _str , _num , repo . getblockcount ( id , version ) ) ; assertsameiterator ( _str , new long [ ] { _num } , repo . blocks ( id , version ) ) ; assertequals ( _str , expected , read ( repo . inputstream ( id , version ) ) ) ; }	test copy of an stream containing exactly one block ' s data .
public void runtest ( ) throws throwable { document doc ; nodelist elementlist ; node namenode ; characterdata child ; string badstring ; doc = ( document ) load ( _str , _bool ) ; elementlist = doc . getelementsbytagname ( _str ) ; namenode = elementlist . item ( _num ) ; child = ( characterdata ) namenode . getfirstchild ( ) ; { boolean success = _bool ; try { badstring = child . substringdata ( - _num , _num ) ; } catch ( domexception ex ) { success = ( ex . code == domexception . index_size_err ) ; } asserttrue ( _str , success ) ; } }	runs the test case .
private static int iptobytes ( string ip , byte [ ] bytes , boolean musthave4 ) throws ipmatcherexception { string [ ] parts = ip . split ( _str ) ; if ( parts . length > _num || musthave4 && parts . length != _num ) { throw new ipmatcherexception ( _str + ip ) ; } try { for ( int i = _num ; i < parts . length ; i ++ ) { int p = integer . parseint ( parts [ i ] ) ; if ( p < _num || p > _num ) { throw new ipmatcherexception ( _str + ip ) ; } bytes [ i ] = ( byte ) ( p < _num ? p : p - _num ) ; } } catch ( numberformatexception nfe ) { throw new ipmatcherexception ( _str + ip , nfe ) ; } return parts . length ; }	fill out a given four - byte array with the ipv4 address specified in the given string.
protected void reply ( requestcontext context , string key , string message ) { try { httpservletrequest request = context . getrequest ( ) ; string filename = request . getremoteaddr ( ) ; end ( filename , key , message ) ; } catch ( exception e ) { } }	emits an " end " line for a successful reply .
protected void addheaders ( httpurlconnection connection , string tenantid ) { if ( tenantid == null ) { tenantid = propertyutil . getproperty ( propertyutil . hawkular_tenant ) ; } if ( tenantid != null ) { connection . setrequestproperty ( hawkular_tenant , tenantid ) ; } if ( authorization == null && username != null ) { string authstring = username + _str + password ; string encoded = encoder . encodetostring ( authstring . getbytes ( ) ) ; authorization = _str + encoded ; } if ( authorization != null ) { connection . setrequestproperty ( _str , authorization ) ; } }	add the header values to the supplied connection .
public void addlongselectionlistener ( selectionlistener listener ) { if ( listener == null ) throw new illegalargumentexception ( ) ; if ( hexeditcontrol == null ) { if ( listoflonglisteners == null ) listoflonglisteners = new arraylist < > ( ) ; listoflonglisteners . add ( listener ) ; } else { hexeditcontrol . addlongselectionlistener ( listener ) ; } }	adds a long selection listener.
public void println ( ) throws ioexception { out . write ( strategy . getprinternewline ( ) ) ; newline = _bool ; }	output a blank line.
@ override public string tostring ( ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( _str ) ; boolean firsttime = _bool ; for ( entry < integer , string > entry : mcapabilities . entryset ( ) ) { if ( firsttime ) { firsttime = _bool ; } else { sb . append ( _str ) ; } sb . append ( entry . getkey ( ) ) ; sb . append ( _str ) ; sb . append ( entry . getvalue ( ) ) ; sb . append ( _str ) ; return mcapabilities . tostring ( ) ; } return sb . tostring ( ) ; }	convert to string for debugging.
public debug ( string clientid , clientcomms comms ) { this . clientid = clientid ; this . comms = comms ; log . setresourcename ( clientid ) ; }	set the debug facility up for a specific client.
protected string altercase ( string value ) { switch ( getcase ( ) ) { case uppercase : return value . touppercase ( ) ; case lowercase : return value . tolowercase ( ) ; default : return value ; } }	alter the case of this element so that it is rendered according to whatever the value of case_type is . default is mixedcase.
private boolean isackrequired ( ) { return this . ackrequired ; }	return true if a distributed ack message is required.
@ override public synchronized string tostring ( ) { if ( elementcount == _num ) { return _str ; } int length = elementcount - _num ; stringbuffer buffer = new stringbuffer ( elementcount * _num ) ; buffer . append ( _str ) ; for ( int i = _num ; i < length ; i ++ ) { if ( elementdata [ i ] == this ) { buffer . append ( _str ) ; } else { buffer . append ( elementdata [ i ] ) ; } buffer . append ( _str ) ; } if ( elementdata [ length ] == this ) { buffer . append ( _str ) ; } else { buffer . append ( elementdata [ length ] ) ; } buffer . append ( _str ) ; return buffer . tostring ( ) ; }	returns the string representation of this vector .
void addreporter ( string textreporter , int xx , int yy ) { reportericon l = new reportericon ( this ) ; l . setreporter ( textreporter ) ; l . setlocation ( xx , yy ) ; l . setsize ( l . getpreferredsize ( ) . width , l . getpreferredsize ( ) . height ) ; l . setdisplaylevel ( labels ) ; setdirty ( _bool ) ; putitem ( l ) ; }	add a reporter icon to the panel.
private void drawselectionrectangle ( graphics2d g2 ) { if ( this . selectionrectangle != null ) { if ( this . fillselectionrectangle ) { g2 . setpaint ( this . selectionfillpaint ) ; g2 . fill ( selectionrectangle ) ; } else { g2 . setpaint ( this . selectionoutlinepaint ) ; g2 . draw ( selectionrectangle ) ; } } }	draws zoom rectangle ( if present ).
public conversionexception ( final throwable cause ) { super ( cause . getmessage ( ) ) ; this . cause = cause ; }	construct a new exception with the specified root cause .
private boolean hasconnectivitytoallsystems ( initiator initiator , collection < uri > storagesystems , exportgroup exportgroup ) { return hasconnectivitytoallsystems ( initiator , storagesystems , null , exportgroup ) ; }	checks if an initiator has connectivity to a storage system in a varray .
private derivation < tk , fv > constructderivation ( derivation < tk , fv > markednode , int sourceinputid , featureextractor < tk , fv > featurizer , scorer < fv > scorer , searchheuristic < tk , fv > heuristic , outputspace < tk , fv > outputspace ) { final list < derivation < tk , fv > > nodes = new linkedlist < > ( ) ; derivation < tk , fv > p = markednode ; while ( p != null ) { nodes . add ( _num , p ) ; p = p . parent ; } p = markednode . bestchild ; while ( p != null ) { nodes . add ( p ) ; p = p . bestchild ; } derivation < tk , fv > goalhyp = null ; for ( derivation < tk , fv > node : nodes ) { goalhyp = goalhyp == null ? node : new derivation < > ( sourceinputid , node . rule , goalhyp . length , goalhyp , featurizer , scorer , heuristic , outputspace ) ; } return goalhyp ; }	construct a new derivation from a node of interest .
public void testplusmathcontextpositive ( ) { string a = _str ; int ascale = _num ; int precision = _num ; roundingmode rm = roundingmode . floor ; mathcontext mc = new mathcontext ( precision , rm ) ; string c = _str ; int cscale = _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal res = anumber . plus ( mc ) ; assertequals ( _str , c , res . tostring ( ) ) ; assertequals ( _str , cscale , res . scale ( ) ) ; }	plus ( mathcontext ) for a positive bigdecimal.
public void testradix24neg ( ) { string value = _str ; int radix = _num ; biginteger anumber = new biginteger ( value , radix ) ; string result = anumber . tostring ( radix ) ; asserttrue ( result . equals ( value ) ) ; }	test negative number of radix 24.
private static iabstractnode convertor ( final commontree ast ) throws recognitionexception { final list < iabstractnode > children = new arraylist < iabstractnode > ( ) ; for ( final object childobject : ast . getchildren ( ) ) { children . add ( convert ( ( commontree ) childobject ) ) ; } return new cabstractorexpression ( children ) ; }	converts an antrl or ast into a filter or ast .
public jdialog displaypanelinwindow ( final jpanel panel , string title ) { jdialog frame = new genericjdialog ( ) ; frame . setcontentpane ( panel ) ; frame . pack ( ) ; frame . settitle ( title ) ; frame . setvisible ( _bool ) ; return frame ; }	a copy of displaypanel except returning a subclass of window.
public jsontokener ( reader reader ) { this . reader = reader . marksupported ( ) ? reader : new bufferedreader ( reader ) ; this . eof = _bool ; this . useprevious = _bool ; this . previous = _num ; this . index = _num ; this . character = _num ; this . line = _num ; }	construct a jsontokener from a reader .
public static void compress ( ) { string s = binarystdin . readstring ( ) ; char [ ] input = s . tochararray ( ) ; int [ ] freq = new int [ r ] ; for ( int i = _num ; i < input . length ; i ++ ) freq [ input [ i ] ] ++ ; node root = buildtrie ( freq ) ; string [ ] st = new string [ r ] ; buildcode ( st , root , _str ) ; writetrie ( root ) ; binarystdout . write ( input . length ) ; for ( int i = _num ; i < input . length ; i ++ ) { string code = st [ input [ i ] ] ; for ( int j = _num ; j < code . length ( ) ; j ++ ) { if ( code . charat ( j ) == _str ) { binarystdout . write ( _bool ) ; } else if ( code . charat ( j ) == _str ) { binarystdout . write ( _bool ) ; } else throw new illegalstateexception ( _str ) ; } } binarystdout . close ( ) ; }	reads a sequence of 8 - bit bytes from standard input ; compresses them using huffman codes with an 8 - bit alphabet ; and writes the results to standard output .
public builder withtokenizer ( class < ? extends tokenizerfactory > factory , map < string , string > params ) throws ioexception { objects . requirenonnull ( factory , _str ) ; tokenizer . set ( applyresourceloader ( newfactoryclassinstance ( factory , applydefaultparams ( params ) ) ) ) ; componentsadded = _bool ; return this ; }	uses the given tokenizer .
protected double computeazimuthlabeloffset ( double radius , double maxradius ) { return math . asin ( azimuth_label_offset * maxradius / radius ) ; }	compute an angular offset to apply to a azimuth label.
protected void addresource ( list defaults , string bundlename ) { resourcebundle bundle = resourcebundle . getbundle ( bundlename ) ; for ( enumeration keys = bundle . getkeys ( ) ; keys . hasmoreelements ( ) ; ) { string key = ( string ) keys . nextelement ( ) ; defaults . add ( key ) ; defaults . add ( bundle . getobject ( key ) ) ; } }	adds the all keys / values from the given named resource bundle to the defaults.
public void displaychanged ( ) { executedisplaychangedonedt ( getgraphicsconfiguration ( ) ) ; }	from the displaychangedlistener interface ; called from x11graphicsdevice when the display mode has been changed .
private static stream < method > extractmethods ( class clazz ) { try { method [ ] methods = clazz . getmethods ( ) ; if ( methods . length > _num ) { return stream . of ( methods ) ; } } catch ( exception | error e ) { log . warn ( _str , clazz , e ) ; } return stream . empty ( ) ; }	extract a set of methods from a given class .
@ override public void updateserveraddress ( application application , string dockermanagerip , string serverport , string servermanagerport ) { string suffixcloudunit = application . getsuffixcloudunitio ( ) ; jedispool pool = null ; jedis jedis = null ; try { pool = new jedispool ( new jedispoolconfig ( ) , redisip , integer . parseint ( redisport ) , _num ) ; jedis = pool . getresource ( ) ; string subnamespace = concatsubnamespace ( application ) ; string key = subnamespace + suffixcloudunit ; string frontend = _str + key . tolowercase ( ) ; jedis . lset ( frontend , _num , _str + dockermanagerip + _str + serverport ) ; string frontendservermanager = _str + key . tolowercase ( ) ; jedis . lset ( frontendservermanager , _num , _str + dockermanagerip + _str + servermanagerport ) ; } catch ( jedisconnectionexception | unsupportedencodingexception e ) { logger . error ( _str , e ) ; } finally { if ( jedis != null ) { pool . destroy ( ) ; } } }	update the server address.
protected void remove ( int itemposition ) { if ( itemposition >= _num && itemposition < getitemcount ( ) ) { list . remove ( itemposition ) ; } }	remove an item from the adapter ' s list .
protected string chooserandomenemys ( ) { final list < string > enemylist = new linkedlist < string > ( enemyforces . keyset ( ) ) ; final int enemysize = enemylist . size ( ) ; final int position = rand . rand ( enemysize ) ; return enemylist . get ( position ) ; }	function for choosing random enemy from map.
public boolean isroutetodestvalid ( block protecting , block destination ) { if ( protecting == destination ) { log . debug ( _str ) ; if ( getadjacency ( protecting ) != null ) { return _bool ; } } else if ( getvalidroute ( protecting , destination ) != null ) { return _bool ; } return _bool ; }	is the route to the destination block , going via our neighbouring block valid.
public void sortpools ( list < storagepool > storagepools ) { _portmetricsprocessor . computestoragepoolsavgportmetrics ( storagepools ) ; collections . sort ( storagepools , _storagepoolcomparator ) ; }	sort list of storage pools based on its storage system ' s average usage port metrics usage . its secondary sorting components are free and subscribed capacity.
public rhythmgroup addoverlays ( collection < rhythmoverlay > overlays ) { moverlays . addall ( overlays ) ; if ( mcurrentoverlayindex == no_overlay ) { selectoverlay ( _num ) ; } return this ; }	add multiple rhythm overlays to this group.
public static resource forpath ( final string path ) throws unknownresourceexception { resource resource ; if ( path . startswith ( classpathresource . prefix + _str ) ) { resource = new classpathresource ( path ) ; } else if ( path . startswith ( fileresource . prefix + _str ) ) { resource = new fileresource ( path ) ; } else { resource = forpath ( fileresource . prefix + _str + path ) ; } return resource ; }	creates an instance for a path prefixed by either classpath : or file : .
private static boolean isolderthanleopard ( ) { string version = system . getproperty ( _str ) ; stringtokenizer tk = new stringtokenizer ( version , _str ) ; int major = integer . parseint ( tk . nexttoken ( ) ) ; int minor = integer . parseint ( tk . nexttoken ( ) ) ; return major == _num && minor < _num ; }	determines if this is running a mac osx lower than leopard.
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addall ( collections . list ( super . listoptions ( ) ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public static string xmlcontentescape ( string s ) { stringbuilder sb = new stringbuilder ( ) ; for ( int i = _num ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; switch ( c ) { case _str : sb . append ( _str ) ; break ; case _str : sb . append ( _str ) ; break ; case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : break ; default : sb . append ( c ) ; } } return sb . tostring ( ) ; }	escape a string for use inside as xml element content.
private void feedforward ( vec input , list < vec > activations , list < vec > derivatives ) { vec x = input ; for ( int i = _num ; i < ws . size ( ) ; i ++ ) { matrix w_i = ws . get ( i ) ; vec b_i = bs . get ( i ) ; vec a_i = activations . get ( i ) ; a_i . zeroout ( ) ; w_i . multiply ( x , _num , a_i ) ; a_i . mutableadd ( b_i ) ; a_i . applyfunction ( f ) ; vec d_i = derivatives . get ( i ) ; a_i . copyto ( d_i ) ; d_i . applyfunction ( f . getd ( ) ) ; x = a_i ; } }	feeds a vector through the network to get an output.
private file findfile ( file directory , string name ) throws filenotfoundexception { file file = new file ( directory , name ) ; if ( file . exists ( ) ) { return file ; } for ( string child : directory . list ( ) ) { if ( child . equalsignorecase ( name ) ) { return new file ( directory , child ) ; } } throw new filenotfoundexception ( _str + file ) ; }	finds the named file in the named directory.
public static boolean compareresults ( solrclient controlclient , solrclient cloudclient ) throws solrserverexception , ioexception { return compareresults ( controlclient , cloudclient , null , null ) ; }	compares the results of the control and cloud clients .
public arraylist < string > getelementlist ( string xpathexpression ) { try { arraylist < string > values = new arraylist < string > ( ) ; list < ? > nodelist = xpath . selectnodes ( this . xmldocument , xpathexpression ) ; iterator < ? > iter = nodelist . iterator ( ) ; while ( iter . hasnext ( ) ) { org . jdom . element element = ( org . jdom . element ) iter . next ( ) ; values . add ( element . gettext ( ) ) ; } return values ; } catch ( exception ex ) { log . error ( _str + ex . getmessage ( ) , ex ) ; return null ; } }	retrieves the text elements for a given xpath expression.
public static clcontext createcontextfromcurrentgl ( ) { runtimeexception first = null ; for ( clplatform platform : listplatforms ( ) ) { try { clcontext ctx = platform . createcontextfromcurrentgl ( ) ; if ( ctx != null ) return ctx ; } catch ( runtimeexception ex ) { if ( first == null ) first = ex ; } } throw new runtimeexception ( _str , first ) ; }	creates an opencl context able to share entities with the current opengl context .
public void collapsetree ( ) { for ( int i = _num ; i < tree . getrowcount ( ) ; ++ i ) { tree . collapserow ( i ) ; } }	collapse the tree so that only the root node is visible .
static void queueplayercapereplacement ( abstractclientplayer player ) { final string displayname = player . getdisplaynamestring ( ) ; logger . info ( _str , displayname ) ; thread_pool . submit ( null ) ; }	queue the replacement of a player ' s cape with the testmod3 cape.
public void removevetoablechangelistener ( vetoablechangelistener listener ) { if ( listener != null ) { synchronized ( this ) { if ( vetoablesupport != null ) { vetoablesupport . removevetoablechangelistener ( listener ) ; } } } }	removes a vetoablechangelistener from the listener list.
public streamthroughput ( string statusmessageprefix ) { m_instancecount = _num ; m_samplecount = _num ; m_numsamples = _num ; m_cumulativetime = _num ; m_starttime = system . currenttimemillis ( ) ; m_statusmessageprefix = statusmessageprefix ; }	construct a new streamthroughput.
protected void parsecommand ( final string ... args ) { for ( string arg : args ) { final command command = command . valueofname ( arg ) ; if ( command != null ) { setcommand ( command ) ; break ; } } }	iterates the list of arguments in search of the target locator launcher command .
@ requestmapping ( value = _str , method = requestmethod . put ) public responseentity < bookmark > editbookmark ( @ pathvariable ( value = _str ) string username , @ pathvariable ( value = _str ) int bookmarkid , @ requestbody string json ) throws ioexception , bookmarknotfoundexception , illegalaccessexception , invocationtargetexception { optional < bookmark > optional = bookmarksrepository . findbyidanduserusername ( bookmarkid , username ) ; if ( optional . ispresent ( ) ) { objectmapper mapper = new objectmapper ( ) ; map < string , string > changemap = mapper . readvalue ( json , hashmap . class ) ; bookmark bookmark = optional . get ( ) ; beanutils . populate ( bookmark , changemap ) ; bookmark = bookmarksrepository . save ( bookmark ) ; return new responseentity < > ( bookmark , httpstatus . ok ) ; } else { throw new bookmarknotfoundexception ( _str + bookmarkid ) ; } }	a method to edit a bookmark .
public static string convertfromutf32 ( int [ ] text , int startpos , int endpos ) { stringbuilder sb = new stringbuilder ( ) ; for ( int i = startpos ; i < endpos ; i ++ ) { sb . append ( convertfromutf32tochararray ( text [ i ] ) ) ; } return sb . tostring ( ) ; }	/ converts a utf32 code point sequence to a string with the corresponding character ( s ) .
public void createbounds ( ) { if ( isempty ( ) || hassingleelement ( ) ) { mbounds = null ; return ; } int l = integer . max_value ; int t = integer . max_value ; int r = _num ; int b = _num ; for ( selection . element selection : getelements ( ) ) { constraintwidget w = selection . widget ; l = math . min ( w . getdrawx ( ) , l ) ; t = math . min ( w . getdrawy ( ) , t ) ; r = math . max ( w . getdrawright ( ) , r ) ; b = math . max ( w . getdrawbottom ( ) , b ) ; } constraintwidget bounds = new constraintwidget ( l , t , r - l , b - t ) ; bounds . setcompanionwidget ( widgetcompanion . create ( bounds ) ) ; mbounds = new element ( bounds ) ; updateoriginfrombounds ( ) ; }	if the selection has more than one element , it will create a temporary element object as the bounds of the entire selection.
protected static void recordpattern ( bitarray row , int start , int [ ] counters ) throws notfoundexception { int numcounters = counters . length ; arrays . fill ( counters , _num , numcounters , _num ) ; int end = row . getsize ( ) ; if ( start >= end ) { throw notfoundexception . getnotfoundinstance ( ) ; } boolean iswhite = ! row . get ( start ) ; int counterposition = _num ; int i = start ; while ( i < end ) { if ( row . get ( i ) ^ iswhite ) { counters [ counterposition ] ++ ; } else { counterposition ++ ; if ( counterposition == numcounters ) { break ; } else { counters [ counterposition ] = _num ; iswhite = ! iswhite ; } } i ++ ; } if ( ! ( counterposition == numcounters || ( counterposition == numcounters - _num && i == end ) ) ) { throw notfoundexception . getnotfoundinstance ( ) ; } }	records the size of successive runs of white and black pixels in a row , starting at a given point.
public static object [ ] findmethodwithlistparameters ( object service , string methodname , list < ? > args ) { object [ ] arguments = new object [ args . size ( ) ] ; for ( int i = _num ; i < args . size ( ) ; i ++ ) { arguments [ i ] = args . get ( i ) ; } return findmethodwithlistparameters ( service , methodname , arguments ) ; }	returns ( method , params ) for the given service or ( null , null ) if no method was found .
static int firstillegalcharacter ( string source ) { for ( int i = _num ; i < source . length ( ) ; i ++ ) { if ( islegal ( source . charat ( i ) ) == _bool ) { return i ; } } return - _num ; }	utility method to find the first invalid character as per rfc 2396 section 2.
private coderresult decodebytebuffertocharacterbuffer ( boolean endofinput ) throws decodingexception { buffer . flip ( ) ; return decodemorebytestocharacterbuffer ( endofinput ) ; }	decodes contents of the byte buffer to the character buffer.
protected void newfastclockminute ( ) { for ( int i = delayedtrains . size ( ) - _num ; i >= _num ; i -- ) { activetrain at = delayedtrains . get ( i ) ; if ( ( ! at . getstarted ( ) ) && at . getdelayedstart ( ) != activetrain . nodelay ) { if ( at . getdelayedstart ( ) == activetrain . timeddelay ) { if ( isfastclocktimege ( at . getdeparturetimehr ( ) , at . getdeparturetimemin ( ) ) ) { at . setstarted ( ) ; delayedtrains . remove ( i ) ; if ( _autoallocate ) { autoallocate . scanallocationrequestlist ( allocationrequests ) ; } } } } else if ( at . getstarted ( ) && at . getstatus ( ) == activetrain . ready && at . reachedrestartpoint ( ) ) { if ( isfastclocktimege ( at . getrestartdeparthr ( ) , at . getrestartdepartmin ( ) ) ) { at . restart ( ) ; delayedtrains . remove ( i ) ; if ( _autoallocate ) { autoallocate . scanallocationrequestlist ( allocationrequests ) ; } } } } }	handle activity that is triggered by the fast clock.
public void add ( final creaturerespawnpoint point ) { respawnpoints . add ( point ) ; }	add a creature respawn point to the zone .
private void loadorgaccessrole ( arraylist < orgaccess > list ) { preparedstatement pstmt = null ; resultset rs = null ; string sql = _str + _str ; try { pstmt = db . preparestatement ( sql , get_trxname ( ) ) ; pstmt . setint ( _num , getad_role_id ( ) ) ; rs = pstmt . executequery ( ) ; while ( rs . next ( ) ) { mroleorgaccess oa = new mroleorgaccess ( getctx ( ) , rs , get_trxname ( ) ) ; loadorgaccessadd ( list , new orgaccess ( oa . getad_client_id ( ) , oa . getad_org_id ( ) , oa . isreadonly ( ) ) ) ; } } catch ( exception e ) { log . log ( level . severe , sql , e ) ; } finally { db . close ( rs , pstmt ) ; } }	load org access role.
public void testbytesassource ( ) throws exception { string json = _str ; byte [ ] b = json . getbytes ( _str ) ; int offset = _num ; int len = b . length ; byte [ ] src = new byte [ offset + len + offset ] ; system . arraycopy ( b , _num , src , offset , len ) ; jsonfactory jf = new jsonfactory ( ) ; jsonparser jp = jf . createjsonparser ( src , offset , len ) ; asserttoken ( jsontoken . start_array , jp . nexttoken ( ) ) ; asserttoken ( jsontoken . value_number_int , jp . nexttoken ( ) ) ; assertequals ( _num , jp . getintvalue ( ) ) ; asserttoken ( jsontoken . value_number_int , jp . nexttoken ( ) ) ; assertequals ( _num , jp . getintvalue ( ) ) ; asserttoken ( jsontoken . value_number_int , jp . nexttoken ( ) ) ; assertequals ( _num , jp . getintvalue ( ) ) ; asserttoken ( jsontoken . value_number_int , jp . nexttoken ( ) ) ; assertequals ( _num , jp . getintvalue ( ) ) ; asserttoken ( jsontoken . end_array , jp . nexttoken ( ) ) ; assertnull ( jp . nexttoken ( ) ) ; jp . close ( ) ; }	simple unit test that verifies that passing in a byte array as source works as expected .
public java . security . cert . certificate enginegeneratecertificate ( inputstream in ) throws certificateexception { if ( currentstream == null ) { currentstream = in ; sdata = null ; sdataobjectcount = _num ; } else if ( currentstream != in ) { currentstream = in ; sdata = null ; sdataobjectcount = _num ; } try { if ( sdata != null ) { if ( sdataobjectcount != sdata . size ( ) ) { return getcertificate ( ) ; } else { sdata = null ; sdataobjectcount = _num ; return null ; } } pushbackinputstream pis = new pushbackinputstream ( in ) ; int tag = pis . read ( ) ; if ( tag == - _num ) { return null ; } pis . unread ( tag ) ; if ( tag != _num ) { return readpemcertificate ( pis ) ; } else { return readdercertificate ( new asn1inputstream ( pis ) ) ; } } catch ( exception e ) { throw new excertificateexception ( e ) ; } }	generates a certificate object and initializes it with the data read from the input stream instream .
public string tostring ( object value ) { return toprettystring ( value ) ; }	returns pretty string representation of the object .
@ override public list < period > generaterollingperiods ( datetimeunit datetimeunit ) { calendar cal = getcalendar ( ) ; datetimeunit . setday ( _num ) ; datetimeunit = cal . minusmonths ( datetimeunit , _num ) ; list < period > periods = lists . newarraylist ( ) ; for ( int i = _num ; i < _num ; i ++ ) { periods . add ( createperiod ( datetimeunit , cal ) ) ; datetimeunit = cal . plusmonths ( datetimeunit , _num ) ; } return periods ; }	generates the last 12 months where the last one is the month which the given date is inside .
@ suppresswarnings ( _str ) public synchronized t findcounter ( enum < ? > counterkey ) throws illegalaccessexception , instantiationexception { t counter = cache . get ( counterkey ) ; if ( counter == null ) { counter = countertype . newinstance ( ) ; cache . put ( counterkey , counter ) ; } return counter ; }	returns the counter associated with the key.
public static uri addmessagetouri ( contentresolver resolver , uri uri , string address , string body , string subject , long date , boolean read , boolean deliveryreport , long threadid ) { contentvalues values = new contentvalues ( _num ) ; values . put ( sms . address , address ) ; if ( date != null ) { values . put ( sms . date , date ) ; } values . put ( sms . read , read ? integer . valueof ( _num ) : integer . valueof ( _num ) ) ; values . put ( sms . subject , subject ) ; values . put ( sms . body , body ) ; if ( deliveryreport ) { values . put ( sms . status , sms . status_pending ) ; } if ( threadid != - _num ) { values . put ( sms . thread_id , threadid ) ; } return resolver . insert ( uri , values ) ; }	add an sms to the given uri with the specified thread id .
public void runtest ( ) throws throwable { document doc ; nodelist elementlist ; node namenode ; characterdata child ; string childdata ; doc = ( document ) load ( _str , _bool ) ; elementlist = doc . getelementsbytagname ( _str ) ; namenode = elementlist . item ( _num ) ; child = ( characterdata ) namenode . getfirstchild ( ) ; childdata = child . getdata ( ) ; assertequals ( _str , _str , childdata ) ; }	runs the test case .
protected void enginesetmode ( string mode ) { if ( ! mode . equalsignorecase ( _str ) ) { throw new illegalargumentexception ( _str + mode ) ; } }	should never be called .
@ suppresswarnings ( _str ) private void expungestaleentries ( ) { synchronized ( sync ) { listweakreference r ; while ( ( r = ( listweakreference ) queue . poll ( ) ) != null ) { listentry le = r . getlistentry ( ) ; int i = list . indexof ( le ) ; if ( i != - _num ) { list . remove ( i ) ; } } } }	expunge stale entries from the list .
protected void work ( final iresource resource , final list < workitem > resources , iprogressmonitor monitor ) { ipreferencestore store = findbugsplugin . getpluginpreferences ( getproject ( ) ) ; boolean runasjob = store . getboolean ( findbugsconstants . key_run_analysis_as_extra_job ) ; findbugsjob fbjob = new startedfrombuilderjob ( _str + resource . getname ( ) + _str , resource , resources ) ; if ( runasjob ) { if ( debug ) { findbugsplugin . log ( _str ) ; } findbugsjob . cancelsimilarjobs ( fbjob ) ; if ( debug ) { findbugsplugin . log ( _str ) ; } fbjob . scheduleassystem ( ) ; if ( debug ) { findbugsplugin . log ( _str ) ; } } else { if ( debug ) { findbugsplugin . log ( _str ) ; } fbjob . run ( monitor ) ; if ( debug ) { findbugsplugin . log ( _str ) ; } } }	run a findbugs analysis on the given resource as build job but not delaying the current java build.
public void firevetoablechange ( string name , object oldvalue , object newvalue ) throws propertyvetoexception { super . firevetoablechange ( name , oldvalue , newvalue ) ; beancontextchildsupport . firevetoablechange ( name , oldvalue , newvalue ) ; }	report a vetoable property update to any registered listeners.
@ override public void onfullbackup ( fullbackupdataoutput output ) throws ioexception { if ( mvolumes != null ) { if ( debug ) slog . i ( tag , _str + mvolumes . length + _str ) ; hashset < string > externalfilesdirfilter = new hashset < string > ( ) ; final file externalandroidroot = new file ( environment . getexternalstoragedirectory ( ) , environment . directory_android ) ; externalfilesdirfilter . add ( externalandroidroot . getcanonicalpath ( ) ) ; for ( int i = _num ; i < mvolumes . length ; i ++ ) { storagevolume v = mvolumes [ i ] ; string domain = fullbackup . shared_prefix + i ; fullbackupfiletree ( null , domain , v . getpath ( ) , externalfilesdirfilter , output ) ; } } }	full backup of the shared - storage filesystem.
public static void removeconnectionlist ( integer tab ) { tabbed_connections . remove ( tab . intvalue ( ) ) ; }	remove the list of connections at the supplied index.
protected void paintrangerings ( point2d originpnt , point2d dest , graphics graphics , mapbean themap ) { geo origingeo = new geo ( originpnt . gety ( ) , originpnt . getx ( ) , _bool ) ; geo destgeo = new geo ( dest . gety ( ) , dest . getx ( ) , _bool ) ; double distance = origingeo . distance ( destgeo ) ; for ( int i = _num ; i <= math . max ( _num , numrings ) ; i ++ ) { double ringdist = distance * ( double ) i ; paintcircle ( origingeo , ringdist , graphics , themap ) ; paintlabel ( origingeo , ringdist , graphics , themap ) ; } }	paints the circles and their labels on the given graphics .
public static string separatorstowindows ( string path ) { if ( path == null || path . indexof ( unix_separator ) == - _num ) { return path ; } return path . replace ( unix_separator , windows_separator ) ; }	converts all separators to the windows separator of backslash .
public void translateandappendpending ( int backoff ) throws unsupportedencodingexception { int bufferend = current - backoff ; int len = bufferend - complete ; output . append ( new string ( input , offset + complete , len , charset ) ) ; complete = bufferend ; }	translate pending bytes using selected character set.
@ override public trie optimize ( trie orig ) { list < charsequence > cmds = orig . cmds ; list < row > rows = new arraylist < > ( ) ; list < row > orows = orig . rows ; int remap [ ] = new int [ orows . size ( ) ] ; for ( int j = orows . size ( ) - _num ; j >= _num ; j -- ) { liftup ( orows . get ( j ) , orows ) ; } arrays . fill ( remap , - _num ) ; rows = removegaps ( orig . root , orows , new arraylist < row > ( ) , remap ) ; return new trie ( orig . forward , remap [ orig . root ] , cmds , rows ) ; }	optimize ( eliminate rows with no content ) the given trie and return the reduced trie .
private handler < void > installafterhandler ( final httpserverrequest request , final buffer buffer , final list < listener > afterlistener ) { handler < void > afterhandler = null ; return afterhandler ; }	this handler is called after the self request ( original request ) is performed successfully.
private void tryshutdown ( ) { if ( isclosing ( ) && isoktoclose ( ) ) shutdown ( closefuture . get ( ) ) ; }	close was signaled in closeasync ( ) but there were pending messages at that time.
public storageentity createstorageentity ( string storagename , storageplatformentity storageplatformentity , list < attribute > attributes ) { storageentity storageentity = new storageentity ( ) ; storageentity . setname ( storagename ) ; storageentity . setstorageplatform ( storageplatformentity ) ; if ( ! collectionutils . isempty ( attributes ) ) { list < storageattributeentity > attributeentities = new arraylist < > ( ) ; storageentity . setattributes ( attributeentities ) ; for ( attribute attribute : attributes ) { storageattributeentity attributeentity = new storageattributeentity ( ) ; attributeentities . add ( attributeentity ) ; attributeentity . setstorage ( storageentity ) ; attributeentity . setname ( attribute . getname ( ) ) ; attributeentity . setvalue ( attribute . getvalue ( ) ) ; } } return storagedao . saveandrefresh ( storageentity ) ; }	creates and persists a new storage entity .
public void displayinfoline ( string infoline , int labeldesignator ) { if ( infolineholder != null ) { setlabel ( ( infoline != null && infoline . length ( ) > _num ) ? infoline : fudgestring , labeldesignator ) ; } }	display a line of text in a designated info line .
public console format ( string format , object ... args ) { formatter f = new formatter ( writer ) ; f . format ( format , args ) ; f . flush ( ) ; return this ; }	writes a formatted string to the console using the specified format string and arguments .
public void testsignerstringidentityscope ( ) throws exception { signer s = new signerstub ( _str , identityscope . getsystemscope ( ) ) ; assertnotnull ( s ) ; assertequals ( _str , s . getname ( ) ) ; assertsame ( identityscope . getsystemscope ( ) , s . getscope ( ) ) ; assertnull ( s . getprivatekey ( ) ) ; try { signer s2 = new signerstub ( _str , identityscope . getsystemscope ( ) ) ; fail ( _str ) ; } catch ( keymanagementexception e ) { } signer s2 = new signerstub ( null ) ; assertnull ( s2 . getname ( ) ) ; }	verify signer ( string , identityscope ) creates instance.
public static object invokestaticmethod ( bshclassmanager bcm , class clas , string methodname , object [ ] args ) throws reflecterror , utilevalerror , invocationtargetexception { interpreter . debug ( _str ) ; method method = resolveexpectedjavamethod ( bcm , clas , null , methodname , args , _bool ) ; return invokemethod ( method , null , args ) ; }	invoke a method known to be static.
protected abstractregexnpannotator ( string pattern , boolean casesensitive , double confidence ) { this ( pattern . compile ( pattern , casesensitive ? _num : pattern . case_insensitive ) , _num , confidence ) ; }	new instance , based on the supplied pattern.
private static void removeloopsafepoint ( structuredgraph graph ) { loopbeginnode loopbegin = findfirstloop ( graph ) ; loopbegin . disablesafepoint ( ) ; }	remove the safepoint from the first loop in the test method , so only the safepoints on monitorenter and monitorexit remain in the loop.
protected abstract void binditem ( databoundviewholder < t > holder , int position , list < object > payloads ) ;	override this method to handle binding your items into views.
public void testcase7 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = _num ; int bsign = _num ; byte rbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . add ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	add two positive numbers of different length.
public synchronized void add ( double minvalue , double maxvalue ) { super . add ( minvalue ) ; mmaxvalues . add ( maxvalue ) ; }	adds new values to the series.
public static date daysbefore ( date dateinst , int numdays ) { if ( ( numdays <= _num ) || ( dateinst == null ) ) { throw new illegalargumentexception ( ) ; } final calendar cal = new gregoriancalendar ( ) ; cal . settime ( dateinst ) ; cal . add ( calendar . day_of_year , - numdays ) ; return cal . gettime ( ) ; }	method to return a date instance which is exactly numdays days before the point in time designated by the input date .
public final int remainingcapacity ( ) { return math . max ( _num , capacity - cache . size ( ) ) ; }	gets the number of entries that can be added to this cache without the need for removing stale entries .
@ override public void writeexternal ( objectoutput out ) throws ioexception { super . writeexternal ( out ) ; out . writeobject ( conservativeapproximation ) ; }	calls the super method and writes the conservative approximation of the knn distances of this entry to the specified stream .
int putdata ( object data ) throws fitsexception { long lsize = arrayfuncs . computelsize ( data ) ; if ( lsize > integer . max_value ) { throw new fitsexception ( _str ) ; } int size = ( int ) lsize ; expandheap ( size ) ; bytearrayoutputstream bo = new bytearrayoutputstream ( size ) ; try { buffereddataoutputstream o = new buffereddataoutputstream ( bo ) ; o . writearray ( data ) ; o . flush ( ) ; o . close ( ) ; } catch ( ioexception e ) { throw new fitsexception ( _str , e ) ; } system . arraycopy ( bo . tobytearray ( ) , _num , this . heap , this . heapsize , size ) ; int oldoffset = this . heapsize ; this . heapsize += size ; return oldoffset ; }	add some data to the heap .
public void paint ( graphics g ) { try { super . paint ( g ) ; } catch ( exception e ) { } int focusedrow = getfocusedrow ( _bool ) ; if ( focusedrow != - _num && focusedrow < getrowcount ( ) ) { border rowborder = uimanager . getborder ( _str ) ; if ( rowborder != null ) { rectangle rect = getcellrect ( focusedrow , _num , _bool ) ; rect . width = getwidth ( ) ; rowborder . paintborder ( this , g , rect . x , rect . y , rect . width , rect . height ) ; } } }	paints the table & a focused row border .
private void add ( final jlabel label , final jtextfield field ) { panel . add ( label ) ; panel . add ( field ) ; if ( previous == null ) { layout . putconstraint ( springlayout . north , panel , - spacing , springlayout . north , label ) ; } else { layout . putconstraint ( springlayout . north , label , spacing , springlayout . south , previous ) ; } layout . putconstraint ( springlayout . west , panel , - spacing , springlayout . west , label ) ; layout . putconstraint ( springlayout . south , panel , spacing , springlayout . south , label ) ; layout . putconstraint ( springlayout . east , field , - spacing , springlayout . east , panel ) ; layout . putconstraint ( springlayout . west , field , - ( text_field_width + spacing ) , springlayout . east , panel ) ; layout . putconstraint ( springlayout . south , field , spacing , springlayout . south , label ) ; previous = label ; }	adds a label and a field combination .
private void ontrackpointstart ( attributes attributes ) { latitude = attributes . getvalue ( attribute_lat ) ; longitude = attributes . getvalue ( attribute_lon ) ; altitude = null ; time = null ; }	on track point start .
public static byte [ ] combine ( final list < byte [ ] > datachunks ) { int totalsize = _num ; for ( final byte [ ] datapart : datachunks ) { totalsize += datapart . length ; } final byte [ ] data = new byte [ totalsize ] ; int index = _num ; for ( final byte [ ] datapart : datachunks ) { system . arraycopy ( datapart , _num , data , index , datapart . length ) ; index += datapart . length ; } return data ; }	combines a list of byte arrays into one big byte array .
public void commit ( iresource [ ] resources , string comment , boolean keeplocks , iprogressmonitor monitor ) throws teamexception { if ( monitor == null ) { monitor = new nullprogressmonitor ( ) ; } map table = getprovidermapping ( resources ) ; set keyset = table . keyset ( ) ; monitor . begintask ( _str , keyset . size ( ) * _num ) ; monitor . settaskname ( policy . bind ( _str ) ) ; iterator iterator = keyset . iterator ( ) ; while ( iterator . hasnext ( ) ) { iprogressmonitor submonitor = new subprogressmonitor ( monitor , _num ) ; svnteamprovider provider = ( svnteamprovider ) iterator . next ( ) ; list list = ( list ) table . get ( provider ) ; iresource [ ] providerresources = ( iresource [ ] ) list . toarray ( new iresource [ list . size ( ) ] ) ; provider . checkin ( providerresources , comment , keeplocks , iresource . depth_infinite , submonitor ) ; } }	commit the given resources to their associated providers .
public boolean canspawnworkers ( ) { boolean canspawnworker = _bool ; if ( verboseloglevel > _num ) { utilities . verboselog ( _str + gridname + _str + tier + _str + maxtierdepth + _str + liferemaining ( ) + _str + maximumlifemillis ) ; } if ( ! gridname . equals ( _str ) ) { return _bool ; } if ( clusterstate != null ) { long timesinceclusterlastupdatedclusterstate = system . currenttimemillis ( ) - clusterstate . getlastupdated ( ) ; utilities . verboselog ( _str + timesinceclusterlastupdatedclusterstate ) ; if ( timesinceclusterlastupdatedclusterstate > _num * gridcheckinterval * _num ) { utilities . verboselog ( _str + clusterstate . tostring ( ) ) ; return _bool ; } } else { return _bool ; } if ( tier == maxtierdepth ) { return _bool ; } if ( liferemaining ( ) < ( maximumlifemillis * _num ) ) { return _bool ; } switch ( tier ) { case _num : canspawnworker = _bool ; break ; case _num : canspawnworker = _bool ; break ; case _num : canspawnworker = _bool ; break ; case _num : canspawnworker = _bool ; break ; default : if ( gridthrottle ) { canspawnworker = _bool ; } else { canspawnworker = _bool ; } } return canspawnworker ; }	check if this worker can spawn any worker.
public boolean equals ( object object ) { if ( object == null || ! ( object instanceof sessionid ) ) { return _bool ; } sessionid another = ( sessionid ) object ; return encryptedstring . equals ( another . encryptedstring ) ; }	compares this session id to the specified object.
public static boolean areidentical ( string playerident , offlineplayer compareto ) { return playerident . equals ( getidentificationforasstring ( compareto ) ) ; }	returns whether a given ident matches that of another offline player.
builder addlenient ( string name , string value ) { namesandvalues . add ( name ) ; namesandvalues . add ( value . trim ( ) ) ; return this ; }	add a field with the specified value without any validation.
protected string stringwithoutheader ( ) { stringbuffer text = new stringbuffer ( ) ; for ( int i = _num ; i < numinstances ( ) ; i ++ ) { text . append ( instance ( i ) ) ; if ( i < numinstances ( ) - _num ) { text . append ( _str ) ; } } return text . tostring ( ) ; }	returns the instances in the dataset as a string in arff format.
protected boolean isalwaysnonnull ( value v ) { return _bool ; }	this can be overwritten by sublasses to mark a certain value as constantly non - null .
public final < t > void removeinternal ( list < t > list , int position ) { if ( hasheaderview ( ) && position == _num ) return ; if ( enableloadmore ( ) && position == getitemcount ( ) - _num ) return ; if ( list . size ( ) > _num ) { synchronized ( mlock ) { list . remove ( hasheaderview ( ) ? position - _num : position ) ; } removenotifyexternal ( position ) ; notifyitemremoved ( position ) ; } }	remove a item of the list of the adapter.
public amprimarymastheadviewbean ( string name ) { super ( name ) ; }	creates an instance of base view bean object .
public boolean consumedgesture ( ) { return reacted ; }	returns true if the gesture was consumed by the server .
private void initializelayer ( list < neuron > layer , neuronupdaterule nodetype , int nodes ) { for ( int i = _num ; i < nodes ; i ++ ) { neuron node = new neuron ( getparentnetwork ( ) , nodetype ) ; layer . add ( node ) ; } }	helper method to initialize a layer by adding the desired number of neurons with the desired neuron update rule .
public static double angle ( coordinate p ) { return math . atan2 ( p . y , p . x ) ; }	returns the angle that the vector from ( 0 , 0 ) to p , relative to the positive x - axis.
public void fireneuronmoved ( final neuron moved ) { for ( neuronlistener listener : neuronlisteners ) { listener . neuronmoved ( new networkevent < neuron > ( this , moved ) ) ; } }	fire a network changed event to all registered model listeners .
public static x509certificate createcertificatefrombytes ( byte [ ] certbytes ) { x509certificate cert = null ; certificatefactory certfactory ; try { certfactory = certificatefactory . getinstance ( _str ) ; inputstream in = new bytearrayinputstream ( certbytes ) ; cert = ( x509certificate ) certfactory . generatecertificate ( in ) ; } catch ( certificateexception e ) { logger . warn ( _str + _str , e ) ; } return cert ; }	creates an x509 certificate for a given byte array.
void handleselectionchanged ( string selection ) { if ( mdidexpandselection ) { mdidexpandselection = _bool ; return ; } if ( selection == null || selection . isempty ( ) ) { scheduleinvalidtapnotification ( ) ; if ( mselectiontype == selectiontype . tap ) { resetselectionstates ( ) ; return ; } } if ( selection != null && ! selection . isempty ( ) ) { unscheduleinvalidtapnotification ( ) ; } mselectedtext = selection ; if ( mwastapgesturedetected ) { mselectiontype = selectiontype . tap ; handleselection ( selection , mselectiontype ) ; mwastapgesturedetected = _bool ; } else { mhandler . handleselectionmodification ( selection , mx , my ) ; } }	handles a change in the current selection .
public termsackparser parse ( ) throws parserconfigurationexception , saxexception , parsefailureexception { try { saxparserfactory factory = saxparserfactory . newinstance ( ) ; saxparser parser = factory . newsaxparser ( ) ; parser . parse ( minputsource , this ) ; return this ; } catch ( ioexception e ) { throw new parsefailureexception ( _str , e ) ; } }	parse the terms ack information.
public static string format ( final string value , string ... params ) { validate ( value , null_string_predicate , null_string_msg_supplier ) ; pattern p = pattern . compile ( _str ) ; matcher m = p . matcher ( value ) ; string result = value ; while ( m . find ( ) ) { int paramnumber = integer . parseint ( m . group ( _num ) ) ; if ( params == null || paramnumber >= params . length ) { throw new illegalargumentexception ( _str + m . group ( ) ) ; } result = result . replace ( m . group ( ) , params [ paramnumber ] ) ; } return result ; }	formats a string using parameters.
public builder server ( string server ) { if ( server . endswith ( _str ) == _bool ) { server = server + _str ; } this . server = server ; return this ; }	set the server url to be used by parse.
private responsepacket executecount ( querytemplatepacket template , ijspace space , transaction txn ) throws sqlexception { try { template . setrouting ( getrouting ( ) ) ; template . setexplainplan ( getexplainplan ( ) ) ; int count = space . count ( template , txn , getreadmodifier ( ) ) ; responsepacket response = new responsepacket ( ) ; object [ ] [ ] values = new object [ _num ] [ _num ] ; values [ _num ] [ _num ] = count ; resultentry result = new resultentry ( new string [ ] { getcountcolumnname ( ) } , new string [ ] { getcountcolumnlabel ( ) } , new string [ ] { _str } , values ) ; response . setresultentry ( result ) ; return response ; } catch ( exception e ) { if ( _logger . isloggable ( level . severe ) ) { _logger . log ( level . severe , e . getmessage ( ) , e ) ; } throw new sqlexception ( _str + e , _str , - _num ) ; } }	handle read query - check if it is a read query or a readmultiple and execute it.
void deriveconfidencevalue ( double basecount ) { if ( utils . ismissingvalue ( m_confidence ) && ! utils . ismissingvalue ( basecount ) && basecount > _num ) { m_confidence = m_recordcount / basecount ; } }	backfit confidence value ( does nothing if the confidence value is already set ) .
public modifiablesolrparams add ( string name , string ... val ) { string [ ] old = vals . put ( name , val ) ; if ( old != null ) { if ( val == null || val . length < _num ) { string [ ] both = new string [ old . length + _num ] ; system . arraycopy ( old , _num , both , _num , old . length ) ; both [ old . length ] = null ; vals . put ( name , both ) ; } else { string [ ] both = new string [ old . length + val . length ] ; system . arraycopy ( old , _num , both , _num , old . length ) ; system . arraycopy ( val , _num , both , old . length , val . length ) ; vals . put ( name , both ) ; } } return this ; }	add the given values to any existing name.
public bytearraydatasource ( inputstream is , string type ) { try { bytearrayoutputstream os = new bytearrayoutputstream ( ) ; int ch ; while ( ( ch = is . read ( ) ) != - _num ) { os . write ( ch ) ; } m_data = os . tobytearray ( ) ; } catch ( ioexception ioex ) { log . log ( level . warning , _str , ioex ) ; } if ( type != null && type . length ( ) > _num ) m_type = type ; }	create a datasource from an input stream.
object totype ( string value , string pattern , locale locale ) { calendar calendar = tocalendar ( value , pattern , locale ) ; return totype ( calendar ) ; }	parse a string value to the required type.
public void addlimitline ( limitline l ) { mlimitlines . add ( l ) ; if ( mlimitlines . size ( ) > _num ) { log . e ( _str , _str ) ; } }	adds a new limitline to this axis .
public void readdata ( datainput din ) throws ioexception { function = din . readunsignedshort ( ) ; data = ( short ) ( din . readshort ( ) & _num ) ; }	readdata - - read the function code and data value.
int readresults ( final byte [ ] b , final int bpos , final int bavail , final context context ) { if ( context . buffer != null ) { final int len = math . min ( available ( context ) , bavail ) ; system . arraycopy ( context . buffer , context . readpos , b , bpos , len ) ; context . readpos += len ; if ( context . readpos >= context . pos ) { context . buffer = null ; } return len ; } return context . eof ? eof : _num ; }	extracts buffered data into the provided byte [ ] array , starting at position bpos , up to a maximum of bavail bytes.
public static int inflate ( byte [ ] previous , int previouslength , byte [ ] current , int currentlength , byte [ ] result ) { if ( previous == null ) { system . arraycopy ( current , _num , result , _num , currentlength ) ; return currentlength ; } int length = _num ; int start1 = _num ; int start2 = _num ; while ( start1 < previouslength && start2 < currentlength ) { int end1 = start1 ; while ( end1 < previouslength && previous [ end1 ] != _str ) { end1 ++ ; } int end2 = start2 ; while ( end2 < currentlength && current [ end2 ] != _str ) { end2 ++ ; } if ( current [ start2 ] == _str && end2 == start2 + _num ) { for ( int i = start1 ; i < end1 ; i ++ ) result [ length ++ ] = previous [ i ] ; } else { for ( int i = start2 ; i < end2 ; i ++ ) result [ length ++ ] = current [ i ] ; } if ( end2 < currentlength ) result [ length ++ ] = _str ; start1 = end1 + _num ; start2 = end2 + _num ; } return length ; }	inflate the current sam line by replacing all & by the corresponding field in the previous sam line.
public object [ ] toarray ( ) { final object [ ] items = this . items ; final reentrantlock lock = this . lock ; lock . lock ( ) ; try { final int count = this . count ; object [ ] a = new object [ count ] ; int n = items . length - takeindex ; if ( count <= n ) { system . arraycopy ( items , takeindex , a , _num , count ) ; } else { system . arraycopy ( items , takeindex , a , _num , n ) ; system . arraycopy ( items , _num , a , n , count - n ) ; } return a ; } finally { lock . unlock ( ) ; } }	returns an array containing all of the elements in this queue , in proper sequence.
private void legends ( list < string > legends_list , list < integer > color_code_list ) { textpaint . setcolor ( color . black ) ; textpaint . settextsize ( _num ) ; int left = ( int ) ( graphwidth * _num ) ; for ( int i = _num ; i < legends_list . size ( ) ; i ++ ) { string label = legends_list . get ( i ) ; float text_width = textpaint . measuretext ( label , _num , label . length ( ) ) ; int color = color_code_list . get ( i ) ; if ( ! ( ( graphwidth - legendleft ) > ( text_width + _num ) ) ) { legendtop -= _num ; legendleft = left ; } addlegends ( canvas , color , legendtop , legendleft , legendright , legendbottom , label ) ; legendleft += ( ( int ) text_width + _num ) ; } }	this function calculates the position for each legend.
private void fetchmetadata ( tablemaplogevent tableevent ) throws sqlexception , replicatorexception { if ( metadatacache == null ) metadatacache = new tablemetadatacache ( _num ) ; table table = metadatacache . retrieve ( tableevent . getdatabasename ( ) , tableevent . gettablename ( ) ) ; if ( table == null || table . gettableid ( ) != tableevent . gettableid ( ) ) { preparemetadataconnection ( ) ; table = metadataconnection . findtable ( tableevent . getdatabasename ( ) , tableevent . gettablename ( ) , _bool ) ; if ( table != null ) { table . settableid ( tableevent . gettableid ( ) ) ; metadatacache . store ( table ) ; } } else if ( logger . isdebugenabled ( ) ) logger . debug ( _str + tableevent . getdatabasename ( ) + _str + tableevent . gettablename ( ) + _str ) ; if ( table == null ) { logger . warn ( _str + tableevent . getdatabasename ( ) + _str + tableevent . gettablename ( ) ) ; } else { tableevent . settable ( table ) ; } }	fetches metadata for the table from the cache or from the database if needed.
public string encode ( ) { stringbuffer sb = new stringbuffer ( ) ; encode ( sb ) ; return sb . tostring ( ) ; }	returns the encoded string representing the object type signature .
@ override public int read ( byte [ ] buf , int offset , int len ) throws ioexception { int available = _available ; if ( available > _num ) { len = math . min ( len , available ) ; len = _next . read ( buf , offset , len ) ; if ( len > _num ) { _available -= len ; } } else if ( available == _num ) { _available = readchunklength ( ) ; if ( _available > _num ) { len = math . min ( len , _available ) ; len = _next . read ( buf , offset , len ) ; if ( len > _num ) _available -= len ; } else { _available = - _num ; len = - _num ; } } else { len = - _num ; } return len ; }	reads more data from the input stream .
@ override public void flush ( ) { flushtask task ; synchronized ( logrecords ) { task = new flushtask ( new arraylist < string > ( logrecords ) ) ; logrecords . clear ( ) ; } task . run ( ) ; }	flushes the buffered logrecords .
public static arraylist < page > pagecreatorbuttons ( arraylist < page > pages , item manualtype ) { arraylist < page > newpages = new arraylist < > ( ) ; int pageamount = pages . size ( ) ; int times = _num ; while ( pageamount > _num ) { arraylist < page > pagestemp = new arraylist < > ( ) ; pagestemp . addall ( pages . sublist ( _num * times , ( pageamount > _num ? _num + _num * times : _num * times + pageamount ) ) ) ; int height = _num ; arraylist < manualwidgetbase > widgets = new arraylist < > ( ) ; for ( page page : pagestemp ) { widgets . add ( new buttonwidget ( _num , _num + height , page ) ) ; height += _num ; } newpages . add ( new page ( _str + times , ( arraylist < manualwidgetbase > ) widgets . clone ( ) , _bool , manualtype ) ) ; widgets . clear ( ) ; pagestemp . clear ( ) ; pageamount -= _num ; times ++ ; } return newpages ; }	creates the button pages for a category.
public void testposposfirstlonger ( ) { byte abytes [ ] = { - _num , _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , - _num , _num , _num , - _num , - _num } ; byte bbytes [ ] = { - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = _num ; int bsign = _num ; byte rbytes [ ] = { _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . and ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	and for two positive numbers ; the first is longer.
protected list < string > createnewexportmaskworkflowforinitiators ( list < uri > initiatoruris , exportgroup exportgroup , workflow workflow , map < uri , integer > volumemap , storagesystem storage , string token , string previousstep ) throws exception { list < string > newsteps = new arraylist < > ( ) ; if ( ! initiatoruris . isempty ( ) ) { map < string , list < uri > > computeresourcetoinitiators = mapinitiatorstocomputeresource ( exportgroup , initiatoruris ) ; for ( map . entry < string , list < uri > > resourceentry : computeresourcetoinitiators . entryset ( ) ) { string computekey = resourceentry . getkey ( ) ; list < uri > computeinitiatoruris = resourceentry . getvalue ( ) ; _log . info ( string . format ( _str , computekey ) ) ; genexportmaskcreateworkflowresult result = generatedevicespecificexportmaskcreateworkflow ( workflow , previousstep , storage , exportgroup , computeinitiatoruris , volumemap , token ) ; previousstep = result . getstepid ( ) ; newsteps . add ( previousstep ) ; } } if ( newsteps . isempty ( ) && previousstep != null ) { newsteps . add ( previousstep ) ; } return newsteps ; }	creates a new exportmask for host for the given initiators .
public boolean islessthen ( percent percent ) { assertdefined ( ) ; bigdecimal thisvalue = notnull ( this ) ; bigdecimal parameter = notnull ( percent ) ; return ( thisvalue . compareto ( parameter ) < _num ) ; }	compares two percent objects .
@ override public uri toedgeuri ( final object key ) { return touri ( key . tostring ( ) ) ; }	override to allow for colons in the id without urlencoding them .
short readshort ( ) throws ioexception { mdexfile . readfully ( tmpbuf , _num , _num ) ; if ( isbigendian ) { return ( short ) ( ( tmpbuf [ _num ] & _num ) | ( ( tmpbuf [ _num ] & _num ) << _num ) ) ; } else { return ( short ) ( ( tmpbuf [ _num ] & _num ) | ( ( tmpbuf [ _num ] & _num ) << _num ) ) ; } }	reads a signed 16 - bit integer , byte - swapping if necessary .
public static list < inaviproject > loadprojects ( final abstractsqlprovider provider , final debuggertemplatemanager debuggermanager ) throws couldntloaddataexception { postgresqldatabasefunctions . checkarguments ( provider , debuggermanager ) ; final cconnection connection = provider . getconnection ( ) ; final list < inaviproject > projects = new arraylist < > ( ) ; if ( ! postgresqlhelpers . hastable ( connection , ctablenames . projects_table ) ) { return projects ; } string query = _str + _str + ctablenames . address_spaces_table + _str + ctablenames . projects_table + _str + _str + ctablenames . projects_table ; try ( resultset resultset = connection . executequery ( query , _bool ) ) { while ( resultset . next ( ) ) { final int projectid = resultset . getint ( _str ) ; final string name = postgresqlhelpers . readstring ( resultset , _str ) ; final string description = postgresqlhelpers . readstring ( resultset , _str ) ; final int addressspacecount = resultset . getint ( _str ) ; final timestamp creationdate = resultset . gettimestamp ( _str ) ; final timestamp modificationdate = resultset . gettimestamp ( _str ) ; final list < debuggertemplate > debuggers = postgresqldatabasefunctions . getassigneddebuggers ( connection , projectid , debuggermanager ) ; projects . add ( new cproject ( projectid , name , description == null ? _str : description , creationdate , modificationdate , addressspacecount , debuggers , provider ) ) ; } } catch ( final sqlexception e ) { throw new couldntloaddataexception ( e ) ; } return new arraylist < inaviproject > ( projects ) ; }	loads the projects of a database .
public string syllabify ( string phonestring ) { linkedlist < string > phonelist = splitintoallophones ( phonestring ) ; syllabify ( phonelist ) ; stringbuilder sb = new stringbuilder ( ) ; for ( string p : phonelist ) { if ( sb . length ( ) > _num ) sb . append ( _str ) ; sb . append ( p ) ; } return sb . tostring ( ) ; }	syllabify a phonetic string , marking syllable boundaries with dash characters in the output.
@ override protected node removefromfrontier ( ) { cleanupfrontier ( ) ; node result = frontier . remove ( ) ; updatemetrics ( frontier . size ( ) ) ; setexplored ( result ) ; return result ; }	cleans up the head of the frontier , removes the first node of a non - explored state from the head of the frontier , adds it to the corresponding explored map , and returns the node .
public static boolean isfile ( string path ) { file f = new file ( path ) ; return f . isfile ( ) ; }	checks if the given path is a file.
public boolean equals ( object object ) { if ( ! ( object instanceof objectinstance ) ) { return _bool ; } objectinstance val = ( objectinstance ) object ; if ( ! name . equals ( val . getobjectname ( ) ) ) return _bool ; if ( classname == null ) return ( val . getclassname ( ) == null ) ; return classname . equals ( val . getclassname ( ) ) ; }	compares the current object instance with another object instance .
public zookeeperembedded ( int port ) { this . port = port ; this . logdir = new file ( system . getproperty ( _str ) , _str + port ) ; }	create zookeeper testing server .
public basiccondition ( string variable , value value , relation relation ) { this . variable = template . create ( variable ) ; this . templatevalue = template . create ( value . tostring ( ) ) ; this . groundvalue = value ; this . relation = relation ; }	creates a new basic condition , given a variable label , an expected value , and a relation to hold between the variable and its value.
public static set < string > readstopwordspath ( path path , boolean lowercase ) throws ioexception { return readstopwordsinputstream ( files . newinputstream ( path ) , lowercase ) ; }	read a file containing stopwords ( one per line ).
@ override public string tostring ( ) { stringbuilder srep = new stringbuilder ( ) ; srep . append ( _str ) ; srep . append ( articleid ) ; srep . append ( _str ) ; srep . append ( revisioncounter ) ; srep . append ( _str ) ; srep . append ( timestamp ) ; srep . append ( _str ) ; srep . append ( revisionid ) ; if ( revisiontext != null ) { srep . append ( _str ) ; srep . append ( revisiontext . length ( ) ) ; } srep . append ( _str ) ; return srep . tostring ( ) ; }	returns the string representation of this object .
private void breakbarrier ( ) { generation . broken = _bool ; count = parties ; trip . signalall ( ) ; }	sets current barrier generation as broken and wakes up everyone.
public list < entry > filter ( list < entry > points , double tolerance ) { if ( tolerance <= _num ) return points ; keep = new boolean [ points . size ( ) ] ; switch ( mtype ) { case douglas_peucker : return reducewithdouglaspeuker ( points , tolerance ) ; case none : return points ; default : return points ; } }	filters according to type .
protected void sendlogevent ( string component , string message , callback < object > callback ) { string syslogmessage = string . format ( locale . us , _str , getsyslogformatteddate ( ) , utils . getapplicationname ( context ) , component , message ) ; senddataoverudp ( syslogmessage , callback ) ; }	create properly formatted message to send over udp that acts like a syslog message syslog format : " & lt ; priority & gt ; timestamp orange_link blue_link : message " details : http : / / en.
public static < t extends throwable > t writestacktraces ( t throwable , streamoutput out ) throws ioexception { stacktraceelement [ ] stacktrace = throwable . getstacktrace ( ) ; out . writevint ( stacktrace . length ) ; for ( stacktraceelement element : stacktrace ) { out . writestring ( element . getclassname ( ) ) ; out . writeoptionalstring ( element . getfilename ( ) ) ; out . writestring ( element . getmethodname ( ) ) ; out . writevint ( element . getlinenumber ( ) ) ; } throwable [ ] suppressed = throwable . getsuppressed ( ) ; out . writevint ( suppressed . length ) ; for ( throwable t : suppressed ) { out . writethrowable ( t ) ; } return throwable ; }	serializes the given exceptions stacktrace elements as well as it ' s suppressed exceptions to the given output stream .
public distributedlogmultistreamwriter build ( ) { preconditions . checkargument ( ( null != _streams && ! _streams . isempty ( ) ) , _str ) ; preconditions . checknotnull ( _client , _str ) ; preconditions . checknotnull ( _codec , _str ) ; preconditions . checkargument ( _firstspeculativetimeoutms > _num && _firstspeculativetimeoutms <= _maxspeculativetimeoutms && _speculativebackoffmultiplier > _num && _maxspeculativetimeoutms < _requesttimeoutms , _str ) ; return new distributedlogmultistreamwriter ( _streams , _client , math . min ( _buffersize , max_logrecordset_size ) , _flushintervalmicros , _requesttimeoutms , _firstspeculativetimeoutms , _maxspeculativetimeoutms , _speculativebackoffmultiplier , _codec , _ticker , _executorservice ) ; }	build the multi stream writer .
public static string numbertostring ( number number ) throws jsonexception { if ( number == null ) { throw new jsonexception ( _str ) ; } testvalidity ( number ) ; string string = number . tostring ( ) ; if ( string . indexof ( _str ) > _num && string . indexof ( _str ) < _num && string . indexof ( _str ) < _num ) { while ( string . endswith ( _str ) ) { string = string . substring ( _num , string . length ( ) - _num ) ; } if ( string . endswith ( _str ) ) { string = string . substring ( _num , string . length ( ) - _num ) ; } } return string ; }	produce a string from a number .
private imageelement ( int ad_printformatitem_id ) { loadattachment ( ad_printformatitem_id ) ; }	create image from attachment.
public threadregistervalues ( final threadregisters values ) { m_tid = values . gettid ( ) ; for ( final registervalue value : values . getregisters ( ) ) { m_values . add ( new register ( value ) ) ; } }	creates a new thread register values object .
public launcherdiscoveryrequestbuilder configurationparameters ( map < string , string > configurationparameters ) { preconditions . notnull ( configurationparameters , _str ) ; configurationparameters . foreach ( null ) ; return this ; }	add all of the supplied configuration parameters to the request .
public boolean istriggered ( ) { return checkbox . isselected ( ) ; }	see if this anti - ba pod should be triggered.
public void addall ( int index , int [ ] data ) { int datalen = data . length ; if ( datalen == _num ) { return ; } int newcap = size + ( int ) ( datalen * _num ) + _num ; ensurecapacity ( newcap ) ; system . arraycopy ( array , index , array , index + datalen , size - index ) ; system . arraycopy ( data , _num , array , index , datalen ) ; size += datalen ; }	appends all of the elements in the specified array at the specified position in this list .
private static float calculatescore ( final int [ ] playcounts ) { if ( playcounts == null ) { return _num ; } float score = _num ; for ( int i = _num ; i < math . min ( playcounts . length , num_weeks ) ; i ++ ) { score += playcounts [ i ] * getscoremultiplierforweek ( i ) ; } return score ; }	calculates the score of the song given the play counts.
public void removescanningcallback ( onesheeldscanningcallback scanningcallback ) { if ( scanningcallback != null && scanningcallbacks . contains ( scanningcallback ) ) scanningcallbacks . remove ( scanningcallback ) ; }	remove a scanning callback .
public void paintrect ( graphics g , jcomponent c , int x , int y , int w , int h ) { rectangle bounds = c . getbounds ( ) ; check ( bounds ) ; g . drawimage ( m_backimage , x , y , x + w , h + y , x , y , x + w , y + h , c ) ; }	paint / copy background to component rectangle.
@ override public final void sample ( ) { _value = _acquirecount . get ( ) - _releasecount . get ( ) ; }	return the probe ' s next average .
private boolean ispagebreak ( int row ) { for ( int i = _num ; i < m_pagebreak . size ( ) ; i ++ ) { integer rr = ( integer ) m_pagebreak . get ( i ) ; if ( rr . intvalue ( ) + _num == row ) return _bool ; else if ( rr . intvalue ( ) > row ) return _bool ; } return _bool ; }	check for for pagebreak.
public executorservice shutdown ( ) { pool . shutdown ( ) ; return pool ; }	shuts down the internal thread pool.
public static boolean ispropositionsymbolidentifierpart ( char ch ) { return character . isjavaidentifierpart ( ch ) ; }	determine if the given character is part of a proposition symbol .
public static void o ( zdiagmat d ) { o ( d , parameters . outputfieldwidth , parameters . outputfracplaces ) ; }	prints a zdiagmat in default format .
public int search ( string txt ) { int m = pat . length ( ) ; int n = txt . length ( ) ; int skip ; for ( int i = _num ; i <= n - m ; i += skip ) { skip = _num ; for ( int j = m - _num ; j >= _num ; j -- ) { if ( pat . charat ( j ) != txt . charat ( i + j ) ) { skip = math . max ( _num , j - right [ txt . charat ( i + j ) ] ) ; break ; } } if ( skip == _num ) return i ; } return n ; }	returns the index of the first occurrence of the pattern string in the text string .
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public string tochars ( int [ ] indices ) { stringbuilder s = new stringbuilder ( indices . length ) ; for ( int i = _num ; i < indices . length ; i ++ ) s . append ( tochar ( indices [ i ] ) ) ; return s . tostring ( ) ; }	returns the characters corresponding to the argument indices .
public static final string trunc ( final string str , final int length ) { if ( str == null ) { return str ; } if ( str . length ( ) <= length ) { return str ; } return str . substring ( _num , length ) ; }	truncate string to a given length .
public void cleartransactions ( int fromheight ) { lock . lock ( ) ; try { if ( fromheight == _num ) { unspent . clear ( ) ; spent . clear ( ) ; pending . clear ( ) ; dead . clear ( ) ; transactions . clear ( ) ; } else { throw new unsupportedoperationexception ( ) ; } } finally { lock . unlock ( ) ; } }	deletes transactions which appeared above the given block height from the wallet , but does not touch the keys.
@ override public boolean load ( final player player , final list < string > args ) { groovybinding . setvariable ( _str , player ) ; if ( args != null ) { groovybinding . setvariable ( _str , args . toarray ( new string [ args . size ( ) ] ) ) ; } else { groovybinding . setvariable ( _str , new string [ _num ] ) ; } final groovyshell interp = new groovyshell ( groovybinding ) ; boolean ret = _bool ; preexecute ( player , args ) ; try { final file f = new file ( groovyscript ) ; interp . evaluate ( f ) ; } catch ( final exception e ) { logger . error ( _str + groovyscript , e ) ; setmessage ( e . getmessage ( ) ) ; ret = _bool ; } catch ( final error e ) { logger . error ( _str + groovyscript , e ) ; setmessage ( e . getmessage ( ) ) ; ret = _bool ; } postexecute ( player , args , ret ) ; return ( ret ) ; }	initial load of this script .
private void cleandirtyregion ( float eventx , float eventy ) { dirtyrect . left = math . min ( lasttouchx , eventx ) ; dirtyrect . right = math . max ( lasttouchx , eventx ) ; dirtyrect . top = math . min ( lasttouchy , eventy ) ; dirtyrect . bottom = math . max ( lasttouchy , eventy ) ; }	retrieve the region needing to be redrawn.
public sort ( string [ ] fields ) { this ( fields , new boolean [ fields . length ] ) ; arrays . fill ( m_ascend , _bool ) ; }	creates a new sort specification that sorts on the given fields , all in ascending order .
@ override public boolean wassuccessful ( ) { return isfinished ( ) && getcurrentpoints ( ) >= successthreashold ; }	the attack is only successful if the xsw message is accepted .
void startlocatingphone ( ) { intent intent = new intent ( scontext , locationservice . class ) ; intent . setaction ( locationservice . start_service ) ; intent . putextra ( _str , this . manswerto ) ; scontext . startservice ( intent ) ; }	starts the geolocation service.
public void deleteresourceconfig ( string clustername , resourcetype resourcetype , string dsname ) throws configurationexception { if ( getclusterhome ( ) == null ) { throw new configurationexception ( _str ) ; } file resources = getdir ( getresourceconfigdirname ( getclusterhome ( ) , clustername , resourcetype ) ) ; string delfilename = resources . getabsolutepath ( ) + file . separator + dsname + _str ; delfile ( delfilename ) ; }	delete a specific resource configuration .
public busmovement ( busmovement proto ) { super ( proto ) ; this . controlsystem = proto . controlsystem ; this . id = nextid ++ ; controlsystem . registerbus ( this ) ; startmode = _bool ; }	create a new instance from a prototype.
private int removenext ( ) { if ( lastusagedates . isempty ( ) ) { return invalid_size ; } long oldestusage = null ; file mostlongusedfile = null ; set < entry < file , long > > entries = lastusagedates . entryset ( ) ; synchronized ( lastusagedates ) { for ( entry < file , long > entry : entries ) { if ( mostlongusedfile == null ) { mostlongusedfile = entry . getkey ( ) ; oldestusage = entry . getvalue ( ) ; } else { long lastvalueusage = entry . getvalue ( ) ; if ( lastvalueusage < oldestusage ) { oldestusage = lastvalueusage ; mostlongusedfile = entry . getkey ( ) ; } } } } int filesize = _num ; if ( mostlongusedfile != null ) { if ( mostlongusedfile . exists ( ) ) { filesize = getsize ( mostlongusedfile ) ; if ( mostlongusedfile . delete ( ) ) { lastusagedates . remove ( mostlongusedfile ) ; } } else { lastusagedates . remove ( mostlongusedfile ) ; } } return filesize ; }	remove next file and returns it ' s size.
private void creategui ( ) { for ( final iresultspanel panel : m_factory ) { m_tabbedpane . addtab ( panel . gettitle ( ) , panel . getcomponent ( ) ) ; } add ( m_tabbedpane , borderlayout . center ) ; m_tabbedpane . setvisible ( _bool ) ; }	creates the sub - components of the panel .
public static float generaterandomfloatbetween ( float lowerlimit , float upperlimit ) { return lowerlimit + ( ( upperlimit - lowerlimit ) * _r . nextfloat ( ) ) ; }	generates a random float between two limits.
public sgenitemprovideradapterfactory ( ) { supportedtypes . add ( ieditingdomainitemprovider . class ) ; supportedtypes . add ( istructureditemcontentprovider . class ) ; supportedtypes . add ( itreeitemcontentprovider . class ) ; supportedtypes . add ( iitemlabelprovider . class ) ; supportedtypes . add ( iitempropertysource . class ) ; }	this constructs an instance . < ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
synchronized void addtracer ( tracer tracer ) { if ( curtracers . add ( tracer ) ) { log . trace ( tostring ( ) + _str + tracer . tostring ( ) ) ; } }	add a new tracer .
private void grow ( ) { int newcap = ( entries . length << _num ) + _num ; object [ ] newentries = new object [ newcap ] ; system . arraycopy ( entries , _num , newentries , _num , size ) ; entries = newentries ; }	expands capacity of internal arrays .
public void damage ( double value ) { setvalue ( math . max ( _num , getvalue ( ) - value ) ) ; }	damage component by given value .
@ ignore ( _str ) @ test public void testconcurrenteventsonemptyregion ( ) { versiontestconcurrenteventsonemptyregion ( ) ; }	this tests the concurrency versioning system to ensure that event conflation happens correctly and that the statistic is being updated properly.
public graph ( ) { roots = new arraylist < node > ( ) ; nodes = new arraylist < node > ( ) ; string = _str ; }	constructs an empty graph.
private static string trimversion ( string apiversion ) { if ( apiversion == null ) { return null ; } else { string [ ] versionparts = apiversion . split ( _str ) ; return versionparts [ versionparts . length - _num ] ; } }	separates apiversion for apigroup / apiversion combination .
private inventory queryinventory ( boolean queryskudetails , list < string > moreitemskus ) throws iabexception { checknotdisposed ( ) ; checksetupdone ( _str ) ; try { inventory inv = new inventory ( ) ; int r = querypurchases ( inv , item_type_inapp ) ; if ( r != billing_response_result_ok ) { throw new iabexception ( r , _str ) ; } if ( queryskudetails ) { r = queryskudetails ( item_type_inapp , inv , moreitemskus ) ; if ( r != billing_response_result_ok ) { throw new iabexception ( r , _str ) ; } } if ( msubscriptionssupported ) { r = querypurchases ( inv , item_type_subs ) ; if ( r != billing_response_result_ok ) { throw new iabexception ( r , _str ) ; } if ( queryskudetails ) { r = queryskudetails ( item_type_subs , inv , moreitemskus ) ; if ( r != billing_response_result_ok ) { throw new iabexception ( r , _str ) ; } } } return inv ; } catch ( remoteexception e ) { throw new iabexception ( iabhelper_remote_exception , _str , e ) ; } catch ( jsonexception e ) { throw new iabexception ( iabhelper_bad_response , _str , e ) ; } }	queries the inventory . this will query all owned items from the server , as well as information on additional skus , if specified . this method may block or take long to execute .
@ override public void incomingobject ( ianalyzedinterval analyzedinterval ) throws adeexception { if ( ! m_percentileswithemptyintervals && analyzedinterval . getnumuniquemessageids ( ) == _num ) { return ; } final double rawscore = calcrawscore ( analyzedinterval ) ; if ( ! seenhugelogprob ( analyzedinterval ) ) { m_rawscores . add ( rawscore ) ; ++ m_intervalcount ; } }	if we do not use empty intervals to compute percentiles and there are no unique messages for this interval then we simply return.
public static string readfileasstring ( file file , string encoding ) throws ioexception { bytebuffer buffer = readfile ( file ) ; if ( null == encoding ) { encoding = _str ; } string converted = new string ( buffer . array ( ) , encoding ) ; return converted ; }	new nio based method to read a file as a string with the given encoding .
public embayesestimatoreditor ( embayesestimatorwrapper embayesestwrapper ) { this ( embayesestwrapper . getestimatebayesim ( ) , embayesestwrapper . getdataset ( ) ) ; }	constructs a new bayes im editor from a bayes estimator wrapper .
private boolean savedatatodisk ( boolean exit , boolean complete , string updatedsavename ) { return savedatatodisk ( exit , complete , updatedsavename , _bool ) ; }	saves data and writes it to disk.
public static final void writemapxml ( map val , string name , xmlserializer out , writemapcallback callback ) throws xmlpullparserexception , java . io . ioexception { if ( val == null ) { out . starttag ( null , _str ) ; out . endtag ( null , _str ) ; return ; } out . starttag ( null , _str ) ; if ( name != null ) { out . attribute ( null , _str , name ) ; } writemapxml ( val , out , callback ) ; out . endtag ( null , _str ) ; }	flatten a map into an xmlserializer.
public boolean needpreloadkey ( int idx ) { return preloadkeys != null && preloadkeys . get ( idx ) ; }	checks whether entry info should be sent to primary node from backup .
public int generatechallengetoken ( inetsocketaddress address ) { int token = random . nextint ( ) ; challengetokens . put ( address , token ) ; return token ; }	generate a new token .
@ override public void perform ( ir ir ) { for ( enumeration < basicblock > e = ir . getbasicblocks ( ) ; e . hasmoreelements ( ) ; ) { basicblock bb = e . nextelement ( ) ; if ( bb . isempty ( ) ) continue ; container . counter2 ++ ; if ( bb . getinfrequent ( ) ) { container . counter1 ++ ; if ( ir . options . freq_focus_effort ) continue ; } for ( enumeration < instruction > ie = bb . forwardinstrenumerator ( ) ; ie . hasmoreelements ( ) ; ) { instruction s = ie . nextelement ( ) ; if ( typecheck . conforms ( s ) && ( invertnullandtypechecks ( s ) || pushtypecheckbelowif ( s , ir ) ) ) { ie = bb . forwardinstrenumerator ( ) ; } } } }	main routine : perform the transformation .
public void runwithretries ( retryabletask task ) throws exception { boolean maxsleepintervalhit = _bool ; for ( int i = _num ; i < numattempts ; i ++ ) { try { task . run ( ) ; return ; } catch ( exception e ) { if ( i == numattempts - _num ) { throw e ; } int sleeptime ; if ( maxsleepintervalhit ) { sleeptime = maxsleepinterval ; } else { sleeptime = basesleepinterval * ( int ) math . pow ( _num , i ) ; } log . error ( _str + sleeptime + _str , e ) ; try { thread . sleep ( sleeptime * _num ) ; } catch ( interruptedexception ie ) { log . error ( _str , ie ) ; throw ie ; } } } }	run a task , retrying a fixed number of times if there is a failure .
public object pack ( ) { if ( collection ) { list l = ( list ) value ; if ( types . isarray ( type ) ) { object [ ] o = ( object [ ] ) array . newinstance ( itemtype , l . size ( ) ) ; l . toarray ( o ) ; return o ; } } return value ; }	based on accumulated value , produce a value for this property .
public void removerequest ( interruptrequest interruptrequest ) { synchronized ( interruptrequestqueue ) { interruptrequestqueue . remove ( interruptrequest ) ; } }	this is the way to remove a specific request object.
@ override public final void onheatmapfailed ( ) { updatepending = _bool ; }	callback function when heatmap generation has failed.
@ suppresslint ( _str ) @ nullable public static drawable inflate ( boolean forcesystemhandlingwhenpossible , @ nonnull resources resources , @ drawableres int id ) { boolean systemhandling = issystemhandling ( forcesystemhandlingwhenpossible ) ; log . d ( log_tag , string . format ( _str , integer . tohexstring ( id ) , systemhandling ) ) ; if ( systemhandling ) { return resources . getdrawable ( id , null ) ; } try { return vectordrawable . create ( resources , id ) ; } catch ( resources . notfoundexception e ) { return null ; } }	inflate a drawable from a vector xml resource .
public static long objectfieldoffset ( field field ) { return unsafe . objectfieldoffset ( field ) ; }	returns object field offset .
public void addannotation ( string annotation , double x , double y ) { mannotations . add ( annotation ) ; mstringxy . put ( x , y ) ; }	add an string at ( x , y ) coordinates.
protected synchronized void write ( long offset , byte [ ] b ) throws ioexception { if ( bytebuffer != null ) { bytebuffer . position ( ( int ) offset ) ; bytebuffer . put ( b ) ; } else { throw new ioexception ( _str + getpath ( ) + _str ) ; } }	writes bytes to the underlying rrd file on the disk.
public static byte [ ] ivcipherconcat ( byte [ ] iv , byte [ ] ciphertext ) { byte [ ] combined = new byte [ iv . length + ciphertext . length ] ; system . arraycopy ( iv , _num , combined , _num , iv . length ) ; system . arraycopy ( ciphertext , _num , combined , iv . length , ciphertext . length ) ; return combined ; }	concatinate the iv to the ciphertext using array copy.
long timestamp ( long timestamp ) { this . timestamp = math . max ( this . timestamp , timestamp ) ; return this . timestamp ; }	returns an updated executor timestamp .
public materialpackage ( materialpackagebo materialpackagebo , list < generictrack > generictracks ) { super ( materialpackagebo ) ; this . materialpackagebo = materialpackagebo ; this . generictracks = collections . unmodifiablelist ( generictracks ) ; }	instantiates a new materialpackage object.
public edge findedgeinsamedirection ( coordinate p0 , coordinate p1 ) { for ( int i = _num ; i < edges . size ( ) ; i ++ ) { edge e = ( edge ) edges . get ( i ) ; coordinate [ ] ecoord = e . getcoordinates ( ) ; if ( matchinsamedirection ( p0 , p1 , ecoord [ _num ] , ecoord [ _num ] ) ) return e ; if ( matchinsamedirection ( p0 , p1 , ecoord [ ecoord . length - _num ] , ecoord [ ecoord . length - _num ] ) ) return e ; } return null ; }	returns the edge which starts at p0 and whose first segment is parallel to p1.
public void acquireprobabilities ( final string string ) { if ( string . length ( ) < _num ) { return ; } for ( int i = _num ; i < string . length ( ) ; ++ i ) { final char previouschar = string . charat ( i - _num ) ; final char currentchar = string . charat ( i - _num ) ; final char nextchar = string . charat ( i ) ; final string key = previouschar + _str + currentchar ; if ( ! sequences . contains ( key ) ) { sequences . add ( key ) ; } hashmap < character , integer > probabilities = sequenceprobabilities . get ( key ) ; if ( probabilities == null ) { probabilities = new hashmap < > ( ) ; sequenceprobabilities . put ( key , probabilities ) ; } int existingvalue = probabilities . getordefault ( nextchar , _num ) ; ++ existingvalue ; probabilities . put ( nextchar , existingvalue ) ; } }	parses the specified string to determine the probability of a character appearing after the previous two characters beginning with the third character in the string and ending with the last .
protected final void resolveissue ( healthissue healthissue ) { eventbus eventbus ; boolean wasissueactive ; synchronized ( mlock ) { if ( mhealtheventbus == null ) { log . w ( _str + _str , healthissue . tostring ( ) ) ; return ; } eventbus = mhealtheventbus ; wasissueactive = mactiveissues . remove ( healthissue ) ; } if ( wasissueactive ) { eventbus . post ( healthissue . resolved ) ; } }	marks as resolved the specified issue.
public static byte [ ] decode ( string s ) { return decode ( s , no_options ) ; }	decodes data from base64 notation , automatically detecting gzip - compressed data and decompressing it .
private static boolean test ( odatabasedocumentpool pool , string dburl , string user , string password , boolean finaltry ) { odatabasedocumenttx db = null ; try { logger . info ( _str ) ; db = pool . acquire ( dburl , user , password ) ; iterator < odocument > iter = db . browseclass ( _str ) ; if ( iter . hasnext ( ) ) { iter . next ( ) ; } } catch ( oexception ex ) { if ( finaltry ) { logger . info ( _str , ex ) ; } else { logger . debug ( _str , ex ) ; } return _bool ; } finally { if ( db != null ) { db . close ( ) ; } } return _bool ; }	perform a basic access on the db for a rudimentary test.
@ override public void agg ( object newval ) { if ( newval instanceof byte [ ] ) { byte [ ] values = ( byte [ ] ) newval ; bytebuffer buffer = bytebuffer . wrap ( values ) ; buffer . rewind ( ) ; while ( buffer . hasremaining ( ) ) { valueset . add ( buffer . getint ( ) ) ; } return ; } else { double value = new double ( newval . tostring ( ) ) ; agg ( value ) ; } }	distinct count aggregate function which update the distinct count.
public boolean isunparsedentity ( string entityname ) { entity entity = ( entity ) fentities . get ( entityname ) ; if ( entity == null ) { return _bool ; } return entity . isunparsed ( ) ; }	checks whether an entity given by name is unparsed .
public void flush ( ) throws ioexception { out . flush ( ) ; }	flush any buffered messages .
private static string urlencode ( final string text ) throws unsupportedencodingexception { return urlencoder . encode ( text , _str ) ; }	encode text as utf - 8.
protected void processfocusevent ( focusevent evt ) { super . processfocusevent ( evt ) ; if ( evt . getid ( ) == focusevent . focus_lost ) { if ( popup != null ) hidepopup ( ) ; } }	ensures that if we lose focus , the popup goes away .
@ override public synchronized void addrequestproperty ( string key , string value ) { if ( connected || connecting ) throw new illegalstateexception ( _str ) ; if ( key == null ) throw new nullpointerexception ( _str ) ; if ( isexternalmessageheaderallowed ( key , value ) ) { requests . add ( key , value ) ; if ( ! key . equalsignorecase ( _str ) ) { userheaders . add ( key , value ) ; } } }	adds a general request property specified by a key - value pair.
public void execute ( abortabletask task ) { abortingrunnable ar = new abortingrunnable ( task ) ; tasks . add ( ar ) ; try { exec . execute ( ar ) ; } catch ( rejectedexecutionexception e ) { tasks . remove ( ar ) ; throw e ; } }	executes the task using the embedded executor .
default bytebuffer serialize ( t value ) { bytebuffer buffer = bytebuffer . allocate ( size ( value ) ) ; serialize ( value , buffer ) ; return buffer ; }	serialize to a byte buffer.
private void loadsubmissions ( ) { submissions . clear ( ) ; string [ ] users = jplagcentral . userslist ( ) ; for ( int i = _num ; i < users . length ; i ++ ) { accessstructure [ ] subm = jplagcentral . listaccessstructures ( users [ i ] ) ; if ( subm != null && subm . length != _num ) { for ( int j = _num ; j < subm . length ; j ++ ) { submissions . add ( subm [ j ] ) ; } } } }	used to actualize the vector containing all submissions.
public static bit valueof ( string bit ) throws numberformatexception { final int i = integer . parseint ( bit ) ; if ( i != _num && i != _num ) { throw new numberformatexception ( _str + bit + _str ) ; } return ( i > _num ) ? true : false ; }	method to construct a bit for a given string expression .
public boolean next ( ) throws eofexception { if ( limit >= filesize ) { throw new eofexception ( _str ) ; } if ( mem . getlongvolatile ( structure . limit ) <= limit ) { return _bool ; } byte commit = mem . getbytevolatile ( limit ) ; byte rollback = mem . getbytevolatile ( limit + length . commit ) ; if ( rollback == rollback . set ) { limit += length . recordheader + recordsize ; timeoutcounter = _num ; timerstart = _num ; return _bool ; } if ( commit == commit . set ) { timeoutcounter = _num ; timerstart = _num ; return _bool ; } timeoutcounter ++ ; if ( timeoutcounter >= max_timeout_count ) { if ( timerstart == _num ) { timerstart = system . currenttimemillis ( ) ; } else { if ( system . currenttimemillis ( ) - timerstart >= maxtimeout ) { mem . putbytevolatile ( limit + length . commit , rollback . set ) ; limit += length . recordheader + recordsize ; timeoutcounter = _num ; timerstart = _num ; return _bool ; } } } return _bool ; }	steps forward to the next record if there ' s one available.
private int composecomponent ( int a , int b ) { return math . min ( b + b * a / dimming_factor , _num ) ; }	apply composition to an individual color component of a pixel .
public synchronized void writeto ( outputstream out ) throws ioexception { int remaining = count ; for ( byte [ ] buf : buffers ) { int c = math . min ( buf . length , remaining ) ; out . write ( buf , _num , c ) ; remaining -= c ; if ( remaining == _num ) { break ; } } }	writes the entire contents of this byte stream to the specified output stream .
public void removetreemodellistener ( treemodellistener l ) { treemodellisteners . removeelement ( l ) ; }	removes a listener previously added with addtreemodellistener ( ) .
public uriname ( string name ) throws ioexception { try { uri = new uri ( name ) ; } catch ( urisyntaxexception use ) { throw new ioexception ( _str + name , use ) ; } if ( uri . getscheme ( ) == null ) { throw new ioexception ( _str + name ) ; } host = uri . gethost ( ) ; if ( host != null ) { if ( host . charat ( _num ) == _str ) { string ipv6host = host . substring ( _num , host . length ( ) - _num ) ; try { hostip = new ipaddressname ( ipv6host ) ; } catch ( ioexception ioe ) { throw new ioexception ( _str + _str + name ) ; } } else { try { hostdns = new dnsname ( host ) ; } catch ( ioexception ioe ) { try { hostip = new ipaddressname ( host ) ; } catch ( exception ioe2 ) { throw new ioexception ( _str + _str + _str + name ) ; } } } } }	create the uriname object with the specified name .
public projectedstream addview ( string namespace , string name , list < expression > parameters ) { views . add ( view . create ( namespace , name , parameters ) ) ; return this ; }	adds a parameterized view to the stream .
protected int read ( speechrecord recorder , byte [ ] buffer ) { int len = buffer . length ; int numofbytes = recorder . read ( buffer , _num , len ) ; int status = getstatus ( numofbytes , len ) ; if ( status == _num ) { system . arraycopy ( buffer , _num , mrecording , mrecordedlength , numofbytes ) ; mrecordedlength += len ; } return status ; }	copy data from the given recorder into the given buffer , and append to the complete recording . public int read ( byte [ ] audiodata , int offsetinbytes , int sizeinbytes ).
public void touch ( ) { candiesstore = null ; }	cleans the candies store so that it will be read from file next time .
public static int hash ( object o ) { int h = o == null ? _num : o instanceof byte [ ] ? arrays . hashcode ( ( byte [ ] ) o ) : o . hashcode ( ) ; h += ( h << _num ) ^ _num ; h ^= ( h > > > _num ) ; h += ( h << _num ) ; h ^= ( h > > > _num ) ; h += ( h << _num ) + ( h << _num ) ; return h ^ ( h > > > _num ) ; }	gets hash code for a given object .
public void addparsetemplate ( string parsetemplate ) { parsetemplates . add ( parsetemplate ) ; }	adds a template which should be " parsed " while the parsing process .
private void attachimagefromcamera ( ) { try { if ( null != mshootedpicturepath ) { uri uri = uri . fromfile ( new file ( mshootedpicturepath ) ) ; try { bitmap previewbitmap = vectorapp . getsavedpickerimagepreview ( ) ; string thumbnailpath = getthumbnailpath ( mshootedpicturepath ) ; int rotationangle = imageutils . getrotationangleforbitmap ( vectormediaspickeractivity . this , uri ) ; if ( _num != rotationangle ) { android . graphics . matrix bitmapmatrix = new android . graphics . matrix ( ) ; bitmapmatrix . postrotate ( _num - rotationangle ) ; previewbitmap = bitmap . createbitmap ( previewbitmap , _num , _num , previewbitmap . getwidth ( ) , previewbitmap . getheight ( ) , bitmapmatrix , _bool ) ; } file file = new file ( thumbnailpath ) ; fileoutputstream outstream = new fileoutputstream ( file ) ; previewbitmap . compress ( bitmap . compressformat . jpeg , _num , outstream ) ; outstream . flush ( ) ; outstream . close ( ) ; } catch ( exception e ) { log . e ( log_tag , _str ) ; } bundle condata = new bundle ( ) ; intent intent = new intent ( ) ; intent . setdata ( uri ) ; intent . putextras ( condata ) ; setresult ( result_ok , intent ) ; } } catch ( exception e ) { setresult ( result_canceled , null ) ; } finally { vectorapp . setsavedcameraimagepreview ( null ) ; finish ( ) ; } }	return the taken image from the camera to the calling activity.
private double minignorenan ( double a , double b ) { if ( double . isnan ( a ) ) { return b ; } if ( double . isnan ( b ) ) { return a ; } return math . min ( a , b ) ; }	a function to find the minimum of two values , but ignoring any double.
public objectname preregister ( mbeanserver server , objectname name ) throws exception { setmbeanserver ( server ) ; if ( name == null ) { name = new objectname ( server . getdefaultdomain ( ) + _str + servicename . mlet ) ; } this . mletobjectname = name ; return this . mletobjectname ; }	allows the m - let to perform any operations it needs before being registered in the mbean server . if the objectname is null , the m - let provides a default name for its registration & lt ; defaultdomain & gt ; : type = mlet.
static string matchstringorthrow ( pattern p , todateparser params , enum < ? > aenum ) { string s = params . getinputstr ( ) ; matcher matcher = p . matcher ( s ) ; if ( ! matcher . find ( ) ) { throwexception ( params , format ( _str , aenum . name ( ) ) ) ; } return matcher . group ( _num ) ; }	match the pattern , or if not possible throw an exception .
string sourceformforinitializer ( annotationvalue annotationvalue , processingenvironment processingenv , string membername , element context ) { sourceformvisitor visitor = new initializersourceformvisitor ( processingenv , membername , context ) ; stringbuilder sb = new stringbuilder ( ) ; visitor . visit ( annotationvalue , sb ) ; return sb . tostring ( ) ; }	returns a string representation of the given annotation value , suitable for inclusion in a java source file as the initializer of a variable of the appropriate type .
static bytebuffer newbytebuffer ( int capacity ) { bytebuffer newbb = bytebuffer . allocate ( capacity ) ; newbb . order ( byteorder . little_endian ) ; return newbb ; }	create a ` bytebuffer ` with a given capacity .
public synchronized void add ( double x , double y , double value ) { super . add ( x , y ) ; mvalue . add ( value ) ; updaterange ( value ) ; }	adds a new value to the series .
private void validatecollectionattribute ( collectionattribute collection , set < string > allcollections ) { if ( collection == null || allcollections == null ) { return ; } for ( restmethod restmethod : collection . getmethods ( ) ) { if ( allcollections . contains ( restmethod . getrestfullmethodname ( ) ) ) { aspect . warning ( simplelocation . toplevel , _str + _str + _str + _str , collection . getfullname ( ) , restmethod . getrestmethodname ( ) ) ; } } }	validates if the collection does not contain same named elements ( methods and resources ) .
public void putstringnonull ( string s ) { ensurecapacity ( s . length ( ) * _num ) ; system . arraycopy ( s . getbytes ( ) , _num , this . bytebuffer , this . position , s . length ( ) ) ; this . position += s . length ( ) ; }	put a string in the buffer.
public void externalentitydecl ( string name , xmlresourceidentifier identifier , augmentations augs ) throws xniexception { try { if ( fdeclhandler != null ) { string publicid = identifier . getpublicid ( ) ; string systemid = fresolvedtduris ? identifier . getexpandedsystemid ( ) : identifier . getliteralsystemid ( ) ; fdeclhandler . externalentitydecl ( name , publicid , systemid ) ; } } catch ( saxexception e ) { throw new xniexception ( e ) ; } }	an external entity declaration .
public holtwintersmodelbuilder alpha ( double alpha ) { this . alpha = alpha ; return this ; }	alpha controls the smoothing of the data.
public static @ checkfornull classdescriptor createclassdescriptorfromfieldsignature ( string signature ) { int start = signature . indexof ( _str ) ; if ( start < _num ) { return null ; } int end = signature . indexof ( _str , start ) ; if ( end < _num ) { return null ; } return createclassdescriptor ( signature . substring ( start + _num , end ) ) ; }	create a class descriptor from a field signature.
private static serviceticketresponse checkgetnfcserviceticketresponse ( serviceticketresponse serviceticketresponse ) throws rpcexception { logger . info ( _str , serviceticketresponse ) ; switch ( serviceticketresponse . getresult ( ) ) { case ok : break ; case system_error : throw new systemerrorexception ( serviceticketresponse . geterror ( ) ) ; case not_found : throw new datastorenotfoundexception ( serviceticketresponse . geterror ( ) ) ; default : throw new rpcexception ( string . format ( _str , serviceticketresponse . geterror ( ) ) ) ; } return serviceticketresponse ; }	this method validates a serviceticketresponse object , raising an exception if the response reflects an operation failure .
public void schedule ( timertask task , long delay ) { if ( delay < _num ) throw new illegalargumentexception ( _str ) ; sched ( task , system . currenttimemillis ( ) + delay , _num ) ; }	schedules the specified task for execution after the specified delay .
public void filledellipse ( double x , double y , double semimajoraxis , double semiminoraxis ) { if ( semimajoraxis < _num ) throw new illegalargumentexception ( _str ) ; if ( semiminoraxis < _num ) throw new illegalargumentexception ( _str ) ; double xs = scalex ( x ) ; double ys = scaley ( y ) ; double ws = factorx ( _num * semimajoraxis ) ; double hs = factory ( _num * semiminoraxis ) ; if ( ws <= _num && hs <= _num ) pixel ( x , y ) ; else offscreen . fill ( new ellipse2d . double ( xs - ws / _num , ys - hs / _num , ws , hs ) ) ; draw ( ) ; }	draws an ellipse with given semimajor and semiminor axes , centered on ( x , y ) .
@ override public cursor swapcursor ( cursor newcursor ) { malphabetindexer . setcursor ( newcursor ) ; return super . swapcursor ( newcursor ) ; }	overrides swapcursor to move the new cursor into the alphabetindex as well as the cursoradapter .
public void lockflushing ( ) { flushlock . lock ( ) ; }	lock the flushing mechanism in order to prevent a thread flushing this buffer while another thread is doing a physiological operation .
public static boolean canberandomized ( class clazz ) { return classutils . isprimitiveorwrapper ( clazz ) || clazz . equals ( string . class ) || clazz . equals ( idiscordclient . class ) ; }	checks if the class is supported to be randomized without recursion .
public static string generatenativeguid ( string devicetype , string serialnumber ) { return string . format ( _str , _devicetypemap . get ( devicetype ) , serialnumber ) ; }	the format of this native guid using the given devicetype & serialnumber .
public static secretkeys keys ( string keysstr ) throws invalidkeyexception { string [ ] keysarr = keysstr . split ( _str ) ; if ( keysarr . length != _num ) { throw new illegalargumentexception ( _str ) ; } else { byte [ ] confidentialitykey = base64 . decode ( keysarr [ _num ] , base64_flags ) ; if ( confidentialitykey . length != aes_key_length_bits / _num ) { throw new invalidkeyexception ( _str + aes_key_length_bits + _str ) ; } byte [ ] integritykey = base64 . decode ( keysarr [ _num ] , base64_flags ) ; if ( integritykey . length != hmac_key_length_bits / _num ) { throw new invalidkeyexception ( _str + hmac_key_length_bits + _str ) ; } return new secretkeys ( new secretkeyspec ( confidentialitykey , _num , confidentialitykey . length , cipher ) , new secretkeyspec ( integritykey , hmac_algorithm ) ) ; } }	an aes key derived from a base64 encoded key.
public writableraster createwritablechild ( int x , int y , int width , int height , int x0 , int y0 , int bandlist [ ] ) { if ( x < this . minx ) { throw new rasterformatexception ( _str ) ; } if ( y < this . miny ) { throw new rasterformatexception ( _str ) ; } if ( ( x + width < x ) || ( x + width > this . minx + this . width ) ) { throw new rasterformatexception ( _str ) ; } if ( ( y + height < y ) || ( y + height > this . miny + this . height ) ) { throw new rasterformatexception ( _str ) ; } samplemodel sm ; if ( bandlist != null ) sm = samplemodel . createsubsetsamplemodel ( bandlist ) ; else sm = samplemodel ; int deltax = x0 - x ; int deltay = y0 - y ; return new shortbandedraster ( sm , databuffer , new rectangle ( x0 , y0 , width , height ) , new point ( samplemodeltranslatex + deltax , samplemodeltranslatey + deltay ) , this ) ; }	creates a writable subraster given a region of the raster.
private void sortchildren ( final jcriteriumtreenode parentnode ) { final list < jcriteriumtreenode > operators = new arraylist < jcriteriumtreenode > ( ) ; final list < jcriteriumtreenode > conditions = new arraylist < jcriteriumtreenode > ( ) ; final list < jcriteriumtreenode > minus = new arraylist < jcriteriumtreenode > ( ) ; final enumeration < ? > children = parentnode . children ( ) ; while ( children . hasmoreelements ( ) ) { final jcriteriumtreenode child = ( jcriteriumtreenode ) children . nextelement ( ) ; final icriterium type = child . getcriterium ( ) ; if ( type instanceof cconditioncriterium ) { conditions . add ( child ) ; } else { operators . add ( child ) ; } } parentnode . removeallchildren ( ) ; for ( final jcriteriumtreenode child : operators ) { parentnode . add ( child ) ; child . setparent ( parentnode ) ; } for ( final jcriteriumtreenode child : conditions ) { parentnode . add ( child ) ; child . setparent ( parentnode ) ; } for ( final jcriteriumtreenode child : minus ) { parentnode . add ( child ) ; child . setparent ( parentnode ) ; } }	sorts visible tree nodes .
public static int poisson ( double lambda ) { int k = _num ; double p = _num ; double l = math . exp ( - lambda ) ; do { k ++ ; p *= uniform ( ) ; } while ( p >= l ) ; return k - _num ; }	return an integer with a poisson distribution with mean lambda .
public boolean isbuiltinsoundavailable ( string soundidentifier ) { return builtinsounds . containskey ( soundidentifier ) ; }	indicates whether a user installed or system sound is available.
public iterator < string > iterateserializers ( ) { return serializers . iterator ( ) ; }	iterate over view serializers.
private static void checkkey ( string key ) throws malformedobjectnameexception { if ( key == null ) throw new nullpointerexception ( _str ) ; final int len = key . length ( ) ; if ( len == _num ) throw new malformedobjectnameexception ( _str ) ; final char [ ] k = key . tochararray ( ) ; final int endkey = parsekey ( k , _num ) ; if ( endkey < len ) throw new malformedobjectnameexception ( _str + k [ endkey ] + _str ) ; }	check if the supplied key is a valid key .
public abstract boolean isshutdown ( ) ;	tells whether or not this asynchronous channel group is shutdown .
protected abstract void init ( ) ;	initializes the storage elements of the tree .
private void drawarc ( canvas canvas ) { if ( mcurrentdashmode . equals ( dash_mode . download ) ) { mnindeterminatestartposition += ( _num - mnprogress ) * mnstartspeed ; if ( ( mnindeterminatestartposition > circular_factor ) || ( mnindeterminatestartposition < _num ) ) { mnindeterminatestartposition = _num ; } rect currrect = new rect ( ) ; getlocalvisiblerect ( currrect ) ; float nringboundaryinner = mnringradius - ( mnringwidth / _num ) - ( mnarcwidth / _num ) ; marcrect . set ( mnviewcenter - nringboundaryinner , mnviewcenter - nringboundaryinner , mnviewcenter + nringboundaryinner , mnviewcenter + nringboundaryinner ) ; mpaint . setcolor ( marccolor ) ; mpaint . setstyle ( paint . style . stroke ) ; mpaint . setstrokewidth ( mnarcwidth ) ; mpaint . setstrokecap ( paint . cap . round ) ; canvas . drawarc ( marcrect , mnindeterminatestartposition , mnarclength , _bool , mpaint ) ; } }	draw the arc around the ring only for the download mode.
public static string formatdatetime ( java . util . date date , string format , string locale , string timezone ) { simpledateformat dateformat = getdateformat ( format , locale , timezone ) ; synchronized ( dateformat ) { return dateformat . format ( date ) ; } }	formats a date using a format string .
public static byte [ ] decode ( byte [ ] input , int offset , int len , int flags ) { decoder decoder = new decoder ( flags , new byte [ len * _num / _num ] ) ; if ( ! decoder . process ( input , offset , len , _bool ) ) { throw new illegalargumentexception ( _str ) ; } if ( decoder . op == decoder . output . length ) { return decoder . output ; } byte [ ] temp = new byte [ decoder . op ] ; system . arraycopy ( decoder . output , _num , temp , _num , decoder . op ) ; return temp ; }	decode the base64 - encoded data in input and return the data in a new byte array.
protected messagedigest ( string algorithm ) { this . algorithm = algorithm ; }	creates a message digest with the specified algorithm name .
public static int [ ] mergesort ( int [ ] a ) { if ( a . length == _num ) return a ; int [ ] x = mergesort ( arrays . copyofrange ( a , _num , a . length / _num ) ) ; int [ ] y = mergesort ( arrays . copyofrange ( a , a . length / _num , a . length ) ) ; return merge ( x , y ) ; }	merge sort . < p / > time complexity : o ( n log n ) space complexity : o ( n ) ( also needs o ( log n ) stack space as it is recursive ).
private void copyacls ( final list < accesscontrollevel > accesscontrollevels2 ) { for ( accesscontrollevel acl : this . accesscontrollevels ) { accesscontrollevels2 . add ( new accesscontrollevel ( acl ) ) ; } }	copy acls for new configuration .
public void put ( bytebuffer bytebuffer , int contentlength ) { if ( contentlength > ( bytes . length - this . contentlength ) ) { throw new illegalargumentexception ( _str ) ; } bytebuffer . get ( bytes , this . contentlength , contentlength ) ; this . contentlength += contentlength ; }	appends content from the specified bytebuffer to this bytearray.
private void handleresponse ( avsresponse response ) { boolean checkafter = ( avsqueue . size ( ) == _num ) ; if ( response != null ) { for ( int i = response . size ( ) - _num ; i >= _num ; i -- ) { if ( response . get ( i ) instanceof avsreplaceallitem || response . get ( i ) instanceof avsreplaceenqueueditem ) { avsqueue . clear ( ) ; response . remove ( i ) ; } } log . i ( tag , _str + response . size ( ) + _str ) ; avsqueue . addall ( response ) ; } if ( checkafter ) { checkqueue ( ) ; } }	handle the response sent back from alexa ' s parsing of the intent , these can be any of the avsitem types ( play , speak , stop , clear , listen ).
protected synchronized void request ( string stream ) { if ( stream == null || stream . isempty ( ) ) { return ; } stream = stream . tolowercase ( locale . english ) ; followerinfo cachedinfo = cached . get ( stream ) ; if ( cachedinfo == null || checktimepassed ( cachedinfo ) ) { if ( type == follower . type . follower ) { api . requestfollowers ( stream ) ; } else if ( type == follower . type . subscriber ) { api . requestsubscribers ( stream ) ; } } else { if ( type == follower . type . follower ) { listener . receivedfollowers ( cachedinfo ) ; } else if ( type == follower . type . subscriber ) { listener . receivedsubscribers ( cachedinfo ) ; } } }	checks if there is info already cached and whether it is old enough to be updated , in which case it requests the data from the api .
boolean removeviewifhidden ( view view ) { final int index = mcallback . indexofchild ( view ) ; if ( index == - _num ) { if ( mhiddenviews . remove ( view ) && debug ) { throw new illegalstateexception ( _str ) ; } return _bool ; } if ( mbucket . get ( index ) ) { mbucket . remove ( index ) ; mcallback . removeviewat ( index ) ; if ( ! mhiddenviews . remove ( view ) && debug ) { throw new illegalstateexception ( _str ) ; } return _bool ; } return _bool ; }	removes a view from the viewgroup if it is hidden .
public string consumecssidentifier ( ) { int start = pos ; while ( ! isempty ( ) && ( matchesword ( ) || matchesany ( _str , _str ) ) ) pos ++ ; return queue . substring ( start , pos ) ; }	consume a css identifier ( id or class ) off the queue ( letter , digit , - , _ ) http : / / www.
@ ignore ( _str ) @ test public void testpopulate1kbwrites ( ) { final byte [ ] value = new byte [ entry_size ] ; arrays . fill ( value , ( byte ) _num ) ; for ( int i = _num ; i < op_count ; i ++ ) { region . put ( new integer ( i ) , value ) ; } closedown ( ) ; }	currently not being executed for congo but after transition to jdk 1.
public void serialize ( kxmlserializer serializer ) throws ioexception { serializer . starttag ( ns , tag ) ; serializeattribute ( serializer , name_attr , mname ) ; serializeattribute ( serializer , app_package_name_attr , mapppackagename ) ; serializeattribute ( serializer , digest_attr , getdigest ( ) ) ; if ( signature_test_pkg . equals ( mname ) ) { serializer . attribute ( ns , _str , _str ) ; } msuiteroot . serialize ( serializer ) ; serializer . endtag ( ns , tag ) ; }	serialize this object and all its contents to xml .
public void rollback ( throwable t ) { log . debug ( _str + tempfile + _str + t ) ; try { filecontentstore . delete ( tempfile , node ) ; } catch ( exception e ) { t . addsuppressed ( e ) ; } }	rollback the download ( delete the temporary file ).
protected void parsegeometrystring ( ) { int i = _num ; byte [ ] bytes = geometrystring . getbytes ( ) ; xgrav = new string ( bytes , _num , _num ) ; for ( i = _num ; i < bytes . length ; i ++ ) { if ( ( bytes [ i ] == _str ) || ( bytes [ i ] == _str ) ) break ; } if ( i == bytes . length ) return ; ygrav = ( bytes [ i ] == _str ) ? _str : _str ; xpos = integer . parseint ( new string ( bytes , _num , i - _num ) ) ; ++ i ; ypos = integer . parseint ( new string ( bytes , i , bytes . length - i ) ) ; }	parse x - like geometry string .
@ override protected final synchronized boolean writedata ( bytebuffer data ) { aionserverpacket packet = sendmsgqueue . pollfirst ( ) ; if ( packet == null ) { return _bool ; } packet . setbuf ( data ) ; packet . write ( this ) ; return _bool ; }	this method will be called by dispatcher , and will be repeated till return false .
public synchronized int lastindexof ( object object , int location ) { if ( location < elementcount ) { if ( object != null ) { for ( int i = location ; i >= _num ; i -- ) { if ( object . equals ( elementdata [ i ] ) ) { return i ; } } } else { for ( int i = location ; i >= _num ; i -- ) { if ( elementdata [ i ] == null ) { return i ; } } } return - _num ; } throw arrayindexoutofboundsexception ( location , elementcount ) ; }	searches in this vector for the index of the specified object.
@ override public boolean canundo ( ) { return ! m_undolist . isempty ( ) ; }	returns whether an undo is possible , i.
protected void calculatedestination ( ifile uxf , icompilationunit referencingcompilationunit , destination dest ) throws coreexception { ifile uxfdest = calculateimgdestination ( uxf , referencingcompilationunit ) ; if ( uxfdest != null ) { dest . imgfiledestination = uxfdest ; } }	calculate the destination of the given umlet diagram . return null if the diagram reference does not need to be updated.
@ override public void onevent ( projectevent event ) { if ( event . gettype ( ) == projectevent . eventtype . updated || event . gettype ( ) == projectevent . eventtype . created ) { update ( event ) ; } }	there is a change on the project that we ' re monitoring , whatever the type of event is , we need to updated the runner .
protected abstract boolean onmouseclick ( point point ) ;	called on left mouse single click .
public void updatevisibleids ( list < integer > priority ) { if ( mnativetabcontentmanager != _num ) { int idssize = math . min ( mfullresthumbnailsmaxsize , priority . size ( ) ) ; if ( idssize != mprioritytabids . length ) { mprioritytabids = new int [ idssize ] ; } for ( int i = _num ; i < idssize ; i ++ ) { mprioritytabids [ i ] = priority . get ( i ) ; } nativeupdatevisibleids ( mnativetabcontentmanager , mprioritytabids ) ; } }	update the priority - ordered list of visible tabs .
public final void walkgraph ( hashtable semnodestable ) { integer uid = new integer ( myuid ) ; if ( semnodestable . get ( uid ) != null ) return ; semnodestable . put ( new integer ( myuid ) , this ) ; }	tostring , leveldatatostring , and walkgraph methods to implement explorenode interface.
public boolean showpreviousnotification ( ) { int i = getselectedindex ( ) ; if ( i != - _num && i > _num ) { model . setselecteditem ( model . getelementat ( i - _num ) ) ; return _bool ; } return _bool ; }	scrolls to the previous notification .
@ override public void writeexternal ( objectoutput out ) throws ioexception { super . writeexternal ( out ) ; out . writeboolean ( isleaf ) ; out . writeint ( numentries ) ; }	calls the super method and writes the id of this node , the numentries and the entries array to the specified stream .
protected void addinputnode_internal ( bnode inputnode ) { if ( inputnodes . containskey ( inputnode . getid ( ) ) ) { log . warning ( _str + inputnode . getid ( ) + _str + nodeid ) ; } inputnodes . put ( inputnode . getid ( ) , inputnode ) ; }	adds a new incoming relation to the node.
public static void initialize ( final cdatabaseconfiguration configuration ) throws couldntloaddriverexception , couldntconnectexception , sqlexception { checkdriver ( configuration ) ; final string url = postgres_driver + _str + configuration . gethost ( ) + _str + postgres_default_db ; connection connection = null ; try { connection = drivermanager . getconnection ( url , configuration . getuser ( ) , configuration . getpassword ( ) ) ; } catch ( final sqlexception exception ) { cutilityfunctions . logexception ( exception ) ; throw new couldntconnectexception ( exception , exception . geterrorcode ( ) , exception . getsqlstate ( ) ) ; } final string statement = _str + configuration . getname ( ) + _str ; final preparedstatement preparedstatement = connection . preparestatement ( statement ) ; try { preparedstatement . execute ( ) ; } finally { preparedstatement . close ( ) ; connection . close ( ) ; } }	initializes a new postgresql database.
private void registerobjectread ( object obj , int handle , boolean unshared ) throws ioexception { if ( unshared ) { obj = unshared_obj ; } int index = handle - objectstreamconstants . basewirehandle ; int size = objectsread . size ( ) ; while ( index > size ) { objectsread . add ( null ) ; ++ size ; } if ( index == size ) { objectsread . add ( obj ) ; } else { objectsread . set ( index , obj ) ; } }	associates a read object with the its serialization handle .
public static void addextensionheader ( string headername , string classname ) { namemap . put ( headername . tolowercase ( ) , classname ) ; }	add an extension header to this map .
public boolean merge ( final frame < ? extends v > frame , final interpreter < v > interpreter ) throws analyzerexception { if ( top != frame . top ) { throw new analyzerexception ( null , _str ) ; } boolean changes = _bool ; for ( int i = _num ; i < locals + top ; ++ i ) { v v = interpreter . merge ( values [ i ] , frame . values [ i ] ) ; if ( ! v . equals ( values [ i ] ) ) { values [ i ] = v ; changes = _bool ; } } return changes ; }	merges this frame with the given frame .
public static void keytool ( string cmd ) { log . info ( _str + cmd ) ; arraylist < string > list = new arraylist < string > ( ) ; stringtokenizer st = new stringtokenizer ( cmd , _str ) ; string quotebuffer = null ; while ( st . hasmoretokens ( ) ) { string token = st . nexttoken ( ) ; if ( quotebuffer == null ) { if ( token . startswith ( _str ) ) quotebuffer = token . substring ( _num ) ; else list . add ( token ) ; } else quotebuffer += _str + token ; if ( token . endswith ( _str ) ) { string str = quotebuffer . substring ( _num , quotebuffer . length ( ) - _num ) ; list . add ( str ) ; quotebuffer = null ; } } string [ ] args = new string [ list . size ( ) ] ; list . toarray ( args ) ; try { keytool . main ( args ) ; } catch ( exception e ) { } }	submit command to key tool.
private void smoothsnaptoposition ( int scrolly , int availablescrollheight , alphabeticalappslist . fastscrollsectioninfo info ) { mrv . removecallbacks ( msmoothsnapnextframerunnable ) ; mrv . removecallbacks ( mfastscrolltotargetsectionrunnable ) ; trackallchildviews ( ) ; if ( mhasfastscrolltouchsettled ) { mcurrentfastscrollsection = info . sectionname ; mtargetfastscrollsection = null ; updatetrackedviewsfastscrollfocusstate ( ) ; } else { mcurrentfastscrollsection = null ; mtargetfastscrollsection = info . sectionname ; mhasfastscrolltouchsettled = _bool ; updatetrackedviewsfastscrollfocusstate ( ) ; mrv . postdelayed ( mfastscrolltotargetsectionrunnable , mhasfastscrolltouchsettledatleastonce ? repeat_touch_settling_duration : initial_touch_settling_duration ) ; } int newscrolly = math . min ( availablescrollheight , mrv . getpaddingtop ( ) + mrv . gettop ( info . fastscrolltoitem . rowindex ) ) ; int numframes = mfastscrollframes . length ; for ( int i = _num ; i < numframes ; i ++ ) { mfastscrollframes [ i ] = ( newscrolly - scrolly ) / numframes ; } mfastscrollframeindex = _num ; mrv . postonanimation ( msmoothsnapnextframerunnable ) ; }	smoothly snaps to a given position.
private void updatepropertytovalue2 ( ) throws exception { properties . put ( test_key , test_value_2 ) ; updatepropertiesfile ( ) ; }	updates the key in the persistent property store to " value 2 " .
public void unassignservices ( string universalid , set servicenames ) throws amconsoleexception { if ( ( servicenames != null ) && ! servicenames . isempty ( ) ) { string [ ] params = new string [ _num ] ; params [ _num ] = universalid ; string currentsvc = _str ; try { amidentity amid = idutils . getidentity ( getuserssotoken ( ) , universalid ) ; for ( iterator iter = servicenames . iterator ( ) ; iter . hasnext ( ) ; ) { currentsvc = ( string ) iter . next ( ) ; params [ _num ] = currentsvc ; logevent ( _str , params ) ; amid . unassignservice ( currentsvc ) ; logevent ( _str , params ) ; } } catch ( ssoexception e ) { string [ ] paramsex = { universalid , currentsvc , geterrorstring ( e ) } ; logevent ( _str , paramsex ) ; debug . warning ( _str , e ) ; throw new amconsoleexception ( geterrorstring ( e ) ) ; } catch ( idrepoexception e ) { string [ ] paramsex = { universalid , currentsvc , geterrorstring ( e ) } ; logevent ( _str , paramsex ) ; debug . warning ( _str , e ) ; throw new amconsoleexception ( geterrorstring ( e ) ) ; } } }	unassigns services from an entity .
private cluster < t > expandcluster ( final cluster < t > cluster , final t point , final list < t > neighbors , final collection < t > points , final map < clusterable , pointstatus > visited ) { cluster . addpoint ( point ) ; visited . put ( point , pointstatus . part_of_cluster ) ; list < t > seeds = new arraylist < t > ( neighbors ) ; int index = _num ; while ( index < seeds . size ( ) ) { final t current = seeds . get ( index ) ; pointstatus pstatus = visited . get ( current ) ; if ( pstatus == null ) { final list < t > currentneighbors = getneighbors ( current , points ) ; if ( currentneighbors . size ( ) >= minpts ) { seeds = merge ( seeds , currentneighbors ) ; } } if ( pstatus != pointstatus . part_of_cluster ) { visited . put ( current , pointstatus . part_of_cluster ) ; cluster . addpoint ( current ) ; } index ++ ; } return cluster ; }	expands the cluster to include density - reachable items .
private static address getfloatarrayelements ( jnienvironment env , int arrayjref , address iscopyaddress ) { if ( tracejni ) vm . syswrite ( _str ) ; runtimeentrypoints . checkjnicountdowntogc ( ) ; try { float [ ] sourcearray = ( float [ ] ) env . getjniref ( arrayjref ) ; int size = sourcearray . length ; if ( memorymanager . willnevermove ( sourcearray ) ) { jnigenerichelpers . setboolstar ( iscopyaddress , _bool ) ; return magic . objectasaddress ( sourcearray ) ; } else { address copybuffer = syscall . sysmalloc ( size << log_bytes_in_float ) ; if ( copybuffer . iszero ( ) ) { env . recordexception ( new outofmemoryerror ( ) ) ; return address . zero ( ) ; } memory . memcopy ( copybuffer , magic . objectasaddress ( sourcearray ) , size << log_bytes_in_float ) ; jnigenerichelpers . setboolstar ( iscopyaddress , _bool ) ; return copybuffer ; } } catch ( throwable unexpected ) { if ( tracejni ) unexpected . printstacktrace ( system . err ) ; env . recordexception ( unexpected ) ; return address . zero ( ) ; } }	getfloatarrayelements : get all the elements of a float array.
private void preparetransfers ( ) throws libusbexception { if ( mavailabletransfers == null ) { mavailabletransfers = new linkedtransferqueue < > ( ) ; for ( int x = _num ; x < transfer_buffer_pool_size ; x ++ ) { transfer transfer = libusb . alloctransfer ( ) ; if ( transfer == null ) { throw new libusbexception ( _str , libusb . error_no_mem ) ; } final bytebuffer buffer = bytebuffer . allocatedirect ( mbuffersize ) ; libusb . fillbulktransfer ( transfer , mdevicehandle , usb_endpoint , buffer , bufferprocessor . this , _str , usb_timeout_us ) ; mavailabletransfers . add ( transfer ) ; } } }	prepares ( allocates ) a set of transfer buffers for use in transferring data from the tuner via the bulk interface.
private void outputfulllines ( ) throws ioexception { for ( ; ; ) { int leftlen = leftbuf . indexof ( _str ) ; if ( leftlen < _num ) { return ; } int rightlen = rightbuf . indexof ( _str ) ; if ( rightlen < _num ) { return ; } if ( leftlen != _num ) { out . write ( leftbuf . substring ( _num , leftlen ) ) ; } if ( rightlen != _num ) { writespaces ( out , leftwidth - leftlen ) ; out . write ( rightbuf . substring ( _num , rightlen ) ) ; } out . write ( _str ) ; leftbuf . delete ( _num , leftlen + _num ) ; rightbuf . delete ( _num , rightlen + _num ) ; } }	outputs to the final destination as many full line pairs as there are in the pending output , removing those lines from their respective buffers.
@ secured public void addpay_simple ( long userid , bigdecimal amount , date created , paymenttype paytype , string details , boolean updatecache ) throws concurrentupdatesqlexception , exception { checkaccessfor_admin ( ) ; amount = amount . abs ( ) ; long id = universal . nextseqfor ( payments ) ; paymentext payment = paymentext . createsystempayment ( id , userid , amount , created , paytype , details ) ; bigdecimal newval = dopayment ( userid , payment , updatecache ) ; log . info ( _str + userid + ( newval != null ? _str + newval : _str ) + _str + getreqinfostr ( ) ) ; }	positive amount . no unblocks if blocked.
public void registerunregisterednamespaces ( ) { for ( int i = _num ; i < m_unregisteredextensions . size ( ) ; i ++ ) { string ns = ( string ) m_unregisteredextensions . get ( i ) ; extensionnamespacesupport extnsspt = definejavanamespace ( ns ) ; if ( extnsspt != null ) m_extensions . add ( extnsspt ) ; } }	attempt to register any unregistered extension namespaces .
private void removeallobjects ( ) { logger . debug ( _str ) ; texts . clear ( ) ; }	remove all map objects .
public builder deletedisplayname ( ) { deletefields . add ( _str ) ; return this ; }	deletes the display name of a existing user.
public static type newtype ( ast ast , variabledeclaration declaration ) { return newtype ( ast , declaration , null , null ) ; }	returns the new type node corresponding to the type of the given declaration including the extra dimensions .
public void delete ( ) throws ioexception { close ( ) ; util . deletecontents ( directory ) ; }	closes the cache and deletes all of its stored values.
private void waitforiteratorscleared ( ignitecache < string , integer > cache , int secs ) throws interruptedexception { for ( int i = _num ; i < secs ; i ++ ) { try { cache . size ( ) ; checkiteratorscleared ( ) ; } catch ( assertionfailederror e ) { if ( i == _num ) { for ( int j = _num ; j < gridcount ( ) ; j ++ ) executeonlocalorremotejvm ( j , new printiteratorstatetask ( ) ) ; throw e ; } log . info ( _str ) ; thread . sleep ( _num ) ; } } }	checks iterators are cleared .
public void addlifecyclelistener ( lifecyclelistener lifecyclelistener ) { if ( ! lifecyclelisteners . contains ( lifecyclelistener ) ) { lifecyclelisteners . add ( lifecyclelistener ) ; } }	adds a listener for all of this controller ' s lifecycle events.
private int indexof ( string fullpath ) { for ( int i = _num , length = this . relativepaths . length ; i < length ; i ++ ) { string currentrelativepath = this . relativepaths [ i ] ; if ( currentrelativepath == null ) continue ; string currentcontainerpath = this . containerpaths [ i ] ; string currentfullpath = currentrelativepath . length ( ) == _num ? currentcontainerpath : ( currentcontainerpath + _str + currentrelativepath ) ; if ( encloses ( currentfullpath , fullpath , i ) ) return i ; } return - _num ; }	returns paths list index of given path or - 1 if not found . note : use indexof ( string , string ) for path inside jars.
boolean destroyvolume ( boolean force ) { naelement elem = new naelement ( _str ) ; elem . addnewchild ( _str , boolean . tostring ( force ) ) ; elem . addnewchild ( _str , name ) ; try { server . invokeelem ( elem ) ; return _bool ; } catch ( exception e ) { string msg = _str + name ; log . error ( msg , e ) ; throw new netappexception ( msg , e ) ; } }	destroys a volume , releasing all storage blocks assigned to it .
public static generalpath stackspline ( generalpath p , float [ ] pts , float epsilon , float slack , boolean closed , float tx , float ty ) { int npoints = _num ; for ( ; npoints < pts . length ; ++ npoints ) if ( float . isnan ( pts [ npoints ] ) ) break ; return stackspline ( p , pts , _num , npoints / _num , epsilon , slack , closed , tx , ty ) ; }	computes a set of curves using the cardinal spline approach , but using straight lines for completely horizontal or vertical segments .
private boolean validatecooldownsetting ( string appid , autoscalerpolicytrigger policytrigger , string triggerid ) { autoscalingdatastore statestore = autoscalingdatastorefactory . getautoscalingdatastore ( ) ; appautoscalestate appstate = null ; appstate = statestore . getscalingstate ( appid ) ; if ( appstate == null ) { return _bool ; } else if ( ( appstate . getinstancecountstate ( ) != scalingstatemanager . scaling_state_completed ) && ( appstate . getinstancecountstate ( ) != scalingstatemanager . scaling_state_failed ) ) { long laststarttime = appstate . getlastactionstarttime ( ) ; long currenttime = system . currenttimemillis ( ) ; boolean timeexpired = ( currenttime - laststarttime ) > this . eventtimeout ; if ( timeexpired ) { logger . debug ( _str + appid + _str ) ; return _bool ; } logger . debug ( _str + appid + _str ) ; return _bool ; } else { long cooldownendtime = appstate . getlastactionendtime ( ) + _num * getcooldownsecs ( policytrigger , triggerid ) ; if ( system . currenttimemillis ( ) < cooldownendtime ) { logger . debug ( _str + appid + _str ) ; return _bool ; } } return _bool ; }	checks if the app should be scaled in / out according to cooldown settings.
private long converttobytes ( int megabytes ) { long bytes = megabytes ; bytes = bytes * _num * _num ; return bytes ; }	takes an int which is supposed to be in megabytes and converts it to a long.
private string generatezonesetclonename ( string zonesettoclone ) { try { thread . sleep ( _num ) ; } catch ( interruptedexception ex ) { _log . warn ( ex . getlocalizedmessage ( ) ) ; } calendar cal = calendar . getinstance ( ) ; dateformat dateformat = new simpledateformat ( _str ) ; string datestring = dateformat . format ( cal . gettime ( ) ) ; string longname = mdsdialogproperties . getstring ( _str ) ; if ( ! longname . contains ( _str ) ) { return longname ; } return _str + zonesettoclone + _str + datestring ; }	generate a unique name for the zoneset clone.
protected abstract void writesignatureblock ( byte [ ] signature , outputstream out ) throws ioexception ;	write a . rsa file with a digital signature .
private stringbuffer buildselectquery ( string schemaname , string tablename , arraylist < onerowchange . columnspec > keys , arraylist < onerowchange . columnval > keyvalues ) { stringbuffer stmt = new stringbuffer ( ) ; stmt . append ( _str ) ; stmt . append ( conn . getdatabaseobjectname ( schemaname ) + _str + conn . getdatabaseobjectname ( tablename ) ) ; stmt . append ( _str ) ; printcolumnspec ( stmt , keys , keyvalues , printmode . assignment , _str ) ; return stmt ; }	constructs a sql statement template later used for prepared statement .
public void show ( animation anim ) { manim = anim ; show ( ) ; }	starts the animation given as parameter .
public static boolean isurikey ( string key ) { return key . endswith ( _str ) || key . endswith ( _str ) ; }	this method determines if the supplied key relates to a uri .
public int receive ( byte [ ] buffer , int offset , int count , int timeout ) { checkarraybounds ( buffer , offset , count ) ; if ( count == _num ) { return _num ; } byte [ ] data = buffer ; if ( offset > _num ) { data = new byte [ count ] ; } intout bytesreceivedout = new intout ( ) ; try { idevice . checkresult ( libimobiledevice . idevice_connection_receive_timeout ( getref ( ) , data , count , bytesreceivedout , timeout ) ) ; int bytesread = bytesreceivedout . getvalue ( ) ; if ( bytesread > _num && data != buffer ) { system . arraycopy ( data , _num , buffer , offset , bytesread ) ; } return bytesread ; } finally { bytesreceivedout . delete ( ) ; } }	receives data from the device.
public synchronized void addofchannelhandlerandsendrole ( ofchannelhandler h ) { connectedchannelhandlers . add ( h ) ; h . sendrolerequest ( this . role ) ; }	add a newly connected ofchannelhandler.
public boolean send ( byte [ ] bytes ) { if ( ! connected ) return _bool ; try { outputstream . write ( bytes ) ; outputstream . flush ( ) ; return _bool ; } catch ( ioexception e ) { connected = _bool ; log . e ( tag , _str ) ; return _bool ; } finally { if ( ! connected ) { closeconnection ( ) ; } } }	send array of bytes to bluetooth output stream .
public copyonwritearraylist ( collection c ) { object [ ] elements = new object [ c . size ( ) ] ; int size = _num ; for ( iterator itr = c . iterator ( ) ; itr . hasnext ( ) ; ) { object e = itr . next ( ) ; elements [ size ++ ] = e ; } setarray ( elements ) ; }	creates a list containing the elements of the specified collection , in the order they are returned by the collection ' s iterator .
private byte [ ] entitytobytes ( httpentity entity ) throws ioexception , servererror { poolingbytearrayoutputstream bytes = new poolingbytearrayoutputstream ( mpool , ( int ) entity . getcontentlength ( ) ) ; byte [ ] buffer = null ; try { inputstream in = entity . getcontent ( ) ; if ( in == null ) { throw new servererror ( ) ; } buffer = mpool . getbuf ( _num ) ; int count ; while ( ( count = in . read ( buffer ) ) != - _num ) { bytes . write ( buffer , _num , count ) ; } return bytes . tobytearray ( ) ; } finally { try { entity . consumecontent ( ) ; } catch ( ioexception e ) { volleylog . v ( _str ) ; } mpool . returnbuf ( buffer ) ; bytes . close ( ) ; } }	reads the contents of httpentity into a byte [ ] .
public void addtailarg ( string arg ) { _tailargs . add ( arg ) ; }	adds an arg after the command and any options .
public inlineurihandler ( final string namespace ) { this . namespace = namespace ; this . len = namespace . length ( ) ; }	create a handler for the supplied namespace prefix - the handler will be invoked iff it is the registered handler having the longest prefix lte to the actual uri .
private double [ ] calcvariablecoef ( variogram variogram , krigingpoint p , list < krigingpoint > nnpoints ) { int n = nnpoints . size ( ) ; double [ ] mat = new double [ n + _num ] ; double dist = _num ; for ( int i = _num ; i < n ; i ++ ) { dist = math . sqrt ( math . abs ( math . pow ( nnpoints . get ( i ) . x - p . x , _num ) ) + math . abs ( math . pow ( nnpoints . get ( i ) . y - p . y , _num ) ) ) ; mat [ i ] = gettheoreticalsvvalue ( dist , variogram ) ; } mat [ n ] = _num ; return mat ; }	calculates the d matrix for kriging system.
public static object deserialization ( string filepath ) { objectinputstream in = null ; try { in = new objectinputstream ( new fileinputstream ( filepath ) ) ; object o = in . readobject ( ) ; in . close ( ) ; return o ; } catch ( filenotfoundexception e ) { throw new runtimeexception ( _str , e ) ; } catch ( classnotfoundexception e ) { throw new runtimeexception ( _str , e ) ; } catch ( ioexception e ) { throw new runtimeexception ( _str , e ) ; } finally { ioutils . close ( in ) ; } }	deserialization object from file .
private static boolean ismergedsegment ( string segname ) { if ( segname . contains ( _str ) ) { return _bool ; } return _bool ; }	to check if the segment is merged or not .
public static cipherparameters makepbemacparameters ( pbekeyspec keyspec , int type , int hash , int keysize ) { pbeparametersgenerator generator = makepbegenerator ( type , hash ) ; byte [ ] key ; cipherparameters param ; key = convertpassword ( type , keyspec ) ; generator . init ( key , keyspec . getsalt ( ) , keyspec . getiterationcount ( ) ) ; param = generator . generatederivedmacparameters ( keysize ) ; for ( int i = _num ; i != key . length ; i ++ ) { key [ i ] = _num ; } return param ; }	generate a pbe based key suitable for a mac algorithm , the key size is chosen according the mac size , or the hashing algorithm , whichever is greater .
public void addemojicongroup ( list < easeemojicongroupentity > groupentitielist ) { for ( int i = _num ; i < groupentitielist . size ( ) ; i ++ ) { easeemojicongroupentity groupentity = groupentitielist . get ( i ) ; emojicongrouplist . add ( groupentity ) ; pagerview . addemojicongroup ( groupentity , i == groupentitielist . size ( ) - _num ? _bool : _bool ) ; tabbar . addtab ( groupentity . geticon ( ) ) ; } }	add emojicon group list.
public void updateend ( logger log ) { m_instancecount ++ ; m_samplecount ++ ; double end = system . currenttimemillis ( ) ; double temp = end - m_updatestart ; m_cumulativetime += temp ; boolean tofasttomeasure = _bool ; if ( ( end - m_starttime ) >= m_sampletime ) { computeupdate ( end ) ; if ( log != null ) { log . statusmessage ( m_statusmessageprefix + _str + m_instancecount + _str + m_avinstspersec / m_numsamples + _str + ( tofasttomeasure ? _str : _str ) ) ; } m_samplecount = _num ; m_cumulativetime = _num ; m_starttime = system . currenttimemillis ( ) ; } }	register a throughput measurement end point.
public boolean shouldinclude ( final path path ) { return includematchers . size ( ) == _num || matches ( path , includematchers ) ; }	check whether a path should be included .
public arraylist < mechsummary > generateunits ( int num , unitfilter filter ) { arraylist < mechsummary > retval = new arraylist < > ( ) ; for ( int i = _num ; i < num ; i ++ ) { mechsummary ms = generateunit ( filter ) ; if ( ms != null ) { retval . add ( ms ) ; } } return retval ; }	selects a number of units from the table with a filter .
static public automaton concatenate ( automaton a1 , automaton a2 ) { return concatenate ( arrays . aslist ( a1 , a2 ) ) ; }	returns an automaton that accepts the concatenation of the languages of the given automata.
public void contentschanged ( listdataevent e ) { object oldselection = selecteditemreminder ; object newselection = datamodel . getselecteditem ( ) ; if ( oldselection == null || ! oldselection . equals ( newselection ) ) { selecteditemchanged ( ) ; if ( ! selectingitem ) { fireactionevent ( ) ; } } }	this method is public as an implementation side effect.
protected void createfromhvalues ( int [ ] hvalues , int partitions ) { arrays . sort ( hvalues ) ; this . splits = new int [ partitions ] ; int maxh = _num ; for ( int i = _num ; i < splits . length ; i ++ ) { int quantile = ( int ) ( ( long ) ( i + _num ) * hvalues . length / partitions ) ; this . splits [ i ] = quantile == hvalues . length ? maxh : hvalues [ quantile ] ; } }	create a hilbertcurvepartitioner from a list of points.
private void readobject ( objectinputstream oos ) throws ioexception , classnotfoundexception { iinstant = ( localdatetime ) oos . readobject ( ) ; datetimefieldtype type = ( datetimefieldtype ) oos . readobject ( ) ; ifield = type . getfield ( iinstant . getchronology ( ) ) ; }	reads the property from a safe serialization format .
public void testconstructor_inetaddressiinetaddressi ( ) throws exception { int sport = startserver ( _str ) ; sslsocket ssl = getsslsocket ( inetaddress . getlocalhost ( ) , sport , inetaddress . getlocalhost ( ) , _num ) ; assertnotnull ( ssl ) ; assertequals ( sport , ssl . getport ( ) ) ; ssl . close ( ) ; try { getsslsocket ( inetaddress . getlocalhost ( ) , _num , inetaddress . getlocalhost ( ) , _num ) ; fail ( ) ; } catch ( ioexception expected ) { } try { getsslsocket ( inetaddress . getlocalhost ( ) , - _num , inetaddress . getlocalhost ( ) , sport + _num ) ; fail ( ) ; } catch ( illegalargumentexception expected ) { } try { getsslsocket ( inetaddress . getlocalhost ( ) , sport , inetaddress . getlocalhost ( ) , - _num ) ; fail ( ) ; } catch ( illegalargumentexception expected ) { } try { getsslsocket ( inetaddress . getlocalhost ( ) , integer . min_value , inetaddress . getlocalhost ( ) , sport + _num ) ; fail ( ) ; } catch ( ioexception expectedonri ) { asserttrue ( standardnames . is_ri ) ; } catch ( illegalargumentexception expectedonandroid ) { assertfalse ( standardnames . is_ri ) ; } try { getsslsocket ( inetaddress . getlocalhost ( ) , sport , inetaddress . getlocalhost ( ) , integer . max_value ) ; fail ( ) ; } catch ( illegalargumentexception expectedonandroid ) { assertfalse ( standardnames . is_ri ) ; } }	javax . net . ssl . sslsocket # sslsocket ( inetaddress address , int port , inetaddress clientaddress , int clientport ).
private string convertuserinputintoafullyqualifiedpath ( final string userinput ) { if ( fileutils . denotesabsolutepath ( userinput ) ) { return userinput ; } if ( userinput . startswith ( home_directory_symbol ) ) { assert . notnull ( home , _str ) ; if ( userinput . length ( ) > _num ) { return home + userinput . substring ( _num ) ; } } string fullpath = getworkingdirectoryasstring ( ) + userinput ; return fullpath ; }	if the user input starts with a tilde character ( ~ ) , replace the tilde character with the user ' s home directory.
static final int resizestamp ( int n ) { return integer . numberofleadingzeros ( n ) | ( _num << ( resize_stamp_bits - _num ) ) ; }	returns the stamp bits for resizing a table of size n.
public byte readbyte ( ) throws ioexception { return dis . readbyte ( ) ; }	read a byte from the input stream .
protected static byte [ ] hkdfexpand ( byte [ ] ikm , byte [ ] salt , byte [ ] info , int length ) throws invalidkeyexception , nosuchalgorithmexception { hkdfbytesgenerator hkdf = new hkdfbytesgenerator ( new sha256digest ( ) ) ; hkdf . init ( new hkdfparameters ( ikm , salt , info ) ) ; byte [ ] okm = new byte [ length ] ; hkdf . generatebytes ( okm , _num , length ) ; return okm ; }	convenience method for computing the hmac key derivation function.
public boolean isemoteignored ( emoticon emote ) { return ignoredemotes . contains ( emote . code ) ; }	check if the given emote is on the list of ignored emotes.
public boolean ispropertyallowed ( name name ) { return propertiesallowed . contains ( name ) ; }	is the given word the name of an allowed css property ?.
@ suppresswarnings ( _str ) public void readfile ( string filename ) throws jdomexception , ioexception { if ( checkfile ( filename ) ) { element root = rootfromname ( filename ) ; element roster ; if ( root == null ) { log . warn ( _str ) ; return ; } roster = root . getchild ( _str ) ; if ( roster == null ) { log . debug ( _str ) ; return ; } iterator < element > consistiterator = root . getdescendants ( new elementfilter ( _str ) ) ; try { element consist ; do { consist = consistiterator . next ( ) ; consistfromxml ( consist ) ; } while ( consistiterator . hasnext ( ) ) ; } catch ( nosuchelementexception nde ) { log . debug ( _str ) ; } } else { log . info ( _str ) ; } }	read all consists from a file .
public void testconstructorsignbyteszeronull2 ( ) { byte abytes [ ] = { } ; int asign = _num ; byte rbytes [ ] = { _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = anumber . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , anumber . signum ( ) ) ; }	create a zero number from a sign and an array of zero length.
private int accept ( filedescriptor ssfd , filedescriptor newfd , inetsocketaddress [ ] isaa ) throws ioexception { return accept0 ( ssfd , newfd , isaa ) ; }	accept a connection on a socket .
protected void transcode ( file file , transcoder transcoder ) throws ioexception , transcoderexception { transcoder . addtranscodinghint ( xmlabstracttranscoder . key_xml_parser_validating , boolean . false ) ; svgdocument doc = clonedocument ( ) ; transcoderinput input = new transcoderinput ( doc ) ; outputstream out = new bufferedoutputstream ( new fileoutputstream ( file ) ) ; transcoderoutput output = new transcoderoutput ( out ) ; transcoder . transcode ( input , output ) ; out . flush ( ) ; out . close ( ) ; }	transcode a document into a file using the given transcoder .
private void reportprogress ( state state , innerstate innerstate ) { long now = system . currenttimemillis ( ) ; if ( innerstate . mbytessofar - innerstate . mbytesnotified > constants . min_progress_step && now - innerstate . mtimelastnotification > constants . min_progress_time ) { minfo . mcurrentbytes = innerstate . mbytessofar ; mdb . updatedownloadcurrentbytes ( minfo ) ; innerstate . mbytesnotified = innerstate . mbytessofar ; innerstate . mtimelastnotification = now ; long totalbytessofar = innerstate . mbytesthissession + mservice . mbytessofar ; if ( constants . logvv ) { log . v ( constants . tag , _str + minfo . mcurrentbytes + _str + minfo . mtotalbytes ) ; log . v ( constants . tag , _str + totalbytessofar + _str + mservice . mtotallength ) ; } mservice . notifyupdatebytes ( totalbytessofar ) ; } }	report download progress through the database if necessary .
@ override public document newdocument ( ) { return new mf . org . apache . xerces . dom . documentimpl ( ) ; }	non - preferred : use the getdomimplementation ( ) method instead of this one to get a dom level 2 domimplementation object and then use dom level 2 methods to create a dom document object .
@ hlefunction ( nid = _num , version = _num , checkinsideinterrupt = _bool ) public int __scesassetgrain ( int sascore , int grain ) { checksashandlegood ( sascore ) ; grainsamples = grain ; return _num ; }	set the number of samples generated by one __scesascore call .
public void handletblrequesthandlerlistbuttonaddrequest ( requestinvocationevent event ) throws modelcontrolexception { try { map values = getvalues ( ) ; onbeforesaveprofile ( values ) ; setpagesessionattribute ( property_attribute , ( hashmap ) values ) ; scsaml2soapbindingrequesthandlerlistaddviewbean vb = ( scsaml2soapbindingrequesthandlerlistaddviewbean ) getviewbean ( scsaml2soapbindingrequesthandlerlistaddviewbean . class ) ; unlockpagetrail ( ) ; passpgsessionmap ( vb ) ; vb . forwardto ( getrequestcontext ( ) ) ; } catch ( amconsoleexception e ) { setinlinealertmessage ( ccalert . type_error , _str , e . getmessage ( ) ) ; } }	handles add request handler request .
protected static void drawdatapoint ( double x , double y , double xprev , double yprev , int size , int shape , graphics gx ) { drawdatapoint ( x , y , size , shape , gx ) ; gx . drawline ( ( int ) x , ( int ) y , ( int ) xprev , ( int ) yprev ) ; }	draws a data point at a given set of panel coordinates at a given size and connects a line to the previous point .
static boolean chunkset ( internaldistributedmember recipient , set set , int chunk_size_in_bytes , boolean includevalues , objectintprocedure proc ) throws ioexception { iterator it = set . iterator ( ) ; boolean keepgoing = _bool ; boolean sentlastchunk = _bool ; final heapdataoutputstream mos = new heapdataoutputstream ( initialimageoperation . chunk_size_in_bytes + _num , recipient . getversionobject ( ) ) ; do { mos . reset ( ) ; int avgitemsize = _num ; int itemcount = _num ; while ( ( mos . size ( ) + avgitemsize ) < initialimageoperation . chunk_size_in_bytes && it . hasnext ( ) ) { object key = it . next ( ) ; dataserializer . writeobject ( key , mos ) ; itemcount ++ ; avgitemsize = mos . size ( ) / itemcount ; } dataserializer . writeobject ( ( object ) null , mos ) ; int lastmsg = it . hasnext ( ) ? _num : _num ; keepgoing = proc . executewith ( mos , lastmsg ) ; sentlastchunk = lastmsg == _num && keepgoing ; } while ( keepgoing && it . hasnext ( ) ) ; return sentlastchunk ; }	serialize the given set ' s elments into byte [ ] chunks , calling proc for each one.
private int [ ] parsemetadatainformation ( ) throws usererror { int [ ] selectedcolumns = new int [ metadata . size ( ) ] ; set < string > usedcolumnnames = new hashset < > ( ) ; int columnindex = _num ; int usedcolumnindex = _num ; for ( columnmetadata column : metadata ) { if ( ! column . isremoved ( ) ) { selectedcolumns [ usedcolumnindex ] = columnindex ; usedcolumnindex ++ ; string columnname = column . getname ( ) ; if ( ! usedcolumnnames . contains ( columnname ) ) { usedcolumnnames . add ( columnname ) ; } else { throw new usererror ( null , _str , columnname ) ; } } columnindex ++ ; } int [ ] attributecolumns = arrays . copyof ( selectedcolumns , usedcolumnindex ) ; return attributecolumns ; }	goes once through the metadata , checks which columns are removed and checks that the remaining columns have unique names .
static field findfield ( object instance , string name ) throws nosuchfieldexception { for ( class < ? > clazz = instance . getclass ( ) ; clazz != null ; clazz = clazz . getsuperclass ( ) ) { try { field field = clazz . getdeclaredfield ( name ) ; if ( ! field . isaccessible ( ) ) { field . setaccessible ( _bool ) ; } return field ; } catch ( nosuchfieldexception e ) { } } throw new nosuchfieldexception ( _str + name + _str + instance . getclass ( ) ) ; }	locates a given field anywhere in the class inheritance hierarchy .
sslsession tosession ( byte [ ] data , string host , int port ) { bytearrayinputstream bais = new bytearrayinputstream ( data ) ; datainputstream dais = new datainputstream ( bais ) ; try { int type = dais . readint ( ) ; if ( type != open_ssl ) { log ( new assertionerror ( _str + type ) ) ; return null ; } int length = dais . readint ( ) ; byte [ ] sessiondata = new byte [ length ] ; dais . readfully ( sessiondata ) ; int count = dais . readint ( ) ; x509certificate [ ] certs = new x509certificate [ count ] ; for ( int i = _num ; i < count ; i ++ ) { length = dais . readint ( ) ; byte [ ] certdata = new byte [ length ] ; dais . readfully ( certdata ) ; certs [ i ] = opensslx509certificate . fromx509der ( certdata ) ; } return new opensslsessionimpl ( sessiondata , host , port , certs , this ) ; } catch ( ioexception e ) { log ( e ) ; return null ; } }	creates a session from the given bytes .
private void adddumpfile ( ) { adddumpfile ( dumpfile ) ; }	add the set dumpfilestream to the tree.
private static boolean datebyordinal ( datetimeformatterbuilder bld , collection < datetimefieldtype > fields , boolean extended , boolean strictiso ) { boolean reducedprec = _bool ; if ( fields . remove ( datetimefieldtype . year ( ) ) ) { bld . append ( yearelement ( ) ) ; if ( fields . remove ( datetimefieldtype . dayofyear ( ) ) ) { appendseparator ( bld , extended ) ; bld . appenddayofyear ( _num ) ; } else { reducedprec = _bool ; } } else if ( fields . remove ( datetimefieldtype . dayofyear ( ) ) ) { bld . appendliteral ( _str ) ; bld . appenddayofyear ( _num ) ; } return reducedprec ; }	creates a date using the ordinal date format.
public boolean ispageinrange ( int pagenumber ) { for ( int ind = _num ; ind < sequencestarts . size ( ) ; ind ++ ) { if ( sequencestarts . get ( ind ) <= pagenumber && pagenumber <= sequenceends . get ( ind ) ) return _bool ; } return _bool ; }	checks if a given page is present in the range built so far .
public void dispose ( ) { logdebug ( _str ) ; msetupdone = _bool ; if ( mserviceconn != null ) { logdebug ( _str ) ; if ( mcontext != null ) mcontext . unbindservice ( mserviceconn ) ; } mdisposed = _bool ; mcontext = null ; mserviceconn = null ; mservice = null ; mpurchaselistener = null ; }	dispose of object , releasing resources.
@ suppresswarnings ( _str ) public static < t extends dimensionalitemobject > list < t > astypedlist ( collection < dimensionalitemobject > collection ) { list < t > list = new arraylist < > ( ) ; if ( collection != null ) { for ( dimensionalitemobject object : collection ) { list . add ( ( t ) object ) ; } } return list ; }	returns a list typed with the desired erasure based on the given collection.
public putindextemplaterequest aliases ( xcontentbuilder source ) { return aliases ( source . bytes ( ) ) ; }	sets the aliases that will be associated with the index when it gets created.
void addnewtable ( string name , int tdefpagenumber , short type , string linkeddbname , string linkedtablename ) throws ioexception { addtable ( name , integer . valueof ( tdefpagenumber ) , type , linkeddbname , linkedtablename ) ; addtosystemcatalog ( name , tdefpagenumber , type , linkeddbname , linkedtablename , _tableparentid ) ; addtoaccesscontrolentries ( tdefpagenumber , _tableparentid , _newtablesids ) ; }	adds a newly created table to the relevant internal database structures .
public void removelistener ( @ notnull configurationlistener listener ) { if ( mylisteners != null ) { mylisteners . remove ( listener ) ; if ( mylisteners . isempty ( ) ) { mylisteners = null ; } } }	removes a listener such that it is no longer notified of changes.
void reclaimscrapviews ( list < view > views ) { if ( mviewtypecount == _num ) { views . addall ( mcurrentscrap ) ; } else { final int viewtypecount = mviewtypecount ; final arraylist < view > [ ] scrapviews = mscrapviews ; for ( int i = _num ; i < viewtypecount ; ++ i ) { final arraylist < view > scrappile = scrapviews [ i ] ; views . addall ( scrappile ) ; } } }	puts all views in the scrap heap into the supplied list .
public void dowindowopen ( ) { doconnect ( ) ; }	this method is fired after the tab has been created and placed in the tab controller .
public boolean schedule ( runnable task , classloader loader ) { boolean ispriority = _bool ; boolean isqueue = _bool ; boolean iswake = _bool ; return scheduleimpl ( task , loader , max_expire , ispriority , isqueue , iswake ) ; }	schedules a new task .
public static int hash2 ( int hash , object x , object y ) { return _num | ( hash + _num * system . identityhashcode ( x ) + _num * system . identityhashcode ( y ) ) ; }	utility method to combine a base hash with the identity hash of one or more objects .
public static double [ ] parsevectorstring ( string vectorstring ) { string [ ] parsedstring = vectorstring . split ( _str ) ; double [ ] vector = new double [ parsedstring . length ] ; for ( int j = _num ; j < parsedstring . length ; j ++ ) { double val = utils . doubleparsable ( parsedstring [ j ] ) ; vector [ j ] = double . isnan ( val ) ? _num : val ; } return vector ; }	converts a string representation of a vector ( e.
public string globalinfo ( ) { return _str + _str + _str + _str + _str + _str ; }	returns a string describing this filter.
public static < t > stream < t > concat ( stream < ? extends t > a , stream < ? extends t > b ) { objects . requirenonnull ( a ) ; objects . requirenonnull ( b ) ; @ suppresswarnings ( _str ) spliterator < t > split = new streams . concatspliterator . ofref < > ( ( spliterator < t > ) a . spliterator ( ) , ( spliterator < t > ) b . spliterator ( ) ) ; stream < t > stream = streamsupport . stream ( split , a . isparallel ( ) || b . isparallel ( ) ) ; return stream . onclose ( streams . composedclose ( a , b ) ) ; }	creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream.
public void findandinit ( iterator it ) { while ( it . hasnext ( ) ) { findandinit ( it . next ( ) ) ; } }	the method called by beancontextmembershiplistener methods to find components in the maphandler .
public static datasourcepropertiesinterface decodexml ( document document , string elementname ) { if ( ( document == null ) || ( elementname == null ) ) { return null ; } map < string , string > map = new linkedhashmap < string , string > ( ) ; nodelist nodelist = document . getelementsbytagname ( elementname ) ; if ( nodelist . getlength ( ) > _num ) { node node = nodelist . item ( _num ) ; node child = node . getfirstchild ( ) ; while ( child != null ) { if ( child . getnodetype ( ) == node . element_node ) { map . put ( child . getnodename ( ) , child . gettextcontent ( ) ) ; } child = child . getnextsibling ( ) ; } return datasourceconnectorfactory . getdatasourceproperties ( map ) ; } else { return datasourceconnectorfactory . getnodatasource ( ) ; } }	decode the data source properties from xml .
@ override public char next ( ) { ++ docpos ; if ( docpos < segmentend || segmentend >= doc . getlength ( ) ) { return text . next ( ) ; } try { doc . gettext ( segmentend , doc . getlength ( ) - segmentend , text ) ; } catch ( badlocationexception e ) { throw new runtimeexception ( e ) ; } segmentend += text . count ; return text . current ( ) ; }	increments the iterator ' s index by one and returns the character at the new index .
private void adjustrowheights ( jtable table ) { for ( int row = _num ; row < table . getrowcount ( ) ; row ++ ) { int rowheight = table . getrowheight ( ) ; for ( int column = _num ; column < table . getcolumncount ( ) ; column ++ ) { component comp = table . preparerenderer ( table . getcellrenderer ( row , column ) , row , column ) ; rowheight = math . max ( rowheight , comp . getpreferredsize ( ) . height ) ; } table . setrowheight ( row , rowheight ) ; } }	adjust the row heights of a table based on the table contents .
public list < uri > volumeuris ( list < uri > uris , boolean delete , boolean remediate , valck ... checks ) { list < uri > remediateduris = new arraylist < uri > ( ) ; list < volume > volumes = dbclient . queryobject ( volume . class , uris ) ; list < volume > remediatedvolumes = volumes ( volumes , delete , remediate , checks ) ; for ( volume volume : remediatedvolumes ) { remediateduris . add ( volume . getid ( ) ) ; } return remediateduris ; }	validates a list of volumes.
private formatstring [ ] parse ( string s ) { arraylist < formatstring > al = new arraylist < > ( ) ; matcher m = fspattern . matcher ( s ) ; for ( int i = _num , len = s . length ( ) ; i < len ; ) { if ( m . find ( i ) ) { if ( m . start ( ) != i ) { checktext ( s , i , m . start ( ) ) ; al . add ( new fixedstring ( s . substring ( i , m . start ( ) ) ) ) ; } al . add ( new formatspecifier ( m ) ) ; i = m . end ( ) ; } else { checktext ( s , i , len ) ; al . add ( new fixedstring ( s . substring ( i ) ) ) ; break ; } } return al . toarray ( new formatstring [ al . size ( ) ] ) ; }	finds format specifiers in the format string .
private void updateindexcolumnbuttons ( ) { indexremovebutton . setenabled ( _bool ) ; indexupbutton . setenabled ( _bool ) ; indexdownbutton . setenabled ( _bool ) ; int index = selectedcolumns . getselectionindex ( ) ; if ( index >= _num ) { indexremovebutton . setenabled ( _bool ) ; if ( index > _num ) { indexupbutton . setenabled ( _bool ) ; } else if ( index < selectedcolumns . getitemcount ( ) - _num ) { indexdownbutton . setenabled ( _bool ) ; } } }	updates status of index column up / down buttons .
public string urlforpoisearch ( string tag , boundingbox bb , int limit , int timeout ) { stringbuilder s = new stringbuilder ( ) ; s . append ( mservice + _str ) ; string sbb = _str + bb . getlatsouth ( ) + _str + bb . getlonwest ( ) + _str + bb . getlatnorth ( ) + _str + bb . getloneast ( ) + _str ; string data = _str + timeout + _str + _str + tag + _str + sbb + _str + _str + tag + _str + sbb + _str + _str + tag + _str + sbb + _str + _str + limit + _str ; log . d ( bonuspackhelper . log_tag , _str + data ) ; s . append ( urlencoder . encode ( data ) ) ; return s . tostring ( ) ; }	build the url to search for elements having a specific osm tag ( key = value ) , within a bounding box.
public void waitfordecodingtofinish ( ) { while ( isdecoding ) { try { thread . sleep ( _num ) ; } catch ( final interruptedexception e ) { logwriter . writelog ( _str + e . getmessage ( ) ) ; isdecoding = _bool ; } } }	wait for decoding to finish.
private static string wikitoplaintext ( string content ) { content = content . replaceall ( _str , _str ) ; content = content . replaceall ( _str , _str ) ; content = content . replaceall ( _str , _str ) ; content = content . replaceall ( _str , _str ) ; content = content . replaceall ( _str , _str ) ; content = content . replaceall ( _str , _str ) ; content = content . replaceall ( _str , _str ) ; content = content . replaceall ( _str , _str ) ; content = content . replaceall ( _str , _str ) ; content = content . replaceall ( _str , _str ) ; content = content . trim ( ) ; final int size = content . length ( ) ; int endoffirstparagraph = content . indexof ( _str , _num ) ; if ( endoffirstparagraph < _num ) { endoffirstparagraph = size ; } content = content . substring ( _num , math . min ( endoffirstparagraph , _num ) ) ; return content ; }	extract plain text from wikipedia article content .
public final byte [ ] update ( byte [ ] input ) { if ( mode != encrypt_mode && mode != decrypt_mode ) { throw new illegalstateexception ( ) ; } if ( input == null ) { throw new illegalargumentexception ( _str ) ; } if ( input . length == _num ) { return null ; } return spiimpl . engineupdate ( input , _num , input . length ) ; }	continues a multi - part transformation ( encryption or decryption ).
private static int createpackedparams ( sungraphics2d sg2d , glyphlist gl ) { return ( ( ( gl . usepositions ( ) ? _num : _num ) << offset_positions ) | ( ( gl . issubpixpos ( ) ? _num : _num ) << offset_subpixpos ) | ( ( gl . isrgborder ( ) ? _num : _num ) << offset_rgborder ) | ( ( sg2d . lcdtextcontrast & _num ) << offset_contrast ) ) ; }	packs the given parameters into a single int value in order to save space on the rendering queue.
public static int update ( string sql , object [ ] args ) { connection c = null ; preparedstatement p = null ; try { c = getconnection ( ) ; if ( c == null ) return - _num ; p = c . preparestatement ( sql ) ; int order = _num ; if ( args != null ) { for ( int i = _num ; i < args . length ; i ++ ) { object o = args [ i ] ; setparameter ( p , order ++ , o ) ; } } return p . executeupdate ( ) ; } catch ( exception e ) { if ( log . iserrorenabled ( ) ) log . error ( sql + tostring ( args ) , e ) ; } finally { close ( p , c ) ; } return _num ; }	update the data using the sql sentence .
public boolean islocksubject ( ) { return _bool ; }	if entryholder is used as lockobject ( for example in all_in_cache ) - its the lock subject itself.
@ override public int hashcode ( ) { int code = _num ; if ( fpublicid != null ) { code += fpublicid . hashcode ( ) ; } if ( fliteralsystemid != null ) { code += fliteralsystemid . hashcode ( ) ; } if ( fbasesystemid != null ) { code += fbasesystemid . hashcode ( ) ; } if ( fexpandedsystemid != null ) { code += fexpandedsystemid . hashcode ( ) ; } if ( fnamespace != null ) { code += fnamespace . hashcode ( ) ; } return code ; }	returns a hash code for this object .
public quickactionview addaction ( action action ) { checkshown ( ) ; mactions . add ( action ) ; return this ; }	adds an action to the quickactionview.
protected boolean display ( file helpfile ) throws helpexception { if ( helpfile . exists ( ) ) { loadandwrite ( helpfile ) ; return _bool ; } else { file notfound = new file ( helpdir , not_found ) ; if ( notfound . exists ( ) ) loadandwrite ( notfound ) ; else throw new helpexception ( _str ) ; return _bool ; } }	displays the requested help file if it is found.
public static void storelocation ( context context , latlng location ) { sharedpreferences prefs = preferencemanager . getdefaultsharedpreferences ( context ) ; sharedpreferences . editor editor = prefs . edit ( ) ; editor . putlong ( preferences_lat , double . doubletorawlongbits ( location . latitude ) ) ; editor . putlong ( preferences_lng , double . doubletorawlongbits ( location . longitude ) ) ; editor . apply ( ) ; }	store the location in the app preferences .
public point2d either ( ) { return best1 ; }	returns one of the points in the closest pair of points .
@ override public boolean equals ( object object ) { if ( this == object ) { return _bool ; } if ( object instanceof list ) { list < ? > list = ( list < ? > ) object ; if ( list . size ( ) != size ( ) ) { return _bool ; } iterator < ? > it1 = iterator ( ) , it2 = list . iterator ( ) ; while ( it1 . hasnext ( ) ) { object e1 = it1 . next ( ) , e2 = it2 . next ( ) ; if ( ! ( e1 == null ? e2 == null : e1 . equals ( e2 ) ) ) { return _bool ; } } return _bool ; } return _bool ; }	compares the specified object to this list and return true if they are equal.
public static string rowtostring ( jsonarray ja ) { stringbuffer sb = new stringbuffer ( ) ; for ( int i = _num ; i < ja . length ( ) ; i += _num ) { if ( i > _num ) { sb . append ( _str ) ; } object object = ja . opt ( i ) ; if ( object != null ) { string string = object . tostring ( ) ; if ( string . length ( ) > _num && ( string . indexof ( _str ) >= _num || string . indexof ( _str ) >= _num || string . indexof ( _str ) >= _num || string . indexof ( _num ) >= _num || string . charat ( _num ) == _str ) ) { sb . append ( _str ) ; int length = string . length ( ) ; for ( int j = _num ; j < length ; j += _num ) { char c = string . charat ( j ) ; if ( c >= _str && c != _str ) { sb . append ( c ) ; } } sb . append ( _str ) ; } else { sb . append ( string ) ; } } } sb . append ( _str ) ; return sb . tostring ( ) ; }	produce a comma delimited text row from a jsonarray.
private static void removetable ( connection conn , string name ) throws sqlexception { name = name . replace ( _str , _str ) ; statement stat = conn . createstatement ( ) ; stat . execute ( _str + name ) ; dbutil . commitel ( conn ) ; }	remove a table from the memory database.
public boolean containscategory ( string category ) { return ! hiddenbugcategoryset . contains ( category ) ; }	returns false if the given category is hidden in the project filter settings .
public static boolean isvolumefullcopysource ( volume volume , dbclient dbclient ) { boolean isfullcopysource = _bool ; stringset fullcopyids = volume . getfullcopies ( ) ; if ( ( fullcopyids != null ) && ( ! fullcopyids . isempty ( ) ) ) { iterator < string > fullcopyidsiter = fullcopyids . iterator ( ) ; while ( fullcopyidsiter . hasnext ( ) ) { uri fullcopyuri = uri . create ( fullcopyidsiter . next ( ) ) ; volume fullcopyvolume = dbclient . queryobject ( volume . class , fullcopyuri ) ; if ( ( fullcopyvolume != null ) && ( ! fullcopyvolume . getinactive ( ) ) ) { isfullcopysource = _bool ; } } } return isfullcopysource ; }	determine if the passed volume is a source volume for any full copies .
@ override public void assertequals ( string message , object expectedobj , object actualobj ) { linearregressionmodel expected = ( linearregressionmodel ) expectedobj ; linearregressionmodel actual = ( linearregressionmodel ) actualobj ; message = message + _str + actual . getsource ( ) + _str ; assert . assertarrayequals ( message + _str , expected . getcoefficients ( ) , actual . getcoefficients ( ) , _num ) ; assert . assertarrayequals ( message + _str , expected . getprobabilities ( ) , actual . getprobabilities ( ) , _num ) ; assert . assertarrayequals ( message + _str , expected . getselectedattributenames ( ) , actual . getselectedattributenames ( ) ) ; assert . assertarrayequals ( message + _str , expected . getselectedattributes ( ) , actual . getselectedattributes ( ) ) ; assert . assertarrayequals ( message + _str , expected . getstandarderrors ( ) , actual . getstandarderrors ( ) , _num ) ; assert . assertarrayequals ( message + _str , expected . getstandardizedcoefficients ( ) , actual . getstandardizedcoefficients ( ) , _num ) ; assert . assertarrayequals ( message + _str , expected . gettolerances ( ) , actual . gettolerances ( ) , _num ) ; assert . assertarrayequals ( message + _str , expected . gettstats ( ) , actual . gettstats ( ) , _num ) ; }	tests two linearregression models by comparing all values.
public static map < string , object > entitymaintpermcheck ( dispatchcontext dctx , map < string , ? extends object > context ) { genericvalue userlogin = ( genericvalue ) context . get ( _str ) ; locale locale = ( locale ) context . get ( _str ) ; security security = dctx . getsecurity ( ) ; map < string , object > resultmap = null ; if ( security . haspermission ( _str , userlogin ) ) { resultmap = serviceutil . returnsuccess ( ) ; resultmap . put ( _str , _bool ) ; } else { resultmap = serviceutil . returnfailure ( utilproperties . getmessage ( resource , _str , locale ) ) ; resultmap . put ( _str , _bool ) ; } return resultmap ; }	performs an entity maintenance security check.
public void testquorumsucceed ( ) { quorum . succeed ( ) ; quorum . fail ( ) ; assertequals ( callbackresult . get ( ) , _num ) ; quorum . fail ( ) ; quorum . succeed ( ) ; assertequals ( callbackresult . get ( ) , _num ) ; }	tests a successful quorum .
public void requestafterexplanation ( @ nonnull string [ ] permissions ) { arraylist < string > permissionstorequest = new arraylist < > ( ) ; for ( string permissionname : permissions ) { if ( ispermissiondeclined ( permissionname ) ) { permissionstorequest . add ( permissionname ) ; } else { permissioncallback . onpermissionpregranted ( permissionname ) ; } } if ( permissionstorequest . isempty ( ) ) return ; permissions = permissionstorequest . toarray ( new string [ permissionstorequest . size ( ) ] ) ; context . requestpermissions ( permissions , request_permissions ) ; }	to be called when explanation is presented to the user.
static void pausethread ( long duration ) { try { thread . sleep ( duration ) ; } catch ( exception e ) { s_logger . warn ( _str , e ) ; } }	simple puts the thread to sleep for the passed duration .
final public void println ( string v ) { try { _out . println ( v ) ; } catch ( ioexception e ) { log . log ( level . fine , e . tostring ( ) , e ) ; } }	writes a string followed by a newline .
public int read ( char cbuf [ ] , int offset , int length ) throws ioexception { return sd . read ( cbuf , offset , length ) ; }	reads characters into a portion of an array .
public int read ( ) throws ioexception { int val ; if ( ( val = is . read ( ) ) < _num ) { return - _num ; } switch ( val & _num ) { case _num : case _num : val = ( ( val & _num ) << _num ) | ( is . read ( ) & _num ) ; break ; case _num : val = ( ( val & _num ) << _num ) | ( ( is . read ( ) & _num ) << _num ) | ( is . read ( ) & _num ) ; break ; case _num : throw new unsupportedencodingexception ( ) ; default : break ; } return val ; }	reads a single character .
private static boolean callnonvirtualbooleanmethodv ( jnienvironment env , int objjref , int classjref , int methodid , address argaddress ) throws exception { if ( tracejni ) vm . syswrite ( _str ) ; runtimeentrypoints . checkjnicountdowntogc ( ) ; try { object obj = env . getjniref ( objjref ) ; object returnobj = jnihelpers . invokewithvararg ( obj , methodid , argaddress , typereference . boolean , _bool ) ; return reflection . unwrapboolean ( returnobj ) ; } catch ( throwable unexpected ) { if ( tracejni ) unexpected . printstacktrace ( system . err ) ; env . recordexception ( unexpected ) ; return _bool ; } }	callnonvirtualbooleanmethodv : invoke a virtual method that returns a boolean value.
private boolean rcontainsrminstruction ( programblock pb , string varname ) { if ( pb instanceof whileprogramblock ) { whileprogramblock tmp = ( whileprogramblock ) pb ; for ( programblock c : tmp . getchildblocks ( ) ) if ( rcontainsrminstruction ( c , varname ) ) return _bool ; } else if ( pb instanceof ifprogramblock ) { ifprogramblock tmp = ( ifprogramblock ) pb ; for ( programblock c : tmp . getchildblocksifbody ( ) ) if ( rcontainsrminstruction ( c , varname ) ) return _bool ; for ( programblock c : tmp . getchildblockselsebody ( ) ) if ( rcontainsrminstruction ( c , varname ) ) return _bool ; } else if ( pb instanceof forprogramblock ) { forprogramblock tmp = ( forprogramblock ) pb ; for ( programblock c : tmp . getchildblocks ( ) ) if ( rcontainsrminstruction ( c , varname ) ) return _bool ; } else if ( pb instanceof functionprogramblock ) { } else { for ( instruction inst : pb . getinstructions ( ) ) { string inststr = inst . tostring ( ) ; if ( inststr . contains ( _str + lop . operand_delimitor + varname ) || inststr . contains ( _str + lop . operand_delimitor + varname ) ) { return _bool ; } } } return _bool ; }	determines if the given program block includes a rmvar or rmfilevar instruction for the given varname .
public projectimporter ( final file rootfolder ) { assertnotnull ( _str , rootfolder ) ; asserttrue ( _str + rootfolder , rootfolder . exists ( ) ) ; asserttrue ( _str + rootfolder , rootfolder . isdirectory ( ) ) ; asserttrue ( _str + rootfolder , rootfolder . canread ( ) ) ; asserttrue ( _str + rootfolder , null != rootfolder . listfiles ( ) ) ; this . rootfolder = rootfolder ; }	creates a project importer with the root folder of all projects that has to be imported for the test .
public void testdoubles ( ) throws exception { double [ ] values = new double [ ] { double . negative_infinity , - _num , - _num , - _num , - _num , - _num , - _num , + _num , _num , _num , _num , _num , _num , double . positive_infinity , double . nan } ; long [ ] encoded = new long [ values . length ] ; for ( int i = _num ; i < values . length ; i ++ ) { encoded [ i ] = numericutils . doubletosortablelong ( values [ i ] ) ; asserttrue ( _str , double . compare ( values [ i ] , numericutils . sortablelongtodouble ( encoded [ i ] ) ) == _num ) ; } for ( int i = _num ; i < encoded . length ; i ++ ) { asserttrue ( _str , encoded [ i - _num ] < encoded [ i ] ) ; } }	check various sorted values of doubles ( including extreme values ) check for correct ordering of the encoded bytes and that values round - trip .
public static boolean isregistered ( class < ? > clazz ) { return regmodules . containskey ( clazz . getname ( ) ) ; }	has this class already been registered .
public class < ? > loadclass ( string name ) throws classnotfoundexception { return class . forname ( name ) ; }	return the class with the given name .
public void waitforoperations ( ) { operator . waitforoperations ( ) ; }	wait for the bucket operator to complete any pending asynchronous operations .
protected boolean isalltestcomponentsintarget ( geometry testgeom ) { list coords = componentcoordinateextracter . getcoordinates ( testgeom ) ; for ( iterator i = coords . iterator ( ) ; i . hasnext ( ) ; ) { coordinate p = ( coordinate ) i . next ( ) ; int loc = targetpointlocator . locate ( p ) ; if ( loc == location . exterior ) return _bool ; } return _bool ; }	tests whether all components of the test geometry are contained in the target geometry.
private object createinner ( simpleobject post , requestcontext context ) throws responseexception { try { string xml = completexform ( convertuuidstoids ( post ) ) ; file file = file . createtempfile ( _str , null ) ; processor . processxform ( xml , file . getabsolutepath ( ) , _bool , context . getrequest ( ) ) ; } catch ( ioexception e ) { throw new genericrestexception ( _str , e ) ; } catch ( responseexception e ) { throw e ; } catch ( exception e ) { throw new conversionexception ( _str , e ) ; } encounter encounter = guessencounterfromxformsubmission ( post ) ; if ( encounter == null ) { return post ; } simpleobject returnjson = new simpleobject ( ) ; encounterresource . populatejsonproperties ( encounter , returnjson ) ; return returnjson ; }	accepts a submitted form instance .
public endpoint ( uri endpointurl , securitymode ... modes ) { if ( modes == null || endpointurl == null ) throw new illegalargumentexception ( _str ) ; for ( securitymode m : modes ) { if ( m == null ) throw new illegalargumentexception ( _str ) ; hash = _num * hash + m . hashcode ( ) ; } this . endpointurl = endpointurl . tostring ( ) ; this . modes = modes ; this . endpointconfiguration = endpointconfiguration . defaults ( ) ; hash = _num * hash + endpointurl . hashcode ( ) ; }	create a new endpoint .
protected value parsevalue ( ) throws ioexception , rdfparseexception , rdfhandlerexception { int c = peekcodepoint ( ) ; if ( c == _str ) { return parseuri ( ) ; } else if ( c == _str || turtleutil . isprefixstartchar ( c ) ) { return parseqnameorboolean ( ) ; } else if ( c == _str ) { return parsenodeid ( ) ; } else if ( c == _str || c == _str ) { return parsequotedliteral ( ) ; } else if ( asciiutil . isnumber ( c ) || c == _str || c == _str || c == _str ) { return parsenumber ( ) ; } else if ( c == - _num ) { throweofexception ( ) ; return null ; } else { reportfatalerror ( _str + new string ( character . tochars ( c ) ) + _str ) ; return null ; } }	parses an rdf value.
public timeseriescollection ( ) { this ( null , timezone . getdefault ( ) ) ; }	constructs an empty dataset , tied to the default timezone .
public static < e > list < e > of ( e e1 , e e2 , e e3 ) { list < e > list = new arraylist < > ( ) ; list . add ( e1 ) ; list . add ( e2 ) ; list . add ( e3 ) ; return list ; }	returns a list of the given elements , in order .
public int alloc ( int size ) { int index = n ; int len = array . length ; if ( n + size >= len ) { byte [ ] aux = new byte [ len + blocksize ] ; system . arraycopy ( array , _num , aux , _num , len ) ; array = aux ; } n += size ; return index ; }	this is to implement memory allocation in the array.
@ override public void addattribute ( string name , float value ) { string str = float . tostring ( value ) ; if ( str . endswith ( _str ) ) str = str . substring ( _num , str . length ( ) - _num ) ; current . setattribute ( name , str ) ; }	adds an attribute to current element of the dom document .
@ requestmapping ( value = _str , method = requestmethod . post ) @ responsebody public jsonresponse createdirectory ( @ pathvariable final string containerid , @ pathvariable final string applicationname , @ requestparam ( _str ) string path ) throws serviceexception , checkexception , ioexception { if ( logger . isdebugenabled ( ) ) { logger . debug ( _str + containerid ) ; logger . debug ( _str + applicationname ) ; logger . debug ( _str + path ) ; } fileservice . createdirectory ( applicationname , containerid , path ) ; return new httpok ( ) ; }	create resources ( files and folders ) into a container for a path.
public void fill_ellipse_arr ( plaellipse [ ] p_ellipse_arr , graphics p_g , color p_color , double p_translucency_factor ) { if ( p_color == null ) return ; if ( p_ellipse_arr . length <= _num ) return ; generalpath draw_path = new generalpath ( generalpath . wind_even_odd ) ; for ( plaellipse curr_ellipse : p_ellipse_arr ) { point2d center = coordinate_transform . board_to_screen ( curr_ellipse . center ) ; double bigger_radius = coordinate_transform . board_to_screen ( curr_ellipse . bigger_radius ) ; if ( ! point_near_rectangle ( center . getx ( ) , center . gety ( ) , ( rectangle ) p_g . getclip ( ) , bigger_radius ) ) { continue ; } double smaller_radius = coordinate_transform . board_to_screen ( curr_ellipse . smaller_radius ) ; ellipse2d draw_ellipse = new ellipse2d . double ( center . getx ( ) - bigger_radius , center . gety ( ) - smaller_radius , _num * bigger_radius , _num * smaller_radius ) ; double rotation = coordinate_transform . board_to_screen_angle ( curr_ellipse . rotation ) ; affinetransform affine_transform = new affinetransform ( ) ; affine_transform . rotate ( rotation , center . getx ( ) , center . gety ( ) ) ; shape rotated_ellipse = affine_transform . createtransformedshape ( draw_ellipse ) ; draw_path . append ( rotated_ellipse , _bool ) ; } graphics2d g2 = ( graphics2d ) p_g ; g2 . setcolor ( p_color ) ; set_translucency ( g2 , p_translucency_factor ) ; g2 . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; g2 . fill ( draw_path ) ; }	draws the interiour of an array of ellipses.
@ override public void zoomdomainaxes ( double factor , plotrenderinginfo state , point2d source ) { }	multiplies the range on the domain axis / axes by the specified factor .
private void refreshchallengecounts ( ) { mduechallengecounts = mduechallengelogic . getduechallengecounts ( mcategories ) ; }	reloads the due challenge counts from the database .
public identity ( final int dim ) { this ( dim , enumset . noneof ( address . flags . class ) ) ; }	creates an identity matrix.
private imagedata awttoswt ( final bufferedimage bufferedimage , final int width , final int height ) { final int [ ] awtpixels = new int [ width * height ] ; final imagedata swtimagedata = new imagedata ( width , height , _num , palette_data ) ; swtimagedata . transparentpixel = transparent_color ; final int step = swtimagedata . depth / _num ; final byte [ ] data = swtimagedata . data ; bufferedimage . getrgb ( _num , _num , width , height , awtpixels , _num , width ) ; for ( int i = _num ; i < height ; i ++ ) { int idx = ( _num + i ) * swtimagedata . bytesperline + _num * step ; for ( int j = _num ; j < width ; j ++ ) { final int rgb = awtpixels [ j + i * width ] ; for ( int k = swtimagedata . depth - _num ; k >= _num ; k -= _num ) { data [ idx ++ ] = ( byte ) ( rgb > > k & _num ) ; } } } return swtimagedata ; }	transform a java2d bufferedimage to a swt image .
public static boolean isunlimitedstrengthpolicyavailable ( ) { try { return cipher . getmaxallowedkeylength ( _str ) >= _num ; } catch ( final nosuchalgorithmexception e ) { e . printstacktrace ( ) ; } return _bool ; }	helper method to check whether the jvm has the unlimited strength policy installed.
public long rsslim ( ) { return long . parselong ( fields [ _num ] ) ; }	current soft limit in bytes on the rss of the process ; see the description of rlimit_rss in getrlimit ( 2 ) .
public void addtotals ( info_column [ ] layout ) { addtotals ( ( columninfo [ ] ) layout ) ; }	adding a new row with the totals.
private void fillstacktrace ( stringbuffer buffer , stacktraceelement [ ] elements ) { for ( int index = _num ; index < elements . length ; index ++ ) { buffer . append ( elements [ index ] ) ; buffer . append ( _str ) ; } }	creates a printing stacktrace from the given elements .
public static boolean isfiletypesupported ( int filetype ) { list providers = getmidifilewriters ( ) ; for ( int i = _num ; i < providers . size ( ) ; i ++ ) { midifilewriter writer = ( midifilewriter ) providers . get ( i ) ; if ( writer . isfiletypesupported ( filetype ) ) { return _bool ; } } return _bool ; }	indicates whether file writing support for the specified midi file type is provided by the system .
public void makeimmutable ( ) { if ( ismutable ) { ismutable = _bool ; } }	makes this object immutable .
public static double uniform ( ) { return random . nextdouble ( ) ; }	returns a random real number uniformly in [ 0 , 1 ) .
private amsetupdsconfig ( ) { map map = servicesdefaultvalues . getdefaultvalues ( ) ; dsmanager = ( string ) map . get ( setupconstants . config_var_ds_mgr_dn ) ; suffix = ( string ) map . get ( setupconstants . config_var_root_suffix ) ; dshostname = ( string ) map . get ( setupconstants . config_var_directory_server_host ) ; dsport = ( string ) map . get ( setupconstants . config_var_directory_server_port ) ; dsadminpwd = ( string ) map . get ( setupconstants . config_var_ds_mgr_pwd ) ; basedir = ( string ) map . get ( setupconstants . config_var_base_dir ) ; deployuri = ( string ) map . get ( setupconstants . config_var_server_uri ) ; }	constructs a new instance .
private boolean compareandincrementworkercount ( int expect ) { return ctl . compareandset ( expect , expect + _num ) ; }	attempts to cas - increment the workercount field of ctl .
private void makeitems ( int fingerposition , list < view > viewlist ) { if ( fingerposition >= viewlist . size ( ) ) { return ; } for ( int i = _num ; i < viewlist . size ( ) ; i ++ ) { int translationy = math . min ( math . max ( math . abs ( fingerposition - i ) * intervalheight , _num ) , maxtranslationheight ) ; updateitemheightanimator ( viewlist . get ( i ) , translationy ) ; } }	calculates every icon ' s height needed and start animation.
private boolean pathiswindows ( string path ) { if ( path != null && path . length ( ) > _num ) { return ( character . isletter ( path . charat ( _num ) ) && path . charat ( _num ) == _str ) || ( path . startswith ( _str ) || path . startswith ( _str ) ) ; } return _bool ; }	returns true if the path is on windows .
object processchar ( stylesheethandler handler , string uri , string name , string rawname , string value , elemtemplateelement owner ) throws org . xml . sax . saxexception { if ( getsupportsavt ( ) ) { try { avt avt = new avt ( handler , uri , name , rawname , value , owner ) ; if ( ( avt . issimple ( ) ) && ( value . length ( ) != _num ) ) { handleerror ( handler , xslterrorresources . invalid_tchar , new object [ ] { name , value } , null ) ; return null ; } return avt ; } catch ( transformerexception te ) { throw new org . xml . sax . saxexception ( te ) ; } } else { if ( value . length ( ) != _num ) { handleerror ( handler , xslterrorresources . invalid_tchar , new object [ ] { name , value } , null ) ; return null ; } return new character ( value . charat ( _num ) ) ; } }	process an attribute string of type t_char into a character value .
public static element addchildelementvalue ( element element , string childelementname , string childelementvalue , document document ) { element newelement = addchildelement ( element , childelementname , document ) ; newelement . appendchild ( document . createtextnode ( childelementvalue ) ) ; return newelement ; }	creates a child element with the given name and appends it to the element child node list.
public boolean issegmentbalanced ( ) { if ( m_lines . size ( ) == _num || m_doc . ismulticurrency ( ) ) return _bool ; macctschemaelement [ ] elements = m_acctschema . getacctschemaelements ( ) ; for ( int i = _num ; i < elements . length ; i ++ ) { macctschemaelement ase = elements [ i ] ; if ( ase . isbalanced ( ) && ! issegmentbalanced ( ase . getelementtype ( ) ) ) return _bool ; } return _bool ; }	are all segments balanced.
attributes parseattributes ( ) throws jasperexception { attributesimpl attrs = new attributesimpl ( ) ; reader . skipspaces ( ) ; while ( parseattribute ( attrs ) ) reader . skipspaces ( ) ; return attrs ; }	attributes : : = ( s attribute ) * s ?.
public static byte [ ] readbinaryfile ( file sourcefile ) { byte [ ] result = null ; try { bufferedinputstream input ; input = new bufferedinputstream ( new fileinputstream ( sourcefile ) ) ; int num = input . available ( ) ; result = new byte [ num ] ; input . read ( result , _num , num ) ; input . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; result = null ; } return result ; }	reads a binary input file into a byte array.
@ suppresswarnings ( _str ) public void test_streamapi ( ) { final list < ibindingset > expectedsolutions = new arraylist < ibindingset > ( ) ; { final ibindingset expected = new listbindingset ( ) ; expected . set ( var . var ( _str ) , new constant < iv > ( termid ) ) ; expectedsolutions . add ( expected ) ; } { final ibindingset expected = new listbindingset ( ) ; expected . set ( var . var ( _str ) , new constant < iv > ( termid ) ) ; expected . set ( var . var ( _str ) , new constant < iv > ( blobiv ) ) ; expectedsolutions . add ( expected ) ; } doencodedecodetest ( expectedsolutions ) ; }	unit test of the stream - oriented api .
public void addterm ( splitcondition condition ) { terms . add ( condition ) ; }	this method adds a condition to the conjunction in the rule ' s head.
@ override protected void thresholdreached ( ) throws ioexception { if ( prefix != null ) { outputfile = file . createtempfile ( prefix , suffix , directory ) ; } fileoutputstream fos = new fileoutputstream ( outputfile ) ; memoryoutputstream . writeto ( fos ) ; currentoutputstream = fos ; memoryoutputstream = null ; }	switches the underlying output stream from a memory based stream to one that is backed by disk.
public void removeindexinterval ( int index0 , int index1 ) { int rmminindex = math . min ( index0 , index1 ) ; int rmmaxindex = math . max ( index0 , index1 ) ; int gaplength = ( rmmaxindex - rmminindex ) + _num ; for ( int i = rmminindex ; i <= maxindex ; i ++ ) { setstate ( i , value . get ( i + gaplength ) ) ; } int leadindex = this . leadindex ; if ( leadindex == _num && rmminindex == _num ) { } else if ( leadindex > rmmaxindex ) { leadindex = this . leadindex - gaplength ; } else if ( leadindex >= rmminindex ) { leadindex = rmminindex - _num ; } int anchorindex = this . anchorindex ; if ( anchorindex == _num && rmminindex == _num ) { } else if ( anchorindex > rmmaxindex ) { anchorindex = this . anchorindex - gaplength ; } else if ( anchorindex >= rmminindex ) { anchorindex = rmminindex - _num ; } if ( leadindex != this . leadindex || anchorindex != this . anchorindex ) { updateleadanchorindices ( anchorindex , leadindex ) ; } firevaluechanged ( ) ; }	remove the indices in the interval index0 , index1 ( inclusive ) from the selection model.
public void rebuildeventlist ( boolean resetselected ) { if ( logger . isloggable ( level . fine ) ) { logger . fine ( _str ) ; } allevents = null ; activeevents = null ; hidedetails ( ) ; initinterface ( getactiveevents ( ) , resetselected ) ; highlightcurrentevent ( currenttime ) ; firepropertychange ( activeeventsproperty , null , getactiveevents ( ) ) ; }	this is the method that rebuilds the list of visible events .
public diskstorefactory creatediskstorefactory ( ) { return new diskstorefactoryimpl ( this ) ; }	create diskstore factory with default attributes.
public static boolean deletedirectorysubdirectories ( string rootdirectory ) { if ( ( rootdirectory == null ) ) { return _bool ; } boolean didsuccessfullydeletealldirectories = _bool ; try { list < file > files = getlistoffilesinadirectory ( rootdirectory ) ; for ( file file : files ) { if ( file . isdirectory ( ) ) { boolean deletesuccess = deletedirectoryandcontents ( file ) ; if ( ! deletesuccess ) { logger . debug ( _str + file . getabsolutepath ( ) ) ; didsuccessfullydeletealldirectories = _bool ; } } } } catch ( exception e ) { logger . debug ( e . tostring ( ) + system . lineseparator ( ) + stacktrace . getstringfromstacktrace ( e ) ) ; return _bool ; } return didsuccessfullydeletealldirectories ; }	this is a quiet method.
public void put ( byte [ ] buffer , int offset , int count ) { if ( count > ( bytes . length - this . contentlength ) ) { throw new illegalargumentexception ( _str ) ; } system . arraycopy ( buffer , offset , bytes , this . contentlength , count ) ; this . contentlength += count ; }	puts content from the specified byte array to this bytearray.
private void markreserved ( int ropreg , int category ) { reservedropregs . set ( ropreg , ropreg + category , _bool ) ; }	marks a range of rop registers as " reserved for a local variable . ".
public static void registerdefaultresolvers ( ) { synchronized ( resolverlist ) { resolverlist . add ( new resourceresolver ( new resolverfragment ( ) ) ) ; resolverlist . add ( new resourceresolver ( new resolverlocalfilesystem ( ) ) ) ; resolverlist . add ( new resourceresolver ( new resolverxpointer ( ) ) ) ; resolverlist . add ( new resourceresolver ( new resolverdirecthttp ( ) ) ) ; } }	this method registers the default resolvers .
private boolean processauthenticationresponse ( final httpmethod method ) { log . trace ( _str + _str ) ; try { switch ( method . getstatuscode ( ) ) { case httpstatus . sc_unauthorized : return processwwwauthchallenge ( method ) ; case httpstatus . sc_proxy_authentication_required : return processproxyauthchallenge ( method ) ; default : return _bool ; } } catch ( exception e ) { if ( log . iserrorenabled ( ) ) { log . error ( e . getmessage ( ) , e ) ; } return _bool ; } }	processes a response that requires authentication.
private void release ( bytearray bytearray ) { synchronized ( syncroot ) { if ( availablebytearrays . size ( ) >= maxavailablearrayscount ) { return ; } if ( ! availablebytearrays . contains ( bytearray ) ) { availablebytearrays . add ( bytearray ) ; } } }	releases specified byte array.
public pipeline ( ) { }	constructs an empty pipeline.
private void init ( ) { acceptablemethods = new arraylist < > ( ) ; acceptablemethods . add ( new noauthenticationrequiredmethod ( ) ) ; acceptablemethods . add ( new gssapimethod ( ) ) ; acceptablemethods . add ( new usernamepasswordmethod ( ) ) ; }	constructs a socks5 instance without any parameter .
private boolean lockorder ( order order ) { lock . lock ( ) ; try { return activeorders . add ( order . getid ( ) ) ; } finally { lock . unlock ( ) ; } }	attempts the lock the order.
public void put ( buffer buffer ) { if ( buffer . getlength ( ) <= _num ) { return ; } byte [ ] currentrtppacketdata = ( ( byte [ ] ) buffer . getdata ( ) ) ; h264rtpheaders h264rtpheaders = new h264rtpheaders ( currentrtppacketdata ) ; if ( h264rtpheaders . getfui_f ( ) ) { return ; } if ( reassembleddata == null ) { timestamp = buffer . gettimestamp ( ) ; format = buffer . getformat ( ) ; seqnumber = buffer . getsequencenumber ( ) ; reassembleddatanalheader = h264rtpheaders . getnalheader ( ) ; reassembleddata = new byte [ javapacketizer . h264_max_rtp_pkts ] [ h264_frame_packet_size ] ; reassembleddatasize = new int [ javapacketizer . h264_max_rtp_pkts ] ; reassembleddatahasstart = _bool ; reassembleddatahasend = _bool ; } int posseq = ( int ) ( buffer . getsequencenumber ( ) & video_decoder_max_payloads_chunks_mask ) ; int payloadstartposition = h264rtpheaders . getheadersize ( ) ; int payloadlength = buffer . getlength ( ) - h264rtpheaders . getheadersize ( ) ; if ( h264rtpheaders . getfui_type ( ) == h264rtpheaders . avc_naltype_fua ) { reassembleddatahasstart |= ( h264rtpheaders . getfuh_s ( ) ) ; reassembleddatahasend |= ( h264rtpheaders . getfuh_e ( ) ) ; reassembleddataposseqstart = ( ( h264rtpheaders . getfuh_s ( ) ) ? posseq : reassembleddataposseqstart ) ; reassembleddataposseqend = ( ( h264rtpheaders . getfuh_e ( ) ) ? posseq : reassembleddataposseqend ) ; } reassembleddatasize [ posseq ] = payloadlength ; reassembleddatafullsize += payloadlength ; system . arraycopy ( currentrtppacketdata , payloadstartposition , reassembleddata [ posseq ] , _num , payloadlength ) ; videoorientation = buffer . getvideoorientation ( ) ; }	add the buffer ( which contains a fragment ) to the assembler .
public static final void writestringarrayxml ( string [ ] val , string name , xmlserializer out ) throws xmlpullparserexception , java . io . ioexception { if ( val == null ) { out . starttag ( null , _str ) ; out . endtag ( null , _str ) ; return ; } out . starttag ( null , _str ) ; if ( name != null ) { out . attribute ( null , _str , name ) ; } final int n = val . length ; out . attribute ( null , _str , integer . tostring ( n ) ) ; for ( int i = _num ; i < n ; i ++ ) { out . starttag ( null , _str ) ; out . attribute ( null , _str , val [ i ] ) ; out . endtag ( null , _str ) ; } out . endtag ( null , _str ) ; }	flatten a string [ ] into an xmlserializer.
private void unifyusernamebyname ( map < string , list < logcommitinfo > > devnamemap ) { for ( entry < string , list < logcommitinfo > > entry : devnamemap . entryset ( ) ) { list < string > usernames = getusernameslist ( entry . getvalue ( ) ) ; if ( usernames . size ( ) > _num ) { string newusername = getnewusername ( usernames ) ; for ( logcommitinfo commit : entry . getvalue ( ) ) { commit . setusername ( newusername ) ; } } } }	treat similar name aliases.
@ suppresswarnings ( _str ) public jdbcdata ( connection connection , string table , boolean buffered ) { this . connection = connection ; this . table = table ; setbuffered ( buffered ) ; try { setcolumntypes ( getjdbccolumntypes ( ) ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } }	initializes a new instance to query the data from a specified table using a specified jdbc connection.
public void storestackforexception ( throwable t , int currentstackframe ) { if ( ! exceptionstack . containskey ( t ) ) { int [ ] s = new int [ stackpointer + _num ] ; system . arraycopy ( stack , _num , s , _num , stackpointer ) ; s [ stackpointer ] = currentstackframe ; exceptionstack . put ( t , s ) ; } }	stores the stack for the given exception.
public secureelfformatter ( ) { string timestampgeneratorclass = lmanager . getproperty ( logconstants . secure_timestamp_generator ) ; try { class clz = class . forname ( timestampgeneratorclass ) ; securetimestampgenerator = ( itimestampgenerator ) clz . newinstance ( ) ; } catch ( classnotfoundexception cnfe ) { debug . error ( _str + _str , cnfe ) ; } catch ( instantiationexception ie ) { debug . error ( _str + _str , ie ) ; } catch ( illegalaccessexception iae ) { debug . error ( _str + _str , iae ) ; } }	returns a elf formatter.
public static byte [ ] readdata ( final url url ) throws ioexception { try ( inputstream input = url . openstream ( ) ) { return readdata ( input ) ; } }	reads all the data from the supplied url into a byte array .
public boolean isvalidcurrent ( long checktime ) { if ( checktime == _num || ( rdatelist == null && rruleslist == null ) ) { return _bool ; } boolean found = _bool ; iterator < recurrencerule > rulesiterator = getrecurrenceruleiterator ( ) ; while ( rulesiterator . hasnext ( ) ) { recurrencerule rule = rulesiterator . next ( ) ; long currenttime = rule . validcurrent ( getstarttime ( ) , checktime , getcurrentcount ( ) ) ; currenttime = checkdatelist ( rdatelist , currenttime , checktime ) ; if ( ( currenttime > _num ) && isvalid ( checktime ) ) { found = _bool ; } else { return _bool ; } } return found ; }	checks the current recurrence validity for checktime .
public static energynetwork initnetwork ( ) { random random = new random ( system . currenttimemillis ( ) ) ; int id = random . nextint ( ) ; while ( usedids . contains ( id ) ) { id = random . nextint ( ) ; } ; energynetwork net = new energynetwork ( ) ; usedids . add ( id ) ; net . networkid = id ; return net ; }	create a new network and get an id.
public static string tokilobytes ( long bytes ) { if ( bytes < _num ) return _str + general_unit_kilobytes ; long kbytes = bytes / _num ; if ( ( bytes & _num ) != _num || ( bytes > _num && bytes < _num ) ) kbytes ++ ; return number_format0 . format ( kbytes ) + general_unit_kilobytes ; }	this static method converts the passed in number of bytes into a kilobyte string grouping digits with locale - dependant thousand separator and with " kb " locale - dependant unit at the end .
private pendingintent createrequestpendingintent ( @ nonnull string pendingintentclassname ) { pendingintent pendingintent = null ; try { class classofpendingintent = class . forname ( pendingintentclassname ) ; if ( classofpendingintent != null ) { intent intent = new intent ( mcontext , classofpendingintent ) ; pendingintent = pendingintent . getservice ( mcontext , _num , intent , pendingintent . flag_update_current ) ; } } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } return pendingintent ; }	create a pending intent from the storable fence.
public boolean isstatic ( ) { return modifier . isstatic ( _method . getmodifiers ( ) ) ; }	returns true for a static method .
void teststring ( ) { string a = randomstring ( ) ; if ( returnnew ) { string b = stringutils . fromcacheornew ( a ) ; try { assertequals ( a , b ) ; } catch ( exception e ) { testbase . logerror ( _str , e ) ; } if ( a != null && a == b && a . length ( ) > _num ) { throw new assertionerror ( _str + system . identityhashcode ( a ) + _str + system . identityhashcode ( b ) ) ; } } else { string b ; if ( useintern ) { b = a == null ? null : a . intern ( ) ; } else { b = stringutils . cache ( a ) ; } try { assertequals ( a , b ) ; } catch ( exception e ) { testbase . logerror ( _str , e ) ; } } }	test one string operation using the string cache .
public static string unifylineseparators ( string s ) { return unifylineseparators ( s , system . getproperty ( _str ) ) ; }	parses the given string and replaces all occurrences of ' \ n ' , ' \ r ' and ' \ r \ n ' with the system line separator .
public static byte [ ] decryptkey ( byte [ ] password , byte [ ] encryptedkey ) { try { cipher c = cipher . getinstance ( encrypt_key_algorithm ) ; c . init ( cipher . decrypt_mode , new secretkeyspec ( password , secret_key_algorithm ) , cbc_salt_key ) ; return c . dofinal ( encryptedkey ) ; } catch ( exception e ) { throw new illegalstateexception ( encrypt_key_algorithm + _str , e ) ; } }	decrypt key ( does not use salting , so the encryption result is the same for the same input ).
public void configs ( swtplatform ... platforms ) { configs ( arrays . aslist ( platforms ) ) ; }	adds the given location to be the target for artifacts .
private view fillfromselection ( int selectedleft , int childrenleft , int childrenright ) { if ( debug ) log . i ( tag , _str + selectedleft + _str + childrenleft + children_right + childrenright + m_first_position + mfirstposition ) ; final int fadingedgelength = gethorizontalfadingedgelength ( ) ; final int selectedposition = mselectedposition ; final int numrows = mnumrows ; final int horizontalspacing = mhorizontalspacing ; int columnstart ; int columnend = - _num ; if ( ! mstackfrombottom ) { columnstart = selectedposition - ( selectedposition % numrows ) ; } else { int invertedselection = mitemcount - _num - selectedposition ; columnend = mitemcount - _num - ( invertedselection - ( invertedselection % numrows ) ) ; columnstart = math . max ( _num , columnend - numrows + _num ) ; } view sel ; view referenceview ; int leftselectionpixel = getleftselectionpixel ( childrenleft , fadingedgelength , columnstart ) ; int rightselectionpixel = getrightselectionpixel ( childrenright , fadingedgelength , numrows , columnstart ) ; sel = makecolumn ( mstackfrombottom ? columnend : columnstart , selectedleft , _bool ) ; mfirstposition = columnstart ; referenceview = mreferenceview ; adjustforleftfadingedge ( referenceview , leftselectionpixel , rightselectionpixel ) ; adjustforrightfadingedge ( referenceview , leftselectionpixel , rightselectionpixel ) ; if ( ! mstackfrombottom ) { fillleft ( columnstart - numrows , referenceview . getleft ( ) - horizontalspacing ) ; adjustviewsleftorright ( ) ; fillright ( columnstart + numrows , referenceview . getright ( ) + horizontalspacing ) ; } else { fillright ( columnend + numrows , referenceview . getright ( ) + horizontalspacing ) ; adjustviewsleftorright ( ) ; fillleft ( columnstart - _num , referenceview . getleft ( ) - horizontalspacing ) ; } return sel ; }	fills the grid based on positioning the new selection at a specific location.
private static field findfield ( object instance , string name ) throws nosuchfieldexception { for ( class < ? > clazz = instance . getclass ( ) ; clazz != null ; clazz = clazz . getsuperclass ( ) ) { try { field field = clazz . getdeclaredfield ( name ) ; if ( ! field . isaccessible ( ) ) { field . setaccessible ( _bool ) ; } return field ; } catch ( nosuchfieldexception e ) { } } throw new nosuchfieldexception ( _str + name + _str + instance . getclass ( ) ) ; }	locates a given field anywhere in the class inheritance hierarchy .
protected int calculatebreakposition ( int p0 , token tokenlist , float x0 ) { int p = p0 ; rsyntaxtextarea textarea = ( rsyntaxtextarea ) getcontainer ( ) ; float currentwidth = getwidth ( ) ; if ( currentwidth == integer . max_value ) currentwidth = getpreferredspan ( x_axis ) ; currentwidth = math . max ( currentwidth , min_width ) ; token t = tokenlist ; while ( t != null && t . ispaintable ( ) ) { float tokenwidth = t . getwidth ( textarea , this , x0 ) ; if ( tokenwidth > currentwidth ) { if ( p == p0 ) { return t . getoffsetbeforex ( textarea , this , _num , currentwidth ) ; } return t . iswhitespace ( ) ? p + t . textcount : p ; } currentwidth -= tokenwidth ; x0 += tokenwidth ; p += t . textcount ; t = t . getnexttoken ( ) ; } return p + _num ; }	this is called by the nested wrapped line views to determine the break location.
@ override public shapetilesimplex to_simplex ( ) { if ( is_empty ( ) ) return shapetilesimplex . empty ; arraylist < plalineint > line_arr = new arraylist < plalineint > ( _num ) ; line_arr . add ( new plalineint ( box_ll , pladirection . right ) ) ; line_arr . add ( new plalineint ( box_ur , pladirection . up ) ) ; line_arr . add ( new plalineint ( box_ur , pladirection . left ) ) ; line_arr . add ( new plalineint ( box_ll , pladirection . down ) ) ; return new shapetilesimplex ( line_arr ) ; }	returns an object of class simplex defining the same shape.
private void injectcontent ( inject injectcontent ) throws ioexception , mojoexecutionexception { map < pattern , file > contents = getcontentsmap ( injectcontent . getcontents ( ) ) ; file tmpfile = iofactory . createtemporaryfile ( injectcontent . getdestinationfile ( ) ) ; bufferedreader reader = null ; bufferedwriter writer = null ; try { reader = iofactory . newreader ( injectcontent . getdestinationfile ( ) ) ; writer = iofactory . newwriter ( tmpfile ) ; string line ; while ( ( line = reader . readline ( ) ) != null ) { file content = doeslinematchid ( contents , line ) ; if ( content != null ) { iofactory . writecontent ( writer , content , getcontentconverter ( injectcontent ) ) ; } else { iofactory . writeline ( writer , line ) ; } } } finally { if ( reader != null ) { reader . close ( ) ; } if ( writer != null ) { writer . flush ( ) ; writer . close ( ) ; } } iofactory . moveto ( tmpfile , injectcontent . getdestinationfile ( ) ) ; }	injects the configured content files into the destination file .
public static < e > boolean isempty ( charsequence c ) { return ( c == null ) || c . length ( ) == _num ; }	check whether charsequence c is empty .
private static boolean createbooleansetting ( final map < string , string > rawsettings , final string settingname , final boolean defaultvalue ) { final string settingstring = rawsettings . get ( settingname ) ; if ( settingstring == null ) { return defaultvalue ; } else { try { return boolean . parseboolean ( settingstring ) ; } catch ( final numberformatexception exception ) { cutilityfunctions . logexception ( exception ) ; return defaultvalue ; } } }	turns a settings string value into a boolean value .
@ override public void disconnectionnotification ( string eventname , object source ) { m_listenees . remove ( source ) ; }	notify this object that it has been deregistered as a listener with a source for named event.
private marshalledwrapper lookupdo ( template tmpl ) { if ( isempty ( tmpl . servicetypes ) || tmpl . serviceid != null ) { itemiter iter = matchingitems ( tmpl ) ; if ( iter . hasnext ( ) ) return iter . next ( ) . service ; return null ; } list services = matchingservices ( tmpl . servicetypes ) ; long now = system . currenttimemillis ( ) ; int slen = services . size ( ) ; if ( slen == _num ) return null ; int srand = math . abs ( random . nextint ( ) % slen ) ; for ( int i = _num ; i < slen ; i ++ ) { svcreg reg = ( svcreg ) services . get ( ( i + srand ) % slen ) ; if ( reg . leaseexpiration > now && matchattributes ( tmpl , reg . item ) ) return reg . item . service ; } return null ; }	the code that does the real work of lookup.
string generatekey ( ) throws oracleexception { byte [ ] data = null ; try { data = hashfuncs . getrandom ( ) ; } catch ( exception e ) { if ( oraclelog . isloggingenabled ( ) ) log . warning ( e . tostring ( ) ) ; } if ( data == null ) { data = fetchguid ( ) ; } if ( data == null ) { throw sodautils . makeexception ( sodamessage . ex_unable_to_create_uuid ) ; } return ( bytearray . rawtohex ( data ) ) ; }	generate a uuid key string.
public double [ ] arraycopy ( ) { double [ ] array = new double [ length ( ) ] ; for ( indexvalue iv : this ) array [ iv . getindex ( ) ] = iv . getvalue ( ) ; return array ; }	creates a new array that contains all the values of this vector in the appropriate indices.
public static void delete ( path path ) { if ( path != null ) { path = path . toabsolutepath ( ) ; if ( intargetdir ( path ) ) { try { ioutil . delete ( path ) ; } catch ( ioexception e ) { printerror ( _str + path . toabsolutepath ( ) + _str , e ) ; } } else { printerror ( _str + path ) ; } } }	a method that will delete a file or folder only if it is within the ' target ' directory ( for safety ).
private void initpattern ( ) { stringbuffer patterntemplateregex = new stringbuffer ( ) ; logger . debug ( _str ) ; matcher placeholdermatcher = getplaceholdermatcher ( ) ; logger . debug ( _str ) ; while ( placeholdermatcher . find ( ) ) { string group = placeholdermatcher . group ( _num ) ; if ( ! groups . contains ( group ) ) { logger . trace ( _str ) ; groups . add ( group ) ; string groupregex = getgroupregex ( group ) ; placeholdermatcher . appendreplacement ( patterntemplateregex , matcher . quotereplacement ( _str + group + _str + groupregex + _str ) ) ; } else { logger . trace ( _str ) ; placeholdermatcher . appendreplacement ( patterntemplateregex , matcher . quotereplacement ( _str + group + _str ) ) ; } } placeholdermatcher . appendtail ( patterntemplateregex ) ; string patternregex = patterntemplateregex . tostring ( ) ; logger . debug ( _str + patternregex ) ; pattern = pattern . compile ( patternregex ) ; }	initialize the pattern to match files .
protected void newline ( printwriter file , string string , boolean ismanifest ) { string [ ] lines = string . split ( new_line ) ; for ( string line : lines ) { string [ ] words = line . split ( space ) ; stringbuffer sb = new stringbuffer ( ) ; for ( string word : words ) { if ( checkstringlength ( sb . tostring ( ) + word , ismanifest ) ) { sb . append ( word + space ) ; } else { sb . setlength ( sb . length ( ) - _num ) ; addline ( file , sb . tostring ( ) ) ; sb = new stringbuffer ( word + space ) ; } } if ( sb . length ( ) > _num ) { sb . setlength ( sb . length ( ) - _num ) ; } addline ( file , sb . tostring ( ) ) ; } }	writes a string to a file.
protected boolean updateattachmentpoint ( ) { boolean moved = _bool ; this . oldaps = attachmentpoints ; if ( attachmentpoints == null || attachmentpoints . isempty ( ) ) return _bool ; list < attachmentpoint > aplist = new arraylist < attachmentpoint > ( ) ; if ( attachmentpoints != null ) aplist . addall ( attachmentpoints ) ; map < long , attachmentpoint > newmap = getapmap ( aplist ) ; if ( newmap == null || newmap . size ( ) != aplist . size ( ) ) { moved = _bool ; } if ( moved ) { log . info ( _str , attachmentpoints , newmap ) ; list < attachmentpoint > newaplist = new arraylist < attachmentpoint > ( ) ; if ( newmap != null ) newaplist . addall ( newmap . values ( ) ) ; this . attachmentpoints = newaplist ; } return moved ; }	update the known attachment points.
public list < softwrapimpl > removestartingfrom ( int offset ) { int startindex = getsoftwrapindex ( offset ) ; if ( startindex < _num ) { startindex = - startindex - _num ; } if ( startindex >= mywraps . size ( ) ) { return collections . emptylist ( ) ; } list < softwrapimpl > tail = mywraps . sublist ( startindex , mywraps . size ( ) ) ; list < softwrapimpl > result = new arraylist < softwrapimpl > ( tail ) ; tail . clear ( ) ; return result ; }	removes soft wraps with offsets equal or larger than a given offset from storage .
public static string formatdps ( final double dps ) { return _str + string . format ( _str , dps ) + _str ; }	formats given dps ( = damage per second ) to a readable string.
public static string truncate ( string string , int length ) { if ( string . length ( ) > length ) { string = string . substring ( _num , length ) ; } return string ; }	sets the maximum length of the string.
@ suppresswarnings ( _str ) public sortedset < e > subset ( e start , e end ) { return subset ( start , _bool , end , _bool ) ; }	answers a sortedset of the specified portion of this treeset which contains elements greater or equal to the start element but less than the end element.
private boolean checkdisband ( legion legion ) { if ( legion . isdisbanding ( ) ) { if ( ( system . currenttimemillis ( ) / _num ) > legion . getdisbandtime ( ) ) { disbandlegion ( legion ) ; return _bool ; } } return _bool ; }	method that checks if a legion is disbanding.
public void index ( tuple t , string field ) { string s ; if ( ( s = t . getstring ( field ) ) == null ) return ; stringtokenizer st = new stringtokenizer ( s , m_delim ) ; while ( st . hasmoretokens ( ) ) { string tok = st . nexttoken ( ) ; addstring ( tok , t ) ; } }	indexes the given field of the provided tuple instance .
public static void downto ( float self , number to , @ closureparams ( firstparam . class ) closure closure ) { float to1 = to . floatvalue ( ) ; if ( self >= to1 ) { for ( float i = self ; i >= to1 ; i -- ) { closure . call ( i ) ; } } else throw new groovyruntimeexception ( _str + to + _str + self + _str ) ; }	iterates from this number down to the given number , inclusive , decrementing by one each time .
protected void parsedomattributes ( element element ) throws saml2exception { requestid = element . getattribute ( saml2constants . id ) ; validateid ( requestid ) ; version = element . getattribute ( saml2constants . version ) ; validateversion ( version ) ; string issueinstantstr = element . getattribute ( saml2constants . issue_instant ) ; validateissueinstant ( issueinstantstr ) ; destinationuri = element . getattribute ( saml2constants . destination ) ; consent = element . getattribute ( saml2constants . consent ) ; }	parses attributes of the docuemnt element for this object .
protected int readfully ( inputstream in , byte buffer [ ] ) throws java . io . ioexception { for ( int i = _num ; i < buffer . length ; i ++ ) { int q = in . read ( ) ; if ( q == - _num ) return i ; buffer [ i ] = ( byte ) q ; } return buffer . length ; }	this method works around the bizarre semantics of bufferedinputstream ' s read method .
@ calledbynative private static void insertfullscreeninfointolist ( arraylist < fullscreeninfo > list , string origin , string embedder ) { list . add ( new fullscreeninfo ( origin , embedder , _bool ) ) ; }	inserts fullscreen information into a list .
public static inputstream streamfromstring ( string location ) throws ioexception { inputstream is = null ; url url = urlfromstring ( location , null , _bool ) ; if ( url != null ) { is = url . openstream ( ) ; } else { file f = new file ( location ) ; if ( f . exists ( ) ) is = new fileinputstream ( f ) ; } if ( is == null ) { return null ; } else if ( isgzipfile ( location ) ) { return new gzipinputstream ( is ) ; } else { return is ; } }	get an input string corresponding to the given location string.
public void add ( t item ) { synchronized ( lock ) { items . add ( identifieditemfactory . create ( item ) ) ; } notifydatasetchanged ( ) ; }	adds the specified item at the end of the array .
private void copyacls ( list < unmanagedcifsshareacl > origacllist , list < cifsshareacl > shareacllist , fileshare fileshare ) { cifsshareacl shareacl = null ; for ( unmanagedcifsshareacl origacl : origacllist ) { shareacl = new cifsshareacl ( ) ; shareacl . setid ( uriutil . createid ( cifsshareacl . class ) ) ; shareacl . setuser ( origacl . getuser ( ) ) ; shareacl . setpermission ( origacl . getpermission ( ) ) ; shareacl . setsharename ( origacl . getsharename ( ) ) ; shareacl . setfilesystemid ( fileshare . getid ( ) ) ; shareacllist . add ( shareacl ) ; _logger . info ( _str , shareacl . tostring ( ) ) ; } }	copy unmanaged cifs share into new cifs share acls.
public resourcelistparser parse ( ) throws parserconfigurationexception , saxexception , parsefailureexception { try { saxparserfactory factory = saxparserfactory . newinstance ( ) ; saxparser parser = factory . newsaxparser ( ) ; parser . parse ( minputsource , this ) ; return this ; } catch ( ioexception e ) { throw new parsefailureexception ( _str , e ) ; } }	parse the resource list.
public builder deleteentitlements ( ) { deletefields . add ( _str ) ; return this ; }	deletes all entitlements of a existing user.
protected void incorporatesignedproperties ( ) throws dssexception { signedpropertiesdom = dssxmlutils . addelement ( documentdom , qualifyingpropertiesdom , xades , xades_signed_properties ) ; signedpropertiesdom . setattribute ( id , _str + deterministicid ) ; incorporatesignedsignatureproperties ( ) ; }	creates the signedproperties dom object element .
private channelselection createchannelselection ( stylefactoryimpl stylefactory , contrastmethod contrastmethod ) { contrastenhancement contrastenhancement = ( contrastenhancement ) stylefactory . contrastenhancement ( null , contrastmethod . name ( ) ) ; filterfactory ff = commonfactoryfinder . getfilterfactory ( ) ; map < string , expression > options = contrastenhancement . getoptions ( ) ; options . put ( _str , ff . literal ( _str ) ) ; options . put ( _str , ff . literal ( _str ) ) ; options . put ( _str , ff . literal ( _str ) ) ; selectedchanneltype channeltype = stylefactory . createselectedchanneltype ( _str , contrastenhancement ) ; selectedchanneltype [ ] channels = new selectedchanneltype [ _num ] ; channels [ _num ] = channeltype ; channels [ _num ] = channeltype ; channels [ _num ] = channeltype ; channelselection channelselection = stylefactory . createchannelselection ( channels ) ; return channelselection ; }	creates the channel selection object.
public static float mean ( float [ ] data , int [ ] inds ) { float mean = _num ; for ( int i = _num ; i < inds . length ; i ++ ) { if ( float . isnan ( data [ inds [ i ] ] ) ) throw new illegalargumentexception ( _str ) ; mean += data [ inds [ i ] ] ; } mean /= inds . length ; return mean ; }	compute the mean of all elements in the array with given indices.
public int depth ( ) { return pointer ; }	get the depth of the stack .
public result docomparisontest ( properties properties ) throws exception { final long timeout = long . parselong ( properties . getproperty ( testoptions . timeout ) ) ; final int ntrials = integer . parseint ( properties . getproperty ( testoptions . ntrials ) ) ; final int nclients = integer . parseint ( properties . getproperty ( testoptions . nclients ) ) ; final double percentreaders = double . parsedouble ( properties . getproperty ( testoptions . percent_readers ) ) ; final double percentwriterswillflush = double . parsedouble ( properties . getproperty ( testoptions . percent_writer_will_flush ) ) ; final int reclen = integer . parseint ( properties . getproperty ( testoptions . reclen ) ) ; final int nwritespertask = integer . parseint ( properties . getproperty ( testoptions . nwrites ) ) ; final int nreadspertask = integer . parseint ( properties . getproperty ( testoptions . nreads ) ) ; final atomicinteger nerr = new atomicinteger ( ) ; final result result = domrmwtest ( store , timeout , ntrials , nclients , percentreaders , percentwriterswillflush , reclen , nwritespertask , nreadspertask , nerr ) ; return result ; }	setup and run a test .
private void cmd_import ( ) { jfilechooser jc = new jfilechooser ( ) ; jc . setdialogtitle ( msg . getmsg ( env . getctx ( ) , _str ) ) ; jc . setdialogtype ( jfilechooser . open_dialog ) ; jc . setfileselectionmode ( jfilechooser . files_only ) ; if ( jc . showopendialog ( this ) != jfilechooser . approve_option ) return ; stringbuffer sb = new stringbuffer ( ) ; try { inputstreamreader in = new inputstreamreader ( new fileinputstream ( jc . getselectedfile ( ) ) ) ; char [ ] cbuf = new char [ _num ] ; int count ; while ( ( count = in . read ( cbuf ) ) > _num ) sb . append ( cbuf , _num , count ) ; in . close ( ) ; } catch ( exception e ) { log . log ( level . severe , _str + e . getmessage ( ) ) ; return ; } sethtmltext ( sb . tostring ( ) ) ; }	import text from file.
private list < string > fetchfilecosidlist ( ) throws sosfailure { final string methodname = _str ; log . trace ( methodname + _str ) ; final string file_cos_uri = _str ; list < string > filecosidlist = new arraylist < string > ( ) ; try { coslist coselemlist = _client . queryobject ( file_cos_uri , coslist . class ) ; if ( coselemlist != null && coselemlist . getcoselements ( ) != null ) { for ( coselement elem : coselemlist . getcoselements ( ) ) { if ( elem != null ) { filecosidlist . add ( elem . getid ( ) ) ; } } } log . trace ( methodname + _str + filecosidlist ) ; if ( coselemlist != null && filecosidlist != null ) { log . trace ( methodname + _str + filecosidlist . size ( ) + _str ) ; return filecosidlist ; } log . trace ( methodname + _str ) ; return new arraylist < string > ( ) ; } catch ( nosuchalgorithmexception e ) { log . error ( methodname + _str , e ) ; throw new sosfailure ( e ) ; } catch ( uniforminterfaceexception e ) { log . error ( methodname + _str , e ) ; throw new sosfailure ( e ) ; } }	returns list of file cos ids.
public void monitor ( scalingstatemonitortask task ) { taskqueue . add ( task ) ; startmonitor ( ) ; }	adds a monitor task to the queue.
public void insertnodeinto ( mutabletreenode newchild , mutabletreenode parent , int index ) { parent . insert ( newchild , index ) ; int [ ] newindexs = new int [ _num ] ; newindexs [ _num ] = index ; nodeswereinserted ( parent , newindexs ) ; }	invoked this to insert newchild at location index in parents children.
public final double samplemax ( ) { long max = _max . getandset ( _num ) ; return _scale * max ; }	return the probe ' s next sample .
private static void writefile ( file file , list < string > lines ) throws ioexception { if ( ! file . exists ( ) ) file . createnewfile ( ) ; filewriter fw = new filewriter ( file ) ; bufferedwriter bw = new bufferedwriter ( fw ) ; printwriter pw = new printwriter ( bw ) ; for ( string line : lines ) pw . println ( line ) ; bw . close ( ) ; fw . close ( ) ; pw . close ( ) ; }	writes the lines given in input in file .
public synchronized boolean verifychunkauthtag ( int chunkidx , byte [ ] chunkauthtag ) throws fileencryptionexception { if ( ( chunkidx < _num ) || ( chunkauthtag == null ) || ( chunkauthtag . length != backencrandomaccessfile . chunk_tlen ) ) { throw new fileencryptionexception ( _str ) ; } else { byte [ ] storedauthtag = ataglist . get ( chunkidx ) ; if ( storedauthtag == null || ! arrays . equals ( chunkauthtag , storedauthtag ) ) { return _bool ; } else { return _bool ; } } }	verifies if the given chunk authentication tag equals the one in the authentication tag list , but does not verify if the complete list of all authentication tags is valid w.
public static string guessmimetypefromextension ( string extension ) { if ( extension == null || extension . isempty ( ) ) { return null ; } return extensiontomimetypemap . get ( extension ) ; }	returns the mime type for the given extension .
public < annotationtype extends annotation > void register ( methodbinder < annotationtype > methodbinder ) { set < annotatedmethod < annotationtype > > annotatedmethods = annotatedmethods . get ( methodbinder . getannotationclass ( ) , annotatedtype ) ; if ( ! annotatedmethods . isempty ( ) ) { objectbinders . add ( new annotatedmethodbinder < > ( methodbinder , annotatedmethods ) ) ; } }	update the cache with this binder.
private document parseroutefile ( ) throws exception { documentbuilderfactory factory = documentbuilderfactory . newinstance ( ) ; factory . setnamespaceaware ( _bool ) ; documentbuilder builder = factory . newdocumentbuilder ( ) ; return builder . parse ( routefile ) ; }	parse the spring integration route file and return dom document .
public void removedteddirectoryhandler ( dteddirectoryhandler handler ) { directories . remove ( handler ) ; }	remove a dted directoryhandler from the list used for the dtedframecache .
public default void addfile ( final contentprovider contentprovider , final string filename , final entryinformation entryinformation ) throws ioexception { addfile ( contentprovider , filename , entryinformation , optional . empty ( ) ) ; }	add a file to the binary package.
protected void read_lookahead ( ) throws java . lang . exception { lookahead = new symbol [ error_sync_size ( ) ] ; for ( int i = _num ; i < error_sync_size ( ) ; i ++ ) { lookahead [ i ] = cur_token ; cur_token = scan ( ) ; } lookahead_pos = _num ; }	read from input to establish our buffer of " parse ahead " lookahead symbols .
private vector < snmpvarbind > splitfrom ( vector < snmpvarbind > original , int limit ) { int max = original . size ( ) ; vector < snmpvarbind > result = new vector < > ( max - limit ) ; int i = limit ; for ( enumeration < snmpvarbind > e = original . elements ( ) ; e . hasmoreelements ( ) ; -- i ) { snmpvarbind var = e . nextelement ( ) ; if ( i > _num ) continue ; result . addelement ( new snmpvarbind ( var . oid , var . value ) ) ; } return result ; }	this method creates a new vector which does not contain the first element up to the specified limit .
public static void initurbansimzonewriter ( config config ) { urbansimparameterconfigmodulev3 module = ( urbansimparameterconfigmodulev3 ) config . getmodule ( urbansimparameterconfigmodulev3 . group_name ) ; try { log . info ( _str ) ; parcelwriter = ioutils . getbufferedwriter ( module . getmatsim4opustemp ( ) + file_name ) ; log . info ( _str + module . getmatsim4opustemp ( ) + file_name + _str ) ; parcelwriter . write ( internalconstants . parcel_id + _str + accessibility_by_freespeed + _str + accessibility_by_car + _str + accessibility_by_bike + _str + accessibility_by_walk + _str + accessibility_by_pt ) ; parcelwriter . newline ( ) ; log . info ( _str ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }	writes the header for zones csv file.
@ override public void onreset ( ) { closedialog ( ) ; }	called when the view navigates .
public final void delaytask ( @ notnull transactionrunnable task ) { mydelayedtasks . add ( task ) ; }	delay task to be executed after refresh.
public texteditor replaceall ( string regex , string replacement ) { if ( text . length ( ) > _num ) { final string r = replacement ; pattern p = pattern . compile ( regex , pattern . multiline ) ; matcher m = p . matcher ( text ) ; stringbuffer sb = new stringbuffer ( ) ; while ( m . find ( ) ) { m . appendreplacement ( sb , r ) ; } m . appendtail ( sb ) ; text = new stringbuilder ( sb . tostring ( ) ) ; } return this ; }	replace all occurrences of the regular expression with the replacement.
private static < t > int migrateall ( migration < t > migration ) throws exception { int migrated = _num ; for ( t entity : migration . getallentities ( ) ) { try { if ( migration . ismigrated ( entity ) ) continue ; } catch ( exception x ) { log . error ( _str , entity ) ; throw x ; } try { migration . migrate ( entity ) ; } catch ( exception x ) { log . error ( _str , entity ) ; throw x ; } migrated ++ ; } return migrated ; }	migrates entities and skips those which are already migrated .
private void capturedifferentstring ( string oldstring , string newstring , map < string , string > map , string appname ) { reject . ifnull ( appname ) ; reject . ifnull ( map ) ; if ( oldstring == null ? newstring != null : ! oldstring . equals ( newstring ) ) { map . put ( appname , newstring ) ; } }	adds entries to the passed in map , using the supplied appname as the key.
public void onchildthreadresumebegin ( ) { _threadcount . incrementandget ( ) ; }	start housekeeping for a child thread managed by the launcher ' s housekeeping , but not spawned by the launcher itself , e.
@ override protected void drawxlabels ( list < double > xlabels , double [ ] xtextlabellocations , canvas canvas , paint paint , int left , int top , int bottom , double xpixelsperunit , double minx , double maxx ) { int length = xlabels . size ( ) ; if ( length > _num ) { boolean showlabels = mrenderer . isshowlabels ( ) ; boolean showgridy = mrenderer . isshowgridy ( ) ; dateformat format = getdateformat ( xlabels . get ( _num ) , xlabels . get ( length - _num ) ) ; for ( int i = _num ; i < length ; i ++ ) { long label = math . round ( xlabels . get ( i ) ) ; float xlabel = ( float ) ( left + xpixelsperunit * ( label - minx ) ) ; if ( showlabels ) { paint . setcolor ( mrenderer . getxlabelscolor ( ) ) ; canvas . drawline ( xlabel , bottom , xlabel , bottom + mrenderer . getlabelstextsize ( ) / _num , paint ) ; drawtext ( canvas , format . format ( new date ( label ) ) , xlabel , bottom + mrenderer . getlabelstextsize ( ) * _num / _num , paint , mrenderer . getxlabelsangle ( ) ) ; } if ( showgridy ) { paint . setcolor ( mrenderer . getgridcolor ( ) ) ; canvas . drawline ( xlabel , bottom , xlabel , top , paint ) ; } } } drawxtextlabels ( xtextlabellocations , canvas , paint , _bool , left , top , bottom , xpixelsperunit , minx , maxx ) ; }	the graphical representation of the labels on the x axis .
public static string encodetostring ( byte [ ] src ) { if ( src == null ) { return null ; } if ( src . length == _num ) { return _str ; } string result ; try { result = new string ( delegate . encode ( src ) , default_charset . displayname ( ) ) ; } catch ( unsupportedencodingexception e ) { throw new illegalstateexception ( e ) ; } return result ; }	base64 - encode the given byte array to a string .
public boolean equals ( object obj ) { if ( this == obj ) { return _bool ; } if ( obj instanceof ecfieldf2m ) { ecfieldf2m o = ( ecfieldf2m ) obj ; if ( this . m == o . m ) { if ( this . rp == null ) { if ( o . rp == null ) { return _bool ; } } else { return arrays . equals ( this . ks , o . ks ) ; } } } return _bool ; }	returns whether the specified object equals to this finite field .
public elsaserializerpojo make ( ) { return new elsaserializerpojo ( objectstack , singletons , registeredsers , registeredserheaders , registereddeser , unknownclassnotification , new elsaclassinforesolver . arraybased ( classes . toarray ( new class [ _num ] ) ) ) ; }	creates new serializer with configuration from this builder.
private void loadbinary ( inputstream is ) throws ioexception { if ( is instanceof fileinputstream ) { fileinputstream fis = ( fileinputstream ) is ; filechannel fc = fis . getchannel ( ) ; mappedbytebuffer bb = fc . map ( filechannel . mapmode . read_only , _num , ( int ) fc . size ( ) ) ; bb . load ( ) ; loadbinary ( bb ) ; is . close ( ) ; } else { loadbinary ( new datainputstream ( is ) ) ; } }	loads a binary file from the input stream .
private static boolean istwoslottype ( classnode type ) { return type == classhelper . long_type || type == classhelper . double_type ; }	returns true for long and double.
public specificationrunnerbuilder sections ( string [ ] paramsections ) { collections . addall ( this . sections , paramsections ) ; return this ; }	you can add sections to filter the input specification , so livingdoc will only execute the specified sections .
private void consumecrlf ( ) throws decodingexception { char next = nextchar ( ) ; if ( next != _str ) { consumechar ( _str ) ; } consumechar ( _str ) ; }	consumes a crlf from the request.
private string processlogoutrequest ( logoutstate t , logoutrequest logoutrequest , sessionmanager sessionmanager ) throws samlserviceexception { string sessionid = null ; list < sessionindex > sessionlist = logoutrequest . getsessionindexes ( ) ; validate . notnull ( sessionlist , _str ) ; validate . istrue ( sessionlist . size ( ) > _num ) ; for ( sessionindex sessionindex : sessionlist ) { validate . notnull ( sessionindex ) ; string participantsession = sessionindex . getsessionindex ( ) ; validate . notnull ( participantsession , _str ) ; session session = sessionmanager . getbyparticipant ( participantsession ) ; if ( session == null ) { throw new samlserviceexception ( _str ) ; } if ( ! session . containssessionparticipanturl ( t . getissuervalue ( ) ) ) { throw new samlserviceexception ( _str ) ; } if ( sessionid == null ) { sessionid = session . getid ( ) ; } else { if ( ! sessionid . equals ( session . getid ( ) ) ) { throw new samlserviceexception ( _str ) ; } } } return sessionid ; }	process logoutrequest return the session found or throw samlserviceexception.
public boolean equals ( object o ) { if ( o instanceof coverageintvdt ) { coverageintvdt civ = ( coverageintvdt ) o ; return ( ( attribute == civ . attribute ) && ( value == civ . value ) ) ; } else { return _bool ; } }	override the equals method.
public void accept ( final path file ) throws interruptedexception { logger . info ( string . format ( _str , file ) ) ; permits . acquire ( ) ; executor . execute ( new consumertask ( file ) ) ; }	consume a file . jobs are put in an bounded queue and executed in serial , in a separate thread . this method blocks when the queue bound is reached to avoid flooding the consumer .
private void addoptionlist ( final list < string > args , final string optname , final list < string > values ) { for ( final string value : values ) { if ( value != null && ! value . isempty ( ) ) { args . add ( optname ) ; args . add ( value ) ; } } }	adds multivalued option to arguments .
private activity checkactivity ( ) { activity activity = mactivity . get ( ) ; if ( activity == null ) { throw new illegalstateexception ( _str ) ; } return activity ; }	ensures that our weakreference to the activity is still valid.
@ override public synchronized void start ( ) { logger . info ( _str ) ; timer = new timer ( _str ) ; timer . schedule ( this , initial_scan_delay , scan_interval ) ; running = _bool ; }	starts the timer . alive timers will be checked from then on .
public boolean islandingpage ( url url ) { if ( url . getquery ( ) != null ) { return _bool ; } else { return landingpagesuffix ( url ) != _str ; } }	calculates whether the url is a landing page or not.
protected static void writerowcountdefinitions ( tablecreator creator , bytebuffer buffer ) { writerowcountdefinitions ( creator , buffer , creator . getindexcount ( ) ) ; }	writes the index row count definitions into a table definition buffer .
public void send ( string thestring ) { send ( thestring . getbytes ( ) ) ; }	send a string using udp to an already specified remoteaddress .
public void init ( ) { _tokenmgmtexecutor . schedulewithfixeddelay ( new expiredtokencleaner ( ) , _num , _maxlifevaluesholder . getmaxtokenidletimeinmins ( ) , timeunit . minutes ) ; _tokenmgmtexecutor . schedulewithfixeddelay ( new tokenkeysupdater ( ) , _num , foreign_token_keys_bundle_refresh_rate_in_mins , timeunit . minutes ) ; }	initializer , startup the background expired token deletion thread and key updater thread ( no op unless multi vdc ).
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return path ; case _num : return offset_lba ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public string tostring ( ) { return _str + string . valueof ( bean ) + _str ; }	renders a string representation of this object .
private static string dogetpath ( string filename , int separatoradd ) { if ( filename == null ) { return null ; } int prefix = getprefixlength ( filename ) ; if ( prefix < _num ) { return null ; } int index = indexoflastseparator ( filename ) ; int endindex = index + separatoradd ; if ( prefix >= filename . length ( ) || index < _num || prefix >= endindex ) { return _str ; } return filename . substring ( prefix , endindex ) ; }	does the work of getting the path .
private void sign ( final byte [ ] contentbytes , final bytearrayoutputstream mimecontent ) throws exception { string algid = conf . getsignaturealgorithmid ( ) ; string keyid = conf . getactivesigningkey ( ) ; log . debug ( _str + _str , keyid , algid ) ; string signature = signhelper ( keyid , algid , contentbytes ) ; mimecontent . write ( envelopeheader . getbytes ( ) ) ; try ( multipartencoder encoder = new multipartencoder ( mimecontent , envelopeboundary ) ) { encoder . startpart ( mpmixedcontenttype ( databoundary ) ) ; encoder . write ( contentbytes ) ; string alguri = cryptoutils . getsignaturealgorithmuri ( algid ) ; string hashuri = hashcalculator . getalgouri ( ) ; path verificatiocertpath = conf . getcertpath ( keyid ) ; encoder . startpart ( mimetypes . binary , new string [ ] { header_content_transfer_encoding + _str , header_sig_algo_id + _str + alguri , header_verification_cert_hash + _str + getverificationcerthash ( verificatiocertpath ) + _str + header_hash_algorithm_id + _str + hashuri } ) ; encoder . write ( signature . getbytes ( ) ) ; } log . debug ( _str , mimecontent . tostring ( ) ) ; files . write ( tempconfpath , mimecontent . tobytearray ( ) ) ; log . debug ( _str , tempconfpath ) ; }	signs the global configuration directory content .
private boolean nextitemis ( string match ) throws ioexception { int c ; while ( iswhitespace ( c = buf . get ( ) ) ) { } for ( int i = _num ; i < match . length ( ) ; i ++ ) { if ( i > _num ) { c = buf . get ( ) ; } if ( c != match . charat ( i ) ) { return _bool ; } } return _bool ; }	requires the next few characters ( after whitespace ) to match the argument .
public static object deserializeobject ( final byte [ ] objbytes , final classloader loader ) throws ioexception , classnotfoundexception { objectinputstream objin = null ; try { objin = new classloaderobjectinputstream ( new bytearrayinputstream ( objbytes ) , loader ) ; return objin . readobject ( ) ; } finally { close ( objin ) ; } }	convenience method to de - serialize a byte array back into an object who ' s class type is resolved by the specific classloader . < p / >.
public intervalimpl ( int serialnum , long startintervaldatetime , double coveragefactor , framingflowtype intervaldatatype , isource source , iintervalclassification intervalclassification , version adeversion ) throws adeinternalexception { a_adeversion = adeversion ; if ( startintervaldatetime < _num ) { throw new illegalargumentexception ( string . format ( _str + _str + _str + _str , serialnum , startintervaldatetime , coveragefactor , intervaldatatype , source , intervalclassification , adeversion ) ) ; } m_startintervaltime = startintervaldatetime ; m_framingflowtype = intervaldatatype ; m_serialnum = serialnum ; m_intervalclassification = intervalclassification ; if ( m_intervalclassification == null ) { m_intervalclassification = intervalclassificationenum . regular ; } m_messagesummarymap = new treemap < integer , imessagesummary > ( ) ; m_endintervaltime = m_startintervaltime + m_framingflowtype . getduration ( ) ; m_source = source ; if ( coveragefactor <= _num || coveragefactor > _num ) { throw new adeinternalexception ( _str + coveragefactor ) ; } m_coveragefactor = coveragefactor ; }	this is used to build partial intervals .
public static boolean istrue ( map < string , object > dict , string key ) { return istrue ( dict , key , _bool ) ; }	returns true if the dictionary contains true for the given key or false if no value is defined for the key .
protected shoppingcartitem ( ) { }	cannot create shopping cart item with no parameters.
public outputstream bindstream ( outputstream output ) { outputstream stream = m_streams . get ( ) ; m_streams . set ( output ) ; return stream ; }	bind the specified stream to the current thread .
private void initmaplayer ( ) { float zoom = getinitzoom ( mapview . getwidth ( ) , mapview . getheight ( ) , image . getwidth ( ) , image . getheight ( ) ) ; log . i ( tag , float . tostring ( zoom ) ) ; mapview . setcurrentzoom ( zoom , _num , _num ) ; float width = mapview . getwidth ( ) - zoom * image . getwidth ( ) ; float height = mapview . getheight ( ) - zoom * image . getheight ( ) ; mapview . translate ( width / _num , height / _num ) ; }	init map image layer.
public static double sampleskew ( int size , double moment3 , double samplevariance ) { int n = size ; double s = math . sqrt ( samplevariance ) ; double m3 = moment3 * n ; return n * m3 / ( ( n - _num ) * ( n - _num ) * s * s * s ) ; }	returns the sample skew of a data sequence.
private string extractspan ( string spans , int start , int end ) throws indexoutofboundsexception { int offset = getfirstspanoffset ( spans ) ; assert ( start >= offset ) ; assert ( end >= offset ) ; spans += html_open_span ; int substart = getspanpos ( spans , start - offset ) ; int subend = getspanpos ( spans , end - offset + _num ) ; return spans . substring ( substart , subend ) ; }	helper function for uploadnewnertask2 : extract certain token spans from the html token spans that the crowdflower job task1 uses to display a text fragment.
public void finished ( long chainlength ) { currentstate = chainlength ; if ( loggers != null ) { for ( logger logger : loggers ) { logger . log ( currentstate ) ; logger . stoplogging ( ) ; } } if ( showoperatoranalysis ) { showoperatoranalysis ( system . out ) ; } if ( operatoranalysisfile != null ) { try { printstream out = new printstream ( new fileoutputstream ( operatoranalysisfile ) ) ; showoperatoranalysis ( out ) ; out . flush ( ) ; out . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } }	cleans up when the chain finishes ( possibly early ) .
public boolean hasdelay ( ) { return delay != - _num ; }	return true if delay exists.
void pushspacehandling ( attributes attrs ) throws org . xml . sax . saxparseexception { string value = attrs . getvalue ( _str ) ; if ( null == value ) { m_spacepreservestack . push ( m_spacepreservestack . peekorfalse ( ) ) ; } else if ( value . equals ( _str ) ) { m_spacepreservestack . push ( _bool ) ; } else if ( value . equals ( _str ) ) { m_spacepreservestack . push ( _bool ) ; } else { saxsourcelocator locator = getlocator ( ) ; errorlistener handler = m_stylesheetprocessor . geterrorlistener ( ) ; try { handler . error ( new transformerexception ( xslmessages . createmessage ( xslterrorresources . er_illegal_xmlspace_value , null ) , locator ) ) ; } catch ( transformerexception te ) { throw new org . xml . sax . saxparseexception ( te . getmessage ( ) , locator , te ) ; } m_spacepreservestack . push ( m_spacepreservestack . peek ( ) ) ; } }	push boolean value on to the spacepreserve stack depending on the value of xml : space = default / preserve .
protected void positiveclose ( ) { freecontent ( ) ; }	method stub for sub classes do not call from fxdialog e.
public inputstreamreader ( java . io . inputstream is , java . lang . string enc ) throws java . io . unsupportedencodingexception { internal = is ; this . enc = enc . intern ( ) ; }	create an inputstreamreader that uses the named character encoding . is - an inputstreamenc - the name of a supported character encoding - if the named encoding is not supported.
public int serverdelivery ( object message , object consumer , int deliverycount ) throws exception { protonserversendercontext protonsender = serversenders . get ( consumer ) ; if ( protonsender != null ) { return protonsender . delivermessage ( message , deliverycount ) ; } return _num ; }	the consumer object from the broker or the key used to store the sender.
public static string decode ( abstractmessage msg , boolean ext , int header ) { if ( ext == _bool ) { return decode ( msg ) ; } return _str + header ; }	return a string representation of a decoded cbus message.
private instance votedreclassifyexample ( instance example ) throws exception { int classvotes [ ] = new int [ getnumclasses ( ) ] ; for ( int i = _num ; i < classvotes . length ; i ++ ) { classvotes [ i ] = _num ; } for ( enumeration < rulelist > e = new wekaenumeration < rulelist > ( m_decisionlist ) ; e . hasmoreelements ( ) ; ) { rulelist rl = e . nextelement ( ) ; int classvalue = ( int ) rl . classifyinstance ( example ) ; if ( classvalue >= _num ) { classvotes [ classvalue ] ++ ; } } int maxvote = _num ; int vote = - _num ; for ( int i = _num ; i < classvotes . length ; i ++ ) { if ( classvotes [ i ] > maxvote ) { maxvote = classvotes [ i ] ; vote = i ; } } if ( vote >= _num ) { example . setclassvalue ( vote ) ; } else { throw new exception ( _str ) ; } return example ; }	classify example with maximum vote the following way.
public final int hashcode ( ) { return system . identityhashcode ( this ) ; }	the hash code for all sunhints.
public dtmaxisiterator cloneiterator ( ) { _isrestartable = _bool ; try { final precedingiterator clone = ( precedingiterator ) super . clone ( ) ; final int [ ] stackcopy = new int [ _stack . length ] ; system . arraycopy ( _stack , _num , stackcopy , _num , _stack . length ) ; clone . _stack = stackcopy ; return clone ; } catch ( clonenotsupportedexception e ) { throw new dtmexception ( xmlmessages . createxmlmessage ( xmlerrorresources . er_iterator_clone_not_supported , null ) ) ; } }	returns a deep copy of this iterator.
private bigqueryio ( ) { }	disallow construction of utility class .
private boolean keychaincontainsprivatekey ( collection < eckey > keychain , eckey keytoadd ) { if ( keychain == null || keytoadd == null ) { return _bool ; } else { for ( eckey loopkey : keychain ) { if ( arrays . equals ( keytoadd . getprivkeybytes ( ) , loopkey . getprivkeybytes ( ) ) ) { return _bool ; } } return _bool ; } }	this method is here because there is no equals on eckey .
public scriptbuilder data ( byte [ ] data ) { if ( data . length == _num ) return smallnum ( _num ) ; else return data ( chunks . size ( ) , data ) ; }	adds a copy of the given byte array as a data element ( i.
public rotationmatrixbuilder withthetas ( double theta ) { for ( plane plane : planes ) { plane . settheta ( theta ) ; } return this ; }	sets the rotation angle , in radians , of all 2d rotation planes added to this builder .
private void writeuserregistry ( localcontainer container , file configdir , map < string , string > users , map < string , list < string > > groups ) throws ioexception { file usersxml = new file ( configdir , _str ) ; printstream writer = serverconfigutils . open ( usersxml ) ; writer . println ( _str ) ; for ( map . entry < string , string > user : users . entryset ( ) ) { writer . print ( _str ) ; writer . print ( user . getkey ( ) ) ; writer . print ( _str ) ; writer . print ( user . getvalue ( ) ) ; writer . println ( _str ) ; } for ( map . entry < string , list < string > > group : groups . entryset ( ) ) { writer . print ( _str ) ; writer . print ( group . getkey ( ) ) ; writer . println ( _str ) ; for ( string member : group . getvalue ( ) ) { writer . print ( _str ) ; writer . print ( member ) ; writer . println ( _str ) ; } writer . println ( _str ) ; } writer . println ( _str ) ; serverconfigutils . close ( writer ) ; }	this method writes a user registry xml.
public static string valueof ( double value ) { return double . tostring ( value ) ; }	converts the specified double to its string representation .
private static void decodehanzisegment ( bitsource bits , stringbuilder result , int count ) throws formatexception { if ( count * _num > bits . available ( ) ) { throw formatexception . getformatinstance ( ) ; } byte [ ] buffer = new byte [ _num * count ] ; int offset = _num ; while ( count > _num ) { int twobytes = bits . readbits ( _num ) ; int assembledtwobytes = ( ( twobytes / _num ) << _num ) | ( twobytes % _num ) ; if ( assembledtwobytes < _num ) { assembledtwobytes += _num ; } else { assembledtwobytes += _num ; } buffer [ offset ] = ( byte ) ( ( assembledtwobytes > > _num ) & _num ) ; buffer [ offset + _num ] = ( byte ) ( assembledtwobytes & _num ) ; offset += _num ; count -- ; } try { result . append ( new string ( buffer , stringutils . gb2312 ) ) ; } catch ( unsupportedencodingexception ignored ) { throw formatexception . getformatinstance ( ) ; } }	see specification gbt 18284 - 2000.
@ genignore static record createrecord ( string name , string address , class itf , jsonobject metadata ) { return createrecord ( name , address , itf . getname ( ) , metadata ) ; }	sugar method to creates a record for this type.
public stopwatchcpu ( ) { threadtimer = managementfactory . getthreadmxbean ( ) ; start = threadtimer . getcurrentthreadcputime ( ) ; }	initializes a new stopwatch .
public synchronized byte [ ] lookupaudio ( string inputtype , string locale , string voice , string outputparams , string style , string effects , string inputtext ) throws sqlexception { if ( inputtype == null || locale == null || voice == null || inputtext == null ) { throw new nullpointerexception ( _str ) ; } byte [ ] audio = null ; string query = _str + inputtype + _str + locale + _str + voice + _str + outputparams + _str + style + _str + effects + _str ; preparedstatement st = connection . preparestatement ( query ) ; st . setstring ( _num , inputtext ) ; resultset results = st . executequery ( ) ; if ( results . next ( ) ) { audio = results . getbytes ( _num ) ; } return audio ; }	carry out a lookup in the cache with the given parameters , for a request with output type audio .
public void addcondition ( final condition condition ) { conditions . add ( condition ) ; condition . setid ( conditionidcounter ++ ) ; }	will add the condition to the list .
public static byte [ ] readbytesfrombytebuffer ( bytebuffer bytebuffer ) { byte [ ] buffer = new byte [ bytebuffer . remaining ( ) ] ; bytebuffer . get ( buffer ) ; return buffer ; }	reads the remaining bytes in a bytebuffer into a byte [ ] .
public void findpackageandclass ( ) throws ioexception { packagename = null ; classname = null ; linenumberreader reader = new linenumberreader ( new filereader ( inputfile ) ) ; try { while ( classname == null || packagename == null ) { string line = reader . readline ( ) ; if ( line == null ) break ; if ( packagename == null ) { matcher matcher = package_pattern . matcher ( line ) ; if ( matcher . find ( ) ) { packagename = matcher . group ( _num ) ; } } if ( classname == null ) { matcher matcher = class_pattern . matcher ( line ) ; if ( matcher . find ( ) ) { classname = matcher . group ( _num ) ; } } } if ( classname == null ) { classname = _str ; } } finally { reader . close ( ) ; } }	peek into . flex file to get package and class name.
public static void log ( final string msg , final throwable t ) { if ( debug ) { log ( msg ) ; t . printstacktrace ( system . out ) ; } }	prints msg and exception to system.
public static set < uri > fetchrptargetvirtualpools ( dbclient dbclient ) { set < uri > rpprotectedtargetvpools = new hashset < uri > ( ) ; try { list < uri > vpoolprotectionsettingsuris = dbclient . querybytype ( vpoolprotectionvarraysettings . class , _bool ) ; iterator < vpoolprotectionvarraysettings > vpoolprotectionsettingsitr = dbclient . queryiterativeobjects ( vpoolprotectionvarraysettings . class , vpoolprotectionsettingsuris , _bool ) ; while ( vpoolprotectionsettingsitr . hasnext ( ) ) { vpoolprotectionvarraysettings rsetting = vpoolprotectionsettingsitr . next ( ) ; if ( null != rsetting && ! nullcolumnvaluegetter . isnulluri ( rsetting . getvirtualpool ( ) ) ) { rpprotectedtargetvpools . add ( rsetting . getvirtualpool ( ) ) ; } } } catch ( exception ex ) { _log . error ( _str , ex ) ; } return rpprotectedtargetvpools ; }	fetch the rp protected target virtual pool uris .
public nsdata ( file file ) throws ioexception { bytes = new byte [ ( int ) file . length ( ) ] ; randomaccessfile raf = new randomaccessfile ( file , _str ) ; raf . read ( bytes ) ; raf . close ( ) ; }	creates a nsdata object from a file.
public int cardinality ( ) { int sum = _num ; for ( long l : this . data ) sum += long . bitcount ( l ) ; return sum ; }	compute the number of bits set to 1.
private string deescapeliteral ( string lit ) { return lit . replaceall ( _str , _str ) ; }	de - escapes a literal.
private static uri cookieuri ( uri uri , httpcookie cookie ) { uri cookieuri = uri ; if ( cookie . getdomain ( ) != null ) { string domain = cookie . getdomain ( ) ; if ( domain . charat ( _num ) == _str ) { domain = domain . substring ( _num ) ; } try { cookieuri = new uri ( uri . getscheme ( ) == null ? _str : uri . getscheme ( ) , domain , cookie . getpath ( ) == null ? _str : cookie . getpath ( ) , null ) ; } catch ( urisyntaxexception e ) { log . w ( tag , e ) ; } } return cookieuri ; }	get the real uri from the cookie " domain " and " path " attributes , if they are not set then uses the uri provided ( coming from the response ).
public static void i ( string msg , object ... args ) { if ( ! allowi ) return ; stacktraceelement caller = getcallerstacktraceelement ( ) ; string tag = generatetag ( caller ) ; if ( slevel > level_info ) { return ; } if ( args . length > _num ) { msg = string . format ( msg , args ) ; } log . i ( tag , msg ) ; }	send an info log message.
public static < v > boolean addlistnotnullvalue ( list < v > sourcelist , v value ) { return ( sourcelist != null && value != null ) ? sourcelist . add ( value ) : _bool ; }	add not null entry to list.
public dnewkeystoretype ( jframe parent ) { super ( parent , dialog . modalitytype . document_modal ) ; settitle ( res . getstring ( _str ) ) ; initcomponents ( ) ; }	creates a new dnewkeystoretype dialog .
protected void sprint ( long longfield ) { sprint ( string . valueof ( longfield ) ) ; }	pretty printing accumulator function for longs.
private string substitutesubstring ( string input , string find , string replace ) { int find_length = find . length ( ) ; int replace_length = replace . length ( ) ; stringbuilder output = new stringbuilder ( input ) ; int index = input . indexof ( find ) ; int outputoffset = _num ; while ( index > - _num ) { output . replace ( index + outputoffset , index + outputoffset + find_length , replace ) ; outputoffset = outputoffset + ( replace_length - find_length ) ; index = input . indexof ( find , index + find_length ) ; } return output . tostring ( ) ; }	replace substrings of one string with another string and return altered string .
public void removelistener ( final l listener ) { validate . notnull ( listener , _str ) ; listeners . remove ( listener ) ; }	unregisters an event listener .
public void run ( ) { start ( ) ; try { while ( _bool ) { thread . sleep ( interval ) ; processconfigmessages ( ) ; } } catch ( interruptedexception e ) { e . printstacktrace ( ) ; log . warn ( _str ) ; } finally { log . info ( _str ) ; stop ( ) ; } }	this method is an infinite loop that periodically checks if there are any new messages in the job coordinator stream , and reads them if they exist.
private int clampmag ( int value , int absmin , int absmax ) { final int absvalue = math . abs ( value ) ; if ( absvalue < absmin ) return _num ; if ( absvalue > absmax ) return value > _num ? absmax : - absmax ; return value ; }	clamp the magnitude of value for absmin and absmax.
private void readobject ( java . io . objectinputstream s ) throws ioexception , classnotfoundexception { s . defaultreadobject ( ) ; init ( getname ( ) , getmask ( actions ) ) ; }	readobject is called to restore the state of the servicepermission from a stream .
public int predblockindexforsourcesindex ( int sourcesindex ) { return operands . get ( sourcesindex ) . blockindex ; }	gets the index of the pred block associated with the registerspec at the particular getsources ( ) index .
public lockablefilewriter ( file file , charset encoding , boolean append , string lockdir ) throws ioexception { super ( ) ; file = file . getabsolutefile ( ) ; if ( file . getparentfile ( ) != null ) { fileutils . forcemkdir ( file . getparentfile ( ) ) ; } if ( file . isdirectory ( ) ) { throw new ioexception ( _str ) ; } if ( lockdir == null ) { lockdir = system . getproperty ( _str ) ; } file lockdirfile = new file ( lockdir ) ; fileutils . forcemkdir ( lockdirfile ) ; testlockdir ( lockdirfile ) ; lockfile = new file ( lockdirfile , file . getname ( ) + lck ) ; createlock ( ) ; out = initwriter ( file , encoding , append ) ; }	constructs a lockablefilewriter with a file encoding .
void appendprogramdescription ( final wrappingstringbuilder wb ) { if ( ! mprogramdescription . equals ( _str ) ) { wb . append ( ls ) ; wb . setwrapindent ( _num ) ; wb . wraptextwithnewlines ( mprogramdescription ) ; } }	append the description text for this program , if one exists .
public static byte [ ] decode ( string s ) throws java . io . ioexception { return decode ( s , no_options ) ; }	decodes data from base64 notation , automatically detecting gzip - compressed data and decompressing it .
@ suppresswarnings ( _str ) private static final url tourl ( string location , boolean file ) { if ( file ) { file f = new file ( location ) ; if ( f . exists ( ) ) { try { return f . tourl ( ) ; } catch ( malformedurlexception murl ) { return null ; } } else { return null ; } } else { return geturl ( location ) ; } }	makes a url out of a location , as either a file or a resource .
protected object parsevalue ( string string ) { int openparen = string . indexof ( _str ) ; string type = string . substring ( _num , openparen ) ; string value = string . substring ( openparen + _num , string . length ( ) - _num ) ; if ( type . equals ( _str ) ) { return value ; } else if ( type . equals ( _str ) ) { return new float ( float . parsefloat ( value ) ) ; } else if ( type . equals ( _str ) ) { return new integer ( integer . parseint ( value ) ) ; } else if ( type . equals ( _str ) ) { stringtokenizer tok = new stringtokenizer ( value , _str ) ; int size = tok . counttokens ( ) ; int [ ] values = new int [ size ] ; for ( int i = _num ; i < size ; i ++ ) { float fval = float . parsefloat ( tok . nexttoken ( ) ) ; values [ i ] = math . round ( fval ) ; } return values ; } else { throw new error ( _str + type ) ; } }	coerces a string into a value .
public static string touppercase ( string string ) { boolean changed = _bool ; char [ ] chars = string . tochararray ( ) ; for ( int i = _num ; i != chars . length ; i ++ ) { char ch = chars [ i ] ; if ( _str <= ch && _str >= ch ) { changed = _bool ; chars [ i ] = ( char ) ( ch - _str + _str ) ; } } if ( changed ) { return new string ( chars ) ; } return string ; }	a locale independent version of touppercase .
@ override public void update ( list < envvar > datalist ) { envvarlist . clear ( ) ; if ( datalist == null ) { for ( envvar envvar : builtinenvvarmap . values ( ) ) { envvarlist . add ( envvar ) ; } } else { for ( envvar envvar : datalist ) { if ( builtinenvvarmap . containskey ( envvar . getname ( ) ) ) { envvarlist . add ( new envvar ( envvar , _bool ) ) ; } else { envvarlist . add ( new envvar ( envvar , _bool ) ) ; } } } setenvironmentvariablevalues ( ) ; }	update the environment variables .
public void makeclass ( string str , boolean caseless ) { for ( int i = _num ; i < str . length ( ) ; i ++ ) makeclass ( str . charat ( i ) , caseless ) ; }	creates a new character class for each character of the specified string .
protected void notifytimestampstogateways ( entryeventimpl event ) { versiontagholder updatetimestampevent = new versiontagholder ( event . getversiontag ( ) ) ; updatetimestampevent . setoperation ( operation . update_version_stamp ) ; updatetimestampevent . setkeyinfo ( event . getkeyinfo ( ) ) ; updatetimestampevent . setgeneratecallbacks ( _bool ) ; updatetimestampevent . distributedmember = event . getdistributedmember ( ) ; updatetimestampevent . setneweventid ( getsystem ( ) ) ; if ( event . getregion ( ) instanceof bucketregion ) { bucketregion br = ( bucketregion ) event . getregion ( ) ; partitionedregion pr = br . getpartitionedregion ( ) ; updatetimestampevent . setregion ( pr ) ; if ( pr . isparallelwanenabled ( ) ) { br . handlewanevent ( updatetimestampevent ) ; } if ( pr . isinitialized ( ) ) { pr . notifygatewaysender ( enumlistenerevent . timestamp_update , updatetimestampevent ) ; } } else { updatetimestampevent . setregion ( event . getregion ( ) ) ; notifygatewaysender ( enumlistenerevent . timestamp_update , updatetimestampevent ) ; } }	this notifies all wan sites about updated timestamp on local site .
public token nextregex ( pattern pattern ) { if ( ! hasnextregex ( pattern ) ) throw new illegalstateexception ( _str ) ; matcher matcher = anymentionpattern . matcher ( remaining ) ; if ( ! matcher . find ( ) ) throw new illegalstateexception ( _str ) ; final int start = currentposition + matcher . start ( ) ; final int end = currentposition + matcher . end ( ) ; stepto ( end ) ; return new token ( this , start , end ) ; }	returns the next occurrence of the regular expression , stepping forward the tokenizer to the next line .
public boolean removenode ( servicenode node ) { try { return nodes . remove ( node ) ; } catch ( exception e ) { return _bool ; } }	remove a service node from the node list.
public string asstring ( ) throws ioexception { long len = getcontentlength ( ) ; bytearrayoutputstream buf ; if ( _num < len ) { buf = new bytearrayoutputstream ( ( int ) len ) ; } else { buf = new bytearrayoutputstream ( ) ; } writeto ( buf ) ; return decode ( buf . tobytearray ( ) , getcharacterencoding ( ) ) ; }	return a copy of the result as a string.
public void execute ( ) throws ioexception { string key = _str + ( system . currenttimemillis ( ) / _num ) ; string b64key = base64 . encode ( key ) ; sendhandshakerequest ( b64key ) ; receivehandshakeresponse ( b64key ) ; }	executes a websocket handshake . will throw an ioexception if the handshake fails.
public void calculatemin ( double min ) { if ( this . min == - _num ) { this . min = min ; } else { this . min = math . min ( this . min , min ) ; } }	sets the minimum and deals with the - 1 initialization ! .
private void emituntil ( @ nonnegative int taskcountallowed ) throws ioexception { try { while ( emitqueue . size ( ) > taskcountallowed ) { future < byte [ ] > future = emitqueue . remove ( ) ; byte [ ] towrite = future . get ( ) ; blocksizes . add ( towrite . length ) ; out . write ( towrite ) ; } tryemit ( ) ; } catch ( executionexception e ) { throw new ioexception ( e ) ; } catch ( interruptedexception e ) { throw new interruptedioexception ( ) ; } }	emits any opportunistically available blocks.
void xrot ( double theta ) { theta *= ( pi / _num ) ; double ct = math . cos ( theta ) ; double st = math . sin ( theta ) ; float nyx = ( float ) ( yx * ct + zx * st ) ; float nyy = ( float ) ( yy * ct + zy * st ) ; float nyz = ( float ) ( yz * ct + zz * st ) ; float nyo = ( float ) ( yo * ct + zo * st ) ; float nzx = ( float ) ( zx * ct - yx * st ) ; float nzy = ( float ) ( zy * ct - yy * st ) ; float nzz = ( float ) ( zz * ct - yz * st ) ; float nzo = ( float ) ( zo * ct - yo * st ) ; yo = nyo ; yx = nyx ; yy = nyy ; yz = nyz ; zo = nzo ; zx = nzx ; zy = nzy ; zz = nzz ; }	rotate theta degrees about the x axis.
public void testauditcompleted ( ) { }	test of auditcompleted method , of class auditservicethreadqueueimpl .
public static void scalerectaboutcenter ( rect r , float scale ) { if ( scale != _num ) { int cx = r . centerx ( ) ; int cy = r . centery ( ) ; r . offset ( - cx , - cy ) ; r . left = ( int ) ( r . left * scale + _num ) ; r . top = ( int ) ( r . top * scale + _num ) ; r . right = ( int ) ( r . right * scale + _num ) ; r . bottom = ( int ) ( r . bottom * scale + _num ) ; r . offset ( cx , cy ) ; } }	scales a rect about its centroid.
private static charhandler parseunprintableextcodes ( string [ ] codestrings ) { if ( codestrings . length != _num ) { throw new illegalstateexception ( _str + arrays . aslist ( codestrings ) ) ; } byte [ ] bytes = codestobytes ( codestrings [ _num ] , _bool ) ; if ( bytes . length != _num ) { throw new illegalstateexception ( _str + arrays . aslist ( codestrings ) ) ; } return new unprintableextcharhandler ( bytes [ _num ] ) ; }	returns a unprintableextcharhandler parsed from the given index code strings .
private int measureheight ( int measurespec ) { float result ; int specmode = measurespec . getmode ( measurespec ) ; int specsize = measurespec . getsize ( measurespec ) ; if ( specmode == measurespec . exactly ) { result = specsize ; } else { result = mpaintselected . getstrokewidth ( ) + getpaddingtop ( ) + getpaddingbottom ( ) ; if ( specmode == measurespec . at_most ) { result = math . min ( result , specsize ) ; } } return ( int ) math . ceil ( result ) ; }	determines the height of this view.
public static boolean isnull ( uri id ) { return ( id == null ) || null_uri . equals ( id ) ; }	checks if the id is null ( or matches the null_uri ) .
public void updatependinglist ( ) { while ( mpendinglist . size ( ) > _num && activelisthasroom ( ) ) { downloadinforunnable pending = mpendinglist . get ( _num ) ; pending . changestatusstate ( new activestate ( pending ) ) ; } }	check if there are pending downloads and if so move the top one up to the active list .
@ suppresswarnings ( _str ) public static float valuerangelimit ( float value , float startvalue , float endvalue ) { if ( value < math . min ( startvalue , endvalue ) ) return math . min ( startvalue , endvalue ) ; if ( value > math . max ( startvalue , endvalue ) ) return math . max ( startvalue , endvalue ) ; return value ; }	limit number within a values range.
protected void createtitle ( string title ) { string newtitle ; newtitle = _str + new version ( ) ; if ( title . length ( ) != _num ) { newtitle += _str + title ; } settitle ( newtitle ) ; }	creates and displays the title .
public static boolean isconnected ( nettype nettype , networkinfo networkinfo ) { if ( nettype == nettype . any && networkinfo != null && isconnected ( networkinfo ) ) return _bool ; else if ( nettype == nettype . wifi && networkinfo != null && networkinfo . gettype ( ) == connectivitymanager . type_wifi && isconnected ( networkinfo ) ) return _bool ; else if ( nettype == nettype . mobile && networkinfo != null && networkinfo . gettype ( ) == connectivitymanager . type_mobile && isconnected ( networkinfo ) ) return _bool ; return _bool ; }	according to the different type of network to determine whether the network connection .
public void deleteitem ( int position ) { if ( ! isdatalistempty ( ) && position >= _num && position < mdatalist . size ( ) ) { mdatalist . remove ( position ) ; notifyitemremoved ( position ) ; } }	delete an item by position.
private int calculategraidentchannel ( int sourcechannel , int destchannel , int distance , int offset ) { if ( sourcechannel == destchannel ) { return sourcechannel ; } float ratio = ( ( float ) offset ) / ( ( float ) distance ) ; int pos = ( int ) ( math . abs ( sourcechannel - destchannel ) * ratio ) ; if ( sourcechannel > destchannel ) { return sourcechannel - pos ; } else { return sourcechannel + pos ; } }	converts the color channel value according to the offest within the distance.
public static void addstartuplistener ( startuplistener s ) { m_startuplisteners . add ( s ) ; }	add a listener to be notified when startup is complete .
public static void closequiet ( @ nullable selectionkey rsrc ) { if ( rsrc != null ) closequiet ( rsrc . channel ( ) ) ; }	quietly closes given resource ignoring possible checked exceptions .
public completablefuture < newfile > run ( ) { log . log ( level . fine , _str , files . size ( ) ) ; completablefuture < newfile > filecreation = new completablefuture < > ( ) ; final list < tsdata > fjpfiles = this . files ; task_pool . execute ( null ) ; synchronized ( outstanding ) { outstanding . add ( filecreation ) ; } this . files = new linkedlist < > ( ) ; return filecreation ; }	start creating the optimized file.
private static key createdeskey ( byte [ ] bytes , int offset ) { byte [ ] keybytes = new byte [ _num ] ; system . arraycopy ( bytes , offset , keybytes , _num , _num ) ; byte [ ] material = new byte [ _num ] ; material [ _num ] = keybytes [ _num ] ; material [ _num ] = ( byte ) ( keybytes [ _num ] << _num | ( keybytes [ _num ] & _num ) > > > _num ) ; material [ _num ] = ( byte ) ( keybytes [ _num ] << _num | ( keybytes [ _num ] & _num ) > > > _num ) ; material [ _num ] = ( byte ) ( keybytes [ _num ] << _num | ( keybytes [ _num ] & _num ) > > > _num ) ; material [ _num ] = ( byte ) ( keybytes [ _num ] << _num | ( keybytes [ _num ] & _num ) > > > _num ) ; material [ _num ] = ( byte ) ( keybytes [ _num ] << _num | ( keybytes [ _num ] & _num ) > > > _num ) ; material [ _num ] = ( byte ) ( keybytes [ _num ] << _num | ( keybytes [ _num ] & _num ) > > > _num ) ; material [ _num ] = ( byte ) ( keybytes [ _num ] << _num ) ; oddparity ( material ) ; return new secretkeyspec ( material , _str ) ; }	creates a des encryption key from the given key material .
static void checkdesc ( final string desc , final boolean canbevoid ) { int end = checkdesc ( desc , _num , canbevoid ) ; if ( end != desc . length ( ) ) { throw new illegalargumentexception ( _str + desc ) ; } }	checks that the given string is a valid type descriptor .
protected jsoutput newjsoutput ( module m ) throws ioexception { return new jsoutput ( m , iscompilinglanguagemodule ( ) ) ; }	this exists solely so that the web ide can override it and use a different jsoutput.
public string text ( ) { stringbuilder sb = new stringbuilder ( ) ; for ( node node : nodes ) { sb . append ( node . gettextcontent ( ) ) ; } return sb . tostring ( ) ; }	gets the combined text contents of each element in the set of matched elements , including their descendants.
public void addline ( int startline , string sourcefile , int repeatcount , int outputline , int outputincrement ) { _lines . add ( new line ( startline , sourcefile , repeatcount , outputline , outputincrement ) ) ; }	adds a line from the smap.
public string ( stringbuffer stringbuffer ) { offset = _num ; synchronized ( stringbuffer ) { value = stringbuffer . sharevalue ( ) ; count = stringbuffer . length ( ) ; } }	creates a string from the contents of a stringbuffer .
public int size ( ) { return all . size ( ) ; }	return the number of signers in the collection .
public process executeasync ( final commandline command , final map < string , string > environment , final executeresulthandler handler ) throws ioexception { if ( workingdirectory != null && ! workingdirectory . exists ( ) ) { throw new ioexception ( workingdirectory + _str ) ; } return executeinternal ( command , environment , workingdirectory , streamhandler , handler ) ; }	methods for starting asynchronous execution.
public libertymanagerclient ( ) { }	constructs the libertymanager client.
private void checkcomplianceattributes ( attrset attrset , boolean ignorecompliance ) throws amexception { if ( ! ignorecompliance && complianceservicesimpl . iscomplianceuserdeletionenabled ( ) ) { complianceimpl . verifyattributes ( attrset ) ; } }	checks for compliance related attributes if applicable . the check can be over - ridden by setting the ignorecompliance to true.
private void updatezoningmap ( unmanagedexportmask mask , list < initiator > initiators , list < storageport > storageports ) { zoneinfomap zoningmap = networkdevicecontroller . getinitiatorszoneinfomap ( initiators , storageports ) ; for ( zoneinfo zoneinfo : zoningmap . values ( ) ) { log . info ( _str , new object [ ] { zoneinfo . getzonename ( ) , zoneinfo . getinitiatorwwn ( ) , zoneinfo . getportwwn ( ) } ) ; } mask . setzoningmap ( zoningmap ) ; }	set mask zoning map.
public invitationstatus waitinvitationanswer ( ) { return waitinvitationanswer ( mringingperiod ) ; }	wait session invitation answer.
private double [ ] [ ] xprime ( int t ) { double [ ] [ ] x = new double [ _num ] [ getnumlags ( ) * numvars ] ; for ( int i = _num ; i < getnumlags ( ) ; i ++ ) { double [ ] [ ] yprime = yprime ( t - i - _num ) ; system . arraycopy ( yprime [ _num ] , _num , x [ _num ] , i * numvars , numvars ) ; } return x ; }	constructs the x ( t ) vector .
public int size ( ) { return components . size ( ) ; }	returns the number of components that are stored in this container .
public void testroundmathcontextprecision0 ( ) { string a = _str ; int ascale = _num ; int precision = _num ; roundingmode rm = roundingmode . half_up ; mathcontext mc = new mathcontext ( precision , rm ) ; string res = _str ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal result = anumber . round ( mc ) ; assertequals ( _str , res , result . tostring ( ) ) ; assertequals ( _str , ascale , result . scale ( ) ) ; }	round ( bigdecimal , mathcontext ) when precision = 0.
public void omitlessfreq ( ) { if ( name == null ) return ; int threshold = n_words [ _num ] / less_freq_ratio ; if ( threshold < minimum_freq ) threshold = minimum_freq ; set < string > keys = freq . keyset ( ) ; int roman = _num ; for ( iterator < string > i = keys . iterator ( ) ; i . hasnext ( ) ; ) { string key = i . next ( ) ; int count = freq . get ( key ) ; if ( count <= threshold ) { n_words [ key . length ( ) - _num ] -= count ; i . remove ( ) ; } else { if ( key . matches ( _str ) ) { roman += count ; } } } if ( roman < n_words [ _num ] / _num ) { set < string > keys2 = freq . keyset ( ) ; for ( iterator < string > i = keys2 . iterator ( ) ; i . hasnext ( ) ; ) { string key = i . next ( ) ; if ( key . matches ( _str ) ) { n_words [ key . length ( ) - _num ] -= freq . get ( key ) ; i . remove ( ) ; } } } }	eliminate below less frequency n - grams and noise latin alphabets.
public static publickeyselector fromstring ( string type ) { if ( type != null ) { for ( publickeyselector keyselector : publickeyselector . values ( ) ) { if ( type . equalsignorecase ( keyselector . type ) ) { return keyselector ; } } } return null ; }	translates a string into a token endpoint auth method type .
public static sortedmap < integer , integer > generatesortedtagmap ( string [ ] partitions , map < string , string > tags ) { final sortedmap < integer , integer > taghashmap = new treemap < integer , integer > ( ) ; for ( map . entry < string , string > entry : tags . entryset ( ) ) { final string tagname = entry . getkey ( ) ; final string tagvalue = entry . getvalue ( ) ; if ( tagvalue == null || ispartitiontag ( partitions , tagname ) ) continue ; taghashmap . put ( tagname . hashcode ( ) , tagvalue . hashcode ( ) ) ; } return taghashmap ; }	generate the internal sorted hashmap for tags.
public static void describeshapedetail ( shape shape , double flattening ) { pathiterator pi2 = shape . getpathiterator ( null ) ; flatteningpathiterator pi = new flatteningpathiterator ( pi2 , flattening ) ; double [ ] coords = new double [ _num ] ; int pointcount = _num ; debug . output ( _str + flattening + _str ) ; while ( ! pi . isdone ( ) ) { int type = pi . currentsegment ( coords ) ; debug . output ( _str + type + _str + ( pointcount ++ ) + _str + coords [ _num ] + _str + coords [ _num ] ) ; pi . next ( ) ; } debug . output ( _str + pointcount + _str ) ; }	utility method that iterates over a shape object and prints out the points.
protected static string shortenclassname ( string nam , char c ) { final int lastdot = nam . lastindexof ( c ) ; if ( lastdot >= _num ) { nam = nam . substring ( lastdot + _num ) ; } return nam ; }	shorten the class name .
public void add ( t graphic ) { synchronized ( mlock ) { mgraphics . add ( graphic ) ; } postinvalidate ( ) ; }	adds a graphic to the overlay .
public string tostring ( ) { stringbuffer sbuf = new stringbuffer ( ) ; typeparameter . tostring ( sbuf , typeparams ) ; sbuf . append ( _str ) ; type . tostring ( sbuf , params ) ; sbuf . append ( _str ) ; sbuf . append ( rettype ) ; if ( exceptions . length > _num ) { sbuf . append ( _str ) ; type . tostring ( sbuf , exceptions ) ; } return sbuf . tostring ( ) ; }	returns the string representation .
@ override public void flip ( x11componentpeer peer , component target , volatileimage xbackbuffer , int x1 , int y1 , int x2 , int y2 , buffercapabilities . flipcontents flipaction ) { if ( flipaction == buffercapabilities . flipcontents . copied ) { surfacemanager vsm = surfacemanager . getmanager ( xbackbuffer ) ; surfacedata sd = vsm . getprimarysurfacedata ( ) ; if ( sd instanceof glxvsyncoffscreensurfacedata ) { glxvsyncoffscreensurfacedata vsd = ( glxvsyncoffscreensurfacedata ) sd ; surfacedata bbsd = vsd . getflipsurface ( ) ; graphics2d bbg = new sungraphics2d ( bbsd , color . black , color . white , null ) ; try { bbg . drawimage ( xbackbuffer , _num , _num , null ) ; } finally { bbg . dispose ( ) ; } } else { graphics g = peer . getgraphics ( ) ; try { g . drawimage ( xbackbuffer , x1 , y1 , x2 , y2 , x1 , y1 , x2 , y2 , null ) ; } finally { g . dispose ( ) ; } return ; } } else if ( flipaction == buffercapabilities . flipcontents . prior ) { return ; } oglsurfacedata . swapbuffers ( peer . getcontentwindow ( ) ) ; if ( flipaction == buffercapabilities . flipcontents . background ) { graphics g = xbackbuffer . getgraphics ( ) ; try { g . setcolor ( target . getbackground ( ) ) ; g . fillrect ( _num , _num , xbackbuffer . getwidth ( ) , xbackbuffer . getheight ( ) ) ; } finally { g . dispose ( ) ; } } }	performs the native glx flip operation for the given target component .
public boolean addproperty ( owlproperty property ) { property . addrestriction ( this ) ; return properties . add ( property ) ; }	add " onproperty p " information , and tell p to point back here .
public static googleanalytics initialisegoogleanalytics ( context context , string trackerid , final exceptionparser callback ) { manalytics = googleanalytics . getinstance ( context ) ; manalytics . setlocaldispatchperiod ( _num ) ; mtracker = manalytics . newtracker ( trackerid ) ; mtracker . enableexceptionreporting ( _bool ) ; mtracker . enableautoactivitytracking ( _bool ) ; thread . uncaughtexceptionhandler handler = thread . getdefaultuncaughtexceptionhandler ( ) ; if ( handler != null && handler instanceof exceptionreporter ) { exceptionreporter exceptionreporter = ( exceptionreporter ) handler ; exceptionreporter . setexceptionparser ( callback ) ; thread . setdefaultuncaughtexceptionhandler ( exceptionreporter ) ; log . d ( log_tag , _str ) ; } else { log . e ( log_tag , _str ) ; } return manalytics ; }	initialise google analytics immediately so it will catch all sorts of errors prior to easytracker onstart.
void onmoved ( ) { double diff = system . currenttimemillis ( ) - timestamp ; timestamp = _num ; if ( diff > discard_threshold ) { return ; } double recentjitter = _num ; double sum = _num ; for ( int i = _num ; i < vector_length ; i ++ ) { double old = times [ i ] ; double avg = ( diff + old ) / _num ; recentjitter += math . abs ( old - diff ) ; times [ i ] = avg ; diff = old ; sum += avg ; } recentjitter /= _num ; jitter = ( jitter + _num * math . max ( jitter , recentjitter ) + recentjitter ) / _num ; prediction = turn_length / ( sum / vector_length + jitter ) ; wtwindowmanager wm = wtwindowmanager . getinstance ( ) ; wm . setproperty ( speed_property , double . tostring ( prediction ) ) ; wm . setproperty ( jitter_property , double . tostring ( jitter ) ) ; }	called when the user moves.
public serviceid ( datainput in ) throws ioexception { this . mostsig = in . readlong ( ) ; this . leastsig = in . readlong ( ) ; }	reads in 16 bytes in standard network byte order .
public void onenterelementconsumed ( string uri , string localname , string qname , attributes atts ) throws saxexception { attstack . push ( currentatts = new attributesimpl ( atts ) ) ; nseffectivestack . push ( new integer ( nseffectiveptr ) ) ; nseffectiveptr = namespaces . size ( ) ; }	called by the generated handler code when an enter element event is consumed.
private void addfinally ( arraylist returnlist , stmnt finallyblock ) throws compileerror { bytecode bc = bytecode ; int n = returnlist . size ( ) ; for ( int i = _num ; i < n ; ++ i ) { final int [ ] ret = ( int [ ] ) returnlist . get ( i ) ; int pc = ret [ _num ] ; bc . write16bit ( pc , bc . currentpc ( ) - pc + _num ) ; returnhook hook = new jsrhook2 ( this , ret ) ; finallyblock . accept ( this ) ; hook . remove ( this ) ; if ( ! hasreturned ) { bc . addopcode ( opcode . goto ) ; bc . addindex ( pc + _num - bc . currentpc ( ) ) ; } } }	adds a finally clause for earch return statement .
public object nextmeta ( ) throws jsonexception { char c ; char q ; do { c = next ( ) ; } while ( character . iswhitespace ( c ) ) ; switch ( c ) { case _num : throw syntaxerror ( _str ) ; case _str : return xml . lt ; case _str : return xml . gt ; case _str : return xml . slash ; case _str : return xml . eq ; case _str : return xml . bang ; case _str : return xml . quest ; case _str : case _str : q = c ; for ( ; ; ) { c = next ( ) ; if ( c == _num ) { throw syntaxerror ( _str ) ; } if ( c == q ) { return boolean . true ; } } default : for ( ; ; ) { c = next ( ) ; if ( character . iswhitespace ( c ) ) { return boolean . true ; } switch ( c ) { case _num : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : back ( ) ; return boolean . true ; } } } }	returns the next xml meta token.
public static void writejsonstring ( collection collection , writer out ) throws ioexception { if ( collection == null ) { out . write ( _str ) ; return ; } boolean first = _bool ; iterator iter = collection . iterator ( ) ; out . write ( _str ) ; while ( iter . hasnext ( ) ) { if ( first ) first = _bool ; else out . write ( _str ) ; object value = iter . next ( ) ; if ( value == null ) { out . write ( _str ) ; continue ; } jsonvalue . writejsonstring ( value , out ) ; } out . write ( _str ) ; }	encode a list into json text and write it to out.
protected int [ ] readcolortable ( final int ncolors ) { final int nbytes = _num * ncolors ; int [ ] tab = null ; final byte [ ] c = new byte [ nbytes ] ; try { rawdata . get ( c ) ; tab = new int [ _num ] ; int i = _num ; int j = _num ; while ( i < ncolors ) { final int r = ( c [ j ++ ] ) & _num ; final int g = ( c [ j ++ ] ) & _num ; final int b = ( c [ j ++ ] ) & _num ; tab [ i ++ ] = _num | ( r << _num ) | ( g << _num ) | b ; } } catch ( final bufferunderflowexception e ) { log . w ( tag , _str , e ) ; status = status_format_error ; } return tab ; }	reads color table as 256 rgb integer values.
void touch ( boolean openreadonly ) throws ioexception { if ( isreadonly || openreadonly ) { throw new ioexception ( _str ) ; } lastmodified = system . currenttimemillis ( ) ; }	update the last modified time .
@ sneakythrows public void addkeytokeystore ( keystore keystore , x509certificate cert , rsaprivatekey privatekey , string alias , string password ) { keystore . passwordprotection pass = new keystore . passwordprotection ( password . tochararray ( ) ) ; certificate [ ] certificatechain = { cert } ; keystore . setentry ( alias , new keystore . privatekeyentry ( privatekey , certificatechain ) , pass ) ; }	based on a public certificate , private key , alias and password , this method will load the certificate and private key as an entry into the keystore , and it will set the provided alias and password to the keystore entry .
public boolean needsreload ( file file ) { return ffilestoreoad . contains ( file ) ; }	returns true if the given indicator file needs to be reloaded .
public putrepositoryrequest source ( byte [ ] repositorydefinition ) { return source ( repositorydefinition , _num , repositorydefinition . length ) ; }	parses repository definition . json , smile and yaml formats are supported.
private void disablebuttons ( ) { setfireenabled ( _bool ) ; setskipenabled ( _bool ) ; settwistenabled ( _bool ) ; setnextenabled ( _bool ) ; butdone . setenabled ( _bool ) ; setfliparmsenabled ( _bool ) ; setfiremodeenabled ( _bool ) ; setnexttargetenabled ( _bool ) ; }	disables all buttons in the interface.
public boolean isadditivenumber ( string num ) { int n = num . length ( ) ; for ( int i = _num ; i <= n / _num ; i ++ ) { if ( num . charat ( _num ) == _str && i > _num ) { return _bool ; } biginteger num1 = new biginteger ( num . substring ( _num , i ) ) ; for ( int j = _num ; math . max ( i , j ) <= n - i - j ; j ++ ) { if ( num . charat ( i ) == _str && j > _num ) { break ; } biginteger num2 = new biginteger ( num . substring ( i , i + j ) ) ; if ( isadditivenumber ( num1 , num2 , i + j , num ) ) { return _bool ; } } } return _bool ; }	recursive . generate the first and second of the sequence , check if the rest of the string match the sum recursively . i is the length of first number , j is the length of thgste second .
@ override public void write ( string str ) { int start = _num ; while ( start < str . length ( ) ) { int end = math . min ( start + max_message_length , str . length ( ) ) ; log . i ( tag , str . substring ( start , end ) ) ; start = end ; } }	writes the given string to android logcat .
protected void addtoquarantinequeue ( nodeporttuple npt ) { if ( quarantinequeue . contains ( npt ) == _bool ) { quarantinequeue . add ( npt ) ; } }	add a switch port to the quarantine queue.
private carbondictionarysortinfo createcolumnsortinfo ( carbondictionarysortmodel [ ] dictionarysortmodels ) { int [ ] sortindex ; int [ ] sortindexinverted ; arrays . sort ( dictionarysortmodels ) ; sortindex = new int [ dictionarysortmodels . length ] ; sortindexinverted = new int [ dictionarysortmodels . length ] ; for ( int i = _num ; i < dictionarysortmodels . length ; i ++ ) { carbondictionarysortmodel dictionarysortmodel = dictionarysortmodels [ i ] ; sortindex [ i ] = dictionarysortmodel . getkey ( ) ; sortindexinverted [ dictionarysortmodel . getkey ( ) - _num ] = i + _num ; } dictionarysortmodels = null ; list < integer > sortindexlist = converttolist ( sortindex ) ; list < integer > sortindexinvertedlist = converttolist ( sortindexinverted ) ; return new carbondictionarysortinfo ( sortindexlist , sortindexinvertedlist ) ; }	the method prepares the sort_index and sort_index_inverted data.
private void addfeature ( jsonnode feature , int index ) { pointfeature feat = null ; try { feat = pointfeature . fromjsonnode ( feature ) ; } catch ( emptypolygonexception e ) { log . warn ( _str ) ; return ; } catch ( unsupportedgeometryexception e ) { log . warn ( e . message ) ; return ; } if ( feat == null ) { return ; } addfeature ( feat , index ) ; }	add one geojson feature to this freeformpointset from a jackson node tree.
public bitstring ( final string value ) { this ( value . length ( ) ) ; for ( int i = _num ; i < value . length ( ) ; i ++ ) { if ( value . charat ( i ) == _str ) { setbit ( value . length ( ) - ( i + _num ) , _bool ) ; } else if ( value . charat ( i ) != _str ) { throw new illegalargumentexception ( _str + i ) ; } } }	initialises the bit string from a character string of 1s and 0s in big - endian order .
public void sort ( comparator < individual > comparator ) { collections . sort ( individuals , comparator ) ; }	sorts the individuals in ascending order according to their performance , thus the best one will be in last position .
public void write ( writer writer ) throws exception { writer . write ( tostring ( ) ) ; writer . flush ( ) ; }	writes the current dom document into the given writer .
public safeasynctask ( ) { this . executor = default_executor ; }	sets executor to executors . newfixedthreadpool ( default_pool_size ) and handler to new handler ( ).
public static boolean iscglibrenamedmethod ( method renamedmethod ) { string name = renamedmethod . getname ( ) ; if ( name . startswith ( cglib_renamed_method_prefix ) ) { int i = name . length ( ) - _num ; while ( i >= _num && character . isdigit ( name . charat ( i ) ) ) { i -- ; } return ( ( i > cglib_renamed_method_prefix . length ( ) ) && ( i < name . length ( ) - _num ) && ( name . charat ( i ) == _str ) ) ; } return _bool ; }	determine whether the given method is a cglib ' renamed ' method , following the pattern " cglib $ methodname $ 0 " .
public pwresetexception ( string bundlename , string errcode , object [ ] args ) { super ( bundlename , errcode , args ) ; errlist = new arraylist ( _num ) ; errlist . add ( getmessage ( ) ) ; }	creates a password reset exception object with localizable error message .
public static string [ ] unionarrays ( string [ ] array1 , string [ ] array2 ) { if ( array1 == null ) { return array2 ; } if ( array2 == null ) { return array1 ; } set < string > set = new linkedhashset < > ( ) ; set . addall ( arrays . aslist ( array1 ) ) ; set . addall ( arrays . aslist ( array2 ) ) ; return set . toarray ( new string [ set . size ( ) ] ) ; }	returns a union of 2 arrays , ensuring that each string exists only once .
boolean isstatechange ( xdecoratedpeer window , xpropertyevent e ) { if ( ! window . isshowing ( ) ) { statelog . finer ( _str ) ; return _bool ; } int wm_state = window . getwmstate ( ) ; if ( wm_state == xutilconstants . withdrawnstate ) { statelog . finer ( _str ) ; return _bool ; } else { if ( statelog . isloggable ( platformlogger . level . finer ) ) { statelog . finer ( _str + wm_state ) ; } } boolean is_state_change = _bool ; if ( e . get_atom ( ) == xa_wm_state . getatom ( ) ) { is_state_change = _bool ; } for ( xstateprotocol proto : getprotocols ( xstateprotocol . class ) ) { is_state_change |= proto . isstatechange ( e ) ; if ( statelog . isloggable ( platformlogger . level . finest ) ) { statelog . finest ( proto + _str + is_state_change ) ; } } return is_state_change ; }	\ notice window state change when wm changes a property on the window.
@ override public xobject execute ( xpathcontext xctxt ) throws javax . xml . transform . transformerexception { node xpathownernode = ( node ) xctxt . getownerobject ( ) ; if ( xpathownernode == null ) { return null ; } int xpathownernodedtm = xctxt . getdtmhandlefromnode ( xpathownernode ) ; int currentnode = xctxt . getcurrentnode ( ) ; dtm dtm = xctxt . getdtm ( currentnode ) ; int doccontext = dtm . getdocument ( ) ; if ( dtm . null == doccontext ) { error ( xctxt , xpatherrorresources . er_context_has_no_ownerdoc , null ) ; } { document currentdoc = xmlutils . getownerdocument ( dtm . getnode ( currentnode ) ) ; document xpathownerdoc = xmlutils . getownerdocument ( xpathownernode ) ; if ( currentdoc != xpathownerdoc ) { throw new transformerexception ( i18n . translate ( _str ) ) ; } } xnodeset nodes = new xnodeset ( xctxt . getdtmmanager ( ) ) ; nodesetdtm nodeset = nodes . mutablenodeset ( ) ; { int herenode = dtm . null ; switch ( dtm . getnodetype ( xpathownernodedtm ) ) { case node . attribute_node : case node . processing_instruction_node : { herenode = xpathownernodedtm ; nodeset . addnode ( herenode ) ; break ; } case node . text_node : { herenode = dtm . getparent ( xpathownernodedtm ) ; nodeset . addnode ( herenode ) ; break ; } default : break ; } } nodeset . detach ( ) ; return nodes ; }	the here function returns a node - set containing the attribute or processing instruction node or the parent element of the text node that directly bears the xpath expression.
public list < localtime > top ( int n ) { list < localtime > top = new arraylist < > ( ) ; int [ ] values = data . tointarray ( ) ; intarrays . parallelquicksort ( values , reverseintcomparator . instance ( ) ) ; for ( int i = _num ; i < n && i < values . length ; i ++ ) { top . add ( packedlocaltime . aslocaltime ( values [ i ] ) ) ; } return top ; }	returns the largest ( " top " ) n values in the column.
public static string grabclass ( string signature ) { matcher matcher = sigre . matcher ( signature ) ; boolean b = matcher . matches ( ) ; if ( ! b && matcher . groupcount ( ) != _num ) logger . error ( _str , signature ) ; return matcher . group ( _num ) ; }	grab the class from the signature.
public timeseriesmetricdeltaset ( stream < entry < tags , metricvalue > > td ) { values_ = any2 . right ( td . collect ( collectors . tomap ( null , null , null , null ) ) ) ; }	create a metricdelta set for tagged metrics and initialize it with the given collection .
public int size ( ) { return nodes . size ( ) ; }	returns the number of nodes in this model ' s nodelist .
@ override public final e nextelement ( ) { e result = m_vector . get ( m_counter ) ; m_counter ++ ; if ( m_counter == m_specialelement ) { m_counter ++ ; } return result ; }	returns the next element .
private bytestring escapebytes ( final bytestring value ) { if ( ! needescaping ( value ) ) { return value ; } final bytestringbuilder builder = new bytestringbuilder ( ) ; for ( int i = _num ; i < value . length ( ) ; i ++ ) { final byte b = value . byteat ( i ) ; if ( isbytetoescape ( b ) ) { builder . appendbyte ( dn . normalized_esc_byte ) ; } builder . appendbyte ( b ) ; } return builder . tobytestring ( ) ; }	return a new byte string with bytes 0x00 , 0x01 and 0x02 escaped.
public inputbuilder < t > repeatall ( int times ) { list < t > toappend = new arraylist < > ( ) ; for ( int i = _num ; i < times ; i ++ ) { toappend . addall ( input ) ; } input . addall ( toappend ) ; return this ; }	repeat the current input list.
public final void renameclass ( map classnames ) { string jvmnewthisname = ( string ) classnames . get ( descriptor . tojvmname ( thisclassname ) ) ; if ( jvmnewthisname != null ) thisclassname = descriptor . tojavaname ( jvmnewthisname ) ; constpool . renameclass ( classnames ) ; attributeinfo . renameclass ( attributes , classnames ) ; arraylist list = methods ; int n = list . size ( ) ; for ( int i = _num ; i < n ; ++ i ) { methodinfo minfo = ( methodinfo ) list . get ( i ) ; string desc = minfo . getdescriptor ( ) ; minfo . setdescriptor ( descriptor . rename ( desc , classnames ) ) ; attributeinfo . renameclass ( minfo . getattributes ( ) , classnames ) ; } list = fields ; n = list . size ( ) ; for ( int i = _num ; i < n ; ++ i ) { fieldinfo finfo = ( fieldinfo ) list . get ( i ) ; string desc = finfo . getdescriptor ( ) ; finfo . setdescriptor ( descriptor . rename ( desc , classnames ) ) ; attributeinfo . renameclass ( finfo . getattributes ( ) , classnames ) ; } }	replaces all occurrences of several class names in the class file .
@ suppresswarnings ( _str ) public void handlebutton3request ( requestinvocationevent event ) { backtrail ( ) ; try { string name = ( string ) getpagesessionattribute ( save_vb_name ) ; viewbean vb = getviewbean ( class . forname ( name ) ) ; passpgsessionmap ( vb ) ; vb . forwardto ( getrequestcontext ( ) ) ; } catch ( classnotfoundexception e ) { debug . warning ( _str , e ) ; } }	called on request from the ui to return to the previous page .
public ionexception ( throwable cause ) { super ( cause . getmessage ( ) , cause ) ; }	constructs a new exception with the given cause , copying the message from the cause into this instance .
public final double distance ( ) { return math . sqrt ( distance_square ( ) ) ; }	the " size " of the line from 0 , 0 to x , y.
@ override public void done ( ) { super . done ( ) ; if ( mnumtestsexpected > mnumtestsrun ) { handletestrunfailed ( string . format ( _str , mnumtestsexpected , mnumtestsrun ) ) ; } else if ( mtestruninprogress ) { handletestrunfailed ( _str ) ; } }	called by parent when adb session is complete .
public list < challenge > challenges ( ) { string responsefield ; if ( code == http_unauthorized ) { responsefield = _str ; } else if ( code == http_proxy_auth ) { responsefield = _str ; } else { return collections . emptylist ( ) ; } return okheaders . parsechallenges ( headers ( ) , responsefield ) ; }	returns the authorization challenges appropriate for this response ' s code.
byte [ ] tobytes ( sslsession session ) { if ( ! ( session instanceof opensslsessionimpl ) ) { return null ; } opensslsessionimpl sslsession = ( opensslsessionimpl ) session ; try { bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; dataoutputstream daos = new dataoutputstream ( baos ) ; daos . writeint ( open_ssl ) ; byte [ ] data = sslsession . getencoded ( ) ; daos . writeint ( data . length ) ; daos . write ( data ) ; certificate [ ] certs = session . getpeercertificates ( ) ; daos . writeint ( certs . length ) ; for ( certificate cert : certs ) { data = cert . getencoded ( ) ; daos . writeint ( data . length ) ; daos . write ( data ) ; } return baos . tobytearray ( ) ; } catch ( ioexception e ) { log ( e ) ; return null ; } catch ( certificateencodingexception e ) { log ( e ) ; return null ; } }	converts the given session to bytes .
public mersennetwister ( ) { mt = new int [ n ] ; setseed ( system . currenttimemillis ( ) + system . identityhashcode ( this ) ) ; }	creates a new random number generator.
private void verifytimestamp ( x509certificate cert ) throws certpathvalidatorexception { string msg = _str ; if ( debug != null ) debug . println ( _str + msg + _str + date . tostring ( ) + _str ) ; try { cert . checkvalidity ( date ) ; } catch ( certificateexpiredexception e ) { throw new certpathvalidatorexception ( msg + _str , e , null , - _num , basicreason . expired ) ; } catch ( certificatenotyetvalidexception e ) { throw new certpathvalidatorexception ( msg + _str , e , null , - _num , basicreason . not_yet_valid ) ; } if ( debug != null ) debug . println ( msg + _str ) ; }	internal method to verify the timestamp on a certificate.
public static byte [ ] encryptpassword ( final string password , final byte [ ] seed ) throws nosuchalgorithmexception { if ( password == null || password . equals ( _str ) ) { return new byte [ _num ] ; } final messagedigest messagedigest = messagedigest . getinstance ( _str ) ; final byte [ ] stage1 = messagedigest . digest ( password . getbytes ( ) ) ; messagedigest . reset ( ) ; final byte [ ] stage2 = messagedigest . digest ( stage1 ) ; messagedigest . reset ( ) ; messagedigest . update ( seed ) ; messagedigest . update ( stage2 ) ; final byte [ ] digest = messagedigest . digest ( ) ; final byte [ ] returnbytes = new byte [ digest . length ] ; for ( int i = _num ; i < digest . length ; i ++ ) { returnbytes [ i ] = ( byte ) ( stage1 [ i ] ^ digest [ i ] ) ; } return returnbytes ; }	encrypts a password < p > protocol for authentication is like this : 1.
public int rows ( ) { return rows ; }	returns the number of rows of the receiver .
public static string array2hex ( final byte [ ] array ) { return bytearray2string ( array , _str , _str , _bool , _num ) ; }	a byte array into its hex string representation.
private byte [ ] writecheckedbytes ( messagenano proto ) { backupprotos . checkedmessage wrapper = new backupprotos . checkedmessage ( ) ; wrapper . payload = messagenano . tobytearray ( proto ) ; crc32 checksum = new crc32 ( ) ; checksum . update ( wrapper . payload ) ; wrapper . checksum = checksum . getvalue ( ) ; return messagenano . tobytearray ( wrapper ) ; }	wrap a proto in a checkedmessage and compute the checksum .
public double reduceto ( int width , int height , double limit ) { int w = geticonwidth ( ) ; int h = geticonheight ( ) ; double scale = _num ; if ( w > width ) { scale = ( ( double ) width ) / w ; } if ( h > height ) { scale = math . min ( scale , ( ( double ) height ) / h ) ; } if ( scale < _num ) { if ( limit > _num ) { scale = math . max ( scale , limit ) ; } affinetransform t = affinetransform . getscaleinstance ( scale , scale ) ; transformimage ( ( int ) math . ceil ( scale * w ) , ( int ) math . ceil ( scale * h ) , t , null ) ; } return scale ; }	if necessary , reduce this image to within ' width ' x ' height ' dimensions . limit the reduction by ' limit '.
public void installbuiltinsound ( string soundidentifier , inputstream data ) throws ioexception { builtinsounds . put ( soundidentifier , convertbuiltinsound ( data ) ) ; }	installs a replacement sound as the builtin sound responsible for the given sound identifier ( this will override the system sound if such a sound exists ) .
private integer countfragmentfilteredpages ( list < string > templatefragments , boolean whitelist ) throws wikiapiexception { try { int count = _num ; preparedstatement statement = null ; resultset result = null ; try { stringbuffer sqlstring = new stringbuffer ( ) ; stringbuffer subconditions = new stringbuffer ( ) ; sqlstring . append ( _str + generatorconstants . table_tplid_tplname + _str + generatorconstants . table_tplid_pageid + _str + ( whitelist ? _str : _str ) + _str ) ; for ( @ suppresswarnings ( _str ) string fragment : templatefragments ) { if ( subconditions . length ( ) != _num ) { subconditions . append ( _str ) ; } subconditions . append ( _str ) ; } sqlstring . append ( subconditions ) ; sqlstring . append ( _str ) ; statement = connection . preparestatement ( sqlstring . tostring ( ) ) ; int curidx = _num ; for ( string fragment : templatefragments ) { fragment = fragment . tolowercase ( ) ; fragment = fragment . trim ( ) ; fragment = fragment . replaceall ( _str , _str ) ; statement . setstring ( curidx ++ , fragment + _str ) ; } result = execute ( statement ) ; if ( result == null ) { return _num ; } if ( result . next ( ) ) { count = result . getint ( _num ) ; } } finally { if ( statement != null ) { statement . close ( ) ; } if ( result != null ) { result . close ( ) ; } } return count ; } catch ( exception e ) { throw new wikiapiexception ( e ) ; } }	returns the number of all pages that contain a template the name of which starts with any of the the given strings .
public static int findname ( string name , int [ ] table ) { for ( int i = _num ; i < table . length ; i ++ ) { if ( name . equals ( getname ( table [ i ] ) ) ) { return i ; } } return - _num ; }	get the encoding value of a glyph given its name and a charset .
private void scoretrackresults ( collection < track > tracks , searchquery query , collection < scoredresult > output ) { for ( track track : tracks ) { double score = scoretrackresult ( query , track ) ; output . add ( new scoredresult ( track , score ) ) ; } }	scores a collection of track results .
private long currenttime ( ) { return system . currenttimemillis ( ) / _num ; }	returns a current time seconds from epoch .
private static byte [ ] encode ( double latitude , double longitude ) { byte [ ] bytes = new byte [ _num * integer . bytes ] ; numericutils . inttosortablebytes ( encodelatitude ( latitude ) , bytes , _num ) ; numericutils . inttosortablebytes ( encodelongitude ( longitude ) , bytes , integer . bytes ) ; return bytes ; }	sugar encodes a single point as a byte array.
public static void putlongvolatile ( object obj , long off , long val ) { unsafe . putlongvolatile ( obj , off , val ) ; }	stores long value with volatile semantic .
public static list < string > run ( list < string > commands ) { return shell . run ( _str , commands . toarray ( new string [ commands . size ( ) ] ) , null , _bool ) ; }	runs commands as root ( if available ) and return output.
public void circle ( double x , double y , double r ) { if ( r < _num ) throw new illegalargumentexception ( _str ) ; double xs = scalex ( x ) ; double ys = scaley ( y ) ; double ws = factorx ( _num * r ) ; double hs = factory ( _num * r ) ; if ( ws <= _num && hs <= _num ) pixel ( x , y ) ; else offscreen . draw ( new ellipse2d . double ( xs - ws / _num , ys - hs / _num , ws , hs ) ) ; draw ( ) ; }	draws a circle of radius r , centered on ( x , y ) .
final public void println ( double v ) { writer out = this . out ; if ( out == null ) return ; print ( v ) ; try { out . write ( _newline , _num , _newline . length ) ; } catch ( ioexception e ) { log . log ( level . fine , e . tostring ( ) , e ) ; } }	prints a double followed by a newline .
public void writesi32 ( int value ) throws ioexception { flushbits ( ) ; out . write ( value & _num ) ; out . write ( value > > _num ) ; out . write ( value > > _num ) ; out . write ( value > > _num ) ; byteswritten += _num ; }	write a 32 bit signed value.
private static void map ( final stringbuilder buffer , final bytesequence sequence , final boolean trim , final boolean foldcase ) { final string value = sequence . tostring ( ) ; for ( int i = _num ; i < value . length ( ) ; i ++ ) { final char c = value . charat ( i ) ; if ( map_2_null . contains ( c ) ) { continue ; } if ( map_2_space . contains ( c ) ) { if ( canmaptospace ( buffer , trim ) ) { buffer . append ( space_char ) ; } continue ; } if ( foldcase ) { final string mapping = case_map_table . get ( c ) ; if ( mapping != null ) { buffer . append ( mapping ) ; continue ; } } buffer . append ( c ) ; } }	checks each character and replaces it with its mapping .
public void addbuttonpressedlistener ( fieldconfigstringbuttoninterface listener ) { if ( buttonpressedlistenerlist == null ) { buttonpressedlistenerlist = new arraylist < fieldconfigstringbuttoninterface > ( ) ; } buttonpressedlistenerlist . add ( listener ) ; }	adds the button pressed listener .
public void dispose ( ) { logdebug ( _str ) ; msetupdone = _bool ; if ( mserviceconn != null ) { logdebug ( _str ) ; if ( mcontext != null ) mcontext . unbindservice ( mserviceconn ) ; mserviceconn = null ; mservice = null ; mpurchaselistener = null ; } }	dispose of object , releasing resources.
private void fillxmlattribute ( attributes att , int index ) { fillqname ( fattributeqname , att . geturi ( index ) , att . getlocalname ( index ) , att . getqname ( index ) ) ; string type = att . gettype ( index ) ; fattributes . addattributens ( fattributeqname , ( type != null ) ? type : xmlsymbols . fcdatasymbol , att . getvalue ( index ) ) ; }	adds an attribute to the xmlattributes object .
public jcomponent createpropertygui ( propertyconsumer pc ) { this . propertyconsumer = pc ; properties props = new properties ( ) ; props = pc . getproperties ( props ) ; properties info = new properties ( ) ; info = pc . getpropertyinfo ( info ) ; string prefix = pc . getpropertyprefix ( ) ; return createpropertygui ( prefix , props , info ) ; }	creates a jcomponent with the properties to be changed.
public long copy ( string filename , outputstream out , long offset , long size ) throws ioexception , interruptedexception { if ( size < _num ) { return _num ; } bufferedinputstream is = new bufferedinputstream ( getfileinputstream ( filename ) ) ; byte [ ] buf = new byte [ _num * _num ] ; int bytesread ; long pos = _num ; long remaining = size ; try { if ( offset != _num ) { is . skip ( offset ) ; pos += offset ; } while ( remaining != _num ) { int max = buf . length ; if ( max > remaining ) { max = ( int ) remaining ; } bytesread = is . read ( buf , _num , max ) ; if ( bytesread == - _num ) { break ; } out . write ( buf , _num , bytesread ) ; pos += bytesread ; remaining -= bytesread ; } out . flush ( ) ; } catch ( exception e ) { out . flush ( ) ; } finally { try { is . close ( ) ; } catch ( exception e ) { } } return pos ; }	copies the given file to the output stream continously , i.
private static void deserializeheader ( kdbheader kdbheader , datainput datainput ) throws ioexception { kdbheader . setflags ( datainput . readint ( ) ) ; kdbheader . setversion ( datainput . readint ( ) ) ; byte [ ] buffer = new byte [ _num ] ; datainput . readfully ( buffer ) ; kdbheader . setmasterseed ( buffer ) ; buffer = new byte [ _num ] ; datainput . readfully ( buffer ) ; kdbheader . setencryptioniv ( buffer ) ; kdbheader . setgroupcount ( datainput . readint ( ) ) ; kdbheader . setentrycount ( datainput . readint ( ) ) ; byte [ ] buffer32 = new byte [ _num ] ; datainput . readfully ( buffer32 ) ; kdbheader . setcontenthash ( buffer32 ) ; buffer32 = new byte [ _num ] ; datainput . readfully ( buffer32 ) ; kdbheader . settransformseed ( buffer32 ) ; kdbheader . settransformrounds ( datainput . readint ( ) ) ; }	deserialize a header from a source into the supplied kdbheader.
public void runtest ( ) throws throwable { document doc ; nodelist elementlist ; node namenode ; characterdata child ; string childdata ; doc = ( document ) load ( _str , _bool ) ; elementlist = doc . getelementsbytagname ( _str ) ; namenode = elementlist . item ( _num ) ; child = ( characterdata ) namenode . getfirstchild ( ) ; child . insertdata ( _num , _str ) ; childdata = child . getdata ( ) ; assertequals ( _str , _str , childdata ) ; }	runs the test case .
public boolean areallpermissionsgranted ( ) { return deniedpermissionresponses . isempty ( ) ; }	returns whether the user has granted all the requested permission.
private string fetchcharsetfromcache ( client client , locale loc ) { map ccache = ( map ) charsetcache . get ( client . getclienttype ( ) ) ; string val = null ; if ( ccache != null ) { val = ( string ) ccache . get ( loc ) ; } return val ; }	fetches the charset to be used for any given locale from cache.
public shape paintlayer ( graphics g , int offs0 , int offs1 , shape bounds , jtextcomponent c , view view ) { g . setcolor ( getcolor ( ) ) ; if ( offs0 == view . getstartoffset ( ) && offs1 == view . getendoffset ( ) ) { rectangle alloc ; if ( bounds instanceof rectangle ) alloc = ( rectangle ) bounds ; else alloc = bounds . getbounds ( ) ; paintsquiggle ( g , alloc ) ; return alloc ; } try { shape shape = view . modeltoview ( offs0 , position . bias . forward , offs1 , position . bias . backward , bounds ) ; rectangle r = ( shape instanceof rectangle ) ? ( rectangle ) shape : shape . getbounds ( ) ; paintsquiggle ( g , r ) ; return r ; } catch ( badlocationexception e ) { e . printstacktrace ( ) ; } return null ; }	paints a portion of a highlight .
public void addcontrolroll ( pilotingrolldata control ) { controlrolls . addelement ( control ) ; }	adds a pending control roll to the list for this phase .
void processaddonchanges ( window caller , addondependencychecker . addonchangesresult changes ) { if ( addonsdialog != null ) { addonsdialog . setdownloadingupdates ( ) ; } if ( getview ( ) != null ) { set < addon > addons = new hashset < > ( changes . getuninstalls ( ) ) ; addons . addall ( changes . getoldversions ( ) ) ; set < extension > extensions = new hashset < > ( ) ; extensions . addall ( changes . getunloadextensions ( ) ) ; extensions . addall ( changes . getsoftunloadextensions ( ) ) ; if ( ! warnunsavedresourcesoractiveactions ( caller , addons , extensions , _bool ) ) { return ; } } uninstalladdons ( caller , changes . getuninstalls ( ) , _bool ) ; set < addon > alladdons = new hashset < > ( changes . getnewversions ( ) ) ; alladdons . addall ( changes . getinstalls ( ) ) ; for ( addon addon : alladdons ) { if ( addonsdialog != null ) { addonsdialog . notifyaddondownloading ( addon ) ; } downloadaddon ( addon ) ; } }	processes the given add - on changes .
public void rederivecolor ( ) { color src = uimanager . getcolor ( uidefaultparentname ) ; if ( src != null ) { float [ ] tmp = color . rgbtohsb ( src . getred ( ) , src . getgreen ( ) , src . getblue ( ) , null ) ; tmp [ _num ] = clamp ( tmp [ _num ] + hoffset ) ; tmp [ _num ] = clamp ( tmp [ _num ] + soffset ) ; tmp [ _num ] = clamp ( tmp [ _num ] + boffset ) ; int alpha = clamp ( src . getalpha ( ) + aoffset ) ; argbvalue = ( color . hsbtorgb ( tmp [ _num ] , tmp [ _num ] , tmp [ _num ] ) & _num ) | ( alpha << _num ) ; } else { float [ ] tmp = new float [ _num ] ; tmp [ _num ] = clamp ( hoffset ) ; tmp [ _num ] = clamp ( soffset ) ; tmp [ _num ] = clamp ( boffset ) ; int alpha = clamp ( aoffset ) ; argbvalue = ( color . hsbtorgb ( tmp [ _num ] , tmp [ _num ] , tmp [ _num ] ) & _num ) | ( alpha << _num ) ; } }	recalculate the derived color from the uimanager parent color and offsets.
public static string tostring ( int [ ] oid ) { stringbuilder sb = new stringbuilder ( _num * oid . length ) ; for ( int i = _num ; i < oid . length - _num ; ++ i ) { sb . append ( oid [ i ] ) ; sb . append ( _str ) ; } sb . append ( oid [ oid . length - _num ] ) ; return sb . tostring ( ) ; }	returns string representation of oid.
public void onidlebegin ( ) { _idlecount . incrementandget ( ) ; }	called by the thread before going into the idle state .
private void addspan ( cachespan span ) { treeset < cachespan > spansforkey = cachedspans . get ( span . key ) ; if ( spansforkey == null ) { spansforkey = new treeset < cachespan > ( ) ; cachedspans . put ( span . key , spansforkey ) ; } spansforkey . add ( span ) ; totalspace += span . length ; notifyspanadded ( span ) ; }	adds a cached span to the in - memory representation .
public boolean equals ( object obj ) { if ( this == obj ) { return _bool ; } if ( ! ( obj instanceof uriname ) ) { return _bool ; } uriname other = ( uriname ) obj ; return uri . equals ( other . geturi ( ) ) ; }	compares this name with another , for equality .
void repaintchildren ( ) { for ( component child : panel . getcomponents ( ) ) { child . repaint ( ) ; } }	request repainting of all the child panels .
private void validatednsname ( string dnsname ) throws policyexception { int starindex = dnsname . indexof ( _str ) ; if ( ( starindex >= _num ) && ! dnsname . equals ( _str ) ) { if ( ( starindex > _num ) || ( ( starindex == _num ) && ( ( dnsname . indexof ( _str , _num ) != - _num ) || ( dnsname . charat ( _num ) != _str ) ) ) ) { string args [ ] = { dns_name , dnsname } ; throw new policyexception ( resbundleutils . rbname , _str , args , null ) ; } } }	validates a dns name for format.
private static string readcomment ( string input , int index ) { string comment = null ; matcher matcher = comment_pattern . matcher ( input . substring ( index ) ) ; if ( matcher . find ( ) ) { comment = matcher . group ( _num ) ; comment = comment . substring ( _num ) ; } return comment ; }	reads the first comment line from the input , and returns the comment line ( including the line break character ) without the leading " # " .
public static int findnext ( string str , char separator , char escapechar , int start , stringbuilder split ) { int numpreescapes = _num ; for ( int i = start ; i < str . length ( ) ; i ++ ) { char curchar = str . charat ( i ) ; if ( numpreescapes == _num && curchar == separator ) { return i ; } else { split . append ( curchar ) ; numpreescapes = ( curchar == escapechar ) ? ( ++ numpreescapes ) % _num : _num ; } } return - _num ; }	finds the first occurrence of the separator character ignoring the escaped separators starting from the index.
private static string guesscontenttype ( string url ) { url = url . tolowercase ( ) ; if ( url . endswith ( _str ) ) { return _str ; } else if ( url . endswith ( _str ) ) { return _str ; } else if ( url . matches ( _str ) ) { return _str ; } else if ( url . endswith ( _str ) ) { return _str ; } else if ( url . endswith ( _str ) ) { return _str ; } else { return _str ; } }	guess a content type from the url .
public static string extractcsvoutputlinedomain ( string csvout ) { string tokens [ ] = csvout . split ( _str , - _num ) ; return tokens [ _num ] ; }	used for testing - - input is a full csv line : < freq , domain , ip , ts , opt : generic >.
public void connect ( ) { connect ( this . logwriter ) ; }	connects to the currently configured system .
public static boolean docacheheadervalidation ( final solrqueryrequest solrreq , final httpservletrequest req , final method reqmethod , final httpservletresponse resp ) { if ( method . post == reqmethod || method . other == reqmethod ) { return _bool ; } final long lastmod = httpcacheheaderutil . calclastmodified ( solrreq ) ; final string etag = httpcacheheaderutil . calcetag ( solrreq ) ; resp . setdateheader ( _str , lastmod ) ; resp . setheader ( _str , etag ) ; if ( checketagvalidators ( req , resp , reqmethod , etag ) ) { return _bool ; } if ( checklastmodvalidators ( req , resp , lastmod ) ) { return _bool ; } return _bool ; }	sets http response cache validator headers appropriately and validates the http request against these using any conditional request headers.
public ivrzoneset showactiveivrzoneset ( ) throws networkdevicecontrollerexception { list < ivrzoneset > zonesets = showivrzonesets ( _bool ) ; return zonesets . isempty ( ) ? null : zonesets . get ( _num ) ; }	collect the active ivr zoneset , and its zones , members.
@ suppresswarnings ( _str ) public static < k > immutablearray < k > empty ( ) { return ( immutablearray < k > ) empty ; }	get an empty immutable array .
public void replacenonoptionalnonminusnodeswith ( final list < igroupmembernode > ordered , final boolean recomputedefinitelyproduced ) { nonoptionalnonminusnodes . clear ( ) ; nonoptionalnonminusnodes . addall ( ordered ) ; if ( recomputedefinitelyproduced ) { recomputedefinitelyproduced ( ) ; } }	the new ordered list of non - optional non - minus nodes.
public static string tostring ( accountable a ) { stringbuilder sb = new stringbuilder ( ) ; tostring ( sb , a , _num ) ; return sb . tostring ( ) ; }	returns a string description of an accountable and any nested resources.
@ override public int hashcode ( ) { return type << _num | value . hashcode ( ) << _num | othervalue . hashcode ( ) ; }	returns a hash code for this node .
protected void deletetypevertex ( atlasvertex instancevertex , datatypes . typecategory typecategory , boolean force ) throws atlasexception { switch ( typecategory ) { case struct : case trait : deletetypevertex ( instancevertex , force ) ; break ; case class : deleteentities ( collections . singletonlist ( instancevertex ) ) ; break ; default : throw new illegalstateexception ( _str + typecategory + _str ) ; } }	deletes a type vertex - can be entity ( class type ) or just vertex ( struct / trait type ).
public static list < string > readtolist ( reader r ) throws ioexception { try ( bufferedreader in = new bufferedreader ( r ) ) { list < string > l = new arraylist < > ( ) ; string line = null ; while ( ( line = in . readline ( ) ) != null ) l . add ( line ) ; return collections . unmodifiablelist ( l ) ; } }	read the reader line for line and return the result in a list.
@ suppresswarnings ( _str ) public void addcachecontext ( gridcachecontext cachectx ) throws ignitecheckedexception { if ( ctxmap . containskey ( cachectx . cacheid ( ) ) ) { gridcachecontext < k , v > existing = ctxmap . get ( cachectx . cacheid ( ) ) ; throw new ignitecheckedexception ( _str + _str + cachectx . name ( ) + _str + existing . name ( ) + _str ) ; } cachestoremanager mgr = cachectx . store ( ) ; if ( mgr . configured ( ) && mgr . islocal ( ) ) locstorecnt . incrementandget ( ) ; ctxmap . put ( cachectx . cacheid ( ) , cachectx ) ; }	adds cache context to shared cache context .
protected static boolean iscglibgetcallbacks ( annotatedmethod am ) { class < ? > rt = am . getrawtype ( ) ; if ( rt == null || ! rt . isarray ( ) ) { return _bool ; } class < ? > comptype = rt . getcomponenttype ( ) ; package pkg = comptype . getpackage ( ) ; if ( pkg != null ) { string pname = pkg . getname ( ) ; if ( pname . startswith ( _str ) || pname . startswith ( _str ) ) { return _bool ; } } return _bool ; }	this method was added to address [ jackson - 53 ] : need to weed out cglib - injected " getcallbacks ".
public int compareto ( namedmediatype other ) { return _name . compareto ( other . _name ) ; }	compares this namedmediatype to another .
public boolean ismodified ( ) { synchronized ( this ) { if ( _ischecking || _ismodified ) { return _ismodified ; } _ischecking = _bool ; } try { long now ; now = currenttime . currenttime ( ) ; if ( now < _lastchecktime + _checkinterval ) return _ismodified ; _lastchecktime = now ; for ( int i = _dependencylist . size ( ) - _num ; i >= _num ; i -- ) { dependency dependency = _dependencylist . get ( i ) ; if ( dependency . ismodified ( ) ) { dependency . logmodified ( log ( ) ) ; _ismodified = _bool ; return _ismodified ; } } return _ismodified ; } finally { _ischecking = _bool ; } }	returns true if the underlying dependencies have changed .
protected replacedelement newirreplaceableimageelement ( int csswidth , int cssheight ) { bufferedimage missingimage ; replacedelement mre ; try { missingimage = imageutil . createcompatiblebufferedimage ( csswidth , cssheight , bufferedimage . type_int_rgb ) ; graphics2d g = missingimage . creategraphics ( ) ; g . setcolor ( color . black ) ; g . setbackground ( color . white ) ; g . setfont ( new font ( _str , font . plain , _num ) ) ; g . drawstring ( _str , _num , _num ) ; g . dispose ( ) ; mre = new imagereplacedelement ( missingimage , csswidth , cssheight ) ; } catch ( exception e ) { mre = new emptyreplacedelement ( csswidth < _num ? _num : csswidth , cssheight < _num ? _num : cssheight ) ; } return mre ; }	returns a replacedelement for some element in the stream which should be replaceable , but is not.
public boolean greaterthan ( fxgversion version ) { return ( compareto ( version ) > _num ) ; }	compares whether this fxgversion ' s value is greater than the value of the version parameter .
@ override public datasource createdatasource ( properties properties ) throws sqlexception { properties propertiescopy = new properties ( ) ; if ( properties != null ) { propertiescopy . putall ( properties ) ; } rejectunsupportedoptions ( propertiescopy ) ; rejectpoolingoptions ( propertiescopy ) ; jdbcdatasource datasource = new jdbcdatasource ( ) ; setuph2datasource ( datasource , propertiescopy ) ; return datasource ; }	creates a basic data source .
public set < string > find ( t object ) { if ( ! locations . containskey ( object ) ) { locations . put ( object , new hashset < > ( ) ) ; } return collections . unmodifiableset ( locations . get ( object ) ) ; }	find the names of a given object .
private void scrollcurrentitemtocenter ( ) { final viewitem curritem = mviewitems [ buffer_center ] ; if ( curritem == null ) { return ; } final int currentviewcenter = curritem . getcenterx ( ) ; if ( mcontroller . isscrolling ( ) || misuserscrolling || iscurrentitemcentered ( ) ) { log . d ( tag , _str + mcontroller . isscrolling ( ) ) ; return ; } int snapintime = ( int ) ( snap_in_center_time_ms * ( ( float ) math . abs ( mcenterx - currentviewcenter ) ) / mdrawarea . width ( ) ) ; log . d ( tag , _str ) ; mcontroller . scrolltoposition ( currentviewcenter , snapintime , _bool ) ; }	keep the current item in the center.
public void addmetaobject ( metaobject object ) { for ( int k = _num ; k < metaobjects . size ( ) ; ++ k ) { if ( metaobjects . get ( k ) == null ) { metaobjects . set ( k , object ) ; return ; } } metaobjects . add ( object ) ; }	add a metaobject to the state .
public boolean remove ( string word ) { return m_words . remove ( word ) ; }	removes the word from the stopword list.
public void testcase12 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = _num ; int bsign = - _num ; byte rbytes [ ] = { - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . add ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , result . signum ( ) ) ; }	add two numbers of different length and sign.
public synchronized void addrecentitem ( t item ) { item = fromstring ( tostring ( item ) ) ; if ( m_recentitems . size ( ) > _num ) { if ( item . equals ( m_recentitems . get ( _num ) ) ) return ; } m_recentitems . remove ( item ) ; m_recentitems . add ( _num , item ) ; while ( m_recentitems . size ( ) > m_maxcount ) m_recentitems . remove ( m_recentitems . size ( ) - _num ) ; if ( m_ignorechanges ) return ; writeprops ( ) ; updatemenu ( ) ; notifyrecentitemlistenersofadd ( item ) ; }	adds the item to the internal list .
public void testinvokeall2 ( ) throws interruptedexception { executorservice e = new forkjoinpool ( _num ) ; poolcleaner cleaner = null ; try { cleaner = cleaner ( e ) ; list < future < string > > r = e . invokeall ( new arraylist < callable < string > > ( ) ) ; asserttrue ( r . isempty ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }	invokeall ( empty collection ) returns empty collection.
public void cfgpackage ( configurationvalue cfgval , string name , string desc ) { packages . add ( new packageinfo ( name , desc ) ) ; packagenames . add ( name ) ; }	assigns description to a package.
@ override public void close ( ) throws ioexception { input . close ( ) ; }	closes this stream . this implementation closes the source stream .
private void createblockmirrordata ( string name , int numblockmirrors ) throws exception { volume volume = new volume ( ) ; uri volumeuri = uriutil . createid ( volume . class ) ; testvolumeuris . add ( volumeuri ) ; volume . setid ( volumeuri ) ; volume . setlabel ( _str ) ; uri cguri = createblockconsistencygroup ( _str ) ; volume . setconsistencygroup ( cguri ) ; _dbclient . createobject ( volume ) ; for ( int i = _num ; i <= numblockmirrors ; i ++ ) { blockmirror blockmirror = new blockmirror ( ) ; uri blockmirroruri = uriutil . createid ( blockmirror . class ) ; testblockmirroruris . add ( blockmirroruri ) ; blockmirror . setid ( blockmirroruri ) ; blockmirror . setlabel ( name + i ) ; blockmirror . setconsistencygroup ( cguri ) ; _dbclient . createobject ( blockmirror ) ; } }	creates the blockobject blockmirror data .
@ override public synchronized void start ( ) { if ( running ) { return ; } logger . info ( _str ) ; if ( endpoints . isempty ( ) ) { int port = config . getint ( networkconfig . keys . coap_port ) ; logger . log ( level . info , _str , port ) ; addendpoint ( new coapendpoint ( port , this . config ) ) ; } int started = _num ; for ( endpoint ep : endpoints ) { try { ep . start ( ) ; ++ started ; } catch ( ioexception e ) { logger . log ( level . severe , _str + ep . getaddress ( ) + _str , e ) ; } } if ( started == _num ) { throw new illegalstateexception ( _str ) ; } else { running = _bool ; } }	starts the server by starting all endpoints this server is assigned to.
public boolean retainall ( abstractfloatlist other ) { if ( other . size ( ) == _num ) { if ( size == _num ) return _bool ; setsize ( _num ) ; return _bool ; } int limit = other . size ( ) - _num ; int j = _num ; for ( int i = _num ; i < size ; i ++ ) { if ( other . indexoffromto ( getquick ( i ) , _num , limit ) >= _num ) setquick ( j ++ , getquick ( i ) ) ; } boolean modified = ( j != size ) ; setsize ( j ) ; return modified ; }	retains ( keeps ) only the elements in the receiver that are contained in the specified other list.
@ override public void exceptioncaught ( iosession session , throwable cause ) { final iosessioninputstream in = ( iosessioninputstream ) session . getattribute ( key_in ) ; ioexception e = null ; if ( cause instanceof streamioexception ) { e = ( ioexception ) cause . getcause ( ) ; } else if ( cause instanceof ioexception ) { e = ( ioexception ) cause ; } if ( e != null && in != null ) { in . throwexception ( e ) ; } else { logger . warn ( _str , cause ) ; session . close ( _bool ) ; } }	forwards caught exceptions to input stream .
protected void clearresult ( ) { md . clearresult ( ) ; localizationresult . settext ( _str ) ; }	clears the result that may has been set .
public static < t > string tostring ( collection < t > collection ) { if ( collection == null ) { return _str ; } if ( collection . isempty ( ) ) { return _str ; } stringbuilder buf = new stringbuilder ( ) ; string delimiter = _str ; for ( t t : collection ) { if ( t == null ) { continue ; } buf . append ( delimiter ) ; buf . append ( t ) ; delimiter = _str ; } return buf . tostring ( ) ; }	returns a list of the elements invoking tostring on non - null elements .
public static float between ( float val , float min , float max ) { return math . max ( math . min ( val , max ) , min ) ; }	check if value within allowed range .
public static stringbuffer replacestring ( stringbuffer buffer , string [ ] parameters ) { int placeholderposition = - _num ; string placeholder = null ; for ( int i = _num ; i < parameters . length ; i ++ ) { if ( parameters [ i ] == null ) { break ; } placeholder = _str + ( i + _num ) + _str ; placeholderposition = buffer . indexof ( placeholder ) ; if ( placeholderposition != - _num ) { buffer . replace ( placeholderposition , placeholderposition + placeholder . length ( ) , parameters [ i ] ) ; } else { break ; } } return buffer ; }	replaces the place holders by parameters.
private static int lookupqualselector ( xmpnode arraynode , string qualname , string qualvalue , int aliasform ) throws xmpexception { if ( xml_lang . equals ( qualname ) ) { qualvalue = utils . normalizelangvalue ( qualvalue ) ; int index = xmpnodeutils . lookuplanguageitem ( arraynode , qualvalue ) ; if ( index < _num && ( aliasform & aliasoptions . prop_array_alt_text ) > _num ) { xmpnode langnode = new xmpnode ( array_item_name , null ) ; xmpnode xdefault = new xmpnode ( xml_lang , x_default , null ) ; langnode . addqualifier ( xdefault ) ; arraynode . addchild ( _num , langnode ) ; return _num ; } else { return index ; } } else { for ( int index = _num ; index < arraynode . getchildrenlength ( ) ; index ++ ) { xmpnode curritem = arraynode . getchild ( index ) ; for ( iterator it = curritem . iteratequalifier ( ) ; it . hasnext ( ) ; ) { xmpnode qualifier = ( xmpnode ) it . next ( ) ; if ( qualname . equals ( qualifier . getname ( ) ) && qualvalue . equals ( qualifier . getvalue ( ) ) ) { return index ; } } } return - _num ; } }	searches for a qualifier selector in a node : [ ? qualname = " value " ] - an element in an array , chosen by a qualifier value.
public boolean ismultipleallowed ( string frameid ) { return multipleframes . contains ( frameid ) ; }	are multiple occurrences of frame allowed.
public string [ ] parseconfiguration ( file xmlfile ) throws saxexception , ioexception { document document = builder . parse ( xmlfile ) ; return ( parseconfiguration ( document ) ) ; }	parse an xml configuration from a file.
public void create ( string [ ] rpffilepaths , string outputfile ) throws maketocexception { create ( rpffilepaths , outputfile , _bool ) ; }	create a a . toc file specificed by the frame file list , at the location specified .
private synchronized void postevent ( eventinfo eventinfo ) { eventqueue . add ( eventinfo ) ; notifyall ( ) ; }	queue the given event in the event queue .
public string chooseserveralias ( string keytype , principal [ ] issuers , socket sock ) { return sunx509keymanager . chooseserveralias ( keytype , issuers , sock ) ; }	choose an alias to authenticate the server side of a secure socket given the public key type and the list of certificate issuer authorities recognized by the peer ( if any ) .
private void processbmpimage ( bufferedimage image ) { if ( ! iserror ) { file outputfile = new file ( path , prefix + ( numpage + _num ) + _str ) ; try { imageio . write ( image , _str , outputfile ) ; addtempfile ( outputfile ) ; addscanfile ( outputfile ) ; numpage ++ ; } catch ( ioexception e ) { e . printstacktrace ( ) ; endprocess ( _bool , _bool ) ; } } }	procesa el escaneo de una imagen en modo nativo.
public pathhandler ( string path ) { this ( paths . get ( path ) ) ; }	convenience method to create a path.
public boolean loadlines ( ) { boolean result = _bool ; try { m_parser . parse ( new inputsource ( m_reader ) , this ) ; result = _bool ; m_success = _bool ; } catch ( saxexception e ) { m_errormessage = _str ; m_errordescription = e . getmessage ( ) ; } catch ( ioexception e ) { m_errormessage = _str ; m_errordescription = e . getmessage ( ) ; } return result ; }	read statementlines from inputstream .
private void loadignorefile ( final string srcfolder ) { ignorefile = ignorefile . load ( srcfolder ) ; if ( ignorefile == null ) { loaddefaultexcludepattern ( srcfolder ) ; } }	load ignore file using.
public boolean removearg ( final bop arg ) { if ( arg == null ) throw new illegalargumentexception ( ) ; if ( arg == this ) throw new illegalargumentexception ( ) ; if ( args . remove ( arg ) ) { mutation ( ) ; return _bool ; } return _bool ; }	remove the 1st occurrence of the argument ( core mutation method ) .
public static boolean lookslikealiststyletype ( string val ) { return list_types . indexof ( val ) >= _num ; }	description of the method.
public pkcs10attribute ( pkcs9attribute attr ) { this . attributeid = attr . getoid ( ) ; this . attributevalue = attr . getvalue ( ) ; }	constructs an attribute from pkcs9 attribute .
public void createnote ( note note ) { sqlitedatabase db = getwritabledatabase ( ) ; string spannableashtml = html . tohtml ( note . getspannable ( ) ) ; string date = dt . format ( new date ( ) ) ; contentvalues values = new contentvalues ( ) ; values . put ( key_spannable_note , spannableashtml ) ; values . put ( key_note_title , note . gettitle ( ) ) ; values . put ( key_image , bitmapconverter . getbytes ( note . getimage ( ) ) ) ; values . put ( key_date_updated , date ) ; db . insert ( table_notes , null , values ) ; db . close ( ) ; }	method used to put note object into database.
void verifyuniquexids ( list < ofmessage > msgs ) { if ( seenxids == null ) seenxids = new hashset < long > ( ) ; for ( ofmessage m : msgs ) { long xid = m . getxid ( ) ; asserttrue ( _str , xid != _num ) ; assertfalse ( _str + xid + _str , seenxids . contains ( xid ) ) ; seenxids . add ( xid ) ; } }	make sure that the transaction ids in the given messages are not 0 and differ between each other.
void addnext ( node < t > n ) { nextnodes . add ( n ) ; collections . sort ( nextnodes , isvertical ? verticalcomparator : horizontalcomparator ) ; }	adds a " next " node ( node to the right or bottom ) to this divider ' s list of next nodes .
protected void configdialogpropertychange ( propertychangeevent event ) { log . debug ( _str ) ; firepropertychange ( propertychangeid . config_change , event . getoldvalue ( ) , event . getnewvalue ( ) ) ; }	callback for the config dialog.
public final string readutf ( ) throws ioexception { return decodeutf ( readunsignedshort ( ) ) ; }	see the general contract of the readutf method of datainput.
private void myadd ( linkedlist < integer > l , int i ) { l . add ( i ) ; }	for debugging purposes , it ' s useful to insert print statements here .
private void resetstateforgridtop ( ) { final int colcount = mcolcount ; if ( mitemtops == null || mitemtops . length != colcount ) { mitemtops = new int [ colcount ] ; mitembottoms = new int [ colcount ] ; } final int top = getpaddingtop ( ) ; arrays . fill ( mitemtops , top ) ; arrays . fill ( mitembottoms , top ) ; mfirstposition = _num ; if ( mrestoreoffsets != null ) arrays . fill ( mrestoreoffsets , _num ) ; }	reset all internal state to be at the top of the grid .
public string testnexttoken ( ) throws ioexception { token t = super . nexttoken ( ) ; return integer . tostring ( t . type ) + _str + t . content + _str ; }	calls super . nexttoken ( ) and prints out a string representation of token type and content .
public static repaintmanager currentmanager ( component c ) { return currentmanager ( appcontext . getappcontext ( ) ) ; }	return the repaintmanager for the calling thread given a component .
private boolean isrecoverpointinitiator ( string portwwn ) { return portwwn . contains ( recoverpoint_initiator_prefix ) ; }	determines if the given port wwn is a recoverpoint initiator .
protected boolean iswfxmlchar ( string chardata , character refinvalidchar ) { if ( chardata == null || ( chardata . length ( ) == _num ) ) { return _bool ; } char [ ] dataarray = chardata . tochararray ( ) ; int datalength = dataarray . length ; if ( fisxmlversion11 ) { int i = _num ; while ( i < datalength ) { if ( xml11char . isxml11invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - _num ] ; if ( xmlchar . ishighsurrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if ( xmlchar . islowsurrogate ( ch2 ) && xmlchar . issupplemental ( xmlchar . supplemental ( ch , ch2 ) ) ) { continue ; } } refinvalidchar = new character ( ch ) ; return _bool ; } } } else { int i = _num ; while ( i < datalength ) { if ( xmlchar . isinvalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - _num ] ; if ( xmlchar . ishighsurrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if ( xmlchar . islowsurrogate ( ch2 ) && xmlchar . issupplemental ( xmlchar . supplemental ( ch , ch2 ) ) ) { continue ; } } refinvalidchar = new character ( ch ) ; return _bool ; } } } return _bool ; }	checks if a xml character is well - formed.
@ override public void send ( buffer buffer ) { _outproxy . write ( _outwriter , buffer , _bool ) ; }	initialization when the websocket completes .
@ override public boolean eisset ( int featureid ) { switch ( featureid ) { case eippackage . route__owned_endpoints : return ownedendpoints != null && ! ownedendpoints . isempty ( ) ; case eippackage . route__owned_channels : return ownedchannels != null && ! ownedchannels . isempty ( ) ; case eippackage . route__name : return name_edefault == null ? name != null : ! name_edefault . equals ( name ) ; case eippackage . route__exchange_type : return exchangetype != exchange_type_edefault ; } return super . eisset ( featureid ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
public void removeclickinglistener ( onwheelclickedlistener listener ) { clickinglisteners . remove ( listener ) ; }	removes wheel clicking listener.
public void addsection ( final section section ) { if ( null == section ) return ; sections . add ( section ) ; collections . sort ( sections , new sectioncomparator ( ) ) ; fireupdateevent ( section_event ) ; }	adds the given section to the list of sections.
private int calculatepreferredwrapposition ( @ notnull editor editor , @ notnull charsequence text , int tabsize , int spacesize , int startlineoffset , int endlineoffset , int targetrangeendoffset ) { boolean hastabs = _bool ; boolean canoptimize = _bool ; boolean hasnonspacesymbols = _bool ; loop : for ( int i = startlineoffset ; i < math . min ( endlineoffset , targetrangeendoffset ) ; i ++ ) { char c = text . charat ( i ) ; switch ( c ) { case _str : { hastabs = _bool ; if ( hasnonspacesymbols ) { canoptimize = _bool ; break loop ; } } case _str : break ; default : hasnonspacesymbols = _bool ; } } if ( ! hastabs ) { return wrappositionfortextwithouttabs ( startlineoffset , endlineoffset , targetrangeendoffset ) ; } else if ( canoptimize ) { return wrappositionfortabbedtextwithoptimization ( text , tabsize , startlineoffset , endlineoffset , targetrangeendoffset ) ; } else { return wrappositionfortabbedtextwithoutoptimization ( editor , text , spacesize , startlineoffset , endlineoffset , targetrangeendoffset ) ; } }	checks if it ' s worth to try to wrap target line ( it ' s long enough ) and tries to calculate preferred wrap position .
public void addall ( ovector v ) { expandfor ( size + v . size - _num , null ) ; system . arraycopy ( v . vector , _num , vector , size - v . size , v . size ) ; }	adds all the values in the given vector to the end of this vector , expanding its capacity as necessary .
public static void pipeall ( inputstream instr , outputstream outstr ) throws ioexception { byte [ ] bs = new byte [ buffer_size ] ; int numread ; while ( ( numread = instr . read ( bs , _num , bs . length ) ) >= _num ) { outstr . write ( bs , _num , numread ) ; } }	write the full contents of instr to the destination stream outstr .
public void addrule ( string ruleexpression , t resultifmatched ) { mrulemap . add ( new mimematcherrule ( ruleexpression , resultifmatched ) ) ; }	add a matching rule in the canonical mime t form such as " image / * " or a mime t literal such as " text / html " .
protected abstract boolean validatenumber ( conversationcontext context , number input ) ;	validates a number , for use cases where you may need the number to be within a range.
public void sendmessageuntilstopcount ( int stopcount ) { for ( int i = processedworkercount ; i < workers . size ( ) ; ++ i ) { actorref worker = workers . get ( i ) ; try { thread . sleep ( _num ) ; } catch ( interruptedexception e ) { logger . error ( _str + e + _str , e ) ; } worker . tell ( operationworkermsgtype . process_request , originalmanager ) ; processedworkercount ++ ; if ( processedworkercount > stopcount ) { return ; } logger . debug ( _str , processedworkercount , requesttotalcount , taskidtrim ) ; } }	note that if there is sleep in this method .
public static arraylist < string > stringtoarraylist ( string string ) { return new arraylist < > ( arrays . aslist ( string . split ( _str ) ) ) ; }	make arraylist from " , " separated string.
private string pickcharset ( ) { if ( charset != null ) { return charset ; } else if ( utf8supported ) { return _str ; } else { return system . getproperty ( _str ) ; } }	returns the name of the charset that should be used in textual transmissions .
public void testtoengineeringstringpos ( ) { string a = _str ; bigdecimal anumber = new bigdecimal ( a ) ; string result = _str ; assertequals ( _str , result , anumber . toengineeringstring ( ) ) ; }	convert a positive bigdecimal to an engineering string representation.
@ override public void clear ( ) { if ( elementcount > _num ) { elementcount = _num ; arrays . fill ( elementdata , null ) ; modcount ++ ; } }	removes all mappings from this hash map , leaving it empty .
public void addlayer ( final layerdefinition layer ) { layer . setmap ( this ) ; layers . add ( layer ) ; }	adds a new layer to the map .
private list < rule > readrules ( reader reader ) throws ioexception , illegalargumentexception { bufferedreader in = new bufferedreader ( reader ) ; list < rule > rules = new arraylist < rule > ( ) ; string line ; while ( ( line = in . readline ( ) ) != null ) { if ( line . length ( ) == _num ) { continue ; } line = line . trim ( ) ; char first = line . charat ( _num ) ; boolean sign = _bool ; switch ( first ) { case _str : sign = _bool ; break ; case _str : sign = _bool ; break ; case _str : case _str : case _str : continue ; default : throw new ioexception ( _str + line ) ; } string regex = line . substring ( _num ) ; if ( log . istraceenabled ( ) ) { log . trace ( _str + regex + _str ) ; } rule rule = createrule ( sign , regex ) ; rules . add ( rule ) ; } return rules ; }	read the specified file of rules .
@ suppresswarnings ( _str ) @ override protected object applyupdatestomanageddata ( object updates ) { boolean madechanges = _bool ; list < string > words = ( list < string > ) updates ; log . info ( _str + words ) ; boolean ignorecase = getignorecase ( ) ; for ( string word : words ) { if ( ignorecase ) word = word . tolowercase ( locale . root ) ; if ( managedwords . add ( word ) ) { madechanges = _bool ; log . info ( _str , word ) ; } } return madechanges ? managedwords : null ; }	applies updates to the word set being managed by this resource .
@ override public void write ( char c [ ] , int off , int len ) { if ( ( off < _num ) || ( off > c . length ) || ( len < _num ) || ( ( off + len ) > c . length ) || ( ( off + len ) < _num ) ) { throw new indexoutofboundsexception ( ) ; } else if ( len == _num ) { return ; } int newcount = count + len ; if ( newcount > buf . length ) { buf = arrays . copyof ( buf , math . max ( buf . length << _num , newcount ) ) ; } system . arraycopy ( c , off , buf , count , len ) ; count = newcount ; }	writes characters to the buffer .
@ deprecated public static episodematchingresult detectepisodefromfilename ( file file ) { logger . debug ( _str + file . getname ( ) ) ; episodematchingresult result = new episodematchingresult ( ) ; string filename = file . getname ( ) ; result = parsestring ( filename ) ; collections . sort ( result . episodes ) ; matcher matcher = stackingmarkerpattern . matcher ( result . name ) ; result . stackingmarkerfound = matcher . matches ( ) ; logger . debug ( _str + result ) ; return result ; }	detect episode from filename .
public static typedoperation createarraycreation ( arraytype arraytype ) { list < type > typelist = new arraylist < > ( ) ; typelist . add ( javatypes . int_type ) ; typetuple inputtypes = new typetuple ( typelist ) ; return new typedtermoperation ( new arraycreation ( arraytype ) , inputtypes , arraytype ) ; }	creates a simple array creation operation for the given type .
public void fireevent ( final sparqlupdateevent e ) { if ( isreadonly ( ) ) throw new unsupportedoperationexception ( ) ; if ( e == null ) throw new illegalargumentexception ( ) ; if ( listeners . isempty ( ) ) { return ; } final isparqlupdatelistener [ ] a = listeners . toarray ( new isparqlupdatelistener [ _num ] ) ; for ( isparqlupdatelistener l : a ) { final isparqlupdatelistener listener = l ; try { listener . updateevent ( e ) ; } catch ( throwable t ) { if ( innercause . isinnercause ( t , interruptedexception . class ) ) { throw new runtimeexception ( t ) ; } log . error ( t , t ) ; } } }	send an event to all registered listeners .
public preferencebuilder < preferenceclass > preftype ( class < preferenceclass > preftype ) { if ( ! valid_types . contains ( preftype ) ) { throw new illegalargumentexception ( _str + preftype + _str ) ; } this . preftype = preftype ; return this ; }	the type of preference to retrieve.
private void expungestaleentries ( ) { for ( object x ; ( x = queue . poll ( ) ) != null ; ) { synchronized ( queue ) { @ suppresswarnings ( _str ) entry < k , v > e = ( entry < k , v > ) x ; int i = indexfor ( e . hash , table . length ) ; entry < k , v > prev = table [ i ] ; entry < k , v > p = prev ; while ( p != null ) { entry < k , v > next = p . next ; if ( p == e ) { if ( prev == e ) table [ i ] = next ; else prev . next = next ; e . value = null ; size -- ; break ; } prev = p ; p = next ; } } } }	expunges stale entries from the table .
protected boolean isnumeric ( string text ) { text = text . trim ( ) ; int tlen = text . length ( ) ; for ( int i = _num ; i < tlen ; i ++ ) { if ( character . isdigit ( text . charat ( i ) ) == _bool ) { return _bool ; } } return _bool ; }	utility method for subclasses to determine if an entire string is digits.
public static boolean ischar ( string desc ) { return desc . endswith ( _str ) ; }	tells whether a given type is a char.
public rsapublickeyimpl ( byte [ ] encoded ) throws invalidkeyexception { decode ( encoded ) ; rsakeyfactory . checkrsaproviderkeylengths ( n . bitlength ( ) , e ) ; }	construct a key from its encoding.
date todate ( calendar calendar ) { return calendar . gettime ( ) ; }	convert a calendar to a java.
public boolean isclientauthentication ( ) { return clientauthentication ; }	returns a boolean flag to determine if this message will be sent to a server that requires client authentication .
private jpanel createimagefilepanel ( ) { jpanel panel = new jpanel ( ) ; panel . setlayout ( new boxlayout ( panel , boxlayout . x_axis ) ) ; panel . add ( imagefilename ) ; panel . add ( box . createhorizontalstrut ( _num ) ) ; panel . add ( new jbutton ( openimagefile ) ) ; return panel ; }	create and return the image file panel .
void writeline ( bufferedwriter writer , string line ) throws ioexception { writer . write ( line ) ; writer . newline ( ) ; }	writes the given line with the given writer , followed by a new line .
public layer childat ( int index ) { return children . get ( index ) ; }	returns the layer at the specified index.
private static void checkpermission ( ) { securitymanager security = system . getsecuritymanager ( ) ; if ( security != null ) security . checkpermission ( modifythreadpermission ) ; }	if there is a security manager , makes sure caller has permission to modify threads .
public static function < value , value > ofvalue ( ) { return value ; }	the identity function for value conversion - returns the value untouched .
public static string removequotes ( string s ) { if ( s == null ) { return null ; } string trimmed = s . trim ( ) ; if ( trimmed . length ( ) == _num ) { return trimmed ; } int i = nextnonquoteindex ( trimmed , _num , _bool ) ; int j = nextnonquoteindex ( trimmed , trimmed . length ( ) - _num , _bool ) ; return trimmed . substring ( i , j + _num ) ; }	trims white spaces and remove quotes from the string .
public static boolean isdefinednsdecl ( serializationhandler serializer , int attr , dtm dtm ) { if ( dtm . namespace_node == dtm . getnodetype ( attr ) ) { string prefix = dtm . getnodenamex ( attr ) ; string uri = serializer . getnamespaceurifromprefix ( prefix ) ; if ( ( null != uri ) && uri . equals ( dtm . getstringvalue ( attr ) ) ) return _bool ; } return _bool ; }	returns whether a namespace is defined.
public void testuserdatahandlernotifiedofshallowclones ( ) { recordinghandler handler = new recordinghandler ( ) ; name . setuserdata ( _str , _str , handler ) ; name . setuserdata ( _str , _str , handler ) ; standard . setuserdata ( _str , _str , handler ) ; waffles . setuserdata ( _str , _str , handler ) ; element clonedname = ( element ) name . clonenode ( _bool ) ; attr clonedstandard = clonedname . getattributenode ( _str ) ; set < string > expected = new hashset < string > ( ) ; expected . add ( notification ( node_cloned , _str , _str , name , clonedname ) ) ; expected . add ( notification ( node_cloned , _str , _str , name , clonedname ) ) ; expected . add ( notification ( node_cloned , _str , _str , standard , clonedstandard ) ) ; assertequals ( expected , handler . calls ) ; }	a shallow clone requires cloning the attributes but not the child nodes .
public dbasicconstraints ( jdialog parent , byte [ ] value ) throws ioexception { super ( parent ) ; settitle ( res . getstring ( _str ) ) ; initcomponents ( ) ; prepopulatewithvalue ( value ) ; }	creates a new dbasicconstraints dialog .
private static int lastindexof ( object o , object [ ] elements , int index ) { if ( o == null ) { for ( int i = index ; i >= _num ; i -- ) if ( elements [ i ] == null ) return i ; } else { for ( int i = index ; i >= _num ; i -- ) if ( o . equals ( elements [ i ] ) ) return i ; } return - _num ; }	static version of lastindexof .
public floatcolumn ( int nrows , int capacity , float defaultvalue ) { super ( float . class , new float ( defaultvalue ) ) ; if ( capacity < nrows ) { throw new illegalargumentexception ( _str ) ; } m_values = new float [ capacity ] ; arrays . fill ( m_values , defaultvalue ) ; m_size = nrows ; }	create a new floatcolumn .
void readprj ( ) throws ioexception { while ( _bool ) { string s = isr . readline ( ) ; if ( s == null ) return ; if ( s . startswith ( _str ) ) return ; } }	read prj records ( in fact does nothing ).
private void purgeone ( ) { synchronized ( queue ) { weakkey key = ( weakkey ) queue . poll ( ) ; if ( key != null ) { super . remove ( key . getreferenced ( ) ) ; } } }	purges one entry whose wrapped key has been garbage collected .
private void checkalterperiodconverters ( ) throws securityexception { securitymanager sm = system . getsecuritymanager ( ) ; if ( sm != null ) { sm . checkpermission ( new jodatimepermission ( _str ) ) ; } }	checks whether the user has permission ' convertermanager.
public boolean equals ( final artifactcoordinates obj ) { return this == obj || obj != null && groupid . equals ( obj . groupid ) && artifactid . equals ( obj . artifactid ) && version . equals ( obj . version ) && classifier . equals ( obj . classifier ) ; }	determine whether this coordinates object equals the target object .
private void checkmatrixdimensions ( matrix b ) { if ( b . m != m || b . n != n ) { throw new illegalargumentexception ( _str ) ; } }	check if size ( a ) = = size ( b ).
public void importfromchange ( change sourcechange ) { if ( sourcechange . revision ( ) > _num ) { this . revisionid = new numericliteralimpl ( sourcechange . revision ( ) ) ; } if ( sourcechange . timestamp ( ) != null ) { date date = sourcechange . timestamp ( ) ; calendar c = calendar . getinstance ( timezone . gettimezone ( _str ) , locale . root ) ; c . settime ( date ) ; this . lastmodified = new literalimpl ( datatypeconverter . printdate ( c ) , xmlschema . datetime ) ; } }	import revision data from change object .
protected printwriter linefileout ( document doc ) { return linefileout ; }	selects output line file by written doc.
@ override public query newfuzzyquery ( string text , int fuzziness ) { if ( settings . lowercaseexpandedterms ( ) ) { text = text . tolowercase ( settings . locale ( ) ) ; } booleanquery . builder bq = new booleanquery . builder ( ) ; bq . setdisablecoord ( _bool ) ; for ( map . entry < string , float > entry : weights . entryset ( ) ) { try { query q = new fuzzyquery ( new term ( entry . getkey ( ) , text ) , fuzziness ) ; q . setboost ( entry . getvalue ( ) ) ; bq . add ( q , booleanclause . occur . should ) ; } catch ( runtimeexception e ) { rethrowunlesslenient ( e ) ; } } return super . simplify ( bq . build ( ) ) ; }	dispatches to lucene ' s simplequeryparser ' s newfuzzyquery , optionally lowercasing the term first.
public callchaininfo ( sootmethod m , stmt s , string type ) { this . type = type ; this . link = _str ; this . method = m ; this . stmt = s ; calls = _num ; if ( type . equals ( _str ) ) syscalls = _num ; }	creates a call from stmt s to sootmethod m.
public void startplayback ( ) { log . d ( tag , _str ) ; if ( null == mrecordfile ) { log . e ( tag , _str ) ; return ; } mplayer = new mediaplayer ( ) ; try { mplayer . setdatasource ( mrecordfile . getabsolutepath ( ) ) ; log . d ( tag , _str + mrecordfile . getabsolutepath ( ) + _str ) ; mplayer . setoncompletionlistener ( this ) ; mplayer . setonerrorlistener ( this ) ; mplayer . prepare ( ) ; log . d ( tag , _str ) ; mplayer . start ( ) ; } catch ( ioexception e ) { log . e ( tag , _str + e ) ; seterror ( error_player_internal ) ; return ; } catch ( illegalargumentexception e ) { log . e ( tag , _str + e ) ; seterror ( error_player_internal ) ; return ; } catch ( securityexception e ) { log . e ( tag , _str + e ) ; seterror ( error_player_internal ) ; return ; } catch ( illegalstateexception e ) { log . e ( tag , _str + e ) ; seterror ( error_player_internal ) ; return ; } setstate ( state_playback ) ; log . d ( tag , _str ) ; }	play current recorded file , if failed notify error message to caller , if success update fm recorder state.
public static void notempty ( string string , string msg ) { if ( string == null || string . length ( ) == _num ) throw new illegalargumentexception ( msg ) ; }	validates that the string is not empty.
public static void resetcontext ( ) { contexts . set ( null ) ; }	resets the current context.
public static object converttoparametervalues ( object object ) { collection < object > collection ; if ( object instanceof object [ ] ) { collection = arrays . aslist ( ( object [ ] ) object ) ; } else if ( object instanceof collection ) { collection = ( collection < object > ) object ; } else { logger . warn ( _str ) ; return new object [ ] { } ; } list < object > s = new linkedlist < object > ( ) ; for ( object o : collection ) { object converted = converttoparametervalue ( o ) ; if ( converted instanceof object [ ] ) { s . addall ( arrays . aslist ( ( object [ ] ) converted ) ) ; } else { s . add ( converted ) ; } } return s . toarray ( new object [ s . size ( ) ] ) ; }	converts an array / collection of values ( the object ) to a parameter values array.
public boolean logoutuser ( string username , httpservletrequest req ) { return logoutuser ( username , req , _bool , _bool ) ; }	basic internal api call to authsvc to logout a user .
public static operation createoperationtoupdateorcreatenetworkinterface ( computestate existingcomputestate , networkinterfacestate networkinterface , list < string > tenantlinks , statelessservice service , boolean ispublic ) { string existinginterfacelink = getexistingnetworkinterfacelink ( existingcomputestate , ispublic ) ; operation networkinterfaceoperation = null ; if ( existinginterfacelink == null ) { networkinterfaceoperation = createpostoperation ( service , networkinterface , networkinterfaceservice . factory_link ) ; } else { networkinterfaceoperation = createpatchoperation ( service , networkinterface , existinginterfacelink ) ; } return networkinterfaceoperation ; }	compares the ip addresses of the instance on aws and maps those to the network interfaces in the system.
public codesourcefacade ( final codesource codesource ) { this . location = codesource . getlocation ( ) ; final certificate [ ] certificates = codesource . getcertificates ( ) ; if ( null == certificates || _num == certificates . length ) { logger . warning ( string . format ( _str , codesource ) ) ; this . firstcertificate = null ; return ; } this . firstcertificate = ( x509certificate ) certificates [ _num ] ; }	creates a new code source .
public jdpbroadcaster ( inetaddress address , inetaddress srcaddress , int port , int ttl ) throws ioexception , jdpexception { this . addr = address ; this . port = port ; protocolfamily family = ( address instanceof inet6address ) ? standardprotocolfamily . inet6 : standardprotocolfamily . inet ; channel = datagramchannel . open ( family ) ; channel . setoption ( standardsocketoptions . so_reuseaddr , _bool ) ; channel . setoption ( standardsocketoptions . ip_multicast_ttl , ttl ) ; if ( srcaddress != null ) { networkinterface interf = networkinterface . getbyinetaddress ( srcaddress ) ; try { channel . bind ( new inetsocketaddress ( srcaddress , _num ) ) ; } catch ( unsupportedaddresstypeexception ex ) { throw new jdpexception ( _str ) ; } channel . setoption ( standardsocketoptions . ip_multicast_if , interf ) ; } }	create a new broadcaster.
public void close ( ) throws ioexception { rrdfile . close ( ) ; }	closes this database stream and releases any associated system resources .
public vector rotateindegree ( double degree ) { return rotateinradian ( math . toradians ( degree ) ) ; }	return a new instance of vector rotated from the given number of degrees .
public static string tostring ( final uri uri , final charset encoding ) throws ioexception { return ioutils . tostring ( uri . tourl ( ) , charsets . tocharset ( encoding ) ) ; }	gets the contents at the given uri .
public void put ( int fieldnumber , fielddata data ) { int i = binarysearch ( fieldnumber ) ; if ( i >= _num ) { mdata [ i ] = data ; } else { i = ~ i ; if ( i < msize && mdata [ i ] == deleted ) { mfieldnumbers [ i ] = fieldnumber ; mdata [ i ] = data ; return ; } if ( mgarbage && msize >= mfieldnumbers . length ) { gc ( ) ; i = ~ binarysearch ( fieldnumber ) ; } if ( msize >= mfieldnumbers . length ) { int n = idealintarraysize ( msize + _num ) ; int [ ] nkeys = new int [ n ] ; fielddata [ ] nvalues = new fielddata [ n ] ; system . arraycopy ( mfieldnumbers , _num , nkeys , _num , mfieldnumbers . length ) ; system . arraycopy ( mdata , _num , nvalues , _num , mdata . length ) ; mfieldnumbers = nkeys ; mdata = nvalues ; } if ( msize - i != _num ) { system . arraycopy ( mfieldnumbers , i , mfieldnumbers , i + _num , msize - i ) ; system . arraycopy ( mdata , i , mdata , i + _num , msize - i ) ; } mfieldnumbers [ i ] = fieldnumber ; mdata [ i ] = data ; msize ++ ; } }	adds a mapping from the specified fieldnumber to the specified data , replacing the previous mapping if there was one .
void hideborder ( ) { insets insets = getinsets ( ) ; setborder ( borderfactory . createemptyborder ( insets . top , insets . left , insets . bottom , insets . right ) ) ; }	hide the special border of the title bar .
public void remove ( string btxn ) { synchronized ( filtermap ) { filterprocessor oldfp = filtermap . get ( btxn ) ; if ( oldfp != null ) { globalexclusionfilters . remove ( oldfp ) ; btxnfilters . remove ( oldfp ) ; } } }	this method removes the business transaction .
public void add ( double weight , double x , double y ) { observations . add ( new weightedobservedpoint ( weight , x , y ) ) ; }	adds a point to the sample .
public boolean addtagid ( final long tagid ) { if ( tagid != null && tagid > _num ) { return tagids . add ( tagid ) ; } return _bool ; }	adds the given tag id to this request .
public void supporttlsintolerantserver ( sslsocket socket ) { socket . setenabledprotocols ( new string [ ] { _str } ) ; }	attempt a secure connection with basic functionality to maximize compatibility.
public static list < executionentity > orderfromroottoleaf ( collection < executionentity > executions ) { list < executionentity > orderedlist = new arraylist < executionentity > ( executions . size ( ) ) ; hashset < string > previousids = new hashset < string > ( ) ; for ( executionentity execution : executions ) { if ( execution . getparentid ( ) == null ) { orderedlist . add ( execution ) ; previousids . add ( execution . getid ( ) ) ; } } while ( orderedlist . size ( ) < executions . size ( ) ) { for ( executionentity execution : executions ) { if ( ! previousids . contains ( execution . getid ( ) ) && previousids . contains ( execution . getparentid ( ) ) ) { orderedlist . add ( execution ) ; previousids . add ( execution . getid ( ) ) ; } } } return orderedlist ; }	takes in a collection of executions belonging to the same process instance.
public void inittkf91 ( ) { int inumnodes = iparent . length ; double ibeta [ ] = new double [ inumnodes ] ; ib = new double [ inumnodes ] ; ie = new double [ inumnodes ] ; ih = new double [ inumnodes ] ; in = new double [ inumnodes ] ; iinitial = _num ; for ( int i = _num ; i < inumnodes ; i ++ ) { if ( i == inumnodes - _num ) { ibeta [ i ] = _num / imu ; ih [ i ] = _num ; } else { ibeta [ i ] = math . exp ( ( ilambda - imu ) * itau [ i ] ) ; ibeta [ i ] = ( _num - ibeta [ i ] ) / ( imu - ilambda * ibeta [ i ] ) ; ih [ i ] = math . exp ( - imu * itau [ i ] ) * ( _num - ilambda * ibeta [ i ] ) ; } ib [ i ] = ilambda * ibeta [ i ] ; ie [ i ] = imu * ibeta [ i ] ; in [ i ] = ( _num - imu * ibeta [ i ] ) * ( _num - ib [ i ] ) - ih [ i ] ; iinitial *= ( _num - ib [ i ] ) ; } }	populates the ib , ie , ih and in arrays , and iinitial value.
public static string serializeexpression ( node s ) { if ( s instanceof astterm ) { astterm a = ( astterm ) s ; return ( a . isnotflag ( ) ? _str : _str ) + _str + a . getterm ( ) ; } string prefix = _str ; string suffix = _str ; string join = _str ; if ( s instanceof astexpression ) { astexpression a = ( astexpression ) s ; prefix = ( a . isnotflag ( ) ? _str : _str ) + _str ; suffix = _str ; join = _str + a . gettype ( ) + _str ; } list < string > children = new arraylist < string > ( ) ; for ( int i = _num ; i < s . jjtgetnumchildren ( ) ; i ++ ) { children . add ( serializeexpression ( s . jjtgetchild ( i ) ) ) ; } return prefix + stringutils . join ( children , join ) + suffix ; }	serialize a node ( and it ' s children ) to a parsable string .
private void defineinternalframemenubuttons ( uidefaults d ) { string p = _str ; string c = painter_prefix + _str ; d . put ( p + _str , new titlepanemenubuttonwindownotfocusedstate ( ) ) ; d . put ( p + _str , new insetsuiresource ( _num , _num , _num , _num ) ) ; d . put ( p + _str , new lazypainter ( c , titlepanemenubuttonpainter . which . icon_enabled ) ) ; d . put ( p + _str , new lazypainter ( c , titlepanemenubuttonpainter . which . icon_disabled ) ) ; d . put ( p + _str , new lazypainter ( c , titlepanemenubuttonpainter . which . icon_mouseover ) ) ; d . put ( p + _str , new lazypainter ( c , titlepanemenubuttonpainter . which . icon_pressed ) ) ; d . put ( p + _str , new lazypainter ( c , titlepanemenubuttonpainter . which . icon_enabled_windownotfocused ) ) ; d . put ( p + _str , new lazypainter ( c , titlepanemenubuttonpainter . which . icon_mouseover_windownotfocused ) ) ; d . put ( p + _str , new lazypainter ( c , titlepanemenubuttonpainter . which . icon_pressed_windownotfocused ) ) ; d . put ( p + _str , new seaglassicon ( p , _str , _num , _num ) ) ; }	initialize the internal frame menu button settings .
public static workflow . method restorefromclonemethod ( uri storage , list < uri > clone , boolean updateopstatus , boolean iscg ) { return new workflow . method ( _str , storage , clone , updateopstatus , iscg ) ; }	return a workflow . method for restorevolume.
@ override public synchronized void removedatasourcelistener ( datasourcelistener dsl ) { m_datasourcelisteners . remove ( dsl ) ; }	remove a datasource listener.
public string rightstr ( string str , int length ) { return str . substring ( math . max ( _num , str . length ( ) - length ) ) ; }	returns a substring of the given string , representing the ' length ' most - right characters.
public void clearnameinunoccupiedblocks ( ) { for ( int i = _num ; i < mblockentries . size ( ) ; i ++ ) { block b = mblockentries . get ( i ) ; if ( b . getstate ( ) == block . unoccupied ) { b . setvalue ( _str ) ; } } }	this function clears the block values for blocks in this section .
public static object unserialize ( data data ) { try { class clazz = ( class ) class . forname ( ( string ) data . get ( _str ) ) ; if ( clazz . isenum ( ) ) { return enum . valueof ( clazz , data . get ( _str ) ) ; } else if ( clazz == vector3d . class ) { return new vector3d ( data . get ( _str ) , data . get ( _str ) , data . get ( _str ) ) ; } else if ( clazz == vector2d . class ) { return new vector2d ( data . get ( _str ) , ( double ) data . get ( _str ) ) ; } else { return unserialize ( clazz , data ) ; } } catch ( exception e ) { throw new dataexception ( e ) ; } }	loads an object from its stored data , with an unknown class.
public static void ongridstop ( ) throws interruptedexception { synchronized ( mux ) { if ( gridcnt == _num ) return ; -- gridcnt ; thread timer0 = timer ; if ( gridcnt == _num && timer0 != null ) { timer = null ; timer0 . interrupt ( ) ; timer0 . join ( ) ; } } }	stops clock timer if all nodes into jvm were stopped .
public void pushtemplatefolder ( @ notnull string foldername ) throws ioexception { mylasttemplatefolders . push ( resolvename ( foldername ) ) ; }	resolve the foldername and push the resulting folder as the last template folder .
public void printdepthfirst ( ) { print ( new depthfirstenumerator ( _firstnode ) ) ; }	print , to system.
public void addevent ( simevent newevent ) { double eventtime = newevent . eventtime ( ) ; if ( eventtime >= maxtime ) { list . add ( newevent ) ; maxtime = eventtime ; return ; } listiterator < simevent > iterator = list . listiterator ( ) ; simevent event ; while ( iterator . hasnext ( ) ) { event = iterator . next ( ) ; if ( event . eventtime ( ) > eventtime ) { iterator . previous ( ) ; iterator . add ( newevent ) ; return ; } } list . add ( newevent ) ; }	adds a new event to the queue.
public dbschemaejbgenerator ( generatedtables gentables , schemaelement schemaelement ) { this ( gentables , schemaelement , collectiontype . collection , _bool , _bool , _bool ) ; }	creates a generator for a set of beans .
@ override public void initialize ( ) { board = null ; switch ( simpanectrl . getparamvalueindex ( param_init_conf ) ) { case _num : board = new eightpuzzleboard ( new int [ ] { _num , _num , _num , _num , _num , _num , _num , _num , _num } ) ; break ; case _num : board = new eightpuzzleboard ( new int [ ] { _num , _num , _num , _num , _num , _num , _num , _num , _num } ) ; break ; case _num : board = new eightpuzzleboard ( new int [ ] { _num , _num , _num , _num , _num , _num , _num , _num , _num } ) ; break ; case _num : board = new eightpuzzleboard ( new int [ ] { _num , _num , _num , _num , _num , _num , _num , _num , _num } ) ; random r = new random ( system . currenttimemillis ( ) ) ; for ( int i = _num ; i < _num ; i ++ ) { switch ( r . nextint ( _num ) ) { case _num : board . movegapup ( ) ; break ; case _num : board . movegapdown ( ) ; break ; case _num : board . movegapleft ( ) ; break ; case _num : board . movegapright ( ) ; break ; } } } stateviewctrl . initialize ( board ) ; }	displays the initialized board on the state view .
protected abstract void onopen ( htableinterface tbl , scan scan ) throws ioexception ;	hbase table connection callback function.
private static void addabbreviation ( string primitive , string abbreviation ) { abbreviationmap . put ( primitive , abbreviation ) ; reverseabbreviationmap . put ( abbreviation , primitive ) ; }	add primitive type abbreviation to maps of abbreviations .
private void inittreemap ( ) { if ( entitytype == null ) { entitytype = _str ; } if ( entitytype . equalsignorecase ( _str ) ) { imagemap = rotatingentitymanager . getcircle ( ) ; } if ( entitytype . equalsignorecase ( _str ) ) { imagemap = rotatingentitymanager . getmouse ( ) ; } else if ( entitytype . equalsignorecase ( _str ) ) { imagemap = rotatingentitymanager . getrotatingtileset ( _str , _num ) ; } else if ( entitytype . equalsignorecase ( _str ) ) { imagemap = rotatingentitymanager . getrotatingtileset ( _str , _num ) ; } else if ( entitytype . equalsignorecase ( _str ) ) { imagemap = rotatingentitymanager . getrotatingtileset ( _str , _num ) ; } else if ( entitytype . equalsignorecase ( _str ) ) { imagemap = rotatingentitymanager . getrotatingtileset ( _str , _num ) ; } else if ( entitytype . equalsignorecase ( _str ) ) { imagemap = rotatingentitymanager . getrotatingtileset ( _str , _num ) ; } else if ( entitytype . equalsignorecase ( _str ) ) { imagemap = rotatingentitymanager . getrotatingtileset ( _str , _num ) ; } else if ( entitytype . equalsignorecase ( _str ) ) { imagemap = rotatingentitymanager . getrotatingtileset ( _str , _num ) ; } else if ( entitytype . equalsignorecase ( _str ) ) { imagemap = rotatingentitymanager . getrotatingtileset ( _str , _num ) ; } else if ( entitytype . equalsignorecase ( _str ) ) { imagemap = rotatingentitymanager . getrotatingtileset ( _str , _num ) ; } update ( ) ; }	initialize the tree map , which associates angles with images / animations .
public static file locatereplicatorhomedir ( ) { if ( replicatorhomedir == null ) { string replicatorhome = system . getproperty ( home_dir ) ; if ( replicatorhome == null ) replicatorhome = system . getproperty ( _str ) ; replicatorhomedir = new file ( replicatorhome ) ; if ( ! replicatorhomedir . isdirectory ( ) ) { throw new serverruntimeexception ( _str + replicatorhomedir ) ; } } return replicatorhomedir ; }	find and return the replicator home directory .
public stringdata ( string data ) { m_data = data ; }	creates a transferable capable of transferring the specified string .
void writerepeatedsqr ( dd xdd ) { if ( xdd . ge ( dd . valueof ( _num ) ) ) throw new illegalargumentexception ( _str ) ; int count = _num ; while ( xdd . doublevalue ( ) > _num ) { count ++ ; if ( count == _num ) count = count ; double x = xdd . doublevalue ( ) ; dd xsqr = xdd . sqr ( ) ; string s = xsqr . tostring ( ) ; dd xsqr2 = dd . parse ( s ) ; xdd = xsqr ; } }	this routine simply tests for robustness of the tostring function .
public java . lang . stringbuffer append ( float f ) { internal . append ( f ) ; return this ; }	appends the string representation of the float argument to this string buffer.
public static final void open ( file file ) throws nosuchmethodexception { if ( platform . ismacosx ( ) ) { execargs ( _str , file . getabsolutepath ( ) ) ; } else if ( platform . iswindows ( ) ) { if ( file . isdirectory ( ) ) { execargs ( _str , file . getabsolutepath ( ) ) ; } else { execargs ( _str , file . getabsolutepath ( ) ) ; } } else if ( platform . isunix ( ) && hasunixcommand ( _str ) ) { execargs ( _str , file . tostring ( ) ) ; } else if ( platform . isunix ( ) && hasunixcommand ( _str ) ) { execargs ( _str , file . tostring ( ) ) ; } else if ( platform . issolaris ( ) && file . isdirectory ( ) ) { execargs ( _str , _str , file . getabsolutepath ( ) ) ; } else { throw new nosuchmethodexception ( _str ) ; } }	opens a file with the default system action .
@ override public string testdestination ( location destination , track track ) { string status = super . testdestination ( destination , track ) ; if ( ! status . equals ( track . okay ) ) { return status ; } if ( track == null ) { return status ; } return track . checkschedule ( this ) ; }	used to determine if a car can be set out at a destination ( location ).
public void close ( ) throws java . io . ioexception { flushbuffer ( ) ; m_os . close ( ) ; }	close the stream , flushing it first.
private static string [ ] norm ( string path ) { string [ ] elements = path . split ( _str ) ; arraylist < string > stack = new arraylist < string > ( ) ; for ( string e : elements ) { if ( e . isempty ( ) || e . equals ( _str ) ) continue ; if ( e . equals ( _str ) ) { if ( ! stack . isempty ( ) ) stack . remove ( stack . size ( ) - _num ) ; else return null ; continue ; } stack . add ( e ) ; } return stack . toarray ( new string [ stack . size ( ) ] ) ; }	process a path into an array of folders.
static random random ( ) { if ( null == lucene_test_case ) { return null ; } else { try { method randommethod = lucene_test_case . getmethod ( _str ) ; return ( random ) randommethod . invoke ( null ) ; } catch ( exception e ) { throw new illegalstateexception ( _str , e ) ; } } }	returns a random to be used by the current thread if available , otherwise returns null .
protected string record ( string deployment ) { deployments . add ( deployment ) ; return deployment ; }	record the fact that something was deployed , resulting in the given deployment id.
protected void onbeforestart ( bundlecontext ctx ) { }	this method is called before ignite initialises.
@ override public void onsuccess ( dlsn value ) { if ( value . getlogsegmentsequenceno ( ) != currentlogsegmentseqno ) { log . error ( _str , value . getlogsegmentsequenceno ( ) , currentlogsegmentseqno ) ; errorsfound . set ( _bool ) ; } if ( verifyentryid && value . getentryid ( ) != currententryid ) { log . error ( _str , value . getentryid ( ) , currententryid ) ; errorsfound . set ( _bool ) ; } synclatch . countdown ( ) ; }	invoked if the computation completes successfully.
private static void shutdownmysqlabandonedconnectioncleanupthread ( classloader classloader ) { try { class < ? > mysqlcleanupthreadclass ; try { mysqlcleanupthreadclass = classloader . loadclass ( _str ) ; } catch ( classnotfoundexception e ) { log . trace ( _str + _str , e ) ; return ; } method shutdownmethod = mysqlcleanupthreadclass . getmethod ( _str ) ; shutdownmethod . invoke ( null ) ; log . debug ( _str ) ; } catch ( throwable e ) { log . warn ( _str , e ) ; } }	shuts down a cleanup thread com.
public void write ( byte [ ] buffer ) { if ( isfinal ) { log . warning ( _str ) ; return ; } byte [ ] newdata = new byte [ data . length + buffer . length ] ; system . arraycopy ( data , _num , newdata , _num , data . length ) ; system . arraycopy ( buffer , _num , newdata , data . length , buffer . length ) ; data = newdata ; }	expands the current speech data by appending a new buffer of audio data.
public string parse ( string controltemplate , context controlcontext ) throws exception { this . controlcontext = controlcontext ; fillcontextdefaults ( this . controlcontext ) ; fillcontextproperties ( this . controlcontext ) ; template template = gettemplate ( controltemplate , inputencoding ) ; stringwriter sw = new stringwriter ( ) ; template . merge ( controlcontext , sw ) ; return sw . tostring ( ) ; }	parse the control template and merge it with the control context.
protected boolean oncreatecustomfromtag ( xmlpullparser parser , t parent , final attributeset attrs ) throws xmlpullparserexception { return _bool ; }	before this inflater tries to create an item from the tag , this method will be called . the parser will be pointing to the start of a tag , you must stop parsing and return when you reach the end of this element !.
public static long writefile ( string path , byte [ ] jpeg , exifinterface exif ) throws ioexception { if ( ! createdirectoryifneeded ( path ) ) { log . e ( tag , _str + path ) ; return - _num ; } if ( exif != null ) { exif . writeexif ( jpeg , path ) ; file f = new file ( path ) ; return f . length ( ) ; } else { return writefile ( path , jpeg ) ; } }	writes the jpeg data to a file.
private boolean checkforimageservers ( ) { boolean imageserverexists = _bool ; list < uri > imageserverurilist = _dbclient . querybytype ( computeimageserver . class , _bool ) ; arraylist < uri > templist = lists . newarraylist ( imageserverurilist . iterator ( ) ) ; if ( templist . isempty ( ) ) { imageserverexists = _bool ; } return imageserverexists ; }	check if there are image servers in the system.
final long now ( ) { return system . nanotime ( ) ; }	returns current nanosecond time .
public void removeextension ( string ext ) { synchronized ( exts ) { ext = ext . tolowercase ( ) ; exts . remove ( ext ) ; } }	this method removes an extension to the recognizer .
protected suballocatedintvector findnamespacecontext ( int elementnodeindex ) { if ( null != m_namespacedeclsetelements ) { int wouldbeat = findinsortedsuballocatedintvector ( m_namespacedeclsetelements , elementnodeindex ) ; if ( wouldbeat >= _num ) return ( suballocatedintvector ) m_namespacedeclsets . elementat ( wouldbeat ) ; if ( wouldbeat == - _num ) return null ; wouldbeat = - _num - wouldbeat ; int candidate = m_namespacedeclsetelements . elementat ( -- wouldbeat ) ; int ancestor = _parent ( elementnodeindex ) ; if ( wouldbeat == _num && candidate < ancestor ) { int roothandle = getdocumentroot ( makenodehandle ( elementnodeindex ) ) ; int rootid = makenodeidentity ( roothandle ) ; int uppermostnscandidateid ; if ( getnodetype ( roothandle ) == dtm . document_node ) { int ch = _firstch ( rootid ) ; uppermostnscandidateid = ( ch != dtm . null ) ? ch : rootid ; } else { uppermostnscandidateid = rootid ; } if ( candidate == uppermostnscandidateid ) { return ( suballocatedintvector ) m_namespacedeclsets . elementat ( wouldbeat ) ; } } while ( wouldbeat >= _num && ancestor > _num ) { if ( candidate == ancestor ) { return ( suballocatedintvector ) m_namespacedeclsets . elementat ( wouldbeat ) ; } else if ( candidate < ancestor ) { do { ancestor = _parent ( ancestor ) ; } while ( candidate < ancestor ) ; } else if ( wouldbeat > _num ) { candidate = m_namespacedeclsetelements . elementat ( -- wouldbeat ) ; } else break ; } } return null ; }	retrieve list of namespace declaration locations active at this node.
public void addobserver ( observer observer ) { if ( observer == null ) { throw new nullpointerexception ( _str ) ; } synchronized ( this ) { if ( ! observers . contains ( observer ) ) observers . add ( observer ) ; } }	adds the specified observer to the list of observers.
protected double distance ( int i , int k , int [ ] designations ) { return math . sqrt ( math . max ( selfk [ i ] - _num / ownes [ k ] * evalsumk ( i , k , designations ) + meansqrdnorms [ k ] * normconsts [ k ] , _num ) ) ; }	computes the distance between one data point and a specified mean.
public stringbuffer format ( object pat , stringbuffer result , fieldposition fpos ) { string pattern = processpattern ( ( string ) pat ) ; int lastoffset = _num ; for ( int i = _num ; i <= maxoffset ; ++ i ) { int offidx = offsets [ i ] ; result . append ( pattern . substring ( lastoffset , offsets [ i ] ) ) ; lastoffset = offidx ; string key = arguments [ i ] ; string obj ; if ( key . length ( ) > _num ) { obj = formatobject ( processkey ( key ) ) ; } else { result . append ( this . ldel ) ; result . append ( this . rdel ) ; continue ; } if ( obj == null ) { string lessgreedy = ldel + key ; int fromright = lessgreedy . lastindexof ( ldel ) ; if ( fromright > _num ) { string newkey = lessgreedy . substring ( fromright + ldel . length ( ) ) ; string newsubst = formatobject ( processkey ( newkey ) ) ; if ( newsubst != null ) { obj = lessgreedy . substring ( _num , fromright ) + newsubst ; } } } if ( obj == null ) { if ( throwex ) { throw new illegalargumentexception ( _str ) ; } else { obj = ldel + key + rdel ; } } result . append ( obj ) ; } result . append ( pattern . substring ( lastoffset , pattern . length ( ) ) ) ; return result ; }	formats the parsed string by inserting table ' s values .
public void add ( string keyword , byte id ) { int key = getstringmapkey ( keyword ) ; map [ key ] = new keyword ( keyword . tochararray ( ) , id , map [ key ] ) ; }	adds a key - value mapping .
void release ( object owner , field field ) { map < string , integer > fields = owners . get ( owner ) ; if ( fields != null ) { release ( ) ; integer count = fields . get ( field . togenericstring ( ) ) ; if ( -- count > _num ) { fields . put ( field . togenericstring ( ) , count ) ; } else { fields . remove ( field . togenericstring ( ) ) ; } } if ( fields != null && fields . isempty ( ) ) { owners . remove ( owner ) ; } }	release an instance injected as a field of an object.
public static list < dashboarddto > transformtodto ( list < dashboard > dashboards ) { if ( dashboards == null ) { throw new webapplicationexception ( _str , status . internal_server_error ) ; } list < dashboarddto > result = new arraylist < dashboarddto > ( ) ; for ( dashboard dashboard : dashboards ) { result . add ( transformtodto ( dashboard ) ) ; } return result ; }	converts list of alert entity objects to list of alertdto objects .
static executor screenexecutor ( executor e ) { if ( ! usecommonpool && e == forkjoinpool . commonpool ( ) ) return asyncpool ; if ( e == null ) throw new nullpointerexception ( ) ; return e ; }	null - checks user executor argument , and translates uses of commonpool to asyncpool in case parallelism disabled .
public void addgrouppropertieslistener ( grouppropertieslistener grouppropertieslistener ) { grouppropertieslisteners . add ( grouppropertieslistener ) ; }	adds a group properties listener .
public static void editglobalfunctioncomment ( final abstractsqlprovider provider , final inavifunction function , final integer commentid , final integer userid , final string newcomment ) throws couldntsavedataexception { postgresqlcommentfunctions . editcomment ( provider , commentid , userid , newcomment ) ; }	edits a global function comment .
public synchronized void clearsessions ( context context , boolean clearcredentials ) { synchronized ( instance ) { while ( mmxsessions . size ( ) > _num ) { clearsession ( context , mmxsessions . get ( _num ) , clearcredentials ) ; } } }	clear any existing session .
public boolean doesentryexists ( ssotoken token , string entrydn ) { try { persistentobject po = umsobject . getobject ( internaltoken , new guid ( entrydn ) ) ; } catch ( umsexception ue ) { if ( entrydn . indexof ( _str ) < _num ) { if ( debug . messageenabled ( ) ) { debug . message ( _str + _str , ue ) ; } } return _bool ; } return _bool ; }	checks if the entry exists in the directory .
private static char [ ] yy_unpack_cmap ( string packed ) { char [ ] map = new char [ _num ] ; int i = _num ; int j = _num ; while ( i < _num ) { int count = packed . charat ( i ++ ) ; char value = packed . charat ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > _num ) ; } return map ; }	unpacks the compressed character translation table .
private static native void initids ( ) ;	initialize jni field and method ids .
private static int hashwrappername ( string xn ) { if ( xn . length ( ) < _num ) { return _num ; } return ( _num * xn . charat ( _num ) + xn . charat ( _num ) ) % _num ; }	class name to wrapper hash , derived from wrapper . hashwrap ( ).
@ override public final void startelement ( final string ns , final string lname , final string qname , final attributes list ) throws saxexception { string name = lname == null || lname . length ( ) == _num ? qname : lname ; stringbuffer sb = new stringbuffer ( match ) ; if ( match . length ( ) > _num ) { sb . append ( _str ) ; } sb . append ( name ) ; match = sb . tostring ( ) ; rule r = ( rule ) rules . match ( match ) ; if ( r != null ) { r . begin ( name , list ) ; } }	process notification of the start of an xml element being reached .
public boolean isstring ( string key ) { object val = get ( key ) ; return val instanceof string ; }	check type of section element defined by key . return true this element is string.
private void createprwithtotalnumpropsetlist ( list vmlist , int startindexforregion , int endindexforregion , int localmaxmemory , int redundancy ) { iterator nodeiterator = vmlist . iterator ( ) ; while ( nodeiterator . hasnext ( ) ) { vm vm = ( vm ) nodeiterator . next ( ) ; vm . invoke ( createmultipleprwithtotalnumbucketpropset ( prprefix , startindexforregion , endindexforregion , redundancy , localmaxmemory , _num ) ) ; } }	this function creates a partition region with total_buckets_num_property set to 11 .
public zdiagmat ( zmat a , int k ) throws jampackexception { parameters . baseindexnotchangeable = _bool ; basex = parameters . baseindex ; if ( k >= _num ) { if ( k >= a . ncol ) { throw new jampackexception ( _str ) ; } order = math . min ( a . nrow , a . ncol - k ) ; re = new double [ order ] ; im = new double [ order ] ; for ( int i = _num ; i < order ; i ++ ) { re [ i ] = a . re [ i ] [ i + k ] ; im [ i ] = a . im [ i ] [ i + k ] ; } } else { k = - k ; if ( k >= a . nrow ) { throw new jampackexception ( _str ) ; } order = math . min ( a . nrow - k , a . ncol ) ; re = new double [ order ] ; im = new double [ order ] ; for ( int i = _num ; i < order ; i ++ ) { re [ i ] = a . re [ i + k ] [ i ] ; im [ i ] = a . im [ i + k ] [ i ] ; } } getproperties ( ) ; }	constructs a zdiagmat and initializes it to the diagonal of a zmat .
protected void checkantversion ( hashtable h ) { if ( null == h ) h = new hashtable ( ) ; try { final string ant_version_class = _str ; final string ant_version_method = _str ; final class noargs [ ] = new class [ _num ] ; class clazz = objectfactory . findproviderclass ( ant_version_class , objectfactory . findclassloader ( ) , _bool ) ; method method = clazz . getmethod ( ant_version_method , noargs ) ; object returnvalue = method . invoke ( null , new object [ _num ] ) ; h . put ( version + _str , ( string ) returnvalue ) ; } catch ( exception e ) { h . put ( version + _str , class_notpresent ) ; } }	report product version information from ant .
public void buildnetwork ( ) { neuron firstneuron = new neuron ( network , default_neuron_type ) ; list < neuron > currentlayer = new arraylist < neuron > ( ) ; firstneuron . setposition ( initialposition ) ; currentlayer . add ( firstneuron ) ; int numneuronslastlayer = ( int ) math . pow ( numbrachesperneuron , numlayers ) ; double totalspace = numneuronslastlayer * horizontalspacing ; for ( int layerindex = _num ; layerindex <= numlayers ; layerindex ++ ) { list < neuron > templist = new arraylist < neuron > ( ) ; double layerspacing = totalspace / ( int ) math . pow ( numbrachesperneuron , layerindex ) ; double branchwidth = layerspacing * ( numbrachesperneuron - _num ) ; for ( neuron baseneuron : currentlayer ) { network . addneuron ( baseneuron ) ; double initialxoffset = branchwidth / _num ; for ( int j = _num ; j < numbrachesperneuron ; j ++ ) { neuron targetneuron = new neuron ( network , new linearrule ( ) ) ; targetneuron . setlocation ( baseneuron . getx ( ) - initialxoffset + ( j * layerspacing ) , initialposition . y - ( layerindex * verticalspacing ) ) ; templist . add ( targetneuron ) ; network . addneuron ( targetneuron ) ; targetneuron . setupdatepriority ( layerindex ) ; synapse synapse = new synapse ( network , baseneuron , targetneuron , new staticsynapserule ( ) ) ; network . addsynapse ( synapse ) ; } } currentlayer = templist ; } }	create the cascading network .
private static boolean areequal ( int fromindex , charsequence left , charsequence right ) { if ( left == right ) return _bool ; if ( ( left == null ) || ( right == null ) ) return _bool ; int n = left . length ( ) ; if ( right . length ( ) != n ) return _bool ; for ( int i = n ; i > fromindex ; ) { if ( character . touppercase ( left . charat ( -- i ) ) != character . touppercase ( right . charat ( i ) ) ) return _bool ; } return _bool ; }	check for equality of the two characters sequences starting at the specified index.
public void testcase12 ( ) { byte bbytes [ ] = { _num , _num , - _num , _num , _num , - _num , _num , - _num } ; int bsign = - _num ; byte rbytes [ ] = { _num } ; biginteger anumber = biginteger . zero ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . divide ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	divide zero by a negative number .
public enumeration productions ( ) { return _productions . elements ( ) ; }	access to productions with this non terminal on the lhs .
public void addtightsourcenode ( astnode reference ) { ftightsourcerangenodes . add ( reference ) ; list < structuralpropertydescriptor > properties = reference . structuralpropertiesfortype ( ) ; for ( iterator < structuralpropertydescriptor > iterator = properties . iterator ( ) ; iterator . hasnext ( ) ; ) { structuralpropertydescriptor descriptor = iterator . next ( ) ; if ( descriptor . ischildproperty ( ) ) { astnode child = ( astnode ) reference . getstructuralproperty ( descriptor ) ; if ( child != null && isextending ( child , reference ) ) { addtightsourcenode ( child ) ; } } else if ( descriptor . ischildlistproperty ( ) ) { list < ? extends astnode > children = ( list < ? extends astnode > ) reference . getstructuralproperty ( descriptor ) ; for ( iterator < ? extends astnode > iterator2 = children . iterator ( ) ; iterator2 . hasnext ( ) ; ) { astnode child = iterator2 . next ( ) ; if ( isextending ( child , reference ) ) { addtightsourcenode ( child ) ; } } } } }	add the given node to the set of " tight " nodes .
protected boolean iseventdisabled ( xevent e ) { switch ( e . get_type ( ) ) { case xconstants . configurenotify : return _bool ; case xconstants . enternotify : case xconstants . leavenotify : return _bool ; default : return super . iseventdisabled ( e ) ; } }	end of i n s e t s c o d e.
public djarinfo ( jframe parent ) throws ioexception { this ( parent , res . getstring ( _str ) , modalitytype . document_modal ) ; }	creates new djarinfo dialog where the parent is a frame .
protected void transformpointarraynotouch ( float [ ] pts ) { mmatrixvaluetopx . mappoints ( pts ) ; mmatrixoffset . mappoints ( pts ) ; }	transform an array of points with all matrixes except the touch matrix - - > use this if the transformed values are not effected by touch gestures.
private void convertescapedfunction ( final stringbuilder target , final charsequence escapedfunction ) throws fbsqlparseexception { final string templateresult = fbescapedfunctionhelper . converttemplate ( escapedfunction . tostring ( ) , mode ) ; target . append ( templateresult != null ? templateresult : escapedfunction ) ; }	this method converts escaped function to a server function call.
@ override public final string tostring ( ) { if ( stringrep == null ) { stringbuilder buffer = new stringbuilder ( ) ; buffer . append ( this . name ) ; buffer . append ( _str ) ; buffer . append ( integer . tostring ( this . defaultport ) ) ; stringrep = buffer . tostring ( ) ; } return stringrep ; }	return a string representation of this object .
public void addlistener ( imssessionlistener listener ) { mlisteners . add ( listener ) ; }	add a listener for receiving events.
public static ipath stamptopath ( final long stamp ) { fgcalendar . settimeinmillis ( stamp ) ; final stringbuffer buffer = new stringbuffer ( _num ) ; buffer . append ( fgcalendar . get ( calendar . year ) ) ; buffer . append ( ipath . separator ) ; buffer . append ( fgcalendar . get ( calendar . month ) + _num ) ; buffer . append ( ipath . separator ) ; buffer . append ( fgcalendar . get ( calendar . week_of_year ) ) ; return new path ( buffer . tostring ( ) ) ; }	returns a path representing the history part for the specified time stamp .
public void printusermessage ( usermessage message ) { user user = message . user ; boolean ignored = message . ignored_compact ; if ( ignored ) { printcompact ( _str , user ) ; return ; } color color = message . color ; boolean action = message . action ; string text = message . text ; tagemotes emotes = message . emotes ; boolean highlighted = message . highlighted ; if ( message . whisper && message . action ) { color = styleconstants . getforeground ( styles . info ( ) ) ; highlighted = _bool ; } closecompactmode ( ) ; mutableattributeset style ; if ( highlighted ) { style = styles . highlight ( color ) ; } else { style = styles . standard ( ) ; } print ( gettimeprefix ( ) , style ) ; printuser ( user , action , message . whisper , message . id ) ; if ( ! highlighted && action && styles . actioncolored ( ) ) { style = styles . standard ( user . getdisplaycolor ( ) ) ; } printspecials ( text , user , style , emotes , _bool , message . bits > _num ) ; printnewline ( ) ; }	output a regular message from a user .
public boolean connectimpl ( string address , int port ) throws ioexception { _sockettimeout = _num ; _nativefd = - _num ; _isclosed . set ( _bool ) ; synchronized ( _writelock ) { boolean isconnect = nativeconnect ( _socketfd , address , port ) ; return isconnect ; } }	creates the new server socket .
public static boolean isaccessmodifier ( string str ) { return str . equals ( _str ) || str . equals ( _str ) || str . equals ( _str ) || str . equals ( _str ) || str . equals ( _str ) || str . equals ( _str ) ; }	returns true if str is an access modifier , false otherwise .
protected void handleappendrequestfailure ( memberstate member , appendrequest request , throwable error ) { failattempt ( member , error ) ; }	handles an append failure .
private static sizepair selectsizepair ( camera camera , int desiredwidth , int desiredheight ) { list < sizepair > validpreviewsizes = generatevalidpreviewsizelist ( camera ) ; sizepair selectedpair = null ; int mindiff = integer . max_value ; for ( sizepair sizepair : validpreviewsizes ) { size size = sizepair . previewsize ( ) ; int diff = math . abs ( size . getwidth ( ) - desiredwidth ) + math . abs ( size . getheight ( ) - desiredheight ) ; if ( diff < mindiff ) { selectedpair = sizepair ; mindiff = diff ; } } return selectedpair ; }	selects the most suitable preview and picture size , given the desired width and height.
public list < addressitem > loadalldeepfromcursor ( cursor cursor ) { int count = cursor . getcount ( ) ; list < addressitem > list = new arraylist < addressitem > ( count ) ; if ( cursor . movetofirst ( ) ) { if ( identityscope != null ) { identityscope . lock ( ) ; identityscope . reserveroom ( count ) ; } try { do { list . add ( loadcurrentdeep ( cursor , _bool ) ) ; } while ( cursor . movetonext ( ) ) ; } finally { if ( identityscope != null ) { identityscope . unlock ( ) ; } } } return list ; }	reads all available rows from the given cursor and returns a list of new imageto objects .
public static string decode ( byte [ ] utf8 ) throws charactercodingexception { return decode ( bytebuffer . wrap ( utf8 ) , _bool ) ; }	converts the provided byte array to a string using the utf - 8 encoding.
private map < string , string > attributestolowercase ( ) { map < string , string > lowercaseattributes = new linkedhashmap < string , string > ( ) ; for ( string key : attributes . keyset ( ) ) { lowercaseattributes . put ( key . tolowercase ( ) , attributes . get ( key ) ) ; } return lowercaseattributes ; }	returns a copy of the set of attributes for this node with lowercase names.
protected final void acceptannotations ( final methodvisitor mv ) { int n = visibletypeannotations == null ? _num : visibletypeannotations . size ( ) ; for ( int i = _num ; i < n ; ++ i ) { typeannotationnode an = visibletypeannotations . get ( i ) ; an . accept ( mv . visitinsnannotation ( an . typeref , an . typepath , an . desc , _bool ) ) ; } n = invisibletypeannotations == null ? _num : invisibletypeannotations . size ( ) ; for ( int i = _num ; i < n ; ++ i ) { typeannotationnode an = invisibletypeannotations . get ( i ) ; an . accept ( mv . visitinsnannotation ( an . typeref , an . typepath , an . desc , _bool ) ) ; } }	makes the given visitor visit the annotations of this instruction .
public static < t > list < t > tolist ( t obj1 , t obj2 ) { list < t > list = new linkedlist < t > ( ) ; list . add ( obj1 ) ; list . add ( obj2 ) ; return list ; }	create a list from passed objx parameters.
public byte [ ] readnextpart ( ) throws jplagexception { if ( remainingbytes == _num ) { throw new jplagexception ( _str , _str , _str ) ; } try { fileinputstream in = new fileinputstream ( file ) ; in . skip ( filesize - remainingbytes ) ; int partsize = remainingbytes ; if ( partsize > _num ) partsize = _num ; byte [ ] data = new byte [ partsize ] ; in . read ( data ) ; in . close ( ) ; remainingbytes -= partsize ; return data ; } catch ( ioexception e ) { e . printstacktrace ( ) ; throw new jplagexception ( _str , _str + _str , _str ) ; } }	reads the next part of the related file.
public boolean ismultilinetabbed ( ) { return multilinetab ; }	whether using the tab key indents the selected lines of code.
protected void computeparameters ( ) { if ( m_sumofweights > _num ) { m_mean = m_sumofvalues / m_sumofweights ; double stddev = math . sqrt ( math . abs ( m_sumofvaluessq - m_mean * m_sumofvalues ) / m_sumofweights ) ; if ( stddev > _num ) { m_standarddev = math . max ( m_precision / ( _num * _num ) , stddev ) ; } } }	compute the parameters of the distribution.
public string translatedatatype ( string sourcevendorname , string targetvendorname , string datatype , int size , int scale ) { return getdatatype ( targetvendorname , getdatatypeid ( sourcevendorname , datatype ) , size , scale ) ; }	translate data type from source to target database.
public static int findglobalvalleylocation ( double [ ] data ) { double min = double . nan ; int imin = - _num ; for ( int i = _num ; i < data . length ; i ++ ) { if ( double . isnan ( data [ i ] ) ) continue ; if ( double . isnan ( min ) || data [ i ] < min ) { min = data [ i ] ; imin = i ; } } return imin ; }	find the minimum of all elements in the array , ignoring elements that are nan .
protected void movedownselected ( ) { int selectedindex = table . getselectedrow ( ) ; if ( selectedindex > - _num ) { int index = data . movedown ( indextomodel ( selectedindex ) ) ; setrowselected ( indextoview ( index ) ) ; } }	moves the selected item down in the model ( and table ).
jarwithfile ( pathimpl backing ) { super ( backing ) ; }	creates a new jar .
public list < runnable > shutdownnow ( ) { logger . info ( _str ) ; return executor . shutdownnow ( ) ; }	shut down the scanner , interrupting running tasks and cancelling waiting ones .
public static list < string > torelativepaths ( @ notnull virtualfile root , @ notnull final collection < filepath > filepaths ) { arraylist < string > rc = new arraylist < string > ( filepaths . size ( ) ) ; for ( filepath path : filepaths ) { rc . add ( relativepath ( root , path ) ) ; } return rc ; }	covert list of files to relative paths.
private void handleunlockorinstall ( ) { if ( isfinishing ( ) ) { return ; } switch ( mkeystore . state ( ) ) { case uninitialized : { ensurekeyguard ( ) ; return ; } case locked : { new unlockdialog ( ) ; return ; } case unlocked : { if ( ! checkkeyguardquality ( ) ) { new configurekeyguarddialog ( ) ; return ; } installifavailable ( ) ; finish ( ) ; return ; } } }	based on the current state of the keystore and key guard , try to make progress on unlocking or installing to the keystore .
private void offsetstarttimeifnecessary ( time starttime , time endtime , string rrule , calendareventmodel model ) { if ( rrule == null || rrule . isempty ( ) ) { return ; } meventrecurrence . parse ( rrule ) ; if ( meventrecurrence . freq != eventrecurrence . weekly ) { return ; } if ( meventrecurrence . byday . length > meventrecurrence . bydaycount ) { return ; } int closestweekday = integer . max_value ; int weekstart = eventrecurrence . day2timeday ( meventrecurrence . wkst ) ; int startday = starttime . weekday ; for ( int i = _num ; i < meventrecurrence . bydaycount ; i ++ ) { int day = eventrecurrence . day2timeday ( meventrecurrence . byday [ i ] ) ; if ( day == startday ) { return ; } if ( day < weekstart ) { day += _num ; } if ( day > startday && ( day < closestweekday || closestweekday < startday ) ) { closestweekday = day ; } if ( closestweekday == integer . max_value || closestweekday < startday ) { if ( day < closestweekday ) { closestweekday = day ; } } } if ( closestweekday < startday ) { closestweekday += _num ; } int daysoffset = closestweekday - startday ; starttime . monthday += daysoffset ; endtime . monthday += daysoffset ; long newstarttime = starttime . normalize ( _bool ) ; long newendtime = endtime . normalize ( _bool ) ; model . mstart = newstarttime ; model . mend = newendtime ; }	if the recurrence rule is such that the event start date doesn ' t actually fall in one of the recurrences , then push the start date up to the first actual instance of the event .
public vector3 ceil ( ) { return new vector3 ( math . ceil ( x ) , math . ceil ( y ) , math . ceil ( z ) ) ; }	rounds the x , y , and z values of this vector3 up to the nearest integer value .
public void simulatemethod ( sootmethod method , referencevariable thisvar , referencevariable returnvar , referencevariable params [ ] ) { string subsignature = method . getsubsignature ( ) ; if ( subsignature . equals ( _str ) ) { java_lang_throwable_fillinstacktrace ( method , thisvar , returnvar , params ) ; return ; } else { defaultmethod ( method , thisvar , returnvar , params ) ; return ; } }	implements the abstract method simulatemethod.
private void cleanupfrontier ( ) { while ( ! frontier . isempty ( ) && isexplored ( frontier . element ( ) ) ) frontier . remove ( ) ; }	helper method which removes nodes of already explored states from the head of the frontier .
private void parseattributes ( typedarray a ) { barwidth = ( int ) a . getdimension ( r . styleable . progresswheel_pwbarwidth , barwidth ) ; rimwidth = ( int ) a . getdimension ( r . styleable . progresswheel_pwrimwidth , rimwidth ) ; spinspeed = ( int ) a . getdimension ( r . styleable . progresswheel_pwspinspeed , spinspeed ) ; barlength = ( int ) a . getdimension ( r . styleable . progresswheel_pwbarlength , barlength ) ; delaymillis = a . getinteger ( r . styleable . progresswheel_pwdelaymillis , delaymillis ) ; if ( delaymillis < _num ) { delaymillis = _num ; } if ( a . hasvalue ( r . styleable . progresswheel_pwtext ) ) { settext ( a . getstring ( r . styleable . progresswheel_pwtext ) ) ; } barcolor = a . getcolor ( r . styleable . progresswheel_pwbarcolor , barcolor ) ; textcolor = a . getcolor ( r . styleable . progresswheel_pwtextcolor , textcolor ) ; rimcolor = a . getcolor ( r . styleable . progresswheel_pwrimcolor , rimcolor ) ; circlecolor = a . getcolor ( r . styleable . progresswheel_pwcirclecolor , circlecolor ) ; contourcolor = a . getcolor ( r . styleable . progresswheel_pwcontourcolor , contourcolor ) ; textsize = ( int ) a . getdimension ( r . styleable . progresswheel_pwtextsize , textsize ) ; contoursize = a . getdimension ( r . styleable . progresswheel_pwcontoursize , contoursize ) ; a . recycle ( ) ; }	parse the attributes passed to the view from the xml.
public static byte [ ] concatenate ( byte [ ] a , byte [ ] b ) { byte [ ] output = new byte [ a . length + b . length ] ; system . arraycopy ( a , _num , output , _num , a . length ) ; system . arraycopy ( b , _num , output , a . length , b . length ) ; return output ; }	concatenates two byte arrays .
public final assertsubscriber < t > assertterminated ( ) { if ( cdl . getcount ( ) != _num ) { throw new assertionerror ( _str , null ) ; } return this ; }	assert either complete successfully or error signal has been received .
protected static void assertargument ( final boolean validarg , final string message , final object ... args ) { if ( ! validarg ) { throw new illegalargumentexception ( string . format ( message , args ) ) ; } }	asserts the argument is valid , as determined by the caller passing the result of an evaluated expression to this assertion .
public static boolean isbeforetoday ( calendar _calendar ) { return _calendar . before ( calendar . getinstance ( ) ) ; }	allows to know if a given calendar instance is set before today.
public static viewitemgroup buildloginui ( modelapplication modelapp , activity activity ) { viewitemgroup viewitems = new viewitemgroup ( activity ) ; textview usernametext = new textview ( activity ) ; usernametext . settext ( r . string . username ) ; viewitems . addview ( usernametext ) ; viewitemfactory viewitemfactory = viewitemfactory . instance ( ) ; viewitem usernameitem = viewitemfactory . create ( loginviewid . username , viewitemfactory . text_datatype_db_id , activity ) ; viewitems . addviewitem ( usernameitem , new omnitext ( modelapp . getusername ( ) ) ) ; textview passwordtext = new textview ( activity ) ; passwordtext . settext ( r . string . password ) ; viewitems . addview ( passwordtext ) ; viewitem passworditem = viewitemfactory . create ( loginviewid . password , viewitemfactory . password_input_datatype_db_id , activity ) ; viewitems . addviewitem ( passworditem , new omnipasswordinput ( modelapp . getpassword ( ) ) ) ; return viewitems ; }	build a standard login ui with username and password fields.
public void unmapvolumefromscsiinitiator ( string volumeid , string initiatorid ) throws exception { string uri = scaleioconstants . getunmapvolumetoscsiinitiatoruri ( volumeid ) ; scaleiounmapvolumetoscsiinitiator unmapparm = new scaleiounmapvolumetoscsiinitiator ( ) ; unmapparm . setscsiinitiatorid ( initiatorid ) ; post ( uri . create ( uri ) , getjsonforentity ( unmapparm ) ) ; }	unmap the volume from scsi initiator.
public collection < t > ascollection ( ) { return this . list ; }	returns the underlying collection .
private static void addquarterarc ( path2d . float path , float x1 , float y1 , float x2 , float y2 , float curvature , boolean verticalstart ) { boolean down = y1 < y2 ; boolean left = x1 > x2 ; float cx1 = _num ; float cy1 = _num ; float cx2 = _num ; float cy2 = _num ; if ( verticalstart ) { cx1 = x1 ; cy2 = y2 ; if ( left ) { cx2 = x1 - curvature ; } else { cx2 = x1 + curvature ; } if ( down ) { cy1 = y2 - curvature ; } else { cy1 = y2 + curvature ; } } else { cx2 = x2 ; cy1 = y1 ; if ( left ) { cx1 = x2 + curvature ; } else { cx1 = x2 - curvature ; } if ( down ) { cy2 = y1 + curvature ; } else { cy2 = y1 - curvature ; } } path . curveto ( cx1 , cy1 , cx2 , cy2 , x2 , y2 ) ; }	add a quarter circular path to a given path object , starting from ( x1 , y1 ) to ( x2 , y2 ) .
@ override public void parse ( string content , node block ) { this . block = block ; this . input = content . trim ( ) ; this . index = _num ; this . lastdelimiter = null ; this . lastbracket = null ; boolean moretoparse ; do { moretoparse = parseinline ( ) ; } while ( moretoparse ) ; processdelimiters ( null ) ; mergetextnodes ( block . getfirstchild ( ) , block . getlastchild ( ) ) ; }	parse content in block into inline children , using reference map to resolve references .
public static void random ( byte [ ] b , int offset , int length ) { checkpositionindex ( offset , b . length , _str ) ; checkargument ( length > _num , _str ) ; checkpositionindex ( offset + length , b . length , _str ) ; byte [ ] buf = new byte [ length ] ; rng . nextbytes ( buf ) ; system . arraycopy ( buf , _num , b , offset , length ) ; }	fill given array with random bytes at the specified position .
public void removeallscanningcallbacks ( ) { scanningcallbacks . clear ( ) ; }	removes all scanning callbacks .
public int read ( byte [ ] buf , int off , int len ) throws ttransportexception { if ( inputstream_ == null ) { throw new ttransportexception ( ttransportexception . not_open , _str ) ; } int bytesread ; try { bytesread = inputstream_ . read ( buf , off , len ) ; } catch ( ioexception iox ) { throw new ttransportexception ( ttransportexception . unknown , iox ) ; } if ( bytesread < _num ) { throw new ttransportexception ( ttransportexception . end_of_file ) ; } return bytesread ; }	reads from the underlying input stream if not null .
public void handlemanagercreation ( ) throws managementexception { if ( ! isserviceinitialised ( _str ) ) { return ; } objectname managermbeanname = mbeanjmxadapter . getmanagername ( ) ; managermbeanbridge bridge = new managermbeanbridge ( service ) ; managermxbean bean = new managermbean ( bridge ) ; service . registerinternalmbean ( bean , managermbeanname ) ; }	assumption is always cache and membermbean has been will be created first.
@ suppresswarnings ( _str ) private boolean checksetshape ( shape oldshape , shape newshape ) { shape currentshape = getshape ( ) ; assert oldshape != newshape : _str ; assert newshape != currentshape : _str + currentshape ; assert oldshape == currentshape || oldshape . getparent ( ) == currentshape : _str + _str + currentshape + _str + oldshape + _str + newshape ; return _bool ; }	check whether fast transition is valid .
protected boolean isfilevisible ( file file ) { if ( file == null || ! file . exists ( ) || ! file . canread ( ) || file . ishidden ( ) ) { return _bool ; } return _bool ; }	returns true if the given file is visible.
public static string [ ] append ( final string [ ] a , final string ... b ) { final int alen = a . length ; final int blen = b . length ; final string [ ] res = arrays . copyof ( a , alen + blen ) ; system . arraycopy ( b , _num , res , alen , blen ) ; return res ; }	append strings to an array creating a new array for the result .
public void delete ( ) throws amexception , ssoexception { delete ( _bool ) ; }	removes and destroys the object .
public string ( byte [ ] bytes , int off , int len , java . lang . string enc ) throws java . io . unsupportedencodingexception { this ( bytestochars ( bytes , off , len , enc ) ) ; }	construct a new string by converting the specified subarray of bytes using the specified character encoding.
private boolean initializesearchitemset ( bitvector bv , int [ ] scratchi , int [ ] iters ) { for ( int i = _num ; i < scratchi . length ; i ++ ) { iters [ i ] = ( i == _num ) ? bv . iter ( ) : bv . iteradvance ( iters [ i - _num ] ) ; if ( iters [ i ] < _num ) { return _bool ; } scratchi [ i ] = bv . iterdim ( iters [ i ] ) ; } return _bool ; }	initialize the scratch itemset .
private rectangle computeeditorbounds ( ) { if ( row == - _num || column == - _num ) return new rectangle ( _num , _num , _num , _num ) ; rectangle cell = grid . getcellbounds ( column , row ) ; rectangle area = grid . getclientarea ( ) ; if ( cell . x < area . x + area . width ) { if ( cell . x + cell . width > area . x + area . width ) { cell . width = area . x + area . width - cell . x ; } } rectangle editorrect = new rectangle ( cell . x , cell . y , minimumwidth , minimumheight ) ; if ( grabhorizontal ) { editorrect . width = math . max ( cell . width , minimumwidth ) ; } if ( grabvertical ) { editorrect . height = math . max ( cell . height , minimumheight ) ; } if ( horizontalalignment == swt . right ) { editorrect . x += cell . width - editorrect . width ; } else if ( horizontalalignment == swt . left ) { } else { editorrect . x += ( cell . width - editorrect . width ) / _num ; } if ( verticalalignment == swt . bottom ) { editorrect . y += cell . height - editorrect . height ; } else if ( verticalalignment == swt . top ) { } else { editorrect . y += ( cell . height - editorrect . height ) / _num ; } return editorrect ; }	returns the bounds of the editor .
public int read ( byte [ ] buffer , int offset , int length ) throws ioexception { throw new unsupportedoperationexception ( string . valueof ( this ) ) ; }	reads the next chunk from the stream .
public cuboid ( world world , int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { this . worldname = world . getname ( ) ; this . x1 = math . min ( x1 , x2 ) ; this . x2 = math . max ( x1 , x2 ) ; this . y1 = math . min ( y1 , y2 ) ; this . y2 = math . max ( y1 , y2 ) ; this . z1 = math . min ( z1 , z2 ) ; this . z2 = math . max ( z1 , z2 ) ; }	construct a cuboid in the given world and xyz co - ordinates.
@ suppresswarnings ( { _str } ) public double logmarginallikelihoodsmoothed ( list < double > v , double delta , double pdata ) { final double logdelta = strictmath . log ( delta ) ; final double loginvdelta = strictmath . log ( _num - delta ) ; final int n = v . size ( ) ; final double logn = strictmath . log ( n ) ; final double offset = loginvdelta - pdata ; double bottom = logn + logdelta - loginvdelta ; double top = bottom + pdata ; for ( int i = _num ; i < n ; i ++ ) { double weight = - logtricks . logsum ( logdelta , offset + v . get ( i ) ) ; top = logtricks . logsum ( top , weight + v . get ( i ) ) ; bottom = logtricks . logsum ( bottom , weight ) ; } return top - bottom ; }	calculates the log marginal likelihood of a model using newton and raftery ' s smoothed estimator.
public boolean isnewmessage ( ) { if ( message == null ) { throw new illegalstateexception ( _str ) ; } return message . startswith ( _str ) || message . equals ( _str ) ; }	returns true if the message starts with & quot ; new ( & quot ; or if it equals & quot ; new & quot ;.
private void installproperties ( ) { system . setproperty ( _str , useragentgenerator . getuseragent ( ) ) ; if ( osutils . ismacosx ( ) ) { system . setproperty ( _str , _str ) ; } }	installs any system properties .
public doublebuffer put ( double [ ] src , int srcoffset , int doublecount ) { arrays . checkoffsetandcount ( src . length , srcoffset , doublecount ) ; if ( doublecount > remaining ( ) ) { throw new bufferoverflowexception ( ) ; } for ( int i = srcoffset ; i < srcoffset + doublecount ; ++ i ) { put ( src [ i ] ) ; } return this ; }	writes doubles from the given double array , starting from the specified offset , to the current position and increases the position by the number of doubles written .
private void loadrecipients ( int addresstype , hashset < string > recipients , hashmap < integer , encodedstringvalue [ ] > addressmap , boolean excludemynumber ) { encodedstringvalue [ ] array = addressmap . get ( addresstype ) ; if ( array == null ) { return ; } if ( excludemynumber && array . length == _num ) { return ; } string mynumber = excludemynumber ? mtelephonymanager . getline1number ( ) : null ; for ( encodedstringvalue v : array ) { if ( v != null ) { string number = v . getstring ( ) ; if ( ( mynumber == null || ! phonenumberutils . compare ( number , mynumber ) ) && ! recipients . contains ( number ) ) { recipients . add ( number ) ; } } } }	for a given address type , extract the recipients from the headers .
public static boolean isextension ( string filename , string extension ) { if ( filename == null ) { return _bool ; } if ( extension == null || extension . length ( ) == _num ) { return indexofextension ( filename ) == - _num ; } string fileext = getextension ( filename ) ; return fileext . equals ( extension ) ; }	checks whether the extension of the filename is that specified.
@ prepersist public void prepersist ( ) { locktime = system . currenttimemillis ( ) ; }	used to automatically update the timestamp of locks .
public libpadstack add ( string p_name , shapeconvex [ ] p_shapes , boolean p_attach_allowed , boolean p_placed_absolute ) { int pad_no = count ( ) + _num ; libpadstack new_padstack = new libpadstack ( p_name , pad_no , p_shapes , p_attach_allowed , p_placed_absolute ) ; padstack_list . add ( new_padstack ) ; return new_padstack ; }	appends a new padstack with the input shapes to this padstacks.
protected argsbase ( ) { _argv = null ; _env = null ; }	for the commandmanager init .
@ override public void startcontentmodel ( string elementname , augmentations augs ) throws xniexception { if ( fvalidation ) { fdtdelementdeclname = elementname ; fmixedelementtypes . clear ( ) ; } if ( fdtdgrammar != null ) fdtdgrammar . startcontentmodel ( elementname , augs ) ; if ( fdtdcontentmodelhandler != null ) { fdtdcontentmodelhandler . startcontentmodel ( elementname , augs ) ; } }	the start of a content model.
public omrangerings ( latlonpoint center , double radius , length units , int nverts ) { super ( center , radius , units , nverts ) ; centerpoint = createcenterpoint ( ) ; form . setmaximumfractiondigits ( _num ) ; }	create an omrangerings with a lat / lon center and a physical distance radius.
public static inputsource createinputsource ( string s ) { try { return new inputsource ( new bytearrayinputstream ( s . getbytes ( _str ) ) ) ; } catch ( unsupportedencodingexception e ) { throw new runtimeexception ( e ) ; } }	create an inputsource form a string .
public static preferences userroot ( ) { return factory . userroot ( ) ; }	returns the root node of the user preference hierarchy .
public static string todebugstring ( final long socketidentifier ) { final int ipbits = ( int ) socketidentifier ; final int port = extractportnumber ( socketidentifier ) ; final int inode = ( int ) ( socketidentifier > > _num ) ; return integer . tohexstring ( ipbits ) + _str + port + _str + inode ; }	generates a vaguely human - readable format for a given socket identifier .
public final void push ( string s ) { if ( ( m_firstfree + _num ) >= m_mapsize ) { m_mapsize += m_blocksize ; string newmap [ ] = new string [ m_mapsize ] ; system . arraycopy ( m_map , _num , newmap , _num , m_firstfree + _num ) ; m_map = newmap ; } m_map [ m_firstfree ] = s ; m_firstfree ++ ; }	tell if the table contains the given string .
public static string readfromfile ( final file path ) throws ioexception { fileinputstream fis = null ; try { fis = new fileinputstream ( path ) ; return readfromfile ( fis ) ; } finally { if ( fis != null ) { fis . close ( ) ; } } }	read contents of a file .
public static int xtotilex ( int x , int tilegridxoffset , int tilewidth ) { x -= tilegridxoffset ; if ( x < _num ) { x += _num - tilewidth ; } return x / tilewidth ; }	converts a pixel ' s x coordinate into a horizontal tile index relative to a given tile grid layout specified by its x offset and tile width .
public input ( string name , @ inputtype int type , @ alignment int align , connection connection ) { mname = name ; mtype = type ; malign = align ; mconnection = connection ; if ( mconnection != null ) { mconnection . setinput ( this ) ; } }	creates a new input that can be added to a block .
public static bshclassmanager createclassmanager ( interpreter interpreter ) { bshclassmanager manager ; if ( capabilities . classexists ( _str ) && capabilities . classexists ( _str ) && capabilities . classexists ( _str ) ) try { class clas = class . forname ( _str ) ; manager = ( bshclassmanager ) clas . newinstance ( ) ; } catch ( exception e ) { throw new interpretererror ( _str + e ) ; } else manager = new bshclassmanager ( ) ; if ( interpreter == null ) interpreter = new interpreter ( ) ; manager . declaringinterpreter = interpreter ; return manager ; }	create a new instance of the class manager.
public int swap ( ) { if ( ! megl . eglswapbuffers ( megldisplay , meglsurface ) ) { return megl . eglgeterror ( ) ; } return egl10 . egl_success ; }	display the current render surface .
public void requestlastlogintime ( ) { operations . add ( passwordpolicystateoperationtype . get_last_login_time ) ; }	returns the last login time .
public static stream < string > wordsof ( string text ) { requirenonnull ( text ) ; return words . splitasstream ( text ) ; }	creates and returns a stream of the words in the given text.
public void add ( appinfo info ) { if ( mappfilter != null && ! mappfilter . shouldshowapp ( info . componentname ) ) { return ; } if ( findactivity ( data , info . componentname , info . user ) ) { return ; } data . add ( info ) ; added . add ( info ) ; }	add the supplied applicationinfo objects to the list , and enqueue it into the list to broadcast when notify ( ) is called.
public joiner match ( string field , object ... value ) { return match ( field , arrays . aslist ( value ) ) ; }	filter the matching objects for the one ( s ) whoose named field is equal to value.
private string removeyoutubemarkup ( string plot ) { if ( plot == null ) return null ; return plot . replaceall ( _str , _str ) ; }	removes some markup that appears on the plot for youtube videos.
private string createdasharraystring ( list < float > dashesarray ) { stringbuilder sb = new stringbuilder ( ) ; if ( dashesarray != null ) { int index = _num ; for ( float value : dashesarray ) { string str = float . tostring ( value ) ; if ( str . endswith ( _str ) ) { sb . append ( value . intvalue ( ) ) ; } else { sb . append ( value ) ; } if ( index < dashesarray . size ( ) - _num ) { sb . append ( _str ) ; } index ++ ; } } return sb . tostring ( ) ; }	creates the dash array string .
public long position ( java . sql . blob pattern , long start ) throws sqlexception { return position ( pattern . getbytes ( _num , ( int ) pattern . length ( ) ) , start ) ; }	finds the position of the given pattern in this blob .
protected synchronized t load ( ) throws ioexception { long genloaded = - _num ; ioexception ioe = null ; list < string > genfiles = new arraylist < string > ( ) ; string [ ] files ; try { files = dir . listall ( ) ; } catch ( ioexception ioe2 ) { return null ; } t loaded = null ; for ( string file : files ) { if ( file . startswith ( prefix ) ) { long gen = long . parselong ( file . substring ( prefix . length ( ) ) ) ; if ( genloaded == - _num || gen > genloaded ) { genfiles . add ( file ) ; indexinput in = dir . openinput ( file , iocontext . default ) ; try { loaded = loadone ( in ) ; } catch ( ioexception ioe2 ) { if ( ioe == null ) { ioe = ioe2 ; } } finally { in . close ( ) ; } genloaded = gen ; } } } if ( genloaded == - _num ) { if ( ioe != null ) { throw ioe ; } } else { if ( genfiles . size ( ) > _num ) { string curfilename = prefix + genloaded ; for ( string file : genfiles ) { long gen = long . parselong ( file . substring ( prefix . length ( ) ) ) ; if ( candelete ( gen ) && ! curfilename . equals ( file ) ) { dir . deletefile ( file ) ; } } } nextwritegen = _num + genloaded ; } return loaded ; }	loads the most recent generation file .
public static string readline ( inputstream in , string charset ) throws ioexception { bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; while ( _bool ) { int b = in . read ( ) ; if ( b == - _num ) { if ( baos . size ( ) == _num ) { return null ; } else { break ; } } if ( b == _str ) { break ; } if ( b != _str ) { baos . write ( b ) ; continue ; } int b2 = in . read ( ) ; if ( b2 == - _num ) { baos . write ( b ) ; break ; } if ( b2 == _str ) { break ; } baos . write ( b ) ; baos . write ( b2 ) ; } return baos . tostring ( charset ) ; }	read a line from the given stream .
public boolean checktableexists ( tabledefinition table ) { string column = null ; for ( fielddefinition field : table . getfields ( ) ) { if ( column == null ) { column = field . getname ( ) ; } else if ( field . isprimarykey ( ) ) { column = field . getname ( ) ; break ; } } string sql = _str + column + _str + table . getfullname ( ) + _str + column + _str + column ; datareadquery query = new datareadquery ( sql ) ; query . setmaxrows ( _num ) ; try { session . executequery ( query ) ; return _bool ; } catch ( exception notfound ) { return _bool ; } finally { } }	check if the table exists by issuing a select .
private int processcolon ( int length ) { if ( _hasscheme ) { if ( ! readuserpass ( length ) && _buffer . length ( ) > _num ) { _reader . goback ( ) ; _buffer . delete ( _buffer . length ( ) - _num , _buffer . length ( ) ) ; int backtrackonfail = _reader . getposition ( ) - _buffer . length ( ) + length ; if ( ! readdomainname ( _buffer . substring ( length ) ) ) { _reader . seek ( backtrackonfail ) ; readend ( readendstate . invalidurl ) ; } length = _num ; } } else if ( readscheme ( ) && _buffer . length ( ) > _num ) { _hasscheme = _bool ; length = _buffer . length ( ) ; } else if ( _buffer . length ( ) > _num && _options . hasflag ( urldetectoroptions . allow_single_level_domain ) && _reader . canreadchars ( _num ) ) { _reader . goback ( ) ; _buffer . delete ( _buffer . length ( ) - _num , _buffer . length ( ) ) ; readdomainname ( _buffer . tostring ( ) ) ; } else { readend ( readendstate . invalidurl ) ; length = _num ; } return length ; }	we found a " : " and is now trying to read either scheme , username / password.
public static boolean containssqlscriptdelimiters ( string script , string delim ) { boolean inliteral = _bool ; char [ ] content = script . tochararray ( ) ; for ( int i = _num ; i < script . length ( ) ; i ++ ) { if ( content [ i ] == _str ) { inliteral = ! inliteral ; } if ( ! inliteral && script . startswith ( delim , i ) ) { return _bool ; } } return _bool ; }	does the provided sql script contain the specified delimiter ?.
public void compress ( byte [ ] bytes , int off , int len , outputstream os ) { try { os . write ( bytes , off , len ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }	writes the bytes on the output stream .
public void assertnotjoined ( final uuid serviceid ) { m_triggers . add ( new quorumeventinvariant ( quorumeventenum . service_join , serviceid ) ) ; if ( ismember ( m_quorum . getjoined ( ) , serviceid ) ) broken ( ) ; }	establish an invariant that the specified service is a not joined with the met quorum .
public int encryptblock ( byte [ ] in , int inoff , byte [ ] out , int outoff ) throws datalengthexception , illegalstateexception { if ( ( inoff + blocksize ) > in . length ) { throw new datalengthexception ( _str ) ; } if ( ( outoff + blocksize ) > out . length ) { throw new datalengthexception ( _str ) ; } cipher . processblock ( cfbv , _num , cfboutv , _num ) ; for ( int i = _num ; i < blocksize ; i ++ ) { out [ outoff + i ] = ( byte ) ( cfboutv [ i ] ^ in [ inoff + i ] ) ; } system . arraycopy ( cfbv , blocksize , cfbv , _num , cfbv . length - blocksize ) ; system . arraycopy ( out , outoff , cfbv , cfbv . length - blocksize , blocksize ) ; return blocksize ; }	do the appropriate processing for cfb mode encryption .
public final void print ( string value ) { try { element rootelement = workdoc . getdefaultrootelement ( ) ; int deletelines = rootelement . getelementcount ( ) - linesmax ; for ( int index = _num ; index < deletelines ; index ++ ) { element elem = rootelement . getelement ( _num ) ; workdoc . remove ( elem . getstartoffset ( ) , elem . getendoffset ( ) ) ; } workdoc . insertstring ( workdoc . getlength ( ) , value , null ) ; textarea . setcaretposition ( workdoc . getlength ( ) ) ; } catch ( exception exc ) { exc . printstacktrace ( ) ; } }	prints a string without adding a / n at the end .
private void addconnectiongroups ( collection < connectiongroup > connectiongroups ) { for ( connectiongroup connectiongroup : connectiongroups ) { apiconnectiongroup parent = retrievedgroups . get ( connectiongroup . getparentidentifier ( ) ) ; if ( parent != null ) { collection < apiconnectiongroup > children = parent . getchildconnectiongroups ( ) ; if ( children == null ) { children = new arraylist < apiconnectiongroup > ( ) ; parent . setchildconnectiongroups ( children ) ; } apiconnectiongroup apiconnectiongroup = new apiconnectiongroup ( connectiongroup ) ; retrievedgroups . put ( connectiongroup . getidentifier ( ) , apiconnectiongroup ) ; children . add ( apiconnectiongroup ) ; } else logger . debug ( _str , connectiongroup . getidentifier ( ) , connectiongroup . getparentidentifier ( ) ) ; } }	adds each of the provided connection groups to the current tree as children of their respective parents.
public void loadmap ( inputstream input , string groupid ) throws exception { shapes = parser . parse ( input , groupid ) ; boundaries = new arraylist < rect2d > ( shapes . size ( ) ) ; for ( igeometric2d shape : shapes ) { boundaries . add ( shape . getbounds ( ) ) ; } }	loads a map input into this cartesian plot .
public void adddecoration ( linedecoration decoration ) { if ( decoration != null ) { decorations . add ( decoration ) ; } }	add another line decoration into the composite line decoration.
private string parselinktitle ( ) { string title = match ( link_title ) ; if ( title != null ) { return escaping . unescapestring ( title . substring ( _num , title . length ( ) - _num ) ) ; } else { return null ; } }	attempt to parse link title ( sans quotes ) , returning the string or null if no match .
@ override public void put ( double val ) { final double nn = this . n + _num ; final double delta = val - m1 ; final double delta_nn = delta / nn ; final double delta_nn2 = delta_nn * delta_nn ; final double inc = delta * delta_nn * this . n ; m4 += inc * delta_nn2 * ( nn * nn - _num * nn + _num ) + _num * delta_nn2 * m2 - _num * delta_nn * m3 ; m3 += inc * delta_nn * ( nn - _num ) - _num * delta_nn * m2 ; m2 += inc ; m1 += delta_nn ; n = nn ; min = math . min ( min , val ) ; max = math . max ( max , val ) ; }	add a single value with weight 1 . 0.
public void close ( ) { this . closed = _bool ; }	closes the command processor , canceling the current work if not finish.
public int size ( ) { return m_recentitems . size ( ) ; }	returns the number of recent items currently stored .
public jcdiagnostic warning ( lintcategory lc , string key , object ... args ) { return create ( warning , lc , enumset . noneof ( diagnosticflag . class ) , null , null , key , args ) ; }	create a warning diagnostic .
public destructurer ( final tree . pattern that , final generatejsvisitor gen , final set < declaration > directaccess , final string expvar , boolean first , final boolean forassert ) { this . gen = gen ; jsw = gen == null ? null : gen . out ; names = gen == null ? null : gen . getnames ( ) ; this . directaccess = directaccess ; this . expvar = expvar ; this . first = first ; this . forassert = forassert ; that . visit ( this ) ; if ( jsw != null && ! attribs . isempty ( ) ) { for ( value attr : attribs ) { jsw . write ( _str , names . self ( ( typedeclaration ) attr . getcontainer ( ) ) , _str , names . name ( attr ) , _str , names . name ( attr ) ) ; } } }	generate the code for the specified pattern.
@ suppresswarnings ( _str ) public void handletblsubconfigbuttondeleterequest ( requestinvocationevent event ) throws modelcontrolexception { submitcycle = _bool ; ccactiontable tbl = ( ccactiontable ) getchild ( tbl_sub_config ) ; tbl . restorestatedata ( ) ; ccactiontablemodel tblmodel = ( ccactiontablemodel ) tbl . getmodel ( ) ; integer [ ] selected = tblmodel . getselectedrows ( ) ; serializedfield szcache = ( serializedfield ) getchild ( sz_cache ) ; list list = szcache . getserializedobj ( ) ; set < string > names = new hashset < > ( selected . length * _num ) ; for ( integer index : selected ) { smsubconfig sc = ( smsubconfig ) list . get ( index ) ; names . add ( sc . getname ( ) ) ; } try { abstractauditmodel model = ( abstractauditmodel ) getmodel ( ) ; model . deleteeventhandles ( names ) ; if ( selected . length == _num ) { setinlinealertmessage ( type_info , information_message , _str ) ; } else { setinlinealertmessage ( type_info , information_message , _str ) ; } } catch ( amconsoleexception e ) { setinlinealertmessage ( type_error , error_message , e . getmessage ( ) ) ; } submitcycle = _bool ; forwardto ( ) ; }	called on request from the ui to delete an event handler .
public boolean ishealthy ( boolean doextensivechecks ) { if ( socket . isclosed ( ) || socket . isinputshutdown ( ) || socket . isoutputshutdown ( ) ) { return _bool ; } if ( framedconnection != null ) { return _bool ; } if ( doextensivechecks ) { try { int readtimeout = socket . getsotimeout ( ) ; try { socket . setsotimeout ( _num ) ; if ( source . exhausted ( ) ) { return _bool ; } return _bool ; } finally { socket . setsotimeout ( readtimeout ) ; } } catch ( sockettimeoutexception ignored ) { } catch ( ioexception e ) { return _bool ; } } return _bool ; }	returns true if this connection is ready to host new streams .
public void addcolumn ( int index , column column ) { validatecolumn ( column ) ; columnlist . add ( index , column ) ; }	adds the given column to this table at the given position in the column list.
private void init ( ) { settitle ( _str ) ; hoppropertiespanel = new hopfieldpropertiespanel ( networkpanel ) ; hoppropertiespanel . fillfieldvalues ( ) ; tablogic . setlayout ( new flowlayout ( ) ) ; tablogic . add ( hoppropertiespanel ) ; tablayout . add ( layoutpanel ) ; layoutpanel = new mainlayoutpanel ( _bool , this ) ; tabbedpane . addtab ( _str , tablogic ) ; tabbedpane . addtab ( _str , layoutpanel ) ; setcontentpane ( tabbedpane ) ; action helpaction = new showhelpaction ( hoppropertiespanel . gethelppath ( ) ) ; addbutton ( new jbutton ( helpaction ) ) ; }	initializes all components used in dialog .
private double normvector ( double [ ] z ) { double sum = _num ; for ( int i = _num ; i < problem . getnumberofobjectives ( ) ; i ++ ) { sum += z [ i ] * z [ i ] ; } return math . sqrt ( sum ) ; }	computes the norm of a vector .
public string forcegetvalueasstring ( ) { if ( mvalue == null ) { return _str ; } else if ( mvalue instanceof byte [ ] ) { if ( mdatatype == type_ascii ) { return new string ( ( byte [ ] ) mvalue , us_ascii ) ; } else { return arrays . tostring ( ( byte [ ] ) mvalue ) ; } } else if ( mvalue instanceof long [ ] ) { if ( ( ( long [ ] ) mvalue ) . length == _num ) { return string . valueof ( ( ( long [ ] ) mvalue ) [ _num ] ) ; } else { return arrays . tostring ( ( long [ ] ) mvalue ) ; } } else if ( mvalue instanceof object [ ] ) { if ( ( ( object [ ] ) mvalue ) . length == _num ) { object val = ( ( object [ ] ) mvalue ) [ _num ] ; if ( val == null ) { return _str ; } else { return val . tostring ( ) ; } } else { return arrays . tostring ( ( object [ ] ) mvalue ) ; } } else { return mvalue . tostring ( ) ; } }	gets a string representation of the value .
public int hashcode ( ) { return _num * factor . hashcode ( ) + lag ; }	probably should recheck this later .
private void convertmaximaltominimaledgerings ( list ringedges ) { for ( iterator i = ringedges . iterator ( ) ; i . hasnext ( ) ; ) { polygonizedirectededge de = ( polygonizedirectededge ) i . next ( ) ; long label = de . getlabel ( ) ; list intnodes = findintersectionnodes ( de , label ) ; if ( intnodes == null ) continue ; for ( iterator inode = intnodes . iterator ( ) ; inode . hasnext ( ) ; ) { node node = ( node ) inode . next ( ) ; computenextccwedges ( node , label ) ; } } }	convert the maximal edge rings found by the initial graph traversal into the minimal edge rings required by jts polygon topology rules .
public void removeeventlistener ( imagesharinglistener listener ) throws rcsservicenotavailableexception , rcsgenericexception { if ( mapi == null ) { throw new rcsservicenotavailableexception ( ) ; } try { weakreference < iimagesharinglistener > weakref = mimagesharinglisteners . remove ( listener ) ; if ( weakref == null ) { return ; } iimagesharinglistener rcslistener = weakref . get ( ) ; if ( rcslistener != null ) { mapi . removeeventlistener2 ( rcslistener ) ; } } catch ( exception e ) { rcsillegalargumentexception . assertexception ( e ) ; throw new rcsgenericexception ( e ) ; } }	removes a listener on image sharing events.
private void updatewavefilesize ( ) throws ioexception { bytebuffer buffer = getunsignedintegerbuffer ( mfilechannel . size ( ) - _num ) ; mfilechannel . write ( buffer , _num ) ; bytebuffer buffer2 = getunsignedintegerbuffer ( mfilechannel . size ( ) - _num ) ; mfilechannel . write ( buffer2 , _num ) ; }	updates the overall and the chunk2 sizes.
private void writejournal ( parcelfiledescriptor newstate , journal journal ) { try { fileoutputstream outstream = new fileoutputstream ( newstate . getfiledescriptor ( ) ) ; final byte [ ] journalbytes = writecheckedbytes ( journal ) ; outstream . write ( journalbytes ) ; if ( verbose ) log . v ( tag , _str + journalbytes . length + _str ) ; } catch ( ioexception e ) { log . w ( tag , _str , e ) ; } }	write the new journal to the output file.
public boolean matches ( string sa ) { if ( _length != sa . length ( ) ) return _bool ; char [ ] buffer = _buffer ; int offset = _offset ; for ( int i = _length - _num ; i >= _num ; i -- ) if ( _buffer [ _offset + i ] != sa . charat ( i ) ) return _bool ; return _bool ; }	returns true if the charsegment matches the string .
@ override public void mousereleased ( mouseevent event ) { if ( event . getsource ( ) == getcomponentdecreasespinnerbutton ( ) ) { decreasetimer . stop ( ) ; } else { increasetimer . stop ( ) ; } }	mousereleased , this will be called when the spinner button is released .
public double computemaxclassvalueusingpercentfactorperseries ( defaultchartdata chartdata , string [ ] series , double [ ] percentfactorperseries ) { double maxvalue = _num ; for ( string classname : chartdata . getclassnamesincludingdisabled ( ) ) { double total = _num ; for ( int i = _num ; i < series . length ; i ++ ) { string seriesname = series [ i ] ; if ( transposedheightsadditive ) total += percentfactorperseries [ i ] * chartdata . getvalueasdouble ( seriesname , classname ) ; else total = math . max ( total , percentfactorperseries [ i ] * chartdata . getvalueasdouble ( seriesname , classname ) ) ; } if ( total > maxvalue ) { maxvalue = total ; } } return _num * maxvalue ; }	gets the max value for a given class in a transposed chart when using percentages.
public int addchannel ( channel channel ) { int index = - _num ; switch ( channel . getchanneltype ( ) ) { case standard : mchannels . add ( channel ) ; index = mchannels . size ( ) - _num ; firetablerowsinserted ( index , index ) ; break ; case traffic : mtrafficchannels . add ( channel ) ; index = mchannels . size ( ) - _num ; break ; default : break ; } broadcast ( new channelevent ( channel , event . notification_add ) ) ; if ( channel . getenabled ( ) ) { broadcast ( new channelevent ( channel , event . request_enable ) ) ; } return index ; }	adds the channel to the model and broadcasts a channel add event.
public static string join ( object ... array ) { if ( array == null ) { return null ; } if ( array . length == _num ) { return stringpool . empty ; } if ( array . length == _num ) { return string . valueof ( array [ _num ] ) ; } final stringbuilder sb = new stringbuilder ( array . length * _num ) ; for ( int i = _num ; i < array . length ; i ++ ) { sb . append ( array [ i ] ) ; } return sb . tostring ( ) ; }	joins an array of objects into one string without separators .
public boolean hastrait ( final storetrait storetrait ) { final set < storetrait > traits = gettraits ( ) ; return null != traits && traits . contains ( storetrait ) ; }	returns true if the store can handle the provided trait and false if it cannot .
public void createsupply ( mwminoutboundline boundline , bigdecimal qtysupply ) { mproduct product = mproduct . get ( boundline . getctx ( ) , boundline . getm_product_id ( ) ) ; if ( product . isbom ( ) ) { createmo ( boundline , product , qtysupply ) ; } else if ( product . ispurchased ( ) ) { createrequisition ( boundline , product , qtysupply ) ; } }	create supply based in out bound line.
public int size ( ) { return parameters . size ( ) ; }	returns the number of parameters in this parameter file .
@ override public void loadxml ( node stepnode , list < databasemeta > databases , map < string , counter > counters ) throws kettlexmlexception { try { schemaname = xmlhandler . gettagvalue ( stepnode , _str ) ; tabelname = xmlhandler . gettagvalue ( stepnode , _str ) ; mdkeysize = xmlhandler . gettagvalue ( stepnode , _str ) ; measurecount = xmlhandler . gettagvalue ( stepnode , _str ) ; heirandkeysize = xmlhandler . gettagvalue ( stepnode , _str ) ; cubename = xmlhandler . gettagvalue ( stepnode , _str ) ; groupbyenabled = xmlhandler . gettagvalue ( stepnode , _str ) ; aggregatorclassstring = xmlhandler . gettagvalue ( stepnode , _str ) ; aggregatorstring = xmlhandler . gettagvalue ( stepnode , _str ) ; factdimlensstring = xmlhandler . gettagvalue ( stepnode , _str ) ; levelanddatatypestring = xmlhandler . gettagvalue ( stepnode , _str ) ; currentrestructnumber = integer . parseint ( xmlhandler . gettagvalue ( stepnode , _str ) ) ; partitionid = xmlhandler . gettagvalue ( stepnode , _str ) ; segmentid = xmlhandler . gettagvalue ( stepnode , _str ) ; taskno = xmlhandler . gettagvalue ( stepnode , _str ) ; } catch ( exception e ) { throw new kettlexmlexception ( _str , e ) ; } }	load the values for this step from an xml node.
public void put ( int key , e value ) { int i = binarysearch ( mkeys , _num , msize , key ) ; if ( i >= _num ) { mvalues [ i ] = value ; } else { i = ~ i ; if ( i < msize && mvalues [ i ] == deleted ) { mkeys [ i ] = key ; mvalues [ i ] = value ; return ; } if ( mgarbage && msize >= mkeys . length ) { gc ( ) ; i = ~ binarysearch ( mkeys , _num , msize , key ) ; } if ( msize >= mkeys . length ) { int n = math . max ( msize + _num , mkeys . length * _num ) ; int [ ] nkeys = new int [ n ] ; object [ ] nvalues = new object [ n ] ; system . arraycopy ( mkeys , _num , nkeys , _num , mkeys . length ) ; system . arraycopy ( mvalues , _num , nvalues , _num , mvalues . length ) ; mkeys = nkeys ; mvalues = nvalues ; } if ( msize - i != _num ) { system . arraycopy ( mkeys , i , mkeys , i + _num , msize - i ) ; system . arraycopy ( mvalues , i , mvalues , i + _num , msize - i ) ; } mkeys [ i ] = key ; mvalues [ i ] = value ; msize ++ ; } }	adds a mapping from the specified key to the specified value , replacing the previous mapping from the specified key if there was one .
public void readdata ( datainput din ) throws ioexception { reference = din . readunsignedshort ( ) ; }	readdata - - read the reference word .
public float dotproduct ( densevector df ) { float res = _num ; for ( int i = _num ; i < math . min ( size , df . getlength ( ) ) ; i ++ ) { res += u [ i ] * df . u [ i ] ; } return res ; }	return the dot product to a dense feature vector.
private void emitcode ( ) { linkedlist < instantiation > worklist = new linkedlist < instantiation > ( ) ; worklist . add ( new instantiation ( null , mainsubroutine ) ) ; insnlist newinstructions = new insnlist ( ) ; list < trycatchblocknode > newtrycatchblocks = new arraylist < trycatchblocknode > ( ) ; list < localvariablenode > newlocalvariables = new arraylist < localvariablenode > ( ) ; while ( ! worklist . isempty ( ) ) { instantiation inst = worklist . removefirst ( ) ; emitsubroutine ( inst , worklist , newinstructions , newtrycatchblocks , newlocalvariables ) ; } instructions = newinstructions ; trycatchblocks = newtrycatchblocks ; localvariables = newlocalvariables ; }	creates the new instructions , inlining each instantiation of each subroutine until the code is fully elaborated .
public static double stdev ( final list < double > list ) { return math . sqrt ( variance ( list ) ) ; }	gets the standard deviation from a list of numbers .
public void trimtosize ( ) { if ( size < array . length ) { int [ ] olddata = array ; array = new int [ size ] ; system . arraycopy ( olddata , _num , array , _num , size ) ; } }	trims the capacity of this instance to be the list ' s current size.
public void testsetbitzerooutside1 ( ) { byte abytes [ ] = { _num } ; int asign = _num ; int number = _num ; byte rbytes [ ] = { _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . setbit ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	setbit ( int n ) outside zero.
public static int compare ( date left , boolean right ) { return compare ( left , right ? _num : _num ) ; }	compares a date with a boolean.
private ibindingset [ ] decodenextchunk ( ) throws ioexception { if ( nsolutions == solutionsetcount ) { if ( log . isdebugenabled ( ) ) log . debug ( _str + name + _str + nsolutions ) ; return null ; } in . readint ( ) ; final int chunksize = in . readint ( ) ; final int bytelength = in . readint ( ) ; final byte [ ] a = new byte [ bytelength ] ; in . readfully ( a ) ; final datainputbuffer buf = new datainputbuffer ( a ) ; final ibindingset [ ] t = new ibindingset [ chunksize ] ; for ( int i = _num ; i < chunksize ; i ++ ) { t [ i ] = decoder . decodesolution ( buf , _bool ) ; if ( log . istraceenabled ( ) ) log . trace ( _str + name + _str + t [ i ] ) ; } nsolutions += chunksize ; if ( log . istraceenabled ( ) ) log . trace ( _str + name + _str + chunksize + _str + ( solutionsetstreamencoder . chunk_header_size + bytelength ) + _str + nsolutions ) ; return t ; }	read ahead and decode the next chunk of solutions .
public udpclientsocket ( logger logger ) { this . logger = logger ; try { socket = new datagramsocket ( ) ; socket . setbroadcast ( _bool ) ; socket . setsendbuffersize ( _num * _num * _num ) ; socket . setreceivebuffersize ( _num * _num * _num ) ; socket . setsotimeout ( _num ) ; } catch ( socketexception e ) { logger . severe ( _str ) ; logger . severe ( _str + e . getmessage ( ) ) ; system . exit ( _num ) ; } }	create a new udp client socket with the specified logger .
public void multiplyallvaluesby ( final double multiplyby , final int roundtype ) { for ( final t t : keyset ( ) ) { double val = mapvalues . get ( t ) ; switch ( roundtype ) { case _num : val = math . floor ( val * multiplyby ) ; break ; case _num : val = math . round ( val * multiplyby ) ; break ; case _num : val = math . ceil ( val * multiplyby ) ; break ; default : val = val * multiplyby ; break ; } put ( t , ( int ) val ) ; } }	will multiply all values by a given double.
public static boolean islevel ( level level ) { if ( level == null ) return _bool ; return level . intvalue ( ) >= s_currentlevel . intvalue ( ) ; }	is logging level logged.
protected void computefolderchildren ( file folder , boolean isincluded , string [ ] pkgname , arraylist vchildren , char [ ] [ ] inclusionpatterns , char [ ] [ ] exclusionpatterns ) throws javamodelexception { if ( isincluded ) { ipackagefragment pkg = getpackagefragment ( pkgname ) ; vchildren . add ( pkg ) ; } try { file [ ] members = folder . listfiles ( ) ; boolean hasincluded = isincluded ; int length = members . length ; if ( length > _num ) { javaproject javaproject = ( javaproject ) getjavaproject ( ) ; string sourcelevel = javaproject . getoption ( javacore . compiler_source , _bool ) ; string compliancelevel = javaproject . getoption ( javacore . compiler_compliance , _bool ) ; for ( int i = _num ; i < length ; i ++ ) { file member = members [ i ] ; string membername = member . getname ( ) ; if ( member . isdirectory ( ) ) { if ( util . isvalidfoldernameforpackage ( membername , sourcelevel , compliancelevel ) ) { string [ ] newnames = util . arrayconcat ( pkgname , manager . intern ( membername ) ) ; boolean ismemberincluded = _bool ; computefolderchildren ( member , ismemberincluded , newnames , vchildren , inclusionpatterns , exclusionpatterns ) ; } } else { if ( ! hasincluded && util . isvalidcompilationunitname ( membername , sourcelevel , compliancelevel ) ) { hasincluded = _bool ; ipackagefragment pkg = getpackagefragment ( pkgname ) ; vchildren . add ( pkg ) ; } } } } } catch ( illegalargumentexception e ) { throw new javamodelexception ( e , ijavamodelstatusconstants . element_does_not_exist ) ; } catch ( coreexception e ) { throw new javamodelexception ( e ) ; } }	starting at this folder , create package fragments and add the fragments that are not exclused to the collection of children .
public static string quote ( file input ) { return quote ( input . getabsolutepath ( ) ) ; }	quotes the absolute path of the given file iff it contains whitespace .
private void readfromnet ( ) throws ignitecheckedexception { try { innetbuf . clear ( ) ; int read = ch . read ( innetbuf ) ; if ( read == - _num ) throw new ignitecheckedexception ( _str ) ; } catch ( ioexception e ) { throw new ignitecheckedexception ( _str , e ) ; } }	read data from net buffer .
synchronized void clear ( ) { maps = new maps ( ) ; tombstones . clear ( ) ; rambytesusedcurrent . set ( _num ) ; if ( mgr != null ) { mgr . removelistener ( this ) ; mgr = null ; } }	called when this index is closed .
public synchronized void removeconsumer ( imageconsumer ic ) { ics . removeelement ( ic ) ; }	remove an imageconsumer from the list of consumers interested in data for this image .
public boolean isnavigationatbottom ( ) { return ( msmallestwidthdp >= _num || minportrait ) ; }	should a navigation bar appear at the bottom of the screen in the current device configuration ? a navigation bar may appear on the right side of the screen in certain configurations .
private void updateaperture ( int newvalue , long now ) { int previous = targetaperture ; targetaperture = newvalue ; targetaperture = math . max ( minaperture , targetaperture ) ; int maxaperture = math . min ( this . maxaperture , activesockets . size ( ) + activefactories . size ( ) ) ; targetaperture = math . min ( maxaperture , targetaperture ) ; lastaperturerefresh = now ; pendings . reset ( ( minpendings + maxpendings ) / _num ) ; if ( targetaperture != previous ) { logger . debug ( _str , pendings . value ( ) , targetaperture , previous ) ; } }	update the aperture value and ensure its value stays in the right range .
public i buildinvocation ( object protocolkey , i invocation ) throws configexception { objects . requirenonnull ( invocation ) ; invocation = buildinvocation ( invocation ) ; lrucache < object , i > invocationcache = _invocationcache ; if ( invocationcache != null ) { i oldinvocation ; oldinvocation = invocationcache . get ( protocolkey ) ; if ( oldinvocation != null && ! oldinvocation . ismodified ( ) ) { return oldinvocation ; } if ( invocation . geturllength ( ) < _maxurllength ) { invocationcache . put ( protocolkey , invocation ) ; } } return invocation ; }	builds the invocation , saving its value keyed by the protocol key .
public webresourcestatistics computemark ( webresourcestatistics wrstatistics ) { float passed = wrstatistics . getnbofpassed ( ) ; if ( passed == - _num ) { wrstatistics . setrawmark ( float . valueof ( - _num ) ) ; return wrstatistics ; } float failed = wrstatistics . getnboffailed ( ) ; float needmoreinfo = wrstatistics . getnbofnmi ( ) ; if ( failed == _num && passed == _num ) { wrstatistics . setmark ( float . valueof ( _num ) ) ; return wrstatistics ; } float rationmi = needmoreinfo / ( passed + failed + needmoreinfo ) ; float result = ( ( _num - rationmi ) * passed / ( passed + failed ) + rationmi * needmoreinfo / ( passed + failed + needmoreinfo ) ) * _num ; wrstatistics . setmark ( result ) ; return wrstatistics ; }	this method compute the mark of the audit . here is the algorithm formula : ( ( 1 - rationmi ) * passed / ( passed + failed ) + rationmi needmoreinfo / ( passed + failed + needmoreinfo ) ) * 100f where rationmi = needmoreinfo / ( passed + failed + needmoreinfo ).
public void testgcdfirstzero ( ) { byte abytes [ ] = { _num } ; byte bbytes [ ] = { _num , _num , _num , _num , - _num , _num , _num , _num , - _num , _num , _num , _num } ; int asign = _num ; int bsign = _num ; byte rbytes [ ] = { _num , _num , _num , _num , - _num , _num , _num , _num , - _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . gcd ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	gcd : the first number is zero.
public void testkingcapture ( ) throws chessparseerror { position pos = textio . readfen ( _str ) ; pos . setwhitemove ( _bool ) ; list < string > strmoves = getmovelist ( pos , _bool ) ; assertequals ( _num , strmoves . size ( ) ) ; assertequals ( _str , strmoves . get ( _num ) ) ; pos . setpiece ( position . getsquare ( _num , _num ) , piece . wbishop ) ; pos . setpiece ( position . getsquare ( _num , _num ) , piece . wpawn ) ; strmoves = getmovelist ( pos , _bool ) ; assertequals ( _num , strmoves . size ( ) ) ; assertequals ( _str , strmoves . get ( _num ) ) ; pos . setpiece ( position . getsquare ( _num , _num ) , piece . wpawn ) ; pos . setpiece ( position . getsquare ( _num , _num ) , piece . wpawn ) ; strmoves = getmovelist ( pos , _bool ) ; assertequals ( _num , strmoves . size ( ) ) ; assertequals ( _str , strmoves . get ( _num ) ) ; }	test that if king capture is possible , only a king capture move is returned in the move list .
public static list < object > validateandevaluate ( string viewname , statementcontext statementcontext , list < exprnode > expressions ) throws viewparameterexception { list < object > results = new arraylist < object > ( ) ; int expressionnumber = _num ; streamtypeservice streamtypeservice = new streamtypeserviceimpl ( statementcontext . getengineuri ( ) , _bool ) ; for ( exprnode expr : expressions ) { object result = validateandevaluateexpr ( viewname , statementcontext , expr , streamtypeservice , expressionnumber ) ; results . add ( result ) ; expressionnumber ++ ; } return results ; }	validate the view parameter expressions and evaluate the expressions returning the result object .
@ notnull public static string parserelativedirectory ( @ notnull string s ) throws svnbindexception { s = s . trim ( ) ; int length = s . length ( ) ; string result ; if ( isunescapedquote ( s , length - _num ) ) { int index = lastunescapedindexof ( s , length - _num , _str ) ; assertindex ( s , index , _str ) ; result = s . substring ( index + _num , length - _num ) ; } else { int index = lastunescapedindexof ( s , length , _str ) ; assertindex ( s , index , _str ) ; result = s . substring ( index + _num ) ; } return unescape ( result ) ; }	parses relative directory from externals definition ( in format starting from svn 1.
private string pickencoding ( inputsource inputsource ) { reader reader = inputsource . getcharacterstream ( ) ; if ( reader != null ) { return character_encoding ; } string encoding = inputsource . getencoding ( ) ; return encoding == null ? default_encoding : encoding ; }	picks an encoding for an external entity.
@ override public string generateurl ( categorydataset dataset , int series , int category ) { string url = this . prefix ; comparable serieskey = dataset . getrowkey ( series ) ; comparable categorykey = dataset . getcolumnkey ( category ) ; boolean firstparameter = ! url . contains ( _str ) ; url += firstparameter ? _str : _str ; try { url += this . seriesparametername + _str + urlencoder . encode ( serieskey . tostring ( ) , _str ) ; url += _str + this . categoryparametername + _str + urlencoder . encode ( categorykey . tostring ( ) , _str ) ; } catch ( unsupportedencodingexception ex ) { throw new runtimeexception ( ex ) ; } return url ; }	generates a url for a particular item within a series .
public boolean isidleexpire ( ) { if ( ! _lifecycle . isactive ( ) ) return _bool ; long now = currenttimeactual ( ) ; long idleexpire = _threadidleexpiretime . get ( ) ; int idlecount = _idlecount . get ( ) ; if ( _idlemin < idlecount ) { long nextidleexpire = now + _idletimeout ; if ( _idlemax < idlecount && _idlemin < _idlemax ) { _threadidleexpiretime . compareandset ( idleexpire , nextidleexpire ) ; return _bool ; } else if ( idleexpire < now && _threadidleexpiretime . compareandset ( idleexpire , nextidleexpire ) ) { return _bool ; } } return _bool ; }	returns true if the thread should expire instead of going to the idle state .
public void begindisplay ( displayevent event ) throws modelcontrolexception { identitysubjectmodel subjectmodel = getsubjectmodel ( ) ; policymodel model = ( policymodel ) getmodel ( ) ; super . begindisplay ( event ) ; ccdropdownmenu menu = ( ccdropdownmenu ) getchild ( filter_type ) ; map supportedentitytypes = model . getsupportedentitytypes ( realmname ) ; optionlist entitytypes = createoptionlist ( supportedentitytypes ) ; entitytypes . add ( _num , _str , _str ) ; menu . setoptions ( entitytypes ) ; menu . setvalue ( _str ) ; ccaddremove child = ( ccaddremove ) getchild ( values_multiple_choice_value ) ; child . restorestatedata ( ) ; optionlist selected = addremovemodel . getselectedoptionlist ( ) ; optionlist possible = helper . createoptionlist ( model . getuserssotoken ( ) , model . getuserlocale ( ) , this , getpossiblevalues ( subjectmodel , realmname ) ) ; child . resetstatedata ( ) ; addremovemodel . setavailableoptionlist ( possible ) ; }	sets the values to ui model .
private void decode64 ( bytebuffer infile , longarraypointer a ) { byte [ ] nbitplanes = new byte [ n03 ] ; byte [ ] tmagic = new byte [ _num ] ; infile . get ( tmagic ) ; if ( tmagic [ _num ] != code_magic [ _num ] || tmagic [ _num ] != code_magic [ _num ] ) { throw new runtimeexception ( _str ) ; } this . nx = infile . getint ( ) ; this . ny = infile . getint ( ) ; this . scale = infile . getint ( ) ; long sumall = infile . getlong ( ) ; infile . get ( nbitplanes ) ; dodecode64 ( infile , a , nbitplanes ) ; a . set ( _num , sumall ) ; }	char * infile ; input file long * a ; address of output tiledimageoperation [ nx ] [ ny ] int * nx , * ny ; size of output tiledimageoperation int * scale ; scale factor for digitization.
private static void createscript ( ) throws exception { class . forname ( _str ) ; connection conn = drivermanager . getconnection ( _str ) ; statement stat = conn . createstatement ( ) ; stat . execute ( _str ) ; stat . execute ( _str ) ; stat . execute ( _str ) ; stat . close ( ) ; conn . close ( ) ; }	create a script from a new database .
public static double cauchy ( ) { return math . tan ( math . pi * ( uniform ( ) - _num ) ) ; }	returns a random real number from the cauchy distribution .
public void addjobgrouptoneverdelete ( string group ) { if ( group != null ) jobgroupstoneverdelete . add ( group ) ; }	add the given group to the list of job groups that will never be deleted by this processor , even if a pre - processing - command to delete the group is encountered .
private webdoc createlayout ( webdoc doc , mworkflow wf , int activenode , mwfnode [ ] nodes , arraylist nodes_id , int [ ] [ ] imagemap ) { body b = doc . getbody ( ) ; b . addelement ( printworkflow ( activenode , wf , nodes , nodes_id , imagemap ) ) ; b . addelement ( new hr ( ) ) ; b . addelement ( printdescription ( activenode , wf , nodes , nodes_id ) ) ; b . addelement ( new br ( ) ) ; b . addelement ( printcontrolpanel ( activenode , wf , nodes , nodes_id ) ) ; return doc ; }	print the entire layout .
@ override public void requestpollread ( ) { try { requestloop ( ) ; } catch ( exception e ) { log . log ( level . warning , e . tostring ( ) , e ) ; } }	wake a connection from a select / poll keepalive .
public multimatchquerybuilder field ( string field ) { fields . add ( field ) ; return this ; }	adds a field to run the multi match against .
void encode ( outputstream os , boolean include_h ) throws ioexception { int q = params . q ; os . write ( getencoded ( f ) ) ; if ( params . basistype == ntrusigningkeygenerationparameters . basis_type_standard ) { integerpolynomial fprimeint = fprime . tointegerpolynomial ( ) ; for ( int i = _num ; i < fprimeint . coeffs . length ; i ++ ) { fprimeint . coeffs [ i ] += q / _num ; } os . write ( fprimeint . tobinary ( q ) ) ; } else { os . write ( getencoded ( fprime ) ) ; } if ( include_h ) { os . write ( h . tobinary ( q ) ) ; } }	writes the basis to an output stream.
private void signalnoacks ( ) { lock . lock ( ) ; try { allacksrcvcond . signalall ( ) ; } finally { lock . unlock ( ) ; } }	signal that currenlty there are no more pending acks .
private static string arraytostring ( int [ ] array ) { stringbuilder sb = new stringbuilder ( ) ; boolean first = _bool ; for ( int i : array ) { if ( first ) { first = _bool ; } else { sb . append ( _str ) ; } sb . append ( i ) ; } return sb . tostring ( ) ; }	converts an array into a string.
public static byte [ ] copy ( byte [ ] source , byte [ ] target ) { int len = source . length ; if ( len > target . length ) { target = new byte [ len ] ; } system . arraycopy ( source , _num , target , _num , len ) ; return target ; }	copy the contents of the source array to the target array.
public double greatcircledistance ( location location ) { if ( location == null ) { throw new illegalargumentexception ( logger . logmessage ( logger . error , _str , _str , _str ) ) ; } double lat1radians = math . toradians ( this . latitude ) ; double lon1radians = math . toradians ( this . longitude ) ; double lat2radians = math . toradians ( location . latitude ) ; double lon2radians = math . toradians ( location . longitude ) ; if ( lat1radians == lat2radians && lon1radians == lon2radians ) { return _num ; } double a = math . sin ( ( lat2radians - lat1radians ) / _num ) ; double b = math . sin ( ( lon2radians - lon1radians ) / _num ) ; double c = a * a + math . cos ( lat1radians ) * math . cos ( lat2radians ) * b * b ; double distanceradians = _num * math . asin ( math . sqrt ( c ) ) ; return double . isnan ( distanceradians ) ? _num : distanceradians ; }	computes the angular distance of the great circle path between this location and a specified location.
private list < inputsplit > parsemanifest ( filesystem fs , path manifestpath , jobconf job ) throws ioexception { list < inputsplit > splits = null ; fsdatainputstream fp = fs . open ( manifestpath ) ; jsonreader reader = new jsonreader ( new inputstreamreader ( fp , charsets . utf_8 ) ) ; reader . beginobject ( ) ; while ( reader . hasnext ( ) ) { string name = reader . nextname ( ) ; switch ( name ) { case version_json_key : job . set ( dynamodbconstants . export_format_version , string . valueof ( reader . nextint ( ) ) ) ; break ; case entries_json_key : splits = readentries ( reader , job ) ; break ; default : log . info ( _str + name ) ; reader . skipvalue ( ) ; break ; } } reader . endobject ( ) ; if ( splits == null ) { return collections . emptylist ( ) ; } return splits ; }	an example manifest file looks like { " name " : " dynamodb - export " , " version " : 3 , " entries " : [ { " url " : " s3 : / / path / to / object / 92dd1414 - a049 - 4c68 - 88fb - a23acd44907e " , " mandatory " : true } , { " url " : " s3 : / / path / to / object / ba3f3535 - 7aa1 - 4f97 - a530 - e72938bf4b76 " , " mandatory " : true } ] }.
@ override public final void readfully ( byte ba [ ] , int off , int len ) throws ioexception { dis . readfully ( ba , off , len ) ; }	read bytes until the count is satisfied .
public void fireoperatormoved ( operator operator ) { list < operator > list = new linkedlist < > ( ) ; list . add ( operator ) ; fireoperatorsmoved ( list ) ; }	fire when an operator has been moved .
public void remove ( int i ) { individuals . remove ( i ) ; }	removes a single individual .
@ override public void modifyvariableid ( string oldid , string newid ) { if ( basevar . equals ( oldid ) ) { basevar = newid . replace ( _str , _str ) ; } }	replaces occurrences of the old variable identifier oldid with the new identifier newid .
public static string repeat ( string str , int count ) { final stringbuilder result = new stringbuilder ( str . length ( ) * count ) ; for ( int i = _num ; i < count ; i ++ ) { result . append ( str ) ; } return result . tostring ( ) ; }	repeats the specified substring a number of times .
private void waitforstatechange ( int maxttw ) throws mqttexception { synchronized ( waiter ) { if ( ! donext ) { try { waiter . wait ( maxttw ) ; } catch ( interruptedexception e ) { log ( _str ) ; e . printstacktrace ( ) ; } if ( ex != null ) { throw ( mqttexception ) ex ; } } donext = _bool ; } }	wait for a maximum amount of time for a state change event to occur.
@ override public node picknode ( final inferencegraph g ) { treecache . clear ( ) ; pair < list < node > , integer > bestpath = nopath ; for ( node n : g . nodes ) { if ( ! collections . disjoint ( n . data , varstosolve ) ) { pair < list < node > , integer > path = computetreetoleafs ( n ) ; if ( path . snd < bestpath . snd ) { bestpath = path ; } } } if ( bestpath == nopath ) { throw new nodenotfoundexception ( g ) ; } return bestpath . fst . head ; }	pick the leaf that minimize cost.
public adduserfields ( ) { m_attributespecs = new arraylist < attributespec > ( ) ; }	constructs a new adduserfields.
private integer parseint ( string s , int flags ) { if ( convertcolornames ( flags ) ) { string c = descriptor . convertcolorname ( s ) ; if ( c != null ) { s = c ; } } try { if ( hasleadingzeros ( s ) ) { return null ; } else { return integer . decode ( s ) ; } } catch ( numberformatexception e ) { return null ; } }	we accept 0x and # prefixes .
private rectangle findbounds ( int ad_wf_node_id ) { for ( int i = _num ; i < m_nodes . size ( ) ; i ++ ) { wfnode node = ( wfnode ) m_nodes . get ( i ) ; if ( node . getad_wf_node_id ( ) == ad_wf_node_id ) return node . getbounds ( ) ; } return null ; }	get bounds of wf node icon.
protected void stopworkers ( collection < workerthread > workers ) { if ( workers == null ) { workers = this . workers ; } final iterator < workerthread > iter = workers . iterator ( ) ; while ( iter . hasnext ( ) ) { final workerthread worker = iter . next ( ) ; if ( ( worker . getstatus ( ) & ( workerthread . sended | workerthread . sending ) ) == _num ) { worker . signalshutdown ( ) ; runningworkers -- ; } } }	signals the given workers to end.
public arraylist < mapping > cloneframe ( ) { if ( stack [ top ] == null ) return null ; arraylist < mapping > clone = new arraylist < mapping > ( ) ; for ( mapping map = topofframe ( ) ; map != null ; map = next ( ) ) { clone . add ( map ) ; } return clone ; }	return a copy of the current frame.
protected float calculatestatetransitionpercentage ( string name , boolean flapping ) { int flapinterval = getflapinterval ( name ) ; linkedlist < boolean > list = getflaps ( name ) ; float lowweight = getflaplowweight ( name ) ; float highweight = getflaphighweight ( name ) ; float weightrange = highweight - lowweight ; float result = _num ; for ( int i = list . size ( ) - _num ; i >= _num ; i -- ) { boolean thisflap = list . get ( i ) ; if ( flapping != thisflap ) { float weight = lowweight + ( weightrange * i / ( flapinterval - _num ) ) ; result += weight ; } } return result / flapinterval ; }	calculate state transition percentage .
public static string manglename ( method method , boolean isfull ) { stringbuffer sb = new stringbuffer ( ) ; sb . append ( method . getname ( ) ) ; class [ ] params = method . getparametertypes ( ) ; for ( int i = _num ; i < params . length ; i ++ ) { sb . append ( _str ) ; sb . append ( mangleclass ( params [ i ] , isfull ) ) ; } return sb . tostring ( ) ; }	creates a unique mangled method name based on the method name and the method parameters .
private void savestate ( ) { savedstartoffset = offsetattribute . startoffset ( ) ; savedendoffset = offsetattribute . endoffset ( ) ; hasillegaloffsets = ( savedendoffset - savedstartoffset != termattribute . length ( ) ) ; savedtype = typeattribute . type ( ) ; if ( savedbuffer . length < termattribute . length ( ) ) { savedbuffer = new char [ arrayutil . oversize ( termattribute . length ( ) , character . bytes ) ] ; } system . arraycopy ( termattribute . buffer ( ) , _num , savedbuffer , _num , termattribute . length ( ) ) ; iterator . text = savedbuffer ; hassavedstate = _bool ; }	saves the existing attribute states.
public string consumeto ( string seq ) { int offset = queue . indexof ( seq , pos ) ; if ( offset != - _num ) { string consumed = queue . substring ( pos , offset ) ; pos += consumed . length ( ) ; return consumed ; } else { return remainder ( ) ; } }	pulls a string off the queue , up to but exclusive of the match sequence , or to the queue running out .
private void printoutdefinedips ( list < string > definedips ) { list < string > iplist = new arraylist < > ( ) ; for ( string ip : definedips ) { if ( ip . indexof ( _str ) != - _num ) { iplist . add ( _str + ip ) ; } else { iplist . add ( _str + ip ) ; } } collections . sort ( iplist ) ; for ( string ip : iplist ) { log . info ( ip ) ; } }	prints out the given list of defined ip addresses.
private void disposecodec ( iosession session ) { disposeencoder ( session ) ; disposedecoder ( session ) ; disposedecoderout ( session ) ; }	dispose the encoder , decoder , and the callback for the decoded messages .
private static int transpositions ( final charsequence first , final charsequence second ) { int transpositions = _num ; for ( int i = _num ; i < first . length ( ) ; i ++ ) { if ( first . charat ( i ) != second . charat ( i ) ) { transpositions ++ ; } } return transpositions / _num ; }	calculates the number of transposition between two strings .
@ override public object parseobject ( final string source , final parseposition pos ) { return parser . parseobject ( source , pos ) ; }	uses the parser format instance .
@ override public default stream < timeseriescollection > stream ( ) { return streamsupport . stream ( spliterator ( ) , _bool ) ; }	stream the tsdata contents.
private manifestmodinfo registermod ( file file , manifest manifest ) { manifestmodinfo mod = loadmod ( file , manifest ) ; if ( mod != null ) { if ( idmap . containskey ( mod . getmodid ( ) ) ) { modinfo mod2 = idmap . get ( mod . getmodid ( ) ) ; duplicates . put ( mod . getmodid ( ) , mod ) ; duplicates . put ( mod . getmodid ( ) , mod2 ) ; log . error ( _str , mod . getmodfile ( ) , mod2 . getmodfile ( ) ) ; } else { modlist . add ( mod ) ; idmap . put ( mod . getmodid ( ) , mod ) ; } } return mod ; }	constructs and registers a mod .
protected size2d arrangenn ( blockcontainer container , graphics2d g2 ) { list blocks = container . getblocks ( ) ; block b = ( block ) blocks . get ( _num ) ; size2d s = b . arrange ( g2 , rectangleconstraint . none ) ; b . setbounds ( new rectangle2d . double ( _num , _num , s . width , s . height ) ) ; return new size2d ( s . width , s . height ) ; }	arranges the blocks without any constraints.
public static boolean iscontenttype ( string contenttype , message message ) { if ( contenttype == null ) { return message . getcontenttype ( ) == null ; } else { return contenttype . equals ( message . getcontenttype ( ) ) ; } }	check whether the content - type field of the properties section ( if present ) in the given message matches the provided string ( where null matches if there is no content type present .
private static x509certificate generatecertificate ( string dn , int days , string applicationuri , keypair keys , org . opcfoundation . ua . transport . security . keypair issuerkeys , string ... hostnames ) throws generalsecurityexception , ioexception { privatekey privkey = keys . getprivate ( ) ; publickey publickey = keys . getpublic ( ) ; return generatecertificate ( dn , days , applicationuri , publickey , privkey , issuerkeys , hostnames ) ; }	create a x . 509 v3 certificate .
@ suppresswarnings ( _str ) public void handlebutton1request ( requestinvocationevent event ) throws modelcontrolexception { submitcycle = _bool ; abstractauditmodel model = ( abstractauditmodel ) getmodel ( ) ; ampropertysheet ps = ( ampropertysheet ) getchild ( property_attribute ) ; string subconfigname = ( string ) getpagesessionattribute ( audit_handler_name ) ; try { map orig = model . geteventhandlerattributevalues ( subconfigname ) ; map values = ps . getattributevalues ( orig , _bool , _bool , model ) ; model . seteventhandlerattributevalues ( subconfigname , values ) ; backtoprofileviewbean ( ) ; } catch ( amconsoleexception e ) { setinlinealertmessage ( type_error , error_message , e . getmessage ( ) ) ; forwardto ( ) ; } }	handles next button request .
private string checkalldependencies ( hashmap < string , moduledescriptor > modlist ) { for ( moduledescriptor md : modlist . values ( ) ) { string res = checkdependencies ( md , modlist ) ; if ( ! res . isempty ( ) ) { return res ; } } return _str ; }	check that all dependencies are satisfied.
public void childrenremoved ( beancontextmembershipevent bcme ) { for ( iterator it = bcme . iterator ( ) ; it . hasnext ( ) ; ) { findandundo ( it . next ( ) ) ; } }	beancontextmembership interface method . called by beancontext when children are being removed . unhooks itself from the objects that are being removed if they are contained within the frame .
public static void checkdirectoryiswriteable ( @ notnull file directory ) throws ioexception { while ( ! directory . exists ( ) || ! directory . isdirectory ( ) ) { directory = directory . getparentfile ( ) ; } if ( ! directory . canwrite ( ) ) { throw new ioexception ( _str + directory . getabsolutepath ( ) ) ; } }	find the first parent directory that exists and check if this directory is writeable .
public string tostring ( ) { stringbuilder s = new stringbuilder ( ) ; boolean appended = _bool ; if ( this . weeks != _num || appended ) { appended = _bool ; s . append ( this . weeks + _str ) ; } if ( this . days != _num || appended ) { appended = _bool ; s . append ( this . days + _str ) ; } if ( this . hours != _num || appended ) { appended = _bool ; s . append ( this . hours + _str ) ; } if ( this . minutes != _num || appended ) { appended = _bool ; s . append ( this . minutes + _str ) ; } if ( this . seconds != _num || appended ) { appended = _bool ; s . append ( this . seconds + _str ) ; } if ( this . milliseconds != _num || appended ) { appended = _bool ; s . append ( this . milliseconds + _str ) ; } return s . tostring ( ) ; }	returns the textual description of the time value .
private synchronized void writeobject ( java . io . objectoutputstream s ) throws ioexception { s . defaultwriteobject ( ) ; }	writeobject is called to save the state of the url to an objectoutputstream.
public void startentity ( string name ) throws org . xml . sax . saxexception { }	report the beginning of an entity.
public static boolean isjavakeyword ( string name ) { return tokens . contains ( name ) ; }	determines whether the given name is a java keyword.
protected string extractimporturl ( final matcher matcher ) { return matcher . group ( index_url ) ; }	override this method to provide a custom way of extracting the imported resource url .
@ override public boolean equals ( object that ) { if ( this == that ) { return _bool ; } if ( that == null ) { return _bool ; } if ( getclass ( ) != that . getclass ( ) ) { return _bool ; } collator other = ( collator ) that ; return ( ( strength == other . strength ) && ( decmp == other . decmp ) ) ; }	compares the equality of two collators .
public void runtest ( ) throws throwable { document doc ; nodelist emlist ; node emnode ; characterdata emtext ; node nullchild ; doc = ( document ) load ( _str , _bool ) ; emlist = doc . getelementsbytagname ( _str ) ; emnode = emlist . item ( _num ) ; emtext = ( characterdata ) emnode . getfirstchild ( ) ; nullchild = emtext . getfirstchild ( ) ; assertnull ( _str , nullchild ) ; }	runs the test case .
type renametypeastype ( type type ) { if ( type == null ) { return null ; } if ( type . getsort ( ) == type . object ) { string in = type . getinternalname ( ) ; string newin = renameinternaltype ( in ) ; if ( newin != in ) { return type . gettype ( _str + newin + _str ) ; } } else if ( type . getsort ( ) == type . array ) { stringbuilder sb = new stringbuilder ( ) ; for ( int n = type . getdimensions ( ) ; n > _num ; n -- ) { sb . append ( _str ) ; } sb . append ( renametype ( type . getelementtype ( ) ) ) ; return type . gettype ( sb . tostring ( ) ) ; } return type ; }	renames an object type , e.
public static void writefilelist ( xmloutput xmloutput , string tagname , iterable < file > listvalues ) throws ioexception { if ( listvalues != null ) { writefilelist ( xmloutput , tagname , listvalues . iterator ( ) ) ; } }	write a list of strings to document as elements with given tag name .
public dpolicyconstraints ( jdialog parent ) { super ( parent ) ; settitle ( res . getstring ( _str ) ) ; initcomponents ( ) ; }	creates a new dpolicyconstraints dialog .
@ preauthorize ( springevalexpressions . has_auth_system_admin ) @ override public responseentity < collection < string > > invalidatecaches ( ) { final collection < string > cachenames = cachemanager . getcachenames ( ) ; logger . info ( _str , cachenames ) ; cachenames . foreach ( null ) ; return responseentity . ok ( cachenames ) ; }	invalidates all caches for all tenants .
public static final void writebytearrayxml ( byte [ ] val , string name , xmlserializer out ) throws xmlpullparserexception , java . io . ioexception { if ( val == null ) { out . starttag ( null , _str ) ; out . endtag ( null , _str ) ; return ; } out . starttag ( null , _str ) ; if ( name != null ) { out . attribute ( null , _str , name ) ; } final int n = val . length ; out . attribute ( null , _str , integer . tostring ( n ) ) ; stringbuilder sb = new stringbuilder ( val . length * _num ) ; for ( int i = _num ; i < n ; i ++ ) { int b = val [ i ] ; int h = b > > _num ; sb . append ( h >= _num ? ( _str + h - _num ) : ( _str + h ) ) ; h = b & _num ; sb . append ( h >= _num ? ( _str + h - _num ) : ( _str + h ) ) ; } out . text ( sb . tostring ( ) ) ; out . endtag ( null , _str ) ; }	flatten a byte [ ] into an xmlserializer.
public static void writefile ( final file destination , final list < string > contents ) throws ioexception { final bufferedwriter bw = new bufferedwriter ( new filewriter ( destination ) ) ; try { for ( string line : contents ) { bw . write ( line ) ; bw . newline ( ) ; } bw . flush ( ) ; } finally { bw . close ( ) ; } }	write the strings to the file , one per line .
public void cancelrequestsbytag ( object tag , boolean mayinterruptifrunning ) { if ( tag == null ) { return ; } for ( list < requesthandle > requestlist : requestmap . values ( ) ) { if ( requestlist != null ) { for ( requesthandle requesthandle : requestlist ) { if ( tag . equals ( requesthandle . gettag ( ) ) ) requesthandle . cancel ( mayinterruptifrunning ) ; } } } }	allows you to cancel all requests currently in queue or running , by set tag , if passed tag is null , will not attempt to cancel any requests , if tag is null on requesthandle , it cannot be canceled by this call.
public static void drawsnaphorizontalmargin ( viewtransform transform , graphics2d g , int x1 , int x2 , int y1 , string text , boolean textover ) { canvas c = new canvas ( ) ; fontmetrics fm = c . getfontmetrics ( sfont ) ; g . setfont ( sfont ) ; int padding = transform . getswingdimension ( _num ) ; rectangle2d bounds = fm . getstringbounds ( text , g ) ; int tw = ( int ) bounds . getwidth ( ) ; int offset = _num * connection_arrow_size ; if ( x1 > x2 ) { int temp = x1 ; x1 = x2 ; x2 = temp ; } int w = ( ( x2 - x1 ) - ( tw + _num * padding ) ) / _num ; if ( w <= padding ) { g . drawline ( x1 , y1 , x2 , y1 ) ; if ( textover ) { offset = - _num * offset / _num ; } g . drawstring ( text , x1 + w + padding , y1 + offset ) ; } else { g . drawline ( x1 , y1 , x1 + w , y1 ) ; g . drawline ( x2 - w , y1 , x2 , y1 ) ; g . drawstring ( text , x1 + w + padding , ( int ) ( y1 + ( bounds . getheight ( ) / _num ) ) ) ; } g . drawline ( x1 , y1 - connection_arrow_size , x1 , y1 + connection_arrow_size ) ; g . drawline ( x2 , y1 - connection_arrow_size , x2 , y1 + connection_arrow_size ) ; }	draw a snap horizontal margin indicator.
public static genericrecord subsetrecord ( genericrecord record , schema subsetschema ) { return subsetrecord ( record , subsetschema , null ) ; }	the subset of the original record that contains the values for the given subset schema .
static public void queueoperation ( context context , operationinfo args ) { args . calculatescheduledtime ( ) ; synchronized ( sworkqueue ) { sworkqueue . add ( args ) ; sworkqueue . notify ( ) ; } context . startservice ( new intent ( context , asyncqueryservicehelper . class ) ) ; }	queues the operation for execution.
private static cell [ ] interpret ( string string ) { cell [ ] cells = new cell [ _num ] ; for ( int i = _num ; i < string . length ( ) ; i ++ ) { int dig = string . charat ( i ) - _str ; int col = dig % _num ; int row = dig / _num ; cells [ i ] = new cell ( col , row ) ; } return cells ; }	interpret string of digits into cells .
public shape transform ( shape shape ) { rectangle2d bounds = shape . getbounds2d ( ) ; point2d center = new point2d . double ( bounds . getcenterx ( ) , bounds . getcentery ( ) ) ; point2d newcenter = transform ( center ) ; double dx = newcenter . getx ( ) - center . getx ( ) ; double dy = newcenter . gety ( ) - center . gety ( ) ; affinetransform at = affinetransform . gettranslateinstance ( dx , dy ) ; return at . createtransformedshape ( shape ) ; }	return the supplied shape , translated to the coordinates that result from calling transform on its center.
public void list ( printwriter out , int indent ) { for ( int i = _num ; i < indent ; i ++ ) { out . print ( _str ) ; } out . println ( this ) ; }	prints out a list , starting at the specified indentation , to the specified print writer .
private void init ( ) { settitle ( _str ) ; comppropertiespanel = competitivepropertiespanel . createcompetitivepropertiespanel ( networkpanel , competitivepropspaneltype . create_group ) ; tablogic . add ( comppropertiespanel ) ; layoutpanel = new mainlayoutpanel ( _bool , this ) ; layoutpanel . setcurrentlayout ( competitivegroup . default_layout ) ; tablayout . add ( layoutpanel ) ; tabbedpane . addtab ( _str , tablogic ) ; tabbedpane . addtab ( _str , layoutpanel ) ; setcontentpane ( tabbedpane ) ; action helpaction = new showhelpaction ( comppropertiespanel . gethelppath ( ) ) ; addbutton ( new jbutton ( helpaction ) ) ; }	initializes all components used in dialog .
public static revocationstatus check ( x509certificate cert , x509certificate issuercert ) throws ioexception , certpathvalidatorexception { certid certid = null ; uri responderuri = null ; try { x509certimpl certimpl = x509certimpl . toimpl ( cert ) ; responderuri = getresponderuri ( certimpl ) ; if ( responderuri == null ) { throw new certpathvalidatorexception ( _str ) ; } certid = new certid ( issuercert , certimpl . getserialnumberobject ( ) ) ; } catch ( certificateexception | ioexception e ) { throw new certpathvalidatorexception ( _str , e ) ; } ocspresponse ocspresponse = check ( collections . singletonlist ( certid ) , responderuri , issuercert , null , null , collections . < extension > emptylist ( ) ) ; return ( revocationstatus ) ocspresponse . getsingleresponse ( certid ) ; }	obtains the revocation status of a certificate using ocsp using the most common defaults.
public static compositetype foralphacomposite ( alphacomposite ac ) { switch ( ac . getrule ( ) ) { case alphacomposite . clear : return clear ; case alphacomposite . src : if ( ac . getalpha ( ) >= _num ) { return srcnoea ; } else { return src ; } case alphacomposite . dst : return dst ; case alphacomposite . src_over : if ( ac . getalpha ( ) >= _num ) { return srcovernoea ; } else { return srcover ; } case alphacomposite . dst_over : return dstover ; case alphacomposite . src_in : return srcin ; case alphacomposite . dst_in : return dstin ; case alphacomposite . src_out : return srcout ; case alphacomposite . dst_out : return dstout ; case alphacomposite . src_atop : return srcatop ; case alphacomposite . dst_atop : return dstatop ; case alphacomposite . xor : return alphaxor ; default : throw new internalerror ( _str ) ; } }	return a compositetype object for the specified alphacomposite rule .
public void removetrackingicon ( object tag ) { if ( trackingicons != null && trackingicons . remove ( tag ) ) { repaint ( ) ; } }	removes the specified tracking icon .
private list findphonemes ( ) { set set = new hashset ( ) ; for ( int i = _num ; i < statemachine . length ; i ++ ) { if ( statemachine [ i ] instanceof finalstate ) { finalstate fstate = ( finalstate ) statemachine [ i ] ; if ( fstate . phonelist != null ) { for ( int j = _num ; j < fstate . phonelist . length ; j ++ ) { set . add ( fstate . phonelist [ j ] ) ; } } } } return new arraylist ( set ) ; }	returns a list of all the phonemes used by the lts rules .
public static file removeparent ( file parent , file file ) { string absolutepath = file . getabsolutepath ( ) ; string parentabsolutepath = parent . getabsolutepath ( ) ; string newpath = absolutepath . replace ( parentabsolutepath + _str , _str ) ; return new file ( newpath ) ; }	convert a file into a relative path from a given parent.
public static boolean almostequal ( double a , double b , double delta ) { return math . abs ( a - b ) <= delta ; }	check whether two floating point values match with a given precision .
public void endelement ( ) { nss . popcontext ( ) ; }	ends the current element context and gets back to the parent context.
public void test_fill biib ( ) { byte val = byte . max_value ; byte d [ ] = new byte [ _num ] ; arrays . fill ( d , _num , d . length , val ) ; for ( int i = _num ; i < _num ; i ++ ) asserttrue ( _str , ! ( d [ i ] == val ) ) ; for ( int i = _num ; i < d . length ; i ++ ) asserttrue ( _str , d [ i ] == val ) ; int result ; try { arrays . fill ( new byte [ _num ] , _num , _num , ( byte ) _num ) ; result = _num ; } catch ( arrayindexoutofboundsexception e ) { result = _num ; } catch ( illegalargumentexception e ) { result = _num ; } assertequals ( _str , _num , result ) ; try { arrays . fill ( new byte [ _num ] , - _num , _num , ( byte ) _num ) ; result = _num ; } catch ( arrayindexoutofboundsexception e ) { result = _num ; } catch ( illegalargumentexception e ) { result = _num ; } assertequals ( _str , _num , result ) ; try { arrays . fill ( new byte [ _num ] , _num , _num , ( byte ) _num ) ; result = _num ; } catch ( arrayindexoutofboundsexception e ) { result = _num ; } catch ( illegalargumentexception e ) { result = _num ; } assertequals ( _str , _num , result ) ; }	java . util . arrays # fill ( byte [ ] , int , int , byte ).
private jsonwriter open ( int empty , string openbracket ) throws ioexception { beforevalue ( ) ; push ( empty ) ; out . write ( openbracket ) ; return this ; }	enters a new scope by appending any necessary whitespace and the given bracket .
private double calculatelog ( double value ) { return math . log ( value ) / this . baselog ; }	calculates the log of a given value .
@ override public boolean uploadfile ( string source , string dest ) { fileinputstream fis ; try { file file = new file ( source ) ; fis = new fileinputstream ( file ) ; mdbapi . putfileoverwrite ( dest , fis , file . length ( ) , null ) ; fis . close ( ) ; return _bool ; } catch ( dropboxunlinkedexception e ) { log . d ( string . valueof ( r . string . app_name ) , _str , e ) ; return _bool ; } catch ( dropboxexception e ) { log . d ( string . valueof ( r . string . app_name ) , _str , e ) ; return _bool ; } catch ( filenotfoundexception e ) { log . d ( string . valueof ( r . string . app_name ) , _str , e ) ; return _bool ; } catch ( ioexception e ) { e . printstacktrace ( ) ; return _bool ; } }	uploads a file from source to the dropbox.
private file createzipfilehandle ( ) throws ioexception { file zipfile = file . createtempfile ( _str , _str , tmpoutputfolder . getroot ( ) ) ; asserttrue ( zipfile . delete ( ) ) ; return zipfile ; }	create a file object to which we can safely zip a file .
public boolean removehandler ( string columnname ) { if ( m_overrides == null ) return _bool ; else return m_overrides . remove ( columnname ) != null ; }	remove a custom data handler for a given column name.
public boolean isempty ( ) { return ( tag == null || tag . isempty ( ) ) && images . size ( ) == _num ; }	determines whether the tag has no fields specified . < br > < p > if there are no images we return empty if either there is no vorbistag or if there is a vorbistag but it is empty.
@ suppresswarnings ( _str ) private void restorebadges ( ) { bundle restoredbundle = savedinstancestate ; if ( restoredbundle != null ) { if ( restoredbundle . containskey ( badge_full_text_key ) ) { shouldshowbadgewithnineplus = restoredbundle . getboolean ( badge_full_text_key ) ; } if ( restoredbundle . containskey ( budges_item_bundle_key ) ) { badgesaveinstancehashmap = ( hashmap < integer , object > ) savedinstancestate . getserializable ( budges_item_bundle_key ) ; if ( badgesaveinstancehashmap != null ) { for ( integer integer : badgesaveinstancehashmap . keyset ( ) ) { badgehelper . forceshowbadge ( badgelist . get ( integer ) , ( badgeitem ) badgesaveinstancehashmap . get ( integer ) , shouldshowbadgewithnineplus ) ; } } } } }	restore available badges from saveinstance.
public void touch ( ) { touch = system . currenttimemillis ( ) ; if ( worker != null ) { worker . touch ( ) ; } }	touch the worker if you have a http connection that needs to wait .
public catalogentry ( string name , vector args ) throws catalogexception { integer itype = ( integer ) entrytypes . get ( name ) ; if ( itype == null ) { throw new catalogexception ( catalogexception . invalid_entry_type ) ; } int type = itype . intvalue ( ) ; try { integer iargs = ( integer ) entryargs . get ( type ) ; if ( iargs . intvalue ( ) != args . size ( ) ) { throw new catalogexception ( catalogexception . invalid_entry ) ; } } catch ( arrayindexoutofboundsexception e ) { throw new catalogexception ( catalogexception . invalid_entry_type ) ; } entrytype = type ; this . args = args ; }	construct a catalog entry of the specified type .
public void addmsgwaiting ( mwitype type , int count , mwiprofile profile , boolean storemessage ) { if ( count > _num ) { count = _num ; } messages_ . add ( new msgwaiting ( type , count , profile , storemessage ) ) ; }	adds a message waiting .
private void pushstack ( int newtop ) { if ( stacksize == stack . length ) { int [ ] newstack = new int [ stacksize * _num ] ; int [ ] newpathindices = new int [ stacksize * _num ] ; string [ ] newpathnames = new string [ stacksize * _num ] ; system . arraycopy ( stack , _num , newstack , _num , stacksize ) ; system . arraycopy ( pathindices , _num , newpathindices , _num , stacksize ) ; system . arraycopy ( pathnames , _num , newpathnames , _num , stacksize ) ; stack = newstack ; pathindices = newpathindices ; pathnames = newpathnames ; } stack [ stacksize ++ ] = newtop ; }	push a new scope on top of the scope stack.
private static void loghierarchy ( string prefix , classloader classloader ) { if ( ! isdiagnosticsenabled ( ) ) { return ; } classloader systemclassloader ; if ( classloader != null ) { final string classloaderstring = classloader . tostring ( ) ; logdiagnostic ( prefix + objectid ( classloader ) + _str + classloaderstring + _str ) ; } try { systemclassloader = classloader . getsystemclassloader ( ) ; } catch ( securityexception ex ) { logdiagnostic ( prefix + _str ) ; return ; } if ( classloader != null ) { stringbuffer buf = new stringbuffer ( prefix + _str ) ; for ( ; ; ) { buf . append ( objectid ( classloader ) ) ; if ( classloader == systemclassloader ) { buf . append ( _str ) ; } try { classloader = classloader . getparent ( ) ; } catch ( securityexception ex ) { buf . append ( _str ) ; break ; } buf . append ( _str ) ; if ( classloader == null ) { buf . append ( _str ) ; break ; } } logdiagnostic ( buf . tostring ( ) ) ; } }	logs diagnostic messages about the given classloader and it ' s hierarchy.
public void addgossipmember ( gossipmember member ) { gossipmembers . add ( member ) ; }	add a gossip member to the list of members to start with .
public static collection < string > logfiles ( ) { collection < string > res = new arraylist < > ( fileappenders . size ( ) ) ; for ( fileappender a : fileappenders ) res . add ( a . getfile ( ) ) ; return res ; }	gets files for all registered file appenders .
public boolean iscasesensitive ( ) { return m_casesensitivebox . isselected ( ) ; }	returns the case sensitive search switch .
public boolean isnamespacenode ( node n ) { if ( node . attribute_node == n . getnodetype ( ) ) { string attrname = n . getnodename ( ) ; return ( attrname . startswith ( _str ) || attrname . equals ( _str ) ) ; } return _bool ; }	test whether the given node is a namespace decl node.
@ override public int hashcode ( ) { int hash = type . hashcode ( ) ; if ( name != null ) hash ^= name . hashcode ( ) ; if ( actions != null ) hash ^= actions . hashcode ( ) ; return hash ; }	returns the hash code value for this object .
public subconfigmodelimpl ( httpservletrequest req , string servicename , string parentid , map map ) throws amconsoleexception { super ( req , map ) ; this . servicename = servicename ; this . parentid = parentid ; subconfigmeta = new subconfigmeta ( servicename , this ) ; subconfigmeta . setparentid ( parentid ) ; displayname = subconfigmeta . getparentdisplayname ( ) ; }	creates a simple model using default resource bundle .
@ override public boolean equals ( object obj ) { if ( ! ( obj instanceof polynomialfunction2d ) ) { return _bool ; } polynomialfunction2d that = ( polynomialfunction2d ) obj ; return arrays . equals ( this . coefficients , that . coefficients ) ; }	tests this function for equality with an arbitrary object .
public static int converttocolorint ( string a , string r , string g , string b , boolean usealpha ) { int alpha = usealpha ? integer . parseint ( a , _num ) : _num ; int red = integer . parseint ( r , _num ) ; int green = integer . parseint ( g , _num ) ; int blue = integer . parseint ( b , _num ) ; return color . argb ( usealpha ? alpha : - _num , red , green , blue ) ; }	concerts a string color ( # ff882465 ) to an int color.
@ override public void onaction ( ) { onaction ( actiontype . pick ) ; }	perform the default action .
public abstractbinarytraversal ( ibinarytreenode < t > node ) { if ( node == null ) { throw new nullpointerexception ( _str ) ; } stack . add ( new moment ( node , initialphase ( ) ) ) ; advance ( ) ; }	start the traversal at the given node .
@ override public void endelement ( string uri , string localname , string qname ) throws saxexception { if ( qname . equals ( tag_root ) ) { } else if ( qname . equals ( tag_group ) || qname . equals ( tag_property ) ) { settingsitem item = itemstack . remove ( itemstack . size ( ) - _num ) ; settingsitems . put ( item . getkey ( ) , item ) ; } else { throw new saxexception ( _str + localname ) ; } }	xml parser : closing xml tag .
public void cancelall ( ) { endpoint . cancelall ( ) ; }	cancel all observer relations that this server has established with this ' realtion ' s endpoint .
@ override public double value ( int attindex ) { int index = locateindex ( attindex ) ; if ( ( index >= _num ) && ( m_indices [ index ] == attindex ) ) { return m_attvalues [ index ] ; } else { return _num ; } }	returns an instance ' s attribute value in internal format .
public synchronized string findvalue ( string k ) { if ( k == null ) { for ( int i = nkeys ; -- i >= _num ; ) if ( keys [ i ] == null ) return values [ i ] ; } else for ( int i = nkeys ; -- i >= _num ; ) { if ( k . equalsignorecase ( keys [ i ] ) ) return values [ i ] ; } return null ; }	find the value that corresponds to this key.
public static byte [ ] decode ( string input ) throws parseexception { if ( input . length ( ) == _num ) { return new byte [ _num ] ; } byte [ ] input58 = new byte [ input . length ( ) ] ; for ( int i = _num ; i < input . length ( ) ; ++ i ) { char c = input . charat ( i ) ; int digit = c < _num ? indexes [ c ] : - _num ; if ( digit < _num ) { throw new parseexception ( _str + c + _str + i , i ) ; } input58 [ i ] = ( byte ) digit ; } int zeros = _num ; while ( zeros < input58 . length && input58 [ zeros ] == _num ) { ++ zeros ; } byte [ ] decoded = new byte [ input . length ( ) ] ; int outputstart = decoded . length ; for ( int inputstart = zeros ; inputstart < input58 . length ; ) { decoded [ -- outputstart ] = divmod ( input58 , inputstart , _num , _num ) ; if ( input58 [ inputstart ] == _num ) { ++ inputstart ; } } while ( outputstart < decoded . length && decoded [ outputstart ] == _num ) { ++ outputstart ; } return arrays . copyofrange ( decoded , outputstart - zeros , decoded . length ) ; }	decodes the given base58 string into the original data bytes .
templatesubpatternassociation ( elemtemplate template , steppattern pattern , string pat ) { m_pattern = pat ; m_template = template ; m_steppattern = pattern ; m_targetstring = m_steppattern . gettargetstring ( ) ; m_wild = m_targetstring . equals ( _str ) ; }	construct a match pattern from a pattern and template .
public boolean delete ( ) throws ioexception { if ( closed . compareandset ( _bool , _bool ) ) { close ( _bool ) ; boolean success = allocatednodeslist . delete ( ) ; success &= niofile . delete ( ) ; return success ; } return _bool ; }	closes the btree and then deletes its data files .
public static boolean hasnoprefix ( final annotatedtypemirror annotype ) { if ( annotype == null ) { return _bool ; } for ( annotationmirror mirror : annotype . getannotations ( ) ) { if ( ! hasnoprefix ( mirror ) ) { return _bool ; } } return _bool ; }	checks to see if an annotated type has no prefix.
public static void tryformatsatisfiability ( string format ) throws illegalformatexception { @ suppresswarnings ( _str ) string unused = string . format ( format , ( object [ ] ) null ) ; }	throws an exception if the format is not syntactically valid .
public static ignitelogger logger ( gridkernalcontext ctx , atomicreference < ignitelogger > logref , class < ? > cls ) { ignitelogger log = logref . get ( ) ; if ( log == null ) { logref . compareandset ( null , ctx . log ( cls ) ) ; log = logref . get ( ) ; } return log ; }	initializes logger into / from log reference passed in .
public byte receiveonebyte ( ) { log . d ( tag , _str ) ; try { acquirelock ( ) ; mserversocket . receive ( mreceivepacket ) ; log . d ( tag , _str + ( _num + mreceivepacket . getdata ( ) [ _num ] ) ) ; return mreceivepacket . getdata ( ) [ _num ] ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return byte . min_value ; }	receive one byte from the port and convert it into string.
public static list < constraintviolation > check ( resource resource , progressmonitor monitor ) { return check ( resource , spin . constraint , null , monitor ) ; }	checks all spin : constraints for a given resource .
public static boolean isvalidimdbid ( string imdbid ) { if ( stringutils . isempty ( imdbid ) ) { return _bool ; } return imdbid . matches ( _str ) ; }	checks if is valid imdb id .
protected void showrecordedvideo ( ) { string abspath = mcurrentvideofile . getabsolutepath ( ) ; intent intent = new intent ( this , playeractivity . class ) ; intent . putextra ( playeractivity . extra_video_path , abspath ) ; startactivity ( intent ) ; mcurrentvideofile = null ; }	move to the activity where we show the recorded video.
private void write ( coordinate [ ] coords , int level , stringbuffer buf ) { startline ( _str , level , buf ) ; boolean isnewline = _bool ; for ( int i = _num ; i < coords . length ; i ++ ) { if ( i > _num ) { buf . append ( tuple_separator ) ; } if ( isnewline ) { startline ( _str , level , buf ) ; isnewline = _bool ; } write ( coords [ i ] , buf ) ; if ( ( i + _num ) % maxcoordinatesperline == _num && i < coords . length - _num ) { buf . append ( _str ) ; isnewline = _bool ; } } buf . append ( _str ) ; }	takes a list of coordinates and converts it to kml.
protected static boolean isintendedexception ( exception e , class < ? > clazz ) { final string message = e . getmessage ( ) ; return ( ! textutils . isempty ( message ) && message . startswith ( clazz . getname ( ) ) ) ; }	checks if the exception is one of the intended server side exception that has been thrown over the aidl layer .
public static void swappivot ( densedoublematrix2d source , long diag , densedoublematrix2d s , densedoublematrix2d t ) { long swaprow = diag ; long swapcol = diag ; double maxvalue = math . abs ( source . getdouble ( diag , diag ) ) ; long rows = source . getrowcount ( ) ; long cols = source . getcolumncount ( ) ; double abs = _num ; for ( long row = diag ; row < rows ; row ++ ) { for ( long col = diag ; col < cols ; col ++ ) { abs = math . abs ( source . getdouble ( row , col ) ) ; if ( abs > maxvalue ) { maxvalue = abs ; swaprow = row ; swapcol = col ; } } } if ( swaprow != diag ) { swaprows ( source , swaprow , diag ) ; swaprows ( t , swaprow , diag ) ; } if ( swapcol != diag ) { swapcols ( source , swapcol , diag ) ; swapcols ( s , swapcol , diag ) ; } }	swap the matrices so that the largest value is on the pivot.
public boolean canpopupoverlaptaskbar ( ) { boolean result = _bool ; try { securitymanager sm = system . getsecuritymanager ( ) ; if ( sm != null ) { sm . checkpermission ( securityconstants . awt . set_window_always_on_top_permission ) ; } } catch ( securityexception se ) { result = _bool ; } return result ; }	returns whether popup is allowed to be shown above the task bar.
public job createjobforcreatecluster ( string activitixmlclasspathresourcename , list < parameter > parameters ) throws exception { return createjobforcreatecluster ( activitixmlclasspathresourcename , parameters , null ) ; }	creates a job based on the specified activiti xml classpath resource location and defines a emr cluster definition .
public static list < string > findmainclasses ( file rootdir ) throws ioexception { list < string > ret = new arraylist < > ( ) ; if ( ! rootdir . exists ( ) ) { return ret ; } if ( ! rootdir . isdirectory ( ) ) { throw new illegalargumentexception ( string . format ( _str , rootdir . getpath ( ) ) ) ; } findclasses ( ret , rootdir , rootdir . getabsolutepath ( ) + _str ) ; return ret ; }	find all classes below a certain directory which contain main ( ) classes.
private static string validatexml ( string string ) throws ioexception { for ( int i = _num ; i < string . length ( ) ; i ++ ) { char ch = string . charat ( i ) ; if ( ! ( ch == _num || ch == _num || ch == _num || ch >= _num ) ) throw new ioexception ( _str + integer . tostring ( ch ) + _str ) ; } return string ; }	validates whether the given string only contains valid xml characters .
public void readvalues ( ) { readvalues ( _bool ) ; }	read values from settings.
protected static boolean isaccesscompatiblewithinstantrun ( int access ) { return ( ( access & opcodes . acc_abstract ) == _num ) && ( ( access & opcodes . acc_bridge ) == _num ) ; }	defines when a method access flags are compatible with instantrun technology.
protected asn1sequence ( asn1encodable [ ] array ) { for ( int i = _num ; i != array . length ; i ++ ) { seq . addelement ( array [ i ] ) ; } }	create a sequence containing a vector of objects .
public threadedlistenermanager ( executorservice pool ) { managernumber = manager_count . getandincrement ( ) ; this . pool = pool ; }	configures with specified thread pool.
private void readobject ( objectinputstream in ) throws ioexception , classnotfoundexception { in . defaultreadobject ( ) ; if ( choicelimits . length != choiceformats . length ) { throw new invalidobjectexception ( _str ) ; } }	after reading an object from the input stream , do a simple verification to maintain class invariants .
private void computeoffsetsegment ( linesegment seg , int side , double distance , linesegment offset ) { int sidesign = side == position . left ? _num : - _num ; double dx = seg . p1 . x - seg . p0 . x ; double dy = seg . p1 . y - seg . p0 . y ; double len = math . sqrt ( dx * dx + dy * dy ) ; double ux = sidesign * distance * dx / len ; double uy = sidesign * distance * dy / len ; offset . p0 . x = seg . p0 . x - uy ; offset . p0 . y = seg . p0 . y + ux ; offset . p1 . x = seg . p1 . x - uy ; offset . p1 . y = seg . p1 . y + ux ; }	compute an offset segment for an input segment on a given side and at a given distance.
@ suppresswarnings ( _str ) public synchronized e elementat ( int location ) { if ( location < elementcount ) { return ( e ) elementdata [ location ] ; } throw arrayindexoutofboundsexception ( location , elementcount ) ; }	returns the element at the specified location in this vector .
private list < qosrule > createqosrules ( jsonobject qossettings ) { list < qosrule > rules = new arraylist < > ( ) ; if ( qossettings . containskey ( json_field_rules ) ) { jsonobject jsonrules = qossettings . getjsonobject ( json_field_rules ) ; for ( string urlpatternregexp : jsonrules . fieldnames ( ) ) { log . debug ( _str + urlpatternregexp ) ; jsonobject jsonrule = jsonrules . getjsonobject ( urlpatternregexp ) ; pattern urlpattern = pattern . compile ( urlpatternregexp ) ; qosrule rule = new qosrule ( urlpattern ) ; boolean addrule = _bool ; if ( jsonrule . containskey ( _str ) ) { addrule = _bool ; rule . setreject ( jsonrule . getdouble ( _str ) ) ; } if ( jsonrule . containskey ( _str ) ) { addrule = _bool ; rule . setwarn ( jsonrule . getdouble ( _str ) ) ; } if ( addrule ) { rules . add ( rule ) ; } else { log . warn ( _str , urlpatternregexp ) ; } } } return rules ; }	creates the qos rule objects from the given jsonobject and returns them in a list .
private static final byte [ ] tooctets ( int identifier , string text ) { byte [ ] s = text . getbytes ( standardcharsets . utf_8 ) ; byte [ ] base = octetutils . tooctets ( attributetype . vendor_specific , identifier ) ; int maxtextspace = attribute . max_attribute_length - base . length ; byte [ ] octets ; if ( s . length > maxtextspace ) { octets = new byte [ attribute . max_attribute_length ] ; system . arraycopy ( s , _num , octets , base . length , attribute . max_attribute_length - base . length ) ; } else { octets = new byte [ base . length + s . length ] ; system . arraycopy ( s , _num , octets , base . length , s . length ) ; } system . arraycopy ( base , _num , octets , _num , base . length ) ; octets [ _num ] = ( byte ) octets . length ; return octets ; }	custom implementation of tooctets to ensure a string value too long will be truncated properly in view of the space needed by the type , length , and identifier .
private double formatdoublevalue ( double value , int places ) { bigdecimal bd = new bigdecimal ( value ) ; bd = bd . setscale ( places , roundingmode . half_up ) ; return bd . doublevalue ( ) ; }	this function returns decimals value for a double.
@ override public void flush ( ) throws ioexception { out . flush ( ) ; }	flush all buffered data to the underlying output stream .
static boolean iscoctetstringvalid ( string value , int maxlength ) { if ( value == null ) return _bool ; if ( value . length ( ) >= maxlength ) return _bool ; return _bool ; }	validate the c - octet string .
public rectangle2d createproperbounds ( double x1 , double y1 , double x2 , double y2 ) { double x = math . min ( x1 , x2 ) ; double y = math . min ( y1 , y2 ) ; double w = math . abs ( x1 - x2 ) ; double h = math . abs ( y1 - y2 ) ; return new rectangle2d . double ( x , y , w , h ) ; }	create a bounding rectangle given the four coordinates , where the upper left corner of the rectangle is the minimum x , y values and the width and height are the difference between xs and ys .
public void addcleargraphdatabutton ( ) { jbutton clearbutton = new jbutton ( _str ) ; clearbutton . setaction ( rasterplotactions . getcleargraphaction ( this ) ) ; buttonpanel . add ( clearbutton ) ; }	add button for clearing graph data .
public static float normalizedlevenshteindistance ( string s , string t ) { float d = levenshteindistance ( s , t ) ; int max = math . max ( s . length ( ) , t . length ( ) ) ; return d / ( float ) max ; }	from https : / / en.
private void createfile ( int number , string extention ) { for ( int i = _num ; i < number ; i ++ ) { try { bufferedwriter output = new bufferedwriter ( new filewriter ( new file ( textinputfolder + _str + string . valueof ( i ) + extention ) ) ) ; try { output . write ( _str ) ; output . write ( string . valueof ( i ) ) ; } finally { output . close ( ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } } }	this private method just creates a number of files with a specific extension .
public boolean isanimal ( ) { return typestring . contains ( suffix_animal ) ; }	determine if the expression is an animal .
public static string unifylineseparators ( string s , string ls ) { if ( s == null ) { return null ; } if ( ls == null ) { ls = system . getproperty ( _str ) ; } if ( ! ( ls . equals ( _str ) || ls . equals ( _str ) || ls . equals ( _str ) ) ) { throw new illegalargumentexception ( _str ) ; } int length = s . length ( ) ; stringbuilder buffer = new stringbuilder ( length ) ; for ( int i = _num ; i < length ; i ++ ) { if ( s . charat ( i ) == _str ) { if ( ( i + _num ) < length && s . charat ( i + _num ) == _str ) { i ++ ; } buffer . append ( ls ) ; } else if ( s . charat ( i ) == _str ) { buffer . append ( ls ) ; } else { buffer . append ( s . charat ( i ) ) ; } } return buffer . tostring ( ) ; }	parses the given string and replaces all occurrences of ' \ n ' , ' \ r ' and ' \ r \ n ' with the given line separator .
public void addnotification ( pingnotification notification ) { notifications . add ( notification ) ; }	adds a ping notification to the current list .
public list < datastore > createnfsdatastore ( clustercomputeresource cluster , filesharerestrep filesystem , filesystemexportparam export , uri datacenterid , string datastorename ) { addnfsdatastoretag ( filesystem , export , datacenterid , datastorename ) ; list < datastore > datastores = lists . newarraylist ( ) ; string fileserver = stringutils . substringbefore ( export . getmountpoint ( ) , _str ) ; string mountpath = stringutils . substringafter ( export . getmountpoint ( ) , _str ) ; for ( hostsystem host : cluster . gethosts ( ) ) { datastores . add ( execute ( new createnfsdatastore ( host , fileserver , mountpath , datastorename ) ) ) ; addaffectedresource ( filesystem ) ; executionutils . clearrollback ( ) ; } return datastores ; }	creates an nfs datastore for the hosts in the cluster.
private void checksize ( final int i ) { if ( i >= max_size ) { final int old_size = max_size ; max_size += increment_size ; if ( max_size <= i ) { max_size = i + increment_size + _num ; } final string [ ] temp = items ; items = new string [ max_size ] ; system . arraycopy ( temp , _num , items , _num , old_size ) ; increment_size = incrementsize ( increment_size ) ; } }	check the size of the array and increase if needed.
public album ( context context , uri mediauri ) { super ( ) ; media . add ( _num , new media ( context , mediauri ) ) ; setcurrentphotoindex ( _num ) ; }	used for open an image from an unknown content storage.
static void checkinternalname ( final string name , final int start , final int end , final string msg ) { int max = end == - _num ? name . length ( ) : end ; try { int begin = start ; int slash ; do { slash = name . indexof ( _str , begin + _num ) ; if ( slash == - _num || slash > max ) { slash = max ; } checkidentifier ( name , begin , slash , null ) ; begin = slash + _num ; } while ( slash != max ) ; } catch ( illegalargumentexception unused ) { throw new illegalargumentexception ( _str + msg + _str + name ) ; } }	checks that the given substring is a valid internal class name .
protected void initializetaskdone ( set < taskimagecontainer > tasks , optional < runnable > runnablewhendone ) { set < capturesession > sessionset = new hashset < > ( ) ; map < capturesession , integer > sessiontaskcount = new hashmap < > ( ) ; for ( taskimagecontainer task : tasks ) { sessionset . add ( task . msession ) ; integer currentcount = sessiontaskcount . get ( task . msession ) ; if ( currentcount == null ) { sessiontaskcount . put ( task . msession , _num ) ; } else { sessiontaskcount . put ( task . msession , currentcount + _num ) ; } } synchronized ( mshadowtaskmap ) { for ( capturesession capturesession : sessionset ) { blocksignalprotocol protocol = new blocksignalprotocol ( ) ; protocol . setcount ( sessiontaskcount . get ( capturesession ) ) ; final imageshadowtask shadowtask ; shadowtask = new imageshadowtask ( protocol , capturesession , runnablewhendone ) ; mshadowtaskmap . put ( capturesession , shadowtask ) ; mprocessingtaskconsumer . enqueuetask ( shadowtask ) ; } } }	for a given set of starting tasks , initialize the associated sessions with a proper blocking semaphore and value of number of tasks to be run.
public static string unquote ( string name ) { return isquoted ( name ) ? name . substring ( _num , name . length ( ) - _num ) : name ; }	return the unquoted version of name ( stripping the start and end ' ` ' characters if present ) .
public boolean hasleader ( string playername ) { return ( leader != null ) && leader . equals ( playername ) ; }	is the specified player the leader of this group ?.
synchronized void redo ( rtedittext editor ) { stack < operation > redostack = getredostack ( editor ) ; if ( ! redostack . empty ( ) ) { stack < operation > undostack = getundostack ( editor ) ; operation op = redostack . pop ( ) ; push ( op , undostack ) ; op . redo ( editor ) ; while ( ! redostack . empty ( ) && op . canmerge ( redostack . peek ( ) ) ) { op = redostack . pop ( ) ; push ( op , undostack ) ; op . redo ( editor ) ; } } }	re - do the last undone operation for a specific rich text editor.
private static < t > t reportjoin ( object r ) { if ( r instanceof altresult ) { throwable x ; if ( ( x = ( ( altresult ) r ) . ex ) == null ) return null ; if ( x instanceof cancellationexception ) throw ( cancellationexception ) x ; if ( x instanceof completionexception ) throw ( completionexception ) x ; throw new completionexception ( x ) ; } @ suppresswarnings ( _str ) t t = ( t ) r ; return t ; }	decodes outcome to return result or throw unchecked exception .
public int write ( final protein protein ) throws ioexception { checkentryhierarchy ( ) ; if ( entryhierarchy != null ) { for ( proteinxref xref : protein . getcrossreferences ( ) ) { final simpleprotein simpleprotein = simpleprotein . valueof ( protein , xref , entryhierarchy ) ; if ( simpleprotein != null ) { final simplehash model = buildmodelmap ( simpleprotein , entryhierarchy ) ; writer writer = null ; try { final template temp = freemarkerconfig . gettemplate ( freemarkertemplate ) ; checktempdirectory ( tempdirectory ) ; if ( ! tempdirectory . endswith ( file . separator ) ) { tempdirectory = tempdirectory + file . separator ; } urlfriendlyidgenerator gen = urlfriendlyidgenerator . getinstance ( ) ; string urlfriendlyid = gen . generate ( xref . getidentifier ( ) ) ; final path newresultfile = paths . get ( tempdirectory + urlfriendlyid + _str ) ; resultfiles . add ( newresultfile ) ; writer = files . newbufferedwriter ( newresultfile , characterset ) ; temp . process ( model , writer ) ; writer . flush ( ) ; } catch ( templateexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } finally { if ( writer != null ) { writer . close ( ) ; } } } } } return _num ; }	writes out protein view to an zipped and compressed html file .
public void testcasts ( ) { string sql_begin = _str ; string [ ] [ ] sql_tests = new string [ ] [ ] { { _str , _str } , { _str , _str } , { _str , _str } , { _str , _str } , { _str , _str } , { _str , _str } , { _str , _str } } ; string sql_end = _str ; stringbuffer sql = new stringbuffer ( sql_begin ) ; stringbuffer sqle = new stringbuffer ( sql_begin ) ; for ( int i = _num ; i < sql_tests . length ; i ++ ) { if ( i > _num ) { sql . append ( _str ) ; sqle . append ( _str ) ; } sql . append ( sql_tests [ i ] [ _num ] ) ; sqle . append ( sql_tests [ i ] [ _num ] ) ; } sql . append ( sql_end ) ; sqle . append ( sql_end ) ; string [ ] r = convert . convert ( sql . tostring ( ) ) ; assertequals ( sqle . tostring ( ) , r [ _num ] ) ; }	test bf [ 1824256 ] convert sql casts.
public void writeintosptklf0file ( string sptkfilename ) throws ioexception { ledataoutputstream lf0data = new ledataoutputstream ( new bufferedoutputstream ( new fileoutputstream ( sptkfilename ) ) ) ; for ( int i = _num ; i < this . contour . length ; i ++ ) { double f0val = contour [ i ] ; if ( contour [ i ] == _num ) { lf0data . writefloat ( negative_maximum ) ; } else { lf0data . writefloat ( ( float ) math . log ( contour [ i ] ) ) ; } } lf0data . flush ( ) ; lf0data . close ( ) ; }	write contour into a lf0 file in sptk format.
public static thread start ( long timeout ) { return start ( thread . currentthread ( ) , timeout ) ; }	start monitoring the current thread .
public static element find ( node parent , string name ) { nodelist list = parent . getchildnodes ( ) ; for ( int i = _num ; i < list . getlength ( ) ; i ++ ) { node n = list . item ( i ) ; if ( n instanceof element ) { element e = ( element ) n ; if ( name . equals ( e . getattribute ( _str ) ) ) { return e ; } } element r = find ( n , name ) ; if ( r != null ) { return r ; } } return null ; }	find an element by its " id " attribute ; null if no element is found .
public static re mkstar ( re x ) { if ( x . equals ( epsilon ) || x . equals ( empty ) ) { return epsilon ; } re res = new re ( reop . star ) ; res . unaryarg = x ; return res ; }	construct a regular expression matching the kleene closure of the language matched by the argument regular expression .
public void remove ( final object element ) { set oldselection = new hashset ( selection ) ; boolean rv = selection . remove ( element ) ; if ( rv ) { fireselectionchanged ( oldselection , selection ) ; } oldselection = null ; }	remove the specified element from the selection .
@ override public void mouseclicked ( mouseevent evt ) { delegate . mousemoved ( evt ) ; }	pass mouseevent straight through to delegate.
public void printf ( locale locale , string format , object ... args ) { out . printf ( locale , format , args ) ; out . flush ( ) ; }	prints a formatted string to this output stream , using the specified locale , format string , and arguments , and then flushes this output stream .
public void transform ( source xmlsource , result outputtarget ) throws transformerexception { transform ( xmlsource , outputtarget , _bool ) ; }	process the source tree to the output result .
public void testsortsattributesbeforeelements ( ) throws exception { xppdom dom1 = xppfactory . builddom ( _str ) ; xppdom dom2 = xppfactory . builddom ( _str ) ; assertequals ( - _num , comparator . compare ( dom1 , dom2 ) ) ; assertequals ( _str , xpath . get ( ) ) ; assertequals ( _num , comparator . compare ( dom2 , dom1 ) ) ; assertequals ( _str , xpath . get ( ) ) ; }	tests comparison sorts attributes before elements .
public void addsuffix ( dalvinsn insn ) { suffix . add ( insn ) ; }	adds an instruction to the output suffix .
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options.
private void closeselector ( ) { if ( selector . isopen ( ) ) { if ( log . isdebugenabled ( ) ) log . debug ( _str ) ; for ( selectionkey key : selector . keys ( ) ) u . close ( key . channel ( ) , log ) ; if ( log . isdebugenabled ( ) ) log . debug ( _str ) ; u . close ( selector , log ) ; } }	close selector if needed .
public static number sub ( number a , number b ) { if ( isfloatingpoint ( a ) || isfloatingpoint ( b ) ) { return a . doublevalue ( ) - b . doublevalue ( ) ; } else { return a . longvalue ( ) - b . longvalue ( ) ; } }	returns the value of subtracting the first from the second number .
public builder requiredattributes ( final string ... nameoroids ) { return requiredattributes ( arrays . aslist ( nameoroids ) ) ; }	adds the provided required attributes .
private void showhistorydialog ( ) { jblist commandslist = new jblist ( historyutils . getcommandsfromhistory ( ) ) ; commandslist . setcellrenderer ( new historylistcellrenderer ( ) ) ; commandslist . setemptytext ( _str ) ; commandslist . setselectionmode ( listselectionmodel . single_selection ) ; string [ ] buttons = { _str , _str } ; int result = joptionpane . showoptiondialog ( toolwindowcontent , commandslist , _str , joptionpane . yes_no_cancel_option , joptionpane . plain_message , null , buttons , buttons [ _num ] ) ; if ( result == _num ) { updateuifromcommand ( ( command ) commandslist . getselectedvalue ( ) ) ; } }	shows up history dialog.
public int size ( ) { return count . get ( ) ; }	returns the number of elements in this queue .
protected static byte [ ] read ( inputstream is ) throws ioexception { final boolean close = _bool ; bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; try { int i ; while ( ( i = is . read ( ) ) != - _num ) { baos . write ( i ) ; } } finally { try { if ( close ) { is . close ( ) ; } baos . close ( ) ; } catch ( exception ex ) { log . warn ( _str + ex , ex ) ; } } return baos . tobytearray ( ) ; }	read a stream into a byte [ ].
public static < t > streamable < t > frompublisher ( final publisher < ? extends t > publisher ) { objects . requirenonnull ( publisher ) ; final seqsubscriber < t > sub = seqsubscriber . subscriber ( ) ; publisher . subscribe ( sub ) ; return fromstream ( sub . stream ( ) ) ; }	construct a lazyfuturestream from an publisher.
public protobufconnection ( listener < messagetype > handler , messagetype prototype , int maxmessagesize , int timeoutmillis ) { this . handler = handler ; this . prototype = prototype ; this . maxmessagesize = math . min ( maxmessagesize , integer . max_value - _num ) ; settimeoutenabled ( _bool ) ; setsockettimeout ( timeoutmillis ) ; }	creates a new protobuf handler .
private response < bitmap > doparse ( networkresponse response ) { byte [ ] data = response . data ; bitmapfactory . options decodeoptions = new bitmapfactory . options ( ) ; bitmap bitmap = null ; if ( mmaxwidth == _num && mmaxheight == _num ) { decodeoptions . inpreferredconfig = mdecodeconfig ; bitmap = bitmapfactory . decodebytearray ( data , _num , data . length , decodeoptions ) ; } else { decodeoptions . injustdecodebounds = _bool ; bitmapfactory . decodebytearray ( data , _num , data . length , decodeoptions ) ; int actualwidth = decodeoptions . outwidth ; int actualheight = decodeoptions . outheight ; int desiredwidth = getresizeddimension ( mmaxwidth , mmaxheight , actualwidth , actualheight , mscaletype ) ; int desiredheight = getresizeddimension ( mmaxheight , mmaxwidth , actualheight , actualwidth , mscaletype ) ; decodeoptions . injustdecodebounds = _bool ; decodeoptions . insamplesize = findbestsamplesize ( actualwidth , actualheight , desiredwidth , desiredheight ) ; bitmap tempbitmap = bitmapfactory . decodebytearray ( data , _num , data . length , decodeoptions ) ; if ( tempbitmap != null && ( tempbitmap . getwidth ( ) > desiredwidth || tempbitmap . getheight ( ) > desiredheight ) ) { bitmap = bitmap . createscaledbitmap ( tempbitmap , desiredwidth , desiredheight , _bool ) ; tempbitmap . recycle ( ) ; } else { bitmap = tempbitmap ; } } if ( bitmap == null ) { return response . error ( new parseerror ( response ) ) ; } else { return response . success ( bitmap , httpheaderparser . parsecacheheaders ( response ) ) ; } }	the real guts of parsenetworkresponse.
public notification find ( integer notificationid ) { notification notification = new notification ( context , notificationid , null ) ; if ( notification . getattributes ( ) == null ) notification . loadattributesfrompreferences ( ) ; return notification ; }	get a notification by its id .
public greengradient ( int maxcount ) { this . maxcount = maxcount ; factor = maxcount / math . log ( maxcount ) ; }	setup the green gradient.
public static void writehistogram ( tdoubledoublehashmap distr , string filename ) throws filenotfoundexception , ioexception { bufferedwriter awriter = ioutils . getbufferedwriter ( filename ) ; awriter . write ( _str ) ; awriter . newline ( ) ; double [ ] keys = distr . keys ( ) ; arrays . sort ( keys ) ; for ( double key : keys ) { awriter . write ( string . valueof ( key ) ) ; awriter . write ( _str ) ; awriter . write ( string . valueof ( distr . get ( key ) ) ) ; awriter . newline ( ) ; } awriter . close ( ) ; }	writes a histogram as a tab - separated file with two columns : the first column indicates the bin key ( e.
public static < t > completionstage < t > dereference ( completionstage < ? extends completionstage < t > > stage ) { return stage . thencompose ( identity . instance ) ; }	this takes a stage of a stage of a value and returns a plain stage of a value .
public static number plus ( character left , number right ) { return numbernumberplus . plus ( integer . valueof ( left ) , right ) ; }	add a character and a number.
public static string clipstringifnecessary ( jcomponent c , fontmetrics fm , string string , int availtextwidth ) { if ( ( string == null ) || ( string . equals ( _str ) ) ) { return _str ; } int textwidth = swingutilities2 . stringwidth ( c , fm , string ) ; if ( textwidth > availtextwidth ) { return swingutilities2 . clipstring ( c , fm , string , availtextwidth ) ; } return string ; }	clips the passed in string to the space provided .
public boolean removeelement ( object obj ) { synchronized ( actions ) { if ( allowtochange ) { boolean result = actions . remove ( obj ) ; if ( actions . isempty ( ) ) { if ( headtask != null ) { cancel ( ) ; } } return result ; } } return _bool ; }	removes an element from this instantrunnable .
public void addslide ( @ nonnull fragment fragment ) { fragments . add ( fragment ) ; addbackgroundcolor ( color . transparent ) ; pageradapter . notifydatasetchanged ( ) ; }	add a slide to the intro.
public static string [ ] wrapstring ( @ nonnull string str , int maxwidth , @ nullable string [ ] output ) { if ( output == null ) { output = new string [ ( int ) ( ( str . length ( ) / maxwidth ) * _num + _num ) ] ; } int linestart = _num ; int arrayindex = _num ; int i ; for ( i = _num ; i < str . length ( ) ; i ++ ) { char c = str . charat ( i ) ; if ( c == _str ) { output = addstring ( output , str . substring ( linestart , i ) , arrayindex ++ ) ; linestart = i + _num ; } else if ( i - linestart == maxwidth ) { output = addstring ( output , str . substring ( linestart , i ) , arrayindex ++ ) ; linestart = i ; } } if ( linestart != i || i == _num ) { output = addstring ( output , str . substring ( linestart ) , arrayindex ++ , output . length + _num ) ; } if ( arrayindex < output . length ) { output [ arrayindex ] = null ; } return output ; }	splits the given string into lines using on any embedded newlines , and wrapping the text as needed to conform to the given maximum line width . < p / > this uses and assumes unix - style newlines.
private static floatbuffer createvertexarray ( float [ ] coords ) { bytebuffer bb = bytebuffer . allocatedirect ( coords . length * _num ) ; bb . order ( byteorder . nativeorder ( ) ) ; floatbuffer fb = bb . asfloatbuffer ( ) ; fb . put ( coords ) ; fb . position ( _num ) ; return fb ; }	allocates a direct float buffer , and populates it with the vertex data .
protected void publish ( ) throws mqttexception , ioexception { sampleclientpub = new sampleasyncwait ( url , clientidpub , cleansession , quietmode , username , password ) ; if ( sampleclientpub != null ) { string topic = _str ; int qos = _num ; string message = _str ; try { sampleclientpub . publish ( topic , qos , message . getbytes ( ) ) ; } catch ( throwable e ) { e . printstacktrace ( ) ; } } }	publish / send a message to an mqtt server.
public static void cleandirectory ( file directory ) throws ioexception { if ( ! directory . exists ( ) ) { string message = directory + _str ; throw new illegalargumentexception ( message ) ; } if ( ! directory . isdirectory ( ) ) { string message = directory + _str ; throw new illegalargumentexception ( message ) ; } file [ ] files = directory . listfiles ( ) ; if ( files == null ) { throw new ioexception ( _str + directory ) ; } ioexception exception = null ; for ( file file : files ) { try { forcedelete ( file ) ; } catch ( ioexception ioe ) { exception = ioe ; } } if ( null != exception ) { throw exception ; } }	cleans a directory without deleting it .
private object [ ] invwmsubband ( image img , double [ ] wm , int n , double threshold ) { int m = _num ; double z = _num ; double v = _num ; for ( int i = _num ; i < img . getwidth ( ) * img . getheight ( ) ; i ++ ) { if ( img . getdata ( ) [ i ] > threshold ) { z += ( img . getdata ( ) [ i ] * wm [ i % n ] ) ; v += math . abs ( img . getdata ( ) [ i ] ) ; m ++ ; } } return new object [ ] { m , z , v } ; }	extracts the watermark data from subband.
public static void movetodirectory ( file src , file destdir , boolean createdestdir ) throws ioexception { if ( src == null ) { throw new nullpointerexception ( _str ) ; } if ( destdir == null ) { throw new nullpointerexception ( _str ) ; } if ( ! src . exists ( ) ) { throw new filenotfoundexception ( _str + src + _str ) ; } if ( src . isdirectory ( ) ) { movedirectorytodirectory ( src , destdir , createdestdir ) ; } else { movefiletodirectory ( src , destdir , createdestdir ) ; } }	moves a file or directory to the destination directory.
private static tungstenproperties loadsecuritypropertiesfromfile ( string propertiesfilelocation ) throws configurationexception { tungstenproperties securityprops = null ; fileinputstream securityconfigurationfileinputstream = null ; if ( propertiesfilelocation == null && clusterconfiguration . getclusterhome ( ) == null ) { throw new configurationexception ( _str ) ; } file securitypropertiesfile ; if ( propertiesfilelocation == null ) { file clusterconfdirectory = clusterconfiguration . getdir ( clusterconfiguration . getglobalconfigdirname ( clusterconfiguration . getclusterhome ( ) ) ) ; securitypropertiesfile = new file ( clusterconfdirectory . getpath ( ) , securityconf . security_properties_file_name ) ; } else { securitypropertiesfile = new file ( propertiesfilelocation ) ; } try { securityprops = new tungstenproperties ( ) ; securityconfigurationfileinputstream = new fileinputstream ( securitypropertiesfile ) ; securityprops . load ( securityconfigurationfileinputstream , _bool ) ; closesecurityconfigurationfileinputstream ( securityconfigurationfileinputstream ) ; } catch ( filenotfoundexception e ) { string msg = messageformat . format ( _str , securitypropertiesfile . getpath ( ) ) ; logger . debug ( msg , e ) ; throw new configurationexception ( msg ) ; } catch ( ioexception e ) { string msg = messageformat . format ( _str , securitypropertiesfile . getpath ( ) , e . getmessage ( ) ) ; logger . debug ( msg , e ) ; throw new configurationexception ( msg ) ; } finally { closesecurityconfigurationfileinputstream ( securityconfigurationfileinputstream ) ; } if ( logger . isdebugenabled ( ) ) { logger . debug ( messageformat . format ( _str , securitypropertiesfile . getpath ( ) ) ) ; } securityprops . put ( securityconf . security_properties_parent_file_location , securitypropertiesfile . getabsolutepath ( ) ) ; return securityprops ; }	loads security related properties from a file.
public static void close ( inputstream in ) { try { if ( in != null ) { in . close ( ) ; } } catch ( ioexception ioe ) { } }	closes an input stream .
private synchronized void clearscanfiles ( ) { if ( ( allfiles != null ) && ( allfiles . size ( ) > _num ) ) { iterator it = allfiles . iterator ( ) ; file file = null ; while ( it . hasnext ( ) ) { file = ( file ) it . next ( ) ; file . delete ( ) ; } allfiles . clear ( ) ; } }	limpia la lista de ficheros del escaneo.
public static void execandcheckoutput ( processbuilder builder , string expectedout , string expectederr ) throws exception { process process = builder . start ( ) ; executorservice executorservice = executors . newfixedthreadpool ( _num ) ; try { future < string > errfuture = executorservice . submit ( streamtostringcallable ( process . geterrorstream ( ) ) ) ; future < string > outfuture = executorservice . submit ( streamtostringcallable ( process . getinputstream ( ) ) ) ; assertequals ( expectedout , outfuture . get ( _num , timeunit . seconds ) ) ; assertequals ( expectederr , errfuture . get ( _num , timeunit . seconds ) ) ; } finally { executorservice . shutdown ( ) ; process . waitfor ( ) ; } }	starts the process described by ' builder ' , and asserts that it sees ' expectedout ' on stdout and ' expectederr ' on stderr.
private void startfilebasedmerge ( ) throws carbonsortkeyandgroupbyexception { try { executorservice . shutdown ( ) ; executorservice . awaittermination ( _num , timeunit . days ) ; datasorterandwriterexecutorservice . shutdown ( ) ; datasorterandwriterexecutorservice . awaittermination ( _num , timeunit . days ) ; } catch ( interruptedexception e ) { throw new carbonsortkeyandgroupbyexception ( _str , e ) ; } }	below method will be used to start file based merge.
public void insertupdate ( documentevent e ) { if ( ! dirty ) { setdirty ( _bool ) ; } }	callback for when text is inserted into the document .
public datetimeparseexception ( string message , charsequence parseddata , int errorindex ) { super ( message ) ; this . parsedstring = parseddata . tostring ( ) ; this . errorindex = errorindex ; }	constructs a new exception with the specified message .
private boolean areparallelsiblings ( component source , component target , int axis ) { componentinfo sourceinfo = getcomponentinfo ( source ) ; componentinfo targetinfo = getcomponentinfo ( target ) ; spring sourcespring ; spring targetspring ; if ( axis == horizontal ) { sourcespring = sourceinfo . horizontalspring ; targetspring = targetinfo . horizontalspring ; } else { sourcespring = sourceinfo . verticalspring ; targetspring = targetinfo . verticalspring ; } arraylist sourcepath = tmpparallelset ; sourcepath . clear ( ) ; spring spring = sourcespring . getparent ( ) ; while ( spring != null ) { sourcepath . add ( spring ) ; spring = spring . getparent ( ) ; } spring = targetspring . getparent ( ) ; while ( spring != null ) { if ( sourcepath . contains ( spring ) ) { sourcepath . clear ( ) ; while ( spring != null ) { if ( spring instanceof parallelgroup ) { return _bool ; } spring = spring . getparent ( ) ; } return _bool ; } spring = spring . getparent ( ) ; } sourcepath . clear ( ) ; return _bool ; }	returns true if the two components have a common parallelgroup ancestor along the particular axis .
protected object readobjectimpl ( class cl ) throws ioexception { try { object obj = cl . newinstance ( ) ; if ( _refs == null ) _refs = new arraylist ( ) ; _refs . add ( obj ) ; hashmap fieldmap = getfieldmap ( cl ) ; int code = read ( ) ; for ( ; code >= _num && code != _str ; code = read ( ) ) { unread ( ) ; object key = readobject ( ) ; field field = ( field ) fieldmap . get ( key ) ; if ( field != null ) { object value = readobject ( field . gettype ( ) ) ; field . set ( obj , value ) ; } else { object value = readobject ( ) ; } } if ( code != _str ) throw expect ( _str , code ) ; try { method method = cl . getmethod ( _str , new class [ _num ] ) ; return method . invoke ( obj , new object [ _num ] ) ; } catch ( exception e ) { } return obj ; } catch ( ioexception e ) { throw e ; } catch ( exception e ) { throw new ioexceptionwrapper ( e ) ; } }	reads an object from the input stream.
public void testcase18 ( ) { byte abytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num } ; byte bbytes [ ] = { _num } ; byte rbytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num } ; int asign = _num ; int bsign = _num ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . subtract ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _num , result . signum ( ) ) ; }	subtract zero from a number.
public static plaintext plain ( int text ) { return plain ( integer . tostring ( text ) ) ; }	creates a new plaintext component with the given int.
public static boolean istoday ( calendar _calendar ) { calendar now = calendar . getinstance ( ) ; if ( now . get ( calendar . day_of_month ) == _calendar . get ( calendar . day_of_month ) ) { if ( now . get ( calendar . month ) == _calendar . get ( calendar . month ) ) { if ( now . get ( calendar . year ) == _calendar . get ( calendar . year ) ) { return _bool ; } } } return _bool ; }	allows to know if a given calendar instance is set today.
public void start ( ) { managedpairs . add ( createport ( ) ) ; fixnames ( ) ; singleports . addobserver ( observer , _bool ) ; for ( ports < m > ports : multiportslist ) { ports . addobserver ( observer , _bool ) ; } }	creates an initial port and starts to listen .
protected void sprint ( double doublefield ) { sprint ( string . valueof ( doublefield ) ) ; }	pretty printing accumulator function for doubles.
public static bitmap convertyuvimagetobitmap ( @ nonnull final yuvimage yuvimage ) { bytearrayoutputstream out = new bytearrayoutputstream ( ) ; yuvimage . compresstojpeg ( new rect ( _num , _num , yuvimage . getwidth ( ) , yuvimage . getheight ( ) ) , _num , out ) ; byte [ ] imagebytes = out . tobytearray ( ) ; try { out . close ( ) ; } catch ( ioexception e ) { log . e ( log_tag , _str , e ) ; } return bitmapfactory . decodebytearray ( imagebytes , _num , imagebytes . length ) ; }	note : this conversion procedure is sloppy and may result in jpeg compression artifacts.
public double read ( string value ) { return double . valueof ( value ) ; }	this method is used to convert the string value given to an appropriate representation.
public boolean hasfeature ( string feature , string version ) { if ( feature . equals ( _str ) ) { return version == null || version . equals ( _str ) || version . equals ( _str ) ; } return _bool ; }	test if the dom implementation implements a specific feature .
private storageport assignportbasedonusage ( list < storageport > matchingtargetports , map < storageport , integer > portusage ) { storageport foundport = null ; for ( storageport matchedport : matchingtargetports ) { if ( portusage . get ( matchedport ) == null ) { portusage . put ( matchedport , _num ) ; } if ( foundport == null ) { foundport = matchedport ; } else { if ( portusage . get ( matchedport ) < portusage . get ( foundport ) ) { foundport = matchedport ; } } } if ( foundport != null ) { portusage . put ( foundport , portusage . get ( foundport ) + _num ) ; } return foundport ; }	doing the best possible assignment.
public externalevent nextevent ( ) { if ( queue . size ( ) == _num ) { return new externalevent ( double . max_value ) ; } externalevent ee = queue . get ( nexteventindex ) ; nexteventindex ++ ; if ( nexteventindex >= queue . size ( ) ) { queue = readevents ( nrofpreload ) ; nexteventindex = _num ; } return ee ; }	returns the next event in the queue or externalevent with time of double . max_value if there are no events left.
public void appendtobuffer ( stringbuilder buf ) { iterator < double [ ] > iter = points . iterator ( ) ; while ( iter . hasnext ( ) ) { double [ ] data = iter . next ( ) ; for ( int i = _num ; i < data . length ; i ++ ) { if ( i > _num ) { buf . append ( _str ) ; } buf . append ( data [ i ] ) ; } if ( iter . hasnext ( ) ) { buf . append ( _str ) ; } } }	append the polygon to the buffer .
public void updatecombobox ( jcombobox < track > box ) { box . removeallitems ( ) ; box . additem ( null ) ; list < track > tracks = gettrackbynamelist ( null ) ; for ( track track : tracks ) { box . additem ( track ) ; } }	updates a jcombobox with all of the track locations for this location .
public refactoringsessiontransformer ( final boolean projects ) { fprojects = projects ; }	creates a new refactoring session transformer .
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public compareresult open ( ) { final contentcomparator [ ] comparatorarray = comparators . toarray ( new contentcomparator [ comparators . size ( ) ] ) ; final customcompareeditorinput input = new customcompareeditorinput ( modified , original , ancestor , comparatorarray , compareconfiguration , externalcomparehandler ) ; if ( compareconfiguration . islefteditable ( ) || compareconfiguration . isrighteditable ( ) ) { compareconfiguration . setproperty ( _str , boolean . false ) ; input . setalwaysdirty ( alwaysdirty ) ; } input . addsavelistener ( new proxycomparesavelistener ( ) ) ; log . info ( messageformat . format ( _str , getlabelnoloc ( modified ) , getlabelnoloc ( original ) ) ) ; compareuitype . opencompareui ( input ) ; final boolean contentsidentical = ( input . getcompareresult ( ) == null ) ; final boolean contentssaved = ( input . getsavedcontents ( ) . length > _num ) ; return new compareresult ( contentsidentical , input . wasokpressed ( ) , contentssaved ) ; }	opens this compare operation , showing the compare ui , returning the result details of the comparison.
protected void addresource ( string resource ) { if ( ! stringutils . isempty ( resource ) ) { resources . add ( resource ) ; } }	import a resources into view.
public static boolean isnumeric ( string maybenumeric ) { return maybenumeric != null && maybenumeric . matches ( _str ) ; }	checks whether a string contains only number or not using a regex . i like this approach since it doesn ' t need to parse it into a numerical variable which may not fit into any particularly type.
public static string encode ( string string ) { byte [ ] bytes ; try { bytes = string . getbytes ( preferred_encoding ) ; } catch ( unsupportedencodingexception e ) { bytes = string . getbytes ( ) ; } return encodebytes ( bytes ) ; }	encode string as a byte array in base64 annotation .
public final long addandget ( long delta ) { for ( ; ; ) { long current = get ( ) ; long next = current + delta ; if ( compareandset ( current , next ) ) return next ; } }	atomically adds the given value to the current value .
default long now ( timeunit unit ) { return unit . convert ( system . currenttimemillis ( ) , timeunit . milliseconds ) ; }	returns the " current time " notion of this scheduler .
private final void append ( list < ? super namevaluepair > l , final string k , final string v ) { if ( v != null ) l . add ( new namevaluepair ( k , v ) ) ; }	appends a namevaluepair of k / v to l if v is non - null .
protected properties createproperties ( url location ) throws ioexception { inputstream is = null ; if ( location != null ) { is = location . openstream ( ) ; } properties tmpproperties = new properties ( ) ; if ( is != null ) { tmpproperties . load ( is ) ; } return tmpproperties ; }	reads the file at the given location and creates a properties file from the contents .
protected double calcplanweight ( final t plan , final double maxscore ) { if ( plan . getscore ( ) == null ) { return double . nan ; } double weight = math . exp ( this . beta * ( plan . getscore ( ) - maxscore ) ) ; if ( weight < min_weight ) weight = min_weight ; return weight ; }	calculates the weight of a single plan .
public static boolean isextension ( string filename , collection < string > extensions ) { if ( filename == null ) { return _bool ; } if ( extensions == null || extensions . isempty ( ) ) { return indexofextension ( filename ) == - _num ; } string fileext = getextension ( filename ) ; for ( string extension : extensions ) { if ( fileext . equals ( extension ) ) { return _bool ; } } return _bool ; }	checks whether the extension of the filename is one of those specified.
void findvalue ( ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str + label ( ) ) ; } for ( int i = _num ; i < _value . getitemcount ( ) ; i ++ ) { string choice = _value . getitemat ( i ) ; settinglist sl = choicehash . get ( choice ) ; if ( sl . match ( ) ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str + i ) ; } _value . setselecteditem ( choice ) ; return ; } } if ( log . isdebugenabled ( ) ) { log . debug ( _str ) ; } }	suspect underlying variables have changed value ; check.
public void mkdir ( string key ) throws ioexception { key = key . replace ( _str , _str ) ; if ( key . endswith ( _str ) && ! key . equals ( _str ) ) { throw new invalidparameterexception ( _str ) ; } string [ ] split = key . split ( _str ) ; stringbuilder builder = new stringbuilder ( ) ; for ( string s : split ) { builder . append ( s ) ; if ( ! s . isempty ( ) && ! exists ( builder . tostring ( ) ) ) { zkstate . set ( builder . tostring ( ) , null ) ; } builder . append ( _str ) ; } }	creates the znode if it does not exist.
public double calculatelog ( double value ) { return math . log ( value ) / this . baselog ; }	calculates the log of the given value , using the current base .
public static vector3 pow ( vector3 o , double power ) { return new vector3 ( math . pow ( o . x , power ) , math . pow ( o . y , power ) , math . pow ( o . z , power ) ) ; }	raises the x , y , and z values of a vector3 to the given power .
public datagrampacket responsereceive ( ) throws ioexception { byte [ ] buf = new byte [ _num ] ; datagrampacket dp = new datagrampacket ( buf , buf . length ) ; datagramsocket . receive ( dp ) ; return dp ; }	used to receive ssdp response packet.
public static float [ ] temperaturetorgb ( int degreesk ) { int k = mathutils . constrain ( degreesk , _num , _num ) ; float a = ( k % _num ) / _num ; int i = ( ( k - _num ) / _num ) * _num ; return new float [ ] { interp ( i , a ) , interp ( i + _num , a ) , interp ( i + _num , a ) } ; }	convert a color temperature value ( in kelvin ) to a rgb units as floats.
public advancedstatemap . builder withname ( function < propertiesmap , string > mapper ) { this . namemapper = mapper ; return this ; }	sets the state mapper to set the name to the value returned by the specified mapper.
public void test_fill ziiz ( ) { boolean val = _bool ; boolean d [ ] = new boolean [ _num ] ; arrays . fill ( d , _num , d . length , val ) ; for ( int i = _num ; i < _num ; i ++ ) asserttrue ( _str , ! ( d [ i ] == val ) ) ; for ( int i = _num ; i < d . length ; i ++ ) asserttrue ( _str , d [ i ] == val ) ; try { arrays . fill ( d , _num , _num , val ) ; fail ( _str ) ; } catch ( illegalargumentexception e ) { } try { arrays . fill ( d , - _num , _num , val ) ; fail ( _str ) ; } catch ( arrayindexoutofboundsexception e ) { } try { arrays . fill ( d , _num , d . length + _num , val ) ; fail ( _str ) ; } catch ( arrayindexoutofboundsexception e ) { } }	java . util . arrays # fill ( boolean [ ] , int , int , boolean ).
@ override public synchronized boolean addall ( collection < ? extends e > collection ) { return addall ( elementcount , collection ) ; }	adds the objects in the specified collection to the end of this vector .
public string sprintf ( ) { final iterator < conversionspecification > e = vfmt . iterator ( ) ; conversionspecification cs ; char c ; final stringbuilder sb = new stringbuilder ( ) ; while ( e . hasnext ( ) ) { cs = e . next ( ) ; c = cs . getconversioncharacter ( ) ; if ( c == _str ) { sb . append ( cs . getliteral ( ) ) ; } else if ( c == _str ) { sb . append ( _str ) ; } } return sb . tostring ( ) ; }	format nothing . just use the control string .
default string resourcename ( string tablename , string type ) { return string . format ( resource_name , tablename , type ) ; }	get the name of a relation between an object and a resource.
protected void updatecomboboxesloadchange ( ) { if ( autotrackcheckbox . isselected ( ) ) { updatelocationtrackcombobox ( ) ; } if ( autodestinationtrackcheckbox . isselected ( ) ) { updatedestinationtrackcombobox ( ) ; } if ( autofinaldesttrackcheckbox . isselected ( ) ) { updatefinaldestination ( ) ; } }	update locations if load changes.
public string removeclasscolumntiptext ( ) { return _str ; }	returns the tip text for this property.
public static string join ( namedvalue [ ] values , string separator ) { stringbuilder buff = new stringbuilder ( ) ; for ( int i = _num ; i < values . length ; i ++ ) { buff . append ( values [ i ] ) ; if ( i < values . length - _num ) buff . append ( separator ) ; } return buff . tostring ( ) ; }	joins multiple namedvalues into a single string.
protected string sourceclass ( attribute c , double [ ] dist ) { if ( c . isnominal ( ) ) { return integer . tostring ( utils . maxindex ( dist ) ) ; } else { return double . tostring ( dist [ _num ] ) ; } }	returns the value as string out of the given distribution.
public void done ( ) throws ioexception { printer . flush ( ) ; }	description of the method.
int requestgroupdata ( char groupnum ) { setcurrdatagroup ( groupnum ) ; currgrpitems = knowngrpitems . get ( integer . valueof ( getcurrdatagroup ( ) ) ) ; char [ ] payload = { groupnum } ; return ( writetelegram ( payload , cmd_group_read , null ) ) ; }	send request to read group data.
protected string encodecookie ( serializablehttpcookie cookie ) { if ( cookie == null ) return null ; bytearrayoutputstream os = new bytearrayoutputstream ( ) ; try { objectoutputstream outputstream = new objectoutputstream ( os ) ; outputstream . writeobject ( cookie ) ; } catch ( ioexception e ) { log . d ( log_tag , _str , e ) ; return null ; } return bytearraytohexstring ( os . tobytearray ( ) ) ; }	serializes cookie object into string.
public long skip ( long bytes ) throws ioexception { if ( closed ) { throw new ioexception ( _str ) ; } int av = available ( ) ; if ( av == _num ) { av = makeavailable ( ) ; if ( av == _num ) { return _num ; } } long res = math . min ( av , bytes ) ; head += res ; return res ; }	skips the given number of bytes .
public void resume ( ) { mpaused = _bool ; mlastframetime = system . currenttimemillis ( ) ; invalidate ( ) ; }	resumes the ken burns effect animation .
public void testsubtractdiffscalenegpos ( ) { string a = _str ; int ascale = - _num ; string b = _str ; int bscale = _num ; string c = _str ; int cscale = _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; bigdecimal result = anumber . subtract ( bnumber ) ; assertequals ( _str , c , result . tostring ( ) ) ; assertequals ( _str , cscale , result . scale ( ) ) ; }	subtract two numbers of different scales ; the first is negative.
void addtoprototypecallback ( ) ;	generates a function that adds members to a prototype , then calls it .
public alltoallpanel ( alltoall connector , networkpanel networkpanel ) { super ( ) ; this . connection = connector ; allowselfconnectpanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; allowselfconnectpanel . add ( new jlabel ( _str ) ) ; allowselfconnectpanel . add ( allowselfconnectchkbx ) ; fillfieldvalues ( ) ; add ( allowselfconnectpanel ) ; }	construct a new all to all panel .
public boolean functionavailable ( string ns , string funcname ) throws javax . xml . transform . transformerexception { try { if ( funcname == null ) { string fmsg = xslmessages . createxpathmessage ( xpatherrorresources . er_arg_cannot_be_null , new object [ ] { _str } ) ; throw new nullpointerexception ( fmsg ) ; } javax . xml . namespace . qname myqname = new qname ( ns , funcname ) ; javax . xml . xpath . xpathfunction xpathfunction = resolver . resolvefunction ( myqname , _num ) ; if ( xpathfunction == null ) { return _bool ; } return _bool ; } catch ( exception e ) { return _bool ; } }	is the extension function available ?.
private void allocate_sections ( int p_section_count ) { section_list . ensurecapacity ( p_section_count ) ; while ( section_list . size ( ) < p_section_count ) { section_list . add ( new mazesearchelement ( ) ) ; } }	allocates and initializes p_section_count sections.
public boolean refreshneeded ( ) { return this . softttl < system . currenttimemillis ( ) ; }	true if a refresh is needed from the original data source .
public static byte [ ] randombytes ( int length ) { byte [ ] bytes = new byte [ length ] ; seeded_random . nextbytes ( bytes ) ; return bytes ; }	generate an array of random bytes.
public weightdistribution ( columnexampletable columntable , int [ ] selection , int attributenumber ) { calculatelabelweights ( columntable , selection , attributenumber ) ; leftlabelweights = new double [ totallabelweights . length ] ; leftweight = _num ; totalweight = gettotalweight ( totallabelweights ) ; if ( hasmissings ) { missingsweight = gettotalweight ( missingslabelweights ) ; rightweight = totalweight - missingsweight ; rightlabelweights = arraydifference ( totallabelweights , missingslabelweights ) ; } else { missingsweight = _num ; rightweight = totalweight ; rightlabelweights = new double [ totallabelweights . length ] ; system . arraycopy ( totallabelweights , _num , rightlabelweights , _num , totallabelweights . length ) ; } }	initializes the counting arrays with the start distribution .
public static string removeextension ( string filename ) { int index = filename . lastindexof ( _str ) ; if ( index == - _num ) { return filename ; } else { return filename . substring ( _num , index ) ; } }	removes the extensions of the given file name .
public void delete ( string name ) throws ioexception { if ( name . equalsignorecase ( key_id ) ) { id = null ; } else { throw new ioexception ( _str + _str ) ; } encodethis ( ) ; }	delete the attribute value .
public static dataframe normalize ( dataframe dataframe , double min , double max ) { return normalize ( dataframe , min , max , collections . < string > emptylist ( ) ) ; }	scale based on min , max.
boolean issocketscheme ( string scheme ) { for ( string p : urihelper . socket_schemes ) { if ( p . equals ( scheme ) ) { return _bool ; } } return _bool ; }	internal utility method to determine if the given scheme should use semicolons ( ; ) for query separator instead of ampersand ( & ).
private static void addleafwithnonexistingparents ( spatial root , spatial leaf ) { if ( ! ( root instanceof node ) ) { logger . log ( level . warning , _str , new object [ ] { leaf . getname ( ) , root . getname ( ) } ) ; return ; } for ( spatial s = leaf ; s . getparent ( ) != null ; s = s . getparent ( ) ) { spatial parent = s . getparent ( ) ; spatial other = findtaggedspatial ( root , parent ) ; if ( other == null ) { continue ; } if ( other instanceof node ) { logger . log ( level . info , _str , new object [ ] { s , other , root , leaf } ) ; for ( spatial spt = leaf ; spt != parent ; spt = spt . getparent ( ) ) { spt . setuserdata ( original_name , spt . getname ( ) ) ; spt . setuserdata ( original_path , getspatialpath ( spt ) ) ; spt = spt . getparent ( ) ; } node othernode = ( node ) other ; othernode . attachchild ( s ) ; logger . log ( loglevel . userinfo , _str , new object [ ] { other . getname ( ) , leaf . getname ( ) } ) ; return ; } else { logger . log ( level . warning , _str , new object [ ] { leaf , other , root } ) ; } } logger . log ( level . warning , _str , leaf . getname ( ) ) ; }	adds a leaf to a spatial , including all nonexisting parents .
private void adjustblocklisteners ( list < oblock > oldrange , list < oblock > newrange , tracker tracker ) { iterator < oblock > iter = newrange . iterator ( ) ; while ( iter . hasnext ( ) ) { oblock b = iter . next ( ) ; if ( oldrange . contains ( b ) ) { oldrange . remove ( b ) ; continue ; } addblocklistener ( b , tracker ) ; } iter = oldrange . iterator ( ) ; while ( iter . hasnext ( ) ) { removeblocklistener ( iter . next ( ) , tracker ) ; } }	do venn diagram between the two sets.
static public string hexencode ( byte [ ] ainput ) { stringbuffer result = new stringbuffer ( ) ; final char [ ] digits = { _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str } ; for ( int idx = _num ; idx < ainput . length ; ++ idx ) { byte b = ainput [ idx ] ; result . append ( digits [ ( b & _num ) > > _num ] ) ; result . append ( digits [ b & _num ] ) ; } return result . tostring ( ) ; }	the byte [ ] returned by messagedigest does not have a nice textual representation , so some form of encoding is usually performed.
private static size clampsize ( size original , double maxarea , size maxsize ) { if ( original . getwidth ( ) * original . getheight ( ) < maxarea && original . getwidth ( ) < maxsize . getwidth ( ) && original . getheight ( ) < maxsize . getheight ( ) ) { return original ; } double ratio = math . min ( math . sqrt ( maxarea / original . area ( ) ) , _num ) ; int width = ( int ) math . round ( original . width ( ) * ratio ) ; int height = ( int ) math . round ( original . height ( ) * ratio ) ; if ( width > maxsize . width ( ) || height > maxsize . height ( ) ) { return computefitwithinsize ( original , maxsize ) ; } return new size ( width , height ) ; }	given a size , compute a value such that it will downscale the original size to fit within the maxsize bounding box and to be less than the provided area.
tcpchannel ( tcptransport tr , tcpendpoint ep ) { this . tr = tr ; this . ep = ep ; }	create channel for endpoint .
@ override public final string tostring ( ) { stringbuilder buffer = new stringbuilder ( ) ; buffer . append ( _str ) ; for ( int i = _num ; i < fields . size ( ) ; i ++ ) { indexablefield field = fields . get ( i ) ; buffer . append ( field . tostring ( ) ) ; if ( i != fields . size ( ) - _num ) { buffer . append ( _str ) ; } } buffer . append ( _str ) ; return buffer . tostring ( ) ; }	prints the fields of a document for human consumption .
public static byte [ ] encode ( byte [ ] data ) { bytearrayoutputstream bout = new bytearrayoutputstream ( ) ; try { encoder . encode ( data , _num , data . length , bout ) ; } catch ( ioexception e ) { throw new runtimeexception ( _str + e ) ; } return bout . tobytearray ( ) ; }	encode the input data producing a base 64 encoded byte array .
public static face drawdir ( direction dir , meshmodel model , double minx , double miny , double minz , double maxx , double maxy , double maxz , cubetexturecoordinates texturecoordinates ) { switch ( dir ) { case down : return drawdown ( model , minx , miny , minz , maxx , maxy , maxz , texturecoordinates ) ; case up : return drawup ( model , minx , miny , minz , maxx , maxy , maxz , texturecoordinates ) ; case north : return drawnorth ( model , minx , miny , minz , maxx , maxy , maxz , texturecoordinates ) ; case south : return drawsouth ( model , minx , miny , minz , maxx , maxy , maxz , texturecoordinates ) ; case east : return draweast ( model , minx , miny , minz , maxx , maxy , maxz , texturecoordinates ) ; case west : return drawwest ( model , minx , miny , minz , maxx , maxy , maxz , texturecoordinates ) ; } throw new renderexception ( _str ) ; }	creates a face of the model in a specified direction.
public void addobserver ( final filealterationobserver observer ) { if ( observer != null ) { observers . add ( observer ) ; } }	add a file system observer to this monitor .
public static double log1p ( final double x ) { if ( x == - _num ) { return double . negative_infinity ; } if ( x == double . positive_infinity ) { return double . positive_infinity ; } if ( x > _num || x < - _num ) { final double xpa = _num + x ; final double xpb = - ( xpa - _num - x ) ; final double [ ] hiprec = new double [ _num ] ; final double lores = log ( xpa , hiprec ) ; if ( double . isinfinite ( lores ) ) { return lores ; } final double fx1 = xpb / xpa ; final double epsilon = _num * fx1 + _num ; return epsilon * fx1 + hiprec [ _num ] + hiprec [ _num ] ; } else { final double y = ( x * f_1_3 - f_1_2 ) * x + _num ; return y * x ; } }	computes log ( 1 + x ) .
protected scriptbuilder bignum ( long num ) { return bignum ( chunks . size ( ) , num ) ; }	adds the given number as a push data chunk.
static object newinstance ( string classname , classloader cl , boolean dofallback ) throws configurationerror { try { class providerclass = findproviderclass ( classname , cl , dofallback ) ; object instance = providerclass . newinstance ( ) ; if ( debug ) debugprintln ( _str + providerclass + _str + cl ) ; return instance ; } catch ( classnotfoundexception x ) { throw new configurationerror ( _str + classname + _str , x ) ; } catch ( exception x ) { throw new configurationerror ( _str + classname + _str + x , x ) ; } }	create an instance of a class using the specified classloader.
public void addaction ( entityaction ea ) { actions . addelement ( ea ) ; processgameevent ( new gamenewactionevent ( this , ea ) ) ; }	adds the specified action to the actions list for this phase .
public polygon ( polygonpoint p1 , polygonpoint p2 , polygonpoint p3 ) { p1 . _next = p2 ; p2 . _next = p3 ; p3 . _next = p1 ; p1 . _previous = p3 ; p2 . _previous = p1 ; p3 . _previous = p2 ; _points . add ( p1 ) ; _points . add ( p2 ) ; _points . add ( p3 ) ; }	to create a polygon we need atleast 3 separate points.
public static jsonobject readjsonobject ( final jsonarray jsonarray , final int index , final boolean required , final boolean notnull ) throws jsonexception { if ( required ) { return jsonarray . getjsonobject ( index ) ; } if ( notnull && jsonarray . isnull ( index ) ) { throw new jsonexception ( string . format ( locale . us , null_value_format_array , index ) ) ; } jsonobject value = null ; if ( ! jsonarray . isnull ( index ) ) { value = jsonarray . getjsonobject ( index ) ; } return value ; }	reads the json object value from the json array for specified index .
public static void waitelementtonotbepresent ( searchcontext parent , by by , int waitinseconds ) { preconditions . checknotnull ( parent ) ; preconditions . checknotnull ( by ) ; try { webelementwait wait = new webelementwait ( parent , waitinseconds ) ; wait . until ( null ) ; } catch ( timeoutexception e ) { throw new timeoutexception ( string . format ( _str , by , waitinseconds ) , e ) ; } }	will wait until no element identified by the by is present .
public final testsubscriber assertterminated ( ) { if ( done . getcount ( ) != _num ) { fail ( _str , _str , errors ) ; } long c = completions ; if ( c > _num ) { fail ( _str , _str + c , errors ) ; } int s = errors . size ( ) ; if ( s > _num ) { fail ( _str , _str + s , errors ) ; } if ( c != _num && s != _num ) { fail ( _str , _str + c , errors ) ; } return this ; }	assert that the testsubscriber terminated ( i.
public boolean isvimeourlvalid ( ) { string videoid = getextractedidentifier ( ) ; return videoid . length ( ) > _num && textutils . isdigitsonly ( videoid ) ; }	check if a vimeo url has a valid identifier.
public boolean iscancelled ( ) { return mstate . get ( ) == state_cancelled ; }	check whether this work is canceled .
public final void pushsubcontextlist ( subcontextlist iter ) { m_axesiteratorstack . push ( iter ) ; }	push a treewalker on the stack .
private void updatedownloadedfiles ( sqlitedatabase db , string newaccountname , string oldaccountname ) { string whereclause = providertablemeta . file_account_owner + _str + providertablemeta . file_storage_path + _str ; cursor c = db . query ( providertablemeta . file_table_name , null , whereclause , new string [ ] { newaccountname } , null , null , null ) ; try { if ( c . movetofirst ( ) ) { string oldaccountpath = filestorageutils . getsavepath ( oldaccountname ) ; string newaccountpath = filestorageutils . getsavepath ( newaccountname ) ; file oldaccountfolder = new file ( oldaccountpath ) ; file newaccountfolder = new file ( newaccountpath ) ; oldaccountfolder . renameto ( newaccountfolder ) ; do { string oldpath = c . getstring ( c . getcolumnindex ( providertablemeta . file_storage_path ) ) ; ocfile file = new ocfile ( c . getstring ( c . getcolumnindex ( providertablemeta . file_path ) ) ) ; string newpath = filestorageutils . getdefaultsavepathfor ( newaccountname , file ) ; contentvalues cv = new contentvalues ( ) ; cv . put ( providertablemeta . file_storage_path , newpath ) ; db . update ( providertablemeta . file_table_name , cv , providertablemeta . file_storage_path + _str , new string [ ] { oldpath } ) ; log_oc . v ( _str , _str + oldpath + _str + newpath ) ; } while ( c . movetonext ( ) ) ; } } finally { c . close ( ) ; } }	rename the local owncloud folder of one account to match the a rename of the account itself.
public void dumpoptions ( ) { logger . info ( _str ) ; for ( method getter : getconfigurationinterface . class . getmethods ( ) ) { string gettername = getter . getname ( ) ; try { object result = getter . invoke ( configurationmanager . getcurrentprofile ( ) ) ; if ( result instanceof boolean ) { result = localizationhelper . getyesorno ( ( boolean ) result ) ; } if ( result instanceof list ) { for ( int i = _num ; i < ( ( list ) result ) . size ( ) ; i ++ ) { assert ( ( list ) result ) . get ( i ) instanceof customcatalogentry ; customcatalogentry c = ( ( list < customcatalogentry > ) result ) . get ( i ) ; string optionname = helper . pad ( localization . main . gettext ( _str ) + _str + ( i + _num ) + _str + c . getattop ( ) . tostring ( ) , _str , _num ) + _str ; logger . info ( optionname + c . getlabel ( ) + _str + c . getvalue ( ) . tostring ( ) + _str + c . getattop ( ) . tostring ( ) ) ; } } else { string optionname = gettername . substring ( _num ) ; dumpoption ( optionname , result ) ; } } catch ( illegalaccessexception e ) { logger . warn ( _str , e ) ; } catch ( invocationtargetexception e ) { logger . warn ( _str , e ) ; } } logger . info ( _str ) ; }	dump all the configuration options listed as get methods in the configuration interface .
private jsonnode parselanguageresource ( resource resource ) throws ioexception { inputstream stream = resource . asstream ( ) ; if ( stream == null ) return null ; try { jsonnode tree = mapper . readtree ( stream ) ; return tree ; } finally { stream . close ( ) ; } }	parses the given language resource , returning the resulting jsonnode.
public collection < tuple2 < transitionstate , double > > startstates ( ) { list < tuple2 < transitionstate , double > > result = new arraylist < tuple2 < transitionstate , double > > ( ) ; { double score = math . log ( line_mrgn_prob ) ; addnosubglyphstartstate ( result , new int [ _num ] , transitionstatetype . lmrgn , - _num , score ) ; } for ( int destlanguage = _num ; destlanguage < numlanguages ; ++ destlanguage ) { singlelanguagemodel destlm = lm . get ( destlanguage ) ; double destlanguageprior = lm . languageprior ( destlanguage ) ; for ( int c : destlm . getactivecharacters ( ) ) { if ( c != spacecharindex ) { double score = math . log ( _num - line_mrgn_prob ) + math . log ( getngramprob ( destlm , new int [ _num ] , c ) ) + math . log ( destlanguageprior ) ; addglyphstartstates ( result , c , new int [ ] { c } , transitionstatetype . tmpl , destlanguage , score ) ; } } } { double totalspaceprob = _num ; for ( int language = _num ; language < numlanguages ; ++ language ) totalspaceprob += getngramprob ( lm . get ( language ) , new int [ _num ] , spacecharindex ) * lm . languageprior ( language ) ; double score = math . log ( _num - line_mrgn_prob ) + math . log ( totalspaceprob ) ; addnosubglyphstartstate ( result , new int [ ] { spacecharindex } , transitionstatetype . tmpl , - _num , score ) ; } return result ; }	make a collection of states that can be the start of a line.
public boolean removecontainerandcancelifnecessary ( imagecontainer container ) { mcontainers . remove ( container ) ; if ( mcontainers . isempty ( ) ) { mrequest . cancel ( ) ; return _bool ; } return _bool ; }	detatches the bitmap container from the request and cancels the request if no one is left listening .
public kerneldensityfunction ( collection < double [ ] > points ) { this ( points . toarray ( new double [ points . size ( ) ] [ ] ) ) ; }	creates a new kernel density function with the given points.
private static object cloneserializableobject ( object o ) throws ioexception , classnotfoundexception { bytearrayoutputstream b = new bytearrayoutputstream ( ) ; objectoutputstream out = new objectoutputstream ( b ) ; out . writeobject ( o ) ; out . flush ( ) ; out . close ( ) ; bytearrayinputstream bi = new bytearrayinputstream ( b . tobytearray ( ) ) ; objectinputstream in = new objectinputstream ( bi ) ; return in . readobject ( ) ; }	this methods provide cloning for serializable objects . mail attributes are serializable but not clonable so we need a deep copy.
public boolean hasthree ( ) { return points . size ( ) > _num ; }	determine if there are more than 2 points currently in the partial hull .
public zipentry ( string name ) { objects . requirenonnull ( name , _str ) ; if ( name . length ( ) > _num ) { throw new illegalargumentexception ( _str ) ; } this . name = name ; }	creates a new zip entry with the specified name .
public void _teststatements ( ) throws exception { connection connection = getconnectionviadrivermanager ( ) ; connection . setautocommit ( _bool ) ; try { statement stmt = connection . createstatement ( ) ; resultset rs = stmt . executequery ( _str ) ; rs . close ( ) ; randomselector selector1 = new randomselector ( stmt , select_table_1 , record_count ) ; randomselector selector2 = new randomselector ( stmt , select_table_2 , record_count ) ; thread thread1 = new thread ( selector1 , _str ) ; thread thread2 = new thread ( selector2 , _str ) ; thread1 . start ( ) ; thread2 . start ( ) ; thread . sleep ( test_time_seconds * _num ) ; selector1 . stop ( ) ; selector2 . stop ( ) ; thread1 . join ( ) ; thread2 . join ( ) ; stmt . close ( ) ; } finally { connection . close ( ) ; } }	test if single statement can be safely used in multiple transactions.
void readdictionary ( string filename , string suffix , inputstream res ) throws ioexception { dictionarynames nms = new dictionarynames ( filename , suffix ) ; bufferedreader in = new bufferedreader ( new inputstreamreader ( res ) ) ; string line ; while ( ( line = in . readline ( ) ) != null ) { string [ ] terms = splitter . split ( line ) ; if ( terms . length > maxphraselength ) continue ; if ( terms . length == _num ) continue ; gazentry ge = gaz . get ( terms [ _num ] ) ; if ( ge == null ) { gaz . put ( terms [ _num ] , new gazentry ( terms , _num , nms ) ) ; } else { ge . addchild ( terms , _num , nms ) ; } } in . close ( ) ; }	read the given dictionary file from the input stream .
public void addvertex ( valuegraphvertex v ) { if ( vertices . add ( v ) ) { if ( v . representsparameter ( ) ) { nparameter ++ ; } if ( representativev == null ) { representativev = v ; } } }	add a vertex to this congruence class .
private void createviewtomodel ( int rowcount ) { int recreatefrom = _num ; if ( viewtomodel != null ) { recreatefrom = math . min ( rowcount , viewtomodel . length ) ; if ( viewtomodel . length != rowcount ) { row [ ] oldviewtomodel = viewtomodel ; viewtomodel = new row [ rowcount ] ; system . arraycopy ( oldviewtomodel , _num , viewtomodel , _num , recreatefrom ) ; } } else { viewtomodel = new row [ rowcount ] ; } int i ; for ( i = _num ; i < recreatefrom ; i ++ ) { viewtomodel [ i ] . modelindex = i ; } for ( i = recreatefrom ; i < rowcount ; i ++ ) { viewtomodel [ i ] = new row ( this , i ) ; } }	resets the viewtomodel array to be of size rowcount .
public set < string > files ( ) { if ( setfiles == null ) { throw new illegalstateexception ( _str ) ; } return collections . unmodifiableset ( setfiles ) ; }	return all files referenced by this segmentinfo .
public static boolean ismac ( ) { string osname = system . getproperty ( _str ) ; osname = osname . tolowercase ( ) ; return osname . indexof ( _str ) != - _num ; }	do we run on apple.
private boolean isassignablefrom ( throwable concretethrowable , set < class < ? extends throwable > > throwableclasses ) { for ( class < ? extends throwable > t : throwableclasses ) { if ( t . isassignablefrom ( concretethrowable . getclass ( ) ) ) { return _bool ; } } return _bool ; }	tests if concretethrowable . getclass is assignable to any of the classes in throwableclasses.
public string popandencode ( boolean fromonlineevent ) { synchronized ( this ) { if ( activebridgemode == null ) { return null ; } activebridgemode . notifyofflush ( this , fromonlineevent ) ; if ( queue . isempty ( ) ) { return null ; } int totalpayloadlen = _num ; int nummessagestosend = _num ; for ( jsmessage message : queue ) { int messagesize = calculatepackedmessagelength ( message ) ; if ( nummessagestosend > _num && totalpayloadlen + messagesize > max_payload_size && max_payload_size > _num ) { break ; } totalpayloadlen += messagesize ; nummessagestosend += _num ; } stringbuilder sb = new stringbuilder ( totalpayloadlen ) ; for ( int i = _num ; i < nummessagestosend ; ++ i ) { jsmessage message = queue . removefirst ( ) ; packmessage ( message , sb ) ; } if ( ! queue . isempty ( ) ) { sb . append ( _str ) ; } string ret = sb . tostring ( ) ; return ret ; } }	combines and returns queued messages combined into a single string.
protected void print ( int v ) throws ioexception { print ( string . valueof ( v ) ) ; }	prints an integer to the stream .
public object2doubleopenhashmap < intrbtreeset > confidencemap ( ) { list < itemset > itemsets = learn ( ) ; object2doubleopenhashmap < intrbtreeset > confidencemap = new object2doubleopenhashmap < > ( itemsets . size ( ) ) ; for ( itemset itemset : itemsets ) { intrbtreeset itemsetcopy = new intrbtreeset ( itemset . items ) ; confidencemap . put ( itemsetcopy , itemset . support / ( double ) setcount ) ; } return confidencemap ; }	returns a map of associations and their confidence , where confidence is support for the itemset ( that is , the number of times it appears in the input data ) divided by the total number of sets ( i.
public static boolean isallalpha ( string str ) { if ( str == null ) return _bool ; for ( int i = str . length ( ) - _num ; i >= _num ; i -- ) { if ( ! character . isletter ( str . charat ( i ) ) ) return _bool ; } return _bool ; }	returns true if all characters in the string are letters.
protected static int todigit ( char ch , int index ) throws dssexception { int digit = character . digit ( ch , _num ) ; if ( digit == - _num ) { throw new dssexception ( _str + ch + _str + index ) ; } return digit ; }	converts a hexadecimal character to an integer .
static void loadlibrarywithpath ( string libname , classloader loader , string librarypath ) { throw new error ( _str ) ; }	this method must be provided by the vm vendor , as it is called by java.
public enumeration listoptions ( ) { vector newvector = new vector ( ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public void testconstructorsignbytespositive7 ( ) { byte abytes [ ] = { - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , - _num } ; int asign = _num ; byte rbytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = anumber . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , anumber . signum ( ) ) ; }	create a positive number from a sign and an array of bytes.
public void save ( file keystore , string type , char [ ] password , char [ ] keypassword , string caalias ) throws generalsecurityexception , ioexception { keystore store = keystore . getinstance ( type ) ; store . load ( null , password ) ; store . setkeyentry ( caalias , cakey , keypassword , cacerts ) ; outputstream out = new fileoutputstream ( keystore ) ; try { store . store ( out , password ) ; } catch ( ioexception ioe ) { ioe . printstacktrace ( ) ; } finally { out . close ( ) ; } }	saves the ca key and the certificate chain to the specified keystore.
public orquerybuilder add ( querybuilder filterbuilder ) { filters . add ( filterbuilder ) ; return this ; }	adds a filter to the list of filters to " or " .
public static void d ( string tag , string msg , object ... args ) { if ( slevel > level_debug ) { return ; } if ( args . length > _num ) { msg = string . format ( msg , args ) ; } log . d ( tag , msg ) ; }	send a debug log message.
void update ( long timenanos , int rows ) { count ++ ; executiontimeminnanos = math . min ( timenanos , executiontimeminnanos ) ; executiontimemaxnanos = math . max ( timenanos , executiontimemaxnanos ) ; rowcountmin = math . min ( rows , rowcountmin ) ; rowcountmax = math . max ( rows , rowcountmax ) ; double rowdelta = rows - rowcountmean ; rowcountmean += rowdelta / count ; rowcountm2 += rowdelta * ( rows - rowcountmean ) ; double timedelta = timenanos - executiontimemeannanos ; executiontimemeannanos += timedelta / count ; executiontimem2nanos += timedelta * ( timenanos - executiontimemeannanos ) ; executiontimecumulativenanos += timenanos ; rowcountcumulative += rows ; lastupdatetime = system . currenttimemillis ( ) ; }	update the statistics entry .
public void test_ctor_2 ( ) throws sailexception { final file file = new file ( getname ( ) + options . jnl ) ; if ( file . exists ( ) ) { if ( ! file . delete ( ) ) { fail ( _str + file ) ; } } final properties properties = new properties ( ) ; properties . setproperty ( options . file , file . tostring ( ) ) ; final bigdatasail sail = new bigdatasail ( properties ) ; try { sail . initialize ( ) ; sail . shutdown ( ) ; } finally { if ( ! file . exists ( ) ) { fail ( _str + file ) ; if ( ! file . delete ( ) ) { fail ( _str + file ) ; } } } }	test create and shutdown of a named store .
@ override public string tostring ( ) { string result ; result = null ; if ( isobject ( ) ) { if ( isroot ( ) ) { result = _str ; } else if ( m_name == null ) { result = _str ; } else { result = escape ( m_name ) + _str ; } } else if ( isarray ( ) ) { if ( m_name == null ) { result = _str ; } else { result = escape ( m_name ) + _str ; } } else { if ( m_name != null ) { result = escape ( m_name ) + _str + escape ( m_value ) ; } else { result = _str + m_value ; } } return result ; }	returns a string representation of the node .
public final boolean split_traces_keep_point ( ) { if ( keep_point == null ) return _bool ; itemselectionfilter filter = new itemselectionfilter ( itemselectionchoice . traces ) ; collection < brditem > picked_items = r_board . pick_items ( keep_point . keep_point , keep_point . on_layer , filter ) ; for ( brditem curr_item : picked_items ) { brdtracep a_trace = ( brdtracep ) curr_item ; int line_idx = a_trace . polyline_find_line_idx ( keep_point . keep_point ) ; if ( line_idx < _num ) continue ; arraylist < brdtracep > clean_list = a_trace . split_with_end_point ( line_idx , keep_point . keep_point ) ; return clean_list . size ( ) > _num ; } return _bool ; }	splits the traces containing this.
public static byte [ ] flipallbitsinplace ( byte [ ] bytes , int index , int length ) { int endindex = math . min ( bytes . length , index + length ) ; for ( int i = index ; i < endindex ; i ++ ) { bytes [ i ] = ( byte ) ( bytes [ i ] ^ _num ) ; } return bytes ; }	this flips the bits in the range [ index , index + length ) and returns the same byte [ ] .
public createindexrequest source ( string source ) { return source ( source . getbytes ( charsets . utf_8 ) ) ; }	sets the settings and mappings as a single source .
private void addusers ( user [ ] users , localconfiguration configuration ) { for ( user user : users ) { configuration . adduser ( user . createuser ( ) ) ; } }	add users to the configuration .
void trytodrainbuffers ( ) { if ( evictionlock . trylock ( ) ) { try { drainstatus . lazyset ( processing ) ; drainbuffers ( ) ; } finally { drainstatus . compareandset ( processing , idle ) ; evictionlock . unlock ( ) ; } } }	attempts to acquire the eviction lock and apply the pending operations , up to the amortized threshold , to the page replacement policy .
public static boolean copyfile ( file source , file dest ) { file parentdest = dest . getparentfile ( ) ; if ( ! parentdest . exists ( ) ) { if ( ! createdirectory ( parentdest . getabsolutepath ( ) ) ) { return _bool ; } } try { files . copy ( source . topath ( ) , dest . topath ( ) ) ; return _bool ; } catch ( ioexception e ) { e . printstacktrace ( ) ; return _bool ; } }	copy source file to destination file . create directory if destination directory does not exist.
public static string propertiesencode ( properties pp ) { bytearrayoutputstream bos = new bytearrayoutputstream ( ) ; try { pp . store ( bos , _str ) ; } catch ( ioexception e ) { log . log ( level . severe , _str , e ) ; } string result = new string ( bos . tobytearray ( ) ) ; try { result = urlencoder . encode ( result , mobileenv . encoding ) ; } catch ( unsupportedencodingexception e ) { log . log ( level . severe , _str + mobileenv . encoding , e ) ; string enc = system . getproperty ( _str ) ; try { result = urlencoder . encode ( result , enc ) ; log . info ( _str + enc ) ; } catch ( exception ex ) { log . log ( level . severe , _str , ex ) ; } } return result ; }	decode properties into string ( url encoded ).
@ override public void generaterss ( xmlwriter w , extensionprofile extprofile ) throws ioexception { arraylist < xmlwriter . attribute > attrs = new arraylist < xmlwriter . attribute > ( _num ) ; if ( mimetype != null ) { attrs . add ( new xmlwriter . attribute ( _str , mimetype . getmediatype ( ) ) ) ; } if ( uri != null ) { attrs . add ( new xmlwriter . attribute ( _str , uri ) ) ; } if ( length != - _num ) { attrs . add ( new xmlwriter . attribute ( _str , long . tostring ( length ) ) ) ; } w . simpleelement ( namespaces . rssns , _str , attrs , null ) ; }	generates xml in the rss format .
public void testsortselementsbyname ( ) throws exception { xppdom dom1 = xppfactory . builddom ( _str ) ; xppdom dom2 = xppfactory . builddom ( _str ) ; assertequals ( - _num , comparator . compare ( dom1 , dom2 ) ) ; assertequals ( _str , xpath . get ( ) ) ; assertequals ( _num , comparator . compare ( dom2 , dom1 ) ) ; assertequals ( _str , xpath . get ( ) ) ; }	tests comparison of different elements .
public static boolean deletedirectory ( final file path ) { if ( path . exists ( ) ) { file [ ] files = path . listfiles ( ) ; for ( file file : files ) { if ( file . isdirectory ( ) ) { deletedirectory ( file ) ; } else { file . delete ( ) ; } } } return path . delete ( ) ; }	deletes directory with files .
public static timestamp stringtotimestamp ( string datetimestring , string datetimeformat , timezone tz , locale locale ) throws parseexception { dateformat dateformat = todatetimeformat ( datetimeformat , tz , locale ) ; date parseddate = dateformat . parse ( datetimestring ) ; return new timestamp ( parseddate . gettime ( ) ) ; }	localized string to timestamp conversion.
private boolean startsnewhunk ( string string ) { if ( string . length ( ) == _num ) return _bool ; return islegalchar ( string . charat ( _num ) ) ; }	true if the string is the beginning of a new camel case hunk.
public void clearvalues ( ) { valuemap . clear ( ) ; }	removes all placeholder - value mappings .
private hashmap < string , byte [ ] > readchars ( byte [ ] d ) { hashmap < string , byte [ ] > hm = new hashmap < string , byte [ ] > ( ) ; int i = findslashname ( d , _str ) ; if ( i < _num ) { return hm ; } psparser psp = new psparser ( d , i ) ; while ( _bool ) { string s = psp . readthing ( ) ; char c = s . charat ( _num ) ; if ( c == _str ) { int len = integer . parseint ( psp . readthing ( ) ) ; string go = psp . readthing ( ) ; if ( go . equals ( _str ) || go . equals ( _str ) ) { psp . setloc ( psp . getloc ( ) + _num ) ; byte [ ] line = psp . getnencodedbytes ( len , password , leniv ) ; hm . put ( s . substring ( _num ) , line ) ; } } else if ( s . equals ( _str ) ) { break ; } } return hm ; }	get the character definitions of the font .
public static byte [ ] stringtobytearray ( string input ) { char chars [ ] = input . tochararray ( ) ; byte bytes [ ] = new byte [ chars . length ] ; for ( int i = _num ; i < chars . length ; i ++ ) { bytes [ i ] = ( byte ) chars [ i ] ; } return bytes ; }	converts a string to a byte array .
public void playfileforuser ( string filename , string username ) throws soundplaybackexception { if ( username == null || username . isempty ( ) ) { username = appproperties . getproperty ( _str ) ; } try { guild guild = getusersguild ( username ) ; joinuserscurrentchannel ( username ) ; playfile ( filename , guild ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }	joins the channel of the user provided and then plays a file .
@ deprecated public static void runfinalizersonexit ( boolean run ) { securitymanager sm = system . getsecuritymanager ( ) ; if ( sm != null ) { sm . checkexit ( _num ) ; } synchronized ( hookslist ) { finalizeonexit = run ; } }	ensure that , when the virtual machine is about to exit , all objects are finalized.
public double [ ] [ ] predictintervals ( double conf ) { updatemeanandvariance ( ) ; double val = statistics . normalinverse ( _num - ( _num - conf ) / _num ) ; double [ ] [ ] arr = new double [ _num ] [ _num ] ; arr [ _num ] [ _num ] = m_mean + val * math . sqrt ( m_variance ) ; arr [ _num ] [ _num ] = m_mean - val * math . sqrt ( m_variance ) ; return arr ; }	returns the interval for the given confidence value .
public static < t > t min ( collection < ? extends t > collection , comparator < ? super t > comparator ) { if ( comparator == null ) { @ suppresswarnings ( _str ) t result = ( t ) min ( ( collection < java . lang . comparable > ) collection ) ; return result ; } iterator < ? extends t > it = collection . iterator ( ) ; t min = it . next ( ) ; while ( it . hasnext ( ) ) { t next = it . next ( ) ; if ( comparator . compare ( min , next ) > _num ) { min = next ; } } return min ; }	searches the specified collection for the minimum element using the specified comparator .
public static boolean checksha ( final string shahash , final file file ) { if ( textutils . isempty ( shahash ) || file == null || ! fileutils . isreadable ( file ) ) { log . e ( _str ) ; return _bool ; } final string hash = getsha ( file ) ; if ( hash == null ) { log . e ( _str ) ; return _bool ; } return hash . equalsignorecase ( shahash ) ; }	checks if given hash is the same for given file - helps to detect file changes.
public void addvaluekeyname ( string key ) { valuekeynames . add ( key ) ; }	add the key that should be treated as one of the value fields . the key must be in the input map.
public assignment update ( border border ) { arrays . sort ( cs ) ; int j = _num ; boolean found = ( cs [ _num ] . core == border . core ) ; for ( int i = _num ; i < cs . length ; i ++ ) { if ( cs [ i ] . core != cs [ i - _num ] . core ) { cs [ j ++ ] = cs [ i ] ; } found |= ( cs [ i ] . core == border . core ) ; } if ( found ) { if ( j == _num ) { border r = cs [ _num ] ; cs = null ; return r ; } if ( j < cs . length ) { cs = arrays . copyof ( cs , j ) ; } return this ; } if ( j + _num != cs . length ) { cs = arrays . copyof ( cs , j + _num ) ; } cs [ j ] = border ; return this ; }	add a new border to the existing borders .
public static string fromchar ( int value ) { if ( value > _num ) return null ; string name ; initialize ( ) ; name = ( string ) _bychar . get ( new integer ( value ) ) ; return name ; }	returns the name of an html character reference based on its character value.
public static list < string > splitlines ( final string content ) { if ( content == null || content . length ( ) == _num ) return collections . emptylist ( ) ; string [ ] lines = content . split ( _str ) ; return arrays . aslist ( lines ) ; }	split the supplied content into lines , returning each line as an element in the returned list .
@ override public void draw ( graphics2d g2 , rectangle2d area , point2d anchor , plotstate state , plotrenderinginfo info ) { boolean b1 = ( area . getwidth ( ) <= minimum_width_to_draw ) ; boolean b2 = ( area . getheight ( ) <= minimum_height_to_draw ) ; if ( b1 || b2 ) { return ; } if ( info != null ) { info . setplotarea ( area ) ; } rectangleinsets insets = getinsets ( ) ; insets . trim ( area ) ; drawchipgrid ( g2 , area ) ; drawwaferedge ( g2 , area ) ; }	draws the wafermap view .
public void addhole ( edgering holeer ) { holeer . setshell ( this ) ; linearring hole = holeer . getring ( ) ; if ( holes == null ) holes = new arraylist ( ) ; holes . add ( hole ) ; }	adds a hole to the polygon formed by this ring .
private static void registercomponents ( ) { registercomponent ( barchartcomponent . class , barchartgui . class ) ; registercomponent ( docviewercomponent . class , docviewerdesktopcomponent . class ) ; registercomponent ( consolecomponent . class , consoledesktopcomponent . class ) ; registercomponent ( displaycomponent . class , displaycomponentdesktopgui . class ) ; registercomponent ( dataworldcomponent . class , dataworlddesktopcomponent . class ) ; registercomponent ( histogramcomponent . class , histogramgui . class ) ; registercomponent ( networkcomponent . class , networkdesktopcomponent . class ) ; registercomponent ( odorworldcomponent . class , odorworlddesktopcomponent . class ) ; registercomponent ( piechartcomponent . class , piechartgui . class ) ; registercomponent ( projectioncomponent . class , projectiongui . class ) ; registercomponent ( readercomponent . class , readercomponentdesktopgui . class ) ; registercomponent ( scatterplotcomponent . class , scatterplotgui . class ) ; registercomponent ( timeseriesplotcomponent . class , timeseriesplotgui . class ) ; registercomponent ( rasterplotcomponent . class , rasterplotgui . class ) ; registercomponent ( visionworldcomponent . class , visionworlddesktopcomponent . class ) ; registercomponent ( gamecomponent . class , gamedesktopcomponent . class ) ; registercomponent ( deviceinteractioncomponent . class , deviceinteractiondesktopcomponent . class ) ; }	create mappings from guicomponents to their gui wrappers .
private void initialize ( class < opstype > opstype , interface instance ) throws instantiationexception , illegalaccessexception { mopsinstance = opstype . newinstance ( ) ; mretainedfragmentmanager . put ( opstype . getsimplename ( ) , mopsinstance ) ; mopsinstance . onconfiguration ( instance , _bool ) ; }	initialize the genericactivity fields .
private long skipinputbytes ( long n ) throws ioexception { cblock . lock ( ) ; try { return iis . skipbytes ( n ) ; } finally { cblock . unlock ( ) ; } }	this method is called from the native code in order to skip requested number of bytes in the input stream .
public byte [ ] generate64bithashid ( ) throws cryptoexception { try { derbitstring publickeybitstring = encodepublickeyasbitstring ( publickey ) ; byte [ ] hash = digestutil . getmessagedigest ( publickeybitstring . getbytes ( ) , digesttype . sha1 ) ; byte [ ] subhash = arrays . copyofrange ( hash , _num , _num ) ; subhash [ _num ] &= _num ; subhash [ _num ] |= _num ; return subhash ; } catch ( ioexception ex ) { throw new cryptoexception ( res . getstring ( _str ) , ex ) ; } }	generate 64 bit hash key identifier .
public static < c extends configurationclient , s extends configuration > createsubcommandhandler < c , s > create ( subcommandargumentparser parser , managedobjectpath < ? , ? > p , optionalrelationdefinition < c , s > r ) throws argumentexception { return new createsubcommandhandler < > ( parser , p , r , null , p . child ( r ) ) ; }	creates a new create - xxx sub - command for an optional relation .
public dsubjectinformationaccess ( jdialog parent , byte [ ] value ) throws ioexception { super ( parent ) ; settitle ( res . getstring ( _str ) ) ; initcomponents ( ) ; prepopulatewithvalue ( value ) ; }	creates a new dsubjectinformationaccess dialog .
private figure readlineelement ( ixmlelement elem ) throws ioexception { hashmap < attributekey , object > a = new hashmap < attributekey , object > ( ) ; readcoreattributes ( elem , a ) ; readtransformattribute ( elem , a ) ; readopacityattribute ( elem , a ) ; readlineattributes ( elem , a ) ; if ( fill_color . get ( a ) != null && stroke_color . get ( a ) == null ) { stroke_color . put ( a , fill_color . get ( a ) ) ; } if ( fill_gradient . get ( a ) != null && stroke_gradient . get ( a ) == null ) { stroke_gradient . put ( a , fill_gradient . get ( a ) ) ; } fill_color . put ( a , null ) ; fill_gradient . put ( a , null ) ; double x1 = tonumber ( elem , readattribute ( elem , _str , _str ) ) ; double y1 = tonumber ( elem , readattribute ( elem , _str , _str ) ) ; double x2 = tonumber ( elem , readattribute ( elem , _str , _str ) ) ; double y2 = tonumber ( elem , readattribute ( elem , _str , _str ) ) ; figure figure = factory . createline ( x1 , y1 , x2 , y2 , a ) ; elementobjects . put ( elem , figure ) ; return figure ; }	reads an svg " line " element .
public listmodel ( final object [ ] items ) { for ( int i = _num ; i < items . length ; ++ i ) m_items . add ( items [ i ] ) ; }	create a listmodel with the provided items .
public boolean issetcalltype ( ) { return __isset_bit_vector . get ( __calltype_isset_id ) ; }	returns true if field calltype is set ( has been assigned a value ) and false otherwise.
private ibuffer mapsource ( sourcemapper mapper , ibinarytype info , iclassfile bufferowner ) { char [ ] contents = mapper . findsource ( gettype ( ) , info ) ; if ( contents != null ) { ibuffer buffer = buffermanager . createbuffer ( bufferowner ) ; if ( buffer == null ) return null ; buffermanager bufmanager = getbuffermanager ( ) ; bufmanager . addbuffer ( buffer ) ; if ( buffer . getcharacters ( ) == null ) { buffer . setcontents ( contents ) ; } buffer . addbufferchangedlistener ( this ) ; mapper . mapsource ( getoutermostenclosingtype ( ) , contents , info ) ; return buffer ; } else { ibuffer buffer = buffermanager . createnullbuffer ( bufferowner ) ; if ( buffer == null ) return null ; buffermanager bufmanager = getbuffermanager ( ) ; bufmanager . addbuffer ( buffer ) ; buffer . addbufferchangedlistener ( this ) ; return buffer ; } }	loads the buffer via sourcemapper , and maps it in sourcemapper.
public jfiledatastorechooser ( shell parent , int style , final list < string > extensions ) { this ( parent , style , associations ( extensions ) ) ; }	create a dialog that filters for files with the specified extensions .
private void computestaticloadmetrics ( accessprofile accessprofile ) throws basecollectionexception { uri storagesystemid = accessprofile . getsystemid ( ) ; storagesystem storagesystem = null ; try { storagesystem = _dbclient . queryobject ( storagesystem . class , storagesystemid ) ; _logger . info ( _str , storagesystem . getlabel ( ) ) ; vnxeapiclient client = getvnxunityclient ( accessprofile ) ; list < vnxenasserver > nasservers = client . getnasservers ( ) ; for ( vnxenasserver nasserver : nasservers ) { if ( ( nasserver . getmode ( ) == vnxenasserver . nasservermodeenum . destination ) || nasserver . getisreplicationdestination ( ) ) { _logger . debug ( _str ) ; continue ; } if ( nasserver . getissystem ( ) ) { continue ; } virtualnas virtualnas = findvnasbynativeid ( storagesystem , nasserver . getid ( ) ) ; if ( virtualnas != null ) { _logger . info ( _str , nasserver . getname ( ) ) ; stringmap dbmetrics = virtualnas . getmetrics ( ) ; if ( dbmetrics == null ) { dbmetrics = new stringmap ( ) ; } stringmap tmpdbmetrics = populatedbmetrics ( nasserver , client ) ; dbmetrics . putall ( tmpdbmetrics ) ; virtualnas . setmetrics ( dbmetrics ) ; _dbclient . updateobject ( virtualnas ) ; } } } catch ( exception e ) { _logger . error ( _str , storagesystemid , e ) ; } }	compute static load metrics .
public final short readshort ( ) throws java . io . ioexception { readfully ( scratch , _num , _num ) ; return ( short ) ( ( scratch [ _num ] << _num ) | ( scratch [ _num ] & _num ) ) ; }	see the general contract of the readshort method of datainput.
public replicationjob createjobforcopypartition ( long auditlogid , long auditlogentrycreatetime , hiveobjectspec spec ) throws stateupdateexception { map < string , string > extras = new hashmap < > ( ) ; extras . put ( persistedjobinfo . audit_log_id_extras_key , long . tostring ( auditlogid ) ) ; extras . put ( persistedjobinfo . audit_log_entry_create_time_key , long . tostring ( auditlogentrycreatetime ) ) ; list < string > partitionnames = new arraylist < > ( ) ; partitionnames . add ( spec . getpartitionname ( ) ) ; replicationoperation replicationoperation = replicationoperation . copy_partition ; persistedjobinfo persistedjobinfo = jobinfostore . resilientcreate ( replicationoperation , replicationstatus . pending , optional . empty ( ) , srccluster . getname ( ) , spec , partitionnames , optional . empty ( ) , optional . empty ( ) , optional . empty ( ) , extras ) ; replicationtask replicationtask = new copypartitiontask ( conf , destinationobjectfactory , objectconflicthandler , srccluster , destcluster , spec , optional . < path > empty ( ) , optional . < path > empty ( ) , directorycopier , _bool ) ; return new replicationjob ( conf , replicationtask , onstatechangehandler , persistedjobinfo ) ; }	create a replication job to copy a partition .
public static void main ( string ... args ) throws exception { string [ ] pages = { _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str } ; stringbuilder buff = new stringbuilder ( ) ; for ( string filename : pages ) { string text = getcontent ( filename ) ; for ( string page : pages ) { text = stringutils . replaceall ( text , page + _str , _str ) ; } text = disablerailroads ( text ) ; text = removeheaderfooter ( filename , text ) ; buff . append ( text ) ; } string finaltext = buff . tostring ( ) ; file output = new file ( base_dir , _str ) ; printwriter writer = new printwriter ( new filewriter ( output ) ) ; writer . println ( _str + _str ) ; writer . println ( _str ) ; writer . println ( _str + _str ) ; writer . println ( _str ) ; writer . println ( _str + constants . getfullversion ( ) + _str ) ; writer . println ( finaltext ) ; writer . println ( _str ) ; writer . close ( ) ; }	this method is called when executing this application from the command line .
public static map < string , object > findorders ( dispatchcontext dctx , map < string , ? extends object > context ) { return findorders ( dctx , context , _bool ) ; }	scipio : stock findorders service .
public static boolean isfileexist ( string filepath ) { if ( stringutils . isblank ( filepath ) ) { return _bool ; } file file = new file ( filepath ) ; return ( file . exists ( ) && file . isfile ( ) ) ; }	indicates if this file represents a file on the underlying file system .
public static pronghornstage findstagebypath ( graphmanager m , int ... path ) { int ordinal = path [ _num ] ; int i = _num ; int limit = m . stageidtostage . length ; while ( i < limit ) { if ( null != m . stageidtostage [ i ] ) { if ( - _num == m . multinputids [ m . stageidtoinputsbeginidx [ m . stageidtostage [ i ] . stageid ] ] ) { if ( -- ordinal <= _num ) { return findstagebypath ( m , m . stageidtostage [ i ] , _num , path ) ; } } } i ++ ; } throw new unsupportedoperationexception ( _str + path [ _num ] ) ; }	start with ordinal selection of input stages then ordinal selection of each output ring there after . todo : do generic return that extends pronghornstage.
public static double [ ] calculatetstats ( double [ ] coef , double [ ] stderror , int k ) { double [ ] result = new double [ k ] ; for ( int i = _num ; i < k ; i ++ ) { result [ i ] = coef [ i ] / stderror [ i ] ; } return result ; }	returns an array of the t - statistic of each coefficient in a multiple linear regression model .
static void runbootstrappers ( final coreearlycomponent early , final list < heroicbootstrap > bootstrappers ) throws exception { for ( final heroicbootstrap bootstrap : bootstrappers ) { try { bootstrap . run ( early ) ; } catch ( exception e ) { throw new exception ( _str + bootstrap , e ) ; } } }	this method basically goes through the list of bootstrappers registered by modules and runs them .
public static byte [ ] checkindexheaderid ( datainput in , byte [ ] expectedid ) throws ioexception { byte id [ ] = new byte [ stringhelper . id_length ] ; in . readbytes ( id , _num , id . length ) ; if ( ! arrays . equals ( id , expectedid ) ) { throw new corruptindexexception ( _str + stringhelper . idtostring ( expectedid ) + _str + stringhelper . idtostring ( id ) , in ) ; } return id ; }	expert : just reads and verifies the object id of an index header.
public byte [ ] tobytearray ( ) { byte [ ] b = output . tobytearray ( ) ; bytearray . write16bit ( numofentries , b , _num ) ; return b ; }	returns the stack map table written out .
protected void savebuffer ( string name ) { stringbuffer sb = m_history . getnamedbuffer ( name ) ; if ( sb != null ) { if ( m_saveout . save ( sb ) ) { m_log . logmessage ( _str ) ; } } }	save the currently selected clusterer output to a file .
public list < recommendation > schedulestorage ( virtualarray srcvarray , set < uri > requestedvplexsystems , uri srcstoragesystem , virtualpool srcvpool , boolean isharequest , virtualarray requestedhavarray , virtualpool havpool , virtualpoolcapabilityvalueswrapper capabilities , project project , vpooluse vpooluse , map < vpooluse , list < recommendation > > currentrecommendations ) { _log . info ( _str ) ; if ( ! isharequest ) { return schedulestorageforlocalvplexvolume ( srcvarray , requestedvplexsystems , srcstoragesystem , srcvpool , capabilities , project , vpooluse , currentrecommendations ) ; } else { return schedulestoragefordistributedvplexvolume ( srcvarray , requestedvplexsystems , srcstoragesystem , srcvpool , requestedhavarray , havpool , capabilities , project , vpooluse , currentrecommendations ) ; } }	get recommendations for resource placement based on the passed parameters .
@ notnull public static list < string > completerelativepath ( @ notnull string basedir , @ notnull string shownbasedir , @ notnull string relativepath ) { list < string > result = lists . newlinkedlist ( ) ; string bashbasedir = osutil . tobashcompatible ( basedir ) ; for ( string path : completeabsolutepath ( basedir + file . separator + relativepath , predicates . < file > alwaystrue ( ) ) ) { if ( path . startswith ( bashbasedir ) ) { result . add ( shownbasedir + path . substring ( bashbasedir . length ( ) ) ) ; } } return result ; }	collect a list of relative paths.
protected boolean isfilespecifyingmodulespecifier ( string specifier ) { return specifier . length ( ) > _num && specifier . charat ( specifier . length ( ) - _num ) != ipath . separator ; }	returns true if the given module specifier is specifying a file.
private void insertexpectedpoolsettingspertier ( cimobjectpath capabilitiespath , map < string , object > keymap ) { list < string > expectedpoolsettingstier = ( list < string > ) keymap . get ( constants . vnxpoolcapabilities_tier ) ; expectedpoolsettingstier . add ( capabilitiespath . tostring ( ) + constants . hyphen + constants . no_data_movement ) ; expectedpoolsettingstier . add ( capabilitiespath . tostring ( ) + constants . hyphen + constants . auto_tier ) ; expectedpoolsettingstier . add ( capabilitiespath . tostring ( ) + constants . hyphen + constants . high_available_tier ) ; expectedpoolsettingstier . add ( capabilitiespath . tostring ( ) + constants . hyphen + constants . low_available_tier ) ; expectedpoolsettingstier . add ( capabilitiespath . tostring ( ) + constants . hyphen + constants . start_high_then_auto_tier ) ; }	in vnx , 4 default policies are present , and this method creates expected settings per poolcapability .
private static final void transferstreams ( inputstream source , outputstream destination , string path , iprogressmonitor monitor ) throws coreexception { monitor = policy . monitorfor ( monitor ) ; try { synchronized ( buffer ) { while ( _bool ) { int bytesread = - _num ; try { bytesread = source . read ( buffer ) ; } catch ( ioexception e ) { string msg = nls . bind ( messages . failedreadduringwrite , path ) ; policy . error ( efs . error_read , msg , e ) ; } try { if ( bytesread == - _num ) { destination . close ( ) ; break ; } destination . write ( buffer , _num , bytesread ) ; } catch ( ioexception e ) { string msg = nls . bind ( messages . couldnotwrite , path ) ; policy . error ( efs . error_write , msg , e ) ; } monitor . worked ( _num ) ; } } } finally { policy . safeclose ( source ) ; policy . safeclose ( destination ) ; } }	transfers the contents of an input stream to an output stream , using a large buffer .
private int pathpositionatlevel ( int orgunitlevel ) { return ( orgunitlevel - _num ) * _num + _num ; }	returns the position within an orgunit path at which the orgunit uid will be found for a given orgunitlevel .
private int makeavailable ( ) { if ( pos != - _num ) { return _num ; } total += tail - head - pad ; system . arraycopy ( buffer , tail - pad , buffer , _num , pad ) ; head = _num ; tail = pad ; for ( ; ; ) { int bytesread = _num ; try { bytesread = input . read ( buffer , tail , bufsize - tail ) ; } catch ( ioexception e ) { throw new runtimeexception ( _str ) ; } if ( bytesread == - _num ) { final string msg = _str ; throw new malformedstreamexception ( msg ) ; } tail += bytesread ; findseparator ( ) ; int av = available ( ) ; if ( av > _num || pos != - _num ) { return av ; } } }	attempts to read more data .
protected void addnumerictrainclass ( double classvalue , double weight ) { if ( classvalue > m_maxtarget ) { m_maxtarget = classvalue ; } if ( classvalue < m_mintarget ) { m_mintarget = classvalue ; } if ( m_trainclassvals == null ) { m_trainclassvals = new double [ _num ] ; m_trainclassweights = new double [ _num ] ; } if ( m_numtrainclassvals == m_trainclassvals . length ) { double [ ] temp = new double [ m_trainclassvals . length * _num ] ; system . arraycopy ( m_trainclassvals , _num , temp , _num , m_trainclassvals . length ) ; m_trainclassvals = temp ; temp = new double [ m_trainclassweights . length * _num ] ; system . arraycopy ( m_trainclassweights , _num , temp , _num , m_trainclassweights . length ) ; m_trainclassweights = temp ; } m_trainclassvals [ m_numtrainclassvals ] = classvalue ; m_trainclassweights [ m_numtrainclassvals ] = weight ; m_numtrainclassvals ++ ; }	adds a numeric ( non - missing ) training class value and weight to the buffer of stored values.
private list < group > parsegroups ( jsonarray groups , string grouptype ) throws jsonexception , adeusageexception { if ( groups . length ( ) == _num ) throw new adeusageexception ( _str + grouptype ) ; list < group > currentgroups = new arraylist < group > ( ) ; for ( int i = _num ; i < groups . length ( ) ; i ++ ) { jsonobject group = groups . getjsonobject ( i ) ; string name = group . getstring ( _str ) ; string datatype = group . getstring ( _str ) ; short evalorder = group . getshort ( _str ) ; string rulename = group . getstring ( _str ) ; if ( ! verifystringparam ( name , _num , _str ) || name . equalsignorecase ( _str ) || ! validatedatatype ( datatype ) || evalorder < _num || ! verifystringparam ( rulename , _num , _str ) ) { throw new adeusageexception ( _str + grouptype + _str ) ; } currentgroups . add ( new group ( name , grouptype . valueof ( grouptype ) , datatype . valueof ( datatype . touppercase ( ) ) , evalorder , rulename ) ) ; } validateevaluationorderandname ( currentgroups ) ; return currentgroups ; }	main logic for parsing the groups from the json file.
@ override public void draggesturerecognized ( draggestureevent evt ) { dragentry dragentry = kseframe . dragselectedentry ( ) ; if ( dragentry == null ) { return ; } imageicon icon = dragentry . getimage ( ) ; toolkit toolkit = toolkit . getdefaulttoolkit ( ) ; dimension dim = toolkit . getbestcursorsize ( icon . geticonwidth ( ) , icon . geticonheight ( ) ) ; bufferedimage buffimage = new bufferedimage ( dim . width , dim . height , bufferedimage . type_int_argb_pre ) ; icon . painticon ( evt . getcomponent ( ) , buffimage . getgraphics ( ) , _num , _num ) ; cursor = toolkit . createcustomcursor ( buffimage , new point ( _num , _num ) , _str ) ; evt . startdrag ( cursor , new keystoreentrytransferable ( dragentry ) , this ) ; }	drag gesture recognized . start the drag off if valid .
public static boolean isidentifierhelperchar ( char ch ) { return _str == ch || _str == ch || _str == ch || _str == ch ; }	checks if specified character can be part of xml identifier ( tag name of attribute name ) and is not standard identifier character .
public void addheader ( string line ) { header . add ( line ) ; }	add a header line to this result .
public static iaddress loadaddress ( final resultset resultset , final string columnname ) throws sqlexception { preconditions . checknotnull ( resultset , _str ) ; preconditions . checknotnull ( columnname , _str ) ; final string addressstring = readstring ( resultset , columnname ) ; return resultset . wasnull ( ) ? null : new caddress ( new biginteger ( addressstring ) ) ; }	loads an address value from the database .
private static string encode ( string stringtoencode ) { string encoded ; try { encoded = urlencoder . encode ( stringtoencode , utf_8 ) ; } catch ( unsupportedencodingexception e ) { throw new mcapiruntimeexception ( e ) ; } encoded = encoded . replace ( _str , _str ) ; encoded = encoded . replace ( _str , _str ) ; encoded = encoded . replace ( _str , _str ) ; return encoded ; }	formats the input string for inclusion in a url.
public static string togeturl ( string url , bundle params ) { if ( params != null ) { if ( ! url . endswith ( _str ) ) { url = url + _str ; } for ( string key : params . keyset ( ) ) { url = url + key + _str + params . getstring ( key ) + _str ; } } return url ; }	returns get url with appended parameters .
public void namespaceafterstartelement ( string prefix , string uri ) throws saxexception { if ( m_firsttagnotemitted && m_firstelementuri == null && m_firstelementname != null ) { string prefix1 = getprefixpart ( m_firstelementname ) ; if ( prefix1 == null && emptystring . equals ( prefix ) ) { m_firstelementuri = uri ; } } startprefixmapping ( prefix , uri , _bool ) ; }	this method is used when a prefix / uri namespace mapping is indicated after the element was started with a startelement ( ) and before and endelement ( ).
protected static string guesstype ( file file ) { string name = file . getname ( ) ; string suffix = name . substring ( name . lastindexof ( _str ) + _num ) ; return mimemap . get ( suffix . tolowercase ( locale . root ) ) ; }	guesses the type of a file , based on file name suffix.
public void testadvanceallterms ( ) throws exception { list < string > termslist = new arraylist < > ( ) ; termslist . addall ( arrays . aslist ( commonterms ) ) ; termslist . addall ( arrays . aslist ( mediumterms ) ) ; termslist . addall ( arrays . aslist ( rareterms ) ) ; string terms [ ] = termslist . toarray ( new string [ _num ] ) ; for ( int amount = _num ; amount < _num ; amount += _num ) { for ( int minnrshouldmatch = _num ; minnrshouldmatch <= terms . length ; minnrshouldmatch ++ ) { scorer expected = scorer ( terms , minnrshouldmatch , mode . doc_values ) ; scorer actual = scorer ( terms , minnrshouldmatch , mode . scorer ) ; assertadvance ( expected , actual , amount ) ; expected = scorer ( terms , minnrshouldmatch , mode . doc_values ) ; actual = scorer ( terms , minnrshouldmatch , mode . bulk_scorer ) ; assertadvance ( expected , actual , amount ) ; } } }	test advance with giant bq of all terms with varying minshouldmatch.
public boolean ispublic ( ) { return modifier . ispublic ( getaccessflags ( ) ) ; }	returns true for a public class .
public boolean releaseencumbrancebudget ( final map < string , object > detailsmap ) { if ( detailsmap == null ) throw new validationexception ( arrays . aslist ( new validationerror ( _str , _str ) ) ) ; detailsmap . put ( constants . consumeorrelease , _bool ) ; final bigdecimal bd = getdetails ( detailsmap ) ; return bd . intvalue ( ) == _num ; }	this api will be called for releasing the budget that was already allocated to some estimate or purchase order.
protected transferable createlocaletransferable ( long [ ] formats ) throws ioexception { return null ; }	the clipboard must be opened .
public void putlength ( int len ) throws ioexception { if ( len < _num ) { write ( ( byte ) len ) ; } else if ( len < ( _num << _num ) ) { write ( ( byte ) _num ) ; write ( ( byte ) len ) ; } else if ( len < ( _num << _num ) ) { write ( ( byte ) _num ) ; write ( ( byte ) ( len > > _num ) ) ; write ( ( byte ) len ) ; } else if ( len < ( _num << _num ) ) { write ( ( byte ) _num ) ; write ( ( byte ) ( len > > _num ) ) ; write ( ( byte ) ( len > > _num ) ) ; write ( ( byte ) len ) ; } else { write ( ( byte ) _num ) ; write ( ( byte ) ( len > > _num ) ) ; write ( ( byte ) ( len > > _num ) ) ; write ( ( byte ) ( len > > _num ) ) ; write ( ( byte ) len ) ; } }	put the encoding of the length in the stream .
public void putgenericfontfamily ( string familyname , font font ) { genericfontfamilies . put ( familyname . tolowercase ( ) , font ) ; }	adds a generic font family .
private boolean writereference ( object value , nodemap node ) { string name = get ( value ) ; int size = size ( ) ; if ( name != null ) { node . put ( refer , name ) ; return _bool ; } string unique = string . valueof ( size ) ; node . put ( mark , unique ) ; put ( value , unique ) ; return _bool ; }	this is used to write the xml element attributes representing the serialized object instance.
private nsobject parsedata ( ) throws parseexception { nsobject obj = null ; skip ( ) ; if ( accept ( data_gsobject_begin_token ) ) { skip ( ) ; expect ( data_gsbool_begin_token , data_gsdate_begin_token , data_gsint_begin_token , data_gsreal_begin_token ) ; if ( accept ( data_gsbool_begin_token ) ) { skip ( ) ; expect ( data_gsbool_true_token , data_gsbool_false_token ) ; if ( accept ( data_gsbool_true_token ) ) { obj = new nsnumber ( _bool ) ; } else { obj = new nsnumber ( _bool ) ; } skip ( ) ; } else if ( accept ( data_gsdate_begin_token ) ) { skip ( ) ; string datestring = readinputuntil ( data_end_token ) ; obj = new nsdate ( datestring ) ; } else if ( accept ( data_gsint_begin_token , data_gsreal_begin_token ) ) { skip ( ) ; string numberstring = readinputuntil ( data_end_token ) ; obj = new nsnumber ( numberstring ) ; } read ( data_end_token ) ; } else { string datastring = readinputuntil ( data_end_token ) ; datastring = datastring . replaceall ( _str , _str ) ; int numbytes = datastring . length ( ) / _num ; byte [ ] bytes = new byte [ numbytes ] ; for ( int i = _num ; i < bytes . length ; i ++ ) { string bytestring = datastring . substring ( i * _num , i * _num + _num ) ; int bytevalue = integer . parseint ( bytestring , _num ) ; bytes [ i ] = ( byte ) bytevalue ; } obj = new nsdata ( bytes ) ; skip ( ) ; } return obj ; }	parses a data object from the current parsing position.
public boolean empty ( ) { return individuals . size ( ) == _num ; }	returns true is the population contains no individuals .
@ override public string format ( datetimeformatter formatter ) { objects . requirenonnull ( formatter , _str ) ; return formatter . format ( this ) ; }	formats this date - time using the specified formatter.
public @ dottedclassname string todottedclassname ( ) { return classname . todottedclassname ( classname ) ; }	get the name of the class in dotted format .
public daddextensions ( jframe parent , string title , x509extensionset extensions , publickey authoritypublickey , x500name authoritycertname , biginteger authoritycertserialnumber , publickey subjectpublickey ) { super ( parent , dialog . modalitytype . document_modal ) ; settitle ( res . getstring ( _str ) ) ; this . extensions = extensions ; this . authoritypublickey = authoritypublickey ; this . authoritycertname = authoritycertname ; this . authoritycertserialnumber = authoritycertserialnumber ; this . subjectpublickey = subjectpublickey ; initcomponents ( ) ; }	creates a new daddextensions dialog .
private void playnext ( ) { if ( mediatype == config . youtube_media_type_video ) { seekvideo ( _num ) ; restartvideo ( ) ; return ; } if ( previouswascalled ) { previouswascalled = _bool ; iterator . next ( ) ; } if ( ! iterator . hasnext ( ) ) { iterator = youtubevideos . listiterator ( ) ; } videoitem = iterator . next ( ) ; nextwascalled = _bool ; playvideo ( ) ; }	plays next video in playlist.
public static < t > t invokemethod ( object obj , string name , object ... params ) throws nosuchmethodexception { class [ ] paramtypes = getparamtypes ( params ) ; final class < ? > aclass = obj . getclass ( ) ; method method ; try { method = aclass . getdeclaredmethod ( name , paramtypes ) ; } catch ( nosuchmethodexception e ) { method = aclass . getmethod ( name , paramtypes ) ; } method . setaccessible ( _bool ) ; try { return ( t ) method . invoke ( obj , params ) ; } catch ( illegalaccessexception | invocationtargetexception e ) { throw new runtimeexception ( e ) ; } }	invokes a method by reflection .
public void addnodes ( nodeiterator iterator ) { if ( ! m_mutable ) throw new runtimeexception ( xslmessages . createxpathmessage ( xpatherrorresources . er_nodeset_not_mutable , null ) ) ; if ( null != iterator ) { node obj ; while ( null != ( obj = iterator . nextnode ( ) ) ) { addelement ( obj ) ; } } }	copy nodelist members into this nodelist , adding in document order.
public static rotatestream create ( path path ) { synchronized ( _streams ) { weakreference < rotatestream > ref = _streams . get ( path ) ; rotatestream stream = ref != null ? ref . get ( ) : null ; if ( stream == null ) { stream = new rotatestream ( path ) ; _streams . put ( path , new weakreference < > ( stream ) ) ; } return stream ; } }	returns the rotate stream corresponding to this path.
private void cleanuphistory ( ) { if ( ! mhistoryofnumbers . isempty ( ) && mhistoryofnumbers . size ( ) >= max_history_size ) { for ( int i = _num ; i < math . max ( _num , max_history_size / _num ) ; i ++ ) { mpreviousnumbers . remove ( mhistoryofnumbers . removefirst ( ) ) ; } } }	removes old tracks and cleans up the history preparing for new tracks to be added to the mapping.
@ suppresswarnings ( _str ) protected void processstyledattributes ( @ nonnull typedarray a ) { float targetaspectratiox = math . abs ( a . getfloat ( r . styleable . ucrop_ucropview_ucrop_aspect_ratio_x , default_aspect_ratio ) ) ; float targetaspectratioy = math . abs ( a . getfloat ( r . styleable . ucrop_ucropview_ucrop_aspect_ratio_y , default_aspect_ratio ) ) ; if ( targetaspectratiox == source_image_aspect_ratio || targetaspectratioy == source_image_aspect_ratio ) { mtargetaspectratio = source_image_aspect_ratio ; } else { mtargetaspectratio = targetaspectratiox / targetaspectratioy ; } }	this method extracts all needed values from the styled attributes.
public logmessage ( string template , int code ) { this ( template , null , empty_string_array , code , optional . empty ( ) ) ; }	construct a log message that does not involve any templating .
protected string action_translate ( string act_string , int act_pos , hashtable label_map , hashtable label_types ) { int id_start ; int pos ; int len ; string id_str ; boolean in_id ; stringbuffer result ; char buffer [ ] ; if ( act_string == null || act_string . length ( ) == _num ) return act_string ; len = act_string . length ( ) ; result = new stringbuffer ( len + _num ) ; buffer = new char [ len + _num ] ; act_string . getchars ( _num , len , buffer , _num ) ; buffer [ len ] = _str ; in_id = _bool ; for ( pos = id_start = _num ; pos <= len ; pos ++ ) { if ( in_id ) { if ( ! is_id_char ( buffer [ pos ] ) ) { id_str = new string ( buffer , id_start , pos - id_start ) ; result . append ( label_translate ( id_str , act_pos , label_map , label_types ) ) ; if ( buffer [ pos ] != _str ) result . append ( buffer , pos , _num ) ; in_id = _bool ; } else { } } else { if ( is_id_start ( buffer [ pos ] ) ) { in_id = _bool ; id_start = pos ; } else { if ( buffer [ pos ] != _str ) result . append ( buffer , pos , _num ) ; } } } return result . tostring ( ) ; }	translate all the label names within an action string to appropriate code .
public boolean canload ( ) { return _bool ; }	the command will only load if this condition is true.
public boolean bool ( ) { return ( double . isnan ( m_val ) || ( m_val == _num ) ) ? _bool : _bool ; }	cast result object to a boolean .
protected boolean strictparseboolean ( string s ) { if ( s == null || s . isempty ( ) ) { throw new illegalargumentexception ( _str ) ; } if ( s . equalsignorecase ( _str ) ) { return _bool ; } if ( s . equalsignorecase ( _str ) ) { return _bool ; } throw new illegalargumentexception ( _str + s ) ; }	we need this strict function because boolean . parseboolean silently ignores malformed strings.
@ override public boolean eisset ( int featureid ) { switch ( featureid ) { case functionblockpackage . event__name : return name_edefault == null ? name != null : ! name_edefault . equals ( name ) ; case functionblockpackage . event__properties : return properties != null && ! properties . isempty ( ) ; } return super . eisset ( featureid ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
public string format ( datetimeformatter formatter ) { objects . requirenonnull ( formatter , _str ) ; return formatter . format ( this ) ; }	formats this time using the specified formatter.
private void initializesourcecodemap ( string adaptedcontent ) { sourcecodewithline = new linkedhashmap < > ( ) ; int linenumber = _num ; stringreader sr = new stringreader ( adaptedcontent ) ; bufferedreader br = new bufferedreader ( sr ) ; string line ; try { while ( ( line = br . readline ( ) ) != null ) { sourcecodewithline . put ( linenumber , line ) ; linenumber ++ ; } } catch ( ioexception ex ) { logger . error ( _str + ex . getmessage ( ) ) ; } }	initialisation of a local map that handles each source code line , keyed by the line number.
public matrix u ( ) { return u . clone ( ) ; }	return the left singular vectors.
protected set < string > allowedduplicateerrorcodes ( ) { return collections . emptyset ( ) ; }	override this if the should_not_contain_same_error_codes_for_different_instances_that_are_not_wrappers test is failing and you * really * want to allow one or more of your error codes to have duplicate apierrors that are not wrappers.
private boolean isfieldvisited ( object object , field objectfield , field field ) { map < string , set < string > > bag = visitedfields . get ( object ) ; if ( bag == null ) { return _bool ; } string objectfiledkey = objectfield == null ? _str : objectfield . togenericstring ( ) ; set < string > fields = bag . get ( objectfiledkey ) ; return fields != null && fields . contains ( field ) ; }	indicates whether the field of a target object is visited.
public void removefromcompletedlist ( downloadinforunnable downloadinforunnable ) { mcompletedlist . remove ( downloadinforunnable ) ; }	removes a download from the completed list .
protected void addshingledphrasequeries ( final booleanquery mainquery , final list < clause > clauses , final collection < fieldparams > fields , int shinglesize , final float tiebreaker , final int slop ) throws syntaxerror { if ( null == fields || fields . isempty ( ) || null == clauses || clauses . size ( ) < shinglesize ) return ; if ( _num == shinglesize ) shinglesize = clauses . size ( ) ; final int lastclauseindex = shinglesize - _num ; stringbuilder userphrasequery = new stringbuilder ( ) ; for ( int i = _num ; i < clauses . size ( ) - lastclauseindex ; i ++ ) { userphrasequery . append ( _str ) ; for ( int j = _num ; j <= lastclauseindex ; j ++ ) { userphrasequery . append ( clauses . get ( i + j ) . val ) ; userphrasequery . append ( _str ) ; } userphrasequery . append ( _str ) ; userphrasequery . append ( _str ) ; } extendedsolrqueryparser pp = createedismaxqueryparser ( this , impossible_field_name ) ; pp . addalias ( impossible_field_name , tiebreaker , getfieldboosts ( fields ) ) ; pp . setphraseslop ( slop ) ; pp . setremovestopfilter ( _bool ) ; pp . makedismax = _bool ; pp . minclausesize = _num ; query phrase = pp . parse ( userphrasequery . tostring ( ) ) ; if ( phrase != null ) { mainquery . add ( phrase , booleanclause . occur . should ) ; } }	modifies the main query by adding a new optional query consisting of shingled phrase queries across the specified clauses using the specified field = & gt ; boost mappings .
public string asxmlid ( ) { return datatypeconverter . printhexbinary ( tokendigest . getvalue ( ) ) ; }	return an id conformant to xml id.
public void createsnapshot ( ) throws backupexception { logger . debug ( _str + this . snapshotname ) ; processhelper . exec ( _str , lvcreatecmd ) ; }	creates a new snapshot , which is assumed not to exist already .
public final uri storelogfile ( final logfile logfile , final int sessionid ) { final contentvalues values = new contentvalues ( ) ; values . put ( schema . col_manufacturer , logfile . getmanufacturer ( ) ) ; values . put ( schema . col_model , logfile . getmodel ( ) ) ; values . put ( schema . col_revision , logfile . getrevision ( ) ) ; values . put ( schema . col_swid , logfile . getswid ( ) ) ; values . put ( schema . col_swver , logfile . getswversion ( ) ) ; values . put ( schema . col_timestamp , system . currenttimemillis ( ) ) ; values . put ( schema . col_session_id , sessionid ) ; return contentresolver . insert ( contentprovider . content_uri_logfile , values ) ; }	persists logfile in database .
public map < string , string > merge ( map < string , string > curprops , map < string , string > newprops ) throws ioexception { map < string , string > props = new hashmap < > ( newprops ) ; for ( map . entry < string , string > e : curprops . entryset ( ) ) { string name = e . getkey ( ) ; string curvalue = e . getvalue ( ) ; if ( props . containskey ( name ) ) { props . put ( name , curvalue ) ; } } return props ; }	merges two bunches of the properties from current and new configurations .
public builder deletepreferredlanguage ( ) { deletefields . add ( _str ) ; return this ; }	delete the preferred language of a existing user.
public void onprepared ( mediaplayer player ) { mstate = state . playing ; updatenotification ( string . format ( getstring ( r . string . media_state_playing ) , mfile . getfilename ( ) ) ) ; if ( mmediacontroller != null ) { mmediacontroller . setenabled ( _bool ) ; } player . seekto ( mstartposition ) ; configandstartmediaplayer ( ) ; if ( ! mplayonprepared ) { processpauserequest ( ) ; } if ( mmediacontroller != null ) { mmediacontroller . updatepauseplay ( ) ; } }	called when media player is done preparing.
private void parseparameter ( string token , string value ) { if ( token != null && value != null ) { if ( token . equalsignorecase ( nonce_token ) ) { mnonce = value ; return ; } if ( token . equalsignorecase ( stale_token ) ) { parsestale ( value ) ; return ; } if ( token . equalsignorecase ( opaque_token ) ) { mopaque = value ; return ; } if ( token . equalsignorecase ( qop_token ) ) { mqop = value . tolowercase ( ) ; return ; } if ( token . equalsignorecase ( algorithm_token ) ) { malgorithm = value . tolowercase ( ) ; return ; } } }	if the token is a known parameter name , parses and initializes the token value .
public void skip ( int n ) throws ioexception { dis . skip ( n ) ; }	skip a set amount of bytes .
public void toallinradius ( worldserver world , vec3d pos , double radius ) { double maxdistance = radius * radius + radius * radius + radius * radius ; toall ( world . getplayers ( entityplayermp . class , null ) ) ; }	sends this packet to all the players in the world within the radius.
public static ecdhecryptography fromnamedcurveid ( int supportedgroupid ) { supportedgroup group = supportedgroup . fromid ( supportedgroupid ) ; if ( group == null ) { return null ; } else { try { return new ecdhecryptography ( group . name ( ) ) ; } catch ( generalsecurityexception e ) { logger . log ( level . warning , _str , new object [ ] { group . name ( ) , e . getmessage ( ) } ) ; return null ; } } }	creates an ephemeral ecdh key pair for a supported group ( named curve ) .
private static void addheader ( message message , string name , string value ) { map < string , list < string > > protocolheaders = castutils . cast ( ( map < ? , ? > ) message . get ( message . protocol_headers ) ) ; if ( protocolheaders == null ) { protocolheaders = new treemap < string , list < string > > ( string . case_insensitive_order ) ; message . put ( message . protocol_headers , protocolheaders ) ; } list < string > header = castutils . cast ( ( list < ? > ) protocolheaders . get ( name ) ) ; if ( header == null ) { header = new arraylist < string > ( ) ; protocolheaders . put ( name , header ) ; } if ( header . size ( ) == _num ) { header . add ( value ) ; } else { header . set ( _num , header . get ( _num ) + _str + value ) ; } }	adds a value to a header.
public string asstring ( ) { stringbuilder buff = new stringbuilder ( ) ; for ( int i = _num ; i < arraylevel ; i ++ ) { if ( refcount ) { buff . append ( _str ) ; } buff . append ( _str ) ; } if ( refcount ) { if ( ! classobj . isprimitive ) { buff . append ( _str ) ; } } buff . append ( classobj . tostring ( ) ) ; if ( refcount ) { if ( ! classobj . isprimitive ) { buff . append ( _str ) ; } } for ( int i = _num ; i < arraylevel ; i ++ ) { if ( refcount ) { buff . append ( _str ) ; } else { if ( ! classobj . isprimitive ) { buff . append ( _str ) ; } } buff . append ( _str ) ; } if ( ! refcount ) { if ( isobject ( ) ) { buff . append ( _str ) ; } } return buff . tostring ( ) ; }	get the c + + code .
public boolean recreateworkspacetable ( sqlitedatabase db ) { db . begintransaction ( ) ; try { cursor c = db . query ( table_workspace_screens , new string [ ] { launchersettings . workspacescreens . _id } , null , null , null , null , launchersettings . workspacescreens . screen_rank ) ; arraylist < long > sortedids = new arraylist < long > ( ) ; long maxid = _num ; try { while ( c . movetonext ( ) ) { long id = c . getlong ( _num ) ; if ( ! sortedids . contains ( id ) ) { sortedids . add ( id ) ; maxid = math . max ( maxid , id ) ; } } } finally { c . close ( ) ; } db . execsql ( _str + table_workspace_screens ) ; addworkspacestable ( db , _bool ) ; int total = sortedids . size ( ) ; for ( int i = _num ; i < total ; i ++ ) { contentvalues values = new contentvalues ( ) ; values . put ( launchersettings . workspacescreens . _id , sortedids . get ( i ) ) ; values . put ( launchersettings . workspacescreens . screen_rank , i ) ; addmodifiedtime ( values ) ; db . insertorthrow ( table_workspace_screens , null , values ) ; } db . settransactionsuccessful ( ) ; mmaxscreenid = maxid ; } catch ( sqlexception ex ) { log . e ( tag , ex . getmessage ( ) , ex ) ; return _bool ; } finally { db . endtransaction ( ) ; } return _bool ; }	recreates workspace table and migrates data to the new table .
public list < jsonobject > executeparametrizedstatement ( string statement , list < string > parameternames , list < object > parametervalues ) { jsonobject namedparams = jsonobject . create ( ) ; for ( int param = _num ; param < parameternames . size ( ) ; param ++ ) { namedparams . put ( parameternames . get ( param ) , parametervalues . get ( param ) ) ; } parameterizedn1qlquery query = n1qlquery . parameterized ( statement , namedparams ) ; return executequery ( query ) ; }	executes a n1ql statement with named parameters .
public final t endall ( ) { while ( ! tagstack . isempty ( ) ) { end ( ) ; } return getself ( ) ; }	closes all open tags .
public void entityreference ( string name ) throws org . xml . sax . saxexception { append ( m_doc . createentityreference ( name ) ) ; }	receive notivication of a entityreference .
private boolean linklast ( node < e > node ) { if ( count >= capacity ) return _bool ; node < e > l = last ; node . prev = l ; last = node ; if ( first == null ) first = node ; else l . next = node ; ++ count ; notempty . signal ( ) ; return _bool ; }	links node as last element , or returns false if full .
void drawdivider ( canvas canvas , rect bounds , int childindex ) { final drawable divider = mdivider ; final boolean clipdivider = mclipdivider ; if ( ! clipdivider ) { divider . setbounds ( bounds ) ; } else { canvas . save ( ) ; canvas . cliprect ( bounds ) ; } divider . draw ( canvas ) ; if ( clipdivider ) { canvas . restore ( ) ; } }	draws a divider for the given child in the given bounds .
protected formspec ( defaultalignment defaultalignment , string encodeddescription ) { this ( defaultalignment , sizes . default , no_grow ) ; parseandinitvalues ( encodeddescription . tolowercase ( locale . english ) ) ; }	constructs a formspec from the specified encoded description.
public static < t > list < t > decode ( inputstream data , parser < t > parser ) throws ioexception { codedinputstream stream = codedinputstream . newinstance ( data ) ; list < t > list = new arraylist < > ( ) ; while ( ! stream . isatend ( ) ) { int size = stream . readrawvarint32 ( ) ; byte [ ] element = stream . readrawbytes ( size ) ; t decoded = parser . parsefrom ( element ) ; list . add ( decoded ) ; } return list ; }	decode custom protobuf variable length array .
public static void writeint ( dataoutput out , int v ) throws ioexception { out . writebyte ( _num & v ) ; out . writebyte ( _num & ( v > > > _num ) ) ; out . writebyte ( _num & ( v > > > _num ) ) ; out . writebyte ( _num & ( v > > > _num ) ) ; }	writes a little - endian int .
public void writefield ( final string name , final double value ) throws java . io . ioexception { writefield ( name , double . tostring ( value ) ) ; }	writes an double field value .
public creature calculatenextcreature ( final int questlevel ) { final list < creature > possiblecreaturestospawn = new arraylist < creature > ( ) ; int lastlevel = _num ; for ( final creature creature : sortedcreatures ) { if ( creature . getlevel ( ) > questlevel ) { break ; } if ( creature . getlevel ( ) > lastlevel ) { possiblecreaturestospawn . clear ( ) ; lastlevel = creature . getlevel ( ) ; } possiblecreaturestospawn . add ( creature ) ; } creature creaturetospawn = null ; if ( possiblecreaturestospawn . size ( ) == _num ) { creaturetospawn = sortedcreatures . get ( sortedcreatures . size ( ) - _num ) ; } else { collections . shuffle ( possiblecreaturestospawn ) ; creaturetospawn = possiblecreaturestospawn . get ( _num ) ; } return creaturetospawn ; }	calculates which type of creature should be spawned next .
@ override public void before ( propertyinforestrep oldprops , propertyinforestrep newprops ) { string newintervalstr = newprops . getproperty ( backupconstants . schedule_interval ) ; string newstarttimestr = newprops . getproperty ( backupconstants . schedule_time ) ; if ( ( newintervalstr == null || newintervalstr . isempty ( ) ) && ( newstarttimestr == null || newstarttimestr . isempty ( ) ) ) { _log . info ( _str ) ; return ; } string intervalstr = ( newintervalstr == null || newintervalstr . isempty ( ) ) ? oldprops . getproperty ( backupconstants . schedule_interval ) : newintervalstr ; string starttimestr = ( newstarttimestr == null || newstarttimestr . isempty ( ) ) ? oldprops . getproperty ( backupconstants . schedule_time ) : newstarttimestr ; _log . info ( _str , intervalstr , starttimestr ) ; validatebackupintervalandstarttime ( intervalstr , starttimestr ) ; }	check if backup related configurations conformed to rules , if not fail the property update .
@ override public void deletetrait ( string guid , string traitnametobedeleted ) throws atlasexception { guid = paramchecker . notempty ( guid , _str ) ; traitnametobedeleted = paramchecker . notempty ( traitnametobedeleted , _str ) ; if ( ! typesystem . isregistered ( traitnametobedeleted ) ) { final string msg = string . format ( _str , traitnametobedeleted ) ; log . error ( msg ) ; throw new typenotfoundexception ( msg ) ; } repository . deletetrait ( guid , traitnametobedeleted ) ; ontraitdeletedfromentity ( repository . getentitydefinition ( guid ) , traitnametobedeleted ) ; }	deletes a given trait from an existing entity represented by a guid .
public void addtables ( collection < table > tables ) { for ( iterator < table > it = tables . iterator ( ) ; it . hasnext ( ) ; ) { addtable ( ( table ) it . next ( ) ) ; } }	adds the given tables .
protected void writefile ( string template , writer writer ) { if ( template == null ) { throw new illegalargumentexception ( _str ) ; } bufferedwriter bufferedwriter = new bufferedwriter ( writer ) ; string output = replace ( template , null ) ; try { bufferedwriter . append ( output ) ; } catch ( ioexception e ) { logger . log ( diagnostic . kind . error , _str ) ; e . printstacktrace ( ) ; } finally { try { bufferedwriter . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } }	replace placeholder in template.
public synchronized boolean clear ( ) { if ( isloading ( ) ) { return _bool ; } loader = new thread ( null ) ; loader . start ( ) ; return _bool ; }	will clear the current classes and reload in another thread .
public int indexof ( final roundedtoolitem item ) { checkwidget ( ) ; return items . indexof ( item ) ; }	searches the receiver ' s list starting at the first item ( index 0 ) until an item is found that is equal to the argument , and returns the index of that item.
public void addattribute ( string alias , string typeuri , boolean required , int count ) throws messageexception { if ( alias . indexof ( _str ) > - _num || alias . indexof ( _str ) > - _num || alias . indexof ( _str ) > - _num || alias . indexof ( _str ) > - _num ) throw new messageexception ( _str + alias ) ; _parameters . set ( new parameter ( _str + alias , typeuri ) ) ; string level = required ? _str : _str ; parameter levelparam = _parameters . getparameter ( level ) ; parameter newparam ; if ( levelparam == null ) { newparam = new parameter ( level , alias ) ; } else { newparam = new parameter ( level , levelparam . getvalue ( ) + _str + alias ) ; _parameters . removeparameters ( level ) ; } _parameters . set ( newparam ) ; setcount ( alias , count ) ; if ( debug ) _log . debug ( _str + typeuri + _str + alias + _str + count + _str + required ) ; }	adds an attribute to the fetch request .
public void call ( ) throws exception { final list < future < void > > tasks = new linkedlist < future < void > > ( ) ; try { for ( iv < ? , ? > termid : graphs ) { final futuretask < void > ft = new futuretask < void > ( new drainiteratortask ( termid ) ) ; tasks . add ( ft ) ; executor . execute ( ft ) ; } for ( future < void > f : tasks ) { f . get ( ) ; } } catch ( throwable ex ) { for ( future < void > f : tasks ) f . cancel ( _bool ) ; throw new runtimeexception ( ex ) ; } finally { buffer . close ( ) ; } return null ; }	outer callable submits tasks for execution .
protected void runfullimport ( string dataconfig , map < string , string > extraparams ) throws exception { hashmap < string , string > params = new hashmap < > ( ) ; params . put ( _str , _str ) ; params . put ( _str , _str ) ; params . put ( _str , dataconfig ) ; params . put ( _str , _str ) ; params . put ( _str , _str ) ; params . putall ( extraparams ) ; namedlist l = new namedlist ( ) ; for ( map . entry < string , string > e : params . entryset ( ) ) { l . add ( e . getkey ( ) , e . getvalue ( ) ) ; } localsolrqueryrequest request = new localsolrqueryrequest ( h . getcore ( ) , l ) ; h . query ( _str , request ) ; }	runs a full - import using the given dataconfig and the provided request parameters.
public string useridfromrange ( object ominid , object omaxid ) { int minid = functionhandler . getint ( ominid ) ; int maxid = functionhandler . getint ( omaxid ) ; stack < integer > stack = getstack ( minid , maxid ) ; if ( stack . size ( ) > _num ) { return integer . tostring ( stack . pop ( ) ) ; } throw new illegalargumentexception ( _str ) ; }	generate a random user id in the range provided.
public void start ( ) { if ( isstarted ) { log . info ( _str ) ; return ; } log . info ( _str ) ; systemconsumer . start ( ) ; isstarted = _bool ; }	starts the underlying systemconsumer .
public static void generatebinaryoperationflags ( final itranslationenvironment environment , final long nextoffset , final string result , final operandsize resultsize , final list < reilinstruction > instructions ) throws illegalargumentexception { preconditions . checknotnull ( environment , _str ) ; preconditions . checknotnull ( result , _str ) ; preconditions . checknotnull ( resultsize , _str ) ; preconditions . checknotnull ( instructions , _str ) ; final long baseoffset = nextoffset - instructions . size ( ) ; long offset = nextoffset ; generatesignflagcode ( environment , offset , result , resultsize , instructions ) ; offset = ( baseoffset + instructions . size ( ) ) - _num ; instructions . add ( reilhelpers . createbisz ( offset + _num , resultsize , result , operandsize . byte , helpers . zero_flag ) ) ; instructions . add ( reilhelpers . createstr ( offset + _num , operandsize . byte , _str , operandsize . byte , helpers . carry_flag ) ) ; instructions . add ( reilhelpers . createstr ( offset + _num , operandsize . byte , _str , operandsize . byte , helpers . overflow_flag ) ) ; }	sets the flags according to the result of a binary and / or / xor operation .
public boolean islabelmovable ( ) { mxgraph graph = graphcomponent . getgraph ( ) ; string label = graph . getlabel ( state . getcell ( ) ) ; return graph . islabelmovable ( state . getcell ( ) ) && label != null && label . length ( ) > _num ; }	returns true if the label is movable .
public int writetypelist ( typelist typelist ) { int off = data . position ( ) ; short [ ] types = typelist . types ; writeint ( types . length ) ; for ( short type : types ) { writeshort ( type ) ; } return off ; }	write typelist item into current section .
public static void loadconfigresource ( string resourcename ) throws ioexception { config . clear ( ) ; config . putall ( loadpropertiesfromresource ( resourcename ) ) ; }	load configuration from resource in current class loader .
public static void safeclosestream ( inputstream in ) { if ( in != null ) { try { in . close ( ) ; } catch ( exception e ) { log . error ( e . getmessage ( ) , e ) ; } } }	close streams without pain.
private transaction createtransaction ( ) throws leasedeniedexception , remoteexception , transactionexception { itransactionmanagerprovider transactionmanagerprovider = gettransactionmanagerprovider ( ) ; return ( transactionfactory . create ( transactionmanagerprovider . gettransactionmanager ( ) , _config . gettransactiontimeout ( ) ) ) . transaction ; }	create new transaction using the local transaction manager.
public void skipwhile ( string skip ) throws ioexception { char ch ; do { ch = read ( ) ; } while ( skip . indexof ( ch ) > - _num ) ; unreadcharacter ( ch ) ; }	skips char any contiguous characters in skip.
public static string packagetopath ( string packagename ) { return packagename . replace ( _str , file . separatorchar ) ; }	converts a package name to a path by replacing all '.
@ override public boolean containskey ( object key ) { if ( key == null ) { return entryfornullkey != null ; } int hash = key . hashcode ( ) ; hash ^= ( hash > > > _num ) ^ ( hash > > > _num ) ; hash ^= ( hash > > > _num ) ^ ( hash > > > _num ) ; hashmapentry < k , v > [ ] tab = table ; for ( hashmapentry < k , v > e = tab [ hash & ( tab . length - _num ) ] ; e != null ; e = e . next ) { k ekey = e . key ; if ( ekey == key || ( e . hash == hash && key . equals ( ekey ) ) ) { return _bool ; } } return _bool ; }	returns whether this map contains the specified key .
protected boolean isvalidfragment ( string fragment ) { if ( fragment == null ) { return _bool ; } return isoff ( no_fragments ) ; }	returns true if the given fragment is null or fragments are allowed .
private void rehash ( ) { int oldcapacity = m_capacity ; hashentry [ ] oldtable = m_table ; int newcapacity = _num * oldcapacity + _num ; m_capacity = newcapacity ; m_threshold = ( int ) ( newcapacity * m_loadfactor ) ; m_table = new hashentry [ newcapacity ] ; for ( int i = oldcapacity - _num ; i >= _num ; i -- ) { for ( hashentry old = oldtable [ i ] ; old != null ; ) { hashentry e = old ; old = old . next ; int newindex = e . hash % newcapacity ; if ( newindex < _num ) newindex = - newindex ; e . next = m_table [ newindex ] ; m_table [ newindex ] = e ; } } }	increases the capacity of and internally reorganizes the hashtable , in order to accommodate and access its entries more efficiently.
public void savepoisfromassets ( ) { list < poi > pois = poiassetloader . loadpoisfromassets ( ) ; timber . d ( _str , pois . size ( ) ) ; for ( poi poi : pois ) { timber . d ( _str , poi ) ; savepoi ( poi ) ; timber . d ( _str ) ; } }	load pois from assets and save them in the database .
private void createelement ( document doc , element parentelement , string elementname , color value ) { element element = doc . createelement ( elementname ) ; element . appendchild ( doc . createtextnode ( colourutils . fromcolour ( value ) ) ) ; parentelement . appendchild ( element ) ; }	creates the xml element for a colour value .
public static boolean beendone ( @ scope int scope , string tag , countchecker numberoftimes ) { list < long > tagseendates = taglastseenmap . get ( tag ) ; if ( tagseendates . isempty ( ) ) { return _bool ; } if ( scope == this_app_install ) { return numberoftimes . check ( tagseendates . size ( ) ) ; } else if ( scope == this_app_session ) { int counter = _num ; for ( string tagfromlist : sessionlist ) { if ( tagfromlist . equals ( tag ) ) { counter ++ ; } } return numberoftimes . check ( counter ) ; } else { int counter = _num ; for ( long seendate : tagseendates ) { if ( seendate > lastappupdatedtime ) { counter ++ ; } } return numberoftimes . check ( counter ) ; } }	checks if a tag has been marked done within a given scope a specific number of times .
void variableoperatorchanged ( int row , string oper ) { conditionalvariable variable = _variablelist . get ( row ) ; int oldoper = variable . getopern ( ) ; if ( row > _num ) { if ( oper . equals ( bundle . getmessage ( _str ) ) ) { variable . setopern ( conditional . operator_or ) ; } else { variable . setopern ( conditional . operator_and ) ; } } else { variable . setopern ( conditional . operator_none ) ; } if ( variable . getopern ( ) != oldoper ) { makeantecedent ( ) ; } }	responds to the operator column in the edit conditional window.
public void addheader ( string name , string val ) { mmsgheader = mmsgheader + name + _str + val + mlinedelimiter ; addinternalheaderfields ( name , val ) ; }	add a header with the name and value given.
public static void checkduplicaterequest ( redisclient redisclient , string uri , buffer buffer , string ttl , handler < boolean > callback ) { integer timetolive = parsetimetolive ( ttl ) ; string rediskey = getrediskey ( uri , hashcodegenerator . createhashcode ( uri , buffer . tostring ( ) ) ) ; handlestorage ( redisclient , rediskey , timetolive , callback ) ; }	this method checks if an entry for the provided information ( uri and buffer ) is stored in the redis database.
boolean ishidden ( view view ) { return mhiddenviews . contains ( view ) ; }	returns whether a view is visible to layoutmanager or not .
public static void deleterecursive ( @ nonnull file fileordirectory ) { deleterecursive ( fileordirectory , collections . empty_list ) ; }	deletes a file or directory and all its content recursively .
static boolean doesmenubarbordertoolbar ( jmenubar c ) { jtoolbar tb = ( jtoolbar ) metaltoolbarui . findregisteredcomponentoftype ( c , jtoolbar . class ) ; if ( tb != null && tb . getorientation ( ) == jtoolbar . horizontal ) { jrootpane rp = swingutilities . getrootpane ( c ) ; point point = new point ( _num , _num ) ; point = swingutilities . convertpoint ( c , point , rp ) ; int menux = point . x ; int menuy = point . y ; point . x = point . y = _num ; point = swingutilities . convertpoint ( tb , point , rp ) ; return ( point . x == menux && menuy + c . getheight ( ) == point . y && c . getwidth ( ) == tb . getwidth ( ) ) ; } return _bool ; }	returns true if the passed in jmenubar is above a horizontal jtoolbar .
void constructnode ( string nodename , string prefix , string nodenamespace , transformerimpl transformer ) throws transformerexception { boolean shouldaddattrs ; try { serializationhandler rhandler = transformer . getresulttreehandler ( ) ; if ( null == nodename ) { shouldaddattrs = _bool ; } else { if ( null != prefix ) { rhandler . startprefixmapping ( prefix , nodenamespace , _bool ) ; } rhandler . startelement ( nodenamespace , qname . getlocalpart ( nodename ) , nodename ) ; super . execute ( transformer ) ; shouldaddattrs = _bool ; } transformer . executechildtemplates ( this , shouldaddattrs ) ; if ( null != nodename ) { rhandler . endelement ( nodenamespace , qname . getlocalpart ( nodename ) , nodename ) ; if ( null != prefix ) { rhandler . endprefixmapping ( prefix ) ; } } } catch ( saxexception se ) { throw new transformerexception ( se ) ; } }	construct a node in the result tree.
private priorityqueue < usfield > createqueue ( string fieldname , map < string , flt > words ) throws ioexception { int numdocs = ir . numdocs ( ) ; freqq res = new freqq ( words . size ( ) ) ; for ( string word : words . keyset ( ) ) { float tf = words . get ( word ) . x ; if ( mintermfreq > _num && tf < mintermfreq ) { continue ; } int docfreq = ir . docfreq ( new term ( fieldname , word ) ) ; if ( mindocfreq > _num && docfreq < mindocfreq ) { continue ; } if ( docfreq == _num || docfreq > maxdocfreq ) { continue ; } float idf = similarity . idf ( docfreq , numdocs ) ; float score = _num ; if ( islogtf ( ) ) { score = ( float ) ( math . log ( tf + _num ) * idf ) ; } else { score = tf * idf ; } usfield mltfield ; if ( ispayloadfield ( fieldname ) ) { mltfield = new usfield ( word , fieldname , score , tf , idf , docfreq , _num ) ; } else { mltfield = new usfield ( word , fieldname , score , tf , idf , docfreq ) ; } res . insertwithoverflow ( mltfield ) ; } return res ; }	create a priorityqueue from a word - > tf map .
public static void eachobject ( objectinputstream ois , closure closure ) throws ioexception , classnotfoundexception { try { while ( _bool ) { try { object obj = ois . readobject ( ) ; closure . call ( obj ) ; } catch ( eofexception e ) { break ; } } inputstream temp = ois ; ois = null ; temp . close ( ) ; } finally { closewithwarning ( ois ) ; } }	iterates through the given object stream object by object.
private static int exitwithstatus ( int status ) { if ( toolio . getmode ( ) == toolio . system ) { system . exit ( status ) ; } return status ; }	if run in the system mode , exits the program , in tool mode returns the status.
public static double distanceinmeters ( final double latp1 , final double latp2 , final double lonp1 , final double lonp2 ) { double distrad = math . acos ( math . sin ( toradians ( latp1 ) ) * math . sin ( toradians ( latp2 ) ) + math . cos ( toradians ( latp1 ) ) * math . cos ( toradians ( latp2 ) ) * math . cos ( toradians ( lonp1 - lonp2 ) ) ) ; final double distasdegree = todegrees ( distrad ) ; return distasdegree * _num * _num * _num ; }	computes the distance between two coordinates in meters .
public void processchallenge ( final string challenge ) throws malformedchallengeexception { string s = authchallengeparser . extractscheme ( challenge ) ; if ( ! s . equalsignorecase ( getschemename ( ) ) ) { throw new malformedchallengeexception ( _str + challenge ) ; } int i = challenge . indexof ( _str ) ; if ( i != - _num ) { s = challenge . substring ( i , challenge . length ( ) ) ; this . ntlmchallenge = s . trim ( ) ; this . state = type2_msg_received ; } else { this . ntlmchallenge = _str ; if ( this . state == uninitiated ) { this . state = initiated ; } else { this . state = failed ; } } }	processes the ntlm challenge .
public static biginteger calculatea ( biginteger p , biginteger q , biginteger ga , biginteger x2s ) { return ga . modpow ( x2s , p ) ; }	calculate a as done in round 2 .
public static mcostqueue add ( mproduct product , int m_attributesetinstance_id , macctschema as , int ad_org_id , int m_costelement_id , bigdecimal amt , bigdecimal qty , int precision , mcostdetail cd , string trxname ) { if ( clogmgt . islevelfine ( ) ) s_log . fine ( _str + ad_org_id + _str + product . get_id ( ) + _str + m_attributesetinstance_id + _str + amt + _str + qty + _str + precision ) ; mcostqueue cq = new mcostqueue ( product , m_attributesetinstance_id , as , ad_org_id , m_costelement_id , trxname ) ; cq . setcosts ( amt , qty , precision ) ; cq . setdateacct ( cd . getdateacct ( ) ) ; cq . saveex ( ) ; if ( clogmgt . islevelfine ( ) ) s_log . fine ( _str + cq ) ; return cq ; }	push to queue record . costinglevel is not validated.
public void addundoevent ( undointerface event ) { if ( shouldprocessundoredoaction ( ) ) { boolean atendoflist = ( currentindex >= undolist . size ( ) ) ; if ( ! atendoflist ) { while ( undolist . size ( ) > currentindex ) { int lastindex = undolist . size ( ) - _num ; undolist . remove ( lastindex ) ; } } undolist . add ( event ) ; currentindex = undolist . size ( ) ; updatemenuitems ( ) ; logger . debug ( event . getstringrepresentation ( ) ) ; } }	adds the undo event .
public static exception establishcacheifneeded ( printstream ... progress ) { if ( m_offline ) { return null ; } if ( rep_mirror == null ) { establishmirror ( ) ; } exception problem = null ; if ( initial_cache_build_needed ) { for ( printstream p : progress ) { p . println ( _str ) ; } problem = refreshcache ( progress ) ; initial_cache_build_needed = _bool ; } return problem ; }	establish the local copy of the package meta data if needed.
public spanny append ( charsequence text , imagespan imagespan ) { text = _str + text ; append ( text ) ; setspan ( imagespan , length ( ) - text . length ( ) , length ( ) - text . length ( ) + _num ) ; return this ; }	add the imagespan to the start of the text .
public static boolean validatepassword ( string password , string correcthash ) throws nosuchalgorithmexception , invalidkeyspecexception { return validatepassword ( password . tochararray ( ) , correcthash ) ; }	validates a password using a hash .
public list < snapshot > currentsnapshots ( string repositoryname ) { list < snapshot > snapshotlist = new arraylist < > ( ) ; list < snapshotsinprogress . entry > entries = currentsnapshots ( repositoryname , null ) ; for ( snapshotsinprogress . entry entry : entries ) { snapshotlist . add ( inprogresssnapshot ( entry ) ) ; } collectionutil . timsort ( snapshotlist ) ; return collections . unmodifiablelist ( snapshotlist ) ; }	returns a list of currently running snapshots from repository sorted by snapshot creation date.
public void addcertificate ( x509certificateholder certificate ) throws cmsexception { certs . add ( certificate . toasn1structure ( ) ) ; }	add a certificate to the certificate set to be included with the generated signeddata message .
public void testcase8 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = _num ; byte rbytes [ ] = { _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = biginteger . zero ; biginteger result = anumber . multiply ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	multiply a number by zero .
private void cleanstatic ( methodnode method ) { }	finds the begining of the zkm blurb , the end , then removed everything in between !.
@ override protected void painttabbackground ( graphics g , int tabplacement , int tabindex , int x , int y , int w , int h , boolean isselected ) { if ( isselected ) { if ( tabplacement == top ) { g . setcolor ( color . white ) ; g . fillroundrect ( x , y , w , h + r + r , r , r ) ; } } else { } }	give selected tab blue color with a gradient ! ! . fixme : with plastic l & f the unselected background is too dark.
private automaton buildautomaton ( bytesrefhash termbyteshash ) { final treeset < bytesref > terms = new treeset < bytesref > ( ) ; for ( int i = _num ; i < termbyteshash . size ( ) ; i ++ ) { bytesref ref = new bytesref ( ) ; termbyteshash . get ( i , ref ) ; terms . add ( ref ) ; } final automaton a = daciukmihovautomatonbuilder . build ( terms ) ; return a ; }	build an automaton to represent the frontier query.
protected range findrangebounds ( categorydataset dataset , boolean includeinterval ) { if ( dataset == null ) { return null ; } if ( getdataboundsincludesvisibleseriesonly ( ) ) { list visibleserieskeys = new arraylist ( ) ; int seriescount = dataset . getrowcount ( ) ; for ( int s = _num ; s < seriescount ; s ++ ) { if ( isseriesvisible ( s ) ) { visibleserieskeys . add ( dataset . getrowkey ( s ) ) ; } } return datasetutilities . findrangebounds ( dataset , visibleserieskeys , includeinterval ) ; } else { return datasetutilities . findrangebounds ( dataset , includeinterval ) ; } }	returns the range of values the renderer requires to display all the items from the specified dataset .
protected string adminshutdown ( ) { server . shutdown ( ) ; return _str ; }	stop the application and the server .
public long num_threads ( ) { return long . parselong ( fields [ _num ] ) ; }	number of threads in this process ( since linux 2.
public void assignrole ( amrole role ) throws amexception , ssoexception { assignrole ( role . getdn ( ) ) ; }	assigns a role to the user .
public orderedthreadpoolexecutor ( int corepoolsize , int maximumpoolsize ) { this ( corepoolsize , maximumpoolsize , default_keep_alive , timeunit . seconds , executors . defaultthreadfactory ( ) , null ) ; }	creates a default threadpool , with default values : - keepalive set to 30 seconds - a default threadfactory - all events are accepted.
protected void writeinitialstyles ( ) throws ioexception { out . flushbits ( ) ; fillbits = outstream . determineunsignedbitsize ( fillstyles . size ( ) ) ; linebits = outstream . determineunsignedbitsize ( linestyles . size ( ) ) ; if ( ! hasstyle ) { fillbits = _num ; } else { writestyles ( fillstyles ) ; writestyles ( linestyles ) ; out . flushbits ( ) ; } out . writeubits ( _num , fillbits ) ; out . writeubits ( _num , linebits ) ; }	description of the method.
public static < t extends map . entry < string , string > > string formencode ( collection < t > parameters ) throws ioexception { bytearrayoutputstream b = new bytearrayoutputstream ( ) ; formencode ( parameters , b ) ; return new string ( b . tobytearray ( ) ) ; }	construct a x - www - form - urlencoded document containing the given sequence of name / value pairs.
public void test_singleresourcelocking_serialized_lowconcurrency2 ( ) throws exception { properties properties = new properties ( ) ; properties . setproperty ( testoptions . nthreads , _str ) ; properties . setproperty ( testoptions . ntasks , _str ) ; properties . setproperty ( testoptions . nresources , _str ) ; properties . setproperty ( testoptions . min_locks , _str ) ; properties . setproperty ( testoptions . max_locks , _str ) ; properties . setproperty ( testoptions . predeclare_locks , _str ) ; properties . setproperty ( testoptions . sort_lock_requests , _str ) ; docomparisontest ( properties ) ; }	test where each operation locks only a single resource and there is only one resource to be locked so that all operations must be serialized .
public void runnextpendingcommand ( ) { runnable runnable = deltaqueue . pop ( ) ; runnable . run ( ) ; }	runs the next command scheduled to be executed immediately .
public void stop ( int timeout ) throws interruptedexception { if ( ! isclosed . compareandset ( _bool , _bool ) ) { return ; } list < websocket > socketstoclose = null ; synchronized ( connections ) { socketstoclose = new arraylist < websocket > ( connections ) ; } for ( websocket ws : socketstoclose ) { ws . close ( closeframe . going_away ) ; } synchronized ( this ) { if ( selectorthread != null && selectorthread != thread . currentthread ( ) ) { selector . wakeup ( ) ; selectorthread . interrupt ( ) ; selectorthread . join ( timeout ) ; } } }	closes all connected clients sockets , then closes the underlying serversocketchannel , effectively killing the server socket selectorthread , freeing the port the server was bound to and stops all internal workerthreads.
private static document loaddocument ( resource xmlfile ) throws saxexception , ioexception { domparser parser = new domparser ( ) ; inputstream is = null ; try { is = ioutil . tobufferedinputstream ( xmlfile . getinputstream ( ) ) ; inputsource source = new inputsource ( is ) ; parser . parse ( source ) ; } finally { ioutil . closeel ( is ) ; } return parser . getdocument ( ) ; }	load xml document from xml file.
public void test_dividebigdecimalroundingmodedown ( ) { string a = _str ; string b = _str ; roundingmode rm = roundingmode . down ; string c = _str ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) ) ; bigdecimal result = anumber . divide ( bnumber , rm ) ; assertequals ( _str , c , result . tostring ( ) ) ; }	java . math . bigdecimal # divide ( java . math . bigdecimal , java . math . roundingmode ) divide ( bigdecimal , roundingmode ).
public void removeannotation ( int index ) { mannotations . remove ( index ) ; mstringxy . removebyindex ( index ) ; }	remove an string at index.
public string replace ( char oldchar , char newchar ) { char [ ] buffer = value ; int _offset = offset ; int _count = count ; int idx = _offset ; int last = _offset + _count ; boolean copied = _bool ; while ( idx < last ) { if ( buffer [ idx ] == oldchar ) { if ( ! copied ) { char [ ] newbuffer = new char [ _count ] ; system . arraycopy ( buffer , _offset , newbuffer , _num , _count ) ; buffer = newbuffer ; idx -= _offset ; last -= _offset ; copied = _bool ; } buffer [ idx ] = newchar ; } idx ++ ; } return copied ? new string ( _num , count , buffer ) : this ; }	copies this string replacing occurrences of the specified character with another character .
public static void touch ( file file ) throws ioexception { if ( ! file . exists ( ) ) { outputstream out = openoutputstream ( file ) ; ioutils . closequietly ( out ) ; } boolean success = file . setlastmodified ( system . currenttimemillis ( ) ) ; if ( ! success ) { throw new ioexception ( _str + file ) ; } }	implements the same behaviour as the " touch " utility on unix.
private < type extends message > rpccallback < type > wrapscallback ( mockcallback < ? > callback ) { easymock . reportmatcher ( new wrapscallback ( callback ) ) ; return null ; }	wrapscallback ( ) is an easymock argument predicate.
public boolean shouldselectcell ( eventobject e ) { log . finest ( m_mfield . getcolumnname ( ) ) ; return _bool ; }	the editing cell should be selected or not.
public void testcase18 ( ) { byte abytes [ ] = { _num } ; byte bbytes [ ] = { _num } ; byte rbytes [ ] = { _num } ; int asign = _num ; int bsign = _num ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . add ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	add zero to zero.
@ nonnull public buginstance addclass ( classnode classnode ) { string dottedclassname = classname . todottedclassname ( classnode . name ) ; classannotation classannotation = new classannotation ( dottedclassname ) ; add ( classannotation ) ; return this ; }	add a class annotation for the classnode .
public static void tryformatsatisfiability ( string format ) throws illegalformatexception { messageformat . format ( format , ( object [ ] ) null ) ; }	throws an exception if the format is not syntactically valid .
public static int parseuppermap ( string s ) throws numberformatexception { int uppercase = map_undefined ; int length = s . length ( ) ; if ( length >= _num && length <= _num ) { uppercase = integer . parseint ( s , _num ) ; } else if ( s . length ( ) != _num ) { throw new numberformatexception ( ) ; } return uppercase ; }	parse the uppercase mapping attribute for a unicode character.
@ override public void run ( ) { while ( ! isinterrupted ( ) ) { try { reference ref = _queue . remove ( ) ; _entryinfos . remove ( ref ) ; } catch ( interruptedexception e ) { interrupt ( ) ; break ; } } }	block on the queue until an entry is been cleaned by the gc.
private file createzipfile ( int entrycount , int entrysize ) throws ioexception { file result = createtemporaryzipfile ( ) ; byte [ ] writebuffer = new byte [ _num ] ; random random = new random ( ) ; zipoutputstream out = new zipoutputstream ( new bufferedoutputstream ( new fileoutputstream ( result ) ) ) ; for ( int entry = _num ; entry < entrycount ; ++ entry ) { zipentry ze = new zipentry ( integer . tohexstring ( entry ) ) ; out . putnextentry ( ze ) ; for ( int i = _num ; i < entrysize ; i += writebuffer . length ) { random . nextbytes ( writebuffer ) ; int bytecount = math . min ( writebuffer . length , entrysize - i ) ; out . write ( writebuffer , _num , bytecount ) ; } out . closeentry ( ) ; } out . close ( ) ; return result ; }	compresses the given number of files , each of the given size , into a.
private boolean isvalidplaylistname ( string newname ) { playlist blankplaylist = new playlist ( newname , _bool ) ; return ! newname . isempty ( ) && ! musiclibrary . containsplaylist ( blankplaylist ) ; }	ensures that a string for a playlist is valid , checking if it is empty , or another playlist has the same name .
public string importxml ( string filename , properties ctx , string trxname ) throws exception { log . info ( _str + filename ) ; file in = new file ( filename ) ; if ( ! in . exists ( ) ) { string msg = _str + filename ; log . info ( _str + msg ) ; return msg ; } try { log . info ( _str ) ; system . setproperty ( _str , _str ) ; packinhandler handler = new packinhandler ( ) ; handler . set_trxname ( trxname ) ; handler . setctx ( ctx ) ; handler . setprocess ( this ) ; saxparserfactory factory = saxparserfactory . newinstance ( ) ; saxparser parser = factory . newsaxparser ( ) ; string msg = _str ; log . info ( msg ) ; parser . parse ( in , handler ) ; msg = _str ; log . info ( msg ) ; return _str ; } catch ( exception e ) { log . log ( level . severe , _str , e ) ; throw e ; } }	uses packinhandler to update ad .
public synchronized void logaddorremoverow ( session session , int tableid , row row , boolean add ) { if ( logmode != log_mode_off ) { if ( ! recoveryrunning ) { log . logaddorremoverow ( session , tableid , row , add ) ; } } }	a record is added to a table , or removed from a table .
public org . smpte_ra . schemas . st2067_2_2016 . digestmethodtype builddefaultdigestmethodtype ( ) { org . smpte_ra . schemas . st2067_2_2016 . digestmethodtype digestmethodtype = new org . smpte_ra . schemas . st2067_2_2016 . digestmethodtype ( ) ; digestmethodtype . setalgorithm ( compositionplaylistbuilder_2016 . defaulthashalgorithm ) ; return digestmethodtype ; }	a method to construct a default digest method type with a default hashalgorithm.
public static < v extends sampledvertex > set < v > createsampledpartition ( collection < v > vertices ) { set < v > partition = new hashset < v > ( ) ; for ( v vertex : vertices ) { if ( vertex . issampled ( ) ) partition . add ( vertex ) ; } return partition ; }	creates a subset of sampled vertices .
public gremlintransactionmanager ( gremlingraphfactory graphfactory ) { super ( ) ; this . graphfactory = graphfactory ; }	instantiates a new gremlintransactionmanager with the given gremlingraphfactory .
public void shiftbeans ( beaninstance toshiftto , boolean save ) { if ( save ) { m_originalcoords = new vector < point > ( ) ; } int targetx = toshiftto . getx ( ) ; int targety = toshiftto . gety ( ) ; for ( int i = _num ; i < m_subflow . size ( ) ; i ++ ) { beaninstance temp = ( beaninstance ) m_subflow . elementat ( i ) ; if ( save ) { point p = new point ( temp . getx ( ) - targetx , temp . gety ( ) - targety ) ; m_originalcoords . add ( p ) ; } temp . setx ( targetx ) ; temp . sety ( targety ) ; } }	move coords of all inputs and outputs of this meta bean to the coords of the supplied beaninstance.
@ override protected final list < latlong > doinbackground ( final object ... args ) { list < latlong > points = new arraylist < > ( ) ; datahelper dbhelper = new datahelper ( mcontext ) ; final arraylist < positionrecord > positions = dbhelper . loadpositions ( ( integer ) args [ session_id ] , ( double ) args [ min_lat_col ] , ( double ) args [ max_lat_col ] , ( double ) args [ min_lon_col ] , ( double ) args [ max_lon_col ] ) ; for ( positionrecord position : positions ) { points . add ( new latlong ( position . getlatitude ( ) , position . getlongitude ( ) ) ) ; } return points ; }	queries reference database for all wifis in specified range around map centre .
public void make ( ) throws exception { for ( int i = _num ; i < _makelist . size ( ) ; i ++ ) { make make = _makelist . get ( i ) ; make . make ( ) ; } }	returns true if the underlying dependencies have changed .
@ override void deletedtext ( characterdataimpl node , int offset , int count ) { if ( ranges != null ) { notifyrangesdeletedtext ( node , offset , count ) ; } }	a method to be called when some text was deleted from a text node , so that live objects can be notified .
private applicationenvironment ( ) { try { if ( system . getproperty ( bootstrapproperties . is_uberjar ) != null ) { this . mode = mode . uberjar ; if ( ! loadwildflyswarmapplicationmanifestfromclasspath ( ) ) { loadwildflyswarmapplicationmanifestfromtccl ( ) ; } } else { this . mode = mode . classpath ; loadfractionmanifestsfromclasspath ( ) ; } } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }	do not construct directly .
public producerworker ( string topic , string message ) { this . _topic = topic ; this . _message = message ; }	creates a new producer object .
private void tabcreatedinforeground ( int id , int sourceid , boolean newisincognito , float originx , float originy ) { layouttab newlayouttab = createlayouttab ( id , newisincognito , no_close_button , no_title ) ; if ( mlayouttabs == null || mlayouttabs . length == _num ) { mlayouttabs = new layouttab [ ] { newlayouttab } ; } else { mlayouttabs = new layouttab [ ] { mlayouttabs [ _num ] , newlayouttab } ; } updatecachevisibleids ( new linkedlist < integer > ( arrays . aslist ( id , sourceid ) ) ) ; newlayouttab . setborderalpha ( _num ) ; newlayouttab . setstatictoviewblend ( _num ) ; forceanimationtofinish ( ) ; interpolator interpolator = bakedbezierinterpolator . transform_curve ; addtoanimation ( newlayouttab , layouttab . property . scale , _num , _num , foreground_animation_duration , _num , _bool , interpolator ) ; addtoanimation ( newlayouttab , layouttab . property . alpha , _num , _num , foreground_animation_duration , _num , _bool , interpolator ) ; addtoanimation ( newlayouttab , layouttab . property . x , originx , _num , foreground_animation_duration , _num , _bool , interpolator ) ; addtoanimation ( newlayouttab , layouttab . property . y , originy , _num , foreground_animation_duration , _num , _bool , interpolator ) ; mtabmodelselector . selectmodel ( newisincognito ) ; starthiding ( id , _bool ) ; }	animate opening a tab in the foreground .
private static boolean functionsareallowed ( boolean isaddallfunction , boolean isputallfunction , class < ? > classd , class < ? > classs ) { if ( isaddallfunction ) return collectionisassignablefrom ( classd ) && collectionisassignablefrom ( classs ) ; if ( isputallfunction ) return mapisassignablefrom ( classd ) && mapisassignablefrom ( classs ) ; return isassignablefrom ( classd , classs ) ; }	returns true if the function to check is allowed .
private void loadorgaccessuser ( arraylist < orgaccess > list ) { preparedstatement pstmt = null ; resultset rs = null ; string sql = _str + _str ; try { pstmt = db . preparestatement ( sql , get_trxname ( ) ) ; pstmt . setint ( _num , getad_user_id ( ) ) ; rs = pstmt . executequery ( ) ; while ( rs . next ( ) ) { muserorgaccess oa = new muserorgaccess ( getctx ( ) , rs , get_trxname ( ) ) ; loadorgaccessadd ( list , new orgaccess ( oa . getad_client_id ( ) , oa . getad_org_id ( ) , oa . isreadonly ( ) ) ) ; } } catch ( exception e ) { log . log ( level . severe , sql , e ) ; } finally { db . close ( rs , pstmt ) ; } }	load org access user.
public void close ( ) { synchronized ( mdiskcachelock ) { if ( mdisklrucache != null ) { try { if ( ! mdisklrucache . isclosed ( ) ) { mdisklrucache . close ( ) ; } } catch ( throwable e ) { logutils . e ( e . getmessage ( ) , e ) ; } mdisklrucache = null ; } } }	closes the disk cache associated with this imagecache object.
private map < uri , integer > createvolumemapforexportmask ( exportmask exportmask ) { map < uri , integer > map = new hashmap < > ( ) ; for ( uri uri : exportmaskutils . getvolumeuris ( exportmask ) ) { map . put ( uri , exportgroup . lun_unassigned ) ; } return map ; }	using the exportmask object , create a volume uri to hlu map . for scaleio , there isn ' t any hlu required.
@ override public void close ( ) throws ioexception { socketchannel s = _channel ; _channel = null ; sslsocket sslsocket = _sslsocket ; _sslsocket = null ; if ( sslsocket != null ) { try { sslsocket . close ( ) ; } catch ( exception e ) { } } if ( s != null ) { try { s . close ( ) ; } catch ( exception e ) { } } }	closes the underlying socket .
public static vector3d max ( vector3d a , vector3d b ) { return new vector3d ( fastmath . max ( a . getx ( ) , b . getx ( ) ) , fastmath . max ( a . gety ( ) , b . gety ( ) ) , fastmath . max ( a . getz ( ) , b . getz ( ) ) ) ; }	calculates maximum of each coordinate .
public static void waitforprocessoutput ( process self , outputstream output , outputstream error ) { thread tout = consumeprocessoutputstream ( self , output ) ; thread terr = consumeprocesserrorstream ( self , error ) ; try { tout . join ( ) ; } catch ( interruptedexception ignore ) { } try { terr . join ( ) ; } catch ( interruptedexception ignore ) { } try { self . waitfor ( ) ; } catch ( interruptedexception ignore ) { } closestreams ( self ) ; }	gets the output and error streams from a process and reads them to keep the process from blocking due to a full output buffer.
public commandline add ( string ... args ) { if ( args != null && args . length > _num ) { collections . addall ( line , args ) ; } return this ; }	adds list of arguments in command line .
@ override final node < v > find ( int h , long k ) { for ( node < v > e = first ; e != null ; ) { int s ; if ( ( ( s = lockstate ) & ( waiter | writer ) ) != _num ) { if ( ( e . key == k ) ) { return e ; } e = e . next ; } else if ( u . compareandswapint ( this , lockstate , s , s + reader ) ) { treenode < v > r ; treenode < v > p ; try { p = ( ( r = root ) == null ? null : r . findtreenode ( h , k ) ) ; } finally { thread w ; if ( getandaddint ( this , lockstate , - reader ) == ( reader | waiter ) && ( w = waiter ) != null ) { locksupport . unpark ( w ) ; } } return p ; } } return null ; }	returns matching node or null if none.
@ override public axisstate draw ( graphics2d g2 , double cursor , rectangle2d plotarea , rectangle2d dataarea , rectangleedge edge , plotrenderinginfo plotstate ) { axisstate axisstate = new axisstate ( cursor ) ; if ( isaxislinevisible ( ) ) { drawaxisline ( g2 , cursor , dataarea , edge ) ; } if ( istickmarksvisible ( ) ) { drawtickmarks ( g2 , axisstate , dataarea , edge ) ; } if ( isticklabelsvisible ( ) ) { for ( int band = _num ; band < this . labelinfo . length ; band ++ ) { axisstate = drawticklabels ( band , g2 , axisstate , dataarea , edge ) ; } } if ( getattributedlabel ( ) != null ) { axisstate = drawattributedlabel ( getattributedlabel ( ) , g2 , plotarea , dataarea , edge , axisstate ) ; } else { axisstate = drawlabel ( getlabel ( ) , g2 , plotarea , dataarea , edge , axisstate ) ; } return axisstate ; }	draws the axis on a java 2d graphics device ( such as the screen or a printer ) .
private arraylist < urlcrawldatum > readcontents ( path fetchlist ) throws ioexception { sequencefile . reader reader = new sequencefile . reader ( fs , fetchlist , conf ) ; arraylist < urlcrawldatum > l = new arraylist < urlcrawldatum > ( ) ; read : do { text key = new text ( ) ; crawldatum value = new crawldatum ( ) ; if ( ! reader . next ( key , value ) ) { break read ; } l . add ( new urlcrawldatum ( key , value ) ) ; } while ( _bool ) ; reader . close ( ) ; return l ; }	read contents of fetchlist .
public static color createrandomcolour ( ) { float r = rand . nextfloat ( ) ; float g = rand . nextfloat ( ) ; float b = rand . nextfloat ( ) ; color randomcolor = new color ( r , g , b ) ; return randomcolor ; }	creates a random colour .
private static pair < diagnostickind , boolean > parsecategorystring ( string category ) { final string fixable = _str ; final boolean isfixable = category . startswith ( fixable ) ; if ( isfixable ) { category = category . substring ( fixable . length ( ) ) ; } diagnostickind categoryenum = diagnostickind . fromparsestring ( category ) ; return pair . of ( categoryenum , isfixable ) ; }	given a category string that may be prepended with " fixable - " , return the category enum that corresponds with the category and whether or not it is a isfixable error.
public void legacyprocess ( class clazz , method m , methodappearancedecision decision ) { if ( m . getdeclaringclass ( ) != object . class && m . getreturntype ( ) != void . class && m . getparametertypes ( ) . length == _num ) { string mname = m . getname ( ) ; if ( ! lookslikepropertyreadmethod ( mname ) ) { decision . setexposemethodas ( null ) ; try { decision . setexposeasproperty ( new propertydescriptor ( mname , clazz , mname , null ) ) ; } catch ( introspectionexception e ) { throw new runtimeexception ( e ) ; } } } }	this only exists as the tests need to call this through the deprecated method too .
public sptkpitchreaderwriter ( string lf0sptkfile , float windowsizeinseconds , float skipsizeinseconds , int samplingrate ) { contour = null ; header = new pitchfileheader ( ) ; header . windowsizeinseconds = windowsizeinseconds ; header . skipsizeinseconds = skipsizeinseconds ; header . fs = samplingrate ; try { contour = readsptkf0data ( lf0sptkfile ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }	read a sptk lf0 file with external settings.
public void abort ( ) { cleanup ( ) ; if ( mfuture != null ) { mfuture . cancel ( _bool ) ; mfuture = null ; } if ( mexecutorservice != null ) { mexecutorservice . shutdownnow ( ) ; mexecutorservice = null ; } mlistener = null ; }	aborts the call . this method will cleanup the resources and removes the listener , if one was registered ,.
public void addcspstatelistener ( cspstatelistener listener ) { listeners . add ( listener ) ; }	adds a csp state listener to the solution strategy .
public static void printwrappedtext ( final printstream stream , final string message ) { if ( stream != null && message != null && ! message . isempty ( ) ) { stream . println ( wraptext ( message , max_line_width ) ) ; } }	prints the provided string on the provided stream .
public void removeatrange ( int index , int size ) { final int end = math . min ( msize , index + size ) ; for ( int i = index ; i < end ; i ++ ) { removeat ( i ) ; } }	remove a range of mappings as a batch .
public static void assertnullability ( resultset rs , boolean [ ] nullability ) throws sqlexception { resultsetmetadata rsmd = rs . getmetadata ( ) ; int actualcols = rsmd . getcolumncount ( ) ; assertequals ( _str , nullability . length , rsmd . getcolumncount ( ) ) ; for ( int i = _num ; i < actualcols ; i ++ ) { int expected = nullability [ i ] ? resultsetmetadata . columnnullable : resultsetmetadata . columnnonulls ; assertequals ( _str + ( i + _num ) , expected , rsmd . isnullable ( i + _num ) ) ; } }	check the nullability of the column definitions for the resultset matches the expected values .
private synchronized rect [ ] computeboundingboxes ( ) { if ( ! boundingboxes . ispresent ( ) ) { rect [ ] bb = new rect [ ( int ) contours . size ( ) ] ; for ( int i = _num ; i < contours . size ( ) ; i ++ ) { bb [ i ] = boundingrect ( contours . get ( i ) ) ; } boundingboxes = optional . of ( bb ) ; } return boundingboxes . get ( ) ; }	compute the bounding boxes of all contours ( if they haven ' t already been computed ).
public void addtimeline ( final jsonobject timeline ) { timelinechannel . notifytimeline ( timeline ) ; timelines . addfirst ( timeline ) ; final int maxcnt = symphonys . getint ( _str ) ; if ( timelines . size ( ) > maxcnt ) { timelines . remove ( maxcnt ) ; } }	adds the specified timeline .
private boolean loadlobdata ( ) { if ( isstoreattachmentsonfilesystem ) { return loadlobdatafromfilesystem ( ) ; } return loadlobdatafromdb ( ) ; }	load data into local m_data.
protected void paintcomponent ( graphics g ) { backgroundpainter . paint ( g , getvisiblerect ( ) ) ; textui ui = getui ( ) ; if ( ui != null ) { graphics scratchgraphics = g . create ( ) ; try { ui . update ( scratchgraphics , this ) ; } finally { scratchgraphics . dispose ( ) ; } } }	paints the text area .
public static < t > list < t > copytoarraylistwithextracapacity ( t [ ] elements , int extracapacity ) { list < t > aslist ; if ( elements != null ) { aslist = new arraylist < t > ( elements . length + extracapacity ) ; aslist . addall ( arrays . aslist ( elements ) ) ; } else { aslist = new arraylist < t > ( extracapacity ) ; } return aslist ; }	produces an arraylist for an array of elements where the list is pre - sized with extra capacity.
private boolean sendeventtolisteners ( clusterevent event ) { boolean success = _bool ; for ( string listenerid : collections . unmodifiableset ( listeners . keyset ( ) ) ) { logger . debug ( _str , listenerid , event . gettype ( ) , instanceid ) ; clustereventlistener listener = listeners . get ( listenerid ) ; if ( listener != null && ! listener . handleevent ( event ) ) { success = _bool ; } } return success ; }	sends a clusterevent to all registered listeners.
@ requestmapping ( method = requestmethod . put , value = _str , consumes = { mediatype . application_json_value } , produces = { mediatype . application_json_value } ) @ apioperation ( value = _str , notes = _str + _str + _str , response = void . class ) @ apiresponses ( { @ apiresponse ( code = _num , message = _str ) , @ apiresponse ( code = _num , message = _str ) , @ apiresponse ( code = _num , message = _str ) , @ apiresponse ( code = _num , message = _str ) , @ apiresponse ( code = _num , message = _str ) , @ apiresponse ( code = _num , message = _str ) , @ apiresponse ( code = _num , message = _str ) } ) @ preauthorize ( _str ) public responseentity < ? > update ( @ pathvariable ( _str ) string region , @ pathvariable ( _str ) final string [ ] keys , @ requestparam ( value = _str , defaultvalue = _str ) final string opvalue , @ requestbody final string json ) { logger . debug ( _str , region ) ; region = decode ( region ) ; if ( keys . length > _num ) { return updatemultiplekeys ( region , keys , json ) ; } else { return updatesinglekey ( region , keys [ _num ] , json , opvalue ) ; } }	update data for a key or set of keys.
public void load ( x509extension extensions ) { set < string > critexts = extensions . getcriticalextensionoids ( ) ; set < string > noncritexts = extensions . getnoncriticalextensionoids ( ) ; list < x509ext > sortedexts = new arraylist < x509ext > ( ) ; for ( iterator < string > itr = critexts . iterator ( ) ; itr . hasnext ( ) ; ) { string extoid = itr . next ( ) ; byte [ ] value = extensions . getextensionvalue ( extoid ) ; x509ext ext = new x509ext ( new asn1objectidentifier ( extoid ) , value , _bool ) ; sortedexts . add ( ext ) ; } for ( iterator < string > itr = noncritexts . iterator ( ) ; itr . hasnext ( ) ; ) { string extoid = itr . next ( ) ; byte [ ] value = extensions . getextensionvalue ( extoid ) ; x509ext ext = new x509ext ( new asn1objectidentifier ( extoid ) , value , _bool ) ; sortedexts . add ( ext ) ; } collections . sort ( sortedexts , new extensionnamecomparator ( ) ) ; data = new object [ sortedexts . size ( ) ] [ _num ] ; int i = _num ; for ( iterator < x509ext > itrsortedexts = sortedexts . iterator ( ) ; itrsortedexts . hasnext ( ) ; ) { x509ext ext = itrsortedexts . next ( ) ; loadrow ( ext , i ) ; i ++ ; } firetabledatachanged ( ) ; }	load the extensionstablemodel with x.
public builder deleteaddresses ( ) { deletefields . add ( _str ) ; return this ; }	deletes all existing addresses of the a existing user.
public query limit ( int limit ) { return limit ( limit < _num ? no_limit : field . < integer > field ( integer . tostring ( limit ) ) ) ; }	set the limit of this statement.
public static boolean fileexists ( string fname ) { boolean result = _bool ; file file = new file ( fname ) ; if ( file != null ) { result = file . exists ( ) && file . isfile ( ) ; } return result ; }	test if a file exists or not.
public long skip ( long n ) { if ( position + n <= document . getlength ( ) ) { position += n ; return n ; } long temp = position ; position = document . getlength ( ) ; return document . getlength ( ) - temp ; }	skips characters . this will not ' skip ' past the end of the document .
private static void _init ( ) { addmethod ( _str , new com . earth2me . essentials . register . payment . methods . ico6 ( ) ) ; addmethod ( _str , new com . earth2me . essentials . register . payment . methods . ico5 ( ) ) ; addmethod ( _str , new com . earth2me . essentials . register . payment . methods . bose7 ( ) ) ; addmethod ( _str , new com . earth2me . essentials . register . payment . methods . mcur ( ) ) ; dependencies . add ( _str ) ; addmethod ( _str , new com . earth2me . essentials . register . payment . methods . vaulteco ( ) ) ; }	implement all methods along with their respective name & class .
public static string convertfilename ( string name , int maxbytes ) { try { return convertfilename ( name , maxbytes , charset . defaultcharset ( ) ) ; } catch ( charactercodingexception cce ) { try { return convertfilename ( name , maxbytes , charset . forname ( _str ) ) ; } catch ( charactercodingexception e ) { throw new runtimeexception ( _str + name , e ) ; } } }	cleans up the filename from illegal characters and truncates it to the length of bytes specified .
public static void copy ( url url , file file ) throws ioexception { inputstream is = url . openstream ( ) ; try { outputstream os = new fileoutputstream ( file ) ; try { byte [ ] buffer = new byte [ _num ] ; int read ; while ( ( read = is . read ( buffer ) ) > _num ) { os . write ( buffer , _num , read ) ; } } finally { os . close ( ) ; } } finally { is . close ( ) ; } }	copy a url to a file .
public void updatedeltas ( int deltax , int deltay ) { if ( mleftborderactive ) { mdeltax = math . max ( - mbaselinex , deltax ) ; mdeltax = math . min ( mbaselinewidth - _num * mtouchtargetwidth , mdeltax ) ; } else if ( mrightborderactive ) { mdeltax = math . min ( mdraglayer . getwidth ( ) - ( mbaselinex + mbaselinewidth ) , deltax ) ; mdeltax = math . max ( - mbaselinewidth + _num * mtouchtargetwidth , mdeltax ) ; } if ( mtopborderactive ) { mdeltay = math . max ( - mbaseliney , deltay ) ; mdeltay = math . min ( mbaselineheight - _num * mtouchtargetwidth , mdeltay ) ; } else if ( mbottomborderactive ) { mdeltay = math . min ( mdraglayer . getheight ( ) - ( mbaseliney + mbaselineheight ) , deltay ) ; mdeltay = math . max ( - mbaselineheight + _num * mtouchtargetwidth , mdeltay ) ; } }	here we bound the deltas such that the frame cannot be stretched beyond the extents of the celllayout , and such that the frame ' s borders can ' t cross .
public void createauthconfiguration ( string name ) throws amconsoleexception { if ( ( name == null ) || ( name . length ( ) == _num ) ) { throw new amconsoleexception ( getlocalizedstring ( _str ) ) ; } string [ ] params = { currentrealm , name } ; logevent ( _str , params ) ; string errormsg = null ; try { amauthconfigutils . createnamedconfig ( name , _num , new hashmap ( ) , currentrealm , getuserssotoken ( ) ) ; logevent ( _str , params ) ; } catch ( smsexception e ) { errormsg = geterrorstring ( e ) ; string [ ] paramsex = { currentrealm , name , errormsg } ; logevent ( _str , paramsex ) ; debug . warning ( _str , e ) ; } catch ( ssoexception e ) { errormsg = geterrorstring ( e ) ; string [ ] paramsex = { currentrealm , name , errormsg } ; logevent ( _str , paramsex ) ; debug . warning ( _str , e ) ; } catch ( amconfigurationexception e ) { errormsg = geterrorstring ( e ) ; string [ ] paramsex = { currentrealm , name , errormsg } ; logevent ( _str , paramsex ) ; debug . warning ( _str , e ) ; } if ( errormsg != null ) { throw new amconsoleexception ( errormsg ) ; } }	creates a new named authentication configuration object.
public void trim ( string atext , int [ ] aspan ) { int begin = aspan [ _num ] ; int end = aspan [ _num ] - _num ; string data = atext ; while ( ( begin < ( data . length ( ) - _num ) ) && trimchar ( data . charat ( begin ) ) ) { begin ++ ; } while ( ( end > _num ) && trimchar ( data . charat ( end ) ) ) { end -- ; } end ++ ; aspan [ _num ] = begin ; aspan [ _num ] = end ; }	remove trailing or leading whitespace from the annotation .
public string classifiertiptext ( ) { return _str ; }	returns the tip text for this property.
public writableraster createwritablechild ( int x , int y , int width , int height , int x0 , int y0 , int [ ] bandlist ) { if ( x < this . minx ) { throw new rasterformatexception ( _str ) ; } if ( y < this . miny ) { throw new rasterformatexception ( _str ) ; } if ( ( x + width < x ) || ( x + width > this . minx + this . width ) ) { throw new rasterformatexception ( _str ) ; } if ( ( y + height < y ) || ( y + height > this . miny + this . height ) ) { throw new rasterformatexception ( _str ) ; } samplemodel sm ; if ( bandlist != null ) { sm = samplemodel . createsubsetsamplemodel ( bandlist ) ; } else { sm = samplemodel ; } int deltax = x0 - x ; int deltay = y0 - y ; return new bytepackedraster ( sm , databuffer , new rectangle ( x0 , y0 , width , height ) , new point ( samplemodeltranslatex + deltax , samplemodeltranslatey + deltay ) , this ) ; }	creates a writable subraster given a region of the raster.
private void sendbuffer ( ) throws ioexception { buf . flip ( ) ; send ( buf , buf . remaining ( ) ) ; buf = null ; }	send all local - buffered data to server .
public void callevent ( event event ) { if ( event . isasynchronous ( ) ) { if ( thread . holdslock ( this ) ) { throw new illegalstateexception ( event . geteventname ( ) + _str ) ; } if ( server . isprimarythread ( ) ) { throw new illegalstateexception ( event . geteventname ( ) + _str ) ; } fireevent ( event ) ; } else { synchronized ( this ) { fireevent ( event ) ; } } }	calls an event with the given details.
@ nullable private static psifile findfiletoopen ( @ notnull list < psifile > files ) { psifile bestfile = null ; folderconfiguration bestconfig = null ; for ( psifile file : files ) { psidirectory qualifieddirectory = file . getparent ( ) ; assert qualifieddirectory != null : _str ; folderconfiguration config = folderconfiguration . getconfigforfolder ( qualifieddirectory . getname ( ) ) ; if ( bestconfig == null || config == null || config . compareto ( bestconfig ) < _num ) { bestconfig = config ; bestfile = file ; } } return bestfile ; }	returns the best configuration of a particular resource given a set of multiple configurations of the same resource .
protected boolean areequal ( string string1 , string string2 , boolean casematters ) { return ( casematters && string1 . equals ( string2 ) ) || ( ! casematters && string1 . equalsignorecase ( string2 ) ) ; }	compares the two strings .
public static commandresult execcommand ( list < string > commands , boolean isroot ) { return execcommand ( commands == null ? null : commands . toarray ( new string [ ] { } ) , isroot , _bool ) ; }	execute shell commands , default return result msg.
protected void populateblob ( int id , byte [ ] basecontent , int requiredsize ) throws sqlexception { connection con = getconnectionviadrivermanager ( ) ; callablestatement cstmt = null ; try { cstmt = con . preparecall ( execute_fill_binary_blob ) ; cstmt . setint ( _num , id ) ; cstmt . setbytes ( _num , basecontent ) ; cstmt . setint ( _num , requiredsize ) ; cstmt . execute ( ) ; } finally { closequietly ( cstmt ) ; closequietly ( con ) ; } }	populates a ( segmented ) blob using the fill_binary_blob stored procedure.
private void removeobservedfile ( string localpath ) { file file = new file ( localpath ) ; string parentpath = file . getparent ( ) ; folderobserver observer = mfolderobserversmap . get ( parentpath ) ; if ( observer != null ) { observer . stopwatching ( file . getname ( ) ) ; if ( observer . isempty ( ) ) { mfolderobserversmap . remove ( parentpath ) ; log_oc . d ( tag , _str + parentpath + _str ) ; } } else { log_oc . d ( tag , _str + localpath ) ; } }	unregisters a local file from being observed for changes .
public void makeimmutable ( ) { if ( mutable ) { if ( results != null ) { int length = results . size ( ) ; for ( int i = _num ; i < length ; i ++ ) { result result = ( result ) results . get ( i ) ; result . makeimmutable ( ) ; } results = collections . unmodifiablelist ( results ) ; } mutable = _bool ; } }	makes the object immutable.
public statement isnull ( ) { statement . append ( _str ) ; return this ; }	appending the is null operator clause .
public void clear ( ) { processqueue ( ) ; hash . clear ( ) ; }	remove all mappings from this cache .
private void updatefavoritestation ( ) { string showstring = null ; if ( fmradiostation . isfavoritestation ( mcontext , mcurrentstation ) ) { string stationname = fmradiostation . getstationname ( mcontext , mcurrentstation , fmradiostation . station_type_favorite ) ; fmradiostation . updatestationtodb ( mcontext , stationname , fmradiostation . station_type_searched , mcurrentstation ) ; mbuttonaddtofavorite . setimageresource ( r . drawable . btn_fm_favorite_off_selector ) ; mtextstationname . settext ( _str ) ; showstring = mprojectstringext . getprojectstring ( mcontext , r . string . toast_channel_deleted , r . string . toast_channel_deleted1 ) ; } else { string stationname = fmradiostation . getstationname ( mcontext , mcurrentstation , fmradiostation . station_type_searched ) ; if ( fmradiostation . isstationexist ( mcontext , mcurrentstation , fmradiostation . station_type_searched ) ) { fmradiostation . updatestationtodb ( mcontext , stationname , fmradiostation . station_type_favorite , mcurrentstation ) ; } else { fmradiostation . insertstationtodb ( mcontext , stationname , mcurrentstation , fmradiostation . station_type_favorite ) ; } mbuttonaddtofavorite . setimageresource ( r . drawable . btn_fm_favorite_on_selector ) ; mtextstationname . settext ( stationname ) ; showstring = mprojectstringext . getprojectstring ( mcontext , r . string . toast_channel_added , r . string . toast_channel_added1 ) ; } showtoast ( showstring ) ; }	update the favorite ui state.
public int addallabsent ( collection < ? extends e > c ) { object [ ] cs = c . toarray ( ) ; if ( cs . length == _num ) return _num ; final reentrantlock lock = this . lock ; lock . lock ( ) ; try { object [ ] elements = getarray ( ) ; int len = elements . length ; int added = _num ; for ( int i = _num ; i < cs . length ; ++ i ) { object e = cs [ i ] ; if ( indexof ( e , elements , _num , len ) < _num && indexof ( e , cs , _num , added ) < _num ) cs [ added ++ ] = e ; } if ( added > _num ) { object [ ] newelements = arrays . copyof ( elements , len + added ) ; system . arraycopy ( cs , _num , newelements , len , added ) ; setarray ( newelements ) ; } return added ; } finally { lock . unlock ( ) ; } }	appends all of the elements in the specified collection that are not already contained in this list , to the end of this list , in the order that they are returned by the specified collection ' s iterator .
public analyzer saveanalysis ( file file ) throws ioexception { printstream ps = null ; try { ps = new printstream ( new bufferedoutputstream ( new fileoutputstream ( file ) ) ) ; printanalysis ( ps ) ; } finally { if ( ps != null ) { ps . close ( ) ; } } return this ; }	saves the analysis of all data recorded in this analyzer to the specified file .
public iterator < capability > dependencies ( ) { return m_dependencies . iterator ( ) ; }	returns an iterator over the stored dependencies.
public final static int parseint ( string str ) { char c = str . charat ( _num ) ; int length = str . length ( ) ; boolean negative = ( c == _str ) ; int offset = _num ; if ( negative ) { if ( length == _num || length > _num ) { return integer . parseint ( str ) ; } c = str . charat ( offset ++ ) ; } else { if ( length > _num ) { return integer . parseint ( str ) ; } } if ( c > _str || c < _str ) { return integer . parseint ( str ) ; } int num = c - _str ; if ( offset < length ) { c = str . charat ( offset ++ ) ; if ( c > _str || c < _str ) { return integer . parseint ( str ) ; } num = ( num * _num ) + ( c - _str ) ; if ( offset < length ) { c = str . charat ( offset ++ ) ; if ( c > _str || c < _str ) { return integer . parseint ( str ) ; } num = ( num * _num ) + ( c - _str ) ; if ( offset < length ) { do { c = str . charat ( offset ++ ) ; if ( c > _str || c < _str ) { return integer . parseint ( str ) ; } num = ( num * _num ) + ( c - _str ) ; } while ( offset < length ) ; } } } return negative ? - num : num ; }	helper method to ( more ) efficiently parse integer numbers from string values .
public bufferedheader ( final chararraybuffer buffer ) throws parseexception { super ( ) ; if ( buffer == null ) { throw new illegalargumentexception ( _str ) ; } int colon = buffer . indexof ( _str ) ; if ( colon == - _num ) { throw new parseexception ( _str + buffer . tostring ( ) ) ; } string s = buffer . substringtrimmed ( _num , colon ) ; if ( s . length ( ) == _num ) { throw new parseexception ( _str + buffer . tostring ( ) ) ; } this . buffer = buffer ; this . name = s ; this . valuepos = colon + _num ; }	creates a new header from a buffer.
public static string todatestring ( java . util . date date , string format ) { if ( date == null ) return _str ; simpledateformat dateformat = null ; if ( format != null ) { dateformat = new simpledateformat ( format ) ; } else { dateformat = new simpledateformat ( ) ; } calendar calendar = calendar . getinstance ( ) ; calendar . settime ( date ) ; return dateformat . format ( date ) ; }	makes a date string in the given from a date.
@ deprecated public static < t > t executewithbackoff ( abstractgoogleclientrequest < t > client , string error , object ... errorargs ) throws ioexception , interruptedexception { return executewithbackoff ( client , string . format ( error , errorargs ) ) ; }	execute a bq request with exponential backoff and return the result .
private void checkserverresponsecode ( httpurlconnection urlconnection ) throws requestfailureexception { try { if ( urlconnection . getresponsecode ( ) != _num ) { throw new requestfailureexception ( _str + urlconnection . getresponsecode ( ) + _str ) ; } } catch ( ioexception e ) { throw new requestfailureexception ( _str , e ) ; } }	confirms that the omaha server sent back an " ok " code .
public static void addresourcesource ( resourcesource source ) { all_resource_sources . add ( source ) ; }	adds a new resource source.
private void commitchanges ( ) { hopfieldpropspanel . commitchanges ( ) ; inputpanel . commitchanges ( ) ; }	commit all changes made in the dialog to the model .
private boolean connect_to_target ( plapointint p_from_point ) { if ( nearest_target_item != null && target_set != null && ! target_set . contains ( nearest_target_item ) ) { nearest_target_item = null ; } if ( nearest_target_item == null || ! nearest_target_item . shares_net_no ( net_nos ) ) { return _bool ; } boolean route_completed = _bool ; plapointint connection_point = null ; if ( nearest_target_item instanceof brdabit ) { brdabit target = ( brdabit ) nearest_target_item ; connection_point = target . center_get ( ) ; } else if ( nearest_target_item instanceof brdtracep ) { return r_board . connect_to_trace ( p_from_point , ( brdtracep ) nearest_target_item , pen_half_width_arr [ layer_active_no ] , clearance_class ) ; } else if ( nearest_target_item instanceof brdareaconduction ) { connection_point = p_from_point ; } if ( connection_point != null ) { route_completed = itera_connect ( p_from_point , connection_point ) ; } return route_completed ; }	if p_from_point is already on a target item , a connection to the target is made and true returned .
public boolean ongenericmotionevent ( motionevent ev ) { if ( ( ev . getsource ( ) & inputdevice . source_class_pointer ) == inputdevice . source_class_pointer ) { int action = ev . getaction ( ) ; switch ( action & motionevent . action_mask ) { case motionevent . action_scroll : float vscroll = ev . getaxisvalue ( motionevent . axis_vscroll ) ; if ( vscroll > _num ) { if ( mdeckview . ensurefocusedtask ( ) ) { mdeckview . focusnexttask ( _bool , _bool ) ; } } else { if ( mdeckview . ensurefocusedtask ( ) ) { mdeckview . focusnexttask ( _bool , _bool ) ; } } return _bool ; } } return _bool ; }	handles generic motion events.
public boolean addclass ( owlclass targetclass ) { targetclass . addqcrestriction ( this ) ; return qcclasses . add ( targetclass ) ; }	add " onclass c " information , and tell c to point back here .
public void editelement ( final object element , final string columnpropertyname ) { final int columnindex = tableviewerutils . columnpropertynametocolumnindex ( columnpropertyname , _bool , viewer ) ; viewer . editelement ( element , columnindex ) ; }	initiates cell editing on the specified element.
public fp ( eccurve curve , ecfieldelement x , ecfieldelement y ) { this ( curve , x , y , _bool ) ; }	create a point which encodes with point compression .
private static string serializedocumentint ( document doc ) throws transformerexception , ioexception { bytearrayoutputstream s = new bytearrayoutputstream ( ) ; transformerfactory factory = transformerfactory . newinstance ( ) ; transformer transformer = factory . newtransformer ( ) ; transformer . setoutputproperty ( outputkeys . method , _str ) ; transformer . setoutputproperty ( outputkeys . indent , _str ) ; domsource source = new domsource ( doc ) ; streamresult outputtarget = new streamresult ( s ) ; transformer . transform ( source , outputtarget ) ; return s . tostring ( _str ) ; }	serializes a xml document into a string - encoded in utf8 format , with platform line separators .
static double area ( s2point a , s2point b , s2point c ) { final double sa = b . angle ( c ) ; final double sb = c . angle ( a ) ; final double sc = a . angle ( b ) ; final double s = _num * ( sa + sb + sc ) ; if ( s >= _num ) { double s2 = s * s ; double dmin = s - math . max ( sa , math . max ( sb , sc ) ) ; if ( dmin < _num * s * s2 * s2 ) { double area = girardarea ( a , b , c ) ; if ( dmin < s * ( _num * area ) ) { return area ; } } } return _num * math . atan ( math . sqrt ( math . max ( _num , math . tan ( _num * s ) * math . tan ( _num * ( s - sa ) ) * math . tan ( _num * ( s - sb ) ) * math . tan ( _num * ( s - sc ) ) ) ) ) ; }	return the area of triangle abc.
private void serializable ( final isolationlevels level ) throws exception { clear ( store ) ; final valuefactory vf = store . getvaluefactory ( ) ; final iri subj = vf . createiri ( _str ) ; final iri pred = vf . createiri ( _str ) ; repositoryconnection prep = store . getconnection ( ) ; try { prep . begin ( level ) ; prep . add ( subj , pred , vf . createliteral ( _num ) ) ; prep . commit ( ) ; } finally { prep . close ( ) ; } final countdownlatch start = new countdownlatch ( _num ) ; final countdownlatch observed = new countdownlatch ( _num ) ; thread t1 = incrementby ( start , observed , level , vf , subj , pred , _num ) ; thread t2 = incrementby ( start , observed , level , vf , subj , pred , _num ) ; t2 . start ( ) ; t1 . start ( ) ; t2 . join ( ) ; t1 . join ( ) ; assertnotfailed ( ) ; repositoryconnection check = store . getconnection ( ) ; try { check . begin ( level ) ; literal lit = readliteral ( check , subj , pred ) ; int val = lit . intvalue ( ) ; if ( val != _num && val != _num ) { assertequals ( _num , val ) ; } check . commit ( ) ; } finally { check . close ( ) ; } }	two transactions read a value and replace it.
public static array listtoarrayremoveempty ( string list , char delimiter ) { int len = list . length ( ) ; arrayimpl array = new arrayimpl ( ) ; if ( len == _num ) return array ; int last = _num ; for ( int i = _num ; i < len ; i ++ ) { if ( list . charat ( i ) == delimiter ) { if ( last < i ) array . _append ( list . substring ( last , i ) ) ; last = i + _num ; } } if ( last < len ) array . _append ( list . substring ( last ) ) ; return array ; }	casts a list to array object remove empty elements.
public static < t extends object & java . lang . comparable < ? super t > > t min ( collection < ? extends t > collection ) { iterator < ? extends t > it = collection . iterator ( ) ; t min = it . next ( ) ; while ( it . hasnext ( ) ) { t next = it . next ( ) ; if ( min . compareto ( next ) > _num ) { min = next ; } } return min ; }	searches the specified collection for the minimum element .
@ override public serverheartbeat server ( string address , int port , boolean isssl , string clusterid , string displayname , boolean isdynamic ) { objects . requirenonnull ( address ) ; objects . requirenonnull ( clusterid ) ; if ( address . isempty ( ) ) { address = _str ; } clusterheartbeat cluster = createcluster ( clusterid ) ; serverheartbeat server ; if ( isdynamic ) { server = cluster . createdynamicserver ( address , port , isssl ) ; } else { server = cluster . createserver ( address , port , isssl ) ; } if ( displayname != null ) { server . setdisplayname ( displayname ) ; } if ( ! isdynamic ) { cluster . addseedserver ( server ) ; } return server ; }	create an external / configured server.
public void testtostring ( ) { linkedblockingqueue q = populatedqueue ( size ) ; string s = q . tostring ( ) ; for ( int i = _num ; i < size ; ++ i ) { asserttrue ( s . indexof ( string . valueof ( i ) ) >= _num ) ; } }	tostring contains tostrings of elements.
private void findclub ( ) { if ( ce ( ) == null ) { return ; } string title = messages . getstring ( _str ) ; string body = messages . getstring ( _str ) ; if ( ! clientgui . doyesnodialog ( title , body ) ) { return ; } attacks . removeallelements ( ) ; attacks . addelement ( new findclubaction ( cen ) ) ; ready ( ) ; }	the entity spends the rest of its turn finding a club.
public pdfxref ( byte [ ] line ) { if ( line == null ) { id = - _num ; generation = - _num ; } else { id = integer . parseint ( new string ( line , _num , _num ) ) ; generation = integer . parseint ( new string ( line , _num , _num ) ) ; } compressed = _bool ; }	create a new pdfxref , given a sequence of bytes representing the fixed - width cross reference table line.
public static string [ ] makestrings ( collection < inetaddress > addrs ) { string [ ] result = new string [ addrs . size ( ) ] ; int i = _num ; for ( inetaddress addr : addrs ) { result [ i ++ ] = addr . gethostaddress ( ) ; } return result ; }	create a string array of host addresses from a collection of inetaddresses.
public static void showprofile ( activity activity , string pilotid , @ nullable hashmap < string , string > extras ) { if ( ( pilotid == null || pilotid . isempty ( ) ) && airmap . hasvalidauthenticateduser ( ) ) { pilotid = airmap . getuserid ( ) ; } intent intent = new intent ( activity , profileactivity . class ) ; intent . putextra ( profileactivity . arg_pilot_id , pilotid ) ; if ( extras != null ) { intent . putextra ( createflightactivity . key_value_extras , extras ) ; } activity . startactivity ( intent ) ; }	display the authenticated pilot ' s profile.
public smoothmoves ( ) { cyclestart = system . nanotime ( ) / _num ; starttimer ( currentresolution ) ; }	creates a new instance of smoothanimation.
public static void updatepricelists ( properties ctx , productbean productbean , string trxname ) throws operationexception { arraylist < productbean > list = productbean . getproductbeanlist ( ) ; if ( list != null ) { int productid = productbean . getproductid ( ) ; iterator < productbean > iter = list . iterator ( ) ; while ( iter . hasnext ( ) ) { productbean bean = iter . next ( ) ; int pricelistid = bean . getpricelistid ( ) ; bigdecimal stdprice = bean . getstdprice ( ) ; bigdecimal listprice = bean . getlistprice ( ) ; bigdecimal limitprice = bean . getlimitprice ( ) ; mpricelist pricelist = mpricelist . get ( ctx , pricelistid , trxname ) ; if ( pricelist . istaxincluded ( ) ) { stdprice = bean . getstdpriceincl ( ) ; listprice = bean . getlistpriceincl ( ) ; limitprice = bean . getlimitpriceincl ( ) ; } updatepricelists ( ctx , productid , pricelistid , stdprice , listprice , limitprice , trxname ) ; } } }	updates product price . the product and price list are obtained from the product bean . the latest price list version is used .
private string checkdependencies ( moduledescriptor md , hashmap < string , moduledescriptor > modlist ) { logger . debug ( _str + md . getid ( ) ) ; moduleinterface [ ] requires = md . getrequires ( ) ; if ( requires != null ) { for ( moduleinterface req : requires ) { string res = checkonedependency ( md , req , modlist ) ; if ( ! res . isempty ( ) ) { return res ; } } } return _str ; }	check that the dependencies are satisfied .
public void testclearbitpositiveinside1 ( ) { byte abytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = _num ; int number = _num ; byte rbytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . clearbit ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	clearbit ( int n ) inside a positive number.
public void deserializefunnel ( list < object > serializedfunnel ) { set < object > funnelstepaccumulator = new hashset < > ( ) ; for ( object e : serializedfunnel ) { if ( e != null ) { funnelstepaccumulator . add ( e ) ; } else { funnelsteps . add ( new hashset < > ( funnelstepaccumulator ) ) ; funnelstepaccumulator . clear ( ) ; } } }	deserialize funnel steps . have to deserialize the null separated list .
public static string appendparameter ( ctclass type , string descriptor ) { int i = descriptor . indexof ( _str ) ; if ( i < _num ) return descriptor ; else { stringbuffer newdesc = new stringbuffer ( ) ; newdesc . append ( descriptor . substring ( _num , i ) ) ; todescriptor ( newdesc , type ) ; newdesc . append ( descriptor . substring ( i ) ) ; return newdesc . tostring ( ) ; } }	appends a parameter type to the parameter list represented by the given descriptor.
public void addcatchclause ( catchclause clause ) { assertnotnull ( clause ) ; if ( catchclauses == null ) { catchclauses = new arraylist < catchclause > ( ) ; } catchclauses . add ( clause ) ; clause . setparent ( this ) ; }	add a catch - clause to the end of the list , and sets its parent to this node .
public static void streamcontenttobrowser ( httpservletresponse response , byte [ ] bytes , string contenttype , string filename ) throws ioexception { setresponsebrowserproxynocache ( response ) ; response . setcontentlength ( bytes . length ) ; if ( contenttype != null ) { response . setcontenttype ( contenttype ) ; } if ( filename != null ) { response . setheader ( _str , _str + filename + _str ) ; } outputstream out = response . getoutputstream ( ) ; inputstream in = new bytearrayinputstream ( bytes ) ; try { streamcontent ( out , in , bytes . length ) ; } catch ( ioexception e ) { in . close ( ) ; out . close ( ) ; throw e ; } in . close ( ) ; out . flush ( ) ; out . close ( ) ; }	stream an array of bytes to the browser this method will close the servletoutputstream when finished.
public void unlock ( object key ) { string uid = string . valueof ( key ) ; transaction tr = lockeduidhashmap . get ( uid ) ; if ( tr == null ) { return ; } try { tr . commit ( ) ; } catch ( exception e ) { logger . warn ( _str , e ) ; } finally { lockeduidhashmap . remove ( uid ) ; } }	unlocks the given lock on the key.
public list < order > fetchorders ( int startindex , int num ) { int endindex = startindex + num > orders . size ( ) ? orders . size ( ) : startindex + num ; return orders . sublist ( startindex , endindex ) ; }	returns a slice of orders.
public boolean ensureschemaagreement ( ) { long start = system . currenttimemillis ( ) ; map < string , list < string > > schemas = null ; while ( system . currenttimemillis ( ) - start < dbclientcontext . max_schema_wait_ms ) { try { log . info ( _str , dbclientcontext . schema_retry_sleep_millis / _num ) ; thread . sleep ( dbclientcontext . schema_retry_sleep_millis ) ; } catch ( interruptedexception ex ) { log . warn ( _str ) ; } schemas = getschemaversions ( ) ; if ( schemas . size ( ) > _num ) { continue ; } if ( schemas . size ( ) == _num ) { if ( ! schemas . containskey ( storageproxy . unreachable ) ) { return _bool ; } else { continue ; } } if ( schemas . containskey ( storageproxy . unreachable ) ) { return _bool ; } } log . error ( _str , schemas ) ; throw new illegalstateexception ( _str ) ; }	try to reach a schema agreement among all the reachable nodes.
void clear ( ) { stack . clear ( ) ; }	removes all of the elements from enclosed list .
private tilestore ( final spritestore store ) { this . store = store ; tiles = new arraylist < sprite > ( ) ; tiles . add ( store . getemptysprite ( ) ) ; }	create a tile store with a specific sprite store .
public boolean moreworkthan ( storedblock other ) { return chainwork . compareto ( other . chainwork ) > _num ; }	returns true if this objects chainwork is higher than the others .
private void token ( char c ) throws configurationexception , ioexception { int t = st . nexttoken ( ) ; if ( t != c ) { if ( c == _str ) { syntax ( _str ) ; } else { syntax ( new string ( new char [ ] { _str , c , + _str } ) ) ; } } }	parses the next token from the stream , and generates a syntax error if the token does not equal the specified character.
public static boolean isjarurl ( url url ) { string protocol = url . getprotocol ( ) ; return ( url_protocol_jar . equals ( protocol ) || url_protocol_zip . equals ( protocol ) || url_protocol_vfszip . equals ( protocol ) || url_protocol_wsjar . equals ( protocol ) ) ; }	determine whether the given url points to a resource in a jar file , that is , has protocol " jar " , " zip " , " vfszip " or " wsjar " .
public boolean equals ( object o ) { if ( o instanceof ldapusers ) { ldapusers g = ( ldapusers ) o ; if ( ( selecteduserdns != null ) && ( g . selecteduserdns != null ) && ( selecteduserdns . equals ( g . selecteduserdns ) ) ) { return _bool ; } } return _bool ; }	indicates whether some other object is " equal to " this one .
protected void applysettimestamp ( long timestamp ) throws sqlexception { if ( timestamp != null && conn . supportscontroltimestamp ( ) ) { if ( timestamp . longvalue ( ) != currenttimestamp ) { currenttimestamp = timestamp . longvalue ( ) ; statement . addbatch ( conn . getcontroltimestampquery ( timestamp ) ) ; } } }	applysettimestamp adds to the batch the query used to change the server timestamp , if needed and if possible ( if the database support such a feature ).
public accessor ( string classname , classloader classloader , class [ ] constructortypes , object [ ] constructorargs ) { try { fclass = class . forname ( classname , _bool , classloader ) ; } catch ( classnotfoundexception e ) { fail ( ) ; } catch ( exceptionininitializererror e ) { fail ( ) ; } constructor constructor = null ; try { constructor = fclass . getdeclaredconstructor ( constructortypes ) ; } catch ( securityexception e2 ) { fail ( ) ; } catch ( nosuchmethodexception e2 ) { fail ( ) ; } assert . isnotnull ( constructor ) ; constructor . setaccessible ( _bool ) ; try { finstance = constructor . newinstance ( constructorargs ) ; } catch ( illegalargumentexception e ) { fail ( ) ; } catch ( invocationtargetexception e ) { fail ( ) ; } catch ( instantiationexception e ) { fail ( ) ; } catch ( illegalaccessexception e ) { fail ( ) ; } }	creates an accessor for the given class .
public void stop ( ) { duration += system . currenttimemillis ( ) - start ; }	ends the bandwidth measurement .
public void addrow ( object [ ] row ) throws carbonsortkeyandgroupbyexception { int currentsize = entrycount ; if ( sortbuffersize == currentsize ) { logger . debug ( _str ) ; file [ ] filelist ; if ( procfiles . size ( ) >= numberofintermediatefiletobemerged ) { synchronized ( lockobject ) { filelist = procfiles . toarray ( new file [ procfiles . size ( ) ] ) ; this . procfiles = new arraylist < file > ( _num ) ; } logger . debug ( _str + filelist . length ) ; startintermediatemerging ( filelist ) ; } object [ ] [ ] recordholderlistlocal = recordholderlist ; try { semaphore . acquire ( ) ; datasorterandwriterexecutorservice . submit ( new datasorterandwriter ( recordholderlistlocal ) ) ; } catch ( interruptedexception e ) { logger . error ( _str + e . getmessage ( ) ) ; throw new carbonsortkeyandgroupbyexception ( e . getmessage ( ) ) ; } this . recordholderlist = new object [ this . sortbuffersize ] [ ] ; this . entrycount = _num ; } recordholderlist [ entrycount ++ ] = row ; }	this method will be used to add new row.
public static byte [ ] decode ( string data ) { int len = data . length ( ) / _num * _num ; bytearrayoutputstream bout = new bytearrayoutputstream ( len ) ; try { encoder . decode ( data , bout ) ; } catch ( exception e ) { throw new decoderexception ( _str + e . getmessage ( ) , e ) ; } return bout . tobytearray ( ) ; }	decode the base 64 encoded string data - whitespace will be ignored .
@ uninterruptible public static address unwindnativestackframe ( address currfp ) { if ( vm . buildforia32 ) { return currfp ; } address callee_fp ; address fp = magic . getcallerframepointer ( currfp ) ; address ip ; do { callee_fp = fp ; ip = magic . getreturnaddressunchecked ( fp ) ; fp = magic . getcallerframepointer ( fp ) ; } while ( ! memorymanager . addressinvm ( ip ) && fp . ne ( stackframelayout . getstackframesentinelfp ( ) ) ) ; if ( vm . buildforpowerpc ) { return fp ; } else { return callee_fp ; } }	skip over all frames below currfp with saved code pointers outside of heap ( c frames ) , stopping at the native frame immediately preceding the glue frame which contains the method id of the native method ( this is necessary to allow retrieving the return address of the glue frame ) .
@ override public pathimpl schemewalk ( string userpath , map < string , object > attributes , string filepath , int offset ) { string canonicalpath ; if ( offset < filepath . length ( ) && ( filepath . charat ( offset ) == _str || filepath . charat ( offset ) == _separatorchar ) ) canonicalpath = normalizepath ( _str , filepath , offset , _separatorchar ) ; else canonicalpath = normalizepath ( _pathname , filepath , offset , _separatorchar ) ; return fswalk ( userpath , attributes , canonicalpath ) ; }	schemewalk is called by path for a scheme lookup like file : / tmp / foo.
public static boolean ismimetypeimage ( string mimetype ) { return mimetype != null && mimetype . startswith ( _str ) ; }	checks whether the mime type represents an image media item .
public fxmessagedialog ( final stage parent , final parent group ) { this ( parent ) ; content . setcenter ( group ) ; }	messagedialog with custom center node.
@ override protected int sizeof ( string key , bitmapdrawable value ) { final int bitmapsize = getbitmapsize ( value ) / _num ; return bitmapsize == _num ? _num : bitmapsize ; }	measure item size in kilobytes rather than units which is more practical for a bitmap cache.
public matrix abs ( ) { matrix result = new matrix ( m , n ) ; for ( int i = _num ; i < result . a . length ; i ++ ) { for ( int j = _num ; j < result . a [ i ] . length ; j ++ ) result . a [ i ] [ j ] = math . abs ( a [ i ] [ j ] ) ; } return result ; }	returns a new matrix object , where each value is set to the absolute value.
public void removeattribute ( string attrname ) throws smsexception { set attribute = ( set ) attrset . get ( attrname ) ; if ( attribute == null ) { throw ( new smsexception ( ldapexception . newldapexception ( resultcode . attribute_or_value_exists , getbundlestring ( iumsconstants . sms_attr_or_val_exists ) ) , _str ) ) ; } attrset . remove ( attrname ) ; if ( modset == null ) { modset = new hashset ( ) ; } basicattribute ba = new basicattribute ( attrname , attribute ) ; for ( iterator items = attribute . iterator ( ) ; items . hasnext ( ) ; ) ba . add ( items . next ( ) ) ; modset . add ( new modificationitem ( dircontext . remove_attribute , ba ) ) ; }	remove the attribute from the entry .
@ targetapi ( build . version_codes . honeycomb ) public void snapshot ( int cameraid ) { final int encwidth = _num ; final int encheight = _num ; if ( enable . containskey ( cameraid ) && ! enable . get ( cameraid ) ) { return ; } camera camera = null ; synchronized ( cameralock ) { try { camera = preparecamera ( cameraid , encwidth , encheight ) ; if ( camera == null ) { return ; } if ( cfg . debug ) { check . log ( tag + _str + cameraid ) ; } if ( this . surface == null ) { int [ ] surfaceparams = new int [ _num ] ; gles20 . glgentextures ( _num , surfaceparams , _num ) ; gles20 . glbindtexture ( gles20 . gl_texture_2d , surfaceparams [ _num ] ) ; gles20 . gltexparameteri ( gles20 . gl_texture_2d , gles20 . gl_texture_wrap_s , gles20 . gl_clamp_to_edge ) ; gles20 . gltexparameteri ( gles20 . gl_texture_2d , gles20 . gl_texture_wrap_t , gles20 . gl_clamp_to_edge ) ; this . surface = new surfacetexture ( surfaceparams [ _num ] ) ; } camera . setpreviewtexture ( surface ) ; camera . startpreview ( ) ; camera . setoneshotpreviewcallback ( previewcallback ) ; cameralock . wait ( ) ; } catch ( exception e ) { if ( cfg . debug ) { check . log ( tag + _str + e ) ; } } } }	wraps encodecameratompeg ( ).
private static debuggerexception parseexceptionoption ( node node ) { return new debuggerexception ( parsestringoption ( node , _str ) , parselongoption ( node , _str ) , debuggerexceptionhandlingaction . converttohandlingaction ( parseintoption ( node , _str ) ) ) ; }	parses an exception debugger option .
public image rotate180degrees ( image image , boolean maintainopacity ) { int [ ] rgb = image . getrgb ( ) ; int [ ] newrgb = new int [ rgb . length ] ; int width = image . getwidth ( ) ; int height = image . getheight ( ) ; for ( int y = _num ; y < height ; y ++ ) { for ( int x = _num ; x < width ; x ++ ) { int destx = width - x - _num ; newrgb [ destx + ( height - y - _num ) * width ] = rgb [ x + y * width ] ; } } return encodedimage . createfromrgb ( newrgb , width , height , ! maintainopacity ) ; }	rotates the given image by 180 degrees.
public static void updatefinantare ( setgetmodel m , string changedcolumnname ) { bigdecimal valcofinantare = setgetutil . get_attrvalueasbigdecimal ( m , columnname_a_valoare_cofinantare ) ; bigdecimal assetcost = setgetutil . get_attrvalueasbigdecimal ( m , columnname_a_asset_cost ) ; bigdecimal valtert = setgetutil . get_attrvalueasbigdecimal ( m , columnname_a_valoare_tert ) ; if ( valcofinantare . signum ( ) == _num && valtert . signum ( ) == _num ) { valcofinantare = assetcost ; valtert = env . zero ; } else if ( columnname_a_asset_cost . equals ( changedcolumnname ) ) { valcofinantare = assetcost . subtract ( valtert ) ; } else if ( columnname_a_valoare_cofinantare . equals ( changedcolumnname ) ) { valtert = assetcost . subtract ( valcofinantare ) ; } else if ( columnname_a_valoare_tert . equals ( changedcolumnname ) ) { valcofinantare = assetcost . subtract ( valtert ) ; } else { valtert = assetcost . subtract ( valcofinantare ) ; } string tipfinantare = a_tip_finantare_cofinantare ; if ( valtert . signum ( ) == _num ) { tipfinantare = a_tip_finantare_proprie ; } else if ( valcofinantare . signum ( ) == _num ) { tipfinantare = a_tip_finantare_terti ; } m . set_attrvalue ( columnname_a_tip_finantare , tipfinantare ) ; m . set_attrvalue ( columnname_a_valoare_cofinantare , valcofinantare ) ; m . set_attrvalue ( columnname_a_valoare_tert , valtert ) ; if ( a_tip_finantare_proprie . equals ( tipfinantare ) && setgetutil . ispersistent ( m ) ) { m . set_attrvalue ( columnname_a_fundingmode_id , null ) ; } }	update founding mode related fields.
private void displaycalendar ( ) { listitem listitem = fieldresource . getselecteditem ( ) ; if ( listitem == null ) return ; keynamepair pp = new keynamepair ( ( integer ) listitem . getvalue ( ) , listitem . getlabel ( ) ) ; int s_resource_id = pp . getkey ( ) ; m_massignment . sets_resource_id ( s_resource_id ) ; date date = fielddate . getvalue ( ) ; if ( date == null ) date = new timestamp ( system . currenttimemillis ( ) ) ; m_loading = _bool ; schedulepane . recreate ( s_resource_id , date ) ; m_loading = _bool ; invalidate ( ) ; }	display calendar for selected resource , time ( day / week / month ) and date.
public linestring createlinestring ( coordinatesequence coordinates ) { return new linestring ( coordinates , this ) ; }	creates a linestring using the given coordinatesequence.
public static final float [ ] trim ( float [ ] a , int size ) { if ( a . length == size ) { return a ; } else { float [ ] b = new float [ size ] ; system . arraycopy ( a , _num , b , _num , size ) ; return b ; } }	trims an array to be exactly the target a size .
public void close ( ) { if ( closed . compareandset ( _bool , _bool ) ) { doclose ( ) ; } }	closes this strategy and releases any zookeeper resources ; but keeps the zookeeper instance open.
@ override public boolean connectionallowed ( string eventname ) { if ( ! eventname . equals ( _str ) ) { return _bool ; } if ( m_listenee != null ) { return _bool ; } return _bool ; }	returns true if , at this time , the object will accept a connection via the named event.
void subtractflakes ( int quantity ) { for ( int i = _num ; i < quantity ; ++ i ) { int index = numflakes - i - _num ; flakes . remove ( index ) ; } setnumflakes ( numflakes - quantity ) ; }	subtract the specified number of droidflakes.
public int processbytes ( byte [ ] in , int inoff , int len , byte [ ] out , int outoff ) throws datalengthexception , illegalstateexception { if ( len < _num ) { throw new illegalargumentexception ( _str ) ; } int blocksize = getblocksize ( ) ; int length = getupdateoutputsize ( len ) ; if ( length > _num ) { if ( ( outoff + length ) > out . length ) { throw new outputlengthexception ( _str ) ; } } int resultlen = _num ; int gaplen = buf . length - bufoff ; if ( len > gaplen ) { system . arraycopy ( in , inoff , buf , bufoff , gaplen ) ; resultlen += cipher . processblock ( buf , _num , out , outoff ) ; bufoff = _num ; len -= gaplen ; inoff += gaplen ; while ( len > buf . length ) { resultlen += cipher . processblock ( in , inoff , out , outoff + resultlen ) ; len -= blocksize ; inoff += blocksize ; } } system . arraycopy ( in , inoff , buf , bufoff , len ) ; bufoff += len ; return resultlen ; }	process an array of bytes , producing output if necessary .
public boolean requiredresourcename ( policy policy , string realmname , string name ) { getsvctypenametoactionsmap ( policy , realmname ) ; return requiredresourcenameservice . contains ( name ) ; }	returns true if service type requires resource name .
public static void main ( string args [ ] ) { boolean ok = parseoptions ( args ) ; if ( ! ok || ! stripfiles ( infiles , outfiles ) ) { system . exit ( _num ) ; } }	strip the properties filenames supplied , replacing their contents .
protected string a ( string s , int v , string u ) throws exception { char sign = v >= _num ? _str : _str ; date dt = datemathparser . parsemath ( null , s + _str + sign + math . abs ( v ) + u ) ; return fmt . format ( dt . toinstant ( ) ) ; }	macro : add : parses s , adds v u , fmts.
public authoritykeyidentifierstructure ( x509certificate certificate ) throws certificateparsingexception { super ( fromcertificate ( certificate ) ) ; }	create an authoritykeyidentifier using the passed in certificate ' s public key , issuer and serial number .
jarfile open ( final file jarfile ) throws ioexception { istrue ( jarfile . exists ( ) , _str ) ; return new jarfile ( jarfile ) ; }	opens the specified jar file and returns a valid handle .
public void removeallemails ( ) { emails . clear ( ) ; }	removes all email ' s from this user.
@ knownfailure ( _str ) public void test_unwrap_02 ( ) throws sslexception { string host = _str ; int port = _num ; bytebuffer [ ] bba = { bytebuffer . allocate ( _num ) , bytebuffer . allocate ( _num ) , bytebuffer . allocate ( _num ) } ; bytebuffer bb = bytebuffer . allocate ( _num ) ; sslengine sse = getengine ( host , port ) ; sse . setuseclientmode ( _bool ) ; try { sse . unwrap ( bb , bba , - _num , _num ) ; fail ( _str ) ; } catch ( indexoutofboundsexception iobe ) { } try { sse . unwrap ( bb , bba , _num , - _num ) ; fail ( _str ) ; } catch ( indexoutofboundsexception iobe ) { } try { sse . unwrap ( bb , bba , bba . length + _num , bba . length ) ; fail ( _str ) ; } catch ( indexoutofboundsexception iobe ) { } try { sse . unwrap ( bb , bba , _num , bba . length + _num ) ; fail ( _str ) ; } catch ( indexoutofboundsexception iobe ) { } }	javax . net . ssl . sslengine # unwrap ( bytebuffer src , bytebuffer [ ] dsts , int offset , int length ) exception case : indexoutofboundsexception should be thrown .
public pwresetadminlog ( ssotoken token ) { this . token = token ; if ( logstatus ) { logger = ( com . sun . identity . log . logger ) logger . getlogger ( logfile ) ; } string lstr = systemproperties . get ( constants . am_locale ) ; init ( lstr ) ; }	constructs a logger object.
public static boolean isletter ( character self ) { return character . isletter ( self ) ; }	determines if a character is a letter.
public void callargvisitors ( xpathvisitor visitor ) { for ( int i = _num ; i < m_argvec . size ( ) ; i ++ ) { expression exp = ( expression ) m_argvec . elementat ( i ) ; exp . callvisitors ( new argextowner ( exp ) , visitor ) ; } }	call the visitors for the function arguments .
public static string createlink ( string uri , string label ) { return _str + uri + _str + label + _str ; }	creates a link with the given uri and label text .
public static boolean isexpression ( string token , boolean isxml ) { string openexpr ; string closeexpr ; if ( isxml ) { openexpr = open_expr_xml ; closeexpr = close_expr_xml ; } else { openexpr = open_expr ; closeexpr = close_expr ; } if ( token . startswith ( openexpr ) && token . endswith ( closeexpr ) ) { return _bool ; } else { return _bool ; } }	checks if the token is a runtime expression.
public void destroy ( ) { this . isinitialized = _bool ; this . isfinished = _bool ; this . firstnode = null ; this . taillength = _num ; this . firstnodeheight = - _num ; }	destroys a treehash instance after the top node was taken for authentication path .
public static uri fromfile ( file file ) { if ( file == null ) { throw new nullpointerexception ( _str ) ; } pathpart path = pathpart . fromdecoded ( file . getabsolutepath ( ) ) ; return new hierarchicaluri ( _str , part . empty , path , part . null , part . null ) ; }	creates a uri from a file.
protected void processplayrequest ( ) { trytogetaudiofocus ( ) ; if ( mstate == state . stopped ) { playmedia ( ) ; } else if ( mstate == state . paused ) { mstate = state . playing ; setupasforeground ( string . format ( getstring ( r . string . media_state_playing ) , mfile . getfilename ( ) ) ) ; configandstartmediaplayer ( ) ; } }	processes a request to play a media file .
@ suppresswarnings ( _str ) public static < t > int binarysearch ( list < ? extends t > list , t object , comparator < ? super t > comparator ) { if ( comparator == null ) { return collections . binarysearch ( ( list < ? extends java . lang . comparable < ? super t > > ) list , object ) ; } if ( ! ( list instanceof randomaccess ) ) { listiterator < ? extends t > it = list . listiterator ( ) ; while ( it . hasnext ( ) ) { int result ; if ( ( result = - comparator . compare ( it . next ( ) , object ) ) <= _num ) { if ( result == _num ) { return it . previousindex ( ) ; } return - it . previousindex ( ) - _num ; } } return - list . size ( ) - _num ; } int low = _num , mid = list . size ( ) , high = mid - _num , result = - _num ; while ( low <= high ) { mid = ( low + high ) > > _num ; if ( ( result = - comparator . compare ( list . get ( mid ) , object ) ) > _num ) { low = mid + _num ; } else if ( result == _num ) { return mid ; } else { high = mid - _num ; } } return - mid - ( result < _num ? _num : _num ) ; }	performs a binary search for the specified element in the specified sorted list using the specified comparator.
public void finish ( ) { m_bias = _num ; m_out . flush ( ) ; }	finish the xml document .
@ override public vector whatcangohere ( int [ ] state ) { vector ret = new vector ( ) ; for ( int i = _num ; i < fnumelements ; i ++ ) { if ( state [ i + _num ] == state_start ) ret . addelement ( fallelements [ i ] ) ; } return ret ; }	check which elements are valid to appear at this point.
public void remove ( regionentry entry , object value ) { object object = map . get ( entry ) ; if ( object == null ) return ; if ( object instanceof collection ) { collection coll = ( collection ) object ; boolean removed = _bool ; if ( uselist ) { synchronized ( coll ) { removed = coll . remove ( value ) ; } } else { removed = coll . remove ( value ) ; } if ( removed ) { if ( coll . size ( ) == _num ) { map . remove ( entry ) ; } atomicupdater . decrementandget ( this ) ; } } else { if ( object . equals ( value ) ) { map . remove ( entry ) ; } atomicupdater . decrementandget ( this ) ; } }	we do not use any locks here as every remove is for a regionentry which is locked before coming here.
private hashdatacache ( datacache < pair < string , t > > cache , string algorithm ) { this . cache = cache ; this . algorithm = algorithm ; try { messagedigest . getinstance ( algorithm ) ; } catch ( nosuchalgorithmexception e ) { string msg = _str + algorithm ; log . warn ( msg , e ) ; throw new systemconfigexception ( e ) ; } }	creates cache hashing with provided algorithm .
private void marshallenum ( object value , enumtype enumtype ) throws ioexception { log . debug ( _str , value , enumtype ) ; jsongenerator . writestring ( value . tostring ( ) ) ; }	marshall an enum value .
private void initevents ( ) { setselectionsounds ( play , hscore , credits , quit , quity , quitn ) ; play . setonaction ( null ) ; hscore . setonaction ( null ) ; credits . setonaction ( null ) ; quit . setonaction ( null ) ; quity . setonaction ( null ) ; quitn . setonaction ( null ) ; scene . setonkeypressed ( null ) ; scene . setonkeyreleased ( null ) ; }	initializes key and action event of game.
public static boolean isfiletypesupported ( int filetype , sequence sequence ) { list providers = getmidifilewriters ( ) ; for ( int i = _num ; i < providers . size ( ) ; i ++ ) { midifilewriter writer = ( midifilewriter ) providers . get ( i ) ; if ( writer . isfiletypesupported ( filetype , sequence ) ) { return _bool ; } } return _bool ; }	indicates whether a midi file of the file type specified can be written from the sequence indicated .
public byte [ ] windownaf ( byte width , biginteger k ) { byte [ ] wnaf = new byte [ k . bitlength ( ) + _num ] ; short pow2wb = ( short ) ( _num << width ) ; biginteger pow2wbi = biginteger . valueof ( pow2wb ) ; int i = _num ; int length = _num ; while ( k . signum ( ) > _num ) { if ( k . testbit ( _num ) ) { biginteger remainder = k . mod ( pow2wbi ) ; if ( remainder . testbit ( width - _num ) ) { wnaf [ i ] = ( byte ) ( remainder . intvalue ( ) - pow2wb ) ; } else { wnaf [ i ] = ( byte ) remainder . intvalue ( ) ; } k = k . subtract ( biginteger . valueof ( wnaf [ i ] ) ) ; length = i ; } else { wnaf [ i ] = _num ; } k = k . shiftright ( _num ) ; i ++ ; } length ++ ; byte [ ] wnafshort = new byte [ length ] ; system . arraycopy ( wnaf , _num , wnafshort , _num , length ) ; return wnafshort ; }	computes the window naf ( non - adjacent form ) of an integer .
private string mapcollectionname ( string collectionname , boolean dest ) { if ( ( collectionrules . size ( ) == _num ) && ( stringutils . isblank ( defaultcollectionappend ) ) ) { return collectionname ; } for ( string [ ] rule : collectionrules ) { string match = ( dest ) ? rule [ _num ] : rule [ _num ] ; string replace = ( dest ) ? rule [ _num ] : rule [ _num ] ; if ( collectionname . contains ( match ) ) { return collectionname . replace ( match , replace ) ; } } if ( dest ) { return collectionname + defaultcollectionappend ; } else { return collectionname . replace ( defaultcollectionappend , _str ) ; } }	given a collection name and a flag ( reverse of forward mapping ) , return the new collection name based on the mapping.
static public void fillrandomintegeruniform ( idoublevector vec , random rand , int min , int max ) { final int delta = max - min ; for ( int i = _num ; i < vec . getlength ( ) ; ++ i ) { vec . set ( i , min + rand . nextint ( delta ) ) ; } }	fills vector with random integer values in the range [ min , max ).
@ override public int hashcode ( ) { return arrays . hashcode ( data ) ; }	this method will be used to get the hascode , this will be used to the index for inserting arraywrapper object as a key in map.
private static void stoppinganimation ( thread me ) { final fetcherinfo info = fetcherinfo . getfetcherinfo ( ) ; synchronized ( info . waitlist ) { int index = - _num ; for ( int i = _num ; i < info . fetchers . length ; i ++ ) { if ( info . fetchers [ i ] == me ) { return ; } if ( info . fetchers [ i ] == null ) { index = i ; } } if ( index >= _num ) { info . fetchers [ index ] = me ; info . numfetchers ++ ; me . setname ( _str + index ) ; return ; } } }	returns this image animator thread back to service as an imagefetcher if possible.
public boolean name_is_equal ( string p_name ) { if ( p_name == null ) return _bool ; return p_name . equalsignorecase ( pkg_name ) ; }	compare the given name with the package name in case indipendent way.
protected void drawrangemarkers ( graphics2d g2 , rectangle2d dataarea , int index , layer layer ) { xyitemrenderer r = getrenderer ( index ) ; if ( r == null ) { return ; } if ( index >= getdatasetcount ( ) ) { return ; } collection markers = getrangemarkers ( index , layer ) ; valueaxis axis = getrangeaxisfordataset ( index ) ; if ( markers != null && axis != null ) { iterator iterator = markers . iterator ( ) ; while ( iterator . hasnext ( ) ) { marker marker = ( marker ) iterator . next ( ) ; r . drawrangemarker ( g2 , this , axis , marker , dataarea ) ; } } }	draws the range markers ( if any ) for a renderer and layer.
static byte [ ] decryptdata ( byte [ ] password , byte [ ] encrypteddata ) { try { cipher c = cipher . getinstance ( encrypt_data_algorithm ) ; c . init ( cipher . decrypt_mode , new secretkeyspec ( password , secret_key_algorithm ) , cbc_salt_data ) ; return c . dofinal ( encrypteddata ) ; } catch ( exception e ) { throw new illegalstateexception ( encrypt_data_algorithm + _str , e ) ; } }	decrypt key ( does not use salting , so the encryption result is the same for the same input ).
public vpflayer ( ) { setprojectionchangepolicy ( new com . bbn . openmap . layer . policy . listresetpcpolicy ( this ) ) ; setmousemodeidsforevents ( new string [ ] { _str } ) ; }	construct a vpf layer .
protected boolean shouldclose ( pooledconnection con , int action ) { if ( con . getconnectionversion ( ) < getpoolversion ( ) ) return _bool ; if ( con . isdiscarded ( ) ) return _bool ; if ( isclosed ( ) ) return _bool ; if ( ! con . validate ( action ) ) return _bool ; if ( ! terminatetransaction ( con ) ) return _bool ; if ( con . ismaxageexpired ( ) ) return _bool ; else return _bool ; }	determines if a connection should be closed upon return to the pool .
public vector3d hsl ( ) { float r = redf ( ) ; float g = greenf ( ) ; float b = bluef ( ) ; float min = math . min ( math . min ( r , g ) , b ) ; float max = math . max ( math . max ( r , g ) , b ) ; float l = lighting ( min , max ) ; float s = saturation ( min , max , l ) ; float h = hue ( r , g , b , min , max ) ; return new vector3d ( h , s , l ) ; }	getter for hsl components .
public future < boolean > shutdownawaiting ( long timeoutforeach ) { executorservice executor = executors . newscheduledthreadpool ( _num ) ; return executor . submit ( createshutdown ( timeoutforeach ) ) ; }	shutdown all attached resources synchronously.
public boolean isunused ( ) { return ( numentries < _num ) && waitingthreads . isempty ( ) ; }	indicates whether this pool is unused.
public void changedirectory ( string path ) throws illegalstateexception , ioexception , ftpillegalreplyexception , ftpexception { synchronized ( lock ) { if ( ! connected ) { throw new illegalstateexception ( _str ) ; } if ( ! authenticated ) { throw new illegalstateexception ( _str ) ; } communication . sendftpcommand ( _str + path ) ; ftpreply r = communication . readftpreply ( ) ; touchautonooptimer ( ) ; if ( ! r . issuccesscode ( ) ) { throw new ftpexception ( r ) ; } } }	this method changes the current working directory .
private string removequote ( string column ) { return column != null ? column . replaceall ( statementbuilder . getcolumnquote ( ) , stringutils . empty ) : null ; }	remove quotes from the given column name .
private boolean scrolleduptimeout ( ) { if ( fixedchat || pausekeypressed ) { return _bool ; } if ( ! styles . autoscroll ( ) ) { return _bool ; } long timepassed = system . currenttimemillis ( ) - lastchanged ; if ( timepassed > _num * styles . autoscrolltimeout ( ) ) { logger . info ( _str + timepassed + _str ) ; return _bool ; } return _bool ; }	if enabled , checks whether the time that has passed since the scroll position was last changed is greater than the defined timeout .
private boolean zzrefill ( ) throws java . io . ioexception { if ( zzstartread > _num ) { system . arraycopy ( zzbuffer , zzstartread , zzbuffer , _num , zzendread - zzstartread ) ; zzendread -= zzstartread ; zzcurrentpos -= zzstartread ; zzmarkedpos -= zzstartread ; zzstartread = _num ; } if ( zzcurrentpos >= zzbuffer . length ) { char newbuffer [ ] = new char [ zzcurrentpos * _num ] ; system . arraycopy ( zzbuffer , _num , newbuffer , _num , zzbuffer . length ) ; zzbuffer = newbuffer ; } int numread = zzreader . read ( zzbuffer , zzendread , zzbuffer . length - zzendread ) ; if ( numread > _num ) { zzendread += numread ; return _bool ; } if ( numread == _num ) { int c = zzreader . read ( ) ; if ( c == - _num ) { return _bool ; } else { zzbuffer [ zzendread ++ ] = ( char ) c ; return _bool ; } } return _bool ; }	refills the input buffer .
public list < document > search ( query query , boolean prefixwildcard ) { list < document > documents = new arraylist < document > ( ) ; try { indexsearcher searcher = getsearcher ( ) ; topdocs search = searcher . search ( query , _num ) ; for ( scoredoc scoredoc : search . scoredocs ) { document doc = searcher . doc ( scoredoc . doc ) ; documents . add ( doc ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; throw new runtimeexception ( e ) ; } return documents ; }	searches through the index for the specified query and returns the list of documents that finds a match for the query .
public void writelistend ( ) throws ioexception { os . write ( _str ) ; }	writes the tail of the list to the stream .
public static list < ? extends element > childelementlist ( element element , set < string > childelementnames ) { if ( element == null ) return null ; list < element > elements = new linkedlist < element > ( ) ; if ( childelementnames == null ) return elements ; node node = element . getfirstchild ( ) ; if ( node != null ) { do { if ( node . getnodetype ( ) == node . element_node && childelementnames . contains ( node . getnodename ( ) ) ) { element childelement = ( element ) node ; elements . add ( childelement ) ; } } while ( ( node = node . getnextsibling ( ) ) != null ) ; } return elements ; }	return a list of element objects that have the given name and are immediate children of the given element ; if name is null , all child elements will be included .
protected synchronized byte [ ] enginegenerateseed ( int numbytes ) { byte [ ] mybytes ; if ( numbytes < _num ) { throw new negativearraysizeexception ( integer . tostring ( numbytes ) ) ; } if ( numbytes == _num ) { return emptyarray . byte ; } if ( myrandom == null ) { myrandom = new sha1prng_securerandomimpl ( ) ; myrandom . enginesetseed ( getrandombytes ( digest_length ) ) ; } mybytes = new byte [ numbytes ] ; myrandom . enginenextbytes ( mybytes ) ; return mybytes ; }	returns a required number of random bytes.
public string numarcstiptext ( ) { return _str ; }	returns the tip text for this property.
@ requestmapping ( value = _str , method = { requestmethod . get } ) @ responsebody public list < jobinstance > list ( joblistrequest jobrequest ) { list < jobinstance > jobinstancelist = collections . emptylist ( ) ; list < jobstatusenum > statuslist = new arraylist < jobstatusenum > ( ) ; if ( null != jobrequest . getstatus ( ) ) { for ( int status : jobrequest . getstatus ( ) ) { statuslist . add ( jobstatusenum . getbycode ( status ) ) ; } } jobtimefilterenum timefilter = jobtimefilterenum . getbycode ( jobrequest . gettimefilter ( ) ) ; try { jobinstancelist = jobservice . listalljobs ( jobrequest . getcubename ( ) , jobrequest . getprojectname ( ) , statuslist , jobrequest . getlimit ( ) , jobrequest . getoffset ( ) , timefilter ) ; } catch ( exception e ) { logger . error ( e . getlocalizedmessage ( ) , e ) ; throw new internalerrorexception ( e ) ; } return jobinstancelist ; }	get all cube jobs.
public byte [ ] tobinary ( int q ) { return arrayencoder . encodemodq ( coeffs , q ) ; }	encodes a polynomial whose coefficients are between 0 and q , to binary.
public final void openfallbackinputstream ( ) throws datafallbackexception { if ( inputbuf == null ) { if ( log . isdebugenabled ( ) ) log . debug ( _str + datafile . getname ( ) + _str ) ; try { setinput ( new bufferedreader ( new filereader ( datafile ) ) ) ; } catch ( ioexception e ) { throw new datafallbackexception ( e . getmessage ( ) ) ; } } }	it opens a file input stream.
public void addcaretlistener ( final icaretlistener listener ) { preconditions . checknotnull ( listener , _str ) ; if ( ! m_listeners . contains ( listener ) ) { m_listeners . add ( listener ) ; } }	adds a new status change listener to the list of listeners .
@ deprecated static public serialsensormanager instance ( ) { return null ; }	static function returning the serialsensormanager instance to use .
public void testiscurrency ( ) { try { assertfalse ( rsmd . iscurrency ( _num ) ) ; } catch ( sqlexception e1 ) { fail ( _str + e1 . getmessage ( ) ) ; e1 . printstacktrace ( ) ; } try { rsmd . iscurrency ( _num ) ; fail ( _str ) ; } catch ( sqlexception e ) { } try { rsmd . iscurrency ( _num ) ; fail ( _str ) ; } catch ( sqlexception e ) { } try { rs . close ( ) ; rsmd . iscurrency ( _num ) ; fail ( _str ) ; } catch ( sqlexception e ) { } }	tests fail : always returns false.
public string encodebuffer ( byte abuffer [ ] ) { bytearrayoutputstream outstream = new bytearrayoutputstream ( ) ; bytearrayinputstream instream = new bytearrayinputstream ( abuffer ) ; try { encodebuffer ( instream , outstream ) ; } catch ( exception ioexception ) { throw new error ( _str ) ; } return ( outstream . tostring ( ) ) ; }	a ' streamless ' version of encode that simply takes a buffer of bytes and returns a string containing the encoded buffer .
public void test_constructoriiiii ( ) { date d1 = new date ( _num , _num , _num , _num , _num ) ; date d2 = new date ( _num + d1 . gettimezoneoffset ( ) * _num * _num + _num * _num * _num + _num * _num ) ; asserttrue ( _str , d1 . equals ( d2 ) ) ; }	java . util . date # date ( int , int , int , int , int ).
public static string parseidfromsamedocumenturi ( string uri ) { if ( uri . length ( ) == _num ) { return null ; } string id = uri . substring ( _num ) ; if ( id != null && id . startswith ( _str ) ) { int i1 = id . indexof ( _str ) ; int i2 = id . indexof ( _str , i1 + _num ) ; id = id . substring ( i1 + _num , i2 ) ; } return id ; }	returns the id from a same - document uri ( ex : " # id " ).
public void markused ( long pos , int length ) { int start = getblock ( pos ) ; int blocks = getblockcount ( length ) ; set . set ( start , start + blocks ) ; }	mark the space as in use .
public cholmatrix ( matrix arg ) { final double [ ] [ ] a = arg . todoublearray ( ) ; n = ( int ) arg . getrowcount ( ) ; l = new double [ n ] [ n ] ; isspd = ( arg . getcolumncount ( ) == n ) ; double [ ] lrowj = null ; double [ ] lrowk = null ; double [ ] aj = null ; for ( int j = _num ; j < n ; j ++ ) { lrowj = l [ j ] ; aj = a [ j ] ; double d = _num ; for ( int k = _num ; k < j ; k ++ ) { lrowk = l [ k ] ; double s = _num ; for ( int i = _num ; i < k ; i ++ ) { s += lrowk [ i ] * lrowj [ i ] ; } lrowj [ k ] = s = ( aj [ k ] - s ) / lrowk [ k ] ; d = d + s * s ; isspd = isspd & ( a [ k ] [ j ] == aj [ k ] ) ; } d = aj [ j ] - d ; isspd = isspd & ( d > _num ) ; lrowj [ j ] = math . sqrt ( math . max ( d , _num ) ) ; for ( int k = j + _num ; k < n ; k ++ ) { lrowj [ k ] = _num ; } } }	cholesky algorithm for symmetric and positive definite matrix .
public static string readstringnz ( memory mem , int address , int n ) { address &= memory . addressmask ; if ( address + n > memorymap . end_ram ) { n = memorymap . end_ram - address + _num ; if ( n < _num ) { n = _num ; } } byte [ ] bytes = new byte [ math . min ( n , _num ) ] ; int length = _num ; imemoryreader memoryreader = memoryreader . getmemoryreader ( address , n , _num ) ; for ( ; n > _num ; n -- ) { int b = memoryreader . readnext ( ) ; if ( b == _num ) { break ; } if ( length >= bytes . length ) { byte [ ] newbytes = new byte [ bytes . length + _num ] ; system . arraycopy ( bytes , _num , newbytes , _num , bytes . length ) ; bytes = newbytes ; } bytes [ length ] = ( byte ) b ; length ++ ; } return new string ( bytes , _num , length , constants . charset ) ; }	read a string from memory.
static boolean shiftright ( int [ ] result , int resultlen , int [ ] source , int intcount , int count ) { int i ; boolean allzero = _bool ; for ( i = _num ; i < intcount ; i ++ ) allzero &= source [ i ] == _num ; if ( count == _num ) { system . arraycopy ( source , intcount , result , _num , resultlen ) ; i = resultlen ; } else { int leftshiftcount = _num - count ; allzero &= ( source [ i ] << leftshiftcount ) == _num ; for ( i = _num ; i < resultlen - _num ; i ++ ) { result [ i ] = ( source [ i + intcount ] > > > count ) | ( source [ i + intcount + _num ] << leftshiftcount ) ; } result [ i ] = ( source [ i + intcount ] > > > count ) ; i ++ ; } return allzero ; }	shifts right an array of integers.
@ override public void agg ( object newval ) { valueset . add ( newval instanceof long ? ( long ) newval : long . valueof ( newval . tostring ( ) ) ) ; firsttime = _bool ; }	distinct aggregate function which update the distinct set.
private boolean removelegionmember ( string charname , boolean kick , string playername ) { legionmemberex legionmember = getlegionmemberex ( charname ) ; if ( legionmember == null ) { log . error ( _str + charname ) ; return _bool ; } deletelegionmemberfromdb ( legionmember ) ; player player = world . findplayer ( charname ) ; if ( player != null ) { packetsendutility . broadcastpacket ( player , new sm_legion_update_title ( player . getobjectid ( ) , _num , _str , _num ) , _bool ) ; } if ( kick ) { packetsendutility . broadcastpackettolegion ( legionmember . getlegion ( ) , new sm_legion_leave_member ( _num , legionmember . getobjectid ( ) , playername , legionmember . getname ( ) ) ) ; } else { packetsendutility . broadcastpackettolegion ( legionmember . getlegion ( ) , new sm_legion_leave_member ( _num , legionmember . getobjectid ( ) , charname ) ) ; } return _bool ; }	this method will remove a legion member.
synchronized void printbuffer ( ) throws ioexception { int len = sb . length ( ) ; if ( len > _num ) { char [ ] chars = new char [ len ] ; sb . getchars ( _num , len , chars , _num ) ; sb . setlength ( _num ) ; super . write ( chars , _num , chars . length ) ; } }	prints the characters from the buffer and resets it todo : make sure that printbuffer ( ) is called at the end of the stream in case we have some characters there ! ( flush ( ) ? ).
public boolean containsbafbody ( ) { iterator < sootmethod > methodit = methoditerator ( ) ; while ( methodit . hasnext ( ) ) { sootmethod m = methodit . next ( ) ; if ( m . hasactivebody ( ) && m . getactivebody ( ) instanceof soot . baf . bafbody ) { return _bool ; } } return _bool ; }	returns true if some method in this class has an active baf body .
public static string retainallchars ( string str , string retainchars ) { int pos = indexofchars ( str , retainchars ) ; if ( pos == - _num ) { return _str ; } stringbuilder buf = new stringbuilder ( ) ; do { buf . append ( str . charat ( pos ) ) ; pos = indexofchars ( str , retainchars , pos + _num ) ; } while ( pos != - _num ) ; return buf . tostring ( ) ; }	removes all characters from ' str ' that are not in ' retainchars ' . example : retainallchars ( " hello , world ! " , " lo " ) returns " llool ".
public synchronized void deleteleastusedconnection ( ) { final httpconnection connection = ( httpconnection ) freeconnections . removefirst ( ) ; if ( connection != null ) { deleteconnection ( connection ) ; } else if ( log . isdebugenabled ( ) ) { log . debug ( _str ) ; } }	close and delete an old , unused connection to make room for a new one .
private int binarysearch ( t x , int from , int to ) { while ( from <= to ) { int m = ( from + to ) > > > _num ; if ( comp . compare ( x , data [ m ] ) >= _num ) { from = m + _num ; } else { to = m - _num ; } } return from ; }	find the index of the element that is larger than x .
private transitschedule cleanupschedule ( transitschedule newtransitschedule ) { newtransitschedule = transitschedulecleaner . removerouteswithoutdepartures ( newtransitschedule ) ; newtransitschedule = transitschedulecleaner . removeemptylines ( newtransitschedule ) ; newtransitschedule = transitschedulecleaner . removestopsnotused ( newtransitschedule ) ; return newtransitschedule ; }	removes all routes without any departure from the schedule.
protected static boolean match ( object ref , object test ) { if ( ref == null ) { return _bool ; } if ( ref == test ) { return _bool ; } if ( ref instanceof labellist && test instanceof labellist ) { final labellist lref = ( labellist ) ref ; final labellist ltest = ( labellist ) test ; final int s1 = lref . size ( ) , s2 = ltest . size ( ) ; if ( s1 == _num || s2 == _num ) { return _bool ; } for ( int i = _num ; i < s1 ; i ++ ) { string l1 = lref . get ( i ) ; if ( l1 == null ) { continue ; } for ( int j = _num ; j < s2 ; j ++ ) { if ( l1 . equals ( ltest . get ( j ) ) ) { return _bool ; } } } } return ref . equals ( test ) ; }	test whether two relation agree .
public string patch_totext ( list < patch > patches ) { stringbuilder text = new stringbuilder ( ) ; for ( patch apatch : patches ) { text . append ( apatch ) ; } return text . tostring ( ) ; }	take a list of patches and return a textual representation .
void close ( int contextprec , int ownprec ) throws ioexception { if ( ownprec < contextprec ) out . write ( _str ) ; }	leave precedence level . emit a ` ( ' if inner precedence level is less than precedence level we revert to .
private void validatesortsize ( ) { string sortsizestr = carbonproperties . getproperty ( carboncommonconstants . sort_size , carboncommonconstants . sort_size_default_val ) ; try { int sortsize = integer . parseint ( sortsizestr ) ; if ( sortsize < carboncommonconstants . sort_size_min_val ) { logger . info ( _str + sortsizestr + _str + carboncommonconstants . sort_size_default_val ) ; carbonproperties . setproperty ( carboncommonconstants . sort_size , carboncommonconstants . sort_size_default_val ) ; } } catch ( numberformatexception e ) { logger . info ( _str + sortsizestr + _str + carboncommonconstants . sort_size_default_val ) ; carbonproperties . setproperty ( carboncommonconstants . sort_size , carboncommonconstants . sort_size_default_val ) ; } }	this method validates the sort size.
public void finishpainting ( boolean usecache ) { databufferint databuffer = new databufferint ( w0 * h0 ) ; int transparency = nativefinishpainting ( sunwritableraster . stealdata ( databuffer , _num ) , w0 , h0 ) ; sunwritableraster . markdirty ( databuffer ) ; int [ ] bands = band_offsets [ transparency - _num ] ; writableraster raster = raster . createpackedraster ( databuffer , w0 , h0 , w0 , bands , null ) ; colormodel cm = color_models [ transparency - _num ] ; image img = new bufferedimage ( cm , raster , _bool , null ) ; if ( usecache ) { cache . setimage ( getclass ( ) , null , w0 , h0 , cacheargs , img ) ; } graphics . drawimage ( img , x0 , y0 , null ) ; }	called to indicate that painting is finished.
public boolean deletepanel ( ) { if ( ! super . deletepanel ( ) ) { return _bool ; } turnoutlist . clear ( ) ; tracklist . clear ( ) ; pointlist . clear ( ) ; xinglist . clear ( ) ; sliplist . clear ( ) ; turntablelist . clear ( ) ; return _bool ; }	invoked by deletepanel menu item validate user intent before deleting.
@ override default completablefuture < optionaldouble > averagedouble ( final todoublefunction < ? super t > fn ) { return completablefuture . supplyasync ( null , getexec ( ) ) ; }	perform an asynchronous average operation.
public string next ( ) { return next ( any_pattern ) ; }	returns the next token.
public xerceshtmldocumentbuilderfactory ( documentbuildersetting [ ] settings ) throws domtestincompatibleexception { super ( settings ) ; try { classloader classloader = classloader . getsystemclassloader ( ) ; class htmlbuilderclass = classloader . loadclass ( _str ) ; htmlbuilderconstructor = htmlbuilderclass . getconstructor ( no_classes ) ; gethtmldocumentmethod = htmlbuilderclass . getmethod ( _str , no_classes ) ; class htmldomimpl = classloader . loadclass ( _str ) ; method method = htmldomimpl . getmethod ( _str , no_classes ) ; domimpl = ( domimplementation ) method . invoke ( null , no_objects ) ; class saxfactoryclass = classloader . loadclass ( _str ) ; factory = ( saxparserfactory ) saxfactoryclass . newinstance ( ) ; } catch ( invocationtargetexception ex ) { throw new domtestincompatibleexception ( ex . gettargetexception ( ) , null ) ; } catch ( exception ex ) { throw new domtestincompatibleexception ( ex , null ) ; } if ( settings != null ) { for ( int i = _num ; i < settings . length ; i ++ ) { } } try { factory . newsaxparser ( ) ; } catch ( parserconfigurationexception ex ) { throw new domtestincompatibleexception ( ex , null ) ; } catch ( saxexception ex ) { throw new domtestincompatibleexception ( ex , null ) ; } }	creates a implementation of domtestdocumentbuilderfactory using org.
@ override public final string tostring ( ) { stringbuilder cab = new stringbuilder ( _num + gethopcount ( ) * _num ) ; cab . append ( _str ) ; if ( this . localaddress != null ) { cab . append ( this . localaddress ) ; cab . append ( _str ) ; } cab . append ( _str ) ; if ( this . tunnelled == tunneltype . tunnelled ) cab . append ( _str ) ; if ( this . layered == layertype . layered ) cab . append ( _str ) ; if ( this . secure ) cab . append ( _str ) ; cab . append ( _str ) ; if ( this . proxychain != null ) { for ( httphost aproxychain : this . proxychain ) { cab . append ( aproxychain ) ; cab . append ( _str ) ; } } cab . append ( this . targethost ) ; cab . append ( _str ) ; return cab . tostring ( ) ; }	obtains a description of this route .
public macro ( file file ) throws eofexception , filenotfoundexception , ioexception { documentbuilderfactory dbf = documentbuilderfactory . newinstance ( ) ; documentbuilder db = null ; document doc = null ; try { db = dbf . newdocumentbuilder ( ) ; inputsource is = new inputsource ( new unicodereader ( new fileinputstream ( file ) , file_encoding ) ) ; is . setencoding ( file_encoding ) ; doc = db . parse ( is ) ; } catch ( exception e ) { e . printstacktrace ( ) ; string desc = e . getmessage ( ) ; if ( desc == null ) { desc = e . tostring ( ) ; } throw new ioexception ( _str + desc ) ; } macrorecords = new arraylist ( ) ; boolean parsedok = initializefromxmlfile ( doc . getdocumentelement ( ) ) ; if ( parsedok == _bool ) { name = null ; macrorecords . clear ( ) ; macrorecords = null ; throw new ioexception ( _str ) ; } }	loads a macro from a file on disk .
public static void deleteesinput ( ) { string espirindex = systemconfiguration . getproperty ( distributedtestdriver . es_input_nodes_property ) + _str + systemconfiguration . getproperty ( distributedtestdriver . es_input_port_property ) + _str + systemconfiguration . getproperty ( distributedtestdriver . es_input_index_property ) ; logger . info ( _str + espirindex ) ; processbuilder pdeletepir = new processbuilder ( _str , _str , espirindex ) ; try { testutils . executecommand ( pdeletepir ) ; logger . info ( _str ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }	delete the elasticsearch indices that was used for functional testing.
private boolean add ( int part ) { if ( ! parts . contains ( part ) ) { parts . add ( part ) ; return _bool ; } return _bool ; }	adds partition to partition set .
private void terminateandwaitfsyncservice ( ) throws exception { if ( fsyncservice . isterminated ( ) ) return ; fsyncservice . shutdown ( ) ; fsyncservice . awaittermination ( _num , timeunit . seconds ) ; exception fsyncexceptioncopy = fsyncexception ; if ( fsyncexceptioncopy != null ) throw fsyncexceptioncopy ; }	terminate the fsync service and wait for all the tasks to complete . if it is already terminated.
private location findfarthestlocation ( location location , direction direction ) { location farthest ; do { farthest = location ; location = farthest . offset ( direction ) ; } while ( gridoperator . isvalidlocation ( location ) && gamegrid . get ( location ) == null ) ; return farthest ; }	searchs for the farthest empty location where the current tile could go.
public static int computeminimagesamplesize ( imagesize srcsize ) { int srcwidth = srcsize . getwidth ( ) ; int srcheight = srcsize . getheight ( ) ; int targetwidth = maxbitmapsize . getwidth ( ) ; int targetheight = maxbitmapsize . getheight ( ) ; int widthscale = ( int ) math . ceil ( ( float ) srcwidth / targetwidth ) ; int heightscale = ( int ) math . ceil ( ( float ) srcheight / targetheight ) ; return math . max ( widthscale , heightscale ) ; }	computes minimal sample size for downscaling image so result image size won ' t exceed max acceptable opengl texture size.
private jsplitpane createmainsplitpane ( ) { final jsplitpane mainsplitpane = new jsplitpane ( ) ; mainsplitpane . setonetouchexpandable ( _bool ) ; mainsplitpane . setdividerlocation ( _num ) ; mainsplitpane . setresizeweight ( _num ) ; mainsplitpane . setorientation ( jsplitpane . horizontal_split ) ; m_componentpanel . setbackground ( color . white ) ; mainsplitpane . setleftcomponent ( createprojecttreepanel ( ) ) ; mainsplitpane . setrightcomponent ( m_componentpanel ) ; mainsplitpane . setborder ( new lineborder ( color . gray ) ) ; return mainsplitpane ; }	creates the main split pane.
private digicorechain cleanchain ( digicorechain chain ) { return chain ; }	todo currently returns exactly the same chain.
private boolean checksetup ( ) { this . txmgr = transactionmanagerimp . gettransactionmanager ( ) ; if ( this . txmgr == null ) { try { hashtable < string , string > env = new hashtable < string , string > ( ) ; env . put ( context . initial_context_factory , this . initialcontextfactory ) ; env . put ( context . provider_url , this . providerurl ) ; context ctx = new initialcontext ( env ) ; this . txmgrserver = ( usertransactionserver ) portableremoteobject . narrow ( ctx . lookup ( this . usertransactionserverlookupname ) , usertransactionserver . class ) ; } catch ( exception e ) { e . printstacktrace ( ) ; throw new runtimeexception ( getnotfoundmessage ( ) ) ; } if ( this . txmgrserver == null ) throw new runtimeexception ( getnotfoundmessage ( ) ) ; } return this . txmgr != null ; }	referenceable mechanism requires later setup of txmgr_ , otherwise binding into jndi already requires that tm is running .
public static fsdirectory newfsdirectory ( class < ? extends fsdirectory > clazz , path path ) throws reflectiveoperationexception { return newfsdirectory ( clazz , path , fslockfactory . getdefault ( ) ) ; }	creates a new specific fsdirectory instance.
private static element addelement ( document doc , node parent , string tagname , string attr1 , string val1 , string attr2 , string val2 ) { element elem = doc . createelement ( tagname ) ; if ( attr1 != null ) elem . setattribute ( attr1 , val1 ) ; if ( attr2 != null ) elem . setattribute ( attr2 , val2 ) ; parent . appendchild ( elem ) ; return elem ; }	add element to xml document .
public static string stream2string ( inputstream is , int maxlength ) throws ioexception { byte [ ] buffer = new byte [ _num ] ; stringwriter sw = new stringwriter ( ) ; int totalread = _num ; int read = _num ; do { sw . write ( new string ( buffer , _num , read ) ) ; totalread += read ; read = is . read ( buffer , _num , buffer . length ) ; } while ( ( ( - _num == maxlength ) || ( totalread < maxlength ) ) && ( read != - _num ) ) ; return sw . tostring ( ) ; }	read a string of up to maxlength bytes from an inputstream.
private static couple < string > splitnameofremotebranch ( string branchname ) { int firstslash = branchname . indexof ( _str ) ; string remotename = firstslash > - _num ? branchname . substring ( _num , firstslash ) : branchname ; string remotebranchname = branchname . substring ( firstslash + _num ) ; return couple . of ( remotename , remotebranchname ) ; }	returns the remote and the " local " name of a remote branch.
public static outputstream encrypt ( outputstream unencryptedoutputstream , char [ ] password ) throws encryptionexception , ioexception { outputstream encryptedoutputstream = null ; pbekeyspec pbekeyspec = new pbekeyspec ( password ) ; pbeparameterspec pbeparameterspec = new pbeparameterspec ( salt , iteration_count ) ; try { secretkeyfactory secretkeyfactory = secretkeyfactory . getinstance ( encryption_algorithm , cryptoprovider ) ; secretkey pbekey = secretkeyfactory . generatesecret ( pbekeyspec ) ; cipher cipher = cipher . getinstance ( encryption_algorithm , cryptoprovider ) ; cipher . init ( cipher . encrypt_mode , pbekey , pbeparameterspec ) ; encryptedoutputstream = new cipheroutputstream ( unencryptedoutputstream , cipher ) ; } catch ( generalsecurityexception e ) { throw new encryptionexception ( _str , e ) ; } return encryptedoutputstream ; }	encrypts data received from the given outputstream using the aes algorithm .
public static string rightpad ( string original , int length , char padchar ) { if ( original . length ( ) >= length ) { return original ; } return original + stringofchar ( padchar , length - original . length ( ) ) ; }	pads the string with the given character until it has the given length.
protected void reloadswipestateinview ( view frontview , int position ) { if ( ! opened . get ( position ) ) { viewcompat . settranslationx ( frontview , _num ) ; } else { if ( openedright . get ( position ) ) { viewcompat . settranslationx ( frontview , swipelistview . getwidth ( ) ) ; } else { viewcompat . settranslationx ( frontview , - swipelistview . getwidth ( ) ) ; } } }	reset the state of front view when the it ' s recycled by listview.
void reset ( ) { system . arraycopy ( iv , _num , k , _num , blocksize ) ; }	resets the iv to its original value.
public matrix3 multiplybyverticalflip ( ) { double [ ] m = this . m ; m [ _num ] += m [ _num ] ; m [ _num ] += m [ _num ] ; m [ _num ] += m [ _num ] ; m [ _num ] = - m [ _num ] ; m [ _num ] = - m [ _num ] ; m [ _num ] = - m [ _num ] ; return this ; }	multiplies this matrix by a matrix that flips and shifts the y - axis.
public void shutdown ( ) throws datasourceexception { if ( createdsessionfactory ) { if ( sessionfactory != null && ! sessionfactory . isclosed ( ) ) { try { sessionfactory . close ( ) ; } finally { sessionfactory = null ; } } } }	shuts down the data source.
private string stringifyip ( byte [ ] ip ) { string temp = _str ; for ( int i = _num ; i < ip . length / _num ; i ++ ) { temp += integer . tostring ( ip [ i ] & _num ) + _str ; } temp = temp . substring ( _num , temp . length ( ) - _num ) ; temp += _str ; for ( int i = ip . length / _num ; i < ip . length ; i ++ ) { temp += integer . tostring ( ip [ i ] & _num ) + _str ; } temp = temp . substring ( _num , temp . length ( ) - _num ) ; return temp ; }	stringifies an ipv4 or v6 address with subnet mask .
public copenfunctionaction ( final cgraphwindow parent , final iviewcontainer container , final inavifunction function ) { super ( string . format ( _str , function . getname ( ) ) ) ; preconditions . checknotnull ( parent , _str ) ; preconditions . checknotnull ( container , _str ) ; m_parent = parent ; m_container = container ; m_function = function ; }	creates a new action object .
public static byte [ ] hexstringtobytes ( string hexstring ) { if ( hexstring == null || hexstring . equals ( _str ) ) { return null ; } hexstring = hexstring . touppercase ( ) ; int length = hexstring . length ( ) / _num ; char [ ] hexchars = hexstring . tochararray ( ) ; byte [ ] d = new byte [ length ] ; for ( int i = _num ; i < length ; i ++ ) { int pos = i * _num ; d [ i ] = ( byte ) ( chartobyte ( hexchars [ pos ] ) << _num | chartobyte ( hexchars [ pos + _num ] ) ) ; } return d ; }	convert hex string to byte [ ].
public void writestring ( final string s ) { final byte [ ] bytes = s . getbytes ( ) ; final int len = bytes . length ; writeint ( len ) ; system . arraycopy ( bytes , _num , buffer , offset , len ) ; offset += len ; pad ( ) ; }	puts a string into the buffer by first writing the size of the string as an int , followed by the bytes of the string , padded if necessary to a multiple of 4 .
private static permissioncollection createallpermissions ( ) { permissions permissions = new permissions ( ) ; permissions . add ( new allpermission ( ) ) ; return permissions ; }	create permission for our trusted code . no restrictions are applied.
private void mergenetworks ( network tzone , network szone ) { list < string > addedendpoints = new arraylist < string > ( szone . retrieveendpoints ( ) ) ; stringset newendpoints = szone . retrieveendpoints ( ) ; for ( string endpoint : tzone . retrieveendpoints ( ) ) { if ( newendpoints . contains ( endpoint ) ) { addedendpoints . remove ( endpoint ) ; } } if ( ! addedendpoints . isempty ( ) ) { tzone . addendpoints ( addedendpoints , _bool ) ; } tzone . setnativeguid ( szone . getnativeguid ( ) ) ; }	update one network with information from another.
static public void println ( string msg ) { println ( msg , clloglevel . normal ) ; }	temporary utility method to keep current println behavior .
private static bytestring readchunk ( inputstream in , final int chunksize ) throws ioexception { final byte [ ] buf = new byte [ chunksize ] ; int bytesread = _num ; while ( bytesread < chunksize ) { final int count = in . read ( buf , bytesread , chunksize - bytesread ) ; if ( count == - _num ) { break ; } bytesread += count ; } if ( bytesread == _num ) { return null ; } else { return bytestring . copyfrom ( buf , _num , bytesread ) ; } }	blocks until a chunk of the given size can be made from the stream , or eof is reached.
private list < facetresult > sumassociations ( ) throws ioexception { directoryreader indexreader = directoryreader . open ( indexdir ) ; indexsearcher searcher = new indexsearcher ( indexreader ) ; taxonomyreader taxoreader = new directorytaxonomyreader ( taxodir ) ; facetscollector fc = new facetscollector ( ) ; facetscollector . search ( searcher , new matchalldocsquery ( ) , _num , fc ) ; facets tags = new taxonomyfacetsumintassociations ( _str , taxoreader , config , fc ) ; facets genre = new taxonomyfacetsumfloatassociations ( _str , taxoreader , config , fc ) ; list < facetresult > results = new arraylist < > ( ) ; results . add ( tags . gettopchildren ( _num , _str ) ) ; results . add ( genre . gettopchildren ( _num , _str ) ) ; indexreader . close ( ) ; taxoreader . close ( ) ; return results ; }	user runs a query and aggregates facets by summing their association values .
public reversegeocode ( inputstream placenames , boolean majoronly ) throws ioexception { createkdtree ( placenames , majoronly ) ; }	parse the raw text geonames file .
protected string patchname ( string qname ) { final int lastcolon = qname . lastindexof ( _str ) ; if ( lastcolon > _num ) { final int firstcolon = qname . indexof ( _str ) ; final string prefix = qname . substring ( _num , firstcolon ) ; final string localname = qname . substring ( lastcolon + _num ) ; final string uri = m_prefixmap . lookupnamespace ( prefix ) ; if ( uri != null && uri . length ( ) == _num ) { return localname ; } else if ( firstcolon != lastcolon ) { return prefix + _str + localname ; } } return qname ; }	if at runtime , when the qname of the attribute is known , another prefix is specified for the attribute , then we can patch or hack the name with this method.
public static string fromtag ( listtag < tag > tag ) { stringbuilder builder = new stringbuilder ( ) ; builder . append ( array_start ) ; boolean start = _bool ; for ( tag value : tag . getvalue ( ) ) { if ( start ) { start = _bool ; } else { builder . append ( element_seperator ) ; } builder . append ( fromgenerictag ( value ) ) ; } builder . append ( array_end ) ; return builder . tostring ( ) ; }	creates a mojangson string from the given list tag .
private xmlelement2 createanotherelement ( ) { return new xmlelement2 ( this . entities , this . ignorewhitespace , _bool , this . ignorecase ) ; }	creates a new similar xml element.
public synchronized void reset ( ) { labels . clear ( ) ; labels . put ( sensisionconstants . sensision_label_topic , this . topic ) ; labels . put ( sensisionconstants . sensision_label_groupid , this . groupid ) ; for ( int i = _num ; i < this . counters . length ; i ++ ) { if ( null == this . counters [ i ] ) { continue ; } labels . put ( sensisionconstants . sensision_label_partition , integer . tostring ( i ) ) ; sensision . clear ( sensisionconstants . sensision_class_warp_kafka_consumer_offset , labels ) ; this . counters [ i ] = null ; } }	remove per partition counters and associated sensision metrics.
public vector rotateinradian ( double radians ) { final double length = length ( ) ; double angle = angleinradian ( ) ; angle += radians ; final vector result = new vector ( math . cos ( angle ) , math . sin ( angle ) ) ; return result . multiply ( length ) ; }	return a new instance of vector rotated from the given number of radians .
public void connectionlost ( java . lang . throwable cause ) { int rc = - _num ; led . setamber ( ) ; led . setflash ( ) ; settitletext ( _str ) ; synchronized ( this ) { writelogln ( _str + mqtt . getserveruri ( ) ) ; } try { while ( ( rc == - _num ) && connected ) { try { synchronized ( connlostwait ) { connlostwait . wait ( _num ) ; } } catch ( interruptedexception iex ) { } synchronized ( this ) { if ( connected ) { writelog ( _str ) ; try { connect ( mqtt . getserveruri ( ) , optionscomp . ispersistenceselected ( ) ) ; rc = _num ; } catch ( mqttexception mqte ) { rc = - _num ; } if ( rc == - _num ) { writelogln ( _str ) ; } else { writelogln ( _str ) ; } } } } settitletext ( _str ) ; } catch ( exception ex ) { settitletext ( _str ) ; ex . printstacktrace ( ) ; disconnect ( ) ; } finally { if ( led . isflashing ( ) ) { led . setflash ( ) ; } } if ( connected ) { led . setgreen ( ) ; setconnected ( _bool ) ; } else { led . setred ( ) ; setconnected ( _bool ) ; } }	the method is part of the mqttsimplecallback interface < br > in the event of the mqtt connection being broken the led is set to colour amber and made to flash.
public string headerout ( string name ) { arraylist < string > keys = _headerkeysout ; int headersize = keys . size ( ) ; for ( int i = _num ; i < headersize ; i ++ ) { string oldkey = keys . get ( i ) ; if ( oldkey . equalsignorecase ( name ) ) { return ( string ) _headervaluesout . get ( i ) ; } } if ( name . equalsignorecase ( _str ) ) { return _contentlengthout >= _num ? string . valueof ( _contentlengthout ) : null ; } if ( name . equalsignorecase ( _str ) ) { return _contenttypeout ; } return null ; }	returns the value of an already set output header .
private static map < string , set < string > > parsesparsefields ( multivaluedmap < string , string > queryparams ) { map < string , set < string > > result = new hashmap < > ( ) ; for ( map . entry < string , list < string > > kv : queryparams . entryset ( ) ) { string key = kv . getkey ( ) ; if ( key . startswith ( _str ) && key . endswith ( _str ) ) { string type = key . substring ( _num , key . length ( ) - _num ) ; linkedhashset < string > filters = new linkedhashset < > ( ) ; for ( string filterparams : kv . getvalue ( ) ) { collections . addall ( filters , filterparams . split ( _str ) ) ; } if ( ! filters . isempty ( ) ) { result . put ( type , filters ) ; } } } return result ; }	parses queryparams and produces sparsefields map .
public element signwithwsssamltokenprofile ( document doc , java . security . cert . certificate cert , string assertionid , string algorithm , list ids ) throws xmlsignatureexception { return signwithwsssamltokenprofile ( doc , cert , assertionid , algorithm , ids , soapbindingconstants . wsf_10_version ) ; }	sign part of the xml document referered by the supplied a list of id attributes of nodes.
@ override public void statechanged ( changeevent e ) { updateframetitle ( ) ; updatemenu ( ) ; if ( e . getsource ( ) instanceof jcomponent ) { settabtitle ( ( jcomponent ) e . getsource ( ) ) ; } }	invoked when the target of the listener has changed its state .
@ override public void addurl ( url url , boolean isscanned ) { if ( containsurl ( url ) ) { return ; } super . addurl ( url , isscanned ) ; if ( isscanned ) _pendingscanroots . add ( new scanroot ( url , null ) ) ; }	adds the url to the urlclassloader .
public void add ( final int start , final int end , final byte status ) { final int s = start - mstart ; if ( s < minterval . length && end > mstart ) { arrays . fill ( minterval , math . max ( s , _num ) , math . min ( end - mstart , minterval . length ) , status ) ; } }	add points to the interval.
public void reset ( ) { alpha = initalpha ; neighborhoodsize = initneighborhoodsize ; }	resets som network to initial values .
private void reload ( ) { document doc = textpane . getdocument ( ) ; doc . putproperty ( document . streamdescriptionproperty , null ) ; reference = currentreference ; loadpage ( currentpage ) ; }	reloads the current page and jumps to the same position.
private boolean isstatic ( field field ) { int modifier = field . getmodifiers ( ) ; if ( modifier . isstatic ( modifier ) ) { return _bool ; } return _bool ; }	this is used to determine if a field is static.
public int outstandingrequests ( ) { return outstanding . get ( ) ; }	get the current number of outstanding ( batch ) requests to google pub / sub .
final public static string tostring ( final byte [ ] key , final int off , final int len ) { if ( key == null ) return null ; final stringbuilder sb = new stringbuilder ( len * _num + _num ) ; sb . append ( _str ) ; for ( int i = off ; i < off + len ; i ++ ) { if ( i > _num ) sb . append ( _str ) ; sb . append ( integer . tostring ( key [ i ] & _num ) ) ; } sb . append ( _str ) ; return sb . tostring ( ) ; }	formats a key as a series of comma delimited unsigned bytes .
public void init ( string componentname ) throws logexception { accesslogger = logger . getlogger ( componentname + _str ) ; errorlogger = logger . getlogger ( componentname + _str ) ; }	initializes the logging for the component .
private view fillleft ( int pos , int nextright ) { if ( debug ) log . i ( tag , _str + pos + _str + nextright + m_first_position + mfirstposition ) ; view selectedview = null ; final int end = mlistpadding . left ; while ( nextright > end && pos >= _num ) { view temp = makecolumn ( pos , nextright , _bool ) ; if ( temp != null ) { selectedview = temp ; } nextright = mreferenceview . getleft ( ) - mhorizontalspacing ; mfirstposition = pos ; pos -= mnumrows ; } if ( mstackfrombottom ) { mfirstposition = math . max ( _num , pos + _num ) ; } return selectedview ; }	fills the list from pos to the left of the list view .
public void removedefaultvalue ( string value ) throws smsexception , ssoexception { set defaultvalues = getdefaultvalues ( ) ; if ( defaultvalues != collections . empty_set ) { defaultvalues . remove ( value ) ; updatedefaultvalues ( defaultvalues ) ; } }	removes the given value from the set of default values .
public void testputcauseeviction ( ) { list < string > log = new arraylist < string > ( ) ; lrucache < string , string > cache = newremovallogcache ( log ) ; cache . put ( _str , _str ) ; cache . put ( _str , _str ) ; cache . put ( _str , _str ) ; cache . put ( _str , _str ) ; assertequals ( arrays . aslist ( _str ) , log ) ; assertsnapshot ( cache , _str , _str , _str , _str , _str , _str ) ; }	replacing the value for a key doesn ' t cause an eviction but it does bring the replaced entry to the front of the queue .
protected signature mergesignatures ( signature first , signature second , int numbins ) { int d2 = - _num ; for ( int i = _num ; i < second . spec . length ; i += _num ) { if ( second . spec [ i ] >= _num ) { assert ( d2 == - _num ) : _str ; d2 = i ; } } assert ( d2 >= _num ) : _str ; if ( first . spec [ d2 ] >= _num ) { return null ; } final modifiabledbids intersection = dbidutil . intersection ( first . ids , second . ids ) ; final int support = intersection . size ( ) ; double width = ( second . spec [ d2 + _num ] - second . spec [ d2 ] + _num ) / ( double ) numbins ; double expect = first . ids . size ( ) * width ; if ( support <= expect || support < minclustersize ) { return null ; } final double test = poissondistribution . rawprobability ( support , expect ) ; if ( ( poissonthreshold ) <= test ) { return null ; } int [ ] spec = first . spec . clone ( ) ; spec [ d2 ] = second . spec [ d2 ] ; spec [ d2 + _num ] = second . spec [ d2 ] ; final signature newsig = new signature ( spec , intersection ) ; if ( log . isdebugging ( ) ) { log . debug ( newsig . tostring ( ) ) ; } return newsig ; }	generates a merged signature of this and another one , where the other signature must be a 1 - signature .
@ override public int hashcode ( ) { return super . hashcode ( ) ; }	returns a hash code for this object .
public ignitedeploymentexception ( throwable cause ) { this ( cause . getmessage ( ) , cause ) ; }	creates new exception with given throwable as a nested cause and source of error message .
public synchronized boolean enter ( cnatreeelement obj ) throws transactionabortedexception { if ( aborted ) { throw new transactionabortedexception ( ) ; } visited . add ( obj ) ; if ( this . initiator != null ) { return _bool ; } this . initiator = obj ; aborted = _bool ; return _bool ; }	the given objects enters the transaction .
public options addoption ( option opt ) { string key = opt . getkey ( ) ; if ( opt . haslongopt ( ) ) { longopts . put ( opt . getlongopt ( ) , opt ) ; } if ( opt . isrequired ( ) ) { if ( requiredopts . contains ( key ) ) { requiredopts . remove ( requiredopts . indexof ( key ) ) ; } requiredopts . add ( key ) ; } shortopts . put ( key , opt ) ; return this ; }	adds an option instance.
private void pauseforclienttojoin ( ) { wait . pause ( _num ) ; }	the joined event fires when the first client handshake is processed.
public void propertychange ( propertychangeevent pce ) { if ( pce . getpropertyname ( ) == mapbean . backgroundproperty && backgroundslave ) { map . setbckgrnd ( ( paint ) pce . getnewvalue ( ) ) ; } }	propertychangelistener method , to listen for the source map ' s background changes.
public transitionbuilder addframe ( int imageresource ) { mframes . add ( imageresource ) ; return this ; }	add a frame to the transition animation .
public class < ? > [ ] scanforclasses ( string location , class < ? > implementedinterface ) throws exception { log . debug ( _str + location + _str + implementedinterface . getname ( ) + _str ) ; list < class < ? > > classes = new arraylist < class < ? > > ( ) ; set < string > resourcenames = findresourcenames ( location , _str , _str ) ; for ( string resourcename : resourcenames ) { string classname = toclassname ( resourcename ) ; class < ? > clazz = classloader . loadclass ( classname ) ; if ( modifier . isabstract ( clazz . getmodifiers ( ) ) || clazz . isenum ( ) || clazz . isanonymousclass ( ) ) { log . debug ( _str + classname ) ; continue ; } if ( ! implementedinterface . isassignablefrom ( clazz ) ) { continue ; } try { classutils . instantiate ( classname , classloader ) ; } catch ( exception e ) { throw new cassandramigrationexception ( _str + classname , e ) ; } classes . add ( clazz ) ; log . debug ( _str + classname ) ; } return classes . toarray ( new class < ? > [ classes . size ( ) ] ) ; }	scans the classpath for concrete classes under the specified package implementing this interface.
public string nextcdata ( ) throws jsonexception { char c ; int i ; stringbuffer sb = new stringbuffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( end ( ) ) { throw syntaxerror ( _str ) ; } sb . append ( c ) ; i = sb . length ( ) - _num ; if ( i >= _num && sb . charat ( i ) == _str && sb . charat ( i + _num ) == _str && sb . charat ( i + _num ) == _str ) { sb . setlength ( i ) ; return sb . tostring ( ) ; } } }	get the text in the cdata block .
private static boolean needsskylightupdate ( fastcubeblockaccess access , mutableblockpos pos ) { if ( access . getblocklightopacity ( pos ) >= _num ) { return _bool ; } int computedlight = access . computelightvalue ( pos ) ; for ( enumfacing facing : enumfacing . values ( ) ) { pos . move ( facing ) ; int currentlight = access . getlightfor ( enumskyblock . sky , pos ) ; int currentopacity = math . max ( _num , access . getblocklightopacity ( pos ) ) ; pos . move ( facing . getopposite ( ) ) ; if ( computedlight == currentlight - currentopacity ) { return _bool ; } } return _bool ; }	determines if the block at the given position requires a skylight update .
public static void expand ( rectangle2d r , double amount ) { r . setrect ( r . getx ( ) - amount , r . gety ( ) - amount , r . getwidth ( ) + _num * amount , r . getheight ( ) + _num * amount ) ; }	expand a rectangle by the given amount .
static void stringtopacket ( string s , datagrampacket packet ) { byte [ ] bytes = s . getbytes ( ) ; system . arraycopy ( bytes , _num , packet . getdata ( ) , _num , bytes . length ) ; packet . setlength ( bytes . length ) ; }	converts a given string into a datagram packet .
@ override public string tostring ( ) { stringbuffer buffer = new stringbuffer ( _str ) ; buffer . append ( _str ) ; buffer . append ( gridx ) ; buffer . append ( _str ) ; buffer . append ( gridy ) ; buffer . append ( _str ) ; buffer . append ( gridwidth ) ; buffer . append ( _str ) ; buffer . append ( gridheight ) ; buffer . append ( _str ) ; buffer . append ( halign ) ; buffer . append ( _str ) ; buffer . append ( valign ) ; if ( ! empty_insets . equals ( insets ) ) { buffer . append ( _str ) ; buffer . append ( insets ) ; } buffer . append ( _str ) ; buffer . append ( honorsvisibility ) ; buffer . append ( _str ) ; return buffer . tostring ( ) ; }	constructs and returns a string representation of this constraints object .
public boolean isinitialized ( ) { return _initialized ; }	indicates if the bean was initialized at least once.
public boolean removeshutdownhook ( thread hook ) { if ( hook == null ) { throw new nullpointerexception ( _str ) ; } if ( shuttingdown ) { throw new illegalstateexception ( _str ) ; } synchronized ( shutdownhooks ) { return shutdownhooks . remove ( hook ) ; } }	unregisters a previously registered vm shutdown hook .
private resultpointsandtransitions transitionsbetween ( resultpoint from , resultpoint to ) { int fromx = ( int ) from . getx ( ) ; int fromy = ( int ) from . gety ( ) ; int tox = ( int ) to . getx ( ) ; int toy = ( int ) to . gety ( ) ; boolean steep = math . abs ( toy - fromy ) > math . abs ( tox - fromx ) ; if ( steep ) { int temp = fromx ; fromx = fromy ; fromy = temp ; temp = tox ; tox = toy ; toy = temp ; } int dx = math . abs ( tox - fromx ) ; int dy = math . abs ( toy - fromy ) ; int error = - dx / _num ; int ystep = fromy < toy ? _num : - _num ; int xstep = fromx < tox ? _num : - _num ; int transitions = _num ; boolean inblack = image . get ( steep ? fromy : fromx , steep ? fromx : fromy ) ; for ( int x = fromx , y = fromy ; x != tox ; x += xstep ) { boolean isblack = image . get ( steep ? y : x , steep ? x : y ) ; if ( isblack != inblack ) { transitions ++ ; inblack = isblack ; } error += dy ; if ( error > _num ) { if ( y == toy ) { break ; } y += ystep ; error -= dx ; } } return new resultpointsandtransitions ( from , to , transitions ) ; }	counts the number of black / white transitions between two points , using something like bresenham ' s algorithm .
public string tostring ( ) { return double . tostring ( get ( ) ) ; }	returns the string representation of the current value .
boolean checkcamerasize ( cameraoptions cameraid ) { boolean sizeavailable = _bool ; camera camera = null ; method method = getcameraopenmethod ( ) ; if ( method != null ) { try { camera = ( camera ) method . invoke ( camera , new object [ ] { cameraid . getvalue ( ) } ) ; } catch ( exception e ) { camera = camera . open ( ) ; } } else { camera = camera . open ( ) ; } if ( camera == null ) { return _bool ; } parameters param = camera . getparameters ( ) ; list < camera . size > sizes = param . getsupportedpreviewsizes ( ) ; for ( camera . size size : sizes ) { if ( ( size . width == h264config . qvga_width && size . height == h264config . qvga_height ) || ( size . width == h264config . cif_width && size . height == h264config . cif_height ) || ( size . width == h264config . vga_width && size . height == h264config . vga_height ) ) { sizeavailable = _bool ; break ; } } camera . release ( ) ; return sizeavailable ; }	check if good camera sizes are available for encoder.
public void append ( final string s ) { if ( first ) { first = _bool ; } else { builder . append ( space ) ; } builder . append ( s ) ; }	append string separated by space .
public static bytearrayoutputstream encode ( string plaintext ) throws ioexception , messagingexception { bytearrayoutputstream out = new bytearrayoutputstream ( ) ; byte [ ] in = plaintext . getbytes ( ) ; bytearrayoutputstream instream = new bytearrayoutputstream ( ) ; instream . write ( in , _num , in . length ) ; if ( ( in . length % _num ) == _num ) { instream . write ( _num ) ; instream . write ( _num ) ; } else if ( ( in . length % _num ) == _num ) { instream . write ( _num ) ; } instream . writeto ( mimeutility . encode ( out , _str ) ) ; return out ; }	encode string to base64.
public lookuplisttable lookuplist ( ) { if ( lookuplisttable . get ( ) == null ) { lookuplisttable . compareandset ( null , gsub . createlookuplist ( ) ) ; } return lookuplisttable . get ( ) ; }	return information about the lookup tables in this gsub table .
public long sum ( ) { return deltasum . get ( ) ; }	get aggregate summation of time - deltas , in nanoseconds .
private static boolean iswordboundary ( charsequence singlechar , string wordseparators ) { return textutils . isempty ( singlechar ) || wordseparators . contains ( singlechar ) ; }	takes a character sequence with a single character and checks if the character occurs in a list of word separators or is empty .
public void executeblocking ( string desc , blockingconsumer < mongoclient > operation ) throws interruptedexception { while ( _bool ) { mongoclient primary = primaryconnectionsupplier . get ( ) ; try { operation . accept ( primary ) ; return ; } catch ( throwable t ) { errorhandler . accept ( desc , t ) ; } } }	execute the supplied operation using the primary , blocking until a primary is available.
public void write ( char [ ] cbuf ) throws java . io . ioexception { write ( cbuf , _num , cbuf . length ) ; }	write an array of characters .
protected tableviewer createtable ( composite parent , int span ) { table table = new table ( parent , swt . h_scroll | swt . v_scroll | swt . border | swt . single | swt . full_selection ) ; griddata data = new griddata ( griddata . fill_both | griddata . grab_horizontal ) ; data . horizontalspan = span ; table . setlayoutdata ( data ) ; tablelayout layout = new tablelayout ( ) ; layout . addcolumndata ( new columnweightdata ( _num , _bool ) ) ; table . setlayout ( layout ) ; tablecolumn col = new tablecolumn ( table , swt . none ) ; col . setresizable ( _bool ) ; return new tableviewer ( table ) ; }	creates the table for the repositories.
public string typeasstring ( ) { string typestr = _str ; string subtypestr = _str ; switch ( this . type ) { case etype_control : typestr = _str ; switch ( this . subtype ) { case estype_header : subtypestr = _str ; break ; case estype_footer : subtypestr = _str ; break ; } break ; case etype_transactions : typestr = _str ; switch ( this . subtype ) { case estype_tran_start : subtypestr = _str ; break ; case estype_tran_commit : subtypestr = _str ; break ; case estype_tran_rollback : subtypestr = _str ; break ; case estype_tran_rollback_to_savepoint : subtypestr = _str ; break ; case estype_tran_audit : subtypestr = _str ; break ; } break ; case etype_lcr_data : typestr = _str ; switch ( this . subtype ) { case estype_lcr_insert : subtypestr = _str ; break ; case estype_lcr_delete : subtypestr = _str ; break ; case estype_lcr_update : subtypestr = _str ; break ; case estype_lcr_lob_write : subtypestr = _str ; break ; case estype_lcr_lob_trim : subtypestr = _str ; break ; case estype_lcr_lob_erase : subtypestr = _str ; break ; case estype_lcr_ddl : subtypestr = _str ; break ; } break ; case etype_lcr_plog : typestr = _str ; switch ( this . subtype ) { case estype_lcr_plog_ifile : subtypestr = _str ; break ; case estype_lcr_plog_ifile_stats : subtypestr = _str ; break ; } break ; default : typestr = _str + this . type + _str ; subtypestr = _str + this . subtype ; } return typestr + subtypestr ; }	human readable text description of type and subtype.
public void lineto ( float x , float y ) { mpoints . add ( pathpoint . lineto ( x , y ) ) ; }	create a straight line from the current path point to the new one specified by x and y .
protected boolean [ ] canhandlemissing ( boolean nominalpredictor , boolean numericpredictor , boolean stringpredictor , boolean datepredictor , boolean relationalpredictor , boolean multiinstance , int classtype , boolean predictormissing , boolean classmissing , int missinglevel ) { if ( missinglevel == _num ) { print ( _str ) ; } print ( _str ) ; if ( predictormissing ) { print ( _str ) ; if ( classmissing ) { print ( _str ) ; } } if ( classmissing ) { print ( _str ) ; } print ( _str ) ; printattributesummary ( nominalpredictor , numericpredictor , stringpredictor , datepredictor , relationalpredictor , multiinstance , classtype ) ; print ( _str ) ; arraylist < string > accepts = new arraylist < string > ( ) ; accepts . add ( _str ) ; accepts . add ( _str ) ; accepts . add ( _str ) ; int numtrain = getnuminstances ( ) , numtest = getnuminstances ( ) , numclasses = _num ; return runbasictest ( nominalpredictor , numericpredictor , stringpredictor , datepredictor , relationalpredictor , multiinstance , classtype , missinglevel , predictormissing , classmissing , numtrain , numtest , numclasses , accepts ) ; }	checks basic missing value handling of the scheme.
private void disablebuttons ( ) { for ( deploycommand cmd : deploycommand . values ( ) ) { setbuttonenabled ( cmd , _bool ) ; } butdone . setenabled ( _bool ) ; setloadenabled ( _bool ) ; setunloadenabled ( _bool ) ; setassaultdropenabled ( _bool ) ; }	disables all buttons in the interface.
public artifact load ( file path ) throws ioexception { return load ( new artifactname ( path . getname ( ) ) , path ) ; }	load artifact at path , using path name as artifactid.
protected final boolean tryacquire ( int acquires ) { final thread current = thread . currentthread ( ) ; int c = getstate ( ) ; if ( c == _num ) { if ( ! hasqueuedpredecessors ( ) && compareandsetstate ( _num , acquires ) ) { setexclusiveownerthread ( current ) ; return _bool ; } } else if ( current == getexclusiveownerthread ( ) ) { int nextc = c + acquires ; if ( nextc < _num ) throw new error ( _str ) ; setstate ( nextc ) ; return _bool ; } return _bool ; }	fair version of tryacquire.
private static final boolean isheaderend ( stringbuilder sb ) { int len = sb . length ( ) ; if ( len > _num ) { if ( lf2 . equals ( sb . substring ( len - _num ) ) ) { return _bool ; } } if ( len > _num ) { if ( crlf2 . equals ( sb . substring ( len - _num ) ) ) { return _bool ; } } return _bool ; }	check if the current stringbuilder trailing characters is an http header end ( empty crlf ) .
@ override public enumeration < option > listoptions ( ) { vector < option > result = new vector < option > ( ) ; result . addelement ( new option ( _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str , _str , _num , _str ) ) ; result . add ( new option ( _str + _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str , _str , _num , _str ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options < p >.
public tsactiondelay ( transitsectionaction tsa , int delay ) { _tsa = tsa ; _delay = delay ; }	a runnable that implements delayed execution of a transitsectionaction.
public daddextensions ( jdialog parent , x509extensionset extensions , publickey authoritypublickey , x500name authoritycertname , biginteger authoritycertserialnumber , publickey subjectpublickey ) { super ( parent , dialog . modalitytype . document_modal ) ; settitle ( res . getstring ( _str ) ) ; this . extensions = ( x509extensionset ) extensions . clone ( ) ; this . authoritypublickey = authoritypublickey ; this . authoritycertname = authoritycertname ; this . authoritycertserialnumber = authoritycertserialnumber ; this . subjectpublickey = subjectpublickey ; initcomponents ( ) ; }	creates new daddextensions dialog .
public void add ( imultipoint pt ) { if ( inprogress ) { throw new concurrentmodificationexception ( _str ) ; } points . add ( pt ) ; }	add point to the result set .
public static boolean iscglibproxyclass ( class < ? > clazz ) { return ( clazz != null && iscglibproxyclassname ( clazz . getname ( ) ) ) ; }	check whether the specified class is a cglib - generated class .
private discoveryinformation verifydiscovered ( authsuccess authresp , discoveryinformation discovered ) throws discoveryexception { if ( authresp == null || authresp . getidentity ( ) == null ) { _log . info ( _str ) ; return null ; } if ( authresp . isversion2 ( ) ) return verifydiscovered2 ( authresp , discovered ) ; else return verifydiscovered1 ( authresp , discovered ) ; }	verifies the dicovery information matches the data received in a authentication response from an openid provider .
public boolean generate ( reportdescription description , date date ) { try { integer targetdateint = integer . parseint ( format . format ( date ) ) ; analysisresultset logaggregation = makeloganal ( description , targetdateint ) ; report report = new report ( ) ; report . setsendtime ( new date ( ) ) ; report . settargetdate ( date ) ; report . setlogreport ( logaggregation ) ; report . settargets ( description . gettargets ( ) ) ; logger . debug ( _str + report ) ; reportrepository . save ( report ) ; return _bool ; } catch ( exception e ) { logger . error ( e . getmessage ( ) , e ) ; return _bool ; } }	generate report using description and target date.
@ override public void updatetextviews ( recharge recharge ) { unittypetextview . settext ( recharge . getunits ( ) ) ; unitvaluetextview . settext ( string . valueof ( recharge . getcurrentamount ( ) ) ) ; costtextview . settext ( currency . localize ( recharge . getcurrentcost ( ) , _bool ) ) ; rechargename . settext ( recharge . gettitle ( ) ) ; confirmationtextview . settext ( _str + recharge . getcurrentamount ( ) + _str + recharge . getunits ( ) + _str ) ; if ( recharge . getcurrentamount ( ) == recharge . getinitialamount ( ) ) { downarrow . setvisibility ( view . invisible ) ; } else { downarrow . setvisibility ( view . visible ) ; } }	update the text views based on the recharge data being passed in .
private concurrentmap < gridcacheversion , igniteinternaltx > transactionmap ( igniteinternaltx tx ) { return ( tx . near ( ) && ! tx . local ( ) ) ? nearidmap : idmap ; }	gets transaction id map depending on transaction type .
public void stop ( ) { synchronized ( this ) { mstopped = _bool ; if ( mlistenerthread == null ) { return ; } } mlistenerthread . interrupt ( ) ; try { if ( mserversocket != null ) { mserversocket . close ( ) ; } } catch ( ioexception e ) { } }	stops the listener thread and unbinds the address .
public static byte [ ] decode ( byte [ ] data , string pri_key ) { try { cipher cipher = cipher . getinstance ( _str ) ; java . security . key k = getprivatekey ( pri_key ) ; cipher . init ( cipher . decrypt_mode , k ) ; byte [ ] debytes = cipher . dofinal ( data ) ; return debytes ; } catch ( exception e ) { log . error ( pri_key , e ) ; } return null ; }	decode data with private key .
public static int deriveargb ( color color1 , color color2 , float midpoint ) { int r = color1 . getred ( ) + ( int ) ( ( color2 . getred ( ) - color1 . getred ( ) ) * midpoint + _num ) ; int g = color1 . getgreen ( ) + ( int ) ( ( color2 . getgreen ( ) - color1 . getgreen ( ) ) * midpoint + _num ) ; int b = color1 . getblue ( ) + ( int ) ( ( color2 . getblue ( ) - color1 . getblue ( ) ) * midpoint + _num ) ; int a = color1 . getalpha ( ) + ( int ) ( ( color2 . getalpha ( ) - color1 . getalpha ( ) ) * midpoint + _num ) ; return ( ( a & _num ) << _num ) | ( ( r & _num ) << _num ) | ( ( g & _num ) << _num ) | ( b & _num ) ; }	derives the argb value for a color based on an offset between two other colors .
public void addlandingpad ( int x , int z ) { blockposition pos = new blockposition ( x , _num , z ) ; if ( ! spawnlocations . contains ( pos ) ) { spawnlocations . add ( pos ) ; occupiedlandingpads . put ( pos , _bool ) ; } }	adds a landing pad to the station.
static attackstrategy create ( string params ) { string [ ] arg = params . split ( _str , - _num ) ; if ( arg . length != _num ) { throw new illegalargumentexception ( _str + params + _str ) ; } pair < string , string > desc = parsestrategy ( arg [ _num ] ) ; targetselectionstrategy targeter = targetselectionstrategyfactory . get ( desc . first ( ) , desc . second ( ) ) ; desc = parsestrategy ( arg [ _num ] ) ; positioningstrategy positioner = positioningstrategyfactory . get ( desc . first ( ) , desc . second ( ) ) ; return new compoundattackstrategy ( getsubstrategy ( arg [ _num ] ) , targeter , positioner ) ; }	create a new strategy .
public orderedthreadpoolexecutor ( ) { this ( default_initial_thread_pool_size , default_max_thread_pool , default_keep_alive , timeunit . seconds , executors . defaultthreadfactory ( ) , null ) ; }	creates a default threadpool , with default values : - minimum pool size is 0 - maximum pool size is 16 - keepalive set to 30 seconds - a default threadfactory - all events are accepted.
final public void writechunk ( l locator , kvo < o > [ ] chunk ) throws mockstalelocatorexception { synchronized ( this ) { if ( stalelocators . contains ( locator . getpartitionid ( ) ) ) { throw new mockstalelocatorexception ( locator ) ; } if ( ! knownlocators . contains ( locator . getpartitionid ( ) ) ) { throw new runtimeexception ( _str + locator ) ; } } acceptwrite ( locator , chunk ) ; }	write a chunk onto the data service .
public event event ( int id ) { if ( ! host ) { return ( event ) events . get ( new integer ( id ) ) ; } return null ; }	disabled for hosted mode .
private void initvalues ( ) { ipreferencestore store = dogetpreferencestore ( ) ; final string storeditems = store . getstring ( checkerpreferences . pref_checker_custom_classes ) ; if ( ! storeditems . equals ( _str ) ) { customcheckers . setitems ( storeditems . split ( _str ) ) ; } }	initialize the values in the table to the preference values.
private void loadproperties ( ) { string property = system . getproperty ( _str ) ; if ( null == property ) { property = carboncommonconstants . carbon_properties_file_path ; } file file = new file ( property ) ; logger . info ( _str + file . getabsolutepath ( ) ) ; fileinputstream fis = null ; try { if ( file . exists ( ) ) { fis = new fileinputstream ( file ) ; carbonproperties . load ( fis ) ; } } catch ( filenotfoundexception e ) { logger . error ( _str + carboncommonconstants . carbon_properties_file_path + _str ) ; } catch ( ioexception e ) { logger . error ( _str + carboncommonconstants . carbon_properties_file_path ) ; } finally { if ( null != fis ) { try { fis . close ( ) ; } catch ( ioexception e ) { logger . error ( _str + carboncommonconstants . carbon_properties_file_path ) ; } } } print ( ) ; }	this method will read all the properties from file and load it into memory.
public void list ( printstream out ) { out . println ( _str ) ; hashtable < string , object > h = new hashtable < > ( ) ; enumerate ( h ) ; for ( enumeration < string > e = h . keys ( ) ; e . hasmoreelements ( ) ; ) { string key = e . nextelement ( ) ; string val = ( string ) h . get ( key ) ; if ( val . length ( ) > _num ) { val = val . substring ( _num , _num ) + _str ; } out . println ( key + _str + val ) ; } }	prints this property list out to the specified output stream.
public static date stringtodate ( string strdate , @ suppresswarnings ( _str ) string format ) { date date = null ; simpledateformat formatter = new simpledateformat ( format ) ; try { date = formatter . parse ( strdate ) ; } catch ( parseexception e ) { e . printstacktrace ( ) ; } return date ; }	convert date in string format to date format.
@ nullable public static string md5 ( @ nullable file file , @ nullable ignitelogger log ) { if ( file != null ) return file . isfile ( ) ? filemd5 ( file , log ) : directorymd5 ( file , log ) ; return null ; }	calculates md5 checksum for the given file o directory.
public void init ( int size , int certainty , securerandom random ) { this . size = size ; this . certainty = certainty ; this . random = random ; }	initialise the parameters generator .
@ override public boolean hasnext ( ) { if ( allrowsresult . size ( ) == _num ) { return _bool ; } totalrecordcounter ++ ; listrecordcounter ++ ; if ( listrecordcounter == _num || ( listrecordcounter >= currentrowpointer . size ( ) && currentlistcounter < allrowsresult . size ( ) ) ) { listrecordcounter = _num ; currentrowpointer = allrowsresult . get ( currentlistcounter ) ; currentlistcounter ++ ; } return totalrecordcounter < totalnumberofrecords ; }	method to check more result is present or not.
public void trimtosize ( ) { delegate . trimtosize ( ) ; }	trims the capacity of this list to be the list ' s current size .
jsonstringer open ( scope empty , string openbracket ) throws jsonexception { if ( stack . isempty ( ) && out . length ( ) > _num ) { throw new jsonexception ( _str ) ; } beforevalue ( ) ; stack . add ( empty ) ; out . append ( openbracket ) ; return this ; }	enters a new scope by appending any necessary whitespace and the given bracket .
public static final string asciiboard ( position pos ) { stringbuilder ret = new stringbuilder ( _num ) ; string nl = string . format ( locale . us , _str ) ; ret . append ( _str ) ; ret . append ( nl ) ; for ( int y = _num ; y >= _num ; y -- ) { ret . append ( _str ) ; for ( int x = _num ; x < _num ; x ++ ) { ret . append ( _str ) ; int p = pos . getpiece ( position . getsquare ( x , y ) ) ; if ( p == piece . empty ) { boolean dark = position . darksquare ( x , y ) ; ret . append ( dark ? _str : _str ) ; } else { ret . append ( piece . iswhite ( p ) ? _str : _str ) ; string piecename = piecetochar ( p ) ; if ( piecename . length ( ) == _num ) piecename = _str ; ret . append ( piecename ) ; ret . append ( _str ) ; } } ret . append ( nl ) ; ret . append ( _str ) ; ret . append ( nl ) ; } return ret . tostring ( ) ; }	create an ascii representation of a position .
public final void clear ( ) { caches . clear ( ) ; sections . clear ( ) ; }	clears the caches and sections data set.
static set < node > tonodeset ( iterator < node > i ) { set < node > nodeset = new hashset < node > ( ) ; while ( i . hasnext ( ) ) { node n = i . next ( ) ; nodeset . add ( n ) ; if ( n . getnodetype ( ) == node . element_node ) { namednodemap nnm = n . getattributes ( ) ; for ( int j = _num , length = nnm . getlength ( ) ; j < length ; j ++ ) { nodeset . add ( nnm . item ( j ) ) ; } } } return nodeset ; }	converts an iterator to a set of nodes , according to the xpath data model .
public static void runconcurrently ( final callable < void > task , final int times ) throws exception { final executorservice service = executors . newfixedthreadpool ( _num ) ; final list < future < ? > > futures = new arraylist < future < ? > > ( ) ; for ( int i = _num ; i < times ; i ++ ) { futures . add ( service . submit ( task ) ) ; } for ( final future < ? > future : futures ) { future . get ( ) ; } }	runs a task concurrently.
private static arraylist < containervm > createvmlist ( int brokerid , int containervmsnumber ) { arraylist < containervm > containervms = new arraylist < containervm > ( ) ; for ( int i = _num ; i < containervmsnumber ; ++ i ) { arraylist < containerpe > pelist = new arraylist < containerpe > ( ) ; int vmtype = i / ( int ) math . ceil ( ( double ) containervmsnumber / _num ) ; for ( int j = _num ; j < constantsexamples . vm_pes [ vmtype ] ; ++ j ) { pelist . add ( new containerpe ( j , new cotainerpeprovisionersimple ( ( double ) constantsexamples . vm_mips [ vmtype ] ) ) ) ; } containervms . add ( new powercontainervm ( ids . pollid ( containervm . class ) , brokerid , ( double ) constantsexamples . vm_mips [ vmtype ] , ( float ) constantsexamples . vm_ram [ vmtype ] , constantsexamples . vm_bw , constantsexamples . vm_size , _str , new containerschedulertimesharedoversubscription ( pelist ) , new containerramprovisionersimple ( constantsexamples . vm_ram [ vmtype ] ) , new containerbwprovisionersimple ( constantsexamples . vm_bw ) , pelist , constantsexamples . scheduling_interval ) ) ; } return containervms ; }	create the virtual machines and add them to the list.
public static void addportuse ( map < storageport , integer > portusecounts , storageport port ) { if ( ! portusecounts . containskey ( port ) ) { portusecounts . put ( port , _num ) ; } else { integer newcount = portusecounts . get ( port ) + _num ; portusecounts . put ( port , newcount ) ; } }	adds a use count to a port , which indicates one initiator is using the port this is public static because the storageportsassignertest uses it .
public void popelemattributeset ( ) { m_attrsetstack . pop ( ) ; }	pop the current executing attribute set .
@ override public synchronized cacheobject < v > put ( k key , cacheobject < v > value ) { if ( cache . size ( ) >= maxsize ) { if ( removeexpired ( ) <= _num ) { if ( cachefullremovetype instanceof removetypenotremove ) { return null ; } if ( fullremoveone ( ) == null ) { return null ; } } } value . setentertime ( system . currenttimemillis ( ) ) ; cache . put ( key , value ) ; return value ; }	put element , key and value both not allowed to be null.
public void removemodelchange ( string tablename , modelvalidator listener ) { if ( tablename == null || listener == null ) return ; string propertyname = m_globalvalidators . contains ( listener ) ? tablename + _str : tablename + listener . getad_client_id ( ) ; arraylist < modelvalidator > list = m_modelchangelisteners . get ( propertyname ) ; if ( list == null ) return ; list . remove ( listener ) ; if ( list . size ( ) == _num ) m_modelchangelisteners . remove ( propertyname ) ; }	remove model change listener.
protected void firechangeevent ( ) { iterator iter = m_listeners . iterator ( ) ; changeevent evt = new changeevent ( this ) ; while ( iter . hasnext ( ) ) { changelistener cl = ( changelistener ) iter . next ( ) ; cl . statechanged ( evt ) ; } }	fire a change event to listeners .
private string createconnectionname ( ) { stringbuilder namebuffer = new stringbuilder ( ) ; namebuffer . append ( getconnectiontype ( ) ) ; namebuffer . append ( _str ) ; namebuffer . append ( _host ) ; namebuffer . append ( _str ) ; namebuffer . append ( _port ) ; return namebuffer . tostring ( ) ; }	constructs a name for the connection using the connection type , host , and port .
@ post @ produces ( { mediatype . application_xml , mediatype . application_json } ) @ path ( _str ) @ checkpermission ( roles = { role . tenant_admin } ) public taskresourcerep discoverhost ( @ pathparam ( _str ) uri id ) { argvalidator . checkfielduritype ( id , host . class , _str ) ; host host = queryobject ( host . class , id , _bool ) ; return dodiscoverhost ( host ) ; }	discovers ( refreshes ) a host.
public static final void readfully ( inputstream i , byte b [ ] , int off , int len ) throws ioexception { if ( len < _num ) { throw new indexoutofboundsexception ( ) ; } int n = _num ; while ( n < len ) { int count = i . read ( b , off + n , len - n ) ; if ( count < _num ) { throw new eofexception ( ) ; } n += count ; } }	the read fully method from data input stream is very useful for all types of streams.
private void drawlines ( canvas canvas ) { for ( int i = _num ; i < connectionorder . size ( ) - _num ; i ++ ) { drawline ( canvas , circles [ connectionorder . get ( i ) ] , circles [ connectionorder . get ( i + _num ) ] ) ; } }	draw lines between the connectors.
private void addorupdatenode ( astarnode newnode ) { boolean found = _bool ; for ( astarnode toupdate : closednodes ) { if ( newnode . equals ( toupdate ) ) { toupdate . updatedistance ( newnode . getg ( ) , newnode . parent ) ; found = _bool ; break ; } } if ( ! found ) { openqueue . offer ( newnode ) ; } }	adds a new astarnode to the queue unless it is already among the closed nodes , in which case it only updates the closed node with the new distance .
public static file tofile ( javafileobject javafileobject ) { return new file ( javafileobject . getname ( ) ) ; }	gets the file from a java file object .
public writableraster createcompatiblewritableraster ( int w , int h ) { int [ ] boffs = { _num , _num , _num } ; return raster . createinterleavedraster ( databuffer . type_byte , w , h , w * _num , _num , boffs , null ) ; }	creates a writableraster with the specified width and height , that has a data layout ( samplemodel ) compatible with this colormodel .
public static multisegmentpowerlawbipartitegraph buildrandommultisegmentbipartitegraph ( int maxnumsegments , int maxnumedgespersegment , int leftsize , int rightsize , double edgeprobability , random random ) { multisegmentpowerlawbipartitegraph multisegmentpowerlawbipartitegraph = new multisegmentpowerlawbipartitegraph ( maxnumsegments , maxnumedgespersegment , leftsize / _num , ( int ) ( rightsize * edgeprobability / _num ) , _num , rightsize / _num , ( int ) ( leftsize * edgeprobability / _num ) , _num , new identityedgetypemask ( ) , new nullstatsreceiver ( ) ) ; for ( int i = _num ; i < leftsize ; i ++ ) { for ( int j = _num ; j < rightsize ; j ++ ) { if ( random . nextdouble ( ) < edgeprobability ) { multisegmentpowerlawbipartitegraph . addedge ( i , j , ( byte ) _num ) ; } } } return multisegmentpowerlawbipartitegraph ; }	build a random left - regular bipartite graph of given left and right sizes .
public static string execute ( string command ) { return subprocessuttility . execute ( command ) ; }	execute a command in the environment.
public synchronized void updateprogress ( final int value ) { final thread t = thread . currentthread ( ) ; final myinteger v = mindividualthreadprogress . get ( t ) ; if ( v == null ) { mindividualthreadprogress . put ( t , new myinteger ( value ) ) ; } else { v . setvalue ( value ) ; } if ( value > mlastreportedprogress ) { int min = integer . max_value ; for ( final myinteger m : mindividualthreadprogress . values ( ) ) { if ( m . getvalue ( ) < min ) { min = m . getvalue ( ) ; } } if ( min > mlastreportedprogress ) { mlastreportedprogress = min ; diagnostic . progress ( _str + min + _str + mname ) ; } } }	update progress , safe to use for multithreading .
private contexthandler createcontexthandler ( string directory , boolean isinjar , file installrootdirectory , int expiresinseconds ) { final contexthandler contexthandler = new contexthandler ( ) ; final resourcehandler resourcehandler = new expiresresourcehandler ( expiresinseconds ) ; final string directorywithslash = _str + directory ; contexthandler . setcontextpath ( directorywithslash ) ; resource directoryresource = getdirectoryresource ( directory , isinjar , installrootdirectory ) ; directoryresource = new jsminifyingresource ( directoryresource ) ; if ( isinjar ) { directoryresource = new cachingresource ( directoryresource , directorywithslash ) ; } resourcehandler . setbaseresource ( directoryresource ) ; if ( ! isinjar ) { resourcehandler . setminmemorymappedcontentlength ( _num ) ; } contexthandler . sethandler ( resourcehandler ) ; return contexthandler ; }	creates a context handler for the directory .
public boolean startswith ( java . lang . charsequence prefix ) { return startswith ( prefix , _num ) ; }	indicates if this text starts with the specified prefix .
private list < containerinitializer > jspinitializers ( ) { jettyjasperinitializer sci = new jettyjasperinitializer ( ) ; containerinitializer initializer = new containerinitializer ( sci , null ) ; list < containerinitializer > initializers = new arraylist < containerinitializer > ( ) ; initializers . add ( initializer ) ; return initializers ; }	ensure the jsp engine is initialized correctly.
public static temppath createdirectory ( ) throws ioexception { return wrap ( files . createtempdirectory ( prefix ) ) ; }	creates a new temporary directory in the default temporary file location .
public static string tostring ( int partition [ ] [ ] ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( _str ) ; for ( int i = _num ; i < partition . length ; i ++ ) { sb . append ( _str + arrays . tostring ( partition [ i ] ) ) ; } sb . append ( _str ) ; return sb . tostring ( ) ; }	tostring - a string representation for the super - class partition ' partition ' .
public static boolean iscategorychildof ( servletrequest request , string parentproductcategoryid , string productcategoryid ) { return iscategorychildof ( ( delegator ) request . getattribute ( _str ) , ( localdispatcher ) request . getattribute ( _str ) , parentproductcategoryid , productcategoryid ) ; }	scipio : returns true only if the category id is child of the given parent category id . < p > note : is caching.
@ override public boolean input ( instance instance ) { if ( getinputformat ( ) == null ) { throw new illegalstateexception ( _str ) ; } if ( m_newbatch ) { resetqueue ( ) ; m_newbatch = _bool ; } push ( ( instance ) instance . copy ( ) ) ; return _bool ; }	input an instance for filtering.
public collection < string > listcolumns ( string table ) throws databaseexception { collection < string > result = new arraylist < string > ( ) ; resultset rs = null ; try { databasemetadata dbm = connection . getmetadata ( ) ; rs = dbm . getcolumns ( null , null , table , null ) ; while ( rs . next ( ) ) { result . add ( rs . getstring ( _str ) ) ; } } catch ( sqlexception e ) { throw new databaseexception ( e ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( sqlexception e ) { } } } return result ; }	get a list of all of the columns on a table .
public void addcreatedresource ( location location , resource resource ) { resourcelist . add ( resource ) ; locationtoresourcemap . put ( location , resource ) ; }	add a resource created within the analyzed method .
public void signalevent ( ) { collection < semaphore > semaphores = _semaphores . values ( ) ; for ( semaphore semaphore : semaphores ) { semaphore . release ( ) ; semaphores . remove ( semaphore ) ; } }	signals the semaphore when the event arrives .
@ override public boolean equals ( object obj ) { if ( obj == this ) { return _bool ; } if ( ! ( obj instanceof keyedobjects ) ) { return _bool ; } keyedobjects that = ( keyedobjects ) obj ; int count = getitemcount ( ) ; if ( count != that . getitemcount ( ) ) { return _bool ; } for ( int i = _num ; i < count ; i ++ ) { comparable k1 = getkey ( i ) ; comparable k2 = that . getkey ( i ) ; if ( ! k1 . equals ( k2 ) ) { return _bool ; } object o1 = getobject ( i ) ; object o2 = that . getobject ( i ) ; if ( o1 == null ) { if ( o2 != null ) { return _bool ; } } else { if ( ! o1 . equals ( o2 ) ) { return _bool ; } } } return _bool ; }	tests this object for equality with an arbitrary object .
protected boolean isquorummaintained ( ) { if ( nodecount == _num ) { log . info ( _str ) ; return _bool ; } int quorumnodecnt = nodecount / _num + _num ; coordinatorclient coordinatorclient = coordinator . getcoordinatorclient ( ) ; list < service > allactivedbsvcs = coordinatorclient . locateallsvcsallvers ( constants . dbsvc_name ) ; list < string > otheractivedbsvcids = new arraylist < > ( ) ; string mysvcid = coordinator . getmysvcid ( ) ; string localdbsvcid = _str + mysvcid . substring ( mysvcid . lastindexof ( _str ) ) ; for ( service activedbsvc : allactivedbsvcs ) { if ( ! localdbsvcid . equals ( activedbsvc . getid ( ) ) ) { otheractivedbsvcids . add ( activedbsvc . getid ( ) ) ; } } log . info ( _str , otheractivedbsvcids , quorumnodecnt ) ; boolean ismaintained = otheractivedbsvcids . size ( ) >= quorumnodecnt ; if ( ! ismaintained ) { log . info ( _str ) ; } return ismaintained ; }	check if node_count / 2 + 1 dbsvc instances are active on other nodes in the cluster so that if the current node is powered off , a quorum will still be maintained .
public static void schedulenextalarm ( context context ) { schedulenextalarm ( context , alertutils . createalarmmanager ( context ) , reminder_query_batch_size , system . currenttimemillis ( ) ) ; }	schedules the nearest upcoming alarm , to refresh notifications.
public void requeststop ( ) { stoprequested . set ( _bool ) ; }	allows scheduling a request to stop the workload .
public void test_enginecreatesslengine_02 ( ) { int [ ] invalid_port = { integer . min_value , - _num , - _num , _num , integer . max_value } ; sslcontextspiimpl ssl = new sslcontextspiimpl ( ) ; try { sslengine sleng = ssl . enginecreatesslengine ( _str , _num ) ; fail ( _str ) ; } catch ( runtimeexception re ) { string str = re . getmessage ( ) ; if ( ! str . equals ( _str ) ) fail ( _str + str ) ; } catch ( exception e ) { fail ( _str + e + _str ) ; } for ( int i = _num ; i < invalid_port . length ; i ++ ) { try { sslengine sleng = ssl . enginecreatesslengine ( _str , invalid_port [ i ] ) ; fail ( _str ) ; } catch ( illegalargumentexception iae ) { } } }	javax . net . ssl . sslcontextspi # enginecreatesslengine ( string host , int port ) verify exception when sslcontextspi object wasn ' t initialiazed .
@ safevarargs public static < t > t [ ] join ( intfunction < t [ ] > arrayfunction , t [ ] ... arrays ) { if ( arrays . length == _num ) { return arrayfunction . apply ( _num ) ; } if ( arrays . length == _num ) { return arrays [ _num ] ; } if ( arrays . length == _num ) { return join ( arrayfunction , arrays [ _num ] , arrays [ _num ] ) ; } t [ ] notnull = null ; int finalsize = _num ; int nullarrays = _num ; list < t > list = new arraylist < > ( arrays . length * _num ) ; for ( t [ ] array : arrays ) { if ( ( array == null ) || ( array . length == _num ) ) { nullarrays ++ ; } else { notnull = array ; finalsize += array . length ; collections . addall ( list , array ) ; } } if ( nullarrays == arrays . length ) { return arrayfunction . apply ( _num ) ; } if ( nullarrays == ( arrays . length - _num ) ) { return notnull ; } return list . toarray ( arrayfunction . apply ( list . size ( ) ) ) ; }	joins arrays together , if only one array contains elements it will be returned without coping anything.
private static set < string > splitpath ( relaxedurl url ) { set < string > results = new hashset < string > ( ) ; set < string > queries = normalizequery ( url . getquery ( ) ) ; results . add ( _str ) ; for ( string q : queries ) { results . add ( _str + q ) ; } set < string > paths = splitpath ( url . getpath ( ) ) ; results . addall ( paths ) ; for ( string p : paths ) { for ( string q : queries ) { results . add ( p + _str + q ) ; } } return results ; }	returns a list of sub parts of path of a resource name .
public actionforward initbestsellingreport ( actionmapping mapping , actionform form , httpservletrequest request , httpservletresponse response ) throws applicationexception , operationexception { actionforward fwd = init ( mapping , form , request , response ) ; if ( fwd != null ) return fwd ; sellingitemform reportform = ( sellingitemform ) form ; string timeperiod = reportdatemanager . today ; string daterange = constants . fixed_date_range ; reportform . settimeperiod ( timeperiod ) ; reportform . setdaterange ( daterange ) ; reportform . setfromdate ( _str ) ; reportform . settodate ( _str ) ; reportform . validate ( mapping , request ) ; return mapping . findforward ( init_best_selling_report ) ; }	initialise best selling items report.
@ override public void transactionbegin ( ) { for ( bigdatagraphlistener listener : listeners ) { listener . transactionbegin ( ) ; } }	notification of transaction beginning .
public synchronized void add ( job job ) { boolean canrunimmediately = dagmanager . addjob ( job ) ; if ( canrunimmediately ) { log . debug ( _str + job + _str ) ; jobstorun . add ( job ) ; } incrementsubmittedjobcount ( ) ; }	add the given job to run.
public void reset ( string latex ) { parsestring = new stringbuffer ( latex ) ; len = parsestring . length ( ) ; formula . root = null ; pos = _num ; spos = _num ; line = _num ; col = _num ; group = _num ; insertion = _bool ; atisletter = _num ; arraymode = _bool ; ignorewhitespace = _bool ; firstpass ( ) ; }	reset the parser with a new latex expression.
public void addconstant ( constantpoolentry entry ) { if ( entry instanceof utf8constant ) { utf8constant utf8 = ( utf8constant ) entry ; _utf8map . put ( utf8 . getvalue ( ) , utf8 ) ; } _entries . add ( entry ) ; }	adds a new constant .
public void adddata ( arraylist < chartset > data ) { this . data = data ; }	add full chart data .
public final double infogain ( ) { return m_infogain ; }	returns ( c4 . 5 - type ) information gain for the generated split .
boolean cancel ( int propertyconstant ) { if ( ( mpropertymask & propertyconstant ) != _num && mnamevaluesholder != null ) { int count = mnamevaluesholder . size ( ) ; for ( int i = _num ; i < count ; ++ i ) { namevaluesholder namevaluesholder = mnamevaluesholder . get ( i ) ; if ( namevaluesholder . mnameconstant == propertyconstant ) { mnamevaluesholder . remove ( i ) ; mpropertymask &= ~ propertyconstant ; return _bool ; } } } return _bool ; }	removes the given property from being animated as a part of this propertybundle.
@ suppresswarnings ( _str ) public static < t > typeserializer < t > deserialize ( byte [ ] bytes ) throws ioexception { bytearrayinputstream bis = new bytearrayinputstream ( bytes ) ; objectinput in = null ; try { in = new objectinputstream ( bis ) ; return ( typeserializer < t > ) in . readobject ( ) ; } catch ( classnotfoundexception e ) { throw new ioexception ( _str ) ; } finally { try { bis . close ( ) ; } catch ( ioexception ex ) { } try { if ( in != null ) { in . close ( ) ; } } catch ( ioexception ex ) { } } }	deserializes a serialized typeserializer.
public void testremainderknuthmultidigitsbyonedigit ( ) { byte abytes [ ] = { _num , - _num , _num , - _num , _num , - _num , _num , _num , - _num } ; byte bbytes [ ] = { _num , - _num , - _num , - _num } ; int asign = _num ; int bsign = - _num ; byte rbytes [ ] = { _num , - _num , - _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . remainder ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	divide the number of multi digits by the number of one digit.
public void showselectedneuronproperties ( ) { neurondialog dialog = neurondialog . createneurondialog ( getselectedneurons ( ) ) ; dialog . setmodalitytype ( dialog . modalitytype . modeless ) ; dialog . pack ( ) ; dialog . setlocationrelativeto ( null ) ; dialog . setvisible ( _bool ) ; }	creates and displays the neuron properties dialog .
public void encrypt ( byte [ ] in , int length ) { int pos = _num ; while ( pos < in . length && pos < length ) { encryptblock ( in , pos , length ) ; pos += blocksize ; } }	perform pseudo " in - place " encryption.
private static boolean haschangesofchildren ( long last , pagecontext pc , class clazz ) { java . lang . reflect . method [ ] methods = clazz . getmethods ( ) ; java . lang . reflect . method method ; class [ ] params ; for ( int i = _num ; i < methods . length ; i ++ ) { method = methods [ i ] ; if ( method . getdeclaringclass ( ) == clazz ) { if ( _haschangesofchildren ( pc , last , method . getreturntype ( ) ) ) return _bool ; params = method . getparametertypes ( ) ; for ( int y = _num ; y < params . length ; y ++ ) { if ( _haschangesofchildren ( pc , last , params [ y ] ) ) return _bool ; } } } return _bool ; }	check if one of the children is changed.
private windowstuffhelper ( ) { }	prevent initializing this class .
public static string removespecialchar ( string tempstr ) { if ( tempstr != null ) { tempstr = replace ( tempstr , _str , _str , _bool , _bool ) ; tempstr = replace ( tempstr , _str , _str , _bool , _bool ) ; tempstr = replace ( tempstr , _str , _str , _bool , _bool ) ; tempstr = replace ( tempstr , _str , _str , _bool , _bool ) ; tempstr = replace ( tempstr , _str , _str , _bool , _bool ) ; tempstr = replace ( tempstr , _str , _str , _bool , _bool ) ; tempstr = replace ( tempstr , _str , _str , _bool , _bool ) ; tempstr = replace ( tempstr , _str , _str , _bool , _bool ) ; tempstr = replace ( tempstr , _str , _str , _bool , _bool ) ; tempstr = replace ( tempstr , _str , _str , _bool , _bool ) ; tempstr = replace ( tempstr , _str , _str , _bool , _bool ) ; tempstr = replace ( tempstr , _str , _str , _bool , _bool ) ; tempstr = replace ( tempstr , _str , _str , _bool , _bool ) ; while ( tempstr . indexof ( _str ) > _num ) { tempstr = replace ( tempstr , _str , _str , _bool , _bool ) ; } tempstr = replace ( tempstr , _str , _str , _bool , _bool ) ; } return tempstr ; }	for some save scnearios and analysis we should remove special characters , i.
public runscriptaction ( networkpanel networkpanel ) { super ( _str ) ; putvalue ( small_icon , resourcemanager . getimageicon ( _str ) ) ; putvalue ( short_description , _str ) ; this . networkpanel = networkpanel ; }	create a new script action for the workspace .
public t webimage ( string url ) { return webimage ( url , _bool , _bool , _num ) ; }	load the webview with an image with a url.
private map < installment , list < receipt > > consolidatetuplesinstallmentwise ( final list < installmentreceipttuple > tuples ) { final map < installment , list < receipt > > consolidated = new hashmap < installment , list < receipt > > ( ) ; for ( final installmentreceipttuple t : tuples ) { list < receipt > receiptsforinstallment = consolidated . get ( t . installment ) ; if ( receiptsforinstallment == null ) { receiptsforinstallment = new arraylist < receipt > ( ) ; consolidated . put ( t . installment , receiptsforinstallment ) ; } if ( ! receiptsforinstallment . contains ( t . receipt ) ) receiptsforinstallment . add ( t . receipt ) ; } logger . info ( _str + consolidated ) ; return consolidated ; }	constructs a list of receipts for each installment .
public static boolean isvalidemail ( string email ) { final string emailpattern = _str ; matcher matcher ; pattern pattern = pattern . compile ( emailpattern ) ; matcher = pattern . matcher ( email ) ; if ( matcher != null ) return matcher . matches ( ) ; else return _bool ; }	checks if the input parameter is a valid email .
public void add ( linemergedirectededge directededge ) { directededges . add ( directededge ) ; }	adds a directed edge which is known to form part of this line .
public static applicationxml parseapplicationxmlfromfile ( file file , entityresolver entityresolver ) throws ioexception , jdomexception { inputstream in = null ; try { in = new fileinputstream ( file ) ; return parseapplicationxml ( in , entityresolver ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( ioexception ioe ) { } } } }	parses a deployment descriptor stored in a regular file .
public channelentry newconnection ( readselectorthread readhandler , selectionkey key ) { socketchannel channel = ( socketchannel ) key . channel ( ) ; writeselectorthread writehandler = _selectormanager . getwritehandler ( key . channel ( ) ) ; socket socket = channel . socket ( ) ; inetsocketaddress socketaddress = ( inetsocketaddress ) ( socket == null ? null : socket . getremotesocketaddress ( ) ) ; channelentry channelentry = new channelentry ( writehandler , readhandler , key , socketaddress , this ) ; m_channels . put ( channel , channelentry ) ; if ( socketaddress != null ) { _clienttochannel . put ( socketaddress , channelentry ) ; } if ( _logger . isloggable ( level . fine ) ) _logger . log ( level . fine , _str + channelentry . getclientendpointaddress ( ) + _str ) ; return channelentry ; }	called by the connmgr thread when a new connection is created .
public string report ( ) { stringbuffer report = new stringbuffer ( ) ; inthashtable = new int [ table . tablesize ] ; calculateslotusage ( ) ; int max = maxcollisions ( ) ; int [ ] slotusagecount = new int [ max + _num ] ; for ( int i : inthashtable ) { slotusagecount [ i ] ++ ; } report . append ( _str + numentries + _str ) ; report . append ( _str + ( numentries / ( _num * table . tablesize ) + _str ) ) ; float weightedavg = _num ; int numnonempty = _num ; report . append ( _str ) ; for ( int j = _num ; j <= max ; j ++ ) { if ( slotusagecount [ j ] != _num ) { report . append ( j + _str + slotusagecount [ j ] + _str ) ; if ( j != _num ) { weightedavg += slotusagecount [ j ] * j ; numnonempty += slotusagecount [ j ] ; } } } weightedavg /= numnonempty ; report . append ( _str + mincollisions ( ) + _str + max + _str + weightedavg ) ; return report . tostring ( ) ; }	generate and return the collision report .
public void addsubscriptiontostore ( final string topic , final string clientid ) { final clienttopiccouple subscription = new clienttopiccouple ( clientid , topic ) ; if ( ! topics . contains ( subscription ) ) { logger . debug ( _str + topic + _str + clientid + _str ) ; subscriptionsstore . add ( subscription ) ; topics . add ( topic ) ; } }	adds the given topic to the subscription store - used for topic to subscription matching .
public boolean zip ( string ziplocation , string tobezippedname ) { boolean ret = _bool ; if ( verbose ) debug . put ( _str ) ; file tobezipped = new file ( tobezippedname ) ; if ( tobezipped . exists ( ) ) { try { fileutils . savezipfile ( ziplocation , tobezipped ) ; ret = _bool ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } return ret ; }	store the contents of the tobezippedname directory into a zip file with the provided name.
private hashmap < integer , boolean > generateexpandedstatemap ( ) { hashmap < integer , boolean > parentlistitemhashmap = new hashmap < > ( ) ; int childcount = _num ; object listitem ; parentwrapper parentwrapper ; int listitemcount = mitemlist . size ( ) ; for ( int i = _num ; i < listitemcount ; i ++ ) { if ( mitemlist . get ( i ) != null ) { listitem = getlistitem ( i ) ; if ( listitem instanceof parentwrapper ) { parentwrapper = ( parentwrapper ) listitem ; parentlistitemhashmap . put ( i - childcount , parentwrapper . isexpanded ( ) ) ; } else { childcount ++ ; } } } return parentlistitemhashmap ; }	generates a hashmap used to store expanded state for items in the list on configuration change or whenever onresume is called .
public void addaudiopacketlistener ( listener < audiopacket > listener ) { maudiopacketbroadcaster . addlistener ( listener ) ; }	adds the listener to receive audio packets from all modules .
public deltacrlindicatorextension ( boolean critical , object value ) throws ioexception { super ( pkixextensions . deltacrlindicator_id , critical . booleanvalue ( ) , value , name , label ) ; }	creates the extension from the passed der encoded value of the same .
public javaenvironment ( file javapath ) { objects . requirenonnull ( javapath ) ; this . javapath = javapath ; }	creates a javaenvironment with the given ' java ' path .
void addcallback ( jsobject source , string method , jsfunction callback , boolean async ) { string key = source . tojspointer ( ) + _str + method ; callbacks . put ( key , callback ) ; string id = jsobject . id_key ; string self = source . tojspointer ( ) ; string js = self + _str + method + _str + _str + self + _str + method + _str + _str + _str + _str + _str + id + _str + _str + jslookuptable + _str + jslookuptable + _str + id + _str + jslookuptable + _str + jslookuptable + _str + id + _str + _str + _str + jslookuptable + _str + _str + _str + _str + _str + _str ; exec ( js , async ) ; }	adds a jsfunction to handle calls to the specified javascript object.
public void removeallblocksfromsection ( ) { for ( int i = mblockentries . size ( ) ; i > _num ; i -- ) { block b = mblockentries . get ( i - _num ) ; if ( b != null ) { b . removepropertychangelistener ( mblocklisteners . get ( i - _num ) ) ; } mblocklisteners . remove ( i - _num ) ; mblockentries . remove ( i - _num ) ; } for ( int i = mforwardentrypoints . size ( ) ; i > _num ; i -- ) { mforwardentrypoints . remove ( i - _num ) ; } for ( int i = mreverseentrypoints . size ( ) ; i > _num ; i -- ) { mreverseentrypoints . remove ( i - _num ) ; } initializationneeded = _bool ; }	remove all blocks , block listeners , and entry points.
public static void writestringtofile ( path file , string text ) throws ioexception { byte [ ] buf = text . getbytes ( standardcharsets . utf_8 ) ; files . write ( file , buf ) ; }	java nio replacement of commons - io.
private static boolean isoperatorvariableaccess ( final inavioperandtreenode node ) { final list < inavioperandtreenode > children = node . getchildren ( ) ; if ( children . size ( ) == _num ) { final inavioperandtreenode child0 = children . get ( _num ) ; final inavioperandtreenode child1 = children . get ( _num ) ; return isvariable ( child0 ) ^ isvariable ( child1 ) ; } else { return _bool ; } }	determines whether a given node is a variable access node that can be simplified .
@ override public void onvalueselected ( int pickerindex , int newvalue , boolean autoadvance ) { if ( pickerindex == hour_index ) { sethour ( newvalue , _bool ) ; string announcement = string . format ( _str , newvalue ) ; if ( mallowautoadvance && autoadvance ) { setcurrentitemshowing ( minute_index , _bool , _bool , _bool ) ; announcement += _str + mselectminutes ; } else { mtimepicker . setcontentdescription ( mhourpickerdescription + _str + newvalue ) ; } utils . tryaccessibilityannounce ( mtimepicker , announcement ) ; } else if ( pickerindex == minute_index ) { setminute ( newvalue ) ; mtimepicker . setcontentdescription ( mminutepickerdescription + _str + newvalue ) ; } else if ( pickerindex == half_day_index ) { updatehalfday ( newvalue ) ; } else if ( pickerindex == enable_picker_index ) { if ( ! istypedtimefullylegal ( ) ) { mtypedtimes . clear ( ) ; } finishkbmode ( _bool ) ; } }	called by the picker for updating the header display .
public static final list < geo > segmentnearpoly ( geo s1 , geo s2 , geoarray r , double near ) { int rlen = r . getsize ( ) ; geo pl0 = r . get ( rlen - _num , new geo ( ) ) ; geo pl1 = new geo ( ) ; list < geo > list = null ; geo check = new geo ( ) ; for ( int j = _num ; j < rlen ; j ++ ) { r . get ( j , pl1 ) ; geo ret = segmentsintersectornear ( s1 , s2 , pl0 , pl1 , near , check ) ; if ( ret != null ) { if ( list == null ) { list = new linkedlist < geo > ( ) ; } list . add ( ret ) ; check = new geo ( ) ; } pl0 . initialize ( pl1 ) ; } return list ; }	where is a segment , represented by endpoints ' s1 ' and ' s2 ' , withing a range ' near ' of region ' r ' ?.
public void addaction ( updateaction action ) { actionlist . add ( action ) ; for ( updatemanagerlistener listener : listeners ) { listener . actionadded ( action ) ; } }	add an action to the list .
public void load ( datainput rafin ) throws ioexception , maryconfigurationexception { int numidx = rafin . readint ( ) ; idxinterval = rafin . readint ( ) ; if ( idxinterval <= _num ) { throw new maryconfigurationexception ( _str ) ; } byteptrs = new long [ numidx ] ; timeptrs = new long [ numidx ] ; int numbytestoread = _num * numidx + _num ; byte [ ] data = new byte [ numbytestoread ] ; rafin . readfully ( data ) ; datainput bufin = new datainputstream ( new bytearrayinputstream ( data ) ) ; for ( int i = _num ; i < numidx ; i ++ ) { byteptrs [ i ] = bufin . readlong ( ) ; timeptrs [ i ] = bufin . readlong ( ) ; if ( i > _num ) { if ( byteptrs [ i ] < byteptrs [ i - _num ] || timeptrs [ i ] < timeptrs [ i - _num ] ) { throw new maryconfigurationexception ( _str ) ; } } } bufin . readlong ( ) ; bufin . readlong ( ) ; }	method which loads an index from a data input ( random access file or data input stream ) .
public url find ( string classname ) { string jarname = _str + classname . replace ( _str , _str ) + _str ; return thisclass . getresource ( jarname ) ; }	obtains the url of the specified class file .
public void signoff ( string uniqueid ) { debug . message ( _str , _str + uniqueid + _str ) ; caches . remove ( uniqueid ) ; viewattributelists . remove ( uniqueid ) ; timestamps . remove ( uniqueid ) ; }	the signoff function lets the server know that a client is checking out .
private string createnoncgsrdfpairstepsonemptygroup ( list < volumedescriptor > sourcedescriptors , list < volumedescriptor > targetdescriptors , remotedirectorgroup group , map < uri , volume > urivolumemap , string waitfor , workflow workflow ) { storagesystem system = dbclient . queryobject ( storagesystem . class , group . getsourcestoragesystemuri ( ) ) ; uri vpoolchangeuri = getvirtualpoolchangevolume ( sourcedescriptors ) ; log . info ( _str , vpoolchangeuri ) ; list < uri > sourceuris = volumedescriptor . getvolumeuris ( sourcedescriptors ) ; list < uri > targeturis = new arraylist < > ( ) ; for ( uri sourceuri : sourceuris ) { volume source = urivolumemap . get ( sourceuri ) ; stringset srdftargets = source . getsrdftargets ( ) ; for ( string targetstr : srdftargets ) { uri targeturi = uri . create ( targetstr ) ; targeturis . add ( targeturi ) ; } } method createlistmethod = createlistreplicasmethod ( system . getid ( ) , sourceuris , targeturis , vpoolchangeuri , _bool ) ; method rollbackmethod = rollbacksrdflinksmethod ( system . getid ( ) , sourceuris , targeturis , _bool ) ; string stepid = workflow . createstep ( create_srdf_active_volume_pair_step_group , create_srdf_active_volume_pair_step_desc , waitfor , system . getid ( ) , system . getsystemtype ( ) , getclass ( ) , createlistmethod , rollbackmethod , null ) ; return stepid ; }	this method creates steps to create srdf pairs in an empty srdf group .
public static long downsamplertimestamp ( long millitimestamp , long windowsize ) { return millitimestamp - ( millitimestamp % windowsize ) ; }	creating timestamp for downsampling in order to be consistent with tsdb downsampling func on hour / minute level.
@ override public string tostring ( ) { if ( points == null || points . length ( ) == _num ) { return idx + _str ; } stringbuffer bf = new stringbuffer ( ) ; try { bf . append ( idx + _str ) ; listnode temp ; for ( int i = _num ; i < points . size ( ) ; i ++ ) { temp = points . get ( i ) ; if ( i == _num ) { bf . append ( _str + temp . idx ) ; } else { bf . append ( _str + temp . idx ) ; } } } catch ( exception ex ) { ex . printstacktrace ( ) ; } return bf . tostring ( ) ; }	returns a string represention of the node .
public void error ( org . xml . sax . saxparseexception e ) throws org . xml . sax . saxexception { string formattedmsg = e . getmessage ( ) ; saxsourcelocator locator = getlocator ( ) ; errorlistener handler = m_stylesheetprocessor . geterrorlistener ( ) ; try { handler . error ( new transformerexception ( formattedmsg , locator ) ) ; } catch ( transformerexception te ) { throw new org . xml . sax . saxexception ( te ) ; } }	receive notification of a recoverable xslt processing error .
private void puthead ( string key , templatesubpatternassociation assoc ) { if ( key . equals ( psuedonames . pseudoname_text ) ) m_textpatterns = assoc ; else if ( key . equals ( psuedonames . pseudoname_root ) ) m_docpatterns = assoc ; else if ( key . equals ( psuedonames . pseudoname_comment ) ) m_commentpatterns = assoc ; m_patterntable . put ( key , assoc ) ; }	get the head of the assocation list that is keyed by target .
public unionpathiterator ( compiler compiler , int oppos ) throws javax . xml . transform . transformerexception { super ( ) ; oppos = opmap . getfirstchildpos ( oppos ) ; loadlocationpaths ( compiler , oppos , _num ) ; }	create a unionpathiterator object , including creation of location path iterators from the opcode list , and call back into the compiler to create predicate expressions .
public int read ( string table , string key , set < string > fields , hashmap < string , byteiterator > result ) { long st = system . nanotime ( ) ; int res = _db . read ( table , key , fields , result ) ; long en = system . nanotime ( ) ; _measurements . measure ( _str , ( int ) ( ( en - st ) / _num ) ) ; _measurements . reportreturncode ( _str , res ) ; return res ; }	read a record from the database.
protected void errormessage ( string msg ) throws ioexception { string str = msg + _str + m_tokenizer . tostring ( ) ; if ( m_lines > _num ) { int line = integer . parseint ( str . replaceall ( _str , _str ) ) ; str = str . replaceall ( _str , _str + ( m_lines + line - _num ) ) ; } throw new ioexception ( str ) ; }	throws error message with line number and last token read .
public boolean hasnext ( ) { if ( deal > _num ) { sc . close ( ) ; } return ( deal <= _num ) ; }	if the deal has more deals , this returns true ; false otherwise .
public void addissuer ( x500principal issuer ) { if ( issuer == null ) { throw new nullpointerexception ( _str ) ; } if ( issuernames == null ) { issuernames = new arraylist < string > ( ) ; } string name = issuer . getname ( x500principal . canonical ) ; if ( ! issuernames . contains ( name ) ) { issuernames . add ( name ) ; } if ( issuerprincipals == null ) { issuerprincipals = new arraylist < x500principal > ( issuernames . size ( ) ) ; } int size = issuernames . size ( ) - _num ; for ( int i = issuerprincipals . size ( ) ; i < size ; i ++ ) { issuerprincipals . add ( new x500principal ( issuernames . get ( i ) ) ) ; } issuerprincipals . add ( issuer ) ; }	adds an issuer to the criterion for the issuer distinguished names.
static string buildkeyselection ( int selectioncount ) { string [ ] list = new string [ selectioncount ] ; arrays . fill ( list , _str ) ; return key_column + _str + textutils . join ( _str , list ) + _str ; }	build the string required for an sql select statement : where key in ( ? , ? ,.
private void filternodemap ( concurrentmap < string , collection < clusternode > > map , final clusternode exclnode ) { for ( string cachename : registeredcaches . keyset ( ) ) { string maskedname = masknull ( cachename ) ; while ( _bool ) { collection < clusternode > oldnodes = map . get ( maskedname ) ; if ( oldnodes == null || oldnodes . isempty ( ) ) break ; collection < clusternode > newnodes = new arraylist < > ( oldnodes ) ; if ( ! newnodes . remove ( exclnode ) ) break ; if ( map . replace ( maskedname , oldnodes , newnodes ) ) break ; } } }	creates a copy of nodes map without the given node .
public void storedevice ( device d ) { if ( ! ismaster ) return ; if ( d == null ) return ; long now = system . nanotime ( ) ; writeupdateddevicetostorage ( d ) ; lastwritetimes . put ( d . getdevicekey ( ) , now ) ; }	write the given device to storage if we are master.
public void testcreateelementns1 ( ) throws throwable { string namespaceuri = _str ; string malformedname = _str ; document doc ; doc = ( document ) load ( _str , builder ) ; { boolean success = _bool ; try { doc . createelementns ( namespaceuri , malformedname ) ; } catch ( domexception ex ) { success = ( ex . code == domexception . namespace_err ) ; } asserttrue ( _str , success ) ; } }	runs the test case .
private static void adjustabs ( double [ ] array , int lower , int upper ) { int j , k ; double temp ; j = lower ; k = lower * _num ; while ( k <= upper ) { if ( ( k < upper ) && ( math . abs ( array [ k - _num ] ) < math . abs ( array [ k ] ) ) ) { k += _num ; } if ( math . abs ( array [ j - _num ] ) < math . abs ( array [ k - _num ] ) ) { temp = array [ j - _num ] ; array [ j - _num ] = array [ k - _num ] ; array [ k - _num ] = temp ; } j = k ; k *= _num ; } }	helps sort an array of doubles.
public synchronized iaudioprocessor remove ( int index ) { iaudioprocessor processor = processors . remove ( index ) ; buildfinalprocessor ( ) ; return processor ; }	removes the processor from the internal processor queue at the provided index .
linkedlist < trienode < t > > makesuffixchain ( trienode < t > root , string suffix , t value ) { linkedlist < trienode < t > > result = new linkedlist < > ( ) ; string rootprefix = root . getprefix ( ) ; for ( int i = _num , suffixsize = suffix . length ( ) ; i <= suffixsize ; i ++ ) { string newprefix = rootprefix + suffix . substring ( _num , i ) ; trienode < t > newnode = trienode . makenode ( newprefix ) ; result . add ( newnode ) ; root . addchild ( newnode ) ; root = newnode ; } root . setvalue ( value ) ; return result ; }	inserts a chain of children into the given node .
private static by byfromlocator ( string locator ) { if ( locator . startswith ( _str ) ) { return by . xpath ( locator ) ; } if ( locator . startswith ( _str ) ) { return by . id ( locator . replacefirst ( _str , _str ) ) ; } if ( locator . startswith ( _str ) ) { return by . cssselector ( locator . replacefirst ( _str , _str ) ) ; } if ( locator . startswith ( _str ) ) { return by . xpath ( locator . replacefirst ( _str , _str ) ) ; } if ( locator . startswith ( _str ) ) { return by . name ( locator . replacefirst ( _str , _str ) ) ; } if ( locator . startswith ( _str ) ) { return by . linktext ( locator . replacefirst ( _str , _str ) ) ; } if ( locator . startswith ( _str ) ) { return by . partiallinktext ( locator . replacefirst ( _str , _str ) ) ; } throw new illegalargumentexception ( _str + locator ) ; }	converts a locator string with a known prefix to a by object.
private static void taskstarted ( progressthread task ) { for ( progressthreadstatelistener l : listener . getlisteners ( progressthreadstatelistener . class ) ) { l . progressthreadstarted ( task ) ; } }	notify listeners that a task was started .
private void throwexceptionifdestroyed ( string method ) throws deepstreamrecorddestroyedexception { if ( this . isdestroyed ) { throw new deepstreamrecorddestroyedexception ( method ) ; } }	throw an exception if the record has been destroyed.
public void upload ( final inputstream in , string artifact , string version , string filename , properties props ) throws ioexception { props . put ( file_name_property , filename ) ; props . put ( version_property , version ) ; props . put ( artifact_property , artifact ) ; storeproperties ( artifact , version , props ) ; try ( outputstream out = newoutputstream ( getartifact ( artifact , version , filename ) ) ) { ioutils . copylarge ( in , out ) ; } finally { in . close ( ) ; } }	uploads artifact into the repository .
static string escapebytes ( final bytestring input ) { final stringbuilder builder = new stringbuilder ( input . size ( ) ) ; for ( int i = _num ; i < input . size ( ) ; i ++ ) { final byte b = input . byteat ( i ) ; switch ( b ) { case _num : builder . append ( _str ) ; break ; case _str : builder . append ( _str ) ; break ; case _str : builder . append ( _str ) ; break ; case _str : builder . append ( _str ) ; break ; case _str : builder . append ( _str ) ; break ; case _str : builder . append ( _str ) ; break ; case _num : builder . append ( _str ) ; break ; case _str : builder . append ( _str ) ; break ; case _str : builder . append ( _str ) ; break ; case _str : builder . append ( _str ) ; break ; default : if ( b >= _num ) { builder . append ( ( char ) b ) ; } else { builder . append ( _str ) ; builder . append ( ( char ) ( _str + ( ( b > > > _num ) & _num ) ) ) ; builder . append ( ( char ) ( _str + ( ( b > > > _num ) & _num ) ) ) ; builder . append ( ( char ) ( _str + ( b & _num ) ) ) ; } break ; } } return builder . tostring ( ) ; }	escapes bytes in the format used in protocol buffer text format , which is the same as the format used for c string literals.
private static class < ? > [ ] types ( object ... values ) { if ( values == null ) { return new class [ _num ] ; } class < ? > [ ] result = new class [ values . length ] ; for ( int i = _num ; i < values . length ; i ++ ) { object value = values [ i ] ; result [ i ] = value == null ? null . class : value . getclass ( ) ; } return result ; }	get an array of types for an array of objects.
public void addtoparent ( element headere ) throws exception { document doc = headere . getownerdocument ( ) ; element securitye = doc . createelementns ( wssens , wsseconstants . tag_wsse + _str + wsseconstants . tag_securityt ) ; securitye . setattributens ( soapbindingconstants . ns_xml , wsseconstants . tag_xml_wsse , wssens ) ; headere . appendchild ( securitye ) ; document binarytokend = xmlutils . todomdocument ( tostring ( ) , debug ) ; element binarytokene = binarytokend . getdocumentelement ( ) ; securitye . appendchild ( doc . importnode ( binarytokene , _bool ) ) ; }	adds th binary security token to the header element .
public final static int skipspaces ( final string in , final int start ) { int pos = start ; while ( pos < in . length ( ) && ( in . charat ( pos ) == _str || in . charat ( pos ) == _str ) ) { pos ++ ; } return pos < in . length ( ) ? pos : - _num ; }	skips spaces in the given string .
public void update ( ) { if ( amplitude > _num ) { long elapsed = system . currenttimemillis ( ) - timestamp ; double delta = amplitude * math . exp ( - elapsed / timeconstant ) ; if ( math . abs ( delta ) > _num ) { viewpointnode . drag ( lastdx * delta , lastdy * delta ) ; } else { amplitude = _num ; updatelookat ( ) ; } } }	update the kinetic scrolling.
@ override public assignment sample ( ) { if ( ! samples . isempty ( ) ) { int selection = sampler . nextint ( samples . size ( ) ) ; assignment selected = samples . get ( selection ) ; return selected ; } else { log . warning ( _str ) ; return new assignment ( ) ; } }	samples from the distribution . in this case , simply selects one arbitrary sample out of the set defining the distribution.
@ sneakythrows public static x509certificate readcertificate ( inputstream is ) { return ( x509certificate ) cert_factory . generatecertificate ( is ) ; }	reads x509certificate object from given input stream .
public guacamolehttptunnelmap ( ) { executor . scheduleatfixedrate ( new tunneltimeouttask ( tunnel_timeout * _num ) , tunnel_timeout , tunnel_timeout , timeunit . seconds ) ; }	creates a new guacamolehttptunnelmap which automatically closes and removes http tunnels which are no longer in use .
default b with ( string key , class < ? > value ) { return with ( key , value != null ? value . getname ( ) : null ) ; }	associate the given class name value with the specified key .
private void rename ( table table ) { if ( renamedefinitions != null ) { for ( column col : table . getallcolumns ( ) ) { string newcolname = renamedefinitions . getnewcolumnname ( table . getschema ( ) , table . getname ( ) , col . getname ( ) ) ; if ( newcolname != null ) col . setname ( newcolname ) ; } string newtablename = renamedefinitions . getnewtablename ( table . getschema ( ) , table . getname ( ) ) ; string newschemaname = renamedefinitions . getnewschemaname ( table . getschema ( ) , table . getname ( ) ) ; if ( newtablename != null ) table . settable ( newtablename ) ; if ( newschemaname != null ) table . setschema ( newschemaname ) ; } }	if renamedefinitions object is prepared , does the lookup and renaming of schema , table and columns.
private void handlereadlastconfirmederror ( int rc ) { if ( bkexception . code . nosuchledgerexistsexception == rc ) { if ( bkcnoledgerexceptionsonreadlac . incrementandget ( ) > noledgerexceptiononreadlacthreshold ) { log . info ( _str , new object [ ] { fullyqualifiedname , currentlh , conf . getreadaheadnosuchledgerexceptiononreadlacerrorthresholdmillis ( ) } ) ; bkcnoledgerexceptionsonreadlac . set ( _num ) ; if ( closecurrentledgerhandle ( ) ) { next . process ( bkexception . code . ok ) ; } return ; } else { if ( log . istraceenabled ( ) ) { log . info ( _str , new object [ ] { fullyqualifiedname , currentlh , conf . getreadaheadwaittime ( ) } ) ; } schedule ( readaheadworker . this , conf . getreadaheadwaittime ( ) ) ; return ; } } else if ( bkexception . code . ok != rc ) { handleexception ( readaheadphase . read_last_confirmed , rc ) ; return ; } }	handle the result of reading last add confirmed .
public synchronized boolean put ( long fp ) { int index = ( int ) ( fp & this . mask ) ; long [ ] list = this . table [ index ] ; if ( list != null ) { int listlen = list . length ; for ( int i = _num ; i < listlen ; i ++ ) { if ( list [ i ] == fp ) return _bool ; } } if ( count >= threshold ) { rehash ( ) ; index = ( int ) ( fp & this . mask ) ; list = this . table [ index ] ; } int len = ( list == null ? _num : list . length ) ; long [ ] newlist = new long [ len + _num ] ; if ( list != null ) system . arraycopy ( list , _num , newlist , _num , len ) ; newlist [ len ] = fp ; this . table [ index ] = newlist ; this . count ++ ; return _bool ; }	tests if the specified fingerprint is in this set.
public void applylayout ( ) { layout . setinitiallocation ( getposition ( ) ) ; layout . layoutneurons ( getneuronlist ( ) ) ; }	apply this group ' s layout to its neurons .
public int nice ( ) { return integer . parseint ( fields [ _num ] ) ; }	the nice value ( see setpriority ( 2 ) ) , a value in the range 19 ( low priority ) to - 20 ( high priority ) .
float layersize ( int p_76490_1_ ) { if ( ( float ) p_76490_1_ < ( float ) this . heightlimit * _num ) { return - _num ; } else { float f = ( float ) this . heightlimit / _num ; float f1 = f - ( float ) p_76490_1_ ; float f2 = mathhelper . sqrt_float ( f * f - f1 * f1 ) ; if ( f1 == _num ) { f2 = f ; } else if ( math . abs ( f1 ) >= f ) { return _num ; } return f2 * _num ; } }	gets the rough size of a layer of the tree .
public static method findstaticmethod ( class < ? > type , string name , class < ? > ... args ) throws nosuchmethodexception { method method = findmethod ( type , name , args ) ; if ( ! modifier . isstatic ( method . getmodifiers ( ) ) ) { throw new nosuchmethodexception ( _str + name + _str ) ; } return method ; }	finds public static method that is accessible from public class .
private void fetchsearchservicecardsfromserver ( string keyword , string categoryid ) { final map < string , string > params = new hashmap < string , string > ( _num ) ; params . put ( httpconstants . latitude , sharedpreferencehelper . getstring ( r . string . pref_latitude ) ) ; params . put ( httpconstants . longitude , sharedpreferencehelper . getstring ( r . string . pref_longitude ) ) ; params . put ( httpconstants . type , httpconstants . searchtype . service_card ) ; params . put ( httpconstants . group_id , categoryid ) ; params . put ( httpconstants . per , _str ) ; params . put ( httpconstants . radius , _str ) ; params . put ( httpconstants . title , keyword ) ; retrocallback retrocallback ; retrocallback = new retrocallback ( this ) ; retrocallback . setrequestid ( httpconstants . apiresponsecodes . search_services ) ; retrocallbacklist . add ( retrocallback ) ; params . put ( httpconstants . page , _str ) ; myeloapi . getservicecards ( params , retrocallback ) ; mswiperefreshlayout . setrefreshing ( _bool ) ; }	helper http function to get list of my service cards based on keyword and category.
public void addphonenumber ( string aphonenumber ) { if ( mphonenumbers . indexof ( aphonenumber ) < _num ) { mphonenumbers . add ( aphonenumber ) ; } }	add a phone number address to the list .
public static final string digitsandplusonly ( matcher matcher ) { stringbuilder buffer = new stringbuilder ( ) ; string matchingregion = matcher . group ( ) ; for ( int i = _num , size = matchingregion . length ( ) ; i < size ; i ++ ) { char character = matchingregion . charat ( i ) ; if ( character == _str || character . isdigit ( character ) ) { buffer . append ( character ) ; } } return buffer . tostring ( ) ; }	convenience method to return only the digits and plus signs in the matching string .
boolean comparemethods ( method a , method b ) { if ( ( a == null ) != ( b == null ) ) { return _bool ; } if ( a != null && b != null ) { if ( ! a . equals ( b ) ) { return _bool ; } } return _bool ; }	package private helper method for descriptor.
markersegment findmarkersegment ( int tag ) { iterator iter = markersequence . iterator ( ) ; while ( iter . hasnext ( ) ) { markersegment seg = ( markersegment ) iter . next ( ) ; if ( seg . tag == tag ) { return seg ; } } return null ; }	returns the first markersegment object in the list with the given tag , or null if none is found .
private static reader openinput ( string from ) { try { return cliutils . reader ( from ) ; } catch ( ioexception e ) { log . error ( _str , e ) ; system . exit ( _num ) ; return null ; } }	open the input using the " from " parameter , exiting on failure .
public publisherconcatarray < t > concatadditionalsourcefirst ( publisher < ? extends t > source ) { int n = array . length ; @ suppresswarnings ( _str ) publisher < ? extends t > [ ] newarray = new publisher [ n + _num ] ; system . arraycopy ( array , _num , newarray , _num , n ) ; newarray [ _num ] = source ; return new publisherconcatarray < > ( delayerror , newarray ) ; }	returns a new instance which has the additional first source to be concatenated together with the current array of sources.
protected void dopublish ( string tenantid , list < t > items , string subscriber , int retrycount , long delay ) throws exception { string data = mapper . writevalueasstring ( items ) ; textmessage tm = session . createtextmessage ( data ) ; if ( tenantid != null ) { tm . setstringproperty ( _str , tenantid ) ; } if ( subscriber != null ) { tm . setstringproperty ( _str , subscriber ) ; } tm . setintproperty ( _str , retrycount ) ; if ( delay > _num ) { tm . setlongproperty ( _str , system . currenttimemillis ( ) + delay ) ; } if ( log . isloggable ( level . finest ) ) { log . finest ( _str + tm ) ; } producer . send ( tm ) ; }	this method publishes the supplied items .
@ override public boolean eisset ( int featureid ) { switch ( featureid ) { case mappingpackage . attribute__name : return name_edefault == null ? name != null : ! name_edefault . equals ( name ) ; case mappingpackage . attribute__value : return value_edefault == null ? value != null : ! value_edefault . equals ( value ) ; } return super . eisset ( featureid ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
protected void checkvalid ( ) throws uriexception { if ( ! ( equals ( _scheme , default_scheme ) || _scheme == null ) ) { throw new uriexception ( uriexception . parsing , _str ) ; } }	verify the valid class use for construction .
public privatekeyusageextension ( boolean critical , object value ) throws certificateexception , ioexception { this . extensionid = pkixextensions . privatekeyusage_id ; this . critical = critical . booleanvalue ( ) ; this . extensionvalue = ( byte [ ] ) value ; derinputstream str = new derinputstream ( this . extensionvalue ) ; dervalue [ ] seq = str . getsequence ( _num ) ; for ( int i = _num ; i < seq . length ; i ++ ) { dervalue opt = seq [ i ] ; if ( opt . iscontextspecific ( tag_before ) && ! opt . isconstructed ( ) ) { if ( notbefore != null ) { throw new certificateparsingexception ( _str ) ; } opt . resettag ( dervalue . tag_generalizedtime ) ; str = new derinputstream ( opt . tobytearray ( ) ) ; notbefore = str . getgeneralizedtime ( ) ; } else if ( opt . iscontextspecific ( tag_after ) && ! opt . isconstructed ( ) ) { if ( notafter != null ) { throw new certificateparsingexception ( _str ) ; } opt . resettag ( dervalue . tag_generalizedtime ) ; str = new derinputstream ( opt . tobytearray ( ) ) ; notafter = str . getgeneralizedtime ( ) ; } else throw new ioexception ( _str + _str ) ; } }	create the extension from the passed der encoded value .
@ override public list < period > generateperiods ( datetimeunit datetimeunit ) { calendar cal = getcalendar ( ) ; datetimeunit . setmonth ( _num ) ; datetimeunit . setday ( _num ) ; list < period > periods = lists . newarraylist ( ) ; int year = datetimeunit . getyear ( ) ; while ( datetimeunit . getyear ( ) == year ) { periods . add ( createperiod ( datetimeunit , cal ) ) ; datetimeunit = cal . plusmonths ( datetimeunit , _num ) ; } return periods ; }	generates bimonthly periods for the whole year in which the start date of the given period exists .
public static secretkey createaeskey ( ) { try { final keygenerator kgen = keygenerator . getinstance ( _str ) ; final int keysize = _num ; kgen . init ( keysize ) ; return kgen . generatekey ( ) ; } catch ( final nosuchalgorithmexception e ) { e . printstacktrace ( ) ; } return null ; }	generates a random aes key for encrypting / decrypting the turnover value attention : in a real cash box this key would be generated during the init process and stored in a secure area.
@ override public void valuechange ( valuechangeevent e ) { string name = e . getpropertyname ( ) ; object value = e . getnewvalue ( ) ; log . config ( name + _str + value ) ; if ( value == null ) return ; }	vetoable change listener . - business partner - currency - date.
@ deprecated public static jsonobject parsejson ( string response ) throws jsonexception , facebookerror { if ( response . equals ( _str ) ) { throw new facebookerror ( _str ) ; } if ( response . equals ( _str ) ) { response = _str ; } jsonobject json = new jsonobject ( response ) ; if ( json . has ( _str ) ) { jsonobject error = json . getjsonobject ( _str ) ; throw new facebookerror ( error . getstring ( _str ) , error . getstring ( _str ) , _num ) ; } if ( json . has ( _str ) && json . has ( _str ) ) { throw new facebookerror ( json . getstring ( _str ) , _str , integer . parseint ( json . getstring ( _str ) ) ) ; } if ( json . has ( _str ) ) { throw new facebookerror ( _str , _str , integer . parseint ( json . getstring ( _str ) ) ) ; } if ( json . has ( _str ) ) { throw new facebookerror ( json . getstring ( _str ) ) ; } if ( json . has ( _str ) ) { throw new facebookerror ( json . getstring ( _str ) ) ; } return json ; }	parse a server response into a json object.
public spyversions loadversions ( ) throws xmlexception { setloading ( _bool ) ; final string urlstring = propertyloader . getproperty ( basepropertynames . version_info_url ) + _str + currentrelease ; try { final url url = new url ( urlstring ) ; final string xml = ioutils . tostring ( url . openstream ( ) ) ; versions = ( spyversions ) loadfromstring ( xml ) ; } catch ( ioexception | nullpointerexception e ) { throw new xmlexception ( _str + urlstring , e ) ; } setloading ( _bool ) ; return versions ; }	loads version information from the url .
@ requestmapping ( value = _str , method = post , produces = application_json_value ) public responseentity < pageresponse < userdto > > findall ( @ requestbody pagerequestbyexample < userdto > prbe ) throws urisyntaxexception { pageresponse < userdto > pageresponse = userdtoservice . findall ( prbe ) ; return new responseentity < > ( pageresponse , new httpheaders ( ) , httpstatus . ok ) ; }	find a page of user using query by example .
public void addfooterview ( view view ) { mfooterviews . add ( view ) ; notifydatasetchanged ( ) ; }	add a static view to appear at the end of the recyclerview.
public void addfirst ( string seq ) { queue = seq + queue . substring ( pos ) ; pos = _num ; }	add a string to the start of the queue .
public boolean isreadonly ( boolean usesessionstatus ) throws sqlexception { if ( usesessionstatus && ! this . isclosed && versionmeetsminimum ( _num , _num , _num ) && ! getuselocalsessionstate ( ) && getreadonlypropagatestoserver ( ) ) { java . sql . statement stmt = null ; java . sql . resultset rs = null ; try { try { stmt = getmetadatasafestatement ( ) ; rs = stmt . executequery ( _str ) ; if ( rs . next ( ) ) { return rs . getint ( _num ) != _num ; } } catch ( sqlexception ex1 ) { if ( ex1 . geterrorcode ( ) != mysqlerrornumbers . er_must_change_password || getdisconnectonexpiredpasswords ( ) ) { throw sqlerror . createsqlexception ( _str , sqlerror . sql_state_general_error , ex1 , getexceptioninterceptor ( ) ) ; } } } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( exception ex ) { } rs = null ; } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( exception ex ) { } stmt = null ; } } } return this . readonly ; }	tests to see if the connection is in read only mode.
public void testconsume ( ) { atomicinteger sum = new atomicinteger ( ) ; submissionpublisher < integer > p = basicpublisher ( ) ; completablefuture < void > f = p . consume ( null ) ; int n = _num ; for ( int i = _num ; i <= n ; ++ i ) p . submit ( i ) ; p . close ( ) ; f . join ( ) ; assertequals ( ( n * ( n + _num ) ) / _num , sum . get ( ) ) ; }	consume returns a completablefuture that is done when publisher completes.
public void exprsetparent ( expressionnode n ) { super . exprsetparent ( n ) ; int nargs = m_argvec . size ( ) ; for ( int i = _num ; i < nargs ; i ++ ) { expression arg = ( expression ) m_argvec . elementat ( i ) ; arg . exprsetparent ( n ) ; } }	set the parent node.
public final boolean isregistered ( ) { return ! canonicalname . startswith ( _str ) && ! canonicalname . startswith ( _str ) ; }	returns true if this charset is known to be registered in the iana charset registry .
private static downscalequality addconstant ( string type ) { init ( ) ; if ( constlist . containskey ( type ) ) { throw new runtimeexception ( _str + type + _str ) ; } downscalequality q = new downscalequality ( type ) ; constlist . put ( type , q ) ; return q ; }	create and add constant instance.
public void bail ( string message , boolean printusagestatement ) { debug . output ( message ) ; if ( printusagestatement ) printusage ( ) ; system . exit ( _num ) ; }	called if something is messed up.
private void asserttimestampsequalwithepsilon ( long expected , long actual , int epsilon , string desc ) { asserttrue ( _str + desc + _str + epsilon + _str + expected + _str + actual , math . abs ( actual - expected ) < epsilon ) ; }	kinda like the junit asserts for doubles , which allows an " epsilon " but this is for integers , and with a specific description in the assert just for timestamps . all times are expected in milliseconds.
public spidersitemapxmlparser ( spiderparam params ) { super ( ) ; if ( params == null ) { throw new illegalargumentexception ( _str ) ; } this . params = params ; }	instantiates a new sitemap.
public boolean flush ( boolean deaccelerated ) ;	flush all cached resources.
public void addhop ( int id ) { if ( entities == null ) { return ; } hopsnumber ++ ; entities . add ( integer . valueof ( id ) ) ; }	add an entity where the infopacket traverses.
public boolean isempty ( ) { return meventqueue . isempty ( ) ; }	determines if the event queue is empty .
public static void testprimitiveinstantiation ( ) { testprimitiveinstantiation ( _bool ) ; }	test that all of the graphicsprimitiveproxy objects actually resolve to something.
public void readentries ( tablekelp table , insegment reader , segmententrycallback cb ) { tempbuffer tbuf = tempbuffer . createlarge ( ) ; byte [ ] buffer = tbuf . buffer ( ) ; instore sin = reader . getstoreread ( ) ; byte [ ] tablekey = new byte [ tablekelp . table_key_size ] ; for ( int ptr = length ( ) - block_size ; ptr > _num ; ptr -= block_size ) { sin . read ( getaddress ( ) + ptr , buffer , _num , buffer . length ) ; int index = _num ; long seq = bitsutil . readlong ( buffer , index ) ; index += _num ; if ( seq != getsequence ( ) ) { log . warning ( l . l ( _str , seq , getsequence ( ) , long . tohexstring ( getaddress ( ) + ptr ) ) ) ; break ; } system . arraycopy ( buffer , index , tablekey , _num , tablekey . length ) ; index += tablekey . length ; if ( ! arrays . equals ( tablekey , _tablekey ) ) { log . warning ( l . l ( _str , hex . toshorthex ( tablekey ) , hex . toshorthex ( _tablekey ) , long . tohexstring ( getaddress ( ) + ptr ) ) ) ; break ; } int head = index ; while ( head < block_size && buffer [ head ] != _num ) { head = readentry ( table , buffer , head , cb , getaddress ( ) ) ; } boolean iscont = buffer [ head + _num ] != _num ; if ( ! iscont ) { break ; } } tbuf . free ( ) ; }	reads index entries from the segment.
static int numberofhosts ( map < uri , list < initiator > > net2initiatorsmap ) { set < uri > hostset = new hashset < uri > ( ) ; for ( list < initiator > initiators : net2initiatorsmap . values ( ) ) { for ( initiator init : initiators ) { hostset . add ( init . gethost ( ) ) ; } } return hostset . size ( ) ; }	returns number of hosts in the net2initiatorsmap.
public void addcertificates ( store certstore ) throws cmsexception { certs . addall ( cmsutils . getcertificatesfromstore ( certstore ) ) ; }	add the certificates in certstore to the certificate set to be included with the generated signeddata message .
protected void processlob ( lobmetadata lob , databasemapping mapping , metadataclass referenceclass , boolean isformapkey ) { lob . process ( mapping , this , referenceclass , isformapkey ) ; }	internal : process a lob specification.
protected attributesimpl startprefixmapping ( element element , namespacestack namespacestack ) throws saxexception { attributesimpl namespaceattributes = null ; namespace elementnamespace = element . getnamespace ( ) ; if ( ( elementnamespace != null ) && ! isignoreablenamespace ( elementnamespace , namespacestack ) ) { namespacestack . push ( elementnamespace ) ; contenthandler . startprefixmapping ( elementnamespace . getprefix ( ) , elementnamespace . geturi ( ) ) ; namespaceattributes = addnamespaceattribute ( namespaceattributes , elementnamespace ) ; } list < namespace > declarednamespaces = element . declarednamespaces ( ) ; for ( namespace namespace : declarednamespaces ) { if ( ! isignoreablenamespace ( namespace , namespacestack ) ) { namespacestack . push ( namespace ) ; contenthandler . startprefixmapping ( namespace . getprefix ( ) , namespace . geturi ( ) ) ; namespaceattributes = addnamespaceattribute ( namespaceattributes , namespace ) ; } } return namespaceattributes ; }	fires a sax startprefixmapping event for all the namespacestack which have just come into scope.
public void printstacktrace ( java . io . printwriter pw ) { if ( rootcause != null ) { string superstring = super . tostring ( ) ; synchronized ( pw ) { pw . print ( superstring + ( superstring . endswith ( _str ) ? _str : _str ) + _str ) ; rootcause . printstacktrace ( pw ) ; } } else { super . printstacktrace ( pw ) ; } }	prints this exception ' s stack trace to a print writer.
private static dataflavor [ ] converttoarray ( list < dataflavor > dataflavourlist ) { dataflavor [ ] array = new dataflavor [ dataflavourlist . size ( ) ] ; dataflavourlist . toarray ( array ) ; return array ; }	convert dataflavor list to array .
public void testchoiceemptyiconerrorhandling ( ) { string xml = _str ; xml += createstartmissionxml ( _str , _str ) ; xml += createstartchoicemomentxml ( _str , _num , _str , _str ) ; xml += createchoicexml ( _str , _str , _str , _bool , _bool , _str ) ; xml += createchoicexml ( _str , _str , _str , _bool , _bool , _str ) ; xml += createendchoicemomentxml ( ) ; xml += createendchoicemomentxml ( ) ; xml += createendmissionxml ( ) ; utils . logdebug ( tag , xml ) ; inputstream momentinputstream = new bytearrayinputstream ( xml . getbytes ( ) ) ; mmission = new mission ( mmissiondata ) ; boolean didmissionparsefail = _bool ; try { mmission . readmoments ( momentinputstream ) ; } catch ( missionparseexception e ) { e . printstacktrace ( ) ; didmissionparsefail = _bool ; } assert . assertequals ( _bool , didmissionparsefail ) ; }	test for correct error handling for a choice that has an empty icon element .
public static string translateattribute ( string attributes ) throws ioexception { short [ ] flags = strattrtobooleanflags ( attributes ) ; stringbuilder sb = new stringbuilder ( ) ; if ( flags [ read_only ] == yes ) sb . append ( _str ) ; else if ( flags [ read_only ] == no ) sb . append ( _str ) ; if ( flags [ hidden ] == yes ) sb . append ( _str ) ; else if ( flags [ hidden ] == no ) sb . append ( _str ) ; if ( flags [ system ] == yes ) sb . append ( _str ) ; else if ( flags [ system ] == no ) sb . append ( _str ) ; if ( flags [ archive ] == yes ) sb . append ( _str ) ; else if ( flags [ archive ] == no ) sb . append ( _str ) ; return sb . tostring ( ) ; }	sets attributes of a file on windows system.
public static int nextindexid ( ) { return msgidx . getandincrement ( ) ; }	gets next id for indexed message id .
private void fillfieldvalues ( ) { if ( iscreationpanel ) { phrase . settext ( _str + hearing . default_phrase ) ; outputamount . settext ( _str + hearing . default_output_amount ) ; } else { phrase . settext ( _str + hearingsensor . getphrase ( ) ) ; outputamount . settext ( _str + hearingsensor . getoutputamount ( ) ) ; } }	set the current values of all fields .
public static boolean checksecurityinfos ( string endpoint , identity clientidentity , list < securityinfo > securityinfos ) { if ( clientidentity . issecure ( ) ) { if ( securityinfos == null || securityinfos . isempty ( ) ) { log . warn ( _str , endpoint ) ; return _bool ; } else { for ( securityinfo securityinfo : securityinfos ) { if ( checksecurityinfo ( endpoint , clientidentity , securityinfo ) ) { return _bool ; } } return _bool ; } } else if ( securityinfos != null && ! securityinfos . isempty ( ) ) { log . warn ( _str , endpoint ) ; return _bool ; } return _bool ; }	return true if any of the securityinfos is valid for the given endpoint and client identity .
public boolean retainall ( abstractintlist other ) { if ( other . size ( ) == _num ) { if ( size == _num ) return _bool ; setsize ( _num ) ; return _bool ; } int limit = other . size ( ) - _num ; int j = _num ; for ( int i = _num ; i < size ; i ++ ) { if ( other . indexoffromto ( getquick ( i ) , _num , limit ) >= _num ) setquick ( j ++ , getquick ( i ) ) ; } boolean modified = ( j != size ) ; setsize ( j ) ; return modified ; }	retains ( keeps ) only the elements in the receiver that are contained in the specified other list.
public static arraylist < bytestring > bytearraystostrings ( arraylist < byte [ ] > bytearrays ) { if ( bytearrays == null ) { return null ; } arraylist < bytestring > bytestrings = new arraylist < bytestring > ( ) ; for ( byte [ ] bytes : bytearrays ) { bytestrings . add ( bytestring . of ( bytes ) ) ; } return bytestrings ; }	converts an arraylist < byte [ ] > to an arraylist < bytestring >.
void addindex ( indextype type , list < string > columnnames ) { indexdefinition index = new indexdefinition ( ) ; index . indexname = tablename + _str + indexes . size ( ) ; index . columnnames = new . arraylist ( columnnames ) ; index . type = type ; indexes . add ( index ) ; }	defines an index with the specified column names .
public builder withkeystorekeypassword ( string keystorekeypassword ) { properties . setproperty ( nettyoptions . ssl_key_store_key_password , assert . notnull ( keystorekeypassword , _str ) ) ; return this ; }	sets the ssl key store key password .
public zookeeperstatemachineensemble ( curatorframework curatorclient , string basepath ) { this ( curatorclient , basepath , _bool , default_logsize ) ; }	instantiates a new zookeeper state machine ensemble .
public static customshortcutset createshortcut ( char ch ) { character mnemonic = character . valueof ( ch ) ; string shortcut = systeminfo . ismac && systeminfo . isjavaversionatleast ( _str ) ? _str + mnemonic : _str + mnemonic ; return customshortcutset . fromstring ( shortcut ) ; }	creates shortcut for mnemonic replacing standard alt + letter to ctrl + alt + letter on mac with jdk version newer than 6.
private node deletemin ( node x ) { if ( x . left == null ) return x . right ; x . left = deletemin ( x . left ) ; x . size = _num + size ( x . left ) + size ( x . right ) ; x . height = _num + math . max ( height ( x . left ) , height ( x . right ) ) ; return balance ( x ) ; }	removes the smallest key and associated value from the given subtree .
public static void resetcounters ( ) { errors = _num ; warnings = _num ; }	reset error and warning counters.
public void write ( ceylonconfig config , file source , outputstream out ) throws ioexception { if ( source . isfile ( ) ) { inputstream in = null ; try { in = new fileinputstream ( source ) ; write ( config , in , out ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( ioexception e ) { } } } } else { throw new filenotfoundexception ( _str ) ; } }	reads config from the given source file , updating it using the given configuration and writing in to the given output .
protected map < targetclass , list < attribute . typecompound > > sift ( final iterable < attribute . typecompound > typecompounds ) { final map < targetclass , list < attribute . typecompound > > targetclasstocompound = new enummap < > ( targetclass . class ) ; for ( targetclass targetclass : targetclass . values ( ) ) { targetclasstocompound . put ( targetclass , new arraylist < typecompound > ( ) ) ; } for ( final attribute . typecompound typecompound : typecompounds ) { final targettype typecompoundtarget = typecompound . position . type ; final list < attribute . typecompound > destlist ; if ( elementannotationutil . contains ( typecompoundtarget , annotatedtargets ( ) ) ) { destlist = targetclasstocompound . get ( targetclass . targeted ) ; } else if ( elementannotationutil . contains ( typecompoundtarget , validtargets ( ) ) ) { destlist = targetclasstocompound . get ( targetclass . valid ) ; } else { destlist = targetclasstocompound . get ( targetclass . invalid ) ; } destlist . add ( typecompound ) ; } return targetclasstocompound ; }	separate the input annotations into a map of targetclass ( targeted , valid , invalid ) to the annotations that fall into each of those categories .
protected synchronized void updatelocation ( point newlocn ) { prev = locn ; locn = newlocn ; if ( math . abs ( locn . x - prev . x ) > hysteresis || math . abs ( locn . y - prev . y ) > hysteresis ) { if ( timer . isrunning ( ) ) timer . stop ( ) ; } else { if ( ! timer . isrunning ( ) ) timer . start ( ) ; } }	cause autoscroll to occur < p >.
@ override public int compareto ( value o ) { if ( o instanceof stringval ) { return str . compareto ( ( ( stringval ) o ) . str ) ; } else { return _num ; } }	compares the string value to another value.
public void bind ( integerproperty property , int value ) { if ( isachieved ( ) ) return ; bind ( property . greaterthanorequalto ( value ) ) ; booleanbinding bb = property . greaterthanorequalto ( value / _num ) ; progresslistener = null ; bb . addlistener ( progresslistener ) ; }	bind achievement condition to given property .
public void removecolumn ( column c ) { int idx = m_columns . indexof ( c ) ; if ( idx < _num ) { throw new illegalargumentexception ( _str ) ; } removecolumn ( idx ) ; }	remove a column from this table.
public synchronized void write ( string logdata ) { if ( logenabled ) { histdata . append ( logdata ) ; histdata . revalidate ( ) ; synchronized ( histdata ) { histdata . notify ( ) ; } } }	append text to the log , repaint the window and notify the autoscroll thread to scroll to the end of the text area .
public void closeconnection ( ) { try { if ( m_connection != null ) { m_connection . close ( ) ; } } catch ( final sqlexception exception ) { navilogger . severe ( _str , exception ) ; } m_connection = null ; }	closes the connection to the database .
public structembayessearcheditor ( structembayessearchrunner sembayesestwrapper ) { this ( sembayesestwrapper . getestimatedbayesim ( ) , sembayesestwrapper . getdataset ( ) ) ; }	constructs a new bayes im editor from a bayes estimator wrapper .
public void removeactionlistener ( actionlistener listener ) { forwardprojectionbutton . addactionlistener ( listener ) ; backprojectionbutton . addactionlistener ( listener ) ; }	removes the listener for events that shift the projection stack .
boolean isliteral ( int index ) { if ( isvalidmask ( ) && index < string . length ( ) ) { return literalmask . get ( index ) ; } return _bool ; }	returns true if the character at index is a literal , that is not editable .
protected granularity generategranularity ( string granularity , granularityparser granularityparser ) throws badapirequestexception { try { return granularityparser . parsegranularity ( granularity ) ; } catch ( granularityparseexception e ) { log . error ( unknown_granularity . logformat ( granularity ) , granularity ) ; throw new badapirequestexception ( e . getmessage ( ) ) ; } }	generate a granularity instance based on a path element .
public worditerator ( ) { this ( locale . getdefault ( ) ) ; }	constructs a worditerator using the default locale .
@ override public void close ( ) { if ( leaf != null ) { leaf . close ( ) ; leaf = null ; } ccmgr . releaseindexlocks ( ) ; dirsmaybeupdated = null ; }	closes the index by closing its open leaf page , if necessary .
public void pushfile ( string local , string remote , isyncprogressmonitor monitor ) throws syncexception , ioexception , timeoutexception { file f = new file ( local ) ; if ( ! f . exists ( ) ) { throw new syncexception ( syncerror . no_local_file ) ; } if ( f . isdirectory ( ) ) { throw new syncexception ( syncerror . local_is_directory ) ; } monitor . start ( ( int ) f . length ( ) ) ; dopushfile ( local , remote , monitor ) ; monitor . stop ( ) ; }	push a single file .
public string process ( item seg ) throws processexception { return segcodactype ( seg , _str ) ; }	performs some processing on the given item .
public void resize ( int size ) { if ( buffer != null ) { if ( size >= _num && size < buffer . size ( ) ) { int oldlastindex = buffer . size ( ) - _num ; int newlastindex = size - _num ; for ( int i = oldlastindex ; i > newlastindex ; i -- ) { buffer . remove ( i ) ; } } } else { if ( size >= _num && size < offsets . size ( ) ) { long offset = offsets . get ( size ) ; bytecache . resize ( key , offset ) ; arraylist < long > newoffsets = new arraylist < long > ( size ) ; for ( int i = _num ; i < size ; i ++ ) { newoffsets . add ( offsets . get ( i ) ) ; } offsets = newoffsets ; } } }	resizes the array to contain a smaller number of elements.
public static byte [ ] splituint8to2bytes ( char uint8 ) { if ( uint8 < _num || uint8 > _num ) { throw new runtimeexception ( _str ) ; } string hexstring = integer . tohexstring ( uint8 ) ; byte low ; byte high ; if ( hexstring . length ( ) > _num ) { high = ( byte ) integer . parseint ( hexstring . substring ( _num , _num ) , _num ) ; low = ( byte ) integer . parseint ( hexstring . substring ( _num , _num ) , _num ) ; } else { high = _num ; low = ( byte ) integer . parseint ( hexstring . substring ( _num , _num ) , _num ) ; } byte [ ] result = new byte [ ] { high , low } ; return result ; }	split uint8 to 2 bytes of high byte and low byte.
protected void sprint ( short shortfield ) { sprint ( string . valueof ( shortfield ) ) ; }	pretty printing accumulator function for shorts.
protected void initfromdir ( string prefix , file dir ) { file [ ] files ; files = dir . listfiles ( new classfilefilter ( ) ) ; for ( file file : files ) { if ( prefix == null ) { add ( file . getname ( ) ) ; } else { add ( prefix + _str + file . getname ( ) ) ; } } files = dir . listfiles ( new directoryfilter ( ) ) ; for ( file file : files ) { if ( prefix == null ) { initfromdir ( file . getname ( ) , file ) ; } else { initfromdir ( prefix + _str + file . getname ( ) , file ) ; } } }	fills the class cache with classes in the specified directory .
public void removebandwidth ( string name ) { if ( name != null ) if ( bandwidthlist != null ) { for ( int i = _num ; i < bandwidthlist . size ( ) ; i ++ ) { object o = bandwidthlist . elementat ( i ) ; if ( o instanceof bandwidthfield ) { bandwidthfield b = ( bandwidthfield ) o ; try { string type = b . gettype ( ) ; if ( type != null ) { if ( name . equals ( type ) ) { bandwidthlist . remove ( b ) ; } } } catch ( sdpparseexception e ) { } } } } }	removes the specified bandwidth type .
protected static void succeed ( ) { system . exit ( _num ) ; }	exit with a process success code .
public static long now ( ) { return system . currenttimemillis ( ) ; }	get the current time .
public static string collapsenewlines ( string argstr ) { char last = argstr . charat ( _num ) ; stringbuffer argbuf = new stringbuffer ( ) ; for ( int cidx = _num ; cidx < argstr . length ( ) ; cidx ++ ) { char ch = argstr . charat ( cidx ) ; if ( ch != _str || last != _str ) { argbuf . append ( ch ) ; last = ch ; } } return argbuf . tostring ( ) ; }	remove / collapse multiple newline characters .
@ override protected string generatejavadoc ( int index ) throws exception { throw new exception ( _str ) ; }	generates and returns the javadoc for the specified start / end tag pair .
public properties extractproperties ( iterable < map . entry < string , string > > propsrc ) { properties result = new properties ( ) ; for ( map . entry < string , string > entry : propsrc ) { string name = entry . getkey ( ) ; if ( isnamespacedproperty ( name ) ) { string val = entry . getvalue ( ) ; result . setproperty ( name , val ) ; } } return result ; }	extract all properties in this namespace that can be found in the provided property source.
public t removelast ( ) { if ( rows . size ( ) != _num ) rows . remove ( rows . size ( ) - _num ) ; return instance ( ) ; }	remove the last row .
public static void ensurevisible ( string componentname ) { if ( verbose ) { log ( _str + componentname + _str ) ; } ensurevisible ( findbyname ( componentname ) ) ; }	scrolls to show the component in case it is invisible currently.
public void endrepresentation ( ) { if ( ! representationprotectionsset ) { if ( currentrepresentationprotections != null ) { collections . sort ( currentrepresentationprotections , this ) ; } representationprotections = currentrepresentationprotections ; representationprotectionsset = _bool ; } else { if ( currentrepresentationprotections == null ) { assertions . checkstate ( representationprotections == null ) ; } else { collections . sort ( currentrepresentationprotections , this ) ; assertions . checkstate ( currentrepresentationprotections . equals ( representationprotections ) ) ; } } currentrepresentationprotections = null ; }	should be invoked after processing each child representation element , in order to apply consistency checks .
public standardpiesectionlabelgenerator ( string labelformat ) { this ( labelformat , numberformat . getnumberinstance ( ) , numberformat . getpercentinstance ( ) ) ; }	creates a new section label generator using the specified label format string , and platform default number and percentage formatters .
public static charsequence [ ] split ( charsequence line , int delimiter ) { charsequence [ ] tokens0 = split ( line , delimiter , n ) ; if ( tokens0 . length < n ) { return tokens0 ; } else { charsequence [ ] tokens1 = split ( tokens0 [ n - _num ] , delimiter ) ; charsequence [ ] tokens2 = new charsequence [ tokens0 . length + tokens1 . length - _num ] ; system . arraycopy ( tokens0 , _num , tokens2 , _num , tokens0 . length - _num ) ; system . arraycopy ( tokens1 , _num , tokens2 , tokens0 . length - _num , tokens1 . length ) ; return tokens2 ; } }	splits a charsequence according to the delimiter character .
public cctimer ( object t , string s , float seconds ) { target = t ; selector = s ; interval = seconds ; elapsed = - _num ; try { class < ? > cls = target . getclass ( ) ; invocation = cls . getmethod ( s , float . type ) ; } catch ( nosuchmethodexception e ) { e . printstacktrace ( ) ; } }	initializes a timer with a target , a selector and an interval in seconds .
public tuple read ( ) throws ioexception { try { map fields = jsontuplestream . next ( ) ; if ( fields == null ) { map m = new hashmap ( ) ; m . put ( _str , _bool ) ; return new tuple ( m ) ; } else { string msg = ( string ) fields . get ( _str ) ; if ( msg != null ) { handledexception ioexception = new handledexception ( msg ) ; throw ioexception ; } if ( trace ) { fields . put ( _str , this . baseurl ) ; if ( slice != null ) { fields . put ( _str , slice ) ; } } if ( fieldmappings != null ) { fields = mapfields ( fields , fieldmappings ) ; } return new tuple ( fields ) ; } } catch ( handledexception e ) { throw new ioexception ( _str + this . baseurl + _str + e . getmessage ( ) ) ; } catch ( exception e ) { throw new ioexception ( _str + this . baseurl + _str , e ) ; } }	reads a tuple from the stream.
private string compute ( string left , double right , boolean isinteger ) { if ( left == null && double . isnan ( right ) ) { return null ; } if ( isinteger && right == ( int ) right ) { return ( left == null ? _str : left ) + ( int ) right ; } else if ( double . isinfinite ( right ) ) { return ( left == null ? _str : left ) + tools . formatnumber ( right ) ; } else { return ( left == null ? _str : left ) + ( double . isnan ( right ) ? _str : right ) ; } }	adds a string and a double.
public void removepropertychangelistener ( final propertychangelistener listener ) { propertychangesupport . removepropertychangelistener ( listener ) ; }	remove the specified property change listener .
public void loadxml ( node stepnode , list < databasemeta > databases , map < string , counter > counters ) throws kettlexmlexception { try { this . tabelname = xmlhandler . gettagvalue ( stepnode , _str ) ; this . outputrowsize = xmlhandler . gettagvalue ( stepnode , _str ) ; this . factdimlensstring = xmlhandler . gettagvalue ( stepnode , _str ) ; this . tablename = xmlhandler . gettagvalue ( stepnode , _str ) ; this . databasename = xmlhandler . gettagvalue ( stepnode , _str ) ; this . dimensioncount = xmlhandler . gettagvalue ( stepnode , _str ) ; this . nodictionarydims = xmlhandler . gettagvalue ( stepnode , _str ) ; this . nodictionarydimsmapping = xmlhandler . gettagvalue ( stepnode , _str ) ; this . complexdimensioncount = xmlhandler . gettagvalue ( stepnode , _str ) ; this . measurecount = xmlhandler . gettagvalue ( stepnode , _str ) ; this . updatememberrequest = xmlhandler . gettagvalue ( stepnode , _str ) ; this . measuredatatype = xmlhandler . gettagvalue ( stepnode , _str ) ; this . partitionid = xmlhandler . gettagvalue ( stepnode , _str ) ; this . segmentid = xmlhandler . gettagvalue ( stepnode , _str ) ; this . taskno = xmlhandler . gettagvalue ( stepnode , _str ) ; } catch ( exception e ) { throw new kettlexmlexception ( _str , e ) ; } }	load the values for this step from an xml node.
public final int [ ] hashsignature ( final int [ ] signature ) { int [ ] hash = new int [ stages ] ; int rows = signature . length / stages ; for ( int i = _num ; i < signature . length ; i ++ ) { int stage = math . min ( i / rows , stages - _num ) ; hash [ stage ] = ( int ) ( ( hash [ stage ] + ( long ) signature [ i ] * large_prime ) % buckets ) ; } return hash ; }	hash a signature . the signature is divided in s stages ( or bands ) . each stage is hashed to one of the b buckets .
private void addtriggergroupname ( string groupname ) throws jobpersistenceexception , resourceexception { addrepolistname ( groupname , trigger_group_names_resource_path , _str ) ; }	adds a trigger group name to the list of trigger group names.
public string readstring ( ) throws ioexception { int firstbyte = readbyte ( ) ; int length = readint ( firstbyte , prefix_8_bits ) ; byte [ ] encoded = new byte [ length ] ; bytesleft -= length ; in . readfully ( encoded ) ; return new string ( encoded , _str ) ; }	reads a utf - 8 encoded string.
private synchronized void cleartempfiles ( ) { if ( ( tempfiles != null ) && ( tempfiles . size ( ) > _num ) ) { iterator it = tempfiles . iterator ( ) ; file file = null ; while ( it . hasnext ( ) ) { file = ( file ) it . next ( ) ; file . delete ( ) ; } tempfiles . clear ( ) ; } }	limpia la lista de ficheros temporales del escaneo.
private bitmap readanddecompressthumbnail ( file file ) { try { if ( file . length ( ) > _num ) { fileinputstream instream = new fileinputstream ( file ) ; readablebytechannel bytechan = channels . newchannel ( instream ) ; bytebuffer buff = bytebuffer . allocatedirect ( ( int ) file . length ( ) ) ; if ( buff != null ) { bytechan . read ( buff ) ; instream . close ( ) ; buff . rewind ( ) ; pdqimage pthumb = decompressionservice . decompressthumbnailimage ( buff ) ; if ( pthumb != null ) { bitmap bm = conversionservice . convertpdqimagetobitmap ( pthumb , _bool ) ; pthumb . close ( ) ; return bm ; } } } } catch ( ioexception ex ) { ex . printstacktrace ( ) ; } return null ; }	read and extract a thumbnail - sized image from a file .
public void testsubmitrunnable ( ) throws throwable { executorservice e = new forkjoinpool ( _num ) ; poolcleaner cleaner = null ; try { cleaner = cleaner ( e ) ; future < ? > future = e . submit ( new nooprunnable ( ) ) ; assertnull ( future . get ( ) ) ; asserttrue ( future . isdone ( ) ) ; assertfalse ( future . iscancelled ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }	completed submit ( runnable ) returns successfully.
public rectangle2d shrink ( rectangle2d area , rectangle2d result ) { if ( result == null ) { result = new rectangle2d . double ( ) ; } result . setrect ( area . getx ( ) + this . left , area . gety ( ) + this . top , area . getwidth ( ) - this . left - this . right , area . getheight ( ) - this . top - this . bottom ) ; return result ; }	shrinks an area by the space attributes .
public static string assertjq ( solrqueryrequest req , string ... tests ) throws exception { return assertjq ( req , jsontestutil . default_delta , tests ) ; }	validates a query matches some json test expressions using the default double delta tolerance .
protected void buildabsolutestats ( string name , long value , long time ) throws interruptedexception { list < xydataitem > stats = statscollection . getstats ( name ) ; if ( stats == null ) { stats = statscollection . newstats ( name , maxseries ) ; } else { xydataitem data = new xydataitem ( time , value ) ; statscollection . lockforupdate ( ) ; try { stats . add ( data ) ; housekeepstats ( stats ) ; } finally { statscollection . releaselock ( ) ; } if ( listeners != null ) { statscollectionevent event = new statscollectionevent ( name , data ) ; for ( statscollectionlistener listener : listeners ) { if ( listener . isenabled ( ) ) { listener . statscollected ( event ) ; } } } } }	builds the absolute stats .
protected void serialize ( string filename ) { classifier . serializeclassifier ( filename ) ; }	serialize a model to file .
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return begin_in_both ; case _num : return newint ; case _num : return newbyte ; case _num : return newshort ; case _num : return newlong ; case _num : return newdouble ; case _num : return newstruct ; case _num : return newlist ; case _num : return newset ; case _num : return newmap ; case _num : return newstring ; case _num : return end_in_both ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public boolean ispartitiontag ( string field ) { if ( partitions == null || ( ! istag ( field ) ) ) { return _bool ; } for ( string partition : partitions ) { if ( partition . equals ( field ) ) { return _bool ; } } return _bool ; }	check if the specified field is a partition tag field.
protected size2d arrangefn ( blockcontainer container , graphics2d g2 , rectangleconstraint constraint ) { list blocks = container . getblocks ( ) ; block b = ( block ) blocks . get ( _num ) ; size2d s = b . arrange ( g2 , rectangleconstraint . none ) ; double width = constraint . getwidth ( ) ; rectangle2d bounds = new rectangle2d . double ( ( width - s . width ) / _num , _num , s . width , s . height ) ; b . setbounds ( bounds ) ; return new size2d ( ( width - s . width ) / _num , s . height ) ; }	arranges the blocks in the container with a fixed width and no height constraint .
private object processexecute ( statement proxy , method method , object [ ] args ) throws throwable { long starttime = logslowquery ? system . currenttimemillis ( ) : _num ; try { if ( method . getname ( ) == _str ) return newproxiedresultset ( proxy , method , args ) ; return targetinvoke ( method , args ) ; } finally { if ( logslowquery ) logquery ( proxy , args , starttime ) ; } }	mainly exists to provide statement.
int boundedindexof ( string string , char search , int start , int end ) { int retvalue = string . indexof ( search , start ) ; if ( retvalue >= end ) { return - _num ; } return retvalue ; }	similar to string . indexof , but allows an upper bound ( this is slower in that it will still check string starting at start .
public int incr ( t k , int delta ) { integer i = counts . get ( k ) ; if ( i == null ) { i = _num ; } int next = i . intvalue ( ) + delta ; if ( next < _num ) { throw new java . lang . arithmeticexception ( ) ; } if ( next == _num ) { counts . remove ( k ) ; } else { counts . put ( k , i + delta ) ; } return i ; }	adds delta to the count for k and returns the count prior to addition .
public void send ( final oscpacket thepacket , final tcpclient theclient ) { theclient . send ( thepacket . getbytes ( ) ) ; }	send to tcp client.
@ override @ suppresswarnings ( _str ) public void keytyped ( keyevent evt ) { int modifiers = evt . getmodifiers ( ) ; char c = evt . getkeychar ( ) ; if ( c != keyevent . char_undefined && ( modifiers & inputevent . alt_mask ) == _num ) { if ( c >= _num && c != _num ) { keystroke keystroke = keystroke . getkeystroke ( character . touppercase ( c ) ) ; object o = currentbindings . get ( keystroke ) ; if ( o instanceof hashtable ) { currentbindings = ( hashtable ) o ; return ; } else if ( o instanceof actionlistener ) { currentbindings = bindings ; executeaction ( ( actionlistener ) o , evt . getsource ( ) , string . valueof ( c ) ) ; return ; } currentbindings = bindings ; if ( grabaction != null ) { handlegrabaction ( evt ) ; return ; } if ( repeat && character . isdigit ( c ) ) { repeatcount *= _num ; repeatcount += ( c - _str ) ; return ; } executeaction ( insert_char , evt . getsource ( ) , string . valueof ( evt . getkeychar ( ) ) ) ; repeatcount = _num ; repeat = _bool ; } } }	handle a key typed event.
public static map < string , mappedclass > fillinthegaps ( map < string , mappedclass > mappedclasses , mappingmode mode ) { for ( string originalname : mappedclasses . keyset ( ) ) { mappedclasses = fillgap ( mappedclasses . get ( originalname ) , mappedclasses , mode ) ; } return mappedclasses ; }	given a map of already renamed classes , fill in the gaps for classes that were not reached , but have parents that can be pulled from .
private void readobject ( objectinputstream s ) throws ioexception , classnotfoundexception { s . defaultreadobject ( ) ; if ( name == null ) { if ( types != null ) { throw new invalidobjectexception ( _str ) ; } } else { try { check ( ) ; } catch ( runtimeexception e ) { rethrow ( e ) ; } } if ( constraints != null && constraints . isempty ( ) ) { throw new invalidobjectexception ( _str ) ; } }	verifies that the method name , parameter types , and constraints are valid .
public static script createmultisiginputscriptbytes ( list < byte [ ] > signatures ) { checkargument ( signatures . size ( ) <= _num ) ; scriptbuilder builder = new scriptbuilder ( ) ; builder . smallnum ( _num ) ; for ( byte [ ] signature : signatures ) builder . data ( signature ) ; return builder . build ( ) ; }	create a program that satisfies an op_checkmultisig program , using pre - encoded signatures .
public void deleteinstances ( int [ ] rowindices ) { int i ; arrays . sort ( rowindices ) ; addundopoint ( ) ; m_ignorechanges = _bool ; for ( i = rowindices . length - _num ; i >= _num ; i -- ) { deleteinstanceat ( rowindices [ i ] , _bool ) ; } m_ignorechanges = _bool ; notifylistener ( new tablemodelevent ( this , rowindices [ _num ] , rowindices [ rowindices . length - _num ] , tablemodelevent . all_columns , tablemodelevent . delete ) ) ; }	deletes the instances at the given positions.
public synchronized < t extends eventlistener > void add ( class < t > t , t l ) { if ( l == null ) { return ; } if ( ! t . isinstance ( l ) ) { throw new illegalargumentexception ( _str + l + _str + t ) ; } if ( listenerlist == null_array ) { listenerlist = new object [ ] { t , l } ; } else { int i = listenerlist . length ; object [ ] tmp = new object [ i + _num ] ; system . arraycopy ( listenerlist , _num , tmp , _num , i ) ; tmp [ i ] = t ; tmp [ i + _num ] = l ; listenerlist = tmp ; } }	adds the listener as a listener of the specified type .
public static void gc2gc ( double c1 [ ] , int m1 , double g1 , double c2 [ ] , int m2 , double g2 ) { double [ ] gc2gc_buff = arrays . copyof ( c1 , m1 + _num ) ; c2 [ _num ] = gc2gc_buff [ _num ] ; for ( int i = _num ; i <= m2 ; i ++ ) { double ss1 = _num ; double ss2 = _num ; int min = m1 < i ? m1 : i - _num ; for ( int k = _num ; k <= min ; k ++ ) { int mk = i - k ; double cc = gc2gc_buff [ k ] * c2 [ mk ] ; ss2 += k * cc ; ss1 += mk * cc ; } if ( i <= m1 ) c2 [ i ] = gc2gc_buff [ i ] + ( g2 * ss2 - g1 * ss1 ) / i ; else c2 [ i ] = ( g2 * ss2 - g1 * ss1 ) / i ; } }	gc2gc : generalized cepstral transformation.
public static boolean between ( date basedate , date startdate , date enddate ) { if ( startdate . equals ( enddate ) || enddate . before ( startdate ) ) { return _bool ; } if ( ( startdate . before ( basedate ) || startdate . equals ( basedate ) ) && ( enddate . after ( basedate ) || enddate . equals ( basedate ) ) ) { return _bool ; } return _bool ; }	tests if the given base date is between the given start date and end date , including the dates themselves .
public void addlistener ( final timeouteventlistener listener ) { final long timeout = listener . gettimeout ( ) ; if ( timeout > _num ) { listeners . add ( listener ) ; synchronized ( statelock ) { pendinglistenermindelay = math . min ( pendinglistenermindelay , timeout ) ; statelock . notifyall ( ) ; } } }	registers a timeout event listener for timeout notification .
public static string [ ] convertstrings ( list < string > strings ) { string [ ] ret = new string [ strings . size ( ) ] ; for ( int i = _num ; i < ret . length ; i ++ ) { ret [ i ] = strings . get ( i ) ; } return ret ; }	converts the provided string list to a string array .
public static string transformtooltiptext ( final string description , final boolean addhtmltags , final int linelength , final boolean escapeslashes , final boolean escapehtml ) { string completetext = description . trim ( ) ; if ( escapehtml ) { completetext = tools . escapehtml ( completetext ) ; } if ( escapeslashes ) { completetext = completetext . replaceall ( _str , _str ) ; } stringbuffer result = new stringbuffer ( ) ; if ( addhtmltags ) { result . append ( _str ) ; } completetext = tools . transformalllineseparators ( completetext ) ; string [ ] lines = completetext . split ( _str ) ; for ( string text : lines ) { boolean first = _bool ; while ( text . length ( ) > linelength ) { int spaceindex = text . indexof ( _str , linelength ) ; if ( ! first ) { result . append ( _str ) ; } first = _bool ; if ( spaceindex >= _num ) { result . append ( text . substring ( _num , spaceindex ) ) ; text = text . substring ( spaceindex + _num ) ; } else { result . append ( text ) ; text = _str ; } } if ( ! first && text . length ( ) > _num ) { result . append ( _str ) ; } result . append ( text ) ; result . append ( _str ) ; } if ( addhtmltags ) { result . append ( _str ) ; } return result . tostring ( ) ; }	this method transforms the given tool tip text into html.
@ override public void write ( byte [ ] buffer , int offset , int length ) { if ( isclosed ( ) || ishead ( ) ) { return ; } int bytelength = _offset ; while ( _bool ) { int sublen = math . min ( length , size - bytelength ) ; system . arraycopy ( buffer , offset , _buffer , bytelength , sublen ) ; offset += sublen ; length -= sublen ; bytelength += sublen ; if ( length <= _num ) { break ; } _offset = bytelength ; flushbytebuffer ( ) ; bytelength = _offset ; } _offset = bytelength ; }	writes a chunk of bytes to the stream .
public clienthttprequest ( urlconnection connection ) throws ioexception { this . connection = connection ; connection . setdooutput ( _bool ) ; connection . setdoinput ( _bool ) ; connection . setrequestproperty ( _str , _str + boundary ) ; }	creates a new multipart post http request on a freshly opened urlconnection.
public void characters ( string characters ) throws saxexception { final int len = characters . length ( ) ; if ( len > m_charsbuff . length ) { m_charsbuff = new char [ len * _num + _num ] ; } characters . getchars ( _num , len , m_charsbuff , _num ) ; characters ( m_charsbuff , _num , len ) ; }	receive notification of character data .
private void appendtag ( string tagname , string value ) { xml . append ( _str ) ; xml . append ( tagname ) ; xml . append ( _str ) ; xml . append ( value ) ; xml . append ( _str ) ; xml . append ( tagname ) ; xml . append ( _str ) ; }	helper method for printing a tag in toplevel . xml.
@ override public certificatetokenvalidationextrainfo extrainfo ( ) { return extrainfo ; }	returns the object managing the validation extra info .
public void addtoplevelcontents ( collection < contentelement > contents ) { toplevelcontents . addall ( contents ) ; }	add top level contents to the document .
public static void withinstance ( map < string , object > args , closure c ) throws sqlexception , classnotfoundexception { sql sql = null ; try { sql = newinstance ( args ) ; c . call ( sql ) ; } finally { if ( sql != null ) sql . close ( ) ; } }	invokes a closure passing it a new sql instance created from the given map of arguments.
public void write ( byte [ ] buffer , int offset , int length , boolean isend ) throws ioexception { throw new unsupportedoperationexception ( string . valueof ( this ) ) ; }	writes a buffer to the underlying stream .
private boolean addindexentry ( servicetype resourcetype , string resourcename , string policyname ) throws policyexception { resourceindex resourceindex = ( resourceindex ) resourceindices . get ( resourcetype . getname ( ) ) ; if ( resourceindex == null ) { resourceindex = refreshresourceindexfromdatastore ( resourcetype ) ; } return resourceindex . addindexentry ( resourcename , policyname ) ; }	adds a new index entry or updates an existing index entry.
public void ddsolve ( set < node > qrynodes ) { long solve_time = _num , prepare_time = _num ; if ( hasexecuted == _bool ) solve ( ) ; if ( ddprepared == _bool || offlineprocessor == null ) { offlineprocessor = new offlineprocessor ( this ) ; ifiguremanager . cleancache ( ) ; ddprepared = _bool ; ps . println ( ) ; ps . println ( _str ) ; } int init_size = qrynodes . size ( ) ; if ( init_size == _num ) { ps . println ( _str ) ; return ; } date prepare_begin = new date ( ) ; offlineprocessor . init ( ) ; offlineprocessor . adduserdefpts ( qrynodes ) ; offlineprocessor . runoptimizations ( ) ; date prepare_end = new date ( ) ; prepare_time += prepare_end . gettime ( ) - prepare_begin . gettime ( ) ; date begin = new date ( ) ; preparenextrun ( ) ; nodegenerator . initflowgraph ( this ) ; solveconstraints ( ) ; date end = new date ( ) ; solve_time += end . gettime ( ) - begin . gettime ( ) ; ps . println ( ) ; ps . printf ( _str , ( double ) prepare_time / _num ) ; ps . printf ( _str , ( double ) solve_time / _num ) ; }	the demand - driven mode for precisely computing points - to information for given pointers.
private static void deletefrom ( int deleteat , int [ ] starts , int numstarts ) { while ( starts [ -- numstarts ] > deleteat ) { starts [ numstarts ] -= _num ; } }	adjust indices in starts to reflect a deletion after deleteat.
public static eventtypemetadata createbeantype ( string name , class clazz , boolean ispreconfiguredstatic , boolean ispreconfigured , boolean isconfigured , typeclass typeclass ) { set < string > secondarynames = null ; if ( name == null ) { name = clazz . getname ( ) ; } else { if ( ! name . equals ( clazz . getname ( ) ) ) { secondarynames = new linkedhashset < string > ( ) ; secondarynames . add ( clazz . getname ( ) ) ; } } return new eventtypemetadata ( name , secondarynames , typeclass , ispreconfiguredstatic , ispreconfigured , isconfigured , applicationtype . class , _bool ) ; }	factory for a bean type .
private boolean reverseit ( ) { if ( ! isactive ( ) ) throw new illegalstateexception ( _str ) ; mperiod . testperiodopen ( getctx ( ) , getdatetrx ( ) , mperiodcontrol . docbasetype_paymentallocation , getad_org_id ( ) ) ; setisactive ( _bool ) ; if ( ! isposted ( ) ) setposted ( _bool ) ; setdocumentno ( getdocumentno ( ) + _str ) ; setdocstatus ( docstatus_reversed ) ; if ( ! save ( ) || isactive ( ) ) throw new illegalstateexception ( _str ) ; mfactacct . deleteex ( mallocationhdr . table_id , getc_allocationhdr_id ( ) , get_trxname ( ) ) ; getlines ( _bool ) ; hashset < integer > bps = new hashset < integer > ( ) ; for ( int i = _num ; i < m_lines . length ; i ++ ) { mallocationline line = m_lines [ i ] ; line . setisactive ( _bool ) ; line . saveex ( ) ; bps . add ( new integer ( line . processit ( _bool ) ) ) ; } updatebp ( bps ) ; return _bool ; }	reverse allocation . period needs to be open.
public static boolean usesubjectcredsonly ( gsscaller caller ) { if ( caller instanceof httpcaller ) { return _bool ; } string propvalue = accesscontroller . doprivileged ( new getpropertyaction ( _str , _str ) ) ; return ( ! propvalue . equalsignorecase ( _str ) ) ; }	determines if the application doesn ' t mind if the mechanism obtains the required credentials from outside of the current subject.
public void add ( string fieldname , string value ) { if ( fieldname == null ) throw new illegalargumentexception ( _str ) ; if ( value == null ) throw new illegalargumentexception ( _str ) ; if ( fieldname . length ( ) == _num || fieldname . indexof ( _str ) != - _num || value . indexof ( _str ) != - _num ) { throw new illegalargumentexception ( _str + fieldname + _str + value ) ; } addlenient ( fieldname , value ) ; }	add a field with the specified value .
public void deletestorage ( storagedata storagedata ) throws businessexception , ioexception { storagedata local = getlocalstoragedataobject ( storagedata ) ; synchronized ( local ) { if ( ( storagerecorder . isrecordingon ( ) || storagerecorder . isrecordingscheduled ( ) ) && objects . equals ( local , recorderstoragedata ) ) { throw new businessexception ( _str + local + _str , storageerrorcodeenum . storage_already_closed ) ; } if ( local . isstorageopened ( ) ) { storagewriter writer = openedstoragesmap . get ( local ) ; if ( writer != null ) { writer . cancel ( ) ; } openedstoragesmap . remove ( local ) ; } deletecompletestoragedatafromdisk ( local ) ; existingstoragesset . remove ( local ) ; } }	deletes a storage information and files from disk .
public coapresponse advanced ( request request ) { assignclienturiifempty ( request ) ; return synchronous ( request ) ; }	sends an advanced synchronous request that has to be configured by the developer .
@ override public boolean conditionok ( example example ) { boolean isok = _bool ; for ( attribute attribute : checkedattributes ) { isok &= ! double . isnan ( example . getvalue ( attribute ) ) ; } return isok ; }	returns true if the example does not contain missing values within regarded attributes .
private void loadbinary ( inputstream is ) throws ioexception { if ( usenewio && is instanceof fileinputstream ) { fileinputstream fis = ( fileinputstream ) is ; if ( useindexing ) { loadbinaryindex ( new url ( indexname ) ) ; mapdatabase ( fis ) ; } else { loadmappedbinary ( fis ) ; } } else { datainputstream dis = new datainputstream ( new bufferedinputstream ( is ) ) ; loadbinary ( dis ) ; } }	loads a binary file from the input stream.
public vnxecommandjob deletelunsfromlungroup ( string lungroupid , list < string > luns ) { lungroupmodifyparam param = new lungroupmodifyparam ( ) ; list < lunaddparam > lundelete = new arraylist < lunaddparam > ( ) ; for ( string lunid : luns ) { vnxebase lun = new vnxebase ( lunid ) ; lunaddparam lunadd = new lunaddparam ( ) ; lunadd . setlun ( lun ) ; lundelete . add ( lunadd ) ; } param . setlundelete ( lundelete ) ; lungrouprequests req = new lungrouprequests ( _khclient ) ; return req . modifylungroupasync ( lungroupid , param ) ; }	delete luns from lun group.
public void removelocators ( lookuplocator [ ] locators ) { testsetfornull ( locators ) ; synchronized ( this ) { if ( terminated ) { throw new illegalstateexception ( _str ) ; } hashmap groupsmap = new hashmap ( _num ) ; for ( int i = _num ; i < locators . length ; i ++ ) { locatorreg reg = removediscoveredlocator ( locators [ i ] ) ; if ( reg != null ) { groupsmap . put ( reg . proxy , reg . membergroups ) ; continue ; } reg = findreg ( locators [ i ] ) ; if ( reg != null ) { undiscoveredlocators . remove ( reg ) ; } } if ( ! groupsmap . isempty ( ) && ! listeners . isempty ( ) ) { addnotify ( ( arraylist ) listeners . clone ( ) , groupsmap , _bool ) ; } } }	deletes a set of locators from the managed set of locators , and discards any already - discovered lookup service that corresponds to a deleted locator.
public boolean is_selected ( itemselectionchoice p_choice ) { return sel_array [ p_choice . ordinal ( ) ] ; }	looks , if the input item type is selected .
private void add ( final iprogressoperation operation ) { final gridbagconstraints constraints = new gridbagconstraints ( ) ; constraints . fill = gridbagconstraints . horizontal ; constraints . gridy = counter ++ ; constraints . gridx = _num ; constraints . weightx = _num ; constraints . weighty = _num ; m_progresspanel . add ( operation . getprogresspanel ( ) , constraints ) ; }	updates the dialog with a new operation .
public keystorebuilder withprovider ( final string providername ) { provider provider = security . getprovider ( providername ) ; if ( provider == null ) { throw new illegalargumentexception ( _str + providername ) ; } return withprovider ( provider ) ; }	specifies the security provider to use for the keystore .
private boolean compareanddecrementworkercount ( int expect ) { return ctl . compareandset ( expect , expect - _num ) ; }	attempts to cas - decrement the workercount field of ctl .
public static httpurlconnection tohttpconnection ( request ... requests ) { return tohttpconnection ( arrays . aslist ( requests ) ) ; }	serializes one or more requests but does not execute them.
public tcpendpoint ( string host , int port ) { this ( host , port , null , null ) ; }	create an endpoint for a specified host and port.
public void testbug22613 ( ) throws exception { createtable ( _str , _str ) ; checkmetadataforbug22613 ( this . conn ) ; if ( versionmeetsminimum ( _num , _num ) ) { connection infoschemconn = null ; try { properties props = new properties ( ) ; props . setproperty ( _str , _str ) ; infoschemconn = getconnectionwithprops ( props ) ; checkmetadataforbug22613 ( infoschemconn ) ; } finally { if ( infoschemconn != null ) { infoschemconn . close ( ) ; } } } }	tests fix for bug # 22613 - dbmd . getcolumns ( ) does not return expected column_size for the set type ( fixed to be consistent with the odbc driver ).
public long stime ( ) { return long . parselong ( fields [ _num ] ) ; }	amount of time that this process has been scheduled in kernel mode , measured in clock ticks ( divide by sysconf ( _sc_clk_tck ) ) .
public programrewriter ( arraylist < hoprewriterule > hrewrites , arraylist < statementblockrewriterule > sbrewrites ) { _dagruleset = new arraylist < hoprewriterule > ( ) ; _dagruleset . addall ( hrewrites ) ; _sbruleset = new arraylist < statementblockrewriterule > ( ) ; _sbruleset . addall ( sbrewrites ) ; }	construct a program rewriter for the given rewrite sets which are passed from outside .
private jmenu createsettingsmenu ( ) { final jmenu menu = new jmenu ( _str ) ; menu . setmnemonic ( _str ) ; menu . add ( new cactionshowsettingsdialog ( getparent ( ) ) ) ; menu . add ( new jseparator ( ) ) ; menu . add ( new cactioninitialcallgraphsettings ( getparent ( ) ) ) ; menu . add ( new cactioninitialflowgraphsettings ( getparent ( ) ) ) ; return menu ; }	creates the settings menu .
public static void writestring ( dataoutputstream os , string s ) throws ioexception { if ( s == null ) { os . writeint ( - _num ) ; } else { byte array [ ] = s . getbytes ( ) ; os . writeint ( array . length ) ; os . write ( array ) ; } }	write string to dataoutputstream motivation : datainputstream . readutf can ' t print lines larger than ushortmax.
public static boolean isjavavalidname ( string str ) { if ( str . isempty ( ) ) return _bool ; if ( javakeys . contains ( str ) ) return _bool ; char first = str . charat ( _num ) ; if ( isvalidnamestartchar ( first ) ) { for ( int i = _num ; i < str . length ( ) ; ++ i ) { char c = str . charat ( i ) ; if ( ! isvalidnamechar ( c ) ) return _bool ; } return _bool ; } else { return _bool ; } }	check whether the given string can be a valid java name.
private list < string > createcommands ( ) { list < string > commands = createnodecommands ( nodejsfile , tsfile ) ; list < string > args = createnodeargs ( ) ; if ( args != null ) { commands . addall ( args ) ; } return commands ; }	create process commands to start tern with node . js.
private void parsepackages ( sensorcontext sensorcontext ) { for ( directory directory : packagelist ) { sensorcontext . savemeasure ( directory , coremetrics . directories , _num ) ; sensorcontext . savemeasure ( directory , coremetrics . files , ( double ) filescount . get ( directory ) ) ; } }	count the metrics for packages.
public static thread consumeprocesserrorstream ( process self , appendable error ) { thread thread = new thread ( new textdumper ( self . geterrorstream ( ) , error ) ) ; thread . start ( ) ; return thread ; }	gets the error stream from a process and reads it to keep the process from blocking due to a full buffer.
public strbuilder deletefirst ( final string str ) { final int len = ( str == null ? _num : str . length ( ) ) ; if ( len > _num ) { final int index = indexof ( str , _num ) ; if ( index >= _num ) { deleteimpl ( index , index + len , len ) ; } } return this ; }	deletes the string wherever it occurs in the builder .
private static class < ? > [ ] classesforparams ( list < string > params ) { class < ? > [ ] result = new class < ? > [ params . size ( ) ] ; for ( int i = _num ; i < params . size ( ) ; i ++ ) { result [ i ] = classforparam ( params . get ( i ) ) ; } return result ; }	turn an array of strings ( class names ) into an array of class objects.
final public void trimtosize ( ) { for ( gazentry ge : gaz . values ( ) ) { ge . trimtosize ( ) ; } }	trim off excess size dead space .
public boolean containsselectaccount ( ) { return prompts . contains ( prompt_select_account ) ; }	determines if the prompt contains ' select_account ' .
protected static void quicksort ( instances insts , int [ ] indices , int attidx , int left , int right ) { if ( left < right ) { int middle = partition ( insts , indices , attidx , left , right ) ; quicksort ( insts , indices , attidx , left , middle ) ; quicksort ( insts , indices , attidx , middle + _num , right ) ; } }	sorts the instances according to the given attribute / dimension.
public image flipimagehorizontally ( image image , boolean maintainopacity ) { int [ ] rgb = image . getrgb ( ) ; int [ ] newrgb = new int [ rgb . length ] ; int width = image . getwidth ( ) ; int height = image . getheight ( ) ; for ( int y = _num ; y < height ; y ++ ) { for ( int x = _num ; x < width ; x ++ ) { newrgb [ ( width - x - _num ) + y * width ] = rgb [ x + y * width ] ; } } return encodedimage . createfromrgb ( newrgb , width , height , ! maintainopacity ) ; }	flips the given image on the horizontal axis.
public static boolean audit ( ) { return audit . get ( ) == null ? _bool : audit . get ( ) ; }	whether audit is enable ? defaults to true .
public static boolean istermsrequest ( siprequest request ) { string contenttype = request . getcontenttype ( ) ; return ( contenttype != null && contenttype . startswith ( _str ) ) ; }	is a terms & conditions request.
private void readsegments ( ) throws ioexception { for ( segmentextent10 extent : _segmentextents ) { try ( readstream is = openread ( extent . address ( ) , extent . length ( ) ) ) { is . skip ( extent . length ( ) - block_size ) ; long sequence = bitsutil . readlong ( is ) ; byte [ ] tablekey = new byte [ table_key_size ] ; is . readall ( tablekey , _num , tablekey . length ) ; if ( sequence > _num ) { segment10 segment = new segment10 ( sequence , tablekey , extent ) ; _segments . add ( segment ) ; } } } }	reads the segment metadata , the sequence and table key .
public static double projecttimewithin24hours ( double time ) { double secondsinoneday = _num * _num * _num ; if ( time == double . negative_infinity || time == double . positive_infinity ) { debuglib . stopsystemandreportinconsistency ( _str ) ; } while ( time < _num ) { time += secondsinoneday ; } if ( time < secondsinoneday ) { return time ; } else { return ( ( time / secondsinoneday ) - ( math . floor ( time / secondsinoneday ) ) ) * secondsinoneday ; } }	if time is > 60 * 60 * 24 [ seconds ] , it will be projected into next day , e.
private byte [ ] updateminmaxfornodictionary ( byte [ ] valuewithlength ) { bytebuffer buffer = bytebuffer . wrap ( valuewithlength ) ; byte [ ] actualvalue = new byte [ buffer . getshort ( ) ] ; buffer . get ( actualvalue ) ; return actualvalue ; }	below method will be used to update the min or max value by removing the length from it.
private object _deserializestruct ( element elstruct ) throws converterexception { string type = elstruct . getattribute ( _str ) ; struct struct = new structimpl ( ) ; nodelist list = elstruct . getchildnodes ( ) ; int len = list . getlength ( ) ; for ( int i = _num ; i < len ; i ++ ) { node node = list . item ( i ) ; if ( node instanceof element ) { element var = ( element ) node ; element value = getchildelement ( ( element ) node ) ; if ( value != null ) { struct . setel ( var . getattribute ( _str ) , _deserialize ( value ) ) ; } } } if ( struct . size ( ) == _num && type != null && type . length ( ) > _num ) { return _str ; } return struct ; }	desirialize a struct object.
public queriercli ( string [ ] args ) { clioptions = createoptions ( ) ; try { commandlineparser parser = new gnuparser ( ) ; commandline = parser . parse ( clioptions , args , _bool ) ; if ( hasoption ( _str ) ) { printhelp ( ) ; system . exit ( _num ) ; } if ( ! parseoptions ( ) ) { logger . info ( _str ) ; printhelp ( ) ; system . exit ( _num ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; system . exit ( _num ) ; } }	create and parse allowable options.
private static byte [ ] concatbytes ( byte [ ] array1 , byte [ ] array2 ) { byte [ ] cbytes = new byte [ array1 . length + array2 . length ] ; try { system . arraycopy ( array1 , _num , cbytes , _num , array1 . length ) ; system . arraycopy ( array2 , _num , cbytes , array1 . length , array2 . length ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } return cbytes ; }	this method concatenates two byte arrays.
public in ( file file ) { if ( file == null ) throw new nullpointerexception ( _str ) ; try { fileinputstream fis = new fileinputstream ( file ) ; scanner = new scanner ( new bufferedinputstream ( fis ) , charset_name ) ; scanner . uselocale ( locale ) ; } catch ( ioexception ioe ) { throw new illegalargumentexception ( _str + file ) ; } }	initializes an input stream from a file .
protected extendeddismaxconfiguration createconfiguration ( string qstr , solrparams localparams , solrparams params , solrqueryrequest req ) { return new extendeddismaxconfiguration ( localparams , params , req ) ; }	creates an instance of extendeddismaxconfiguration . it will contain all the necessary parameters to parse the query.
void writevalueproperties ( string fullid , long dbid , string localid , jsonvalue value , connection connection ) throws sqlexception { if ( cfg . haspossiblesearchableproperties ( ) ) { integer batchingcount = _num ; preparedstatement propcreatestatement = getpreparedstatement ( connection , querydefinition . propcreatequerystr ) ; try { batchingcount = writevalueproperties ( fullid , dbid , localid , value , connection , propcreatestatement , batchingcount ) ; if ( enablebatching && batchingcount > _num ) { int [ ] numupdates = propcreatestatement . executebatch ( ) ; logger . debug ( _str , numupdates ) ; if ( logger . isdebugenabled ( ) ) { logger . debug ( _str , arrays . aslist ( numupdates ) ) ; } propcreatestatement . clearbatch ( ) ; } } finally { cleanuphelper . loggedclose ( propcreatestatement ) ; } } }	writes all properties of a given resource to the properties table and links them to the main table record .
protected double computemaxyaxisvaluelogscale ( double maxvalue ) { double v = _num ; int mantisse = _num ; int exponent = _num ; while ( v < maxvalue ) { if ( mantisse < _num ) mantisse ++ ; else { mantisse = _num ; exponent ++ ; } v = mantisse * math . pow ( _num , exponent ) ; } return math . log10 ( v ) ; }	compute the maximum value on a log scale.
public void addfocusclearedlistener ( focusclearedlistener focusclearedlistener ) { mfocusclearedlisteners . add ( focusclearedlistener ) ; }	register a listener to be notified when focus is cleared.
public void additemlistener ( itemlistener alistener ) { listenerlist . add ( itemlistener . class , alistener ) ; }	add a listener for mode changes.
@ override public enumeration < option > listoptions ( ) { vector < option > result ; result = new vector < option > ( ) ; result . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str + getdefaultnumdecimals ( ) + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str + _str , _str , _num , _str ) ) ; return result . elements ( ) ; }	returns an enumeration of all the available options.
public static mosaiclevy createmosaiclevy ( final mosaicid mosaicid ) { return new mosaiclevy ( mosaictransferfeetype . absolute , generaterandomaccount ( ) , mosaicid , quantity . fromvalue ( _num ) ) ; }	creates a xem mosaic levy .
public int rankof ( double value ) { int ret = _num ; if ( ! hascapacity ( ) ) { ret = arrays . binarysearch ( data , value ) ; if ( ret < _num ) { return - ret - _num ; } else { return ret ; } } else { for ( int i = _num ; i < next ; i ++ ) { if ( data [ i ] < value ) { ret ++ ; } } return ret ; } }	returns the ordinal rank of value among the sampled values in this buffer .
public static < t > predicate < t > not ( predicate < t > predicate ) { return predicate . negate ( ) ; }	negate the given predicate .
private static void addmargintoptocontentchild ( view mcontentchild , int statusbarheight ) { if ( mcontentchild == null ) { return ; } if ( ! tag_margin_added . equals ( mcontentchild . gettag ( ) ) ) { framelayout . layoutparams lp = ( framelayout . layoutparams ) mcontentchild . getlayoutparams ( ) ; lp . topmargin += statusbarheight ; mcontentchild . setlayoutparams ( lp ) ; mcontentchild . settag ( tag_margin_added ) ; } }	add margintop to simulate set fitssystemwindow true.
static byte [ ] hexstringtobytearray ( string hexstring ) { string s = hexstring ; int len = s . length ( ) ; if ( len % _num == _num ) { s = _str + s ; len ++ ; } byte [ ] data = new byte [ len / _num ] ; for ( int i = _num ; i < len ; i += _num ) { data [ i / _num ] = ( byte ) ( ( character . digit ( s . charat ( i ) , _num ) << _num ) + character . digit ( s . charat ( i + _num ) , _num ) ) ; } return data ; }	converts a hexadecimal string into an byte array.
public int send ( byte [ ] buffer , int offset , int count ) { checkarraybounds ( buffer , offset , count ) ; if ( count == _num ) { return _num ; } byte [ ] data = buffer ; if ( offset > _num ) { data = new byte [ count ] ; system . arraycopy ( buffer , offset , data , _num , count ) ; } intout bytessentout = new intout ( ) ; try { idevice . checkresult ( libimobiledevice . idevice_connection_send ( getref ( ) , data , count , bytessentout ) ) ; return bytessentout . getvalue ( ) ; } finally { bytessentout . delete ( ) ; } }	sends data to the device on this connection .
private void fetchschema ( ) throws executionexception , rpcexception , timeoutexception { message schema = rpc . get ( myclient . getschema ( ) , fetch_schema_timeout_ms , timeunit . milliseconds ) ; log . info ( _str + schema . entities . length + _str + schema . constants . length + _str ) ; int atoms = _num ; for ( entity type : schema . entities ) { if ( atommetadata . find ( type ) != null ) { atoms ++ ; } dynamic . register ( type ) ; } log . info ( _str + atoms + _str ) ; for ( constantset set : schema . constants ) { constantset . register ( set ) ; } }	requests and blocks for the schema from the server .
private void append ( stringbuilder buffer , double [ ] data , string prefix , string separator , string suffix ) { buffer . append ( prefix ) ; for ( int i = _num ; i < data . length ; ++ i ) { if ( i > _num ) { buffer . append ( separator ) ; } buffer . append ( data [ i ] ) ; } buffer . append ( suffix ) ; }	append a text representation of an array to a buffer .
public t torealarray ( ) { return _outputarraytype . cast ( arraymultidimensionalizer . multidimensionalize ( _real , _dimensions ) ) ; }	returns an array that holds the real values from the matlab array.
private arraylist < writablecomparable > readpartitions ( filesystem fs , path p , jobconf job ) throws ioexception { sequencefile . reader reader = new sequencefile . reader ( fs , p , job ) ; arraylist < writablecomparable > parts = new arraylist < writablecomparable > ( ) ; try { doublewritable key = new doublewritable ( ) ; nullwritable value = nullwritable . get ( ) ; while ( reader . next ( key , value ) ) { parts . add ( key ) ; key = new doublewritable ( ) ; } } catch ( exception e ) { throw new runtimeexception ( e ) ; } finally { ioutilfunctions . closesilently ( reader ) ; } reader . close ( ) ; return parts ; }	read the cut points from the given sequence file .
public boolean pollseqno ( long seqno ) { return seqno <= disklog . getmaxseqno ( ) ; }	returns true if the indicated sequence number is available .
private static void drawline ( int x0 , int y0 , int x1 , int y1 , boolean [ ] [ ] pic ) { final int xres = pic . length , yres = pic [ _num ] . length ; y0 = ( y0 < _num ) ? _num : ( y0 >= yres ) ? ( yres - _num ) : y0 ; y1 = ( y1 < _num ) ? _num : ( y1 >= yres ) ? ( yres - _num ) : y1 ; x0 = ( x0 < _num ) ? _num : ( x0 >= xres ) ? ( xres - _num ) : x0 ; x1 = ( x1 < _num ) ? _num : ( x1 >= xres ) ? ( xres - _num ) : x1 ; final int dx = + math . abs ( x1 - x0 ) , sx = x0 < x1 ? _num : - _num ; final int dy = - math . abs ( y1 - y0 ) , sy = y0 < y1 ? _num : - _num ; int err = dx + dy ; for ( ; ; ) { pic [ x0 ] [ y0 ] = _bool ; if ( x0 == x1 && y0 == y1 ) { break ; } final int e2 = err << _num ; if ( e2 > dy ) { err += dy ; x0 += sx ; } if ( e2 < dx ) { err += dx ; y0 += sy ; } } }	draw a line onto the array , using the classic bresenham algorithm .
public string process ( item item ) throws processexception { int count = _num ; item inphrase = sub_phrase_path . finditem ( item ) ; for ( item p = inphrase ; p != null ; p = p . getprevious ( ) ) { count ++ ; } return integer . tostring ( rail ( count ) ) ; }	performs some processing on the given item .
public e push ( e value ) { elements . add ( value ) ; return value ; }	push to the top of the stack.
public long cardinality ( final int tailindex ) { return rangecount ( tailindex ) ; }	return the cardinality of a particular tail , which is the range count if not optional and infinite if optional .
public static void createresponse ( httpservletrequest request , httpservletresponse response , httpservlet servlet , properties cookieproperties , webdoc doc , boolean debug ) throws ioexception { response . setheader ( _str , _str ) ; response . setcontenttype ( _str ) ; if ( cookieproperties != null ) { cookie cookie = new cookie ( webenv . cookie_info , propertiesencode ( cookieproperties ) ) ; cookie . setcomment ( _str ) ; cookie . setsecure ( _bool ) ; cookie . setpath ( _str ) ; if ( cookieproperties . size ( ) == _num ) cookie . setmaxage ( _num ) ; else cookie . setmaxage ( _num ) ; response . addcookie ( cookie ) ; } if ( debug && webenv . debug ) { webenv . addfooter ( request , response , servlet , doc . getbody ( ) ) ; } printwriter out = response . getwriter ( ) ; doc . output ( out ) ; out . flush ( ) ; if ( out . checkerror ( ) ) log . log ( level . severe , _str ) ; out . close ( ) ; }	create standard response header with optional cookie and print document.
public static long tolong ( object o ) throws pageexception { if ( o instanceof long ) return ( long ) o ; return long . valueof ( tolongvalue ( o ) ) ; }	cast a object to a long object ( reference type ).
protected void finishgridrow ( ) { gridbagconstraints constraints = new gridbagconstraints ( ) ; constraints . gridwidth = gridbagconstraints . remainder ; constraints . weightx = _num ; final jlabel icon ; if ( param . isoptional ( ) ) { if ( param . isdefined ( ) && param . tookdefaultvalue ( ) && ! ( param instanceof flag ) ) { icon = new jlabel ( stockicon . getstockicon ( stockicon . dialog_information ) ) ; icon . settooltiptext ( _str + param . getdefaultvalueasstring ( ) ) ; } else { icon = new jlabel ( ) ; icon . setminimumsize ( new dimension ( _num , _num ) ) ; } } else { if ( ! param . isdefined ( ) ) { icon = new jlabel ( stockicon . getstockicon ( stockicon . dialog_error ) ) ; icon . settooltiptext ( _str ) ; } else { icon = new jlabel ( ) ; icon . setminimumsize ( new dimension ( _num , _num ) ) ; } } parent . add ( icon , constraints ) ; }	complete the current grid row , adding the icon at the end.
public final void testisstatepreserved1 ( ) { byte [ ] encodedkey = new byte [ ] { ( byte ) _num , ( byte ) _num , ( byte ) _num , ( byte ) _num } ; byte [ ] encodedkeycopy = encodedkey . clone ( ) ; x509encodedkeyspec meks = new x509encodedkeyspec ( encodedkeycopy ) ; encodedkeycopy [ _num ] = ( byte ) _num ; byte [ ] ek = meks . getencoded ( ) ; asserttrue ( arrays . equals ( encodedkey , ek ) ) ; }	tests that internal state of the object can not be changed by modifying initial array value.
@ override public void shutdown ( ) { if ( ! shouldkeepadbalive ) { androiddebugbridge . disconnectbridge ( ) ; androiddebugbridge . terminate ( ) ; } logger . info ( _str ) ; }	shutdown the androiddebugbridge and clean up all connected devices .
public void pingreceived ( ping pong ) { long now = system . currenttimemillis ( ) ; long previousreceived = ( int ) ( lastpingsent . get ( ) & _num ) ; log . debug ( _str , new object [ ] { getid ( ) , now , pong . getvalue2 ( ) , previousreceived } ) ; if ( pong . getvalue2 ( ) == previousreceived ) { lastpingtime . set ( ( int ) ( now & _num ) - pong . getvalue2 ( ) ) ; } lastpongreceived . set ( now ) ; }	marks that ping back was received .
public static int findobjectliteral ( object literal ) { synchronized ( objectliterals ) { integer result = objectliterals . get ( literal ) ; return result == null ? _num : result . intvalue ( ) ; } }	find a slot in the jtoc with this object literal in else return 0.
@ override public void resetviewablearea ( ) { throw new runtimeexception ( _str ) ; }	not part of api turns off the viewable area , scaling the page back to original scaling.
private void testtransferrate ( ) { assert . assertnotnull ( mexpectedtransferrateops ) ; assert . assertnotnull ( mexpectedtransferratebps ) ; assert . asserttrue ( mexpectedtransferratebps . intvalue ( ) > _num ) ; assert . asserttrue ( mexpectedtransferrateops . intvalue ( ) > _num ) ; }	compare transfer rate calculated to expected value .
public void add ( x509trustmanager mgr ) { if ( mgr instanceof x509extensions ) { managers . add ( ( x509extensions ) mgr ) ; } else { managers . add ( new x509extensionswrapper ( mgr ) ) ; } }	add an x509trustmanager to the ones being governed by this composite.
public iterator < treenode > findchildren ( ) { list < treenode > nodes ; if ( children == null ) nodes = collections . emptylist ( ) ; else nodes = children ; return nodes . iterator ( ) ; }	return an iterator of all children of this node.
private int createfolder ( ) { if ( mnewdirectoryname != null && mselecteddir != null && mselecteddir . canwrite ( ) ) { file newdir = new file ( mselecteddir , mnewdirectoryname ) ; if ( ! newdir . exists ( ) ) { boolean result = newdir . mkdir ( ) ; if ( result ) { changedirectory ( newdir ) ; return r . string . create_folder_success ; } else { return r . string . create_folder_error ; } } else { return r . string . create_folder_error_already_exists ; } } else if ( mselecteddir != null && ! mselecteddir . canwrite ( ) ) { return r . string . create_folder_error_no_write_access ; } else { return r . string . create_folder_error ; } }	creates a new folder in the current directory with the name create_directory_name .
public static double i ( double p [ ] [ ] , int j , int k ) { double i = _num ; double p_x = p [ j ] [ j ] ; double p_y = p [ k ] [ k ] ; double p_xy = p [ j ] [ k ] ; i += p_xy * math . log ( p_xy / ( p_x * p_y ) ) ; i += ( _num - p_xy ) * math . log ( ( _num - p_xy ) / ( ( _num - p_x ) * ( _num - p_y ) ) ) ; return i ; }	i - mutual information . < br > note binary only.
public result docomparisontest ( properties properties ) throws exception { final long timeout = long . parselong ( properties . getproperty ( testoptions . timeout ) ) ; final int nclients = integer . parseint ( properties . getproperty ( testoptions . nclients ) ) ; final int ntrials = integer . parseint ( properties . getproperty ( testoptions . ntrials ) ) ; final int keylen = integer . parseint ( properties . getproperty ( testoptions . keylen ) ) ; final int nops = integer . parseint ( properties . getproperty ( testoptions . nops ) ) ; final double insertrate = integer . parseint ( properties . getproperty ( testoptions . insert_rate ) ) ; final int nindices = integer . parseint ( properties . getproperty ( testoptions . nindices ) ) ; final boolean testcorrectness = boolean . parseboolean ( properties . getproperty ( testoptions . test_correctness ) ) ; result result = doconcurrentclienttest ( client , nclients , timeout , ntrials , keylen , nops , insertrate , nindices , testcorrectness ) ; return result ; }	setup and run a test .
public void testgetscale ( ) throws sqlexception { try { int scale = _num ; string createtable = _str + _str + scale + _str ; string insert = _str ; string select = _str ; statement st = conn . createstatement ( ) ; st . executeupdate ( createtable ) ; st . executeupdate ( insert ) ; rs = st . executequery ( select ) ; resultsetmetadata rsmd2 = rs . getmetadata ( ) ; assertnotnull ( rsmd2 ) ; assertequals ( scale , rsmd2 . getscale ( _num ) ) ; asserttrue ( rsmd2 . getscale ( _num ) > _num ) ; asserttrue ( rsmd2 . getscale ( _num ) > _num ) ; try { rsmd . getscale ( _num ) ; fail ( _str ) ; } catch ( sqlexception e ) { } try { rsmd . getscale ( _num ) ; fail ( _str ) ; } catch ( sqlexception e ) { } try { conn . close ( ) ; rsmd . getscale ( _num ) ; fail ( _str ) ; } catch ( sqlexception e ) { } } finally { st . cancel ( ) ; } }	always returns 0 , exception tests fail no positive test case for black - box test possible : no default value indicated . not supported.
static string valuetostring ( object value , int indentfactor , int indent ) { if ( value == null || value . equals ( null ) ) { return _str ; } try { if ( value instanceof string ) { return quote ( ( string ) value ) ; } } catch ( exception e ) { } if ( value instanceof float || value instanceof double || value instanceof byte || value instanceof short || value instanceof integer || value instanceof long ) { return numbertostring ( value ) ; } if ( value instanceof boolean ) { return value . tostring ( ) ; } if ( value instanceof map ) { return print ( ( map ) value , indentfactor , indent ) ; } if ( value instanceof list ) { return print ( ( list ) value , indentfactor , indent ) ; } return quote ( value . tostring ( ) ) ; }	make a prettyprinted json text of an object value.
public static boolean isretainedatruntime ( class < ? extends annotation > annotationtype ) { retention retention = annotationtype . getannotation ( retention . class ) ; return retention != null && retention . value ( ) == retentionpolicy . runtime ; }	returns true if the given annotation is retained at runtime .
public void testprocessmsg5 ( ) { byte [ ] pdu = createpdu ( _num ) ; int headerlen = pdu . length - ( mgsmheader . length + muserdataheader . length + mmessagebody . length ) ; int pdutype = _num ; int tranid = _num ; string originalpackagename = mpackagename ; string originalclassname = mclassname ; try { mclassname = _str ; iwappushmanager iwapman = getinterface ( ) ; iwapman . addpackage ( integer . tostring ( mappidvalue ) , integer . tostring ( mcontenttypevalue ) , mpackagename , mclassname , wappushmanagerparams . app_type_activity , _bool , _bool ) ; asserttrue ( ( iwapman . processmessage ( integer . tostring ( mappidvalue ) , integer . tostring ( mcontenttypevalue ) , createintent ( pdutype , tranid ) ) & wappushmanagerparams . message_handled ) == wappushmanagerparams . message_handled ) ; iwapman . deletepackage ( integer . tostring ( mappidvalue ) , integer . tostring ( mcontenttypevalue ) , mpackagename , mclassname ) ; } catch ( remoteexception e ) { asserttrue ( _bool ) ; } mpackagename = originalpackagename ; mclassname = originalclassname ; }	message processing test , send invalid sms data.
public void addclasspath ( string classpath ) { char sep = cauchoutil . getpathseparatorchar ( ) ; int head = _num ; int tail = _num ; while ( head < classpath . length ( ) ) { tail = classpath . indexof ( sep , head ) ; string segment = null ; if ( tail < _num ) { segment = classpath . substring ( head ) ; head = classpath . length ( ) ; } else { segment = classpath . substring ( head , tail ) ; head = tail + _num ; } if ( segment . equals ( _str ) ) continue ; else if ( segment . endswith ( _str ) || segment . endswith ( _str ) ) addmergepath ( jarpath . create ( vfsold . lookup ( segment ) ) ) ; else addmergepath ( vfsold . lookup ( segment ) ) ; } }	adds the classpath for the loader as paths in the mergepath .
@ singleton public static synchronized void loaddirectories ( string firstoption ) throws invalidconfigexception { if ( useriddirectories == null ) { useriddirectories = new treemap < string , string > ( ) ; useriddirectories . put ( _str , ( firstoption == null ) ? _str : firstoption ) ; properties properties = directoriesproperties ( ) ; for ( map . entry < object , object > entry : properties . entryset ( ) ) { string key = stringutils . trim ( ( string ) entry . getkey ( ) ) ; string value = stringutils . trim ( ( string ) entry . getvalue ( ) ) ; if ( key != null && value != null ) { useriddirectories . put ( key , value ) ; } else { string error = directories_propfile_path + _str ; log . error ( error ) ; throw new invalidconfigexception ( invalidconfigexception . type . invalid_properties_file , error ) ; } } if ( ( useriddirectories . size ( ) - _num ) == _num ) { string error = _str + directories_propfile_path + _str ; log . error ( error ) ; throw new invalidconfigexception ( invalidconfigexception . type . invalid_properties_file , error ) ; } } }	load directories map used to populate select on basic metadata page.
public static individuum nullindividuum ( int dim ) { short [ ] gene = new short [ dim ] ; arrays . fill ( gene , dont_care ) ; return new individuum ( _num , gene ) ; }	create a " null " individuum ( full space ) .
public list < class < ? > > findallclasses ( string uri ) throws ioexception , classnotfoundexception { list < class < ? > > classes = new arraylist < > ( ) ; list < string > strings = findallstrings ( uri ) ; for ( string classname : strings ) { class < ? > clazz = _classloader . loadclass ( classname ) ; classes . add ( clazz ) ; } return classes ; }	executes findallstrings assuming the strings are the names of a classes that should be loaded and returned.
private boolean isslavogermanic ( string value ) { return value . indexof ( _str ) > - _num || value . indexof ( _str ) > - _num || value . indexof ( _str ) > - _num || value . indexof ( _str ) > - _num ; }	determines whether or not a value is of slavo - germanic orgin.
public void shuffleinventory ( @ nonnull iinventory inv , @ nonnull random random ) { final list < itemstack > list = getinventorylist ( inv ) ; collections . shuffle ( list , random ) ; for ( int i = _num ; i < inv . getsizeinventory ( ) ; ++ i ) { inv . setinventoryslotcontents ( i , list . get ( i ) ) ; } }	shuffles all items in the inventory.
@ override public string format ( double value , int formatnumber ) { if ( formatnumber % _num == _num ) { return format . format ( value ) ; } else { return null ; } }	returns the formatted value.
public static string tolowercase ( string string ) { boolean changed = _bool ; char [ ] chars = string . tochararray ( ) ; for ( int i = _num ; i != chars . length ; i ++ ) { char ch = chars [ i ] ; if ( _str <= ch && _str >= ch ) { changed = _bool ; chars [ i ] = ( char ) ( ch - _str + _str ) ; } } if ( changed ) { return new string ( chars ) ; } return string ; }	a locale independent version of tolowercase .
public void runasserts ( list < step > list , int size , boolean needassignee ) { assertequals ( size , list . size ( ) ) ; for ( int i = _num ; i < size ; i ++ ) { runasserts ( list . get ( i ) , i , needassignee ) ; } }	assert a step - list with getalistofsamplesteps ( size ).
public static boolean registertransform ( final string transformuri ) { final boolean added = transforms . add ( transformuri ) ; return added ; }	this method allows to register a transformation .
public synchronized void co_exit ( int thiscoroutine ) { m_activeids . clear ( thiscoroutine ) ; m_nextcoroutine = nobody ; notify ( ) ; }	terminate this entire set of coroutines.
public void shrink ( ) { if ( c . length == length ) { return ; } char [ ] newc = new char [ length ] ; system . arraycopy ( c , _num , newc , _num , length ) ; c = newc ; }	shrinks the capacity of the buffer to the current length if necessary . this method involves copying the data once !.
public andcondition ( condition ... conditions ) { reject . ifnull ( conditions ) ; this . conditions = arrays . aslist ( conditions ) ; }	creates a new logical and condition with the provided sub - conditions .
private void dropdownstreamto ( long absoluteposition ) { int relativeposition = ( int ) ( absoluteposition - totalbytesdropped ) ; int allocationindex = relativeposition / allocationlength ; for ( int i = _num ; i < allocationindex ; i ++ ) { allocator . release ( dataqueue . remove ( ) ) ; totalbytesdropped += allocationlength ; } }	discard any allocations that hold data prior to the specified absolute position , returning them to the allocator .
public hopimpl ( string hostname , int portnumber , string trans ) { host = hostname ; if ( host . indexof ( _str ) >= _num ) if ( host . indexof ( _str ) < _num ) host = _str + host + _str ; port = portnumber ; transport = trans ; }	create new hop given host , port and transport .
private void updatecontrols ( ) { spinner difficulty = ( spinner ) findviewbyid ( r . id . spinner_difficultylevel ) ; difficulty . setselection ( gameactivity . getdifficultyindex ( ) ) ; button resume = ( button ) findviewbyid ( r . id . button_resumegame ) ; resume . setenabled ( gameactivity . canresumefromsave ( ) ) ; checkbox neverloseball = ( checkbox ) findviewbyid ( r . id . checkbox_neverloseball ) ; neverloseball . setchecked ( gameactivity . getneverloseball ( ) ) ; checkbox soundeffectsenabled = ( checkbox ) findviewbyid ( r . id . checkbox_soundeffectsenabled ) ; soundeffectsenabled . setchecked ( gameactivity . getsoundeffectsenabled ( ) ) ; textview highscore = ( textview ) findviewbyid ( r . id . text_highscore ) ; highscore . settext ( string . valueof ( mhighscore ) ) ; }	sets the state of the ui controls to match our internal state .
public static void write ( outputstream out , int c ) { if ( out == null ) { throw new illegalargumentexception ( _str ) ; } try { out . write ( c ) ; } catch ( ioexception e ) { throw new runtimeexception ( e . getmessage ( ) , e ) ; } }	write a ascii code to the output stream.
public void message ( loconetmessage m ) { if ( m . getnumdataelements ( ) != _num ) { return ; } int b1 = m . getelement ( _num ) & _num ; int b2 = m . getelement ( _num ) & _num ; int b3 = m . getelement ( _num ) & _num ; int b4 = m . getelement ( _num ) & _num ; if ( ( b1 == _num ) && ( ( b2 == _num ) || ( b2 == _num ) || ( b2 == _num ) ) && ( b3 == _num ) ) { idbox . setselectedindex ( b4 + _num ) ; } }	process the incoming message , see if it is a panel response , and if so parse the loconet id.
public void call ( ) throws exception { byte [ ] [ ] keys = new byte [ nops ] [ ] ; byte [ ] [ ] vals = new byte [ nops ] [ ] ; if ( r . nextdouble ( ) <= insertrate ) { for ( int i = _num ; i < nops ; i ++ ) { keys [ i ] = nextkey ( ) ; vals [ i ] = new byte [ _num ] ; r . nextbytes ( vals [ i ] ) ; } lock . lock ( ) ; try { ndx . submit ( _num , nops , keys , vals , batchinsertconstructor . return_no_values , null ) ; if ( groundtruth != null ) { groundtruth . submit ( _num , nops , keys , vals , batchinsertconstructor . return_no_values , null ) ; } } finally { lock . unlock ( ) ; } } else { for ( int i = _num ; i < nops ; i ++ ) { keys [ i ] = nextkey ( ) ; } lock . lock ( ) ; try { ndx . submit ( _num , nops , keys , null , batchremoveconstructor . return_mutation_count , null ) ; if ( groundtruth != null ) { groundtruth . submit ( _num , nops , keys , null , batchremoveconstructor . return_mutation_count , null ) ; } } finally { lock . unlock ( ) ; } } return null ; }	executes a random batch operation with keys presented in sorted order.
public boolean allowmultipleadditions ( string systemname ) { return _bool ; }	a method that determines if it is possible to add a range of lights in numerical order eg 11 thru 18 , primarily used to show / not show the add range box in the add light window.
protected static boolean isobjectclasspresent ( set objectclasses , string objectclass ) { if ( objectclasses != null && ! objectclasses . isempty ( ) ) { iterator itr = objectclasses . iterator ( ) ; while ( itr . hasnext ( ) ) { string serviceoc = ( string ) itr . next ( ) ; if ( serviceoc . equalsignorecase ( objectclass ) ) { return _bool ; } } } return _bool ; }	method to compare all the object classes in the set with the specfied object class.
public void writefield ( final string name , final int value ) throws java . io . ioexception { writefield ( name , integer . tostring ( value ) ) ; }	writes an int field value .
public static double lnfactorial ( int x ) { if ( x < _num ) throw new illegalargumentexception ( _str + x ) ; else if ( x > _num ) return lngamma ( x + _num ) ; else { int l = factorialsbuffer . size ( ) ; for ( int i = l ; i <= x ; i ++ ) { factorialsbuffer . add ( log ( i ) + factorialsbuffer . get ( i - _num ) ) ; } return factorialsbuffer . get ( x ) ; } }	get the log of the factorial of a number.
public void sync ( ) throws ioexception { try { latch . await ( ) ; } catch ( interruptedexception e ) { thread . interrupted ( ) ; throw ioexceptionsupport . create ( e ) ; } failonerror ( ) ; }	waits for a response to some pending operation .
public int addandget ( t obj , int delta ) { for ( ; ; ) { int current = get ( obj ) ; int next = current + delta ; if ( compareandset ( obj , current , next ) ) return next ; } }	atomically adds the given value to the current value of the field of the given object managed by this updater .
public static void closesilently ( closeable closeable ) { if ( closeable == null ) { return ; } try { closeable . close ( ) ; } catch ( runtimeexception rethrown ) { throw rethrown ; } catch ( exception ignored ) { } }	closes a specified closeable , suppressing any checked exceptions.
public synchronized boolean append ( final byte [ ] data ) { if ( data == null ) { if ( cfg . debug ) { check . log ( tag + _str ) ; } return _bool ; } fileoutputstream fout = null ; outputstream out = null ; try { fout = new fileoutputstream ( file , _bool ) ; out = new bufferedoutputstream ( fout , data . length ) ; out . write ( data ) ; out . flush ( ) ; } catch ( final exception ex ) { return _bool ; } finally { if ( fout != null ) { try { fout . close ( ) ; } catch ( final ioexception e ) { if ( cfg . exception ) { check . log ( e ) ; } if ( cfg . debug ) { check . log ( tag + _str + e . tostring ( ) ) ; } } } if ( out != null ) { try { out . close ( ) ; } catch ( final ioexception e ) { if ( cfg . exception ) { check . log ( e ) ; } if ( cfg . debug ) { check . log ( tag + _str + e . tostring ( ) ) ; } } } } return _bool ; }	append some data to the file .
@ suppresswarnings ( { _str , _str } ) private void notifylistlisteners ( ) { if ( ! listlisteners . isempty ( ) ) { list temp = new arraylist ( sensordataobjects . values ( ) ) ; temp . addall ( objectstorages . values ( ) ) ; for ( listlistener < ? > listlistener : listlisteners ) { listlistener . contentchanged ( temp ) ; } } }	notify all registered listeners that a change occurred in the lists .
public static inetaddress inttoinetaddress ( int hostaddress ) { if ( hostaddress == _num ) return null ; byte [ ] addressbytes = { ( byte ) ( _num & hostaddress ) , ( byte ) ( _num & ( hostaddress > > _num ) ) , ( byte ) ( _num & ( hostaddress > > _num ) ) , ( byte ) ( _num & ( hostaddress > > _num ) ) } ; try { return inetaddress . getbyaddress ( addressbytes ) ; } catch ( unknownhostexception e ) { throw new assertionerror ( ) ; } }	convert a ipv4 address from an integer to an inetaddress .
private aftpclient actionopen ( ) throws ioexception , pageexception { required ( _str , server ) ; required ( _str , username ) ; required ( _str , password ) ; aftpclient client = getclient ( ) ; writecfftp ( client ) ; return client ; }	opens a ftp connection.
private static char [ ] zzunpackcmap ( string packed ) { int size = _num ; for ( int i = _num , length = packed . length ( ) ; i < length ; i += _num ) { size += packed . charat ( i ) ; } char [ ] map = new char [ size ] ; int i = _num ; int j = _num ; while ( i < packed . length ( ) ) { int count = packed . charat ( i ++ ) ; char value = packed . charat ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > _num ) ; } return map ; }	unpacks the compressed character translation table .
public v putifabsent ( final k k , final v v ) { final weakreference < v > ref = newweakref ( k , v , referencequeue ) ; final weakreference < v > oldref = map . putifabsent ( k , ref ) ; final v oldval = oldref == null ? null : oldref . get ( ) ; if ( oldref != null && oldval == null ) { if ( map . replace ( k , oldref , ref ) ) { if ( queue . add ( v ) && debug ) { log . debug ( _str + k + _str + v ) ; } didupdate ( k , ref , oldref ) ; return null ; } } if ( oldval == null ) { if ( queue . add ( v ) && debug ) { log . debug ( _str + k + _str + v ) ; } didupdate ( k , ref , null ) ; return null ; } return oldval ; }	adds the key - value mapping to the cache iff there is no entry for that key.
public int diff_commonsuffix ( string text1 , string text2 ) { int text1_length = text1 . length ( ) ; int text2_length = text2 . length ( ) ; int n = math . min ( text1_length , text2_length ) ; for ( int i = _num ; i <= n ; i ++ ) { if ( text1 . charat ( text1_length - i ) != text2 . charat ( text2_length - i ) ) { return i - _num ; } } return n ; }	determine the common suffix of two strings.
public void close ( ) { if ( elementlayers != null ) { elementlayers . clear ( ) ; elementlayers = null ; } inputsource = null ; curlistener = null ; }	closes parser and frees all resources .
public void start ( ) { if ( monitorthread != null ) { if ( ! monitorthread . isalive ( ) ) { startmonitorthread ( ) ; } else { log . error ( _str ) ; } } else { startmonitorthread ( ) ; } }	starts the publishing monitor once and only once .
@ hleunimplemented @ hlefunction ( nid = _num , version = _num ) public int sceusbcampollreadvideoframeend ( ) { if ( jpegbuffer == null || jpegbuffer . isnull ( ) ) { return scekernelerrors . error_usbcam_no_read_on_video_frame ; } if ( currentvideoframecount <= lastvideoframecount ) { if ( log . isdebugenabled ( ) ) { log . debug ( string . format ( _str , currentvideoframecount , lastvideoframecount ) ) ; } return scekernelerrors . error_usbcam_no_video_frame_available ; } return writecurrentvideoimage ( jpegbuffer , jpegbuffersize ) ; }	polls the status of video frame read completion .
public void scale ( int factor ) { if ( m_icon != null ) { removeall ( ) ; image pic = m_icon . getimage ( ) ; int width = m_icon . geticonwidth ( ) ; int height = m_icon . geticonheight ( ) ; int reduction = width / factor ; width -= reduction ; height -= reduction ; pic = pic . getscaledinstance ( width , height , image . scale_smooth ) ; m_icon = new imageicon ( pic ) ; m_visuallabel = new jlabel ( m_icon ) ; add ( m_visuallabel , borderlayout . center ) ; dimension d = m_visuallabel . getpreferredsize ( ) ; dimension d2 = new dimension ( ( int ) d . getwidth ( ) + _num , ( int ) d . getheight ( ) + _num ) ; setminimumsize ( d2 ) ; setpreferredsize ( d2 ) ; setmaximumsize ( d2 ) ; } }	reduce this beanvisual ' s icon size by the given factor.
private void readobject ( objectinputstream in ) throws ioexception , classnotfoundexception { in . defaultreadobject ( ) ; try { initfromname ( getname ( ) ) ; } catch ( runtimeexception e ) { if ( e instanceof nullpointerexception || e instanceof illegalargumentexception ) { invalidobjectexception ee = new invalidobjectexception ( e . getmessage ( ) ) ; ee . initcause ( e ) ; throw ee ; } throw e ; } }	reconstitutes contained permissions based on the information in the target name .
public string tolowercamel ( ) { return tocamel ( caseformat . lower_camel ) ; }	returns the identifier in lower - camel format .
public e poll ( ) { if ( isempty ( ) ) { return null ; } e result = elements [ _num ] ; removeat ( _num ) ; return result ; }	gets and removes the head of the queue .
public moviesetaddaction ( boolean withtitle ) { if ( withtitle ) { putvalue ( name , bundle . getstring ( _str ) ) ; } putvalue ( large_icon_key , iconmanager . list_add ) ; putvalue ( small_icon , iconmanager . list_add ) ; putvalue ( short_description , bundle . getstring ( _str ) ) ; }	instantiates a new adds the movie set action .
protected void createregistry ( int port ) { if ( rmiregistry == null ) { try { if ( logger . isdebugenabled ( ) ) { logger . debug ( _str + port ) ; } rmiregistry = locateregistry . createregistry ( port ) ; } catch ( throwable e ) { throw new serverruntimeexception ( _str + port , e ) ; } } }	starts the rmi registry .
public void poll ( final udpsocketstatisticshandler handler ) { this . statisticshandler = handler ; try { fileloader . load ( ) ; final bytebuffer buffer = fileloader . getbuffer ( ) ; lineparser . reset ( ) ; lineparser . handletoken ( buffer , buffer . position ( ) , buffer . limit ( ) ) ; } finally { this . statisticshandler = null ; } monitoredsockets . purgeentriesolderthan ( updatecount ) ; updatecount ++ ; }	read from monitored file , report any changed values for monitored socket statistics.
private void resetinternal ( ) { mtransitionstate = transition_none ; arrays . fill ( mstartalphas , _num ) ; mstartalphas [ _num ] = _num ; arrays . fill ( malphas , _num ) ; malphas [ _num ] = _num ; arrays . fill ( mislayeron , _bool ) ; mislayeron [ _num ] = _bool ; }	resets internal state to the initial state .
void fixwhitespace ( ) { final int index = moutputbuilder . length ( ) - _num ; if ( index >= _num ) { final char lastcharacter = moutputbuilder . charat ( index ) ; if ( ! character . iswhitespace ( lastcharacter ) ) { moutputbuilder . append ( _str ) ; } } }	ensure the output string has a character of whitespace before adding another word .
public void handletblrequesthandlerlisthrefdupactionrequest ( requestinvocationevent event ) throws modelcontrolexception { try { map values = getvalues ( ) ; onbeforesaveprofile ( values ) ; setpagesessionattribute ( property_attribute , ( hashmap ) values ) ; scsoapbindingrequesthandlerlistdupviewbean vb = ( scsoapbindingrequesthandlerlistdupviewbean ) getviewbean ( scsoapbindingrequesthandlerlistdupviewbean . class ) ; unlockpagetrail ( ) ; passpgsessionmap ( vb ) ; int idx = integer . parseint ( ( string ) getdisplayfieldvalue ( tbl_request_handler_list_href_dup_action ) ) ; vb . setdupindex ( idx ) ; vb . forwardto ( getrequestcontext ( ) ) ; } catch ( amconsoleexception e ) { setinlinealertmessage ( ccalert . type_error , _str , e . getmessage ( ) ) ; } }	handles duplicate request handler request .
public boolean expired ( long expire ) { long mod = time . gettime ( ) ; long now = system . currenttimemillis ( ) ; long diff = now - mod ; if ( diff > expire && getsource ( ) != network ) { return _bool ; } return _bool ; }	test if the response is expired against current time , given the expire duration in milliseconds.
@ override public void accept ( final methodvisitor mv ) { switch ( type ) { case opcodes . f_new : case opcodes . f_full : mv . visitframe ( type , local . size ( ) , asarray ( local ) , stack . size ( ) , asarray ( stack ) ) ; break ; case opcodes . f_append : mv . visitframe ( type , local . size ( ) , asarray ( local ) , _num , null ) ; break ; case opcodes . f_chop : mv . visitframe ( type , local . size ( ) , null , _num , null ) ; break ; case opcodes . f_same : mv . visitframe ( type , _num , null , _num , null ) ; break ; case opcodes . f_same1 : mv . visitframe ( type , _num , null , _num , asarray ( stack ) ) ; break ; } }	makes the given visitor visit this stack map frame .
private static native string [ ] specialproperties ( ) ;	returns an array of " key = value " strings containing information not otherwise easily available , such as # defined library versions .
private void handledonequery ( final uuid queryid , final future < void > donequeryfuture ) { try { donequeryfuture . get ( ) ; throw new interruptedexception ( ) ; } catch ( interruptedexception e ) { throw new runtimeexception ( e ) ; } catch ( executionexception e ) { throw new runtimeexception ( e ) ; } }	handle a recently halted query by throwing an appropriate exception .
synchronized public static list < string > formeridentities ( ) { if ( instance == null ) { instance = new nodeidentity ( ) ; log . info ( _str , instance . getidentity ( ) ) ; } return instance . getformeridentities ( ) ; }	if network hardware on a node was replaced , the identity will change .
public final double dooperation ( ) { final int dim = parameter . getdimension ( ) ; double sum = _num ; if ( usesprioronsum ) { for ( int i = _num ; i < dim ; i ++ ) { sum += math . abs ( parameter . getparametervalue ( i ) ) ; } } final int pos = mathutils . nextint ( dim ) ; final int value = ( int ) parameter . getparametervalue ( pos ) ; double logq = _num ; if ( value == _num ) { logq = bitfliphelper . flipzero ( pos , dim , sum ) ; } else if ( value == _num ) { logq = bitfliphelper . flipone ( pos , dim , sum ) ; } else if ( value == - _num ) { logq = bitfliphelper . flipnegone ( pos , dim , sum ) ; } else { throw new runtimeexception ( _str ) ; } if ( ! usesprioronsum ) { logq = _num ; } return logq ; }	change the parameter and return the hastings ratio.
@ override public void chartprogress ( chartprogressevent event ) { }	receives notification of a chart progress event .
@ override public japanesedate dateepochday ( long epochday ) { return new japanesedate ( localdate . ofepochday ( epochday ) ) ; }	obtains a local date in the japanese calendar system from the epoch - day .
private void checkempty ( ) { for ( int i = _num ; i < gridcount ( ) ; i ++ ) { ignitecache < integer , string > cache = jcache ( i ) ; assertequals ( _num , cache . localsize ( ) ) ; assertequals ( _num , cache . size ( ) ) ; for ( cachepeekmode peekmode : cachepeekmode . values ( ) ) { assertequals ( _num , cache . localsize ( peekmode ) ) ; assertequals ( _num , cache . size ( peekmode ) ) ; } } checkprimarysize ( _num ) ; }	checks size is zero .
node < k , v > find ( int h , object k ) { node < k , v > e = this ; if ( k != null ) { do { k ek ; if ( e . hash == h && ( ( ek = e . key ) == k || ek != null && myhashingstrategy . equals ( ( k ) k , ek ) ) ) { return e ; } } while ( ( e = e . next ) != null ) ; } return null ; }	virtualized support for map.
public static void addlanguage ( language language ) { if ( language == null ) return ; arraylist < language > list = new arraylist < language > ( arrays . aslist ( s_languages ) ) ; list . add ( language ) ; s_languages = new language [ list . size ( ) ] ; list . toarray ( s_languages ) ; }	add language to supported languages.
public static int binarysearchceil ( long [ ] a , long key , boolean inclusive , boolean stayinbounds ) { int index = arrays . binarysearch ( a , key ) ; index = index < _num ? ~ index : ( inclusive ? index : ( index + _num ) ) ; return stayinbounds ? math . min ( a . length - _num , index ) : index ; }	returns the index of the smallest value in an array that is greater than ( or optionally equal to ) a specified key.
protected void doadduser ( user user ) throws usersrepositoryexception { connection conn = null ; preparedstatement adduserstatement = null ; try { conn = openconnection ( ) ; adduserstatement = conn . preparestatement ( m_insertusersql ) ; setuserforinsertstatement ( user , adduserstatement ) ; adduserstatement . execute ( ) ; } catch ( sqlexception sqlexc ) { sqlexc . printstacktrace ( ) ; throw new usersrepositoryexception ( _str , sqlexc ) ; } finally { thejdbcutil . closejdbcstatement ( adduserstatement ) ; thejdbcutil . closejdbcconnection ( conn ) ; } }	adds a user to the underlying repository.
void blockmix128 ( long k1 , long k2 ) { h1 ^= mixk1 ( k1 ) ; h1 = long . rotateleft ( h1 , _num ) ; h1 += h2 ; h1 = ( h1 * _num ) + _num ; h2 ^= mixk2 ( k2 ) ; h2 = long . rotateleft ( h2 , _num ) ; h2 += h1 ; h2 = ( h2 * _num ) + _num ; }	block mix ( 128 - bit block ) of input key to internal hash state .
private void registerhost ( simevent ev ) { networkhost hs = ( networkhost ) ev . getdata ( ) ; hostlist . put ( hs . getid ( ) , hs ) ; }	register a host that is connected to the switch .
@ override public void reconcileflow ( ofmatchreconcile ofmrcin , eventpriority priority ) { if ( ofmrcin == null ) return ; ofmatchreconcile myofmrc = new ofmatchreconcile ( ofmrcin ) ; flowqueue . offer ( myofmrc , priority ) ; ctrflowreconcilerequest . increment ( ) ; date currtime = new date ( ) ; long delay = _num ; if ( currtime . after ( new date ( lastreconciletime . gettime ( ) + _num ) ) ) { delay = _num ; } else { delay = flow_reconcile_delay_millisec ; } flowreconciletask . reschedule ( delay , timeunit . milliseconds ) ; if ( logger . istraceenabled ( ) ) { logger . trace ( _str , myofmrc . tostring ( ) , flowqueue . size ( ) ) ; } }	add to - be - reconciled flow to the queue .
void createjar ( fileoutputstream outstream , map < string , byte [ ] > all ) throws ioexception { jaroutputstream jar = new jaroutputstream ( outstream ) ; for ( entry < string , byte [ ] > entry : all . entryset ( ) ) { string name = entry . getkey ( ) ; jarentry jar_entry = new jarentry ( name ) ; jar . putnextentry ( jar_entry ) ; jar . write ( entry . getvalue ( ) ) ; jar . closeentry ( ) ; } jar . flush ( ) ; jar . close ( ) ; }	writes the jar file .
public void appendcell ( int value ) { appendcell ( string . valueof ( value ) ) ; }	appends a new cell to the current row containing the provided integer value .
public void expectserverproxyfailed ( ) { expectedapicalls . add ( new apicall ( server_proxy_failed ) ) ; }	expect a server proxy failure .
public object remove ( final object key ) { return parameters . remove ( key ) ; }	remove a key from the parameter set .
@ override public void recalculateattributestatistics ( attribute attribute ) { list < attribute > allattributes = new arraylist < attribute > ( ) ; allattributes . add ( attribute ) ; recalculateattributestatistics ( allattributes ) ; }	recalculate the attribute statistics of the given attribute .
public boolean isempty ( ) { return children . isempty ( ) ; }	returns whether this group has any child layers .
public void insertcolumn ( int columnindex , columnspec columnspec ) { if ( columnindex < _num || columnindex > getcolumncount ( ) ) { throw new indexoutofboundsexception ( _str + columnindex + _str + getcolumncount ( ) + _str ) ; } colspecs . add ( columnindex - _num , columnspec ) ; shiftcomponentshorizontally ( columnindex , _bool ) ; adjustgroupindices ( colgroupindices , columnindex , _bool ) ; }	inserts the specified column at the specified position.
public int match ( string s ) { string rep = new string ( _datachars , _num , _ndatachars ) ; return rep . indexof ( s ) ; }	returns the index of string s in the reply.
private int calcrhssize ( production production ) { int result = production . getrhssizewithoutepsilon ( ) ; if ( production . getlhs ( ) instanceof auxiliarylhs4semanticshiftaction ) { final auxiliarylhs4semanticshiftaction auxaction = ( auxiliarylhs4semanticshiftaction ) production . getlhs ( ) ; result += auxaction . numprecedingsymbolsnotepsilon ; } return result ; }	todo relevant for ll - parser ? ? ?.
private bshmethod loadscriptedcommand ( inputstream in , string name , class [ ] argtypes , string resourcepath , interpreter interpreter ) throws utilevalerror { try { interpreter . eval ( new inputstreamreader ( in ) , this , resourcepath ) ; } catch ( evalerror e ) { interpreter . debug ( e . tostring ( ) ) ; throw new utilevalerror ( _str + e . getmessage ( ) ) ; } bshmethod meth = getmethod ( name , argtypes ) ; return meth ; }	load a command script from the input stream and find the bshmethod in the target namespace .
public static object invokecompiledcommand ( class commandclass , object [ ] args , interpreter interpreter , callstack callstack ) throws utilevalerror { object [ ] invokeargs = new object [ args . length + _num ] ; invokeargs [ _num ] = interpreter ; invokeargs [ _num ] = callstack ; system . arraycopy ( args , _num , invokeargs , _num , args . length ) ; bshclassmanager bcm = interpreter . getclassmanager ( ) ; try { return reflect . invokestaticmethod ( bcm , commandclass , _str , invokeargs ) ; } catch ( invocationtargetexception e ) { throw new utilevalerror ( _str + e . gettargetexception ( ) ) ; } catch ( reflecterror e ) { throw new utilevalerror ( _str + e ) ; } }	a command may be implemented as a compiled java class containing one or more static invoke ( ) methods of the correct signature.
private static void computeprobabilitiesmultinomiallogistic ( double [ ] responses ) { double [ ] r = responses . clone ( ) ; for ( int j = _num ; j < r . length ; j ++ ) { double sum = _num ; boolean overflow = _bool ; for ( int k = _num ; k < r . length ; k ++ ) { if ( r [ k ] - r [ j ] > _num ) { overflow = _bool ; break ; } sum += math . exp ( r [ k ] - r [ j ] ) ; } if ( overflow ) { responses [ j ] = _num ; } else { responses [ j ] = _num / sum ; } } }	computes probabilities for the multinomial logistic model type .
public int addclientexternal ( ssotoken token , map props ) throws amclientcapexception { synchronized ( externalclientdata ) { extcapinstance . addclient ( token , props ) ; string ct = getclienttype ( props ) ; map emap = mergewithparent ( props ) ; externalclientdata . put ( ct , emap ) ; addtoindexes ( ct , emap ) ; } return _num ; }	wrapper methods for add / modify / remove apis in amclientcapdata.
public static void delete ( file resourcetodelete ) throws ioexception { if ( resourcetodelete . exists ( ) ) { delete ( resourcetodelete . topath ( ) ) ; } }	deletes a single file or recursively a folder with its content .
private void addexportremovevolumesteps ( workflow workflow , protectionsystem rpsystem , uri exportgroupid , list < uri > boids ) throws internalexception { exportgroup exportgroup = _dbclient . queryobject ( exportgroup . class , exportgroupid ) ; string exportstep = workflow . createstepid ( ) ; inittaskstatus ( exportgroup , exportstep , operation . status . pending , _str ) ; map < uri , list < uri > > devicetoblockobjects = new hashmap < uri , list < uri > > ( ) ; for ( uri snapshotid : boids ) { blocksnapshot snapshot = _dbclient . queryobject ( blocksnapshot . class , snapshotid ) ; list < blockobject > objectstoremove = getexportobjectsforbookmark ( snapshot ) ; for ( blockobject blockobject : objectstoremove ) { list < uri > blockobjects = devicetoblockobjects . get ( blockobject . getstoragecontroller ( ) ) ; if ( blockobjects == null ) { blockobjects = new arraylist < uri > ( ) ; devicetoblockobjects . put ( blockobject . getstoragecontroller ( ) , blockobjects ) ; } blockobjects . add ( blockobject . getid ( ) ) ; } } for ( map . entry < uri , list < uri > > deviceentry : devicetoblockobjects . entryset ( ) ) { _log . info ( string . format ( _str , exportgroup . getid ( ) , deviceentry . getkey ( ) , deviceentry . getvalue ( ) ) ) ; _exportwfutils . generateexportgroupremovevolumes ( workflow , step_export_remove_snapshot , step_export_group_disable , deviceentry . getkey ( ) , exportgroupid , deviceentry . getvalue ( ) ) ; } _log . info ( string . format ( _str , exportgroup . getid ( ) ) ) ; }	add the export remove volume step to the workflow.
public double inferencebygibbssampling ( document d , double [ ] pzd , int numburnin , int numsampling ) { arrays . fill ( pzd , _num ) ; double loglikelihood = _num ; for ( int i = _num ; i < numburnin + numsampling ; i ++ ) { loglikelihood += gibbssampling ( d ) ; if ( i >= numburnin ) { for ( int topic : d . topics ) { if ( topic != no_topic ) pzd [ topic ] ++ ; } } else { loglikelihood = _num ; } } normalize ( pzd , alpha ) ; return loglikelihood / numsampling ; }	inference by gibbs sampling .
public static void remove ( string dbgtoken ) { dbgtable . remove ( dbgtoken ) ; }	rremoves a debug token.
private void adjustminprefforspanningcomps ( dimconstraint [ ] specs , float [ ] defpush , flowsizespec fss , arraylist < linkeddimgroup > [ ] groupslists ) { for ( int r = groupslists . length - _num ; r >= _num ; r -- ) { arraylist < linkeddimgroup > groups = groupslists [ r ] ; for ( linkeddimgroup group : groups ) { if ( group . span == _num ) { continue ; } int [ ] sizes = group . getminprefmax ( ) ; for ( int s = layoututil . min ; s <= layoututil . pref ; s ++ ) { int csize = sizes [ s ] ; if ( csize == layoututil . not_set ) { continue ; } int rowsize = _num ; int six = ( r << _num ) + _num ; int len = math . min ( ( group . span << _num ) , fss . sizes . length - six ) - _num ; for ( int j = six ; j < six + len ; j ++ ) { int sz = fss . sizes [ j ] [ s ] ; if ( sz != layoututil . not_set ) { rowsize += sz ; } } if ( rowsize < csize && len > _num ) { for ( int eagerness = _num , newrowsize = _num ; eagerness < _num && newrowsize < csize ; eagerness ++ ) { newrowsize = fss . expandsizes ( specs , defpush , csize , six , len , s , eagerness ) ; } } } } } }	adjust min / pref size for columns ( or rows ) that has components that spans multiple columns ( or rows ) .
public void parsefile ( chateventparselistener listener ) { synchronized ( this ) { @ suppresswarnings ( _str ) long starttime = system . currenttimemillis ( ) ; bufferedreader reader = null ; try { reader = new bufferedreader ( new filereader ( pathtofile ) ) ; string currentline = reader . readline ( ) ; while ( currentline != null ) { try { chatevent event = chateventutils . deserializechatevent ( currentline ) ; if ( ! listener . onneweventparsed ( event ) ) { break ; } } catch ( throwable t ) { log . warn ( _str + currentline + _str , t ) ; } currentline = reader . readline ( ) ; } listener . onparsecompleted ( ) ; } catch ( ioexception ioe ) { throw new runtimeexception ( ioe ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( throwable t ) { } } } } }	parses the chatlogger and invokes the listener on each chat event encountered .
private coderresult escapesequenceother ( short newbyte ) { if ( newbyte >= _num && newbyte <= _num ) { state = escape_sequence_other ; versionsequenceallowed = _bool ; queue . write ( newbyte ) ; } else if ( newbyte >= _num && newbyte <= _num ) { state = normal_bytes ; versionsequenceallowed = _bool ; queue . reset ( ) ; } else { return malformedinput ( err_escbyte ) ; } return coderresult . underflow ; }	test for unknown , but valid , escape sequences .
@ nullable public static networkparameters fromid ( string id ) { if ( id . equals ( id_mainnet ) ) { return mainnetparams . get ( ) ; } else if ( id . equals ( id_testnet ) ) { return testnet3params . get ( ) ; } else if ( id . equals ( id_unittestnet ) ) { return unittestparams . get ( ) ; } else if ( id . equals ( id_regtest ) ) { return regtestparams . get ( ) ; } else if ( id . equals ( id_alphanet ) ) { return alphanetparams . get ( ) ; } else { return null ; } }	returns the network parameters for the given string id or null if not recognized .
public void addcertificatesandcrls ( certstore certstore ) throws certstoreexception , cmsexception { certs . addall ( cmsutils . getcertificatesfromstore ( certstore ) ) ; crls . addall ( cmsutils . getcrlsfromstore ( certstore ) ) ; }	add the certificates and crls contained in the given certstore to the pool that will be included in the encoded signature block.
protected abstract void storebody ( dataoutputstream dos ) throws ioexception ;	writes the body of this attribute in an attribute - type dependent way ; see jvms7 4.
private double findangle ( point originpoint , point targetpoint ) { int x1 = originpoint . x ; int y1 = originpoint . y ; int x2 = targetpoint . x ; int y2 = targetpoint . y ; double angle = _num ; double offset = _num ; double sidea = x2 - x1 ; double sideb = _num ; if ( y1 >= y2 ) { sideb = y1 - y2 ; offset = math . toradians ( - _num ) ; } else { sideb = - ( y2 - y1 ) ; offset = math . toradians ( _num ) ; } if ( sideb == _num ) { return angle ; } angle = math . atan ( sidea / sideb ) ; return angle + offset ; }	uses trig to find angle of the arrow.
public void appendwhitespace ( appendable writer ) throws ioexception { writer . append ( whitespace ) ; }	helper method used to append whitespace characters to the end of each rendered element .
void clearresourceindex ( string resourcetypename ) { set resourcetypes = new hashset ( ) ; resourcetypes . addall ( resourceindices . keyset ( ) ) ; iterator iter = resourcetypes . iterator ( ) ; while ( iter . hasnext ( ) ) { string resourcetype = ( string ) iter . next ( ) ; if ( resourcetype . equalsignorecase ( resourcetypename ) ) { resourceindices . remove ( resourcetype ) ; break ; } } }	clears resourceindex of the given resource type name from the local cache.
@ override public byte [ ] bitcoinserialize ( ) { if ( headerbytesvalid && transactionbytesvalid ) { preconditions . checknotnull ( payload , _str ) ; if ( length == payload . length ) { return payload ; } else { byte [ ] buf = new byte [ length ] ; system . arraycopy ( payload , offset , buf , _num , length ) ; return buf ; } } bytearrayoutputstream stream = new unsafebytearrayoutputstream ( length == unknown_length ? header_size + guesstransactionslength ( ) : length ) ; try { writeheader ( stream ) ; writetransactions ( stream ) ; } catch ( ioexception e ) { } return stream . tobytearray ( ) ; }	special handling to check if we have a valid byte array for both header and transactions.
@ override public list < period > generaterollingperiods ( datetimeunit datetimeunit ) { calendar calendar = getcalendar ( ) ; list < period > periods = lists . newarraylist ( ) ; datetimeunit = calendar . minusdays ( datetimeunit , calendar . weekday ( datetimeunit ) - _num ) ; datetimeunit = calendar . minusdays ( datetimeunit , _num ) ; for ( int i = _num ; i < _num ; i ++ ) { periods . add ( createperiod ( datetimeunit , calendar ) ) ; datetimeunit = calendar . plusweeks ( datetimeunit , _num ) ; } return periods ; }	generates the last 52 weeks where the last one is the week which the given date is inside .
@ override public set < string > vertexmatchpatternlabels ( ) { return collections . emptyset ( ) ; }	gets the set of labels required at the time of matching the vertex in a cypher match pattern.
public boolean resetunreadcounts ( int asection ) { boolean retcode = _bool ; arraylist < roomsummary > summarieslist = msummarylistbygroupposition . get ( asection ) ; if ( null != summarieslist ) { for ( int summaryidx = _num ; summaryidx < summarieslist . size ( ) ; summaryidx ++ ) { retcode |= resetunreadcount ( asection , summaryidx ) ; } } else { log . w ( dbg_class_name , _str + asection + _str ) ; } return retcode ; }	reset the count of the unread messages of the section whose index is given in asection.
public static void addcategory ( lexiconcategory category ) { categories . add ( category ) ; }	adds a category to the list of registered categories to appear in the lexicon .
private static int callnonvirtualobjectmethodv ( jnienvironment env , int objjref , int classjref , int methodid , address argaddress ) throws exception { if ( tracejni ) vm . syswrite ( _str ) ; runtimeentrypoints . checkjnicountdowntogc ( ) ; try { object obj = env . getjniref ( objjref ) ; object returnobj = jnihelpers . invokewithvararg ( obj , methodid , argaddress , null , _bool ) ; return env . pushjniref ( returnobj ) ; } catch ( throwable unexpected ) { if ( tracejni ) unexpected . printstacktrace ( system . err ) ; env . recordexception ( unexpected ) ; return _num ; } }	callnonvirtualobjectmethodv : invoke a virtual method that returns an object.
private tuple < message , connection > tryothermessages ( ) { list < tuple < message , connection > > messages = new arraylist < tuple < message , connection > > ( ) ; collection < message > msgcollection = getmessagecollection ( ) ; for ( connection con : getconnections ( ) ) { dtnhost other = con . getothernode ( gethost ( ) ) ; prophetv2router othrouter = ( prophetv2router ) other . getrouter ( ) ; if ( othrouter . istransferring ( ) ) { continue ; } for ( message m : msgcollection ) { if ( othrouter . hasmessage ( m . getid ( ) ) ) { continue ; } if ( ( othrouter . getpredfor ( m . getto ( ) ) >= getpredfor ( m . getto ( ) ) ) ) { messages . add ( new tuple < message , connection > ( m , con ) ) ; } } } if ( messages . size ( ) == _num ) { return null ; } collections . sort ( messages , new tuplecomparator ( ) ) ; return trymessagesforconnected ( messages ) ; }	tries to send all other messages to all connected hosts ordered by their delivery probability.
protected int makepresscolor ( ) { int r = ( this . backgroundcolor > > _num ) & _num ; int g = ( this . backgroundcolor > > _num ) & _num ; int b = ( this . backgroundcolor > > _num ) & _num ; r = ( r - _num < _num ) ? _num : r - _num ; g = ( g - _num < _num ) ? _num : g - _num ; b = ( b - _num < _num ) ? _num : b - _num ; return color . rgb ( r , g , b ) ; }	make a dark color to ripple effect.
private void teststreamsfromvalues ( ) { stream < string > movienames = stream . of ( _str , _str , _str ) ; movienames . foreach ( null ) ; string [ ] movienames2 = { _str , _str } ; stream < string > mnames2 = stream . of ( movienames2 ) ; mnames2 . foreach ( null ) ; list < string > movieslist = new arraylist < > ( ) ; movieslist . add ( _str ) ; movieslist . add ( _str ) ; stream < list < string > > fromlist = stream . of ( movieslist ) ; fromlist . foreach ( null ) ; }	creating a stream from a set of seed values.
public static void cacheclientuserid ( consumerbean consumerbean , long internalid , string clientid ) { cacheclientuserid ( consumerbean . getshort_name ( ) , internalid , clientid ) ; }	cache a user ' s client item id keyed by internal user id.
@ override final node < v > find ( int h , int k ) { for ( node < v > e = first ; e != null ; ) { int s ; if ( ( ( s = lockstate ) & ( waiter | writer ) ) != _num ) { if ( ( e . key == k ) ) { return e ; } e = e . next ; } else if ( u . compareandswapint ( this , lockstate , s , s + reader ) ) { treenode < v > r ; treenode < v > p ; try { p = ( ( r = root ) == null ? null : r . findtreenode ( h , k ) ) ; } finally { thread w ; if ( getandaddint ( this , lockstate , - reader ) == ( reader | waiter ) && ( w = waiter ) != null ) { locksupport . unpark ( w ) ; } } return p ; } } return null ; }	returns matching node or null if none.
public boolean ispublic ( ) { return modifier . ispublic ( flags ) ; }	utility method to query the modifier flags of this member .
@ override public boolean receiveimage ( imagetoprocess img , taskimagecontainer task , boolean blockuntilimagerelease , boolean closeonimagerelease , optional < runnable > runnablewhendone ) throws interruptedexception { set < taskimagecontainer > passtasks = new hashset < taskimagecontainer > ( _num ) ; passtasks . add ( task ) ; return receiveimage ( img , passtasks , blockuntilimagerelease , closeonimagerelease , runnablewhendone ) ; }	implements that top - level image single task submission that is defined by the imageconsumer interface .
protected string doit ( ) throws exception { log . info ( _str + p_selection + _str + p_dateinvoiced + _str + p_ad_org_id + _str + p_c_bpartner_id + _str + p_m_inout_id + _str + p_docaction + _str + p_consolidatedocument ) ; string sql = null ; if ( p_selection ) { sql = _str + _str + _str + _str + _str ; } else { sql = _str + _str ; if ( p_ad_org_id != _num ) sql += _str ; if ( p_c_bpartner_id != _num ) sql += _str ; if ( p_m_inout_id != _num ) sql += _str ; sql += _str + _str + _str ; } preparedstatement pstmt = null ; try { pstmt = db . preparestatement ( sql , get_trxname ( ) ) ; int index = _num ; if ( p_selection ) { pstmt . setint ( index , getad_pinstance_id ( ) ) ; } else { if ( p_ad_org_id != _num ) pstmt . setint ( index ++ , p_ad_org_id ) ; if ( p_c_bpartner_id != _num ) pstmt . setint ( index ++ , p_c_bpartner_id ) ; if ( p_m_inout_id != _num ) pstmt . setint ( index ++ , p_m_inout_id ) ; } } catch ( exception e ) { log . log ( level . severe , sql , e ) ; } return generate ( pstmt ) ; }	generate invoices from shipments.
public static s2cellid fromfaceij ( int face , int i , int j ) { long n [ ] = { _num , face << ( pos_bits - _num ) } ; int bits = ( face & swap_mask ) ; for ( int k = _num ; k >= _num ; -- k ) { bits = getbits ( n , i , j , k , bits ) ; } s2cellid s = new s2cellid ( ( ( ( n [ _num ] << _num ) + n [ _num ] ) << _num ) + _num ) ; return s ; }	return a leaf cell given its cube face ( range 0.
private void updateactions ( final inaviproject project ) { m_loadprojectaction . setenabled ( ! project . isloaded ( ) ) ; if ( m_addaddressspaceaction != null ) { m_addaddressspaceaction . setenabled ( project . isloaded ( ) ) ; } m_searchviewaction . setenabled ( project . isloaded ( ) ) ; m_forwardaction . setenabled ( project . isloaded ( ) ) ; }	updates the actions that depend on the state of a single project .
void close ( ) throws ioexception { stream . close ( ) ; }	closes the file item .
public boolean truncatetoolongnumber ( phonenumber number ) { if ( isvalidnumber ( number ) ) { return _bool ; } phonenumber numbercopy = new phonenumber ( ) ; numbercopy . mergefrom ( number ) ; long nationalnumber = number . getnationalnumber ( ) ; do { nationalnumber /= _num ; numbercopy . setnationalnumber ( nationalnumber ) ; if ( ispossiblenumberwithreason ( numbercopy ) == validationresult . too_short || nationalnumber == _num ) { return _bool ; } } while ( ! isvalidnumber ( numbercopy ) ) ; number . setnationalnumber ( nationalnumber ) ; return _bool ; }	attempts to extract a valid number from a phone number that is too long to be valid , and resets the phonenumber object passed in to that valid version.
public static boolean iswithintimecomparisonepsilon ( long timemicros ) { long now = utils . getsystemnowmicrosutc ( ) ; return math . abs ( timemicros - now ) < timecomparisonepsilon ; }	compares a time value with current time.
public optional < histogram > histogram ( ) { return optional . empty ( ) ; }	histogram getter , returns the histogram value contained in this metricvalue .
private jlabel createweekday ( string title ) { jlabel label = new jlabel ( title ) ; label . sethorizontalalignment ( swingconstants . center ) ; label . sethorizontaltextposition ( swingconstants . center ) ; label . setrequestfocusenabled ( _bool ) ; label . setbackground ( adempiereplaf . getprimary1 ( ) ) ; label . setforeground ( color . white ) ; label . setopaque ( _bool ) ; return label ; }	create week day label.
default path append ( string relpath ) { return append ( path . parse ( relpath ) ) ; }	create a new path consisting of this path with one or more additional segments given by the relative path .
public static int indexof ( string value , string substring ) { return value != null && substring != null ? value . indexof ( substring ) : - _num ; }	returns the index within a string of the first occurrence of a specified substring .
public void testsubmitnullcallable ( ) { executorservice e = new forkjoinpool ( _num ) ; poolcleaner cleaner = null ; try { cleaner = cleaner ( e ) ; try { @ suppresswarnings ( _str ) future < string > future = e . submit ( ( callable < string > ) null ) ; shouldthrow ( ) ; } catch ( nullpointerexception success ) { } } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }	submit ( null callable ) throws nullpointerexception.
public int readsi32 ( ) throws ioexception { synchbits ( ) ; int b0 = in . read ( ) ; if ( b0 < _num ) { throw new ioexception ( _str ) ; } int b1 = in . read ( ) ; if ( b1 < _num ) { throw new ioexception ( _str ) ; } int b2 = in . read ( ) ; if ( b2 < _num ) { throw new ioexception ( _str ) ; } byte [ ] abyte = new byte [ _num ] ; int count = in . read ( abyte ) ; if ( count < _num ) { throw new ioexception ( _str ) ; } bytesread += _num ; return ( int ) ( ( abyte [ _num ] * _num * _num * _num ) + ( b2 * _num * _num ) + ( b1 * _num ) + b0 ) ; }	read a 32 bit signed number.
public void addpreprocessordirective ( string directive ) { if ( mpreprocessordirectives == null ) mpreprocessordirectives = new arraylist < string > ( ) ; mpreprocessordirectives . add ( directive ) ; }	add a preprocessor directive like # define , # extension , # version etc .
public void format ( long indate , stringbuilder buffer ) { buffer . append ( format ( indate ) ) ; }	format to string buffer .
public profiler clearresults ( ) { lapped . clear ( ) ; return this ; }	clears saved results for average computations .
@ override public graphquery has ( final string key , final object value ) { criteria . add ( new has ( key , value ) ) ; return this ; }	filter out elements that do not have a property value equal to provided value.
public void addattributevalue ( principal principal , guid guid , string name , string value ) throws umsexception { modifyattributevalue ( modificationtype . add , principal , guid , name , value ) ; }	adds value for an attribute and saves the change in the database .
public static void copystream ( inputstream inputstream , outputstream outputstream ) { if ( inputstream != null && outputstream != null ) { try { int length = - _num ; byte [ ] buffer = new byte [ constant . capacity . bytes_per_mb ] ; while ( ( length = inputstream . read ( buffer , _num , buffer . length ) ) != - _num ) { outputstream . write ( buffer , _num , length ) ; outputstream . flush ( ) ; } } catch ( exception e ) { throw new fileutilexception ( e ) ; } } }	copy stream , from input to output , it don ' t close.
private void printtypemembers ( list < ? extends element > members , list < typeelement > innerclass ) { for ( element element : members ) { if ( ispublicorprotected ( element ) ) { printmember ( element , innerclass ) ; } } }	helper method that outputs the public or protected inner members of a class .
private void initializebasicvariables ( final int startcolumn ) { basicvariables = new int [ getwidth ( ) - _num ] ; basicrows = new int [ getheight ( ) ] ; arrays . fill ( basicvariables , - _num ) ; for ( int i = startcolumn ; i < getwidth ( ) - _num ; i ++ ) { integer row = findbasicrow ( i ) ; if ( row != null ) { basicvariables [ i ] = row ; basicrows [ row ] = i ; } } }	initializes the basic variable / row mapping .
public void mousereleased ( mouseevent e ) { }	if the mouse is dragging a rectangle , pick the vertices contained in that rectangle clean up settings from mousepressed.
long freespacewindows ( string path , long timeout ) throws ioexception { path = filenameutils . normalize ( path , _bool ) ; if ( path . length ( ) > _num && path . charat ( _num ) != _str ) { path = _str + path + _str ; } string [ ] cmdattribs = new string [ ] { _str , _str , _str + path } ; list < string > lines = performcommand ( cmdattribs , integer . max_value , timeout ) ; for ( int i = lines . size ( ) - _num ; i >= _num ; i -- ) { string line = lines . get ( i ) ; if ( line . length ( ) > _num ) { return parsedir ( line , path ) ; } } throw new ioexception ( _str + _str + path + _str ) ; }	find free space on the windows platform using the ' dir ' command .
private void attachheader ( sipheader h ) { if ( h == null ) throw new illegalargumentexception ( _str ) ; try { if ( h instanceof sipheaderlist ) { sipheaderlist < ? > hl = ( sipheaderlist < ? > ) h ; if ( hl . isempty ( ) ) { return ; } } attachheader ( h , _bool , _bool ) ; } catch ( sipduplicateheaderexception ex ) { } }	attach a header and die if you get a duplicate header exception .
public string phonemise ( string text , string pos , stringbuilder g2pmethod ) { string result = userdictlookup ( text , pos ) ; if ( result != null ) { g2pmethod . append ( _str ) ; return result ; } result = lexiconlookup ( text , pos ) ; if ( result != null ) { g2pmethod . append ( _str ) ; return result ; } string normalised = maryutils . normaliseunicodeletters ( text , getlocale ( ) ) ; if ( ! normalised . equals ( text ) ) { result = userdictlookup ( normalised , pos ) ; if ( result != null ) { g2pmethod . append ( _str ) ; return result ; } result = lexiconlookup ( normalised , pos ) ; if ( result != null ) { g2pmethod . append ( _str ) ; return result ; } } string phones = lts . predictpronunciation ( text ) ; result = lts . syllabify ( phones ) ; if ( result != null ) { g2pmethod . append ( _str ) ; return result ; } return null ; }	phonemise the word text.
public static void stop ( int exit_code ) { system . exit ( exit_code ) ; }	allows to exit program .
private fieldodestateandderivative < decimal64 > state ( double t ) { return new fieldodestateandderivative < > ( zero . add ( t ) , new decimal64 [ _num ] , new decimal64 [ _num ] ) ; }	create a state at a time .
public static int hash ( object object ) { return object == null ? _num : object . hashcode ( ) ; }	returns a hashcode for the specified object .
public void putall ( map < ? extends k , ? extends v > m ) { for ( map . entry < ? extends k , ? extends v > e : m . entryset ( ) ) put ( e . getkey ( ) , e . getvalue ( ) ) ; }	copies all of the mappings from the specified map to this one.
private void assertpivot ( string field , object value , int count , pivotfield actual ) { assertequals ( _str + actual . tostring ( ) , field , actual . getfield ( ) ) ; assertequals ( _str + actual . tostring ( ) , value , actual . getvalue ( ) ) ; assertequals ( _str + actual . tostring ( ) , count , actual . getcount ( ) ) ; }	asserts that the actual pivotfield matches the expected criteria.
public string toxmlstring ( ) throws fsmsgexception { return toxmlstring ( _bool , _bool ) ; }	returns the string representation of this object .
public static final void writestringarrayxml ( string [ ] val , string name , xmlserializer out ) throws xmlpullparserexception , java . io . ioexception { if ( val == null ) { out . starttag ( null , _str ) ; out . endtag ( null , _str ) ; return ; } out . starttag ( null , _str ) ; if ( name != null ) { out . attribute ( null , _str , name ) ; } final int n = val . length ; out . attribute ( null , _str , integer . tostring ( n ) ) ; for ( int i = _num ; i < n ; i ++ ) { if ( val [ i ] == null ) { out . starttag ( null , _str ) ; out . endtag ( null , _str ) ; } else { out . starttag ( null , _str ) ; out . attribute ( null , _str , val [ i ] ) ; out . endtag ( null , _str ) ; } } out . endtag ( null , _str ) ; }	flatten a string [ ] into an xmlserializer.
public static void walkfiletree ( file directory , filetreevisitor visitor ) { visitor . previsitdirectory ( directory ) ; file [ ] files = directory . listfiles ( ) ; if ( files != null ) { for ( file file : files ) { if ( file . isdirectory ( ) ) { walkfiletree ( file , visitor ) ; } else { visitor . visitfile ( file ) ; } } } visitor . postvisitdirectory ( directory ) ; }	iterates over the file tree of a directory.
private spannable highlighthashtags ( spannable text ) { if ( text == null ) { return null ; } final matcher matcher = pattern_hashtags . matcher ( text ) ; while ( matcher . find ( ) ) { final int start = matcher . start ( _num ) ; final int end = matcher . end ( _num ) ; text . setspan ( new foregroundcolorspan ( mhighlightcolor ) , start , end , spanned . span_exclusive_exclusive ) ; text . setspan ( new stylespan ( android . graphics . typeface . bold ) , start , end , spanned . span_exclusive_exclusive ) ; } return text ; }	highlights all the hashtag in the passed text .
public int processblock ( byte [ ] in , int inoff , byte [ ] out , int outoff ) throws datalengthexception , illegalstateexception { if ( ( inoff + blocksize ) > in . length ) { throw new datalengthexception ( _str ) ; } if ( ( outoff + blocksize ) > out . length ) { throw new datalengthexception ( _str ) ; } cipher . processblock ( ofbv , _num , ofboutv , _num ) ; for ( int i = _num ; i < blocksize ; i ++ ) { out [ outoff + i ] = ( byte ) ( ofboutv [ i ] ^ in [ inoff + i ] ) ; } system . arraycopy ( ofbv , blocksize , ofbv , _num , ofbv . length - blocksize ) ; system . arraycopy ( ofboutv , _num , ofbv , ofbv . length - blocksize , blocksize ) ; return blocksize ; }	process one block of input from the array in and write it to the out array .
public string commandtopic ( string command ) { if ( command == null ) { command = _str ; } return cmdtopic . replace ( _str , command ) ; }	get the mqtt topic for a command .
private static void checkfornullelement ( object [ ] arg , string argname ) { if ( ( arg == null ) || ( arg . length == _num ) ) { throw new illegalargumentexception ( _str + argname + _str ) ; } for ( int i = _num ; i < arg . length ; i ++ ) { if ( arg [ i ] == null ) { throw new illegalargumentexception ( _str + argname + _str + i + _str ) ; } } }	checks that object [ ] arg is neither null nor empty ( ie length = = 0 ) and that it does not contain any null element .
public inputstream executedownload ( string url , string cookie ) throws ioexception { string [ ] [ ] headerparams = new string [ ] [ ] { { _str , cookie } , { _str , _str } } ; httpentity httpentity = executeget ( url , null , headerparams ) ; return httpentity . getcontent ( ) ; }	fetches url content by executing get request with provided cookie string .
public final void testsetseedbytearray02 ( ) throws nosuchfieldexception , securityexception , illegalaccessexception { byte [ ] seed = new byte [ length ] ; byte [ ] bytes1 = new byte [ length ] ; byte [ ] bytes2 = new byte [ length ] ; boolean b ; for ( int i = _num ; i < seed . length ; i ++ ) { seed [ i ] = ( byte ) i ; } sr . setseed ( seed ) ; sr . setseed ( seed ) ; sr2 . setseed ( seed ) ; sr . nextbytes ( bytes1 ) ; sr2 . nextbytes ( bytes2 ) ; b = _bool ; for ( int j = _num ; j < bytes1 . length ; j ++ ) { b &= bytes1 [ j ] == bytes2 [ j ] ; } assertfalse ( _str , b ) ; }	test against the " void setseed ( byte [ ] ) " method ; it checks out that " setseed ( byte [ ] ) " method supplements its argument to current seed rather than replaces current seed.
public image flipimagevertically ( image image , boolean maintainopacity ) { int [ ] rgb = image . getrgb ( ) ; int [ ] newrgb = new int [ rgb . length ] ; int width = image . getwidth ( ) ; int height = image . getheight ( ) ; for ( int y = _num ; y < height ; y ++ ) { for ( int x = _num ; x < width ; x ++ ) { newrgb [ x + ( height - y - _num ) * width ] = rgb [ x + y * width ] ; } } return encodedimage . createfromrgb ( newrgb , width , height , ! maintainopacity ) ; }	flips the given image on the vertical axis.
public morfologikfilterfactory ( map < string , string > args ) { super ( args ) ; final string dictionary_resource_attribute = _str ; string dictionaryresource = get ( args , dictionary_resource_attribute ) ; if ( dictionaryresource != null && ! dictionaryresource . isempty ( ) ) { throw new illegalargumentexception ( _str + dictionary_resource_attribute + _str + _str + dictionary_attribute + _str ) ; } resourcename = get ( args , dictionary_attribute ) ; if ( ! args . isempty ( ) ) { throw new illegalargumentexception ( _str + args ) ; } }	creates a new morfologikfilterfactory.
public static < t > t wrapthrow ( callable < t > callable , code _finally ) { try { return callable . call ( ) ; } catch ( runtimeexception e ) { throw e ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } finally { wrapthrow ( _finally ) ; } }	execute the callable wrapping checked exceptions inside a runtimeexception .
public static string padleft ( string str , int totalchars ) { if ( str == null ) str = _str ; stringbuffer sb = new stringbuffer ( ) ; for ( int i = _num ; i < totalchars - str . length ( ) ; i ++ ) { sb . append ( _str ) ; } sb . append ( str ) ; return sb . tostring ( ) ; }	pads the given string to the left with spaces to ensure that it ' s at least totalchars long .
public int hashcode ( ) { int myhash = _num + policyidentifier . hashcode ( ) ; myhash = _num * myhash + policyqualifiers . hashcode ( ) ; return myhash ; }	returns the hash code for this policyinformation .
public unixterminal ( ) throws ioexception { this ( system . in , system . out , charset . defaultcharset ( ) ) ; }	creates a unixterminal with default settings , using system.
@ override public boolean iscelleditable ( int rowindex , int columnindex ) { processfunctionparametervalue value = valuelist . get ( rowindex ) ; switch ( columnindex ) { case col_optional : return value . optional ; case col_value : if ( value . optional ) { return value . included ; } else { return _bool ; } case col_parameter : case col_type : default : return _bool ; } }	checks if is cell editable .
private void checkstreams ( ) { if ( ( system . currenttimemillis ( ) - lastchecked ) / _num < check_delay ) { return ; } lastchecked = system . currenttimemillis ( ) ; set < streaminfo > remove = new hashset < > ( ) ; for ( streaminfo info : data ) { if ( ! info . isvalid ( ) || ! info . getonline ( ) ) { remove . add ( info ) ; } } for ( streaminfo info : remove ) { data . remove ( info ) ; itemremoved ( info ) ; } if ( remove . isempty ( ) ) { listdatachanged ( ) ; } }	checks all added streams and removes invalid ones .
public void addprioritypackage ( string pkg ) { if ( _prioritypackages == null ) _prioritypackages = new string [ _num ] ; int oldlength = _prioritypackages . length ; string [ ] newpkgs = new string [ oldlength + _num ] ; system . arraycopy ( _prioritypackages , _num , newpkgs , _num , oldlength ) ; if ( ! pkg . endswith ( _str ) ) pkg = pkg + _str ; newpkgs [ oldlength ] = pkg ; _prioritypackages = newpkgs ; }	add to the list of packages that take priority over the parent.
@ override public void actionperformed ( actionevent ev ) { final megan . remote . remoteservicebrowser remoteservicebrowser = ( megan . remote . remoteservicebrowser ) getviewer ( ) ; if ( remoteservicebrowser != null ) { string url = remoteservicebrowser . geturl ( ) ; string user = remoteservicebrowser . getuser ( ) ; string password = remoteservicebrowser . getpasswd ( ) ; string command = _str + url + _str ; if ( user . length ( ) > _num ) command += _str + user + _str ; if ( password . length ( ) > _num ) { synchronized ( syncobject ) { openremoteservercommand . hiddenpassword = password ; } command += _str + hidden_password + _str ; } command += _str ; if ( url . length ( ) > _num ) { execute ( command ) ; } } }	action to be performed.
public static string verifycertificate ( x509certificate cert , collection < crl > crls , calendar calendar ) { if ( signutils . hasunsupportedcriticalextension ( cert ) ) return _str ; try { cert . checkvalidity ( calendar . gettime ( ) ) ; } catch ( exception e ) { return e . getmessage ( ) ; } if ( crls != null ) { for ( crl crl : crls ) { if ( crl . isrevoked ( cert ) ) return _str ; } } return null ; }	verifies a single certificate .
public static void expand ( ) { string [ ] st = new string [ l ] ; int i ; for ( i = _num ; i < r ; i ++ ) st [ i ] = _str + ( char ) i ; st [ i ++ ] = _str ; int codeword = binarystdin . readint ( w ) ; if ( codeword == r ) return ; string val = st [ codeword ] ; while ( _bool ) { binarystdout . write ( val ) ; codeword = binarystdin . readint ( w ) ; if ( codeword == r ) break ; string s = st [ codeword ] ; if ( i == codeword ) s = val + val . charat ( _num ) ; if ( i < l ) st [ i ++ ] = val + s . charat ( _num ) ; val = s ; } binarystdout . close ( ) ; }	reads a sequence of bit encoded using lzw compression with 12 - bit codewords from standard input ; expands them ; and writes the results to standard output .
audiocapabilities ( int [ ] supportedencodings , int maxchannelcount ) { if ( supportedencodings != null ) { this . supportedencodings = arrays . copyof ( supportedencodings , supportedencodings . length ) ; arrays . sort ( this . supportedencodings ) ; } else { this . supportedencodings = new int [ _num ] ; } this . maxchannelcount = maxchannelcount ; }	constructs new audio capabilities based on a set of supported encodings and a maximum channel count .
@ override public boolean isrotateedgelabels ( ) { return graphcreator . isrotatingedgelabels ( ) ; }	let the graph model decide .
public static responsecode createextension ( string name ) { stringbuffer buffer = new stringbuffer ( name . length ( ) + _num ) ; if ( ! name . startswith ( _str ) ) { buffer . append ( _str ) ; } buffer . append ( name ) ; return new responsecode ( buffer . tostring ( ) ) ; }	creates an extension response code . names that do not begin with ' x ' will have ' x ' prepended.
@ override public double [ ] makeinversecumulativetestvalues ( ) { double [ ] points = makecumulativetestpoints ( ) ; double [ ] points2 = new double [ points . length - _num ] ; system . arraycopy ( points , _num , points2 , _num , points2 . length ) ; return points2 ; }	creates the default inverse cumulative probability density test expected values .
public java . lang . stringbuilder append ( boolean b ) { if ( b ) { return append ( _str ) ; } return append ( _str ) ; }	appends the string representation of the boolean argument to the string buffer.
public void deleteservers ( set servers ) throws amconsoleexception { if ( servers . contains ( systemproperties . getserverinstancename ( ) ) ) { throw new amconsoleexception ( getlocalizedstring ( _str ) ) ; } string servername = null ; try { if ( ( servers != null ) && ! servers . isempty ( ) ) { ssotoken token = getuserssotoken ( ) ; for ( iterator i = servers . iterator ( ) ; i . hasnext ( ) ; ) { servername = ( string ) i . next ( ) ; string [ ] param = { servername } ; logevent ( _str , param ) ; serverconfiguration . deleteserverinstance ( token , servername ) ; logevent ( _str , param ) ; } } } catch ( smsexception e ) { string [ ] params = { servername , e . getmessage ( ) } ; logevent ( _str , params ) ; throw new amconsoleexception ( geterrorstring ( e ) ) ; } catch ( ssoexception e ) { string [ ] params = { servername , e . getmessage ( ) } ; logevent ( _str , params ) ; throw new amconsoleexception ( geterrorstring ( e ) ) ; } }	deletes a set of servers .
static void sort ( float [ ] a , int left , int right , float [ ] work , int workbase , int worklen ) { while ( left <= right && float . isnan ( a [ right ] ) ) { -- right ; } for ( int k = right ; -- k >= left ; ) { float ak = a [ k ] ; if ( ak != ak ) { a [ k ] = a [ right ] ; a [ right ] = ak ; -- right ; } } dosort ( a , left , right , work , workbase , worklen ) ; int hi = right ; while ( left < hi ) { int middle = ( left + hi ) > > > _num ; float middlevalue = a [ middle ] ; if ( middlevalue < _num ) { left = middle + _num ; } else { hi = middle ; } } while ( left <= right && float . floattorawintbits ( a [ left ] ) < _num ) { ++ left ; } for ( int k = left , p = left - _num ; ++ k <= right ; ) { float ak = a [ k ] ; if ( ak != _num ) { break ; } if ( float . floattorawintbits ( ak ) < _num ) { a [ k ] = _num ; a [ ++ p ] = - _num ; } } }	sorts the specified range of the array using the given workspace array slice if possible for merging.
public void fatalerror ( org . xml . sax . saxparseexception e ) throws org . xml . sax . saxexception { string formattedmsg = e . getmessage ( ) ; saxsourcelocator locator = getlocator ( ) ; errorlistener handler = m_stylesheetprocessor . geterrorlistener ( ) ; try { handler . fatalerror ( new transformerexception ( formattedmsg , locator ) ) ; } catch ( transformerexception te ) { throw new org . xml . sax . saxexception ( te ) ; } }	report a fatal xslt processing error .
public boolean add ( terminal sym ) throws internal_error { boolean result ; not_null ( sym ) ; result = _elements . get ( sym . index ( ) ) ; if ( ! result ) _elements . set ( sym . index ( ) ) ; return result ; }	add a single terminal to the set .
private void createrecursivly ( string path ) throws keeperexception , interruptedexception { try { if ( zk . exists ( path , _bool ) == null && path . length ( ) > _num ) { string temp = path . substring ( _num , path . lastindexof ( file . separator ) ) ; createrecursivly ( temp ) ; zk . create ( path , null , ids . open_acl_unsafe , createmode . persistent ) ; } else { return ; } } catch ( keeperexception e ) { throw e ; } catch ( interruptedexception e ) { throw e ; } }	create zookeepr node if not exist.
public void stoprecording ( ) { mhandler . sendmessage ( mhandler . obtainmessage ( msg_stop_recording ) ) ; mhandler . sendmessage ( mhandler . obtainmessage ( msg_quit ) ) ; }	tells the video recorder to stop recording.
private void writetag ( string name , tag tag ) throws ioexception { tagtype type = tag . gettype ( ) ; byte [ ] namebytes = name . getbytes ( standardcharsets . utf_8 ) ; if ( type == tagtype . end ) { throw new ioexception ( _str ) ; } os . writebyte ( type . getid ( ) ) ; os . writeshort ( namebytes . length ) ; os . write ( namebytes ) ; writetagpayload ( tag ) ; }	write a tag with a name .
public int hashcode ( ) { if ( myhash == - _num ) { if ( timestamp == null ) { myhash = signercertpath . hashcode ( ) ; } else { myhash = signercertpath . hashcode ( ) + timestamp . hashcode ( ) ; } } return myhash ; }	returns the hash code value for this code signer.
public typevariablebv typevariable ( ) { int id = typevariablelist . size ( ) ; typevariablelist . add ( null ) ; typevariablebv result = new typevariablebv ( id , this ) ; typevariablelist . set ( id , result ) ; return result ; }	get new type variable.
public static void downto ( number self , number to , @ closureparams ( firstparam . class ) closure closure ) { int self1 = self . intvalue ( ) ; int to1 = to . intvalue ( ) ; if ( self1 >= to1 ) { for ( int i = self1 ; i >= to1 ; i -- ) { closure . call ( i ) ; } } else throw new groovyruntimeexception ( _str + to + _str + self + _str ) ; }	iterates from this number down to the given number , inclusive , decrementing by one each time .
public void add ( selectclauseelementraw element ) { selectclauseelements . add ( element ) ; }	adds an select expression within the select clause .
public synchronized void removepvchangelistener ( pvchangelistener l ) { log . debug ( _str + string . valueof ( this ) + _str + string . valueof ( l ) ) ; pvchangelisteners . remove ( l ) ; }	remove listener for pv changes.
public static boolean isnormal ( geotimeserie gts , int buckets , double pcterror , boolean bessel ) { if ( _num == gts . values ) { return _bool ; } if ( type . double != gts . type && type . long != gts . type ) { return _bool ; } double [ ] musigma = musigma ( gts , bessel ) ; double mu = musigma [ _num ] ; double sigma = musigma [ _num ] ; if ( _num == sigma ) { return _bool ; } double [ ] bounds = saxutils . getbounds ( buckets ) ; int [ ] counts = new int [ bounds . length + _num ] ; for ( int i = _num ; i < gts . values ; i ++ ) { double v = ( ( double ) gtshelper . valueatindex ( gts , i ) - mu ) / sigma ; int insertion = arrays . binarysearch ( bounds , v ) ; if ( insertion >= _num ) { counts [ insertion ] ++ ; } else { counts [ - ( _num + insertion ) ] ++ ; } } double mean = gts . values / counts . length ; for ( int i = _num ; i < counts . length ; i ++ ) { if ( math . abs ( _num - ( counts [ i ] / mean ) ) > pcterror ) { return _bool ; } } return _bool ; }	determine if a gts ' values are normally distributed . works for numerical gts only.
public showprogress ( ) { start = last = system . currenttimemillis ( ) ; }	create a new instance of this class , and start the timer .
public static repositoryexpression parserepositoryexpression ( string toparse ) throws parseerror { streamtokenizer t = parser . tokenize ( toparse ) ; term creator = parser . parseterm ( t ) ; list < operation > operations = parser . parseoperationlist ( t ) ; repositoryexpression ex = new repositoryexpression ( creator ) ; if ( ! operations . isempty ( ) ) { throw new parseerror ( _str ) ; } return ex ; }	parse a string under the expectation that it is a repositoryexpression , i.
@ override public synchronized void close ( ) throws ioexception { buffer = null ; notifyall ( ) ; }	closes this stream . this implementation releases the buffer used for the pipe and notifies all threads waiting to read or write .
public void addsection ( sourcesection section ) { sections . add ( section ) ; }	add a section to the document .
public static genomerelationships load ( bufferedreader reader ) throws ioexception { final genomerelationships ped = new genomerelationships ( ) ; string line ; while ( ( line = reader . readline ( ) ) != null ) { line = line . trim ( ) ; if ( line . startswith ( _str ) || line . matches ( _str ) ) { continue ; } if ( line . matches ( _str ) ) { parsegenomeline ( ped , line ) ; continue ; } if ( line . matches ( _str ) ) { parserelationshipline ( ped , line ) ; continue ; } throw new notalkbackslimexception ( _str + line + _str ) ; } return ped ; }	load a genome relationships file.
private int [ ] versionparts ( string version ) { string [ ] parts = version . split ( _str ) ; int [ ] p = new int [ _num ] ; for ( int i = _num ; i < _num ; i ++ ) { int pi ; if ( i < parts . length ) { p [ i ] = integer . parseint ( parts [ i ] ) ; } else { p [ i ] = - _num ; } } return p ; }	return the version parts.
private fgsrunner . type computetype ( ) { object model = getdatamodel ( ) ; if ( model == null && getsourcegraph ( ) != null ) { model = getsourcegraph ( ) ; } if ( model == null ) { throw new runtimeexception ( _str + _str + _str + _str ) ; } if ( model instanceof graph ) { type = fgsrunner . type . graph ; } else if ( model instanceof dataset ) { dataset dataset = ( dataset ) model ; if ( dataset . iscontinuous ( ) ) { type = fgsrunner . type . continuous ; } else if ( dataset . isdiscrete ( ) ) { type = fgsrunner . type . discrete ; } else { throw new illegalstateexception ( _str ) ; } } else if ( model instanceof icovariancematrix ) { type = fgsrunner . type . continuous ; } else if ( model instanceof datamodellist ) { datamodellist list = ( datamodellist ) model ; if ( allcontinuous ( list ) ) { type = fgsrunner . type . continuous ; } else if ( alldiscrete ( list ) ) { type = fgsrunner . type . discrete ; } else { throw new illegalargumentexception ( _str ) ; } } return type ; }	executes the algorithm , producing ( at least ) a result workbench.
public static boolean approxequals ( final double a , final double b , final double tolerance ) { if ( double . isnan ( a ) || double . isnan ( b ) ) { return _bool ; } if ( a == b ) { return _bool ; } if ( double . isinfinite ( a ) || double . isinfinite ( b ) ) { return _bool ; } if ( a >= ( b - tolerance ) && a <= ( b + tolerance ) ) { return _bool ; } return _bool ; }	check if two doubles are equal to within specified tolerance .
public static map < string , object > loadjsonmodel ( file jsfile ) { try { map < string , object > model = javascriptresolver . readjsonmodel ( jsfile ) ; if ( model == null ) { throw new compilererrorexception ( _str + jsfile . getabsolutepath ( ) ) ; } if ( ! model . containskey ( _str ) ) { throw new ceylonrunjsexception ( _str + jsfile + _str ) ; } return model ; } catch ( ioexception ex ) { throw new compilererrorexception ( _str + jsfile ) ; } }	read the metamodel declaration from a js file , check it ' s the right version and return the model as a map .
static string [ ] splitline ( final string line ) { final int ix0 = line . indexof ( _str ) ; final int ix = ix0 == - _num ? line . length ( ) : ix0 ; final string lesscomment = line . substring ( _num , ix ) ; if ( lesscomment . matches ( _str ) ) { return null ; } return lesscomment . split ( _str ) ; }	check for comments , trim white space.
private list < volume > createvolumedata ( string name , int numvolumes ) { list < volume > volumes = new arraylist < volume > ( ) ; uri cguri = createblockconsistencygroup ( name + _str ) ; for ( int i = _num ; i <= numvolumes ; i ++ ) { volume volume = new volume ( ) ; uri volumeuri = uriutil . createid ( volume . class ) ; testvolumeuris . add ( volumeuri ) ; volume . setid ( volumeuri ) ; volume . setlabel ( name + i ) ; volume . setconsistencygroup ( cguri ) ; _dbclient . createobject ( volume ) ; } return volumes ; }	creates the blockobject volume data .
private static < t > t hashmaptoobject ( linkedhashmap map , class < t > type ) { try { return stringtoobject ( mapper . writevalueasstring ( map ) , type ) ; } catch ( ioexception e ) { log . warn ( _str + type . getname ( ) + _str + map . tostring ( ) + _str + e . getmessage ( ) ) ; return null ; } }	takes a hashmap and creates an object.
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return success ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
private static blocksremoveinfo isstartblock ( blocknode remblock , blocknode startblock ) { list < insnnode > reminsns = remblock . getinstructions ( ) ; list < insnnode > startinsns = startblock . getinstructions ( ) ; if ( reminsns . size ( ) < startinsns . size ( ) ) { return null ; } int startpos = reminsns . size ( ) - startinsns . size ( ) ; int endpos = _num ; if ( ! checkinsns ( reminsns , startinsns , startpos , null ) ) { if ( checkinsns ( reminsns , startinsns , _num , null ) ) { startpos = _num ; endpos = startinsns . size ( ) ; } else { boolean found = _bool ; for ( int i = _num ; i < startpos ; i ++ ) { if ( checkinsns ( reminsns , startinsns , i , null ) ) { startpos = i ; endpos = startinsns . size ( ) + i ; found = _bool ; break ; } } if ( ! found ) { return null ; } } } blockspair startpair = new blockspair ( remblock , startblock ) ; blocksremoveinfo removeinfo = new blocksremoveinfo ( startpair ) ; removeinfo . setstartsplitindex ( startpos ) ; removeinfo . setendsplitindex ( endpos ) ; if ( endpos != _num ) { removeinfo . setend ( startpair ) ; } if ( ! checkinsns ( reminsns , startinsns , startpos , removeinfo ) ) { return null ; } return removeinfo ; }	' finally ' instructions can start in the middle of the first block .
public boolean checkerror ( ) { return pw . checkerror ( ) ; }	checks to see if the there has been an error in the printstream .
public list < pdfdocument > splitbysize ( long size ) { list < pagerange > splitranges = new arraylist < > ( ) ; int currentpage = _num ; int numofpages = pdfdocument . getnumberofpages ( ) ; while ( currentpage <= numofpages ) { pagerange nextrange = getnextrange ( currentpage , numofpages , size ) ; splitranges . add ( nextrange ) ; list < integer > allpages = nextrange . getallpages ( ) ; currentpage = ( int ) allpages . get ( allpages . size ( ) - _num ) + _num ; } return extractpageranges ( splitranges ) ; }	splits the document basing on the given size .
private boolean validateauthschemes ( set authschemeset ) throws policyexception { if ( authschemeset . isempty ( ) ) { string args [ ] = { auth_scheme } ; throw new policyexception ( resbundleutils . rbname , _str , args , null ) ; } iterator authschemesetiter = authschemeset . iterator ( ) ; authschemes . clear ( ) ; while ( authschemesetiter . hasnext ( ) ) { try { string authscheme = ( string ) authschemesetiter . next ( ) ; authschemes . add ( authscheme ) ; } catch ( classcastexception e ) { string args [ ] = { auth_scheme } ; throw new policyexception ( resbundleutils . rbname , _str , args , null ) ; } } return _bool ; }	validates the module instance names provided to the setproperties ( ) call for the auth_scheme key.
public static uuid fromuuidasurnstringtouuid ( string uuidasurn ) { if ( ! uuidasurn . startswith ( uuidhelper . uuid_as_a_urn_prefix ) ) { imferrorlogger imferrorlogger = new imferrorloggerimpl ( ) ; imferrorlogger . adderror ( imferrorlogger . imferrors . errorcodes . uuid_error , imferrorlogger . imferrors . errorlevels . fatal , string . format ( _str + _str , uuidasurn , uuidhelper . uuid_as_a_urn_prefix ) ) ; throw new imfexception ( string . format ( _str , uuidasurn , uuidhelper . uuid_as_a_urn_prefix ) , imferrorlogger ) ; } return uuid . fromstring ( uuidasurn . split ( uuidhelper . uuid_as_a_urn_prefix ) [ _num ] ) ; }	a helper method to return the uuid without the " urn : uuid : " prefix.
public string readline ( ) { string line ; try { line = scanner . nextline ( ) ; } catch ( nosuchelementexception e ) { line = null ; } return line ; }	reads and returns the next line in this input stream .
public static byte [ ] decode ( final string s ) { return base64 . decode ( s , base64 . no_options ) ; }	decodes data from base64 notation , automatically detecting gzip - compressed data and decompressing it .
public static gradientpaint makeredpaint ( final double width , final double height ) { return new gradientpaint ( _num , _num , new color ( _num , _num , _num ) , ( float ) width / _num , ( float ) height / _num , new color ( _num , _num , _num ) , _bool ) ; }	creates a red gradient paint .
public static list < string > matchnumbers ( string text ) { string pattern = _str ; pattern pat = pattern . compile ( pattern ) ; matcher m = pat . matcher ( text ) ; list < string > matches = new arraylist < string > ( ) ; while ( m . find ( ) ) { matches . add ( m . group ( ) ) ; } return matches ; }	returns a list of all numbers found in a given string .
@ override public uuid createentrynode ( uuid parentnode ) { uuid uuid = uuid . randomuuid ( ) ; graphserver . addvertex ( uuid ) ; graphserver . addedge ( uuid , parentnode ) ; return uuid ; }	creates a node that accepts input into the routing network can only connect to one other node.
protected void assertdeliverystates ( final collection < customerorderdelivery > deliveries , final map < string , string > expectedstate ) { for ( customerorderdelivery delivery : deliveries ) { assertequals ( _str + delivery . getdeliverygroup ( ) + _str + delivery . getdeliverynum ( ) , expectedstate . get ( delivery . getdeliverygroup ( ) ) , delivery . getdeliverystatus ( ) ) ; } }	assert delivery state by delivery group .
@ nullable private compilescope createfacetscompilescope ( @ notnull final compilermanager compilermanager , @ notnull final virtualfile [ ] files ) { final set < module > modules = new . set ( ) ; boolean facetsfound = _bool ; for ( final virtualfile file : files ) { final module module = moduleutilcore . findmoduleforfile ( file , project ) ; if ( module != null ) { modules . add ( module ) ; if ( ! facetsfound ) { facetsfound = hasfacets ( module ) ; } } } if ( facetsfound ) { return compilermanager . createmodulescompilescope ( modules . toarray ( module . empty_array ) , _bool , _bool ) ; } return null ; }	it seems that createfilescompilescope does not work in all environments , at least with android , see https : / / intellij - support.
@ nullable @ workerthread static file writebitmaptofile ( @ nonnull bitmap bitmap , @ nonnull file file ) { fileoutputstream filestream = null ; try { bytearrayoutputstream bytestream = new bytearrayoutputstream ( ) ; bitmap . compress ( bitmap . compressformat . png , _num , bytestream ) ; filestream = new fileoutputstream ( file ) ; filestream . write ( bytestream . tobytearray ( ) ) ; return file ; } catch ( ioexception e ) { log . e ( tag , e . getmessage ( ) , e ) ; } finally { if ( filestream != null ) { try { filestream . close ( ) ; } catch ( ioexception e ) { log . e ( tag , e . getmessage ( ) , e ) ; } } } return null ; }	writes the bitmap to disk and returns the new file .
public static sentence parse ( final string text , final conversationcontext ctx ) { string txt ; if ( text == null ) { txt = _str ; } else { if ( ( ctx != null ) && ctx . isformatching ( ) ) { final expressionmatcher matcher = new expressionmatcher ( ) ; txt = matcher . readmatchingflags ( text ) ; if ( matcher . isanyflagset ( ) ) { return matcher . parsesentence ( txt , ctx ) ; } } else { txt = text ; } } txt = txt . trim ( ) ; final sentenceimplementation sentence = new sentenceimplementation ( ctx , txt ) ; try { final conversationparser parser = new conversationparser ( sentence ) ; sentence . parse ( parser ) ; sentence . classifywords ( parser ) ; if ( ( ctx != null ) && ctx . getmergeexpressions ( ) ) { sentence . evaluatesentencetype ( ) ; sentence . mergewords ( ) ; if ( ! ctx . isformatching ( ) ) { sentence . standardizesentencetype ( ) ; sentence . performaaliasing ( ) ; } } sentence . seterror ( parser . geterrorstring ( ) ) ; } catch ( final exception e ) { logger . error ( _str + text + _str ) ; sentence . seterror ( e . getmessage ( ) ) ; e . printstacktrace ( ) ; } return sentence ; }	parse the given text sentence .
public elemtemplateelement replacechild ( elemtemplateelement newchildelem , elemtemplateelement oldchildelem ) { if ( oldchildelem == null || oldchildelem . getparentelem ( ) != this ) return null ; elemtemplateelement prev = oldchildelem . getprevioussiblingelem ( ) ; if ( null != prev ) prev . m_nextsibling = newchildelem ; if ( m_firstchild == oldchildelem ) m_firstchild = newchildelem ; newchildelem . m_parentnode = this ; oldchildelem . m_parentnode = null ; newchildelem . m_nextsibling = oldchildelem . m_nextsibling ; oldchildelem . m_nextsibling = null ; return newchildelem ; }	replace the old child with a new child .
protected int hash ( object key1 , object key2 , object key3 ) { int h = _num ; if ( key1 != null ) { h ^= key1 . hashcode ( ) ; } if ( key2 != null ) { h ^= key2 . hashcode ( ) ; } if ( key3 != null ) { h ^= key3 . hashcode ( ) ; } h += ~ ( h << _num ) ; h ^= ( h > > > _num ) ; h += ( h << _num ) ; h ^= ( h > > > _num ) ; return h ; }	gets the hash code for the specified multi - key .
public void flush ( ) throws ioexception { flushbuffer ( ) ; _outputstream . flush ( ) ; }	flushes the stream . if the stream has saved any characters from the various write ( ) methods in a buffer , write them immediately to their intended destination . then , if that destination is another character or byte stream , flush it . thus one flush ( ) invocation will flush all the buffers in a chain of writers and outputstreams .
private void addentrytoinfolist ( entry entry , list < entryinfo > entryinfolist ) { if ( entryinfolist != null ) { string typetoadd = entry . gettype ( ) ; if ( typetoadd . equals ( dblogic . constants . quotation ) ) { typetoadd = dblogic . constants . note ; } entryinfolist . add ( new entryinfo ( entry . getid ( ) , entry . getnoteortitle ( _str ) , entry . getquotation ( _str ) , entry . getispublic ( ) , entry . hasfirstchildid ( ) , entry . hasparentid ( ) , typetoadd ) ) ; } }	adds the entry to the entry list .
private void updatesliding ( float newpositionnormalized ) { currentslide = newpositionnormalized ; state = currentslide == _num ? expanded : currentslide == _num ? collapsed : sliding ; float slidey = math . abs ( ( currentslide * maxslide ) - maxslide ) ; slidableview . sety ( slidey ) ; invalidate ( ) ; notifylisteners ( currentslide ) ; }	always use this method to update the position of the sliding view .
void flush ( vcfwriter writer ) throws ioexception { if ( mprevrecord != null ) { if ( ! mprevdense ) { writecount ( writer , mprevrecord ) ; } else { mvcffilterstatistics . increment ( stat . density_window_count ) ; } } mprevrecord = null ; mprevdense = _bool ; }	writes any remaining snp lines.
public videostream ( string streamstr ) { string [ ] args = streamstr . split ( _str ) ; map < string , string > argmap = new hashmap < string , string > ( ) ; for ( string arg : args ) { string [ ] argsvalues = arg . split ( _str ) ; if ( argsvalues != null ) { if ( argsvalues . length >= _num ) { argmap . put ( argsvalues [ _num ] , argsvalues [ _num ] ) ; } } } murl = argmap . get ( _str ) ; }	construct a video stream from one of the strings obtained from the " url_encoded_fmt_stream_map " parameter if the video_info.
public boolean equals ( string str ) { if ( str == null ) return _bool ; if ( _length != str . length ( ) ) return _bool ; for ( int i = _length , j = _offset + _length ; -- i >= _num ; ) { if ( _array [ -- j ] != str . charat ( i ) ) return _bool ; } return _bool ; }	compares this character array against the specified string.
protected void flush ( ) { stream . flush ( ) ; }	flushes any buffered output .
private serverstarter startservers ( ) throws exception { serverstarter srvstarter = new serverstarter ( ) ; thread t = new thread ( srvstarter ) ; t . setdaemon ( _bool ) ; t . setname ( _str ) ; t . start ( ) ; srvstarter . waitforserverstart ( ) ; return srvstarter ; }	starts background thread that launches servers.
public pagination evaluate ( final class entityclass ) { paginate paginate = entityclass != null ? ( paginate ) entityclass . getannotation ( paginate . class ) : null ; int defaultlimit = paginate != null ? paginate . defaultlimit ( ) : default_page_limit ; int maxlimit = paginate != null ? paginate . maxlimit ( ) : max_page_limit ; evaluate ( defaultlimit , maxlimit ) ; generatetotals = generatetotals && ( paginate == null || paginate . countable ( ) ) ; return this ; }	evaluates the pagination variables.
public runtimecollector ( algorithm algorithm , int frequency , resultfilewriter writer ) { super ( algorithm , frequency , frequencytype . evaluations ) ; this . writer = writer ; starttime = system . nanotime ( ) ; }	constructs a new wrapper to collect runtime dynamics .
public boolean deregisterserviceprovider ( object provider ) { object oprovider = map . get ( provider . getclass ( ) ) ; if ( provider == oprovider ) { map . remove ( provider . getclass ( ) ) ; poset . remove ( provider ) ; if ( provider instanceof registerableservice ) { registerableservice rs = ( registerableservice ) provider ; rs . onderegistration ( registry , category ) ; } return _bool ; } return _bool ; }	if the provider was not previously registered , do nothing .
public newestfirstcomparator ( date now ) { preconditions . checknotnull ( now ) ; mnow = new date ( now . gettime ( ) + millis_in_day ) ; }	construct a comparator that sorts items by newest first.
protected void update ( comparable x , object y ) { int index = indexof ( x ) ; if ( index < _num ) { throw new seriesexception ( _str + x ) ; } else { comparableobjectitem item = getdataitem ( index ) ; item . setobject ( y ) ; fireserieschanged ( ) ; } }	updates an item in the series .
public void writefield ( string name , float value ) throws java . io . ioexception { writefield ( name , float . tostring ( value ) ) ; }	writes an float field value .
public byte [ ] decodedata ( byte [ ] data , int numerrorcorrectionbytes ) throws reedsolomonexception , datatoolargeexception { if ( data == null || data . length == _num ) { return null ; } if ( data . length > _num ) { throw new datatoolargeexception ( _str ) ; } int [ ] dataints = new int [ data . length ] ; for ( int i = _num ; i < data . length ; i ++ ) { dataints [ i ] = data [ i ] & _num ; } int totalbytes = data . length - numerrorcorrectionbytes ; decoder . decode ( dataints , numerrorcorrectionbytes ) ; bytearrayoutputstream bos = new bytearrayoutputstream ( ) ; for ( int i = _num ; i < totalbytes && i < dataints . length ; i ++ ) { bos . write ( dataints [ i ] ) ; } return bos . tobytearray ( ) ; }	repairs and decodes the supplied byte array , removing the error correction codes and returning the original data.
public shape createscrollbuttonapart ( int x , int y , int w , int h ) { path . reset ( ) ; path . moveto ( x , y ) ; path . lineto ( x , y + h ) ; path . lineto ( x + w , y + h ) ; addscrollgappath ( x , y , w , h , _bool ) ; path . closepath ( ) ; return path ; }	return a path for a scroll bar button.
void removeallviewsfromadapter ( viewpager pager ) { mviews . clear ( ) ; pager . removeallviews ( ) ; misviewpagerinintentionallyinconsistentstate = _bool ; }	remove all the views from the adapter and de - parents them from the viewpager after calling this , it is expected that notifydatasetchanged should be called soon afterwards .
public static boolean isvalidmobile ( @ nonnull string mobile ) { if ( ! textutils . isempty ( mobile ) && mobile . length ( ) == _num ) { if ( mobile . startswith ( _str ) || mobile . startswith ( _str ) || mobile . startswith ( _str ) ) { return _bool ; } } return _bool ; }	method to check valid malaysia mobile number.
public string converterror ( string filename , int line , int column , string message ) { string srcfilename = null ; int destline = _num ; int srcline = _num ; for ( int i = _num ; i < _lines . size ( ) ; i ++ ) { line map = _lines . get ( i ) ; if ( filename != null && ! filename . endswith ( _dstfilename ) ) { } else if ( map . _dstline <= line && line <= map . getlastdestinationline ( ) ) { srcfilename = map . _srcfilename ; srcline = map . getsourceline ( line ) ; } } if ( srcfilename != null ) return srcfilename + _str + srcline + _str + message ; else return filename + _str + line + _str + message ; }	converts an error in the generated file to a compileerror based on the source .
public static number sinh ( number a ) { return math . sinh ( a . doublevalue ( ) ) ; }	returns the hyperbolic sine of the number .
public void addnotification ( @ notnull notification notification ) { notificationitem item = new notificationitem ( resources , notification , delegate , panel ) ; notificationwidget . add ( notification ) ; }	show notification in container .
protected boolean isattributesmodified ( ) { if ( attributes != null ) { return ( attributes . isempty ( ) ) ? _bool : _bool ; } return _bool ; }	have the attributes of this service schema been modified.
@ nullable public static ignoredescriptor formethod ( class cls , method mthd ) { if ( mthd . isannotationpresent ( igniteignore . class ) ) { igniteignore ignore = mthd . getannotation ( igniteignore . class ) ; string reason = ignore . value ( ) ; if ( f . isempty ( reason ) ) throw new illegalargumentexception ( _str + cls . getname ( ) + _str + mthd . getname ( ) + _str ) ; return new ignoredescriptor ( reason , ignore . forcefailure ( ) ) ; } else return null ; }	get descriptor for method ( if any ) .
public static modifiabledbids randomsample ( dbids source , int k , random random ) { if ( k < _num || k > source . size ( ) ) { throw new illegalargumentexception ( _str + k + _str + source . size ( ) + _str ) ; } if ( random == null ) { random = new fastnonthreadsaferandom ( ) ; } if ( k < source . size ( ) > > _num ) { arraydbids aids = dbidutil . ensurearray ( source ) ; dbidarrayiter iter = aids . iter ( ) ; hashsetmodifiabledbids sample = dbidutil . newhashset ( k ) ; while ( sample . size ( ) < k ) { iter . seek ( random . nextint ( aids . size ( ) ) ) ; sample . add ( iter ) ; } return sample ; } else { arraymodifiabledbids sample = dbidutil . newarray ( source ) ; randomshuffle ( sample , random , k ) ; for ( int i = sample . size ( ) - _num ; i >= k ; i -- ) { sample . remove ( i ) ; } return sample ; } }	produce a random sample of the given dbids .
protected int drawmessagesize ( ) { int sizediff = sizerange [ _num ] == sizerange [ _num ] ? _num : rng . nextint ( sizerange [ _num ] - sizerange [ _num ] ) ; return sizerange [ _num ] + sizediff ; }	generates a ( random ) message size.
public static string [ ] grabargs ( string signature ) { matcher matcher = sigre . matcher ( signature ) ; boolean b = matcher . matches ( ) ; if ( ! b && matcher . groupcount ( ) != _num ) logger . error ( _str , signature ) ; string args = matcher . group ( _num ) ; if ( args . isempty ( ) ) return new string [ _num ] ; return args . split ( _str ) ; }	grab the args string from the method signature.
public void test_enginecreatesslengine_01 ( ) { sslcontextspiimpl ssl = new sslcontextspiimpl ( ) ; try { sslengine sleng = ssl . enginecreatesslengine ( ) ; fail ( _str ) ; } catch ( runtimeexception re ) { string str = re . getmessage ( ) ; if ( ! str . equals ( _str ) ) fail ( _str + str ) ; } catch ( exception e ) { fail ( _str + e + _str ) ; } }	javax . net . ssl . sslcontextspi # enginecreatesslengine ( ) verify exception when sslcontextspi object wasn ' t initialiazed .
public void processdispatch ( uniformpair < eventbean [ ] > events ) { if ( ! forclausedelivery ) { dispatchinternal ( events ) ; return ; } if ( ( groupdeliveryexpressions == null ) || ( groupdeliveryexpressions . length == _num ) ) { uniformpair < eventbean [ ] > todeliver = new uniformpair < eventbean [ ] > ( null , null ) ; if ( events != null ) { if ( events . getfirst ( ) != null ) { for ( eventbean theevent : events . getfirst ( ) ) { todeliver . setfirst ( new eventbean [ ] { theevent } ) ; dispatchinternal ( todeliver ) ; } todeliver . setfirst ( null ) ; } if ( events . getsecond ( ) != null ) { for ( eventbean theevent : events . getsecond ( ) ) { todeliver . setsecond ( new eventbean [ ] { theevent } ) ; dispatchinternal ( todeliver ) ; } todeliver . setsecond ( null ) ; } } return ; } map < object , uniformpair < eventbean [ ] > > groups ; try { groups = getgroupedresults ( events ) ; } catch ( runtimeexception ex ) { log . error ( _str + ex . getmessage ( ) + _str , ex ) ; dispatchinternal ( events ) ; return ; } for ( map . entry < object , uniformpair < eventbean [ ] > > group : groups . entryset ( ) ) { dispatchinternal ( group . getvalue ( ) ) ; } }	indicate an outbound result .
protected void reset ( ) { arrays . fill ( m_iscandidate , _bool ) ; }	reset the candidate parser settings , making each parser equally likely .
protected void redefine ( int nodetype , string namespace , string localname ) { this . nodetype = nodetype ; this . namespace = namespace ; this . localname = localname ; this . hash = nodetype + namespace . hashcode ( ) + localname . hashcode ( ) ; }	redefine this extendedtype object to represent a different extended type.
public void putlong ( long pos , long val ) { unsafe . putlong ( pos + addr , val ) ; }	writes a long to the specified position .
public boolean deletersetstep ( uri rpsystemid , list < uri > volumeids , string token ) throws internalexception { list < string > replicationsetnames = new arraylist < string > ( ) ; try { list < recoverpointvolumeprotectioninfo > volumeprotectioninfolist = new arraylist < recoverpointvolumeprotectioninfo > ( ) ; protectionsystem rpsystem = _dbclient . queryobject ( protectionsystem . class , rpsystemid ) ; recoverpointclient rp = rphelper . getrecoverpointclient ( rpsystem ) ; for ( uri volumeid : volumeids ) { volume volume = _dbclient . queryobject ( volume . class , volumeid ) ; recoverpointvolumeprotectioninfo volumeprotectioninfo = rp . getprotectioninfoforvolume ( rphelper . getrpwwn ( volume . getid ( ) , _dbclient ) ) ; volume sourcevolume = rphelper . getrpsourcevolume ( _dbclient , volume ) ; virtualpool virtualpool = _dbclient . queryobject ( virtualpool . class , sourcevolume . getvirtualpool ( ) ) ; volumeprotectioninfo . setmetropoint ( virtualpool . vpoolspecifiesmetropoint ( virtualpool ) ) ; volumeprotectioninfolist . add ( volumeprotectioninfo ) ; replicationsetnames . add ( volume . getrsetname ( ) ) ; } if ( ! volumeprotectioninfolist . isempty ( ) ) { rp . deletereplicationsets ( volumeprotectioninfolist ) ; } workflowstepcompleter . stepsucceded ( token ) ; } catch ( exception e ) { _log . error ( string . format ( _str , replicationsetnames . tostring ( ) ) ) ; return stepfailed ( token , e , _str ) ; } return _bool ; }	delete the replication set.
private void movetonext ( ) { checkmainthread ( ) ; scheduled . set ( _bool ) ; bitmap next = pending . poll ( ) ; if ( next != null ) { if ( current != null && ! finished . offer ( current ) ) throw new runtimeexception ( _str ) ; current = next ; invalidateself ( ) ; ensurescheduled ( ) ; frameavailablesubject . onnext ( null ) ; fpscounter . update ( ) ; } }	called to move to the next frame.
public final long readlong ( ) throws java . io . ioexception { readfully ( scratch , _num , _num ) ; int h = ( ( scratch [ _num ] & _num ) << _num ) | ( ( scratch [ _num ] & _num ) << _num ) | ( ( scratch [ _num ] & _num ) << _num ) | ( ( scratch [ _num ] & _num ) << _num ) ; int l = ( ( scratch [ _num ] & _num ) << _num ) | ( ( scratch [ _num ] & _num ) << _num ) | ( ( scratch [ _num ] & _num ) << _num ) | ( ( scratch [ _num ] & _num ) << _num ) ; return ( ( ( long ) h ) << _num ) | ( ( long ) l ) & _num ; }	see the general contract of the readlong method of datainput.
public void testgetcolumnsmetadata ( ) throws exception { databasemetadata dmd = con . getmetadata ( ) ; resultset rs = dmd . getcolumns ( null , null , _str , null ) ; assertnotnull ( rs ) ; resultsetmetadata rsmd = rs . getmetadata ( ) ; assertnotnull ( rsmd . getcatalogname ( _num ) ) ; assertnotnull ( rsmd . getcolumnclassname ( _num ) ) ; rsmd . getcolumncount ( ) ; asserttrue ( _num != rsmd . getcolumndisplaysize ( _num ) ) ; assertnotnull ( rsmd . getcolumnlabel ( _num ) ) ; assertnotnull ( rsmd . getcolumnname ( _num ) ) ; rsmd . getcolumntype ( _num ) ; assertnotnull ( rsmd . getcolumntypename ( _num ) ) ; rsmd . getprecision ( _num ) ; rsmd . getscale ( _num ) ; assertnotnull ( rsmd . getschemaname ( _num ) ) ; assertnotnull ( rsmd . gettablename ( _num ) ) ; rsmd . isautoincrement ( _num ) ; rsmd . iscasesensitive ( _num ) ; rsmd . iscurrency ( _num ) ; rsmd . isdefinitelywritable ( _num ) ; rsmd . isnullable ( _num ) ; rsmd . isreadonly ( _num ) ; rsmd . issearchable ( _num ) ; rsmd . issigned ( _num ) ; rsmd . iswritable ( _num ) ; rs . close ( ) ; }	test for bug [ 1120168 ] jtds 101 - tds data type 0 invalid .
private log discoverlogimplementation ( string logcategory ) throws logconfigurationexception { if ( isdiagnosticsenabled ( ) ) { logdiagnostic ( _str ) ; } initconfiguration ( ) ; log result = null ; string specifiedlogclassname = finduserspecifiedlogclassname ( ) ; if ( specifiedlogclassname != null ) { if ( isdiagnosticsenabled ( ) ) { logdiagnostic ( _str + specifiedlogclassname + _str ) ; } result = createlogfromclass ( specifiedlogclassname , logcategory , _bool ) ; if ( result == null ) { stringbuffer messagebuffer = new stringbuffer ( _str ) ; messagebuffer . append ( specifiedlogclassname ) ; messagebuffer . append ( _str ) ; if ( specifiedlogclassname != null ) { informuponsimilarname ( messagebuffer , specifiedlogclassname , logging_impl_log4j_logger ) ; informuponsimilarname ( messagebuffer , specifiedlogclassname , logging_impl_jdk14_logger ) ; informuponsimilarname ( messagebuffer , specifiedlogclassname , logging_impl_lumberjack_logger ) ; informuponsimilarname ( messagebuffer , specifiedlogclassname , logging_impl_simple_logger ) ; } throw new logconfigurationexception ( messagebuffer . tostring ( ) ) ; } return result ; } if ( isdiagnosticsenabled ( ) ) { logdiagnostic ( _str + _str ) ; } for ( int i = _num ; ( i < classestodiscover . length ) && ( result == null ) ; ++ i ) { result = createlogfromclass ( classestodiscover [ i ] , logcategory , _bool ) ; } if ( result == null ) { throw new logconfigurationexception ( _str ) ; } return result ; }	attempts to create a log instance for the given category name.
public viaheader createviaheader ( string host , int port , string transport , string branch ) throws parseexception , invalidargumentexception { if ( host == null || transport == null ) throw new nullpointerexception ( _str ) ; via via = new via ( ) ; if ( branch != null ) via . setbranch ( branch ) ; if ( host . indexof ( _str ) >= _num && host . indexof ( _str ) < _num ) { if ( stripaddressscopezones ) { int zonestart = host . indexof ( _str ) ; if ( zonestart != - _num ) host = host . substring ( _num , zonestart ) ; } host = _str + host + _str ; } via . sethost ( host ) ; via . setport ( port ) ; via . settransport ( transport ) ; return via ; }	creates a new viaheader based on the newly supplied uri and branch values .
public string tostring ( ) { return super . tostring ( ) + _str + recordmap . size ( ) + _str + firstoffset + _str + releasebuffer + _str + prefixwrites + _str + usechecksum + _str + byteswritten ( ) + _str + remaining ( ) + _str + m_removed + _str ; }	adds some debugging information .
private object [ ] resolveparameters ( executable executable , optional < object > target , object outerinstance , extensioncontext extensioncontext , extensionregistry extensionregistry ) { preconditions . notnull ( target , _str ) ; parameter [ ] parameters = executable . getparameters ( ) ; object [ ] values = new object [ parameters . length ] ; int start = _num ; if ( outerinstance != null ) { values [ _num ] = outerinstance ; start = _num ; } for ( int i = start ; i < parameters . length ; i ++ ) { parametercontext parametercontext = new defaultparametercontext ( parameters [ i ] , i , target ) ; values [ i ] = resolveparameter ( parametercontext , executable , extensioncontext , extensionregistry ) ; } return values ; }	resolve the array of parameters for the supplied executable , target , and outer instance .
public static boolean isvalidnamechar ( char c ) { return isvalidnamestartchar ( c ) || ( c >= _str && c <= _str ) ; }	check whether the given char can be one of a name.
protected static boolean id_start_char ( int ch ) { return ( ch >= _str && ch <= _str ) || ( ch >= _str && ch <= _str ) || ( ch == _str ) ; }	determine if a character is ok to start an id .
public int hashcode ( ) { int fhash = ( family != null ) ? family . hashcode ( ) : _num ; return fhash ^ style ^ size ; }	returns a hashcode for this font .
private commandhandlerenum ( final command command1 ) { this . command = command1 ; }	enum contructor to set command .
public static boolean isfloat ( string desc ) { return desc . endswith ( _str ) ; }	tells whether a given type is a float.
public void componentresized ( componentevent e ) { jscrollbar bar = getverticalscrollbar ( ) ; int incr = ( int ) ( getsize ( ) . getheight ( ) - ( bar . getunitincrement ( _num ) * _num ) ) ; getverticalscrollbar ( ) . setblockincrement ( incr ) ; }	invoked when the component ' s size changes.
public arg ( string aname , string desc , int expectednumberofarguments , boolean expectdashedarguments ) { name = aname ; description = desc ; numexpectedvalues = expectednumberofarguments ; c = name . charat ( _num ) ; dashedarguments = expectdashedarguments ; }	create an arg with a name and help line description , along with a number of expected arguments to follow this option.
private boolean remove ( object o , object [ ] snapshot , int index ) { final reentrantlock lock = this . lock ; lock . lock ( ) ; try { object [ ] current = getarray ( ) ; int len = current . length ; if ( snapshot != current ) findindex : { int prefix = math . min ( index , len ) ; for ( int i = _num ; i < prefix ; i ++ ) { if ( current [ i ] != snapshot [ i ] && eq ( o , current [ i ] ) ) { index = i ; break findindex ; } } if ( index >= len ) return _bool ; if ( current [ index ] == o ) break findindex ; index = indexof ( o , current , index , len ) ; if ( index < _num ) return _bool ; } object [ ] newelements = new object [ len - _num ] ; system . arraycopy ( current , _num , newelements , _num , index ) ; system . arraycopy ( current , index + _num , newelements , index , len - index - _num ) ; setarray ( newelements ) ; return _bool ; } finally { lock . unlock ( ) ; } }	a version of remove ( object ) using the strong hint that given recent snapshot contains o at the given index .
public void removemodel ( model model ) { models . remove ( model ) ; }	removes the given model from the container .
public void readmap ( int map_number ) { inputstream map_file ; try { map_file = new fileinputstream ( _str + map_number + _str ) ; try { byte [ ] data = new byte [ map_file . available ( ) ] ; map_file . read ( data ) ; map_file . close ( ) ; string load_data = new string ( data , _str ) ; makemap ( load_data ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } catch ( filenotfoundexception e1 ) { e1 . printstacktrace ( ) ; } }	read map information from stage0x . stg.
public static double hoeffdingln ( double trials , double observed , double prob ) { return - _num * math . pow ( trials * prob - observed , _num ) / trials ; }	get hoeffding probability number , in ln space.
@ override public void onnestedprescroll ( view target , int dx , int dy , int [ ] consumed ) { if ( ( ! mpullrefreshenable && ! mpullloadenable ) ) { return ; } if ( math . abs ( dy ) > _num ) { return ; } if ( ! isconfirm ) { if ( dy < _num && ! canchildscrollup ( ) ) { mcurrentaction = pull_refresh ; isconfirm = _bool ; } else if ( dy > _num && ! canchildscrolldown ( ) ) { mcurrentaction = load_more ; isconfirm = _bool ; } } if ( movespinner ( - dy ) ) { consumed [ _num ] += dy ; } }	with child view to processing move events.
public void testlocalinstances_deterministic ( ) { matsimrandom . reset ( ) ; random local1a = matsimrandom . getlocalinstance ( ) ; random local1b = matsimrandom . getlocalinstance ( ) ; matsimrandom . reset ( ) ; random local2a = matsimrandom . getlocalinstance ( ) ; random local2b = matsimrandom . getlocalinstance ( ) ; assertequalrandomnumbergenerators ( local1a , local2a ) ; assertequalrandomnumbergenerators ( local1b , local2b ) ; }	tests that local instances can be recreated ( = are deterministic ) if the same random seed is used to generate them .
public void add ( match match , appliedregion appliedregion ) { add ( match , appliedregion , _bool ) ; }	adds a new applied region to the match without a priority .
public void reset ( ) { techtree . checksubtree ( techtree . getpathforrow ( _num ) , _bool ) ; }	resets the selection the panel by selecting all technologies .
@ suppresswarnings ( _str ) private static < t > void assertthrows ( final consumer < void > consumer , final class < t > exceptionclass , final consumer < t > assertexceptionproperties , final string message ) { final string normalizedmessage = null == message ? _str : string . format ( _str , message ) ; try { consumer . accept ( null ) ; } catch ( final exception ex ) { if ( exceptionclass . isassignablefrom ( ex . getclass ( ) ) ) { assertexceptionproperties . accept ( ( t ) ex ) ; return ; } assert . fail ( string . format ( _str , normalizedmessage , ex . getclass ( ) , ex . getmessage ( ) ) ) ; } assert . fail ( string . format ( _str , normalizedmessage , exceptionclass ) ) ; }	asserts that the execution of consumer throws an exception of the specific class .
public boolean isempty ( ) { return nodes . isempty ( ) && ways . isempty ( ) && relations . isempty ( ) ; }	return true if this storage is empty.
public static void assertbool ( boolean b ) { if ( verbose ) { log ( _str + b + _str ) ; } if ( ! b ) { throw new runtimeexception ( ) ; } }	assertions allow for simpler test code.
public tagkeyvaluemapconverter ( boolean nullifempty , string idkey ) { objects . requirenonnull ( idkey ) ; this . nullifempty = nullifempty ; this . addid = _bool ; this . idkey = idkey ; }	store feature ids using idkey.
private static void postinit ( ) { debugall = dbgtable . containskey ( debugalltoken ) ; }	common inits , regardless of applet or application .
private static void attemptretryonexception ( string logprefix , request < ? > request , volleyerror exception ) throws volleyerror { retrypolicy retrypolicy = request . getretrypolicy ( ) ; int oldtimeout = request . gettimeoutms ( ) ; try { retrypolicy . retry ( exception ) ; } catch ( volleyerror e ) { request . addmarker ( string . format ( _str , logprefix , oldtimeout ) ) ; throw e ; } request . addmarker ( string . format ( _str , logprefix , oldtimeout ) ) ; }	attempts to prepare the request for a retry.
public static list < file > sortinbatch ( file file , comparator < string > cmp ) throws ioexception { return sortinbatch ( file , cmp , defaultmaxtempfiles ) ; }	this will simply load the file by blocks of x rows , then sort them in - memory , and write the result to temporary files that have to be merged later .
public void adddirectoryset ( context context , string path ) { tinydb tinydb = new tinydb ( context ) ; arraylist < string > file = tinydb . getliststring ( _str ) ; file . add ( path ) ; tinydb . putliststring ( _str , file ) ; }	add directory to scan for saves avatars.
private fastconcurrentskiplistmap . node < k , v > hinode ( ) { if ( hi == null ) return m . findlast ( ) ; else if ( hiinclusive ) return m . findnear ( hi , m . lt | m . eq ) ; else return m . findnear ( hi , m . lt ) ; }	returns highest node . this node might not be in range , so most usages need to check bounds.
protected static void addidrepoamsdkplugin ( ssotoken token , string orgname ) throws smsexception , ssoexception { serviceconfigmanager scm = new serviceconfigmanager ( servicemanager . realm_service , token ) ; serviceconfig sc = scm . getorganizationconfig ( orgname , null ) ; map attributes = new hashmap ( ) ; set values = new hashset ( ) ; values . add ( _str ) ; attributes . put ( _str , values ) ; values = new hashset ( ) ; values . add ( dnmapper . realmnametoamsdkname ( dnmapper . orgnametodn ( orgname ) ) ) ; attributes . put ( _str , values ) ; sc . addsubconfig ( _str , _str , _num , attributes ) ; }	adds idrepo amsdk plugin to the given organization name.
public static string onkeypress ( string key ) { pin = pin . concat ( key ) ; return pin ; }	getting the value of key pressed and appending it to current pin.
public boolean ishierachic ( string string ) { int index = string . indexof ( m_seperator ) ; if ( ( index == ( string . length ( ) - _num ) ) || ( index == - _num ) ) { return _bool ; } return _bool ; }	whether the given string has a hierachy structure with the seperators.
public shape paintlayer ( graphics g , int offs0 , int offs1 , shape bounds , jtextcomponent c , view view ) { color base = getcolor ( ) ; color color = base != null ? new color ( base . getred ( ) , base . getgreen ( ) , base . getblue ( ) , _num ) : null ; if ( color == null ) { g . setcolor ( c . getselectioncolor ( ) ) ; } else { g . setcolor ( color ) ; } if ( offs0 == view . getstartoffset ( ) && offs1 == view . getendoffset ( ) ) { rectangle alloc ; if ( bounds instanceof rectangle ) { alloc = ( rectangle ) bounds ; } else { alloc = bounds . getbounds ( ) ; } g . fillrect ( alloc . x , alloc . y , c . getwidth ( ) - alloc . x , alloc . height ) ; } else { try { shape shape = view . modeltoview ( offs0 , position . bias . forward , offs1 , position . bias . backward , bounds ) ; rectangle r = ( shape instanceof rectangle ) ? ( rectangle ) shape : shape . getbounds ( ) ; g . fillrect ( _num , r . y , c . getwidth ( ) , r . height ) ; return r ; } catch ( badlocationexception e ) { } } return null ; }	paints a portion of a highlight .
synchronized void receive ( char onechar ) throws ioexception { if ( buffer == null ) { throw new ioexception ( _str ) ; } if ( lastreader != null && ! lastreader . isalive ( ) ) { throw new ioexception ( _str ) ; } lastwriter = thread . currentthread ( ) ; try { while ( buffer != null && out == in ) { notifyall ( ) ; wait ( _num ) ; if ( lastreader != null && ! lastreader . isalive ( ) ) { throw new ioexception ( _str ) ; } } } catch ( interruptedexception e ) { throw new interruptedioexception ( ) ; } if ( buffer == null ) { throw new ioexception ( _str ) ; } if ( in == - _num ) { in = _num ; } buffer [ in ++ ] = onechar ; if ( in == buffer . length ) { in = _num ; } }	receives a char and stores it into the pipedreader.
public static final bytebuffer buffertobytebuffer ( final byte [ ] buffer , final byteorder order ) { final bytebuffer retbuff = bytebuffer . wrap ( buffer ) ; retbuff . order ( order ) ; return retbuff ; }	converts a buffer to a bytebuffer .
public static void writesinglebyte ( outputstream out , int b ) throws ioexception { byte [ ] buffer = new byte [ _num ] ; buffer [ _num ] = ( byte ) ( b & _num ) ; out . write ( buffer ) ; }	implements outputstream . write ( int ) in terms of outputstream . write ( byte [ ] , int , int ) . outputstream assumes that you implement outputstream . write ( int ) and provides default implementations of the others , but often the opposite is more efficient .
private uri processlocalfiles ( uri uri ) { string uristr = uri . tostring ( ) ; if ( uristr . startswith ( _str ) ) { uristr = _str + system . getproperty ( _str ) + _str + uristr . substring ( _num ) ; url url ; try { url = new url ( uristr ) ; return url . touri ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } return uri ; }	convert local paths into absolute paths for links based on the local file system .
private string generatescreenonoroffutternace ( int feedbackindex ) { int resourceid = ( feedbackindex == index_screen_on ) ? r . string . template_screen_on : r . string . template_screen_off ; string template = mcontext . getstring ( resourceid ) ; int currentringervolume = maudiomanager . getstreamvolume ( audiomanager . stream_ring ) ; int maxringervolume = maudiomanager . getstreammaxvolume ( audiomanager . stream_ring ) ; int volumepercent = ( _num / maxringervolume ) * currentringervolume ; int adjustment = volumepercent % _num ; if ( adjustment < _num ) { volumepercent -= adjustment ; } else if ( adjustment > _num ) { volumepercent += ( _num - adjustment ) ; } return string . format ( template , volumepercent ) ; }	generates an utterance for announcing screen on and screen off .
public void reset ( ) { count = _num ; starttime = system . currenttimemillis ( ) ; }	resets the rate sampling .
public int readint ( ) throws ioexception { length += _num ; int k1 = in . read ( ) ; if ( k1 < _num ) return _num ; int k2 = in . read ( ) << _num ; int k3 = in . read ( ) << _num ; return k1 + k2 + k3 + ( in . read ( ) << _num ) ; }	read the next int from the inputstream .
public enumeration listoptions ( ) { vector newvector = new vector ( _num ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public void testaddissuerljavax_security_auth_x500_x500principal02 ( ) { x509crlselector selector = new x509crlselector ( ) ; x500principal iss1 = new x500principal ( _str ) ; x500principal iss2 = new x500principal ( _str ) ; crl crl1 = new testcrl ( iss1 ) ; crl crl2 = new testcrl ( iss2 ) ; selector . addissuer ( iss1 ) ; asserttrue ( _str , selector . match ( crl1 ) ) ; assertfalse ( _str , selector . match ( crl2 ) ) ; selector . addissuer ( iss2 ) ; asserttrue ( _str , selector . match ( crl2 ) ) ; }	addissuer ( x500principal issuer ) method testing.
public void addtransformation ( tagtransformation tagtransformation ) { if ( tagtransformation != null ) { mappings . put ( tagtransformation . getsourcetag ( ) , tagtransformation ) ; } }	adds specified tag transformation to the collection .
@ override public boolean isfilemodified ( long filetimestamp , long endoffset ) { boolean isfilemodified = _bool ; if ( getlastmodifiedtime ( ) > filetimestamp || getsize ( ) > endoffset ) { isfilemodified = _bool ; } return isfilemodified ; }	this method will be used to check whether a file has been modified or not.
public string nextstring ( ) { nextclean ( _str ) ; stringbuilder sb = new stringbuilder ( ) ; for ( ; ; ) { char c = next ( ) ; switch ( c ) { case _num : case _str : case _str : throw syntaxerror ( _str ) ; case _str : c = next ( ) ; switch ( c ) { case _str : sb . append ( _str ) ; break ; case _str : sb . append ( _str ) ; break ; case _str : sb . append ( _str ) ; break ; case _str : sb . append ( _str ) ; break ; case _str : sb . append ( _str ) ; break ; case _str : sb . append ( ( char ) integer . parseint ( next ( _num ) , _num ) ) ; break ; default : sb . append ( c ) ; } break ; case _str : return sb . tostring ( ) ; default : if ( c < _str ) { throw syntaxerror ( _str + ( ( int ) c ) + _str ) ; } sb . append ( c ) ; break ; } } }	return the characters up to the next close quote character.
private void readlyrics3tag ( file file , randomaccessfile newfile , int loadoptions ) throws ioexception { }	read lyrics3 tag todo : not working.
public double evaluate ( vectorinstance x , vectorinstance y ) throws exception { double dotprod = x . dotproduct ( y ) ; return math . pow ( m_gamma * dotprod + m_coef0 , m_degree ) ; }	compute the result of the kernel evaluation on the supplied vectors.
private boolean isdbconfigurationpresent ( ) { return stringutils . isnotblank ( selectcolumn ) && stringutils . isnotblank ( tablename ) ; }	returns whether the database configuration is present or not ( i.
public boolean isincompletenumericalrun ( string pin ) { final int len = pin . length ( ) ; int consecutive = _num ; char last = pin . charat ( _num ) ; for ( int i = _num ; i < len ; i ++ ) { final char c = pin . charat ( i ) ; if ( last == c ) { consecutive ++ ; } else { consecutive = _num ; } last = c ; if ( consecutive >= _num ) { return _bool ; } } return _bool ; }	tests the string to see if it contains a partial numeric run.
private static void generatejavascriptlogalertclosewindow ( writer writer , string message ) throws ioexception { writer . write ( _str + message + _str ) ; writer . write ( _str ) ; writer . write ( _str ) ; }	metodo que genera un alert con el mensaje de error y ademas cierra la ventana que se intenta abrir.
public tree < string > extractbestmaxruleparse1 ( int start , int end , int state , list < string > sentence ) { int cstate = maxcchild [ start ] [ end ] [ state ] ; if ( cstate == - _num ) { return extractbestmaxruleparse2 ( start , end , state , sentence ) ; } else { list < tree < string > > child = new arraylist < tree < string > > ( ) ; child . add ( extractbestmaxruleparse2 ( start , end , cstate , sentence ) ) ; string statestr = ( string ) tagnumberer . object ( state ) ; if ( statestr . endswith ( _str ) ) statestr = statestr . substring ( _num , statestr . length ( ) - _num ) ; int intermediatenode = grammar . getunaryintermediate ( ( short ) state , ( short ) cstate ) ; if ( intermediatenode == _num ) { } if ( intermediatenode > _num ) { list < tree < string > > restoredchild = new arraylist < tree < string > > ( ) ; string statestr2 = ( string ) tagnumberer . object ( intermediatenode ) ; if ( statestr2 . endswith ( _str ) ) statestr2 = statestr2 . substring ( _num , statestr2 . length ( ) - _num ) ; restoredchild . add ( new tree < string > ( statestr2 , child ) ) ; return new tree < string > ( statestr , restoredchild ) ; } return new tree < string > ( statestr , child ) ; } }	returns the best parse for state " state " , potentially starting with a unary rule.
protected void parsedomattributes ( element element ) throws saml2exception { super . parsedomattributes ( element ) ; }	parses attributes of the docuemnt element for this object .
private static double distance ( double x1 , double y1 , double x2 , double y2 ) { return math . sqrt ( ( y2 - y1 ) * ( y2 - y1 ) + ( x2 - x1 ) * ( x2 - x1 ) ) ; }	calculates the distance between two given points in the plane .
public void start ( int conditions ) throws ioexception { print ( _str , new string [ ] { integer . tobinarystring ( conditions ) } ) ; printer . flush ( ) ; }	description of the method.
public string pad ( string value , int places , string padcharacter ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( value ) ; while ( sb . length ( ) < places ) { sb . append ( padcharacter ) ; } return sb . tostring ( ) ; }	pads spaces onto the end of the value to make it ' places ' long.
private static resultcode registererrorresultcode ( final int intvalue , final localizablemessage name , final enum resultcodeenum ) { final resultcode t = new resultcode ( intvalue , name , _bool , resultcodeenum ) ; elements . put ( intvalue , t ) ; return t ; }	creates and registers a new error result code with the application .
public void addall ( exceptionset other ) { exceptionset . or ( other . exceptionset ) ; explicitset . or ( other . explicitset ) ; size = countbits ( exceptionset ) ; commonsupertype = null ; }	add all exceptions in the given set .
@ hleunimplemented @ hlefunction ( nid = _num , version = _num ) public int sceusbcamstartvideo ( ) { if ( ! setupvideo ( ) ) { log . warn ( string . format ( _str ) ) ; } return _num ; }	starts video input from the camera .
protected resourceloaderlicenselocator ( final charset charset , final string ... licensefiles ) { if ( licensefiles == null || licensefiles . length == _num ) { throw new illegalargumentexception ( _str ) ; } if ( charset == null ) { throw new nullpointerexception ( _str ) ; } this . licensefiles = new arraylist < string > ( arrays . aslist ( licensefiles ) ) ; this . charset = charset ; }	constructs the license locator with the given license file names.
private static boolean isintendedexception ( exception e , class < ? > clazz ) { final string message = e . getmessage ( ) ; return ( ! textutils . isempty ( message ) && message . startswith ( clazz . getname ( ) ) ) ; }	checks if the exception is one of the intended server side exception that has been thrown over the aidl layer .
@ inject public projecttyperegistry ( set < projecttypedef > types ) { projecttypes = new hashmap < > ( ) ; validateddata = new hashmap < > ( ) ; validate ( types ) ; for ( projecttypedef type : validateddata . values ( ) ) { try { init ( type ) ; } catch ( projecttypeconstraintexception e ) { log . error ( e . getmessage ( ) ) ; } } }	initialises set of project type definitions.
static public void addnotificationlistener ( jmxconnector jmxconnector , class < ? > mbeaninterface , string mbeanname , notificationlistener notificationlistener , boolean ignored ) throws instancenotfoundexception , exception { mbeanserverconnection mbsc = jmxconnector . getmbeanserverconnection ( ) ; objectname objectname = generatembeanobjectname ( mbeaninterface . getname ( ) , mbeanname ) ; mbsc . addnotificationlistener ( objectname , notificationlistener , null , null ) ; }	attach notificationlistener that can be used to listen notifications emitted by mbean server .
public void testcase16 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = - _num ; int bsign = - _num ; byte rbytes [ ] = { _num , _num , _num , _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . subtract ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _num , result . signum ( ) ) ; }	subtract two negative numbers of different length.
private void consume ( ) { consumer . subscribe ( topics ) ; while ( running . get ( ) ) { try { consumerrecords records = consumer . poll ( pollintervalms ) ; if ( records == null ) { continue ; } iterator < consumerrecord < string , string > > iterator = records . iterator ( ) ; while ( iterator . hasnext ( ) ) { sendmessage ( iterator . next ( ) ) ; } } catch ( exception ex ) { string error = _str ; logger . error ( error , ex ) ; bus . send ( configconstants . consumer_error_topic , geterrorstring ( error , ex . getmessage ( ) ) ) ; } } }	handles looping and consuming.
private void deleteattrs ( svcreg reg , entryrep entry , boolean checkdups ) { entryclass eclass = entry . eclass ; deleteinstance ( eclass ) ; object [ ] fields = entry . fields ; if ( fields . length == _num ) { arraylist regs = servicebyemptyattr . get ( eclass ) ; if ( regs == null || ( checkdups && hasemptyattr ( reg , eclass ) ) ) return ; int idx = regs . indexof ( reg ) ; if ( idx >= _num ) { regs . remove ( idx ) ; if ( regs . isempty ( ) ) servicebyemptyattr . remove ( eclass ) ; } return ; } for ( int fldidx = fields . length ; -- fldidx >= _num ; ) { eclass = getdefiningclass ( eclass , fldidx ) ; hashmap [ ] attrmaps = servicebyattr . get ( eclass ) ; if ( attrmaps == null || attrmaps [ fldidx ] == null || ( checkdups && hasattr ( reg , eclass , fldidx , fields [ fldidx ] ) ) ) continue ; hashmap map = attrmaps [ fldidx ] ; object value = fields [ fldidx ] ; arraylist regs = ( arraylist ) map . get ( value ) ; if ( regs == null ) continue ; int idx = regs . indexof ( reg ) ; if ( idx < _num ) continue ; regs . remove ( idx ) ; if ( ! regs . isempty ( ) ) continue ; map . remove ( value ) ; if ( ! map . isempty ( ) ) continue ; attrmaps [ fldidx ] = null ; if ( allnull ( attrmaps ) ) servicebyattr . remove ( eclass ) ; } }	if checkdups is false , delete the service ( if present ) from servicebyattr under all attribute values of the given entry or from servicebyemptyattr if the entry has no attributes.
public void testdsaprovider ( ) throws exception { algorithmparameters params = algorithmparameters . getinstance ( _str ) ; assertequals ( _str , _str , params . getalgorithm ( ) ) ; biginteger p = biginteger . one ; biginteger q = biginteger . ten ; biginteger g = biginteger . zero ; params . init ( new dsaparameterspec ( p , q , g ) ) ; byte [ ] enc = params . getencoded ( ) ; assertnotnull ( enc ) ; assertnotnull ( params . getencoded ( _str ) ) ; dsaparameterspec spec = params . getparameterspec ( dsaparameterspec . class ) ; assertequals ( _str , p , spec . getp ( ) ) ; assertequals ( _str , q , spec . getq ( ) ) ; assertequals ( _str , g , spec . getg ( ) ) ; params = algorithmparameters . getinstance ( _str ) ; params . init ( enc ) ; asserttrue ( _str , arrays . equals ( enc , params . getencoded ( ) ) ) ; params = algorithmparameters . getinstance ( _str ) ; params . init ( enc , _str ) ; asserttrue ( _str , arrays . equals ( enc , params . getencoded ( ) ) ) ; params = algorithmparameters . getinstance ( _str ) ; try { params . init ( enc , _str ) ; fail ( _str ) ; } catch ( ioexception e ) { } }	tests dsa algorithmparameters provider.
public static boolean isclassliteralpossible ( classnode classnode ) { return modifier . ispublic ( classnode . getmodifiers ( ) ) ; }	tells if a class node is candidate for class literal bytecode optimization.
private properties loadlogfile ( license license , boolean create ) { properties log = new properties ( ) ; file logfile = getlogfile ( license ) ; try { if ( create && logfile . createnewfile ( ) ) { logger . fine ( _str + logfile . getabsolutepath ( ) ) ; } final inputstream in = new fileinputstream ( logfile ) ; try { log . load ( in ) ; } finally { in . close ( ) ; } } catch ( filenotfoundexception ex ) { if ( create ) { logger . log ( level . severe , _str + logfile . getabsolutepath ( ) , ex ) ; } else { logger . fine ( _str ) ; } } catch ( ioexception ex ) { logger . log ( level . warning , _str + logfile . getabsolutepath ( ) , ex ) ; } return log ; }	loads the log file for the given license and returns it .
public htmlstripcharfilterfactory ( map < string , string > args ) { super ( args ) ; escapedtags = getset ( args , _str ) ; if ( ! args . isempty ( ) ) { throw new illegalargumentexception ( _str + args ) ; } }	creates a new htmlstripcharfilterfactory.
public static int update ( long id , v v ) { string passwd = ( string ) v . value ( _str ) ; if ( ! x . isempty ( passwd ) ) { passwd = encrypt ( passwd ) ; v . set ( _str , passwd , _bool ) ; } else { v . remove ( _str ) ; } return helper . update ( id , v . set ( _str , system . currenttimemillis ( ) ) , user . class ) ; }	update the user by the values , < br > if the values contains " password " field , it will auto encrypt the password field .
public double likelihood ( string [ ] doc , string tag ) { double likelihood = _num ; if ( ntw . rowsum ( tag ) == _num ) { return likelihood ; } counter < string > nwd = new counter < string > ( ) ; for ( string w : doc ) { nwd . inc ( w , _num ) ; } double norm = _num ; map < string , double > prwd = new hashtable < string , double > ( ) ; for ( entry < string , long > e : nwd ) { double prw = prw ( e . getkey ( ) ) ; norm += prw ; prwd . put ( e . getkey ( ) , prw ) ; } for ( entry < string , double > e : prwd . entryset ( ) ) { double prw = e . getvalue ( ) / norm ; likelihood += ptr ( tag , e . getkey ( ) ) * prw * ( _num - pcm ( ) ) ; } likelihood += ptr ( tag , noise ) * pcm ( ) ; return likelihood ; }	the likelihood of a tag in given document .
@ override public string tostring ( ) { stringbuffer text = new stringbuffer ( ) ; text . append ( _str + attributestostring ( ) + _str ) ; text . append ( _str + getinstnums ( ) ) ; return text . tostring ( ) ; }	make a string from the cluster features .
public boolean issafemode ( ) { return this . safemode ; }	check if task will be in safe mode.
public void test_getputbytearraywithoffsetandlength ( ) { final int size = _num ; final idatarecord buf = new fixedbytearraybuffer ( size ) ; assertequals ( ( byte ) _num , buf . getbyte ( _num ) ) ; assertequals ( ( byte ) _num , buf . getbyte ( size - _num ) ) ; final int pos = _num ; for ( int i = _num ; i < limit ; i ++ ) { final byte [ ] expected = new byte [ r . nextint ( size - _num ) ] ; final int off = ( expected . length / _num == _num ? _num : r . nextint ( expected . length / _num ) ) ; final int len = ( expected . length == _num ? _num : r . nextint ( expected . length - off ) ) ; r . nextbytes ( expected ) ; buf . put ( pos , expected , off , len ) ; assertequals ( _num , bytesutil . comparebyteswithlenandoffset ( off , len , expected , pos , len , buf . array ( ) ) ) ; final int dstoff = r . nextint ( _num ) ; final byte [ ] actual = new byte [ expected . length + dstoff ] ; buf . get ( pos , actual , dstoff , expected . length ) ; assertequals ( _num , bytesutil . comparebyteswithlenandoffset ( off , len , expected , dstoff , len , actual ) ) ; } assertequals ( ( byte ) _num , buf . getbyte ( _num ) ) ; assertequals ( ( byte ) _num , buf . getbyte ( pos + size - _num ) ) ; }	test of the bulk get / put byte [ ] methods which accept a slice into the caller ' s array .
public void addlastitem ( m model ) { additem ( mdatas . size ( ) , model ) ; }	insert data to footer.
static boolean haslocalizedmessages ( ) { return guimediator . isenglishlocale ( ) || ! first_message . equals ( i18n . tr ( first_message ) ) ; }	determines whether or not the current locale language is english.
public static dockerimage fromimagename ( string imagename ) { imagename = prepare ( imagename ) ; string [ ] parts = imagename . split ( section_separator ) ; switch ( parts . length ) { case _num : return fromparts ( null , null , parts [ _num ] ) ; case _num : if ( isvalidnamespace ( parts [ _num ] ) ) { return fromparts ( null , parts [ _num ] , parts [ _num ] ) ; } else { return fromparts ( parts [ _num ] , null , parts [ _num ] ) ; } case _num : return fromparts ( parts [ _num ] , parts [ _num ] , parts [ _num ] ) ; default : throw new illegalargumentexception ( _str + imagename ) ; } }	parse a full image name ( myhost : 300 / namespace / repo : tag ) into its components.
public synchronized void listen ( final set < notificationchannel > channelnames ) { m_channels . addall ( channelnames ) ; }	adds the set of channel names to the set of listened channels .
public static void deletedirectory ( file directory ) throws ioexception { if ( ! directory . exists ( ) ) { return ; } if ( ! issymlink ( directory ) ) { cleandirectory ( directory ) ; } if ( ! directory . delete ( ) ) { string message = _str + directory + _str ; throw new ioexception ( message ) ; } }	deletes a directory recursively .
public list < long > deleteemptyfolders ( ) { arraylist < long > folderids = new arraylist < long > ( ) ; sqlitedatabase db = mopenhelper . getwritabledatabase ( ) ; db . begintransaction ( ) ; try { string selection = launchersettings . favorites . item_type + _str + launchersettings . favorites . item_type_folder + _str + launchersettings . favorites . _id + _str + launchersettings . favorites . container + _str + table_favorites + _str ; cursor c = db . query ( table_favorites , new string [ ] { launchersettings . favorites . _id } , selection , null , null , null , null ) ; while ( c . movetonext ( ) ) { folderids . add ( c . getlong ( _num ) ) ; } c . close ( ) ; if ( folderids . size ( ) > _num ) { db . delete ( table_favorites , utilities . createdbselectionquery ( launchersettings . favorites . _id , folderids ) , null ) ; } db . settransactionsuccessful ( ) ; } catch ( sqlexception ex ) { log . e ( tag , ex . getmessage ( ) , ex ) ; folderids . clear ( ) ; } finally { db . endtransaction ( ) ; } return folderids ; }	deletes any empty folder from the db .
@ override default completablefuture < integer > sumint ( final tointfunction < ? super t > fn ) { return completablefuture . supplyasync ( null , getexec ( ) ) ; }	perform an asynchronous sum operation.
public void testwrite3 ( ) throws exception { byte [ ] data = new byte [ ] { - _num , - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num } ; testoutputstream tos = new testoutputstream ( ) ; cipheroutputstream cos = new cipheroutputstream ( tos , new nullcipher ( ) ) ; for ( int i = _num ; i < data . length ; i ++ ) { cos . write ( data , i , _num ) ; } cos . flush ( ) ; byte [ ] result = tos . tobytearray ( ) ; if ( ! arrays . equals ( result , data ) ) { fail ( _str ) ; } }	write ( byte [ ] b , int off , int len ) method testing .
private document parse ( final string data ) { if ( docbuilder == null || data == null ) { return null ; } document document = null ; try { string buf = beginpart + data + endpart ; inputsource inputsource = new inputsource ( new stringreader ( buf ) ) ; document = docbuilder . parse ( inputsource ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } return document ; }	converts the loggingevent data in xml string format into an actual xml document class instance .
public boolean isproductionjournal ( set < string > productioncopies , volume volume ) { for ( string productioncopy : productioncopies ) { if ( productioncopy . equalsignorecase ( volume . getrpcopyname ( ) ) ) { return _bool ; } } return _bool ; }	checks to see if the volume is a production journal.
private void testpoundsymbolincolumnname ( ) throws sqlexception { deletedb ( _str ) ; connection conn = getconnection ( _str ) ; statement stat = conn . createstatement ( ) ; stat . execute ( _str ) ; stat . execute ( _str ) ; assertresult ( _str , stat , _str ) ; conn . close ( ) ; }	test the # in a column name for oracle compatibility.
public static string decode ( final string escaped ) throws uriexception { try { final byte [ ] rawdata = urlcodec . decodeurl ( encodingutil . getasciibytes ( escaped ) ) ; return encodingutil . getstring ( rawdata , uri . getdefaultprotocolcharset ( ) ) ; } catch ( final decoderexception e ) { throw new uriexception ( e . getmessage ( ) ) ; } }	unescape and decode a given string regarded as an escaped string with the default protocol charset .
void waitbeforenextpoll ( int pollinginterval ) throws interruptedexception { synchronized ( this ) { wait ( pollinginterval ) ; } if ( ! polloutstanding ) { return ; } log . debug ( _str ) ; for ( int i = _num ; i < _num ; i ++ ) { synchronized ( this ) { wait ( pollinginterval / _num ) ; } log . debug ( _str ) ; if ( ! polloutstanding ) { return ; } } }	wait before sending next poll.
protected dimension computelengths ( string annotext ) { string [ ] lines = util . splitlines ( annotext ) ; int linelength = _num ; for ( string line : lines ) { if ( line . length ( ) > linelength ) linelength = line . length ( ) ; } return new dimension ( linelength + _num , lines . length + _num ) ; }	determine the number of lines in the annotation text and the length of the longest line .
public static void writeimagemap ( printwriter writer , string name , chartrenderinginfo info , tooltiptagfragmentgenerator tooltiptagfragmentgenerator , urltagfragmentgenerator urltagfragmentgenerator ) throws ioexception { writer . println ( imagemaputilities . getimagemap ( name , info , tooltiptagfragmentgenerator , urltagfragmentgenerator ) ) ; }	writes an image map to the specified writer .
importnotebuilder addmessage ( importnotemessage . type type , string message ) { if ( ! strings . isnullorempty ( message ) ) { messages . add ( new importnotemessage ( type , message ) ) ; } return this ; }	adds a message ( if not null ) to the builder .
public string toxmlstring ( boolean includens , boolean declarens ) throws fsmsgexception { return toxmlstring ( includens , declarens , _bool ) ; }	returns a string representation of the logout response .
public static list < string > asstringlist ( collection < ? extends object > objects ) { list < string > list = new arraylist < > ( ) ; for ( object object : objects ) { list . add ( string . valueof ( object ) ) ; } return list ; }	returns a list of strings , where the strings are the result of calling string.
public < e extends t > e min ( iterable < e > iterable ) { iterator < e > iterator = iterable . iterator ( ) ; e minsofar = iterator . next ( ) ; while ( iterator . hasnext ( ) ) { minsofar = min ( minsofar , iterator . next ( ) ) ; } return minsofar ; }	returns the smallest of the specified values according to this ordering.
public synchronized int read ( byte b [ ] , int off , int len ) throws ioexception { if ( len <= _num ) return _num ; int morespace ; synchronized ( lock ) { if ( pos >= present ) pos = present = _num ; else if ( pos >= watermark ) { system . arraycopy ( buffer , pos , buffer , _num , present - pos ) ; present -= pos ; pos = _num ; } int freespace = buffer . length - present ; morespace = math . max ( freespace - requested , _num ) ; } if ( morespace > _num ) manager . sendrequest ( info , morespace ) ; synchronized ( lock ) { requested += morespace ; while ( ( pos >= present ) && ! disconnected ) { try { lock . wait ( ) ; } catch ( interruptedexception e ) { } } if ( disconnected && pos >= present ) return - _num ; int available = present - pos ; if ( len < available ) { system . arraycopy ( buffer , pos , b , off , len ) ; pos += len ; return len ; } else { system . arraycopy ( buffer , pos , b , off , available ) ; pos = present = _num ; return available ; } } }	read a subarray of bytes from connection.
public final void put ( string key , int value ) { if ( ( m_firstfree + _num ) >= m_mapsize ) { m_mapsize += m_blocksize ; string newmap [ ] = new string [ m_mapsize ] ; system . arraycopy ( m_map , _num , newmap , _num , m_firstfree + _num ) ; m_map = newmap ; int newvalues [ ] = new int [ m_mapsize ] ; system . arraycopy ( m_values , _num , newvalues , _num , m_firstfree + _num ) ; m_values = newvalues ; } m_map [ m_firstfree ] = key ; m_values [ m_firstfree ] = value ; m_firstfree ++ ; }	append a string onto the vector .
public static list < itemstack > consolidateitemstacks ( list < itemstack > inputstacks ) { list < itemstack > outputstacks = new arraylist < itemstack > ( ) ; for ( itemstack sourceis : inputstacks ) { boolean bfound = _bool ; for ( itemstack destis : outputstacks ) { if ( destis != null && sourceis != null && itemstackingredientsmatch ( destis , sourceis ) ) { bfound = _bool ; destis . stacksize += sourceis . stacksize ; } } if ( ! bfound ) outputstacks . add ( sourceis . copy ( ) ) ; } return outputstacks ; }	take a list of itemstacks and amalgamate where possible . < br >.
public static int howmanydaysold ( long time ) { return ( int ) ( ( system . currenttimemillis ( ) - time ) / dateutils . day_in_millis ) ; }	determines how many days ago time was ( rounded down ) .
protected character iswfxmlchar ( string chardata ) { character refinvalidchar ; if ( chardata == null || ( chardata . length ( ) == _num ) ) { return null ; } char [ ] dataarray = chardata . tochararray ( ) ; int datalength = dataarray . length ; if ( fisxmlversion11 ) { int i = _num ; while ( i < datalength ) { if ( xml11char . isxml11invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - _num ] ; if ( xmlchar . ishighsurrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if ( xmlchar . islowsurrogate ( ch2 ) && xmlchar . issupplemental ( xmlchar . supplemental ( ch , ch2 ) ) ) { continue ; } } refinvalidchar = new character ( ch ) ; return refinvalidchar ; } } } else { int i = _num ; while ( i < datalength ) { if ( xmlchar . isinvalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - _num ] ; if ( xmlchar . ishighsurrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if ( xmlchar . islowsurrogate ( ch2 ) && xmlchar . issupplemental ( xmlchar . supplemental ( ch , ch2 ) ) ) { continue ; } } refinvalidchar = new character ( ch ) ; return refinvalidchar ; } } } return null ; }	checks if a xml character is well - formed.
public void testzerozero ( ) { string numa = _str ; string numb = _str ; string res = _str ; biginteger anumber = new biginteger ( numa ) ; biginteger bnumber = new biginteger ( numb ) ; biginteger result = anumber . xor ( bnumber ) ; asserttrue ( res . equals ( result . tostring ( ) ) ) ; }	xor for zero and zero.
public final parallelflux < t > doonnext ( consumer < ? super t > onnext ) { objects . requirenonnull ( onnext , _str ) ; return doonsignal ( this , onnext , null , null , null , null , null , null , null ) ; }	call the specified consumer with the current element passing through any ' rail ' .
public void test_fill ciic ( ) { char val = _str ; char d [ ] = new char [ _num ] ; arrays . fill ( d , _num , d . length , val ) ; for ( int i = _num ; i < _num ; i ++ ) asserttrue ( _str , ! ( d [ i ] == val ) ) ; for ( int i = _num ; i < d . length ; i ++ ) asserttrue ( _str , d [ i ] == val ) ; try { arrays . fill ( d , _num , _num , val ) ; fail ( _str ) ; } catch ( illegalargumentexception e ) { } try { arrays . fill ( d , - _num , _num , val ) ; fail ( _str ) ; } catch ( arrayindexoutofboundsexception e ) { } try { arrays . fill ( d , _num , d . length + _num , val ) ; fail ( _str ) ; } catch ( arrayindexoutofboundsexception e ) { } }	java . util . arrays # fill ( char [ ] , int , int , char ).
protected void addmissing ( instances data , int level , boolean predictormissing , boolean classmissing ) { int classindex = data . classindex ( ) ; random random = new random ( _num ) ; for ( int i = _num ; i < data . numinstances ( ) ; i ++ ) { instance current = data . instance ( i ) ; for ( int j = _num ; j < data . numattributes ( ) ; j ++ ) { if ( ( ( j == classindex ) && classmissing ) || ( ( j != classindex ) && predictormissing ) ) { if ( math . abs ( random . nextint ( ) ) % _num < level ) current . setmissing ( j ) ; } } } }	add missing values to a dataset .
public < t extends dataobject > void insertinbatches ( list < t > records , int partitionsize , dbclient dbclient , string type ) { list < list < t > > volume_partitions = lists . partition ( records , partitionsize ) ; for ( list < t > partition : volume_partitions ) { try { dbclient . createobject ( partition ) ; _log . info ( _str , partition . size ( ) , type ) ; } catch ( databaseexception e ) { _log . error ( _str , type , e ) ; } } }	insert discovered objects in batches.
public void removeontabselectedlistener ( ontabselectedlistener listener ) { if ( listener != null ) { mlisteners . remove ( listener ) ; } }	removes the given tab listener from this layout.
public connecturimanager ( list < string > connecturi ) throws thlexception { this . urilist = connecturi ; if ( connecturi . size ( ) == _num ) { throw new thlexception ( _str ) ; } }	creates a new instance with a list of uris .
private void addvolumestoparkingstoragegroup ( storagesystem storage , string policyname , set < string > volumedeviceids ) throws exception { string [ ] tokens = policyname . split ( constants . smis_plus_regex ) ; cimobjectpath grouppath = _helper . getvolumegroupbasedonslo ( storage , storage , tokens [ _num ] , tokens [ _num ] , tokens [ _num ] ) ; if ( grouppath == null ) { grouppath = _helper . createvolumegroupbasedonslo ( storage , storage , tokens [ _num ] , tokens [ _num ] , tokens [ _num ] ) ; } cimargument [ ] inargs = _helper . getaddvolumestomaskinggroupinputarguments ( storage , grouppath , volumedeviceids ) ; cimargument [ ] outargs = new cimargument [ _num ] ; smisjob addvolumestosgjob = new smissynchsubtaskjob ( null , storage . getid ( ) , smisconstants . add_members ) ; _helper . invokemethodsynchronously ( storage , _cimpath . getcontrollerconfigsvcpath ( storage ) , _str , inargs , outargs , addvolumestosgjob ) ; }	this method is used for vmax3 to add volumes to parking storage group once volumes are unexported .
public static inputstream toinputstream ( string input , charset encoding ) { return new bytearrayinputstream ( input . getbytes ( charsets . tocharset ( encoding ) ) ) ; }	convert the specified string to an input stream , encoded as bytes using the specified character encoding .
public boolean exportpkcs8 ( ) { return jrbpkcs8 . isselected ( ) ; }	has the user chosen to export to pkcs # 8 ?.
public static publickey generatepublickey ( string encodedpublickey ) { try { byte [ ] decodedkey = base64 . decode ( encodedpublickey ) ; keyfactory keyfactory = keyfactory . getinstance ( key_factory_algorithm ) ; return keyfactory . generatepublic ( new x509encodedkeyspec ( decodedkey ) ) ; } catch ( nosuchalgorithmexception e ) { throw new runtimeexception ( e ) ; } catch ( invalidkeyspecexception e ) { log . e ( tag , _str ) ; throw new illegalargumentexception ( e ) ; } catch ( base64decoderexception e ) { log . e ( tag , _str ) ; throw new illegalargumentexception ( e ) ; } }	generates a publickey instance from a string containing the base64 - encoded public key .
public numbertick ( number number , string label , textanchor textanchor , textanchor rotationanchor , double angle ) { super ( number . doublevalue ( ) , label , textanchor , rotationanchor , angle ) ; this . number = number ; }	creates a new tick .
private boolean isstoppable ( ) { return ( isrunning ( ) && getcache ( ) != null ) ; }	determines whether the server can be stopped in - process , such as when a server is embedded in an application and the serverlauncher api is being used .
private void log ( string message , string level , string levelcolor , printstream ps ) { stringbuilder builder = new stringbuilder ( ) ; if ( ! level . equals ( _str ) ) builder . append ( getprefix ( level , levelcolor ) ) ; builder . append ( message ) ; string ts = builder . tostring ( ) ; ps . println ( ts ) ; for ( loghandler hand : handlers ) hand . onlog ( level , message , ts , this ) ; }	log a new message on the selected printstream with the given method and level.
public static boolean ispublic ( int mod ) { return modifier . ispublic ( mod ) ; }	returns if modifier is public.
public static map < string , object > createuserprefmap ( genericvalue rec ) throws generalexception { return addpreftomap ( rec , new linkedhashmap < string , object > ( ) ) ; }	convert a userpreference genericvalue to a userprefmap .
public jsonbuffer appendstring ( object cont ) { if ( stack . empty ( ) || stack . peek ( ) != operand . array ) { throw new jsonexception ( _str ) ; } addquotedstring ( cont ) ; addseparator ( ) ; return this ; }	append a string in quotes.
public static void deleteuserfromauthenticationinfo ( authenticationinfo authenticationinfo ) throws serverruntimeexception { string username = authenticationinfo . getusername ( ) ; string passwordfilelocation = authenticationinfo . getpasswordfilelocation ( ) ; try { propertiesconfiguration props = new propertiesconfiguration ( passwordfilelocation ) ; string usernameinfile = props . getstring ( username ) ; if ( usernameinfile == null ) { throw new serverruntimeexception ( messageformat . format ( _str , username ) ) ; } props . clearproperty ( username ) ; props . save ( ) ; } catch ( org . apache . commons . configuration . configurationexception ce ) { logger . error ( _str + authenticationinfo . getpasswordfilelocation ( ) , ce ) ; throw new serverruntimeexception ( _str + ce . getmessage ( ) ) ; } }	delete a user and password from a file.
public void error ( level level , string messageid , string data [ ] , object session ) throws logexception { error ( level , messageid , data , session , null ) ; }	logs error messages to the error logs .
public synchronized void remove ( iaudioprocessor processor ) { processors . remove ( processor ) ; buildfinalprocessor ( ) ; }	removes the provided processor from the internal processor queue .
private int endrecoveranimation ( viewholder viewholder , boolean override ) { final int recoveranimsize = mrecoveranimations . size ( ) ; for ( int i = recoveranimsize - _num ; i >= _num ; i -- ) { final recoveranimation anim = mrecoveranimations . get ( i ) ; if ( anim . mviewholder == viewholder ) { anim . moverridden |= override ; if ( ! anim . mended ) { anim . cancel ( ) ; } mrecoveranimations . remove ( i ) ; return anim . manimationtype ; } } return _num ; }	returns the animation type or 0 if cannot be found .
public final void addelement ( string value ) { if ( ( m_firstfree + _num ) >= m_mapsize ) { m_mapsize += m_blocksize ; string newmap [ ] = new string [ m_mapsize ] ; system . arraycopy ( m_map , _num , newmap , _num , m_firstfree + _num ) ; m_map = newmap ; } m_map [ m_firstfree ] = value ; m_firstfree ++ ; }	append a string onto the vector .
private boolean ismethodcontained ( method m , list < method > wrappermethods ) { string name = m . getname ( ) ; class < ? > [ ] paramtypes = m . getparametertypes ( ) ; class < ? > returntype = m . getreturntype ( ) ; for ( method wm : wrappermethods ) { if ( name . equals ( wm . getname ( ) ) && arrays . equals ( paramtypes , wm . getparametertypes ( ) ) && returntype == wm . getreturntype ( ) ) { return _bool ; } } return _bool ; }	returns true it the passed method is contained in the also passed list of methods by also comparing matching parameters .
public void deletenode ( node n ) { assert . check ( nodes . contains ( n ) ) ; nodes . remove ( n ) ; notifyupdate ( n , null ) ; }	delete a node from the graph.
void updatepressed ( actionevent e , boolean newroute ) { string uname = _username . gettext ( ) ; route g = checknamesok ( ) ; if ( g == null ) { return ; } g . setusername ( uname ) ; g . clearoutputturnouts ( ) ; g . clearoutputsensors ( ) ; g . clearroutesensors ( ) ; initializeincludedlist ( ) ; setturnoutinformation ( g ) ; setsensorinformation ( g ) ; g . setoutputscriptname ( scriptfile . gettext ( ) ) ; g . setoutputsoundname ( soundfile . gettext ( ) ) ; setcontrolinformation ( g ) ; curroute = g ; finishupdate ( ) ; status1 . settext ( ( newroute ? bundle . getmessage ( _str ) : bundle . getmessage ( _str ) ) + _str + uname + _str + _includedturnoutlist . size ( ) + _str + bundle . getmessage ( _str ) + _str + _includedsensorlist . size ( ) + _str + bundle . getmessage ( _str ) + _str ) ; }	responds to the update button - update to route table.
public string tostring ( ) { return m_attributes . tostring ( ) ; }	returns a string representation of this object.
private static void checkforxstream ( ) { try { class . forname ( _str ) ; m_present = _bool ; } catch ( exception e ) { m_present = _bool ; } }	checks whether the xstream is present in the class path.
public double evaluate ( vectorinstance x , double [ ] y ) throws exception { vectorinstance diff = x . subtract ( y ) ; double result = - m_gamma * diff . dotproduct ( diff ) ; return math . exp ( result ) ; }	compute the result of the kernel evaluation on the supplied vectors.
@ override public int batchsize ( ) { return batchsize ; }	get local batch size for this sequences .
public static final byte [ ] decodeurl ( byte [ ] bytes ) throws decoderexception { if ( bytes == null ) { return null ; } bytearrayoutputstream buffer = new bytearrayoutputstream ( ) ; for ( int i = _num ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b == _str ) { buffer . write ( _str ) ; } else if ( b == _str ) { try { int u = character . digit ( ( char ) bytes [ ++ i ] , _num ) ; int l = character . digit ( ( char ) bytes [ ++ i ] , _num ) ; if ( u == - _num || l == - _num ) { throw new decoderexception ( _str ) ; } buffer . write ( ( char ) ( ( u << _num ) + l ) ) ; } catch ( arrayindexoutofboundsexception e ) { throw new decoderexception ( _str ) ; } } else { buffer . write ( b ) ; } } return buffer . tobytearray ( ) ; }	decodes an array of url safe 7 - bit characters into an array of original bytes.
public void clear ( ) { mattachedscrap . clear ( ) ; recycleandclearcachedviews ( ) ; }	clear scrap views out of this recycler.
public void adddataset ( t d ) { if ( d == null ) return ; myvalcount += d . getentrycount ( ) ; myvaluesum += d . getyvaluesum ( ) ; if ( mdatasets . size ( ) <= _num ) { mymax = d . getymax ( ) ; mymin = d . getymin ( ) ; if ( d . getaxisdependency ( ) == axisdependency . left ) { mleftaxismax = d . getymax ( ) ; mleftaxismin = d . getymin ( ) ; } else { mrightaxismax = d . getymax ( ) ; mrightaxismin = d . getymin ( ) ; } } else { if ( mymax < d . getymax ( ) ) mymax = d . getymax ( ) ; if ( mymin > d . getymin ( ) ) mymin = d . getymin ( ) ; if ( d . getaxisdependency ( ) == axisdependency . left ) { if ( mleftaxismax < d . getymax ( ) ) mleftaxismax = d . getymax ( ) ; if ( mleftaxismin > d . getymin ( ) ) mleftaxismin = d . getymin ( ) ; } else { if ( mrightaxismax < d . getymax ( ) ) mrightaxismax = d . getymax ( ) ; if ( mrightaxismin > d . getymin ( ) ) mrightaxismin = d . getymin ( ) ; } } mdatasets . add ( d ) ; handleemptyaxis ( getfirstleft ( ) , getfirstright ( ) ) ; }	adds a dataset dynamically .
public void endelement ( string elementname ) throws saxexception { if ( m_firsttagnotemitted ) { flush ( ) ; } m_handler . endelement ( elementname ) ; }	pass the call on to the underlying handler.
public libvlc ( arraylist < string > options ) { boolean setaout = _bool , setchroma = _bool ; if ( options != null ) { for ( string option : options ) { if ( option . startswith ( _str ) ) setaout = _bool ; if ( option . startswith ( _str ) ) setchroma = _bool ; if ( ! setaout && ! setchroma ) break ; } } if ( setaout || setchroma ) { if ( options == null ) options = new arraylist < string > ( ) ; if ( setaout ) { final hwdecoderutil . audiooutput hwaout = hwdecoderutil . getaudiooutputfromdevice ( ) ; if ( hwaout == hwdecoderutil . audiooutput . opensles ) options . add ( _str ) ; else options . add ( _str ) ; } if ( setchroma ) { options . add ( _str ) ; options . add ( _str ) ; } } nativenew ( options . toarray ( new string [ options . size ( ) ] ) ) ; }	create a libvlc withs options.
public fpstextureview addchildat ( int location , @ nonnull displaybase displaybase ) { displaybase . setup ( mfps ) ; mdisplaylist . add ( location , displaybase ) ; return this ; }	adds a child to the display list at the specified index , bumping children at equal or greater indexes up one , and setting its parent to this container.
public static int minpathsum ( int [ ] [ ] grid ) { if ( grid == null || grid . length == _num ) return _num ; int m = grid . length ; int n = grid [ _num ] . length ; int [ ] rowsum = new int [ n ] ; rowsum [ _num ] = grid [ _num ] [ _num ] ; for ( int col = _num ; col < n ; col ++ ) rowsum [ col ] = rowsum [ col - _num ] + grid [ _num ] [ col ] ; for ( int row = _num ; row < m ; row ++ ) { rowsum [ _num ] += grid [ row ] [ _num ] ; for ( int col = _num ; col < n ; col ++ ) { rowsum [ col ] = math . min ( rowsum [ col - _num ] , rowsum [ col ] ) + grid [ row ] [ col ] ; } } return rowsum [ n - _num ] ; }	dp . bottom - up row by row , use an array to store values.
public time ( date time ) { simpletimezone tz = new simpletimezone ( _num , _str ) ; simpledateformat datef = new simpledateformat ( _str ) ; datef . settimezone ( tz ) ; string d = datef . format ( time ) + _str ; int year = integer . parseint ( d . substring ( _num , _num ) ) ; if ( year < _num || year > _num ) { this . time = new dergeneralizedtime ( d ) ; } else { this . time = new derutctime ( d . substring ( _num ) ) ; } }	creates a time object from a given date - if the date is between 1950 and 2049 a utctime object is generated , otherwise a generalizedtime is used .
public dcheckupdate ( jframe parent ) { super ( parent , dialog . modalitytype . document_modal ) ; initcomponents ( ) ; }	creates a new dcheckupdate dialog .
public static automaton minimizesimple ( automaton a ) { set < integer > initialset = new hashset < integer > ( ) ; a = determinizesimple ( operations . reverse ( a , initialset ) , initialset ) ; initialset . clear ( ) ; a = determinizesimple ( operations . reverse ( a , initialset ) , initialset ) ; return a ; }	simple , original brics implementation of brzozowski minimize ( ).
@ override public boolean equals ( object o ) { if ( this == o ) return _bool ; if ( o == null || getclass ( ) != o . getclass ( ) ) return _bool ; abstractitem < ? , ? > that = ( abstractitem < ? , ? > ) o ; return midentifier == that . midentifier ; }	if this item equals to the given object.
public void addcolumn ( column column ) { if ( column != null ) { columns . add ( column ) ; } }	adds the given column .
private boolean checkfornans ( numbervector vec ) { for ( int i = _num , d = vec . getdimensionality ( ) ; i < d ; i ++ ) { double v = vec . doublevalue ( i ) ; if ( v != v ) { return _bool ; } } return _bool ; }	check for nan values .
public static void fill ( stringbuilder strb , int offset ) { while ( strb . length ( ) < offset ) strb . append ( _str ) ; }	fills a string buffer with spaces until it has at least the given length.
public void openforwrite ( ) throws eventexception { file f = new file ( configutils . getinitialpropertyexpanded ( m_address . getpathname ( ) ) ) ; try { if ( ! f . exists ( ) ) { f . createnewfile ( ) ; } else { logger . info ( _str + m_address . getpathname ( ) ) ; } } catch ( ioexception ioe ) { throw new eventexception ( _str + m_address . getpathname ( ) + _str + ioe ) ; } try { m_fos = new fileoutputstream ( f , _bool ) ; } catch ( filenotfoundexception fnfe ) { throw new eventexception ( _str + m_address . getpathname ( ) + _str + fnfe ) ; } }	open the file with appending mode.
@ override public double calculate_k ( int [ ] x_index , double [ ] x_att , int [ ] y_index , double [ ] y_att ) { return ( math . exp ( gamma * norm2 ( x_index , x_att , y_index , y_att ) ) ) ; }	calculates kernel value of vectors x and y .
@ override public void close ( ) throws ioexception { throwable thrown = null ; try { flush ( ) ; } catch ( throwable e ) { thrown = e ; } try { out . close ( ) ; } catch ( throwable e ) { if ( thrown == null ) { thrown = e ; } } }	closes this stream . this implementation closes the target stream .
public static void writefofn ( final file destination , final list < file > files ) throws ioexception { final bufferedwriter bw = new bufferedwriter ( new filewriter ( destination ) ) ; try { for ( final file file : files ) { bw . write ( wraparg ( file . getabsolutepath ( ) ) ) ; bw . newline ( ) ; } bw . flush ( ) ; } finally { bw . close ( ) ; } }	takes a list of files and writes it as a " file of file names " ( i.
void markinternalclasses ( ) { for ( int i = mclassdefs . length - _num ; i >= _num ; i -- ) { mtypeids [ mclassdefs [ i ] . classidx ] . internal = _bool ; } for ( int i = _num ; i < mtypeids . length ; i ++ ) { string classname = mstrings [ mtypeids [ i ] . descriptoridx ] ; if ( classname . length ( ) == _num ) { mtypeids [ i ] . internal = _bool ; } else if ( classname . charat ( _num ) == _str ) { mtypeids [ i ] . internal = _bool ; } } }	sets the " internal " flag on type ids which are defined in the dex file or within the vm ( e.
public final double cos ( ) { return math . cos ( this . radians ) ; }	obtains the cosine of this angle .
public static double sserror ( double [ ] predictedvalues , double [ ] targetattribute ) { double ret = _num ; for ( int i = _num ; i < predictedvalues . length ; i ++ ) { ret += math . pow ( targetattribute [ i ] - predictedvalues [ i ] , _num ) ; } return ret ; }	how much of the variance is not explained by the regression.
public int size ( ) { return prefixes . size ( ) ; }	this returns the number of available namespaces .
@ override public writer append ( charsequence value ) { builder . append ( value ) ; return this ; }	append a character sequence to this writer .
public static string timestamp ( datetime ts ) { return long . tostring ( ts . getmillis ( ) / _num ) ; }	convert a timestamp to the string representation that wavefront will accept .
public string consume ( string name , boolean required ) throws parseexception { if ( name == null ) { if ( content == null && required ) { throw new parseexception ( coreerrordomain . err . missingrequiredcontent ) ; } contentconsumed = _bool ; return content ; } string value = attrs . get ( name ) ; if ( value == null ) { if ( required ) { parseexception pe = new parseexception ( coreerrordomain . err . missingattribute ) ; pe . setinternalreason ( _str + name + _str ) ; throw pe ; } return null ; } attrs . remove ( name ) ; return value ; }	gets the value of an attribute and remove it from the list .
public int copy ( byte [ ] bytes , int at ) { system . arraycopy ( this . bytes , _num , bytes , at , this . length ) ; return at + this . length ; }	copy the contents of this kim to a byte array .
public void importkey ( eckey key ) { lock . lock ( ) ; try { checkkeyencryptionstatematches ( key ) ; if ( haskey ( key ) ) return ; importkeylocked ( key ) ; queueonkeysadded ( immutablelist . of ( key ) ) ; } finally { lock . unlock ( ) ; } }	imports a key to the key chain.
public connectiongrouptree ( usercontext usercontext , connectiongroup root , list < objectpermission . type > permissions ) throws guacamoleexception { this . rootapigroup = new apiconnectiongroup ( root ) ; retrievedgroups . put ( root . getidentifier ( ) , this . rootapigroup ) ; user self = usercontext . self ( ) ; this . connectionpermissions = self . getconnectionpermissions ( ) ; this . sharingprofilepermissions = self . getsharingprofilepermissions ( ) ; this . connectiondirectory = usercontext . getconnectiondirectory ( ) ; this . connectiongroupdirectory = usercontext . getconnectiongroupdirectory ( ) ; this . sharingprofiledirectory = usercontext . getsharingprofiledirectory ( ) ; addconnectiongroupdescendants ( collections . singleton ( root ) , permissions ) ; }	creates a new connection group tree using the given connection group as the tree root .
private boolean containssinglemetric ( bufferedreader reader ) throws formatparseexception { try { reader . mark ( _num ) ; char firstchar = ( char ) reader . read ( ) ; reader . reset ( ) ; return firstchar == _str ; } catch ( ioexception e ) { throw new formatparseexception ( _str , e ) ; } }	determines if the given reader contains a single or multiple metrics .
private string separemetatagscontent ( string content ) { string result = utils . pregmatch ( content , constants . metatag_content_pattern , _num ) ; return htmldecode ( result ) ; }	gets content from metatag.
@ override public void removecolumns ( column ... columns ) { for ( column c : columns ) { columnlist . remove ( c ) ; } }	removes the given columns.
private void readserviceconfig ( ) throws ssoexception , smsexception { if ( debug . messageenabled ( ) ) { debug . message ( _str ) ; } ssotoken internaltoken = ( ssotoken ) accesscontroller . doprivileged ( admintokenaction . getinstance ( ) ) ; serviceschemamanager = new serviceschemamanager ( g11n_settings_service_name , internaltoken ) ; serviceschema gsc = serviceschemamanager . getglobalschema ( ) ; rawservicedata = gsc . getattributedefaults ( ) ; }	read g11nsettings service config data from sms.
public void refreshpreferences ( context context ) { if ( menabledresid != _num ) { final sharedpreferences prefs = preferencemanager . getdefaultsharedpreferences ( context ) ; if ( ! prefs . getboolean ( context . getstring ( menabledresid ) , menableddefault ) ) { settriggerkeys ( collections . < long > emptyset ( ) ) ; return ; } } settriggerkeys ( keycombopreference . getkeycodesforpreference ( context , massignedkeysresid ) ) ; }	read key mapping from default preferences for context.
void addinheritedtypes ( typemirror typemirror , types typesutils ) { if ( ! compilerutils . typemirrorincollection ( inheritedtypes , typemirror , typesutils ) ) { inheritedtypes . add ( typemirror ) ; } }	add the types that are inherited by this class .
public static histogram multiply ( histogram x , double y ) { return x . modifyeventcounters ( null ) ; }	multiply histogram by scalar .
public void addcacheparticipants ( map < uuid , igniteuuid > allparticipants , map < uuid , igniteuuid > addedparticipants ) { verstore . addparticipants ( allparticipants , addedparticipants ) ; }	adds participants to all shared deployments .
public static string tojsonstring ( map map ) { final stringwriter writer = new stringwriter ( ) ; try { writejsonstring ( map , writer ) ; return writer . tostring ( ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }	convert a map to json text.
public void printcontext ( printstream out ) { out . println ( getmessage ( ) ) ; out . print ( context ) ; }	prints the message and context .
public int size ( ) { return methods . size ( ) ; }	returns the number of method invoked so far .
private void storerequestid ( string requestid , string key ) { requestids . put ( requestid , key ) ; }	helper method to associate request ids to shared preference keys.
private void savepostmni ( string mnipostlocation , string mnipostresplocation , list managenameidlist , com . sun . identity . saml2 . jaxb . metadata . objectfactory objfact ) throws jaxbexception { if ( mnipostlocation != null && mnipostlocation . length ( ) > _num ) { managenameidserviceelement slselempost = objfact . createmanagenameidserviceelement ( ) ; slselempost . setbinding ( httppostbinding ) ; slselempost . setlocation ( mnipostlocation ) ; slselempost . setresponselocation ( mnipostresplocation ) ; managenameidlist . add ( slselempost ) ; } }	saves the post managenameid service .
public static boolean gotoupdatepage ( context context ) { final uri playstoreuri = uri . parse ( _str + context . getpackagename ( ) ) ; freshairlog . i ( _str + playstoreuri . tostring ( ) ) ; final intent playstoreintent = new intent ( intent . action_view , playstoreuri ) ; final packagemanager packagemanager = context . getpackagemanager ( ) ; for ( resolveinfo resolveinfo : packagemanager . queryintentactivities ( playstoreintent , _num ) ) { final activityinfo resolveactivity = resolveinfo . activityinfo ; final string resolvepackagename = resolveactivity . packagename ; if ( resolvepackagename . equals ( _str ) ) { freshairlog . i ( _str ) ; playstoreintent . setcomponent ( new componentname ( resolvepackagename , resolveactivity . name ) ) ; context . startactivity ( playstoreintent ) ; return _bool ; } } freshairlog . e ( _str + playstoreuri . tostring ( ) ) ; return _bool ; }	attempts to start the play store activity for the update page of this app , and returns success or failure .
public ijavaelement createelement ( classscope scope , icompilationunit unit , hashset existingelements , hashmap knownscopes ) { return createelement ( scope , scope . referencecontext . sourcestart , unit , existingelements , knownscopes ) ; }	returns a handle denoting the class member identified by its scope .
public static list < string > torelativefiles ( @ notnull virtualfile root , @ notnull final collection < virtualfile > files ) { arraylist < string > rc = new arraylist < string > ( files . size ( ) ) ; for ( virtualfile file : files ) { rc . add ( relativepath ( root , file ) ) ; } return rc ; }	covert list of files to relative paths.
synchronized static void ensuresecuritymanager ( ) { if ( system . getsecuritymanager ( ) == null ) { system . setsecuritymanager ( new rmisecuritymanager ( ) ) ; } }	utility routine that sets a security manager if one isn ' t already present .
public static bigdecimal rate ( int p_c_currencyfrom_id , int p_c_currencyto_id , timestamp p_conversiondate , int p_c_conversiontype_id , int p_ad_client_id , int p_ad_org_id ) throws sqlexception { if ( p_c_currencyfrom_id == p_c_currencyto_id ) return adempiere . one ; timestamp conversiondate = p_conversiondate ; if ( conversiondate == null ) conversiondate = new timestamp ( system . currenttimemillis ( ) ) ; conversiondate = adempiere . trunc ( conversiondate ) ; int c_conversiontype_id = p_c_conversiontype_id ; if ( c_conversiontype_id == _num ) { string sql = _str + _str + _str + _str + _str ; c_conversiontype_id = adempiere . getsqlvalue ( sql , p_ad_client_id ) ; } bigdecimal rate = null ; string sql = _str + _str + _str + _str + _str + _str + _str + _str ; preparedstatement pstmt = adempiere . preparestatement ( sql ) ; pstmt . setint ( _num , p_c_currencyfrom_id ) ; pstmt . setint ( _num , p_c_currencyto_id ) ; pstmt . setint ( _num , c_conversiontype_id ) ; pstmt . settimestamp ( _num , conversiondate ) ; pstmt . settimestamp ( _num , conversiondate ) ; pstmt . setint ( _num , p_ad_client_id ) ; pstmt . setint ( _num , p_ad_org_id ) ; resultset rs = pstmt . executequery ( ) ; if ( rs . next ( ) ) { rate = rs . getbigdecimal ( _num ) ; } rs . close ( ) ; pstmt . close ( ) ; if ( rate == null ) return null ; return rate ; }	get conversion rate . previously : c_currency_rate - now : currencyrate.
public static socket dointeraction ( final httpsurlconnection clientconnection , final serversocket serversocket , final int responsecode , final boolean doauthentication ) throws throwable { clientconnection . setdoinput ( _bool ) ; clientconnection . setconnecttimeout ( timeout ) ; clientconnection . setreadtimeout ( timeout ) ; serverwork server = new serverwork ( serversocket , responsecode , doauthentication ) ; clientconnectionwork client = new clientconnectionwork ( clientconnection ) ; executorservice executorservice = executors . newfixedthreadpool ( _num ) ; try { future < void > serverfuture = executorservice . submit ( server ) ; future < void > clientfuture = executorservice . submit ( client ) ; throwable t = null ; try { serverfuture . get ( _num , timeunit . seconds ) ; } catch ( executionexception e ) { t = e . getcause ( ) ; } try { clientfuture . get ( _num , timeunit . seconds ) ; } catch ( executionexception e ) { if ( t != null ) { t . printstacktrace ( ) ; } t = e . getcause ( ) ; } if ( t != null ) { throw t ; } } catch ( executionexception e ) { throw e . getcause ( ) ; } finally { executorservice . shutdown ( ) ; } return server . peersocket ; }	performs interaction between client ' s httpsurlconnection and servers side ( serversocket ).
public static snmpengineid createengineid ( int port ) throws unknownhostexception { int suniana = _num ; inetaddress address = null ; address = inetaddress . getlocalhost ( ) ; return createengineid ( address , port , suniana ) ; }	generates a unique engine id.
public static list < rule > parsereferential ( string path ) { ruleset ruleset = delphirulesutils . buildrulesetfromxml ( delphirulesutils . getconfigurationfromfile ( path ) ) ; list < rule > rulesrepository = new arraylist < rule > ( ) ; for ( delphirule frule : ruleset . getrules ( ) ) { rulesrepository . add ( createrepositoryrule ( frule ) ) ; } return rulesrepository ; }	parses rules xml file.
public org . w3c . dom . document encryptandreplacewsselements ( org . w3c . dom . document doc , java . util . map elmmap , java . lang . string encdataencalg , int encdataencalgstrength , string certalias , int kekstrength , java . lang . string tokentype , java . lang . string providerid ) throws encryptionexception { return null ; }	encrypts the given wss xml element in a given xml context document .
public void addissue ( int reason , eobject obj , int featureid ) { issues . add ( new transformationissue ( reason , obj , featureid , null ) ) ; }	add an issue during transformation.
public void insertchild ( node node , int index ) { node . detachfromparent ( ) ; node . parentnode = this ; try { initchildnodes ( node ) ; childnodes . add ( index , node ) ; } catch ( indexoutofboundsexception ignore ) { throw new lagartodomexception ( _str + index ) ; } reindexchildren ( ) ; }	inserts node at given index .
private static byte [ ] ntlmhash ( final string password ) throws authenticationexception { try { final byte [ ] unicodepassword = password . getbytes ( _str ) ; final md4 md4 = new md4 ( ) ; md4 . update ( unicodepassword ) ; return md4 . getoutput ( ) ; } catch ( unsupportedencodingexception e ) { throw new authenticationexception ( _str + e . getmessage ( ) , e ) ; } }	creates the ntlm hash of the user ' s password .
private boolean betweenzeroandone ( final string paramname , final double val ) { if ( ( val < _num ) || ( val > _num ) ) { joptionpane . showmessagedialog ( null , paramname + _str , _str , joptionpane . warning_message ) ; return _bool ; } return _bool ; }	helper method to check that a value is between 0 and 1 and display a warning if not .
public abstract string substitutemacros ( string parametervalue , macrohandler mh ) throws undefinedparametererror ;	this method operates on the internal string representation of parameter values and replaces macro expressions of the form % { macroname } .
public void powequals ( double exp ) { for ( int i = _num ; i < a . length ; i ++ ) for ( int j = _num ; j < a [ i ] . length ; j ++ ) a [ i ] [ j ] = math . pow ( a [ i ] [ j ] , exp ) ; }	x . powequals ( ) calculates the power of each element of the matrix . the result is stored in this matrix object again .
private static list < string > splitcamelcase ( string classname ) { string remaining = classname ; list < string > result = new arraylist < string > ( ) ; while ( ! remaining . isempty ( ) ) { boolean found = _bool ; for ( int i = _num ; i < remaining . length ( ) ; i ++ ) { if ( character . isuppercase ( remaining . charat ( i ) ) ) { result . add ( remaining . substring ( _num , i ) ) ; remaining = remaining . substring ( i ) ; found = _bool ; break ; } } if ( ! found ) { result . add ( remaining ) ; remaining = _str ; } } return result ; }	converts a name like " outputbyteinputtablecodingloop " to a list of words : { " output " , " byte " , " input " , " table " , " coding " , " loop " }.
public static nodelist selectnodelist ( node doc , string str , namespacecontext nsctx ) throws xpathexception { xpathfactory xpf = xpathfactorycache . getinstanceforcurrentthread ( ) ; xpath xpath = xpf . newxpath ( ) ; xpath . setnamespacecontext ( nsctx ) ; xpathexpression expr = xpath . compile ( str ) ; return ( nodelist ) expr . evaluate ( doc , xpathconstants . nodeset ) ; }	use an xpath string to select a nodelist namespace prefix is resolved using the the specified context .
public resultentry ( nondominatedpopulation population , typedproperties properties ) { this ( population , properties == null ? null : properties . getproperties ( ) ) ; }	constructs a result file entry with the specified non - dominated population and auxiliary properties .
private void generatediscovery ( ) throws saxexception { handler . startelement ( _str , locators , locators , empty ) ; generatelocators ( ) ; handler . endelement ( _str , locators , locators ) ; }	generates xml for locators in the distributed system.
protected basictype ( class < t > type , int sqltype ) { super ( type , sqltype ) ; checknull = ! type . isprimitive ( ) ; }	instantiates a new type instance .
@ override public void actionperformed ( actionevent e ) { }	close window ( or reload page if in debug mode ).
public void applyproperties ( ) { for ( parametertype type : allparametertypes ) { string value = allparametervalues . getproperty ( type . getkey ( ) ) ; parameterservice . setparametervalue ( type , value ) ; } }	applies the properties without saving them .
private void rotateleft ( node < k , v > root ) { node < k , v > left = root . left ; node < k , v > pivot = root . right ; node < k , v > pivotleft = pivot . left ; node < k , v > pivotright = pivot . right ; root . right = pivotleft ; if ( pivotleft != null ) { pivotleft . parent = root ; } replaceinparent ( root , pivot ) ; pivot . left = root ; root . parent = pivot ; root . height = math . max ( left != null ? left . height : _num , pivotleft != null ? pivotleft . height : _num ) + _num ; pivot . height = math . max ( root . height , pivotright != null ? pivotright . height : _num ) + _num ; }	rotates the subtree so that its root ' s right child is the new root .
public void add ( clusternode newnode ) { if ( node != null ) { nodes = new arraylist < > ( _num ) ; nodes . add ( node ) ; node = null ; } nodes . add ( newnode ) ; }	add node to the group .
public boolean checkifbackupsetexists ( string setname ) { validatenotnullorempty ( setname ) ; try { file file = new file ( getbackuproot ( ) , setname ) ; if ( file . exists ( ) ) { return _bool ; } } catch ( exception e ) { log . error ( _str ) ; } return _bool ; }	check to see if the given backup set already exists in the backup store .
public static string [ ] toquotedandcommaseparatedarray ( string str ) throws ioexception { linkedlist < string > values = new linkedlist < string > ( ) ; streamtokenizer tt = new streamtokenizer ( new stringreader ( str ) ) ; tt . wordchars ( _str , _str ) ; tt . wordchars ( _str , _str ) ; tt . wordchars ( _num + _num , _num ) ; tt . whitespacechars ( _num , _str ) ; tt . quotechar ( _str ) ; tt . quotechar ( _str ) ; while ( tt . nexttoken ( ) != streamtokenizer . tt_eof ) { switch ( tt . ttype ) { case streamtokenizer . tt_word : case _str : case _str : values . add ( tt . sval ) ; break ; } } return values . toarray ( new string [ values . size ( ) ] ) ; }	returns a value as a string array.
public void writestringnocompression ( string str ) throws ioexception { if ( str == null ) { writeint ( _num ) ; } else { writeint ( str . length ( ) ) ; for ( int i = _num ; i < str . length ( ) ; i ++ ) io . write ( ( byte ) str . charat ( i ) ) ; } }	write a string without compression.
public smartthresholds parse ( final resource thresholdfileresource ) throws ioexception { final smartthresholds holder = new smartthresholds ( ) ; bufferedreader reader = null ; try { reader = new bufferedreader ( new inputstreamreader ( thresholdfileresource . getinputstream ( ) ) ) ; string line ; while ( ( line = reader . readline ( ) ) != null ) { if ( line . startswith ( _str ) ) { string [ ] lineinput = line . split ( _str ) ; holder . addthreshold ( new smartthreshold ( lineinput ) ) ; } } } finally { if ( reader != null ) { reader . close ( ) ; } } return holder ; }	returns a map of model accession to a threshold record .
public void shutdown ( ) { executorservice executor = executors . newscheduledthreadpool ( _num ) ; executor . submit ( createshutdown ( _num ) ) ; }	shutdown all attached resources without waiting on the thread.
@ override public point drawingtoview ( point2d . double p ) { return new point ( ( int ) ( p . x * scalefactor ) - translation . x , ( int ) ( p . y * scalefactor ) - translation . y ) ; }	converts drawing coordinates to view coordinates .
protected void onconnect ( ) { }	this method is called once the pircbot has successfully connected to the irc server.
public void adddescriptor ( final setupdescriptor desc ) { descriptors . add ( desc ) ; }	add a setup descriptor .
public static string compileprogresssuccessaction ( string progresssuccessaction ) throws templatemodelexception { environment env = commonftlutil . getcurrentenvironment ( ) ; return compileprogresssuccessaction ( progresssuccessaction , contextftlutil . getrequest ( env ) , contextftlutil . getresponse ( env ) ) ; }	compiles a progress success action.
public static string join ( string separator , float ... elements ) { if ( elements == null || elements . length == _num ) { return _str ; } list < number > list = new arraylist < number > ( elements . length ) ; for ( float elem : elements ) { list . add ( elem ) ; } return join ( separator , list ) ; }	returns a string with all float values concatenated by a specified separator .
public static void putunsignedbyte ( bytebuffer bb , short v ) { bb . put ( ( byte ) ( v & _num ) ) ; }	put an unsigned byte into the specified bytebuffer at the current position.
public static int numofparameters ( string desc ) { int n = _num ; int i = _num ; for ( ; ; ) { char c = desc . charat ( i ) ; if ( c == _str ) break ; while ( c == _str ) c = desc . charat ( ++ i ) ; if ( c == _str ) { i = desc . indexof ( _str , i ) + _num ; if ( i <= _num ) throw new indexoutofboundsexception ( _str ) ; } else ++ i ; ++ n ; } return n ; }	returns the number of the prameters included in the given descriptor .
@ override public trie optimize ( trie orig ) { list < charsequence > cmds = orig . cmds ; list < row > rows = new arraylist < > ( ) ; list < row > orows = orig . rows ; int remap [ ] = new int [ orows . size ( ) ] ; for ( int j = orows . size ( ) - _num ; j >= _num ; j -- ) { row now = new remap ( orows . get ( j ) , remap ) ; boolean merged = _bool ; for ( int i = _num ; i < rows . size ( ) ; i ++ ) { row q = merge ( now , rows . get ( i ) ) ; if ( q != null ) { rows . set ( i , q ) ; merged = _bool ; remap [ j ] = i ; break ; } } if ( merged == _bool ) { remap [ j ] = rows . size ( ) ; rows . add ( now ) ; } } int root = remap [ orig . root ] ; arrays . fill ( remap , - _num ) ; rows = removegaps ( root , rows , new arraylist < row > ( ) , remap ) ; return new trie ( orig . forward , remap [ root ] , cmds , rows ) ; }	optimize ( remove empty rows ) from the given trie and return the resulting trie .
public boolean isalldenied ( ) { int count = _num ; for ( int i = _num ; i < mperms . size ( ) ; i ++ ) { if ( mperms . get ( muserpermission . get ( i ) ) == packagemanager . permission_denied ) count ++ ; } return count == mperms . size ( ) ; }	is all denied boolean .
public string tostringkey ( ) { string result ; int i ; result = _str + _str ; for ( i = _num ; i < getcolcount ( ) ; i ++ ) { if ( getcolhidden ( i ) ) continue ; result += _str + _str + ( i + _num ) + _str + _str + removefiltername ( m_colnames [ i ] ) + _str + _str ; } result += _str ; return result ; }	returns returns a key for all the col names , for better readability if the names got cut off .
private datetimeformatter toformatter ( locale locale , resolverstyle resolverstyle , chronology chrono ) { objects . requirenonnull ( locale , _str ) ; while ( active . parent != null ) { optionalend ( ) ; } compositeprinterparser pp = new compositeprinterparser ( printerparsers , _bool ) ; return new datetimeformatter ( pp , locale , decimalstyle . standard , resolverstyle , null , chrono , null ) ; }	completes this builder by creating the formatter .
protected void waitforexternalstoremount ( ) throws exception { string extstoragestate = environment . getexternalstoragestate ( ) ; int currentwaittime = _num ; while ( ! extstoragestate . equals ( environment . media_mounted ) ) { log . i ( log_tag , _str ) ; currentwaittime = timeoutwait ( currentwaittime , default_wait_poll_time , default_max_wait_time , _str ) ; extstoragestate = environment . getexternalstoragestate ( ) ; } }	synchronously waits for external store to be mounted ( eg : sd card ) .
public final void push ( node value ) { int ff = m_firstfree ; if ( ( ff + _num ) >= m_mapsize ) { if ( null == m_map ) { m_map = new node [ m_blocksize ] ; m_mapsize = m_blocksize ; } else { m_mapsize += m_blocksize ; node newmap [ ] = new node [ m_mapsize ] ; system . arraycopy ( m_map , _num , newmap , _num , ff + _num ) ; m_map = newmap ; } } m_map [ ff ] = value ; ff ++ ; m_firstfree = ff ; }	append a node onto the vector .
public boolean uploadandinstallapk ( @ notnull idevice device , @ notnull string packagename , @ notnull file localfile , @ notnull launchstatus launchstatus ) { if ( ! needsinstall ( device , localfile , packagename ) ) { return _bool ; } string remotepath = _str + packagename ; myprinter . stdout ( _str + localfile + _str + remotepath ) ; try { device . pushfile ( localfile . getpath ( ) , remotepath ) ; boolean installed = installapp ( device , remotepath , packagename , launchstatus ) ; if ( installed ) { myinstalledapkcache . setinstalled ( device , localfile , packagename ) ; } return installed ; } catch ( exception e ) { myprinter . stderr ( e . tostring ( ) ) ; return _bool ; } }	installs the given apk on the device .
public static bytearraylist readasbytes ( inputstream is ) throws ioexception { bytearraylist buf = new bytearraylist ( ) ; byte [ ] b = new byte [ _num ] ; int nread = - _num ; while ( ( nread = is . read ( b ) ) >= _num ) { buf . add ( b , _num , nread ) ; } return buf ; }	reads an input stream into a list of byte values .
public static int uninstallsilent ( context context , string packagename ) { return uninstallsilent ( context , packagename , _bool ) ; }	uninstall package and clear data of app silent by root.
public void open ( final long [ ] list , final int position ) { launchplayeractivity = _bool ; synchronized ( this ) { if ( mshufflemode == shuffle_auto ) { mshufflemode = shuffle_normal ; } final long oldid = getaudioid ( ) ; final int listlength = list . length ; boolean newlist = _bool ; if ( mplaylistlen == listlength ) { newlist = _bool ; for ( int i = _num ; i < listlength ; i ++ ) { if ( list [ i ] != mplaylist [ i ] ) { newlist = _bool ; break ; } } } if ( newlist ) { addtoplaylist ( list , - _num ) ; notifychange ( queue_changed ) ; } if ( position >= _num ) { mplaypos = position ; } else { mplaypos = mshuffler . nextint ( mplaylistlen ) ; } mhistory . clear ( ) ; opencurrentandnext ( ) ; if ( oldid != getaudioid ( ) ) { notifychange ( meta_changed ) ; } } }	opens a list for playback.
public builder names ( final string ... names ) { return names ( arrays . aslist ( names ) ) ; }	adds the provided user friendly names .
public void testnegativereversestepbyonewithclosure ( ) { final list calllog = new arraylist ( ) ; final closure closure = new recordingclosure ( calllog ) ; final range range = createrange ( _num , _num ) ; range . step ( - _num , closure ) ; assertequals ( _str , _num , calllog . size ( ) ) ; final iterator iter = calllog . iterator ( ) ; for ( int i = _num ; i <= _num ; i ++ ) { assertequals ( _str , createvalue ( i ) , iter . next ( ) ) ; } }	tests stepping backwards through a reversed range with a closure .
public static bigdecimal normalizedecimalvalue ( bigdecimal bigdecimal , int allowedprecision ) { if ( bigdecimal . precision ( ) > allowedprecision ) { return null ; } return bigdecimal ; }	this method will check the digits before dot with the max precision allowed.
protected static node deserializestring ( string doc ) { try { stringreader reader = new stringreader ( doc ) ; streamsource source = new streamsource ( reader ) ; domresult result = new domresult ( ) ; transformerfactory tf = transformerfactory . newinstance ( ) ; transformer transformer = tf . newtransformer ( ) ; transformer . setoutputproperty ( outputkeys . encoding , default_encoding ) ; transformer . setoutputproperty ( outputkeys . indent , default_indent ) ; transformer . transform ( source , result ) ; return result . getnode ( ) ; } catch ( throwable e ) { log . log ( level . severe , _str , e ) ; } return null ; }	this method deserializes the supplied document .
public static string append ( final charsequence url , final object ... params ) { final string baseurl = url . tostring ( ) ; if ( params == null || params . length == _num ) return baseurl ; if ( params . length % _num != _num ) throw new illegalargumentexception ( _str ) ; final stringbuilder result = new stringbuilder ( baseurl ) ; addpathseparator ( baseurl , result ) ; addparamprefix ( baseurl , result ) ; object value ; result . append ( params [ _num ] ) ; result . append ( _str ) ; value = params [ _num ] ; if ( value != null ) result . append ( value ) ; for ( int i = _num ; i < params . length ; i += _num ) { result . append ( _str ) ; result . append ( params [ i ] ) ; result . append ( _str ) ; value = params [ i + _num ] ; if ( value != null ) result . append ( value ) ; } return result . tostring ( ) ; }	append given name / value pairs as query parameters to the base url < p > the params argument is interpreted as a sequence of name / value pairs so the given number of params must be divisible by 2 .
public void sendeventtoagent ( final string event ) { synchronized ( eventsocket ) { eventwriter . print ( event ) ; eventwriter . flush ( ) ; } }	sends a message to the testrunneragent.
private void applyjmsobjects ( hashmap < string , string > filters ) { stringwriter writer = new stringwriter ( ) ; printwriter printwriter = new printwriter ( writer ) ; printwriter . println ( ) ; for ( string str : getqueuelist ( ) ) { printwriter . println ( _str + str + _str ) ; } for ( string str : gettopiclist ( ) ) { printwriter . println ( _str + str + _str ) ; } filters . put ( _str , writer . tostring ( ) ) ; }	it will create the jms configurations.
public void index ( iterator tuples , string field ) { while ( tuples . hasnext ( ) ) { tuple t = ( tuple ) tuples . next ( ) ; index ( t , field ) ; } }	indexes the data values for the given field name for each tuple in the provided iterator.
public final static void closeel ( final outputstream os ) { try { if ( os != null ) os . close ( ) ; } catch ( final throwable e ) { } }	close outputstream without a exception.
public void addsearchlistener ( searchlistener l ) { m_searchlisteners . add ( l ) ; }	adds the specified listener to the internal list of listeners .
public boolean issingleattributecontainer ( ) { return _bool ; }	returns false for the idpplegalidentity container .
public cachespan touch ( ) { long now = system . currenttimemillis ( ) ; file newcachefile = getcachefilename ( file . getparentfile ( ) , key , position , now ) ; file . renameto ( newcachefile ) ; return cachespan . createcacheentry ( key , position , now , newcachefile ) ; }	renames the file underlying this cache span to update its last access time .
public void open ( file file ) throws ioexception { checkawtpermission ( ) ; checkexec ( ) ; checkactionsupport ( action . open ) ; checkfilevalidation ( file ) ; peer . open ( file ) ; }	launches the associated application to open the file.
@ override public void toggleselection ( t photo ) { if ( selectedphotos . contains ( photo ) ) { selectedphotos . remove ( photo ) ; } else { selectedphotos . add ( photo ) ; } }	toggle the selection status of the item at a given position.
protected void pretick ( ) { }	fired when the scheduler begins to tick , before any tasks are processed .
public byte map ( byte src ) { char c = map ( ( char ) src ) ; if ( c < byte . min_value || c > byte . max_value ) { return _num ; } return ( byte ) c ; }	cannot map from a byte.
public object produceevent ( ) throws invocationtargetexception { if ( ! valid ) { throw new illegalstateexception ( tostring ( ) + _str ) ; } try { return method . invoke ( target ) ; } catch ( illegalaccessexception e ) { throw new assertionerror ( e ) ; } catch ( invocationtargetexception e ) { if ( e . getcause ( ) instanceof error ) { throw ( error ) e . getcause ( ) ; } throw e ; } }	invokes the wrapped producer method .
public string wrapifkeywordorbuiltin ( string name ) { if ( keyword_built_in_set . contains ( name ) ) { return name + _str ; } return name ; }	return a non - conflicting safe name if name is a ruby built - in .
public issuematcher add ( ) { issuematcher issuematcher = new issuematcher ( ) ; issuematchers . add ( issuematcher ) ; return issuematcher ; }	creates a new issue matcher and adds it to this matcher .
private < t > injectscope < t > findscope ( annotatedelement annelement ) { for ( annotation ann : annelement . getannotations ( ) ) { class < ? extends annotation > anntype = ann . annotationtype ( ) ; if ( anntype . isannotationpresent ( scope . class ) ) { supplier < injectscope < t > > scopegen = ( supplier ) _scopemap . get ( anntype ) ; if ( scopegen != null ) { return scopegen . get ( ) ; } else { log . fine ( l . l ( _str , anntype . getsimplename ( ) ) ) ; } } } return new injectscopefactory < > ( ) ; }	finds the scope for a bean producing declaration , either a method or a type .
private static native int [ ] regopenkey ( int hkey , byte [ ] subkey , int securitymask ) ;	java wrapper for windows registry api regopenkey ( ).
public void removepropertychangelistener ( ipropertychangelistener listener ) { listeners . remove ( listener ) ; }	remove the provided listener from the receiver .
@ override public int previous ( ) { characteriterator text = gettext ( ) ; if ( current ( ) == text . getbeginindex ( ) ) { return breakiterator . done ; } int start = current ( ) ; int lastresult = cachedlastknownbreak ; if ( lastresult >= start || lastresult <= breakiterator . done ) { getprevious ( ) ; lastresult = handleprevious ( ) ; } else { text . setindex ( lastresult ) ; } int result = lastresult ; while ( result != breakiterator . done && result < start ) { lastresult = result ; result = handlenext ( ) ; } text . setindex ( lastresult ) ; cachedlastknownbreak = lastresult ; return lastresult ; }	advances the iterator backwards , to the last boundary preceding this one .
public deferredimagereplacedelement ( imageresource imageresource , repaintlistener repaintlistener , int w , int h ) { this . _imageresource = imageresource ; _loaded = _bool ; this . repaintlistener = repaintlistener ; if ( w == - _num && h == - _num ) { _doscaleimage = _bool ; _targetheight = _num ; _targetwidth = _num ; } else { _doscaleimage = _bool ; _targetheight = math . max ( _num , h ) ; _targetwidth = math . max ( _num , w ) ; } _image = imageutil . createcompatiblebufferedimage ( _targetwidth , _targetheight ) ; }	creates a new imagereplacedelement and scales it to the size specified if either width or height has a valid value ( values are > - 1 ) , otherwise original size is preserved.
public boolean startswith ( name n ) { if ( n instanceof compoundname ) { return ( impl . startswith ( n . size ( ) , n . getall ( ) ) ) ; } else { return _bool ; } }	determines whether a compound name is a prefix of this compound name.
public void testinvokeall5 ( ) throws throwable { executorservice e = new forkjoinpool ( _num ) ; poolcleaner cleaner = null ; try { cleaner = cleaner ( e ) ; list < callable < string > > l = new arraylist < callable < string > > ( ) ; l . add ( new stringtask ( ) ) ; l . add ( new stringtask ( ) ) ; list < future < string > > futures = e . invokeall ( l ) ; assertequals ( _num , futures . size ( ) ) ; for ( future < string > future : futures ) assertsame ( test_string , future . get ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }	invokeall ( c ) returns results of all completed tasks in c.
public internallistener ( final configmanager configfile ) { this . configfile = configfile ; }	creates a new listener object .
public byte [ ] sign ( byte [ ] hash ) { ecdsasigner signer = new ecdsasigner ( new hmacdsakcalculator ( new sha256digest ( ) ) ) ; signer . init ( _bool , new ecprivatekeyparameters ( priv , domain ) ) ; biginteger [ ] signature = signer . generatesignature ( hash ) ; bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; try { dersequencegenerator seq = new dersequencegenerator ( baos ) ; seq . addobject ( new asn1integer ( signature [ _num ] ) ) ; seq . addobject ( new asn1integer ( tocanonicals ( signature [ _num ] ) ) ) ; seq . close ( ) ; return baos . tobytearray ( ) ; } catch ( ioexception e ) { } return null ; }	sign a digest with this key .
public timeperiod ( date starttime , date endtime ) { if ( starttime != null && endtime != null && ! endtime . after ( starttime ) ) { throw new illegalargumentexception ( _str + endtime + _str + starttime ) ; } this . starttime = starttime ; this . endtime = endtime ; }	creates time interval [ starttime , endtime ) if times are not null.
jmenu createeditmenu ( ) { jmenu editmenu = new jmenu ( _str ) ; editmenu . add ( actionmanager . getcutaction ( ) ) ; editmenu . add ( actionmanager . getcopyaction ( ) ) ; editmenu . add ( actionmanager . getpasteaction ( ) ) ; editmenu . add ( actionmanager . getdeleteaction ( ) ) ; editmenu . addseparator ( ) ; editmenu . add ( actionmanager . getclearsourceneuronsaction ( ) ) ; editmenu . add ( actionmanager . getsetsourceneuronsaction ( ) ) ; editmenu . add ( actionmanager . getconnectionmenu ( ) ) ; editmenu . add ( actionmanager . getaddsynapsegroupaction ( ) ) ; editmenu . addseparator ( ) ; editmenu . add ( actionmanager . getrandomizeobjectsaction ( ) ) ; editmenu . add ( actionmanager . getshowadjustsynapsesdialog ( ) ) ; editmenu . addseparator ( ) ; editmenu . add ( actionmanager . getlayoutmenu ( ) ) ; editmenu . add ( actionmanager . getgroupmenu ( ) ) ; editmenu . addseparator ( ) ; editmenu . add ( createalignmenu ( ) ) ; editmenu . add ( createspacingmenu ( ) ) ; editmenu . addseparator ( ) ; editmenu . add ( actionmanager . getsetneuronpropertiesaction ( ) ) ; editmenu . add ( actionmanager . getsetsynapsepropertiesaction ( ) ) ; editmenu . addseparator ( ) ; editmenu . add ( createselectionmenu ( ) ) ; return editmenu ; }	create and return a new edit menu for this network panel .
public void removehistorychangedlistener ( historychangedlistener l ) { m_historychangedlisteners . remove ( l ) ; }	removes the given listener from the list of listeners .
public void currentstate ( long state , model currentmodel ) { currentstate = state ; if ( loggers != null ) { for ( logger logger : loggers ) { logger . log ( state ) ; } } }	called to update the current model keepevery states .
public boolean isbom ( ) { return m_isbom ; }	is it a bom.
public boolean issigned ( ) { return signed ; }	returns whether the object is signed or not .
public object parsetext ( string text ) { if ( text == null || text . length ( ) == _num ) { throw new illegalargumentexception ( _str ) ; } return parse ( new linecolumnreader ( new stringreader ( text ) ) ) ; }	parse a text representation of a json data structure.
public int size ( ) { return parts . size ( ) ; }	the number of parts in this multipart body .
protected < t > database makesimpledatabase ( string filename , int expectedsize , listparameterization params , class < ? > [ ] filters ) { try ( inputstream is = open ( filename ) ) { list < objectfilter > filterlist = new arraylist < > ( ) ; filterlist . add ( new fixeddbidsfilter ( _num ) ) ; if ( filters != null ) { for ( class < ? > filtercls : filters ) { objectfilter filter = classgenericsutil . parameterizeorabort ( filtercls , params ) ; filterlist . add ( filter ) ; } } numbervectorlabelparser < doublevector > parser = new numbervectorlabelparser < > ( doublevector . factory ) ; inputstreamdatabaseconnection dbc = new inputstreamdatabaseconnection ( is , filterlist , parser ) ; params . addparameter ( abstractdatabase . parameterizer . database_connection_id , dbc ) ; database db = classgenericsutil . parameterizeorabort ( staticarraydatabase . class , params ) ; testparameterizationok ( params ) ; db . initialize ( ) ; relation < ? > rel = db . getrelation ( typeutil . any ) ; assertequals ( _str , expectedsize , rel . size ( ) ) ; return db ; } catch ( ioexception e ) { fail ( _str + filename + _str ) ; return null ; } }	generate a simple doublevector database from a file .
protected void addchooserfilters ( jfilechooser chooser ) { javax . swing . filechooser . filenameextensionfilter filter ; chooser . addchoosablefilefilter ( filter = new javax . swing . filechooser . filenameextensionfilter ( _str , _str ) ) ; chooser . setfilefilter ( filter ) ; }	add filter ( s ) for possible types to the input file chooser .
public void onstop ( ) { if ( null != mservice ) { if ( null != mcontext ) { mcontext . unbindservice ( mserviceconnection ) ; } mserviceconnection = null ; mservice = null ; } }	unbinds the in - app billing service .
public string peek ( ) { string result = null ; if ( isempty ( ) ) { return null ; } else { int cachedcurrentindex = currentindex ; if ( iseatingblocksofdelimiters ) { trimstartingdelimiters ( ) ; } int nearestdelimeter = - _num ; for ( int i = _num ; i < delimiters . length ( ) ; i ++ ) { int delimiter = source . indexof ( delimiters . charat ( i ) , currentindex ) ; if ( nearestdelimeter == - _num || delimiter != - _num && delimiter < nearestdelimeter ) { nearestdelimeter = delimiter ; } } if ( nearestdelimeter == - _num ) { result = source . substring ( currentindex ) ; } else { result = source . substring ( currentindex , nearestdelimeter ) ; } currentindex = cachedcurrentindex ; } return result ; }	returns null if there is nothing left .
private void eliminarusuariosorgano ( gestionorganizacionbi organizacionbi , organizacionvo organizacionvo ) { organizacionbi . eliminarusuariosorgano ( organizacionvo . getid ( ) ) ; }	metodo encargado de borrar todos los usuarios asociados a un determinado organo , siempre y cuando este organo se encuentre en estado vigente .
private static void addpreviouslayer ( list < list < neuron > > layers , list < neuron > sourcelayer , list < neuron > layertocheck ) { final int maxlayers = _num ; set < neuron > newlayertemp = new hashset < neuron > ( ) ; boolean thenextlayeristhesourcelayer = _bool ; for ( neuron neuron : layertocheck ) { for ( synapse synapse : neuron . getfanin ( ) ) { neuron sourceneuron = synapse . getsource ( ) ; if ( sourcelayer . contains ( sourceneuron ) ) { thenextlayeristhesourcelayer = _bool ; } if ( sourceneuron == neuron ) { continue ; } newlayertemp . add ( synapse . getsource ( ) ) ; } } if ( ( thenextlayeristhesourcelayer ) || ( newlayertemp . size ( ) == _num ) || ( layers . size ( ) > maxlayers ) ) { layers . add ( sourcelayer ) ; } else { list < neuron > newlayer = new arraylist < neuron > ( newlayertemp ) ; collections . sort ( newlayer , orientationcomparator . x_order ) ; layers . add ( newlayer ) ; addpreviouslayer ( layers , sourcelayer , newlayer ) ; } }	helper method for getintermedatelayers.
public void testshiftright2 ( ) { byte abytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = _num ; int number = - _num ; byte rbytes [ ] = { _num , _num , - _num , _num , - _num , - _num , - _num , _num , - _num , _num , - _num , _num , - _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . shiftright ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	shiftright ( int n ) , n < 0.
public static void ignorm ( double c1 [ ] , double c2 [ ] , int m , double ng ) { if ( ng != _num ) { double k = math . pow ( c1 [ _num ] , ng ) ; for ( int i = m ; i >= _num ; i -- ) c2 [ i ] = k * c1 [ i ] ; c2 [ _num ] = ( k - _num ) / ng ; } else { system . arraycopy ( c1 , _num , c2 , _num , m - _num ) ; c2 [ _num ] = math . log ( c1 [ _num ] ) ; } }	ignorm : inverse gain normalization.
public static int findnonwhitespacecharacter ( string s , int index ) { int slength = s . length ( ) ; while ( index < slength && character . iswhitespace ( s . charat ( index ) ) ) { index ++ ; } return index ; }	finds the first non - whitespace character starting at index .
public void readcontent ( ) throws ioexception { if ( offset + length > buffer . length ) { throw new asn1exception ( _str ) ; } if ( in == null ) { offset += length ; } else { int bytesread = in . read ( buffer , offset , length ) ; if ( bytesread != length ) { int c = bytesread ; do { if ( c < _num || bytesread > length ) { throw new asn1exception ( _str ) ; } c = in . read ( buffer , offset + bytesread , length - bytesread ) ; bytesread += c ; } while ( bytesread != length ) ; } offset += length ; } }	reads the next encoded content from the encoded input stream.
public primitive ( object value ) { this . value = value ; type = ( value != null ) ? utilities . getprimitivetype ( value . getclass ( ) ) : null ; if ( type == null ) { throw new illegalargumentexception ( _str + value ) ; } }	creates an object that represents a primitive value of the type associated with the specified primitive wrapper object .
public void createcashbasedjournalentriesandreversalsforsavingstax ( final office office , final string currencycode , final cash_accounts_for_savings accounttypetobedebited , final cash_accounts_for_savings accounttypetobecredited , final long savingsproductid , final long paymenttypeid , final long savingsid , final string transactionid , final date transactiondate , final bigdecimal amount , final boolean isreversal , final list < taxpaymentdto > taxdetails ) { for ( taxpaymentdto taxpaymentdto : taxdetails ) { if ( taxpaymentdto . getamount ( ) != null ) { if ( taxpaymentdto . getcreditaccountid ( ) == null ) { createcashbasedcreditjournalentriesandreversalsforsavings ( office , currencycode , accounttypetobecredited . getvalue ( ) , savingsproductid , paymenttypeid , savingsid , transactionid , transactiondate , taxpaymentdto . getamount ( ) , isreversal ) ; } else { createcashbasedcreditjournalentriesandreversalsforsavings ( office , currencycode , taxpaymentdto . getcreditaccountid ( ) , savingsid , transactionid , transactiondate , taxpaymentdto . getamount ( ) , isreversal ) ; } } } createcashbaseddebitjournalentriesandreversalsforsavings ( office , currencycode , accounttypetobedebited . getvalue ( ) , savingsproductid , paymenttypeid , savingsid , transactionid , transactiondate , amount , isreversal ) ; }	convenience method that creates a pair of related debits and credits for cash based accounting . the target accounts for debits and credits are switched in case of a reversal.
public int read ( bytebuf dst , int dststart , int dstlength ) throws ioexception { final int remaining = ( int ) math . min ( this . length - this . position , integer . max_value ) ; final int read = math . min ( remaining , dstlength ) ; final int bufferposition = checkoffset ( position , read ) ; final long srcaddress = platformdependent . directbufferaddress ( lastmapped ) + bufferposition ; if ( dst . hasmemoryaddress ( ) ) { final long dstaddress = dst . memoryaddress ( ) + dststart ; platformdependent . copymemory ( srcaddress , dstaddress , read ) ; } else if ( dst . hasarray ( ) ) { final byte [ ] dstarray = dst . array ( ) ; platformdependent . copymemory ( srcaddress , dstarray , dststart , read ) ; } else { throw new illegalargumentexception ( _str ) ; } position += read ; return read ; }	reads a sequence of bytes from this file into the given buffer.
public static calendar cleartime ( final calendar self ) { cleartimecommon ( self ) ; return self ; }	clears the time portion of this calendar instance ; useful utility where it makes sense to compare month / day / year only portions of a calendar .
public double pdf ( int k ) { return math . exp ( k * math . log ( this . mean ) - arithmetic . logfactorial ( k ) - this . mean ) ; }	returns the probability distribution function .
public static void appendunpaddedinteger ( stringbuffer buf , long value ) { int intvalue = ( int ) value ; if ( intvalue == value ) { appendunpaddedinteger ( buf , intvalue ) ; } else { buf . append ( long . tostring ( value ) ) ; } }	converts an integer to a string , and appends it to the given buffer.
private void drawtextelements ( canvas canvas , float textsize , typeface typeface , colorstatelist textcolor , string [ ] texts , float [ ] textx , float [ ] texty , paint paint , int alpha , boolean showactivated , int activateddegrees , boolean activatedonly ) { paint . settextsize ( textsize ) ; paint . settypeface ( typeface ) ; final float activatedindex = activateddegrees / ( _num / num_positions ) ; final int activatedfloor = ( int ) activatedindex ; final int activatedceil = ( ( int ) math . ceil ( activatedindex ) ) % num_positions ; for ( int i = _num ; i < _num ; i ++ ) { final boolean activated = ( activatedfloor == i || activatedceil == i ) ; if ( activatedonly && ! activated ) { continue ; } final int [ ] statemask = new int [ ] { android . r . attr . state_enabled , ( showactivated && activated ? android . r . attr . state_selected : _num ) } ; final int color = textcolor . getcolorforstate ( statemask , _num ) ; paint . setcolor ( color ) ; paint . setalpha ( getmultipliedalpha ( color , alpha ) ) ; canvas . drawtext ( texts [ i ] , textx [ i ] , texty [ i ] , paint ) ; } }	draw the 12 text values at the positions specified by the textgrid parameters .
public void testfindspringactivedirectorywithlimit ( ) { ldapproxy proxy = getldapad ( ) ; list result = null ; int limit = _num ; try { result = proxy . find ( getldapsearchvo ( _str , limit , _str , _str , null , ldapscopeconstants . scope_subtree ) ) ; } catch ( exception e ) { } assertnotnull ( result ) ; if ( result != null ) { assertequals ( limit , result . size ( ) ) ; } }	test de busqueda active directory con limite.
@ override public void handlekey ( int virtualkeycode , int transitionstate , char keychar ) { switchcontrolkeys ( virtualkeycode , transitionstate ) ; inputbuffer . add ( new globalkeyevent ( this , virtualkeycode , transitionstate , keychar , menupressed , shiftpressed , controlpressed , extendedkey ) ) ; }	handle the input virtualkeycode and transitionstate , create event and add it to the inputbuffer.
public int hashcode ( ) { return alignment ^ leader ^ math . round ( position ) ; }	returns the hashcode for the object.
public static string stripleadingperiod ( string s ) { if ( null != s && s . startswith ( _str ) ) return s . substring ( math . min ( _num , s . length ( ) ) , s . length ( ) ) ; return s ; }	strips leading period from a string ( example : input - > " . ext " , output - > " ext " ).
public static boolean isrequiredconfigdirectory ( final string directory ) { return requiredconfigdirectories . contains ( directory ) ; }	check if the passed in directory is required to be present in the configuration data set .
private void cleanuplabels ( ) { int id = _num ; for ( iterator < label > i = labels . iterator ( ) ; i . hasnext ( ) ; ) { label label = i . next ( ) ; if ( label . isempty ( ) ) { i . remove ( ) ; } else { label . compact ( ) ; label . id = id ++ ; } } }	removes empty labels and assigns ids to non - empty labels .
void zrot ( double theta ) { theta *= ( pi / _num ) ; double ct = math . cos ( theta ) ; double st = math . sin ( theta ) ; float nyx = ( float ) ( yx * ct + xx * st ) ; float nyy = ( float ) ( yy * ct + xy * st ) ; float nyz = ( float ) ( yz * ct + xz * st ) ; float nyo = ( float ) ( yo * ct + xo * st ) ; float nxx = ( float ) ( xx * ct - yx * st ) ; float nxy = ( float ) ( xy * ct - yy * st ) ; float nxz = ( float ) ( xz * ct - yz * st ) ; float nxo = ( float ) ( xo * ct - yo * st ) ; yo = nyo ; yx = nyx ; yy = nyy ; yz = nyz ; xo = nxo ; xx = nxx ; xy = nxy ; xz = nxz ; }	rotate theta degrees about the z axis.
public static long nanosfromdate ( long ms ) { calendar cal = getcalendar ( ) ; cal . settimeinmillis ( ms ) ; return nanosfromcalendar ( cal ) ; }	convert a time in milliseconds in utc to the nanoseconds since midnight ( in the default timezone ) .
@ override default completablefuture < optionallong > maxlong ( final tolongfunction < ? super t > fn ) { return completablefuture . supplyasync ( null , getexec ( ) ) ; }	perform an asynchronous max operation.
protected balancedwebresource createhttpsclient ( final string username , final string password , list < string > hosts ) throws nosuchalgorithmexception { return createhttpsclient ( username , password , hosts , _bool ) ; }	create the httpsclient , returns a balancedwebresource that can be used the same way a webresource is .
public static char [ ] createarraysignature ( char [ ] typesignature , int arraycount ) { if ( arraycount == _num ) return typesignature ; int siglength = typesignature . length ; char [ ] result = new char [ arraycount + siglength ] ; for ( int i = _num ; i < arraycount ; i ++ ) { result [ i ] = c_array ; } system . arraycopy ( typesignature , _num , result , arraycount , siglength ) ; return result ; }	creates a new type signature with the given amount of array nesting added to the given type signature .
public void println ( ) throws ioexception { writer . write ( format . getlineseparator ( ) ) ; }	writes the new line text to the underlying writer.
protected void increasebuffersize ( int minsize ) { int newlength = buf . length ; while ( newlength < minsize ) newlength *= _num ; double [ ] newbuf = new double [ newlength ] ; int avail = currentlyinbuffer ( ) ; system . arraycopy ( buf , readpos , newbuf , _num , avail ) ; buf = newbuf ; readpos = _num ; writepos = avail ; }	increase the underlying buffer array in size , so that the new size is at least minsize.
private void handleenumeratedattribute ( instances traininstances ) throws exception { instance instance ; m_distribution = new distribution ( m_complexityindex , traininstances . numclasses ( ) ) ; enumeration < instance > enu = traininstances . enumerateinstances ( ) ; while ( enu . hasmoreelements ( ) ) { instance = enu . nextelement ( ) ; if ( ! instance . ismissing ( m_attindex ) ) { m_distribution . add ( ( int ) instance . value ( m_attindex ) , instance ) ; } } if ( m_distribution . check ( m_minnoobj ) ) { m_numsubsets = m_complexityindex ; m_infogain = infogaincrit . splitcritvalue ( m_distribution , m_sumofweights ) ; m_gainratio = gainratiocrit . splitcritvalue ( m_distribution , m_sumofweights , m_infogain ) ; } }	creates split on enumerated attribute .
private boolean isloadmore ( ) { return mnextloadenable && pagesize != - _num && mrequestloadmorelistener != null && mdata . size ( ) >= pagesize ; }	determine whether it is loaded more.
private void addworkerifnecessary ( ) { if ( idleworkers . get ( ) == _num ) { synchronized ( workers ) { if ( workers . isempty ( ) || ( idleworkers . get ( ) == _num ) ) { addworker ( ) ; } } } }	add a new worker only if there are no idle worker .
@ override protected node removefromfrontier ( ) { node result = frontier . remove ( ) ; frontiernodelookup . remove ( result . getstate ( ) ) ; explored . add ( result . getstate ( ) ) ; updatemetrics ( frontier . size ( ) ) ; return result ; }	removes the node at the head of the frontier , adds the corresponding state to the explored set , and returns the node .
public static font createbitmapfont ( string name , image bitmap , int [ ] cutoffsets , int [ ] charwidth , string charsets ) { font f = createbitmapfont ( bitmap , cutoffsets , charwidth , charsets ) ; bitmapcache . put ( name , f ) ; return f ; }	creates a bitmap font with the given arguments and places said font in the cache.
static boolean istenured ( memorypoolmxbean memorypoolmxbean ) { if ( memorypoolmxbean . gettype ( ) != memorytype . heap ) { return _bool ; } string name = memorypoolmxbean . getname ( ) ; return name . equals ( _str ) || name . equals ( _str ) || name . equals ( _str ) || name . equals ( _str ) || name . equals ( _str ) || name . equals ( _str ) || name . equals ( _str ) || ( heap_pool != null && name . equals ( heap_pool ) ) ; }	determines if the name of the memory pool mxbean provided matches a list of known tenured pool names.
public string tosimplestring ( ) { stringbuffer buffer = new stringbuffer ( ) ; buffer . append ( _str + ( mlabel == null ? _str : mlabel ) + _str + myvals . size ( ) + _str ) ; return buffer . tostring ( ) ; }	returns a simple string representation of the dataset with the type and the number of entries .
public static < t > t interpreteronly ( callable < t > callable ) throws exception { return callable . call ( ) ; }	directive for the compiler that the given callable should only be executed in the interpreter .
private void addselectorforprotocol ( properties settings , string protocol , protocoldispatchselector ps ) { string proxy = settings . getproperty ( protocol ) ; if ( proxy != null ) { fixedproxyselector protocolselector = proxyutil . parseproxysettings ( proxy ) ; ps . setselector ( protocol , protocolselector ) ; } }	creates a selector for a given protocol.
public void addheader ( string name , string value ) { header . put ( name , value ) ; }	adds given line to the header .
public static void readskel ( bufferedreader reader ) throws ioexception { list < string > lines = new arraylist < string > ( ) ; stringbuilder section = new stringbuilder ( ) ; string ln ; while ( ( ln = reader . readline ( ) ) != null ) { if ( ln . startswith ( _str ) ) { lines . add ( section . tostring ( ) ) ; section . setlength ( _num ) ; } else { section . append ( ln ) ; section . append ( nl ) ; } } if ( section . length ( ) > _num ) lines . add ( section . tostring ( ) ) ; if ( lines . size ( ) != size ) { out . error ( errormessages . wrong_skeleton ) ; throw new generatorexception ( ) ; } line = new string [ size ] ; for ( int i = _num ; i < size ; i ++ ) line [ i ] = lines . get ( i ) ; }	reads an external skeleton file from a bufferedreader .
public static set < string > nonmonogamoussamples ( collection < family > families ) { final linkedhashset < string > ret = new linkedhashset < > ( ) ; final hashset < string > parents = new hashset < > ( ) ; for ( family f : families ) { if ( ! parents . add ( f . getfather ( ) ) ) { ret . add ( f . getfather ( ) ) ; } if ( ! parents . add ( f . getmother ( ) ) ) { ret . add ( f . getmother ( ) ) ; } } return ret ; }	detects the presence of genetic non - monogamy within an set of families.
private void createscenevao ( ) { int vao = glgenvertexarrays ( ) ; int vbo = glgenbuffers ( ) ; glbindvertexarray ( vao ) ; glbindbuffer ( gl_array_buffer , vbo ) ; bytebuffer bb = bufferutils . createbytebuffer ( boxes . length * _num * ( _num + _num ) * _num * _num ) ; floatbuffer fv = bb . asfloatbuffer ( ) ; for ( int i = _num ; i < boxes . length ; i += _num ) { demoutils . triangulatebox ( boxes [ i ] , boxes [ i + _num ] , fv ) ; } glbufferdata ( gl_array_buffer , bb , gl_static_draw ) ; glenablevertexattribarray ( _num ) ; glvertexattribpointer ( _num , _num , gl_float , _bool , _num * ( _num + _num ) , _num ) ; glenablevertexattribarray ( _num ) ; glvertexattribpointer ( _num , _num , gl_float , _bool , _num * ( _num + _num ) , _num * _num ) ; glbindbuffer ( gl_array_buffer , _num ) ; glbindvertexarray ( _num ) ; this . vaoscene = vao ; }	creates a vao for the scene .
public boolean contains ( file file , string filecontent ) { if ( exists ( file ) ) { string content = readfilecontent ( file ) ; return content != null && content . equals ( filecontent ) ; } return _bool ; }	returns boolean indicating whether this file contains the content value .
public static boolean [ ] [ ] loadimage ( file file , char offchar ) throws filenotfoundexception , runtimeexception { arraylist < string > rows = loadimagepad ( file , offchar ) ; string s = rows . get ( _num ) ; boolean [ ] [ ] img = new boolean [ rows . size ( ) ] [ s . length ( ) ] ; for ( int i = _num ; i < rows . size ( ) ; i ++ ) { s = rows . get ( i ) ; for ( int j = _num ; j < s . length ( ) ; j ++ ) { char c = s . charat ( j ) ; if ( c == offchar ) { img [ i ] [ j ] = _bool ; } else { img [ i ] [ j ] = _bool ; } } } return img ; }	load up an image from the given file , where only the off character is known.
protected void updatereceiptstatuswhencancelled ( final string receiptnumber ) { final list < egdmcollectedreceipt > egdmcollectedreceipts = demandgenericdao . getallegdmcollectedreceipts ( receiptnumber ) ; if ( egdmcollectedreceipts != null && ! egdmcollectedreceipts . isempty ( ) ) for ( final egdmcollectedreceipt egdmcollectedreceipt : egdmcollectedreceipts ) { egdmcollectedreceipt . setstatus ( demandconstants . cancelled_receipt ) ; egdmcollectedreceipt . setupdatedtime ( new date ( ) ) ; egdmcollectedreceiptdao . update ( egdmcollectedreceipt ) ; } }	when receipt is cancelled the status of the receipt in egdmcollectedreceipts is updated as cancelled .
public void addanimation ( int id , animation ... animations ) { if ( manimations . get ( id ) == null ) { manimations . put ( id , new arraylist < animation > ( animations . length ) ) ; if ( id != animation . full_page ) { manimatedviews . add ( id ) ; } } arraylist < animation > anims = manimations . get ( id ) ; collections . addall ( anims , animations ) ; }	add animations to the target view.
private void cleanupdiscovery ( storagesystem system ) { try { system . setreachablestatus ( _bool ) ; _dbclient . persistobject ( system ) ; } catch ( databaseexception e ) { _logger . error ( _str , e ) ; } }	if discovery fails , then mark the system as unreachable.
@ override protected void initialize ( ) { list < string > words ; super . initialize ( ) ; m_words = new hashset < string > ( ) ; words = read ( ) ; for ( string word : words ) { if ( ! word . startswith ( _str ) ) m_words . add ( word ) ; } }	performs intialization of the scheme .
protected boolean existsinrange ( string x , int minlength , int maxlength ) { x = stringutils . trimtonull ( x ) ; return x != null && x . length ( ) >= minlength && x . length ( ) <= maxlength ; }	checks if string has a length in a certain range .
public synchronized void unwatch ( string pathname ) throws ioexception { unregisterall ( paths . get ( pathname ) ) ; }	recursively listen for file system events in the specified path name .
public criteria addproperty ( string name , string value , operator operator ) { properties . add ( new propertycriteria ( name , value , operator ) ) ; return this ; }	this method adds a new property criteria .
public void removecolumn ( final string columnname ) { if ( columnname == null ) { return ; } final list < string > cols = arrays . aslist ( getinfo ( ) . headers ) ; final int colindex = cols . indexof ( columnname ) ; removecolumn ( colindex ) ; }	remove the column represented by its name.
public static unmanagedprotectionset checkunmanagedprotectionsetexistsindb ( dbclient dbclient , string nativeguid ) throws ioexception { list < unmanagedprotectionset > cgs = customqueryutility . getunmanagedprotectionsetbynativeguid ( dbclient , nativeguid ) ; iterator < unmanagedprotectionset > cgsitr = cgs . iterator ( ) ; if ( cgsitr . hasnext ( ) ) { return cgsitr . next ( ) ; } return null ; }	check unmanaged protection set exists in db.
public static void putstring2bytes ( byte [ ] destbytes , string srcstring , int destoffset , int srcoffset , int count ) { for ( int i = _num ; i < count ; i ++ ) { destbytes [ count + i ] = srcstring . getbytes ( ) [ i ] ; } }	put string to byte [ ].
private void checkquery ( string expres , string qry ) throws exception { assertequals ( _num , executehivequery ( _str ) ) ; assertequals ( _num , executehivequery ( _str + _str + _str + _str + qry ) ) ; igfsinputstream in = igfs . open ( new igfspath ( _str ) ) ; byte [ ] buf = new byte [ ( int ) in . length ( ) ] ; in . read ( buf ) ; assertequals ( expres , new string ( buf ) ) ; }	runs query check result .
public final v updateandget ( unaryoperator < v > updatefunction ) { v prev , next ; do { prev = get ( ) ; next = updatefunction . apply ( prev ) ; } while ( ! compareandset ( prev , next ) ) ; return next ; }	atomically updates the current value with the results of applying the given function , returning the updated value.
public void close ( ) { stoptimers ( ) ; closed = _bool ; window . dispose ( ) ; if ( listener != null ) { listener . notificationremoved ( this ) ; } if ( activitylistener != null ) { activitytracker . removeactivitylistener ( activitylistener ) ; } }	close the window immediately and cleanup .
protected boolean shouldmove ( final iloadbalancerservice loadbalancerservice ) { if ( loadbalancerservice == null ) throw new illegalargumentexception ( ) ; final boolean highlyutilizedservice ; try { final uuid serviceuuid = resourcemanager . getdataserviceuuid ( ) ; highlyutilizedservice = loadbalancerservice . ishighlyutilizeddataservice ( serviceuuid ) ; } catch ( exception ex ) { log . warn ( _str ) ; return _bool ; } if ( ! highlyutilizedservice ) { if ( log . isinfoenabled ( ) ) log . info ( _str ) ; return _bool ; } final resourcescores resourcescores = resourcemanager . getresourcescores ( ) ; final boolean shouldmove = ( resourcescores . percentcputime >= resourcemanager . movepercentcputimethreshold ) || ( resourcescores . majorpagefaultspersec > _num ) || ( resourcescores . datadirbytesfree < bytes . gigabyte * _num ) || ( resourcescores . datadirbytesfree < bytes . gigabyte * _num ) ; return shouldmove ; }	figure out if this data service is considered to be highly utilized , in which case the ds should shed some index partitions.
private static object [ ] convertthrowablemessages ( final object [ ] args ) { if ( args != null ) { for ( int i = _num ; i < args . length ; i ++ ) { if ( args [ i ] instanceof throwable ) { throwable t = ( throwable ) args [ i ] ; if ( t . getmessage ( ) != null ) { args [ i ] = t . getmessage ( ) ; } } } } return args ; }	converts all throwable arguments to its message if the message is not null.
public rafdirectory ( path path , lockfactory lockfactory ) throws ioexception { super ( path , lockfactory ) ; path . tofile ( ) ; }	create a new rafdirectory for the named location.
public static void addminutestolist ( context context , arraylist < integer > values , arraylist < string > labels , int minutes ) { int index = values . indexof ( minutes ) ; if ( index != - _num ) { return ; } string label = constructreminderlabel ( context , minutes , _bool ) ; int len = values . size ( ) ; for ( int i = _num ; i < len ; i ++ ) { if ( minutes < values . get ( i ) ) { values . add ( i , minutes ) ; labels . add ( i , label ) ; return ; } } values . add ( minutes ) ; labels . add ( len , label ) ; }	if " minutes " is not currently present in " values " , we add an appropriate new entry to values and labels .
void recomposevariables ( elemvariable elemvar ) { if ( getvariableorparamcomposed ( elemvar . getname ( ) ) == null ) { elemvar . setistoplevel ( _bool ) ; elemvar . setindex ( m_variables . size ( ) ) ; m_variables . addelement ( elemvar ) ; } }	recompose the top level variable and parameter declarations .
public void propertychange ( propertychangeevent e ) { string propertyname = e . getpropertyname ( ) ; if ( propertyname == _str ) { if ( e . getoldvalue ( ) == boolean . false && e . getnewvalue ( ) == boolean . true ) { handlepopupisvisibleevent ( _bool ) ; } else if ( e . getoldvalue ( ) == boolean . true && e . getnewvalue ( ) == boolean . false ) { handlepopupisvisibleevent ( _bool ) ; } } }	this method gets called when a bound property is changed .
private static int [ ] maybesort ( int [ ] values ) { if ( ! issorted ( values , _num , _bool ) ) { values = values . clone ( ) ; arrays . sort ( values ) ; } return values ; }	clone and sort the array , if not already sorted .
public int executeupdate ( string sql ) throws genericdatasourceexception { statement stmt = null ; try { stmt = _connection . createstatement ( ) ; return stmt . executeupdate ( sql ) ; } catch ( sqlexception sqle ) { throw new genericdatasourceexception ( _str + _sql , sqle ) ; } finally { if ( stmt != null ) { try { stmt . close ( ) ; } catch ( sqlexception sqle ) { debug . logwarning ( _str + sqle . getmessage ( ) , module ) ; } } } }	execute update based on the sql statement given.
private void dotextnormal ( final pdfpage cmds , final string text ) { final pointf zero = new pointf ( ) ; final matrix scale = new matrix ( ) ; utils . setmatvalues ( scale , fsize , _num , _num , fsize * th , _num , tr ) ; final matrix at = new matrix ( ) ; final list < pdfglyph > l = ( list < pdfglyph > ) font . getglyphs ( text ) ; for ( final pdfglyph glyph : l ) { at . set ( cur ) ; at . preconcat ( scale ) ; final pointf advance = glyph . addcommands ( cmds , at , tm ) ; float advancex = ( advance . x * fsize ) + tc ; if ( glyph . getchar ( ) == _str ) { advancex += tw ; } advancex *= th ; cur . pretranslate ( advancex , advance . y ) ; } final float [ ] src = { zero . x , zero . y } ; final float [ ] dst = new float [ src . length ] ; cur . mappoints ( dst , src ) ; prevend . set ( dst [ _num ] , dst [ _num ] ) ; }	add some text to the page .
public synchronized static void initialize ( connection conn ) throws sqlexception { if ( loghadoopidpatterns != null && loglineagepatterns != null ) { return ; } loadlineagepatterns ( conn ) ; loadhadoopidpatterns ( conn ) ; }	initialize , download the regex info into cache.
public void addindices ( collection < iindex > indices ) { for ( iterator < iindex > it = indices . iterator ( ) ; it . hasnext ( ) ; ) { addindex ( ( iindex ) it . next ( ) ) ; } }	adds the given indices .
public static boolean iscookiesecure ( ) { return securecookie ; }	gets property value of " com.
public static list < objectmodel > loadjsonstream ( inputstream input ) { list < objectmodel > models = new arraylist < > ( ) ; reader reader = new inputstreamreader ( input ) ; objectmodel [ ] objectmodels = gson . fromjson ( reader , objectmodel [ ] . class ) ; for ( objectmodel objectmodel : objectmodels ) { models . add ( objectmodel ) ; } return models ; }	load object definitions from json stream .
protected multistepexprholder createmultistepexprlist ( vector paths ) { multistepexprholder first = null ; int n = paths . size ( ) ; for ( int i = _num ; i < n ; i ++ ) { expressionowner eo = ( expressionowner ) paths . elementat ( i ) ; if ( null == eo ) continue ; locpathiterator lpi = ( locpathiterator ) eo . getexpression ( ) ; int numpaths = countsteps ( lpi ) ; if ( numpaths > _num ) { if ( null == first ) first = new multistepexprholder ( eo , numpaths , null ) ; else first = first . addinsortedorder ( eo , numpaths ) ; } } if ( ( null == first ) || ( first . getlength ( ) <= _num ) ) return null ; else return first ; }	for the reduction of location path parts , create a list of all the multistep paths with more than one step , sorted by the number of steps , with the most steps occuring earlier in the list.
private int addwordlenweights ( channel chan , int weightidx ) { int [ ] weigthstab = atrac3p_wl_weights [ chan . chnum * _num + weightidx - _num ] ; for ( int i = _num ; i < ctx . numquantunits ; i ++ ) { chan . quwordlen [ i ] += weigthstab [ i ] ; if ( chan . quwordlen [ i ] < _num || chan . quwordlen [ i ] > _num ) { log . error ( string . format ( _str , i , chan . quwordlen [ i ] ) ) ; return at3p_error ; } } return _num ; }	add weighting coefficients to the decoded word - length information .
public void testupdate3 ( ) throws sqlexception { databasecreator . fillfkstricttable ( conn ) ; statement . execute ( _str + databasecreator . fkstrict_table + _str ) ; statement . execute ( _str + databasecreator . parent_table + _str ) ; }	updatefunctionalitytest2 # testupdate3 ( ) . deletes all referencing rows and then updates referenced one.
final void pruneexceptionalout ( ir ir ) { int n = getnumberofexceptionalout ( ) ; if ( n > _num ) { computedbbenum handlers = new computedbbenum ( n ) ; enumeration < instruction > e = forwardrealinstrenumerator ( ) ; while ( e . hasmoreelements ( ) ) { instruction x = e . nextelement ( ) ; enumeration < basicblock > bbs = getapplicableexceptionalout ( x ) ; while ( bbs . hasmoreelements ( ) ) { basicblock bb = bbs . nextelement ( ) ; handlers . addpossiblyduplicateelement ( bb ) ; } } deleteexceptionalout ( ) ; for ( int i = _num ; handlers . hasmoreelements ( ) ; i ++ ) { exceptionhandlerbasicblock b = ( exceptionhandlerbasicblock ) handlers . nextelement ( ) ; insertout ( b ) ; } } recomputenormalout ( ir ) ; }	prune away exceptional out edges that are not reachable given this block ' s instructions .
public string tospacedstring ( ) { final string original = tostring ( ) ; final stringbuilder builder = new stringbuilder ( ) ; for ( int i = _num ; i < original . length ( ) ; i ++ ) { if ( i > _num && ( i % _num ) == _num ) builder . append ( _str ) ; builder . append ( original . charat ( i ) ) ; } return builder . tostring ( ) ; }	return a spaced fingerprint representation of this hexdigest . ex : 1e0f 5874 2268 e82f c600 d81d 9064 07c5 7cc2 c3a7.
private int parsecontenttype ( final byte [ ] b , final int off ) throws parseexception { contenttypeval_ = primitivesparser . parsebyte ( b , off ) ; if ( contenttype . deserialize ( contenttypeval_ ) == null ) { throw new badciphertextexception ( _str ) ; } return _num ; }	parse the content type in the provided bytes.
@ benchmark public void noncaching ( ) { run ( ) ; }	no cache for deserialized strings , each string is an own instance .
private void rlineto ( float dx , float dy ) { if ( isempty ( ) ) { mpath . moveto ( mlastx = _num , mlasty = _num ) ; } dx += mlastx ; dy += mlasty ; mpath . lineto ( mlastx = dx , mlasty = dy ) ; }	same as lineto , but the coordinates are considered relative to the last point on this contour.
@ override public conflictresults parseoutput ( final string stdout , final string stderr ) { final list < string > contentconflicts = new arraylist < string > ( ) ; final list < string > renameconflicts = new arraylist < string > ( ) ; final list < string > bothconflicts = new arraylist < string > ( ) ; final string [ ] lines = getlines ( stderr ) ; for ( final string line : lines ) { final int index = line . lastindexof ( _str ) ; if ( index != - _num ) { if ( stringutils . endswith ( line , both_conflicts_suffix ) ) { bothconflicts . add ( line . substring ( _num , index ) ) ; } else if ( stringutils . endswith ( line , rename_conflict_suffix ) ) { renameconflicts . add ( line . substring ( _num , index ) ) ; } else { contentconflicts . add ( line . substring ( _num , index ) ) ; } } } return new conflictresults ( contentconflicts , renameconflicts , bothconflicts ) ; }	outputs the conflicts found in the workspace in the following format : < p / > tfstest_01 / addfold / testhere2 : the item content has changed tfstest_01 / testadd . txt : the item content has changed.
protected void sendstart ( final outputstream out ) throws ioexception { log . trace ( _str ) ; out . write ( extra_bytes ) ; out . write ( getpartboundary ( ) ) ; out . write ( crlf_bytes ) ; }	write the start to the specified output stream.
public void addactualqty ( bigdecimal add ) { m_actualqty = m_actualqty . add ( add ) ; }	add to actual qty.
protected static boolean isvowel ( final char c ) { final char l = character . tolowercase ( c ) ; return ( ( l == _str ) || ( l == _str ) || ( l == _str ) || ( l == _str ) || ( l == _str ) ) ; }	is the character a vowel ?.
public static void printstacktrace ( sqlexception e , printwriter pw ) { sqlexception next = e ; while ( next != null ) { next . printstacktrace ( pw ) ; next = next . getnextexception ( ) ; if ( next != null ) { pw . println ( _str ) ; } } }	print the stack trace for a sqlexception to a specified printwriter .
public void readdata ( datainput din ) throws ioexception { bytecount = din . readbyte ( ) ; status = din . readunsignedshort ( ) ; eventcount = din . readunsignedshort ( ) ; messagecount = din . readunsignedshort ( ) ; events = new byte [ bytecount - _num ] ; if ( events . length > _num ) { din . readfully ( events , _num , events . length ) ; } }	readdata - - input the modbus message from din.
public e remove ( int index ) { final reentrantlock lock = this . lock ; lock . lock ( ) ; try { object [ ] elements = getarray ( ) ; int len = elements . length ; e oldvalue = get ( elements , index ) ; int nummoved = len - index - _num ; if ( nummoved == _num ) setarray ( arrays . copyof ( elements , len - _num ) ) ; else { object [ ] newelements = new object [ len - _num ] ; system . arraycopy ( elements , _num , newelements , _num , index ) ; system . arraycopy ( elements , index + _num , newelements , index , nummoved ) ; setarray ( newelements ) ; } return oldvalue ; } finally { lock . unlock ( ) ; } }	removes the element at the specified position in this list.
private static < t extends component > t buildrow ( final jpanel panel , final string labeltext , final string hint , final t component , final boolean islast ) { component . setpreferredsize ( new dimension ( colorpanel_width , colorpanel_height ) ) ; final jpanel rowpanel = new jpanel ( new borderlayout ( ) ) ; rowpanel . setborder ( new emptyborder ( _num , _num , islast ? _num : _num , _num ) ) ; rowpanel . add ( new jlabel ( labeltext ) , borderlayout . center ) ; rowpanel . add ( chintcreator . createhintpanel ( component , hint ) , borderlayout . east ) ; panel . add ( rowpanel ) ; return component ; }	builds a single row of components in the panel .
public builder addtargetelements ( element ... additionaltargets ) { for ( int i = _num ; i < additionaltargets . length ; i ++ ) { targetelements . add ( additionaltargets [ i ] ) ; } return this ; }	adds additional target elements.
public void curveto ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { if ( size ( ) == _num ) { throw new illegalpathstateexception ( _str ) ; } node lastpoint = get ( size ( ) - _num ) ; lastpoint . mask |= c2_mask ; lastpoint . x [ _num ] = x1 ; lastpoint . y [ _num ] = y1 ; if ( ( lastpoint . mask & c1c2_mask ) == c1c2_mask ) { lastpoint . keepcolinear = math . abs ( geom . angle ( lastpoint . x [ _num ] , lastpoint . y [ _num ] , lastpoint . x [ _num ] , lastpoint . y [ _num ] ) - geom . angle ( lastpoint . x [ _num ] , lastpoint . y [ _num ] , lastpoint . x [ _num ] , lastpoint . y [ _num ] ) ) < _num ; } add ( new node ( c1_mask , x3 , y3 , x2 , y2 , x3 , y3 ) ) ; }	adds a cubic curve to the bezier path.
public void testdivideroundupneg ( ) { string a = _str ; int ascale = - _num ; string b = _str ; int bscale = _num ; string c = _str ; int resscale = - _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; bigdecimal result = anumber . divide ( bnumber , resscale , bigdecimal . round_up ) ; assertequals ( _str , c , result . tostring ( ) ) ; assertequals ( _str , resscale , result . scale ( ) ) ; }	divide : rounding mode is round_up , result is negative.
private void opencounterdatainputstream ( ) throws datafallbackexception { if ( dinput == null ) { if ( log . isdebugenabled ( ) ) log . debug ( _str + counterfile . getname ( ) + _str ) ; try { dinput = new bufferedreader ( new filereader ( counterfile ) ) ; } catch ( ioexception e ) { throw new datafallbackexception ( e . getmessage ( ) ) ; } } }	create a stream to read from the counter file.
public compositepredicate ( predicate p1 , predicate p2 ) { m_clauses . add ( p1 ) ; m_clauses . add ( p2 ) ; }	create a new compositepredicate .
public string readnextword ( ) { if ( tokenizer . hasmoretokens ( ) ) { return tokenizer . nexttoken ( ) ; } else { return null ; } }	read the next word from the parsed sentence .
public static final void tostring ( stringbuffer output , string str ) { if ( str == null ) { output . append ( _str ) ; return ; } output . append ( tostring ( str ) ) ; }	provides a java string literal representing the parameter string.
public static boolean testfileexists ( string name ) { boolean status ; if ( ( testsavelocationexists ( ) ) && ( ! name . equals ( _str ) ) ) { file path = environment . getexternalstoragedirectory ( ) ; file newpath = constructfilepaths ( path . tostring ( ) , name ) ; status = newpath . exists ( ) ; } else { status = _bool ; } return status ; }	determine if a file or directory exists .
@ override public void buildassociations ( instances data ) throws exception { buildassociations ( ( object ) data ) ; return ; }	method that generates all large item sets with a minimum support , and from these all association rules with a minimum metric ( i.
public static string replacefirst ( string s , string sub , string with ) { int i = s . indexof ( sub ) ; if ( i == - _num ) { return s ; } return s . substring ( _num , i ) + with + s . substring ( i + sub . length ( ) ) ; }	replaces the very first occurrence of a substring with supplied string .
private locationhelper ( ) { }	prevent initializing this class .
public void addobject ( string s ) throws exception { inspect ( class . forname ( s ) ) ; }	add the name of the class to methodize.
public static element firstchildelement ( element element , set < string > childelementnames ) { if ( element == null ) return null ; node node = element . getfirstchild ( ) ; if ( node != null ) { do { if ( node . getnodetype ( ) == node . element_node && childelementnames . contains ( node . getnodename ( ) ) ) { element childelement = ( element ) node ; return childelement ; } } while ( ( node = node . getnextsibling ( ) ) != null ) ; } return null ; }	return the first child element returns the first element .
public static void main ( string [ ] args ) throws exception { final jframe frame = new htmltest ( args ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . pack ( ) ; frame . setvisible ( _bool ) ; }	the main program for the htmltest class.
@ override public int hashcode ( ) { return rawstring . hashcode ( ) ; }	returns the hashcode for the raw string .
public final void testaddallhelpertextcolorsfromarray ( ) { int helpertextcolor1 = color . black ; int helpertextcolor2 = color . gray ; int [ ] helpertextcolors1 = new int [ _num ] ; helpertextcolors1 [ _num ] = helpertextcolor1 ; helpertextcolors1 [ _num ] = helpertextcolor2 ; passwordedittext passwordedittext = new passwordedittext ( getcontext ( ) ) ; passwordedittext . addallhelpertextcolors ( helpertextcolors1 ) ; passwordedittext . addallhelpertextcolors ( helpertextcolors1 ) ; collection < integer > helpertextcolors2 = passwordedittext . gethelpertextcolors ( ) ; assertequals ( helpertextcolors1 . length , helpertextcolors2 . size ( ) ) ; iterator < integer > iterator = helpertextcolors2 . iterator ( ) ; assertequals ( helpertextcolor1 , ( int ) iterator . next ( ) ) ; assertequals ( helpertextcolor2 , ( int ) iterator . next ( ) ) ; }	tests the functionality of the method , which allows to add all helper text colors , which are contained by an array .
private void normalize ( double [ ] in ) { double max = _num ; for ( double d : in ) { max = math . max ( max , d ) ; } for ( int i = _num ; i < in . length ; i ++ ) { in [ i ] = in [ i ] / max ; } }	applies max norm to the histogram .
public static boolean writetofile ( string filename , string message , boolean append ) { boolean result ; bufferedwriter writer ; try { writer = new bufferedwriter ( new filewriter ( filename , append ) ) ; writer . write ( message ) ; writer . newline ( ) ; writer . flush ( ) ; writer . close ( ) ; result = _bool ; } catch ( exception e ) { result = _bool ; } return result ; }	writes the given message to the specified file.
public int hashcode ( ) { return ( _num * colormodel . hashcode ( ) ) + ( _num * samplemodel . hashcode ( ) ) ; }	returns the hash code for this imagetypespecifier .
static public final float random ( float start , float end ) { return start + random . nextfloat ( ) * ( end - start ) ; }	returns a random number between start ( inclusive ) and end ( inclusive ) .
public void writefile ( string name , string mimetype , string filename , byte [ ] data ) throws ioexception { if ( data == null ) { throw new illegalargumentexception ( _str ) ; } if ( filename == null || filename . isempty ( ) ) { throw new illegalargumentexception ( _str ) ; } out . writebytes ( prefix ) ; out . writebytes ( boundary ) ; out . writebytes ( newline ) ; out . writebytes ( _str + name + _str + filename + _str ) ; out . writebytes ( newline ) ; if ( mimetype != null ) { out . writebytes ( _str + mimetype ) ; out . writebytes ( newline ) ; } out . writebytes ( newline ) ; out . write ( data , _num , data . length ) ; out . writebytes ( newline ) ; out . flush ( ) ; }	writes the given bytes .
@ targetapi ( build . version_codes . ice_cream_sandwich_mr1 ) private void onconfigurationchanged ( configuration newconfig ) { final locale newlocale = newconfig . locale ; if ( newlocale . equals ( msystemlocale ) ) { return ; } msystemlocale = newlocale ; ensuresupportedlocale ( ) ; }	handles updating the system locale.
public static keymap fromkey ( final string key ) { if ( key == null || key . isempty ( ) ) { return null ; } final keymap searchresult = instances . get ( key ) ; return searchresult ; }	retrieve an keymap instance by its key .
private static boolean isgmtish ( string name ) { if ( name . length ( ) < _num ) { return _bool ; } char c1 = name . charat ( _num ) ; char c2 = name . charat ( _num ) ; char c3 = name . charat ( _num ) ; if ( ! ( ( c1 == _str || c1 == _str ) && ( c2 == _str || c2 == _str ) && ( c3 == _str || c3 == _str ) ) && ! ( ( c1 == _str || c1 == _str ) && ( c2 == _str || c2 == _str ) && ( c3 == _str || c3 == _str ) ) && ! ( ( c1 == _str || c1 == _str ) && ( c2 == _str || c2 == _str ) && ( c3 == _str ) ) ) { return _bool ; } if ( name . length ( ) == _num ) { return _bool ; } string offset = name . substring ( _num ) ; if ( offset . startswith ( _str ) ) { return offset . equals ( _str ) || offset . equals ( _str ) || offset . equals ( _str ) ; } else { return offset . equals ( _str ) || offset . equals ( _str ) || offset . equals ( _str ) ; } }	tells if a offset or time zone is gmt.
private static string massageuri ( string uri ) { uri = uri . trim ( ) ; int protocolend = uri . indexof ( _str ) ; if ( protocolend < _num || iscolonfollowedbyportnumber ( uri , protocolend ) ) { uri = _str + uri ; } return uri ; }	transforms a string that represents a uri into something more proper , by adding or canonicalizing the protocol .
public void delete ( int key ) { int i = binarysearch ( mkeys , _num , msize , key ) ; if ( i >= _num ) { system . arraycopy ( mkeys , i + _num , mkeys , i , msize - ( i + _num ) ) ; system . arraycopy ( mvalues , i + _num , mvalues , i , msize - ( i + _num ) ) ; msize -- ; } }	removes the mapping from the specified key , if there was any .
protected void addwholematch ( stringbuilder sb , string surface , string analyzed ) { sb . append ( _str ) ; sb . append ( surface ) ; sb . append ( _str ) ; }	called while highlighting a single result , to append the whole matched token to the provided fragments list .
public void start ( ) { stopat = system . currenttimemillis ( ) + max_processing_time ; }	start the timer to make sure processing doesn ' t take too long .
private object [ ] singlerow ( int row ) { object [ ] res = new object [ this . nfields ] ; for ( int i = _num ; i < this . nfields ; i += _num ) { if ( this . isnull == null || ! this . isnull [ row * this . nfields + i ] ) { res [ i ] = arrayfuncs . newinstance ( this . types [ i ] , _num ) ; system . arraycopy ( this . data [ i ] , row , res [ i ] , _num , _num ) ; } } return res ; }	extract a single row from a table.
public static string removechars ( string src , string chars ) { int i = src . length ( ) ; stringbuilder sb = new stringbuilder ( i ) ; for ( int j = _num ; j < i ; j ++ ) { char c = src . charat ( j ) ; if ( chars . indexof ( c ) == - _num ) { sb . append ( c ) ; } } return sb . tostring ( ) ; }	removes all characters contained in provided string .
private void addallcolumns ( ) throws sqlexception { databasemetadata metadata = getdatabasemetadata ( ) ; list < string > columns = new arraylist < > ( ) ; try ( resultset rs = metadata . getcolumns ( null , null , normalizeobjectname ( statementmodel . gettablename ( ) ) , null ) ) { while ( rs . next ( ) ) { columns . add ( quoteobjectname ( rs . getstring ( idx_column_name ) ) ) ; } } columnnames = columns . toarray ( new string [ _num ] ) ; addreturningclause ( ) ; }	adds all available table columns to the query as generated keys .
static private void copystream ( final inputstream content , final outputstream outstr ) throws ioexception { final byte [ ] buf = new byte [ gzip_buffer ] ; while ( _bool ) { final int rdlen = content . read ( buf ) ; if ( rdlen <= _num ) { break ; } outstr . write ( buf , _num , rdlen ) ; } }	copy the input stream to the output stream .
public void checkandsetupstreamsdrawer ( ) { setuplistviewadapter ( ) ; }	initiates the streams drawer if the streams in the drawer is 0 .
public void testfptypeoverridesimple ( ) throws exception { objectmapper m = new objectmapper ( ) ; m . enable ( deserializationconfig . feature . use_big_decimal_for_floats ) ; bigdecimal dec = new bigdecimal ( _str ) ; number result = m . readvalue ( dec . tostring ( ) , number . class ) ; assertequals ( bigdecimal . class , result . getclass ( ) ) ; assertequals ( dec , result ) ; object value = m . readvalue ( dec . tostring ( ) , object . class ) ; assertequals ( bigdecimal . class , result . getclass ( ) ) ; assertequals ( dec , value ) ; }	test for verifying [ jackson - 72 ] .
private com . codename1 . ui . component copycomponent ( com . codename1 . ui . component cmp ) { com . codename1 . ui . container cnt = builder . createcontainer ( res , copiedresourcename ) ; com . codename1 . ui . component dest = builder . findbyname ( cmp . getname ( ) , cnt ) ; if ( dest != null && dest . getparent ( ) != null ) { removecomponentsync ( dest . getparent ( ) , dest ) ; } return dest ; }	creates a copy of the given component and its hierarchy.
static double zetastatic ( long st , long n , double theta , double initialsum ) { double sum = initialsum ; for ( long i = st ; i < n ; i ++ ) { sum += _num / ( math . pow ( i + _num , theta ) ) ; } return sum ; }	compute the zeta constant needed for the distribution.
@ override public bigdecimal calculatetotalpendingadvance ( final bigdecimal totaladvancepaid , final date billdate , final workorderestimate workorderestimate , final long billid ) { final cchartofaccounts advancecoa = contractoradvanceservice . getcontractoradvanceaccountcodeforwoe ( workorderestimate . getid ( ) ) ; bigdecimal totalpendingbalance = bigdecimal . zero ; bigdecimal totaladvanceadjusted = bigdecimal . zero ; if ( advancecoa != null && totaladvancepaid != null && totaladvancepaid . compareto ( bigdecimal . zero ) > _num ) { totaladvanceadjusted = gettotaladvanceadjustedforwoe ( billdate , workorderestimate . getid ( ) , advancecoa . getid ( ) , billid ) ; if ( totaladvanceadjusted != null && totaladvanceadjusted . compareto ( bigdecimal . zero ) > _num && totaladvanceadjusted . compareto ( bigdecimal . zero ) > _num ) totalpendingbalance = totaladvanceadjusted . subtract ( totaladvanceadjusted ) ; else totalpendingbalance = totaladvancepaid ; } return totalpendingbalance ; }	the method return bigdecimal.
private void loadprofile ( string userid , string name ) { final intent userprofileintent = new intent ( getactivity ( ) , userprofileactivity . class ) ; userprofileintent . putextra ( appconstants . keys . user_id , userid ) ; userprofileintent . putextra ( appconstants . keys . user_name , name ) ; userprofileintent . putextra ( appconstants . keys . service_screen_type , appconstants . servicescreentype . profile ) ; startactivity ( userprofileintent ) ; }	loads the user profile.
private void scrollby ( final int increment ) { index += increment ; if ( index < _num ) { index = _num ; } if ( index >= items . size ( ) ) { index = items . size ( ) - _num ; } redraw ( ) ; }	scroll the selected item.
public static boolean symbolneedsquoting ( charsequence symbol , boolean quoteoperators ) { int length = symbol . length ( ) ; if ( length == _num ) { throw new emptysymbolexception ( ) ; } if ( ! isidentifierkeyword ( symbol ) ) { char c = symbol . charat ( _num ) ; if ( ! quoteoperators && isoperatorpart ( c ) ) { for ( int ii = _num ; ii < length ; ii ++ ) { c = symbol . charat ( ii ) ; if ( ! isoperatorpart ( c ) ) { return _bool ; } } return _bool ; } else if ( isidentifierstart ( c ) ) { for ( int ii = _num ; ii < length ; ii ++ ) { c = symbol . charat ( ii ) ; if ( ( c == _str || c < _num || c > _num ) || ! isidentifierpart ( c ) ) { return _bool ; } } return _bool ; } } return _bool ; }	determines whether the text of a symbol requires ( single ) quotes .
public static long parsecommitcounterfile ( final string name , final string ext ) throws numberformatexception { if ( name == null ) throw new illegalargumentexception ( ) ; if ( ext == null ) throw new illegalargumentexception ( ) ; final int len = name . length ( ) - ext . length ( ) ; final string filebasename = name . substring ( _num , len ) ; final long commitcounter = long . parselong ( filebasename ) ; return commitcounter ; }	parse out the commitcounter from the file name .
public static document loaddocument ( file file ) throws exception { documentbuilderfactory factory = documentbuilderfactory . newinstance ( ) ; documentbuilder builder = factory . newdocumentbuilder ( ) ; return builder . parse ( file ) ; }	loads a xml document from a file and returns the corresponding dom document .
private node newfloatingcomment ( ) { node c = new node ( token . empty ) ; linkcommenttonode ( c ) ; return c ; }	returns a new comment attached to an empty node.
public boolean ishod ( final long assignid ) { final list < headofdepartments > hodlist = employeedepartmentrepository . getallhoddepartments ( assignid ) ; return ! hodlist . isempty ( ) ; }	returns true if the given employee is an hod.
public munger singlelabelmode ( string ... languages ) { return singlelabelmode ( arrays . aslist ( languages ) ) ; }	build a munger that will load only a single label per entity.
public statvalue [ ] matchspec ( statspec spec ) { if ( spec . getcombinetype ( ) == statspec . global ) { statvalue [ ] allvalues = matchspec ( new rawstatspec ( spec ) ) ; if ( allvalues . length == _num ) { return allvalues ; } else { combovalue cv = new combovalue ( allvalues ) ; return new statvalue [ ] { cv } ; } } else { list l = new arraylist ( ) ; statarchivereader . statarchivefile [ ] archives = getarchives ( ) ; for ( int i = _num ; i < archives . length ; i ++ ) { statarchivefile f = archives [ i ] ; if ( spec . archivematches ( f . getfile ( ) ) ) { f . matchspec ( spec , l ) ; } } statvalue [ ] result = new statvalue [ l . size ( ) ] ; return ( statvalue [ ] ) l . toarray ( result ) ; } }	returns an array of stat values that match the specified spec.
private void assignclusternums ( int [ ] cl_num ) throws exception { if ( m_children != null && m_children . size ( ) < _num ) { throw new exception ( _str ) ; } m_clusternum = cl_num [ _num ] ; cl_num [ _num ] ++ ; if ( m_children != null ) { for ( int i = _num ; i < m_children . size ( ) ; i ++ ) { cnode child = m_children . get ( i ) ; child . assignclusternums ( cl_num ) ; } } }	recursively assigns numbers to the nodes in the tree .
protected void closesubpath ( ) { mpsstream . println ( closepath_str ) ; mpenx = mstartpathx ; mpeny = mstartpathy ; }	close the current subpath by appending a straight line from the current point to the subpath ' s starting point .
public tvshowepisodescrapetask ( list < tvshowepisode > episodes , mediascraper mediascraper ) { super ( bundle . getstring ( _str ) , episodes . size ( ) , tasktype . background_task ) ; this . episodes = episodes ; this . mediascraper = mediascraper ; this . scrapethumb = _bool ; }	instantiates a new tv show episode scrape task .
public void saveselection ( iminitable minitable ) { log . info ( _str ) ; arraylist < integer > results = new arraylist < integer > ( ) ; setselection ( null ) ; int rows = minitable . getrowcount ( ) ; for ( int i = _num ; i < rows ; i ++ ) { idcolumn id = ( idcolumn ) minitable . getvalueat ( i , _num ) ; if ( id != null && id . isselected ( ) ) results . add ( id . getrecord_id ( ) ) ; } if ( results . size ( ) == _num ) return ; log . config ( _str + results . size ( ) ) ; setselection ( results ) ; }	save selection & return selecion query or " ".
public modelmbeannotificationinfo ( string [ ] notiftypes , string name , string description ) { this ( notiftypes , name , description , null ) ; }	constructs a modelmbeannotificationinfo object with a default descriptor .
public void cleanbuildtask ( long id ) throws notfoundexception { futurebuildtask task = tasks . remove ( id ) ; if ( task == null ) { throw new notfoundexception ( string . format ( _str , id ) ) ; } task . cancel ( _bool ) ; cleanup ( task ) ; }	clean - up all resources and files allocated for the given build task .
public static file createtempdir ( file parent ) { file temp = new file ( parent , integer . tostring ( math . abs ( unseeded_random . nextint ( ) ) % _num ) ) ; temp . delete ( ) ; temp . mkdir ( ) ; temp . deleteonexit ( ) ; return temp ; }	create a temporary directory that is a child of the given directory.
public void moveto ( final int loncenter , final int latcenter ) { double mlatcenter = geomath . late7tomercator ( latcenter ) ; double mtop = geomath . late7tomercator ( top ) ; int newbottom = geomath . mercatortolate7 ( mlatcenter - ( mtop - bottommercator ) / _num ) ; try { translate ( ( loncenter - left - ( int ) ( width / _num ) ) , newbottom - bottom ) ; } catch ( osmexception e ) { e . printstacktrace ( ) ; } }	performs a translation so the center of this bounding box will be at ( loncenter | latcenter ) .
public void sendevent ( final string name , final map < string , string > properties ) { final string eventname = string . format ( tfstelemetryconstants . plugin_action_event_name_format , name ) ; final propertymapbuilder builder = new propertymapbuilder ( properties ) ; logger . debug ( string . format ( _str , name , builder . tostring ( ) ) ) ; if ( telemetryclient != null ) { telemetryclient . trackevent ( eventname , builder . build ( ) , null ) ; } }	call sendevent to track an occurrence of a named event .
public void handleheadercolumnpressed ( point p ) { jtableheader th = table . gettableheader ( ) ; int col = th . columnatpoint ( p ) ; int c = table . convertcolumnindextomodel ( col ) ; if ( c != - _num ) { table . setpressedcolumnindex ( c ) ; th . repaint ( th . getheaderrect ( col ) ) ; } }	tell the table something is pressed .
private static list < fixedrecord > createfixedrecords ( int count ) { list < fixedrecord > records = new arraylist < > ( ) ; for ( int i = _num ; i < count ; i ++ ) { records . add ( new fixedrecord ( i ) ) ; } return records ; }	create a list of count 16 - byte records .
public trackedentityinstancequeryparams addattributesifnotexist ( list < queryitem > attrs ) { for ( queryitem attr : attrs ) { if ( attributes != null && ! attributes . contains ( attr ) ) { attributes . add ( attr ) ; } } return this ; }	add the given attributes to this params if they are not already present .
void recomposeattributesets ( elemattributeset attrset ) { arraylist attrsetlist = ( arraylist ) m_attrsets . get ( attrset . getname ( ) ) ; if ( null == attrsetlist ) { attrsetlist = new arraylist ( ) ; m_attrsets . put ( attrset . getname ( ) , attrsetlist ) ; } attrsetlist . add ( attrset ) ; }	recompose the attribute - set declarations .
public static list split ( string str , string regex ) { return ( arrays . aslist ( str . split ( regex ) ) ) ; }	splits the given string using the given regex as delimiters.
protected final void deletedbffdcfiles ( string directorytodelete ) throws adeexception { try { final file dirtodelete = new file ( directorytodelete ) ; string [ ] filelist = dirtodelete . list ( ) ; if ( filelist . length == _num ) { dirtodelete . delete ( ) ; } else { for ( int i = _num ; i < filelist . length ; i ++ ) { final file f = new file ( dirtodelete , filelist [ i ] ) ; if ( f . isdirectory ( ) ) { final string filepath = f . getpath ( ) ; deletedbffdcfiles ( filepath ) ; continue ; } f . delete ( ) ; } filelist = dirtodelete . list ( ) ; if ( filelist . length == _num ) { dirtodelete . delete ( ) ; } } } catch ( exception e ) { throw new adeinternalexception ( _str , e ) ; } }	deletes the backed - up db directory . note that a directory can be deleted only if there are no files in it.
node < k , v > findlast ( ) { index < k , v > q = head ; for ( ; ; ) { index < k , v > d , r ; if ( ( r = q . right ) != null ) { if ( r . indexesdeletednode ( ) ) { q . unlink ( r ) ; q = head ; } else q = r ; } else if ( ( d = q . down ) != null ) { q = d ; } else { node < k , v > b = q . node ; node < k , v > n = b . next ; for ( ; ; ) { if ( n == null ) return b . isbaseheader ( ) ? null : b ; node < k , v > f = n . next ; if ( n != b . next ) break ; object v = n . value ; if ( v == null ) { n . helpdelete ( b , f ) ; break ; } if ( v == n || b . value == null ) break ; b = n ; n = f ; } q = head ; } } }	specialized version of find to get last valid node .
public void appendtonalunit ( byte [ ] data , int offset , int limit ) { if ( ! isfilling ) { return ; } int readlength = limit - offset ; if ( naldata . length < nallength + readlength ) { naldata = arrays . copyof ( naldata , ( nallength + readlength ) * _num ) ; } system . arraycopy ( data , offset , naldata , nallength , readlength ) ; nallength += readlength ; }	invoked to pass stream data.
public static long sizeofdirectory ( file directory ) { checkdirectory ( directory ) ; final file [ ] files = directory . listfiles ( ) ; if ( files == null ) { return _num ; } long size = _num ; for ( final file file : files ) { try { if ( ! issymlink ( file ) ) { size += sizeof ( file ) ; if ( size < _num ) { break ; } } } catch ( ioexception ioe ) { } } return size ; }	counts the size of a directory recursively ( sum of the length of all files ) .
public synchronized void panabs ( double dx , double dy ) { damagereport ( ) ; m_transform . translate ( dx , dy ) ; try { m_itransform = m_transform . createinverse ( ) ; } catch ( exception e ) { } }	pans the view provided by this display in absolute ( i.
public static void checkserializedequality ( object object ) { object object2 = serializeandrecover ( object ) ; assert . assertequals ( _str , object , object2 ) ; assert . assertequals ( _str , object . hashcode ( ) , object2 . hashcode ( ) ) ; }	verifies that serialization preserves equals and hashcode.
public string documentationreferenceguideurl ( ) { return properties . getproperty ( _str ) ; }	returns the url of the product wiki page .
public static double mean ( final list < double > list ) { double sum = _num ; for ( double number : list ) { sum += number ; } return sum / list . size ( ) ; }	gets the average from a list of numbers .
public static string tohex ( byte [ ] data ) { try { return new string ( hex . encode ( data ) , _str ) ; } catch ( unsupportedencodingexception e ) { } return null ; }	convert a byte array to hexadecimal.
public in ( url url ) { if ( url == null ) throw new nullpointerexception ( _str ) ; try { urlconnection site = url . openconnection ( ) ; inputstream is = site . getinputstream ( ) ; scanner = new scanner ( new bufferedinputstream ( is ) , charset_name ) ; scanner . uselocale ( locale ) ; } catch ( ioexception ioe ) { throw new illegalargumentexception ( _str + url ) ; } }	initializes an input stream from a url .
@ visiblefortesting public void processenablefullscreenrunnablefortest ( ) { if ( mhandler . hasmessages ( msg_id_enable_fullscreen_after_load ) ) { mhandler . removemessages ( msg_id_enable_fullscreen_after_load ) ; enablefullscreenafterload ( ) ; } }	removes the enable fullscreen runnable from the ui queue and runs it immediately .
private static string fromhtmlentity ( string str ) { character ch = map . get ( str ) ; return ( ch != null ) ? ch . tostring ( ) : str ; }	find the html entity and convert it back to a regular character if the entity exists , otherwise return the same string .
public void write ( byte [ ] vector ) { check ( vector . length ) ; system . arraycopy ( vector , _num , buffer , write_pos , vector . length ) ; write_pos += vector . length ; }	writes vector of opaque values.
public void unlockui ( processinfo pi ) { boolean notprint = pi != null && pi . getad_process_id ( ) != m_curtab . getad_process_id ( ) && pi . isreportingprocess ( ) == _bool ; setbusy ( _bool , notprint ) ; if ( notprint ) { m_curtab . datarefresh ( ) ; if ( pi . istimeout ( ) ) env . setcontext ( m_ctx , m_curwindowno , _str , _str ) ; m_curgc . dynamicdisplay ( _num ) ; setstatusline ( pi . getsummary ( ) , pi . iserror ( ) ) ; if ( pi . iserror ( ) ) adialog . error ( m_curwindowno , this , null , pi . getsummary ( ) ) ; processinfoutil . setlogfromdb ( pi ) ; string loginfo = pi . getloginfo ( ) ; if ( loginfo . length ( ) > _num ) adialog . info ( m_curwindowno , this , env . getheader ( m_ctx , m_curwindowno ) , pi . gettitle ( ) , loginfo ) ; } else { setstatusline ( pi . getsummary ( ) , pi . iserror ( ) ) ; if ( pi . iserror ( ) ) adialog . error ( m_curwindowno , this , null , pi . getsummary ( ) ) ; } }	unlock user interface . called from the worker when processing is done.
private map < uri , storagesystem > buildarraymap ( storagesystem vplexsystem , list < volumedescriptor > descriptors , volumedescriptor . type [ ] types ) { map < uri , storagesystem > arraymap = new hashmap < uri , storagesystem > ( ) ; if ( types != null ) { descriptors = volumedescriptor . filterbytype ( descriptors , types , new volumedescriptor . type [ ] { } ) ; } for ( volumedescriptor desc : descriptors ) { if ( arraymap . containskey ( desc . getdeviceuri ( ) ) == _bool ) { if ( vplexsystem == null ) { storagesystem array = getdataobject ( storagesystem . class , desc . getdeviceuri ( ) , _dbclient ) ; arraymap . put ( desc . getdeviceuri ( ) , array ) ; } else { set < uri > connectedsystems = connectivityutil . getstoragesystemassociationsbynetwork ( _dbclient , vplexsystem . getid ( ) , storageport . porttype . backend ) ; if ( connectedsystems . contains ( desc . getdeviceuri ( ) ) ) { storagesystem array = getdataobject ( storagesystem . class , desc . getdeviceuri ( ) , _dbclient ) ; arraymap . put ( desc . getdeviceuri ( ) , array ) ; } } } } return arraymap ; }	build a map of uri to cached storagesystem for the underlying arrays .
public byte [ ] encrypt ( byte [ ] plaintextasbytes , charsequence password ) throws keycrypterexception { try { byte [ ] salt = new byte [ salt_length ] ; securerandom . nextbytes ( salt ) ; parameterswithiv key = ( parameterswithiv ) getaespasswordkey ( password , salt ) ; bufferedblockcipher cipher = new paddedbufferedblockcipher ( new cbcblockcipher ( new aesfastengine ( ) ) ) ; cipher . init ( _bool , key ) ; byte [ ] encryptedbytes = new byte [ cipher . getoutputsize ( plaintextasbytes . length ) ] ; final int processlength = cipher . processbytes ( plaintextasbytes , _num , plaintextasbytes . length , encryptedbytes , _num ) ; final int dofinallength = cipher . dofinal ( encryptedbytes , processlength ) ; return concat ( salt , arrays . copyof ( encryptedbytes , processlength + dofinallength ) ) ; } catch ( exception e ) { throw new keycrypterexception ( _str + utils . bytestohexstring ( plaintextasbytes ) + _str , e ) ; } }	password based encryption using aes - cbc 256 bits .
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return after_id ; case _num : return max_jobs ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
@ override public void deinstall ( jeditorpane editor ) { super . deinstall ( editor ) ; editor . removekeylistener ( this ) ; }	deinstalls the editor for the kit .
public boolean issecure ( ) { return mtlscipher != null && ! mtlscipher . isempty ( ) ; }	check if sip transport uses tls.
public void sample ( record rec ) { totalrecs ++ ; if ( samples . size ( ) < max_samples ) { samples . add ( new sample ( rec , schema ) ) ; updatenewvalueinterval ( rec ) ; } else { double flip = random . nextdouble ( ) ; if ( flip < ( double ) max_samples / totalrecs ) { samples . set ( random . nextint ( max_samples ) , new sample ( rec , schema ) ) ; updatenewvalueinterval ( rec ) ; } } }	keep a record as a sample , with certain probability.
public tenantcreateparam preparetenantparam ( keystonetenant tenant ) { tenantcreateparam param = new tenantcreateparam ( cinderconstants . tenant_name_prefix + _str + tenant . getname ( ) , prepareusermappings ( tenant . getid ( ) ) ) ; param . setdescription ( getpropertenantdescription ( tenant . getdescription ( ) ) ) ; return param ; }	prepares tenantcreateparam class filled with information from given tenant .
private void forceinternalerror ( ) { throw new internalerror ( _str ) ; }	not really any good way to convince java to do this , so i ' m just gonna throw it directly .
@ override public void drawhighlight ( graphics g , int w , int h ) { g . setcolor ( color . black ) ; fontmetrics fm = g . getfontmetrics ( ) ; int l = ( int ) ( m_x * w ) - fm . stringwidth ( m_id ) / _num ; int t = ( int ) ( m_y * h ) - fm . getheight ( ) / _num ; g . fillrect ( l - _num , t - _num , fm . stringwidth ( m_id ) + _num , fm . getheight ( ) + fm . getdescent ( ) + _num ) ; drawnode ( g , w , h ) ; }	call this function to draw the node highlighted .
public static imageencoder newinstance ( string format ) { imageencoder imageencoder = null ; string classname = ( string ) encoders . get ( format ) ; if ( classname == null ) { throw new illegalargumentexception ( _str + format ) ; } try { class imageencoderclass = class . forname ( classname ) ; imageencoder = ( imageencoder ) imageencoderclass . newinstance ( ) ; } catch ( exception e ) { throw new illegalargumentexception ( e . tostring ( ) ) ; } return imageencoder ; }	used to retrieve an imageencoder for a specific image format .
public static void applypinchzoomimage ( imageview mimageview ) { mimageview . setontouchlistener ( new pinchzoom ( ) ) ; }	use for apply pinchzoom functionality to your imageview.
public static file parse ( string [ ] options , string option , file defvalue ) throws exception { string value = utils . getoption ( option , options ) ; if ( value . isempty ( ) ) return defvalue ; else return new file ( value ) ; }	parses a file option , uses default if option is missing .
public boolean isacctbalanced ( ) { if ( m_lines . size ( ) == _num ) return _bool ; bigdecimal balance = getacctbalance ( ) ; boolean retvalue = balance . signum ( ) == _num ; if ( retvalue ) log . finer ( tostring ( ) ) ; else log . warning ( _str + balance + _str + tostring ( ) ) ; return retvalue ; }	are the lines accounting balanced.
public void ensurecapacity ( int mincapacity ) { int oldcapacity = capacity ; if ( mincapacity > oldcapacity ) { int newcapacity = ( oldcapacity * _num ) / _num + _num ; if ( newcapacity < mincapacity ) newcapacity = mincapacity ; bitvector vector = tobitvector ( ) ; vector . setsize ( newcapacity * bitsperelement ) ; this . bits = vector . elements ( ) ; this . capacity = newcapacity ; } }	ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory.
private string detailbase ( final method method ) { final class < ? > clazz = method . getdeclaringclass ( ) ; final string detailbase = messageutils . bundlenameforclass ( clazz ) ; if ( isblank ( detailbase ) ) { throw new illegalstateexception ( _str + clazz ) ; } return detailbase ; }	get the name of the message bundle to use when getting the message for the specified method.
public void finished ( ) throws ioexception { outputstream . close ( ) ; }	do all required cleanup now that we ' re finished with the currently - open . zip.
public final void lock ( ) { suntoolkit . awtlock ( ) ; }	locks the queue for read / write access .
@ override public object createstatement ( object proxy , method method , object [ ] args , object statement , long time ) { try { object result = null ; string name = method . getname ( ) ; string sql = null ; constructor < ? > constructor = null ; if ( compare ( create_statement , name ) ) { constructor = getconstructor ( create_statement_idx , statement . class ) ; } else if ( compare ( prepare_statement , name ) ) { sql = ( string ) args [ _num ] ; constructor = getconstructor ( prepare_statement_idx , preparedstatement . class ) ; if ( sql != null ) { preparestatement ( sql , time ) ; } } else if ( compare ( prepare_call , name ) ) { sql = ( string ) args [ _num ] ; constructor = getconstructor ( prepare_call_idx , callablestatement . class ) ; preparecall ( sql , time ) ; } else { return statement ; } result = constructor . newinstance ( new object [ ] { new statementproxy ( statement , sql ) } ) ; return result ; } catch ( exception x ) { log . warn ( _str , x ) ; } return statement ; }	creates a statement interceptor to monitor query response times.
public updateresponse remove ( long id ) throws ioexception , solrserverexception { updateresponse res = solrclient . deletebyid ( string . valueof ( id ) ) ; solrclient . commit ( _bool , _bool , _bool ) ; return res ; }	deletes a solrdocument with the given id .
public void switchsetup ( ) { int retval ; retval = m_setupfilechooser . showopendialog ( this ) ; if ( retval != jfilechooser . approve_option ) { return ; } m_dbutils . initialize ( m_setupfilechooser . getselectedfile ( ) ) ; m_url = m_dbutils . getdatabaseurl ( ) ; m_user = m_dbutils . getusername ( ) ; m_password = m_dbutils . getpassword ( ) ; m_texturl . settext ( m_url ) ; }	lets the user select a props file for changing the database connection parameters .
private clientdetailsentity loadclientobject ( final oidcauthorizationrequestcontext authorizationrequest ) { log . debug ( _str , authorizationrequest . getclientid ( ) ) ; return clientservice . loadclientbyclientid ( authorizationrequest . getclientid ( ) ) ; }	load client object client details entity .
public void addfieldproperty ( string name , string accessorfield ) { fieldproperties . add ( new legacyfieldpropdesc ( name , accessorfield ) ) ; }	adds the named event property backed by the named accessor field .
private void parsenowildcards ( ) { this . fsegments = new string [ _num ] ; this . fsegments [ _num ] = this . fpattern ; this . fbound = this . flength ; }	this method parses the given pattern into segments seperated by wildcard ' * ' characters.
public map < string , string > environment ( ) { string base64 = tostringbase64 ( ) ; if ( base64 == null || base64 . length ( ) == _num ) { return collections . emptymap ( ) ; } map < string , string > environment = maps . newhashmap ( ) ; environment . put ( baggageutils . baggage_environment_variable , base64 ) ; return environment ; }	encodes the baggage to strings to set as environment variables , which will then be picked up in a child process.
@ override public void drawseries ( canvas canvas , paint paint , list < float > points , list < double > values , xyseriesrenderer seriesrenderer , supportseriesrender supportseriesrender , float yaxisvalue , int seriesindex , int startindex ) { int seriesnr = mdataset . getseriescount ( ) ; int length = points . size ( ) ; paint . setcolor ( seriesrenderer . getcolor ( ) ) ; paint . setstyle ( style . fill ) ; float halfdiffx = gethalfdiffx ( points , length , seriesnr ) ; for ( int i = _num ; i < length ; i += _num ) { float x = points . get ( i ) ; float y = points . get ( i + _num ) ; drawbar ( canvas , x , yaxisvalue , x , y , halfdiffx , seriesnr , seriesindex , paint ) ; } paint . setcolor ( seriesrenderer . getcolor ( ) ) ; }	the graphical representation of a series .
public void listenmodlog ( string username , string token ) { if ( ! hasserver ( ) ) { return ; } if ( modloglisten . containskey ( username ) ) { return ; } this . token = token ; long userid = getuserid ( username ) ; modloglisten . put ( username , userid ) ; logger . info ( _str + username + _str + userid ) ; if ( userid != - _num ) { sendlistenmodlog ( userid , _bool ) ; } }	start receiving the modlog for the given channel ( username ).
public static boolean isvalidclassname ( string classname ) { if ( classname . indexof ( _str ) >= _num ) { return _bool ; } return _bool ; }	return whether or not the given class name is valid .
@ suppresswarnings ( _str ) public void newminute ( ) { if ( ! insyncwithinternalfastclock ) { return ; } if ( correctfastclock || synchronizewithinternalclock ) { date now = clock . gettime ( ) ; if ( now . getminutes ( ) != _num ) { curdays = now . getdate ( ) ; curhours = now . gethours ( ) ; curminutes = now . getminutes ( ) ; long millis = now . gettime ( ) ; long elapsedms = millis % msecperminute ; double frac_min = elapsedms / ( double ) msecperminute ; curfractionalminutes = ( int ) correction - ( int ) ( correction * frac_min ) ; setclock ( ) ; } } else if ( setinternal && ! correctfastclock && ! synchronizewithinternalclock ) { insyncwithinternalfastclock = _bool ; initiateread ( ) ; } }	corrects the loconet fast clock.
private < t extends discoveredsystemobject > boolean isdatacollectionscanjobschedulingneeded ( long lastscantime , boolean inprogress ) { long systemtime = system . currenttimemillis ( ) ; long refreshinterval = getrefreshinterval ( controllerserviceimpl . scanner ) ; if ( inprogress ) { return _bool ; } if ( lastscantime > _num && ( systemtime - lastscantime < refreshinterval * _num ) ) { _logger . info ( _str ) ; return _bool ; } return _bool ; }	if the job is in progress , don ' t schedule the job.
private void removebreakpoints ( final set < breakpointaddress > breakpointaddressset , final breakpointstorage storage ) { if ( breakpointaddressset . size ( ) != _num ) { final set < breakpoint > breakpoints = storage . getbreakpointsbyaddress ( breakpointaddressset ) ; storage . removebreakpoints ( breakpointaddressset ) ; for ( final breakpointmanagerlistener listener : listeners ) { try { listener . breakpointsremoved ( breakpoints ) ; } catch ( final exception e ) { cutilityfunctions . logexception ( e ) ; } } } }	remove the given set of breakpoints .
public void replacecreationtemplate ( guid guid , string templatename , attrset attrset ) throws configmanagerexception { if ( guid == null ) { guid = new guid ( _rootdn ) ; } dn dn = dn . valueof ( guid . getdn ( ) ) ; string org = _str ; list < rdn > rdns = new arraylist < > ( ) ; for ( rdn rdn : dn ) { rdns . add ( _num , rdn ) ; } for ( rdn rdn : rdns ) { org = org + _str + ldaputils . rdnvalue ( rdn ) ; } string service = creationpath + _str + templatename ; map map = converttomap ( attrset ) ; try { replaceserviceattributes ( org , service , map ) ; } catch ( smsexception e ) { string args [ ] = new string [ _num ] ; args [ _num ] = e . tostring ( ) ; throw new configmanagerexception ( i18n . getstring ( iumsconstants . error_cm , args ) ) ; } catch ( ssoexception se ) { string args [ ] = new string [ _num ] ; args [ _num ] = se . tostring ( ) ; throw new configmanagerexception ( i18n . getstring ( iumsconstants . error_cm , args ) ) ; } }	replaces an existing template .
private void readobject ( objectinputstream stream ) throws ioexception , classnotfoundexception { stream . defaultreadobject ( ) ; marshalledinstance mi = ( marshalledinstance ) stream . readobject ( ) ; try { listener = ( remoteeventlistener ) mi . get ( _bool ) ; } catch ( throwable e ) { if ( e instanceof error && throwableconstants . retryable ( e ) == throwableconstants . bad_object ) { throw ( error ) e ; } logger . log ( level . warning , _str , e ) ; } }	unmarshals the event listener .
public void add ( t item ) { if ( set . add ( item ) ) { firecontentschanged ( this , _num , getsize ( ) - _num ) ; } }	adds the specified item to this list model.
private string bytearraytohexstring ( byte [ ] bytes ) { stringbuilder sb = new stringbuilder ( bytes . length * _num ) ; for ( byte element : bytes ) { int v = element & _num ; if ( v < _num ) { sb . append ( _str ) ; } sb . append ( integer . tohexstring ( v ) ) ; } return sb . tostring ( ) ; }	using some super basic byte array & lt ; - & gt ; hex conversions so we don ' t have to rely on any large base64 libraries . can be overridden if you like !.
public scserver createclusterserver ( string ssn , string clustername , string osid ) throws storagecenterapiexception { parameters params = new parameters ( ) ; params . add ( _str , clustername ) ; params . add ( _str , ssn ) ; params . add ( _str , notes_string ) ; params . add ( _str , osid ) ; restresult rr = restclient . post ( _str , params . tojson ( ) ) ; if ( ! checkresults ( rr ) ) { string error = string . format ( _str , clustername , rr . geterrormsg ( ) ) ; throw new storagecenterapiexception ( error ) ; } return gson . fromjson ( rr . getresult ( ) , scserver . class ) ; }	creates a new cluster server definition .
public void testconstructorsignbytespositive4 ( ) { byte abytes [ ] = { _num , _num , _num , - _num } ; int asign = _num ; byte rbytes [ ] = { _num , _num , _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = anumber . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , anumber . signum ( ) ) ; }	create a positive number from a sign and an array of bytes.
public void testminimalcompletionstage ( ) { completablefuture < integer > f = new completablefuture < > ( ) ; completionstage < integer > g = f . minimalcompletionstage ( ) ; atomicinteger x = new atomicinteger ( _num ) ; atomicreference < throwable > r = new atomicreference < throwable > ( ) ; checkincomplete ( f ) ; g . whencomplete ( null ) ; f . complete ( _num ) ; checkcompletednormally ( f , _num ) ; assertequals ( x . get ( ) , _num ) ; assertnull ( r . get ( ) ) ; }	minimalcompletionstage returns a completablefuture that is completed normally , with the same value , when source is .
private void writedirectorypostresource ( element postresourceel , string path ) { postresourceel . setattribute ( _str , dir_resource_set ) ; postresourceel . setattribute ( _str , path . replace ( _str , _str ) ) ; }	write directory post resource.
private static int [ ] trimarray ( int [ ] array , int size ) { if ( size < _num ) { throw new illegalargumentexception ( ) ; } if ( size == _num ) { return no_errors ; } int [ ] a = new int [ size ] ; system . arraycopy ( array , _num , a , _num , size ) ; return a ; }	trim the array to the required size .
static potiontype fromname ( string name ) { for ( potiontypetable table : values ( ) ) { if ( name . equalsignorecase ( table . name ) ) return table . type ; } return potiontype . valueof ( name . touppercase ( ) ) ; }	converts a vanilla potion id to an equivalent bukkit potiontype.
public synchronized void removecurlmesh ( curlmesh mesh ) { while ( mcurlmeshes . remove ( mesh ) ) ; }	removes curlmesh from this renderer .
private list < datum > samplenbestlist ( int sourceid , sequence < istring > source , sentencelevelmetric < istring , string > scoremetric , list < richtranslation < istring , string > > translations , list < sequence < istring > > references ) { int [ ] sourceids = new int [ _num ] ; sourceids [ _num ] = sourceid ; list < sequence < istring > > sources = new arraylist < > ( _num ) ; sources . add ( source ) ; list < list < richtranslation < istring , string > > > translationlist = new arraylist < list < richtranslation < istring , string > > > ( _num ) ; translationlist . add ( translations ) ; list < list < sequence < istring > > > referencelist = new arraylist < list < sequence < istring > > > ( _num ) ; referencelist . add ( references ) ; return samplenbestlists ( sourceids , sources , scoremetric , translationlist , referencelist ) ; }	select pro samples from a single instance .
protected void postrunnable ( runnable runnable ) { if ( runnable != null ) { handler . post ( runnable ) ; } }	helper method to send runnable into local handler loop.
public boolean isclosed ( ) { return map . isclosed ( ) ; }	check whether this map is closed .
public void insertthinktime ( ) { scriptstep thinktimescriptstep = scriptstepfactory . createthinktime ( getminthinktime ( ) , getmaxthinktime ( ) ) ; steps . add ( getinsertindex ( ) , thinktimescriptstep ) ; minthinktime = _str ; maxthinktime = _str ; reindexscriptsteps ( ) ; }	does something to insert think time into the script .
public void addnode ( final instruction instruction ) { instructions . add ( instruction ) ; if ( previnstruction != null ) { addedge ( previnstruction , instruction ) ; } previnstruction = instruction ; }	add new node and set prev instruction pointing to this instruction.
public void ensurecapacity ( int minimumcapacity ) { if ( minimumcapacity <= _capacity ) return ; if ( minimumcapacity > _num ) { _capacity = ( minimumcapacity + _num ) & ~ _num ; } else { while ( _capacity < minimumcapacity ) { _capacity += _capacity ; } } byte [ ] bytes = new byte [ _capacity ] ; system . arraycopy ( _buffer , _num , bytes , _num , _length ) ; _buffer = bytes ; }	ensure the buffer can hold at least ' minimumcapacity ' bytes .
public builder removename ( final string name ) { names . remove ( name ) ; return this ; }	removes the provided user friendly name .
public < t > jsonapidocument < list < t > > readdocumentcollection ( inputstream datastream , class < t > clazz ) { try { resourcecache . init ( ) ; jsonnode rootnode = objectmapper . readtree ( datastream ) ; validationutils . ensurenoterror ( objectmapper , rootnode ) ; validationutils . ensurecollection ( rootnode ) ; resourcecache . cache ( parseincluded ( rootnode ) ) ; list < t > resourcelist = new arraylist < > ( ) ; for ( jsonnode element : rootnode . get ( data ) ) { t pojo = readobject ( element , clazz , _bool ) ; resourcelist . add ( pojo ) ; } jsonapidocument < list < t > > result = new jsonapidocument < > ( resourcelist , objectmapper ) ; if ( rootnode . has ( meta ) ) { result . setmeta ( mapmeta ( rootnode . get ( meta ) ) ) ; } if ( rootnode . has ( links ) ) { result . setlinks ( new links ( maplinks ( rootnode . get ( links ) ) ) ) ; } return result ; } catch ( runtimeexception e ) { throw e ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } finally { resourcecache . clear ( ) ; } }	reads json api spec document and converts it into collection of target type objects .
public void addtargetedbyswarm ( int entityid , int weaponid ) { hitbyswarmsentity . addelement ( new integer ( entityid ) ) ; hitbyswarmsweapon . addelement ( new integer ( weaponid ) ) ; }	add a targeting by a swarm volley from a specified entity.
private boolean ischeckpointexists ( connection conn , string key ) throws sqlexception { preparedstatement st = null ; resultset rs = null ; try { st = conn . preparestatement ( chkexistssql ) ; st . setstring ( _num , key ) ; rs = st . executequery ( ) ; return rs . next ( ) ; } finally { u . close ( rs , log ) ; u . close ( st , log ) ; } }	checks specified checkpoint existing .
public omscalingraster ( double ullat , double ullon , double lrlat , double lrlon , imageicon ii ) { this ( ullat , ullon , lrlat , lrlon , ii . getimage ( ) ) ; }	create an omraster , lat / lon placement with an imageicon .
public static void copystream ( inputstream is , outputstream os , byte [ ] buffer , int buffersize , string confid , double filesize , context context ) throws ioexception { double downloaded = _num ; int [ ] update = new int [ _num ] ; try { for ( ; ; ) { int count = is . read ( buffer , _num , buffersize ) ; downloaded += count ; if ( count == - _num ) { if ( context != null ) { } break ; } os . write ( buffer , _num , count ) ; if ( context != null ) { update [ _num ] = ( int ) downloaded ; update [ _num ] = ( int ) filesize ; update [ _num ] = ( int ) ( ( downloaded / filesize ) * _num ) ; } } } catch ( ioexception e ) { throw e ; } }	copy from one stream to another . throws ioexception in the event of error ( for example , sd card is full ).
@ override public void writeheader ( ) throws ioexception { os = new pdfwriter ( new bufferedoutputstream ( ros ) , pdf_version ) ; delayimagequeue = new pdfimagedelayqueue ( os ) ; delaypaintqueue = new pdfpaintdelayqueue ( os , delayimagequeue ) ; fonttable = new pdffonttable ( os ) ; pdfdocinfo info = os . opendocinfo ( _str ) ; info . settitle ( getproperty ( title ) ) ; info . setauthor ( getproperty ( author ) ) ; info . setsubject ( getproperty ( subject ) ) ; info . setkeywords ( getproperty ( keywords ) ) ; info . setcreator ( getcreator ( ) ) ; info . setproducer ( producer == null ? _str : producer ) ; if ( ! isdeviceindependent ( ) ) { calendar now = calendar . getinstance ( ) ; info . setcreationdate ( now ) ; info . setmodificationdate ( now ) ; } info . settrapped ( _str ) ; os . close ( info ) ; pdfcatalog catalog = os . opencatalog ( _str , _str ) ; catalog . setoutlines ( _str ) ; catalog . setpagemode ( _str ) ; catalog . setviewerpreferences ( _str ) ; catalog . setopenaction ( new object [ ] { os . ref ( _str ) , os . name ( _str ) } ) ; os . close ( catalog ) ; pdfviewerpreferences prefs = os . openviewerpreferences ( _str ) ; prefs . setfitwindow ( _bool ) ; prefs . setcenterwindow ( _bool ) ; os . close ( prefs ) ; alphaindex = _num ; extgstates = new hashmap < float , string > ( ) ; if ( ! ismultipage ( ) ) { openpage ( getsize ( ) , null ) ; } }	writes the catalog , docinfo , preferences , and ( as we use only single page output the page tree .
protected string parsestring ( int closingcharacter ) throws ioexception , rdfparseexception { stringbuilder sb = getbuilder ( ) ; while ( _bool ) { int c = readcodepoint ( ) ; if ( c == closingcharacter ) { break ; } else if ( c == - _num ) { throweofexception ( ) ; } appendcodepoint ( sb , c ) ; if ( c == _str ) { c = readcodepoint ( ) ; if ( c == - _num ) { throweofexception ( ) ; } appendcodepoint ( sb , c ) ; } } return sb . tostring ( ) ; }	parses a " normal string ".
private void codeunwrapreturnvalue ( class < ? > type , dataoutputstream out ) throws ioexception { if ( type . isprimitive ( ) ) { primitivetypeinfo prim = primitivetypeinfo . get ( type ) ; out . writebyte ( opc_checkcast ) ; out . writeshort ( cp . getclass ( prim . wrapperclassname ) ) ; out . writebyte ( opc_invokevirtual ) ; out . writeshort ( cp . getmethodref ( prim . wrapperclassname , prim . unwrapmethodname , prim . unwrapmethoddesc ) ) ; if ( type == int . class || type == boolean . class || type == byte . class || type == char . class || type == short . class ) { out . writebyte ( opc_ireturn ) ; } else if ( type == long . class ) { out . writebyte ( opc_lreturn ) ; } else if ( type == float . class ) { out . writebyte ( opc_freturn ) ; } else if ( type == double . class ) { out . writebyte ( opc_dreturn ) ; } else { throw new assertionerror ( ) ; } } else { out . writebyte ( opc_checkcast ) ; out . writeshort ( cp . getclass ( dottoslash ( type . getname ( ) ) ) ) ; out . writebyte ( opc_areturn ) ; } }	generate code for unwrapping a return value of the given type from the invocation handler ' s " invoke " method ( as type object ) to its correct type.
private string formatlink ( string [ ] parts ) { string anchor , text ; if ( parts . length < _num ) { anchor = _str ; text = _str ; } else { anchor = parts [ _num ] ; text = parts [ _num ] ; } return string . format ( _str , anchor , text ) ; }	formats a link , given an array of tokens .
public jsonexception ( throwable cause ) { super ( cause . getmessage ( ) ) ; this . cause = cause ; }	constructs a new jsonexception with the specified cause .
public boolean fixutils ( string [ ] utils ) throws exception { for ( string util : utils ) { if ( ! checkutil ( util ) ) { if ( checkutil ( _str ) ) { if ( hasutil ( util , _str ) ) { fixutil ( util , roottools . utilpath ) ; } } else { if ( checkutil ( _str ) ) { if ( hasutil ( util , _str ) ) { fixutil ( util , roottools . utilpath ) ; } } else { return _bool ; } } } } return _bool ; }	this will check an array of binaries , determine if they exist and determine that it has either the permissions 755 , 775 , or 777.
@ override protected void initialize ( ) { list < string > patterns ; super . initialize ( ) ; m_patterns = new arraylist < pattern > ( ) ; patterns = read ( ) ; for ( string pattern : patterns ) { m_patterns . add ( pattern . compile ( pattern ) ) ; } }	performs intialization of the scheme .
public static string [ ] lsdirectories ( string directory ) throws exception { string [ ] tmp = ls ( directory ) ; arraylist < string > files = new arraylist < > ( ) ; for ( string s : tmp ) { if ( isdirectory ( directory + file . separator + s ) ) files . add ( s ) ; } return files . toarray ( new string [ files . size ( ) ] ) ; }	list the directories contained within a directory .
private void tostringwithchildren ( stringbuffer buffer , int indent ) { internaltostring ( buffer , indent ) ; if ( fchildren != null ) { for ( iterator < textedit > iterator = fchildren . iterator ( ) ; iterator . hasnext ( ) ; ) { textedit child = iterator . next ( ) ; buffer . append ( _str ) ; child . tostringwithchildren ( buffer , indent + _num ) ; } } }	adds the string representation for this text edit and its children to the given string buffer .
public static void encode ( appendable out , int value ) throws ioexception { value = tovlqsigned ( value ) ; do { int digit = value & vlq_base_mask ; value >>>= vlq_base_shift ; if ( value > _num ) { digit |= vlq_continuation_bit ; } out . append ( base64 . tobase64 ( digit ) ) ; } while ( value > _num ) ; }	writes a vlq encoded value to the provide appendable .
public mxicelloverlay removecelloverlay ( object cell , mxicelloverlay overlay ) { if ( overlay == null ) { removecelloverlays ( cell ) ; } else { mxicelloverlay [ ] arr = getcelloverlays ( cell ) ; if ( arr != null ) { list < mxicelloverlay > list = arrays . aslist ( arr ) ; if ( list . remove ( overlay ) ) { removecelloverlaycomponent ( overlay , cell ) ; } arr = ( mxicelloverlay [ ] ) list . toarray ( ) ; overlays . put ( cell , arr ) ; } } return overlay ; }	removes and returns the given overlay from the given cell.
public void removeforeignkey ( int idx ) { foreignkeys . remove ( idx ) ; }	removes the indicated foreign key .
public java . lang . stringbuffer insert ( int offset , int i ) { internal . insert ( offset , i ) ; return this ; }	inserts the string representation of the second int argument into this string buffer.
public void addgefaehrdungsumsetzung ( gefaehrdungsumsetzung gefaehrdung ) { if ( ! allgefaehrdungsumsetzungen . contains ( gefaehrdung ) ) { allgefaehrdungsumsetzungen . add ( gefaehrdung ) ; } }	adds a gefaehrdung to the list of all gefaehrdungen if gefaehrdung not already exits .
string normalizeclasspath ( string classpath , boolean generaterelative ) { char sep = cauchoutil . getpathseparatorchar ( ) ; int head = _num ; int tail = _num ; charbuffer cb = charbuffer . allocate ( ) ; while ( head < classpath . length ( ) ) { tail = classpath . indexof ( sep , head ) ; if ( tail < _num ) tail = classpath . length ( ) ; if ( tail > head ) { string segment = classpath . substring ( head , tail ) ; segment = normalizepath ( segment , generaterelative ) ; if ( segment != null ) { if ( cb . length ( ) != _num ) cb . append ( sep ) ; cb . append ( segment ) ; } } head = tail + _num ; } return cb . close ( ) ; }	converts any relative classpath references to the full path .
protected asn1sequence ( asn1encodable obj ) { seq . addelement ( obj ) ; }	create a sequence containing one object.
public final void push ( int value ) { int ff = m_firstfree ; if ( ( ff + _num ) >= m_mapsize ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapsize = m_blocksize ; } else { m_mapsize += m_blocksize ; int newmap [ ] = new int [ m_mapsize ] ; system . arraycopy ( m_map , _num , newmap , _num , ff + _num ) ; m_map = newmap ; } } m_map [ ff ] = value ; ff ++ ; m_firstfree = ff ; }	append a node onto the vector .
protected node stringconversion ( node node ) { typeelement stringelement = elements . gettypeelement ( _str ) ; if ( ! typesutils . isstring ( node . gettype ( ) ) ) { node converted = new stringconversionnode ( node . gettree ( ) , node , stringelement . astype ( ) ) ; addtoconvertedlookupmap ( converted ) ; insertnodeafter ( converted , node ) ; return converted ; } else { return node ; } }	convert the input node to string type , if it isn ' t already .
@ knownfailure ( _str ) public void testupdate7 ( ) throws sqlexception { databasecreator . fillfkstricttable ( conn ) ; statement . executeupdate ( _str + databasecreator . fkstrict_table + _str + databasecreator . parent_table + _str ) ; resultset r = statement . executequery ( _str + databasecreator . fkstrict_table + _str ) ; r . next ( ) ; assertequals ( _str , _num , r . getint ( _num ) ) ; r . close ( ) ; }	updatefunctionalitytest2 # testupdate7 ( ) . updates table using subquery in where clause todo foreign key functionality is not supported.
completablefuture < historyreadresponse > historyread ( historyreaddetails historyreaddetails , timestampstoreturn timestampstoreturn , boolean releasecontinuationpoints , list < historyreadvalueid > nodestoread ) ;	this service is used to read historical values or events of one or more nodes .
private void validate ( ) throws urisyntaxexception { string s = getscheme ( ) ; if ( ( s != null ) && ( s . compareto ( _str ) == _num ) ) { return ; } if ( getlocalvmid ( ) == - _num ) { throw new urisyntaxexception ( uri . tostring ( ) , _str ) ; } }	check that the vmidentifier includes a unique numerical identifier for the target jvm .
public synchronized void finishwriting ( ) { donewriting = _bool ; notifyall ( ) ; }	stream will close after the already written bytes are read .
private long offset2physicaladdress ( final long offset ) { return offset + headersize ; }	adjusts the offset by the headersize , such that writing to a zero offset would not corrupt the header .
@ override public void internalentitydecl ( string name , xmlstring text , xmlstring nonnormalizedtext , augmentations augs ) throws xniexception { try { if ( fdeclhandler != null ) { fdeclhandler . internalentitydecl ( name , text . tostring ( ) ) ; } } catch ( saxexception e ) { throw new xniexception ( e ) ; } }	an internal entity declaration .
public static boolean isauthorized ( string logname , string operation , object credential ) { return authorizer . isauthorized ( logname , operation , credential ) ; }	returns true if a given log record should be published .
public object next ( ) { if ( pos < size ) return array . get ( array , pos ++ ) ; throw new nosuchelementexception ( _str + pos + _str + size ) ; }	move to next element in the array .
public void addmessages ( list < ? extends message > messages ) { if ( show_logs ) logger . v ( tag , _str + messages ) ; mqueuelock . lock ( tag ) ; mplayermessagesqueue . addall ( messages ) ; mqueuelock . notify ( tag ) ; if ( show_logs ) logger . v ( tag , _str + messages ) ; mqueuelock . unlock ( tag ) ; }	use it if you need to add a multiple messages.
public permissionrequestobject onrational ( func3 rationalfunc ) { mrationalfunc = rationalfunc ; return this ; }	called for the first denied permission if there is need to show the rational.
public genericprincipal ( string username , string password , list < string > roles , map < string , list < genericprincipal . attribute > > writeentries , map < string , list < genericprincipal . attribute > > readentries , map < string , list < genericprincipal . attribute > > executetasks ) { this . username = username ; this . password = password ; this . writeentries = writeentries ; this . readentries = readentries ; this . executetasks = executetasks ; if ( roles != null ) { this . roles = new string [ roles . size ( ) ] ; this . roles = roles . toarray ( this . roles ) ; if ( this . roles . length > _num ) arrays . sort ( this . roles ) ; } writematchobjects = new hashmap < string , matchobject > ( ) ; readmatchobjects = new hashmap < string , matchobject > ( ) ; executematchobjects = new hashmap < string , matchobject > ( ) ; userdefinedroles = new arraylist < string > ( ) ; }	construct a new principal for the specified username and password , with the specified role names ( as strings ) .
public boolean equals ( object other ) { if ( other == this ) { return _bool ; } if ( ! ( other instanceof x509crlentry ) ) { return _bool ; } x509crlentry obj = ( x509crlentry ) other ; try { return arrays . equals ( getencoded ( ) , obj . getencoded ( ) ) ; } catch ( crlexception e ) { return _bool ; } }	returns whether the specified object equals to this instance .
public static int roll1d6 ( ) { return rand . nextint ( _num ) + _num ; }	simulates rolling a dice with 6 sides .
static byte [ ] septetstream2octetstream ( byte [ ] septets ) { int octetlength = ( int ) math . ceil ( ( ( septets . length * _num ) ) / _num ) ; byte [ ] octets = new byte [ octetlength ] ; for ( int i = _num ; i < septets . length ; i ++ ) { for ( int j = _num ; j < _num ; j ++ ) { if ( ( septets [ i ] & ( _num << j ) ) != _num ) { int bitindex = ( i * _num ) + j ; octets [ bitindex > > > _num ] |= _num << ( bitindex & _num ) ; } } } return octets ; }	convert a list of septet values into an octet stream , with a number of empty bits at the start .
public ctaggingpanel ( final jframe parent , final zygraph graph , final itagmanager manager ) { super ( new borderlayout ( ) ) ; m_tagstree = new ctagstree ( parent , graph , manager ) ; final jscrollpane pane = new jscrollpane ( m_tagstree ) ; pane . setverticalscrollbarpolicy ( scrollpaneconstants . vertical_scrollbar_as_needed ) ; pane . sethorizontalscrollbarpolicy ( scrollpaneconstants . horizontal_scrollbar_as_needed ) ; add ( pane ) ; setborder ( new titledborder ( new lineborder ( color . light_gray , _num , _bool ) , _str ) ) ; setdoublebuffered ( _bool ) ; }	creates a new panel object .
@ override public double height ( final int markerindex ) { mathutils . checkrangeinclusive ( markerindex , _num , markerarray . length - _num ) ; return markerarray [ markerindex ] . markerheight ; }	return marker height given index.
public < k , v > void consume ( string groupid , string clientid , offsetresetstrategy autooffsetreset , deserializer < k > keydeserializer , deserializer < v > valuedeserializer , booleansupplier continuation , offsetcommitcallback offsetcommitcallback , runnable completion , collection < string > topics , java . util . function . consumer < consumerrecord < k , v > > consumerfunction ) { properties props = getconsumerproperties ( groupid , clientid , autooffsetreset ) ; thread t = new thread ( null ) ; t . setname ( clientid + _str ) ; t . start ( ) ; }	use the supplied function to asynchronously consume messages from the cluster .
public double distance ( instance first , instance second , performancestats stats ) { return math . sqrt ( distance ( first , second , double . positive_infinity , stats ) ) ; }	calculates the distance ( or similarity ) between two instances.
public void findsameaschaining ( resource subj , set < resource > currentsameas , resource [ ] contxts ) throws inferenceengineexception { try { closeableiteration < statement , queryevaluationexception > subjiter = ryadaohelper . query ( ryadao , subj , owl . sameas , null , conf , contxts ) ; while ( subjiter . hasnext ( ) ) { statement st = subjiter . next ( ) ; if ( ! currentsameas . contains ( st . getobject ( ) ) ) { resource castedobj = ( resource ) st . getobject ( ) ; currentsameas . add ( castedobj ) ; findsameaschaining ( castedobj , currentsameas , contxts ) ; } } subjiter . close ( ) ; closeableiteration < statement , queryevaluationexception > objiter = ryadaohelper . query ( ryadao , null , owl . sameas , subj , conf , contxts ) ; while ( objiter . hasnext ( ) ) { statement st = objiter . next ( ) ; if ( ! currentsameas . contains ( st . getsubject ( ) ) ) { resource sameassubj = st . getsubject ( ) ; currentsameas . add ( sameassubj ) ; findsameaschaining ( sameassubj , currentsameas , contxts ) ; } } objiter . close ( ) ; } catch ( queryevaluationexception e ) { throw new inferenceengineexception ( e ) ; } }	todo : this chaining can be slow at query execution . the other option is to perform this in the query itself , but that will be constrained to how many levels we decide to go.
public static void reindex ( connection conn ) throws sqlexception { init ( conn ) ; removealltriggers ( conn , trigger_prefix ) ; removeindexfiles ( conn ) ; statement stat = conn . createstatement ( ) ; resultset rs = stat . executequery ( _str + schema + _str ) ; while ( rs . next ( ) ) { string schema = rs . getstring ( _str ) ; string table = rs . getstring ( _str ) ; createtrigger ( conn , schema , table ) ; indexexistingrows ( conn , schema , table ) ; } }	re - creates the full text index for this database.
string todot ( ) { stringbuilder buf = new stringbuilder ( ) ; for ( type t : inferencecontext . undetvars ) { undetvar uv = ( undetvar ) t ; buf . append ( string . format ( _str , uv . qtype , uv . getbounds ( inferencebound . upper ) , uv . getbounds ( inferencebound . lower ) , uv . getbounds ( inferencebound . eq ) ) ) ; } return graphutils . todot ( nodes , _str + hashcode ( ) , buf . tostring ( ) ) ; }	debugging : dot representation of this graph.
private void resizetables ( ) { if ( mobjectdataused > mobjectdata . length - max_data_size ) { mobjectdata = arrays . copyof ( mobjectdata , mobjectdata . length * _num ) ; } if ( mobjectcount < mtypes . length ) { return ; } mobjectoffset = arrays . copyof ( mobjectoffset , mobjectoffset . length * _num ) ; mtypes = arrays . copyof ( mtypes , mtypes . length * _num ) ; mobjects = arrays . copyof ( mobjects , mobjects . length * _num ) ; mrect = arrays . copyof ( mrect , mrect . length * _num ) ; }	resize tables as the number of objects grow.
private boolean hasnextinetsocketaddress ( ) { return nextinetsocketaddressindex < inetsocketaddresses . size ( ) ; }	returns true if there ' s another socket address to try .
protected static double convertpercentiletox ( double percentileleveliteratedto ) { double x = _num / ( _num - ( percentileleveliteratedto / _num ) ) ; return math . log10 ( x ) ; }	x = 1 / ( 1 - percentage ).
public static string queuenamefromdbname ( string dbname ) { string [ ] tokens = dbname . split ( _str , _num ) ; return tokens [ _num ] ; }	extracts the queue name given a pinlater queue database name .
public string usethis ( int type , string id , string context ) { int i = findsym ( type , id , context ) ; if ( i == symtab . size ( ) ) return id ; else return ( ( symtabentry ) symtab . elementat ( i ) ) . usethis ; }	routines for returning disambiguated names .
private float angle ( touchstate s ) { return ( float ) math . todegrees ( math . atan2 ( s . ydown - s . ycurrent , s . xdown - s . xcurrent ) ) ; }	angle between the current touch coordinates and the down coordinates.
private int uint16fromdata ( int offset ) { return twobytestoint ( arrays . copyofrange ( data ( ) , offset , offset + _num ) , constants . cc2540_byte_order ) ; }	parse a little - endian uint16 from the data at the given offset .
private static string removequotesencolosingoption ( string filename , string option ) throws exception { string option1 = removequotecharactersifnecessary ( filename , option , _str ) ; if ( ! option1 . equals ( option ) ) { return option1 ; } return removequotecharactersifnecessary ( filename , option , _str ) ; }	removes the surrounding quote characters as needed.
@ override public string generatelabel ( xydataset dataset , int series ) { paramchecks . nullnotpermitted ( dataset , _str ) ; string label = messageformat . format ( this . formatpattern , createitemarray ( dataset , series ) ) ; return label ; }	generates a label for the specified series.
private boolean matchstrings ( string pattern , string str , map < string , string > uritemplatevariables ) { antpathstringmatcher matcher = new antpathstringmatcher ( pattern , str , uritemplatevariables ) ; return matcher . matchstrings ( ) ; }	tests whether or not a string matches against a pattern . the pattern may contain two special characters : < br > ' * ' means zero or more characters < br > ' ? ' means one and only one character.
@ nullable public dimension adjust ( @ notnull dimension newpreferredsize , @ nullable dimension oldpreferredsize , @ notnull editorimpl editor ) { if ( oldpreferredsize == null || myskip ) { return newpreferredsize ; } if ( newpreferredsize . height != oldpreferredsize . height ) { return newpreferredsize ; } striptimings ( ) ; mytimings . add ( system . currenttimemillis ( ) ) ; if ( mytimings . size ( ) < frequent_size_changes_number ) { return newpreferredsize ; } boolean increasewidth = newpreferredsize . width > oldpreferredsize . width ; dimension result ; if ( increasewidth ) { final int spacewidth = editorutil . getspacewidth ( font . plain , editor ) ; newpreferredsize . width += myreservecolumns * spacewidth ; myreservecolumns += _num ; result = newpreferredsize ; } else { result = oldpreferredsize ; } schedulesizeupdate ( editor ) ; return result ; }	asks to adjust new preferred size appliance if necessary .
public rvmfield finddeclaredfield ( atom fieldname , atom fielddescriptor ) { for ( rvmfield field : declaredfields ) { if ( field . getname ( ) == fieldname && field . getdescriptor ( ) == fielddescriptor ) { return field ; } } return null ; }	find description of a field of this class .
public quarter ( date time , timezone zone ) { this ( time , zone , locale . getdefault ( ) ) ; }	constructs a quarter , based on a date / time and time zone .
private util ( ) { }	this class is never instantiated.
default b withdefault ( string key , float value ) { return withdefault ( key , float . tostring ( value ) ) ; }	if there is no field with the specified key , then associate the given value with the specified key .
public static boolean readboolean ( final jsonarray jsonarray , final int index , final boolean required , final boolean notnull ) throws jsonexception { if ( required ) { return jsonarray . getboolean ( index ) ; } if ( notnull && jsonarray . isnull ( index ) ) { throw new jsonexception ( string . format ( locale . us , null_value_format_array , index ) ) ; } boolean value = _bool ; if ( ! jsonarray . isnull ( index ) ) { value = jsonarray . getboolean ( index ) ; } return value ; }	reads the boolean value from the json array for specified index.
protected static void autoboxing ( methodvisitor mv , type fieldtype ) { switch ( fieldtype . getsort ( ) ) { case type . boolean : mv . visitmethodinsn ( invokestatic , _str , _str , _str ) ; break ; case type . byte : mv . visitmethodinsn ( invokestatic , _str , _str , _str ) ; break ; case type . char : mv . visitmethodinsn ( invokestatic , _str , _str , _str ) ; break ; case type . short : mv . visitmethodinsn ( invokestatic , _str , _str , _str ) ; break ; case type . int : mv . visitmethodinsn ( invokestatic , _str , _str , _str ) ; break ; case type . float : mv . visitmethodinsn ( invokestatic , _str , _str , _str ) ; break ; case type . long : mv . visitmethodinsn ( invokestatic , _str , _str , _str ) ; break ; case type . double : mv . visitmethodinsn ( invokestatic , _str , _str , _str ) ; break ; } }	append the call of proper autoboxing method for the given primitif type .
public final void openpdffile ( final byte [ ] data ) throws pdfexception { final randomaccessbuffer pdf_datafile ; try { if ( pdffilereader . alwayscacheinmemory == - _num || data . length < pdffilereader . alwayscacheinmemory ) { pdf_datafile = new randomaccessdatabuffer ( data ) ; } else { try { final file file = file . createtempfile ( _str , _str , new file ( objectstore . temp_dir ) ) ; tempfilename = file . getabsolutepath ( ) ; final java . io . fileoutputstream a = new java . io . fileoutputstream ( file ) ; a . write ( data ) ; a . flush ( ) ; a . close ( ) ; pdf_datafile = new randomaccessfilebuffer ( tempfilename , _str ) ; } catch ( final exception e ) { throw new runtimeexception ( _str + objectstore . temp_dir + _str + e ) ; } } objectreader . init ( pdf_datafile ) ; } catch ( final exception e ) { logwriter . writelog ( _str + e + _str ) ; throw new pdfexception ( _str + e + _str ) ; } }	open pdf file using a byte stream - by default files under 16384 bytes are cached to disk but this can be altered by setting pdffilereader . alwayscacheinmemory to a maximimum size or - 1 ( always keep in memory ).
public static void main ( string [ ] args ) { if ( args . length < _num ) { logger . error ( _str ) ; return ; } int lastindex = args . length - _num ; path [ ] files = getfiles ( args ) ; main main = new main ( ) ; main . generate ( files [ lastindex ] , arrays . copyof ( files , lastindex ) ) ; }	generate allure report data from directories with allure report results .
@ nullable e awaitmatch ( int start ) { for ( int step = _num , totalspins = _num ; ( step < arena_length ) && ( totalspins < spins ) ; step ++ ) { int index = ( start + step ) & arena_mask ; atomicreference < object > slot = arena [ index ] ; object found = slot . get ( ) ; if ( found == free ) { if ( slot . compareandset ( free , waiter ) ) { int slotspins = _num ; for ( ; ; ) { found = slot . get ( ) ; if ( ( found != waiter ) && slot . compareandset ( found , free ) ) { @ suppresswarnings ( _str ) e e = ( e ) found ; return e ; } else if ( ( slotspins >= spins_per_step ) && ( found == waiter ) && ( slot . compareandset ( waiter , free ) ) ) { totalspins += slotspins ; break ; } slotspins ++ ; } } } else if ( ( found != waiter ) && slot . compareandset ( found , free ) ) { @ suppresswarnings ( _str ) e e = ( e ) found ; return e ; } } return null ; }	waits for ( by spinning ) to have an element transfered from another thread.
private arraylist < signature > constructonesignatures ( setdbids [ ] [ ] partitions , final long [ ] [ ] markers ) { final int dim = partitions . length ; arraylist < signature > signatures = new arraylist < > ( ) ; for ( int d = _num ; d < dim ; d ++ ) { final dbids [ ] parts = partitions [ d ] ; if ( parts == null ) { continue ; } final long [ ] marked = markers [ d ] ; for ( int start = bitsutil . nextsetbit ( marked , _num ) ; start >= _num ; ) { int end = bitsutil . nextclearbit ( marked , start + _num ) ; end = ( end == - _num ) ? dim : end ; int [ ] signature = new int [ dim << _num ] ; arrays . fill ( signature , - _num ) ; signature [ d << _num ] = start ; signature [ ( d << _num ) + _num ] = end - _num ; hashsetmodifiabledbids sids = uniondbids ( parts , start , end ) ; if ( log . isdebugging ( ) ) { log . debug ( _str + d + _str + start + _str + ( end - _num ) ) ; } signatures . add ( new signature ( signature , sids ) ) ; start = ( end < dim ) ? bitsutil . nextsetbit ( marked , end + _num ) : - _num ; } } return signatures ; }	construct the 1 - signatures by merging adjacent dense bins .
public void testtestbitpositive1 ( ) { byte abytes [ ] = { - _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = _num ; int number = _num ; biginteger anumber = new biginteger ( asign , abytes ) ; asserttrue ( ! anumber . testbit ( number ) ) ; }	testbit ( int n ) of a positive number.
public static int findendtrimnewlinechars ( charsequence s ) { for ( int i = s . length ( ) ; i > _num ; ) { if ( s . charat ( i - _num ) != _str ) { return i ; } i -- ; if ( i > _num && s . charat ( i - _num ) == _str ) { i -- ; } } return _num ; }	finds and returns the end of the given character sequence after trimming new line characters from the right.
private void calccoordinates ( final float x , final float [ ] [ ] trm , float charspacing ) { final float [ ] [ ] trm = new float [ _num ] [ _num ] ; for ( int xx = _num ; xx < _num ; xx ++ ) { system . arraycopy ( trm [ xx ] , _num , trm [ xx ] , _num , _num ) ; } x1 = x ; x2 = trm [ _num ] [ _num ] - ( charspacing * trm [ _num ] [ _num ] ) ; if ( glyphdata . ishorizontal ( ) ) { if ( trm [ _num ] [ _num ] < _num ) { x1 = x + trm [ _num ] [ _num ] - ( charspacing * trm [ _num ] [ _num ] ) ; x2 = trm [ _num ] [ _num ] ; } else if ( trm [ _num ] [ _num ] > _num ) { x1 = x ; x2 = trm [ _num ] [ _num ] ; } } else if ( trm [ _num ] [ _num ] > _num ) { x1 = trm [ _num ] [ _num ] ; x2 = x + trm [ _num ] [ _num ] - ( charspacing * trm [ _num ] [ _num ] ) ; } else if ( trm [ _num ] [ _num ] < _num ) { x2 = trm [ _num ] [ _num ] ; x1 = x + trm [ _num ] [ _num ] - ( charspacing * trm [ _num ] [ _num ] ) ; } }	calculate the x coords for text here y coords are calculated in the method processtextarray ( final byte [ ] stream , int startcommand , int datapointer ).
protected java . util . date fromjulian ( int julian ) { ymd ymd = new ymd ( julian ) ; gregoriancalendar cal = new gregoriancalendar ( ymd . year , ymd . month - _num , ymd . day ) ; return cal . gettime ( ) ; }	convert a julian to it ' s java date equivalent .
public synchronized boolean removelast ( k obj ) { if ( peeklast ( ) != obj ) { return _bool ; } array = arrays . copyof ( array , array . length - _num ) ; return _bool ; }	remove the last element , if it matches .
private boolean serializecompactrdfstructprop ( xmpnode node , int indent , boolean hasrdfresourcequal ) throws xmpexception , ioexception { boolean hasattrfields = _bool ; boolean haselemfields = _bool ; boolean emitendtag = _bool ; for ( iterator ic = node . iteratechildren ( ) ; ic . hasnext ( ) ; ) { xmpnode field = ( xmpnode ) ic . next ( ) ; if ( canberdfattrprop ( field ) ) { hasattrfields = _bool ; } else { haselemfields = _bool ; } if ( hasattrfields && haselemfields ) { break ; } } if ( hasrdfresourcequal && haselemfields ) { throw new xmpexception ( _str , xmperror . badrdf ) ; } if ( ! node . haschildren ( ) ) { write ( _str ) ; writenewline ( ) ; emitendtag = _bool ; } else if ( ! haselemfields ) { serializecompactrdfattrprops ( node , indent + _num ) ; write ( _str ) ; writenewline ( ) ; emitendtag = _bool ; } else if ( ! hasattrfields ) { write ( _str ) ; writenewline ( ) ; serializecompactrdfelementprops ( node , indent + _num ) ; } else { write ( _str ) ; writenewline ( ) ; writeindent ( indent + _num ) ; write ( rdf_struct_start ) ; serializecompactrdfattrprops ( node , indent + _num ) ; write ( _str ) ; writenewline ( ) ; serializecompactrdfelementprops ( node , indent + _num ) ; writeindent ( indent + _num ) ; write ( rdf_struct_end ) ; writenewline ( ) ; } return emitendtag ; }	serializes a struct property .
public default utilitytable queryutil ( bnetwork network , string queryvar , assignment evidence ) { return queryutil ( new query . utilquery ( network , arrays . aslist ( queryvar ) , evidence ) ) ; }	computes the utility table for the query variable ( typically an action variable ) , given the provided evidence.
public static float [ ] stringlisttonumeric ( list < string > scorelist ) throws numberformatexception { float [ ] scores = new float [ scorelist . size ( ) ] ; int scoreid = _num ; for ( string score : scorelist ) { float floatscore = ( float ) double . parsedouble ( score ) ; if ( float . isnan ( floatscore ) ) { throw new numberformatexception ( _str + score ) ; } scores [ scoreid ++ ] = floatscore ; } return scores ; }	converts a string list of scores to float .
@ override public void next ( ) { currentimage = optional . of ( addindexandgetimagebyoffset ( + _num ) ) ; eventbus . post ( new sourcehaspendingupdateevent ( this ) ) ; }	assigns the output socket to the next image . ( wraps around ).
protected void parse ( datainputstream stream ) throws exception { int size = stream . readint ( ) ; int ret , read = _num ; data = new byte [ size ] ; while ( size > _num ) { ret = stream . read ( data , read , size ) ; size -= ret ; read += ret ; } }	loading method . ( see nbt_tag ).
private list < activity > findbestinsertion ( list < activity > partialroute , boolean allowasmajor ) { int startindex = _num ; int endindex = partialroute . size ( ) - _num ; if ( allowasmajor ) { startindex = _num ; endindex = partialroute . size ( ) ; } list < activity > newlist = partialroute ; double best = double . positive_infinity ; list < activity > bestlist = null ; for ( int i = startindex ; i <= endindex ; i ++ ) { list < activity > tmplist = new arraylist < > ( newlist ) ; activity tmpactivity = getrelocationactivity ( ) ; tmplist . add ( i , tmpactivity ) ; double tmp = evaluatelist ( tmplist ) ; if ( tmp < best ) { if ( i == _num ) { tmpactivity . settype ( _str ) ; tmpactivity . setendtime ( time . parsetime ( _str ) ) ; } else if ( i == partialroute . size ( ) ) { tmpactivity . settype ( _str ) ; } else { tmpactivity . settype ( _str ) ; tmpactivity . setmaximumduration ( time . parsetime ( _str ) ) ; } best = tmp ; bestlist = tmplist ; } } return bestlist ; }	find the best insertion position for a relocated activity in a given list of current activities .
public void writeshort ( int value ) throws ioexception { checkwriteprimitivetypes ( ) ; primitivetypes . writeshort ( value ) ; }	writes a short ( 16 bit ) to the target stream .
private boolean isinitialized ( ) { return poolnames != null && ! poolnames . isempty ( ) ; }	checks if is initialized .
public void onregisterclick ( view view ) { intent register = new intent ( intent . action_view , uri . parse ( getstring ( r . string . welcome_link_url ) ) ) ; setresult ( result_canceled ) ; startactivity ( register ) ; }	starts and activity to open the ' new account ' page in the owncloud web site.
private void registerextravalidsubject ( string subject ) { extravalidsubjects . add ( subject ) ; restoredstatements . addall ( unknownsubjects . removeall ( subject ) ) ; }	register an extra valid subject.
public static string trimline ( string line ) { int idx = line . indexof ( _str ) ; if ( idx != - _num ) { line = line . substring ( _num , idx ) ; } return line . trim ( ) ; }	trims a line and removes comments.
public double distance2 ( double p1 , double p2 ) { return ( p1 - p2 ) * ( p1 - p2 ) ; }	calculates the square of the euclidean distance between two 1d points represented by real values .
public static void appendinstruction ( offlowmod . builder fmb , ofinstruction inst ) { list < ofinstruction > newil = new arraylist < ofinstruction > ( ) ; list < ofinstruction > oldil = fmb . getinstructions ( ) ; if ( oldil != null ) { newil . addall ( fmb . getinstructions ( ) ) ; } for ( ofinstruction i : newil ) { if ( i . gettype ( ) == inst . gettype ( ) ) { newil . remove ( i ) ; } } newil . add ( inst ) ; fmb . setinstructions ( newil ) ; }	adds the instructions to the list of ofinstructions in the offlowmod.
public iterator < t > iterator ( ) { return orderlist . iterator ( ) ; }	non - thread safe iterator.
private void verifydomainsisnotinuse ( stringset domains ) { checkforactivetenantsusingdomains ( domains ) ; checkforvdcrolesusingdomains ( domains ) ; checkfortenantrolesusingdomains ( domains ) ; checkforusergroupsusingdomains ( domains ) ; }	check if given domains are in use or not , if any of them is in use , throw exception .
private hashtable < ipoint , list < icircle > > filter ( hashtable < ipoint , icircle [ ] > circleintersections ) { hashtable < ipoint , list < icircle > > real = new hashtable < ipoint , list < icircle > > ( ) ; for ( ipoint pt : circleintersections . keyset ( ) ) { icircle [ ] circs = circleintersections . get ( pt ) ; for ( int i = _num ; i < circs . length - _num ; i ++ ) { for ( int j = i + _num ; j < circs . length ; j ++ ) { ipoint [ ] pts = intersects ( circs [ i ] , circs [ j ] ) ; if ( pts != null ) { for ( ipoint p : pts ) { report ( real , p , circs [ i ] , circs [ j ] ) ; } } } } } return real ; }	this method implements the algebraic intersection detection method to determine whether the circles are actually intersecting.
public void initwithoutjunitforfixture ( class fixture , method method ) { this . testclass = fixture ; this . testmethodname = method . getname ( ) ; }	initializes matsimtestutils without requiring the method of a class to be a junit test.
protected javatype findserializationtype ( annotated a , boolean usestatictyping , javatype declaredtype ) { class < ? > serclass = _annotationintrospector . findserializationtype ( a ) ; if ( serclass != null ) { class < ? > rawdeclared = declaredtype . getrawclass ( ) ; if ( serclass . isassignablefrom ( rawdeclared ) ) { declaredtype = declaredtype . widenby ( serclass ) ; } else { if ( ! rawdeclared . isassignablefrom ( serclass ) ) { throw new illegalargumentexception ( _str + a . getname ( ) + _str + serclass . getname ( ) + _str + rawdeclared . getname ( ) ) ; } declaredtype = _config . constructspecializedtype ( declaredtype , serclass ) ; } usestatictyping = _bool ; } javatype secondary = beanserializerfactory . modifysecondarytypesbyannotation ( _config , a , declaredtype ) ; if ( secondary != declaredtype ) { usestatictyping = _bool ; declaredtype = secondary ; } if ( ! usestatictyping ) { jsonserialize . typing typing = _annotationintrospector . findserializationtyping ( a ) ; if ( typing != null ) { usestatictyping = ( typing == jsonserialize . typing . static ) ; } } return usestatictyping ? declaredtype : null ; }	method that will try to determine statically defined type of property being serialized , based on annotations ( for overrides ) , and alternatively declared type ( if static typing for serialization is enabled ).
private static void convert ( ascene scene , inputstream in , outputstream out ) throws ioexception , defexception , parseexception { indexunit iu = javaparser . parse ( in ) ; extractscene ( iu , scene ) ; try ( writer w = new bufferedwriter ( new outputstreamwriter ( out ) ) ) { indexfilewriter . write ( scene , w ) ; } }	augment given scene with information from stubfile , reading stubs from input stream and writing jaif to output stream .
public static < k , v > map < k , v > of ( k k1 , v v1 , k k2 , v v2 ) { map map = of ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; return map ; }	returns map containing the given entries .
@ override public void write ( char [ ] chr ) throws ioexception { out . write ( chr ) ; }	write the characters from an array .
public static void load ( marytts . modules . synthesis . voice maryvoice ) throws nosuchpropertyexception { if ( mary2freettsvoices == null ) mary2freettsvoices = new hashmap < marytts . modules . synthesis . voice , com . sun . speech . freetts . voice > ( ) ; if ( freetts2maryvoices == null ) freetts2maryvoices = new hashmap < com . sun . speech . freetts . voice , marytts . modules . synthesis . voice > ( ) ; if ( mary2freettsvoices . containskey ( maryvoice ) ) return ; load ( maryvoice , createfreettsvoice ( maryvoice ) ) ; }	add a freetts voice for a given mary voice.
public void append ( int key , double value ) { if ( msize != _num && key <= mkeys [ msize - _num ] ) { put ( key , value ) ; return ; } int pos = msize ; if ( pos >= mkeys . length ) { int n = arrayutils . idealintarraysize ( pos + _num ) ; int [ ] nkeys = new int [ n ] ; double [ ] nvalues = new double [ n ] ; system . arraycopy ( mkeys , _num , nkeys , _num , mkeys . length ) ; system . arraycopy ( mvalues , _num , nvalues , _num , mvalues . length ) ; mkeys = nkeys ; mvalues = nvalues ; } mkeys [ pos ] = key ; mvalues [ pos ] = value ; msize = pos + _num ; }	puts a key / value pair into the array , optimizing for the case where the key is greater than all existing keys in the array .
public synchronized void addincrementalclassifierlistener ( incrementalclassifierlistener cl ) { m_incrementalclassifierlisteners . add ( cl ) ; }	add an incremental classifier listener.
public float readr4 ( ) throws java . io . ioexception { return float . intbitstofloat ( ( int ) readdword ( ) ) ; }	reads an r4 from the file and returns it in a float.
public collection enginegeneratecertificates ( inputstream instream ) throws certificateexception { java . security . cert . certificate cert ; list certs = new arraylist ( ) ; while ( ( cert = enginegeneratecertificate ( instream ) ) != null ) { certs . add ( cert ) ; } return certs ; }	returns a ( possibly empty ) collection view of the certificates read from the given input stream instream .
public static boolean filesexistondestbutnotsrc ( configuration conf , path src , path dest , optional < pathfilter > filter ) throws ioexception { set < filestatus > srcfilestatuses = getfilestatusesrecursive ( conf , src , filter ) ; set < filestatus > destfilestatuses = getfilestatusesrecursive ( conf , dest , filter ) ; map < string , long > srcfilesizes = null ; map < string , long > destfilesizes = null ; try { srcfilesizes = getrelpathtosizes ( src , srcfilestatuses ) ; destfilesizes = getrelpathtosizes ( dest , destfilestatuses ) ; } catch ( argumentexception e ) { throw new ioexception ( _str , e ) ; } for ( string file : destfilesizes . keyset ( ) ) { if ( ! srcfilesizes . containskey ( file ) ) { log . warn ( string . format ( _str , file , dest , src ) ) ; return _bool ; } } return _bool ; }	checks to see if filenames exist on a destination directory that don ' t exist in the source directory.
protected void convertorder ( sqlselect select , blackboard bb , relcollation collation , list < sqlnode > orderexprlist , sqlnode offset , sqlnode fetch ) { if ( select . getorderlist ( ) == null || select . getorderlist ( ) . getlist ( ) . isempty ( ) ) { assert collation . getfieldcollations ( ) . isempty ( ) ; if ( ( offset == null || ( ( sqlliteral ) offset ) . bigdecimalvalue ( ) . equals ( bigdecimal . zero ) ) && fetch == null ) { return ; } } bb . setroot ( logicalsort . create ( bb . root , collation , offset == null ? null : convertexpression ( offset ) , fetch == null ? null : convertexpression ( fetch ) ) , _bool ) ; if ( orderexprlist . size ( ) > _num && ! bb . top ) { final list < rexnode > exprs = new arraylist < > ( ) ; final reldatatype rowtype = bb . root . getrowtype ( ) ; final int fieldcount = rowtype . getfieldcount ( ) - orderexprlist . size ( ) ; for ( int i = _num ; i < fieldcount ; i ++ ) { exprs . add ( rexbuilder . makeinputref ( bb . root , i ) ) ; } bb . setroot ( logicalproject . create ( bb . root , exprs , rowtype . getfieldnames ( ) . sublist ( _num , fieldcount ) ) , _bool ) ; } }	converts a query ' s order by clause , if any .
public void tickblock ( blockpos pos ) { list < blockpos > validcoords = new arraylist < > ( ) ; for ( int xoffset = - tick_range ; xoffset <= tick_range ; xoffset ++ ) { for ( int zoffset = - tick_range ; zoffset <= tick_range ; zoffset ++ ) { if ( xoffset == _num && zoffset == _num ) continue ; if ( isvalidswapposition ( pos . add ( xoffset , _num , zoffset ) ) ) validcoords . add ( pos . add ( xoffset , _num , zoffset ) ) ; } } if ( ! validcoords . isempty ( ) && ! world . isremote ) { blockpos toswap = validcoords . get ( rand . nextint ( validcoords . size ( ) ) ) ; world . setblockstate ( toswap , statetoset , _num | _num ) ; } }	tick a specific block position , finding the valid blocks immediately adjacent to it and then replacing one at random .
public synchronized int updatepurchase ( string orderid , string productid , purchasestate purchasestate , long purchasetime , string developerpayload ) { insertorder ( orderid , productid , purchasestate , purchasetime , developerpayload ) ; cursor cursor = mdb . query ( purchase_history_table_name , history_columns , history_product_id_col + _str , new string [ ] { productid } , null , null , null , null ) ; if ( cursor == null ) { return _num ; } int quantity = _num ; try { while ( cursor . movetonext ( ) ) { int stateindex = cursor . getint ( _num ) ; purchasestate state = purchasestate . valueof ( stateindex ) ; if ( state == purchasestate . purchased || state == purchasestate . refunded ) { quantity += _num ; } } updatepurchaseditem ( productid , quantity ) ; } finally { if ( cursor != null ) { cursor . close ( ) ; } } return quantity ; }	adds the given purchase information to the database and returns the total number of times that the given product has been purchased .
private void configuremessagelabel ( jlabel label ) { color color = ( color ) defaultlookup . get ( optionpane , this , _str ) ; if ( color != null ) { label . setforeground ( color ) ; } font messagefont = ( font ) defaultlookup . get ( optionpane , this , _str ) ; if ( messagefont != null ) { label . setfont ( messagefont ) ; } }	configures any necessary colors / fonts for the specified label used representing the message .
public void removealllimitlines ( ) { mlimitlines . clear ( ) ; }	removes all limitlines from the axis .
default filterable < t > removeall ( final stream < ? extends t > stream ) { final set < t > set = stream . collect ( collectors . toset ( ) ) ; return filternot ( null ) ; }	remove all elements in the supplied stream from this filterable.
private static meteringrectangle [ ] regionsfornormalizedcoord ( float nx , float ny , float fraction , final rect cropregion , int sensororientation ) { int mincropedge = math . min ( cropregion . width ( ) , cropregion . height ( ) ) ; int halfsidelength = ( int ) ( _num * fraction * mincropedge ) ; pointf nsc = camerautil . normalizedsensorcoordsfornormalizeddisplaycoords ( nx , ny , sensororientation ) ; int xcentersensor = ( int ) ( cropregion . left + nsc . x * cropregion . width ( ) ) ; int ycentersensor = ( int ) ( cropregion . top + nsc . y * cropregion . height ( ) ) ; rect meteringregion = new rect ( xcentersensor - halfsidelength , ycentersensor - halfsidelength , xcentersensor + halfsidelength , ycentersensor + halfsidelength ) ; meteringregion . left = camerautil . clamp ( meteringregion . left , cropregion . left , cropregion . right ) ; meteringregion . top = camerautil . clamp ( meteringregion . top , cropregion . top , cropregion . bottom ) ; meteringregion . right = camerautil . clamp ( meteringregion . right , cropregion . left , cropregion . right ) ; meteringregion . bottom = camerautil . clamp ( meteringregion . bottom , cropregion . top , cropregion . bottom ) ; return new meteringrectangle [ ] { new meteringrectangle ( meteringregion , camera2_region_weight ) } ; }	compute 3a regions for a sensor - referenced touch coordinate.
@ override public void flush ( ) throws ioexception { flushbuffer ( ) ; _outputstream . flush ( ) ; }	flushes the stream . if the stream has saved any characters from the various write ( ) methods in a buffer , write them immediately to their intended destination . then , if that destination is another character or byte stream , flush it . thus one flush ( ) invocation will flush all the buffers in a chain of writers and outputstreams .
public vector ( double comp [ ] ) throws negativearraysizeexception { int n = comp . length ; if ( n <= _num ) throw new negativearraysizeexception ( _str ) ; components = new double [ n ] ; system . arraycopy ( comp , _num , components , _num , n ) ; }	create a vector of given dimension.
@ override public void visitinnerclass ( final string aname , final string outername , final string innername , final int attr_access ) { if ( ( name != null ) && name . equals ( aname ) ) { this . access = attr_access ; } super . visitinnerclass ( aname , outername , innername , attr_access ) ; }	handle a bizarre special case.
public long lontopixel ( double lon ) { return ( long ) ( ( lon + _num ) / _num * math . pow ( _num , zoom ) * _num ) ; }	convert longitude to pixel value.
public static boolean worldfilevaluesappeargeographic ( avlist values ) { double xlocation ; double ylocation ; double xpixelsize ; double ypixelsize ; object o = values . getvalue ( world_file_x_location ) ; if ( o != null && o instanceof double ) xlocation = ( double ) o ; else return _bool ; o = values . getvalue ( world_file_y_location ) ; if ( o != null && o instanceof double ) ylocation = ( double ) o ; else return _bool ; o = values . getvalue ( world_file_x_pixel_size ) ; if ( o != null && o instanceof double ) xpixelsize = ( double ) o ; else return _bool ; o = values . getvalue ( world_file_y_pixel_size ) ; if ( o != null && o instanceof double ) ypixelsize = ( double ) o ; else return _bool ; return ( angle . isvalidlongitude ( xpixelsize ) && angle . isvalidlatitude ( ypixelsize ) && angle . isvalidlongitude ( xlocation ) && angle . isvalidlatitude ( ylocation ) ) ; }	indicates whether world file values appear to be in latitude and longitude .
public void storeinregister ( int registernumber ) throws ioexception { print ( _str , new string [ ] { integer . tostring ( registernumber ) } ) ; }	description of the method.
public void remove ( sessionid sessionid ) { remotesessionset . remove ( sessionid ) ; }	remove a remote session .
@ override public synchronized string tostring ( ) { if ( elementcount == _num ) { return _str ; } int length = elementcount - _num ; stringbuilder buffer = new stringbuilder ( elementcount * _num ) ; buffer . append ( _str ) ; for ( int i = _num ; i < length ; i ++ ) { if ( elementdata [ i ] == this ) { buffer . append ( _str ) ; } else { buffer . append ( elementdata [ i ] ) ; } buffer . append ( _str ) ; } if ( elementdata [ length ] == this ) { buffer . append ( _str ) ; } else { buffer . append ( elementdata [ length ] ) ; } buffer . append ( _str ) ; return buffer . tostring ( ) ; }	returns the string representation of this vector .
public iterator < abstractpage > childiterator ( final boolean dirtynodesonly ) { if ( dirtynodesonly ) { return new dirtychilditerator ( this ) ; } else { return new childiterator ( ) ; } }	iterator visits the direct child nodes in the external key ordering .
public void enable ( ) throws ioexception { synchronized ( optoutlock ) { if ( isoptout ( ) ) { configuration . set ( _str , _bool ) ; configuration . save ( configurationfile ) ; } if ( task == null ) { start ( ) ; } } }	enables metrics for the server by setting " opt - out " to false in the config file and starting the metrics task .
public hmact64 ( byte [ ] key ) { super ( _str ) ; int length = math . min ( key . length , block_length ) ; for ( int i = _num ; i < length ; i ++ ) { ipad [ i ] = ( byte ) ( key [ i ] ^ ipad ) ; opad [ i ] = ( byte ) ( key [ i ] ^ opad ) ; } for ( int i = length ; i < block_length ; i ++ ) { ipad [ i ] = ipad ; opad [ i ] = opad ; } try { md5 = messagedigest . getinstance ( _str ) ; } catch ( exception ex ) { throw new illegalstateexception ( ex . getmessage ( ) ) ; } enginereset ( ) ; }	creates an hmact64 instance which uses the given secret key material .
public boolean startswith ( string string ) { if ( string == null ) return _bool ; int strlen = string . length ( ) ; if ( _length < strlen ) return _bool ; char [ ] buffer = _buffer ; int offset = _offset ; while ( -- strlen >= _num ) { if ( buffer [ offset + strlen ] != string . charat ( strlen ) ) return _bool ; } return _bool ; }	returns true if the charsegment starts with the string .
private void writerawbytesinternal ( final bytebuffer value ) throws ioexception { int length = value . remaining ( ) ; if ( limit - position >= length ) { value . get ( buffer , position , length ) ; position += length ; totalbyteswritten += length ; } else { final int byteswritten = limit - position ; value . get ( buffer , position , byteswritten ) ; length -= byteswritten ; position = limit ; totalbyteswritten += byteswritten ; refreshbuffer ( ) ; while ( length > limit ) { value . get ( buffer , _num , limit ) ; output . write ( buffer , _num , limit ) ; length -= limit ; totalbyteswritten += limit ; } value . get ( buffer , _num , length ) ; position = length ; totalbyteswritten += length ; } }	write a bytebuffer that isn ' t backed by an array .
public boolean issrcclass ( sootclass clz ) { return srcclasses . contains ( clz . getname ( ) ) ; }	return true if the class was loaded from the application src / directory .
private void processldif ( connection conn , string path ) throws upgradeexception { changerecordreader reader = null ; try { if ( debug . messageenabled ( ) ) { debug . message ( _str + path ) ; } map < string , string > tags = new hashmap < string , string > ( _num ) ; tags . put ( _str , basedn ) ; tags . put ( _str , _str ) ; string content = amsetupservlet . readfile ( path ) ; string tagswapped = stringutils . tagswap ( content , tags ) ; reader = new ldifchangerecordreader ( new bytearrayinputstream ( tagswapped . getbytes ( charset . forname ( _str ) ) ) ) ; changerecordwriter writer = new connectionchangerecordwriter ( conn ) ; while ( reader . hasnext ( ) ) { writer . writechangerecord ( reader . readchangerecord ( ) ) ; } } catch ( ioexception ioe ) { debug . error ( _str + path , ioe ) ; throw new upgradeexception ( ioe ) ; } finally { ioutils . closeifnotnull ( reader ) ; } }	reads in the ldif file , and writes the changerecords on the ldap connection .
private void printprogress ( long row , long rowfrom , long rowtill ) { long rowsprocessed = row + chunksize - rowfrom ; if ( rowsprocessed > ( rowtill - rowfrom ) ) rowsprocessed = ( rowtill - rowfrom ) ; print ( string . format ( _str , ( int ) ( ( ( double ) ( rowsprocessed ) / ( double ) ( rowtill - rowfrom ) ) * _num ) ) ) ; }	render ( print ) progress bar .
void postremotereleaselock ( object objectname ) throws interruptedexception { if ( ! acquiredestroyreadlock ( _num ) ) { return ; } try { checkdestroyed ( ) ; drainpermittedrequests ( ) ; grantlock ( objectname ) ; } catch ( lockservicedestroyedexception e ) { } catch ( lockgrantordestroyedexception e ) { } finally { releasedestroyreadlock ( ) ; } }	drain currently permitted requests and grant lock to next requestor.
public final arraylist < positionrecord > loadpositions ( final int session , final double minlat , final double maxlat , final double minlon , final double maxlon ) { final arraylist < positionrecord > positions = new arraylist < > ( ) ; string selection = schema . col_session_id + _str ; cursor cursor = null ; list < string > selectionargs = null ; if ( minlat != null & maxlat != null && minlon != null && maxlon != null ) { selectionargs = new arraylist < > ( ) ; selectionargs . add ( string . valueof ( session ) ) ; selectionargs . add ( string . valueof ( minlat ) ) ; selectionargs . add ( string . valueof ( maxlat ) ) ; selectionargs . add ( string . valueof ( minlon ) ) ; selectionargs . add ( string . valueof ( maxlon ) ) ; selection += _str + schema . col_latitude + _str + schema . col_latitude + _str + schema . col_longitude + _str + schema . col_longitude + _str ; cursor = contentresolver . query ( contentprovider . content_uri_position , null , selection , selectionargs . toarray ( new string [ _num ] ) , schema . col_timestamp ) ; } else { log . v ( tag , _str ) ; cursor = contentresolver . query ( contentprovider . content_uri_position , null , null , null , schema . col_timestamp ) ; } while ( cursor . movetonext ( ) ) { positions . add ( positionfromcursor ( cursor ) ) ; } cursor . close ( ) ; return positions ; }	loads positions within certain arrea.
public static checkbox createtoggle ( string text , image icon ) { checkbox cb = new checkbox ( text , icon ) ; cb . settoggle ( _bool ) ; return cb ; }	shorthand for creating the check box setting the icon / text and making it into a toggle button.
public long addcompletedbatch ( requestbatch requestbatch ) { long completedbatchid = insertbatchascompleted ( requestbatch ) ; for ( request request : requestbatch . getrequests ( ) ) { request . setbatchid ( completedbatchid ) ; file file = new file ( request . getdestinationpath ( ) ) ; long length = file . exists ( ) ? file . length ( ) : _num ; insertrequestascompleteddownload ( request . getdestinationpath ( ) , length , request ) ; } return completedbatchid ; }	adds this batch to the downloads system .
@ targetapi ( build . version_codes . jelly_bean ) private void dequeueoutputbuffer ( mediacodec codec , bytebuffer [ ] outputbuffers , int index , mediacodec . bufferinfo info ) { if ( build . version . sdk_int >= build . version_codes . jelly_bean ) { bytebuffer buffer = outputbuffers [ index ] ; log . i ( _str + info . size + _str + buffer . remaining ( ) ) ; if ( info . size <= buffer . remaining ( ) ) { final byte [ ] buffercopied = new byte [ info . size ] ; buffer . get ( buffercopied ) ; codec . releaseoutputbuffer ( index , _bool ) ; addencoded ( buffercopied ) ; if ( log . debug ) { audioutils . showsomebytes ( _str , buffercopied ) ; } } else { log . e ( _str ) ; codec . releaseoutputbuffer ( index , _bool ) ; } } }	save the encoded ( output ) buffer into the complete encoded recording . todo : copy directly ( without the intermediate byte array ).
public static defaultjobdefinition retryablefixeddelayjobdefinition ( final string jobtype , final string jobname , final string description , final duration fixeddelay , final int restarts , final int retries , final optional < duration > retrydelay , final optional < duration > maxage ) { return new defaultjobdefinition ( jobtype , jobname , description , maxage , optional . of ( fixeddelay ) , optional . empty ( ) , restarts , retries , retrydelay ) ; }	create a jobdefinition that is using fixed delays specify , when and how often the job should be triggered .
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return message ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public static void putlong ( long addr , long val ) { if ( unaligned ) unsafe . putlong ( addr , val ) ; else putlongbybyte ( addr , val , big_endian ) ; }	stores given integer value.
public static file createminimalsplit ( string inputfolder , int numfolds , int numavailablejcas , boolean issequence ) throws exception { file outputfolder = new file ( inputfolder , _str ) ; int splitnum = ( int ) math . ceil ( numfolds / ( double ) numavailablejcas ) ; collectionreaderdescription createreader = collectionreaderfactory . createreaderdescription ( binarycasreader . class , binarycasreader . param_source_location , inputfolder , binarycasreader . param_patterns , _str ) ; analysisenginedescription multiplier = analysisenginefactory . createenginedescription ( foldclassificationunitcasmultiplier . class , foldclassificationunitcasmultiplier . param_requested_splits , splitnum , foldclassificationunitcasmultiplier . param_use_sequences , issequence ) ; analysisenginedescription xmiwriter = analysisenginefactory . createenginedescription ( binarycaswriter . class , binarycaswriter . param_target_location , outputfolder . getabsolutepath ( ) , binarycaswriter . param_format , _str ) ; analysisenginedescription both = analysisenginefactory . createenginedescription ( multiplier , xmiwriter ) ; simplepipeline . runpipeline ( createreader , both ) ; isnumberofcascreatedlargerequalnumfolds ( outputfolder , numfolds ) ; return outputfolder ; }	takes the available cas and creates more cases from them to conform to the minimal requested amount of cas objects to have sufficient for running a cross - validation.
public org . w3c . dom . element signxml ( org . w3c . dom . document doc , java . lang . string certalias ) throws xmlsignatureexception { return signxml ( doc , certalias , null ) ; }	sign the xml document using enveloped signatures .
public boolean displaypopup ( ) { if ( m_popupclass == null ) return _bool ; try { window win = swingutilities . getwindowancestor ( this ) ; cfieldpopup popup = null ; if ( win instanceof dialog ) { constructor < ? > constructor = m_popupclass . getconstructor ( new class < ? > [ ] { dialog . class , string . class , boolean . class } ) ; popup = ( cfieldpopup ) constructor . newinstance ( new object [ ] { ( dialog ) win , m_title , new boolean ( _bool ) } ) ; } else if ( win instanceof frame ) { constructor < ? > constructor = m_popupclass . getconstructor ( new class [ ] { frame . class , string . class , boolean . class } ) ; popup = ( cfieldpopup ) constructor . newinstance ( new object [ ] { ( frame ) win , m_title , new boolean ( _bool ) } ) ; } if ( popup == null ) return _bool ; popup . setvalue ( m_editor . getitem ( ) ) ; popup . setformat ( m_editor . getformat ( ) ) ; popup . show ( ) ; m_editor . setitem ( popup . getvalue ( ) ) ; popup = null ; } catch ( exception e ) { notifyuser ( e ) ; } return _bool ; }	display popup . called from adempierecombopopup and allows to implement alternative actions than showing the popup.
public abstractsdfwriter ( final prereadtype prereadtype , final boolean hasquality , boolean hasnames , boolean compressed , final sequencetype type ) { mprereadtype = prereadtype ; mprereadarm = prereadarm . unknown ; msdfid = new sdfid ( ) ; mnamehandler = new sequencenamehandler ( ) ; msequencetype = type ; mfirstvalid = msequencetype . firstvalid ( ) ; mresiduecounts = new long [ msequencetype . numberknowncodes ( ) + msequencetype . firstvalid ( ) ] ; mnhistogram = new long [ max_histogram ] ; mposhistogram = new long [ max_histogram ] ; mqsaverageperpos = new double [ max_histogram ] ; mpositioncounts = new long [ max_histogram ] ; mglobalqsaverage = _num ; mdatahashfunction = new prereadhashfunction ( ) ; mqualityhashfunction = new prereadhashfunction ( ) ; mnamehashfunction = new prereadhashfunction ( ) ; mnamesuffixhashfunction = new prereadhashfunction ( ) ; mhasquality = hasquality ; mhasnames = hasnames ; mcompressed = compressed ; mseqdatachecksum = new crc32 ( ) ; mqualdatachecksum = new crc32 ( ) ; }	creates a writer for processing sequences from provided data source .
firingplan guessbestfiringplanunderheat ( entity shooter , @ nullable entitystate shooterstate , targetable target , @ nullable entitystate targetstate , int maxheat , igame game ) { if ( maxheat < _num ) { maxheat = _num ; } firingplan alphastrike = guessfullfiringplan ( shooter , shooterstate , target , targetstate , game ) ; if ( alphastrike . getheat ( ) <= maxheat && ! ( shooter instanceof infantry ) && ! ( shooter instanceof battlearmor ) ) { return alphastrike ; } firingplan heatplans [ ] = calcfiringplansunderheat ( shooter , alphastrike ) ; arrays . sort ( heatplans ) ; if ( heatplans . length > _num ) { return heatplans [ _num ] ; } else { return new firingplan ( target ) ; } }	guesses the ' best ' firing plan under a certain heat no twisting is done.
public static volumegrouprestrep map ( volumegroup from ) { if ( from == null ) { return null ; } volumegrouprestrep rep = new volumegrouprestrep ( ) ; mapdataobjectfields ( from , rep ) ; rep . setdescription ( from . getdescription ( ) ) ; rep . setroles ( from . getroles ( ) ) ; rep . setparent ( torelatedresource ( resourcetypeenum . volume_group , from . getparent ( ) ) ) ; rep . setmigrationgroupby ( from . getmigrationgroupby ( ) ) ; rep . setmigrationtype ( from . getmigrationtype ( ) ) ; return rep ; }	map an volumegroup to volumegrouprestrep.
public int postfiles ( string [ ] args , int startindexinargs , outputstream out , string type ) { reset ( ) ; int filesposted = _num ; for ( int j = startindexinargs ; j < args . length ; j ++ ) { file srcfile = new file ( args [ j ] ) ; if ( srcfile . isdirectory ( ) && srcfile . canread ( ) ) { filesposted += postdirectory ( srcfile , out , type ) ; } else if ( srcfile . isfile ( ) && srcfile . canread ( ) ) { filesposted += postfiles ( new file [ ] { srcfile } , out , type ) ; } else { file parent = srcfile . getparentfile ( ) ; if ( parent == null ) parent = new file ( _str ) ; string fileglob = srcfile . getname ( ) ; globfilefilter ff = new globfilefilter ( fileglob , _bool ) ; file [ ] files = parent . listfiles ( ff ) ; if ( files == null || files . length == _num ) { warn ( _str + srcfile ) ; continue ; } filesposted += postfiles ( parent . listfiles ( ff ) , out , type ) ; } } return filesposted ; }	post all filenames provided in args.
public void clearsearchable ( ) { searchables . clear ( ) ; }	clear all searchable items.
public void addactionlistener ( actionlistener newlistener ) { m_listeners . add ( newlistener ) ; }	register a listener to be notified when plotting completes.
@ deprecated public shapelessrecipe addingredient ( int count , material ingredient , int rawdata ) { validate . istrue ( ingredients . size ( ) + count <= _num , _str ) ; if ( rawdata == - _num ) { rawdata = short . max_value ; } while ( count -- > _num ) { ingredients . add ( new itemstack ( ingredient , _num , ( short ) rawdata ) ) ; } return this ; }	adds multiples of the specified ingredient .
public string order ( ) { return morderby . length ( ) > _num ? morderby . tostring ( ) : null ; }	returns the order string produced by this object .
static axeswalker findclone ( axeswalker key , vector clonelist ) { if ( null != clonelist ) { int n = clonelist . size ( ) ; for ( int i = _num ; i < n ; i += _num ) { if ( key == clonelist . elementat ( i ) ) return ( axeswalker ) clonelist . elementat ( i + _num ) ; } } return null ; }	find a clone that corresponds to the key argument .
public static byte [ ] encodingtobytes ( final string str , final string encoding ) { if ( str == null ) { return null ; } try { return str . getbytes ( encoding ) ; } catch ( final unsupportedencodingexception e ) { throw new error ( encoding + _str + e ) ; } }	convert a string to a byte array using the specified encoding .
public static boolean lookslikeabgrepeat ( string val ) { return background_repeats . indexof ( val ) >= _num ; }	description of the method.
public void before ( ) throws throwable { if ( build . version . sdk_int >= build . version_codes . m ) { processbuilder processbuilder = new processbuilder ( ) ; processbuilder . command ( _str , _str ) ; processbuilder . redirecterrorstream ( ) ; process process = processbuilder . start ( ) ; process . waitfor ( ) ; if ( process . exitvalue ( ) != _num ) { log . e ( log_tag , _str + process . exitvalue ( ) ) ; } } }	clear logcat buffer prior to test run .
public void addmeta ( char meta , string replacement ) { metacharacterset . set ( meta ) ; replacementmap . put ( new string ( new char [ ] { meta } ) , replacement ) ; }	add a metacharacter and its replacement .
private matches lookupdo ( template tmpl , int maxmatches ) { if ( maxmatches < _num ) throw new illegalargumentexception ( _str ) ; int totalmatches = _num ; arraylist matches = null ; itemiter iter = matchingitems ( tmpl ) ; if ( maxmatches > _num || iter . dupspossible ) matches = new arraylist ( ) ; if ( iter . dupspossible ) { while ( iter . hasnext ( ) ) { item item = iter . next ( ) ; if ( ! matches . contains ( item ) ) matches . add ( item ) ; } totalmatches = matches . size ( ) ; if ( maxmatches > _num ) { for ( int i = matches . size ( ) ; -- i >= maxmatches ; ) matches . remove ( i ) ; for ( int i = matches . size ( ) ; -- i >= _num ; ) { matches . set ( i , copyitem ( ( item ) matches . get ( i ) ) ) ; } } else { matches = null ; } } else { while ( iter . hasnext ( ) ) { item item = iter . next ( ) ; totalmatches ++ ; if ( -- maxmatches >= _num ) matches . add ( copyitem ( item ) ) ; } } return new matches ( matches , totalmatches ) ; }	the code that does the real work of lookup.
public static list < history > findhistorybyjob ( entitymanager em , jpaentity job , biginteger limit ) { requireargument ( em != null , _str ) ; requireargument ( job != null , _str ) ; typedquery < history > query = em . createnamedquery ( _str , history . class ) ; if ( limit != null ) { query . setmaxresults ( limit . intvalue ( ) ) ; } try { query . setparameter ( _str , job ) ; return query . getresultlist ( ) ; } catch ( noresultexception ex ) { return new arraylist < history > ( _num ) ; } }	finds all history records for the given job .
public static string quote ( char ch ) { switch ( ch ) { case _str : return _str ; case _str : return _str ; case _str : return _str ; case _str : return _str ; case _str : return _str ; case _str : return _str ; case _str : return _str ; case _str : return _str ; default : return ( isprintableascii ( ch ) ) ? string . valueof ( ch ) : string . format ( _str , ( int ) ch ) ; } }	escapes a character if it has an escape sequence or is non - printable ascii.
private void updatependingnodes ( final int newlandmarkindex , final routerpriorityqueue < node > pendingnodes ) { final list < double > newestremtravcosts = new arraylist < > ( ) ; final list < node > nodestobeupdated = new arraylist < > ( ) ; final internallandmarkdata landmarkdata = new internallandmarkdata ( ) ; for ( node node : pendingnodes ) { final astarnodedata role = getdata ( node ) ; final preprocesslandmarks . landmarksdata pprole = preprocess . getnodedata ( node ) ; landmarkdata . setdelegate ( pprole ) ; final double newestremtravcost = estimateremainingtravelcost ( landmarkdata , newlandmarkindex ) ; if ( newestremtravcost > role . getexpectedremainingcost ( ) ) { nodestobeupdated . add ( node ) ; newestremtravcosts . add ( newestremtravcost ) ; } } for ( node node : nodestobeupdated ) { pendingnodes . remove ( node ) ; } for ( int i = _num ; i < nodestobeupdated . size ( ) ; i ++ ) { final node node = nodestobeupdated . get ( i ) ; final astarnodedata data = getdata ( node ) ; data . setexpectedremainingcost ( newestremtravcosts . get ( i ) ) ; pendingnodes . add ( node , getpriority ( data ) ) ; } }	if a landmark has been added to the set of the active landmarks , this function re - evaluates the estimated remaining travel time based on the new set of active landmarks of the nodes contained in pendingnodes.
@ override public string tostring ( ) { stringbuffer buff = new stringbuffer ( ) ; if ( m_correlations == null ) { buff . append ( _str ) ; } else { buff . append ( _str ) ; if ( m_detailedoutput && m_detailedoutputbuff . length ( ) > _num ) { buff . append ( _str ) ; buff . append ( m_detailedoutputbuff ) ; } } return buff . tostring ( ) ; }	describe the attribute evaluator.
private void drawoverflowindicator ( final graphics g , int maxx ) { int width = _num ; int height = _num ; int xoffset = _num ; int stepsize = width / _num ; int dotsize = _num ; int x = maxx - width - xoffset ; int y = button . getsize ( ) . height - height ; g . setcolor ( lighter_gray ) ; g . fillrect ( x , y , width , width ) ; g . setcolor ( color . gray ) ; g . drawroundrect ( x , y , width , width , _num , _num ) ; g . setcolor ( color . black ) ; g . filloval ( x + stepsize , y + _num , dotsize , dotsize ) ; g . filloval ( x + stepsize * _num , y + _num , dotsize , dotsize ) ; g . filloval ( x + stepsize * _num , y + _num , dotsize , dotsize ) ; g . dispose ( ) ; }	draws indicator in case the expression text overflows on the y axis .
public void writeline ( long time , float [ ] column ) { string str = long . tostring ( time ) ; for ( int i = _num ; i < column . length ; ++ i ) { str += _str + column [ i ] ; } writer . println ( str ) ; }	write a line of values to the file with a timestamp.
public static boolean ispem ( inputstream is ) { try { string startpem = _str ; int headerlength = _num ; byte [ ] preamble = new byte [ headerlength ] ; if ( is . read ( preamble , _num , headerlength ) > _num ) { string startarray = new string ( preamble ) ; return startarray . startswith ( startpem ) ; } return _bool ; } catch ( exception e ) { throw new dssexception ( _str ) ; } }	this method returns true if the inputstream contains a pem encoded item.
public closelistener ( object resource ) { _resource = resource ; }	creates the new close listener .
@ override public indexrequest routing ( string routing ) { if ( routing != null && routing . length ( ) == _num ) { this . routing = null ; } else { this . routing = routing ; } return this ; }	controls the shard routing of the request.
public byte [ ] receive ( ) throws networkexception { try { packet . setlength ( datagramconnection . default_datagram_size ) ; connection . receive ( packet ) ; int packetlength = packet . getlength ( ) ; byte [ ] data = new byte [ packetlength ] ; system . arraycopy ( packet . getdata ( ) , _num , data , _num , packetlength ) ; return data ; } catch ( ioexception e ) { throw new networkexception ( _str , e ) ; } }	receive data with a specific buffer size.
@ override protected void forcedeleteattributeat ( int position ) { double [ ] newvalues = new double [ m_attvalues . length - _num ] ; system . arraycopy ( m_attvalues , _num , newvalues , _num , position ) ; if ( position < m_attvalues . length - _num ) { system . arraycopy ( m_attvalues , position + _num , newvalues , position , m_attvalues . length - ( position + _num ) ) ; } m_attvalues = newvalues ; }	deletes an attribute at the given position ( 0 to numattributes ( ) - 1 ) .
public synchronized alphabeticindex addlabels ( locale locale ) { addlabels ( peer , locale . tostring ( ) ) ; return this ; }	adds the index characters from the given locale to the index.
protected byte [ ] enginewrap ( key key ) throws illegalblocksizeexception , invalidkeyexception { throw new unsupportedoperationexception ( ) ; }	wrap a key . < p > this concrete method has been added to this previously - defined abstract class . ( for backwards compatibility , it cannot be abstract . ) it may be overridden by a provider to wrap a key . such an override is expected to throw an illegalblocksizeexception or invalidkeyexception ( under the specified circumstances ) , if the given key cannot be wrapped . if this method is not overridden , it always throws an unsupportedoperationexception .
@ deprecated public javapluginloader ( server instance ) { validate . notnull ( instance , _str ) ; server = instance ; }	this class was not meant to be constructed explicitly.
public void addseparator ( ) { if ( log . isloggable ( platformlogger . level . finer ) ) { log . finer ( _str ) ; } }	addseparator routines are not used in peers . shared code invokes additem ( " - " ) for adding separators.
public static boolean testsavelocationexists ( ) { string sdcardstatus = environment . getexternalstoragestate ( ) ; boolean status ; if ( sdcardstatus . equals ( environment . media_mounted ) ) { status = _bool ; } else { status = _bool ; } return status ; }	determine if sd card exists .
public static final list < inavirawmodule > loadrawmodules ( final abstractsqlprovider provider ) throws couldntloaddataexception { preconditions . checknotnull ( provider , _str ) ; final cconnection connection = provider . getconnection ( ) ; final list < inavirawmodule > modules = new arraylist < inavirawmodule > ( ) ; if ( ! postgresqlhelpers . hastable ( connection , ctablenames . raw_modules_table ) ) { return modules ; } final string query = _str + ctablenames . raw_modules_table + _str ; try ( resultset resultset = connection . executequery ( query , _bool ) ) { while ( resultset . next ( ) ) { final int rawmoduleid = resultset . getint ( _str ) ; final string name = postgresqlhelpers . readstring ( resultset , _str ) ; final boolean iscomplete = postgresqldatabasefunctions . checkrawmodulestables ( provider . getconnection ( ) , postgresqlhelpers . getdatabasename ( provider . getconnection ( ) ) , rawmoduleid ) ; final int functioncount = iscomplete ? postgresqldatabasefunctions . getrawmodulefunctioncount ( connection , rawmoduleid ) : _num ; final crawmodule module = new crawmodule ( rawmoduleid , name , functioncount , iscomplete , provider ) ; modules . add ( module ) ; } } catch ( final sqlexception e ) { throw new couldntloaddataexception ( e ) ; } return modules ; }	loads the raw modules of a database .
void write ( imageoutputstream ios ) throws ioexception { length = _num + data . length ; writetag ( ios ) ; ios . write ( data ) ; }	writes the data for this segment to the stream in valid jpeg format , directly from the data array .
public static int probround ( double value , random rand ) { if ( value >= _num ) { double lower = math . floor ( value ) ; double prob = value - lower ; if ( rand . nextdouble ( ) < prob ) { return ( int ) lower + _num ; } else { return ( int ) lower ; } } else { double lower = math . floor ( math . abs ( value ) ) ; double prob = math . abs ( value ) - lower ; if ( rand . nextdouble ( ) < prob ) { return - ( ( int ) lower + _num ) ; } else { return - ( int ) lower ; } } }	rounds a double to the next nearest integer value in a probabilistic fashion ( e.
map < string , typename > convertpropertiestotypes ( map < string , executableelement > properties ) { map < string , typename > types = new linkedhashmap < string , typename > ( ) ; for ( map . entry < string , executableelement > entry : properties . entryset ( ) ) { executableelement el = entry . getvalue ( ) ; types . put ( entry . getkey ( ) , typename . get ( el . getreturntype ( ) ) ) ; } return types ; }	converts the executableelement properties to typename properties.
private static list < registerdescription > parseregisterinformation ( final node node ) throws messageparserexception { final list < registerdescription > registers = new arraylist < > ( ) ; final nodelist nodes = node . getchildnodes ( ) ; for ( int i = _num ; i < nodes . getlength ( ) ; ++ i ) { final node child = nodes . item ( i ) ; final string registername = getattribute ( child , _str ) ; final string registersize = getattribute ( child , _str ) ; final string registereditable = getattribute ( child , _str ) ; registers . add ( new registerdescription ( registername , integer . valueof ( registersize ) , boolean . valueof ( registereditable ) ) ) ; } return registers ; }	parses register information from the target information string .
public namedthreadfactory ( string nameprefix ) { this . nameprefix = objects . requirenonnull ( nameprefix ) ; group = getthreadgroup ( ) ; daemon = _bool ; }	creates a daemon thread with the specified name prefix.
public void test_metric_cpu_num_uint16 ( ) { final igangliametadatamessage decl = new gangliametadatamessage ( _str , _str , _bool , gangliamessagetypeenum . uint16 , _str , _str , gangliaslopeenum . zero , _num , _num , abstractmetrics . getmap ( igangliaattributes . group_cpu , _str , _str ) ) ; assertencodedecode ( null , decl ) ; final igangliametricmessage expected = new gangliametricmessage ( gangliamessagetypeenum . uint16 , _str , _str , _bool , _str , integer . valueof ( _num ) ) ; final byte [ ] actualdata = assertencodedecode ( decl , expected ) ; final byte [ ] expecteddata = new byte [ ] { _num , _num , _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; if ( ! arrays . equals ( expecteddata , actualdata ) ) { fail ( _str + arrays . tostring ( expecteddata ) + _str + arrays . tostring ( actualdata ) ) ; } }	unit test for a cpu_num message .
public void addtransaction ( sipservertransaction servertransaction ) throws ioexception { if ( logger . isloggingenabled ( logwriter . trace_debug ) ) logger . logdebug ( _str + servertransaction ) ; servertransaction . map ( ) ; addtransactionhash ( servertransaction ) ; }	add a new server transaction to the set of existing transactions.
private void delayretry ( int multiplier ) { debug ( _str ) ; try { thread . sleep ( _num * multiplier ) ; } catch ( interruptedexception e ) { warn ( e , _str ) ; } }	dalays the current thread.
public void testsplitandjoinsemicolonnestedinpipeproperties ( ) { properties outer = propertyutils . splitpropertiesonpipe ( one_then_two_outer_a ) ; assertequals ( one_semi_two , outer . getproperty ( _str ) ) ; assertequals ( _num , outer . size ( ) ) ; try { assertequals ( one_then_two_outer_a , propertyutils . joinonpipe ( propertyutils . tomap ( outer ) ) ) ; return ; } catch ( comparisonfailure deviation1 ) { } try { assertequals ( two_then_one_outer_a , propertyutils . joinonpipe ( propertyutils . tomap ( outer ) ) ) ; return ; } catch ( comparisonfailure deviation2 ) { } try { assertequals ( one_then_two_outer_b , propertyutils . joinonpipe ( propertyutils . tomap ( outer ) ) ) ; return ; } catch ( comparisonfailure deviation3 ) { } try { assertequals ( two_then_one_outer_b , propertyutils . joinonpipe ( propertyutils . tomap ( outer ) ) ) ; return ; } catch ( comparisonfailure deviation4 ) { } assertequals ( two_then_one_outer_a , propertyutils . joinonpipe ( propertyutils . tomap ( outer ) ) ) ; }	test split and join of nested properties ( using pipe ) .
public void testintbooleanmap ( ) throws exception { objectmapper mapper = new objectmapper ( ) ; string json = _str ; map < string , integer > result = mapper . readvalue ( json , new typereference < hashmap < integer , boolean > > ( ) { } ) ; assertnotnull ( result ) ; assertequals ( hashmap . class , result . getclass ( ) ) ; assertequals ( _num , result . size ( ) ) ; assertequals ( boolean . true , result . get ( integer . valueof ( _num ) ) ) ; assertequals ( boolean . false , result . get ( integer . valueof ( - _num ) ) ) ; assertnull ( result . get ( _str ) ) ; assertnull ( result . get ( _num ) ) ; }	let ' s also check that it is possible to do type conversions to allow use of non - string map keys .
@ override public boolean isbusy ( ) { return _bool ; }	returns true if . at this time , the bean is busy with some ( i . e . perhaps a worker thread is performing some calculation ) .
protected bytearrayoutputstream parsebytes ( bytearrayoutputstream bos ) throws ioexception { int ch ; for ( ch = skipwhitespace ( ) ; ch >= _num && ch != _str ; ch = skipwhitespace ( ) ) { int b1 = ch ; int b2 = read ( ) ; int b3 = read ( ) ; int b4 = read ( ) ; if ( b4 != _str ) { int chunk = ( ( base64decode [ b1 ] << _num ) + ( base64decode [ b2 ] << _num ) + ( base64decode [ b3 ] << _num ) + ( base64decode [ b4 ] ) ) ; bos . write ( chunk > > _num ) ; bos . write ( chunk > > _num ) ; bos . write ( chunk ) ; } else if ( b3 != _str ) { int chunk = ( ( base64decode [ b1 ] << _num ) + ( base64decode [ b2 ] << _num ) + ( base64decode [ b3 ] > > _num ) ) ; bos . write ( chunk > > _num ) ; bos . write ( chunk ) ; } else { int chunk = ( ( base64decode [ b1 ] << _num ) + ( base64decode [ b2 ] > > _num ) ) ; bos . write ( chunk ) ; } } if ( ch == _str ) _peek = ch ; return bos ; }	parses a byte array .
public void reset ( ) { if ( mdownloadbandwidth != null ) { mdownloadbandwidth . reset ( ) ; } mcurrentbandwidthconnectionquality . set ( connectionquality . unknown ) ; }	resets the bandwidth average for this instance of the bandwidth manager .
public void testmergesecurityroleintoemptydocument ( ) throws exception { string srcxml = _str ; webxml srcwebxml = webxmlio . parsewebxml ( new bytearrayinputstream ( srcxml . getbytes ( _str ) ) , null ) ; string mergexml = _str + _str + _str + _str + _str ; webxml mergewebxml = webxmlio . parsewebxml ( new bytearrayinputstream ( mergexml . getbytes ( _str ) ) , null ) ; webxmlmerger merger = new webxmlmerger ( srcwebxml ) ; merger . merge ( mergewebxml ) ; list < string > securityrolenames = webxmlutils . getsecurityrolenames ( srcwebxml ) ; assertequals ( _num , securityrolenames . size ( ) ) ; assertequals ( _str , securityrolenames . get ( _num ) ) ; }	tests whether a single security role is correctly inserted into an empty descriptor .
private diffpart decodefullrevision ( final int blocksize_l ) throws unsupportedencodingexception , decodingexception { if ( blocksize_l < _num ) { throw new decodingexception ( _str + blocksize_l ) ; } int l = r . read ( blocksize_l ) ; bytearrayoutputstream output = new bytearrayoutputstream ( ) ; for ( int i = _num ; i < l ; i ++ ) { output . write ( r . readbyte ( ) ) ; } diffpart part = new diffpart ( diffaction . full_revision_uncompressed ) ; part . settext ( output . tostring ( wikipedia_encoding ) ) ; return part ; }	decodes a fullrevision operation .
private synchronized static void removechildcharacterdata ( node node , boolean deep ) { nodelist list = node . getchildnodes ( ) ; for ( int i = list . getlength ( ) ; i >= _num ; i -- ) { node n = list . item ( i ) ; if ( n == null ) continue ; if ( n instanceof characterdata ) node . removechild ( xmlcaster . torawnode ( n ) ) ; else if ( deep ) removechildcharacterdata ( n , deep ) ; } }	remove children from type characterdata from a node , this includes text , comment and cdatasection nodes.
void unlink ( node < e > p , node < e > trail ) { p . item = null ; trail . next = p . next ; if ( last == p ) last = trail ; if ( count . getanddecrement ( ) == capacity ) notfull . signal ( ) ; }	unlinks interior node p with predecessor trail .
public static float mixfriction ( float friction1 , float friction2 ) { return mathutils . sqrt ( friction1 * friction2 ) ; }	friction mixing law . feel free to customize this . todo djm : add customization.
public string serialize ( object obj , string contenttype ) throws apiexception { if ( contenttype . startswith ( _str ) ) { return json . serialize ( obj ) ; } else { throw new apiexception ( _num , _str + contenttype ) ; } }	serialize the given java object into string according the given content - type ( only json is supported for now ) .
private boolean compileswsequencezr ( int baseregister , int [ ] offsets , int [ ] registers ) { for ( int i = _num ; i < registers . length ; i ++ ) { if ( registers [ i ] != _zr ) { return _bool ; } } for ( int i = _num ; i < offsets . length ; i ++ ) { if ( offsets [ i ] != offsets [ i - _num ] + _num ) { return _bool ; } } int offset = offsets [ _num ] ; int length = offsets . length ; do { int copylength = math . min ( length , fastmemory . zero . length ) ; mv . visitfieldinsn ( opcodes . getstatic , type . getinternalname ( fastmemory . class ) , _str , _str ) ; loadimm ( _num ) ; loadmemoryint ( ) ; preparememindex ( baseregister , offset , _bool , _num ) ; loadimm ( copylength ) ; mv . visitmethodinsn ( opcodes . invokestatic , type . getinternalname ( system . class ) , _str , arraycopydescriptor ) ; length -= copylength ; offset += copylength ; } while ( length > _num ) ; return _bool ; }	compile a sequence sw $ zr , n ( $ reg ) sw $ zr , n + 4 ( $ reg ) sw $ zr , n + 8 ( $ reg ).
private boolean isnativevolumeexpansionsupported ( volume vplexvolume , long newsize ) { boolean usenativevolumeexpansion = _bool ; stringset assocvolumeids = vplexvolume . getassociatedvolumes ( ) ; if ( null == assocvolumeids ) { s_logger . warn ( _str , vplexvolume . fordisplay ( ) ) ; usenativevolumeexpansion = _bool ; } else { for ( string assocvolumeid : assocvolumeids ) { volume assocvolume = _permissionshelper . getobjectbyid ( uri . create ( assocvolumeid ) , volume . class ) ; try { super . verifyvolumeexpansionrequest ( assocvolume , newsize ) ; } catch ( exception e ) { usenativevolumeexpansion = _bool ; break ; } } } return usenativevolumeexpansion ; }	determines if the vplex volume can be expanded by natively expanding the backend volumes .
public void updategui ( rosterentry r ) { roadname . settext ( r . getroadname ( ) ) ; roadnumber . settext ( r . getroadnumber ( ) ) ; mfg . settext ( r . getmfg ( ) ) ; owner . settext ( r . getowner ( ) ) ; model . settext ( r . getmodel ( ) ) ; comment . settext ( r . getcomment ( ) ) ; decodermodel . settext ( r . getdecodermodel ( ) ) ; decoderfamily . settext ( r . getdecoderfamily ( ) ) ; decodercomment . settext ( r . getdecodercomment ( ) ) ; dateupdated . settext ( r . getdateupdated ( ) ) ; maxspeedspinner . setvalue ( integer . valueof ( r . getmaxspeedpct ( ) ) ) ; }	file gui from roster contents.
public static double oizp ( number value ) { if ( value == null ) { return null ; } return ( value . doublevalue ( ) >= _num ) ? _num : _num ; }	function which will return one if the argument is zero or a positive number , and zero if not .
public terminalsize with ( terminalsize size ) { if ( equals ( size ) ) { return this ; } return size ; }	returns itself if it is equal to the supplied size , otherwise the supplied size.
private boolean isgzipallowed ( final httpservletrequest request ) { return ! dispatcherstreamlocator . isincludedrequest ( request ) && wroutil . isgzipsupported ( request ) ; }	checks if the request supports gzip and is not a include request ( these cannot be gzipped ).
public replayprocessor ( int buffersize , boolean unbounded ) { if ( unbounded ) { this . buffer = new unboundedbuffer < > ( buffersize ) ; } else { this . buffer = new boundedbuffer < > ( buffersize ) ; } subscribers . lazyset ( this , empty ) ; }	constructs a replayprocessor with bounded or unbounded buffering .
protected void onshowconversations ( @ nonnull list < c > conversations ) { if ( debug ) { log . d ( tag , _str + conversations . size ( ) + _str ) ; } mview . showconversations ( new arraylist < > ( conversations ) ) ; }	by default displays the current conversations in the view , this method can be updated to modify the conversations list before it is shown , can be used to filter the list or augment it.
protected int read ( ) throws ioexception { if ( offset == buffer . length ) { throw new asn1exception ( _str ) ; } if ( in == null ) { return buffer [ offset ++ ] & _num ; } else { int octet = in . read ( ) ; if ( octet == - _num ) { throw new asn1exception ( _str ) ; } buffer [ offset ++ ] = ( byte ) octet ; return octet ; } }	reads the next encoded byte from the encoded input stream .
public void enqueuejob ( final runnable job ) { synchronized ( msleepsync ) { if ( hasjob ( ) ) { throw new illegalstateexception ( _str ) ; } setjob ( job ) ; msleepsync . notifyall ( ) ; } }	enqueue a job for this thread.
public void testtestbitpositive2 ( ) { byte abytes [ ] = { - _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = _num ; int number = _num ; biginteger anumber = new biginteger ( asign , abytes ) ; asserttrue ( anumber . testbit ( number ) ) ; }	testbit ( int n ) of a positive number.
public void startelement ( string uri , string localname , string qname , attributes attributes ) throws org . xml . sax . saxexception { if ( qname . equals ( printdata . xml_tag ) ) { string name = attributes . getvalue ( printdata . xml_attribute_name ) ; if ( m_pd == null ) { m_pd = new printdata ( m_ctx , name ) ; push ( m_pd ) ; } else { printdata temp = new printdata ( m_ctx , name ) ; m_curpd . addnode ( temp ) ; push ( temp ) ; } } else if ( qname . equals ( printdata . xml_row_tag ) ) { m_curpd . addrow ( _bool , _num ) ; } else if ( qname . equals ( printdataelement . xml_tag ) ) { m_curpdename = attributes . getvalue ( printdataelement . xml_attribute_name ) ; m_curpdevalue = new stringbuffer ( ) ; } }	receive notification of the start of an element .
public void drawstring ( string str , int x , int y , int textdecoration ) { if ( str . length ( ) == _num || ( str . length ( ) == _num && str . charat ( _num ) == _str ) ) { return ; } object nativefont = null ; if ( current != null ) { nativefont = current . getnativefont ( ) ; } if ( current instanceof customfont ) { current . drawstring ( this , str , x , y ) ; } else { impl . drawstring ( nativegraphics , nativefont , str , x + xtranslate , y + ytranslate , textdecoration ) ; } }	draw a string using the current font and color in the x , y coordinates.
@ override public int read ( char [ ] array , int offset , int length ) { if ( idx >= charsequence . length ( ) ) { return - _num ; } if ( array == null ) { throw new nullpointerexception ( _str ) ; } if ( length < _num || offset < _num || offset + length > array . length ) { throw new indexoutofboundsexception ( _str + array . length + _str + offset + _str + length ) ; } int count = _num ; for ( int i = _num ; i < length ; i ++ ) { int c = read ( ) ; if ( c == - _num ) { return count ; } array [ offset + i ] = ( char ) c ; count ++ ; } return count ; }	read the sepcified number of characters into the array .
public void updatenonceparameters ( ) { if ( mnextnonce . equals ( mnonce ) ) { mcnoncecounter ++ ; } else { mcnoncecounter = _num ; mnonce = mnextnonce ; } }	update the nonce parameters.
private void matchvpools ( uri rpsystemid ) { list < uri > storagepoolids = connectivityutil . getrpsystemstoragepools ( _dbclient , rpsystemid ) ; stringbuffer errormessage = new stringbuffer ( ) ; if ( storagepoolids != null && ! storagepoolids . isempty ( ) ) { list < storagepool > storagepools = _dbclient . queryobject ( storagepool . class , storagepoolids ) ; implicitpoolmatcher . matchmodifiedstoragepoolswithallvirtualpool ( storagepools , _dbclient , _coordinator , errormessage ) ; } }	recalculate all virtual pools matching storage pools that have rp protection as creation of a protection system creates new relationships and constraints on the matching pools of an rp system .
public static bigdecimal calculatefee ( player player , int price ) { bigdecimal fee = bigdecimal . valueof ( price ) ; fee = fee . multiply ( bigdecimal . valueof ( trading_fee_percentage ) ) ; if ( player . isbadboy ( ) ) { fee = fee . multiply ( bigdecimal . valueof ( _num + trading_fee_player_killer_penalty ) ) ; } bigdecimal feebonus = bigdecimal . one ; feebonus = bigdecimal . valueof ( math . exp ( - player . gettradescore ( ) / fee_bonus_constant ) ) ; fee = fee . multiply ( feebonus ) ; return fee . max ( bigdecimal . one ) ; }	calculates the trading fee a player has to pay when selling for a certain price.
private void addsearchhistory ( ) { addsearchhistory ( tfsearcheditor . gettext ( ) ) ; }	adds current search pattern in the search history list.
arraylist < sourcefile > trimfilelist ( arraylist < sourcefile > files ) { hashmap < string , string > names = new hashmap < string , string > ( ) ; arraylist < sourcefile > list = new arraylist < sourcefile > ( ) ; int size = files . size ( ) ; for ( int i = _num ; i < size ; i ++ ) { boolean addit = _bool ; sourcefile fi = files . get ( i ) ; string fname = fi . getrawname ( ) ; if ( m_swffilter == null ) { if ( names . get ( fname ) == null ) addit = _bool ; } else { addit = m_swffilter . containssource ( fi ) ; } if ( addit ) { names . put ( fname , fname ) ; list . add ( fi ) ; } } return list ; }	walk the file list looking for name collisions . if we find one , then we remove it.
public static string join ( double [ ] self , string separator ) { stringbuilder buffer = new stringbuilder ( ) ; boolean first = _bool ; if ( separator == null ) separator = _str ; for ( double next : self ) { if ( first ) { first = _bool ; } else { buffer . append ( separator ) ; } buffer . append ( next ) ; } return buffer . tostring ( ) ; }	concatenates the string representation of each items in this array , with the given string as a separator between each item .
protected void writeshort ( int value ) throws ioexception { out . write ( value & _num ) ; out . write ( ( value > > _num ) & _num ) ; }	write 16 - bit value to output stream , lsb first.
public entityquery orderby ( string ... fields ) { this . orderby = arrays . aslist ( fields ) ; return this ; }	the fields of the named entity to order the resultset by ; optionally add a " asc " for ascending or " desc " for descending note : each successive call to any of the orderby (.
public stemmedstring ( string orig , string stemmed ) { strorig = orig ; strstemmed = stemmed ; }	create a stemmedstring from two strings.
public lognetworkstreammerger ( logrequest req , mediatype mediatype , logsvcpropertiesloader propertiesloader ) { logger . trace ( _str ) ; this . request = req ; this . mediatype = mediatype ; this . propertiesloader = propertiesloader ; list < lognetworkreader > readers = getlognetworkstreams ( ) ; int size = readers . size ( ) ; logheads = new logmessage [ size ] ; this . logstreamlist = new lognetworkreader [ size ] ; int index = _num ; for ( lognetworkreader reader : readers ) { logstreamlist [ index ] = reader ; logheads [ index ] = null ; index ++ ; } }	merges all logs on each node based on time stamp.
public static string packciphersuites ( string [ ] ciphers ) { string cipherset = null ; if ( ciphers != null ) { stringbuffer buf = new stringbuffer ( ) ; for ( int i = _num ; i < ciphers . length ; i ++ ) { buf . append ( ciphers [ i ] ) ; if ( i < ciphers . length - _num ) { buf . append ( _str ) ; } } cipherset = buf . tostring ( ) ; } return cipherset ; }	converts an array of ciphers into a single string .
public extensionfilefilter ( string description , string extension ) { this . description = description ; this . extensions = new hashset < string > ( ) ; extensions . add ( extension . tolowercase ( ) ) ; defaultextension = extension ; }	creates a new instance .
private void ensuretuplearray ( int row ) { int nrows = math . max ( m_table . getrowcount ( ) , row + _num ) ; if ( m_tuples == null ) { m_tuples = new tabletuple [ nrows ] ; } else if ( m_tuples . length < nrows ) { int capacity = math . max ( ( _num * m_tuples . length ) / _num + _num , nrows ) ; tabletuple [ ] tuples = new tabletuple [ capacity ] ; system . arraycopy ( m_tuples , _num , tuples , _num , m_tuples . length ) ; m_tuples = tuples ; } }	ensure the tuple array exists .
private static boolean isanargument ( final string arg ) { return ( arg . startswith ( _str ) && ( arg . length ( ) > _num ) && ! character . isdigit ( arg . charat ( _num ) ) ) ; }	given a string like " - foo " or " - 5 " or " - 123.
private synchronized static void removechildren ( node node , short type , boolean deep ) { nodelist list = node . getchildnodes ( ) ; for ( int i = list . getlength ( ) ; i >= _num ; i -- ) { node n = list . item ( i ) ; if ( n == null ) continue ; if ( n . getnodetype ( ) == type || type == undefined_node ) node . removechild ( xmlcaster . torawnode ( n ) ) ; else if ( deep ) removechildren ( n , type , deep ) ; } }	removes child elements from a specific type.
public final void lazyset ( v newvalue ) { unsafe . putorderedobject ( this , valueoffset , newvalue ) ; }	eventually sets to the given value .
public boolean isvalidsavepoint ( savepoint sp ) { if ( issource ( ) ) return _bool ; boolean result = _bool ; if ( sp != null ) result = _bool ; return result ; }	checks whether a savepoint is valid.
public static void columnsfor ( resultset resultset , tableeditor editor ) throws sqlexception { list < column > columns = new arraylist < > ( ) ; columnsfor ( resultset , null ) ; editor . setcolumns ( columns ) ; }	use the supplied table editor to create columns for the supplied result set .
private static void write ( collection < string > src , file out ) throws ioexception { try ( writer writer = new bufferedwriter ( new filewriter ( out ) ) ) { for ( string line : src ) writer . write ( line + _str ) ; } }	write source code to file .
public void clear ( ) { if ( moriginalvalues != null ) { synchronized ( mlock ) { moriginalvalues . clear ( ) ; } } else { mobjects . clear ( ) ; } if ( mnotifyonchange ) notifydatasetchanged ( ) ; }	remove all elements from the list .
private long resetuidvalidity ( ) throws ioexception { long timestamp = system . currenttimemillis ( ) ; setuidvalidity ( timestamp ) ; return timestamp ; }	sets and returns a new uidvalidity for this folder .
public static int writeoggpageheader ( byte [ ] buf , int offset , int headertype , long granulepos , int streamserialnumber , int pagecount , int packetcount , byte [ ] packetsizes ) { writestring ( buf , offset , _str ) ; buf [ offset + _num ] = _num ; buf [ offset + _num ] = ( byte ) headertype ; writelong ( buf , offset + _num , granulepos ) ; writeint ( buf , offset + _num , streamserialnumber ) ; writeint ( buf , offset + _num , pagecount ) ; writeint ( buf , offset + _num , _num ) ; buf [ offset + _num ] = ( byte ) packetcount ; system . arraycopy ( packetsizes , _num , buf , offset + _num , packetcount ) ; return packetcount + _num ; }	writes an ogg page header to the given byte array .
private void handlestaticsiterequest ( staticsiterequest . pointrequest request , transportnetwork transportnetwork , taskstatistics ts ) { staticcomputer computer = new staticcomputer ( request , transportnetwork , ts ) ; if ( request . request . bucket != null ) computer . run ( ) ; else { try { pipedinputstream pis = new pipedinputstream ( ) ; pipedoutputstream pos = new pipedoutputstream ( pis ) ; finishprioritytask ( request , pis ) ; computer . write ( pos ) ; pos . close ( ) ; } catch ( ioexception e ) { log . error ( _str , e ) ; } } deleterequest ( request ) ; }	handle a fancy new - fangled static site request.
public synchronized void removeroom ( string room ) { if ( ! helper . validatestream ( room ) ) { return ; } room = room . tolowercase ( ) ; if ( rooms . remove ( room ) ) { unsubroom ( room ) ; removeemotes ( room ) ; prevemotesets . remove ( room ) ; } }	remove subscription to a room.
public static double discharge ( itemstack itemstack , double amount ) { if ( itemstack != null ) { if ( itemstack . getitem ( ) instanceof ienergizeditem ) { ienergizeditem energizeditem = ( ienergizeditem ) itemstack . getitem ( ) ; if ( energizeditem . cansend ( itemstack ) ) { double energytouse = math . min ( energizeditem . getmaxtransfer ( itemstack ) , math . min ( energizeditem . getenergy ( itemstack ) , amount ) ) ; energizeditem . setenergy ( itemstack , energizeditem . getenergy ( itemstack ) - energytouse ) ; return energytouse ; } } } return _num ; }	discharges an ienergizeditem with the defined amount of energy .
public object [ ] toarray ( ) { final reentrantlock lock = this . lock ; lock . lock ( ) ; try { object [ ] a = new object [ count ] ; int k = _num ; for ( node < e > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }	returns an array containing all of the elements in this deque , in proper sequence ( from first to last element ).
public void addall ( final collection elements ) { adjusting = _bool ; set oldselection = new hashset ( selection ) ; boolean rv = selection . addall ( elements ) ; adjusting = _bool ; if ( rv ) { fireselectionchanged ( oldselection , selection ) ; } oldselection = null ; }	add all of the specified elements to the selection .
public boolean hasfeature ( int feature ) { return ( ( feature >= mode_first && feature <= mode_last ) || ( feature >= feature_first && feature <= feature_last ) ) && ( feature == mode_off || mcapabilities . get ( feature ) ) ; }	checks if a particular feature or mode is supported by the system .
public set < integer > backuppartitions ( uuid nodeid ) { set < integer > set = backup . get ( nodeid ) ; return set == null ? collections . < integer > emptyset ( ) : set ; }	get backup partitions for specified node id .
public loader load ( string imageurl ) { imageurl = imageurl ; return this ; }	just pass http url and then you have to call view ( imageview ).
private void buildptr ( ) { double [ ] temp_row ; double [ ] [ ] ptra ; int k ; pivottransform pt ; ptr = matrix . identity ( n , n ) ; ptra = ptr . getarray ( ) ; k = pivottransformqueue . size ( ) ; while ( k -- > _num ) { pt = pivottransformqueue . removelast ( ) ; temp_row = ptra [ pt . pos1 ] ; ptra [ pt . pos1 ] = ptra [ pt . pos2 ] ; ptra [ pt . pos2 ] = temp_row ; } }	build the pivot - transform - reverse matrix ptr.
private static string bytetohex ( byte [ ] digest ) { stringbuilder builder = new stringbuilder ( ) ; for ( byte b : digest ) { string hex = integer . tohexstring ( _num & b ) ; if ( hex . length ( ) == _num ) { builder . append ( _str ) ; } builder . append ( hex ) ; } return builder . tostring ( ) ; }	transform binary to hex.
public bidi createlinebidi ( int linestart , int linelimit ) { attributedstring astr = new attributedstring ( _str ) ; bidi newbidi = new bidi ( astr . getiterator ( ) ) ; return bidibase . setline ( this , bidibase , newbidi , newbidi . bidibase , linestart , linelimit ) ; }	create a bidi object representing the bidi information on a line of text within the paragraph represented by the current bidi.
public boolean iscallervalidforpackage ( context context , int authrequirements , string packagetomatch ) { assert ! textutils . isempty ( packagetomatch ) ; return iscallervalid ( context , authrequirements , packagetomatch ) ; }	returns whether the callers of the current transaction contains a package that matches the give authentication requirements .
public void paintinternalframetitlepanebackground ( synthcontext context , graphics g , int x , int y , int w , int h ) { paintbackground ( context , g , x , y , w , h , null ) ; }	paints the background of an internal frame title pane .
public synchronized void addgraphlistener ( graphlistener cl ) { m_graphlisteners . addelement ( cl ) ; }	add a graph listener.
public void restartandinstallifnecessary ( ) { file patchesdir = new file ( mysdkhandler . getlocation ( ) , patchinstallerutil . patches_dir_name ) ; studiologgerprogressindicator progress = new studiologgerprogressindicator ( patchinstallerfactory . class ) ; if ( patchesdir . exists ( ) ) { file [ ] subdirs = patchesdir . listfiles ( null ) ; for ( file patchdir : subdirs ) { processpatch ( mysdkhandler . getlocation ( ) , progress , patchdir ) ; } } }	find any pending patches under the given sdk root that require studio to be restarted , and if there are any , restart and install them.
public static double [ ] [ ] align ( int [ ] real , double [ ] pred ) { int missing = numberofmissinglabels ( real ) ; double [ ] _real = new double [ real . length - missing ] ; double [ ] _pred = new double [ real . length - missing ] ; int offset = _num ; for ( int i = _num ; i < real . length ; i ++ ) { if ( real [ i ] == - _num || pred [ i ] == - _num || double . isnan ( pred [ i ] ) ) { offset ++ ; continue ; } _real [ i - offset ] = real [ i ] ; _pred [ i - offset ] = pred [ i ] ; } double [ ] [ ] res = new double [ _num ] [ _num ] ; res [ _num ] = _real ; res [ _num ] = _pred ; return res ; }	helper function for missing values in the labels and missing predictions ( i.
public static boolean iscategory ( int m_product_category_id , int m_product_id ) { if ( m_product_id == _num || m_product_category_id == _num ) return _bool ; integer product = new integer ( m_product_id ) ; integer category = ( integer ) s_products . get ( product ) ; if ( category != null ) return category . intvalue ( ) == m_product_category_id ; string sql = _str ; preparedstatement pstmt = null ; try { pstmt = db . preparestatement ( sql , null ) ; pstmt . setint ( _num , m_product_id ) ; resultset rs = pstmt . executequery ( ) ; if ( rs . next ( ) ) category = new integer ( rs . getint ( _num ) ) ; rs . close ( ) ; pstmt . close ( ) ; pstmt = null ; } catch ( exception e ) { s_log . log ( level . severe , sql , e ) ; } try { if ( pstmt != null ) pstmt . close ( ) ; pstmt = null ; } catch ( exception e ) { pstmt = null ; } if ( category != null ) { s_products . put ( product , category ) ; s_log . fine ( _str + m_product_id + _str + category + _str + m_product_category_id + _str + ( category . intvalue ( ) == m_product_category_id ) ) ; return category . intvalue ( ) == m_product_category_id ; } s_log . log ( level . severe , _str + m_product_id ) ; return _bool ; }	is product in category.
public allstatstablemulti ( datasetgenerator datasetgenerator , locker locker ) { argumentchecking . notnull ( datasetgenerator , _str ) ; initcomponents ( ) ; table . setdefaultrenderer ( jlabel . class , new renderer ( ) ) ; table . setcolumnselectionallowed ( _bool ) ; table . setrowselectionallowed ( _bool ) ; table . setgridcolor ( grid_color ) ; jtableheader header = table . gettableheader ( ) ; header . setreorderingallowed ( _bool ) ; guiutilities . settableheader ( header ) ; model = new model ( datasetgenerator ) ; table . setmodel ( model ) ; this . locker = locker ; }	it creates a new instance of this panel .
public void append ( file file , ftpdatatransferlistener listener ) throws illegalstateexception , filenotfoundexception , ioexception , ftpillegalreplyexception , ftpexception , ftpdatatransferexception , ftpabortedexception { if ( ! file . exists ( ) ) { throw new filenotfoundexception ( file . getabsolutepath ( ) ) ; } inputstream inputstream = null ; try { inputstream = new fileinputstream ( file ) ; } catch ( ioexception e ) { throw new ftpdatatransferexception ( e ) ; } try { append ( file . getname ( ) , inputstream , _num , listener ) ; } catch ( illegalstateexception e ) { throw e ; } catch ( ioexception e ) { throw e ; } catch ( ftpillegalreplyexception e ) { throw e ; } catch ( ftpexception e ) { throw e ; } catch ( ftpdatatransferexception e ) { throw e ; } catch ( ftpabortedexception e ) { throw e ; } finally { if ( inputstream != null ) { try { inputstream . close ( ) ; } catch ( throwable t ) { ; } } } }	this method uploads a file to the remote server.
public list < string > providewhitelist ( ) { linkedlist < string > whitelist = new linkedlist < > ( ) ; whitelist . add ( _str ) ; return whitelist ; }	provide white list , entry in white list will not be shown in ui list .
public static boolean isscopedname ( string name ) { return name . indexof ( _str ) != - _num ; }	used to detect scoped attributes .
public input ( iobuffer buf ) { super ( buf ) ; amf3_mode = _num ; stringreferences = new arraylist < string > ( ) ; classreferences = new arraylist < classreference > ( ) ; }	creates input object for amf3 from byte buffer.
public static properties loadconfigfile ( string path ) { properties property = null ; file file = new file ( path ) ; if ( file . exists ( ) && file . canread ( ) ) { try { property = new properties ( ) ; property . load ( new filereader ( file . getabsolutepath ( ) ) ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } return property ; }	searching the specified configuration file and return a properties.
protected void sprint ( boolean booleanfield ) { sprint ( string . valueof ( booleanfield ) ) ; }	pretty printing accumulator function for booleans.
protected static void toeplviews ( stringwriter writer , list < view > views ) { if ( ( views != null ) && ( views . size ( ) != _num ) ) { writer . write ( _str ) ; string delimiter = _str ; for ( view view : views ) { writer . write ( delimiter ) ; view . toepl ( writer ) ; delimiter = _str ; } } }	renders the views onto the projected stream .
protected void removedatabaselisteners ( ) { databaselisteners . clear ( ) ; }	removes all database listeners added .
private audiomaptype loadaudiomapxml ( file audiomapfile ) throws xmlparsingexception , filenotfoundexception { if ( ! audiomapfile . isfile ( ) ) { throw new filenotfoundexception ( string . format ( _str , audiomapfile . getabsolutepath ( ) ) ) ; } return xmlparser . parse ( audiomapfile , new string [ ] { audiomap_xml_scheme } , audiomap_package , audiomaptype . class ) ; }	loads and validates audiomap.
public void addgenericattr ( genericattr g ) { generic . addelement ( g ) ; }	add a generic attribute to the field . a generic attribute contains a stream of uninterpreted bytes which is ignored by the vm ( as long as its name doesn ' t conflict with other names for attributes that are understood by the vm ).
private list < fahrzeitevent > addfahrtinfotofahrzeitevents ( list < fahrtevent > fahrtevents , list < fahrzeitevent > fahrzeitevents , boolean keepfahrzeiteventswithoutfahrtevent ) { list < fahrzeitevent > fahrzeiteventsout = new linkedlist < fahrzeitevent > ( ) ; map < string , fahrtevent > rbldatekursdatetimeist2fahrteventmap = new hashmap < string , fahrtevent > ( ) ; set < string > searchstrings = new treeset < string > ( ) ; for ( fahrtevent fahrtevent : fahrtevents ) { string searchid = string . valueof ( fahrtevent . getrbldate ( ) ) + string . valueof ( fahrtevent . getkurs ( ) ) + fahrtevent . getdeparturedateist ( ) + fahrtevent . getdeparturetimeist ( ) ; if ( searchstrings . contains ( searchid ) ) { log . warn ( _str + searchid ) ; } else { searchstrings . add ( searchid ) ; rbldatekursdatetimeist2fahrteventmap . put ( searchid , fahrtevent ) ; } } int numberofmissingfahrtevents = _num ; for ( fahrzeitevent fahrzeitevent : fahrzeitevents ) { string searchid = string . valueof ( fahrzeitevent . getrbldate ( ) ) + string . valueof ( fahrzeitevent . getkurs ( ) ) + fahrzeitevent . getdeparturedateist ( ) + fahrzeitevent . getdeparturetimeist ( ) ; fahrtevent fahrtevent = rbldatekursdatetimeist2fahrteventmap . get ( searchid ) ; if ( fahrtevent == null ) { numberofmissingfahrtevents ++ ; if ( keepfahrzeiteventswithoutfahrtevent ) { fahrzeiteventsout . add ( fahrzeitevent ) ; } } else { fahrzeitevent . add ( fahrtevent ) ; fahrzeiteventsout . add ( fahrzeitevent ) ; } } log . info ( numberofmissingfahrtevents + _str ) ; log . info ( _str + fahrzeiteventsout . size ( ) + _str ) ; return fahrzeiteventsout ; }	link fahrzeit events to the corresponding fahrt event.
private static object newinstancenoserviceloader ( class < ? > providerclass ) { if ( system . getsecuritymanager ( ) == null ) { return null ; } try { method creationmethod = providerclass . getdeclaredmethod ( _str ) ; return creationmethod . invoke ( null , ( object [ ] ) null ) ; } catch ( nosuchmethodexception exc ) { return null ; } catch ( exception exc ) { return null ; } }	try to construct using newtransformerfactorynoserviceloader method if available .
private void checkuuid ( string uuid , int code ) { checkhash ( uuid . fromstring ( uuid ) , code ) ; }	check unique id and generated hash code .
@ override protected void preparewrite ( writablebytechannel channel ) throws exception { os = channels . newoutputstream ( channel ) ; }	creates the output stream that elements will be written to .
public void run ( ) { try { boolean cleanremotesessions = _bool ; synchronized ( this ) { collection < stateinfo > infos = new arraylist < > ( ) ; infos . addall ( servers . values ( ) ) ; infos . addall ( sites . values ( ) ) ; for ( stateinfo info : infos ) { info . isup = checkserverup ( info ) ; if ( ! info . isup ) { down . add ( info . id ) ; } else { if ( ! down . isempty ( ) && down . remove ( info . id ) ) { cleanremotesessions = _bool ; } } } } if ( cleanremotesessions ) { foreignsessionhandler . cleanupremotesessions ( ) ; } } catch ( exception ex ) { sessiondebug . error ( _str + ex . getmessage ( ) , ex ) ; } }	monitoring logic used by background thread.
private void writeobject ( java . io . objectoutputstream p_stream ) throws java . io . ioexception { p_stream . defaultwriteobject ( ) ; p_stream . writeint ( trace_angle_restriction . get_no ( ) ) ; }	writes an instance of this class to a file.
@ suppresswarnings ( _str ) public literalextensioniv createiv ( final value value ) { if ( value instanceof literal == _bool ) throw new illegalargumentexception ( ) ; final literal lit = ( literal ) value ; final abstractliteraliv delegate = new packedlongiv ( long . parselong ( lit . getlabel ( ) ) ) ; return new literalextensioniv ( delegate , datatype . getiv ( ) ) ; }	convert the supplied value into an internal representation as packedlongiv .
public builder addheader ( string name , string value ) { headers . add ( new header ( name , value ) ) ; return this ; }	adds the supplied request header .
public void add ( leafatom atom ) { leafchildren . add ( atom ) ; }	adds a child leaf to this container .
public static double normalcdf ( double x ) { return ( _num * ( _num + ( erf ( x / ( math . sqrt ( _num ) ) ) ) ) ) ; }	computes an approximation to normalcdf ( x ) .
public void removeresult ( string name ) { stringbuffer buff = m_results . get ( name ) ; if ( buff != null ) { m_results . remove ( name ) ; m_model . removeelement ( name ) ; m_objs . remove ( name ) ; system . gc ( ) ; } }	removes one of the result buffers from the history.
private void addentry ( ) { filtermodel . addnewentry ( ) ; extentmodel . populate ( null ) ; removeftcbutton . setenabled ( _bool ) ; addextentbutton . setenabled ( _bool ) ; removeextentbutton . setenabled ( _bool ) ; }	adds a new feature type constraint entry .
public void testcase22 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , - _num , _num } ; int asign = _num ; int bsign = - _num ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; try { anumber . mod ( bnumber ) ; fail ( _str ) ; } catch ( arithmeticexception e ) { } }	mod when modulus is negative.
public dexportprivatekeyopenssl ( jframe parent , string entryalias , passwordqualityconfig passwordqualityconfig ) { super ( parent , dialog . modalitytype . document_modal ) ; this . entryalias = entryalias ; this . passwordqualityconfig = passwordqualityconfig ; initcomponents ( ) ; }	creates a new dexportprivatekeyopenssl dialog .
public bigdecimal sum ( string sqlexpression ) { return aggregate ( sqlexpression , aggregate_sum ) ; }	sum sqlexpression for items that match query criteria.
@ override public int calculateoffsetx ( ) { return ( int ) ( math . cos ( this . angle ) * this . distance ) - this . shadowsize ; }	calculates the x - offset for drawing the shadow image relative to the source .
protected void onfinish ( ) { merrorlistener = null ; }	clear listeners when finished.
private < t > void runtestwrite ( xmlwriter < t > writer , list < t > bundle , list < string > expected ) throws exception { file tmpfile = tmpfolder . newfile ( _str ) ; try ( fileoutputstream fileoutputstream = new fileoutputstream ( tmpfile ) ) { writebundle ( writer , bundle , fileoutputstream . getchannel ( ) ) ; } list < string > lines = new arraylist < > ( ) ; try ( bufferedreader reader = new bufferedreader ( new filereader ( tmpfile ) ) ) { for ( ; ; ) { string line = reader . readline ( ) ; if ( line == null ) { break ; } line = line . trim ( ) ; if ( line . length ( ) > _num ) { lines . add ( line ) ; } } assertequals ( expected , lines ) ; } }	write a bundle with an xmlwriter and verify the output is expected .
public string adddays ( object odays , string format ) { int days = functionhandler . getint ( odays ) ; calendar now = calendar . getinstance ( ) ; now . add ( calendar . day_of_year , days ) ; dateformat formatter = getformatter ( format ) ; return formatter . format ( now . gettime ( ) ) ; }	get the date x days from now .
private static file createtempfile ( context context , @ nullable string mimetype ) throws ioexception { file externalcachedir = context . getexternalcachedir ( ) ; file internalcachedir = context . getcachedir ( ) ; file cachedir ; if ( externalcachedir == null && internalcachedir == null ) { throw new ioexception ( _str ) ; } if ( externalcachedir == null ) { cachedir = internalcachedir ; } else if ( internalcachedir == null ) { cachedir = externalcachedir ; } else { cachedir = externalcachedir . getfreespace ( ) > internalcachedir . getfreespace ( ) ? externalcachedir : internalcachedir ; } return file . createtempfile ( temp_file_prefix , getfileextensionfortype ( mimetype ) , cachedir ) ; }	create a temporary file in the cache directory on either internal or external storage , whichever is available and has more free space .
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str + _str , _str , _num , _str ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public boolean removeentry ( int xindex , int datasetindex ) { if ( datasetindex >= mdatasets . size ( ) ) return _bool ; t dataset = mdatasets . get ( datasetindex ) ; entry e = dataset . getentryforxindex ( xindex ) ; return removeentry ( e , datasetindex ) ; }	removes the entry object at the given xindex from the dataset at the specified index.
private void runreadtest ( byte [ ] input , compressionmode mode ) throws ioexception { runreadtest ( input , mode , mode ) ; }	run a single read test , writing and reading back input with the given compression mode .
public static void close ( @ nullable context rsrc , @ nullable ignitelogger log ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch ( namingexception e ) { warn ( log , _str + e . getmessage ( ) ) ; } }	closes given resource logging possible checked exception .
void removeeq ( object o ) { final reentrantlock lock = this . lock ; lock . lock ( ) ; try { object [ ] array = queue ; for ( int i = _num , n = size ; i < n ; i ++ ) { if ( o == array [ i ] ) { removeat ( i ) ; break ; } } } finally { lock . unlock ( ) ; } }	identity - based version for use in itr . remove.
public writableraster createcompatiblewritableraster ( int w , int h ) { if ( w <= _num || h <= _num ) { throw new rasterformatexception ( _str + ( ( w <= _num ) ? _str : _str ) ) ; } samplemodel sm = samplemodel . createcompatiblesamplemodel ( w , h ) ; return new integerinterleavedraster ( sm , new point ( _num , _num ) ) ; }	creates a raster with the same band layout but using a different width and height , and with new zeroed data arrays .
public static string [ ] schedulercommandargs ( config config , config runtime , list < integer > freeports ) { if ( freeports . size ( ) < ports_required_for_scheduler ) { throw new runtimeexception ( _str ) ; } for ( int port : freeports ) { if ( port == - _num ) { throw new runtimeexception ( _str ) ; } } int httpport = freeports . get ( _num ) ; list < string > commands = new arraylist < > ( ) ; commands . add ( _str ) ; commands . add ( context . cluster ( config ) ) ; commands . add ( _str ) ; commands . add ( context . role ( config ) ) ; commands . add ( _str ) ; commands . add ( context . environ ( config ) ) ; commands . add ( _str ) ; commands . add ( context . topologyname ( config ) ) ; commands . add ( _str ) ; commands . add ( context . topologybinaryfile ( config ) ) ; commands . add ( _str ) ; commands . add ( integer . tostring ( httpport ) ) ; return commands . toarray ( new string [ _num ] ) ; }	util method to get the arguments to the heron scheduler .
public documentanalysisrequest adddocument ( solrinputdocument doc ) { documents . add ( doc ) ; return this ; }	adds a document to be analyzed .
public final key dophase ( key key , boolean lastphase ) throws invalidkeyexception , illegalstateexception { choosefirstprovider ( ) ; return spi . enginedophase ( key , lastphase ) ; }	executes the next phase of this key agreement with the given key that was received from one of the other parties involved in this key agreement .
public simplesystempermissionset ( ) { }	creates a new empty simplesystempermissionset .
@ override public final void addbeziercurvey ( final float x , final float y , final float x3 , final float y3 ) { elements . add ( new quadcurveto ( x , y , x3 , y3 ) ) ; currentpos [ _num ] = x3 ; currentpos [ _num ] = y3 ; }	add a curve to the shape.
public void readbucketsfromprefs ( ) { sharedpreferences prefs = mcontext . getsharedpreferences ( shared_prefs , _num ) ; set < string > buckets = prefs . getstringset ( pref_buckets_ids , new treeset < string > ( ) ) ; mbuckets . clear ( ) ; for ( string bucketid : buckets ) { automixbucket bucket = restorebucketfromid ( bucketid ) ; mbuckets . add ( bucket ) ; } }	restore the automix buckets stored in sharedpreferences.
protected int nextchar ( ) throws ioexception { freadfrombuffer = ( fbuffer . length ( ) > _num ) ; if ( freadfrombuffer ) { char ch = fbuffer . charat ( findex ++ ) ; if ( findex >= fbuffer . length ( ) ) { fbuffer . setlength ( _num ) ; findex = _num ; } return ch ; } int ch = fcharafterwhitespace ; if ( ch == - _num ) { ch = freader . read ( ) ; } if ( fskipwhitespace && character . iswhitespace ( ( char ) ch ) ) { do { ch = freader . read ( ) ; } while ( character . iswhitespace ( ( char ) ch ) ) ; if ( ch != - _num ) { fcharafterwhitespace = ch ; return _str ; } } else { fcharafterwhitespace = - _num ; } return ch ; }	returns the next character .
@ override public void acceptappoffer ( offer offer ) { int index = getindex ( offer , appoffers ) ; if ( index != - _num ) { appoffers . remove ( index ) ; appofferstream . onnext ( offer ) ; } index = getindex ( offer , acceptedoffers ) ; if ( index == - _num ) { acceptedoffers . add ( offer ) ; } }	accept app offer remove from app offers list update corresponding app usage.
public boolean verify ( publickey key , string sigprovider ) throws nosuchalgorithmexception , nosuchproviderexception , cmsexception { return verify ( key , cmsutils . getprovider ( sigprovider ) ) ; }	verify that the given public key successfully handles and confirms the signature associated with this signer .
private void injectdependencies ( ) { easymvpapplication easymvpapplication = ( easymvpapplication ) getapplication ( ) ; list < object > activityscopemodules = ( getmodules ( ) != null ) ? getmodules ( ) : new arraylist < > ( ) ; activityscopemodules . add ( new activitymodule ( this ) ) ; activityscopegraph = easymvpapplication . buildgraphwithaditionalmodules ( activityscopemodules ) ; inject ( this ) ; }	generates activity scope graph using activitymodule plus additional modules provided by inheritance .
public void writerequest ( ) { object lock = new object ( ) ; synchronized ( lock ) { synchronized ( this ) { boolean goaheadwithwrite = writerlocks . size ( ) == _num && currentreaders == _num && currentwriters == _num ; if ( goaheadwithwrite ) { ++ currentwriters ; return ; } writerlocks . addlast ( lock ) ; } try { lock . wait ( ) ; } catch ( interruptedexception e ) { } } }	request the write lock.
public long readlocaldate ( ) throws ioexception { expectstarttag ( _str ) ; if ( localcalendar == null ) localcalendar = calendar . getinstance ( ) ; long value = parsedate ( localcalendar ) ; expectendtag ( _str ) ; return value ; }	reads a date value from the input stream .
public void removeselectionlistener ( final selectionlistener listener ) { checkwidget ( ) ; listeners . remove ( listener ) ; }	removes the listener from the collection of listeners who will be notified when the user changes the receiver ' s value .
private void writehex ( int i ) throws ioexception { int cursor = _num ; do { hex [ -- cursor ] = hex_digits [ i & _num ] ; } while ( ( i >>>= _num ) != _num ) ; socketout . write ( hex , cursor , hex . length - cursor ) ; }	equivalent to , but cheaper than writing integer.
private synchronized string readinputstream ( inputstreamreader inputstreamreader ) throws ioexception , badlocationexception { bufferedreader bufferedreader = null ; try { bufferedreader = new bufferedreader ( inputstreamreader ) ; string newline = _str ; stringbuffer sb = new stringbuffer ( ) ; string line ; while ( ( line = bufferedreader . readline ( ) ) != null ) { sb . append ( line + newline ) ; } return sb . tostring ( ) ; } finally { if ( null != bufferedreader ) bufferedreader . close ( ) ; if ( null != inputstreamreader ) inputstreamreader . close ( ) ; } }	read an imputstream reader.
private list < map < string , object > > typeparameters ( list < typeparameter > tpl , declaration from ) { if ( tpl != null && ! tpl . isempty ( ) ) { list < map < string , object > > l = new arraylist < > ( tpl . size ( ) ) ; for ( typeparameter tp : tpl ) { l . add ( typeparametermap ( tp , from ) ) ; } return l ; } return null ; }	create a list of maps from the list of type parameters .
long freespaceunix ( string path , boolean kb , boolean posix , long timeout ) throws ioexception { if ( path . length ( ) == _num ) { throw new illegalargumentexception ( _str ) ; } string flags = _str ; if ( kb ) { flags += _str ; } if ( posix ) { flags += _str ; } string [ ] cmdattribs = flags . length ( ) > _num ? new string [ ] { df , flags , path } : new string [ ] { df , path } ; list < string > lines = performcommand ( cmdattribs , _num , timeout ) ; if ( lines . size ( ) < _num ) { throw new ioexception ( _str + df + _str + _str + path + _str + lines ) ; } string line2 = lines . get ( _num ) ; stringtokenizer tok = new stringtokenizer ( line2 , _str ) ; if ( tok . counttokens ( ) < _num ) { if ( tok . counttokens ( ) == _num && lines . size ( ) >= _num ) { string line3 = lines . get ( _num ) ; tok = new stringtokenizer ( line3 , _str ) ; } else { throw new ioexception ( _str + df + _str + _str + path + _str ) ; } } else { tok . nexttoken ( ) ; } tok . nexttoken ( ) ; tok . nexttoken ( ) ; string freespace = tok . nexttoken ( ) ; return parsebytes ( freespace , path ) ; }	find free space on the * nix platform using the ' df ' command .
public static void readandclosestream ( inputstream is ) { final byte [ ] bytes = new byte [ default_buffer_size ] ; try { while ( is . read ( bytes , _num , default_buffer_size ) != - _num ) ; } catch ( ioexception ignored ) { } finally { closesilently ( is ) ; } }	reads all data from stream and close it silently.
private static boolean withintwo ( inode n , inode goal ) { doublelinkedlist < imove > moves = n . validmoves ( ) ; for ( iterator < imove > it = moves . iterator ( ) ; it . hasnext ( ) ; ) { imove move = it . next ( ) ; inode successor = n . copy ( ) ; move . execute ( successor ) ; if ( withinone ( successor , goal ) ) { return _bool ; } } return _bool ; }	see if within two moves of solution .
public penntreebankreader ( string treebankhome , string [ ] sections , string parseviewname ) throws exception { super ( corpusreaderconfigurator . buildresourcemanager ( penn_treebank_wsj , treebankhome ) ) ; this . parseviewname = parseviewname ; combinedwsjhome = treebankhome ; if ( sections == null ) this . sections = ioutils . lsdirectories ( combinedwsjhome ) ; else { this . sections = new string [ sections . length ] ; system . arraycopy ( sections , _num , this . sections , _num , sections . length ) ; } updatecurrentfiles ( ) ; }	reads the specified sections from penn treebank.
@ override public void unwrapsslv2 ( byte [ ] bytes ) { unexpectedmessage ( ) ; }	processes sslv2 hello message.
@ override public void closewrite ( ) throws ioexception { if ( _isclosewrite ) { return ; } _isclosewrite = _bool ; outputstream os = _os ; _os = null ; boolean isshutdownoutput = _bool ; if ( _s instanceof sslsocket ) { log . finer ( l . l ( _str ) ) ; return ; } else if ( _s != null ) { try { _s . shutdownoutput ( ) ; isshutdownoutput = _bool ; } catch ( unsupportedoperationexception e ) { log . log ( level . finest , e . tostring ( ) , e ) ; } catch ( exception e ) { log . finer ( e . tostring ( ) ) ; log . log ( level . finest , e . tostring ( ) , e ) ; } } if ( ! isshutdownoutput && os != null ) { os . close ( ) ; } }	closes the write half of the stream .
protected void applyrowchangedata ( rowchangedata data , list < reploption > options , string sourcedbmstype ) throws replicatorexception { if ( options != null ) { try { if ( applysessionvariables ( null , options ) ) { if ( logger . isdebugenabled ( ) ) { logger . debug ( _str ) ; } executependingbatch ( ) ; statement . executebatch ( ) ; statement . clearbatch ( ) ; } } catch ( sqlexception e ) { throw new applierexception ( _str , e ) ; } } list < reploption > rowoptions = data . getoptions ( ) ; if ( rowoptions != null ) { try { if ( applysessionvariables ( null , rowoptions ) ) { if ( logger . isdebugenabled ( ) ) { logger . debug ( _str ) ; } executependingbatch ( ) ; statement . executebatch ( ) ; statement . clearbatch ( ) ; } } catch ( sqlexception e ) { throw new applierexception ( _str , e ) ; } } for ( onerowchange row : data . getrowchanges ( ) ) { applyonerowchangeprepared ( row , sourcedbmstype ) ; } }	apply one or more row changes .
public namedlist normalize ( namedlist input ) { input . remove ( _str ) ; for ( int i = _num ; i < input . size ( ) ; i ++ ) { object v = input . getval ( i ) ; if ( v instanceof namedlist ) { input . setval ( i , normalize ( ( namedlist ) v ) ) ; } } return input ; }	the ' avgrequestspersecond ' field will make everything look like it changed.
public boolean isinfinite ( ) { return isinfinite ( value ) ; }	returns true if this double value is infinitely large in magnitude .
string inprogressznodename ( long ledgerid , long firsttxid , long logsegmentseqno ) { if ( distributedlogconstants . logsegment_name_version == conf . getlogsegmentnameversion ( ) ) { return string . format ( _str , distributedlogconstants . inprogress_logsegment_prefix , logsegmentseqno ) ; } else { return distributedlogconstants . inprogress_logsegment_prefix + _str + long . tostring ( firsttxid , _num ) ; } }	get the name of the inprogress znode .
public synchronized void add ( double value ) { add ( mcategories . size ( ) + _str , value ) ; }	adds a new value to the series.
public void receiveredundancy ( ) { try { while ( _bool ) { if ( min . read ( minbuffer ) <= _num ) return ; } } catch ( ioexception e ) { } }	receive socket redundancy data.
void outputdoctypedecl ( string name , boolean closedecl ) throws saxexception { if ( m_cdatatagopen ) closecdata ( ) ; try { final java . io . writer writer = m_writer ; writer . write ( _str ) ; writer . write ( name ) ; string doctypepublic = getdoctypepublic ( ) ; if ( null != doctypepublic ) { writer . write ( _str ) ; writer . write ( doctypepublic ) ; writer . write ( _str ) ; } string doctypesystem = getdoctypesystem ( ) ; if ( null != doctypesystem ) { if ( null == doctypepublic ) writer . write ( _str ) ; else writer . write ( _str ) ; writer . write ( doctypesystem ) ; if ( closedecl ) { writer . write ( _str ) ; writer . write ( m_linesep , _num , m_lineseplen ) ; closedecl = _bool ; } else writer . write ( _str ) ; } } catch ( ioexception e ) { throw new saxexception ( e ) ; } }	output the doc type declaration .
public static boolean isvalidvector ( vector2f vector ) { if ( vector == null ) return _bool ; if ( float . isnan ( vector . x ) || float . isnan ( vector . y ) ) return _bool ; if ( float . isinfinite ( vector . x ) || float . isinfinite ( vector . y ) ) return _bool ; return _bool ; }	check a vector . . . if it is null or its floats are nan or infinite , return false . else return true .
public static url resolveurl ( url base , string target ) throws malformedurlexception { target = target . trim ( ) ; if ( target . startswith ( _str ) ) { return fixpurequerytargets ( base , target ) ; } return new url ( base , target ) ; }	resolve relative url - s and fix a few java.
protected int maxdepth ( layout . node node ) { int depth = _num ; for ( int i = _num ; i < node . numchildren ( ) ; i ++ ) { layout . node child = node . getchild ( i ) ; depth = math . max ( depth , maxdepth ( child ) ) ; } return depth + _num ; }	compute the depth of the graph .
private static url [ ] pathtourls ( string path ) throws malformedurlexception { synchronized ( pathtourlscache ) { object [ ] v = ( object [ ] ) pathtourlscache . get ( path ) ; if ( v != null ) { return ( url [ ] ) v [ _num ] ; } } stringtokenizer st = new stringtokenizer ( path ) ; url [ ] urls = new url [ st . counttokens ( ) ] ; for ( int i = _num ; st . hasmoretokens ( ) ; i ++ ) { urls [ i ] = new url ( st . nexttoken ( ) ) ; } synchronized ( pathtourlscache ) { pathtourlscache . put ( path , new object [ ] { urls , new softreference ( path ) } ) ; } return urls ; }	convert a string containing a space - separated list of urls into a corresponding array of url objects , throwing a malformedurlexception if any of the urls are invalid .
private void addfinal ( object [ ] stacks ) { object [ ] input = new object [ inputsize ] , output = new object [ outputsize ] ; for ( int i = _num ; i < stacks . length ; i ++ ) { if ( i < inputsize ) { input [ i ] = stacks [ i ] ; } else if ( ! ( i - inputsize > outputsize ) ) { output [ i - inputsize ] = stacks [ i ] ; } else { throw new runtimeexception ( _str ) ; } } addrecipe ( input , output ) ; }	separates the recipe into an input and output list.
protected void fireconnectionclosed ( ) { connectionevent evt = new connectionevent ( this ) ; for ( connectioneventlistener listener : connectioneventlisteners ) { listener . connectionclosed ( evt ) ; } }	helper method to fire the connectionclosed event .
public static void putintvolatile ( object obj , long off , int val ) { unsafe . putintvolatile ( obj , off , val ) ; }	stores integer value with volatile semantic .
numberstrategy ( final int field ) { this . field = field ; }	construct a strategy that parses a number field.
public static uri createurifromserverset ( set < inetsocketaddress > serverinetset , string path , string protocol ) throws urisyntaxexception { inetsocketaddress inetsocketaddress = serviceutils . selectrandomitem ( serverinetset ) ; string address = inetsocketaddress . gethoststring ( ) ; int port = inetsocketaddress . getport ( ) ; uri uri = new uri ( protocol , null , address , port , path , null , null ) ; return uri ; }	returns the uri of a random server .
public plotnavigator ( plot plot , string ... axesnames ) { this ( plot , arrays . aslist ( axesnames ) ) ; }	initializes a new instance that is responsible for zooming and panning the axes with the specified names of the specified plot .
public void addcolumn ( class classtype , boolean readonly , string header ) { m_modelheaderclass . add ( classtype ) ; setcolumnreadonly ( m_modelheaderclass . size ( ) - _num , readonly ) ; addcolumn ( header ) ; wlistitemrenderer renderer = ( wlistitemrenderer ) getitemrenderer ( ) ; renderer . setcolumnclass ( ( renderer . getnocolumns ( ) - _num ) , classtype ) ; return ; }	set the attributes of the column .
pointcomparator ( int dimension ) { this . dimension = dimension ; }	constructs a new comparator on the given dimension.
public static void addelement ( document doc , element rootelement , string elementname , string typein , string isarrayin , string partitionerin ) { element element = doc . createelement ( _str ) ; rootelement . appendchild ( element ) ; element name = doc . createelement ( _str ) ; name . appendchild ( doc . createtextnode ( elementname ) ) ; element . appendchild ( name ) ; element type = doc . createelement ( _str ) ; type . appendchild ( doc . createtextnode ( typein ) ) ; element . appendchild ( type ) ; if ( isarrayin . equals ( _str ) ) { element . appendchild ( doc . createelement ( _str ) ) ; } if ( partitionerin != null ) { element partitioner = doc . createelement ( _str ) ; partitioner . appendchild ( doc . createtextnode ( partitionerin ) ) ; element . appendchild ( partitioner ) ; } }	helper method to add elements to the test data schema.
public void flushbuffer ( ) throws ioexception { if ( count > _num ) { m_os . write ( m_outputbytes , _num , count ) ; count = _num ; } }	flush the internal buffer.
public void addfirst ( character c ) { addfirst ( c . tostring ( ) ) ; }	add a character to the start of the queue ( will be the next character retrieved ) .
public final void addinstanceof ( string classname ) { reject . ifnull ( classname ) ; string value = classname . trim ( ) ; if ( ! value . matches ( class_re ) ) { throw new illegalargumentexception ( _str + value + _str ) ; } instanceofinterfaces . add ( value ) ; }	add an class name which property values must implement .
@ override public int read ( byte [ ] b , int off , int len ) throws ioexception { if ( b == null ) { throw new nullpointerexception ( _str ) ; } if ( len < _num || off < _num || ( off + len ) > b . length ) { throw new indexoutofboundsexception ( _str + b . length + _str + off + _str + len ) ; } int read = _num ; if ( len == _num ) { return _num ; } while ( len > _num ) { if ( encoderout . hasremaining ( ) ) { int c = math . min ( encoderout . remaining ( ) , len ) ; encoderout . get ( b , off , c ) ; off += c ; len -= c ; read += c ; } else { fillbuffer ( ) ; if ( endofinput && ! encoderout . hasremaining ( ) ) { break ; } } } return read == _num && endofinput ? - _num : read ; }	read the specified number of bytes into an array .
public boolean isdisplayedexpectingcomponents ( ) { boolean result = _bool ; if ( conditions . isconditionmet ( visibilityof ( window ) ) ) { if ( components . isempty ( ) ) { closebutton . click ( ) ; } else { result = _bool ; } } return result ; }	this check contains a workaround for an issue in aem 6.
private void processrunstartedtag ( string identifier ) { pattern numtestspattern = pattern . compile ( _str ) ; matcher numtests = numtestspattern . matcher ( identifier ) ; if ( numtests . find ( ) ) { try { mnumtestsexpected = integer . parseint ( numtests . group ( _num ) ) ; } catch ( numberformatexception e ) { log . e ( log_tag , _str + numtests . group ( _num ) ) ; } } if ( mnumtestsexpected > _num ) { reporttestrunstarted ( ) ; mnumtestsrun = _num ; mtestruninprogress = _bool ; } }	parses and stores the test identifier ( class and test name ) .
public styledstring insert ( char ch , int offset ) throws stringindexoutofboundsexception { if ( offset < _num || offset > builder . length ( ) ) { throw new stringindexoutofboundsexception ( _str + offset + _str ) ; } builder . insert ( offset , ch ) ; return this ; }	inserts the character at the given offset.
public void addroot ( protoelement root ) { roots . add ( root ) ; }	add a root element to the model.
public void expandtoobjectandselect ( object elementortreepath , int level ) { if ( checkbusy ( ) ) { return ; } object parent = getparentelement ( elementortreepath ) ; if ( ( ( parent != null ) && getexpandedstate ( parent ) ) || isrootelement ( elementortreepath ) ) { widget w = internalgetwidgettoselect ( elementortreepath ) ; if ( null != w ) { list < object > selectionlist = new arraylist < > ( ) ; selectionlist . add ( w ) ; setselection ( selectionlist ) ; objecttoselect . set ( null ) ; } else { objecttoselect . set ( elementortreepath ) ; } } else { objecttoselect . set ( elementortreepath ) ; list < object > objectstoexpand = createobjectlist ( parent , new arraylist < > ( ) ) ; if ( ! objectstoexpand . isempty ( ) ) { objectstobeexpanded . addall ( objectstoexpand ) ; widget w = internalexpand ( elementortreepath , _bool ) ; if ( w != null ) { internalexpandtolevel ( w , level ) ; } } else { widget w = internalgetwidgettoselect ( elementortreepath ) ; if ( null != w ) { list < object > selectionlist = new arraylist < > ( ) ; selectionlist . add ( w ) ; setselection ( selectionlist ) ; objecttoselect . set ( null ) ; } } } }	expands all ancestors of the given element or tree path so that the given element becomes visible in this viewer ' s tree control , and then expands the subtree rooted at the given element to the given level.
public void appendcell ( float value ) { appendcell ( string . valueof ( value ) ) ; }	appends a new cell to the current row containing the provided float value .
public svnchangesetcollector ( isynchronizepageconfiguration configuration ) { super ( configuration ) ; }	constructs a new svnchangesetcollector used to collect incoming change sets.
public void ensuremaxsize ( int maxwidth , int maxheight , boolean keepproportions ) { int width = canvas . getwidth ( ) ; int height = canvas . getheight ( ) ; if ( keepproportions ) { if ( width > height ) { if ( width > maxwidth ) { height = math . round ( height *= maxwidth / ( double ) width ) ; width = maxwidth ; } } else { if ( height > maxheight ) { width = math . round ( width *= maxheight / ( double ) height ) ; height = maxheight ; } } } else { width = math . min ( width , maxwidth ) ; height = math . min ( height , maxheight ) ; } resize ( width , height ) ; }	ensure a max size for the image.
public static boolean isnormalized ( charsequence src , java . text . normalizer . form form , int option ) { return normalizerbase . isnormalized ( src . tostring ( ) , form , option ) ; }	determines if the given sequence of char values is normalized .
@ override public string tostring ( boolean freq ) { stringbuffer result = new stringbuffer ( ) ; result . append ( m_attribute . name ( ) + _str ) ; switch ( m_comparison ) { case equal : result . append ( _str ) ; break ; case less_than_or_equal_to : result . append ( _str ) ; break ; case greater_than : result . append ( _str ) ; break ; default : break ; } result . append ( _str + utils . doubletostring ( m_splitpoint , _num ) ) ; if ( freq ) { result . append ( _str + m_frequency ) ; } return result . tostring ( ) ; }	a string representation of this item , ( i.
public static string unescapesom ( string s ) { int idx = s . indexof ( _str ) ; if ( idx < _num ) return s ; stringbuilder sb = new stringbuilder ( ) ; int last = _num ; while ( idx >= _num ) { sb . append ( s . substring ( last , idx ) ) ; last = idx + _num ; idx = s . indexof ( _str , idx + _num ) ; } sb . append ( s . substring ( last ) ) ; return sb . tostring ( ) ; }	unescapes a som string fragment replacing " \.
void saveasync ( columnentity entity , duration ttl , consumer < columnentity > callback ) throws executeasyncqueryexception , unsupportedoperationexception ;	saves an entity asynchronously.
private static copystate readcopystate ( datainput in ) throws ioexception { byte [ ] infosbytes = new byte [ in . readvint ( ) ] ; in . readbytes ( infosbytes , _num , infosbytes . length ) ; long gen = in . readvlong ( ) ; long version = in . readvlong ( ) ; map < string , filemetadata > files = copyfileshandler . readfilesmetadata ( in ) ; int count = in . readvint ( ) ; set < string > completedmergefiles = new hashset < > ( ) ; for ( int i = _num ; i < count ; i ++ ) { completedmergefiles . add ( in . readstring ( ) ) ; } long primarygen = in . readvlong ( ) ; return new copystate ( files , version , gen , infosbytes , completedmergefiles , primarygen , null ) ; }	pulls copystate off the wire.
private void beforename ( ) throws ioexception { jsonscope context = peek ( ) ; if ( context == jsonscope . nonempty_object ) { out . write ( _str ) ; } else if ( context != jsonscope . empty_object ) { throw new illegalstateexception ( _str + stack ) ; } newline ( ) ; replacetop ( jsonscope . dangling_name ) ; }	inserts any necessary separators and whitespace before a name.
@ transactional public void redeem ( final string tokennumber , final string service ) { final token token = tokenrepository . findbytokennumberandservice ( tokennumber , service ) ; if ( token == null ) throw new applicationruntimeexception ( _str + tokennumber + _str ) ; redeem ( token ) ; }	checks whether a token can be redeemed and then redeems it i.
public int lightencolor ( int color , float factor ) { float r = color . red ( color ) * factor ; float g = color . green ( color ) * factor ; float b = color . blue ( color ) * factor ; int ir = math . min ( _num , ( int ) r ) ; int ig = math . min ( _num , ( int ) g ) ; int ib = math . min ( _num , ( int ) b ) ; int ia = color . alpha ( color ) ; return ( color . argb ( ia , ir , ig , ib ) ) ; }	lighten the given color by the factor.
private static string todatabasestring ( final operandsize size ) { switch ( size ) { case byte : return _str ; case word : return _str ; case dword : return _str ; case qword : return _str ; case oword : return _str ; case address : return _str ; default : throw new illegalargumentexception ( string . format ( _str , size ) ) ; } }	returns the database string of a given operand size .
static string filenameofclass ( final string classname , string typesuffix ) { return classname . replace ( _str , _str ) + _str + typesuffix ; }	get the file name of a class .
public void writepv ( processvar pv , int recursivedepth ) { writepv ( pv , recursivedepth , _bool ) ; }	write a process variable as xml to an output stream.
private static void assertqualns ( string qualns ) throws xmpexception { if ( qualns == null || qualns . length ( ) == _num ) { throw new xmpexception ( _str , xmperror . badschema ) ; } }	parameterasserts that a qualifier namespace is set .
public static stringbuilder formatto ( stringbuilder buf , float [ ] d , string sep , numberformat nf ) { if ( d == null ) { return buf . append ( _str ) ; } if ( d . length == _num ) { return buf ; } buf . append ( nf . format ( d [ _num ] ) ) ; for ( int i = _num ; i < d . length ; i ++ ) { buf . append ( sep ) ; buf . append ( nf . format ( d [ i ] ) ) ; } return buf ; }	formats the float array d with the specified number format .
public static void pack ( int [ ] n , string s ) { for ( int i = _num ; i < n . length ; i ++ ) { n [ i ] = _num ; } int idx = n . length - _num ; for ( int i = s . length ( ) - _num ; i >= _num ; i -- ) { n [ idx -- ] = s . charat ( i ) - _str ; } }	pack from string into array .
public int removeviewpoints ( int [ ] indices ) { for ( int i = indices . length - _num ; i >= _num ; -- i ) viewpointlist . remove ( indices [ i ] ) ; viewpointindex = indices [ _num ] - _num ; if ( viewpointlist . size ( ) == _num ) { viewpointindex = - _num ; } else if ( viewpointindex < _num ) { viewpointindex = viewpointlist . size ( ) - _num ; } return ( viewpointindex ) ; }	remove a viewpoint from the list.
public void clearonpagechangelisteners ( ) { if ( monpagechangelisteners != null ) { monpagechangelisteners . clear ( ) ; } }	remove all listeners that are notified of any changes in scroll state or position .
private void updatecolor ( ) { try { breakpointconditionparser . evaluate ( inputfield . gettext ( ) ) ; inputfield . setbackground ( color . white ) ; } catch ( final invalidformulaexception e ) { inputfield . setbackground ( color . red ) ; } }	updates the color of the input field depending on whether the entered formula string is valid or not .
public void removeignoredview ( view v ) { ignoredviews . remove ( v ) ; }	remove a view from ignored views ;.
public boolean writeheader ( outputstream os ) { try { writeint ( os , cache_magic ) ; writestring ( os , key ) ; writestring ( os , etag == null ? _str : etag ) ; writelong ( os , serverdate ) ; writelong ( os , lastmodified ) ; writelong ( os , ttl ) ; writelong ( os , softttl ) ; writestringstringmap ( responseheaders , os ) ; os . flush ( ) ; return _bool ; } catch ( ioexception e ) { vincilog . d ( _str , e . tostring ( ) ) ; return _bool ; } }	writes the contents of this cacheheader to the specified outputstream .
private static boolean ensurecurrent ( leasedresource resource ) { return resource . getexpiration ( ) > systemtime . timemillis ( ) ; }	utility method that check for valid resource.
public static int maxfill ( final int n , final float f ) { return math . min ( ( int ) math . ceil ( n * f ) , n - _num ) ; }	returns the maximum number of entries that can be filled before rehashing .
public void clear ( ) { mcategories . clear ( ) ; mtitles . clear ( ) ; mvalues . clear ( ) ; }	removes all the existing values from the series .
public void togglesectionselected ( int sectionindex ) { setsectionselected ( sectionindex , ! issectionselected ( sectionindex ) ) ; }	toggle selection state of an entire section.
public string combine ( list < string > files , string outfile ) throws exception { arraylist < string > cmd = new arraylist < string > ( ) ; cmd . add ( soxbin ) ; for ( string file : files ) { cmd . add ( file ) ; } cmd . add ( outfile ) ; int rc = execsox ( cmd , callback ) ; if ( rc != _num ) { throw new exception ( _str + rc ) ; } return outfile ; }	simple combiner sox file [ 0 ] file [ 1 ].
void stopscrollinginstance ( ) { if ( log . isloggable ( platformlogger . level . finer ) ) { log . finer ( _str + this ) ; } i_scroller . stop ( ) ; }	tell the instance scroller to stop scrolling . see 6243382 for more information.
public void execute2 ( kahanobject in1 , double in2 ) { if ( double . isinfinite ( in1 . _sum ) || double . isinfinite ( in2 ) ) { in1 . set ( double . isinfinite ( in2 ) ? in2 : in1 . _sum , _num ) ; return ; } double correction = in2 + in1 . _correction ; double sum = in1 . _sum + correction ; in1 . set ( sum , correction - ( sum - in1 . _sum ) ) ; }	simplified version of execute ( data in1 , double in2 ) without exception handling and casts .
public static response newfixedlengthresponse ( string msg ) { return newfixedlengthresponse ( status . ok , nanohttpd . mime_html , msg ) ; }	create a text response with known length .
@ override public xmlevent peek ( ) throws xmlstreamexception { log . log ( level . fine , _str ) ; if ( ! hasnext ( ) ) { throw new xmlstreamexception ( _str ) ; } log . log ( level . fine , _str , nextevent ) ; return nextevent ; }	check the next xmlevent without reading it from the stream.
public static string replaceendpoint ( string url , string endpoint ) { return endpoint + url . replacefirst ( default_endpoint , _str ) ; }	replace the url end point ( schema + host + port ) with the given end point .
private void makeokpath ( ) { path1 . reset ( ) ; int w2 = getmeasuredwidth ( ) / _num ; int h2 = getmeasuredheight ( ) / _num ; double a = math . cos ( math . toradians ( _num ) ) * getradius ( ) ; double c = math . sin ( math . toradians ( _num ) ) * getradius ( ) ; double l = math . cos ( math . toradians ( _num ) ) * _num * a ; double b = math . sin ( math . toradians ( _num ) ) * l ; double m = math . cos ( math . toradians ( _num ) ) * l ; path1 . moveto ( ( float ) ( w2 - a ) , ( float ) ( h2 - c ) ) ; path1 . lineto ( ( float ) ( w2 - a + m ) , ( float ) ( h2 - c + math . sin ( math . toradians ( _num ) ) * l ) ) ; path1 . lineto ( ( float ) ( w2 + a ) , ( float ) ( h2 - c ) ) ; pathmeasure1 . setpath ( path1 , _bool ) ; mmarkoklength = pathmeasure1 . getlength ( ) ; }	make the path to show.
public void addmembervalue ( string name , membervalue value ) { pair p = new pair ( ) ; p . name = pool . addutf8info ( name ) ; p . value = value ; if ( members == null ) members = new linkedhashmap ( ) ; members . put ( name , p ) ; }	adds a new member .
protected list < string > addwhitespace ( list < string > list ) { list < string > whitespacelist = new arraylist < > ( ) ; for ( string value : list ) { whitespacelist . add ( addwhitespace ( value ) ) ; } return whitespacelist ; }	adds leading and trailing whitespace characters to all members in this list .
public static string computequalifiedwidgettypename ( node widgetnode ) { if ( widgetnode . getnodetype ( ) != node . element_node ) { return null ; } string typename = widgetnode . getlocalname ( ) ; if ( typename . length ( ) == _num || character . islowercase ( typename . charat ( _num ) ) ) { return null ; } string packagename = uibinderutilities . getpackagename ( widgetnode . getnamespaceuri ( ) ) ; return packagename != null ? javautilities . getqualifiedtypename ( typename , packagename ) : null ; }	computes the fully qualified name for the widget - derived type at the given node .
private static boolean processftypatom ( parsablebytearray atomdata ) { atomdata . setposition ( atom . header_size ) ; int majorbrand = atomdata . readint ( ) ; if ( majorbrand == brand_quicktime ) { return _bool ; } atomdata . skipbytes ( _num ) ; while ( atomdata . bytesleft ( ) > _num ) { if ( atomdata . readint ( ) == brand_quicktime ) { return _bool ; } } return _bool ; }	process an ftyp atom to determine whether the media is quicktime .
public map < string , string > parse ( final string str , char separator ) { if ( str == null ) { return new hashmap < string , string > ( ) ; } return parse ( str . tochararray ( ) , separator ) ; }	extracts a map of name / value pairs from the given string.
public string delete ( string url , final int expectedstatuscode ) { return delete ( url , collections . < string , string > emptymap ( ) , expectedstatuscode ) ; }	issue an http delete and assert the response status code .
protected void runningsum ( set < map . entry < double , double > > c , double value , double [ ] sums ) { double offset = const - math . log ( m_width ) ; double logfactor = math . log ( m_threshold ) - math . log ( _num - m_threshold ) ; double logsumofweights = math . log ( m_sumofweights ) ; iterator < map . entry < double , double > > itr = c . iterator ( ) ; while ( itr . hasnext ( ) ) { map . entry < double , double > entry = itr . next ( ) ; if ( entry . getvalue ( ) > _num ) { double diff = ( entry . getkey ( ) - value ) / m_width ; double logdensity = offset - _num * diff * diff ; double logweight = math . log ( entry . getvalue ( ) ) ; sums [ _num ] = logofsum ( sums [ _num ] , logweight + logdensity ) ; sums [ _num ] = logofsum ( sums [ _num ] , logweight ) ; if ( logdensity + logsumofweights < logofsum ( logfactor + sums [ _num ] , logdensity + sums [ _num ] ) ) { break ; } } } }	compute running sum of density values and weights .
@ override public categoricaltable copy ( ) { map < value , double > newtable = new hashmap < value , double > ( ) ; for ( value v : table . keyset ( ) ) { newtable . put ( v , table . get ( v ) ) ; } return new categoricaltable ( variable , newtable ) ; }	returns a copy of the probability table.
public configuration subconfig ( string prefix , string keyprefix ) { configuration sub = new configuration ( ) ; addtosubconf ( sub , prefix . length ( ) > _num ? prefix + _str + keyprefix : keyprefix ) ; return sub ; }	return a sub configuration from this instance that has the keys equal to either prefix.
public map < string , string > mapnametodisplayname ( set < string > names ) throws smsexception , ssoexception { final map < string , string > map = new hashmap < > ( names . size ( ) ) ; for ( string name : names ) { if ( smsconsoleserviceconfig . isservicevisible ( name ) ) { final serviceschemamanager serviceschemamanager = serviceschemamanagerfactory . build ( name ) ; string displayname = getlocalizedservicename ( serviceschemamanager , name ) ; string resourcename = serviceschemamanager . getresourcename ( ) ; if ( ! name . equals ( displayname ) && ! stringutils . isblank ( resourcename ) ) { map . put ( resourcename , displayname ) ; } } } return map ; }	maps service internal names to displayable ( localized ) names via their resource names.
public intcolumn ( int nrows , int capacity , int defaultvalue ) { super ( int . class , new integer ( defaultvalue ) ) ; if ( capacity < nrows ) { throw new illegalargumentexception ( _str ) ; } m_values = new int [ capacity ] ; arrays . fill ( m_values , defaultvalue ) ; m_size = nrows ; }	create a new intcolumn .
@ override public string tostring ( ) { return _str + getid ( ) ; }	returns a string representation of the object .
public static final boolean executepotentialwork ( final object data , final imageview imageview ) { final bitmapworkertask bitmapworkertask = getbitmapworkertask ( imageview ) ; if ( bitmapworkertask != null ) { final object bitmapdata = bitmapworkertask . mkey ; if ( bitmapdata == null || ! bitmapdata . equals ( data ) ) { bitmapworkertask . cancel ( _bool ) ; } else { return _bool ; } } return _bool ; }	returns true if the current work has been canceled or if there was no work in progress on this image view.
public static void queuebitmap ( string key , bitmap bmp ) { mbitmapqueue . put ( key , bmp ) ; }	temporarily store a bitmap.
public void addlistener ( afterserverstartlistener listener ) { _afterstartlisteners . add ( listener ) ; }	adds a new afterstart listener for post - startup cleanup.
private int makeavailable ( ) throws ioexception { if ( pos != - _num ) { return _num ; } total += tail - head - pad ; system . arraycopy ( buffer , tail - pad , buffer , _num , pad ) ; head = _num ; tail = pad ; for ( ; ; ) { int bytesread = input . read ( buffer , tail , bufsize - tail ) ; if ( bytesread == - _num ) { final string msg = _str ; throw new fileuploadexception ( malformedstreamexception , msg ) ; } tail += bytesread ; findseparator ( ) ; int av = available ( ) ; if ( av > _num || pos != - _num ) { return av ; } } }	attempts to read more data .
public relationnotification ( string notiftype , object sourceobj , long sequence , long timestamp , string message , string id , string typename , objectname objectname , list < objectname > unregmbeanlist ) throws illegalargumentexception { super ( notiftype , sourceobj , sequence , timestamp , message ) ; if ( ! isvalidbasicstrict ( notiftype , sourceobj , id , typename ) || ! isvalidcreate ( notiftype ) ) { throw new illegalargumentexception ( _str ) ; } relationid = id ; relationtypename = typename ; relationobjname = safegetobjectname ( objectname ) ; unregistermbeanlist = safegetobjectnamelist ( unregmbeanlist ) ; }	creates a notification for either a relation creation ( relationsupport object created internally in the relation service , or an mbean added as a relation ) or for a relation removal from the relation service .
public void adddatatostore ( object [ ] row ) throws carbondatawriterexception { datarows . add ( row ) ; this . entrycount ++ ; if ( this . entrycount == this . blockletsize ) { try { semaphore . acquire ( ) ; producerexecutorservicetasklist . add ( producerexecutorservice . submit ( new producer ( blockletdataholder , datarows , ++ writertasksequencecounter ) ) ) ; blockletprocessingcount . incrementandget ( ) ; processeddatacount += entrycount ; logger . info ( _str + processeddatacount ) ; datarows = new arraylist < > ( this . blockletsize ) ; this . entrycount = _num ; } catch ( interruptedexception e ) { logger . error ( e , e . getmessage ( ) ) ; throw new carbondatawriterexception ( e . getmessage ( ) ) ; } } }	below method will be used to add row to store.
public boolean localhostordomainis ( string host , string domain ) { return domain . startswith ( host ) ; }	is true if the host name matches exactly the specified host name , or if there is no domain name part in the host name , but the unqualified host name matches .
protected double entropy ( double [ ] [ ] datazs , double [ ] [ ] dataws ) { double entropy = _num ; int numinstances = datazs . length ; for ( int j = _num ; j < m_numclasses ; j ++ ) { double m = _num ; double sum = _num ; for ( int i = _num ; i < numinstances ; i ++ ) { m += datazs [ i ] [ j ] * dataws [ i ] [ j ] ; sum += dataws [ i ] [ j ] ; } m /= sum ; for ( int i = _num ; i < numinstances ; i ++ ) { entropy += dataws [ i ] [ j ] * math . pow ( datazs [ i ] [ j ] - m , _num ) ; } } return entropy ; }	helper function to compute entropy from z / w values .
public void saveworkinginstancestofileq ( ) { if ( m_iothread == null ) { m_filechooser . setcapabilitiesfilter ( m_filtereditor . getcapabilitiesfilter ( ) ) ; m_filechooser . setacceptallfilefilterused ( _bool ) ; int returnval = m_filechooser . showsavedialog ( this ) ; if ( returnval == jfilechooser . approve_option ) { instances inst = new instances ( m_instances ) ; inst . setclassindex ( m_attvisualizepanel . getcoloringindex ( ) ) ; saveinstancestofile ( m_filechooser . getsaver ( ) , inst ) ; } filefilter temp = m_filechooser . getfilefilter ( ) ; m_filechooser . setacceptallfilefilterused ( _bool ) ; m_filechooser . setfilefilter ( temp ) ; } else { joptionpane . showmessagedialog ( this , _str + _str , _str , joptionpane . warning_message ) ; } }	queries the user for a file to save instances as , then saves the instances in a background process.
private void calculatecolor ( int coord ) { coord = coord - mbarpointerhaloradius ; if ( coord < _num ) { coord = _num ; } else if ( coord > mbarlength ) { coord = mbarlength ; } mcolor = color . hsvtocolor ( math . round ( mpostoopacfactor * coord ) , mhsvcolor ) ; if ( color . alpha ( mcolor ) > _num ) { mcolor = color . hsvtocolor ( mhsvcolor ) ; } else if ( color . alpha ( mcolor ) < _num ) { mcolor = color . transparent ; } }	calculate the color selected by the pointer on the bar .
public int read ( char cbuf [ ] , int off , int len ) throws ioexception { if ( ( off < _num ) || ( off > cbuf . length ) || ( len < _num ) || ( ( off + len ) > cbuf . length ) || ( ( off + len ) < _num ) ) throw new indexoutofboundsexception ( ) ; if ( len == _num ) return _num ; if ( next >= length ) return - _num ; int n = math . min ( length - next , len ) ; text . getchars ( next , next + n , cbuf , off ) ; next += n ; return n ; }	reads characters into a portion of an array .
private boolean adjustindent ( ) { alignmentimpl alignment = coreformatterutil . getalignment ( mycurrentblock ) ; whitespace whitespace = mycurrentblock . getwhitespace ( ) ; if ( alignment == null || myalignmentstoskip . contains ( alignment ) ) { if ( whitespace . containslinefeeds ( ) ) { adjustspacingbyindentoffset ( ) ; } else { whitespace . arrangespaces ( mycurrentblock . getspaceproperty ( ) ) ; } return _bool ; } blockalignmentprocessor alignmentprocessor = alignment_processors . get ( alignment . getanchor ( ) ) ; if ( alignmentprocessor == null ) { log . error ( string . format ( _str , alignment . getanchor ( ) ) ) ; return _bool ; } blockalignmentprocessor . context context = new blockalignmentprocessor . context ( mydocument , alignment , mycurrentblock , myalignmentmappings , mybackwardshiftedalignedblocks , getindentoptionstouse ( mycurrentblock , mydefaultindentoption ) , myrightmargin ) ; blockalignmentprocessor . result result = alignmentprocessor . applyalignment ( context ) ; final leafblockwrapper offsetresponsibleblock = alignment . getoffsetrespblockbefore ( mycurrentblock ) ; switch ( result ) { case target_block_processed_not_aligned : return _bool ; case target_block_aligned : storealignmentmapping ( ) ; return _bool ; case backward_block_aligned : if ( offsetresponsibleblock == null ) { return _bool ; } set < leafblockwrapper > blockscausedrealignment = new hashset < leafblockwrapper > ( ) ; mybackwardshiftedalignedblocks . clear ( ) ; mybackwardshiftedalignedblocks . put ( offsetresponsibleblock , blockscausedrealignment ) ; blockscausedrealignment . add ( mycurrentblock ) ; storealignmentmapping ( mycurrentblock , offsetresponsibleblock ) ; mycurrentblock = offsetresponsibleblock . getnextblock ( ) ; oncurrentlinechanged ( ) ; return _bool ; case recursion_detected : mycurrentblock = offsetresponsibleblock ; case unable_to_align_backward_block : myalignmentstoskip . add ( alignment ) ; return _bool ; default : return _bool ; } }	adjusts indent of the current block .
@ override public void appendcode ( type declaringtype , typetuple inputtypes , type outputtype , list < variable > inputvars , stringbuilder b ) { b . append ( field . tocode ( declaringtype , inputvars ) ) ; }	adds the text for an initialization of a variable from a field to the stringbuilder .
public forwardplanner ( dialoguesystem system ) { this . system = system ; }	constructs a forward planner for the dialogue system .
private jbutton addbutton ( string text , container container , float alignment ) { jbutton button = new jbutton ( text ) ; button . setalignmentx ( alignment ) ; container . add ( button ) ; return button ; }	adds a preconfigured jbutton to the specified container using the specified alignment constraint.
private boolean nomatchfortaginattributes ( attributeset attr , html . tag t , object tagvalue ) { if ( attr != null && attr . isdefined ( t ) ) { object newvalue = attr . getattribute ( t ) ; if ( ( tagvalue == null ) ? ( newvalue == null ) : ( newvalue != null && tagvalue . equals ( newvalue ) ) ) { return _bool ; } } return _bool ; }	searches the attribute set for a tag , both of which are passed in as a parameter.
public string businessobjectdatakeytostring ( businessobjectdatakey businessobjectdatakey ) { if ( businessobjectdatakey == null ) { return null ; } return businessobjectdatakeytostring ( businessobjectdatakey . getnamespace ( ) , businessobjectdatakey . getbusinessobjectdefinitionname ( ) , businessobjectdatakey . getbusinessobjectformatusage ( ) , businessobjectdatakey . getbusinessobjectformatfiletype ( ) , businessobjectdatakey . getbusinessobjectformatversion ( ) , businessobjectdatakey . getpartitionvalue ( ) , businessobjectdatakey . getsubpartitionvalues ( ) , businessobjectdatakey . getbusinessobjectdataversion ( ) ) ; }	returns a string representation of the business object data key .
private usage createtalkusage ( context context ) { if ( talkusage != null ) { return talkusage ; } typetoken < list < usage > > token = new typetoken < list < usage > > ( ) { } ; list < usage > inittalkio = jsonutils . parsejsonfile ( context , _str , token ) ; talkusage = inittalkio . get ( _num ) ; return talkusage ; }	get talk incoming / outgoing info from the json file and save in cache.
@ nullable public grcall enclosingcall ( string name , gdslmembersholderconsumer consumer ) { final psielement place = consumer . getplace ( ) ; if ( place == null ) return null ; grcall call = psitreeutil . getparentoftype ( place , grcall . class , _bool ) ; if ( call == null ) return null ; while ( call != null && ! name . equals ( getinvokedmethodname ( call ) ) ) { call = psitreeutil . getparentoftype ( call , grcall . class , _bool ) ; } if ( call == null ) return null ; final grargumentlist argumentlist = call . getargumentlist ( ) ; if ( argumentlist != null ) { for ( grexpression arg : argumentlist . getexpressionarguments ( ) ) { if ( arg instanceof grclosableblock && psitreeutil . findcommonparent ( place , arg ) == arg ) { return call ; } } } if ( call instanceof grmethodcallexpression ) { for ( grexpression arg : call . getclosurearguments ( ) ) { if ( arg instanceof grclosableblock && psitreeutil . findcommonparent ( place , arg ) == arg ) { return call ; } } } return null ; }	returns enclosing method call of a given context ' s place.
public static void genovfenvisoimage ( string ovfenvpropkvstr , string isofilepath ) { byte [ ] bovfenvpropkvstr = ovfenvpropkvstr . getbytes ( ) ; string propfilepath = _str ; file propfile = new file ( propfilepath ) ; try { fileutils . writeplainfile ( propfilepath , bovfenvpropkvstr ) ; } catch ( exception e1 ) { propfile . delete ( ) ; log . error ( _str , e1 . getmessage ( ) ) ; throw new illegalstateexception ( _str ) ; } try { file isofile = new file ( isofilepath ) ; string [ ] genisoimagecommand = { geniso_cmd , _str , _str , _str , propfilepath , _str , isofilepath , _str , _str } ; exec . result result = exec . sudo ( cmd_timeout , genisoimagecommand ) ; if ( ! result . exitednormally ( ) || result . getexitvalue ( ) != _num ) { log . error ( _str , result . getexitvalue ( ) , result . getstderror ( ) ) ; throw new illegalstateexception ( _str ) ; } } catch ( exception e ) { throw e ; } finally { propfile . delete ( ) ; } }	generate ovfenv iso image which will be then saved to ovfenv partition.
public static void createactionableevent ( dbclient dbclient , eventutils . eventcode eventcode , uri tenant , string name , string description , string warning , dataobject resource , list < uri > affectedresources , string approvemethod , object [ ] approveparameters ) { createactionableevent ( dbclient , eventcode , tenant , name , description , warning , resource , affectedresources , approvemethod , approveparameters , null , null ) ; }	creates an actionable event and persists to the database.
public rational ( byteprovider byteprovider ) throws ioexception { mxfpropertypopulator . populatefield ( byteprovider , this , _str ) ; mxfpropertypopulator . populatefield ( byteprovider , this , _str ) ; }	instantiates a new rational .
public synchronized void removenotifications ( string type ) throws instancenotfoundexception { vector < integer > v = getnotificationids ( type ) ; if ( v . isempty ( ) ) throw new instancenotfoundexception ( _str ) ; for ( integer i : v ) removenotification ( i ) ; }	removes all the timer notifications corresponding to the specified type from the list of notifications .
private void unifyviaatom ( atomic parentatom ) { atomic childatom = getruleconclusionatom ( ) ; query parent = parentatom . getparentquery ( ) ; map < string , string > unifiers = childatom . getunifiers ( parentatom ) ; head . unify ( unifiers ) ; body . unify ( unifiers ) ; set < string > childfvs = body . getvarset ( ) ; set < string > parentbvs = parentatom . getvarnames ( ) ; set < string > parentvars = parent . getvarset ( ) ; parentbvs . foreach ( null ) ; childfvs . foreach ( null ) ; }	propagate variables to child via a relation atom ( atom variables are bound ).
static void adduuid ( ssfnode node , uuid uuid ) { node . set ( _str , uuid . getmostsignificantbits ( ) ) ; node . set ( _str , uuid . getleastsignificantbits ( ) ) ; }	adds uuid value to given node as uuidmost and uuidleast tags .
public long objectfieldoffset ( field field ) { if ( modifier . isstatic ( field . getmodifiers ( ) ) ) { throw new illegalargumentexception ( _str ) ; } return objectfieldoffset0 ( field ) ; }	gets the raw byte offset from the start of an object ' s memory to the memory used to store the indicated instance field .
abstract void toxml ( stringbuilder xml , int level ) ;	generates the xml representation of the object ( without xml headers or enclosing plist - tags ) .
public void dispose ( ) { mrunbutton . setselected ( _bool ) ; super . dispose ( ) ; }	when the window closes , stop any sequences running.
public fluxconcatarray < t > concatadditionalsourcefirst ( publisher < ? extends t > source ) { int n = array . length ; @ suppresswarnings ( _str ) publisher < ? extends t > [ ] newarray = new publisher [ n + _num ] ; system . arraycopy ( array , _num , newarray , _num , n ) ; newarray [ _num ] = source ; return new fluxconcatarray < > ( delayerror , newarray ) ; }	returns a new instance which has the additional first source to be concatenated together with the current array of sources.
public void shutdown ( ) { shutdownserverthread ( ) ; shutdownsessions ( ) ; }	closes the server socket and all client sockets .
private boolean islocalid ( string localid ) { if ( ! localid . startswith ( _str ) ) { return _bool ; } for ( int i = _num ; i < localid . length ( ) ; ++ i ) { char c = localid . charat ( i ) ; if ( ! ( c >= _str && c <= _str ) && ! ( c >= _str && c <= _str ) ) { return _bool ; } } return _bool ; }	returns true if localid has the right basic format for a local id .
public serversocketbar bind ( serversocketbar ss ) throws configexception , ioexception { synchronized ( _sslinitlock ) { if ( _stdserversocket != null ) throw new configexception ( l . l ( _str ) ) ; try { initconfig ( ) ; } catch ( runtimeexception e ) { e . printstacktrace ( ) ; throw e ; } _stdserversocket = ss ; initssl ( ) ; return this ; } }	creates the server socket .
private int checkinterruptwhilewaiting ( node node ) { return thread . interrupted ( ) ? ( transferaftercancelledwait ( node ) ? throw_ie : reinterrupt ) : _num ; }	checks for interrupt , returning throw_ie if interrupted before signalled , reinterrupt if after signalled , or 0 if not interrupted .
private void resetoutputbuilders ( ) { ansi = ansi . ansi ( ) ; stringbuilder = new stringbuilder ( ) ; }	reset both output builders .
public void write ( string filename ) { logger . info ( _str ) ; try { openfile ( filename ) ; writexmlhead ( ) ; startcarriers ( this . writer ) ; for ( carrier carrier : carriers ) { startcarrier ( carrier , this . writer ) ; writevehicles ( carrier , this . writer ) ; writeshipments ( carrier , this . writer ) ; writeplans ( carrier , this . writer ) ; endcarrier ( this . writer ) ; } endcarriers ( this . writer ) ; close ( ) ; logger . info ( _str ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; logger . error ( e ) ; system . exit ( _num ) ; } }	writes carriers and their plans into a xml - file .
public void removeresourcelistener ( resourceeventslistener listener ) { resourcelisteners . remove ( listener ) ; }	un - registers a listener to the system.
public void testhasmainactivity ( ) throws exception { menabled . add ( launcheractivitydetector . issue_more_than_one_launcher ) ; menabled . add ( launcheractivitydetector . issue_missing_launcher ) ; menabled . add ( launcheractivitydetector . issue_launcher_activity_in_library ) ; string expected = _str ; string result = lintproject ( xml ( fn_android_manifest_xml , _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str ) ) ; assertequals ( expected , result ) ; }	test that a manifest with an activity with a launcher intent has no warnings .
private void informuponsimilarname ( final stringbuffer messagebuffer , final string name , final string candidate ) { if ( name . equals ( candidate ) ) { return ; } if ( name . regionmatches ( _bool , _num , candidate , _num , pkg_len + _num ) ) { messagebuffer . append ( _str ) ; messagebuffer . append ( candidate ) ; messagebuffer . append ( _str ) ; } }	appends message if the given name is similar to the candidate .
protected void writeheader ( randomaccessfile file , int size ) throws ioexception { string str ; int offset = _num ; byte [ ] buffer = new byte [ _num ] ; str = integer . tostring ( getsize ( ) ) ; for ( int i = _num ; i < ( _num - str . length ( ) ) ; i ++ ) { buffer [ i ] = ( byte ) _str ; } offset += ( _num - str . length ( ) ) ; for ( int i = _num ; i < str . length ( ) ; i ++ ) { buffer [ i + offset ] = ( byte ) str . charat ( i ) ; } file . write ( buffer ) ; }	this is called by superclass when attempt to write data from file .
public string buildjavavendor ( ) { return properties . getproperty ( _str ) ; }	returns the vendor for the java version used to generate this build .
public voiceresult ( string match , float confidence ) { mmatch = match ; mconfidence = confidence ; }	creates an instance of a voiceresult .
final void treeify ( node < k , v > [ ] tab ) { treenode < k , v > root = null ; for ( treenode < k , v > x = this , next ; x != null ; x = next ) { next = ( treenode < k , v > ) x . next ; x . left = x . right = null ; if ( root == null ) { x . parent = null ; x . red = _bool ; root = x ; } else { k k = x . key ; int h = x . hash ; class < ? > kc = null ; for ( treenode < k , v > p = root ; ; ) { int dir , ph ; k pk = p . key ; if ( ( ph = p . hash ) > h ) dir = - _num ; else if ( ph < h ) dir = _num ; else if ( ( kc == null && ( kc = comparableclassfor ( k ) ) == null ) || ( dir = comparecomparables ( kc , k , pk ) ) == _num ) dir = tiebreakorder ( k , pk ) ; treenode < k , v > xp = p ; if ( ( p = ( dir <= _num ) ? p . left : p . right ) == null ) { x . parent = xp ; if ( dir <= _num ) xp . left = x ; else xp . right = x ; root = balanceinsertion ( root , x ) ; break ; } } } } moveroottofront ( tab , root ) ; }	forms tree of the nodes linked from this node .
private void addcategorytotree ( defaultmutabletreenode node , string [ ] names ) { if ( names . length == _num ) { return ; } boolean matched = _bool ; for ( @ suppresswarnings ( _str ) enumeration < defaultmutabletreenode > e = node . children ( ) ; e . hasmoreelements ( ) ; ) { defaultmutabletreenode childnode = e . nextelement ( ) ; string nodename = ( string ) childnode . getuserobject ( ) ; if ( nodename . equals ( names [ _num ] ) ) { if ( names . length > _num ) { addcategorytotree ( childnode , arrays . copyofrange ( names , _num , names . length ) ) ; matched = _bool ; } else { } } } if ( ! matched ) { defaultmutabletreenode root = node ; for ( int i = _num ; i < names . length ; i ++ ) { defaultmutabletreenode newnode = new defaultmutabletreenode ( names [ i ] ) ; root . add ( newnode ) ; root = newnode ; } } }	this recursive method is a hack : directoryitems flattens the directory structure , but it provides useful functionality , so this method will reconstruct the directory structure for the jtree .
public void adddrawerlistener ( @ nonnull drawerlistener listener ) { if ( listener == null ) { return ; } if ( mlisteners == null ) { mlisteners = new arraylist < drawerlistener > ( ) ; } mlisteners . add ( listener ) ; }	adds the specified listener to the list of listeners that will be notified of drawer events .
private void editnote ( int noteid ) { hidesoftkeyboard ( ) ; intent intent = new intent ( mainactivity . this , noteactivity . class ) ; intent . setflags ( intent . flag_activity_clear_task ) ; intent . putextra ( _str , string . valueof ( noteid ) ) ; startactivity ( intent ) ; }	method used to enter note edition mode.
public final entry addentry ( position inputposition , position outputposition ) { entry entry = new entry ( inputposition , outputposition ) ; entries . add ( entry ) ; return entry ; }	adds an entry to the source map ( entry must be added in order ) .
public void unhideactionbar ( view view ) { if ( toolbarautohider != null ) toolbarautohider . showcomponent ( ) ; }	onclick handler - unhide action bar.
public static string formattimedelta ( long time , charsequence sep ) { final stringbuilder sb = new stringbuilder ( ) ; final formatter fmt = new formatter ( sb ) ; for ( int i = time_unit_sizes . length - _num ; i >= _num ; -- i ) { if ( i == _num && sb . length ( ) > _num ) { continue ; } if ( sb . length ( ) > _num ) { sb . append ( sep ) ; } final long acvalue = time / time_unit_sizes [ i ] ; time = time % time_unit_sizes [ i ] ; if ( ! ( acvalue == _num && sb . length ( ) == _num ) ) { fmt . format ( _str + time_unit_digits [ i ] + _str , long . valueof ( acvalue ) , time_unit_names [ i ] ) ; } } fmt . close ( ) ; return sb . tostring ( ) ; }	formats a time delta in human readable format .
public static double [ ] deconvolve ( final double [ ] p , final double rate ) { final double [ ] r = arrays . copyof ( p , p . length ) ; for ( int k = _num ; k < p . length ; k ++ ) { for ( int j = _num ; j < p . length ; j ++ ) { if ( k + j < p . length ) { r [ k + j ] -= rate * p [ k ] * p [ j ] ; } } } double sum = _num ; for ( final double q : r ) { sum += q ; } sum = _num / sum ; for ( int k = _num ; k < r . length ; k ++ ) { r [ k ] *= sum ; } return r ; }	takes a probability distribution and reduces higher - order terms by contributions arising from combinations of lower order terms.
public static string collapsenewlines ( string str ) { return collapsecharacter ( str , _str ) ; }	remove / collapse multiple newline characters.
private synchronized void readobject ( java . io . objectinputstream s ) throws ioexception , classnotfoundexception { s . defaultreadobject ( ) ; init ( getname ( ) ) ; }	readobject is called to restore the state of the execoptionpermission from a stream .
public static double calculatecolumntotal ( values2d data , int column , int [ ] validrows ) { paramchecks . nullnotpermitted ( data , _str ) ; double total = _num ; int rowcount = data . getrowcount ( ) ; for ( int v = _num ; v < validrows . length ; v ++ ) { int row = validrows [ v ] ; if ( row < rowcount ) { number n = data . getvalue ( row , column ) ; if ( n != null ) { total += n . doublevalue ( ) ; } } } return total ; }	returns the total of the values in one column of the supplied data table by taking only the row numbers in the array into account .
public boolean openanalysis ( file f , savetype savetype ) { if ( ! f . exists ( ) || ! f . canread ( ) ) { throw new illegalargumentexception ( _str + f . getpath ( ) ) ; } mainframeloadsavehelper . prepareforfileload ( f , savetype ) ; mainframeloadsavehelper . loadanalysis ( f ) ; return _bool ; }	opens the analysis . also clears the source and summary panes . makes comments enabled false . sets the savetype and adds the file to the recent menu .
public void childrenremoved ( beancontextmembershipevent bcme ) { findandundo ( bcme . iterator ( ) ) ; }	method for beancontextmembership interface .
public string process ( item item ) throws processexception { int count = _num ; item ss = item . getitemas ( relation . syllable ) ; item firstsyllable = last_last_syllable_path . finditem ( item ) ; for ( item p = ss ; p != null ; p = p . getnext ( ) ) { if ( p . equalsshared ( firstsyllable ) ) { break ; } count ++ ; } return integer . tostring ( rail ( count ) ) ; }	performs some processing on the given item .
private void removeinstancesfromcontainers ( arraylist < container > containers , map < integer , list < instanceid > > allocation , map < string , integer > componentstoscaledown ) { arraylist < ramrequirement > ramrequirements = getraminstances ( componentstoscaledown ) ; for ( ramrequirement ramrequirement : ramrequirements ) { string component = ramrequirement . getcomponentname ( ) ; int numinstancestoremove = - componentstoscaledown . get ( component ) ; for ( int j = _num ; j < numinstancestoremove ; j ++ ) { pair < integer , instanceid > idpair = removerrinstance ( containers , component ) ; list < instanceid > instances = allocation . get ( idpair . first ) ; instances . remove ( idpair . second ) ; allocation . put ( idpair . first , instances ) ; } } }	removes instances from containers during scaling down.
protected void drawnormalmessage ( drawhandler drawhandler , pointdouble send , pointdouble receive , relationdrawer . arrowendtype arrowendtype , boolean fillarrow , drawinginfo drawinginfo ) { line line = new line ( send , receive ) ; drawhandler . drawline ( line ) ; drawhandler . setlinetype ( linetype . solid ) ; relationdrawer . drawarrowtoline ( receive , drawhandler , line , _bool , arrowendtype , fillarrow , _bool ) ; double height = send . y - drawinginfo . getverticalstart ( sendtick ) ; double topleftx ; alignhorizontal halignment ; if ( from == getfirstlifeline ( ) ) { topleftx = send . x ; halignment = alignhorizontal . left ; } else { topleftx = receive . x ; halignment = alignhorizontal . right ; } if ( duration == _num ) { halignment = alignhorizontal . center ; } topleftx += lifeline_text_padding ; textsplitter . drawtext ( drawhandler , textlines , topleftx , send . y - height , math . abs ( send . x - receive . x ) - lifeline_text_padding * _num , height , halignment , alignvertical . bottom ) ; }	draws a message which is sent between two different lifelines.
private void killconsist ( ) { if ( validlocoadr ( locotextfield1 . gettext ( ) ) < _num ) { return ; } int locoaddr = getlocoaddr ( locotextfield1 , adrbutton1 ) ; sendncebinarycommand ( locoaddr , ncebinarycommand . loco_cmd_kill_consist , ( byte ) _num ) ; }	kills consist using lead loco address.
public listenkey startlistening ( ) throws ioexception { return startlistening ( null , _num ) ; }	listen on the default address.
@ nonnull public static set < flag > parse ( @ nonnegative final int bitmask ) { check . notnegative ( bitmask , _str ) ; final set < flag > flags = new hashset < flag > ( ) ; for ( final flag flag : values ( ) ) { if ( ( bitmask & flag . getnumber ( ) ) != _num ) { flags . add ( flag ) ; } } return flags ; }	parses a sum of flags as numerical values ( bitmask ) and translates it to set of enum values .
protected boolean engineverify ( byte [ ] sigbytes ) throws signatureexception { if ( sigbytes == null ) { throw new nullpointerexception ( _str ) ; } return checksignature ( sigbytes , _num , _num ) ; }	verifies the signature bytes .
public void addmatchstring ( string matchstring ) { matchstrings . add ( matchstring ) ; }	add string to see if it matches in the query.
public string timeago ( final long millis ) { return time ( system . currenttimemillis ( ) - millis ) ; }	get time ago that milliseconds date occurred.
public static byte [ ] hexstringtobytearray ( string input ) { if ( ( input == null ) || ( input . length ( ) % _num != _num ) ) { throw new illegalargumentexception ( _str + _str + input ) ; } byte [ ] output = new byte [ input . length ( ) / _num ] ; for ( int i = _num ; i < output . length ; i ++ ) { output [ i ] = ( byte ) ( ( character . digit ( input . charat ( i * _num ) , _num ) << _num ) + character . digit ( input . charat ( i * _num + _num ) , _num ) ) ; } return output ; }	converts a string with an even number of hexadecimal characters to a byte array .
private boolean stoptrackingjob ( jobstatus jobstatus ) { boolean removed ; boolean rocking ; synchronized ( mjobs ) { removed = mjobs . remove ( jobstatus ) ; rocking = mreadytorock ; } if ( removed && rocking ) { for ( int i = _num ; i < mcontrollers . size ( ) ; i ++ ) { statecontroller controller = mcontrollers . get ( i ) ; controller . maybestoptrackingjob ( jobstatus ) ; } } return removed ; }	called when we want to remove a jobstatus object that we ' ve finished executing.
public double coefficientofvariance ( ) { return math . sqrt ( variance ( ) ) / mean ( ) ; }	returns the coefficient of variance .
public string tostring ( ) { stringbuilder buf = new stringbuilder ( ) ; buf . append ( this . coefficient ) ; if ( this . variables . length > _num ) { buf . append ( _str ) ; } for ( int variable : this . variables ) { buf . append ( _str ) ; buf . append ( variable ) ; buf . append ( _str ) ; } return buf . tostring ( ) ; }	prints out a representation of the term .
public skeletonversionchecker ( int defaultversion ) { myexplicitversion = createtreemap ( ) ; mydefaultversion = defaultversion ; load ( ) ; }	creates an instance , loads requirements file .
@ override public attributeschemaimpl upgradeattribute ( attributeschemaimpl newattr ) throws upgradeexception { return updatedefaultvalues ( newattr , collections . singleton ( oldest_version ) ) ; }	this is called when the service is added for the first time and it will change the default install value of an attribute .
public static string todalvikname ( string canonicalname ) { final boolean isarray = ( canonicalname . charat ( _num ) == _str ) ; if ( isarray ) { return canonicalname . replace ( _str , _str ) ; } else { if ( canonicalname . equals ( _str ) ) return _str ; else if ( canonicalname . equals ( _str ) ) return _str ; else if ( canonicalname . equals ( _str ) ) return _str ; else if ( canonicalname . equals ( _str ) ) return _str ; else if ( canonicalname . equals ( _str ) ) return _str ; else if ( canonicalname . equals ( _str ) ) return _str ; else if ( canonicalname . equals ( _str ) ) return _str ; else if ( canonicalname . equals ( _str ) ) return _str ; else if ( canonicalname . equals ( _str ) ) return _str ; else return _str + canonicalname . replace ( _str , _str ) + _str ; } }	convert a canonical java class name to dalvik flavor .
private void emitensurecollection ( method method , string fieldname , stringbuilder builder ) { builder . append ( _str ) ; builder . append ( getensurename ( fieldname ) ) ; builder . append ( _str ) ; builder . append ( _str ) ; builder . append ( fieldname ) ; builder . append ( _str ) ; builder . append ( fieldname ) ; builder . append ( _str ) ; builder . append ( getimplname ( method . getgenericreturntype ( ) , _bool ) ) ; builder . append ( _str ) ; builder . append ( _str ) ; builder . append ( _str ) ; }	emit a method that ensures a collection is initialized .
public void unregisterclient ( clientproxymembershipid proxyid , acceptorimpl acceptor , boolean clientdisconnectedcleanly ) { unregisterclient ( proxyid ) ; if ( acceptor != null ) { cacheclientnotifier ccn = acceptor . getcacheclientnotifier ( ) ; if ( ccn != null ) { try { ccn . unregisterclient ( proxyid , clientdisconnectedcleanly ) ; } catch ( cancelexception ignore ) { } } } }	unregisters a client to be monitored .
private string doublequoteshandling ( string resource ) { return resource . replaceall ( _str , matcher . quotereplacement ( _str ) ) ; }	this method handles double quotes .
public static int allocatenewcontainer ( arraylist < container > containers , resource capacity , int paddingpercentage ) { containers . add ( new container ( capacity , paddingpercentage ) ) ; return containers . size ( ) ; }	allocate a new container of a given capacity.
public static boolean islocalresourceuri ( uri uri ) { final string scheme = getschemeornull ( uri ) ; return local_resource_scheme . equals ( scheme ) ; }	check if uri represents local resource.
protected string dowaitforpath ( string filepath ) { string path = null ; long waittimemillis = _num ; asserttrue ( _str + filepath + _str , msm . isobbmounted ( filepath ) ) ; while ( path == null ) { try { thread . sleep ( wait_time_incr ) ; waittimemillis += wait_time_incr ; if ( waittimemillis > max_wait_time ) { fail ( _str + filepath ) ; } } catch ( interruptedexception e ) { } path = msm . getmountedobbpath ( filepath ) ; } log . i ( log_tag , _str + path ) ; return path ; }	helper to synchronously wait until we can get a path for a given obb file.
@ override protected boolean iszonelevelresource ( ) { return _bool ; }	block consistency group is not a zone level resource.
private void validatemessage ( string expectedtype , string type , long returncode , string service , string payload ) throws replicatorexception { if ( ! type . equals ( expectedtype ) ) { throw new replicatorexception ( _str + protocol . type_filtered + _str + type + _str ) ; } else if ( returncode != _num ) { throw new replicatorexception ( _str + returncode + _str + payload ) ; } else if ( ! service . equals ( messagegenerator . getservice ( ) ) ) { throw new replicatorexception ( _str + service + _str + messagegenerator . getservice ( ) + _str ) ; } }	protocol safety checks for the server returned message .
private void closedatabases ( ) { s_logger . log ( level . info , _str ) ; s_logger . log ( level . info , _str ) ; m_source . close ( ) ; m_target . close ( ) ; m_source . reset ( ) ; m_source = null ; m_target . reset ( ) ; m_target = null ; m_direction = null ; m_objecttype = null ; m_objecttypes = null ; m_sourcemap = null ; m_targetmap = null ; m_objectlist = new arraylist < string > ( ) ; m_trackinglist = new arraylist < string > ( ) ; m_tempindexes = null ; m_counterprg = null ; m_counterdrp = null ; m_counterupd = null ; m_counteradd = null ; m_totalprg = null ; m_totaldrp = null ; m_totalupd = null ; m_totaladd = null ; m_detailtype = null ; m_detailtypes = null ; m_detailcounterdrp = null ; m_detailcounterupd = null ; m_detailcounteradd = null ; system . gc ( ) ; }	closes target and source databases.
public static byte [ ] md5 ( final byte [ ] message , final int offset , final int length ) { messagedigest digest ; try { digest = messagedigest . getinstance ( _str ) ; digest . update ( message , offset , length ) ; final byte [ ] md5 = digest . digest ( ) ; return md5 ; } catch ( final nosuchalgorithmexception e ) { if ( cfg . exception ) { check . log ( e ) ; } } return null ; }	calcola il md5 del messaggio , usando la crypto api .
private int runmetastorecomparejob ( optional < path > inputtablelistpath , path outputpath ) throws interruptedexception , ioexception , classnotfoundexception , templaterenderexception { log . info ( _str ) ; int result ; if ( inputtablelistpath . ispresent ( ) ) { result = runmetastorecomparejobwithtextinput ( inputtablelistpath . get ( ) , outputpath ) ; } else { result = runmetastorecomparejob ( outputpath ) ; } if ( result == _num ) { log . info ( _str + _str + velocityutils . rendertemplate ( step1_hql_template , velocitycontext ) ) ; } return result ; }	runs the job to scan the metastore for directory locations .
public void deletesubpeoplecontainers ( set peoplecontainers ) throws amexception , ssoexception { iterator iter = peoplecontainers . iterator ( ) ; while ( iter . hasnext ( ) ) { string peoplecontainerdn = ( string ) iter . next ( ) ; ampeoplecontainer peoplecontainer = new ampeoplecontainerimpl ( super . token , peoplecontainerdn ) ; peoplecontainer . delete ( ) ; } }	deletes sub people containers in this people container .
private void testfindrecentmessageuidsinmailbox ( ) throws exception { log . info ( _str ) ; list < messageuid > recentmessages = messagemapper . findrecentmessageuidsinmailbox ( mboxes . get ( _num ) ) ; assertequals ( message_no . size ( ) - _num , recentmessages . size ( ) ) ; }	test of findrecentmessageuidsinmailbox method , of class hbasemessagemapper .
public void queueevent ( runnable r ) { if ( r == null ) { throw new illegalargumentexception ( _str ) ; } synchronized ( sglthreadmanager ) { meventqueue . add ( r ) ; sglthreadmanager . notifyall ( ) ; } }	queue an " event " to be run on the gl rendering thread .
private void adderrormessage ( string message ) { if ( message != null ) { m_errormessages . append ( message ) ; } m_errormessages . append ( _str ) ; }	return list of error messages found while parsing last template .
@ suppresswarnings ( _str ) protected final void ensurecapacity ( long targetsize ) { long capacity = capacity ( ) ; if ( targetsize > capacity ) { inflatespine ( ) ; for ( int i = spineindex + _num ; targetsize > capacity ; i ++ ) { if ( i >= spine . length ) { int newspinesize = spine . length * _num ; spine = arrays . copyof ( spine , newspinesize ) ; priorelementcount = arrays . copyof ( priorelementcount , newspinesize ) ; } int nextchunksize = chunksize ( i ) ; spine [ i ] = ( e [ ] ) new object [ nextchunksize ] ; priorelementcount [ i ] = priorelementcount [ i - _num ] + spine [ i - _num ] . length ; capacity += nextchunksize ; } } }	ensure that the buffer has at least capacity to hold the target size.
public void write ( string key , byte [ ] newvalue ) throws exception { map < string , byte [ ] > entry = new hashmap < > ( ) ; entry . put ( key , newvalue ) ; write ( entry ) ; }	performs the best effort of updating zk node { basepath } / { key } to the provided value.
public string query ( string handler , solrqueryrequest req ) throws exception { try ( solrcore core = getcoreinc ( ) ) { solrqueryresponse rsp = new solrqueryresponse ( ) ; solrrequestinfo . setrequestinfo ( new solrrequestinfo ( req , rsp ) ) ; core . execute ( core . getrequesthandler ( handler ) , req , rsp ) ; if ( rsp . getexception ( ) != null ) { throw rsp . getexception ( ) ; } stringwriter sw = new stringwriter ( _num ) ; queryresponsewriter responsewriter = core . getqueryresponsewriter ( req ) ; responsewriter . write ( sw , req , rsp ) ; req . close ( ) ; return sw . tostring ( ) ; } finally { req . close ( ) ; solrrequestinfo . clearrequestinfo ( ) ; } }	processes a " query " using a user constructed solrqueryrequest , and closes the request at the end .
private boolean bothlinkshavesamelinkstats ( link linka , link linkb ) { boolean bothlinkshavesamelinkstats = _bool ; if ( linka . getfreespeed ( ) != linkb . getfreespeed ( ) ) { bothlinkshavesamelinkstats = _bool ; } if ( linka . getcapacity ( ) != linkb . getcapacity ( ) ) { bothlinkshavesamelinkstats = _bool ; } return bothlinkshavesamelinkstats ; }	compare link attributes . return whether they are the same or not .
public string generatesanitizedid ( ) { string result = generateid ( ) ; result = result . replace ( _str , _str ) ; result = result . replace ( _str , _str ) ; result = result . replace ( _str , _str ) ; return result ; }	generate a unique id - that is friendly for a url or file system.
public static synchronized void removeprovider ( int providernumber ) { provider p = providers . remove ( providernumber - _num ) ; providersnames . remove ( p . getname ( ) ) ; setneedrefresh ( ) ; }	removes the provider at the specified 1 - based position .
private object parseelement ( node element ) throws xmlparseexception { try { return parseelementraw ( element ) ; } catch ( exception e ) { throw new xmlparseexception ( _str + element . getnodename ( ) , e ) ; } }	parses a ( non - top ) xml element .
public static string format ( money money ) { long microamount = _num ; if ( money != null ) { microamount = money . getmicroamount ( ) ; } else { return placeholder_null ; } double amount = ( double ) microamount / micro_units ; return string . format ( format_money , amount ) ; }	formats a given monetary value in a default format ( 2 decimals , padded left to 10 characters ) .
private void deleteinstance ( entryclass eclass ) { int idx = entryclasses . indexof ( eclass ) ; eclass = ( entryclass ) entryclasses . get ( idx ) ; int num = eclass . getnuminstances ( ) - _num ; if ( num == _num ) entryclasses . remove ( idx ) ; eclass . setnuminstances ( num ) ; }	delete an instance of the entryclass , and remove the class from entryclasses if this is the last such instance .
public properties readsettings ( ) { try { string pacscripturl = detectscripturlperdhcp ( ) ; if ( pacscripturl == null ) { pacscripturl = detectscripturlperdns ( ) ; } if ( pacscripturl == null ) { return null ; } properties result = new properties ( ) ; result . setproperty ( _str , pacscripturl ) ; return result ; } catch ( ioexception e ) { return new properties ( ) ; } }	loads the settings and stores them in a properties map .
public void logwarning ( string message ) { logger . warning ( logprefix + message ) ; }	logs a warning message using the logger of this interpreter .
public static string readasstring ( inputstream is ) throws ioexception { stringbuffer buf = new stringbuffer ( ) ; byte [ ] b = new byte [ _num ] ; int nread = - _num ; while ( ( nread = is . read ( b ) ) >= _num ) { string s = new string ( b , _num , nread ) ; buf . append ( s ) ; } return buf . tostring ( ) ; }	reads an input stream into a single string result .
public arrayfieldvector ( int size , t preset ) { this ( preset . getfield ( ) , size ) ; arrays . fill ( data , preset ) ; }	construct a vector with preset values .
public static synchronized void unregistertransactionserviceplugin ( transactionserviceplugin l ) { if ( service_ != null ) { service_ . removetslistener ( l ) ; } tslistenerslist_ . remove ( l ) ; }	remove a transaction service listener .
protected static void isort ( int level [ ] , float bc [ ] ) { float temp ; int temp2 ; for ( int i = _num ; i < bc . length - _num ; i ++ ) { int j = i ; temp = bc [ j + _num ] ; temp2 = level [ j + _num ] ; if ( temp == _num ) { continue ; } int prej = j + _num ; while ( j > - _num && ( temp < bc [ j ] || bc [ j ] == _num ) ) { if ( bc [ j ] == _num ) { j -- ; continue ; } else { bc [ prej ] = bc [ j ] ; level [ prej ] = level [ j ] ; prej = j ; j -- ; } } bc [ prej ] = temp ; level [ prej ] = temp2 ; } }	this methods sorts the vertices in level [ ] according to their barycenters in bc [ ] , using insertion sort.
public void testisconsistentmodelclass ( ) { sessionnode node1 = new sessionnode ( type1 . class ) ; sessionnode node2 = new sessionnode ( type2 . class ) ; sessionnode node3 = new sessionnode ( type3 . class ) ; sessionnode node4 = new sessionnode ( new class [ ] { type1 . class , type2 . class } ) ; sessionnode node6 = new sessionnode ( new class [ ] { type1 . class , type2 . class , type3 . class } ) ; sessionnode node7 = new sessionnode ( new class [ ] { type1 . class , type4 . class } ) ; list parents = new arraylist ( ) ; parents . add ( node1 ) ; parents . add ( node2 ) ; parents . add ( node3 ) ; parents . remove ( node1 ) ; parents . remove ( node2 ) ; parents . remove ( node3 ) ; parents . add ( node4 ) ; asserttrue ( node1 . isconsistentmodelclass ( type1 . class , parents , _bool ) ) ; parents . add ( node6 ) ; asserttrue ( node1 . isconsistentmodelclass ( type1 . class , parents , _bool ) ) ; parents . remove ( node6 ) ; parents . add ( node7 ) ; asserttrue ( ! node1 . isconsistentmodelclass ( type1 . class , parents , _bool ) ) ; }	tests whether model classes can identified correctly as consistent .
public void findandinit ( object someobj ) { if ( someobj instanceof com . bbn . openmap . mapbean ) { logger . fine ( _str ) ; setmapbean ( ( mapbean ) someobj ) ; } }	look at the object received in a maphandler status message and connect to it if necessary .
public void removealllayers ( ) { _layers . removeallelements ( ) ; refreshlayers = _bool ; super . repaint ( ) ; }	removes all layers from the map.
public int size ( ) { return productions . size ( ) ; }	returns the number of productions contained in this rule .
public static future < boxedunit > zkasynccreatefullpathoptimistic ( final zookeeperclient zkc , final string pathtocreate , final byte [ ] data , final list < acl > acl , final createmode createmode ) { optional < string > parentpathshouldnotcreate = optional . absent ( ) ; return zkasynccreatefullpathoptimistic ( zkc , pathtocreate , parentpathshouldnotcreate , data , acl , createmode ) ; }	asynchronously create zookeeper path recursively and optimistically .
private void writeobject ( objectoutputstream oos ) throws ioexception { oos . defaultwriteobject ( ) ; writestroke ( oos , stroke , omgraphicadapter . basic_stroke ) ; writetexturemask ( oos , texturemask ) ; }	write this object to a stream .
public boolean equals ( object obj ) { if ( obj instanceof mrfqresponselineqty ) { mrfqresponselineqty cmp = ( mrfqresponselineqty ) obj ; if ( ! cmp . isvalidamt ( ) || ! isvalidamt ( ) ) return _bool ; bigdecimal cmpnet = cmp . getnetamt ( ) ; if ( cmpnet == null ) return _bool ; bigdecimal net = cmp . getnetamt ( ) ; if ( net == null ) return _bool ; return cmpnet . compareto ( net ) == _num ; } return _bool ; }	is net amount equal ?.
public reflectiveattribute ( class < o > objecttype , class < a > fieldtype , string fieldname ) { super ( objecttype , fieldtype , fieldname ) ; field field ; try { field = getfield ( objecttype , fieldname ) ; if ( ! field . isaccessible ( ) ) { field . setaccessible ( _bool ) ; } } catch ( exception e ) { throw new illegalstateexception ( _str + fieldname + _str + objecttype . getname ( ) + _str ) ; } if ( ! fieldtype . isassignablefrom ( field . gettype ( ) ) ) { throw new illegalstateexception ( _str + fieldname + _str + field . gettype ( ) + _str + objecttype . getname ( ) + _str + fieldtype . getname ( ) ) ; } this . field = field ; }	creates an attribute which reads values from the field indicated using reflection .
private void processevent ( eventlogcontrol check , final string name , final dtnhost host1 , final dtnhost host2 , final message message ) { string descstring ; if ( ! check . showevent ( ) ) { return ; } descstring = name + _str + ( host1 != null ? host1 : _str ) + ( host2 != null ? ( host_delim + host2 ) : _str ) + ( message != null ? _str + message : _str ) ; if ( regexp != null && ! descstring . matches ( regexp ) ) { return ; } if ( check . pauseonevent ( ) ) { gui . setpaused ( _bool ) ; if ( host1 != null ) { gui . setfocus ( host1 ) ; } } addevent ( name , host1 , host2 , message , check . pauseonevent ( ) ) ; }	processes a log event.
public boolean removemembershiplistener ( membershiplistener listener ) { return membershiplisteners . remove ( listener ) != null ; }	remove listener from the list to receive notification when a provile is added or removed .
public static uri addmessagetouri ( contentresolver resolver , uri uri , string address , string body , string subject , long date , boolean read , boolean deliveryreport , long threadid ) { contentvalues values = new contentvalues ( _num ) ; values . put ( address , address ) ; if ( date != null ) { values . put ( date , date ) ; } values . put ( read , read ? integer . valueof ( _num ) : integer . valueof ( _num ) ) ; values . put ( subject , subject ) ; values . put ( body , body ) ; if ( deliveryreport ) { values . put ( status , status_pending ) ; } if ( threadid != - _num ) { values . put ( thread_id , threadid ) ; } return resolver . insert ( uri , values ) ; }	add an sms to the given uri with thread_id specified .
private void present ( ) { gluseprogram ( quadprogram ) ; glbindbuffer ( gl_array_buffer , vbo ) ; glactivetexture ( gl_texture0 ) ; glbindtexture ( gl_texture_2d , tex ) ; gldrawarrays ( gl_triangles , _num , _num ) ; glactivetexture ( gl_texture0 ) ; glbindtexture ( gl_texture_2d , _num ) ; glbindbuffer ( gl_array_buffer , _num ) ; gluseprogram ( _num ) ; }	present the final image on the screen / viewport .
public static calendar next ( calendar self ) { calendar result = ( calendar ) self . clone ( ) ; result . add ( calendar . day_of_year , _num ) ; return result ; }	increment a calendar by one day .
protected void angularobjectclientbind ( notebooksocket conn , hashset < string > userandroles , notebook notebook , message frommessage ) throws exception { string noteid = frommessage . gettype ( _str ) ; string varname = frommessage . gettype ( _str ) ; object varvalue = frommessage . get ( _str ) ; string paragraphid = frommessage . gettype ( _str ) ; note note = notebook . getnote ( noteid ) ; if ( paragraphid == null ) { throw new illegalargumentexception ( _str + _str ) ; } if ( note != null ) { final interpretergroup interpretergroup = findinterpretergroupforparagraph ( note , paragraphid ) ; final angularobjectregistry registry = interpretergroup . getangularobjectregistry ( ) ; if ( registry instanceof remoteangularobjectregistry ) { remoteangularobjectregistry remoteregistry = ( remoteangularobjectregistry ) registry ; pushangularobjecttoremoteregistry ( noteid , paragraphid , varname , varvalue , remoteregistry , interpretergroup . getid ( ) , conn ) ; } else { pushangularobjecttolocalrepo ( noteid , paragraphid , varname , varvalue , registry , interpretergroup . getid ( ) , conn ) ; } } }	push the given angular variable to the target interpreter angular registry given a noteid and a paragraph id.
public static < t > void removeall ( list < t > list , list < integer > indexes ) { if ( list == null || indexes == null ) { return ; } collections . sort ( indexes , collections . reverseorder ( ) ) ; final int size = list . size ( ) ; for ( integer index : indexes ) { if ( index >= _num && index < size ) { list . remove ( ( int ) index ) ; } } }	removes from the given list the elements at the given indexes.
public cprojecttree ( final jframe parent , final cdatabasemanager databasemanager ) { preconditions . checknotnull ( databasemanager , _str ) ; m_treemodel = new cprojecttreemodel ( this ) ; setmodel ( m_treemodel ) ; cprojecttreedraghandlerinitializer . initialize ( parent , this , databasemanager ) ; addmouselistener ( new internalmouselistener ( ) ) ; setscrollsonexpand ( _bool ) ; setrootvisible ( _bool ) ; m_rootnode = new crootnode ( this , databasemanager ) ; m_treemodel . setroot ( m_rootnode ) ; setcellrenderer ( new iconnoderenderer ( ) ) ; m_popup . add ( cactionproxy . proxy ( new cadddatabaseaction ( this ) ) ) ; }	creates a new project tree component .
public boolean isobject ( ) { return typestring . startswith ( object ) ; }	determine if the expression is an object . ( a thing , not a person ).
private float interpolate ( ) { long currtime = system . currenttimemillis ( ) ; float elapsed = ( currtime - starttime ) / zoom_time ; elapsed = math . min ( _num , elapsed ) ; return interpolator . getinterpolation ( elapsed ) ; }	use interpolator to get t.
private void autorequestmods ( ) { if ( ! c . autorequestmodsenabled ( ) ) { return ; } set < string > joinedchannels = c . getjoinedchannels ( ) ; for ( string channel : joinedchannels ) { if ( ! modsalreadyrequested . contains ( channel ) ) { logger . info ( _str + channel ) ; modsalreadyrequested . add ( channel ) ; requestmodssilent ( channel ) ; return ; } } }	if enabled in the settings , requests / mods for one currently joined channel ( and only one ) , ignoring the ones it was already requested for .
@ override public boolean contains ( object value ) { final iterator < comparable > iter = new stepiterator ( this , _num ) ; if ( value == null ) { return _bool ; } while ( iter . hasnext ( ) ) { if ( defaulttypetransformation . compareequal ( value , iter . next ( ) ) ) return _bool ; } return _bool ; }	iterates over all values and returns true if one value matches .
public synchronized void renamefile ( jdbcsequentialfile file , string newfilename ) throws sqlexception { try { connection . setautocommit ( _bool ) ; renamefile . setstring ( _num , newfilename ) ; renamefile . setint ( _num , file . getid ( ) ) ; renamefile . executeupdate ( ) ; connection . commit ( ) ; } catch ( sqlexception e ) { connection . rollback ( ) ; throw e ; } }	updates the filename field to the new value .
public static void handleerrorviolations ( formatter formatter , long numerrors ) { exitcode exitcode = formatter . getexitstatus ( numerrors ) ; if ( exitcode != exitcode . success ) { system . exit ( exitcode . ordinal ( ) ) ; } }	non - zero exit status when any violation messages have severity . error , controlled by - - max - severity.
public void remove ( final sensor sensor ) { set < sensor > oldselection = new hashset < sensor > ( selection ) ; boolean rv = selection . remove ( sensor ) ; if ( rv ) { fireselectionchanged ( oldselection , selection ) ; } }	remove the specified sensor from this sensor selection model .
protected void printway ( mapway way , defaultentityviewinfo pinfo , boolean asarea ) { list < mapnode > nodes = getwaynodes ( way ) ; if ( nodes != null ) { boolean asoneway = _bool ; nameinfo textinfo = null ; if ( scale >= pinfo . minnamescale * displayfactor ) { asoneway = way . isoneway ( ) ; if ( way . getname ( ) != null && pinfo . namecolor != null ) { textinfo = new nameinfo ( way . getname ( ) , pinfo . namecolor , pinfo . printorder ) ; } } printline ( imagebdr , nodes , pinfo , asarea , asoneway , textinfo ) ; } }	prints a way entity .
@ override public string tostring ( ) { stringbuffer result = new stringbuffer ( ) ; for ( int i = _num ; i < data . length ; i ++ ) { result . append ( ( i == _num ? _str : _str ) + data [ i ] ) ; } return result . tostring ( ) ; }	returns a string representation of the data row .
public element fullpath ( managedobjectreference obj ) throws invalidpropertyfaultmsg , runtimefaultfaultmsg , finderexception { list < objectcontent > set = ancestryset ( obj ) ; map < moref , element > childtoparent = new hashmap < > ( ) ; for ( objectcontent cont : set ) { moref key = new moref ( cont . getobj ( ) ) ; managedobjectreference parentref = getparent ( cont ) ; element parent ; if ( parentref != null ) { parent = element . make ( parentref , getname ( cont ) ) ; } else { parent = element . make ( cont . getobj ( ) , getname ( cont ) ) ; } childtoparent . put ( key , parent ) ; } moref next = new moref ( obj ) ; list < string > path = new arraylist < > ( ) ; while ( _bool ) { element parent = childtoparent . get ( next ) ; path . add ( parent . path ) ; if ( next . equals ( new moref ( parent . object ) ) ) { break ; } next = new moref ( parent . object ) ; } collections . reverse ( path ) ; stringbuilder sb = new stringbuilder ( ) ; for ( string s : path ) { sb . append ( _str ) ; sb . append ( s ) ; } return element . make ( obj , sb . tostring ( ) ) ; }	walks up the tree until a root object is found .
private boolean hasnextproxy ( ) { return nextproxyindex < proxies . size ( ) ; }	returns true if there ' s another proxy to try .
private boolean noobjectwasclickedon ( ) { boolean pickednodenull = ( pickednode == null ) ; boolean camerapicked = ( pickednode instanceof pcamera ) ; return ( pickednodenull || camerapicked ) ; }	encapsulate logic for determining the case where no object ( neuron node , synpase node , etc ) was clicked on at the beginning of this drag sequence .
@ override public int hashcode ( ) { throw new unsupportedoperationexception ( _str ) ; }	this operation is not supported because sets are mutable .
public builder measurementmappings ( map < string , string > measurementmappings ) { map < string , pattern > mappingsbypattern = new hashmap < string , pattern > ( ) ; for ( map . entry < string , string > entry : measurementmappings . entryset ( ) ) { try { final pattern pattern = pattern . compile ( entry . getvalue ( ) ) ; mappingsbypattern . put ( entry . getkey ( ) , pattern ) ; } catch ( patternsyntaxexception e ) { throw new runtimeexception ( _str + entry . getvalue ( ) , e ) ; } } this . measurementmappings = mappingsbypattern ; return this ; }	map measurement to a defined measurement name , where the key is the measurement name and the value is the reqex the measurement should be mapped by .
public static void extract ( file zipfile , file destdir ) throws ioexception { zipfile zf = new zipfile ( zipfile ) ; try { extract ( zf , destdir ) ; } finally { zf . close ( ) ; } }	extract the contents of a zipfile to a directory .
public config ( string file ) { this ( new file ( config_dir , file . contains ( _str ) ? file : file . concat ( _str ) ) ) ; }	creates a new config within the config directory , using the filename provided .
public gotolinedialog ( jtextcomponent text ) { super ( actionutils . getframefor ( text ) , _bool ) ; initcomponents ( ) ; this . text = text ; setlocationrelativeto ( text . getrootpane ( ) ) ; }	creates new form gotolinedialog.
private void sendrequestteardown ( ) throws ioexception { string request = _str + mparameters . host + _str + mparameters . port + mparameters . path + _str + addheaders ( ) ; log . i ( tag , request . substring ( _num , request . indexof ( _str ) ) ) ; moutputstream . write ( request . getbytes ( _str ) ) ; moutputstream . flush ( ) ; }	forges and sends the teardown request.
public boolean parsemoredata ( final encodedimage encodedimage ) { if ( mparserstate == not_a_jpeg ) { return _bool ; } final int databuffersize = encodedimage . getsize ( ) ; if ( databuffersize <= mbytesparsed ) { return _bool ; } final inputstream buffereddatastream = new pooledbytearraybufferedinputstream ( encodedimage . getinputstream ( ) , mbytearraypool . get ( buffer_size ) , mbytearraypool ) ; try { streamutil . skip ( buffereddatastream , mbytesparsed ) ; return doparsemoredata ( buffereddatastream ) ; } catch ( ioexception ioe ) { throwables . propagate ( ioe ) ; return _bool ; } finally { closeables . closequietly ( buffereddatastream ) ; } }	if this is the first time calling this method , the buffer will be checked to make sure it starts with soi marker ( 0xffd8 ).
public void testsimpleear ( ) throws exception { final url url = new url ( _str + system . getproperty ( _str ) + _str ) ; final string expected = _str ; pingutils . assertpingtrue ( url . getpath ( ) + _str , expected , url , logger ) ; }	test deploying a simple ear .
public int length ( ) { return this . filledlength ; }	gets the current filled and readable length of the array .
@ override public boolean equals ( object o ) { if ( o instanceof prefix ) { return value . equals ( ( ( prefix ) o ) . value ) ; } return _bool ; }	equals method to be consistent with comparable.
private void notifywifistate ( ) { synchronized ( mwifimonitor ) { log . v ( log_tag , _str ) ; mwifimonitor . notify ( ) ; } }	send a notification via the mwifimonitor when the wifi state changes .
private boolean arraykeyvalueexists ( string key , string value ) { if ( visitedpost . containskey ( key ) ) { for ( string s : visitedpost . get ( key ) ) { if ( s . equals ( value ) ) { return _bool ; } } } return _bool ; }	checks whether the value exists in an arraylist of certain key .
public void removediagramchangelistener ( mxdiagramchangelistener listener ) { if ( diagramchangelisteners != null ) { diagramchangelisteners . remove ( listener ) ; } }	removes the given listener from the list of diagram change listeners .
public static connectivitygrid connectivitygridfactory ( int key , double maxrange ) { if ( gridobjects . containskey ( ( integer ) key ) ) { return ( connectivitygrid ) gridobjects . get ( ( integer ) key ) ; } else { connectivitygrid newgrid = new connectivitygrid ( ( int ) math . ceil ( maxrange * cellsizemultiplier ) ) ; gridobjects . put ( ( integer ) key , newgrid ) ; return newgrid ; } }	returns a connectivity grid object based on a hash value.
public static string stripleadingdollar ( string str ) { return ( str . charat ( _num ) == _str ) ? str . substring ( _num ) : str ; }	removes any leading $ from the given string .
@ afterclass public static void clearhostcontext ( ) throws exception { system . clearproperty ( _str ) ; }	clears the " hostcontext " system property.
public pnormnormalization ( double p ) { if ( p <= _num || double . isnan ( p ) ) throw new illegalargumentexception ( _str + p ) ; this . p = p ; }	creates a new p norm.
@ override public void start ( stage stage ) throws exception { categorydataset dataset = createdataset ( ) ; jfreechart chart = createchart ( dataset ) ; chartviewer viewer = new chartviewer ( chart ) ; viewer . addchartmouselistener ( this ) ; stage . setscene ( new scene ( viewer ) ) ; stage . settitle ( _str ) ; stage . setwidth ( _num ) ; stage . setheight ( _num ) ; stage . show ( ) ; }	adds a chart viewer to the stage and displays it .
@ override public void acceptdatapoint ( chartevent e ) { if ( e . getreset ( ) ) { m_xcount = _num ; m_max = _num ; m_min = _num ; } if ( m_outputframe != null ) { boolean refresh = _bool ; if ( e . getlegendtext ( ) != null & e . getlegendtext ( ) != m_legendtext ) { m_legendtext = e . getlegendtext ( ) ; refresh = _bool ; } if ( e . getmin ( ) != m_min || e . getmax ( ) != m_max ) { m_oldmax = m_max ; m_oldmin = m_min ; m_max = e . getmax ( ) ; m_min = e . getmin ( ) ; refresh = _bool ; m_yscaleupdate = _bool ; } if ( refresh ) { m_legendpanel . repaint ( ) ; m_scalepanel . repaint ( ) ; } acceptdatapoint ( e . getdatapoint ( ) ) ; } m_xcount ++ ; }	accept a data point ( encapsulated in a chart event ) to plot.
public void sub ( namedrangeset other ) { list < namedrange > newranges = new arraylist < namedrange > ( ) ; outer_loop : for ( namedrange range : ranges ) { namedrange thisrange = new namedrange ( range . start , range . end , range . name ) ; for ( namedrange otherrange : other . ranges ) { if ( otherrange . start <= thisrange . start && otherrange . end >= thisrange . end ) { continue outer_loop ; } if ( otherrange . end < thisrange . start || otherrange . start > thisrange . end ) { } else if ( otherrange . start <= thisrange . start ) { thisrange . start = otherrange . end + _num ; } else if ( otherrange . end >= thisrange . end ) { thisrange . end = otherrange . start - _num ; } else { newranges . add ( new namedrange ( thisrange . start , otherrange . start - _num , thisrange . name ) ) ; thisrange . start = otherrange . end + _num ; } } newranges . add ( thisrange ) ; } ranges = newranges ; }	assumptions : ranges are disjoint , non - contiguous , and ordered.
public static tailer create ( file file , tailerlistener listener , long delaymillis , boolean end , int bufsize ) { tailer tailer = new tailer ( file , listener , delaymillis , end , bufsize ) ; thread thread = new thread ( tailer ) ; thread . setdaemon ( _bool ) ; thread . start ( ) ; return tailer ; }	creates and starts a tailer for the given file .
public static boolean ismacos ( ) { return osname . indexof ( _str ) > - _num ; }	is operating system mac os ?.
public int size ( ) { return values . size ( ) ; }	returns the number of items in the collection .
public dviewasn1dump ( jdialog parent , x509crl crl ) throws asn1exception , ioexception { super ( res . getstring ( _str ) ) ; this . crl = crl ; initcomponents ( ) ; }	creates new dviewasn1dump dialog where the parent is a dialog .
public static string righttrim ( final string value ) { validate ( value , null_string_predicate , null_string_msg_supplier ) ; return value . replaceall ( _str , _str ) ; }	remove all spaces on right .
public synchronized void putmessage ( object obj ) { fifo . addelement ( obj ) ; nummessage ++ ; notifyall ( ) ; }	add a message in the buffer.
public void dispose ( ) { if ( isdisposed ( ) ) { return ; } setdisposed ( _bool ) ; if ( ! menu ) { super . dispose ( ) ; } }	closes the current form and returns to the previous form , releasing the edt in the process.
public double signed_distance ( plapointfloat p_point ) { double dx = point_b . v_x - point_a . v_x ; double dy = point_b . v_y - point_a . v_y ; double det = dy * ( p_point . v_x - point_a . v_x ) - dx * ( p_point . v_y - point_a . v_y ) ; double length = math . sqrt ( dx * dx + dy * dy ) ; return det / length ; }	returns the signed distance of this line from p_point.
public static void expandreal ( string numberstring , wordrelation wordrelation , item tokenitem ) { int stringlength = numberstring . length ( ) ; int position ; if ( numberstring . charat ( _num ) == _str ) { wordrelation . addword ( tokenitem , _str ) ; expandreal ( numberstring . substring ( _num , stringlength ) , wordrelation , tokenitem ) ; } else if ( numberstring . charat ( _num ) == _str ) { wordrelation . addword ( tokenitem , _str ) ; expandreal ( numberstring . substring ( _num , stringlength ) , wordrelation , tokenitem ) ; } else if ( ( position = numberstring . indexof ( _str ) ) != - _num || ( position = numberstring . indexof ( _str ) ) != - _num ) { expandreal ( numberstring . substring ( _num , position ) , wordrelation , tokenitem ) ; wordrelation . addword ( tokenitem , _str ) ; expandreal ( numberstring . substring ( position + _num ) , wordrelation , tokenitem ) ; } else if ( ( position = numberstring . indexof ( _str ) ) != - _num ) { string beforedot = numberstring . substring ( _num , position ) ; if ( beforedot . length ( ) > _num ) { expandreal ( beforedot , wordrelation , tokenitem ) ; } wordrelation . addword ( tokenitem , _str ) ; string afterdot = numberstring . substring ( position + _num ) ; if ( afterdot . length ( ) > _num ) { expanddigits ( afterdot , wordrelation , tokenitem ) ; } } else { expandnumber ( numberstring , wordrelation , tokenitem ) ; } }	expands the given number string as a real number .
public static double [ ] ones ( int l ) { double m [ ] = new double [ l ] ; arrays . fill ( m , _num ) ; return m ; }	ones - return a vector full of 1s .
private permissionrequest submit ( ) { int showrationale = _num ; arraylist < string > requests = new arraylist < > ( ) ; for ( final string permission : mpermissions ) { if ( mactivity . checkselfpermission ( permission ) != packagemanager . permission_granted ) { requests . add ( permission ) ; if ( activitycompat . shouldshowrequestpermissionrationale ( mactivity , permission ) ) { showrationale ++ ; } } } mrequestcode = mrequestid . addandget ( _num ) ; if ( requests . isempty ( ) ) { if ( mcallback != null ) { mcallback . onpermissionsgranted ( ) ; } } else { if ( showrationale == _num ) { activitycompat . requestpermissions ( mactivity , mpermissions , mrequestcode ) ; } else { showrationale ( ) ; } } return this ; }	submits a requests for a set of permissions for an activity .
public void testsettinganulldeployableproperty ( ) { deployable deployableelement = new deployable ( ) ; war war = new war ( _str ) ; map < string , string > properties = new hashmap < string , string > ( ) ; properties . put ( _str , null ) ; deployableelement . setproperties ( properties ) ; deployableelement . setpropertiesondeployable ( war , createdefaultproject ( _str , null ) ) ; assertequals ( _str , war . getcontext ( ) ) ; }	setting a null property is the way maven2 operates when the user specifies an empty property.
private navilogger ( ) { }	you are not supposed to instantiate this class .
public static deletesubcommandhandler create ( subcommandargumentparser parser , managedobjectpath < ? , ? > p , setrelationdefinition < ? , ? > r ) throws argumentexception { return new deletesubcommandhandler ( parser , p , r , p . child ( r ) ) ; }	creates a new delete - xxx sub - command for a set relation .
protected void removecycles ( ) { int visited [ ] = new int [ m_nodes . size ( ) ] ; for ( int i = _num ; i < graphmatrix . length ; i ++ ) { if ( visited [ i ] == _num ) { removecycles2 ( i , visited ) ; visited [ i ] = _num ; } } }	the following two methods remove cycles from the graph .
public string tostring ( objectmatrix3d matrix ) { stringbuffer buf = new stringbuffer ( ) ; boolean oldprintshape = this . printshape ; this . printshape = _bool ; for ( int slice = _num ; slice < matrix . slices ( ) ; slice ++ ) { if ( slice != _num ) buf . append ( sliceseparator ) ; buf . append ( tostring ( matrix . viewslice ( slice ) ) ) ; } this . printshape = oldprintshape ; if ( printshape ) buf . insert ( _num , shape ( matrix ) + _str ) ; return buf . tostring ( ) ; }	returns a string representation of the given matrix .
int findancestor ( xpathcontext xctxt , xpath frommatchpattern , xpath countmatchpattern , int context , elemnumber namespacecontext ) throws javax . xml . transform . transformerexception { dtm dtm = xctxt . getdtm ( context ) ; while ( dtm . null != context ) { if ( null != frommatchpattern ) { if ( frommatchpattern . getmatchscore ( xctxt , context ) != xpath . match_score_none ) { break ; } } if ( null != countmatchpattern ) { if ( countmatchpattern . getmatchscore ( xctxt , context ) != xpath . match_score_none ) { break ; } } context = dtm . getparent ( context ) ; } return context ; }	given a ' from ' pattern ( ala xsl : number ) , a match pattern and a context , find the first ancestor that matches the pattern ( including the context handed in ) .
public synchronized void kill ( ) { running = _bool ; closed = _bool ; try { stdin . close ( ) ; } catch ( ioexception e ) { } try { process . destroy ( ) ; } catch ( exception e ) { } }	try to clean up as much as possible from a shell that ' s gotten itself wedged.
public final bytebuffer encode ( charbuffer in ) throws charactercodingexception { int length = ( int ) ( in . remaining ( ) * averagebytesperchar ) ; bytebuffer out = bytebuffer . allocate ( length ) ; reset ( ) ; while ( state != flushed ) { coderresult result = encode ( in , out , _bool ) ; if ( result == coderresult . overflow ) { out = allocatemore ( out ) ; continue ; } else { checkcoderresult ( result ) ; } result = flush ( out ) ; if ( result == coderresult . overflow ) { out = allocatemore ( out ) ; } else { checkcoderresult ( result ) ; } } out . flip ( ) ; return out ; }	this is a facade method for the encoding operation.
public static metrics create ( map < string , string > dimensionmap ) { map < string , string > map = maps . newtreemap ( ) ; map . putall ( dimensionmap ) ; return new metrics ( collections . unmodifiablemap ( map ) ) ; }	creates a metrics object with the dimensions map immutable.
protected class < ? > resolveclass ( objectstreamclass classdesc ) throws ioexception , classnotfoundexception { object annotation = readlocation ( ) ; string classname = classdesc . getname ( ) ; classloader defaultloader = skipdefaultresolveclass ? null : latestuserdefinedloader ( ) ; string codebase = null ; if ( ! usecodebaseonly && annotation instanceof string ) { codebase = ( string ) annotation ; } try { return rmiclassloader . loadclass ( codebase , classname , defaultloader ) ; } catch ( accesscontrolexception e ) { return checksunclass ( classname , e ) ; } catch ( classnotfoundexception e ) { try { if ( character . islowercase ( classname . charat ( _num ) ) && classname . indexof ( _str ) == - _num ) { return super . resolveclass ( classdesc ) ; } } catch ( classnotfoundexception e2 ) { } throw e ; } }	resolveclass is extended to acquire ( if present ) the location from which to load the specified class.
public boolean contains ( final creaturerespawnpoint point ) { if ( point == null ) { return _bool ; } final irpzone entityzone = point . getzone ( ) ; return zone . equals ( entityzone ) && shape . contains ( point . getx ( ) , point . gety ( ) ) ; }	checks whether a respawn point is within this area .
public void add ( int i , byte [ ] buffer , int offset , int length ) { if ( _length + length > _capacity ) ensurecapacity ( _length + length ) ; system . arraycopy ( _buffer , i , _buffer , i + length , _length - i ) ; system . arraycopy ( buffer , offset , _buffer , i , length ) ; _length += length ; }	inserts a byte array.
public boolean isuseantialias ( ) { return useantialias ; }	checks if is use anti alias .
private void loadlevelfile ( string tablename , string columnname , string cubename , string schemaname ) { string baselocation = carbonutil . getcarbonstorepath ( schemaname , cubename ) ; baselocation = baselocation + file . separator + schemaname + file . separator + cubename ; if ( loadfolderlist . size ( ) == _num ) { checkandupdatefolderlist ( baselocation ) ; } try { file [ ] filesarray = null ; for ( file loadfoler : loadfolderlist ) { filesarray = getfilesarray ( loadfoler , tablename + _str + columnname ) ; if ( null != filesarray ) { for ( int i = _num ; i < filesarray . length ; i ++ ) { readlevelfileandupdatecache ( filesarray [ i ] , tablename + _str + columnname ) ; } } } } catch ( ioexception e ) { logger . error ( _str ) ; } }	below method will be used to fill the level cache.
protected void dovalidatezerolongfile ( string path , string filename , long size , boolean checkcontents ) { file infile = new file ( path , filename ) ; datainputstream instream = null ; log . i ( log_tag , _str + filename + _str + path ) ; try { instream = new datainputstream ( new fileinputstream ( infile ) ) ; if ( checkcontents ) { for ( long i = _num ; i < size ; ++ i ) { if ( instream . readlong ( ) != _num ) { fail ( _str + filename ) ; } } } if ( instream != null ) { instream . close ( ) ; } log . i ( log_tag , _str + filename + _str + size + _str ) ; } catch ( ioexception e ) { fail ( _str + infile + _str + e . tostring ( ) ) ; } }	helper to validate the contents of a " long " file on our obbs the format of the files are sequential 0 ' s of type long.
protected void write ( dataoutputstream stream ) throws exception { iterator < nbt_tag > iter = elements . iterator ( ) ; while ( iter . hasnext ( ) ) { nbt_tag ret = iter . next ( ) ; ret . save ( stream ) ; } tag_end end = new tag_end ( _str ) ; end . save ( stream ) ; }	saving method . ( see nbt_tag ).
public string applymask ( string mask , string value ) { return ( string ) getmaskorgetcursorindex ( mask , value , _num , _bool ) ; }	makes a masked value of a value.
private void computeduration ( ) { duration = system . currenttimemillis ( ) - start ; total_duration += duration ; }	computes the duration by subtracting start to the current time in milliseconds.
public int handlenitfheader ( binaryfile binfile ) { try { byte [ ] nitfarray = binfile . readbytes ( _num , _bool ) ; string nitf = new string ( nitfarray ) ; binfile . seek ( rpf_date_location ) ; nitfarray = binfile . readbytes ( _num , _bool ) ; nitf = new string ( nitfarray ) ; if ( nitf . equalsignorecase ( _str ) || nitf . equalsignorecase ( _str ) ) return _num ; binfile . seek ( rpf_date_location + toc_nitf_header_length ) ; nitfarray = binfile . readbytes ( _num , _bool ) ; nitf = new string ( nitfarray ) ; if ( nitf . equalsignorecase ( _str ) || nitf . equalsignorecase ( _str ) ) return toc_nitf_header_length ; binfile . seek ( rpf_date_location + frame_short_nitf_header_length ) ; nitfarray = binfile . readbytes ( _num , _bool ) ; nitf = new string ( nitfarray ) ; if ( nitf . equalsignorecase ( _str ) || nitf . equalsignorecase ( _str ) ) return frame_short_nitf_header_length ; binfile . seek ( rpf_date_location + frame_long_nitf_header_length ) ; nitfarray = binfile . readbytes ( _num , _bool ) ; nitf = new string ( nitfarray ) ; if ( nitf . equalsignorecase ( _str ) || nitf . equalsignorecase ( _str ) ) return frame_long_nitf_header_length ; } catch ( ioexception e ) { debug . error ( _str + e ) ; return - _num ; } catch ( formatexception f ) { debug . error ( _str + f ) ; return - _num ; } return - _num ; }	checks to see if the file is in nitf or not , and then puts the file pointer in the right place to start reading the header for the file.
public bufferedimage takescreenshot ( ) { debug . setdebuglevel ( _num ) ; file scrfile = driver . getscreenshotas ( outputtype . file ) ; bufferedimage bufferedimage = null ; try { bufferedimage = imageio . read ( scrfile ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return bufferedimage ; }	convenience method that takes a screenshot of the device and returns a bufferedimage for further processing .
