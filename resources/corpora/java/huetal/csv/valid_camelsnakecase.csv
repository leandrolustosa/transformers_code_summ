code	desc
public int hash code ( ) { return value . hash code ( ) ; }	this returns the hash code for the key.
public void on start ( ) { }	fired when the request is started , override to handle in your own code.
@ override protected void property change ( property change event evt ) { if ( sea glass look and feel . should update style ( evt ) ) { update style ( ( j ) evt . get source ( ) ) ; } super . property change ( evt ) ; }	this method gets called when a bound property is changed on the associated jtextcomponent.
@ not null public psi query filter ( @ not null final class < ? extends psi named element > clazz , @ not null final string name ) { final set < psi element > result = new hash set < psi element > ( arrays . as list ( my psi elements ) ) ; for ( final psi element element : my psi elements ) { final psi named element named element = py util . as ( element , clazz ) ; if ( ( named element == null ) || ( ! name . equals ( named element . get name ( ) ) ) ) { result . remove ( element ) ; } } return new psi query ( result . to array ( new psi element [ result . size ( ) ] ) ) ; }	filter elements by class and name.
protected void write qualified name ( string ns alias , string name ) throws io { if ( ns alias != null && ns alias . length ( ) > num ) { writer . write ( ns alias ) ; writer . write ( str ) ; } writer . write ( name ) ; }	writes a namespace qualified element or attribute name .
public text editor delete all ( string pattern ) { return replace all ( pattern , str ) ; }	remove all occurrences of the given regex pattern , replacing them with the empty string .
public synchronized gcm helper add registration callback ( @ non null context context , @ non null gcm registration listener registration listener , boolean sticky ) { if ( null == registration callbacks ) { registration callbacks = new concurrent linked queue < > ( ) ; } registration callbacks . add ( registration listener ) ; if ( sticky && ! text utils . is empty ( this . push token ) ) { registration listener . on token available ( context , push token , bool ) ; } return this ; }	add a gcm registration listener . this does not replace the existing listeners but adds to the list of listeners.
@ override public void accept training set ( training set event e ) { instances training set = e . get training set ( ) ; data set event dse = new data set event ( this , training set ) ; accept data set ( dse ) ; }	accept a training set.
< t > list < t > on find ( class < t > model class , string [ ] columns , string [ ] conditions , string order by , string limit , boolean is eager ) { base utility . check conditions correct ( conditions ) ; list < t > data list = query ( model class , columns , get where clause ( conditions ) , get where args ( conditions ) , null , null , order by , limit , get foreign key associations ( model class . get name ( ) , is eager ) ) ; return data list ; }	the open interface for other classes in crud package to query multiple records by parameters .
public static byte [ ] calendar to raw bytes ( calendar timestamp , boolean honor device time offset ) { if ( honor device time offset ) { int offset in hours = mi band coordinator . get device time offset hours ( ) ; if ( offset in hours != num ) { timestamp . add ( calendar . hour of day , offset in hours ) ; } } byte [ ] year = from uint16 ( timestamp . get ( calendar . year ) ) ; return new byte [ ] { year [ num ] , year [ num ] , from uint8 ( timestamp . get ( calendar . month ) + num ) , from uint8 ( timestamp . get ( calendar . date ) ) , from uint8 ( timestamp . get ( calendar . hour of day ) ) , from uint8 ( timestamp . get ( calendar . minute ) ) , from uint8 ( timestamp . get ( calendar . second ) ) , day of week to raw bytes ( timestamp ) , num } ; }	converts a timestamp to the byte sequence to be sent to the current time characteristic.
protected void init bp ( int c b id , boolean for invoice ) { log . config ( str + c b id ) ; key name pair pp = new key name pair ( num , str ) ; order field . remove action listener ( this ) ; order field . remove all items ( ) ; order field . add item ( pp ) ; array list < key name pair > list = load order data ( c b id , for invoice , same warehouse cb . is selected ( ) ) ; for ( key name pair knp : list ) order field . add item ( knp ) ; order field . set selected index ( num ) ; order field . add action listener ( this ) ; init bp ( c b id ) ; }	load pbartner dependent order / invoice / shipment field .
public modpack initialization panel ( wizard controller controller , map wizard data , vector < string > versions , string sel version ) { init components ( ) ; this . controller = controller ; this . wizard data = wizard data ; wizard data . put ( key game version , versions ) ; wizard data . put ( str , sel version ) ; wizard data . put ( key including launcher , bool ) ; configure combo contents ( ) ; check problem ( ) ; }	creates new form modpackinitializationpanel.
public synchronized void remove ( int index ) { super . remove ( index ) ; double removed value = m value . remove ( index ) ; if ( removed value == m min value || removed value == m max value ) { init range ( ) ; } }	removes an existing value from the series .
private boolean coord is calendar cell ( float y ) { return y > cell height ; }	y is bigger than the head of the calendar , meaning that the coordination may represent a day of the calendar.
private int attribute map ( string name ) { integer num = map . get ( name ) ; if ( num == null ) { return num ; } return num . int value ( ) ; }	returns the integer attribute number for the passed attribute name .
public string list ( ) throws io , tomcat manager exception { return invoke ( str , null , null ) ; }	list currently deployed webapps .
public attribute filler ( attributes impl attributes , po po to auto fill ) { attributes . clear ( ) ; atts = attributes ; po = po to auto fill ; }	will clear attributes ! ! !.
@ request mapping ( value = { str , str } , method = request method . put ) @ response body public rest wrapper insert ( @ model attribute ( str ) @ valid file file , binding result binding result , principal principal ) { rest wrapper rest wrapper = null ; if ( binding result . has errors ( ) ) { binding result error binding result error = new binding result error ( ) ; return binding result error . error message ( binding result ) ; } try { file . set creation ts ( date converter . string to date ( file . get table creation ts ( ) ) ) ; file dao . insert ( file ) ; rest wrapper = new rest wrapper ( file , rest wrapper . ok ) ; logger . info ( str + file . get batch id ( ) + str + principal . get name ( ) + file ) ; } catch ( metadata exception e ) { logger . error ( e ) ; rest wrapper = new rest wrapper ( e . get message ( ) , rest wrapper . error ) ; } return rest wrapper ; }	this method calls proc insertfile and adds a record of file.
private void enable updates ( ) { if ( lmgr != null ) { try { lmgr . add gps status listener ( this ) ; lmgr . request location updates ( location manager . gps provider , gps logging interval , num , this ) ; } catch ( security exception e ) { log . e ( tag , str ) ; } } }	request gps update notification.
private void add integer ( ) { int old pos = pos - num ; string literal = scan integer ( ) ; final string substring ; final int radix ; if ( literal . starts with ( str ) || literal . starts with ( str ) ) { radix = num ; substring = literal . substring ( num ) ; } else if ( literal . starts with ( str ) && literal . length ( ) > num ) { radix = num ; substring = literal . substring ( num ) ; } else { radix = num ; substring = literal ; } int value = num ; try { value = integer . parse int ( substring , radix ) ; } catch ( number format exception e ) { error ( str + radix + str + literal ) ; } add token ( token kind . int , old pos , pos , value ) ; }	scans an addinteger literal.
public void remove mouse listener ( global mouse listener listener ) { listeners . remove ( listener ) ; }	removes a global mouse listener.
public xml ( double version , boolean standalone ) { prolog = new vector < object > ( num ) ; string buffer version str = new string buffer ( ) ; version str . append ( str ) ; version str . append ( version ) ; version str . append ( str ) ; if ( standalone ) version str . append ( str ) ; else version str . append ( str ) ; this . version decl = version str . to string ( ) ; }	this sets the document up . since an xml document can be pretty much anything , all this does is create the xml instruction with the version specified , and identifies the document as standalone if set.
public object name create distribution locator ( string host , int port , string working directory , string product directory , string remote command ) throws malformed object name exception { try { distribution locator jmx impl locator = ( distribution locator jmx impl ) add distribution locator ( ) ; distribution locator config config = locator . get config ( ) ; config . set host ( host ) ; config . set port ( port ) ; config . set working directory ( working directory ) ; config . set product directory ( product directory ) ; config . set remote command ( remote command ) ; return new object name ( locator . get m ( ) ) ; } catch ( runtime exception e ) { logger . warn ( e . get message ( ) , e ) ; throw e ; } catch ( virtual machine error err ) { system failure . initiate failure ( err ) ; throw err ; } catch ( error e ) { system failure . check failure ( ) ; logger . error ( e . get message ( ) , e ) ; throw e ; } }	creates a new distributionlocator for this system and registers an mbean for managing it.
void apply center panel ( grass marlin ui ) { if ( tree view component != null ) { center panel component . add ( tree view component , split pane . position . center ) ; } center panel component . add ( graph component , split pane . position . right ) ; center panel component . add ( log component , split pane . position . left bottom ) ; border b = border factory . create matte border ( num , num , num , num , color . gray ) ; border b2 = border factory . create matte border ( num , num , num , num , color . gray ) ; tree view component . set border ( b2 ) ; graph component . set border ( b ) ; log component . set border ( b2 ) ; center panel component . set initial size ( x , y ) ; dimension d = new dimension ( num , num ) ; ui . add ( new filler ( d , d , d ) , border layout . west ) ; ui . add ( new filler ( d , d , d ) , border layout . east ) ; ui . add ( center panel component , border layout . center ) ; }	positions the center two components into something that extends a jsplitpane.
private boolean is abstract ( string source ) { int nonterminal count = num ; for ( string t : source . split ( str ) ) { if ( ! t . matches ( nt regex ) ) return bool ; nonterminal count ++ ; } return nonterminal count != num ; }	determines whether a rule is an abstract rule.
public static string ur ( string path ) { if ( path . starts with ( file util . preferences ) ) { return path . replace first ( file util . preferences , str ) ; } else if ( path . starts with ( file util . program ) ) { return path . replace first ( file util . program , str ) ; } else { return null ; } }	get the public uri for a portable path.
public int hash code ( ) { return float . float to int bits ( value ) ; }	returns a hash code for this floatconstant object .
public static void log ( throwable error , string message , object ... args ) { if ( logging enabled ) { log . d ( tag , args . length == num ? message : string . format ( message , args ) , error ) ; } }	send a log message if logging is enabled .
public void add extension namespace ( string uri , extension handler ext ns ) { m extension function namespaces . put ( uri , ext ns ) ; }	register an extension namespace handler.
private void generate type parameter infos ( binary member parent , char [ ] signature , hash map new elements , array list type parameter handles ) { if ( signature == null ) return ; char [ ] [ ] type parameter signatures = signature . get type parameters ( signature ) ; for ( int i = num , type parameter count = type parameter signatures . length ; i < type parameter count ; i ++ ) { char [ ] type parameter signature = type parameter signatures [ i ] ; char [ ] type parameter name = signature . get type variable ( type parameter signature ) ; char operation . replace ( type parameter signature , str , str ) ; char [ ] [ ] type parameter bound signatures = signature . get type parameter bounds ( type parameter signature ) ; int bound length = type parameter bound signatures . length ; char [ ] [ ] type parameter bounds = new char [ bound length ] [ ] ; for ( int j = num ; j < bound length ; j ++ ) { type parameter bounds [ j ] = signature . to char array ( type parameter bound signatures [ j ] ) ; } type parameter type parameter = new type parameter ( parent , parent . manager , new string ( type parameter name ) ) ; type parameter element info info = new type parameter element info ( ) ; info . bounds = type parameter bounds ; info . bounds signatures = type parameter bound signatures ; type parameter handles . add ( type parameter ) ; while ( new elements . contains key ( type parameter ) ) type parameter . occurrence count ++ ; new elements . put ( type parameter , info ) ; } }	creates the handles and infos for the type parameter of the given binary member.
public routing info ( object o ) { this . text = o . to string ( ) ; }	creates a routing info based on any object.
public static cert chain key pair generate signed ( string fqdn , x509 certificate issuer certificate , private key issuer private key ) { try { return generate certificate and sign ( fqdn , issuer certificate , issuer private key , get server extensions ( issuer certificate ) ) ; } catch ( certificate exception | operator creation exception | no such algorithm exception | io e ) { throw new runtime exception ( string . format ( str , e . get message ( ) ) , e ) ; } }	generates a signed certificate and a private key .
public void add request ( request request ) { request set . add ( request ) ; }	adds a request object to this object .
public static double logpmf ( double x , int n , double p ) { if ( x < num || x > n ) { return double . negative infinity ; } if ( p <= num ) { return x == num ? num : double . negative infinity ; } if ( p >= num ) { return x == n ? num : double . negative infinity ; } final double q = num - p ; if ( x == num ) { if ( p < num ) { return - deviance term ( n , n * q ) - n * p ; } else { return n * math . log ( q ) ; } } if ( x == n ) { if ( p > num ) { return - deviance term ( n , n * p ) - n * q ; } else { return n * math . log ( p ) ; } } final double lc = stirling error ( n ) - stirling error ( x ) - stirling error ( n - x ) - deviance term ( x , n * p ) - deviance term ( n - x , n * q ) ; final double f = ( math util . twopi * x * ( n - x ) ) / n ; return lc - num * math . log ( f ) ; }	poisson probability mass function ( pmf ) for integer values .
private void byte2hex ( byte b , string buffer buf ) { char [ ] hex chars = { str , str , str , str , str , str , str , str , str , str , str , str , str , str , str , str } ; int high = ( ( b & num ) > > num ) ; int low = ( b & num ) ; buf . append ( hex chars [ high ] ) ; buf . append ( hex chars [ low ] ) ; }	converts a byte to hex digit and writes to the supplied buffer.
protected void check signature ( byte [ ] buf ) { if ( ! arrays . equals ( buf , png helper internal . get png id signature ( ) ) ) throw new pngj input exception ( str ) ; }	throws pngjinputexception if bad signature.
private void two way merge internal ( final reservoir longs sketch sketch in , final boolean is modifiable ) { if ( sketch in . get n ( ) <= sketch in . get k ( ) ) { two way merge internal standard ( sketch in ) ; } else if ( gadget . get n ( ) < gadget . get k ( ) ) { final reservoir longs sketch tmp sketch = gadget ; gadget = ( is modifiable ? sketch in : sketch in . copy ( ) ) ; two way merge internal standard ( tmp sketch ) ; } else if ( sketch in . get implicit sample weight ( ) < gadget . get n ( ) / ( ( double ) ( gadget . get k ( ) - num ) ) ) { two way merge internal weighted ( sketch in ) ; } else { final reservoir longs sketch tmp sketch = gadget ; gadget = ( is modifiable ? sketch in : sketch in . copy ( ) ) ; two way merge internal weighted ( tmp sketch ) ; } }	this either merges sketchin into gadget_ or gadget_ into sketchin.
final public void print ( object v ) { writer out = this . out ; if ( out == null ) return ; try { if ( v == null ) out . write ( null chars , num , null chars . length ) ; else { string s = v . to string ( ) ; out . write ( s , num , s . length ( ) ) ; } } catch ( io e ) { log . log ( level . fine , e . to string ( ) , e ) ; } }	prints the value of the object .
public void subscribe to ( final k key , final subscriber < v > subscriber , final executor subscribe on ) { completable future . run async ( null , subscribe on ) ; }	subscribe asynchronously to a pipe.
private void refresh buffer ( ) throws io { if ( output == null ) { throw new out of space exception ( ) ; } output . write ( buffer , num , position ) ; position = num ; }	internal helper that writes the current buffer to the output.
public string damage bay door ( ) { string bay type = str ; vector < bay > potential ; potential = new vector < bay > ( ) ; enumeration < transporter > iter = transports . elements ( ) ; while ( iter . has more elements ( ) ) { transporter next = iter . next element ( ) ; if ( next instanceof bay ) { bay next bay = ( bay ) next ; if ( next bay . get doors ( ) > num ) { potential . add ( next bay ) ; } } } if ( potential . size ( ) > num ) { bay chosen bay = potential . element at ( compute . random int ( potential . size ( ) ) ) ; chosen bay . destroy door ( ) ; chosen bay . reset doors ( ) ; chosen bay . set doors ( chosen bay . get doors ( ) - num ) ; bay type = chosen bay . get type ( ) ; } return bay type ; }	damages a randomly determined bay door on the entity , if one exists.
public void update enabled state ( ) { boolean b = ( get simulation thread ( ) == null ) ; boolean prep = b && controller != null && controller . is prepared ( ) ; clear button . set enabled ( b ) ; prepare button . set enabled ( b ) ; run button . set enabled ( prep ) ; if ( b ) pause button . set selected ( bool ) ; pause button . set enabled ( ! b ) ; step button . set enabled ( prep ) ; cancel button . set enabled ( ! b ) ; for ( j < object > combo : selectors . combos ) combo . set enabled ( b ) ; }	enables / disables combos and buttons .
private void prepare volume data ( ) throws exception { prepare v ( ) ; prepare rp ( ) ; }	prepares the data for volume tests .
private static int determine icon id by mime type list ( list < string > mimetypes ) { if ( mimetypes == null || mimetypes . size ( ) < num ) { return r . drawable . file ; } else { for ( string mimetype : mimetypes ) { integer icon id = mimetype to icon mapping . get ( mimetype ) ; if ( icon id != null ) { return icon id ; } } for ( string mimetype : mimetypes ) { string main mimetype part = mimetype . split ( str ) [ num ] ; integer icon id = mainmimetype to icon mapping . get ( main mimetype part ) ; if ( icon id != null ) { return icon id ; } } } return r . drawable . file ; }	determines the icon based on the mime type .
public sms mms message ( context context , long message id , long thread id , long timestamp , string message body , int unread count , int message type ) { context = context ; message id = message id ; thread id = thread id ; timestamp = timestamp ; message body = message body ; unread count = unread count ; message type = message type ; from address = sms popup utils . get mms address ( context , message id ) ; from email gateway = bool ; contact name = phone number utils . format number ( from address ) ; contact identification contact identify = sms popup utils . get person id from phone number ( context , from address ) ; if ( contact identify == null ) { contact identify = sms popup utils . get person id from email ( context , from address ) ; if ( contact identify != null ) { from email gateway = bool ; } } if ( contact identify != null ) { contact id = contact identify . contact id ; contact lookup key = contact identify . contact lookup ; contact name = contact identify . contact name ; } }	construct smsmmsmessage for getmmsdetails ( ) - fetched from the mms database table.
public void attribute as class ( ) { data sorted table model model ; if ( m == - num ) { return ; } model = ( data sorted table model ) m . get model ( ) ; if ( model . get attribute at ( m ) == null ) { return ; } set cursor ( cursor . get predefined cursor ( cursor . wait cursor ) ) ; model . attribute as class at ( m ) ; set cursor ( cursor . get predefined cursor ( cursor . default cursor ) ) ; }	sets the current attribute as class attribute , i.
public void add listener ( refresh listener listener ) { if ( listener == null ) { throw new null pointer exception ( str ) ; } refresh listeners . add ( listener ) ; }	adds a listener , to be notified when a reference is refreshed / swapped .
public final void do export ( final string track name , final file target , int verbosity ) throws io { log . i ( tag , str + target . get absolute path ( ) ) ; m db helper = new database helper ( m context . get application context ( ) ) ; final buffered writer bw = new buffered writer ( new file writer ( target ) ) ; bw . write ( xml header ) ; bw . write ( tag gpx ) ; if ( verbosity == verbosity track and waypoints || verbosity == verbosity waypoints only || verbosity == verbosity all ) { write waypoints ( bw ) ; } if ( verbosity == verbosity track and waypoints || verbosity == verbosity all ) { write trackpoints ( track name , bw ) ; } bw . flush ( ) ; if ( verbosity == verbosity all ) { write wifis ( bw ) ; bw . flush ( ) ; write cells ( bw ) ; bw . flush ( ) ; } bw . write ( tag gpx close ) ; bw . close ( ) ; m db helper . close ( ) ; log . i ( tag , str ) ; }	writes the gpx file.
public list < v > values in selection ( rich edit text editor , int span type ) { list < v > result = new array list < v > ( ) ; selection expanded selection = get expanded selection ( editor , span type ) ; if ( expanded selection != null ) { for ( span < v > span : get spans ( editor . get text ( ) , expanded selection ) ) { result . add ( span . get value ( ) ) ; } } return result ; }	returns the value of this effect in the current selection .
private boolean is gte ( double value ) { return math . abs ( value ) - math . abs ( m delta ) > - num ; }	indicates if the absolute value of the argument is greater than or equal to the delta value with accuracy to 14 digits of precision.
public static string row to string ( json ja ) { string builder sb = new string builder ( ) ; for ( int i = num ; i < ja . length ( ) ; i += num ) { if ( i > num ) { sb . append ( str ) ; } object object = ja . opt ( i ) ; if ( object != null ) { string string = object . to string ( ) ; if ( string . length ( ) > num && ( string . index of ( str ) >= num || string . index of ( str ) >= num || string . index of ( str ) >= num || string . index of ( num ) >= num || string . char at ( num ) == str ) ) { sb . append ( str ) ; int length = string . length ( ) ; for ( int j = num ; j < length ; j += num ) { char c = string . char at ( j ) ; if ( c >= str && c != str ) { sb . append ( c ) ; } } sb . append ( str ) ; } else { sb . append ( string ) ; } } } sb . append ( str ) ; return sb . to string ( ) ; }	produce a comma delimited text row from a jsonarray.
@ override public boolean contains ( object object ) { if ( object == null ) { return bool ; } for ( int i = num ; i < size ; i ++ ) { if ( object . equals ( elements [ i ] ) ) { return bool ; } } return bool ; }	answers if there is an element in this queue equals to the object .
public void close ( ) throws io { writer . close ( ) ; }	closes the xmlwriter and the underlying output writer .
public static void substitute properties ( node node , properties properties ) { node child ; node next = node . get first child ( ) ; while ( ( child = next ) != null ) { next = child . get next sibling ( ) ; if ( child . get node type ( ) == node . text node ) { child . set node value ( properties util . substitute property ( child . get node value ( ) , properties ) ) ; } else if ( child . get node type ( ) == node . element node ) { named node map attributes = child . get attributes ( ) ; for ( int i = num ; i < attributes . get length ( ) ; i ++ ) { node attribute = attributes . item ( i ) ; attribute . set node value ( properties util . substitute property ( attribute . get node value ( ) , properties ) ) ; } substitute properties ( child , properties ) ; } } }	replaces $ { property [ : default value ] } references in all attributes and text nodes of supplied node.
@ suppress warnings ( str ) public pseudo function selector ( string function name , string expression ) { super ( type . pseudo function ) ; this . pseudo function = ( pseudo function < e > ) lookup pseudo function ( function name . trim ( ) ) ; this . expression = expression ; this . parsed expression = pseudo function . parse expression ( expression ) ; }	creates pseudo function selector for given function and expression .
public static string fix query mistakes ( string q ) { q = q . replace all ( str , str ) ; q = q . replace all ( str , str ) ; return q ; }	fixing a query mistake covers most common wrong queries from the user.
public byte [ ] read bytes ( ) throws io { if ( ! parse tag ( ) ) throw new burlap protocol exception ( str ) ; string tag = sbuf . to string ( ) ; if ( tag . equals ( str ) ) { expect end tag ( str ) ; return null ; } else if ( tag . equals ( str ) ) { sbuf . set length ( num ) ; byte [ ] value = parse bytes ( ) ; expect end tag ( str ) ; return value ; } else throw expect begin tag ( str , tag ) ; }	reads a byte array from the input stream.
public synchronized utterance pend ( ) { utterance utterance = null ; while ( list . size ( ) == num ) { try { wait ( ) ; } catch ( interrupted exception ie ) { return null ; } } utterance = ( utterance ) list . remove first ( ) ; notify ( ) ; return utterance ; }	blocks until there is an utterance in the queue .
public void test long value pos ( ) { string a = str ; big decimal a number = new big decimal ( a ) ; long result = num ; assert true ( str , a number . long value ( ) == result ) ; }	long value of a positive bigdecimal.
public static evaluation result find or create ( result hierarchy hierarchy , result parent , string name , string shortname ) { array list < evaluation result > ers = result util . filter results ( hierarchy , parent , evaluation result . class ) ; evaluation result ev = null ; for ( evaluation result e : ers ) { if ( shortname . equals ( e . get short name ( ) ) ) { ev = e ; break ; } } if ( ev == null ) { ev = new evaluation result ( name , shortname ) ; hierarchy . add ( parent , ev ) ; } return ev ; }	find or create an evaluation result .
public static boolean is running java web start ( ) { boolean has jnlp = bool ; try { class . for name ( str ) ; has jnlp = bool ; } catch ( class not found exception ex ) { has jnlp = bool ; } return has jnlp ; }	are we running from a webstart instance ?.
public boolean is connected ( ) { return connected . get ( ) ; }	returns the connection status .
private void try schedule action ( runnable action ) { try { scheduler . submit ( action ) ; } catch ( rejected execution exception e ) { } }	tries to schedule a runnable on the underlying executor.
private static double score sequence ( list < lat long > pts ) { lat long prev = pts . get ( pts . size ( ) - num ) ; lat long prevprev = pts . get ( pts . size ( ) - num ) ; double prev angle = math . atan2 ( prev . lat - prevprev . lat , prev . lng - prevprev . lng ) ; double score = num ; for ( lat long pt : pts ) { double angle = math . atan2 ( pt . lat - prev . lat , pt . lng - prev . lng ) ; double diff = prev angle - angle ; if ( diff > math . pi ) diff -= math . pi * num ; else if ( diff < - math . pi ) diff += math . pi * num ; if ( diff < num ) score += num ; else score += diff ; prev = pt ; prev angle = angle ; } return score ; }	how ' good ' does this sequence of points look ? the sequence must be clockwise and have the least acute angles possible .
public void add web app debug model listener ( i listener ) { synchronized ( private instance lock ) { web app debug model listeners . add ( listener ) ; } }	add a listener for changes to the model .
public void simulate method ( soot method method , reference variable this var , reference variable return var , reference variable params [ ] ) { string sub signature = method . get sub signature ( ) ; if ( sub signature . equals ( str ) ) { java lang get class context ( method , this var , return var , params ) ; return ; } else if ( sub signature . equals ( str ) ) { java lang current class loader0 ( method , this var , return var , params ) ; return ; } else if ( sub signature . equals ( str ) ) { java lang current loaded class0 ( method , this var , return var , params ) ; return ; } else { default method ( method , this var , return var , params ) ; return ; } }	implements the abstract method simulatemethod.
public static boolean is file exists ( final string path ) { if ( text utils . is empty ( path ) ) { log . e ( file utils . class , str ) ; return bool ; } final file file to check = new file ( path ) ; return file to check . exists ( ) && ! file to check . is directory ( ) ; }	check if given path is a file and if it exists.
private list < reference > create signature references ( xml xml sig factory , list < string > reference id list ) throws no such algorithm exception , invalid algorithm parameter exception { list < reference > result = new array list < reference > ( ) ; for ( string ref id : reference id list ) { if ( ref id == null ) { continue ; } reference ref = xml sig factory . new reference ( str + ref id , xml sig factory . new digest method ( digest method . sh , null ) , collections . singleton list ( xml sig factory . new canonicalization method ( canonicalization method . exclusive , ( n ) null ) ) , null , null ) ; result . add ( ref ) ; } return collections . unmodifiable list ( result ) ; }	creates all references needed for this signature.
public boolean remove network connection ( network connection network connection ) { return network connections . remove ( network connection ) ; }	remove a networkconnection from a vm ' s networks .
@ override public enumeration < option > list options ( ) { vector < option > result = new vector < option > ( ) ; result . add element ( new option ( str + str , str , num , str ) ) ; result . add element ( new option ( str + str , str , num , str ) ) ; result . add element ( new option ( str , str , num , str ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
protected object convert array ( object value ) { return value ; }	returns the value unchanged .
public static string encode string ( string s ) { return new string ( encode ( s . get bytes ( ) ) ) ; }	encodes a string into base64 format.
grid lucene file ( grid lucene directory dir ) { this . dir = dir ; files cnt . increment and get ( ) ; }	file used as buffer , in no ramdirectory.
public void add attributes ( attributes atts ) throws sax { int n atts = atts . get length ( ) ; for ( int i = num ; i < n atts ; i ++ ) { string uri = atts . get uri ( i ) ; if ( null == uri ) uri = str ; add attribute always ( uri , atts . get local name ( i ) , atts . get q ( i ) , atts . get type ( i ) , atts . get value ( i ) , bool ) ; } }	add the given attributes to the currently collected ones.
public synchronized void add pan listener ( pan listener listener ) { m pan listeners . add ( listener ) ; }	adds a new pan listener .
public synchronized long last online ago ( ) { return ( system . current time millis ( ) - last online ) / num ; }	how long ago the stream was last online.
public double distance weighted ( pla point float p other , double p horizontal weight , double p vertical weight ) { double delta x = v x - p other . v x ; double delta y = v y - p other . v y ; delta x *= p horizontal weight ; delta y *= p vertical weight ; double result = math . sqrt ( delta x * delta x + delta y * delta y ) ; return result ; }	computes the weighted distance to p_other .
public name space swap ( name space new top ) { name space old top = ( name space ) ( stack . element at ( num ) ) ; stack . set element at ( new top , num ) ; return old top ; }	swap in the value as the new top of the stack and return the old value .
public static list < string > classes path ( ) throws file not found exception , loading file exception { list < file > files = get java files ( ) ; list < string > paths = new array list < string > ( ) ; for ( file file : files ) paths . add ( file . get path ( ) ) ; return paths ; }	returns a list with the paths of all java classes .
public static delete participant [ ] load delete participants ( refactoring status status , refactoring processor processor , object element , delete arguments arguments , i filter , string [ ] affected natures , sharable participants shared ) { refactoring participant [ ] participants = fg delete instance . get participants ( status , processor , element , arguments , filter , affected natures , shared ) ; delete participant [ ] result = new delete participant [ participants . length ] ; system . arraycopy ( participants , num , result , num , participants . length ) ; return result ; }	loads the delete participants for the given element .
public put result ( string success count , string fail count , list < string > error messages ) { success count = success count ; fail count = fail count ; error messages = new array list < > ( ) ; if ( error messages != null ) { error messages . add all ( error messages ) ; } }	creates a new putresult object .
@ override public int hash code ( ) { int my position = position ; int hash = num ; while ( my position < limit ) { hash = hash + get ( my position ++ ) ; } return hash ; }	calculates this buffer ' s hash code from the remaining chars.
public void print ( char sequence text ) throws io { int size = text . length ( ) ; int pos = num ; for ( int i = num ; i < size ; i ++ ) { if ( text . char at ( i ) == str ) { write ( text . sub sequence ( pos , size ) , i - pos + num ) ; pos = i + num ; at start of line = bool ; } } write ( text . sub sequence ( pos , size ) , size - pos ) ; }	print text to the output stream .
public void close running app ( string device id , string app package ) throws interrupted exception , io { cmd . run command ( str + device id + str + app package ) ; }	this method will close the running app.
@ android only ( str ) public void test unwrap 05 ( ) { string host = str ; int port = num ; byte buffer [ ] bb a = { byte buffer . allocate ( num ) , byte buffer . allocate ( num ) , byte buffer . allocate ( num ) } ; byte buffer bb = byte buffer . allocate ( num ) ; ssl sse = get engine ( host , port ) ; try { sse . unwrap ( bb , bb a , num , bb a . length ) ; fail ( str ) ; } catch ( illegal state exception iobe ) { } catch ( exception e ) { fail ( e + str ) ; } }	javax . net . ssl . sslengine # unwrap ( bytebuffer src , bytebuffer [ ] dsts , int offset , int length ) exception case : illegalstateexception should be thrown .
public boolean filterout invalidation ( t tag , tag quality status status to add , string status description , timestamp timestamp ) { return filterout ( tag , tag . get value ( ) , tag . get value description ( ) , status to add , status description , timestamp ) ; }	as for general filterout method , but for invalidation only .
public void bind y ( double property y property ) { min y . bind ( y property . add ( get min y ( ) ) ) ; max y . bind ( min y . add ( get height ( ) ) ) ; }	bind to y property of entity .
private void copy field attributes ( ) { if ( ( load fields == null ) || fields == null ) { return ; } for ( int i = num ; i < load fields . length ; i ++ ) { object stream field load field = load fields [ i ] ; string name = load field . get name ( ) ; for ( int j = num ; j < fields . length ; j ++ ) { object stream field field = fields [ j ] ; if ( name . equals ( field . get name ( ) ) ) { load field . set unshared ( field . is unshared ( ) ) ; load field . set offset ( field . get offset ( ) ) ; break ; } } } }	if a class uses " serialpersistentfields " to define the serialized fields , this.
public static uri . builder append id ( uri . builder builder , long id ) { return builder . append encoded path ( string . value of ( id ) ) ; }	appends the given id to the end of the path .
private static void begin starting service ( context context , intent intent ) { synchronized ( s starting service sync ) { if ( s starting service == null ) { power manager pm = ( power manager ) context . get system service ( context . power service ) ; s starting service = pm . new wake lock ( power manager . partial wake lock , str ) ; } s starting service . acquire ( ) ; if ( context . start service ( intent ) == null ) { log . e ( tag , str ) ; } } }	start the service to process the current event notifications , acquiring the wake lock before returning to ensure that the service will run .
public static double stddev ( double [ ] a ) { return math . sqrt ( var ( a ) ) ; }	returns the sample standard deviation in the specified array .
public simple arguments bundle ( @ non null map < string , string > arguments , @ non null display metrics metrics ) { m arguments = arguments ; m metrics = metrics ; }	create a new simple arguments bundle implementation from provided key - & gt ; value map .
public static string collapse whitespace ( string str ) { return collapse ( str , white spaces , str ) ; }	replaces any string of adjacent whitespace characters with the whitespace character " " .
private void adjust asi ( js previous parser , boolean strict , set < follow element > result ) { observable xtext token stream tokens = ( observable xtext token stream ) previous parser . get token stream ( ) ; int last token index = tokens . size ( ) - num ; if ( last token index >= num ) { common token last token = ( common token ) tokens . lt ( - num ) ; @ suppress warnings ( str ) list < token > token list = tokens . get tokens ( ) ; if ( last token == null ) { return ; } if ( should skip asi ( last token ) ) { if ( may skip asi ( last token , tokens ) ) { token list . remove ( last token index ) ; result . add all ( reset and get follow elements ( tokens , strict ) ) ; remove postfix operator ( result ) ; } } else if ( should add synthetic semicolon ( previous parser , last token index , last token ) ) { common token token = new common token ( semi ) ; token list . add ( token ) ; result . add all ( reset and get follow elements ( tokens , strict ) ) ; remove postfix operator ( result ) ; } } }	the second pass over the given input.
public linked list < patch > patch make ( string text1 , string text2 ) { if ( text1 == null || text2 == null ) { throw new illegal argument exception ( str ) ; } linked list < diff > diffs = diff main ( text1 , text2 , bool ) ; if ( diffs . size ( ) > num ) { diff cleanup semantic ( diffs ) ; diff cleanup efficiency ( diffs ) ; } return patch make ( text1 , diffs ) ; }	compute a list of patches to turn text1 into text2.
public void test basics v6 ( ) throws exception { directory dir = new directory ( ) ; random index writer writer = new random index writer ( random ( ) , dir ) ; document document = new document ( ) ; inet address address = inet address . get by name ( str ) ; document . add ( new inet address point ( str , address ) ) ; writer . add document ( document ) ; index reader reader = writer . get reader ( ) ; index searcher searcher = new searcher ( reader ) ; assert equals ( num , searcher . count ( inet address point . new exact query ( str , address ) ) ) ; assert equals ( num , searcher . count ( inet address point . new prefix query ( str , address , num ) ) ) ; assert equals ( num , searcher . count ( inet address point . new range query ( str , inet address . get by name ( str ) , inet address . get by name ( str ) ) ) ) ; reader . close ( ) ; writer . close ( ) ; dir . close ( ) ; }	add a single address and search for it.
private boolean is minor version upgrade ( string current version , string target version ) { string current db schema version = vdc util . get db schema version ( current version ) ; if ( current db schema version == null ) { return bool ; } return current db schema version . equals ( vdc util . get db schema version ( target version ) ) ; }	check if the current upgrade is a sp / patch / hotfix upgrade .
public static final void exception ( throwable e ) { log expensive ( level . severe , e . get message ( ) , e ) ; }	static version to log a severe exception .
private static default alignment value of ( string str , boolean is horizontal ) { if ( str . equals ( str ) || str . equals ( str ) ) { return fill align ; } else if ( str . equals ( str ) || str . equals ( str ) ) { return center align ; } else if ( is horizontal ) { if ( str . equals ( str ) || str . equals ( str ) ) { return right align ; } else if ( str . equals ( str ) || str . equals ( str ) ) { return left align ; } else { return null ; } } else if ( str . equals ( str ) || str . equals ( str ) ) { return top align ; } else if ( str . equals ( str ) || str . equals ( str ) ) { return bottom align ; } else { return null ; } }	returns a defaultalignment that corresponds to the specified string , null if no such alignment exists .
public void combine sets ( hash map < string , set < string > > container affinities , operator pair pair ) { set < string > set1 = container affinities . get ( pair . first ) ; set < string > set2 = container affinities . get ( pair . second ) ; set1 . add all ( set2 ) ; container affinities . put ( pair . first , set1 ) ; container affinities . put ( pair . second , set1 ) ; }	combine affinity sets for operators with affinity.
protected void fire property change ( string property name , object old value , object new value ) { property change support . fire property change ( property name , old value , new value ) ; }	support for reporting bound property changes for object properties.
@ override public boolean is busy ( ) { return ( m split thread != null ) ; }	returns true if . at this time , the bean is busy with some ( i . e . perhaps a worker thread is performing some calculation ) .
public static < e > boolean is not empty ( char sequence c ) { return ( ( c != null ) && ( c . length ( ) > num ) ) ; }	check whether charsequence c is not empty .
@ override public boolean e is set ( int feature id ) { switch ( feature id ) { case eip package . composite processor name : return name edefault == null ? name != null : ! name edefault . equals ( name ) ; case eip package . composite processor to channels : return to channels != null && ! to channels . is empty ( ) ; case eip package . composite processor from channels : return from channels != null && ! from channels . is empty ( ) ; case eip package . composite processor owned endpoints : return owned endpoints != null && ! owned endpoints . is empty ( ) ; } return super . e is set ( feature id ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
private void add info button ( j panel , object o , string client prop ) { j h button ; h button = new j ( o . to string ( ) ) ; h button . put client property ( client prop , o ) ; h button . add action listener ( this ) ; h button . set font ( font ) ; h button . set margin ( new insets ( num , num , num , num ) ) ; h button . set background ( log button bg ) ; panel . add ( h button ) ; }	adds a new button to a log entry panel and attaches a client property into it.
public void remove network listener ( network listener network listener ) { network listeners . remove ( network listener ) ; }	remove a network listener .
public static string chomp ( string s ) { if ( s . ends with ( str ) ) return s . substring ( num , s . length ( ) - num ) ; if ( s . ends with ( str ) || s . ends with ( str ) ) return s . substring ( num , s . length ( ) - num ) ; return s ; }	removes a line - break from the end of the string ( if there ' s any ) .
private void validate surrogate settings ( ) { faulty surrogates radio button . set enabled ( bool ) ; discard surrogates article radio button . set enabled ( bool ) ; replace surrogates radio button . set enabled ( bool ) ; discard surrogates revision radio button . set selected ( bool ) ; }	validates the surrogate settings .
static disk id create disk id ( long max oplog size , boolean is persistence type , boolean needs linked list ) { long bytes = max oplog size * num * num ; if ( bytes > integer . max value ) { if ( is persistence type ) { if ( needs linked list ) { return new persistence with long offset ( ) ; } else { return new ll ( ) ; } } else { if ( needs linked list ) { return new overflow only with long offset ( ) ; } else { return new ll ( ) ; } } } else { if ( is persistence type ) { if ( needs linked list ) { return new persistence with int offset ( ) ; } else { return new ll ( ) ; } } else { if ( needs linked list ) { return new overflow only with int offset ( ) ; } else { return new ll ( ) ; } } } }	creates appropriate instance of diskid depending upon the maxoplogsize set by the user.
public static long size of ( class clazz ) { long max size = header size ( clazz ) ; while ( clazz != object . class ) { for ( field f : clazz . get declared fields ( ) ) { if ( ( f . get modifiers ( ) & modifier . static ) == num ) { long offset = unsafe . object field offset ( f ) ; if ( offset > max size ) { max size = offset + num ; } } } clazz = clazz . get superclass ( ) ; } return round up to8 ( max size ) ; }	returns the size of an instance of this class ( in bytes ).
public void add handler ( string column name , sql handler ) { if ( m overrides == null ) m overrides = new hash map ( num ) ; m overrides . put ( column name , handler ) ; }	add a custom data handler for a given column name .
public void add near evicted ( key cache object key ) { if ( near evicted == null ) near evicted = new array list < > ( ) ; near evicted . add ( key ) ; }	adds near evicted key.
public word ( string word , string display as , string ... sounds like ) { this ( ) ; this . word = word ; this . display as = display as ; this . sounds like = arrays . as list ( sounds like ) ; }	instantiates a new word .
public enumerated distribution ( final list < pair < t , double > > pmf ) throws math illegal argument exception { singletons = new array list < > ( pmf . size ( ) ) ; final double [ ] probs = new double [ pmf . size ( ) ] ; for ( int i = num ; i < pmf . size ( ) ; i ++ ) { final pair < t , double > sample = pmf . get ( i ) ; singletons . add ( sample . get key ( ) ) ; final double p = sample . get value ( ) ; probs [ i ] = p ; } probabilities = check and normalize ( probs ) ; cumulative probabilities = new double [ probabilities . length ] ; double sum = num ; for ( int i = num ; i < probabilities . length ; i ++ ) { sum += probabilities [ i ] ; cumulative probabilities [ i ] = sum ; } }	create an enumerated distribution using the given probability mass function enumeration .
@ override public calendar next ( ) { if ( spot . equals ( end final ) ) { throw new no such element exception ( ) ; } spot . add ( calendar . date , num ) ; return ( calendar ) spot . clone ( ) ; }	return the next calendar in the iteration.
public void pause work ( ) { m exit tasks early = bool ; set pause ( bool ) ; if ( debug ) { log . d ( tag , string . format ( str , this ) ) ; } }	temporarily hand up work , you can call this when the view is scrolling .
public static list < error logger . error object > is virtual track in cpl ( payload record cpl payload record , virtual track virtual track , list < payload record > essences header partition payloads ) throws io { list < virtual track > virtual tracks = new array list < > ( ) ; imf imf error logger = new imf ( ) ; virtual tracks . add ( virtual track ) ; imf error logger . add all errors ( check virtual track and essences header partition payload records ( virtual tracks , essences header partition payloads ) ) ; if ( imf error logger . has fatal errors ( ) ) { return imf error logger . get errors ( ) ; } imf error logger . add all errors ( conform virtual tracks in cpl ( cpl payload record , essences header partition payloads , bool ) ) ; return imf error logger . get errors ( ) ; }	a stateless method that can be used to determine if a virtual track in a composition is conformant . conformance checks perform deeper inspection of the composition and the essencedescriptors corresponding to the virtual track.
public static string encode ( byte [ ] input ) { if ( input . length == num ) { return str ; } int zeros = num ; while ( zeros < input . length && input [ zeros ] == num ) { ++ zeros ; } input = arrays . copy of ( input , input . length ) ; char [ ] encoded = new char [ input . length * num ] ; int output start = encoded . length ; for ( int input start = zeros ; input start < input . length ; ) { encoded [ -- output start ] = alphabet [ divmod ( input , input start , num , num ) ] ; if ( input [ input start ] == num ) { ++ input start ; } } while ( output start < encoded . length && encoded [ output start ] == encoded zero ) { ++ output start ; } while ( -- zeros >= num ) { encoded [ -- output start ] = encoded zero ; } return new string ( encoded , output start , encoded . length - output start ) ; }	encodes the given bytes as a base58 string ( no checksum is appended ) .
public static int [ ] cells ( int [ ] start , int [ ] end ) { arrays . sort ( start ) ; arrays . sort ( end ) ; int overlap = num ; int gaps = num ; for ( int i = num , j = num ; j < end . length ; ) { if ( i < start . length && start [ i ] < end [ j ] ) { overlap ++ ; i ++ ; } else { j ++ ; overlap -- ; } if ( overlap == num ) { gaps ++ ; } } int [ ] cells = new int [ gaps * num ] ; overlap = num ; gaps = num ; int previous overlap = num ; for ( int i = num , j = num ; j < end . length ; ) { if ( i < start . length && start [ i ] < end [ j ] ) { overlap ++ ; if ( previous overlap == num ) { cells [ gaps ++ ] = start [ i ] ; } i ++ ; } else { overlap -- ; if ( overlap == num ) { cells [ gaps ++ ] = end [ j ] ; } j ++ ; } previous overlap = overlap ; } return cells ; }	calculate the ranges for the cells.
@ override public in store open read ( long address , int size ) { if ( file size ( ) < address + size ) { throw new illegal state exception ( l . l ( str , this , address , size , file size ( ) ) ) ; } if ( is closed . get ( ) ) { throw new illegal state exception ( l . l ( str , this ) ) ; } if ( file size < address + size ) { throw new illegal state exception ( l . l ( str , long . to hex string ( address ) , size ) ) ; } try { stream open ( address , size ) ; return open read impl ( address , size ) ; } catch ( io e ) { throw new runtime exception ( e ) ; } }	opens the underlying file to the database .
list < address > geo decode ( string searched location ) { try { geocoder geo = new geocoder ( s context , locale . get default ( ) ) ; list < address > addresses = geo . get from location name ( searched location , num ) ; if ( addresses != null && addresses . size ( ) > num ) { return addresses ; } } catch ( exception ex ) { } return null ; }	return list of < address > from searched location.
private boolean is identifier start char ( int position ) { if ( len >= num && position >= len ) { return bool ; } char ch = working [ position ] ; return character . is unicode identifier start ( ch ) ; }	checks if character at specified position can be identifier start .
public void destroy ( ) { fallback storage . clear ( ) ; file utils . delete quietly ( fallback storage file ) ; }	destroy the persisted storage and all stored data .
public static select clause create ( string ... property names ) { list < select clause element > select list = new array list < select clause element > ( ) ; for ( string name : property names ) { select list . add ( new select clause expression ( new property value expression ( name ) ) ) ; } return new select clause ( stream selector . istream only , select list ) ; }	creates a select - clause consisting of a list of property names .
public static string make margin transform ( double owidth , double oheight , double iwidth , double iheight , double lmargin , double tmargin , double rmargin , double bmargin ) { double swidth = iwidth + lmargin + rmargin ; double sheight = iheight + tmargin + bmargin ; double scale = math . max ( swidth / owidth , sheight / oheight ) ; double offx = ( scale * owidth - swidth ) * num + lmargin ; double offy = ( scale * oheight - sheight ) * num + tmargin ; return str + fmt ( num / scale ) + str + fmt ( offx ) + str + fmt ( offy ) + str ; }	make a transform string to add margins.
public static boolean is attachment ( string content disposition ) { return content disposition != null && content disposition . region matches ( bool , num , str , num , num ) ; }	returns true if the download meant to be treated as an attachment .
private j create insert menu ( ) { j insert menu = new j ( str ) ; insert menu . add ( action manager . get new network action ( ) ) ; j new gauge sub menu = new j ( str ) ; for ( action action : action manager . get plot actions ( ) ) { new gauge sub menu . add ( action ) ; } insert menu . add ( new gauge sub menu ) ; j new world sub menu = new j ( str ) ; for ( action action : action manager . get new world actions ( ) ) { new world sub menu . add ( action ) ; } insert menu . add ( new world sub menu ) ; insert menu . add separator ( ) ; insert menu . add ( action manager . get new doc viewer action ( ) ) ; insert menu . add ( action manager . get new console action ( ) ) ; return insert menu ; }	create the workspace insert menu .
public static vector < string > find packages ( ) { vector < string > result ; enumeration < string > packages ; init cache ( ) ; result = new vector < string > ( ) ; packages = m . packages ( ) ; while ( packages . has more elements ( ) ) { result . add ( packages . next element ( ) ) ; } collections . sort ( result , new string compare ( ) ) ; return result ; }	lists all packages it can find in the classpath .
public static string convert system name to alternate ( string system name ) { if ( ! valid system name format ( system name , system name . char at ( num ) , str ) ) { return str ; } string alt name = str ; alt name = system name ; return alt name ; }	public static method to convert one format acela system name for the alternate format.
private void initialize user directives ( ) { user directives = new array list < > ( ) ; i preferences = velocity core plugin . get preferences ( ) ; string directives = preferences . get ( i . velocity user directives , str ) ; string tokenizer st = new string tokenizer ( directives , str ) ; while ( st . has more elements ( ) ) { string directive = ( string ) st . next element ( ) ; string name = directive . substring ( num , directive . index of ( str ) ) ; int type = ( directive . ends with ( str ) ? directive . block : directive . line ) ; user directives . add ( str + name ) ; add directive ( new velocity directive ( name , type ) ) ; } }	this methods initializes all user directives .
private synchronized void store timestamp and set status ( timestamper . timestamp succeeded message , timestamp record timestamp record ) throws exception { try { persist timestamp record ( message , timestamp record ) ; set timestamp succeeded ( ) ; } catch ( exception e ) { log . error ( str , e ) ; set timestamp failed regardless of queue ( new date time ( ) ) ; throw e ; } }	stores timestamped records , and sets status to succeeded if everything went as expected . this method is synchronized so that these two operations are executed atomically and do not disturb each other : 1 ) storetimestampandsetstatus : stores timestamp records and sets status 2 ) settimestampfailed : reads status , checks existence of unstamped records and sets status.
public static character [ ] values of ( char [ ] array ) { character [ ] dest = new character [ array . length ] ; for ( int i = num ; i < array . length ; i ++ ) { dest [ i ] = character . value of ( array [ i ] ) ; } return dest ; }	converts to object array .
public void mark ( int readlimit ) { stream . mark ( readlimit ) ; if ( mark supported ( ) ) { markpos = frame pos ; mark push back len = push back len ; if ( mark push back len > num ) { if ( mark push back buffer == null ) { mark push back buffer = new byte [ frame size ] ; } system . arraycopy ( push back buffer , num , mark push back buffer , num , mark push back len ) ; } } }	marks the current position in this audio input stream .
public void test creating launcher with jetty1 ( ) { swt bot project creation . create maven gwt project is created1 ( bot , project name , package name ) ; swt bot project debug . launch gwt ( bot , project name ) ; string persisted args = swt bot project debug . get the program args text box ( bot ) ; assert true ( persisted args . contains ( str ) ) ; }	gwt maven plugin 1 test launch.
public static boolean needs default formatter ( value formatter formatter ) { if ( formatter == null ) return bool ; if ( formatter instanceof default value formatter ) return bool ; return bool ; }	if this component has no valueformatter or is only equipped with the default one ( no custom set ) , return true .
public boolean put grammar ( schema grammar grammar , boolean deep , boolean ignore conflict ) { if ( ! ignore conflict ) { return put grammar ( grammar , deep ) ; } schema grammar sg = get grammar ( grammar . f target namespace ) ; if ( sg == null ) { put grammar ( grammar ) ; } if ( ! deep ) { return bool ; } vector curr grammars = grammar . get imported grammars ( ) ; if ( curr grammars == null ) { return bool ; } vector grammars = ( ( vector ) curr grammars . clone ( ) ) ; schema grammar sg1 , sg2 ; vector gs ; for ( int i = num ; i < grammars . size ( ) ; i ++ ) { sg1 = ( schema grammar ) grammars . element at ( i ) ; sg2 = get grammar ( sg1 . f target namespace ) ; if ( sg2 == null ) { gs = sg1 . get imported grammars ( ) ; if ( gs == null ) continue ; for ( int j = gs . size ( ) - num ; j >= num ; j -- ) { sg2 = ( schema grammar ) gs . element at ( j ) ; if ( ! grammars . contains ( sg2 ) ) grammars . add element ( sg2 ) ; } } else { grammars . remove ( sg1 ) ; } } for ( int i = grammars . size ( ) - num ; i >= num ; i -- ) { put grammar ( ( schema grammar ) grammars . element at ( i ) ) ; } return bool ; }	put a schema grammar and any grammars imported by it ( directly or inderectly ) into the registry.
public list < n > nodes ( @ nullable object key , int cnt ) { return nodes ( key , cnt , null , null ) ; }	gets specified count of adjacent nodes for a given key.
public boolean is exists key ( connection connection , object [ ] keys ) { string builder builder = new string builder ( ) ; builder . append ( str ) ; builder . append ( table name ) ; builder . append ( str ) ; string delimiter = str ; for ( string key field : key field names ) { builder . append ( delimiter ) ; builder . append ( key field ) ; builder . append ( str ) ; delimiter = str ; } string query = builder . to string ( ) ; prepared statement statement = null ; try { if ( ( execution path debug log . is debug enabled ) && ( log . is debug enabled ( ) ) ) { log . debug ( str + query + str + print ( keys ) + str ) ; } statement = connection . prepare statement ( query ) ; for ( int i = num ; i < keys . length ; i ++ ) { statement . set object ( i + num , keys [ i ] ) ; } result set rs = statement . execute query ( ) ; if ( ! rs . next ( ) ) { return bool ; } return bool ; } catch ( sql ex ) { string message = str + query + str + ex . get message ( ) ; log . error ( message , ex ) ; store exception handler . handle ( message , ex ) ; throw new db ( message , ex ) ; } finally { try { if ( statement != null ) statement . close ( ) ; } catch ( sql e ) { } } }	determine if the key exists .
public static < t > t implement ( class < t > type , object object ) { if ( type . is instance ( object ) ) { return type . cast ( object ) ; } return type . cast ( proxy . new proxy instance ( type . get class loader ( ) , new class [ ] { type } , new duck type ( object ) ) ) ; }	causes object to implement the interfacetoimplement and returns an instance of the object implementing interfacetoimplement even if interfacetoimplement was not declared in object.
public boolean is ivr vsan ( int vsan id ) { boolean in range = vsans . contains ( vsan id ) ; if ( ! in range ) { for ( int range range : get vsans ranges ( ) ) { in range = range . contains integer ( vsan id ) ; if ( in range ) { break ; } } } return in range ; }	determine if given vsan is an ivr vsan.
private void add bom ( m product , big decimal qty ) { mpp bom bom = mpp bom . get default ( product , null ) ; mpp bom [ ] bom lines = bom . get lines ( bool ) ; for ( int i = num ; i < bom lines . length ; i ++ ) add bom ( bom lines [ i ] , qty ) ; log . fine ( str + bom lines . length ) ; }	add bom lines to this . called recursively.
@ override public foo fetch by uuid c ( string uuid , long company id , order by comparator < foo > order by comparator ) { int count = count by uuid c ( uuid , company id ) ; if ( count == num ) { return null ; } list < foo > list = find by uuid c ( uuid , company id , count - num , count , order by comparator ) ; if ( ! list . is empty ( ) ) { return list . get ( num ) ; } return null ; }	returns the last foo in the ordered set where uuid = & # 63 ; and companyid = & # 63 ; .
public final boolean at ( string str , char sequence csq ) { int i = index ; int length = csq . length ( ) ; for ( int j = num ; j < str . length ( ) ; ) { if ( ( i >= length ) || ( str . char at ( j ++ ) != csq . char at ( i ++ ) ) ) return bool ; } return bool ; }	indicates if this cursor points to the specified characters in the specified sequence .
public static int find last of ( string container , string char seq , int begin ) { for ( int i = begin ; i < container . length ( ) && i >= num ; -- i ) { if ( char seq . contains ( str + container . char at ( i ) ) ) return i ; } return - num ; }	find the last occurrence .
private static cookie origin adjust effective host ( final cookie origin origin ) { string host = origin . get host ( ) ; boolean is local host = bool ; for ( int i = num ; i < host . length ( ) ; i ++ ) { char ch = host . char at ( i ) ; if ( ch == str || ch == str ) { is local host = bool ; break ; } } if ( is local host ) { host += str ; return new cookie origin ( host , origin . get port ( ) , origin . get path ( ) , origin . is secure ( ) ) ; } else { return origin ; } }	set ' effective host name ' as defined in rfc 2965.
protected final void finalize ( ) { }	enum classes cannot have finalize methods .
public boolean add bound ( type bound bound ) { if ( bound . is trivial ( ) ) { return bool ; } final boolean was added = internal add bound ( bound ) ; if ( debug ) { final string suffix = was added ? str : str ; log ( str + bound + suffix ) ; } return was added ; }	adds a type bound to this set.
public boolean remove ( sim event event ) { return sorted set . remove ( event ) ; }	removes the event from the queue .
public static final void print thread cpu time ( final thread thread ) { if ( tbe . is thread cpu time enabled ( ) ) { log . info ( str + thread . get name ( ) + str + get thread cpu time ( thread ) + str ) ; } }	prints the cpu time for the given thread , i.
public static version from bits ( int major , int minor , int bugfix ) { return new version ( major , minor , bugfix ) ; }	returns a new version based on raw numbers.
private static i [ ] random points ( int n , int d , int scale ) { i points [ ] = new i [ n ] ; for ( int i = num ; i < n ; i ++ ) { string builder sb = new string builder ( ) ; for ( int j = num ; j < d ; j ++ ) { sb . append ( r gen . next double ( ) * scale ) ; if ( j < d - num ) { sb . append ( str ) ; } } points [ i ] = new hyperpoint ( sb . to string ( ) ) ; } return points ; }	generate array of n d - dimensional points whose coordinates are values in the range 0.
public static string bytes to string ( int [ ] b ) { if ( b . length < num ) { return str ; } return string . format ( str , b [ num ] , b [ num ] , b [ num ] , b [ num ] ) ; }	prints a int [ ] as a string separated by ".
private string convert to iso date time ( string human readable date time ) throws parse exception { date format df initial = new simple date format ( str ) ; date initial date time = df initial . parse ( human readable date time ) ; date format df = new simple date format ( str ) ; return df . format ( initial date time ) ; }	convert string of datetime of format " yyyy - mm - dd hh : mm : ss " into iso 8601 format " yyyy - mm - dd ' t ' hh : mm : ss . s ' z ' ".
private static boolean class names equal ( string name1 , string name2 ) { name1 = name1 . substring ( name1 . last index of ( str ) + num ) ; name2 = name2 . substring ( name2 . last index of ( str ) + num ) ; return name1 . equals ( name2 ) ; }	compares class names for equality , ignoring package names.
public boolean opt boolean ( int index ) { return opt boolean ( index , bool ) ; }	get the optional boolean value associated with an index.
public command builder with long switch if present ( map < string , object > properties , string ... keys ) { with long switch if present ( properties , unary operator . identity ( ) , keys ) ; return this ; }	if the given key ( s ) is present in the map , create a long switch ( - - switch ) with the same name as the key.
private void on collection clicked ( long collection id ) { intent intent = new intent ( this , product list activity . class ) ; if ( collection id != null ) { intent . put extra ( product list activity . extra collection id , collection id ) ; } start activity ( intent ) ; }	when the user picks a collection , launch the product list activity to display the products in that collection .
public boolean is item stack registered for name ( item stack stack , string ore name ) { final int [ ] ore i = ore dictionary . get ore i ( stack ) ; for ( final int ore id : ore i ) { if ( ore name . equals ( ore dictionary . get ore name ( ore id ) ) ) { return bool ; } } return bool ; }	is the itemstack registered under the specified ore name ? < p > test for this thread : http : / / www.
private static @ nonnull url [ ] create classloader urls ( @ nonnull url url ) throws plugin exception { list < url > urls = new array list < url > ( ) ; urls . add ( url ) ; manifest mf = null ; file f = new file ( url . get path ( ) ) ; if ( ! f . is directory ( ) ) { jar input stream jis = null ; try { jis = new jar input stream ( url . open stream ( ) ) ; mf = jis . get manifest ( ) ; } catch ( io ioe ) { throw new plugin exception ( str + url , ioe ) ; } finally { io . close ( jis ) ; } } else { file manifest = guess manifest ( f ) ; if ( manifest != null ) { file input stream is = null ; try { is = new file input stream ( manifest ) ; mf = new manifest ( is ) ; } catch ( io e ) { throw new plugin exception ( str + url , e ) ; } finally { io . close ( is ) ; } } } if ( mf != null ) { try { add class path from manifest ( url , urls , mf ) ; } catch ( url e ) { throw new plugin exception ( str + url , e ) ; } } return urls . to array ( new url [ urls . size ( ) ] ) ; }	patch for issue 3429143 : allow plugins load classes / resources from 3rd party jars.
@ override public void write ( string str , int st , int end ) throws io { out . write ( str , st , end ) ; }	write the specified characters from a string .
public boolean is awake ( ) { return is awake ; }	returns whether the node is awake .
private static void transfer streams ( input stream source , output stream destination ) { byte [ ] buffer = new byte [ num ] ; try { while ( bool ) { int bytes read = - num ; try { bytes read = source . read ( buffer ) ; } catch ( io e ) { return ; } if ( bytes read == - num ) break ; try { destination . write ( buffer , num , bytes read ) ; } catch ( io e ) { return ; } } } finally { try { source . close ( ) ; } catch ( io e ) { } finally { try { destination . close ( ) ; } catch ( io e ) { } } } }	transfers all available bytes from the given input stream to the given output stream.
public static void gc ( ) { if ( started gc ) { force gc = bool ; gc should loop = bool ; } start gc ( ) ; synchronized ( lock ) { lock . notify ( ) ; } try { thread . sleep ( num ) ; } catch ( interrupted exception er ) { } }	runs the garbage collector.
public static blob entry is blob entry for storing ( string repository location , string mime type ) { repository location location ; try { location = new repository location ( repository location ) ; entry entry = location . locate entry ( ) ; if ( entry instanceof blob entry ) { blob entry blob entry = ( blob entry ) entry ; if ( mime type . equals ( blob entry . get mime type ( ) ) ) { return blob entry ; } else { swing tools . show simple error message ( str , blob entry . get name ( ) ) ; return null ; } } else if ( entry == null ) { return create blob entry ( repository location ) ; } else { swing tools . show simple error message ( str , entry . get name ( ) ) ; } } catch ( repository exception e ) { swing tools . show simple error message ( str , e ) ; } catch ( malformed repository location exception e ) { swing tools . show simple error message ( str , e ) ; } return null ; }	this method will check if the given location is either empty or is an blobentry of the given mimetype.
@ request mapping ( value = { str , str } , method = request method . put ) @ response body public rest wrapper insert ( @ model attribute ( str ) @ valid batch batch , binding result binding result , principal principal ) { rest wrapper rest wrapper = null ; if ( binding result . has errors ( ) ) { binding result error binding result error = new binding result error ( ) ; return binding result error . error message ( binding result ) ; } try { com . wipro . ats . bdre . md . dao . jpa . batch jpa batch = new com . wipro . ats . bdre . md . dao . jpa . batch ( ) ; jpa batch . set batch type ( batch . get batch type ( ) ) ; instance exec instance exec = new instance exec ( ) ; if ( batch . get source instance exec id ( ) != null ) { instance exec . set instance exec id ( batch . get source instance exec id ( ) ) ; jpa batch . set instance exec ( instance exec ) ; } long auto gen batch id = batch dao . insert ( jpa batch ) ; batch . set batch id ( auto gen batch id ) ; rest wrapper = new rest wrapper ( batch , rest wrapper . ok ) ; logger . info ( recordwithid + batch . get batch id ( ) + str + principal . get name ( ) + batch ) ; } catch ( metadata exception e ) { logger . error ( e ) ; rest wrapper = new rest wrapper ( e . get message ( ) , rest wrapper . error ) ; } return rest wrapper ; }	this method calls proc insertbatch and adds a record in database.
private void on click gallery image ( final recent media a media item ) { if ( null != m camera ) { m camera . stop preview ( ) ; } m selected gallery items list . add ( a media item ) ; if ( ( null != a media item . m thumbnail ) && ! m is avatar mode ) { update ui configuration ( ui show taken image , image origin gallery ) ; m image preview image view . set image bitmap ( a media item . m thumbnail ) ; vector app . set saved camera image preview ( a media item . m thumbnail ) ; } else if ( null != a media item . m file uri ) { display image preview ( null , null , a media item . m file uri , image origin gallery ) ; } else { log . e ( log tag , str ) ; } m image preview image view . set tag ( a media item . m file uri ) ; }	the user clicked on a gallery image.
public static double pareto ( double alpha ) { if ( ! ( alpha > num ) ) throw new illegal argument exception ( str ) ; return math . pow ( num - uniform ( ) , - num / alpha ) - num ; }	returns a random real number from a pareto distribution with shape parameter & alpha ; .
public void disconnect from broker ( final mqtt async connection connection ) { try { connection . disconnect ( new mqtt disconnection result handler ( ) ) ; } catch ( spy exception e ) { platform . run later ( new mqtt event handler ( new mqtt disconnection attempt failure event ( connection , e ) ) ) ; logger . error ( e . get message ( ) , e ) ; } }	disconnects the specified connection from the broker .
public object [ ] copy all ( ) { return arrays . copy of ( args , args . length ) ; }	returns all arguments in the argument list in a freshly - allocated array .
public void start ( ) { log . info ( str , port , log level ) ; try { component . start ( ) ; } catch ( exception e ) { throw new illegal state exception ( str , e ) ; } log . info ( str , port ) ; running = bool ; started = system . current time millis ( ) ; }	starts the nutch server printing some logging to the log file .
public fs read account fed info ( string user id , string provider id ) throws fs { return read account fed info ( user id , provider id , null ) ; }	reads account ' s federation info from data store for given providerid and returns value as fedinfo object . returns null if value not found for given providerid.
public response ( string status , string mime type , string txt ) { this . status = status ; this . mime type = mime type ; try { this . data = new byte array input stream ( txt . get bytes ( str ) ) ; } catch ( java . io . unsupported encoding exception uee ) { uee . print stack trace ( ) ; } }	convenience method that makes an inputstream out of given text .
@ parallel @ realtime ( limit = linear ) public e reduce ( binary operator < e > operator ) { iterator < e > itr = iterator ( ) ; if ( ! itr . has next ( ) ) return null ; e accumulator = itr . next ( ) ; while ( itr . has next ( ) ) accumulator = operator . apply ( accumulator , itr . next ( ) ) ; return accumulator ; }	performs a reduction by applying the specified operator over the elements of this collection .
public void save history ( string filename ) throws exception { file output stream fos = new file output stream ( filename ) ; object output stream oos = new object output stream ( fos ) ; oos . write object ( get history ( ) ) ; oos . close ( ) ; }	save the utilization history to a file .
private void check size ( final int i ) { if ( i >= max size ) { final int old size = max size ; max size += increment size ; if ( max size <= i ) { max size = i + increment size + num ; } final double [ ] temp = items ; items = new double [ max size ] ; system . arraycopy ( temp , num , items , num , old size ) ; increment size = increment size ( increment size ) ; } }	check the size of the array and increase if needed.
public double next gaussian ( ) { return random . next gaussian ( ) ; }	get the next gaussian value .
private void read from properties ( final properties props , final boolean default minimized , final int default x , final int default y , final boolean default visible ) { minimized = boolean . parse boolean ( props . get property ( str + name + str , boolean . to string ( default minimized ) ) ) ; visible = boolean . parse boolean ( props . get property ( str + name + str , boolean . to string ( default visible ) ) ) ; x = integer . parse int ( props . get property ( str + name + str , integer . to string ( default x ) ) ) ; y = integer . parse int ( props . get property ( str + name + str , integer . to string ( default y ) ) ) ; }	read window configuration from properties .
public boolean send e ( int ad id , string subject , string message , collection < file > attachments , boolean html ) { m to = m . get ( get ctx ( ) , ad id ) ; string to e = to . get e ( ) ; if ( to e == null || to e . length ( ) == num ) { log . warning ( str + to ) ; return bool ; } e email = create e ( null , to , subject , message , html ) ; if ( email == null ) return bool ; email . add attachments ( attachments ) ; try { return send email now ( null , to , email ) ; } catch ( exception ex ) { log . severe ( get name ( ) + str + ex . get localized message ( ) ) ; return bool ; } }	send email from request user - with trace.
private void add unit tax calculation info clone ( final tax calculation info tax cal info , final tax calculation info clone ) { final list < unit tax calculation info > units = new array list < unit tax calculation info > ( ) ; final list < unit tax calculation info > units by date = new array list < unit tax calculation info > ( ) ; for ( final unit tax calculation info unit info : tax cal info . get unit tax calculation infos ( ) ) { final unit tax calculation info new unit info = get unit tax calculation info clone ( unit info ) ; units by date . add ( new unit info ) ; } clone . set unit tax calculation info ( units ) ; }	adds the unittaxcalculationinfo clones to clone.
public socket wrapper accept ( ) throws io { for ( ; ; ) { try { socket sock = server socket . accept ( ) ; return new socket wrapper ( sock ) ; } catch ( socket timeout exception e ) { } catch ( io e ) { if ( done ) { throw new socket termination exception ( str , e ) ; } else { throw e ; } } } }	accepts a connection the server socket .
private string replace dot in mustache keys ( final list < string > mustache keys , final string plugin call ) { string fixed plugin call = plugin call ; for ( string mustache key : mustache keys ) { if ( mustache key . contains ( str ) ) { fixed plugin call = fixed plugin call . replace ( str + mustache key + str , str + mustache key . replace ( str , str ) + str ) ; } } return fixed plugin call ; }	todo : trivial components does not support foo.
protected synchronized instance process buffers ( ) { if ( m first buffer != null && m second buffer != null && m first buffer . size ( ) > num && m second buffer . size ( ) > num ) { if ( m stop requested . get ( ) ) { return null ; } instance holder first h = m first buffer . peek ( ) ; instance holder second h = m second buffer . peek ( ) ; instance first = first h . m instance ; instance second = second h . m instance ; int cmp = compare ( first , second , first h , second h ) ; if ( cmp == num ) { instance new inst = generate merged instance ( m first buffer . remove ( ) , m second buffer . remove ( ) ) ; return new inst ; } else if ( cmp < num ) { do { m first buffer . remove ( ) ; if ( m first buffer . size ( ) > num ) { first h = m first buffer . peek ( ) ; first = first h . m instance ; cmp = compare ( first , second , first h , second h ) ; } } while ( cmp < num && m first buffer . size ( ) > num ) ; } else { do { m second buffer . remove ( ) ; if ( m second buffer . size ( ) > num ) { second h = m second buffer . peek ( ) ; second = second h . m instance ; cmp = compare ( first , second , first h , second h ) ; } } while ( cmp > num && m second buffer . size ( ) > num ) ; } } return null ; }	process the current state of the two buffers.
public boolean is theme constant ( string constant name , boolean def ) { string c = get theme constant ( constant name , null ) ; if ( c == null ) { return def ; } return c . equals ignore case ( str ) || c . equals ( str ) ; }	returns a theme constant defined in the resource editor as a boolean value.
public void test delete4 ( ) throws sql { database creator . fill fk ( conn ) ; statement . execute ( str + database creator . parent table + str ) ; }	deletefunctionalitytest # testdelete4 ( ) . deletes row with no referencing ones and cascade action.
public void unmap ( int addr , int len ) { for ( int i = num ; i < len ; i += page size ) { int pte = get pte ( addr + i ) ; if ( get page ( pte ) != null ) { readable memory [ pte ] = null ; writable memory [ pte ] = null ; executable memory [ pte ] = null ; } else { throw new error ( str + integer . to hex string ( addr ) + str + len ) ; } } }	unmap a page of memory.
private synchronized void save to settings ( ) { list < list > entries to save = new array list < > ( ) ; for ( status history entry entry : entries . values ( ) ) { entries to save . add ( entry to list ( entry ) ) ; } settings . put list ( str , entries to save ) ; }	turns all entries into a list and adds them to a list that is saved in the settings .
protected void init finished ( ) { }	a hook method after initialize ( ) and initgui have been called .
protected void add to maintenance queue ( node port tuple npt ) { if ( maintenance queue . contains ( npt ) == bool ) maintenance queue . add ( npt ) ; }	add a switch port to maintenance queue .
public movie scraper metadata panel ( movie scraper metadata config config ) { this . config = config ; init components ( ) ; }	instantiates a new movie scraper metadata panel .
public static void assert props per row ( iterator < event bean > iterator , safe iterator < event bean > safe iterator , string [ ] property names , object [ ] [ ] expected ) { assert props per row ( ep . iterator to array ( iterator ) , property names , expected ) ; assert props per row ( ep . iterator to array ( safe iterator ) , property names , expected ) ; safe iterator . close ( ) ; }	compare the property values returned by events of both iterators with the expected values , using exact - order semantics .
public void test get ( ) throws exception { ignite cache < long , long > cache = populate ( ) ; for ( long i = from ; i < to ; i ++ ) { long val = cache . get ( i ) ; assert not null ( val ) ; assert equals ( i , val . long value ( ) ) ; } assert equals ( num , swapped cnt . get ( ) ) ; assert equals ( num , offheaped cnt . get ( ) ) ; assert equals ( to - from , unswaped cnt . get ( ) + onheaped cnt . get ( ) ) ; check entries ( cache ) ; assert equals ( to - from , unswaped cnt . get ( ) + onheaped cnt . get ( ) ) ; }	tests behavior on offheaped entries .
public int read ( ) throws io { if ( has next char ) { has next char = bool ; write ( next char ) ; return next char ; } if ( previous line != lexer . get line ( ) ) { num unicode escapes found on current line = num ; previous line = lexer . get line ( ) ; } int c = reader . read ( ) ; if ( c != str ) { write ( c ) ; return c ; } c = reader . read ( ) ; if ( c != str ) { has next char = bool ; next char = c ; write ( str ) ; return str ; } int number of u = num ; do { number of u ++ ; c = reader . read ( ) ; } while ( c == str ) ; check hex digit ( c ) ; string builder char num = new string builder ( ) ; char num . append ( ( char ) c ) ; for ( int i = num ; i < num ; i ++ ) { c = reader . read ( ) ; check hex digit ( c ) ; char num . append ( ( char ) c ) ; } int rv = integer . parse int ( char num . to string ( ) , num ) ; write ( rv ) ; num unicode escapes found += num + number of u ; num unicode escapes found on current line += num + number of u ; return rv ; }	gets the next character from the underlying reader , translating escapes as required .
public boolean is empty ( ) { if ( ! built ) return item boundables . is empty ( ) ; return root . is empty ( ) ; }	tests whether the index contains any items.
protected abstract writer ( writer w , document doc , int pos , int len ) { this . doc = doc ; it = new element iterator ( doc . get default root element ( ) ) ; out = w ; start offset = pos ; end offset = pos + len ; object doc newline = doc . get property ( default editor kit . end of line string property ) ; if ( doc newline instanceof string ) { set line separator ( ( string ) doc newline ) ; } else { string newline = null ; try { newline = system . get property ( str ) ; } catch ( security exception se ) { } if ( newline == null ) { newline = str ; } set line separator ( newline ) ; } can wrap lines = bool ; }	creates a new abstractwriter.
protected void adjust position y ( int velocity y ) { if ( reverse layout ) velocity y *= - num ; int child count = get child count ( ) ; if ( child count > num ) { int cur position = view utils . get center y ( this ) ; int child height = get height ( ) - get padding top ( ) - get padding bottom ( ) ; int fling count = get fling count ( velocity y , child height ) ; int target position = cur position + fling count ; if ( m single page fling ) { fling count = math . max ( - num , math . min ( num , fling count ) ) ; target position = fling count == num ? cur position : m position on touch down + fling count ; } target position = math . max ( target position , num ) ; target position = math . min ( target position , get item count ( ) - num ) ; if ( target position == cur position && ( ! m single page fling || m position on touch down == cur position ) ) { view center y = view utils . get center y ( this ) ; if ( center y != null ) { if ( m touch span > center y . get height ( ) * m trigger offset && target position != num ) { if ( ! reverse layout ) target position -- ; else target position ++ ; } else if ( m touch span < center y . get height ( ) * - m trigger offset && target position != get item count ( ) - num ) { if ( ! reverse layout ) target position ++ ; else target position -- ; } } } if ( debug ) { log . d ( str , str + m touch span ) ; log . d ( str , str + target position ) ; } smooth scroll to position ( safe target position ( target position , get item count ( ) ) ) ; } }	adjust position before touch event complete and fling action start .
@ override public node import to ( document host document ) { validate util . validate not null ( host document , str ) ; element cloned token element = ( element ) host document . import node ( parsed token . get document element ( ) , bool ) ; mark assertion id attribute ( cloned token element ) ; return cloned token element ; }	imports a copy of the xml representation of the token into the given document as a first child of the provided node < p > the copied token signature will remain valid if the original one was .
public static matrix random ( int m , int n ) { matrix a = new matrix ( m , n ) ; double [ ] [ ] x = a . get array ( ) ; for ( int i = num ; i < m ; i ++ ) { for ( int j = num ; j < n ; j ++ ) { x [ i ] [ j ] = math . random ( ) ; } } return a ; }	generate matrix with random elements.
public void add priority unit ( string id ) { if ( ! string util . is positive integer ( id ) ) { return ; } add priority unit ( integer . parse int ( id ) ) ; }	add an enemy unit to the priority list .
private void calc interval dis ( ) { if ( m mark text paint == null ) { return ; } string default text = str ; rect temp = new rect ( ) ; int max = num ; if ( m items != null && m items . size ( ) > num ) { for ( string i : m items ) { m mark text paint . get text bounds ( i , num , i . length ( ) , temp ) ; if ( temp . width ( ) > max ) { max = temp . width ( ) ; } } } else { m mark text paint . get text bounds ( default text , num , default text . length ( ) , temp ) ; max = temp . width ( ) ; } if ( ! text utils . is empty ( m addition center mark ) ) { m mark text paint . set text size ( m normal text size ) ; m mark text paint . get text bounds ( m addition center mark , num , m addition center mark . length ( ) , temp ) ; m addition center mark width = temp . width ( ) ; max += temp . width ( ) ; } m interval dis = max * m interval factor ; }	calculate interval distance between items.
public boolean is use softkeys ( ) { return use softkeys ; }	when set to true softkeys are used to enable delete functionality.
public void test division knuth first digits equal ( ) { byte a bytes [ ] = { num , - num , - num , - num , - num , - num , - num , - num , - num , - num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , - num , - num , - num , - num , - num , - num , - num } ; int a sign = - num ; int b sign = - num ; byte r bytes [ ] = { num , - num , - num , - num , - num , - num , - num , - num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . divide ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	verifies the case when the first digits of the dividend and divisor equal .
public void connection closed ( connection event event ) { if ( is active ) { managed connection conn = ( managed connection ) event . get source ( ) ; transaction manager impl trans manager = transaction manager impl . get transaction manager ( ) ; try { transaction txn = trans manager . get transaction ( ) ; if ( txn == null ) { mann pool cache . return pooled connection to pool ( conn ) ; } } catch ( exception se ) { string exception = str + se . get message ( ) ; if ( logger . is debug enabled ( ) ) { logger . debug ( exception , se ) ; } } } }	callback for connection closed .
public metadata block header ( boolean is last block , block type block type , int data length ) { byte buffer rawdata = byte buffer . allocate ( header length ) ; this . block type = block type ; this . is last block = is last block ; this . data length = data length ; byte type ; if ( is last block ) { type = ( byte ) ( num | block type . get id ( ) ) ; } else { type = ( byte ) block type . get id ( ) ; } rawdata . put ( type ) ; rawdata . put ( ( byte ) ( ( data length & num ) > > > num ) ) ; rawdata . put ( ( byte ) ( ( data length & num ) > > > num ) ) ; rawdata . put ( ( byte ) ( data length & num ) ) ; bytes = new byte [ header length ] ; for ( int i = num ; i < header length ; i ++ ) { bytes [ i ] = rawdata . get ( i ) ; } }	construct a new header in order to write metadatablock to file.
private void check file to run ( ) throws exit code exception { if ( run this file == null || ! run this file . exists ( ) ) { throw new exit code exception ( exitcode module to run not found ) ; } }	check if the file is there .
@ managed operation ( description = str ) public void notify all tag cache listeners ( ) { logger . info ( str ) ; for ( long key : control tag cache . get keys ( ) ) { control tag cache . acquire write lock on key ( key ) ; try { control tag control tag = control tag cache . get copy ( key ) ; long event time = system . current time millis ( ) ; control tag cache . notify listener status confirmation ( control tag , event time ) ; } finally { control tag cache . release write lock on key ( key ) ; } } for ( long key : data tag cache . get keys ( ) ) { data tag cache . acquire write lock on key ( key ) ; try { data tag data tag = data tag cache . get copy ( key ) ; long event time = system . current time millis ( ) ; data tag cache . notify listener status confirmation ( data tag , event time ) ; } finally { data tag cache . release write lock on key ( key ) ; } } logger . info ( str ) ; }	notifies all tag cache listeners with the confirmstatus notification , so that all listeners receive up to date notifications ( notice alarm cache listeners are notified as these are all re - evaluated , both via tag and supervision status notification ; the ruletag cache is also left out here , as all rules are refreshes through datatag and controltag status confirmations ) .
public static long [ ] breakdown ( long t , @ non null time unit unit , boolean round millis ) { long days = unit . to days ( t ) ; long hours = unit . to hours ( t ) % num ; long minutes = unit . to minutes ( t ) % num ; long seconds = unit . to seconds ( t ) % num ; long msecs = unit . to millis ( t ) % num ; if ( round millis ) { if ( msecs >= num ) { seconds ++ ; msecs = num ; if ( seconds == num ) { minutes ++ ; seconds = num ; if ( minutes == num ) { hours ++ ; minutes = num ; if ( hours == num ) { days ++ ; hours = num ; } } } } } return new long [ ] { days , hours , minutes , seconds , msecs } ; }	returns a breakdown of a given time into its values in hours , minutes , seconds and milliseconds .
private int socks get server port ( ) { inet socket address addr = ( inet socket address ) proxy . address ( ) ; return addr . get port ( ) ; }	gets the socks proxy server port .
public static < t > reactive seq < t > from list ( final list < t > list ) { objects . require non null ( list ) ; final reversing list spliterator array = new reversing list spliterator < t > ( list , bool ) ; return stream utils . reactive seq ( stream support . stream ( array , bool ) , optional . of nullable ( array ) ) ; }	construct a reactiveseq from a list ( prefer this method if the source is a list , as it allows more efficient stream reversal ) .
private boolean process key up ( int key code ) { if ( key code == key event . keycode del ) { if ( m in kb mode ) { if ( ! m typed times . is empty ( ) ) { int deleted = delete last typed key ( ) ; string deleted key str ; if ( deleted == get am or pm key code ( am ) ) { deleted key str = m am text ; } else if ( deleted == get am or pm key code ( pm ) ) { deleted key str = m pm text ; } else { deleted key str = string . format ( str , get val from key code ( deleted ) ) ; } view compat utils . announce for accessibility ( m delegator , string . format ( m deleted key format , deleted key str ) ) ; update display ( bool ) ; } } } else if ( key code == key event . keycode 0 || key code == key event . keycode 1 || key code == key event . keycode 2 || key code == key event . keycode 3 || key code == key event . keycode 4 || key code == key event . keycode 5 || key code == key event . keycode 6 || key code == key event . keycode 7 || key code == key event . keycode 8 || key code == key event . keycode 9 || ( ! m is24 hour view && ( key code == get am or pm key code ( am ) || key code == get am or pm key code ( pm ) ) ) ) { if ( ! m in kb mode ) { if ( m radial time picker view == null ) { log . e ( tag , str ) ; return bool ; } m typed times . clear ( ) ; try starting kb mode ( key code ) ; return bool ; } if ( add key if legal ( key code ) ) { update display ( bool ) ; } return bool ; } return bool ; }	for keyboard mode , processes key events .
public synchronized om prepare ( ) { om list = new om ( ) ; projection proj = get projection ( ) ; if ( proj == null ) { return list ; } d upper left = proj . get upper left ( ) ; d lower right = proj . get lower right ( ) ; if ( upper left . get x ( ) > lower right . get x ( ) ) { get points ( new data bounds ( upper left , new d . double ( num , lower right . get y ( ) ) ) , list , proj ) ; get points ( new data bounds ( new d . double ( - num , upper left . get y ( ) ) , lower right ) , list , proj ) ; } else { get points ( new data bounds ( upper left , lower right ) , list , proj ) ; } om statement = new om ( num , proj . get height ( ) - num , get name ( ) + str + list . size ( ) + str + data source . size ( ) + str , om . justify left ) ; statement . set fill paint ( color . gray ) ; statement . generate ( proj ) ; list . add ( num , statement ) ; return list ; }	this is an important layer method to override.
public x509 name ( vector oids , vector values ) { this ( oids , values , new x509 default entry converter ( ) ) ; }	takes two vectors one of the oids and the other of the values .
void next line ( ) { try { next line = current episode . read line ( ) ; while ( next line . equals ( str ) ) next line = current episode . read line ( ) ; } catch ( io | null pointer exception e ) { next line = null ; } }	move to the next line.
public jobs subset ( string [ ] job ids ) { final list < job > subset result = new array list < job > ( ) ; for ( string job id : job ids ) { job job = job map . get ( job id ) ; if ( job . is analysis ( ) ) { subset result . add ( job ) ; } } return new jobs ( subset result ) ; }	returns a subset of all of the defined jobs that are restricted by the jobids ( bean ids ) passed in.
public void add property change listener ( property change listener listener ) { list < property change listener > l = arrays . as list ( listener list . get listeners ( property change listener . class ) ) ; if ( ! l . contains ( listener ) ) { listener list . add ( property change listener . class , listener ) ; } }	add a listener for this pane ' s property change events.
public static byte [ ] from hex string ( string text ) { text = text . trim ( ) ; if ( text . length ( ) % num != num ) text = str + text ; int res len = text . length ( ) / num ; int lo nibble , hi nibble ; byte [ ] res = new byte [ res len ] ; for ( int i = num ; i < res len ; i ++ ) { int j = i << num ; hi nibble = char to nibble ( text . char at ( j ) ) ; lo nibble = char to nibble ( text . char at ( j + num ) ) ; if ( lo nibble == - num || hi nibble == - num ) return null ; res [ i ] = ( byte ) ( hi nibble << num | lo nibble ) ; } return res ; }	convert a string containing consecutive ( no inside whitespace ) hexadecimal digits into a corresponding byte array.
protected static double variance ( double [ ] s , double [ ] s s , double [ ] sum of weights ) { double var = num ; for ( int i = num ; i < s . length ; i ++ ) { if ( sum of weights [ i ] > num ) { var += single variance ( s [ i ] , s s [ i ] , sum of weights [ i ] ) ; } } return var ; }	computes variance for subsets .
public void write ( char sequence csq ) throws io { final int length = csq . length ( ) ; for ( int i = num ; i < length ; ) { char c = csq . char at ( i ++ ) ; if ( c < num ) { bytes [ index ] = ( byte ) c ; if ( ++ index >= bytes . length ) { flush buffer ( ) ; } } else { write ( c ) ; } } }	writes the specified character sequence .
public static boolean can resize ( list constraints ) { for ( iterator iter = constraints . iterator ( ) ; iter . has next ( ) ; ) { dock constraint dc = ( dock constraint ) iter . next ( ) ; if ( ! dc . can resize ( ) ) return bool ; } return bool ; }	determine property over a list of dockconstraint objects.
string read number ( string source , int ofs , string token , boolean adjacent ) { if ( adjacent ) { return source . substring ( ofs , ofs + token . length ( ) ) ; } int len = source . length ( ) ; for ( int i = ofs ; i < len ; i ++ ) { char ch = source . char at ( i ) ; if ( is numeric ( ch ) == bool ) { if ( i == num ) { return null ; } return source . substring ( ofs , i ) ; } } return source . substring ( ofs ) ; }	read the number . does not attempt to parse .
private vec feed forward ( vec input ) { vec x = input ; for ( int i = num ; i < ws . size ( ) ; i ++ ) { matrix w i = ws . get ( i ) ; vec b i = bs . get ( i ) ; vec a i = w i . multiply ( x ) ; a i . mutable add ( b i ) ; a i . apply function ( f ) ; x = a i ; } return x ; }	feeds an input through the network.
private boolean split wtrace other ( brd tracep found trace , collection < brd tracep > split pieces , array list < pla line int > intersecting lines , awtree find entry found entry ) { if ( found trace == this ) return bool ; boolean have trace split = bool ; for ( pla line int inter line : intersecting lines ) { if ( have trace split ) break ; int line no = found entry . shape index in object + num ; array list < brd tracep > curr split pieces = found trace . split with end line ( line no , inter line ) ; if ( curr split pieces . size ( ) < num ) continue ; have trace split = bool ; split pieces . add all ( curr split pieces ) ; } if ( ! have trace split ) split pieces . add ( found trace ) ; return have trace split ; }	return true if some other trace was split.
private void print solution ( solution solution ) { if ( include variables ) { for ( int i = num ; i < solution . get number of variables ( ) ; i ++ ) { if ( i > num ) { writer . print ( str ) ; } writer . print ( encode ( solution . get variable ( i ) ) ) ; } } for ( int i = num ; i < solution . get number of objectives ( ) ; i ++ ) { if ( ( i > num ) || ( include variables && ( solution . get number of variables ( ) > num ) ) ) { writer . print ( str ) ; } writer . print ( solution . get objective ( i ) ) ; } writer . println ( ) ; }	prints the solution to the result file .
public void read nbt ( nbt nbt ) { if ( nbt . has key ( str , num ) ) { this . decay level = nbt . get integer ( str ) ; this . decay saturation level = nbt . get float ( str ) ; this . decay acceleration level = nbt . get float ( str ) ; } }	reads the decay stats from nbt.
public void copy to ( position texture vertex [ ] verts , textured quad [ ] quad ) { textured polygon [ ] poly = new textured polygon [ quad . length ] ; for ( int idx = num ; idx < quad . length ; idx ++ ) { poly [ idx ] = new textured polygon ( ( position texture vertex [ ] ) quad [ idx ] . vertex positions ) ; } copy to ( verts , poly ) ; }	copies an array of vertices and quads to the current shape.
public synchronized void delete observer ( observer observer ) { observers . remove ( observer ) ; }	removes the specified observer from the list of observers.
public account attribute as account attribute ( account account ) { if ( account == null ) { return null ; } account attribute who = new account attribute ( ) ; who . name = account . get full name ( ) ; who . email = account . get preferred email ( ) ; who . username = account . get user name ( ) ; return who ; }	create an authorattribute for the given account suitable for serialization to json .
public void delete ( template persistence data data ) { if ( data . is user added ( ) ) f templates . remove ( data ) ; else data . set deleted ( bool ) ; }	removes a template from the store .
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str + str + str + str , str , num , str ) ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str + str + str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str + str + str + str + str + str + str , str , num , str ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public string consume word ( ) { int start = pos ; while ( matches word ( ) ) pos ++ ; return queue . substring ( start , pos ) ; }	retrieves the next run of word type ( letter or digit ) off the queue .
public static void print inlining ( final resolved java method method , final int bci , final int inlining depth , final boolean success , final string msg , final object ... args ) { if ( hot spot print inlining . get value ( ) ) { string builder sb = new string builder ( ) ; sb . append ( str ) ; sb . append ( str ) ; sb . append ( string . format ( str , str , method . is synchronized ( ) ? str : str , str , str , method . is native ( ) ? str : str ) ) ; sb . append ( str ) ; sb . append ( str ) ; for ( int i = num ; i < inlining depth ; i ++ ) { sb . append ( str ) ; } sb . append ( string . format ( str , bci , method name ( method ) , success ? str : str , string . format ( msg , args ) ) ) ; tty . println ( sb . to string ( ) ) ; } }	print a hotspot - style inlining message to the console .
public static double calculate p ( double t , int v ) { return num * ( num - t . cdf ( math . abs ( t ) , v ) ) ; }	calculates the two - sided p - value of the underlying t - distribution with v degrees of freedom.
public static void append child ( node parent , node child ) { document owner doc = get owner document ( parent ) ; if ( child . get owner document ( ) != owner doc ) { parent . append child ( owner doc . import node ( child , bool ) ) ; } else { parent . append child ( child ) ; } }	checks if child element has same owner document before appending to the parent , and imports it to the parent ' s document if necessary .
@ suppress lint ( str ) private void prune scrap views ( ) { final int max views = m active views . length ; final int view type count = m view type count ; final array list < view > [ ] scrap views = m scrap views ; for ( int i = num ; i < view type count ; ++ i ) { final array list < view > scrap pile = scrap views [ i ] ; int size = scrap pile . size ( ) ; final int extras = size - max views ; size -- ; for ( int j = num ; j < extras ; j ++ ) { remove detached view ( scrap pile . remove ( size -- ) , bool ) ; } } if ( m transient state views != null ) { for ( int i = num ; i < m transient state views . size ( ) ; i ++ ) { final view v = m transient state views . value at ( i ) ; if ( ! v . has transient state ( ) ) { m transient state views . remove at ( i ) ; i -- ; } } } }	makes sure that the size of mscrapviews does not exceed the size of mactiveviews.
private void update work amount ( double work time ) { if ( work time <= num ) { current work amount *= num ; } else { total time taken += work time ; completed work amount += current work amount ; current work amount = ( int ) math . ceil ( target execution ms * completed work amount / total time taken ) ; } }	update the currentworkamount based upon the worktime it took to run the last command so running the worker will take ~ targetexecutionms .
public static boolean is laf aqua ( ) { ensure valid cache ( ) ; if ( cached is laf aqua == null ) { cached is laf aqua = boolean . value of ( compute is laf aqua ( ) ) ; } return cached is laf aqua . boolean value ( ) ; }	lazily checks and answers whether the aqua look & amp ; feel is active .
public void move randomly ( ) { set random path from ( get x ( ) , get y ( ) , get movement range ( ) / num ) ; }	give npc a random path.
public void pln i ( object o ) throws io { p ( o . to string ( ) ) ; pln ( ) ; p i ( ) ; }	writes object ; ends current line ; indents in .
@ override public void write entity to nbt ( nbt par1 nbt ) { par1 nbt . set short ( str , ( short ) this . x tile ) ; par1 nbt . set short ( str , ( short ) this . y tile ) ; par1 nbt . set short ( str , ( short ) this . z tile ) ; par1 nbt . set integer ( str , block . get id from block ( this . in tile ) ) ; par1 nbt . set byte ( str , ( byte ) this . in data ) ; par1 nbt . set byte ( str , ( byte ) this . arrow shake ) ; par1 nbt . set byte ( str , ( byte ) ( this . in ground ? num : num ) ) ; par1 nbt . set boolean ( str , this . is explosive ) ; }	( abstract ) protected helper method to write subclass entity data to nbt .
@ override public string buffer format ( final double value , final string buffer buffer , final field position position ) { return format ( double . value of ( value ) , buffer , position ) ; }	formats a double value as a fraction and appends the result to a stringbuffer .
private object translate stream to input stream ( input stream str , data flavor flavor , long format , transferable locale transferable ) throws io { if ( is flavor charset text type ( flavor ) && is text format ( format ) ) { str = new reencoding input stream ( str , format , data transferer . get text charset ( flavor ) , locale transferable ) ; } return construct flavored object ( str , flavor , input stream . class ) ; }	for arbitrary flavors , just use the raw inputstream.
private boolean is ipt ( file dir ) { if ( dir . exists ( ) && dir . is directory ( ) ) { file persistence file = new file ( dir , persistence file ) ; file eml file = new file ( dir , data dir . eml xml filename ) ; return persistence file . is file ( ) && eml file . is file ( ) ; } return bool ; }	determine whether the directory represents an ipt resource directory or not.
public set < string > add sprite frames ( string plist , cc d texture ) { hash map < string , object > dict = plist parser . parse ( plist ) ; return add sprite frames ( dict , texture ) ; }	adds multiple sprite frames from a plist file.
public void add annotation ( final annotation annotation ) { annotation list . add ( annotation ) ; annotation . setxy graph ( xy graph ) ; add ( annotation ) ; revalidate ( ) ; change support . fire property change ( str , null , annotation ) ; }	add an annotation to the plot area .
public static void create overviews ( as config ) throws compiler exception { string templates path = config . get templates path ( ) ; string dita path = config . get output ( ) + str + file . separator ; buffered writer writer = null ; reader reader = null ; try { writer = new buffered writer ( new file writer ( dita path + str ) ) ; if ( config . get package description file ( ) != null ) { reader = new buffered reader ( new file reader ( config . get package description file ( ) ) ) ; } else { reader = new buffered reader ( new file reader ( templates path + str ) ) ; } overviews handler h = new overviews handler ( writer , config ) ; input source source = new input source ( reader ) ; sax factory = sax . new instance ( ) ; sax parser = factory . new sax ( ) ; parser . parse ( source , h ) ; } catch ( exception e ) { if ( trace . error ) e . print stack trace ( ) ; compiler message c = new could not create ( str , e . get message ( ) ) ; thread local toolkit . log ( c ) ; throw c ; } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( io ioe ) { } } if ( reader != null ) { try { reader . close ( ) ; } catch ( io ioe ) { } } } }	reads the overviews_base . xml from the templates folder and creates a temporary overviews . xml in the output folder.
public create new note intent builder add tags ( @ nullable array list < string > tags ) { array list < string > list = m args . get string array list ( evernote intent . extra tag name list ) ; if ( list == null ) { list = tags ; } else if ( tags != null ) { list . add all ( tags ) ; } return set tags ( list ) ; }	adds more tags . any existing tags aren ' t overwritten .
private remote operation result refresh shares for folder ( own cloud client client ) { remote operation result result = null ; get remote shares for file operation operation = new get remote shares for file operation ( m local folder . get remote path ( ) , bool , bool ) ; result = operation . execute ( client ) ; if ( result . is success ( ) ) { array list < oc > shares = new array list < oc > ( ) ; for ( object obj : result . get data ( ) ) { shares . add ( ( oc ) obj ) ; } m storage manager . save shares in folder ( shares , m local folder ) ; } return result ; }	syncs the share resources for the files contained in the folder refreshed ( children , not deeper descendants ) .
public double dist ( math vector other ) { double dist x = this . x - other . x ; double dist y = this . y - other . y ; return math . sqrt ( dist x * dist x + dist y * dist y ) ; }	calculate each vector ' s distance.
public static string parse string ( string value ) { if ( ( value . starts with ( str ) ) && ( value . ends with ( str ) ) || ( value . starts with ( str ) ) && ( value . ends with ( str ) ) ) { if ( value . length ( ) > num ) { if ( value . index of ( str ) != - num ) { return unescape ( value . substring ( num , value . length ( ) - num ) ) ; } return value . substring ( num , value . length ( ) - num ) ; } } throw new illegal argument exception ( str + value + str ) ; }	parse the string literal consisting of text between double - quotes or single - quotes .
private void define desktop panes ( ui d ) { d . put ( str , new ui ( num ) ) ; string c = painter prefix + str ; string p = str ; d . put ( p + str , new lazy painter ( c , desktop pane painter . which . background enabled ) ) ; p = str ; c = painter prefix + str ; d . put ( p + str , new ui ( num , num , num , num ) ) ; d . put ( p + str , new lazy painter ( c , desktop icon painter . which . background enabled ) ) ; }	initialize the desktop pane ui settings .
object animator animate bound scroll ( ) { float cur scroll = get stack scroll ( ) ; float new scroll = get bounded stack scroll ( cur scroll ) ; if ( float . compare ( new scroll , cur scroll ) != num ) { animate scroll ( cur scroll , new scroll , null ) ; } return m scroll animator ; }	animates the stack scroll into bounds.
public int array resize ( int array array , long size ) { if ( array instanceof big int array ) { return resize in place ( ( big int array ) array , size ) ; } else { abstract array arr = ( abstract array ) array ; final int array new array = new int array ( size , arr . clear on resize ) ; for ( long i = num , end = math . min ( size , array . size ( ) ) ; i < end ; ++ i ) { new array . set ( i , array . get ( i ) ) ; } array . close ( ) ; return new array ; } }	resize the array to the exact provided size .
public static double pdf ( double x , double mu , double beta ) { final double z = ( x - mu ) / beta ; if ( x == double . negative infinity ) { return num ; } return math . exp ( - z - math . exp ( - z ) ) / beta ; }	pdf of gumbel distribution.
private static byte [ ] copy buffer ( byte [ ] buffer , int s offset , int len ) { byte [ ] new data = new byte [ len ] ; system . arraycopy ( buffer , s offset , new data , num , len ) ; return new data ; }	wrapped system function arraycopy.
public shared fs checkpoint spi ( ) { dir paths . offer ( dflt dir path ) ; }	initializes default directory paths .
public void pull ( final pull params params , final progress monitor progress monitor ) throws io { pull ( params , progress monitor , docker daemon uri ) ; }	pulls docker image from registry .
public boolean is alive ( ) { if ( has sent data ) { if ( system . current time millis ( ) - last send time < timeout ) return bool ; return has received data && last receive time > last send time ; } return bool ; }	calculates whether this peer is alive : the peer is alive when the peer hasn ' t send data yet , or when data is received within the timeout after sending data .
private void remove selected items ( list items ) { for ( iterator iter = items . iterator ( ) ; iter . has next ( ) ; ) { object item = iter . next ( ) ; remove history item ( item ) ; } refresh with last selection = bool ; content provider . refresh ( ) ; }	removes selected items from history .
public static < k , v > map < k , v > of ( k k1 , v v1 , k k2 , v v2 , k k3 , v v3 , k k4 , v v4 ) { map map = of ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; map . put ( k3 , v3 ) ; map . put ( k4 , v4 ) ; return map ; }	returns map containing the given entries .
public static void disable connection reuse if necessary ( ) { if ( build . version . sdk int < build . version codes . froyo ) { system . set property ( str , str ) ; } }	workaround for bug pre - froyo , see here for more info : http : / / android - developers.
public static long size of ( struct sct ) { iterator < entry < key , object > > it = sct . entry iterator ( ) ; entry < key , object > e ; long size = num ; while ( it . has next ( ) ) { e = it . next ( ) ; size += size of . size ( e . get key ( ) ) ; size += size of . size ( e . get value ( ) ) ; } return size ; }	return the size of given struct , size of values + keys.
@ override public boolean is enabled ( ) { if ( ( attribute selection panel != null ) && ! is value only ( ) ) { return attribute selection panel . is enabled ( ) ; } else { if ( table != null ) { return table . is enabled ( ) ; } } return bool ; }	checks if is enabled .
@ override public boolean is factory for type ( object type ) { return supported types . contains ( type ) || super . is factory for type ( type ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
public void read content ( byte [ ] dst , int offset , int length ) { system . arraycopy ( content , num , dst , offset , length ) ; }	reads this request ' s content into the destination buffer .
public static void put object field ( object obj , long field off , object val ) { unsafe . put object ( obj , field off , val ) ; }	stores reference value into object field .
public void on configuration changed ( ) { int cur first = pager . get current screen ( ) * page size ; cal page size ( ) ; int new page = cur first / page size ; remove view at ( num ) ; after platform list got ( ) ; pager . set current screen ( new page ) ; }	after the screen rotates , this method will be called to refresh the list of gridviews.
public list < function desc > list all functions ( ) { list < function desc > functions = new array list < function desc > ( ) ; for ( measure desc m : measures ) { functions . add ( m . get function ( ) ) ; } return functions ; }	get all functions from each measure .
public boolean has explicit field ( string field name ) { if ( fields . contains key ( field name ) ) { return bool ; } for ( dynamic field df : dynamic fields ) { if ( field name . equals ( df . get regex ( ) ) ) return bool ; } return bool ; }	does the schema explicitly define the specified field , i.
private static boolean instance of any ( object o , collection < class > classes ) { for ( class c : classes ) { if ( c . is instance ( o ) ) return bool ; } return bool ; }	returns true if the object ' o ' is an instance of any class in the collection.
public static i new setter attribute proposal computer ( content assist request content assist request , i java project ) { idom node = ( idom ) content assist request . get node ( ) ; if ( node . get node type ( ) != idom . element node ) { return null ; } string widget type name = ui binder xml model utilities . compute qualified widget type name ( node ) ; if ( widget type name == null ) { return null ; } string match string = content assist request . get match string ( ) ; return new setter attribute proposal computer ( node , widget type name , java project , match string , content assist request . get replacement begin position ( ) , match string . length ( ) ) ; }	creates a proposal computer for widget attributes based on existing type setter methods .
public void omit all ( ) { if ( write chunk != null ) bytes written += write chunk . position ( ) ; bytes read = bytes written ; list . clear ( ) ; write chunk = null ; read chunk = null ; }	clears queue and moves read pointer to written pointer .
job load preview ( future callback < pair < omni build environment , omni gradle build > > result handler , list < progress listener > listeners ) ;	loads the gradle project data required to populate the preview page .
private void refresh ( i configuration ) { set launch configuration ( configuration ) ; try { f model = create classpath model ( configuration ) ; } catch ( exception e ) { message = e . get message ( ) ; set error message ( e . get message ( ) ) ; } f classpath viewer . set launch configuration ( configuration ) ; f classpath viewer . set input ( f model ) ; set dirty ( bool ) ; }	refreshes the classpath entries based on the current state of the given launch configuration .
public void compute package fragment roots ( i [ ] resolved classpath , object vector accumulated roots , hash set root i , i referring entry , boolean retrieve exported roots , map root to resolved entries ) throws java model exception { if ( referring entry == null ) { root i . add ( root id ( ) ) ; } for ( int i = num , length = resolved classpath . length ; i < length ; i ++ ) { compute package fragment roots ( resolved classpath [ i ] , accumulated roots , root i , referring entry , retrieve exported roots , root to resolved entries ) ; } }	returns ( local / all ) the package fragment roots identified by the given project ' s classpath.
private void init ( ) { set title ( str ) ; som panel = new som ( network panel , som . create group ) ; tab logic . add ( som panel ) ; layout panel = new main layout panel ( bool , this ) ; layout panel . set current layout ( som . default layout ) ; tab layout . add ( layout panel ) ; tabbed pane . add tab ( str , tab logic ) ; tabbed pane . add tab ( str , layout panel ) ; set content pane ( tabbed pane ) ; action help action = new show help action ( som panel . get help path ( ) ) ; add button ( new j ( help action ) ) ; }	initializes all components used in dialog .
private string diff lines to chars munge ( string text , list < string > line array , map < string , integer > line hash ) { int line start = num ; int line end = - num ; string line ; string builder chars = new string builder ( ) ; while ( line end < text . length ( ) - num ) { line end = text . index of ( str , line start ) ; if ( line end == - num ) { line end = text . length ( ) - num ; } line = text . substring ( line start , line end + num ) ; line start = line end + num ; if ( line hash . contains key ( line ) ) { chars . append ( string . value of ( ( char ) ( int ) line hash . get ( line ) ) ) ; } else { line array . add ( line ) ; line hash . put ( line , line array . size ( ) - num ) ; chars . append ( string . value of ( ( char ) ( line array . size ( ) - num ) ) ) ; } } return chars . to string ( ) ; }	split a text into a list of strings.
public void remove ( video video ) { video list . remove ( video ) ; notify data set changed ( ) ; }	removes a video from the adapter and notify the change .
public boolean can invert ( ) { return bool ; }	xbee turnouts do support inversion.
public void add all searchables ( array list < ? extends search result > searchable ) { searchables . add all ( searchable ) ; }	add all searchable items.
public static string to string ( final iterable < ? > iterable ) { if ( iterable instanceof collection ) { return iterable . to string ( ) ; } else { final string builder builder = new string builder ( ) ; boolean first value = bool ; builder . append ( str ) ; for ( final object value : iterable ) { if ( ! first value ) { builder . append ( str ) ; } builder . append ( value ) ; first value = bool ; } builder . append ( str ) ; return builder . to string ( ) ; } }	returns a string representation of the provided iterable composed of an opening square bracket , followed by each element separated by commas , and then a closing square bracket .
public static int parse int ( string text ) { return parse int ( text , num ) ; }	parse a string to an int , returning 0 if it ' s not parsable .
@ override public void end document ( augmentations augs ) throws xni { try { if ( f document handler != null ) { f document handler . end document ( ) ; } if ( f content handler != null ) { f content handler . end document ( ) ; } } catch ( sax e ) { throw new xni ( e ) ; } }	the end of the document .
public string exec command ( string command ) { string builder buf = new string builder ( ) ; send wait for ( command , default timeout , prompts , buf ) ; log . debug ( buf . to string ( ) ) ; return clean output ( buf ) ; }	expectation here is that the command is less than 80 characters and is terminated by new line !.
private void client thread run ( ) throws io { socket channel channel = null ; try { log . debug ( str , hostname , port , pending . size ( ) ) ; channel = socket channel . open ( new inet socket address ( hostname , port ) ) ; channel . configure blocking ( bool ) ; client thread main loop ( channel ) ; } finally { if ( channel != null ) { channel . close ( ) ; } if ( current != null ) { pending . offer first ( current ) ; current = null ; } } }	establishes a connection to the server , then runs the client thread main loop returns if connection fails or if the connection is interrupted.
@ override public path impl scheme walk ( string user path , map < string , object > new attributes , string uri , int offset ) { int length = uri . length ( ) ; if ( length < num + offset || uri . char at ( offset ) != str || uri . char at ( num + offset ) != str ) throw new runtime exception ( str ) ; char buffer buf = new char buffer ( ) ; int i = num + offset ; int ch = num ; boolean is ipv6 = bool ; for ( ; ( i < length && ( ch = uri . char at ( i ) ) != str && ch != str && ! ( ch == str && ! is ipv6 ) ) ; i ++ ) { if ( ch == str ) is ipv6 = bool ; else if ( ch == str ) is ipv6 = bool ; buf . append ( ( char ) ch ) ; } string host = buf . to string ( ) ; if ( host . length ( ) == num ) throw new runtime exception ( str ) ; int port = num ; if ( ch == str ) { for ( i ++ ; i < length && ( ch = uri . char at ( i ) ) >= str && ch <= str ; i ++ ) { port = num * port + uri . char at ( i ) - str ; } } return create ( this , user path , new attributes , host , port ) ; }	lookup the new path assuming we ' re the scheme root .
@ request mapping ( value = str ) public void sso default tenant binding error ( locale locale , http servlet response response ) throws io { logger . info ( str + locale . to string ( ) + str ) ; send error ( locale , response , str ) ; }	handle default tenant request sent with a wrong binding.
@ override public void on can start video service changed ( boolean can start video service ) { log . i ( str , str + string . value of ( can start video service ) ) ; if ( can start video service == bool ) { m conversation helper . start outgoing video ( ) ; m conversation helper . start incoming video ( ) ; } }	called when the video service on the established conversation can be started.
public manifest ( input stream is ) throws io { while ( is . available ( ) != num ) { message header m = new message header ( is ) ; entries . add element ( m ) ; } }	parse a manifest from a stream.
@ override public object read reply ( class expected class ) throws throwable { int tag = read ( ) ; if ( tag == str ) return read object ( expected class ) ; else if ( tag == str ) { hash map map = ( hash map ) read object ( hash map . class ) ; throw prepare fault ( map ) ; } else { string builder sb = new string builder ( ) ; sb . append ( ( char ) tag ) ; try { int ch ; while ( ( ch = read ( ) ) >= num ) { sb . append ( ( char ) ch ) ; } } catch ( io e ) { log . log ( level . fine , e . to string ( ) , e ) ; } throw error ( str + code name ( tag ) + str + sb ) ; } }	reads a reply as an object.
public static string unexpand line ( char sequence self , int tab stop ) { string builder builder = new string builder ( self . to string ( ) ) ; int index = num ; while ( index + tab stop < builder . length ( ) ) { string piece = builder . substring ( index , index + tab stop ) ; int count = num ; while ( ( count < tab stop ) && ( character . is whitespace ( piece . char at ( tab stop - ( count + num ) ) ) ) ) count ++ ; if ( count > num ) { piece = piece . substring ( num , tab stop - count ) + str ; builder . replace ( index , index + tab stop , piece ) ; index = index + tab stop - ( count - num ) ; } else index = index + tab stop ; } return builder . to string ( ) ; }	replaces sequences of whitespaces with tabs within a line .
private void uninstall ( string row type ) { if ( extensions by rowtype . contains key ( row type ) ) { extensions by rowtype . remove ( row type ) ; file f = get extension file ( row type ) ; if ( f . exists ( ) ) { file utils . delete quietly ( f ) ; } else { log . warn ( str + row type ) ; } } else { log . warn ( str + row type ) ; } }	uninstall extension by its unique rowtype .
public void add property change listener ( string property name , property change listener in pcl ) { pc support . add property change listener ( property name , in pcl ) ; }	method for beancontextchild interface .
static final int table size for ( int cap ) { int n = cap - num ; n |= n > > > num ; n |= n > > > num ; n |= n > > > num ; n |= n > > > num ; n |= n > > > num ; return ( n < num ) ? num : ( n >= maximum capacity ) ? maximum capacity : n + num ; }	returns a power of two size for the given target capacity .
@ override public boolean connection allowed ( string event name ) { if ( ! event name . equals ( str ) && ! event name . equals ( str ) && ! event name . equals ( str ) && ! event name . equals ( str ) ) { return bool ; } if ( m listenee != null ) { return bool ; } return bool ; }	returns true if , at this time , the object will accept a connection via the named event.
protected void generate om ( om g ) { if ( g != null && g . get need to regenerate ( ) ) { projection proj = get projection ( ) ; if ( proj != null ) { g . generate ( proj ) ; } else if ( debug ) { debug . output ( str + g . get need to regenerate ( ) ) ; } } }	if the projection is not null , generate the omgraphic .
public void insert variable ( ) { script step variable step = script step factory . create variable ( get variable key ( ) , get variable value ( ) ) ; steps . add ( get insert index ( ) , variable step ) ; variable key = str ; variable value = str ; reindex script steps ( ) ; }	does something to insert a variable request into the script .
protected boolean [ ] can handle zero training ( boolean nominal predictor , boolean numeric predictor , boolean string predictor , boolean date predictor , boolean relational predictor , boolean multi instance , int class type ) { print ( str ) ; print attribute summary ( nominal predictor , numeric predictor , string predictor , date predictor , relational predictor , multi instance , class type ) ; print ( str ) ; array list < string > accepts = new array list < string > ( ) ; accepts . add ( str ) ; accepts . add ( str ) ; int num train = num , num test = get num instances ( ) , num classes = num , missing level = num ; boolean predictor missing = bool , class missing = bool ; return run basic test ( nominal predictor , numeric predictor , string predictor , date predictor , relational predictor , multi instance , class type , missing level , predictor missing , class missing , num train , num test , num classes , accepts ) ; }	checks whether the scheme can handle zero training instances .
public static byte [ ] long2buff ( long n ) { byte [ ] bs ; bs = new byte [ num ] ; bs [ num ] = ( byte ) ( ( n > > num ) & num ) ; bs [ num ] = ( byte ) ( ( n > > num ) & num ) ; bs [ num ] = ( byte ) ( ( n > > num ) & num ) ; bs [ num ] = ( byte ) ( ( n > > num ) & num ) ; bs [ num ] = ( byte ) ( ( n > > num ) & num ) ; bs [ num ] = ( byte ) ( ( n > > num ) & num ) ; bs [ num ] = ( byte ) ( ( n > > num ) & num ) ; bs [ num ] = ( byte ) ( n & num ) ; return bs ; }	long convert to buff ( big - endian ).
final boolean try write lock ( ) { thread current = thread . current thread ( ) ; int c = get state ( ) ; if ( c != num ) { int w = exclusive count ( c ) ; if ( w == num || current != get exclusive owner thread ( ) ) return bool ; if ( w == max count ) throw new error ( str ) ; } if ( ! compare and set state ( c , c + num ) ) return bool ; set exclusive owner thread ( current ) ; return bool ; }	performs trylock for write , enabling barging in both modes.
public io service listener support ( io service service ) { if ( service == null ) { throw new illegal argument exception ( str ) ; } this . service = service ; }	creates a new instance of the listenersupport .
private void cancel event lease do ( long event id , uuid lease id ) throws unknown lease exception { long now = system . current time millis ( ) ; event reg reg = ( event reg ) event by id . get ( new long ( event id ) ) ; if ( reg == null || reg . lease expiration <= now ) throw new unknown lease exception ( ) ; delete event ( reg ) ; if ( reg . lease expiration == min event expiration ) concurrent obj . waiter notify ( event notifier ) ; }	the code that does the real work of canceleventlease .
public static boolean is valid g ( string value ) { string regex = str ; if ( value . matches ( regex ) ) { return is valid calendar value ( value ) ; } else { return bool ; } }	determines if the supplied value is a valid xsd : gday string .
protected void paint3 d ( d g2 , int x , int y , int width , int height ) { g2 . set color ( color . white ) ; g2 . draw line ( x + num , y + num , x + num , y + height - num ) ; g2 . draw line ( x + num , y + num , x + width - num , y + num ) ; g2 . set color ( color . gray ) ; g2 . draw line ( x + num , y + height - num , x + width - num , y + height - num ) ; g2 . draw line ( x + width - num , y + num , x + width - num , y + height - num ) ; g2 . set color ( color . dark gray ) ; g2 . draw line ( x , y + height , x + width , y + height ) ; g2 . draw line ( x + width , y , x + width , y + height ) ; }	adds windows2k type 3d lighting effects.
@ deprecated public media file ( file f , media file type type ) { this ( f . to path ( ) , type ) ; }	instantiates a new media file .
public command line clear ( ) { line . clear ( ) ; return this ; }	removes all command line arguments .
public static string grep minus v ( string val , string pattern ) { return grep inner ( val , pattern , bool ) ; }	like grep - v , but in java.
public drop down popup button builder add ( action action ) { popup menu . add ( action ) ; return this ; }	adds an action to the popup menu that is displayed when the button is clicked .
@ suppress lint ( str ) private void attach image fromm gallery ( ) { bundle con data = new bundle ( ) ; intent intent = new intent ( ) ; if ( ( m selected gallery items list . size ( ) == num ) || ( build . version . sdk int < build . version codes . jelly bean m ) ) { intent . set data ( m selected gallery items list . get ( num ) . m file uri ) ; } else if ( m selected gallery items list . size ( ) > num ) { clip data . item first uri = new clip data . item ( null , null , null , m selected gallery items list . get ( num ) . m file uri ) ; string [ ] mime type = { str } ; clip data clip data = new clip data ( str , mime type , first uri ) ; for ( int index = num ; index < m selected gallery items list . size ( ) ; index ++ ) { clip data . item item = new clip data . item ( null , null , null , m selected gallery items list . get ( index ) . m file uri ) ; clip data . add item ( item ) ; } intent . set clip data ( clip data ) ; } else { uri uri saved from life cycle = ( uri ) m image preview image view . get tag ( ) ; if ( null != uri saved from life cycle ) { intent . set data ( uri saved from life cycle ) ; } } intent . put extras ( con data ) ; set result ( result ok , intent ) ; vector app . set saved camera image preview ( null ) ; finish ( ) ; }	return the taken image from the gallery to the calling activity.
public static void mkdirs ( file directory ) throws create directory exception { if ( directory . exists ( ) ) { if ( directory . is directory ( ) ) { return ; } if ( ! directory . delete ( ) ) { throw new create directory exception ( directory . get absolute path ( ) , new file delete exception ( directory . get absolute path ( ) ) ) ; } } if ( ! directory . mkdirs ( ) && ! directory . is directory ( ) ) { throw new create directory exception ( directory . get absolute path ( ) ) ; } }	creates the specified directory , along with all parent paths if necessary.
public boolean has dependency ( capability c ) { if ( do not check capabilities ( ) ) { return bool ; } return m . contains ( c ) ; }	returns true if the classifier handler has a dependency for the specified capability.
private static int prefix len ( string o1 , string o2 ) { final int l1 = o1 . length ( ) , l2 = o2 . length ( ) , l = l1 < l2 ? l1 : l2 ; int prefix = num ; while ( prefix < l && ( o1 . char at ( prefix ) == o2 . char at ( prefix ) ) ) { prefix ++ ; } return prefix ; }	compute the length of the prefix .
@ override public void write external ( object output out ) throws io { super . write external ( out ) ; out . write double ( parent distance ) ; }	calls the super method and writes the parentdistance of this entry to the specified stream .
public named thread factory ( final string pool id ) { id = pool id ; }	create a new thread factory , using the specified pool id as a basis for naming each thread .
public void move location up ( route location rl ) { int sequence id = rl . get sequence id ( ) ; if ( sequence id - num <= num ) { rl . set sequence id ( sequence num + num ) ; resequence ids ( ) ; } else { route location replace rl = get item by sequence id ( sequence id - num ) ; if ( replace rl != null ) { replace rl . set sequence id ( sequence id ) ; rl . set sequence id ( sequence id - num ) ; } else { resequence ids ( ) ; } } set dirty and fire property change ( listchange changed property , null , integer . to string ( sequence id ) ) ; }	places a routelocation earlier in the route .
public static string print canopy assignments ( instances data points , list < long [ ] > canopy assignments ) { string builder temp = new string builder ( ) ; for ( int i = num ; i < data points . size ( ) ; i ++ ) { temp . append ( str + i + str ) ; temp . append ( data points . instance ( i ) ) ; if ( canopy assignments != null && canopy assignments . size ( ) == data points . size ( ) ) { long [ ] assignments = canopy assignments . get ( i ) ; temp . append ( print single assignment ( assignments ) ) ; } temp . append ( str ) ; } return temp . to string ( ) ; }	print the supplied instances and their canopies.
public static void register default prefixes ( ) throws xml { set default prefix ( str , str ) ; set default prefix ( str , str ) ; set default prefix ( str , str ) ; set default prefix ( str , str ) ; set default prefix ( str , str ) ; set default prefix ( str , str ) ; set default prefix ( str , str ) ; set default prefix ( str , str ) ; }	this method registers the default prefixes .
protected void init bp ( int c b id , boolean for invoice ) { log . config ( str + c b id ) ; key name pair pp = new key name pair ( num , str ) ; order field . remove action listener ( this ) ; order field . remove all items ( ) ; order field . add item ( pp ) ; array list < key name pair > list = load order data ( c b id , for invoice , bool ) ; for ( key name pair knp : list ) order field . add item ( knp ) ; order field . set selected index ( num ) ; order field . add action listener ( this ) ; dialog . pack ( ) ; init bp ( c b id ) ; }	load pbartner dependent order / invoice / shipment field .
private void write toc ( byte buffer data file buffer , toc type toc type , int entry count , int first entry offset ) { data file buffer . put int ( toc type . identifier ) ; data file buffer . put int ( entry count ) ; data file buffer . put long ( first entry offset ) ; }	writes out a pcp mmv table - of - contents block .
public void start part ( string content type , string [ ] headers ) throws io { write current boundary ( ) ; if ( content type != null ) { write string ( mime utils . header content type + str + content type ) ; out . write ( crlf ) ; } for ( int i = num ; headers != null && i < headers . length ; i ++ ) { write string ( headers [ i ] ) ; out . write ( crlf ) ; } out . write ( crlf ) ; }	starts new mime part.
public embedded meta service ( ) throws io , execution exception { this ( system . getenv ( jolie home env ) ) ; }	creates an embedded metaservice instance , executing a jolie interpreter in the local jvm .
public int show dialog ( ) { m = cancel option ; int [ ] orig selected = m . get selected indices ( ) ; set visible ( bool ) ; if ( m == cancel option ) { m . set selected indices ( orig selected ) ; } return m ; }	pops up the modal dialog and waits for cancel or a selection .
public final void add alarm values ( final list < alarm value impl > alarm values ) { if ( alarm values != null ) { for ( alarm value impl alarm value : alarm values ) { if ( alarm value != null ) { add alarm value ( alarm value ) ; } } } }	adds the given alarm values to the transfer tag , except if an alarm with the same id id already present or , if the alarm values do not belong to the specified tag .
public string product ( properties ctx , int window no , grid tab m tab , grid field m field , object value ) { integer m id = ( integer ) value ; if ( m id == null || m id . int value ( ) == num ) return str ; if ( env . get context as int ( ctx , window no , env . tab info , str ) == m id . int value ( ) && env . get context as int ( ctx , window no , env . tab info , str ) != num ) m tab . set value ( str , env . get context as int ( ctx , window no , env . tab info , str ) ) ; else m tab . set value ( str , null ) ; check qty available ( ctx , m tab , window no , m id , null ) ; return str ; }	product modified set attribute set instance.
protected void processpacket ( sim event ev ) { cloud sim . cancel all ( get id ( ) , new predicate type ( cloud sim tags . up ) ) ; schedule ( get id ( ) , switching delay , cloud sim tags . up ) ; pktlist . add ( ( network packet ) ev . get data ( ) ) ; }	process a received packet .
public void add child ( controller controller ) { if ( children == null ) children = new array list < controller > ( ) ; children . add ( controller ) ; controller . parent = this ; }	add a child controller .
protected boolean check turnouts in section ( section s , int seq num , section next section , active train at , layout editor le , section prev section ) { return turnout util ( s , seq num , next section , at , le , bool , bool , prev section ) ; }	check that all turnouts are correctly set for travel in the designated section to the next section.
protected string instance to matlab ( instance inst ) { string buffer result ; int i ; result = new string buffer ( ) ; for ( i = num ; i < inst . num attributes ( ) ; i ++ ) { if ( i > num ) { result . append ( ( m ? str : str ) ) ; } result . append ( m . format ( inst . value ( i ) ) ) ; } return result . to string ( ) ; }	turns the instance into a matlab row .
private static double distance ( problem problem , solution a , solution b , double power ) { double distance = num ; for ( int i = num ; i < problem . get number of objectives ( ) ; i ++ ) { distance += math . pow ( math . abs ( a . get objective ( i ) - b . get objective ( i ) ) , power ) ; } return math . pow ( distance , num / power ) ; }	returns the distance in objective space between the two solutions .
private void print rainbow user ( user user , string user name , boolean action , special color type , string id ) { simple attribute set user style = new simple attribute set ( styles . nick ( ) ) ; user style . add attribute ( attribute . is user message , bool ) ; user style . add attribute ( attribute . user , user ) ; if ( id != null ) { user style . add attribute ( attribute . id , id ) ; } int length = user name . length ( ) ; if ( action ) { print ( str , styles . nick ( ) ) ; } for ( int i = num ; i < length ; i ++ ) { color c ; if ( type == special color . rainbow ) { c = make rainbow color ( i , length ) ; } else { c = make gold color ( i , length ) ; } style constants . set foreground ( user style , c ) ; print ( user name . substring ( i , i + num ) , user style ) ; } }	output the username in rainbow colors.
public void notify address throttle found ( dcc throttle t ) { if ( log . is debug enabled ( ) ) { log . debug ( str ) ; } m throttle = t ; set enabled ( bool ) ; m throttle . add property change listener ( this ) ; set fn buttons ( ) ; }	get notification that a throttle has been found as we requested.
public boolean verify ( ) throws missing resource failure exception , xml { return super . verify references ( bool ) ; }	tests core validation process.
public open id prompt ( string prompt ) { original value = prompt ; if ( is empty ( prompt ) ) { prompts = collections . empty set ( ) ; } else { prompts = string to set ( prompt . to lower case ( ) ) ; } }	constructs a new openidprompt instance from the given prompt string.
private static boolean calculate is failure ( ) { int random value = random . next int ( num ) + num ; return random value <= error pct ; }	randomly determine whether this call should result in a network failure .
private int check user link ( spannable string builder out , string in , int start ) { int pos = start + num ; string builder temp = new string builder ( ) ; string target string = in . substring ( pos , math . min ( in . length ( ) , pos + num ) ) ; for ( int i = num ; i < target string . length ( ) ; i ++ ) { char c = target string . char at ( i ) ; if ( ( c >= str && c <= str ) || ( c >= str && c <= str ) || ( c >= str && c <= str ) || c == str ) { temp . append ( c ) ; } else { break ; } } string username = temp . to string ( ) ; if ( username . length ( ) < num || username . equals ignore case ( str ) ) { return - num ; } out . append ( username ) ; return pos + username . length ( ) - num ; }	change this should review account . java.
public void clear ( ) { m array list . clear ( ) ; }	clear out the adapter .
public void test common test 01 ( ) { ssl ssl = new ssl ( ) ; try { ssl slsc = ssl . engine get client session context ( ) ; fail ( str ) ; } catch ( runtime exception re ) { string str = re . get message ( ) ; if ( ! str . equals ( str ) ) fail ( str + str ) ; } catch ( exception e ) { fail ( str + e + str ) ; } try { ssl slsc = ssl . engine get server session context ( ) ; fail ( str ) ; } catch ( runtime exception re ) { string str = re . get message ( ) ; if ( ! str . equals ( str ) ) fail ( str + str ) ; } catch ( exception e ) { fail ( str + e + str ) ; } try { ssl sssf = ssl . engine get server socket factory ( ) ; fail ( str ) ; } catch ( runtime exception re ) { string str = re . get message ( ) ; if ( ! str . equals ( str ) ) fail ( str + str ) ; } catch ( exception e ) { fail ( str + e + str ) ; } try { ssl ssf = ssl . engine get socket factory ( ) ; fail ( str ) ; } catch ( runtime exception re ) { string str = re . get message ( ) ; if ( ! str . equals ( str ) ) fail ( str + str ) ; } catch ( exception e ) { fail ( str + e + str ) ; } }	sslcontextspi # enginegetclientsessioncontext ( ) sslcontextspi # enginegetserversessioncontext ( ) sslcontextspi # enginegetserversocketfactory ( ) sslcontextspi # enginegetsocketfactory ( ) verify exception when sslcontextspi object wasn ' t initialiazed .
public static class descriptor create class descriptor from resource name ( string resource name ) { if ( ! is class resource ( resource name ) ) { throw new illegal argument exception ( str + resource name + str ) ; } return create class descriptor ( resource name . substring ( num , resource name . length ( ) - num ) ) ; }	create a class descriptor from a resource name .
public static void show ( final window parent , final string content ) { final c dialog = new c ( parent , content ) ; gui helper . center child to parent ( parent , dialog , bool ) ; dialog . set visible ( bool ) ; }	shows a dialog that displays the content of the binnavi log file .
protected void end node ( node node ) throws org . xml . sax . sax { switch ( node . get node type ( ) ) { case node . document node : break ; case node . document type node : serialize doc type ( ( document type ) node , bool ) ; break ; case node . element node : serialize element ( ( element ) node , bool ) ; break ; case node . cdata section node : break ; case node . entity reference node : serialize entity reference ( ( entity reference ) node , bool ) ; break ; default : } }	end processing of given node.
public create window clause add view ( string namespace , string name ) { views . add ( view . create ( namespace , name ) ) ; return this ; }	adds an un - parameterized view to the named window .
public int size ( ) { return set . size ( ) ; }	returns the number of keys in this set .
public void associate connection ( object connection ) throws resource exception { if ( ! connection sharing ) disassociate connections ( ) ; try { final fb abstract connection = ( fb ) connection ; abstract connection . set managed connection ( this ) ; connection handles . add ( abstract connection ) ; } catch ( class cast exception cce ) { throw new fb ( str , cce ) ; } }	used by the container to change the association of an application - level connection handle with a managedconneciton instance.
chrono local date time < d > to local date time ( ) ;	gets the local date - time part of this date - time.
private void save ( ) { try { file utils . write ( new file ( jar name + str ) , text ) ; } catch ( io e ) { j . show message dialog ( null , e . get message ( ) , str , j . error message ) ; } }	saves the scan to the filesystem .
private static void assert not empty ( string message , string string ) { assert not null ( message , string ) ; assert false ( message , string . equals ( str ) ) ; }	asserts that a string is non - null and non - empty.
private void generate entity config ( managed entity config config ) throws sax { string host = config . get host ( ) ; if ( host != null ) { handler . start element ( str , host , host , empty ) ; handler . characters ( host . to char array ( ) , num , host . length ( ) ) ; handler . end element ( str , host , host ) ; } string remote command = config . get remote command ( ) ; if ( remote command != null ) { handler . start element ( str , remote command , remote command , empty ) ; handler . characters ( remote command . to char array ( ) , num , remote command . length ( ) ) ; handler . end element ( str , remote command , remote command ) ; } string working directory = config . get working directory ( ) ; if ( working directory != null ) { handler . start element ( str , working directory , working directory , empty ) ; handler . characters ( working directory . to char array ( ) , num , working directory . length ( ) ) ; handler . end element ( str , working directory , working directory ) ; } string product directory = config . get product directory ( ) ; if ( product directory != null ) { handler . start element ( str , product directory , product directory , empty ) ; handler . characters ( product directory . to char array ( ) , num , product directory . length ( ) ) ; handler . end element ( str , product directory , product directory ) ; } }	generates xml for attributes common to all managed entities .
public void append line ( char sequence line ) { lines . add ( line ) ; }	append the responseline to the smtpresponse.
public static void register new aggregation function ( string name , class < ? extends aggregation function > clazz , aggregation function meta data provider meta data provider ) { aggreation functions . put ( name , clazz ) ; aggregation functions meta data provider . put ( name , meta data provider ) ; }	with this method extensions might register additional aggregation functions if needed .
private byte [ ] build file auth tag ( ) throws file encryption exception { secret key key = back enc random access file . share key ; if ( key == null || key . get encoded ( ) . length == num ) { throw new file encryption exception ( str ) ; } else { auth tag h . reset ( ) ; key parameter key parameter = new key parameter ( key . get encoded ( ) ) ; auth tag h . init ( key parameter ) ; } if ( atag list . size ( ) == num ) { throw new file encryption exception ( str ) ; } else { for ( int i = num ; i < atag list . size ( ) ; i ++ ) { byte [ ] cur chunk tag = atag list . get ( i ) ; if ( ( cur chunk tag == null ) || ( cur chunk tag . length != chunk auth tag length ) ) { throw new file encryption exception ( str + i ) ; } else { auth tag h . update ( cur chunk tag , num , chunk auth tag length ) ; } } byte [ ] tmp = new byte [ auth tag size ] ; auth tag h . do final ( tmp , num ) ; return tmp ; } }	builds and returns the root authentication tag.
public void update data ( map element map element ) { name label . set text ( map element . get name ( ) ) ; pinned check box . set selected ( map element . is pinned ( ) ) ; }	map element was renamed.
public int do final ( byte [ ] out , int out off ) throws data length exception , illegal state exception , invalid cipher text exception { try { int result len = num ; if ( out off + buf off > out . length ) { throw new output length exception ( str ) ; } if ( buf off != num ) { if ( ! partial block okay ) { throw new data length exception ( str ) ; } cipher . process block ( buf , num , buf , num ) ; result len = buf off ; buf off = num ; system . arraycopy ( buf , num , out , out off , result len ) ; } return result len ; } finally { reset ( ) ; } }	process the last block in the buffer .
public priority queue ( int initial capacity , comparator < ? super e > comparator ) { if ( initial capacity < num ) { throw new illegal argument exception ( ) ; } elements = new element array ( initial capacity ) ; this . comparator = comparator ; }	constructs a priority queue with the specified capacity and comparator .
public void read data ( data input input ) throws io { read reference = input . read unsigned short ( ) ; read count = input . read unsigned short ( ) ; write reference = input . read unsigned short ( ) ; write count = input . read unsigned short ( ) ; int byte count = input . read unsigned byte ( ) ; if ( non word data handler == null ) { byte buffer [ ] = new byte [ byte count ] ; input . read fully ( buffer , num , byte count ) ; int offset = num ; registers = new register [ write count ] ; for ( int register = num ; register < write count ; register ++ ) { registers [ register ] = new simple register ( buffer [ offset ] , buffer [ offset + num ] ) ; offset += num ; } } else { non word data handler . read data ( input , write reference , write count ) ; } }	readdata - - read the values of the registers to be written , along with the reference and count for the registers to be read .
private boolean is touch inside list ( motion event ev ) { float x = ev . get x ( ) - m list view . get x ( ) ; float y = ev . get y ( ) - m list view . get y ( ) ; if ( x < num || x > m list view . get width ( ) || y < num || y > m list view . get height ( ) ) { return bool ; } return bool ; }	checks whether a touch event is inside of the bounds of the mode list .
public static final void center child to parent ( final component parent , final component child , final boolean b stay on screen ) { int x = ( parent . get x ( ) + ( parent . get width ( ) / num ) ) - ( child . get width ( ) / num ) ; int y = ( parent . get y ( ) + ( parent . get height ( ) / num ) ) - ( child . get height ( ) / num ) ; if ( b stay on screen ) { final toolkit tk = toolkit . get default toolkit ( ) ; final dimension ss = new dimension ( tk . get screen size ( ) ) ; if ( ( x + child . get width ( ) ) > ss . get width ( ) ) { x = ( int ) ( ss . get width ( ) - child . get width ( ) ) ; } if ( ( y + child . get height ( ) ) > ss . get height ( ) ) { y = ( int ) ( ss . get height ( ) - child . get height ( ) ) ; } if ( x < num ) { x = num ; } if ( y < num ) { y = num ; } } child . set location ( x , y ) ; }	centers the child component relative to its parent component .
public boolean is connecting ( ) { return start != null && preview != null && preview . is visible ( ) ; }	returns true if the source terminal has been clicked and a new connection is currently being previewed .
public protected properties ( properties props ) { enumeration < ? > prop enum = props . property names ( ) ; while ( prop enum . has more elements ( ) ) { string prop name = ( string ) prop enum . next element ( ) ; string prop value = props . get property ( prop name ) ; super . set property ( prop name , prop value ) ; } closed = bool ; }	creates a set of protected properties from a set of normal ones .
public boolean is empty ( ) { return item list . is empty ( ) ; }	return whether or not the worklist is empty .
private static void fix numeric byte order ( byte [ ] bytes ) { for ( int i = num ; i < bytes . length ; i += num ) { byte util . swap4 bytes ( bytes , i ) ; } }	swaps the bytes of the given numeric in place .
public synchronized boolean has scope ( ) { return ! scope stack . is empty ( ) ; }	returns true if this thread is executing inside a scope.
private boolean check attribute changed ( string existing , string current ) { if ( existing == null && current == null ) { return bool ; } if ( ( existing == null ) ^ ( current == null ) ) { return bool ; } return ( ! existing . equals ignore case ( current ) ) ; }	check that a single pair of attributes changed .
public boolean is empty ( ) { return count ( ) == num ; }	checks if consistent hash has nodes added to it .
@ override public void add table model listener ( table model listener l ) { m . add ( l ) ; }	adds a listener to the list that is notified each time a change to data model occurs.
private static url [ ] path to ur ( string path ) throws url { synchronized ( path to ur ) { object [ ] v = path to ur . get ( path ) ; if ( v != null ) { return ( ( url [ ] ) v [ num ] ) ; } } string tokenizer st = new string tokenizer ( path ) ; url [ ] urls = new url [ st . count tokens ( ) ] ; for ( int i = num ; st . has more tokens ( ) ; i ++ ) { urls [ i ] = new url ( st . next token ( ) ) ; } synchronized ( path to ur ) { path to ur . put ( path , new object [ ] { urls , new soft reference < string > ( path ) } ) ; } return urls ; }	convert a string containing a space - separated list of urls into a corresponding array of url objects , throwing a malformedurlexception if any of the urls are invalid .
boolean perform work ( task manager . task who , object param ) throws job exception { integer tmp = null ; synchronized ( tasks ) { tmp = ( integer ) tasks . get ( who ) ; } if ( tmp == null ) throw new unknown task exception ( ) ; int rank = tmp . int value ( ) ; synchronized ( attempts ) { attempts [ rank ] ++ ; } object result = do work ( who , param ) ; if ( result == null ) return bool ; try { report done ( who , result ) ; } catch ( unknown task exception e ) { } catch ( partial result exception e ) { } catch ( job exception e ) { } return bool ; }	used by a task to do a piece of work and record the number of attempts .
public list < order > load all deep from cursor ( cursor cursor ) { int count = cursor . get count ( ) ; list < order > list = new array list < order > ( count ) ; if ( cursor . move to first ( ) ) { if ( identity scope != null ) { identity scope . lock ( ) ; identity scope . reserve room ( count ) ; } try { do { list . add ( load current deep ( cursor , bool ) ) ; } while ( cursor . move to next ( ) ) ; } finally { if ( identity scope != null ) { identity scope . unlock ( ) ; } } } return list ; }	reads all available rows from the given cursor and returns a list of new imageto objects .
public static boolean is valid auth type ( string auth type ) { log . debug ( str ) ; if ( auth type != null ) { if ( ! auth type . is empty ( ) ) { if ( auth type . equals ignore case ( ldap auth base . ldap auth type simple ) ) return bool ; if ( auth type . equals ignore case ( ldap auth base . ldap auth type none ) ) return bool ; } } return bool ; }	determine if is a supported auth type.
public annotation member ( string name , object val , class type , method m ) { this ( name , val ) ; defining method = m ; if ( type == int . class ) { element type = integer . class ; } else if ( type == boolean . class ) { element type = boolean . class ; } else if ( type == char . class ) { element type = character . class ; } else if ( type == float . class ) { element type = float . class ; } else if ( type == double . class ) { element type = double . class ; } else if ( type == long . class ) { element type = long . class ; } else if ( type == short . class ) { element type = short . class ; } else if ( type == byte . class ) { element type = byte . class ; } else { element type = type ; } }	creates the completely defined element .
public void unregister preference change listener ( preference change listener preference change listener ) { m listeners . remove ( preference change listener ) ; }	removes the listener from receiving callbacks for any preference change event.
public static string join ( string separator , list < ? > elements ) { if ( elements == null || elements . size ( ) == num ) { return str ; } string buffer sb = new string buffer ( elements . size ( ) * num ) ; int i = num ; for ( object elem : elements ) { if ( i ++ > num ) { sb . append ( separator ) ; } sb . append ( format ( elem ) ) ; } return sb . to string ( ) ; }	returns a string containing all elements concatenated by a specified separator .
public boolean remove trace ( final trace trace ) { boolean result = trace list . remove ( trace ) ; if ( result ) { remove ( trace ) ; revalidate ( ) ; } return result ; }	remove a trace from the plot area .
private void update random values ( ) { for ( int i = num ; i < m block number ; i ++ ) { for ( int j = num ; j < default number random values ; j ++ ) { m block values [ i ] [ j ] = m random . next float ( ) ; if ( m block values [ i ] [ j ] < num ) { m block values [ i ] [ j ] = num ; } } } }	create random values to be picked when creating a new dynamics.
static private string byte ( ) { long temp value = byte . min value - num ; return string . value of ( temp value ) ; }	get the min value minus one for a byte.
public double accumulator ( double binary operator accumulator function , double identity ) { this . function = accumulator function ; base = this . identity = double . double to raw long bits ( identity ) ; }	creates a new instance using the given accumulator function and identity element .
public static void bitmap to mat ( bitmap bmp , mat mat , boolean un premultiply alpha ) { if ( bmp == null ) throw new java . lang . illegal argument exception ( str ) ; if ( mat == null ) throw new java . lang . illegal argument exception ( str ) ; n bitmap to mat2 ( bmp , mat . native obj , un premultiply alpha ) ; }	converts android bitmap to opencv mat.
public static void send mail ( context m context , string mail id ) { uri uri = uri . parse ( str + mail id ) ; intent intent = new intent ( intent . action sendto , uri ) ; m context . start activity ( intent ) ; }	use for sending mail to any id.
public void push ( @ not null status notification notification ) { stack . push ( notification ) ; }	push notification to message stack .
public void on paint actions ( view transform transform , d g ) { if ( ! m is selected ) { return ; } if ( m color set == null ) { return ; } if ( m widget . get visibility ( ) == constraint widget . gone ) { return ; } if ( ! m show resize handles ) { return ; } if ( ! m show actions ) { return ; } if ( m widget actions . size ( ) == num ) { return ; } int l = transform . get swing fx ( m widget . get draw x ( ) ) ; int t = transform . get swing fy ( m widget . get draw y ( ) ) ; int h = transform . get swing dimension ( m widget . get height ( ) ) ; int x = l ; int y = t + h + connection draw . connection anchor size + num ; g . set color ( m color set . get selected frames ( ) ) ; for ( widget action action : m widget actions ) { action . update ( ) ; if ( ! action . is visible ( ) ) { continue ; } action . on paint ( transform , g , x , y ) ; x += action size + connection draw . connection anchor size ; } }	paint the actions ( if any ) of this widget.
@ override public lookup create global context ( ) { if ( proxy lookup == null ) { logger . config ( str ) ; project lookup = new abstract lookup ( content ) ; proxy lookup = new proxy lookup ( global context lookup , project lookup ) ; } return proxy lookup ; }	returns a proxylookup that adds the current project instance to the global selection returned by utilities.
public void write ( byte [ ] bytes ) throws io { flush bits ( ) ; if ( bytes != null && bytes . length > num ) { out . write ( bytes ) ; bytes written += bytes . length ; } }	write the given bytes to the output stream.
public static mutable list < string > chunk ( string string , int size ) { if ( size <= num ) { throw new illegal argument exception ( str + size ) ; } int length = string . length ( ) ; if ( length == num ) { return fast list . new list ( ) ; } mutable list < string > result = fast list . new list ( ( length + size - num ) / size ) ; int start offset = num ; while ( start offset < length ) { result . add ( string . substring ( start offset , math . min ( start offset + size , length ) ) ) ; start offset += size ; } return result ; }	partitions string in fixed size chunks .
public void remove im ( im entity im ) { ims . remove ( im ) ; }	removes the given im from this user.
public language setting ( option opt ) { elem = null ; name = opt . get language ( ) ; string [ ] suffix array = opt . get suffixes ( ) ; string buffer strbuf = new string buffer ( ) ; for ( int i = num ; i < suffix array . length ; i ++ ) { strbuf . append ( suffix array [ i ] ) ; if ( i != suffix array . length - num ) strbuf . append ( str ) ; } this . suffixes = strbuf . to string ( ) ; min match len = opt . get minimum match length ( ) ; cluster type = opt . get clustertype ( ) ; read subdirs = opt . is read subdirs ( ) ; store matches = opt . get store matches ( ) ; }	constructs an element - less languagesetting object out of a option object . the set methods may not be used for the resulting object !.
private double calc util4 performing ( final double typ duration , final double actual duration ) { return num * marginal util performing sec + marginal util performing sec * typ duration * math . log ( actual duration / typ duration ) ; }	only true if all activities have same priority.
public void clear all cache ( ) { clear memory cache ( ) ; clear storage cache ( ) ; }	clears the caches for this cache object.
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str + str + str , str , num , str ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public void add notify ( ) { super . add notify ( ) ; if ( text area != null ) { l . install ( text area ) ; } update cell widths ( ) ; update cell heights ( ) ; }	overridden to set width of this component correctly when we are first displayed ( as keying off of the rtextarea gives us ( 0 , 0 ) when it isn ' t yet displayed .
@ description ( summary = str ) public void maven install local ( ) { jar mv ( ) ; string pom = new string ( read file ( new file ( str ) ) ) ; pom = replace all ( pom , str , str ) ; write file ( new file ( str ) , pom . get bytes ( ) ) ; exec script ( str , args ( str , str , str + get jar suffix ( ) , str , str , str , str ) ) ; jar ( ) ; pom = new string ( read file ( new file ( str ) ) ) ; pom = replace all ( pom , str , str ) ; write file ( new file ( str ) , pom . get bytes ( ) ) ; exec script ( str , args ( str , str , str + get jar suffix ( ) , str , str , str , str ) ) ; }	this will build a ' snapshot ' h2.
public static boolean is dto getter ( method method ) { if ( method . is annotation present ( delegate to . class ) ) { return bool ; } if ( method . get parameter types ( ) . length > num ) { return bool ; } string method name = method . get name ( ) ; return method name . starts with ( str ) || ( method name . starts with ( str ) && ( ( method . get return type ( ) == boolean . class || method . get return type ( ) == boolean . class ) ) ) ; }	check is specified method is dto getter .
protected list < dto > extract videos from cursor ( cursor cursor , int offset , int limit ) { list < dto > videos = new array list < > ( ) ; int count = num ; int begin = offset > num ? offset : num ; if ( cursor . move to position ( begin ) ) { do { dto video = extract one video from cursor ( cursor ) ; videos . add ( video ) ; count ++ ; if ( limit > num && count > limit ) { break ; } } while ( cursor . move to next ( ) ) ; } cursor . close ( ) ; return videos ; }	extract a list of videodto from current cursor with the given offset and limit .
private static void compute next ccw ( node node , long label ) { directed edge star de star = node . get out edges ( ) ; polygonize directed edge first out de = null ; polygonize directed edge prev in de = null ; list edges = de star . get edges ( ) ; for ( int i = edges . size ( ) - num ; i >= num ; i -- ) { polygonize directed edge de = ( polygonize directed edge ) edges . get ( i ) ; polygonize directed edge sym = ( polygonize directed edge ) de . get sym ( ) ; polygonize directed edge out de = null ; if ( de . get label ( ) == label ) out de = de ; polygonize directed edge in de = null ; if ( sym . get label ( ) == label ) in de = sym ; if ( out de == null && in de == null ) continue ; if ( in de != null ) { prev in de = in de ; } if ( out de != null ) { if ( prev in de != null ) { prev in de . set next ( out de ) ; prev in de = null ; } if ( first out de == null ) first out de = out de ; } } if ( prev in de != null ) { assert . is true ( first out de != null ) ; prev in de . set next ( first out de ) ; } }	computes the next edge pointers going ccw around the given node , for the given edgering label . this algorithm has the effect of converting maximal edgerings into minimal edgerings.
@ override public boolean equals ( object other ) { if ( other instanceof int array wrapper ) { return arrays . equals ( data , ( ( int array wrapper ) other ) . data ) ; } return bool ; }	this method will be used check to arraywrapper object is equal or not.
public static date time to date simple ( string str , time zone time zone ) throws page exception { date time dt = to date simple ( str , converting type offset , bool , time zone , null ) ; if ( dt == null ) throw new expression exception ( str + str + str ) ; return dt ; }	converts a object to a datetime object , returns null if invalid string.
public boolean contains ( song s ) { return m songs . contains ( s ) ; }	returns whether or not this adapter contains the provided song.
private boolean zz refill ( ) throws java . io . io { if ( zz start read > num ) { zz end read += zz final high surrogate ; zz final high surrogate = num ; system . arraycopy ( zz buffer , zz start read , zz buffer , num , zz end read - zz start read ) ; zz end read -= zz start read ; zz current pos -= zz start read ; zz marked pos -= zz start read ; zz start read = num ; } if ( zz current pos >= zz buffer . length - zz final high surrogate ) { char new buffer [ ] = new char [ zz buffer . length * num ] ; system . arraycopy ( zz buffer , num , new buffer , num , zz buffer . length ) ; zz buffer = new buffer ; zz end read += zz final high surrogate ; zz final high surrogate = num ; } int requested = zz buffer . length - zz end read ; int num read = zz reader . read ( zz buffer , zz end read , requested ) ; if ( num read == num ) { throw new java . io . io ( str ) ; } if ( num read > num ) { zz end read += num read ; if ( num read == requested ) { if ( character . is high surrogate ( zz buffer [ zz end read - num ] ) ) { -- zz end read ; zz final high surrogate = num ; } } return bool ; } return bool ; }	refills the input buffer .
public int add padding ( byte [ ] in , int in off ) { byte code = ( byte ) ( in . length - in off ) ; while ( in off < in . length - num ) { if ( random == null ) { in [ in off ] = num ; } else { in [ in off ] = ( byte ) random . next int ( ) ; } in off ++ ; } in [ in off ] = code ; return code ; }	add the pad bytes to the passed in block , returning the number of bytes added .
public static long make long ( string s ) { if ( ww . is empty ( s ) ) { return null ; } try { return long . value of ( s ) ; } catch ( number format exception e ) { return null ; } }	parses a string to a long value if the string can be parsed as a long.
private void verify block snapshot migration ( ) throws exception { log . info ( str ) ; iterator < block snapshot > block snapshot itr = db client . query iterative objects ( block snapshot . class , block snapshot ur ) ; list < block object > block objects = new array list < block object > ( ) ; while ( block snapshot itr . has next ( ) ) { block objects . add ( block snapshot itr . next ( ) ) ; } verify block objects ( block objects ) ; }	verify the blockmirror objects have been migrated correctly .
public static string edge type to string ( @ type int edge type ) { switch ( edge type ) { case fall through edge : return str ; case ifcmp edge : return str ; case switch edge : return str ; case switch default edge : return str ; case jsr edge : return str ; case ret edge : return str ; case goto edge : return str ; case return edge : return str ; case unhandled exception edge : return str ; case handled exception edge : return str ; case start edge : return str ; case backedge target edge : return str ; case backedge source edge : return str ; case exit edge : return str ; } throw new illegal state exception ( str + edge type ) ; }	get string representing given edge type .
boolean check groups ( phone number util util , phone number number , string builder normalized candidate , string [ ] expected number groups ) ;	returns true if the groups of digits found in our candidate phone number match our expectations .
private int insert unassigned group ( ) throws sql { prepared statement group statement ; final int ruleid = insert unassigned rule ( ) ; final int evaluation order = get num of groups ( ) + num ; string unassigned group sql statement = str + groups table + str + str + str ; unassigned group sql statement = string . format ( unassigned group sql statement , unassigned group , unassigned group type , unassigned data type , ruleid , evaluation order ) ; group statement = prepare statement ( unassigned group sql statement , new string [ ] { str } ) ; group statement . execute ( ) ; return get internal id ( group statement ) ; }	this method returns the group internal id of the unassigned group.
public builder delete extension field ( string urn , string field name ) { delete fields . add ( urn + str + field name ) ; return this ; }	deletes the given extension field of a existing user.
@ suppress warnings ( str ) private list < list < group attribute > > search auth provider ( filter query builder , string [ ] return attributes , final long count limit , attributes mapper mapper , validation failure reason [ ] failure reason ) throws size limit exceeded exception { search controls group search controls = new search controls ( search controls . subtree scope , count limit , search controls . get time limit ( ) , return attributes , search controls . get returning obj flag ( ) , search controls . get deref link flag ( ) ) ; list < list < group attribute > > query group results = null ; query group results = safe ldap search ( base dn , query builder . encode ( ) , group search controls , mapper , failure reason ) ; return query group results ; }	searches the authentication provider ( either ldap or ad ) based on the given search controls and required return attributes and return count limit .
public depend ( path impl source , long last modified , long length ) { source = source ; last modified = last modified ; length = length ; }	create a new dependency with an already known modified time and length .
public boolean has task of type in progress ( @ not null external system task type type , @ not null project project ) { string project id = external system task id . get project id ( project ) ; for ( external system task id id : my tasks in progress . key set ( ) ) { if ( type . equals ( id . get type ( ) ) && project id . equals ( id . get ide project id ( ) ) ) { return bool ; } } return bool ; }	allows to check if any task of the given type is being executed at the moment .
public final void remove change listener ( change listener listener ) { listeners . remove ( listener ) ; }	remove a changelistener . to be called in edt .
public static boolean contains ignore case ( string str , string query ) { if ( str != null && query != null ) { int limit = str . length ( ) - query . length ( ) + num ; for ( int i = num ; i < limit ; i ++ ) { if ( matches ignore case ( str , query , i ) ) { return bool ; } } } return bool ; }	same as string . contains , but ignores case .
public string to matrix string ( ) throws exception { return to matrix string ( str ) ; }	calls tomatrixstring ( ) with a default title .
public quad edge connect ( quad edge a , quad edge b ) { quad edge q = quad edge . connect ( a , b ) ; quad edges . add ( q ) ; return q ; }	creates a new quadedge connecting the destination of a to the origin of b , in such a way that all three have the same left face after the connection is complete.
public test find test ( list < string > suite names , string test class name , string test name , boolean insert if missing ) { if ( suite names . size ( ) <= num ) { test case test case = get test case ( test class name ) ; return test case . find test ( test name , insert if missing ) ; } else { string root name = suite names . remove ( num ) ; test suite suite = get test suite ( root name ) ; return suite . find test ( suite names , test class name , test name , insert if missing ) ; } }	insert the given test result into this suite .
public job configure ( boolean is secured , string meta store uris , string principal , string redis host , int redis port , string password , int redis db , string input database , string input table , string input filter , string key name , string value name , string key prefix , int num reducer , boolean replace , boolean pipeline , boolean flush , int commit size , string [ ] anon fields , string export salt ) throws exception { this . is secured = is secured ; this . meta store uris = meta store uris ; this . principal = principal ; this . redis host = redis host ; this . redis port = redis port ; this . password = password ; this . redis db = redis db ; this . input database = input database ; this . input table = input table ; this . input filter = input filter ; this . key name = key name ; this . key prefix = key prefix ; this . value name = value name ; this . num reducer = num reducer ; this . replace = replace ; this . pipeline = pipeline ; this . flush = flush ; this . commit size = commit size ; this . anon fields = anon fields . clone ( ) ; this . export salt = export salt ; return configure ( ) ; }	this function takes all required parameters and returns a configured job object .
public static double log2 ( double a ) { return math . log ( a ) / log2 ; }	returns the logarithm of a for base 2 .
public void add suggestions ( final @ non null suggestions result result , final @ non null string bucket , final @ non null token source source ) { query token query = result . get query token ( ) ; synchronized ( m lock ) { m result map . put ( bucket , result ) ; set < string > waiting for buckets = m waiting for results . get ( query ) ; if ( waiting for buckets != null ) { waiting for buckets . remove ( bucket ) ; if ( waiting for buckets . size ( ) == num ) { m waiting for results . remove ( query ) ; } } } string current token string = source . get current token string ( ) ; synchronized ( m lock ) { m suggestions . clear ( ) ; list < suggestible > suggestions = m suggestions list builder . build suggestions ( m result map , current token string ) ; if ( suggestions . size ( ) > num ) { m suggestions . add all ( suggestions ) ; m suggestions visibility manager . display suggestions ( bool ) ; } else { hide suggestions if necessary ( result . get query token ( ) , source ) ; } } notify data set changed ( ) ; }	add mention suggestions to a given bucket in the adapter.
public static < et extends enum < et > > enum resolver < et > construct for ( class < et > enum cls , annotation introspector ai ) { et [ ] enum values = enum cls . get enum constants ( ) ; if ( enum values == null ) { throw new illegal argument exception ( str + enum cls . get name ( ) ) ; } hash map < string , et > map = new hash map < string , et > ( ) ; for ( et e : enum values ) { map . put ( ai . find enum value ( e ) , e ) ; } return new enum resolver < et > ( enum cls , enum values , map ) ; }	factory method for constructing resolver that maps from enum . name ( ) into enum value.
public static boolean replace ( r text area , string to find , string replace with , boolean forward , boolean match case , boolean whole word , boolean regex ) throws pattern syntax exception { text area . begin atomic edit ( ) ; try { if ( regex ) { return regex replace ( text area , to find , replace with , forward , match case , whole word ) ; } make mark and dot equal ( text area , forward ) ; if ( find ( text area , to find , forward , match case , whole word , bool ) ) { text area . replace selection ( replace with ) ; return bool ; } } finally { text area . end atomic edit ( ) ; } return bool ; }	finds the next instance of the text / regular expression specified from the caret position.
public void pre single sign on request ( string hosted entity id , string idp entity id , string realm , http servlet request request , http servlet response response , authn request authn request ) throws sam { return ; }	invokes before openam sends the single - sign - on request to idp .
public static image icon create icon ( basic stroke stroke , int width , int height , boolean horizontal orientation ) { buffered image big image = new buffered image ( width , height , buffered image . type int argb ) ; d g = ( d ) big image . get graphics ( ) ; g . set background ( om . clear ) ; g . set paint ( om . clear ) ; g . fill rect ( num , num , width , height ) ; g . set paint ( color . black ) ; g . set stroke ( stroke ) ; if ( horizontal orientation ) { g . draw line ( num , height / num , width , height / num ) ; } else { g . draw line ( width / num , num , width / num , height ) ; } return new image icon ( big image ) ; }	given a basicstroke , create an imageicon that shows it .
public static final < t extends e > list < t > collect nodes within same this environment ( e root , class < t > cls ) { final list < t > result = new array list < > ( ) ; final tree iterator < e > iter = root . e all contents ( ) ; while ( iter . has next ( ) ) { final e obj = iter . next ( ) ; if ( cls . is assignable from ( obj . get class ( ) ) ) { @ suppress warnings ( str ) final t obj casted = ( t ) obj ; result . add ( obj casted ) ; } if ( obj instanceof this arg provider ) { iter . prune ( ) ; } } return result ; }	root usually a function or other thisproviding environment .
protected abstract list < single variable declaration > adjust dst params ( method declaration method ) ;	returns the destination method parameters minus the async callback ( if applicable ) .
public string full source ( ) { if ( full source == null ) { full source = add sentence markers ( source ( ) ) ; } return full source ; }	returns a sentence with the start and stop symbols added to the beginning and the end of the sentence respectively.
private void update detail data ( ) { final long start = m left position ; final long end = m right position ; final long now = m current time ; final context context = get context ( ) ; network stats history . entry original entry = m original network stats history . get values ( start , end , now , null ) ; final long original total bytes = original entry . rx bytes ; m original total phrase = formatter . format file size ( context , original total bytes ) ; network stats history . entry compressed entry = m received network stats history . get values ( start , end , now , null ) ; final long compressed total bytes = compressed entry . rx bytes ; m received total phrase = formatter . format file size ( context , compressed total bytes ) ; float percentage = num ; if ( original total bytes > num && original total bytes > compressed total bytes ) { percentage = ( original total bytes - compressed total bytes ) / ( float ) original total bytes ; } m percent reduction phrase = string . format ( str , num * percentage ) ; m start date phrase = format date ( context , start ) ; m end date phrase = format date ( context , end ) ; }	update data reduction statistics whenever the chart ' s inspection range changes.
public punctuation trie < t > lookup ( char sequence s ) { punctuation trie < t > t = this ; for ( int i = num , n = s . length ( ) ; i < n ; ++ i ) { t = t . lookup ( s . char at ( i ) ) ; if ( null == t ) { break ; } } return t ; }	the descendant of this trie corresponding to the string for this trie appended with s .
private static file construct file paths ( string file1 , string file2 ) { file new path ; if ( file2 . starts with ( file1 ) ) { new path = new file ( file2 ) ; } else { new path = new file ( file1 + str + file2 ) ; } return new path ; }	create a new file object from two file paths .
public string resolve template ( i template type , map < string , string > replacements ) throws io { path path = get template path ( template type ) ; string template = new string ( files . read all bytes ( path ) , standard charsets . utf 8 ) ; return insert properties ( template , replacements ) ; }	resolves a template for the given template type and set of placeholder to replace .
public void execute ( ) { try { prep . execute ( ) ; } catch ( sql e ) { throw convert ( e ) ; } }	execute the prepared statement .
private static byte [ ] unwrap calculated value ( byte [ ] data ) { if ( data . length < calc data offset ) { return data ; } byte buffer buffer = page channel . wrap ( data ) ; buffer . position ( calc data len offset ) ; int data len = buffer . get int ( ) ; byte [ ] new data = new byte [ math . min ( buffer . remaining ( ) , data len ) ] ; buffer . get ( new data ) ; return new data ; }	grabs the real data bytes from a calculated value .
public synchronized type instance create instance ( final string name , final string comment , final base type base type , final section section , final long section offset ) throws couldnt save data exception , couldnt load data exception { preconditions . check not null ( name , str ) ; preconditions . check argument ( comment == null || ! comment . is empty ( ) , str ) ; preconditions . check not null ( base type , str ) ; preconditions . check not null ( section , str ) ; preconditions . check argument ( section offset >= num , str ) ; preconditions . check argument ( ! instances by address . contains key ( new type instance address ( section . get start address ( ) , section offset ) ) ) ; final type instance instance = backend . create type instance ( name , comment , base type , section , section offset ) ; instances by address . put ( instance . get address ( ) , instance ) ; instances . add ( instance ) ; notify instance added ( instance ) ; return instance ; }	creates a new type instance instance and stores it in the database .
void show input box ( string message , consumer < string > result callback ) { show input box ( message , null , result callback ) ; }	shows input box with input field and ok button.
public void add ( field field ) { m fields . add ( field ) ; }	adds a single field to the end of this input .
public static long measure time ( callable < object > c , int thread cnt ) throws exception { a . ensure ( thread cnt >= num , str ) ; long start = system . current time millis ( ) ; if ( thread cnt == num ) c . call ( ) ; else grid test utils . run multi threaded ( c , thread cnt , str ) ; return system . current time millis ( ) - start ; }	performs operation , measuring it ' s time .
@ override public boolean is closed ( ) { return is closed . get ( ) ; }	returns true if closed .
protected statement list node generate destructor body ( context context , statement list node statement list ) { model model = ( model ) value ; set < string > ids = new linked hash set < string > ( ) ; if ( model . is declared ( ) ) ids . add ( model . get id ( ) ) ; collect declarations ( model . get sub initializer iterator ( ) , ids ) ; node factory node factory = context . get node factory ( ) ; statement list node result = statement list ; statement list node function statement list = null ; for ( string id : ids ) { literal null node literal null = node factory . literal null ( ) ; identifier node identifier = node factory . identifier ( id ) ; node expression statement = node factory . assignment expression ( identifier , assign token , literal null ) ; function statement list = node factory . statement list ( function statement list , expression statement ) ; } function signature node function signature = node factory . function signature ( null , null ) ; function signature . void anno = bool ; identifier node function identifier = node factory . identifier ( model . get definition name ( ) + str ) ; function common node function common = node factory . function common ( context , function identifier , function signature , function statement list ) ; function common . set user defined body ( bool ) ; attribute list node attribute list = abstract syntax tree util . generate private attribute ( node factory ) ; function name node function name = node factory . function name ( tokens . empty token , function identifier ) ; function definition node function definition = node factory . function definition ( context , attribute list , function name , function common ) ; result = node factory . statement list ( result , function definition ) ; return result ; }	generates the destructor / reset method as necessary as required by itransientdeferredinstance rvalues .
protected synchronized void expire ( ) throws illegal monitor state exception { if ( owner == thread . current thread ( ) ) { expired = bool ; } else { throw new illegal monitor state exception ( str ) ; } }	sets the status of the headtask to expired .
private string buffer prepare optimized insert statement ( one row change one row change ) { string buffer stmt ; stmt = new string buffer ( ) ; stmt . append ( str ) ; stmt . append ( conn . get database object name ( one row change . get schema name ( ) ) + str + conn . get database object name ( one row change . get table name ( ) ) ) ; stmt . append ( str ) ; print column spec ( stmt , one row change . get column spec ( ) , null , null , print mode . names only , str ) ; stmt . append ( str ) ; boolean first row = bool ; for ( array list < column val > one row values : one row change . get column values ( ) ) { if ( first row ) { first row = bool ; } else stmt . append ( str ) ; print column spec ( stmt , one row change . get column spec ( ) , null , one row values , print mode . place holder , str ) ; stmt . append ( str ) ; } return stmt ; }	build prepare statement for optimized inserts : < br > insert into table1 values (.
private boolean extractor queue empty ( ) throws interrupted exception { if ( extractor . has more events ( ) ) return bool ; else if ( block commit interval millis <= num ) return bool ; else { long next commit millis = last commit millis + block commit interval millis ; long sleep millis = next commit millis - system . current time millis ( ) ; while ( sleep millis > num ) { thread . sleep ( num ) ; if ( extractor . has more events ( ) ) return bool ; sleep millis = next commit millis - system . current time millis ( ) ; } return bool ; } }	determines whether the extractor queue is currently empty.
public static void verify ( final class reader cr , final boolean dump , final print writer pw ) { verify ( cr , null , dump , pw ) ; }	checks a given class.
public file async http response handler ( context context ) { super ( ) ; this . file = get temporary file ( context ) ; this . append = bool ; this . rename if exists = bool ; }	obtains new fileasynchttpresponsehandler against context with target being temporary file.
public static boolean is window opaque ( window window ) { if ( window == null ) { throw new null pointer exception ( str ) ; } return window . is opaque ( ) ; }	returns whether the window is opaque or translucent .
public static byte [ ] encode ( byte [ ] data , int off , int length ) { int len = ( length + num ) / num * num ; byte array output stream b out = new byte array output stream ( len ) ; try { encoder . encode ( data , off , length , b out ) ; } catch ( exception e ) { throw new encoder exception ( str + e . get message ( ) , e ) ; } return b out . to byte array ( ) ; }	encode the input data producing a base 64 encoded byte array .
public double entropy nmi ( ) { return ( entropy mutual information ( ) / math . min ( entropy first ( ) , entropy second ( ) ) ) ; }	get the min - normalized mutual information ( normalized , 0 = unequal ).
public static void unregister ( close watcher w ) { w . closeable = null ; refs . remove ( w ) ; }	unregister an object , so it is no longer tracked .
static label node [ ] clone ( final list < label node > labels , final map < label node , label node > map ) { label node [ ] clones = new label node [ labels . size ( ) ] ; for ( int i = num ; i < clones . length ; ++ i ) { clones [ i ] = map . get ( labels . get ( i ) ) ; } return clones ; }	returns the clones of the given labels .
@ override public jetty solr runner create jetty ( file solr home , string data dir , string shard list , string solr config override , string schema override ) throws exception { return create proxied jetty ( solr home , data dir , shard list , solr config override , schema override ) ; }	overrides the parent implementation to install a socketproxy in - front of the jetty server .
public synchronized void add batch classifier listener ( batch classifier listener cl ) { m batch classifier listeners . add element ( cl ) ; }	add a batch classifier listener.
private boolean match andwrite one audit log ( buffered writer writer , audit log auditlog , string keyword ) throws marshalling excetion { try { audit log utils . reset desc ( auditlog , resb ) ; if ( audit log utils . is keyword contained ( auditlog , keyword ) ) { if ( count . get and increment ( ) > num ) { while ( ! first written . get ( ) ) { try { thread . sleep ( num ) ; } catch ( interrupted exception e ) { logger . warn ( str ) ; } } writer . write ( str + mapper . write value as string ( auditlog ) ) ; } else { writer . write ( mapper . write value as string ( auditlog ) ) ; first written . set ( bool ) ; } return bool ; } logger . debug ( str , auditlog . get description ( ) , keyword ) ; return bool ; } catch ( json generation exception e ) { throw new marshalling excetion ( str , e ) ; } catch ( json mapping exception e ) { throw new marshalling excetion ( str , e ) ; } catch ( io e ) { throw new marshalling excetion ( str , e ) ; } }	match if auditlog description contains expected keyword , stream out the auditlog if matched , otherwise ignore this one piece of auditlog.
string to string ( boolean include private credentials ) { string s = resources mgr . get string ( str ) ; string suffix = str ; synchronized ( principals ) { iterator < principal > p i = principals . iterator ( ) ; while ( p i . has next ( ) ) { principal p = p i . next ( ) ; suffix = suffix + resources mgr . get string ( str ) + p . to string ( ) + resources mgr . get string ( str ) ; } } synchronized ( pub credentials ) { iterator < object > p i = pub credentials . iterator ( ) ; while ( p i . has next ( ) ) { object o = p i . next ( ) ; suffix = suffix + resources mgr . get string ( str ) + o . to string ( ) + resources mgr . get string ( str ) ; } } if ( include private credentials ) { synchronized ( priv credentials ) { iterator < object > p i = priv credentials . iterator ( ) ; while ( p i . has next ( ) ) { try { object o = p i . next ( ) ; suffix += resources mgr . get string ( str ) + o . to string ( ) + resources mgr . get string ( str ) ; } catch ( security exception se ) { suffix += resources mgr . get string ( str ) ; break ; } } } } return s + suffix ; }	package private convenience method to print out the subject without firing off a security check when trying to access the private credentials.
private void decode tones phase ( int ch num , boolean band has tones [ ] ) { waves data dst [ ] = ctx . channels [ ch num ] . tones info ; for ( int sb = num ; sb < ctx . waves info . num tone bands ; sb ++ ) { if ( ! band has tones [ sb ] ) { continue ; } int wparam = dst [ sb ] . start index ; for ( int i = num ; i < dst [ sb ] . num wavs ; i ++ ) { ctx . waves info . waves [ wparam + i ] . phase index = br . read ( num ) ; } } }	decode phase information for each subband of a channel .
public int encode ( byte [ ] data , int off , int length , output stream out ) throws io { for ( int i = off ; i < ( off + length ) ; i ++ ) { int v = data [ i ] & num ; out . write ( encoding table [ ( v > > > num ) ] ) ; out . write ( encoding table [ v & num ] ) ; } return length * num ; }	encode the input data producing a hex output stream .
public void clear ( ) { synchronized ( m lock ) { m graphics . clear ( ) ; } post invalidate ( ) ; }	removes all graphics from the overlay .
public static string remove all ( string str , string [ ] patterns ) { for ( string pattern : patterns ) str = str . replace ( pattern , str ) ; return str ; }	removes all occurrences of each pattern in str.
public void add series renderer ( simple series renderer renderer ) { m renderers . add ( renderer ) ; }	adds a simple renderer to the multiple renderer .
public static void cc draw circle ( g gl , cg center , float r , float a , int segments , boolean draw line to center ) { float buffer vertices = get vertices ( num * ( segments + num ) ) ; int additional segment = num ; if ( draw line to center ) additional segment ++ ; final float coef = num * ( float ) math . pi / segments ; for ( int i = num ; i <= segments ; i ++ ) { float rads = i * coef ; float j = ( float ) ( r * math . cos ( rads + a ) + center . x ) ; float k = ( float ) ( r * math . sin ( rads + a ) + center . y ) ; vertices . put ( j ) ; vertices . put ( k ) ; } vertices . put ( center . x ) ; vertices . put ( center . y ) ; vertices . position ( num ) ; gl . gl disable ( gl texture 2 d ) ; gl . gl disable client state ( gl texture coord array ) ; gl . gl disable client state ( gl color array ) ; gl . gl vertex pointer ( num , gl float , num , vertices ) ; gl . gl draw arrays ( gl line strip , num , segments + additional segment ) ; gl . gl enable client state ( gl color array ) ; gl . gl enable client state ( gl texture coord array ) ; gl . gl enable ( gl texture 2 d ) ; }	draws a circle given the center , radius and number of segments .
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add all ( collections . list ( super . list options ( ) ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
@ override public boolean is parent ( file folder , file file ) { return folder . equals ( file . get parent file ( ) ) ; }	checks whether folder is the same as file.
@ override public void print ( char c ) throws io { boolean is ws = character . is whitespace ( c ) ; if ( is ws ) { if ( is first char ) return ; if ( c == char return ) return ; if ( sb . length ( ) > num ) { print buffer ( ) ; last char = ( c == char nl ) ? char nl : c ; super . print ( last char ) ; return ; } } is first char = bool ; if ( c == char gt && sb . length ( ) > num ) print buffer ( ) ; if ( is ws || ! add to buffer ( c ) ) { if ( depth sum == num ) { if ( is ws ) { if ( last char == char nl ) return ; if ( c != char nl ) { if ( character . is whitespace ( last char ) ) return ; } } } last char = c ; super . print ( c ) ; } }	sends a character to output stream if it is not a consecutive white - space unless we ' re inside a pre or textarea tag .
public static token endpoint auth method from string ( string type ) { if ( type != null ) { for ( token endpoint auth method auth method : token endpoint auth method . values ( ) ) { if ( type . equals ignore case ( auth method . type ) ) { return auth method ; } } } return null ; }	translates a string into a token endpoint auth method type .
public void put ( e e ) throws interrupted exception { if ( e == null ) throw new null pointer exception ( ) ; int c = - num ; final reentrant lock put lock = this . put lock ; final atomic integer count = this . count ; put lock . lock interruptibly ( ) ; try { while ( count . get ( ) >= capacity ) { not full . await ( ) ; } enqueue ( e ) ; c = count . get and increment ( ) ; if ( c + num < capacity ) not full . signal ( ) ; } finally { put lock . unlock ( ) ; } if ( c == num ) signal not empty ( ) ; }	inserts the specified element at the tail of this queue , waiting if necessary for space to become available .
private boolean compare ( list < string > remote modules , list < string > expected modules ) { collections . sort ( remote modules ) ; collections . sort ( expected modules ) ; return remote modules . equals ( expected modules ) ; }	return true if the both lists contain the same content ( order doesn ' t matter ).
private void encode size ( byte buffer header buffer , int size ) { header buffer . put ( ( byte ) ( ( size & num ) > > num ) ) ; header buffer . put ( ( byte ) ( ( size & num ) > > num ) ) ; header buffer . put ( ( byte ) ( size & num ) ) ; logger . fine ( str + size + str + integer . to binary string ( size ) + str + integer . to hex string ( size ) ) ; }	write frame size ( can now be accurately calculated , have to convert 4 byte int to 3 byte format .
public boolean this is you ( object n ) { return id . equals ( n ) ; }	checks the internal id against the given one .
@ override public synchronized void clear ( ) { file [ ] files = m root directory . list files ( ) ; if ( files != null ) { for ( file file : files ) { file . delete ( ) ; } } m entries . clear ( ) ; m total size = num ; volley log . d ( str ) ; }	clears the cache . deletes all cached files from disk .
public void reset workspace ( ) { m block factory . clear prior block references ( ) ; m root blocks . clear ( ) ; m stats . clear ( ) ; m deleted blocks . clear ( ) ; }	reset the workspace view when changing workspaces.
protected void on complete ( ) { }	meant to be overwritten by children classes that want to do something special after the download is completed .
public static big decimal paid to date ( int p c id , int p c id , int p ap , timestamp date acct ) throws sql { if ( p c id == num || p c id == num ) return null ; big decimal ap = new big decimal ( ( double ) p ap ) ; if ( p ap == num ) ap = adempiere . one ; int c id = num ; big decimal payment amt = allocated amt to date ( p c id , p c id , c id , ap , date acct ) ; return currency . round ( payment amt , p c id , null ) ; }	get invoice paid ( allocated ) amount . - invoicepaid.
public static list < window > windows ( input stream words , tokenizer factory tokenizer factory , int window size ) { tokenizer tokenizer = tokenizer factory . create ( words ) ; list < string > list = new array list < > ( ) ; while ( tokenizer . has more tokens ( ) ) list . add ( tokenizer . next token ( ) ) ; if ( list . is empty ( ) ) throw new illegal state exception ( str ) ; return windows ( list , window size ) ; }	constructs a list of window of size windowsize.
public static double [ ] page rank ( matrix interface prepared matrix , int max iteration ) { double [ ] init = new double [ prepared matrix . get rows count ( ) ] ; for ( int i = num ; i != init . length ; i ++ ) init [ i ] = num ; return page rank ( prepared matrix , max iteration , default d , init ) ; }	call preparematrix or preparesparsematrix first.
public boolean has mime ( string mime type ) { if ( mime type == null ) return bool ; string type = mime type ; if ( mime type . index of ( str ) > num ) { type = mime type . substring ( num , mime type . index of ( str ) ) ; } for ( string mt : this . mime types ) { if ( mt . equals ignore case ( mime type ) ) { return bool ; } if ( mime type != type && mt . equals ignore case ( type ) ) { return bool ; } } return bool ; }	checks if specified mime type matches one of the fileformat ' s mime types.
private void read object ( java . io . object input stream s ) throws java . io . io , class not found exception { s . default read object ( ) ; key = key . clone ( ) ; }	readobject is called to restore the state of this key from a stream .
void unexecute ns ( transformer impl transformer ) throws transformer exception { unexecute ns ( transformer , null ) ; }	send endprefixmapping events to the result tree handler for all declared prefix mappings in the stylesheet .
public boolean add ( protocol message pm ) { return protocol messages . add ( pm ) ; }	adds protocol message to the list.
public void random init ( ) { do { m bits = new boolean [ m n nodes * m n nodes ] ; for ( int i = num ; i < m n nodes ; i ++ ) { int i pos ; do { i pos = m random . next int ( m n nodes * m n nodes ) ; } while ( is square ( i pos ) ) ; m bits [ i pos ] = bool ; } } while ( has cycles ( ) ) ; calc global score ( ) ; }	initialize with a random structure by randomly placing m_nnodes arcs .
public static int safe parse int ( string s ) { return safe parse int ( s , - num ) ; }	parses the specified string argument to an unsigned decimal integer.
protected boolean has receivers for ( distributed member end point ) { synchronized ( this . receivers ) { for ( iterator it = receivers . iterator ( ) ; it . has next ( ) ; ) { connection con = ( connection ) it . next ( ) ; if ( end point . equals ( con . get remote address ( ) ) ) { return bool ; } } } return bool ; }	check to see if there are still any receiver threads for the given end - point.
public void add range restriction ( string column name , object code , object to , string info name , string info display , string to ) { restriction r = new restriction ( column name , code , to , info name , info display , to , bool , num ) ; m list . add ( r ) ; }	add range restriction ( between ).
public static string unsigned to string ( final int value ) { if ( value >= num ) { return integer . to string ( value ) ; } else { return long . to string ( value & num ) ; } }	convert an unsigned 32 - bit integer to a string .
public static list < file > find all ( file base file , string regex ) { array list < file > found = new array list < file > ( ) ; find all ( base file , regex , found ) ; return found ; }	find a files in a given base directory that match a the given regex.
public void append css ( string builder buf ) { buf . append ( str ) ; buf . append ( name ) ; buf . append ( str ) ; for ( pair < string , string > pair : statements ) { buf . append ( pair . get first ( ) ) ; buf . append ( str ) ; buf . append ( pair . get second ( ) ) ; buf . append ( str ) ; } buf . append ( str ) ; }	append css definition to a stream.
@ override public boolean e is set ( int feature id ) { switch ( feature id ) { case datatype package . constraint type : return type != type edefault ; case datatype package . constraint constraint values : return constraint values edefault == null ? constraint values != null : ! constraint values edefault . equals ( constraint values ) ; } return super . e is set ( feature id ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
protected object clone object ( object obj ) { if ( obj == null ) { return null ; } if ( obj instanceof string || obj instanceof boolean || obj instanceof byte || obj instanceof short || obj instanceof character || obj instanceof integer || obj instanceof long || obj instanceof float || obj instanceof double ) { return obj ; } if ( obj instanceof byte [ ] ) { byte [ ] body = ( byte [ ] ) obj ; byte [ ] data = new byte [ body . length ] ; system . arraycopy ( body , num , data , num , body . length ) ; return data ; } return serialization helper . deep clone ( obj ) ; }	returns a clone of the object .
private void assert write varint ( byte [ ] data , long value ) throws exception { if ( ( value > > > num ) == num ) { byte array output stream raw output = new byte array output stream ( ) ; coded output stream output = coded output stream . new instance ( raw output ) ; output . write raw varint32 ( ( int ) value ) ; output . flush ( ) ; assert equal bytes ( data , raw output . to byte array ( ) ) ; assert equals ( data . length , coded output stream . compute raw varint32 size ( ( int ) value ) ) ; } { byte array output stream raw output = new byte array output stream ( ) ; coded output stream output = coded output stream . new instance ( raw output ) ; output . write raw varint64 ( value ) ; output . flush ( ) ; assert equal bytes ( data , raw output . to byte array ( ) ) ; assert equals ( data . length , coded output stream . compute raw varint64 size ( value ) ) ; } for ( int block size = num ; block size <= num ; block size *= num ) { if ( ( value > > > num ) == num ) { byte array output stream raw output = new byte array output stream ( ) ; coded output stream output = coded output stream . new instance ( raw output , block size ) ; output . write raw varint32 ( ( int ) value ) ; output . flush ( ) ; assert equal bytes ( data , raw output . to byte array ( ) ) ; } { byte array output stream raw output = new byte array output stream ( ) ; coded output stream output = coded output stream . new instance ( raw output , block size ) ; output . write raw varint64 ( value ) ; output . flush ( ) ; assert equal bytes ( data , raw output . to byte array ( ) ) ; } } }	writes the given value using writerawvarint32 ( ) and writerawvarint64 ( ) and checks that the result matches the given bytes .
public void attach ( action observer observer ) { observer . make one time use ( ) ; lock . lock ( ) ; try { once used observers . add ( observer ) ; } finally { lock . unlock ( ) ; } }	once used observer add to observercontroller.
private void sign certificate chain ( ) { list < certificate > cc = new array list < > ( ) ; cc . add ( sign cert ) ; list < certificate > oc = new array list < > ( certs ) ; for ( int k = num ; k < oc . size ( ) ; ++ k ) { if ( sign cert . equals ( oc . get ( k ) ) ) { oc . remove ( k ) ; -- k ; } } boolean found = bool ; while ( found ) { x509 certificate v = ( x509 certificate ) cc . get ( cc . size ( ) - num ) ; found = bool ; for ( int k = num ; k < oc . size ( ) ; ++ k ) { x509 certificate issuer = ( x509 certificate ) oc . get ( k ) ; try { v . verify ( issuer . get public key ( ) , provider ) ; found = bool ; cc . add ( oc . get ( k ) ) ; oc . remove ( k ) ; break ; } catch ( exception ignored ) { } } } sign certs = cc ; }	helper method that creates the collection of certificates used for the main signature based on the complete list of certificates and the sign certificate .
public static string meter to string ( of inst , logger log ) { return long . to string ( inst . get meter id ( ) ) ; }	convert an ofinstructionmeter to string form.
public string charset ( ) { return parameter ( header content type , param charset ) ; }	get ' charset ' parameter from ' content - type ' response header.
public dimension minimum layout size ( container parent ) { dimension rd , mbd ; insets i = get insets ( ) ; if ( content pane != null ) { rd = content pane . get minimum size ( ) ; } else { rd = parent . get size ( ) ; } if ( menu bar != null && menu bar . is visible ( ) ) { mbd = menu bar . get minimum size ( ) ; } else { mbd = new dimension ( num , num ) ; } return new dimension ( math . max ( rd . width , mbd . width ) + i . left + i . right , rd . height + mbd . height + i . top + i . bottom ) ; }	returns the minimum amount of space the layout needs .
public static boolean check if can use ( string class name ) { if ( mock list . should be mocked ( class name ) ) { return bool ; } for ( string s : class exceptions ) { if ( class name . starts with ( s ) ) { return bool ; } } return bool ; }	check if we can use the given class directly in a junit test.
public static int read all ( input stream i , byte b [ ] ) throws io { int len = b . length ; int n = num ; while ( n < len ) { int count = i . read ( b , n , len - n ) ; if ( count < num ) { return n ; } n += count ; } return n ; }	reads until the array is full or until the stream ends.
public void switch to simple ( experiment exp ) { if ( exp == null ) { exp = m advanced panel . get experiment ( ) ; } if ( exp != null && ! m simple panel . set experiment ( exp ) ) { m r . set selected ( bool ) ; switch to advanced ( exp ) ; } else { remove ( m advanced panel ) ; m advanced panel . remove notes frame ( ) ; add ( m simple panel , border layout . center ) ; validate ( ) ; repaint ( ) ; } }	switches to the simple setup mode only if allowed to .
public static cache span create cache entry ( file file ) { matcher matcher = cache file pattern . matcher ( file . get name ( ) ) ; if ( ! matcher . matches ( ) ) { return null ; } string key = util . unescape file name ( matcher . group ( num ) ) ; return key == null ? null : create cache entry ( key , long . parse long ( matcher . group ( num ) ) , long . parse long ( matcher . group ( num ) ) , file ) ; }	creates a cache span from an underlying cache file .
public boolean is component part of current menu ( component c ) { if ( selection . size ( ) > num ) { menu element me = selection . element at ( num ) ; return is component part of current menu ( me , c ) ; } else return bool ; }	return true if c is part of the currently used menu.
public static int hsba ( float h , float s , float b , float a ) { return set alpha ( color . hs rgb ( h , s , b ) , ( int ) ( a * num + num ) & num ) ; }	get the color code for the given hue , saturation , and brightness values , translating from hsb color space to rgb color space .
lambda form buffer replace functions ( named function [ ] old fns , named function [ ] new fns , object ... for arguments ) { assert ( in trans ( ) ) ; if ( old fns . length == num ) return this ; for ( int i = arity ; i < length ; i ++ ) { name n = names [ i ] ; int nfi = index of ( n . function , old fns ) ; if ( nfi >= num && arrays . equals ( n . arguments , for arguments ) ) { change name ( i , new name ( new fns [ nfi ] , n . arguments ) ) ; } } return this ; }	replace any name whose function is in oldfns with a copy whose function is in the corresponding position in newfns.
@ override public client socket open if live ( ) { if ( state . is closed ( ) ) { return null ; } client socket stream = open recycle ( ) ; if ( stream != null ) return stream ; long now = current time . current time ( ) ; if ( is failed ( now ) ) return null ; else if ( state == state . fail && starting count . get ( ) > num ) { return null ; } return connect ( ) ; }	open a stream to the target server object persistence .
public void commit ( ) { info ( str + solr url + str ) ; do get ( append param ( solr url . to string ( ) , str ) ) ; }	does a simple commit operation.
public abstract void files dropped ( java . io . file [ ] files ) ;	this method is called when files have been successfully dropped .
protected void wait for thread to enter wait state ( thread thread , long timeout millis ) { long start time = num ; for ( ; ; ) { thread . state s = thread . get state ( ) ; if ( s == thread . state . blocked || s == thread . state . waiting || s == thread . state . timed waiting ) return ; else if ( s == thread . state . terminated ) fail ( str ) ; else if ( start time == num ) start time = system . nano time ( ) ; else if ( millis elapsed since ( start time ) > timeout millis ) { thread assert true ( thread . is alive ( ) ) ; return ; } thread . yield ( ) ; } }	spin - waits up to the specified number of milliseconds for the given thread to enter a wait state : blocked , waiting , or timed_waiting .
public void force rewrite exif ( string filename , collection < exif tag > tags ) throws file not found exception , io { if ( ! rewrite exif ( filename , tags ) ) { exif data temp data = m data ; m data = new exif data ( default byte order ) ; file input stream is = null ; byte array output stream bytes = null ; try { is = new file input stream ( filename ) ; bytes = new byte array output stream ( ) ; do exif stream io ( is , bytes ) ; byte [ ] image bytes = bytes . to byte array ( ) ; read exif ( image bytes ) ; set tags ( tags ) ; write exif ( image bytes , filename ) ; } catch ( io e ) { close silently ( is ) ; throw e ; } finally { is . close ( ) ; m data = temp data ; } } }	attempts to do an in - place rewrite of the exif metadata.
public static lat lng translate point ( lat lng point , double distance , double bearing ) { distance = distance / num ; double lat = math . to radians ( point . latitude ) ; double lng = math . to radians ( point . longitude ) ; bearing = math . to radians ( bearing ) ; double lat2 = math . asin ( ( math . sin ( lat ) * math . cos ( distance / earth ) ) + ( math . cos ( lat ) * math . sin ( distance / earth ) * math . cos ( bearing ) ) ) ; double long2 = lng + math . atan2 ( math . sin ( bearing ) * math . sin ( distance / earth ) * math . cos ( lat ) , math . cos ( distance / earth ) - ( math . sin ( lat ) * math . sin ( lat2 ) ) ) ; lat2 = math . to degrees ( lat2 ) ; long2 = math . to degrees ( long2 ) ; return new lat lng ( lat2 , long2 ) ; }	returns the destination point from the starting point point having travelled the given distance on the given initial bearing ( bearing normally varies around path followed ) .
public static string detect properties path ( ) { string override = system . get property ( str ) ; if ( override != null ) { return override ; } string jar path = detect jar path ( ) ; string prop file = constants . props file + str ; return fix whitespaces ( get parent directory ( jar path ) + file . separator + prop file ) ; }	gets the path to qz - tray . properties.
static int format float ( final char [ ] out , float val , int digits ) { boolean negative = bool ; if ( val == num ) { out [ num ] = str ; return num ; } if ( val < num ) { negative = bool ; val = - val ; } if ( digits >= po . length ) { digits = po . length - num ; } val *= po [ digits ] ; long lval = math . round ( val ) ; int index = out . length - num ; int char count = num ; while ( lval != num || char count < ( digits + num ) ) { int digit = ( int ) ( lval % num ) ; lval = lval / num ; out [ index -- ] = ( char ) ( digit + str ) ; char count ++ ; if ( char count == digits ) { out [ index -- ] = str ; char count ++ ; } } if ( negative ) { out [ index ] = str ; char count ++ ; } return char count ; }	formats a float value to the given number of decimals.
public void accept package ( char [ ] package name ) { }	one result of the search consists of a new package .
public gaussian density function ( double mean , double variance ) { this . mean = new double [ ] { mean } ; this . variance = new double [ ] { variance } ; std dev = new double [ ] { math . sqrt ( variance ) } ; if ( variance < num ) { log . warning ( str + variance ) ; } }	creates a new , univariate density function with a given mean and variance.
int encrypt final ( byte [ ] in , int in ofs , int len , byte [ ] out , int out ofs ) throws illegal block size exception , short buffer exception { if ( out . length - out ofs < ( len + tag len bytes ) ) { throw new short buffer exception ( str ) ; } process aad ( ) ; if ( len > num ) { do last block ( in , in ofs , len , out , out ofs , bool ) ; } byte [ ] length block = get length block ( size of aad * num , processed * num ) ; ghash all to s . update ( length block ) ; byte [ ] s = ghash all to s . digest ( ) ; byte [ ] s out = new byte [ s . length ] ; gctr gctr for s = new gctr ( embedded cipher , this . pre counter block ) ; gctr for s . do final ( s , num , s . length , s out , num ) ; system . arraycopy ( s out , num , out , ( out ofs + len ) , tag len bytes ) ; return ( len + tag len bytes ) ; }	performs encryption operation for the last time .
public static string component to image col name ( string component ) { if ( component . equals ( mixn match columns . key homescreen ) ) { return themes columns . homescreen uri ; } else if ( component . equals ( mixn match columns . key lockscreen ) ) { return themes columns . lockscreen uri ; } else if ( component . equals ( mixn match columns . key boot anim ) ) { return themes columns . boot anim uri ; } else if ( component . equals ( mixn match columns . key font ) ) { return themes columns . font uri ; } else if ( component . equals ( mixn match columns . key icons ) ) { return themes columns . icon uri ; } else if ( component . equals ( mixn match columns . key status bar ) ) { return themes columns . statusbar uri ; } else if ( component . equals ( mixn match columns . key notifications ) ) { throw new illegal argument exception ( str ) ; } else if ( component . equals ( mixn match columns . key ringtone ) ) { throw new illegal argument exception ( str ) ; } else if ( component . equals ( mixn match columns . key overlays ) ) { return themes columns . overlays uri ; } else if ( component . equals ( mixn match columns . key alarm ) ) { throw new illegal argument exception ( str ) ; } else if ( component . equals ( mixn match columns . key navigation bar ) ) { throw new illegal argument exception ( str ) ; } else if ( component . equals ( mixn match columns . key live lock screen ) ) { throw new illegal argument exception ( str ) ; } return null ; }	for a given key value in the mixnmatch table , return the column associated with it in the themes table.
public boolean is abstract ( ) { return modifier . is abstract ( method . get modifiers ( ) ) ; }	returns true for an abstract method .
private static void parse copy fields ( parse context context , field mapper field mapper , list < string > copy to fields ) throws io { if ( ! context . is within copy to ( ) && copy to fields . is empty ( ) == bool ) { context = context . create copy to context ( ) ; for ( string field : copy to fields ) { parse context . document target doc = null ; for ( parse context . document doc = context . doc ( ) ; doc != null ; doc = doc . get parent ( ) ) { if ( field . starts with ( doc . get prefix ( ) ) ) { target doc = doc ; break ; } } assert target doc != null ; final parse context copy to context ; if ( target doc == context . doc ( ) ) { copy to context = context ; } else { copy to context = context . switch doc ( target doc ) ; } parse copy ( field , copy to context ) ; } } }	creates instances of the fields that the current field should be copied to.
protected file create obb file ( string name , int raw res id ) { file out file = null ; try { final file files dir = m context . get files dir ( ) ; out file = new file ( files dir , name ) ; copy raw to file ( raw res id , out file ) ; } catch ( not found exception e ) { if ( out file != null ) { out file . delete ( ) ; } } return out file ; }	creates an obb file ( with the given name ) , into the app ' s standard files directory.
public play sound entity ( string sound , int radius , int volume ) { this . sounds = sound . split ( str ) ; this . radius = radius ; this . volume = volume ; }	creates a new playsoundentity.
public repository ( string domain ) { this ( domain , bool ) ; }	construct a new repository with the given default domain .
private void update view ( int view position ) { notify item changed ( view position ) ; }	update the contents of a view ( i.
public static string optimize ( string ... args ) { return simple tag ( str , args ) ; }	helper that returns an & lt ; optimize & gt ; string with optional key / val pairs .
protected boolean is valid server ( final string server ) { boolean is valid = check server prefixes ( server ) ; if ( is valid ) { if ( server . starts with ( str ) ) { is valid = can connect ( server ) ; } else if ( server . starts with ( str ) ) { is valid = is directory ( server ) ; } } return is valid ; }	returns whether the given server can be connected to .
public concurrent hash map ( map < ? extends k , ? extends v > m ) { this ( math . max ( ( int ) ( m . size ( ) / default load factor ) + num , default initial capacity ) , default load factor , default concurrency level ) ; put all ( m ) ; }	creates a new map with the same mappings as the given map.
public map maker expiration ( long duration , time unit unit ) { if ( expiration nanos != num ) { throw new illegal state exception ( str + expiration nanos + str ) ; } if ( duration <= num ) { throw new illegal argument exception ( str + duration ) ; } this . expiration nanos = unit . to nanos ( duration ) ; use custom map = bool ; return this ; }	specifies that each entry should be automatically removed from the map once a fixed duration has passed since the entry ' s creation .
void init from node ( final node from node , final double start time , final pseudo remove priority queue < node > pending nodes ) { dijkstra node data data = get data ( from node ) ; visit node ( from node , data , pending nodes , start time , num , null ) ; }	initializes the first node of a route .
public collection < html > tokenize html ( ) { list < html > tokens = new array list < html > ( ) ; string nested tags = nested tags regex ( num ) ; pattern p = pattern . compile ( str + str + str + str + str + nested tags + str , pattern . case insensitive ) ; matcher m = p . matcher ( text ) ; int last pos = num ; while ( m . find ( ) ) { if ( last pos < m . start ( ) ) { tokens . add ( html . text ( text . substring ( last pos , m . start ( ) ) ) ) ; } tokens . add ( html . tag ( text . substring ( m . start ( ) , m . end ( ) ) ) ) ; last pos = m . end ( ) ; } if ( last pos < text . length ( ) ) { tokens . add ( html . text ( text . substring ( last pos , text . length ( ) ) ) ) ; } return tokens ; }	parse html tags , returning a collection of htmltoken objects .
public int decrypt block ( byte [ ] in , int in off , byte [ ] out , int out off ) throws data length exception , illegal state exception { if ( ( in off + block size ) > in . length ) { throw new data length exception ( str ) ; } if ( ( out off + block size ) > out . length ) { throw new data length exception ( str ) ; } cipher . process block ( cfb v , num , cfb out v , num ) ; system . arraycopy ( cfb v , block size , cfb v , num , cfb v . length - block size ) ; system . arraycopy ( in , in off , cfb v , cfb v . length - block size , block size ) ; for ( int i = num ; i < block size ; i ++ ) { out [ out off + i ] = ( byte ) ( cfb out v [ i ] ^ in [ in off + i ] ) ; } return block size ; }	do the appropriate processing for cfb mode decryption .
private string compute md5 hash ( string buffer ) { message digest md ; try { md = message digest . get instance ( str ) ; return bytes to hex ( md . digest ( buffer . get bytes ( str ) ) ) ; } catch ( no such algorithm exception ignore ) { } catch ( unsupported encoding exception e ) { } return str ; }	needed for the digest access authentication .
public void run ( ) throws io , interrupted exception { for ( int i = num ; i < conn cnt ; i ++ ) exec . submit ( new client thread ( ) ) ; thread . sleep ( num * num * num ) ; exec . shutdown now ( ) ; }	runs single benchamark configuration .
public static string pluralize ( string word ) { if ( word == null ) { throw new illegal argument exception ( ) ; } final string lower case word = word . to lower case ( ) ; if ( ends with any ( lower case word , str , str , str ) ) { return word + str ; } if ( lower case word . ends with ( str ) && ! lower case word . ends with ( str ) || ends with any ( lower case word , str , str , str ) ) { return word . substring ( num , word . length ( ) - num ) + str ; } else { return word + str ; } }	get the plural for the given english word .
protected void on network type change ( network info old network , network info new network ) throws router exception { log . info ( string . format ( str , old network == null ? str : old network . get type name ( ) , new network == null ? str : new network . get type name ( ) ) ) ; if ( disable ( ) ) { log . info ( string . format ( str , old network == null ? str : old network . get type name ( ) ) ) ; } network info = new network ; if ( enable ( ) ) { log . info ( string . format ( str , new network == null ? str : new network . get type name ( ) ) ) ; } }	can be overriden by subclasses to do additional work .
private linked hash map < term , integer > repeating terms ( ) { linked hash map < term , integer > tord = new linked hash map < > ( ) ; hash map < term , integer > tcnt = new hash map < > ( ) ; for ( phrase positions pp : phrase positions ) { for ( term t : pp . terms ) { integer cnt0 = tcnt . get ( t ) ; integer cnt = cnt0 == null ? new integer ( num ) : new integer ( num + cnt0 . int value ( ) ) ; tcnt . put ( t , cnt ) ; if ( cnt == num ) { tord . put ( t , tord . size ( ) ) ; } } } return tord ; }	find repeating terms and assign them ordinal values.
public list < inet address > discover hosts ( int udp port , int timeout millis ) { list < inet address > hosts = new array list < inet address > ( ) ; datagram socket socket = null ; try { socket = new datagram socket ( ) ; broadcast ( udp port , socket ) ; socket . set so timeout ( timeout millis ) ; while ( bool ) { datagram packet packet = new datagram packet ( new byte [ num ] , num ) ; try { socket . receive ( packet ) ; } catch ( socket timeout exception ex ) { if ( info ) info ( str , str ) ; return hosts ; } if ( info ) info ( str , str + packet . get address ( ) ) ; hosts . add ( packet . get address ( ) ) ; } } catch ( io ex ) { if ( error ) error ( str , str , ex ) ; return hosts ; } finally { if ( socket != null ) socket . close ( ) ; } }	broadcasts a udp message on the lan to discover any running servers .
protected void reload cluster configuration ( ) { synchronized ( this . cluster ) { load cluster configuration ( ) ; } }	reload configuration for this cluster .
public double expected utility ( nondominated population population ) { double sum = num ; for ( int i = num ; i < weights . length ; i ++ ) { double max = double . negative infinity ; for ( solution solution : population ) { max = math . max ( max , utility function . compute utility ( solution , weights [ i ] ) ) ; } sum += max ; } return sum / weights . length ; }	computes the expected utility for the given population .
public void count ( hash map < string , tree map < string , integer > > table , string suffix , string tag ) { tree map < string , integer > counts = table . get ( suffix ) ; if ( counts == null ) { counts = new tree map < string , integer > ( ) ; table . put ( suffix , counts ) ; } integer count = counts . get ( tag ) ; if ( count == null ) count = num ; counts . put ( tag , count + num ) ; }	increments the count for the given suffix and tag .
public void add input mode ( string mode , string [ ] [ ] input chars ) { modes map . put ( mode , input chars ) ; }	add an input mode to the virtual keyboard.
public static void sleep ( int msec ) throws interrupted exception { thread . sleep ( msec ) ; }	description of the method.
public void property change ( property change event pce ) { if ( pce . get property name ( ) == om . loaders property ) { object obj = pce . get new value ( ) ; if ( obj instanceof vector ) { vector < edit tool loader > loaders = ( vector < edit tool loader > ) obj ; set loaders ( loaders . iterator ( ) ) ; reset gui ( ) ; } } }	propertychangelistener method , to listen for the omdrawingtool ' s list of loaders that may or may not change .
public void remove app offer ( offer offer ) { int index to remove = get index ( offer ) ; if ( index to remove != - num ) { app offers . remove ( index to remove ) ; notify data set changed ( ) ; } }	remove an appoffer from the binder when user adds to base plan.
public data transform ( data data , xml xc ) throws transform exception { return spi . transform ( data , xc ) ; }	transforms the specified data using the underlying transform algorithm .
public static double quantile ( double val , double mu , double sigma , double xi ) { if ( val < num || val > num ) { return double . n ; } if ( xi == num ) { return mu - sigma * math . log ( num - val ) ; } return mu - sigma / xi * ( num - math . pow ( num - val , - xi ) ) ; }	quantile function of gpd distribution.
oath device settings create device profile ( int min shared secret length ) { reject . if false ( min shared secret length >= num , str ) ; int shared secret byte length = math . max ( min shared secret byte length , ( int ) math . ceil ( min shared secret length / num ) ) ; byte [ ] secret bytes = new byte [ shared secret byte length ] ; secure random . next bytes ( secret bytes ) ; string shared secret = datatype converter . print hex binary ( secret bytes ) ; return new oath device settings ( shared secret , device name , initial last login time , initial counter value ) ; }	creates and saves a fresh device profile for the given user.
public final void delete selected objects ( ) { component [ ] components = get components ( ) ; list < display node > graph nodes = new array list < > ( ) ; list < i > graph edges = new array list < > ( ) ; for ( component comp : components ) { if ( comp instanceof display node ) { if ( ! is delete variables allowed ( ) ) { continue ; } display node node = ( display node ) comp ; if ( node . is selected ( ) ) { graph nodes . add ( node ) ; } } else if ( comp instanceof i ) { i edge = ( i ) comp ; if ( edge . is selected ( ) ) { graph edges . add ( edge ) ; } } } for ( display node graph node : graph nodes ) { remove node ( graph node ) ; } for ( i display edge : graph edges ) { try { remove edge ( display edge ) ; reset edge offsets ( display edge ) ; } catch ( exception e ) { if ( is node edge errors reported ( ) ) { j . show message dialog ( j . centering comp ( ) , e . get message ( ) ) ; } } } }	deletes all selected nodes in the workbench plus any edges that have had one of their nodes deleted in the process .
protected final void init statistics ( string who , string [ ] header lines ) throws ade exception { set stats file path ( ) ; if ( stats file path == null ) { throw new ade internal exception ( str ) ; } append stat string ( spacer ) ; append stat string ( string . format ( str , current time stamp ( ) , who ) ) ; append stat string ( spacer ) ; for ( int i = num ; i < header lines . length ; i ++ ) { append stat string ( header lines [ i ] ) ; } append stat string ( spacer ) ; }	method to create a new dedicated stats file for this instance , and to insert the input headerlines as first content to that text file .
protected void add class path ( string classpath ) { if ( classpath == null ) return ; string sep = classpath . index of ( str ) == - num ? str : str ; string [ ] parse cp = classpath . split ( sep ) ; for ( string cp entry : parse cp ) { add entry ( cp entry ) ; } }	add classpath with path separator.
@ inject entry uploader impl ( entry inserter entry inserter , entry provider entry provider , entry updater entry updater ) { this . entry inserter = check not null ( entry inserter ) ; this . entry provider = check not null ( entry provider ) ; this . entry updater = check not null ( entry updater ) ; }	creates a new entryuploaderimpl with the given dependencies .
protected void add ( long bytes in , long bytes out ) { total bytes in . add and get ( bytes in ) ; total bytes out . add and get ( bytes out ) ; }	adds the input / output byes of a compression .
public static double vector distance ( double [ ] vec1 , double [ ] vec2 , double power , double one over power ) { double result = num ; if ( power == num ) { for ( int i = num ; i < vec1 . length ; i ++ ) { result += vec1 [ i ] - vec2 [ i ] == num ? num : num ; } } else if ( power == num ) { for ( int i = num ; i < vec1 . length ; i ++ ) { result += math . abs ( vec1 [ i ] - vec2 [ i ] ) ; } } else if ( power == num ) { result = math . sqrt ( dist squared cartesian ( vec1 , vec2 ) ) ; } else if ( power == integer . max value || double . is infinite ( power ) ) { for ( int i = num ; i < vec1 . length ; i ++ ) { result = math . max ( result , math . max ( vec1 [ i ] , vec2 [ i ] ) ) ; } } else { for ( int i = num ; i < vec1 . length ; i ++ ) { result += math . pow ( vec1 [ i ] - vec2 [ i ] , power ) ; } result = math . pow ( result , one over power ) ; } return result ; }	calculate the p - norm ( i.
public static float [ ] random vector ( int a size , long seed ) { random rand = new random ( seed ) ; float [ ] unk = new float [ a size ] ; for ( int i = num ; i < unk . length ; i ++ ) { unk [ i ] = ( rand . next float ( ) - num ) / a size ; } return unk ; }	create a random vector.
public boolean was raw ( ) { return was raw ; }	returns true if the type was raw , that is , type arguments were not provided but instead inferred .
public table find table ( string catalog name , string schema name , string table name , boolean case sensitive ) { string cache key = catalog name + str + schema name + str + table name + str + case sensitive ; integer table index = table index cache . get ( cache key ) ; if ( table index != null ) { if ( table index < get table count ( ) ) { table table = get table ( table index ) ; if ( does match ( table , catalog name , schema name , table name , case sensitive ) ) { return table ; } } } table [ ] tables = get tables ( ) ; for ( int i = num ; i < tables . length ; i ++ ) { table table = tables [ i ] ; if ( does match ( table , catalog name , schema name , table name , case sensitive ) ) { table index cache . put ( cache key , i ) ; return table ; } } return null ; }	catalog & schema aware finder for ddlutils database class.
public void test domain matches on local addresses ( ) { assert false ( http cookie . domain matches ( str , str ) ) ; assert false ( http cookie . domain matches ( str , str ) ) ; }	rfc 2109 and rfc 2965 disagree here.
public void flush ( ) { write data block ( ) ; }	used to dump any data contained in memory to disk .
protected crfp [ ] vector to crfp ( vector vector ) { int size = vector . size ( ) ; crfp [ ] rets = new crfp [ size ] ; for ( int i = num ; i < size ; i ++ ) { rpf coverage box box = ( rpf coverage box ) vector . element at ( i ) ; if ( box != null ) { rets [ i ] = new crfp ( ( float ) box . nw lat , ( float ) box . nw lon , ( float ) box . se lat , ( float ) box . se lon , box . subframe lat interval , box . subframe lon interval , box . chart code , ( short ) box . zone , new xy ( ( short ) box . start indexes . x , ( short ) box . start indexes . y ) , new xy ( ( short ) box . end indexes . x , ( short ) box . end indexes . y ) , ( short ) box . toc number , ( short ) box . entry number , box . scale , box . percent coverage ) ; } } return rets ; }	convert a vector of rpfcoveragebox to a crfpcoveragebox array .
public void notify listeners of initialization ( ) { if ( initialized ) { for ( action listener l : listeners ) { l . action performed ( new action event ( this , action event . action performed , str ) ) ; } } }	notifies all the listeners that initialization is finished.
public void check password ( string password ) throws bad request exception { if ( password == null ) { throw new bad request exception ( str ) ; } if ( password . length ( ) < num ) { throw new bad request exception ( str ) ; } int num of letters = num ; int num of digits = num ; for ( char password char : password . to char array ( ) ) { if ( character . is digit ( password char ) ) { num of digits ++ ; } else if ( character . is letter ( password char ) ) { num of letters ++ ; } } if ( num of digits == num || num of letters == num ) { throw new bad request exception ( str ) ; } }	checks whether password is ok .
final node < k , v > find ( int h , object k ) { if ( k != null ) { for ( node < k , v > e = first ; e != null ; ) { int s ; k ek ; if ( ( ( s = lock state ) & ( waiter | writer ) ) != num ) { if ( e . hash == h && ( ( ek = e . key ) == k || ( ek != null && k . equals ( ek ) ) ) ) return e ; e = e . next ; } else if ( u . compare and swap int ( this , lockstate , s , s + reader ) ) { tree node < k , v > r , p ; try { p = ( ( r = root ) == null ? null : r . find tree node ( h , k , null ) ) ; } finally { thread w ; if ( u . get and add int ( this , lockstate , - reader ) == ( reader | waiter ) && ( w = waiter ) != null ) lock support . unpark ( w ) ; } return p ; } } } return null ; }	returns matching node or null if none.
public synchronized boolean remove suspended response ( worker category category , response response ) { deque < response > deque = workers by category . get ( category ) ; if ( deque == null ) { return bool ; } if ( deque . remove ( response ) ) { n waiting consumers -= num ; log . debug ( str ) ; return bool ; } return bool ; }	when we notice that a long poll connection has closed , we remove it here .
public static number sin ( number a ) { return math . sin ( a . double value ( ) ) ; }	returns the trigonometric sine of the number .
private typed class operation instantiate operation types ( typed class operation operation ) { list < type variable > type parameters = operation . get type parameters ( ) ; if ( type parameters . is empty ( ) ) { return operation ; } substitution < reference type > substitution = select substitution ( type parameters ) ; if ( substitution == null ) { return null ; } return operation . apply ( substitution ) ; }	selects an instantiation of the generic types of an operation , and returns a new operation with the types instantiated .
default t fold ( final t identity , final binary operator < t > accumulator ) { final optional < t > opt = to optional ( ) ; if ( opt . is present ( ) ) return accumulator . apply ( identity , get ( ) ) ; return identity ; }	use the supplied identity value and function to reduce this value to a single result ( unwraps the value stored in this value if the provided monoid combination instance obeys the monoid laws ).
protected void load ( string filename , properties p ) throws file not found exception { file file = new file ( filename ) ; if ( ! file . exists ( ) ) throw new file not found exception ( filename ) ; classifier = new crf < core label > ( p ) ; try { classifier . load classifier ( file , p ) ; } catch ( class cast exception e ) { e . print stack trace ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } catch ( class not found exception e ) { e . print stack trace ( ) ; } }	load a serialized model .
public string resolve font ( java . awt . font font ) { string ret = str ; ret = ret . concat ( str + font . get name ( ) ) ; if ( font . is bold ( ) ) ret = ret . concat ( str ) ; else ret = ret . concat ( str ) ; if ( font . is italic ( ) ) ret = ret . concat ( str ) ; else ret = ret . concat ( str ) ; ret = ret . concat ( str ) ; ret = ret . concat ( str + font . get size ( ) ) ; ret = ret . concat ( str ) ; ret = ret . concat ( str ) ; ret = ret . concat ( str ) ; ret = ret . concat ( str ) ; ret = ret . concat ( str ) ; ret = ret . concat ( str ) ; return ret ; }	in the idl , fonts are represented by a string.
public void add line content ( final zy line content line ) { preconditions . check not null ( line , str ) ; m content . add ( line ) ; }	adds another line add the end of the label content .
public static boolean exclude by package ( string pkg , list < string > exclude pkg ) { for ( string ep : exclude pkg ) { if ( pkg . matches ( ep ) ) { return bool ; } } return bool ; }	compare a package with a list of packages to determine whether the package should be excluded or not .
public region version holder ( long ver ) { this . version = ver ; }	this contructor should only be used for cloning a regionversionholder or initializing and invalid version holder ( with version - 1 ).
public static void write fully ( file channel file , long pos , byte buffer src ) { try { int off = num ; do { int len = file . write ( src , pos + off ) ; off += len ; } while ( src . remaining ( ) > num ) ; } catch ( io e ) { throw new illegal state exception ( error writing failed , str , file , src . remaining ( ) , pos , e ) ; } }	write to a file channel .
public void update request timeout ( time span span ) throws security exception , application exception { check write access ( ) ; boolean has access = config web util . has access ( config , security manager . type setting ) ; if ( ! has access ) throw new security exception ( str ) ; element scope = get root element ( str ) ; element application = get root element ( str ) ; if ( span != null ) { if ( span . get millis ( ) <= num ) throw new application exception ( str ) ; application . set attribute ( str , span . get day ( ) + str + span . get hour ( ) + str + span . get minute ( ) + str + span . get second ( ) ) ; } else application . remove attribute ( str ) ; if ( scope . has attribute ( str ) ) scope . remove attribute ( str ) ; }	updates request timeout value.
@ override protected boolean calc problem ( ) { string type = get tag with key ( tags . key type ) ; if ( type == null || type . equals ( str ) ) { return bool ; } return super . calc problem ( ) ; }	test if the relation has a problem .
public int read byte ( ) throws io { ++ length ; return in . read ( ) & num ; }	read the next byte from the inputstream .
public void update shape shadows to current time ( boolean update minutes , boolean update hours , int current minute , int current hour ) { if ( update minutes ) { int tens = ( int ) math . floor ( current minute / num ) ; int units = ( int ) math . floor ( current minute % num ) ; if ( minutes tens . get current value ( ) != tens ) { string mt = string . format ( str , tens ) ; mt = mt . concat ( str ) ; log . d ( tag , str + mt ) ; minutes tens . parse json ( mt ) ; } if ( minutes units . get current value ( ) != units ) { string mu = string . format ( str , units ) ; mu = mu . concat ( str ) ; log . d ( tag , str + mu ) ; minutes units . parse json ( mu ) ; } } if ( update hours ) { int tens = ( int ) math . floor ( current hour / num ) ; int units = ( int ) math . floor ( current hour % num ) ; if ( hours tens . get current value ( ) != tens ) { string ht = string . format ( str , tens ) ; ht = ht . concat ( str ) ; log . d ( tag , str + ht ) ; hours tens . parse json ( ht ) ; } if ( hours units . get current value ( ) != units ) { string hu = string . format ( str , units ) ; hu = hu . concat ( str ) ; log . d ( tag , str + hu ) ; hours units . parse json ( hu ) ; } } }	updates the shadows of the numbers to the current time.
public set < raw protein < super family hmmer3 raw match > > parse ( input stream is ) throws io { map < string , raw protein < super family hmmer3 raw match > > data = new hash map < string , raw protein < super family hmmer3 raw match > > ( ) ; buffered reader reader = null ; try { reader = new buffered reader ( new input stream reader ( is ) ) ; string line ; while ( ( line = reader . read line ( ) ) != null ) { set < super family hmmer3 raw match > raw matches = parse line ( line ) ; super family hmmer3 raw match raw match ; for ( super family hmmer3 raw match raw matche : raw matches ) { raw match = raw matche ; string sequence id = raw match . get sequence identifier ( ) ; if ( data . contains key ( sequence id ) ) { raw protein < super family hmmer3 raw match > raw protein = data . get ( sequence id ) ; raw protein . add match ( raw match ) ; } else { raw protein < super family hmmer3 raw match > raw protein = new raw protein < super family hmmer3 raw match > ( sequence id ) ; raw protein . add match ( raw match ) ; data . put ( sequence id , raw protein ) ; } } } } finally { if ( reader != null ) { reader . close ( ) ; } } return new hash set < raw protein < super family hmmer3 raw match > > ( data . values ( ) ) ; }	parse the temporary file.
public string relation name ( ) { return m ; }	returns the relation ' s name .
@ request mapping ( value = str , method = request method . post , produces = media type . text plain value ) @ timed public response entity < ? > change password ( @ request body string password ) { if ( ! check password length ( password ) ) { return new response entity < > ( str , http status . bad request ) ; } user service . change password ( password ) ; return new response entity < > ( http status . ok ) ; }	post / account / change_password : changes the current user ' s password.
public void test bad segment ( ) throws io { directory dir = new directory ( ) ; index writer iw = new index writer ( dir , new index writer config ( new mock analyzer ( random ( ) ) ) ) ; document document = new document ( ) ; field type custom type = new field type ( text field . type not stored ) ; custom type . set store term vectors ( bool ) ; document . add ( new field ( str , str , custom type ) ) ; iw . add document ( document ) ; iw . close ( ) ; dir . close ( ) ; }	test that no nullpointerexception will be raised , when adding one document with a single , empty field and term vectors enabled .
public static int size ( string str ) { if ( str == null ) return num ; int length = str . length ( ) ; int size = length ; try { size = str . get bytes ( str ) . length ; } catch ( unsupported encoding exception e ) { log . log ( level . severe , str , e ) ; } return size ; }	size of string in bytes.
protected void synch with target ( ) throws monitor exception { long time limit = system . current time millis ( ) + sync wait ms ; log ( str + lvmid + str ) ; while ( ! prologue . is accessible ( ) ) { log ( str ) ; try { thread . sleep ( num ) ; } catch ( interrupted exception e ) { } if ( system . current time millis ( ) > time limit ) { logln ( str + lvmid ) ; throw new monitor exception ( str ) ; } } logln ( str + lvmid ) ; }	method that waits until the target jvm indicates that its shared memory is safe to access .
public static char sequence time ( context context , easy cursor c ) { long now = system . current time millis ( ) ; long when = c . get long ( reviews . written on ) ; return now - when > minute in millis ? date utils . get relative time span string ( when , now , num , format abbrev all ) : context . get string ( r . string . recent time ) ; }	get when the review was written .
private double screen to normalized ( float screen coord ) { int width = get width ( ) ; if ( width <= num * padding ) { return num ; } else { double result = ( screen coord - padding ) / ( width - num * padding ) ; return math . min ( num , math . max ( num , result ) ) ; } }	converts screen space x - coordinates into normalized values .
public long round trip time ( ) throws interrupted exception { latch . await ( ) ; return received - sent ; }	returns the round trip time for this ping in nanoseconds , waiting for the response to arrive if necessary.
static private string user id from range ( string [ ] values , boolean include ) { int min id = integer . parse int ( values [ num ] ) ; int max id = integer . parse int ( values [ num ] ) ; string exclusions = values . length > num ? values [ num ] : null ; stack < integer > stack = get stack ( min id , max id , exclusions , include ) ; if ( stack . size ( ) > num ) { return integer . to string ( stack . pop ( ) ) ; } throw new illegal argument exception ( str ) ; }	generate a random user id as an integer.
public void test case4 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num } ; byte r bytes [ ] = { - num , - num , - num , - num , - num , - num , - num } ; int a sign = - num ; int b sign = num ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . add ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , result . signum ( ) ) ; }	add two numbers of the same length.
public void actualiza campo ( int tipo ficha , vo campo ) { vo campo anterior = retrieve ( tipo ficha , campo . get tipo ( ) , campo . get id objeto ( ) , campo . get id campo ( ) , campo . get orden ( ) , campo . get tipo elemento ( ) ) ; if ( campo anterior == null ) insert ( tipo ficha , campo ) ; else update ( tipo ficha , campo , campo anterior . get valor info ( ) ) ; }	actualiza el campo de la ficha .
public static int length ( reg exp re ) { reg exp2 r ; switch ( re . type ) { case sym . bar : { r = ( reg exp2 ) re ; int l1 = length ( r . r1 ) ; if ( l1 < num ) return - num ; int l2 = length ( r . r2 ) ; if ( l1 == l2 ) return l1 ; else return - num ; } case sym . concat : { r = ( reg exp2 ) re ; int l1 = length ( r . r1 ) ; if ( l1 < num ) return - num ; int l2 = length ( r . r2 ) ; if ( l2 < num ) return - num ; return l1 + l2 ; } case sym . star : case sym . plus : case sym . question : return - num ; case sym . cclass : case sym . cclassnot : case sym . char : case sym . char i : return num ; case sym . string : case sym . string i : { string content = ( string ) ( ( reg exp1 ) re ) . content ; return content . length ( ) ; } case sym . tilde : case sym . bang : return - num ; case sym . macrouse : return length ( macros . get definition ( ( string ) ( ( reg exp1 ) re ) . content ) ) ; } throw new error ( str + re . type + str + re ) ; }	returns length if expression has fixed length , - 1 otherwise.
public static time zone random time zone ( random random ) { string tz ids [ ] = time zone . get available i ( ) ; return time zone . get time zone ( tz ids [ random . next int ( tz ids . length ) ] ) ; }	return a random timezone from the available timezones on the system.
public static string array to list ( string [ ] array , string delimiter ) { if ( array util . is empty ( array ) ) return str ; string builder sb = new string builder ( array [ num ] ) ; if ( delimiter . length ( ) == num ) { char c = delimiter . char at ( num ) ; for ( int i = num ; i < array . length ; i ++ ) { sb . append ( c ) ; sb . append ( array [ i ] ) ; } } else { for ( int i = num ; i < array . length ; i ++ ) { sb . append ( delimiter ) ; sb . append ( array [ i ] ) ; } } return sb . to string ( ) ; }	convert a string array to string list.
@ override public boolean add all ( collection < ? extends e > c ) { iterator < ? extends e > i = c . iterator ( ) ; boolean changed = bool ; while ( i . has next ( ) ) { boolean ret = add ( i . next ( ) ) ; if ( ! changed ) { changed = ret ; } } return changed ; }	add all of the elements in the given collection to this list .
public void reset ( ) { m codes . clear ( ) ; m is first char capitalized = bool ; m preferred word = null ; m typed word . set length ( num ) ; m caps count = num ; }	clear out the keys registered so far .
private string extract path ( final string uri ) { return default wildcard stream locator . strip query path ( uri . replace ( prefix , string utils . empty ) ) ; }	replaces the protocol specific prefix and removes the query path if it exist , since it should not be accepted .
public void add classes to check ( file basedir , string ... relative names ) throws io { add classes to check ( basedir , arrays . as list ( relative names ) ) ; }	parses and adds a multiple class files .
public static short to short ( string str ) throws page exception { return short . value of ( to short value ( str ) ) ; }	cast a object to a byte object ( reference type ).
public void test read xml lang new style ( ) throws exception { properties result = xml to properties ( str ) ; assert not null ( result ) ; assert true ( ! result . is empty ( ) ) ; assert equals ( num , result . size ( ) ) ; assert equals ( str , result . get property ( str ) ) ; }	new ( and correct ) style xml : lang value is en - au.
public boolean has permission ( security security , generic value user login ) { return order read helper . has permission ( security , user login , order header ) ; }	checks to see if this user has read permission on this order.
protected boolean filter files ( list < file > files ) { if ( task . get no mtime check ( ) || is output repository url ( ) ) { return bool ; } iterator < file > iter = files . iterator ( ) ; while ( iter . has next ( ) ) { file file = iter . next ( ) ; module module = infer module ( file ) ; if ( module == null ) { task . log ( str + file , project . msg verbose ) ; continue ; } if ( module . get version ( ) == null ) { task . log ( str + module . get name ( ) , project . msg verbose ) ; continue ; } long oldest = get artifact file time ( module , file ) ; if ( oldest == long . max value ) { file out module dir = get artifact dir ( module ) ; oldest = oldest output artifact ( long . max value , out module dir ) ; task . log ( str + module + str + new date ( oldest ) , project . msg debug ) ; } else { task . log ( str + file + str + module + str + new date ( oldest ) , project . msg debug ) ; } long newest file = file . last modified ( ) ; task . log ( str + file + str + new date ( newest file ) , project . msg debug ) ; if ( newest file != long . min value && oldest != long . max value && newest file < oldest ) { task . log ( str + file + str ) ; iter . remove ( ) ; } } return files . size ( ) == num ; }	filters out all the source files which appear to not require compilation based on comparison of file modification times.
public void flush ( ) { output stream . flush ( ) ; }	clears all buffers for the current writer and causes any buffered data to be written to the underlying device .
public int create measures ( msla goal ) { string sql = str + str + str + str + str + str + str + str + str + m . id + str ; int counter = num ; prepared statement pstmt = null ; result set rs = null ; try { pstmt = db . prepare statement ( sql , null ) ; pstmt . set int ( num , goal . get c b id ( ) ) ; pstmt . set int ( num , goal . get pa sla id ( ) ) ; rs = pstmt . execute query ( ) ; while ( rs . next ( ) ) { int m id = rs . get int ( num ) ; big decimal measure actual = rs . get big decimal ( num ) ; timestamp movement date = rs . get timestamp ( num ) ; string description = rs . get string ( num ) + str + rs . get timestamp ( num ) ; if ( goal . is date valid ( movement date ) ) { msla measure = new msla ( goal , movement date , measure actual , description ) ; measure . set link ( m . id , m id ) ; if ( measure . save ( ) ) counter ++ ; } } } catch ( exception e ) { log . log ( level . severe , str , e ) ; } finally { db . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } return counter ; }	create new measures for the goal.
@ override public string resolve video url ( @ nullable final video video , step step ) { if ( video == null ) return null ; string local path = database facade . get path to video if exist ( video ) ; if ( local path != null && check existing on disk ( local path , step ) ) { return local path ; } else { list < video url > url list = video . get urls ( ) ; if ( url list == null || url list . size ( ) == num ) return null ; return resolve from web ( url list ) ; } }	don ' t call in main thread.
protected object lookup service ( ) throws exception { object service = null ; service template templ ; if ( template == null ) { class < ? > [ ] types = ( service class == null ? null : new class [ ] { service class } ) ; entry [ ] entry = ( service name == null ? null : new entry [ ] { new name ( service name ) } ) ; templ = new service template ( null , types , entry ) ; } else { templ = template ; } lookup locator [ ] lookup locators = null ; if ( locators != null ) { lookup locators = new lookup locator [ locators . length ] ; for ( int i = num ; i < locators . length ; i ++ ) { string locator = locators [ i ] ; if ( ! locator . starts with ( str ) ) { locator = str + locator ; } lookup locators [ i ] = new lookup locator ( locator ) ; } } service discovery manager service discovery = null ; try { service discovery = shared discovery management . get backwards service discovery manager ( groups , lookup locators , null ) ; service item return object = service discovery . lookup ( templ , null , timeout ) ; if ( return object != null ) { service = return object . service ; } } finally { if ( service discovery != null ) { try { service discovery . terminate ( ) ; } catch ( exception e ) { logger . warn ( str , e ) ; } } } return service ; }	a helper method to lookup the service .
public static boolean equals ( final object obj1 , final object obj2 ) { return ( obj1 != null && obj1 . equals ( obj2 ) ) ; }	determines whether 2 objects are equal in value.
public void test merge same filter with init param in two documents ( ) throws exception { string src xml = str + str + str + str + str + str + str + str + str + str + str + str + str + str ; web xml src web xml = web xml io . parse web xml ( new byte array input stream ( src xml . get bytes ( str ) ) , null ) ; string merge xml = str + str + str + str + str + str + str + str + str + str + str + str + str + str ; web xml merge web xml = web xml io . parse web xml ( new byte array input stream ( merge xml . get bytes ( str ) ) , null ) ; web xml merger merger = new web xml merger ( src web xml ) ; merger . merge filters ( merge web xml ) ; assert true ( web xml utils . has filter ( src web xml , str ) ) ; list < string > filter init param names = web xml utils . get filter init param names ( src web xml , str ) ; assert true ( filter init param names . size ( ) == num ) ; assert equals ( str , filter init param names . get ( num ) ) ; list < string > filter mappings = web xml utils . get filter mappings ( src web xml , str ) ; assert equals ( num , filter mappings . size ( ) ) ; assert equals ( str , filter mappings . get ( num ) ) ; }	tests whether the same filter in two different files is mapped correctly ( i.
public webapp template loader ( servlet context servlet context , string subdir path ) { if ( servlet context == null ) { throw new illegal argument exception ( str ) ; } if ( subdir path == null ) { throw new illegal argument exception ( str ) ; } subdir path = subdir path . replace ( str , str ) ; if ( ! subdir path . ends with ( str ) ) { subdir path += str ; } if ( ! subdir path . starts with ( str ) ) { subdir path = str + subdir path ; } this . subdir path = subdir path ; this . servlet context = servlet context ; }	creates a template loader that will use the specified servlet context to load the resources.
@ suppress warnings ( { str } ) public static < t > t [ ] insert ( t [ ] dest , t src , int offset , class component type ) { t [ ] temp = ( t [ ] ) array . new instance ( component type , dest . length + num ) ; system . arraycopy ( dest , num , temp , num , offset ) ; temp [ offset ] = src ; system . arraycopy ( dest , offset , temp , offset + num , dest . length - offset ) ; return temp ; }	inserts one element into another array .
@ override public void flush ( ) throws io { writer . write ( buffer , num , fill ) ; fill = num ; }	flushes the internal buffer but does not flush the wrapped writer .
public metric instance with dependency metric names ( list < string > dependency metric names ) { return new metric instance ( metric name , maker , dependency metric names . to array ( new string [ dependency metric names . size ( ) ] ) ) ; }	makes a copy of the metric instance with new dependencymetricnames .
public static i validate method name ( string name ) { return validate method name ( name , compiler options . version 1 3 , compiler options . version 1 3 ) ; }	validate the given method name.
@ suppress warnings ( str ) void notify alarm clock ( timer alarm clock notification notification ) { timer notification timer notification = null ; date timer date = null ; timer alarm clock alarm clock = ( timer alarm clock ) notification . get source ( ) ; synchronized ( timer . this ) { for ( object [ ] obj : timer table . values ( ) ) { if ( obj [ alarm clock index ] == alarm clock ) { timer notification = ( timer notification ) obj [ timer notif index ] ; timer date = ( date ) obj [ timer date index ] ; break ; } } } send notification ( timer date , timer notification ) ; update timer table ( timer notification . get notification id ( ) ) ; }	this method is called by the timer each time the timeralarmclock has exceeded its timeout .
public profiler entity start ( ) { start time = system . nano time ( ) ; return this ; }	start the entity . call this when you are ready to start measuring . returns itself for easy chaining .
public static < e extends enum < e > > enum set < e > of ( e e1 , e e2 , e e3 ) { enum set < e > set = of ( e1 , e2 ) ; set . add ( e3 ) ; return set ; }	creates a new enum set , containing only the specified elements.
public pick request with camera pics directory ( @ nullable final file p dir file ) { this . m custom camera pics dir path = p dir file == null ? null : p dir file . get absolute path ( ) ; return this ; }	set a directory to which pictures taken by camera will be saved . useful only when camera is a pick source.
public void prepare for next run ( ) { for ( int i = num ; i < num ; i ++ ) { system . gc ( ) ; try { thread . sleep ( num ) ; } catch ( interrupted exception e ) { e . print stack trace ( ) ; } } }	try to give gc some time to settle down .
public void add ( chip chip ) { if ( ! m chip list . contains ( chip ) || m tolerating duplicate ) { m chip list . add ( chip ) ; notify update ( ) ; } }	wrapper to add a chip.
private boolean check trip zone consistency ( ) { log . info ( str ) ; hash set < string > missing zones = new hash set < string > ( ) ; for ( trip t : trips . values ( ) ) { basic location zo = zones . get location ( id . create ( t . zone o , zone . class ) ) ; basic location zd = zones . get location ( id . create ( t . zone d , zone . class ) ) ; if ( zo == null ) { missing zones . add ( t . zone o ) ; } if ( zd == null ) { missing zones . add ( t . zone d ) ; } } if ( missing zones . size ( ) > num ) { string msg = missing zones . size ( ) + str ; for ( string s : missing zones ) msg += str + s . to string ( ) + str ; log . error ( msg ) ; return bool ; } else log . info ( str ) ; return bool ; }	checks that all trips start and end in zones represented in the zones file .
private int insert index for layer ( component comp , int layer , int position ) { int i , count , cur layer ; int layer start = - num ; int layer end = - num ; int component count = get component count ( ) ; array list < component > comp list = new array list < component > ( component count ) ; for ( int index = num ; index < component count ; index ++ ) { if ( get component ( index ) != comp ) { comp list . add ( get component ( index ) ) ; } } count = comp list . size ( ) ; for ( i = num ; i < count ; i ++ ) { cur layer = get layer ( comp list . get ( i ) ) ; if ( layer start == - num && cur layer == layer ) { layer start = i ; } if ( cur layer < layer ) { if ( i == num ) { layer start = num ; layer end = num ; } else { layer end = i ; } break ; } } if ( layer start == - num && layer end == - num ) return count ; if ( layer start != - num && layer end == - num ) layer end = count ; if ( layer end != - num && layer start == - num ) layer start = layer end ; if ( position == - num ) return layer end ; if ( position > - num && layer start + position <= layer end ) return layer start + position ; return layer end ; }	this method is an extended version of insertindexforlayer ( ) to support setlayer which uses container.
public void test timed invoke all2 ( ) throws interrupted exception { executor service e = new fork join pool ( num ) ; pool cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; list < future < string > > r = e . invoke all ( new array list < callable < string > > ( ) , medium delay ms , milliseconds ) ; assert true ( r . is empty ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }	timed invokeall ( empty collection ) returns empty collection.
public static wait dialog show dialog ( wait dialog . runnable runnable , string message , container container , int width , int height ) { wait dialog new dialog = null ; if ( container instanceof j ) { new dialog = new wait dialog ( ( j ) container ) ; } else if ( container instanceof j ) { new dialog = new wait dialog ( ( j ) container ) ; } else { new dialog = new wait dialog ( ( j ) null ) ; new dialog . set location relative to ( container ) ; } new dialog . build dialog ( width , height ) ; runnable . set dialog ( new dialog ) ; new dialog . container = container ; new dialog . runnable = runnable ; new dialog . set message ( message ) ; thread process thread = new process thread ( new dialog ) ; process thread . start ( ) ; while ( ! new dialog . is visible ( ) ) { try { thread . sleep ( num ) ; } catch ( interrupted exception ie ) { } } return new dialog ; }	will display message in a modal jdialog while in the run method of runnable . will set the location of the jdialog relative to container.
public void test flip bit positive outside2 ( ) { byte a bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = num ; int number = num ; byte r bytes [ ] = { num , - num , num , num , num , num , num , num , num , num , num , num , num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . flip bit ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	flipbit ( int n ) outside a positive number.
public synchronized void write ( byte b [ ] , int off , int len ) throws io { if ( len <= num ) return ; int free space = buffer . length - pos ; if ( len <= free space ) { system . arraycopy ( b , off , buffer , pos , len ) ; pos += len ; return ; } flush ( ) ; int local requested ; while ( bool ) { synchronized ( lock ) { while ( ( local requested = requested ) < num && ! disconnected ) { try { lock . wait ( ) ; } catch ( interrupted exception e ) { } } if ( disconnected ) throw new io ( str ) ; } if ( local requested < len ) { manager . send transmit ( info , b , off , local requested ) ; off += local requested ; len -= local requested ; synchronized ( lock ) { requested -= local requested ; } } else { manager . send transmit ( info , b , off , len ) ; synchronized ( lock ) { requested -= len ; } break ; } } }	write a subarray of bytes over connection .
protected alarm ( ) { this ( str ) ; }	create a new wakeup alarm with a designated listener as a callback.
public void remove mouse mode ( map mouse mode med ) { boolean need to adjust active mode = bool ; if ( med == null ) { return ; } if ( med . equals ( active mouse mode ) ) { need to adjust active mode = bool ; set inactive ( med ) ; } for ( map mouse mode check mm : mouse modes ) { if ( med . equals ( check mm ) ) { med . remove all map mouse listeners ( ) ; } else if ( need to adjust active mode ) { set active ( check mm ) ; need to adjust active mode = bool ; } } mouse modes . remove ( med ) ; fire property change ( mouse modes property , null , mouse modes ) ; }	removes a particular mapmousemode from the mousemode list .
@ override public boolean has dispatch function ( ) { return bool ; }	cbus does not have a dispatch function.
public void add map ( map < k , v > map , k min , k max ) { if ( min != null && max != null && key type . compare ( min , max ) > num ) { data utils . new illegal argument exception ( str , min , max ) ; } int len = shards . length + num ; shard < k , v > [ ] new shards = arrays . copy of ( shards , len ) ; shard < k , v > new shard = new shard < k , v > ( ) ; new shard . map = map ; new shard . min including = min ; new shard . max excluding = max ; new shards [ len - num ] = new shard ; shards = new shards ; }	add the given shard .
private void retry failed interfaces ( ) { for ( iterator i = failed interfaces . iterator ( ) ; i . has next ( ) ; ) { network interface nic = ( network interface ) i . next ( ) ; try { if ( nic != null ) { socket . set network interface ( nic ) ; } socket . join group ( request addr ) ; i . remove ( ) ; level l = multicast interfaces specified ? level . info : level . fine ; if ( logger . is loggable ( l ) ) { if ( nic != null ) { logger . log ( l , str , new object [ ] { nic } ) ; } else { logger . log ( l , str ) ; } } } catch ( io e ) { } } }	attempts to configure each interface contained in the failedinterfaces list , removing it from the list if configuration succeeds.
public void write header ( ) throws io { flv flv header = new flv ( ) ; flv header . set flag audio ( bool ) ; flv header . set flag video ( bool ) ; byte buffer header = byte buffer . allocate ( header length + num ) ; flv header . write ( header ) ; file . set length ( header length + num ) ; if ( header . has array ( ) ) { log . debug ( str ) ; file . write ( header . array ( ) ) ; } else { log . debug ( str ) ; byte [ ] tmp = new byte [ header length + num ] ; header . get ( tmp ) ; file . write ( tmp ) ; } bytes written = file . length ( ) ; header . clear ( ) ; }	writes the header bytes.
public static future < ? > submit ( runnable task ) { return thread pool . submit ( task ) ; }	submits a runnable task for execution and returns a future representing that task .
public boolean add overlay ( overlay overlay , kml document kml doc ) { if ( overlay == null ) return bool ; kml feature kml item ; if ( overlay instanceof ground overlay ) { kml item = new kml ground overlay ( ( ground overlay ) overlay ) ; } else if ( overlay instanceof folder overlay ) { kml item = new kml folder ( ( folder overlay ) overlay , kml doc ) ; } else if ( overlay instanceof marker clusterer ) { kml item = new kml folder ( ( marker clusterer ) overlay , kml doc ) ; } else if ( overlay instanceof marker ) { marker marker = ( marker ) overlay ; kml item = new kml placemark ( marker ) ; } else if ( overlay instanceof polygon ) { polygon polygon = ( polygon ) overlay ; kml item = new kml placemark ( polygon , kml doc ) ; } else if ( overlay instanceof polyline ) { polyline polyline = ( polyline ) overlay ; kml item = new kml placemark ( polyline , kml doc ) ; } else { return bool ; } m items . add ( kml item ) ; return bool ; }	converts the overlay to a kmlfeature and add it inside this.
private < t extends sb > t look for resource ( sb type , class < t > clazz ) { list < t > resources = look for resources ( type , clazz ) ; return resources != null && resources . size ( ) > num ? resources . get ( num ) : null ; }	find one resource by type.
private object produce event ( ) throws invocation target exception { if ( ! valid ) { throw new illegal state exception ( to string ( ) + str ) ; } try { return method . invoke ( target ) ; } catch ( illegal access exception e ) { throw new assertion error ( e ) ; } catch ( invocation target exception e ) { if ( e . get cause ( ) instanceof error ) { throw ( error ) e . get cause ( ) ; } throw e ; } }	invokes the wrapped producer method .
private list < float > create dash array ( string dash string ) { string [ ] dashes = dash string . split ( str ) ; list < float > float dash array = new array list < float > ( ) ; for ( string dash value : dashes ) { try { float dash array . add ( float . parse float ( dash value ) ) ; } catch ( number format exception e ) { return null ; } } return float dash array ; }	creates the dash array .
public void clean patch by version ( string version name ) { if ( patch directory == null || version name == null ) { return ; } string path = patch directory . get absolute path ( ) + str + version name ; share patch file util . delete dir ( path ) ; }	clean the patch version files , such as tinker / patch - 641e634c.
public static boolean is valid java class name ( string input ) { if ( ! string utils . has text ( input ) ) { return bool ; } if ( ! character . is java identifier start ( input . char at ( num ) ) ) { return bool ; } if ( input . length ( ) > num ) { for ( int i = num ; i < input . length ( ) ; i ++ ) { if ( ! character . is java identifier part ( input . char at ( i ) ) ) { return bool ; } } } return bool ; }	utility method to check if a string can be used as a valid class name.
public void test create empty ( ) { final string id = str ; final map < string , object > metadata = new hash map < string , object > ( ) ; metadata . put ( file metadata schema . id , id ) ; metadata . put ( str , str ) ; final int version = repo . create ( metadata ) ; metadata . put ( file metadata schema . version , integer . value of ( version ) ) ; assert equals ( str , num , version ) ; repository document impl doc = ( repository document impl ) repo . read ( id ) ; assert true ( str , doc . exists ( ) ) ; assert equals ( str , version , doc . get version ( ) ) ; assert not same ( str , num , doc . get version create time ( ) ) ; assert equals ( str , doc . get version create time ( ) , doc . get earliest version create time ( ) ) ; assert equals ( str , doc . get version create time ( ) , doc . get metadata update time ( ) ) ; map < string , object > actual = doc . as map ( ) ; assert equals ( str , id , actual . get ( file metadata schema . id ) ) ; assert equals ( str , version , actual . get ( file metadata schema . version ) ) ; assert equals ( str , str , actual . get ( str ) ) ; assert equals ( str , metadata . size ( ) , actual . size ( ) ) ; }	create an empty file and verify its metadata .
public static string rename ( string desc , string oldname , string newname ) { if ( desc . index of ( oldname ) < num ) return desc ; string buffer newdesc = new string buffer ( ) ; int head = num ; int i = num ; for ( ; ; ) { int j = desc . index of ( str , i ) ; if ( j < num ) break ; else if ( desc . starts with ( oldname , j + num ) && desc . char at ( j + oldname . length ( ) + num ) == str ) { newdesc . append ( desc . substring ( head , j ) ) ; newdesc . append ( str ) ; newdesc . append ( newname ) ; newdesc . append ( str ) ; head = i = j + oldname . length ( ) + num ; } else { i = desc . index of ( str , j ) + num ; if ( i < num ) break ; } } if ( head == num ) return desc ; else { int len = desc . length ( ) ; if ( head < len ) newdesc . append ( desc . substring ( head , len ) ) ; return newdesc . to string ( ) ; } }	substitutes a class name in the given descriptor string .
public void sort ( int att index ) { double [ ] vals = new double [ num instances ( ) ] ; instance [ ] backup = new instance [ vals . length ] ; for ( int i = num ; i < vals . length ; i ++ ) { instance inst = instance ( i ) ; backup [ i ] = inst ; double val = inst . value ( att index ) ; if ( utils . is missing value ( val ) ) { vals [ i ] = double . max value ; } else { vals [ i ] = val ; } } int [ ] sort order = utils . sort with no missing values ( vals ) ; for ( int i = num ; i < vals . length ; i ++ ) { m . set ( i , backup [ sort order [ i ] ] ) ; } }	sorts the instances based on an attribute.
private static byte v ( jni env , int obj jref , int method id , address arg address ) throws exception { if ( trace jni ) vm . sys write ( str ) ; runtime entrypoints . check jni gc ( ) ; try { object obj = env . get jni ( obj jref ) ; object return obj = jni . invoke with var arg ( obj , method id , arg address , type reference . byte , bool ) ; return reflection . unwrap byte ( return obj ) ; } catch ( throwable unexpected ) { if ( trace jni ) unexpected . print stack trace ( system . err ) ; env . record exception ( unexpected ) ; return num ; } }	callbytemethodv : invoke a virtual method that returns a byte value.
public boolean adjust entry ( e entry ) { final spatial directory entry se = ( spatial directory entry ) entry ; final modifiable hyper bounding box mbr = compute mbr ( ) ; boolean changed = bool ; if ( se . has mbr ( ) ) { final int dim = se . get dimensionality ( ) ; for ( int i = num ; i < dim ; i ++ ) { if ( math . abs ( se . get min ( i ) - mbr . get min ( i ) ) > float . min normal ) { changed = bool ; break ; } if ( math . abs ( se . get max ( i ) - mbr . get max ( i ) ) > float . min normal ) { changed = bool ; break ; } } } else { changed = bool ; } if ( changed ) { se . set mbr ( mbr ) ; } return changed ; }	adjusts the parameters of the entry representing this node .
private void trace object ( object reference object , boolean root ) { if ( verbose ) { trace . trace ( item . sanity , str , object model . get string ( object ) ) ; } if ( object . is null ( ) ) return ; boolean marked = black set . contains ( object ) ; if ( ! marked ) { black set . add ( object ) ; mark stack . add ( object ) ; } visitor . visit object ( object , root , marked ) ; }	trace an object , calling the appropriate visitor method.
private static int compare ( int from index , char sequence left , char sequence right ) { if ( left == null ) return - num ; if ( right == null ) return num ; for ( int i = from index , n = math lib . min ( left . length ( ) , right . length ( ) ) ; i < n ; i ++ ) { char c1 = character . to upper case ( left . char at ( i ) ) ; char c2 = character . to upper case ( right . char at ( i ) ) ; if ( c1 != c2 ) return c1 - c2 ; } return left . length ( ) - right . length ( ) ; }	compares the two characters sequences starting at the specified index.
public boolean restore accessibility focus ( calendar day day ) { if ( ( day . year != m year ) || ( day . month != m month ) || ( day . day > m num cells ) ) { return bool ; } m touch helper . set focused virtual view ( day . day ) ; return bool ; }	attempts to restore accessibility focus to the specified date .
@ override public int hash code ( ) { if ( hash == num ) { int result = num ; result = num * result + range . hash code ( ) ; long bits weight = double . double to long bits ( weight ) ; result = num * result + ( int ) ( bits weight ^ ( bits weight > > > num ) ) ; hash = result ; } return hash ; }	returns a hash code value for the object .
@ override public void on click ( view v ) { int position = math . min ( ( integer ) v . get tag ( ) , m item list . size ( ) - num ) ; m selected tracker = m item list . get ( position ) ; m toggle config handler . show for selected toggle ( ) ; m toggle config handler . show at location ( v ) ; m toggle config handler . set arrow position ( v ) ; }	called when a toggle button is clicked .
private int read from data source ( byte [ ] target , int offset , int length , int bytes already read , boolean allow end of input ) throws interrupted exception , io { if ( thread . interrupted ( ) ) { throw new interrupted exception ( ) ; } int bytes read = data source . read ( target , offset + bytes already read , length - bytes already read ) ; if ( bytes read == c . result end of input ) { if ( bytes already read == num && allow end of input ) { return c . result end of input ; } throw new eof ( ) ; } return bytes already read + bytes read ; }	starts or continues a read from the data source .
public explanation explain ( int doc , explanation freq ) throws io { return explanation . match ( score ( doc , freq . get value ( ) ) , str + doc + str + freq . get value ( ) + str , collections . singleton ( freq ) ) ; }	explain the score for a single document.
public static stack < string > split parts ( string name ) { while ( name . starts with ( str ) ) name = name . substring ( num ) ; stack < string > parts = new stack < > ( ) ; int last = num ; int pos = num ; string part ; while ( bool ) { pos = last ; while ( bool ) { pos = name . index of ( str , pos ) ; if ( pos < num ) break ; if ( name . char at ( pos - num ) == str ) ++ pos ; else break ; } if ( pos < num ) break ; part = name . substring ( last , pos ) ; if ( ! part . ends with ( str ) ) part += str ; parts . add ( part ) ; last = pos + num ; } part = name . substring ( last ) ; if ( ! part . ends with ( str ) ) part += str ; parts . add ( part ) ; return parts ; }	splits a som name in the individual parts .
public set < soot method > collect source methods ( ) { set < soot method > result = new hash set < soot method > ( ) ; for ( source call chain info cci : entry points ) { collect source methods ( cci , result ) ; } return result ; }	returns a set of source methods included in the source call tree .
public void test precision and scale ( ) throws exception { test precision for type ( str , num , - num , bool ) ; test precision for type ( str , num , - num , bool ) ; test precision for type ( str , num , - num , bool ) ; test precision for type ( str , num , - num , bool ) ; test precision for type ( str , num , - num , bool ) ; test precision for type ( str , num , - num , bool ) ; test precision for type ( str , num , - num , bool ) ; test precision for type ( str , num , - num , bool ) ; test precision for type ( str , num , - num , bool ) ; test precision for type ( str , num , - num , bool ) ; test precision for type ( str , num , num , bool ) ; test precision for type ( str , num , num , bool ) ; test precision for type ( str , num , num , bool ) ; test precision for type ( str , num , num , bool ) ; test precision for type ( str , num , num , bool ) ; test precision for type ( str , num , num , bool ) ; test precision for type ( str , num , num , bool ) ; test precision for type ( str , num , num , bool ) ; }	tests that resultsetmetadata precision and scale methods work correctly for all numeric types .
public void register ( named bean s ) { string system name = s . get system name ( ) ; tsys . put ( system name , s ) ; string user name = s . get user name ( ) ; if ( user name != null ) { tuser . put ( user name , s ) ; } fire property change ( str , null , integer . value of ( tsys . size ( ) ) ) ; s . add property change listener ( this , str , str ) ; }	remember a namedbean object created outside the manager.
protected void expand for ( int i1 , int i2 , double d ) { if ( i1 >= sizes . size ( ) ) { int old size = sizes . size ( ) , capacity = vector . length ; sizes . set ( i1 , num ) ; if ( capacity < sizes . size ( ) ) { while ( capacity < sizes . size ( ) ) capacity *= num ; double [ ] [ ] t = new double [ capacity ] [ ] ; system . arraycopy ( vector , num , t , num , old size ) ; vector = t ; } for ( int i = old size ; i < sizes . size ( ) ; ++ i ) vector [ i ] = new double [ default capacity2 ] ; } if ( i2 < sizes . get ( i1 ) ) return ; int old size = sizes . get ( i1 ) , capacity = vector [ i1 ] . length ; sizes . set ( i1 , i2 + num ) ; if ( capacity >= sizes . get ( i1 ) ) return ; while ( capacity < sizes . get ( i1 ) ) capacity *= num ; double [ ] t = new double [ capacity ] ; system . arraycopy ( vector [ i1 ] , num , t , num , old size ) ; if ( d != num ) arrays . fill ( t , old size , sizes . get ( i1 ) , d ) ; vector [ i1 ] = t ; }	makes sure the capacities and sizes of the vectors can accomodate the given indexes.
public v put ( final k k , final v v ) { final weak reference < v > ref = new weak ref ( k , v , reference queue ) ; final weak reference < v > old ref = map . put ( k , ref ) ; final v old val = old ref == null ? null : old ref . get ( ) ; if ( queue . add ( v ) && debug ) { log . debug ( str + k + str + v ) ; } did update ( k , ref , old ref ) ; return old val ; }	adds the key - value mapping to the cache .
static void delay ( long millis ) throws interrupted exception { long nanos = millis * ( num * num ) ; final long wakeup time = system . nano time ( ) + nanos ; do { if ( millis > num ) thread . sleep ( millis ) ; else thread . yield ( ) ; nanos = wakeup time - system . nano time ( ) ; millis = nanos / ( num * num ) ; } while ( nanos >= num ) ; }	delays , via thread.
public void delete ( int key ) { int i = container helpers . binary search ( m keys , m size , key ) ; if ( i >= num ) { system . arraycopy ( m keys , i + num , m keys , i , m size - ( i + num ) ) ; system . arraycopy ( m values , i + num , m values , i , m size - ( i + num ) ) ; m size -- ; } }	removes the mapping from the specified key , if there was any .
public page object context peek ( ) { return deque . peek ( ) ; }	return top context from the queue , without removing it .
protected void write namespace ( string prefix , string uri ) throws io { if ( ( prefix != null ) && ( prefix . length ( ) > num ) ) { writer . write ( str ) ; writer . write ( prefix ) ; writer . write ( str ) ; } else { writer . write ( str ) ; } writer . write ( uri ) ; writer . write ( str ) ; }	writes the sax namepsaces.
public static void wait some time ( int seconds ) { try { thread . sleep ( seconds * num ) ; } catch ( interrupted exception e ) { } }	waits a few seconds .
public void encode ( string value , byte buffer buffer ) throws buffer overflow exception { if ( value == null ) { buffer . put ( ( byte ) ( num ) ) ; return ; } int char count = value . length ( ) ; if ( char count == num ) { buffer . put ( ( byte ) ( num | num ) ) ; return ; } int position = buffer . position ( ) ; boolean ascii = bool ; if ( char count > num ) { for ( int i = num ; i < char count ; i ++ ) { int c = value . char at ( i ) ; if ( c > num ) { ascii = bool ; break ; } buffer . put ( ( byte ) c ) ; } } else { ascii = bool ; } if ( ascii ) { position = buffer . position ( ) ; buffer . put ( position - num , ( byte ) ( buffer . get ( position - num ) | num ) ) ; } else { buffer . position ( position ) ; write length ( char count + num , buffer ) ; int char index = num ; for ( ; char index < char count ; char index ++ ) { int c = value . char at ( char index ) ; if ( c > num ) break ; buffer . put ( ( byte ) c ) ; } write ut ( value , char count , char index , buffer ) ; } }	encode the string to the buffer , null and empty string is allowable.
public void test bug71672 statement ( int test step , connection test conn , string query , int expected update count , int [ ] expected keys ) throws sql { statement test stmt = test conn . create statement ( ) ; if ( expected update count < num ) { assert false ( test step + str , test stmt . execute ( query , statement . return generated keys ) ) ; } else { assert equals ( test step + str , expected update count , test stmt . execute update ( query , statement . return generated keys ) ) ; } result set test rs = test stmt . get generated keys ( ) ; for ( int k : expected keys ) { assert true ( test step + str , test rs . next ( ) ) ; assert equals ( test step + str , k , test rs . get int ( num ) ) ; } assert false ( test step + str , test rs . next ( ) ) ; test rs . close ( ) ; test stmt . close ( ) ; }	check the update count and returned keys for an insert query using a statement object.
public static path impl lookup ( string url ) { path impl pwd = get pwd ( ) ; if ( ! url . starts with ( str ) ) { return pwd . lookup ( url , null ) ; } else { return pwd . lookup ( url , null ) ; } }	returns a new path relative to the current directory .
public static xml now ( ) { return get xml ( null ) ; }	gets the current date / time as an xmlgregoriancalendar with the default time zone in the default locale .
protected void add scalar dimension ( int i ) { for ( dimension dimension : dimension list ) { if ( dimension . get dimension ( ) == i ) { return ; } } dimension list . add ( new dimension ( i ) ) ; }	add a dimension object .
public void initialize ( ) { texture state ts = new texture state ( ) ; ts . set enabled ( bool ) ; set render state ( ts ) ; for ( int i = num ; i < line set list . size ( ) ; ++ i ) { line set state state = line set list . get ( i ) ; add line set ( state , bool ) ; } z buffer state = new z ( ) ; z buffer state . set function ( z . test function . less than or equal to ) ; z buffer state . set enabled ( bool ) ; set render state ( z buffer state ) ; }	initialize this linesets object.
protected boolean reg exp region matches ( string text , int t start , string p , int p start , int plen ) { while ( plen -- > num ) { char tchar = text . char at ( t start ++ ) ; char pchar = p . char at ( p start ++ ) ; if ( ! this . f ignore wild cards ) { if ( pchar == f single wild card ) { continue ; } } if ( pchar == tchar ) { continue ; } if ( this . f ignore case ) { if ( character . to upper case ( tchar ) == character . to upper case ( pchar ) ) { continue ; } if ( character . to lower case ( tchar ) == character . to lower case ( pchar ) ) { continue ; } } return bool ; } return bool ; }	check for a match in a certain region .
public static void init keys ( key store keystore , properties props ) { if ( props . contains key ( configuration . webcall kafka aes ) ) { byte [ ] key = keystore . decode key ( props . get property ( configuration . webcall kafka aes ) ) ; preconditions . check argument ( ( num == key . length || num == key . length || num == key . length ) , configuration . webcall kafka aes + str ) ; keystore . set key ( key store . aes kafka webcall , key ) ; aes key = key ; } if ( props . contains key ( configuration . webcall kafka mac ) ) { byte [ ] key = keystore . decode key ( props . get property ( configuration . webcall kafka mac ) ) ; preconditions . check argument ( ( num == key . length ) , configuration . webcall kafka mac + str ) ; keystore . set key ( key store . siphash kafka webcall , key ) ; siphash key = key ; } }	extract the required keys if they exist.
public static boolean is empty ( string builder str ) { return is null ( str ) || str . length ( ) <= num ; }	returns true if the str is empty , false otherwise .
public static gas register ( gas gas ) { if ( gas == null ) { return null ; } registered gasses . add ( gas ) ; return get gas ( gas . get name ( ) ) ; }	register a new gas into gasregistry .
@ override public boolean lock ( ) { try { lock path = zk . create ( this . lock type folder + carbon common constants . file separator + lock name , null , ids . open acl unsafe , create mode . ephemeral sequential ) ; list < string > nodes = zk . get children ( this . lock type folder , null ) ; collections . sort ( nodes ) ; if ( lock path . ends with ( nodes . get ( num ) ) ) { return bool ; } else { zk . delete ( lock path , - num ) ; return bool ; } } catch ( keeper exception | interrupted exception e ) { logger . error ( e , e . get message ( ) ) ; return bool ; } }	handling of the locking mechanism using zoo keeper .
@ override protected void key typed ( char par1 , int par2 ) { token box . textbox key typed ( par1 , par2 ) ; if ( par2 == num || par2 == num ) action performed ( ( gui button ) button list . get ( num ) ) ; }	fired when a key is typed.
private static boolean is alphanumeric ( final string label ) { boolean status = bool ; if ( string utils . is not empty ( label ) ) { matcher matcher = pattern alphanumeric . matcher ( label ) ; status = matcher . matches ( ) ; } return status ; }	validates if a label contains only alphanumeric values.
final static string trim uri ( url src , string sub ) { final string s = src . to external form ( ) ; final int end index = s . last index of ( sub ) ; final string t = s . substring ( num , end index ) ; return t ; }	convenience method to prune last substring occurance from url .
@ override public string global info ( ) { return str + str + str ; }	returns a string describing this result listener.
public boolean remove row ( int row ) { if ( m rows . is valid row ( row ) ) { fire table event ( row , row , table model event . all columns , table model event . delete ) ; m tuples . invalidate ( row ) ; m rows . release row ( row ) ; for ( iterator cols = get columns ( ) ; cols . has next ( ) ; ) { column c = ( column ) cols . next ( ) ; c . revert to default ( row ) ; } return bool ; } return bool ; }	removes a row from this table .
private boolean is parsable to double ( string i ) { return i . matches ( str ) ; }	quick method to test for a string , in a method to shield the exception from the caller .
protected string [ ] init paths from properties ( string raw paths ) { string [ ] ret paths = null ; if ( raw paths != null ) { try { string tokenizer token = new string tokenizer ( raw paths , file . path separator ) ; int num paths = token . count tokens ( ) ; ret paths = new string [ num paths ] ; for ( int i = num ; i < num paths ; i ++ ) { ret paths [ i ] = token . next token ( ) ; } return ret paths ; } catch ( java . util . no such element exception e ) { e . print stack trace ( ) ; } } return ret paths ; }	takes a string of file.
private void register default validator ids ( application application , linked hash set < string > default validator ids ) { if ( default validator ids == null ) { default validator ids = new linked hash set < > ( ) ; if ( is bean validator available ( ) ) { web configuration web config = web configuration . get instance ( ) ; if ( ! web config . is option enabled ( web configuration . boolean web context init parameter . disable default bean validator ) ) { default validator ids . add ( bean validator . validator id ) ; } } } for ( string validator id : default validator ids ) { if ( logger . is loggable ( level . fine ) ) { logger . log ( level . fine , message format . format ( str , validator id ) ) ; } application . add default validator id ( validator id ) ; } }	if defaultvalidatorids is null , then no & lt ; default - validators & gt ; element appeared in any configuration file.
protected void initialize location ( v v , d coord ) { point point = locations . get ( v ) ; coord . set location ( point . x , point . y ) ; }	sets persisted location for a vertex within the dimensions of the space.
public static date parse date ( string date str ) { string format string = str ; if ( date str . length ( ) == num ) date str = date str . substring ( num , num ) ; if ( date str . length ( ) == num ) format string = str ; if ( date str . length ( ) == num ) format string = str ; simple date format formatter = new simple date format ( format string ) ; parse position pos = new parse position ( num ) ; return formatter . parse ( date str , pos ) ; }	returns a date object from a string .
@ suppress warnings ( str ) private void do unload ( marked project marked project , n4 progress state recorder rec ) throws js { if ( create debug output ) { println ( str + marked project . project ) ; } rec . mark start unloading ( marked project ) ; for ( resource res : marked project . resources ) { rec . mark unloading of ( res ) ; res . unload ( ) ; } rec . mark finished unloading ( marked project ) ; }	unload all referenced resources .
public void write file ( array list < dcc loco address > consist list , string file name ) throws io { element root = new element ( str ) ; document doc = new document ( root , dtd location + str ) ; map < string , string > m = new hash map < string , string > ( ) ; m . put ( str , str ) ; m . put ( str , xslt location + str ) ; processing instruction p = new processing instruction ( str , m ) ; doc . add content ( num , p ) ; element roster = new element ( str ) ; for ( int i = num ; i < consist list . size ( ) ; i ++ ) { consist new consist = consist man . get consist ( consist list . get ( i ) ) ; roster . add content ( consist to xml ( new consist ) ) ; } root . add content ( roster ) ; try { if ( ! check file ( file name ) ) { file file = new file ( file name ) ; file parent dir = file . get parent file ( ) ; if ( ! parent dir . exists ( ) ) { if ( ! parent dir . mkdir ( ) ) { throw ( new io ( ) ) ; } } if ( ! file . create new file ( ) ) { throw ( new io ( ) ) ; } } write xml ( find file ( file name ) , doc ) ; } catch ( io ioe ) { log . error ( str + ioe ) ; throw ( ioe ) ; } }	write all consists to a file .
public void train ( reader a reader ) throws io { buffered reader in = new buffered reader ( a reader ) ; string line = in . read line ( ) ; while ( line != null ) { matcher m = word pattern . matcher ( line . to lower case ( ) ) ; while ( m . find ( ) ) { string word = m . group ( ) ; atomic integer count = n words . get ( word ) ; if ( count == null ) { count = new atomic integer ( num ) ; n words . put ( word , count ) ; } count . increment and get ( ) ; } line = in . read line ( ) ; } }	read words from the given reader and count their occurrences .
private void start client ( ) { if ( flume client != null && ! flume client . is active ( ) ) { flume client . close ( ) ; flume client = null ; } if ( flume client == null ) { try { flume client = rpc client factory . get default instance ( flume host name , flume port , max span batch size ) ; } catch ( flume exception e ) { log . warn ( str + e . get message ( ) ) ; } } }	create / reconnect flume rpc client.
public void vspan ( long start , long end , paint color , string legend ) { legend text legend text = new legend text ( color , legend ) ; comments . add ( legend text ) ; plot elements . add ( new v ( start , end , color , legend text ) ) ; }	draws a vertical span into the graph and optionally adds a legend .
public void on draw ( canvas canvas , int center x , int center y ) { if ( ! m visible ) { return ; } m arc bounds = new f ( center x - m progress radius , center y - m progress radius , center x + m progress radius , center y + m progress radius ) ; canvas . draw circle ( center x , center y , m progress radius , m progress base paint ) ; canvas . draw arc ( m arc bounds , - num , m progress angle degrees , bool , m progress paint ) ; if ( m progress angle degrees == num && system . current time millis ( ) > m time to hide ) { m visible = bool ; if ( m visibility listener != null ) { m visibility listener . on hidden ( ) ; } } }	draw the current progress ( if < 100 % ) centered at the given location .
public boolean check ( ) { return ( m != null ) && ( m != null ) && m . exists ( ) ; }	performs a check whether this setup is valid .
public static list < long > z score test ( geo time serie gts , boolean use median , double d ) throws warp script exception { double check ( gts ) ; list < long > anomalous ticks = new array list < long > ( ) ; double [ ] musigma = madsigma ( gts , use median ) ; double m = musigma [ num ] ; double std = musigma [ num ] ; if ( num == std ) { return anomalous ticks ; } for ( int i = num ; i < gts . values ; i ++ ) { double z = ( gts . double values [ i ] - m ) / std ; if ( math . abs ( z ) >= d ) { anomalous ticks . add ( gts . ticks [ i ] ) ; } } return anomalous ticks ; }	applying z - score test if usemedian is true , then use modified z - score .
private void append ( print writer pw , final string k , final string v ) { if ( v != null ) { pw . println ( k + str + v ) ; } }	appends ' k : v ' to pw if v is non null .
default b with default ( string key , object value ) { return with default ( key , value != null ? value . to string ( ) : null ) ; }	if there is no field with the specified key , then associate the given value with the specified key .
private void skip whitespace ( ) { matcher . use pattern ( whitespace ) ; if ( matcher . looking at ( ) ) { matcher . region ( matcher . end ( ) , matcher . region end ( ) ) ; } }	skip over any whitespace so that the matcher region starts at the next token .
protected void create dynamic style for components ( final text field tag name , final text area tag desc , final string taregt tag color ) { tag name . remove style name ( spui . tag name ) ; tag desc . remove style name ( spui . tag desc ) ; get target dynamic styles ( taregt tag color ) ; tag name . add style name ( tag name dynamic style ) ; tag desc . add style name ( tag desc dynamic style ) ; }	set tag name and desc field border color based on chosen color .
public void calculate scores ( ) { score = num ; if ( contents . length == num ) { api api = api . v ( ) ; set < info kind > source = api . get source info kinds ( method ) ; set < info kind > sink = api . get sink info kinds ( method ) ; if ( is system ( method ) ) { if ( api . is safe method ( method ) ) score = num ; else if ( api . is spec method ( method ) ) score = num ; else if ( api . is banned method ( method ) ) score = num ; if ( ! source . is empty ( ) ) score += num ; else if ( ! sink . is empty ( ) ) score += num ; } return ; } for ( call chain info cci : contents ) { cci . calculate scores ( ) ; calls += cci . calls ; syscalls += cci . syscalls ; if ( cci . score > score ) score = cci . score ; } }	calculate the score for each entry in the call chain.
public < t > json array < t > create list dto from json ( string json , class < t > dto interface ) { final dto provider < t > dto provider = get dto provider ( dto interface ) ; final list < json element > list = gson . from json ( json , list type cache . get unchecked ( json element . class ) ) ; final list < t > result = new array list < > ( list . size ( ) ) ; for ( json element e : list ) { result . add ( dto provider . from json ( e ) ) ; } return new json array impl < > ( result ) ; }	parses the json data from the specified sting into list of objects of the specified type .
public void start consumption ( multi threaded batch processor < t , tl > processor ) ;	called once at the start of processing.
public static long long for query ( sq db , string query , string [ ] selection args ) { sq prog = db . compile statement ( query ) ; try { return long for query ( prog , selection args ) ; } finally { prog . close ( ) ; } }	utility method to run the query on the db and return the value in the first column of the first row .
public void test one one ( ) { string num a = str ; string num b = str ; string res = str ; big integer a number = new big integer ( num a ) ; big integer b number = new big integer ( num b ) ; big integer result = a number . xor ( b number ) ; assert true ( res . equals ( result . to string ( ) ) ) ; }	xor for one and one.
public string to string ( ) { string s = str + ids . to string ( ) + str ; return ( s ) ; }	return printable form of the object .
@ override public void remove ( string ... identifiers ) { whitelist . remove all ( arrays . as list ( identifiers ) ) ; }	removes identifiers from the serialization strategy .
public commafier ( final string initial ) { m separator = default separator ; sb . append ( initial ) ; }	creates a commafier object that starts with an initial string .
public void write ( file file ) throws io { print writer pw = new print writer ( new output stream writer ( new file output stream ( file ) , str ) , bool ) ; if ( from dir != null ) { pw . println ( str + from dir + str + from ext ) ; } string str = null ; for ( int i = num ; i < b list . size ( ) ; i ++ ) { str = ( string ) ( b list . element at ( i ) ) ; pw . println ( str ) ; } }	write the basenamelist to a file .
private void log ( i status ) { resources plugin . log ( status ) ; }	adds an entry to the log of this plug - in for the given status.
static private string builder replace ( string builder input , java . util . regex . pattern pattern , string replacement ) { java . util . regex . matcher m = pattern . matcher ( input ) ; while ( m . find ( ) ) { if ( is escaped char ( input . to string ( ) , m . start ( ) ) ) { continue ; } input . replace ( m . start ( ) , m . end ( ) , replacement ) ; m . reset ( input ) ; } return input ; }	replaces strings matching a pattern with another string.
public static multisig aggregate modification transaction create multisig modification ( ) { return new multisig aggregate modification transaction ( time instant . zero , utils . generate random account ( ) , collections . singleton list ( new multisig cosignatory modification ( multisig modification type . add cosignatory , utils . generate random account ( ) ) ) ) ; }	creates a multisig aggregate modification .
public static boolean is jar cache enabled default ( ) { return is jar cache enabled ; }	returns true if jar entries should be cached .
public void test write flush update ( ) { final journal store = ( journal ) get store ( ) ; try { rw buffer strategy = ( rw ) store . get buffer strategy ( ) ; final int nbytes = num ; byte [ ] a = new byte [ nbytes ] ; r . next bytes ( a ) ; final long addr = buffer strategy . write ( byte buffer . wrap ( a ) ) ; assert equals ( nbytes , store . get byte count ( addr ) ) ; store . commit ( ) ; { final byte buffer b = buffer strategy . read ( addr ) ; assert not null ( b ) ; for ( int i = num ; i < num ; i ++ ) { assert equals ( str + i , a [ i ] , b . get ( i ) ) ; } } } finally { store . destroy ( ) ; } }	ttest write ( ) + flush ( ) + update ( ) - for this case the data have been flushed from the write cache so the update will be a random write on the file rather than being buffered by the write cache .
public static void copy ( long [ ] src , int src offset , long [ ] dst , int dst offset , int len ) { int src limit = src offset + len ; while ( src offset < src limit ) { int src idx = src offset & num ; int dst idx = dst offset & num ; int src remainder = num - src idx ; int dst remainder = num - dst idx ; int chunk len = math . min ( src remainder , dst remainder ) ; long mask = mask below ( chunk len ) << src idx ; dst [ dst offset > > num ] |= ( ( src [ src offset > > num ] & mask ) > > > src idx ) << dst offset ; src offset += chunk len ; dst offset += chunk len ; } }	copies a bit range from one vector to another .
public static int saved xerror handler ( long display , x error ) { if ( saved error handler != num ) { } if ( log . is loggable ( platform logger . level . fine ) ) { log . fine ( str + str + error . get resourceid ( ) + str + str + error . get serial ( ) + str + str + error . get error code ( ) + str + str + error . get request code ( ) + str + str + error . get minor code ( ) ) ; } return num ; }	should be called under lock .
protected int in border ( int x , int y ) { border b = get border ( ) ; if ( b == null ) { return undef ; } insets i = b . get border insets ( this ) ; if ( x <= i . left ) { return dock west ; } if ( x >= get width ( ) - i . right ) { return dock east ; } if ( y <= i . top ) { return dock north ; } if ( y >= get height ( ) - i . bottom ) { return dock south ; } return undef ; }	get the border that mouse is in.
public wall force ( float grav const , float x1 , float y1 , float x2 , float y2 ) { params = new float [ ] { grav const } ; min values = new float [ ] { default min grav constant } ; max values = new float [ ] { default max grav constant } ; this . x1 = x1 ; this . y1 = y1 ; this . x2 = x2 ; this . y2 = y2 ; dx = x2 - x1 ; dy = y2 - y1 ; float r = ( float ) math . sqrt ( dx * dx + dy * dy ) ; if ( dx != num ) dx /= r ; if ( dy != num ) dy /= r ; }	create a new wallforce .
public static void write ln ( final output stream out ) throws io { out . write ( ls bytes ) ; }	write an end of line to out .
public static boolean is system application ( context context ) { if ( context == null ) { return bool ; } return is system application ( context , context . get package name ( ) ) ; }	whether context is system application.
public void test pos zero ( ) { string num a = str ; string num b = str ; string res = str ; big integer a number = new big integer ( num a ) ; big integer b number = new big integer ( num b ) ; big integer result = a number . xor ( b number ) ; assert true ( res . equals ( result . to string ( ) ) ) ; }	xor for a positive number and zero.
private static void initialize release platform ( ) { string platform property = read config property ( platform properties , platform property key ) ; if ( platform property == null ) { log info ( str ) ; } else { current platform = platform . value of ( platform property . to upper case ( locale . uk ) ) ; log info ( str + current platform ) ; } }	loads release platform from properties file .
public static boolean is empty ( char sequence str ) { if ( str == null || str . length ( ) == num ) { return bool ; } else { return bool ; } }	returns true if the string is null or 0 - length .
@ override public fs open ( path path , int buffer size ) throws io { string table = get table name ( root path , path ) ; string split = get split name ( root path , path ) ; split = split name without gzip extension ( split ) ; return new fs ( new emo split input stream ( table , split ) ) ; }	opens a split for reading.
public void simulate method ( soot method method , reference variable this var , reference variable return var , reference variable params [ ] ) { string sub signature = method . get sub signature ( ) ; if ( sub signature . equals ( str ) ) { java lang define class0 ( method , this var , return var , params ) ; return ; } else if ( sub signature . equals ( str ) ) { java lang find bootstrap class ( method , this var , return var , params ) ; return ; } else if ( sub signature . equals ( str ) ) { java lang find loaded class ( method , this var , return var , params ) ; return ; } else if ( sub signature . equals ( str ) ) { java lang get caller class loader ( method , this var , return var , params ) ; return ; } else { default method ( method , this var , return var , params ) ; return ; } }	implements the abstract method simulatemethod.
public static final string extract ipl identity host frimware rev ( loco net message m ) { string builder s = new string builder ( ) ; s . append ( integer . to string ( ( m . get element ( num ) & num ) > > num ) ) ; s . append ( str ) ; s . append ( integer . to string ( ( m . get element ( num ) & num ) ) ) ; return s . to string ( ) ; }	returns the host firmware revision number from an ipl identity report message.
private void grow ( ) { if ( keys == null || nkeys >= keys . length ) { string [ ] nk = new string [ nkeys + num ] ; string [ ] nv = new string [ nkeys + num ] ; if ( keys != null ) system . arraycopy ( keys , num , nk , num , nkeys ) ; if ( values != null ) system . arraycopy ( values , num , nv , num , nkeys ) ; keys = nk ; values = nv ; } }	grow the key / value arrays as needed.
private list < t > filter ( final collection < t > collection ) { final list < t > null free list = new array list < t > ( ) ; if ( collection != null ) { for ( final t item : collection ) { if ( item != null ) { null free list . add ( item ) ; } } } return null free list ; }	this filtering is required , in order to ensure that no nulls are passed ( which happens when using gson for deserializing json collection .
public boolean is system class ( soot class clz ) { return all system classes . contains ( clz ) ; }	return true if this class is a system class defined in android.
private byte [ ] try decode host to ip ( string host ) { if ( host . starts with ( str ) && host . ends with ( str ) ) { return try decode host to i ( host ) ; } return try decode host to i ( host ) ; }	checks if the host is an ip address . returns the byte representation of it.
public list < node > list available nodes ( class < ? > type ) { list < node > result = new array list < node > ( ) ; for ( node node : available nodes ) { if ( type . is assignable from ( node . get return type ( ) ) ) { result . add ( node ) ; } } return result ; }	returns the list of all available nodes with the given return type .
private < t extends draft3 resource > t look for resource ( draft3 resource type type , class < t > clazz ) { list < t > resources = look for resources ( type , clazz ) ; return resources != null && resources . size ( ) > num ? resources . get ( num ) : null ; }	find one resource by type.
public static string read file to string ( file file ) throws io { return read file to string ( file , charset . default charset ( ) ) ; }	reads the contents of a file into a string using the default encoding for the vm.
private boolean is locked ( order order ) { lock . lock ( ) ; try { return active orders . contains ( order . get id ( ) ) ; } finally { lock . unlock ( ) ; } }	determines if the order is locked .
private static byte [ ] long to byte array ( long l ) { byte [ ] ret val = new byte [ num ] ; for ( int i = num ; i < num ; i ++ ) { ret val [ i ] = ( byte ) l ; l >>= num ; } return ret val ; }	helper function to convert a long into a byte array ( least significant byte first ) .
public encoder test suite builder encode ( final string expected , final string input ) { return encode ( str + input , expected , input ) ; }	tells the suite builder that for the given input it should expect the given encoded output.
public void add muted username ( final string username ) { add muted username ( username , null ) ; }	mute the username permanently.
public void override current time ( long time ) { start time = system . current time millis ( ) ; current time = num ; stored time = time ; }	forcefully sets the current time for the stopwatch .
public static string sc ( double score ) { string score str = string . format ( str , score ) ; return score str ; }	synopsis [ ] four decimal places for double.
public static boolean validate bind address ( string bind address ) { if ( bind address == null || bind address . length ( ) == num ) return bool ; if ( inet address util . validate host ( bind address ) == null ) return bool ; return bool ; }	validates the bind address.
protected void fail ( string string ) { last print = num ; if ( string . length ( ) > num ) { char [ ] data = string . to char array ( ) ; for ( int i = num ; i < data . length ; i ++ ) { char c = data [ i ] ; if ( c >= num || c < num ) { data [ i ] = ( char ) ( str + ( c & num ) ) ; string = null ; } } if ( string == null ) { string = new string ( data ) ; } } println ( string ) ; throw new assertion error ( string ) ; }	called if the test reached a point that was not expected .
public typecheck result interpret results ( test configuration config , compilation result compilation result ) { list < test diagnostic > expected diagnostics = read diagnostics ( config , compilation result ) ; return typecheck result . from compilation results ( config , compilation result , expected diagnostics ) ; }	reads the expected diagnostics for the given configuration and creates a typecheckresult which contains all of the missing and expected diagnostics.
public boolean is trusted xacml ( string realm , string entity id , string trusted entity id , string role ) throws sam { boolean result = bool ; if ( role != null ) { if ( role . equals ( sam . pdp role ) ) { xacmlpdp pdp config = get policy decision point config ( realm , entity id ) ; if ( pdp config != null ) { result = is same circle of trust ( pdp config , realm , trusted entity id ) ; } } else if ( role . equals ( sam . pep role ) ) { xacml pep config = get policy enforcement point config ( realm , entity id ) ; result = is same circle of trust ( pep config , realm , trusted entity id ) ; } } return result ; }	determines whether two entities are in the same circle of trust under the realm.
private property editor load property editor ( class clz ) { property editor editor = null ; try { editor = ( property editor ) clz . new instance ( ) ; } catch ( exception e ) { e . print stack trace ( ) ; } return editor ; }	load propertyeditor from clz through reflection .
public distribution ( instances source , classifier split model model to use ) throws exception { int index ; instance instance ; double [ ] weights ; m per class per bag = new double [ model to use . num subsets ( ) ] [ num ] ; m per bag = new double [ model to use . num subsets ( ) ] ; tota l = num ; m per class = new double [ source . num classes ( ) ] ; for ( int i = num ; i < model to use . num subsets ( ) ; i ++ ) { m per class per bag [ i ] = new double [ source . num classes ( ) ] ; } enumeration < instance > enu = source . enumerate instances ( ) ; while ( enu . has more elements ( ) ) { instance = enu . next element ( ) ; index = model to use . which subset ( instance ) ; if ( index != - num ) { add ( index , instance ) ; } else { weights = model to use . weights ( instance ) ; add weights ( instance , weights ) ; } } }	creates a distribution according to given instances and split model .
public void writing request headers ( ) { if ( sent request millis != - num ) throw new illegal state exception ( ) ; sent request millis = system . current time millis ( ) ; }	called immediately before the transport transmits http request headers.
public list < dexlib abstract instruction > instructions after ( dexlib abstract instruction instruction ) { int i = instructions . index of ( instruction ) ; if ( i == - num ) throw new illegal argument exception ( str + instruction + str ) ; return instructions . sub list ( i + num , instructions . size ( ) ) ; }	return the instructions that appear ( lexically ) after the given instruction .
private alignment fine tune alignment ( final alignment first compute , final int xframe , final int yframe , final point frame location , final point component location , final int comp width , final int comp height ) { switch ( first compute ) { case topleft : case topright : if ( component location . x - frame location . x + comp width / num > xframe / num ) { return alignment . topright ; } else { return alignment . topleft ; } case leftbottom : case lefttop : if ( component location . y - frame location . y + comp height / num > yframe / num ) { return alignment . leftbottom ; } else { return alignment . lefttop ; } case rightbottom : case righttop : if ( component location . y - frame location . y + comp height / num > yframe / num ) { return alignment . rightbottom ; } else { return alignment . righttop ; } case bottomleft : case bottomright : if ( component location . x - frame location . x + comp width / num > xframe / num ) { return alignment . bottomright ; } else { return alignment . bottomleft ; } default : if ( real alignment == alignment . innerleft || real alignment == alignment . innerright ) { return real alignment ; } if ( component location . x - frame location . x > xframe + frame location . x - ( comp width + component location . x ) ) { return alignment . innerright ; } else { return alignment . innerleft ; } } }	after the calculatealignment ( ) decided the optimal side , this method decides which is the optimal direction for the bubble.
public boolean is empty ( ) { return shapes == null ? bool : shapes . is empty ( ) ; }	checks whether the plot does not contain any elements .
public static boolean is network available ( context context ) { connectivity manager cm = ( connectivity manager ) context . get system service ( context . connectivity service ) ; network info net info = cm . get active network info ( ) ; return net info != null && net info . is connected or connecting ( ) ; }	check availability of internet.
public void reset data ( ) { data . clear ( ) ; data names . clear ( ) ; data set . reset data ( data names , data , bins ) ; }	clears the data . currently just adds a single vector to each data source .
@ override public uri upload package ( ) { boolean file exists = new file ( topology package location ) . is file ( ) ; if ( ! file exists ) { log . info ( str + topology package location + str ) ; return null ; } path file path = paths . get ( dest topology file ) ; file parent directory = file path . get parent ( ) . to file ( ) ; assert parent directory != null ; if ( ! parent directory . exists ( ) ) { log . fine ( str ) ; if ( ! parent directory . mkdirs ( ) ) { log . severe ( str + parent directory . get path ( ) ) ; return null ; } } file exists = new file ( file path . to string ( ) ) . is file ( ) ; if ( file exists ) { log . fine ( str + file path . to string ( ) + str ) ; } log . fine ( str + topology package location + str + file path . to string ( ) ) ; path source = paths . get ( topology package location ) ; try { copy option [ ] options = new copy option [ ] { standard copy option . replace existing } ; files . copy ( source , file path , options ) ; } catch ( io ex ) { log . info ( str + source . to string ( ) + str + ex ) ; return null ; } return get uri ( dest topology file ) ; }	upload the topology package to the destined location in local file system.
public static string strip escape ( string pattern ) { if ( pattern == null ) return null ; string builder stripped = new string builder ( pattern . length ( ) ) ; for ( int pos = num ; pos < pattern . length ( ) ; pos ++ ) { char ch = pattern . char at ( pos ) ; if ( ch != str ) { stripped . append ( ch ) ; } else if ( pos < pattern . length ( ) - num && pattern . char at ( pos + num ) == str ) { stripped . append ( str ) ; pos += num ; } } return stripped . to string ( ) ; }	strips all backslash - escapes from a string .
public long guest time ( ) { return long . parse long ( fields [ num ] ) ; }	( since linux 2.
public void audit operation ( string operation , list < ? extends api > entities , list < string > encoded row keys , entity definition entity definition ) { if ( is auditing required ( entity definition . get service ( ) ) ) { list < generic audit entity > audit entities = build audit entities ( operation , entities , encoded row keys , entity definition ) ; if ( null != audit entities && num != audit entities . size ( ) ) { audit support . fire audit ( entity definition . get service ( ) , audit entities ) ; } } }	method to be invoked for firing audit event .
public void register ( string pattern , string result ) { assert . is true ( matchers . size ( ) == results . size ( ) ) ; pattern = pattern . trim ( ) ; if ( pattern . length ( ) == num ) { return ; } matchers . add ( new string matcher ( pattern , bool , bool ) ) ; results . add ( result ) ; }	register a pattern and an associated string.
@ override public boolean on item use ( item stack par1 item stack , entity player par2 entity player , world par3 world , int x , int y , int z , int par7 , float par8 , float par9 , float par10 ) { if ( ! par3 world . is remote ) { tile entity tile entity = par3 world . get tile entity ( x , y , z ) ; if ( tile entity != null ) { if ( tile entity instanceof tile launcher prefab ) { tile launcher prefab missile launcher = ( tile launcher prefab ) tile entity ; if ( missile launcher . get frequency ( ) > num ) { set frequency ( missile launcher . get frequency ( ) , par1 item stack ) ; par2 entity player . add chat message ( new chat component text ( reference . chat desc + enum color . grey + str + lang utils . localize ( str ) + str + enum color . dark grey + get frequency ( par1 item stack ) ) ) ; } else { par2 entity player . add chat message ( new chat component text ( reference . chat desc + enum color . grey + str + lang utils . localize ( str ) ) ) ; } } } } return bool ; }	callback for item usage.
private static string parse der ( byte [ ] alter name value ) throws throwable { try { as p = new as ( alter name value ) ; as d = p . read object ( ) ; as der = d . to as ( ) ; return get string from object ( der ) ; } catch ( throwable e ) { logger . error ( str + e . get message ( ) ) ; throw e ; } }	parse der - encoded bytes to locate a string object.
public atlas messages adapter add cell factories ( atlas cell factory ... cell factories ) { for ( atlas cell factory cell factory : cell factories ) { cell factory . set style ( m message style ) ; m cell factories . add ( cell factory ) ; m view type count ++ ; cell type me = new cell type ( bool , cell factory ) ; m cell types by view type . put ( m view type count , me ) ; m my view types by cell . put ( cell factory , m view type count ) ; m view type count ++ ; cell type not me = new cell type ( bool , cell factory ) ; m cell types by view type . put ( m view type count , not me ) ; m their view types by cell . put ( cell factory , m view type count ) ; } return this ; }	registers one or more cellfactories for the atlasmessagesadapter to manage.
protected string consume bom ( input stream stream , string encoding ) throws io { byte [ ] b = new byte [ num ] ; int count = num ; stream . mark ( num ) ; if ( encoding . equals ( str ) ) { count = stream . read ( b , num , num ) ; if ( count == num ) { final int b0 = b [ num ] & num ; final int b1 = b [ num ] & num ; final int b2 = b [ num ] & num ; if ( b0 != num || b1 != num || b2 != num ) { stream . reset ( ) ; } } else { stream . reset ( ) ; } } else if ( encoding . starts with ( str ) ) { count = stream . read ( b , num , num ) ; if ( count == num ) { final int b0 = b [ num ] & num ; final int b1 = b [ num ] & num ; if ( b0 == num && b1 == num ) { return str ; } else if ( b0 == num && b1 == num ) { return str ; } } stream . reset ( ) ; } return encoding ; }	removes the byte order mark from the stream , if it exists and returns the encoding name .
public static int create with id generation ( connection connection , string raw sql query , object ... parameters ) throws sql { prepared statement stmt = null ; result set rs = null ; try { stmt = connection . prepare statement ( raw sql query , statement . return generated keys ) ; for ( int index = num ; index < parameters . length ; index ++ ) { jdbc utils . bind parameter ( stmt , index + num , parameters [ index ] ) ; } stmt . execute update ( ) ; rs = stmt . get generated keys ( ) ; rs . next ( ) ; return rs . get int ( num ) ; } finally { jdbc utils . close result set ( rs ) ; jdbc utils . close statement ( stmt ) ; } }	insert one row into database with the auto incremental id returned .
public static int and not ( int a [ ] , int lena , int b [ ] , int lenb , int [ ] target ) { if ( lena == num ) return num ; if ( lenb == num ) { system . arraycopy ( a , num , target , num , lena ) ; return lena ; } if ( ( lenb > > num ) >= lena ) { return and not binary search ( a , lena , b , lenb , target ) ; } int count = num ; int i = num , j = num ; int doca = a [ i ] , docb = b [ j ] ; for ( ; ; ) { if ( doca > docb ) { if ( ++ j >= lenb ) break ; docb = b [ j ] ; } else if ( doca < docb ) { target [ count ++ ] = doca ; if ( ++ i >= lena ) break ; doca = a [ i ] ; } else { if ( ++ i >= lena ) break ; doca = a [ i ] ; if ( ++ j >= lenb ) break ; docb = b [ j ] ; } } int leftover = lena - i ; if ( leftover > num ) { system . arraycopy ( a , i , target , count , leftover ) ; count += leftover ; } return count ; }	puts the intersection of a and not b into the target array and returns the size.
void create buttons ( ) { if ( scroll forward button != null ) { tab pane . remove ( scroll forward button ) ; scroll forward button . remove action listener ( this ) ; tab pane . remove ( scroll backward button ) ; scroll backward button . remove action listener ( this ) ; } int tab placement = tab pane . get tab placement ( ) ; int width = ui . get int ( str ) ; if ( tab placement == top || tab placement == bottom ) { scroll forward button = new arrow button ( east , width ) ; scroll backward button = new arrow button ( west , width ) ; } else { scroll forward button = new arrow button ( south , width ) ; scroll backward button = new arrow button ( north , width ) ; } scroll forward button . add action listener ( this ) ; scroll backward button . add action listener ( this ) ; tab pane . add ( scroll forward button ) ; tab pane . add ( scroll backward button ) ; }	recreates the scroll buttons and adds them to the tabbedpane .
public static string rm slash from url ( final string url ) { return url . ends with ( str ) ? url . substring ( num , url . length ( ) - num ) : url ; }	remove the trailing slash from url .
protected void update chart layout ( ) { chart container . remove all ( ) ; list < string > selected metrics = get selected metrics ( ) ; if ( selected metrics . size ( ) > num ) { if ( selected metrics . size ( ) <= num ) { chart container . set layout ( new grid layout ( num , num ) ) ; } else if ( selected metrics . size ( ) <= num ) { chart container . set layout ( new grid layout ( num , num ) ) ; } else if ( selected metrics . size ( ) <= num ) { chart container . set layout ( new grid layout ( num , num ) ) ; } else if ( selected metrics . size ( ) <= num ) { chart container . set layout ( new grid layout ( num , num ) ) ; } else { chart container . set layout ( new grid layout ( ( int ) math . ceil ( selected metrics . size ( ) / num ) , num ) ) ; } grid layout layout = ( grid layout ) chart container . get layout ( ) ; int spaces = layout . get rows ( ) * layout . get columns ( ) ; for ( int i = num ; i < math . max ( spaces , selected metrics . size ( ) ) ; i ++ ) { if ( i < selected metrics . size ( ) ) { chart container . add ( create chart ( selected metrics . get ( i ) ) ) ; } else { chart container . add ( new empty plot ( this ) ) ; } } } chart container . revalidate ( ) ; }	updates the chart layout when the user changes which metrics to plot.
public string host ( properties props ) { return props . get property ( host property key , str ) ; }	returns the hostname property.
void cancel ( ) { set visible ( bool ) ; }	cancel any updates made in this dialog , and closes it .
@ override public mem chunk holder < volatile mem allocator > create chunk ( long size , boolean autoreclaim ) { mem chunk holder < volatile mem allocator > ret = null ; long addr = m vmasvc . allocate ( m nid , size , bool ) ; if ( num == addr && m activegc ) { m chunkcollector . wait reclaim cool down ( m gctimeout ) ; addr = m vmasvc . allocate ( m nid , size , bool ) ; } if ( num != addr ) { ret = new mem chunk holder < volatile mem allocator > ( this , addr , size ) ; ret . set collector ( m chunkcollector ) ; if ( autoreclaim ) { m chunkcollector . register ( ret ) ; } } return ret ; }	create a memory chunk that is managed by its holder .
public void wait for invocation ( long msec wait , int number of new events ) { long start time = system . current time millis ( ) ; while ( bool ) { if ( ( system . current time millis ( ) - start time ) > msec wait ) { throw new runtime exception ( str + number of new events + str + get new data list flattened ( ) . length ) ; } event bean [ ] events = get new data list flattened ( ) ; if ( events . length >= number of new events ) { return ; } try { thread . sleep ( num ) ; } catch ( interrupted exception e ) { return ; } } }	wait for the listener invocation for up to the given number of milliseconds .
private string version name ( string prefix , int ver ) { return f name ( prefix ) + string . value of ( ver ) ; }	generates a version filename prepended with the stable storage directory path with the given version number as a suffix .
private void request permission if needed ( ) { if ( build . version . sdk int >= build . version codes . m ) { int has enable coarse location perm = check self permission ( manifest . permission . access coarse location ) ; int has enable fine location perm = check self permission ( manifest . permission . access fine location ) ; int has enable external write perm = check self permission ( manifest . permission . write external storage ) ; list < string > permission to request = new array list < > ( ) ; if ( has enable coarse location perm == package manager . permission denied ) { permission to request . add ( manifest . permission . access coarse location ) ; } if ( has enable fine location perm == package manager . permission denied ) { permission to request . add ( manifest . permission . access fine location ) ; } if ( has enable external write perm == package manager . permission denied ) { permission to request . add ( manifest . permission . write external storage ) ; } if ( ! permission to request . is empty ( ) ) { request permissions ( permission to request . to array ( new string [ permission to request . size ( ) ] ) , allow permissions ) ; } else { init event ( ) ; } } }	this method must be called if the android version is 6.
public extract method refactoring ( i unit , int selection start , int selection length ) { f c = unit ; f root = null ; f method name = str ; f selection start = selection start ; f selection length = selection length ; f visibility = - num ; }	creates a new extract method refactoring.
@ override public boolean done ( ) { if ( stopping increments && increments left == num ) return bool ; else return bool ; }	override incrementsaredone so that we can eventually stop .
public void parse ( ) throws java . lang . exception { int act ; symbol lhs sym ; short handle size , lhs sym num ; production tab = production table ( ) ; action tab = action table ( ) ; reduce tab = reduce table ( ) ; init actions ( ) ; user init ( ) ; cur token = scan ( ) ; stack . push ( new symbol ( num , start state ( ) ) ) ; tos = num ; for ( done parsing = bool ; ! done parsing ; ) { act = get action ( ( ( symbol ) stack . peek ( ) ) . parse state , cur token . sym ) ; if ( act > num ) { cur token . parse state = act - num ; stack . push ( cur token ) ; tos ++ ; cur token = scan ( ) ; } else if ( act < num ) { lhs sym = do action ( ( - act ) - num , this , stack , tos ) ; lhs sym num = production tab [ ( - act ) - num ] [ num ] ; handle size = production tab [ ( - act ) - num ] [ num ] ; for ( int i = num ; i < handle size ; i ++ ) { stack . pop ( ) ; tos -- ; } act = get reduce ( ( ( symbol ) stack . peek ( ) ) . parse state , lhs sym num ) ; lhs sym . parse state = act ; stack . push ( lhs sym ) ; tos ++ ; } else if ( act == num ) { syntax error ( cur token ) ; if ( ! error recovery ( bool ) ) { unrecovered syntax error ( cur token ) ; done parsing ( ) ; } } } }	this method provides the main parsing routine.
private static void write set1 ( final b btree ) { log . info ( str ) ; for ( int i = num ; i < num ; i ++ ) { btree . insert ( i , i ) ; } }	write a set of tuples having keys in [ 0 : 1000 ) and values equal to the keys .
private byte [ ] create segment table ( int setup header length , list < ogg page header . packet start and length > extra packets ) { byte array output stream result baos = new byte array output stream ( ) ; byte [ ] rest should be ; byte [ ] next packet ; rest should be = create segments ( setup header length , bool ) ; try { result baos . write ( rest should be ) ; if ( extra packets . size ( ) > num ) { for ( ogg page header . packet start and length packet : extra packets ) { next packet = create segments ( packet . get length ( ) , bool ) ; result baos . write ( next packet ) ; } } } catch ( io ioe ) { throw new runtime exception ( str + ioe . get message ( ) ) ; } return result baos . to byte array ( ) ; }	this method creates a new segment table for the second half of setup header.
public static int index of ignore case ( string src , string sub , int start index , int end index ) { if ( start index < num ) { start index = num ; } int srclen = src . length ( ) ; if ( end index > srclen ) { end index = srclen ; } int sublen = sub . length ( ) ; if ( sublen == num ) { return start index > srclen ? srclen : start index ; } sub = sub . to lower case ( ) ; int total = end index - sublen + num ; char c = sub . char at ( num ) ; mainloop : for ( int i = start index ; i < total ; i ++ ) { if ( character . to lower case ( src . char at ( i ) ) != c ) { continue ; } int j = num ; int k = i + num ; while ( j < sublen ) { char source = character . to lower case ( src . char at ( k ) ) ; if ( sub . char at ( j ) != source ) { continue mainloop ; } j ++ ; k ++ ; } return i ; } return - num ; }	finds first index of a substring in the given source string and range with ignored case .
private void add polygon ring ( linear ring lr , int cw left , int cw right ) { if ( lr . is empty ( ) ) return ; coordinate [ ] coord = coordinate arrays . remove repeated points ( lr . get coordinates ( ) ) ; if ( coord . length < num ) { has too few points = bool ; invalid point = coord [ num ] ; return ; } int left = cw left ; int right = cw right ; if ( cg . is ccw ( coord ) ) { left = cw right ; right = cw left ; } edge e = new edge ( coord , new label ( arg index , location . boundary , left , right ) ) ; line edge map . put ( lr , e ) ; insert edge ( e ) ; insert point ( arg index , coord [ num ] , location . boundary ) ; }	adds a polygon ring to the graph.
public boolean accepts load name ( string load ) { if ( load option . equals ( all loads ) ) { return bool ; } if ( load option . equals ( include loads ) ) { return load list . contains ( load ) ; } return ! load list . contains ( load ) ; }	determine if track will service a specific receive load name .
public static void expand letters ( string letters , word relation word relation ) { letters = letters . to lower case ( ) ; char c ; for ( int i = num ; i < letters . length ( ) ; i ++ ) { c = letters . char at ( i ) ; if ( is digit ( c ) ) { word relation . add word ( digit2num [ c - str ] ) ; } else if ( letters . equals ( str ) ) { word relation . add word ( str ) ; } else { word relation . add word ( string . value of ( c ) ) ; } } }	expands the given string of letters as a list of single char symbols .
public static void write string to file ( file file , string data , charset encoding , boolean append ) throws io { output stream out = null ; try { out = open output stream ( file , append ) ; io . write ( data , out , encoding ) ; out . close ( ) ; } finally { io . close quietly ( out ) ; } }	writes a string to a file creating the file if it does not exist .
@ deprecated public static void subtract ( string name , double amount ) throws user does not exist exception , no loan permitted exception { try { substract ( name , big decimal . value of ( amount ) ) ; } catch ( arithmetic exception e ) { logger . log ( level . warning , str + amount + str + name + str + e . get message ( ) , e ) ; } }	substracts money from the balance of a user.
public mnemonic code ( input stream wordstream , string word list digest ) throws io , illegal argument exception { buffered reader br = new buffered reader ( new input stream reader ( wordstream , str ) ) ; word list = new array list < string > ( num ) ; string word ; while ( ( word = br . read line ( ) ) != null ) word list . add ( word ) ; br . close ( ) ; initialize from words ( word list , word list digest ) ; }	creates an mnemoniccode object , initializing with words read from the supplied input stream.
public qk add menu item ( string title , long id ) { m menu items . add ( title ) ; m menu item ids . add ( id ) ; return this ; }	adds a menu style item , allowing for dynamic ids for different items . this is useful when the item order is set dynamically , like in the messagelistitem if you use this method , always make sure to use # buildmenu ( onitemclicklistener ) to compile the items and add the click listener.
public anchor pane create finger print panel ( array list < fp panel > fingerprint panel list ) { return create finger print panel ( fingerprint panel list , null ) ; }	creates a new fingerprint panel from scratch ( new uuid ).
private static boolean is memory access ( final string value ) { return value . equals ( str ) ; }	checks whether a string is a memory access identifier string .
public void add attribute ( attribute info info ) { attribute info . remove ( attributes , info . get name ( ) ) ; attributes . add ( info ) ; }	appends an attribute . if there is already an attribute with the same name , the new one substitutes for it .
private static boolean verify string param ( string str , int max length , string acceptable characters ) { return ! ( str == null || str . length ( ) == num || str . length ( ) > max length || ! pattern . matches ( acceptable characters , str ) ) ; }	returns true if the specified string is non - null , greater then 0 in length , less than the specified length and matches the regex provided .
private int calculate drag sensitivity ( ) { int range = max drag sensitivity - min drag sensitivity ; return math . round ( ( num - get drag sensitivity ( ) ) * range + min drag sensitivity ) ; }	calculates and returns the distance after which dragging has an effect on the bottom sheet in pixels.
public static string lower first char ( string string ) { if ( string == null ) return null ; if ( string . length ( ) <= num ) return string . to lower case ( ) ; string builder sb = new string builder ( string ) ; sb . set char at ( num , character . to lower case ( sb . char at ( num ) ) ) ; return sb . to string ( ) ; }	changes the first letter of the passed string to lower case .
public void for each block pos mutable top down ( predicate < block pos > func ) { block pos . mutable block pos block pos = new block pos . mutable block pos ( ) ; int base x = get min block x ( ) ; int base z = get min block z ( ) ; int block y = get max block y ( ) ; for ( int x = num ; x < num ; x ++ ) { for ( int z = num ; z < num ; z ++ ) { block pos . set pos ( base x + x , block y , base z + z ) ; for ( int y = num ; y >= num ; y -- ) { boolean cont = func . test ( block pos ) ; block pos . move ( enum facing . down ) ; if ( ! cont ) { break ; } } } } }	for each x / z coordinate pair in this cube position - goes top - down and calls func for each blockpos.
public string visit ( type t , locale locale ) { return t . accept ( this , locale ) ; }	get a localized string representation for a given type .
public static final void write map xml ( map val , xml serializer out , write map callback callback ) throws xml pull parser exception , java . io . io { if ( val == null ) { return ; } set s = val . entry set ( ) ; iterator i = s . iterator ( ) ; while ( i . has next ( ) ) { map . entry e = ( map . entry ) i . next ( ) ; write value xml ( e . get value ( ) , ( string ) e . get key ( ) , out , callback ) ; } }	flatten a map into an xmlserializer.
public static void drop table ( string table , connection connection ) { table = table . replace ( str , str ) ; string builder drop table query = new string builder ( ) ; drop table query . append ( str ) ; drop table query . append ( table ) ; log . info ( str ) ; log . info ( drop table query ) ; execute statement if exists ( drop table query . to string ( ) , connection ) ; }	drops a table from a database underneath the connection object .
private int free space ( ) { return buffer . capacity ( ) - buffer . limit ( ) + buffer . position ( ) ; }	return the size of free space in a buffer.
@ override public list < node > generate ( int pop size ) { list < node > population = new array list < > ( ) ; for ( int i = num ; i < pop size ; ) { node candidate = grow ( num ) ; if ( candidate . is valid ( ) ) { population . add ( candidate ) ; i ++ ; } } return population ; }	this method return a new population of the desired size . the population is generated by growth algorithm which creates individual with a depth from 1 to a specified max depth ,.
public synchronized void notify before use ( composite transaction ct ) throws invalid session handle state exception { if ( closed ) throw new invalid session handle state exception ( str ) ; try { transaction context suspended = null ; if ( ct != null ) { iterator < transaction context > it = all contexts . iterator ( ) ; while ( it . has next ( ) && suspended == null ) { transaction context b = ( transaction context ) it . next ( ) ; if ( b . is suspended in transaction ( ct ) ) { suspended = b ; } } } if ( suspended != null ) { if ( logger . is debug enabled ( ) ) logger . log debug ( this + str + ct . get tid ( ) ) ; current context = suspended ; current context . transaction resumed ( ) ; } else { try { if ( logger . is trace enabled ( ) ) logger . log trace ( this + str + ct ) ; current context . check enlist before use ( ct ) ; } catch ( unexpected transaction context exception tx boundary passed ) { if ( logger . is debug enabled ( ) ) logger . log debug ( this + str + ct ) ; current context . transaction suspended ( ) ; current context = new transaction context ( resource , xa resource ) ; all contexts . add ( current context ) ; try { current context . check enlist before use ( ct ) ; } catch ( unexpected transaction context exception e ) { string msg = str ; logger . log error ( msg , e ) ; throw new invalid session handle state exception ( msg ) ; } } } } catch ( invalid session handle state exception e ) { notify session error occurred ( ) ; throw e ; } }	notification that the session handle is about to be used in the current transaction context ( i.
public void on activity result ( int request code , int result code , intent data ) { if ( m initialization complete ) { m activity delegate . on activity result with native ( request code , result code , data ) ; } else { if ( m pending activity results == null ) { m pending activity results = new array list < activity result > ( num ) ; } m pending activity results . add ( new activity result ( request code , result code , data ) ) ; } }	this is the android onactivityresult callback deferred , if necessary , to when the native library has loaded .
public void delete selection ( array list < integer > nodes ) { for ( int i = num ; i < nodes . size ( ) ; i ++ ) { for ( int j = i + num ; j < nodes . size ( ) ; j ++ ) { if ( nodes . get ( i ) > nodes . get ( j ) ) { int h = nodes . get ( i ) ; nodes . set ( i , nodes . get ( j ) ) ; nodes . set ( j , h ) ; } } } if ( m b needs undo action ) { add undo action ( new delete selection action ( nodes ) ) ; } boolean b needs undo action = m b needs undo action ; m b needs undo action = bool ; try { for ( int i node = nodes . size ( ) - num ; i node >= num ; i node -- ) { delete node ( nodes . get ( i node ) ) ; } } catch ( exception e ) { e . print stack trace ( ) ; } m b needs undo action = b needs undo action ; }	delete nodes with indexes in selection from the network , updating instances , parentsets , distributions conditional distributions are condensed by taking the values for the target node to be its first value.
protected void on cached ( ) { if ( log configuration . logging is enabled ( ) ) { logger . log ( level . info , str ) ; } ui handler . hide message ( ) ; updating = bool ; fire application cache event ( cache event . on cached ) ; }	called when a cached event is triggered.
public static void show string ( string title , string content , dimension dimension ) { j area = new j ( content ) ; area . set editable ( bool ) ; j scroll = new j ( area ) ; scroll . set preferred size ( dimension ) ; j . show message dialog ( null , scroll , title , j . information message ) ; }	display a string ( can be long ) inside a message dialogue.
private void mark cg ( block consistency group consistency group ) { if ( ! consistency group . get inactive ( ) ) { consistency group . set storage controller ( null ) ; consistency group . set inactive ( bool ) ; db client . update object ( consistency group ) ; } }	update the cg so it is deleted .
public long buffer put ( long [ ] src , int src offset , int long count ) { j . check offset and count ( src . length , src offset , long count ) ; if ( long count > remaining ( ) ) { throw new buffer overflow exception ( ) ; } for ( int i = src offset ; i < src offset + long count ; ++ i ) { put ( src [ i ] ) ; } return this ; }	writes longs from the given long array , starting from the specified offset , to the current position and increases the position by the number of longs written .
@ override public void invoke command ( int arg length , string [ ] args , string command ) { pattern regex = null ; if ( args . length == num ) { regex = pattern . compile ( args [ num ] ) ; } else if ( args . length != num ) { throw new usage exception ( str ) ; } for ( abstract command cmd : command bus . commands ) try regex ( regex , cmd ) ; for ( fuzzy command cmd : command bus . parsers ) try regex ( regex , cmd ) ; }	invoke the command if the name matches the one to be triggered.
protected int parse and add node ( xml resource parser parser , hash map < string , tag parser > tag parser map , array list < long > screen ids ) throws xml pull parser exception , io { if ( tag include . equals ( parser . get name ( ) ) ) { final int res id = get attribute resource value ( parser , attr workspace , num ) ; if ( res id != num ) { return parse layout ( res id , screen ids ) ; } else { return num ; } } m values . clear ( ) ; parse container and screen ( parser , m temp ) ; final long container = m temp [ num ] ; final long screen id = m temp [ num ] ; m values . put ( launcher settings . favorites . container , container ) ; m values . put ( launcher settings . favorites . screen , screen id ) ; m values . put ( launcher settings . favorites . cellx , convert to distance from end ( get attribute value ( parser , attr x ) , m column count ) ) ; m values . put ( launcher settings . favorites . celly , convert to distance from end ( get attribute value ( parser , attr y ) , m row count ) ) ; tag parser tag parser = tag parser map . get ( parser . get name ( ) ) ; if ( tag parser == null ) { if ( logd ) log . d ( tag , str + parser . get name ( ) ) ; return num ; } long new element id = tag parser . parse and add ( parser ) ; if ( new element id >= num ) { if ( ! screen ids . contains ( screen id ) && container == launcher settings . favorites . container desktop ) { screen ids . add ( screen id ) ; } return num ; } return num ; }	parses the current node and returns the number of elements added .
public word entry add new word ( final string str ) { final string key = trim word ( str ) ; word entry entry = words . get ( key ) ; if ( entry == null ) { entry = new word entry ( ) ; entry . set type ( new expression type ( str ) ) ; entry . set normalized ( key ) ; words . put ( key , entry ) ; } else { logger . warn ( str + str + str + entry . get normalized ( ) ) ; } return entry ; }	add a new word to the list in order to remember it later .
@ override public int insert ( string elem ) { int first index = ( int ) ( elem . char at ( num ) - str ) ; int middle index = ( int ) ( elem . char at ( - num + elem . length ( ) / num ) - str ) ; int last index = ( int ) ( elem . char at ( elem . length ( ) - num ) - str ) ; storage [ first index * num + middle index * num + last index ] = elem ; return num ; }	insert element into collection.
@ override protected void on measure ( int width measure spec , int height measure spec ) { m width = measure spec . get size ( width measure spec ) ; m height = measure spec . get size ( height measure spec ) ; int min side = math . min ( m width , m height ) ; m width = min side ; m height = min side ; m current progress position = calculate current position from current seconds ( m current seconds ) ; object animator progress . set float values ( m current progress position / m width , num ) ; object animator progress . set duration ( ( m max seconds - m current seconds ) * num ) ; if ( m bitmap cover image != null ) scale cover bitmap ( m bitmap cover image ) ; rect f . set ( num , m height - m progress height , m width , m height ) ; m drawable bottom shadow . set bounds ( num , ( num * m height ) / num , m width , m height ) ; if ( start requested ) { start requested = bool ; start ( ) ; } super . on measure ( width measure spec , height measure spec ) ; }	calculate witdh , height and region values here.
protected list < command > handle commands ( server connector server connector , list < command > commands ) { list < command > results = new array list < command > ( ) ; for ( command command : commands ) { if ( log . is loggable ( level . finest ) ) { log . finest ( str + command ) ; } results . add all ( server connector . receive ( command ) ) ; } return results ; }	processes incoming commands and creates outgoing commands .
public static void u ( double [ ] x , double [ ] f , int nx ) { int count1 = num ; int count2 = num ; double sum1 = num ; double sum2 = num ; double yj ; double hj ; double n = num ; double e = num ; for ( int j = num ; j <= nx ; j ++ ) { yj = x [ j - num ] - math . sin ( num * pi * x [ num ] + j * pi / nx ) ; hj = num * yj * yj - math . cos ( num * pi * yj ) + num ; if ( j % num == num ) { sum2 += hj ; count2 ++ ; } else { sum1 += hj ; count1 ++ ; } } hj = ( num / n + e ) * math . abs ( math . sin ( num * n * pi * x [ num ] ) ) ; f [ num ] = x [ num ] + hj + num * sum1 / ( double ) count1 ; f [ num ] = num - x [ num ] + hj + num * sum2 / ( double ) count2 ; }	evaluates the uf5 problem .
private view fill up ( int pos , int next bottom ) { if ( debug ) log . i ( tag , str + pos + str + next bottom + m first position + m first position ) ; view selected view = null ; final int end = m list padding . top ; while ( next bottom > end && pos >= num ) { view temp = make row ( pos , next bottom , bool ) ; if ( temp != null ) { selected view = temp ; } next bottom = m reference view . get top ( ) - m vertical spacing ; m first position = pos ; pos -= m num columns ; } if ( m stack from bottom ) { m first position = math . max ( num , pos + num ) ; } return selected view ; }	fills the list from pos up to the top of the list view .
private list < validation error > validate ( ) { list < validation error > errors = lists . new array list ( ) ; module module = get module ( ) ; errors . add all ( blaze android run configuration validation util . validate module ( module ) ) ; android facet facet = null ; if ( module != null ) { facet = android facet . get instance ( module ) ; errors . add all ( blaze android run configuration validation util . validate facet ( facet , module ) ) ; } errors . add all ( config state . validate ( facet ) ) ; errors . add all ( blaze android run configuration validation util . validate label ( get label ( ) , configuration . get project ( ) , kind . android binary ) ) ; return errors ; }	we collect errors rather than throwing to avoid missing fatal errors by exiting early for a warning.
public void remove child job ( job child job ) { if ( ! child jobs . contains ( child job ) ) { throw new runtime exception ( str + child job + str ) ; } boolean removed = child jobs . remove ( child job ) ; if ( ! removed ) { throw new runtime exception ( str ) ; } }	removes a child job from this job ' s set of child jobs.
private f is flinging to delete ( drag source source ) { if ( m fling to delete drop target == null ) return null ; if ( ! source . supports fling to delete ( ) ) return null ; view configuration config = view configuration . get ( m launcher ) ; m velocity tracker . compute current velocity ( num , config . get scaled maximum fling velocity ( ) ) ; if ( m velocity tracker . get y ( ) < m fling to delete threshold velocity ) { f vel = new f ( m velocity tracker . get x ( ) , m velocity tracker . get y ( ) ) ; f up vec = new f ( num , - num ) ; float theta = ( float ) math . acos ( ( ( vel . x * up vec . x ) + ( vel . y * up vec . y ) ) / ( vel . length ( ) * up vec . length ( ) ) ) ; if ( theta <= math . to radians ( max fling degrees ) ) { return vel ; } } return null ; }	determines whether the user flung the current item to delete it .
public static void run script ( final file file , final list < pair < string , object > > bindings ) throws script exception , io { final script engine engine = manager . get engine by extension ( file utils . get file extension ( file ) ) ; preconditions . check not null ( engine , str , file . get absolute path ( ) ) ; final string script = file utils . read textfile ( file ) ; run script ( engine , script , bindings ) ; }	executes a script file.
public void add u ( u ug ) { graphics . add element ( ug ) ; }	add a new ugraphic to the graphiclist.
public void apply ( ) throws illegal state exception { try { system . set security manager ( this ) ; } catch ( security exception e ) { logger . error ( str , e ) ; throw new illegal state exception ( e ) ; } }	use this manager as security manager.
public static rule create a ( string rule name , string rule url ) throws policy exception { map < string , set < string > > action values = new hash map < string , set < string > > ( ) ; set < string > set = new hash set < string > ( ) ; set . add ( allow decision ) ; action values . put ( get action , set ) ; set = new hash set < string > ( ) ; set . add ( allow decision ) ; action values . put ( post action , set ) ; return new rule ( rule name , iplanetamwebagentservice , rule url , action values ) ; }	create a http get / post rule for the given url .
public fast array list ( collection < ? extends e > c ) { element data = c . to array ( ) ; size = element data . length ; if ( element data . get class ( ) != object [ ] . class ) element data = arrays . copy of ( element data , size , object [ ] . class ) ; }	constructs a list containing the elements of the specified collection , in the order they are returned by the collection ' s iterator .
void create scene vao ( ) { int vao = gl gen vertex arrays ( ) ; int vbo = gl gen buffers ( ) ; gl bind vertex array ( vao ) ; gl bind buffer ( gl array buffer , vbo ) ; long buffer size = num * ( num + num ) * mesh . num vertices ; long normals offset = num * num * mesh . num vertices ; gl buffer data ( gl array buffer , buffer size , gl static draw ) ; gl buffer sub data ( gl array buffer , num , mesh . positions ) ; gl buffer sub data ( gl array buffer , normals offset , mesh . normals ) ; gl enable vertex attrib array ( num ) ; gl vertex attrib pointer ( num , num , gl float , bool , num , num ) ; gl enable vertex attrib array ( num ) ; gl vertex attrib pointer ( num , num , gl float , bool , num , normals offset ) ; gl bind buffer ( gl array buffer , num ) ; gl bind vertex array ( num ) ; this . vao scene = vao ; }	creates a vao for the scene .
public list < ? > end batch ( ) { list < ? > result = null ; if ( operations batch . size ( ) > num ) { result = do flush ( ) ; } use batch = bool ; operations batch = null ; return result ; }	after this call , the operations will be imediatelly sent to the remote peer.
public static collection remove inner class names ( collection col ) { list list = new array list ( ) ; list . add all ( col ) ; iterator it = list . iterator ( ) ; while ( it . has next ( ) ) { string name = ( string ) it . next ( ) ; if ( name . index of ( str ) != - num ) it . remove ( ) ; } return list ; }	return a new collection without any inner class names.
public trie node find ( string word ) { return ( word . length ( ) < num ? null : find ( word , root , num ) ) ; }	look up the given word in this trie.
private void test ordered indexes ( ) throws sql { delete db ( str ) ; connection conn = get connection ( str ) ; statement stat = conn . create statement ( ) ; stat . execute ( str + str ) ; stat . execute ( str ) ; result set rs = stat . execute query ( str + str ) ; rs . next ( ) ; assert contains ( rs . get string ( num ) , str ) ; stat . execute ( str ) ; stat . execute ( str ) ; stat . execute ( str ) ; stat . execute ( str ) ; rs = stat . execute query ( str + str ) ; rs . next ( ) ; assert contains ( rs . get string ( num ) , str ) ; conn . close ( ) ; }	where there are multiple indices , and we have an order by , select the index that already has the required ordering .
public string encode ( byte buffer a buffer ) { byte [ ] buf = get bytes ( a buffer ) ; return encode ( buf ) ; }	260 * a ' streamless ' version of encode that simply takes a bytebuffer 261 * and returns a string containing the encoded buffer.
public static int clear list info ( delegator delegator , string shopping list id ) throws generic entity exception { delegator . remove by and ( str , util misc . to map ( str , shopping list id ) ) ; return delegator . remove by and ( str , util misc . to map ( str , shopping list id ) ) ; }	remove all items from the given list .
private synchronized void handle watchdog ( ) { final int exit code ; if ( watchdog == null ) return ; if ( watchdog timeout == num ) return ; if ( ! is running ( ) ) { exit code = on command result listener . shell died ; debug . log ( string . format ( str , shell . to upper case ( locale . english ) ) ) ; } else if ( watchdog count ++ < watchdog timeout ) { return ; } else { exit code = on command result listener . watchdog exit ; debug . log ( string . format ( str , shell . to upper case ( locale . english ) ) ) ; } if ( handler != null ) { post callback ( command , exit code , buffer ) ; } command = null ; buffer = null ; idle = bool ; watchdog . shutdown ( ) ; watchdog = null ; kill ( ) ; }	called from a scheduledthreadpoolexecutor timer thread every second when there is an outstanding command.
public synchronized boolean has service ( class service class ) { if ( service class == null ) throw new null pointer exception ( str ) ; synchronized ( bean context . global hierarchy lock ) { if ( services . contains key ( service class ) ) return bool ; bean context services bcs = null ; try { bcs = ( bean context services ) get bean context ( ) ; } catch ( class cast exception cce ) { return bool ; } return bcs == null ? bool : bcs . has service ( service class ) ; } }	has a service , which may be delegated.
public static string format ( integer i ) { if ( i == null ) return null ; return i . to string ( ) ; }	formats the given integer in the format required by a numeric field .
public filename utils ( ) { super ( ) ; }	instances should not be constructed in standard programming .
public static string convert method signature ( string class name , string method name , string method sig , string pkg name ) { string builder args = new string builder ( ) ; signature converter converter = new signature converter ( method sig ) ; converter . skip ( ) ; args . append ( str ) ; while ( converter . get first ( ) != str ) { if ( args . length ( ) > num ) { args . append ( str ) ; } args . append ( shorten ( pkg name , converter . parse next ( ) ) ) ; } converter . skip ( ) ; args . append ( str ) ; string builder result = new string builder ( ) ; result . append ( class name ) ; result . append ( str ) ; result . append ( method name ) ; result . append ( args . to string ( ) ) ; return result . to string ( ) ; }	convenience method for generating a method signature in human readable form .
protected void predicate ( ) throws javax . xml . transform . transformer exception { if ( token is ( str ) ) { next token ( ) ; predicate expr ( ) ; consume expected ( str ) ; } }	predicate : : = ' [ ' predicateexpr ' ] '.
public static string canonical id ( string id ) { if ( id == null ) return str ; int st = num ; int len = id . length ( ) ; boolean substr = bool ; int c ; while ( st < len && ( ( c = id . char at ( st ) ) == str || c <= str ) ) { st ++ ; substr = bool ; } while ( st < len && ( ( c = id . char at ( len - num ) ) == str || c <= str ) ) { len -- ; substr = bool ; } return substr ? id . substring ( st , len ) : id ; }	convert a message - id string to canonical form ( strips off leading and trailing & lt ; & gt ; s ).
private static void encode binary ( byte [ ] bytes , int startpos , int count , int startmode , string builder sb ) { if ( count == num && startmode == text compaction ) { sb . append ( ( char ) shift to byte ) ; } else { boolean sixpack = ( ( count % num ) == num ) ; if ( sixpack ) { sb . append ( ( char ) latch to byte ) ; } else { sb . append ( ( char ) latch to byte padded ) ; } } int idx = startpos ; if ( count >= num ) { char [ ] chars = new char [ num ] ; while ( ( startpos + count - idx ) >= num ) { long t = num ; for ( int i = num ; i < num ; i ++ ) { t <<= num ; t += bytes [ idx + i ] & num ; } for ( int i = num ; i < num ; i ++ ) { chars [ i ] = ( char ) ( t % num ) ; t /= num ; } for ( int i = chars . length - num ; i >= num ; i -- ) { sb . append ( chars [ i ] ) ; } idx += num ; } } for ( int i = idx ; i < startpos + count ; i ++ ) { int ch = bytes [ i ] & num ; sb . append ( ( char ) ch ) ; } }	encode parts of the message using byte compaction as described in iso / iec 15438 : 2001 ( e ) , chapter 4.
protected void copy2 d ( int from [ ] [ ] , int to [ ] [ ] ) { for ( int i = num ; i < from . length ; i ++ ) { to [ i ] = new int [ from [ i ] . length ] ; system . arraycopy ( from [ i ] , num , to [ i ] , num , from [ i ] . length ) ; } }	copies one array of type int [ ] [ ] to another .
public static < k , v > map < k , v > of ( k k1 , v v1 , k k2 , v v2 , k k3 , v v3 ) { map map = of ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; map . put ( k3 , v3 ) ; return map ; }	returns map containing the given entries .
public boolean fill ( reader reader , int pos ) throws io { int res = reader . read ( f buf ) ; if ( res == - num ) { f offset = pos ; f length = num ; return bool ; } int chars read = res ; while ( chars read < buffer size ) { res = reader . read ( f buf , chars read , buffer size - chars read ) ; if ( res == - num ) { f offset = pos ; f length = chars read ; return bool ; } chars read += res ; } f offset = pos ; f length = buffer size ; return bool ; }	fills the buffer by reading from the given reader .
public void draw in rect ( g gl , cg rect ) { gl . gl enable ( gl texture 2 d ) ; load texture ( gl ) ; float vertices [ ] = { rect . origin . x , rect . origin . y , rect . origin . x + rect . size . width , rect . origin . y , rect . origin . x , rect . origin . y + rect . size . height , rect . origin . x + rect . size . width , rect . origin . y + rect . size . height } ; m vertices . put ( vertices ) ; m vertices . position ( num ) ; float coordinates [ ] = { num , max t , max s , max t , num , num , max s , num } ; m coordinates . put ( coordinates ) ; m coordinates . position ( num ) ; gl . gl enable client state ( gl vertex array ) ; gl . gl enable client state ( gl texture coord array ) ; gl . gl bind texture ( gl texture 2 d , name ) ; gl . gl tex parameterx ( gl texture 2 d , gl texture wrap s , gl repeat ) ; gl . gl tex parameterx ( gl texture 2 d , gl texture wrap t , gl repeat ) ; gl . gl vertex pointer ( num , gl float , num , m vertices ) ; gl . gl tex coord pointer ( num , gl float , num , m coordinates ) ; gl . gl draw arrays ( gl triangle strip , num , num ) ; gl . gl disable client state ( gl vertex array ) ; gl . gl disable client state ( gl texture coord array ) ; gl . gl disable ( gl texture 2 d ) ; }	draws a texture inside a rect.
synchronized void executed ( rt editor , operation op ) { stack < operation > undo stack = get undo stack ( editor ) ; stack < operation > redo stack = get redo stack ( editor ) ; while ( ! undo stack . empty ( ) && op . can merge ( undo stack . peek ( ) ) ) { operation previous op = undo stack . pop ( ) ; op . merge ( previous op ) ; } push ( op , undo stack ) ; redo stack . clear ( ) ; }	call this when an operation is performed to add it to the undo stack .
public static boolean is oss build ( ) { boolean is oss build = bool ; string build type = system . get property ( str ) ; if ( string utils . is not blank ( build type ) && build type . equals ignore case ( str ) ) { is oss build = bool ; } return is oss build ; }	checks if the build is a open source build or emc enterprise build.
public void invoke hook bolt execute ( tuple tuple , long execute latency ns ) { if ( task hooks . size ( ) != num ) { bolt execute info execute info = new bolt execute info ( tuple , get this task id ( ) , execute latency ns / constants . milliseconds to nanoseconds ) ; for ( i task hook : task hooks ) { task hook . bolt execute ( execute info ) ; } } }	task hook called in bolt every time a tuple gets executed.
private void validate iam roles ( list < iam role > iam roles ) { assert . not null ( iam roles , str ) ; assert . is true ( iam roles . size ( ) > num , str ) ; for ( iam role iam role : iam roles ) { assert . not null ( iam role , str ) ; assert . has text ( iam role . get iam role name ( ) , str ) ; } }	asserts that the given iam roles are valid as a user input.
public static intent build start in background intent ( file script ) { final component name component name = constants . s a service launcher component name ; intent intent = new intent ( ) ; intent . set component ( component name ) ; intent . set action ( constants . action launch background script ) ; intent . put extra ( constants . extra script path , script . get absolute path ( ) ) ; return intent ; }	builds an intent that will launch a script in the background .
public static java . lang . string value of ( java . lang . object obj ) { return obj == null ? str : obj . to string ( ) ; }	returns the string representation of the object argument .
@ suppress warnings ( { str , str } ) public span multi term query wrapper ( q query ) { this . query = objects . require non null ( query ) ; this . rewrite method = select rewrite method ( query ) ; }	create a new spanmultitermquerywrapper .
public void write map end ( ) throws io { os . write ( str ) ; }	writes the tail of the map to the stream .
public shape create arrow up ( final double x , final double y , final double w , final double h ) { path . reset ( ) ; path . move to ( x , y + h ) ; path . line to ( x + w / num , y ) ; path . line to ( x + w , y + h ) ; path . close path ( ) ; return path ; }	return a path for an arrow pointing up .
protected void fire value changed ( ) { change event evt = new change event ( this ) ; for ( change listener listener : listener list . get listeners ( change listener . class ) ) { listener . state changed ( evt ) ; } }	notify listeners of a changed value .
public static void stream content to browser ( http servlet response response , input stream in , int length , string content type , string file name ) throws io { set response browser proxy no cache ( response ) ; response . set content length ( length ) ; if ( content type != null ) { response . set content type ( content type ) ; } if ( file name != null ) { response . set header ( str , str + file name ) ; } output stream out = response . get output stream ( ) ; try { stream content ( out , in , length ) ; } catch ( io e ) { out . close ( ) ; throw e ; } out . flush ( ) ; out . close ( ) ; }	streams content from inputstream to the servletoutputstream this method will close the servletoutputstream when finished this method does not close the inputsteam passed.
public static byte buffer encode ( string string ) throws character coding exception { return encode ( string , bool ) ; }	converts the provided string to bytes using the utf - 8 encoding.
public void disable realtime steps notify ( ) { check connection ( ) ; final list < ble > list = new array list < > ( ) ; list . add ( new write action ( profile . uuid char control point , protocol . disable realtime steps notify ) ) ; queue ( list ) ; }	stops listening to step count in real time.
public static void un register tile codec ( int comp ) { xtiff cod = get tile codec ( comp ) ; tile codecs . remove ( cod ) ; }	unregister the xtifftilecodec corresponding to the tiff compression type .
public static void escape ( str builder to append , string text , boolean escape quote , boolean escape apos ) { if ( text == null ) { return ; } for ( int i = num ; i < text . length ( ) ; i ++ ) { char ch = text . char at ( i ) ; switch ( ch ) { case str : to append . append ( str ) ; break ; case str : to append . append ( str ) ; break ; case str : to append . append ( str ) ; break ; case str : to append . append ( escape quote ? str : ch ) ; break ; case str : to append . append ( escape apos ? str : ch ) ; break ; default : to append . append ( ch ) ; break ; } } }	escapes any xml entities in the text , appending the result to the strbuilder .
public void destroy ( ) { m listeners . clear ( ) ; m spring system . deregister spring ( this ) ; }	destroys this spring , meaning that it will be deregistered from its basespringsystem so it won ' t be iterated anymore and will clear its set of listeners.
@ override public synchronized void remove instance listener ( instance listener tsl ) { m instance listeners . remove element ( tsl ) ; }	remove an instance listener.
private void toggle favorite ( ) { for ( string game : list . get selected values list ( ) ) { if ( favorites . contains ( game ) ) { favorites . remove ( game ) ; } else { favorites . add ( game ) ; } } save favorites ( ) ; update ( ) ; }	removes all selected favorites and adds all selected non - favorites as favorites .
private void create partition region ( list vm list , int start index for region , int end index for region , int local max memory , int redundancy , boolean first creation flag , boolean multiple vm ) { iterator node iterator = vm list . iterator ( ) ; while ( node iterator . has next ( ) ) { vm vm = ( vm ) node iterator . next ( ) ; vm . invoke ( create multiple partition region ( pr prefix , start index for region , end index for region , redundancy , local max memory , first creation flag , multiple vm ) ) ; } }	this function createas multiple partition regions on nodes specified in the vmlist.
public boolean has extensions with deps ( ) { return ! extensions with deps . is empty ( ) ; }	tells whether or not this add - on has at least one extension with dependencies .
public synchronized void add series ( xy series ) { m series . add ( series ) ; }	adds a new xy series to the list .
private int [ ] calculate task count per container ( int task count , int prev container count , int current container count ) { int [ ] new task count per container = new int [ math . max ( current container count , prev container count ) ] ; arrays . fill ( new task count per container , num ) ; for ( int i = num ; i < current container count ; i ++ ) { new task count per container [ i ] = task count / current container count ; if ( task count % current container count > i ) { new task count per container [ i ] ++ ; } } return new task count per container ; }	calculates the expected number of tasks for each container.
@ override public void action perform ( component component ) { if ( ! is enabled ( ) ) { return ; } if ( before action performed handler != null ) { if ( ! before action performed handler . before action performed ( ) ) return ; } set selected = target . get selected ( ) ; if ( ! selected . is empty ( ) ) { if ( confirm ) { confirm and remove ( selected ) ; } else { remove ( selected ) ; } } }	this method is invoked by the action owner component .
public void test compare to pos pos2 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num , num , num , num , num } ; int a sign = num ; int b sign = num ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; assert equals ( - num , a number . compare to ( b number ) ) ; }	compareto ( biginteger a ).
static public void generate seed ( byte [ ] result ) { instance . get seed bytes ( result ) ; }	fill result with bytes from the queue.
private double hamming distance number vector ( number vector o1 , number vector o2 ) { final int d1 = o1 . get dimensionality ( ) , d2 = o2 . get dimensionality ( ) ; int differences = num ; int d = num ; for ( ; d < d1 && d < d2 ; d ++ ) { double v1 = o1 . double value ( d ) , v2 = o2 . double value ( d ) ; if ( v1 != v1 || v2 != v2 ) { continue ; } if ( v1 != v2 ) { ++ differences ; } } for ( ; d < d1 ; d ++ ) { double v1 = o1 . double value ( d ) ; if ( v1 != num && v1 == v1 ) { ++ differences ; } } for ( ; d < d2 ; d ++ ) { double v2 = o2 . double value ( d ) ; if ( v2 != num && v2 == v2 ) { ++ differences ; } } return differences ; }	version for number vectors .
public static kernel create kernel ( int kernel type ) { switch ( kernel type ) { case kernel radial : return new kernel radial ( ) ; case kernel polynomial : return new kernel polynomial ( ) ; case kernel neural : return new kernel neural ( ) ; default : return new kernel dot ( ) ; } }	creates a new kernel of the given type.
protected void check for pending tasks ( collection < uri > tenants , collection < ? extends data object > data objects ) { for ( uri tenant : tenants ) { check for pending tasks ( tenant , data objects ) ; } }	given a list of tenants and dataobject references , check if any of the dataobjects have pending tasks against them.
@ org . junit . test public void verify get float response ( ) throws exception { map < string , string > query params = new hash map < string , string > ( ) ; string str = client . invoke api ( str , str , query params , null , new hash map < string , string > ( ) , null , str , null , new string [ num ] ) ; assert equals ( str , string . value of ( example builder . sample float property value ) ) ; }	verifies that the return value is automatically created.
public static double median ( final double [ ] values ) { final int len = values . length ; final double [ ] sorted values = arrays . copy of ( values , len ) ; arrays . sort ( sorted values ) ; if ( len % num == num ) { return ( ( double ) sorted values [ len / num ] + ( double ) sorted values [ len / num - num ] ) / num ; } else { return ( double ) sorted values [ len / num ] ; } }	computes the median of the values in the input array .
private list < block info > fill segment id to table info map ( list < table block info > table block infos , absolute table identifier absolute table identifier ) { map < string , list < block info > > map = segment id to block list map . get ( absolute table identifier ) ; if ( null == map ) { map = new concurrent hash map < string , list < block info > > ( ) ; segment id to block list map . put ( absolute table identifier , map ) ; } block info temp = null ; list < block info > block infos need to load = new array list < > ( ) ; for ( table block info info : table block infos ) { list < block info > temp table block infos = map . get ( info . get segment id ( ) ) ; if ( null == temp table block infos ) { temp table block infos = new array list < > ( ) ; map . put ( info . get segment id ( ) , temp table block infos ) ; } temp = new block info ( info ) ; if ( ! temp table block infos . contains ( temp ) ) { temp table block infos . add ( temp ) ; } block infos need to load . add ( temp ) ; } return block infos need to load ; }	below method will be used to fill segment id to its block mapping map . it will group all the table block info based on segment id and it will fill.
public char buffer put ( string str , int start , int end ) { if ( is read only ( ) ) { throw new read only buffer exception ( ) ; } if ( start < num || end < start || end > str . length ( ) ) { throw new index out of bounds exception ( str + str . length ( ) + str + start + str + end ) ; } if ( end - start > remaining ( ) ) { throw new buffer overflow exception ( ) ; } for ( int i = start ; i < end ; i ++ ) { put ( str . char at ( i ) ) ; } return this ; }	writes chars of the given string to the current position of this buffer , and increases the position by the number of chars written .
public list < offer recommendation > evaluate ( list < offer > offers ) { list < offer recommendation > recommendations = new array list < offer recommendation > ( ) ; int offer resource count = num ; for ( offer offer : offers ) { offer resource count += offer . get resources count ( ) ; for ( resource to destroy : select unexpected resources ( expected persistent volume ids , get persistent volumes by id ( offer ) ) ) { recommendations . add ( new destroy offer recommendation ( offer , to destroy ) ) ; } } int destroy recommendation count = recommendations . size ( ) ; for ( offer offer : offers ) { for ( resource to unreserve : select unexpected resources ( expected reserved resource ids , get reserved resources by id ( offer ) ) ) { recommendations . add ( new unreserve offer recommendation ( offer , to unreserve ) ) ; } } logger . info ( str , offers . size ( ) , offer resource count , destroy recommendation count , recommendations . size ( ) - destroy recommendation count ) ; return recommendations ; }	returns a list of operations which should be performed , given the provided list of offers from mesos.
@ override public int update ( byte buffer in buffer , byte buffer out buffer ) throws short buffer exception { return cipher . update ( in buffer , out buffer ) ; }	continues a multiple - part encryption / decryption operation.
boolean display context assump ( node representation rep , int i ) { return rep . is created || ( ( ! state . split chosen ( ) ) && show context value ) ; }	this returns true iff we should display a context assumption rep = state.
private void unregister m ( ) { list < object name > unregistered = new array list < object name > ( ) ; for ( object name name : mbeans ) { try { mbeanserver . unregister m ( name ) ; unregistered . add ( name ) ; } catch ( jm e ) { } } mbeans . remove all ( unregistered ) ; }	unregister all jmx mbeans.
public static void main ( string [ ] argv ) throws io , sax { scanner s = new html ( ) ; reader r = new input stream reader ( system . in , str ) ; writer w = new output stream writer ( system . out , str ) ; pyx pw = new pyx ( w ) ; s . scan ( r , pw ) ; w . close ( ) ; }	test procedure . reads html from the standard input and writes pyx to the standard output .
private void create amp result stream method ( java class j class , method method , int result offset ) { string method name = method . get name ( ) ; class < ? > [ ] parameter types = method . get parameter types ( ) ; annotation [ ] [ ] parameter anns = method . get parameter annotations ( ) ; add method ( method ) ; code writer attribute code = create method header ( j class , method ) ; code . set max locals ( num + num * parameter types . length ) ; code . set max stack ( num + num * parameter types . length ) ; code . push object var ( num ) ; code . get field ( j class . get this class ( ) , str , message factory amp . class ) ; int arg len = parameter types . length - num ; code . push object var ( get length ( parameter types , result offset ) + num ) ; long timeout = default timeout ; code . push constant ( timeout ) ; code . push object var ( num ) ; code . get field ( j class . get this class ( ) , str , service ref amp . class ) ; code . push object var ( num ) ; code . get field ( j class . get this class ( ) , field name ( method ) , method amp . class ) ; partition method ( code , parameter types , parameter anns ) ; push parameters ( code , parameter types , parameter anns , num , num , arg len + num , result offset ) ; code . invoke interface ( message factory amp . class , str , void . class , result stream . class , long . class , service ref amp . class , method amp . class , object [ ] . class ) ; code . add return ( ) ; code . close ( ) ; }	void foo ( x a1 , y a2 , resultstream < t > result ) { stream ( __caucho_getcurrentcontext ( ) , cont , timeout , _methodref , new object [ ] { a1 , a2 } ) . send ( ) ; }.
private static synchronized void end transaction ( connection c , boolean successful ) throws ade exception { logger . trace ( str ) ; try { if ( successful ) { c . commit ( ) ; } else { c . rollback ( ) ; } c . set auto commit ( bool ) ; } catch ( throwable t ) { surface throwable ( str , t ) ; throw ade exception of ( t ) ; } logger . trace ( str ) ; }	thin wrapper around jdbc connection.
public double [ ] estimate l2 distance squared ( datum query datum ) { real vector vector = query datum . metrics ( ) ; double [ ] estimates = new double [ num ] ; for ( int i = num ; i < k ; i ++ ) { double delta lo = vector . get entry ( i ) - this . boundaries [ i ] [ num ] ; double delta hi = this . boundaries [ i ] [ num ] - vector . get entry ( i ) ; double sq delta lo = delta lo * delta lo ; double sq delta hi = delta hi * delta hi ; if ( delta lo < num || delta hi < num ) { if ( sq delta hi < sq delta lo ) { estimates [ num ] += sq delta hi ; estimates [ num ] += sq delta lo ; } else { estimates [ num ] += sq delta lo ; estimates [ num ] += sq delta hi ; } } else { estimates [ num ] += math . max ( sq delta hi , sq delta lo ) ; } } return estimates ; }	estimates bounds on the distance to a region.
private void deserialize class ( file file ) throws runtime exception { try { file input stream in = new file input stream ( file ) ; object input stream obj in = new object input stream ( in ) ; object o = obj in . read object ( ) ; in . close ( ) ; } catch ( class not found exception e ) { throw new runtime exception ( str + str + file + str + str + str , e ) ; } catch ( io e ) { throw new runtime exception ( str + str + file + str , e ) ; } }	deserializes the information in the given file , returning the object represented .
private boolean can open ( ) { for ( final i project : m projects ) { if ( project . is loaded ( ) ) { return bool ; } } return bool ; }	determines whether all nodes for which the menu is built are unloaded .
public static array list with quotes to array ( string list , string delimiter , string quotes ) { if ( list . length ( ) == num ) return new array impl ( ) ; int len = list . length ( ) ; int last = num ; char [ ] del = delimiter . to char array ( ) ; char [ ] quo = quotes . to char array ( ) ; char c ; char inside = num ; array impl array = new array impl ( ) ; try { for ( int i = num ; i < len ; i ++ ) { c = list . char at ( i ) ; for ( int y = num ; y < quo . length ; y ++ ) { if ( c == quo [ y ] ) { if ( c == inside ) inside = num ; else if ( inside == num ) inside = c ; continue ; } } for ( int y = num ; y < del . length ; y ++ ) { if ( inside == num && c == del [ y ] ) { array . append ( list . substring ( last , i ) ) ; last = i + num ; break ; } } } if ( last <= len ) array . append ( list . substring ( last ) ) ; } catch ( expression exception e ) { } return array ; }	casts a list to array object , the list can be have quoted ( " , ' ) arguments and delimter in this arguments are ignored . quotes are not removed example : listwithquotestoarray ( " aab , a ' a , b ' , a \ " a , b \ " " , " , " , " \ " ' " ) will be translated to [ " aab " , " a ' a , b ' " , " a \ " a , b \ " " ].
public ml execute ( string dml script file path , array list < string > args name , array list < string > args values , string config file path ) throws io , dml , parse exception { hash map < string , string > new named args = new hash map < string , string > ( ) ; if ( args name . size ( ) != args values . size ( ) ) { throw new dml ( str + args name . size ( ) + str + str ) ; } for ( int i = num ; i < args name . size ( ) ; i ++ ) { string k = args name . get ( i ) ; string v = args values . get ( i ) ; new named args . put ( k , v ) ; } return execute ( dml script file path , new named args , config file path ) ; }	execute dml script by passing positional arguments using specified config file.
public boolean is in memory db ( ) { return path . equals ignore case ( memory db path ) ; }	returns true if the database is in - memory .
private static boolean test specific value ( double x , double y , double expected value , double interp value ) { logger . info ( str + x + str + y + str + expected value + str + interp value + str ) ; boolean specific value interp useful = bool ; if ( interp value > expected value + num || interp value < expected value - num ) specific value interp useful = bool ; return specific value interp useful ; }	tests the interpolation of a specific expected or known value.
@ override public string leave dtd ( ) { if ( writer == dtd writer ) { line . append ( text ) ; text = new string buffer ( num ) ; flush line ( bool ) ; writer = doc writer ; return dtd writer . to string ( ) ; } return null ; }	called by the root element to leave dtd mode and if any dtd parts were printer , will return a string with their textual content .
private static class node load class ( string name , config config ) throws exception { string file path = config . get class dump path ( ) + name . replace ( str , str ) + str ; class reader reader = new class reader ( new file input stream ( file path ) ) ; class node node = new class node ( ) ; reader . accept ( node , class reader . expand frames ) ; return node ; }	find and return the class of the given name.
public void write ( char [ ] cbuf , int off , int len ) throws io { internal out . write ( cbuf , off , len ) ; }	writes a portion of an array of characters .
public void add ( final string clazz , final string subclazz , final boolean blocked ) { entries . add ( new entry ( clazz , subclazz , blocked ) ) ; }	add a criteria entry .
private synchronized void buffer change ( ) throws read failed exception { byte buffer current = super . get byte buffer ( ) ; if ( null != current ) { current . clear ( ) ; empty buffers . add ( current ) ; } int tries = num ; while ( bool ) { try { byte buffer buffer = full buffers . poll ( num , time unit . milliseconds ) ; if ( null != buffer ) { super . set byte buffer ( buffer ) ; break ; } else { tries ++ ; if ( read failed || ( tries > max buffer pool tries ) ) { throw new read failed exception ( str ) ; } } } catch ( interrupted exception e ) { thread . interrupted ( ) ; } } }	changes the current buffer used for streaming with a full one .
protected synchronized class load class ( string name , boolean resolve ) throws class not found exception { class c = find loaded class ( name ) ; if ( c == null ) c = find class ( name ) ; if ( c == null ) throw new class not found exception ( name ) ; if ( resolve ) resolve class ( c ) ; return c ; }	requests the class loader to load a class .
@ suppress warnings ( { str , str } ) public static comparable < ? > max ( comparable < ? > [ ] ar ) { comparable ret = ar [ num ] ; for ( int i = num ; i < ar . length ; i ++ ) { if ( ret . compare to ( ar [ i ] ) < num ) { ret = ar [ i ] ; } } return ret ; }	locate the maximum value from an array of comparables .
private void init bprma ( int c b id ) { rma field . remove action listener ( this ) ; rma field . remove all items ( ) ; key name pair pp = new key name pair ( num , str ) ; rma field . add item ( pp ) ; array list < key name pair > list = load rma ( c b id ) ; for ( key name pair knp : list ) rma field . add item ( knp ) ; rma field . set selected index ( num ) ; rma field . add action listener ( this ) ; }	load rma that are candidates for shipment.
protected void reset options ( ) { m max stale = num ; m search direction = selection forward ; m starting = null ; m start range = new range ( ) ; m class index = - num ; m total evals = num ; m cache size = num ; m debug = bool ; }	reset options to default values.
@ override protected void tear down ( ) throws exception { try { take screen shot ( ) ; } catch ( throwable throwable ) { throwable . print stack trace ( ) ; } super . tear down ( ) ; }	takes a screenshot after every test.
private boolean itera connect ( pla point int p from point , pla point int p to point ) { array list < pla point int > corners = angled connection ( p from point , p to point ) ; boolean connection succeeded = bool ; for ( int index = num ; index < corners . size ( ) ; ++ index ) { pla point int from corner = corners . get ( index - num ) ; pla point int to corner = corners . get ( index ) ; time limit time limit = new time limit ( s check forced trace time max ) ; while ( ! from corner . equals ( to corner ) ) { pla point int curr ok point = r board . insert trace ( from corner , to corner , pen half width arr [ layer active no ] , layer active no , net nos , clearance class , max shove trace recursion depth , max shove via recursion depth , max spring over recursion depth , itera settings . trace pullt min move , ! is stitch mode , time limit ) ; if ( curr ok point == null ) { r board . undo ( null ) ; return bool ; } if ( curr ok point . equals ( from corner ) && itera settings . is automatic neckdown ( ) ) { curr ok point = try neckdown at end ( from corner , to corner ) ; } if ( curr ok point . equals ( from corner ) ) { prev corner = from corner ; connection succeeded = bool ; break ; } from corner = curr ok point ; } } return connection succeeded ; }	tries to make a trace connection from p_from_point to p_to_point according to the angle restriction .
private node < k , v > find predecessor of last ( ) { for ( ; ; ) { index < k , v > q = head ; for ( ; ; ) { index < k , v > d , r ; if ( ( r = q . right ) != null ) { if ( r . indexes deleted node ( ) ) { q . unlink ( r ) ; break ; } if ( r . node . next != null ) { q = r ; continue ; } } if ( ( d = q . down ) != null ) q = d ; else return q . node ; } } }	specialized variant of findpredecessor to get predecessor of last valid node.
public boolean query ( int object to query , long [ ] [ ] hash functions ) { for ( long [ ] h : hash functions ) { int i = hash ( h , ( long ) object to query ) ; if ( ! bit set . get ( i ) ) return bool ; } return bool ; }	determines whether an item ( represented by an integer ) is present in the bloom filter .
@ safe varargs public static < v > set < v > create set ( v ... values ) { set < v > set = new linked hash set < v > ( ) ; for ( v v : values ) { set . add ( v ) ; } return set ; }	create a set for the provided values .
public void stop ( ) { time mon index = num ; set exception ( ) ; iterator iter = iter ( ) ; while ( iter . has next ( ) ) { http mon item mon item = ( http mon item ) iter . next ( ) ; mon item . stop ( this ) ; } if ( stack trace != null ) change details ( ) ; }	method called to stop any active http monitoring requests , and responses.
public void calc min tick ( ) { if ( min data == num ) min tick = num ; else min tick = math . floor ( min data / major tick ) * major tick ; }	calculate the optimum minimum tick . override to change default behaviour.
public static void switch timing ( string next phase ) { stop most recent timer ( ) ; start timing ( next phase ) ; }	stop the most recent stopwatch and start this one.
public byte [ ] encode ( ) { char type = get attribute type ( ) ; if ( ! is type valid ( type ) ) throw new illegal state exception ( ( ( int ) type ) + str ) ; byte bin value [ ] = new byte [ header length + get data length ( ) ] ; bin value [ num ] = ( byte ) ( type > > num ) ; bin value [ num ] = ( byte ) ( type & num ) ; bin value [ num ] = ( byte ) ( get data length ( ) > > num ) ; bin value [ num ] = ( byte ) ( get data length ( ) & num ) ; bin value [ num ] = num ; bin value [ num ] = get family ( ) ; bin value [ num ] = ( byte ) ( get port ( ) > > num ) ; bin value [ num ] = ( byte ) ( get port ( ) & num ) ; if ( get family ( ) == address family ip ) { system . arraycopy ( get address bytes ( ) , num , bin value , num , num ) ; } else { system . arraycopy ( get address bytes ( ) , num , bin value , num , num ) ; } return bin value ; }	returns a binary representation of this attribute .
private void do delete entry ( string alias ) throws exception { if ( key store . contains alias ( alias ) == bool ) { message format form = new message format ( rb . get string ( str ) ) ; object [ ] source = { alias } ; throw new exception ( form . format ( source ) ) ; } key store . delete entry ( alias ) ; }	deletes an entry from the keystore .
protected integer map throwable flat ( throwable throwable ) { class < ? extends throwable > throwable class = throwable . get class ( ) ; integer res id = throwable to msg id map . get ( throwable class ) ; if ( res id == null ) { class < ? extends throwable > closest class = null ; set < entry < class < ? extends throwable > , integer > > mappings = throwable to msg id map . entry set ( ) ; for ( entry < class < ? extends throwable > , integer > mapping : mappings ) { class < ? extends throwable > candidate = mapping . get key ( ) ; if ( candidate . is assignable from ( throwable class ) ) { if ( closest class == null || closest class . is assignable from ( candidate ) ) { closest class = candidate ; res id = mapping . get value ( ) ; } } } } return res id ; }	mapping without checking the cause ( done in mapthrowable ) .
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( ) ; new vector . add ( new option ( str + str , str , num , str ) ) ; new vector . add ( new option ( str , str , num , str ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public void assert column type ( result set rs ) throws sql { result set meta data md = rs . get meta data ( ) ; int sql type = md . get column type ( mdi . get position ( ) ) ; assert true ( string . format ( str , sql type , mdi ) , is allowed sql type ( sql type ) ) ; }	asserts the type of this column as reported by the resultsetmetadata of this resultset .
private void validate dns names ( set dns name set ) throws policy exception { iterator dns names = dns name set . iterator ( ) ; while ( dns names . has next ( ) ) { string dns name = ( string ) dns names . next ( ) ; validate dns name ( dns name ) ; dns list . add ( dns name . to lower case ( ) ) ; } }	validates if the value of property dns_name is correct and adheres to the expected format.
public static boolean is mop method ( string method name ) { return ( method name . starts with ( str ) || method name . starts with ( str ) ) && ! method name . contains ( str ) ; }	method to determine if a method is a mop method.
protected void init ( ) { d template = new d ( ) ; graphics environment env = graphics environment . get local graphics environment ( ) ; graphics device device = env . get default screen device ( ) ; graphics configuration config = device . get best configuration ( template ) ; canvas = new d ( config ) ; canvas . set size ( new dimension ( default dimension , default dimension ) ) ; obj root bg = new branch group ( ) ; obj root bg . set capability ( group . allow children extend ) ; construct world ( obj root bg ) ; }	set up the canvas and the universe .
private < delegated > presenter binder < ? super delegated > find presenter binder for class ( class < delegated > clazz ) throws illegal access exception , instantiation exception { presenter binder < ? super delegated > presenter binder ; string cls name = clazz . get name ( ) ; string class name = cls name + presenter binder suffix ; try { class < ? > presenter binder class = class . for name ( class name ) ; presenter binder = ( presenter binder < ? super delegated > ) presenter binder class . new instance ( ) ; } catch ( class not found exception e ) { return null ; } return presenter binder ; }	find generated binder for class.
@ override final node < k , v > find ( int h , object k ) { if ( k != null ) { for ( node < k , v > e = first ; e != null ; ) { int s ; if ( ( ( s = lock state ) & ( waiter | writer ) ) != num ) { if ( e . hash == h && is equal ( ( k ) k , e . key , my hashing strategy ) ) { return e ; } e = e . next ; } else if ( u . compare and swap int ( this , lockstate , s , s + reader ) ) { tree node < k , v > r , p ; try { p = ( ( r = root ) == null ? null : r . find tree node ( h , k , null ) ) ; } finally { int ls ; do { } while ( ! u . compare and swap int ( this , lockstate , ls = lock state , ls - reader ) ) ; thread w ; if ( ls == ( reader | waiter ) && ( w = waiter ) != null ) { lock support . unpark ( w ) ; } } return p ; } } } return null ; }	returns matching node or null if none.
public void square ( double x , double y , double r ) { if ( r < num ) throw new illegal argument exception ( str ) ; double xs = scale x ( x ) ; double ys = scale y ( y ) ; double ws = factor x ( num * r ) ; double hs = factor y ( num * r ) ; if ( ws <= num && hs <= num ) pixel ( x , y ) ; else offscreen . draw ( new d . double ( xs - ws / num , ys - hs / num , ws , hs ) ) ; draw ( ) ; }	draws a square of side length 2r , centered on ( x , y ) .
private int lower height map ( int x , int y , int z ) { for ( -- y ; y >= num ; -- y ) { if ( get type ( x , z , y ) != num ) { break ; } } return y + num ; }	scan downwards to determine the new height map value .
public string to string ( ) { string buffer result = new string buffer ( str ) ; for ( int i = num ; i < intervalls . size ( ) ; i ++ ) result . append ( intervalls . element at ( i ) ) ; result . append ( str ) ; return result . to string ( ) ; }	make a string representation of this char set .
public void remove ( @ not null status notification notification ) { stack . remove ( notification ) ; on close ( notification ) ; }	remove notification from message stack .
private job definition entity create or update job definition entity ( job definition entity job definition entity , namespace entity namespace entity , string job name , string description , string activiti id , list < parameter > parameters , s3 properties location s3 properties location ) { job definition entity job definition entity local = job definition entity ; if ( job definition entity local == null ) { job definition entity local = new job definition entity ( ) ; } job definition entity local . set name ( job name ) ; job definition entity local . set namespace ( namespace entity ) ; job definition entity local . set description ( description ) ; job definition entity local . set activiti id ( activiti id ) ; string bucket name = null ; string key = null ; if ( s3 properties location != null ) { bucket name = s3 properties location . get bucket name ( ) ; key = s3 properties location . get key ( ) ; } job definition entity local . set s3 bucket name ( bucket name ) ; job definition entity local . set s3 object key ( key ) ; list < job definition parameter entity > parameter entities = new array list < > ( ) ; if ( ! collection utils . is empty ( parameters ) ) { for ( parameter parameter : parameters ) { job definition parameter entity parameter entity = new job definition parameter entity ( ) ; parameter entities . add ( parameter entity ) ; parameter entity . set name ( parameter . get name ( ) ) ; parameter entity . set value ( parameter . get value ( ) ) ; } } job definition entity local . set parameters ( parameter entities ) ; return job definition entity local ; }	creates a new job definition entity from the request information .
@ request mapping ( value = { str , str } , method = request method . put ) @ response body public rest wrapper insert ( @ model attribute ( str ) @ valid users users , binding result binding result , principal principal ) { rest wrapper rest wrapper = null ; if ( binding result . has errors ( ) ) { binding result error binding result error = new binding result error ( ) ; return binding result error . error message ( binding result ) ; } try { string hashed password = digest utils . sha1 hex ( users . get password ( ) ) ; com . wipro . ats . bdre . md . dao . jpa . users jpa users = new com . wipro . ats . bdre . md . dao . jpa . users ( ) ; jpa users . set password ( hashed password ) ; jpa users . set username ( users . get username ( ) ) ; jpa users . set enabled ( ( users . get enabled ( ) == num ) ? bool : bool ) ; users dao . insert ( jpa users ) ; rest wrapper = new rest wrapper ( users , rest wrapper . ok ) ; logger . info ( str + users . get username ( ) + str + principal . get name ( ) + users ) ; } catch ( exception e ) { logger . error ( e ) ; rest wrapper = new rest wrapper ( e . get message ( ) , rest wrapper . error ) ; } return rest wrapper ; }	this method calls insertusers and adds a record passed in users table.
public static string capped int ( final long val ) { if ( val >= integer . max value ) { return over ; } else if ( val <= integer . min value ) { return under ; } return long . to string ( val ) ; }	return a long as a string but capped as a 32 - bit signed value.
private void create from assets ( string my db , file dbfile , input stream asset file input stream ) { output stream out = null ; try { string db path = dbfile . get absolute path ( ) ; db path = db path . substring ( num , db path . last index of ( str ) + num ) ; file db path file = new file ( db path ) ; if ( ! db path file . exists ( ) ) db path file . mkdirs ( ) ; file new db file = new file ( db path + my db ) ; out = new file output stream ( new db file ) ; byte [ ] buf = new byte [ num ] ; int len ; while ( ( len = asset file input stream . read ( buf ) ) > num ) out . write ( buf , num , len ) ; log . v ( str , str + new db file . get absolute path ( ) ) ; } catch ( io ex ) { log . v ( str , str + ex . get message ( ) ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( io ignored ) { } } } }	if a prepopulated db file exists in the assets folder it is copied to the dbpath.
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return person property ; case num : return page property ; case num : return equiv ; case num : return page view ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
protected string internal put ( string key , string new value ) { synchronized ( child and property lock ) { string old value = properties . get ( key ) ; if ( old value != null && old value . equals ( new value ) ) return old value ; properties = properties . put ( key , new value ) ; return old value ; } }	stores the given ( key , value ) pair , performing lazy initialization of the properties field if necessary.
public polyline ( pla point int p from corner , pla point int p to corner ) { if ( p from corner . equals ( p to corner ) ) throw new illegal argument exception ( classname + str ) ; lines list = new array list < pla line int > ( num ) ; pla direction dir = new pla direction ( p from corner , p to corner ) ; lines list . add ( new pla line int ( p from corner , dir . rotate 45 deg ( num ) ) ) ; lines list . add ( new pla line int ( p from corner , p to corner ) ) ; lines list . add ( new pla line int ( p to corner , dir . rotate 45 deg ( num ) ) ) ; corners allocate ( corner count ( ) ) ; precalculated corners [ num ] = p from corner ; precalculated corners [ num ] = p to corner ; }	creates a polyline consisting of 3 lines.
protected boolean is on same screen as children ( ) { return bool ; }	whether this preference group should be shown on the same screen as its contained preferences .
public static string format price ( double price ) { if ( price == null ) return str ; return format price ( price . double value ( ) ) ; }	formats a double representing a price into a string.
static void check log dir ( ) { if ( system . get property ( str ) == null ) { log . error ( str ) ; } }	checks whether mandatory log dir is given.
private static boolean is more above ( string src , int index ) { int ch ; int cc ; int len = src . length ( ) ; for ( int i = index + character . char count ( src . code point at ( index ) ) ; i < len ; i += character . char count ( ch ) ) { ch = src . code point at ( i ) ; cc = normalizer . get combining class ( ch ) ; if ( cc == combining class above ) { return bool ; } else if ( cc == num ) { return bool ; } } return bool ; }	implements the " more_above " condition specification : c is followed by one or more characters of combining class 230 ( above ) in the combining character sequence . regular expression : after c : [ { cc ! = 0 } ] * [ { cc = = 230 } ].
public void restore key ( string key ) { if ( ! key . equals ignore case ( str ) ) { string original key = key . substring ( key test mode . length ( ) ) ; object value = get ( key ) ; put ( original key , value ) ; clear ( key ) ; } }	restore the original value for the key after it has been changed in test mode .
public static comparable [ ] sort copy ( comparable [ ] objects ) { int len = objects . length ; comparable [ ] copy = new comparable [ len ] ; system . arraycopy ( objects , num , copy , num , len ) ; sort ( copy ) ; return copy ; }	sorts an array of comparable objects , returning a new array with the sorted items.
private utf8 constant parse utf8 constant ( int index ) throws io { int length = read short ( ) ; string builder cb = new string builder ( ) ; for ( int i = num ; i < length ; i ++ ) { int ch = read ( ) ; if ( ch < num ) { cb . append ( ( char ) ch ) ; } else if ( ( ch & num ) == num ) { int ch2 = read ( ) ; i ++ ; cb . append ( ( char ) ( ( ( ch & num ) << num ) + ( ch2 & num ) ) ) ; } else { int ch2 = read ( ) ; int ch3 = read ( ) ; i += num ; cb . append ( ( char ) ( ( ( ch & num ) << num ) + ( ( ch2 & num ) << num ) + ( ( ch3 & num ) ) ) ) ; } } return new utf8 constant ( class . get constant pool ( ) , index , cb . to string ( ) ) ; }	parses a utf - 8 constant pool entry .
@ override public boolean mark next sequence ( ) throws io { if ( m seq size < m limit && m pointer size + m pointer entry size <= m limit ) { m pointers . write byte ( ( int ) m checksum seq . get value ( ) ) ; m checksum seq . reset ( ) ; if ( m checksum qual != null ) { m pointers . write byte ( ( int ) m checksum qual . get value ( ) ) ; m checksum qual . reset ( ) ; } m pointers . write int ( ( int ) m seq size ) ; m pointer size += m pointer entry size ; return bool ; } return bool ; }	declares the beginning of a sequence .
public final double sample active count ( ) { return active count . get ( ) ; }	sample the active count.
private void preprocess data ( map < integer , map < integer , list < integer > > > knoten von spur nach spur mapping , map < integer , map < integer , string > > knoten spur link mapping ) { preprocess knoten spur link mapping ( knoten spur link mapping ) ; clean knoten von spur nach spur mapping ( knoten von spur nach spur mapping , knoten spur link mapping ) ; merge lanes on same link ( knoten von spur nach spur mapping , knoten spur link mapping ) ; }	calls several preprocessing procedures , the order of the calls is important !.
@ override public boolean mutate ( test case test , test factory factory ) { if ( randomness . next double ( ) >= properties . p change parameter ) return bool ; if ( ! is static ( ) ) { variable reference source = get source ( ) ; list < variable reference > objects = test . get objects ( source . get type ( ) , get position ( ) ) ; objects . remove ( source ) ; if ( ! objects . is empty ( ) ) { set source ( randomness . choice ( objects ) ) ; return bool ; } } return bool ; }	try to replace source of field with all possible choices.
public x ( string expr string , source locator locator , prefix resolver prefix resolver , int type ) throws javax . xml . transform . transformer exception { this ( expr string , locator , prefix resolver , type , null ) ; }	construct an xpath object.
private void add menu item ( j menu , string title , mwf node , int ad wf id ) { wf item = new wf ( title , node , ad wf id ) ; menu . add ( item ) ; item . add action listener ( this ) ; }	add menu item to - add new line to node.
public synchronized long allocate ( int length ) { int blocks = get block count ( length ) ; block range x = null ; for ( block range b : free space ) { if ( b . blocks >= blocks ) { x = b ; break ; } } long pos = get pos ( x . start ) ; if ( x . blocks == blocks ) { free space . remove ( x ) ; } else { x . start += blocks ; x . blocks -= blocks ; } return pos ; }	allocate a number of blocks and mark them as used .
public jenkins http client ( uri uri , string username , string password ) { this ( uri ) ; if ( is not blank ( username ) ) { credentials provider provider = client . get credentials provider ( ) ; auth scope scope = new auth scope ( uri . get host ( ) , uri . get port ( ) , auth scope . any realm ) ; username password credentials credentials = new username password credentials ( username , password ) ; provider . set credentials ( scope , credentials ) ; local context = new basic http context ( ) ; local context . set attribute ( str , new basic scheme ( ) ) ; client . add request interceptor ( new preemptive auth ( ) , num ) ; } }	create an authenticated jenkins http client.
public static set combine o ( set one , set two ) { if ( one == null || one . is empty ( ) ) { return two ; } if ( two == null || two . is empty ( ) ) { return one ; } set result set = new hash set ( ) ; iterator itr1 = one . iterator ( ) ; while ( itr1 . has next ( ) ) { string value1 = ( string ) itr1 . next ( ) ; result set . add ( value1 . to lower case ( ) ) ; } iterator itr2 = two . iterator ( ) ; while ( itr2 . has next ( ) ) { string value2 = ( string ) itr2 . next ( ) ; result set . add ( value2 . to lower case ( ) ) ; } return result set ; }	combines two sets which contains objectclass values of an entry in a case insensitive manner . oc values are sometimes returned by ldap in mixed case and when duplicate values for objectclass exists in a mixed case , there is a object class violation note : there is a possibility that this method will return null.
private string wrap ( string str ) { string builder buf = new string builder ( str ) ; int len = line length ; while ( len < buf . length ( ) ) { int idx = buf . last index of ( str , len ) ; if ( idx != - num ) { buf . replace ( idx , idx + num , breaker ) ; len = idx + breaker . length ( ) + line length ; } else { buf . insert ( len , breaker ) ; len += breaker . length ( ) + line length ; } } buf . insert ( num , str ) ; return buf . to string ( ) ; }	line - wrap the passed string as an html string with break strings inserted .
public static double pdf ( double x , double shape , double scale ) { if ( x < num ) return num ; if ( x == num ) { if ( shape == num ) return num / scale ; else return num ; } if ( shape == num ) return num / x ; if ( shape == - num ) { return math . sqrt ( x ) ; } final double xs = x / scale ; if ( shape == num ) { return math . exp ( - xs ) / scale ; } final double a = math . exp ( ( shape - num ) * math . log ( xs ) - xs - gamma function . ln gamma ( shape ) ) ; return a / scale ; }	probability density function of the gamma distribution.
public void flush ( ) { synchronized ( list ) { int n = num ; long m = num ; for ( t b : list ) { if ( halt ) throw new runtime exception ( first cause . get ( ) ) ; final int size = b . size ( ) ; final long counter = b . flush ( ) ; m += counter ; if ( debug ) log . debug ( str + size + str + counter ) ; } if ( info ) log . info ( str + n + str + m + str ) ; } }	flush each of the unsynchronized buffers onto their backing synchronized buffer .
public void log info ( string message ) { logger . info ( log prefix + message ) ; }	logs an information message using the logger of this interpreter .
private boolean match address ( final byte [ ] remote mask ) { if ( rule type == rule type . allwildcard ) { return bool ; } if ( prefix mask == null ) { return bool ; } if ( remote mask . length != prefix mask . length ) { return bool ; } for ( int i = num ; i < prefix mask . length ; i ++ ) { if ( ! wild card . get ( i ) && ( rule mask [ i ] & prefix mask [ i ] ) != ( remote mask [ i ] & prefix mask [ i ] ) ) { return bool ; } } return bool ; }	try to match remote client address using prefix mask and rule mask .
public static string sign ( string signing string , private key private key ) throws invalid key exception , signature exception { byte [ ] bytes = signing string . get bytes ( standard charsets . utf 8 ) ; signature sig ; try { sig = signature . get instance ( sh with rsa ) ; } catch ( no such algorithm exception e ) { throw new illegal argument exception ( str , e ) ; } sig . init sign ( private key ) ; sig . update ( bytes ) ; return hex . encode hex string ( sig . sign ( ) ) ; }	signs a string using the private key and sha 256 with rsa signing algorithm , and returns it as a hex - encoded string .
public object invoke ( method method , object target , extension context extension context , extension registry extension registry ) { @ suppress warnings ( str ) optional < object > optional target = ( target instanceof optional ? ( optional < object > ) target : optional . of nullable ( target ) ) ; return reflection utils . invoke method ( method , target , resolve parameters ( method , optional target , extension context , extension registry ) ) ; }	invoke the supplied method on the supplied target object with dynamic parameter resolution .
registered project put project ( project config config , folder entry folder , boolean updated , boolean detected ) throws server exception , conflict exception , not found exception { final registered project project = new registered project ( folder , config , updated , detected , this . project type registry ) ; projects . put ( project . get path ( ) , project ) ; return project ; }	creates registeredproject and caches it .
@ override public void remove listener ( final i < ? > listener ) { m listeners . remove listener ( listener ) ; }	removes a listener object from the realizer .
protected void assert result row count ( int expected , result set rs ) throws sql { int i = num ; while ( rs . next ( ) ) { i ++ ; } assert equals ( expected , i ) ; }	check that the result set row count matches .
private boolean is model useful ( contingency matrix cm ) { for ( int row = num ; row < cm . get number of predictions ( ) ; row ++ ) { for ( int col = num ; col < cm . get number of classes ( ) ; col ++ ) { if ( math . abs ( cm . get lift ( row , col ) - num ) > min advantage ) { return bool ; } } } return bool ; }	helper method to decide whether a model improves the training error enough to be considered .
public void scan ( class node cn ) { list < threat result > threats = new array list < threat result > ( ) ; for ( class handler class handler : class handlers ) { threat result result = class handler . scan class ( cn ) ; if ( result != null ) { threats . add ( result ) ; } } for ( method node mn : cn . methods ) { for ( method handler method handler : method handlers ) { threat result result = method handler . scan method ( mn ) ; if ( result != null ) { threats . add ( result ) ; } } } if ( threats . size ( ) > num ) { threats by class . put ( cn . name , threats ) ; } }	scans a class node .
public void reset ( ) { m channel number = num ; m active calls . clear ( ) ; m es . clear ( ) ; m neighbor i . clear ( ) ; m receive frequencies . clear ( ) ; m site i . clear ( ) ; m talkgroups . clear ( ) ; m transmit frequencies . clear ( ) ; m unique i . clear ( ) ; reset state ( ) ; }	performs a full reset.
public static string newick no lengths ( tree tree ) { string buffer buffer = new string buffer ( ) ; newick ( tree , tree . get root ( ) , bool , branch length type . no branch lengths , null , null , null , null , buffer ) ; buffer . append ( str ) ; return buffer . to string ( ) ; }	recursive function for constructing a newick tree representation in the given buffer .
@ override public string to string ( ) { return ( string . value of ( get type ( ) ) + str + get key ( ) + str + get value ( ) ) ; }	return string representation of event.
@ post @ path ( str ) @ produces ( { media type . application xml , media type . application json } ) @ consumes ( { media type . application xml , media type . application json } ) @ check permission ( roles = { role . security admin , role . restricted security admin } , block proxies = bool ) public string rotate i ( ) { ipsec mgr . verify i ( ) ; string version = ipsec mgr . rotate key ( ) ; audit mgr . record audit log ( null , null , ipsec service type , operation type enum . update system property , system . current time millis ( ) , audit log manager . auditlog success , null , str + version ) ; return version ; }	rotate the vipr ipsec pre - shared key .
public int append ( char chunk [ ] ) throws guacamole exception { return append ( chunk , num , chunk . length ) ; }	appends data from the given buffer to the current instruction .
public byte [ ] reset ( byte [ ] data ) { byte [ ] bytes = null ; if ( ( data [ num ] & num ) < num ) { bytes = new byte [ data [ num ] + num ] ; system . arraycopy ( data , num , bytes , num , data [ num ] + num ) ; } else { if ( ( data [ num ] & num ) > num ) { int len = data [ num ] & ( byte ) num ; int result = num ; for ( int i = num ; i < len ; i ++ ) { result |= ( data [ i + num ] & num ) << ( num * ( len - i - num ) ) ; } bytes = new byte [ result + len + num ] ; system . arraycopy ( data , num , bytes , num , result + len + num ) ; } } return bytes ; }	reset asn . 1 data stream after decryption , remove redundant bytes .
public vector clock ( ) { this ( new array list < clock entry > ( num ) , system . current time millis ( ) ) ; }	construct an empty vectorclock.
public analyzer add ( string name , nondominated population result ) { list < nondominated population > list = data . get ( name ) ; if ( list == null ) { list = new array list < nondominated population > ( ) ; data . put ( name , list ) ; } list . add ( result ) ; return this ; }	adds a new sample with the specified name.
public static void assert equals ( string msg , double [ ] expected , double [ ] observed , double tolerance ) { string builder out = new string builder ( msg ) ; if ( expected . length != observed . length ) { out . append ( str ) ; out . append ( str ) ; out . append ( expected . length ) ; out . append ( str ) ; out . append ( observed . length ) ; assert . fail ( out . to string ( ) ) ; } boolean failure = bool ; for ( int i = num ; i < expected . length ; i ++ ) { if ( ! precision . equals including na n ( expected [ i ] , observed [ i ] , tolerance ) ) { failure = bool ; out . append ( str ) ; out . append ( i ) ; out . append ( str ) ; out . append ( str ) ; out . append ( expected [ i ] ) ; out . append ( str ) ; out . append ( observed [ i ] ) ; } } if ( failure ) { assert . fail ( out . to string ( ) ) ; } }	verifies that two arrays are close ( sup norm ).
public void initialize atoms for finite ( list < datum > data , string filename , random random ) { beta = new double [ k ] ; dof = new double [ k ] ; omega = new array list < > ( k ) ; if ( filename != null ) { try { loc = batch mixture model . initialize clusters from file ( filename , k ) ; if ( loc . size ( ) < k ) { loc = batch mixture model . gonzalez initialize mixture centers ( loc , data , k , random ) ; } } catch ( file not found exception e ) { e . print stack trace ( ) ; loc = batch mixture model . gonzalez initialize mixture centers ( data , k , random ) ; } } else { loc = batch mixture model . gonzalez initialize mixture centers ( data , k , random ) ; } log . debug ( str , loc ) ; for ( int k = num ; k < this . k ; k ++ ) { beta [ k ] = base beta ; dof [ k ] = base nu ; omega . add ( base omega ) ; } }	initializes atom ( component ) distributions.
@ override public void on init ( list < ? extends index commit > commits ) throws io { if ( commits . is empty ( ) ) { return ; } log . info ( str , new commits logging info ( commits ) ) ; log . debug ( str , new commits logging debug ( commits ) ) ; update commits ( commits ) ; }	internal use for lucene.
public boolean is loading ( ) { return state . equals ( loading ) ; }	check if loading state is shown.
char sequence convert ( object value , string key ) ;	converts a given object to a json value .
@ override public final void sample ( ) { synchronized ( lock ) { long count = count . get ( ) ; long last count = last avg count ; last avg count = count ; long sum = sum . get ( ) ; double last sum = last avg sum ; last avg sum = sum ; if ( count == last count ) value = num ; else value = scale * ( sum - last sum ) / ( double ) ( count - last count ) ; } }	return the probe ' s next average .
public boolean login ( ) throws login exception { try { load password file ( ) ; } catch ( io ioe ) { login exception le = new login exception ( str + password file display name ) ; throw env help . init cause ( le , ioe ) ; } if ( user credentials == null ) { throw new login exception ( str ) ; } if ( logger . debug on ( ) ) { logger . debug ( str , str + password file display name ) ; } if ( try first pass ) { try { attempt authentication ( bool ) ; succeeded = bool ; if ( logger . debug on ( ) ) { logger . debug ( str , str ) ; } return bool ; } catch ( login exception le ) { clean state ( ) ; logger . debug ( str , str ) ; } } else if ( use first pass ) { try { attempt authentication ( bool ) ; succeeded = bool ; if ( logger . debug on ( ) ) { logger . debug ( str , str ) ; } return bool ; } catch ( login exception le ) { clean state ( ) ; logger . debug ( str , str ) ; throw le ; } } if ( logger . debug on ( ) ) { logger . debug ( str , str ) ; } try { attempt authentication ( bool ) ; succeeded = bool ; if ( logger . debug on ( ) ) { logger . debug ( str , str ) ; } return bool ; } catch ( login exception le ) { clean state ( ) ; logger . debug ( str , str ) ; throw le ; } }	begin user authentication ( authentication phase 1 ).
public builder update extension ( extension extension ) { extensions . add ( extension ) ; return this ; }	updates the given fields in the extension.
public void process utterance ( utterance utterance ) throws process exception { if ( utterance . get relation ( relation . segment ) == null ) { throw new illegal state exception ( str ) ; } utterance . set object ( sample info . utt name , diphone database . get sample info ( ) ) ; create unit relation ( utterance ) ; }	generates the unit relation from the segment relation .
public static int copy ( input stream in , output stream out ) throws io { assert . not null ( in , str ) ; assert . not null ( out , str ) ; try { return stream utils . copy ( in , out ) ; } finally { try { in . close ( ) ; } catch ( io ex ) { } try { out . close ( ) ; } catch ( io ex ) { } } }	copy the contents of the given inputstream to the given outputstream.
private string convert to attribute name ( string local name ) { return local name . replace ( str , str ) ; }	converts an xml element local name ( with underscores ) to an attribute name ( with spaces ) .
public expanded statement builder reference ( string property , object value ) { check can change ( ) ; extra info . add ( new reference info ( property , value ) ) ; return this ; }	add a reference to this statement .
@ target api ( build . version codes . honeycomb ) protected void swipe view ( view child , float delta x , float delta y ) { if ( is fixed view ( child ) ) { delta x = delta x / num ; } float delta x = math . abs ( delta x ) ; float fraction covered = delta x / ( float ) child . get width ( ) ; child . set translation x ( delta x ) ; child . set alpha ( num - fraction covered ) ; if ( delta x > num ) child . set rotation y ( - num * fraction covered ) ; else child . set rotation y ( num * fraction covered ) ; }	swipe a view by moving distance.
private void verify is root ( ) { if ( hierarchy elements . size ( ) != num ) { throw new illegal state exception ( str + str + hierarchy ) ; } }	verify that this node is the root.
@ override public int size ( ) { final reentrant lock lock = this . lock ; lock . lock ( ) ; try { return count ; } finally { lock . unlock ( ) ; } }	returns the number of elements in this deque .
private void verify with separate signing key ( x509 certificate cert , public key prev key , boolean sign flag , set < x509 certificate > stacked certs ) throws cert path validator exception { string msg = str ; if ( debug != null ) { debug . println ( str + str + msg + str ) ; } if ( ( stacked certs != null ) && stacked certs . contains ( cert ) ) { if ( debug != null ) { debug . println ( str + str ) ; } throw new cert path validator exception ( str , null , null , - num , basic reason . undetermined revocation status ) ; } if ( ! sign flag ) { build to new key ( cert , null , stacked certs ) ; } else { build to new key ( cert , prev key , stacked certs ) ; } }	we have a cert whose revocation status couldn ' t be verified by a crl issued by the cert that issued the crl.
private boolean map pattern elem pos ( int nesting , boolean is start , boolean is attr name ) { if ( num == nesting ) { if ( m pattern map size >= m pattern map . length ) { int pattern map [ ] = m pattern map ; int len = m pattern map . length ; m pattern map = new int [ m pattern map size + num ] ; system . arraycopy ( pattern map , num , m pattern map , num , len ) ; } if ( ! is start ) { m pattern map [ m pattern map size - num ] -= targetextra ; } m pattern map [ m pattern map size ] = ( m compiler . get token queue size ( ) - ( is attr name ? num : num ) ) + targetextra ; m pattern map size ++ ; is start = bool ; } return is start ; }	record the current position on the token queue as long as this is a top - level element.
public boolean add operation at first ( operation operation ) { if ( is running ) { if ( operation handler thread handler == null ) return bool ; return operation handler thread handler . post at front of queue ( new android operation ( this , operation ) ) ; } else { return operation queue . add ( new android operation ( this , operation , android operation . type . atfirst , null , num ) ) ; } }	add operation to operationqueue.
public void test shift left1 ( ) { byte a bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = num ; int number = num ; byte r bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . shift left ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	shiftleft ( int n ) , n = 0.
public static string to unitbytes ( long bytes ) { if ( bytes < num ) { return str + general unit kilobytes ; } long unit value ; string unit name ; if ( bytes < num ) { unit value = num ; unit name = general unit kilobytes ; } else if ( bytes < num ) { unit value = num ; unit name = general unit megabytes ; } else if ( bytes < num ) { unit value = num ; unit name = general unit gigabytes ; } else { unit value = num ; unit name = general unit terabytes ; } number format number format ; if ( ( double ) bytes * num / unit value < num ) number format = number forma ; else number format = number forma ; try { return number format . format ( ( double ) bytes / unit value ) + str + unit name ; } catch ( arithmetic exception ae ) { return str + unit name ; } }	converts the passed in number of bytes into a byte - size string.
@ override public enumeration < option > list options ( ) { vector < option > result = new vector < option > ( ) ; result . add element ( new option ( str + str + str + str + str , str , num , str ) ) ; result . add element ( new option ( str + str , str , num , str ) ) ; result . add element ( new option ( str + str , str , num , str ) ) ; result . add element ( new option ( str + str , str , num , str ) ) ; result . add element ( new option ( str + str + str , str , num , str ) ) ; result . add element ( new option ( str + str + str + str + str , str , num , str ) ) ; result . add all ( collections . list ( super . list options ( ) ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
public static string change password ( connection conn , string user name , string password ) throws exception { prepared statement prep = conn . prepare statement ( str ) ; prep . set string ( num , password ) ; prep . set string ( num , user name ) ; prep . execute update ( ) ; return password ; }	utility method to change a password of a user.
public object remove ( object key ) { process queue ( ) ; return map . remove ( key . create ( key , null ) ) ; }	removes association for given key , returning value previously associated with key , or null if none .
protected rectangle compute popup bounds ( int px , int py , int pw , int ph ) { toolkit toolkit = toolkit . get default toolkit ( ) ; rectangle screen bounds ; graphics configuration gc = combo box . get graphics configuration ( ) ; point p = new point ( ) ; swing utilities . convert point from screen ( p , combo box ) ; if ( gc != null ) { insets screen insets = toolkit . get screen insets ( gc ) ; screen bounds = gc . get bounds ( ) ; screen bounds . width -= ( screen insets . left + screen insets . right ) ; screen bounds . height -= ( screen insets . top + screen insets . bottom ) ; screen bounds . x += ( p . x + screen insets . left ) ; screen bounds . y += ( p . y + screen insets . top ) ; } else { screen bounds = new rectangle ( p , toolkit . get screen size ( ) ) ; } rectangle rect = new rectangle ( px , py , pw , ph ) ; if ( py + ph > screen bounds . y + screen bounds . height && ph < screen bounds . height ) { rect . y = - rect . height ; } return rect ; }	calculate the placement and size of the popup portion of the combo box based on the combo box location and the enclosing screen bounds.
public static intent build background shortcut intent ( file script , parcelable icon resource ) { intent intent = new intent ( ) ; intent . put extra ( intent . extra shortcut intent , build start in background intent ( script ) ) ; intent . put extra ( intent . extra shortcut name , script . get name ( ) ) ; intent . put extra ( intent . extra shortcut icon resource , icon resource ) ; return intent ; }	builds an intent that creates a shortcut to launch the provided script in the background .
public static boolean is shown ( final actor actor ) { return actor != null && actor . get stage ( ) != null ; }	null - safe check if the actor has a stage.
public static void add listener ( final diagnostic listener listener ) { if ( listener != null ) { listeners . add ( listener ) ; } }	add the given listener to the those notified whenever a diagnostic occurs.
public void shuffle training set ( ) { utils . shuffle list ( training files ) ; }	shuffles ( randomizes the order of ) the files appearing in the training set .
public ntlm ( boolean is proxy , url url , password authentication pw ) { super ( is proxy ? proxy authentication : server authentication , auth scheme . ntlm , url , str ) ; init ( pw ) ; }	create a ntlmauthentication : username may be specified as domain < backslash > username in the application authenticator.
public message channel create message channel ( sip request , message processor mp , hop next hop ) throws io { host target host = new host ( ) ; target host . set hostname ( next hop . get host ( ) ) ; host port target host port = new host port ( ) ; target host port . set host ( target host ) ; target host port . set port ( next hop . get port ( ) ) ; message channel return channel = mp . create message channel ( target host port ) ; return return channel ; }	creates a client transaction to handle a new request.
public static byte [ ] generate mac ( byte [ ] byte cipher text , secret key integrity key ) throws no such algorithm exception , invalid key exception { mac sha256 hmac = mac . get instance ( hmac algorithm ) ; sha256 hmac . init ( integrity key ) ; return sha256 hmac . do final ( byte cipher text ) ; }	generate the mac based on hmac_algorithm.
public void populate edit text ( string query ) { string text = query . trim ( ) ; set search string ( text , bool ) ; dispatch state change ( search view state . search ) ; }	populate the persistentsearchview with search query.
public static byte [ ] concat ( byte [ ] b1 , byte [ ] b2 ) { byte [ ] out = new byte [ b1 . length + b2 . length ] ; system . arraycopy ( b1 , num , out , num , b1 . length ) ; system . arraycopy ( b2 , num , out , b1 . length , b2 . length ) ; return out ; }	concatenates and returns the given byte arrays .
public static void put float ( string property , float val ) { simbrain preferences . put float ( property , val ) ; }	set a property whose value is a float .
public int hash code ( ) { return arrays . hash code ( this . uid ) ; }	a method to generate hash code for this mxf uid.
private void advance run state ( int target state ) { for ( ; ; ) { int c = ctl . get ( ) ; if ( run state at least ( c , target state ) || ctl . compare and set ( c , ctl of ( target state , worker count of ( c ) ) ) ) break ; } }	transitions runstate to given target , or leaves it alone if already at least the given target .
public static final double [ ] copy ( final double [ ] v ) { return arrays . copy of ( v , v . length ) ; }	returns a copy of this vector .
public void add action ( string action ) { object [ ] args = new string [ num ] ; simple date format sdf = new simple date format ( context . get string ( r . string . date format ) ) ; args [ num ] = sdf . format ( new date ( ) ) ; string timestamp = context . get string ( r . string . timestamp , args ) ; history . add ( action + timestamp ) ; notify listeners ( new property change event ( this , activity constants . history property , null , null ) ) ; }	add an action to the history of the client.
private filter operation codes ( ) { }	don ' t let anyone instantiate this class .
@ override public string to string ( ) { string buffer text = new string buffer ( ) ; if ( m train instances == null ) { text . append ( str ) ; } else { text . append ( str ) ; if ( ! m missing merge ) { text . append ( str ) ; } } text . append ( str ) ; return text . to string ( ) ; }	return a description of the evaluator.
public char sequence sub sequence ( int start , int end ) { return substring ( start , end ) ; }	has the same result as the substring function , but is present so that string may implement the charsequence interface .
private creation template to creation template ( attr set t ) { attr name attr = t . get attribute ( template name ) ; string name = null ; if ( name attr != null ) { name = name attr . get value ( ) ; } attr naming attr = t . get attribute ( template namingattribute ) ; string naming attribute = null ; if ( naming attr != null ) { naming attribute = naming attr . get value ( ) ; } attr class attr = t . get attribute ( template javaclass ) ; string [ ] class names = null ; if ( class attr != null ) { class names = class attr . get string values ( ) ; } attr set required = decode attr ( t . get attribute ( template required ) , str ) ; attr set optional = decode attr ( t . get attribute ( template optional ) , str ) ; attr set validated = decode attr ( t . get attribute ( template validated ) , str ) ; creation template template = new creation template ( ) ; array list classes = new array list ( ) ; try { if ( class names != null ) { for ( int i = num ; i < class names . length ; i ++ ) { class cls = class . for name ( class names [ i ] ) ; classes . add ( cls ) ; } } template = new creation template ( name , required , optional , classes ) ; } catch ( class not found exception e ) { template = new creation template ( name , required , optional ) ; } if ( validated != null ) { template . set validation ( validated ) ; } if ( naming attribute != null ) { template . set naming attribute ( naming attribute ) ; } return template ; }	reads in a attribute set and converts name - value pairs to a creationtemplate object .
public void place item ( item stack stack , block pos pos , world world , boolean centre item ) { double offset = ( centre item ) ? num : num ; entity item entityitem = new entity item ( world , ( double ) pos . get x ( ) + offset , ( double ) pos . get y ( ) + offset , ( double ) pos . get z ( ) + offset , stack ) ; entityitem . motion x = num ; entityitem . motion y = num ; entityitem . motion z = num ; entityitem . set default pickup delay ( ) ; world . spawn entity in world ( entityitem ) ; }	spawn a single item at the specified position .
private < m extends configuration client , p > managed object < m > create new managed object ( managed object definition < m , ? > d , managed object path < m , ? > p , property definition < p > naming property definition , string name , collection < property exception > exceptions ) { property set child properties = new property set ( ) ; for ( property definition < ? > pd : d . get all property definitions ( ) ) { try { create property ( child properties , p , pd ) ; } catch ( property exception e ) { if ( exceptions != null ) { exceptions . add ( e ) ; } } } if ( naming property definition != null ) { p value = naming property definition . decode value ( name ) ; child properties . set property values ( naming property definition , collections . singleton ( value ) ) ; } return new instance ( d , p , child properties , bool , naming property definition ) ; }	creates a new managed object with no active values , just default values .
public abstract void initialize constraints ( step step , settings settings ) ;	performs any initialization of the velocity and position constraints .
public void test empty commits ( ) throws exception { clear index with replication ( ) ; index ( master client , str , str , str , str ) ; empty update ( master client , str , str ) ; pull from master to slave ( ) ; r query ( num , str , slave client ) ; assert versions ( master client , slave client ) ; empty update ( master client , str , str ) ; pull from master to slave ( ) ; index ( master client , str , str , str , str ) ; empty update ( master client , str , str ) ; pull from master to slave ( ) ; r query ( num , str , slave client ) ; assert versions ( master client , slave client ) ; index ( master client , str , str , str , str ) ; empty update ( master client , str , str , str , str ) ; pull from master to slave ( ) ; r query ( num , str , master client ) ; r query ( num , str , slave client ) ; index ( master client , str , str , str , str ) ; empty update ( master client , str , str ) ; pull from master to slave ( ) ; string q = str ; r query ( num , q , master client ) ; r query ( num , q , slave client ) ; assert versions ( master client , slave client ) ; }	verify that empty commits and / or commits with opensearcher = false on the master do not cause subsequent replication problems on the slave.
private byte [ ] decrypt ( byte [ ] d , int start , int end , int key , int skip ) { if ( end - start - skip < num ) { skip = num ; } byte [ ] o = new byte [ end - start - skip ] ; int r = key ; int ipos ; int c1 = num ; int c2 = num ; for ( ipos = start ; ipos < end ; ipos ++ ) { int c = d [ ipos ] & num ; int p = ( c ^ ( r > > num ) ) & num ; r = ( ( c + r ) * c1 + c2 ) & num ; if ( ipos - start - skip >= num ) { o [ ipos - start - skip ] = ( byte ) p ; } } return o ; }	decrypt an array using the adobe type 1 font decryption algorithm .
@ override public final void insert all ( dbi ids ) { if ( ids . is empty ( ) || ( ids . size ( ) == num ) ) { return ; } if ( can bulk load ( ) ) { list < knn > leafs = new array list < > ( ids . size ( ) ) ; for ( dbid iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { leafs . add ( create new leaf entry ( dbid . deref ( iter ) ) ) ; } bulk load ( leafs ) ; } else { for ( dbid iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { insert ( iter ) ; } } do extra integrity checks ( ) ; }	inserts the specified objects into this index.
public void test case14 ( ) { byte r bytes [ ] = { num } ; big integer a number = big integer . one ; big integer b number = big integer . one ; big integer result = a number . divide ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	divide one by one .
public static boolean is supplemental ( int c ) { return ( c >= num && c <= num ) ; }	returns true if the specified character is a supplemental character .
private final string decode short unicode name ( int len ) throws io { int out ptr = num ; char [ ] out buf = text buffer . empty and get current segment ( ) ; int in ptr = input ptr ; input ptr += len ; final int [ ] codes = smile constants . s utf8 unit lengths ; final byte [ ] in buf = input buffer ; for ( int end = in ptr + len ; in ptr < end ; ) { int i = in buf [ in ptr ++ ] & num ; int code = codes [ i ] ; if ( code != num ) { switch ( code ) { case num : i = ( ( i & num ) << num ) | ( in buf [ in ptr ++ ] & num ) ; break ; case num : i = ( ( i & num ) << num ) | ( ( in buf [ in ptr ++ ] & num ) << num ) | ( in buf [ in ptr ++ ] & num ) ; break ; case num : i = ( ( i & num ) << num ) | ( ( in buf [ in ptr ++ ] & num ) << num ) | ( ( in buf [ in ptr ++ ] & num ) << num ) | ( in buf [ in ptr ++ ] & num ) ; i -= num ; out buf [ out ptr ++ ] = ( char ) ( num | ( i > > num ) ) ; i = num | ( i & num ) ; break ; default : report error ( str + integer . to hex string ( i ) + str ) ; } } out buf [ out ptr ++ ] = ( char ) i ; } return text buffer . set current and return ( out ptr ) ; }	helper method used to decode short unicode string , length for which actual length ( in bytes ) is known.
public void save device profile ( @ nonnull string user , @ nonnull string realm , @ nonnull push device settings device settings ) throws auth login exception { reject . if null ( user , realm , device settings ) ; try { devices dao . save device profiles ( user , realm , json utils . to json values ( collections . singleton list ( device settings ) ) ) ; } catch ( io e ) { debug . error ( str , user , realm , e ) ; throw new auth login exception ( e ) ; } }	saves the push device settings to the user ' s profile , overwriting any existing device profile .
public ranking image list provider in days ( int days ) { m time = integer . to string ( days ) + str ; return this ; }	sets time limit for a ranking list in days ( the default value is all time ) .
public void remove update listener ( animator update listener listener ) { if ( m update listeners == null ) { return ; } m update listeners . remove ( listener ) ; if ( m update listeners . size ( ) == num ) { m update listeners = null ; } }	removes a listener from the set listening to frame updates for this animation .
public final void db unavailable ( final boolean alarm up , final string exception msg , final string db info ) { if ( alarm up == fallback alarms interface . activated ) { array list recipients = new array list ( ) ; mail details bean mail details = new mail details bean ( ) ; mail details . set sender ( str ) ; recipients . add ( str ) ; mail details . set to recipients ( recipients ) ; mail details . set subject ( str ) ; mail details . set message ( str + db info + str + exception msg ) ; mail details . set server ( str ) ; smtp mail sender = new smtp ( ) ; try { mail sender . send mail ( mail details ) ; } catch ( mail sender exception e ) { log . debug ( e . get message ( ) ) ; } } }	sends an email warning about the db problems.
public static string tidy string ( string string ) { if ( string . matches ( str ) ) { return string ; } else { return string . replace all ( str , str ) ; } }	removed punctuation from the begging or end of input if it does not appear to be a sentence ending with a period .
public select < t > sort desc ( string ... columns ) { for ( string column : columns ) { m sorting order list . add ( column + str ) ; } return this ; }	sorts the specified columns in desc order.
public void test ulp neg ( ) { string a = str ; int a scale = num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal result = a number . ulp ( ) ; string res = str ; int res scale = num ; assert equals ( str , res , result . to string ( ) ) ; assert equals ( str , res scale , result . scale ( ) ) ; }	ulp ( ) of a negative bigdecimal.
public log record ( level level , string msg ) { level . get class ( ) ; this . level = level ; message = msg ; sequence number = global sequence number . get and increment ( ) ; thread id = default thread id ( ) ; millis = system . current time millis ( ) ; need to infer caller = bool ; }	construct a logrecord with the given level and message values.
public matrix correlation ( ) { final matrix corr = covariance ( ) ; final array v = corr . diagonal ( ) ; for ( int i = num ; i < dimension ; i ++ ) { for ( int j = num ; j < dimension ; j ++ ) { if ( i == j ) { if ( v . [ v . ( i ) ] == num ) { corr . [ corr . ( i , j ) ] = num ; } else { corr . [ corr . ( i , j ) ] *= num / math . sqrt ( v . [ v . ( i ) ] * v . [ v . ( j ) ] ) ; } } else { if ( v . [ v . ( i ) ] == num && v . [ v . ( j ) ] == num ) { corr . [ corr . ( i , j ) ] = num ; } else if ( v . [ v . ( i ) ] == num || v . [ v . ( j ) ] == num ) { corr . [ corr . ( i , j ) ] = num ; } else { corr . [ corr . ( i , j ) ] *= num / math . sqrt ( v . [ v . ( i ) ] * v . [ v . ( j ) ] ) ; } } } } return corr ; }	returns the correlation matrix.
@ not null public static save directory from ( file file ) throws file not found exception { file current file = file ; save directory result = null ; if ( current file == null ) { } else { result = create valid save directory ( current file ) ; current file = current file . get parent file ( ) ; if ( result != null ) { return result ; } else if ( current file == null ) { } else { result = create valid save directory ( current file ) ; current file = current file . get parent file ( ) ; if ( result != null ) { return result ; } else { } } } throw new file not found exception ( str + file ) ; }	returns a new valid instance of the class savedirectory.
public serializer serializer ( ) { return serializer ; }	returns the metastore serializer .
private void add included resources ( json api document json api document , persistent resource rec , list < string > requested relation paths ) { requested relation paths . for each ( null ) ; }	adds the requested relation resources to the included block of the jsonapidocument .
private void shift segments ( int from idx , int offset ) { for ( element element : elements ) { if ( element . end . left > from idx ) { shift segment ( element . start , from idx , offset ) ; shift segment ( element . end , from idx , offset ) ; if ( element . text != null ) { for ( segment text segment : element . text ) { shift segment ( text segment , from idx , offset ) ; } } } } }	iterates all existed elements and shifts their segments if needed.
public ref update . result modify file ( change edit edit , string file , raw input content ) throws auth exception , invalid change operation exception , io { return modify ( tree operation . change entry , edit , file , null , content ) ; }	modify file in existing change edit from its base commit .
private void start document ( final boolean multi object mode ) throws sax { if ( depth == num ) { content handler . start document ( ) ; if ( multi object mode ) { depth ++ ; } } }	fires the sax startdocument event towards the configured contenthandler .
public void flush ( ) throws io { writer . flush ( ) ; }	flushes the xmlwriter and the underlying output writer .
private static array list < grid collision job context wrapper > slice ( collection < collision job context > src , int num ) { array list < grid collision job context wrapper > slice = new array list < > ( ) ; iterator < collision job context > iter = src . iterator ( ) ; for ( int i = num ; i < num && iter . has next ( ) ; i ++ ) slice . add ( new grid collision job context wrapper ( iter . next ( ) , i ) ) ; return slice ; }	takes first n element from contexts list , wrap them and put it into a new list .
protected void calculate formatter ( float min , float max ) { float reference = num ; if ( m data == null || m data . get x ( ) < num ) { reference = math . max ( math . abs ( min ) , math . abs ( max ) ) ; } else { reference = math . abs ( max - min ) ; } int digits = utils . get decimals ( reference ) ; m default formatter = new default value formatter ( digits ) ; }	calculates the required number of digits for the values that might be drawn in the chart ( if enabled ) , and creates the default - value - formatter.
public request add ( request request ) { request . set request queue ( this ) ; synchronized ( m current requests ) { m current requests . add ( request ) ; } request . set sequence ( get sequence number ( ) ) ; request . add marker ( str ) ; if ( ! request . should cache ( ) ) { m network queue . add ( request ) ; return request ; } synchronized ( m waiting requests ) { string cache key = request . get cache key ( ) ; if ( m waiting requests . contains key ( cache key ) ) { queue < request > staged requests = m waiting requests . get ( cache key ) ; if ( staged requests == null ) { staged requests = new linked list < request > ( ) ; } staged requests . add ( request ) ; m waiting requests . put ( cache key , staged requests ) ; if ( volley log . debug ) { volley log . v ( str , cache key ) ; } } else { m waiting requests . put ( cache key , null ) ; m cache queue . add ( request ) ; } return request ; } }	adds a request to the dispatch queue .
public string lookup ( string data ) { iterator < string > it = map . get prefixed by ( data ) ; if ( ! it . has next ( ) ) return null ; return it . next ( ) ; }	return the last string in the set that can be prefixed by this string ( trie ' s are stored in alphabetical order ).
public static object load module ( string homedir , script engine engine , string name ) throws file not found exception , script exception { hash map < string , file > mp = ( hash map < string , file > ) engine . get ( str ) ; object ret = load ( mp . get ( name ) , engine ) ; return ret ; }	load a module into the javascript engine.
@ override public void modify variable id ( string node id , string new id ) { map < assignment , utility estimate > utilities2 = new hash map < assignment , utility estimate > ( ) ; for ( assignment a : table . key set ( ) ) { assignment b = new assignment ( ) ; for ( string var : a . get variables ( ) ) { string new var = ( var . equals ( node id ) ) ? new id : var ; b . add pair ( new var , a . get value ( var ) ) ; } utilities2 . put ( b , table . get ( a ) ) ; } table = utilities2 ; }	modifies a variable label with a new one.
public static long [ ] truncate i ( long [ ] v , int len ) { final int zap = ( v . length * long . size ) - len ; final int zap words = ( zap > > > long lo size ) ; final int zapbits = zap & long lo mask ; arrays . fill ( v , v . length - zap words , v . length , num ) ; if ( zapbits > num ) { v [ v . length - zap words - num ] &= ( long all bits > > > zapbits ) ; } return v ; }	truncate a bit string to the given length ( setting any higher bit to 0 ) .
public void test no resources does not wait predeclare locks synchronous queue ( ) throws exception { final properties properties = new properties ( ) ; final int ntasks = num ; final int core pool size = num ; final int max pool size = ntasks ; properties . set property ( test options . synchronous queue , str ) ; properties . set property ( test options . core pool size , str + core pool size ) ; properties . set property ( test options . max pool size , str + max pool size ) ; properties . set property ( test options . ntasks , str + ntasks ) ; properties . set property ( test options . nresources , str ) ; properties . set property ( test options . min locks , str ) ; properties . set property ( test options . max locks , str ) ; properties . set property ( test options . predeclare locks , str ) ; properties . set property ( test options . sort lock requests , str ) ; final result result = do comparison test ( properties ) ; assert equals ( str , ntasks , integer . parse int ( result . get ( str ) ) ) ; final int maxrunning = integer . parse int ( result . get ( str ) ) ; assert true ( str + maxrunning , core pool size <= maxrunning ) ; }	test where no locks are declared.
private void position at central directory ( ) throws io { boolean found = bool ; long off = archive . length ( ) - min eocd size ; if ( off >= num ) { archive . seek ( off ) ; byte [ ] sig = jb . eocd sig ; int curr = archive . read ( ) ; while ( curr != - num ) { if ( curr == sig [ pos 0 ] ) { curr = archive . read ( ) ; if ( curr == sig [ pos 1 ] ) { curr = archive . read ( ) ; if ( curr == sig [ pos 2 ] ) { curr = archive . read ( ) ; if ( curr == sig [ pos 3 ] ) { found = bool ; break ; } } } } archive . seek ( -- off ) ; curr = archive . read ( ) ; } } if ( ! found ) { throw new zip exception ( str ) ; } archive . seek ( off + cfd locator offset ) ; byte [ ] cfd offset = new byte [ word ] ; archive . read fully ( cfd offset ) ; currentcfdfoffset = zip long . get value ( cfd offset ) ; archive . seek ( currentcfdfoffset ) ; }	searches for the & quot ; end of central dir record & quot ; , parses it and positions the stream at the first central directory record .
public list query ( double x1 , double x2 ) { return super . query ( new interval ( math . min ( x1 , x2 ) , math . max ( x1 , x2 ) ) ) ; }	returns items whose bounds intersect the given bounds .
public static boolean is null ( object object ) { return object != null && object == null cache . get ( object . get class ( ) ) ; }	returns whether the given object is the magic object that represents the null value of its class .
public static void create destination folder ( string path ) { file fpath = new file ( path ) ; fpath . mkdirs ( ) ; }	creates a folder with a given path , including all necessary nonexistent parent directories.
public void remove all ( ) { log . debug ( str + connection to added . size ( ) ) ; connection to added . clear ( ) ; }	removes all connections referenced by this handler .
public float read float ( ) throws io { return primitive types . read float ( ) ; }	reads a float ( 32 bit ) from the source stream .
public synchronized static int insert lua state ( lua state l ) { int i ; for ( i = num ; i < states . size ( ) ; i ++ ) { lua state state = ( lua state ) states . get ( i ) ; if ( state != null ) { if ( state . get c ( ) == l . get c ( ) ) return i ; } } i = get next state index ( ) ; states . set ( i , l ) ; return i ; }	receives a existing luastate and checks if it exists in the states list.
public phone number validator ( @ non null final char sequence error message ) { super ( error message , regex ) ; }	creates a new validator , which allows to validate texts to ensure , that they represent valid phone numbers .
@ override public int hash code ( ) { return fully qualified name . hash code ( ) ; }	uses fullyqualifiedname to create a hashcode .
public d convert window to reference ( d apt ) { if ( scroll back reference rect == null ) return null ; else return new d . double ( ( apt . get x ( ) - scroll back reference rect . get x ( ) ) / scroll back reference rect . get width ( ) , ( apt . get y ( ) - scroll back reference rect . get y ( ) ) / scroll back reference rect . get height ( ) ) ; }	converts a point from window coordinates to reference coordinates.
public void clear ( ) { final reentrant lock lock = this . lock ; lock . lock ( ) ; try { for ( tenant queue q : qs . values ( ) ) { q . clear ( ) ; } } finally { lock . unlock ( ) ; } }	atomically removes all of the elements from this delay queue.
public void print usage ( print writer pw , int width , string cmd line syntax ) { int arg pos = cmd line syntax . index of ( str ) + num ; print wrapped ( pw , width , default syntax prefix . length ( ) + arg pos , default syntax prefix + cmd line syntax ) ; }	print the cmdlinesyntax to the specified writer , using the specified width .
private void add new line ( ) { if ( add line dialog == null ) { add line dialog = new add parallel line dialog ( ) ; } add line dialog . set chart engine ( engine ) ; add line dialog . show dialog ( ) ; if ( horizontal line radiobutton . is selected ( ) ) { set horizontal line selected ( ) ; } else if ( vertical line radiobutton . is selected ( ) ) { set vertical line selected ( ) ; } }	adds a new line .
public final static < t > completable future < list < t > > stream to completable future ( final stream < t > stream ) { return completable future . completed future ( stream . collect ( cyclops collectors . to list x ( ) ) ) ; }	create a completablefuture containing a list materialized from a stream.
@ suppress warnings ( str ) public static boolean is gzip supported ( final http servlet request request ) { if ( request != null ) { final enumeration < string > header names = request . get header names ( ) ; if ( header names != null ) { while ( header names . has more elements ( ) ) { final string header name = header names . next element ( ) ; final matcher m = pattern accept encoding . matcher ( header name ) ; if ( m . find ( ) ) { final string header value = request . get header ( header name ) ; final matcher m value = pattern gzip . matcher ( header value ) ; return m value . find ( ) ; } } } } return bool ; }	analyze headers of the request and searches for mangled ( by proxy ) for " accept - encoding " header and its mangled variations and gzip header value and its mangled variations .
private boolean is language allowed ( string language key ) { if ( allowed languages == null ) return bool ; return allowed languages . contains ( language key ) ; }	returns whether a language having the given key should be allowed to be loaded.
public list < boundary > populate ward ( final long zone id ) { list < boundary > ward list = new linked list < boundary > ( ) ; try { ward list = boundary service . get child boundaries by boundary id ( zone id ) ; } catch ( final exception e ) { logger . error ( str + e . get message ( ) ) ; throw new application runtime exception ( str , e ) ; } return ward list ; }	populate the ward list by zone.
static object new instance ( string class name , class loader cl , boolean do fallback ) throws configuration error { try { class provider class = find provider class ( class name , cl , do fallback ) ; object instance = provider class . new instance ( ) ; debug println ( str + provider class + str + cl ) ; return instance ; } catch ( class not found exception x ) { throw new configuration error ( str + class name + str , x ) ; } catch ( exception x ) { throw new configuration error ( str + class name + str + x , x ) ; } }	create an instance of a class using the specified classloader.
public void handle request ( list arguments ) { try { install logger migrate log = new install logger ( str migrate ) ; multiple migrate driver driver = new multiple migrate driver ( ) ; if ( arguments . is empty ( ) ) { debug . log ( str ) ; driver . migrate ( migrate log ) ; } else if ( arguments . size ( ) == num ) { debug . log ( str ) ; driver . migrate ( migrate log ) ; } } catch ( install abort exception ia ) { debug . log ( str , ia ) ; console . println raw text ( ia . get message ( ) ) ; } catch ( install exception ex ) { debug . log ( str , ex ) ; print console message ( loc hr err migrate , new object [ ] { ex . get message ( ) } ) ; } }	handle the request of migration .
public static synchronizer status make running status ( ) { return new synchronizer status ( status . running , new date ( ) , null ) ; }	makes a running status .
public static iterable < file > apply cwd ( file cwd , iterable < file > files ) { if ( files != null ) { list < file > result = new array list < file > ( ) ; for ( file f : files ) { result . add ( apply cwd ( cwd , f ) ) ; } return result ; } else { return null ; } }	given an iterable of files and a " current working directory " returns an iterable where the files that were relative are now absolute after having the " cwd " applied to them as their parent directory.
private void close ( boolean force ) { if ( close guard . compare and set ( bool , bool ) ) hadoop . close ( force ) ; }	close underlying rpc handler .
mutable big integer divide knuth ( mutable big integer b , mutable big integer quotient , boolean need remainder ) { if ( b . int len == num ) throw new arithmetic exception ( str ) ; if ( int len == num ) { quotient . int len = quotient . offset = num ; return need remainder ? new mutable big integer ( ) : null ; } int cmp = compare ( b ) ; if ( cmp < num ) { quotient . int len = quotient . offset = num ; return need remainder ? new mutable big integer ( this ) : null ; } if ( cmp == num ) { quotient . value [ num ] = quotient . int len = num ; quotient . offset = num ; return need remainder ? new mutable big integer ( ) : null ; } quotient . clear ( ) ; if ( b . int len == num ) { int r = divide one word ( b . value [ b . offset ] , quotient ) ; if ( need remainder ) { if ( r == num ) return new mutable big integer ( ) ; return new mutable big integer ( r ) ; } else { return null ; } } if ( int len >= knuth po thresh len ) { int trailing zero bits = math . min ( get lowest set bit ( ) , b . get lowest set bit ( ) ) ; if ( trailing zero bits >= knuth po thresh zeros * num ) { mutable big integer a = new mutable big integer ( this ) ; b = new mutable big integer ( b ) ; a . right shift ( trailing zero bits ) ; b . right shift ( trailing zero bits ) ; mutable big integer r = a . divide knuth ( b , quotient ) ; r . left shift ( trailing zero bits ) ; return r ; } } return divide magnitude ( b , quotient , need remainder ) ; }	calculates the quotient of this div b and places the quotient in the provided mutablebiginteger objects and the remainder object is returned.
@ suppress warnings ( str ) public void insert ( int id , comparable < e > priority ) { int i ; i = ++ n ; h p = new h ( ) ; while ( i > num ) { int p idx = i / num ; h e idx = ( h ) elements [ p idx ] ; p . id = e idx . id ; p . priority = e idx . priority ; if ( priority . compare to ( ( e ) p . priority ) > num ) { break ; } h ei = ( h ) elements [ i ] ; ei . id = p . id ; ei . priority = p . priority ; pos [ p . id ] = i ; i = p idx ; } h ei = ( h ) elements [ i ] ; ei . id = id ; ei . priority = priority ; pos [ id ] = i ; }	insert the element ( id ) with given priority.
external problem ( socket socket ) throws io { this ( socket . get input stream ( ) , socket . get output stream ( ) ) ; }	constructs an external problem using the specified socket .
private static void stop gc ( ) { gc should loop = bool ; synchronized ( lock ) { lock . notify ( ) ; } }	invoked from native code.
public final void insert element at ( int value , int at ) { if ( ( m first free + num ) >= m map size ) { m map size += m blocksize ; int new map [ ] = new int [ m map size ] ; system . arraycopy ( m map , num , new map , num , m first free + num ) ; m map = new map ; } if ( at <= ( m first free - num ) ) { system . arraycopy ( m map , at , m map , at + num , m first free - at ) ; } m map [ at ] = value ; m first free ++ ; }	inserts the specified node in this vector at the specified index.
public static @ nullable request body create gzip ( final media type media type , final string body ) { byte array output stream gzip byte array output stream = new byte array output stream ( ) ; try { output stream gzip output stream = new gzip ( gzip byte array output stream ) ; gzip output stream . write ( body . get bytes ( ) ) ; gzip output stream . close ( ) ; } catch ( io e ) { return null ; } return request body . create ( media type , gzip byte array output stream . to byte array ( ) ) ; }	creates a requestbody from a mediatype and gzip - ed body string.
public xintro activity builder remove fragment ( int fragment pos ) { intro fragment model list . remove ( fragment pos ) ; return this ; }	remove fragment from xintro activity builder .
public boolean update ( ) { return update ; }	perform updates if added documents already exist ?.
public tree viewer builder ( composite parent , int style ) { mappings = collections . empty map ( ) ; checkable = ( style & swt . check ) == swt . check ; if ( checkable ) { viewer = new checkbox tree viewer ( parent , style ) ; } else { viewer = new tree viewer ( parent , style ) ; } column viewer tool tip support . enable for ( viewer , tool tip . no recreate ) ; }	creates a new treeviewerbuilder .
@ override public void write ( byte [ ] buffer , int offset , int count ) throws io { synchronized ( int thread ) { int avail = ( wrote index - data end index + data . length ) % data . length ; if ( avail == num ) avail = data . length ; if ( avail < count ) { throw new io ( str + avail + str + count ) ; } if ( count > data . length - data end index ) { int first part = data . length - data end index ; int second part = count - first part ; system . arraycopy ( buffer , offset , data , data end index , first part ) ; system . arraycopy ( buffer , offset + first part , data , num , second part ) ; data end index = second part ; } else { system . arraycopy ( buffer , offset , data , data end index , count ) ; data end index += count ; } int thread . notify ( ) ; } }	will never block . always write to memory.
public void pause ( ) { pause lock . lock ( ) ; try { paused = bool ; } finally { pause lock . unlock ( ) ; } }	pauses the spider crawling .
public void add to consolitated msg ( final string message ) { if ( consolidated message != null && consolidated message . length ( ) > num ) { consolidated message = consolidated message + str ; } consolidated message = consolidated message + message ; }	add to the consolidated result message which will be displayed in the notification on closing the window . each message that will be added in new line of previous messages using html < br >.
public void sort ( final comparator < ? super t > comparator ) { synchronized ( m lock ) { collections . sort ( m list , comparator ) ; } notify data set changed ( ) ; }	sorts the content of this adapter using the specified comparator .
public string crop keep final character ( string string , char final char ) { string cropped = crop ( string ) ; if ( ( null == string ) || string . equals ( cropped ) ) { return string ; } if ( cropped . length ( ) == num ) { return cropped ; } return cropped + final char ; }	crops the given string and adds the given final character to the string ' s end.
public static boolean is derived adjective ( final string word ) { if ( word . length ( ) > num ) { if ( word . ends with ( str ) || word . ends with ( str ) ) return bool ; if ( word . ends with ( str ) ) return bool ; } return bool ; }	check the given word for derived adjectives like " magical " or " nomadic " .
string rename file ( string input filename ) { for ( pattern search exp : regex mappings . key set ( ) ) { matcher matcher = search exp . matcher ( input filename ) ; if ( matcher . find ( ) ) { string renamed = matcher . replace first ( regex mappings . get ( search exp ) ) ; return file sep char matcher . trim leading from ( renamed ) ; } } throw new moe problem ( str + str , input filename ) ; }	returns the filename according to the rules in mappings .
private static int validate adb server port ( @ non null string adb server port ) throws illegal argument exception { try { int port = integer . decode ( adb server port ) ; if ( port <= num || port >= num ) { throw new illegal argument exception ( str ) ; } return port ; } catch ( number format exception e ) { throw new illegal argument exception ( str ) ; } }	returns the integer port value if it is a valid value for adb server port.
public static string format elapsed ( timestamp start ) { if ( start == null ) return str ; long start time = start . get time ( ) ; long end time = system . current time millis ( ) ; return format elapsed ( end time - start time ) ; }	format elapsed time until now.
@ override public void stop ( ) { for ( thread thread : threads ) { thread . interrupt ( ) ; } try { for ( thread thread : threads ) { thread . join ( ) ; } } catch ( interrupted exception e ) { } }	kill all the threads , and shutdown .
private boolean verify published dual inet address ( string node id ) { dual inet address dual address = null ; configuration config = query configuration ( constants . node dualinetaddr config , node id ) ; if ( config != null ) { dual address = parse inet address config ( config ) ; } if ( ( dual address != null ) && dual address . equals ( inet address lookup map . get dual inet address ( ) ) ) { return bool ; } return bool ; }	returns true is found published dualinetaddress for this node , and it matches with current configured.
public void test recursive chains ( ) throws throwable { for ( execution mode m : execution mode . values ( ) ) for ( boolean add dead ends : new boolean [ ] { bool , bool } ) { final int val = num ; final int n = expensive tests ? num : num ; completable future < integer > head = new completable future < > ( ) ; completable future < integer > tail = head ; for ( int i = num ; i < n ; i ++ ) { if ( add dead ends ) m . then apply ( tail , null ) ; tail = m . then apply ( tail , null ) ; if ( add dead ends ) m . apply to either ( tail , tail , null ) ; tail = m . apply to either ( tail , tail , null ) ; if ( add dead ends ) m . then combine ( tail , tail , null ) ; tail = m . then combine ( tail , tail , null ) ; } head . complete ( val ) ; assert equals ( val + num * n , ( int ) tail . join ( ) ) ; } }	test long recursive chains of completablefutures with cascading completions.
public boolean response is string ( string oid ) { return string responses . contains ( oid ) ; }	determine if the response to a given ldap extended operation ( specified by oid ) should be treated as a string.
private static int type ( final class writer cw , final string desc ) { string t ; int index = desc . char at ( num ) == str ? desc . index of ( str ) + num : num ; switch ( desc . char at ( index ) ) { case str : return num ; case str : case str : case str : case str : case str : return integer ; case str : return float ; case str : return long ; case str : return double ; case str : t = desc . substring ( index + num , desc . length ( ) - num ) ; return object | cw . add type ( t ) ; default : int data ; int dims = index + num ; while ( desc . char at ( dims ) == str ) { ++ dims ; } switch ( desc . char at ( dims ) ) { case str : data = boolean ; break ; case str : data = char ; break ; case str : data = byte ; break ; case str : data = short ; break ; case str : data = integer ; break ; case str : data = float ; break ; case str : data = long ; break ; case str : data = double ; break ; default : t = desc . substring ( dims + num , desc . length ( ) - num ) ; data = object | cw . add type ( t ) ; } return ( dims - index ) << num | data ; } }	returns the int encoding of the given type .
public void log fine ( string message ) { logger . fine ( log prefix + message ) ; }	logs an information message using the logger of this interpreter ( logger level : fine ) .
public static optional < string > create input dialog ( final window owner , final string title , final string label ) { final text input dialog dialog = new text input dialog ( ) ; dialog . set title ( title ) ; dialog . set header text ( null ) ; dialog . set content text ( label ) ; dialog . init owner ( owner ) ; return dialog . show and wait ( ) ; }	asks the user for input .
private static string encode ( final string text ) throws unsupported encoding exception { return url . encode ( text , str ) ; }	encode text as utf - 8.
public static string convert to rgb ( int color ) { string red = integer . to hex string ( color . red ( color ) ) ; string green = integer . to hex string ( color . green ( color ) ) ; string blue = integer . to hex string ( color . blue ( color ) ) ; if ( red . length ( ) == num ) { red = str + red ; } if ( green . length ( ) == num ) { green = str + green ; } if ( blue . length ( ) == num ) { blue = str + blue ; } return str + red + green + blue ; }	method currently used by ongetdefaultvalue method to convert hex string provided in android : defaultvalue to color integer .
private static final void append encoded byte ( string buffer buffer , byte value , byte [ ] state ) { if ( state [ num ] != num ) { char c = ( char ) ( ( state [ num ] << num ) | ( ( ( int ) value ) & num ) ) ; buffer . append ( c ) ; state [ num ] = num ; } else { state [ num ] = num ; state [ num ] = value ; } }	append a byte to the given stringbuffer , packing two bytes into each character.
public sided plane ( double p x , double p y , double p z , vector v , double d ) { super ( v , d ) ; sig num = math . signum ( evaluate ( p x , p y , p z ) ) ; if ( sig num == num ) throw new illegal argument exception ( str ) ; }	construct a sided plane with a normal vector and offset .
public string build union query ( string [ ] sub queries , string sort order , string limit ) { string builder query = new string builder ( num ) ; int sub query count = sub queries . length ; string union operator = m distinct ? str : str ; for ( int i = num ; i < sub query count ; i ++ ) { if ( i > num ) { query . append ( union operator ) ; } query . append ( sub queries [ i ] ) ; } append clause ( query , str , sort order ) ; append clause ( query , str , limit ) ; return query . to string ( ) ; }	given a set of subqueries , all of which are select statements , construct a query that returns the union of what those subqueries return .
@ override public string to string ( ) { string buffer sb = new string buffer ( ) ; sb . append ( client id ) ; sb . append ( str ) ; switch ( status ) { case connected : sb . append ( context . get string ( r . string . connectedto ) ) ; break ; case disconnected : sb . append ( context . get string ( r . string . disconnected ) ) ; break ; case none : sb . append ( context . get string ( r . string . no status ) ) ; break ; case connecting : sb . append ( context . get string ( r . string . connecting ) ) ; break ; case disconnecting : sb . append ( context . get string ( r . string . disconnecting ) ) ; break ; case error : sb . append ( context . get string ( r . string . connection error ) ) ; } sb . append ( str ) ; sb . append ( host ) ; return sb . to string ( ) ; }	a string representing the state of the client this connection object represents.
void register callback ( bluetooth callback callback ) { synchronized ( m callbacks ) { m callbacks . add ( callback ) ; } }	register to start receiving callbacks for bluetooth events .
private void validate table meta data no row ( string table name pattern , string [ ] types ) throws exception { try ( result set tables = dbmd . get tables ( null , null , table name pattern , types ) ) { assert false ( string . format ( str , table name pattern , arrays . to string ( types ) ) , tables . next ( ) ) ; } }	helper method for test methods that retrieve metadata expecting no results .
void check class bounds ( diagnostic position pos , type type ) { check class bounds ( pos , new hash map < type symbol , type > ( ) , type ) ; }	check that class c does not implement directly or indirectly the same parameterized interface with two different argument lists .
private static string parse token ( string pattern , int [ ] index ref ) { string buffer buf = new string buffer ( ) ; int i = index ref [ num ] ; int length = pattern . length ( ) ; char c = pattern . char at ( i ) ; if ( c >= str && c <= str || c >= str && c <= str ) { buf . append ( c ) ; while ( i + num < length ) { char peek = pattern . char at ( i + num ) ; if ( peek == c ) { buf . append ( c ) ; i ++ ; } else { break ; } } } else { buf . append ( str ) ; boolean in literal = bool ; for ( ; i < length ; i ++ ) { c = pattern . char at ( i ) ; if ( c == str ) { if ( i + num < length && pattern . char at ( i + num ) == str ) { i ++ ; buf . append ( c ) ; } else { in literal = ! in literal ; } } else if ( ! in literal && ( c >= str && c <= str || c >= str && c <= str ) ) { i -- ; break ; } else { buf . append ( c ) ; } } } index ref [ num ] = i ; return buf . to string ( ) ; }	parses an individual token .
@ override public void node down ( long event uid , string node id ) { try { lock . lock ( ) ; untried connectors . put all ( tried connectors ) ; tried connectors . clear ( ) ; if ( untried connectors . size ( ) > num ) { condition . signal ( ) ; } } finally { lock . unlock ( ) ; } }	if a node goes down we try all the connectors again as one may now be available for replication < p > todo : there will be a better way to do this by finding which nodes backup has gone down .
public void remove cart item ( int index , boolean trigger external ops , local dispatcher dispatcher ) throws cart item modify exception { if ( is read only cart ( ) ) { throw new cart item modify exception ( str ) ; } if ( index < num ) return ; if ( cart lines . size ( ) <= index ) return ; shopping cart item item = cart lines . remove ( index ) ; item . set quantity ( big decimal . zero , dispatcher , this , trigger external ops , bool , bool , bool ) ; }	scipio : remove an item from the cart object.
private final void access check ( t obj ) { if ( ! cclass . is instance ( obj ) ) throw access check exception ( obj ) ; }	checks that target argument is instance of cclass.
protected void mark first time ( element elem ) { string elem name = elem . get name ( ) ; if ( elem name . equals ( str ) ) { seen html = bool ; } else if ( elem name . equals ( str ) ) { seen head = bool ; } else if ( elem name . equals ( str ) ) { if ( buf . length == num ) { char [ ] new buf = new char [ num ] ; new buf [ num ] = buf [ num ] ; buf = new buf ; } seen body = bool ; } }	marks the first time a tag has been seen in a document.
public static string time to string ( long period ) { period /= num ; final long milsecs = period % num ; period /= num ; final long secs = period % num ; period /= num ; final long mins = period % num ; period /= num ; final long hours = period ; return string . format ( str , hours , mins , secs , milsecs ) ; }	converts millisecond count to hh : mm : ss.
protected static boolean is user defined property ( string prop name ) { return ! standard prop names . contains ( prop name ) ; }	is this property a solr - standard property , or is it an extra property defined per - core by the user ?.
private boolean condition m0 ( string value , int index ) { if ( char at ( value , index + num ) == str ) { return bool ; } return contains ( value , index - num , num , str ) && ( ( index + num ) == value . length ( ) - num || contains ( value , index + num , num , str ) ) ; }	complex condition 0 for ' m '.
@ reference ( authors = str , title = str , booktitle = str , url = str ) public double compute tau ( long c , long d , double m , long wd , long bd ) { double tie = ( wd * ( wd - num ) + bd * ( bd - num ) ) > > > num ; return ( c - d ) / math . sqrt ( ( m - tie ) * m ) ; }	compute the tau correlation measure.
private void read object ( object input stream in ) throws io , class not found exception { in . default read object ( ) ; service id = new id ( in ) ; }	reads the service id , encoded as specified by the serviceid.
private void generate create events ( list < igfs path > created paths , boolean file ) { if ( evts . is recordable ( event type . evt igfs dir created ) ) { for ( int i = num ; i < created paths . size ( ) - num ; i ++ ) igfs utils . send events ( igfs ctx . kernal context ( ) , created paths . get ( i ) , event type . evt igfs dir created ) ; } igfs path leaf path = created paths . get ( created paths . size ( ) - num ) ; if ( file ) { igfs utils . send events ( igfs ctx . kernal context ( ) , leaf path , event type . evt igfs file created ) ; igfs utils . send events ( igfs ctx . kernal context ( ) , leaf path , event type . evt igfs file opened write ) ; } else igfs utils . send events ( igfs ctx . kernal context ( ) , leaf path , event type . evt igfs dir created ) ; }	generate events for created file or directory .
public opt in template class resolver ( set allowed classes , list trusted templates ) { this . allowed classes = allowed classes != null ? allowed classes : collections . empty set ; if ( trusted templates != null ) { trusted template names = new hash set ( ) ; trusted template prefixes = new array list ( ) ; iterator it = trusted templates . iterator ( ) ; while ( it . has next ( ) ) { string li = ( string ) it . next ( ) ; if ( li . starts with ( str ) ) li = li . substring ( num ) ; if ( li . ends with ( str ) ) { trusted template prefixes . add ( li . substring ( num , li . length ( ) - num ) ) ; } else { trusted template names . add ( li ) ; } } } else { trusted template names = collections . empty set ; trusted template prefixes = collections . empty list ; } }	creates a new instance .
protected void async op release ( ) { if ( async ops sem != null ) async ops sem . release ( ) ; }	releases asynchronous operations permit , if limited .
public static boolean valid system name config ( string system name , char type ) { if ( ! valid system name format ( system name , type ) ) { return bool ; } return bool ; }	public static method to validate system name for configuration returns ' true ' if system name has a valid meaning in current configuration , else returns ' false '.
public void remove all ( ) { if ( m records . size ( ) >= num ) { m records . clear ( ) ; m current position = - num ; notify observers ( ) ; } }	clear the internal cursor data .
public synchronized boolean start reindexer ( string name , boolean force ) throws reindexer already running exception { online reindexer < ? , ? , ? > reindexer = reindexers . get ( name ) ; validate reindexer not running ( reindexer ) ; if ( force || ! is current index version latest ( name , reindexer ) ) { reindexer . start ( ) ; return bool ; } return bool ; }	start the online reindexer if the current index is not already the latest .
@ override public void print stack trace ( ) { super . print stack trace ( ) ; if ( nested != null ) nested . print stack trace ( ) ; }	prints the composite message to system.
private static void update last modified ( file dest dir , string war file path ) { file war file = new file ( war file path ) ; dest dir . set last modified ( war file . last modified ( ) ) ; }	updates the last - modified timestamp of the webapp directory to that of the daemon war .
public void add child ( base assembly node child node ) { child node . parent node = this ; child nodes . add ( child node ) ; }	add a child node .
protected void notify history changed listeners ( ) { iterator < history changed listener > iter ; history changed listener l ; iter = m . iterator ( ) ; while ( iter . has next ( ) ) { l = iter . next ( ) ; l . history changed ( new history changed event ( this , history name , get history ( ) ) ) ; } }	notifies the history listeners of the event .
private void signal not full ( ) { final reentrant lock put lock = this . put lock ; put lock . lock ( ) ; try { not full . signal ( ) ; } finally { put lock . unlock ( ) ; } }	signals a waiting put.
private text view find text view by tag id ( final string tag id ) { for ( final text view view : m tag view map . values ( ) ) { final tag tag = ( tag ) view . get tag ( ) ; if ( tag id . equals ( tag . id ) ) { return view ; } } return null ; }	finds a textview by the tag id.
public space prune ( space prefix ) throws scope exception { space x = this ; array list < space > stack = new array list < > ( ) ; while ( x != null && ! x . equals ( prefix ) ) { stack . add ( num , x ) ; x = x . get parent ( ) ; } if ( x == null ) { throw new scope exception ( str ) ; } else { space result = new space ( universe , x . get domain ( ) ) ; for ( space space : stack ) { result = result . s ( space . get relation ( ) ) ; } return result ; } }	prune this space using the given prefix.
default void infof ( string format , object ... args ) { info ( string . format ( format , args ) ) ; }	log an info level message with given format and arguments .
public static int darker ( int color , float factor ) { int a = color . alpha ( color ) ; int r = color . red ( color ) ; int g = color . green ( color ) ; int b = color . blue ( color ) ; return color . argb ( a , math . max ( ( int ) ( r * factor ) , num ) , math . max ( ( int ) ( g * factor ) , num ) , math . max ( ( int ) ( b * factor ) , num ) ) ; }	retuns a darker color from a specified color by the factor .
public < fv > fv extract raw java field value ( object object ) throws sql { object val ; if ( field get method == null ) { try { val = field . get ( object ) ; } catch ( exception e ) { throw sql exception util . create ( str + this , e ) ; } } else { try { val = field get method . invoke ( object ) ; } catch ( exception e ) { throw sql exception util . create ( str + field get method + str + this , e ) ; } } @ suppress warnings ( str ) fv converted = ( fv ) val ; return converted ; }	return the value from the field in the object that is defined by this fieldtype .
public static void write file ( file file , byte [ ] data ) { try { random access file ra = new random access file ( file , str ) ; ra . write ( data ) ; ra . set length ( data . length ) ; ra . close ( ) ; } catch ( io e ) { throw new runtime exception ( str + file , e ) ; } }	create or overwrite a file .
public static double [ ] threshold string to array ( string top , int l ) { if ( top . starts with ( str ) ) { return ml . to double array ( top ) ; } else { double t [ ] = new double [ l ] ; arrays . fill ( t , double . parse double ( top ) ) ; return t ; } }	thresholdstringtoarray - parse a threshold option string to an array of l thresholds ( one for each label variable ) .
@ override public string [ ] determine column constraints ( result producer rp ) throws exception { return null ; }	determines if there are any constraints ( imposed by the destination ) on the result columns to be produced by resultproducers.
abstract set < string > init config names ( ) ;	let subclass start the needed config names.
public static int eval ( string url , string text ) throws io { string return value = null ; if ( url . starts with ( str ) ) { return value = do http ( url , text ) ; } else if ( url . starts with ( str ) ) { return value = do bsh ( url , text ) ; } else throw new io ( str + str ) ; try { return integer . parse int ( return value ) ; } catch ( exception e ) { return num ; } }	evaluate text in the interpreter at url , returning a possible integer return value .
public dsa ( byte [ ] encoded ) throws invalid key exception { clear old key ( ) ; decode ( encoded ) ; }	make a dsa private key from its der encoding ( pkcs # 8 ) .
private void send broadcast new operation ( target target , remote operation operation ) { intent intent = new intent ( action operation added ) ; if ( target . m account != null ) { intent . put extra ( extra account , target . m account ) ; } else { intent . put extra ( extra server url , target . m server url ) ; } send sticky broadcast ( intent ) ; }	sends a broadcast when a new operation is added to the queue . local broadcasts are only delivered to activities in the same process , but can ' t be done sticky : \.
int successful ( ) { return success . get ( ) ; }	total successful operations so far.
public void monitor ( string key ) { timer t = new timer ( bool ) ; t . schedule ( new watchable registration ( key ) , num * num , num * num ) ; }	activates a watchdog watching over a registration.
protected int check risk attribute ( ) { int ret val = num ; if ( debug . message enabled ( ) ) { debug . message ( str , adaptive ) ; } if ( risk attribute name != null && risk attribute value != null ) { set < string > risk attribute values = null ; risk attribute values = get identity attribute set ( risk attribute name ) ; if ( risk attribute values != null ) { for ( string risk attr : risk attribute values ) { if ( risk attribute value . equals ignore case ( risk attr ) ) { if ( debug . message enabled ( ) ) { debug . message ( str , adaptive ) ; } ret val = risk attribute score ; break ; } } } } if ( ! risk attribute invert ) { ret val = risk attribute score - ret val ; } return ret val ; }	check to see if the user profile has a risk attribute with value.
public static meth executor result execute instance ( string receiver , string selector , class [ ] types , object [ ] args ) { try { class receiver class = class . for name ( receiver ) ; constructor init = receiver class . get declared constructor ( new class [ num ] ) ; init . set accessible ( bool ) ; object target = init . new instance ( new object [ num ] ) ; object res = null ; try { method the method = get method ( receiver class , selector , types ) ; res = the method . invoke ( target , args ) ; return new meth executor result ( res ) ; } catch ( invocation target exception inv targ ex ) { throwable targ ex = inv targ ex . get target exception ( ) ; if ( targ ex == null ) { return new meth executor result ( res ) ; } else { return new meth executor result ( targ ex ) ; } } } catch ( virtual machine error e ) { system failure . initiate failure ( e ) ; throw e ; } catch ( throwable t ) { return new meth executor result ( t ) ; } }	send the message " selector " to an instance of the class named " receiver ".
private void write object ( object output stream stream ) throws io { stream . default write object ( ) ; marshal attributes ( attrs , stream ) ; }	writes attributes as a null - terminated list of marshalledinstances .
@ override synchronized public void write ( byte b [ ] , int off , int len ) throws io { if ( b == null ) { throw new null pointer exception ( ) ; } else if ( off < num || len < num || len > b . length - off ) { throw new index out of bounds exception ( ) ; } else if ( len == num ) { return ; } c . check write ( ) ; boolean is first record of the payload = bool ; try { do { boolean hold record = bool ; int howmuch ; if ( is first record of the payload && c . need to split payload ( ) ) { howmuch = math . min ( num , r . available data bytes ( ) ) ; if ( ( len != num ) && ( howmuch == num ) ) { hold record = bool ; } } else { howmuch = math . min ( len , r . available data bytes ( ) ) ; } if ( is first record of the payload && howmuch != num ) { is first record of the payload = bool ; } if ( howmuch > num ) { r . write ( b , off , howmuch ) ; off += howmuch ; len -= howmuch ; } c . write record ( r , hold record ) ; c . check write ( ) ; } while ( len > num ) ; } catch ( exception e ) { c . handle exception ( e ) ; } }	write the data out , now .
public boolean on intercept touch event ( motion event ev ) { @ suppress warnings ( str ) final boolean debug = bool ; if ( debug ) { log . d ( launcher . tag , str + ev + str + m dragging ) ; } acquire velocity tracker and add movement ( ev ) ; final int action = ev . get action ( ) ; final int [ ] drag layer pos = get clamped drag layer pos ( ev . get x ( ) , ev . get y ( ) ) ; final int drag layer x = drag layer pos [ num ] ; final int drag layer y = drag layer pos [ num ] ; switch ( action ) { case motion event . action move : break ; case motion event . action down : m motion down x = drag layer x ; m motion down y = drag layer y ; m last drop target = null ; break ; case motion event . action up : m last touch up time = system . current time millis ( ) ; if ( m dragging ) { f vec = is flinging to delete ( m drag object . drag source ) ; if ( ! delete drop target . will accept drop ( m drag object . drag info ) ) { vec = null ; } if ( vec != null ) { drop on fling to delete target ( drag layer x , drag layer y , vec ) ; } else { drop ( drag layer x , drag layer y ) ; } } end drag ( ) ; break ; case motion event . action cancel : cancel drag ( ) ; break ; } return m dragging ; }	call this from a drag source view .
public void test concurrent kb ( ) throws exception { final string namespace = get name ( ) ; final properties properties = get properties ( ) ; journal jnl = null ; try { jnl = new journal ( properties ) ; do concurrent create and discovery test ( jnl , namespace ) ; } finally { if ( jnl != null ) jnl . destroy ( ) ; } }	basic test of the concurrent create and discovery of a kb .
private void reset database ( tungsten properties service props , map < string , string > progress ) throws interrupted exception { data source administrator admin = null ; string service name = service props . get string ( replicator conf . service name ) ; try { admin = new data source administrator ( service props ) ; admin . prepare ( ) ; progress . put ( str , service name ) ; boolean cleared = admin . reset all ( ) ; if ( cleared ) { logger . info ( str ) ; } else { logger . info ( str + service name ) ; } } catch ( replicator exception e ) { logger . error ( string . format ( str , service name , e . get message ( ) ) , e ) ; } finally { if ( admin != null ) { admin . release ( ) ; } } }	resets all catalog data for data sources associated with current replicator .
private void initialize ideal point ( ) { ideal point = new double [ problem . get number of objectives ( ) ] ; arrays . fill ( ideal point , double . positive infinity ) ; }	initializes the ideal point .
private long start wait ( ) { return system . nano time ( ) ; }	initialize the timeout timer.
public static string [ ] read font names ( final font data font data ) { final string [ ] font names = new string [ num ] ; font names [ num ] = null ; final buffered reader br = new buffered reader ( new string reader ( new string ( font data . get bytes ( num , font data . length ( ) ) ) ) ) ; string line = null ; while ( bool ) { try { line = br . read line ( ) ; } catch ( final io e ) { log writer . write log ( str + e . get message ( ) ) ; } if ( line == null ) { break ; } if ( line . starts with ( str ) ) { final int name start = line . index of ( str , num ) ; if ( name start != - num ) { final int name end = line . index of ( str , name start ) ; if ( name end != - num ) { final string name = line . substring ( name start + num , name end ) ; font names [ num ] = name . to lower case ( ) ; break ; } } } } if ( br != null ) { try { br . close ( ) ; } catch ( final exception e ) { log writer . write log ( str + e + str ) ; } } if ( font data != null ) { font data . close ( ) ; } return font names ; }	return name of font name will be lowercase to avoid issues of capitalisation when used for lookup - if no name , will default to null mode is pdfdecoder.
private void write units of indentation ( int i ) throws io { for ( ; i > num ; i -- ) { writer . write ( indentation unit ) ; } }	write the specified number of indentation units to the writer .
private pattern parser ( ) throws hyphenation exception { token = new string builder ( ) ; parser = create parser ( ) ; parser . set content handler ( this ) ; parser . set error handler ( this ) ; hyphen char = str ; }	construct a pattern parser .
public static int cap between ( int min , int number , int max ) { assert true ( min <= max ) ; return math . min ( max , math . max ( min , number ) ) ; }	caps given number betwen given min and max , inclusive .
public boolean has extensions ( ) { return extensions != null ; }	return whether or not the holder ' s attribute certificate contains extensions .
public void munge ( string entity id , collection < statement > statements , collection < string > existing values , collection < string > existing refs , change source change ) { if ( statements . is empty ( ) ) { return ; } munge operation op = new munge operation ( entity id , statements , existing values , existing refs ) ; if ( source change != null ) { op . import from change ( source change ) ; } op . munge ( ) ; existing values . remove all ( op . extra valid subjects ) ; existing refs . remove all ( op . extra valid subjects ) ; return ; }	adds and removes entries from the statements collection to munge wikibase rdf exports into a more queryable form .
public void show property dialog ( ) { if ( m . get value ( ) != null ) { if ( m pd == null ) { int x = get location on screen ( ) . x ; int y = get location on screen ( ) . y ; if ( property dialog . get parent dialog ( this ) != null ) m pd = new property dialog ( property dialog . get parent dialog ( this ) , m , x , y ) ; else m pd = new property dialog ( property dialog . get parent frame ( this ) , m , x , y ) ; m pd . set visible ( bool ) ; } else { m pd . set visible ( bool ) ; } m . set value ( m . get value ( ) ) ; } }	displays the property edit dialog for the panel .
public lucene60 codec ( mode mode ) { super ( str ) ; this . stored fields format = new lucene50 stored fields format ( objects . require non null ( mode ) ) ; }	instantiates a new codec , specifying the stored fields compression mode to use .
public synchronized void remove ( string name ) { for ( int i = num ; i < modifications . size ( ) ; i ++ ) { modification mod = modifications . get ( i ) ; attribute attr = mod . get attribute ( ) ; if ( name . equals ignore case ( attr . get attribute description as string ( ) ) ) { modifications . remove ( i ) ; return ; } } }	removes the first attribute with the specified name in the set of modifications .
private boolean quiet sleep ( long ms ) { try { thread . sleep ( ms ) ; } catch ( interrupted exception e ) { return bool ; } return bool ; }	wrapper around thread . sleep ( ) without that annoying interruptedexception .
public void push frame ( local variable map vars , dml pc ) { call stack . push ( new dml ( vars , pc ) ) ; }	put current frame into stack due to function call.
protected void layout graphic modifiers ( draw context dc , av modifiers , ordered symbol osym ) { }	layout static graphic modifiers around the symbol.
public static synchronized void progress ( final string message ) { s last progress = message ; final print stream prog = get progress stream ( ) ; if ( prog != null ) { prog . println ( now ( ) + message ) ; prog . flush ( ) ; if ( prog . check error ( ) ) { s progress stream = null ; } } }	write a message to the progress stream if a log file exists .
private static boolean match ( char sequence string , char sequence pattern , int s ndx , int p ndx ) { int p len = pattern . length ( ) ; if ( p len == num ) { if ( pattern . char at ( num ) == str ) { return bool ; } } int s len = string . length ( ) ; boolean next is not wildcard = bool ; while ( bool ) { if ( ( s ndx >= s len ) == bool ) { while ( ( p ndx < p len ) && ( pattern . char at ( p ndx ) == str ) ) { p ndx ++ ; } return p ndx >= p len ; } if ( p ndx >= p len ) { return bool ; } char p = pattern . char at ( p ndx ) ; if ( next is not wildcard == bool ) { if ( p == str ) { p ndx ++ ; next is not wildcard = bool ; continue ; } if ( p == str ) { s ndx ++ ; p ndx ++ ; continue ; } if ( p == str ) { char p next = num ; if ( p ndx + num < p len ) { p next = pattern . char at ( p ndx + num ) ; } if ( p next == str ) { p ndx ++ ; continue ; } int i ; p ndx ++ ; for ( i = string . length ( ) ; i >= s ndx ; i -- ) { if ( match ( string , pattern , i , p ndx ) == bool ) { return bool ; } } return bool ; } } else { next is not wildcard = bool ; } if ( p != string . char at ( s ndx ) ) { return bool ; } s ndx ++ ; p ndx ++ ; } }	internal matching recursive function .
public void add grammar file ( string file name ) { grammar files . add ( file name ) ; }	adds a grammar file name .
private workflow . method rollback delete mirror device method ( uri vplex uri , uri vplex mirror uri ) { return new workflow . method ( rb delete mirror device method name , vplex uri , vplex mirror uri ) ; }	returns a workflow . method for deactivating mirror.
private string find cipher and strength ( byte [ ] supported ciphers , string [ ] tokens ) { byte s ; for ( int i = num ; i < strength . length ; i ++ ) { if ( ( s = strength [ i ] ) != num ) { for ( int j = num ; j < supported ciphers . length ; j ++ ) { if ( s == supported ciphers [ j ] && ( specified cipher == null || specified cipher . equals ( tokens [ j ] ) ) ) { switch ( s ) { case high strength : negotiated strength = str ; break ; case medium strength : negotiated strength = str ; break ; case low strength : negotiated strength = str ; break ; } return tokens [ j ] ; } } } } return null ; }	steps through the ordered ' strength ' array , and compares it with the ' supportedciphers ' array.
public static string [ ] split ( string line , string delim ) { list list = new array list ( ) ; string tokenizer t = new string tokenizer ( line , delim ) ; while ( t . has more tokens ( ) ) { list . add ( t . next token ( ) ) ; } return ( string [ ] ) list . to array ( new string [ list . size ( ) ] ) ; }	create a string array from a string separated by delim.
public static string slurp file ( file file ) throws io { reader r = new file reader ( file ) ; return slurp reader ( r ) ; }	returns all the text in the given file .
@ override public string to string ( ) { string builder result = new string builder ( limit - position ) ; for ( int i = position ; i < limit ; i ++ ) { result . append ( get ( i ) ) ; } return result . to string ( ) ; }	returns a string representing the current remaining chars of this buffer .
public void test equals unequal1 ( ) { string a = str ; int a scale = - num ; string b = str ; int b scale = num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; assert false ( a number . equals ( b number ) ) ; }	equals ( ) for unequal bigdecimals.
public void test case8 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; int a sign = - num ; int b sign = num ; byte r bytes [ ] = { - num , - num , - num , - num , - num , - num , - num , - num , - num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . subtract ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( - num , result . signum ( ) ) ; }	subtract two numbers of the same length and different signs.
public get form key cmd ( string process definition id , string task definition key ) { set process definition id ( process definition id ) ; if ( task definition key == null || task definition key . length ( ) < num ) { throw new activiti illegal argument exception ( str + task definition key + str ) ; } this . task definition key = task definition key ; }	retrieves a task form key .
protected abstract storage level storage level ( ) ;	returns the log storage level .
@ override public graphics create ( ) { if ( debug ) { m printstream . println ( str ) ; } postscript graphics psg = new postscript graphics ( this ) ; return ( psg ) ; }	clone a postscriptgraphics object.
private void parse actions ( ) { string tokenizer st = new string tokenizer ( actions , str , bool ) ; boolean comma = bool ; while ( st . has more tokens ( ) ) { string act = st . next token ( ) ; if ( act . equals ( str ) ) { continue ; } else if ( comma ) { if ( ! act . equals ( str ) ) { comma = bool ; break ; } } else if ( act . equals ignore case ( str ) ) { mask |= connect ; } else if ( act . equals ignore case ( str ) ) { mask |= accept ; } else if ( act . equals ignore case ( str ) ) { mask |= delegate ; } else if ( act . equals ignore case ( str ) ) { mask |= listen ; } else { break ; } comma = ! comma ; } if ( ! comma ) { throw new illegal argument exception ( str ) ; } }	parses the actions field and initializes the transient mask field .
public static boolean is valid name ( string name ) { if ( name == null ) { return bool ; } return name . length ( ) > num ; }	verifies that the specified name is valid for our service.
protected void add counters ( basic counters < mutable long > target , basic counters < mutable long > source ) { for ( enum < reader counter keys > key : reader counter keys . values ( ) ) { mutable long tcounter = target . get counter ( key ) ; if ( tcounter == null ) { tcounter = new mutable long ( ) ; target . set counter ( key , tcounter ) ; } mutable long scounter = source . get counter ( key ) ; if ( scounter != null ) { tcounter . add ( scounter . long value ( ) ) ; } } }	transfers the counters in partitioning .
private void recompute seperation ( double [ ] [ ] means , double [ ] sep ) { final int k = means . length ; assert ( sep . length == k ) ; boolean issquared = ( distance function instanceof squared euclidean distance function ) ; arrays . fill ( sep , double . positive infinity ) ; for ( int i = num ; i < k ; i ++ ) { double vector m1 = double vector . wrap ( means [ i ] ) ; for ( int j = num ; j < i ; j ++ ) { double d = distance function . distance ( m1 , double vector . wrap ( means [ j ] ) ) ; sep [ i ] = ( d < sep [ i ] ) ? d : sep [ i ] ; sep [ j ] = ( d < sep [ j ] ) ? d : sep [ j ] ; } } for ( int i = num ; i < k ; i ++ ) { sep [ i ] = issquared ? math . sqrt ( sep [ i ] ) : sep [ i ] ; sep [ i ] *= num ; } }	recompute the separation of cluster means .
private int transition ( int state , int symbol ) { for ( int i = state ; i < transitions . length ; i ++ ) { if ( ( transitions [ i ] % vocabulary size ) == symbol ) { return ( transitions [ i ] / vocabulary size ) ; } } return - num ; }	causes this fsm to transition to the next state given the current state and input symbol .
public synchronized ceylon config merge ( ceylon config other ) { for ( string key : other . get option names ( null ) ) { string [ ] values = other . get option values ( key ) ; set option values ( key , values ) ; } return this ; }	merges the options from the given configuration with the current one where duplicate options that exist locally will be overwritten by the ones encountered in the given configuration .
public static synchronized string rot13 ( string input ) { string buffer output = new string buffer ( ) ; if ( input != null ) { for ( int i = num ; i < input . length ( ) ; i ++ ) { char in char = input . char at ( i ) ; if ( ( in char >= str ) & ( in char <= str ) ) { in char += num ; if ( in char > str ) { in char -= num ; } } if ( ( in char >= str ) & ( in char <= str ) ) { in char += num ; if ( in char > str ) { in char -= num ; } } output . append ( in char ) ; } } return output . to string ( ) ; }	description of the method.
private long month range ( ) { value range start range = chrono . range ( month of year ) ; if ( start range . is fixed ( ) && start range . is int value ( ) ) { return start range . get maximum ( ) - start range . get minimum ( ) + num ; } return - num ; }	calculates the range of months .
public void animate ( marker with position marker , lat lng from , lat lng to ) { lock . lock ( ) ; m animation tasks . add ( new animation task ( marker , from , to ) ) ; lock . unlock ( ) ; }	animates a markerwithposition some time in the future .
@ override public int compare to ( component description o ) { int my pos = num ; int o pos = num ; if ( this instanceof language component description ) { my pos = num ; } else if ( this instanceof voice component description ) { my pos = num ; } if ( o instanceof language component description ) { o pos = num ; } else if ( o instanceof voice component description ) { o pos = num ; } if ( o pos - my pos != num ) { return ( o pos - my pos ) ; } return name . compare to ( o . name ) ; }	define a natural ordering for component descriptions.
public boolean [ ] test to string ( ) { return super . test to string ( ) ; }	checks whether the scheme ' s tostring ( ) method works even though the classifies hasn ' t been built yet .
public static byte [ ] escape eastern unicode byte stream ( byte [ ] orig bytes , string orig string ) { if ( orig bytes == null ) { return null ; } if ( orig bytes . length == num ) { return new byte [ num ] ; } int bytes len = orig bytes . length ; int buf index = num ; int str index = num ; byte array output stream bytes out = new byte array output stream ( bytes len ) ; while ( bool ) { if ( orig string . char at ( str index ) == str ) { bytes out . write ( orig bytes [ buf index ++ ] ) ; } else { int lo byte = orig bytes [ buf index ] ; if ( lo byte < num ) { lo byte += num ; } bytes out . write ( lo byte ) ; if ( lo byte >= num ) { if ( buf index < ( bytes len - num ) ) { int hi byte = orig bytes [ buf index + num ] ; if ( hi byte < num ) { hi byte += num ; } bytes out . write ( hi byte ) ; buf index ++ ; if ( hi byte == num ) { bytes out . write ( hi byte ) ; } } } else if ( lo byte == num ) { if ( buf index < ( bytes len - num ) ) { int hi byte = orig bytes [ buf index + num ] ; if ( hi byte < num ) { hi byte += num ; } if ( hi byte == num ) { bytes out . write ( num ) ; bytes out . write ( num ) ; buf index ++ ; } } } buf index ++ ; } if ( buf index >= bytes len ) { break ; } str index ++ ; } return bytes out . to byte array ( ) ; }	unfortunately , sjis has 0x5c as a high byte in some of its double - byte characters , so we need to escape it .
private static string builder dump ( string builder lbuffer , long value ) { for ( int j = num ; j < num ; j ++ ) { lbuffer . append ( chars [ ( int ) ( value > > shifts [ j ] ) & num ] ) ; } return lbuffer ; }	dump a long value into a stringbuilder .
public union member description with error ( ie delegate , composed type ref composed type ref , i [ ] sub scopes , boolean write access ) { super ( delegate ) ; this . composed type ref = composed type ref ; this . sub scopes = sub scopes ; max = sub scopes . length ; this . write access = write access ; }	creates a new instance of this wrapping description .
private void read object ( object input stream oos ) throws io , class not found exception { i instant = ( date midnight ) oos . read object ( ) ; date time field type type = ( date time field type ) oos . read object ( ) ; i field = type . get field ( i instant . get chronology ( ) ) ; }	reads the property from a safe serialization format .
public void generate loot chest ( world world , random random , block pos pos , int min , int max , i state , resource location loot table ) { world . set block state ( pos , state , num ) ; tile entity chest chest = ( tile entity chest ) world . get tile entity ( pos ) ; if ( chest != null ) chest . set loot table ( loot table , random . next long ( ) ) ; }	generates a loot chest at a location.
private void draw auto hit ( graphics g , coords hex ) { int base x = ( hex . get x ( ) * ( hex side [ zoom ] + hex side by sin30 [ zoom ] ) ) + left margin + hex side [ zoom ] ; int base y = ( ( ( num * hex . get y ( ) ) + num + ( hex . get x ( ) % num ) ) * hex side by cos30 [ zoom ] ) + top margin ; color alt = g . get color ( ) ; g . set color ( color . red ) ; g . draw oval ( base x - ( unit size - num ) , base y - ( unit size - num ) , ( num * unit size ) - num , ( num * unit size ) - num ) ; g . draw line ( base x - unit size - num , base y , ( base x - unit size ) + num , base y ) ; g . draw line ( base x + unit size + num , base y , ( base x + unit size ) - num , base y ) ; g . draw line ( base x , base y - unit size - num , base x , ( base y - unit size ) + num ) ; g . draw line ( base x , base y + unit size + num , base x , ( base y + unit size ) - num ) ; g . set color ( alt ) ; }	draws a red crosshair for artillery autohit hexes ( predesignated only ) .
public void remove ( ) throws recurrence rule exception { try { rule . remove ( ) ; } catch ( generic entity exception e ) { throw new recurrence rule exception ( e . get message ( ) , e ) ; } }	removes this rule from the persistant store .
private boolean should be escaped ( char c ) { return c < str || ( c >= str && c < str ) || ( c >= str && c < str ) ; }	json . org spec says that all control characters must be escaped .
public c ( final j table , final list < i > traces ) { add open function ( swing utilities . get window ancestor ( table ) , traces ) ; add ( new j ( c . proxy ( new c ( swing utilities . get window ancestor ( table ) , table ) ) ) ) ; add ( new copy selection action ( table ) ) ; }	creates a new menu object .
@ override public int available ( ) throws io { return ( out bytes . length + input stream . available ( ) ) ; }	returns metadata associated with the performed cryptographic operation .
public void add bug pattern ( bug pattern bug pattern ) { bug patterns . add ( bug pattern ) ; }	add a bugpattern reported by the plugin .
public spider git parser ( spider param params ) { super ( ) ; this . params = params ; }	instantiates a new spider git index parser .
public void on retry ( int retry no ) { log . d ( log tag , string . format ( str , retry no ) ) ; }	fired when a retry occurs , override to handle in your own code.
protected void analyze dto setter method ( method method , method model method model ) { method model . set setter ( bool ) ; type field type = method . get generic parameter types ( ) [ num ] ; string field name = get setter field name ( method ) ; field attributes . put ( field name , field type ) ; method model . set field name ( field name ) ; method model . set field type ( convert type ( field type ) ) ; }	populate model from given reflect setter method.
public static string load last color ( context context ) { try { shared preferences shared preferences = context . get shared preferences ( str , context . mode private ) ; string s = shared preferences . get string ( sp key last color , null ) ; color . parse color ( s ) ; return s ; } catch ( exception e ) { e . print stack trace ( ) ; return null ; } }	gets the color stored in shared preferences as the last picked color or null if it doesn ' t exist.
public bevel border ( int bevel type , color highlight , color shadow ) { this ( bevel type , highlight . brighter ( ) , highlight , shadow , shadow . brighter ( ) ) ; }	creates a bevel border with the specified type , highlight and shadow colors .
protected final void refresh session layer ( final location location ) { if ( ! m refresh session pending && is visible ( ) ) { log . d ( tag , str ) ; m refresh session pending = bool ; trigger session objects update ( null ) ; session objects refresh time = system . current time millis ( ) ; session objects refreshed at = location ; } else if ( ! is visible ( ) ) { log . v ( tag , str ) ; } else { log . v ( tag , str ) ; } }	refreshes reference and session layer.
public static int m date gap ( string day name ) { log . d ( str , day name ) ; if ( day name . equals ( str ) ) { return num ; } else if ( day name . equals ( str ) ) { return num ; } else if ( day name . equals ( str ) ) { return num ; } else if ( day name . equals ( str ) ) { return num ; } else if ( day name . equals ( str ) ) { return num ; } else if ( day name . equals ( str ) ) { return num ; } else { return num ; } }	get the day difference in the selected day and the first day in the week.
public static string remove additional party ( http servlet request request , http servlet response response ) { shopping cart cart = get cart object ( request ) ; string party id = request . get parameter ( str ) ; string role type id [ ] = request . get parameter values ( str ) ; list < string > event list = new linked list < string > ( ) ; locale locale = util http . get locale ( request ) ; int i ; if ( util validate . is empty ( party id ) || role type id . length < num ) { request . set attribute ( str , util properties . get message ( resource error , str , locale ) ) ; return str ; } if ( request . get attribute ( str ) != null ) { list < string > msg = util generics . check list ( request . get attribute ( str ) ) ; event list . add all ( msg ) ; } for ( i = num ; i < role type id . length ; i ++ ) { try { cart . remove additional party role ( party id , role type id [ i ] ) ; } catch ( exception e ) { debug . log info ( e . get localized message ( ) , module ) ; event list . add ( e . get localized message ( ) ) ; } } request . remove attribute ( str ) ; request . set attribute ( str , event list ) ; return str ; }	removes a previously associated party to order.
public map < string , string [ ] > crop ( final map < string , string [ ] > original ) { map < string , string [ ] > result = new hash map < string , string [ ] > ( original . size ( ) ) ; for ( map . entry < string , string [ ] > entry : original . entry set ( ) ) { string key = entry . get key ( ) ; if ( null == key ) { continue ; } string [ ] value = entry . get value ( ) ; string [ ] converted value ; if ( null == value ) { converted value = new string [ num ] ; converted value [ num ] = str ; } else { boolean cropping was needed = bool ; converted value = value ; for ( int i = num , l = value . length ; i < l ; i ++ ) { string cur value = value [ i ] ; string cropping result = crop ( cur value ) ; if ( ( cur value != cropping result ) & ! cropping was needed ) { cropping was needed = bool ; converted value = new string [ value . length ] ; system . arraycopy ( value , num , converted value , num , i ) ; converted value [ i ] = cropping result ; } if ( cropping was needed ) { converted value [ i ] = cropping result ; } } } result . put ( key , converted value ) ; } return result ; }	analyzes the given map and tries to re - use the values in string arrays and the string arrays themself to converse memory.
@ override int look for selectable position ( int position , boolean look down ) { final list adapter adapter = m adapter ; if ( adapter == null || is in touch mode ( ) ) { return invalid position ; } final int count = adapter . get count ( ) ; if ( ! m are all items selectable ) { if ( look down ) { position = math . max ( num , position ) ; while ( position < count && ! adapter . is enabled ( position ) ) { position ++ ; } } else { position = math . min ( position , count - num ) ; while ( position >= num && ! adapter . is enabled ( position ) ) { position -- ; } } if ( position < num || position >= count ) { return invalid position ; } return position ; } else { if ( position < num || position >= count ) { return invalid position ; } return position ; } }	find a position that can be selected ( i.
public void populate bottom tab items ( @ non null bottom tabs builder builder ) { if ( m container . get child count ( ) >= min bottom navigation items ) { check bottom item guidelines ( m container . get child count ( ) ) ; } list < bottom navigation item > build = builder . build ( ) ; for ( int i = num ; i < build . size ( ) ; i ++ ) { bottom navigation item item = build . get ( i ) ; item . set position ( i ) ; add bottom navigation item ( item ) ; } update bottom nav views ( ) ; select tab view ( ) ; }	convinient way to populate bottom navigation layout using bottomtabsbuilder.
public final int skip bytes ( int count ) throws java . io . io { int skipped = num ; long skip ; while ( skipped < count && ( skip = in . skip ( count - skipped ) ) != num ) { skipped += skip ; } return skipped ; }	see the general contract of the skipbytes method of datainput.
public general anderson darling test ( list < double > data , real distribution dist ) { if ( dist == null ) { throw new null pointer exception ( ) ; } this . dist = dist ; collections . sort ( data ) ; this . data = data ; run test ( ) ; }	constructs an anderson - darling test for the given column of data .
private final void insert ( object text ) { buf . insert ( buf . length ( ) - num , str ) ; buf . insert ( buf . length ( ) - num , text ) ; }	splices additional information for a node into the buffer .
public static void split textures ( file destination , file texture pack , double scale , boolean alphas , progress callback progress ) throws exception { if ( destination == null ) throw new illegal argument exception ( str ) ; log . info ( str + destination + str ) ; if ( ! destination . exists ( ) || ! destination . is directory ( ) ) { if ( destination . exists ( ) ) throw new runtime exception ( str ) ; if ( ! destination . mkdir ( ) ) throw new runtime exception ( str ) ; } get textures ( texture pack , scale , progress , alphas , bool , destination ) ; }	reads a minecraft texture pack and splits the individual block textures into.
public void test builder ( ) { sql root = new sql ( ) ; list < sql > additional exceptions = new array list < sql > ( ) ; for ( int count = num ; count <= num ; count ++ ) { additional exceptions . add ( new sql ( integer . to string ( count ) ) ) ; } sql < sql > builder = new sql < sql > ( root ) ; for ( sql ex : additional exceptions ) { builder . append ( ex ) ; } assert true ( str , builder . has exception ( ) ) ; sql result exception = builder . get exception ( ) ; assert same ( str , root , result exception ) ; check exception chain ( result exception , additional exceptions ) ; }	test for sqlexceptionchainbuilder constructed with a root sqlexception and multiple appends .
protected synchronized string next cnx key ( ) { if ( connections counter == integer . max value ) connections counter = num ; connections counter ++ ; int rand long = random . next int ( integer . max value ) ; return connections counter + ( rand long + str + id suffix ) ; }	according to the m_connfactorytype we decide what would be the connection key prefix.
public static boolean copy file safe ( final path src file , final path dest file ) throws io { return copy file safe ( src file , dest file , bool ) ; }	copy a file , preserving the attributes , but not overwrite it.
public static boolean is header ( header header ) { string xten = header . get string value ( xtension ) ; if ( xten == null ) { return bool ; } xten = xten . trim ( ) ; return xten . equals ( xtension bintable ) || xten . equals ( str ) ; }	check that this is a valid binary table header .
final void put float ( int offset , float value ) { unsafe . put float ( offset + address , value ) ; }	writes a float at the specified offset from this native object ' s base address .
public void doctype decl ( string root element , string public id , string system id , augmentations augs ) throws xni { f in dtd = bool ; try { if ( f lexical handler != null ) { f lexical handler . start dtd ( root element , public id , system id ) ; } } catch ( sax e ) { throw new xni ( e ) ; } if ( f decl handler != null ) { f declared attrs = new symbol hash ( ) ; } }	notifies of the presence of the doctype line in the document .
@ visible for testing static oma parse oma ( string entry ) { int index = entry . index of ( str ) ; long download id = long . parse long ( entry . substring ( num , index ) ) ; return new oma ( download id , entry . substring ( index + num ) ) ; }	parse oma entry from the sharedprefs string todo ( qinmin ) : use a file instead of sharedprefs to store the oma entry .
public void parse ( ) throws io { long length = num ; try { length = file . length ( ) ; } catch ( io e ) { throw new io ( str ) ; } try { parse ( str , length ) ; } catch ( io e ) { throw new io ( str ) ; } }	parses the mp4 file .
public void test ( ) throws sql { string sql = str + str + database creator . customers table + str + database creator . customers table + str + str + str ; result set result = statement . execute query ( sql ) ; hash map < integer , string > value = new hash map < integer , string > ( ) ; value . put ( num , str ) ; value . put ( num , str ) ; value . put ( num , str ) ; while ( result . next ( ) ) { int key = result . get int ( str ) ; string val = result . get string ( str ) ; assert true ( str , value . contains key ( key ) ) ; assert equals ( str , value . get ( key ) , val ) ; value . remove ( key ) ; } assert true ( str , value . is empty ( ) ) ; result . close ( ) ; }	selectfunctionalitytest # test_selectthreetables ( ) . selects records from a table using union.
public c ( final listener provider < i > listeners ) { super ( new border layout ( ) ) ; m listeners = listeners ; final j inner panel = new j ( new grid layout ( num , num ) ) ; inner panel . add ( build row ( str , m normal function checkbox ) ) ; inner panel . add ( build row ( str , m imported function checkbox ) ) ; inner panel . add ( build row ( str , m library function checkbox ) ) ; inner panel . add ( build row ( str , m thunk function checkbox ) ) ; inner panel . add ( build row ( str , m adjustor function checkbox ) ) ; add ( inner panel , border layout . north ) ; set border ( new titled border ( str ) ) ; }	creates a new function type panel object .
public drag context ( node draggable ) { this . node = draggable ; this . go to foreground on contact = bool ; this . touch id = null id ; this . activated = bool ; this . drag limits = new bounding box ( num , num , integer . max value , integer . max value ) ; this . drag threshold = num ; this . drag started = bool ; this . relocate threshold = num ; this . drag init action = null ; this . drag finish action = null ; touch handler = null ; mouse handler = null ; draggable . add event handler ( touch event . any , touch handler ) ; draggable . add event handler ( mouse event . any , mouse handler ) ; }	creates a dragcontext keeping track of touch events , so that a node is made draggable .
protected x509 certificate [ ] open certificate ( file certificate file ) { try { file input stream is = new file input stream ( certificate file ) ; return open certificate ( is , certificate file . get name ( ) ) ; } catch ( file not found exception ex ) { j . show message dialog ( frame , message format . format ( res . get string ( str ) , certificate file ) , res . get string ( str ) , j . warning message ) ; return null ; } }	open a certificate file .
public shape tile simplex ( pla line int alist p line alist ) { lines list = new array list < pla line int > ( p line alist . size ( ) ) ; for ( pla line int a line : p line alist ) lines list . add ( a line ) ; collections . sort ( lines list ) ; }	to be used when you know that the lines are surely ok example , when creating a new object from a mirros or rotate operation.
public proper fraction format ( number format format ) { this ( format , ( number format ) format . clone ( ) , ( number format ) format . clone ( ) ) ; }	create a proper formatting instance with a custom number format for the whole , numerator , and denominator .
private file create capture file ( int encoding type ) { return create capture file ( encoding type , str ) ; }	create a file in the applications temporary directory based upon the supplied encoding .
public double [ ] [ ] extract main set jacobian ( final ode state ) { final double [ ] p = state . get secondary state ( index ) ; final double [ ] [ ] d yd y0 = new double [ jode . get dimension ( ) ] [ jode . get dimension ( ) ] ; int j = num ; for ( int i = num ; i < jode . get dimension ( ) ; i ++ ) { system . arraycopy ( p , j , d yd y0 [ i ] , num , jode . get dimension ( ) ) ; j += jode . get dimension ( ) ; } return d yd y0 ; }	extract the jacobian matrix with respect to state .
public static string byte to hex string ( byte [ ] byte array ) { string builder builder = new string builder ( ) ; for ( int i = num ; i < byte array . length ; i ++ ) { int byte code = byte array [ i ] & num ; if ( byte code < num ) { builder . append ( num ) ; } builder . append ( integer . to hex string ( byte code ) ) ; } return builder . to string ( ) ; }	byte to hex string.
public static void assert not equal ( object expected , object actual ) { if ( verbose ) { log ( str + expected + str + actual + str ) ; } test utils . assert bool ( ! expected . equals ( actual ) ) ; }	asserts that the given objects are not equal using the first object ' s . equal ( ) method.
private boolean is empty ( string value ) { return value . length ( ) == num ; }	this method is used to determine if a root annotation value is an empty value.
public static object stream class lookup any ( class < ? > cl ) { return lookup stream class ( cl ) ; }	returns the descriptor for any class , whether or not the class implements serializable or externalizable .
public static void main ( string [ ] args ) { try { int server port = integer . parse int ( system . get property ( str , str ) ) ; t transport ; transport = new t ( new t ( str , server port ) ) ; transport . open ( ) ; t protocol = new t ( transport ) ; packet streamer . client client = new packet streamer . client ( protocol ) ; send packets ( client , ( short ) num , of . packet in , bool ) ; log . debug ( str ) ; client . terminate session ( str ) ; transport . close ( ) ; } catch ( t x ) { x . print stack trace ( ) ; } }	main function entry point ;.
public configuration parser ( boolean verify , class loader loader ) throws parser configuration exception { factory = document builder factory . new instance ( ) ; factory . set validating ( verify ) ; factory . set namespace aware ( bool ) ; factory . set expand entity references ( bool ) ; factory . set coalescing ( bool ) ; builder = factory . new document builder ( ) ; if ( verify ) builder . set error handler ( new xml ( ) ) ; if ( loader == null ) throw new null pointer exception ( str ) ; }	create a new configurationparser.
test environment ( system test environment system test environment , path working dir , path source dir , path class dir , path jacoco dir ) { this . system test environment = system test environment ; this . working dir = working dir ; this . source dir = source dir ; this . class dir = class dir ; this . jacoco dir = jacoco dir ; this . test class path = system test environment . classpath + str + class dir . to string ( ) ; }	creates a test environment for a specific system test method .
public application create jmx application interactive ( string connection string , string display name , environment provider provider , boolean persistent ) { return create jmx application interactive ( connection string , display name , provider , persistent , bool ) ; }	creates new application defined by jmx connection and adds it to the applications tree.
public object reference insert ( string reference , object value ) { string s = null ; if ( value != null ) { s = reference value ; } else { if ( reference . equals ( str ) ) { s = no reference value ; } } return s ; }	event handler for when a reference is inserted into the output stream .
public graphic component ( graphic attribute graphic , decoration decorator , int [ ] chars lto v , byte [ ] levels , int start , int limit , affine transform base tx ) { if ( limit <= start ) { throw new illegal argument exception ( str ) ; } this . graphic = graphic ; this . graphic advance = graphic . get advance ( ) ; this . decorator = decorator ; this . cm = create core metrics ( graphic ) ; this . base tx = base tx ; init local ordering ( chars lto v , levels , start , limit ) ; }	create a new graphiccomponent.
public static boolean has valid user in context ( security context security context ) { if ( ( security context != null ) && ( security context . get user principal ( ) instanceof os ) ) { return bool ; } else { return bool ; } }	determine if the security context has a valid storageosuser object .
private void handle end of stream ( state state , inner state inner state ) throws stop request { m info . m current bytes = inner state . m bytes so far ; m db . update download ( m info ) ; boolean length mismatched = ( inner state . m header content length != null ) && ( inner state . m bytes so far != integer . parse int ( inner state . m header content length ) ) ; if ( length mismatched ) { if ( cannot resume ( inner state ) ) { throw new stop request ( downloader service . status cannot resume , str ) ; } else { throw new stop request ( get final status for http error ( state ) , str ) ; } } }	called when we ' ve reached the end of the http response stream , to update the database and check for consistency .
public string to string ( ) { return m . format ( get stamp ( ) ) ; }	returns the timestamp as string in the specified format.
private string seconds to time ( int seconds ) { string time = str ; string minutes text = string . value of ( seconds / num ) ; if ( minutes text . length ( ) == num ) minutes text = str + minutes text ; string seconds text = string . value of ( seconds % num ) ; if ( seconds text . length ( ) == num ) seconds text = str + seconds text ; time = minutes text + str + seconds text ; return time ; }	convert seconds to time.
private void process new port ( datapath id sw , of p ) { if ( is link discovery suppressed ( sw , p ) ) { return ; } iof iof switch = switch service . get switch ( sw ) ; if ( iof switch == null ) { return ; } node port tuple npt = new node port tuple ( sw , p ) ; discover ( sw , p ) ; add to quarantine queue ( npt ) ; }	process a new port.
public amqp receiver ( amqp session session , string address , string receiver id ) { if ( address != null && address . is empty ( ) ) { throw new illegal argument exception ( str ) ; } this . user specified source = null ; this . session = session ; this . address = address ; this . receiver id = receiver id ; }	create a new receiver instance .
@ known failure ( str ) public void test get columns table with no catalog schema ( ) throws sql { try { result set no schema table = meta . get columns ( str , str , database creator . test tabl , str ) ; assert not null ( no schema table ) ; no schema table . last ( ) ; int size = no schema table . get row ( ) ; assert equals ( str , num , size ) ; } catch ( sql e ) { fail ( str + e . get message ( ) ) ; } try { result set no schema table = meta . get columns ( str , str , database creator . test tabl , str ) ; assert not null ( no schema table ) ; no schema table . last ( ) ; int size = no schema table . get row ( ) ; assert equals ( str , num , size ) ; } catch ( sql e ) { fail ( str + e . get message ( ) ) ; } try { result set no schema table = meta . get columns ( str , str , str , str ) ; assert not null ( no schema table ) ; no schema table . last ( ) ; int size = no schema table . get row ( ) ; assert equals ( str , num , size ) ; } catch ( sql e ) { fail ( str + e . get message ( ) ) ; } conn . close ( ) ; try { meta . get columns ( null , null , database creator . test tabl , str ) ; fail ( str ) ; } catch ( sql e ) { } }	java . sql . databasemetadata # getcolumns ( java . lang . string , java . lang . string , java . lang . string , java . lang . string ).
public static byte read byte ( ) { return scanner . next byte ( ) ; }	reads the next token from standard input , parses it as a byte , and returns the byte .
public void clear value local ( string column header ) { values . remove ( column header . to lower case ( ) ) ; }	locally clears the particular value.
public list close bucket advisors ( ) { list primaries held = collections . empty list ; if ( this . buckets != null ) { for ( int i = num ; i < this . buckets . length ; i ++ ) { proxy bucket region pbr = this . buckets [ i ] ; if ( pbr . is primary ( ) ) { if ( primaries held == collections . empty list ) { primaries held = new array list ( ) ; } primaries held . add ( integer . value of ( i ) ) ; } pbr . close ( ) ; } } return primaries held ; }	close the bucket advisors , releasing any locks for primary buckets.
public boolean is mac muted ( final string mac ) { final long mute till = get mac unmute time ( mac ) ; return mute till > system . current time millis ( ) ; }	is the given mac muted ? this may have the side effect of removing from the database any mac ' s whose mute has expired.
public abstract void insert spill before ( instruction s , register r , byte type , int location ) ;	insert a spill of a physical register before instruction s .
static public test suite ( ) { return proxy suite helper . suite when standalone ( test sparql update . class , str , new linked hash set < buffer mode > ( arrays . as list ( new buffer mode [ ] { buffer mode . transient , buffer mode . worm , buffer mode . mem store , buffer mode . rw } ) ) , test mode . quads ) ; }	we need to be running this test suite for each of the buffermodes that we want to support.
private synchronized void cleanup is complex type attribute ( ) { first attribute = null ; remaining attributes . clear ( ) ; is complex type attribute = bool ; }	cleanup the " is complex type attribute " info .
public static string left trim ( final string value ) { validate ( value , null string predicate , null string msg supplier ) ; return value . replace all ( str , str ) ; }	removes all spaces on left.
public float polar angle ( ) { return ( float ) math . to degrees ( angle ( ) ) ; }	angle of this sample in degrees.
public string check params non negative ( ) { string ret = str ; if ( param1 < num ) { ret = ret . concat ( pdf . get param1 name ( ) + str ) ; } if ( param2 < num ) { ret = ret . concat ( pdf . get param2 name ( ) + str ) ; } if ( upper bound < num ) { ret = ret . concat ( str ) ; } if ( lower bound < num ) { ret = ret . concat ( str ) ; } return ret ; }	checks to make sure that there are no negative parameters .
public static boolean validate ( string str , string reg ex , debug tmp debug ) { debug = tmp debug ; if ( str == null || str . length ( ) == num ) { debug . message ( str ) ; return bool ; } char [ ] value = str . to char array ( ) ; int count = value . length ; set h set = new hash set ( ) ; string tokenizer st = new string tokenizer ( reg ex , seperator ) ; while ( st . has more tokens ( ) ) { h set . add ( st . next token ( ) ) ; } iterator itr = h set . iterator ( ) ; while ( itr . has next ( ) ) { string obj = ( string ) itr . next ( ) ; if ( process ( value , obj , num , count ) > - num ) { debug . message ( str ) ; return bool ; } } return bool ; }	checks for invalid characters in the source string .
public static float turbulence2 ( float x , float y , float octaves ) { float t = num ; for ( float f = num ; f <= octaves ; f *= num ) t += math . abs ( noise2 ( f * x , f * y ) ) / f ; return t ; }	compute turbulence using perlin noise .
public void add map object ( internal map object map object ) { map objects . add ( map object ) ; }	adds a map object to this map layer .
public list < mock response > enqueue ( string ... paths ) { if ( paths == null ) { return null ; } list < mock response > mock response list = new array list < > ( ) ; for ( string path : paths ) { fixture fixture = fixture . parse from ( path , parser ) ; mock response mock response = new mock response ( ) ; if ( fixture . status code != num ) { mock response . set response code ( fixture . status code ) ; } if ( fixture . body != null ) { mock response . set body ( fixture . body ) ; } if ( fixture . delay != num ) { mock web server . set dispatcher ( new delayed dispatcher ( fixture . delay , time unit . milliseconds ) ) ; } if ( fixture . headers != null ) { for ( string header : fixture . headers ) { mock response . add header ( header ) ; } } mock web server . enqueue ( mock response ) ; mock response list . add ( mock response ) ; } return mock response list ; }	given paths will be parsed to fixtures and added to the queue . can be multiple.
@ override public void end of stream ( ) throws ade exception { double min prob = num ; if ( m total interval count == num ) { m total interval count = num ; } for ( entry < string , bernoulli score . msg data > entry : m msg data . entry set ( ) ) { final full bernoulli msg data data = ( full bernoulli msg data ) entry . get value ( ) ; data . m prob = ( ( double ) data . m count + num ) / ( m total interval count + num ) ; if ( data . m prob < num || data . m prob >= num ) { logger . info ( entry . get key ( ) + str + data . m prob + str + data . m count + str + m total interval count + str ) ; } if ( data . m prob < min prob ) { min prob = data . m prob ; } data . m out of cluster prob = ( ( double ) data . m out of cluster count + num ) / ( m total interval count + num ) ; if ( data . m out of cluster count < min prob && data . m out of cluster count > num ) { min prob = data . m out of cluster count ; } } for ( bernoulli score . msg data data super : m msg data . values ( ) ) { final full bernoulli msg data data = ( full bernoulli msg data ) data super ; final double probability = data . m prob ; data . m score = - math . log ( probability ) ; if ( data . m score > num ) { data . m score = num ; } final double out of context probability = data . m out of cluster prob ; data . m out of context score = - math . log ( out of context probability ) ; if ( data . m out of context score > num ) { data . m out of context score = num ; } } m trained = bool ; }	calculate the probabilities and scores for each message ' s data after going through all the analyzed intervals.
public boolean has next key typed ( ) { synchronized ( key lock ) { return ! keys typed . is empty ( ) ; } }	returns true if the user has typed a key .
public void add operator ( variation operator ) { operators . add ( operator ) ; }	adds an operator to be used in the auto - adaptive multi - method recombination .
public r params to multipart entity ( boolean isrepeatable ) { try { m http entity = create multipart entity ( isrepeatable ) ; } catch ( io e ) { e . print stack trace ( ) ; } return ( r ) this ; }	convert params to multipart entity .
private static int parse int ( string value , int begin index , int end index ) throws number format exception { if ( begin index < num || end index > value . length ( ) || begin index > end index ) { throw new number format exception ( value ) ; } int i = begin index ; int result = num ; int digit ; if ( i < end index ) { digit = character . digit ( value . char at ( i ++ ) , num ) ; if ( digit < num ) { throw new number format exception ( str + value . substring ( begin index , end index ) ) ; } result = - digit ; } while ( i < end index ) { digit = character . digit ( value . char at ( i ++ ) , num ) ; if ( digit < num ) { throw new number format exception ( str + value . substring ( begin index , end index ) ) ; } result *= num ; result -= digit ; } return - result ; }	parse an integer located between 2 given offsets in a string.
public boolean is alert definition created ( stat alert definition alert definition ) { synchronized ( alert definitions ) { return alert definitions . contains key ( integer . value of ( alert definition . get id ( ) ) ) ; } }	convenience method to check whether an alert definition is created .
public static double logpoisson pd ( double x plus 1 , double lambda ) { if ( double . is infinite ( lambda ) ) { return double . negative infinity ; } if ( x plus 1 > num ) { return raw log probability ( x plus 1 - num , lambda ) ; } if ( lambda > math . abs ( x plus 1 - num ) * math util . lo * double . max exponent / num ) { return - lambda - gamma distribution . log gamma ( x plus 1 ) ; } else { return raw log probability ( x plus 1 , lambda ) + math . log ( x plus 1 / lambda ) ; } }	compute the poisson distribution pdf with an offset of + 1 log pdf ( x_plus_1 - 1 , lambda ).
public void check and notify ( ) { for ( file alteration listener listener : listeners ) { listener . on start ( this ) ; } file root file = root entry . get file ( ) ; if ( root file . exists ( ) ) { check and notify ( root entry , root entry . get children ( ) , list files ( root file ) ) ; } else if ( root entry . is exists ( ) ) { check and notify ( root entry , root entry . get children ( ) , file utils . empty file array ) ; } else { } for ( file alteration listener listener : listeners ) { listener . on stop ( this ) ; } }	check whether the file and its chlidren have been created , modified or deleted .
private double allowable error ( int rank ) { int size = samples . size ( ) ; final double error = calculate error ( rank , size ) ; final double min error = size + num ; if ( error < min error ) { return error ; } return min error ; }	specifies the allowable error for this rank , depending on which quantiles are being targeted.
public retry policy with max duration ( long max duration , time unit time unit ) { assert . not null ( time unit , str ) ; assert . state ( time unit . to nanos ( max duration ) > delay . to nanos ( ) , str ) ; this . max duration = new duration ( max duration , time unit ) ; return this ; }	sets the max duration to perform retries for , else the execution will be failed .
private static final void cleanup namespace nodes ( zoo keeper zkc , string root , string self broker url ) throws exception { for ( string node : zkc . get children ( root , bool ) ) { string current path = root + str + node ; list < string > children = zkc . get children ( current path , bool ) ; if ( children . size ( ) == num ) { cleanup single namespace node ( zkc , current path , self broker url ) ; } else { cleanup namespace nodes ( zkc , current path , self broker url ) ; } } }	cleanupnamespacenodes is only called when the namespaceservice is initialized.
string validate logix reference ( string name ) { logix l = null ; if ( name != null ) { if ( name . length ( ) > num ) { l = logix manager . get by user name ( name ) ; if ( l != null ) { return name ; } } l = logix manager . get by system name ( name ) ; } if ( l == null ) { message invalid action item name ( name , str ) ; return null ; } return name ; }	checks logix reference of text .
protected void clear menu selection ( ) { popup menu group . clear selection ( ) ; update selection status ( ) ; }	clears the selection of the button and also the toggle button .
public double distance ( lat lng ll ) { double er = num ; double lat from = math . to radians ( get lat ( ) ) ; double lat to = math . to radians ( ll . get lat ( ) ) ; double lng from = math . to radians ( get lng ( ) ) ; double lng to = math . to radians ( ll . get lng ( ) ) ; double d = math . acos ( math . sin ( lat from ) * math . sin ( lat to ) + math . cos ( lat from ) * math . cos ( lat to ) * math . cos ( lng to - lng from ) ) * er ; return d ; }	calculate the surface distance in kilometres from the this latlng to the given latlng .
public static string encode ( string encode ) { string builder str = new string builder ( encode ) ; string key ; int i = num ; while ( i < str . length ( ) ) { key = find value ( str . char at ( i ) ) ; if ( key != null ) { str . replace ( i , i + num , key ) ; i += key . length ( ) ; } else { i ++ ; } } return str . to string ( ) ; }	converts special characters in ascii into html entities ( e.
protected static boolean try to lock ( string service name ) { distributed lock service service = distributed lock service . get service named ( service name ) ; boolean locked = service . lock ( str , num , - num ) ; if ( locked ) { service . unlock ( str ) ; } return boolean . value of ( locked ) ; }	accessed via reflection . do not remove.
public int hash code ( ) { lat lon point llp = get location ( ) ; int hc1 = float . float to int bits ( llp . get latitude ( ) ) ; int hc2 = float . float to int bits ( llp . get longitude ( ) ) ; return hc1 ^ ( hc2 << num ) ^ ( hc2 > > > num ) ; }	override hashcode so that two intersections at the same location have the same hashcode .
private x load from services file ( string uri , string resource name , input stream in ) { if ( debug ) debug println ( str + resource name ) ; buffered reader rd ; try { rd = new buffered reader ( new input stream reader ( in , str ) , default line length ) ; } catch ( java . io . unsupported encoding exception e ) { rd = new buffered reader ( new input stream reader ( in ) , default line length ) ; } string factory class name ; x result factory = null ; while ( bool ) { try { factory class name = rd . read line ( ) ; } catch ( io x ) { break ; } if ( factory class name != null ) { int hash index = factory class name . index of ( str ) ; if ( hash index != - num ) { factory class name = factory class name . substring ( num , hash index ) ; } factory class name = factory class name . trim ( ) ; if ( factory class name . length ( ) == num ) { continue ; } try { x found factory = create instance ( factory class name ) ; if ( found factory . is object model supported ( uri ) ) { result factory = found factory ; break ; } } catch ( exception ignored ) { } } else { break ; } } io utils . close quietly ( rd ) ; return result factory ; }	searches for a xpathfactory for a given uri in a meta - inf / services file .
private synchronized void stop ( ) { while ( m activities . size ( ) > num ) { activity a = ( activity ) m activities . get ( m activities . size ( ) - num ) ; a . cancel ( ) ; } set running ( bool ) ; notify ( ) ; }	stops the activity manager thread.
public void run test ( ) throws throwable { document doc ; node list element list ; node name node ; character data child ; string child data ; int child length ; java . util . list result = new java . util . array list ( ) ; doc = ( document ) load ( str , bool ) ; element list = doc . get elements by tag name ( str ) ; name node = element list . item ( num ) ; child = ( character data ) name node . get first child ( ) ; child . delete data ( num , num ) ; child data = child . get data ( ) ; assert equals ( str , str , child data ) ; child length = ( int ) child . get length ( ) ; assert equals ( str , num , child length ) ; }	runs the test case .
public rhythm group make group ( string title ) { final rhythm group group = new rhythm group ( ) ; group . m title = title ; group . m index = m rhythm groups . size ( ) ; group . m control = this ; m rhythm groups . add ( group ) ; if ( m current notification group index == notification no groups ) { m current notification group index = num ; request notification update ( ) ; } return group ; }	make a new rhythm group , registered in this rhythm control.
public void test multiply math context diff scale pos neg ( ) { string a = str ; int a scale = num ; string b = str ; int b scale = - num ; string c = str ; int c scale = - num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; math context mc = new math context ( num , rounding mode . half up ) ; big decimal result = a number . multiply ( b number , mc ) ; assert equals ( str , c , result . to string ( ) ) ; assert equals ( str , c scale , result . scale ( ) ) ; }	multiply two numbers of different scales using mathcontext.
public void write to ( final output stream out ) throws io { for ( final block block : blocks ) { out . write ( block . data , num , block . limit ) ; } }	write the entire buffer to output stream .
public void test merge one servlet into document with same servlet and param ( ) throws exception { string src xml = str + str + str + str + str + str ; web xml src web xml = web xml io . parse web xml ( new byte array input stream ( src xml . get bytes ( str ) ) , null ) ; string merge xml = str + str + str + str + str + str + str + str + str + str ; web xml merge web xml = web xml io . parse web xml ( new byte array input stream ( merge xml . get bytes ( str ) ) , null ) ; web xml merger merger = new web xml merger ( src web xml ) ; merger . merge ( merge web xml ) ; assert true ( web xml utils . has servlet ( src web xml , str ) ) ; list < string > init params = web xml utils . get servlet init param names ( src web xml , str ) ; assert equals ( num , init params . size ( ) ) ; assert equals ( str , init params . get ( num ) ) ; assert equals ( str , web xml utils . get servlet init param ( src web xml , str , str ) ) ; }	tets whether a servlet with an initialization parameter is correctly merged into a descriptor that contains the definition of a servlet with the same name .
public kmp ( string pat ) { this . r = num ; this . pat = pat ; int m = pat . length ( ) ; dfa = new int [ r ] [ m ] ; dfa [ pat . char at ( num ) ] [ num ] = num ; for ( int x = num , j = num ; j < m ; j ++ ) { for ( int c = num ; c < r ; c ++ ) dfa [ c ] [ j ] = dfa [ c ] [ x ] ; dfa [ pat . char at ( j ) ] [ j ] = j + num ; x = dfa [ pat . char at ( j ) ] [ x ] ; } }	preprocesses the pattern string .
private void load configuration ( ) { m client id = m configuration manager . get string ( pref client id , str ) ; m client key = m configuration manager . get string ( pref client key , str ) ; timber . i ( str ) ; }	load the configuration of the component .
public static void put boolean field ( object obj , long field off , boolean val ) { unsafe . put boolean ( obj , field off , val ) ; }	stores boolean value into object field .
public void sort ( comparator < file > comparator ) { synchronized ( m lock ) { collections . sort ( file list , comparator ) ; } notify data set changed ( ) ; }	sorts the content of this adapter using the specified comparator .
public accept request interceptor ( final string accept ) { this . accept = accept ; check argument ( ! accept . is empty ( ) , str ) ; }	creates request interceptor which sets the accept header .
public void test get lowest set bit neg ( ) { byte a bytes [ ] = { - num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = - num ; int i number = num ; big integer a number = new big integer ( a sign , a bytes ) ; int result = a number . get lowest set bit ( ) ; assert true ( str , result == i number ) ; }	java . math . biginteger # getlowestsetbit ( ) getlowestsetbit for negative biginteger.
private int tailing non newline ( string str , int off , int len ) { for ( int cnt = num ; cnt < len ; cnt ++ ) { final int pos = off + ( len - num ) - cnt ; if ( str . char at ( pos ) == unix newline ) { return cnt ; } if ( str . char at ( pos ) == carriage return ) { return cnt ; } } return len ; }	count the tailing non - newline characters .
@ override public void reset ( ) { clear ( ) ; bnodes = null ; bnodes total count = num ; bnodes resolved count = num ; deferred stmts = null ; reified stmts = null ; if ( queue != null ) { final future < void > ft = this . ft ; if ( ft != null ) { ft . cancel ( bool ) ; this . ft = null ; } queue . clear ( ) ; } }	clears all buffered data , including the canonicalizing mapping for blank nodes and deferred provenance statements .
public static byte [ ] read data ( final input stream input ) throws io { final byte [ ] input buffer = new byte [ buffer length ] ; final byte array output stream byte output = new byte array output stream ( buffer length ) ; int bytes read ; while ( ( bytes read = input . read ( input buffer ) ) != - num ) { byte output . write ( input buffer , num , bytes read ) ; } final byte [ ] r = byte output . to byte array ( ) ; byte output . close ( ) ; return r ; }	reads all the data from the supplied inputstream into a byte array .
@ override public synchronized void println ( ) { print ( str ) ; }	prints a new line.
public boolean is crash ( string test path ) { for ( string prefix : get prefixes ( test path ) ) { if ( m crash list . contains ( prefix ) ) { return bool ; } } return bool ; }	checks if test is expected to crash.
public abstract site map parse site map ( string content type , byte [ ] content , url url ) throws unknown format exception , io { media type media type = media type . parse ( content type ) ; while ( media type != null && ! media type . equals ( media type . octet stream ) ) { if ( xml media types . contains ( media type ) ) { return process xml ( url , content ) ; } else if ( text media types . contains ( media type ) ) { return process text ( url . to string ( ) , content ) ; } else if ( gz media types . contains ( media type ) ) { return process gzip ( url , content ) ; } else { media type = media type registry . get supertype ( media type ) ; return parse site map ( media type . to string ( ) , content , url ) ; } } throw new unknown format exception ( str + content type + str + url + str ) ; }	parse a sitemap , given the mime type , the content bytes , and the url.
private void create default managed object ( managed object definition < ? , ? > d , managed object < ? > child , default managed object < ? , ? > dmo ) { for ( property definition < ? > pd : d . get all property definitions ( ) ) { set property values ( child , pd , dmo ) ; } try { child . commit ( ) ; } catch ( managed object already exists exception e ) { moaee = e ; } catch ( missing mandatory properties exception e ) { mmpe = e ; } catch ( concurrent modification exception e ) { cme = e ; } catch ( operation rejected exception e ) { ore = e ; } catch ( ldap exception e ) { ere = e ; } }	create the child managed object .
static string omit quotes if exist ( string str ) { if ( str == null ) { return null ; } if ( ( ( str . char at ( num ) == str ) || ( str . char at ( num ) == str ) ) && ( str . length ( ) >= num ) ) { str = str . substring ( num , str . length ( ) - num ) ; } return str ; }	omits quotes of all kinds if they exist in the string.
static void make72 safe ( string buffer line ) { int length = line . length ( ) ; if ( length > num ) { int index = num ; while ( index < length - num ) { line . insert ( index , str ) ; index += num ; length += num ; } } return ; }	adds line breaks to enforce a maximum 72 bytes per line .
@ override public int last ( ) { character iterator t = get text ( ) ; t . set index ( t . get end index ( ) ) ; return t . get index ( ) ; }	sets the current iteration position to the end of the text.
public static void register protocol ( final string id , final protocol protocol ) { if ( id == null ) { throw new illegal argument exception ( str ) ; } if ( protocol == null ) { throw new illegal argument exception ( str ) ; } protocols . put ( id , protocol ) ; }	registers a new protocol with the given identifier.
public static int hash ( string key , int bit size , string input , string hash type ) { int bit limited hash ; try { message digest md = message digest . get instance ( hash type ) ; byte [ ] array = md . digest ( input . get bytes ( ) ) ; int hash int = from byte array ( array ) ; bit limited hash = hash int ; if ( bit size < num ) { bit limited hash = ( num > > > ( num - bit size ) ) & hash int ; } logger . debug ( str + hash int + str + bit limited hash ) ; } catch ( no such algorithm exception e ) { logger . info ( e . to string ( ) ) ; bit limited hash = hash ( key , bit size , input ) ; } return bit limited hash ; }	hash method to optionally specify a hash type other than the default java hashcode ( ) hashtype must be md5 , sha - 1 , or sha - 256.
private of compute initial factory ( set < of > of versions ) { if ( of versions == null || of versions . is empty ( ) ) { throw new illegal state exception ( str ) ; } of highest = null ; for ( of v : of versions ) { if ( highest == null ) { highest = v ; } else if ( v . compare to ( highest ) > num ) { highest = v ; } } return of . get factory ( highest ) ; }	find the max version supplied in the supported versions list and use it as the default , which will subsequently be used in our hello message header ' s version field.
public byte [ ] encode frame ( ) { int length = this . payload . length + frame length overhead ; if ( this . payload . length > num ) { length += num ; } else if ( this . payload . length >= num ) { length += num ; } byte buffer buffer = byte buffer . allocate ( length ) ; append fin and op code ( buffer , this . opcode , this . fin ) ; byte mask [ ] = generate masking key ( ) ; append length and mask ( buffer , this . payload . length , mask ) ; for ( int i = num ; i < this . payload . length ; i ++ ) { buffer . put ( ( byte ) ( this . payload [ i ] ^= mask [ i % num ] ) ) ; } buffer . flip ( ) ; return buffer . array ( ) ; }	encodes the this websocketframe into a byte array .
public static void preload icon ( context context , component name component name , bitmap icon , int dpi ) { try { package manager package manager = context . get package manager ( ) ; package manager . get activity icon ( component name ) ; return ; } catch ( package manager . name not found exception e ) { } final string key = component name . flatten to string ( ) ; file output stream resource file = null ; try { resource file = context . open file output ( get resource filename ( component name ) , context . mode private ) ; byte array output stream os = new byte array output stream ( ) ; if ( icon . compress ( android . graphics . bitmap . compress format . png , num , os ) ) { byte [ ] buffer = os . to byte array ( ) ; resource file . write ( buffer , num , buffer . length ) ; } else { log . w ( tag , str + key ) ; return ; } } catch ( file not found exception e ) { log . w ( tag , str + key , e ) ; } catch ( io e ) { log . w ( tag , str + key , e ) ; } finally { if ( resource file != null ) { try { resource file . close ( ) ; } catch ( io e ) { log . d ( tag , str + key , e ) ; } } } }	pre - load an icon into the persistent cache.
public void normalize ( ) { string builder sb = new string builder ( ) ; for ( string v : values ) { sb . append ( v ) ; } values . clear ( ) ; values . add ( sb . to string ( ) ) ; compacted = bool ; }	this method convert the list of values again into a only one value.
public void add attribute ( string key , string value ) { extra session attributes . put ( key , value ) ; }	adds attribute to the session .
string capitalise ( final string s ) { if ( s . length ( ) == num ) { return s ; } final string buffer s1 = new string buffer ( s ) ; if ( character . is lower case ( s1 . char at ( num ) ) ) { s1 . set char at ( num , character . to upper case ( s1 . char at ( num ) ) ) ; } for ( int j = num ; j < s1 . length ( ) ; j ++ ) { if ( character . is upper case ( s1 . char at ( j ) ) ) { s1 . set char at ( j , character . to lower case ( s1 . char at ( j ) ) ) ; } } return s1 . to string ( ) ; }	capitalizes the first letter and lower - cases every consecutive letter.
private geometry union actual ( geometry g0 , geometry g1 ) { return restrict to polygons ( g0 . union ( g1 ) ) ; }	encapsulates the actual unioning of two polygonal geometries .
public boolean supports ( @ magic constant ( flags from class = features . class ) int capability ) { i target = get target ( ) ; if ( target != null ) { return render service . supports capability ( get module ( ) , target , capability ) ; } return bool ; }	returns true if this configuration supports the given rendering capability.
@ override public void transaction aborted ( ) { if ( listeners . is empty ( ) ) { records . reset ( ) ; } else { records . flush ( ) ; listeners . for each ( null ) ; } }	notification of transaction aborted .
public standard crosshair label generator ( ) { this ( str , number format . get number instance ( ) ) ; }	creates a new instance with default attributes .
private uri create ethernet storage port ( map < string , object > key map , storage port port , string name , string port instance id , list < storage port > new ports , list < storage port > existing ports ) throws io { storage port portin memory = ( storage port ) key map . get ( port instance id ) ; if ( null == port ) { portin memory . set port network id ( name ) ; portin memory . set port end point id ( name ) ; string port native guid = guid . generate native guid ( db client , portin memory ) ; portin memory . set native guid ( port native guid ) ; portin memory . set label ( port native guid ) ; db client . create object ( portin memory ) ; new ports . add ( portin memory ) ; return portin memory . get id ( ) ; } else { port . set port name ( portin memory . get port name ( ) ) ; port . set port speed ( portin memory . get port speed ( ) ) ; port . set port end point id ( name ) ; port . set compatibility status ( portin memory . get compatibility status ( ) ) ; port . set discovery status ( portin memory . get discovery status ( ) ) ; port . set operational status ( portin memory . get operational status ( ) ) ; port . set port type ( portin memory . get port type ( ) ) ; db client . persist object ( port ) ; existing ports . add ( port ) ; return port . get id ( ) ; } }	create ethernet storage port.
default int add ( item stack ) { int items left = stack . count ( ) ; for ( int i = num ; i < size ( ) ; i ++ ) { items left = add ( i , stack . with amount ( items left ) ) ; } if ( items left != stack . count ( ) ) { mark changed ( ) ; } return items left ; }	adds items to this inventory.
public void mark ( long n ) { count . add and get ( n ) ; m1 rate . update ( n ) ; m5 rate . update ( n ) ; m15 rate . update ( n ) ; }	mark the occurrence of a given number of events .
public string [ ] read all lines ( ) { array list < string > lines = new array list < string > ( ) ; while ( has next line ( ) ) { lines . add ( read line ( ) ) ; } return lines . to array ( new string [ num ] ) ; }	reads all remaining lines from this input stream and returns them as an array of strings .
protected qualified item [ ] parse qualified items ( final version spec default version , final boolean allow version range , final int start index ) { return parse qualified items ( get free arguments ( ) , default version , allow version range , start index ) ; }	parses qualified items ( item specs with optional versions , version ranges , or deletion specifiers ) from the free arguments .
public void change change enabled ( change enabled state state ) throws refactoring exception { refactoring session session = get refactoring session ( state . get session id ( ) ) ; session . update change enabled ( state . get change id ( ) , state . is enabled ( ) ) ; }	include / exclude refactoring change from refactoring.
public update builder bind uris ( string from , collection < string > uris ) { return bind uris ( from , uris , str ) ; }	bind some uris to a string .
public void populate all ( ) throws general exception { for ( service eca action eca action : service eca rule . get eca action list ( ) ) { services called by this service eca . add ( aif . get service artifact info ( eca action . get service name ( ) ) ) ; util misc . add to sorted set in map ( this , aif . all service eca infos referring to service name , eca action . get service name ( ) ) ; } }	this must be called after creation from the artifactinfofactory after this class has been put into the global map in order to avoid recursive initialization.
public void validation states removed ( k key ) { hide message ( key ) ; validation error states . remove ( key ) ; notify upstream ( key , collections . < validation state > empty set ( ) ) ; }	removes all validation states for the given key .
public void kill application ( string application id ) throws io , yarn exception { log . info ( str + application id ) ; yarn client . kill application ( get application id ( application id ) ) ; }	this function kills an application given the applicationid.
public static string convert ( string prefix ) { string builder sb = new string builder ( ) ; prefix = prefix . replace ( str , str ) ; string [ ] lines = prefix . split ( str ) ; for ( string line : lines ) { list < string > tokens = new array list < string > ( ) ; char [ ] c = unsafe string . get chars ( line ) ; int lastidx = num ; int idx = num ; while ( idx < c . length ) { while ( c [ idx ] != str && c [ idx ] != str && c [ idx ] != str ) { idx ++ ; } if ( idx != lastidx ) { tokens . add ( new string ( c , lastidx , idx - lastidx ) ) ; } idx ++ ; lastidx = idx ; } collections . reverse ( tokens ) ; for ( string token : tokens ) { sb . append ( token ) ; sb . append ( str ) ; } } return sb . to string ( ) ; }	converts prefix to postfix , considering the arguments of the prefix notation are in the order they will be popped out of the stack.
public boolean to boolean ( element el , string attribute name , boolean default value ) { string value = el . get attribute ( attribute name ) ; if ( value == null ) return default value ; return caster . to boolean value ( value , bool ) ; }	reads a xml element attribute ans cast it to a boolean value.
protected void serialize pre root ( ) throws io { int i ; if ( pre root != null ) { for ( i = num ; i < pre root . size ( ) ; ++ i ) { print text ( ( string ) pre root . element at ( i ) , bool , bool ) ; if ( indenting ) printer . break line ( ) ; } pre root . remove all elements ( ) ; } }	comments and pis cannot be serialized before the root element , because the root element serializes the document type , which generally comes first.
private void create schema column entities ( list < schema column > schema columns , boolean is partition list , collection < schema column entity > schema column entity list , map < string , schema column entity > schema column entity map , business object format entity business object format entity ) { if ( ! collection utils . is empty ( schema columns ) ) { int position = num ; for ( schema column schema column : schema columns ) { schema column entity schema column entity = schema column entity map . get ( schema column . get name ( ) ) ; if ( schema column entity == null ) { schema column entity = create schema column entity ( schema column , business object format entity ) ; schema column entity list . add ( schema column entity ) ; schema column entity map . put ( schema column . get name ( ) , schema column entity ) ; } if ( is partition list ) { schema column entity . set partition level ( position ++ ) ; } else { schema column entity . set position ( position ++ ) ; } } } }	creates the schema column entities .
public static < t > string join and ( final string delimiter , final string last delimiter , final collection < t > objs ) { if ( objs == null || objs . is empty ( ) ) return str ; final iterator < t > iter = objs . iterator ( ) ; final string builder buffer = new string builder ( ) ; while ( iter . has next ( ) ) { final t obj = iter . next ( ) ; if ( not empty ( obj ) ) { if ( buffer . length ( ) != num ) { buffer . append ( iter . has next ( ) ? delimiter : last delimiter ) ; } buffer . append ( strings . to string ( obj ) ) ; } } return buffer . to string ( ) ; }	like join , but allows for a distinct final delimiter.
public static string generate native guid ( db client db client , snapshot snapshot ) throws io { file share fs = db client . query object ( file share . class , snapshot . get parent ( ) ) ; storage system device = db client . query object ( storage system . class , fs . get storage device ( ) ) ; return string . format ( str + snapshot + str , device type map . get ( device . get system type ( ) ) , device . get serial number ( ) , snapshot . get native id ( ) ) ; }	generates the format storagesystem + serialnumber + snapshot + nativeid native guid for snapshot objects.
public static map < string , object > update file ( dispatch context dctx , map < string , ? extends object > context ) { map < string , object > result = null ; try { result = update file method ( dctx , context ) ; } catch ( generic service exception e ) { return service util . return error ( e . get message ( ) ) ; } return result ; }	a service wrapper for the updatefilemethod method.
public edit sensors dialog ( final collection < sensor > sensors ) { super ( ) ; if ( sensors == null ) { throw new illegal argument exception ( str ) ; } this . sensors = sensors ; set title ( str + sensors . size ( ) + str ) ; init components ( ) ; layout components ( ) ; }	create a new edit sensor dialog .
public string read to delimiter ( char delim ) throws format exception { string buffer buildretval = new string buffer ( ) ; char tmp ; try { while ( ( tmp = read char ( ) ) != delim ) buildretval . append ( tmp ) ; } catch ( eof e ) { } catch ( format exception fe ) { if ( buildretval . length ( ) == num ) { throw fe ; } } return buildretval . to string ( ) ; }	reads a string until the specified delimiter or eof is encountered.
default t call ( source section source , t lhs , t argument1 , t argument2 ) { return call ( source , lhs , arrays . as list ( argument ( argument1 ) , argument ( argument2 ) ) ) ; }	helper function : create a call with two unnamed arguments .
public void save lock password ( string password , int quality , boolean is fallback ) { final byte [ ] hash = password to hash ( password ) ; try { random access file raf = new random access file ( s lock password filename , str ) ; try { if ( password == null ) { raf . set length ( num ) ; } else { raf . write ( hash , num , hash . length ) ; } } finally { if ( raf != null ) raf . close ( ) ; } } catch ( file not found exception fnfe ) { log util . e ( tag , str + s lock password filename ) ; } catch ( io ioe ) { log util . e ( tag , str + s lock password filename ) ; } }	save a lock password.
public boolean check username exists ( string username ) throws data access exception { return get user info ( username ) != null ; }	checks to see if the username already exist in the user table.
public code39 reader ( ) { using check digit = bool ; extended mode = bool ; }	creates a reader that assumes all encoded data is data , and does not treat the final character as a check digit.
public static string encode ( final list < position > path , int precision ) { long last lat = num ; long last lng = num ; final string buffer result = new string buffer ( ) ; double factor = math . pow ( num , precision ) ; for ( final position point : path ) { long lat = math . round ( point . get latitude ( ) * factor ) ; long lng = math . round ( point . get longitude ( ) * factor ) ; long d lat = lat - last lat ; long d lng = lng - last lng ; encode ( d lat , result ) ; encode ( d lng , result ) ; last lat = lat ; last lng = lng ; } return result . to string ( ) ; }	encodes a sequence of positions into an encoded path string .
@ override public int compare to ( lib package p other ) { return pkg name . compare to ignore case ( p other . pkg name ) ; }	compares 2 packages by name.
public void write exif ( bitmap bmap , string exif out file name ) throws file not found exception , io { if ( bmap == null || exif out file name == null ) { throw new illegal argument exception ( null argument string ) ; } output stream s = null ; try { s = get exif writer stream ( exif out file name ) ; bmap . compress ( bitmap . compress format . jpeg , num , s ) ; s . flush ( ) ; } catch ( io e ) { close silently ( s ) ; throw e ; } s . close ( ) ; }	writes the tags from this exifinterface object into a jpeg compressed bitmap , removing prior exif tags .
public double entropy ( int [ ] x ) { double h = num ; int n = x . length ; double ln2 = math . log ( num ) ; int n0 = num ; for ( int i = num ; i < n ; i ++ ) { if ( x [ i ] == num ) { n0 ++ ; } } double p ; if ( n0 == num || n0 == n ) { return h ; } else { p = ( double ) n0 / ( double ) n ; h = - ( p * math . log ( p ) + ( num - p ) * math . log ( num - p ) ) / ln2 ; } return h ; }	this method computes the entropy of a binary signal stored in an int array.
private string [ ] addto selection args ( final string arg value , final string [ ] selection args in ) { string [ ] selection args = selection args in ; list < string > selection args list = new array list < > ( ) ; selection args list . add ( arg value ) ; if ( null != selection args in ) { for ( final string arg : selection args in ) { selection args list . add ( arg ) ; } } selection args = selection args list . to array ( new string [ num ] ) ; selection args list . clear ( ) ; selection args list = null ; return selection args ; }	adds criteria to ( existing ) selection arguments criteria is always added as first element into ( existing ) selection arguments.
public void put ( string sample , string attribute , object value ) { if ( ! sample order . contains ( sample ) ) sample order . add ( sample ) ; if ( ! attribute order . contains ( attribute ) ) attribute order . add ( attribute ) ; table . put ( sample , attribute , value ) ; }	put a value in the table.
public boolean is compacted ( ) { return compacted ; }	method that checks if the element has been compacted .
protected void center ( ) { container parent = get parent ( ) ; final dimension size = get preferred size ( ) ; set bounds ( ( parent . get width ( ) - size . width ) / num , ( parent . get height ( ) - size . height ) / num , size . width , size . height ) ; }	center the window within the parent component .
public boolean is card dismissible ( string tag ) { return m dismissible cards . contains ( tag ) ; }	returns true if the card is shown and is dismissible .
public void write ( char cbuf [ ] , int off , int len ) throws io { se . write ( cbuf , off , len ) ; }	writes a portion of an array of characters .
public boolean validate ( string telephone ) { char a char ; string builder buf = new string builder ( telephone ) ; for ( int a index = num ; a index < buf . length ( ) ; a index ++ ) { a char = buf . char at ( a index ) ; if ( ! character . is space char ( a char ) ) { if ( ! character . is digit ( a char ) && ! is valid telephone chars ( a char ) ) { return bool ; } } } return bool ; }	determines whether the specified string is a valid " basic " telephone number string.
public static void unpack ( hash map < string , object > object , string key , object value ) { string [ ] split = key . split ( str ) ; hash map lobj = object ; for ( int cur = num ; cur < split . length ; cur ++ ) { string current = split [ cur ] ; if ( ! ( lobj . contains key ( current ) && lobj . get ( current ) instanceof hash map ) ) { lobj . put ( current , new hash map < string , object > ( ) ) ; } if ( cur == split . length - num ) { lobj . put ( current , value ) ; } else lobj = ( hash map ) lobj . get ( current ) ; } }	unpack a period delimited string and get the object at that pointer.
public void remove listener ( dns listener ) { listeners . remove ( listener ) ; }	remove a listener from all outstanding questions.
static set < string > parse resource path params ( string resource path ) { matcher matcher = param url regex . matcher ( resource path ) ; set < string > patterns = new linked hash set < > ( ) ; while ( matcher . find ( ) ) { patterns . add ( matcher . group ( num ) ) ; } return patterns ; }	gets the set of unique path parameters used in the given uri.
@ override public void close ( ) throws io { if ( logger != null ) { logger . println ( str + socket was closed ) ; } if ( ! socket was closed ) { if ( handshake started ) { alert protocol . alert ( alert protocol . warning , alert protocol . close notify ) ; try { output . write ( alert protocol . wrap ( ) ) ; } catch ( io ex ) { } alert protocol . set processed ( ) ; } shutdown ( ) ; close transport layer ( ) ; socket was closed = bool ; } }	this method works according to the specification of implemented class .
public j ( bounded range model model , int orientation , int direction ) { super . set focusable ( bool ) ; this . model = model ; this . orientation = orientation ; this . direction = direction ; set foreground ( color . light gray ) ; this . lstnr = create listener ( ) ; model . add change listener ( lstnr ) ; add mouse listener ( this ) ; add mouse motion listener ( this ) ; add key listener ( this ) ; }	create a new range slider .
public static boolean is auto new ( properties ctx ) { if ( ctx == null ) throw new illegal argument exception ( str ) ; string s = get context ( ctx , str ) ; if ( s != null && s . equals ( str ) ) return bool ; return bool ; }	is auto new record.
public boolean can read ( string path ) { try { zip entry entry = get zip entry ( path ) ; return entry != null && ! entry . is directory ( ) ; } catch ( io e ) { log . log ( level . fine , e . to string ( ) , e ) ; return bool ; } }	readable if the jar is readable and the path refers to a file .
public static long [ ] and i ( long [ ] v , long [ ] o , int off ) { if ( off == num ) { return and i ( v , o ) ; } if ( off < num ) { throw new unsupported operation exception ( str ) ; } final int shift words = off > > > long lo size ; final int shift bits = off & long lo mask ; if ( shift words >= v . length ) { return v ; } if ( shift bits == num ) { final int end = math . min ( v . length , o . length + shift words ) ; for ( int i = shift words ; i < end ; i ++ ) { v [ i ] &= o [ i - shift words ] ; } arrays . fill ( v , num , shift words , num ) ; return v ; } final int unshift bits = long . size - shift bits ; final int end = math . min ( v . length , o . length + shift words ) - num ; arrays . fill ( v , end + num , v . length , num ) ; for ( int i = end ; i > shift words ; i -- ) { final int src = i - shift words ; v [ i ] &= ( o [ src ] << shift bits ) | ( o [ src - num ] > > > unshift bits ) ; } v [ shift words ] &= o [ num ] << shift bits ; arrays . fill ( v , num , shift words , num ) ; return v ; }	and o onto v inplace , i.
public boolean equals ( object p test ) { if ( p test instanceof uri ) { uri test uri = ( uri ) p test ; if ( ( ( m scheme == null && test uri . m scheme == null ) || ( m scheme != null && test uri . m scheme != null && m scheme . equals ( test uri . m scheme ) ) ) && ( ( m userinfo == null && test uri . m userinfo == null ) || ( m userinfo != null && test uri . m userinfo != null && m userinfo . equals ( test uri . m userinfo ) ) ) && ( ( m host == null && test uri . m host == null ) || ( m host != null && test uri . m host != null && m host . equals ( test uri . m host ) ) ) && m port == test uri . m port && ( ( m path == null && test uri . m path == null ) || ( m path != null && test uri . m path != null && m path . equals ( test uri . m path ) ) ) && ( ( m query string == null && test uri . m query string == null ) || ( m query string != null && test uri . m query string != null && m query string . equals ( test uri . m query string ) ) ) && ( ( m fragment == null && test uri . m fragment == null ) || ( m fragment != null && test uri . m fragment != null && m fragment . equals ( test uri . m fragment ) ) ) ) { return bool ; } } return bool ; }	determines if the passed - in object is equivalent to this uri .
public void test case5 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; int a sign = num ; int b sign = - num ; byte r bytes [ ] = { - num , - num , - num , num , - num , - num , - num , - num , num , - num , - num , - num , num , - num , num , num , num , - num , - num , num , num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . multiply ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , result . signum ( ) ) ; }	multiply two numbers of different length and different signs.
public isaac ( ) { set seed ( system . current time millis ( ) + system . identity hash code ( this ) ) ; }	creates a new isaac random number generator.
public static boolean is m ( final string string ) { preconditions . check not null ( string , str ) ; return ( string . length ( ) == num ) && is hex string ( string ) ; }	tests whether a given string is a valid md5 string .
public synchronized void wait for submitted tasks ( ) throws interrupted exception { while ( current task count . get ( ) > num ) { wait for single task ( ) ; } }	waits for all tasks that have been previously submitted to the pool to finish .
private int scan token ( int start pos ) { int position = start pos ; while ( position < max position ) { if ( ! has surrogates ) { char c = str . char at ( position ) ; if ( ( c <= max delim code point ) && ( delimiters . index of ( c ) >= num ) ) break ; position ++ ; } else { int c = str . code point at ( position ) ; if ( ( c <= max delim code point ) && is delimiter ( c ) ) break ; position += character . char count ( c ) ; } } if ( ret delims && ( start pos == position ) ) { if ( ! has surrogates ) { char c = str . char at ( position ) ; if ( ( c <= max delim code point ) && ( delimiters . index of ( c ) >= num ) ) position ++ ; } else { int c = str . code point at ( position ) ; if ( ( c <= max delim code point ) && is delimiter ( c ) ) position += character . char count ( c ) ; } } return position ; }	skips ahead from startpos and returns the index of the next delimiter character encountered , or maxposition if no such delimiter is found .
public void zoom at ( double x , double y , double z , double zoom value ) { double [ ] diff = { target xoff - x , target yoff - y , z - target zoff } ; double length = math . sqrt ( diff [ num ] * diff [ num ] + diff [ num ] * diff [ num ] + diff [ num ] * diff [ num ] ) ; if ( length == num ) { length = num ; } double [ ] normalized = { diff [ num ] / length , diff [ num ] / length , diff [ num ] / length } ; double percent = zoom value / normalized [ num ] ; move to position ( - ( float ) ( target xoff + normalized [ num ] * percent ) , - ( float ) ( target yoff + normalized [ num ] * percent ) ) ; zoom to camera ( ( float ) ( target zoff + normalized [ num ] * percent ) ) ; }	move the eye in straight line toward the given world position , reducing ( or augmenting ) the distance between eye and point of zoomvalue .
private static int string to hash ( string s ) { int len = s . length ( ) ; int hash2 = num ; int hash = len ; hash <<= num ; hash += s . char at ( num ) - num ; int j = len ; for ( int i = num ; i < num && j > num ; i ++ ) { j -- ; hash <<= num ; hash += s . char at ( j ) - num ; hash2 <<= num ; hash2 += s . char at ( i ) - num ; } return hash ^ hash2 ; }	this method has to return a unique integer for each well - known lower - cased attribute name .
public void register dense features ( array list < feature function > feature functions ) { for ( feature function feature : feature functions ) { array list < string > names = feature . report dense features ( dense features . size ( ) ) ; for ( string name : names ) { dense feature names . add ( name ) ; dense features . add ( get sparse ( name ) ) ; sparse features . remove ( name ) ; } } }	register one or more dense features with the global weight vector.
private void add flag ( final list < string > args , final string arg name , final boolean value ) { if ( value ) { args . add ( arg name ) ; } }	adds flag to arguments when value is true .
public static private key load ( input stream is ) throws io , crypto exception { byte [ ] pvk = read util . read fully ( is ) ; byte buffer bb = byte buffer . wrap ( pvk ) ; bb . order ( byte order . little endian ) ; long key type = read reserved magic key type ( bb ) ; long encrypted = unsigned util . get int ( bb ) ; if ( encrypted != pvk unencrypted ) { throw new private key encrypted exception ( message format . format ( res . get string ( str ) , long . to hex string ( encrypted ) , long . to hex string ( pvk unencrypted ) ) ) ; } long salt length = unsigned util . get int ( bb ) ; if ( salt length != unencrypted salt length ) { throw new crypto exception ( message format . format ( res . get string ( str ) , long . to hex string ( salt length ) , long . to hex string ( unencrypted salt length ) ) ) ; } long key length = unsigned util . get int ( bb ) ; read private key blob header ( bb , key type ) ; byte [ ] private key blob = new byte [ bb . remaining ( ) ] ; bb . get ( private key blob ) ; if ( key length != ( private key blob . length + blob header length ) ) { throw new crypto exception ( message format . format ( res . get string ( str ) , long . to hex string ( key length ) , long . to hex string ( private key blob . length + blob header length ) ) ) ; } return blob to private key ( private key blob ) ; }	load an unencrypted pvk private key from the stream .
public static byte [ ] key gen private ( byte [ ] random bytes ) throws no such algorithm exception , digest exception { if ( random bytes . length < num ) { throw new runtime exception ( str ) ; } message digest digest = message digest . get instance ( str ) ; digest . digest ( random bytes , num , random bytes . length ) ; byte [ ] private key = digest . digest ( ) ; private key [ num ] &= num ; private key [ num ] &= num ; private key [ num ] |= num ; return private key ; }	generating private key . source : https : / / cr . yp . to / ecdh . html.
private boolean is checkpoint table exists ( connection conn ) { statement st = null ; result set rs = null ; try { st = conn . create statement ( ) ; rs = st . execute query ( chk tbl exists sql ) ; return bool ; } catch ( sql ignored ) { return bool ; } finally { u . close ( rs , log ) ; u . close ( st , log ) ; } }	this method accomplishes rdbms - independent table exists check .
public function table model ( ) { column list . add ( localisation . get string ( function table model . class , str ) ) ; column list . add ( localisation . get string ( function table model . class , str ) ) ; column list . add ( localisation . get string ( function table model . class , str ) ) ; column list . add ( localisation . get string ( function table model . class , str ) ) ; }	instantiates a new function table model .
private new cookie create ws cookie ( string cookie name , string token , boolean set max age , string user agent ) { string ie expires = str ; int max age = set max age ? token manager . get max token life time in secs ( ) : new cookie . default max age ; if ( set max age && string utils . contains ( user agent , str ) ) { ie expires = str + get expired time gmt ( max age ) ; log . debug ( str + ie expires ) ; } if ( token != null && ! token . is empty ( ) ) { return new new cookie ( cookie name , token + str + ie expires , null , null , null , max age , bool ) ; } return null ; }	create and return a cookie object with the token.
protected void init view ( ) { p . set fake bold text ( bool ) ; p . set anti alias ( bool ) ; p . set text size ( mini day number text size ) ; p . set style ( style . fill ) ; m month num paint = new paint ( ) ; m month num paint . set fake bold text ( bool ) ; m month num paint . set anti alias ( bool ) ; m month num paint . set text size ( mini day number text size ) ; m month num paint . set color ( m focus month color ) ; m month num paint . set style ( style . fill ) ; m month num paint . set text align ( align . center ) ; }	sets up the text and style properties for painting.
scheduled future task ( runnable r , v result , long ns , long period ) { super ( r , result ) ; this . time = ns ; this . period = period ; this . sequence number = sequencer . get and increment ( ) ; }	creates a periodic action with given nano time and period .
public boolean verify ( x509 certificate cert , provider sig provider ) throws no such algorithm exception , certificate expired exception , certificate not yet valid exception , cms { time signing time = get signing time ( ) ; if ( signing time != null ) { cert . check validity ( signing time . get date ( ) ) ; } return do verify ( cert . get public key ( ) , sig provider ) ; }	verify that the given certificate successfully handles and confirms the signature associated with this signer and , if a signingtime attribute is available , that the certificate was valid at the time the signature was generated .
public geo mark analyse ( final string text , final string [ ] tags , final int maxlength , final string salt ) { geo location loc = geocode ( text , tags , maxlength ) ; if ( loc != null ) return new geo mark ( loc , salt ) ; return reverse geocode ( text ) ; }	analyse a text for the presence of a location name.
public void test ( ) throws sql { string select query = str + database creator . orders table + str ; result set result = statement . execute query ( select query ) ; array list < integer > values = new array list < integer > ( ) ; values . add ( integer . value of ( num ) ) ; values . add ( integer . value of ( num ) ) ; values . add ( integer . value of ( num ) ) ; values . add ( integer . value of ( num ) ) ; values . add ( integer . value of ( num ) ) ; values . add ( integer . value of ( num ) ) ; values . add ( integer . value of ( num ) ) ; values . add ( integer . value of ( num ) ) ; values . add ( integer . value of ( num ) ) ; values . add ( integer . value of ( num ) ) ; int index = num ; while ( result . next ( ) ) { integer onum = result . get int ( str ) ; assert true ( str , values . contains ( onum ) ) ; assert equals ( str , index , values . index of ( onum ) ) ; index ++ ; } result . close ( ) ; }	selectfunctionalitytest # test_selectorderby ( ) . selects records from a table using order by.
private static string format to2 digits ( string str ) { if ( str . length ( ) < num ) { str = str + str ; } return str ; }	makes values consist of 2 letters " 01 ".
protected static string quote sql ( object data , int type ) throws sql { if ( data == null ) { return str ; } switch ( type ) { case types . bit : case types . boolean : case types . integer : case types . bigint : case types . decimal : case types . double : case types . float : case types . numeric : case types . real : case types . smallint : case types . tinyint : return data . to string ( ) ; case types . date : case types . time : case types . timestamp : case types . longvarchar : case types . char : case types . varchar : return quote string ( data . to string ( ) ) ; case types . varbinary : case types . longvarbinary : case types . binary : if ( data instanceof uuid ) { return str + data . to string ( ) + str ; } return str + string utils . convert bytes to hex ( ( byte [ ] ) data ) + str ; case types . clob : case types . java object : case types . other : case types . blob : case types . struct : case types . ref : case types . null : case types . array : case types . datalink : case types . distinct : throw throw exception ( str + type ) ; default : return str ; } }	internal . convert an object to a string as used in a sql statement .
public static int calculate digit count ( long value ) { if ( value < num ) { if ( value != long . min value ) { return calculate digit count ( - value ) + num ; } else { return num ; } } return ( value < num ? num : ( value < num ? num : ( value < num ? num : ( value < num ? num : ( ( int ) ( math . log ( value ) / log 10 ) + num ) ) ) ) ) ; }	calculates the number of decimal digits for the given value , including the sign .
public string byte string no semicolon ( ) { string builder retval = new string builder ( ) ; try { while ( bool ) { char next = look ahead ( num ) ; if ( next == str || next == str || next == str || next == str ) { break ; } else { consume ( num ) ; retval . append ( next ) ; } } } catch ( parse exception ex ) { return retval . to string ( ) ; } return retval . to string ( ) ; }	return a substring containing no semicolons .
public void test neg neg first longer ( ) { byte a bytes [ ] = { - num , num , num , num , - num , - num , num , num , num , num , - num , num , num , - num , num , num , - num , - num } ; byte b bytes [ ] = { - num , - num , - num , - num , num , num , num , num , num , num , num , num , num , num } ; int a sign = - num ; int b sign = - num ; byte r bytes [ ] = { - num , num , num , - num , - num , - num , - num , - num , - num , - num , - num , - num , - num , - num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . or ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , result . signum ( ) ) ; }	or for two negative numbers ; the first is longer.
public static void println ( double x ) { out . println ( x ) ; }	prints a double to standard output and then terminates the line .
public boolean subscribe topic ( @ non null context context , @ non null string [ ] new topics ) { if ( ! initialized ) init ( context ) ; if ( new topics . length == num ) return bool ; if ( null == topics ) { topics = new array list < > ( ) ; } for ( string topic : new topics ) { if ( topics . contains ( topic ) ) { return bool ; } topics . add ( topic ) ; } save subscibed topics ( context ) ; intent intent = new intent ( context , registration intent service . class ) ; intent . set action ( registration intent service . action subscribe ) ; intent . put extra ( registration intent service . extra topic list , new topics ) ; context . start service ( intent ) ; return bool ; }	subscribe to a list of topics .
public static string serialise ( node node ) { try { dom registry = dom . new instance ( ) ; dom ls ls impl = ( dom ls ) registry . get dom ( str ) ; ls serializer = ls impl . create ls ( ) ; return serializer . write to string ( node ) ; } catch ( exception e ) { log . fine ( str + e ) ; return str ; } }	serialises the xml node into a string .
public static boolean is on segment ( geo a , geo b , geo i ) { return ( ( a . distance ( i ) < a . distance ( b ) ) && ( b . distance ( i ) < b . distance ( a ) ) ) ; }	point i is on the great circle defined by the points a and b.
public void add extension point ( extension point extension point ) { f extension points . add ( extension point ) ; }	adds a extension point .
private list add node to list ( int start index for node , int end index for node ) { list localvm list = new array list ( ) ; for ( int i = start index for node ; i < end index for node ; i ++ ) { localvm list . add ( vm [ i ] ) ; } return localvm list ; }	this function adds nodes to node list.
public void add meta method ( meta method method ) { if ( is initialized ( ) ) { throw new runtime exception ( str + method ) ; } final cached class declaring class = method . get declaring class ( ) ; add meta method to index ( method , meta method index . get header ( declaring class . get the class ( ) ) ) ; }	adds a metamethod to this class.
public void wait for event ( long timeout ) { thread thread = thread . current thread ( ) ; semaphore semaphore = semaphores . get ( thread ) ; if ( semaphore == null ) { semaphore = new semaphore ( num , bool ) ; semaphore . drain permits ( ) ; semaphores . put if absent ( thread , semaphore ) ; } semaphore = semaphores . get ( thread ) ; try { semaphore . try acquire ( timeout , time unit . milliseconds ) ; } catch ( interrupted exception exception ) { logger . log ( level . finer , str , exception ) ; } }	blocks the current thread until the event arrives or the timeout expires .
public string string value ( ) { object cv = assert . check non null ( const value ( ) ) ; return cv . to string ( ) ; }	the constant value of this type , converted to string.
public date parse date ( string str ) { try { return date format . parse ( str ) ; } catch ( java . text . parse exception e ) { throw new runtime exception ( e ) ; } }	parse the given string into date object .
default int hash32 ( string value ) { return hash32 ( value . get bytes ( ) ) ; }	returns a 32 - bit hash of the given string .
public name add all ( name suffix ) throws invalid name exception { return add all ( size ( ) , suffix ) ; }	adds the components of a name - - in order - - to the end of this name .
public final input stream as input stream ( ) throws unknown resource exception { return to input stream ( ) ; }	loads the resource and returns an inputstream from which to load it .
private static double euclidean norm ( double vector [ ] ) { int n = vector . length ; if ( n < num ) { return num ; } if ( n == num ) { return math . abs ( vector [ num ] ) ; } double scale = num ; double sum = num ; for ( int i = num ; i < n ; i ++ ) { if ( vector [ i ] != num ) { double abs = math . abs ( vector [ i ] ) ; if ( scale < abs ) { double t = scale / abs ; sum = num + sum * ( t * t ) ; scale = abs ; } else { double t = abs / scale ; sum += t * t ; } } } return scale * math . sqrt ( sum ) ; }	returns the euclidean norm of a vector.
public static file descriptor create socket ( ) throws io { if ( ! is supported ) throw new unsupported operation exception ( str ) ; int fd val = create0 ( ) ; file descriptor fd = new file descriptor ( ) ; fd access . set ( fd , fd val ) ; return fd ; }	creates a sdp socket , returning file descriptor referencing the socket .
private static void extract file ( zip input stream zip in , string file path ) throws io { buffered output stream bos = new buffered output stream ( new file output stream ( file path ) ) ; byte [ ] bytes in = new byte [ buffer size ] ; int read = num ; while ( ( read = zip in . read ( bytes in ) ) != - num ) { bos . write ( bytes in , num , read ) ; } bos . close ( ) ; }	extracts a zip entry ( file entry ).
public static final string square to string ( int square ) { string builder ret = new string builder ( ) ; int x = position . get x ( square ) ; int y = position . get y ( square ) ; ret . append ( ( char ) ( x + str ) ) ; ret . append ( ( char ) ( y + str ) ) ; return ret . to string ( ) ; }	convert a square number to a string , such as " e4 " .
public static boolean has valid cover ( i game , coords pos , int elevation ) { if ( ( pos == null ) || ( elevation > num ) ) { return bool ; } boolean has moved entity = bool ; for ( entity e : game . get entities vector ( pos ) ) { if ( e . is done ( ) && ! ( e instanceof infantry ) && ( e . get elevation ( ) == elevation ) ) { has moved entity = bool ; break ; } } if ( ! has moved entity ) { enumeration < entity > wrecks = game . get wrecked entities ( ) ; while ( wrecks . has more elements ( ) ) { entity e = wrecks . next element ( ) ; if ( pos . equals ( e . get position ( ) ) && ! ( e instanceof infantry ) ) { has moved entity = bool ; } } } return has moved entity ; }	determines if there is valid cover for an infantry unit to utilize the using non - infantry as cover rules ( to pg 108 ) .
public static coordinate [ ] compute tangents through point ( coordinate circle center , double radius , coordinate point ) { coordinate [ ] ret = new coordinate [ num ] ; double dx = ( point . x - circle center . x ) / num ; double dy = ( point . y - circle center . y ) / num ; double d = math . sqrt ( dx * dx + dy * dy ) ; double a = ( radius * radius ) / ( num * d ) ; double x2 = circle center . x + ( dx * a / d ) ; double y2 = circle center . y + ( dy * a / d ) ; double h = math . sqrt ( radius * radius - a * a ) ; double rx = - dy * ( h / d ) ; double ry = dx * ( h / d ) ; double xi = x2 + rx ; double yi = y2 + ry ; double xi prime = x2 - rx ; double yi prime = y2 - ry ; ret [ num ] = new coordinate ( point ) ; ret [ num ] = new coordinate ( xi , yi ) ; ret [ num ] = new coordinate ( xi prime , yi prime ) ; return ret ; }	computes both tangents of a circle running through a given point.
public void add group ( group config interface sub group ) { sub group list . add ( sub group ) ; }	adds the sub group .
public void start scanning ( final beacon service connection service connection ) { final cursor cursor = m database helper . get all regions ( ) ; while ( cursor . move to next ( ) ) { final uuid uuid = uuid . from string ( cursor . get string ( num ) ) ; final int major = cursor . get int ( num ) ; final int minor = cursor . get int ( num ) ; final int event = cursor . get int ( num ) ; service connection . start ranging beacons in region ( beacons fragment . beacon company id , uuid , major , minor , this ) ; if ( event == beacon contract . event in range || event == beacon contract . event out of range ) service connection . start monitoring for region ( beacons fragment . beacon company id , uuid , major , minor , this ) ; } }	registers for monitoring and ranging events for all regions in the database .
public void test divide round half down neg1 ( ) { string a = str ; int a scale = - num ; string b = str ; int b scale = num ; string c = str ; int res scale = - num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; big decimal result = a number . divide ( b number , res scale , big decimal . round half down ) ; assert equals ( str , c , result . to string ( ) ) ; assert equals ( str , res scale , result . scale ( ) ) ; }	divide : rounding mode is round_half_down , result is negative ; distance = 1.
public static boolean is header ( header hdr ) { return hdr . get boolean value ( zimage , bool ) ; }	check that this hdu has a valid header for this type .
public static info register create folder ( user user , integer book id , list atts , list inter , map documents , string entidad , boolean consolidacion ) throws validation exception , security exception , book exception , session exception , tec doc exception , parse exception , attributes exception { info register result = new info register ( ) ; string session id = new string ( ) ; try { session id = login . login ( user , entidad ) ; set office user register ( entidad , session id , atts ) ; book session . open book ( session id , book id , entidad ) ; integer launch dist out register = register services util . get inves conf actions ( entidad ) ; register services util . can create folder ( session id , book id , documents , user , atts , entidad , consolidacion ) ; ax sf axsf q = book session . get form format ( session id , book id , entidad ) ; field format field format = register services util . get field format ( session id , book id ) ; map translated ids = register services util . get fields with sustitute ( atts , axsf q , session id , book id , entidad ) ; ax sf new ax sf = register services util . init in or out folder ( user , axsf q ) ; new ax sf = register services util . complete folder ( translated ids , axsf q , new ax sf , user . get locale ( ) , atts , field format , consolidacion ) ; folder data session data = register . create new folder ( session id , book id , new ax sf , inter , documents , launch dist out register , user . get locale ( ) , entidad , consolidacion ) ; result = consult register . consult register info ( book id , data . get axsf new ( ) , data . get new register id ( ) , data . get scrofic ( ) , data . get user name ( ) , user . get locale ( ) ) ; } finally { book session . close book ( session id , book id ) ; security session . logout ( session id , entidad ) ; } return result ; }	metodo que crea un registro.
public void close ( ) throws io { f input stream . close ( ) ; }	close the stream . once a stream has been closed , further read ( ) , ready ( ) , mark ( ) , or reset ( ) invocations will throw an ioexception . closing a previously - closed stream , however , has no effect .
private void handle subscription error ( azure allocation context ctx , string namespace , throwable e ) { if ( e instanceof cloud exception ) { cloud exception ce = ( cloud exception ) e ; cloud error body = ce . get body ( ) ; if ( body != null ) { string code = body . get code ( ) ; if ( missing subscription code . equals ( code ) ) { register subscription ( ctx , namespace ) ; return ; } } } handle error ( ctx , e ) ; }	this method tries to detect a subscription registration error and register subscription for given namespace.
public boolean has shutdown hook ( runnable shutdown hook ) { return hooks . contains ( shutdown hook ) ; }	indicates if a shutdownhook is registered or not .
@ override public void end process sub tokens ( ) { if ( ! skey . is empty ( ) ) { map . put ( skey , sval ) ; skey = str ; sval = str ; } }	inserts subtoken key , val pair in subtoken hash . if there are multiple keys with the same value override this call and append values.
private void heapify down ( comparable < object > cur ) { final int stop = size > > > num ; int twopos = num ; while ( twopos < stop ) { int bestchild = ( twopos << num ) + num ; comparable < object > best = twoheap [ bestchild ] ; final int right = bestchild + num ; if ( right < size && best . compare to ( twoheap [ right ] ) > num ) { bestchild = right ; best = twoheap [ right ] ; } if ( cur . compare to ( best ) <= num ) { break ; } twoheap [ twopos ] = best ; twopos = bestchild ; } twoheap [ twopos ] = cur ; }	invoke heapify - down for the root object .
public void add feature ( i fv ) { idx list . add all ( ints . as list ( fv . get indices ( ) ) ) ; val list . add all ( floats . as list ( fv . get values ( ) ) ) ; }	currentvector = currentvector + fv.
private boolean is in thumb range ( float touch x , double normalized thumb value ) { return math . abs ( touch x - normalized to screen ( normalized thumb value ) ) <= thumb half width ; }	decides if given x - coordinate in screen space needs to be interpreted as " within " the normalized thumb x - coordinate .
public static byte [ ] str2 unicode byte array ( final jbbp byte order , final string str ) { final byte [ ] result = new byte [ str . length ( ) << num ] ; int index = num ; for ( int i = num ; i < str . length ( ) ; i ++ ) { final int val = str . char at ( i ) ; switch ( byte order ) { case big endian : { result [ index ++ ] = ( byte ) ( val > > num ) ; result [ index ++ ] = ( byte ) val ; } break ; case little endian : { result [ index ++ ] = ( byte ) val ; result [ index ++ ] = ( byte ) ( val > > num ) ; } break ; default : throw new error ( str + byte order + str ) ; } } return result ; }	convert chars of a string into a byte array contains the unicode codes .
private method def parse method ( str tok st ) { string method name = st . need word ( ) ; st . need ( str ) ; array list < string > args = new array list < > ( ) ; string tok = st . next token ( ) ; if ( tok != str ) { st . push back ( ) ; do { tok = st . need word ( ) ; args . add ( tok ) ; } while ( st . next token ( ) == str ) ; st . push back ( ) ; st . need ( str ) ; } type [ ] targs = new type [ args . size ( ) ] ; for ( int ii = num ; ii < args . size ( ) ; ii ++ ) { targs [ ii ] = bcel . classname to type ( args . get ( ii ) ) ; } return new method def ( method name , targs ) ; }	parse a method declaration.
private void write experieced and causing person delay ( ) { sorted map < double , map < id < person > , double > > time bin2 affected person2 delay = get experienced person delay ( num ) ; sorted map < double , map < id < person > , double > > time bin2 causing person2 delay = get causing person delay ( num ) ; if ( time bin2 affected person2 delay . size ( ) != num ) throw new runtime exception ( str ) ; map < id < person > , double > affectedperson2 delay = time bin2 affected person2 delay . get ( simulation end time ) ; map < id < person > , double > caused person2 delay = time bin2 causing person2 delay . get ( simulation end time ) ; buffered writer writer = io . get buffered writer ( run dir + str + pricing scenario + suffix for soring + str ) ; try { writer . write ( str ) ; for ( id < person > id : caused person2 delay . key set ( ) ) { writer . write ( id + str + pf . get munich user group from person id ( id ) + str + affectedperson2 delay . get ( id ) / num + str + caused person2 delay . get ( id ) / num + str ) ; } writer . close ( ) ; } catch ( exception e ) { throw new runtime exception ( str + e ) ; } }	writes < p > personid usergroup delayinhr.
static list < list < file > > partition ( final int bin count , final file ... files ) { final file [ ] sort = arrays . copy of ( files , files . length ) ; return bin them ( bin count , sort ) ; }	partition the given files into the specified bins trying to approximately balance the size of the bins according to the lengths of the files.
private void calc bite point ( int center x , int center y , float circle edge x , float circle edge y , double bite line , boolean is first bite , boolean is random bite ) { double bite percent ; if ( is first bite ) { bite x = ( int ) circle edge x ; bite y = ( int ) circle edge y ; } else { bite percent = bite radius / bite line ; if ( is random bite ) { bite percent *= bites taken map . get ( bite direction ) ; } else { bite percent *= ( num bites for one direction - num bites for one direction left ) ; } bite x = draw utils . get point between two points ( circle edge x , center x , bite percent ) ; bite y = draw utils . get point between two points ( circle edge y , center y , bite percent ) ; } }	method for calculating bite point for random & one direction options.
private boolean zz refill ( ) throws java . io . io { if ( zz start read > num ) { system . arraycopy ( zz buffer , zz start read , zz buffer , num , zz end read - zz start read ) ; zz end read -= zz start read ; zz current pos -= zz start read ; zz marked pos -= zz start read ; zz pushback pos -= zz start read ; zz start read = num ; } if ( zz current pos >= zz buffer . length ) { char new buffer [ ] = new char [ zz current pos * num ] ; system . arraycopy ( zz buffer , num , new buffer , num , zz buffer . length ) ; zz buffer = new buffer ; } int num read = zz reader . read ( zz buffer , zz end read , zz buffer . length - zz end read ) ; if ( num read < num ) { return bool ; } else { zz end read += num read ; return bool ; } }	refills the input buffer .
private void update business object definition entity descriptive information ( business object definition entity business object definition entity , business object definition descriptive information update request request ) { business object definition entity . set description ( request . get description ( ) ) ; business object definition entity . set display name ( request . get display name ( ) ) ; business object definition dao . save and refresh ( business object definition entity ) ; }	update and persist the business object definition descriptive information per specified update request .
@ override public void on download progress ( download progress info progress ) { m average speed . set text ( get string ( r . string . kilobytes per second , helpers . get speed string ( progress . m current speed ) ) ) ; m time remaining . set text ( get string ( r . string . time remaining , helpers . get time remaining ( progress . m time remaining ) ) ) ; progress . m overall total = progress . m overall total ; m pb . set max ( ( int ) ( progress . m overall total > > num ) ) ; m pb . set progress ( ( int ) ( progress . m overall progress > > num ) ) ; m progress percent . set text ( long . to string ( progress . m overall progress * num / progress . m overall total ) + str ) ; m progress fraction . set text ( helpers . get download progress string ( progress . m overall progress , progress . m overall total ) ) ; }	sets the state of the various controls based on the progressinfo object sent from the downloader service .
static public boolean is same day ( timestamp one , timestamp two ) { gregorian calendar cal one = new gregorian calendar ( ) ; if ( one != null ) cal one . set time in millis ( one . get time ( ) ) ; gregorian calendar cal two = new gregorian calendar ( ) ; if ( two != null ) cal two . set time in millis ( two . get time ( ) ) ; if ( cal one . get ( calendar . year ) == cal two . get ( calendar . year ) && cal one . get ( calendar . month ) == cal two . get ( calendar . month ) && cal one . get ( calendar . day of month ) == cal two . get ( calendar . day of month ) ) return bool ; return bool ; }	is it the same day.
public static void update all for facade ( data store data store , iterable < update > updates ) { update all for facade ( data store , updates . iterator ( ) ) ; }	creates , updates or deletes zero or more pieces of content in the data store facades .
public array field vector ( field vector < t > v1 , field vector < t > v2 ) throws null argument exception { math utils . check not null ( v1 ) ; math utils . check not null ( v2 ) ; field = v1 . get field ( ) ; final t [ ] v1 data = ( v1 instanceof array field vector ) ? ( ( array field vector < t > ) v1 ) . data : v1 . to array ( ) ; final t [ ] v2 data = ( v2 instanceof array field vector ) ? ( ( array field vector < t > ) v2 ) . data : v2 . to array ( ) ; data = math arrays . build array ( field , v1 data . length + v2 data . length ) ; system . arraycopy ( v1 data , num , data , num , v1 data . length ) ; system . arraycopy ( v2 data , num , data , v1 data . length , v2 data . length ) ; }	construct a vector by appending one vector to another vector .
public boolean equals ( object o ) { if ( o instanceof service config manager ) { service config manager oscm = ( service config manager ) o ; if ( service name . equals ( oscm . service name ) && version . equals ( oscm . version ) ) { return ( bool ) ; } } return ( bool ) ; }	compares this object with the given object .
public void add item bounds listener ( item bounds listener ibl ) { if ( m bounders == null ) m bounders = new copy on write array list ( ) ; m bounders . add ( ibl ) ; }	add an itemboundslistener to receive notifications when the bounds occupied by the visualitems in this display change .
public void increase dpi ( ) { if ( this . current dpi pos < ( this . dpi sizes . length - num ) ) { ++ this . current dpi pos ; } }	increase the image size ( dpi ) .
string vector process prefix urllist ( stylesheet handler handler , string uri , string name , string raw name , string value ) throws org . xml . sax . sax { string tokenizer tokenizer = new string tokenizer ( value , str ) ; int n strings = tokenizer . count tokens ( ) ; string vector strings = new string vector ( n strings ) ; for ( int i = num ; i < n strings ; i ++ ) { string prefix = tokenizer . next token ( ) ; string url = handler . get namespace for prefix ( prefix ) ; if ( url != null ) strings . add element ( url ) ; else throw new org . xml . sax . sax ( xsl . create message ( xslt . er cant resolve nsprefix , new object [ ] { prefix } ) ) ; } return strings ; }	process an attribute string of type t_urllist into a vector of prefixes that may be resolved to urls .
@ override public void write ( data output out ) throws io { out . write long ( duration ) ; out . write int ( get length ( ) ) ; for ( int i = num ; i < coeffs . length ; i ++ ) { out . write float ( coeffs [ i ] ) ; } }	write this datagram to a random access file or data output stream .
private void add sharing profiles ( collection < sharing profile > sharing profiles ) throws guacamole exception { for ( sharing profile sharing profile : sharing profiles ) { string primary connection identifier = sharing profile . get primary connection identifier ( ) ; api primary connection = retrieved connections . get ( primary connection identifier ) ; if ( primary connection != null ) { collection < api > children = primary connection . get sharing profiles ( ) ; if ( children == null ) { children = new array list < api > ( ) ; primary connection . set sharing profiles ( children ) ; } children . add ( new api ( sharing profile ) ) ; } else logger . debug ( str + str + str , sharing profile . get identifier ( ) , primary connection identifier ) ; } }	adds each of the provided sharing profiles to the current tree as children of their respective primary connections.
public void failover copy ( rp copy to failover to ) throws recover point exception { string bookmark name = copy to failover to . get bookmark name ( ) ; date apit time = copy to failover to . get apit time ( ) ; if ( bookmark name != null ) { logger . info ( str + bookmark name ) ; } else if ( apit time != null ) { logger . info ( str + apit time . to string ( ) ) ; } else { logger . info ( str ) ; } recover point image management utils image manager = new recover point image management utils ( ) ; image manager . enable copy image ( functional api , copy to failover to , bool ) ; }	perform a failover to the consistency group copy specified by the input request params .
private static void prepare logging system enviroment ( ) { system . set property ( str , get log folder ( ) ) ; }	initialize the logging system .
public state attribute ( byte [ ] octets ) { super ( octets ) ; state = new string ( octets , num , octets . length - num , charset . for name ( str ) ) ; }	creates a replymessageattribute from the on - the - wire octets .
private static long calc size ( long size , long skip , long limit ) { return size >= num ? math . max ( - num , math . min ( size - skip , limit ) ) : - num ; }	calculates the sliced size given the current size , number of elements skip , and the number of elements to limit .
public static collection < inet socket address > resolve addresses ( address resolver addr rslvr , iterable < string > addrs , int port ) throws ignite spi exception { assert addr rslvr != null ; collection < inet socket address > ext addrs = new hash set < > ( ) ; for ( string addr : addrs ) { inet socket address sock addr = new inet socket address ( addr , port ) ; if ( ! sock addr . is unresolved ( ) ) { collection < inet socket address > ext addrs0 = resolve address ( addr rslvr , sock addr ) ; if ( ext addrs0 != null ) ext addrs . add all ( ext addrs0 ) ; } } return ext addrs ; }	resolves all not loopback addresses and collect results .
@ override public void run ( ) { while ( ! is interrupted ( ) ) { try { key holder < k > ref = ( key holder < k > ) queue . remove ( ) ; v removed = table . remove ( ref ) ; if ( listener != null && removed != null ) listener . weak entry removed ( removed ) ; } catch ( interrupted exception e ) { interrupt ( ) ; break ; } } }	block on the queue until an entry is been cleaned by the gc.
public job definition create request create job definition create request ( string namespace cd , string job name , string job description , string activiti xml , list < parameter > parameters ) { job definition create request request = new job definition create request ( ) ; request . set namespace ( namespace cd ) ; request . set job name ( job name ) ; request . set description ( job description ) ; request . set activiti job xml ( activiti xml ) ; request . set parameters ( parameters ) ; return request ; }	creates a new job definition create request based on user specified parameters .
public tab state restore tab state ( int tab id , boolean encrypted ) { return tab state . restore tab state ( get tab state file ( tab id , encrypted ) , encrypted ) ; }	restores the tabstate with the given id .
public ftp ( ) { add list parser ( new unix list parser ( ) ) ; add list parser ( new dos ( ) ) ; add list parser ( new eplf ( ) ) ; add list parser ( new net ware list parser ( ) ) ; add list parser ( new mlsd ( ) ) ; }	builds and initializes the client .
public string add extension ( string test file name ) { return test file name + str ; }	adds any specialized extension required by the implementation .
public < t > string make string value sq ( t value ) { return value . to string ( ) ; }	scipio : makes an escaped freemarker string value without enclosing single - quotes , as intended for a regular ( non - raw ) string.
private level description to log level ( string description ) { level result = level . off ; if ( description . equals ( s logger . localize message ( str ) ) ) { result = level . off ; } else if ( description . equals ( s logger . localize message ( str ) ) ) { result = level . severe ; } else if ( description . equals ( s logger . localize message ( str ) ) ) { result = level . warning ; } else if ( description . equals ( s logger . localize message ( str ) ) ) { result = level . info ; } else if ( description . equals ( s logger . localize message ( str ) ) ) { result = level . config ; } else if ( description . equals ( s logger . localize message ( str ) ) ) { result = level . fine ; } else if ( description . equals ( s logger . localize message ( str ) ) ) { result = level . finer ; } else if ( description . equals ( s logger . localize message ( str ) ) ) { result = level . finest ; } else if ( description . equals ( s logger . localize message ( str ) ) ) { result = level . all ; } return result ; }	convert localized descriptive text to log level.
default boolean is immutable ( ) { return bool ; }	returns if this stream component will return the same stream result over time ( immutable or analytics type of data ) .
public long renew ( string entry uid , string class name , int object type , long duration , boolean from replication , boolean origin , boolean is from gateway ) throws unknown lease exception , internal space exception { try { extend lease period ( entry uid , class name , object type , duration , from replication , origin , bool , null , is from gateway ) ; } catch ( unknown lease exception unknown lease exception ) { if ( cache manager . is cache external db ( ) && object type != object types . notify null template && object type != object types . notify template ) { if ( logger . is loggable ( level . fine ) ) { logger . log ( level . fine , str , unknown lease exception ) ; } } else throw unknown lease exception ; } return duration ; }	renews a lease for an additional period of time ( specified in milliseconds ) for a registered entry in this lease manager.
public jk ( ) { }	instantiates a new jk tag mapping .
public static void in range ( final long value , final string name , final long min inclusive , final long max inclusive ) { if ( value < min inclusive || value > max inclusive ) { final string message = string . format ( str , name , min inclusive , max inclusive ) ; throw new illegal argument exception ( message ) ; } }	throws an exception if the specified long value is not in the specified inclusive range .
public static file unzip to temp folder ( file zip file ) { string zip filename = zip file . get name ( ) ; string temp folder prefix = zip filename . substring ( num , zip filename . last index of ( str ) ) ; file temp folder = create temp folder ( temp folder prefix ) ; try { pu . unzip ( zip file , temp folder ) ; return temp folder ; } catch ( exception e ) { try { file utils . delete file or directory ( temp folder ) ; } catch ( runtime exception ex ) { logger . debug ( str + temp folder , ex ) ; } throw new runtime exception ( str + zip file + str + temp folder , e ) ; } }	unzips the specified zip file to a temp folder.
public void test ascii ( ) throws exception { string str = str ; byte array input stream aa = new byte array input stream ( str . get bytes ( str ) ) ; input stream reader a = new input stream reader ( aa , str ) ; try { int x = a . read ( ) ; assert equals ( str , x ) ; char [ ] c = new char [ num ] ; x = a . read ( c , num , num ) ; assert equals ( str , a . get encoding ( ) ) ; assert equals ( num , x ) ; assert equals ( str , string . value of ( c ) ) ; } finally { a . close ( ) ; } }	checks if ascii encoding works with inputstreamreader.
public void clear ( ) { m reduced results . clear ( ) ; m current search index = num ; }	resets the cursor and clears the current results .
public static void create accessor method ( soot method container , stmt stmt ) { body container body = container . get active body ( ) ; soot . util . chain container stmts = container body . get units ( ) ; if ( ! container stmts . contains ( stmt ) ) throw new runtime exception ( ) ; if ( stmt . contains invoke expr ( ) ) { create invoke accessor ( container , stmt ) ; } else if ( stmt instanceof assign stmt ) { assign stmt as = ( assign stmt ) stmt ; field ref ref ; if ( as . get left op ( ) instanceof field ref ) { ref = ( field ref ) as . get left op ( ) ; create set accessor ( container , as , ref ) ; } else if ( as . get right op ( ) instanceof field ref ) { ref = ( field ref ) as . get right op ( ) ; create get accessor ( container , as , ref ) ; } else { throw new runtime exception ( str ) ; } } else throw new runtime exception ( str ) ; }	turns a field access or method call into a call to an accessor method . reuses existing accessors based on name mangling ( see createaccessorname ).
@ override public void display changed ( ) { update gc ( ) ; }	from the displaychangedlistener interface.
public final void push pair ( node v1 , node v2 ) { if ( null == m map ) { m map = new node [ m blocksize ] ; m map size = m blocksize ; } else { if ( ( m first free + num ) >= m map size ) { m map size += m blocksize ; node new map [ ] = new node [ m map size ] ; system . arraycopy ( m map , num , new map , num , m first free ) ; m map = new map ; } } m map [ m first free ] = v1 ; m map [ m first free + num ] = v2 ; m first free += num ; }	push a pair of nodes into the stack.
final segment < k , v > segment for ( int hash ) { return segments [ ( hash > > > segment shift ) & segment mask ] ; }	returns the segment that should be used for key with given hash.
public static string serialize ( object to serialize ) throws exception { class < ? > xstream class ; java . lang . reflect . constructor < ? > constructor ; object xstream ; class < ? > [ ] serialize args classes = new class [ num ] ; object [ ] serialize args = new object [ num ] ; java . lang . reflect . method method serialize ; string result ; xstream class = class . for name ( str ) ; constructor = xstream class . get constructor ( ) ; xstream = constructor . new instance ( ) ; serialize args classes [ num ] = object . class ; serialize args [ num ] = to serialize ; method serialize = xstream class . get method ( str , serialize args classes ) ; try { result = ( string ) method serialize . invoke ( xstream , serialize args ) ; } catch ( exception ex ) { result = null ; } return result ; }	serializes the supplied object xml.
@ override public void release ( ) { super . release ( ) ; }	release aquired resources to enable tag reusage .
public void update and test counter ( of ofm , string type ) { validate counter ( type , num ) ; counters . update write stats ( ofm ) ; counters . update write stats ( ofm ) ; counters . update read stats ( ofm ) ; counters . update read stats ( ofm ) ; validate counter ( type , num ) ; }	sends two messages of read and write for the given type and tests the counters.
public static < e > list < e > of ( ) { return collections . empty list ( ) ; }	returns the empty list .
protected void draw domain crosshair ( d g2 , d data area , plot orientation orientation , int dataset index , comparable row key , comparable column key , stroke stroke , paint paint ) { category dataset dataset = get dataset ( dataset index ) ; category axis axis = get domain axis for dataset ( dataset index ) ; category item renderer renderer = get renderer ( dataset index ) ; d line ; if ( orientation == plot orientation . vertical ) { double xx = renderer . get item middle ( row key , column key , dataset , axis , data area , rectangle edge . bottom ) ; line = new d . double ( xx , data area . get min y ( ) , xx , data area . get max y ( ) ) ; } else { double yy = renderer . get item middle ( row key , column key , dataset , axis , data area , rectangle edge . left ) ; line = new d . double ( data area . get min x ( ) , yy , data area . get max x ( ) , yy ) ; } g2 . set stroke ( stroke ) ; g2 . set paint ( paint ) ; g2 . draw ( line ) ; }	draws a domain crosshair .
@ override public table summary ( ) { table table = table . create ( str + name ( ) ) ; category column measure = category column . create ( str ) ; category column value = category column . create ( str ) ; table . add column ( measure ) ; table . add column ( value ) ; measure . add ( str ) ; value . add ( string . value of ( size ( ) ) ) ; measure . add ( str ) ; value . add ( string . value of ( count missing ( ) ) ) ; measure . add ( str ) ; value . add ( string . value of ( min ( ) ) ) ; measure . add ( str ) ; value . add ( string . value of ( max ( ) ) ) ; return table ; }	returns a table of dates and the number of observations of those dates.
public c ( final c criterium ) { super ( new border layout ( ) ) ; visibility criterium = criterium ; visibility state box . add action listener ( visibility state box listener ) ; init panel ( ) ; }	creates a new panel object .
public boolean is alter add ( ) { return columns to add . size ( ) > num ; }	true if the table has added columns .
private boolean process removed node ( final i node ) { if ( node instanceof i ) { final i cnode = ( i ) node ; try { final i target function = cnode . get parent function ( ) ; if ( m node counter . contains key ( target function ) ) { final int new counter = m node counter . get ( target function ) - num ; if ( new counter == num ) { m node counter . remove ( target function ) ; final set < c > to delete = new hash set < c > ( ) ; for ( final c reference : m cross references ) { if ( reference . get called function ( ) == target function ) { to delete . add ( reference ) ; } } m cross references . remove all ( to delete ) ; return bool ; } else { m node counter . put ( target function , new counter ) ; } } } catch ( final maybe null exception exception ) { } } return bool ; }	processes a removed node and updates the references list accordingly .
public long transfer to ( long position , long count , output stream dst ) throws io { return transfer to ( position , count , channels . new channel ( dst ) ) ; }	convenience method for writing the selected portion of this channel to the given destination stream .
public void test is lenient ( ) { date format df = date format . get instance ( ) ; calendar c = df . get calendar ( ) ; if ( df . is lenient ( ) ) { try { c . set ( calendar . day of month , num ) ; c . get ( calendar . day of month ) ; } catch ( exception e ) { fail ( str + e . to string ( ) ) ; } c . set lenient ( bool ) ; try { c . set ( calendar . day of month , num ) ; c . get ( calendar . day of month ) ; fail ( str ) ; } catch ( illegal argument exception e ) { } catch ( exception e ) { fail ( str + e . to string ( ) ) ; } } else { try { c . set ( calendar . day of month , num ) ; c . get ( calendar . day of month ) ; fail ( str ) ; } catch ( illegal argument exception e ) { } catch ( exception e ) { fail ( str + e . to string ( ) ) ; } c . set lenient ( bool ) ; try { c . set ( calendar . day of month , num ) ; c . get ( calendar . day of month ) ; } catch ( exception e ) { fail ( str + e . to string ( ) ) ; } } }	java . text . dateformat # islenient ( ) test of method java . text . dateformat # islenient ( ) .
private void write index file ( ) throws io , carbon data writer exception { index header index header = carbon metadata util . get index header ( local cardinality , thrift column schema list ) ; list < block index > block index thrift = carbon metadata util . get block index info ( block index info list ) ; string file name = store location + file . separator + carbon table path . get carbon index file name ( carbon data file attributes . get task id ( ) , carbon data file attributes . get fact time stamp ( ) ) ; carbon index file writer writer = new carbon index file writer ( ) ; writer . open thrift writer ( file name ) ; writer . write thrift ( index header ) ; for ( block index block index : block index thrift ) { writer . write thrift ( block index ) ; } writer . close ( ) ; copy carbon data file to carbon store path ( file name ) ; }	below method will be used to write the idex file.
public void nack all ( pubsub reader < t > reader ) throws io { check state ( this . reader == null , str ) ; list < string > batch yet to ack ids = new array list < > ( math . min ( not yet read ids . size ( ) , ack batch size ) ) ; for ( string ack id : not yet read ids ) { batch yet to ack ids . add ( ack id ) ; if ( batch yet to ack ids . size ( ) >= ack batch size ) { long now ms since epoch = now ( reader ) ; reader . nack batch ( now ms since epoch , batch yet to ack ids ) ; batch yet to ack ids . clear ( ) ; } } if ( ! batch yet to ack ids . is empty ( ) ) { long now ms since epoch = now ( reader ) ; reader . nack batch ( now ms since epoch , batch yet to ack ids ) ; } }	blocking nack all messages which have been read from pubsub but not passed downstream.
static public void assert equals ( string message , object expected , object actual ) { if ( expected == null && actual == null ) return ; if ( expected != null && expected . equals ( actual ) ) return ; fail not equals ( message , expected , actual ) ; }	asserts that two objects are equal.
public final void compute index ( ) { if ( index computed ) { return ; } list < long > cell list = new array list ( ) ; list < integer > edge list = new array list ( ) ; for ( int i = num ; i < get num edges ( ) ; ++ i ) { s2 point from = edge from ( i ) ; s2 point to = edge to ( i ) ; array list < s2 cell id > cover = new array list ( ) ; int level = get covering ( from , to , bool , cover ) ; minimum s2 level used = math . min ( minimum s2 level used , level ) ; for ( s2 cell id cell id : cover ) { cell list . add ( cell id . id ( ) ) ; edge list . add ( i ) ; } } cells = new long [ cell list . size ( ) ] ; edges = new int [ edge list . size ( ) ] ; for ( int i = num ; i < cells . length ; i ++ ) { cells [ i ] = cell list . get ( i ) ; edges [ i ] = edge list . get ( i ) ; } sort index ( ) ; index computed = bool ; }	computes the index ( if it has not been previously done ) .
public wait for any listener ( int number of results ) { this ( number of results , null ) ; }	constructs a new listener with the number of executions this listener will be set on .
public static object string to value ( string string ) { double d ; if ( string . equals ( str ) ) { return string ; } if ( string . equals ignore case ( str ) ) { return boolean . true ; } if ( string . equals ignore case ( str ) ) { return boolean . false ; } if ( string . equals ignore case ( str ) ) { return json . null ; } char b = string . char at ( num ) ; if ( ( b >= str && b <= str ) || b == str || b == str || b == str ) { try { if ( string . index of ( str ) > - num || string . index of ( str ) > - num || string . index of ( str ) > - num ) { d = double . value of ( string ) ; if ( ! d . is infinite ( ) && ! d . is na n ( ) ) { return d ; } } else { long my long = new long ( string ) ; if ( my long . long value ( ) == my long . int value ( ) ) { return new integer ( my long . int value ( ) ) ; } else { return my long ; } } } catch ( exception ignore ) { } } return string ; }	try to convert a string into a number , boolean , or null.
public abstract void on pin set ( string pin ) ;	abstract method which gives the pin entered by user.
public void test case9 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; int a sign = - num ; int b sign = - num ; byte r bytes [ ] = { - num , - num , - num , - num , - num , - num , - num , - num , - num , - num , - num , - num , - num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . add ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , result . signum ( ) ) ; }	add two negative numbers of different length.
public void remove nodes from partition ( list < i > nodes to remove ) { for ( final i node to remove : nodes to remove ) { if ( node to remove != null ) { if ( ! non optional non minus nodes . remove ( node to remove ) ) { if ( node to remove . equals ( optional or minus ) ) { optional or minus = null ; } } } } recompute definitely produced ( ) ; }	removes the given set of nodes and updates the internal data structures .
public static void banner ( logger logger , class < ? > clazz , string method name , string text ) { string string = clazz . get simple name ( ) + str + method name ; if ( text != null ) { string += str + text ; } logger . info ( str ) ; logger . info ( str ) ; logger . info ( str + string ) ; logger . info ( str ) ; }	log a banner containing the class and method name and text.
private void read object ( object input stream in ) throws io , class not found exception { in . default read object ( ) ; if ( resource bundle name != null ) { try { rb = resource bundle . get bundle ( resource bundle name ) ; } catch ( missing resource exception e ) { rb = null ; } } }	serialization helper to setup transient resource bundle instance .
private static void exit ( @ nullable string err msg , @ nullable options options , int exit code ) { if ( err msg != null ) echo ( str + err msg ) ; string runner = system . get property ( ignite prog name , str ) ; int space = runner . index of ( str ) ; runner = runner . substring ( num , space == - num ? runner . length ( ) : space ) ; if ( options != null ) { help formatter formatter = new help formatter ( ) ; formatter . print help ( runner , options ) ; } system . exit ( exit code ) ; }	exists with optional error message , usage show and exit code .
private static void replace alt special instructions ( ) { fill instruction map ( num , num , new fr instruction ( instruction format . d , num , num , str , str , str , instruction . flow type . none , bool , bool , andccr u8 simulation code ) ) ; fill instruction map ( num , num , new fr instruction ( instruction format . d , num , num , str , str , str , instruction . flow type . none , bool , bool , stilm u8 simulation code ) ) ; fill instruction map ( num , num , new fr instruction ( instruction format . d , num , num , str , str , str , instruction . flow type . none , bool , bool , orccr u8 simulation code ) ) ; fill instruction map ( num , num , new fr instruction ( instruction format . d , num , num , str , str , str , instruction . flow type . none , bool , bool , addsp s10 simulation code ) ) ; }	these are replacement names for dedicated opcodes working on ilm , ccr and sp so that they look the same as others.
@ override public boolean add sensor to route ( string sensor name , int mode ) { if ( control sensor list . size ( ) >= max control sensors ) { log . warn ( str , get system name ( ) ) ; } control sensor sensor = new control sensor ( sensor name ) ; log . debug ( str , get system name ( ) , sensor name ) ; if ( ! sensor . set state ( mode ) ) { return bool ; } if ( is control sensor included ( sensor ) ) { log . debug ( str , sensor name , get system name ( ) ) ; } else { control sensor list . add ( sensor ) ; } return bool ; }	method to add a sensor to the list of control sensors for this route .
private void eliminate backfill states ( int base state ) { if ( states to backfill . contains ( new integer ( base state ) ) ) { states to backfill . remove element ( new integer ( base state ) ) ; short [ ] state = temp state table . element at ( base state ) ; for ( int i = num ; i < num categories ; i ++ ) { if ( state [ i ] != num ) { eliminate backfill states ( state [ i ] ) ; } } } }	this removes " ending states " and states reachable from them from the list of states to backfill .
static boolean separate convex polygons ( float [ ] verts1 , float [ ] verts2 , vector2 separation ) { final int length1 = verts1 . length ; final int length2 = verts2 . length ; for ( int i = num ; i < length1 ; i += num ) { final int j = ( i + num ) % length1 ; float proj x = verts1 [ j + num ] - verts1 [ i + num ] ; float proj y = verts1 [ i ] - verts1 [ j ] ; final float length = ( float ) math . sqrt ( proj x * proj x + proj y * proj y ) ; proj x /= length ; proj y /= length ; float min1 = float . positive infinity , max1 = float . negative infinity ; for ( int k = num ; k < length1 ; k += num ) { final float dot = proj x * verts1 [ k ] + proj y * verts1 [ k + num ] ; if ( dot < min1 ) min1 = dot ; if ( dot > max1 ) max1 = dot ; } float min2 = float . positive infinity , max2 = float . negative infinity ; for ( int k = num ; k < length2 ; k += num ) { final float dot = proj x * verts2 [ k ] + proj y * verts2 [ k + num ] ; if ( dot < min2 ) min2 = dot ; if ( dot > max2 ) max2 = dot ; } if ( ( max1 < min2 ) || ( max2 < min1 ) ) { if ( null != separation ) separation . set ( proj y , - proj x ) ; return bool ; } } return bool ; }	check whether some of the first polygon ' s edges defined forms a separation axis of two polygons defined by the lists of vertices.
public string payment term ( properties ctx , int window no , grid tab m tab , grid field m field , object value ) { integer c id = ( integer ) value ; int c id = env . get context as int ( ctx , window no , str ) ; if ( c id == null || c id . int value ( ) == num || c id == num ) return str ; m pt = new m ( ctx , c id . int value ( ) , null ) ; if ( pt . get id ( ) == num ) return str ; boolean valid = pt . apply ( c id ) ; m tab . set value ( str , valid ? str : str ) ; return str ; }	set payment term . payment term has changed.
public static void transform criteria ( properties form properties , input stream xsl is , result result ) throws sax , io , parser configuration exception , transformer exception { dbf . set namespace aware ( bool ) ; document builder builder = dbf . new document builder ( ) ; org . w3c . dom . document xsl doc = builder . parse ( xsl is ) ; dom ds = new dom ( xsl doc ) ; transformer transformer = null ; synchronized ( t factory ) { transformer = t factory . new transformer ( ds ) ; } transform criteria ( form properties , transformer , result ) ; }	slower transformation using an uncompiled stylesheet ( suitable for development environment ).
public static list < byte [ ] > split and pad ( byte [ ] byte array , int blocksize ) { list < byte [ ] > blocks = new array list < byte [ ] > ( ) ; int num blocks = ( int ) math . ceil ( byte array . length / ( double ) blocksize ) ; for ( int i = num ; i < num blocks ; i ++ ) { byte [ ] block = new byte [ blocksize ] ; arrays . fill ( block , ( byte ) num ) ; if ( i + num == num blocks ) { int remaining bytes = byte array . length - ( i * blocksize ) ; system . arraycopy ( byte array , i * blocksize , block , num , remaining bytes ) ; } else { system . arraycopy ( byte array , i * blocksize , block , num , blocksize ) ; } blocks . add ( block ) ; } return blocks ; }	splits the given array into blocks of given size and adds padding to the last one , if necessary .
public void put ( e item ) throws interrupted exception { if ( ! done . get ( ) ) { queue . put ( item ) ; } }	adds another item to the queue , blocking while the queue is full .
protected void notify complete ( ) { final string method name = str ; log . fine ( class name , method name , str , new object [ ] { get key ( ) , this . response , this . exception } ) ; synchronized ( response lock ) { if ( exception == null && pending complete ) { completed = bool ; pending complete = bool ; } else { pending complete = bool ; } response lock . notify all ( ) ; } synchronized ( sent lock ) { sent = bool ; sent lock . notify all ( ) ; } }	notifies this token that a response message ( an ack or nack ) has been received .
private node < k , v > [ ] init table ( ) { node < k , v > [ ] tab ; int sc ; while ( ( tab = table ) == null || tab . length == num ) { if ( ( sc = size ctl ) < num ) { thread . yield ( ) ; } else if ( u . compare and swap int ( this , sizectl , sc , - num ) ) { try { if ( ( tab = table ) == null || tab . length == num ) { int n = ( sc > num ) ? sc : default capacity ; @ suppress warnings ( str ) node < k , v > [ ] nt = ( node < k , v > [ ] ) new node < ? , ? > [ n ] ; table = tab = nt ; sc = n - ( n > > > num ) ; } } finally { size ctl = sc ; } break ; } } return tab ; }	initializes table , using the size recorded in sizectl .
public synchronized boolean load public key ( ) { if ( ! has ( str ) || ! has ( str ) ) return bool ; string encoded key = get string ( str ) ; string algorithm = get string ( str ) ; public key pub = io . decode public key ( encoded key , algorithm ) ; if ( pub != null ) { public key = pub ; key algorithm = algorithm ; set peer hash ( ) ; return bool ; } return bool ; }	load public key from file.
private void load text data ( data input stream dis ) throws io { for ( int f = num ; f < num frames ; f ++ ) { times [ f ] = float . parse float ( general . read word ( dis ) ) ; general . read word ( dis ) ; for ( int c = num ; c < num channels ; c ++ ) { frames [ f ] [ c ] = float . parse float ( general . read word ( dis ) ) ; } } }	load the data section of the file as ascii text.
public static boolean is gzip content ( string content encoding ) { return content encoding != null && content encoding . contains ( str ) ; }	whether the content has been compressed .
public synchronized boolean check size ( final int size checked ) { if ( ! started ) { throw new illegal state exception ( str ) ; } if ( size checked > buffer size ) { throw new illegal state exception ( str + buffer size + str ) ; } if ( buffer limit == num || buffer . writer index ( ) + size checked > buffer limit ) { flush ( ) ; delay flush = bool ; final int remaining in file = buffer observer . get remaining bytes ( ) ; if ( size checked > remaining in file ) { return bool ; } else { buffer limit = math . min ( remaining in file , buffer size ) ; return bool ; } } else { delay flush = bool ; return bool ; } }	verify if the size fits the buffer.
public void test compare less scale1 ( ) { string a = str ; int a scale = num ; string b = str ; int b scale = num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; int result = num ; assert equals ( str , result , a number . compare to ( b number ) ) ; }	compare to a number of an less scale.
public void exit ( ) { exit called = bool ; if ( thread map != null ) { delete all threads ( ) ; log . info ( str ) ; if ( duration statistics . collect statistics ) { statistics . exit ( ) ; log . info ( string . format ( str , statistics . all cycles , statistics . get duration millis ( ) / num ) ) ; collections . sort ( statistics . threads ) ; for ( statistics . thread statistics thread statistics : statistics . threads ) { double percentage = num ; if ( statistics . all cycles != num ) { percentage = ( thread statistics . run clocks / ( double ) statistics . all cycles ) * num ; } log . info ( string . format ( str , thread statistics . get quoted name ( ) , thread statistics . run clocks , percentage ) ) ; } } } }	to be called when exiting the emulation.
private void format node to ( formatter f , int level , radix tree node < t > node ) { for ( int i = num ; i < level ; i ++ ) { f . format ( str ) ; } f . format ( str ) ; for ( int i = num ; i < level ; i ++ ) { f . format ( str ) ; } if ( node . is real ( ) == bool ) f . format ( str , node . get key ( ) , node . get value ( ) ) ; else f . format ( str , node . get key ( ) ) ; for ( radix tree node < t > child : node . get childern ( ) ) { format node to ( f , level + num , child ) ; } }	warning ! do not use this for a large trie , it ' s for testing purpose only .
protected void start download ( int blocks ) { if ( blocks > num ) log . info ( str + blocks + str + ( blocks > num ? str : str ) ) ; }	called when download is initiated .
public void add ( int start , int end , int handler , int type ) { if ( start < end ) entries . add ( new exception table entry ( start , end , handler , type ) ) ; }	appends a new entry at the end of the table .
private void free kick ( team offense ) { if ( game time <= num ) return ; else { if ( game time < num && ( ( game poss && ( away score - home score ) <= num && ( away score - home score ) > num ) || ( ! game poss && ( home score - away score ) <= num && ( home score - away score ) > num ) ) ) { if ( offense . get k ( num ) . rat kick fum * math . random ( ) > num || math . random ( ) < num ) { game event log += get event prefix ( ) + offense . abbr + str + offense . get k ( num ) . name + str + offense . abbr + str ; game yard line = num ; game down = num ; game yards need = num ; } else { game event log += get event prefix ( ) + offense . abbr + str + offense . get k ( num ) . name + str ; game poss = ! game poss ; game yard line = num ; game down = num ; game yards need = num ; } game time -= num + num * math . random ( ) ; } else { game yard line = ( int ) ( num - ( offense . get k ( num ) . rat kick pow + num - num * math . random ( ) ) ) ; if ( game yard line <= num ) game yard line = num ; game down = num ; game yards need = num ; game poss = ! game poss ; game time -= num * math . random ( ) ; } } }	kick the ball off following a safety , turning the ball over to the other team.
private void process new port ( long sw , short p ) { if ( is link discovery suppressed ( sw , p ) ) { return ; } iof iof switch = floodlight provider . get switch ( sw ) ; if ( iof switch == null ) return ; if ( auto port fast feature && iof switch . is fast port ( p ) ) { return ; } node port tuple npt = new node port tuple ( sw , p ) ; discover ( sw , p ) ; if ( ! iof switch . is fast port ( p ) ) { add to quarantine queue ( npt ) ; } else { add to maintenance queue ( npt ) ; } }	process a new port.
public static void put3 byte int ( byte buffer buffer , int val ) { put3 byte int ( buffer , val , buffer . order ( ) ) ; }	put an integer into the given buffer at the given offset as a 3 - byte integer .
public static void assert no exception ( runnable expression , string error message ) { if ( verbose ) { log ( str + expression + str + error message + str ) ; } try { expression . run ( ) ; } catch ( runtime exception failure ) { test utils . fail ( error message ) ; } }	asserts that no exception is raised.
@ override public int index of ( object object ) { return index of ( object , num ) ; }	searches in this vector for the index of the specified object.
protected response format type generate accept format ( string format ) throws bad api request exception { try { return format == null ? response format type . json : response format type . value of ( format . to upper case ( locale . english ) ) ; } catch ( illegal argument exception e ) { log . error ( accept format invalid . log format ( format ) , e ) ; throw new bad api request exception ( accept format invalid . format ( format ) ) ; } }	generates the format in which the response data is expected .
public shared object ( map < string , object > data , string name , string path , boolean persistent ) { super ( ) ; this . name = name ; this . path = path ; this . persistent so = persistent ; owner message = new shared object message ( null , name , num , persistent ) ; creation time = system . current time millis ( ) ; super . set attributes ( data ) ; }	creates new so from given data map , name , path and persistence option.
public static string date to string ( date date ) { if ( date == null ) { return null ; } else { date format df = new simple date format ( date format ) ; df . set time zone ( utc ) ; return df . format ( date ) ; } }	converts a date object to a string representation .
public static string info first last pixels ( image line int line ) { return line . img info . channels == num ? string . format ( str , line . scanline [ num ] , line . scanline [ line . scanline . length - num ] ) : string . format ( str , line . scanline [ num ] , line . scanline [ num ] , line . scanline [ num ] , line . scanline [ line . scanline . length - line . img info . channels ] , line . scanline [ line . scanline . length - line . img info . channels + num ] , line . scanline [ line . scanline . length - line . img info . channels + num ] ) ; }	just for basic info or debugging.
public static iterable < element > elements ( node list nodes ) { return null ; }	returns an iterable collection for the elements in the given node list .
public void add url ( string url ) { set < string > urls = get cached urls ( ) ; urls . add ( url ) ; put cached urls ( urls ) ; update notification ( urls ) ; }	add a url to the store of urls.
public void test value of long max ( ) { long long val = long . max value ; big integer a number = big integer . value of ( long val ) ; byte r bytes [ ] = { num , - num , - num , - num , - num , - num , - num , - num } ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = a number . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , a number . signum ( ) ) ; }	valueof ( long val ) : convert long.
private void close database connection ( connection connection ) { if ( connection == null ) return ; try { connection . close ( ) ; } catch ( sql e ) { } connection = null ; return ; }	close a database connection.
@ override public boolean e is set ( int feature id ) { switch ( feature id ) { case information model package . information model name : return name edefault == null ? name != null : ! name edefault . equals ( name ) ; case information model package . information model namespace : return namespace edefault == null ? namespace != null : ! namespace edefault . equals ( namespace ) ; case information model package . information model version : return version edefault == null ? version != null : ! version edefault . equals ( version ) ; case information model package . information model references : return references != null && ! references . is empty ( ) ; case information model package . information model description : return description edefault == null ? description != null : ! description edefault . equals ( description ) ; case information model package . information model displayname : return displayname edefault == null ? displayname != null : ! displayname edefault . equals ( displayname ) ; case information model package . information model category : return category edefault == null ? category != null : ! category edefault . equals ( category ) ; case information model package . information model properties : return properties != null && ! properties . is empty ( ) ; } return super . e is set ( feature id ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
public void add unnamed task ( tmm task task ) { if ( unnamed task executor == null || unnamed task executor . is shutdown ( ) ) { unnamed task executor = create unnamed task executor ( ) ; } task . add listener ( this ) ; task . set state ( task state . queued ) ; unnamed task executor . execute ( task ) ; }	add a tasks which does not fit in the named queues ( like caching or tv show episode scraping task ).
public path ( final vertex v0 , final vertex v1 , final edge sample edge sample ) { if ( v0 == null ) throw new illegal argument exception ( ) ; if ( v1 == null ) throw new illegal argument exception ( ) ; if ( v0 . sample == null ) throw new illegal argument exception ( ) ; if ( edge sample == null ) throw new illegal argument exception ( ) ; if ( edge sample . get sample ( ) == null ) throw new illegal argument exception ( ) ; this . vertices = new vertex [ ] { v0 , v1 } ; this . preds = get predicates ( vertices ) ; this . edge sample = edge sample ; this . sum est read = v0 . sample . est card + edge sample . est read ; this . sum est card = edge sample . est card ; this . sum est cost = get cost ( this . sum est read , this . sum est card ) ; }	create a path from a single edge .
public boolean evaluate ( map record ) { object rec val = record . get ( key field ) ; return op . evaluate ( this . val , rec val ) ; }	asks the op class to evaluate the provided value against the rules value .
public char [ ] to char array ( ) { charset utf8 = charset . for name ( str ) ; char buffer char buffer = utf8 . decode ( byte buffer . wrap ( buffer , offset , length ) ) ; char [ ] chars = new char [ char buffer . remaining ( ) ] ; char buffer . get ( chars ) ; return chars ; }	returns the utf - 8 decoded char array representation of this byte sequence .
public static byte [ ] chars2utf ( char [ ] src , int sindex , int len ) { byte [ ] dst = new byte [ len * num ] ; int len1 = chars2utf ( src , sindex , dst , num , len ) ; byte [ ] result = new byte [ len1 ] ; system . arraycopy ( dst , num , result , num , len1 ) ; return result ; }	return characters as an array of bytes in utf8 representation .
public static void agentmain ( string agent args , instrumentation inst ) throws exception { synchronized ( jvm . class ) { if ( instance == null ) { instance = new jvm ( inst ) ; wait for instance . count down ( ) ; } } }	when the agent gets loaded , this method is called , giving us an instrumentation instance . voila !.
public void close ( ) { handler [ ] handler array = m logger . get handlers ( ) ; for ( int i = num ; i < handler array . length ; i ++ ) { handler h = handler array [ i ] ; h . flush ( ) ; h . close ( ) ; m logger . remove handler ( h ) ; } }	close and remove the handlers.
public string to string ( ) { if ( val == null ) return str ; if ( val instanceof long || val instanceof integer ) { return long . to string ( val . long value ( ) ) ; } double d = val . double value ( ) ; if ( double . is infinite ( d ) ) return ( d > num ) ? str : str ; if ( double . is na n ( d ) ) return str ; return double . to string ( d ) ; }	returns the string representing the object.
public static list < string > split text ( string text ) { int start line = num ; int i = num ; int n = text . length ( ) ; array list < string > rc = new array list < string > ( ) ; while ( i < n ) { switch ( text . char at ( i ) ) { case str : i ++ ; if ( i < n && text . char at ( i ) == str ) { i ++ ; } rc . add ( text . substring ( start line , i ) ) ; start line = i ; break ; case str : i ++ ; if ( i < n && text . char at ( i ) == str ) { i ++ ; } rc . add ( text . substring ( start line , i ) ) ; start line = i ; break ; default : i ++ ; } } if ( start line == text . length ( ) ) { rc . add ( str ) ; } else { rc . add ( text . substring ( start line , i ) ) ; } return rc ; }	split text into lines.
country code source maybe strip international prefix and normalize ( string builder number , string possible idd prefix ) { if ( number . length ( ) == num ) { return country code source . from default country ; } matcher m = plus chars pattern . matcher ( number ) ; if ( m . looking at ( ) ) { number . delete ( num , m . end ( ) ) ; normalize ( number ) ; return country code source . from number with plus sign ; } pattern idd pattern = regex cache . get pattern for regex ( possible idd prefix ) ; normalize ( number ) ; return parse prefix as idd ( idd pattern , number ) ? country code source . from number with idd : country code source . from default country ; }	strips any international prefix ( such as + , 00 , 011 ) present in the number provided , normalizes the resulting number , and indicates if an international prefix was present .
@ override public void write ( int value ) { digest . update ( ( byte ) value ) ; }	updates a digest with one byte .
public boolean is manufactured ( boolean ignore supplier products ) { list < generic value > supplier products = null ; try { supplier products = product . get related ( str , util misc . to map ( str , str ) , util misc . to list ( str ) , bool ) ; } catch ( generic entity exception gee ) { debug . log error ( str , module ) ; } supplier products = entity util . filter by date ( supplier products , util date time . now timestamp ( ) , str , str , bool ) ; return children nodes . size ( ) > num && ( ignore supplier products || util validate . is empty ( supplier products ) ) ; }	a part is considered manufactured if it has child nodes and unless ignoresupplierproducts is set , if it also has no unexpired supplierproducts defined.
private void add code from field ( string builder sb , field f ) { try { sb . append ( f . get name ( ) + str + f . get int ( key event . class ) ) ; } catch ( illegal argument exception e ) { e . print stack trace ( ) ; } catch ( illegal access exception e ) { e . print stack trace ( ) ; } sb . append ( str ) ; }	add a new line of code that defines the field constant.
protected boolean scroll up ( text view widget , spannable buffer , int amount ) { final layout layout = widget . get layout ( ) ; final int top = widget . get scroll y ( ) ; int top line = layout . get line for vertical ( top ) ; if ( layout . get line top ( top line ) == top ) { top line -= num ; } if ( top line >= num ) { top line = math . max ( top line - amount + num , num ) ; touch . scroll to ( widget , layout , widget . get scroll x ( ) , layout . get line top ( top line ) ) ; return bool ; } return bool ; }	performs a scroll up action.
public void load ( string filename ) { ++ num mappings ; load class file ( filename ) ; }	load the class map from file .
protected void fill face tool bar ( j face tb , button group bg ) { for ( edit tool loader loader : loader list ) { string [ ] classnames = loader . get editable classes ( ) ; for ( int i = num ; i < classnames . length ; i ++ ) { image icon icon = loader . get icon ( classnames [ i ] ) ; j btn = new j ( icon , bool ) ; btn . set tool tip text ( loader . get pretty name ( classnames [ i ] ) ) ; btn . set focusable ( bool ) ; btn . set action command ( classnames [ i ] ) ; btn . add action listener ( this ) ; bg . add ( btn ) ; face tb . add ( btn ) ; } } }	fill the face ' s toolbar with buttons.
public void write to file ( file filename ) throws io { file utils . string to file ( m text . to string ( ) , filename ) ; }	write the reference . txt to a file.
protected void transform rects touch ( array list < f > rects ) { for ( int i = num ; i < rects . size ( ) ; i ++ ) { m matrix touch . map rect ( rects . get ( i ) ) ; } }	transforms the given rect objects with the touch matrix only.
@ override public string to string ( ) { string builder buf = new string builder ( ) ; for ( name value pair pair : name value pair list ) { buf . append ( str ) ; buf . append ( pair . get name ( ) ) ; buf . append ( str ) ; buf . append ( str ) ; buf . append ( get quoted attribute value ( pair . get value ( ) ) ) ; buf . append ( str ) ; } return buf . to string ( ) ; }	return the attribute list as a string which can be directly output as part of an xml tag .
@ override public final int array offset ( ) { return protected array offset ( ) ; }	returns the offset of the byte array which this buffer is based on , if there is one.
public dom new instance ( document builder setting [ ] new settings ) throws dom { if ( new settings == null ) { return this ; } document builder setting [ ] merged settings = merge settings ( new settings ) ; return new batik test document builder factory ( merged settings ) ; }	create new instance of document builder factory reflecting specified settings .
public float [ ] value array ( float [ ] array ) { if ( array == null || array . length != size ( ) ) { array = new float [ count ] ; } system . arraycopy ( values , num , array , num , count ) ; return array ; }	fill an already - allocated array with the values ( more efficient than creating a new array each time ).
public static set < type variable > method type to targets ( final annotated executable type method type ) { final list < annotated type variable > annotated type vars = method type . get type variables ( ) ; final set < type variable > targets = new linked hash set < > ( annotated type vars . size ( ) ) ; for ( final annotated type variable atv : annotated type vars ) { targets . add ( atv . get underlying type ( ) ) ; } return targets ; }	given an annotatedexecutabletype return a set of type variables that represents the generic type parameters of that method.
private void validate table meta data single row ( string table name pattern , string [ ] types , map < table meta data , object > validation rules ) throws exception { check validation rules complete ( validation rules ) ; try ( result set tables = dbmd . get tables ( null , null , table name pattern , types ) ) { assert true ( str , tables . next ( ) ) ; validate row values ( tables , validation rules ) ; assert false ( str , tables . next ( ) ) ; } }	helper method for test methods that retrieve a single metadata row .
public void flush ( ) throws io { try { writer . write ( buffer , num , pos ) ; writer . flush ( ) ; } catch ( io except ) { if ( exception == null ) exception = except ; throw except ; } pos = num ; }	flush the output stream.
private java script relation sets ( ) { }	prevent instantiation of this name - space class .
private j make log level menu ( ) { return new log level menu ( ) ; }	creates the log level menu for the current log .
@ override public void close ( ) throws io { synchronized ( lock ) { buf = null ; in . close ( ) ; } }	closes this reader . this implementation closes the source reader and releases the pushback buffer .
public d ( j parent , string title , string alias ) { super ( parent , title , dialog . modality type . document modal ) ; init components ( alias ) ; }	creates a new dgetalias dialog .
public static array list < hop > deep copy hops dag ( array list < hop > hops ) throws hops exception { array list < hop > ret = new array list < hop > ( ) ; try { hash map < long , hop > memo = new hash map < long , hop > ( ) ; for ( hop hop root : hops ) ret . add ( r deep copy hops dag ( hop root , memo ) ) ; } catch ( exception ex ) { throw new hops exception ( ex ) ; } return ret ; }	deep copy of hops dags for parallel recompilation .
public void add all ( t ... items ) { if ( m event delegate != null ) m event delegate . add data ( items == null ? num : items . length ) ; if ( items != null && items . length != num ) { synchronized ( m lock ) { collections . add all ( m objects , items ) ; } } if ( m notify on change ) notify data set changed ( ) ; }	adds the specified items at the end of the array .
private void replace impl ( final int start index , final int end index , final int remove len , final string insert str , final int insert len ) { final int new size = size - remove len + insert len ; if ( insert len != remove len ) { ensure capacity ( new size ) ; system . arraycopy ( buffer , end index , buffer , start index + insert len , size - end index ) ; size = new size ; } if ( insert len > num ) { insert str . get chars ( num , insert len , buffer , start index ) ; } }	internal method to delete a range without validation .
public void update cheque dd ( final map instrument details map ) { update instrument and payin sql ( instrument details map ) ; add to bank reconcilation sql ( instrument details map ) ; }	this method will be called for remit to bank in case of cheque / dd / card / atm / online deposit where a receipt voucher is generated this api will be used for only when it is called in loop.
public void testtest is last ( ) throws sql { assert false ( target . is last ( ) ) ; target . absolute ( - num ) ; assert true ( target . is last ( ) ) ; assert false ( empty target . is last ( ) ) ; assert false ( empty target . next ( ) ) ; assert false ( empty target . is last ( ) ) ; try { target . close ( ) ; target . is last ( ) ; fail ( str ) ; } catch ( sql e ) { } }	second block first assertion fails.
public final void add helper text ( @ non null final char sequence helper text ) { ensure not null ( helper text , str ) ; ensure not empty ( helper text , str ) ; if ( ! helper texts . contains ( helper text ) ) { helper texts . add ( helper text ) ; verify password strength ( ) ; } }	adds a new helper text , which should be shown , depending on the password strength.
void wait for log entry ( int index , int timeout ) throws gondola exception , interrupted exception , timeout exception { reset ( ) ; this . index = index ; long end ts = timeout < num ? long . max value : gondola . get clock ( ) . now ( ) + timeout ; lock . lock ( ) ; try { while ( status == command . status none && gondola . get clock ( ) . now ( ) < end ts ) { if ( timeout < num ) { update cond . await ( ) ; } else { update cond . await ( timeout , time unit . milliseconds ) ; } } if ( this . index != index ) { logger . error ( str ) ; } } finally { lock . unlock ( ) ; } switch ( status ) { case command . status none : status = command . status timeout ; throw new timeout exception ( string . format ( str , timeout , index ) ) ; case command . status not leader : assert bool ; break ; case command . status slave mode : throw new gondola exception ( gondola exception . code . slave mode , cmember . member id ) ; case command . status error : throw new illegal state exception ( str + index + str + error message ) ; case command . status ok : break ; } }	this should not be called by clients.
public static string generate native guid ( db client db client , volume volume ) throws io { storage system device = db client . query object ( storage system . class , volume . get storage controller ( ) ) ; return string . format ( str + volume + str , device type map . get ( device . get system type ( ) ) , device . get serial number ( ) , volume . get native id ( ) ) ; }	generates the format storagesystem + serialnumber + volume + nativeid native guid for volume objects.
public agent mappings save agent mappings ( agent mappings agent mappings , boolean check environments ) throws business exception , jaxb , io { if ( check environments ) { check environments ( agent mappings ) ; } agent mappings current ; do { current = agent mappings reference . get ( ) ; if ( current . get revision ( ) != agent mappings . get revision ( ) ) { throw new business exception ( str , configuration interface error code enum . revision check failed ) ; } } while ( ! agent mappings reference . compare and set ( current , agent mappings ) ) ; agent mappings . set revision ( agent mappings . get revision ( ) + num ) ; save agent mapping ( agent mappings ) ; publish agent mappings update event ( ) ; return agent mappings ; }	sets the agent mappings to be used .
public e push ( e object ) { add element ( object ) ; return object ; }	pushes the specified object onto the top of the stack .
protected void new cert btn listener ( ) { new certificate dialog data data = new new certificate dialog data ( ) ; new certificate dialog dialog = new new certificate dialog ( get shell ( ) , data , str ) ; int return code = dialog . open ( ) ; if ( return code == window . ok ) { string cert path = data . get cer file path ( ) ; cert txt . set text ( cert path != null ? cert path . replace ( str , str ) : cert path ) ; cert info txt . set text ( get cert info ( cert txt . get text ( ) ) ) ; } }	listener for new button .
public static void generate mov ( final i environment , final long base offset , final i instruction , final list < reil instruction > instructions ) throws internal translation exception { preconditions . check not null ( environment , str ) ; preconditions . check not null ( instruction , str ) ; preconditions . check not null ( instructions , str ) ; long reil offset = base offset ; final list < ? extends i > operands = instruction . get operands ( ) ; final translation result load source = helpers . translate operand ( environment , reil offset , operands . get ( num ) , bool ) ; instructions . add all ( load source . get instructions ( ) ) ; reil offset = base offset + instructions . size ( ) ; final translation result load dest = helpers . translate operand ( environment , reil offset , operands . get ( num ) , bool ) ; instructions . add all ( load dest . get instructions ( ) ) ; reil offset = base offset + instructions . size ( ) ; helpers . write back ( environment , reil offset , operands . get ( num ) , load source . get register ( ) , load dest . get size ( ) , load dest . get address ( ) , load dest . get type ( ) , instructions ) ; }	generates code for a mov or cmovcc instruction.
public void characters ( char ch [ ] , int start , int length ) throws org . xml . sax . sax { if ( ! m should process ) return ; xslt elem processor = get current processor ( ) ; xslt def = elem processor . get elem def ( ) ; if ( def . get type ( ) != xslt . t pcdata ) elem processor = def . get processor for ( null , str ) ; if ( null == elem processor ) { if ( ! xml . is white space ( ch , start , length ) ) error ( xsl . create message ( xslt . er nonwhitespace not allowed in position , null ) , null ) ; } else elem processor . characters ( this , ch , start , length ) ; }	receive notification of character data inside an element .
public void test bug68562 ( ) throws exception { test bug68562 batch with size ( num ) ; test bug68562 batch with size ( num ) ; }	tests fix for bug # 68562 - combination rewritebatchedstatements and useaffectedrows not working as expected.
public vec2 to vector ( d v ) { return new vec2 ( to meters ( v . get x ( ) ) , to meters ( - v . get y ( ) ) ) ; }	converts a vector of type point2d to vector of type vec2.
@ override public void terminate any restore sessions ( storage system storage , block object from , uri volume , task completer task completer ) throws exception { block object block object = block object . fetch ( db client , volume ) ; collection < cim > sync objects = null ; if ( storage . check if vmax3 ( ) ) { sync objects = helper . get settings define state paths ( storage , block object , ( block snapshot ) from ) ; } else { sync objects = get restored or mixed state sync objects ( storage , block object ) ; } for ( cim sync object : sync objects ) { resume snapshot ( storage , from , block object , sync object , task completer ) ; } }	given a snapshot and a uri of its parent volume , look up any existing restore sessions and terminate them .
public static < t > set < t > to set ( t obj1 , t obj2 , t obj3 , t obj4 , t obj5 , t obj6 ) { set < t > the set = new linked hash set < t > ( ) ; the set . add ( obj1 ) ; the set . add ( obj2 ) ; the set . add ( obj3 ) ; the set . add ( obj4 ) ; the set . add ( obj5 ) ; the set . add ( obj6 ) ; return the set ; }	create a set from passed objx parameters.
protected void write graphic ctrl ext ( ) throws io { out . write ( num ) ; out . write ( num ) ; out . write ( num ) ; int transp , disp ; if ( transparent == - num ) { transp = num ; disp = num ; } else { transp = num ; disp = num ; } if ( dispose >= num ) { disp = dispose & num ; } disp <<= num ; out . write ( num | disp | num | transp ) ; write short ( delay ) ; out . write ( trans index ) ; out . write ( num ) ; }	writes graphic control extension.
public final double do operation ( ) throws operator failed exception { int index ; if ( update map == null ) { index = math utils . next int ( parameter . get dimension ( ) ) ; } else { index = update map . get ( math utils . next int ( update map size ) ) ; } double draw = ( num * math utils . next double ( ) - num ) * window size ; double new value = parameter . get parameter value ( index ) + draw ; final bounds < double > bounds = parameter . get bounds ( ) ; final double lower = ( lower operator bound == null ? bounds . get lower limit ( index ) : math . max ( bounds . get lower limit ( index ) , lower operator bound ) ) ; final double upper = ( upper operator bound == null ? bounds . get upper limit ( index ) : math . min ( bounds . get upper limit ( index ) , upper operator bound ) ) ; if ( condition == boundary condition . reflecting ) { new value = reflect value ( new value , lower , upper ) ; } else if ( condition == boundary condition . absorbing && ( new value < lower || new value > upper ) ) { return num ; } else if ( new value < lower || new value > upper ) { throw new operator failed exception ( str ) ; } parameter . set parameter value ( index , new value ) ; return num ; }	change the parameter and return the hastings ratio .
public collection < object > injectables ( ) { return collections . empty list ( ) ; }	this method returns spi internal instances that need to be injected as well.
private void update effective dimensions ( ) { effective width = math . max ( num , width - left border - right border ) ; effective height = math . max ( num , height - top border - bottom border ) ; }	updates the effective dimensions .
public void add attribute ( attribute info info ) { if ( attribute == null ) attribute = new array list ( ) ; attribute info . remove ( attribute , info . get name ( ) ) ; attribute . add ( info ) ; }	appends an attribute . if there is already an attribute with the same name , the new one substitutes for it .
public void add line ( string text ) throws bad location exception { if ( text == null || text . length ( ) == num || text . equals ( str ) ) { return ; } document . replace ( document . get length ( ) , num , text ) ; }	contrary to addincrement ( string ) , this method does not verify that the input terminates with the newline separator.
protected void mute button pressed ( action event e ) { j b = ( j ) e . get source ( ) ; log . debug ( str + b . is selected ( ) ) ; fire property change ( id . mute , ! b . is selected ( ) , b . is selected ( ) ) ; }	handle " mute " button press.
public d ( string s ) { string tokenizer st = new string tokenizer ( s , str ) ; x = double . value of ( st . next token ( ) ) ; y = double . value of ( st . next token ( ) ) ; }	construct when given a comma - separated string of x , y values as double.
private void read object ( final object input stream in ) throws io , class not found exception { in . default read object ( ) ; init ( ) ; }	create the object after serialization.
public static boolean is class support ( string clz name ) { try { class . for name ( clz name ) ; return bool ; } catch ( class not found exception e ) { return bool ; } }	check if the class is valid by clzname.
public void add popup listener ( final popup listener listener ) { if ( ! popup listeners . contains ( listener ) ) { popup listeners . add ( listener ) ; } }	adds a listener which will be notified when the popup is opened .
public static byte [ ] decode ( byte [ ] data ) { int len = data . length / num * num ; byte array output stream b out = new byte array output stream ( len ) ; try { encoder . decode ( data , num , data . length , b out ) ; } catch ( exception e ) { throw new decoder exception ( str + e . get message ( ) , e ) ; } return b out . to byte array ( ) ; }	decode the base 64 encoded input data.
public static string build selector from attribute type and value ( string attribute type , string attribute value ) { string builder strb = new string builder ( ) ; strb . append ( open bracket ) ; strb . append ( attribute type ) ; strb . append ( equal ) ; strb . append ( attribute value ) ; strb . append ( close bracket ) ; return strb . to string ( ) ; }	create a selector of the form [ $ attributetype = $ attributevalue ].
public static bitmap scale fit ( bitmap src , int max w , int max h ) { float ratio = math . min ( max w / ( float ) src . get width ( ) , max h / ( float ) src . get height ( ) ) ; int new w = ( int ) ( src . get width ( ) * ratio ) ; int new h = ( int ) ( src . get height ( ) * ratio ) ; return scale ( src , new w , new h ) ; }	scaling bitmap to fit required sizes.
public file ( string dir path , string name ) { if ( name == null ) { throw new null pointer exception ( str ) ; } if ( dir path == null || dir path . is empty ( ) ) { this . path = fix slashes ( name ) ; } else if ( name . is empty ( ) ) { this . path = fix slashes ( dir path ) ; } else { this . path = fix slashes ( join ( dir path , name ) ) ; } }	constructs a new file using the specified directory path and file name , placing a path separator between the two .
void decode attribute body ( byte [ ] attribute value , char offset , char length ) { username = new byte [ length ] ; system . arraycopy ( attribute value , offset , username , num , length ) ; }	copies the value of the username attribute from the specified attributevalue .
public static string normalize inet4 address ( string ip4 string ) { final int [ ] octets = parse inet4 address ( ip4 string ) ; if ( octets == null ) { return null ; } string builder sb = new string builder ( ) ; for ( int i = num ; i < num ; i ++ ) { if ( i > num ) { sb . append ( str ) ; } sb . append ( octets [ i ] ) ; } return sb . to string ( ) ; }	normalize a string representing an ipv4 address to the canonical representation with four decimal octets ( d.
public static int [ ] shuffle ( int [ ] input ) { list < integer > vals = new array list < integer > ( input . length ) ; for ( int i = num ; i < input . length ; i ++ ) vals . add ( input [ i ] ) ; collections . shuffle ( vals , seeded random ) ; int [ ] copy = new int [ input . length ] ; for ( int i = num ; i < input . length ; i ++ ) copy [ i ] = vals . get ( i ) ; return copy ; }	weirdly java doesn ' t seem to have arrays.
public boolean offer ( pooled connection pooled connection ) { acquired connections . remove ( pooled connection ) ; boolean offer = queue . offer ( pooled connection ) ; if ( ! offer ) { pooled connection . dispose ( ) ; } if ( is terminating . get ( ) ) { pooled connection poll = queue . poll ( ) ; if ( poll != null ) { poll . dispose ( ) ; } } return offer ; }	offer a connections back to the queue.
private int parse style in default workspace ( rest reader , int count , list < style wrapper > style list ) { rest geo server style list = reader . get styles ( ) ; for ( string style : geo server style list . get names ( ) ) { style wrapper new style wrapper = new style wrapper ( default workspace name , style ) ; style list . add ( new style wrapper ) ; if ( parent obj != null ) { parent obj . read styles progress ( connection , count , count ) ; } count ++ ; } return count ; }	parses the style in default workspace .
private class signature load class from jigsaw ( string classname ) throws io { if ( method get module == null || method get name == null ) { return null ; } final class < ? > clazz ; final string module name ; try { clazz = class . for name ( classname , bool , loader ) ; final object module = method get module . invoke ( clazz ) ; module name = ( string ) method get name . invoke ( module ) ; } catch ( exception e ) { return null ; } return new class signature ( clazz , asm utils . is runtime module ( module name ) ) ; }	loads the bytecode from java9 ' s module system.
public void test connect ant ( ) { if ( ! run test ) { log . d ( tag , big test utils . disable message ) ; return ; } use ant ( ) ; assert true ( check sensors status not recording ( ) ) ; check ant ( r . id . sensor state cadence ) ; }	tests connecting to a cadence ant + sensor .
@ override public boolean equals ( object obj ) { if ( this == obj ) { return bool ; } if ( obj == null ) { return bool ; } if ( get class ( ) != obj . get class ( ) ) { return bool ; } diff other = ( diff ) obj ; if ( operation != other . operation ) { return bool ; } if ( text == null ) { if ( other . text != null ) { return bool ; } } else if ( ! text . equals ( other . text ) ) { return bool ; } return bool ; }	is this diff equivalent to another diff ?.
public void clear attribute specs ( ) { if ( m attribute specs == null ) { m attribute specs = new array list < attribute spec > ( ) ; } m attribute specs . clear ( ) ; }	clear the list of attribute specifications.
public void load properties ( boolean silent ) { load properties file ( system . get property ( properties file , str ) , silent ) ; initialize properties ( ) ; }	load and initialize a properties file from the default path.
@ override public void start ( ) { try { journal client endpoint endpoint = connect ( ) ; if ( endpoint != null ) { output stream os ; os = os = endpoint . start message ( ) ; if ( os != null ) { os . write ( str ) ; } } } catch ( exception e ) { log . finer ( e . to string ( ) ) ; } }	start a journalled message .
static private int read bytes ( int c [ ] , int len , input stream is ) throws io { byte buf [ ] = new byte [ len ] ; if ( is . read ( buf , num , len ) < len ) { return - num ; } for ( int i = num ; i < len ; i ++ ) { c [ i ] = buf [ i ] & num ; } return num ; }	tries to read the specified number of bytes from the stream returns - 1 , if eof is reached before len bytes are read , returns 0 otherwise.
public static void sort ( object [ ] array ) { if ( array . length > num ) { arrays . sort ( array , instance ) ; } }	sort the given array with a default ordercomparator.
public static int expected size of probability table ( random variable ... vars ) { int expected size of distribution = num ; if ( null != vars ) { for ( random variable rv : vars ) { if ( ! ( rv . get domain ( ) instanceof finite domain ) ) { throw new illegal argument exception ( str + rv ) ; } finite domain d = ( finite domain ) rv . get domain ( ) ; expected size of distribution *= d . size ( ) ; } } return expected size of distribution ; }	calculated the expected size of a probabilitytable for the provided random variables .
native private static void initialize ( string application id ) ;	com initialization should be invoked once per process.
public network connectivity listener ( ) { m state = state . unknown ; }	create a new networkconnectivitylistener .
vector process simplepatternlist ( stylesheet handler handler , string uri , string name , string raw name , string value , elem template element owner ) throws org . xml . sax . sax { try { string tokenizer tokenizer = new string tokenizer ( value , str ) ; int n patterns = tokenizer . count tokens ( ) ; vector patterns = new vector ( n patterns ) ; for ( int i = num ; i < n patterns ; i ++ ) { x pattern = handler . create match pattern x ( tokenizer . next token ( ) , owner ) ; patterns . add element ( pattern ) ; } return patterns ; } catch ( transformer exception te ) { throw new org . xml . sax . sax ( te ) ; } }	process an attribute string of type t_simplepatternlist into a vector of xpath match patterns .
public void add copy ( i copy , copy arguments arguments ) { if ( f copy == null ) { f copy = new array list ( num ) ; f copy arguments = new array list ( num ) ; } f copy . add ( copy ) ; f copy arguments . add ( arguments ) ; add copy delta ( copy , arguments ) ; }	adds the given resource to the list of resources to be copied .
public void insert trace ( polyline p polyline , int p layer , int p half width , net nos list p net no arr , int p clearance class , item fix state p fixed state ) { brd tracep new trace = insert trace without cleaning ( p polyline , p layer , p half width , p net no arr , p clearance class , p fixed state ) ; if ( new trace == null ) return ; new trace . normalize ( changed area . get area ( p layer ) ) ; }	inserts a trace into the board , whose geometry is described by a polyline.
void send transmit ( multiplex connection info info , byte buf [ ] , int off , int len ) throws io { synchronized ( data out ) { if ( alive && ! info . closed ) try { data out . write byte ( transmit ) ; data out . write short ( info . id ) ; data out . write int ( len ) ; data out . write ( buf , off , len ) ; data out . flush ( ) ; } catch ( io e ) { multiplex log . log ( log . brief , str , e ) ; shut down ( ) ; throw e ; } } }	send packet of requested data on connection to remote endpoint .
public < t extends sql > t to flat sql ( class < t > type ) throws class cast exception { return type . cast ( to flat sql ( ) ) ; }	converts the builder to the appropriate sqlexception instance and casts to the specified type t .
public void add total result count cookie ( workbench request req , http servlet response resp , int value ) { add cookie ( req , resp , str , string . value of ( value ) ) ; }	add a ' total_result_count ' cookie.
abstract void start poll ( int fd , int events ) ;	register file descriptor with polling mechanism for given events.
private rectangle integerise ( d rect ) { int x0 = ( int ) math . ceil ( rect . get min x ( ) ) ; int y0 = ( int ) math . ceil ( rect . get min y ( ) ) ; int x1 = ( int ) math . floor ( rect . get max x ( ) ) ; int y1 = ( int ) math . floor ( rect . get max y ( ) ) ; return new rectangle ( x0 , y0 , ( x1 - x0 ) , ( y1 - y0 ) ) ; }	trims a rectangle to integer coordinates .
@ override public void mouse moved ( mouse event evt ) { delegate . mouse moved ( evt ) ; }	pass mouseevent straight through to delegate.
protected void validate config ( ) { a . not null ( get streamer ( ) , str ) ; a . not null ( get ignite ( ) , str ) ; a . not null ( endpoint url , str ) ; a . ensure ( get single tuple extractor ( ) != null || get multiple tuple extractor ( ) != null , str ) ; string follow param = api params . get ( site user id key ) ; a . ensure ( follow param != null && follow param . matches ( str ) , str ) ; }	validates config at start .
public long [ ] select zero ( long rank , long [ ] dest , final int offset , final int length ) { if ( length == num ) return dest ; long s = select zero ( rank ) ; dest [ offset ] = s ; int curr = ( int ) ( s / long . size ) ; long window = ~ bits [ curr ] & - num << s ; window &= window - num ; for ( int i = num ; i < length ; i ++ ) { while ( window == num ) window = ~ bits [ ++ curr ] ; dest [ offset + i ] = curr * long . size + long . number of trailing zeros ( window ) ; window &= window - num ; } return dest ; }	performs a bulk select of consecutive ranks into a given array fragment .
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return string field ; case num : return set field ; case num : return list field ; case num : return binary field ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public int size ( ) { synchronized ( children ) { return children . size ( ) ; } }	gets the number of children currently nested in this beancontext .
private string flatten comment ( string string ) { string buffer buffer = new string buffer ( string . length ( ) + num ) ; boolean skip adjacent line separator = bool ; for ( int i = num ; i < string . length ( ) ; i ++ ) { char c = string . char at ( i ) ; if ( c == str || c == str ) { if ( ! skip adjacent line separator ) buffer . append ( policy . bind ( str ) ) ; skip adjacent line separator = bool ; } else { buffer . append ( c ) ; skip adjacent line separator = bool ; } } return buffer . to string ( ) ; }	flatten the given string so it contains no more line breaks.
private boolean is accelerating ( sensor event event ) { float ax = event . values [ num ] ; float ay = event . values [ num ] ; float az = event . values [ num ] ; final double magnitude = math . sqrt ( ax * ax + ay * ay + az * az ) ; return magnitude > acceleration threshold ; }	returns true if the device is currently accelerating .
@ override public byte [ ] read byte array ( string file path , int length ) { file channel file channel = update cache ( file path ) ; byte buffer byte bffer = read ( file channel , length ) ; return byte bffer . array ( ) ; }	this method will be used to read the byte array from file based on length ( number of bytes ).
public void pop drag entry ( int index ) { if ( is index in bound ( index ) ) { m dragged entry = m drag entries . get ( index ) ; m dragged entry index = index ; m drag entered entry index = index ; mark drop area ( index ) ; } }	temporarily removes a contact from the list for ui refresh.
public void test load and verify small quads mode ( ) throws exception { final string resource = str ; final properties p = get properties ( ) ; p . set property ( abstract triple store . options . quads , str ) ; do load and verify test ( resource , p ) ; }	test with the " small.
public void add email ( email entity email ) { emails . add ( email ) ; }	adds a new email to this user.
private static int manhattan distance ( final int x1 , final int y1 , final int x2 , final int y2 ) { return math . abs ( x1 - x2 ) + math . abs ( y1 - y2 ) ; }	calculates the manhattan distance between to positions .
public void put grammar ( schema grammar grammar ) { if ( grammar . get target namespace ( ) == null ) f no ns = grammar ; else f grammar registry . put ( grammar . get target namespace ( ) , grammar ) ; }	put a schema grammar into the registry this method is for internal use only : it assumes that a grammar with the same target namespace is not already in the bucket .
public json opt json ( string key ) { object o = opt ( key ) ; return o instanceof json ? ( json ) o : null ; }	get an optional jsonarray associated with a key.
private void status ( ) { ps . println ( str ) ; ps . println ( str ) ; ps . println ( str ) ; ps . println ( str ) ; write keys with prefix ( str , str ) ; }	writes the status help.
void push import source ( source source from uri ) { m import source stack . push ( source from uri ) ; }	push the source of an import href onto the stylesheet stack , obtained from a uriresolver , null if there is no uriresolver , or if that resolver returned null .
public static byte [ ] build nal unit ( byte [ ] data , int offset , int length ) { byte [ ] nal unit = new byte [ length + nal start code . length ] ; system . arraycopy ( nal start code , num , nal unit , num , nal start code . length ) ; system . arraycopy ( data , offset , nal unit , nal start code . length , length ) ; return nal unit ; }	constructs a nal unit consisting of the nal start code followed by the specified data .
protected void do log oob message outbound ( message message ) { if ( rpc logger != null ) { rpc logger . log oob message ( client info , server info , message , system . current time millis ( ) ) ; } }	logger all information about an outbound oobmessage .
@ override public void stop ( ) { count down latch latch = stopped ; thread old thread = thread . get and update ( null ) ; if ( old thread != null && latch != null ) { try { latch . await ( num , time unit . seconds ) ; } catch ( interrupted exception e ) { thread . interrupted ( ) ; } } }	stop this executor from executing , and block until the thread has completed all work ( or until the timeout has occurred ).
@ override public byte [ ] encode ( buffered image buffered image ) throws io { byte array output stream output stream = new byte array output stream ( ) ; encode ( buffered image , output stream ) ; return output stream . to byte array ( ) ; }	encodes an image in png format .
private json parser exception create helpful exception ( char first , char [ ] expected , int failure position ) throws json parser exception { string builder error token = new string builder ( first + ( expected == null ? str : new string ( expected , num , failure position ) ) ) ; while ( is ascii letter ( peek char ( ) ) && error token . length ( ) < num ) error token . append ( ( char ) advance char ( ) ) ; return create parse exception ( null , str + error token + str + ( expected == null ? str : str + first + new string ( expected ) + str ) , bool ) ; }	throws a helpful exception based on the current alphanumeric token .
public void test constructor bytes positive3 ( ) { byte a bytes [ ] = { num , num , num , - num } ; byte r bytes [ ] = { num , num , num , - num } ; big integer a number = new big integer ( a bytes ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = a number . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , a number . signum ( ) ) ; }	create a positive number from an array of bytes.
public static void i ( string tag , string s , object ... args ) { if ( log . info >= loglevel ) log . i ( tag , string . format ( s , args ) ) ; }	info log message with printf formatting .
public void remove lifecycle listener ( lifecycle listener lifecycle listener ) { lifecycle listeners . remove ( lifecycle listener ) ; }	removes a previously added lifecycle listener.
private synchronized void init registry ( boolean force ) throws matlab connection exception { if ( registry == null || force ) { try { registry = rmi . create registry ( options . get port ( ) ) ; } catch ( exception e ) { try { registry = rmi . get registry ( options . get port ( ) ) ; } catch ( exception ex ) { throw new matlab connection exception ( str , ex ) ; } } } }	initializes the registry if it has not already been set up .
public boolean phase has turns ( i . phase this phase ) { switch ( this phase ) { case phase set artyautohithexes : case phase deploy minefields : case phase deployment : case phase movement : case phase firing : case phase physical : case phase targeting : case phase offboard : return bool ; default : return bool ; } }	returns true if this phase has turns.
public int read ( ) throws io { int ch1 = is . read ( ) ; int ch2 = is . read ( ) ; if ( ch2 < num ) return - num ; return ( ch2 << num ) + ch1 ; }	reads into a character buffer using the correct encoding .
public static boolean is url ( string resource location ) { if ( resource location == null ) { return bool ; } if ( resource location . starts with ( classpath url prefix ) ) { return bool ; } try { new url ( resource location ) ; return bool ; } catch ( url ex ) { return bool ; } }	return whether the given resource location is a url : either a special " classpath " pseudo url or a standard url .
public static string encode url ( string uri ) { char buffer cb = char buffer . allocate ( ) ; for ( int i = num ; i < uri . length ( ) ; i ++ ) { char ch = uri . char at ( i ) ; switch ( ch ) { case str : case str : case str : case str : case str : case str : cb . append ( str ) ; cb . append ( encode hex ( ch > > num ) ) ; cb . append ( encode hex ( ch ) ) ; break ; default : cb . append ( ch ) ; } } return cb . close ( ) ; }	encode the url with ' % ' encoding .
public void close ( ) throws io { if ( closed ) { return ; } if ( queued for cleanup ) { return ; } try { if ( expected > count ) { long nskip = expected - count ; if ( nskip <= available ( ) ) { do { } while ( ( nskip = ( expected - count ) ) > num && skip ( math . min ( nskip , available ( ) ) ) > num ) ; } else if ( expected <= keep alive stream cleaner . max data remaining && ! hurried ) { queue for cleanup ( new keep alive cleaner entry ( this , hc ) ) ; } else { hc . close server ( ) ; } } if ( ! closed && ! hurried && ! queued for cleanup ) { hc . finished ( ) ; } } finally { if ( pi != null ) pi . finish tracking ( ) ; if ( ! queued for cleanup ) { in = null ; hc = null ; closed = bool ; } } }	attempt to cache this connection.
public boolean is public ( ) { return modifier . is public ( method . get modifiers ( ) ) ; }	returns true for a public method .
private object [ ] initialize caller hierarchy roots ( map < string , map < string , set < json element > > > caller map ) { list < tree element < source method node , source method node > > roots = new array list < tree element < source method node , source method node > > ( ) ; caller hierarchy caller hierarchy = ( caller hierarchy ) f input ; source method node root node = caller hierarchy . get root ( ) ; set < source method node > processed nodes = new hash set < source method node > ( ) ; tree element < source method node , source method node > root = initialize caller hierarchy ( root node , processed nodes , caller map ) ; return new object [ ] { root } ; }	creates tree elements for the caller hierarchy outline view.
private list < entry > reduce with douglas peuker ( list < entry > entries , double epsilon ) { if ( epsilon <= num || entries . size ( ) < num ) { return entries ; } keep [ num ] = bool ; keep [ entries . size ( ) - num ] = bool ; algorithm douglas peucker ( entries , epsilon , num , entries . size ( ) - num ) ; list < entry > reduced entries = new array list < entry > ( ) ; for ( int i = num ; i < entries . size ( ) ; i ++ ) { if ( keep [ i ] ) { entry cur entry = entries . get ( i ) ; reduced entries . add ( new entry ( cur entry . get val ( ) , cur entry . get x ( ) ) ) ; } } return reduced entries ; }	uses the douglas peuker algorithm to reduce the given list of entries.
public static double [ ] compute log amplitude spectrum ( final double [ ] signal ) { double [ ] spectrum = compute amplitude spectrum ( signal ) ; for ( int i = num ; i < spectrum . length ; i ++ ) { spectrum [ i ] = math . log ( spectrum [ i ] ) ; } return spectrum ; }	convenience method for computing the log amplitude spectrum of a real signal.
private segment create memory segment ( segment descriptor descriptor ) { file segment file = segment file . create segment file ( name , storage . directory ( ) , descriptor . id ( ) , descriptor . version ( ) ) ; buffer buffer = heap buffer . allocate ( math . min ( default buffer size , descriptor . max segment size ( ) ) , integer . max value ) ; descriptor . copy to ( buffer ) ; segment segment = new segment ( new segment file ( segment file ) , buffer . slice ( ) , descriptor , create index ( descriptor ) , new offset predicate ( ) , serializer . clone ( ) , this ) ; logger . debug ( str , segment ) ; return segment ; }	creates a new segment .
public static void init ( final async context context ) { final security context security = ( security context ) context . get attribute ( async context . security ctx ) ; final boolean force set security = force set security context ( context ) ; if ( force set security ) { security context holder . set context ( security ) ; } ctx . set ( context ) ; }	initialise security context from async context.
private void cancel previous web rtc notifications ( ) { set < string > notification ids = m shared preferences . get string set ( webrtc notification ids , null ) ; if ( notification ids == null ) return ; iterator < string > iterator = notification ids . iterator ( ) ; while ( iterator . has next ( ) ) { m notification manager . cancel ( notification namespace , integer . parse int ( iterator . next ( ) ) ) ; } shared preferences . editor shared preference editor = m shared preferences . edit ( ) ; shared preference editor . remove ( media capture notification service . webrtc notification ids ) ; shared preference editor . apply ( ) ; }	cancel all previously existing notifications.
public static final string read string ( byte [ ] bytes , int offset , int length , string charset ) throws io { return read string ( bytes , num , bytes . length , charset . for name ( charset ) ) ; }	convert a byte array to a string ; consistently uses \ n line endings in java.
private topology updater thread ( ) { super ( id + str ) ; }	creates topology refresh thread .
private void type parameters rest ( list < ? extends type parameter tree > type parameters , indent plus indent ) { builder . open ( plus indent ) ; builder . break op ( ) ; builder . open ( zero ) ; boolean first = bool ; for ( type parameter tree type parameter : type parameters ) { if ( ! first ) { token ( str ) ; builder . break op ( str ) ; } scan ( type parameter , null ) ; first = bool ; } token ( str ) ; builder . close ( ) ; builder . close ( ) ; }	does not omit the leading ' < ' , which should be associated with the type name .
public void write string ( string str ) throws io { if ( str == null ) write int ( num ) ; else { if ( use compression && str . length ( ) >= compressor . min size for deflation ) { byte [ ] bytes = compressor . deflate string2 byte array ( str ) ; write int ( - bytes . length ) ; outs . write ( bytes , num , bytes . length ) ; position += bytes . length ; } else { byte [ ] bytes = str . get bytes ( str ) ; write int ( bytes . length ) ; outs . write ( bytes , num , bytes . length ) ; position += bytes . length ; } } }	write a string , compressed , if long enough.
public void dequeue sound ( uri uri ) { m audio queue . remove ( new audio queue item ( uri , null ) ) ; }	removes the first instance of a sound from the audio queue .
public void remove bookmark ( final c bookmark ) { preconditions . check not null ( bookmark , str ) ; preconditions . check argument ( m bookmarks . remove ( bookmark ) , str ) ; for ( final i listener : m listeners ) { try { listener . removed bookmark ( this , bookmark ) ; } catch ( final exception exception ) { c . log exception ( exception ) ; } } }	removes the bookmark at the given index .
public static key store load key store ( string type , file file , char [ ] password ) throws exception { key store key store = key store . get instance ( type ) ; try ( file input stream fis = new file input stream ( file ) ) { key store . load ( fis , password ) ; } return key store ; }	loads a key store from a file .
public void loop ( double ellapsed millis ) { for ( spring system listener listener : m listeners ) { listener . on before integrate ( this ) ; } advance ( ellapsed millis ) ; if ( m active springs . is empty ( ) ) { m idle = bool ; } for ( spring system listener listener : m listeners ) { listener . on after integrate ( this ) ; } if ( m idle ) { m spring looper . stop ( ) ; } }	loop the system until idle.
private void update recording track ( track track , long last track point id , boolean increase number of points ) { if ( last track point id >= num ) { if ( track . get start id ( ) < num ) { track . set start id ( last track point id ) ; } track . set stop id ( last track point id ) ; } if ( increase number of points ) { track . set number of points ( track . get number of points ( ) + num ) ; } track trip statistics updater . update time ( system . current time millis ( ) ) ; track . set trip statistics ( track trip statistics updater . get trip statistics ( ) ) ; my tracks provider utils . update track ( track ) ; }	updates the recording track time.
@ override public void request startup updates ( string from , byte [ ] table key , int pod index , long delta time , result < boolean > cont ) { if ( log . is loggable ( level . finest ) ) { log . finest ( str + from + str + pod index + str + delta time ) ; } long access time = current time . current time ( ) + delta time ; table pod table pod = client kraken . get table ( table key ) ; if ( table pod == null ) { if ( log . is loggable ( level . finest ) ) { log . finest ( l . l ( str , hex . to short hex ( table key ) , bartender system . get current self server ( ) ) ) ; } cont . ok ( bool ) ; return ; } table pod . get updates from local ( pod index , access time , cont ) ; }	asks for updates from the message.
private void refresh mute video button ( ) { if ( ( null != m call ) && m call . is video ( ) ) { m mute local camera view . set visibility ( view . visible ) ; boolean is muted = m call . is video recording muted ( ) ; log . d ( log tag , str + is muted ) ; int icon id = is muted ? r . drawable . ic material videocam off pink red : r . drawable . ic material videocam off grey ; m mute local camera view . set image resource ( icon id ) ; } else { log . d ( log tag , str ) ; m mute local camera view . set visibility ( view . invisible ) ; } }	update the mute video icon .
public boolean is auto update trl ( string table name ) { if ( super . is multi lingual document ( ) ) return bool ; if ( table name == null ) return bool ; if ( table name . starts with ( str ) && get ad id ( ) == num ) return bool ; return bool ; }	update trl tables automatically ?.
private void create preference controls ( composite parent , set < preference id > preference set , input definition input definition ) { for ( preference id preference id enum : preference set ) { i preference control = preference control factory . create preference controls ( parent , toolkit , preference id enum , this , input definition ) ; if ( null != preference control ) { preference control list . add ( preference control ) ; } } }	creates the preference controls in the preference control panel .
@ request mapping ( value = str , method = post , produces = application json value ) public response entity < page response < dto > > find all ( @ request body page request by example < dto > prbe ) throws uri { page response < dto > page response = project dto . find all ( prbe ) ; return new response entity < > ( page response , new http headers ( ) , http status . ok ) ; }	find a page of project using query by example .
public void test sha ( ) { message digest md = null ; try { md = message digest . get instance ( str ) ; } catch ( no such algorithm exception e ) { fail ( str + e ) ; } byte [ ] bytes = new byte [ ] { num , num , num , num , num } ; try { md . update ( bytes , - num , num ) ; fail ( str ) ; } catch ( index out of bounds exception e ) { } try { md . update ( bytes , num , - num ) ; fail ( str ) ; } catch ( index out of bounds exception e ) { } try { md = message digest . get instance ( str ) ; } catch ( no such algorithm exception e ) { fail ( str + e ) ; } try { md . digest ( bytes , num , - num ) ; fail ( str ) ; } catch ( digest exception e ) { } try { md . digest ( bytes , - num , num ) ; fail ( str ) ; } catch ( digest exception e ) { } try { md = message digest . get instance ( str ) ; fail ( str ) ; } catch ( no such algorithm exception e ) { } }	tests sha messagedigest provider.
static private double fac2 ( int j ) { long i = j ; if ( j < num ) i = math . abs ( j ) ; double d = num ; while ( i > num ) d *= i -- ; if ( j < num ) return - d ; else return d ; }	returns the factorial of the argument .
private static boolean is input exhausted ( stream tokenizer input ) throws parse error { try { if ( input . next token ( ) == stream tokenizer . tt eof ) { return bool ; } input . push back ( ) ; return bool ; } catch ( io e ) { throw new parse error ( e . get message ( ) ) ; } }	determines if the input is exhausted .
public void clear ( ) { m . clear ( ) ; }	removes all of the elements from this set .
public static void write unsafe ( packet output stream out , input stream is , long length , boolean no backslash escapes ) throws io { out . write unsafe ( quote ) ; byte [ ] buffer = new byte [ num ] ; long bytes left = length ; int len ; for ( ; ; ) { int bytes to read = ( int ) math . min ( bytes left , buffer . length ) ; if ( bytes to read == num ) { break ; } len = is . read ( buffer , num , bytes to read ) ; if ( len <= num ) { break ; } write bytes escaped unsafe ( out , buffer , len , no backslash escapes ) ; bytes left -= len ; } out . write unsafe ( quote ) ; }	write stream in text format without checking buffer size .
public sql ( class < t > type , string sql expression , query result type query result type ) { this ( sql expression , type . get name ( ) , null , query result type , null ) ; }	creates a sqlquery using the specified type , expression and result type .
public builder retry ( long duration , time unit time unit ) { this . retry = time unit . to seconds ( duration ) ; return this ; }	set the period after which , if no ack is received , the job is put again into the queue for delivery.
private record buffer < r > try take ( long elapsed waiting ) { record buffer < r > result = null ; if ( ! retry queue . is empty ( ) ) { result = retry queue . poll ( ) ; } else { result = never pub queue . poll ( ) ; } if ( result != null ) { return on take success ( result , elapsed waiting ) ; } else if ( elapsed waiting > num ) { return on take timeout ( elapsed waiting ) ; } else return null ; }	keep private . call only when holding lock .
public void test constructor bytes negative1 ( ) { byte a bytes [ ] = { - num , num , num , - num , - num , num , num , num , num , - num , num , num , num , num } ; byte r bytes [ ] = { - num , num , num , - num , - num , num , num , num , num , - num , num , num , num , num } ; big integer a number = new big integer ( a bytes ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = a number . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , a number . signum ( ) ) ; }	create a negative number from an array of bytes.
private < t > list < t > to sorted list ( t [ ] array , comparator < t > comparator ) { list < t > list = new array list < > ( ) ; collections . add all ( list , array ) ; collections . sort ( list , comparator ) ; return list ; }	creates a sorted list from an array of elements using the given classcomparator .
private geo mark reverse geocode ( final string text ) { for ( string t : text . split ( str ) ) { if ( t . length ( ) < num ) continue ; string [ ] c = t . split ( str ) ; if ( c . length != num ) continue ; try { double lat = double . parse double ( c [ num ] ) ; double lon = double . parse double ( c [ num ] ) ; geo mark mark = city near ( lat , lon ) ; if ( mark == null ) continue ; return mark ; } catch ( number format exception e ) { continue ; } } return null ; }	find the geolocation for coordinates in a text.
public array list < pla touple int > entrance points ( polyline p polyline ) { array list < pla touple int > result = new array list < pla touple int > ( num * p polyline . plaline len ( ) ) ; int prev intersection line no = - num ; int prev intersection edge no = - num ; for ( int line no = num ; line no < p polyline . plaline len ( - num ) ; ++ line no ) { pla segment int curr line seg = p polyline . segment get ( line no ) ; int [ ] curr intersections = curr line seg . border intersections ( this ) ; for ( int index = num ; index < curr intersections . length ; ++ index ) { int edge no = curr intersections [ index ] ; if ( line no != prev intersection line no || edge no != prev intersection edge no ) { result . add ( new pla touple int ( line no , edge no ) ) ; prev intersection line no = line no ; prev intersection edge no = edge no ; } } } return result ; }	returns an arry of tuples of integers.
public static byte [ ] serialize as byte array ( object b ) throws io { byte array output stream bos = new byte array output stream ( ) ; object output stream out = new object output stream ( bos ) ; try { out . write object ( b ) ; } finally { out . close ( ) ; } return bos . to byte array ( ) ; }	serialize an object as a raw byte array.
public static void put int le ( long addr , int val ) { if ( unaligned ) unsafe . put int ( addr , integer . reverse bytes ( val ) ) ; else put int by byte ( addr , val , bool ) ; }	stores given integer value assuming that value should be stored in little - endian byte order and native byte order is big - endian.
public floating action button create sub fab ( char icon , string text ) { floating action button sub = new floating action button ( icon , text , num ) ; if ( sub menu == null ) { sub menu = new array list < floating action button > ( ) ; } sub menu . add ( sub ) ; return sub ; }	adds a sub fab to the floatingactionbutton instance.
public string read value ( input node from ) throws exception { if ( ! stack . is relevant ( from ) ) { return null ; } int length = text . length ( ) ; if ( length <= num ) { event node event = reader . peek ( ) ; if ( event . is end ( ) ) { if ( stack . top ( ) == from ) { return null ; } else { stack . pop ( ) ; } event = reader . next ( ) ; } } return read text ( from ) ; }	read the contents of the characters between the specified xml element tags , if the read is currently at that element.
private void dispatch on third party registered ( ) { synchronized ( this ) { for ( third party registration listener listener : m third party registration listeners ) { try { listener . on third party registered ( ) ; } catch ( exception e ) { log . e ( log tag , str + e . get localized message ( ) ) ; } } m third party registration listeners . clear ( ) ; } }	dispatch the onthirdpartyregistered to the listeners .
void update for decoder type id ( list < decoder file > p list ) { decoder box . set model ( decoder index file . j combo box model from list ( p list ) ) ; decoder box . insert item at ( str , num ) ; decoder box . set selected index ( num ) ; }	decoder identify has matched one or more specific types.
@ override public void action performed ( action event event ) { switch ( event . get action command ( ) ) { case new alias : add alias ( new alias ( str ) ) ; break ; case copy alias : for ( alias alias : get selected aliases ( ) ) { add alias ( alias factory . copy of ( alias ) ) ; } break ; case delete alias : list < alias > to delete = get selected aliases ( ) ; if ( to delete != null && ! to delete . is empty ( ) ) { string title = to delete . size ( ) == num ? str : str ; string prompt = to delete . size ( ) == num ? str : str + to delete . size ( ) + str ; int choice = j . show confirm dialog ( alias controller . this , prompt , title , j . yes no option , j . warning message ) ; if ( choice == j . yes option ) { for ( alias alias : to delete ) { m alias model . remove alias ( alias ) ; } } } break ; default : break ; } }	responds to new , copy and delete channel button invocations.
public boolean direction key is pressed ( ) { return pressed state keys . contains ( key event . vk up ) || pressed state keys . contains ( key event . vk down ) || pressed state keys . contains ( key event . vk left ) || pressed state keys . contains ( key event . vk right ) || pressed state keys . contains ( key event . vk kp left ) || pressed state keys . contains ( key event . vk kp right ) || pressed state keys . contains ( key event . vk kp up ) || pressed state keys . contains ( key event . vk kp down ) ; }	check if any direction key is in " pressed " state .
public void add position ( int offset , int length , string ... ids ) { text attribute highlighting = ids . length == num ? attribute provider . get attribute ( ids [ num ] ) : attribute provider . get merged attributes ( ids ) ; boolean is existing = bool ; for ( int i = num , n = removed positions . size ( ) ; i < n ; i ++ ) { attributed position position = removed positions . get ( i ) ; if ( position == null ) continue ; if ( position . is equal ( offset , length , highlighting ) ) { is existing = bool ; removed positions . set ( i , null ) ; removed position count -- ; break ; } } if ( ! is existing ) { attributed position position = presenter . create highlighted position ( offset , length , highlighting ) ; added positions . add ( position ) ; } }	add a position with the given range and highlighting if it does not exist already .
static void export mask update ( export mask export mask , map < uri , integer > volume map , list < initiator > initiators , list < uri > targets ) { if ( volume map != null ) { for ( uri volume : volume map . key set ( ) ) { export mask . add volume ( volume , volume map . get ( volume ) ) ; } } if ( initiators != null ) { for ( initiator initiator : initiators ) { export mask . add initiator ( initiator ) ; } } if ( targets != null ) { for ( uri target : targets ) { export mask . add target ( target ) ; } } }	adds the volumes , initiators , and targets to an exportmask .
private void internal add head ( final message reference ref ) { queue memory size . add and get ( ref . get message memory estimate ( ) ) ; ref added ( ref ) ; int priority = get priority ( ref ) ; message references . add head ( ref , priority ) ; }	the caller of this method requires synchronized on the queue.
private boolean create new ( m product , m as ) { m dimension = m . get or create ( product , num , as , num , num , as . get m id ( ) , m ce . get m id ( ) ) ; if ( dimension . is new ( ) ) return dimension . save ( ) ; return bool ; }	create new client level costing record.
@ override protected void step ( ) { while ( iter . has next ( ) ) { reg = ( svc reg ) iter . next ( ) ; if ( reg . lease expiration > now ) return ; } reg = null ; }	set reg to the next matching element , or null if none.
public enumeration < string > packages ( ) { return m . keys ( ) ; }	returns all the stored packages .
protected int size ( ) { return document . length ( ) ; }	returns the number of bytes of the document .
public tps current row ( ) { return current row ( null ) ; }	filters for the current row ( most recent bindings ).
public final void delete all entries ( ) { if ( num entries > num ) { arrays . fill ( entries , null ) ; this . num entries = num ; } }	deletes all entries in this node .
public list < map < string , object > > query ( final string index name , final string q , final operator operator , final int offset , final int count ) { assert count > num ; search request builder request = elasticsearch client . prepare search ( index name ) . set query ( query builders . multi match query ( q , str ) . operator ( operator ) . zero terms query ( zero terms query . all ) ) . set from ( offset ) . set size ( count ) ; search response response = request . execute ( ) . action get ( ) ; search hit [ ] hits = response . get hits ( ) . get hits ( ) ; array list < map < string , object > > result = new array list < map < string , object > > ( ) ; for ( search hit hit : hits ) { map < string , object > map = hit . get source ( ) ; result . add ( map ) ; } return result ; }	query with a string and boundaries.
public sorted set < string > plugins ( ) { sorted set < string > r = new tree set < > ( ) ; for ( name pair p : items . key set ( ) ) { r . add ( p . plugin name ) ; } return collections . unmodifiable sorted set ( r ) ; }	get the names of all running plugins supplying this type .
public static void error ( int window no , container c , string ad ) { error ( window no , c , ad , null ) ; }	display error with error icon.
public reil function translate ( final i environment , final i < instruction type > function ) throws internal translation exception { return translate ( environment , function , new array list < i < instruction type > > ( ) ) ; }	translates a disassembled function to reil code .
public name parse ( string name ) throws naming exception { vector < string > comps = ins string to stringified comps ( name ) ; return new cn ( comps . elements ( ) ) ; }	returns a compoundname given a string in ins syntax .
public csv ( ) { super ( str , csv mime types , csv file endings , csv . csv format specification step id ) ; }	constructs a new factory instance .
private void send ack ( string index , string message , guacamole status status ) { if ( status != guacamole status . success ) close intercepted stream ( index ) ; send instruction ( new guacamole instruction ( str , index , message , integer . to string ( status . get guacamole status code ( ) ) ) ) ; }	injects an " ack " instruction into the outbound guacamole protocol stream , as if sent by the connected client.
public static boolean is windows platform ( ) { string os = system . get property ( str ) ; return ( os != null && os . starts with ( win id ) ) ; }	try to determine whether this application is running under windows or some other platform by examing the " os.
static public int count ranges that collide zone ( list < bounds > ranges , list < bounds > zone ranges ) { int overall eoaa = num ; collections . sort ( zone ranges ) ; for ( bounds extracted bounds : ranges ) { for ( bounds expected bounds : zone ranges ) { if ( expected bounds . start >= extracted bounds . end ) { break ; } if ( extracted bounds . overlaps ( expected bounds ) ) { overall eoaa ++ ; break ; } } } return overall eoaa ; }	counts the number of checkedranges that overlaps with the zoneranges.
public static boolean time stamp changed ( string location ) { synchronized ( install lock ) { if ( fg has changed . contains ( location ) ) { return bool ; } file file = new file ( location ) ; if ( file . exists ( ) ) { if ( fg install time map == null ) { read install info ( ) ; } long stamp = fg install time map . get ( location ) ; long fstamp = file . last modified ( ) ; if ( stamp != null ) { if ( stamp . long value ( ) == fstamp ) { return bool ; } } stamp = new long ( fstamp ) ; fg install time map . put ( location , stamp ) ; write install info ( ) ; fg has changed . add ( location ) ; return bool ; } } return bool ; }	checks to see if the time stamp of the file describe by the given location string has been modified since the last recorded time stamp.
public static boolean [ ] values of ( boolean [ ] array ) { boolean [ ] dest = new boolean [ array . length ] ; for ( int i = num ; i < array . length ; i ++ ) { dest [ i ] = boolean . value of ( array [ i ] ) ; } return dest ; }	converts to object array .
private void correct too high ( int child count ) { int last position = m first position + child count - num ; if ( last position == m item count - num && child count > num ) { final int last bottom = get lowest child bottom ( ) ; final int end = ( get bottom ( ) - get top ( ) ) - get list padding bottom ( ) ; int bottom offset = end - last bottom ; final int first top = get highest child top ( ) ; if ( bottom offset > num && ( m first position > num || first top < get list padding top ( ) ) ) { if ( m first position == num ) { bottom offset = math . min ( bottom offset , get list padding top ( ) - first top ) ; } offset children top and bottom ( bottom offset ) ; if ( m first position > num ) { int previous position = m first position - num ; fill up ( previous position , get next child ups bottom ( previous position ) ) ; adjust views up or down ( ) ; } } } }	check if we have dragged the bottom of the list too high ( we have pushed the top element off the top of the screen when we did not need to ).
public static boolean write line ( string file name , string value ) { buffered writer writer = null ; try { writer = new buffered writer ( new file writer ( file name ) ) ; writer . write ( value ) ; } catch ( file not found exception e ) { log . w ( tag , str + file name + str , e ) ; return bool ; } catch ( io e ) { log . e ( tag , str + file name , e ) ; return bool ; } finally { try { if ( writer != null ) { writer . close ( ) ; } } catch ( io e ) { } } return bool ; }	writes the given value into the given file.
public void did rollback ( ) { synchronized ( this ) { if ( pending != null ) { pending . cancel ( bool ) ; pending = null ; } docs since commit . set ( num ) ; } }	inform tracker that a rollback has occurred , cancel any pending commits.
@ override protected void calculate thumb location ( ) { super . calculate thumb location ( ) ; if ( slider . get snap to ticks ( ) ) { int upper value = slider . get value ( ) + slider . get extent ( ) ; int snapped value = upper value ; int major tick spacing = slider . get major tick spacing ( ) ; int minor tick spacing = slider . get minor tick spacing ( ) ; int tick spacing = num ; if ( minor tick spacing > num ) { tick spacing = minor tick spacing ; } else if ( major tick spacing > num ) { tick spacing = major tick spacing ; } if ( tick spacing != num ) { if ( ( upper value - slider . get minimum ( ) ) % tick spacing != num ) { float temp = ( float ) ( upper value - slider . get minimum ( ) ) / ( float ) tick spacing ; int which tick = math . round ( temp ) ; snapped value = slider . get minimum ( ) + ( which tick * tick spacing ) ; } if ( snapped value != upper value ) { slider . set extent ( snapped value - slider . get value ( ) ) ; } } } if ( slider . get orientation ( ) == j . horizontal ) { int upper position = x position for value ( slider . get value ( ) + slider . get extent ( ) ) ; upper thumb rect . x = upper position - ( upper thumb rect . width / num ) ; upper thumb rect . y = track rect . y ; } else { int upper position = y position for value ( slider . get value ( ) + slider . get extent ( ) ) ; upper thumb rect . x = track rect . x ; upper thumb rect . y = upper position - ( upper thumb rect . height / num ) ; } }	updates the locations for both thumbs .
public void compile ( int through phase ) throws compilation failed exception { goto phase ( phases . initialization ) ; through phase = math . min ( through phase , phases . all ) ; while ( through phase >= phase && phase <= phases . all ) { if ( phase == phases . semantic analysis ) { do phase operation ( resolve ) ; if ( dequeued ( ) ) continue ; } process phase operations ( phase ) ; process new phase operations ( phase ) ; if ( progress callback != null ) progress callback . call ( this , phase ) ; complete phase ( ) ; apply to source units ( mark ) ; if ( dequeued ( ) ) continue ; goto phase ( phase + num ) ; if ( phase == phases . class generation ) { sort classes ( ) ; } } error collector . fail if errors ( ) ; }	compiles the compilation unit from sources .
public string generate bearer token ( string email , string username , map < string , string > payload ) { string token = token generator . generate ( ) ; map < string , string > payload copy = payload == null ? new hash map ( ) : new hash map ( payload ) ; payload copy . put ( str , email ) ; payload copy . put ( str , username ) ; payload copy . put ( str , long . to string ( system . current time millis ( ) ) ) ; token map . put ( token , payload copy ) ; return token ; }	generate new token for given user .
public void end document ( augmentations augs ) throws xni { try { if ( f document handler != null ) { f document handler . end document ( ) ; } if ( f content handler != null ) { f content handler . end document ( ) ; } } catch ( sax e ) { throw new xni ( e ) ; } }	the end of the document .
public final connection state new input ( ) throws io { if ( in . has remaining ( ) ) { throw new runtime exception ( str ) ; } in . clear ( ) ; int r = ch . read ( in ) ; if ( r == - num ) throw new io ( str ) ; if ( r == num ) return connection state . selector wait for new input ; in . flip ( ) ; return new request chunk ( ) ; }	new data available for the connection .
public boolean can move forward ( ) { return current index >= num && current index < ( history . size ( ) - num ) ; }	return true if there is a previous url in the list relative to the current position .
public void clear cache ( ) { disk lru cache . clear cache ( m cache dir ) ; }	removes all disk cache entries from this instance cache dir.
public void add natural join column ( column c ) { if ( natural join columns == null ) { natural join columns = new . array list ( ) ; } natural join columns . add ( c ) ; }	add a column to the natural join key column list .
private refactoring status check can create intermediary method ( ) throws java model exception { list < i > parameter bindings = new array list < i > ( ) ; if ( ! is static target ( ) ) parameter bindings . add ( f intermediary first parameter type ) ; parameter bindings . add all ( arrays . as list ( f target method binding . get parameter types ( ) ) ) ; return checks . check method in type ( f intermediary type binding , f intermediary method name , parameter bindings . to array ( new i [ parameter bindings . size ( ) ] ) ) ; }	checks whether the target method can be created.
@ override public string generate tool tip ( xy data , int series , int item ) { return get tool tip text ( series , item ) ; }	generates a tool tip text item for a particular item within a series .
private class < ? > find class non dalvik ( string name ) throws class not found exception { string path name = class path + name + str ; file path = new file ( path name ) ; random access file raf ; try { raf = new random access file ( path , str ) ; } catch ( file not found exception fnfe ) { throw new class not found exception ( str + path name ) ; } byte [ ] file data ; try { file data = new byte [ ( int ) raf . length ( ) ] ; raf . read fully ( file data ) ; } catch ( io ioe ) { throw new class not found exception ( str + path name ) ; } finally { try { raf . close ( ) ; } catch ( io ioe ) { } } try { return define class ( name , file data , num , file data . length ) ; } catch ( throwable th ) { throw new class not found exception ( str , th ) ; } }	finds the class with the specified binary name , from.
public static void load ( class < ? > parent ) { load ( parent , class loader . get system class loader ( ) ) ; }	load the service file .
public void remove change listener ( change listener cl ) { listeners . remove ( cl ) ; }	removes a listener for changeevents .
@ guarded by ( str ) void apply read ( node < k , v > node ) { if ( eviction deque . contains ( node ) ) { eviction deque . move to back ( node ) ; } }	updates the node ' s location in the page replacement policy .
private void flush write chunk ( ) { if ( write chunk == null ) return ; if ( write chunk . position ( ) == num ) return ; if ( ! write chunk . has remaining ( ) ) { bytes written += write chunk . position ( ) ; write chunk . flip ( ) ; list . add last ( write chunk ) ; write chunk = null ; return ; } bytes written += write chunk . position ( ) ; byte buffer flush chunk = write chunk ; write chunk = write chunk . slice ( ) ; write chunk . order ( order ) ; flush chunk . flip ( ) ; list . add last ( flush chunk ) ; return ; }	flushes write chunk to internal buffer.
public final double sin ( ) { return math . sin ( this . radians ) ; }	obtains the sine of this angle .
public axis label layout ( string group , int axis , valued range model values ) { this ( group , axis , values , null ) ; }	create a new axislabellayout layout .
public double angle ( i agent ) { return geometric . angle ( this . location , agent . get location ( ) ) ; }	return the angle between this agent and the given one.
@ override public boolean equals ( object obj ) { if ( obj == this ) { return bool ; } if ( ! ( obj instanceof default drawing supplier ) ) { return bool ; } default drawing supplier that = ( default drawing supplier ) obj ; if ( ! arrays . equals ( this . paint sequence , that . paint sequence ) ) { return bool ; } if ( this . paint index != that . paint index ) { return bool ; } if ( ! arrays . equals ( this . outline paint sequence , that . outline paint sequence ) ) { return bool ; } if ( this . outline paint index != that . outline paint index ) { return bool ; } if ( ! arrays . equals ( this . stroke sequence , that . stroke sequence ) ) { return bool ; } if ( this . stroke index != that . stroke index ) { return bool ; } if ( ! arrays . equals ( this . outline stroke sequence , that . outline stroke sequence ) ) { return bool ; } if ( this . outline stroke index != that . outline stroke index ) { return bool ; } if ( ! equal shapes ( this . shape sequence , that . shape sequence ) ) { return bool ; } if ( this . shape index != that . shape index ) { return bool ; } return bool ; }	tests this object for equality with another object .
@ override protected void paint component ( graphics g ) { super . paint component ( g ) ; d g2 = ( d ) g ; if ( should draw ) { draw display list on ( g2 ) ; } }	note ! called from ed thread .
public void load ( input stream in ) throws io { properties . load ( in ) ; dirty = bool ; }	loads this preference store from the given input stream.
@ override public void on bind view holder ( vh holder , int position ) { if ( list . get ( position ) . type == type item ) { on bind item view holder ( holder , position ) ; } else if ( list . get ( position ) . type == type header ) { on bind header view holder ( holder , position ) ; } }	splits onbindviewholder method into two separate methods for items and headers .
public static map < component wrapper , cc > parse component constraints ( map < component wrapper , string > constr map ) { hash map < component wrapper , cc > flow constr map = new hash map < component wrapper , cc > ( ) ; for ( component wrapper c : constr map . key set ( ) ) { flow constr map . put ( c , parse component constraint ( constr map . get ( c ) ) ) ; } return flow constr map ; }	parses all component constraints and stores the parsed values in the transient ( cache ) member variables .
private void send stage progress patch ( task state state ) { service utils . log info ( this , str , state . stage , state . sub stage ) ; task utils . send self patch ( this , build patch ( state . stage , state . sub stage , null ) ) ; }	this method sends a patch operation to the current service instance to move to a new state .
public void test common prefix ( ) { string returned = m . get common prefix ( ) ; assert equals ( str , num , returned . length ( ) ) ; string expected = str ; trie t = build trie ( new string [ ] { m [ num ] , m [ num ] } ) ; returned = t . get common prefix ( ) ; assert equals ( str , expected . length ( ) , returned . length ( ) ) ; }	tests whether the common prefix is determined correctly.
public string move back ( ) { check . is true ( current index > num , str ) ; current index -- ; return history . get ( current index ) ; }	return the previous url in the list ( relative to the current position ) and moves the index back to make this the now current position .
public static long hash64 ( final string text ) { final byte [ ] bytes = text . get bytes ( ) ; return hash64 ( bytes , bytes . length ) ; }	generates 64 bit hash from a string .
public static void delete core ( ) { log . info ( str ) ; if ( h != null ) { h . close ( ) ; } if ( factory prop == null ) { system . clear property ( str ) ; } solr config = null ; h = null ; lrf = null ; config string = schema string = null ; }	shuts down the test harness , and makes the best attempt possible to delete datadir , unless the system property " solr.
public static boolean can tab ( list constraints ) { for ( iterator iter = constraints . iterator ( ) ; iter . has next ( ) ; ) { dock constraint dc = ( dock constraint ) iter . next ( ) ; if ( ! dc . can tab ( ) ) return bool ; } return bool ; }	determine property over a list of dockconstraint objects.
public imdn parser parse ( ) throws parser configuration exception , sax , parse failure exception { try { sax factory = sax . new instance ( ) ; sax parser = factory . new sax ( ) ; parser . parse ( m input source , this ) ; return this ; } catch ( io e ) { throw new parse failure exception ( str , e ) ; } }	parse the imdn parser.
public static big integer to big integer ( final ed25519 encoded field element encoded ) { return to big integer ( encoded . get raw ( ) ) ; }	converts an encoded field element to a biginteger .
public string escape ldap ( string filter ) { string builder sb = new string builder ( ) ; for ( int i = num ; i < filter . length ( ) ; i ++ ) { char cur char = filter . char at ( i ) ; switch ( cur char ) { case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; default : sb . append ( cur char ) ; } } return sb . to string ( ) ; }	escapes the given string for use within an ldap search filter.
protected synchronized void save ( ) { int ret val ; file file ; string text ; file writer fwriter ; buffered writer bwriter ; ret val = m . show open dialog ( this ) ; if ( ret val != meka file chooser . approve option ) return ; file = m . get selected file ( ) ; text = m . get text ( ) ; fwriter = null ; bwriter = null ; try { fwriter = new file writer ( file ) ; bwriter = new buffered writer ( fwriter ) ; bwriter . write ( text ) ; bwriter . new line ( ) ; bwriter . flush ( ) ; log ( str + file ) ; } catch ( exception e ) { handle exception ( str + file , e ) ; } finally { file utils . close quietly ( bwriter ) ; file utils . close quietly ( fwriter ) ; } }	saves the logging content .
public eigenvalue decomposition ( double [ ] [ ] a ) { n = a . length ; v = new double [ n ] [ n ] ; d = new double [ n ] ; e = new double [ n ] ; issymmetric = bool ; for ( int j = num ; ( j < n ) && issymmetric ; j ++ ) { for ( int i = num ; ( i < n ) && issymmetric ; i ++ ) { issymmetric = ( a [ i ] [ j ] == a [ j ] [ i ] ) ; if ( double . is na n ( a [ i ] [ j ] ) ) { throw new illegal argument exception ( str ) ; } if ( double . is infinite ( a [ i ] [ j ] ) ) { throw new illegal argument exception ( str ) ; } } } if ( issymmetric ) { for ( int i = num ; i < n ; i ++ ) { system . arraycopy ( a [ i ] , num , v [ i ] , num , n ) ; } tred2 ( ) ; tql2 ( ) ; } else { h = new double [ n ] [ n ] ; ort = new double [ n ] ; for ( int j = num ; j < n ; j ++ ) { for ( int i = num ; i < n ; i ++ ) { h [ i ] [ j ] = a [ i ] [ j ] ; } } orthes ( ) ; hqr2 ( ) ; } }	check for symmetry , then construct the eigenvalue decomposition.
public search source builder fields ( string ... fields ) { if ( field names == null ) { field names = new array list < > ( ) ; } collections . add all ( field names , fields ) ; return this ; }	adds the fields to load and return as part of the search request.
public static string builder format to ( string builder buf , boolean [ ] d , string sep ) { if ( d == null ) { return buf . append ( str ) ; } if ( d . length == num ) { return buf ; } buf . append ( d [ num ] ) ; for ( int i = num ; i < d . length ; i ++ ) { buf . append ( sep ) ; buf . append ( format ( d [ i ] ) ) ; } return buf ; }	formats the boolean array d .
public string to complete string ( ) { string ret = str ; if ( ! lines . is empty ( ) && ! config . v ( ) . no source info ) { for ( source location tag line : lines ) { ret += str + line + str ; } } ret += to signature string ( ) ; return ret ; }	return a string of all the information of this method object : line numbers , receiver and signature .
@ override public void update receipt details ( final set < bill receipt info > bill receipts ) { logger . debug ( str + bill receipts ) ; final boolean status = bool ; if ( bill receipts != null ) super . update receipt details ( bill receipts ) ; logger . debug ( str + status ) ; }	this method is invoked from collections end when an event related to receipt in bill generation occurs .
public static void remove map entries ( map map , set set ) { if ( ( set != null ) && ! set . is empty ( ) ) { for ( iterator iter = set . iterator ( ) ; iter . has next ( ) ; ) { map . remove ( iter . next ( ) ) ; } } }	removes the mapping of which keys matches with items in a given set .
public static void put file ( service client h , final operation put , file f ) throws io { final asynchronous file channel ch = asynchronous file channel . open ( f . to path ( ) , standard open option . read ) ; atomic integer completion count = new atomic integer ( num ) ; string content type = file utils . get content type ( f . to uri ( ) ) ; final boolean [ ] file is done = { bool } ; put chunks ( h , put , ch , content type , f . length ( ) , num , completion count , file is done ) ; }	given a post operation and a file , post the file to the uri .
protected string builder process line ( string next element ) { string builder sb = new string builder ( initial string size ) ; for ( int j = num ; j < next element . length ( ) ; j ++ ) { char next char = next element . char at ( j ) ; process character ( sb , next char ) ; } return sb ; }	processes all the characters in a line .
public java refactoring descriptor ( final string id , final string project , final string description , final string comment , final map arguments , final int flags ) { super ( id , project , description , comment , flags ) ; f arguments = arguments ; f arguments . put ( attribute version , value version 1 0 ) ; }	creates a new java refactoring descriptor .
private static supported group negotiate named curve ( client hello client hello ) { supported group result = null ; list < supported group > preferred groups = supported group . get preferred groups ( ) ; supported elliptic curves extension extension = client hello . get supported elliptic curves extension ( ) ; if ( extension == null ) { if ( ! preferred groups . is empty ( ) ) { result = preferred groups . get ( num ) ; } } else { for ( integer preferred group id : extension . get supported group ids ( ) ) { supported group group = supported group . from id ( preferred group id ) ; if ( group != null && group . is usable ( ) && preferred groups . contains ( group ) ) { result = group ; break ; } } } return result ; }	determines the elliptic curve to use during the ec based dh key exchange .
public void zoom ( ) { if ( get selected row key ( ) != null && get selected row key ( ) > num ) { m zoom query = new m ( ) ; string column = get key column ( ) ; if ( column . index of ( str ) > num ) column = column . substring ( column . index of ( str ) + num ) ; zoom query . add restriction ( column , m . equal , get selected row key ( ) ) ; zoom query . set record count ( num ) ; zoom query . set table name ( column . substring ( num , column . length ( ) - num ) ) ; a . zoom ( num , zoom query ) ; } }	zoom action to be overwritten by concrete classes.
public long avg rate ( ) { long sum = num ; for ( sample s : samples ) { sum += s . rate ( ) ; } return ( long ) ( sum / ( long ) samples . size ( ) ) ; }	returns the average of the message rates in the samplegroup .
@ override public synchronized void close ( ) throws io { try { if ( sync task != null ) { sync task . cancel ( ) ; } sync ( ) ; unmap file ( ) ; } finally { super . close ( ) ; } }	closes the underlying rrd file .
public boolean mouse moved ( mouse event e ) { om new selected graphic ; if ( show plot && graph != null ) { new selected graphic = graph . select point ( e . get x ( ) , e . get y ( ) , num ) ; if ( new selected graphic != null ) { string infostring = ( string ) ( new selected graphic . get attribute ( om . app object ) ) ; if ( infostring != null ) { fire request info line ( infostring ) ; } } else { fire request info line ( str ) ; } return bool ; } else { om list = get list ( ) ; if ( list != null ) { new selected graphic = list . select closest ( e . get x ( ) , e . get y ( ) , num ) ; if ( new selected graphic != null && ( selected graphic == null || new selected graphic != selected graphic ) ) { debug . message ( str , str ) ; selected graphic = new selected graphic ; selected graphic . regenerate ( get projection ( ) ) ; globe site = ( globe ) ( new selected graphic . get attribute ( om . app object ) ) ; if ( site != null ) { fire request info line ( site . get info ( ) ) ; } repaint ( ) ; } else if ( selected graphic != null && new selected graphic == null ) { debug . message ( str , str ) ; selected graphic . regenerate ( get projection ( ) ) ; fire request info line ( str ) ; selected graphic = null ; repaint ( ) ; } return bool ; } } return bool ; }	called whenever the mouse is moved on this layer and one of the requested mouse modes is active.
public void hide popup ( ) { show pending = bool ; if ( popup != null ) { popup . hide ( ) ; popup = null ; } }	hides the popup window .
public final runtime exception process do method invoke exception ( exception e , object object , object [ ] argument array ) { if ( e instanceof runtime exception ) return ( runtime exception ) e ; return meta class helper . create exception text ( str , this , object , argument array , e , bool ) ; }	this method is called when an exception occurs while invoking this method .
protected boolean build subfield defns ( string psz sublist ) { if ( psz sublist . char at ( num ) == str ) { b repeating subfields = bool ; psz sublist = psz sublist . substring ( num ) ; } vector papsz subfield names = prop utils . parse markers ( psz sublist , str ) ; pao subfield defns = new vector ( ) ; for ( iterator it = papsz subfield names . iterator ( ) ; it . has next ( ) ; ) { ddf ddfsd = new ddf ( ) ; ddfsd . set name ( ( string ) it . next ( ) ) ; pao subfield defns . add ( ddfsd ) ; } return bool ; }	based on the list contained in the string , build a set of subfield definitions .
public boolean is running ( ) { return m running . get ( ) ; }	indicates if this thread is running.
private static map < string , boolean > object methods to generate ( list < executable element > methods ) { map < string , boolean > vars = new tree map < string , boolean > ( ) ; vars . put ( str , bool ) ; vars . put ( str , bool ) ; vars . put ( str , bool ) ; for ( executable element method : methods ) { if ( is to string or equals or hash code ( method ) ) { boolean can generate = method . get modifiers ( ) . contains ( modifier . abstract ) || is java lang object ( ( type element ) method . get enclosing element ( ) ) ; vars . put ( method . get simple name ( ) . to string ( ) , can generate ) ; } } assert vars . size ( ) == num ; return vars ; }	given a list of all methods defined in or inherited by a class , returns a map with keys " tostring " , " equals " , " hashcode " and corresponding value true if that method should be generated .
public void add entry time ( double time ) { if ( entry times == null ) { return ; } if ( time < num ) { time = num ; } entry times . add ( double . value of ( time ) ) ; }	register the time the packet arrives at an entity such as a router or cloudresource.
public void test single resource locking serialized waits for high concurrency ( ) throws exception { final properties properties = new properties ( ) ; final int nthreads = num ; final int ntasks = num ; properties . set property ( test options . core pool size , str + nthreads ) ; properties . set property ( test options . ntasks , str + ntasks ) ; properties . set property ( test options . nresources , str ) ; properties . set property ( test options . min locks , str ) ; properties . set property ( test options . max locks , str ) ; properties . set property ( test options . predeclare locks , str ) ; properties . set property ( test options . sort lock requests , str ) ; final result result = do comparison test ( properties ) ; assert equals ( str , num , integer . parse int ( result . get ( str ) ) ) ; assert equals ( str , num , integer . parse int ( result . get ( str ) ) ) ; assert equals ( str , ntasks , integer . parse int ( result . get ( str ) ) ) ; }	test where each operation locks only a single resource and there is only one resource to be locked so that all operations must be serialized .
public final double npv ( ) { calculate ( ) ; ql . require ( ! double . is na n ( this . npv ) , str ) ; return npv ; }	returns the net present value of the instrument .
public array real vector ( array real vector v1 , real vector v2 ) { final int l1 = v1 . data . length ; final int l2 = v2 . get dimension ( ) ; data = new double [ l1 + l2 ] ; system . arraycopy ( v1 . data , num , data , num , l1 ) ; for ( int i = num ; i < l2 ; ++ i ) { data [ l1 + i ] = v2 . get entry ( i ) ; } }	construct a vector by appending one vector to another vector .
public static map < string , object > deactivate content assoc ( dispatch context dctx , map < string , ? extends object > rcontext ) { map < string , object > context = util misc . make map writable ( rcontext ) ; context . put ( str , str ) ; list < string > target operation list = content worker . prep target operation list ( context , str ) ; list < string > content purpose list = content worker . prep content purpose list ( context ) ; context . put ( str , target operation list ) ; context . put ( str , content purpose list ) ; context . put ( str , null ) ; map < string , object > result = deactivate content assoc method ( dctx , context ) ; return result ; }	update a contentassoc service.
public byte buffer flush and release buffer ( ) throws io { lock . lock ( ) ; try { flush pending = bool ; while ( buffer use count != num ) { flush ready . await ( ) ; } buffer . flip ( ) ; if ( buffer . limit ( ) != num && modified ) { if ( backing file == null ) { backing file = files . create temp file ( str , str ) ; } log . debug ( str , start index , backing file , buffer . limit ( ) , block size ) ; try ( byte channel out = files . new byte channel ( backing file , write ) ) { out . write ( buffer ) ; } } else { log . debug ( str , start index ) ; } byte buffer old buffer = buffer ; buffer = null ; loaded = bool ; return old buffer ; } catch ( interrupted exception e ) { throw throwables . propagate ( e ) ; } finally { flush pending = bool ; flush complete . signal all ( ) ; lock . unlock ( ) ; } }	flushes the block ' s buffer to disk and releases the buffer for use by another block.
public static boolean is directly getting powered ( world world , d coord ) { for ( forge direction side : forge direction . valid directions ) { d side coord = coord . get from side ( side ) ; if ( side coord . exists ( world ) ) { if ( world . is block providing power to ( coord . x coord , coord . y coord , coord . z coord , side . ordinal ( ) ) > num ) { return bool ; } } } return bool ; }	checks if a block is directly getting powered by any of its neighbors without loading any chunks .
public < t extends property container > list < search match < t > > search ( string query , class < t > clazz ) { search result result = do query ( query , clazz ) ; list < search match < t > > matches = build search matches ( result ) ; @ suppress warnings ( str ) function < search match , t > resolver = ( function < search match , t > ) ( clazz . equals ( node . class ) ? get node resolver ( ) : get relationship resolver ( ) ) ; return resolve match items ( matches , resolver ) ; }	search for nodes or relationships.
private synchronized void enumerate ( hashtable < string , object > h ) { if ( defaults != null ) { defaults . enumerate ( h ) ; } for ( enumeration < ? > e = keys ( ) ; e . has more elements ( ) ; ) { string key = ( string ) e . next element ( ) ; h . put ( key , get ( key ) ) ; } }	enumerates all key / value pairs in the specified hashtable .
public void update quantity csv ( item bean original , item bean item to add , boolean add ) { big decimal original quantity = original . get qty csv ( ) ; big decimal quantity to add = item to add . get qty csv ( ) ; big decimal final quantity = null ; if ( ! add ) final quantity = original quantity . subtract ( quantity to add ) ; else final quantity = original quantity . add ( quantity to add ) ; original . set qty csv ( final quantity ) ; }	update quantity csv in inventory.
public static number abs ( number a ) { if ( is floating point ( a ) ) { return math . abs ( a . double value ( ) ) ; } else { return math . abs ( a . long value ( ) ) ; } }	returns the absolute value of the number .
public user ( string id , string name , string email ) { this . id = id ; this . email = email ; this . name = name ; }	construct a user given an id , name , and email .
@ suppress warnings ( str ) public object [ ] to array ( ) { final reentrant lock lock = this . lock ; lock . lock ( ) ; try { object [ ] a = new object [ count ] ; int k = num ; for ( node < e > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }	returns an array containing all of the elements in this deque , in proper sequence ( from first to last element ).
public static asset create asset from bitmap ( bitmap bitmap ) { if ( bitmap != null ) { final byte array output stream byte stream = new byte array output stream ( ) ; bitmap . compress ( bitmap . compress format . png , num , byte stream ) ; return asset . create from bytes ( byte stream . to byte array ( ) ) ; } return null ; }	create a wearable asset from a bitmap .
public boolean is ip ( session sess , string client ip ) throws sso { boolean check = bool ; try { inet address sess ip = inet address . get by name ( sess . get property ( str ) ) ; inet address client ip = inet address . get by name ( client ip ) ; if ( sess ip . equals ( client ip ) ) { check = bool ; } } catch ( exception e ) { if ( debug . message enabled ( ) ) { debug . message ( str , e ) ; } } return check ; }	validate the ip address of the client with the ip stored in session .
@ suppress warnings ( str ) private static void handle method node ( get static graph static usage tree , class node cn , method node mn , int depth ) { insn list instructions = mn . instructions ; iterator < abstract insn node > iterator = instructions . iterator ( ) ; while ( iterator . has next ( ) ) { abstract insn node insn = iterator . next ( ) ; if ( insn instanceof method insn node ) { handle method insn node ( static usage tree , cn , mn , ( method insn node ) insn , depth + num ) ; } else if ( insn instanceof field insn node ) { handle field insn node ( static usage tree , cn , mn , ( field insn node ) insn , depth + num ) ; } } }	add all possible calls for a given method.
public void add parameter ( name value pair param ) throws illegal argument exception { log . trace ( str ) ; if ( param == null ) { throw new illegal argument exception ( str ) ; } add parameter ( param . get name ( ) , param . get value ( ) ) ; }	adds a new parameter to be used in the post request body .
private void read policies ( xml pull parser parser ) throws io , xml pull parser exception { while ( parser . next ( ) != xml pull parser . end tag ) { if ( parser . get event type ( ) != xml pull parser . start tag ) { continue ; } string name = parser . get name ( ) ; if ( tag user restriction . equals ( name ) ) { string user restriction = parser . get attribute value ( null , attribute name ) ; if ( user restriction != null ) { m user restrictions . add ( user restriction ) ; } } else if ( tag global setting . equals ( name ) ) { string setting = parser . get attribute value ( null , attribute name ) ; string value = parser . get attribute value ( null , attribute value ) ; if ( setting != null && value != null ) { m global settings . add ( new global setting ( setting , value ) ) ; } } else if ( tag disable status bar . equals ( name ) ) { m disable status bar = boolean . parse boolean ( parser . get attribute value ( null , attribute value ) ) ; } else if ( tag disable keyguard . equals ( name ) ) { m disable keyguard = boolean . parse boolean ( parser . get attribute value ( null , attribute value ) ) ; } else if ( tag disable camera . equals ( name ) ) { m disable camera = boolean . parse boolean ( parser . get attribute value ( null , attribute value ) ) ; } else if ( tag disable screen capture . equals ( name ) ) { m disable screen capture = boolean . parse boolean ( parser . get attribute value ( null , attribute value ) ) ; } skip current tag ( parser ) ; } }	read the policies to be set.
public boolean read header ( random access file raf ) throws io { string buffer id = new string buffer ( num ) ; for ( int i = num ; i < num ; i ++ ) { int ch = raf . read ( ) ; if ( ch < num ) { string hx = integer . to hex string ( ch ) ; if ( hx . length ( ) < num ) { hx = str + hx ; } return bool ; } id . append ( ( char ) ch ) ; } chunk id = id . to string ( ) ; size = aiff util . read uin ( raf ) ; return bool ; }	reads the header of a chunk.
private xy initialize plot ( ) { jmx chart = new y ( str ) ; y yintervalseriescollection = new y ( ) ; yintervalseriescollection . add series ( jmx chart ) ; deviation renderer renderer = new deviation renderer ( bool , bool ) ; renderer . set base shapes visible ( bool ) ; renderer . set series stroke ( num , new basic stroke ( num , basic stroke . cap round , basic stroke . join round ) ) ; renderer . set series fill paint ( num , new color ( num , num , num ) ) ; renderer . set series outline stroke ( num , new basic stroke ( num ) ) ; renderer . set series shape ( num , new d . double ( - num , - num , num , num ) ) ; renderer . set base tool tip generator ( new xy ( xy . default tool tip format , date format . get date time instance ( ) , number format . get number instance ( ) ) ) ; number axis range axis = plot data solver . get axis ( ) ; subplot = new xy ( yintervalseriescollection , null , range axis , renderer ) ; subplot . set axis offset ( new rectangle insets ( num , num , num , num ) ) ; subplot . set range axis location ( axis location . top or left ) ; subplot . set range crosshair visible ( bool ) ; return subplot ; }	initializes the upper plot .
private boolean is fatal state ( string sql state ) { if ( sql state == null || sql state . length ( ) < num ) { return bool ; } for ( string fatal sql state class : fatal sql state classes ) { if ( sql state . starts with ( fatal sql state class ) ) { return bool ; } } return bool ; }	decides if the given sql state is a fatal connection error .
private void analyze file ( file input file , optional < common token stream > opt token stream , optional < top level context > opt tree , formatter formatter , severity max severity , construct lengths construct lengths , set < rules > enabled rules ) throws cli { try { printer printer = new printer ( input file , max severity , formatter ) ; if ( opt token stream . is present ( ) && opt tree . is present ( ) ) { common token stream token stream = opt token stream . get ( ) ; top level context tree = opt tree . get ( ) ; comment extractor comment extractor = new comment extractor ( token stream ) ; violation suppressor disable analysis = new violation suppressor ( printer , comment extractor . get single line comments ( ) , comment extractor . get multiline comments ( ) ) ; disable analysis . analyze ( ) ; list < swift base listener > listeners = create listeners ( enabled rules , printer , token stream , construct lengths , comment extractor ) ; walk parse tree ( listeners , tree ) ; try ( file listener file listener = new file listener ( printer , input file , construct lengths , enabled rules ) ) { file listener . verify ( ) ; } num errors . add and get ( printer . get num error messages ( ) ) ; num warnings . add and get ( printer . get num warning messages ( ) ) ; } else { printer . set should print parse error message ( bool ) ; } printers for all files . add ( printer ) ; } catch ( io e ) { handle io ( e ) ; } catch ( cli e ) { handle cli ( e ) ; } }	analyzes an individual file by creating the corresponding listeners and walking the file ' s parse tree .
@ suppress warnings ( str ) public static < t > t to object ( byte buffer bf ) throws io , class not found exception { object obj = null ; input stream is = null ; object input stream ois = null ; try { is = new byte buffer backed input stream ( bf ) ; ois = new object input stream ( is ) ; obj = ois . read object ( ) ; } finally { if ( is != null ) { is . close ( ) ; } if ( ois != null ) { ois . close ( ) ; } } return ( t ) obj ; }	de - serialize an object from a bytebuffer object .
static private void scan deadline queue ( final long now nanos , final priority blocking queue < query deadline > deadline queue ) { final list < query deadline > c = new array list < query deadline > ( deadline queue scan size ) ; deadline queue . drain to ( c , deadline queue scan size ) ; int ndropped = num , nrunning = num ; for ( query deadline x : c ) { if ( x . check deadline ( now nanos ) != null ) { deadline queue . add ( x ) ; nrunning ++ ; } else { ndropped ++ ; } } if ( log . is info enabled ( ) ) log . info ( str + deadline queue scan size + str + ndropped + str + nrunning + str + deadline queue . size ( ) ) ; }	queries with a deadline that lies significantly in the future can lie around in the priority queue until that deadline is reached if there are other queries in front of them that are not terminated and whose deadline has not be reached.
public int compare ( file file1 , file file2 ) { return case sensitivity . check compare to ( file1 . get name ( ) , file2 . get name ( ) ) ; }	compare the names of two files with the specified case sensitivity .
@ override public string last string ( ) { return integer . to string ( lastint ) ; }	return the previous string generated by the distribution ; e.
public boolean remove item content ( string uid ) { if ( ! users . is empty ( ) ) { return remove content ( uid , users ) ; } else if ( ! reports . is empty ( ) ) { return remove content ( uid , reports ) ; } else { return remove content ( uid , resources ) ; } }	removes the content with the given uid.
public void close ( ) { if ( dialog != null ) { dialog . set visible ( bool ) ; dialog . dispose ( ) ; dialog = null ; pane = null ; my bar = null ; } }	indicate that the operation is complete.
public static void expand ordinal ( string raw number string , word relation word relation ) { string number string = utilities . delete char ( raw number string , str ) ; expand number ( number string , word relation ) ; item last item = word relation . get tail ( ) ; if ( last item != null ) { feature set feature set = last item . get features ( ) ; string last number = feature set . get string ( str ) ; string ordinal = find match in array ( last number , digit2num , ord2num ) ; if ( ordinal == null ) { ordinal = find match in array ( last number , digit2teen , ord2teen ) ; } if ( ordinal == null ) { ordinal = find match in array ( last number , digit2enty , ord2enty ) ; } if ( last number . equals ( str ) ) { ordinal = str ; } else if ( last number . equals ( str ) ) { ordinal = str ; } else if ( last number . equals ( str ) ) { ordinal = str ; } if ( ordinal != null ) { word relation . set last word ( ordinal ) ; } } }	expands the digit string of an ordinal number .
private void check bounded type parameter ( method method ) { type variable < method > type parameter = get type parameter ( method ) ; assert equals ( str , type parameter . get name ( ) ) ; assert equals ( method , type parameter . get generic declaration ( ) ) ; type [ ] bounds = type parameter . get bounds ( ) ; assert lenght one ( bounds ) ; type bound = bounds [ num ] ; assert equals ( bounded wildcards generic methods . class , bound ) ; }	tests whether the type parameter is bounded by boundedgenericmethods like : < t extends boundedgenericmethods > .
public void register sensor ( sensor s , int i ) { if ( ( i < num ) || ( i > ( input bits [ node type ] - num ) ) || ( i > maxsensors ) ) { log . error ( str + integer . to string ( i + num ) ) ; return ; } has active sensors = bool ; if ( sensor array [ i ] == null ) { sensor array [ i ] = s ; if ( last used sensor < i ) { last used sensor = i ; } } else { log . warn ( str + integer . to string ( ( get node address ( ) * serial sensor manager . sensorspernode ) + i + num ) ) ; } }	the numbers here are 0 to maxsensors , not 1 to maxsensors .
public boolean has organisation units ( ) { list < dimensional item object > dim opts = get dimension options ( orgunit dim id ) ; list < dimensional item object > filter opts = get filter options ( orgunit dim id ) ; return ! dim opts . is empty ( ) || ! filter opts . is empty ( ) ; }	indicates whether organisation units are present as dimension or filter .
protected void fixup blocks ( byte [ ] bytes2 ) { byte [ ] bytes = bytes2 ; for ( iterator enumerator = blocks . iterator ( ) ; enumerator . has next ( ) ; ) { int [ ] info = ( int [ ] ) enumerator . next ( ) ; int code size = info [ num ] ; int offset = info [ num ] ; byte [ ] size bytes = out stream . sint to2 bytes ( code size ) ; bytes [ offset ] = size bytes [ num ] ; bytes [ offset + num ] = size bytes [ num ] ; } }	description of the method.
protected double negative log likelihood ( double [ ] [ ] data ys , double [ ] [ ] probs ) { double log likelihood = num ; for ( int i = num ; i < data ys . length ; i ++ ) { for ( int j = num ; j < m num classes ; j ++ ) { if ( data ys [ i ] [ j ] == num ) { log likelihood -= math . log ( probs [ i ] [ j ] ) ; } } } return log likelihood ; }	returns the negative loglikelihood of the y - values ( actual class probabilities ) given the p - values ( current probability estimates ) .
public static boolean valid system name config ( string system name , char type , acela system connection memo memo ) { if ( ! valid system name format ( system name , type , memo . get system prefix ( ) ) ) { return bool ; } acela node node = get node from system name ( system name , memo ) ; if ( node == null ) { return bool ; } int bit = get bit from system name ( system name ) ; if ( ( type == str ) || ( type == str ) ) { if ( ( bit < minoutputaddress ) || ( bit > maxoutputaddress ) ) { return bool ; } } else if ( type == str ) { if ( ( bit < minsensoraddress ) || ( bit > maxsensoraddress ) ) { return bool ; } } else { log . error ( str ) ; return bool ; } return bool ; }	public static method to validate acela system name for configuration returns ' true ' if system name has a valid meaning in current configuration , else returns ' false '.
public void add member ( string player name ) { open invites . remove ( player name ) ; members and last seen . put ( player name , long . value of ( system . current time millis ( ) ) ) ; if ( leader == null ) { leader = player name ; } send group change event ( ) ; }	adds a member to the group.
public xy ( ) { this ( default format string , number format . get number instance ( ) , number format . get number instance ( ) , number format . get number instance ( ) ) ; }	creates a new tool tip generator using default number formatters for the x , y and z - values .
void add nodes ( list < node > new nodes , boolean at beginning ) { if ( at beginning ) { if ( ( nodes . size ( ) > num ) && nodes . get ( num ) == new nodes . get ( new nodes . size ( ) - num ) ) { log . i ( debug tag , str ) ; if ( new nodes . size ( ) > num ) { log . i ( debug tag , str ) ; new nodes . remove ( new nodes . size ( ) - num ) ; add nodes ( new nodes , at beginning ) ; } return ; } nodes . add all ( num , new nodes ) ; } else { if ( ( nodes . size ( ) > num ) && new nodes . get ( num ) == nodes . get ( nodes . size ( ) - num ) ) { log . i ( debug tag , str ) ; if ( new nodes . size ( ) > num ) { log . i ( debug tag , str ) ; new nodes . remove ( num ) ; add nodes ( new nodes , at beginning ) ; } return ; } nodes . add all ( new nodes ) ; } }	adds multiple nodes to the way in the order in which they appear in the list.
public synchronized boolean update av ( string stream id , room client rcm ) { try { room client rcl usual = get client by public sid ( rcm . get public sid ( ) , bool ) ; if ( rcl usual != null ) { rcl usual . set broad cast id ( rcm . get broad cast id ( ) ) ; rcl usual . set avsettings ( rcm . get avsettings ( ) ) ; rcl usual . set v ( rcm . get v ( ) ) ; rcl usual . set v ( rcm . get v ( ) ) ; rcl usual . set vx ( rcm . get vx ( ) ) ; rcl usual . set vy ( rcm . get vy ( ) ) ; if ( client list . contains key ( rcl usual . get streamid ( ) ) ) { client list . put ( rcl usual . get streamid ( ) , rcl usual ) ; } else { log . debug ( str + rcl usual . get streamid ( ) ) ; } } update client by stream id ( stream id , rcm ) ; } catch ( exception err ) { log . error ( str , err ) ; } return null ; }	update the session object of the audio / video - connection and additionally swap the values to the session object of the user that holds the full session object.
public void add color ( int color ) { if ( m colors == null ) m colors = new array list < integer > ( ) ; m colors . add ( color ) ; }	adds a new color to the colors array of the dataset .
private void clamp starting position ( ) { final float c x = m bounds . exact center x ( ) ; final float c y = m bounds . exact center y ( ) ; final float d x = m starting x - c x ; final float d y = m starting y - c y ; final float r = m target radius ; if ( d x * d x + d y * d y > r * r ) { final double angle = math . atan2 ( d y , d x ) ; m clamped starting x = c x + ( float ) ( math . cos ( angle ) * r ) ; m clamped starting y = c y + ( float ) ( math . sin ( angle ) * r ) ; } else { m clamped starting x = m starting x ; m clamped starting y = m starting y ; } }	clamps the starting position to fit within the ripple bounds .
public boolean is empty ( ) { if ( last batch != null ) { if ( ! last batch . is empty ( ) ) { return bool ; } } return current batch . is empty ( ) ; }	returns true if the window is empty , or false if not empty .
@ suppress warnings ( str ) public dummy data ( int cols , int rows , comparable < ? > value ) { value . get class ( ) ; this . cols = cols ; this . rows = rows ; this . value = value ; class < ? extends comparable < ? > > [ ] types = new class [ cols ] ; arrays . fill ( types , value . get class ( ) ) ; set column types ( types ) ; }	creates a new instance with the specified number of columns and rows , which are filled all over with the same specified value .
public object clone ( ) throws clone not supported exception { node vector clone = ( node vector ) super . clone ( ) ; if ( ( null != this . m map ) && ( this . m map == clone . m map ) ) { clone . m map = new int [ this . m map . length ] ; system . arraycopy ( this . m map , num , clone . m map , num , this . m map . length ) ; } return clone ; }	get a cloned locpathiterator .
public boolean match with pattern ( string pattern ) { if ( text utils . is empty ( pattern ) ) { m current pattern = str ; m upper case pattern = str ; m lower case pattern = str ; } if ( text utils . is empty ( m display name ) ) { return bool ; } if ( text utils . is empty ( m upper case display name ) ) { m upper case display name = m display name . to lower case ( ) ; m lower case display name = m display name . to upper case ( ) ; } if ( ! pattern . equals ( m current pattern ) ) { m current pattern = pattern ; m upper case pattern = pattern . to upper case ( ) ; m lower case pattern = pattern . to lower case ( ) ; } return ( m upper case display name . index of ( m upper case pattern ) >= num ) || ( m lower case display name . index of ( m upper case pattern ) >= num ) ; }	test if some fields match with the pattern.
public boolean equals ( object obj ) { if ( obj == this ) { return bool ; } if ( obj instanceof annotation member ) { annotation member that = ( annotation member ) obj ; if ( name . equals ( that . name ) && tag == that . tag ) { if ( tag == array ) { return equal array value ( that . value ) ; } else if ( tag == error ) { return bool ; } else { return value . equals ( that . value ) ; } } } return bool ; }	returns true if the specified object represents equal element ( equivalent name - value pair ).
public static range iterate z ( xyz dataset , boolean include interval ) { double minimum = double . positive infinity ; double maximum = double . negative infinity ; int series count = dataset . get series count ( ) ; for ( int series = num ; series < series count ; series ++ ) { int item count = dataset . get item count ( series ) ; for ( int item = num ; item < item count ; item ++ ) { double value = dataset . get z ( series , item ) ; if ( ! double . is na n ( value ) ) { minimum = math . min ( minimum , value ) ; maximum = math . max ( maximum , value ) ; } } } if ( minimum == double . positive infinity ) { return null ; } else { return new range ( minimum , maximum ) ; } }	iterates over the data items of the xyz dataset to find the z - dimension bounds .
public void remove view from fade list ( view view ) { if ( m fade view list != null && view != null ) { m fade view list . remove ( view ) ; } }	remove view that has been added by addviewtofadelist.
void add indifferent algorithm ( string algorithm ) { indifferent algorithms . add ( algorithm ) ; }	adds an algorithm with statistically similar performance to the current algorithm .
public union iterator ( iterable < ? extends e > ... args ) { this ( arrays . as list ( args ) ) ; }	creates a new unioniterator that returns the bag union of the results of a number of iterators .
public static string mangle native method ( string owner , string name , string desc ) { string builder sb = new string builder ( ) ; sb . append ( str ) ; sb . append ( mangle native string ( owner ) ) ; sb . append ( str ) ; sb . append ( mangle native string ( name ) ) ; if ( desc != null ) { sb . append ( str ) ; sb . append ( mangle native string ( desc . substring ( num , desc . last index of ( str ) ) ) ) ; } return sb . to string ( ) ; }	returns the long version of the jni function name for a method .
public string read line ( ) throws io { boolean got cr = bool , got lf = bool ; pos = num ; line buf = new string buffer ( ) ; while ( ! got lf ) { int c = is . read ( ) ; if ( c == - num ) { return null ; } if ( got cr ) { if ( c == lf ) { got lf = bool ; } else { got cr = bool ; consume ( cr ) ; consume ( c ) ; } } else { if ( c == cr ) { got cr = bool ; } else { consume ( c ) ; } } } line buf . append ( buf , num , pos ) ; return new string ( line buf ) ; }	read a line from the stream returning as a string.
public lobby client login ( ) { if ( ! m server properties . is server available ( ) ) { j . show message dialog ( m parent , m server properties . server error message , str , j . error message ) ; return null ; } if ( m server properties . port == - num ) { if ( client file system helper . are we old extra jar ( ) ) { j . show message dialog ( m parent , str + url constants . latest game download website + str + str , str , j . error message ) ; } else { j . show message dialog ( m parent , str + url constants . latest game download website + str , str , j . error message ) ; } return null ; } return login to server ( ) ; }	attempt to login to the lobbyserver < p > if we could not login , return null .
@ override public boolean e is set ( int feature id ) { switch ( feature id ) { case functionblock package . param multiplicity : return multiplicity != multiplicity edefault ; case functionblock package . param name : return name edefault == null ? name != null : ! name edefault . equals ( name ) ; case functionblock package . param description : return description edefault == null ? description != null : ! description edefault . equals ( description ) ; } return super . e is set ( feature id ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
protected node pop node ( stack < node > stack , class < ? extends node > cls , string uri ) { node top = stack . is empty ( ) ? null : stack . peek ( ) ; if ( top != null ) { if ( node matches ( top , cls , uri ) ) { node node = stack . pop ( ) ; popped nodes . push ( node ) ; return node ; } else { for ( int i = stack . size ( ) - num ; i >= num ; i -- ) { if ( node matches ( stack . get ( i ) , cls , uri ) ) { node node = stack . remove ( i ) ; popped nodes . push ( node ) ; return node ; } } } } return null ; }	this method pops a node of the defined class and optional uri from the stack.
public static double [ ] [ ] compute weight matrix ( int bpp ) { final int dim = bpp * bpp * bpp ; final double [ ] [ ] m = new double [ dim ] [ dim ] ; final double max = num * ( bpp - num ) ; for ( int x = num ; x < dim ; x ++ ) { final int rx = ( x / bpp ) / bpp ; final int gx = ( x / bpp ) % bpp ; final int bx = x % bpp ; for ( int y = x ; y < dim ; y ++ ) { final int ry = ( y / bpp ) / bpp ; final int gy = ( y / bpp ) % bpp ; final int by = y % bpp ; final double dr = math . abs ( rx - ry ) ; final double dg = math . abs ( gx - gy ) ; final double db = math . abs ( bx - by ) ; final double val = num - ( dr + dg + db ) / max ; m [ x ] [ y ] = m [ y ] [ x ] = val ; } } return m ; }	compute weight matrix for a rgb color histogram.
private static boolean is gnome ( ) { return system . getenv ( str ) != null ; }	checks if we are currently running under gnome desktop .
protected size requirements calculate major axis requirements ( int axis , size requirements r ) { size requirements req = super . calculate major axis requirements ( axis , r ) ; req . maximum = integer . max value ; return req ; }	calculate the requirements needed along the major axis.
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str + str + str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public map < string , list < revision file > > current revision files ( ) ;	returns the current revision files held by the handler .
public void end subreport ( string subreport ) { if ( subreport . is empty ( ) ) { log . error ( string . format ( str , subreport ) ) ; return ; } string top subreport = subreports . peek ( ) ; if ( top subreport . equals ( subreport ) ) { subreports . pop ( ) ; add log entry ( new subreport end entry ( subreport ) ) ; return ; } log . error ( string . format ( str , subreport ) ) ; }	closes the subreport . checks if the provided subreport name matches subreport name stored on the stack . if the names match , endsubreport will remove the subreport from stack and close it . otherwise , endsubreport will log an error in the report .
public static double dnorm log ( double x , double mean , double sd ) { if ( sd <= num ) throw new illegal argument exception ( str ) ; return - math . log ( sd ) + dnorm log ( ( x - mean ) / sd ) ; }	returns the log - density value of a standard normal .
public static void delete ( file f ) { delete ( f , bool ) ; }	delete a file or directory.
public boolean extends entity ( class < ? > entity definition ) { return entity definition . get annotation ( extends entity . class ) != null ; }	checks to see if the entity definition indicates that it extends another entity definition .
public void parse ( input source input ) throws io , sax { if ( parsing ) { throw new sax ( str ) ; } setup parser ( ) ; parsing = bool ; try { parser . parse ( input ) ; } finally { parsing = bool ; } parsing = bool ; }	parse an xml document .
private void release0 ( long ptr , long size , atomic long cnt ) { if ( ptr != num ) { if ( safe release ) fill ( ptr , size , ( byte ) num ) ; grid unsafe . free memory ( ptr ) ; cnt . add and get ( - size ) ; if ( lsnr != null ) lsnr . on event ( release ) ; } }	internal release procedure . decreases size of corresponding counter .
public void add services ( list < service definition > services ) throws exception { ensure path exists ( ) ; set < string > remaining descriptors = new hash set < > ( data manager . get children ( zk service definition path ) ) ; for ( service definition service : services ) { log . debug ( string . format ( str , service . service id ) ) ; string path = get service definition path ( service . service id ) ; try { stat before = data manager . check exists ( path ) ; data manager . put data ( path , service ) ; stat after = data manager . check exists ( path ) ; node updated ( path , before , after ) ; remaining descriptors . remove ( service . service id ) ; } catch ( exception e ) { log . error ( string . format ( str , service . service id , path ) , e ) ; throw e ; } } for ( string descriptor name : remaining descriptors ) { log . info ( string . format ( str , descriptor name ) ) ; data manager . remove node ( zk service definition path + str + descriptor name ) ; } }	adds all the given service definitions to the zookeeper tree.
protected void read props ( ) { int count ; properties props ; int i ; string item str ; t item ; m = bool ; props = load props ( ) ; count = integer . parse int ( props . get property ( expand ( get count key ( ) ) , str ) ) ; m . clear ( ) ; for ( i = count - num ; i >= num ; i -- ) { item str = props . get property ( get item prefix ( ) + i , str ) ; if ( item str . length ( ) > num ) { item = from string ( item str ) ; if ( check ( item ) ) add recent item ( item ) ; } } m = bool ; }	reads the recent items from the props file .
public form index step index out ( form index index ) { if ( index . is terminal ( ) ) { return null ; } else { return new form index ( step index out ( index . get next level ( ) ) , index ) ; } }	used to go up one level in the formindex.
protected double kernel helper lp ( int n , char [ ] s , int end index s , char [ ] t , int end index t , int remaining match length ) { if ( n == num ) { return get return value ( n ) ; } if ( math . min ( end index s + num , end index t + num ) < n ) { ; return get return value ( n ) ; } if ( remaining match length < num * n ) { return get return value ( n ) ; } int adr = num ; if ( m use recursion cache ) { adr = m mult x * n + m mult y * end index s + m mult z * end index t + m mult zz * remaining match length ; if ( cachekh2 k [ adr % max cache ] == adr + num ) { return cachekh2 [ adr % max cache ] ; } } int rml = num ; double result = num ; for ( int i s = ( end index s - remaining match length ) ; i s <= end index s ; i s ++ ) { result *= m lambda ; result += kernel helper2 lp ( n , s , i s , t , end index t , rml ++ ) ; } if ( m use recursion cache && end index s >= num && end index t >= num && n >= num ) { cachekh k [ adr % max cache ] = adr + num ; cachekh [ adr % max cache ] = result ; } return result ; }	helper function for the evaluation of the kernel ( k ' n ) using lambda pruning.
@ override protected synchronized void on measure ( int width measure spec , int height measure spec ) { int width = num ; if ( measure spec . unspecified != measure spec . get mode ( width measure spec ) ) { width = measure spec . get size ( width measure spec ) ; } int height = thumb image . get height ( ) ; if ( measure spec . unspecified != measure spec . get mode ( height measure spec ) ) { height = math . min ( height , measure spec . get size ( height measure spec ) ) ; } set measured dimension ( width , height ) ; }	ensures correct size of the widget .
public void start ( ) { calculate position array ( ) ; set preferred size ( calculate preferred size ( ) ) ; offset = get width ( ) ; timer = new timer ( interval , this ) ; timer . start ( ) ; }	start the ticker - do this only after the gui has been packed as the offset needs to know the actual width of the control to set itself correctly .
public static void write plain file ( string file path , byte [ ] content ) throws io { file output stream file ouput stream = new file output stream ( file path ) ; file ouput stream . write ( content ) ; file ouput stream . close ( ) ; }	write byte array into a regular file.
public void transform ( affine transform at ) { clip [ num ] = clip [ num ] ; clip [ num ] = clip [ num ] ; clip [ num ] = clip [ num ] ; clip [ num ] = clip [ num ] ; at . transform ( clip , num , clip , num , num ) ; double xmin = clip [ num ] , ymin = clip [ num ] ; double xmax = clip [ num ] , ymax = clip [ num ] ; for ( int i = num ; i < num ; i += num ) { if ( clip [ i ] < xmin ) xmin = clip [ i ] ; if ( clip [ i ] > xmax ) xmax = clip [ i ] ; if ( clip [ i + num ] < ymin ) ymin = clip [ i + num ] ; if ( clip [ i + num ] > ymax ) ymax = clip [ i + num ] ; } clip [ num ] = xmin ; clip [ num ] = ymin ; clip [ num ] = xmax ; clip [ num ] = ymax ; }	transform the clip contents.
@ suppress warnings ( str ) public boolean is portable filename ( string filename ) { return ( filename . starts with ( program ) || filename . starts with ( home ) || filename . starts with ( preferences ) || filename . starts with ( scripts ) || filename . starts with ( profile ) || filename . starts with ( settings ) || filename . starts with ( file ) || filename . starts with ( resource ) ) ; }	test if the given filename is a portable filename.
void configure basic auth ( http server request server request , http client request http client request ) { final string authorization = server request . get param ( str ) ; if ( authorization != null ) { http client request . put header ( http headers . authorization , authorization ) ; } }	configure basic auth for proxied stream.
public boolean node change ( catalog tree node node , string name ) { catalog tree node c node = get corresponding node ( node ) ; c node . set leaves ( node . get leaves ( ) ) ; abstract catalog tree tree = ( abstract catalog tree ) get coresponding model ( node ) ; c node . set user object ( name ) ; node . set user object ( name ) ; tree . node changed ( c node ) ; model . node changed ( node ) ; update panel ( ) ; image index editor . index changed ( bool ) ; update panel ( ) ; return bool ; }	make a change to a node in the displayed tree . either its name or the contents of its leaves ( image references ).
public static enumeration all ( ) { return all . elements ( ) ; }	access to all productions .
public boolean wait until empty ( long timeout ) throws interrupted exception { if ( ! notify lock . try lock ( timeout , time unit . milliseconds ) ) { return bool ; } try { return pending . is empty ( ) || notify condition . await ( timeout , time unit . milliseconds ) ; } finally { notify lock . unlock ( ) ; } }	wait until the client ' s pending queue is empty . may not work if there are people concurrently adding to the queue.
public static set < java class and method > resolve method call targets ( reference type receiver type , invoke instruction invoke instruction , constant pool gen cpg ) throws class not found exception { return resolve method call targets ( receiver type , invoke instruction , cpg , bool ) ; }	resolve possible instance method call targets.
private string safe ( string src ) { string buffer sb = new string buffer ( ) ; for ( int i = num ; i < src . length ( ) ; i ++ ) { char c = src . char at ( i ) ; if ( c >= num && c < num ) { sb . append ( c ) ; } else { sb . append ( str + ( int ) c + str ) ; } } return sb . to string ( ) ; }	convert a string to one in which any non - printable bytes are replaced by " < # # # > " where # # is the value of the byte .
public algorithm ( element el ) { required key = el . get attribute ( str ) ; jce name = el . get attribute ( str ) ; algorithm class = el . get attribute ( str ) ; if ( el . has attribute ( str ) ) { key length = integer . parse int ( el . get attribute ( str ) ) ; } else { key length = num ; } }	gets data from element.
protected abstract boolean is ssl ( ) ;	return if the socket is using ssl / tls.
private run consume run ( int offset ) { char ch = f text . char at ( offset ) ; int length = f text . length ( ) ; run run = get run ( ch ) ; while ( run . consume ( ch ) && offset < length - num ) { offset ++ ; ch = f text . char at ( offset ) ; } return run ; }	consumes a run of characters at the limits of which we introduce a break .
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add all ( collections . list ( super . list options ( ) ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public static string format for ui ( calendar today , calendar date ) { if ( today . get ( calendar . year ) == date . get ( calendar . year ) ) { if ( today . get ( calendar . day of year ) == date . get ( calendar . day of year ) ) { return str ; } return current year date format ( date . get time in millis ( ) ) ; } else { return format ( date . get time in millis ( ) ) ; } }	formats the date in ui - friendly way.
public output stream writer ( output stream out , charset encoder enc ) { super ( out ) ; if ( enc == null ) throw new null pointer exception ( str ) ; se = stream encoder . for output stream writer ( out , this , enc ) ; }	creates an outputstreamwriter that uses the given charset encoder .
public synchronized void free ( long pos , int length ) { int start = get block ( pos ) ; int blocks = get block count ( length ) ; block range x = new block range ( start , blocks ) ; block range next = free space . ceiling ( x ) ; if ( next == null ) { throw data utils . new illegal state exception ( data utils . error internal , str ) ; } block range prev = free space . lower ( x ) ; if ( prev != null ) { if ( prev . start + prev . blocks == start ) { prev . blocks += blocks ; if ( prev . start + prev . blocks == next . start ) { prev . blocks += next . blocks ; free space . remove ( next ) ; } return ; } } if ( start + blocks == next . start ) { next . start -= blocks ; next . blocks += blocks ; return ; } free space . add ( x ) ; }	mark the space as free .
public uri csrf token ( ) { uri builder = api builder ( ) ; builder . set parameter ( str , str ) ; builder . set parameter ( str , str ) ; builder . set parameter ( str , str ) ; return build ( builder ) ; }	uri to fetch a csrf token .
public distributed log multi stream writer build ( ) { preconditions . check argument ( ( null != streams && ! streams . is empty ( ) ) , str ) ; preconditions . check not null ( client , str ) ; preconditions . check not null ( codec , str ) ; preconditions . check argument ( first speculative timeout ms > num && first speculative timeout ms <= max speculative timeout ms && speculative backoff multiplier > num && max speculative timeout ms < request timeout ms , str ) ; return new distributed log multi stream writer ( streams , client , math . min ( buffer size , max logrecordset size ) , flush interval ms , request timeout ms , first speculative timeout ms , max speculative timeout ms , speculative backoff multiplier , codec , ticker , executor service ) ; }	build the multi stream writer .
private void write chars ( int number , char c ) throws io { for ( ; number > num ; number -- ) { writer . write ( c ) ; } }	writes an amount of chars , mostly spaces.
@ override public void error ( string msg , throwable t ) { if ( logger . is loggable ( level . severe ) ) { log ( self , level . severe , msg , t ) ; } }	log an exception ( throwable ) at the severe level with an accompanying message .
public int exit signal ( ) { return integer . parse int ( fields [ num ] ) ; }	( since linux 2.
public command ( ) { msg queue = new linked list < message > ( ) ; msg queue . clear ( ) ; }	instantiates a new command .
public synchronized int index of ( v item ) { return items . index of ( item ) ; }	looks for the particular item in the list and returns the index within the list ( starting from zero ) of that item if it is found , or - 1 otherwise.
protected void create node ( default mutable tree node top , string title , string info , string content , int line count ) { default mutable tree node thread info = null ; thread info = new default mutable tree node ( new thread info ( title , info , content , line count , get thread tokens ( title ) ) ) ; top . add ( thread info ) ; }	create a tree node with the provided information.
public peer clone ( ) { peer clone = new peer ( network . clone ( ) , address ) ; return clone ; }	create a deep copy of the peer which references the same remote peer but whose peernetwork is a distinct object .
public static string generate native guid ( string device type , string serial number , string file share native id ) { return string . format ( str + filesystem + str , device type map . get ( device type ) , serial number , file share native id ) ; }	generates the format storagesystem + serialnumber + filesystem + nativeid native guid for fileshare objects.
public str builder ensure capacity ( final int capacity ) { if ( capacity > buffer . length ) { final char [ ] old = buffer ; buffer = new char [ capacity * num ] ; system . arraycopy ( old , num , buffer , num , size ) ; } return this ; }	checks the capacity and ensures that it is at least the size specified .
private void on start tracking touch ( ) { m is dragging = bool ; }	this is called when the user has started touching this widget .
private static void create super forwarder ( class node target node , method node forwarder , final map < string , class node > generics spec ) { list < class node > interfaces = new array list < class node > ( traits . collect all interfaces reverse order ( target node , new linked hash set < class node > ( ) ) ) ; string name = forwarder . get name ( ) ; parameter [ ] forwarder parameters = forwarder . get parameters ( ) ; linked hash set < class node > traits = new linked hash set < class node > ( ) ; list < method node > super forwarders = new linked list < method node > ( ) ; for ( class node node : interfaces ) { if ( traits . is trait ( node ) ) { method node method = node . get declared method ( name , forwarder parameters ) ; if ( method != null ) { traits . add ( node ) ; super forwarders . add ( method ) ; } } } for ( method node super forwarder : super forwarders ) { do create super forwarder ( target node , super forwarder , traits . to array ( new class node [ traits . size ( ) ] ) , generics spec ) ; } }	creates , if necessary , a super forwarder method , for stackable traits .
public void test case15 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num } ; byte r bytes [ ] = { num } ; int a sign = - num ; int b sign = num ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . add ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	add two equal numbers of different signs.
public boolean is virtual pool accessible ( virtual pool resource ) { return permissions helper . tenant has usage acl ( uri . create ( user . get tenant id ( ) ) , resource ) ; }	verify whether the user in the filter has access to the vpool based on resource acl.
public void test timed invoke all null time unit ( ) throws throwable { executor service e = new fork join pool ( num ) ; pool cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; list < callable < string > > l = new array list < callable < string > > ( ) ; l . add ( new string task ( ) ) ; try { e . invoke all ( l , medium delay ms , null ) ; should throw ( ) ; } catch ( null pointer exception success ) { } } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }	timed invokeall ( null time unit ) throws nullpointerexception.
private static boolean intersects one of ( final d r , final collection < ? extends shape > shapes ) { if ( shapes . is empty ( ) ) { return bool ; } for ( final shape item : shapes ) { if ( item . intersects ( r ) ) { return bool ; } } return bool ; }	java . lang . boolean intersectsoneof ( java . awt . geom . rectangle2d , java . tools . collection ) function to test if the given 2d rectangle intersects any of the shapes given in the collection .
private void expected byte ( int position , int count ) throws utf { throw new utf ( localizer . get message ( str , integer . to string ( position ) , integer . to string ( count ) ) ) ; }	throws an exception for expected byte .
private list < string > check config list ( configuration config , string name ) { string peer i = config . get config ( name ) ; array list < string > peers = new array list < string > ( ) ; if ( peer i != null ) { for ( string ip : string utils . split ( peer i , str ) ) { peers . add ( ip ) ; } } return peers ; }	read a string list ( connected by ' , ' ) from given db config.
private void load external ( ) { properties properties = new properties ( ) ; try { properties . load from xml ( new file input stream ( properties path ) ) ; for ( string key : properties . string property names ( ) ) { external support . put ( key , properties . get property ( key ) ) ; } } catch ( io ignore ) { } }	load the properties for external utilities from a xml file.
public static uri parse uri ( string nuri , uri baseuri ) throws uri { int colon location = nuri . index of ( str ) ; int fragment location = get fragment location ( nuri ) ; if ( colon location == - num || colon location > fragment location ) { if ( baseuri == null ) throw new uri ( str + nuri + str + str , nuri ) ; } string protocol = nuri . substring ( num , colon location ) ; if ( protocol . equals ( str ) ) { return parse urn ( nuri , colon location , fragment location ) ; } else if ( protocol . equals ( str ) ) { return new uri ( nuri ) ; } else if ( protocol . equals ( str ) ) { return new uri ( nuri ) ; } else if ( protocol . equals ( str ) ) { return new uri ( nuri ) ; } else { return parse general uri ( nuri , colon location , fragment location ) ; } }	constructs an uri from a string.
protected void update us ( ) { try { set text ( m . get as text ( ) ) ; } catch ( illegal argument exception ex ) { } }	attempts to update the textfield value from the editor .
public file make dirty ( ) throws io { file f = file . create temp file ( str , str , repository location . get parent file ( ) ) ; file writer fw = new file writer ( f ) ; fw . write ( str + system . current time millis ( ) ) ; fw . flush ( ) ; fw . close ( ) ; return f ; }	creates a new file with dummy content inside the git repository to make it dirty .
public static big decimal allocated ( int p c id , int p c id ) throws sql { big decimal pay amt = null ; int c id = num ; string sql = str + str + str ; prepared statement pstmt = adempiere . prepare statement ( sql ) ; pstmt . set int ( num , p c id ) ; result set rs = pstmt . execute query ( ) ; if ( rs . next ( ) ) { pay amt = rs . get big decimal ( num ) ; c id = rs . get int ( num ) ; } rs . close ( ) ; pstmt . close ( ) ; if ( c id > num ) return pay amt ; int c id = num ; big decimal allocated amt = get allocated amt ( p c id , p c id , c id ) ; return currency . round ( allocated amt , p c id , null ) ; }	get allocated payment amount . - paymentallocated.
public static byte buffer process outbound package ( byte buffer ro data , int exchange id , boolean connection ok ) { ro data . rewind ( ) ; if ( build config . debug ) { xposed bridge . log ( str + integer . to string ( ro data . remaining ( ) ) ) ; } try { synchronized ( sync ) { } } catch ( throwable e ) { xposed bridge . log ( e ) ; } return null ; }	processes single package going from client to server rodata is created by allocate and had to have array.
public void initialize ( ) { if ( is closed . get ( ) ) { logger . info ( str ) ; actor config . create and get actor system ( ) ; http client store . init ( ) ; tcp ssh ping resource store . init ( ) ; parallel task manager . get instance ( ) ; is closed . set ( bool ) ; logger . info ( str ) ; } else { logger . debug ( str ) ; } }	initialize . create the httpclientstore , tcpclientstore.
@ not null private static text range process spaces ( @ not null helper helper , @ not null text range range , int tab width ) { char sequence indent = helper . get current line indent ( ) ; int start = math . max ( num , range . get start offset ( ) - helper . get current line start offset ( ) ) ; int end = math . min ( indent . length ( ) , range . get end offset ( ) - helper . get current line start offset ( ) ) ; int tabs number = num ; int indent offset = end ; for ( int i = start ; i < end ; i ++ ) { char c = indent . char at ( i ) ; if ( c == str ) { tabs number ++ ; } else if ( c != str ) { indent offset = i ; break ; } } if ( tabs number > num ) { helper . replace ( start , indent offset , string util . repeat ( str , indent offset - start - tabs number + tabs number * tab width ) ) ; return text range . create ( range . get start offset ( ) , range . get end offset ( ) - tabs number + tabs number * tab width ) ; } else { return range ; } }	converts tabulations to white spaces at the target line ' s indent space .
public void remove alarm ( final alarm alarm ) { if ( alarms . contains ( alarm ) ) alarms . remove ( alarm ) ; }	removes the given alarm object from the list of alarms .
public int read ( ) throws java . io . io { synchronized ( lock ) { char char array [ ] = new char [ num ] ; if ( read ( char array , num , num ) != - num ) { return char array [ num ] ; } return - num ; } }	read a single character.
protected void check parameters ( ) { if ( parameters != null ) { for ( int i = num , size = parameters . size ( ) ; i < size ; i ++ ) { parameter param = parameters . get ( i ) ; param . check set ( ) ; } } }	check if all parameters have been set .
private static properties create properties1 ( string conflation ) { properties props = new properties ( ) ; props . set property ( delta propagation , str ) ; props . set property ( mcast port , str ) ; props . set property ( locators , str ) ; props . set property ( conflate events , conflation ) ; return props ; }	create properties for a loner vm.
public static void c ( double [ ] x , double [ ] f , double [ ] c , int nx ) { int count1 = num ; int count2 = num ; double sum1 = num ; double sum2 = num ; double prod1 = num ; double prod2 = num ; double yj ; double pj ; double n = num ; double a = num ; for ( int j = num ; j <= nx ; j ++ ) { yj = x [ j - num ] - math . sin ( num * pi * x [ num ] + j * pi / nx ) ; pj = math . cos ( num * yj * pi / math . sqrt ( j + num ) ) ; if ( j % num == num ) { sum2 += yj * yj ; prod2 *= pj ; count2 ++ ; } else { sum1 += yj * yj ; prod1 *= pj ; count1 ++ ; } } f [ num ] = x [ num ] + num * ( num * sum1 - num * prod1 + num ) / ( double ) count1 ; f [ num ] = num - x [ num ] * x [ num ] + num * ( num * sum2 - num * prod2 + num ) / ( double ) count2 ; c [ num ] = f [ num ] + f [ num ] * f [ num ] - a * math . sin ( n * pi * ( f [ num ] * f [ num ] - f [ num ] + num ) ) - num ; }	evaluates the cf3 problem .
public static void close silently ( result set rs ) { if ( rs != null ) { try { rs . close ( ) ; } catch ( sql e ) { } } }	close a result set without throwing an exception .
public static void execute ( pool impl pool , function function , object args , member mapped argument member mapped arg , boolean all servers , byte has result , boolean is fn serialization reqd , string [ ] groups ) { list servers = null ; abstract op op = new execute function no ack op impl ( function , args , member mapped arg , has result , is fn serialization reqd , groups , all servers ) ; try { if ( all servers && groups . length == num ) { if ( logger . is debug enabled ( ) ) { logger . debug ( str + op . get message ( ) + str + pool ) ; } servers = pool . get current servers ( ) ; iterator i = servers . iterator ( ) ; while ( i . has next ( ) ) { pool . execute on ( ( server location ) i . next ( ) , op ) ; } } else { if ( logger . is debug enabled ( ) ) { logger . debug ( str + op . get message ( ) + str + pool + str + arrays . to string ( groups ) + str + all servers ) ; } pool . execute ( op , num ) ; } } catch ( exception ex ) { if ( logger . is debug enabled ( ) ) { logger . debug ( str + op . get message ( ) + str + pool , ex ) ; } if ( ex . get message ( ) != null ) throw new function exception ( ex . get message ( ) , ex ) ; else throw new function exception ( str , ex ) ; } }	does a execute function on a server using connections from the given pool to communicate with the server .
public static script create multi sig input script ( transaction signature ... signatures ) { return create multi sig input script ( arrays . as list ( signatures ) ) ; }	create a program that satisfies an op_checkmultisig program .
object proxy if return type is jdbc interface ( class < ? > return type , object to proxy ) { if ( to proxy != null ) { if ( util . is jdbc interface ( return type ) ) { class < ? > to proxy class = to proxy . get class ( ) ; return proxy . new proxy instance ( to proxy class . get class loader ( ) , util . get implemented interfaces ( to proxy class ) , get new jdbc interface proxy ( to proxy ) ) ; } } return to proxy ; }	if the given return type is or implements a jdbc interface , proxies the given object so that we can catch sql errors and fire a connection switch .
public final void empty ( ) { synchronized ( buffer ) { buffer . clear ( ) ; buffer map . clear ( ) ; } }	empties the synchrobuffer of all it ' s current content .
public void test moderately complex templating ( ) throws exception { html page page = get page ( str ) ; string text = page . as text ( ) ; assert true ( text . contains ( str ) ) ; }	added for issue 1552 .
private value range range by week ( temporal accessor temporal , temporal field field ) { int dow = localized day of week ( temporal ) ; int offset = start of week offset ( temporal . get ( field ) , dow ) ; value range field range = temporal . range ( field ) ; return value range . of ( compute week ( offset , ( int ) field range . get minimum ( ) ) , compute week ( offset , ( int ) field range . get maximum ( ) ) ) ; }	map the field range to a week range.
public object apply ( object in ) { if ( in instanceof has word ) { has word w = ( has word ) in ; string str = w . word ( ) ; string out str = americanize ( str , capitalize timex ) ; if ( ! out str . equals ( str ) ) { w . set word ( out str ) ; } return w ; } else { string str = ( string ) in ; return americanize ( str , capitalize timex ) ; } }	americanize the hasword or string coming in .
public void add way ref ( map way way , int node idx ) { if ( ways == null ) ways = new array list < way ref > ( num ) ; if ( ways . is empty ( ) || ways . get ( num ) != way ) ways . add ( new default way ref ( way , ( short ) node idx ) ) ; }	adds the information to the node that it is part of the specified way .
public double do cross validation ( iterable < t > data , int data size ) throws interrupted exception , execution exception { stats = new one variable stats ( ) ; log . info ( str + ( new date ( ) ) ) ; log . info ( str + num folds + str ) ; list < list < t > > splits = split data ( data , data size ) ; log . info ( str ) ; executor service executor = executors . new fixed thread pool ( num threads ) ; list < future task < double > > folds = new array list < > ( ) ; for ( int i = num ; i < num folds ; i ++ ) { list < t > training set = new array list < > ( ) ; for ( int j = num ; j < num folds ; j ++ ) { if ( j != i ) training set . add all ( splits . get ( j ) ) ; } list < t > test set = splits . get ( i ) ; future task < double > fold = create fold task ( training set , test set , i ) ; executor . execute ( fold ) ; folds . add ( fold ) ; } executor . shutdown ( ) ; executor . await termination ( timeout seconds , time unit . seconds ) ; for ( future task < double > fold : folds ) { stats . add ( fold . get ( ) ) ; } log . info ( str + ( new date ( ) ) ) ; return stats . mean ( ) ; }	note : this does not take care of shuffling or randomizing the data .
public entire text builder add background ( @ color int int bg color , int start , int end ) { background holder background holder = new background holder ( bg color , start , end ) ; m backgrounds . add ( background holder ) ; return this ; }	add background to text .
public boolean matches ( string filename ) { if ( exts == null ) return bool ; int j = filename . last index of ( str ) ; if ( j == - num || j == filename . length ( ) ) return bool ; string suffix = filename . substring ( j + num ) ; return exts . contains ( suffix ) ; }	returns true if a file with the given name is of this media type , i.
public rectangle [ ] compute gaps ( ) { array list < rectangle > ret = new array list < > ( ) ; rectangle gap = new rectangle ( ) ; for ( int i = num ; i < m rect list . length ; i ++ ) { rectangle rectangle a = m rect list [ i ] ; for ( int j = i + num ; j < m rect list . length ; j ++ ) { rectangle rectangle b = m rect list [ j ] ; boolean viable = calculate gap ( rectangle a , rectangle b , gap ) ; if ( viable ) { for ( int k = num ; k < m rect list . length ; k ++ ) { if ( k != j && k != i ) { if ( gap . intersects ( m rect list [ k ] ) ) { viable = bool ; break ; } } } } if ( viable ) { ret . add ( new rectangle ( gap ) ) ; } } } return ret . to array ( new rectangle [ ret . size ( ) ] ) ; }	build a array of rectangles representing the gaps used for debugging purposes.
public synchronized method count set collect hot methods ( int opt level , double threshold ) { if ( debug ) validity check ( ) ; array list < hot method recompilation event > collect = new array list < hot method recompilation event > ( ) ; collect hot opt methods internal ( num , collect , hotness to counts ( threshold ) , opt level ) ; int num hot methods = collect . size ( ) ; double [ ] num counts = new double [ num hot methods ] ; compiled method [ ] hot methods = new compiled method [ num hot methods ] ; for ( int i = num ; i < num hot methods ; i ++ ) { hot method event event = collect . get ( i ) ; hot methods [ i ] = event . get compiled method ( ) ; num counts [ i ] = event . get num samples ( ) ; } return new method count set ( hot methods , num counts ) ; }	collect the hot methods that have been compiled at the given opt level .
public synchronized void add ban ( long duration , string reason , string id ) { add line ( new ban message ( system . current time millis ( ) , duration , reason , id ) ) ; }	adds a single ban with the current time .
private void write header ( ) throws open stego exception { dct header = null ; try { header = new dct ( this . data length , this . file name , this . config ) ; if ( ( ( header . get header size ( ) + this . data length ) * num ) > ( this . img width * this . img height / ( dct . njpeg * dct . njpeg ) ) ) { throw new open stego exception ( null , lsb . namespace , lsb . image size insufficient ) ; } this . coord = new coordinates ( ( header . get header size ( ) + this . data length ) * num ) ; write ( header . get header data ( ) ) ; } catch ( io io ex ) { throw new open stego exception ( io ex ) ; } }	method to write header data to stream.
public int decrement subscriber count ( ) { if ( is available ( ) ) { return jmdns subscriber count . decrement and get ( ) ; } return num ; }	decrements the count of jmdns subscribers .
public static boolean add shapeless enchanting recipe ( item stack a result , enchantment [ ] a enchantments added , int [ ] a enchantment levels added , object [ ] a recipe ) { return add shapeless crafting recipe ( a result , a enchantments added , a enchantment levels added , bool , bool , bool , bool , a recipe ) ; }	shapeless crafting recipes . deletes conflicting recipes too .
public void start ( ) throws tomcat exception { if ( cat == null ) init ( ) ; cat . start ( ) ; }	this method starts the tomcat server .
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str , str , num , str ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options.
private boolean image outline ( default mutable tree node node ) { boolean is outline = bool ; if ( node != null ) { default mutable tree node parent node = ( default mutable tree node ) node . get parent ( ) ; if ( parent node != null ) { if ( parent node . get user object ( ) instanceof raster symbolizer ) { is outline = bool ; } } } return is outline ; }	check to see if symbolizer is an image outline .
private short add entry ( entry entry ) { pool . add ( entry ) ; if ( pool . size ( ) >= num ) { throw new illegal argument exception ( str ) ; } return ( short ) pool . size ( ) ; }	add a new constant pool entry and return its index .
private boolean load next page ( ) { result = pageable . get page ( query , skip , page size ) ; index = num ; if ( result == null || result . is empty ( ) ) { return bool ; } return bool ; }	retrieves results of next page of the query , and checks if a element is present in this new page .
public void close ( ) throws io { if ( ! closed ) { if ( uses default inflater ) inf . end ( ) ; in . close ( ) ; closed = bool ; } }	closes this input stream and releases any system resources associated with the stream .
public field analysis request add field type ( string field type name ) { if ( field types == null ) { field types = new linked list < > ( ) ; } field types . add ( field type name ) ; return this ; }	adds the given field type for analysis .
public static big fraction parse edit rate ( string edit rate ) { edit rate = edit rate . contains ( str ) ? r frame rate to edit rate ( edit rate ) : edit rate ; string [ ] parts = edit rate . split ( str ) ; try { if ( parts . length == num ) { return new big fraction ( long . parse long ( parts [ num ] ) , long . parse long ( parts [ num ] ) ) ; } else if ( parts . length == num ) { return new big fraction ( long . parse long ( parts [ num ] ) ) ; } } catch ( number format exception e ) { throw new conversion helper exception ( str , e ) ; } throw new conversion helper exception ( str ) ; }	returns a fraction corresponding to the given edit rate string .
public fst < t > finish ( ) throws io { final un compiled node < t > root = frontier [ num ] ; freeze tail ( num ) ; if ( root . input count < min suffix count1 || root . input count < min suffix count2 || root . num arcs == num ) { if ( fst . empty output == null ) { return null ; } else if ( min suffix count1 > num || min suffix count2 > num ) { return null ; } } else { if ( min suffix count2 != num ) { compile all targets ( root , last input . length ( ) ) ; } } fst . finish ( compile node ( root , last input . length ( ) ) . node ) ; if ( do pack fst ) { return fst . pack ( this , num , math . max ( num , ( int ) ( get node count ( ) / num ) ) , acceptable overhead ratio ) ; } else { return fst ; } }	returns final fst . note : this will return null if nothing is accepted by the fst .
public void on configuration ( contacts ops . view view , boolean first time in ) { m contacts view = new weak reference < > ( view ) ; if ( first time in ) { initialize account ( ) ; m cursor adapter = new simple cursor adapter ( view . get application context ( ) , r . layout . list layout , null , s columns to display , s column res ids , num ) ; } }	hook method dispatched by the genericactivity framework to initialize the contactsopsimpl object after it ' s been created .
public static final int random unset bit ( random r , bit set bits , final int max ) { if ( bits . cardinality ( ) == max + num ) { return - num ; } final int candidate = test util . next int ( r , num , max ) ; if ( bits . get ( candidate ) ) { final int lo = bits . previous clear bit ( candidate ) ; final int hi = bits . next clear bit ( candidate ) ; if ( lo < num && max < hi ) { fail ( str + bits . cardinality ( ) + str + bits . size ( ) ) ; } else if ( lo < num ) { return hi ; } else if ( max < hi ) { return lo ; } return ( ( candidate - lo ) < ( hi - candidate ) ) ? lo : hi ; } return candidate ; }	given a bitset , returns a random bit that is currently false , or - 1 if all bits are true.
@ override public void flush ( ) throws io { synchronized ( lock ) { out . flush ( ) ; } }	flushes this writer to ensure all pending data is sent out to the target writer.
public double std ( ) { if ( min == max || num == num ) { return num ; } double m = mean ( ) ; return math . sqrt ( sigmax2 / num - m * m ) ; }	calculate the population standard deviation . $ \ sqrt ( \ frac { \ sum ( x - m ) ^ 2 } { n } ) $.
public boolean contains instruction ( instruction handle handle ) { iterator < instruction handle > i = instruction iterator ( ) ; while ( i . has next ( ) ) { if ( i . next ( ) == handle ) { return bool ; } } return bool ; }	return whether or not the basic block contains the given instruction .
public string trim to size ( string str , int max string length ) { if ( str == null ) return null ; if ( str . length ( ) > max string length ) { string builder sb = new string builder ( str ) ; sb . set length ( max string length ) ; str = sb . to string ( ) ; } return str ; }	trim a given string to maxstringlength if it is over maxstringlength .
public subject login ( string username , string password ) { if ( string utils . is blank ( username ) || string utils . is blank ( password ) ) return null ; properties credentials = new properties ( ) ; credentials . set property ( resource constants . user name , username ) ; credentials . set property ( resource constants . password , password ) ; return login ( credentials ) ; }	convenient method for testing.
@ timed @ exception metered @ path ( str ) @ get @ produces ( application json ) public iterable < sanitized secret > secret listing v2 ( @ auth automation client automation client , @ query param ( str ) integer idx , @ query param ( str ) integer num , @ default value ( str ) @ query param ( str ) boolean newest first ) { if ( idx != null && num != null ) { if ( idx < num || num < num ) { throw new bad request exception ( str ) ; } return secret controller . get secrets batched ( idx , num , newest first ) ; } return secret controller . get sanitized secrets ( null , null ) ; }	retrieve listing of secrets . if " idx " and " num " are both provided , retrieve " num " names starting at " idx " from a list of secrets ordered by creation date , with order depending on " newestfirst " ( which defaults to " true " ).
public void deselect ( iterable < integer > positions ) { iterator < integer > entries = positions . iterator ( ) ; while ( entries . has next ( ) ) { deselect ( entries . next ( ) , entries ) ; } }	deselects all items at the positions in the iteratable.
public static string map2 oid ( string alg name ) { check cache version ( ) ; string result = alg2 oid map . get ( alg name . to upper case ( locale . us ) ) ; if ( result != null ) { return result ; } alg name mapper source s = source ; if ( s != null ) { return s . map name to oid ( alg name ) ; } return null ; }	returns oid for algname.
private void end list ( boolean ordered list ) { if ( ! m paragraph styles . is empty ( ) ) { accumulated paragraph style style = m paragraph styles . peek ( ) ; paragraph type type = style . get type ( ) ; if ( ( ordered list && ( type . is numbering ( ) || type == paragraph type . indentation ol ) ) || ( ! ordered list && ( type . is bullet ( ) || type == paragraph type . indentation ul ) ) ) { int indent = style . get relative indent ( ) ; if ( indent > num ) { style . set relative indent ( indent - num ) ; style . set absolute indent ( style . get absolute indent ( ) - num ) ; } else { m paragraph styles . pop ( ) ; } } else { m paragraph styles . pop ( ) ; end list ( ordered list ) ; } } }	handles ol and ul end tags.
public boolean is natural join column ( column c ) { return natural join columns != null && natural join columns . contains ( c ) ; }	check if the given column is a natural join column .
public int read ( byte [ ] b , int off , int len ) throws io { ensure open ( ) ; if ( b == null ) { throw new null pointer exception ( str ) ; } else if ( off < num || len < num || len > b . length - off ) { throw new index out of bounds exception ( ) ; } else if ( len == num ) { return num ; } int cnt = num ; while ( len > num && ! def . finished ( ) ) { int n ; if ( def . needs input ( ) ) { n = in . read ( buf , num , buf . length ) ; if ( n < num ) { def . finish ( ) ; } else if ( n > num ) { def . set input ( buf , num , n ) ; } } n = def . deflate ( b , off , len ) ; cnt += n ; off += n ; len -= n ; } if ( cnt == num && def . finished ( ) ) { reach eof = bool ; cnt = - num ; } return cnt ; }	reads compressed data into a byte array.
@ override public void passivate ( ) { cleanup user transaction ( ) ; super . passivate ( ) ; }	override passivate ( ) to ensure we always cleanup the usertransaction .
public builder delay ( long duration , time unit time unit ) { this . delay = time unit . to seconds ( duration ) ; return this ; }	set the time that should elapse before the job is queued by any server .
private boolean contains ( int part ) { return parts . contains ( part ) ; }	checks if partition set contains given partition .
int key count ( class clazz ) { map map = get ( clazz ) ; int count = map . size ( ) ; if ( map . contains key ( constructors key ) ) count -- ; if ( map . contains key ( generic get key ) ) count -- ; if ( map . contains key ( argtypes key ) ) count -- ; return count ; }	returns the number of introspected methods / properties that should be available via the templatehashmodel interface .
public mp4 stco box ( mp4 box header header , byte buffer original data buffer , int adjustment ) { this . header = header ; this . data buffer = original data buffer . slice ( ) ; data buffer . position ( data buffer . position ( ) + version flag length + other flag length ) ; this . no of off sets = utils . get int be ( data buffer , data buffer . position ( ) , ( data buffer . position ( ) + no of offsets length - num ) ) ; data buffer . position ( data buffer . position ( ) + no of offsets length ) ; for ( int i = num ; i < no of off sets ; i ++ ) { int offset = utils . get int be ( data buffer , data buffer . position ( ) , ( data buffer . position ( ) + no of offsets length - num ) ) ; offset = offset + adjustment ; data buffer . put ( utils . get size be ( offset ) ) ; } }	construct box from data and adjust offets accordingly.
public static void create opus ( config config ) { log . info ( str ) ; urban sim parameter config module v3 module = u . get urban sim parameter config and possibly convert ( config ) ; file temp file = new file ( module . get opus home ( ) ) ; temp file . mkdirs ( ) ; temp file = new file ( module . get mat ( ) ) ; temp file . mkdirs ( ) ; temp file = new file ( module . get mat ( ) ) ; temp file . mkdirs ( ) ; temp file = new file ( module . get mat ( ) ) ; temp file . mkdirs ( ) ; temp file = new file ( module . get mat ( ) ) ; temp file . mkdirs ( ) ; log . info ( str ) ; }	create new temp directories.
public static string lcfirst ( string input ) { return with first ( input , null ) ; }	returns the specified text but with the first character lowercase .
void compress ( int page , byte [ ] old ) { byte [ ] [ ] array = data ; if ( page >= array . length ) { return ; } byte [ ] d = array [ page ] ; if ( d != old ) { return ; } synchronized ( lzf ) { int len = lzf . compress ( d , block size , buffer , num ) ; if ( len <= block size ) { d = new byte [ len ] ; system . arraycopy ( buffer , num , d , num , len ) ; byte [ ] o = array [ page ] ; if ( o != old ) { return ; } array [ page ] = d ; } } }	compress the data in a byte array .
public hadoop process descriptor local process descriptor ( ) { return loc proc desc ; }	gets local process descriptor .
private pair < string , boolean > describe rain ( calendar calendar , int temperature mod ) { int month = calendar . get ( calendar . month ) ; month = num * math . abs ( month - num ) ; int hour = calendar . get ( calendar . hour of day ) ; hour = math . abs ( ( hour + num ) % num - num ) / num ; int temp = temperature . get value ( ) - hour - month + ( temperature mod * num ) ; logger . debug ( str + temp + str + temperature mod ) ; if ( temp <= - num ) { return new pair < string , boolean > ( str , boolean . false ) ; } return new pair < string , boolean > ( str , temp >= - num && thunder . get description ( num ) != null ) ; }	describe either rain or snow , depending on the time , temperature and temperature modifiers .
@ visible for testing @ called by native unchecked ( str ) public void add child ( bookmark node child ) { m children . add ( child ) ; }	adds a child to this node.
public void test get min crl ( ) { crl selector = new crl ( ) ; assert null ( str , selector . get min crl ( ) ) ; big integer min crl = new big integer ( str ) ; selector . set min crl ( min crl ) ; assert true ( str , min crl . equals ( selector . get min crl ( ) ) ) ; }	getmincrl ( ) method testing.
public void test when complete exceptional completion ( ) { for ( execution mode m : execution mode . values ( ) ) for ( boolean create incomplete : new boolean [ ] { bool , bool } ) { final atomic integer a = new atomic integer ( num ) ; final cf ex = new cf ( ) ; final completable future < integer > f = new completable future < > ( ) ; if ( ! create incomplete ) f . complete exceptionally ( ex ) ; final completable future < integer > g = m . when complete ( f , null ) ; if ( create incomplete ) f . complete exceptionally ( ex ) ; check completed with wrapped exception ( g , ex ) ; check completed exceptionally ( f , ex ) ; assert equals ( num , a . get ( ) ) ; } }	whencomplete action executes on exceptional completion , propagating source result .
@ override public string read ( string pattern ) { return read ( pattern . compile ( pattern , pattern . dotall | pattern . multiline ) ) ; }	will attempt to read the string matching the given parameter.
private string construct iscsi ( string system id , list < host storage domain > hsd list , string model ) { map < string , object > attribute map = new hash map < string , object > ( ) ; storage array array = new storage array ( system id ) ; add add op = new add ( hds . iscsi name for hsd target ) ; attribute map . put ( hds . storagearray , array ) ; attribute map . put ( hds . add , add op ) ; attribute map . put ( hds . model , model ) ; attribute map . put ( hds . hostgroup list , hsd list ) ; string add wwn = xml . get input xml ( hds . batch add wwn to hsd op , attribute map , hds . hitachi input xml context file , hds . hitachi smooks config file ) ; return add wwn ; }	constructs a batch query for given hsd ' s and each with a set of worldwidename ' s to add.
public static void try claim ( publication publication , buffer filler fill buffer , int length , int timeout , time unit time unit ) { if ( publication . is closed ( ) ) { throw new not connected exception ( ) ; } final buffer claim buffer claim = buffer claims . get ( ) ; final long start = system . nano time ( ) ; do { final long current = system . nano time ( ) ; if ( ( current - start ) > time unit . to nanos ( timeout ) ) { throw new timed out exception ( ) ; } final long offer = publication . try claim ( length , buffer claim ) ; if ( offer >= num ) { try { final mutable direct buffer buffer = buffer claim . buffer ( ) ; final int offset = buffer claim . offset ( ) ; fill buffer . fill ( offset , buffer ) ; break ; } finally { buffer claim . commit ( ) ; } } else if ( publication . not connected == offer ) { throw new not connected exception ( ) ; } } while ( bool ) ; }	sends a message using tryclaim.
protected boolean table exists ( table t ) throws sql { string sql = str + ( t . is temporary ( ) ? str : ( str + t . get schema ( ) + str ) ) + str + ( t . is temporary ( ) ? ( t . get schema ( ) + str ) : str ) + t . get name ( ) + str ; statement stmt = db conn . create statement ( ) ; try { result set rs = stmt . execute query ( sql ) ; return rs . next ( ) ; } finally { if ( stmt != null ) { try { stmt . close ( ) ; } catch ( sql e ) { } } } }	checks whether the given table exists in the currently connected database.
private void read unlocked thread ( ) { final long this thread id = thread . current thread ( ) . get id ( ) ; final integer entry = thread lock map . get ( this thread id ) ; assert entry != null ; if ( entry . int value ( ) == num ) { thread lock map . remove ( this thread id ) ; } else { thread lock map . put ( this thread id , entry . int value ( ) - num ) ; } }	track the # of read locks by thread iff this is a read / write index view .
boolean is single window standard offset ( ) { return window end . equals ( local date time . max ) && time definition == time definition . wall && fixed saving amount secs == null && last rule list . is empty ( ) && rule list . is empty ( ) ; }	checks if the window is empty .
public void add ( character ok ) { add ( ok . char value ( ) ) ; }	delegates to the corresponding type - specific method .
private workflow . method delete volumes method ( uri system uri , list < uri > volume ur ) { return new workflow . method ( str , system uri , volume ur ) ; }	return a workflow . method for deletevolumes .
public boolean remove ( accessible state state ) { if ( states == null ) { return bool ; } else { return states . remove element ( state ) ; } }	removes a state from the current state set.
public void test radix10 pos ( ) { string value = str ; int radix = num ; big integer a number = new big integer ( value , radix ) ; string result = a number . to string ( radix ) ; assert true ( result . equals ( value ) ) ; }	test positive number of radix 10.
public void output example xml ( print writer writer , attribute rule rule ) { writer . print ( str + rule . get name ( ) + str ) ; if ( rule . has example ( ) ) { writer . print ( rule . get example ( ) ) ; } else { output attribute value ( writer , rule . get attribute class ( ) ) ; } writer . print ( str ) ; }	outputs an example of a rule , using the syntax information .
public static double calculate julian date ( gregorian calendar cal ) { int year = cal . get ( calendar . year ) ; int month = cal . get ( calendar . month ) ; int day = cal . get ( calendar . day of month ) ; month ++ ; if ( ( month == num ) || ( month == num ) ) { year -= num ; month += num ; } int a = year / num ; int b = ( int ) ( num - a + ( a / num ) ) ; int c = ( int ) ( num * ( float ) year ) ; int d = ( int ) ( num * ( float ) ( month + num ) ) ; double julian date = ( double ) ( b + c + d + day ) + num ; return julian date ; }	given a date from a gregorian calendar , give back a julian date.
public boolean is upload in progress ( ) { return m upload started . get ( ) ; }	as soon as this method return true , upload can be cancel via cancel ( ) .
private int index of ( int tab id ) { return m tab id list . index of ( tab id ) ; }	finds the index of the given tab id .
public ndef message ( ndef record record , ndef record ... records ) { if ( record == null ) throw new null pointer exception ( str ) ; for ( ndef record r : records ) { if ( r == null ) { throw new null pointer exception ( str ) ; } } m records = new ndef record [ num + records . length ] ; m records [ num ] = record ; system . arraycopy ( records , num , m records , num , records . length ) ; }	construct an ndef message from one or more ndef records .
private int find checkpoint position ( int [ ] cids ) { if ( checkpoint period < num ) { return - num ; } if ( cids . length == num ) { throw new illegal argument exception ( ) ; } int first cid = cids [ num ] ; if ( ( first cid + num ) % checkpoint period == num ) { return cid position ( cids , first cid ) ; } else { int next ckp index = ( ( ( first cid / checkpoint period ) + num ) * checkpoint period ) - num ; if ( next ckp index <= cids [ cids . length - num ] ) { return cid position ( cids , next ckp index ) ; } } return - num ; }	iterates over the commands to find if the replica took a checkpoint.
private boolean read next line ( ) throws io { if ( header lines . has more elements ( ) ) { try { pos = num ; string line = ( header lines . next element ( ) + line seperator ) ; if ( ! header lines . has more elements ( ) ) { line += line seperator ; } curr line = line . get bytes ( str ) ; return bool ; } catch ( unsupported encoding exception e ) { throw new io ( str ) ; } } else { return bool ; } }	load the next header line if possible.
private boolean pause ( ) { try { u . await ( pause latch , remap pause , milliseconds ) ; return bool ; } catch ( ignite interrupted checked exception e ) { on done ( e ) ; return bool ; } }	pause to avoid crazy resending in case of topology changes .
public static input stream to input stream ( final char sequence input ) { return io . to input stream ( input , charset . default charset ( ) ) ; }	convert the specified charsequence to an input stream , encoded as bytes using the default character encoding of the platform .
public void write ( final int c ) throws io { if ( m writer != null ) m writer . write ( c ) ; if ( count >= buf length ) flush buffer ( ) ; if ( c < num ) { buf [ count ++ ] = ( byte ) ( c ) ; } else if ( c < num ) { buf [ count ++ ] = ( byte ) ( num + ( c > > num ) ) ; buf [ count ++ ] = ( byte ) ( num + ( c & num ) ) ; } else { buf [ count ++ ] = ( byte ) ( num + ( c > > num ) ) ; buf [ count ++ ] = ( byte ) ( num + ( ( c > > num ) & num ) ) ; buf [ count ++ ] = ( byte ) ( num + ( c & num ) ) ; } }	write a single character.
private static list < c > convert ( final i module , final list < operand > operands ) { final list < c > converted operands = new array list < c > ( ) ; for ( final operand operand : operands ) { converted operands . add ( module . create operand ( convert ( module , operand . get root node ( ) , null ) ) ) ; } return converted operands ; }	converts api operands to internal operands .
public static string xml escape ( string s ) { string builder sb = new string builder ( ) ; for ( int i = num ; i < s . length ( ) ; i ++ ) { char ch = s . char at ( i ) ; switch ( ch ) { case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : break ; default : sb . append ( ch ) ; break ; } } return sb . to string ( ) ; }	returns a form of " s " appropriate for including in an xml document , after escaping certain special characters ( e.
public boolean write header ( output stream os ) { try { write int ( os , cache magic ) ; write string ( os , key ) ; write string ( os , etag == null ? str : etag ) ; write long ( os , server date ) ; write long ( os , ttl ) ; write long ( os , soft ttl ) ; write string string map ( response headers , os ) ; os . flush ( ) ; return bool ; } catch ( io e ) { volley log . d ( str , e . to string ( ) ) ; return bool ; } }	writes the contents of this cacheheader to the specified outputstream .
@ visible for testing public bitmap ensure normalized icon ( bitmap icon , string origin ) { if ( icon == null || icon . get width ( ) == num ) { if ( m icon generator == null ) { int corner radius px = math . min ( m large icon width px , m large icon height px ) / num ; m icon generator = new rounded icon generator ( m large icon width px , m large icon height px , corner radius px , notification icon bg color , notification text size dp * m density ) ; } return m icon generator . generate icon for url ( origin , bool ) ; } if ( icon . get width ( ) > m large icon width px || icon . get height ( ) > m large icon height px ) { return icon . create scaled bitmap ( icon , m large icon width px , m large icon height px , bool ) ; } return icon ; }	ensures the availability of an icon for the notification.
protected boolean [ ] can handle zero training ( boolean nominal predictor , boolean numeric predictor , boolean string predictor , boolean date predictor , boolean relational predictor , boolean multi instance , int class type ) { print ( str ) ; print attribute summary ( nominal predictor , numeric predictor , string predictor , date predictor , relational predictor , multi instance , class type ) ; print ( str ) ; array list < string > accepts = new array list < string > ( ) ; accepts . add ( str ) ; accepts . add ( str ) ; int num train = num , num classes = num , missing level = num ; boolean predictor missing = bool , class missing = bool ; return run basic test ( nominal predictor , numeric predictor , string predictor , date predictor , relational predictor , multi instance , class type , missing level , predictor missing , class missing , num train , num classes , accepts ) ; }	checks whether the scheme can handle zero training instances .
public sql ( string type name , string sql expression ) { this ( sql expression , type name , null , default query result type , null ) ; }	creates a sqlquery using the specified type and expression .
private static void check offset ( string value , int offset , char expected ) throws index out of bounds exception { char found = value . char at ( offset ) ; if ( found != expected ) { throw new index out of bounds exception ( str + expected + str + found + str ) ; } }	check if the expected character exist at the given offset of the.
public boolean is in net ( string host , string pattern , string mask ) { host = dns resolve ( host ) ; if ( host == null || host . length ( ) == num ) { return bool ; } long lhost = parse ip address to long ( host ) ; long lpattern = parse ip address to long ( pattern ) ; long lmask = parse ip address to long ( mask ) ; return ( lhost & lmask ) == lpattern ; }	returns true if the ip address of the host matches the specified ip address pattern.
protected static pair < string , string > rrx register ( final long offset , final i environment , final list < reil instruction > instructions , final string register node value ) { final string shifter operand = environment . get next variable string ( ) ; final string shifter carry out = environment . get next variable string ( ) ; final string tmp var1 = environment . get next variable string ( ) ; final string tmp var2 = environment . get next variable string ( ) ; final string tmp var3 = environment . get next variable string ( ) ; long base offset = offset ; instructions . add ( reil helpers . create bsh ( base offset ++ , byte size , str , word size , thirty one set , d word size , tmp var1 ) ) ; instructions . add ( reil helpers . create bsh ( base offset ++ , d word size , register node value , byte size , str + one set , d word size , tmp var2 ) ) ; instructions . add ( reil helpers . create or ( base offset ++ , d word size , tmp var1 , d word size , tmp var2 , d word size , tmp var3 ) ) ; instructions . add ( reil helpers . create and ( base offset ++ , d word size , tmp var3 , d word size , bit mask all bits set , d word size , shifter operand ) ) ; instructions . add ( reil helpers . create and ( base offset ++ , d word size , register node value , byte size , string . value of ( num ) , byte size , shifter carry out ) ) ; return new pair < string , string > ( shifter operand , shifter carry out ) ; }	< rm > , rrx operation : shifter_operand = ( c flag logical_shift_left 31 ) or ( rm logical_shift_right 1 ) shifter_carry_out = rm [ 0 ].
public int enumerate ( thread [ ] threads ) { return enumerate ( threads , bool ) ; }	iterates over all active threads in this group ( and its sub - groups ) and stores the threads in the given array.
public void find and undo ( object some obj ) { if ( some obj instanceof layer handler ) { logger . fine ( str ) ; if ( get layer handler ( ) == ( layer handler ) some obj ) { set layer handler ( null ) ; } } if ( controls != null && some obj != this ) { controls . find and undo ( some obj ) ; } if ( some obj instanceof layer ) { pane look up . remove ( ( layer ) some obj ) ; } }	beancontextmembershiplistener method . called when an object has been removed from the parent beancontext . if a layerhandler is removed , and it ' s the current one being listened to , then the layers in the panel will be wiped clean .
public void start ( ) { log . info ( str , this . name , this . frequency in secs ) ; stopped = bool ; thread dr health monitor thread = new thread ( this ) ; dr health monitor thread . set name ( this . name ) ; dr health monitor thread . start ( ) ; }	start the health monitor.
public void connect ( string event source url ) throws io { log . entering ( class name , str , event source url ) ; if ( stream != null ) { log . warning ( str ) ; throw new illegal argument exception ( str ) ; } stream = new sse event stream ( event source url ) ; stream . set listener ( event stream listener ) ; stream . connect ( ) ; }	connects the eventsource instance to the stream location .
private static string method name ( @ non nls final string method ) { return ssh . handler name + str + method ; }	get the full method name.
public data row remove data row ( int index ) { return data list . remove ( index ) ; }	convenience method for removing data rows .
public void put ( object key , object value ) { int bucket = ( key . hash code ( ) & num ) % f table size ; entry entry = search ( key , bucket ) ; if ( entry != null ) { entry . value = value ; } else { entry = new entry ( key , value , f buckets [ bucket ] ) ; f buckets [ bucket ] = entry ; f num ++ ; } }	adds the key / value mapping to the key table.
public void value changed ( list selection event e ) { if ( table == null ) { return ; } int row = table . get selected row ( ) ; if ( log . is debug enabled ( ) ) { log . debug ( str + row ) ; } if ( row >= num ) { add button . set enabled ( bool ) ; add button . set tool tip text ( null ) ; if ( type != null && type . equals ( str ) ) { make icon map ( pick list model . get bean at ( row ) ) ; clear icon panel ( ) ; do icon panel ( ) ; } } else { add button . set enabled ( bool ) ; add button . set tool tip text ( bundle . get message ( str ) ) ; } validate ( ) ; }	when a pick list is installed , table selection controls the add button.
public static boolean is intermediate table ( string table name , sq db ) { if ( ! text utils . is empty ( table name ) ) { if ( table name . matches ( str ) ) { cursor cursor = null ; try { cursor = db . query ( const . table schema . table name , null , null , null , null , null , null ) ; if ( cursor . move to first ( ) ) { do { string table name db = cursor . get string ( cursor . get column index or throw ( const . table schema . column name ) ) ; if ( table name . equals ignore case ( table name db ) ) { int table type = cursor . get int ( cursor . get column index or throw ( const . table schema . column type ) ) ; if ( table type == const . table schema . intermediate join table ) { return bool ; } break ; } } while ( cursor . move to next ( ) ) ; } } catch ( exception e ) { e . print stack trace ( ) ; } finally { if ( cursor != null ) { cursor . close ( ) ; } } } } return bool ; }	judge the table name is an intermediate table or not .
public static void initialize ( file help dir ) throws help exception { if ( help dir . is directory ( ) && help dir . exists ( ) ) help manager . help dir = help dir ; else throw new help exception ( str + help dir . get absolute path ( ) , null ) ; }	initialize help . this must be called before fetching a help manager .
public real matrix create ( ) { real matrix rotation = new identity matrix ( ) ; for ( plane plane : planes ) { double theta = plane . get theta ( ) ; if ( double . is na n ( theta ) ) { continue ; } rotation = rotation . multiply ( new rotation matrix ( plane . get first axis ( ) , plane . get second axis ( ) , theta ) ) ; } return rotation ; }	returns the rotation matrix resulting from applying all 2d rotation planes and angles added to this builder .
public static string to upper case ( string str ) { return str . to upper case ( locale . english ) ; }	converts the characters in this string to upper case .
public boolean is declared entity ( string entity name ) { entity entity = ( entity ) f entities . get ( entity name ) ; return entity != null ; }	checks whether an entity given by name is declared .
private void open context menu ( mouse event e ) { if ( e . is popup trigger ( ) ) { select clicked ( e , bool ) ; list < removed list item > selected items = list . get selected values list ( ) ; list < stream info > selected = new array list < > ( ) ; for ( removed list item item : selected items ) { selected . add ( item . get stream info ( ) ) ; } stream infos context menu m = new stream infos context menu ( selected , bool ) ; for ( context menu listener cml : context menu listeners ) { m . add context menu listener ( cml ) ; } m . show ( list , e . get x ( ) , e . get y ( ) ) ; } }	open context menu for this user , if the event points at one .
private boolean put ( boolean is root , vector names , int len , object value ) { if ( len == num ) { if ( is root ) { if ( root value != null ) return bool ; root value = value ; } else { if ( other value != null ) return bool ; other value = value ; } return bool ; } else { object name = names . element at ( len - num ) ; context map nested map = ( context map ) name table . get ( name ) ; if ( nested map == null ) { nested map = new context map ( ) ; name table . put ( name , nested map ) ; } return nested map . put ( is root , names , len - num , value ) ; } }	adds a single path ( isroot , names ) and a mode to be used for this path = context .
protected void queue ( final path file ) throws interrupted exception { if ( null != base && file . starts with ( base ) ) { queue . put ( file . subpath ( base . get name count ( ) , file . get name count ( ) ) ) ; } else { queue . put ( file ) ; } }	queue a result from the scanner.
public input stream open path ( ) throws io { path file path = paths . get ( path ( ) ) ; if ( files . exists ( file path ) ) { logger . info ( str , file path ) ; return files . new input stream ( file path ) ; } url resource url = resources . get resource ( path ( ) ) ; logger . info ( str , resource url ) ; return resource url . open stream ( ) ; }	if the path does not exist on the filesystem , it is resolved as a resource .
public static string replace characters ( final conversion method conversion method , final string input , final int from character , final int to character , final string wrap ) { string converted text = input ; for ( int i = from character ; i <= to character ; i ++ ) { final string character to replace = new string ( character . to chars ( i ) ) ; if ( wrap != null ) { converted text = converted text . replace ( character to replace , wrap + convert text ( conversion method , character to replace ) + wrap ) ; } else { converted text = converted text . replace ( character to replace , convert text ( conversion method , character to replace ) ) ; } } return converted text ; }	replaces characters using the given conversion method .
public static byte [ ] hmac sha1 ( byte [ ] key bytes , byte [ ] text ) throws no such algorithm exception , invalid key exception { mac hmac sha1 ; try { hmac sha1 = mac . get instance ( str ) ; } catch ( final no such algorithm exception nsae ) { hmac sha1 = mac . get instance ( str ) ; } final secret key spec mac key = new secret key spec ( key bytes , str ) ; hmac sha1 . init ( mac key ) ; return hmac sha1 . do final ( text ) ; }	this method uses the jce to provide the hmac - sha - 1 algorithm.
public static byte [ ] read bytes and close ( input stream in , int length ) throws io { try { if ( length <= num ) { length = integer . max value ; } int block = math . min ( constants . io buffer size , length ) ; byte array output stream out = new byte array output stream ( block ) ; copy ( in , out , length ) ; return out . to byte array ( ) ; } catch ( exception e ) { throw db exception . convert to io ( e ) ; } finally { in . close ( ) ; } }	read a number of bytes from an input stream and close the stream .
public ident value as ident value ( ) { if ( ! ident is set ) { ident val = ident value . get by ident string ( css primitive value . get css text ( ) ) ; ident is set = bool ; } return ident val ; }	description of the method.
public final test suite build ( ) { root suite = new test suite ( get suite name ( ) ) ; current classname = null ; try { for ( test method test : test grouping . get tests ( ) ) { if ( satisfies all predicates ( test ) ) { add test ( test ) ; } } if ( test cases . size ( ) > num ) { for ( test case test case : test cases ) { if ( satisfies all predicates ( new test method ( test case ) ) ) { add test ( test case ) ; } } } } catch ( exception exception ) { log . i ( str , str , exception ) ; test suite suite = new test suite ( get suite name ( ) ) ; suite . add test ( new failed to create tests ( exception ) ) ; return suite ; } return root suite ; }	call this method once you ' ve configured your builder as desired .
public javax . naming . binding next ( ) throws naming exception { if ( more && counter >= binding list . value . length ) { get more ( ) ; } if ( more && counter < binding list . value . length ) { org . omg . cos naming . binding bndg = binding list . value [ counter ] ; counter ++ ; return map binding ( bndg ) ; } else { throw new no such element exception ( ) ; } }	returns the next binding in the list .
protected < t extends ast > t move node ( t old node , ast rewrite ) { t moved node ; if ( ast . is existing node ( old node ) ) moved node = ast . create move target ( rewrite , old node ) ; else moved node = ast . copy subtree ( rewrite . get ast ( ) , old node ) ; return moved node ; }	if this occurrence update is called from within a declaration update ( i.
@ ignore @ test public void should be faster when running processing in parallel ( ) throws exception { test mojo with configurable wro manager factory with valid config file set ( ) ; final long begin = system . current time millis ( ) ; victim . set parallel processing ( bool ) ; test mojo with configurable wro manager factory with valid config file set ( ) ; final long end serial = system . current time millis ( ) ; victim . set parallel processing ( bool ) ; test mojo with configurable wro manager factory with valid config file set ( ) ; final long end parallel = system . current time millis ( ) ; final long serial = end serial - begin ; final long parallel = end parallel - end serial ; log . info ( str , serial ) ; log . info ( str , parallel ) ; assert true ( string . format ( str , serial , parallel ) , serial > parallel ) ; }	ignoring this test , since it is not reliable .
public void add consumer type ( attribute type type ) { if ( ! consumer types . contains ( type ) ) { consumer types . add ( type ) ; } }	add a new type of consumer .
public final void print verbose message ( final localizable message msg ) { if ( is verbose ( ) ) { out . println ( wrap ( msg ) ) ; } }	displays a message to the output stream if verbose mode is enabled .
@ override public boolean is scraped ( ) { if ( ! scraped ) { if ( ! plot . is empty ( ) && ! ( year . is empty ( ) || year . equals ( str ) ) && ! ( genres == null || genres . size ( ) == num ) && ! ( actors == null || actors . size ( ) == num ) ) { return bool ; } } return scraped ; }	checks if this tv show has been scraped.
public void check ( final int api ) { if ( api == opcodes . as ) { if ( visible type annotations != null && visible type annotations . size ( ) > num ) { throw new runtime exception ( ) ; } if ( invisible type annotations != null && invisible type annotations . size ( ) > num ) { throw new runtime exception ( ) ; } for ( field node f : fields ) { f . check ( api ) ; } for ( method node m : methods ) { m . check ( api ) ; } } }	checks that this class node is compatible with the given asm api version.
public static string rtf ( string s ) { int ln = s . length ( ) ; int first esc idx = - num ; int last esc idx = num ; int plus out ln = num ; for ( int i = num ; i < ln ; i ++ ) { char c = s . char at ( i ) ; if ( c == str || c == str || c == str ) { if ( first esc idx == - num ) { first esc idx = i ; } last esc idx = i ; plus out ln ++ ; } } if ( first esc idx == - num ) { return s ; } else { char [ ] esced = new char [ ln + plus out ln ] ; if ( first esc idx != num ) { s . get chars ( num , first esc idx , esced , num ) ; } int dst = first esc idx ; for ( int i = first esc idx ; i <= last esc idx ; i ++ ) { char c = s . char at ( i ) ; if ( c == str || c == str || c == str ) { esced [ dst ++ ] = str ; } esced [ dst ++ ] = c ; } if ( last esc idx != ln - num ) { s . get chars ( last esc idx + num , ln , esced , dst ) ; } return string . value of ( esced ) ; } }	rich text format encoding ( does not replace line breaks ).
public string to string ( cp info constant pool [ ] ) { return integer . to string ( ( int ) bytes ) ; }	returns a string representation of this entry .
public inet network ( inet address inet address , int subnet bits ) { inet address = inet address ; address = inet address . get address ( ) ; if ( subnet bits < num ) subnet bits = num * address . length ; subnet bits = subnet bits ; subnet byte = subnet bits / num ; subnet mask = ~ ( ( num << ( num - subnet bits % num ) ) - num ) & num ; }	create a internet mask .
@ override public hierarchy wrapper operation create sub operation ( ) { return new to string operation ( builder , base indent ) ; }	add the string to build and growing indent to sub operation.
protected final boolean execute ( ) throws ade exception { logger . info ( str + m request type . name ( ) ) ; final long start = system . current time millis ( ) ; final boolean success = do control logic ( ) ; final long total = system . current time millis ( ) - start ; logger . info ( m request type . name ( ) + ( success ? str : str ) + str + milliseconds to human time ( total ) ) ; return success ; }	call the docontrollogic ( ) method defined in subclass , and provide additional traces , result handling to the docontrollogic ( ) .
public abstract json value sync ( ) throws synchronization exception ;	performs the sync operation .
private boolean valid consist ( ) { int c n = valid consist ( consist text field . get text ( ) ) ; if ( c n == - num ) { consist status . set text ( rb . get string ( str ) ) ; j . show message dialog ( this , rb . get string ( str ) , rb . get string ( str ) , j . error message ) ; return bool ; } return bool ; }	check for valid consist , popup error message if not.
private void activity ( ) { connection checked count = num ; }	notifies the activity tracker that there was activity on the connection .
public void remove ( int position ) { m data . remove ( position ) ; notify item removed ( position + get header layout count ( ) ) ; }	remove the item associated with the specified position of adapter.
public async buffered output stream ( output stream out , int buf size , int max buffers ) { super ( out ) ; buffers = new concurrent linked deque < > ( ) ; buf = new byte [ buf size ] ; flusher thread . start ( ) ; }	creates an asynchronous buffered output stream .
public boolean startlist contains ( string x ) { if ( startwords == null ) return bool ; return startwords . contains ( x ) ; }	returns false if term is not in startlist , true otherwise ( including if no startlist exists ) .
private void close media info ( ) { if ( media info != null ) { media info . close ( ) ; media info = null ; } mi snapshot = null ; }	closes the connection to the mediainfo lib .
public void add header ( final header header ) { headers . add ( header ) ; }	adds the given header to the group.
private void read version ( input node node , object source , label label ) throws exception { object value = read instance ( node , source , label ) ; class expect = type . get type ( ) ; if ( value != null ) { version version = context . get version ( expect ) ; double actual = version . revision ( ) ; if ( ! value . equals ( revision ) ) { revision . compare ( actual , value ) ; } } }	this method is used to read the version from the provided input node.
protected ignite start grid with igfs ( string grid name , string igfs name , igfs mode mode , @ nullable igfs secondary file system secondary fs , @ nullable igfs ipc endpoint configuration rest cfg ) throws exception { file system configuration igfs cfg = new file system configuration ( ) ; igfs cfg . set data cache name ( str ) ; igfs cfg . set meta cache name ( str ) ; igfs cfg . set name ( igfs name ) ; igfs cfg . set block size ( igfs block size ) ; igfs cfg . set default mode ( mode ) ; igfs cfg . set ipc endpoint configuration ( rest cfg ) ; igfs cfg . set secondary file system ( secondary fs ) ; igfs cfg . set prefetch blocks ( prefetch blocks ) ; igfs cfg . set sequential reads before prefetch ( seq reads before prefetch ) ; cache configuration data cache cfg = default cache configuration ( ) ; data cache cfg . set name ( str ) ; data cache cfg . set cache mode ( partitioned ) ; data cache cfg . set near configuration ( null ) ; data cache cfg . set write synchronization mode ( cache write synchronization mode . full sync ) ; data cache cfg . set affinity mapper ( new igfs group data blocks key mapper ( num ) ) ; data cache cfg . set backups ( num ) ; data cache cfg . set atomicity mode ( transactional ) ; data cache cfg . set off heap max memory ( num ) ; cache configuration meta cache cfg = default cache configuration ( ) ; meta cache cfg . set name ( str ) ; meta cache cfg . set cache mode ( replicated ) ; meta cache cfg . set write synchronization mode ( cache write synchronization mode . full sync ) ; meta cache cfg . set atomicity mode ( transactional ) ; ignite configuration cfg = new ignite configuration ( ) ; cfg . set grid name ( grid name ) ; tcp discovery spi disco spi = new tcp discovery spi ( ) ; disco spi . set ip finder ( new tcp discovery vm ip finder ( bool ) ) ; cfg . set discovery spi ( disco spi ) ; cfg . set cache configuration ( data cache cfg , meta cache cfg ) ; cfg . set file system configuration ( igfs cfg ) ; cfg . set local host ( str ) ; cfg . set connector configuration ( null ) ; return g . start ( cfg ) ; }	start grid with igfs .
private list < statistics > remove failed ( list < statistics > statistics ) { list < statistics > result = new array list < > ( ) ; for ( statistics statistic : statistics ) { if ( statistic . get succeeded ( ) ) result . add ( statistic ) ; } return result ; }	returns a list which contains the succeeded statistic objects of the given statistics list.
public void add associated gefahr ( gefaehrdungs umsetzung gefaehrdung ) { if ( ! associated gefaehrdungen . contains ( gefaehrdung ) ) { associated gefaehrdungen . add ( gefaehrdung ) ; } }	adds a gefaehrdung to the list of all gefaehrdungen if gefaehrdung not already exits .
public static byte [ ] pack byte buffer into single byte array ( byte buffer [ ] byte buffer arr ) { if ( null == byte buffer arr || byte buffer arr . length == num ) { return null ; } int no of col = byte buffer arr . length ; short to determine length of byte arr = num ; short offset len = ( short ) ( no of col * num + to determine length of byte arr ) ; int total bytes = calculate total bytes ( byte buffer arr ) + offset len ; byte buffer buffer = byte buffer . allocate ( total bytes ) ; buffer . put short ( ( short ) ( total bytes - to determine length of byte arr ) ) ; buffer . put short ( offset len ) ; for ( int index = num ; index < byte buffer arr . length - num ; index ++ ) { byte buffer individual col = byte buffer arr [ index ] ; int no of bytes = individual col . capacity ( ) ; buffer . put short ( ( short ) ( offset len + no of bytes ) ) ; offset len += no of bytes ; individual col . rewind ( ) ; } for ( int index = num ; index < byte buffer arr . length ; index ++ ) { byte buffer individual col = byte buffer arr [ index ] ; buffer . put ( individual col . array ( ) ) ; } buffer . rewind ( ) ; return buffer . array ( ) ; }	this method will form one single byte [ ] for all the high card dims .
public void connect ( socket address endpoint , int timeout ) throws io { if ( endpoint == null ) throw new illegal argument exception ( str ) ; if ( timeout < num ) throw new illegal argument exception ( str ) ; if ( is closed ( ) ) throw new socket exception ( str ) ; if ( ! old impl && is connected ( ) ) throw new socket exception ( str ) ; if ( ! ( endpoint instanceof inet socket address ) ) throw new illegal argument exception ( str ) ; inet socket address epoint = ( inet socket address ) endpoint ; inet address addr = epoint . get address ( ) ; int port = epoint . get port ( ) ; check address ( addr , str ) ; security manager security = system . get security manager ( ) ; if ( security != null ) { if ( epoint . is unresolved ( ) ) security . check connect ( epoint . get host name ( ) , port ) ; else security . check connect ( addr . get host address ( ) , port ) ; } if ( ! created ) create impl ( bool ) ; if ( ! old impl ) impl . connect ( epoint , timeout ) ; else if ( timeout == num ) { if ( epoint . is unresolved ( ) ) impl . connect ( addr . get host name ( ) , port ) ; else impl . connect ( addr , port ) ; } else throw new unsupported operation exception ( str ) ; connected = bool ; bound = bool ; }	connects this socket to the server with a specified timeout value.
private pair < hash step type , hash chain type > fetch hash step ( string uri , hash chain type current chain ) throws exception { int hash index = uri . index of ( str ) ; if ( hash index < num ) { throw new coded exception ( x malformed hash chain , str , uri ) ; } string base uri = uri . substring ( num , hash index ) ; string fragment = uri . substring ( hash index + num ) ; if ( fragment . is empty ( ) ) { throw new coded exception ( x malformed hash chain , str , uri ) ; } hash chain type hash chain ; if ( base uri . is empty ( ) ) { hash chain = current chain ; } else { hash chain = get hash chain ( base uri ) ; } for ( hash step type step : hash chain . get hash step ( ) ) { if ( fragment . equals ( step . get id ( ) ) ) { return new immutable pair < > ( step , hash chain ) ; } } throw new coded exception ( x malformed hash chain , str , uri ) ; }	retrieve hash step based on the uri .
@ suppress warnings ( str ) public static boolean load by current classloader ( string cls name ) { if ( cls name . starts with ( str ) ) return bool ; if ( cls name . starts with ( str ) ) { if ( cls name . contains ( str ) || cls name . contains ( str ) || cls name . contains ( str ) ) return bool ; } return bool ; }	check whether file must be loaded with current class loader , or normal delegation model should be used.
public void decrement targets count all ( ) { final long decrement and get = targets count all . decrement and get ( ) ; if ( decrement and get < num ) { targets count all . set ( num ) ; } }	decrement the targets all counter .
private void add not available business object data statuses ( list < business object data status > not available statuses , list < storage unit entity > storage unit entities , set < business object data entity > archived business object data entities ) { for ( storage unit entity storage unit entity : storage unit entities ) { not available statuses . add ( create not available business object data status ( storage unit entity , archived business object data entities ) ) ; } }	adds business object data status instances created from the list of storage unit entities to the specified list of not - available statuses .
private list < jdbc statement > create default query jdbc statements ( ) { list < jdbc statement > jdbc statements = new array list < > ( ) ; { jdbc statement jdbc statement = new jdbc statement ( ) ; jdbc statement . set type ( jdbc statement type . query ) ; jdbc statement . set sql ( mock jdbc operations . case 1 sql ) ; jdbc statements . add ( jdbc statement ) ; } return jdbc statements ; }	returns a valid list of jdbc query statements . it contains only 1 statement , and the statement is case_1_sql in mock jdbc ( success , result 1 ).
private void test memory spatial index ( ) throws sql { delete db ( str ) ; connection conn = get connection ( url ) ; statement stat = conn . create statement ( ) ; stat . execute ( str ) ; stat . execute ( str ) ; stat . execute ( str ) ; stat . execute ( str ) ; result set rs ; rs = stat . execute query ( str + str + str ) ; assert false ( rs . next ( ) ) ; rs = stat . execute query ( str + str ) ; rs . next ( ) ; if ( config . mv store ) { assert contains ( rs . get string ( num ) , str ) ; } stat . execute query ( str + str ) ; stat . execute query ( str + str ) ; rs = stat . execute query ( str + str ) ; assert true ( rs . next ( ) ) ; rs = stat . execute query ( str + str ) ; assert true ( rs . next ( ) ) ; rs = stat . execute query ( str + str ) ; assert false ( rs . next ( ) ) ; stat . execute ( str ) ; conn . close ( ) ; delete db ( str ) ; }	test the in the in - memory spatial index.
public static boolean is valid ( date expiration date ) { date current date = new date ( ) ; string formatted date = date format . format ( current date ) ; current date = convert date ( formatted date ) ; boolean is expired = current date . after ( expiration date ) ; boolean is equal = current date . equals ( expiration date ) ; if ( is expired == bool || is equal == bool ) { return bool ; } return bool ; }	validate the token expiration date .
public long content length ( ) { long size ; try { size = long . parse long ( request . get header ( file upload . content length ) ) ; } catch ( number format exception e ) { size = request . get content length ( ) ; } return size ; }	retrieve the content length of the request .
public void test zero pos ( ) { string num a = str ; string num b = str ; string res = str ; big integer a number = new big integer ( num a ) ; big integer b number = new big integer ( num b ) ; big integer result = a number . xor ( b number ) ; assert true ( res . equals ( result . to string ( ) ) ) ; }	xor for zero and a positive number.
public check box add listener ( listener listener ) { if ( listener != null && ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } return this ; }	adds a listener to this check box so that it will be notificed on certain user actions.
private void take picture ( ) { log . d ( tag , str ) ; lock focus ( ) ; }	initiate a still image capture .
public static string show dialog ( final component component , final string title , final object message , final string ... buttons ) { return show dialog ( j . get frame for component ( component ) , title , message , j . plain message , buttons ) ; }	show a new modal dialog and block until the user press a button of closes the dialog.
public static void encode ( input stream in , writer out ) throws io { int column = num ; while ( bool ) { int byte1 = in . read ( ) ; int byte2 = in . read ( ) ; int byte3 = in . read ( ) ; if ( byte1 < num ) { return ; } if ( column >= num ) { column = num ; out . write ( str ) ; } out . write ( charset [ byte1 > > num ] ) ; int index = ( byte1 & num ) << num ; if ( byte2 < num ) { out . write ( charset [ index ] ) ; out . write ( padding char ) ; out . write ( padding char ) ; return ; } index += byte2 > > num ; out . write ( charset [ index ] ) ; index = ( byte2 & num ) << num ; if ( byte3 < num ) { out . write ( charset [ index ] ) ; out . write ( padding char ) ; return ; } index += byte3 > > num ; out . write ( charset [ index ] ) ; out . write ( charset [ byte3 & num ] ) ; column += num ; } }	description of the method.
protected void send message ( string handler , list < ? > arguments ) { owner message . add event ( type . client send message , handler , arguments ) ; sync events . add ( new shared object event ( type . client send message , handler , arguments ) ) ; send stats . increment and get ( ) ; }	broadcast event to event handler.
public void task now ( final runnable r , boolean async ) { if ( async ) { async ( r ) ; } else if ( r != null ) { r . run ( ) ; } }	run a task on the current thread or asynchronously - if it ' s already the main thread , it will jst call run ( ).
public void reset ( ) { cur . reset ( ) ; line . reset ( ) ; inuse = bool ; word . set length ( num ) ; }	reset the pdftextformat for a new run.
protected void engine set mode ( string mode ) throws no such algorithm exception { if ( ( mode != null ) && ( ! mode . equals ignore case ( str ) ) ) { throw new no such algorithm exception ( str + mode ) ; } }	sets the mode of this cipher.
public static list < ? extends element > child element list ( document fragment fragment ) { if ( fragment == null ) return null ; list < element > elements = new linked list < element > ( ) ; node node = fragment . get first child ( ) ; if ( node != null ) { do { if ( node . get node type ( ) == node . element node ) { element child element = ( element ) node ; elements . add ( child element ) ; } } while ( ( node = node . get next sibling ( ) ) != null ) ; } return elements ; }	return a list of element objects that are children of the given documentfragment.
public void simulate method ( soot method method , reference variable this var , reference variable return var , reference variable params [ ] ) { string sub signature = method . get sub signature ( ) ; if ( sub signature . equals ( str ) ) { java lang reflect set ( method , this var , return var , params ) ; return ; } else if ( sub signature . equals ( str ) ) { java lang reflect get ( method , this var , return var , params ) ; return ; } else { default method ( method , this var , return var , params ) ; return ; } }	implements the abstract method simulatemethod.
public float array resize ( float array array , long size ) { if ( array instanceof big float array ) { return resize in place ( ( big float array ) array , size ) ; } else { abstract array arr = ( abstract array ) array ; final float array new array = new float array ( size , arr . clear on resize ) ; for ( long i = num , end = math . min ( size , array . size ( ) ) ; i < end ; ++ i ) { new array . set ( i , array . get ( i ) ) ; } arr . close ( ) ; return new array ; } }	resize the array to the exact provided size .
@ override public boolean domain match ( final string host , string domain ) { if ( host . equals ( domain ) ) { return bool ; } if ( ! domain . starts with ( str ) ) { domain = str + domain ; } return host . ends with ( domain ) || host . equals ( domain . substring ( num ) ) ; }	performs domain - match as implemented in common browsers .
public boolean is dirty ( string key ) { return dirty keys . contains ( key ) ; }	checks if a specific key was changed and not yet saved to the database .
final public void println ( float v ) { writer out = this . out ; if ( out == null ) return ; string s = string . value of ( v ) ; try { out . write ( s , num , s . length ( ) ) ; out . write ( newline , num , newline . length ) ; } catch ( io e ) { log . log ( level . fine , e . to string ( ) , e ) ; } }	prints a float followed by a newline .
public double log density for instance ( instance instance ) throws exception { double [ ] a = log joint densities for instance ( instance ) ; double max = a [ utils . max index ( a ) ] ; double sum = num ; for ( int i = num ; i < a . length ; i ++ ) { sum += math . exp ( a [ i ] - max ) ; } return max + math . log ( sum ) ; }	computes the density for a given instance .
public void test when complete source failed action failed ( ) { for ( boolean create incomplete : new boolean [ ] { bool , bool } ) for ( execution mode m : execution mode . values ( ) ) { final atomic integer a = new atomic integer ( num ) ; final cf ex1 = new cf ( ) ; final cf ex2 = new cf ( ) ; final completable future < integer > f = new completable future < > ( ) ; if ( ! create incomplete ) f . complete exceptionally ( ex1 ) ; final completable future < integer > g = m . when complete ( f , null ) ; if ( create incomplete ) f . complete exceptionally ( ex1 ) ; check completed with wrapped exception ( g , ex1 ) ; check completed exceptionally ( f , ex1 ) ; assert equals ( num , a . get ( ) ) ; } }	if a whencomplete action throws an exception when triggered by a source completion that also throws an exception , the source exception takes precedence ( unlike handle ).
public static angle great circle distance ( lat lon p1 , lat lon p2 ) { if ( ( p1 == null ) || ( p2 == null ) ) { throw new illegal argument exception ( str ) ; } double lat1 = p1 . get latitude ( ) . radians ; double lon1 = p1 . get longitude ( ) . radians ; double lat2 = p2 . get latitude ( ) . radians ; double lon2 = p2 . get longitude ( ) . radians ; if ( lat1 == lat2 && lon1 == lon2 ) return angle . zero ; double a = math . sin ( ( lat2 - lat1 ) / num ) ; double b = math . sin ( ( lon2 - lon1 ) / num ) ; double c = a * a + + math . cos ( lat1 ) * math . cos ( lat2 ) * b * b ; double distance radians = num * math . asin ( math . sqrt ( c ) ) ; return double . is na n ( distance radians ) ? angle . zero : angle . from radians ( distance radians ) ; }	computes the great circle angular distance between two locations.
@ override public query rewrite ( index reader reader ) throws io { if ( disjuncts . length == num ) { return disjuncts [ num ] ; } boolean actually rewritten = bool ; list < query > rewritten disjuncts = new array list < > ( ) ; for ( query sub : disjuncts ) { query rewritten sub = sub . rewrite ( reader ) ; actually rewritten |= rewritten sub != sub ; rewritten disjuncts . add ( rewritten sub ) ; } if ( actually rewritten ) { return new disjunction max query ( rewritten disjuncts , tie breaker multiplier ) ; } return super . rewrite ( reader ) ; }	optimize our representation and our subqueries representations.
public static string value of ( long value ) { return long . to string ( value ) ; }	converts the specified long to its string representation .
public static < t > boolean are sets identical ( final set < t > set1 , final set < t > set2 ) { if ( set1 == set2 ) return bool ; if ( collection util . size ( set1 ) != collection util . size ( set2 ) ) return bool ; if ( collection util . is empty ( set1 ) ) return bool ; for ( final t t : set1 ) if ( ! set2 . contains ( t ) ) return bool ; return bool ; }	returns true iff all of the items on each set exist on the other set .
@ override public int compare to ( value o ) { return hash code ( ) - o . hash code ( ) ; }	compares the list value to another value.
private static void add options ( final list < string > cmd , map < checker prop , object > props ) { for ( checker prop cp : checker prop . values ( ) ) { cmd . add all ( cp . get cmd line ( props ) ) ; } }	any options found in props to the cmd list.
public boolean obsolete ( ) { int [ ] stamp = new int [ num ] ; boolean undeployed = usage . get ( stamp ) ; return undeployed && stamp [ num ] == num ; }	checks if deployment is obsolete , i.
boolean pop namespace ( string prefix ) { if ( prefix . starts with ( xml prefix ) ) { return bool ; } stack stack ; if ( ( stack = get prefix stack ( prefix ) ) != null ) { stack . pop ( ) ; return bool ; } return bool ; }	undeclare the namespace that is currently pointed to by a given prefix.
public void redo last action ( ) { try { if ( undo manager . can redo ( ) ) undo manager . redo ( ) ; } catch ( cannot redo exception cre ) { cre . print stack trace ( ) ; } }	attempt to redo the last action .
protected void continue write ( ) { if ( log . is debug enabled ( ) ) { log . debug ( str ) ; } iterator < variable value > i = variables . iterator ( ) ; while ( i . has next ( ) ) { variable value v = i . next ( ) ; if ( v . is to write ( ) && ( ! writing changes || v . is changed ( ) ) ) { am writing = bool ; set busy ( bool ) ; log . debug ( str + v . label ( ) + str + writing changes ) ; if ( writing changes ) { v . write changes ( ) ; } else { v . write all ( ) ; } log . debug ( str ) ; return ; } } am writing = bool ; super . set state ( stored ) ; set busy ( bool ) ; log . debug ( str ) ; }	see if there ' s anything to write , and if so do it .
private void start game ( game launch message game launch message , faction faction , rating mode rating mode , integer local relay port ) { if ( is running ( ) ) { logger . warn ( str ) ; return ; } stop search ranked1v1 ( ) ; list < string > args = fix malformed args ( game launch message . get args ( ) ) ; try { local relay server . get port ( ) ; process = forged alliance service . start game ( game launch message . get uid ( ) , game launch message . get mod ( ) , faction , args , rating mode , local relay port , rehost requested ) ; set game running ( bool ) ; this . rating mode = rating mode ; spawn termination listener ( process ) ; } catch ( io e ) { logger . warn ( str , e ) ; notification service . add notification ( new immediate notification ( i18n . get ( str ) , i18n . get ( str ) , severity . error , e , arrays . as list ( new report action ( i18n , reporting service , e ) , new dismiss action ( i18n ) ) ) ) ; } }	actually starts the game.
public void add line ( string line ) { int index = line . index of ( str , num ) ; if ( index != - num ) { add lenient ( line . substring ( num , index ) , line . substring ( index + num ) ) ; } else if ( line . starts with ( str ) ) { add lenient ( str , line . substring ( num ) ) ; } else { add lenient ( str , line ) ; } }	add an http header line containing a field name , a literal colon , and a value.
private synchronized void add entries ( hashtable entries ) { entry directory . put all ( entries ) ; }	copy all the entries into the entrydirectory it will overwrite any duplicate keys .
public static void load project ( final j tree , final i project ) { preconditions . check not null ( tree , str ) ; preconditions . check not null ( project , str ) ; load project threaded ( swing utilities . get window ancestor ( tree ) , project , tree ) ; }	loads a project while showing a progress dialog .
public enumeration list options ( ) { vector new vector = new vector ( num ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public static data policy from ordinal ( byte ordinal ) { return values [ ordinal ] ; }	return the datapolicy represented by specified ordinal.
public static boolean is installed ( package manager package manager , string package name ) { list < package info > packs = package manager . get installed packages ( num ) ; for ( int i = num ; i < packs . size ( ) ; i ++ ) { if ( text utils . equals ( packs . get ( i ) . package name , package name ) ) return bool ; } return bool ; }	checks if the app has been installed on the system .
public void add set attribute ( final set attribute set attribute ) { set attributes . add ( set attribute ) ; }	will add the setattribute to the list .
static string apply template ( final string template , final map < string , object > map ) { configuration = get configuration ( ) ; try ( byte array output stream output stream = new byte array output stream ( ) ; writer writer = new output stream writer ( output stream ) ) { template configuration template = configuration . get template ( template ) ; configuration template . process ( map , writer ) ; return output stream . to string ( ) ; } catch ( exception e ) { throw new runtime exception ( e . get message ( ) , e ) ; } }	returns the string result from applying a freemarker template .
final void put short ( int offset , short value ) { unsafe . put short ( offset + address , value ) ; }	writes a short at the specified offset from this native object ' s base address .
public static clob to clob ( object value ) throws page exception { if ( value instanceof clob ) return ( clob ) value ; else if ( value instanceof char [ ] ) return to clob ( new string ( ( char [ ] ) value ) ) ; else if ( value instanceof reader ) { string writer sw = new string writer ( ) ; try { io . copy ( ( reader ) value , sw , bool , bool ) ; } catch ( io e ) { throw expression exception . new instance ( e ) ; } return to clob ( sw . to string ( ) ) ; } return to clob ( caster . to string ( value ) ) ; }	cast given value to a clob.
private j create histogram chart ( example set example set ) { j chart = chart factory . create histogram ( null , null , null , create histogram dataset ( example set ) , plot orientation . vertical , bool , bool , bool ) ; abstract attribute statistics model . set default chart fonts ( chart ) ; chart . set background paint ( null ) ; chart . set background image alpha ( num ) ; xy plot = ( xy ) chart . get plot ( ) ; plot . set range gridlines visible ( bool ) ; plot . set domain gridlines visible ( bool ) ; plot . set outline visible ( bool ) ; plot . set range zero baseline visible ( bool ) ; plot . set domain zero baseline visible ( bool ) ; plot . set background paint ( color invisible ) ; plot . set background image alpha ( num ) ; xy renderer = ( xy ) plot . get renderer ( ) ; renderer . set series paint ( num , attribute gui tools . get color for value type ( ontology . numerical ) ) ; renderer . set bar painter ( new xy ( ) ) ; renderer . set draw bar outline ( bool ) ; renderer . set shadow visible ( bool ) ; return chart ; }	creates the histogram chart .
list < type > save ( ) { list buffer < type > buf = new list buffer < > ( ) ; for ( type t : undetvars ) { undet var uv = ( undet var ) t ; undet var uv2 = new undet var ( ( type var ) uv . qtype , types ) ; for ( inference bound ib : inference bound . values ( ) ) { for ( type b : uv . get bounds ( ib ) ) { uv2 . add bound ( ib , b , types ) ; } } uv2 . inst = uv . inst ; buf . add ( uv2 ) ; } return buf . to list ( ) ; }	save the state of this inference context.
public int execute process ( ) { final list < string > process strings = tokenize string ( exec command ) ; process strings . add all ( tokenize string ( script ) ) ; logger . info ( message format . format ( str , process strings ) ) ; final process builder process builder = new process builder ( process strings ) ; if ( working directory != null ) { final path dir = paths . get ( working directory ) ; if ( files . not exists ( dir ) ) { try { files . create directories ( dir ) ; } catch ( io e ) { logger . warning ( str + working directory ) ; return - num ; } } else if ( ! files . is directory ( dir ) ) { logger . warning ( working directory + str ) ; return - num ; } final file directory = dir . to file ( ) ; process builder . directory ( directory ) ; } process builder . redirect error stream ( bool ) ; integer exit value ; try { logger . info ( str ) ; final process process = process builder . start ( ) ; send input string to process ( process ) ; handle process output ( process ) ; try { exit value = process . wait for ( ) ; } catch ( interrupted exception e ) { logger . warning ( str ) ; process . destroy ( ) ; exit value = - num ; } logger . info ( str + exit value + str ) ; } catch ( io e ) { logger . log ( severe , str , e . get cause ( ) ) ; exit value = - num ; } return exit value ; }	executes the process specified by execcommand , classname , and optionally , invaluesstring .
static void check method desc ( final string desc ) { if ( desc == null || desc . length ( ) == num ) { throw new illegal argument exception ( str ) ; } if ( desc . char at ( num ) != str || desc . length ( ) < num ) { throw new illegal argument exception ( str + desc ) ; } int start = num ; if ( desc . char at ( start ) != str ) { do { if ( desc . char at ( start ) == str ) { throw new illegal argument exception ( str + desc ) ; } start = check desc ( desc , start , bool ) ; } while ( start < desc . length ( ) && desc . char at ( start ) != str ) ; } start = check desc ( desc , start + num , bool ) ; if ( start != desc . length ( ) ) { throw new illegal argument exception ( str + desc ) ; } }	checks that the given string is a valid method descriptor .
protected rectangle apply margins ( rectangle rect , float [ ] margins , boolean reverse ) { if ( is positioned ( ) ) return rect ; return rect . < rectangle > apply margins ( margins [ num ] , margins [ num ] , margins [ num ] , margins [ num ] , reverse ) ; }	applies given margins on the given rectangle.
private void reset attempts ( ) { for ( final political action attachment paa : political action attachment . get political action attachments ( m player ) ) { paa . reset attempts ( get bridge ( ) ) ; } }	reset the attempts - counter for this action , so next round the player can try again for a number of attempts .
public static number minus ( character left , character right ) { return minus ( integer . value of ( left ) , right ) ; }	subtract one character from another.
public void find and init ( object some obj ) { if ( some obj instanceof mouse delegator ) { debug . message ( str , str ) ; set mouse delegator ( ( mouse delegator ) some obj ) ; } }	called when a component that is needed , and not available with an appropriate iterator from the beancontext.
public static int to int ( final string value ) { return integer . parse int ( value ) ; }	converts the given xml string to an integer value .
protected object evaluate left less right ( list elements , string lvalue , string rvalue ) { list array ; if ( elements instanceof java . util . vector ) { array = new java . util . vector ( ) ; } else { array = new array list ( ) ; } for ( iterator e = elements . iterator ( ) ; e . has next ( ) ; ) { object o = e . next ( ) ; if ( o instanceof structured content ) { if ( ( o = evaluate left less right ( ( structured content ) o , lvalue , rvalue ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == num ) { return ( structured content ) array . get ( num ) ; } return array ; }	override this element to handle testing a predicate expression where lvalue < rvalue.
public void remove catchable ( catchable pokemon pokemon ) { if ( cached catchable . size ( ) > num ) { cached catchable . remove ( pokemon ) ; } }	remove a catchable pokemon from the cache.
@ suppress warnings ( str ) @ override protected void fill buffer ( ) { int old p = p ; int index = tokens . size ( ) ; token t = token source . next token ( ) ; while ( t != null && t . get type ( ) != char stream . eof ) { int type = t . get type ( ) ; if ( type == js . solidus || type == js . solidus equals sign || type == js . right curly bracket ) { t . set token index ( index ) ; tokens . add ( t ) ; index ++ ; break ; } boolean discard = bool ; if ( channel override map != null ) { integer channel i = ( integer ) channel override map . get ( integer . value of ( type ) ) ; if ( channel i != null ) { t . set channel ( channel i . int value ( ) ) ; } } if ( discard set != null && discard set . contains ( integer . value of ( type ) ) ) { discard = bool ; } else if ( discard off channel tokens && t . get channel ( ) != this . channel ) { discard = bool ; } if ( ! discard ) { t . set token index ( index ) ; tokens . add ( t ) ; index ++ ; } t = token source . next token ( ) ; } p = old p == - num ? num : old p ; p = skip off token channels ( p ) ; }	fills the buffer but stops on a div or div - equals token .
char case fold ( char c ) { if ( alternate casing ) { if ( c == str ) { return str ; } else if ( c == str ) { return str ; } else { return character . to lower case ( c ) ; } } else { return character . to lower case ( c ) ; } }	folds single character ( according to lang if present ).
public void write counts comparison list ( final string filename , final string format ) { if ( format . compare to ignore case ( str ) == num ) { kml kml writer = new kml ( counts comparison list , this . network , transformation factory . get coordinate transformation ( this . coordinate system , transformation factory . wg ) ) ; kml writer . write file ( filename ) ; } else if ( format . compare to ignore case ( str ) == num ) { count sim comparison table writer writer = new count sim comparison table writer ( counts comparison list , locale . us ) ; writer . write file ( filename ) ; } else { throw new illegal argument exception ( str ) ; } comparison error stats calculator error stats = new comparison error stats calculator ( counts comparison list ) ; double [ ] hours = new double [ num ] ; for ( int i = num ; i < num ; i ++ ) { hours [ i - num ] = i ; } double array table writer table writer = new double array table writer ( ) ; table writer . add column ( hours ) ; table writer . add column ( error stats . get mean rel error ( ) ) ; table writer . write file ( filename + str ) ; }	writes the results of the comparison to a file.
public void put grammar ( dtd grammar ) { xmldtd desc = ( xmldtd ) grammar . get grammar description ( ) ; f grammars . put ( desc , grammar ) ; }	puts the specified grammar into the grammar pool and associate it to a root element name ( this being internal , the lack of generality is irrelevant ) .
public service call < translation result > translate ( final string text , final language source , final language target ) { return translate ( collections . singleton list ( text ) , source , target ) ; }	translate text using source and target languages . < br >.
@ override public int execute ( final form object form , final int type , final string code , final int event type , final char key pressed ) { int message code ; final string js = code ; final string [ ] args = js . convert to array ( js ) ; final string command = args [ num ] ; if ( command . starts with ( str ) ) { message code = handle af ( form , command , js , args , event type , key pressed ) ; } else { execute functions ( js , form , acro ) ; message code = action handler . valueschanged ; } if ( type == pdf dictionary . f ) { calcualte event ( ) ; message code = action handler . valueschanged ; } return message code ; }	execute javascript and reset forms values.
private object read resolve ( ) { synchronized ( levels ) { for ( level level : levels ) { if ( value != level . value ) { continue ; } if ( ! name . equals ( level . name ) ) { continue ; } if ( objects . equal ( resource bundle name , level . resource bundle name ) ) { return level ; } } levels . add ( this ) ; return this ; } }	serialization helper method to maintain singletons and add any new levels .
private static void repeat ( string pattern , int count , appendable out ) throws io { while ( count >= pattern . length ( ) ) { out . append ( pattern ) ; count -= pattern . length ( ) ; } if ( count > num ) { out . append ( pattern , num , count ) ; } }	append count characters from pattern onto out , repeating if necessary .
private void clean up ( reference < ? > reference ) throws shut down { method finalize referent method = get finalize referent method ( ) ; do { reference . clear ( ) ; if ( reference == frq reference ) { throw new shut down ( ) ; } try { finalize referent method . invoke ( reference ) ; } catch ( throwable t ) { logger . log ( level . severe , str , t ) ; } } while ( ( reference = queue . poll ( ) ) != null ) ; }	cleans up a single reference.
public @ check for null queue . item run2 ( @ nonnull string replacement main script , @ nonnull map < string , string > replacement loaded scripts ) { list < action > actions = new array list < action > ( ) ; cps flow execution execution = get execution ( ) ; if ( execution == null ) { return null ; } actions . add ( new replay flow factory action ( replacement main script , replacement loaded scripts , execution . is sandbox ( ) ) ) ; actions . add ( new cause action ( new cause . user id cause ( ) , new replay cause ( run ) ) ) ; for ( class < ? extends action > c : copied actions ) { actions . add all ( run . get actions ( c ) ) ; } return parameterized job mix in . schedule build2 ( run . get parent ( ) , num , actions . to array ( new action [ actions . size ( ) ] ) ) ; }	for use in projects that want initiate a replay via the java api .
public static secret keys keys ( string keys str ) throws invalid key exception { string [ ] keys arr = keys str . split ( str ) ; if ( keys arr . length != num ) { throw new illegal argument exception ( str ) ; } else { byte [ ] confidentiality key = base64 . decode ( keys arr [ num ] , bas flags ) ; if ( confidentiality key . length != aes key length bits / num ) { throw new invalid key exception ( str + aes key length bits + str ) ; } byte [ ] integrity key = base64 . decode ( keys arr [ num ] , bas flags ) ; if ( integrity key . length != hmac key length bits / num ) { throw new invalid key exception ( str + hmac key length bits + str ) ; } secret keys secret keys = new secret keys ( ) ; secret key spec secret key spec = new secret key spec ( ) ; secret key spec . generate ( confidentiality key , num , confidentiality key . length , cipher ) ; secret key spec secret key spec1 = new secret key spec ( ) ; secret key spec1 . generate ( integrity key , hmac algorithm ) ; secret keys . set confidentiality key ( secret key spec ) ; secret keys . set integrity key ( secret key spec1 ) ; return secret keys ; } }	an aes key derived from a base64 encoded key.
public path [ ] choose starting paths ( final int nedges , final path [ ] paths ) { final list < path > tmp = new linked list < path > ( ) ; arrays . sort ( paths , num , paths . length , estimated cardinality comparator . instance ) ; for ( int i = num ; i < paths . length && i < nedges ; i ++ ) { tmp . add ( paths [ i ] ) ; } return tmp . to array ( new path [ tmp . size ( ) ] ) ; }	choose the starting vertices .
private void safe bottom view ( ) { status status = get open status ( ) ; view group bottom = get bottom view ( ) ; if ( status == status . close ) { if ( bottom . get visibility ( ) != invisible ) bottom . set visibility ( invisible ) ; } else { if ( bottom . get visibility ( ) != visible ) bottom . set visibility ( visible ) ; } }	prevent bottom view get any touch event.
public static int uniform ( int n ) { if ( n <= num ) throw new illegal argument exception ( str ) ; return random . next int ( n ) ; }	returns a random integer uniformly in [ 0 , n ) .
private void view delta ( final item item ) { final delta fragment fragment = delta fragment . new instance ( item ) ; navigate to fragment ( fragment ) ; }	starts up a new view delta viewer.
public message ( string type , double value ) { if ( ! valid types . contains ( type ) ) { throw new illegal argument exception ( type + str + str ) ; } this . type = type ; this . value = value ; }	creates a new message from the type and the value .
public void add all ( final casualty list casualty list ) { m damaged . add all ( casualty list . get damaged ( ) ) ; m killed . add all ( casualty list . get killed ( ) ) ; }	can have multiple of the same unit , to show multiple hits to that unit .
public static string import result set ( result set source , database db , string name , import filter filter , boolean use existing table ) throws sql , io { result set meta data md = source . get meta data ( ) ; name = table builder . escape identifier ( name ) ; table table = null ; if ( ! use existing table || ( ( table = db . get table ( name ) ) == null ) ) { list < column builder > columns = to columns ( md ) ; table = create unique table ( db , name , columns , md , filter ) ; } list < object [ ] > rows = new array list < object [ ] > ( copy table batch size ) ; int num columns = md . get column count ( ) ; while ( source . next ( ) ) { object [ ] row = new object [ num columns ] ; for ( int i = num ; i < row . length ; i ++ ) { row [ i ] = source . get object ( i + num ) ; } row = filter . filter row ( row ) ; if ( row == null ) { continue ; } rows . add ( row ) ; if ( rows . size ( ) == copy table batch size ) { table . add rows ( rows ) ; rows . clear ( ) ; } } if ( rows . size ( ) > num ) { table . add rows ( rows ) ; } return table . get name ( ) ; }	copy an existing jdbc resultset into a new ( or optionally existing ) table in this database .
@ override public long skip ( long n ) throws io { long remaining = n ; final char [ ] ch = new char [ f buffer . length ] ; do { int length = ch . length < remaining ? ch . length : ( int ) remaining ; int count = read ( ch , num , length ) ; if ( count > num ) { remaining -= count ; } else { break ; } } while ( remaining > num ) ; long skipped = n - remaining ; return skipped ; }	skip characters . this method will block until some characters are available , an i / o error occurs , or the end of the stream is reached .
public static long [ ] hash to longs ( double datum , long seed ) { double d = ( datum == num ) ? num : datum ; long [ ] data = { double . double to long bits ( d ) } ; return hash ( data , seed ) ; }	hash a double and long seed .
private boolean allow upload crash dump ( ) { if ( is cellular experiment enabled ( ) ) return is usage and crash reporting enabled ( ) ; if ( is mobile network capable ( ) ) { string option = m shared preferences . get string ( pref crash dump upload , m crash dump never upload ) ; return option . equals ( m crash dump always upload ) || ( option . equals ( m crash dump wifi only upload ) && is wi fi or ethernet network ( ) ) ; } return m shared preferences . get boolean ( pref crash dump upload no cellular , bool ) ; }	check whether to allow uploading usage and crash reporting.
private int [ ] join map ( int [ ] a , int [ ] b ) { if ( a == null ) { return b ; } if ( b == null ) { return a ; } int [ ] result = new int [ a . length + b . length ] ; system . arraycopy ( a , num , result , num , a . length ) ; system . arraycopy ( b , num , result , a . length , b . length ) ; return result ; }	joins two map arrays ( int [ ] ) together .
private void read object ( object input stream in ) throws class not found exception , io { in . default read object ( ) ; iter = col . iterator ( ) ; }	recreate inner state for object after deserialization .
public label set ( int indices [ ] , boolean sort ) { this . indices = indices ; if ( sort == bool ) arrays . sort ( this . indices ) ; }	a new labelset , indicating sort = true if indices they need to be sorted ( i.
public void diff equals ( ) { double [ ] col = null ; for ( int i = num ; i < a . length ; i ++ ) { col = new double [ a [ i ] . length - num ] ; for ( int j = num ; j < a [ i ] . length ; j ++ ) col [ j - num ] = math . abs ( a [ i ] [ j ] - a [ i ] [ j - num ] ) ; a [ i ] = col ; } n -- ; }	x . diffequals ( ) calculates differences between adjacent columns of this matrix . consequently the size of the matrix is reduced by one . the result is stored in this matrix object again .
private static void print stack trace element ( stack trace element trace , print writer out , class loader loader ) { try { line map map = get script line map ( trace . get class name ( ) , loader ) ; if ( map != null ) { line map . line line = map . get line ( trace . get line number ( ) ) ; if ( line != null ) { out . print ( trace . get class name ( ) + str + trace . get method name ( ) ) ; out . print ( str + line . get source filename ( ) + str ) ; out . println ( line . get source line ( trace . get line number ( ) ) + str ) ; return ; } } } catch ( throwable e ) { } out . println ( trace ) ; }	prints a single stack trace element .
public void read information object ( final pdf object info obj , final object decoder object decoder ) { try { object decoder . check resolved ( info obj ) ; } catch ( final exception e ) { log writer . write log ( str + e . get message ( ) ) ; } string new value ; int id ; byte [ ] data ; final int count = pdf file information . information field i . length ; for ( int i = num ; i < count ; i ++ ) { id = pdf file information . information field i [ i ] ; if ( id == pdf dictionary . trapped ) { new value = info obj . get name ( id ) ; if ( new value == null ) { new value = str ; } } else { data = info obj . get text stream value as byte ( id ) ; if ( data == null ) { new value = str ; } else { new value = string utils . get text string ( data , bool ) ; } } set field value ( i , new value ) ; } }	read information object and return pointer to correct place.
private void cmd calculate difference ( ) { big decimal previous value , actual value ; timestamp today = time util . get day ( system . current time millis ( ) ) ; m cash = m . get ( p pos . get ctx ( ) , p pos . get c id ( ) , today , null ) ; v previous balance . set value ( cash . get ending balance ( ) ) ; previous value = cash . get ending balance ( ) ; actual value = ( big decimal ) v . get value ( ) ; v difference . set value ( actual value . subtract ( previous value ) ) ; }	calculate difference between previous balance and actual for cash scrutiny.
public boolean test allocation ( ) { boolean change = bool ; if ( is processed ( ) ) { big decimal alloc = get allocated amt ( ) ; if ( alloc == null ) alloc = env . zero ; big decimal total = get grand total ( ) ; if ( ! is so ( ) ) total = total . negate ( ) ; if ( is credit memo ( ) ) total = total . negate ( ) ; boolean test = total . compare to ( alloc ) == num ; change = test != is paid ( ) ; if ( change ) set is paid ( test ) ; log . fine ( str + test + str + alloc + str + total + str ) ; } return change ; }	test allocation ( and set paid flag ).
private void request for upload ( oc file ) { file uploader . upload requester requester = new file uploader . upload requester ( ) ; requester . upload update ( m context , m account , file , file uploader . local behaviour move , bool ) ; m transfer was requested = bool ; }	requests for an upload to the fileuploader service.
void refresh custom master list ( ) { if ( custom master countries == null || custom master countries . length ( ) == num ) { custom master countries list = null ; } else { list < country > local country list = new array list < > ( ) ; for ( string name code : custom master countries . split ( str ) ) { country country = country . get country for name code from library master list ( custom language , name code ) ; if ( country != null ) { if ( ! is already in list ( country , local country list ) ) { local country list . add ( country ) ; } } } if ( local country list . size ( ) == num ) { custom master countries list = null ; } else { custom master countries list = local country list ; } } if ( custom master countries list != null ) { for ( country country : custom master countries list ) { country . log ( ) ; } } else { } }	this will load preferredcountries based on countrypreference.
protected boolean is dto getter ( method method ) { if ( method . is annotation present ( delegate to . class ) ) { return bool ; } string method name = method . get name ( ) ; if ( ( method name . starts with ( str ) || method name . starts with ( str ) ) && method . get parameter types ( ) . length == num ) { if ( method name . length ( ) > num && method name . starts with ( str ) ) { return method . get return type ( ) == boolean . class || method . get return type ( ) == boolean . class ; } return method name . length ( ) > num ; } return bool ; }	check is specified method is dto getter .
protected void handle parse conversion exception ( exception e ) throws sax { if ( e instanceof runtime exception ) throw ( runtime exception ) e ; parse conversion event pce = new parse conversion event impl ( validation event . error , e . get message ( ) , new validation event locator impl ( context . get locator ( ) ) , e ) ; context . handle event ( pce , bool ) ; }	this method is called by the generated derived class when a datatype parse method throws an exception .
public status bar ( boolean show memory ) { super ( new border layout ( ) ) ; add ( create info panel ( ) , border layout . west ) ; if ( show memory ) { add ( create memory status ( ) , border layout . center ) ; j icon panel = new j ( new border layout ( ) ) ; icon panel . add ( new j ( new angled lines windows corner icon ( ) ) , border layout . south ) ; add ( icon panel , border layout . east ) ; } else { set background ( color . white ) ; } }	creates a new instance of statusbar.
public void execute ( final runnable task ) { string name = metadata . get ( metadata . resource name key ) ; if ( name != null ) { name = str + name ; } else { name = str ; } final thread thread = new thread ( task , name ) ; thread . set daemon ( bool ) ; thread . start ( ) ; }	executes the given task in a daemon thread .
static int string size ( string string ) { int size = num ; if ( string != null ) { size += headers + num * num ; size += headers + num * string . length ( ) ; } return size ; }	returns an estimate of the memory footprint , in bytes , of the given string .
public static graph request new post open graph object request ( access token access token , json open graph object , callback callback ) { if ( open graph object == null ) { throw new facebook exception ( str ) ; } if ( utility . is null or empty ( open graph object . opt string ( str ) ) ) { throw new facebook exception ( str ) ; } if ( utility . is null or empty ( open graph object . opt string ( str ) ) ) { throw new facebook exception ( str ) ; } string path = string . format ( my objects format , open graph object . opt string ( str ) ) ; bundle bundle = new bundle ( ) ; bundle . put string ( object param , open graph object . to string ( ) ) ; return new graph request ( access token , path , bundle , http method . post , callback ) ; }	creates a new request configured to create a user owned open graph object .
public void add graph ( graph g ) { graphs . add ( g ) ; }	gives a method for adding classes to the class .
private mrc message load chars ( ) throws java . io . io { int nchars ; byte [ ] rcv buffer = new byte [ num ] ; nchars = inpipe . read ( rcv buffer , num , num ) ; mrc message msg = new mrc message ( nchars ) ; for ( int i = num ; i < nchars ; i ++ ) { msg . set element ( i , rcv buffer [ i ] & num ) ; } return msg ; }	get characters from the input source .
@ suppress warnings ( str ) @ override protected money handle transaction that is a ( final loan repayment schedule installment current installment , final list < loan repayment schedule installment > installments , final loan transaction loan transaction , final money transaction amount unprocessed , list < loan transaction to repayment schedule mapping > transaction mappings ) { return handle transaction that is on time payment of installment ( current installment , loan transaction , transaction amount unprocessed , transaction mappings ) ; }	for late repayments , pay off in the same way as on - time payments , interest first then principal .
protected void fire tuple event ( table t , int start , int end , int type ) { if ( m tuple listeners != null && m tuple listeners . size ( ) > num ) { object [ ] lstnrs = m tuple listeners . get array ( ) ; tuple [ ] tuples = new tuple [ end - start + num ] ; for ( int i = num , r = start ; r <= end ; ++ r , ++ i ) { tuples [ i ] = t . get tuple ( r ) ; } for ( int i = num ; i < lstnrs . length ; ++ i ) { tuple set listener tsl = ( tuple set listener ) lstnrs [ i ] ; if ( type == event constants . insert ) { tsl . tuple set changed ( this , tuples , empty array ) ; } else { tsl . tuple set changed ( this , empty array , tuples ) ; } } } }	fire a tuple event .
public string build query ( string [ ] projection in , string selection , string group by , string having , string sort order , string limit ) { string [ ] projection = compute projection ( projection in ) ; string builder where = new string builder ( ) ; boolean has base where clause = m where clause != null && m where clause . length ( ) > num ; if ( has base where clause ) { where . append ( m where clause . to string ( ) ) ; where . append ( str ) ; } if ( selection != null && selection . length ( ) > num ) { if ( has base where clause ) { where . append ( str ) ; } where . append ( str ) ; where . append ( selection ) ; where . append ( str ) ; } return build query string ( m distinct , m tables , projection , where . to string ( ) , group by , having , sort order , limit ) ; }	construct a select statement suitable for use in a group of select statements that will be joined through union operators in buildunionquery .
public static boolean is exception time ( calendar schedule time , schedule info schedule info ) throws exception { if ( schedule info . get date exceptions ( ) != null ) { for ( string date exception : schedule info . get date exceptions ( ) ) { date format formatter = new simple date format ( schedule info . full daytime format ) ; date date = formatter . parse ( schedule info . get start date ( ) ) ; calendar exception time = calendar . get instance ( time zone . get time zone ( str ) ) ; exception time . set time ( date ) ; if ( exception time . equals ( schedule time ) ) { log . info ( str , schedule time . to string ( ) ) ; return bool ; } } } return bool ; }	check if the schedule time is in exception list.
protected void init port ( ) { string port param = get init parameter ( str ) ; set port ( ( port param == null ) ? default port : integer . parse int ( port param ) ) ; if ( is debug ( ) ) { log ( str + get port ( ) ) ; } }	initializer for property port .
public jpegq ( int [ ] table ) { if ( table == null ) { throw new illegal argument exception ( str ) ; } if ( table . length != num ) { throw new illegal argument exception ( str ) ; } q table = arrays . copy of ( table , table . length ) ; }	constructs a quantization table from the argument , which must contain 64 elements in natural order ( not zig - zag order ).
public vn find snap nfs share ( string snap id , string share name , string software version ) { string builder query filter = new string builder ( vn . name filter ) ; if ( ! vn . is higher version ( software version , vn . vnxe base soft ver ) ) { query filter . append ( share name ) ; query filter . append ( vn . and ) ; query filter . append ( vn . snap filter ) ; query filter . append ( snap id ) ; } else { query filter . append ( str + share name + str ) ; query filter . append ( vn . and ) ; query filter . append ( vn . snap filter ) ; query filter . append ( str + snap id + str ) ; } set filter ( query filter . to string ( ) ) ; vn result = null ; list < vn > share list = get data for objects ( vn . class ) ; if ( share list != null && ! share list . is empty ( ) ) { result = share list . get ( num ) ; logger . info ( str , snap id , share name ) ; } else { logger . info ( str , snap id , share name ) ; } return result ; }	find snapshot nfsshare using snapshot id and share name.
@ override public final int read ( ) throws io { byte buffer bb = wait for available data ( ) ; return ( bb . get ( ) & num ) ; }	see the inputstream read method for javadocs . note that if an attempt to read past the end of the wrapped bytebuffer is done this method throws bufferunderflowexception.
protected token position ( token position other ) { objects . require non null ( other ) ; this . line = other . line ; this . column = other . column ; this . offset = other . offset ; }	creates a new instance with the values of the given token position .
private j create detail panel ( throwable error ) { stack trace list stl = new stack trace list ( error ) ; j detail pane = new j ( stl ) ; detail pane . set preferred size ( new dimension ( get width ( ) , num ) ) ; detail pane . set border ( null ) ; return detail pane ; }	creates a panel for the error details and attaches the exception to it , but doesn ' t add the panel to the dialog .
abstract boolean contains key ( t container , string key ) ;	checks if the container contains the key.
private jmx connect ( string host , int port ) { try { if ( ! is node available ( host ) ) { log . info ( str , host ) ; throw new illegal state exception ( str ) ; } log . debug ( str , host , port ) ; string connector address = string . format ( service url , host , port ) ; jmx url jmx url = new jmx url ( connector address ) ; return jmx . connect ( jmx url ) ; } catch ( url e ) { log . error ( string . format ( str , host , port ) , e ) ; throw new illegal state exception ( str ) ; } catch ( io e ) { log . error ( string . format ( str , host , port ) , e ) ; throw new illegal state exception ( str + host ) ; } }	create a connection to the jmx agent.
public tag handler process object value ( object value ) throws jsp exception { if ( value instanceof attribute definition ) { return process typed attribute ( ( attribute definition ) value ) ; } else if ( value instanceof component definition ) { return process definition ( ( component definition ) value ) ; } return process as definition or url ( value . to string ( ) ) ; }	process an object retrieved as a bean or attribute.
public list < integer > emit ( string stream id , tuple anchor , list < object > tuple ) { return emit ( stream id , arrays . as list ( anchor ) , tuple ) ; }	emits a new tuple to a specific stream with a single anchor.
private synchronized void write to output stream ( int one byte ) { if ( m closed ) { return ; } try { m output stream . write ( one byte ) ; report decoded size if applicable ( ) ; } catch ( io e ) { handle io ( e ) ; } }	writes the byte to all the output streams.
protected list < model entity > make entity model to use list ( ) throws generic entity exception { list < generic value > entity sync includes = entity sync . get related ( str , null , null , bool ) ; list < generic value > entity sync group includes = entity sync . get related ( str , null , null , bool ) ; entity sync includes . add all ( entity sync group includes ) ; list < model entity > entity model to use list = entity group util . get model entities from records ( entity sync includes , delegator , bool ) ; if ( debug . info on ( ) ) debug . log info ( str + entity sync . get ( str ) + str + entity model to use list . size ( ) + str , module ) ; return entity model to use list ; }	prepare a list of all entities we want to synchronize : remove all view - entities and all entities that don ' t match the patterns attached to this entitysync.
private static string lz ( int num ) { return string . format ( str , num ) ; }	add leadingzero if only 1 char.
public void on child idle begin ( ) { idle count . increment and get ( ) ; }	called by the thread before going into the idle state .
private startup mode check startup mode ( configuration config ) throws io { startup mode boot mode = check startup mode on disk ( config ) ; if ( boot mode != null ) { return boot mode ; } if ( check config bool ( config , constants . startupmode restore reinit ) ) { log . info ( str , constants . startupmode restore reinit ) ; geodb restore mode mode = new geodb restore mode ( config ) ; mode . set coordinator ( coordinator ) ; mode . set schema util ( schema util ) ; mode . set db dir ( db dir ) ; return mode ; } if ( check config bool ( config , constants . reinit db ) ) { log . info ( str , constants . reinit db ) ; db reinit mode mode = new db reinit mode ( config ) ; mode . set coordinator ( coordinator ) ; mode . set schema util ( schema util ) ; mode . set db dir ( db dir ) ; return mode ; } list < string > obsolete peers = check config list ( config , constants . obsolete cassandra peers ) ; if ( ! obsolete peers . is empty ( ) ) { obsolete peers cleanup mode mode = new obsolete peers cleanup mode ( config ) ; mode . set coordinator ( coordinator ) ; mode . set schema util ( schema util ) ; mode . set obsolete peers ( obsolete peers ) ; return mode ; } else { normal mode mode = new normal mode ( config ) ; mode . set coordinator ( coordinator ) ; mode . set schema util ( schema util ) ; return mode ; } }	determine current startup mode.
private void write object ( java . io . object output stream s ) throws java . io . io { lock . lock ( ) ; try { q = new priority queue < e > ( math . max ( size , num ) , comparator ) ; q . add all ( this ) ; s . default write object ( ) ; } finally { q = null ; lock . unlock ( ) ; } }	saves this queue to a stream ( that is , serializes it ).
private void run ( ) { try { thread current = thread . current thread ( ) ; byte [ ] buf = new byte [ num ] ; for ( int len = in . read ( buf ) ; len != - num ; len = in . read ( buf ) ) { buffer . write ( buf , num , len ) ; if ( current != thread ) { break ; } } buffer . flush ( ) ; buffer . close ( ) ; } catch ( io e ) { log . error ( e . get message ( ) , e ) ; } }	consumes the input stream until it runs out or is interrupted .
protected boolean shard available ( @ nullable index shard shard ) { return shard != null && shard . can index ( ) && can update index buffer states . contains ( shard . state ( ) ) ; }	returns true if shard exists and is availabe for updates.
synchronized void update auth config globals ( service schema manager scm ) throws sms { service schema schema = scm . get organization schema ( ) ; schema = schema . get sub schema ( str ) ; schema = schema . get sub schema ( str ) ; map attrs = schema . get attribute defaults ( ) ; if ( attrs != null ) { default service success url = ( set ) attrs . get ( is . login success url ) ; default service failure url = ( set ) attrs . get ( is . login failure url ) ; } if ( debug . message enabled ( ) ) { debug . message ( str + default service success url ) ; debug . message ( str + default service failure url ) ; } }	update the authconfiguration organization attributes .
public void increment ( ) { count . increment and get ( ) ; rate window . increment for timestamp ( timer getter . now ( ) ) ; }	increments the cumulative count of evaluations and recalculates the rate.
long total memory ( ) ;	get total physical memory in bytes.
@ override public int preceding ( int offset ) { character iterator text = get text ( ) ; check offset ( offset , text ) ; text . set index ( offset ) ; return previous ( ) ; }	sets the iterator to refer to the last boundary position before the specified position .
public void log ( string event , string message ) { boolean event active = is event active ( event ) ; if ( ( this . logging && event active && ! writers . is empty ( ) ) ) { try { for ( writer writer : writers . values ( ) ) { writer . write ( message ) ; writer . write ( str ) ; writer . flush ( ) ; } } catch ( io e ) { e . print stack trace ( ) ; } } }	logs the given message with a newline associated with the given event .
public int write ( final byte buffer byte buffer ) throws io { ensure open ( ) ; final int remaining = byte buffer . remaining ( ) ; if ( inspectable < buffer . length ) { final int to buffer = math . min ( buffer . length - inspectable , remaining ) ; byte buffer . get ( buffer , inspectable , to buffer ) ; inspectable += to buffer ; } if ( byte buffer . has remaining ( ) ) { file channel . position ( write position ) ; write position += file channel . write ( byte buffer ) ; } return remaining ; }	appends the content of a specified buffer to the end of the currently represented stream .
public void copy into ( int str offset , byte [ ] bytes , int array offset , int len ) { system . arraycopy ( m bytes , m offset + str offset , bytes , array offset , len ) ; }	copy the bytes of the string into the given byte array .
public static string repeat string ( string pattern , int repeats ) { string builder buffer = new string builder ( pattern . length ( ) * repeats ) ; for ( int i = num ; i < repeats ; i ++ ) { buffer . append ( pattern ) ; } return new string ( buffer ) ; }	returns a string made up of repetitions of the specified string .
private boolean is music player ( ) { return player setting != null && player setting . equals ignore case ( str ) ; }	helper method that tells us if we are using musicplayer.
public final static version info [ ] load version info ( string [ ] pckgs , class loader clsldr ) { if ( pckgs == null ) { throw new illegal argument exception ( str ) ; } array list vil = new array list ( pckgs . length ) ; for ( int i = num ; i < pckgs . length ; i ++ ) { version info vi = load version info ( pckgs [ i ] , clsldr ) ; if ( vi != null ) vil . add ( vi ) ; } return ( version info [ ] ) vil . to array ( new version info [ vil . size ( ) ] ) ; }	loads version information for a list of packages .
public static collection < content stream > to content streams ( final string str , final string content type ) { if ( str == null ) return null ; array list < content stream > streams = new array list < > ( num ) ; content stream base ccc = new content stream base . string stream ( str ) ; ccc . set content type ( content type ) ; streams . add ( ccc ) ; return streams ; }	take a string and make it an iterable contentstream.
void write repeated sqrt ( dd xdd ) { int count = num ; while ( xdd . double value ( ) > num ) { count ++ ; double x = xdd . double value ( ) ; dd x sqrt = xdd . sqrt ( ) ; string s = x sqrt . to string ( ) ; dd x sqrt2 = dd . parse ( s ) ; dd xx = x sqrt2 . multiply ( x sqrt2 ) ; double err = math . abs ( xx . double value ( ) - x ) ; xdd = x sqrt ; dd dist from1 dd = x sqrt . subtract ( dd . value of ( num ) ) ; double dist from1 = dist from1 dd . double value ( ) ; if ( math . abs ( dist from1 ) < num ) break ; } }	this routine simply tests for robustness of the tostring function .
public static boolean has extension ( string extension ) { if ( extension == null || extension . is empty ( ) ) { return bool ; } return extension to mime type map . contains key ( extension ) ; }	returns true if the given extension has a registered mime type .
private float apply friction ( float velocity , float simulation rate ) { if ( is zero ( velocity ) ) { velocity = num ; } else if ( velocity > num ) { velocity = math . max ( num , velocity - ( friction * simulation rate ) ) ; } else { velocity = math . min ( num , velocity + ( friction * simulation rate ) ) ; } return velocity ; }	friction slows velocity in the opposite direction of motion , until zero velocity is reached .
static boolean real is j ( class script class , groovy class loader loader ) { boolean is test = bool ; try { try { class run with annotation class = loader . load class ( str ) ; annotation annotation = script class . get annotation ( run with annotation class ) ; if ( annotation != null ) { is test = bool ; } else { class test annotation class = loader . load class ( str ) ; method [ ] methods = script class . get methods ( ) ; for ( int i = num ; i < methods . length ; i ++ ) { method method = methods [ i ] ; annotation = method . get annotation ( test annotation class ) ; if ( annotation != null ) { is test = bool ; break ; } } } } catch ( class not found exception e ) { } } catch ( throwable e ) { } return is test ? boolean . true : boolean . false ; }	utility method to check via reflection if the parsed class appears to be a junit4 test .
private static void parse expression ( final reader reader , final boolean writing string , final string builder template expressions ) throws io { if ( ! writing string ) { template expressions . append ( str ) ; } template expressions . append ( str ) ; while ( bool ) { int c = reader . read ( ) ; if ( c == - num ) break ; if ( c == str ) { c = reader . read ( ) ; if ( c == str ) break ; template expressions . append ( str ) ; } template expressions . append ( ( char ) c ) ; } template expressions . append ( str ) ; }	parse a & lt ; % =.
protected void reduce parse tree ( compilation unit declaration unit ) { type declaration [ ] types = unit . types ; for ( int i = num , l = types . length ; i < l ; i ++ ) purge method statements ( types [ i ] , bool ) ; }	called prior to the unit being resolved.
public static long find revision ( final list < string > output , final pattern pattern ) { long revision = - num ; for ( final string line : output ) { final matcher matcher = pattern . matcher ( line ) ; if ( matcher . find ( ) ) { revision = long . parse long ( matcher . group ( num ) ) ; break ; } } return revision ; }	for the given pattern , find the revision number .
protected int choose high water mark ( int capacity , double max load ) { return math . min ( capacity - num , ( int ) ( capacity * max load ) ) ; }	returns new high water mark threshold based on current capacity and maxloadfactor .
private access grant create access grant ( map < string , string > params ) { access grant access grant = new access grant ( ) ; if ( params . get ( str ) != null ) { string access token = params . get ( str ) ; integer expires = null ; if ( params . get ( str ) != null ) { expires = integer . value of ( params . get ( str ) ) ; } access grant . set key ( access token ) ; access grant . set attribute ( str , expires ) ; } access grant . set provider id ( m provider name . to string ( ) ) ; return access grant ; }	internal method to create new create accessgrant.
protected final boolean load to have at least ( int min available ) throws io { if ( input stream == null ) { return bool ; } int amount = input end - input ptr ; if ( amount > num && input ptr > num ) { curr input processed += input ptr ; curr input row start -= input ptr ; system . arraycopy ( input buffer , input ptr , input buffer , num , amount ) ; input end = amount ; } else { input end = num ; } input ptr = num ; while ( input end < min available ) { int count = input stream . read ( input buffer , input end , input buffer . length - input end ) ; if ( count < num ) { close input ( ) ; if ( count == num ) { throw new io ( str + amount + str ) ; } return bool ; } input end += count ; } return bool ; }	helper method that will try to load at least specified number bytes in input buffer , possible moving existing data around if necessary.
public double log pdf ( double x ) { return math . log ( pdf ( x ) ) ; }	the natural log of the probability density function of the distribution.
private void select file ( int title msg , int button msg , string settings name , string default dir , int dialog , int result ) { set auto mode ( auto mode . off ) ; string action = str ; intent i = new intent ( action ) ; string current file = settings . get string ( settings name , str ) ; string sep = file . separator ; if ( ! current file . contains ( sep ) ) current file = environment . get external storage directory ( ) + sep + default dir + sep + current file ; i . set data ( uri . from file ( new file ( current file ) ) ) ; i . put extra ( str , get string ( title msg ) ) ; i . put extra ( str , get string ( button msg ) ) ; try { start activity for result ( i , result ) ; } catch ( activity not found exception e ) { remove dialog ( dialog ) ; show dialog ( dialog ) ; } }	open a load / save file dialog.
public string timer string ( int level , string message ) { string builder ret string buf = new string builder ( ) ; for ( int i = num ; i < level ; i ++ ) { ret string buf . append ( str ) ; } ret string buf . append ( str ) ; string time since start str = string . value of ( time since start ( ) ) ; ret string buf . append ( time since start str + str ) ; string time since last str = string . value of ( time since last ( ) ) ; ret string buf . append ( time since last str ) ; ret string buf . append ( str ) ; int spacecount = num + ( num * level ) - ret string buf . length ( ) ; for ( int i = num ; i < spacecount ; i ++ ) { ret string buf . append ( str ) ; } ret string buf . append ( message ) ; last message time = system . current time millis ( ) ; string ret string = ret string buf . to string ( ) ; if ( log && debug . timing on ( ) ) debug . log timing ( ret string , module ) ; return ret string ; }	creates a string with information including the passed message , the time since the last call , and the time since the beginning.
public static int recompile with opt ( normal method method ) { if ( vm . build for opt compiler ) { compilation plan plan = new compilation plan ( method , ( optimization plan element [ ] ) optimization plan , null , ( opt options ) options ) ; return recompile with opt ( plan ) ; } else { if ( vm . verify assertions ) vm . assert ( vm . not reached ) ; return - num ; } }	a wrapper method for those callers who don ' t want to make optimization plans.
public string find match ( pattern pattern , string text ) { return find match ( pattern , text , num ) ; }	finds the first match of the specified pattern and returns the first group .
private void add hit ( string cname , class < ? > c ) { if ( len == names . length ) { final int nl = ( len << num ) + num ; names = arrays . copy of ( names , nl ) ; clazzes = arrays . copy of ( clazzes , nl ) ; } names [ len ] = cname ; clazzes [ len ] = c ; ++ len ; }	if a name has been resolved , add it .
private object query command value ( final string command identifier ) { check . not null ( command identifier , str ) ; final string buffer cmd = new string buffer ( ) ; cmd . append ( str ) ; cmd . append ( command identifier ) ; cmd . append ( str ) ; return browser . evaluate ( cmd . to string ( ) ) ; }	gets the value of the document , range , or selection for the given command .
public void line ( double x , double y ) { line line = new line ( x , y ) ; if ( x < min x ) { min x = x ; } if ( y < min y ) { min y = y ; } if ( x > max x ) { max x = x ; } if ( y > max y ) { max y = y ; } elements . add ( line ) ; }	draw a line in the current line style ( if any ).
@ override public list < cluster < t > > cluster ( final collection < t > points ) throws null argument exception { math utils . check not null ( points ) ; final list < cluster < t > > clusters = new array list < cluster < t > > ( ) ; final map < clusterable , point status > visited = new hash map < clusterable , point status > ( ) ; for ( final t point : points ) { if ( visited . get ( point ) != null ) { continue ; } final list < t > neighbors = get neighbors ( point , points ) ; if ( neighbors . size ( ) >= min pts ) { final cluster < t > cluster = new cluster < t > ( ) ; clusters . add ( expand cluster ( cluster , point , neighbors , points , visited ) ) ; } else { visited . put ( point , point status . noise ) ; } } return clusters ; }	performs dbscan cluster analysis .
public void test get version25 ( ) throws exception { string xml = webapp 25 header + str ; web xml web xml = web xml io . parse web xml ( new byte array input stream ( xml . get bytes ( str ) ) , get entity resolver ( ) ) ; assert equals ( web xml version . 5 , web xml . get version ( ) ) ; }	tests whether a servlet api version 2.
@ override public void mouse pressed ( mouse event evt ) { int pos = ( slider . get orientation ( ) == j . horizontal ) ? evt . get x ( ) : evt . get y ( ) ; int loc = get location for value ( get snapped value ( evt ) ) ; this . offset = ( loc < num ) ? num : pos - loc ; }	when the slider is clicked we need to record the offset from the thumb centre .
public void write ( int ch ) throws io { output stream os = get output stream ( ) ; os . write ( str ) ; os . write ( num ) ; os . write ( num ) ; os . write ( ch ) ; }	writes a data byte to the output stream .
public static < s > service loader < s > load installed ( class < s > service ) { class loader cl = class loader . get system class loader ( ) ; if ( cl != null ) { while ( cl . get parent ( ) != null ) { cl = cl . get parent ( ) ; } } return service loader . load ( service , cl ) ; }	constructs a service loader , using the extension class loader .
private static iterator < operand > iterate return values ( ir ir ) { array list < operand > return values = new array list < operand > ( ) ; for ( enumeration < instruction > e = ir . forward instr enumerator ( ) ; e . has more elements ( ) ; ) { instruction s = e . next element ( ) ; if ( return . conforms ( s ) ) { return values . add ( return . get val ( s ) ) ; } } return return values . iterator ( ) ; }	todo : move this utility elsewhere.
public static pattern glob2 pattern ( string ... globs ) { final string builder regex = new string builder ( ) ; boolean need or = bool ; for ( string glob : globs ) { if ( need or ) { regex . append ( str ) ; } int i = num , len = glob . length ( ) ; while ( i < len ) { char c = glob . char at ( i ++ ) ; switch ( c ) { case str : if ( i < len && glob . char at ( i ) == str ) { regex . append ( str ) ; i ++ ; } else { regex . append ( str ) ; } break ; case str : regex . append ( str ) ; break ; default : if ( is regex meta ( c ) ) { regex . append ( str ) ; } regex . append ( c ) ; } } need or = bool ; } return pattern . compile ( regex . to string ( ) , num ) ; }	returns a regex pattern that matches on any of the globs on class names ( e.
public static boolean contains trace explorer module conflict ( string root module name ) { string root module file name = root module name ; if ( ! root module name . ends with ( resource helper . tla extension ) ) { root module file name = resource helper . get module file name ( root module name ) ; } list < string > extended module names = toolbox handle . get extended modules ( root module file name ) ; iterator < string > it = extended module names . iterator ( ) ; while ( it . has next ( ) ) { string module name = it . next ( ) ; if ( module name . equals ( te file tla ) ) { return bool ; } } return bool ; }	determines if the spec with root module rootmodulename is dependent on a module with the same name as the root module used for trace exploration .
public void test flip bit negative inside2 ( ) { byte a bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = - num ; int number = num ; byte r bytes [ ] = { - num , num , - num , - num , num , num , - num , - num , - num , - num , num , - num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . flip bit ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , result . signum ( ) ) ; }	flipbit ( int n ) inside a negative number.
private string build full message ( string msg , object arg0 , object arg1 , object arg2 , object [ ] arg array ) { string builder sb = null ; int last index = num ; int arg c = num ; while ( bool ) { int arg index = msg . index of ( arg string , last index ) ; if ( arg index == - num ) { break ; } if ( sb == null ) { sb = new string builder ( num ) ; } sb . append ( msg , last index , arg index ) ; last index = arg index + arg string length ; if ( arg array == null ) { if ( arg c == num ) { append arg ( sb , arg0 ) ; } else if ( arg c == num ) { append arg ( sb , arg1 ) ; } else if ( arg c == num ) { append arg ( sb , arg2 ) ; } else { } } else if ( arg c < arg array . length ) { append arg ( sb , arg array [ arg c ] ) ; } else { } arg c ++ ; } if ( sb == null ) { return msg ; } else { sb . append ( msg , last index , msg . length ( ) ) ; return sb . to string ( ) ; } }	return a combined single message from the msg ( with possible { } ) and optional arguments .
protected void remove from parent info ( openable child ) { openable parent = ( openable ) child . get parent ( ) ; if ( parent != null && parent . is open ( ) ) { try { openable element info info = ( openable element info ) parent . get element info ( ) ; info . remove child ( child ) ; } catch ( java model exception e ) { } } }	removes the given element from its parents cache of children.
public void remove all update listeners ( ) { if ( m update listeners == null ) { return ; } m update listeners . clear ( ) ; m update listeners = null ; }	removes all listeners from the set listening to frame updates for this animation .
public void execute plan ( task completer completer , string success message , workflow callback handler callback handler , object [ ] callback handler args , workflow rollback handler rollback handler , object [ ] rollback handler args ) throws workflow exception { this . callback handler = callback handler ; if ( callback handler args != null ) { this . callback handler args = callback handler args . clone ( ) ; } this . rollback handler = rollback handler ; if ( rollback handler args != null ) { this . rollback handler args = rollback handler args . clone ( ) ; } this . task completer = completer ; this . success message = success message ; service . execute plan ( this ) ; }	invokes the workflowplanexecutor to execute this workflow plan .
private os ( ) { }	not meant to instantiate .
public boolean is mutable ( ) { return mutable ; }	checks if the object is mutable.
public void handle request ( request context rc ) throws cli { super . handle request ( rc ) ; ldap login ( ) ; string service name = get string option value ( i . service name ) ; string sub config name = get string option value ( i . sub configuration name ) ; string realm name = get string option value ( i . realm name ) ; if ( ( realm name == null ) || ( realm name . length ( ) == num ) ) { delete sub config to root ( service name , sub config name ) ; } else { delete sub config from realm ( realm name , service name , sub config name ) ; } }	services a commandline request .
public void enforce context ( resource ... contexts ) { rdf . verify context not null ( contexts ) ; this . contexts = arrays . copy of ( contexts , contexts . length ) ; }	enforces the supplied contexts upon all statements that are reported to this rdfinserter .
protected void run upload ( integer num of threads , hash map < string , string > attributes , boolean create new version , boolean force ) throws exception { run upload ( num of threads , attributes , create new version , force , null , null ) ; }	runs a normal upload scenario .
public final collection < component > components ( ) { return new hash set < > ( components . values ( ) ) ; }	gets a set of components that this componentprovider provides .
protected boolean [ ] can predict ( boolean nominal predictor , boolean numeric predictor , boolean string predictor , boolean date predictor , boolean relational predictor , boolean multi instance , int class type ) { print ( str ) ; print attribute summary ( nominal predictor , numeric predictor , string predictor , date predictor , relational predictor , multi instance , class type ) ; print ( str ) ; array list < string > accepts = new array list < string > ( ) ; accepts . add ( str ) ; accepts . add ( str ) ; accepts . add ( str ) ; accepts . add ( str ) ; accepts . add ( str ) ; accepts . add ( str ) ; accepts . add ( str ) ; accepts . add ( str ) ; accepts . add ( str ) ; int num train = get num instances ( ) , num classes = num , missing level = num ; boolean predictor missing = bool , class missing = bool ; return run basic test ( nominal predictor , numeric predictor , string predictor , date predictor , relational predictor , multi instance , class type , missing level , predictor missing , class missing , num train , num classes , accepts ) ; }	checks basic prediction of the scheme , for simple non - troublesome datasets .
public void test history index disabled ( ) throws sail exception { final properties properties = get properties ( ) ; properties . set property ( com . bigdata . rdf . store . abstract triple store . options . history service , str ) ; final bigdata sail sail = get sail ( properties ) ; try { sail . initialize ( ) ; final bigdata sail connection conn = sail . get connection ( ) ; try { final i ndx = get history index ( conn . get triple store ( ) ) ; assert null ( ndx ) ; conn . rollback ( ) ; } finally { conn . close ( ) ; } } finally { sail . tear down unit test ( ) ; } }	unit test verifies that the history index is not created if the option is not enabled .
public void collapse ( ) { collapse ( bool ) ; }	collapses all expanded items.
public int num instances ( ) { return m . size ( ) ; }	returns the number of instances in the dataset .
@ override public void start document ( xml locator , string encoding , namespace context namespace context , augmentations augs ) throws xni { f namespace context = namespace context ; try { if ( f document handler != null ) { if ( locator != null ) { f document handler . set document locator ( new locator proxy ( locator ) ) ; } if ( f document handler != null ) { f document handler . start document ( ) ; } } if ( f content handler != null ) { if ( locator != null ) { f content handler . set document locator ( new locator proxy ( locator ) ) ; } if ( f content handler != null ) { f content handler . start document ( ) ; } } } catch ( sax e ) { throw new xni ( e ) ; } }	the start of the document .
public static double parse number percent with separate range ( fxg node , string value , string name , double min number , double max number , double min percent , double max percent , double default value ) { if ( value . length ( ) != num && value . char at ( value . length ( ) - num ) == str ) { string double value = value . substring ( num , value . length ( ) - num ) ; try { return parse double ( node , double value , name , min percent , max percent , default value ) ; } catch ( fxg e ) { throw new fxg ( node . get start line ( ) , node . get start column ( ) , str , name , value ) ; } } else { return parse double ( node , value , name , min number , max number , default value ) ; } }	convert an fxg string value to a double after taking care of the % sign.
private void check download can proceed ( ) throws stop request exception { if ( clock . interval less than ( clock . interval . one second ) ) { return ; } clock . start interval ( ) ; check is paused or canceled ( ) ; check client rules ( ) ; }	check if the download has been paused or canceled , stopping the request appropriately if it has been .
private void delete event ( event reg key expiration reg expiration , event reg reg ) { listeners . dec ( ) ; synchronized ( reg ) { entry rep [ ] tmpls = reg . tmpl . attribute set templates ; if ( tmpls != null ) { for ( int i = tmpls . length ; -- i >= num ; ) { entry class eclass = tmpls [ i ] . eclass ; eclass . set num templates ( eclass . get num templates ( ) - num ) ; } } long id = reg . event id ; event by id . remove ( id ) ; if ( reg expiration != null ) { event by time . remove ( reg expiration ) ; } else { event by time . remove ( new event reg key expiration ( reg , reg . lease expiration ) ) ; } if ( reg . tmpl . service id != null ) { object val = sub event by service . get ( reg . tmpl . service id ) ; if ( val == reg ) { sub event by service . remove ( reg . tmpl . service id ) ; } else { object [ ] array = ( event reg [ ] ) val ; array = array del ( array , index of ( array , reg ) ) ; if ( array . length == num ) val = array [ num ] ; else val = array ; sub event by service . put ( reg . tmpl . service id , val ) ; } } else { sub event by id . remove ( id ) ; } compute max leases ( ) ; } }	remove an event registration from our state.
public string gtid set ( ) { return this . gtid set != null ? this . gtid set : null ; }	get the string representation of the gtid range for the mysql binary log file .
public static peer create map peer ( map map ) throws message exception { if ( ! map . contains key ( port ) || ! map . contains key ( address ) ) throw new message exception ( str ) ; int port = ( int ) ( long ) map . get ( port ) ; string address = ( string ) map . get ( address ) ; string peer id = null ; if ( map . contains key ( peer id ) ) peer id = ( string ) map . get ( peer id ) ; return new peer ( peer id , new inet socket address ( address , port ) ) ; }	create a peer from a map .
private static int count gaps dash dot star ( string sequence ) { int count = num ; for ( int i = num ; i < sequence . length ( ) ; i ++ ) { int a = sequence . char at ( i ) ; if ( a == str || a == str || a == str ) count ++ ; } return count ; }	count the number of gaps ( ' - ' , ' . ' , ' * ' ) in a sequence.
public static void put double field ( object obj , long field off , double val ) { unsafe . put double ( obj , field off , val ) ; }	stores double value into object field .
public string to oid ( ) { if ( s oid == null ) { s oid = str + to string ( ) ; } return s oid ; }	add " oid . " to the beginning of string representation .
public void emit direct ( int task id , string stream id , tuple anchor , list < object > tuple ) { emit direct ( task id , stream id , arrays . as list ( anchor ) , tuple ) ; }	emits a tuple directly to the specified task id on the specified stream.
protected void load value ( string s value ) { s value = s value . trim ( ) ; try { int r = integer . parse int ( s value . substring ( num , num ) , num ) ; int g = integer . parse int ( s value . substring ( num , num ) , num ) ; int b = integer . parse int ( s value . substring ( num , num ) , num ) ; value = new color ( r , g , b ) ; } catch ( number format exception nfe ) { revert to default ( ) ; } catch ( string index out of bounds exception sioobe ) { revert to default ( ) ; } }	returns the value of this setting .
public void schema changed ( string service name , string version ) { update status ( ) ; }	update the controller classes if the administration console service attributes is altered .
public kc serve ( string uri , string method , properties header , properties parms , properties files ) { return serve file ( uri , header , my root dir , bool ) ; }	override this to customize the server.
protected void fill mem data ( object data , int [ ] posits , int length , object output , int output offset , int dim ) { if ( data instanceof object [ ] ) { object [ ] xo = ( object [ ] ) data ; fill mem data ( xo [ posits [ dim ] ] , posits , length , output , output offset , dim + num ) ; } else { int start from = posits [ dim ] ; int start to = output offset ; int copy length = length ; if ( posits [ dim ] < num ) { start from -= posits [ dim ] ; start to -= posits [ dim ] ; copy length += posits [ dim ] ; } if ( posits [ dim ] + length > this . dims [ dim ] ) { copy length -= posits [ dim ] + length - this . dims [ dim ] ; } system . arraycopy ( data , start from , output , start to , copy length ) ; } }	fill a single segment from memory.
public optional < string > start async job ( string job type ) { try { final job runnable job runnable = find job runnable ( job type ) ; job info job info = create job info ( job type ) ; repository . mark job as running if possible ( job info , mutex job types for ( job type ) ) ; repository . create or update ( job info ) ; return optional . of ( start async ( metered ( job runnable ) , job info . get job id ( ) ) ) ; } catch ( job blocked exception e ) { log . info ( e . get message ( ) ) ; return optional . empty ( ) ; } }	starts a job asynchronously in the background .
public boolean is legal replacement ( byte [ ] replacement ) { if ( decoder == null ) { decoder = charset . new decoder ( ) ; decoder . on malformed input ( coding error action . report ) ; decoder . on unmappable character ( coding error action . report ) ; } byte buffer in = byte buffer . wrap ( replacement ) ; char buffer out = char buffer . allocate ( ( int ) ( replacement . length * decoder . max chars per byte ( ) ) ) ; coder result result = decoder . decode ( in , out , bool ) ; return ! result . is error ( ) ; }	tests whether the given argument is legal as this encoder ' s replacement byte array.
public static void adapt table ( constraint table layout table ) { int width = table . get width ( ) ; int height = table . get height ( ) ; constraint widget . dimension behaviour horizontal behaviour = table . get horizontal dimension behaviour ( ) ; constraint widget . dimension behaviour vertical behaviour = table . get vertical dimension behaviour ( ) ; table . set horizontal dimension behaviour ( constraint widget . dimension behaviour . wrap content ) ; table . set vertical dimension behaviour ( constraint widget . dimension behaviour . wrap content ) ; table . layout ( ) ; table . layout ( ) ; table . set min width ( table . get width ( ) ) ; table . set min height ( table . get height ( ) ) ; table . compute guidelines percent positions ( ) ; table . set horizontal dimension behaviour ( horizontal behaviour ) ; table . set vertical dimension behaviour ( vertical behaviour ) ; table . set width ( width < table . get min width ( ) ? table . get min width ( ) : width ) ; table . set height ( height < table . get min height ( ) ? table . get min height ( ) : height ) ; table . layout ( ) ; }	adapt the table ' s dimensions and columns or rows to its content.
public static < v , c extends collection < ? super v > > c add all ( c c , v ... vals ) { collections . add all ( c , vals ) ; return c ; }	adds values to collection and returns the same collection to allow chaining .
public static void add strut ( j b , int layout , int size ) { if ( size < num ) return ; b . add ( get axis ( b , layout ) == box layout . x axis ? box . create horizontal strut ( size ) : box . create vertical strut ( size ) ) ; }	add a strut , or rigid spacing , to a ui component.
public void element type ( string name , int model , int member of , int flags ) { element type e = new element type ( name , model , member of , flags , this ) ; the element types . put ( name . to lower case ( ) , e ) ; if ( member of == m root ) the root = e ; }	add or replace an element type for this schema .
public int array index scale ( class clazz ) { if ( ! clazz . is array ( ) ) { throw new illegal argument exception ( str ) ; } return array index scale0 ( clazz ) ; }	gets the size of each element of the given array class .
public string str rep ( ) { return str + rank team poll score + str + abbr + str + wins + str + losses + str ; }	str rep of team , no bowl results.
@ override public string to string ( ) { if ( e is proxy ( ) ) return super . to string ( ) ; string buffer result = new string buffer ( super . to string ( ) ) ; result . append ( str ) ; result . append ( kind ) ; result . append ( str ) ; return result . to string ( ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
private void record rp ( db client db client , operation type enum op type , operation . status status , object ... ext param ) { try { boolean op status = ( operation . status . ready == status ) ? bool : bool ; string ev type ; ev type = op type . get ev type ( op status ) ; string ev desc = op type . get description ( ) ; string op stage = audit log manager . auditop end ; log . info ( str , op type . to string ( ) , ev type . to string ( ) + str + ev desc ) ; record bourne rp ( db client , get id ( ) , ev type , status , ev desc ) ; switch ( op type ) { case start rp link : case stop rp link : case pause rp link : case resume rp link : case failover rp link : case failover cancel rp link : case change rp image access mode : case swap rp volume : audit block util . audit block ( db client , op type , op status , op stage , ext param ) ; break ; default : log . error ( str ) ; } } catch ( exception e ) { log . error ( str , op type . to string ( ) , e ) ; } }	record block volume related event and audit.
void auto closing clip opened ( auto closing clip clip ) { if ( printer . debug ) printer . debug ( str ) ; int index = num ; synchronized ( auto closing clips ) { index = get auto closing clip index ( clip ) ; if ( index == - num ) { if ( printer . debug ) printer . debug ( str + clip ) ; auto closing clips . add ( new clip info ( clip ) ) ; } } if ( index == - num ) { synchronized ( this ) { notify all ( ) ; } } if ( printer . debug ) printer . debug ( str + auto closing clips . size ( ) + str ) ; }	called from auto - closing clips when one of their open ( ) method is called.
public boolean implies ( permission permission ) { if ( ! ( permission instanceof exec option permission ) ) return bool ; exec option permission p = ( exec option permission ) permission ; if ( all allowed ) return bool ; string pname = p . get name ( ) ; permission x = permissions . get ( pname ) ; if ( x != null ) return x . implies ( permission ) ; int last , offset ; offset = pname . length ( ) - num ; while ( ( last = pname . last index of ( str , offset ) ) != - num ) { pname = pname . substring ( num , last + num ) + str ; x = permissions . get ( pname ) ; if ( x != null ) { return x . implies ( permission ) ; } offset = last - num ; } pname = p . get name ( ) ; offset = pname . length ( ) - num ; while ( ( last = pname . last index of ( str , offset ) ) != - num ) { pname = pname . substring ( num , last + num ) + str ; x = permissions . get ( pname ) ; if ( x != null ) { return x . implies ( permission ) ; } offset = last - num ; } return bool ; }	check and see if this set of permissions implies the permissions expressed in " permission " .
private static byte [ ] save ( bitmap src , bitmap . compress format format , int quality ) { byte array output stream output stream = null ; try { output stream = new byte array output stream ( ) ; src . compress ( format , quality , output stream ) ; return output stream . to byte array ( ) ; } finally { if ( output stream != null ) { try { output stream . close ( ) ; } catch ( io e1 ) { e1 . print stack trace ( ) ; } } } }	saving image to byte array.
public boolean is external ( resource input ) { return external resources . contains ( input ) ; }	tell if it is an external source .
protected final void write d ( byte buffer buf , int value ) { buf . put int ( value ) ; }	write int to buffer .
public list < shopping cart item > items ( ) { list < shopping cart item > result = fast list . new instance ( ) ; result . add all ( cart lines ) ; return result ; }	returns a collection of items in the cart object .
mutable big integer ( big integer b ) { int len = b . mag . length ; value = arrays . copy of ( b . mag , int len ) ; }	construct a new mutablebiginteger with a magnitude equal to the specified biginteger .
public boolean is http11 ( ) { if ( m version . equals ignore case ( htt ) ) { return bool ; } return bool ; }	check if this header is http 1.
protected void delete icon ( ) { if ( selected icon == null ) { return ; } if ( icon map . remove ( selected icon . get name ( ) ) != null ) { remove icon families panel ( ) ; add icons to panel ( icon map ) ; delete icon button . set enabled ( bool ) ; validate ( ) ; } }	action item for initbuttonpanel.
public boolean equals ( object obj ) { if ( obj == null ) return bool ; if ( this == obj ) return bool ; if ( get class ( ) != obj . get class ( ) ) return bool ; choice format other = ( choice format ) obj ; return ( arrays . equals ( choice limits , other . choice limits ) && arrays . equals ( choice formats , other . choice formats ) ) ; }	equality comparision between two.
public static date updated ( date self , map < object , integer > updates ) { calendar cal = calendar . get instance ( ) ; cal . set time ( self ) ; set ( cal , updates ) ; return cal . get time ( ) ; }	legacy alias for copywith.
public boolean display topic ( string name ) { string topic = null ; if ( name == null ) topic = default + file type ; else topic = name . to lower case ( ) + file type ; file help file = new file ( help dir , topic ) ; return display ( help file ) ; }	display help for a topic.
private void dash to words ( string token val ) { int index = token val . index of ( str ) ; string aaa = token val . substring ( num , index ) ; string bbb = token val . substring ( index + num , token val . length ( ) ) ; if ( matches ( digits pattern , aaa ) && matches ( digits pattern , bbb ) ) { feature set feature set = token item . get features ( ) ; feature set . set string ( str , aaa ) ; token to words ( aaa ) ; word relation . add word ( str ) ; feature set . set string ( str , bbb ) ; token to words ( bbb ) ; feature set . set string ( str , str ) ; } else { token to words ( aaa ) ; token to words ( bbb ) ; } }	convert the given dashed string ( e.
public static int number of trailing zeros signed ( long [ ] v ) { for ( int p = num ; ; p ++ ) { if ( p == v . length ) { return - num ; } if ( v [ p ] != num ) { return long . number of trailing zeros ( v [ p ] ) + p * long . size ; } } }	find the number of trailing zeros .
public static void apply wm ( collection < mwm > lines , string bound type ) { for ( mwm line : lines ) { for ( mwm definition : mwm . get all ( line . get ctx ( ) , line . get ( ) ) ) { wm . validate definition ( line , definition , bound type ) ; } } }	apply the wm rule by bound type.
public static float read float ( final json json array , final int index , final boolean required , final boolean not null ) throws json { if ( required ) { return ( float ) json array . get double ( index ) ; } if ( not null && json array . is null ( index ) ) { throw new json ( string . format ( locale . us , null value format array , index ) ) ; } float value = num ; if ( ! json array . is null ( index ) ) { value = ( float ) json array . get double ( index ) ; } return value ; }	reads the float value from the json array for specified index.
public void flush ( ) throws io { flush bits ( ) ; out . flush ( ) ; }	description of the method.
public final flux < t > on error resume with ( predicate < ? super throwable > predicate , function < ? super throwable , ? extends publisher < ? extends t > > fallback ) { objects . require non null ( predicate , str ) ; return on error resume with ( null ) ; }	subscribe to a returned fallback publisher when an error matching the given type occurs.
@ override public enumeration < option > list options ( ) { vector < option > result = new vector < option > ( ) ; result . add element ( new option ( str , str , num , str ) ) ; result . add all ( collections . list ( super . list options ( ) ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
public @ test final void test set users negative ( ) { role role = new role ( test role ) ; thrown . expect ( illegal argument exception . class ) ; role . set users ( null ) ; }	setting the list of grants to null is not allowed .
private set < string > find resource names ( string path , string prefix , string suffix ) throws io { set < string > resource names = find resource names from file system ( path , new file ( path ) ) ; return filter resource names ( resource names , prefix , suffix ) ; }	finds the resources names present at this location and below on the classpath starting with this prefix and ending with this suffix .
public boolean add ( k key , v item ) { set < v > values = map . get ( key ) ; if ( values == null ) { values = ( sorted ? new tree set < v > ( ) : new hash set < v > ( ) ) ; map . put ( key , values ) ; } if ( item == null ) return bool ; return values . add ( item ) ; }	adds item to the set of values associated with the key ( null items are not added ).
public void add ecm ( ecm info ) { ecm effects . add ( info ) ; }	added another ecminfo to the effects for a location .
protected void load image ( string file path , om ret ) { file file = new file ( file path ) ; if ( file . exists ( ) && file . is directory ( ) ) { string [ ] files = file . list ( ) ; for ( int i = num ; i < files . length ; i ++ ) { load image ( file path + str + files [ i ] , ret ) ; } } else { fire status update ( layer status event . start working ) ; try { url file url = prop utils . get resource or file or url ( file path ) ; if ( file url != null ) { if ( image reader loaders != null ) { image tile image tile = null ; for ( image reader loader idl : image reader loaders ) { if ( idl . is loadable ( file path ) ) { image reader id = idl . get image reader ( file url ) ; image tile tmp image tile = id . get image tile ( image cache ) ; if ( image tile == null ) { image tile = tmp image tile ; } else if ( tmp image tile != null && image tile instanceof err image tile ) { image tile = tmp image tile ; } if ( image tile != null && ! ( image tile instanceof err image tile ) ) { break ; } } } if ( image tile != null ) { add image to lists ( image tile , ret , file url ) ; } } else { logger . warning ( str + get name ( ) + str ) ; } } else { logger . warning ( str + file path ) ; } } catch ( url murle ) { } } }	if filepath is a file , the imagereaderloaders are used to try to load and place the image.
@ override protected final boolean write data ( byte buffer data ) { synchronized ( guard ) { gs server packet packet = send msg queue . poll first ( ) ; if ( packet == null ) { return bool ; } packet . write ( this , data ) ; return bool ; } }	this method will be called by dispatcher , and will be repeated till return false .
public static export mask create export mask ( db client db client , export group export group , uri sd uri , string mask name ) throws database exception { export mask export mask = new export mask ( ) ; export mask . set id ( uri . create id ( export mask . class ) ) ; export mask . set mask name ( mask name ) ; export mask . set storage device ( sd uri ) ; db client . create object ( export mask ) ; export group . add export mask ( export mask . get id ( ) ) ; db client . update object ( export group ) ; return export mask ; }	create an export mask object.
public log entry ( string timestamp , string contents ) { this . timestamp = timestamp ; this . contents = contents ; }	creates a new log entry with the given timestamp and contents.
public static boolean cancel potential work ( object data , image view image view ) { final bitmap worker task bitmap worker task = get bitmap worker task ( image view ) ; if ( bitmap worker task != null ) { final object bitmap data = bitmap worker task . m data ; if ( bitmap data == null || ! bitmap data . equals ( data ) ) { bitmap worker task . cancel ( bool ) ; if ( build config . debug ) { log . d ( tag , str + data ) ; } } else { return bool ; } } return bool ; }	returns true if the current work has been canceled or if there was no work in progress on this image view.
void replace policy in resource tree ( policy old policy , policy new policy ) throws policy exception , sso { remove policy from resource tree ( old policy ) ; add policy to resource tree ( new policy ) ; }	replaces resource names of a policy in the resource tree .
public oidc acquire tokens by secur id ( string username , string passcode , id secur id retriever , token spec token spec ) throws oidc , oidc , token validation exception , ssl { validate . not empty ( username , str ) ; validate . not empty ( passcode , str ) ; validate . not null ( secur id retriever , str ) ; validate . not null ( token spec , str ) ; http response http response = oidc . handle secur id ( username , passcode , secur id retriever , token spec , get token endpoint uri ( ) , this . client id , this . holder of key config , this . key store ) ; return oidc . parse token response ( http response , this . provider public key , this . issuer , this . client id , this . clock tolerance in seconds ) ; }	get tokens by securidretriever which handles multi - legged securidgrant.
public void load nested ( environment env ) { load nested ( env , num ) ; }	called when an environment ties a binary definition to a declaration.
private promise < action response , resource exception > internal handle action ( string token id , context context , action request request ) { final string action = request . get action ( ) ; final action handler action handler = action handlers . get ( action ) ; if ( action handler != null ) { return action handler . handle ( token id , context , request ) ; } else { string message = string . format ( str , action ) ; not supported exception e = new not supported exception ( message ) ; if ( logger . message enabled ( ) ) { logger . message ( str + message , e ) ; } return e . as promise ( ) ; } }	handle the action specified by the user ( i.
public int compare to ( object obj ) { int diff = - num ; if ( obj instanceof parser notice ) { parser notice p2 = ( parser notice ) obj ; diff = level - p2 . get level ( ) ; if ( diff == num ) { diff = line - p2 . get line ( ) ; if ( diff == num ) { diff = message . compare to ( p2 . get message ( ) ) ; } } } return diff ; }	compares this parser notice to another .
protected abstract map < integer , filter operation delegate invoker > do get invoker lookup ( ) ;	responsible for returning a lookup map of operation code to invoker .
public static void delete collection ( string host , string collection ) throws exception { string delete collection template = str ; string delete collection command = string . format ( delete collection template , host , default solr port , collection ) ; execute solr command ( delete collection command ) ; }	given a collection name , it deletes it.
private iterable < fragment constructor > create constructors ( ) { return collections . unmodifiable list ( arrays . as list ( new biome data constructor ( resolution . quarter ) , new end islands constructor ( ) , new image constructor ( resolution . quarter , layer ids . background ) , new image constructor ( resolution . chunk , layer ids . slime ) ) ) ; }	this also defines the construction order .
@ nullable public static h psi key ( @ not null psi method psi method , @ not null direction direction , @ not null message digest md ) { final psi class psi class = psi tree util . get parent of type ( psi method , psi class . class , bool ) ; if ( psi class == null ) { return null ; } byte [ ] class digest = psi class digest ( psi class , md ) ; if ( class digest == null ) { return null ; } byte [ ] sig digest = method digest ( psi method , md ) ; if ( sig digest == null ) { return null ; } byte [ ] digest = new byte [ hash size ] ; system . arraycopy ( class digest , num , digest , num , class hash size ) ; system . arraycopy ( sig digest , num , digest , class hash size , signature hash size ) ; return new h ( digest , mk direction key ( direction ) , bool ) ; }	converts a psi method to a small hash key ( hkey ).
public static boolean is sd card mounted ( ) { string status = environment . get external storage state ( ) ; if ( status . equals ( environment . media mounted ) ) return bool ; return bool ; }	checks if the sd card is mounted on the device .
private void parse resource ( final element resource element , final collection < resource > resources ) { final string tag name = resource element . get tag name ( ) ; final string uri = resource element . get text content ( ) ; if ( tag group ref . equals ( tag name ) ) { resources . add all ( get resources for group ( uri ) ) ; } if ( get resource type ( resource element ) != null ) { final resource resource = create resource ( resource element ) ; log . debug ( str , resource ) ; resources . add ( resource ) ; } }	creates a resource from a given resourceelement.
@ override public void licence file ( string text to show , file licence file ) throws cancel exception { try { final file input stream content = new file input stream ( licence file ) ; final string writer writer = new string writer ( ) ; io . copy ( content , writer , str ) ; content . close ( ) ; licence ( text to show , writer . to string ( ) ) ; } catch ( io e ) { throw new script failure exception ( str , e ) ; } }	show the content of a licence file.
public int mean allocation ( ) { if ( m slot allocations == num ) return num ; return ( int ) ( m size allocations / m slot allocations ) ; }	meanallocation : ( total application bytes used across all allocations for this slot size ) / slotsallocated.
@ override public string to string ( ) { return message format . format ( str + str + str , get ldap ( ) , string utils . join ( requested attributes , str ) ) ; }	presents the querybuilder in a human readable format.
public void test case6 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num , num , num , num , num , num , num , num , num } ; int a sign = num ; int b sign = - num ; byte r bytes [ ] = { - num , - num , - num , num , - num , - num , - num , - num , num , - num , - num , - num , num , - num , num , num , num , - num , - num , num , num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . multiply ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , result . signum ( ) ) ; }	multiply two numbers of different length and different signs.
public void animate progress fill ( int animate to ) { m animation handler . remove messages ( num ) ; if ( animate to > m max || animate to < num ) { throw new illegal argument exception ( string . format ( str , animate to , m max ) ) ; } m animation handler . set animate to ( animate to ) ; m animation handler . send empty message ( num ) ; invalidate ( ) ; }	animates a progress fill of the view , using a handler .
static boolean is registered ( object name object name ) { set < object name > registered object names = m bean server . query names ( object name , null ) ; return ! registered object names . is empty ( ) ; }	checks whether an objectname is already registered .
public < t > pushable lazy future stream < t > future stream ( final lazy react s ) { final queue < t > q = create queue ( ) ; return new pushable lazy future stream < t > ( q , s . from stream ( q . stream ( ) ) ) ; }	create a pushable lazyfuturestream using the supplied reactpool.
public byte [ ] convert hex string to binary ( string hex string ) throws illegal argument exception { int length = hex string . length ( ) ; if ( length % num != num ) { throw new illegal argument exception ( str + length + str + hex string ) ; } byte [ ] binary = new byte [ length / num ] ; for ( int i = num ; i < length ; i += num ) { char high bits char = hex string . char at ( i ) ; char low bits char = hex string . char at ( i + num ) ; int high bits = hex char to int ( high bits char , hex string ) << num ; int low bits = hex char to int ( low bits char , hex string ) ; binary [ i / num ] = ( byte ) ( high bits + low bits ) ; } return binary ; }	convert the provided hex - string into a binary representation where each byte represents two characters of the hex string.
public void write field ( final string name , final short value ) throws java . io . io { write field ( name , short . to string ( value ) ) ; }	writes an short field value .
public static result set select ( connection conn , string sql ) throws sql { statement stat = conn . create statement ( result set . type scroll insensitive , result set . concur read only ) ; return stat . execute query ( sql ) ; }	this method is called via reflection from the database .
public static void write set of longs ( set set , boolean has long i , data output out ) throws io { if ( set == null ) { out . write int ( - num ) ; } else { out . write int ( set . size ( ) ) ; out . write boolean ( has long i ) ; for ( iterator it = set . iterator ( ) ; it . has next ( ) ; ) { long l = ( long ) it . next ( ) ; if ( has long i ) { out . write long ( l . long value ( ) ) ; } else { out . write int ( ( int ) l . long value ( ) ) ; } } } }	write a set of long objects.
private void restore widget ( key key , byte [ ] buffer , int data size ) throws io { if ( verbose ) log . v ( tag , str + key . id ) ; if ( debug ) log . d ( tag , str + buffer . length + str + base64 . encode to string ( buffer , num , data size , base64 . no wrap ) ) ; widget widget = unpack proto ( new widget ( ) , buffer , data size ) ; if ( debug ) log . d ( tag , str + widget . provider ) ; if ( widget . icon . data != null ) { bitmap icon = bitmap factory . decode byte array ( widget . icon . data , num , widget . icon . data . length ) ; if ( icon == null ) { log . w ( tag , str + key . name ) ; } else { m icon cache . preload icon ( component name . unflatten from string ( widget . provider ) , icon , widget . icon . dpi , widget . label , m user serial , m idp ) ; } } widget sizes . add ( widget . provider + str + num + str + num ) ; }	read a widget from the stream.
public void consider region x ( geo region r , geo region region ) { geo array r boundary = r . get points ( ) ; geo r point = r boundary . get ( num , new geo ( ) ) ; geo array region boundary = region . get points ( ) ; geo region point = region boundary . get ( num , new geo ( ) ) ; if ( intersection . is point in polygon ( r point , region boundary ) || intersection . is point in polygon ( region point , r boundary ) ) { collector . collect ( r , region ) ; } else { for ( geo path . segment iterator pit = r . segment iterator ( ) ; pit . has next ( ) ; ) { geo segment seg = pit . next segment ( ) ; if ( filter . pre consider ( seg , region ) && consider segment x ( seg , region ) ) { collector . collect ( seg , region ) ; return ; } } } }	puts the region in the collector if r intersects with it .
private char fold case ( char ch ) { if ( ch < num ) { if ( str <= ch && ch <= str ) { return ( char ) ( ch + ( str - str ) ) ; } return ch ; } return character . to lower case ( character . to upper case ( ch ) ) ; }	this isn ' t equivalent to either of icu ' s u_foldcase case folds , and thus any of the unicode case folds , but it ' s what the ri uses .
public writable raster create compatible writable raster ( int w , int h ) { if ( w <= num || h <= num ) { throw new raster format exception ( str + ( ( w <= num ) ? str : str ) ) ; } sample model sm = sample model . create compatible sample model ( w , h ) ; return new byte banded raster ( sm , new point ( num , num ) ) ; }	creates a raster with the same layout but using a different width and height , and with new zeroed data arrays .
@ target api ( version codes . lollipop ) public static void reveal ( final view view , int cx , int cy ) { if ( ! has lollipop ( ) ) { view . set visibility ( view . visible ) ; return ; } int final radius = math . max ( view . get width ( ) , view . get height ( ) ) ; animator animator = view animation utils . create circular reveal ( view , cx , cy , num , final radius ) ; view . set visibility ( view . visible ) ; animator . start ( ) ; }	create the reveal effect animation.
public n ( n type , string previous stop , sort direction order ) { this ( type , previous stop ) ; if ( order == sort direction . asc ) { this . type = n . inverted ; this . nested = optional . of ( new n ( type , previous stop ) ) ; this . previous stop = optional . empty ( ) ; } }	constructs a sort of the given type with a starting point and explicitly specifies the order ( ascending or descending ) .
public void remove supported options ( set < string > unmatched processor options ) { unmatched processor options . remove all ( supported option names ) ; }	remove options that are matched by this processor .
protected void subscribe ( ) { if ( sample client sub == null ) { try { sample client sub = new sample async callback ( url , client id sub , clean session , quiet mode , user name , password ) ; } catch ( mqtt exception e ) { e . print stack trace ( ) ; } } if ( sample client sub != null ) { string topic = str ; int qos = num ; try { sample client sub . subscribe ( topic , qos ) ; } catch ( throwable e ) { e . print stack trace ( ) ; } } }	subscribe to a topic on an mqtt server once subscribed this method waits for the messages to arrive from the server that match the subscription . it continues listening for messages until pin 3 is pressed.
private boolean should crop ( int width , int height ) { int pixel error = num ; pixel error += math . round ( math . max ( width , height ) / num ) ; return ( m max result image size x > num && m max result image size y > num ) || math . abs ( m crop rect . left - m current image rect . left ) > pixel error || math . abs ( m crop rect . top - m current image rect . top ) > pixel error || math . abs ( m crop rect . bottom - m current image rect . bottom ) > pixel error || math . abs ( m crop rect . right - m current image rect . right ) > pixel error ; }	check whether an image should be cropped at all or just file can be copied to the destination path.
public boolean exists ( ) { return do access ( f ok ) ; }	returns a boolean indicating whether this file can be found on the underlying file system .
public shape tile box bounding box ( ) { if ( bounding box != null ) return bounding box ; pla point float start corner = start point approx ( ) ; pla point float end corner = end point approx ( ) ; double llx = math . min ( start corner . v x , end corner . v x ) ; double lly = math . min ( start corner . v y , end corner . v y ) ; double urx = math . max ( start corner . v x , end corner . v x ) ; double ury = math . max ( start corner . v y , end corner . v y ) ; pla point int lower left = new pla point int ( math . floor ( llx ) , math . floor ( lly ) ) ; pla point int upper right = new pla point int ( math . ceil ( urx ) , math . ceil ( ury ) ) ; bounding box = new shape tile box ( lower left , upper right ) ; return bounding box ; }	calculates the smallest surrounding box of this line segmant.
public void test classpath war ( ) throws exception { final url url = new url ( str + system . get property ( str ) + str ) ; final string expected = str ; ping utils . assert ping true ( url . get path ( ) + str , expected , url , logger ) ; }	test changing of classpath with the websphere container .
protected abstract boolean is nullable ( ) ;	returns if this tuple can contain null elements .
public vec3 normalize ( ) { float x = this . m [ num ] ; float y = this . m [ num ] ; float z = this . m [ num ] ; float s = num / ( float ) math . sqrt ( x * x + y * y + z * z ) ; this . m [ num ] = x * s ; this . m [ num ] = y * s ; this . m [ num ] = z * s ; return this ; }	\ brief this = normalize ( this ).
@ override public p read page ( int page id ) { try { count read ( ) ; long offset = ( ( long ) ( header . get reserved pages ( ) + page id ) ) * ( long ) page size ; byte [ ] buffer = new byte [ page size ] ; file . seek ( offset ) ; file . read ( buffer ) ; return byte array to page ( buffer ) ; } catch ( io e ) { throw new runtime exception ( str + page id + str , e ) ; } }	reads the page with the given id from this file .
public void add action listener ( action listener listener ) { forward projection button . add action listener ( listener ) ; back projection button . add action listener ( listener ) ; }	adds a listener for events that shift the projection stack .
void write data to file locked ( random access file file , boolean add mayo , boolean add tomato , int which filling ) throws io { file . set length ( num ) ; file . write int ( which filling ) ; file . write boolean ( add mayo ) ; file . write boolean ( add tomato ) ; log . v ( tag , str + add mayo + str + add tomato + str + which filling ) ; }	handy helper routine to write the ui data to a file .
static type [ ] map key and value types ( type context , class < ? > context raw type ) { if ( context == properties . class ) return new type [ ] { string . class , string . class } ; type map type = get supertype ( context , context raw type , map . class ) ; if ( map type instanceof parameterized type ) { parameterized type map parameterized type = ( parameterized type ) map type ; return map parameterized type . get actual type arguments ( ) ; } return new type [ ] { object . class , object . class } ; }	returns a two element array containing this map ' s key and value types in positions 0 and 1 respectively .
static aggregated http message of ( http headers headers , http data content , http headers trailing headers ) { return of ( collections . empty list ( ) , headers , content , trailing headers ) ; }	creates a new http message .
public static boolean is letter ( char c ) { return character . is letter ( c ) ; }	returns true if character c is an english letter ( a.
protected list < tree node > create child list ( ) { branch branch = get xml branch ( ) ; int size = branch . node count ( ) ; list < tree node > child list = new array list < tree node > ( size ) ; for ( int i = num ; i < size ; i ++ ) { node node = branch . node ( i ) ; if ( node instanceof character data ) { string text = node . get text ( ) ; if ( text == null ) { continue ; } text = text . trim ( ) ; if ( text . length ( ) <= num ) { continue ; } } child list . add ( create child tree node ( node ) ) ; } return child list ; }	factory method to create list of children treenodes.
public set < value > may aliases ( value v , unit u ) { set < value > res = new hash set < value > ( ) ; set < set < value > > flow = get flow before ( u ) ; for ( set < value > set : flow ) { if ( set . contains ( v ) ) res . add all ( set ) ; } return res ; }	returns all values that may - alias with v before u .
@ nullable private static string read ( @ non null socket channel socket , @ non null byte [ ] buffer ) throws io { byte buffer buf = byte buffer . wrap ( buffer , num , buffer . length ) ; while ( buf . position ( ) != buf . limit ( ) ) { int count ; count = socket . read ( buf ) ; if ( count < num ) { throw new io ( str ) ; } } try { return new string ( buffer , num , buf . position ( ) , adb helper . default encoding ) ; } catch ( unsupported encoding exception e ) { return null ; } }	fills a buffer by reading data from a socket .
public static date time unit create local date unit instance ( date date , org . hisp . dhis . calendar . calendar calendar ) { return calendar . from iso ( date time unit . from jdk date ( date ) ) ; }	returns an instance of a dateunit .
public static boolean equal ( double a , double b ) { return ( math . abs ( a - b ) < epsilon ) ; }	returns if two double values are equal to within epsilon .
@ override public void add class annotation ( char [ ] buffer , int offset , int length ) { string ann type = new string ( buffer , offset , length ) ; if ( ann types . contains ( ann type ) ) { add class ( class name ) ; } }	adds a class annotation.
static path part make absolute ( path part old part ) { @ suppress warnings ( str ) boolean encoded cached = old part . encoded != not cached ; string old path = encoded cached ? old part . encoded : old part . decoded ; if ( old path == null || old path . length ( ) == num || old path . starts with ( str ) ) { return old part ; } string new encoded = encoded cached ? str + old part . encoded : not cached ; @ suppress warnings ( str ) boolean decoded cached = old part . decoded != not cached ; string new decoded = decoded cached ? str + old part . decoded : not cached ; return new path part ( new encoded , new decoded ) ; }	prepends path values with " / " if they ' re present , not empty , and they don ' t already start with " / " .
public static int [ ] split gt ( string gt ) { final int gtlen = gt . length ( ) ; if ( gtlen == num ) { return new int [ ] { allele id ( gt . char at ( num ) ) } ; } else { int [ ] result = new int [ num ] ; int ploid = num ; int allelestart = num ; for ( int i = num ; i < gtlen ; i ++ ) { final char c = gt . char at ( i ) ; if ( c == phased separator || c == unphased separator ) { if ( ploid == result . length ) { result = arrays . copy of ( result , result . length + num ) ; } result [ ploid ++ ] = allele id ( gt , allelestart , i - allelestart ) ; allelestart = i + num ; } } if ( allelestart < gtlen ) { if ( ploid == result . length ) { result = arrays . copy of ( result , result . length + num ) ; } result [ ploid ++ ] = allele id ( gt , allelestart , gtlen - allelestart ) ; } if ( ploid < result . length ) { result = arrays . copy of ( result , ploid ) ; } if ( ploid == num ) { throw new number format exception ( str + gt + str ) ; } return result ; } }	utility method for splitting a vcf genotype subfield into an array of numeric allele identifiers .
public void test bug18041 ( ) throws exception { if ( version meets minimum ( num , num ) ) { create table ( str , str ) ; properties props = new properties ( ) ; props . set property ( str , str ) ; props . set property ( str , str ) ; connection trunc conn = null ; prepared statement stm = null ; try { trunc conn = get connection with props ( props ) ; stm = trunc conn . prepare statement ( str ) ; stm . set int ( num , num ) ; stm . set string ( num , str ) ; stm . execute update ( ) ; fail ( str ) ; } catch ( data truncation trunc ex ) { } finally { if ( trunc conn != null ) { trunc conn . close ( ) ; } } } }	tests fix for bug # 18041 - server - side prepared statements don ' t cause truncation exceptions to be thrown .
public void delete kernel ( string name ) { kernel kernel = get kernel by name ( name ) ; if ( kernel != null ) { kernel . dispose ( ) ; integer old size = integer . value of ( kernel hash table . size ( ) ) ; kernel hash table . remove ( name ) ; set dirty and fire property change ( kernel listlength changed property , old size , integer . value of ( kernel hash table . size ( ) ) ) ; } }	delete a kernel by name.
protected boolean should stop ( ) { return is paused ( ) || is killed ( ) ; }	returns true if the request is paused or killed , developers should call this method periodically to test whether they should quit the current io operation immediately.
public builder add token filter ( string name , map < string , string > params ) throws io { objects . require non null ( name , str ) ; token filters . add ( apply resource loader ( token filter factory . for name ( name , apply default params ( params ) ) ) ) ; components added = bool ; return this ; }	adds the given token filter .
public ui ( style style ) { this . style = style ; border = border factory . create line border ( style . get shadow color ( ) ) ; }	create a new styledtooltipui .
public final void add elements ( object value , int number of elements ) { if ( ( m first free + number of elements ) >= m map size ) { m map size += ( m blocksize + number of elements ) ; object new map [ ] = new object [ m map size ] ; system . arraycopy ( m map , num , new map , num , m first free + num ) ; m map = new map ; } for ( int i = num ; i < number of elements ; i ++ ) { m map [ m first free ] = value ; m first free ++ ; } }	append several object values onto the vector .
public void action performed ( action event e ) { super . action performed ( e ) ; string cmd = e . get action command ( ) ; if ( cmd == show maps command ) { j map check = ( j ) e . get source ( ) ; view attributes . show maps = map check . is selected ( ) ; repaint ( ) ; } else if ( cmd == show info command ) { j info check = ( j ) e . get source ( ) ; boolean show info = info check . is selected ( ) ; view attributes . show info = show info ; show subframes ( show info ) ; do prepare ( ) ; } else if ( cmd == lock series command ) { j lock check = ( j ) e . get source ( ) ; boolean locked = lock check . is selected ( ) ; if ( locked ) { list < rpf coverage box > coverage boxes = get coverage boxes ( ) ; string series name ; if ( coverage boxes == null || coverage boxes . is empty ( ) ) { series name = rpf view attributes . any ; } else { series name = coverage boxes . get ( num ) . chart code ; } if ( series name == null ) { series name = rpf view attributes . any ; fire request message ( str + get name ( ) + str ) ; } lock check . set text ( locked button title + str + series name ) ; view attributes . chart series = series name ; } else { lock check . set text ( unlocked button title ) ; view attributes . chart series = rpf view attributes . any ; } } else if ( cmd == show coverage command ) { if ( coverage != null ) { j coverage check = ( j ) e . get source ( ) ; coverage . set in use ( coverage check . is selected ( ) ) ; do prepare ( ) ; } } else { do prepare ( ) ; } }	the action listener method , that reacts to the palette widgets actions .
@ override public void run ( ) { if ( m delay > num ) { try { thread . sleep ( m delay ) ; } catch ( interrupted exception e ) { log impl . w ( tag , get name ( ) + str + e . get message ( ) ) ; } } if ( m parent task != null ) { synchronized ( this ) { try { wait ( ) ; } catch ( interrupted exception e ) { log impl . w ( tag , get name ( ) + str + e . get message ( ) ) ; } } } m status = status . status executing ; long start time = system . current time millis ( ) ; start ( ) ; long end time = system . current time millis ( ) ; log impl . i ( tag , get name ( ) + str + ( end time - start time ) ) ; if ( m done signal != null ) { m done signal . count down ( ) ; } if ( m child task != null ) { synchronized ( m child task ) { m child task . notify ( ) ; } } m status = status . status done ; }	normally should not override it.
public boolean has ( final string name ) { return contents . contains key ( name . to lower case ( ) ) ; }	checks whether an npc with the given name exists .
public void stop ( ) { is alive . set ( bool ) ; for ( kafka consumer < byte [ ] , byte [ ] > c : consumers . values ( ) ) { c . wakeup ( ) ; } kafka consumer executor . shutdown now ( ) ; holding buffer . clear ( ) ; io . close quietly ( this ) ; }	the method is called in the deactivate method of the operator.
public string consume element selector ( ) { int start = pos ; while ( ! is empty ( ) && ( matches word ( ) || matches any ( str , str , str ) ) ) pos ++ ; return queue . substring ( start , pos ) ; }	consume a css element selector ( tag name , but | instead of : for namespaces , to not conflict with : pseudo selects ) .
@ suppress warnings ( str ) public long map ( int initial capacity , float load factor ) { if ( initial capacity < num ) throw new illegal argument exception ( str + initial capacity ) ; if ( initial capacity > num << num ) throw new illegal argument exception ( str + initial capacity ) ; capacity = next power of two ( initial capacity ) ; if ( load factor <= num ) throw new illegal argument exception ( str + load factor ) ; this . load factor = load factor ; threshold = ( int ) ( capacity * load factor ) ; mask = capacity - num ; hash shift = num - long . number of trailing zeros ( capacity ) ; stash capacity = math . max ( num , ( int ) math . ceil ( math . log ( capacity ) ) * num ) ; push iterations = math . max ( math . min ( capacity , num ) , ( int ) math . sqrt ( capacity ) / num ) ; key table = new long [ capacity + stash capacity ] ; value table = ( v [ ] ) new object [ key table . length ] ; }	creates a new map with the specified initial capacity and load factor.
public void end attributes ( ) throws sax { string uri = get current element uri ( ) ; string local = get current element local ( ) ; string prefix = ns context . get prefix ( uri ) ; assert ( prefix != null ) ; string qname ; if ( prefix . length ( ) != num ) qname = prefix + str + local ; else qname = local ; ns context . iterate declared prefixes ( start prefix callback ) ; writer . start element ( uri , local , qname , attributes ) ; attributes . clear ( ) ; text buf . set length ( num ) ; }	switches to the " marshal child texts / elements " mode.
private string abbreviate script ( string script ) { if ( script == null ) { return null ; } if ( script . length ( ) <= num ) { return script ; } return str + script . substring ( num , num ) ; }	abbreviates this script to a length that will fit in the database .
public static void expand id ( string number string , word relation word relation , item token item ) { int number digits = number string . length ( ) ; if ( ( number digits == num ) && ( number string . char at ( num ) == str ) && ( number string . char at ( num ) == str ) ) { if ( number string . char at ( num ) == str ) { expand number ( number string , word relation , token item ) ; } else { expand number ( number string . substring ( num , num ) , word relation , token item ) ; word relation . add word ( token item , str ) ; } } else if ( ( number digits == num ) && ( number string . char at ( num ) == str ) ) { word relation . add word ( token item , str ) ; expand digits ( number string . substring ( num , num ) , word relation , token item ) ; } else if ( ( number digits == num && number string . char at ( num ) == str ) || number digits < num ) { expand number ( number string , word relation , token item ) ; } else if ( number digits % num == num ) { string first digit = digit2num [ number string . char at ( num ) - str ] ; word relation . add word ( token item , first digit ) ; expand id ( number string . substring ( num , number digits ) , word relation , token item ) ; } else { expand number ( number string . substring ( num , num ) , word relation , token item ) ; expand id ( number string . substring ( num , number digits ) , word relation , token item ) ; } }	expands the given number string as pairs as in years or ids.
private static void unregister mbeans from props file ( m m bean server ) throws exception { jamon properties loader loader = new jamon properties loader ( ) ; list < string > jamon jmx bean properties = loader . get mx beans ( ) ; iterator < string > iter = jamon jmx bean properties . iterator ( ) ; while ( iter . has next ( ) ) { string bean info = iter . next ( ) ; mx m xbean = mx . create ( bean info ) ; m bean server . unregister m ( mx . get object name ( m xbean ) ) ; mx m xbean delta = mx . create delta ( bean info ) ; m bean server . unregister m ( mx . get delta object name ( m xbean delta ) ) ; } }	read the properties file and unregister its configurable jamon jmx beans.
source pop import source ( ) { return ( source ) m import source stack . pop ( ) ; }	pop a source from a user provided uriresolver , corresponding to the url popped from the m_importstack .
public static date zero time date ( date date ) { final gregorian calendar gregorian calendar = new gregorian calendar ( ) ; gregorian calendar . set time ( date ) ; gregorian calendar . set ( calendar . hour of day , num ) ; gregorian calendar . set ( calendar . minute , num ) ; gregorian calendar . set ( calendar . second , num ) ; gregorian calendar . set ( calendar . millisecond , num ) ; return gregorian calendar . get time ( ) ; }	reset the time of a date.
public static final void write map xml ( map val , string name , xml serializer out ) throws xml pull parser exception , io { if ( val == null ) { out . start tag ( null , str ) ; out . end tag ( null , str ) ; return ; } set s = val . entry set ( ) ; iterator i = s . iterator ( ) ; out . start tag ( null , str ) ; if ( name != null ) { out . attribute ( null , str , name ) ; } while ( i . has next ( ) ) { map . entry e = ( map . entry ) i . next ( ) ; write value xml ( e . get value ( ) , ( string ) e . get key ( ) , out ) ; } out . end tag ( null , str ) ; }	flatten a map into an xmlserializer.
protected void export ( ) { int ret val ; file file ; abstract file saver saver ; if ( m == null ) m = gui . new converter file chooser ( ) ; ret val = m . show save dialog ( this ) ; if ( ret val != converter file chooser . approve option ) return ; file = m . get selected file ( ) ; saver = m . get saver ( ) ; try { saver . set instances ( m . get instances ( ) ) ; saver . write batch ( ) ; } catch ( exception e ) { j . show message dialog ( this , str + file + str + utils . throwable to string ( e ) , str , j . error message ) ; } }	exports the data to a file .
public void sort ( int i ) { arrays . sort ( vector [ i ] , num , sizes . get ( i ) ) ; }	sorts the selected row in increasing order .
private void create map when needed ( ) { if ( is map initialized ) { return ; } if ( resource bundle != null ) { set < string > set = resource bundle . key set ( ) ; top level map = new hash map < string , object > ( set . size ( ) ) ; for ( string key : set ) { object value = resource bundle . get object ( key ) ; top level map . put ( key , value ) ; } } else { top level map = new hash map < string , object > ( num ) ; } top level map . put ( str , resource bundle ) ; is map initialized = bool ; }	creates the toplevelmap only when it is required.
public static vector clock increment ( vector clock clock , int ... nodes ) { for ( int n : nodes ) clock = clock . incremented ( ( short ) n , system . current time millis ( ) ) ; return clock ; }	record events for the given sequence of nodes.
@ override public string to string ( ) { return str + set . to string ( ) ; }	returns a string representation of the set.
void create heap phi instruction ( basic block bb , heap variable < object > h ) { instruction s = make phi instruction ( h , bb ) ; array list < instruction > heap phis = heap phi . get ( bb ) ; if ( heap phis == null ) { heap phis = new array list < instruction > ( num ) ; heap phi . put ( bb , heap phis ) ; } heap phis . add ( s ) ; register instruction ( s , bb ) ; }	create a heap control phi instruction , and store it at the beginning of a basic block .
protected void print time ( string s ) { simple date format date format = new simple date format ( str ) ; println ( date format . format ( new java . util . date ( ) ) + str + s ) ; }	print the current time and a message to system out .
public static int determine sample size ( image request image request , encoded image encoded image ) { if ( ! encoded image . is meta data available ( encoded image ) ) { return default sample size ; } float ratio = determine downsample ratio ( image request , encoded image ) ; int sample size ; if ( encoded image . get image format ( ) == image format . jpeg ) { sample size = ratio to sample size jpeg ( ratio ) ; } else { sample size = ratio to sample size ( ratio ) ; } int max dimension = math . max ( encoded image . get height ( ) , encoded image . get width ( ) ) ; while ( max dimension / sample size > max bitmap size ) { if ( encoded image . get image format ( ) == image format . jpeg ) { sample size *= num ; } else { sample size ++ ; } } return sample size ; }	get the factor between the dimensions of the encodedimage ( actual image ) and the ones of the imagerequest ( requested size ) .
public skeleton ( print writer out ) { this . out = out ; }	creates a new skeleton ( iterator ) instance .
public void disconnect ( ) { if ( conn != null ) { try { conn . close ( ) ; } catch ( sql e ) { logger . warn ( str , e ) ; } } try { close binlog ( ) ; } catch ( io e ) { logger . warn ( str , e ) ; } }	clean up after termination .
@ override public int read ( byte [ ] b , int off , int len ) throws io { int n = in . read ( b , off , len ) ; if ( n == - num ) { throw if false eof ( ) ; } else { bytes read += n ; } return n ; }	java . io . inputstream # read ( byte [ ] , int , int ) swallows ioexception thrown from read ( ) so we have to override it .
@ override public generator < i > construct ( string [ ] args ) { return new integer generator ( integer . value of ( args [ num ] ) , integer . value of ( args [ num ] ) ) ; }	provide reflective behavior to construct instance of generator given an array of string arguments .
public spatial strategy ( spatial context ctx , string field name ) { if ( ctx == null ) throw new illegal argument exception ( str ) ; this . ctx = ctx ; if ( field name == null || field name . length ( ) == num ) throw new illegal argument exception ( str ) ; this . field name = field name ; }	constructs the spatial strategy with its mandatory arguments .
public void dispose ( ) { if ( keys != null ) { keys . clear ( ) ; keys = null ; } super . dispose ( ) ; }	dispose - free resources.
public boolean is fixed disk ( string letter ) { if ( letter . length ( ) != num ) throw new illegal argument exception ( str + letter ) ; char drive = character . to upper case ( letter . char at ( num ) ) ; if ( drive < str || drive > str ) throw new illegal argument exception ( str + drive ) ; return get drive type ( drive + str ) == num ; }	feed it a drive letter ( such as ' a ' ) to see if it is a fixed disk .
private object [ ] compile ( string path ) { list list = new array list ( ) ; if ( path == null ) { return list . to array ( ) ; } string tokenizer tok = new string tokenizer ( path , str ) ; while ( tok . has more tokens ( ) ) { string token = tok . next token ( ) ; op enum op = op enum . get instance ( token ) ; if ( op == null ) { throw new error ( str + path ) ; } list . add ( op ) ; if ( op == op enum . relation ) { list . add ( tok . next token ( ) ) ; } } return list . to array ( ) ; }	compiles the given path into the compiled form.
private void split chunk ( final memory chunk chunk , final long address ) { final byte [ ] old data = chunk . get bytes ( ) ; final byte [ ] new data1 = new byte [ ( int ) ( address - chunk . get address ( ) ) ] ; final byte [ ] new data2 = new byte [ ( chunk . get length ( ) - new data1 . length ) ] ; system . arraycopy ( old data , num , new data1 , num , new data1 . length ) ; system . arraycopy ( old data , old data . length - new data2 . length , new data2 , num , new data2 . length ) ; final memory chunk new chunk1 = new memory chunk ( chunk . get address ( ) , new data1 ) ; final memory chunk new chunk2 = new memory chunk ( ( chunk . get address ( ) + chunk . get length ( ) ) - new data2 . length , new data2 ) ; remove chunk ( chunk ) ; insert chunk ( new chunk1 ) ; insert chunk ( new chunk2 ) ; }	splits a chunk into two chunks .
public boolean is dirty ( ) { return dirty ; }	check if preferences need to be saved .
private vector show text fixed width ( string text , int align ) { vector comps = new vector ( ) ; if ( ( text == null ) || ( text . equals ( str ) ) ) { return comps ; } int space w = width - x ; vector words = get words ( text , align , bool ) ; if ( words . size ( ) > num ) { int w = num ; string word str = str ; if ( ( css . is white space ( text . char at ( num ) ) ) && ( cur line . get component count ( ) != num ) ) { word str = str ; } while ( w < words . size ( ) ) { string next word = ( string ) words . element at ( w ) ; string space = str ; if ( ( ! word str . equals ( str ) ) && ( ! word str . equals ( str ) ) ) { space = str ; } if ( font . string width ( word str + space + next word ) > space w - num ) { comps . add element ( add string ( word str , align ) ) ; new line if not empty ( align ) ; space w = width - x ; word str = next word ; } else { word str += space + next word ; } w ++ ; } if ( css . is white space ( text . char at ( text . length ( ) - num ) ) ) { word str += str ; } comps . add element ( add string ( word str , align ) ) ; } return comps ; }	shows the given text.
private void calculate slot usage ( ) { num entries = num ; for ( int i = num ; i < table . table . length ; i ++ ) { linked list < v > list = ( linked list < v > ) table . table [ i ] ; if ( list != null ) { num entries += list . size ( ) ; int hash table [ i ] += list . size ( ) ; } } }	compute usages based upon the table .
public insert default values ( ) { default values = bool ; columns . clear ( ) ; values to insert . clear ( ) ; query = null ; invalidate compile cache ( ) ; return this ; }	insert default values for the columns into the table.
public c ( final file directory ) { preconditions . check argument ( directory . exists ( ) , str ) ; m directory = directory ; }	filter for jformattedtextfield . ensures valid filenames . does not work for directories .
public t pop ( ) { return list . remove last ( ) ; }	removes the object at the top of this stack and returns that object as the value of this function .
public static string node list to string ( list < ? extends node > list ) { string buffer buf = new string buffer ( ) ; buf . append ( str ) ; if ( list . size ( ) > num ) { buf . append ( str + dom to string ( list . get ( num ) ) + str ) ; for ( int i = num ; i < list . size ( ) ; ++ i ) { buf . append ( str + i + str + dom to string ( list . get ( num ) ) + str ) ; } buf . append ( str ) ; } buf . append ( str ) ; return buf . to string ( ) ; }	* prettyprints a list < node >.
protected element adapt ( element source , element metadata < ? , ? > source meta , string kind ) { element key < ? , ? > adaptor key = source meta . adapt ( kind ) ; if ( adaptor key != null ) { try { return adapt ( adaptor key , source ) ; } catch ( content creation exception e ) { logger . log ( level . severe , str + source . get class ( ) + str + adaptor key . get element type ( ) , e ) ; } } return source ; }	adapts an element based on a key.
public string convert alias to number ( string alias name ) { if ( ! alias name . contains ( str ) && alias database . contains alias ( alias name ) ) { string [ ] res = alias database . get alias ( alias name ) ; return res [ num ] ; } return alias name ; }	converts an given alias to a unique phone number.
public attr ( string name , @ nullable format format ) { this . name = name ; if ( format != null ) { formats = collections . singleton list ( format ) ; } }	construct a new attribute.
static stream tokenizer make tokenizer ( string tag value ) { stream tokenizer tokenizer = new stream tokenizer ( new string reader ( tag value ) ) ; tokenizer . reset syntax ( ) ; tokenizer . word chars ( str , str ) ; tokenizer . word chars ( str , str ) ; tokenizer . word chars ( str , str ) ; tokenizer . word chars ( str , str ) ; tokenizer . word chars ( str , str ) ; tokenizer . word chars ( str , str ) ; tokenizer . word chars ( str , str ) ; tokenizer . word chars ( str , str ) ; tokenizer . quote char ( str ) ; tokenizer . quote char ( str ) ; tokenizer . whitespace chars ( str , str ) ; tokenizer . whitespace chars ( str , str ) ; tokenizer . whitespace chars ( str , str ) ; tokenizer . whitespace chars ( str , str ) ; tokenizer . eol is significant ( bool ) ; return tokenizer ; }	create a streamtokenizer suitable for parsing the tag text .
private void send request ( ) { int i = tab pane . get selected index ( ) ; string prompt = rb . get string ( str + i + str ) ; if ( log . is debug enabled ( ) ) { log . debug ( str + prompt + str + i ) ; } if ( source == null ) { log . error ( str ) ; timer . stop ( ) ; return ; } source . send bytes ( prompt . get bytes ( ) ) ; }	time to send the next request.
public void remove ( predicate filter ) { for ( int iterator ii = rows ( filter ) ; ii . has next ( ) ; ) remove row ( ii . next int ( ) ) ; }	removes all table rows that meet the input predicate filter .
private void calculate trim area ( rect bounds ) { float size = math . min ( bounds . height ( ) , bounds . width ( ) ) ; float y offset = ( bounds . height ( ) - size ) / num ; float x offset = ( bounds . width ( ) - size ) / num ; float padding = m padding + ( bounds . height ( ) - num * m padding ) * num / num ; m internal bounds . set ( bounds . left + padding + x offset , bounds . top + padding + y offset , bounds . right - padding - x offset , bounds . bottom - padding - y offset ) ; m center = m internal bounds . center x ( ) ; m size = m internal bounds . width ( ) ; m play tip offset = num / num * m size ; m play base offset = num * m size ; set transition state ( num , num ) ; }	this calculates the trim area for the icon as specified in the guidelines.
protected void init instances ( operation post , service document ... states ) { init instances ( post , bool , bool , states ) ; }	initialize a list of service default states if not already created.
protected instance merge instances ( instance source , instance dest ) { instances output format = output format peek ( ) ; double [ ] vals = new double [ output format . num attributes ( ) ] ; for ( int i = num ; i < vals . length ; i ++ ) { if ( ( i != output format . class index ( ) ) && ( m . is in range ( i ) ) ) { if ( ( source != null ) && ! source . is missing ( i ) && ! dest . is missing ( i ) ) { vals [ i ] = dest . value ( i ) - source . value ( i ) ; } else { vals [ i ] = utils . missing value ( ) ; } } else { vals [ i ] = dest . value ( i ) ; } } instance inst = null ; if ( dest instanceof sparse instance ) { inst = new sparse instance ( dest . weight ( ) , vals ) ; } else { inst = new dense instance ( dest . weight ( ) , vals ) ; } inst . set dataset ( dest . dataset ( ) ) ; return inst ; }	creates a new instance the same as one instance ( the " destination " ) but with some attribute values copied from another instance ( the " source " ).
public source call chain builder ( int timeout , boolean process callbacks ) { this . timeout = timeout ; this . process callbacks = process callbacks ; }	create a sourcecallchainbuilder with specified timeout and process_callbacks flag .
public synchronized float recovered bytes percent ( ) { long total = num ; long recovered = num ; for ( file file : file details . values ( ) ) { if ( file . reused ( ) == bool ) { total += file . length ( ) ; recovered += file . recovered ( ) ; } } if ( total == num && file details . size ( ) == num ) { return num ; } if ( total == recovered ) { return num ; } else { return num * recovered / total ; } }	percent of bytes recovered out of total files bytes * to be * recovered.
public < e extends t > event binder < e > on ( ) { return new event binder < > ( optional . empty ( ) ) ; }	retrieves the eventbinder object to bind an eventlistener to ths eventbus that only accepts a specific subclass of & lt ; t & gt ;.
private boolean is value supported ( object value ) { for ( int i = num ; i < values . length ; i ++ ) { if ( value . equals ( values [ i ] ) ) { return bool ; } } return bool ; }	indicates whether the value specified is supported .
public static bit set from byte array ( byte [ ] bytes ) { bit set bits = new bit set ( ) ; for ( int i = num ; i < bytes . length * num ; i ++ ) { if ( ( bytes [ bytes . length - i / num - num ] & ( num << ( i % num ) ) ) > num ) { bits . set ( i ) ; } } return bits ; }	returns a bitset containing the values in bytes.
public repeat time create repeat time ( int repeat interval , int active duration , int [ ] offsets ) { repeat field repeat time field = new repeat field ( ) ; try { repeat time field . set repeat interval ( repeat interval ) ; repeat time field . set active duration ( active duration ) ; repeat time field . set offset array ( offsets ) ; } catch ( sdp exception s ) { s . print stack trace ( ) ; } return repeat time field ; }	returns a repeattime object with the specified interval , duration , and time offsets .
public void remove ( int i ) { if ( ( i >= array . length ) || ( i < num ) ) throw new array index out of bounds exception ( str + i + str + array . length ) ; ns [ ] new array = new ns [ array . length - num ] ; system . arraycopy ( array , num , new array , num , i ) ; system . arraycopy ( array , i + num , new array , i , array . length - i - num ) ; array = new array ; }	remove the i - th element from the array.
private time parse time ( string time string ) throws parse exception { java . util . date parsed date = time field . parse ( time string ) ; if ( parsed date == null ) return null ; return new time ( parsed date . get time ( ) ) ; }	parses the given string into a corresponding time.
private void decrement copy field target count ( schema field dest ) { integer count = copy field target counts . get ( dest ) ; assert count != null ; if ( count <= num ) { copy field target counts . remove ( dest ) ; } else { copy field target counts . put ( dest , count - num ) ; } }	decrements the count for the given destination field in copyfieldtargetcounts .
public static calendar from unix time ( long unix time , time unit time unit ) { calendar calendar = get calendar instance ( ) ; calendar . set time zone ( time zone . get default ( ) ) ; long millis = time unit . to millis ( unix time ) ; calendar . set time in millis ( millis ) ; return calendar ; }	converts unix time in the given time units into java calendar time.
public boolean is layout id in record ( int layout id ) { return m layout ids != null && m layout ids . contains ( layout id ) ; }	is the recorded layout id.
private void open board design action ( ) { design file design file = open dialog ( stat , main options . design dir name ) ; if ( design file == null ) { stat . user println ( resources . get string ( str ) ) ; return ; } string message = resources . get string ( str ) + str + design file . get name ( ) ; stat . user println ( message ) ; board frame board frame = new board frame ( design file , stat ) ; import design d import = new import design ( board frame ) ; d import . execute ( ) ; }	opens a board design from a binary file or a specctra dsn file need to detach from swing thread since messages are not printed.
public static string retrieve display name ( string id , boolean daylight , int style , locale locale ) { string [ ] names = retrieve display names impl ( id , locale ) ; if ( objects . non null ( names ) ) { return names [ ( daylight ? num : num ) - style ] ; } else { return null ; } }	retrieves a standard or daylight - saving time name for the given time zone id .
protected query new fuzzy query ( term term , float minimum similarity , int prefix length ) { string text = term . text ( ) ; int num edits = fuzzy query . float to edits ( minimum similarity , text . code point count ( num , text . length ( ) ) ) ; return new fuzzy query ( term , num edits , prefix length ) ; }	builds a new fuzzyquery instance.
@ override public void play video ( uri uri , string title ) { camera activity activity = m activity . get ( ) ; if ( activity != null ) { camera util . play video ( activity , uri , title ) ; } }	fires an intent to play the video with the given uri and title .
public void copy from ( path other ) { grow ( other . length - num ) ; system . arraycopy ( other . block id list , num , this . block id list , num , other . length ) ; this . length = other . length ; this . cached hash code = other . cached hash code ; }	make this path identical to the given one .
void recover messages ( ) throws rollback failed exception { if ( m is queue ) { if ( logger . is loggable ( level . fine ) ) { logger . log ( level . fine , str ) ; } unacked messages . clear ( ) ; if ( ! is auto ack ( ) ) { rollback local transaction ( ) ; } } else { if ( logger . is loggable ( level . fine ) ) { logger . log ( level . fine , str ) ; } unacked messages . add all ( recover messages ) ; linked list < message queue element > temp = unacked messages ; recover messages . clear ( ) ; unacked messages = recover messages ; recover messages = temp ; } }	performs session recovery . with topics , we redeliver the unacked messages that arrived to the session ( local redelivery ) . with queues , we return the messages to the space so they can be redelivered from there .
private map < key , array > store ( class clazz ) { method [ ] methods = clazz . get methods ( ) ; map < key , array > methods map = new concurrent hash map < key , array > ( ) ; for ( int i = num ; i < methods . length ; i ++ ) { store method ( methods [ i ] , methods map ) ; } map . put ( clazz , methods map ) ; return methods map ; }	store a class with his methods.
protected int read fully ( input stream in , byte buffer [ ] , int offset , int len ) throws io { for ( int i = num ; i < len ; i ++ ) { int q = in . read ( ) ; if ( q == - num ) return ( ( i == num ) ? - num : i ) ; buffer [ i + offset ] = ( byte ) q ; } return len ; }	this method works around the bizarre semantics of bufferedinputstream ' s read method .
private long renew service lease do ( id service id , uuid lease id , long renew duration ) throws unknown lease exception { long now = system . current time millis ( ) ; long renew expiration = renew service lease int ( service id , lease id , renew duration , now ) ; add log record ( new service lease renewed log obj ( service id , lease id , renew expiration ) ) ; return renew expiration - now ; }	the code that does the real work of renewservicelease .
public block swapper ( world world , entity player player , item stack truncator , block pos orig coords , int range , boolean leaves ) { this . world = world ; this . player = player ; this . truncator = truncator ; this . origin = orig coords ; this . range = range ; this . treat leaves special = leaves ; this . candidate queue = new priority queue < > ( ) ; this . completed coords = new hash set < > ( ) ; candidate queue . offer ( new swap candidate ( this . origin , this . range ) ) ; }	creates a new block swapper with the provided parameters .
public static string [ ] to string array ( enumeration < string > enumeration ) { if ( enumeration == null ) { return null ; } list < string > list = collections . list ( enumeration ) ; return list . to array ( new string [ list . size ( ) ] ) ; }	copy the given enumeration into a string array.
public boolean overlap save ( sphere cluster other ) { double min dist = math . sqrt ( num ) * ( get radius ( ) + other . get radius ( ) ) ; double diff = get center distance ( other ) - min dist ; return diff > num ; }	when a clusters looses points the new minimal bounding sphere can be partly outside of the originating cluster.
@ put @ consumes ( { media type . application xml , media type . application json } ) @ path ( str ) @ produces ( { media type . application xml , media type . application json } ) @ check permission ( roles = { role . system admin , role . restricted system admin } ) public file virtual pool rest rep update file virtual pool with assigned pools ( @ path param ( str ) uri id , virtual pool pool update param param ) { virtual pool v pool = update virtual pool with assigned storage pools ( id , param ) ; return to file virtual pool ( v pool , virtual pool . get file remote protection settings ( v pool , db client ) ) ; }	update file virtualpool only allows user to assign matching storage pools .
public static java . sql . date to sql date ( int month , int day , int year ) { java . util . date new date = to date ( month , day , year , num , num , num ) ; if ( new date != null ) { return new java . sql . date ( new date . get time ( ) ) ; } else { return null ; } }	makes a java . sql . date from separate ints for month , day , year.
public object read default list model ( element node ) throws exception { default list model model ; vector < element > children ; element child ; int i ; int index ; int curr index ; if ( debug ) { trace ( new throwable ( ) , node . get attribute ( att name ) ) ; } m = node ; children = xml . get child tags ( node ) ; model = new default list model ( ) ; index = children . size ( ) - num ; for ( i = num ; i < children . size ( ) ; i ++ ) { child = children . get ( i ) ; curr index = integer . parse int ( child . get attribute ( att name ) ) ; if ( curr index > index ) { index = curr index ; } } model . set size ( index + num ) ; for ( i = num ; i < children . size ( ) ; i ++ ) { child = children . get ( i ) ; model . set ( integer . parse int ( child . get attribute ( att name ) ) , invoke read from xml ( child ) ) ; } return model ; }	builds the defaultlistmodel from the given dom node .
private boolean results identical ( string named curve , big integer bad x , big integer bad y , big integer secret , int iter ) throws invalid algorithm parameter exception , no such algorithm exception , invalid key spec exception , invalid key exception { for ( int i = num ; i < iter ; i ++ ) { secret = secret . add ( big integer . one ) ; big integer result custom = compute secret with custom algorithm ( named curve , bad x , bad y , secret ) ; big integer result sun = compute secret with sun algorithm ( named curve , bad x , bad y , secret ) ; if ( result sun != null && ! result sun . equals ( result custom ) ) { return bool ; } } return bool ; }	executes point multiplication with custom and java sun computation.
public void enable layers ( boolean enable ) { texture state texture state = ( texture state ) get local render state ( render state . state type . texture ) ; texture state . set enabled ( enable ) ; mark dirty ( dirty type . render state ) ; }	enable the layers on this mesh .
protected void starve randomly ( int limit ) { while ( population . size ( ) > limit ) { int remove pos = randomness . next int ( ) % population . size ( ) ; population . remove ( remove pos ) ; } }	this method can be used to kick out random chromosomes in the current population until the given limit is reached again .
public void save param ( ) throws exception { enumeration < abstract param panel > en = table panel . elements ( ) ; abstract param panel panel = null ; while ( en . has more elements ( ) ) { panel = en . next element ( ) ; panel . save param ( param object ) ; } }	saves the data of all panels , throwing an exception if there ' s any error.
@ suppress warnings ( str ) public static local streaming container wait for activation ( stram local cluster local cluster , pt operator ) throws interrupted exception { local streaming container container ; long start millis = system . current time millis ( ) ; while ( system . current time millis ( ) < ( start millis + default timeout millis ) ) { if ( operator . get state ( ) == pt . state . active ) { if ( ( container = local cluster . get container ( operator ) ) != null ) { return container ; } } log . debug ( str , new object [ ] { operator , operator . get state ( ) , operator . get container ( ) } ) ; thread . sleep ( num ) ; } assert . fail ( str + operator ) ; return null ; }	wait until instance of operator is deployed into a container and return the container reference.
protected string to external form ( url url ) { return to external form ( url , bool ) ; }	returns the clear text representation of a given url using http format .
public result set execute query ( string query ) throws sql , no connection exception { if ( connection != null ) { statement st = connection . create statement ( ) ; return st . execute query ( query ) ; } throw new no connection exception ( ) ; }	executes an sql query.
private void reject access and terminate process ( radius response response , context holder holder ) { response . set response packet ( new access reject ( ) ) ; response . set universal id ( holder . get universal id ( ) ) ; terminate authn process ( holder ) ; }	sends a radius accessreject response and cleans up the cache and authentication context if it not null by calling its logout method .
public sc volume create view volume ( string name , string instance id ) throws api { log . debug ( str , instance id ) ; string error message = str ; parameters params = new parameters ( ) ; params . add ( str , name ) ; params . add ( str , notes string ) ; try { rest result result = rest client . post ( string . format ( str , instance id ) , params . to json ( ) ) ; if ( check results ( result ) ) { return gson . from json ( result . get result ( ) , sc volume . class ) ; } } catch ( exception e ) { error message = string . format ( str , e ) ; log . warn ( error message ) ; } if ( error message . length ( ) == num ) { error message = string . format ( str , name , instance id ) ; } throw new api ( error message ) ; }	creates a volume from a snapshot .
@ override public boolean contains ( object object ) { return index of ( object , num ) != - num ; }	searches this vector for the specified object .
public void sync ( ) throws storage fault { final string method name = str ; log . debug ( method name + str ) ; try { log . trace ( method name + str ) ; sync manager . sync all ( ) ; } catch ( sos e ) { log . error ( method name + str , e ) ; throw fault util . storage fault ( e ) ; } log . debug ( method name + str ) ; }	caches project and tenant ids for further operations.
private void add menu item ( j menu , string title , mwf line ) { wf item = new wf ( title , line ) ; menu . add ( item ) ; item . add action listener ( this ) ; }	add menu item to - delete line.
public static matcher < binding set > binds ( string name , class < ? > value ) { return new binds matcher < object > ( name , instance of ( value ) ) ; }	check binding to specific class .
private void test add ( ) throws exception { log . info ( str ) ; long msg count = message mapper . count messages in mailbox ( mboxes . get ( num ) ) ; log . info ( msg count + str + message no . size ( ) ) ; assert equals ( message no . size ( ) , msg count ) ; }	test of add method , of class hbasemessagemapper .
public void cancel task no exception ( task task ) { try { cancel task ( task ) ; } catch ( exception e ) { log . error ( str ) ; } }	cancels the vmware task without throwing an exception.
public string to string ( ) { return to indented string ( num ) ; }	returns an indented string representation of this element and any contained child elements .
public int read ( byte b [ ] , int off , int len ) throws io , log exception { if ( length < len ) bad read ( len ) ; len = in . read ( b , off , len ) ; length -= len ; return len ; }	reads data into an array of bytes.
public static void migrate from6 to7 ( sq db ) { string select query = str + database helper . table griditemrelations ; cursor c = db . raw query ( select query , null ) ; if ( c . move to first ( ) ) { do { try { int grid itemid = c . get int ( c . get column index ( database helper . key id ) ) ; int plugin id = c . get int ( c . get column index ( database helper . key griditemrelations plugin ) ) ; string pluginpage url query = str + database helper . key muninplugins pluginpageurl + str + database helper . table muninplugins + str + database helper . key id + str + plugin id ; cursor c2 = db . raw query ( pluginpage url query , null ) ; if ( c2 . move to first ( ) ) { string pluginpage url = c2 . get string ( c2 . get column index ( database helper . key muninplugins pluginpageurl ) ) ; content values values = new content values ( ) ; values . put ( database helper . key griditemrelations pluginpageurl , pluginpage url ) ; db . update ( database helper . table griditemrelations , values , database helper . key id + str , new string [ ] { string . value of ( grid itemid ) } ) ; } c2 . close ( ) ; } catch ( exception ex ) { ex . print stack trace ( ) ; } } while ( c . move to next ( ) ) ; } c . close ( ) ; }	from db version 7 , we began to store plugin page url in order to retrieve it whenever the plugin gets deleted.
@ override public void dataset changed ( dataset change event event ) { fire dataset changed ( ) ; }	receives a change event from the underlying dataset and responds by firing a change event for this dataset .
public void drawing complete ( om omg , om action ) { if ( timer button . is selected ( ) ) { timer . restart ( ) ; } if ( omg instanceof om ) { om p = ( om ) omg ; gl mp = new gl ( p . get lat ( ) , p . get lon ( ) , p . get radius ( ) , bool ) ; mp . set name ( str + ( point count ++ ) ) ; mp . set stationary ( bool ) ; mp . show palette ( ) ; points . put ( mp . get name ( ) , mp ) ; manage graphics ( ) ; } else if ( omg instanceof om ) { om poly = ( om ) omg ; gl pmp = new gl ( poly , num , bool ) ; pmp . set name ( str + ( point count ++ ) ) ; pmp . show palette ( ) ; points . put ( pmp . get name ( ) , pmp ) ; manage graphics ( ) ; } add node button . set enabled ( bool ) ; add path button . set enabled ( bool ) ; }	the method where a graphic , and an action to take on the graphic , arrives .
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return cookie ; case num : return user id ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public charset charset ( ) { return charset != null ? charset . for name ( charset ) : null ; }	returns the charset of this media type , or null if this media type doesn ' t specify a charset .
public driver task delete volume mirror ( volume mirror mirror ) { log . info ( str , mirror ) ; sc task = new sc ( str ) ; try { api api = connection manager . get connection ( mirror . get storage system id ( ) ) ; sc copy mirror migrate cmm = api . get mirror ( mirror . get native id ( ) ) ; api . delete mirror ( cmm . instance id ) ; api . delete volume ( cmm . destination volume . instance id ) ; task . set status ( task status . ready ) ; } catch ( api | sc dex ) { string error = string . format ( str , mirror . get native id ( ) , dex ) ; log . error ( error ) ; task . set failed ( error ) ; } return task ; }	delete volume mirror and the destination volume .
public void test connect ( ) throws io { connect without server ( ) ; disconnect after connected ( ) ; }	test method for ' datagramchannelimpl . connect ( socketaddress ) '.
public byte array data provider ( byte [ ] bytes ) { this . bytes = arrays . copy of ( bytes , bytes . length ) ; }	instantiates a new mxf byte array data provider .
public static string generate native guid for physical nas ( string system native guid , string p nas name ) { return string . format ( str + physical nas + str , system native guid , p nas name ) ; }	generates the nativeguid format as systemnativeguid + physicalnasname for physical nas .
private void expire ( ) { if ( m expire != num && m time exp < system . current time millis ( ) ) { reset ( ) ; } }	expire cache if enabled.
private static int determine consecutive binary count ( string msg , int startpos , charset encoding ) throws writer exception { final charset encoder encoder = encoding . new encoder ( ) ; int len = msg . length ( ) ; int idx = startpos ; while ( idx < len ) { char ch = msg . char at ( idx ) ; int numeric count = num ; while ( numeric count < num && is digit ( ch ) ) { numeric count ++ ; int i = idx + numeric count ; if ( i >= len ) { break ; } ch = msg . char at ( i ) ; } if ( numeric count >= num ) { return idx - startpos ; } ch = msg . char at ( idx ) ; if ( ! encoder . can encode ( ch ) ) { throw new writer exception ( str + ch + str + ( int ) ch + str ) ; } idx ++ ; } return idx - startpos ; }	determines the number of consecutive characters that are encodable using binary compaction .
private boolean apply ( grid client predicate < n > [ ] p , n n ) { if ( p != null ) { for ( grid client predicate < ? super n > r : p ) { if ( r != null && ! r . apply ( n ) ) return bool ; } } return bool ; }	apply predicate to the node .
public boolean has name ( final string name ) { for ( final string n : names ) { if ( n . equals ignore case ( name ) ) { return bool ; } } return bool ; }	indicates whether this schema definition has the specified name .
public void dup2 x2 ( ) { mv . visit insn ( opcodes . du ) ; }	generates a dup2_x2 instruction .
@ override public boolean contains ( object key ) { if ( key == null ) return map . null value != null ; k1 [ ] keys = map . keys ; for ( int i = keys . length - num ; i >= num ; i -- ) { k1 test key = keys [ i ] ; if ( key . equals ( test key ) ) return bool ; } return bool ; }	returns true if the map contains the value .
public static void replace value ( example set example set , attribute attribute , string old value , string new value ) { if ( ! attribute . is nominal ( ) ) { throw new runtime exception ( str ) ; } nominal mapping mapping = attribute . get mapping ( ) ; if ( old value . equals ( str ) ) { for ( example example : example set ) { if ( double . is na n ( example . get value ( attribute ) ) ) { example . set value ( attribute , mapping . map string ( new value ) ) ; } } } else { int old index = mapping . get index ( old value ) ; if ( old index < num ) { throw new runtime exception ( str ) ; } if ( new value . equals ( str ) ) { for ( example example : example set ) { int index = mapping . get index ( example . get value as string ( attribute ) ) ; if ( index == old index ) { example . set value ( attribute , double . n ) ; } } return ; } int new index = mapping . get index ( new value ) ; if ( new index >= num ) { for ( example example : example set ) { int index = mapping . get index ( example . get value as string ( attribute ) ) ; if ( index == old index ) { example . set value ( attribute , new index ) ; } } } else { mapping . set mapping ( new value , old index ) ; } } }	replaces the given value by the new one.
protected void encode ( byte sequences writer writer , byte array data output output , byte [ ] buffer , bytes ref spare , bytes ref payload , set < bytes ref > contexts , long weight ) throws io { int required length = spare . length + num + ( ( has payloads ) ? num + payload . length : num ) ; if ( has contexts ) { for ( bytes ref ctx : contexts ) { required length += num + ctx . length ; } required length += num ; } if ( required length >= buffer . length ) { buffer = array util . grow ( buffer , required length ) ; } output . reset ( buffer ) ; output . write bytes ( spare . bytes , spare . offset , spare . length ) ; if ( has contexts ) { for ( bytes ref ctx : contexts ) { output . write bytes ( ctx . bytes , ctx . offset , ctx . length ) ; output . write short ( ( short ) ctx . length ) ; } output . write short ( ( short ) contexts . size ( ) ) ; } if ( has payloads ) { output . write bytes ( payload . bytes , payload . offset , payload . length ) ; output . write short ( ( short ) payload . length ) ; } output . write long ( weight ) ; writer . write ( buffer , num , output . get position ( ) ) ; }	encodes an entry ( bytes + ( contexts ) + ( payload ) + weight ) to the provided writer.
private int skip quoted string ( string str , int pos ) { int n = str . length ( ) ; pos += num ; while ( pos < n ) { if ( str . char at ( pos ) == str ) { if ( pos + num < n && str . char at ( pos + num ) == str ) { pos += num ; continue ; } return pos + num ; } pos += num ; } return n ; }	skips a quoted string , beginning at the index of the opening quote .
private datagram packet [ ] encode multicast request ( final multicast request req ) throws io { final discovery disco = get discovery ( multicast request constraints . choose protocol version ( ) ) ; final list packets = new array list ( ) ; encode iterator ei = disco . encode multicast request ( req , multicast request constraints . get multicast max packet size ( default max packet size ) , multicast request constraints . get unfulfilled constraints ( ) ) ; while ( ei . has next ( ) ) { try { packets . add all ( arrays . as list ( ei . next ( ) ) ) ; } catch ( exception e ) { logger . log ( ( e instanceof unsupported constraint exception ) ? levels . handled : level . info , str , e ) ; } } if ( packets . is empty ( ) ) { throw new discovery protocol exception ( str ) ; } return ( datagram packet [ ] ) packets . to array ( new datagram packet [ packets . size ( ) ] ) ; }	encodes outgoing multicast requests based on protocol in use , applying configured security constraints ( if any ) .
public feature type constraint model ( feature type constraint model update interface parent ) { this . parent obj = parent ; column list . add ( localisation . get string ( field config base . class , str ) ) ; column list . add ( localisation . get string ( field config base . class , str ) ) ; }	instantiates a new feature type constraint model .
protected void delete db ( string name ) { delete db ( get base dir ( ) , name ) ; }	delete all database files for this database .
private void pull event ( ) { final int new scroll value ; final int item dimension ; final float initial motion value , last motion value ; switch ( get filtered pull to refresh scroll direction ( ) ) { case horizontal : initial motion value = m initial motion x ; last motion value = m last motion x ; break ; case vertical : default : initial motion value = m initial motion y ; last motion value = m last motion y ; break ; } switch ( m current mode ) { case pull from end : new scroll value = math . round ( math . max ( initial motion value - last motion value , num ) / m friction ) ; item dimension = get footer size ( ) ; break ; case google style : new scroll value = math . round ( math . min ( initial motion value - last motion value , num ) / m friction ) ; item dimension = get google style view size ( ) ; break ; case pull from start : default : new scroll value = math . round ( math . min ( initial motion value - last motion value , num ) / m friction ) ; item dimension = get header size ( ) ; break ; } set header scroll ( new scroll value ) ; if ( new scroll value != num && ! is refreshing ( ) ) { float scale = math . abs ( new scroll value ) / ( float ) item dimension ; switch ( m current mode ) { case pull from end : m footer layout . on pull ( scale ) ; break ; case google style : m google style view layout . on pull ( scale ) ; m google style progress layout . on pull ( scale ) ; break ; case pull from start : default : m header layout . on pull ( scale ) ; break ; } if ( m state != state . pull to refresh && item dimension >= math . abs ( new scroll value ) ) { set state ( state . pull to refresh ) ; } else if ( m state == state . pull to refresh && item dimension < math . abs ( new scroll value ) ) { set state ( state . release to refresh ) ; } } }	actions a pull event.
public stat monitor handler ( ) { }	constructs a new statmonitorhandler instance.
public void add elements ( final double [ ] values ) { final double [ ] temp array = new double [ num elements + values . length + num ] ; system . arraycopy ( internal array , start index , temp array , num , num elements ) ; system . arraycopy ( values , num , temp array , num elements , values . length ) ; internal array = temp array ; start index = num ; num elements += values . length ; }	adds several element to the end of this expandable array .
@ override public enumeration < option > list options ( ) { vector < option > result = new vector < option > ( ) ; result . add element ( new option ( str + str + str , str , num , str ) ) ; result . add element ( new option ( str , str , num , str ) ) ; result . add element ( new option ( str + str , str , num , str ) ) ; result . add all ( collections . list ( super . list options ( ) ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
public map < uri , list < uri > > add source volume snapshots ( ) { list < uri > block snapshots = lists . new array list ( ) ; map < uri , list < uri > > snapshots map = new hash map < > ( ) ; for ( uri volume id : uris ( volume ids ) ) { list < uri > snapshots = get snapshots ( volume id ) ; block snapshots . add all ( snapshots ) ; snapshots map . put ( volume id , snapshots ) ; } if ( ! block snapshots . is empty ( ) ) { block storage utils . add volumes to consistency group ( consistency group , block snapshots ) ; } return snapshots map ; }	adds all source volumes ' snapshots to the consistency group.
public static void log initiator ( initiator initiator , network lite network ) { string network name = ( network != null ? network . get label ( ) : str ) ; log . info ( string . format ( str , initiator . get initiator port ( ) , initiator . get host name ( ) , network name ) ) ; }	emits an info message about an initiator containing the address , id , and network name .
public static final criterion and ( criterion one , criterion two ) { final list < criterion > criteria = new array list < criterion > ( ) ; criteria . add ( one ) ; criteria . add ( two ) ; return new conjunction criterion ( conjunction . and , criteria ) ; }	creates a filter composing the two different criteria .
public cc ( object rec , string cb ) { target callback = rec ; selector = cb ; set anchor point ( cg . make ( num , num ) ) ; invocation = null ; if ( rec != null && cb != null ) { class < ? > cls = rec . get class ( ) ; try { invocation = cls . get method ( cb , object . class ) ; } catch ( security exception e ) { e . print stack trace ( ) ; } catch ( no such method exception e ) { e . print stack trace ( ) ; } } is enabled = bool ; is selected = bool ; }	initializes a menu item with a target / selector.
public void add child element ( xml child , boolean add after new line ) throws exception { add child element at ( child , - num , add after new line ) ; }	appends the given child element to the end of the list of existing child elements .
public void edit text ( visual item item , string attribute , rectangle r ) { if ( m editing ) { stop editing ( ) ; } string txt = item . get string ( attribute ) ; m edit item = item ; m edit attribute = attribute ; color tc = color lib . get color ( item . get text color ( ) ) ; color fc = color lib . get color ( item . get fill color ( ) ) ; m editor . set foreground ( tc ) ; m editor . set background ( fc ) ; edit text ( txt , r ) ; }	edit text for the given visualitem and field.
public static column column ( final string id , final string title , final int width , final int double precision ) { return new column ( id , title , math . max ( width , title . length ( ) ) , double precision ) ; }	creates a new column with the provided arguments .
public void print count ( string kind , int count ) { if ( count != num ) { string key ; if ( count == num ) key = str + kind ; else key = str + kind + str ; log . print lines ( writer kind . error , key , string . value of ( count ) ) ; log . flush ( log . writer kind . error ) ; } }	print numbers of errors and warnings .
public static float screen to scroll ( float x , float warp size ) { if ( x <= num ) return num ; if ( x >= warp size ) return x + warp size ; return ( float ) math . sqrt ( x * warp size ) * num ; }	unwarps x so it matches the above warp function .
public synchronized void record statistics ( query statistic statistic ) { query statistics . add ( statistic ) ; }	below method will be used to add the statistics.
protected double [ ] random sub range ( double bound start , double bound len ) { if ( bound len >= num && usually ( ) ) { int int bound start = ( int ) math . ceil ( bound start ) ; int int bound end = ( int ) ( bound start + bound len ) ; int int bound len = int bound end - int bound start ; int new len = ( int ) random gaussian mean max ( int bound len / num , int bound len ) ; int new start = int bound start + random int ( int bound len - new len ) ; return new double [ ] { new start , new len } ; } else { double new len = random gaussian mean max ( bound len / num , bound len ) ; double new start = bound start + ( bound len - new len == num ? num : ( random double ( ) % ( bound len - new len ) ) ) ; return new double [ ] { new start , new len } ; } }	returns new minstart and new length that is inside the range specified by the arguments .
private date time zone generate time zone ( string time zone id , date time zone system time zone ) { if ( time zone id == null ) { return system time zone ; } try { return date time zone . for id ( time zone id ) ; } catch ( illegal argument exception ignored ) { log . debug ( invalid time zone . log format ( time zone id ) ) ; throw new bad api request exception ( invalid time zone . format ( time zone id ) ) ; } }	get the timezone for the request .
protected string to string ( string [ ] [ ] strings ) { int rows = strings . length ; int columns = strings . length <= num ? num : strings [ num ] . length ; string buffer total = new string buffer ( ) ; string buffer s = new string buffer ( ) ; for ( int row = num ; row < rows ; row ++ ) { s . set length ( num ) ; for ( int column = num ; column < columns ; column ++ ) { s . append ( strings [ row ] [ column ] ) ; if ( column < columns - num ) s . append ( column separator ) ; } total . append ( s ) ; if ( row < rows - num ) total . append ( row separator ) ; } return total . to string ( ) ; }	returns a single string representation of the given string matrix .
public void check warehouse ( boolean sbf ) { if ( warehouse == null ) { logger . fine ( str ) ; warehouse = new vpf ( ) ; } }	if the warehouse gets set as a result of this method being called , the properties will beed to be reset on it .
public double max dist ( spatial comparable mbr1 , spatial comparable mbr2 ) { final int dim1 = mbr1 . get dimensionality ( ) , dim2 = mbr2 . get dimensionality ( ) ; final int mindim = ( dim1 < dim2 ) ? dim1 : dim2 ; double agg = num ; for ( int d = num ; d < mindim ; d ++ ) { double d1 = mbr1 . get max ( d ) - mbr2 . get min ( d ) ; double d2 = mbr2 . get max ( d ) - mbr1 . get min ( d ) ; double delta = d1 > d2 ? d1 : d2 ; agg += delta * delta ; } for ( int d = mindim ; d < dim1 ; d ++ ) { double d1 = math . abs ( mbr1 . get min ( d ) ) , d2 = math . abs ( mbr1 . get max ( d ) ) ; double delta = d1 > d2 ? d1 : d2 ; agg += delta * delta ; } for ( int d = mindim ; d < dim2 ; d ++ ) { double d1 = math . abs ( mbr2 . get min ( d ) ) , d2 = math . abs ( mbr2 . get max ( d ) ) ; double delta = d1 > d2 ? d1 : d2 ; agg += delta * delta ; } return math . sqrt ( agg ) ; }	maximum distance of two objects .
public static void create lesson ( @ not null final lesson lesson , @ not null final virtual file course dir , @ not null final file resource root , @ not null final project project ) throws io { string lesson dir name = edu names . lesson + integer . to string ( lesson . get index ( ) ) ; virtual file lesson dir = course dir . create child directory ( project , lesson dir name ) ; final list < task > task list = lesson . get task list ( ) ; for ( int i = num ; i <= task list . size ( ) ; i ++ ) { task task = task list . get ( i - num ) ; task . set index ( i ) ; create task ( task , lesson dir , new file ( resource root , lesson dir . get name ( ) ) , project ) ; } }	creates lesson directory in its course folder in project user created.
protected void rehash ( ) { int old capacity = table . length ; cache entry old table [ ] = table ; int new capacity = old capacity * num + num ; cache entry new table [ ] = new cache entry [ new capacity ] ; threshold = ( int ) ( new capacity * load factor ) ; table = new table ; for ( int i = old capacity ; i -- > num ; ) { for ( cache entry old = old table [ i ] ; old != null ; ) { cache entry e = old ; old = old . next ; if ( e . check ( ) != null ) { int index = ( e . hash & num ) % new capacity ; e . next = new table [ index ] ; new table [ index ] = e ; } else count -- ; } } }	rehashes the contents of the table into a bigger table.
public void append ( byte [ ] utf8 , int start , int len ) { set capacity ( length + len , bool ) ; system . arraycopy ( utf8 , start , bytes , length , len ) ; length += len ; }	append a range of bytes to the end of the given text.
private void handle error ( gcp stats data , throwable e ) { log severe ( e ) ; stats data . error = e ; stats data . stage = stats collection stage . error ; handle stats request ( stats data ) ; }	error handler for gcpstatsservice .
public java . lang . string builder insert ( int offset , double d ) { return insert ( offset , double . to string ( d ) ) ; }	inserts the string representation of the double argument into this string buffer.
public static boolean are ms capi stores supported ( ) { return security . get provider ( ms capi . jce ( ) ) != null ; }	are mscapi stores supported ?.
public boolean is passthrough supported ( string mime type ) { return audio capabilities != null && audio capabilities . supports encoding ( get encoding for mime type ( mime type ) ) ; }	returns whether it is possible to play back input audio in the specified format using encoded audio passthrough .
string internalsprintf ( final object s ) { final string s2 ; if ( conversion character == str || conversion character == str ) { s2 = print s ( s . to string ( ) ) ; } else { throw new illegal argument exception ( str + str + conversion character + str ) ; } return s2 ; }	format an object argument using this conversion specification .
public t first item ( ) { if ( m data list == null || m data list . size ( ) == num ) { return null ; } return m data list . get ( num ) ; }	the first item in list.
public void add request property ( string field , string new value ) { check not connected ( ) ; if ( field == null ) { throw new null pointer exception ( str ) ; } }	adds the given property to the request header.
public double do operation ( ) throws operator failed exception { double [ ] mean = sccs . get mode ( ) ; double [ ] current value = parameter . get parameter values ( ) ; double [ ] new value = new double [ dim ] ; set < integer > update set = new hash set < integer > ( ) ; if ( set size mean != - num ) { final int list length = poisson . next poisson ( set size mean ) ; while ( update set . size ( ) < list length ) { int new int = math utils . next int ( parameter . get dimension ( ) ) ; if ( ! update set . contains ( new int ) ) { update set . add ( new int ) ; } } } else { for ( int i = num ; i < dim ; ++ i ) { update set . add ( i ) ; } } double logq = num ; for ( integer i : update set ) { new value [ i ] = mean [ i ] + scale factor * math utils . next gaussian ( ) ; if ( update all ) { parameter . set parameter value quietly ( i , new value [ i ] ) ; } else { parameter . set parameter value ( i , new value [ i ] ) ; } logq += ( normal distribution . log pdf ( current value [ i ] , mean [ i ] , scale factor ) - normal distribution . log pdf ( new value [ i ] , mean [ i ] , scale factor ) ) ; } if ( update all ) { parameter . set parameter value notify changed all ( num , parameter . get parameter value ( num ) ) ; } return logq ; }	change the parameter and return the hastings ratio .
public object load ( uri uri ) throws io { input stream reader src = null ; try { src = new file reader ( new file ( uri ) ) ; return xstream . from xml ( src ) ; } finally { if ( null != src ) { src . close ( ) ; } } }	load an object from the provided uri .
private synchronized void send pending state ( ) { if ( ! m pending clients . is empty ( ) ) { final message [ ] messages = new message [ ] { santa service messages . get begin full state message ( ) , santa service messages . get switch off message ( m preferences . get switch off ( ) ) , get time update message ( ) , santa service messages . get cast disabled message ( m preferences . get cast disabled ( ) ) , santa service messages . get games message ( m preferences . get gumball disabled ( ) , m preferences . get jetpack disabled ( ) , m preferences . get memory disabled ( ) , m preferences . get rocket disabled ( ) , m preferences . get dancer disabled ( ) , m preferences . get snowdown disabled ( ) ) , santa service messages . get destination photo message ( m preferences . get destination photo disabled ( ) ) , santa service messages . get state message ( m state ) , santa service messages . get videos message ( m preferences . get videos ( ) ) } ; for ( int i = num ; i < m pending clients . size ( ) ; i ++ ) { final messenger messenger = m pending clients . get ( i ) ; try { for ( message msg : messages ) { messenger . send ( msg ) ; } m clients . add ( messenger ) ; } catch ( remote exception e ) { } m pending clients . remove ( i ) ; } } }	send the current state of the application to all pending clients .
private void fetch chunk ( bulk id param input , list < t > results ) { list < t > items = get bulk resources ( input ) ; for ( t item : items ) { results . add ( item ) ; } }	fetches a chunk and filters ( if required ) .
public static void move directory to directory ( file src , file dest dir , boolean create dest dir ) throws io { if ( src == null ) { throw new null pointer exception ( str ) ; } if ( dest dir == null ) { throw new null pointer exception ( str ) ; } if ( ! dest dir . exists ( ) && create dest dir ) { dest dir . mkdirs ( ) ; } if ( ! dest dir . exists ( ) ) { throw new file not found exception ( str + dest dir + str + create dest dir + str ) ; } if ( ! dest dir . is directory ( ) ) { throw new io ( str + dest dir + str ) ; } move directory ( src , new file ( dest dir , src . get name ( ) ) ) ; }	moves a directory to another directory .
public static response data parse ( string response data ) { int index = response data . index of ( str ) ; string main data , extra data ; if ( - num == index ) { main data = response data ; extra data = str ; } else { main data = response data . substring ( num , index ) ; extra data = index >= response data . length ( ) ? str : response data . substring ( index + num ) ; } string [ ] fields = text utils . split ( main data , pattern . quote ( str ) ) ; if ( fields . length < num ) { throw new illegal argument exception ( ) ; } response data data = new response data ( ) ; data . extra = extra data ; data . response code = integer . parse int ( fields [ num ] ) ; data . nonce = integer . parse int ( fields [ num ] ) ; data . package name = fields [ num ] ; data . version code = fields [ num ] ; data . user id = fields [ num ] ; data . timestamp = long . parse long ( fields [ num ] ) ; return data ; }	parses response string into responsedata .
public int no of tabs ( ) { return m cur win tab . get tab count ( ) ; }	get the number of tabs in the panels jtabbedpane .
public void test exceptionally exceptional completion action failed ( ) { for ( boolean create incomplete : new boolean [ ] { bool , bool } ) { final atomic integer a = new atomic integer ( num ) ; final cf ex1 = new cf ( ) ; final cf ex2 = new cf ( ) ; final completable future < integer > f = new completable future < > ( ) ; if ( ! create incomplete ) f . complete exceptionally ( ex1 ) ; final completable future < integer > g = f . exceptionally ( null ) ; if ( create incomplete ) f . complete exceptionally ( ex1 ) ; check completed with wrapped exception ( g , ex2 ) ; check completed exceptionally ( f , ex1 ) ; assert equals ( num , a . get ( ) ) ; } }	if an " exceptionally action " throws an exception , it completes exceptionally with that exception.
private static void close ( closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( io e ) { } } }	convenience method to close the closeable object and ignore the exception being thrown if there is one .
public static string convert timestamp to date string compact ( boolean use utc , long milli ) { date date = new date ( milli ) ; simple date format source format = new simple date format ( str ) ; source format . set time zone ( use utc ? time zone . get time zone ( str ) : time zone . get default ( ) ) ; return source format . format ( date ) ; }	convert a timestamp in milliseconds into a human readable string format.
public final double tan half angle ( ) { return math . tan ( num * this . radians ) ; }	obtains the tangent of half of this angle .
abstract future < asynchronous socket channel > impl accept ( object attachment , completion handler < asynchronous socket channel , object > handler ) ;	invoked by accept to accept connection.
public void parse signatures file ( url url ) throws io , parse exception { parse signatures file ( url . open stream ( ) , url . to string ( ) ) ; }	reads a list of api signatures from the given url .
public void add flare ( flare flare ) { flares . add element ( flare ) ; process game event ( new game board change event ( this ) ) ; }	add a new flare.
public static void object string non recursive ( @ unretained object obj , string builder sb ) { if ( obj instanceof object [ ] ) { sb . append ( str ) ; boolean first = bool ; for ( object o : ( object [ ] ) obj ) { if ( ! first ) { sb . append ( str ) ; sb . append ( o ) ; } else { first = bool ; object string with bytes ( o , sb ) ; } } sb . append ( str ) ; } else { object string with bytes ( obj , sb ) ; } }	get proper string for an an object including arrays with upto one dimension of arrays .
public void read osm ( file file ) { if ( file . exists ( ) ) { street layer . open osm ( file ) ; } else { log . info ( str ) ; } }	opens osm mapdb database if it exists otherwise it prints a warning osm mapdb is used for names of streets.
public void start element ( stylesheet handler handler , string uri , string local name , string raw name , attributes attributes ) throws sax { string msg = str ; if ( ! ( handler . get elem template element ( ) instanceof stylesheet ) ) { msg = str ; handler . error ( msg , new sax ( msg ) ) ; } super . start element ( handler , uri , local name , raw name , attributes ) ; string val = attributes . get value ( str ) ; int index of colon = val . index of ( str ) ; if ( index of colon > num ) { } else { msg = str ; handler . error ( msg , new sax ( msg ) ) ; } }	start an elemexsltfunction . verify that it is top level and that it has a name attribute with a namespace .
public void write ( byte [ ] buffer , int offset , int length ) throws io { file . write ( buffer , offset , length ) ; }	writes a block starting from the current file pointer .
public static boolean can interact ( role issuer , role target ) { if ( issuer . get guild ( ) != target . get guild ( ) ) throw new illegal argument exception ( str ) ; return target . get position ( ) < issuer . get position ( ) ; }	checks if one given role can interact with a 2nd given role - in a permission sense ( kick / ban / modify perms ).
public webster ( ) throws bind exception { this . port = integer . get integer ( webster port , num ) ; initialize ( ) ; }	create a new webster.
public boolean will throw exception if key was not found ( ) { return throwex ; }	test whether formatter will throw exception if object for key was not found.
public void test compute location when uberwar packaging ( ) throws exception { deployable deployable element = new deployable ( ) ; deployable element . set group id ( str ) ; deployable element . set artifact id ( str ) ; deployable element . set type ( str ) ; string location = deployable element . compute location ( create default project ( str , null ) ) ; assert true ( location . ends with ( str ) ) ; }	test compute location for uberwars .
public response create response ( string response string ) throws java . text . parse exception { if ( response string == null ) return new sip ( ) ; string msg parser smp = new string msg parser ( ) ; sip sip message = smp . parse sip ( response string . get bytes ( ) , bool , bool , null ) ; if ( ! ( sip message instanceof sip ) ) throw new parse exception ( response string , num ) ; return ( sip ) sip message ; }	create a response from a string.
private ode state ( double t ) { return new ode ( t , new double [ num ] , new double [ num ] ) ; }	create a state at a time .
public static class < ? > find common element type ( collection collection ) { if ( is empty ( collection ) ) { return null ; } class < ? > candidate = null ; for ( object val : collection ) { if ( val != null ) { if ( candidate == null ) { candidate = val . get class ( ) ; } else if ( candidate != val . get class ( ) ) { return null ; } } } return candidate ; }	find the common element type of the given collection , if any .
private static void decode hanzi segment ( bit source bits , string builder result , int count ) throws format exception { if ( count * num > bits . available ( ) ) { throw format exception . get format instance ( ) ; } byte [ ] buffer = new byte [ num * count ] ; int offset = num ; while ( count > num ) { int two bytes = bits . read bits ( num ) ; int assembled two bytes = ( ( two bytes / num ) << num ) | ( two bytes % num ) ; if ( assembled two bytes < num ) { assembled two bytes += num ; } else { assembled two bytes += num ; } buffer [ offset ] = ( byte ) ( ( assembled two bytes > > num ) & num ) ; buffer [ offset + num ] = ( byte ) ( assembled two bytes & num ) ; offset += num ; count -- ; } try { result . append ( new string ( buffer , string utils . g ) ) ; } catch ( unsupported encoding exception uee ) { throw format exception . get format instance ( ) ; } }	see specification gbt 18284 - 2000.
protected void init ping interval milli ( ) { string ping interval milli param = get init parameter ( str ) ; set ping interval milli ( ( ping interval milli param == null ) ? default ping interval milli : integer . parse int ( ping interval milli param ) ) ; if ( is debug ( ) ) { log ( str + get ping interval milli ( ) ) ; } }	initializer for property pingintervalmilli .
public boolean ask ( final string query str , string external query id ) throws exception { final repository connection cxn = cxn ( ) ; uuid query id = null ; try { final boolean query query = ( boolean query ) cxn . prepare boolean query ( query language . sparql , query str ) ; set max query time ( query ) ; if ( query instanceof bigdata sail boolean query && cxn instanceof bigdata sail repository connection ) { final bigdata sail boolean query bdtq = ( bigdata sail boolean query ) query ; query id = setup query ( ( bigdata sail repository connection ) cxn , bdtq . get ast ( ) , query type . ask , external query id ) ; } final boolean result = query . evaluate ( ) ; return result ; } finally { if ( query id != null ) { finalize query ( query id ) ; } } }	select results using a sparql query .
@ suppress warnings ( str ) private static int find ( object [ ] arr , net . sourceforge . retroweaver . harmony . runtime . java . lang . comparable val , int bnd , int l , int r ) { int m = l ; int d = num ; while ( m <= r ) { if ( val . compare to ( arr [ m ] ) > bnd ) { l = m + num ; } else { r = m - num ; break ; } m += d ; d <<= num ; } while ( l <= r ) { m = ( l + r ) > > > num ; if ( val . compare to ( arr [ m ] ) > bnd ) { l = m + num ; } else { r = m - num ; } } return l - num ; }	finds the place in the given range of specified sorted array , where the element should be inserted for getting sorted array.
public static string as hex ( byte [ ] bytes , string separator ) { string builder sb = new string builder ( ) ; for ( int i = num ; i < bytes . length ; i ++ ) { string code = integer . to hex string ( bytes [ i ] & num ) ; if ( ( bytes [ i ] & num ) < num ) { sb . append ( str ) ; } sb . append ( code ) ; if ( separator != null && i < bytes . length - num ) { sb . append ( separator ) ; } } return sb . to string ( ) ; }	returns a hexadecimal representation of the given byte array .
public void run test ( ) throws throwable { document doc ; node list element list ; node name node ; character data child ; string bad string ; doc = ( document ) load ( str , bool ) ; element list = doc . get elements by tag name ( str ) ; name node = element list . item ( num ) ; child = ( character data ) name node . get first child ( ) ; { boolean success = bool ; try { bad string = child . substring data ( num , num ) ; } catch ( dom ex ) { success = ( ex . code == dom . index size err ) ; } assert true ( str , success ) ; } }	runs the test case .
public string to string ( ) { return string . value of ( val ) ; }	returns the string representing the object .
private static void v ( jni env , int class jref , int method id , address arg address ) throws exception { if ( trace jni ) vm . sys write ( str ) ; runtime entrypoints . check jni gc ( ) ; try { jni . invoke with var arg ( method id , arg address , type reference . void ) ; } catch ( throwable unexpected ) { if ( trace jni ) unexpected . print stack trace ( system . err ) ; env . record exception ( unexpected ) ; } }	callstaticvoidmethoda : invoke a static method that returns void.
public static connection create connection ( boolean auto commit , int trx level ) { connection conn = s cc . get connection ( auto commit , trx level ) ; if ( c . is level finest ( ) ) { } try { if ( conn != null && conn . get auto commit ( ) != auto commit ) { throw new illegal state exception ( str + auto commit + str ) ; } } catch ( sql e ) { } return conn ; }	create new connection . the connection must be closed explicitly by the application.
private boolean update statement data ( statement data sdata , matcher matcher , string to regex ) { if ( transform tables ) return bool ; if ( matcher == null ) return bool ; string schema = sdata . get default schema ( ) ; if ( schema == null ) return bool ; matcher . reset ( schema ) ; if ( matcher . matches ( ) ) { string old schema = schema ; sdata . set default schema ( matcher . replace all ( to regex ) ) ; if ( logger . is debug enabled ( ) ) logger . debug ( str + old schema + str + sdata . get default schema ( ) ) ; return bool ; } return bool ; }	updatestatementdata updates the schema name of the given statementdata object if it matches the regular expression.
public void stop if required ( ) { if ( system . current time millis ( ) > stop at ) { throw new illegal state exception ( ) ; } }	check if it ' s time to stop processing.
private void link account ( final string principal id , final id name id ) throws sam , authentication exception { final string sp entity id = meta manager . get entity by meta alias ( meta alias ) ; try { id info = new id ( sp entity id , entity name , name id , sam . sp role , bool ) ; debug . message ( str , principal id , name id . get value ( ) ) ; if ( should persist name id ( sp entity id ) ) { account utils . set account federation ( info , principal id ) ; } principal = new sam ( principal id ) ; } catch ( sam e ) { throw new authentication exception ( bundle name , str , new object [ num ] ) ; } }	links saml2 accounts once all local auth steps have completed and we have a local principalid , sets the local principal to a new saml2pricipal with that id .
private void enable actions ( ) { restore action . set enabled ( frame . is maximum ( ) || frame . is icon ( ) ) ; maximize action . set enabled ( ( frame . is maximizable ( ) && ! frame . is maximum ( ) && ! frame . is icon ( ) ) || ( frame . is maximizable ( ) && frame . is icon ( ) ) ) ; iconify action . set enabled ( frame . is iconifiable ( ) && ! frame . is icon ( ) ) ; close action . set enabled ( frame . is closable ( ) ) ; size action . set enabled ( bool ) ; move action . set enabled ( bool ) ; }	set the enable / disabled state for the buttons .
private list < string > add rules ( int filter id , list < string > rules , boolean use cosmetics ) { input stream input stream = null ; input stream reader input stream reader = null ; buffered reader reader = null ; try { string file name = get or create filter file ( filter id ) ; input stream = context . open file input ( file name ) ; input stream reader = new input stream reader ( input stream ) ; reader = new buffered reader ( input stream reader ) ; string line = reader . read line ( ) ; while ( line != null ) { if ( use cosmetics || ! filter rule . is cosmetic rule ( line ) ) { rules . add ( line ) ; } line = reader . read line ( ) ; } return rules ; } catch ( exception ex ) { log . error ( str , filter id , ex ) ; throw new runtime exception ( str + filter id , ex ) ; } finally { io . close quietly ( input stream ) ; io . close quietly ( input stream reader ) ; io . close quietly ( reader ) ; } }	adds rules from the specified filter to the list.
public static string convert to hex string ( byte [ ] bytes ) { int size = bytes . length ; string buffer buffer = new string buffer ( size * num ) ; for ( int i = num ; i < size ; i ++ ) { int x = bytes [ i ] ; if ( x < num ) x += num ; string tmp = integer . to hex string ( x ) ; if ( tmp . length ( ) == num ) buffer . append ( str ) ; buffer . append ( tmp ) ; } return buffer . to string ( ) ; }	convert byte array to hex string.
public ordered task ( string identifier , step ... steps ) { this ( identifier , arrays . as list ( steps ) ) ; }	returns an initialized ordered task using the specified identifier and array of steps .
public void randomize ( list < cell index > cell indices ) { random rand = new random ( ) ; int range = get upper bound ( ) - get lower bound ( ) ; for ( cell index cell index : cell indices ) { int row = cell index . row ; int col = cell index . col ; double value = ( rand . next double ( ) * range ) + get lower bound ( ) ; set logical value ( row , col , value , bool ) ; } fire table data changed ( ) ; }	randomize neurons within specified bounds .
public void add auditory ( int id ) { m auditory feedback . add ( id ) ; }	adds auditory feedback to this utterance .
public static void constant attributes ( simple method method , element element , string ... attribute names ) throws validation exception { for ( string name : attribute names ) { string attribute value = element . get attribute ( name ) ; if ( ! mini lang util . is constant attribute ( attribute value ) ) { handle error ( str + name + str , method , element ) ; } } }	tests if element attributes are constant type .
private void bind view type ( wx component ) { int id = generate view type ( component ) ; if ( m view types == null ) { m view types = new sparse array < > ( ) ; } array list < wx > m types = m view types . get ( id ) ; if ( m types == null ) { m types = new array list < > ( ) ; m view types . put ( id , m types ) ; } m types . add ( component ) ; }	viewtype will be classified into { hashmap < integer , arraylist < integer > > mviewtypes }.
protected boolean is empty value ( object raw value ) { return raw value == null || string utils . is blank ( string . value of ( raw value ) ) ; }	check if raw value is empty .
public cipher text iv mac ( byte [ ] c , byte [ ] i , byte [ ] h ) { cipher text = new byte [ c . length ] ; system . arraycopy ( c , num , cipher text , num , c . length ) ; iv = new byte [ i . length ] ; system . arraycopy ( i , num , iv , num , i . length ) ; mac = new byte [ h . length ] ; system . arraycopy ( h , num , mac , num , h . length ) ; }	construct a new bundle of ciphertext and iv .
public static master private key create from encrypted seed ( string passphrase , byte [ ] encrypted seed ) throws hyper ledger exception { try { byte [ ] key = s . generate ( passphrase . get bytes ( str ) , bitcoin seed , num , num , num , num ) ; secret key spec keyspec = new secret key spec ( key , str ) ; if ( encrypted seed . length != num ) { throw new hyper ledger exception ( str ) ; } cipher cipher = cipher . get instance ( str , str ) ; cipher . init ( cipher . decrypt mode , keyspec ) ; return create ( cipher . do final ( encrypted seed ) ) ; } catch ( unsupported encoding exception | no such padding exception | no such provider exception | no such algorithm exception | invalid key exception | bad padding exception | illegal block size exception e ) { throw new hyper ledger exception ( e ) ; } }	create a masterprivatekey from a seed , that is assumed to be encrypted.
public static list < json pointer > filter ( final string ... fields ) { final list < json pointer > result = new array list < > ( fields . length ) ; for ( final string field : fields ) { result . add ( new json pointer ( field ) ) ; } return result ; }	creates a list of json pointers from the provided string representations .
public boolean apply ft proxy ( ) { return method . is annotation present ( astrix fault tolerance proxy . class ) ; }	if true , then a fault tolerance proxy should be applies to a library bean .
private void notify change ( int previous , int current ) { m sound player . play ( m sound id , num , num , num , num , num ) ; if ( m on value change listener != null ) { m on value change listener . on value change ( this , previous , m value ) ; } }	notifies the listener , if registered , of a change of the value of this numberpicker .
public int count ( ) { return comments == null ? num : comments . size ( ) ; }	return the number of comments.
private boolean is any package from list installed ( list < string > packages ) { boolean result = bool ; package manager pm = m context . get package manager ( ) ; for ( string package name : packages ) { try { pm . get package info ( package name , num ) ; q . e ( package name + str ) ; result = bool ; } catch ( package manager . name not found exception e ) { continue ; } } return result ; }	check if any package in the list is installed.
public static string make system name ( string type , int bit num ) { string n name = str ; if ( ( ! type . equals ( str ) ) && ( ! type . equals ( str ) ) && ( ! type . equals ( str ) ) ) { log . error ( str + type ) ; return ( n name ) ; } if ( ( bit num < num ) || ( ( type . equals ( str ) ) && ( bit num > num ) ) || ( bit num > num ) ) { log . error ( str + bit num ) ; return ( n name ) ; } n name = str + type + integer . to string ( bit num ) ; return ( n name ) ; }	public static method to construct a system name from type character and bit number < p > this routine returns a system name in the clxxxx , ctxxxx , or csxxxx format.
public static void remove ( ) { auth token . remove ( ) ; }	deletes the user id .
public abstract boolean conflicts ( copy job other ) ;	return true if this job is trying to copy any of the same files as the other job.
public tree node deserialize ( string data ) { deque < string > nodes = new linked list < > ( ) ; nodes . add all ( arrays . as list ( data . split ( spliter ) ) ) ; return build tree ( nodes ) ; }	recursive . same as pre - order traversal . split data and create a queue of string values first . each time , poll a node from the queue , create the current root . then build left and right subtree recursively .
public void fill ( int from index , int to index , short val ) { if ( to index > pos ) { ensure capacity ( to index ) ; pos = to index ; } arrays . fill ( data , from index , to index , val ) ; }	fills a range in the list with the specified value .
private void run pending requests ( ) { int max start id = - num ; billing request request ; while ( ( request = m pending requests . peek ( ) ) != null ) { if ( request . run if connected ( ) ) { m pending requests . remove ( ) ; if ( max start id < request . get start id ( ) ) { max start id = request . get start id ( ) ; } } else { bind to market billing service ( ) ; return ; } } if ( max start id >= num ) { if ( consts . debug ) { log . i ( tag , str + max start id ) ; } stop self ( max start id ) ; } }	runs any pending requests that are waiting for a connection to the service to be established.
public static void remove attribute default values ( string service name , string schema type , string attr name , set default values , boolean is org attr schema ) throws upgrade exception { string class method = str ; service schema ss = null ; if ( debug . message enabled ( ) ) { debug . message ( class method + str + service name ) ; debug . message ( class method + str + schema type ) ; debug . message ( class method + str + attr name ) ; debug . message ( class method + str + default values ) ; debug . message ( class method + str + is org attr schema ) ; } try { if ( is org attr schema ) { service schema manager sm = get service schema manager ( service name ) ; ss = sm . get organization creation schema ( ) ; } else { ss = get service schema ( service name , null , schema type ) ; } if ( ss != null ) { attribute schema attr schema = ss . get attribute schema ( attr name ) ; for ( iterator i = default values . iterator ( ) ; i . has next ( ) ; ) { string default value = ( string ) i . next ( ) ; attr schema . remove default value ( default value ) ; } } } catch ( sms sme ) { debug . error ( class method + str , sme ) ; } catch ( sso ssoe ) { debug . error ( class method + str , ssoe ) ; } }	removes attribute default values from service schema .
public void unlock ( final t tx ) { if ( debug ) log . debug ( str ) ; lock . lock ( ) ; if ( debug ) log . debug ( str ) ; try { assert not dead ( ) ; assert owns lock ( tx ) ; if ( queue . remove ( ) != tx ) { throw new assertion error ( ) ; } if ( waits for != null ) { final iterator < t > itr = queue . iterator ( ) ; synchronized ( waits for ) { while ( itr . has next ( ) ) { final t pending tx = itr . next ( ) ; try { waits for . remove edge ( pending tx , tx ) ; } catch ( throwable t ) { log . warn ( t . get message ( ) , t ) ; } } } } if ( queue . is empty ( ) ) { if ( info ) log . info ( str ) ; return ; } if ( info ) log . info ( str ) ; available . signal all ( ) ; } finally { lock . unlock ( ) ; if ( debug ) log . debug ( str ) ; } }	release the lock held by the tx on the resource .
public boolean is update available ( ) { return available update != null ; }	inform whether an update is available for this component .
@ override public string to string summary ( ) { string result ; string titles ; int resultset length ; int i ; int j ; if ( m == null ) { return str ; } result = str ; titles = str ; resultset length = num + math . max ( ( int ) ( math . log ( get col count ( ) ) / math . log ( num ) ) , ( int ) ( math . log ( get row count ( ) ) / math . log ( num ) ) ) ; for ( i = num ; i < get col count ( ) ; i ++ ) { if ( get col hidden ( i ) ) { continue ; } titles += str + utils . pad left ( str + get summary title ( i ) , resultset length * num + num ) ; } result += titles + str ; for ( i = num ; i < get col count ( ) ; i ++ ) { if ( get col hidden ( i ) ) { continue ; } for ( j = num ; j < get col count ( ) ; j ++ ) { if ( get col hidden ( j ) ) { continue ; } result += str ; if ( j == i ) { result += utils . pad left ( str , resultset length * num + num ) ; } else { result += utils . pad left ( str + m [ i ] [ j ] + str + m [ i ] [ j ] + str , resultset length * num + num ) ; } } result += str + get summary title ( i ) + str + get col name ( i ) + str ; } return result ; }	returns the summary as string .
public int read ( buffered input stream is ) { init ( ) ; if ( is != null ) { in = is ; read header ( ) ; if ( ! err ( ) ) { read contents ( ) ; if ( frame count < num ) { status = status format error ; } } } else { status = status open error ; } try { is . close ( ) ; } catch ( io e ) { } return status ; }	reads gif image from stream.
private static int determine type ( byte [ ] bytes ) { int offset = num ; if ( bytes . length >= num && ( bytes [ num ] & num ) == num && ( bytes [ num ] & num ) == num && ( bytes [ num ] & num ) == num ) { offset += num ; } while ( offset < bytes . length && bytes [ offset ] == str || bytes [ offset ] == str || bytes [ offset ] == str || bytes [ offset ] == str || bytes [ offset ] == str ) { offset ++ ; } return determine type ( new string ( bytes , offset , math . min ( num , bytes . length - offset ) ) ) ; }	determines the type of a property list by means of the first bytes of its data.
public void fix https url ( ) { url . set default ssl ( ssl context . get socket factory ( ) ) ; }	makes httpsurlconnection trusts a set of certificates specified by the keystore.
@ override public data table sample ( int new size ) { int row count = get row number ( ) ; if ( row count <= new size ) { return this ; } int [ ] sampled selected indices = new int [ row count ] ; for ( int i = num ; i < row count ; ++ i ) { sampled selected indices [ i ] = i ; } random rng = new random ( num ) ; int swap idx ; int tmp value ; for ( int i = num ; i < row count ; ++ i ) { swap idx = rng . next int ( row count ) ; tmp value = sampled selected indices [ swap idx ] ; sampled selected indices [ swap idx ] = sampled selected indices [ i ] ; sampled selected indices [ i ] = tmp value ; } data table view sampled data table = new data table view ( this ) ; vector < integer > sampled selected indices vector = new vector < integer > ( new size ) ; for ( int i = num ; i < new size ; ++ i ) { sampled selected indices vector . add ( sampled selected indices [ i ] ) ; } sampled data table . set selected indices ( sampled selected indices vector ) ; return sampled data table ; }	performs a simple sampling without replacement.
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m filter thread . is alive ( ) && m state != idle ) { wait ( ) ; } } catch ( interrupted exception ex ) { } } else { notify all ( ) ; } }	function used to stop code that calls accepttrainingset , accepttestset , or acceptdataset.
public void cancel ( ) { if ( m upload operation == null ) { if ( m upload started . get ( ) ) { oc . d ( tag , str ) ; m cancellation requested . set ( bool ) ; } else { oc . e ( tag , str ) ; } } else { oc . d ( tag , str ) ; m upload operation . cancel ( ) ; } }	allows to cancel the actual upload operation.
public static void merge files ( final file file1 , final file file2 , final file output file ) { if ( ! is readable ( file1 ) || ! is readable ( file2 ) || ! output file . exists ( ) && ! make dirs for file ( output file ) ) { return ; } try { file input stream fis1 = new file input stream ( file1 ) ; file input stream fis2 = new file input stream ( file2 ) ; sequence input stream sis = new sequence input stream ( fis1 , fis2 ) ; file output stream fos = new file output stream ( output file ) ; int count ; byte [ ] temp = new byte [ num ] ; while ( ( count = sis . read ( temp ) ) != - num ) { fos . write ( temp , num , count ) ; } file utils . sync ( fos ) ; fos . close ( ) ; sis . close ( ) ; fis1 . close ( ) ; fis2 . close ( ) ; } catch ( file not found exception e ) { e . print stack trace ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } }	merge two files into a new file.
public static snippet set parse ( final file file ) throws parse exception { return parse ( file input supplier ( file . get parent file ( ) ) , file . get name ( ) ) ; }	parses the input from a file and returns a snippet set .
public static string read file ( class < ? > context , string name ) throws io { try ( input stream in = context . get resource as stream ( name ) ) { if ( in == null ) { return null ; } return new string ( byte streams . to byte array ( in ) , enc ) ; } catch ( io e ) { throw new io ( str + name , e ) ; } }	read a read a utf - 8 text file from our classpath and return it .
long pts to time us ( long pts ) { if ( last pts != long . min value ) { long closest wrap count = ( last pts + ( max pts / num ) ) / max pts ; long pts wrap below = pts + ( max pts * ( closest wrap count - num ) ) ; long pts wrap above = pts + ( max pts * closest wrap count ) ; pts = math . abs ( pts wrap below - last pts ) < math . abs ( pts wrap above - last pts ) ? pts wrap below : pts wrap above ; } long time us = ( pts * c . micros per second ) / num ; if ( last pts == long . min value ) { timestamp offset us = first sample timestamp - time us ; } last pts = pts ; return time us + timestamp offset us ; }	adjusts a pts value to the corresponding time in microseconds , accounting for pts wraparound .
public int remove ( object key ) { entry e = remove entry for key ( key ) ; return ( e == null ? num : e . value ) ; }	removes the mapping for the specified key from this map if present .
public boolean verify challenge token ( inet socket address address , int token ) { return objects . equals ( challenge tokens . get ( address ) , token ) ; }	verify that the request is using the correct challenge token .
protected void draw triangle ( int x , int y , int w , int h , color fill color , paint fill paint , color pen color , boolean shadow , string direction ) { polygon triangle = new polygon ( ) ; if ( direction . equals ( mx constants . direction north ) ) { triangle . add point ( x , y + h ) ; triangle . add point ( x + w / num , y ) ; triangle . add point ( x + w , y + h ) ; } else if ( direction . equals ( mx constants . direction south ) ) { triangle . add point ( x , y ) ; triangle . add point ( x + w / num , y + h ) ; triangle . add point ( x + w , y ) ; } else if ( direction . equals ( mx constants . direction west ) ) { triangle . add point ( x + w , y ) ; triangle . add point ( x , y + h / num ) ; triangle . add point ( x + w , y + h ) ; } else { triangle . add point ( x , y ) ; triangle . add point ( x + w , y + h / num ) ; triangle . add point ( x , y + h ) ; } draw polygon ( triangle , fill color , fill paint , pen color , shadow ) ; }	draws a triangle shape for the given parameters .
private static map < string , string > resource bundle map ( resource bundle bundle ) { final hash map < string , string > map = new hash map < string , string > ( ) ; final enumeration < string > e = bundle . get keys ( ) ; while ( e . has more elements ( ) ) { final string key = e . next element ( ) ; map . put ( key , ( string ) bundle . get object ( key ) ) ; } return collections . unmodifiable map ( map ) ; }	returns an unmodifiable map of the given bundle .
public int compare to ( int buffer other buffer ) { int compare remaining = ( remaining ( ) < other buffer . remaining ( ) ) ? remaining ( ) : other buffer . remaining ( ) ; int this pos = position ; int other pos = other buffer . position ; int this int , other int ; while ( compare remaining > num ) { this int = get ( this pos ) ; other int = other buffer . get ( other pos ) ; if ( this int != other int ) { return this int < other int ? - num : num ; } this pos ++ ; other pos ++ ; compare remaining -- ; } return remaining ( ) - other buffer . remaining ( ) ; }	compares the remaining ints of this buffer to another int buffer ' s remaining ints .
private boolean is black ( final int x , final int y ) { if ( ! in bounds ( x , y ) ) { return bool ; } return ( m buffered image . get rgb ( x , y ) & num ) == num ; }	java . lang . boolean isblack ( java . lang . int , java . lang . int ) checks to see if the x / y coordinates from a given point are inbounds and if so is it black .
public void add job ( runnable job ) { m jobs . add ( job ) ; }	adds a job to be executed after the chart - view is setup ( after onsizechanged (.
@ override public void close ( ) throws io { if ( in != null ) { in . close ( ) ; in = null ; buf = null ; } }	closes this stream . this implementation closes the source stream and releases the pushback buffer .
public static collection < d > reduce points ( final collection < d > points ) { int size = num ; d min x = null ; d max x = null ; d min y = null ; d max y = null ; for ( d p : points ) { if ( min x == null || p . get x ( ) < min x . get x ( ) ) { min x = p ; } if ( max x == null || p . get x ( ) > max x . get x ( ) ) { max x = p ; } if ( min y == null || p . get y ( ) < min y . get y ( ) ) { min y = p ; } if ( max y == null || p . get y ( ) > max y . get y ( ) ) { max y = p ; } size ++ ; } if ( size < num ) { return points ; } final list < d > quadrilateral = build quadrilateral ( min y , max x , max y , min x ) ; if ( quadrilateral . size ( ) < num ) { return points ; } final list < d > reduced points = new array list < d > ( quadrilateral ) ; for ( final d p : points ) { if ( ! inside quadrilateral ( p , quadrilateral ) ) { reduced points . add ( p ) ; } } return reduced points ; }	returns a point set that is reduced by all points for which it is safe to assume that they are not part of the convex hull .
private ignite bi tuple < string , integer > host port ( string conn str , string host port str ) throws ignite checked exception { string [ ] tokens = host port str . split ( str , - num ) ; string host = tokens [ num ] ; if ( f . is empty ( host ) ) host = localhost ; int port ; if ( tokens . length == num ) port = igfs ipc endpoint configuration . dflt port ; else if ( tokens . length == num ) { string port str = tokens [ num ] ; try { port = integer . value of ( port str ) ; if ( port < num || port > num ) throw new ignite checked exception ( str + conn str ) ; } catch ( number format exception e ) { throw new ignite checked exception ( str + conn str ) ; } } else throw new ignite checked exception ( str + conn str ) ; return f . t ( host , port ) ; }	parse host and port .
public boolean is missile going to hit ( entity missile missile ) { if ( missile == null || missile . target vector == null ) { return bool ; } return ( vector2 . distance ( new vector2 ( new d ( missile ) ) , new vector2 ( x coord , z coord ) ) < alarm range && vector2 . distance ( new vector2 ( missile . target vector ) , new vector2 ( x coord , z coord ) ) < safety range ) ; }	checks to see if the missile will hit within the range of the radar station.
public static usericon parse mod icon ( string json ) { try { json parser = new json ( ) ; json o = ( json ) parser . parse ( json ) ; json room = ( json ) o . get ( str ) ; string room id = ( string ) room . get ( str ) ; string mod badge url = ( string ) room . get ( str ) ; if ( mod badge url == null ) { return null ; } return usericon factory . create twitch like icon ( usericon . type . mod , room id , mod badge url , usericon . source ffz , str ) ; } catch ( parse exception | class cast exception | null pointer exception ex ) { } return null ; }	parses the mod icon . request : / room / : room.
public static long length ( url url ) throws io { http http = http . head ( url , null , null , - num , bool , null , constants . name , null , null ) ; return http . get content length ( ) ; }	return the length of a file defined by a url .
@ override public request < list < workspace > > all ( ) { list < workspace > workspaces to return = new array list < > ( ) ; for ( workspace dummy workspace : workspaces . values ( ) ) { workspaces to return . add ( dummy workspace ) ; } return new dummy request < > ( workspaces to return ) ; }	retrieves all codenvy workspaces of the user identified by the authentication token .
public void subscribe ( event subscriber < ? > subscriber ) { final class < ? > event type = get event type ( subscriber ) ; do subscribe ( subscriber , event type ) ; }	subscribe event listener . the event to subscribe to is inferred by checking the generic type arguments of the given subscriber .
public static string reader to string ( final reader file reader ) throws io { final string builder sb = new string builder ( ) ; try ( buffered reader br = new buffered reader ( file reader ) ) { final char [ ] buffer = file utils . make buffer ( ) ; final int eof = - num ; for ( int len = br . read ( buffer ) ; len > eof ; len = br . read ( buffer ) ) { for ( int i = num ; i < len ; i ++ ) { sb . append ( buffer [ i ] ) ; } } } return sb . to string ( ) ; }	read the contents of a reader and turn it into a string .
public static string bytes to hex ( byte [ ] bytes , boolean with spaces ) { string builder sb = new string builder ( ) ; for ( byte hash byte : bytes ) { int int val = num & hash byte ; if ( int val < num ) { sb . append ( str ) ; } sb . append ( integer . to hex string ( int val ) ) ; if ( with spaces ) { sb . append ( str ) ; } } return sb . to string ( ) ; }	takes the provided byte array and converts it into a hexadecimal string with two characters per byte .
private boolean is interleaved ( component sample model sm ) { int num bands = sample model . get num bands ( ) ; if ( num bands == num ) { return bool ; } int [ ] bank indices = sm . get bank indices ( ) ; for ( int i = num ; i < num bands ; i ++ ) { if ( bank indices [ i ] != num ) { return bool ; } } int [ ] band offsets = sm . get band offsets ( ) ; int min offset = band offsets [ num ] ; int max offset = min offset ; for ( int i = num ; i < num bands ; i ++ ) { int offset = band offsets [ i ] ; if ( offset < min offset ) { min offset = offset ; } if ( offset > max offset ) { max offset = offset ; } } if ( max offset - min offset >= sm . get pixel stride ( ) ) { return bool ; } return bool ; }	analyzes a componentsamplemodel to determine if it can function as a pixelinterleavedsamplemodel.
private int decode size ( byte [ ] buffer ) { big integer bi = new big integer ( buffer ) ; int tmp size = bi . int value ( ) ; if ( tmp size < num ) { logger . warning ( str + tmp size + str + integer . to binary string ( tmp size ) + str + integer . to hex string ( tmp size ) ) ; } return tmp size ; }	read frame size , which has to be decoded.
public certificate issuer extension ( boolean critical , object value ) throws io { this . extension id = pkix . certificate issuer id ; this . critical = critical . boolean value ( ) ; this . extension value = ( byte [ ] ) value ; der value val = new der value ( this . extension value ) ; this . names = new general names ( val ) ; }	create a certificateissuerextension from the specified der encoded value of the same .
@ override public void on sensor selection closed ( dialog fragment dialog ) { log . d ( tag , str ) ; sensor selection dialog = null ; }	will be called if the sensor selection dialog has been closed.
public void run test ( ) throws throwable { document doc ; node list element list ; node name node ; character data child ; string child data ; string child value ; doc = ( document ) load ( str , bool ) ; element list = doc . get elements by tag name ( str ) ; name node = element list . item ( num ) ; child = ( character data ) name node . get first child ( ) ; child . set node value ( str ) ; child data = child . get data ( ) ; assert equals ( str , str , child data ) ; child value = child . get node value ( ) ; assert equals ( str , str , child value ) ; }	runs the test case .
public string to xml ( ) { string buffer str = new string buffer ( ) ; str . append ( str ) ; str . append ( xml root element ) ; str . append ( str ) ; str . append ( str ) ; str . append ( xml element quality code ) ; str . append ( str ) ; str . append ( quality code ) ; str . append ( str ) ; str . append ( xml element quality code ) ; str . append ( str ) ; if ( description != null ) { str . append ( str ) ; str . append ( xml element quality desc ) ; str . append ( str ) ; str . append ( description ) ; str . append ( str ) ; str . append ( xml element quality desc ) ; str . append ( str ) ; } str . append ( str ) ; str . append ( xml root element ) ; str . append ( str ) ; return str . to string ( ) ; }	create an xml representation of a sourcedataquality object.
public byte [ ] decrypt ( faces context context , byte [ ] securedata ) { try { byte [ ] mac bytes = new byte [ mac length ] ; system . arraycopy ( securedata , num , mac bytes , num , mac bytes . length ) ; byte [ ] iv = new byte [ iv length ] ; system . arraycopy ( securedata , mac bytes . length , iv , num , iv . length ) ; byte [ ] encdata = new byte [ securedata . length - mac bytes . length - iv . length ] ; system . arraycopy ( securedata , mac bytes . length + iv . length , encdata , num , encdata . length ) ; byte [ ] raw key = convert password to key ( get password to secure state ( context ) ) ; mac mac = get mac ( raw key ) ; mac . update ( iv ) ; mac . update ( encdata ) ; byte [ ] mac bytes calculated = mac . do final ( ) ; if ( arrays . equals ( mac bytes , mac bytes calculated ) ) { cipher cipher = get block cipher for decryption ( raw key , iv ) ; byte [ ] plaindata = cipher . do final ( encdata ) ; return plaindata ; } else { if ( logger . is loggable ( level . warning ) ) { logger . warning ( str ) ; } return null ; } } catch ( exception e ) { if ( logger . is loggable ( level . severe ) ) { logger . log ( level . severe , e . get message ( ) , e . get cause ( ) ) ; } throw new runtime exception ( e ) ; } }	decrypts the specified byte array using the specified password , and generates an inputstream from it.
public static set < string > comma delimited list to set ( string str ) { set < string > set = new tree set < > ( ) ; string [ ] tokens = comma delimited list to string array ( str ) ; set . add all ( arrays . as list ( tokens ) ) ; return set ; }	convenience method to convert a csv string list to a set.
public int hash code ( ) { return objects . hash ( file , princ , bound ) ; }	returns a hashcode for this keytab .
public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add all ( collections . list ( super . list options ( ) ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
protected void tag ( string tag , string name , string value , boolean close ) { spacing ( ) ; m out . print ( str ) ; m out . print ( tag ) ; m out . print ( str ) ; m out . print ( name ) ; m out . print ( str ) ; m out . print ( str ) ; escape string ( value ) ; m out . print ( str ) ; if ( close ) m out . print ( str ) ; m out . print ( str ) ; println ( ) ; if ( ! close ) { m tag stack . add ( tag ) ; } }	internal method for printing a tag with a single attribute .
public static result evaluate model ( multi label classifier h , instances d ) throws exception { return evaluate model prequential basic ( h , d , num , num , str , str ) ; }	evaluatemodel - over 20 windows .
protected boolean is valid state ( mx cell state state ) { return bool ; }	returns true if the given state is a valid state.
public void test find spring sun directory server with limit ( ) { ldap proxy proxy = get ldap sun directory server ( ) ; list result = null ; int limit = num ; try { result = proxy . find ( get ldap search vo ( str , limit , str , str , null , ldap scope constants . scope subtree ) ) ; } catch ( exception e ) { } assert not null ( result ) ; if ( result != null ) { assert equals ( limit , result . size ( ) ) ; } }	test de busqueda sun directory server con limite.
public static boolean delete dir ( file dir ) { if ( dir == null ) { return bool ; } if ( dir . is directory ( ) ) { string [ ] children = dir . list ( ) ; for ( string child : children ) { boolean success = delete dir ( new file ( dir , child ) ) ; if ( ! success ) { return bool ; } } } return dir . delete ( ) ; }	delete a selected directory recursively.
private cim create filter ( cim managed filter info filter info ) throws wbem { string builder filter name builder = new string builder ( ) ; filter name builder . append ( subscriptions identifier ) ; filter name builder . append ( cim constants . path name delimiter ) ; filter name builder . append ( filter info . get name ( ) ) ; string filter name = filter name builder . to string ( ) ; string impl ns = connection . get impl namespace ( ) ; cim < ? > name property = new cim < string > ( cim constants . name key , cim . string t , filter name ) ; cim < ? > src namespace prop = new cim < string > ( cim constants . filter prop src namespace , cim . string t , impl ns ) ; cim < ? > src namespaces prop = new cim < string [ ] > ( cim constants . filter prop src namespaces , cim . string array t , new string [ ] { impl ns } ) ; cim < ? > query lang prop = new cim < string > ( cim constants . filter prop query language , cim . string t , filter info . get query language ( ) ) ; cim < ? > query prop = new cim < string > ( cim constants . filter prop query , cim . string t , filter info . get query ( ) ) ; cim < ? > [ ] filter properties = new cim [ ] { name property , src namespace prop , src namespaces prop , query lang prop , query prop } ; cim filter path = create instance ( cim constants . cim filter name , filter name , filter properties ) ; filter paths . add ( filter path ) ; return filter path ; }	creates an indication filter in the cimom for the given configuration .
public static array list < array list < string > > file tokenizer ( string fin ) { file file = new file ( fin ) ; buffered reader br ; file reader fr ; array list < string > lines = new array list < string > ( ) ; try { fr = new file reader ( file ) ; br = new buffered reader ( fr ) ; string line ; try { while ( ( line = br . read line ( ) ) != null ) { if ( line . length ( ) > num ) { lines . add ( line ) ; } } } catch ( io ex ) { } } catch ( file not found exception ex ) { } array list < array list < string > > tokenized list = new array list < array list < string > > ( ) ; for ( string s : lines ) { array list < string > tokens = new array list < string > ( ) ; string tokenizer st = new string tokenizer ( s , str ) ; while ( st . has more tokens ( ) ) { tokens . add ( st . next token ( ) ) ; } tokenized list . add ( tokens ) ; } return tokenized list ; }	synopsis [ ] outer arraylist = lines inner arraylist = tokens.
public activation group impl ( id id , marshalled object < ? > data ) throws remote exception { super ( id ) ; group id = id ; unexport object ( this , bool ) ; rmi ssf = new server socket factory impl ( ) ; unicast remote object . export object ( this , num , null , ssf ) ; if ( system . get security manager ( ) == null ) { try { system . set security manager ( new security manager ( ) ) ; } catch ( exception e ) { throw new remote exception ( str , e ) ; } } }	creates a default activation group implementation .
public static double vector length ( double [ ] vector ) { double ret = num ; if ( vector == null ) return ret ; else { for ( double a vector : vector ) { ret += math . pow ( a vector , num ) ; } } return ret ; }	returns the vector length ( sqrt ( sum ( x_i ) ).
public static string encode query ( string url ) { uri uri = uri . parse ( url ) ; try { string query = uri . get query ( ) ; string encoded query = query != null ? url . encode ( query , str ) : null ; uri tmp = new uri ( uri . get scheme ( ) , uri . get authority ( ) , uri . get path ( ) , null , uri . get fragment ( ) ) ; return tmp + ( encoded query != null && encoded query . length ( ) > num ? str + encoded query : str ) ; } catch ( unsupported encoding exception ignore ) { } catch ( uri ignore ) { } return uri . to string ( ) ; }	this method encodes the query part of an url.
public void define fill style ( int bitmap id , matrix matrix , boolean clipped ) throws io { fill styles . add ( new fill style ( bitmap id , matrix , clipped ) ) ; outstanding changes = bool ; }	description of the method.
private static long write file ( string path , byte [ ] data ) { file output stream out = null ; try { out = new file output stream ( path ) ; out . write ( data ) ; return data . length ; } catch ( exception e ) { log . e ( tag , str , e ) ; } finally { try { out . close ( ) ; } catch ( exception e ) { log . e ( tag , str , e ) ; } } return - num ; }	writes the data to a file .
public void fire palette event ( component event event ) { if ( local hack list == null ) { return ; } palette = ( container ) event . get source ( ) ; int event type = event . get id ( ) ; for ( component listener listener : local hack list ) { if ( event type == component event . component hidden ) { listener . component hidden ( event ) ; } else if ( event type == component event . component shown ) { listener . component shown ( event ) ; } } if ( event type == component event . component hidden ) { palette = null ; } }	fire a component event to the layer component listeners , with the palette as the component , letting them know if it ' s visible or not .
public void remove entry ( roster entry e ) { log . debug ( str , e ) ; list . remove ( e ) ; e . remove property change listener ( this ) ; set dirty ( bool ) ; fire property change ( remove , e , null ) ; }	remove a rosterentry object from the in - memory roster . this does not delete the file for the rosterentry !.
protected void log diagnostic ( string msg ) { if ( is diagnostics enabled ( ) ) { log raw diagnostic ( diagnostic prefix + msg ) ; } }	output a diagnostic message to a user - specified destination ( if the user has enabled diagnostic logging ) .
public void add url ( final string url ) { while ( current index < history . size ( ) - num ) { history . remove ( current index + num ) ; } history . add ( url ) ; current index = history . size ( ) - num ; }	add a new url to the browsing history.
public static value timestamp convert timestamp ( timestamp x , calendar calendar ) { if ( calendar == null ) { throw db exception . get invalid value exception ( str , null ) ; } calendar cal = ( calendar ) calendar . clone ( ) ; cal . set time in millis ( x . get time ( ) ) ; long date value = date value from calendar ( cal ) ; long nanos = nanos from calendar ( cal ) ; nanos += x . get nanos ( ) % num ; return value timestamp . from date value and nanos ( date value , nanos ) ; }	convert the timestamp using the specified calendar .
private void element ( string segment ) { int index = segment . index of ( str ) ; string prefix = null ; if ( index > num ) { prefix = segment . substring ( num , index ) ; segment = segment . substring ( index + num ) ; } string element = style . get element ( segment ) ; prefixes . add ( prefix ) ; names . add ( element ) ; }	this will insert the path segment provided.
private void cleanup handler ( content handler vh ) throws sax { for ( prefix mapping pm = prefix mapping ; pm != null ; pm = pm . parent ) vh . end prefix mapping ( pm . prefix ) ; vh . end document ( ) ; }	cleanup a handler . remove proxy namespace mappings calling endprefixmapping and calls also enddocument to signal that the source was ended .
public input stream open classfile ( string classname ) { try { url con = open classfile0 ( classname ) ; if ( con != null ) return con . get input stream ( ) ; } catch ( io e ) { } return null ; }	opens a class file with http .
public void remove ignored view ( view v ) { m ignored views . remove ( v ) ; }	removes the ignored view .
private double fitness ( solution solution , double [ ] weights ) { double max = double . negative infinity ; for ( int i = num ; i < solution . get number of objectives ( ) ; i ++ ) { max = math . max ( max , math . max ( weights [ i ] , num ) * math . abs ( solution . get objective ( i ) - ideal point [ i ] ) ) ; } if ( solution . violates constraints ( ) ) { max += num ; } return max ; }	evaluates the fitness of the specified solution using the chebyshev weights .
private boolean select item by name ( c combo , string name , string [ ] c string ) { for ( int i = num ; i < c string . length ; i ++ ) { string prop name = c string [ i ] ; if ( name . equals ignore case ( prop name ) ) { combo . select ( i ) ; return bool ; } } return bool ; }	pre - select property if it has the same name as a csv table column.
public void add file ( string path ) throws io { file new file = new file ( path ) ; if ( ! new file . exists ( ) ) { throw new io ( str + new file . get absolute path ( ) ) ; } if ( delphi utils . accept file ( new file . get absolute path ( ) ) ) { files . add ( new file ) ; } }	adds a source file to project.
public void remove limit line ( limit line l ) { m limit lines . remove ( l ) ; }	removes the specified limitline from the axis .
public boolean is content ( ) { return state . equals ( content ) ; }	check if content is shown.
protected boolean columns differ ( column current column , column desired column ) { string desired default = desired column . get default value ( ) ; string current default = current column . get default value ( ) ; boolean defaults equal = ( desired default == null ) || desired default . equals ( current default ) ; boolean size matters = database info . has size ( current column . get mapped type code ( ) ) && ( desired column . get size ( ) != null ) ; if ( ( database info . get target jdbc type ( desired column . get mapped type code ( ) ) != current column . get mapped type code ( ) ) || ( desired column . is required ( ) != current column . is required ( ) ) || ( size matters && ! string utils . equals ( desired column . get size ( ) , current column . get size ( ) ) ) || ! defaults equal ) { return bool ; } else { return bool ; } }	compares the current column in the database with the desired one.
public static int read uin ( input stream stream ) throws io { int result = stream . read ( ) ; result |= stream . read ( ) << num ; return result ; }	reads 2 bytes from stream and interprets them as uint16 . < br >.
private void prepare metadata connection ( ) throws sql , replicator exception { if ( metadata connection == null ) metadata connection = data source impl . get connection ( ) ; long current time = system . current time millis ( ) ; if ( last connection time == num ) { last connection time = current time ; } else if ( reconnect timeout in seconds > num && current time - last connection time > reconnect timeout in seconds * num ) { data source impl . release connection ( metadata connection ) ; metadata connection = data source impl . get connection ( ) ; } }	prepare the metadata connection for use : connect or reconnect if needed .
public static string identify line delimiter ( string file content ) { if ( file content . matches ( str ) ) { return str ; } else if ( file content . matches ( str ) ) { return str ; } else if ( file content . matches ( str ) ) { return str ; } else { return str ; } }	identify which line delimiter is used in a file.
public void add item ( force item item ) { items . add ( item ) ; }	add a forceitem to the simulation .
public void test constructor2 ( ) { executor e = executors . new fixed thread pool ( num ) ; submission publisher < integer > p = new submission publisher < integer > ( e , num ) ; check initial state ( p ) ; assert same ( p . get executor ( ) , e ) ; assert equals ( num , p . get max buffer capacity ( ) ) ; }	a new submissionpublisher has no subscribers , is not closed , has the given buffer size , and uses the given executor.
protected void parse container and screen ( xml resource parser parser , long [ ] out ) { if ( hotseat container name . equals ( get attribute value ( parser , attr container ) ) ) { out [ num ] = launcher settings . favorites . container hotseat ; long rank = long . parse long ( get attribute value ( parser , attr rank ) ) ; out [ num ] = ( rank < m hotseat all apps rank ) ? rank : ( rank + num ) ; } else { out [ num ] = launcher settings . favorites . container desktop ; out [ num ] = long . parse long ( get attribute value ( parser , attr screen ) ) ; } }	parses container and screenid attribute from the current tag , and puts it in the out .
public default tree colouring sample tree colouring ( tree tree , colour change matrix colour change matrix , meta population mp ) { default tree colouring colouring = new default tree colouring ( num , tree ) ; double [ ] n = mp . get population sizes ( num ) ; double [ ] root partials = prune ( tree , tree . get root ( ) , colour change matrix , n ) ; double normalization = num ; for ( int i = num ; i < root partials . length ; i ++ ) { normalization += colour change matrix . get equilibrium ( i ) * root partials [ i ] ; } sample internal nodes ( tree , tree . get root ( ) , colour change matrix ) ; sample branch colourings ( colouring , tree , tree . get root ( ) , colour change matrix ) ; double log p = calculate log probability density ( colouring , tree , tree . get root ( ) , colour change matrix , n ) - math . log ( normalization ) ; colouring . set log probability density ( log p ) ; return colouring ; }	colours the tree probabilistically with the given migration rates.
public stored list iterator < t > establish list scan ( boolean random scan ) { if ( is empty ( ) ) return null ; stored list iterator < t > slh = sl . get ( ) ; stored list iterator < t > res = establish pos ( random scan , slh ) ; if ( res == null ) slh . release ( ) ; return res ; }	establish a scan position . if random scanning supported we select a random position.
public static string decode ( final string str , final string charset name ) throws unsupported encoding exception { return decode ( new string ( str . get bytes ( charset name ) , str ) ) ; }	transliterate an unicode object into an ascii string .
public server commit acquire ( operation entry entry , server session context session , long timestamp ) { server commit commit = pool . poll ( ) ; if ( commit == null ) { commit = new server commit ( this , log ) ; } commit . reset ( entry , session , timestamp ) ; return commit ; }	acquires a commit from the pool .
public static synchronized double make noise ( double mean , double standard diviation ) { return random . next gaussian ( ) * math . sqrt ( standard diviation ) + mean ; }	create a gaussian noise around supplied mean value based on supplied standarddiviation.
void shutdown ( ) { try { ssl engine . close inbound ( ) ; } catch ( ssl e ) { if ( log . is debug enabled ( ) ) log . debug ( str + e . get message ( ) + str + ses + str ) ; } }	shuts down the handler .
@ override public synchronized void remove instance listener ( instance listener tsl ) { m instance listeners . remove ( tsl ) ; }	remove an instance listener.
public map < string , map < string , flt > > retrieve terms ( int doc num ) throws io { return retrieve terms ( doc num , null ) ; }	find words for a more - queryfromdocuments - this query former .
boolean alias ( string src , string target ) { if ( src == null ) return bool ; plugin holder < t > a = registry . get ( src ) ; if ( a == null ) return bool ; plugin holder < t > b = registry . get ( target ) ; if ( b != null ) return bool ; registry . put ( target , a ) ; return bool ; }	make a plugin available in an alternate name . this is an internal api and not for public use.
public static < t extends char sequence > t each match ( t self , pattern pattern , @ closure params ( value = from string . class , options = { str , str } ) closure closure ) { each match ( self . to string ( ) , pattern , closure ) ; return self ; }	process each regex group matched substring of the given pattern.
public void switch single row ( ) { if ( m only multi row ) return ; card layout . first ( card panel ) ; m single row = bool ; dynamic display ( num ) ; }	switch to singlerow presentation.
private boolean is string continuation ( int offset ) { int next non ws = f scanner . find non whitespace backward in any partition ( offset - num , java heuristic scanner . unbound ) ; try { if ( next non ws != java heuristic scanner . not found && f document . get char ( next non ws ) == str ) return bool ; else return bool ; } catch ( bad location exception e ) { log . error ( java indenter . class , e ) ; return bool ; } }	tells whether the given string is a continuation expression .
final void push ( final object object ) { stack . add ( object ) ; }	push a new object onto the top of the object stack .
public void make immutable ( ) { mutable = bool ; }	makes the object immutable .
public static < k , v > v atomic get or create ( concurrent map < k , v > map , k key , callable < v > ctor ) { v value = map . get ( key ) ; if ( value == null ) { try { value = ctor . call ( ) ; } catch ( exception e ) { throw new runtime exception ( str , e ) ; } v existing = map . put if absent ( key , value ) ; if ( existing != null ) { return existing ; } } return value ; }	atomically returns a map element for the specifying key.
private void create metric chart panel ( int metric , dataset generator dataset generator , list < gc > list ) { ttg dataset = dataset generator . new category dataset with ttg ( metric , bool ) ; gc panel = new metric chart panel ( chart prefix + dataset generator . get metric name ( metric ) , dataset generator . get unit name ( metric ) , dataset , locker ) ; list . add ( panel ) ; }	it adds a new metric chart panel to the tabbed pane set .
public void test constr string with exponent without point2 ( ) { string a = str ; int a scale = num ; big integer b a = new big integer ( str ) ; big decimal a number = new big decimal ( a ) ; assert equals ( str , b a , a number . unscaled value ( ) ) ; assert equals ( str , a scale , a number . scale ( ) ) ; }	new bigdecimal ( string value ) ; value contains exponent and does not contain decimal point.
public default client web request builder cookie ( string name , string value ) { return cookie ( new http cookie ( name , value ) ) ; }	add a cookie to the http request.
private void add new tilesets ( map map ) throws io { for ( tile set set : map . get tile sets ( ) ) { set by name . put ( set . get tilebmp file ( ) , set ) ; } for ( string name : mapping . get new sets ( ) ) { if ( name . equals ( str ) ) { continue ; } if ( ! set by name . contains key ( name ) ) { tile set set = new tile set ( ) ; set . set name ( construct tileset name ( name ) ) ; basic tile cutter cutter = new basic tile cutter ( num , num , num , num ) ; set . import tile bitmap ( name , cutter ) ; set by name . put ( name , set ) ; map . add tileset ( set ) ; } } }	add all the tilesets that the translation mapping uses to a map .
public static list < css meta data < ? extends styleable , ? > > create css meta data list ( list < css meta data < ? extends styleable , ? > > base list , css meta data < ? extends styleable , ? > ... meta data ) { list < css meta data < ? extends styleable , ? > > styleables = new array list < > ( base list ) ; styleables . add all ( arrays . as list ( meta data ) ) ; return collections . unmodifiable list ( styleables ) ; }	creates a list of cssmetadata instances that is merged by the given parameters.
public void add extension ( as oid , boolean critical , byte [ ] value ) { if ( extensions . contains key ( oid ) ) { throw new illegal argument exception ( str + oid + str ) ; } ext ordering . add element ( oid ) ; extensions . put ( oid , new extension ( oid , critical , new der ( value ) ) ) ; }	add an extension with the given oid and the passed in byte array to be wrapped in the octet string associated with the extension .
public void update client cookies ( boolean client cookies ) throws security exception { check write access ( ) ; boolean has access = config web util . has access ( config , security manager . type setting ) ; if ( ! has access ) throw new security exception ( str ) ; element scope = get root element ( str ) ; scope . set attribute ( str , caster . to string ( client cookies , str ) ) ; }	set if client cookies are enabled or not.
public double [ ] subseries by copy ( double [ ] series , int start , int end ) throws index out of bounds exception { if ( ( start > end ) || ( start < num ) || ( end > series . length ) ) { throw new index out of bounds exception ( str + series . length + str + start + str + string . value of ( end - start ) ) ; } return arrays . copy of range ( series , start , end ) ; }	extract subseries out of series .
public static string create temp file ( final string ... lines ) throws exception { final file f = file . create temp file ( str , str ) ; f . delete on exit ( ) ; try ( final file writer w = new file writer ( f ) ) { for ( final string s : lines ) { w . write ( s + system . get property ( str ) ) ; } } return f . get absolute path ( ) ; }	creates a temporary text file with the specified contents.
public static void read skel ( buffered reader reader ) throws io { vector lines = new vector ( ) ; string buffer section = new string buffer ( ) ; string ln ; while ( ( ln = reader . read line ( ) ) != null ) { if ( ln . starts with ( str ) ) { lines . add element ( section . to string ( ) ) ; section . set length ( num ) ; } else { section . append ( ln ) ; section . append ( nl ) ; } } if ( section . length ( ) > num ) lines . add element ( section . to string ( ) ) ; if ( lines . size ( ) != size ) { out . error ( error messages . wrong skeleton ) ; throw new generator exception ( ) ; } line = new string [ size ] ; for ( int i = num ; i < size ; i ++ ) line [ i ] = ( string ) lines . element at ( i ) ; }	reads an external skeleton file from a bufferedreader .
@ override public long read double ( string file path , long offset ) { file channel file channel = update cache ( file path ) ; byte buffer byte bffer = read ( file channel , carbon common constants . long size in byte , offset ) ; return byte bffer . get long ( ) ; }	this method will be used to read int from file from postion ( offset ) , here length will be always 4 bacause int byte size if 4.
public lua compiler ( compiler settings settings ) { this . settings = objects . require non null ( settings ) ; }	constructs a new compiler instance with the given settings .
public static void show address on map ( context m context , string address ) { address = address . replace ( str , str ) ; intent geo intent = new intent ( intent . action view , uri . parse ( str + address ) ) ; m context . start activity ( geo intent ) ; }	use to show address location pin on map .
public void test copy map ( ) { serializer serializer = new serializer ( ) ; map < string , string > map = new hash map < > ( ) ; map . put ( str , str ) ; map . put ( str , str ) ; map < string , string > result = serializer . copy ( map ) ; assert equals ( map , result ) ; assert equals ( map . get ( str ) , str ) ; assert equals ( map . get ( str ) , str ) ; }	tests copying a map .
private void find bounced instrument ( ) { for ( final receipt instrument info instrument info : instrument details ) if ( instrument info . is bounced ( ) ) bounced instruments . add ( instrument info ) ; }	finds all instruments of this receipt that are in bounced ( dishonored ) status and adds them to the set of bounced instruments .
public static set < string > convert array to set ( string [ ] array ) { set < string > result set = new hash set < string > ( array . length ) ; collections . add all ( result set , array ) ; return result set ; }	transforms array of string objects to set.
public parse file ( byte [ ] data ) { this ( null , data , null ) ; }	creates a new file from a byte array .
private storage policy entity create storage policy entity ( namespace entity namespace entity , string storage policy name , storage entity storage entity , storage entity destination storage entity , storage policy rule type entity storage policy rule type entity , integer storage policy rule value , business object definition entity business object definition entity , string business object format usage , file type entity file type entity , storage policy status entity storage policy status entity , integer storage policy version , boolean storage policy latest version ) { storage policy entity storage policy entity = new storage policy entity ( ) ; storage policy entity . set namespace ( namespace entity ) ; storage policy entity . set name ( storage policy name ) ; storage policy entity . set storage ( storage entity ) ; storage policy entity . set destination storage ( destination storage entity ) ; storage policy entity . set storage policy rule type ( storage policy rule type entity ) ; storage policy entity . set storage policy rule value ( storage policy rule value ) ; storage policy entity . set business object definition ( business object definition entity ) ; if ( string utils . is not blank ( business object format usage ) ) { storage policy entity . set usage ( business object format usage ) ; } storage policy entity . set file type ( file type entity ) ; storage policy entity . set status ( storage policy status entity ) ; storage policy entity . set version ( storage policy version ) ; storage policy entity . set latest version ( storage policy latest version ) ; return storage policy dao . save and refresh ( storage policy entity ) ; }	creates and persists a new storage policy entity .
public void draw std dev line ( d g2d , long std dev val , long y max mark , color color ) { float std dev perc = std dev val / ( float ) y max mark ; g2d . set color ( color ) ; int y pos of line = this . graph bottom - math . round ( this . graph height * std dev perc ) ; g2d . draw line ( this . graph left , y pos of line , this . graph right , y pos of line ) ; }	used to draw the low and high standard devition lines on the line graph.
public sample vcpc ( independence test independence test ) { if ( independence test == null ) { throw new null pointer exception ( ) ; } if ( ! ( independence test instanceof z ) ) { throw new illegal argument exception ( str ) ; } this . independence test = independence test ; this . data set = ( data set ) independence test . get data ( ) ; this . variables = data set . get variables ( ) ; this . cov matrix = new covariance matrix ( data set ) ; list < node > nodes = cov matrix . get variables ( ) ; this . index map = index map ( variables ) ; this . name map = map names ( variables ) ; this . nodes to variables = new hash map < > ( ) ; this . variables to nodes = new hash map < > ( ) ; }	constructs a cpc algorithm that uses the given independence test as oracle . this does not make a copy of the independence test , for fear of duplicating the data set !.
private int next available idx ( collection < integer > started grids , int max top size , random rnd ) { while ( bool ) { int idx = rnd . next int ( max top size ) ; if ( ! started grids . contains ( idx ) ) return idx ; } }	gets next available index .
public boolean has color ( ) { return type string . contains ( color ) ; }	determine if the expression specifies a color .
public clearance matrix ( int p class count , brd layer structure p layer structure , string [ ] p name arr ) { class count = math . max ( p class count , num ) ; layer structure = p layer structure ; clearance rows = new clearance matrix row [ class count ] ; for ( int index = num ; index < class count ; ++ index ) { clearance rows [ index ] = new clearance matrix row ( this , p name arr [ index ] ) ; } max value on layer = new int [ layer structure . size ( ) ] ; }	creates a new instance for p_class_count clearance classes on p_layer_count layers . p_names is an array of dimension p_class_count ;.
public static char [ ] concat ( char [ ] base , char [ ] other , int append count ) { final int length = base . length ; char [ ] new array = copy from ( base , base . length + append count ) ; system . arraycopy ( other , num , new array , length , append count ) ; return new array ; }	appends appendcount number of elements of given array other to given array base.
public array real vector ( array real vector v1 , array real vector v2 ) { data = new double [ v1 . data . length + v2 . data . length ] ; system . arraycopy ( v1 . data , num , data , num , v1 . data . length ) ; system . arraycopy ( v2 . data , num , data , v1 . data . length , v2 . data . length ) ; }	construct a vector by appending one vector to another vector .
void add class list ( string class list filename ) { if ( class list filename . length ( ) > num ) { set option ( str , class list filename ) ; load class names ( class list filename ) ; } else { throw new illegal argument exception ( str ) ; } }	adds a class list filename to this set of options .
private start build ( start event ) { named node map list = event . get attributes ( ) ; int length = list . get length ( ) ; for ( int i = num ; i < length ; i ++ ) { node node = list . item ( i ) ; attribute value = attribute ( node ) ; if ( ! value . is reserved ( ) ) { event . add ( value ) ; } } return event ; }	this is used to build the attributes that are to be used to populate the start event.
public bytes to name canonicalizer make child ( boolean canonicalize , boolean intern ) { return new bytes to name canonicalizer ( this , intern , hash seed , table info . get ( ) ) ; }	factory method used to create actual symbol table instance to use for parsing .
public instances retrieve instances ( ) throws exception { return retrieve instances ( m ) ; }	makes a database query using the query set through the - q option to convert a table into a set of instances.
void extract ( input stream in , string files [ ] ) throws io { zip input stream zis = new zip input stream ( in ) ; zip entry e ; set < zip entry > dirs = new dir set ( ) ; while ( ( e = zis . get next entry ( ) ) != null ) { if ( files == null ) { dirs . add ( extract file ( zis , e ) ) ; } else { string name = e . get name ( ) ; for ( string file : files ) { if ( name . starts with ( file ) ) { dirs . add ( extract file ( zis , e ) ) ; break ; } } } } update last modified time ( dirs ) ; }	extracts specified entries from jar file .
public void test get accent colors by name ( ) { try { for ( string name : material palettes . colors with accent names ) { list < integer > color list = material palettes . get accent colors by name ( name ) ; assert equals ( material palettes . accent color levels . length , color list . size ( ) ) ; } } catch ( illegal access exception iae ) { fail ( ) ; } }	tests that retrieving the accent colors gets the right count .
private static void draw chunk ( image image , graphics g , boolean stretch , int dx1 , int dy1 , int dx2 , int dy2 , int sx1 , int sy1 , int sx2 , int sy2 , boolean x direction ) { if ( dx2 - dx1 <= num || dy2 - dy1 <= num || sx2 - sx1 <= num || sy2 - sy1 <= num ) { return ; } if ( stretch ) { g . draw image ( image , dx1 , dy1 , dx2 , dy2 , sx1 , sy1 , sx2 , sy2 , null ) ; } else { int x size = sx2 - sx1 ; int y size = sy2 - sy1 ; int delta x ; int delta y ; if ( x direction ) { delta x = x size ; delta y = num ; } else { delta x = num ; delta y = y size ; } while ( dx1 < dx2 && dy1 < dy2 ) { int new d = math . min ( dx2 , dx1 + x size ) ; int new d = math . min ( dy2 , dy1 + y size ) ; g . draw image ( image , dx1 , dy1 , new d , new d , sx1 , sy1 , sx1 + new d - dx1 , sy1 + new d - dy1 , null ) ; dx1 += delta x ; dy1 += delta y ; } } }	draws a portion of an image , stretched or tiled .
private static void decode edifact segment ( bit source bits , string builder result ) { do { if ( bits . available ( ) <= num ) { return ; } for ( int i = num ; i < num ; i ++ ) { int edifact value = bits . read bits ( num ) ; if ( edifact value == num ) { int bits left = num - bits . get bit offset ( ) ; if ( bits left != num ) { bits . read bits ( bits left ) ; } return ; } if ( ( edifact value & num ) == num ) { edifact value |= num ; } result . append ( ( char ) edifact value ) ; } } while ( bits . available ( ) > num ) ; }	see iso 16022 : 2006 , 5.
public void write ( byte [ ] b , int offset , int length ) throws io { out . write ( b , offset , length ) ; }	writes the array of bytes to the output stream and increments the number of bytes written by the size of the array .
public sample set ( data input stream is ) throws io { int num samples ; sample info = new sample info ( is ) ; num samples = is . read int ( ) ; this . samples = new sample [ num samples ] ; for ( int i = num ; i < num samples ; i ++ ) { samples [ i ] = sample . load binary ( is ) ; } }	creates a sampleset by reading it from the given input stream.
public void close ( ) { running = bool ; synchronized ( hist data ) { hist data . notify ( ) ; } }	terminate the thread that autoscrolls the text .
public sq ( string path , @ sq . open flags int open flags ) { if ( path == null ) { throw new illegal argument exception ( str ) ; } this . path = path ; label = strip path for logs ( path ) ; this . open flags = open flags ; max sql cache size = num ; locale = locale . get default ( ) ; }	creates a database configuration with the required parameters for opening a database and default values for all other parameters .
private void print properties ( properties properties ) throws io { string writer string buffer = new string writer ( ) ; buffered reader reader = null ; properties . store ( string buffer , null ) ; try { reader = new buffered reader ( new string reader ( string buffer . to string ( ) ) ) ; reader . read line ( ) ; string line = null ; while ( ( line = reader . read line ( ) ) != null ) { writer . print ( str ) ; writer . println ( line ) ; } } finally { if ( reader != null ) { reader . close ( ) ; } } }	prints the properties to the result file.
public static < t > range < t > value of ( string s , class < t > clazz ) { char lbm = s . char at ( num ) ; if ( lbm != str && lbm != str ) throw new illegal argument exception ( s ) ; char ubm = s . char at ( s . length ( ) - num ) ; if ( ubm != str && ubm != str ) throw new illegal argument exception ( s ) ; bound type lbt = lbm == str ? bound type . closed : bound type . open ; bound type ubt = ubm == str ? bound type . closed : bound type . open ; s = s . substring ( num , s . length ( ) - num ) ; string [ ] parts = s . split ( str ) ; string lbs = parts [ num ] ; string ubs = parts [ num ] ; t lower bound = lbs . equals ( str ) ? null : bound value ( lbs , clazz ) ; t upper bound = ubs . equals ( str ) ? null : bound value ( ubs , clazz ) ; return range ( lower bound , lbt , upper bound , ubt ) ; }	create a range from a string produced by tostring ( ).
public static double vector dchisq ( double x , double vector ncp ) { int n = ncp . size ( ) ; double vector d = new double vector ( n ) ; double xh = math . sqrt ( x ) ; double mean ; for ( int i = num ; i < n ; i ++ ) { mean = math . sqrt ( ncp . get ( i ) ) ; if ( ncp . get ( i ) == num ) d . set ( i , dchisq ( x ) ) ; else d . set ( i , ( dnorm ( xh - mean ) + dnorm ( - xh - mean ) ) / ( num * xh ) ) ; } return d ; }	returns the density of the noncentral chi - squared distribution .
@ override public void add property change listener ( property change listener listener ) { property change support . add property change listener ( listener ) ; }	add a propertychangelistener to the listener list .
public void remove all baud rate query callbacks ( ) { baud rate query callbacks . clear ( ) ; }	removes all baud rate query callbacks .
public void add ( abstract option option ) { add ( options . size ( ) , option ) ; }	adds an abstractoption to the container.
private void load vertices and relatives ( ) { list < a > element list = new linked list < a > ( ) ; for ( i loader : get loader list ( ) ) { loader . set cna tree element dao ( get cna tree element dao ( ) ) ; element list . add all ( loader . load elements ( ) ) ; } for ( a element : element list ) { graph . add vertex ( element ) ; if ( log . is debug enabled ( ) ) { log . debug ( str + element . get title ( ) ) ; } uuid map . put ( element . get uuid ( ) , element ) ; } for ( a parent : element list ) { set < a > children = parent . get children ( ) ; for ( a child : children ) { create parent child edge ( parent , child ) ; } } }	loads all vertices and adds them to the graph.
private boolean has non special attribute ( collection < string > keys ) { for ( string attr : keys ) { if ( ! attr . starts with ( str ) ) { return bool ; } } return bool ; }	primitive implementation to decide if the object is a " full " or a partial .
public static final void shuffle ( double [ ] a , int start , int len , random r ) { for ( int i = start + len ; i > num ; -- i ) { double t = a [ i ] ; int j = r . next int ( i ) ; a [ i ] = a [ j ] ; a [ j ] = t ; } }	randomly permute the contents of a range an array .
public boolean is parity correct ( byte [ ] [ ] shards , int first byte , int byte count , byte [ ] temp buffer ) { check buffers and sizes ( shards , first byte , byte count ) ; if ( temp buffer . length < first byte + byte count ) { throw new illegal argument exception ( str ) ; } byte [ ] [ ] to check = new byte [ parity shard count ] [ ] ; system . arraycopy ( shards , data shard count , to check , num , parity shard count ) ; return coding loop . check some shards ( parity rows , shards , data shard count , to check , parity shard count , first byte , byte count , temp buffer ) ; }	returns true if the parity shards contain the right data.
public static void write stream ( input stream in , file file ) throws io { file output stream out = new file output stream ( file ) ; try { transfer ( in , out ) ; } finally { try { out . flush ( ) ; } finally { out . close ( ) ; } } }	writes all data that can be read from the supplied inputstream to the specified file .
private static native long create entity parser ( long parent pointer , string context ) ;	creates a native entity parser .
public void fire property change ( string property name , byte old value , byte new value ) { if ( change support == null || old value == new value ) { return ; } fire property change ( property name , byte . value of ( old value ) , byte . value of ( new value ) ) ; }	reports a bound property change .
private int adjust offset for unit tests ( int offset ) { if ( system . get property ( str ) == null ) return offset ; else return num ; }	when running unit tests , we want byte offsets into the file to always be displayed as zero , so that the unit test expected results will match up with the actual results.
public static boolean is aix ( ) { return os name . index of ( str ) > - num ; }	is operating system aix ?.
private double test fit ( double [ ] x , double [ ] test , distribution dist ) throws arithmetic exception { for ( int i = num ; i < test . length ; i ++ ) { test [ i ] = dist . cdf ( x [ i ] ) ; if ( test [ i ] > num ) { test [ i ] = num ; } if ( test [ i ] < num ) { test [ i ] = num ; } if ( double . is na n ( test [ i ] ) ) { throw new arithmetic exception ( str + dist . to string ( ) ) ; } } arrays . sort ( test ) ; return kolmogorov smirnov test . simple test ( test ) ; }	test the quality of a fit .
public boolean supports sql ( ) { return bool ; }	returns true if the omgraphichandler can handle sql statements for filtering .
private static boolean is valid ip ( final string ip address ) { boolean status = bool ; if ( string utils . is not empty ( ip address ) ) { status = inet address utils . is i ( ip address ) ; } return status ; }	validates ipv4 address using regex for the given ipaddress.
public static pta v ( ) { return v ; }	return the static singleton for the pta.
public void register cache update period change listener ( final property change listener listener ) { cache update period listeners . add ( listener ) ; }	register a listener which is notified when the modelupdate period value is changed .
public void test null stored field ( ) throws exception { directory dir = new directory ( ) ; analyzer analyzer = new mock analyzer ( random ( ) ) ; index writer iw = new index writer ( dir , new index writer config ( analyzer ) ) ; document doc = new document ( ) ; iw . add document ( doc ) ; expect throws ( illegal argument exception . class , null ) ; assert null ( iw . get tragic exception ( ) ) ; iw . close ( ) ; directory reader r = directory reader . open ( dir ) ; assert equals ( num , r . num docs ( ) ) ; r . close ( ) ; dir . close ( ) ; }	test a null string value doesn ' t abort the entire segment.
public static document read document ( string file name ) throws sax , io { document builder doc builder ; document result = null ; document builder factory doc builder factory = document builder factory . new instance ( ) ; doc builder factory . set ignoring element content whitespace ( bool ) ; try { doc builder = doc builder factory . new document builder ( ) ; } catch ( parser configuration exception e ) { throw new error ( e ) ; } file source file = new file ( file name ) ; result = doc builder . parse ( source file ) ; return result ; }	reads document from file.
@ override public double [ ] analyse ( double [ ] a frame ) { if ( a frame . length != frame length ) throw new illegal argument exception ( str + frame length + str + a frame . length ) ; double [ ] real = new double [ fft size ] ; double [ ] imag = new double [ fft size ] ; system . arraycopy ( a frame , num , real , num , a frame . length ) ; fft . transform ( real , imag , bool ) ; math utils . to polar coordinates ( real , imag ) ; real = math utils . log ( real ) ; arrays . fill ( imag , num ) ; double b = num ; int b index = ( int ) ( b / frequency resolution ) ; double [ ] inv real ; double [ ] inv imag ; if ( inv fft size == fft size ) { inv real = real ; inv imag = imag ; } else { inv real = new double [ inv fft size ] ; system . arraycopy ( real , num , inv real , num , b index + num ) ; inv imag = new double [ inv fft size ] ; } for ( int i = b index + num ; i < inv fft size / num ; i ++ ) { inv real [ i ] = inv real [ b index ] ; } for ( int i = num ; i < inv fft size / num ; i ++ ) { inv real [ inv fft size - i - num ] = inv real [ i ] ; } fft . transform ( inv real , inv imag , bool ) ; return inv real ; }	apply this framebasedanalyser to the given data .
public search source builder script field ( string name , script script ) { if ( script fields == null ) { script fields = new array list < > ( ) ; } script fields . add ( new script field ( name , script ) ) ; return this ; }	adds a script field under the given name with the provided script .
public static < t > t with object streams ( socket socket , @ closure params ( value = simple type . class , options = { str , str } ) closure < t > closure ) throws io { input stream input = socket . get input stream ( ) ; output stream output = socket . get output stream ( ) ; object output stream oos = new object output stream ( output ) ; object input stream ois = new object input stream ( input ) ; try { t result = closure . call ( new object [ ] { ois , oos } ) ; input stream temp1 = ois ; ois = null ; temp1 . close ( ) ; temp1 = input ; input = null ; temp1 . close ( ) ; output stream temp2 = oos ; oos = null ; temp2 . close ( ) ; temp2 = output ; output = null ; temp2 . close ( ) ; return result ; } finally { close with warning ( ois ) ; close with warning ( input ) ; close with warning ( oos ) ; close with warning ( output ) ; } }	creates an inputobjectstream and an outputobjectstream from a socket , and passes them to the closure.
public j ( shell parent , int style , final string [ ] extensions ) { this ( parent , style , associations ( arrays . as list ( extensions ) ) ) ; }	create a dialog that filters for files with the specified extensions .
private void adjust alignment ( int align , int cur align ) { if ( ( ! fixed width ) && ( align != cur align ) ) { if ( cur line . get component count ( ) == num ) { cur line . set layout ( new flow layout ( cur align ) ) ; } } }	the following replaces the layout of the curline container with the correct alignment , in non fixed width alignment is done by flowlayout ' s orientation . in case the line is not empty , a new line will be opened by newlineifnotempty below.
public void remove listener ( tracking listener listener ) { listeners . remove ( listener ) ; }	remove from listeners list.
void create impl ( boolean stream ) throws socket exception { if ( impl == null ) set impl ( ) ; try { impl . create ( stream ) ; created = bool ; } catch ( io e ) { throw new socket exception ( e . get message ( ) ) ; } }	creates the socket implementation .
public boolean sh exp match ( string str , string shexp ) { string tokenizer tokenizer = new string tokenizer ( shexp , str ) ; int start pos = num ; while ( tokenizer . has more tokens ( ) ) { string token = tokenizer . next token ( ) ; int temp = str . index of ( token , start pos ) ; if ( start pos == num && ! shexp . starts with ( str ) && temp != num ) { return bool ; } if ( ! tokenizer . has more tokens ( ) && ! shexp . ends with ( str ) && ! str . ends with ( token ) ) { return bool ; } if ( temp == - num ) { return bool ; } else { start pos = temp + token . length ( ) ; } } return bool ; }	returns true if the string matches the specified shell expression.
public char peek ( ) { return is empty ( ) ? num : queue . char at ( pos ) ; }	retrieves but does not remove the first character from the queue .
private string [ ] parent key ( string name , int idx ) { string [ ] parts = name . split ( str ) ; if ( idx > parts . length ) return null ; string parent = str ; string key = null ; if ( idx < parts . length ) key = parts [ idx ] ; for ( int i = num ; i < idx ; i ++ ) { parent = parent . length ( ) > num ? parent + str + parts [ i ] : parts [ i ] ; } return new string [ ] { parent , key } ; }	splits a name formatted like a.
public diphone unit database ( url url , boolean is binary ) throws io { if ( ! use indexing || use cache ) { diphone map = new linked hash map ( ) ; } input stream is = utilities . get input stream ( url ) ; index name = get index name ( url . to string ( ) ) ; if ( is binary ) { load binary ( is ) ; } else { load text ( is ) ; } is . close ( ) ; sample info = new sample info ( sample rate , num channels , residual fold , lpc min , lpc range , num ) ; }	creates the diphoneunitdatabase from the given input stream .
public static list < notification dto > transform to dto ( list < notification > notifications ) { if ( notifications == null ) { throw new web application exception ( str , status . internal server error ) ; } list < notification dto > result = new array list < notification dto > ( ) ; for ( notification notification : notifications ) { result . add ( transform to dto ( notification ) ) ; } return result ; }	converts list of notification entity objects to list of notificationdto objects .
public void write to ( final packet output stream os ) { os . write ( parameter writer . quote ) ; os . write ( date to byte ( ) ) ; parameter writer . format microseconds ( os , ts . get nanos ( ) / num , fractional seconds ) ; os . write ( parameter writer . quote ) ; }	write timestamps to outputstream .
public long skip ( long n ) throws io , log exception { if ( length < n ) bad read ( ( int ) n ) ; n = in . skip ( n ) ; length -= ( int ) n ; return n ; }	skips n bytes of input .
public driver task discover storage provider ( storage provider storage provider , list < storage system > storage systems ) { sc task = new sc ( str ) ; try { log . info ( str , storage provider . get provider host ( ) , storage provider . get port number ( ) , storage provider . get username ( ) ) ; api api = connection manager . get connection ( storage provider . get provider host ( ) , storage provider . get port number ( ) , storage provider . get username ( ) , storage provider . get password ( ) , bool ) ; log . info ( str , storage provider . get provider host ( ) , storage provider . get username ( ) ) ; storage provider . set access status ( access status . read write ) ; storage provider . set manufacturer ( str ) ; storage provider . set provider version ( driver version ) ; storage provider . set is supported version ( bool ) ; em data collector em = api . get dsm ( ) ; if ( em != null ) { log . info ( str , em . type , em . version , em . java version ) ; storage provider . set provider version ( em . version ) ; } storage center [ ] scs = api . get storage center info ( ) ; for ( storage center sc : scs ) { storage system storage system = util . get storage system from storage center ( api , sc , null ) ; storage system . set system type ( driver name ) ; storage systems . add ( storage system ) ; } task . set status ( driver task . task status . ready ) ; } catch ( exception e ) { string msg = string . format ( str , e ) ; log . error ( msg ) ; task . set failed ( msg ) ; } return task ; }	perform discovery for a storage provider .
public void zoom in ( ) { zoom in ( null ) ; }	zooms into the graph by zoomfactor .
public void remove response code listener ( action listener a ) { response code listeners . remove element ( a ) ; }	removes a response listener.
public input field dialog ( final string caption key , final string label key ) { string caption = i18n . tr ( caption key ) ; frame frame = gui . get app frame ( ) ; dialog = new j ( frame , caption , bool ) ; dialog . set size ( num , num ) ; labeled component component = new labeled component ( label key , text field , labeled component . left glue ) ; string [ ] button label keys = { i18n . tr ( str ) , i18n . tr ( str ) } ; string [ ] button label tips = { i18n . tr ( str ) , i18n . tr ( str ) } ; action listener [ ] button listeners = { new ok ( ) , new cancel listener ( ) } ; button row buttons = new button row ( button label keys , button label tips , button listeners , button row . x axis , button row . left glue ) ; container content pane = dialog . get content pane ( ) ; box panel component panel = new box panel ( box panel . y axis ) ; component panel . add ( box . create vertical glue ( ) ) ; component panel . add ( component . get component ( ) ) ; component panel . add ( box . create vertical glue ( ) ) ; main panel . add ( component panel ) ; main panel . add ( box . create vertical glue ( ) ) ; main panel . add ( buttons ) ; content pane . add ( main panel ) ; }	constructs an input field using the specified locale - specific keys for both the caption and the field label .
public entity load info create ( entity entity ) { return create ( entity , null ) ; }	create a new info instance with empty view name .
public float ( d pt2 d ) { set lat lon ( pt2 d . get y ( ) , pt2 d . get x ( ) , bool ) ; }	create float version from point2d object , where the x , y values are expected to be decimal degrees .
public final static boolean is potential zip archive ( string name ) { int last dot = name . last index of ( str ) ; if ( last dot == - num ) return bool ; if ( name . last index of ( file . separator char ) > last dot ) return bool ; int length = name . length ( ) ; int extension length = length - last dot - num ; if ( extension length == extension java . length ( ) ) { for ( int i = extension length - num ; i >= num ; i -- ) { if ( character . to lower case ( name . char at ( length - extension length + i ) ) != extension java . char at ( i ) ) { break ; } if ( i == num ) { return bool ; } } } if ( extension length == extension class . length ( ) ) { for ( int i = extension length - num ; i >= num ; i -- ) { if ( character . to lower case ( name . char at ( length - extension length + i ) ) != extension class . char at ( i ) ) { return bool ; } } return bool ; } return bool ; }	returns whether the given name is potentially a zip archive file name ( it has a file extension and it is not ".
public void open ( ) throws io { connection = new datagram socket ( ) ; connection . set so timeout ( timeout ) ; }	open the datagram connection.
default void for each remaining ( int consumer action ) { objects . require non null ( action ) ; while ( has next ( ) ) action . accept ( next int ( ) ) ; }	performs the given action for each remaining element until all elements have been processed or the action throws an exception.
private boolean is ci ( ) { return objects . equals ( system . getenv ( str ) , str ) ; }	check if we are running as ci.
public dock node ( node contents , string title ) { this ( contents , title , null ) ; }	creates a default docknode with a default title bar and layout .
public void test2033092 ( ) { relative date format rdf = new relative date format ( ) ; rdf . set show zero days ( bool ) ; rdf . set show zero hours ( bool ) ; rdf . set minute suffix ( str ) ; rdf . set hour suffix ( str ) ; rdf . set second suffix ( str ) ; decimal format hours formatter = new decimal format ( ) ; hours formatter . set maximum fraction digits ( num ) ; hours formatter . set maximum integer digits ( num ) ; hours formatter . set minimum integer digits ( num ) ; rdf . set hour formatter ( hours formatter ) ; decimal format mins formatter = new decimal format ( ) ; mins formatter . set maximum fraction digits ( num ) ; mins formatter . set maximum integer digits ( num ) ; mins formatter . set minimum integer digits ( num ) ; rdf . set minute formatter ( mins formatter ) ; decimal format seconds formatter = new decimal format ( ) ; seconds formatter . set maximum fraction digits ( num ) ; seconds formatter . set maximum integer digits ( num ) ; seconds formatter . set minimum integer digits ( num ) ; rdf . set second formatter ( seconds formatter ) ; string s = rdf . format ( new date ( num * num * num * num + num ) ) ; assert equals ( str , s ) ; }	test that we can configure the relativedateformat to show hh : mm : ss .
public static long parse id ( uri content uri ) { string last = content uri . get last path segment ( ) ; return last == null ? - num : long . parse long ( last ) ; }	converts the last path segment to a long.
public void disable vm ( string hostname , long duration millis ) throws illegal state exception { logger . info ( str + hostname + str + duration millis + str ) ; assignable v . disable until ( hostname , system . current time millis ( ) + duration millis ) ; }	disable the virtual machine with the specified hostname.
protected final void end of input ( ) throws io { if ( cache request != null ) { cache body . close ( ) ; } http engine . release ( bool ) ; }	closes the cache entry and makes the socket available for reuse.
public int left ( ) { return data . length ( ) - pos ; }	number of characters left .
public feature set combine ( final feature set other ) { final set < feature > enabled = new hash set < > ( this . enabled ) ; enabled . add all ( other . enabled ) ; final set < feature > disabled = new hash set < > ( this . disabled ) ; disabled . add all ( other . disabled ) ; return new feature set ( enabled , disabled ) ; }	combine this feature set with another .
public void remove interval ( final batch writer writer , final temporal interval interval , final statement statement ) throws mutations rejected exception { final text cf = new text ( statement serializer . write context ( statement ) ) ; final text cq begin = new text ( key parts . cq begin ) ; final text cq end = new text ( key parts . cq end ) ; text key text = new text ( interval . get as key beginning ( ) ) ; key parts . append uniqueness ( statement , key text ) ; mutation m = new mutation ( key text ) ; m . put delete ( cf , cq begin ) ; writer . add mutation ( m ) ; key text = new text ( interval . get as key end ( ) ) ; key parts . append uniqueness ( statement , key text ) ; m = new mutation ( key text ) ; m . put delete ( cf , cq end ) ; writer . add mutation ( m ) ; }	remove an interval index todo : integrate into keyparts ( or eliminate ).
public static final string remove data folder path ( string full path ) { file sd card = environment . get external storage directory ( ) ; string data folder path = sd card . get absolute path ( ) + str + main app . get data folder ( ) + str ; if ( full path . index of ( data folder path ) == num ) { return full path . substring ( data folder path . length ( ) ) ; } return full path ; }	takes a full path to owncloud file and removes beginning which is path to ownload data folder.
default completable future < optional < r > > match async ( final executor executor , final t value ) { return completable future . supply async ( null , executor ) ; }	similar to match , but executed asynchonously on supplied executor .
public static void main ( string [ ] args ) throws format exception { debug . init ( ) ; if ( args . length == num ) { debug . output ( str ) ; system . exit ( num ) ; } for ( int argsi = num ; argsi < args . length ; argsi ++ ) { rootpath = args [ argsi ] ; library selection table lst = new library selection table ( rootpath ) ; if ( debug . debugging ( str ) ) { debug . output ( str + rootpath ) ; debug . output ( str + lst . get database name ( ) ) ; } println ( str ) ; println ( str + rootpath ) ; println ( str + lst . get database description ( ) ) ; list < string > libraries = lst . get library names ( ) ; if ( debug . debugging ( str ) ) { print ( str ) ; for ( string library name : libraries ) { print ( library name , str ) ; } println ( ) ; println ( ) ; } for ( string library name : libraries ) { string prefix = lst . get database name ( ) + str + library name ; println ( str + prefix ) ; print library ( prefix , lst . get cat ( library name ) ) ; println ( ) ; } } }	the main program . takes path arguments , and prints the db it finds.
private static string wildcard to regex ( string pattern ) { return str + string utils . replace each ( escape regexp ( pattern ) , new string [ ] { str , str } , new string [ ] { str , str } ) + str ; }	converts wildcard to regular expression.
protected void clear cache ( ) { if ( cache != null ) { cache . clear ( ) ; cache = null ; } }	clears the cache soft reference if existing .
public string sql ad get custom entity types ( string vendor name , string catalog name , string schema name ) { string table name = str ; array list < string > column names = new array list < string > ( ) ; column names . add ( str ) ; array list < string > alias names = new array list < string > ( ) ; alias names . add ( str ) ; array list < string > conditions = new array list < string > ( ) ; conditions . add ( str ) ; array list < string > sort columns = new array list < string > ( ) ; sort columns . add ( str ) ; return sql select ( vendor name , catalog name , schema name , table name , null , column names , alias names , conditions , sort columns , bool ) ; }	gets the database specific sql command to find custom entity types.
public void paint component ( graphics g ) { int x = padding ; int y = padding ; g . draw image ( picture , x , y , scale w , scale h , null ) ; x += scale w + padding ; g . draw image ( picture , x , y , x + scale w , y + scale h , num , num , picture . get width ( ) , picture . get height ( ) , null ) ; x += scale w + padding ; d g2d = ( d ) g . create ( ) ; g2d . translate ( x , y ) ; g2d . scale ( scale factor , scale factor ) ; g2d . draw image ( picture , num , num , null ) ; g2d . dispose ( ) ; x += scale w + padding ; g2d = ( d ) g . create ( ) ; affine transform at = new affine transform ( ) ; at . translate ( x , y ) ; at . scale ( scale factor , scale factor ) ; g2d . draw image ( picture , at , null ) ; g2d . dispose ( ) ; x += scale w + padding ; image scaled img = picture . get scaled instance ( scale w , scale h , image . scale default ) ; g . draw image ( scaled img , x , y , null ) ; }	draws the picture five times , using the five different scaling approaches described in the book.
public int hash code ( ) { return id type . hash code ( ) ; }	returns the hash code of the object.
private static void backup audio config ( ) { if ( null != m restore audio config timer ) { m restore audio config timer . cancel ( ) ; m restore audio config timer = null ; m restore audio config timer mask = null ; } else if ( null == m audio mode ) { audio manager audio manager = get audio manager ( ) ; m audio mode = audio manager . get mode ( ) ; m is speaker on = audio manager . is speakerphone on ( ) ; } }	back up the current audio config .
public static string build imdn delivery report ( string msg id , imdn document . delivery status status , long timestamp ) { string method ; switch ( status ) { case displayed : method = str ; break ; case delivered : method = str ; break ; default : method = str ; break ; } return str + ut str + str + crlf + str + crlf + str + msg id + str + crlf + str + date utils . encode date ( timestamp ) + str + crlf + str + method + str + status + str + method + str + crlf + str ; }	build a delivery report.
private speedruns live request ( ) { super ( url ) ; }	creates a new request .
public static bitmap decode resource with backouts ( resources res , bitmap factory . options options , int id ) { boolean no bitmap = bool ; int num tries = num ; if ( options . in sample size < num ) { options . in sample size = num ; } bitmap bmap = null ; while ( no bitmap ) { try { bmap = bitmap factory . decode resource ( res , id , options ) ; no bitmap = bool ; } catch ( java . lang . out of memory error e ) { if ( ++ num tries >= bitmap load backout attempts ) { throw e ; } bmap = null ; system . gc ( ) ; options . in sample size *= num ; } } return bmap ; }	loads bitmap from a resource that may be downsampled in low - memory situations .
public void read data file ( string content ) throws data file exception { if ( content == null || content . length ( ) <= num ) throw new illegal state exception ( str ) ; byte array input stream bis = new byte array input stream ( content . get bytes ( ) ) ; read data file ( bis , null ) ; }	populates ( or reloads ) the data file with the text of the given content.
public static string read utf ( data input in ) throws io { return data input stream . read utf ( in ) ; }	note . this is a static method !.
protected object lazily load desktop property ( string name ) { if ( name . starts with ( str ) ) { return lazily load gtk ( name ) ; } return super . lazily load desktop property ( name ) ; }	overridden to handle gtk icon loading.
public o ( string private key string ) throws o { if ( private key string == null ) { throw new o ( str ) ; } else if ( private key string . length ( ) == num ) { throw new o ( str ) ; } try { set private key ( rsa sha1 private key helper . get private key ( private key string ) ) ; } catch ( base64 decoder exception e ) { throw new o ( str , e ) ; } catch ( no such algorithm exception e ) { throw new o ( str , e ) ; } catch ( invalid key spec exception e ) { throw new o ( str , e ) ; } }	sets the rsa - sha1 private key object used to sign this request .
private map < string , volume > group volumes by replication group ( list < volume > volume list ) { map < string , volume > rep group to volume map = new hash map < string , volume > ( ) ; for ( volume volume : volume list ) { string rep group name = volume . get replication group instance ( ) ; if ( volume . is v ( db client ) ) { volume backed vol = v . get vplex ( volume , bool , db client ) ; if ( backed vol != null ) { rep group name = backed vol . get replication group instance ( ) ; } } rep group to volume map . put ( rep group name , volume ) ; } return rep group to volume map ; }	returns a map of replication group name to one of the volumes in the group .
public default file filter ( string extension , string description ) { ext = extension . to lower case ( ) ; desc = description ; }	constructs a new filter for the specified extension and descpription .
public void append cell ( boolean value ) { append cell ( string . value of ( value ) ) ; }	appends a new cell to the current row containing the provided boolean value .
public string name ( ) { return system . get property ( str ) ; }	returns the name of the currently - running jvm .
protected void add url ( url url ) { try { original urls . add ( url ) ; search list . add ( create search url ( url ) ) ; } catch ( url e ) { } }	adds the specified url to the search list .
public void init structure ( ) throws exception { int n attribute = num ; for ( int i order = num ; i order < m . num attributes ( ) ; i order ++ ) { if ( n attribute == m . class index ( ) ) { n attribute ++ ; } } m = new parent set [ m . num attributes ( ) ] ; for ( int i attribute = num ; i attribute < m . num attributes ( ) ; i attribute ++ ) { m [ i attribute ] = new parent set ( m . num attributes ( ) ) ; } }	init structure initializes the structure to an empty graph or a naive bayes graph ( depending on the - n flag ) .
@ override public synchronized completable future < void > disconnect ( ) { close future = new completable future < > ( ) ; if ( ! consumers . is empty ( ) ) { consumers . for each ( null ) ; if ( have pending read && cursor . cancel pending read request ( ) ) { have pending read = bool ; } } else { close future . complete ( null ) ; } return close future ; }	disconnect all consumers on this dispatcher ( server side close ).
public static string read ascii line ( input stream in ) throws io { string builder result = new string builder ( num ) ; while ( bool ) { int c = in . read ( ) ; if ( c == - num ) { throw new eof ( ) ; } else if ( c == str ) { break ; } result . append ( ( char ) c ) ; } int length = result . length ( ) ; if ( length > num && result . char at ( length - num ) == str ) { result . set length ( length - num ) ; } return result . to string ( ) ; }	returns the ascii characters up to but not including the next " \ r \ n " , or " \ n " .
protected boolean ip ( int ip ) { int inv subnet mask = ~ this . subnet mask ; return ( ( ip & inv subnet mask ) == inv subnet mask ) ; }	checks whether an ip address is a broadcast address or not ( determines using subnet mask ).
public void add cell appearances to work list ( df cell ) { for ( enumeration < df > e = get equations ( ) ; e . has more elements ( ) ; ) { df eq = e . next element ( ) ; if ( eq . has cell ( cell ) ) { add to work list ( eq ) ; } } }	add all equations which contain a given cell to the work list .
public void remove ( constraint widget widget ) { element to unselect = null ; for ( element selection : m selected widgets ) { if ( selection . widget == widget ) { to unselect = selection ; break ; } } if ( to unselect != null ) { m selected widgets . remove ( to unselect ) ; } selection has changed ( ) ; }	remove the widget from the current selection.
public static long hex string to long ( final string hex string ) { preconditions . check not null ( hex string , str ) ; preconditions . check argument ( is hex string ( hex string ) , string . format ( str , hex string ) ) ; if ( ( hex string . length ( ) == num ) && ( hex string . char at ( num ) >= num ) ) { final string str addr1 = hex string . substring ( num , hex string . length ( ) - num ) ; final string str addr2 = hex string . substring ( hex string . length ( ) - num ) ; return ( long . parse long ( str addr1 , num ) << num ) + long . parse long ( str addr2 , num ) ; } return long . parse long ( hex string , num ) ; }	converts an hex string to long .
public static boolean contains file ( @ not null source provider provider , @ not null file file ) { collection < file > src directories = get all source folders ( provider ) ; if ( files equal ( provider . get manifest file ( ) , file ) ) { return bool ; } for ( file container : src directories ) { file parent = container . get parent file ( ) ; if ( parent != null && parent . is directory ( ) && files equal ( parent , file ) ) { return bool ; } if ( ! container . exists ( ) ) { continue ; } if ( is ancestor ( container , file , bool ) ) { return bool ; } } return bool ; }	returns true iff this sourceprovider provides the source folder that contains the given file .
public static string check not empty ( string string , object error message ) { if ( exo player library info . assertions enabled && text utils . is empty ( string ) ) { throw new illegal argument exception ( string . value of ( error message ) ) ; } return string ; }	ensures that a string passed as an argument to the calling method is not null or 0 - length .
void run post search ( int cnt items ) ;	runs when search results are retrieved .
private ssl unwrap ( ) throws ssl { if ( app buffer == null ) { app buffer = io buffer . allocate ( in net buffer . remaining ( ) ) ; } else { app buffer . expand ( in net buffer . remaining ( ) ) ; } ssl res ; status status = null ; handshake status handshake status = null ; do { res = ssl engine . unwrap ( in net buffer . buf ( ) , app buffer . buf ( ) ) ; status = res . get status ( ) ; handshake status = res . get handshake status ( ) ; if ( status == ssl . status . buffer overflow ) { app buffer . capacity ( app buffer . capacity ( ) << num ) ; app buffer . limit ( app buffer . capacity ( ) ) ; continue ; } } while ( ( ( status == ssl . status . ok ) || ( status == ssl . status . buffer overflow ) ) && ( ( handshake status == ssl . handshake status . not handshaking ) || ( handshake status == ssl . handshake status . need unwrap ) ) ) ; return res ; }	decrypt the incoming buffer and move the decrypted data to an application buffer .
public certificate request certificate ( byte [ ] csr ) throws acme exception { return request certificate ( csr , null , null ) ; }	requests a certificate for the given csr.
public void clear ( ) { m strings . clear ( ) ; notify data set changed ( ) ; }	remove all elements from the list .
@ suppress warnings ( { str } ) private static grid uri deployment file processor result process with descriptor file ( grid uri deployment spring document doc , file file , string uri , ignite logger log ) throws ignite spi exception { class loader cls ldr = grid uri deployment class loader factory . create ( u . grid class loader ( ) , file , log ) ; list < class < ? extends compute task < ? , ? > > > tasks = doc . get tasks ( cls ldr ) ; list < class < ? extends compute task < ? , ? > > > valid tasks = null ; if ( ! f . is empty ( tasks ) ) { valid tasks = new array list < > ( ) ; for ( class < ? extends compute task < ? , ? > > task : tasks ) { if ( ! is allowed task class ( task ) ) { u . warn ( log , str + str + task + str ) ; } else { if ( log . is debug enabled ( ) ) log . debug ( str + task . get name ( ) ) ; valid tasks . add ( task ) ; } } } grid uri deployment file processor result res = new grid uri deployment file processor result ( ) ; res . set file ( file ) ; res . set class loader ( cls ldr ) ; if ( ! f . is empty ( valid tasks ) ) res . set task classes ( valid tasks ) ; else if ( log . is debug enabled ( ) ) log . debug ( str + file . get absolute path ( ) + str + u . hide password ( uri ) + str ) ; return res ; }	processes given gar file and returns back all tasks which are in descriptor .
private < t extends data object > boolean test selections ( j jc , t dobj ) { list < j > list = jc . get selections ( ) ; for ( j js : list ) { if ( test selection ( jc , js , dobj ) == bool ) { return bool ; } } return bool ; }	selections are logically and - ed together.
public void truncate ( ) { calculate ideal point ( ) ; translate by ideal point ( ) ; list < list < solution > > members = associate to reference point ( this ) ; clear ( ) ; for ( int i = num ; i < members . size ( ) ; i ++ ) { list < solution > associations = members . get ( i ) ; if ( associations . size ( ) > num ) { add ( select ( associations , i ) ) ; } } }	truncates the population so that only one solution is associated with each reference vector .
protected void on downloading ( ) { if ( log configuration . logging is enabled ( ) ) { logger . log ( level . info , messages . downloading resources ( ) ) ; } updating = bool ; fire application cache event ( cache event . on downloading ) ; }	called when a downloading event is triggered.
protected synchronized void add transition listener ( hashtable < tx state , hashtable < tx state , set < event listener > > > listeners , event listener lstnr , tx state from , tx state to ) { hashtable < tx state , set < event listener > > lstnrs = listeners . get ( from ) ; if ( lstnrs == null ) lstnrs = new hashtable < tx state , set < event listener > > ( ) ; set < event listener > tolstnrs = lstnrs . get ( to ) ; if ( tolstnrs == null ) tolstnrs = new hash set < event listener > ( ) ; if ( ! tolstnrs . contains ( lstnr ) ) tolstnrs . add ( lstnr ) ; lstnrs . put ( to , tolstnrs ) ; listeners . put ( from , lstnrs ) ; }	help function for adding transition listeners .
public boolean has exclusion ( ) { return ! m excluded classes . is empty ( ) || ! m excluded tests . is empty ( ) ; }	return true if there are exclusions rules defined .
private int ensure baseline on grid ( ) { float baseline = get baseline ( ) ; float grid align = baseline % four dip ; if ( grid align != num ) { extra top padding = ( int ) ( four dip - math . ceil ( grid align ) ) ; } return extra top padding ; }	ensure that the first line of text sits on the 4dp grid .
@ override public void compute ( ) { spliterator < p in > rs = spliterator , ls ; long size estimate = rs . estimate size ( ) ; long size threshold = get target size ( size estimate ) ; boolean fork right = bool ; @ suppress warnings ( str ) k task = ( k ) this ; atomic reference < r > sr = shared result ; r result ; while ( ( result = sr . get ( ) ) == null ) { if ( task . task canceled ( ) ) { result = task . get empty result ( ) ; break ; } if ( size estimate <= size threshold || ( ls = rs . try split ( ) ) == null ) { result = task . do leaf ( ) ; break ; } k left child , right child , task to fork ; task . left child = left child = task . make child ( ls ) ; task . right child = right child = task . make child ( rs ) ; task . set pending count ( num ) ; if ( fork right ) { fork right = bool ; rs = ls ; task = left child ; task to fork = right child ; } else { fork right = bool ; task = right child ; task to fork = left child ; } task to fork . fork ( ) ; size estimate = rs . estimate size ( ) ; } task . set local result ( result ) ; task . try complete ( ) ; }	overrides abstracttask version to include checks for early exits while splitting or computing .
public static map < string , object > create content assoc ( dispatch context dctx , map < string , ? extends object > rcontext ) { map < string , object > context = util misc . make map writable ( rcontext ) ; context . put ( str , str ) ; list < string > target operation list = content worker . prep target operation list ( context , str ) ; list < string > content purpose list = content worker . prep content purpose list ( context ) ; context . put ( str , target operation list ) ; context . put ( str , content purpose list ) ; context . put ( str , null ) ; map < string , object > result = null ; try { result = create content assoc method ( dctx , context ) ; } catch ( generic service exception e ) { return service util . return error ( e . get message ( ) ) ; } catch ( generic entity exception e2 ) { return service util . return error ( e2 . get message ( ) ) ; } catch ( exception e3 ) { return service util . return error ( e3 . get message ( ) ) ; } return result ; }	create a contentassoc service.
public string format with locale ( locale locale , string ... args ) { return string . format ( locale , this . content , ( object [ ] ) args ) ; }	formats the applied args into the template content.
private static < t extends abstract block base < t > > t add path to linear scan order ( t block , list < t > order , priority queue < t > worklist , bit set visited blocks ) { block . set linear scan number ( order . size ( ) ) ; order . add ( block ) ; t most likely successor = find and mark most likely successor ( block , visited blocks ) ; enqueue successors ( block , worklist , visited blocks ) ; if ( most likely successor != null ) { if ( ! most likely successor . is loop header ( ) && most likely successor . get predecessor count ( ) > num ) { double unscheduled sum = num ; for ( t pred : most likely successor . get predecessors ( ) ) { if ( pred . get linear scan number ( ) == - num ) { unscheduled sum += pred . probability ( ) ; } } if ( unscheduled sum > block . probability ( ) / penalty versus unscheduled ) { visited blocks . clear ( most likely successor . get id ( ) ) ; return null ; } } return most likely successor ; } return null ; }	add a linear path to the linear scan order greedily following the most likely successor .
private static dimension create thumb dimension ( final buffered image image , final int max width , final int max height ) { dimension dimension = new dimension ( ) ; if ( image . get width ( ) >= image . get height ( ) ) { if ( image . get width ( ) >= max width ) { dimension . width = max width ; dimension . height = math . round ( ( ( float ) max width / image . get width ( ) ) * image . get height ( ) ) ; } else { dimension . height = image . get height ( ) ; dimension . width = image . get width ( ) ; } } else { if ( image . get height ( ) >= max height ) { dimension . height = max height ; dimension . width = math . round ( ( ( ( float ) max height / image . get height ( ) ) * image . get width ( ) ) ) ; } else { dimension . height = image . get height ( ) ; dimension . width = image . get width ( ) ; } } return dimension ; }	creates dimension of thumb .
private boolean has current account changed ( ) { account account = account utils . get current own cloud account ( this ) ; if ( account == null ) { return bool ; } else { return ! m original current account . equals ( account . name ) ; } }	checks actual current account against current accounts when the activity has been started .
public int next clear bit ( int index ) { int i = index > > num ; if ( i >= wlen ) return - num ; int sub index = index & num ; long word = ~ bits . get ( i ) > > sub index ; if ( word != num ) { return ( i << num ) + sub index + long . number of trailing zeros ( word ) ; } while ( ++ i < wlen ) { word = ~ bits . get ( i ) ; if ( word != num ) { return ( i << num ) + long . number of trailing zeros ( word ) ; } } return - num ; }	find the next clear bit in the bit set .
private static synchronized void append message ( context c , final string msg ) { if ( msg . length ( ) == num ) return ; string out = msg ; boolean timestamp = pref store . is timestamp ( c ) ; int max lines = pref store . get max lines ( c ) ; int protocol size = protocol . size ( ) ; if ( protocol size > num && last char != str ) { protocol . remove ( protocol size - num ) ; out = last line + out ; } last char = out . char at ( out . length ( ) - num ) ; string [ ] lines = out . split ( str ) ; for ( int i = num , l = lines . length ; i < l ; i ++ ) { last line = lines [ i ] ; if ( timestamp ) protocol . add ( get time stamp ( ) + last line ) ; else protocol . add ( last line ) ; if ( protocol size + i >= max lines ) { protocol . remove ( num ) ; } } show ( ) ; if ( pref store . is logger ( c ) ) write ( c , msg ) ; }	append the message to protocol and show.
public object [ ] import cells ( object [ ] cells , double dx , double dy , object target , point location ) { if ( target == null && cells . length == num && location != null ) { target = get cell at ( location . x , location . y ) ; if ( target instanceof mx i && cells [ num ] instanceof mx i ) { mx i target cell = ( mx i ) target ; mx i drop cell = ( mx i ) cells [ num ] ; if ( target cell . is vertex ( ) == drop cell . is vertex ( ) || target cell . is edge ( ) == drop cell . is edge ( ) ) { mx i model = graph . get model ( ) ; model . set style ( target , model . get style ( cells [ num ] ) ) ; graph . set selection cell ( target ) ; return null ; } } } return super . import cells ( cells , dx , dy , target , location ) ; }	overrides drop behaviour to set the cell style if the target is not a valid drop target and the cells are of the same type ( eg.
private void cancel search ( ) { entrant to search = null ; }	don ' t continue the search if requested data is received.
public static result set polar2 cartesian ( double r , double alpha ) { simple result set rs = new simple result set ( ) ; rs . add column ( str , types . double , num , num ) ; rs . add column ( str , types . double , num , num ) ; if ( r != null && alpha != null ) { double x = r . double value ( ) * math . cos ( alpha . double value ( ) ) ; double y = r . double value ( ) * math . sin ( alpha . double value ( ) ) ; rs . add row ( x , y ) ; } return rs ; }	convert polar coordinates to cartesian coordinates.
public void thread fail ( string reason ) { try { fail ( reason ) ; } catch ( assertion failed error t ) { thread record failure ( t ) ; throw t ; } }	just like fail ( reason ) , but additionally recording ( using threadrecordfailure ) any assertionfailederror thrown , so that the current testcase will fail .
@ override public void connection lost ( throwable cause ) { on disconnect ( bool ) ; }	called when the connection to the server was lost.
private boolean is typed time fully legal ( ) { if ( m is24 hour mode ) { int [ ] values = get entered time ( null ) ; return ( values [ num ] >= num && values [ num ] >= num && values [ num ] < num && values [ num ] >= num && values [ num ] < num ) ; } else { return ( m typed times . contains ( get am or pm key code ( am ) ) || m typed times . contains ( get am or pm key code ( pm ) ) ) ; } }	check if the time that has been typed so far is completely legal , as is .
public synchronized void clear annotations ( ) { m annotations . clear ( ) ; m string xy . clear ( ) ; }	removes all the existing annotations from the series .
public table sample ( double proportion ) { int table count = ( int ) math . round ( row count ( ) * proportion ) ; selection table1 selection = new bitmap backed selection ( ) ; int [ ] selected records = generate uniform bitmap ( table count , row count ( ) ) ; for ( int selected record : selected records ) { table1 selection . add ( selected record ) ; } return select where ( table1 selection ) ; }	returns a table consisting of randomly selected records from this table . the sample size is based on the given proportion.
public static message digest new digest ( ) { try { return message digest . get instance ( str ) ; } catch ( no such algorithm exception e ) { throw new runtime exception ( e ) ; } }	returns a new sha - 256 messagedigest instance.
public container add child at ( int location , @ non null display object display object ) { if ( m fps != default fps ) { display object . set up ( m fps ) ; } m display list . add ( location , display object ) ; return this ; }	adds a child to the display list at the specified index , bumping children at equal or greater indexes up one , and setting its parent to this container.
private void add ( dimension index index ) { flatten . add ( index ) ; lookup . put ( index . get axis ( ) , index ) ; }	populate the hierarchy with the indexes < li > this method is not thread - safe.
public static recipe petals register petal recipe ( item stack output , object ... inputs ) { preconditions . check argument ( inputs . length <= num ) ; recipe petals recipe = new recipe petals ( output , inputs ) ; petal recipes . add ( recipe ) ; return recipe ; }	registers a petal recipe .
private void build first line ( line path path , rect r ) { int [ ] range = new int [ ] { - r . left , - r . top , r . right , r . bottom } ; int max = - num ; int max id = num ; for ( int i = num ; i < num ; i ++ ) { if ( range [ i ] > max ) { max = range [ i ] ; max id = i ; } } switch ( max id ) { case num : path . set end point ( r . left , utils . next int ( r . height ( ) ) + r . top ) ; break ; case num : path . set end point ( utils . next int ( r . width ( ) ) + r . left , r . top ) ; break ; case num : path . set end point ( r . right , utils . next int ( r . height ( ) ) + r . top ) ; break ; case num : path . set end point ( utils . next int ( r . width ( ) ) + r . left , r . bottom ) ; break ; } path . line to end ( ) ; }	line to the the farthest boundary , in case appear a super big piece .
public void test value of double neg ( ) { double a = - num ; big decimal result = big decimal . value of ( a ) ; string res = str ; int res scale = num ; assert equals ( str , res , result . to string ( ) ) ; assert equals ( str , res scale , result . scale ( ) ) ; }	create a bigdecimal from a negative double value.
public void test huge term ( ) throws io { string builder sb = new string builder ( ) ; for ( int i = num ; i < num ; i ++ ) { sb . append ( str ) ; } string input = sb . to string ( ) ; char token [ ] = new char [ num ] ; arrays . fill ( token , str ) ; string expected token = new string ( token ) ; string expected [ ] = { expected token , expected token , expected token , expected token , expected token , expected token , expected token , expected token , expected token , expected token } ; assert analyzes to ( sentence , input , expected ) ; }	tests the handling of binary / malformed data.
public double calc distance ( final double x , final double y ) { double distance x ; double distance y ; if ( this . min x <= x && x <= this . max x ) { distance x = num ; } else { distance x = math . min ( math . abs ( this . min x - x ) , math . abs ( this . max x - x ) ) ; } if ( this . min y <= y && y <= this . max y ) { distance y = num ; } else { distance y = math . min ( math . abs ( this . min y - y ) , math . abs ( this . max y - y ) ) ; } return math . sqrt ( distance x * distance x + distance y * distance y ) ; }	calculates the ( minimum ) distance of a given point to the border of the rectangle.
public synchronized void ensure capacity ( int minimum capacity ) { if ( element data . length < minimum capacity ) { int next = ( capacity increment <= num ? element data . length : capacity increment ) + element data . length ; grow ( minimum capacity > next ? minimum capacity : next ) ; } }	ensures that this vector can hold the specified number of elements without growing .
@ override public string to string ( ) { return string . format ( str , ledger id , entry id ) ; }	string representation of virtual cursor - ledgerid : entryid.
public void trigger ( date time ) { task list . remove ( time ) ; }	implements the trigger function for triggerable interface .
cipher ( cipher spi cipher spi , string transformation ) { this . spi = cipher spi ; this . transformation = transformation ; this . crypto perm = crypto all permission . instance ; this . lock = null ; }	creates a cipher object.
public void test flip bit positive outside1 ( ) { byte a bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = num ; int number = num ; byte r bytes [ ] = { num , num , num , num , num , num , num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . flip bit ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	flipbit ( int n ) outside a positive number.
private void write object ( object output stream a output stream ) throws io { a output stream . default write object ( ) ; }	this is the default implementation of writeobject.
@ override public boolean is panel enabled ( ) { return multi option group enabled ; }	checks if is panel enabled .
public static string to unix newline ( string input ) { return input . replace ( str , str ) ; }	enforces unix newlines on the given string .
private void output indentation ( ) { for ( int i = num ; i < m indent ; i ++ ) { m out . print ( m basic indent ) ; } }	indent to the current level in multiples of basicindent.
protected bucket < t > create bucket ( long bucket key ) { return new bucket < t > ( bucket key ) ; }	create the bucket with the given key.
public abstract site map parse site map ( byte [ ] content , url url ) throws unknown format exception , io { if ( url == null ) { return null ; } string filename = filename utils . get name ( url . get path ( ) ) ; string content type = tika . detect ( content , filename ) ; return parse site map ( content type , content , url ) ; }	parse a sitemap , given the content bytes and the url .
public application meta data ( final deserializer deserializer ) { this . app name = deserializer . read string ( str ) ; this . version = deserializer . read string ( str ) ; this . certificate signer = deserializer . read optional string ( str ) ; this . start time = time instant . read from ( deserializer , str ) ; this . current time = time instant . read from ( deserializer , str ) ; this . time provider = null ; }	deserializes an application meta data instance .
public static constraints parameters load policy data ( input stream policy data stream ) { if ( policy data stream != null ) { return load ( policy data stream ) ; } if ( ( default policy constraints location != null ) && ! default policy constraints location . is empty ( ) ) { return load ( default policy constraints location ) ; } return null ; }	this method loads the policy constraint file.
public static void close ( output stream out ) { try { if ( out != null ) { out . close ( ) ; } } catch ( io io e ) { } }	closes an output stream .
@ override public boolean is cell editable ( int row , int col ) { if ( is connected to data source ) { if ( col != field column id ) { return bool ; } else { return bool ; } } else { return bool ; } }	checks if is cell editable .
private void save sorted pom file ( final string sorted xml ) { file util . save pom file ( sorted xml ) ; log . info ( str + pom file . get absolute path ( ) ) ; }	saves the sorted pom file .
private void append statements ( policy type policy , string prefix ) { list < statement > append statements = new statements ( policy , prefix ) ; for ( statement statement : append statements ) { append statement ( statement ) ; } }	appends new statements for given policy type .
private void validate totp ( ) throws auth login exception { string builder error messages = new string builder ( ) ; if ( string utils . is empty ( login time attr name ) ) { error messages . append ( str ) ; } if ( clock drift check enabled && string utils . is empty ( observed clock drift attr name ) ) { error messages . append ( str ) ; } if ( totp time step <= num ) { error messages . append ( str + totp time step + str ) ; } if ( totp steps in window < num ) { error messages . append ( str + totp steps in window ) ; } if ( error messages . length ( ) > num ) { debug . error ( str + error messages . to string ( ) ) ; throw new auth login exception ( am auth oath , str , null ) ; } }	validate totp specific settings .
public static string remove uri fragment ( string url ) { if ( url == null || url . length ( ) == num ) { return null ; } string [ ] arr = url . split ( str ) ; if ( arr . length == num ) { return arr [ num ] ; } else { return url ; } }	gets the uri without the fragment.
public static void write receipts to files ( list < byte [ ] > printed receipts , string prefix , file base dir ) { try { int index = num ; for ( byte [ ] printed receipt : printed receipts ) { byte array input stream b in = new byte array input stream ( printed receipt ) ; file receipt file = new file ( base dir , prefix + str + index + str ) ; buffered output stream buffered output stream = new buffered output stream ( new file output stream ( receipt file ) ) ; io . copy ( b in , buffered output stream ) ; buffered output stream . close ( ) ; index ++ ; } } catch ( io e ) { e . print stack trace ( ) ; } }	helper method for storing printed pdf receipts to files.
public synchronized void render data for projection ( projection proj , java . awt . graphics g ) { fire status update ( layer status event . finish working ) ; if ( proj == null ) { logger . info ( str ) ; return ; } else { set target index ( proj . get scale ( ) ) ; layer layer = get appropriate layer ( ) ; layer . render data for projection ( proj , g ) ; } }	implementing the projectionpainter interface .
private container panel create container panel ( ) { container panel container panel = new container panel ( ) ; container panel . set animated ( bool ) ; container panel . set minimum size ( new dimension ( num , num ) ) ; character = new character ( ) ; container panel . add repaintable ( character ) ; inventory = new slot window ( str , num , num ) ; inventory . set accepted types ( entity map . get class ( str , null , null ) ) ; inventory . set closeable ( bool ) ; container panel . add repaintable ( inventory ) ; keyring = new key ring ( ) ; keyring . set accepted types ( entity map . get class ( str , null , null ) ) ; container panel . add repaintable ( keyring ) ; user context . add feature change listener ( keyring ) ; spells = new spells ( ) ; spells . set accepted types ( entity map . get class ( str , null , null ) ) ; container panel . add repaintable ( spells ) ; user context . add feature change listener ( spells ) ; return container panel ; }	create the container panel ( right side panel ) , and its child components .
public void copy from geometry3 d ( d geom ) { this . m num indices = geom . get num indices ( ) ; this . m num vertices = geom . get num vertices ( ) ; this . m vertex buffer info = geom . get vertex buffer info ( ) ; this . m index buffer info = geom . get index buffer info ( ) ; this . m tex coord buffer info = geom . get tex coord buffer info ( ) ; this . m only short buffer supported = geom . are only short buffers supported ( ) ; if ( m colors == null ) this . m color buffer info = geom . get color buffer info ( ) ; this . m normal buffer info = geom . get normal buffer info ( ) ; this . m original geometry = geom ; this . m has normals = geom . has normals ( ) ; this . m has texture coordinates = geom . has texture coordinates ( ) ; }	copies another geometry3d ' s bufferinfo objects.
public static intent implicit2 explicit intent ( context context , intent implicit intent ) { package manager pm = context . get package manager ( ) ; list < resolve info > resolve info = pm . query intent services ( implicit intent , num ) ; if ( resolve info == null || resolve info . size ( ) != num ) { return null ; } resolve info service info = resolve info . get ( num ) ; string package name = service info . service info . package name ; string class name = service info . service info . name ; component name component = new component name ( package name , class name ) ; intent explicit intent = new intent ( implicit intent ) ; explicit intent . set component ( component ) ; return explicit intent ; }	android l ( lollipop , api 21 ) introduced a new problem when trying to invoke implicit intent , " java.
private synchronized void garbage collect peer ( peer peer ) { log . debug ( str + peer ) ; m current peers . remove ( peer ) ; }	invalidates a peer and removes it from the peermanager ' s list of current peers .
public void reset ( ) { synchronized ( this ) { queue . clear ( ) ; set bridge mode ( - num ) ; } }	clears all messages and resets to the default bridge mode .
@ post construct public void init application ( ) throws io { if ( env . get active profiles ( ) . length == num ) { log . warn ( str ) ; } else { log . info ( str , arrays . to string ( env . get active profiles ( ) ) ) ; } }	initializes csrs . < p / > spring profiles can be configured with a program arguments - - spring . profiles . active = your - active - profile < p / >.
private void indent ( ) { out . print ( current indention ) ; }	indent the current line.
private void compute implicit forward dependences use ( register r , dep graph node dest node ) { dep graph node source node = get dep graph node ( r ) ; if ( source node != null ) { for ( enumeration < register > e = generic physical def use . enumerate ( generic physical def use . get mask tsp ( ) , ir ) ; e . has more elements ( ) ; ) { register r2 = e . next element ( ) ; if ( r == r2 ) { source node . insert out edge ( dest node , reg may def ) ; return ; } } source node . insert out edge ( dest node , reg true ) ; } }	compute implicit forward dependences from a given register use to a given node .
public string description ( ) { synchronized ( this ) { if ( messages == null ) { messages = resource bundle . get bundle ( str ) ; } } return messages . get string ( str ) ; }	return localized description of this transport service.
set find removable aci list ( set aci list ) throws am , sso { set result set = new hash set ( ) ; if ( aci list == null ) { return result set ; } iterator iter = aci list . iterator ( ) ; while ( iter . has next ( ) ) { string aci = ( string ) iter . next ( ) ; set objs = ds services . search ( token , am . get am dn ( ) , str + am . get global search filter ( am . group ) + str + aci + str , am . scope sub ) ; if ( objs . size ( ) < num ) { result set . add ( aci ) ; } } return result set ; }	gets the dn : aci that is not shared by more that 1 role .
protected final void unregister data source ( data source removed ) { unregister data sources ( collections . singleton ( removed ) ) ; }	unregisters removed datasource from this provider .
public string dump ( byte [ ] der ) throws asn1 exception , io { try { as der object = as . from byte array ( der ) ; if ( der object . get encoded ( ) . length < der . length ) { throw new asn1 exception ( res . get string ( str ) ) ; } return dump ( der object ) ; } catch ( io ex ) { throw new asn1 exception ( res . get string ( str ) , ex ) ; } }	get dump of the supplied der encoded asn.
public static class need class ( string property ) throws no such property exception { string value = need property ( property ) ; class c = null ; try { c = class . for name ( value ) ; } catch ( class not found exception e ) { throw new no such property exception ( str + value + str + property + str ) ; } return c ; }	get a class property from the underlying properties , throwing an exception if it is not defined .
dependency spec create module dependency ( artifact result i , boolean force export ) { if ( jdk module names . contains ( i . name ( ) ) ) return jdk dependency ; final module identifier mi = create module identifier ( i ) ; final boolean export = force export || ( i . import type ( ) == import type . export ) ; return dependency spec . create module dependency spec ( path filters . get meta inf subdirectories without meta inf filter ( ) , ( export ? path filters . accept all ( ) : path filters . reject all ( ) ) , this , mi , i . import type ( ) == import type . optional ) ; }	create module dependency from import .
public void append nodes ( node set nodes ) { int n nodes = nodes . size ( ) ; if ( null == m map ) { m map size = n nodes + m blocksize ; m map = new node [ m map size ] ; } else if ( ( m first free + n nodes ) >= m map size ) { m map size += ( n nodes + m blocksize ) ; node new map [ ] = new node [ m map size ] ; system . arraycopy ( m map , num , new map , num , m first free + n nodes ) ; m map = new map ; } system . arraycopy ( nodes . m map , num , m map , m first free , n nodes ) ; m first free += n nodes ; }	append the nodes to the list .
private int read epoch ( file epoch file ) { int epoch = - num ; if ( ! epoch file . exists ( ) ) { return epoch ; } try { scanner scanner = new scanner ( epoch file ) ; epoch = scanner . next int ( ) ; log . debug ( str , epoch , epoch file . get name ( ) ) ; } catch ( io e ) { log . error ( str , epoch file . get name ( ) , e ) ; } return epoch ; }	read epoch from epoch file.
private int fast match ( string sha1 ) { integer idx = indexes . get ( sha1 ) ; if ( idx == null ) return - num ; else return idx . int value ( ) ; }	fast match - - lookup in the table .
public static void format ( string format , object ... args ) { if ( ! is disabled ( ) ) { print ( string . format ( format , args ) ) ; } }	prints a string formated as in string.
public void concatenate ( sip other list ) { super . concatenate ( other list ) ; }	append a given list to the end of this list .
public builder with key store password ( string trust store password ) { properties . set property ( netty options . ssl key store password , assert . not null ( trust store password , str ) ) ; return this ; }	sets the ssl key store password .
public static string suffix ( string string , string suffix ) { if ( string . ends with ( suffix ) == bool ) { string += suffix ; } return string ; }	appends suffix if doesn ' t exist .
public d ( double x , double y ) { if ( double . is infinite ( x ) || double . is infinite ( y ) ) throw new illegal argument exception ( str ) ; if ( double . is na n ( x ) || double . is na n ( y ) ) throw new illegal argument exception ( str ) ; if ( x == num ) this . x = num ; else this . x = x ; if ( y == num ) this . y = num ; else this . y = y ; }	initializes a new point ( x , y ) .
public static void server failed ( string service name ) { if ( service name . starts with ( valid remote url ) ) { server failed = bool ; } else { remote stubs . remove ( service name ) ; } }	sets the service to be failed .
public request handler ( pokemon go api , ok http client client ) { this . api = api ; this . client = client ; api endpoint = api settings . api endpoint ; async http thread = new thread ( this , str ) ; async http thread . set daemon ( bool ) ; async http thread . start ( ) ; }	instantiates a new request handler .
public string to string ( ) { string s = str ; enumeration names = get attribute names ( ) ; while ( names . has more elements ( ) ) { object key = names . next element ( ) ; object value = get attribute ( key ) ; if ( value instanceof attribute set ) { s = s + key + str ; } else { s = s + key + str + value + str ; } } return s ; }	converts the attribute set to a string .
public vn remove luns from consistency group ( string cg id , list < string > luns ) { lun group modify param param = new lun group modify param ( ) ; list < lun add param > lun removes = new array list < lun add param > ( ) ; for ( string lun id : luns ) { vn lun = new vn ( lun id ) ; lun add param lun add = new lun add param ( ) ; lun add . set lun ( lun ) ; lun removes . add ( lun add ) ; } param . set lun remove ( lun removes ) ; consistency group requests req = new consistency group requests ( kh client ) ; return req . modify consistency group sync ( cg id , param ) ; }	remove luns from the consistency group.
public void read data ( data input din ) throws io { status = din . read unsigned short ( ) ; events = din . read unsigned short ( ) ; }	readdata - - input the modbus message from din.
public void remove ( string identifier , active connection record record ) { synchronized ( records ) { set < active connection record > connections = records . get ( identifier ) ; assert ( connections != null ) ; connections . remove ( record ) ; if ( connections . is empty ( ) ) records . remove ( identifier ) ; } }	removes the given connection record from the list of active connections associated with the object having the given identifier .
private string build metro proint placement status string ( ) { string buffer placement status buf = new string buffer ( ) ; if ( placement status != null ) { placement status buf . append ( string . format ( str ) ) ; placement status buf . append ( placement status . to string ( db client ) ) ; } if ( secondary placement status != null ) { placement status buf . append ( string . format ( str ) ) ; placement status buf . append ( secondary placement status . to string ( db client ) ) ; } return placement status buf . to string ( ) ; }	builds the placementstatus string for metropoint.
private boolean has sequence ( subgraph graph ) { int odd degree count = num ; for ( iterator i = graph . node iterator ( ) ; i . has next ( ) ; ) { node node = ( node ) i . next ( ) ; if ( node . get degree ( ) % num == num ) odd degree count ++ ; } return odd degree count <= num ; }	tests whether a complete unique path exists in a graph using euler ' s theorem .
public void ensure additional capacity ( final int size ) { final int new count = visible . position ( ) + size ; if ( new count > visible . capacity ( ) ) { final byte buffer new byte buffer = byte buffer . allocate ( math . max ( visible . capacity ( ) << num , new count ) ) ; visible . flip ( ) ; visible = new byte buffer . put ( visible ) ; } }	ensures that the specified number of additional bytes will fit in the buffer and resizes it if necessary .
public void force reload ( file file ) { f files to reoad . add ( file ) ; }	adds the given indicator file to the list of files need to be reloaded .
private static long long multiply power ten ( long val , int n ) { if ( val == num || n <= num ) return val ; long [ ] tab = long ten powers table ; long [ ] bounds = thresholds table ; if ( n < tab . length && n < bounds . length ) { long tenpower = tab [ n ] ; if ( val == num ) return tenpower ; if ( math . abs ( val ) <= bounds [ n ] ) return val * tenpower ; } return inflated ; }	compute val * 10 ^ n ; return this product if it is representable as a long , inflated otherwise .
boolean compare methods ( @ nullable method a , @ nullable method b ) { if ( ( a == null ) != ( b == null ) ) { return bool ; } if ( a != null && b != null ) { if ( ! a . equals ( b ) ) { return bool ; } } return bool ; }	package private helper method for descriptor.
public object remove ( string markername ) { return prefix librarian . remove ( markername ) ; }	remove an object from the prefix librarian register , returning that object if it has been found .
string format last modified ( string file name ) { synchronized ( date format ) { return date format . format ( new date ( file utils . last modified ( file name ) ) ) ; } }	get the last modified date of a date and format it as required by the ftp protocol .
public true type font ( string platname , object native names , int f index , boolean java rasterizer , boolean use file pool ) throws font format exception { super ( platname , native names ) ; use java rasterizer = java rasterizer ; font rank = d . ttf rank ; try { verify ( use file pool ) ; init ( f index ) ; if ( ! use file pool ) { close ( ) ; } } catch ( throwable t ) { close ( ) ; if ( t instanceof font format exception ) { throw ( font format exception ) t ; } else { throw new font format exception ( str ) ; } } disposer . add object record ( this , disposer record ) ; }	- does basic verification of the file - reads the header table for this font ( within a collection ) - reads the names ( full , family ).
public logarithmic axis ( string label ) { super ( label ) ; setup number fmt obj ( ) ; }	creates a new axis .
protected final boolean has cycle recu ( set < brd item > p visited items , brd item p search item , brd item p come from item , boolean p ignore areas ) { if ( p ignore areas && ( this instanceof brd area conduction ) ) return bool ; collection < brd item > contact list = get normal contacts ( ) ; if ( contact list == null ) return bool ; for ( brd item curr contact : contact list ) { if ( curr contact == p come from item ) continue ; if ( curr contact == p search item ) return bool ; if ( ! p visited items . add ( curr contact ) ) continue ; if ( curr contact . has cycle recu ( p visited items , p search item , this , p ignore areas ) ) return bool ; } return bool ; }	recursive part of trace.
public static boolean is calling class reflection available ( ) { return bool ; }	determine whether or not the getcallingclass methods will return any sensible results.
private static string [ ] form grams ( string text , int ng ) { int len = text . length ( ) ; string [ ] res = new string [ len - ng + num ] ; for ( int i = num ; i < len - ng + num ; i ++ ) { res [ i ] = text . substring ( i , i + ng ) ; } return res ; }	form all ngrams for a given word .
public void load settings from json ( ) { synchronized ( lock ) { load settings from json ( default file ) ; for ( string file name : files ) { load settings from json ( file name ) ; } } }	loads the settings from a json file .
public void test flush ( ) throws exception { byte [ ] data = new byte [ ] { - num , - num , - num , - num , - num , num , num , num , num , num } ; test output stream tos = new test output stream ( ) ; cipher output stream cos = new cipher output stream ( tos ) { } ; cos . write ( data ) ; cos . flush ( ) ; byte [ ] result = tos . to byte array ( ) ; if ( ! arrays . equals ( result , data ) ) { fail ( str ) ; } }	flush ( ) method testing.
public void load train icons ( ) { for ( train train : get trains by id list ( ) ) { train . load train icon ( ) ; } }	loads train icons if needed.
public final string translate ( final char sequence input ) { if ( input == null ) { return null ; } try { final string writer writer = new string writer ( input . length ( ) * num ) ; translate ( input , writer ) ; return writer . to string ( ) ; } catch ( final io ioe ) { throw new runtime exception ( ioe ) ; } }	helper for non - writer usage .
public void insert reverse sorted ( final int idx , final double distance ) { int i = num ; for ( list node temp : m ) { if ( temp . distance < distance ) { break ; } i ++ ; } m . add ( i , new list node ( idx , distance ) ) ; }	inserts an element in reverse sorted order in the list .
public double normal distance ( final double x , final double y , final double z , final membership ... bounds ) { final double dist = evaluate ( x , y , z ) ; final double perp x = x - dist * this . x ; final double perp y = y - dist * this . y ; final double perp z = z - dist * this . z ; if ( ! meets all bounds ( perp x , perp y , perp z , bounds ) ) { return double . positive infinity ; } return math . abs ( dist ) ; }	compute normal distance from plane to a vector .
public void test b b ( ) throws exception { bridge brokers ( str , str , bool , num , bool ) ; bridge brokers ( str , str , bool , num , bool ) ; start all brokers ( ) ; wait for bridge formation ( ) ; destination dest = create destination ( str , bool ) ; hash map < string , object > props = new hash map < > ( ) ; props . put ( str , str ) ; send messages ( str , dest , message count , props ) ; props . clear ( ) ; props . put ( str , str ) ; send messages ( str , dest , message count , props ) ; message consumer client a = create consumer ( str , dest , str ) ; message consumer client c = create consumer ( str , dest , str ) ; thread . sleep ( num ) ; message id list msgs a = get consumer messages ( str , client a ) ; message id list msgs c = get consumer messages ( str , client c ) ; assert equals ( message count , msgs a . get message count ( ) ) ; assert equals ( message count , msgs c . get message count ( ) ) ; }	brokera < - brokerb - > brokerc.
public void access ( ) { last accessed time = system . current time millis ( ) ; }	updates this tunnel , marking it as recently accessed .
public void write to object ( object object ) { try { method method = bean utils . get write method ( object . get class ( ) , get name ( ) , get type ( ) ) ; if ( method != null ) { method . invoke ( object , new object [ ] { get value ( ) } ) ; } } catch ( exception e ) { throw new runtime exception ( e ) ; } }	writes the value of the property to the given object.
private url do http ( string location , string client session id , map < string , string > metadata , string post body ) throws communication exception { output stream writer writer = null ; try { url url = new url ( location ) ; url connection = ( url ) url . open connection ( ) ; connection . set request method ( str ) ; connection . add request property ( str , str ) ; if ( client session id != null ) { connection . add request property ( http header session id , str + client session id ) ; } if ( metadata != null ) { connection . add request property ( http header metadata , gc util . get base64 encoded metadata ( metadata ) ) ; } if ( constants . enable request logging ) { log request ( connection , post body ) ; } connection . set do output ( bool ) ; writer = new output stream writer ( connection . get output stream ( ) , str ) ; writer . write ( post body ) ; writer . flush ( ) ; if ( connection . get response code ( ) != num ) { throw new communication exception ( str + connection . get response code ( ) ) ; } return connection ; } catch ( url e ) { log . e ( tag , str + location ) ; throw new communication exception ( str + location ) ; } catch ( io e ) { log . e ( tag , str + e . get message ( ) ) ; throw new communication exception ( str + e . get message ( ) , e ) ; } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( io e ) { log . i ( tag , str + e . get message ( ) ) ; } } } }	does a post request with httpclient.
void io message ( throwable ex ) { log . print lines ( prefix kind . javac , str ) ; ex . print stack trace ( log . get writer ( writer kind . notice ) ) ; }	print a message reporting an input / output error .
public void run test ( ) throws throwable { document doc ; node list element list ; node name node ; character data child ; string substring ; doc = ( document ) load ( str , bool ) ; element list = doc . get elements by tag name ( str ) ; name node = element list . item ( num ) ; child = ( character data ) name node . get first child ( ) ; substring = child . substring data ( num , num ) ; assert equals ( str , str , substring ) ; }	runs the test case .
public static collection < uuid > node ids ( @ nullable collection < ? extends cluster node > nodes ) { if ( nodes == null || nodes . is empty ( ) ) return collections . empty list ( ) ; return f . view read only ( nodes , node2id ( ) ) ; }	convenient utility method that returns collection of node ids for a given collection of grid nodes.
public static input stream to input stream ( final char sequence input , final charset encoding ) { return io . to input stream ( input . to string ( ) , encoding ) ; }	convert the specified charsequence to an input stream , encoded as bytes using the specified character encoding .
public static boolean matches xml ( char [ ] buf , int off , int end , string str ) { int len = str . length ( ) ; if ( len != end - off ) return bool ; for ( int i = num ; i < len ; off += num , i ++ ) { if ( buf [ off ] != str . char at ( i ) ) return bool ; } return bool ; }	returns true if the specified char subarray is equal to the string.
public double r ( ) { return math . sqrt ( x * x + y * y ) ; }	returns the polar radius of this point .
public void sign ( key pair keypair ) throws io { if ( namelist . is empty ( ) ) { throw new illegal state exception ( str ) ; } if ( keypair == null ) { throw new illegal argument exception ( str ) ; } try { general name [ ] gns = new general name [ namelist . size ( ) ] ; for ( int ix = num ; ix < namelist . size ( ) ; ix ++ ) { gns [ ix ] = new general name ( general name . d ns , namelist . get ( ix ) ) ; } general names subject alt name = new general names ( gns ) ; pkc p10 builder = new pkc ( namebuilder . build ( ) , keypair . get public ( ) ) ; extensions generator extensions generator = new extensions generator ( ) ; extensions generator . add extension ( extension . subject alternative name , bool , subject alt name ) ; p10 builder . add attribute ( pkcs . pkcs 9 at extension request , extensions generator . generate ( ) ) ; private key pk = keypair . get private ( ) ; jca content signer builder cs builder = new jca content signer builder ( pk instanceof ec ? ec signature alg : signature alg ) ; content signer signer = cs builder . build ( pk ) ; csr = p10 builder . build ( signer ) ; } catch ( operator creation exception ex ) { throw new io ( str , ex ) ; } }	signs the completed csr .
void remove empty rows ( final list list ) { for ( final iterator < receipt detail info > detail = list . iterator ( ) ; detail . has next ( ) ; ) if ( detail . next ( ) == null ) detail . remove ( ) ; }	removes the empty rows .
private void add ( string text , text text node ) { int start index = builder . length ( ) ; builder . append ( text ) ; int end index = builder . length ( ) ; text runs . add ( new text run ( text node , start index , end index ) ) ; }	here we add a textnode and its postion to a list.
public d ( j parent ) { super ( parent ) ; set title ( res . get string ( str ) ) ; init components ( ) ; }	creates a new dnetscapebaseurl dialog .
private void read object ( object input stream s ) throws io , class not found exception { s . default read object ( ) ; init ( get name ( ) ) ; }	readobject is called to restore the state of the basicpermission from a stream .
public void append row ( row spec row spec ) { check not null ( row spec , str ) ; row specs . add ( row spec ) ; }	appends the given row specification to the bottom of all rows .
public static < t > reactive seq < t > from publisher ( final publisher < ? extends t > publisher ) { objects . require non null ( publisher ) ; final seq subscriber < t > sub = seq subscriber . subscriber ( ) ; publisher . subscribe ( sub ) ; return sub . stream ( ) ; }	construct a reactiveseq from an publisher.
public void multiply all values by ( final double multiply by , final int round type ) { for ( final t t : key set ( ) ) { double val = m values . get ( t ) ; switch ( round type ) { case num : val = math . floor ( val * multiply by ) ; break ; case num : val = math . round ( val * multiply by ) ; break ; case num : val = math . ceil ( val * multiply by ) ; break ; default : val = val * multiply by ; break ; } put ( t , ( int ) val ) ; } }	will multiply all values by a given double.
public void on tabs all closing ( long time , boolean incognito ) { }	called when all the tabs in the current stack need to be closed.
public final test subscriber < t > await ( duration timeout ) { if ( cdl . get count ( ) == num ) { return this ; } try { if ( ! cdl . await ( timeout . to millis ( ) , time unit . milliseconds ) ) { throw new assertion error ( str ) ; } return this ; } catch ( interrupted exception ex ) { throw new assertion error ( str , ex ) ; } }	blocking method that waits until a complete successfully or error signal is received or until a timeout occurs .
protected void paint content border bottom edge ( graphics g , int tab placement , int selected index , int x , int y , int w , int h ) { boolean left to right = compiere utils . is left to right ( tab pane ) ; int bottom = y + h - num ; int right = x + w - num ; rectangle sel rect = selected index < num ? null : get tab bounds ( selected index , calc rect ) ; g . set color ( shadow ) ; if ( tab placement != bottom || selected index < num || ( sel rect . x < x || sel rect . x > x + w ) ) { g . set color ( dark shadow ) ; g . draw line ( x , y + h - num , x + w - num , y + h - num ) ; } else { boolean last in run = is last in run ( selected index ) ; g . set color ( dark shadow ) ; if ( left to right || last in run ) g . draw line ( x , bottom , sel rect . x , bottom ) ; else g . draw line ( x , bottom , sel rect . x - num , bottom ) ; if ( sel rect . x + sel rect . width < x + w - num ) { if ( left to right && ! last in run ) g . draw line ( sel rect . x + sel rect . width , bottom , right , bottom ) ; else g . draw line ( sel rect . x + sel rect . width - num , bottom , right , bottom ) ; } } }	paint bottom content area edge.
public static void upto ( double self , number to , @ closure params ( first param . class ) closure closure ) { double to1 = to . double value ( ) ; if ( self <= to1 ) { for ( double i = self ; i <= to1 ; i ++ ) { closure . call ( i ) ; } } else throw new groovy runtime exception ( str + to + str + self + str ) ; }	iterates from this number up to the given number , inclusive , incrementing by one each time .
public void save ( string type , list < elastic search doc > docs ) { if ( docs != null && ! docs . is empty ( ) ) { list < list < elastic search doc > > partitioned docs = lists . partition ( docs , num ) ; partitioned docs . for each ( null ) ; } }	bulk save of the entities.
public void error ( source locator src lctr , string msg ) throws transformer exception { error ( src lctr , null , null , msg , null ) ; }	tell the user of an error , and probably throw an exception .
void remove listener ( string listener id ) { if ( listener objects != null ) { synchronized ( listener objects ) { listener objects . remove ( listener id ) ; if ( listener objects . is empty ( ) ) { deregister listener ( ) ; } } if ( debug . message enabled ( ) ) { debug . message ( str + service name + str + listener id ) ; } } }	unregisters the listener from the service for the given listener id.
@ deprecated public void register credentials ( user credential authentication ) { wallet . put ( authentication . get url ( ) , authentication ) ; }	adds the given credentials .
public void test database driver properties user and password property override ds ( ) { string driver property string = str ; properties props = new properties ( ) ; props . set property ( datasource property set . username , str ) ; props . set property ( datasource property set . password , str ) ; props . set property ( datasource property set . connection properties , driver property string ) ; data source ds = data source converter . from properties ( props ) ; assert equals ( str , ds . get username ( ) ) ; assert equals ( str , ds . get password ( ) ) ; }	test the driver properties when the username and the password is set on datasource .
public boolean is agc ( ) { return m agc . get ( ) ; }	indicates if agc is enabled.
protected linked list < string > split into allophones ( string phone string ) { linked list < string > phone list = new linked list < string > ( ) ; for ( int i = num ; i < phone string . length ( ) ; i ++ ) { string name = null ; for ( int j = num ; j >= num ; j -- ) { if ( i + j <= phone string . length ( ) ) { string candidate = phone string . substring ( i , i + j ) ; if ( get allophone ( candidate ) != null ) { name = candidate ; i += j - num ; break ; } } } if ( name != null ) { phone list . add ( name ) ; } } return phone list ; }	convert a phone string into a list of string representations of individual phones.
private boolean execute ( boolean read response ) throws io { try { http engine . send request ( ) ; if ( read response ) { http engine . read response ( ) ; } return bool ; } catch ( io e ) { if ( handle failure ( e ) ) { return bool ; } else { throw e ; } } }	sends a request and optionally reads a response.
public bigdata sail ( final properties properties ) { this ( properties . get property ( options . namespace , options . default namespace ) , new journal ( properties ) ) ; close on shutdown = bool ; if ( ! exists ( ) ) { try { create ( properties ) ; } catch ( interrupted exception | execution exception e ) { throw new runtime exception ( e ) ; } } }	create or open a database instance configured using the specified properties .
public float convert ( ) { return float . int bits to float ( ( int ) bytes ) ; }	converts the internal representation to an actual float .
public file process controller ( final file controller parameters arguments , final int pid ) { this ( arguments , pid , long . get long ( status timeout property , num * num ) , time unit . milliseconds ) ; }	constructs an instance for controlling a local process .
public void test add certificate2 ( ) throws exception { identity i = new identity stub ( str ) ; public key stub pk1 = new public key stub ( str , str , null ) ; certificate stub c1 = new certificate stub ( str , null , null , pk1 ) ; i . add certificate ( c1 ) ; assert same ( c1 , i . certificates ( ) [ num ] ) ; assert same ( pk1 , i . get public key ( ) ) ; }	verify addcertificate ( certificate certificate ) adds a certificate for this identity.
protected set < future < void > > send ( string channel id , object message ) { collection < session > sessions = ( channel id != null ) ? socket sessions . get ( channel id ) : null ; if ( sessions != null && ! sessions . is empty ( ) ) { set < future < void > > results = new hash set < > ( sessions . size ( ) ) ; string json = json . encode ( message ) ; for ( session session : sessions ) { if ( session . is open ( ) ) { send ( session , json , results ) ; } } return results ; } return empty set ( ) ; }	encode the given message object as json and send it to all open web socket sessions associated with given web socket channel identifier .
public object attribute ( object key ) { return ( attributes != null ) ? attributes . get ( key ) : null ; }	provides lookup of attributes by key .
public response do put ( string url ) { return do put ( url , null ) ; }	does a http put with an empty body.
private static pair < string , string > offset rrx ( final long offset , final i environment , final list < reil instruction > instructions , final string register node value1 , final string register node value2 ) { final string address = environment . get next variable string ( ) ; final string index = environment . get next variable string ( ) ; final string tmp var = environment . get next variable string ( ) ; final string tmp var1 = environment . get next variable string ( ) ; final string tmp var2 = environment . get next variable string ( ) ; final string tmp var3 = environment . get next variable string ( ) ; long base offset = offset ; instructions . add ( reil helpers . create bsh ( base offset ++ , bt , str , wd , string . value of ( num ) , dw , tmp var1 ) ) ; instructions . add ( reil helpers . create bsh ( base offset ++ , dw , register node value2 , bt , string . value of ( - num ) , dw , tmp var2 ) ) ; instructions . add ( reil helpers . create or ( base offset ++ , dw , tmp var1 , dw , tmp var2 , dw , tmp var3 ) ) ; instructions . add ( reil helpers . create and ( base offset ++ , dw , tmp var3 , dw , d word bit mask , dw , index ) ) ; instructions . add ( reil helpers . create add ( base offset ++ , dw , register node value1 , dw , index , dw , tmp var ) ) ; instructions . add ( reil helpers . create and ( base offset ++ , dw , tmp var , dw , d word bit mask , dw , address ) ) ; return new pair < string , string > ( address , register node value1 ) ; }	operation : [ < rn > , + / - < rm > , rrx ] 0b11 / ror or rrx / if shift_imm = = 0 then / rrx / index = ( c flag logical_shift_left 31 ) or ( rm logical_shift_right 1 ) else / ror / index = rm rotate_right shift_imm endcase if u = = 1 then address = rn + index else / u = = 0 / address = rn - index.
public void unregister drop controllers ( ) { drop controller list . clear ( ) ; }	unregister all dropcontrollers from this drag controller .
private static long v ( jni env , int class jref , int method id , address arg address ) throws exception { if ( trace jni ) vm . sys write ( str ) ; runtime entrypoints . check jni gc ( ) ; try { object return obj = jni . invoke with var arg ( method id , arg address , type reference . long ) ; return reflection . unwrap long ( return obj ) ; } catch ( throwable unexpected ) { if ( trace jni ) unexpected . print stack trace ( system . err ) ; env . record exception ( unexpected ) ; return num ; } }	callstaticlongmethodv : invoke a static method that returns a long value.
public int size ( ) { return segments . size ( ) ; }	number of segments in the corpus .
public void add operand ( int start tick , int end tick , string text , lifeline constraint lifeline ) throws sequence diagram checked exception { if ( operands . size ( ) == num && this . start tick != start tick ) { throw new illegal argument exception ( str ) ; } operands . add ( new operand ( start tick , end tick , text , constraint lifeline ) ) ; }	adds an operand with an interaction constraint to the combined fragment .
public static number asin ( number a ) { return math . asin ( a . double value ( ) ) ; }	returns the arc sine of the number .
private void create and attach event ( long ov ) throws windows exception { long h event = create event ( bool , bool ) ; unsafe . put address ( ov + offsetof hevent , h event ) ; }	creates an unnamed event and set it as the hevent field in the given overlapped structure.
public string to string ( ) { string buffer result = new string buffer ( ) ; result . append ( str ) ; int s1 = sizes . size ( ) ; for ( int i = num ; i < s1 ; ++ i ) { int s2 = sizes . get ( i ) ; result . append ( str ) ; for ( int j = num ; j < s2 ; ++ j ) { result . append ( vector [ i ] [ j ] ) ; if ( j + num < s2 ) result . append ( str ) ; } result . append ( str ) ; if ( i + num < s1 ) result . append ( str ) ; } result . append ( str ) ; return result . to string ( ) ; }	returns a text representation of this vector .
@ override public int compare to ( string o ) { int result ; int major ; int minor ; int revision ; int pnt ; int [ ] maj = new int [ num ] ; int [ ] min = new int [ num ] ; int [ ] rev = new int [ num ] ; int [ ] point = new int [ num ] ; parse version ( o , maj , min , rev , point ) ; major = maj [ num ] ; minor = min [ num ] ; revision = rev [ num ] ; pnt = point [ num ] ; if ( major < major ) { result = - num ; } else if ( major == major ) { if ( minor < minor ) { result = - num ; } else if ( minor == minor ) { if ( revision < revision ) { result = - num ; } else if ( revision == revision ) { if ( point < pnt ) { result = - num ; } else if ( point == pnt ) { result = num ; } else { result = num ; } } else { result = num ; } } else { result = num ; } } else { result = num ; } return result ; }	checks the version of this class against the given version - string.
private void generate integrity key pair ( boolean client mode ) throws unsupported encoding exception , io , no such algorithm exception { byte [ ] cimagic = client int magic . get bytes ( encoding ) ; byte [ ] simagic = svr int magic . get bytes ( encoding ) ; message digest md5 = message digest . get instance ( str ) ; byte [ ] key buffer = new byte [ h . length + cimagic . length ] ; system . arraycopy ( h , num , key buffer , num , h . length ) ; system . arraycopy ( cimagic , num , key buffer , h . length , cimagic . length ) ; md5 . update ( key buffer ) ; byte [ ] kic = md5 . digest ( ) ; system . arraycopy ( simagic , num , key buffer , h . length , simagic . length ) ; md5 . update ( key buffer ) ; byte [ ] kis = md5 . digest ( ) ; if ( logger . is loggable ( level . finer ) ) { trace output ( di class name , str , str , kic ) ; trace output ( di class name , str , str , kis ) ; } if ( client mode ) { my ki = kic ; peer ki = kis ; } else { my ki = kis ; peer ki = kic ; } }	generate client - server , server - client key pairs for digest - md5 integrity checking .
public static boolean is local file uri ( uri uri ) { final string scheme = get scheme or null ( uri ) ; return local file scheme . equals ( scheme ) ; }	check if uri represents local file.
completable future < write response > write ( list < write value > write values ) ;	this service is used to write values to one or more attributes of one or more nodes .
public static boolean valid system name config ( string system name , char type ) { if ( ! valid system name format ( system name , type ) ) { return bool ; } int bit = get bit from system name ( system name ) ; if ( ( type == str ) || ( type == str ) ) { if ( ( bit <= num ) || ( bit > output bits . get num output bits ( ) ) ) { return bool ; } } else if ( type == str ) { if ( ( bit <= num ) || ( bit > input bits . get num input bits ( ) ) ) { return bool ; } } else { log . error ( str ) ; return bool ; } return bool ; }	public static method to validate system name for configuration returns ' true ' if system name has a valid meaning in current configuration , else returns ' false '.
public boolean mouse moved ( mouse event e ) { esri graphic list list = get esri graphic list ( ) ; boolean ret = bool ; if ( list != null ) { om omg = list . find closest ( e . get x ( ) , e . get y ( ) , num ) ; if ( omg != null ) { int index ; integer i = ( ( integer ) omg . get attribute ( shape index attribute ) ) ; if ( i != null ) { index = i . int value ( ) ; } else { index = list . index of ( omg ) ; } if ( parent layer == null ) { component comp = get component ( ) ; if ( comp instanceof layer ) { parent layer = ( layer ) comp ; } } if ( parent layer != null ) { parent layer . fire request tool tip ( get description ( index ) ) ; } ret = bool ; } else if ( parent layer != null ) { parent layer . fire hide tool tip ( ) ; } } return ret ; }	handle mouse moved events ( used for firing tool tip descriptions over graphics ).
public format exception ( string s , throwable root cause ) { super ( s + str + root cause . get localized message ( ) ) ; this . root cause = root cause ; }	construct a formatexception with a detail message and root cause .
private pair < big decimal , big decimal > fill payment ( final customer order order , final customer order delivery delivery , final payment payment , final boolean single pay , final big decimal running total , final big decimal running total tax , final boolean last delivery ) { if ( payment . get transaction reference id ( ) == null ) { payment . set transaction reference id ( delivery . get delivery num ( ) ) ; } payment . set order shipment ( single pay ? order . get ordernum ( ) : delivery . get delivery num ( ) ) ; fill payment items ( delivery , payment ) ; fill payment shipment ( order , delivery , payment ) ; return fill payment amount ( order , delivery , payment , single pay , running total , running total tax , last delivery ) ; }	fill single payment with data.
void materialize ( ) { if ( cachefill < num ) { return ; } double min = double . max value , max = double . min value ; for ( int i = num ; i < cachefill ; i ++ ) { min = math . min ( min , cachec [ i ] ) ; max = math . max ( max , cachec [ i ] ) ; } linear scale scale = new linear scale ( min , max ) ; min = scale . get min ( ) ; max = scale . get max ( ) ; this . base = min ; this . max = max ; this . binsize = ( max - min ) / this . destsize ; this . data = new float [ this . destsize << num ] ; size = destsize ; final int end = cachefill ; cachefill = - num ; for ( int i = num ; i < end ; i ++ ) { increment ( cachec [ i ] , cachev [ i ] ) ; } cachec = null ; cachev = null ; }	materialize the histogram from the cache .
public boolean build host part ( appendable buffer , string url , boolean use ssl ) throws web app configuration exception , io { return build host part ( buffer , url , use ssl , bool ) ; }	builds a partial url - including the scheme and host , but not the servlet path or resource.
public static < t > list < t > shift elements to end ( final list < t > source , final int count ) { final array list < t > r val = new array list < > ( source . size ( ) ) ; for ( int i = count ; i < source . size ( ) ; i ++ ) { r val . add ( source . get ( i ) ) ; } for ( int i = num ; i < count ; i ++ ) { r val . add ( source . get ( i ) ) ; } if ( source . size ( ) != r val . size ( ) ) { throw new illegal state exception ( str + count + str + source + str + r val ) ; } return r val ; }	returns a list of everything in source , with the first count units moved to the end.
private boolean is leaf page ( byte buffer buffer ) throws io { byte page type = buffer . get ( num ) ; if ( page type == page types . index leaf ) { return bool ; } else if ( page type == page types . index node ) { return bool ; } throw new io ( with error context ( str + page type ) ) ; }	determines if the given index page is a leaf or node page .
public void add js lib files ( file ... files ) { js lib files . add all ( arrays . as list ( files ) ) ; }	add javascript libraries that are used for the javascript evaluation .
public void test write offset ( ) { int len = num ; int data len = num ; byte [ ] src data = get w ( data len ) ; byte [ ] data = new byte [ data len ] ; int n offset = num ; byte fifo buffer instance = new byte fifo buffer ( len ) ; int result = instance . write offset ( src data , data len , n offset ) ; int read count = instance . read offset ( data , num , data len , n offset ) ; assert equals ( result , read count ) ; assert array equals ( src data , data ) ; byte [ ] half filled = new byte [ data len * num ] ; system . arraycopy ( src data , num , half filled , data len , data len ) ; byte [ ] half filled read = new byte [ data len * num ] ; instance . read offset ( half filled read , data len , data len , n offset ) ; assert array equals ( half filled , half filled read ) ; instance = new byte fifo buffer ( len ) ; instance . write ( src data , data len ) ; instance . write ( src data , data len / num ) ; instance . read ( data , data len ) ; instance . write offset ( src data , data len , num ) ; instance = new byte fifo buffer ( num ) ; instance . write offset ( get w ( num ) , num , num ) ; }	test of writeoffset method , of class bytefifobuffer .
private void init properties if necessary ( ) { if ( timer == null ) { toolkit t = toolkit . get default toolkit ( ) ; integer prop ; prop = ( integer ) t . get desktop property ( str ) ; timer = new timer ( prop == null ? num : prop . int value ( ) , this ) ; prop = ( integer ) t . get desktop property ( str ) ; timer . set initial delay ( prop == null ? num : prop . int value ( ) ) ; prop = ( integer ) t . get desktop property ( str ) ; if ( prop != null ) { hysteresis = prop . int value ( ) ; } } }	initializes the internal properties if they haven ' t been already inited.
public e load model ( string filename , string cwd ) { uri file uri = normalize uri ( uri . create uri ( filename ) ) ; uri cwd uri = normalize uri ( uri . create uri ( cwd ) ) ; return load model ( file uri , cwd uri ) ; }	load the model found in the filename.
static boolean path is windows ( string path ) { if ( path != null && path . length ( ) > num ) { return ( character . is letter ( path . char at ( num ) ) && path . char at ( num ) == str ) || ( path . starts with ( str ) || path . starts with ( str ) ) ; } return bool ; }	returns true if the path is on windows .
public static boolean is test server ( ) { return system . get property ( test server only . test server property ) != null ; }	determines if the current running server is a testserver.
@ suppress warnings ( str ) private < t > string generate test file ( string filename , list < t > elems , avro coder < t > coder , string codec ) throws io { file tmp file = tmp folder . new file ( filename ) ; string path = tmp file . to string ( ) ; file output stream os = new file output stream ( tmp file ) ; datum writer < t > datum writer = coder . create datum writer ( ) ; try ( data file writer < t > writer = new data file writer < > ( datum writer ) ) { writer . set codec ( codec factory . from string ( codec ) ) ; writer . create ( coder . get schema ( ) , os ) ; for ( t elem : elems ) { writer . append ( elem ) ; } } return path ; }	generates an input avro file containing the given records in the temporary directory and returns the full path of the file .
public void notify returned ( notify context notify context , i template ) { if ( notify context == null ) return ; if ( filter manager . is filter [ filter operation codes . after notify trigger ] ) { object [ ] entries = new object [ num ] ; entries [ num ] = notify context . get entry ( ) ; entries [ num ] = template ; try { filter manager . invoke filters ( filter operation codes . after notify trigger , null , entries ) ; } catch ( exception e ) { if ( logger . is loggable ( level . fine ) ) logger . log ( level . fine , str , e ) ; } } decrease counter ( notify context ) ; }	called when a notification returned.
public static string normalize slashes ( string path ) { return path . replace all ( str , str ) ; }	replace ' \ ' with ' / ' from the given path because tsserver normalize it like this .
protected d correct ( d anchor , d bounds ) { if ( anchor == null ) return anchor ; double x = anchor . get x ( ) , y = anchor . get y ( ) ; double x1 = bounds . get min x ( ) , y1 = bounds . get min y ( ) ; double x2 = bounds . get max x ( ) , y2 = bounds . get max y ( ) ; x = ( x < x1 ? x1 : ( x > x2 ? x2 : x ) ) ; y = ( y < y1 ? y1 : ( y > y2 ? y2 : y ) ) ; m tmp . set location ( x , y ) ; return m tmp ; }	corrects the anchor position , such that if the anchor is outside the layout bounds , the anchor is adjusted to be the nearest point on the edge of the bounds .
protected boolean load field ( ddf record , string tag name , int field index ) { if ( fields . get ( tag name ) == null ) { ddf ddf = record . find field ( tag name , field index ) ; if ( ddf != null ) { fields . put ( tag name , ddf ) ; ddf . to string ( ) ; return bool ; } } return bool ; }	if a field has not been loaded , load it from the ddfrecord if it exists and add it to the master field hashtable .
public http request ( final char sequence url , final string method ) throws http request exception { try { this . url = new url ( url . to string ( ) ) ; } catch ( url e ) { throw new http request exception ( e ) ; } this . request method = method ; }	create http connection wrapper.
private boolean is error ( i problem , type type ) { return bool ; }	decides if a problem matters .
@ suppress warnings ( { str , str } ) public record set page ( input input ) { deserializer deserizalizer = new deserializer ( ) ; map map result = deserizalizer . deserialize ( input , map . class ) ; cursor = ( integer ) map result . get ( str ) ; data = ( list < list < object > > ) map result . get ( str ) ; }	creates recordset page from input object.
public optional < string > endpoint ( ) { return optional . of nullable ( endpoint arg ) ; }	returns the endpoint string.
public void test collisions ( ) throws exception { map < integer , set < uuid > > map = new hash map < > ( ) ; collection < uuid > nodes = new linked hash set < > ( ) ; while ( nodes . size ( ) < num ) { uuid uuid = uuid . random uuid ( ) ; int hash code = uuid . hash code ( ) ; set < uuid > set = map . get ( hash code ) ; if ( set == null ) map . put ( hash code , set = new linked hash set < > ( ) ) ; set . add ( uuid ) ; if ( set . size ( ) > num ) nodes . add all ( set ) ; } map . clear ( ) ; grid client consistent hash < uuid > hash = new grid client consistent hash < > ( ) ; hash . add nodes ( nodes , replicas ) ; boolean fail = bool ; for ( uuid exp : nodes ) { uuid act = hash . node ( num , arrays . as list ( exp ) ) ; if ( exp . equals ( act ) ) info ( str + exp + str + act + str ) ; else { info ( str + exp + str + act + str ) ; fail = bool ; } } if ( fail ) fail ( str + nodes ) ; }	test hash codes collisions .
void send message to handler with controller reset ( list < of > messages ) throws exception { send message to handler no controller reset ( messages ) ; }	reset , setup , and replay the messageevent mock for the given messages , mock controller send message to channel handler this method will reset , start replay on controller , and then verify.
public boolean is redeploy mode ( ) { return scenario . equals ( property constants . redeploy mode ) ? bool : bool ; }	check if installer is running at redeploy mode .
public static rsa load from key store ( url keystore url , string password ) throws io , no such algorithm exception , certificate exception , key store exception , unrecoverable key exception { logger . debug ( str , keystore url ) ; url connection = keystore url . open connection ( ) ; input stream is = connection . get input stream ( ) ; try { if ( logger . is debug enabled ( ) ) logger . debug ( str , arrays . to string ( security . get providers ( ) ) ) ; key store key store ; try { try { key store = key store . get instance ( str , str ) ; } catch ( no such provider exception e ) { key store = key store . get instance ( str , crypto util . get security provider name ( key store . class ) ) ; } } catch ( no such provider exception e ) { key store = key store . get instance ( str ) ; } logger . debug ( str , key store . get provider ( ) ) ; key store . load ( is , password == null ? null : password . to char array ( ) ) ; enumeration < string > aliases = key store . aliases ( ) ; key key = null ; while ( aliases . has more elements ( ) ) { string a = ( string ) aliases . next element ( ) ; key = key store . get key ( a , password == null ? null : password . to char array ( ) ) ; } return ( rsa ) key ; } finally { is . close ( ) ; } }	load private key from a key store.
@ override public double conf small m ( double total example weight , double delta ) { double term = math . log ( num / delta ) / ( num * total example weight ) ; return math . sqrt ( term ) + math . pow ( term , num ) + math . pow ( term , num ) ; }	calculate confidence intervall without a specific rule for small m .
public static < t > boolean contains ( iterator < t > iterator , t element ) { if ( iterator != null ) { while ( iterator . has next ( ) ) { t candidate = iterator . next ( ) ; if ( object utils . null safe equals ( candidate , element ) ) return bool ; } } return bool ; }	check whether the given iterator contains the given element .
public void test constructor6 ( ) { integer [ ] ints = new integer [ size ] ; for ( int i = num ; i < size ; ++ i ) ints [ i ] = new integer ( i ) ; linked blocking queue q = new linked blocking queue ( arrays . as list ( ints ) ) ; for ( int i = num ; i < size ; ++ i ) assert equals ( ints [ i ] , q . poll ( ) ) ; }	queue contains all elements of collection used to initialize.
@ override public void draw domain gridline ( d g2 , category plot plot , d data area , double value ) { d line = null ; plot orientation orientation = plot . get orientation ( ) ; if ( orientation == plot orientation . horizontal ) { line = new d . double ( data area . get min x ( ) , value , data area . get max x ( ) , value ) ; } else if ( orientation == plot orientation . vertical ) { line = new d . double ( value , data area . get min y ( ) , value , data area . get max y ( ) ) ; } paint paint = plot . get domain gridline paint ( ) ; if ( paint == null ) { paint = category plot . default gridline paint ; } g2 . set paint ( paint ) ; stroke stroke = plot . get domain gridline stroke ( ) ; if ( stroke == null ) { stroke = category plot . default gridline stroke ; } g2 . set stroke ( stroke ) ; g2 . draw ( line ) ; }	draws a grid line against the domain axis.
public void add pre built classifier ( classifier c ) { m pre built classifiers . add ( c ) ; }	add a prebuilt classifier to the list for use in the ensemble.
@ override public insn list generate ( ) { return merge ( generated instructions . to array ( ) ) ; }	generate final instruction list .
public static void put java variables into engine ( final script engine engine , final map < string , object > variables ) { final bindings bindings = new simple bindings ( ) ; for ( string key : variables . key set ( ) ) { bindings . put ( key , variables . get ( key ) ) ; } engine . set bindings ( bindings , script context . engine scope ) ; }	puts a the given map of variables into the engine .
public void delete with missing ( attribute att ) { delete with missing ( att . index ( ) ) ; }	removes all instances with missing values for a particular attribute from the dataset .
protected void sprint ( string a ) { if ( a == null ) { string representation += get indentation ( ) ; string representation += str ; return ; } if ( a . compare to ( str ) == num || a . compare to ( str ) == num ) { indentation -- ; } string representation += get indentation ( ) ; string representation += a ; string representation += str ; if ( a . compare to ( str ) == num || a . compare to ( str ) == num ) { indentation ++ ; } }	add a new string to the accumulated string representation .
public static java . sql . date to sql date ( string month str , string day str , string year str ) { java . util . date new date = to date ( month str , day str , year str , str , str , str ) ; if ( new date != null ) { return new java . sql . date ( new date . get time ( ) ) ; } else { return null ; } }	makes a java . sql . date from separate strings for month , day , year.
protected void save png ( string filename , buffered image image ) throws io { file file = new file ( filename ) ; io . write ( image , str , file ) ; }	saves an image as png .
public void unset permission ( string name ) { permissions . remove ( name . to lower case ( java . util . locale . english ) ) ; permissible . recalculate permissions ( ) ; }	removes the specified permission from this attachment.
public void before insert ( int index , byte element ) { if ( index > size || index < num ) throw new index out of bounds exception ( str + index + str + size ) ; ensure capacity ( size + num ) ; system . arraycopy ( elements , index , elements , index + num , size - index ) ; elements [ index ] = element ; size ++ ; }	inserts the specified element before the specified position into the receiver.
public om read cached graphics ( url url ) throws java . io . io { if ( debug . debugging ( str ) ) { debug . output ( str ) ; } om omgraphics = new om ( ) ; if ( url != null ) { omgraphics . read graphics ( url ) ; } return omgraphics ; }	read a cache of omgraphics.
int size ( ) { return nox items . size ( ) ; }	returns the number of nox items to be loaded .
public < v > future < v > invoke ( string method , string path , map < string , ? > arguments , result handler < v > result handler ) { if ( method == null ) { throw new illegal argument exception ( ) ; } if ( path == null ) { throw new illegal argument exception ( ) ; } if ( arguments == null ) { throw new illegal argument exception ( ) ; } return executor service . submit ( new invocation callback < > ( method , path , arguments , result handler ) ) ; }	executes a service operation .
@ override public string replace path ( string input uri ) { if ( input uri . contains ( temporary directory manager . directory template ) ) { return input uri . replace ( temporary directory manager . directory template , template directory name ) ; } return input uri ; }	this method replaces ( if found ) the sub - string [ unique ] in any input string with the value template .
@ override public void create ( ) { assert writable ( ) ; final string name = get namespace ( ) + str + name search ; final i index manager = get index manager ( ) ; final properties p = get properties ( ) ; final index metadata index metadata = new index metadata ( index manager , p , name , uuid . random uuid ( ) , index type enum . b ) ; final i key builder factory ; { final properties tmp = new properties ( p ) ; tmp . set property ( key builder . options . strength , p . get property ( options . indexer collator strength , options . default indexer collator strength ) ) ; key builder factory = new default key builder factory ( tmp ) ; } final boolean fields enabled = boolean . parse boolean ( p . get property ( options . fields enabled , options . default fields enabled ) ) ; if ( log . is info enabled ( ) ) log . info ( options . fields enabled + str + fields enabled ) ; index metadata . set tuple serializer ( new full text index tuple serializer < v > ( key builder factory , default tuple serializer . get default leaf keys coder ( ) , empty raba value coder . instance , fields enabled ) ) ; index manager . register index ( index metadata ) ; if ( log . is info enabled ( ) ) log . info ( str + name ) ; }	conditionally registers the necessary index ( s ) .
public static pgp merge signatures ( pgp target key , pgp source key ) throws pgp { if ( ! objects . deep equals ( target key . get fingerprint ( ) , source key . get fingerprint ( ) ) ) { throw new illegal argument exception ( str ) ; } return copy signatures ( target key , source key ) ; }	returns a public key containing signatures of two keys .
public static double info ( int counts [ ] ) { int total = num ; double x = num ; for ( int j = num ; j < counts . length ; j ++ ) { x -= xlogx ( counts [ j ] ) ; total += counts [ j ] ; } return x + xlogx ( total ) ; }	computes entropy for an array of integers .
public compute job failover exception ( throwable cause ) { this ( cause . get message ( ) , cause ) ; }	creates new given throwable as a cause and source of error message .
public boolean has newer version ( ) { return latest stable . compare to ( current version ) > num ; }	compares if there is a newer version available .
@ override public void read nbt ( nbt compound ) { super . read nbt ( compound ) ; if ( compound . has key ( str ) ) { this . exhaustion timer = compound . get integer ( str ) ; } if ( ! compound . has key ( str ) ) { set food level ( get food level ( ) * num ) ; set saturation ( num ) ; } if ( get food level ( ) > num ) set food level ( num ) ; if ( get saturation level ( ) > num ) set saturation ( num ) ; }	reads the food data for the player .
private static boolean verify xml ( string file name ) { schema factory sf = schema factory . new instance ( c xml schema ) ; source xsd file = new stream source ( new file ( xsd file path ) ) ; source xml file = new stream source ( new file ( file name ) ) ; boolean valid xml = bool ; try { schema schema = sf . new schema ( xsd file ) ; validator validator = schema . new validator ( ) ; try { validator . validate ( xml file ) ; valid xml = bool ; } catch ( io e ) { e . print stack trace ( ) ; } if ( ! valid xml ) { new io ( str ) ; } } catch ( sax e ) { e . print stack trace ( ) ; } return valid xml ; }	checks whether the given xml is valid against the xsd for the new data format .
@ nullable public n node ( @ nullable object key , @ nullable collection < n > inc ) { return node ( key , inc , null ) ; }	gets node for a given key .
public void increment ( ) { counter . get and increment ( ) ; }	increments the count of in - flight transactions to the resource being monitored .
public default deployment cache ( ) { this . cache = collections . synchronized map ( new hash map < string , t > ( ) ) ; }	cache with no limit.
private int find insertion point ( sorted list entry entry ) { int insertion point = sorted model . size ( ) ; if ( sort order != sort order . unordered ) { insertion point = collections . binary search ( ( list ) sorted model , entry ) ; if ( insertion point < num ) { insertion point = - ( insertion point + num ) ; } } return insertion point ; }	internal helper method to find the insertion point for a new entry in the sorted model .
private boolean have shown message before ( update message msg ) { if ( ! msg . is shown once ( ) ) return bool ; load seen messages ( ) ; if ( seen messages == null || seen messages . size ( ) == num || ! seen messages . contains ( msg ) ) { if ( seen messages == null ) seen messages = new hash set < > ( ) ; seen messages . add ( msg ) ; save seen messages ( ) ; return bool ; } return bool ; }	checks on a message map , if we ' ve seen this message before.
public void data source added ( int index ) { update ( ) ; update coordinate projection combo boxes ( ) ; }	update bottom stats when a data source is added .
public boolean field is static ( ) { return modifier . is static ( field . get modifiers ( ) ) ; }	returns whether the field is marked with the static modifier .
void new equation ( df lhs , df operator , df op1 , df op2 , df op3 ) { df eq = new df ( lhs , operator , op1 , op2 , op3 ) ; equations . add graph node ( eq ) ; equations . add graph node ( lhs ) ; equations . add graph node ( op1 ) ; equations . add graph node ( op2 ) ; equations . add graph node ( op3 ) ; new equations . add ( eq ) ; op1 . add use ( eq ) ; op2 . add use ( eq ) ; op3 . add use ( eq ) ; lhs . add def ( eq ) ; if ( eager && eq . evaluate ( ) ) changed cell ( lhs ) ; }	add an equation with three operands on the right - hand side .
@ override public void stop ( ) { if ( stopping . compare and set ( bool , bool ) ) { if ( log . is debug enabled ( ) ) log . debug ( str + cache name + str ) ; wake up ( ) ; boolean graceful = bool ; for ( grid worker worker : flush threads ) graceful &= u . join ( worker , log ) ; if ( ! graceful ) log . warning ( str ) ; } }	performs shutdown logic for store.
private set < storage port > and storage port sets ( set < storage port > a , set < storage port > b ) { set < storage port > result = new hash set < storage port > ( ) ; for ( storage port port : a ) { if ( b . contains ( port ) ) { result . add ( port ) ; } } return result ; }	logical and of a and b.
public static void add attribute to schema ( string service name , string sub schema name , string schema type , node attribute schema node , sso admin token ) throws upgrade exception { service schema ss = get service schema ( service name , sub schema name , schema type , admin token ) ; add attribute to schema ( ss , attribute schema node ) ; }	adds new attribute schema to an existing service .
public int next ( int current ) { for ( int i = current + num ; i < ( arguments != null ? arguments . size ( ) : num ) ; i ++ ) { if ( get argument ( i ) instanceof math container ) { return i ; } } throw new array index out of bounds exception ( str ) ; }	get index of next argument .
@ override public boolean supports authentication ( ) { if ( debug . message enabled ( ) ) { debug . message ( str ) ; } return bool ; }	tells whether this identity repository supports authentication .
protected void reorder app deployments after configuration version ( element domain ) { list < element > app deployments = xml tool . select elements matching x ( str , domain ) ; for ( element app deployment : app deployments ) { domain . remove child ( app deployment ) ; } element configuration version = xml tool . select element matching x ( str , domain ) ; node before = null ; node list children = domain . get child nodes ( ) ; for ( int i = num ; i < children . get length ( ) ; i ++ ) { if ( configuration version . equals ( children . item ( i ) ) && i < children . get length ( ) - num ) { before = children . item ( i + num ) ; } } if ( before != null ) { for ( element app deployment : app deployments ) { domain . insert before ( app deployment , before ) ; } } else { for ( element app deployment : app deployments ) { domain . append child ( app deployment ) ; } } }	per current schema of the weblogic domain , app - deployment elements need to come directly after the configuration - version element .
static facet method select facet method ( schema field field , facet method method , integer mincount ) { field type type = field . get type ( ) ; if ( method == null ) { if ( type instanceof bool field && ( field . indexed ( ) == bool || field . has doc values ( ) == bool ) ) { method = facet method . enum ; } else if ( type . get numeric type ( ) != null && ! field . multi valued ( ) ) { method = facet method . fcs ; } else { method = facet method . fc ; } } if ( method == facet method . fc && type . get numeric type ( ) != null && ! field . multi valued ( ) ) { method = facet method . fcs ; } if ( method == facet method . uif && ! field . has doc values ( ) && mincount == num ) { method = field . multi valued ( ) ? facet method . fc : facet method . fcs ; } if ( method == facet method . enum && trie field . get main value prefix ( type ) != null ) { method = field . multi valued ( ) ? facet method . fc : facet method . fcs ; } final boolean multi token = field . multi valued ( ) || type . multi valued field cache ( ) ; if ( method == facet method . fcs && multi token ) { method = facet method . fc ; } return method ; }	this method will force the appropriate facet method even if the user provided a different one as a request parameter n.
public list < hash map < string , object > > clear overall chat ( ) { try { list < hash map < string , object > > my chat list = my chats . get ( overall chat room name ) ; my chat list = new linked list < hash map < string , object > > ( ) ; my chats . put ( overall chat room name , my chat list ) ; map < integer , string > new message = new hash map < integer , string > ( ) ; new message . put ( num , str ) ; scope application adapter . send message to members ( new message ) ; return my chat list ; } catch ( exception err ) { log . error ( str , err ) ; return null ; } }	clear the overallchat history.
public db schema changer begin change ( ) throws exception { backup file = file . create temp file ( str , str ) ; log . info ( str , class file . get absolute path ( ) , backup file . get absolute path ( ) ) ; copy file ( class file , backup file ) ; cc . defrost ( ) ; return this ; }	begin change the schema this method should be called before making any changes to the class.
void animate challenge to ( int y , int velocity ) { if ( m challenge view == null ) { return ; } cancel transitions in progress ( ) ; m challenge interactive internal = bool ; m challenge view . set layer type ( layer type hardware , null ) ; final int sy = m challenge view . get bottom ( ) ; final int dy = y - sy ; if ( dy == num ) { complete challenge scroll ( ) ; return ; } set scroll state ( scroll state settling ) ; final int child height = m challenge view . get height ( ) ; final int half height = child height / num ; final float distance ratio = math . min ( num , num * math . abs ( dy ) / child height ) ; final float distance = half height + half height * distance influence for snap duration ( distance ratio ) ; int duration = num ; velocity = math . abs ( velocity ) ; if ( velocity > num ) { duration = num * math . round ( num * math . abs ( distance / velocity ) ) ; } else { final float child delta = ( float ) math . abs ( dy ) / child height ; duration = ( int ) ( ( child delta + num ) * num ) ; } duration = math . min ( duration , max settle duration ) ; m scroller . start scroll ( num , sy , num , dy , duration ) ; post invalidate on animation ( ) ; }	animate the bottom edge of the challenge view to the given position .
public jca x509v3 certificate builder ( x500 principal issuer , big integer serial , date not before , date not after , x500 principal subject , public key public key ) { super ( x500 name . get instance ( issuer . get encoded ( ) ) , serial , not before , not after , x500 name . get instance ( subject . get encoded ( ) ) , subject public key info . get instance ( public key . get encoded ( ) ) ) ; }	initialise the builder using x500principal objects and a publickey .
private void write guid ( byte buffer buffer , object value ) throws io { matcher m = guid pattern . matcher ( to char sequence ( value ) ) ; if ( ! m . matches ( ) ) { throw new io ( with error context ( str + value ) ) ; } byte buffer orig buffer = null ; byte [ ] tmp buf = null ; if ( buffer . order ( ) != byte order . big endian ) { orig buffer = buffer ; tmp buf = new byte [ num ] ; buffer = byte buffer . wrap ( tmp buf ) ; } byte util . write hex string ( buffer , m . group ( num ) ) ; byte util . write hex string ( buffer , m . group ( num ) ) ; byte util . write hex string ( buffer , m . group ( num ) ) ; byte util . write hex string ( buffer , m . group ( num ) ) ; byte util . write hex string ( buffer , m . group ( num ) ) ; if ( tmp buf != null ) { byte util . swap4 bytes ( tmp buf , num ) ; byte util . swap2 bytes ( tmp buf , num ) ; byte util . swap2 bytes ( tmp buf , num ) ; orig buffer . put ( tmp buf ) ; } }	writes a guid value .
public neuron group ( final network net , final list < neuron > neurons ) { super ( net ) ; neuron list = new array list < neuron > ( neurons . size ( ) ) ; for ( neuron neuron : neurons ) { add neuron ( neuron ) ; } neuron list = new copy on write array list < neuron > ( neuron list ) ; update rule = get neuron type ( ) ; reset subsampling indices ( ) ; }	construct a new neuron group from a list of neurons .
@ log message doc ( level = str , message = str , explanation = str , recommendation = log message doc . report controller bug ) public list < ld > apply updates ( ) { list < ld > applied updates = new array list < ld > ( ) ; ld update = null ; while ( ld updates . peek ( ) != null ) { try { update = ld updates . take ( ) ; } catch ( exception e ) { log . error ( str , e ) ; } if ( log . is trace enabled ( ) ) { log . trace ( str , update ) ; } switch ( update . get operation ( ) ) { case link updated : add or update link ( update . get src ( ) , update . get src port ( ) , update . get dst ( ) , update . get dst port ( ) , update . get type ( ) ) ; break ; case link removed : remove link ( update . get src ( ) , update . get src port ( ) , update . get dst ( ) , update . get dst port ( ) ) ; break ; case switch updated : add or update switch ( update . get src ( ) ) ; break ; case switch removed : remove switch ( update . get src ( ) ) ; break ; case tunnel port added : add tunnel port ( update . get src ( ) , update . get src port ( ) ) ; break ; case tunnel port removed : remove tunnel port ( update . get src ( ) , update . get src port ( ) ) ; break ; case port up : case port down : break ; } applied updates . add ( update ) ; } return ( collections . unmodifiable list ( applied updates ) ) ; }	updates concerning switch disconnect and port down are not processed.
boolean is empty ( ) { return m description . is empty ( ) && m types . is empty ( ) ; }	checks whether the information about the oma content is empty .
public star ( int points , float rotation , float insideness ) { float x = num ; float y = num ; float radius = num ; points = points < num ? num : points ; rotation = rotation + ( float ) ( math . pi / num ) ; boolean flat = insideness >= num ; set control point size ( flat ? points : num * points ) ; final float pi2 = num * ( float ) math . pi ; float inside radius = radius * insideness ; d . float pt ; for ( int p = num ; p < points ; ++ p ) { double vertex = p ; double angle = vertex * pi2 / points + rotation ; pt = new d . float ( ( float ) ( x + math . cos ( angle ) * radius ) , ( float ) ( y + math . sin ( angle ) * radius ) ) ; push point ( pt ) ; if ( ! flat ) { double angle2 = ( vertex + num ) * pi2 / points + rotation ; pt = new d . float ( ( float ) ( x + math . cos ( angle2 ) * inside radius ) , ( float ) ( y + math . sin ( angle2 ) * inside radius ) ) ; push point ( pt ) ; } } }	create a star , or a regular polygon if insideness is 1.
private static boolean is static ( method m ) { int mods = m . get modifiers ( ) ; return ( mods & modifier . static ) != num ; }	returns if a method is static.
public synchronized boolean try lock ( ) { try { lock = file . try lock ( ) ; return lock != null ; } catch ( exception e ) { return bool ; } }	try to lock the file .
@ override public void node down ( topology topology , long event uid , string node id ) { if ( target server id . equals ( node id ) ) { decide on action ( topology ) ; } }	if the node going down is the node we are replicating from then decide on an action .
public boolean is valid ( ) { return bool ; }	returns true if all of the fields have legal values given their names.
private void rollover log task ( ) { try { if ( is init ) { flush ( ) ; } } catch ( exception e ) { log . log ( level . warning , e . to string ( ) , e ) ; } is rolling over = bool ; try { if ( ! is init ) return ; path saved path = null ; long now = current time . current time ( ) ; long last period end = next period end ; next period end = next rollover time ( now ) ; path path = get path ( ) ; synchronized ( log lock ) { flush temp stream ( ) ; long length = files . size ( path ) ; if ( last period end <= now && last period end > num ) { close log stream ( ) ; saved path = get saved path ( last period end - num ) ; } else if ( path != null && get rollover size ( ) <= length ) { close log stream ( ) ; saved path = get saved path ( now ) ; } } if ( saved path != null ) { move path to archive ( saved path ) ; } } catch ( io e ) { e . print stack trace ( ) ; } finally { synchronized ( log lock ) { is rolling over = bool ; flush temp stream ( ) ; } rollover listener . requeue ( rollover alarm ) ; } }	called from rollover worker.
public boolean on scroll changed ( int scroll y ) { boolean is pulling down now = scroll y < last scroll y ; latest pulling down . offer ( is pulling down now ) ; if ( latest pulling down . size ( ) > pulling down time max ) { latest pulling down . poll ( ) ; } last scroll y = scroll y ; return get pulling down time ( ) >= pulling down time threshold ; }	call this when scroll changed.
@ exception handler ( constraint violation exception . class ) @ response status ( value = http status . bad request ) public map < string , object > handle constraint violation exception ( constraint violation exception ex ) { collection < field error > errors = field error . get errors ( ex . get constraint violations ( ) ) ; log . warn ( str + errors . to string ( ) ) ; return lemon util . map of ( str , str , str , errors ) ; }	handles constraint violation exceptions.
@ override public void read external ( object input in ) throws io { b = new double [ in . read int ( ) ] ; for ( int p = num ; p < b . length ; p ++ ) { b [ p ] = in . read double ( ) ; } }	the object implements the readexternal method to restore its contents by calling the methods of datainput for primitive types and readobject for objects , strings and arrays.
private synchronized void add tracker ( string path , object marker , file delete strategy delete strategy ) { if ( exit when finished ) { throw new illegal state exception ( str ) ; } if ( reaper == null ) { reaper = new reaper ( ) ; reaper . start ( ) ; } trackers . add ( new tracker ( path , delete strategy , marker , q ) ) ; }	adds a tracker to the list of trackers .
list < issue > errors ( ) { return errors ; }	returns accumulated parsing errors .
public audio wife add on completion listener ( on completion listener listener ) { m completion listeners . add ( num , listener ) ; return this ; }	* add custom playback completion listener.
public void add volume to consistency group ( string instance id , string cg id ) throws api { rest result rr = rest client . get ( string . format ( str , instance id ) ) ; if ( ! check results ( rr ) ) { throw new api ( string . format ( str , rr . get error msg ( ) ) ) ; } sc volume configuration vol config = gson . from json ( rr . get result ( ) , sc volume configuration . class ) ; list < string > profiles = new array list < > ( ) ; for ( sc object profile : vol config . replay profile list ) { if ( ! cg id . equals ( profile . instance id ) ) { profiles . add ( profile . instance id ) ; } } profiles . add ( cg id ) ; parameters params = new parameters ( ) ; params . add ( str , profiles . to array ( new string [ num ] ) ) ; rr = rest client . put ( string . format ( str , instance id ) , params . to json ( ) ) ; if ( ! check results ( rr ) ) { throw new api ( string . format ( str , rr . get error msg ( ) ) ) ; } }	adds a volume to a consistency group .
public static boolean is implements interface ( class clazz , class interface class ) { if ( ! ( interface class . is interface ( ) ) ) { throw new illegal argument exception ( str ) ; } boolean result this class = recursive is implements interface ( clazz , interface class ) ; if ( result this class ) { return bool ; } return recursive superclass implements interface ( clazz , interface class ) ; }	method to check if a given class , and its superclasses and interfaces ( deep ) , implement a given interface .
private static string replace chars ( string str ) { string buffer buf = new string buffer ( str ) ; int length = buf . length ( ) ; for ( int i = num ; i < length ; i ++ ) { char current char = buf . char at ( i ) ; if ( current char == str ) { buf . set char at ( i , str ) ; buf . insert ( i + num , str ) ; length = length + num ; i = i + num ; } else if ( current char == str ) { buf . set char at ( i , str ) ; } } return buf . to string ( ) ; }	replace spaces with " % 20 " and backslashes with forward slashes in the input string to generate a well - formed uri string .
private void add binding ( final string key , final object value ) { m bindings . put ( key , value ) ; }	adds an additional object binding .
public static < t extends enum < t > > t for key ( string key , map < string , t > mapping , class < t > enumeration ) { t t = mapping . get ( key ) ; if ( t != null ) { return t ; } throw new illegal argument exception ( str + enumeration . to string ( ) + str + key ) ; }	boilerplate method to retrieve an enum method via an arbitrary key , rather than just the enum value .
private exchange rate direct lookup ( final currency source , final currency target , final date date ) { if ( system . get property ( str ) == null ) throw new unsupported operation exception ( str ) ; exchange rate rate = null ; ql . require ( ( ( rate = fetch ( source , target , date ) ) != null ) , str ) ; return rate ; }	fetches a exchange rate from the repository .
protected static int find next new line char ( char sequence s , int start ) { for ( int i = start ; i < s . length ( ) ; i ++ ) { if ( s . char at ( i ) == str ) { return i ; } } return - num ; }	find ' \ n ' from " start " position if not find , return - 1.
public skype builder with chat ( string id ) { if ( ! id . starts with ( str ) ) throw new illegal argument exception ( str ) ; if ( password != null ) throw new illegal argument exception ( str ) ; this . chat id = id ; return this ; }	join a particular chat as a guest . will have no effect if a password is specified.
public static int compare to ( object left , object right ) { return compare to with equality check ( left , right , bool ) ; }	compares the two objects handling nulls gracefully and performing numeric type coercion if required.
public static crl to impl ( crl crl ) throws crl { if ( crl instanceof crl ) { return ( crl ) crl ; } else { return x509 factory . intern ( crl ) ; } }	utility method to convert an arbitrary instance of x509crl to a x509crlimpl.
public final void test roundtrip ( ) { boolean performed = bool ; for ( int i = num ; i < alg name . length ; i ++ ) { for ( int l = num ; l < provider . length ; l ++ ) { if ( provider [ l ] == null ) { continue ; } test data generator g ; try { g = new test data generator ( alg name [ i ] [ num ] , alg name [ i ] [ num ] , private key info damaged , provider [ l ] ) ; } catch ( test data generator . allowed failure allowed failure ) { continue ; } try { encrypted private key info epki ; if ( g . ap ( ) == null ) { epki = new encrypted private key info ( alg name [ i ] [ num ] , g . ct ( ) ) ; } else { epki = new encrypted private key info ( g . ap ( ) , g . ct ( ) ) ; } try { epki . get key spec ( g . pub k ( ) == null ? g . k ( ) : g . pub k ( ) , provider [ l ] ) ; fail ( alg name [ i ] [ num ] + str + alg name [ i ] [ num ] ) ; } catch ( invalid key exception e ) { } performed = bool ; } catch ( no such algorithm exception allowed failure ) { } } } assert true ( str , performed ) ; }	encrypted data contains invalid pkcs8 key info encoding.
public final synchronized void close all ( ) { if ( on close all ( ) ) { log . w ( tag , str ) ; return ; } linked list < integer > ids = new linked list < integer > ( ) ; for ( int id : get existing ids ( ) ) { ids . add ( id ) ; } for ( int id : ids ) { close ( id ) ; } }	close all existing windows .
public void test pos neg first shorter ( ) { byte a bytes [ ] = { - num , - num , - num , - num , num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { - num , num , num , num , - num , - num , num , num , num , num , - num , num , num , - num , num , num , - num , - num } ; int a sign = num ; int b sign = - num ; byte r bytes [ ] = { - num , num , - num , - num , - num , - num , - num , - num , - num , - num , - num , num , - num , - num , num , - num , - num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . or ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , result . signum ( ) ) ; }	or for a positive and a negative number ; the first is shorter.
private boolean start random game ( ) { abstract launch [ ] pins = m card adapter . get launchers ( ) ; list < abstract launch > games = new array list < abstract launch > ( pins . length ) ; for ( abstract launch pin : pins ) { if ( pin . is game ( ) ) { if ( pin . m state == abstract launch . state ready ) { games . add ( pin ) ; } } } if ( games . size ( ) > num ) { random r = new random ( ) ; int index = r . next int ( games . size ( ) ) ; abstract launch game = games . get ( index ) ; log . d ( tag , string . format ( str , game . m content description ) ) ; game . on click ( game . get click target ( ) ) ; measurement manager . record custom event ( m measurement , get string ( r . string . analytics event category launch ) , get string ( r . string . analytics launch action voice ) , game . m content description ) ; analytics manager . send event ( r . string . analytics event category launch , r . string . analytics launch action voice , game . m content description ) ; return bool ; } else { return bool ; } }	pick a game at random from the available games in state_ready state.
public void init disk cache ( ) { synchronized ( m disk cache lock ) { if ( m disk lru cache == null || m disk lru cache . is closed ( ) ) { file disk cache dir = m cache params . disk cache dir ; if ( m cache params . disk cache enabled && disk cache dir != null ) { if ( ! disk cache dir . exists ( ) ) { disk cache dir . mkdirs ( ) ; } if ( get usable space ( disk cache dir ) > m cache params . disk cache size ) { try { m disk lru cache = disk lru cache . open ( disk cache dir , num , num , m cache params . disk cache size ) ; if ( build config . debug ) { log . d ( tag , str ) ; } } catch ( final io e ) { m cache params . disk cache dir = null ; log . e ( tag , str + e ) ; } } } } m disk cache starting = bool ; m disk cache lock . notify all ( ) ; } }	initializes the disk cache.
boolean is registered permission ( permission permission ) ;	returns true if given permissions is registered in this manager .
public static int compare ( string id1 , string id2 ) { int result = - num ; string seed1 = id generator . get seed from id ( id1 ) ; string seed2 = id generator . get seed from id ( id2 ) ; if ( seed1 != null && seed2 != null ) { result = seed1 . compare to ( seed2 ) ; if ( result == num ) { long count1 = id generator . get sequence from id ( id1 ) ; long count2 = id generator . get sequence from id ( id2 ) ; result = ( int ) ( count1 - count2 ) ; } } return result ; }	does a proper compare on the id ' s.
public static element add child element ns ( element element , string child element name , document document , string name space url ) { element new element = document . create element ns ( name space url , child element name ) ; element . append child ( new element ) ; return element ; }	creates a child element with the given namespace supportive name and appends it to the element child node list .
public vn modify consistency group sync ( string id , lun group modify param param ) { string builder url bld = new string builder ( url modif ) ; url bld . append ( id ) ; url bld . append ( url modif ) ; url = url bld . to string ( ) ; return post request sync ( param ) ; }	modify consistency group in sync mode.
protected query finish query ( boolean query . builder in , boolean all terms required ) { return in . build ( ) ; }	subclass can override this to tweak the query before searching .
public long sum ( ) { long sum = num ; for ( atomic long value : map . values ( ) ) { sum = sum + value . get ( ) ; } return sum ; }	returns the sum of all values in this map.
public static string extract full stack trace ( throwable e ) { string writer string writer = new string writer ( ) ; print writer print writer = new print writer ( string writer ) ; e . print stack trace ( print writer ) ; return string writer . to string ( ) ; }	extract the full stack trace :.
public empty tile factory ( tile factory info info ) { super ( info ) ; int tile size = info . get tile size ( info . get minimum zoom level ( ) ) ; empty tile = new buffered image ( tile size , tile size , buffered image . type int argb ) ; d g = empty tile . create graphics ( ) ; g . set rendering hint ( rendering hints . key antialiasing , rendering hints . value antialias on ) ; g . set color ( color . gray ) ; g . fill rect ( num , num , tile size , tile size ) ; g . set color ( color . white ) ; g . draw oval ( num , num , tile size - num , tile size - num ) ; g . fill oval ( num , num , num , num ) ; g . fill oval ( tile size - num , num , num , num ) ; g . fill oval ( tile size / num - num , tile size / num - num , num , num ) ; g . dispose ( ) ; }	creates a new instance of emptytilefactory using the specified info .
public static void i ( string tag , string msg , object ... args ) { if ( s level > level info ) { return ; } if ( args . length > num ) { msg = string . format ( msg , args ) ; } log . i ( tag , msg ) ; }	send an info log message.
public void close ( ) throws io { guard . close ( ) ; random access file local raf = raf ; if ( local raf != null ) { synchronized ( local raf ) { raf = null ; local raf . close ( ) ; } if ( file to delete on close != null ) { file to delete on close . delete ( ) ; file to delete on close = null ; } } }	closes this zip file.
public boolean match with reg ex ( string a reg ex ) { if ( text utils . is empty ( a reg ex ) ) { return bool ; } boolean matched = bool ; if ( ! text utils . is empty ( m display name ) ) { matched = m display name . matches ( a reg ex ) ; } if ( ! matched ) { for ( string email : m emails ) { matched |= email . matches ( a reg ex ) ; } } return matched ; }	test if some fields match with the reg ex .
public string stem string ( string str ) { string buffer result = new string buffer ( ) ; int start = - num ; for ( int j = num ; j < str . length ( ) ; j ++ ) { char c = str . char at ( j ) ; if ( character . is letter or digit ( c ) ) { if ( start == - num ) { start = j ; } } else if ( c == str ) { if ( start == - num ) { result . append ( c ) ; } } else { if ( start != - num ) { result . append ( stem ( str . substring ( start , j ) ) ) ; start = - num ; } result . append ( c ) ; } } if ( start != - num ) { result . append ( stem ( str . substring ( start , str . length ( ) ) ) ) ; } return result . to string ( ) ; }	stems everything in the given string.
public static list < integer > parse numeric list ( string string ) { array list < integer > list = new array list < > ( ) ; pattern ranges = pattern . compile ( str ) ; matcher m = ranges . matcher ( string ) ; while ( m . find ( ) ) { string range = m . group ( str ) ; string = string . replace ( range , str ) ; parse numeric range ( range , list ) ; } string [ ] numbers = string . split ( str ) ; for ( int i = num ; i < numbers . length ; ++ i ) { string number = numbers [ i ] ; if ( ! number . is empty ( ) ) { list . add ( integer . value of ( number ) ) ; } } collections . sort ( list ) ; return list ; }	converts a natural language list of numerals into a list of integers.
protected void save pass code and exit ( ) { intent result intent = new intent ( ) ; result intent . put extra ( key passcode , m pass code digits [ num ] + m pass code digits [ num ] + m pass code digits [ num ] + m pass code digits [ num ] ) ; set result ( result ok , result intent ) ; finish ( ) ; }	saves the pass code input by the user as the current pass code .
public static void read fully ( file channel file , long pos , byte buffer dst ) { try { do { int len = file . read ( dst , pos ) ; if ( len < num ) { throw new eof ( ) ; } pos += len ; } while ( dst . remaining ( ) > num ) ; dst . rewind ( ) ; } catch ( io e ) { long size ; try { size = file . size ( ) ; } catch ( io e2 ) { size = - num ; } throw new illegal state exception ( error reading failed , str + str , file , size , dst . remaining ( ) , pos , e ) ; } }	read from a file channel until the buffer is full.
public void trigger cycle ( ) { lock . lock ( ) ; trigger count ++ ; contexts parked = num ; lock . broadcast ( ) ; lock . unlock ( ) ; }	wake up the parked threads in this group .
protected boolean heapify down comparator ( final int ipos , object cur ) { int pos = ipos ; final int half = size > > > num ; while ( pos < half ) { int min = pos ; object best = cur ; final int lchild = ( pos << num ) + num ; object left = queue [ lchild ] ; if ( comparator . compare ( best , left ) > num ) { min = lchild ; best = left ; } final int rchild = lchild + num ; if ( rchild < size ) { object right = queue [ rchild ] ; if ( comparator . compare ( best , right ) > num ) { min = rchild ; best = right ; } } if ( min == pos ) { break ; } queue [ pos ] = best ; pos = min ; } queue [ pos ] = cur ; return ( pos != ipos ) ; }	execute a " heapify downwards " aka " siftdown ".
public static boolean is string ( string str ) { return ( ( str . starts with ( str ) && str . ends with ( str ) ) || ( str . starts with ( str ) && str . ends with ( str ) ) ) && str . length ( ) > num ; }	check the given string is a string literal.
static public boolean has photo ( tweet tweet ) { return get photo entity ( tweet ) != null ; }	returns true if there is a media entity with the type of " photo ".
public void test case19 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num } ; byte r bytes [ ] = { num , num , num , num , num , num , num } ; int a sign = num ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = big integer . zero ; big integer result = a number . add ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	add zero to a number.
public static string builder format to ( string builder buf , long [ ] d , string sep ) { if ( d == null ) { return buf . append ( str ) ; } if ( d . length == num ) { return buf ; } buf . append ( d [ num ] ) ; for ( int i = num ; i < d . length ; i ++ ) { buf . append ( sep ) ; buf . append ( d [ i ] ) ; } return buf ; }	formats the long array d .
public static < t > int upper bound ( final list < t > value list , int from idx , int to idx , final comparable < t > value ) { int len = to idx - from idx + ( to idx > from idx ? num : num ) ; int from = from idx ; int half ; int middle ; while ( len > num ) { half = len > > num ; middle = from ; middle = middle + half ; if ( value . compare to ( value list . get ( middle ) ) == - num ) { len = half ; } else { from = middle ; from ++ ; len = len - half - num ; } } return from ; }	this method is equivalent to c + + std : upper_bound function returns an index pointing to the first element in the ordered collection which is greater than passed value.
public int size ( ) { return data . size ( ) ; }	returns the number of observations used in this test .
public static synchronized void register additional hyphenation file directory ( string directory ) { if ( additional hyphenation file directories == null ) { additional hyphenation file directories = new array list < > ( ) ; } additional hyphenation file directories . add ( directory ) ; }	registers additional file directories .
private void insert new drive files ( ) throws io { cursor cursor = null ; try { cursor = my tracks provider utils . get track cursor ( sync utils . no drive id tracks query , null , null ) ; long recording track id = preferences utils . get long ( context , r . string . recording track id key ) ; if ( cursor != null && cursor . move to first ( ) ) { do { track track = my tracks provider utils . create track ( cursor ) ; if ( track . get id ( ) == recording track id ) { continue ; } sync utils . insert drive file ( drive , folder id , context , my tracks provider utils , track , bool , bool ) ; } while ( cursor . move to next ( ) ) ; } } finally { if ( cursor != null ) { cursor . close ( ) ; } } }	inserts new drive files from tracks without a drive id .
public void test handle normal completion ( ) { for ( execution mode m : execution mode . values ( ) ) for ( boolean create incomplete : new boolean [ ] { bool , bool } ) for ( integer v1 : new integer [ ] { num , null } ) { final completable future < integer > f = new completable future < > ( ) ; final atomic integer a = new atomic integer ( num ) ; if ( ! create incomplete ) assert true ( f . complete ( v1 ) ) ; final completable future < integer > g = m . handle ( f , null ) ; if ( create incomplete ) assert true ( f . complete ( v1 ) ) ; check completed normally ( g , inc ( v1 ) ) ; check completed normally ( f , v1 ) ; assert equals ( num , a . get ( ) ) ; } }	handle action completes normally with function value on normal completion of source.
private static string unescape ( string s ) { int len = s . length ( ) , base = num , idx ; string escapes = str ; string chars = str ; string buffer sbuf = null ; while ( ( idx = s . index of ( str , base ) ) != - num ) { if ( sbuf != null ) sbuf . append ( s . substring ( base , idx ) ) ; if ( idx + num == len ) break ; char c = s . char at ( idx + num ) ; int cidx = escapes . index of ( c ) ; if ( cidx == - num ) { sbuf . append ( str ) ; sbuf . append ( c ) ; } else { if ( sbuf == null ) sbuf = new string buffer ( s . substring ( base , idx ) ) ; sbuf . append ( chars . char at ( cidx ) ) ; } base = idx + num ; } if ( sbuf != null && base < len ) sbuf . append ( s . substring ( base ) ) ; return ( sbuf == null ? s : sbuf . to string ( ) ) ; }	replace escape sequences with represented characters.
public static void put ( string dbg token ) { dbg table . put ( dbg token , boolean . true ) ; }	installs a new debug token.
public boolean remove data set ( t d ) { if ( d == null ) return bool ; boolean removed = m data sets . remove ( d ) ; if ( removed ) { m y -= d . get entry count ( ) ; m y -= d . get y ( ) ; calc min max ( m data sets ) ; } return removed ; }	removes the given dataset from this data object.
public long reserved store ( ) { return m size * m total slots ; }	bytesreserved : the space reserved on the backing file for those allocation slots ( allocatorslots * slotsreserved ) .
public transfer write string ( string s ) throws io { if ( s == null ) { out . write int ( - num ) ; } else { int len = s . length ( ) ; out . write int ( len ) ; for ( int i = num ; i < len ; i ++ ) { out . write char ( s . char at ( i ) ) ; } } return this ; }	write a string . the maximum string length is integer . max_value .
private void fill inside draw ( graphics g , int x , int y , int w , int h ) { g . set color ( color . black ) ; g . draw rect ( x , y , w , h ) ; g . set color ( color . light gray ) ; g . fill rect ( x + num , y + num , w - num , h - num ) ; }	fill the area only inside the boundary ( no overlap ).
public drawer builder add sticky drawer items ( @ non null i ... sticky drawer items ) { if ( this . m sticky drawer items == null ) { this . m sticky drawer items = new array list < > ( ) ; } collections . add all ( this . m sticky drawer items , sticky drawer items ) ; return this ; }	add a initial draweritem or a draweritem array for the stickydrawerfooter.
public void append to buffer ( string builder buf ) { iterator < polygon > iter = polygons . iterator ( ) ; while ( iter . has next ( ) ) { polygon poly = iter . next ( ) ; poly . append to buffer ( buf ) ; if ( iter . has next ( ) ) { buf . append ( str ) ; } } }	append polygons to the buffer .
public void add function ( function interface active function ) { functions . add ( active function ) ; }	add function to current file.
public static charset to charset ( charset charset ) { return charset == null ? charset . default charset ( ) : charset ; }	returns the given charset or the default charset if the given charset is null .
public < t extends data object > joiner join ( class < t > clazz , string alias ) { if ( ! j classes . is empty ( ) ) { throw new joiner exception ( str ) ; } j jc = new j ( clazz , alias , j classes . size ( ) ) ; j classes . add ( jc ) ; last j = jc ; alias map . put ( alias , jc ) ; return this ; }	starts a new query not related to a previous class query .
public launch option ( version version , authenticator authenticator , minecraft directory minecraft dir ) { objects . require non null ( version ) ; objects . require non null ( authenticator ) ; objects . require non null ( minecraft dir ) ; this . version = version ; this . authenticator = authenticator ; this . minecraft directory = minecraft dir ; this . runtime directory = minecraft dir ; this . java environment = java environment . current ( ) ; }	creates a launchoption using the default java environment .
protected boolean is stoppable ( ) { return ( is running ( ) && get locator ( ) != null ) ; }	determines whether the locator can be stopped in - process , such as when a locator is embedded in an application and the locatorlauncher api is being used .
public void load ( string file name ) throws exception { if ( ! file name . ends with ( str ) && ! file name . ends with ( str ) ) { throw new exception ( str + str ) ; } if ( file name . ends with ( str ) ) { load binary ( file name ) ; } else if ( file name . ends with ( str ) ) { load xml ( file name ) ; } }	load a serialized knowledgeflow ( either binary or xml ).
public bindings add opt component ( string property , class clazz , j c , boolean enabled by default ) { binding b = new opt component binding ( this , property , clazz , c , enabled by default ) ; if ( opt components . contains key ( property ) ) { throw new binding exception ( messages . get string ( str ) ) ; } opt components . put ( property , b ) ; return this ; }	add an optional ( nullable ) java bean component of type clazz .
public static boolean copy file ( file file , file copy ) { if ( file == null || copy == null ) throw new null pointer exception ( str ) ; if ( ! file . is file ( ) || copy . is directory ( ) ) throw new illegal argument exception ( str ) ; file input stream fis = null ; file output stream fos = null ; try { fis = new file input stream ( file ) ; fos = new file output stream ( copy ) ; int bytes ; byte [ ] packet = new byte [ copy packet size ] ; while ( ( bytes = fis . read ( packet , num , copy packet size ) ) != - num ) fos . write ( packet , num , bytes ) ; return bool ; } catch ( exception e ) { logger . log ( level . severe , str , e ) ; return bool ; } finally { try { if ( fos != null ) fos . close ( ) ; } catch ( exception e ) { logger . log ( level . severe , str , e ) ; } try { if ( fis != null ) fis . close ( ) ; } catch ( exception e ) { logger . log ( level . severe , str , e ) ; } } }	copies source file to the destination file , returns true if the file was successfully copied .
public static byte [ ] encrypt my sql ( string password , byte [ ] seed ) { if ( password == null || password . equals ( str ) ) { return new byte [ num ] ; } message digest digest = null ; try { digest = message digest . get instance ( str ) ; } catch ( no such algorithm exception e ) { logger . error ( str , e ) ; return new byte [ num ] ; } byte [ ] stage1 hash = digest . digest ( password . get bytes ( ) ) ; digest . reset ( ) ; byte [ ] sha1 stage1 = digest . digest ( stage1 hash ) ; digest . reset ( ) ; digest . update ( seed ) ; digest . update ( sha1 stage1 ) ; byte [ ] final sha1 = digest . digest ( ) ; byte [ ] token = new byte [ final sha1 . length ] ; for ( int i = num ; i < final sha1 . length ; i ++ ) { token [ i ] = ( byte ) ( stage1 hash [ i ] ^ final sha1 [ i ] ) ; } return token ; }	do a mysql specific encryption of the given password < br > algorithm is : < br > stage1_hash = sha1 ( password ) < br > token = sha1 ( scramble + sha1 ( stage1_hash ) ) xor stage1_hash.
protected void add url ( url url ) { if ( urls . contains ( url ) ) { logger . info ( str + url ) ; return ; } urls . add ( url ) ; logger . info ( str + url ) ; }	adds an url to the list of crl urls.
private int [ ] define numeric ( random random ) { int [ ] num = new int [ get num attributes ( ) ] ; for ( int i = num ; i < num . length ; i ++ ) { num [ i ] = attribute . nominal ; } int num num = num ; for ( int i = num ; ( num num < get num numeric ( ) ) && ( i < get num attributes ( ) * num ) ; i ++ ) { int maybe next = ( int ) ( random . next double ( ) * num . length ) ; if ( num [ maybe next ] != attribute . numeric ) { num [ maybe next ] = attribute . numeric ; num num ++ ; } } return num ; }	chooses randomly the attributes that get datatyp numeric .
public static boolean is favorite station ( context context , int i station ) { return is station exist ( context , i station , station type favorite ) ; }	judge whether station is a favorite station.
protected void paint caption ( graphics g , rectangle rect ) { string s = get target label ( ) ; if ( s . equals ( str ) ) { return ; } g . set font ( get target font ( ) ) ; font metrics fm = g . get font metrics ( ) ; string str = get target label ( ) ; int width = fm . string width ( str ) ; int textx = rect . x + ( rect . width - width ) / num ; int texty = rect . y + caption margin top + fm . get ascent ( ) ; int sepy = rect . y + rect . height - caption separator height / num ; g . set color ( is target enabled ( ) ? get foreground color ( ) : get disabled color ( ) ) ; g . draw string ( s , textx , texty ) ; draw3 d ( g , rect . x , sepy , rect . width , num , bool ) ; }	paints menu window ' s caption.
public void put float ( float x ) { bb . put float ( space -= num , x ) ; }	add a ` float ` to the buffer , backwards from the current location.
final void put int ( int offset , int value ) { unsafe . put int ( offset + address , value ) ; }	writes an int at the specified offset from this native object ' s base address .
private static boolean is unreserved character ( char p char ) { return ( is alphanum ( p char ) || mark characters . index of ( p char ) != - num ) ; }	determine whether a char is an unreserved character .
public static inet socket address parse socket address ( string addr ) { string [ ] parts = addr . split ( colon ) ; preconditions . check argument ( parts . length == num ) ; string hostname = parts [ num ] ; int port = integer . parse int ( parts [ num ] ) ; return new inet socket address ( hostname , port ) ; }	parse the inet socket address from the string representation .
public void message arrived ( mqtt publish send message ) { final string method name = str ; if ( mqtt callback != null || callbacks . size ( ) > num ) { synchronized ( space available ) { while ( running && ! quiescing && message queue . size ( ) >= inbound queue size ) { try { log . fine ( class name , method name , str ) ; space available . wait ( num ) ; } catch ( interrupted exception ex ) { } } } if ( ! quiescing ) { message queue . add element ( send message ) ; synchronized ( work available ) { log . fine ( class name , method name , str ) ; work available . notify all ( ) ; } } } }	this method is called when a message arrives on a topic.
private void find home ( ) { string home = system . get property ( str ) ; if ( home == null ) home = system . get property ( str ) ; if ( home == null ) home = system . get property ( str ) ; if ( home == null ) home = system . get property ( str ) ; if ( home != null ) manifest path = home + file . separator + str + file . separator + manifest file name ; else manifest path = manifest file name ; }	find the home folder of installation .
public static final int [ ] to int array ( string s [ ] ) { int u [ ] = new int [ s . length ] ; for ( int j = num ; j < s . length ; j ++ ) { u [ j ] = integer . parse int ( s [ j ] ) ; } return u ; }	convert eg [ " 1 " , " 2 " ] to [ 1 , 2 ].
private list < string > check all columns in cube ( cube instance cube , table desc table , map < string , hive table meta . hive table column meta > fields map ) { set < column desc > used columns = sets . new hash set ( ) ; for ( tbl col ref col : cube . get all columns ( ) ) { used columns . add ( col . get column desc ( ) ) ; } list < string > violate columns = lists . new array list ( ) ; for ( column desc column : table . get columns ( ) ) { if ( used columns . contains ( column ) ) { hive table meta . hive table column meta field = fields map . get ( column . get name ( ) ) ; if ( field == null || ! is column compatible ( column , field ) ) { violate columns . add ( column . get name ( ) ) ; } } } return violate columns ; }	check whether all columns used in ` cube ` has compatible schema in current hive schema denoted by ` fieldsmap ` .
public static string make unified line feeds ( string query ) { if ( query . index of ( str ) == - num ) { return query ; } string builder result = new string builder ( query . length ( ) ) ; for ( int i = num ; i < query . length ( ) ; i ++ ) { char c = query . char at ( i ) ; if ( c == str ) { continue ; } result . append ( c ) ; } return result . to string ( ) ; }	removes \ \ r characters from query . actually this is done specially for oracle due to some bug in it ' s driver.
private void reflect member variables in left button ( ) { final boolean last page reached = ( view pager . get current item ( ) + num ) == pages . size ( ) ; final boolean button should be invisible = ( last page reached && disable left button on last page ) || left button disabled ; final boolean button is currently invisible = left button . get visibility ( ) == view . invisible ; final boolean should update button = button should be invisible != button is currently invisible ; if ( should update button ) { final animator button animator = button should be invisible ? button animator factory . new left button disappear animator ( left button ) : button animator factory . new left button appear animator ( left button ) ; if ( button should be invisible ) { disable button ( button animator , left button ) ; } else { enable button ( button animator , left button ) ; } } }	enables or disables the left button , so that it matches the current member variables .
public static void register semi disposable block ( string ore dict name ) { semi disposable blocks . add ( ore dict name ) ; }	registers a block as semi disposable using its ore dictionary name.
public boolean accepts type name ( string type ) { return type list . contains ( type ) ; }	returns true if this train will service the type of car or engine .
public void delete async ( final string id , final future callback < task > response callback ) throws io { delete object async ( id , response callback ) ; }	delete the specified project .
private boolean continue after accept failure ( throwable t ) { rmi fh = rmi . get failure handler ( ) ; if ( fh != null ) { return fh . failure ( t instanceof exception ? ( exception ) t : new invocation target exception ( t ) ) ; } else { throttle loop on exception ( ) ; return bool ; } }	returns true if the accept loop should continue after the specified exception has been caught , or false if the accept loop should terminate ( closing the server socket ).
private static void process package ( string tb name , packages pkg ) { string class name prefix = string util . parse hump name ( tb name , bool , is hump model class ) ; pkg . set dao ( package prefix + ( string util . is empty ( package prefix ) || string util . is empty ( package dao ) ? str : str ) + package dao ) ; pkg . set dao name ( class name prefix + dao suffix ) ; pkg . set model ( package prefix + ( string util . is empty ( package prefix ) || string util . is empty ( package model ) ? str : str ) + package model ) ; pkg . set model name ( class name prefix + model suffix ) ; pkg . set mapper xml ( package prefix + ( string util . is empty ( package prefix ) || string util . is empty ( package mapper xml ) ? str : str ) + package mapper xml ) ; pkg . set mapper xml name ( class name prefix + mapper xml suffix ) ; pkg . set model name lower first ( string util . lower first ( pkg . get model name ( ) ) ) ; }	process package and filename.
public void add on central position changed listener ( on central position changed listener listener ) { m on central position changed listeners . add ( listener ) ; }	adds a listener that will be called when the central item of the list changes .
public boolean add call ( string source class , string source method , string target class , string target method ) { call graph entry from = new call graph entry ( target class , target method ) ; call graph entry to = new call graph entry ( source class , source method ) ; if ( source class . equals ( class name ) ) cut nodes . add ( to ) ; if ( ! graph . contains edge ( from , to ) ) { graph . add edge ( from , to ) ; call graph classes . add ( target class . replace all ( str , str ) ) ; return bool ; } return bool ; }	add call to the call graph.
private static void do thread dump ( final http servlet request req , final http servlet response resp ) throws io { resp . set status ( http ok ) ; resp . add header ( str , str ) ; resp . set content type ( mime text plain ) ; final print writer w = resp . get writer ( ) ; try { bigdata statics . thread dump ( w ) ; w . flush ( ) ; } catch ( throwable t ) { launder throwable ( t , resp , str ) ; } finally { w . close ( ) ; } }	write a thread dump onto the http response as an aid to diagnose both node - local and distributed deadlocks.
public static boolean is valid nmtoken ( string nmtoken ) { final int length = nmtoken . length ( ) ; if ( length == num ) { return bool ; } for ( int i = num ; i < length ; ++ i ) { char ch = nmtoken . char at ( i ) ; if ( ! is name ( ch ) ) { return bool ; } } return bool ; }	check to see if a string is a valid nmtoken according to [ 7 ] in the xml 1 . 0 recommendation.
public mm ( mm rng ) { super ( num , num ) ; this . total = rng . random int ( this . faces ) + this . min ; all . add element ( this . total ) ; }	most tolls use standard six sided dice .
public void handle button3 request ( request invocation event event ) throws model control exception { return to home page ( ) ; }	handles return to home page request .
static < t > unix stream < t > unixify ( final stream < t > stream ) { objects . require non null ( stream , str ) ; return new unix stream impl < > ( stream ) ; }	create a new unixstream fro the given stream .
@ deprecated public media file ( file f ) { this ( f . to path ( ) , null ) ; }	instantiates a new media file .
public static key store load ( file key store file , password password , key store type key store type ) throws crypto exception , file not found exception { if ( ! key store type . is file based ( ) ) { throw new crypto exception ( message format . format ( res . get string ( str ) , key store type . jce ( ) ) ) ; } file input stream fis = new file input stream ( key store file ) ; key store key store = get key store instance ( key store type ) ; try { key store . load ( fis , password . to char array ( ) ) ; } catch ( certificate exception ex ) { throw new key store load exception ( message format . format ( res . get string ( str ) , key store type ) , ex , key store type ) ; } catch ( no such algorithm exception ex ) { throw new key store load exception ( message format . format ( res . get string ( str ) , key store type ) , ex , key store type ) ; } catch ( file not found exception ex ) { throw ex ; } catch ( io ex ) { throw new key store load exception ( message format . format ( res . get string ( str ) , key store type ) , ex , key store type ) ; } finally { io . close quietly ( fis ) ; } return key store ; }	load a keystore from a file accessed by a password .
public void dump log ( string container id , file log file ) throws docker exception , interrupted exception { log stream error stream = null ; file channel file channel = null ; file output stream file output stream = null ; try { if ( log file . exists ( ) ) { log file . delete ( ) ; } log file . create new file ( ) ; file output stream = new file output stream ( log file ) ; file channel = file output stream . get channel ( ) ; error stream = docker client . logs ( container id , logs param . stderr ( ) ) ; while ( error stream . has next ( ) ) { log message message = error stream . next ( ) ; byte buffer buffer = message . content ( ) ; file channel . write ( buffer ) ; } } catch ( file not found exception e ) { throw new docker exception ( str + log file + str ) ; } catch ( io e ) { throw new docker exception ( e ) ; } finally { if ( error stream != null ) { error stream . close ( ) ; } if ( file channel != null ) { try { file channel . close ( ) ; } catch ( io e ) { logger . error ( str , e ) ; } } if ( file output stream != null ) { try { file output stream . close ( ) ; } catch ( io e ) { logger . error ( str , e ) ; } } } }	helper method for dumping error logs from docker to file.
public static final void warning ( string message , throwable e ) { if ( message == null && e != null ) { message = e . get message ( ) ; } log expensive ( level . warning , message , e ) ; }	static version to log a warning message .
public static indexed image pack ( int [ ] rgb , int width , int height ) { int array length = width * height ; int [ ] temp palette = new int [ num ] ; int palette location = num ; for ( int iter = num ; iter < array length ; iter ++ ) { int current = rgb [ iter ] ; if ( ! contains ( temp palette , palette location , current ) ) { if ( palette location > num ) { return null ; } temp palette [ palette location ] = current ; palette location ++ ; } } if ( palette location != temp palette . length ) { int [ ] new array = new int [ palette location ] ; system . arraycopy ( temp palette , num , new array , num , palette location ) ; temp palette = new array ; } indexed image i = new indexed image ( width , height , temp palette , rgb ) ; return i ; }	packs the source rgba image and returns null if it fails.
public void add hint ( component hint component , component destination component , string position ) { hint component . put client property ( pos , position ) ; hint component . put client property ( dest , destination component ) ; vec . add element ( hint component ) ; }	places a hint within the glass in a position relative to the destinationcomponent , the position is indicated with border layout attributes.
public static int convert srg rgb ( int color ) { float input , output ; input = color / num ; if ( input <= num ) { output = input / num ; } else { output = ( float ) math . pow ( ( input + num ) / num , num ) ; } return math . round ( output * num ) ; }	helper function to convert a color component in srgb space to linear rgb space.
public void vetoable change ( property change event evt ) throws property veto exception { log . info ( evt . to string ( ) ) ; throw new property veto exception ( str , evt ) ; }	vetoable change . called from ccache to close connections.
public void finish ( ) throws sql { statement statement = connection . create statement ( ) ; statement . execute ( str ) ; statement . close ( ) ; statement = connection . create statement ( ) ; statement . execute ( str ) ; statement . close ( ) ; statement = connection . create statement ( ) ; statement . execute ( str ) ; statement . close ( ) ; statement = connection . create statement ( ) ; statement . execute ( str ) ; statement . close ( ) ; }	wraps up the index generation process and writes all remaining statements e.
public authorization code ( string code , string resource owner id , string client id , string redirect uri , set < string > scope , string claims , long expiry time , string nonce , string realm , string auth modules , string acr , string sso token id , string code challenge , string code challenge method , string auth grant id , string audit id ) { super ( new hash map < string , object > ( ) ) ; set string property ( id , code ) ; set string property ( username , resource owner id ) ; set string property ( client id , client id ) ; set string property ( redirect uri , redirect uri ) ; set string property ( expire time , string . value of ( expiry time ) ) ; put ( scope , new list ( scope ) ) ; set string property ( token type , str ) ; set string property ( token name , oauth code type ) ; set string property ( nonce , nonce ) ; set string property ( auth modules , auth modules ) ; set string property ( acr , acr ) ; set string property ( code challenge , code challenge ) ; set string property ( code challenge method , code challenge method ) ; set string property ( auth grant id , auth grant id ) ; set string property ( realm , realm == null || realm . is empty ( ) ? str : realm ) ; set string property ( sso token id , sso token id ) ; put ( claims , collection utils . as list ( claims ) ) ; set string property ( audit tracking id , audit id ) ; }	constructs a new authorizationcode .
@ override public object draw ( d g2 , d area , object params ) { draw ( g2 , area ) ; return null ; }	draws the block within the specified area .
public void test set bit positive inside3 ( ) { byte a bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = num ; int number = num ; byte r bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . set bit ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	setbit ( int n ) inside a positive number.
public boolean is row visible ( int row ) { if ( row != - num ) { rectangle cell rect = get cell rect ( row , num , bool ) ; rectangle visible rect = get visible rect ( ) ; return visible rect . intersects ( cell rect ) ; } else return bool ; }	determines if the given row is visible .
public static int file in time range ( file f , date start , date end ) { long time = get file time ( f ) ; if ( start != null && time < start . get time ( ) ) { return - num ; } if ( end != null && time > end . get time ( ) ) { return num ; } return num ; }	check if file is modified during that period.
public object ext function ( string ns , string func name , vector arg vec , object method key , expression context expr context ) throws javax . xml . transform . transformer exception { object result = null ; if ( null != ns ) { extension handler ext ns = ( extension handler ) m extension function namespaces . get ( ns ) ; if ( null != ext ns ) { try { result = ext ns . call function ( func name , arg vec , method key , expr context ) ; } catch ( javax . xml . transform . transformer exception e ) { throw e ; } catch ( exception e ) { throw new javax . xml . transform . transformer exception ( e ) ; } } else { throw new x ( xsl . create message ( xslt . er extension func unknown , new object [ ] { ns , func name } ) ) ; } } return result ; }	handle an extension function .
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m build thread . is alive ( ) && m state != idle ) { wait ( ) ; } } catch ( interrupted exception ex ) { } } else { notify all ( ) ; } }	function used to stop code that calls accepttrainingset.
public set < resource > on class ( ) { set < resource > targets = new hash set < > ( ) ; for ( owl class c : qc classes ) { targets . add ( c . get uri ( ) ) ; } return targets ; }	get all onclass relations for this property restriction .
public static int index of chars ( string str , string chars , int from index ) { final int len = str . length ( ) ; for ( int pos = from index ; pos < len ; pos ++ ) { if ( chars . index of ( str . char at ( pos ) ) >= num ) { return pos ; } } return - num ; }	like string . indexof ( ) except that it will look for any of the characters in ' chars ' ( similar to c ' s strpbrk ).
private synchronized void notify zoom listeners ( zoom event e ) { for ( zoom listener listener : m zoom listeners ) { listener . zoom applied ( e ) ; } }	notify the zoom listeners about a zoom change .
public static string build string from lines ( string ... lines ) { int num chars = lines . length ; for ( string line : lines ) { num chars += line . length ( ) ; } string builder builder = new string builder ( num chars ) ; for ( string line : lines ) { builder . append ( line ) ; builder . append ( str ) ; } return builder . to string ( ) ; }	easy way to create a string from a bunch of lines .
public void init ( ) { if ( m context == null ) { return ; } if ( m name . is empty ( ) ) { m name = m context . get package name ( ) ; } if ( m mode == invalid value || ( m mode != mode private && m mode != mode world readable && m mode != mode world writeable ) ) { m mode = mode private ; } m shared preferences = m context . get shared preferences ( m name , m mode ) ; }	initial the instance of the preferences manager .
@ override public void merge and output transformation metadata ( iterator < distinct value > values , string output dir , int col id , file system fs , tf utils agents ) throws io { double min = double . max value ; double max = - double . max value ; int nbins = num ; distinct value val = new distinct value ( ) ; string w = null ; double d ; while ( values . has next ( ) ) { val . reset ( ) ; val = values . next ( ) ; w = val . get word ( ) ; if ( w . starts with ( min prefix ) ) { d = util functions . parse to double ( w . substring ( min prefix . length ( ) ) ) ; if ( d < min ) min = d ; } else if ( w . starts with ( max prefix ) ) { d = util functions . parse to double ( w . substring ( max prefix . length ( ) ) ) ; if ( d > max ) max = d ; } else if ( w . starts with ( nbins prefix ) ) { nbins = ( int ) util functions . parse to long ( w . substring ( nbins prefix . length ( ) ) ) ; } else throw new runtime exception ( str + w ) ; } double binwidth = ( max - min ) / nbins ; write tf mtd ( col id , double . to string ( min ) , double . to string ( max ) , double . to string ( binwidth ) , integer . to string ( nbins ) , output dir , fs , agents ) ; }	method to merge map output transformation metadata .
static sql convert show warnings to sql ( connection connection ) throws sql { return convert show warnings to sql ( connection , num , bool ) ; }	turns output of ' show warnings ' into jdbc sqlwarning instances.
public boolean has empty row ( ) { if ( m data vector . size ( ) == num ) { return bool ; } list < string > data row = m data vector . get ( m data vector . size ( ) - num ) ; for ( string s : data row ) { if ( s . length ( ) != num ) { return bool ; } } return bool ; }	returns true if the model has an empty row.
public node select single node ( node context node , string str , node namespace node ) throws transformer exception { node iterator nl = select node iterator ( context node , str , namespace node ) ; return nl . next node ( ) ; }	use an xpath string to select a single node.
public synchronized void add ( string category , double value ) { m categories . add ( category ) ; m values . add ( value ) ; }	adds a new value to the series .
public final void walk graph ( hashtable sem nodes table ) { integer uid = new integer ( my uid ) ; if ( sem nodes table . get ( uid ) != null ) return ; sem nodes table . put ( uid , this ) ; if ( assume expr != null ) { assume expr . walk graph ( sem nodes table ) ; } ; }	walkgraph finds all reachable nodes in the semantic graph and inserts them in the hashtable semnodestable for use by the explorer tool .
private list < value combo box data group > populate symbol list ( class < ? > panel details ) { list < value combo box data group > combined symbol list = new array list < value combo box data group > ( ) ; for ( field state panel : symbol type field list ) { panel . populate symbol list ( panel details , combined symbol list ) ; } return combined symbol list ; }	populate symbol type list.
@ override public int hash code ( ) { long value = num ; value += num * value + double . double to long bits ( math . abs ( x ) ) ; value += num * value + double . double to long bits ( math . abs ( y ) ) ; return ( int ) ( value ^ ( value > > > num ) ) ; }	calcualates hashcode based on stored coordinates.
public void disconnect ( ) { socket . disconnect ( ) ; }	disconnects from the telemetry service.
protected void init component defaults ( ui table ) { super . init component defaults ( table ) ; color c = table . get color ( str ) ; table . put ( str , c ) ; table . put ( str , c ) ; }	for overwriting component defaults.
public int index of column name ( string column name ) { return column name list . index of ( column name . to lower case ( ) ) ; }	get index of this column name.
public boolean clear ( t expect , boolean allow reset ) { sync . lock ( ) ; try { if ( expect != value ) { return bool ; } value state prev = state ; clear ( allow reset ) ; return prev == value state . set ; } finally { sync . unlock ( ) ; } }	clears the cached value as long it matches the expected value .
public void copy stream ( input stream is ) throws io { super . set content encoding ( null ) ; byte array output stream baos = new byte array output stream ( ) ; while ( bool ) { int b = is . read ( ) ; if ( b == - num ) { content = baos . to byte array ( ) ; is . close ( ) ; return ; } } }	set the content by copying the given stream.
public void test read resolve ( ) { mock attributed character iterator attribute mac1 = new mock attributed character iterator attribute ( str ) ; try { mac1 . read resolve ( ) ; fail ( str ) ; } catch ( invalid object exception e ) { } object output stream out = null ; object input stream in = null ; try { byte array output stream bytes = new byte array output stream ( ) ; out = new object output stream ( bytes ) ; attributed character iterator . attribute attr1 , attr2 ; attr1 = attributed character iterator . attribute . language ; out . write object ( attr1 ) ; in = new object input stream ( new byte array input stream ( bytes . to byte array ( ) ) ) ; try { attr2 = ( attributed character iterator . attribute ) in . read object ( ) ; assert same ( str , attr1 , attr2 ) ; } catch ( illegal argument exception e ) { fail ( str + e ) ; } } catch ( io e ) { fail ( str + e ) ; } catch ( class not found exception e ) { fail ( str + e ) ; } finally { try { if ( out != null ) out . close ( ) ; if ( in != null ) in . close ( ) ; } catch ( io e ) { } } }	java . text . attributedcharacteriterator . attribute # readresolve ( ) test of method java . text . attributedcharacteriterator . attribute # readresolve ( ) .
public void interrupt ( ) { thread t = thread var . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } thread var . clear ( ) ; }	a new method that interrupts the worker thread.
public final boolean is secure ( socket sock ) throws illegal argument exception { if ( sock == null ) { throw new illegal argument exception ( str ) ; } if ( sock . get class ( ) != socket . class ) { throw new illegal argument exception ( str ) ; } if ( sock . is closed ( ) ) { throw new illegal argument exception ( str ) ; } return bool ; }	checks whether a socket connection is secure.
protected boolean check list ( string current val , string token value ) { if ( current val == null || token value == null ) { throw new null pointer exception ( str ) ; } if ( ! current val . starts with ( str ) && ! current val . starts with ( str ) ) { throw new illegal argument exception ( str ) ; } boolean negation = current val . starts with ( str ) ; string list name = current val . substring ( current val . index of ( str ) + num ) ; object list obj = list map . get ( list name ) ; if ( list obj == null ) return bool ; boolean contains ; if ( list obj instanceof set ) { set < string > set = ( set ) list obj ; contains = set . contains ( token value ) ; } else { throw new illegal argument exception ( str + list obj ) ; } return ! ( contains && negation || ! contains && ! negation ) ; }	checks if tokenvalue is contained in list.
public static synchronized void add native library dependencies ( string name , string ... dependency names ) { list < string > list = library dependencies . get ( name ) ; if ( list == null ) { library dependencies . put ( name , list = new array list < string > ( ) ) ; } for ( string dependency name : dependency names ) { if ( ! list . contains ( dependency name ) ) { list . add ( dependency name ) ; } } }	add names of library dependencies for a library.
@ override protected boolean has overflow ( r node ) { if ( node . is leaf ( ) ) { return node . get num entries ( ) == leaf capacity ; } else if ( node . get num entries ( ) == node . get capacity ( ) ) { node . increase entries ( ) ; } return bool ; }	returns true if in the specified node an overflow occurred , false otherwise .
public void process volume expansion ( storage system storage system , uri storage pool uri , uri volume id , cim [ ] out args ) throws exception { string builder log msg builder = new string builder ( string . format ( str ) ) ; cim connection connection = cim connection . get connection ( storage system ) ; wbem client = connection . get cim client ( ) ; storage pool storage pool = db client . query object ( storage pool . class , storage pool uri ) ; string map reservation map = storage pool . get reserved capacity map ( ) ; reservation map . remove ( volume id . to string ( ) ) ; update storage pool capacity ( client , storage pool ) ; db client . persist object ( storage pool ) ; volume volume = db client . query object ( volume . class , volume id ) ; cim volume path = ( cim ) cim path . get from output args ( out args , ibm . cp the element ) ; boolean is success = bool ; if ( volume path != null ) { cim volume instance = client . get instance ( volume path , bool , bool , null ) ; if ( volume instance != null ) { is success = bool ; volume . set provisioned capacity ( get provisioned capacity information ( volume instance ) ) ; volume . set allocated capacity ( get allocated capacity information ( client , volume instance ) ) ; db client . persist object ( volume ) ; log msg builder . append ( string . format ( str , volume . get capacity ( ) , volume . get provisioned capacity ( ) , volume . get allocated capacity ( ) ) ) ; } } if ( ! is success ) { unsigned integer32 return coede = ( unsigned integer32 ) cim path . get from output args ( out args , ibm . cp return code ) ; log msg builder . append ( str ) ; log msg builder . append ( string . format ( str , volume . get id ( ) , return coede . to string ( ) ) ) ; } log . info ( log msg builder . to string ( ) ) ; }	update db with smi - s output .
private void add best test suite ( file newly generated test suite ) { string test name = extract class name ( tmp tests , newly generated test suite ) ; string path = test name . replace ( str , file . separator ) + str ; file file = new file ( get best test folder ( ) + file . separator + path ) ; file . delete ( ) ; try { file utils . copy file ( newly generated test suite , file ) ; } catch ( io e ) { logger . error ( str + e . get message ( ) , e ) ; } }	from the test suites generated in the last ctg run , add the given one to the current best set.
@ override public void create connection factory ( string name , boolean ha , boolean use discovery , int cf type , string connectors , string bindings ) throws exception { create connection factory ( name , ha , use discovery , cf type , to array ( connectors ) , to array ( bindings ) ) ; }	create a jms connectionfactory with the specified name connected to a single live - backup pair of servers.
protected object evaluate single ( list elements , string expr ) { list array ; if ( elements instanceof java . util . vector ) { array = new java . util . vector ( ) ; } else { array = new array list ( ) ; } for ( iterator e = elements . iterator ( ) ; e . has next ( ) ; ) { object o = e . next ( ) ; if ( o instanceof structured content ) { if ( ( o = evaluate single ( ( structured content ) o , expr ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == num ) { return ( structured content ) array . get ( num ) ; } return array ; }	override this element to handle testing a predicate expression with no comparator.
protected void on close ( ) { }	override to trigger some behavior when the filesystem is closed.
private int do scale ( int number , double factor ) { return ( int ) strict math . round ( number * factor ) ; }	scales the given number with the provided scale factor.
private int parse message id ( final byte [ ] b , final int off ) throws parse exception { final int message id len = constants . message id len ; final int len = b . length - off ; if ( len >= message id len ) { message id = arrays . copy of range ( b , off , off + message id len ) ; return message id len ; } else { throw new parse exception ( str ) ; } }	parse the message id in the provided bytes.
public static string combine extensions ( final string [ ] extensions ) { check . not null ( extensions , str ) ; final string buffer ret = new string buffer ( ) ; for ( int i = num ; i < extensions . length ; i ++ ) { if ( i > num ) { ret . append ( str ) ; } ret . append ( extensions [ i ] ) ; } return ret . to string ( ) ; }	combines the given extensions strings into a single string , extensions separated by a comma .
public static void initialize properties ( string file ) throws missing resource exception { properties props = new properties ( ) ; resource bundle bundle = resource bundle . get bundle ( file ) ; for ( string key : bundle . key set ( ) ) { props . put ( key , bundle . get string ( key ) ) ; } initialize properties ( props , bool , bool ) ; }	initializes properties bundle from the < code > file < code > passed .
private string tweak native launch uri ( string uri , boolean for debugging , launch info launch info ) throws io , file not found exception { if ( launch info . is http or about ( ) ) { boolean modify = ( get preference ( pref uri modification ) != num ) ; if ( modify && for debugging && ! launch info . is about ( ) ) { uri = url . escape space ( uri ) ; url url helper = new url ( uri ) ; map < string , string > params = url helper . get parameter map ( ) ; params . put ( str , str ) ; url helper . set parameter map ( params ) ; uri = url helper . get url ( ) ; } } else { file f = null ; if ( uri . starts with ( str ) ) { try { f = new file ( new uri ( uri ) ) ; } catch ( uri e ) { io ioe = new io ( e . get message ( ) ) ; ioe . init cause ( e ) ; throw ioe ; } } else { f = new file ( uri ) ; } if ( f != null && f . exists ( ) ) { uri = f . get absolute path ( ) ; } else { throw new file not found exception ( uri ) ; } } return uri ; }	tweaks the launch uri if necessary , e.
public void add listener ( final listener listener ) { listeners . add ( listener ) ; }	adds a listener to the gui .
public list < t > query as list ( ) { quantum flux cursor < t > cursor = query as cursor ( ) ; try { list < t > result list = new array list < > ( cursor . get count ( ) ) ; while ( cursor . move to next ( ) ) { result list . add ( cursor . inflate ( ) ) ; } return result list ; } finally { if ( cursor != null ) cursor . close ( ) ; } }	does the same as the query cursor , but packs all of the cursor items into a list , once the list is populated , the cursor will be closed .
@ override public void profile ( ) { record stats ( ) ; }	profile memory usage and gc statistics.
public static final void save instance identifier ( string conf path , string instance identifier ) throws exception { path file = paths . get ( conf path , instance identifier file ) ; log . trace ( str , file ) ; atomic save . execute ( file . to string ( ) , str , instance identifier . get bytes ( standard charsets . utf 8 ) ) ; }	saves the instance identifier of this security server to file .
part ( string contents , string property ) throws exception { this . contents = str + contents ; this . property = property ; simplify ( ) ; }	create a new property by parsing the given string .
public static boolean is same ( object s1 , object s2 ) { if ( s1 == s2 ) return bool ; if ( x . is empty ( s1 ) && x . is empty ( s2 ) ) return bool ; if ( s1 != null ) { return s1 . equals ( s2 ) ; } return bool ; }	test whether equals the two objects .
public static double standard deviation ( double variance ) { return math . sqrt ( variance ) ; }	returns the standard deviation from a variance .
public void record gc ( region version vector < t > other ) { assert other . member to gc != null : str ; record gc ( other . my id , other . local gc . get ( ) ) ; for ( map . entry < t , long > entry : other . member to gc . entry set ( ) ) { record gc ( entry . get key ( ) , entry . get value ( ) . long value ( ) ) ; } }	record all of the gc versions in the given vector.
boolean wait for state ( processor p , int state ) { synchronized ( wait sync ) { try { while ( p . get state ( ) < state && state transition ok ) wait sync . wait ( ) ; } catch ( exception e ) { } } return state transition ok ; }	block until the processor has transitioned to the given state.
private static boolean extract file ( context c , string root asset , string path ) { asset manager asset manager = c . get assets ( ) ; input stream in = null ; output stream out = null ; try { in = asset manager . open ( root asset + path ) ; string full path = pref store . get env dir ( c ) + path ; out = new file output stream ( full path ) ; byte [ ] buffer = new byte [ num ] ; int read ; while ( ( read = in . read ( buffer ) ) != - num ) { out . write ( buffer , num , read ) ; } out . flush ( ) ; } catch ( io e ) { e . print stack trace ( ) ; return bool ; } finally { close ( in ) ; close ( out ) ; } return bool ; }	extract file to env directory.
protected int never ( ) { synchronized ( sleep lock ) { while ( running ) { try { sleep lock . wait ( num * num * num ) ; } catch ( interrupted exception e ) { continue ; } } return num ; } }	method that never returns , e.
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return message type ; case num : return request info ; case num : return response info ; case num : return trace info ; case num : return global context ; case num : return local context ; case num : return heartbeat info ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
protected void load history ( boolean set ) { buffered input stream str ; file file ; int width ; int height ; try { file = new file ( get history filename ( ) ) ; if ( file . exists ( ) ) { str = new buffered input stream ( new file input stream ( get history filename ( ) ) ) ; m . load ( str ) ; } } catch ( exception e ) { e . print stack trace ( ) ; } if ( set ) { m . set history ( string to model ( m . get property ( connection panel . history name , str ) ) ) ; m . set history ( string to model ( m . get property ( query panel . history name , str ) ) ) ; m . set max rows ( integer . parse int ( m . get property ( query panel . max rows , str ) ) ) ; width = integer . parse int ( m . get property ( width , str ) ) ; height = integer . parse int ( m . get property ( height , str ) ) ; if ( ( width != num ) && ( height != num ) ) { set preferred size ( new dimension ( width , height ) ) ; } } }	loads the history properties of the sqlviewer in the user ' s home directory .
private void update panel for expansion ( float percentage ) { update promo visibility ( num ) ; float base base y = math utils . interpolate ( num , get base page target y ( ) , percentage ) ; m base page y = base base y ; float brightness = math utils . interpolate ( base page brightness state peeked , base page brightness state expanded , percentage ) ; m base page brightness = brightness ; float search bar height = math . round ( math utils . interpolate ( m search bar height peeking , get search bar height expanded ( ) , percentage ) ) ; m search bar height = search bar height ; m search bar text opacity = num ; m is search bar border visible = bool ; m search bar border y = search bar height - search bar border height dp + num ; m search icon opacity = search icon opacity state expanded ; m arrow icon opacity = arrow icon opacity state expanded ; m arrow icon rotation = math . round ( math utils . interpolate ( arrow icon rotation state peeked , arrow icon rotation state expanded , percentage ) ) ; m close icon opacity = close icon opacity state expanded ; float peeked height = get panel height from state ( panel state . peeked ) ; float threshold = progress bar visibility threshold dp / m px to dp ; float diff = math . min ( m height - peeked height , threshold ) ; float progress bar opacity = math utils . interpolate ( num , num , diff / threshold ) ; m progress bar opacity = progress bar opacity ; m progress bar y = search bar height - progress bar height dp + num ; update search bar shadow ( ) ; }	updates the ui state for the peeked to expanded transition ( and vice versa ) , according to a completion | percentage | .
protected boolean [ ] updateable clusterer ( ) { boolean [ ] result = new boolean [ num ] ; print ( str ) ; if ( m instanceof updateable clusterer ) { println ( str ) ; result [ num ] = bool ; } else { println ( str ) ; result [ num ] = bool ; } return result ; }	checks whether the scheme can build models incrementally .
public void add field ( mapped member mm ) { fields . add ( mm ) ; }	add a field to the class.
public static list < base mqtt message > read and convert message log ( final file selected file ) throws spy exception { final list < string > lines = file utils . read file as lines ( selected file ) ; logger . info ( str , lines . size ( ) , selected file . get absolute file ( ) ) ; return process message log ( parse message log ( lines , null , num , num ) , null , num , num ) ; }	this all - in - one method reads a message log from the given file and turns that into a list of mqtt message objects .
void read stream ( input stream is ) throws exception { string line ; date start = new date ( ) ; buffered reader reader = new buffered reader ( new input stream reader ( is ) ) ; while ( ( line = reader . read line ( ) ) != null && ! m stop ) { m results . append ( line ) ; m results . append ( tools . line sep ) ; date end = new date ( ) ; if ( ( end . get time ( ) - start . get time ( ) ) / num > num || m results . length ( ) > num ) { start = end ; int last = m results . last index of ( str ) ; if ( last != - num ) { xmpp msg msg = new xmpp msg ( font ) ; msg . append ( m results . substring ( num , last + num ) ) ; m cmd base . send ( m shell id , msg ) ; m results . set length ( num ) ; } } } }	reads the given inputstream and sends a xmppmsg every 5000 chars or every 10 seconds , whatever comes first.
public void remove parent relation ( long osm id ) { if ( parent relations != null ) { array list < relation > temp rel list = new array list < relation > ( parent relations ) ; for ( relation r : temp rel list ) { if ( osm id == r . get osm id ( ) ) parent relations . remove ( r ) ; } } }	remove reference to parent relation.
public final void test roundtrip ( ) { boolean performed = bool ; for ( int i = num ; i < alg name . length ; i ++ ) { try { test data generator g = new test data generator ( alg name [ i ] [ num ] , alg name [ i ] [ num ] , private key info , null ) ; encrypted private key info epki ; if ( g . ap ( ) == null ) { epki = new encrypted private key info ( alg name [ i ] [ num ] , g . ct ( ) ) ; } else { epki = new encrypted private key info ( g . ap ( ) , g . ct ( ) ) ; } try { pkc eks = epki . get key spec ( g . c ( ) ) ; if ( ! arrays . equals ( private key info , eks . get encoded ( ) ) ) { fail ( alg name [ i ] [ num ] + str + alg name [ i ] [ num ] ) ; } } catch ( invalid key spec exception e ) { fail ( alg name [ i ] [ num ] + str + alg name [ i ] [ num ] + e + str ) ; } performed = bool ; } catch ( test data generator . allowed failure allowed failure ) { } catch ( no such algorithm exception allowed ) { } } assert true ( str , performed ) ; }	encrypted data contains valid pkcs8 key info encoding.
void insert ( v val , k key ) { array list < k > list = map . get ( val ) ; if ( list == null ) { list = new array list < k > ( num ) ; map . put ( clone value ( val ) , list ) ; } list . add ( key ) ; }	returns the arraylist stored for a key.
public server socket create server socket ( int nport , int backlog ) throws io { return create server socket ( nport , backlog , null ) ; }	return a serversocket possibly configured for ssl.
public static array list < integer > convert string array to integer array ( list < string > array list ) { array list < integer > integers = new array list < > ( ) ; for ( string str : array list ) { integers . add ( integer . value of ( str ) ) ; } return integers ; }	create a integer arraylist from string arraylist.
public static string build selector from class ( string class value ) { string builder strb = new string builder ( ) ; strb . append ( class selector prefix ) ; strb . append ( class value ) ; return strb . to string ( ) ; }	create a selector of the form . $ classvalue.
public void ensure capacity ( int minimum capacity ) { if ( minimum capacity > value . length ) { int our min = value . length * num + num ; enlarge buffer ( math . max ( our min , minimum capacity ) ) ; } }	ensures that the capacity of the buffer is at least equal to the specified minimum.
public string pool footer statements ( ) { string builder sb = new string builder ( ) ; for ( string footer statement : footer statements ) { sb . append ( str ) ; sb . append ( footer statement ) ; sb . append ( str ) ; } footer statements . clear ( ) ; return sb . to string ( ) ; }	gets and clears the footer statements .
private void handle node queue ( serial message incoming message ) { if ( current stage == z . done ) { return ; } logger . debug ( str , node . get node id ( ) , msg queue . size ( ) ) ; if ( msg queue . contains ( incoming message ) ) { msg queue . remove ( incoming message ) ; logger . debug ( str , node . get node id ( ) , msg queue . size ( ) ) ; free to send = bool ; advance node stage ( incoming message . get message class ( ) ) ; } else if ( msg queue . is empty ( ) && current stage == z . security report ) { logger . debug ( str , node . get node id ( ) ) ; advance node stage ( incoming message . get message class ( ) ) ; } }	handles the removal of frames from the send queue.
public static predicate < string > matches ( final string regexp ) { objects . require non null ( regexp , str ) ; return null ; }	create a new predicate returning true when the input string matches the given regexp .
public boolean has set ( string name ) { return m map . contains key ( name ) ; }	indicates if this composite contains a tupleset with the given name .
public void clear parsers ( ) { timer . stop ( ) ; clear parser notice highlights ( ) ; parsers . clear ( ) ; text area . fire parser notices change ( ) ; }	removes all parsers and any highlights they have created .
protected property definition ( abstract managed object definition < ? , ? > d , class < t > the class , string property name , enum set < property option > options , administrator action admin action , default behavior provider < t > default behavior ) { reject . if null ( d , the class , property name , options , admin action , default behavior ) ; this . definition = d ; this . the class = the class ; this . property name = property name ; this . options = enum set . copy of ( options ) ; this . admin action = admin action ; this . default behavior = default behavior ; }	create a property definition .
public date time parse exception ( string message , char sequence parsed data , int error index , throwable cause ) { super ( message , cause ) ; this . parsed string = parsed data . to string ( ) ; this . error index = error index ; }	constructs a new exception with the specified message and cause .
public nb ( xml attribute count xml attribute count ) { this . xml attribute count = xml attribute count ; init components ( ) ; final iterate model number of tags iterator = xml attribute count . get number of attributes iterator ( ) ; configure iterate model n . set start at ( string . value of ( number of tags iterator . get start at ( ) ) ) ; configure iterate model n . set stop at ( string . value of ( number of tags iterator . get stop at ( ) ) ) ; configure iterate model n . set increment ( string . value of ( number of tags iterator . get increment ( ) ) ) ; configure iterate model n . set iterate strategie ( number of tags iterator . get iterate strategie ( ) ) ; list < string > names = arrays . as list ( xml attribute count . get names ( ) ) ; configure string list n . set string list ( names ) ; }	creates new form configurecoerceiveparsingdialog_nb.
public void on menu dismissed ( ) { m reload menu item = null ; }	notify the delegate that menu was dismissed .
public static thread consume process output stream ( process self , output stream output ) { thread thread = new thread ( new byte dumper ( self . get input stream ( ) , output ) ) ; thread . start ( ) ; return thread ; }	gets the output stream from a process and reads it to keep the process from blocking due to a full output buffer.
public static angle great circle azimuth ( lat lon p1 , lat lon p2 ) { if ( ( p1 == null ) || ( p2 == null ) ) { throw new illegal argument exception ( str ) ; } double lat1 = p1 . get latitude ( ) . radians ; double lon1 = p1 . get longitude ( ) . radians ; double lat2 = p2 . get latitude ( ) . radians ; double lon2 = p2 . get longitude ( ) . radians ; if ( lat1 == lat2 && lon1 == lon2 ) return angle . zero ; if ( lon1 == lon2 ) return lat1 > lat2 ? angle . po : angle . zero ; double y = math . cos ( lat2 ) * math . sin ( lon2 - lon1 ) ; double x = math . cos ( lat1 ) * math . sin ( lat2 ) - math . sin ( lat1 ) * math . cos ( lat2 ) * math . cos ( lon2 - lon1 ) ; double azimuth radians = math . atan2 ( y , x ) ; return double . is na n ( azimuth radians ) ? angle . zero : angle . from radians ( azimuth radians ) ; }	computes the azimuth angle ( clockwise from north ) that points from the first location to the second location.
public void add all tags of ( host h ) { list < tag > tags = h . get tags ( ) ; if ( tags . is empty ( ) ) return ; if ( m tag list == null ) { m tag list = new array list < tag > ( tags . size ( ) ) ; } m tag list . add all ( tags ) ; }	adds all the tags from h to this host .
public static boolean is numbers with punctuation ( string token ) { boolean has digit = bool ; int len = token . length ( ) ; for ( int i = num ; i < len ; ++ i ) { char c = token . char at ( i ) ; has digit = has digit || character . is digit ( c ) ; if ( ! ( character . is digit ( c ) || characters . is punctuation ( c ) ) ) { return bool ; } } return has digit ; }	true if the input string contains at least one digit and 0 or more punctuation characters.
private boolean is paint line seperators ( j c ) { boolean paint lines = c instanceof j ; string global override = system . get property ( str ) ; if ( global override != null && global override . length ( ) > num ) { paint lines = boolean . value of ( global override ) ; } boolean override property = ( boolean ) c . get client property ( str ) ; if ( override property != null ) { paint lines = override property ; } return paint lines ; }	test if we should also paint the line seperators .
public static db open ( data source ds ) { try { return new db ( ds . get connection ( ) ) ; } catch ( sql e ) { throw convert ( e ) ; } }	create a new database instance using a data source.
@ override public void basic put part3 ( entry event impl event , region entry entry , boolean is initialized , long last modified , boolean invoke callbacks , boolean if new , boolean if old , object expected old value , boolean require old value ) { distribute update ( event , last modified , bool , bool , null , bool ) ; super . basic put part3 ( event , entry , is initialized , last modified , invoke callbacks , if new , if old , expected old value , require old value ) ; }	distribution and listener notification.
public language range ( string range ) { this . range = range . split ( str ) ; full = range ; }	note range must be in lower case , this is not verified .
protected void remove container ( ) throws throwable { if ( container id == null ) { return ; } send delete container request ( ) ; wait for property value ( provisioning task link , mock task state . class , str , task state . task stage . finished ) ; if ( ! is mock target ( ) ) { thread . sleep ( num ) ; } verify container does not exist ( container id ) ; }	remove the container previously created using createcontainer ( ).
public int size ( ) { return list . size ( ) ; }	returns the number of elements in this set ( its cardinality ) .
public transformer handler new transformer handler ( templates templates ) throws transformer configuration exception { try { transformer impl transformer = ( transformer impl ) templates . new transformer ( ) ; transformer . set uri ( m uri resolver ) ; transformer handler th = ( transformer handler ) transformer . get input content handler ( bool ) ; return th ; } catch ( transformer configuration exception ex ) { if ( m error listener != null ) { try { m error listener . fatal error ( ex ) ; return null ; } catch ( transformer configuration exception ex1 ) { throw ex1 ; } catch ( transformer exception ex1 ) { throw new transformer configuration exception ( ex1 ) ; } } throw ex ; } }	get a transformerhandler object that can process sax contenthandler events into a result , based on the templates argument .
public void add field ( field ref fref ) { m field refs . add ( fref ) ; }	adds the field to the field list .
public string render ( value expr the expr ) throws exception { reset ( ) ; the expr . visit ( this ) ; return m buffer . to string ( ) ; }	return the rendering of the valueexpr object.
public void add ( final d [ ] b loop ) throws math illegal argument exception { add ( new nested loops ( b loop , tolerance ) ) ; }	add a loop in a tree .
@ not null public static < t > list < t > as list ( @ nullable final collection < ? > expression , @ not null final class < t > element class ) { if ( ( expression == null ) || expression . is empty ( ) ) { return collections . empty list ( ) ; } final list < t > result = new array list < t > ( ) ; for ( final object element : expression ) { final t to add = as ( element , element class ) ; if ( to add != null ) { result . add ( to add ) ; } } return result ; }	converts collection to list of certain type.
private void start new transition ( ) { if ( ! has bounds ( ) ) { return ; } m current trans = m trans gen . generate next transition ( m drawable rect , m viewport rect ) ; m elapsed time = num ; m last frame time = system . current time millis ( ) ; fire transition start ( m current trans ) ; }	generates and starts a transition .
@ override protected void make finished ( ) { byte [ ] verify data ; if ( server hello . server version [ num ] == num ) { verify data = new byte [ num ] ; computer verify data tls ( str , verify data ) ; } else { verify data = new byte [ num ] ; computer verify data ss ( ss . client , verify data ) ; } client finished = new finished ( verify data ) ; send ( client finished ) ; if ( is resuming ) { session . last accessed time = system . current time millis ( ) ; status = finished ; } else { if ( server hello . server version [ num ] == num ) { computer reference verify data tls ( str ) ; } else { computer reference verify data ss ( ss . server ) ; } status = need unwrap ; } }	creates and sends finished message.
public static file remove extension ( file file ) { string absolute path = file . get absolute path ( ) ; if ( absolute path . contains ( str ) ) { return new file ( absolute path . substring ( num , absolute path . last index of ( str ) ) ) ; } else { return file ; } }	remove the last extension of file.
public void update ( ) { if ( bg is opaque ) { int w = math . max ( get size ( ) . width , min width ) ; int h = math . max ( get size ( ) . height , min height ) ; off scr = create image ( w , h ) ; if ( off scr == null ) return ; graphics g = off scr . get graphics ( ) ; draw into ( g ) ; repaint ( ) ; g . dispose ( ) ; } else { repaint ( ) ; } }	updates all changes in areas state and repaints component .
public static final int read int ( input stream is ) throws io { return ( ( ( num & is . read ( ) ) << num ) | ( num & is . read ( ) ) ) ; }	reads a two byte integer value from an inputstream .
private void save dynamic actions ( faces context context , state context state context , map < string , object > state map ) { if ( logger . is loggable ( level . finest ) ) { logger . finest ( str ) ; } list < component struct > actions = state context . get dynamic actions ( ) ; hash map < string , ui > component map = state context . get dynamic components ( ) ; if ( actions != null ) { list < object > saved actions = new array list < > ( actions . size ( ) ) ; for ( component struct action : actions ) { ui component = component map . get ( action . client id ) ; if ( component == null && context . is project stage ( project stage . development ) ) { logger . log ( level . warning , str , action . client id ) ; } if ( component != null ) { saved actions . add ( action . save state ( context ) ) ; } } state map . put ( dynamic actions , saved actions ) ; } }	save the dynamic actions .
private instance generate example ( instances format , random random g , subspace cluster definition cl , string c name ) { boolean make integer = cl . is integer ( ) ; int num = - num ; instance example = null ; int num atts = m ; if ( get class flag ( ) ) { num atts ++ ; } example = new dense instance ( num atts ) ; example . set dataset ( format ) ; boolean [ ] attributes = cl . get attributes ( ) ; double [ ] min value = cl . get min value ( ) ; double [ ] max value = cl . get max value ( ) ; double value ; int cluster i = - num ; for ( int i = num ; i < m ; i ++ ) { if ( attributes [ i ] ) { cluster i ++ ; num ++ ; if ( is boolean ( i ) || is nominal ( i ) ) { if ( min value [ cluster i ] == max value [ cluster i ] ) { value = min value [ cluster i ] ; } else { int num values = ( int ) ( max value [ cluster i ] - min value [ cluster i ] + num ) ; value = random g . next int ( num values ) ; value += min value [ cluster i ] ; } } else { value = random g . next double ( ) * ( max value [ num ] - min value [ num ] ) + min value [ num ] ; if ( make integer ) { value = math . round ( value ) ; } } example . set value ( i , value ) ; } else { example . set missing ( i ) ; } } if ( get class flag ( ) ) { example . set class value ( c name ) ; } return example ; }	generate an example of the dataset .
@ override public long skip ( long n ) { if ( n < num ) { throw new illegal argument exception ( str + n ) ; } if ( idx >= char sequence . length ( ) ) { return - num ; } int dest = ( int ) math . min ( char sequence . length ( ) , idx + n ) ; int count = dest - idx ; idx = dest ; return count ; }	skip the specified number of characters .
public default console panel ( ) { set layout ( new border layout ( num , num ) ) ; text pane = new j ( ) ; text pane . set rows ( num ) ; text pane . set editable ( bool ) ; j jp = new j ( text pane ) ; add ( jp , border layout . center ) ; }	instantiates a new console panel .
public void push ( ) { level . add ( null ) ; cloned = bool ; }	push a frame for a node.
private static void load plugins from class loader ( class loader class loader ) { service loader < gds > plugin loader = service loader . load ( gds . class , class loader ) ; for ( gds plugin : plugin loader ) { register plugin ( plugin ) ; } }	load all existing plugins from the specified class loader .
public string redo ( ) { if ( ! can redo ( ) ) { return str ; } m n current edit action ++ ; undo action undo action = m undo stack . get ( m n current edit action ) ; m b needs undo action = bool ; undo action . redo ( ) ; m b needs undo action = bool ; return undo action . get redo msg ( ) ; }	redo the last edit action performed on the network.
@ override public inet socket address ip local ( ) { socket channel s = channel ; if ( s != null ) { try { return ( inet socket address ) s . get local address ( ) ; } catch ( io e ) { throw new runtime exception ( e ) ; } } else { return null ; } }	returns the server inet address that accepted the request .
@ nonnull private static node disk find node disk ( string disk id , list < node disk > node disks , string node name ) throws io { node disk selected = null ; for ( node disk node disk : node disks ) { if ( disk id . equals ( node disk . get disk ref id ( ) ) ) { selected = node disk ; break ; } } if ( selected == null ) { string message = format ( str , node name , disk id ) ; throw new abort exception ( message ) ; } if ( selected . get node mount point ( ) == null ) { string message = format ( str , node name , disk id ) ; throw new abort exception ( message ) ; } return selected ; }	finds the disk definition from the given disks list that matches the given disk id .
private int strip multipart headers ( byte [ ] b , int offset ) { int i = num ; for ( i = offset ; i < b . length ; i ++ ) { if ( b [ i ] == str && b [ ++ i ] == str && b [ ++ i ] == str && b [ ++ i ] == str ) break ; } return i + num ; }	it returns the offset separating multipart file headers from the file ' s data .
void seek ( int position ) throws io { m dex file . seek ( position ) ; }	seeks the dex file to the specified absolute position .
@ override public list < column > columns ( ) { return column list ; }	returns the list of columns.
public static void write float ( data output stream dos , boolean is big endian , float val ) throws io { if ( ! is big endian ) { write little endian float ( dos , val ) ; } else { dos . write float ( val ) ; } }	write a float from the output stream , byte - swapping as necessary.
public void test flip bit positive inside1 ( ) { byte a bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = num ; int number = num ; byte r bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , - num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . flip bit ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	flipbit ( int n ) inside a positive number.
public static instruction osr helper ( instruction barrier , generation context gc ) { instruction inst = osr point . create ( yieldpoint osr , null , num ) ; gc . save osr ( barrier , inst ) ; return inst ; }	creates an osr point instruction with its dependent osrbarrier which provides type and variable information.
protected void initialize state ( s current ) { initialization utils . initialize ( current ) ; if ( current . document expiration time micros <= num ) { current . document expiration time micros = service utils . compute expiration time ( service utils . default doc expiration time micros ) ; } }	initialize state with defaults .
@ suppress warnings ( str ) public input stream fetch volume stats ( final argument argument , final map < string , object > key map , int index ) throws vnx { logger . info ( str ) ; input stream i stream = null ; list < query stats > stat list = new array list < query stats > ( ) ; try { set < string > movers = ( set < string > ) key map . get ( vnx . moverlist ) ; if ( null != movers && ! movers . is empty ( ) ) { for ( string mover id : movers ) { query stats query stats = new query stats ( ) ; volume stats set query params params = new volume stats set query params ( ) ; params . set stats set ( volume stats set type . all ) ; params . set mover ( mover id ) ; query stats . set volume stats ( params ) ; stat list . add ( query stats ) ; } i stream = vnx file input request builder . get multi request query stats packet ( stat list ) ; } else { logger . error ( str ) ; } } catch ( jaxb jaxb exception ) { throw new vnx ( str , jaxb exception . get cause ( ) ) ; } return i stream ; }	create volume stats xml request query and returns a stream after marshalling .
private static boolean is directory ( url url ) { string file = url . get file ( ) ; return ( file . length ( ) > num && file . char at ( file . length ( ) - num ) == str ) ; }	determines if the url is pointing to a directory .
@ override public final string read utf ( ) throws io { return dis . read utf ( ) ; }	read utf counted string .
@ nullable public static network parameters from id ( string id ) { if ( id . equals ( id mainnet ) ) { return main net params . get ( ) ; } else if ( id . equals ( id testnet ) ) { return test net3 params . get ( ) ; } else if ( id . equals ( id unittestnet ) ) { return unit test params . get ( ) ; } else { return null ; } }	returns the network parameters for the given string id or null if not recognized .
final synchronized void release socket ( ) { running = bool ; sender . interrupt ( ) ; outbound messages . clear ( ) ; if ( socket != null ) { socket . close ( ) ; socket = null ; } maximum transmission unit = num ; }	stops the sender and receiver threads and closes the socket used for sending and receiving datagrams .
public boolean add part ( pdu part part ) { if ( null == part ) { throw new null pointer exception ( ) ; } put part to maps ( part ) ; return m parts . add ( part ) ; }	appends the specified part to the end of this body .
public string code owner ( list < code owner > code owners ) { long current unix = system . current time millis ( ) / num ; double best = num ; string owner = str ; for ( code owner code owner : code owners ) { double age = ( current unix - code owner . get most recent unix commit timestamp ( ) ) / num / num ; double calc = code owner . get no lines ( ) / math . pow ( ( age ) , num ) ; if ( calc > best ) { best = calc ; owner = code owner . get name ( ) ; } } return owner ; }	determines who owns a piece of code weighted by time based on current second ( ie time now ) nb if a commit is very close to this time it will always win.
public map read ( sso token , string obj name ) throws sms , sso { if ( obj name == null || obj name . length ( ) == num ) { throw new illegal argument exception ( str ) ; } string obj key = obj name . to lower case ( ) ; map attr map = null ; m rw . read request ( ) ; try { string filepath = m name map . get property ( obj key ) ; if ( filepath == null ) { if ( m debug . message enabled ( ) ) { m debug . message ( str + obj name + str ) ; } } else { file filehandle = new file ( filepath ) ; properties props = null ; try { props = load properties ( filehandle , obj name ) ; } catch ( service not found exception e ) { } if ( props != null ) { attr map = new case insensitive hash map ( ) ; enumeration keys = props . property names ( ) ; while ( keys . has more elements ( ) ) { string key = ( string ) keys . next element ( ) ; string vals = props . get property ( key ) ; if ( ( vals != null ) && ( vals . length ( ) > num ) ) { attr map . put ( key , to val set ( key , vals ) ) ; } } } } } finally { m rw . read done ( ) ; } return attr map ; }	reads in attributes of a configuration object .
public static double parse double ( string s ) { s = s . trim ( ) ; int length = s . length ( ) ; if ( length == num ) { throw invalid real ( s , bool ) ; } char last = s . char at ( length - num ) ; if ( last == str || last == str ) { return parse name ( s , bool ) ; } string exponent pair info = initial parse ( s , length , bool ) ; if ( info . infinity || info . zero ) { return info . special value ( ) ; } double result = parse dbl impl ( info . s , ( int ) info . e ) ; if ( double . double to long bits ( result ) == num ) { throw invalid real ( s , bool ) ; } return info . negative ? - result : result ; }	returns the closest double value to the real number in the string .
public byte read byte ( ) throws io { byte v = data input . read byte ( ) ; offset += num ; available -= num ; return v ; }	reads a single byte .
public static i [ ] random points ( int n , int d ) { i points [ ] = new i [ n ] ; for ( int i = num ; i < n ; i ++ ) { string builder sb = new string builder ( ) ; for ( int j = num ; j < d ; j ++ ) { sb . append ( r gen . next double ( ) ) ; if ( j < d - num ) { sb . append ( str ) ; } } points [ i ] = new hyperpoint ( sb . to string ( ) ) ; } return points ; }	generate array of n d - dimensional points whose coordinates are values in the range 0.
private string verify restore code ( string restore code , string code ) { if ( code == null ) { return str ; } if ( restore code == null ) { return str ; } boolean valid code = password manager . matches ( code , restore code ) ; return valid code ? null : str + code + str + restore code + str ; }	verifies a user supplied restore code against the stored restore code.
public static void append padded integer ( string buffer buf , long value , int size ) { int int value = ( int ) value ; if ( int value == value ) { append padded integer ( buf , int value , size ) ; } else if ( size <= num ) { buf . append ( long . to string ( value ) ) ; } else { if ( value < num ) { buf . append ( str ) ; if ( value != long . min value ) { value = - value ; } else { for ( ; size > num ; size -- ) { buf . append ( str ) ; } buf . append ( str ) ; return ; } } int digits = ( int ) ( math . log ( value ) / log 10 ) + num ; for ( ; size > digits ; size -- ) { buf . append ( str ) ; } buf . append ( long . to string ( value ) ) ; } }	converts an integer to a string , prepended with a variable amount of ' 0 ' pad characters , and appends it to the given buffer.
@ override public void flush ( ) { if ( ! queue . is empty ( ) ) { list < alert stream event > events = new array list < > ( ) ; queue . drain to ( events ) ; events . for each ( null ) ; log . info ( str , events . size ( ) ) ; } last flush time . set ( system . current time millis ( ) ) ; }	flush will be called in synchronous way like stormbolt . execute ( ) as storm outputcollector is not thread - safe.
@ override public void add undo point ( ) { file temp file ; object output stream oos ; if ( ! is undo enabled ( ) ) { return ; } if ( get instances ( ) != null ) { try { temp file = file . create temp file ( str , null ) ; temp file . delete on exit ( ) ; oos = new object output stream ( new buffered output stream ( new file output stream ( temp file ) ) ) ; oos . write object ( get instances ( ) ) ; oos . flush ( ) ; oos . close ( ) ; m . add ( temp file ) ; } catch ( exception e ) { e . print stack trace ( ) ; } } }	adds an undo point to the undo history , if the undo support is enabled.
public final void add child node ( row regex expr node child node ) { child nodes . add ( child node ) ; }	adds a child node .
private list < string > make list ( final string ... strings ) { final list < string > result = new array list < > ( ) ; for ( string string : strings ) { result . add ( string ) ; } return result ; }	builds a list from the parameters .
public int number of shards with state ( shard routing state ... states ) { int count = num ; for ( shard routing shard entry : this ) { for ( shard routing state state : states ) { if ( shard entry . state ( ) == state ) { count ++ ; } } } return count ; }	determine the number of shards with a specific state.
@ override public void notify commit ( final long commit time ) { lock . lock ( ) ; try { update release time for bare commit ( commit time ) ; } finally { lock . unlock ( ) ; } }	the basic implementation advances the release time periodically as commits occur even when there are no transactions in use.
public static int show yes no cancel question ( final component parent , final string msg ) { return j . show confirm dialog ( is iconified ( parent ) ? null : parent , msg , system . get property ( default window title property ) , j . yes no cancel option , j . question message ) ; }	shows a question the user can answer with yes / no / cancel .
public static string quantityplnoun creature ( final int quantity , final string noun ) { if ( noun . equals ( str ) ) { final string end = plnoun creature ( quantity , noun ) ; return integer . to string ( quantity ) + str + end ; } return quantityplnoun ( quantity , noun ) ; }	returns either the plural or singular form of the given noun , depending on the quantity ; also prefixes the quantity . method to prevent collision of items and creatures.
static int copy bytes ( output stream os , input stream is , byte [ ] io buffer , int max size ) throws io { int total size = num ; while ( total size < max size ) { int rc = is . read ( io buffer , num , math . min ( max size - total size , io buffer . length ) ) ; if ( rc == - num ) { break ; } os . write ( io buffer , num , rc ) ; total size += rc ; } return total size ; }	pumps all the bytes ( but no more that maxsize ) from given input stream through iobuffer to given output stream and returns number of moved bytes .
void compose message ( final mail mail , final string text content , final string html content , final map < string , byte [ ] > attachments , final list < string > mail template chain , final string shop code , final string locale , final string template name ) throws messaging exception , class not found exception , io { if ( text content == null || html content == null ) { if ( text content != null ) { mail . set text version ( text content ) ; } if ( html content != null ) { mail . set html version ( html content ) ; inline resources ( mail , html content , mail template chain , shop code , locale , template name ) ; add attachments ( mail , attachments ) ; } } else { mail . set text version ( text content ) ; mail . set html version ( html content ) ; inline resources ( mail , html content , mail template chain , shop code , locale , template name ) ; add attachments ( mail , attachments ) ; } }	fill mail message . at least one of the templates must be given .
private void handle launch message event ( message event message event ) { data map data map = data map . from byte array ( message event . get data ( ) ) ; boolean relaunch if running = data map . get boolean ( key start activity relaunch , bool ) ; data map bundle data = data map . get data map ( key start activity bundle ) ; string activity name = data map . get string ( key start activity name ) ; bundle bundle = null ; if ( bundle data != null ) { bundle = bundle data . to bundle ( ) ; } if ( activity name == null ) { for ( wear consumer consumer : m wear consumers ) { consumer . on wearable application launch request received ( bundle , relaunch if running ) ; } } else { try { if ( ! text utils . is empty ( activity name ) ) { class < ? > target activity = class . for name ( activity name ) ; intent intent = new intent ( m context , target activity ) ; intent . set flags ( intent . flag activity new task ) ; if ( bundle != null ) { intent . put extras ( bundle ) ; } if ( ! m app foreground || relaunch if running ) { m context . start activity ( intent ) ; } } else { log . e ( tag , str ) ; } } catch ( class not found exception e ) { log . e ( tag , str , e ) ; } } }	handles the special message to launch an activity .
@ override public void close ( ) throws io { closed = bool ; def . end ( ) ; in . close ( ) ; }	closes the underlying input stream and discards any remaining uncompressed data .
public static string escape colon in string ( string str ) { if ( str != null ) { if ( str . index of ( str ) >= num ) { str = str . replace all ( str , str ) ; } } return str ; }	escapes colons ( " : " ) in the supplied string to " & # 58 ; ".
protected void tear down ( ) throws exception { file file ; file = new file ( m ) ; if ( file . exists ( ) ) file . delete ( ) ; m = null ; super . tear down ( ) ; }	called by junit after each test method.
private static sax create sax ( ) { try { sax factory = sax . new instance ( ) ; try { sax secure factory = xml . get sax ( factory ) ; secure factory . new sax ( ) ; factory = secure factory ; } catch ( parser configuration exception e ) { } factory . set namespace aware ( bool ) ; return factory ; } catch ( sax e ) { throw new illegal state exception ( str , e ) ; } }	creates a secure sax parser , which is secured against xxe attacks .
public static void save as xml ( ns root , file out ) throws io { file parent = out . get parent file ( ) ; if ( ! parent . exists ( ) && ! parent . mkdirs ( ) ) { throw new io ( str ) ; } file output stream fous = new file output stream ( out ) ; save as xml ( root , fous ) ; fous . close ( ) ; }	saves a property list with the given object as root into a xml file .
public static boolean contains chroot ( string zk host ) { return zk host . contains ( str ) ; }	validates if zkhost contains a chroot.
public final void lazy set ( int new value ) { unsafe . put ordered int ( this , value offset , new value ) ; }	eventually sets to the given value .
public feature ( string line , map cp str2 int , map lb str2 int , map fmap ) { string tokenizer str tok = new string tokenizer ( line , str ) ; int len = str tok . count tokens ( ) ; string str id str = str tok . next token ( ) ; int idx = integer . parse int ( str tok . next token ( ) ) ; float val = num ; double wgt = double . parse double ( str tok . next token ( ) ) ; string tokenizer str id tok = new string tokenizer ( str id str , str ) ; string prefix = str id tok . next token ( ) ; if ( prefix . compare to ignore case ( str ) == num ) { integer y int = ( integer ) lb str2 int . get ( str id tok . next token ( ) ) ; integer yp int = ( integer ) lb str2 int . get ( str id tok . next token ( ) ) ; if ( y int != null && yp int != null ) { e feature1 init ( y int . int value ( ) , yp int . int value ( ) ) ; } } else if ( prefix . compare to ignore case ( str ) == num ) { integer y int = ( integer ) lb str2 int . get ( str id tok . next token ( ) ) ; integer cp int = ( integer ) cp str2 int . get ( str id tok . next token ( ) ) ; if ( y int != null && cp int != null ) { s feature1 init ( y int . int value ( ) , cp int . int value ( ) ) ; } } this . idx = idx ; this . val = val ; this . wgt = wgt ; str id2 idx add ( fmap ) ; }	instantiates a new feature .
public static int patch fast ( input stream old input stream , input stream diff input stream , file new file ) throws io { if ( old input stream == null ) { return return old file err ; } if ( new file == null ) { return return new file err ; } if ( diff input stream == null ) { return return diff file err ; } byte [ ] old bytes = bs . input stream to byte ( old input stream ) ; byte [ ] diff bytes = bs . input stream to byte ( diff input stream ) ; byte [ ] new bytes = patch fast ( old bytes , old bytes . length , diff bytes , diff bytes . length , num ) ; output stream new output stream = new file output stream ( new file ) ; try { new output stream . write ( new bytes ) ; } finally { new output stream . close ( ) ; } return return success ; }	this patch method is fast , but using more memory . memory size = oldbuf + diffbuf + newbuf.
public static byte [ ] read fully no close ( input stream in ) throws io { byte array output stream bytes = new byte array output stream ( ) ; byte [ ] buffer = new byte [ num ] ; int count ; while ( ( count = in . read ( buffer ) ) != - num ) { bytes . write ( buffer , num , count ) ; } return bytes . to byte array ( ) ; }	returns a byte [ ] containing the remainder of ' in ' .
public content storage ( bo content storage bo , list < generic package > generic package list , list < essence container data > essence container data list ) { this . content storage bo = content storage bo ; this . generic package list = collections . unmodifiable list ( generic package list ) ; this . essence container data list = collections . unmodifiable list ( essence container data list ) ; }	instantiates a new contentstorage object.
public io query volume ( string vol id ) throws exception { client response response = get ( uri . create ( io . get volume uri ( vol id ) ) ) ; return get response object ( io . class , response ) ; }	query the volume details.
public void remove event listener ( sip old listener ) { event listeners . remove ( old listener ) ; }	removed an event listener from this dialog .
protected static object primitive array put ( object self , int idx , object new value ) { array . set ( self , normalise index ( idx , array . get length ( self ) ) , new value ) ; return new value ; }	implements the setat ( int idx ) method for primitive type arrays .
public void to axis angle ( vector4f output ) { if ( get w ( ) > num ) { normalise ( ) ; } float angle = num * ( float ) math . to degrees ( math . acos ( get w ( ) ) ) ; float x ; float y ; float z ; float s = ( float ) math . sqrt ( num - get w ( ) * get w ( ) ) ; if ( s < num ) { x = points [ num ] ; y = points [ num ] ; z = points [ num ] ; } else { x = points [ num ] / s ; y = points [ num ] / s ; z = points [ num ] / s ; } output . points [ num ] = x ; output . points [ num ] = y ; output . points [ num ] = z ; output . points [ num ] = angle ; }	get an axis angle representation of this quaternion .
private q < binding expression > process binding attributes ( node node ) { q < binding expression > attribute bindings = null ; for ( iterator < q > i = node . get attribute names ( ) ; i != null && i . has next ( ) ; ) { q qname = i . next ( ) ; string value = ( string ) node . get attribute value ( qname ) ; binding expression be = text parser . parse binding expression ( value , node . begin line ) ; if ( be != null ) { if ( attribute bindings == null ) { attribute bindings = new q < binding expression > ( ) ; } attribute bindings . put ( qname , be ) ; i . remove ( ) ; } } return attribute bindings ; }	collects / processes binding attributes from the node , and then removes them from the node .
public void load ( string file name ) throws io { buffered reader bfr = new buffered reader ( new input stream reader ( new file input stream ( file name ) , str ) ) ; if ( b list == null ) b list = new vector ( default increment , default increment ) ; string line = bfr . read line ( ) ; if ( line . index of ( str ) != - num ) { line = line . substring ( num ) ; string [ ] parts = new string [ num ] ; parts = line . split ( str , num ) ; from dir = parts [ num ] ; from ext = parts [ num ] ; } else if ( ! ( line . matches ( str ) ) ) add ( line ) ; while ( ( line = bfr . read line ( ) ) != null ) { if ( ! ( line . matches ( str ) ) ) add ( line ) ; } }	read the basenamelist from a file.
private void verify register defs ( string where ) { def use . compute du ( this ) ; for ( register r = regpool . get first symbolic register ( ) ; r != null ; r = r . get next ( ) ) { if ( r . is physical ( ) ) continue ; if ( r . use list != null ) { if ( r . def list == null ) { print instructions ( ) ; verror ( where , str + r + str ) ; } } } }	verify that every non - physical , non - parameter symbolic register that has a use also has at least one def.
private static void find snap ( collection < constraint widget > widgets , constraint widget widget , snap candidate candidate , boolean check horizontal ) { array list < constraint anchor > anchors source = widget . get anchors ( ) ; for ( constraint widget w : widgets ) { if ( w == widget ) { continue ; } array list < constraint anchor > anchors target = w . get anchors ( ) ; for ( constraint anchor as : anchors source ) { if ( check horizontal && as . is vertical anchor ( ) ) { continue ; } else if ( ! check horizontal && ! as . is vertical anchor ( ) ) { continue ; } for ( constraint anchor at : anchors target ) { snap check ( as , at , candidate , connection slope ) ; } } } }	utility function iterating through the anchors of a widget , comparing their position with all the anchors of other widgets , and calling the snapcheck ( ) function .
protected string pad string ( string s , int length , boolean left ) { string result ; int i ; result = s ; for ( i = s . length ( ) ; i < length ; i ++ ) { if ( left ) { result = str + result ; } else { result = result + str ; } } if ( ( length > num ) && ( result . length ( ) > length ) ) { result = result . substring ( num , length ) ; } return result ; }	pads the given string until it reaches the given length , if longer cuts it down.
void recompose keys ( key declaration key decl ) { m key decls . add element ( key decl ) ; }	recompose the key declarations .
public < t > json array < t > create list dto from json ( reader json , class < t > dto interface ) throws io { final dto provider < t > dto provider = get dto provider ( dto interface ) ; final list < json element > list ; try { list = gson . from json ( json , list type cache . get ( json element . class ) ) ; } catch ( json syntax exception e ) { final throwable cause = e . get cause ( ) ; if ( cause instanceof io ) { throw ( io ) cause ; } throw e ; } final list < t > result = new array list < > ( list . size ( ) ) ; for ( json element e : list ) { result . add ( dto provider . from json ( e ) ) ; } return new json array impl < > ( result ) ; }	parses the json data from the specified reader into list of objects of the specified type .
private view fill from top ( int next top ) { m first position = math . min ( m first position , - num ) ; m first position = math . min ( m first position , m item count - num ) ; if ( m first position < num ) { m first position = num ; } return fill down ( m first position , next top ) ; }	fills the list from top to bottom , starting with mfirstposition.
public void connection open ( ) { lock . lock ( ) ; try { log . info ( str ) ; connection open = bool ; } finally { lock . unlock ( ) ; } }	called to indicate the connection has been opened and messages can now be generated for the client .
public static float rotate y ( float p x , float p y , float c x , float c y , float angle in degrees ) { double angle = math . to radians ( angle in degrees ) ; return ( float ) ( math . sin ( angle ) * ( p x - c x ) + math . cos ( angle ) * ( p y - c y ) + c y ) ; }	rotate point p around center point c .
public void list ( print stream out ) { properties . list ( out ) ; }	prints the contents of this preference store to the given print stream .
protected layer pane find selected pane ( ) { for ( layer pane pane : get panes ( ) ) { if ( pane . is selected ( ) ) { return pane ; } } return null ; }	find the selected layerpane in the current layerpane list.
private final void scale noise array ( final int sea level ) { for ( int x = num ; x < x sections ; x ++ ) { for ( int z = num ; z < z sections ; z ++ ) { for ( int y = num ; y < y sections ; y ++ ) { this . raw density [ x ] [ y ] [ z ] *= max elev ; this . raw density [ x ] [ y ] [ z ] += sea level ; } } } }	if rawdensity is ranged from - 1 to 1 , use this to scale it up.
public object [ ] to array ( ) { array list < e > al = new array list < e > ( ) ; for ( node < e > p = first ( ) ; p != null ; p = succ ( p ) ) { e item = p . item ; if ( item != null ) al . add ( item ) ; } return al . to array ( ) ; }	returns an array containing all of the elements in this queue , in proper sequence.
public microservices runner ( int ... ports ) { configure transport ( ports ) ; }	creates a microservicesrunner instance which will be used for deploying microservices.
public static boolean delete contents ( file directory ) { file [ ] files = directory . list files ( ) ; boolean success = bool ; if ( files != null ) { for ( file file : files ) { success &= delete recursively ( file ) ; } } return success ; }	deletes all files and subdirectories in directory ( doesn ' t delete the directory passed as parameter ) .
private void handle response ( avs response response ) { m event manager . post ( new command event ( command event . type command searching , keyword alexa ) ) ; if ( response != null ) { for ( int i = response . size ( ) - num ; i >= num ; i -- ) { if ( response . get ( i ) instanceof avs replace all item || response . get ( i ) instanceof avs replace enqueued item ) { m avs queue . clear ( ) ; response . remove ( i ) ; } } timber . i ( str , response . size ( ) ) ; m avs queue . add all ( response ) ; } check queue ( ) ; }	handle the response sent back from alexa ' s parsing of the intent , these can be any of the avsitem types ( play , speak , stop , clear , listen ).
public static list < string > to list ( char sequence self ) { string s = self . to string ( ) ; int size = s . length ( ) ; list < string > answer = new array list < string > ( size ) ; for ( int i = num ; i < size ; i ++ ) { answer . add ( s . substring ( i , i + num ) ) ; } return answer ; }	converts the given charsequence into a list of strings of one character .
void append array generic type ( string builder sb , type [ ] types ) { if ( types . length > num ) { append generic type ( sb , types [ num ] ) ; for ( int i = num ; i < types . length ; i ++ ) { sb . append ( str ) ; append generic type ( sb , types [ i ] ) ; } } }	appends names of the specified array classes to the buffer.
public void check reinit file ( final boolean need reinit ) throws io { file boot mode file = new file ( root dir , constants . startupmode ) ; if ( ! need reinit ) { log . info ( str ) ; if ( boot mode file . exists ( ) ) { boot mode file . delete ( ) ; } return ; } if ( ! boot mode file . exists ( ) ) { set db startup mode as restore reinit ( root dir ) ; } chown ( boot mode file , backup constants . storageos user , backup constants . storageos group ) ; log . info ( str , boot mode file . get absolute path ( ) ) ; }	checks reinit file according to argument needreinit.
public void read dot ( reader input ) { dot parser dp = new dot parser ( input , m nodes , m edges ) ; graph id = dp . parse ( ) ; set appropriate node size ( ) ; if ( m le != null ) { m le . set node size ( padded node width , node height ) ; j bt layout . set enabled ( bool ) ; layout graph ( ) ; } }	dot reader < br > reads a graph description in dot format from a string.
private void notify all entity ( ) { log . print concat line ( super . get name ( ) , str ) ; signal shutdown ( res list ) ; signal shutdown ( gis list ) ; res list . clear ( ) ; gis list . clear ( ) ; }	tells all registered entities about the end of simulation .
public synchronized boolean has alerts ( ) { if ( alerts == null ) { return bool ; } return ! alerts . is empty ( ) ; }	tells whether or not this history reference has alerts .
public void test compare to pos pos1 ( ) { byte a bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; int a sign = num ; int b sign = num ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; assert equals ( num , a number . compare to ( b number ) ) ; }	compareto ( biginteger a ).
protected collection < ? extends annotation mirror > replace poly all ( collection < ? extends annotation mirror > annos ) { set < annotation mirror > return annos = annotation utils . create annotation set ( ) ; for ( annotation mirror top : get top annotations ( ) ) { annotation mirror annotation in hierarchy = find annotation in hierarchy ( annos , top ) ; if ( annotation in hierarchy != null ) { return annos . add ( annotation in hierarchy ) ; } } return return annos ; }	returns a new set that is the passed set , but polyall has been replaced by a polymorphic qualifiers , for hierarchies that do not have an annotation in the set .
public synchronized void reset inputs ( ) throws io { source . print statistics ( str ) ; set config ( config , source ) ; source . reset inputs ( ) ; num docs created . set ( num ) ; reset leftovers ( ) ; }	reset inputs so that the test run would behave , input wise , as if it just started .
public void remove matching coupling ( coupling < ? > to remove ) { for ( coupling < ? > coupling : get couplings ( ) ) { boolean consumers match = attributes match ( coupling . get consumer ( ) , to remove . get consumer ( ) ) ; boolean producers match = attributes match ( coupling . get producer ( ) , to remove . get producer ( ) ) ; if ( consumers match && producers match ) { remove coupling ( coupling ) ; } } }	remove coupling ( if any ) that is essentially a copy of the supplied coupling .
public string to short string ( ) { string builder sb = new string builder ( ) ; if ( x road instance != null ) { sb . append ( x road instance ) ; } for ( string part : get fields for string format ( ) ) { if ( part != null ) { if ( sb . length ( ) > num ) { sb . append ( str ) ; } sb . append ( part ) ; } } return sb . to string ( ) ; }	returns short string representation of the identifier that is more suitable for user interface usage than output of the tostring ( ) method .
private boolean check pattern ( ) { if ( pattern == null ) { return bool ; } char left separator = get left separator ( ) ; char right separator = get right separator ( ) ; stack < character > separator stack = new stack < character > ( ) ; for ( int i = num ; i < pattern . length ( ) ; i ++ ) { char cur = pattern . char at ( i ) ; if ( cur == left separator ) { separator stack . push ( cur ) ; } else if ( cur == right separator ) { if ( ! separator stack . is empty ( ) && ( separator stack . pop ( ) == left separator ) ) { continue ; } else { return bool ; } } } return separator stack . is empty ( ) ; }	check if the pattern has legal separators.
public static sq open or create database ( file file , cursor factory factory ) { return open or create database ( file . get path ( ) , factory ) ; }	equivalent to opendatabase ( file.
public wildcard ( string pattern , int regexp options ) { this . regexp options = regexp options ; regexp = pattern . compile ( wildcard to regex ( pattern ) , regexp options ) ; shortcut = extract shortcut ( pattern ) ; }	initializes a wildcard with the given search pattern and options .
private string local number ( ) throws parse exception { string buffer s = new string buffer ( ) ; if ( debug ) dbg enter ( str ) ; try { int lc = num ; while ( lexer . has more chars ( ) ) { char la = lexer . look ahead ( num ) ; if ( la == str || la == str || la == str || la == str || la == str || la == str || lexer . is hex digit ( la ) ) { lexer . consume ( num ) ; s . append ( la ) ; lc ++ ; } else if ( lc > num ) break ; else throw create parse exception ( str + la ) ; } return s . to string ( ) ; } finally { if ( debug ) dbg leave ( str ) ; } }	parser for the local phone # .
private static void append default value ( string builder sb , field type field type , object default value ) { if ( field type . is escaped default value ( ) ) { append escaped word ( sb , default value . to string ( ) ) ; } else { sb . append ( default value ) ; } }	output the sql type for the default value for the type .
public metadata block data picture ( byte buffer rawdata ) throws io , invalid frame exception { init from byte buffer ( rawdata ) ; }	initialize metablockdatapicture from bytebuffer.
public void previous ( ) { if ( current ( ) == null ) { return ; } m current search index -- ; m is before first = bool ; m is after last = bool ; if ( m current search index < num ) { m current search index = m reduced results . size ( ) - num ; m is before first = bool ; } }	moves search result iteration to the previous search result .
@ nullable public static method find method ( class c , string name , object ... params ) { class [ ] param types = get param types ( params ) ; method method = null ; try { method = c . get declared method ( name , param types ) ; } catch ( no such method exception e ) { try { method = c . get method ( name , param types ) ; } catch ( no such method exception e1 ) { } } if ( method != null ) method . set accessible ( bool ) ; return method ; }	searches for a method by its name and arguments .
public void test pos zero ( ) { byte a bytes [ ] = { - num , - num , - num , - num , num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { num } ; int a sign = num ; int b sign = num ; byte r bytes [ ] = { num , - num , - num , - num , - num , num , num , num , num , num , num , num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . or ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	or for a positive number and zero.
public boolean close all sessions ( ) { while ( exists session ( ) ) { session editor session editor = get frontmost session editor ( ) ; session editor workbench workbench = session editor . get session workbench ( ) ; session wrapper wrapper = workbench . get session wrapper ( ) ; if ( ! wrapper . is session changed ( ) ) { close frontmost session ( ) ; continue ; } string name = session editor . get name ( ) ; int ret = j . show confirm dialog ( j . centering comp ( ) , str + name + str , str , j . yes no cancel option ) ; if ( ret == j . no option ) { close frontmost session ( ) ; continue ; } else if ( ret == j . cancel option ) { return bool ; } save session as action action = new save session as action ( ) ; action . action performed ( new action event ( this , action event . action performed , str ) ) ; if ( ! action . is saved ( ) ) { int ret2 = j . show confirm dialog ( j . centering comp ( ) , str , str , j . ok cancel option ) ; if ( ret2 == j . cancel option ) { return bool ; } } close frontmost session ( ) ; } return bool ; }	queries the user as to whether they would like to save their sessions .
private void remove non visible views ( final int offset ) { int child count = get child count ( ) ; if ( m last item position != m adapter . get count ( ) - num && child count > num ) { view first child = get child at ( num ) ; while ( first child != null && get child bottom ( first child ) + offset < num ) { remove view in layout ( first child ) ; child count -- ; m cached item views . add last ( first child ) ; m first item position ++ ; m list top offset += get child height ( first child ) ; if ( child count > num ) { first child = get child at ( num ) ; } else { first child = null ; } } } if ( m first item position != num && child count > num ) { view last child = get child at ( child count - num ) ; while ( last child != null && get child top ( last child ) + offset > get height ( ) ) { remove view in layout ( last child ) ; child count -- ; m cached item views . add last ( last child ) ; m last item position -- ; if ( child count > num ) { last child = get child at ( child count - num ) ; } else { last child = null ; } } } }	removes view that are outside of the visible part of the list.
public repeated field builder < m , b , i > add message ( int index , m message ) { if ( message == null ) { throw new null pointer exception ( ) ; } ensure mutable message list ( ) ; messages . add ( index , message ) ; if ( builders != null ) { builders . add ( index , null ) ; } on changed ( ) ; increment mod counts ( ) ; return this ; }	inserts the specified message at the specified position in this list.
void unlock ( table t ) { locks . remove ( t ) ; }	unlock just this table .
public void on exceeded database quota ( string url , string database identifier , long current quota , long estimated size , long total used quota , web storage . quota updater quota updater ) { if ( logv enabled ) { log . v ( logtag , str + url + str + database identifier + str + current quota + str + total used quota + str ) ; } long total unused quota = m global limit - total used quota - m app cache max size ; if ( total unused quota <= num ) { if ( total used quota > num ) { schedule out of space notification ( ) ; } quota updater . update quota ( current quota ) ; if ( logv enabled ) { log . v ( logtag , str ) ; } return ; } long new origin quota = current quota ; if ( new origin quota == num ) { if ( total unused quota >= estimated size ) { new origin quota = estimated size ; } else { if ( logv enabled ) { log . v ( logtag , str + str + str + estimated size + str + total unused quota ) ; } new origin quota = num ; } } else { long quota increase = estimated size == num ? math . min ( quota increase step , total unused quota ) : estimated size ; new origin quota += quota increase ; if ( quota increase > total unused quota ) { new origin quota = current quota ; } } quota updater . update quota ( new origin quota ) ; if ( logv enabled ) { log . v ( logtag , str + new origin quota ) ; } }	the origin has exceeded its database quota .
protected string to val string ( set vals ) { string builder sb = new string builder ( ) ; boolean first = bool ; for ( iterator i = vals . iterator ( ) ; i . has next ( ) ; ) { string val = ( string ) i . next ( ) ; val = encode val ( val ) ; if ( first ) { first = bool ; } else { sb . append ( str ) ; } sb . append ( val ) ; } return sb . to string ( ) ; }	converts a set of values for an attribute into a string , encoding special characters in the values as necessary .
public static json read json ( final json json array , final int index , final boolean required , final boolean not null ) throws json { if ( required ) { return json array . get json ( index ) ; } if ( not null && json array . is null ( index ) ) { throw new json ( string . format ( locale . us , null value format array , index ) ) ; } json value = null ; if ( ! json array . is null ( index ) ) { value = json array . get json ( index ) ; } return value ; }	reads the json array value from the json array for specified index.
private static bitmap resize photo ( bitmap real image , float max image size , boolean filter ) { float ratio = math . min ( ( float ) max image size / real image . get width ( ) , ( float ) max image size / real image . get height ( ) ) ; int width = math . round ( ( float ) ratio * real image . get width ( ) ) ; int height = math . round ( ( float ) ratio * real image . get height ( ) ) ; bitmap new bitmap = bitmap . create scaled bitmap ( real image , width , height , filter ) ; return new bitmap ; }	this method resize the photo.
private element create key value ( ) throws exception { element key value ele = null ; private key key = idm client . get tenant private key ( tenant name ) ; if ( key != null ) { rsa rsa key = ( rsa ) key ; element rsa key ele = create rsa ( rsa key ) ; if ( rsa key ele != null ) { key value ele = doc . create element ( saml . ds keyvalue ) ; key value ele . append child ( rsa key ele ) ; } } return key value ele ; }	return a ds : keyvalue element in dom . keyvalue | - - - - - rsakeyvalue.
static protected void expand element ( element el , list < element > list ) { list . add all ( el . get children ( str ) ) ; list < element > children = el . get children ( ) ; for ( int i = num ; i < children . size ( ) ; i ++ ) { expand element ( children . get ( i ) , list ) ; } }	find all of the display elements descending from this element.
static void load ( ) { }	this method may be used to force initialize the static members in the class.
public static string dump ( map < ? , ? > map ) { string builder string builder = new string builder ( ) ; for ( map . entry < ? , ? > entry : map . entry set ( ) ) { string builder . append ( entry . get key ( ) ) ; string builder . append ( str ) ; string builder . append ( entry . get value ( ) ) ; } return string builder . to string ( ) ; }	dump map value into string .
public void changed update ( document event e ) { }	called when the document is modified .
private void merge collapse ( ) { while ( stack size > num ) { int n = stack size - num ; if ( n > num && run len [ n - num ] <= run len [ n ] + run len [ n + num ] ) { if ( run len [ n - num ] < run len [ n + num ] ) n -- ; merge at ( n ) ; } else if ( run len [ n ] <= run len [ n + num ] ) { merge at ( n ) ; } else { break ; } } }	examines the stack of runs waiting to be merged and merges adjacent runs until the stack invariants are reestablished : 1.
protected void remove from maps ( string client type ) { client client = ( client ) client type map . get ( client type ) ; external client data . remove ( client type ) ; map map = ( map ) internal client data . get ( client type ) ; if ( map == null ) { remove from client map ( client type , client ) ; } else { handle parent change ( client type , map ) ; } unload client ( client type ) ; }	remove all references to this client.
public string serialize ( object object ) throws converter exception { deep = num ; string builder sb = new string builder ( ) ; serialize ( object , sb , new hash set < object > ( ) ) ; return sb . to string ( ) ; }	serialize a object to his literal format.
private static < t > void find unique goals ( map < test case , set < t > > test to goals ) { map < test case , set < t > > goal map copy = new linked hash map < > ( ) ; for ( map . entry < test case , set < t > > entry : test to goals . entry set ( ) ) { set < t > goal set = new linked hash set < t > ( entry . get value ( ) ) ; for ( map . entry < test case , set < t > > other entry : test to goals . entry set ( ) ) { if ( entry == other entry ) continue ; goal set . remove all ( other entry . get value ( ) ) ; } goal map copy . put ( entry . get key ( ) , goal set ) ; } test to goals . clear ( ) ; test to goals . put all ( goal map copy ) ; }	determine for each test the set of coverage goals uniquely covered by this test.
private static string form head ( string hair , string face , string neck ) { return string . join ( str , hair , face , neck ) ; }	i ' ll form the head !.
public void terminate ( ) { listeners . clear ( ) ; lookup disc . terminate ( ) ; locator disc . terminate ( ) ; if ( dynamic locator disc != null ) dynamic locator disc . terminate ( ) ; }	terminates all threads , ending all discovery processing being performed by the current instance of this class.
public void start ( ) { start = system . current time millis ( ) ; }	starts the bandwidth measurement .
@ nullable public static string extract protocol ( @ not null string url ) { int index = url . index of ( url . scheme separator ) ; if ( index < num ) return null ; return url . substring ( num , index ) ; }	extracts protocol from the given url.
protected void load buffer ( ) { int res idx = minute spacing / num ; if ( res idx < num ) res idx = num ; else if ( res idx > num ) res idx = num ; string file name = path + etopo file names [ res idx ] ; data buffer = null ; try { binary buffered file bin file = new binary buffered file ( file name ) ; bin file . byte order ( bool ) ; buffer width = etopo widths [ res idx ] ; buffer height = etopo heights [ res idx ] ; int spacer = num ; switch ( minute spacing ) { case ( num ) : spacer = num + this . spacer ; break ; case ( num ) : spacer = num + this . spacer ; break ; default : spacer = num + this . spacer ; } data buffer = new short [ ( buffer width + spacer ) * buffer height ] ; for ( int i = num ; i < buffer width * buffer height ; i ++ ) data buffer [ i ] = bin file . read short ( ) ; bin file . close ( ) ; buffer width += spacer ; } catch ( file not found exception e ) { debug . error ( str + file name + str ) ; } catch ( io e ) { debug . error ( str + e . to string ( ) ) ; } catch ( format exception e ) { debug . error ( str + e . to string ( ) ) ; } }	loads the database from the appropriate file based on the current resolution.
protected version tag fetch remote version tag ( object key ) { version tag tag = null ; assert this . data policy != data policy . replicate ; transaction id tx id = cache . get cache transaction manager ( ) . suspend ( ) ; try { boolean retry = bool ; internal distributed member member = get random replicate ( ) ; while ( retry ) { try { if ( member == null ) { break ; } fetch version response response = remote fetch version message . send ( member , this , key ) ; tag = response . wait for response ( ) ; retry = bool ; } catch ( remote operation exception e ) { member = get random replicate ( ) ; if ( member != null ) { if ( logger . is debug enabled ( ) ) { logger . debug ( str , member ) ; } } } } } finally { if ( tx id != null ) { cache . get cache transaction manager ( ) . resume ( tx id ) ; } } return tag ; }	fetch version for the given key from a remote replicate member .
public node replace child ( node new child , node old child ) throws dom { if ( old child == null || old child . get parent node ( ) != this ) return null ; elem template element new child elem = ( ( elem template element ) new child ) ; elem template element old child elem = ( ( elem template element ) old child ) ; elem template element prev = ( elem template element ) old child elem . get previous sibling ( ) ; if ( null != prev ) prev . m next sibling = new child elem ; if ( m first child == old child elem ) m first child = new child elem ; new child elem . m parent node = this ; old child elem . m parent node = null ; new child elem . m next sibling = old child elem . m next sibling ; old child elem . m next sibling = null ; return new child elem ; }	replace the old child with a new child .
public static f calc text size ( paint paint , string demo text ) { rect r = new rect ( ) ; paint . get text bounds ( demo text , num , demo text . length ( ) , r ) ; return new f ( r . width ( ) , r . height ( ) ) ; }	calculates the approximate size of a text , depending on a demo text avoid repeated calls ( e.
private boolean parse delimiters ( delimiter processor delimiter processor , char delimiter char ) { delimiter data res = scan delimiters ( delimiter processor , delimiter char ) ; if ( res == null ) { return bool ; } int num delims = res . count ; int start index = index ; index += num delims ; text node = append text ( input , start index , index ) ; last delimiter = new delimiter ( node , delimiter char , res . can open , res . can close , last delimiter ) ; last delimiter . num delims = num delims ; if ( last delimiter . previous != null ) { last delimiter . previous . next = last delimiter ; } return bool ; }	attempt to parse delimiters like emphasis , strong emphasis or custom delimiters .
private void clear money ( ) { money . clear ( ) ; update money ( ) ; }	remove all the money objects.
public void exec ( string [ ] args ) throws throwable { url url class loader = new url ( class path . to array ( new url [ class path . size ( ) ] ) ) ; class < ? > cls = url class loader . load class ( main class ) ; method method = cls . get declared method ( str , string [ ] . class ) ; method . set accessible ( bool ) ; try { method . invoke ( null , new object [ ] { args } ) ; } catch ( invocation target exception e ) { throw e . get target exception ( ) ; } }	execute with given arguments.
void rollback local transaction ( ) throws rollback failed exception { if ( tx == null ) { return ; } try { if ( logger . is loggable ( level . finest ) ) { logger . log ( level . finest , str + tx ) ; } tx . abort ( ) ; } catch ( exception e ) { if ( logger . is loggable ( level . severe ) ) { logger . log ( level . severe , str + tx , e ) ; } throw new rollback failed exception ( e ) ; } }	rolls back the local transaction .
public void write ( char c [ ] , int off , int len ) { if ( ( off < num ) || ( off > c . length ) || ( len < num ) || ( ( off + len ) > c . length ) || ( ( off + len ) < num ) ) { throw new index out of bounds exception ( ) ; } else if ( len == num ) { return ; } synchronized ( lock ) { int newcount = count + len ; if ( newcount > buf . length ) { buf = arrays . copy of ( buf , math . max ( buf . length << num , newcount ) ) ; } system . arraycopy ( c , off , buf , count , len ) ; count = newcount ; } }	writes characters to the buffer .
private void write jar post resource ( string builder sb , string path ) { sb . append ( str + jar resource set + str ) ; sb . append ( path . replace ( str , str ) ) ; }	write jar post resource.
public static string normalize ( string value ) { if ( value == null ) return value ; value = value . trim ( ) ; if ( value . index of ( str ) == - num ) return value ; boolean space = bool ; int len = value . length ( ) ; string buffer b = new string buffer ( len ) ; for ( int i = num ; i < len ; i ++ ) { char v = value . char at ( i ) ; if ( v == str ) { if ( ! space ) b . append ( v ) ; space = bool ; } else { b . append ( v ) ; space = bool ; } } return b . to string ( ) ; }	normalize an attribute value ( id - style ).
protected static void append decorations ( int base pos , string source code , create simple lexer lang handler , list < object > out ) { if ( source code == null ) { throw new null pointer exception ( str ) ; } job job = new job ( ) ; job . set source code ( source code ) ; job . set base pos ( base pos ) ; lang handler . decorate ( job ) ; out . add all ( job . get decorations ( ) ) ; }	apply the given language handler to sourcecode and add the resulting decorations to out .
protected carbon dictionary column meta chunk read last chunk from dictionary metadata file ( dictionary column unique identifier dictionary column unique identifier ) throws io { dictionary service dict service = carbon common factory . get dictionary service ( ) ; carbon dictionary metadata reader column metadata reader impl = dict service . get dictionary metadata reader ( dictionary column unique identifier . get carbon table identifier ( ) , dictionary column unique identifier . get column identifier ( ) , carbon store path ) ; carbon dictionary column meta chunk carbon dictionary column meta chunk = null ; try { carbon dictionary column meta chunk = column metadata reader impl . read last entry of dictionary meta chunk ( ) ; } finally { column metadata reader impl . close ( ) ; } return carbon dictionary column meta chunk ; }	this method will read dictionary metadata file and return the dictionary meta chunks.
public static external app id determine external intent source ( string package name , intent intent ) { string app id = intent utils . safe get string extra ( intent , browser . extra application id ) ; external app id external id = external app id . other ; if ( app id == null ) { string url = get url from intent ( intent ) ; if ( url != null && url . starts with ( twitter link prefix ) ) { external id = external app id . twitter ; } else if ( url != null && url . starts with ( facebook link prefix ) ) { external id = external app id . facebook ; } else if ( url != null && url . starts with ( news link prefix ) ) { external id = external app id . news ; } } else { if ( app id . equals ( package plus ) ) { external id = external app id . plus ; } else if ( app id . equals ( package gmail ) ) { external id = external app id . gmail ; } else if ( app id . equals ( package hangouts ) ) { external id = external app id . hangouts ; } else if ( app id . equals ( package messenger ) ) { external id = external app id . messenger ; } else if ( app id . equals ( package line ) ) { external id = external app id . line ; } else if ( app id . equals ( package whatsapp ) ) { external id = external app id . whatsapp ; } else if ( app id . equals ( package gsa ) ) { external id = external app id . gsa ; } else if ( app id . equals ( package name ) ) { external id = external app id . chrome ; } } return external id ; }	determines what app was used to fire this intent .
protected hdu ( header hdr , t td ) { super ( hdr , td ) ; }	create the tablehdu . note that this will normally only be invoked by subclasses in the fits package .
public void push stylesheet ( stylesheet s ) { if ( m stylesheets . size ( ) == num ) m stylesheet root = ( stylesheet root ) s ; m stylesheets . push ( s ) ; }	push the current stylesheet being constructed.
public boolean is blank ( final char sequence cs ) { int str len ; if ( cs == null || ( str len = cs . length ( ) ) == num ) { return bool ; } for ( int i = num ; i < str len ; i ++ ) { if ( ! character . is whitespace ( cs . char at ( i ) ) ) { return bool ; } } return bool ; }	checks if a charsequence is whitespace , empty ( " " ) or null .
public void stop ( ) throws io , interrupted exception { thread . interrupt ( ) ; selector . wakeup ( ) ; }	disconnects and stops the client .
private document parse ( final string data , document builder doc builder ) { if ( doc builder == null || data == null ) { return null ; } document document = null ; try { string builder buf = new string builder ( num ) ; if ( ! data . starts with ( str ) ) { buf . append ( begin part ) ; } buf . append ( data ) ; if ( ! data . ends with ( end part ) ) { buf . append ( end part ) ; } input source input source = new input source ( new string reader ( buf . to string ( ) ) ) ; document = doc builder . parse ( input source ) ; } catch ( exception e ) { logger . warn ( str + e . get message ( ) ) ; } return document ; }	converts the loggingevent data in xml string format into an actual xml document class instance .
private x load chars ( java . io . buffered reader istream ) throws java . io . io { string s = str ; s = istream . read line ( ) ; if ( log . is debug enabled ( ) ) { log . debug ( str + s ) ; } if ( s == null ) { return null ; } else { return new x ( s ) ; } }	get characters from the input source , and file a message.
public synchronized void remove connection manager ( final http connection manager connection manager ) { if ( shutdown ) { throw new illegal state exception ( str ) ; } connection managers . remove ( connection manager ) ; }	removes the connection manager from this class.
private boolean add state ( long state number ) { if ( first state < num ) { first state = state number ; } else if ( step size < num ) { step size = ( int ) ( state number - first state ) ; } else { int step = ( int ) ( state number - last state ) ; if ( step != step size ) { return bool ; } } last state = state number ; return bool ; }	add a state number for these traces.
public void reset ( ) { adler = num ; }	resets the checksum to initial value .
public static boolean is library resource root ( @ nullable virtual file res ) { if ( res != null ) { virtual file aar = res . get parent ( ) ; if ( aar != null ) { virtual file exploded = aar . get parent ( ) ; if ( exploded != null ) { string name = exploded . get name ( ) ; if ( name . equals ( exploded bundles ) || name . equals ( exploded aar ) ) { return bool ; } } } } return bool ; }	returns true if the given resource folder ( such as a given " res " folder , a parent of say a layout folder ) is an extracted library ( aar ) resource folder.
public void fail engine ( string reason , @ nullable throwable failure ) { if ( fail engine lock . try lock ( ) ) { store . inc ref ( ) ; try { try { close no lock ( str + reason + str ) ; } finally { if ( failed engine != null ) { logger . debug ( str , reason , failure ) ; return ; } logger . warn ( str , failure , reason ) ; failed engine = ( failure != null ) ? failure : new illegal state exception ( reason ) ; if ( lucene . is corruption exception ( failure ) ) { try { store . mark store corrupted ( new io ( str + reason + str , exceptions helper . unwrap corruption ( failure ) ) ) ; } catch ( io e ) { logger . warn ( str , e ) ; } } failed engine listener . on failed engine ( shard id , reason , failure ) ; } } catch ( throwable t ) { logger . warn ( str , t ) ; } finally { store . dec ref ( ) ; } } else { logger . debug ( str , reason , failure ) ; } }	fail engine due to some error.
public void clear ( ) { values . clear ( ) ; }	clear out the collection .
@ override default completable future < optional int > max int ( final to int function < ? super t > fn ) { return completable future . supply async ( null , get exec ( ) ) ; }	perform an asynchronous max operation.
private void add vnx ( string storage system uri , distributed queue item processed callback call back ) { if ( string utils . is not empty ( storage system uri ) ) { vnxfile cache . put ( storage system uri , call back ) ; } }	adds vnxfile ' s uri and callback instance into cache.
void reset to preferred sizes ( int available size ) { int [ ] test sizes = get preferred sizes ( ) ; int total size = num ; for ( int counter = num ; counter < num ; counter ++ ) { if ( test sizes [ counter ] != - num ) { total size += test sizes [ counter ] ; } } if ( total size > available size ) { test sizes = get minimum sizes ( ) ; total size = num ; for ( int counter = num ; counter < num ; counter ++ ) { if ( test sizes [ counter ] != - num ) { total size += test sizes [ counter ] ; } } } set sizes ( test sizes ) ; distribute space ( available size - total size , bool ) ; }	resets the components to their preferred sizes .
public boolean is processing ( ) { return m running . get ( ) ; }	indicates if this processing chain is currently receiving samples from a source and sending those samples to the decoders .
private static input stream reader decompress with7 zip ( final string archive path ) throws configuration exception { path program 7 zip = ( string ) config . get config parameter ( configuration keys . path program 7 zip ) ; if ( path program 7 zip == null ) { throw error factory . create configuration exception ( error keys . configuration parameter undefined ) ; } try { runtime runtime = runtime . get runtime ( ) ; process p = runtime . exec ( path program 7 zip + str + archive path + str ) ; return new input stream reader ( p . get input stream ( ) , wikipedia encoding ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } }	starts a decompression process using the 7zip program .
public void send ( string data ) throws io { datagram packet dp = new datagram packet ( data . get bytes ( ) , data . length ( ) , multicast group ) ; datagram socket . send ( dp ) ; }	used to send ssdp packet.
private void remove stale range references ( ) { remove stale references ( range reference queue , ranges ) ; }	remove stale range references from the range list .
private boolean is exported ( uri id , list < uri > exported volumes ) { return exported volumes . contains ( id ) ; }	check if volume is exported .
private string fix monitor links ( string fix string , string dump name ) { if ( fix string . index of ( str ) > num ) { fix string = fix string . replace all ( str , str + dump name + str ) ; } return ( fix string ) ; }	fix the monitor links for proper navigation to the monitor in the right dump .
protected static test dimension config build standard dimension config ( test api dimension name dimension name ) { return new test dimension config ( dimension name , dimension name . as name ( ) , get default key value store ( dimension name ) , get default search provider ( ) , get default fields ( ) , get default fields ( ) ) ; }	build a standard - config dimension config .
public string to string ( ) { string buffer sb = new string buffer ( str ) ; if ( type != set constraints ) { sb . append ( type == as is ? str : str ) ; } sb . append ( loader ) ; sb . append ( str ) ; for ( int i = num ; i < context elements . length ; i ++ ) { if ( i > num ) { sb . append ( str ) ; } sb . append ( context elements [ i ] ) ; } if ( principals == null ) { sb . append ( str ) ; } else { sb . append ( str ) ; for ( int i = num ; i < principals . length ; i ++ ) { if ( i > num ) { sb . append ( str ) ; } sb . append ( principals [ i ] ) ; } sb . append ( str ) ; } for ( int i = num ; i < permissions . length ; i ++ ) { if ( i > num ) { sb . append ( str ) ; } sb . append ( permissions [ i ] ) ; } sb . append ( str ) ; return sb . to string ( ) ; }	returns a string representation of this object .
public synchronized void cache reposts ( list < long > new repost ids ) { tree set < long > reposts = new tree set < > ( ) ; reposts . add all ( longs . as list ( repost cache . get ( ) ) ) ; reposts . add all ( new repost ids ) ; repost cache . set ( longs . to array ( reposts ) ) ; }	caches the given items as reposts .
protected final class < ? > define class ( string class name , byte [ ] class rep , int offset , int length ) throws class format error { return define class ( class name , class rep , offset , length , null ) ; }	constructs a new class from an array of bytes containing a class definition in class file format .
public boolean rewrite exif ( byte buffer buf , collection < exif tag > tags ) throws io { exif modifier mod = null ; try { mod = new exif modifier ( buf , this ) ; for ( exif tag t : tags ) { mod . modify tag ( t ) ; } return mod . commit ( ) ; } catch ( exif invalid format exception e ) { throw new io ( str + e ) ; } }	attempts to do an in - place rewrite the exif metadata in a bytebuffer for the given tags.
private void write newline on debug ( xml out ) throws xml { if ( log . is debugging ( ) ) { out . write characters ( str ) ; } }	print a newline when debugging .
public request handle put ( string url , response handler interface response handler ) { return put ( null , url , null , response handler ) ; }	perform a http put request , without any parameters .
public discretize ( element discretize , field meta info . optype op type , array list < attribute > field defs ) throws exception { super ( op type , field defs ) ; m field name = discretize . get attribute ( str ) ; m map missing to = discretize . get attribute ( str ) ; if ( m map missing to != null && m map missing to . length ( ) > num ) { m map missing defined = bool ; } m default value = discretize . get attribute ( str ) ; if ( m default value != null && m default value . length ( ) > num ) { m default value defined = bool ; } node list db l = discretize . get elements by tag name ( str ) ; for ( int i = num ; i < db l . get length ( ) ; i ++ ) { node db n = db l . item ( i ) ; if ( db n . get node type ( ) == node . element node ) { element db e = ( element ) db n ; discretize bin db = new discretize bin ( db e , m op type ) ; m bins . add ( db ) ; } } if ( field defs != null ) { set up field ( ) ; } }	constructs a discretize expression.
private static string quad tree ( final map tile a tile ) { string builder quad key = new string builder ( ) ; for ( int i = a tile . zoom level ; i > num ; i -- ) { int digit = num ; int mask = num << ( i - num ) ; if ( ( a tile . x & mask ) != num ) digit += num ; if ( ( a tile . y & mask ) != num ) digit += num ; quad key . append ( digit ) ; } return quad key . to string ( ) ; }	converts tms tile coordinates to quadtree.
public static long [ ] ones ( int bits ) { long [ ] v = new long [ ( ( bits - num ) > > > long lo size ) + num ] ; final int fill words = bits > > > long lo size ; final int fill bits = bits & long lo mask ; arrays . fill ( v , num , fill words , long all bits ) ; if ( fill words < v . length ) { v [ v . length - num ] = ( num << fill bits ) - num ; } return v ; }	create a vector initialized with " bits " ones .
private boolean check current key age ( ) throws number format exception { long current token key ts = long . parse long ( cached token keys bundle . get current key entry ( ) ) ; long now = system . current time millis ( ) ; long diff = now - current token key ts ; if ( diff >= key rotation interval in msecs ) { return bool ; } return bool ; }	looks at the current key timestamp.
public final void push context node list ( dtm nl ) { m context node lists . push ( nl ) ; }	set the current context node list .
public void note ( element e , string msg ) { messager . print message ( diagnostic . kind . note , msg , e ) ; }	triggered if a note issued during processing.
public static public key generate public key ( string encoded public key ) { try { byte [ ] decoded key = base64 . decode ( encoded public key , base64 . default ) ; key factory key factory = key factory . get instance ( key factory algorithm ) ; return key factory . generate public ( new x509 encoded key spec ( decoded key ) ) ; } catch ( no such algorithm exception e ) { throw new runtime exception ( e ) ; } catch ( invalid key spec exception e ) { log . e ( tag , str ) ; throw new illegal argument exception ( e ) ; } }	generates a publickey instance from a string containing the base64 - encoded public key .
@ override public enumeration < option > list options ( ) { vector < option > result = new vector < option > ( ) ; result . add all ( collections . list ( super . list options ( ) ) ) ; result . add element ( new option ( str , str , num , str ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
public trust source add ( file trusted ca ) { if ( trusted ca == null ) { throw new illegal argument exception ( str ) ; } string pem file contents ; try { pem file contents = files . to string ( trusted ca , charset . for name ( str ) ) ; } catch ( io e ) { throw new io ( str + trusted ca . get absolute path ( ) , e ) ; } return add ( pem file contents ) ; }	returns a new trustsource containing the same trusted cas as this trustsource , plus zero or more cas contained in the pem - encoded file.
string vector process stringlist ( stylesheet handler handler , string uri , string name , string raw name , string value ) { string tokenizer tokenizer = new string tokenizer ( value , str ) ; int n strings = tokenizer . count tokens ( ) ; string vector strings = new string vector ( n strings ) ; for ( int i = num ; i < n strings ; i ++ ) { strings . add element ( tokenizer . next token ( ) ) ; } return strings ; }	process an attribute string of type t_stringlist into a vector of xpath match patterns .
public static attribute description object class ( ) { return object class ; }	returns an attribute description representing the object class attribute type with no options .
public void add key value comment ( string key name , string value ) { int key index ; if ( ( key index = find key comment index ( key name ) ) < num ) { key val comments . add ( str + key name + str + value + str ) ; return ; } log . warn ( str + key name + str ) ; key val comments . set ( key index , str + key name + str + value + str ) ; }	updates the internal key / value storage to reflect the parameters.
private string is input checked ( string data set , string value ) { if ( data set != null && data set . equals ( value ) ) { return str ; } return str ; }	returns a string which indicates if the input was checked in a submitted form .
public final void pop sub context list ( ) { m axes iterator stack . pop ( ) ; }	pop the last pushed axes iterator .
private driver task create driver task ( string task type ) { string task id = string . format ( str , h par . driver name , task type , uuid . random uuid ( ) ) ; driver task task = new h par ( task id ) ; return task ; }	create driver task for task type.
public void store ( element cat , list < string > trees ) { catalog tree manager manager = instance manager . get default ( jmri . catalog tree manager . class ) ; cat . set attribute ( str , str ) ; iterator < string > iter = trees . iterator ( ) ; while ( iter . has next ( ) ) { string sname = iter . next ( ) ; if ( sname == null ) { log . error ( str ) ; continue ; } if ( log . is debug enabled ( ) ) { log . debug ( str + sname ) ; } if ( sname . char at ( num ) != catalog tree . xml ) { continue ; } catalog tree ct = manager . get by system name ( sname ) ; element elem = new element ( str ) ; elem . set attribute ( str , sname ) ; string uname = ct . get user name ( ) ; if ( uname != null ) { elem . set attribute ( str , uname ) ; } store node ( elem , ct . get root ( ) ) ; if ( log . is debug enabled ( ) ) { log . debug ( str + sname ) ; } cat . add content ( elem ) ; } }	default implementation for storing the contents of a catalogtreemanager.
public boolean is enabled ( ) { return enabled ; }	tells if this processor is enabled or not.
public static boolean load texture ( int gl id , int file ) { input stream is = resource . get res input stream ( file ) ; bitmap bitmap = null ; try { bitmap factory . options opts = new bitmap factory . options ( ) ; opts . in scaled = bool ; bitmap = bitmap factory . decode stream ( is , null , opts ) ; } catch ( exception e ) { log . e ( tag , str + file , e ) ; return bool ; } finally { try { is . close ( ) ; } catch ( exception e ) { log . e ( tag , str , e ) ; } } return load texture ( gl id , bitmap ) ; }	loads one texture file.
public static int roll1 d100 ( ) { return rand . next int ( num ) + num ; }	simulates rolling a dice with 100 sides .
public zipfian generator ( long min , long max , double zipfianconstant , double zetan ) { items = max - min + num ; base = min ; zipfianconstant = zipfianconstant ; theta = zipfianconstant ; zeta2theta = zeta ( num , theta ) ; alpha = num / ( num - theta ) ; zetan = zetan ; countforzeta = items ; eta = ( num - math . pow ( num / items , num - theta ) ) / ( num - zeta2theta / zetan ) ; next int ( ) ; }	create a zipfian generator for items between min and max ( inclusive ) for the specified zipfian constant , using the precomputed value of zeta .
public void remove role ( role entity role ) { roles . remove ( role ) ; }	removes the given role from this user.
private map process event ( match result result ) { map map = new hash map ( ) ; for ( int i = num ; i < result . group count ( ) + num ; i ++ ) { object key = matching keywords . get ( i - num ) ; object value = result . group ( i ) ; map . put ( key , value ) ; } return map ; }	convert the match into a map . < p > relies on the fact that the matchingkeywords list is in the same order as the groups in the regular expression.
public void add extension ( string ext ) { exts . add ( ext . to lower case ( ) ) ; }	add a file extension to this file filter .
public boolean equals ( object o ) { if ( o == this ) return bool ; if ( ! ( o instanceof m ) ) return bool ; m p = ( m ) o ; return ( objects . equals ( p . get name ( ) , get name ( ) ) && objects . equals ( p . get type ( ) , get type ( ) ) && objects . equals ( p . get description ( ) , get description ( ) ) && objects . equals ( p . get descriptor ( ) , get descriptor ( ) ) && p . is readable ( ) == is readable ( ) && p . is writable ( ) == is writable ( ) && p . is is ( ) == is is ( ) ) ; }	compare this mbeanattributeinfo to another .
protected boolean handle directory ( file directory , string [ ] content names ) throws security exception { boolean continue wandering = bool ; for ( string child : content names ) { boolean keep going = handle entry ( new file ( directory . get absolute path ( ) + file . separator , child ) ) ; if ( ! keep going ) { continue wandering = exhaustive search ; if ( ! continue wandering ) { break ; } } } return continue wandering ; }	management method for the wanderer , that steps through the children of the directory and calls handleentry for them .
int size ( ) { return integer . bit count ( set ) ; }	returns the number of settings that have values assigned .
public boolean has next ( ) { return iterator . has next ( ) ; }	tells if there are more sockectchannel left in the iterator.
public static string format number ( final long number ) { long divided = number ; final string buffer sb = new string buffer ( ) ; while ( divided > num ) { long rest = divided % num ; sb . insert ( num , str + string . format ( str , rest ) ) ; divided = divided / num ; } long rest = divided % num ; sb . insert ( num , rest ) ; return sb . to string ( ) ; }	formats the given number into one where thousands are separated by a space .
private boolean is subsumed ( string selector , iterable < string > others ) { for ( string other : others ) { if ( subsumes ( other , selector ) ) { return bool ; } } return bool ; }	check whether selector is subsumed by any of other selectors .
private void display values ( ) { log ( str , project . msg info ) ; log ( str + this . spec ) ; log ( str + get spec absolute path ( ) ) ; log ( str + get serialized spec absolute path ( ) ) ; log ( str + this . specdir ) ; log ( str + this . cup2srcdir ) ; log ( str + this . classpath ) ; log ( str + this . algorithm ) ; log ( str + this . verbose ) ; log ( str + this . parsetable ) ; log ( str ) ; }	display all field values.
private boolean check touching min target ( int index , motion event event ) { if ( is touching min target ( index , event ) ) { last touched min = bool ; is touching min target . add ( event . get pointer id ( index ) ) ; if ( ! min animator . is running ( ) ) { min animator = get min target animator ( bool ) ; min animator . start ( ) ; } return bool ; } return bool ; }	checks if given index is touching the min target.
public boolean is canceled ( ) { if ( pane == null ) return bool ; object v = pane . get value ( ) ; return ( ( v != null ) && ( cancel option . length == num ) && ( v . equals ( cancel option [ num ] ) ) ) ; }	returns true if the user hits the cancel button in the progress dialog .
public int available processors ( ) { return rvm . available processors ; }	return the number of processors , always at least one .
public final static void debug ( string s ) { if ( debug ) debug . println ( str + s ) ; }	print a debug message on debug stream associated with this interpreter only if debugging is turned on .
public static final void write long array xml ( long [ ] val , string name , xml serializer out ) throws xml pull parser exception , io { if ( val == null ) { out . start tag ( null , str ) ; out . end tag ( null , str ) ; return ; } out . start tag ( null , str ) ; if ( name != null ) { out . attribute ( null , str , name ) ; } final int n = val . length ; out . attribute ( null , str , integer . to string ( n ) ) ; for ( int i = num ; i < n ; i ++ ) { out . start tag ( null , str ) ; out . attribute ( null , str , long . to string ( val [ i ] ) ) ; out . end tag ( null , str ) ; } out . end tag ( null , str ) ; }	flatten a long [ ] into an xmlserializer.
public static < t extends generic entity > list < t > filter by or ( list < t > values , list < ? extends entity condition > exprs ) { if ( values == null ) return null ; if ( util validate . is empty ( exprs ) ) { return values ; } list < t > result = new linked list < t > ( ) ; for ( t value : values ) { boolean include = bool ; for ( entity condition condition : exprs ) { include = condition . entity matches ( value ) ; if ( include ) break ; } if ( include ) { result . add ( value ) ; } } return result ; }	returns the values that match any of the exprs in list.
@ override public res next ( req req ) { write trace log ( req , middleware name ) ; if ( predicate . test ( req ) ) { res res = middleware . handle ( req , next ) ; write trace log ( res , middleware name ) ; return res ; } else if ( next != null ) { res res = ( res ) next . next ( req ) ; write trace log ( res , middleware name ) ; return res ; } else { return null ; } }	dispatches a request to the next chain of middleware .
protected void read ( long offset , byte [ ] b ) throws io { rafile . seek ( offset ) ; if ( rafile . read ( b ) != b . length ) { throw new io ( str + get path ( ) ) ; } }	reads a number of bytes from the rrd file on the disk.
public void run ( ) { final fetcher info info = fetcher info . get fetcher info ( ) ; try { fetchloop ( ) ; } catch ( exception e ) { e . print stack trace ( ) ; } finally { synchronized ( info . wait list ) { thread me = thread . current thread ( ) ; for ( int i = num ; i < info . fetchers . length ; i ++ ) { if ( info . fetchers [ i ] == me ) { info . fetchers [ i ] = null ; info . num fetchers -- ; } } } } }	the main run ( ) method of an imagefetcher thread.
public ct class make annotation ( string name ) throws runtime exception { try { ct class cc = make interface ( name , get ( str ) ) ; cc . set modifiers ( cc . get modifiers ( ) | modifier . annotation ) ; return cc ; } catch ( not found exception e ) { throw new runtime exception ( e . get message ( ) , e ) ; } }	creates a new annotation.
public void test negate math context negative ( ) { string a = str ; int a scale = num ; int precision = num ; rounding mode rm = rounding mode . ceiling ; math context mc = new math context ( precision , rm ) ; string c = str ; int c scale = num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal res = a number . negate ( mc ) ; assert equals ( str , c , res . to string ( ) ) ; assert equals ( str , c scale , res . scale ( ) ) ; }	negate ( mathcontext ) for a negative bigdecimal.
public void add ( node node ) { available nodes . add ( node ) ; }	adds a node that can appear in programs produced using these rules .
public void write ( output stream out ) throws io { data output stream data out = new data output stream ( out ) ; data out . write short ( pool . size ( ) + num ) ; for ( entry e : pool ) { e . write ( data out ) ; } }	write this constant pool to a stream as part of the class file format.
protected foreign key constraint build foreign key constraint ( list < string > fk field names , list < string > pk field names , table definition target table , database platform platform ) { assert fk field names . size ( ) > num && fk field names . size ( ) == pk field names . size ( ) ; foreign key constraint fk constraint = new foreign key constraint ( ) ; for ( int i = num ; i < fk field names . size ( ) ; i ++ ) { fk constraint . get source fields ( ) . add ( fk field names . get ( i ) ) ; fk constraint . get target fields ( ) . add ( pk field names . get ( i ) ) ; } fk constraint . set target table ( target table . get full name ( ) ) ; string fk field name = fk field names . get ( num ) ; string name = build foreign key constraint name ( this . get name ( ) , fk field name , platform . get max foreign key name size ( ) , platform ) ; fk constraint . set name ( name ) ; return fk constraint ; }	build a foreign key constraint .
public server builder ( config config ) { objects . require non null ( config ) ; config = config ; }	creates a new server builder .
private static ldap create substring filter ( substring filter sf ) throws ldap , io { list < object > anyo = sf . get any ( ) ; array list < byte string > sub any elements = new array list < > ( anyo . size ( ) ) ; for ( object o : anyo ) { sub any elements . add ( byte string utility . convert value ( o ) ) ; } if ( sf . get initial ( ) == null && sub any elements . is empty ( ) && sf . get final ( ) == null ) { localizable message message = err ldap filter decode null . get ( ) ; throw new ldap ( ldap . protocol error , message ) ; } return ldap . create substring filter ( sf . get name ( ) , sf . get initial ( ) == null ? null : byte string utility . convert value ( sf . get initial ( ) ) , sub any elements , sf . get final ( ) == null ? null : byte string utility . convert value ( sf . get final ( ) ) ) ; }	returns a new substring search filter with the provided information .
@ override protected void on size changed ( int w , int h , int oldw , int oldh ) { if ( ready sent ) { set scale and center ( get scale ( ) , get center ( ) ) ; } }	on resize , preserve center and scale.
protected void disown ( abstract node child ) throws illegal state exception { ensure parentage ( child ) ; child . parent = null ; }	disowns a direct child ( it will be parentless after this call ) .
public string q name2 string ( q q name , boolean write ns ) { string prefix = null ; string namespace uri = q name . get namespace ( ) ; string local part = q name . get local part ( ) ; if ( local part != null && local part . length ( ) > num ) { int index = local part . index of ( str ) ; if ( index != - num ) { prefix = local part . substring ( num , index ) ; if ( prefix . length ( ) > num && ! prefix . equals ( str ) ) { register prefix for uri ( prefix , namespace uri ) ; local part = local part . substring ( index + num ) ; } else { prefix = null ; } } local part = get last local part ( local part ) ; } if ( namespace uri . length ( ) == num ) { if ( write ns ) { string default ns = ns stack . get namespace uri ( str ) ; if ( default ns != null && default ns . length ( ) > num ) { register prefix for uri ( str , str ) ; } } } else { prefix = get prefix for uri ( namespace uri , q name . get preferred prefix ( ) ) ; } if ( ( prefix == null ) || ( prefix . length ( ) == num ) ) return local part ; return prefix + str + local part ; }	convert qname to a string of the form < prefix > : < localpart >.
@ override public void close ( ) throws xml { log . log ( level . fine , str ) ; stream . close ( ) ; }	frees any resources associated with this stream.
public void test divide round half up neg2 ( ) { string a = str ; int a scale = num ; string b = str ; int b scale = num ; string c = str ; int res scale = - num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; big decimal result = a number . divide ( b number , res scale , big decimal . round half up ) ; assert equals ( str , c , result . to string ( ) ) ; assert equals ( str , res scale , result . scale ( ) ) ; }	divide : rounding mode is round_half_up , result is negative ; equidistant.
@ override public string read line ( ) throws io { if ( this . pointer >= this . data . length - num ) { return null ; } else { final string builder buf = new string builder ( ) ; int c ; while ( ( c = read ( ) ) >= num ) { if ( ( c == num ) || ( c == num ) ) { if ( ( ( peek ( ) == num ) || ( peek ( ) == num ) ) && ( peek ( ) != c ) ) { read ( ) ; } break ; } buf . append ( ( char ) c ) ; } return buf . to string ( ) ; } }	return next line ( returns null if no line ).
protected static map attr set to map ( attr set attr set , boolean fetch byte values ) { map attributes map = new am ( fetch byte values ) ; if ( attr set == null ) { return attributes map ; } int attr set size = attr set . size ( ) ; if ( ! fetch byte values ) { for ( int i = num ; i < attr set size ; i ++ ) { attr attr = attr set . element at ( i ) ; string values [ ] = attr . get string values ( ) ; attributes map . put ( attr . get name ( ) , string array to set ( values ) ) ; } } else { for ( int i = num ; i < attr set size ; i ++ ) { attr attr = attr set . element at ( i ) ; attributes map . put ( attr . get name ( ) , attr . get byte values ( ) ) ; } } return attributes map ; }	method to convert a attrset object to map .
public < e > e parse response data ( g req , class < e > result type ) throws io , service exception { input properties input properties = new client input properties ( req , result type ) ; return parse response data ( req . get parse source ( ) , input properties , result type ) ; }	parses the response stream for a request based upon request properties and an expected result type.
public void add rtp stream listener ( rtp stream listener rtp stream listener ) { m rtp stream listener = rtp stream listener ; }	adds the rtp stream listener.
public synchronized byte [ ] to byte array ( ) { int remaining = count ; if ( remaining == num ) { return empty byte array ; } byte [ ] newbuf = new byte [ remaining ] ; int pos = num ; for ( byte [ ] buf : buffers ) { int c = math . min ( buf . length , remaining ) ; system . arraycopy ( buf , num , newbuf , pos , c ) ; pos += c ; remaining -= c ; if ( remaining == num ) { break ; } } return newbuf ; }	gets the curent contents of this byte stream as a byte array.
public void add volumes to consistency group ( string cg name , list < string > virtual volume names ) throws v { s logger . info ( str , base uri ) ; cg mgr . add volumes to consistency group ( cg name , virtual volume names ) ; }	adds the volumes with the passed names to the consistency group with the passed name .
public void test constructor sign bytes positive6 ( ) { byte a bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num , num , - num } ; int a sign = num ; byte r bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num , num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = a number . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , a number . signum ( ) ) ; }	create a positive number from a sign and an array of bytes.
public static boolean looks like a ( string val ) { return font styles . index of ( val ) >= num ; }	description of the method.
public static void dump cursor ( i cursor , int max column width ) { string builder builder = new string builder ( str ) ; dump cursor ( cursor , max column width , builder ) ; logger . d ( logger . log tag , builder . to string ( ) ) ; }	dump the contents of the cursor to the system log , formatted in a readable way.
static int compute valid levels ( long bit pattern ) { return long . bit count ( bit pattern ) ; }	computes the number of valid levels above the base buffer.
public static void run under lock ( reentrant lock lock , runnable runnable ) { lock . lock ( ) ; try { runnable . run ( ) ; } finally { lock . unlock ( ) ; } }	run given runnable under given lock.
@ override public int insert ( string elem ) { int first index = ( int ) ( elem . char at ( num ) - str ) ; int last index = ( int ) ( elem . char at ( elem . length ( ) - num ) - str ) ; storage [ first index * num + last index ] = elem ; return num ; }	insert element into collection.
public void clear movement data ( ) { path sprites = new array list < step sprite > ( ) ; movement target = null ; check fo v ( ) ; repaint ( ) ; refresh move vectors ( ) ; }	clears current movement data from the screen.
public void thread record failure ( throwable t ) { thread failure . compare and set ( null , t ) ; }	records an exception so that it can be rethrown later in the test harness thread , triggering a test case failure.
protected boolean replay completion ( participant participant ) throws illegal state exception { if ( ! replay stack . contains ( participant ) ) { replay stack . push ( participant ) ; } return committed ; }	handle a replay request for a participant.
public void test decoder7 ( ) { boolean res ; string original app id name = m app id name ; int original content type value = m content type value ; random rd = new random ( ) ; for ( int i = num ; i < oma content type names . length ; i ++ ) { m content type name = oma content type names [ i ] ; byte [ ] pdu = create pdu ( num ) ; wsp type decoder pdu decoder = new wsp type decoder ( pdu ) ; res = pdu decoder . decode content type ( m wsp content type start ) ; assert true ( res ) ; log . d ( log tag , str + m content type name + str + pdu decoder . get value string ( ) + str ) ; assert true ( m content type name . equals ( pdu decoder . get value string ( ) ) ) ; } m app id name = original app id name ; m content type value = original content type value ; }	wsptypedecoder test , decode oma content type.
public void shutdown now ( ) { shutdown = bool ; final future < ? > f = engine future . get ( ) ; if ( f != null ) { if ( log . is info enabled ( ) ) log . info ( str + this ) ; f . cancel ( bool ) ; } final executor service s = engine service . get ( ) ; if ( s != null ) { if ( log . is info enabled ( ) ) log . info ( str + this ) ; s . shutdown now ( ) ; } final http client cm = client connection manager ref . get ( ) ; if ( cm != null ) { if ( log . is info enabled ( ) ) log . info ( str + this ) ; try { cm . stop ( ) ; } catch ( exception e ) { log . error ( str , e ) ; } } for ( abstract running query q : running queries . values ( ) ) { q . cancel ( bool ) ; } priority queue . clear ( ) ; deadline queue . clear ( ) ; engine future . set ( null ) ; engine service . set ( null ) ; client connection manager ref . set ( null ) ; }	do not accept new queries and halt any running binding set chunk tasks .
static public void add notification listener ( jmx jmx connector , class < ? > mbean class , notification listener notification listener ) throws instance not found exception , exception { m mbsc = jmx connector . get m ( ) ; object name object name = generate m ( mbean class ) ; mbsc . add notification listener ( object name , notification listener , null , null ) ; }	attach notificationlistener that can be used to listen notifications emitted by mbean server .
protected string to html ( string s ) { string result ; result = s ; result = result . replace all ( str , str ) ; result = result . replace all ( str , str ) ; result = result . replace all ( str , str ) ; result = result . replace all ( str , str ) ; result = result . replace all ( str , str ) ; return result ; }	converts the given string into html , i.
protected void normalize scores ( ) { double hub ssum = num ; double auth ssum = num ; for ( v v : graph . get vertices ( ) ) { double hub val = get output value ( v ) . hub ; double auth val = get output value ( v ) . authority ; hub ssum += ( hub val * hub val ) ; auth ssum += ( auth val * auth val ) ; } hub ssum = math . sqrt ( hub ssum ) ; auth ssum = math . sqrt ( auth ssum ) ; for ( v v : graph . get vertices ( ) ) { hits . scores values = get output value ( v ) ; set output value ( v , new hits . scores ( values . hub / hub ssum , values . authority / auth ssum ) ) ; } }	normalizes scores so that sum of their squares = 1.
public static int absolute max ( int [ ] int array ) { int max = integer . min value ; for ( int i = num ; i < int array . length ; i ++ ) { if ( math . abs ( int array [ i ] ) > max && int array [ i ] != num ) { max = int array [ i ] ; } } return max == integer . min value ? num : max ; }	gets the absolute maximum element of an integer array .
private boolean do acquire nanos ( long arg , long nanos timeout ) throws interrupted exception { if ( nanos timeout <= num ) return bool ; final long deadline = system . nano time ( ) + nanos timeout ; final node node = add waiter ( node . exclusive ) ; boolean failed = bool ; try { for ( ; ; ) { final node p = node . predecessor ( ) ; if ( p == head && try acquire ( arg ) ) { set head ( node ) ; p . next = null ; failed = bool ; return bool ; } nanos timeout = deadline - system . nano time ( ) ; if ( nanos timeout <= num ) return bool ; if ( should park after failed acquire ( p , node ) && nanos timeout > spin for timeout threshold ) lock support . park nanos ( this , nanos timeout ) ; if ( thread . interrupted ( ) ) throw new interrupted exception ( ) ; } } finally { if ( failed ) cancel acquire ( node ) ; } }	acquires in exclusive timed mode .
boolean has min feature count ( string feature ) { if ( min feature count == num ) return bool ; set < integer > ids = clipped feature index . get ( feature ) ; if ( ids == null ) return bool ; return ids . size ( ) >= min feature count ; }	determine whether a feature has been seen enough times to learn a decoding model weight for it.
void mutate ( ) { do { int i bit ; do { i bit = m random . next int ( m n nodes * m n nodes ) ; } while ( is square ( i bit ) ) ; m bits [ i bit ] = ! m bits [ i bit ] ; } while ( has cycles ( ) ) ; calc score ( ) ; }	apply mutation operation to bayesnet calculate score and as a side effect sets bayesnet parent sets .
public void put ( e e ) throws interrupted exception { check not null ( e ) ; final reentrant lock lock = this . lock ; lock . lock interruptibly ( ) ; try { while ( count == items . length ) not full . await ( ) ; enqueue ( e ) ; } finally { lock . unlock ( ) ; } }	inserts the specified element at the tail of this queue , waiting for space to become available if the queue is full .
private void delete comments ( span manager sm ) { int start = num ; while ( ( start = sm . index of ( str , start ) ) != - num ) { int end = sm . index of ( str , start + num ) + num ; if ( end == - num + num ) { end = sm . length ( ) ; } try { if ( line separator . equals ( sm . substring ( start - line separator . length ( ) , start ) ) && line separator . equals ( sm . substring ( end , end + line separator . length ( ) ) ) ) { end += line separator . length ( ) ; } } catch ( index out of bounds exception e ) { } sm . delete ( start , end ) ; } }	deleting all comments out of the spanmanager.
date time parse context ( date time formatter formatter ) { super ( ) ; this . formatter = formatter ; parsed . add ( new parsed ( ) ) ; }	creates a new instance of the context .
public static boolean is network type cellular ( string network type ) { return network type . equals ( str ) ; }	check if connected to cellular provider.
private void define internal frame close buttons ( ui d ) { string p = str ; string c = painter prefix + str ; d . put ( p + str , str ) ; d . put ( p + str , new title pane close button window not focused state ( ) ) ; d . put ( p + str , new ui ( num , num , num , num ) ) ; d . put ( p + str , new lazy painter ( c , title pane close button painter . which . background disabled ) ) ; d . put ( p + str , new lazy painter ( c , title pane close button painter . which . background enabled ) ) ; d . put ( p + str , new lazy painter ( c , title pane close button painter . which . background mouseover ) ) ; d . put ( p + str , new lazy painter ( c , title pane close button painter . which . background pressed ) ) ; d . put ( p + str , new lazy painter ( c , title pane close button painter . which . background enabled windownotfocused ) ) ; d . put ( p + str , new lazy painter ( c , title pane close button painter . which . background mouseover ) ) ; d . put ( p + str , new lazy painter ( c , title pane close button painter . which . background pressed windownotfocused ) ) ; d . put ( p + str , new sea glass icon ( p , str , num , num ) ) ; }	initialize the internal frame close button settings .
private void modify ( storage port port , string port network id ) { port . set port network id ( port network id ) ; db client . persist object ( port ) ; modified storage ports list . add ( port ) ; }	modify the port with new port network id .
public boolean is ( string word ) { return m . contains ( word . to lower case ( ) ) ; }	returns true if the given string is a stop word .
public static final string remove multiple spaces and returns ( final string data ) { final string builder all data = new string builder ( data ) ; int i = num ; while ( i < all data . length ( ) ) { if ( ( ( all data . char at ( i ) == str ) && ( all data . char at ( i - num ) == str ) ) || ( ( all data . char at ( i ) == character . line separator ) && ( all data . char at ( i - num ) == character . line separator ) ) ) { all data . delete char at ( i ) ; } else { i ++ ; } } return all data . to string ( ) ; }	remove multiple spaces and returns so just single value if multiples together - if it fails will just return data.
public void remove listener ( connectable device listener listener ) { listeners . remove ( listener ) ; }	removes a previously added conenctabledevicelistener from the list of listeners for this connectabledevice .
private void notifiy download state ( ) { synchronized ( m download monitor ) { log . v ( log tag , str ) ; m download monitor . notify ( ) ; } }	send a notification via the mdownloadmonitor when a download is complete .
private pkix pkix ( x509 certificate end cert ) throws certificate path building exception { x509 cert selector target constraints = new x509 cert selector ( ) ; target constraints . set certificate ( end cert ) ; pkix params ; try { params = new pkix ( trust store , target constraints ) ; params . set revocation enabled ( bool ) ; } catch ( key store exception e ) { throw new certificate path building exception ( str + e . get message ( ) , e ) ; } catch ( invalid algorithm parameter exception e ) { throw new certificate path building exception ( str + e . get message ( ) , e ) ; } catch ( throwable e ) { throw new certificate path building exception ( str + e . get message ( ) , e ) ; } collection < object > cert collection = new array list < object > ( ) ; add certificate candidates ( end cert , cert collection ) ; if ( ! cert collection . is empty ( ) ) { try { cert store cert store = cert store . get instance ( str , new collection cert store parameters ( cert collection ) ) ; params . add cert store ( cert store ) ; } catch ( invalid algorithm parameter exception e ) { throw new certificate path building exception ( str + e . get message ( ) , e ) ; } catch ( no such algorithm exception e ) { throw new certificate path building exception ( str + e . get message ( ) , e ) ; } } else { logger . debug ( str ) ; } return params ; }	create and init pkixbuilderparameters for certpathbuilder .
public void print stack trace ( ) { throwable t ; string writer writer ; writer = new string writer ( ) ; t = new throwable ( ) ; t . fill in stack trace ( ) ; t . print stack trace ( new print writer ( writer ) ) ; println ( writer . to string ( ) ) ; }	prints the current stacktrace.
protected int effective band size ( final int dim1 , final int dim2 ) { if ( band size == double . positive infinity ) { return ( dim1 > dim2 ) ? dim1 : dim2 ; } if ( band size >= num ) { return ( int ) band size ; } return ( int ) math . ceil ( ( dim1 >= dim2 ? dim1 : dim2 ) * band size ) ; }	compute the effective band size .
public static int encode longitude ceil ( double longitude ) { geo utils . check longitude ( longitude ) ; if ( longitude == num ) { longitude = math . next down ( longitude ) ; } return ( int ) math . ceil ( longitude / lon decode ) ; }	quantizes double ( 64 bit ) longitude into 32 bits ( rounding up : in the direction of + 180 ).
private linked list < diff > diff line mode ( string text1 , string text2 , long deadline ) { lines to chars result b = diff lines to chars ( text1 , text2 ) ; text1 = b . chars1 ; text2 = b . chars2 ; list < string > linearray = b . line array ; linked list < diff > diffs = diff main ( text1 , text2 , bool , deadline ) ; diff chars to lines ( diffs , linearray ) ; diff cleanup semantic ( diffs ) ; diffs . add ( new diff ( operation . equal , str ) ) ; int count delete = num ; int count insert = num ; string text delete = str ; string text insert = str ; list iterator < diff > pointer = diffs . list iterator ( ) ; diff this diff = pointer . next ( ) ; while ( this diff != null ) { switch ( this diff . operation ) { case insert : count insert ++ ; text insert += this diff . text ; break ; case delete : count delete ++ ; text delete += this diff . text ; break ; case equal : if ( count delete >= num && count insert >= num ) { pointer . previous ( ) ; for ( int j = num ; j < count delete + count insert ; j ++ ) { pointer . previous ( ) ; pointer . remove ( ) ; } for ( diff new diff : diff main ( text delete , text insert , bool , deadline ) ) { pointer . add ( new diff ) ; } } count insert = num ; count delete = num ; text delete = str ; text insert = str ; break ; } this diff = pointer . has next ( ) ? pointer . next ( ) : null ; } diffs . remove last ( ) ; return diffs ; }	do a quick line - level diff on both strings , then rediff the parts for greater accuracy.
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return id ; case num : return create time ; case num : return update time ; case num : return operation ; case num : return status ; case num : return src path ; case num : return src cluster ; case num : return src db ; case num : return src table ; case num : return src partitions ; case num : return src modified time ; case num : return rename to db ; case num : return rename to table ; case num : return rename to path ; case num : return extras ; case num : return waiting on jobs ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public json append key hash ( object key ) { if ( stack . empty ( ) || stack . peek ( ) != operand . hash ) { throw new json ( str ) ; } add quoted string ( key ) ; buffer . append ( str ) ; buffer . append ( str ) ; stack . push ( operand . hash ) ; return this ; }	append a key an start a new hash.
static replay promise < void > any replay ( final duration timeout , final promise < ? > ... promises ) { return any replay ( timeout , system . current time millis ( ) , promises ) ; }	any promises must complete .
public static policy service send pll ( url policy service url , policy request preq ) throws send request exception , policy exception { string lbcookie = null ; try { lbcookie = get lb ( preq ) ; } catch ( exception e ) { throw new send request exception ( e ) ; } policy service policy service = new policy service ( ) ; policy service . set method id ( policy service . policy request id ) ; policy service . set policy request ( preq ) ; string xml string = policy service . to xml ( ) ; request request = new request ( xml string ) ; request set request set = new request set ( policy service . policy service ) ; request set . add request ( request ) ; if ( debug . message enabled ( ) ) { debug . message ( str + str + policy service url + str + xml string ) ; } vector responses = pll . send ( policy service url , lbcookie , request set ) ; response response = ( response ) responses . element at ( num ) ; policy service ps = policy service . parse xml ( response . get content ( ) ) ; if ( debug . message enabled ( ) ) { debug . message ( str + str + ps . to xml ( ) ) ; } return ps ; }	return a policyservice object based on the xml document received from remote policy server.
public static uri create id ( class < ? extends data object > clazz ) { return new id ( clazz , get location ( clazz ) ) ; }	creates a uri for an object of type clazz.
public static double log2 ( double x ) { return math . log ( x ) * one by lo ; }	compute the base 2 logarithm .
public void insert element at ( node value , int at ) { if ( ! m mutable ) throw new runtime exception ( xsl . create xpath ( xpath . er nodeset not mutable , null ) ) ; if ( null == m map ) { m map = new node [ m blocksize ] ; m map size = m blocksize ; } else if ( ( m first free + num ) >= m map size ) { m map size += m blocksize ; node new map [ ] = new node [ m map size ] ; system . arraycopy ( m map , num , new map , num , m first free + num ) ; m map = new map ; } if ( at <= ( m first free - num ) ) { system . arraycopy ( m map , at , m map , at + num , m first free - at ) ; } m map [ at ] = value ; m first free ++ ; }	inserts the specified node in this vector at the specified index.
public result regress ( discrete variable x , list < node > regressors ) { if ( ! binary ( x ) ) { throw new illegal argument exception ( str ) ; } for ( node node : regressors ) { if ( ! ( node instanceof continuous variable || binary ( node ) ) ) { throw new illegal argument exception ( str ) ; } } double [ ] [ ] regressors = new double [ regressors . size ( ) ] [ get rows ( ) . length ] ; for ( int j = num ; j < regressors . size ( ) ; j ++ ) { int col = data set . get column ( regressors . get ( j ) ) ; double [ ] data col = data cols [ col ] ; for ( int i = num ; i < get rows ( ) . length ; i ++ ) { regressors [ j ] [ i ] = data col [ get rows ( ) [ i ] ] ; } } int [ ] target = new int [ get rows ( ) . length ] ; int col = data set . get column ( data set . get variable ( x . get name ( ) ) ) ; for ( int i = num ; i < get rows ( ) . length ; i ++ ) { target [ i ] = data set . get int ( get rows ( ) [ i ] , col ) ; } list < string > regressor names = new array list < > ( ) ; for ( node node : regressors ) { regressor names . add ( node . get name ( ) ) ; } return regress ( target , x . get name ( ) , regressors , regressor names ) ; }	x must be binary ; regressors must be continuous or binary .
void copy file ( string source , string target ) ;	copy a file from a source to a destination.
static public list < sequence < i > > tokenize file ( string filename , boolean do nist ) { list < sequence < i > > sequences = new array list < > ( ) ; line number reader reader = io . get reader from file ( filename ) ; try { for ( string line ; ( line = reader . read line ( ) ) != null ; ) { if ( do nist ) line = nist . tokenize ( line ) ; sequences . add ( i . tokenize ( line ) ) ; } reader . close ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } return sequences ; }	convert a newline - delimited file to a list of sequences , optionally applying nist tokenization .
public statement like ( string expr ) { statement . append ( str ) ; append escaped sql ( statement , expr ) ; return this ; }	appending the like operator clause .
public static kdbx header read kdbx header ( kdbx header kdbx header , input stream input stream ) throws io { message digest digest = encryption . get message digest instance ( ) ; digest input stream digest input stream = new digest input stream ( input stream , digest ) ; little endian data input stream ledis = new little endian data input stream ( digest input stream ) ; if ( ! verify magic number ( ledis ) ) { throw new illegal state exception ( str ) ; } if ( ! verify file version ( ledis ) ) { throw new illegal state exception ( str ) ; } byte header type ; while ( ( header type = ledis . read byte ( ) ) != header type . end ) { switch ( header type ) { case header type . comment : get byte array ( ledis ) ; break ; case header type . cipher id : kdbx header . set cipher uuid ( get byte array ( ledis ) ) ; break ; case header type . compression flags : kdbx header . set compression flags ( get int ( ledis ) ) ; break ; case header type . master seed : kdbx header . set master seed ( get byte array ( ledis ) ) ; break ; case header type . transform seed : kdbx header . set transform seed ( get byte array ( ledis ) ) ; break ; case header type . transform rounds : kdbx header . set transform rounds ( get long ( ledis ) ) ; break ; case header type . encryption iv : kdbx header . set encryption iv ( get byte array ( ledis ) ) ; break ; case header type . protected stream key : kdbx header . set protected stream key ( get byte array ( ledis ) ) ; break ; case header type . stream start bytes : kdbx header . set stream start bytes ( get byte array ( ledis ) ) ; break ; case header type . inner random stream id : kdbx header . set inner random stream id ( get int ( ledis ) ) ; break ; default : throw new illegal state exception ( str ) ; } } get byte array ( ledis ) ; kdbx header . set header hash ( digest . digest ( ) ) ; return kdbx header ; }	populate a kdbxheader from the input stream supplied.
public static byte [ ] copy to byte array ( input stream in ) throws io { byte array output stream out = new byte array output stream ( buffer size ) ; copy ( in , out ) ; return out . to byte array ( ) ; }	copy the contents of the given inputstream into a new byte array.
public boolean is enum constant ( ) { return ( get modifiers ( ) & modifier . enum ) != num ; }	indicates whether or not this field is an enumeration constant .
public boolean contains any ( collection < taxon > taxa ) { for ( taxon taxon : taxa ) { if ( taxa . contains ( taxon ) ) { return bool ; } } return bool ; }	returns true if at least 1 member of taxonlist is contained in this taxa .
@ suppress warnings ( str ) public synchronized t dequeue task ( ) throws interrupted exception { while ( data . is empty ( ) ) { if ( ! closed input ) wait ( ) ; else return ( t ) no more tasks ; } t t = data . remove first ( ) ; notify ( ) ; return t ; }	synchronized read and delete from the top of the fifo queue .
@ override public void read external ( object input in ) throws io , class not found exception { super . read external ( in ) ; this . facet name = in . read utf ( ) ; }	read the facet node in .
private boolean string to boolean ( string condition ) { boolean result = bool ; if ( condition != null && condition . length ( ) > num ) { string s = condition . substring ( num , num ) ; if ( s . equals ignore case ( str ) || s . equals ( str ) || s . equals ignore case ( str ) ) result = bool ; } return result ; }	converts string to boolean.
public static void write uin ( long number , output stream out ) throws io { if ( number < num ) { throw new illegal argument exception ( str ) ; } byte [ ] to write = new byte [ num ] ; for ( int i = num ; i <= num ; i += num ) { to write [ i / num ] = ( byte ) ( ( number > > i ) & num ) ; } out . write ( to write ) ; }	writes the given value as uint32 into the stream .
public remote meta data impl ( schema schema ) throws remote exception { this . schema = schema ; fields . add all ( schema . fields ( ) ) ; }	creates a metadata object that wraps the specified schema.
public void add switch with optional extra part ( string option , string option extra part synopsis , string description ) { option list . add ( option ) ; option extra part synopsis map . put ( option , option extra part synopsis ) ; option description map . put ( option , description ) ; int length = option . length ( ) + option extra part synopsis . length ( ) + num ; if ( length > max width ) { max width = length ; } }	add a command line switch that allows optional extra information to be specified as part of it .
public static object detect linux default file browser ( map < string , object > file browsers ) { array list < string > command = new array list < string > ( ) ; command . add ( str ) ; command . add ( str ) ; command . add ( str ) ; command . add ( str ) ; if ( file browsers == null ) { file browsers = new hash map < string , object > ( ) ; file browsers . put ( str , str ) ; } return utils . is expected command output ( command , file browsers ) ; }	detects programs from $ desktop_session.
public void updated ( ) { current color = html colors . decode ( get setting value ( ) ) ; secondary color = html colors . decode ( base color ) ; color foreground color ; color background color ; if ( type == foreground ) { foreground color = current color ; background color = secondary color ; } else { foreground color = secondary color ; background color = current color ; } preview . set foreground ( foreground color ) ; preview . set background ( background color ) ; }	updates the preview and current color objects based on the saved colors .
public collection < ? extends immutable class type > remove instrumentation points ( final collection < ? extends immutable type > types ) { return remove instrumentation points ( types , collections . < i > singleton ( remove all instrumentation applier . get instance ( ) ) ) ; }	removes all instrumentation point from the given types .
private record create record ( record properties record properties ) throws record exception { string debug directory ; if ( is recording ( ) ) { debug directory = previous debug directory ; } else { debug directory = system properties manager . get ( debug constants . config debug directory ) ; } string record directory = debug directory + file . separator + record constants . record folder name + file . separator + record properties . get issue id ( ) + file . separator + record properties . get reference id ( ) ; record record = new record ( record properties , record directory ) ; try { create folder ( record . get folder path ( ) ) ; print writer print writer info = get print writer for file ( record , record constants . info file name ) ; json value info = record report . info report ( record ) ; try { json json = new json ( info . to string ( ) ) ; print writer info . println ( json . to string ( num ) ) ; } catch ( json e ) { debug . warning ( str , info , e ) ; print writer info . println ( info ) ; } print writer info . flush ( ) ; return record ; } catch ( io e ) { debug . error ( str , record properties , e ) ; throw new record exception ( str + record properties . get issue id ( ) + str , e ) ; } }	create a new recorddebug.
public static lagged edge serializable instance ( ) { return new lagged edge ( str , lagged factor . serializable instance ( ) ) ; }	generates a simple exemplar of this class to test serialization .
private static int length of mime names ( string val ) { int len = val . index of ( str ) ; if ( len < num ) len = val . length ( ) ; return len ; }	get the length of the mime names within the property value.
public static boolean is sha1 string ( final string string ) { preconditions . check not null ( string , str ) ; return ( string . length ( ) == num ) && is hex string ( string ) ; }	tests whether a given string is a valid sha1 string .
public boolean is watched ( ) { return watched ; }	checks if is watched .
public void add date change listener ( date change listener listener ) { date change listeners . add ( listener ) ; }	adddatechangelistener , this adds a date change listener to this date picker.
public static string strip file protocol ( string uri string ) { if ( uri string . starts with ( str ) ) { uri string = uri string . substring ( num ) ; } return uri string ; }	removes the " file : / / " prefix from the given uri string , if applicable.
public void replace template ( elem template v , int i ) throws transformer exception { if ( null == m templates ) throw new array index out of bounds exception ( ) ; replace child ( v , ( elem template element ) m templates . element at ( i ) ) ; m templates . set element at ( v , i ) ; v . set stylesheet ( this ) ; }	replace an " xsl : template " property.
public rotated problem ( problem problem , real matrix rotation ) { super ( ) ; this . problem = problem ; this . rotation = rotation ; solution solution = problem . new solution ( ) ; center = new double [ get number of variables ( ) ] ; lower bounds = new double [ get number of variables ( ) ] ; upper bounds = new double [ get number of variables ( ) ] ; for ( int i = num ; i < get number of variables ( ) ; i ++ ) { real variable variable = ( real variable ) solution . get variable ( i ) ; center [ i ] = ( variable . get lower bound ( ) + variable . get upper bound ( ) ) / num ; lower bounds [ i ] = math . sqrt ( num ) * ( variable . get lower bound ( ) - center [ i ] ) ; upper bounds [ i ] = math . sqrt ( num ) * ( variable . get upper bound ( ) - center [ i ] ) ; } }	decorates the specified problem , creating a rotated instance using the specified rotation matrix .
public void characters ( char ch [ ] , int start , int length ) throws sax { m cur value . append ( ch , start , length ) ; }	receive notification of character data inside an element .
public boolean regenerate ( projection proj ) { boolean ret = super . regenerate ( proj ) ; if ( proj != null && ! ret ) { ret = generate ( proj ) ; } return ret ; }	overrides omgraphicadapter version to handle omrasterobject getneedtoreposition .
@ override public byte [ ] unwrap ( final byte [ ] incoming , final int offset , final int len ) throws ldap exception { final byte [ ] copy = new byte [ len ] ; system . arraycopy ( incoming , offset , copy , num , len ) ; return copy ; }	default implementation just returns the copy of the bytes .
private int sequential forward selection ( string data file , string [ ] features , int ind var col number , int x [ ] , int y [ ] , double j [ ] , int row ini , int row end ) { double sig [ ] = new double [ y . length ] ; int sig index [ ] = new int [ y . length ] ; double cor xplusy [ ] = new double [ y . length ] ; double cor x ; if ( x . length > num ) { regression reg = new regression ( ) ; reg . multiple linear regression ( data file , ind var col number , x , features , intercept term , row ini , row end ) ; cor x = reg . get correlation ( ) ; } else cor x = num ; for ( int i = num ; i < y . length ; i ++ ) { cor xplusy [ i ] = correlation of new feature ( data file , features , ind var col number , x , y [ i ] , row ini , row end ) ; sig [ i ] = cor xplusy [ i ] - cor x ; sig index [ i ] = y [ i ] ; } int min sig = math utils . get min index ( sig ) ; j [ num ] = cor xplusy [ min sig ] ; j [ num ] = cor x ; int max sig = math utils . get max index ( sig ) ; j [ num ] = cor xplusy [ max sig ] ; return sig index [ max sig ] ; }	find the f feature in y that maximise j ( x + y ).
private static byte [ ] codes to bytes ( string codes , boolean required ) { if ( codes . length ( ) == num ) { if ( required ) { throw new illegal state exception ( str ) ; } return null ; } if ( ( codes . length ( ) % num ) != num ) { codes = str + codes ; } byte [ ] bytes = new byte [ codes . length ( ) / num ] ; for ( int i = num ; i < bytes . length ; ++ i ) { int char idx = i * num ; bytes [ i ] = ( byte ) ( integer . parse int ( codes . substring ( char idx , char idx + num ) , num ) ) ; } return bytes ; }	converts a string of hex encoded bytes to a byte [ ] , optionally throwing an exception if no codes are given .
public drag entry drag selected entry ( ) { try { key store history history = get active key store history ( ) ; if ( history == null ) { return null ; } key store state current state = history . get current state ( ) ; key store key store = current state . get key store ( ) ; string alias = get selected entry alias ( ) ; if ( alias == null ) { return null ; } if ( key store util . is key entry ( alias , key store ) ) { j . show message dialog ( frame , res . get string ( str ) , kse . get application name ( ) , j . warning message ) ; return null ; } if ( key store util . is key pair entry ( alias , key store ) ) { password password = current state . get entry password ( alias ) ; key store type type = key store type . resolve jce ( key store . get type ( ) ) ; if ( password == null && type . has entry passwords ( ) ) { j . show message dialog ( frame , res . get string ( str ) , kse . get application name ( ) , j . warning message ) ; return null ; } private key private key = ( private key ) key store . get key ( alias , password . to char array ( ) ) ; certificate [ ] certificate chain = key store . get certificate chain ( alias ) ; return new drag key pair entry ( alias , private key , password , certificate chain ) ; } else { certificate trusted certificate = key store . get certificate ( alias ) ; return new drag trusted certificate entry ( alias , trusted certificate ) ; } } catch ( exception ex ) { d . display error ( frame , ex ) ; return null ; } }	get a the selected entry as a drag entry for dnd .
public void insert ( t object , int index ) { synchronized ( m lock ) { if ( m original values != null ) { m original values . add ( index , object ) ; } else { m objects . add ( index , object ) ; } } if ( m notify on change ) notify data set changed ( ) ; }	inserts the specified object at the specified index in the array .
public double reduce ( string numeric column name , numeric reduce function function ) { column column = column ( numeric column name ) ; return function . reduce ( column . to double array ( ) ) ; }	returns the result of applying the given function to the specified column.
public void test set bit negative outside1 ( ) { byte a bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = - num ; int number = num ; byte r bytes [ ] = { - num , num , - num , - num , num , num , - num , - num , - num , - num , num , - num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . set bit ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , result . signum ( ) ) ; }	setbit ( int n ) outside a negative number.
static public string format u ( byte b ) { string ch = new string ( new byte [ ] { b } ) ; ch = ch . replace all ( str , str ) ; return format u ( b ) + str + ch ; }	utility method to print a byte in hexa an ascii.
public static final array list < move > remove illegal ( position pos , array list < move > move list ) { array list < move > ret = new array list < move > ( ) ; undo info ui = new undo info ( ) ; int ml size = move list . size ( ) ; for ( int mi = num ; mi < ml size ; mi ++ ) { move m = move list . get ( mi ) ; pos . make move ( m , ui ) ; pos . set white move ( ! pos . white move ) ; if ( ! in check ( pos ) ) ret . add ( m ) ; pos . set white move ( ! pos . white move ) ; pos . un make move ( m , ui ) ; } return ret ; }	remove all illegal moves from movelist.
public static int apply mask penalty rule4 ( byte matrix matrix ) { int num dark cells = num ; byte [ ] [ ] array = matrix . get array ( ) ; int width = matrix . get width ( ) ; int height = matrix . get height ( ) ; for ( int y = num ; y < height ; ++ y ) { for ( int x = num ; x < width ; ++ x ) { if ( array [ y ] [ x ] == num ) { num dark cells += num ; } } } int num total cells = matrix . get height ( ) * matrix . get width ( ) ; double dark ratio = ( double ) num dark cells / num total cells ; return math . abs ( ( int ) ( dark ratio * num - num ) ) / num * num ; }	apply mask penalty rule 4 and return the penalty.
private void check state ( ) { if ( diagram retrieved ) { throw new illegal state exception ( str ) ; } }	throws an exception if the diagram was already returned.
static hashtable convert to hash ( map m ) { hashtable ret hash = new hashtable ( ) ; set s = m . key set ( ) ; iterator iter = s . iterator ( ) ; while ( iter . has next ( ) ) { string key = ( string ) iter . next ( ) ; set val = ( set ) m . get ( key ) ; ret hash . put ( key , set to string ( val ) ) ; } return ret hash ; }	this will convert updated naming attributes map into naming hashtable.
public void action performed ( action event evt ) { }	this method is called when the soft button / menu item is clicked.
public boolean equal at start ( pla point int p point ) { if ( p point == null ) return bool ; pla point first = corner first ( ) ; return first . equals ( p point ) ; }	returns true of the given point is equal at start of polyline.
public void for each block depth first ( boolean reverse , ssa basic block . visitor v ) { bit set visited = new bit set ( blocks . size ( ) ) ; stack < ssa basic block > stack = new stack < ssa basic block > ( ) ; ssa basic block root block = reverse ? get exit block ( ) : get entry block ( ) ; if ( root block == null ) { return ; } stack . add ( null ) ; stack . add ( root block ) ; while ( stack . size ( ) > num ) { ssa basic block cur = stack . pop ( ) ; ssa basic block parent = stack . pop ( ) ; if ( ! visited . get ( cur . get index ( ) ) ) { bit set children = reverse ? cur . get predecessors ( ) : cur . get successors ( ) ; for ( int i = children . next set bit ( num ) ; i >= num ; i = children . next set bit ( i + num ) ) { stack . add ( cur ) ; stack . add ( blocks . get ( i ) ) ; } visited . set ( cur . get index ( ) ) ; v . visit block ( cur , parent ) ; } } }	walks the basic block tree in depth - first order , calling the visitor method once for every block.
protected void fill path ( ) { m ps . println ( m fill op str ) ; }	fill the current path using the current fill mode and color .
public boolean is last window ( accessibility window info base window , int window type ) { int index = get window index ( base window ) ; if ( index == wrong index ) { return bool ; } int count = m windows . size ( ) ; for ( int i = index + num ; i < count ; i ++ ) { accessibility window info window = m windows . get ( i ) ; if ( window != null && window . get type ( ) == window type ) { return bool ; } } return bool ; }	returns true if there is no window with windowtype after basewindow.
public void pass pg session map ex ( view bean other ) { map attributes = get page session attributes ( ) ; for ( iterator i = retain page sessions btw tabs . iterator ( ) ; i . has next ( ) ; ) { string key = ( string ) i . next ( ) ; other . set page session attribute ( key , ( serializable ) attributes . get ( key ) ) ; } other . set page session attribute ( get tracking tab id ( ) , ( serializable ) attributes . get ( get tracking tab id ( ) ) ) ; }	pass session attribute map to other view bean .
public long time ( ) { return heartbeat time ; }	returns the current commit time .
public boolean hit clip ( int x , int y , int width , int height ) { return g . hit clip ( x , y , width , height ) ; }	returns true if the specified rectangular area intersects the bounding rectangle of the current clipping area.
public static close watcher poll unclosed ( ) { reference queue < object > q = queue ; if ( q == null ) { return null ; } while ( bool ) { close watcher cw = ( close watcher ) q . poll ( ) ; if ( cw == null ) { return null ; } if ( refs != null ) { refs . remove ( cw ) ; } if ( cw . closeable != null ) { return cw ; } } }	check for an collected object .
private static boolean append odexes to class path ( context cxt , file dex dir , string [ ] names ) { string str dex dir = dex dir . get absolute path ( ) ; array list < string > jar paths = new array list < string > ( ) ; for ( int i = num ; i < names . length ; i ++ ) { string jar path = str dex dir + str + names [ i ] ; file f = new file ( jar path ) ; if ( f . is file ( ) ) { jar paths . add ( jar path ) ; } } string [ ] jars of dex = new string [ jar paths . size ( ) ] ; jar paths . to array ( jars of dex ) ; path class loader pcl = ( path class loader ) cxt . get class loader ( ) ; try { if ( build . version . sdk int < sdk int ics ) { framework hack . append dex list impl under ics ( jars of dex , pcl , dex dir ) ; } else { boolean kitkat plus = build . version . sdk int >= sdk int kitkat ; boolean marshmallow plus = build . version . sdk int >= sdk int marshmallow ; array list < file > jar files = dex dex . strings2 files ( jars of dex ) ; framework hack . append dex list impl ics ( jar files , pcl , dex dir , kitkat plus , marshmallow plus ) ; } for ( string jar name : names ) { the appended . add ( jar name ) ; } if ( debug ) { log . d ( tag , str + pcl ) ; log . d ( tag , str + the appended ) ; } } catch ( exception ex ) { throw new runtime exception ( ex ) ; } return bool ; }	append dexoptimized dex files to the classpath .
@ override public final int read int ( ) throws io { dis . read fully ( work , num , num ) ; return ( work [ num ] ) << num | ( work [ num ] & num ) << num | ( work [ num ] & num ) << num | ( work [ num ] & num ) ; }	read an int , 32 - bits.
private void assert serialize and des date time ( string date time string ) throws rya type resolver exception { assert serialize and des date time ( date time string , date time string ) ; }	do the test on the datetime.
public boolean is hard mode ( ) { return is hard mode ; }	gets whether it is hard mode.
protected string do it ( ) throws exception { setup ( ) ; for ( m warehouse : warehouses ) for ( m cost type : cost types ) for ( m cost element : cost elements ) for ( int product id : products ) generate inventory value ( product id , cost type . get m id ( ) , cost element . get m id ( ) , warehouse . get m id ( ) ) ; pstmt . execute batch ( ) ; commit ex ( ) ; db . close ( pstmt ) ; db . execute update ( str + db . to date ( p ) + str , get ad p id ( ) , get ( ) ) ; return str + count ; }	execute the valuation effective date.
public void run ( ) { setup ( ) ; log . info ( str ) ; for ( task storage manager task storage manager : task storage managers ) { task storage manager . init ( ) ; task storage manager . stop stores ( ) ; log . debug ( str + task storage manager . to string ( ) ) ; } log . info ( str + store base dir . to string ( ) ) ; }	run the setup phase and restore all the task storages.
public void read ( int i ) { variable value v = row vector . element at ( i ) ; v . read all ( ) ; }	command reading of a particular variable.
protected list < expression > transform expressions ( list < ? extends expression > expressions , expression transformer transformer ) { list < expression > list = new array list < expression > ( expressions . size ( ) ) ; for ( expression expr : expressions ) { list . add ( transformer . transform ( expr ) ) ; } return list ; }	transforms the list of expressions.
public string prefix forward ( int length ) { final string prefix = prefix ( length ) ; this . pointer += length ; this . index += length ; this . column += length ; return prefix ; }	prefix ( length ) immediately followed by forward ( length ).
private boolean can add task ( ) { return t cur == null ; }	returns whether the task queue is not full .
public void flush ( ) throws io { if ( print writer != null ) { print writer . flush ( ) ; } if ( gzip output stream != null ) { gzip output stream . flush ( ) ; } }	flushes all the streams for this response .
public int start ( ) { started . compare and set ( bool , bool ) ; server . start ( ) ; return server . get server port ( ) ; }	start the server and return the port that the server bound to .
public static double angle ( tuple3d a , tuple3d b ) { double dx = b . x - a . x ; double dy = b . y - a . y ; double angle = num ; if ( dx == num ) { if ( dy == num ) angle = num ; else if ( dy > num ) angle = math . pi / num ; else angle = ( math . pi * num ) / num ; } else if ( dy == num ) { if ( dx > num ) angle = num ; else angle = math . pi ; } else { if ( dx < num ) angle = math . atan ( dy / dx ) + math . pi ; else if ( dy < num ) angle = math . atan ( dy / dx ) + ( num * math . pi ) ; else angle = math . atan ( dy / dx ) ; } return angle ; }	compute the angle between the first and second point .
public void add string to table ( byte [ ] old string , byte new string ) { int length = old string . length ; byte [ ] str = new byte [ length + num ] ; system . arraycopy ( old string , num , str , num , length ) ; str [ length ] = new string ; string table [ table index ++ ] = str ; if ( table index == num ) { bits to get = num ; } else if ( table index == num ) { bits to get = num ; } else if ( table index == num ) { bits to get = num ; } }	add a new string to the string table .
public static boolean identical ( uri first , uri second ) { if ( ( first != null ) && ( second != null ) ) { return first . equals ( second ) ; } return bool ; }	determines if the ids are equal ( and non - null ) .
default < st > xor < st , t > to xor ( final st secondary ) { final optional < t > o = to optional ( ) ; return o . is present ( ) ? xor . primary ( o . get ( ) ) : xor . secondary ( secondary ) ; }	convert to an xor where the secondary value will be used if no primary value is present.
public void process invite ( request event request event , server transaction server transaction ) { sip provider sip provider = ( sip provider ) request event . get source ( ) ; request request = request event . get request ( ) ; logger . info ( str + request ) ; timer . schedule ( new delayed invite responses task ( request event , sip provider ) , num ) ; }	process the invite request .
protected instances data from xml ( instances header ) throws exception { instances result ; element node ; vector < element > list ; list = get child tags ( m . get document element ( ) , tag body ) ; node = list . get ( num ) ; list = get child tags ( node , tag instances ) ; node = list . get ( num ) ; result = create instances ( header , node ) ; return result ; }	generates the complete dataset from the xml document.
private static string prepend if missing ( final string str , final char sequence prefix , final boolean ignore case , final char sequence ... prefixes ) { if ( str == null || is empty ( prefix ) || starts with ( str , prefix , ignore case ) ) { return str ; } if ( prefixes != null && prefixes . length > num ) { for ( final char sequence p : prefixes ) { if ( starts with ( str , p , ignore case ) ) { return str ; } } } return prefix . to string ( ) + str ; }	prepends the prefix to the start of the string if the string does not already start with any of the prefixes .
protected cache distribution advisor create distribution advisor ( internal region arguments internal region args ) { return cache distribution advisor . create cache distribution advisor ( this ) ; }	intended for used during construction of a distributedregion.
public void add mouse listener ( global mouse listener listener ) { listeners . add ( listener ) ; }	adds a global mouse listener.
private d finite or null point ( final double x ) { return double . is infinite ( x ) ? null : new d ( x ) ; }	build a finite point .
public void load pdf ( final file input ) { if ( input == null ) { return ; } scale = num ; pd = input . get absolute path ( ) ; file loc . set text ( pd ) ; open file ( input , null , bool ) ; }	take a file handle to pdf file on local filesystem and displays in pdf viewer.
public char buffer append ( object obj ) { return append ( string . value of ( obj ) ) ; }	appends the string representation of the object to the buffer .
public void test intby int1 ( ) { byte a bytes [ ] = { num , num , num , num } ; byte b bytes [ ] = { num , num , num , num } ; int a sign = num ; int b sign = - num ; byte r bytes [ ] = { - num , - num , - num , num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . multiply ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , result . signum ( ) ) ; }	multiply two numbers of 4 bytes length .
private static void check file validation ( file file ) { if ( file == null ) throw new null pointer exception ( str ) ; if ( ! file . exists ( ) ) { throw new illegal argument exception ( str + file . get path ( ) + str ) ; } file . can read ( ) ; }	checks if the file is a valid file and readable .
public < t > set < t > to set ( converter < t > converter ) { try { if ( is empty ( cursor ) ) { return collections . empty set ( ) ; } return populate ( converter , new hash set < t > ( cursor . get count ( ) ) ) ; } finally { close ( ) ; } }	transforms all rows from the cursor and put them in a read - only set .
public static void stash disable assertion arg ( string arg ) { if ( arg == null || arg . equals ( str ) ) { assertions enabled = bool ; } else { disabled assertion strings = arg . split ( str ) ; } }	remember the given disable assertions string.
public iterator < stream > member iterator ( ) { return member set . iterator ( ) ; }	get iterator over the members of the class .
private void clean mapping ( ) { array list < integer > to remove = new array list < integer > ( ) ; int size = m list mapping . size ( ) ; for ( int i = num ; i < size ; ++ i ) { if ( m list mapping . key at ( i ) == m list mapping . value at ( i ) ) { to remove . add ( m list mapping . key at ( i ) ) ; } } size = to remove . size ( ) ; for ( int i = num ; i < size ; ++ i ) { m list mapping . delete ( to remove . get ( i ) ) ; } }	remove unnecessary mappings from sparse array .
public static string time until ( final int seconds , final boolean force seconds ) { final string builder sbuf = new string builder ( ) ; time until ( sbuf , seconds , force seconds ) ; return sbuf . to string ( ) ; }	create a text representing a saying of time until .
public void remove ( t item ) { if ( set . remove ( item ) ) { fire contents changed ( this , num , get size ( ) - num ) ; } }	removes the specified item from this list model .
public static void append ( file file , reader reader , string charset ) throws io { append ( file , reader , charset , bool ) ; }	append the text supplied by the reader at the end of the file without writing a bom , using a specified encoding .
void parse ignored section ( ) throws io { int depth = num ; in . replace ++ ; while ( bool ) { switch ( ch ) { case str : if ( ( ch = in . read ( ) ) == str ) { if ( ( ch = in . read ( ) ) == str ) { ch = in . read ( ) ; depth ++ ; } } break ; case str : if ( ( ch = in . read ( ) ) == str ) { if ( ( ch = in . read ( ) ) == str ) { ch = in . read ( ) ; if ( -- depth == num ) { in . replace -- ; return ; } } } break ; case - num : error ( str ) ; in . replace -- ; return ; default : ch = in . read ( ) ; break ; } } }	parse an ignored section until ] ] > is encountered .
private synchronized int read record length ( ) throws io { if ( in . get pos ( ) >= end ) { return - num ; } int length = in . read int ( ) ; if ( sync != null && length == sync escape ) { in . read fully ( sync check ) ; if ( ! arrays . equals ( sync , sync check ) ) { throw new io ( str ) ; } sync seen = bool ; if ( in . get pos ( ) >= end ) { return - num ; } length = in . read int ( ) ; } else { sync seen = bool ; } return length ; }	read and return the next record length , potentially skipping over a sync block .
public void add slide ( @ non null fragment fragment ) { fragments . add ( fragment ) ; if ( is wizard mode ) { set off screen page limit ( fragments . size ( ) ) ; } m pager adapter . notify data set changed ( ) ; }	adds a new slide.
public default interval category dataset ( comparable [ ] series keys , comparable [ ] category keys , number [ ] [ ] starts , number [ ] [ ] ends ) { this . start data = starts ; this . end data = ends ; if ( starts != null && ends != null ) { string base name = str ; resource bundle resources = resource bundle wrapper . get bundle ( base name ) ; int series count = starts . length ; if ( series count != ends . length ) { string err msg = str + str + str + str ; throw new illegal argument exception ( err msg ) ; } if ( series count > num ) { if ( series keys != null ) { if ( series keys . length != series count ) { throw new illegal argument exception ( str + str ) ; } this . series keys = series keys ; } else { string prefix = resources . get string ( str ) + str ; this . series keys = generate keys ( series count , prefix ) ; } int category count = starts [ num ] . length ; if ( category count != ends [ num ] . length ) { string err msg = str + str + str + str ; throw new illegal argument exception ( err msg ) ; } if ( category keys != null ) { if ( category keys . length != category count ) { throw new illegal argument exception ( str + str ) ; } this . category keys = category keys ; } else { string prefix = resources . get string ( str ) + str ; this . category keys = generate keys ( category count , prefix ) ; } } else { this . series keys = new comparable [ num ] ; this . category keys = new comparable [ num ] ; } } }	constructs a defaultintervalcategorydataset , populates it with data from the arrays , and uses the supplied names for the series and the supplied objects for the categories .
public void translate ( double dx , double dy ) { if ( ! is relative ( ) ) { x += dx ; y += dy ; } if ( source point != null ) { source point . set x ( source point . get x ( ) + dx ) ; source point . set y ( source point . get y ( ) + dy ) ; } if ( target point != null ) { target point . set x ( target point . get x ( ) + dx ) ; target point . set y ( target point . get y ( ) + dy ) ; } if ( translate control points && points != null ) { int count = points . size ( ) ; for ( int i = num ; i < count ; i ++ ) { mx point pt = ( mx point ) points . get ( i ) ; pt . set x ( pt . get x ( ) + dx ) ; pt . set y ( pt . get y ( ) + dy ) ; } } }	translates the geometry by the specified amount.
public abstract void fill ( byte buffer buffer , long id ) ;	this method adds to the byte - buffer , the token indicating the type of the passed ' id ' ( threadid or sequenceid ) and the optimal byte array representing the id depending on the value of the ' id ' .
private string anonymize password ( string password ) { if ( password == null ) { return str ; } string builder sb = new string builder ( ) ; for ( int i = num ; i < password . length ( ) ; i ++ ) { sb . append ( str ) ; } return sb . to string ( ) ; }	make a password into asterisks of the right length , for logging .
public final void write ( final byte [ ] data ) { byte buffer . put ( data ) ; }	write the data in the buffer .
public void close ( ) throws io { input stream . close ( ) ; }	closes the underlying parser .
public address malloc ( int size , int howmany ) { int result = next reservable address ; next reservable address += size * howmany ; if ( next reservable address > ( memsize + mem address start ) ) { address out of range = bool ; return null ; } return new address ( op . mem , size , result ) ; }	allocates / reservates memory : a specified block size in bytes , multiplied by a given number of blocks.
public static string mask left ( string s , int len , char mask ch ) { if ( len <= num ) { return s ; } len = math . min ( len , s . length ( ) ) ; string builder sb = new string builder ( ) ; for ( int i = num ; i < len ; i ++ ) { sb . append ( mask ch ) ; } sb . append ( s . substring ( len ) ) ; return sb . to string ( ) ; }	returns a string consisting of " s " , with each of the first " len " characters replaced by " mask_ch " character .
public static double pdf ( double x , double mu , double sigma , double skew ) { x = ( x - mu ) / sigma ; if ( math . abs ( skew ) > num ) { x = - math . log ( num - skew * x ) / skew ; } return math util . sqrthalf * math . exp ( - num * x * x ) / sigma / ( num - skew * x ) ; }	probability density function of the skewed normal distribution .
public composer to ( long anim duration , float x , float y , int alpha , float scale x , float scale y , float rotation , ease ease ) { m tween parameter list . add ( new tween parameter ( x , y , alpha , scale x , scale y , rotation , anim duration , ease ) ) ; return this ; }	queues a tween from the current values to the target properties.
@ override public string to string ( ) { string builder buffer = new string builder ( num ) ; try { print ( buffer ) ; } catch ( io e ) { throw new runtime exception ( str , e ) ; } return buffer . to string ( ) ; }	returns the string representation ( in ion format ) of this timestamp in its local time .
@ override public mem chunk holder < big data mem allocator > create chunk ( long size , boolean autoreclaim ) { mem chunk holder < big data mem allocator > ret = null ; long addr = m vmasvc . allocate ( m nid , size , bool ) ; if ( num == addr && m activegc ) { force gc ( ) ; addr = m vmasvc . allocate ( m nid , size , bool ) ; } if ( num != addr ) { ret = new mem chunk holder < big data mem allocator > ( this , addr , size ) ; ret . set collector ( m chunkcollector ) ; if ( autoreclaim ) { m chunkcollector . register ( ret ) ; } } return ret ; }	create a memory chunk that is managed by its holder .
public single < t > grant new access token ( o < t > grant ) { return grant new access token ( grant , calendar . get instance ( ) ) ; }	grants a new access token using the given oauth2 grant .
public static number floor ( number a ) { if ( is floating point ( a ) ) { return math . floor ( a . double value ( ) ) ; } else { return a . long value ( ) ; } }	returns the largest integer value less than or equal to the given number .
private void read defs element ( ixml elem ) throws io { for ( ixml child : elem . get children ( ) ) { figure child figure = read element ( child ) ; } }	reads an svg " defs " element .
@ nullable private static activity wrapper find launcher activity for device ( @ not null list < activity wrapper > launchable activities , @ not null i device ) { if ( device . supports feature ( i . hardware feature . tv ) ) { return find leanback launcher ( launchable activities ) ; } return null ; }	returns a launchable activity specific to the given device .
public boolean is query running ( final bound entity song ) { synchronized ( m running queries ) { return m running queries . contains ( song ) ; } }	returns whether or not a query is currently running for the provided song.
private response < bitmap > do parse ( network response response ) { byte [ ] data = response . data ; bitmap factory . options decode options = new bitmap factory . options ( ) ; bitmap bitmap = null ; if ( m max width == num && m max height == num ) { decode options . in preferred config = m decode config ; bitmap = bitmap factory . decode byte array ( data , num , data . length , decode options ) ; } else { decode options . in just decode bounds = bool ; bitmap factory . decode byte array ( data , num , data . length , decode options ) ; int actual width = decode options . out width ; int actual height = decode options . out height ; int desired width = get resized dimension ( m max width , m max height , actual width , actual height ) ; int desired height = get resized dimension ( m max height , m max width , actual height , actual width ) ; decode options . in just decode bounds = bool ; decode options . in sample size = find best sample size ( actual width , actual height , desired width , desired height ) ; bitmap temp bitmap = bitmap factory . decode byte array ( data , num , data . length , decode options ) ; if ( temp bitmap != null && ( temp bitmap . get width ( ) > desired width || temp bitmap . get height ( ) > desired height ) ) { bitmap = bitmap . create scaled bitmap ( temp bitmap , desired width , desired height , bool ) ; temp bitmap . recycle ( ) ; } else { bitmap = temp bitmap ; } } if ( bitmap == null ) { return response . error ( new parse error ( response ) ) ; } else { return response . success ( bitmap , http header parser . parse cache headers ( response ) ) ; } }	the real guts of parsenetworkresponse.
private map < string , extension file filter > add extensions ( j chooser ) { map < string , extension file filter > filters = new hash map < string , extension file filter > ( ) ; for ( map . entry < string , string > entry : exts . entry set ( ) ) { extension file filter filter = new extension file filter ( entry . get key ( ) , entry . get value ( ) ) ; filters . put ( entry . get key ( ) , filter ) ; chooser . add choosable file filter ( filter ) ; } return filters ; }	adds the filters for the extensions to the provided chooser .
public static string with node info ( accessibility node info node info ) { if ( node info == null ) { return null ; } return string . format ( str , node info . get text ( ) , node info . get content description ( ) ) ; }	return the identify string of a node.
static int all parameters and arguments match with default params ( parameter [ ] params , class node [ ] args ) { int dist = num ; class node ptype = null ; for ( int i = num , j = num ; i < params . length ; i ++ ) { parameter param = params [ i ] ; class node param type = param . get type ( ) ; class node arg = j >= args . length ? null : args [ j ] ; if ( arg == null || ! is assignable to ( arg , param type ) ) { if ( ! param . has initial expression ( ) && ( ptype == null || ! ptype . equals ( param type ) ) ) { return - num ; } ptype = null ; } else { j ++ ; if ( ! param type . equals ( arg ) ) dist += get distance ( arg , param type ) ; if ( param . has initial expression ( ) ) { ptype = arg ; } else { ptype = null ; } } } return dist ; }	checks that arguments and parameter types match , expecting that the number of parameters is strictly greater than the number of arguments , allowing possible inclusion of default parameters .
private void expect ( char expected symbol ) throws parse exception { if ( ! accept ( expected symbol ) ) throw new parse exception ( str + expected symbol + str + ( char ) data [ index ] + str , index ) ; }	expects the input to have the given symbol at the current parsing position .
public abstract void init parameters ( int [ ] a circuit data , i a redstone circuit block ) ;	initializes the parameters of this circuit , all parameters have been set to 0 right before calling this.
public contentlet execute safe first ( ) { list < contentlet > result = execute safe ( ) ; if ( result . size ( ) > num ) { return result . get ( num ) ; } return null ; }	executes the query and returns the first result.
public static boolean is file exist ( string file path , file type file type , boolean perform file check ) throws io { file path = file path . replace ( str , str ) ; switch ( file type ) { case hdfs : case viewfs : path path = new path ( file path ) ; file system fs = path . get file system ( configuration ) ; if ( perform file check ) { return fs . exists ( path ) && fs . is file ( path ) ; } else { return fs . exists ( path ) ; } case local : default : file default file = new file ( file path ) ; if ( perform file check ) { return default file . exists ( ) && default file . is file ( ) ; } else { return default file . exists ( ) ; } } }	this method checks the given path exists or not and also is it file or not if the performfilecheck is true.
private double factor pointwise product ( list < double factor > factors ) { if ( factors . is empty ( ) ) { double factor factor = new double factor ( ) ; factor . add entry ( new assignment ( ) , num , num ) ; return factor ; } else if ( factors . size ( ) == num ) { return factors . get ( num ) ; } double factor factor = factors . get ( num ) ; factors . remove ( num ) ; for ( double factor f : factors ) { double factor temp factor = new double factor ( ) ; set < string > shared vars = new hash set < string > ( f . get variables ( ) ) ; shared vars . retain all ( factor . get variables ( ) ) ; for ( assignment a : f . get values ( ) ) { double [ ] entry = f . get entry ( a ) ; double prob = entry [ num ] ; double util = entry [ num ] ; for ( assignment b : factor . get values ( ) ) { if ( b . consistent with ( a , shared vars ) ) { double [ ] entry2 = factor . get entry ( b ) ; double prob2 = entry2 [ num ] ; double util2 = entry2 [ num ] ; double product = prob * prob2 ; double sum = util + util2 ; temp factor . add entry ( new assignment ( a , b ) , product , sum ) ; } } } factor = temp factor ; } return factor ; }	computes the pointwise matrix product of the list of factors.
public class path ( ) { string syscp = system . get property ( str ) ; string envcp = system . get property ( str ) ; if ( envcp == null ) envcp = str ; string cp = syscp + file . path separator + envcp ; init ( cp ) ; }	build a default class path from the path strings specified by the properties sun.
protected static boolean uninstall add on extension ( add on add on , extension extension , add on uninstallation progress callback callback ) { boolean uninstalled without errors = bool ; if ( extension . is enabled ( ) ) { string ext ui name = extension . get ui ( ) ; if ( extension . can unload ( ) ) { logger . debug ( str + extension . get name ( ) ) ; try { extension . unload ( ) ; extension factory . unload add on extension ( extension ) ; } catch ( exception e ) { logger . error ( str + extension . get name ( ) + str + add on . get id ( ) + str , e ) ; uninstalled without errors = bool ; } } else { logger . debug ( str + extension . get name ( ) ) ; uninstalled without errors = bool ; } callback . extension removed ( ext ui name ) ; } add on . remove loaded extension ( extension ) ; return uninstalled without errors ; }	uninstalls the given extension .
private static string pick random stats fields ( string [ ] field names ) { string field name ; do { field name = field names [ test util . next int ( random ( ) , num , field names . length - num ) ] ; } while ( field name . ends with ( str ) || field name . ends with ( str ) ) ; return field name ; }	picks a random field to use for stats.
@ override public synchronized void do delete child ( base solr resource endpoint , string child id ) { string key = get ignore case ( ) ? child id . to lower case ( locale . root ) : child id ; if ( ! managed words . contains ( key ) ) throw new solr exception ( error code . not found , string . format ( locale . root , str , child id , get resource id ( ) ) ) ; managed words . remove ( key ) ; store managed data ( managed words ) ; log . info ( str , key ) ; }	deletes words managed by this resource .
public d ( j parent ) { super ( parent , dialog . modality type . document modal ) ; set title ( res . get string ( str ) ) ; init components ( ) ; }	creates a new dexportprivatekeytype dialog .
public static i [ ] copy of ( i [ ] original , int new length ) { i [ ] copy = new i [ new length ] ; system . arraycopy ( original , num , copy , num , math . min ( original . length , new length ) ) ; return copy ; }	this method comes with jdk 1.
public void write footer ( ) { ps . println ( str ) ; ps . println ( str ) ; ps . println ( str ) ; }	writes the html footer .
protected void save object ( object object ) { if ( m == null ) { create file chooser ( ) ; } int return val = m . show save dialog ( this ) ; if ( return val == j . approve option ) { file s file = m . get selected file ( ) ; try { object output stream oo = new object output stream ( new buffered output stream ( new file output stream ( s file ) ) ) ; oo . write object ( object ) ; oo . close ( ) ; } catch ( exception ex ) { j . show message dialog ( this , str + s file . get name ( ) + str + ex . get message ( ) , str , j . error message ) ; } } }	saves an object to a file selected by the user .
@ override public void write ( data output out ) throws io { if ( use hadoop text ) text . write string ( out , term ) ; else out . write utf ( term ) ; writable utils . write v ( out , splitno ) ; writable utils . write v ( out , flushno ) ; }	write out this term key to output stream ' out '.
public static string strip non digits ( string str ) { string buffer result = new string buffer ( str . length ( ) ) ; for ( char candidate : str . to char array ( ) ) { if ( character . is digit ( candidate ) ) { result . append ( candidate ) ; } } return result . to string ( ) ; }	strips all non - digit characters from a string.
protected collection < communication summary statistics > do get communication summary statistics ( string tenant id , criteria criteria ) { string index = client . get index ( tenant id ) ; map < string , communication summary statistics > stats = new hash map < > ( ) ; if ( ! criteria . transaction wide ( ) ) { criteria txn wide criteria = criteria . derive transaction wide ( ) ; build communication summary statistics ( stats , index , txn wide criteria , bool ) ; } build communication summary statistics ( stats , index , criteria , bool ) ; return stats . values ( ) ; }	this method returns the flat list of communication summary stats .
public void remove content ( string variable id ) { if ( ! paused ) { cur state . remove from state ( variable id ) ; update ( ) ; } else { log . info ( str + variable id ) ; } }	removes the variable from the dialogue state.
public void add command listener ( action listener l ) { if ( global command listeners == null ) { global command listeners = new event dispatcher ( ) ; } global command listeners . add listener ( l ) ; }	adds a command listener that would be bound to all forms in the gui seamlessly.
public static void complete background tasks ( long timeout millis ) { boolean fifo empty = bool ; boolean async threads completed = bool ; long abs timeout = system . current time millis ( ) + timeout millis ; while ( system . current time millis ( ) < abs timeout ) { synchronized ( fifo ) { fifo empty = fifo . size ( ) == num ; } synchronized ( j . class ) { async threads completed = async threads running == num ; } if ( fifo empty && async threads completed ) break ; try { thread . sleep ( num ) ; } catch ( interrupted exception e ) { break ; } } }	wait for background tasks to complete.
private synchronized void write object ( java . io . object output stream s ) throws io { if ( actions == null ) get actions ( ) ; s . default write object ( ) ; }	writeobject is called to save the state of the propertypermission to a stream.
public static final byte [ ] decode ( buffered reader reader ) throws io , base64 decoding exception { byte [ ] ret bytes = null ; unsync byte array output stream baos = null ; try { baos = new unsync byte array output stream ( ) ; string line ; while ( null != ( line = reader . read line ( ) ) ) { byte [ ] bytes = decode ( line ) ; baos . write ( bytes ) ; } ret bytes = baos . to byte array ( ) ; } finally { baos . close ( ) ; } return ret bytes ; }	base64 decode the lines from the reader and return an inputstream with the bytes .
public boolean is defined in env ( ) { if ( env vars == null || param names . length == num ) { return bool ; } for ( string var : env vars ) { if ( system . getenv ( var ) == null ) { return bool ; } } return bool ; }	determines if the argument provisioning has been done via the environment .
public void apply ( animator animator , float curr value , float end value , float velocity ) { apply ( animator , curr value , end value , velocity , math . abs ( end value - curr value ) ) ; }	applies the interpolator and length to the animator , such that the fling animation is consistent with the finger motion .
public void add notice ( parser notice notice ) { notices . add ( notice ) ; }	adds a parser notice .
@ override public string to string ( ) { int len = session id . length ; string buffer s = new string buffer ( num + num * len ) ; s . append ( str ) ; for ( int i = num ; i < len ; i ++ ) { s . append ( num & session id [ i ] ) ; if ( i != ( len - num ) ) s . append ( str ) ; } s . append ( str ) ; return s . to string ( ) ; }	returns the id as a string.
public event binder < e > after ( string name ) { after . add ( name ) ; return this ; }	sets the event to occur after another event with given name .
public d forward ( d llp , d pt ) { return forward ( llp . get y ( ) , llp . get x ( ) , pt , bool ) ; }	forward project a point .
private static int max num arcs for dedup byte ( int current num dedup bytes ) { int max arcs = num + ( num * current num dedup bytes ) ; if ( current num dedup bytes > num ) { max arcs *= current num dedup bytes ; } return math . min ( max arcs , num ) ; }	num arcs for nth dedup byte : if n < = 5 : 1 + ( 2 * n ) else : ( 1 + ( 2 * n ) ) * n < p > todo : is there a better way to make the fst built to be more topnsearcher friendly ?.
public job create request create job create request ( string namespace cd , string job name ) { list < parameter > parameters = new array list < > ( ) ; parameter parameter = new parameter ( abstract service test . attribute name 2 mixed case , abstract service test . attribute value 2 ) ; parameters . add ( parameter ) ; parameter = new parameter ( str , null ) ; parameters . add ( parameter ) ; return create job create request ( namespace cd , job name , parameters ) ; }	creates job create request using a specified namespace code and job name , but test hard coded parameters will be used .
private void load ( ) throws repository exception , rdf , io { final repository connection conn = repository . get connection ( ) ; string ttl string = model ttl ; input stream string input = new byte array input stream ( ttl string . get bytes ( ) ) ; conn . add ( string input , str , rdf . turtle , new resource [ ] { } ) ; ttl string = bucket ttl ; string input = new byte array input stream ( ttl string . get bytes ( ) ) ; conn . add ( string input , str , rdf . turtle , new resource [ ] { } ) ; conn . commit ( ) ; conn . close ( ) ; }	load the t - box and a - box turtle from strings defined within this class .
public boolean is tax included ( ) { if ( m m id == num ) { m m id = db . get sql ( get ( ) , str , get c id ( ) ) ; } m pl = m . get ( get ctx ( ) , m m id , get ( ) ) ; return pl . is tax included ( ) ; }	is tax included in amount.
protected web resource create request ( string uri path ) { ensure initialization ( ) ; return client request helper . create request ( client , service uri , uri . create ( uri path ) ) ; }	create a request object for the specified path , resolved against the service base uri and using the appropriate client configuration.
public void next table ( ) throws sql { if ( tables . has next ( ) ) { current table = tables . next ( ) ; open rows ( ) ; } }	move reference of the current table up by one.
public d ( j parent , string title , x500 name distinguished name , boolean editable ) { super ( parent , title , dialog . modality type . document modal ) ; this . distinguished name = distinguished name ; this . editable = editable ; init components ( ) ; }	creates a new ddistinguishednamechooser dialog .
public static boolean delete file ( string file path and name ) { if ( ( file path and name == null ) || file path and name . is empty ( ) ) { return bool ; } boolean is successful delete = bool ; try { file file to delete = new file ( file path and name ) ; is successful delete = file to delete . delete ( ) ; } catch ( exception e ) { logger . debug ( e . to string ( ) + system . line separator ( ) + stack trace . get string from stack trace ( e ) ) ; is successful delete = bool ; } return is successful delete ; }	this is a quiet method .
public io ( file path ) { this ( new io ( ) , new file path ( path . get absolute path ( ) ) ) ; }	creates a new instance for os file system operating on the caller - specified file .
@ override public int compare to ( final time instant rhs ) { return integer . compare ( this . time , rhs . time ) ; }	compares this instant to another timeinstant .
private boolean write to characteristic ( bluetooth gatt characteristic charc , byte [ ] data ) { charc . set value ( data ) ; boolean result = m gatt client . write characteristic ( charc ) ; if ( result ) { log . d ( tag , str + charc . get uuid ( ) + str + arrays . to string ( data ) ) ; } else { log . e ( tag , str + charc . get uuid ( ) + str + arrays . to string ( data ) ) ; } return result ; }	write to a oad characteristic.
public char skip to ( char to ) { char c ; int index = this . my index ; do { c = next ( ) ; if ( c == num ) { this . my index = index ; return c ; } } while ( c != to ) ; back ( ) ; return c ; }	skip characters until the next character is the requested character.
public int check version size ( final software version version ) { url image url = get image url ( version ) ; url url connection = invoke request ( image url ) ; return url connection . get content length ( ) ; }	get the size of the image file of a version.
private static date time formatter create formatter for style ( string style ) { if ( style == null || style . length ( ) != num ) { throw new illegal argument exception ( str + style ) ; } int date style = select style ( style . char at ( num ) ) ; int time style = select style ( style . char at ( num ) ) ; if ( date style == none && time style == none ) { throw new illegal argument exception ( str ) ; } return create formatter for style index ( date style , time style ) ; }	select a format from a two character style pattern.
public boolean ack next chunk id ( string id ) { if ( state . is terminated ( ) ) return bool ; else if ( id . equals ( chunkid ) ) { return bool ; } else { if ( ! allow other chunks in between ( id ) ) { if ( state . is done ( ) ) { if ( ! is terminated ( ) ) terminate ( ) ; return bool ; } else { throw new pngj input exception ( str + id + str + chunkid + str ) ; } } else return bool ; } }	this will be called by the owner to report us the next chunk to come.
private top docs combine ( top docs in , top docs resorted , query rescore context ctx ) { system . arraycopy ( resorted . score docs , num , in . score docs , num , resorted . score docs . length ) ; if ( in . score docs . length > resorted . score docs . length ) { for ( int i = resorted . score docs . length ; i < in . score docs . length ; i ++ ) { in . score docs [ i ] . score *= ctx . query weight ( ) ; } arrays . sort ( in . score docs , score doc comparator ) ; } return in ; }	modifies incoming topdocs ( in ) by replacing the top hits with resorted ' s hits , and then resorting all hits .
public void test pos pos same length ( ) { byte a bytes [ ] = { - num , num , num , - num , - num , num , num , num , num , - num , num , num , - num } ; byte b bytes [ ] = { - num , - num , - num , - num , num , num , num , num , num , num , num , num , num , num } ; int a sign = num ; int b sign = num ; byte r bytes [ ] = { num , - num , - num , - num , - num , - num , - num , num , num , num , num , - num , num , num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . or ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	or for two positive numbers of the same length.
@ override public void pause ( boolean to pause ) { is paused = to pause ; }	pauses or unpauses the recogniser .
public static string replace all ( string original , string old substring , string new substring ) { return replace ( original , old substring , new substring , bool ) ; }	returns original with all occurrences of oldsubstring replaced by newsubstring.
public long add ( final add op add ) throws exception { return add ( add , uuid . random uuid ( ) ) ; }	adds rdf data to the remote repository .
protected boolean is small ( ) { return this . scale * this . text size in meters < this . pixel size in meters ; }	determine if the text is too small to draw .
public byte [ ] decompress ( data input is ) { byte array output stream baos = new byte array output stream ( ) ; try { while ( bool ) { byte b = is . read byte ( ) ; if ( b == - num ) break ; baos . write ( b ) ; } } catch ( eof ex ) { } catch ( io ex ) { throw new runtime exception ( ex ) ; } return decompress ( baos . to byte array ( ) ) ; }	decompress an input stream until eof .
public int borrow spare register ( int category ) { int result = spare register base + borrowed spare registers ; borrowed spare registers += category ; register count = math . max ( register count , result + category ) ; return result ; }	borrows a register to use as a temp.
public void true ( boolean expression , object error message ) { if ( ! expression ) { throw new illegal argument exception ( string . value of ( error message ) ) ; } }	ensures the truth of an expression involving one or more parameters to the calling method .
private void process fields ( final object component , final context context , final context destroyer context destroyer ) { class < ? > component class = component . get class ( ) ; while ( component class != null && ! component class . equals ( object . class ) ) { final field [ ] fields = class reflection . get declared fields ( component class ) ; if ( fields != null && fields . length > num ) { process fields ( component , fields , context , context destroyer ) ; } component class = component class . get superclass ( ) ; } }	scans class tree of component to process all its fields .
public static string replace all ( string input , string regular expression , string replacement ) { return input . replace all ( regular expression , replacement ) ; }	replace all occurrences in the original string of the oldstring with the newstring .
void request notification update ( ) { if ( m current notification group index != notification off ) { rhythm notification service . show notification ( m context , m notification id ) ; } }	should be called whenever notification state is changed ( e.
public static int count lower case ( final string text ) { int count = num ; for ( final char chr : text . to char array ( ) ) { if ( character . is lower case ( chr ) ) { count ++ ; } } return count ; }	counts the number of lower case characters .
@ override protected void create buttons for button bar ( final composite parent ) { for ( final iterator it = button descriptions . iterator ( ) ; it . has next ( ) ; ) { final button description button description = ( button description ) it . next ( ) ; create button ( parent , button description . button id , button description . button label , button description . is default ) ; } if ( include default buttons ) { super . create buttons for button bar ( parent ) ; } hook after buttons created ( ) ; }	subclasses may override this method to do their own button bar handling.
private boolean check file modifications ( ) throws exception { long dest file time = dest file . last modified ( ) ; if ( source file . last modified ( ) > dest file time ) { logger . debug ( str ) ; return bool ; } properties metadata = restore file modifications ( meta data file ) ; if ( metadata == null ) { return bool ; } sax parser factory = sax . new instance ( ) ; sax parser = parser factory . new sax ( ) ; time checker handler handler = new time checker handler ( base dir , metadata ) ; parser . parse ( source file , handler ) ; return handler . is modified ( ) ; }	check for modifications of included files .
public static number mul ( number a , number b ) { if ( is floating point ( a ) || is floating point ( b ) ) { return a . double value ( ) * b . double value ( ) ; } else { return a . long value ( ) * b . long value ( ) ; } }	returns the value of multiplying the two numbers .
private final int find widest axis ( ) { int widest = num ; double width = ( max limit [ num ] - min limit [ num ] ) * get axis weight hint ( num ) ; if ( double . is na n ( width ) ) { width = num ; } for ( int i = num ; i < dimensions ; i ++ ) { double nwidth = ( max limit [ i ] - min limit [ i ] ) * get axis weight hint ( i ) ; if ( double . is na n ( nwidth ) ) { nwidth = num ; } if ( nwidth > width ) { widest = i ; width = nwidth ; } } return widest ; }	find the widest axis of the bounds of this node.
public void add sort key ( int column , comparator < string > comparator ) { sort keys . add ( column ) ; sort comparators . add ( comparator ) ; }	adds a table sort key.
public static string tag swap ( string content , map < string , string > tag swap map ) { for ( map . entry < string , string > entry : tag swap map . entry set ( ) ) { content = content . replace ( entry . get key ( ) , entry . get value ( ) ) ; } return content ; }	swaps content with tags with the provided tag values .
public static run stats delegate get bucket for integers ( int buckets ) throws exception { long start time = system . current time millis ( ) ; primary index bucket generator impl ibg = new primary index bucket generator impl ( field data type . integer , buckets ) ; primary index bucket locator impl locator = new primary index bucket locator impl ( null , null , null , ibg . generate buckets ( ) , null , null , null , null , null ) ; logger . debug ( str ) ; hash map < long , list < object > > hm = new hash map < > ( ) ; summary statistics stats = new summary statistics ( ) ; for ( int input int = - num ; input int < num ; input int ++ ) { long bucket id = locator . get bucket ( input int , field data type . integer ) ; calculate ( hm , stats , bucket id , input int ) ; } long run time = system . current time millis ( ) - start time ; run stats run stats = new run stats ( str , field data type . integer , run time , stats , hm ) ; logger . debug ( run stats . to string ( ) ) ; return run stats ; }	test to check the bucket distribution for the common integer values.
public static long count substr ( final string value , final string sub str , final boolean case sensitive , boolean allow overlapping ) { validate ( value , null string predicate , null string msg supplier ) ; return count substr ( case sensitive ? value : value . to lower case ( ) , case sensitive ? sub str : sub str . to lower case ( ) , allow overlapping , num ) ; }	count the number of times substr appears in value.
private void drop index ( string index name ) throws oracle exception { prepared statement stmt = null ; if ( index name == null ) throw soda . make exception ( soda . ex arg cannot be null , str ) ; index name = collection descriptor . string to identifier ( index name ) ; string sqltext = drop index ddl ( index name ) ; try { metrics . start timing ( ) ; stmt = conn . prepare statement ( sqltext ) ; stmt . execute ( ) ; if ( oracle log . is logging enabled ( ) ) log . info ( str + index name ) ; stmt . close ( ) ; stmt = null ; metrics . record ddl ( ) ; } catch ( sql e ) { int errcode = e . get error code ( ) ; if ( ( errcode == ora sql object not exists ) || ( errcode == ora sql index not exists ) ) { if ( oracle log . is logging enabled ( ) ) log . warning ( e . to string ( ) ) ; } else { if ( oracle log . is logging enabled ( ) ) log . warning ( e . to string ( ) ) ; throw soda . make exception with sql ( e , sqltext ) ; } } finally { for ( string message : soda . close cursor ( stmt , null ) ) { if ( oracle log . is logging enabled ( ) ) log . severe ( message ) ; } } }	drop the named index.
void unlaunch ( ) { if ( server != null ) { server . die ( ) ; server = null ; } frame . set visible ( bool ) ; client = null ; system . gc ( ) ; system . run finalization ( ) ; }	un - hides the main menu and tries to clean up the client or server .
public int post files ( file [ ] files , int start index in args , output stream out , string type ) { reset ( ) ; int files posted = num ; for ( file src file : files ) { if ( src file . is directory ( ) && src file . can read ( ) ) { files posted += post directory ( src file , out , type ) ; } else if ( src file . is file ( ) && src file . can read ( ) ) { files posted += post files ( new file [ ] { src file } , out , type ) ; } else { file parent = src file . get parent file ( ) ; if ( parent == null ) parent = new file ( str ) ; string file glob = src file . get name ( ) ; glob file filter ff = new glob file filter ( file glob , bool ) ; file [ ] file list = parent . list files ( ff ) ; if ( file list == null || file list . length == num ) { warn ( str + src file ) ; continue ; } files posted += post files ( file list , out , type ) ; } } return files posted ; }	post all filenames provided in args.
private static string unicode2html ( final string text , final boolean amp , final boolean html ) { if ( text == null ) return null ; final string builder sb = new string builder ( text . length ( ) * num / num ) ; int textpos = num ; string r ; char c ; while ( textpos < text . length ( ) ) { c = text . char at ( textpos ) ; if ( amp && c == amp unicode ) { sb . append ( amp html ) ; textpos ++ ; continue ; } if ( ( r = unicod htm xml . get ( c ) ) != null ) { sb . append ( r ) ; textpos ++ ; continue ; } if ( html && ( r = unicod htm html . get ( c ) ) != null ) { sb . append ( r ) ; textpos ++ ; continue ; } sb . append ( c ) ; textpos ++ ; } return sb . to string ( ) ; }	replaces characters which have special representation in html or xml .
public string add playlist ( string playlist name ) { content values m inserts = new content values ( ) ; m inserts . put ( media store . audio . playlists . name , playlist name ) ; m inserts . put ( media store . audio . playlists . date added , system . current time millis ( ) ) ; m inserts . put ( media store . audio . playlists . date modified , system . current time millis ( ) ) ; uri uri = m content resolver . insert ( media store . audio . playlists . external content uri , m inserts ) ; if ( uri == null ) { return null ; } else { string ref = prefix playlist + get playlist unique name ( long . to string ( content uris . parse id ( uri ) ) ) ; playlist pl = new playlist ( ref ) ; pl . set name ( playlist name ) ; pl . set is loaded ( bool ) ; m playlists . put ( ref , pl ) ; m callback . playlist updated ( pl ) ; return ref ; } }	adds a new playlist.
public static json read json ( final json json object , final string key , final boolean required , final boolean not null ) throws json { if ( required ) { return json object . get json ( key ) ; } if ( not null && json object . is null ( key ) ) { throw new json ( string . format ( locale . us , null value format object , key ) ) ; } json value = null ; if ( ! json object . is null ( key ) ) { value = json object . get json ( key ) ; } return value ; }	reads the json array value from the json object for specified tag .
default int copy to ( @ not null byte [ ] bytes ) throws buffer underflow exception { int len = ( int ) math . min ( bytes . length , read remaining ( ) ) ; for ( int i = num ; i < len ; i ++ ) bytes [ i ] = read byte ( start ( ) + i ) ; return len ; }	read a byte [ ] from memory .
private static float [ ] random points ( random random , int waves count , float width , float shift coef ) { float shift ; float [ ] points = new float [ waves count + num ] ; for ( int i = num ; i < points . length ; i ++ ) { if ( i == num ) { points [ i ] = - num ; } else if ( i == points . length - num ) { points [ i ] = num ; } else { shift = random . next float ( ) * shift coef * width ; shift *= random . next boolean ( ) ? num : - num ; points [ i ] = - num + i * width + shift ; } } return points ; }	generate random points for wave .
private void add characters ( final map < string , rp > characters ) { for ( entry < string , rp > character : characters . entry set ( ) ) { j button = create character button ( character . get key ( ) , character . get value ( ) ) ; character panel . add ( button ) ; } }	add the available characters .
public void run test ( ) throws throwable { document doc ; node list gender list ; node gender node ; character data ent text ; entity reference ent reference ; doc = ( document ) load ( str , bool ) ; gender list = doc . get elements by tag name ( str ) ; gender node = gender list . item ( num ) ; ent reference = doc . create entity reference ( str ) ; assert not null ( str , ent reference ) ; ent text = ( character data ) ent reference . get first child ( ) ; assert not null ( str , ent text ) ; { boolean success = bool ; try { ent text . insert data ( num , str ) ; } catch ( dom ex ) { success = ( ex . code == dom . no modification allowed err ) ; } assert true ( str , success ) ; } }	runs the test case .
@ override public void unbind view ( vh holder ) { }	called when the view is unbound.
public static boolean is present ( rule rule ) { if ( rule == null ) { return bool ; } return ( ! is not set ( rule . get min scale denominator ( ) ) || ! is not set ( rule . get max scale denominator ( ) ) ) ; }	checks if rule has minimum or maximum scale denominator set.
public long startcode ( ) { return long . parse long ( fields [ num ] ) ; }	the address above which program text can run .
public static void register default resolvers ( ) { list < key resolver > key resolver list = new array list < key resolver > ( ) ; key resolver list . add ( new key resolver ( new rsa ( ) ) ) ; key resolver list . add ( new key resolver ( new dsa ( ) ) ) ; key resolver list . add ( new key resolver ( new x509 certificate resolver ( ) ) ) ; key resolver list . add ( new key resolver ( new ski ( ) ) ) ; key resolver list . add ( new key resolver ( new retrieval method resolver ( ) ) ) ; key resolver list . add ( new key resolver ( new x509 subject name resolver ( ) ) ) ; key resolver list . add ( new key resolver ( new x509 issuer serial resolver ( ) ) ) ; key resolver list . add ( new key resolver ( new der ( ) ) ) ; key resolver list . add ( new key resolver ( new key info reference resolver ( ) ) ) ; key resolver list . add ( new key resolver ( new x509 digest resolver ( ) ) ) ; resolver vector . add all ( key resolver list ) ; }	this method registers the default resolvers .
public static final void delete ( string file name ) { file file = new file ( file name ) ; if ( ! file . delete ( ) ) { log . error ( str , file ) ; } file metadata file = new file ( file name + metadata suffix ) ; if ( ! metadata file . delete ( ) ) { log . error ( str , metadata file ) ; } file directory = file . get parent file ( ) ; if ( directory . is directory ( ) ) { directory . delete ( ) ; } }	deletes the file and accompanying expire date .
@ override public boolean equals ( object obj ) { if ( obj == this ) { return bool ; } if ( ! ( obj instanceof time period values collection ) ) { return bool ; } time period values collection that = ( time period values collection ) obj ; if ( this . domain is points in time != that . domain is points in time ) { return bool ; } if ( this . x position != that . x position ) { return bool ; } if ( ! object utilities . equal ( this . data , that . data ) ) { return bool ; } return bool ; }	tests this instance for equality with an arbitrary object .
public void print ( j pane ) { set document ( pane ) ; print dialog ( ) ; }	prints the document in the jtextpane .
private boolean ensure scroll wheel adjusted ( ) { int delta y = m initial scroll offset - m current scroll offset ; if ( delta y != num ) { m previous scroller y = num ; if ( math . abs ( delta y ) > m selector element height / num ) { delta y += ( delta y > num ) ? - m selector element height : m selector element height ; } m adjust scroller . start scroll ( num , num , num , delta y , selector adjustment duration millis ) ; invalidate ( ) ; return bool ; } return bool ; }	ensures that the scroll wheel is adjusted i.
private string sort xml ( final string original xml ) { string error msg = str ; xml processing instruction parser . scan for ignored sections ( original xml ) ; string xml = xml processing instruction parser . replace ignored sections ( ) ; insert xml in xml processor ( xml , error msg ) ; xml processor . sort xml ( ) ; try ( byte array output stream sorted xml output stream = xml processor . get sorted xml ( ) ) { string sorted xml = sorted xml output stream . to string ( encoding ) ; if ( xml processing instruction parser . exists ignored sections ( ) ) { sorted xml = xml processing instruction parser . revert ignored sections ( sorted xml ) ; } return sorted xml ; } catch ( io e ) { throw new failure exception ( error msg + xml , e ) ; } }	sorts the incoming xml .
void wait for dictionary loading ( ) { while ( m updating dictionary ) { try { thread . sleep ( num ) ; } catch ( interrupted exception e ) { } } }	used only for testing purposes this function will wait for loading from database to be done.
private void publish data ( string path , byte [ ] data ) { try { if ( data != null && data . length > num ) { byte array input stream bii = new byte array input stream ( data ) ; object input stream ois = new object input stream ( bii ) ; object data obj = ois . read object ( ) ; zoo keeper data wrapper wrapper = ( zoo keeper data wrapper ) ( data obj ) ; jetstream message tm = ( jetstream message ) wrapper . get orginal data ( ) ; string tracker key = create key ( path , wrapper ) ; m change tracker . put ( tracker key , wrapper . get timestamp ( ) ) ; try { logger . warn ( str + path + str + tracker key + str + wrapper . get timestamp ( ) ) ; m transport listener . post message ( tm , m queue stats ) ; } catch ( throwable mse ) { string buffer buf = new string buffer ( ) ; buf . append ( str ) ; buf . append ( mse . get localized message ( ) ) ; logger . error ( str + path + buf . to string ( ) , mse ) ; } m total msgs rcvd . increment ( ) ; m msgs rcvd per sec . increment ( ) ; } } catch ( class not found exception e ) { logger . error ( str + path , e ) ; } catch ( io e ) { logger . error ( str + path , e ) ; } }	post notifications on to transport listeners.
static public long next addr ( random r , worm address manager am ) { if ( r . next int ( num ) < num ) return num ; return next non zero addr ( r , am ) ; }	returns a legal random address and null 5 % of the time .
public void undoable edit happened ( mx undoable edit undoable edit ) { if ( enabled ) { if ( undoable edit . get transparent ( ) ) { } else if ( ! undoable edit . get undoable ( ) ) { not undoable edit happened ( ) ; } else if ( collection ) { collected . add ( undoable edit ) ; fire event ( new mx event object ( mx event . add , str , undoable edit ) ) ; } else { collected . add ( undoable edit ) ; add event list ( ) ; fire event ( new mx event object ( mx event . add , str , undoable edit ) ) ; } } }	method to be called to add new undoable edits to the history .
public file ( file dir , string name ) { this ( dir == null ? null : dir . get path ( ) , name ) ; }	constructs a new file using the specified directory and name .
public void remove drag listener ( drag listener l ) { m listeners . remove ( l ) ; }	remove a previously installed drag listener .
private high tide values find high tide ( json response object ) throws json , parse exception { json predictions = ( json ) response object . get ( str ) ; json last prediction = null , first high tide = null , second high tide = null , low tide = null ; boolean first tide done = bool ; for ( int i = num ; i < predictions . length ( ) ; i ++ ) { json prediction = ( json ) predictions . get ( i ) ; if ( last prediction == null ) { last prediction = prediction ; continue ; } if ( is tide increasing ( last prediction , prediction ) ) { if ( ! first tide done ) { first high tide = prediction ; } else { second high tide = prediction ; } } else { if ( ! first tide done && first high tide != null ) { first tide done = bool ; } else if ( second high tide != null ) { break ; } if ( first tide done ) { low tide = prediction ; } } last prediction = prediction ; } date format date format = new simple date format ( str ) ; return new high tide values ( alexa date util . get formatted time ( date format . parse ( first high tide . get string ( str ) ) ) , get formatted height ( first high tide . get string ( str ) ) , alexa date util . get formatted time ( date format . parse ( low tide . get string ( str ) ) ) , get formatted height ( low tide . get string ( str ) ) , alexa date util . get formatted time ( date format . parse ( second high tide . get string ( str ) ) ) , get formatted height ( second high tide . get string ( str ) ) ) ; }	algorithm to find the 2 high tides for the day , the first of which is smaller and occurs mid - day , the second of which is larger and typically in the evening .
public static boolean is ip address ( string ip address ) { matcher m1 = valid ip . matcher ( ip address ) ; if ( m1 . matches ( ) ) { return bool ; } matcher m2 = valid ip . matcher ( ip address ) ; return m2 . matches ( ) ; }	determine if the given string is a valid ipv4 or ipv6 address.
@ override public synchronized void remove training set listener ( training set listener tsl ) { m training listeners . remove element ( tsl ) ; }	remove a training set listener.
public void rename attribute value ( attribute att , string val , string name ) { int v = att . index of value ( val ) ; if ( v == - num ) { throw new illegal argument exception ( val + str ) ; } rename attribute value ( att . index ( ) , v , name ) ; }	renames the value of a nominal ( or string ) attribute value.
private static void s uacmean ( sparse block a , double [ ] c , int m , int n , kahan object kbuff , mean kmean , int rl , int ru ) { arrays . fill ( c , n , n * num , ru - rl ) ; if ( a . is contiguous ( ) ) { count dis agg ( a . values ( rl ) , c , a . indexes ( rl ) , a . pos ( rl ) , n , ( int ) a . size ( rl , ru ) ) ; } else { for ( int i = rl ; i < ru ; i ++ ) { if ( ! a . is empty ( i ) ) count dis agg ( a . values ( i ) , c , a . indexes ( i ) , a . pos ( i ) , n , a . size ( i ) ) ; } } if ( a . is contiguous ( ) ) { mean agg ( a . values ( rl ) , c , a . indexes ( rl ) , a . pos ( rl ) , ( int ) a . size ( rl , ru ) , n , kbuff , kmean ) ; } else { for ( int i = rl ; i < ru ; i ++ ) { if ( ! a . is empty ( i ) ) mean agg ( a . values ( i ) , c , a . indexes ( i ) , a . pos ( i ) , a . size ( i ) , n , kbuff , kmean ) ; } } }	colmean , opcode : uacmean , sparse input .
public boolean is pdf attachment ( ) { if ( get po ( ) == null ) return bool ; return m po . is pdf attachment ( ) ; }	does the underlying po ( ! ) object have a pdf attachment.
private int name to index ( string parameter name ) throws sql { parameter metadata . read metadata from db if required ( ) ; for ( int i = num ; i <= parameter metadata . get parameter count ( ) ; i ++ ) { string name = parameter metadata . get name ( i ) ; if ( name != null && name . equals ignore case ( parameter name ) ) { return i ; } } throw new sql ( str + parameter name ) ; }	convert parameter name to parameter index in the query .
public void sort ( comparator < ? super sub range > comparator ) { collections . sort ( data , comparator ) ; }	sort aggregated sub ranges with providen comparator.
private void add ( tree map < string , object > map , string key , object value ) { vector < object > v = get list ( map , key ) ; if ( v == null ) { v = new vector < > ( ) ; synchronized ( map ) { map . put ( key , v ) ; } } if ( ! v . contains ( value ) ) { v . add ( value ) ; } }	generic method for adding into a map.
public void test single resource locking serialized waits for high concurrency task timeout ( ) throws exception { final properties properties = new properties ( ) ; final int nthreads = num ; final int ntasks = num ; properties . set property ( test options . core pool size , str + nthreads ) ; properties . set property ( test options . ntasks , str + ntasks ) ; properties . set property ( test options . nresources , str ) ; properties . set property ( test options . min locks , str ) ; properties . set property ( test options . max locks , str ) ; properties . set property ( test options . task timeout , str ) ; properties . set property ( test options . predeclare locks , str ) ; properties . set property ( test options . sort lock requests , str ) ; final result result = do comparison test ( properties ) ; assert equals ( str , num , integer . parse int ( result . get ( str ) ) ) ; assert equals ( str , num , integer . parse int ( result . get ( str ) ) ) ; final int ncancel = integer . parse int ( result . get ( str ) ) ; assert true ( str , ncancel > num ) ; }	test where each operation locks only a single resource and there is only one resource to be locked so that all operations must be serialized.
private void blackman harris3s ( int size ) { int start = ( window function . length - size ) / num ; int stop = ( window function . length + size ) / num ; double scale = num / ( double ) size / num ; for ( int i = num ; start < stop ; start ++ , i ++ ) window function [ i ] = scale * ( num - num * math . cos ( two pi * i / size ) + num * math . cos ( num * two pi * i / size ) ) ; }	fill an array with the values of a 61 - db 3 - sample blackman - harris window function.
private week fields ( day of week first day of week , int minimal days in first week ) { objects . require non null ( first day of week , str ) ; if ( minimal days in first week < num || minimal days in first week > num ) { throw new illegal argument exception ( str ) ; } this . first day of week = first day of week ; this . minimal days = minimal days in first week ; }	creates an instance of the definition .
static heap doubles sketch copy ( doubles sketch sketch ) { heap doubles sketch qs copy ; qs copy = heap doubles sketch . new instance ( sketch . get k ( ) ) ; qs copy . n = sketch . get n ( ) ; qs copy . min value = sketch . get min value ( ) ; qs copy . max value = sketch . get max value ( ) ; qs copy . combined buffer item capacity = sketch . get combined buffer item capacity ( ) ; qs copy . base buffer count = sketch . get base buffer count ( ) ; qs copy . bit pattern = sketch . get bit pattern ( ) ; double [ ] comb buf = sketch . get combined buffer ( ) ; qs copy . combined buffer = arrays . copy of ( comb buf , comb buf . length ) ; return qs copy ; }	returns an on - heap copy of the given sketch.
public list < ok > verify ( list < ok > result ) throws io , general security exception { if ( result == null ) result = new array list < > ( ) ; while ( pkcs7 != null ) { result . add all ( verify signature ( ) ) ; } return result ; }	verifies all the document - level timestamps and all the signatures in the document .
public schema field ( string name , field type type ) { this ( name , type , type . properties , null ) ; }	create a new schemafield with the given name and type , using all the default properties from the type .
private void create day slot ( array list < m > list , m ma ) { timestamp start = ma . get start time ( ) ; gregorian calendar cal start = new gregorian calendar ( ) ; cal start . set time ( start ) ; cal start . set ( calendar . hour of day , num ) ; cal start . set ( calendar . minute , num ) ; cal start . set ( calendar . second , num ) ; cal start . set ( calendar . millisecond , num ) ; timestamp end = ma . get end time ( ) ; gregorian calendar cal end = new gregorian calendar ( ) ; cal end . set time ( end ) ; cal end . set ( calendar . hour of day , num ) ; cal end . set ( calendar . minute , num ) ; cal end . set ( calendar . second , num ) ; cal end . set ( calendar . millisecond , num ) ; while ( cal start . before ( cal end ) ) { timestamp x start = new timestamp ( cal start . get time in millis ( ) ) ; cal start . add ( calendar . day of year , num ) ; timestamp x end = new timestamp ( cal start . get time in millis ( ) ) ; m my ma = new m ( x start , x end , ma . get name ( ) , ma . get description ( ) , ma . get status ( ) ) ; list . add ( my ma ) ; } }	create a day slot for range.
public boolean is attachment ( string file name ) { return file name . starts with ( entry attachment ) ; }	true if the given file is an attachment .
public optimized ( int n , int s , int t , iterator < edge info > edges ) { super ( n , s , t ) ; queue = new int [ n ] ; queue size = n ; capacity = new int [ n ] [ n ] ; flow = new int [ n ] [ n ] ; previous = new int [ n ] ; visited = new int [ n ] ; while ( edges . has next ( ) ) { edge info ei = edges . next ( ) ; capacity [ ei . start ] [ ei . end ] = ei . capacity ; } }	load up information for this network problem .
public static map < string , object > bad expire even processor ( dispatch context dctx , map < string , ? extends object > context ) { generic value credit card = ( generic value ) context . get ( str ) ; string expire date = credit card . get string ( str ) ; string last number str = expire date . substring ( expire date . length ( ) - num ) ; int last number = integer . parse int ( last number str ) ; if ( last number % num == num ) { return always bad expire processor ( dctx , context ) ; } else { return always approve processor ( dctx , context ) ; } }	fail / bad expire date when year is even processor.
public expression type negate ( ) { if ( is negated ( ) ) { return new expression type ( type string . replace ( suffix negated , str ) ) ; } else { return new expression type ( type string + suffix negated ) ; } }	negate the type . this are the two typical cases : ver - > ver - neg ver - neg - > ver.
protected void update path greyness ( tree path ancestor ) { boolean value = is path check box ( ancestor ) ; object ancestor node = ancestor . get last path component ( ) ; if ( ! is path check box ( ancestor ) ) { add to check box paths set ( ancestor ) ; return ; } }	updates the greyness value value for the given path if there are children with different values.
protected array list < string > use tokenizer ( string s ) throws exception { string [ ] tokens ; array list < string > result ; int i ; tokens = tokenizer . tokenize ( m , new string [ ] { s } ) ; result = new array list < string > ( ) ; for ( i = num ; i < tokens . length ; i ++ ) { result . add ( tokens [ i ] ) ; } return result ; }	runs the tokenizer over the given string and returns the generated tokens .
public dom ( dom factory , string description , string file extension , string mime type ) { this . factory = factory ; this . description = description ; this . file extension = file extension ; this . mime type = mime type ; try { this . data flavor = new data flavor ( mime type ) ; } catch ( class not found exception ex ) { internal error error = new internal error ( str + mime type ) ; error . init cause ( ex ) ; throw error ; } }	creates a new instance using the specified parameters .
default type parameter declaration as type parameter ( ) { throw new unsupported operation exception ( string . format ( str , this ) ) ; }	return this as a typeparameterdeclaration or throw unsupportedoperationexception .
public void add column ( string header ) { if ( get model ( ) instanceof default table model ) { default table model model = ( default table model ) get model ( ) ; model . add column ( util . clean amp ( header ) ) ; } else throw new illegal argument exception ( str ) ; }	add table column . after adding a column , you need to set the column classes again ( defaulttablemodel fires tablestructurechanged , which calls jtable . tablechanged . . createdefaultcolumnsfrommodel.
public void add move script ( string pathname ) { move scripts . add ( pathname ) ; set dirty and fire property change ( str , pathname , null ) ; }	add a script to run when train is moved.
private void check and add resize handler ( ) { component parent = get parent ( ) ; if ( parent != null && resizable && resize handler == null ) { resize handler = new resize handler ( ) ; parent . add component listener ( resize handler ) ; } }	checks conditions and adds resize handler if they are met .
static public void use xalan x ( ) throws exception { class . for name ( str ) ; class c = class . for name ( str ) ; synchronized ( static lock ) { xpath support class = c ; } if ( log . is debug enabled ( ) ) { log . debug ( str ) ; } }	convenience method . tells the system to use xalan for xpath queries .
public int number of owning shards ( ) { int count = num ; for ( shard routing shard entry : this ) { if ( shard entry . state ( ) != shard routing state . relocating ) { count ++ ; } } return count ; }	the number of shards on this node that will not be eventually relocated .
public string convert binary to hex string ( byte [ ] bytes ) { string builder builder = new string builder ( bytes . length * num ) ; for ( byte b : bytes ) { int high bits int = ( b > > num ) & num ; int low bits int = b & num ; builder . append ( hex chars [ high bits int ] ) ; builder . append ( hex chars [ low bits int ] ) ; } return builder . to string ( ) ; }	convert the provided binary into a hex - string representation where each character represents 4 bits of the provided binary , i.
protected static void write header ( xml writer ) { xml writer util . write comment line break ( writer ) ; xml writer util . write comment ( writer , str ) ; date format date format = new simple date format ( str ) ; xml writer util . write comment ( writer , str + date format . format ( new date ( system . current time millis ( ) ) ) ) ; xml writer util . write comment ( writer , str ) ; xml writer util . write comment ( writer , str ) ; xml writer util . write comment line break ( writer ) ; xml writer util . write line break ( writer ) ; }	method from org . apache . maven . plugins . help . abstracteffectivemojo write comments in the effective pom / settings header .
protected void close ( ) { try { if ( to != null ) to . close ( ) ; if ( from != null ) from . close ( ) ; } catch ( io e ) { } if ( process != null ) process . destroy ( ) ; process = null ; to = null ; from = null ; error logger = null ; }	closes the external process ' s input and output streams , and destroys the process .
public void clear parse issues ( ) { parse issues . clear ( ) ; }	clear the list of parse issues .
private static string unsigned to string ( final int value ) { if ( value >= num ) { return integer . to string ( value ) ; } else { return long . to string ( ( ( long ) value ) & num ) ; } }	convert an unsigned 32 - bit integer to a string .
public connection manager ( connection manager configuration configuration ) throws exception { configuration = configuration ; if ( configuration == null ) { throw new connection manager exception ( str ) ; } }	constructs a connection manager instance .
@ suppress warnings ( str ) public pids ( ) { arrays . sort ( pi , pid comparator ) ; }	creates a new instance of pids.
public void handle header column released ( point p ) { table . set pressed column index ( - num ) ; j th = table . get table header ( ) ; int col = th . column at point ( p ) ; if ( col != - num ) th . repaint ( th . get header rect ( col ) ) ; }	tell the table something is not pressed .
public void create devices ( @ not null list < device > devices ) { if ( ! init if necessary ( ) ) { return ; } for ( device device : devices ) { string device id base = device . get id ( ) ; string device name base = device . get display name ( ) ; int i = num ; while ( is user device ( device ) ) { string id = string . format ( locale . get default ( ) , str , device id base , i ) ; string name = string . format ( locale . get default ( ) , str , device name base , i ) ; device = clone device with new id and name ( device , id , name ) ; } our device manager . add user device ( device ) ; } our device manager . save user devices ( ) ; }	create the given devices.
public writable raster create compatible writable raster ( int w , int h ) { if ( w <= num || h <= num ) { throw new raster format exception ( str + ( ( w <= num ) ? str : str ) ) ; } sample model sm = sample model . create compatible sample model ( w , h ) ; return new short banded raster ( sm , new point ( num , num ) ) ; }	creates a raster with the same layout but using a different width and height , and with new zeroed data arrays .
public void write ( print writer writer ) { for ( int i = num ; i < count ; i ++ ) { writer . println ( keys [ i ] + str + values [ i ] ) ; } writer . flush ( ) ; }	write tab - delimited entries out to.
@ worker thread public synchronized int stop record ( ) { if ( m recorder == null ) { m state = state idle ; return - num ; } int length = - num ; switch ( m state ) { case state recording : try { thread . sleep ( stop audio record delay millis ) ; m recorder . stop ( ) ; length = ( int ) ( ( system . current time millis ( ) - m sample start ) / num ) ; } catch ( runtime exception e ) { log . w ( tag , str + e . get message ( ) ) ; } catch ( interrupted exception e ) { log . w ( tag , str + e . get message ( ) ) ; } case state prepared : case state idle : default : try { m recorder . reset ( ) ; } catch ( runtime exception e ) { log . w ( tag , str + e . get message ( ) ) ; } m recorder . release ( ) ; m recorder = null ; m state = state idle ; break ; } return length ; }	stop record , and save audio file .
public xml ( final class class to be bound , final string [ ] schemas ) throws xml { try { jaxb jc = jaxb . new instance ( class to be bound ) ; marshaller = jc . create marshaller ( ) ; marshaller . set schema ( xml . create schema ( schemas ) ) ; unmarshaller = jc . create unmarshaller ( ) ; unmarshaller . set schema ( xml . create schema ( schemas ) ) ; } catch ( jaxb e ) { throw new xml ( str + class to be bound , e ) ; } }	creates the xmlparser with the given class as root and schema files for validation .
private void abort ( throwable t ) { throwable = t ; }	set the throwable and abort run loop . the throwable will be thrown from the run loop thread.
@ override public final string read null terminated ascii string ( ) { byte array output stream baos = new byte array output stream ( ) ; byte b ; while ( bool ) { b = read byte ( ) ; if ( b == num ) { break ; } baos . write ( b ) ; } byte [ ] buf = baos . to byte array ( ) ; char [ ] chr buf = new char [ buf . length ] ; for ( int x = num ; x < buf . length ; x ++ ) { chr buf [ x ] = ( char ) buf [ x ] ; } return string . value of ( chr buf ) ; }	reads a null - terminated string from the stream .
void close silently ( server socket socket ) { try { socket . close ( ) ; } catch ( exception e ) { } }	close a server socket , ignoring errors.
public expression parser builder with process ( process process ) { this . process = process ; return this ; }	adds the process which enables process dependent functions .
void add associated component at ( int index , component cmp ) { if ( comps == null ) { comps = new vector ( ) ; } comps . insert element at ( cmp , index ) ; }	adds the given component to be associated with this element.
private static byte [ ] read class ( final input stream is ) throws io { if ( is == null ) { throw new io ( str ) ; } byte [ ] b = new byte [ is . available ( ) ] ; int len = num ; while ( bool ) { int n = is . read ( b , len , b . length - len ) ; if ( n == - num ) { if ( len < b . length ) { byte [ ] c = new byte [ len ] ; system . arraycopy ( b , num , c , num , len ) ; b = c ; } return b ; } len += n ; if ( len == b . length ) { int last = is . read ( ) ; if ( last < num ) { return b ; } byte [ ] c = new byte [ b . length + num ] ; system . arraycopy ( b , num , c , num , len ) ; c [ len ++ ] = ( byte ) last ; b = c ; } } }	reads the bytecode of a class .
static string string from packet ( datagram packet packet ) { return new string ( packet . get data ( ) , num , packet . get length ( ) ) ; }	converts a given datagram packet ' s contents to a string .
private string read attribute name ( boolean return lower case ) { skip whitespace ( ) ; int c = find ( attribute name terminators ) ; string for substring = return lower case ? input lower case : input ; string result = pos < c ? for substring . substring ( pos , c ) : null ; pos = c ; return result ; }	returns the next attribute name , or null if the input has been exhausted.
public boolean contains ( final entity entity ) { if ( entity == null ) { return bool ; } final irp entity zone = entity . get zone ( ) ; return zone . equals ( entity zone ) && zone . has ( entity . get id ( ) ) && shape . contains ( entity . get x ( ) , entity . get y ( ) ) ; }	checks whether an entity is in this area ( e.
protected void check offscreen image ( dimension d ) { if ( double buffered ) { if ( offscreen == null || offscreen . get width ( ) != d . width || offscreen . get height ( ) != d . height ) { offscreen = new buffered image ( d . width , d . height , buffered image . type int argb ) ; offscreen g2d = offscreen . create graphics ( ) ; } } }	ensure that , if doublebuffering is enabled , the offscreen image buffer exists and is the correct size .
public void warning ( org . xml . sax . sax e ) throws org . xml . sax . sax { string formatted msg = e . get message ( ) ; sax locator = get locator ( ) ; error listener handler = m stylesheet processor . get error listener ( ) ; try { handler . warning ( new transformer exception ( formatted msg , locator ) ) ; } catch ( transformer exception te ) { throw new org . xml . sax . sax ( te ) ; } }	receive notification of a xslt processing warning .
public static boolean check chroot path ( string zk host , boolean create ) throws keeper exception , interrupted exception { if ( ! contains chroot ( zk host ) ) { return bool ; } log . info ( str ) ; string chroot path = zk host . substring ( zk host . index of ( str ) , zk host . length ( ) ) ; solr zk client tmp client = new solr zk client ( zk host . substring ( num , zk host . index of ( str ) ) , num * num ) ; boolean exists = tmp client . exists ( chroot path , bool ) ; if ( ! exists && create ) { tmp client . make path ( chroot path , bool , bool ) ; exists = bool ; } tmp client . close ( ) ; return exists ; }	validates if the chroot exists in zk ( or if it is successfully created ) . optionally , if create is set to true this method will create the path in case it doesn ' t exist.
public void add x ( string x val ) { m x = ( m x + x val . length ( ) ) / num ; m x . add ( x val ) ; }	adds a new x - value to the chart data .
public long time since start ( ) { long current time = system . current time millis ( ) ; return current time - start time ; }	returns the number of milliseconds since the timer started.
public formatter format ( locale l , string format , object ... args ) { ensure open ( ) ; int last = - num ; int lasto = - num ; format string [ ] fsa = parse ( format ) ; for ( int i = num ; i < fsa . length ; i ++ ) { format string fs = fsa [ i ] ; int index = fs . index ( ) ; try { switch ( index ) { case - num : fs . print ( null , l ) ; break ; case - num : if ( last < num || ( args != null && last > args . length - num ) ) throw new missing format argument exception ( fs . to string ( ) ) ; fs . print ( ( args == null ? null : args [ last ] ) , l ) ; break ; case num : lasto ++ ; last = lasto ; if ( args != null && lasto > args . length - num ) throw new missing format argument exception ( fs . to string ( ) ) ; fs . print ( ( args == null ? null : args [ lasto ] ) , l ) ; break ; default : last = index - num ; if ( args != null && last > args . length - num ) throw new missing format argument exception ( fs . to string ( ) ) ; fs . print ( ( args == null ? null : args [ last ] ) , l ) ; break ; } } catch ( io x ) { last exception = x ; } } return this ; }	writes a formatted string to this object ' s destination using the specified locale , format string , and arguments .
public void test write read empty ( ) throws exception { byte array output stream out = new byte array output stream ( num ) ; object output stream os = new object output stream ( out ) ; os . write object ( empty ) ; object input stream is = new object input stream ( new byte array input stream ( out . to byte array ( ) ) ) ; cluster policy copy = ( cluster policy ) is . read object ( ) ; is . close ( ) ; os . close ( ) ; assert true ( helper . are equals ( empty , copy ) ) ; }	test read and write empty clusterpolicy object.
dom ( string [ ] params ) { f strings = new vector ( ) ; if ( params != null ) { for ( int i = num ; i < params . length ; i ++ ) { f strings . add ( params [ i ] ) ; } } }	construct an empty list of domstringlistimpl.
public instant watermark hold ( ) { long min = long . max value ; for ( instant hold : watermark holds . values ( ) ) { min = math . min ( min , hold . get millis ( ) ) ; } return new instant ( min ) ; }	returns the minimum over all watermark holds .
@ override public final boolean is cap present ( int cap ) { return ( ( ogl caps . get caps ( ) & cap ) != num ) ; }	returns true if the provided capability bit is present for this config.
public static < t > menu result < t > again ( ) { return new menu result < > ( type . again , collections . < t > empty list ( ) ) ; }	creates a new menu result indicating that the menu should be displayed again.
@ suppress warnings ( str ) public v put ( k key , v value ) { final int hash = key . hash code ( ) ; int index = index of ( key , hash ) ; if ( index >= num ) { index = ( index << num ) + num ; final v old = ( v ) m array [ index ] ; m array [ index ] = value ; return old ; } index = ~ index ; if ( m size >= m hashes . length ) { final int n = m size >= ( base size * num ) ? ( m size + ( m size > > num ) ) : ( m size >= base size ? ( base size * num ) : base size ) ; final int [ ] ohashes = m hashes ; final object [ ] oarray = m array ; alloc arrays ( n ) ; if ( m hashes . length > num ) { system . arraycopy ( ohashes , num , m hashes , num , ohashes . length ) ; system . arraycopy ( oarray , num , m array , num , oarray . length ) ; } free arrays ( ohashes , oarray , m size ) ; } if ( index < m size ) { system . arraycopy ( m hashes , index , m hashes , index + num , m size - index ) ; system . arraycopy ( m array , index << num , m array , ( index + num ) << num , ( m size - index ) << num ) ; } m hashes [ index ] = hash ; m array [ index << num ] = key ; m array [ ( index << num ) + num ] = value ; m size ++ ; return null ; }	add a new value to the array map .
public long add new user ( string sid , string username , string userpass , string lastname , string firstname , string email , string additionalname , string street , string zip , string fax , long states id , string town , long language id , string base url ) throws axis fault { try { long users id = session management . check session ( sid ) ; long user level = user management . get user level by id ( users id ) ; if ( auth level management . check web service level ( user level ) ) { configuration conf = cfg management . get conf key ( num , str ) ; string j name time zone = str ; if ( conf != null ) { j name time zone = conf . get conf value ( ) ; } long user id = user management . register user ( username , userpass , lastname , firstname , email , new date ( ) , street , additionalname , fax , zip , states id , town , language id , str , base url , bool , j name time zone ) ; if ( user id == null || user id < num ) { return user id ; } users user = user management . get user by id ( user id ) ; user . set status ( num ) ; user . set updatetime ( new date ( ) ) ; user management . update user ( user ) ; return user id ; } else { return new long ( - num ) ; } } catch ( exception err ) { log . error ( str , err ) ; throw new axis fault ( err . get message ( ) ) ; } }	adds a new usre like through the frontend , but also does activates the account to do sso see the methods to create a hash and use those ones !.
public static void interpreter only ( runnable runnable ) { runnable . run ( ) ; }	directive for the compiler that the given runnable should only be executed in the interpreter and ignored in the compiled code .
public d ( j parent , x509 extension extensions ) { super ( parent , dialog . modality type . document modal ) ; set title ( res . get string ( str ) ) ; this . extensions = extensions ; init components ( ) ; }	creates new daddextensiontype dialog .
private int hash ( graphics configuration config , int w , int h , object ... args ) { int hash ; hash = ( config != null ? config . hash code ( ) : num ) ; hash = num * hash + w ; hash = num * hash + h ; hash = num * hash + arrays . deep hash code ( args ) ; return hash ; }	create a unique hash from all the input.
protected void paint text ( graphics g , abstract button b , rectangle text rect , string text ) { paint text ( g , ( j ) b , text rect , text ) ; }	method which renders the text of the current button . < p >.
public static boolean uses second operand ( final integer mnemonic ) { return ! mnemonic . equals ( reil helpers . opcode nop ) && ! mnemonic . equals ( reil helpers . opcode bisz ) && ! mnemonic . equals ( reil helpers . opcode str ) && ! mnemonic . equals ( reil helpers . opcode stm ) && ! mnemonic . equals ( reil helpers . opcode ldm ) && ! mnemonic . equals ( reil helpers . opcode jcc ) ; }	checks whether an instruction with the given mnemonic uses its second operand .
public rhythm group add overlay ( rhythm overlay overlay ) { m overlays . add ( overlay ) ; if ( m current overlay index == no overlay ) { select overlay ( num ) ; } return this ; }	add rhythm overlay to this group.
public char [ ] to char array ( ) { char [ ] buffer = new char [ count ] ; system . arraycopy ( value , offset , buffer , num , count ) ; return buffer ; }	converts this string to a new character array .
private file [ ] filter files ( final file [ ] to filter , final string file name ) { if ( file name != null && to filter != null ) { final file file as filter = new file ( file name ) ; for ( file file : to filter ) { if ( file . compare to ( file as filter ) == num ) { return new file [ ] { file as filter } ; } } return new file [ num ] ; } return to filter ; }	limit list of possible file to import .
private void pull event ( ) { final int new scroll value ; final int item dimension ; final float initial motion value , last motion value ; switch ( get pull to refresh scroll direction ( ) ) { case horizontal : initial motion value = m initial motion x ; last motion value = m last motion x ; break ; case vertical : default : initial motion value = m initial motion y ; last motion value = m last motion y ; break ; } switch ( m current mode ) { case pull from end : new scroll value = math . round ( math . max ( initial motion value - last motion value , num ) / friction ) ; item dimension = get footer size ( ) ; break ; case pull from start : default : new scroll value = math . round ( math . min ( initial motion value - last motion value , num ) / friction ) ; item dimension = get header size ( ) ; break ; } set header scroll ( new scroll value ) ; if ( new scroll value != num && ! is refreshing ( ) ) { float scale = math . abs ( new scroll value ) / ( float ) item dimension ; switch ( m current mode ) { case pull from end : m footer layout . on pull ( scale ) ; break ; case pull from start : default : m header layout . on pull ( scale ) ; break ; } if ( m state != state . pull to refresh && item dimension >= math . abs ( new scroll value ) ) { set state ( state . pull to refresh ) ; } else if ( ( m state == state . pull to refresh && item dimension < math . abs ( new scroll value ) ) || ( m state == state . reset && item dimension < math . abs ( new scroll value ) ) ) { set state ( state . release to refresh ) ; } } }	actions a pull event.
private file write private key file ( ) throws git exception { final file key directory = new file ( root folder , host ) ; if ( ! key directory . exists ( ) ) { key directory . mkdirs ( ) ; } final file key file = new file ( key directory , default key name ) ; try ( file output stream fos = new file output stream ( key file ) ) { fos . write ( ssh key ) ; } catch ( io e ) { log . error ( str , e ) ; throw new git exception ( str ) ; } protect private key file ( key file ) ; return key file ; }	writes private ssh key into file .
protected boolean draw left border ( component c , graphics g , int x , int y , int width , int height ) { if ( super . draw left border ( c , g , x , y , width , height ) && frame . is resizable ( ) ) { g . set color ( get frame highlight ( ) ) ; int top y = y + corner size ; g . draw line ( x , top y , x + num , top y ) ; int bottom y = height - corner size ; g . draw line ( x + num , bottom y , x + num , bottom y ) ; g . set color ( get frame shadow ( ) ) ; g . draw line ( x + num , top y - num , x + num , top y - num ) ; g . draw line ( x + num , bottom y - num , x + num , bottom y - num ) ; return bool ; } return bool ; }	draws the internalframeborder ' s left border .
public static boolean is file readable ( string file name ) { final file file = new file ( file name ) ; return file . exists ( ) && file . can read ( ) ; }	checks whether the given file is readable.
public static string hinting size ( font font ) { int instr size = num ; loca table loca table = font utils . get loca table ( font ) ; glyph table glyf table = font utils . get glyph table ( font ) ; for ( int i = num ; i < loca table . num glyphs ( ) ; i ++ ) { glyph glyph = glyf table . glyph ( loca table . glyph offset ( i ) , loca table . glyph length ( i ) ) ; instr size += glyph . instruction size ( ) ; } double percentage = instr size * num / glyf table . header length ( ) ; return string . format ( str , instr size , two decimal places . format ( percentage ) ) ; }	gets the size of hinting instructions in the glyph table , both in bytes and as a fraction of the glyph table size .
public static void premain ( string agent args , instrumentation inst ) { instrumentation = inst ; logger . info ( str ) ; check for correct setup ( ) ; try { @ suppress warnings ( str ) inspect it class loader class loader = new inspect it class loader ( new url [ num ] ) ; class < ? > agent clazz = class loader . load class ( inspectit agent ) ; constructor < ? > constructor = agent clazz . get constructor ( file . class ) ; object real agent = constructor . new instance ( get inspect it agent jar file location ( ) ) ; agent . agent = ( i ) real agent ; preload classes ( ) ; logger . info ( str ) ; analyze already loaded classes ( ) ; inst . add transformer ( new java agent ( ) ) ; } catch ( exception e ) { logger . severe ( str ) ; e . print stack trace ( ) ; } }	the premain method will be executed before anything else .
private static float system property value ( string name ) { string float string = system . get property ( name ) ; if ( float string == null ) return float . n ; try { return float . parse float ( float string ) ; } catch ( number format exception ex ) { throw new illegal argument exception ( string . format ( str , name , float string ) ) ; } }	returns the value of the system property , or nan if not defined .
@ zap api ignore public boolean is confirm remove proxy excluded domain ( ) { return this . confirm remove proxy exclude domain ; }	tells whether or not the remotion of a proxy exclusion needs confirmation .
private boolean add local key ( key cache object key , affinity topology version top ver , collection < key cache object > distributed keys ) throws ignite checked exception { grid distributed cache entry entry = cctx . colocated ( ) . entry exx ( key , top ver , bool ) ; assert ! entry . detached ( ) ; if ( ! cctx . is all ( entry , filter ) ) { if ( log . is debug enabled ( ) ) log . debug ( str + entry ) ; on complete ( bool , bool ) ; return bool ; } grid cache mvcc candidate cand = add entry ( entry ) ; if ( cand != null && ! cand . reentry ( ) ) distributed keys . add ( key ) ; return in tx ( ) && cand == null ; }	adds local key future .
public void test radix10 neg ( ) { string value = str ; int radix = num ; big integer a number = new big integer ( value , radix ) ; string result = a number . to string ( radix ) ; assert true ( result . equals ( value ) ) ; }	test negative number of radix 10.
public synchronized int read in test from sut ( ) { if ( remote buffer . is empty ( ) ) { return - num ; } return remote buffer . poll ( ) & num ; }	get the data sent by the sut.
public spatial index ( string shp filename ) throws io { this . shp file name = shp filename ; if ( logger . is loggable ( level . fine ) ) { logger . fine ( str + shp filename + str ) ; } }	opens a spatial index file for reading based on the location of the provided shp file .
public int invoke compiler ( ) { list < string > args = get exec arguments ( ) ; for ( int i = num ; i < args . size ( ) ; i ++ ) { string arg = args . get ( i ) ; if ( arg . starts with ( str ) ) { string file name = arg . substring ( num ) ; args . remove ( i ) ; output arguments to file ( file name , args ) ; break ; } } return exec util . execute ( args . to array ( new string [ args . size ( ) ] ) , system . out , system . err ) ; }	invoke the jsr308 type annotations compiler with all relevant jars on its classpath or boot classpath.
protected void pre update menu ( ) { }	hook method which gets executed just before the menu gets updated.
public pojo value field ( property descriptor desc ) { super ( desc ) ; }	constructs ignite cache value field descriptor .
public url filter rule ( string rule text ) { super ( rule text ) ; string url rule text = rule text ; if ( string utils . starts with ( url rule text , mask white list ) ) { url rule text = url rule text . substring ( mask white list . length ( ) ) ; white list rule = bool ; } int options index = string utils . last index of ( url rule text , options delimiter ) ; if ( options index > - num ) { url rule text = url rule text . substring ( num , options index ) ; } url rule text = to punycode ( url rule text ) ; boolean regex rule = url rule text . starts with ( mask regex rule ) && url rule text . ends with ( mask regex rule ) ; if ( ! regex rule ) { shortcut = find shortcut ( url rule text ) ; } }	creates url filter rule.
public static boolean is drm convert needed ( string mimetype ) { return mimetype drm message . equals ( mimetype ) ; }	checks if the media type needs to be drm converted.
public static string pad ( string original , int length , char pad char ) { if ( original . length ( ) >= length ) return original ; string builder sb = new string builder ( original ) ; while ( sb . length ( ) < length ) { sb . append ( pad char ) ; } return sb . to string ( ) ; }	pad the string with the specific character to ensure the string is at least the specified length .
public void property change ( property change event evt ) { string prop name = evt . get property name ( ) ; if ( prop name == map bean . cursor property ) { fallback map bean cursor = ( ( cursor ) evt . get new value ( ) ) ; } else { if ( prop name == mouse delegator . active mode property ) { map mouse mode mmm = ( map mouse mode ) evt . get new value ( ) ; set reset cursor ( mmm . get mode cursor ( ) ) ; } else if ( prop name == map bean . layers property ) { reset for layers ( ( layer [ ] ) evt . get new value ( ) , ( layer [ ] ) evt . get old value ( ) ) ; } else if ( prop name != map bean . projection property ) { return ; } set all labels ( fudge string ) ; } init tool tip ( ) ; }	listen for changes to the active mouse mode and for any changes to the list of available mouse modes.
private void check for night ( final zoned date time time ) { int hour = time . get hour ( ) ; int minute = time . get minute ( ) ; if ( num <= hour && minute >= num && hour <= num && minute <= num || num <= hour && minute <= num && hour <= num && minute <= num ) { if ( is night mode ( ) ) return ; set night mode ( bool ) ; } else { if ( ! is night mode ( ) ) return ; set night mode ( bool ) ; } }	calling this method will check for the current time of the day and switches on / off the night mode .
@ override public int calculate offset y ( ) { return - ( int ) ( math . sin ( this . angle ) * this . distance ) - this . shadow size ; }	calculates the y - offset for drawing the shadow image relative to the source .
private double [ ] concatenate samples ( final double [ ] x , final double [ ] y ) { final double [ ] z = new double [ x . length + y . length ] ; system . arraycopy ( x , num , z , num , x . length ) ; system . arraycopy ( y , num , z , x . length , y . length ) ; return z ; }	concatenate the samples into one array .
public string handle word ( string a word ) { matcher m = condition pattern . matcher ( a word ) ; if ( m != null && m . matches ( ) ) { if ( type . equals ( affix type . prefix ) ) { return handle prefix ( a word ) ; } else if ( type . equals ( affix type . suffix ) ) { return handle suffix ( a word ) ; } } return null ; }	adopt this affix on a given word.
public static void round ( calendar c , string unit ) { integer uu = calendar units . get ( unit ) ; if ( null == uu ) { throw new illegal argument exception ( str + unit ) ; } int u = uu . int value ( ) ; switch ( u ) { case calendar . year : c . clear ( calendar . month ) ; case calendar . month : c . clear ( calendar . day of month ) ; c . clear ( calendar . day of week ) ; c . clear ( calendar . day of week in month ) ; c . clear ( calendar . day of year ) ; c . clear ( calendar . week of month ) ; c . clear ( calendar . week of year ) ; case calendar . date : c . clear ( calendar . hour of day ) ; c . clear ( calendar . hour ) ; c . clear ( calendar . am pm ) ; case calendar . hour of day : c . clear ( calendar . minute ) ; case calendar . minute : c . clear ( calendar . second ) ; case calendar . second : c . clear ( calendar . millisecond ) ; break ; default : throw new illegal state exception ( str + u + str + unit ) ; } }	modifies the specified calendar by " rounding " down to the specified unit.
private static final char [ ] grow buffer ( char [ ] dest , int index , int size ) { char [ ] copy = new char [ size ] ; if ( index > num ) { system . arraycopy ( dest , num , copy , num , index ) ; } return copy ; }	helper method to grow the character buffer as needed , this only happens once in a while so it ' s ok if it ' s in a method call.
protected j create editor component ( ) { j editor = new borderless text field ( str , num ) ; editor . set border ( null ) ; return editor ; }	creates the internal editor component.
private void add arg ( string key , object value ) { if ( request arguments == null ) { request arguments = new hashtable ( ) ; } if ( value == null || key == null ) { return ; } if ( post ) { set write request ( bool ) ; } request arguments . put ( key , value ) ; }	add an argument to the request response.
public static double [ ] read file column ( string filename , int column idx , int size limit ) throws io , sax { path path = paths . get ( filename ) ; if ( ! ( files . exists ( path ) ) ) { throw new sax ( str ) ; } buffered reader br = new buffered reader ( new input stream reader ( new file input stream ( filename ) , str ) ) ; return read ts ( br , column idx , size limit ) ; }	reads timeseries from a file.
private void start reader ( connection table conn table ) { assert . assert true ( ! this . is running ) ; stopped = bool ; this . is running = bool ; conn table . execute command ( this ) ; }	starts a reader thread.
public static boolean is compaction required for table ( string meta folder path ) { string minor compaction status file = meta folder path + carbon common constants . file separator + carbon common constants . minor compaction required file ; string major compaction status file = meta folder path + carbon common constants . file separator + carbon common constants . major compaction required file ; try { if ( file factory . is file exist ( minor compaction status file , file factory . get file type ( minor compaction status file ) ) || file factory . is file exist ( major compaction status file , file factory . get file type ( major compaction status file ) ) ) { return bool ; } } catch ( io e ) { logger . error ( str + e . get message ( ) ) ; } return bool ; }	check whether the file to indicate the compaction is present or not .
public void add excluded class ( string class name ) { m excluded classes . add ( class name ) ; }	adds a test class to the filter.
public bundle message source ( locale locale ) { messages = resource bundle . get bundle ( base name , locale ) ; }	creates a new message resource , based on the com.
private void create edit panel ( ) { edit panel = new j ( ) ; add ( edit panel , border layout . center ) ; card layout cardlayout = new card layout ( ) ; edit panel . set layout ( cardlayout ) ; if ( colour ramp map != null ) { for ( colour ramp panel interface data : colour ramp map . key set ( ) ) { data . set parent ( this ) ; string key = data . get title ( ) ; edit panel . add ( data . get panel ( ) , key ) ; } } }	creates the edit panel .
public static long atol ( string s ) { int i = num ; while ( i < s . length ( ) && character . is whitespace ( s . char at ( i ) ) ) i ++ ; if ( i < s . length ( ) && s . char at ( i ) == str ) { if ( i + num < s . length ( ) && ( s . char at ( i + num ) == str || s . char at ( i + num ) == str ) ) return parse long ( s . substring ( i + num ) , num ) ; else return parse long ( s , num ) ; } else return parse long ( s , num ) ; }	converts a string of digits ( decimal , octal or hex ) to a long integer.
public object eval ( reader reader , script engine engine ) throws script exception { return engine . eval ( reader ) ; }	evaluate a script using the given scriptengine .
public void class for name ( soot method container , stmt for name invoke stmt ) { set < string > class names = reflection info . class for name class names ( container ) ; if ( class names == null || class names . is empty ( ) ) { register guard ( container , for name invoke stmt , str ) ; } else { for ( string cls name : class names ) { constant for name ( cls name , container , for name invoke stmt ) ; } } }	adds an edge to all class initializers of all possible receivers of class.
private abstract renderer create renderer ( j tabbed pane ) { return has embedded tabs ( ) ? abstract renderer . create embedded renderer ( tabbed pane ) : abstract renderer . create renderer ( tab pane ) ; }	creates the renderer used to lay out and paint the tabs .
public void read map ( input stream input stream , map builder builder ) { try { parse map ( input stream , builder ) ; if ( builder . node refs without defs added ( ) ) log . warning ( str ) ; } catch ( sax e ) { throw new osm runtime exception ( str + str + e . get public id ( ) + str + e . get system id ( ) + str + e . get line number ( ) + str + e . get column number ( ) + str , e ) ; } catch ( sax e ) { throw new osm runtime exception ( str , e ) ; } catch ( io e ) { throw new osm runtime exception ( str , e ) ; } finally { if ( input stream != null ) { try { input stream . close ( ) ; } catch ( io e ) { log . log ( level . severe , str , e ) ; } } } }	reads all data from the specified stream and sends it to the consumer.
private void process comment ( ) { template reader . next character ( ) ; if ( template reader . starts with ( syntax . get document type opening ( ) ) ) { process schema comment ( ) ; return ; } else if ( nested comments ) { process nested comment ( ) ; return ; } while ( template reader . has next character ( ) ) { final char comment character = template reader . next character ( ) ; if ( is comment closing marker ( comment character ) && template reader . has next character ( ) && template reader . peek character ( ) == syntax . get tag closing ( ) ) { template reader . next character ( ) ; break ; } } }	found an open tag starting with comment sign.
private void emit permutations app cache ( tree logger logger , linker context context , artifact set artifacts , string start screen id , offline screen offline screen ) throws unable to complete exception { for ( emitted artifact emitted : artifacts . find ( emitted artifact . class ) ) { if ( emitted . get visibility ( ) == visibility . private ) { continue ; } string path name = emitted . get partial path ( ) ; if ( accept cached resource ( path name ) ) { if ( ! all artifacts . contains ( path name ) ) { cached artifacts . add ( path name ) ; } } } set < artifacts group > key set = artifacts by group . key set ( ) ; for ( artifacts group group : key set ) { set < string > set = artifacts by group . get ( group ) ; set . add all ( cached artifacts ) ; artifacts . add ( create cache manifest ( context , logger , set , group . get group id ( ) , start screen id , offline screen ) ) ; artifacts . add ( create cache manifest loader ( context , logger , group . get group id ( ) , start screen id ) ) ; } }	manifest file manipulation methods.
public license ( final string filename , final string text ) { if ( filename == null ) { throw new null pointer exception ( str ) ; } if ( filename . is empty ( ) ) { throw new illegal argument exception ( str ) ; } this . filename = filename ; if ( text == null ) { throw new null pointer exception ( str ) ; } if ( text . is empty ( ) ) { throw new illegal argument exception ( str ) ; } this . text = text ; }	creates a new license with the given license text .
long calculate mid entry ( long lo val , long hi val , final double dfp , long lo entry , long hi entry ) { final double dhi = ( double ) hi entry ; final double dlo = ( double ) lo entry ; final double dhi val = ( double ) hi val ; final double dlo val = ( double ) lo val ; long mid entry = lo entry + ( long ) ( ( dhi - dlo ) * ( dfp - dlo val ) / ( dhi val - dlo val ) ) ; if ( mid entry == hi entry ) { mid entry -- ; } return mid entry ; }	calculates a mid entry where to divide the interval.
@ suppress warnings ( str ) protected int hash fields ( int hash , map < field descriptor , object > map ) { for ( map . entry < field descriptor , object > entry : map . entry set ( ) ) { field descriptor field = entry . get key ( ) ; object value = entry . get value ( ) ; hash = ( num * hash ) + field . get number ( ) ; if ( field . get type ( ) != field descriptor . type . enum ) { hash = ( num * hash ) + value . hash code ( ) ; } else if ( field . is repeated ( ) ) { list < ? extends enum lite > list = ( list < ? extends enum lite > ) value ; hash = ( num * hash ) + hash enum list ( list ) ; } else { hash = ( num * hash ) + hash enum ( ( enum lite ) value ) ; } } return hash ; }	get a hash code for given fields and values , using the given seed .
public dashboard service helper ( ) { attributes require update . add ( dashboard class name ) ; attributes require update . add ( dashboard name ) ; attributes require update . add ( dashboard display name ) ; attributes require update . add ( dashboard icon ) ; attributes require update . add ( dashboard login ) ; attributes require update . add ( icf identifier ) ; attributes . add all ( attributes require update ) ; }	constructs an instance of the dashboardservicehelper.
public static string java util regex escape ( string s ) { if ( s . index of ( str ) == - num ) { return str + s + str ; } string builder sb = new string builder ( ) ; for ( int i = num ; i < s . length ( ) ; i ++ ) { sb . append ( str ) ; sb . append ( s . char at ( i ) ) ; } return sb . to string ( ) ; }	escapes the special characters from a string so it can be used as part of a regex pattern.
public void forget ffmpeg path ( ) { settings . put ( settings ffmpeg path , ffmpeg path unset ) ; }	makes the library forget about where the ffmpeg binary was located.
@ override public void print warning ( final string message ) { print warning ( message , preference store . get boolean ( ui . console show on new warning ) ) ; }	prints a warning message to the console.
public static string revert new lines ( string string ) { int index ; string buffer new string buffer = new string buffer ( ) ; while ( ( index = string . index of ( str ) ) != - num ) { if ( index > num ) { new string buffer . append ( string . substring ( num , index ) ) ; } new string buffer . append ( str ) ; if ( ( index + num ) < string . length ( ) ) { string = string . substring ( index + num ) ; } else { string = str ; } } new string buffer . append ( string ) ; string = new string buffer . to string ( ) ; new string buffer = new string buffer ( ) ; while ( ( index = string . index of ( str ) ) != - num ) { if ( index > num ) { new string buffer . append ( string . substring ( num , index ) ) ; } new string buffer . append ( str ) ; if ( ( index + num ) < string . length ( ) ) { string = string . substring ( index + num ) ; } else { string = str ; } } new string buffer . append ( string ) ; return new string buffer . to string ( ) ; }	reverts \ r and \ n in a string into carriage returns and new lines .
@ override public void on insert complete ( int task id , object cookie , long insert row id ) { if ( task id == app constants . query tokens . insert wallpost && insert row id != - num ) { logger . i ( tag , str + insert row id ) ; } }	method called when an asynchronous insert operation is done.
protected void parse list ( array list < string > list , string text ) { list . clear ( ) ; string tokenizer st = new string tokenizer ( text , str ) ; while ( st . has more elements ( ) ) { string line = ( string ) st . next element ( ) ; list . add ( line . trim ( ) ) ; } }	create a list of patterns from chunk of text , patterns are separated with newline.
protected list < node > split assignments ( node node ) { if ( node instanceof assignment node ) { list < node > result = new array list < > ( ) ; assignment node a = ( assignment node ) node ; result . add ( a . get target ( ) ) ; result . add all ( split assignments ( a . get expression ( ) ) ) ; return result ; } else { return collections . singleton list ( node ) ; } }	takes a node , and either returns the node itself again ( as a singleton list ) , or if the node is an assignment node , returns the lhs and rhs ( where splitassignments is applied recursively to the rhs ) .
public tree < string > extract best max rule parse ( int start , int end , list < string > sentence ) { return extract best max rule parse1 ( start , end , num , sentence ) ; }	returns the best parse , the one with maximum expected labelled recall.
public static double normalize ( double val , double min , double max ) { if ( max < min ) throw new illegal argument exception ( str ) ; return ( val - min ) / ( max - min ) ; }	normalize a value ( val - min ) / ( max - min ).
private static boolean contains only transient and static fields ( list < field > fields ) { boolean contains normal field = bool ; for ( field field : fields ) { if ( ! modifier . is transient ( field . get modifiers ( ) ) && ! modifier . is static ( field . get modifiers ( ) ) ) { contains normal field = bool ; } } return ! contains normal field ; }	only contains transient or static fields , which is the case for a model that is empty , but says it " implements parcelable ".
@ override public void append index map to ( appendable out , string name , list < source map section > sections ) throws io { out . append ( str ) ; append first field ( out , str , str ) ; append field ( out , str , escape string ( name ) ) ; append field start ( out , str ) ; out . append ( str ) ; boolean first = bool ; for ( source map section section : sections ) { if ( first ) { first = bool ; } else { out . append ( str ) ; } out . append ( str ) ; append first field ( out , str , offset value ( section . get line ( ) , section . get column ( ) ) ) ; if ( section . get section type ( ) == source map section . section type . url ) { append field ( out , str , escape string ( section . get section value ( ) ) ) ; } else if ( section . get section type ( ) == source map section . section type . map ) { append field ( out , str , section . get section value ( ) ) ; } else { throw new io ( str ) ; } out . append ( str ) ; } out . append ( str ) ; append field end ( out ) ; out . append ( str ) ; }	appends the index source map to the given buffer .
public builder add part ( part part ) { if ( part == null ) throw new null pointer exception ( str ) ; parts . add ( part ) ; return this ; }	add a part to the body .
protected void notify gone ( l locator ) { synchronized ( this ) { if ( ! stale locators . add ( locator . get partition id ( ) ) ) { fail ( str + locator ) ; } } }	notify the data service that an index partition is no longer located on that data service .
@ override public void add vetoable change listener ( string name , vetoable change listener vcl ) { m bc support . add vetoable change listener ( name , vcl ) ; }	add a vetoable change listener to this bean.
public string build user ( ) { return properties . get property ( str ) ; }	returns the username of the user that created this build .
private void update idle expire time ( long now ) { thread idle expire time . set ( now + idle timeout ) ; }	updates the thread idle expire time .
protected ct class create ct class ( string classname , boolean use cache ) { if ( classname . char at ( num ) == str ) classname = descriptor . to class name ( classname ) ; if ( classname . ends with ( str ) ) { string base = classname . substring ( num , classname . index of ( str ) ) ; if ( ( ! use cache || get cached ( base ) == null ) && find ( base ) == null ) return null ; else return new ct array ( classname , this ) ; } else if ( find ( classname ) == null ) return null ; else return new ct class type ( classname , this ) ; }	creates a ctclass object representing the specified class.
@ transactional public long create voucher from bill ( final int bill id ) throws application runtime exception { try { string voucher status = null ; final list v status list = app config values service . get config values by module and key ( str , str ) ; if ( ! v status list . is empty ( ) && v status list . size ( ) == num ) { final app config values app val = ( app config values ) v status list . get ( num ) ; voucher status = app val . get value ( ) ; } else throw new application runtime exception ( str + missingmsg ) ; final long vh = create voucher . create voucher from bill ( bill id , voucher status , null , null ) ; return vh ; } catch ( final exception e ) { logger . error ( e . get message ( ) ) ; throw new application runtime exception ( e . get message ( ) ) ; } }	api to create voucher from bill with normal flow.
public static float compare equivalance ( bitmap bitmap1 , bitmap bitmap2 ) { if ( bitmap1 == null || bitmap2 == null || bitmap1 . get width ( ) != bitmap2 . get width ( ) || bitmap1 . get height ( ) != bitmap2 . get height ( ) ) { return num ; } byte buffer buffer1 = byte buffer . allocate ( bitmap1 . get height ( ) * bitmap1 . get row bytes ( ) ) ; bitmap1 . copy pixels to buffer ( buffer1 ) ; byte buffer buffer2 = byte buffer . allocate ( bitmap2 . get height ( ) * bitmap2 . get row bytes ( ) ) ; bitmap2 . copy pixels to buffer ( buffer2 ) ; byte [ ] array1 = buffer1 . array ( ) ; byte [ ] array2 = buffer2 . array ( ) ; int len = array1 . length ; int count = num ; for ( int i = num ; i < len ; i ++ ) { if ( array1 [ i ] == array2 [ i ] ) { count ++ ; } } return ( ( float ) ( count ) ) / len ; }	compares two bitmaps and gives the percentage of similarity.
public void handle tbl charset alias href action request ( request invocation event event ) throws model control exception { try { map values = get values ( ) ; on before save profile ( values ) ; set page session attribute ( property attribute , ( hash map ) values ) ; n vb = ( n ) get view bean ( n . class ) ; unlock page trail ( ) ; pass pg session map ( vb ) ; vb . populate values ( ( string ) get display field value ( str ) ) ; vb . forward to ( get request context ( ) ) ; } catch ( am e ) { set inline alert message ( cc . type error , str , e . get message ( ) ) ; } }	handles edit charset alias request .
public boolean glass gene im ( boolean glass gene pm gene pm , parameters parameters ) { try { this . gene pm = gene pm ; this . glass function = new boolean glass function ( gene pm . get lag graph ( ) ) ; this . initializer = new basal initializer ( glass function , num , num ) ; this . history = new gene history ( initializer , glass function ) ; this . simulator = new measurement simulator params ( parameters ) ; } catch ( exception e ) { e . print stack trace ( ) ; } }	obtains a boolean glass function from the boolean glass gene pm provided and uses it to create a glass history and a measurement simulator.
protected list < item type > select fold train items ( list < item type > items , int n folds , int fold ) { list < item type > train items = new array list < item type > ( ) ; for ( int i = num ; i < items . size ( ) ; ++ i ) { if ( i % n folds != fold ) { train items . add ( items . get ( i ) ) ; } } return train items ; }	determines which items should be used for training in one fold of a cross - validation.
protected void rehash ( int new capacity ) { int old capacity = set . length ; k old keys [ ] = ( k [ ] ) set ; short old vals [ ] = values ; set = new object [ new capacity ] ; arrays . fill ( set , free ) ; values = new short [ new capacity ] ; for ( int i = old capacity ; i -- > num ; ) { if ( old keys [ i ] != free && old keys [ i ] != removed ) { k o = old keys [ i ] ; int index = insertion index ( o ) ; if ( index < num ) { throw object contract violation ( set [ ( - index - num ) ] , o ) ; } set [ index ] = o ; values [ index ] = old vals [ i ] ; } } }	rehashes the map to the new capacity .
protected void add attributes ( element element , attributes attributes ) { boolean no namespace attributes = bool ; if ( element instanceof abstract element ) { abstract element base element = ( abstract element ) element ; base element . set attributes ( attributes , namespace stack , no namespace attributes ) ; } else { int size = attributes . get length ( ) ; for ( int i = num ; i < size ; i ++ ) { string attribute q = attributes . get q ( i ) ; if ( no namespace attributes || ! attribute q . starts with ( str ) ) { string attribute uri = attributes . get uri ( i ) ; string attribute local name = attributes . get local name ( i ) ; string attribute value = attributes . get value ( i ) ; q q name = namespace stack . get attribute q ( attribute uri , attribute local name , attribute q ) ; element . add attribute ( q name , attribute value ) ; } } } }	add all the attributes to the given elements.
public static < t > boolean remove ( collection < t > collection , t element ) { if ( element == null ) { return bool ; } if ( collection utils . is empty ( collection ) ) { return bool ; } return collection . remove ( element ) ; }	safe method to remove an element from collection.
private static void persist updated vpool list ( list < virtual pool > updated vpool list , db client db client ) { if ( ! updated vpool list . is empty ( ) ) { db client . update and reindex object ( updated vpool list ) ; } }	persist all the virtualpool which are updated with matched pools .
void compose templates ( elem template element templ ) throws transformer exception { templ . compose ( this ) ; for ( elem template element child = templ . get first child elem ( ) ; child != null ; child = child . get next sibling elem ( ) ) { compose templates ( child ) ; } templ . end compose ( this ) ; }	call the compose function for each elemtemplateelement .
public static boolean class exists ( string class name ) { try { return class . for name ( class name ) != null ; } catch ( class not found exception e ) { return bool ; } }	helper method to safely check whether a class exists at runtime .
public static void create top level classes xml ( string output dir , string templates path , boolean lenient ) throws compiler exception { try { as doc helper as doc help = new as doc helper ( output dir + str , output dir + str , output dir , output dir + str + file . separator + str ) ; as doc help . create top level classes ( lenient ) ; } catch ( throwable t ) { t . print stack trace ( ) ; compiler message c = new could not create ( str , t . get message ( ) ) ; thread local toolkit . log ( c ) ; throw c ; } }	this method is called to kick off the dita generation process.
void draw shape ( graphics g , css . value type , int ax , int ay , int aw , int ah , float align ) { int gap = is left to right ? - ( bulletgap + num ) : ( aw + bulletgap ) ; int x = ax + gap ; int y = math . max ( ay , ay + ( int ) ( align * ah ) - num ) ; if ( type == css . value . square ) { g . draw rect ( x , y , num , num ) ; } else if ( type == css . value . circle ) { g . draw oval ( x , y , num , num ) ; } else { g . fill oval ( x , y , num , num ) ; } }	draws the graphical bullet item specified by the type argument .
public static void restore ( final context context ) { shared preferences prefs = preference manager . get default shared preferences ( context ) ; if ( long term orbits . is supported ( ) && prefs . get boolean ( key location toggle , bool ) ) { save download data wifi only pref ( context ) ; alarm manager am = ( alarm manager ) context . get system service ( context . alarm service ) ; intent intent = new intent ( context , lto service . class ) ; pending intent pi = pending intent . get service ( context , num , intent , pending intent . flag update current | pending intent . flag one shot ) ; long next lto download = system . current time millis ( ) + ( num * num * num ) ; am . set ( alarm manager . rtc , next lto download , pi ) ; } }	restore the properties associated with this preference on boot.
private void generate file ( int word cnt ) throws exception { random rnd = new random ( system . current time millis ( ) ) ; try ( output stream writer writer = new output stream writer ( igfs . create ( file , bool ) ) ) { int cnt = num ; while ( cnt < word cnt ) { string word = dictionary [ rnd . next int ( dictionary . length ) ] ; writer . write ( word + str ) ; cnt ++ ; } } }	generate file with random data and provided argument .
public void polygon ( double [ ] x , double [ ] y ) { int n = x . length ; general path path = new general path ( ) ; path . move to ( ( float ) scale x ( x [ num ] ) , ( float ) scale y ( y [ num ] ) ) ; for ( int i = num ; i < n ; i ++ ) path . line to ( ( float ) scale x ( x [ i ] ) , ( float ) scale y ( y [ i ] ) ) ; path . close path ( ) ; offscreen . draw ( path ) ; draw ( ) ; }	draws a polygon with the given ( x [ i ] , y [ i ] ) coordinates .
public void append ( int key , e value ) { if ( m size != num && key <= m keys [ m size - num ] ) { put ( key , value ) ; return ; } if ( m garbage && m size >= m keys . length ) { gc ( ) ; } int pos = m size ; if ( pos >= m keys . length ) { int n = container helpers . ideal int array size ( pos + num ) ; int [ ] nkeys = new int [ n ] ; object [ ] nvalues = new object [ n ] ; system . arraycopy ( m keys , num , nkeys , num , m keys . length ) ; system . arraycopy ( m values , num , nvalues , num , m values . length ) ; m keys = nkeys ; m values = nvalues ; } m keys [ pos ] = key ; m values [ pos ] = value ; m size = pos + num ; }	puts a key / value pair into the array , optimizing for the case where the key is greater than all existing keys in the array .
public list < search result > search by object name ( string name ) { list < search result > all = new array list < > ( ) ; for ( layer layer : layers ) { if ( is layer visible ( layer ) ) { all . add all ( layer . search by object name ( name ) ) ; } } log . d ( tag , str + all . size ( ) + str + name ) ; return all ; }	search all visible layers for an object with the given name .
private void clear messages ( ) { messages . clear ( ) ; }	clear the current list of pending messages.
public void clear text edits ( ) { f edits . clear ( ) ; }	removes all text edits from this group .
public static void main ( string [ ] args ) { frame frame = new packet tool ( ) ; frame . pack ( ) ; frame . set location relative to ( null ) ; frame . set visible ( bool ) ; }	display a window for testing the transmission of boards .
private void create tool bar ( ) { tool bar = new j ( str ) ; if ( listener . running as j || listener . running as visual vm ) { tool bar . add ( create tool bar button ( str , str ) ) ; tool bar . set floatable ( bool ) ; } else { tool bar . add ( create tool bar button ( str , str ) ) ; close tool bar button = create tool bar button ( str , str ) ; close tool bar button . set enabled ( bool ) ; tool bar . add ( close tool bar button ) ; } tool bar . add separator ( ) ; tool bar . add ( create tool bar button ( str , str ) ) ; tool bar . add separator ( ) ; expand button = create tool bar button ( str , str ) ; expand button . set enabled ( bool ) ; tool bar . add ( expand button ) ; collapse button = create tool bar button ( str , str ) ; collapse button . set enabled ( bool ) ; tool bar . add ( collapse button ) ; tool bar . add separator ( ) ; find lr = create tool bar button ( str , str ) ; find lr . set enabled ( bool ) ; tool bar . add ( find lr ) ; tool bar . add ( create tool bar button ( str , str ) ) ; tool bar . add ( create tool bar button ( str , str ) ) ; tool bar . add separator ( ) ; }	create a toolbar showing the most important main menu entries .
public static map attr set to map ( attr set attr set , boolean fetch byte values ) { map attributes map = new am ( fetch byte values ) ; if ( attr set == null ) { return attributes map ; } int attr set size = attr set . size ( ) ; if ( ! fetch byte values ) { for ( int i = num ; i < attr set size ; i ++ ) { attr attr = attr set . element at ( i ) ; string values [ ] = attr . get string values ( ) ; attributes map . put ( attr . get name ( ) , string array to set ( values ) ) ; } } else { for ( int i = num ; i < attr set size ; i ++ ) { attr attr = attr set . element at ( i ) ; attributes map . put ( attr . get name ( ) , attr . get byte values ( ) ) ; } } return attributes map ; }	method to convert a attrset object to map .
public final iterator < string > schemes iterator ( ) { return m data schemes != null ? m data schemes . iterator ( ) : null ; }	return an iterator over the filter ' s data schemes .
public static void reinit recompiler ( ) { rewriter . set ( new program rewriter ( bool , bool ) ) ; }	re - initializes the recompiler according to the current optimizer flags .
default value remove ( optional < ? extends char sequence > name ) { return name . is present ( ) ? remove ( name . get ( ) ) : null ; }	if the supplied name is provided , then remove the field with the supplied name and return the value .
private string next to internal ( string excluded ) { int start = pos ; for ( ; pos < in . length ( ) ; pos ++ ) { char c = in . char at ( pos ) ; if ( c == str || c == str || excluded . index of ( c ) != - num ) { return in . substring ( start , pos ) ; } } return in . substring ( start ) ; }	returns the string up to but not including any of the given characters or a newline character.
accept tcp ( port tcp port , server socket bar server socket ) { objects . require non null ( port ) ; objects . require non null ( server socket ) ; port = port ; server socket = server socket ; }	creates a new accept thread.
private static void update grabbed cursor ( cursor cur ) { x target = x . get grab window ( ) ; if ( target instanceof x ) { x grabber = ( x ) target ; grabber . p set cursor ( cur ) ; } }	updates cursor on the grabber if it is window peer ( i.
protected void parse uri ( string uri string ) throws uri { string s = uri string ; int index = s . index of ( fragment separator ) ; if ( index != - num ) { set fragment ( s . substring ( index + num ) , bool ) ; s = s . substring ( num , index ) ; } index = s . index of ( scheme separator ) ; if ( index != - num ) { string scheme = s . substring ( num , index ) ; if ( is valid scheme ( scheme ) ) { set scheme ( scheme ) ; s = s . substring ( index + num ) ; } } parse scheme specific part ( s , bool ) ; }	rather than attempting to process the uri string in a linear fashion , this implementation works its way from outside - in.
@ override public boolean equals ( object obj ) { if ( ( obj instanceof keep alive key ) == bool ) return bool ; keep alive key kae = ( keep alive key ) obj ; return host . equals ( kae . host ) && ( port == kae . port ) && protocol . equals ( kae . protocol ) && this . obj == kae . obj ; }	determine whether or not two objects of this type are equal.
protected static void append long string type ( string builder sb ) { sb . append ( str ) ; }	output the sql type for a java long string .
public void test connect headset ( ) { int iterations = bluetooth test runner . s connect headset iterations ; if ( iterations == num ) { return ; } bluetooth adapter adapter = bluetooth adapter . get default adapter ( ) ; bluetooth device device = adapter . get remote device ( bluetooth test runner . s device address ) ; m test utils . disable ( adapter ) ; m test utils . enable ( adapter ) ; m test utils . unpair ( adapter , device ) ; m test utils . pair ( adapter , device , bluetooth test runner . s device pair passkey , bluetooth test runner . s device pair pin ) ; m test utils . disconnect profile ( adapter , device , bluetooth profile . headset , null ) ; for ( int i = num ; i < iterations ; i ++ ) { m test utils . write output ( str + ( i + num ) + str + iterations ) ; m test utils . connect profile ( adapter , device , bluetooth profile . headset , string . format ( str , device ) ) ; m test utils . disconnect profile ( adapter , device , bluetooth profile . headset , string . format ( str , device ) ) ; } m test utils . unpair ( adapter , device ) ; m test utils . disable ( adapter ) ; }	stress test for connecting and disconnecting the hfp with a hands free device.
public static boolean is na ( string [ ] n , string w ) { if ( n == null ) return bool ; for ( string na : n ) { if ( w . equals ( na ) ) return bool ; } return bool ; }	function that checks if the given string is one of na strings .
private double [ ] evaluate probability ( double [ ] data ) { double [ ] prob = new double [ m ] , v = new double [ m ] ; for ( int j = num ; j < m - num ; j ++ ) { for ( int k = num ; k <= m ; k ++ ) { v [ j ] += m [ k ] [ j ] * data [ k ] ; } } v [ m - num ] = num ; for ( int m = num ; m < m ; m ++ ) { double sum = num ; for ( int n = num ; n < m - num ; n ++ ) { sum += math . exp ( v [ n ] - v [ m ] ) ; } prob [ m ] = num / ( sum + math . exp ( - v [ m ] ) ) ; } return prob ; }	compute the posterior distribution using optimized parameter values and the testing instance .
public static final hash map read map xml ( input stream in ) throws xml pull parser exception , io { xml pull parser parser = xml . new pull parser ( ) ; parser . set input ( in , null ) ; return ( hash map ) read value xml ( parser , new string [ num ] ) ; }	read a hashmap from an inputstream containing xml.
protected void modify om ( ) { }	a convenience method that gives an editableomgraphic a chance to modify the omgraphic so it can be drawn quickly , by turning off labels , etc , right before the xorpainting happens.
public observable < drive id > create file ( drive folder folder , file file , string title ) { return create file ( folder , file , title , mime type map . get file extension from url ( file . get path ( ) ) ) ; }	creates a file on drive.
public static string extract collection from path ( string path ) { string extracted collection name = null ; string path modified = remove from end of string ( path , slash ) ; string [ ] path segments = path modified . split ( str ) ; if ( path segments . length > num ) { extracted collection name = path segments [ path segments . length - num ] ; } return extracted collection name ; }	extracts the collection name from the given path . the collection name is known to be the last segment of the path.
public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add all ( collections . list ( super . list options ( ) ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public boolean is private ( ) { return modifier . is private ( field . get modifiers ( ) ) ; }	returns true for a private field .
public static final long long encode ( final string hash ) { int level = hash . length ( ) - num ; long b ; long l = num ; for ( char c : hash . to char array ( ) ) { b = ( long ) ( base 32 string . index of ( c ) ) ; l |= ( b << ( level -- * num ) ) ; } return ( l << num ) | hash . length ( ) ; }	encode from geohash string to the geohash based long format ( lon / lat interleaved , 4 least significant bits = level ).
@ override public void on success ( t result ) { try { logger . debug ( str , result ) ; queue . put ( result ) ; } catch ( interrupted exception e ) { logger . warn ( str , e ) ; } }	on success we add the result to our blocking queue.
public void handle tbl provider resource id mapper button add request ( request invocation event event ) throws model control exception { try { map values = get values ( ) ; on before save profile ( values ) ; set page session attribute ( property attribute , ( hash map ) values ) ; sm vb = ( sm ) get view bean ( sm . class ) ; remove page session attribute ( sm . property attribute ) ; unlock page trail ( ) ; pass pg session map ( vb ) ; vb . forward to ( get request context ( ) ) ; } catch ( am e ) { set inline alert message ( cc . type error , str , e . get message ( ) ) ; } }	handles add provider resource id mapper request .
public c ( final c parent , final i container , final i function ) { super ( string . format ( str , function . get name ( ) ) ) ; m parent = parent ; m container = container ; m function = function ; }	creates a new action object .
public int read ( char [ ] buffer , int offset , int length ) throws io { byte [ ] bytes = new byte [ length ] ; int count = file . read ( bytes , num , length ) ; for ( int i = num ; i < count ; i ++ ) { buffer [ offset + i ] = ( char ) bytes [ i ] ; } return count ; }	reads a block starting from the current file pointer .
public boolean equals ( object o ) { if ( ! ( o instanceof vector2f ) ) { return bool ; } if ( this == o ) { return bool ; } vector2f comp = ( vector2f ) o ; if ( float . compare ( x , comp . x ) != num ) { return bool ; } if ( float . compare ( y , comp . y ) != num ) { return bool ; } return bool ; }	are these two vectors the same ? they are is they both have the same x and y values .
@ override protected e find instantiable compatible ( e e type ) { if ( ! is instantiatable sub type ( e type , e type ) ) { throw new illegal state exception ( string . value of ( e type ) ) ; } return e type ; }	later here have to be checked the inheritance hierarchy , too.
private int measure width ( int measure spec ) { int result = num ; int spec mode = measure spec . get mode ( measure spec ) ; int spec size = measure spec . get size ( measure spec ) ; if ( spec mode == measure spec . exactly ) { result = spec size ; } else { result = image width + max text width + toast height ; if ( spec mode == measure spec . at most ) { result = math . min ( result , spec size ) ; } } return result ; }	determines the width of this view.
public void restore topology ( iterable < tcp discovery node > nodes , long top ver ) { assert ! f . is empty ( nodes ) ; assert top ver > num ; rw lock . write lock ( ) . lock ( ) ; try { loc node . internal order ( top ver ) ; clear ( ) ; boolean first add = bool ; for ( tcp discovery node node : nodes ) { if ( nodes map . contains key ( node . id ( ) ) ) continue ; nodes map . put ( node . id ( ) , node ) ; if ( first add ) { this . nodes = new tree set < > ( this . nodes ) ; first add = bool ; } node . last update time ( u . current time millis ( ) ) ; this . nodes . add ( node ) ; } node order = top ver ; initialize minimum version ( ) ; } finally { rw lock . write lock ( ) . unlock ( ) ; } }	restores topology from parameters values.
final protected void start op ( final i msg ) { if ( ! controller ) throw new unsupported operation exception ( err not controller ) ; if ( msg == null ) throw new illegal argument exception ( ) ; if ( ! query id . equals ( msg . get query id ( ) ) ) throw new illegal argument exception ( ) ; lock . lock ( ) ; try { if ( log . is trace enabled ( ) ) log . trace ( msg . to string ( ) ) ; if ( future . is done ( ) ) throw new runtime exception ( str ) ; run state . start op ( msg ) ; } catch ( timeout exception ex ) { halt ( ex ) ; } finally { lock . unlock ( ) ; } }	message provides notice that the operator has started execution and will consume some specific number of binding set chunks .
public flux < in > drain ( ) { return flux . empty ( ) ; }	drain is a hot replication of the current buffer delivered if supported.
int traverse consistency check ( text edit processor processor , document document , list < list < text edit > > source edits ) { int result = num ; if ( f children != null ) { for ( int i = f children . size ( ) - num ; i >= num ; i -- ) { text edit child = ( text edit ) f children . get ( i ) ; result = math . max ( result , child . traverse consistency check ( processor , document , source edits ) ) ; } } if ( processor . consider edit ( this ) ) { perform consistency check ( processor , document ) ; } return result ; }	traverses the edit tree to perform the consistency check .
public minute ( date time , time zone zone ) { this ( time , zone , locale . get default ( ) ) ; }	constructs a new minute , based on the supplied date / time and timezone .
private plan build plan1 ( ) { plan plan = population utils . create plan ( ) ; activity a = population utils . create activity from coord ( str , coord utils . create coord ( num , num ) ) ; a . set end time ( time . parse time ( str ) ) ; plan . add activity ( a ) ; plan . add leg ( population utils . create leg ( str ) ) ; double travel time = time . parse time ( str ) ; double distance = math . round ( ( travel time * chain chopper . average speed ) / chain chopper . crowfly factor ) ; activity b = population utils . create activity from coord ( str , coord utils . create coord ( distance , num ) ) ; plan . add activity ( b ) ; return plan ; }	a test plan for which the 24 - hour cut is along the journey . 16 : 00 | 08 : 00 a - - - | - - - > b | 24 : 00.
protected void encode atom ( output stream out stream , byte data [ ] , int offset , int len ) throws io { byte a , b = num , c = num ; int c1 , c2 , c3 , c4 ; a = data [ offset ] ; if ( len > num ) { b = data [ offset + num ] ; } if ( len > num ) { c = data [ offset + num ] ; } c1 = ( a > > > num ) & num ; c2 = ( ( a << num ) & num ) | ( ( b > > > num ) & num ) ; c3 = ( ( b << num ) & num ) | ( ( c > > > num ) & num ) ; c4 = c & num ; out stream . write ( c1 + str ) ; out stream . write ( c2 + str ) ; out stream . write ( c3 + str ) ; out stream . write ( c4 + str ) ; return ; }	encodeatom - take three bytes and encodes them into 4 characters if len is less than 3 then remaining bytes are filled with ' 1 '.
public void test unwrap 05 ( ) { string host = str ; int port = num ; byte buffer bbs = byte buffer . allocate ( num ) ; byte buffer bbd = byte buffer . allocate ( num ) ; ssl sse = get engine ( host , port ) ; sse . set use client mode ( bool ) ; try { ssl res = sse . unwrap ( bbs , bbd ) ; assert equals ( num , res . bytes consumed ( ) ) ; assert equals ( num , res . bytes produced ( ) ) ; } catch ( exception e ) { fail ( str + e ) ; } }	javax . net . ssl . sslengine # unwrap ( bytebuffer src , bytebuffer dst ).
private int adjust alpha ( int color , float factor ) { int alpha = math . round ( color . alpha ( color ) * factor ) ; int red = color . red ( color ) ; int green = color . green ( color ) ; int blue = color . blue ( color ) ; return color . argb ( alpha , red , green , blue ) ; }	transparent the given color by the factor the more the factor closer to zero the more the color gets transparent.
private void initialize ratio slider ( ) { ratio slider . set major tick spacing ( num ) ; ratio slider . set minor tick spacing ( num ) ; ratio slider . set paint ticks ( bool ) ; hashtable < integer , j > label table = new hashtable < integer , j > ( ) ; label table . put ( new integer ( num ) , new j ( str ) ) ; label table . put ( new integer ( num ) , new j ( str ) ) ; label table . put ( new integer ( num ) , new j ( str ) ) ; label table . put ( new integer ( num ) , new j ( str ) ) ; label table . put ( new integer ( num ) , new j ( str ) ) ; ratio slider . set label table ( label table ) ; ratio slider . set paint labels ( bool ) ; }	initializes the values of the gui ratio slider .
private static void initialize settings ( settings . builder output , settings input , boolean load defaults ) { output . put ( input ) ; if ( use system properties ( input ) ) { if ( load defaults ) { for ( string prefix : property defaults prefixes ) { output . put properties ( prefix , system . get properties ( ) ) ; } } for ( string prefix : property prefixes ) { output . put properties ( prefix , system . get properties ( ) , property defaults prefixes ) ; } } output . replace property placeholders ( ) ; }	initializes the builder with the given input settings , and loads system properties settings if allowed.
@ override public void draw oval ( int x , int y , int width , int height ) { set state to local ( ) ; m printstream . println ( x transform ( x scale ( x ) ) + str + y transform ( y scale ( y ) ) + str + x scale ( width ) + str + y scale ( height ) + str ) ; }	draw an oval outline in current pen color .
public string to string ( int indent factor ) throws json { return to string ( indent factor , num ) ; }	make a prettyprinted json text of this jsonobject.
private void validate sql ( ) { boolean flag = controller . is enable sql ( ) ; enable sql . set selected ( flag ) ; sql host label . set enabled ( flag ) ; sql host field . set enabled ( flag ) ; sql database label . set enabled ( flag ) ; sql database field . set enabled ( flag ) ; sql user label . set enabled ( flag ) ; sql user field . set enabled ( flag ) ; sql password label . set enabled ( flag ) ; sql password field . set enabled ( flag ) ; enable zip encoding check box . set enabled ( flag ) ; }	validates the uncompressed settings .
public void read from object ( object object ) { try { method method = bean utils . get read method ( object . get class ( ) , get name ( ) ) ; if ( method != null ) { object value = method . invoke ( object , null ) ; initialize value ( value ) ; if ( value != null ) { for ( iterator iter = sub properties . iterator ( ) ; iter . has next ( ) ; ) { property sub property = ( property ) iter . next ( ) ; sub property . read from object ( value ) ; } } } } catch ( exception e ) { throw new runtime exception ( e ) ; } }	reads the value of this property from the given object.
private boolean internal offer task ( a task ) { synchronized ( m frame task queue ) { return m frame task queue . offer ( task ) ; } }	adds a task to the frame task queue .
public static string to string ( byte buffer bb ) { byte [ ] bytes = new byte [ bb . get int ( ) ] ; string s = str ; try { if ( array utils . is not empty ( bytes ) ) { bb . get ( bytes ) ; s = new string ( bytes , ut ) ; } } catch ( exception e ) { throw new runtime exception ( str + str , e ) ; } return s ; }	this assumes the next position is the size as an int , and the following is a string if the size is not zero .
public static boolean valid image ( image image ) { return ( image != null && image . get width ( null ) > num && image . get height ( null ) > num ) ; }	convenience method for testing the validity of an image .
private image size compute size to fit ( float max side ) { if ( num == max side ) { return new image size ( num , num ) ; } image size resized = new image size ( this ) ; if ( ( this . m width > max side ) || ( this . m height > max side ) ) { double ratio x = max side / this . m width ; double ratio y = max side / this . m height ; double scale = math . min ( ratio x , ratio y ) ; scale = num / integer . highest one bit ( ( int ) math . floor ( num / scale ) ) ; resized . m width = ( int ) ( math . floor ( resized . m width * scale / num ) * num ) ; resized . m height = ( int ) ( math . floor ( resized . m height * scale / num ) * num ) ; } return resized ; }	compute the image size to fit in a square .
public static list < big integer > embedded selector to partitions ( string selector , string type , data partitioner partitioner ) throws pir { list < big integer > parts ; int partition bits = partitioner . get bits ( type ) ; if ( partition bits > num ) { int hashed selector = keyed hash . hash ( str , num , selector , str ) ; parts = partitioner . to partitions ( hashed selector , primitive type partitioner . int ) ; } else { parts = partitioner . to partitions ( selector , type ) ; } return parts ; }	method to convert the given selector into the extracted biginteger partitions.
public static double stddevp ( double [ ] a , int lo , int hi ) { return math . sqrt ( varp ( a , lo , hi ) ) ; }	returns the population standard deviation in the specified subarray .
public void maybe look ahead scripts ( ) { }	housekeeping call to call when lookahead might be needed.
public java2 type script translator ( transpilation handler log handler , j context , jc compilation unit , boolean preserve source line numbers ) { super ( log handler , context , compilation unit , new java2 type script adapter ( context ) , preserve source line numbers ) ; }	creates a new typescript translator .
@ override protected void on measure ( int width measure spec , int height measure spec ) { int count = get child count ( ) ; m left width = num ; m right width = num ; int max height = num ; int max width = num ; int child state = num ; for ( int i = num ; i < count ; i ++ ) { final view child = get child at ( i ) ; if ( child . get visibility ( ) != gone ) { measure child with margins ( child , width measure spec , num , height measure spec , num ) ; final layout params lp = ( layout params ) child . get layout params ( ) ; if ( lp . position == layout params . position left ) { m left width += math . max ( max width , child . get measured width ( ) + lp . left margin + lp . right margin ) ; } else if ( lp . position == layout params . position right ) { m right width += math . max ( max width , child . get measured width ( ) + lp . left margin + lp . right margin ) ; } else { max width = math . max ( max width , child . get measured width ( ) + lp . left margin + lp . right margin ) ; } max height = math . max ( max height , child . get measured height ( ) + lp . top margin + lp . bottom margin ) ; child state = combine measured states ( child state , child . get measured state ( ) ) ; } } max width += m left width + m right width ; max height = math . max ( max height , get suggested minimum height ( ) ) ; max width = math . max ( max width , get suggested minimum width ( ) ) ; set measured dimension ( resolve size and state ( max width , width measure spec , child state ) , resolve size and state ( max height , height measure spec , child state << measured height state shift ) ) ; }	ask all children to measure themselves and compute the measurement of this layout based on the children .
protected int exec ( string command , string list args ) { try { print ( command ) ; string list cmd = new string list ( ) ; cmd = cmd . plus ( command ) ; if ( args != null ) { for ( string a : args ) { print ( str + a ) ; } cmd . add all ( args ) ; } println ( str ) ; process builder pb = new process builder ( ) ; pb . command ( cmd . array ( ) ) ; pb . redirect error stream ( bool ) ; process p = pb . start ( ) ; copy in thread ( p . get input stream ( ) , quiet ? null : sys out ) ; p . wait for ( ) ; return p . exit value ( ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } }	execute a program in a separate process .
@ ignore @ test public void test gateway sender event listener invocation without locator ( ) { int m port = available port helper . get random available port for d ( ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; vm6 . invoke ( null ) ; vm7 . invoke ( null ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; start sender in v ( str , vm4 , vm5 ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; vm6 . invoke ( null ) ; vm7 . invoke ( null ) ; final map key values = new hash map ( ) ; for ( int i = num ; i < num ; i ++ ) { key values . put ( i , i ) ; } vm4 . invoke ( null ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; fail ( str ) ; }	test validates whether the listener attached receives all the events.
protected application user build user ( map < string , string > header map , boolean include roles ) { logger . debug ( str ) ; map < string , string > header names = get header names ( ) ; application user application user = create new application user ( ) ; build user id ( application user , header map , header names . get ( http header user id ) ) ; build first name ( application user , header map , header names . get ( http header first name ) ) ; build last name ( application user , header map , header names . get ( http header last name ) ) ; build email ( application user , header map , header names . get ( http header email ) ) ; build session id ( application user , header map , http header session id ) ; build session init time ( application user , header map , header names . get ( http header session init time ) ) ; user namespace authorization helper . build namespace authorizations ( application user ) ; if ( include roles ) { build roles ( application user , header map , header names . get ( http header roles ) ) ; } logger . debug ( str + application user ) ; return application user ; }	builds the application user from the header map .
@ interruptible public static void harness end ( ) { stats . stop all ( ) ; inside harness = bool ; }	generic hook to allow benchmarks to be harnessed.
public gui ( string app name ) { ui . put ( str , boolean . false ) ; j f = new j ( app name ) ; f . set default close operation ( j . exit on close ) ; f . set layout ( new border layout ( ) ) ; track = new track view ( ) ; f . add ( track , border layout . center ) ; control panel = new race control panel ( ) ; f . add ( control panel , border layout . south ) ; f . pack ( ) ; f . set visible ( bool ) ; }	creates a new instance of racegui.
public static iterable < string > to hex strings ( iterable < byte array > arrays ) { array list < string > ret = new array list < string > ( ) ; for ( byte array array : arrays ) ret . add ( hex string . to hex string ( array . get ( ) ) ) ; return ret ; }	translate the each bytearray in an iterable into a hexidecimal string.
public void clear ( ) { documents . clear ( ) ; fire mru ( ) ; }	clears the list of documents mru.
public boolean is directly control dependent on ( basic block ins block , branch b ) { set < control flow edge > incomming = incoming edges of ( ins block ) ; if ( incomming . size ( ) == num ) { for ( control flow edge e : incomming ) { if ( ! e . has control dependency ( ) && ! e . is exception edge ( ) ) { return is directly control dependent on ( get edge source ( e ) , b ) ; } } } boolean is root dependent = is root dependent ( ins block ) ; if ( b == null ) return is root dependent ; if ( is root dependent && b != null ) return bool ; for ( control flow edge e : incomming ) { branch current = e . get branch instruction ( ) ; if ( e . is exception edge ( ) ) { if ( current != null ) throw new illegal state exception ( str ) ; else continue ; } if ( current == null ) continue ; if ( current . equals ( b ) ) return bool ; } return bool ; }	determines whether the given basicblock is directly control dependent on the given branch.
final boolean try read lock ( ) { thread current = thread . current thread ( ) ; for ( ; ; ) { int c = get state ( ) ; if ( exclusive count ( c ) != num && get exclusive owner thread ( ) != current ) return bool ; int r = shared count ( c ) ; if ( r == max count ) throw new error ( str ) ; if ( compare and set state ( c , c + shared unit ) ) { if ( r == num ) { first reader = current ; first reader hold count = num ; } else if ( first reader == current ) { first reader hold count ++ ; } else { hold counter rh = cached hold counter ; if ( rh == null || rh . tid != current . get id ( ) ) cached hold counter = rh = read holds . get ( ) ; else if ( rh . count == num ) read holds . set ( rh ) ; rh . count ++ ; } return bool ; } } }	performs trylock for read , enabling barging in both modes.
public void serialize form def ( form def fd , string filepath ) { string hash = file utils . get md5 hash ( new file ( filepath ) ) ; file form def = new file ( collect . cache path + file . separator + hash + str ) ; if ( ! form def . exists ( ) ) { file output stream fos ; try { fos = new file output stream ( form def ) ; data output stream dos = new data output stream ( fos ) ; fd . write external ( dos ) ; dos . flush ( ) ; dos . close ( ) ; } catch ( file not found exception e ) { e . print stack trace ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } } }	write the formdef to the file system as a binary blog .
private void paint route ( d graphics , jx viewer , plottable entity entity ) { set < plottable > plottables = entity . get plottables ( ) ; if ( plottables . size ( ) > num ) { graphics . set color ( color . black ) ; graphics . set stroke ( new basic stroke ( num ) ) ; draw route ( plottables , graphics , viewer ) ; graphics . set color ( entity . get color ( ) ) ; graphics . set stroke ( new basic stroke ( num ) ) ; draw route ( plottables , graphics , viewer ) ; } }	paints a two - tone route from the entity ' s list of plottables ( locations ).
private boolean install reply ( string alias , input stream in ) throws exception { if ( alias == null ) { alias = key alias ; } pair < key , char [ ] > objs = recover key ( alias , store pass , key pass ) ; private key priv key = ( private key ) objs . fst ; if ( key pass == null ) { key pass = objs . snd ; } certificate user cert = key store . get certificate ( alias ) ; if ( user cert == null ) { message format form = new message format ( rb . get string ( str ) ) ; object [ ] source = { alias } ; throw new exception ( form . format ( source ) ) ; } collection < ? extends certificate > c = cf . generate certificates ( in ) ; if ( c . is empty ( ) ) { throw new exception ( rb . get string ( str ) ) ; } certificate [ ] reply certs = c . to array ( new certificate [ c . size ( ) ] ) ; certificate [ ] new chain ; if ( reply certs . length == num ) { new chain = establish cert chain ( user cert , reply certs [ num ] ) ; } else { new chain = validate reply ( alias , user cert , reply certs ) ; } if ( new chain != null ) { key store . set key entry ( alias , priv key , ( key pass != null ) ? key pass : store pass , new chain ) ; return bool ; } else { return bool ; } }	processes a certificate reply from a certificate authority.
@ override public boolean e is set ( int feature id ) { switch ( feature id ) { case eip package . aggregator name : return name edefault == null ? name != null : ! name edefault . equals ( name ) ; case eip package . aggregator to channels : return to channels != null && ! to channels . is empty ( ) ; case eip package . aggregator from channels : return from channels != null && ! from channels . is empty ( ) ; case eip package . aggregator part : return part != part edefault ; case eip package . aggregator strategy : return strategy edefault == null ? strategy != null : ! strategy edefault . equals ( strategy ) ; case eip package . aggregator expression : return expression edefault == null ? expression != null : ! expression edefault . equals ( expression ) ; } return super . e is set ( feature id ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
public synchronized void mouse wheel ( int wheel amt ) { peer . mouse wheel ( wheel amt ) ; after event ( ) ; }	rotates the scroll wheel on wheel - equipped mice .
@ override public int length ( ) { return data . length / ( format . get frame size ( ) * num ) ; }	returns the duration of the audio data ( in milliseconds ).
public static void delete directory ( final file dir , boolean check for links ) { if ( dir . is file ( ) ) { throw new illegal argument exception ( str + dir . get name ( ) + str ) ; } else if ( check for links && is link ( dir ) ) { throw new illegal argument exception ( str + dir . get name ( ) + str ) ; } if ( dir . exists ( ) ) { io . delete dir ( dir , check for links ) ; } else { throw new illegal argument exception ( str + dir . get name ( ) + str ) ; } }	this method recursively deletes the directory and all its contents.
private static marshaller create marshaller ( jaxb jaxb context , string schema path ) throws sax , jaxb { schema schema = xml parser . get schema ( new string [ ] { schema path } ) ; marshaller jaxb marshaller = jaxb context . create marshaller ( ) ; jaxb marshaller . set schema ( schema ) ; jaxb marshaller . set property ( marshaller . jaxb formatted output , bool ) ; jaxb marshaller . set property ( marshaller . jaxb encoding , str ) ; return jaxb marshaller ; }	create marshaller based on schema for itunes specific metadata format .
public static general path cardinal spline ( float pts [ ] , float slack , boolean closed ) { general path path = new general path ( ) ; path . move to ( pts [ num ] , pts [ num ] ) ; return cardinal spline ( path , pts , slack , closed , num , num ) ; }	compute a cardinal spline , a series of cubic bezier splines smoothly connecting a set of points.
public static string make method safe ( final string s ) { string name = make html ( s ) ; name = name . replace ( str , str ) ; return name ; }	replaces illegal characters that aren ' t allowed in code.
public builder add listen url ( string url ) { if ( url util . is url ( url ) ) { if ( m listen urls == null ) { m listen urls = new hash set < string > ( ) ; } m listen urls . add ( url ) ; } return this ; }	add the url for listening.
public void remove ( production production ) { productions . remove ( production ) ; }	removes a production from this rule .
private void write delay ( ) { try { thread . sleep ( num ) ; } catch ( interrupted exception e ) { fail ( str ) ; } }	a very slight delay to ensure that successive groups of queries in the db cannot have the same timestamp .
public static void main ( string [ ] argv ) { arg parser ap = new arg parser ( str ) ; ap . add ( str , str , num ) ; if ( argv . length < num ) { ap . bail ( str , bool ) ; } ap . parse ( argv ) ; string [ ] files = ap . get arg values ( str ) ; if ( files != null && files [ num ] != null ) { string shp = files [ num ] ; string dbf = null ; try { dbf = shp . substring ( num , shp . last index of ( str ) + num ) + param dbf ; dbf table model model = dbf table model . get dbf table model ( prop utils . get resource or file or url ( dbf ) ) ; esri graphic list list = esri graphic list . get esri graphic list ( prop utils . get resource or file or url ( shp ) , null , null ) ; logger . info ( list . get description ( ) ) ; esri shape export ese = new esri shape export ( list , model , null ) ; ese . export ( ) ; } catch ( url murle ) { logger . warning ( str + murle . get message ( ) ) ; } catch ( null pointer exception npe ) { logger . warning ( str ) ; } catch ( exception exception ) { logger . warning ( str + exception . get message ( ) ) ; exception . print stack trace ( ) ; } } else { ap . bail ( str , bool ) ; } system . exit ( num ) ; }	the main function is a test , reads in a shape file ( with the.
public void test max greater ( ) { byte a bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , - num , num , num , num , num } ; int a sign = num ; int b sign = num ; byte r bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num , num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . max ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert true ( str , result . signum ( ) == num ) ; }	max ( biginteger val ).
public static sorted set < interval > find full availability gaps ( set < interval > available intervals , set < interval > needed intervals ) { comparator < interval > interval start comparator = new interval start comparator ( ) ; sorted set < interval > sorted available intervals = new tree set < > ( interval start comparator ) ; sorted available intervals . add all ( available intervals ) ; sorted set < interval > sorted needed intervals = new tree set < > ( interval start comparator ) ; sorted needed intervals . add all ( needed intervals ) ; iterator < interval > available intervals iterator = sorted available intervals . iterator ( ) ; if ( ! available intervals iterator . has next ( ) ) { return sorted needed intervals ; } interval available = available intervals iterator . next ( ) ; sorted set < interval > missing intervals = new tree set < > ( interval start comparator ) ; for ( interval needed : sorted needed intervals ) { while ( ! can determine availability ( available , needed ) && available intervals iterator . has next ( ) ) { available = available intervals iterator . next ( ) ; } if ( available . contains ( needed ) ) { continue ; } missing intervals . add ( needed ) ; } return missing intervals ; }	finds the gaps in available vs needed interval sets .
public static list < string > split ( string str , string delim ) { list < string > split list = null ; string tokenizer st = null ; if ( str == null ) return split list ; if ( delim != null ) st = new string tokenizer ( str , delim ) ; else st = new string tokenizer ( str ) ; if ( st != null && st . has more tokens ( ) ) { split list = new linked list < string > ( ) ; while ( st . has more tokens ( ) ) split list . add ( st . next token ( ) ) ; } return split list ; }	splits a string on a delimiter into a list of strings .
public void write exif ( string jpeg file name , string exif out file name ) throws file not found exception , io { if ( jpeg file name == null || exif out file name == null ) { throw new illegal argument exception ( null argument string ) ; } input stream is = null ; is = new file input stream ( jpeg file name ) ; write exif ( is , exif out file name ) ; is . close ( ) ; }	writes the tags from this exifinterface object into a jpeg file , removing prior exif tags .
public boolean is gen class ( soot class clz ) { return gen classes . contains ( clz . get name ( ) ) ; }	return true if this class is defined in gen / directory of android application .
public boolean has extra still image ( ) { return is apng ( ) && ! firs idat apng frame ; }	true if it has a default image ( idat ) that is not part of the animation . in that case , we consider it as a pseudo - frame ( number - 1 ).
public void remove change listener ( final pt listener ) { change listeners . remove ( listener ) ; }	remove a change listener.
public static result set optimize in join select ( ) { simple result set rs = new simple result set ( ) ; rs . add column ( str , types . integer , num , num ) ; rs . add row ( num ) ; return rs ; }	this method is called via reflection from the database .
public partition substitution model parse paup ( beauti options options , list < char set > char sets ) throws import exception , io { partition substitution model model = new partition substitution model ( options , str ) ; read top level block ( options , model , char sets ) ; return model ; }	parses a ' paup ' block .
private void z event toggle time menu button mouse pressed ( mouse event e ) { toggle popup ( ) ; }	zeventtoggletimemenubuttonmousepressed , this is called when the user clicks on the " toggle time menu " button of the time picker.
private void add line ( grid field field , v editor , boolean mandatory ) { log . fine ( str + field ) ; j label = v . get label ( field ) ; label . set label for ( ( component ) editor ) ; editor . set read write ( bool ) ; editor . set mandatory ( mandatory ) ; field . add property change listener ( editor ) ; if ( m new row ) { m gbc . gridy = m line ++ ; m gbc . gridx = num ; } else m gbc . gridx = num ; m gbc . insets = m label insets ; m gbc . fill = grid bag constraints . horizontal ; m gbc . weightx = num ; parameter panel . add ( label , m gbc ) ; if ( m new row ) m gbc . gridx = num ; else m gbc . gridx = num ; m gbc . insets = m field insets ; m gbc . fill = grid bag constraints . horizontal ; m gbc . weightx = num ; parameter panel . add ( ( component ) editor , m gbc ) ; m new row = ! m new row ; }	add editor to parameterpanel alternative right / left depending on m_newrow . field value changes update editors.
protected object lazily load desktop property ( string name ) { return null ; }	an opportunity to lazily evaluate desktop property values .
@ edu . umd . cs . findbugs . annotations . suppress warnings ( value = str , justification = str ) public void init recovered version ( t member , region version holder < t > v , boolean latest oplog ) { region version holder < t > recovered = v . clone ( ) ; if ( member == null || member . equals ( my id ) ) { synchronized ( local exceptions ) { if ( latest oplog || local version . get ( ) == num ) { local exceptions = recovered ; if ( logger . is trace enabled ( log marker . rvv ) ) { logger . trace ( log marker . rvv , str , recovered . version ) ; } local version . set ( recovered . version ) ; } } } else { long gc version = member to gc . get ( member ) ; synchronized ( member to version ) { region version holder < t > old version = member to version . get ( member ) ; if ( latest oplog || old version == null || old version . version == num ) { if ( gc version != null ) { recovered . remove exceptions older than ( gc version ) ; } member to version . put ( member , recovered ) ; } } } }	records a version holder that we have recovered from disk.
protected void notify click listeners about click ( int item ) { if ( clicking listeners . size ( ) > num ) { for ( on wheel clicked listener listener : clicking listeners ) { listener . on item clicked ( this , item ) ; } } else { set current item ( item , bool , num ) ; } }	notifies listeners about clicking.
@ override public synchronized void disconnection notification ( string event name , object source ) { list < object > listenees = m listenees . get ( event name ) ; if ( listenees != null ) { listenees . remove ( source ) ; if ( listenees . size ( ) == num ) { m listenees . remove ( event name ) ; } } if ( event name . compare to ( str ) == num ) { stop ( ) ; } }	notify this object that it has been deregistered as a listener with a source with respect to the supplied event name.
public void test constructor sign bytes zero null1 ( ) { byte a bytes [ ] = { } ; int a sign = - num ; byte r bytes [ ] = { num } ; big integer a number = new big integer ( a sign , a bytes ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = a number . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , a number . signum ( ) ) ; }	create a zero number from a sign and an array of zero length.
private string replace illegal char ( string data , char ch , string replacement ) { int idx = num ; string builder buffer = new string builder ( data . length ( ) * num ) ; while ( ( data != null ) && ( idx = data . index of ( ch ) ) != - num ) { buffer . append ( data . substring ( num , idx ) ) ; buffer . append ( replacement ) ; data = data . substring ( idx + num ) ; } if ( ( data != null ) && ( data . length ( ) > num ) ) { buffer . append ( data ) ; } return buffer . to string ( ) ; }	replacing illegal xml char with entity ref.
protected static final void adjust module name ( debug module d ) { d . name = adjust module name ( d . name ) ; }	royale enhancement request : 53160.
public org . dom4j . attribute create attribute ( element elem , attribute attr ) { return factory . create attribute ( elem , create q ( attr . get name ( ) ) , attr . get value ( ) ) ; }	constructs a new dom4j attribute from the provided stax attribute event .
public log entry ( ) { index = entry index . get and increment ( ) ; time = system . current time millis ( ) ; }	constructs the logentry and sets its timestamp to now .
public void test bit length positive3 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num , num , num , num , num } ; int a sign = num ; big integer a number = new big integer ( a sign , a bytes ) ; assert equals ( num , a number . bit length ( ) ) ; }	bitlength ( ) of a positive number which is a power of 2.
public boolean is signature valid ( ) { return ec . verify ( utils . double digest ( content ) , signature , params . get alert signing key ( ) ) ; }	returns true if the digital signature attached to the message verifies.
private void validate create information ( date start time , string task name ) { assert . not null ( start time , str ) ; if ( task name != null && task name . length ( ) > this . max task name size ) { throw new illegal argument exception ( str + this . max task name size + str ) ; } }	validate starttime and taskname are valid .
private static object increment ( final object object , final number amount , final json pointer field ) throws bad request exception { if ( object instanceof long ) { return ( ( long ) object ) + amount . long value ( ) ; } else if ( object instanceof integer ) { return ( ( integer ) object ) + amount . int value ( ) ; } else if ( object instanceof float ) { return ( ( float ) object ) + amount . float value ( ) ; } else if ( object instanceof double ) { return ( ( double ) object ) + amount . double value ( ) ; } else { throw new bad request exception ( str + field + str ) ; } }	helper function to deal with typecasting and incrementing of object to appropriate number object ) .
public static linked hash set < entity > find entites ( linked hash set < entity > matches , hash set < entity > checked , entity entity , predicate predicate ) { if ( ! checked . add ( entity ) ) { return matches ; } if ( predicate . matches ( entity ) ) { matches . add ( entity ) ; } for ( ref node ref node : entity . get children ( ref node . class ) ) { entity e = ref node . get reference ( ) ; if ( e != null ) { find entites ( matches , checked , e , predicate ) ; } } for ( to many node to many node : entity . get children ( to many node . class ) ) { for ( entity e : to many node . get list ( ) ) { if ( e != null ) { find entites ( matches , checked , e , predicate ) ; } } } return matches ; }	finds all entities by navigating the object graph from entity which match the given predicate . < br / >.
public string to xml ( ) throws xacml { return to xml ( bool , bool ) ; }	returns a string representation.
public void add memory pressure listener ( memory pressure listener listener ) { m listeners . add ( listener ) ; }	add a listener to be notified of memory pressure events .
private void reset for ot ( ) { if ( bottom ot && home score == away score ) { game yard line = num ; game yards need = num ; game down = num ; num ot ++ ; if ( ( num ot % num ) == num ) game poss = bool ; else game poss = bool ; game time = - num ; bottom ot = bool ; } else if ( ! bottom ot ) { game poss = ! game poss ; game yard line = num ; game yards need = num ; game down = num ; game time = - num ; bottom ot = bool ; } else { playing ot = bool ; } }	give ball to correct team and reset yard line / down for new team.
public synchronized void start polling ( ) { m scheduler . schedule at fixed rate ( m notification poller , num , num , time unit . milliseconds ) ; }	activates the scheduler and queues the notification poller .
private void drop proxy ( proxy reg reg ) { synchronized ( caches ) { iterator iter = caches . iterator ( ) ; while ( iter . has next ( ) ) { lookup cache impl cache = ( lookup cache impl ) iter . next ( ) ; cache . remove proxy reg ( reg ) ; } } }	removes the given proxy from all the caches maintained by the sdm .
public void test update4 ( ) { int new value1 = - num ; int new value2 = - num ; string update query = str + database creator . test tabl + str + new value1 + str + new value2 + str ; try { int num = statement . execute update ( update query ) ; int expected updated = num ; assert equals ( str , expected updated , num ) ; string select query = str + database creator . test tabl ; result set result = statement . execute query ( select query ) ; while ( result . next ( ) ) { int id = result . get int ( str ) ; } result . close ( ) ; } catch ( sql e ) { fail ( str + e . get message ( ) ) ; } }	updatefunctionalitytest # testupdate4 ( ) . updates values in a several columns in the table using where condition in update command.
public long to long ( ) { return m value . long value ( ) ; }	returns the long value of the address .
public static int copy and close both ( reader input , writer output ) throws io { try { return copy and close output ( input , output ) ; } finally { input . close ( ) ; } }	copy input to output and close both the input and output streams before returning.
protected void write header ( ) throws io { header = new byte [ shape file header length ] ; write be ( header , num , shape file code ) ; write be ( header , num , num ) ; write le ( header , num , shape file version ) ; write le ( header , num , shape type null ) ; write le ( header , num , num ) ; write le ( header , num , num ) ; write le ( header , num , num ) ; write le ( header , num , num ) ; raf . seek ( num ) ; raf . write ( header , num , shape file header length ) ; }	writes a blank header into the shape file .
public string hash key for disk ( string key ) { string cache key ; try { final message digest m digest = message digest . get instance ( str ) ; m digest . update ( key . get bytes ( ) ) ; cache key = bytes to hex string ( m digest . digest ( ) ) ; } catch ( no such algorithm exception e ) { cache key = string . value of ( key . hash code ( ) ) ; } return cache key ; }	using the md5 algorithm to encrypt the key of the incoming and return .
public static void unregister ( spin old ) { if ( old != null ) { local functions . set ( old ) ; } else { local functions . remove ( ) ; } }	unregisters the current model for the current thread .
public static boolean load properties ( properties properties , input stream props in ) { try { properties . load ( props in ) ; return bool ; } catch ( java . io . io e ) { if ( logger . is loggable ( level . fine ) ) { logger . warning ( str ) ; } return bool ; } }	loads properties from a java resource.
public complex sin ( ) { return new complex ( math . sin ( re ) * math . cosh ( im ) , math . cos ( re ) * math . sinh ( im ) ) ; }	returns the complex sine of this complex number .
@ on click ( r . id . dismiss button ) public void on dismiss click ( view view ) { if ( system clock . elapsed realtime ( ) - m last click time < num ) { return ; } m last click time = system clock . elapsed realtime ( ) ; dismiss offer ( get adapter position ( ) ) ; if ( snackbar != null ) { snackbar . dismiss ( ) ; } }	dismiss tapped offer and remove from offers list.
public table find table ( string name ) { return find table ( name , bool ) ; }	finds the table with the specified name , using case insensitive matching.
public static void append string ( final string buffer buf , final string s ) { buf . append ( str ) ; for ( int i = num ; i < s . length ( ) ; ++ i ) { char c = s . char at ( i ) ; if ( c == str ) { buf . append ( str ) ; } else if ( c == str ) { buf . append ( str ) ; } else if ( c == str ) { buf . append ( str ) ; } else if ( c == str ) { buf . append ( str ) ; } else if ( c < num || c > num ) { buf . append ( str ) ; if ( c < num ) { buf . append ( str ) ; } else if ( c < num ) { buf . append ( str ) ; } else if ( c < num ) { buf . append ( str ) ; } buf . append ( integer . to string ( c , num ) ) ; } else { buf . append ( c ) ; } } buf . append ( str ) ; }	appends a quoted string to a given buffer .
public void draw ( final graphics g , final int height , final int width ) { int constant dim ; int changing dim ; if ( orientation == x axis ) { changing dim = width ; constant dim = height ; } else { changing dim = height ; constant dim = width ; } int dim step ; if ( fixed steps ) { dim step = changing dim / steps ; } else { dim step = num ; steps = changing dim / dim step ; } float red = red t ; float green = green t ; float blue = blue t ; int offset = num ; for ( int i = num ; i < steps ; i ++ ) { color c = new color ( round ( red ) , round ( green ) , round ( blue ) ) ; g . set color ( c ) ; draw rect ( g , offset , constant dim , dim step ) ; offset += dim step ; float value = shader . get value ( ( float ) i / ( float ) steps ) ; red = red t + ( red b - red t ) * value ; green = green t + ( green b - green t ) * value ; blue = blue t + ( blue b - blue t ) * value ; } color c = new color ( round ( red ) , round ( green ) , round ( blue ) ) ; g . set color ( c ) ; draw rect ( g , offset , constant dim , changing dim - offset ) ; }	draws the requested fade to g , with the given width and height .
private void send messages ( ) { list < murmur message > messages = get messages ( num ) ; murmur message exchange info message = new murmur message ( str , integer . to string ( messages . size ( ) ) , num ) ; if ( length value write ( out , exchange info message . to json ( murmur application . get context ( ) , num , num ) ) ) { for ( murmur message message : messages ) { list < murmur message > packet = new array list < > ( ) ; packet . add ( message ) ; cleartext messages messages message = new cleartext messages ( ( array list < murmur message > ) packet ) ; length value write ( out , messages message . to json ( murmur application . get context ( ) ) ) ; } } }	get messages from the messagestore , encode them as a cleartextmessages protobuf object , and write that message out to the output stream .
protected void init ( string str ) { int len = str . length ( ) ; text = new char [ len ] ; lc text = new char [ len ] ; for ( int i = num ; i < len ; i ++ ) { char c = str . char at ( i ) ; text [ i ] = c ; if ( c == str || c == str || c == str ) { lc text [ i ] = str ; } else lc text [ i ] = ( ( c >= str && c <= str ) || ( c >= str && c <= str ) ) ? c : character . to lower case ( c ) ; } }	gemeinsame initialmethode der drei konstruktoren , diese erhaelt den cfml code als char [ ] und uebertraegt ihn , in die interen datenhaltung .
private void update attrs ( svc reg reg , entry rep entry , object [ ] values ) { entry class eclass = entry . eclass ; for ( int fldidx = values . length ; -- fldidx >= num ; ) { object oval = entry . fields [ fldidx ] ; object nval = values [ fldidx ] ; if ( nval != null && ! nval . equals ( oval ) ) { eclass = get defining class ( eclass , fldidx ) ; hash map map = add attr ( reg , eclass , fldidx , nval ) ; entry . fields [ fldidx ] = nval ; if ( has attr ( reg , eclass , fldidx , oval ) ) continue ; array list regs = ( array list ) map . get ( oval ) ; regs . remove ( regs . index of ( reg ) ) ; if ( regs . is empty ( ) ) map . remove ( oval ) ; } } }	store all non - null elements of values into the given entry , and update servicebyattr to match .
public void finalize network construction ( ) { set < motif link > key set = node sets departing from link . key set ( ) ; nodes with link = new hash map < motif link , array list < node > > ( key set . size ( ) ) ; for ( motif link motif link : key set ) { set < node > nodes = node sets departing from link . get ( motif link ) ; array list < node > n = new array list < node > ( nodes ) ; collections . sort ( n ) ; nodes with link . put ( motif link , n ) ; } node sets departing from link = null ; }	optimises network structure for further processing.
public collection < ais > failures ( ) { return collections . unmodifiable collection ( failure list ) ; }	gets all failures , if there were any.
public static get inactive images response check get inactive images response ( get inactive images response response ) throws rpc exception { logger . info ( str , response ) ; switch ( response . get result ( ) ) { case ok : break ; case system error : throw new system error exception ( response . get error ( ) ) ; case datastore not found : throw new datastore not found exception ( response . get error ( ) ) ; case operation in progress : throw new operation in progress exception ( response . get error ( ) ) ; default : throw new rpc exception ( string . format ( str , response . get result ( ) ) ) ; } return response ; }	validates a getinactiveimagesresponse object , raising an exception if the response code is not ' ok ' .
public void run test ( ) throws throwable { document doc ; element root ; node list element list ; node first child ; node list text list ; character data text node ; string data ; doc = ( document ) load ( str , bool ) ; root = doc . get document element ( ) ; root . normalize ( ) ; element list = root . get elements by tag name ( str ) ; first child = element list . item ( num ) ; text list = first child . get child nodes ( ) ; text node = ( character data ) text list . item ( num ) ; data = text node . get data ( ) ; assert equals ( str , str , data ) ; }	runs the test case .
public double semi deviation ( ) { return math . sqrt ( semi variance ( ) ) ; }	returns the semi deviation , defined as the square root of the semi variance .
private void check posts display on recycler view ( list < post > posts to check , int position ) { int column count = num ; int size = posts to check . size ( ) + position ; int pos = num ; for ( int i = position ; i < size ; i ++ ) { check item at position ( i , posts to check . get ( pos ) ) ; if ( ( ( i + num ) % column count ) == num ) { int next row start = i + column count ; int next row end = next row start - column count + num ; for ( int n = next row start ; n >= next row end ; n -- ) { check item at position ( n , posts to check . get ( n - position ) ) ; } i = i + column count ; } pos ++ ; } }	this method checks that the given list of posts display within the verticalgridview.
private void add dependent classes to worklist ( gv c ) { for ( value graph vertex v : c ) { for ( enumeration < graph node > e = v . in nodes ( ) ; e . has more elements ( ) ; ) { value graph vertex in = ( value graph vertex ) e . next element ( ) ; int vn = in . get value number ( ) ; gv x = b . get ( vn ) ; work list . push ( x ) ; } } }	assuming congruence class c has changed : find all other classes that might be affected , and add them to the worklist.
public synchronized json to json ( ) { json res = new json ( ) ; res . put all ( this ) ; return res ; }	return a copy of the json content.
private shape create ellipse internal ( int x , int y , int w , int h ) { ellipse . set frame ( x , y , w , h ) ; return ellipse ; }	return a path for an ellipse .
public static string write ( string builder sb , string ... strings ) { for ( string string : strings ) sb . append ( string ) ; return sb . to string ( ) ; }	semplifies the concatenation of strings.
public import folder validation validate ( final string path ) { check . not null ( path , str ) ; if ( validation cache == null ) { validation cache = new hash map ( ) ; } else { if ( validation cache . contains key ( path ) ) { return ( import folder validation ) validation cache . get ( path ) ; } } final import folder validation validation = compute validation ( path ) ; validation cache . put ( path , validation ) ; return validation ; }	validate a potential path for import.
private static byte [ ] hmac sha ( string crypto , byte [ ] key bytes , byte [ ] text ) { try { mac hmac ; hmac = mac . get instance ( crypto ) ; secret key spec mac key = new secret key spec ( key bytes , str ) ; hmac . init ( mac key ) ; return hmac . do final ( text ) ; } catch ( general security exception gse ) { throw new undeclared throwable exception ( gse ) ; } }	this method uses the jce to provide the crypto algorithm.
public static string fetch cg name ( string cluster cg name ) { string cg name = null ; if ( cluster cg name != null && ! cluster cg name . is empty ( ) ) { string [ ] tmp = cluster cg name . split ( splitter ) ; cg name = tmp [ num ] ; } return cg name ; }	parses out the consistency group name from the combined cluster / cg name .
public void test choose server alias ( ) { init ( server ) ; assert null ( manager . choose server alias ( null , null , new socket ( ) ) ) ; assert null ( manager . choose server alias ( str , null , new socket ( ) ) ) ; string res = manager . choose server alias ( type rsa , null , null ) ; assert not null ( res ) ; assert equals ( str , res . to lower case ( ) ) ; res = manager . choose server alias ( type rsa , null , new socket ( ) ) ; assert not null ( res ) ; assert equals ( str , res . to lower case ( ) ) ; }	x509keymanager # chooseserveralias ( string keytype , principal [ ] issuers , socket socket ).
public void add ( int index , entity entity ) { if ( entities . contains ( entity ) ) { throw new illegal state exception ( str + entity + str ) ; } if ( entity . get entity type ( ) != entity type ) { throw new illegal state exception ( str + entity . get entity type ( ) + str + get parent ( ) + str + get name ( ) ) ; } if ( entity . is clearly not in database ( ) ) { new entities . add ( entity ) ; } entities . add ( index , entity ) ; }	we are adding an entity to this list .
public static control tag cache object create test equipment alive ( ) { control tag cache object cache object = new control tag cache object ( new long ( num ) , str , str , data tag constants . mode test ) ; cache object . set description ( str ) ; cache object . set logged ( bool ) ; cache object . set unit ( str ) ; cache object . set dip address ( str ) ; cache object . set japc address ( str ) ; cache object . set value ( new long ( system . current time millis ( ) ) ) ; cache object . set value description ( str ) ; cache object . set simulated ( bool ) ; cache object . set min value ( long . min value ) ; cache object . set max value ( long . max value ) ; cache object . set value dictionary ( new data tag value dictionary ( ) ) ; cache object . set address ( new data tag address ( ) ) ; cache object . set data tag quality ( create valid quality ( ) ) ; cache object . set cache timestamp ( new timestamp ( system . current time millis ( ) ) ) ; cache object . set daq timestamp ( new timestamp ( system . current time millis ( ) ) ) ; cache object . set source timestamp ( new timestamp ( system . current time millis ( ) ) ) ; return cache object ; }	creates a an alivetimer for the equipment .
public distributed log configuration ( ) { super ( ) ; add configuration ( new system configuration ( ) ) ; }	construct distributedlog configuration with default settings.
public static double sample standard deviation ( int size , double sample variance ) { double s , cn ; int n = size ; s = math . sqrt ( sample variance ) ; if ( n > num ) { cn = num + num / ( num * ( n - num ) ) ; } else { cn = math . sqrt ( ( n - num ) * num ) * gamma . gamma ( ( n - num ) * num ) / gamma . gamma ( n * num ) ; } return cn * s ; }	returns the sample standard deviation.
void normalize ( ) throws io { int end = chars . length ( ) ; if ( end == num ) { return ; } int pos = num ; int codepoint = character . code point at ( chars , num ) ; boolean escaped = bool ; for ( int i = num ; i < end ; ) { int char count = character . char count ( codepoint ) ; int i2 = i + char count ; int next codepoint = i2 < end ? character . code point at ( chars , i2 ) : - num ; if ( escaped ) { escaped = bool ; if ( escape one codepoint ( pos , i - num , codepoint , next codepoint ) ) { pos = i2 ; } } else if ( codepoint == str ) { escaped = bool ; } else if ( escape one codepoint ( pos , i , codepoint , next codepoint ) ) { pos = i2 ; } i = i2 ; codepoint = next codepoint ; } out . append ( chars , pos , end ) ; }	like escape , but treats the input as an already escaped string and only tries to ensure that characters that might or need not be escaped for correctness are consistently escaped .
protected void rebuild list model ( ) { default list model dlm = ( default list model ) get list model ( ) ; om list = get list ( ) ; int [ ] selected indicies = null ; if ( list != null ) { if ( selected tiles != null && selected tiles . length > num ) { selected indicies = new int [ selected tiles . length ] ; } int tile count = num ; int selected index = num ; if ( selected indicies != null ) { for ( om omg : list ) { image tile image tile = ( image tile ) omg ; if ( image tile . is selected ( ) && selected index < selected indicies . length ) { selected indicies [ selected index ++ ] = tile count ; } tile count ++ ; } } dlm . clear ( ) ; for ( om omg : list ) { tile count ++ ; dlm . add element ( omg ) ; } } if ( results list != null ) { if ( selected indicies != null ) { results list . set selected indices ( selected indicies ) ; } results list . repaint ( ) ; } }	rebuild the list model contents based on the imagetiles contained on the omgraphiclist .
public void tick ( ) { tick ( num ) ; }	advances a step down.
public result send ( email email , boolean ... sync ) { return service . send ( email , bool to int ( bool , sync ) ) ; }	send email notification , synchronized if sync is absent .
private boolean is populating ( ) { return is populating ; }	checks if the panel is being populated .
public void process attributes ( java . io . writer writer , int n attrs ) throws io , sax { string encoding = get encoding ( ) ; for ( int i = num ; i < n attrs ; i ++ ) { final string name = m attributes . get q ( i ) ; final string value = m attributes . get value ( i ) ; writer . write ( str ) ; writer . write ( name ) ; writer . write ( str ) ; write attr string ( writer , value , encoding ) ; writer . write ( str ) ; } }	process the attributes , which means to write out the currently collected attributes to the writer . the attributes are not cleared by this method.
public int processor ( ) { return integer . parse int ( fields [ num ] ) ; }	( since linux 2.
public void add native child at ( react shadow node child , int native index ) { assertions . assert condition ( ! m is layout only ) ; assertions . assert condition ( ! child . m is layout only ) ; if ( m native children == null ) { m native children = new array list < > ( num ) ; } m native children . add ( native index , child ) ; child . m native parent = this ; }	adds a child that the native view hierarchy will have at this index in the native view corresponding to this node .
public boolean contains key ( final object e key ) { return element order . contains ( e key ) ; }	checks to see if the element key exists .
private void handle exit message ( final component component , final long native ctxt ) { post drop target event ( component , num , num , d . action none , d . action none , null , native ctxt , sun drop target event . mouse exited , sun drop target context peer . dispatch sync ) ; }	upcall to handle exit messages.
public void add parameter annotations ( cst method ref method , annotations list list ) { if ( parameter annotations == null ) { parameter annotations = new array list < parameter annotation struct > ( ) ; } parameter annotations . add ( new parameter annotation struct ( method , list ) ) ; }	adds a parameter annotations item to this instance .
public static string unhtml single quotes ( final string str ) { return str . replace all ( str , str ) ; }	replace single quotes html entities with equivalent character .
public void add input method listener ( input method listener l ) { m text area . add input method listener ( l ) ; }	add text input method listener.
public void init raw swap ( array list < s2 cell id > cell ids ) { this . cell ids = new array list < s2 cell id > ( cell ids ) ; cell ids . clear ( ) ; }	like init ( ) , but does not call normalize ( ).
protected void encrypt final ( ) throws io { in buffer . flip ( ) ; out buffer . clear ( ) ; try { cipher . do final ( in buffer , out buffer ) ; } catch ( short buffer exception e ) { throw new io ( e ) ; } catch ( illegal block size exception e ) { throw new io ( e ) ; } catch ( bad padding exception e ) { throw new io ( e ) ; } in buffer . clear ( ) ; out buffer . flip ( ) ; while ( out buffer . has remaining ( ) ) { output . write ( out buffer ) ; } }	does final encryption of the last data .
private static boolean span will overlap ( spannable span text , url [ ] span list , int start , int end ) { if ( start == end ) { return bool ; } for ( url span : span list ) { int existing start = span text . get span start ( span ) ; int existing end = span text . get span end ( span ) ; if ( ( start >= existing start && start < existing end ) || end > existing start && end <= existing end ) { if ( log . is loggable ( tag , log . verbose ) ) { char sequence seq = span text . sub sequence ( start , end ) ; log . v ( tag , str + seq + str ) ; } return bool ; } } return bool ; }	determines whether a new span at [ start , end ) will overlap with any existing span .
private hash map < integer , trie > build lookup table ( final map < integer , list < trie > > child tries ) { hash map < integer , trie > lookup = new hash map < > ( child tries . size ( ) ) ; for ( int id : child tries . key set ( ) ) { final list < trie > tries = child tries . get ( id ) ; if ( tries . size ( ) == num ) { lookup . put ( id , tries . get ( num ) ) ; } else { lookup . put ( id , new slice aggregating trie ( tries ) ) ; } } return lookup ; }	build a lookup table for children tries.
public void add marker ( int x , int z , color color ) { map marker marker = new map marker ( ) ; marker . x = x ; marker . z = z ; marker . color = color ; markers . add ( marker ) ; }	adds a marker to the map .
private void commit discard ( long time , boolean allow discard ) { if ( m discarding tab == null ) return ; assert m stack tabs != null ; stack tab discarded = m discarding tab ; if ( math . abs ( discarded . get discard amount ( ) ) / get discard range ( ) > discard commit threshold && allow discard ) { m layout . ui requesting close tab ( time , discarded . get id ( ) ) ; record user action . record ( str ) ; record user action . record ( str ) ; } else { start animation ( time , overview animation type . undiscard ) ; } m discarding tab = null ; request update ( ) ; }	commits or release the that currently being considered for discard.
public list < object > build java method parameters ( asset options context context , map < string , string > available assets , asset options method info asset method ) { final list < object > java method parameters = lists . new array list ( ) ; java method parameters . add ( context ) ; for ( string parent asset name : asset method . asset dependencies ) { string parent asset value = available assets . get ( parent asset name ) ; int index = java method parameters . size ( ) ; object value = asset method . convert parameter ( index , parent asset value ) ; java method parameters . add ( value ) ; } return java method parameters ; }	build the list of parameter objects to hand in to the method invocation.
private static image view pick graphic ( restartable service start stoppable ) { final boolean running = start stoppable . is running ( ) ; final image view icon = running ? new image view ( stop image ) : new image view ( start image ) ; if ( ! running ) { final fade transition ft = new fade transition ( duration . millis ( num ) , icon ) ; ft . set to value ( num ) ; ft . set cycle count ( transition . indefinite ) ; ft . set auto reverse ( bool ) ; ft . play ( ) ; } icon . set fit height ( dpi . mini icon size ) ; icon . set fit width ( dpi . mini icon size ) ; return icon ; }	gets the graphic that should be used for the button given the current source ' s state.
public void create cash based journal entries and reversals for savings charges ( final office office , final string currency code , final cash accounts for savings account type to be debited , final cash accounts for savings account type to be credited , final long savings product id , final long payment type id , final long loan id , final string transaction id , final date transaction date , final big decimal total amount , final boolean is reversal , final list < dto > charge payment dt ) { if ( charge payment dt . size ( ) != num ) { throw new platform data integrity exception ( str , str ) ; } dto charge payment dto = charge payment dt . get ( num ) ; final gl charge specific account = get linked gl ( savings product id , account type to be credited . get value ( ) , charge payment dto . get charge id ( ) ) ; final gl savings control account = get linked gl ( savings product id , account type to be debited . get value ( ) , payment type id ) ; if ( is reversal ) { create debit journal entry for savings ( office , currency code , charge specific account , loan id , transaction id , transaction date , total amount ) ; create credit journal entry for savings ( office , currency code , savings control account , loan id , transaction id , transaction date , total amount ) ; } else { create debit journal entry for savings ( office , currency code , savings control account , loan id , transaction id , transaction date , total amount ) ; create credit journal entry for savings ( office , currency code , charge specific account , loan id , transaction id , transaction date , total amount ) ; } }	convenience method that creates a pair of related debits and credits for cash based accounting . the target accounts for debits and credits are switched in case of a reversal.
public void add all ( json array array ) { elements . add all ( array . elements ) ; }	adds all the elements of the specified array to self .
public double next double ( double k ) { double u , v , w , c , z ; if ( k <= num ) throw new illegal argument exception ( ) ; if ( k set != k ) { tau = num + math . sqrt ( num + num * k * k ) ; rho = ( tau - math . sqrt ( num * tau ) ) / ( num * k ) ; r = ( num + rho * rho ) / ( num * rho ) ; k set = k ; } do { u = random generator . raw ( ) ; v = random generator . raw ( ) ; z = math . cos ( math . pi * u ) ; w = ( num + r * z ) / ( r + z ) ; c = k * ( r - w ) ; } while ( ( c * ( num - c ) < v ) && ( math . log ( c / v ) + num < c ) ) ; return ( random generator . raw ( ) > num ) ? math . acos ( w ) : - math . acos ( w ) ; }	returns a random number from the distribution ; bypasses the internal state .
public void test list options ( ) { if ( m . get option handler ( ) != null ) { if ( ! m . check list options ( ) ) { fail ( str ) ; } } }	tests the listing of the options.
@ override final public void mouse released ( mouse event e ) { if ( is component pressed down ) { mouse liberal click ( e ) ; long now = system . current time millis ( ) ; long time between unused clicks = now - last unused liberal single click time stamp ; if ( time between unused clicks <= slowest double click milliseconds ) { mouse liberal double click ( e ) ; last unused liberal single click time stamp = num ; } else { last unused liberal single click time stamp = system . current time millis ( ) ; } } is component pressed down = bool ; mouse release ( e ) ; }	mousereleased , final function.
public static modification type value of ( final int int value ) { modification type result = null ; if ( num <= int value && int value < elements . length ) { result = elements [ int value ] ; } if ( result == null ) { result = new modification type ( int value , str + int value + str , enum . unknown ) ; } return result ; }	returns the modification change type having the specified integer value as defined in rfc 4511 section 4.
@ override public void fill header ( header hdr ) { try { standard . context ( ascii table . class ) ; hdr . set xtension ( str ) ; hdr . set bitpix ( hdu . bitpix byte ) ; hdr . set naxes ( num ) ; hdr . set naxis ( num , this . row len ) ; hdr . set naxis ( num , this . n rows ) ; cursor < string , header card > iter = hdr . iterator ( ) ; iter . set key ( naxi . key ( ) ) ; iter . next ( ) ; iter . add ( new header card ( pcount . key ( ) , num , pcount . comment ( ) ) ) ; iter . add ( new header card ( gcount . key ( ) , num , gcount . comment ( ) ) ) ; iter . add ( new header card ( tfields . key ( ) , this . n fields , tfields . comment ( ) ) ) ; for ( int i = num ; i < this . n fields ; i += num ) { add col info ( i , iter ) ; } } catch ( header card exception e ) { log . log ( level . severe , str + e . get message ( ) , e ) ; } finally { standard . context ( null ) ; } }	fill in a header with information that points to this data .
private boolean search end match ( final string item name ) { for ( map . entry < string , sentence > e : parsed names . entry set ( ) ) { sentence parsed = e . get value ( ) ; if ( item name . ends with ( parsed . get original text ( ) ) || item name . ends with ( parsed . get normalized ( ) ) ) { name = e . get key ( ) ; return bool ; } } return bool ; }	check for end matches while searching for item names .
private static byte expected norm ( final default similarity sim , final int length , final float boost ) { return ( byte ) sim . encode norm value ( boost / ( ( float ) math . sqrt ( length ) ) ) ; }	given a length , and boost returns the expected encoded norm.
@ override public shape tile simplex enlarge ( double p offset ) { if ( p offset == num ) return this ; shape tile simplex offset simplex = offset ( p offset ) ; shape tile octagon bounding oct = bounding octagon ( ) ; if ( bounding oct . is n ( ) ) return shape tile simplex . empty ; shape tile octagon offset oct = bounding oct . offset ( p offset ) ; return offset simplex . intersection ( offset oct . to ( ) ) ; }	returns this simplex enlarged by p_offset . the result simplex is intersected with the by p_offset enlarged bounding octagon of this simplex.
v remove ( object key , int hash , object value ) { lock ( ) ; try { int c = cnt - num ; he < k , v > [ ] tab = table ; int index = hash & ( tab . length - num ) ; he < k , v > first = tab [ index ] ; he < k , v > e = first ; while ( e != null && ( e . hash != hash || ! key . equals ( e . k ) ) ) e = e . next ; v old value = null ; if ( e != null ) { v v = e . v ; if ( value == null || value . equals ( v ) ) { old value = v ; ++ mod cnt ; he < k , v > new first = e . next ; for ( he < k , v > p = first ; p != e ; p = p . next ) new first = new he < k , v > ( p . k , p . hash , new first , p . v ) ; tab [ index ] = new first ; cnt = c ; } } return old value ; } finally { unlock ( ) ; } }	remove ; match on key only if value null , else match both .
public static tree path path till of kind ( final tree path path , final tree . kind kind ) { return path till of kind ( path , enum set . of ( kind ) ) ; }	gets path to the first enclosing tree of the specified kind .
public big decimal read f2 dot14 ( int index ) { throw new unsupported operation exception ( ) ; }	reads the f2dot14 at the given index .
public void add rendering hints ( map < ? , ? > hints ) { m graphics . add rendering hints ( hints ) ; }	adds a number of preferences for the rendering algorithms.
private void create new fields array ( ) { for ( int i = num ; i < person fields old . length ; i ++ ) { person fields new [ i ] = person fields old [ i ] + str ; } }	new fields are named like old ones with _link attached :.
public void remove all relations ( ) { for ( b input node : new linked list < b > ( input nodes . values ( ) ) ) { remove input node ( input node . get id ( ) ) ; } for ( b output node : new linked list < b > ( output nodes . values ( ) ) ) { remove output node ( output node . get id ( ) ) ; } }	removes all input and output relations to the node.
private void add exposed types ( class < ? > clazz , class < ? > cause ) { if ( pruned ( clazz ) ) { return ; } boolean already done = done ( clazz ) ; visit ( clazz ) ; record exposure ( clazz , cause ) ; if ( already done || pruned ( clazz ) ) { return ; } type token < ? > token = type token . of ( clazz ) ; for ( type token < ? > super type : token . get types ( ) ) { if ( ! super type . equals ( token ) ) { logger . debug ( str , super type , clazz ) ; add exposed types ( super type , clazz ) ; } } for ( class inner class : clazz . get declared classes ( ) ) { if ( exposed ( inner class . get modifiers ( ) ) ) { logger . debug ( str , inner class , clazz ) ; add exposed types ( inner class , clazz ) ; } } for ( field field : clazz . get declared fields ( ) ) { if ( exposed ( field . get modifiers ( ) ) ) { logger . debug ( str , field , clazz ) ; add exposed types ( field , clazz ) ; } } for ( invokable invokable : get exposed invokables ( token ) ) { logger . debug ( str , invokable , clazz ) ; add exposed types ( invokable , clazz ) ; } }	adds a class and all of the types it exposes.
public void store logs ( file folder ) { string path = folder . get absolute path ( ) ; m logger folder = new log this ( path ) ; }	enables the sdk to start writing logs into a desired folder with the name of logthis . txt keep in mind that the sdk does not enable any storage permission , so the application must declare it and ask for it on android m and above.
@ override public object clone ( ) { return new location path ( this ) ; }	returns a clone of this object .
private assignment recursive back tracking search ( csp csp , assignment assignment ) { assignment result = null ; if ( assignment . is complete ( csp . get variables ( ) ) ) { result = assignment ; } else { variable var = select unassigned variable ( assignment , csp ) ; for ( object value : order domain values ( var , assignment , csp ) ) { assignment . set assignment ( var , value ) ; fire state changed ( assignment , csp ) ; if ( assignment . is consistent ( csp . get constraints ( var ) ) ) { domain restore info info = inference ( var , assignment , csp ) ; if ( ! info . is empty ( ) ) fire state changed ( csp ) ; if ( ! info . is empty domain found ( ) ) { result = recursive back tracking search ( csp , assignment ) ; if ( result != null ) break ; } info . restore domains ( csp ) ; } assignment . remove assignment ( var ) ; } } return result ; }	template method , which can be configured by overriding the three primitive operations below .
private static json create file transfer error ( int error code , string source , string target , string body , integer http status ) { json error = null ; try { error = new json ( ) ; error . put ( str , error code ) ; error . put ( str , source ) ; error . put ( str , target ) ; if ( body != null ) { error . put ( str , body ) ; } if ( http status != null ) { error . put ( str , http status ) ; } } catch ( json e ) { log . e ( log tag , e . get message ( ) , e ) ; } return error ; }	create an error object based on the passed in errorcode.
public array list < value > keys ( ) { array list < value > list = new . array list ( size ) ; for ( value k : keys ) { if ( k != null && k != value null . deleted ) { list . add ( k ) ; } } return list ; }	get the list of keys .
private void close ( ) { if ( closed ) { return ; } closed = bool ; try { result set . close ( ) ; } catch ( final sql e ) { logger . error ( e , e ) ; } try { if ( statement != null ) { statement . close ( ) ; } } catch ( final sql e ) { logger . error ( e , e ) ; } }	closes the resultset and statement .
public delivery thread ( tom tom layer , service replica receiver , recoverable recoverer , server view controller controller ) { super ( str ) ; this . decided = new linked blocking queue < > ( ) ; this . tom layer = tom layer ; this . receiver = receiver ; this . recoverer = recoverer ; this . controller = controller ; }	creates a new instance of deliverythread.
protected void add button listener ( ) { application insights add dialog dialog = new application insights add dialog ( get shell ( ) ) ; dialog . open ( ) ; table viewer . refresh ( ) ; }	method opens dialog to add existing application insights resource in list .
public int [ ] to array ( ) { int [ ] result = new int [ size ] ; system . arraycopy ( array , num , result , num , size ) ; return result ; }	returns an array containing all of the elements in this list in the correct order .
public block obtain block ( string prototype name , @ nullable string uuid ) { block block ; if ( uuid != null ) { weak reference < block > ref = m block refs . get ( uuid ) ; if ( ref != null ) { block = ref . get ( ) ; if ( block != null ) { throw new illegal argument exception ( str + uuid + str ) ; } } } if ( ! m block templates . contains key ( prototype name ) ) { log . w ( tag , str + prototype name + str ) ; return null ; } block . builder builder = new block . builder ( m block templates . get ( prototype name ) ) ; if ( uuid != null ) { builder . set uuid ( uuid ) ; } block = builder . build ( ) ; m block refs . put ( block . get id ( ) , new weak reference < block > ( block ) ) ; return block ; }	creates a block of the specified type using one of the master blocks known to this factory.
public sms console service config ( ) { document doc = parse document ( config filename ) ; config services ( doc ) ; hidden services = collections . unmodifiable set ( services . get ( hidden services ) ) ; }	generates the singleton smsconsoleserviceconfig by reading and parsing the appropriate xml config file .
private static string convert to quoted string ( string s ) { if ( s == null || s . is empty ( ) ) { return null ; } if ( s . char at ( num ) == str && s . char at ( s . length ( ) - num ) == str ) { return s ; } return str + s + str ; }	encloses the incoming string inside double quotes , if it isn ' t already quoted .
public pattern observer expr ( string namespace , string name , expression [ ] parameters ) { super ( namespace , name , arrays . as list ( parameters ) ) ; }	ctor - for use to create a pattern expression tree , without pattern child expression .
public static string convert string to hex string ( string data ) { return convent bytes to hex string ( data . get bytes ( ) ) ; }	convert the string to hex string value .
public boolean is transient ( ) { return modifier . is transient ( get access flags ( ) ) ; }	returns true for a transient field .
public boolean is for http ( ) { return ( nego value != null ) ? nego value . equals ignore case ( http httpbasic ) : bool ; }	returns < code > true < code > if the callback is for httpbasic .
private string indent ( int level ) { final string s = str ; if ( level == num ) return str ; string builder sb = new string builder ( level * s . length ( ) ) ; for ( int i = num ; i < level ; i ++ ) { sb . append ( s ) ; } return s . to string ( ) ; }	generates an indentation string .
public static string cut ( string line , int predicate test function ) { string s = str ; int pos = sub parser . locate ( line , test function ) ; if ( pos != - num ) { s = line . substring ( num , pos ) ; } return s ; }	cuts the string from the beginning until the testfunction predicates .
public void add listener ( update manager listener listener ) { listeners . add ( listener ) ; }	listen for updates to the update manager .
public void cancel authentication ( ) { synchronized ( sync lock ) { authenticating = bool ; timer . cancel ( ) ; timer . purge ( ) ; } }	if this object is authenticating using the callback based authenticate method , then this will cancel future authentication requests.
private void check valid interval ( duration polling interval , int retries , long time slept millis ) { long high sum = num ; long low sum = num ; for ( int i = num ; i < retries ; i ++ ) { double current interval = polling interval . get millis ( ) * math . pow ( dataflow pipeline job . default backoff exponent , i ) ; double random offset = num * current interval ; high sum += math . round ( current interval + random offset ) ; low sum += math . round ( current interval - random offset ) ; } assert that ( time slept millis , all of ( greater than or equal to ( low sum ) , less than or equal to ( high sum ) ) ) ; }	validates that a given time is valid for the total time slept by a attemptboundedexponentialbackoff given the number of retries and an initial polling interval .
public void write ( string str , int off , int len ) throws io { if ( output stream == null ) throw new io ( str ) ; final int off plus len = off + len ; for ( int i = off ; i < off plus len ; ) { char c = str . char at ( i ++ ) ; if ( c < num ) { bytes [ index ] = ( byte ) c ; if ( ++ index >= bytes . length ) { flush buffer ( ) ; } } else { write ( c ) ; } } }	writes a portion of a string .
public commit record index ( i store , checkpoint checkpoint , index metadata metadata , boolean read only ) { super ( store , checkpoint , metadata , read only ) ; this . ser = new entry . entry serializer ( ) ; }	load from the store .
protected string encode body ( ) { return long . to string ( this . sequence number ) ; }	encode the body of this header ( the stuff that follows headername ).
private void check size ( final int i ) { if ( i >= max size ) { final int old size = max size ; max size += increment size ; if ( max size <= i ) { max size = i + increment size + num ; } final rectangle [ ] temp = items ; items = new rectangle [ max size ] ; system . arraycopy ( temp , num , items , num , old size ) ; increment size = increment size ( increment size ) ; } }	check the size of the array and increase if needed.
public double volume ( ) { if ( cached volume < num ) { cached volume = num ; i cube = this . region ; int nd = cube . dimensionality ( ) ; for ( int d = num ; d <= nd ; d ++ ) { double right = cube . get right ( d ) ; double left = cube . get left ( d ) ; if ( double . is infinite ( right ) ) { right = + num ; } if ( double . is infinite ( left ) ) { left = - num ; } if ( left == - num && right == + num ) { } else { cached volume *= ( right - left ) ; } } } return cached volume ; }	return volume of hypercube region associated with node.
static string target so file ( string lib name , int version ) { context context = m context ; if ( null == context ) { return str ; } string path = str + context . get package name ( ) + str ; file f = context . get files dir ( ) ; if ( f != null ) { path = f . get path ( ) ; } return path + str + lib name + str + version + str ; }	concatenate the path of the so library , including directory .
@ override public void stop monitoring ( ) { stop monitoring ( bool ) ; }	stop monitoring off - heap usage .
@ override public object compute ( array list < map < string , object > > rows ) throws exception { if ( column . equals ( str ) ) { return rows . size ( ) ; } long count = num ; for ( map < string , object > row : rows ) { if ( row . contains key ( column ) && ( row . get ( column ) != null ) ) { count ++ ; } } return count ; }	count number of values of given column .
private property [ ] parse properties ( final string contents ) { final string [ ] parts = contents . split ( str ) ; final list < property > results as list = new array list < property > ( ) ; for ( string part : parts ) { try { if ( ! string utils . is empty ( part . trim ( ) ) ) { results as list . add ( new property ( part ) ) ; } } catch ( final exception e ) { log . warn ( e . get message ( ) , e ) ; } } return results as list . to array ( new property [ results as list . size ( ) ] ) ; }	parses out the properties of a selector ' s body .
public void request seconds until account expiration ( ) { operations . add ( password policy state operation type . get seconds until account expiration ) ; }	returns the seconds until account expiration .
public final boolean equals ignore case ( string a ) { int len = a . length ( ) ; if ( length != len ) return bool ; int offset = offset ; char [ ] buffer = buffer ; for ( int i = num ; i < len ; i ++ ) { char ca = buffer [ offset + i ] ; char cb = a . char at ( i ) ; if ( ca == cb ) { } else if ( character . to lower case ( ca ) != character . to lower case ( cb ) ) return bool ; } return bool ; }	returns true if the charsegment equals the string .
public static int [ ] check object start ( pdf tokenizer line tokenizer ) { try { line tokenizer . seek ( num ) ; if ( ! line tokenizer . next token ( ) || line tokenizer . get token type ( ) != token type . number ) return null ; int num = line tokenizer . get int value ( ) ; if ( ! line tokenizer . next token ( ) || line tokenizer . get token type ( ) != token type . number ) return null ; int gen = line tokenizer . get int value ( ) ; if ( ! line tokenizer . next token ( ) ) return null ; if ( ! arrays . equals ( obj , line tokenizer . get byte content ( ) ) ) return null ; return new int [ ] { num , gen } ; } catch ( exception ioe ) { } return null ; }	check whether line starts with object declaration .
private object single element ( int row , int col ) { object res = null ; if ( this . is null == null || ! this . is null [ row * this . n fields + col ] ) { res = array funcs . new instance ( this . types [ col ] , num ) ; system . arraycopy ( this . data [ col ] , row , res , num , num ) ; } return res ; }	extract a single element from a table.
private char convert to char ( string kurzname ) { char result = kein siegel ; if ( kurzname != null && ! kurzname . is empty ( ) ) { if ( kurzname . length ( ) > num ) { result = kurzname . to char array ( ) [ num ] ; } else { result = kurzname . to char array ( ) [ num ] ; } } return result ; }	convert " > g < " , a , b , c , w , " - " , " - - - " to a char " > g < " is converted to g.
public dtm ( node iterator iterator , x xctxt ) { super ( ) ; node node ; m manager = xctxt . get dtm ( ) ; while ( null != ( node = iterator . next node ( ) ) ) { int handle = xctxt . get dtm ( node ) ; add node in doc order ( handle , xctxt ) ; } }	create a nodesetdtm , and copy the members of the given dtmiterator into it .
public static vec mean vector ( data set data set ) { dense vector dv = new dense vector ( data set . get num numerical vars ( ) ) ; mean vector ( dv , data set ) ; return dv ; }	computes the weighted mean of the given data set .
private void make cache directory ( ) { file cache dir = new file ( cache directory ) ; if ( ! cache dir . exists ( ) ) { cache dir . mkdir ( ) ; } }	creates directory for cache files if it doesn ' t already exist.
public void input keyevent ( int value ) { execute command quietly ( adb command ( str , str , str , str + value ) ) ; try { thread . sleep ( num ) ; } catch ( interrupted exception e ) { log . warn ( str , e ) ; } }	use adb to send a keyevent to the device.
public static void pass mock sleep ( ) { mock sleep queue . offer ( bool ) ; }	let sleeping thread pass the synchronization point .
private query builder build sort ( ) { query builder builder = new query builder ( ) ; iterator < string > sort iterator = m sorting order list . iterator ( ) ; while ( sort iterator . has next ( ) ) { builder . append ( sort iterator . next ( ) ) ; if ( sort iterator . has next ( ) ) builder . append ( str ) ; } return builder ; }	builds the sort query.
public void init ( int mode , byte [ ] key , byte [ ] iv ) { context = open ssl native . init ( context , mode , algorithm , padding , key , iv ) ; }	initialize this cipher with a key and iv .
private string diff words to chars munge ( string text , list < string > line array , map < string , integer > line hash ) { int line start = num ; int line end = - num ; string line ; string builder chars = new string builder ( ) ; while ( line end < text . length ( ) - num ) { string pattern str = str ; pattern pattern = pattern . compile ( pattern str ) ; matcher matcher = pattern . matcher ( text ) ; matcher . region ( line start , text . length ( ) ) ; if ( matcher . find ( ) ) { line end = matcher . start ( ) ; } else line end = - num ; if ( line end == - num ) { line end = text . length ( ) - num ; } line = text . substring ( line start , line end + num ) ; line start = line end + num ; if ( line hash . contains key ( line ) ) { chars . append ( string . value of ( ( char ) ( int ) line hash . get ( line ) ) ) ; } else { line array . add ( line ) ; line hash . put ( line , line array . size ( ) - num ) ; chars . append ( string . value of ( ( char ) ( line array . size ( ) - num ) ) ) ; } } return chars . to string ( ) ; }	split a text into a list of strings.
private void replace top ( scope top of stack ) { stack . set ( stack . size ( ) - num , top of stack ) ; }	replace the value on the top of the stack with the given value .
public boolean has next ( ) { return index < desc . length ( ) ; }	returns true if the iteration has more elements .
public void register session thread ( session thread new session ) { synchronized ( this ) { list < session thread > to be removed = new array list < session thread > ( ) ; for ( session thread session thread : session threads ) { if ( ! session thread . is alive ( ) ) { log . d ( tag , str ) ; try { session thread . join ( ) ; log . d ( tag , str ) ; to be removed . add ( session thread ) ; session thread . close socket ( ) ; } catch ( interrupted exception e ) { log . d ( tag , str ) ; } } } for ( session thread remove thread : to be removed ) { session threads . remove ( remove thread ) ; } session threads . add ( new session ) ; } log . d ( tag , str ) ; }	the ftpserverservice must know about all running session threads so they can be terminated on exit.
protected i < t > store impl ( segment < t > segment , object info < t > oi ) { if ( invalid ) return null ; size . increment and get ( ) ; segment . increment size ( ) ; object info < t > tail = segment . get tail ( ) ; tail . set forward ref ( oi ) ; oi . set backward ref ( tail ) ; segment . set tail ( oi ) ; return oi ; }	store an element in segment.
public x ( ) { parser = new x ( str , this , bool ) ; }	creates an empty texformula .
public static void gray to binary ( binary variable variable ) { int n = variable . get number of bits ( ) ; bit set gray = variable . get bit set ( ) ; variable . set ( n - num , gray . get ( n - num ) ) ; for ( int i = n - num ; i >= num ; i -- ) { variable . set ( i , variable . get ( i + num ) ^ gray . get ( i ) ) ; } }	converts a binary variable from a gray encoding to binary encoding .
private void update tags ( movie movie ) { list < string > available tags = new array list < > ( tags observable ) ; for ( string tag in movie : new array list < > ( movie . get tags ( ) ) ) { boolean tag found = bool ; for ( string tag : available tags ) { if ( tag in movie . equals ( tag ) ) { tag found = bool ; break ; } } if ( ! tag found ) { add tag ( tag in movie ) ; } } }	update tags used in movies .
protected void remove next protocol messages ( list < protocol message > protocol messages , int from index ) { for ( int i = protocol messages . size ( ) - num ; i >= from index ; i -- ) { protocol messages . remove ( i ) ; } }	in a case the protocol message received was not equal to the messages in our protocol message list , we have to clear our protocol message list .
public static double sigmoid ( double x ) { return num / ( num + math . pow ( math . e , - x ) ) ; }	1 / 1 + exp ( - x ).
public void test radix36 neg ( ) { string value = str ; int radix = num ; big integer a number = new big integer ( value , radix ) ; string result = a number . to string ( radix ) ; assert true ( result . equals ( value ) ) ; }	test negative number of radix 24.
public uci stop ( ) { if ( ! is connected ( ) ) { throw new illegal state exception ( str ) ; } if ( log . is debug enabled ( ) ) { log . debug ( str ) ; } uci result = null ; synchronized ( stop synch ) { if ( ! is processing go ( ) ) { result = last best move ; last best move = null ; } else { long total sleep time = num ; send ( str ) ; while ( go runnable != null && total sleep time < num ) { try { thread . sleep ( num ) ; total sleep time += num ; } catch ( interrupted exception ie ) { } } result = last best move ; last best move = null ; } } return result ; }	stops a go that is in process.
@ override public boolean supports data definition and data manipulation transactions ( ) { debug code call ( str ) ; return bool ; }	returns whether data manipulation and create / drop is supported in transactions .
public static void remove java no op logger ( collection < handler > rmv hnds ) { logger log = logger . get logger ( str ) ; for ( handler h : log . get handlers ( ) ) log . remove handler ( h ) ; if ( ! f . is empty ( rmv hnds ) ) { for ( handler h : rmv hnds ) log . add handler ( h ) ; } }	removes previously added no - op handler for root java logger .
private int binary search ( final int start , final int end , final size tester size tester , final f available space ) { int last best = start ; int low = start ; int high = end - num ; int middle ; while ( low <= high ) { middle = low + high > > > num ; final int mid val cmp = size tester . on test size ( middle , available space ) ; if ( mid val cmp < num ) { last best = low ; low = middle + num ; } else if ( mid val cmp > num ) { high = middle - num ; last best = high ; } else return middle ; } return last best ; }	calculates best text size for current edittext size.
protected boolean is valid domain ( string domain ) { matcher ip domain matcher = ip domain pattern . matcher ( domain ) ; if ( ip domain matcher . matches ( ) ) { inet address validator inet address validator = inet address validator . get instance ( ) ; return inet address validator . is valid ( ip domain matcher . group ( num ) ) ; } domain validator domain validator = domain validator . get instance ( allow local ) ; return domain validator . is valid ( domain ) || domain validator . is valid tld ( domain ) ; }	returns true if the domain component of an email address is valid .
public void test timed invoke any4 ( ) throws throwable { executor service e = new fork join pool ( num ) ; pool cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; long start time = system . nano time ( ) ; list < callable < string > > l = new array list < callable < string > > ( ) ; l . add ( new npe ( ) ) ; try { e . invoke any ( l , long delay ms , milliseconds ) ; should throw ( ) ; } catch ( execution exception success ) { assert true ( success . get cause ( ) instanceof null pointer exception ) ; } assert true ( millis elapsed since ( start time ) < long delay ms ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }	timed invokeany ( c ) throws executionexception if no task completes.
private void parse ( file dir ) { file [ ] xml files = dir . list files ( new xml filter ( ) ) ; for ( file xml file : xml files ) { parse test from xml ( xml file ) ; } }	builds mtestmap based on directory contents.
public boolean has next ( int index ) { for ( int p = num ; p < mask . length ; p ++ ) { if ( mask [ p ] ) { if ( index <= last element index [ p ] ) { return bool ; } } } return bool ; }	returns true if the last possible index stored in lastelementindex for all currently selected partitions is not yet reached.
public static boolean is external storage available ( ) { string state = environment . get external storage state ( ) ; if ( state . equals ( environment . media mounted ) ) { return bool ; } else { return bool ; } }	checks if the external storage is available.
public tar entry ( byte [ ] header buf ) { this ( ) ; parse tar header ( header buf ) ; }	construct an entry from an archive ' s header bytes.
public static void unregister mbeans ( m m bean server ) { try { m bean server . unregister m ( mx . get object name ( ) ) ; m bean server . unregister m ( mx . get object name ( ) ) ; m bean server . unregister m ( mx . get object name ( ) ) ; m bean server . unregister m ( mx . get object name ( ) ) ; m bean server . unregister m ( mx . get object name ( ) ) ; m bean server . unregister m ( mx . get object name ( ) ) ; m bean server . unregister m ( mx . get object name ( ) ) ; unregister gc mx ( m bean server ) ; unregister mbeans from props file ( m bean server ) ; } catch ( exception e ) { throw new runtime exception ( e ) ; } }	unregister all jamon related mbeans.
public static deterministic key create master private key ( byte [ ] seed ) throws hd { check argument ( seed . length > num , str ) ; byte [ ] i = hd . hmac sha512 ( master hmac sh , seed ) ; check state ( i . length == num , i . length ) ; byte [ ] il = arrays . copy of range ( i , num , num ) ; byte [ ] ir = arrays . copy of range ( i , num , num ) ; arrays . fill ( i , ( byte ) num ) ; deterministic key master priv key = create master priv key from bytes ( il , ir ) ; arrays . fill ( il , ( byte ) num ) ; arrays . fill ( ir , ( byte ) num ) ; return master priv key ; }	generates a new deterministic key from the given seed , which can be any arbitrary byte array.
public boolean is nanpa ( string region code ) { return nanpa regions . contains ( region code ) ; }	checks if this is a region under the north american numbering plan administration ( nanpa ) .
public void parse ( input stream in ) throws io , sax { try { xml reader . set input ( in ) ; parse all ( ) ; } catch ( xml e ) { if ( e . get nested exception ( ) instanceof io ) throw ( io ) e . get nested exception ( ) ; throw new sax ( e . get message ( ) ) ; } finally { xml reader . reset ( ) ; } }	parses an xml document from the specified input stream ( encoding retrieved from input source and the xml prolog if any ) .
@ override public void print stack trace ( print stream ps ) { super . print stack trace ( ps ) ; if ( nested != null ) nested . print stack trace ( ps ) ; }	prints the composite message and the embedded stack trace to the specified stream ps .
public am ( char [ ] pw ) { int i ; int length = pw . length ; cleared = bool ; password = new char [ length ] ; system . arraycopy ( pw , num , password , num , length ) ; }	creates a password from a char array , then wipes the char array .
public void reset ( ) { first step = bool ; n3 = num ; n4 = num ; system . arraycopy ( iv , num , ofb v , num , iv . length ) ; byte count = num ; cipher . reset ( ) ; }	reset the feedback vector back to the iv and reset the underlying cipher .
private static img create control button image ( string name , string js command , boolean enabled ) { string buffer img name = new string buffer ( str + name ) ; if ( ! enabled ) img name . append ( str ) ; img name . append ( str ) ; img img = new img ( mobile env . get image directory ( img name . to string ( ) ) , name ) ; if ( enabled ) img . set alt ( msg . get msg ( ad , name ) ) ; img . set id ( str ) ; if ( js command != null && js command . length ( ) > num && enabled ) { img . set on click ( str + form name + str + m + str + name + str + js command ) ; } return img ; }	create image with name , id of button_name and set m_command onclick.
public string [ ] to array ( ) throws exception { return utils . split options ( to command line ( ) ) ; }	returns the current dom document as string array .
public static set < eval factory node > recursive get child nodes ( eval factory node current node , eval node util factory filter filter ) { set < eval factory node > result = new linked hash set < eval factory node > ( ) ; if ( filter . consider ( current node ) ) { result . add ( current node ) ; } recursive get child nodes ( result , current node , filter ) ; return result ; }	returns all child nodes as a set .
void dispose ( ) { if ( popup != null ) { popup . remove all ( ) ; } popup = null ; }	clean up when this object is no longer needed . should not be called while the object is still displayed ; see remove ( ).
@ override public void end prefix mapping ( string str ) throws sax { }	this method does nothing .
@ override public void parse ( final cookie cookie , final string value ) throws malformed cookie exception { if ( cookie == null ) { throw new illegal argument exception ( str ) ; } if ( value == null ) { throw new malformed cookie exception ( str ) ; } int age = - num ; try { age = integer . parse int ( value ) ; } catch ( final number format exception e ) { age = - num ; } if ( age < num ) { throw new malformed cookie exception ( str ) ; } cookie . set expiry date ( new date ( system . current time millis ( ) + age * num ) ) ; }	parse cookie max - age attribute .
public variable config resource ( string configuration , text resource base resource ) { this ( base resource ) ; for ( string configuration line : configuration . split ( str ) ) { string [ ] config split = configuration line . split ( str ) ; add config ( config split [ num ] , config split [ num ] ) ; } }	constructs a textresource that substitutes variables with values in a wrapped textresource.
private static string read file ( string file name ) { string class method = str ; string builder file data = new string builder ( ) ; string file string = str ; try { buffered reader reader = new buffered reader ( new file reader ( file name ) ) ; char [ ] buf = new char [ num ] ; int num read = num ; while ( ( num read = reader . read ( buf ) ) != - num ) { string read data = string . value of ( buf , num , num read ) ; file data . append ( read data ) ; buf = new char [ num ] ; } reader . close ( ) ; file string = file data . to string ( ) ; } catch ( exception e ) { debug . error ( class method + str + file name ) ; } return file string ; }	reads a file into a string .
public io snapshot multi volume ( map < string , string > id2snapshot , string system id ) throws exception { string uri = io . get snapshot volumes uri ( system id ) ; io sp vol = new io ( ) ; for ( map . entry < string , string > entry : id2snapshot . entry set ( ) ) { sp vol . add snapshot ( entry . get key ( ) , entry . get value ( ) ) ; } client response response = post ( uri . create ( uri ) , get json for entity ( sp vol ) ) ; return get response object ( io . class , response ) ; }	create multiple snapshots in a consistency group.
@ override public string to string ( ) { return str + m + str + m + str + m tm . to string ( ) ; }	returns textual description of this estimator .
public boolean is draft ( ) { return draft != null && draft . boolean value ( ) ; }	checks the value of the app : draft tag .
private weather updater ( ) { on turn reached ( num ) ; }	create a new weaterupdater instance.
protected void write data to file ( node holder node holder ) throws carbon data writer exception { long offset = write data to file ( node holder , file channel ) ; blocklet info columnar blocklet info = get blocklet info ( node holder , offset ) ; blocklet info list . add ( blocklet info ) ; }	this method will be used to write leaf data to file file format < key > < measure1 > < measure2 >.
protected container create side navigation component ( vector commands ) { return create side navigation component ( commands , null ) ; }	creates the side navigation component with the commands.
public static double min ( double [ ] a ) { double min = double . positive infinity ; for ( int i = num ; i < a . length ; i ++ ) { if ( double . is na n ( a [ i ] ) ) return double . n ; if ( a [ i ] < min ) min = a [ i ] ; } return min ; }	returns the minimum value in the specified array .
@ override public void on update selection ( int old sel start , int old sel end , int new sel start , int new sel end , int candidates start , int candidates end ) { super . on update selection ( old sel start , old sel end , new sel start , new sel end , candidates start , candidates end ) ; if ( m composing . length ( ) > num && ( new sel start != candidates end || new sel end != candidates end ) ) { m composing . set length ( num ) ; update candidates ( ) ; input connection ic = get current input connection ( ) ; if ( ic != null ) { ic . finish composing text ( ) ; } } }	deal with the editor reporting movement of its cursor .
public < t > t map to ( final class < t > mapping class ) { return map to ( mapping class , null ) ; }	map the structure fields to a class fields .
private array list < spinner language element > create spinner languages ( int avoid language ) { array list < spinner language element > result = new array list < spinner language element > ( ) ; list < string > languages = m session options . all languages ( ) ; for ( int i = num ; i < languages . size ( ) ; ++ i ) { if ( i != avoid language ) { result . add ( new spinner language element ( languages . get ( i ) , i ) ) ; } } return result ; }	determines what languages will be shown in the spinner .
private string user agent ( ) { return m user agent ; }	returns the default user agent.
protected void collect properties ( class < ? > type , type < ? > reference type , map < string , property > properties ) { try { bean info bean info = introspector . get bean info ( type ) ; property descriptor [ ] descriptors = bean info . get property descriptors ( ) ; for ( final property descriptor pd : descriptors ) { try { method read method = get read method ( pd , type ) ; method write method = get write method ( pd , type , null ) ; property property = process property ( pd . get name ( ) , pd . get property type ( ) , read method , write method , type , reference type , properties ) ; post process property ( property , pd , read method , write method , type , reference type , properties ) ; } catch ( final exception e ) { throw new runtime exception ( str + reference type . get canonical name ( ) + str + pd . get name ( ) + str , e ) ; } } } catch ( introspection exception e ) { throw new runtime exception ( e ) ; } }	collects all properties for the specified type .
public void add header view ( view v , object data , boolean is selectable ) { if ( m adapter != null && ! ( m adapter instanceof header view list adapter ) ) { throw new illegal state exception ( str ) ; } fixed view info info = new fixed view info ( ) ; info . view = v ; info . data = data ; info . is selectable = is selectable ; m header view infos . add ( info ) ; if ( m adapter != null && m observer != null ) { m observer . on changed ( ) ; } }	add a fixed view to appear at the top of the list.
private void render operator background ( final operator operator , final d g2 ) { d frame = model . get operator rect ( operator ) ; if ( frame == null ) { return ; } d background = new d . double ( frame . get x ( ) - num , frame . get y ( ) - num , frame . get width ( ) + num , frame . get height ( ) + num , operator bg corner , operator bg corner ) ; g2 . set color ( color . white ) ; g2 . fill ( background ) ; d name bounds = operator font . get string bounds ( operator . get name ( ) , g2 . get font render context ( ) ) ; if ( name bounds . get width ( ) > frame . get width ( ) ) { double relevant width = math . min ( name bounds . get width ( ) , frame . get width ( ) * max header ratio ) ; double offset = ( frame . get width ( ) - relevant width ) / num ; int x = ( int ) ( frame . get x ( ) + offset ) ; int padding = num ; d name background = new d . double ( ( int ) math . min ( frame . get x ( ) - padding , x - padding ) , frame . get y ( ) - num , relevant width + num * padding , process renderer model . header height + num , operator bg corner , operator bg corner ) ; g2 . fill ( name background ) ; } render ports background ( operator . get input ports ( ) , g2 ) ; render ports background ( operator . get output ports ( ) , g2 ) ; }	draws the operator background ( white round rectangle ) .
public void make existing demand bill inactive ( string assessment no ) { demand bill service demand bill service = ( demand bill service ) bean provider . get bean ( str ) ; demand bill service . make demand bill inactive ( assessment no ) ; }	api to make the existing demandbill inactive.
public void write ( data output out ) throws io { writable utils . write v ( out , length ) ; out . write ( bytes , num , length ) ; }	serialize write this object to out length uses zero - compressed encoding.
@ override public int do final ( final byte [ ] out , final int out off ) throws bad ciphertext exception { complete = bool ; int written = content crypto handler . do final ( out , out off ) ; update trailing signature ( out , out off , written ) ; if ( crypto algo . get trailing signature length ( ) > num ) { try { ciphertext footers footer = new ciphertext footers ( trailing sig . sign ( ) ) ; byte [ ] f bytes = footer . to byte array ( ) ; system . arraycopy ( f bytes , num , out , out off + written , f bytes . length ) ; return written + f bytes . length ; } catch ( final signature exception ex ) { throw new aws crypto exception ( ex ) ; } } else { return written ; } }	finish encryption of the plaintext bytes .
public void hide all budges ( ) { for ( relative layout badge : badge list ) { if ( badge . get visibility ( ) == visible ) badge helper . hide badge ( badge ) ; } badge save instance hash map . clear ( ) ; }	hiding all available badges.
public element render ( svg svgp ) { element tag = svgp . svg element ( svg . svg g tag ) ; element button = svgp . svg rect ( x , y , w , h ) ; if ( ! double . is na n ( r ) ) { svg . set att ( button , svg . svg rx attribute , r ) ; svg . set att ( button , svg . svg ry attribute , r ) ; } svg . set att ( button , svg . svg style attribute , butcss . inline css ( ) ) ; tag . append child ( button ) ; if ( svgp . get id element ( svg . light gradient id ) != null ) { element light = svgp . svg rect ( x , y , w , h ) ; if ( ! double . is na n ( r ) ) { svg . set att ( light , svg . svg rx attribute , r ) ; svg . set att ( light , svg . svg ry attribute , r ) ; } svg . set att ( light , svg . svg style attribute , str + svg . light gradient id + str ) ; tag . append child ( light ) ; } if ( svgp . get id element ( svg . shadow id ) != null ) { button . set attribute ( svg . svg filter attribute , str + svg . shadow id + str ) ; } if ( title != null ) { element label = svgp . svg text ( x + w * num , y + h * num , title ) ; label . set attribute ( svg . svg style attribute , titlecss . inline css ( ) ) ; tag . append child ( label ) ; } return tag ; }	produce the actual svg elements for the button .
public void add ( string gram ) { if ( name == null || gram == null ) return ; int len = gram . length ( ) ; if ( len < num || len > n . n gram ) return ; ++ n words [ len - num ] ; if ( freq . contains key ( gram ) ) { freq . put ( gram , freq . get ( gram ) + num ) ; } else { freq . put ( gram , num ) ; } }	add n - gram to profile.
public void test addressing ( ) { final journal store = ( journal ) get store ( ) ; try { final rw buffer strategy = ( rw ) store . get buffer strategy ( ) ; final rw rw = buffer strategy . get store ( ) ; final array list < integer > sizes = new array list < integer > ( ) ; final tree map < long , integer > paddrs = new tree map < long , integer > ( ) ; for ( int i = num ; i < num ; i ++ ) { final int s = r . next int ( num ) + num ; sizes . add ( s ) ; final int a = rw . alloc ( s , null ) ; final long pa = rw . physical address ( a ) ; assert true ( paddrs . get ( pa ) == null ) ; paddrs . put ( pa , a ) ; } for ( int i = num ; i < num ; i ++ ) { final int s = r . next int ( num ) + num ; sizes . add ( s ) ; final int a = rw . alloc ( s , null ) ; final long pa = rw . physical address ( a ) ; paddrs . put ( pa , a ) ; } } finally { store . destroy ( ) ; } }	ensures the allocation of unique addresses by mapping allocated address with uniqueness assertion against physical address .
public void handle client membership ( string client id , int event type ) { string notif type = null ; list < managed resource > cleaned up = null ; if ( event type == client membership message . left ) { notif type = notif client left ; cleaned up = cleanup bridge client resources ( client id ) ; } else if ( event type == client membership message . crashed ) { notif type = notif client crashed ; cleaned up = cleanup bridge client resources ( client id ) ; } else if ( event type == client membership message . joined ) { notif type = notif client joined ; } if ( cleaned up != null ) { for ( managed resource resource : cleaned up ) { m . unregister m ( resource ) ; } } helper . send notification ( this , new notification ( notif type , this . model m , helper . get next notification sequence number ( ) , client id ) ) ; }	implementation handles client membership changes .
public < v extends comparable < ? super v > > optional double max by ( double function < v > key extractor ) { obj double box < v > result = collect ( null , null , null ) ; return result . a == null ? optional double . empty ( ) : optional double . of ( result . b ) ; }	returns the maximum element of this stream according to the provided key extractor function.
private j add keybind label ( j panel , string label text ) { grid bag constraints gbc = new grid bag constraints ( ) ; gbc . anchor = grid bag constraints . west ; gbc . insets = new insets ( num , num , num , num ) ; gbc . gridx = num ; gbc . gridy = keybind label grid y ++ ; gbc . weightx = num ; j jlbl = new j ( label text ) ; panel . add ( jlbl , gbc ) ; return jlbl ; }	adds a new label to the keybinds list.
public static boolean is letter or number ( int c ) { return is letter ( c ) || is number ( c ) ; }	checks whether the supplied character is a letter or number according to the n - triples specification .
public string season summary str ( ) { set team ranks ( ) ; string builder sb = new string builder ( ) ; sb . append ( ncg summary str ( ) ) ; sb . append ( str + user team . season summary str ( ) ) ; sb . append ( str + league records . broken records str ( get year ( ) , user team . abbr ) ) ; return sb . to string ( ) ; }	get summary of season .
public void add end bumper ( ) { num end bumpers ++ ; string name = str ; boolean duplicate = bool ; while ( duplicate ) { name = str + num end bumpers ; if ( finder . find positionable point by name ( name ) == null ) { duplicate = bool ; } if ( duplicate ) { num end bumpers ++ ; } } positionable point o = new positionable point ( name , positionable point . end bumper , current point , this ) ; point list . add ( o ) ; set dirty ( bool ) ; }	add an end bumper point .
public int pixel for ( color c ) { return pixel for ( c . get rgb ( ) ) ; }	returns the pixel data for the specified color packed into an integer for easy storage and conveyance.
void strip non compiled nodes ( node n , set < string > files to compile ) { for ( node child : n . children ( ) ) { if ( ! files to compile . contains ( child . get source file name ( ) ) ) { child . detach from parent ( ) ; } } }	removes the root nodes for all the library files from the source node .
protected void restore base uri ( ) { f base uri . pop ( ) ; f literal system id . pop ( ) ; f expanded system id . pop ( ) ; f base uri . pop ( ) ; f current base uri . set base system id ( ( string ) f base uri . peek ( ) ) ; f current base uri . set literal system id ( ( string ) f literal system id . peek ( ) ) ; f current base uri . set expanded system id ( ( string ) f expanded system id . peek ( ) ) ; }	discards the uris at the top of the stack , and restores the ones beneath it .
public void test to big integer pos1 ( ) { string a = str ; big integer b number = new big integer ( str ) ; big decimal a number = new big decimal ( a ) ; big integer result = a number . to big integer ( ) ; assert true ( str , result . equals ( b number ) ) ; }	convert a positive bigdecimal to biginteger.
public static boolean as boolean ( char sequence string ) { return string . length ( ) > num ; }	coerce a string ( an instance of charsequence ) to a boolean value.
public void initialize ( ) { texture state ts = new texture state ( ) ; ts . set enabled ( bool ) ; set render state ( ts ) ; for ( int i = num ; i < landmark list . size ( ) ; ++ i ) { landmark state state = landmark list . get ( i ) ; add landmark ( state , bool ) ; } z buffer state = new z ( ) ; z buffer state . set function ( z . test function . less than or equal to ) ; z buffer state . set enabled ( bool ) ; set render state ( z buffer state ) ; }	initialize this object create landmark objects.
public list < jc > enter trees ( list < jc > roots ) { if ( ! task listener . is empty ( ) ) { for ( jc unit : roots ) { task event e = new task event ( task event . kind . enter , unit ) ; task listener . started ( e ) ; } } enter . main ( roots ) ; if ( ! task listener . is empty ( ) ) { for ( jc unit : roots ) { task event e = new task event ( task event . kind . enter , unit ) ; task listener . finished ( e ) ; } } if ( need root classes || source output || stub output ) { list buffer < jc > cdefs = new list buffer < > ( ) ; for ( jc unit : roots ) { for ( list < jc > defs = unit . defs ; defs . non empty ( ) ; defs = defs . tail ) { if ( defs . head instanceof jc ) cdefs . append ( ( jc ) defs . head ) ; } } root classes = cdefs . to list ( ) ; } for ( jc unit : roots ) { input files . add ( unit . sourcefile ) ; } return roots ; }	enter the symbols found in a list of parse trees.
public static line by line file input operator checkpoint ( line by line file input operator oper , byte array output stream bos ) throws exception { kryo kryo = new kryo ( ) ; output loutput = new output ( bos ) ; kryo . write object ( loutput , oper ) ; loutput . close ( ) ; input l input = new input ( bos . to byte array ( ) ) ; @ suppress warnings ( str ) line by line file input operator check pointed oper = kryo . read object ( l input , oper . get class ( ) ) ; l input . close ( ) ; return check pointed oper ; }	this method checkpoints the given operator .
public static string explode ( collection < string > collection , string delimiter ) { string builder sb = new string builder ( ) ; if ( ! collection . is empty ( ) ) { iterator < string > i = collection . iterator ( ) ; sb . append ( i . next ( ) ) ; while ( i . has next ( ) ) { sb . append ( delimiter ) ; sb . append ( i . next ( ) ) ; } } return sb . to string ( ) ; }	returns the tokens of a collection concanated to a delimited by the given delimiter .
public static void write statistics ( t < descriptive statistics > stats map , string key label , string file ) throws io { double [ ] keys = stats map . keys ( ) ; arrays . sort ( keys ) ; buffered writer writer = new buffered writer ( new file writer ( file ) ) ; writer . write ( key label ) ; writer . write ( tab ) ; writer . write ( str ) ; writer . write ( tab ) ; writer . write ( str ) ; writer . write ( tab ) ; writer . write ( str ) ; writer . write ( tab ) ; writer . write ( str ) ; writer . write ( tab ) ; writer . write ( str ) ; writer . new line ( ) ; for ( double key : keys ) { descriptive statistics stats = stats map . get ( key ) ; writer . write ( string . value of ( key ) ) ; writer . write ( tab ) ; writer . write ( string . value of ( stats . get mean ( ) ) ) ; writer . write ( tab ) ; writer . write ( string . value of ( stats . get percentile ( num ) ) ) ; writer . write ( tab ) ; writer . write ( string . value of ( stats . get min ( ) ) ) ; writer . write ( tab ) ; writer . write ( string . value of ( stats . get max ( ) ) ) ; writer . write ( tab ) ; writer . write ( string . value of ( stats . get n ( ) ) ) ; writer . new line ( ) ; } writer . close ( ) ; }	writes a table with columns map - key and statistical indicators mean , median , min , max and number of samples.
public void action performed ( action event e ) { if ( ! check modified ( ) ) return ; if ( m . get filename ( ) == null ) return ; try { m . start ( m ) ; } catch ( exception ex ) { ex . print stack trace ( ) ; j . show message dialog ( file scripting panel . this , str + ex , str , j . error message ) ; } }	fired when action got executed .
static string encode stub ( rmi rmi server , map < string , ? > env ) throws io { if ( iiop . is stub ( rmi server ) ) return str + encode iiop ( rmi server , env ) ; else return str + encode jrmp ( rmi server , env ) ; }	returns the ior of the given rmiserver .
public int line to y ( int line ) { font metrics fm = painter . get font metrics ( ) ; return ( line - first line ) * fm . get height ( ) - ( fm . get leading ( ) + fm . get max descent ( ) ) ; }	converts a line index to a y co - ordinate .
private void handle double click ( double click event e ) { i selection = e . get selection ( ) ; if ( selection instanceof i ) { i structured = ( i ) selection ; if ( structured . size ( ) == num ) { object first = structured . get first element ( ) ; if ( first instanceof isvn ) { open action . selection changed ( null , selection ) ; open action . run ( null ) ; } else { tree viewer . set expanded state ( first , ! tree viewer . get expanded state ( first ) ) ; } } } }	the mouse has been double - clicked in the tree , perform appropriate behaviour .
public csv ( ) { }	this will create a completely empty result set configuration.
protected file choose file ( int type ) { frame frame = get frame ( ) ; file f = null ; if ( file chooser == null ) file chooser = new j ( ) ; file chooser . set current directory ( e00 file ) ; if ( type == num ) file chooser . set dialog type ( j . open dialog ) ; else file chooser . set dialog type ( j . save dialog ) ; int retval = file chooser . show dialog ( frame , null ) ; if ( retval == j . approve option ) f = file chooser . get selected file ( ) ; return f ; }	description of the method.
public void pixellate ( font render context render frc , d loc , point px result ) { if ( render frc == null ) { render frc = frc ; } affine transform at = render frc . get transform ( ) ; at . transform ( loc , loc ) ; px result . x = ( int ) loc . get x ( ) ; px result . y = ( int ) loc . get y ( ) ; loc . set location ( px result . x , px result . y ) ; try { at . inverse transform ( loc , loc ) ; } catch ( noninvertible transform exception e ) { throw new illegal argument exception ( str ) ; } }	! ! ! not used currently , but might be by getpixelbounds ?.
public static long start time ( ) { return system . nano time ( ) ; }	get a start time .
@ transactional public int delete all ( ) { list < t > all entities = retrieve all ( ) ; for ( t entity : all entities ) { delete ( entity ) ; } return all entities . size ( ) ; }	deletes all instances of class t in the database .
private gs receive from queue ( long timeout ) throws receive from queue exception { transaction txn = m session . get transaction ( ) ; if ( logger . is loggable ( level . fine ) ) { logger . log ( level . fine , str + txn ) ; } try { return ( gs ) m space . take ( m jms message template , txn , timeout ) ; } catch ( exception e ) { throw new receive from queue exception ( e ) ; } }	retrieves a message from the queue .
public string find next ( boolean previous flipped ) { boolean reset is flipped = bool ; if ( previous flipped && count > num ) { if ( ! value iterator . has next ( ) ) { value iterator = values . iterator ( ) ; index = num ; is flipped = bool ; reset is flipped = bool ; } else { index ++ ; } current value = value iterator . next ( ) ; } count ++ ; if ( reset is flipped ) { is flipped = bool ; } return current value ; }	find the next value of the value chain .
public static boolean is not empty ( list < object > list ) { return ! list . is empty ( ) ; }	returns true if list if not empty .
private registration result check password ( string password , string confirm password ) { if ( ( password == null ) || password . length ( ) == num ) { if ( debug . message enabled ( ) ) { debug . message ( str ) ; } return registration result . no password error ; } else { if ( password . length ( ) < required password length ) { if ( debug . message enabled ( ) ) { debug . message ( str ) ; } return registration result . password too short ; } if ( ( confirm password == null ) || confirm password . length ( ) == num ) { if ( debug . message enabled ( ) ) { debug . message ( str ) ; } return registration result . no confirmation error ; } else { if ( ! password . equals ( confirm password ) ) { return registration result . password mismatch error ; } } } return registration result . no error ; }	checks the passwords and returned error state or succeeded if the passwords are valid .
private static ldap create and ( filter set filter set ) throws ldap , io { list < jaxb < ? > > list = filter set . get filter group ( ) ; array list < raw filter > filters = new array list < > ( list . size ( ) ) ; for ( jaxb < ? > filter : list ) { filters . add ( create filter ( filter ) ) ; } return ldap . create and ( filters ) ; }	returns a new and search filter with the provided filter components .
void calculate utility ( firing plan firing plan , int overheat tolerance , boolean shooter is aero ) { int overheat = num ; if ( firing plan . get heat ( ) > overheat tolerance ) { overheat = firing plan . get heat ( ) - overheat tolerance ; } double modifier = num ; modifier += calc command utility ( firing plan . get target ( ) ) ; modifier += calc strategic building target utility ( firing plan . get target ( ) ) ; modifier += calc priority unit target utility ( firing plan . get target ( ) ) ; double utility = num ; utility += damage utility * firing plan . get expected damage ( ) ; utility += critical utility * firing plan . get expected criticals ( ) ; utility += kill utility * firing plan . get kill probability ( ) ; utility *= calc target potential damage multiplier ( firing plan . get target ( ) ) ; utility += target hp fraction dealt utility * calc damage allocation utility ( firing plan . get target ( ) , firing plan . get expected damage ( ) ) ; utility -= calc civilian target disutility ( firing plan . get target ( ) ) ; utility *= modifier ; utility -= ( shooter is aero ? overheat disutility aero : overheat disutility ) * overheat ; utility -= ( firing plan . get target ( ) instanceof mech warrior ) ? ejected pilot disutility : num ; firing plan . set utility ( utility ) ; }	calculates the ' utility ' of a firing plan . override this function if you have a better idea about what firing plans are good.
public void put ( string key , double value ) { if ( value == double . positive infinity ) { put ( key , str ) ; } else if ( value == double . negative infinity ) { put ( key , str ) ; } else { put ( key , double . to string ( value ) ) ; } }	associates the specified double value with the specified key in this map.
public void test fill fiif ( ) { float val = float . max value ; float d [ ] = new float [ num ] ; arrays . fill ( d , num , d . length , val ) ; for ( int i = num ; i < num ; i ++ ) assert true ( str , ! ( d [ i ] == val ) ) ; for ( int i = num ; i < d . length ; i ++ ) assert true ( str , d [ i ] == val ) ; try { arrays . fill ( d , num , num , val ) ; fail ( str ) ; } catch ( illegal argument exception e ) { } try { arrays . fill ( d , - num , num , val ) ; fail ( str ) ; } catch ( array index out of bounds exception e ) { } try { arrays . fill ( d , num , d . length + num , val ) ; fail ( str ) ; } catch ( array index out of bounds exception e ) { } }	java . util . arrays # fill ( float [ ] , int , int , float ).
public static long persian to julian ( long year , int month , int day ) { return num * ( ( ceil ( year - num , num ) + num ) - num ) + ( ( long ) math . floor ( ( num * ( ceil ( year - num , num ) + num ) - num ) / num ) ) + ( persian calendar constants . persian epoch - num ) + num * ( ( long ) math . floor ( ( year - num ) / num ) ) + ( month < num ? num * month : num * month + num ) + day ; }	converts a provided persian ( shamsi ) date to the julian day number ( i.
@ override public void mouse dragged ( mouse event evt ) { int x trans = num ; int y trans = num ; if ( slider . get snap to ticks ( ) ) { int pos = get location for value ( get snapped value ( evt ) ) ; if ( pos > - num ) { if ( slider . get orientation ( ) == j . horizontal ) { x trans = pos - evt . get x ( ) + offset ; evt . translate point ( x trans , num ) ; } else { y trans = pos - evt . get y ( ) + offset ; evt . translate point ( num , y trans ) ; } } } delegate . mouse dragged ( evt ) ; evt . translate point ( x trans , y trans ) ; }	implements the actual ' snap while dragging ' behaviour.
@ override final node < k , v > find ( int h , object k ) { if ( k != null ) { for ( node < k , v > e = first ; e != null ; e = e . next ) { int s ; k ek ; if ( ( ( s = lock state ) & ( waiter | writer ) ) != num ) { if ( e . hash == h && ( ( ek = e . key ) == k || ( ek != null && k . equals ( ek ) ) ) ) return e ; } else if ( u . compare and swap int ( this , lockstate , s , s + reader ) ) { tree node < k , v > r , p ; try { p = ( ( r = root ) == null ? null : r . find tree node ( h , k , null ) ) ; } finally { thread w ; int ls ; do { } while ( ! u . compare and swap int ( this , lockstate , ls = lock state , ls - reader ) ) ; if ( ls == ( reader | waiter ) && ( w = waiter ) != null ) lock support . unpark ( w ) ; } return p ; } } } return null ; }	returns matching node or null if none.
public void stop enumeration ( enumeration deletion context aws ) { aws . compute enumeration request . enumeration action = enumeration action . stop ; handle enumeration request for deletion ( aws ) ; }	signals enumeration stop to the aws enumeration adapter.
public static void do restart ( context c ) { try { if ( c != null ) { package manager pm = c . get package manager ( ) ; if ( pm != null ) { intent m start activity = pm . get launch intent for package ( c . get package name ( ) ) ; if ( m start activity != null ) { m start activity . add flags ( intent . flag activity clear top ) ; int m pending intent id = num ; pending intent m pending intent = pending intent . get activity ( c , m pending intent id , m start activity , pending intent . flag cancel current ) ; alarm manager mgr = ( alarm manager ) c . get system service ( context . alarm service ) ; mgr . set ( alarm manager . rtc , system . current time millis ( ) + num , m pending intent ) ; system . exit ( num ) ; } else { log . e ( str , str ) ; } } else { log . e ( str , str ) ; } } else { log . e ( str , str ) ; } } catch ( exception ex ) { log . e ( str , str ) ; } }	restarts the current application.
public collection < object > values ( ) { array list < object > answer = new array list < object > ( read methods . size ( ) ) ; for ( iterator < object > iter = value iterator ( ) ; iter . has next ( ) ; ) { answer . add ( iter . next ( ) ) ; } return collections . unmodifiable list ( answer ) ; }	returns the values for the beanmap .
protected date time data parse ( string str ) throws schema date time exception { date time data date = new date time data ( str , this ) ; int len = str . length ( ) ; int end = get year month ( str , num , len , date ) ; date . day = day ; parse time zone ( str , end , len , date ) ; validate date time ( date ) ; save unnormalized ( date ) ; if ( date . utc != num && date . utc != str ) { normalize ( date ) ; } date . position = num ; return date ; }	parses , validates and computes normalized version of gyearmonth object.
public array val ( double [ ] values ) { this . array = new double [ values . length ] ; for ( int i = num ; i < array . length ; i ++ ) { array [ i ] = values [ i ] ; } hashcode = arrays . hash code ( array ) ; }	creates a new array of doubles.
public void add child ( string child ) { if ( child == null ) { return ; } string child path = path . ends with ( str ) ? path + child : path + str + child ; children . add ( new zk node ( child path ) ) ; }	input is child name , not full path.
@ visible for testing public static boolean send to t ( string command , string topology name , scheduler state manager adaptor state manager , network utils . tunnel config tunnel config ) { log . fine ( str + topology name ) ; topology master . t location = state manager . get t ( topology name ) ; if ( location == null ) { log . severe ( str + topology name ) ; return bool ; } log . fine ( str + topology name ) ; string url = string . format ( str , location . get host ( ) , location . get controller port ( ) , command , location . get topology id ( ) ) ; try { url endpoint = new url ( url ) ; log . fine ( str + endpoint ) ; return send get request ( endpoint , command , tunnel config ) ; } catch ( url e ) { throw new runtime exception ( str + url , e ) ; } }	communicate with tmaster with command.
public static string from doc2 string ( document doc ) throws exception { k serializer = new k ( ) ; byte array output stream bos = new byte array output stream ( ) ; data output stream dos = new data output stream ( bos ) ; try { serializer . set feature ( str , bool ) ; serializer . set output ( dos , xform constants . default character encoding ) ; doc . write ( serializer ) ; serializer . flush ( ) ; } catch ( exception e ) { e . print stack trace ( ) ; return null ; } return new string ( bos . to byte array ( ) , xform constants . default character encoding ) ; }	converts an xml document to a string .
public int add order term ( generic value order term ) { order terms . add ( order term ) ; return order terms . index of ( order term ) ; }	add an orderterm to the order.
public string to string ( ) { string builder string builder = new string builder ( ) ; for ( validation error object error : errors ) { string builder . append ( error . to string ( ) ) ; } return string builder . to string ( ) ; }	a method that returns a string representation of a validationeventhandlerimpl object.
public static observable string value decision ( observable boolean value condition , observable string value if true , observable string value if false ) { string property ret = new simple string property ( ) ; condition . add listener ( null ) ; if true . add listener ( null ) ; if false . add listener ( null ) ; ret . set ( condition . get ( ) ? if true . get ( ) : if false . get ( ) ) ; return ret ; }	returns a new observable string which contains either the contents of iftrue , or iffalse , depending on the condition.
public static final boolean read from stream ( input stream in , byte [ ] buf , int offset , int len ) throws io { int total bytes read = num ; while ( total bytes read < len ) { int bytes read = in . read ( buf , offset + total bytes read , len - total bytes read ) ; if ( bytes read < num ) { return bool ; } total bytes read += bytes read ; } return bool ; }	read from input stream and fill the given buffer from the given offset up to length len .
public static field find static field ( class < ? > type , string name ) throws no such field exception { field field = find field ( type , name ) ; if ( ! modifier . is static ( field . get modifiers ( ) ) ) { throw new no such field exception ( str + name + str ) ; } return field ; }	finds public static field that is declared in public class .
public void new braces ( editor state editor state , char ch ) { string cas name = argument helper . read characters ( editor state ) ; if ( ch == function open key && meta model . is general ( cas name ) ) { del characters ( editor state , cas name . length ( ) ) ; new function ( editor state , cas name ) ; } else if ( ch == function open key && meta model . is function ( cas name ) ) { del characters ( editor state , cas name . length ( ) ) ; new function ( editor state , cas name ) ; } else { new array ( editor state , num , ch ) ; } }	insert braces ( ) , [ ] , { } , " " .
@ override public xid [ ] recover ( int flag ) throws xa { debug code call ( str , quote flags ( flag ) ) ; check open ( ) ; try ( statement stat = physical conn . create statement ( ) ) { result set rs = stat . execute query ( str + str ) ; array list < xid > list = new . array list ( ) ; while ( rs . next ( ) ) { string tid = rs . get string ( str ) ; int id = get next id ( xid ) ; xid xid = new jdbc xid ( factory , id , tid ) ; list . add ( xid ) ; } rs . close ( ) ; xid [ ] result = new xid [ list . size ( ) ] ; list . to array ( result ) ; if ( list . size ( ) > num ) { prepared = bool ; } return result ; } catch ( sql e ) { xa xa = new xa ( xa . xaer rmerr ) ; xa . init cause ( e ) ; throw xa ; } }	get the list of prepared transaction branches.
public void bind ( texture texture ) { faces . for each ( null ) ; }	binds all the faces and all child models with this texture .
public final void clear password ( ) { arrays . fill ( password , str ) ; password = null ; }	clears the password by overwriting it .
private static int new char array ( jni env , int length ) { if ( trace jni ) vm . sys write ( str ) ; runtime entrypoints . check jni gc ( ) ; try { char [ ] new array = new char [ length ] ; return env . push jni ( new array ) ; } catch ( throwable unexpected ) { if ( trace jni ) unexpected . print stack trace ( system . err ) ; env . record exception ( unexpected ) ; return num ; } }	newchararray : create a new char array.
private void init quad program ( ) { gl use program ( quad program ) ; int tex uniform = gl get uniform location ( quad program , str ) ; gl uniform1i ( tex uniform , num ) ; gl use program ( num ) ; }	initialize the full - screen - quad program .
public void put ( e e ) throws interrupted exception { if ( e == null ) throw new null pointer exception ( ) ; int c = - num ; node < e > node = new node < e > ( e ) ; final reentrant lock put lock = this . put lock ; final atomic integer count = this . count ; put lock . lock interruptibly ( ) ; try { while ( count . get ( ) == capacity ) { not full . await ( ) ; } enqueue ( node ) ; c = count . get and increment ( ) ; if ( c + num < capacity ) not full . signal ( ) ; } finally { put lock . unlock ( ) ; } if ( c == num ) signal not empty ( ) ; }	inserts the specified element at the tail of this queue , waiting if necessary for space to become available .
public static boolean log file zipped ( string file ) { return file . ends with ( str ) || file . ends with ( str ) || file . ends with ( str ) ; }	check for a compressed file extension - for now ,.
private void validate has checksum file ( file archive file ) throws invalid archive update exception { try { resolve checksum file ( extract file to directory ( archive file , checksums file in openidm ) ) ; } catch ( exception e ) { throw new invalid archive update exception ( archive file . get name ( ) , str + archive file . get name ( ) + str , e ) ; } }	check if the checksums file in the zip file is present and can be resolved .
protected string rats problem ( ) { final string text = str + str ; return ( text ) ; }	red alert ! rats in the ados city !.
public class < ? > lookup entity class ( class < ? > obj class ) { for ( class < ? > cls = obj class ; cls != null ; cls = cls . get superclass ( ) ) { if ( entity bindings . contains key ( cls ) || cls . is annotation present ( entity . class ) ) { return cls ; } } throw new illegal argument exception ( str + obj class ) ; }	follow for this class or super - class for entity annotation .
private boolean is whitespace ( int position ) { if ( len >= num && position >= len ) { return bool ; } return character . is whitespace ( working [ position ] ) ; }	checks if character at specified position is whitespace .
private void collect wrapper classes ( class loader cl , string pkg , file file ) throws exception { for ( file f : file . list files ( ) ) { if ( f . is directory ( ) ) { collect wrapper classes ( cl , pkg + f . get name ( ) + str , f ) ; } else { add wrapper class to wrapper classes list ( cl , pkg , f ) ; } } }	walk package tree for collecting wrapper classes .
public void clear images ( ) { chunks . clear ( ) ; markers . clear ( ) ; redraw ( bool ) ; shift x = num ; shift y = num ; zoom level pos = num ; zoom level = num ; }	clears all the images in the preview .
public void test fill jiij ( ) { long d [ ] = new long [ num ] ; arrays . fill ( d , num , d . length , long . max value ) ; for ( int i = num ; i < num ; i ++ ) assert true ( str , ! ( d [ i ] == long . max value ) ) ; for ( int i = num ; i < d . length ; i ++ ) assert true ( str , d [ i ] == long . max value ) ; try { arrays . fill ( d , num , num , long . min value ) ; fail ( str ) ; } catch ( illegal argument exception e ) { } try { arrays . fill ( d , - num , num , long . max value ) ; fail ( str ) ; } catch ( array index out of bounds exception e ) { } try { arrays . fill ( d , num , d . length + num , long . max value ) ; fail ( str ) ; } catch ( array index out of bounds exception e ) { } }	java . util . arrays # fill ( long [ ] , int , int , long ).
private static void add component ( final j panel , final component component , final string description , final string hint ) { final j setting panel = new j ( new border layout ( ) ) ; setting panel . set border ( standard empty border ) ; setting panel . add ( new j ( description ) , border layout . center ) ; final j inner panel = new j ( new border layout ( ) ) ; inner panel . add ( component , border layout . center ) ; final j hint popup = new j ( hint ) ; hint popup . set border ( new empty border ( num , num , num , num ) ) ; inner panel . add ( hint popup , border layout . east ) ; setting panel . add ( inner panel , border layout . east ) ; panel . add ( setting panel ) ; }	adds a component that is used to configure a setting .
public reversed lines file reader ( final file file , final int block size , final string encoding ) throws io { this ( file , block size , charsets . to charset ( encoding ) ) ; }	creates a reversedlinesfilereader with the given block size and encoding .
private void on connect ( ) { connection state = connection state . connected ; check for updated flight = bool ; subscribe ( string . format ( traffic alert channel , flight id ) ) ; subscribe ( string . format ( situational awareness channel , flight id ) ) ; }	when connected , subscribe to the necessary channels to get properly notified.
public static double cdf ( double x , double sigma ) { if ( x <= num ) { return num ; } final double xs = x / sigma ; return num - math . exp ( - num * xs * xs ) ; }	cdf of rayleigh distribution.
public double gaussian shortfall ( double target ) { final cumulative normal distribution g integral = new cumulative normal distribution ( mean ( ) , standard deviation ( ) ) ; return g integral . op ( target ) ; }	gaussian - assumption shortfall ( observations below target ).
@ override public int read ( char ch [ ] , int offset , int length ) throws io { int byte length = length << num ; if ( byte length > f buffer . length ) { byte length = f buffer . length ; } int byte count = f input stream . read ( f buffer , num , byte length ) ; if ( byte count == - num ) { return - num ; } if ( ( byte count & num ) != num ) { int b = f input stream . read ( ) ; if ( b == - num ) { expected two bytes ( ) ; } f buffer [ byte count ++ ] = ( byte ) b ; } final int char count = byte count > > num ; if ( f is big endian ) { process be ( ch , offset , char count ) ; } else { process le ( ch , offset , char count ) ; } return char count ; }	read characters into a portion of an array.
public static void end wrapper ( writer writer ) throws io { writer . write ( str ) ; writer . write ( str ) ; writer . write ( str ) ; writer . write ( str ) ; writer . write ( str ) ; }	writes the ending of the wrapper function for a js module .
protected document create configuration document ( av params ) { document doc = super . create configuration document ( params ) ; if ( doc == null || doc . get document element ( ) == null ) return doc ; data configuration utils . create wms ( params , doc . get document element ( ) ) ; return doc ; }	appends wms basic elevation model configuration elements to the superclass configuration document .
public void register callback ( string challenge , challenge callback plugin plugin , http message attack ) { clean expired callbacks ( ) ; reg callbacks . put ( challenge , new registered callback ( plugin , attack ) ) ; }	registers a new zap api challenge .
public static double min ( array array ) throws page exception { if ( array . get dimension ( ) > num ) throw new expression exception ( str ) ; if ( array . size ( ) == num ) return num ; double rtn = to double value ( array , num ) ; int len = array . size ( ) ; try { for ( int i = num ; i <= len ; i ++ ) { double v = to double value ( array , i ) ; if ( rtn > v ) rtn = v ; } } catch ( page exception e ) { throw new expression exception ( str + e . get message ( ) ) ; } return rtn ; }	the smallest value , of all values inside the array , only work when all values are numeric.
public static byte [ ] write to array ( ns root ) throws io { byte array output stream bout = new byte array output stream ( ) ; write ( bout , root ) ; return bout . to byte array ( ) ; }	writes a binary plist serialization of the given object as the root into a byte array .
private static void load library resource ( string resource subdirectory name , string library name , string temp subdirectory name , string ... dependent library names ) throws throwable { for ( string dependent library name : dependent library names ) { logger . log ( level , str + library name + str + dependent library name ) ; string dependent resource subdirectory name = resource subdirectory name + str + os string ( ) + str + arch string ( ) ; string dependent library temp sub directory name = library name + str + file . separator + os string ( ) + file . separator + arch string ( ) + file . separator ; load library resource ( dependent resource subdirectory name , dependent library name , dependent library temp sub directory name ) ; } string library file name = create library file name ( library name ) ; file library temp file = create temp file ( temp subdirectory name , library file name ) ; if ( ! library temp file . exists ( ) ) { string library resource name = resource subdirectory name + str + library file name ; logger . log ( level , str + library resource name ) ; logger . log ( level , str + library temp file ) ; write resource to file ( library resource name , library temp file ) ; } logger . log ( level , str + library temp file ) ; system . load ( library temp file . to string ( ) ) ; logger . log ( level , str + library temp file + str ) ; }	load the library with the given name from a resource .
private job definition create job definition ( ) throws exception { namespace dao test helper . create namespace entity ( test activiti namespace cd ) ; job definition create request request = job definition service test helper . create job definition create request ( ) ; job definition job definition = job definition service . create job definition ( request , bool ) ; validate job definition ( job definition ) ; return job definition ; }	creates a new standard job definition .
private web socket input stream open input stream ( socket socket ) throws web socket exception { try { return new web socket input stream ( new buffered input stream ( socket . get input stream ( ) ) ) ; } catch ( io e ) { throw new web socket exception ( web socket error . socket input stream failure , str + e . get message ( ) , e ) ; } }	open the input stream of the websocket connection.
@ override protected void draw first pass shape ( d g2 , int pass , int series , int item , shape shape ) { if ( is shadow pass ( pass ) ) { if ( get wall paint ( ) != null ) { g2 . set stroke ( get item stroke ( series , item ) ) ; g2 . set paint ( get wall paint ( ) ) ; g2 . translate ( get x ( ) , get y ( ) ) ; g2 . draw ( shape ) ; g2 . translate ( - get x ( ) , - get y ( ) ) ; } } else { super . draw first pass shape ( g2 , pass , series , item , shape ) ; } }	overrides the method in the subclass to draw a shadow in the first pass .
public static double as double ( string str , double def ) { try { return double . parse double ( str ) ; } catch ( number format exception e ) { return def ; } }	parse string to double , if string can ' t be parsed to double , then it will return given default value .
public j create help menu ( ) { show help action help action = new show help action ( str ) ; j help menu = new j ( str ) ; help menu . add ( help action ) ; return help menu ; }	create and return a new help menu for this network panel .
public static void expand digits ( string number string , word relation word relation , item token item ) { int number digits = number string . length ( ) ; for ( int i = num ; i < number digits ; i ++ ) { char digit = number string . char at ( i ) ; if ( is digit ( digit ) ) { word relation . add word ( token item , digit2num [ number string . char at ( i ) - str ] ) ; } else { word relation . add word ( token item , str ) ; } } }	expands given token to list of words pronouncing it as digits.
public string longest match ( string input ) { trie node node = root ; string result = null ; for ( int i = input . length ( ) - num ; i >= num ; i -- ) { node = node . get child ( input . char at ( i ) ) ; if ( node == null ) break ; if ( node . is terminal ( ) ) result = input . substring ( i ) ; } return result ; }	returns the longest suffix of < code > input < code > that is matched , or < code > null < code > if no match exists .
public void test map sub class ( ) throws exception { object mapper mapper = new object mapper ( ) ; map sub class result = mapper . read value ( str , map sub class . class ) ; assert equals ( num , result . size ( ) ) ; object value = result . get ( str ) ; assert equals ( boolean wrapper . class , value . get class ( ) ) ; boolean wrapper bw = ( boolean wrapper ) value ; assert equals ( boolean . true , bw . b ) ; }	verifying that sub - classing works ok wrt generics information.
@ override public void remove property change listener ( property change listener pcl ) { m pcs . remove property change listener ( pcl ) ; }	remove a property change listener.
public void add on tag click listener ( tags click listener listener ) { if ( click listeners == null ) { click listeners = new array list < > ( ) ; } click listeners . add ( listener ) ; }	adding single item click listener.
public void remove all tracking icons ( ) { if ( tracking icons != null && tracking icons . size ( ) > num ) { tracking icons . clear ( ) ; repaint ( ) ; } }	removes all tracking icons .
private void read reference ( ) { array list < string > v value = new array list < string > ( ) ; array list < string > v name = new array list < string > ( ) ; array list < string > v description = new array list < string > ( ) ; document engine . read reference list ( v value , v name , v description ) ; int size = v value . size ( ) ; s value = new string [ size ] ; s name = new string [ size ] ; s description = new string [ size ] ; for ( int i = num ; i < size ; i ++ ) { s value [ i ] = ( string ) v value . get ( i ) ; s name [ i ] = ( string ) v name . get ( i ) ; s description [ i ] = ( string ) v description . get ( i ) ; } }	fill vector with docaction ref_list ( 135 ) values.
protected void assert round trip ( tps expected ) throws io , class not found exception { final byte [ ] serialized ; { byte array output stream baos = new byte array output stream ( ) ; object output stream oos = new object output stream ( baos ) ; expected . write external ( oos ) ; oos . flush ( ) ; serialized = baos . to byte array ( ) ; } final tps actual ; { actual = new tps ( ) ; byte array input stream bais = new byte array input stream ( serialized ) ; object input stream ois = new object input stream ( bais ) ; actual . read external ( ois ) ; } assert equals ( expected , actual ) ; }	test helper for ( de - ) serialization tests .
public static double calculate contrast ratio ( double lum1 , double lum2 ) { if ( ( lum1 < num ) || ( lum2 < num ) ) { throw new illegal argument exception ( str ) ; } return ( math . max ( lum1 , lum2 ) + num ) / ( math . min ( lum1 , lum2 ) + num ) ; }	calculates the contrast ratio of two order - independent luminance values.
protected void reset ( ) throws xni { int count = f components . size ( ) ; for ( int i = num ; i < count ; i ++ ) { xml c = ( xml ) f components . get ( i ) ; c . reset ( this ) ; } }	reset all xml 1 . 0 components before parsing and namespace context.
public synchronized void unregister ( string name ) { stream scope < ? > stream scope = by name map . remove ( name ) ; if ( stream scope == null ) return ; list < string > names = by stream scope map . get ( stream scope ) ; names . remove ( name ) ; if ( names . is empty ( ) ) by stream scope map . remove ( stream scope ) ; }	remove the specific name registration.
private string expand affix ( string pattern , string buffer buffer ) { buffer . set length ( num ) ; for ( int i = num ; i < pattern . length ( ) ; ) { char c = pattern . char at ( i ++ ) ; if ( c == quote ) { c = pattern . char at ( i ++ ) ; switch ( c ) { case currency sign : if ( i < pattern . length ( ) && pattern . char at ( i ) == currency sign ) { ++ i ; buffer . append ( symbols . get international currency symbol ( ) ) ; } else { buffer . append ( symbols . get currency symbol ( ) ) ; } continue ; case pattern percent : c = symbols . get percent ( ) ; break ; case pattern per mille : c = symbols . get per mill ( ) ; break ; case pattern minus : c = symbols . get minus sign ( ) ; break ; } } buffer . append ( c ) ; } return buffer . to string ( ) ; }	expand an affix pattern into an affix string.
public static query functions extract functions ( string [ ] filter queries ) { final query functions result = new query functions ( ) ; if ( is empty ( filter queries ) ) { return result ; } string [ ] arguments = new string [ num ] ; for ( string unmodified analysis : filter queries ) { string function = extract function ( unmodified analysis ) ; string [ ] functions ; if ( function . contains ( function argument splitter ) ) { functions = function . split ( function argument splitter ) ; } else { functions = new string [ ] { function } ; } for ( string sub function : functions ) { if ( sub function . contains ( aggregation argument delimiter ) ) { arguments = extract aggregation parameter ( sub function ) ; sub function = sub function . substring ( num , sub function . index of ( aggregation argument delimiter ) ) ; } function type type = function type . value of ( sub function . to upper case ( ) ) ; add function ( result , type , arguments ) ; } } return result ; }	analyzes the filter queries and parses them for chronix fucntions.
protected final void fire vetoable change ( string property name , int old value , int new value ) throws property veto exception { vetoable change support a veto support = this . veto support ; if ( a veto support == null ) { return ; } a veto support . fire vetoable change ( property name , integer . value of ( old value ) , integer . value of ( new value ) ) ; }	support for reporting changes for constrained integer properties.
protected boolean is valid classname ( string classname ) { return ( classname . index of ( str ) == - num ) ; }	checks whether the classname is a valid one , i.
public static int number ( ) { return all . size ( ) ; }	total number of non - terminals .
public string generate inverted string ( ) { return string . format ( str , num & generate inverted ( ) ) ; }	gets the string equivalent of the generated shade.
@ not null public string extract presentable url ( @ not null string path ) { return path . replace ( str , file . separator char ) ; }	fetches presentable url of file with the given path in this file system .
public string convert swf html ( url in ) throws exception { url conn = ( url ) in . open connection ( ) ; conn . set allow user interaction ( bool ) ; conn . set request property ( str , str ) ; conn . set instance follow redirects ( bool ) ; conn . connect ( ) ; return convert swf html ( conn . get input stream ( ) ) ; }	description of the method.
private void init program ( ) { gl use program ( this . program ) ; view proj matrix uniform = gl get uniform location ( this . program , str ) ; gl use program ( num ) ; }	initialize the shader program .
private boolean is negative ( final string input ) { require non null ( input ) ; for ( final string negative string : negative strings ) { if ( input . equals ignore case ( negative string ) ) { return bool ; } } return bool ; }	checks if a user ' s input matches one of the negative strings .
@ override protected void send disposition header ( final output stream out ) throws io { log . trace ( str ) ; super . send disposition header ( out ) ; final string filename = source . get file name ( ) ; if ( filename != null ) { out . write ( file name bytes ) ; out . write ( quote bytes ) ; out . write ( encoding util . get ascii bytes ( filename ) ) ; out . write ( quote bytes ) ; } }	write the disposition header to the output stream.
private list < map < string , object > > prepare resultsfor display ( collection < scored result > scored results ) { array list < map < string , object > > output = new array list < map < string , object > > ( scored results . size ( ) ) ; for ( scored result result : scored results ) { map < string , object > result map = new hash map < string , object > ( ) ; if ( result . track != null ) { prepare track for display ( result . track , result map ) ; } else { prepare marker for display ( result . waypoint , result map ) ; } output . add ( result map ) ; } return output ; }	prepares the result for display .
public long copy ( final input stream from , final output stream to ) throws io { long count = num ; byte [ ] tmp = m byte array pool . get ( m temp buf size ) ; try { while ( bool ) { int read = from . read ( tmp , num , m temp buf size ) ; if ( read == - num ) { return count ; } to . write ( tmp , num , read ) ; count += read ; } } finally { m byte array pool . release ( tmp ) ; } }	copy all bytes from inputstream to outputstream .
private static element info as element ( document doc , library info info ) { element library element = doc . create element ( str ) ; library element . set attribute ( str , info . get version ( ) ) ; append path elements ( doc , str , library element , info . get bootpath ( ) ) ; append path elements ( doc , str , library element , info . get extension dirs ( ) ) ; append path elements ( doc , str , library element , info . get endorsed dirs ( ) ) ; return library element ; }	creates an xml element for the given info .
public void add choice value ( string value , string i18n key ) throws sms , sso { map choice values = as . get choice values map ( ) ; choice values . put ( value , i18n key ) ; update choice values ( choice values ) ; }	adds a choice value and its i18n key to the existing set of choice values .
private void notify change ( int previous , int current ) { if ( m on value change listener != null ) { m on value change listener . on value change ( this , previous , m value ) ; } }	notifies the listener , if registered , of a change of the value of this numberpicker .
public void load library ( string lib name ) { load library0 ( lib name , rvm . get class loader from stack frame ( num ) , bool ) ; }	loads and links the library specified by the argument .
public void handle tbl data action href request ( request invocation event event ) { string id repo name = hex to string ( ( string ) get display field value ( tbl data action href ) ) ; string cur realm = ( string ) get page session attribute ( am . current realm ) ; try { id model = ( id ) get model ( ) ; set page session attribute ( id . idrepo name , id repo name ) ; set page session attribute ( id . idrepo type , model . get id ( cur realm , id repo name ) ) ; id vb = ( id ) get view bean ( id . class ) ; unlock page trail ( ) ; pass pg session map ( vb ) ; vb . forward to ( get request context ( ) ) ; } catch ( am e ) { set inline alert message ( cc . type error , str , e . get message ( ) ) ; forward to ( ) ; } }	forwards request to edit id repo view bean .
@ override public void load height map ( raster raster ) throws io { int strip height = math . min ( strip rows , raster length ) ; int strip width = raster width * samples per pixel ; int strip size = strip width * strip height * bytes per sample ; int num strips = ( int ) math . ceil ( ( double ) raster length / strip height ) ; if ( strip size > integer . max value ) { throw new illegal argument exception ( str + integer . max value + str ) ; } if ( ( minimum == null ) || ( maximum == null ) ) { compute min max from strip ( data type , num strips , strip size , strip width , strip height ) ; } load from strip ( data type , num strips , strip size , strip width , strip height , raster , bool ) ; }	load data from height map file into a raster , converting data to float .
public void add footer ( @ non null view view ) { if ( view == null ) { throw new illegal argument exception ( str ) ; } m footers . add ( view ) ; }	adds a footer view .
public static pair < int [ ] , double [ ] > convert ( set < feature > features , lexicon lexicon , boolean training mode ) { t f map = new t ( features . size ( ) ) ; for ( feature feature : features ) { final int feature id = feature utilities . get feature id ( lexicon , training mode , feature ) ; if ( feature id < num ) continue ; double value = feature . get value ( ) + f map . get ( feature id ) ; f map . put ( feature id , value ) ; } int [ ] ids original = f map . keys ( ) ; int [ ] ids = new int [ ids original . length ] ; system . arraycopy ( ids original , num , ids , num , ids . length ) ; arrays . sort ( ids ) ; double [ ] vals = new double [ f map . size ( ) ] ; int count = num ; for ( int key : ids ) { vals [ count ++ ] = f map . get ( key ) ; } return new pair < > ( ids , vals ) ; }	convert a feature set into a pair of arrays of integers and doubles by looking up the feature name in the provided lexicon .
private static string crete xml ( int first row , int num pfis , int num pjur , int r default , int max results ) { string result = null ; document document = document helper . create document ( ) ; element root = document . add element ( person keys . xml personas text ) ; root . add attribute ( person keys . xml inicio text , integer . to string ( first row ) ) ; if ( ( first row + r default ) > ( num pfis + num pjur ) ) { root . add attribute ( person keys . xml fin text , integer . to string ( num pfis + num pjur ) ) ; } else { root . add attribute ( person keys . xml fin text , integer . to string ( first row + r default ) ) ; } root . add attribute ( person keys . xml total text , integer . to string ( num pfis + num pjur ) ) ; root . add attribute ( person keys . xml rango text , integer . to string ( r default ) ) ; root . add attribute ( person keys . xml result max text , integer . to string ( max results ) ) ; result = document . as xml ( ) ; return result ; }	author : 66575267 - gabriel saiz metodo para crear un xml que indique el numero total de resultados encontrados .
public string to feature string ( feature vector fv ) { if ( num byte features != fv . get number of byte features ( ) || num short features != fv . get number of short features ( ) || num continuous features != fv . get number of continuous features ( ) ) throw new illegal argument exception ( str + fv + str ) ; string builder buf = new string builder ( ) ; for ( int i = num ; i < num byte features ; i ++ ) { if ( buf . length ( ) > num ) buf . append ( str ) ; buf . append ( get feature value as string ( i , fv . get byte feature ( i ) ) ) ; } for ( int i = num byte features ; i < num byte features + num short features ; i ++ ) { if ( buf . length ( ) > num ) buf . append ( str ) ; buf . append ( get feature value as string ( i , fv . get short feature ( i ) ) ) ; } for ( int i = num byte features + num short features ; i < num byte features + num short features + num continuous features ; i ++ ) { if ( buf . length ( ) > num ) buf . append ( str ) ; buf . append ( fv . get continuous feature ( i ) ) ; } return buf . to string ( ) ; }	convert a feature vector into a string representation .
protected void sort population ( ) { if ( properties . shuffle goals ) randomness . shuffle ( population ) ; if ( is maximization function ( ) ) { collections . sort ( population , collections . reverse order ( ) ) ; } else { collections . sort ( population ) ; } }	sort the population by fitness warn : used only with singular objective algorithms , multi - objective algorithms should implement their own ' sort '.
public void clean ( ) { chrono full revision cfr = first cfr ; total size = size ; while ( cfr != null ) { total size += cfr . size ( ) ; cfr = cfr . get next ( ) ; } if ( total size < max storage size ) { return ; } cfr = first cfr ; while ( cfr != null ) { total size += cfr . clean ( revision index , num ) ; cfr = cfr . get next ( ) ; } chrono storage block block ; while ( last != null && total size >= max storage size ) { block = last . get index prev ( ) ; if ( storage . remove ( last . get revision index ( ) ) == null ) { throw new runtime exception ( str ) ; } total size -= last . length ( ) ; size += last . length ( ) ; if ( block != null ) { block . set index next ( null ) ; } last . set index prev ( null ) ; cfr = last . get chrono full revision ( ) ; total size += cfr . size ( ) - cfr . clean ( revision index , last . get revision index ( ) ) ; if ( last == first ) { first = null ; } last = block ; } system . gc ( ) ; }	reduces the amount of used storage by discarding chrono storage blocks .
public static number plus ( character left , character right ) { return plus ( integer . value of ( left ) , right ) ; }	add one character to another.
boolean contain relay state ( string relay state ) { return relay state map . contains key ( relay state ) ; }	returns true if the specified relay state is one of the keys in relaystatemap , false otherwise .
public void local search started ( ) { start time = system . current time millis ( ) ; end time = start time + properties . local search budget * num ; tests = num ; suites = num ; fitness evaluations = num ; executed start = max statements stopping condition . get num executed statements ( ) ; }	indicates that the application of ls to the current population has started .
public synchronized int write ( input stream in ) throws io { int read count = num ; int in buffer pos = count - filled buffer sum ; int n = in . read ( current buffer , in buffer pos , current buffer . length - in buffer pos ) ; while ( n != - num ) { read count += n ; in buffer pos += n ; count += n ; if ( in buffer pos == current buffer . length ) { need new buffer ( current buffer . length ) ; in buffer pos = num ; } n = in . read ( current buffer , in buffer pos , current buffer . length - in buffer pos ) ; } return read count ; }	writes the entire contents of the specified input stream to this byte stream.
public static double normalize radians ( double r ) { if ( r < num && r >= - two pi ) return r + two pi ; if ( r >= two pi && r < four pi ) return r - two pi ; if ( r >= num && r < two pi ) return r ; r -= two pi * math . floor ( r * two pi inverse ) ; if ( r < num ) r += two pi ; return r ; }	reduce an angle in radians to the range ( 0 - 2 pi ) .
public static tetrad matrix convert cov to corr ( tetrad matrix m ) { for ( int i = num ; i < m . rows ( ) ; i ++ ) { for ( int j = num ; j < m . columns ( ) ; j ++ ) { if ( double . is na n ( m . get ( i , j ) ) ) { throw new illegal argument exception ( str ) ; } } } return correlation ( m ) ; }	converts a covariance matrix to a correlation matrix in place ; the same matrix is returned for convenience , but m is modified in the process .
private byte [ ] ungzip ( byte [ ] body ) { byte array input stream bytein = new byte array input stream ( body ) ; try ( gzip gzin = new gzip ( bytein ) ; byte array output stream byteout = new byte array output stream ( ) ) { int res = num ; byte buf [ ] = new byte [ num ] ; while ( res >= num ) { res = gzin . read ( buf , num , buf . length ) ; if ( res > num ) { byteout . write ( buf , num , res ) ; } } byte uncompressed [ ] = byteout . to byte array ( ) ; return uncompressed ; } catch ( io e ) { } return null ; }	decompresses using gzip algorithm .
private boolean select id ( int node id , boolean show ) { if ( m root == null ) return bool ; log . config ( str + node id + str + show + str + m root ) ; m node = m root . find node ( node id ) ; if ( node != null ) { tree path tree path = new tree path ( node . get path ( ) ) ; log . config ( str + node + str + tree path . to string ( ) ) ; tree . set selection path ( tree path ) ; if ( show ) { tree . make visible ( tree path ) ; tree . scroll path to visible ( tree path ) ; } return bool ; } log . info ( str + node id ) ; return bool ; }	select id in tree.
protected final boolean is list state ( ) { return state text types . char at ( state ) == str ; }	checks if the current state is marked as a list state .
private static class < ? extends activity > guess error activity class ( context context ) { class < ? extends activity > resolved activity class ; resolved activity class = custom activity on crash . get error activity class with intent filter ( context ) ; if ( resolved activity class == null ) { resolved activity class = default error activity . class ; } return resolved activity class ; }	internal method used to guess which error activity must be called when the app crashes.
public void load glyphs ( string chars ) throws no glyph exception { char [ ] chs = chars . to char array ( ) ; for ( int i = num ; i < chs . length ; i ++ ) { get glyph ( chs [ i ] , null ) ; } }	load the glyphs for the characters in the given string from the fontdefinition into this font .
private void init quest and add to world ( final i quest ) { logger . info ( str + quest . get name ( ) ) ; quest . add to world ( ) ; quests . add ( quest ) ; }	adds a quest to the world.
public static move command [ ] values ( int f , game options opts , boolean forward ini ) { boolean manual shutdown = bool , self destruct = bool ; if ( opts != null ) { manual shutdown = opts . boolean option ( str ) ; self destruct = opts . boolean option ( str ) ; } array list < move command > flagged cmds = new array list < move command > ( ) ; for ( move command cmd : move command . values ( ) ) { if ( ( cmd == move shutdown || cmd == move startup ) && ! manual shutdown ) { continue ; } if ( cmd == move self destruct && ! self destruct ) { continue ; } if ( cmd == move forward ini && ! forward ini ) { continue ; } if ( ( cmd . flag & f ) == f ) { flagged cmds . add ( cmd ) ; } } return flagged cmds . to array ( new move command [ num ] ) ; }	return a list of valid commands for the given parameters .
public boolean is ldap ( ) { string host = get ldap ( ) ; if ( host == null || host . length ( ) == num ) return bool ; string domain = get ldap ( ) ; return domain != null && domain . length ( ) > num ; }	is ldap authentification defined.
public void shed cache ( ) { connection [ ] conn ; synchronized ( free list ) { conn = free list . to array ( new connection [ free list . size ( ) ] ) ; free list . clear ( ) ; } for ( int i = conn . length ; -- i >= num ; ) { connection c = conn [ i ] ; conn [ i ] = null ; try { c . close ( ) ; } catch ( java . io . io e ) { } } }	closes all the connections in the cache , whether timed out or not .
public static byte [ ] hash ( input stream in ) throws io { if ( hash digest == null ) { throw new evernote util exception ( edam hash algorithm + str , new no such algorithm exception ( edam hash algorithm ) ) ; } byte [ ] buf = new byte [ num ] ; int n ; while ( ( n = in . read ( buf ) ) != - num ) { hash digest . update ( buf , num , n ) ; } return hash digest . digest ( ) ; }	returns an md5 checksum of the contents of the provided inputstream .
public abstract tree node create node ( final int x , final int y ) ;	create a new treenode.
@ suppress warnings ( str ) public static < t extends feature structure > list < t > to list ( fs array ) { if ( array == null ) { return new array list < t > ( ) ; } else { return ( list < t > ) arrays . as list ( array . to array ( ) ) ; } }	create a new list from an fsarray.
protected static int to digit ( final char ch , final int index ) throws illegal argument exception { final int digit = character . digit ( ch , num ) ; if ( digit == - num ) { throw new illegal argument exception ( str + ch + str + index ) ; } return digit ; }	converts a hexadecimal character to an integer .
public static server side sort request control new control ( final boolean is critical , final collection < sort key > keys ) { reject . if null ( keys ) ; reject . if false ( ! keys . is empty ( ) , str ) ; return new server side sort request control ( is critical , collections . unmodifiable list ( new array list < sort key > ( keys ) ) ) ; }	creates a new server side sort request control with the provided criticality and list of sort keys .
@ suppress warnings ( { str , str } ) static < e extends comparable < e > > auto sorted collection < e > create auto sorted collection ( supplier < list < sorted list element < e > > > list sup , collection < ? extends e > values ) { list list = list sup . get ( ) ; if ( ! list . is empty ( ) ) { throw new illegal state exception ( str ) ; } auto sorted collection < e > sorted collection = new auto list sorted collection < > ( list , null ) ; sorted collection . add all ( values ) ; return sorted collection ; }	construct new auto sorted collection using natural order .
private void int stream ( ) { int [ ] ints = new int [ ] { num , num , num , num , num } ; int stream int stream = int stream . of ( ints ) ; int stream . for each ( null ) ; int stream int stream2 = int stream . of ( num , num , num , num , num ) ; int stream2 . for each ( null ) ; }	creating stream of ints - intstream.
@ suppress warnings ( str ) public boolean is customized ( ) { if ( m customization level == null ) { get element id ( ) ; m customization level = new integer ( s parameters . customnone ) ; if ( m parent . is custom prefix ( m name ) ) { m customization level = new integer ( s parameters . customprefixed ) ; } else { if ( m parent . is object exists ( str , m parent . get tables ( ) ) && m parent . is object exists ( str , m parent . get tables ( ) ) ) { string sql = s db engine . sql ad get table column entity type ( m parent . get vendor ( ) , m parent . get catalog ( ) , m parent . get schema ( ) , m table , m name ) ; statement stmt = m parent . set statement ( ) ; result set rs = m parent . execute query ( stmt , sql ) ; if ( m parent . get result set next ( rs ) ) { string s = m parent . get result set string ( rs , str ) ; if ( m parent . is custom entity type ( s ) ) m customization level = new integer ( s parameters . custommarked ) ; } m parent . release result set ( rs ) ; m parent . release statement ( stmt ) ; } } } if ( m customization level . int value ( ) > s parameters . customnone ) return bool ; else return bool ; }	whether or not this column is a customization.
public final void scheduled for flush ( ) { scheduled for flush . set ( bool ) ; }	schedule the session for flushed.
public image info inspect image ( string image ) throws io { return inspect image ( inspect image params . create ( image ) ) ; }	gets detailed information about docker image .
@ override public double prev cumulative quantity ( final long wo activity id , long mb header id ) { if ( mb header id == null ) mb header id = - num ; final object [ ] params = new object [ ] { mb header id , mb header id , works constants . cancelled status , wo activity id } ; final double p quant = ( double ) generic service . find by named query ( str , params ) ; if ( p quant == null ) return num ; else return p quant . double value ( ) ; }	get previous cumulative amount ( approved , approval pending and draft entries ) based on workorder activity id.
void receive ( int length , data input stream in ) throws io { synchronized ( lock ) { if ( ( pos > num ) && ( ( buffer . length - present ) < length ) ) { system . arraycopy ( buffer , pos , buffer , num , present - pos ) ; present -= pos ; pos = num ; } if ( ( buffer . length - present ) < length ) throw new io ( str ) ; in . read fully ( buffer , present , length ) ; present += length ; requested -= length ; lock . notify all ( ) ; } }	receive bytes transmitted from connection at remote endpoint .
public jda remove listener ( object listener ) { listeners . remove ( listener ) ; return this ; }	removes a listener from the list of listeners .
private static list < string > read file ( file file ) throws io { file reader fr = new file reader ( file ) ; buffered reader br = new buffered reader ( fr ) ; list < string > lines = new array list < string > ( ) ; string line ; while ( ( line = br . read line ( ) ) != null ) lines . add ( line ) ; fr . close ( ) ; br . close ( ) ; return lines ; }	returns a list with the file lines .
flexible node read external node ( hash map < string , taxon > translation list ) throws import exception , io { flexible node node = new flexible node ( ) ; string label = read token ( str ) ; taxon taxon ; if ( translation list . size ( ) > num ) { taxon = translation list . get ( label ) ; if ( taxon == null ) { throw new unknown taxon exception ( str + label + str ) ; } } else { taxon = new taxon ( label ) ; } if ( get last meta comment ( ) != null ) { parse migration string ( get last meta comment ( ) , node ) ; clear last meta comment ( ) ; } node . set taxon ( taxon ) ; int pop = integer . parse int ( label . split ( str ) [ num ] ) ; node . set attribute ( pop , ( pop - num ) ) ; return node ; }	reads an external node in .
static void plug together pair ( input stream in , output stream out , input stream in1 , output stream out1 ) { thread in thread = null ; thread out thread = null ; int n execs = get num exec ( ) ; in thread = access controller . do privileged ( new new thread action ( new pipe writer ( in , out , str , n execs ) , str , bool ) ) ; out thread = access controller . do privileged ( new new thread action ( new pipe writer ( in1 , out1 , str , n execs ) , str , bool ) ) ; in thread . start ( ) ; out thread . start ( ) ; }	allow plugging together two pipes at a time , to associate output from an execed process.
@ non null public static storable fence and ( @ non null storable fence ... fences ) { return storable fence . and ( arrays . as list ( fences ) ) ; }	creates a meta storable fence which is a logical ' and ' of all the given fences.
public mxfuid ( byte [ ] uid ) { this . uid = arrays . copy of ( uid , uid . length ) ; }	instantiates a new mxf uid .
public static data model list serializable instance ( ) { return new data model list ( ) ; }	generates a simple exemplar of this class to test serialization .
@ override public mb find last mb ( final work order activity work order activity , final long mb header id ) { logger . info ( str ) ; string query = str ; object [ ] params ; final list < object > param list = new array list < object > ( ) ; query = query + str + str + str + str ; param list . add ( work order activity . get id ( ) ) ; param list . add ( mb header id ) ; param list . add ( works constants . approved ) ; param list . add ( mb header id ) ; params = new object [ param list . size ( ) ] ; params = param list . to array ( params ) ; final list < mb > mb header list = generic service . find all by ( query , params ) ; mb result = null ; if ( mb header list != null && ! mb header list . is empty ( ) ) result = mb header list . get ( num ) ; return result ; }	this method will return topageno for a line item from the last mb entry .
synchronized private void output buffered chunk ( ) { if ( small chunks == null || chunk size == num ) { return ; } if ( small chunks . size ( ) == num ) { output chunk ( small chunks . get ( num ) ) ; chunk size = num ; small chunks = null ; return ; } final i [ ] chunk = new i [ chunk size ] ; int dest pos = num ; for ( i [ ] e : small chunks ) { system . arraycopy ( e , num , chunk , dest pos , e . length ) ; dest pos += e . length ; } output chunk ( chunk ) ; chunk size = num ; small chunks = null ; }	output the internal buffer .
private void wait load compete ( ) { if ( m load complete ) return ; m loader . set priority ( thread . norm priority ) ; log . config ( str ) ; while ( m loader . is alive ( ) ) { try { thread . sleep ( num ) ; } catch ( exception e ) { log . log ( level . severe , str , e ) ; } } log . config ( str ) ; }	wait until load is complete.
public void add classes ( list < string > class names ) { if ( handler factories == null ) { handler factories = new array list < string > ( ) ; } handler factories . add all ( class names ) ; }	add a list of exception handler class names .
public static boolean is constant name ( string name ) { return pattern . matches ( str , name ) ; }	checks if given name is a constant name i . e if the name contains all caps and underscores only.
private void notify dead ( final rp dead ) { if ( ! rats . remove ( dead ) ) { logger . warn ( str + dead . to string ( ) + str ) ; } if ( rats . size ( ) == num ) { phase to default phase ( new linked list < string > ( arrays . as list ( str ) ) ) ; } }	function to control amount of alive rats .
public static om read ( data input stream dis ) throws io { return read ( dis , null ) ; }	read a grid off a datainputstream.
public varchar constant ( string s ) { type = new varchar type ( s . length ( ) ) ; val = s ; }	create a constant by wrapping the specified string .
public boolean add child planet ( dimension properties child ) { if ( child == this ) return bool ; child planets . add ( child . get id ( ) ) ; child . set parent planet ( this ) ; return bool ; }	does not check for hierarchy loops !.
@ override public enumeration < string > enumerate measures ( ) { vector < string > new vector = new vector < string > ( num ) ; new vector . add ( str ) ; return new vector . elements ( ) ; }	returns an enumeration of the additional measure names.
int [ ] calculate relative ( int [ ] absolute ) { int [ ] res = new int [ absolute . length ] ; res [ num ] = absolute [ num ] ; for ( int i = num ; i < res . length ; i ++ ) { res [ i ] = absolute [ i ] - absolute [ i - num ] ; } return res ; }	calcuates the relative offset.
@ after class public static void delete log dir ( ) { if ( log dir != null ) { file utils . delete quietly ( log dir ) ; } }	deletes the temporary log dir and all files within .
public string to string ( ) { string buffer sb = new string buffer ( ) ; char [ ] separator = { str , str } ; int n = rows ( ) ; int m = columns ( ) ; for ( int i = num ; i < n ; i ++ ) { separator [ num ] = str ; for ( int j = num ; j < m ; j ++ ) { sb . append ( separator ) ; sb . append ( components [ i ] [ j ] ) ; separator [ num ] = str ; } sb . append ( str ) ; sb . append ( str ) ; } return sb . to string ( ) ; }	returns a string representation of the system .
public static string [ ] split string into array ( string value ) { string [ ] values = new string [ num ] ; if ( value != null && value . length ( ) > num ) { if ( value . index of ( cim . comma seperator ) != - num ) { values = value . split ( str ) ; } else { values = new string [ num ] ; values [ num ] = value ; } } return values ; }	this method will help you to split the string separated with comma into a string array.
public static string from attr modeling model class ( string va model class ) { return va model class . split ( value analysis . model package prefix ) [ num ] ; }	convert the string signature of an attr modeling model class to a string signature of a regular class.
public synchronized void add ( dcc loco address loco address , boolean direction normal ) { if ( ! contains ( loco address ) ) { if ( consist list . size ( ) == num ) { byte command = nce binary command . loco cmd fwd consist lead ; if ( ! direction normal ) { command = nce binary command . loco cmd rev consist lead ; } add loco to consist ( loco address . get number ( ) , loco address . is long address ( ) , command ) ; consist position . put ( loco address , dcc consist . position lead ) ; } else if ( consist list . size ( ) == num ) { byte command = nce binary command . loco cmd fwd consist rear ; if ( ! direction normal ) { command = nce binary command . loco cmd rev consist rear ; } add loco to consist ( loco address . get number ( ) , loco address . is long address ( ) , command ) ; consist position . put ( loco address , dcc consist . position trail ) ; } else { byte command = nce binary command . loco cmd fwd consist mid ; if ( ! direction normal ) { command = nce binary command . loco cmd rev consist mid ; } add loco to consist ( loco address . get number ( ) , loco address . is long address ( ) , command ) ; consist position . put ( loco address , consist position . size ( ) ) ; } consist list . add ( loco address ) ; consist dir . put ( loco address , boolean . value of ( direction normal ) ) ; } else { log . error ( str + loco address + str + get consist address ( ) ) ; } }	add a locomotive to a consist.
private grid client configuration client configuration ( ) { grid client configuration cfg = new grid client configuration ( ) ; cfg . set topology refresh frequency ( topology refresh frequency ( ) ) ; cfg . set max connection idle time ( max connection idle time ( ) ) ; cfg . set protocol ( protocol ( ) ) ; cfg . set servers ( arrays . as list ( server address ( ) ) ) ; cfg . set balancer ( new grid client round robin balancer ( ) ) ; if ( use ssl ( ) ) cfg . set ssl context factory ( ssl context factory ( ) ) ; grid client data configuration loc = new grid client data configuration ( ) ; grid client data configuration partitioned = new grid client data configuration ( ) ; partitioned . set name ( partitioned cache name ) ; partitioned . set affinity ( new grid client partition affinity ( ) ) ; grid client data configuration partitioned async backup = new grid client data configuration ( ) ; partitioned async backup . set name ( partitioned async backup cache name ) ; partitioned async backup . set affinity ( new grid client partition affinity ( ) ) ; grid client data configuration replicated = new grid client data configuration ( ) ; replicated . set name ( replicated cache name ) ; grid client data configuration replicated async = new grid client data configuration ( ) ; replicated async . set name ( replicated async cache name ) ; cfg . set data configurations ( arrays . as list ( loc , partitioned , replicated , replicated async , partitioned async backup ) ) ; return cfg ; }	creates client that will try to connect to only first node in grid .
public final test subscriber assert not subscribed ( ) { string prefix = str ; if ( done . get count ( ) != num ) { prefix = str ; } if ( subscription . get ( ) != null ) { fail ( prefix , str , errors ) ; } else if ( ! errors . is empty ( ) ) { fail ( prefix , str , errors ) ; } return this ; }	assert that the onsubscribe method hasn ' t been called at all .
public builder ( ) { set version code ( math . min ( fresh air . get current application version ( ) , num ) ) ; set features ( new linked list < feature info > ( ) ) ; }	constructs a new builder , assuming that the version code is the current app version .
protected string convert date format ( string pattern ) { boolean inside = bool ; boolean mark = bool ; boolean modified command = bool ; string builder buf = new string builder ( ) ; for ( int i = num ; i < pattern . length ( ) ; i ++ ) { char c = pattern . char at ( i ) ; if ( c == str && ! mark ) { mark = bool ; } else { if ( mark ) { if ( modified command ) { modified command = bool ; mark = bool ; } else { inside = translate command ( buf , pattern , i , inside ) ; if ( c == str || c == str ) { modified command = bool ; } else { mark = bool ; } } } else { if ( ! inside && c != str ) { buf . append ( str ) ; inside = bool ; } buf . append ( c ) ; } } } if ( buf . length ( ) > num ) { char last char = buf . char at ( buf . length ( ) - num ) ; if ( last char != str && inside ) { buf . append ( str ) ; } } return buf . to string ( ) ; }	search the provided pattern and get the c standard date / time formatting rules and convert them to the java equivalent .
public void add child node ( eval factory node child node ) { child nodes . add ( child node ) ; }	adds a child node .
public final void head to ( tuple3d p ) { double angle = geometric . angle ( this . location , p ) ; turn to ( math . to degrees ( angle ) ) ; }	head to the direction of the given point .
public void compact buffer ( ) { if ( offset != buffer . length ) { byte [ ] new buffer = new byte [ offset ] ; system . arraycopy ( buffer , num , new buffer , num , offset ) ; buffer = new buffer ; } }	reallocates the buffer in order to make it exactly the size of data it contains.
public static int put byte buffer ( byte [ ] bytes , int offset , byte buffer buf ) { int len = buf . remaining ( ) ; buf . get ( bytes , offset , len ) ; return offset + len ; }	add the whole content of the bytebuffer to the bytes arrays.
private void clear index to first ( ) { for ( ; ; ) { index < k , v > q = head ; for ( ; ; ) { index < k , v > r = q . right ; if ( r != null && r . indexes deleted node ( ) && ! q . unlink ( r ) ) break ; if ( ( q = q . down ) == null ) { if ( head . right == null ) try reduce level ( ) ; return ; } } } }	clears out index nodes associated with deleted first entry .
final void try terminate ( ) { for ( ; ; ) { int c = ctl . get ( ) ; if ( is running ( c ) || run state at least ( c , tidying ) || ( run state of ( c ) == shutdown && ! work queue . is empty ( ) ) ) return ; if ( worker count of ( c ) != num ) { interrupt idle workers ( only one ) ; return ; } final reentrant lock main lock = this . main lock ; main lock . lock ( ) ; try { if ( ctl . compare and set ( c , ctl of ( tidying , num ) ) ) { try { terminated ( ) ; } finally { ctl . set ( ctl of ( terminated , num ) ) ; termination . signal all ( ) ; } return ; } } finally { main lock . unlock ( ) ; } } }	transitions to terminated state if either ( shutdown and pool and queue empty ) or ( stop and pool empty ).
public void join resource ( ) throws interrupted exception { if ( run obj != null ) { synchronized ( complete ) { if ( run obj != null ) complete . wait ( ) ; } } }	waits for the resource to complete.
public static string to json ( list list ) { if ( list == null ) return str ; boolean first = bool ; string buffer sb = new string buffer ( ) ; iterator iter = list . iterator ( ) ; sb . append ( str ) ; while ( iter . has next ( ) ) { if ( first ) first = bool ; else sb . append ( str ) ; object value = iter . next ( ) ; if ( value == null ) { sb . append ( str ) ; continue ; } sb . append ( json . to json ( value ) ) ; } sb . append ( str ) ; return sb . to string ( ) ; }	convert a list to json text.
@ override public int hash code ( ) { final int prime = num ; int result = super . hash code ( ) ; result = prime * result + ( tenant == null ? num : tenant . hash code ( ) ) ; return result ; }	tenant aware entities extend the equals / hashcode strategy with the tenant name.
public void load accessors ( mapped field configured field , mapped field target field ) { load accessors ( target class , configured field , target field ) ; }	fill fields with they custom methods .
public static matrix block reshape ( matrix block in , matrix block out , int rows , int cols , boolean rowwise ) throws dml { int rlen = in . rlen ; int clen = in . clen ; if ( ( ( long ) rlen ) * clen != ( ( long ) rows ) * cols ) throw new dml ( str + rlen + str + clen + str + rows + str + cols + str ) ; if ( rlen == rows && clen == cols ) { out . copy ( in ) ; return out ; } out . sparse = matrix block . eval sparse format in memory ( rows , cols , in . non zeros ) ; out . rlen = rows ; out . clen = cols ; out . non zeros = in . non zeros ; if ( ! in . sparse && ! out . sparse ) reshape dense ( in , out , rows , cols , rowwise ) ; else if ( in . sparse && out . sparse ) reshape sparse ( in , out , rows , cols , rowwise ) ; else if ( in . sparse ) reshape sparse to dense ( in , out , rows , cols , rowwise ) ; else reshape dense to sparse ( in , out , rows , cols , rowwise ) ; return out ; }	cp reshape operation ( single input , single output matrix ).
public static class < ? > [ ] to classes from objects ( final object [ ] params ) { final class < ? > [ ] classes = new class < ? > [ params . length ] ; int i = num ; for ( final object object : params ) { if ( object != null ) { classes [ i ++ ] = object . get class ( ) ; } else { classes [ i ++ ] = object . class ; } } return classes ; }	to classes from objects .
public admin region ( string local name , vm vm , string user attribute desc ) { string gn = local name ; int idx = local name . last index of ( name sep ) ; if ( idx != - num ) { local name = local name . substring ( idx + num ) ; } else { gn = name sep + gn ; } this . global name = gn ; this . local name = local name ; this . user attribute desc = user attribute desc ; this . vm = vm ; }	creates a root region.
public element sign with wss ( document doc , java . security . cert . certificate cert , string algorithm , list ids ) throws xml { return sign with wss ( doc , cert , algorithm , ids , soap . wsf 10 version ) ; }	sign part of the xml document referered by the supplied a list of id attributes of nodes.
public void add user message listener ( user message listener user message listener ) { user message listeners . add ( user message listener ) ; }	adds a user message listener .
public iterator builder add template ( i query ) { templates . add ( query ) ; return this ; }	adds a template that will be used to control the matching entries the iterator will iterate over .
public string add to class path ( final string path ) { this . class path += ( system . get property ( str ) + path ) ; return this . class path ; }	add to the classpath used when compiling .
private static int new long array ( jni env , int length ) { if ( trace jni ) vm . sys write ( str ) ; runtime entrypoints . check jni gc ( ) ; try { long [ ] new array = new long [ length ] ; return env . push jni ( new array ) ; } catch ( throwable unexpected ) { if ( trace jni ) unexpected . print stack trace ( system . err ) ; env . record exception ( unexpected ) ; return num ; } }	newlongarray : create a new long array.
protected abstract void finalize output ( final int [ ] source image pixels , final int image width , final int image height ) ;	override this if any action needs to be done at the end of the conversion .
public static boolean ignoring battery optimizations ( ) { return ngn application . ignoring battery optimizations ( null ) ; }	raises " action_ignore_battery_optimization_settings " intent.
private boolean retry delay has passed by ( long last fail time ) { return last fail time == null || last fail time + this . retry after ms < system . current time millis ( ) ; }	checks if the retry delay has passed .
public static java . lang . string value of ( long l ) { return long . to string ( l ) ; }	returns the string representation of the long argument.
private boolean use metric ( metric rule rule , metric metric ) { if ( rule . aws dimension select == null && rule . aws dimension select regex == null ) { return bool ; } if ( rule . aws dimension select != null && metrics is in aws dimension select ( rule , metric ) ) { return bool ; } if ( rule . aws dimension select regex != null && metric is in aws dimension select regex ( rule , metric ) ) { return bool ; } return bool ; }	check if a metric should be used according to ` aws_dimension_select ` or ` aws_dimension_select_regex `.
final void add icon manager ( abstract status icon manager manager ) { icon managers . add ( manager ) ; }	add a new status icon manager .
public index meta data upgrade index meta data ( index meta data index meta data ) { if ( is upgraded ( index meta data ) ) { return index meta data ; } check supported version ( index meta data ) ; index meta data new meta data = upgrade legacy routing settings ( index meta data ) ; new meta data = add default units if needed ( new meta data ) ; check mappings compatibility ( new meta data ) ; new meta data = upgrade settings ( new meta data ) ; new meta data = mark as upgraded ( new meta data ) ; return new meta data ; }	checks that the index can be upgraded to the current version of the master node.
static final void encode ( byte [ ] src , int src off , int len , byte [ ] dst , int dst off ) { dst [ dst off ] = ( byte ) encode table . char at ( ( src [ src off ] > > num ) & num ) ; if ( len == num ) { dst [ dst off + num ] = ( byte ) encode table . char at ( ( ( src [ src off ] << num ) & num ) | ( ( src [ src off + num ] > > num ) & num ) ) ; dst [ dst off + num ] = ( byte ) encode table . char at ( ( ( src [ src off + num ] << num ) & num ) | ( ( src [ src off + num ] > > num ) & num ) ) ; dst [ dst off + num ] = ( byte ) encode table . char at ( src [ src off + num ] & num ) ; } else if ( len == num ) { dst [ dst off + num ] = ( byte ) encode table . char at ( ( ( src [ src off ] << num ) & num ) | ( ( src [ src off + num ] > > num ) & num ) ) ; dst [ dst off + num ] = ( byte ) encode table . char at ( ( src [ src off + num ] << num ) & num ) ; } else { dst [ dst off + num ] = ( byte ) encode table . char at ( ( src [ src off ] << num ) & num ) ; } }	encode len bytes of data in src at offset srcoff , storing the result into dst at offset dstoff.
@ suppress warnings ( str ) public static map < string , configuration key < ? > > registered keys ( ) { synchronized ( registered keys ) { if ( copy == null ) copy = collections . unmodifiable map ( ( map < string , configuration key < ? > > ) registered keys . clone ( ) ) ; return copy ; } }	returns a copy of the currently registered keys .
public static string md5 ( string string to hash ) { if ( string to hash != null ) { try { message digest md = message digest . get instance ( str ) ; byte [ ] bytes = md . digest ( string to hash . get bytes ( ) ) ; string builder sb = new string builder ( num * bytes . length ) ; for ( int i = num ; i < bytes . length ; i ++ ) { int low = ( bytes [ i ] & num ) ; int high = ( ( bytes [ i ] & num ) > > num ) ; sb . append ( constants . hexadecimal [ high ] ) ; sb . append ( constants . hexadecimal [ low ] ) ; } return sb . to string ( ) ; } catch ( no such algorithm exception e ) { return str ; } } else { return str ; } }	convierte un string a hash md5.
public string most of string ( ) { string type name = str ; switch ( type ) { case builtin : type name = str ; break ; case number : type name = str ; break ; case string : type name = str ; break ; case pf step : type name = str ; break ; case ident : type name = str ; break ; case comment : type name = str ; break ; case dashes : type name = str ; break ; case end module : type name = str ; break ; case prolog : type name = str ; break ; case epilog : type name = str ; break ; case pcal label : type name = str ; break ; } ; string str = str + string + str ; if ( string == null ) { str = str ; } ; string result = str + str + str + type name + str + column + str + get width ( ) ; if ( above align . line != - num ) { result = result + str + above align . to string ( ) ; } ; if ( below align . line != - num ) { result = result + str + below align . to string ( ) ; } ; if ( pre space != num ) { result = result + str + pre space ; } ; if ( is alignment point ) { result = result + str ; } ; if ( dist from margin != num ) { result = result + str + dist from margin ; } ; if ( subscript ) { result = result + str ; } ; return result ; }	the following defines a tostring ( ) method for printing a token for debugging.
public create index request mapping ( string type , x source ) { if ( mappings . contains key ( type ) ) { throw new illegal state exception ( str + type + str ) ; } try { mappings . put ( type , source . string ( ) ) ; } catch ( io e ) { throw new illegal argument exception ( str , e ) ; } return this ; }	adds mapping that will be added when the index gets created .
private static void copy file ( file src , file dst , integer port , boolean internal compression ) throws io { buffered reader in = new buffered reader ( new input stream reader ( new file input stream ( src ) , standard charsets . utf 8 ) ) ; writer out = new output stream writer ( new file output stream ( dst ) , standard charsets . utf 8 ) ; for ( string line = in . read line ( ) ; null != line ; line = in . read line ( ) ) { if ( null != port ) line = line . replace ( str , port . to string ( ) ) ; line = line . replace ( str , internal compression ? str : str ) ; out . write ( line ) ; } in . close ( ) ; out . close ( ) ; }	character copy of file using utf - 8.
public void assert event log contains ( object event ) { if ( ! m event log . contains ( event ) ) { fail ( str + m event log ) ; } }	fails the current test unless the event log contains a particular event .
private static boolean is all underscores ( ) { int i = num ; boolean result = bool ; while ( result && ( i < token . length ( ) ) ) { if ( token . char at ( i ) != str ) { result = bool ; } ; i = i + num ; } ; return result ; }	the following private methods are all procedures for use by the tokenize method .
public image warp ( buffered image bi , geo coord transformation transform , data bounds image bounds ) { if ( bi != null ) { iwidth = bi . get width ( ) ; iheight = bi . get height ( ) ; set geo trans ( transform ) ; set image bounds ( image bounds ) ; pixels = get pixels ( bi , num , num , iwidth , iheight ) ; bi = null ; } }	create an image warp with some additional transform information .
public static equipment logger factory create factory ( final equipment configuration econf , final process configuration pconf , boolean use equipment loggers , boolean use equipment appenders only ) { return new equipment logger factory ( econf . get handler class name ( ) , long . value of ( econf . get id ( ) ) , econf . get name ( ) , pconf . get process name ( ) , use equipment loggers , use equipment appenders only ) ; }	creates a new equipmentlogger .
protected void assert equals ( integer expected , integer actual ) { if ( expected == null || actual == null ) { if ( expected != actual ) { assert equals ( str + expected , str + actual ) ; } } else { assert equals ( expected . int value ( ) , actual . int value ( ) ) ; } }	check if two values are equal , and if not throw an exception .
public static boolean v pool specifies snapshots ( final virtual pool virtual pool ) { if ( virtual pool . get max native snapshots ( ) == null ) { return bool ; } return virtual pool . get max native snapshots ( ) != max disabled ; }	convenience method to determine if the virtual pool supports snapshots.
public void map dataset to axis ( int index , int axis index ) { list axis indices = new java . util . array list ( num ) ; axis indices . add ( new integer ( axis index ) ) ; map dataset to axes ( index , axis indices ) ; }	maps a dataset to a particular axis.
public uri ( am id , string secret hex , int code length , string issuer ) { reject . if null ( id , str ) ; reject . if null ( secret hex , str ) ; reject . if true ( string utils . is blank ( issuer ) , str ) ; reject . if true ( ( code length < min code length ) , str + min code length + str ) ; if ( secret hex . length ( ) == num ) { throw new illegal argument exception ( str ) ; } this . issuer = issuer ; this . id = id ; this . secret hex = secret hex ; this . code length = code length ; }	construct a builder which can be used to generate uris for registering oath devices with an oath authentication module .
protected void update application enabled ( ) { fire property change ( str , boolean . value of ( ! is enabled ( ) ) , boolean . value of ( is enabled ( ) ) ) ; }	updates the enabled state of this action depending on the new enabled state of the application .
public personality insights ( final string version date , string username , string password ) { this ( version date ) ; set username and password ( username , password ) ; }	instantiates a new personality insights service by username and password .
public string sign message ( string message ) throws illegal state exception { validate . not null ( get sign algorithm ( ) , str ) ; validate . not null ( get private key ( ) , str ) ; validate . not empty ( message , str ) ; log . debug ( str + message + str + get sign algorithm ( ) ) ; try { signature algorithm algo = signature algorithm . get signature algorithm for uri ( get sign algorithm ( ) ) ; signature sig = signature . get instance ( algo . get algorithm name ( ) ) ; sig . init sign ( this . private key ) ; byte [ ] message bytes = message . get bytes ( str ) ; sig . update ( message bytes ) ; byte [ ] sig bytes = sig . sign ( ) ; string signature = shared utils . encode bytes ( sig bytes ) ; log . debug ( str + signature ) ; return signature ; } catch ( exception e ) { log . error ( str , e ) ; throw new illegal state exception ( e ) ; } }	signs message with known private key and algorithm.
private void output price lists ( properties ctx , print writer out , boolean include any ) { out . println ( str ) ; if ( include any ) out . println ( str ) ; out . println ( str ) ; out . println ( str ) ; out . println ( str ) ; }	output xml list of pricelists.
public void clear bindings ( ) { if ( m bind args != null ) { arrays . fill ( m bind args , null ) ; } }	clears all existing bindings.
public boolean assign if best match ( method declaration declaration ) { assert ! finalized : str ; if ( ! is match ( declaration . get parameters ( ) ) ) { return bool ; } if ( this . best match method . is present ( ) ) { if ( this . best match method . get ( ) . get parameters ( ) . size ( ) > declaration . get parameters ( ) . size ( ) ) { return bool ; } } this . best match method = optional . of ( declaration ) ; return bool ; }	assigns this methoddeclaration if it is a match to the params defined for this method .
public static list < user > from ( cursor c ) { list < user > users = null ; int count = c . get count ( ) ; if ( count > num ) { users = new array list < > ( count ) ; while ( c . move to next ( ) ) { user user = new user ( ) ; syncing . from ( c , user ) ; int col = c . get column index ( email hash ) ; if ( col >= num ) { user . email hash = c . get string ( col ) ; } col = c . get column index ( following ) ; if ( col >= num ) { user . is following = c . get int ( col ) == num ; } users . add ( user ) ; } } c . close ( ) ; return users ; }	get contacts from the cursor and then close it .
private void start checking status ( ) { future = executor . submit ( null ) ; }	start checking the status of the transactions in another thread .
private void add signature profile ( signature wrapper signature , xml signature xml signature ) { signature type signature type = signature type . na ; string certificate id = signature . get signing certificate id ( ) ; if ( certificate id != null ) { signature type = get signature type ( certificate id ) ; } xml signature . set signature level ( signature type . name ( ) ) ; }	here we determine the type of the signature .
private static final int parse time string ( string str ) { str = str . trim ( ) ; int ret = num ; boolean neg = bool ; int i = num ; if ( str . char at ( num ) == str ) { neg = bool ; i ++ ; } int num = num ; final int len = str . length ( ) ; for ( ; i < len ; i ++ ) { char c = str . char at ( i ) ; if ( ( c >= str ) && ( c <= str ) ) { num = num * num + c - str ; } else if ( c == str ) { ret += num ; num = num ; ret *= num ; } } ret += num ; ret *= num ; if ( neg ) ret = - ret ; return ret ; }	convert hh : mm : ss to milliseconds.
public synchronized void remove image listener ( image listener cl ) { m image listeners . remove ( cl ) ; }	remove an image listener.
public array list < constraint widget > build list ( scout widget [ ] list ) { array list < constraint widget > ret = new array list < > ( ) ; for ( int i = m contain set . next set bit ( num ) ; i >= num ; i = m contain set . next set bit ( i + num ) ) { ret . add ( list [ i ] . m constraint widget ) ; } return ret ; }	build list of constraintwidgets from the scoutwidget list.
private boolean node exists ( string tokenizer path ) throws backing store exception { string token = path . next token ( ) ; if ( token . equals ( str ) ) throw new illegal argument exception ( str ) ; synchronized ( lock ) { abstract preferences child = kid cache . get ( token ) ; if ( child == null ) child = get child ( token ) ; if ( child == null ) return bool ; if ( ! path . has more tokens ( ) ) return bool ; path . next token ( ) ; if ( ! path . has more tokens ( ) ) throw new illegal argument exception ( str ) ; return child . node exists ( path ) ; } }	tokenizer contains < name > { ' / ' < name > }.
public int size ( ) { return delegate . size ( ) ; }	returns the number of components in this list .
public network address factory impl ( ) throws initialization exception { this ( default tcp http listen port ) ; }	defaults to an ephemeral port .
public transparent glass pane panel ( image icon icon , string text , color background color , float transparency ) { set layout ( new grid bag layout ( ) ) ; grid bag constraints gbc = new grid bag constraints ( ) ; gbc . gridy = num ; gbc . gridx = num ; j icon label = new j ( icon ) ; add ( icon label , gbc ) ; gbc . gridy += num ; label = new j ( text ) ; add ( label , gbc ) ; if ( transparency > num ) { transparency = num ; } else if ( transparency < num ) { transparency = num ; } color transparent color = new color ( background color . get red ( ) , background color . get green ( ) , background color . get blue ( ) , ( int ) ( transparency * num ) ) ; set background ( transparent color ) ; set opaque ( bool ) ; }	creates a transparent panel with a loading icon and a text .
@ override protected void fill header ( header head ) { try { standard . context ( undefined data . class ) ; head . set xtension ( str ) ; head . set bitpix ( hdu . bitpix byte ) ; head . set naxes ( num ) ; head . add value ( naxi . n ( num ) , this . data . length ) ; head . add value ( pcount , num ) ; head . add value ( gcount , num ) ; head . add value ( extend , bool ) ; } catch ( header card exception e ) { log . log ( level . severe , str , e ) ; } finally { standard . context ( null ) ; } }	fill header with keywords that describe data .
protected void clean stations and network ( ) { log . info ( str ) ; clean schedule ( ) ; remove non used stop facilities ( ) ; clean modes ( ) ; remove non used links ( ) ; log . info ( str ) ; }	after all lines created , clean all non - linked stations , all pt - exclusive links ( check allowed modes ) and all nodes which are non - linked to any link after the above cleaning.
private static string strip apple span from markup ( string markup ) { string builder stripped = new string builder ( markup ) ; int prefix beg idx = stripped . index of ( apple span prefix ) ; while ( prefix beg idx >= num ) { int prefix end idx = stripped . index of ( str , prefix beg idx ) + num ; stripped . replace ( prefix beg idx , prefix end idx , str ) ; int suffix beg idx = stripped . last index of ( apple span suffix ) ; int suffix end idx = suffix beg idx + apple span suffix . length ( ) ; stripped . replace ( suffix beg idx , suffix end idx , str ) ; prefix beg idx = stripped . index of ( apple span prefix ) ; } return stripped . to string ( ) ; }	strips the apple span appended by webkit while generating the selection markup .
private invocation constraints create invocation constraints ( ) { if ( min retry >= sleep time [ try indx ] ) { return new invocation constraints ( new connection absolute time ( system . current time millis ( ) + sleep time [ try indx ] ) , null ) ; } else { return invocation constraints . empty ; } }	create the invocationconstraints with connection absolute time based on an increasing retry.
public void create ( sso token , string dn , map attrs ) throws sms , sso { create ( token . get principal ( ) , dn , attrs ) ; object changed ( dn , add ) ; }	create an entry in the directory.
@ override public void close ( ) throws io { if ( ! closed ) { try { if ( ! eof ) { exhaust input stream ( this ) ; } } finally { eof = bool ; closed = bool ; } } }	upon close , this reads the remainder of the chunked message , leaving the underlying socket at a position to start reading the next response without scanning .
private void discard downstream media chunk ( ) { media chunk removed = media chunks . remove first ( ) ; long total bytes = removed . bytes loaded ( ) ; removed . release ( ) ; notify downstream discarded ( removed . start time us , removed . end time us , total bytes ) ; }	discards the first downstream media chunk .
public object execute script ( final script script , final script context context ) { final script engine engine = script engine provider . get script engine ( script . get type ( ) ) ; return execute script ( script , engine , context ) ; }	executes the given script with context as the scriptcontext.
public static placeholder fragment new instance ( ) { placeholder fragment fragment = new placeholder fragment ( ) ; bundle args = new bundle ( ) ; fragment . set arguments ( args ) ; return fragment ; }	returns a new instance of this fragment for the given section number .
public t eval ( ) { return eval ( bindings ( ) ) ; }	convenient method to eval an expression that does not need a scope .
public void add ( xmp segment ) { segments . add ( segment ) ; }	append a path segment.
private void next sync ( ) { if ( sync item iterator . has next ( ) ) { partial start time = system . current time millis ( ) ; current sync item = sync item iterator . next ( ) ; current sync item . sync ( this , host connection , callback handler , content resolver ) ; } else { log utils . logd ( tag , str + ( system . current time millis ( ) - start time ) ) ; if ( listener != null ) { listener . on sync finished ( this ) ; } sync service . stop self ( service start id ) ; } }	processes the next item on the sync list , or cleans up if it is finished .
public string decode ( string encoded ) { json object object = new json object ( encoded ) ; json array headers = object . get json array ( str ) ; for ( object header obj : headers ) { json array header = ( json array ) header obj ; string key = header . get string ( num ) ; string value = header . get string ( num ) ; if ( key . equals ignore case ( content type ) && ( value . contains ( str ) || value . contains ( application json ) ) ) { try { object . put ( str , new json object ( new string ( object . get binary ( payload ) , charset . for name ( utf 8 ) ) ) ) ; } catch ( decode exception e ) { object . put ( str , new string ( object . get binary ( payload ) , charset . for name ( utf 8 ) ) ) ; } object . remove ( payload ) ; break ; } } return object . to string ( ) ; }	decode the payload if the content - type is text or json .
public void test do as 01 ( ) { subject subj = new subject ( ) ; privileged action < object > pa = new my privileged action ( ) ; privileged action < object > pa null = null ; try { object obj = subject . do as ( null , pa ) ; } catch ( exception e ) { fail ( str + e ) ; } try { object obj = subject . do as ( subj , pa ) ; } catch ( exception e ) { fail ( str + e ) ; } try { object obj = subject . do as ( subj , pa null ) ; fail ( str ) ; } catch ( null pointer exception npe ) { } }	javax . security . auth . subject # doas ( subject subject , privilegedaction action ).
public void test divide exp less zero ( ) { string a = str ; int a scale = num ; string b = str ; int b scale = num ; string c = str ; int res scale = - num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; big decimal result = a number . divide ( b number , res scale , big decimal . round ceiling ) ; assert equals ( str , c , result . to string ( ) ) ; assert equals ( str , res scale , result . scale ( ) ) ; }	divide : local variable exponent is less than zero.
public static boolean contains whitespace ( final char sequence seq ) { if ( is empty ( seq ) ) { return bool ; } final int str len = seq . length ( ) ; for ( int i = num ; i < str len ; i ++ ) { if ( character . is whitespace ( seq . char at ( i ) ) ) { return bool ; } } return bool ; }	check whether the given charsequence contains any whitespace characters .
public boolean is wheel event ( ) { return is wheel event ; }	indicates a mouse wheel event .
public connection ( string client handle , string client id , string host , int port , context context , mqtt android client client , boolean ssl connection ) { this . client handle = client handle ; this . client id = client id ; this . host = host ; this . port = port ; this . context = context ; this . client = client ; this . ssl connection = ssl connection ; history = new array list < string > ( ) ; string buffer sb = new string buffer ( ) ; sb . append ( str ) ; sb . append ( client id ) ; sb . append ( str ) ; add action ( sb . to string ( ) ) ; }	creates a connection object with the server information and the client hand which is the reference used to pass the client around activities.
public void record state ( dialogue state state , string name ) { if ( frame != null ) { state monitor tab . record state ( state , name ) ; } }	records a dialogue state in the component and makes it available for display in the network selection list on the left side.
public void characters ( org . w3c . dom . node node ) throws org . xml . sax . sax { flush pending ( ) ; string data = node . get node value ( ) ; if ( data != null ) { final int length = data . length ( ) ; if ( length > m chars buff . length ) { m chars buff = new char [ length * num + num ] ; } data . get chars ( num , length , m chars buff , num ) ; characters ( m chars buff , num , length ) ; } }	this method gets the nodes value as a string and uses that string as if it were an input character notification .
private void compute filters from default ( indicator view state old state ) { filters = new array list < filter > ( ) ; set < string > default filter names = new hash set < string > ( ) ; for ( filter default filter : default filters ) { filters . add ( default filter ) ; if ( default filter . name != null ) default filter names . add ( default filter . name ) ; } if ( old state != null ) { for ( filter old filter : old state . filters ) { if ( old filter . name == null || ! default filter names . contains ( old filter . name ) ) filters . add ( old filter ) ; } } }	computes the filters by combining the default filters and the user - defined filters stored in the previously saved state .
private static data parse name ( set me , set peer ) { if ( me == null ) { throw new null pointer exception ( str ) ; } else if ( me . is empty ( ) ) { throw new illegal argument exception ( str ) ; } data data = new data ( ) ; string buffer b = new string buffer ( ) ; data . me = cons ( me , b ) ; if ( peer != null && ! peer . is empty ( ) ) { b . append ( str ) ; data . peer = cons ( peer , b ) ; } data . name = b . to string ( ) ; return data ; }	constructs the target name and transient field data for the specified principal sets .
public static boolean stream content equals ( input stream s1 , input stream s2 ) throws io { try { int b1 , b2 ; do { b1 = s1 . read ( ) ; b2 = s2 . read ( ) ; } while ( ( b1 == b2 ) && ( b1 != - num ) ) ; return b1 == b2 ; } finally { try { s1 . close ( ) ; s2 . close ( ) ; } catch ( exception e ) { } } }	checks if both inputstreams have the same content and length.
static public void add ( errors errors , string text ) { if ( errors == null ) { return ; } errors . add ( text ) ; }	helper function that discards the text if ` errors ` is null .
public synchronized void remove icons for pkg ( string package name , user handle compat user ) { remove from mem cache locked ( package name , user ) ; long user serial = m user manager . get serial number for user ( user ) ; m icon db . delete ( db . column component + str + db . column user + str , new string [ ] { package name + str , long . to string ( user serial ) } ) ; }	removes the entries related to the given package in memory and persistent db .
public boolean contains ( string s category ) { return category estimations . contains key ( s category ) ; }	returns whether there is an estimation for a given category in the set of estimations .
public static final void front end statistics ( spec obj spec ) { }	this method should print statistics about the specification it is obviously not finished .
public string to string ( ) { if ( not before == null || not after == null ) return str ; return ( str + not before . to string ( ) + str + not after . to string ( ) + str ) ; }	return the validity period as user readable string .
public void zoom ( double x , double y , double factor ) { double range x = math . abs ( current extent . get max x ( ) - current extent . get min x ( ) ) ; double range y = math . abs ( current extent . get max y ( ) - current extent . get min y ( ) ) ; current extent . set min x ( x - ( range x * factor ) / num ) ; current extent . set min y ( y - ( range y * factor ) / num ) ; current extent . set max x ( x + ( range x * factor ) / num ) ; current extent . set max y ( y + ( range y * factor ) / num ) ; add to extent history ( current extent ) ; }	performs a zoom and center operation.
protected boolean is output line expected ( final string line , final string [ ] expected prefixes , final boolean file paths are expected ) { final string trimmed = line != null ? line . trim ( ) : null ; if ( string utils . is not empty ( trimmed ) ) { if ( file paths are expected && is file path ( line ) ) { return bool ; } if ( expected prefixes != null ) { for ( final string prefix : expected prefixes ) { if ( string utils . starts with ignore case ( line , prefix ) ) { return bool ; } } } return bool ; } return bool ; }	this method evaluates a line of output to see if it contains something that is expected.
public static string meter to string ( of inst , logger log ) { return str sub goto meter meter id + str + long . to string ( inst . get meter id ( ) ) ; }	convert an ofinstructionmeter to string form.
public boolean is image cachable ( int w , int h ) { return ( w * h ) < max single image pixel size ; }	check if the image size is to big to be stored in the cache .
public void free entry ( basic pool entry entry ) { if ( num entries < num ) { throw new illegal state exception ( str + route ) ; } if ( num entries <= free entries . size ( ) ) { throw new illegal state exception ( str + route ) ; } free entries . add ( entry ) ; }	returns an allocated entry to this pool .
public boolean is in ( coords coords ) { return coordinates . contains ( coords ) ; }	determine if the building occupies given coordinates.
private dialog base units compute dialog base units ( font metrics metrics ) { double average char width = compute average char width ( metrics , average char width test string ) ; int ascent = metrics . get ascent ( ) ; double height = ascent > num ? ascent : ascent + ( num - ascent ) / num ; dialog base units dialog base units = new dialog base units ( average char width , height ) ; if ( logger . is loggable ( level . config ) ) { logger . config ( str + dialog base units + str + metrics . get font ( ) ) ; } return dialog base units ; }	computes and returns the horizontal dialog base units.
public synchronized void close ( ) { try { writer . close ( ) ; } catch ( io ioe ) { ioe . print stack trace ( ) ; } }	closes the output writer .
public static boolean is proxy uri ( final string url ) { not null ( url ) ; return url . contains ( get request handler path ( ) ) ; }	checks if the provided url is a resource proxy request .
public void add action ( action act ) { if ( act . entry != null && act . entry != this ) { log . e ( tag , str + act . entry . id + str + id ) ; return ; } if ( m actions == null ) { m actions = new array list < action > ( ) ; } if ( m actions . size ( ) == num ) { log . w ( tag , str ) ; return ; } act . entry = this ; m actions . add ( act ) ; }	add a action to this notification.
public abstract iterable < ? extends compilation unit tree > parse ( ) throws io ;	parse the specified files returning a list of abstract syntax trees .
private void name ( string builder builder ) { string name = type . get name ( ) ; if ( name != null ) { builder . append ( str ) ; builder . append ( name ) ; builder . append ( str ) ; } }	this is used to build a string from the annotation.
boolean ensure process size fits ( final execution unit process , final d rect ) { dimension process size = model . get process size ( process ) ; if ( process size == null ) { return bool ; } if ( rect == null ) { return bool ; } boolean needs resize = bool ; double process width = process size . get width ( ) * ( num / model . get zoom factor ( ) ) ; double process height = process size . get height ( ) * ( num / model . get zoom factor ( ) ) ; double width = process width ; double height = process height ; if ( process size != null ) { if ( process width < rect . get max x ( ) + process drawer . grid x offset ) { double diff = rect . get max x ( ) + process drawer . grid x offset - process width ; if ( diff > process drawer . grid x offset ) { width += diff ; } else { width += process drawer . grid x offset ; } needs resize = bool ; } if ( process height < rect . get max y ( ) + process drawer . grid y offset ) { double diff = rect . get max y ( ) + process drawer . grid y offset - process height ; if ( diff > process drawer . grid y offset ) { height += diff ; } else { height += process drawer . grid y offset ; } needs resize = bool ; } if ( needs resize ) { model . set process width ( process , width ) ; model . set process height ( process , height ) ; balance ( ) ; model . fire process size changed ( ) ; return bool ; } } return bool ; }	increases the process size if necessary for the given operator .
public void handle tbl handlers button add request ( request invocation event event ) throws model control exception { try { map values = get values ( ) ; on before save profile ( values ) ; set page session attribute ( property attribute , ( hash map ) values ) ; ws n vb = ( ws n ) get view bean ( ws n . class ) ; unlock page trail ( ) ; pass pg session map ( vb ) ; vb . forward to ( get request context ( ) ) ; } catch ( am e ) { set inline alert message ( cc . type error , str , e . get message ( ) ) ; } }	handles add handler request .
public void reduce dl ( double exp fp , boolean check err ) { boolean need update = bool ; double [ ] ruleset stat = new double [ num ] ; for ( int j = num ; j < m . size ( ) ; j ++ ) { ruleset stat [ num ] += m . get ( j ) [ num ] ; ruleset stat [ num ] += m . get ( j ) [ num ] ; ruleset stat [ num ] += m . get ( j ) [ num ] ; if ( j == m . size ( ) - num ) { ruleset stat [ num ] = m . get ( j ) [ num ] ; ruleset stat [ num ] = m . get ( j ) [ num ] ; ruleset stat [ num ] = m . get ( j ) [ num ] ; } } for ( int k = m . size ( ) - num ; k >= num ; k -- ) { double [ ] rule stat = m . get ( k ) ; double if deleted = potential ( k , exp fp , ruleset stat , rule stat , check err ) ; if ( ! double . is na n ( if deleted ) ) { if ( k == ( m . size ( ) - num ) ) { remove last ( ) ; } else { m . remove ( k ) ; need update = bool ; } } } if ( need update ) { m = null ; m = null ; count data ( ) ; } }	try to reduce the dl of the ruleset by testing removing the rules one by one in reverse order and update all the stats.
@ override public void on draw frame ( g gl10 ) { gle . gl clear color ( num , num , num , num ) ; gle . gl clear ( gle . gl color buffer bit | gle . gl depth buffer bit ) ; gle . gl enable ( gle . gl depth test ) ; gle . gl enable ( gle . gl cull face ) ; gle . gl enable ( gle . gl blend ) ; gle . gl blend func ( gle . gl src alpha , gle . gl one minus src alpha ) ; long current time millis = system . current time millis ( ) ; update with delta ( current time millis - last time millis ) ; last time millis = current time millis ; }	glsurfaceview has default 16bit depth buffer.
public void remove line highlight ( object tag ) { if ( tag instanceof line highlight info ) { line highlights . remove ( tag ) ; repaint line ( ( line highlight info ) tag ) ; } }	removes a line highlight .
private element create single log out for castle as idp ( string binding ) throws exception { string entity id = idm client . get entity id ( tenant name ) ; string sso loc = convert to ip ( entity id ) ; if ( sso loc == null ) { sso loc = tenant name ; } string slo loc = sso loc . replace all ( str , str ) ; element slos ele = create end point ( saml . slos , binding , slo loc , null ) ; return slos ele ; }	return singlelogoutservice element for castle as idp .
public static void unregister transport m ( string container name ) throws exception { m m bean server = get m ( container name ) ; if ( m bean server == null ) return ; object name transport m = transport constants . create transport m ( container name ) ; if ( m bean server . is registered ( transport m ) ) { m bean server . unregister m ( transport m ) ; if ( logger . is loggable ( level . fine ) ) { logger . fine ( str ) ; } } }	release transport mbean registration .
public void add nodes in doc order ( node iterator iterator , x support ) { if ( ! m mutable ) throw new runtime exception ( xsl . create xpath ( xpath . er nodeset not mutable , null ) ) ; node node ; while ( null != ( node = iterator . next node ( ) ) ) { add node in doc order ( node , support ) ; } }	copy nodelist members into this nodelist , adding in document order.
protected void uninstall defaults ( ) { sea glass context context = get context ( split pane , enabled ) ; style . uninstall defaults ( context ) ; context . dispose ( ) ; style = null ; context = get context ( split pane , region . split pane divider , enabled ) ; divider style . uninstall defaults ( context ) ; context . dispose ( ) ; divider style = null ; super . uninstall defaults ( ) ; }	uninstalls the ui defaults .
public void subtract amount ( final string amount ) { subtract amount ( integer . parse int ( amount ) ) ; }	subtract the specified amount from the still needed amount .
private synchronized void make composite builder ( ) throws invalid object exception { if ( composite builder != null ) return ; class < ? > target class = ( class < ? > ) get java type ( ) ; composite builder [ ] [ ] builders = { { new composite builder via from ( target class , item names ) } , { new composite builder via constructor ( target class , item names ) } , { new composite builder check getters ( target class , item names , getter mappings ) , new composite builder via setters ( target class , item names ) , new composite builder via proxy ( target class , item names ) } } ; composite builder found builder = null ; final string builder why nots = new string builder ( ) ; throwable possible cause = null ; find : for ( composite builder [ ] related builders : builders ) { for ( int i = num ; i < related builders . length ; i ++ ) { composite builder builder = related builders [ i ] ; string why not = builder . applicable ( getters ) ; if ( why not == null ) { found builder = builder ; break find ; } throwable cause = builder . possible cause ( ) ; if ( cause != null ) possible cause = cause ; if ( why not . length ( ) > num ) { if ( why nots . length ( ) > num ) why nots . append ( str ) ; why nots . append ( why not ) ; if ( i == num ) break ; } } } if ( found builder == null ) { string msg = str + target class . get name ( ) + str + why nots ; if ( possible cause != null ) msg += str ; throw invalid object exception ( msg , possible cause ) ; } composite builder = found builder ; }	determine how to convert back from the compositedata into the original java type.
public void invalidate all ( ) { if ( m tuples == null ) return ; for ( int i = num ; i < m tuples . length ; ++ i ) invalidate ( i ) ; }	invalidate all tuples managed by this tuplemanager.
public void add ( final long addr ) { addrs . add ( addr ) ; }	add an address to this bucket .
@ android only ( str ) public void test wrap 04 ( ) { string host = str ; int port = num ; byte buffer bbs = byte buffer . allocate ( num ) ; byte buffer bbd = byte buffer . allocate ( num ) ; ssl sse = get engine ( host , port ) ; try { sse . wrap ( bbs , bbd ) ; fail ( str ) ; } catch ( illegal state exception iobe ) { } catch ( exception e ) { fail ( e + str ) ; } }	javax . net . ssl . sslengine # wrap ( bytebuffer src , bytebuffer dst ) illegalstateexception should be thrown .
public static boolean is black listed ( @ nonnull size size , @ nonnull string blacklist string ) { string [ ] blacklist string array = blacklist string . split ( str ) ; if ( blacklist string array . length == num ) { return bool ; } set < string > blacklisted sizes = new hash set ( lists . new array list ( blacklist string array ) ) ; return is black listed ( size , blacklisted sizes ) ; }	returns whether the given size is within the blacklist string .
static private void write dec ref ( writer out , char ch ) throws io { if ( ch == str ) { out . write ( str ) ; return ; } out . write ( str ) ; int i = ( int ) ch ; if ( i > num ) { out . write ( str + ( i / num ) ) ; i = i % num ; out . write ( str + ( i / num ) ) ; i = i % num ; out . write ( str + ( i / num ) ) ; i = i % num ; out . write ( str + ( i / num ) ) ; i = i % num ; out . write ( str + i ) ; } else if ( i > num ) { out . write ( str + ( i / num ) ) ; i = i % num ; out . write ( str + ( i / num ) ) ; i = i % num ; out . write ( str + ( i / num ) ) ; i = i % num ; out . write ( str + i ) ; } else { out . write ( str + ( i / num ) ) ; i = i % num ; out . write ( str + ( i / num ) ) ; i = i % num ; out . write ( str + i ) ; } out . write ( str ) ; }	writes a character as a decimal escape.
protected byte [ ] input stream to byte array ( input stream is ) throws io { byte array output stream bos = new byte array output stream ( ) ; int next = is . read ( ) ; while ( next > - num ) { bos . write ( next ) ; next = is . read ( ) ; } bos . flush ( ) ; is . close ( ) ; return bos . to byte array ( ) ; }	reads an input stream into a byte array.
@ override public string to string ( ) { object value = get ( ) ; return value == null ? str : value . to string ( ) ; }	returns the value as string .
private boolean is a ( string str ) { if ( str == null ) { return bool ; } return str . index of ( str ) == num && str . last index of ( str ) == ( str . length ( ) - num ) ; }	check if the phone number is actually a reference to a data from the intent or external parameter .
protected static string encode ( string url ) { string builder encoder = new string builder ( ) ; for ( char chr : url . to char array ( ) ) { byte chr byte = ( byte ) chr ; if ( ( chr byte <= num || chr byte >= num || chr == str || chr == str ) ) { encoder . append ( string . format ( str , chr byte ) ) ; } else { encoder . append ( chr ) ; } } return encoder . to string ( ) ; }	replaces all special characters in the url with hex strings .
public void test x509 crl ( ) { tbtcrl tbt crlentry = new tbtcrl ( ) ; assert null ( tbt crlentry . get certificate issuer ( ) ) ; assert null ( tbt crlentry . get critical extension oi ( ) ) ; try { assert null ( tbt crlentry . get encoded ( ) ) ; } catch ( crl e ) { fail ( str + e . get message ( ) ) ; } assert null ( tbt crlentry . get non critical extension oi ( ) ) ; assert null ( tbt crlentry . get revocation date ( ) ) ; }	x509crlentry ( ) method testing.
private binlog position find heartbeat ( maxwell replicator r ) throws exception { r . start replicator ( ) ; for ( row map row = r . get row ( ) ; row != null ; row = r . get row ( ) ) { if ( objects . equals ( r . get last heartbeat read ( ) , recovery info . heartbeat ) ) return row . get position ( ) ; } return null ; }	try to find a given heartbeat value from the replicator .
private configure ( ) { properties p = new properties ( ) ; map args = new hash map ( ) ; args . put all ( system . getenv ( ) ) ; args . put all ( system . get properties ( ) ) ; p . put all ( args ) ; this . property = p ; reload ( bool ) ; }	sometimes call by sample application , at that time normally set some properties directly.
private void handle truncated info ( final statement info info ) throws sql { final byte [ ] original info = statement . get statement info request items ( ) ; final byte [ ] new info items = new byte [ original info . length + num * num ] ; int new index = num ; for ( final byte info item : original info ) { assert new index < new info items . length : str ; switch ( info item ) { case isc . isc info sql select : case isc . isc info sql bind : final row descriptor builder current builder = info item == isc . isc info sql select ? info . field builder : info . parameter builder ; final int descriptor index = current builder != null ? current builder . get first unprocessed index ( ) + num : num ; new info items [ new index ++ ] = isc . isc info sql sqlda start ; new info items [ new index ++ ] = num ; new info items [ new index ++ ] = ( byte ) ( descriptor index & num ) ; new info items [ new index ++ ] = ( byte ) ( descriptor index > > num ) ; new info items [ new index ++ ] = info item ; break ; default : new info items [ new index ++ ] = info item ; break ; } } assert new index == new info items . length : str ; info . request buffer size = math . min ( num * info . request buffer size , statement . get max sql info size ( ) ) ; info . buffer = statement . get sql info ( new info items , info . request buffer size ) ; info . current index = num ; }	handles info buffer truncation by requesting new information.
public static string strip file extension ( string name ) { int pos = name . last index of ( str ) ; if ( pos > num & pos < name . length ( ) - num ) return name . substring ( num , pos ) ; return name ; }	remove the extension from the file name.
private static void push transaction start stamp ( transaction t ) { map < transaction , timestamp > map = suspended tx start stamps . get ( ) ; timestamp stamp = transaction start stamp . get ( ) ; if ( stamp != null ) { map . put ( t , stamp ) ; } else { debug . log error ( str , module ) ; } }	put the stamp to remember later.
private int indexed binary search ( list < s2 cell id > l , s2 cell id key , int low ) { int high = l . size ( ) - num ; while ( low <= high ) { int mid = ( low + high ) > > num ; s2 cell id mid val = l . get ( mid ) ; int cmp = mid val . compare to ( key ) ; if ( cmp < num ) { low = mid + num ; } else if ( cmp > num ) { high = mid - num ; } else { return mid ; } } return low ; }	just as normal binary search , except that it allows specifying the starting value for the lower bound .
public variable [ ] find local arrays ( ) { list < variable > arrays = new array list < variable > ( ) ; for ( list iterator < variable > iterator = f local variables . list iterator ( f local variables . size ( ) ) ; iterator . has previous ( ) ; ) { variable local variable = iterator . previous ( ) ; if ( local variable . is array ( ) ) arrays . add ( local variable ) ; } return arrays . to array ( new variable [ arrays . size ( ) ] ) ; }	returns all local arrays in the order that they appear .
public static int index of java like extension ( string file name ) { int file name length = file name . length ( ) ; char [ ] [ ] java like extensions = get java like extensions ( ) ; extensions : for ( int i = num , length = java like extensions . length ; i < length ; i ++ ) { char [ ] extension = java like extensions [ i ] ; int extension length = extension . length ; int extension start = file name length - extension length ; int dot index = extension start - num ; if ( dot index < num ) continue ; if ( file name . char at ( dot index ) != str ) continue ; for ( int j = num ; j < extension length ; j ++ ) { if ( file name . char at ( extension start + j ) != extension [ j ] ) continue extensions ; } return dot index ; } return - num ; }	returns the index of the java like extension of the given file name or - 1 if it doesn ' t end with a known java like extension.
public shape tile simplex remove border line ( int p no ) { if ( p no < num || p no >= lines size ( ) ) { return this ; } array list < pla line int > new arr = new array list < pla line int > ( lines size ( ) ) ; new arr . add all ( lines list ) ; new arr . remove ( p no ) ; return new shape tile simplex ( new arr ) ; }	enlarges the simplex by removing the edge line with index p_no.
protected boolean wait before execution ( ) throws interrupted exception { return bool ; }	provides an opportunity to pause before executing the protocol .
static boolean is valid streaming url ( string url ) { return url != null && url . matches ( str ) ; }	checks if a given string is a valid twitch url ( ie , one that will display " streaming " on the discord client .
public web service proxy ( url server url , executor service executor service ) { this ( server url , executor service , num , num ) ; }	creates a new web service proxy .
private static byte [ ] expose byte array input stream bytes ( byte array input stream bais ) { byte [ ] buffer ; synchronized ( bais ) { byte [ ] buf ; int pos ; try { buf = ( byte [ ] ) bais buf . get ( bais ) ; pos = bais pos . get int ( bais ) ; } catch ( illegal access exception iae ) { throw new assertion error ( iae ) ; } int available = bais . available ( ) ; if ( pos == num && buf . length == available ) { buffer = buf ; } else { buffer = new byte [ available ] ; system . arraycopy ( buf , pos , buffer , num , available ) ; } bais . skip ( available ) ; } return buffer ; }	returns a byte [ ] containing all the bytes from a bytearrayinputstream.
private void restore data ( ) { map < string , ? > map = preference utils . get all ( ) ; set < string > strings = map . key set ( ) ; for ( string string : strings ) { if ( string . starts with ( shared preference utils . key test mode ) ) { preference utils . restore key ( string ) ; } } refresh key values ( ) ; }	restore values of original keys stored .
public string put image ( string the folder , string the image name , bitmap the bitmap ) { if ( the folder == null || the image name == null || the bitmap == null ) return null ; this . default app imagedata directory = the folder ; string m full path = setup full path ( the image name ) ; if ( ! m full path . equals ( str ) ) { last image path = m full path ; save bitmap ( m full path , the bitmap ) ; } return m full path ; }	saves ' thebitmap ' into folder ' thefolder ' with the name ' theimagename '.
public class < ? > type ( ) { if ( is class ) { return ( class < ? > ) object ; } else { return object . get class ( ) ; } }	get the type of the wrapped object .
void add to external css ( css css element ) { if ( external css == null ) { external css = new vector ( ) ; } external css . add element ( css element ) ; }	adds the specified csselement which represents an external css file to the external css vector.
private void remove ( string world , permission holder holder , string permission ) { try { if ( world != null && ! world . equals ( str ) ) { holder . unset permission ( permission , server , world ) ; } else { holder . unset permission ( permission , server ) ; } } catch ( object lacks exception ignored ) { } save ( holder ) ; }	generic method to remove a permission from a holder.
private void action tree add all ( ) { log . info ( str ) ; list model model = center list . get model ( ) ; int size = model . get size ( ) ; int index = - num ; for ( index = num ; index < size ; index ++ ) { list item item = ( list item ) model . get element at ( index ) ; action tree add ( item ) ; } }	action : add all nodes to tree.
private concurrent skip list map . node < k , v > hi node ( ) { if ( hi == null ) return m . find last ( ) ; else if ( hi inclusive ) return m . find near ( hi , lt | eq ) ; else return m . find near ( hi , lt ) ; }	returns highest node . this node might not be in range , so most usages need to check bounds .
public static final image point convert point ( map point map point , map envelope map env , int img height , int img width ) { long image y = math . round ( convert y ( map point , map env , img height ) ) ; long image x = math . round ( convert x ( map point , map env , img width ) ) ; return new image point ( image x , image y ) ; }	this method assumes that parameter p is a doittpoint in map coordinates and converts it under the assumption that the mapenv parameter field is properly set in map coordinates and that the imgheight and imgwidth are the dimensions of the map image in pixels .
private void check using adaptation ( ) { if ( ts use adaptation . is selected ( ) ) { tf adaptation time . set enabled ( bool ) ; tf adaptation param . set enabled ( bool ) ; } else { tf adaptation time . set enabled ( bool ) ; tf adaptation param . set enabled ( bool ) ; } }	checks for using adaptation and enables or disables adaptation field accordingly .
public string combine mix ( list < string > files , string out file ) { array list < string > cmd = new array list < string > ( ) ; cmd . add ( sox bin ) ; cmd . add ( str ) ; for ( string file : files ) { cmd . add ( str ) ; cmd . add ( str ) ; cmd . add ( file ) ; } cmd . add ( out file ) ; try { int rc = exec sox ( cmd , callback ) ; if ( rc != num ) { out file = null ; } } catch ( io e ) { e . print stack trace ( ) ; } catch ( interrupted exception e ) { e . print stack trace ( ) ; } return out file ; }	combine and mix audio files sox - m - v 1.
public quarter ( int quarter , year year ) { if ( ( quarter < first quarter ) || ( quarter > last quarter ) ) { throw new illegal argument exception ( str ) ; } this . year = ( short ) year . get year ( ) ; this . quarter = ( byte ) quarter ; peg ( calendar . get instance ( ) ) ; }	constructs a new quarter .
public void send request vote request ( boolean is prevote ) throws gondola exception { if ( ! enabled || master id >= num ) { return ; } if ( ! is prevote ) { current term ++ ; voted for = - num ; save ( current term , member id ) ; voted for = member id ; } prevotes only = is prevote ; message message = pool . checkout ( ) ; try { save queue . get latest ( saved rid ) ; message . request vote request ( member id , current term , is prevote , saved rid ) ; peers . for each ( null ) ; } finally { message . release ( ) ; } prevote ts = clock . now ( ) + ( long ) ( ( math . random ( ) * prevote period ) ) ; if ( ! is prevote ) { prevote ts += election timeout ; } }	if not a prevote , increments the current term before sending out the message .
private list < string > filter targets from response ( set < string > varray tagged port ww , map < string , list < string > > initiator target map , string initiator key ) { log . debug ( str ) ; list < string > filtered target list = new array list < string > ( ) ; list < string > target port list from response = initiator target map . get ( initiator key ) ; for ( string port wwn : target port list from response ) { if ( varray tagged port ww . contains ( port wwn ) || varray tagged port ww . contains ( port wwn . to upper case ( ) ) ) { filtered target list . add ( port wwn . to upper case ( ) ) ; } } log . debug ( str ) ; return filtered target list ; }	filters the target port list from the response based on the varray tagging .
public piloting roll data check maneuver ( move step step , entity movement type overall move type ) { piloting roll data roll = get base piloting roll ( overall move type ) ; if ( ( step == null ) || ( step . get type ( ) != move step type . maneuver ) ) { roll . add modifier ( target roll . check false , str ) ; return roll ; } boolean side slip mod = ( this instanceof conv fighter ) && is vstol ( ) ; roll . append ( new piloting roll data ( get id ( ) , maneuver type . get mod ( step . get maneuver type ( ) , side slip mod ) , maneuver type . get type name ( step . get maneuver type ( ) ) + str ) ) ; return roll ; }	checks if a maneuver requires a control roll.
public static list < string > parse program args ( i launch config ) throws core exception { return parse args ( launch config . get attribute ( i . attr program arguments , str ) ) ; }	parses the program arguments from the launch configuration into a list of arguments .
public abstract t decode value ( string value ) ;	parse and validate a string representation of a property value .
@ override public synchronized mx mapping for type ( type obj type , mx factory ) throws open data exception { if ( in progress . contains key ( obj type ) ) { throw new open data exception ( str + type name ( obj type ) ) ; } mx mapping ; mapping = get mapping ( obj type ) ; if ( mapping != null ) return mapping ; in progress . put ( obj type , obj type ) ; try { mapping = make mapping ( obj type , factory ) ; } catch ( open data exception e ) { throw open data exception ( str + type name ( obj type ) , e ) ; } finally { in progress . remove ( obj type ) ; } put mapping ( obj type , mapping ) ; return mapping ; }	get the converter for the given java type , creating it if necessary .
public static element create element in signature11 space ( document doc , string element name ) { if ( doc == null ) { throw new runtime exception ( str ) ; } if ( ( ds11 prefix == null ) || ( ds11 prefix . length ( ) == num ) ) { return doc . create element ns ( constants . ns , element name ) ; } return doc . create element ns ( constants . ns , ds11 prefix + str + element name ) ; }	creates an element in the xml signature 1.
public void remove element at ( final int index ) { entries . remove ( index ) ; }	remove an element of the row represented by its index.
public static void c2ir ( double c [ ] , int nc , double hh [ ] , int leng ) { hh [ num ] = math . exp ( c [ num ] ) ; for ( int n = num ; n < leng ; n ++ ) { double d = num ; int upl = ( n >= nc ) ? nc - num : n ; for ( int k = num ; k <= upl ; k ++ ) d += k * c [ k ] * hh [ n - k ] ; hh [ n ] = d / n ; } }	c2ir : the minimum phase impulse response is evaluated from the minimum phase cepstrum.
public void close ( ) { nc guards = null ; }	kill ncguards , so we do not use outdated mappings unintendedly later on.
public void process indication ( hashtable < string , string > cim notification ) { string cim indication type = get cim indication type ( cim notification ) ; if ( monitoring properties loader . is to log indications ( ) ) { logger . debug ( str + get indication data ( cim notification ) ) ; } if ( cim indication type != null && cim indication type . equals ( cim constants . cim alert indication type ) ) { if ( monitoring properties loader . is to log indications ( ) ) { logger . debug ( str ) ; } alert processor . process indication ( cim notification ) ; } else if ( cim indication type != null && cim indication type . equals ( cim constants . cim inst indication type ) ) { if ( monitoring properties loader . is to log indications ( ) ) { logger . debug ( str ) ; } event processor . process indication ( cim notification ) ; } else { if ( monitoring properties loader . is to log indications ( ) ) { logger . debug ( str , cim indication type ) ; } } }	indication will be inserted into cassandra provided timestamp as row key.
public replication job create job for copy table ( long audit log id , long audit log entry create time , table table ) throws state update exception { replication operation replication operation = hive utils . is partitioned ( table ) ? replication operation . copy partitioned table : replication operation . copy unpartitioned table ; map < string , string > extras = new hash map < > ( ) ; extras . put ( persisted job info . audit log id extras key , long . to string ( audit log id ) ) ; extras . put ( persisted job info . audit log entry create time key , long . to string ( audit log entry create time ) ) ; persisted job info persisted job info = job info store . resilient create ( replication operation , replication status . pending , replication utils . get location ( table ) , src cluster . get name ( ) , new hive object spec ( table ) , collections . empty list ( ) , replication utils . get tldt ( table ) , optional . empty ( ) , optional . empty ( ) , extras ) ; hive object spec spec = new hive object spec ( table ) ; optional < path > table location = replication utils . get location ( table ) ; switch ( replication operation ) { case copy unpartitioned table : return new replication job ( conf , new copy unpartitioned table task ( conf , destination object factory , object conflict handler , src cluster , dest cluster , spec , table location , directory copier , bool ) , on state change handler , persisted job info ) ; case copy partitioned table : return new replication job ( conf , new copy partitioned table task ( conf , destination object factory , object conflict handler , src cluster , dest cluster , spec , table location ) , on state change handler , persisted job info ) ; default : throw new runtime exception ( str + replication operation ) ; } }	create a replication job to copy a table .
synchronized public void release xml ( xml reader ) { if ( m reader manager != null ) { m reader manager . release xml ( reader ) ; } }	indicates that the xmlreader object is no longer in use for the transform.
public int un finish size ( ) { return m un finish queue . size ( ) ; }	returns have started but not the end of the request queue size .
public void add sample ( int weight , float value ) { ensure sorted by index ( ) ; sample new sample = recycled sample count > num ? recycled samples [ -- recycled sample count ] : new sample ( ) ; new sample . index = next sample index ++ ; new sample . weight = weight ; new sample . value = value ; samples . add ( new sample ) ; total weight += weight ; while ( total weight > max weight ) { int excess weight = total weight - max weight ; sample oldest sample = samples . get ( num ) ; if ( oldest sample . weight <= excess weight ) { total weight -= oldest sample . weight ; samples . remove ( num ) ; if ( recycled sample count < max recycled samples ) { recycled samples [ recycled sample count ++ ] = oldest sample ; } } else { oldest sample . weight -= excess weight ; total weight -= excess weight ; } } }	record a new observation.
private void specialised predicates ( ) { double predicate double predicate = null ; long predicate long predicate = null ; }	examples of double and long predicates.
private static final synchronized int next pool id ( ) { return ++ pool number sequence ; }	returns the next sequence number.
public static boolean sec key verify ( byte [ ] seckey ) { preconditions . check argument ( seckey . length == num ) ; byte buffer byte buff = native ecdsa . get ( ) ; if ( byte buff == null || byte buff . capacity ( ) < seckey . length ) { byte buff = byte buffer . allocate direct ( seckey . length ) ; byte buff . order ( byte order . native order ( ) ) ; native ecdsa . set ( byte buff ) ; } byte buff . rewind ( ) ; byte buff . put ( seckey ) ; r . lock ( ) ; try { return secp256k1 ec seckey verify ( byte buff , secp256k1 context . get context ( ) ) == num ; } finally { r . unlock ( ) ; } }	libsecp256k1 seckey verify - returns 1 if valid , 0 if invalid.
public tree node iterator ( node root , boolean preorder ) { m preorder = preorder ; m root = root ; m stack = new array list ( ) ; m stack . add ( root ) ; if ( ! preorder ) { for ( node n = root . get child ( num ) ; n != null ; n = n . get child ( num ) ) m stack . add ( n ) ; } }	create a new treenodeiterator over the given subtree .
public static writable native array make native array ( list objects ) { writable native array native array = new writable native array ( ) ; if ( objects == null ) { return native array ; } for ( object elem : objects ) { elem = make native object ( elem ) ; if ( elem == null ) { native array . push null ( ) ; } else if ( elem instanceof boolean ) { native array . push boolean ( ( boolean ) elem ) ; } else if ( elem instanceof integer ) { native array . push int ( ( integer ) elem ) ; } else if ( elem instanceof double ) { native array . push double ( ( double ) elem ) ; } else if ( elem instanceof string ) { native array . push string ( ( string ) elem ) ; } else if ( elem instanceof writable native array ) { native array . push array ( ( writable native array ) elem ) ; } else if ( elem instanceof writable native map ) { native array . push map ( ( writable native map ) elem ) ; } else { throw new illegal argument exception ( str + elem . get class ( ) ) ; } } return native array ; }	this method converts a list into a nativearray.
@ override public void node changed ( ) { log . info ( str ) ; wakeup ( ) ; }	called when user update the site.
private static node pair split block ( final view view , final function function , final code node node , final instruction instruction ) { boolean before = bool ; final list < instruction > before instructions = new array list < instruction > ( ) ; final list < instruction > after instructions = new array list < instruction > ( ) ; for ( final instruction node instruction : node . get instructions ( ) ) { if ( before ) { before instructions . add ( node instruction ) ; } else { after instructions . add ( node instruction ) ; } if ( node instruction == instruction ) { before = bool ; } } if ( after instructions . is empty ( ) ) { return new node pair ( node , null ) ; } else { final code node first node = view . create code node ( function , before instructions ) ; final code node second node = view . create code node ( function , after instructions ) ; first node . set color ( node . get color ( ) ) ; second node . set color ( default block color ) ; for ( final view edge edge : node . get incoming edges ( ) ) { final view edge new edge = view . create edge ( edge . get source ( ) , first node , edge . get type ( ) ) ; new edge . set color ( edge . get color ( ) ) ; } for ( final view edge edge : node . get outgoing edges ( ) ) { final view edge new edge = view . create edge ( second node , edge . get target ( ) , edge . get type ( ) ) ; new edge . set color ( edge . get color ( ) ) ; } view . delete node ( node ) ; return new node pair ( first node , second node ) ; } }	splits a code node into two nodes at a function call.
public pair < string , string > object to string ( final long shop id , final string currency , final big decimal regular price ) { return new pair < string , string > ( str + shop id + str + currency , money bridge . object to string ( regular price ) ) ; }	create index value for given shop currency and price .
public string read line ( ) throws io { string builder line = new string builder ( ) ; int i ; char c ; i = read ( ) ; if ( i == - num ) return null ; while ( i > - num && i != str && i != str ) { c = ( char ) ( i & num ) ; line = line . append ( c ) ; i = read ( ) ; } if ( i == str ) { if ( ( i = read ( ) ) != str ) throw new io ( str + integer . to hex string ( i ) + str + line ) ; } return line . to string ( ) ; }	a method to read a line from the stream up to and including the cr or crlf.
static public void force creation of new index ( ) { force creation of new index ( bool ) ; }	force creation of a new user index without incrementing version.
public signal barrier ( ) { owner = null ; }	create a new signalbarrier without an owner .
private static float [ ] normalize ( float [ ] coefficients ) { float accumulator = num ; for ( int x = num ; x < coefficients . length ; x ++ ) { accumulator += math . abs ( coefficients [ x ] ) ; } for ( int x = num ; x < coefficients . length ; x ++ ) { coefficients [ x ] = coefficients [ x ] / accumulator ; } return coefficients ; }	normalizes all filter coefficients to achieve unity ( 1 ) gain , by ensuring that the sum of the absolute value of all coefficients adds up to 1 .
protected void print track ( track track ) { default entity view info v info = ( default entity view info ) track . get view info ( ) ; tmp node buffer . clear ( ) ; tmp node buffer . add all ( track . get nodes ( ) ) ; if ( ! tmp node buffer . is empty ( ) ) { print line ( image bdr , tmp node buffer , v info , bool , bool , null ) ; print point ( image bdr , tmp node buffer . get ( tmp node buffer . size ( ) - num ) , v info , null ) ; } }	prints a track entity .
private period formatter builder append suffix ( period field affix suffix ) { final object original printer ; final object original parser ; if ( i element pairs . size ( ) > num ) { original printer = i element pairs . get ( i element pairs . size ( ) - num ) ; original parser = i element pairs . get ( i element pairs . size ( ) - num ) ; } else { original printer = null ; original parser = null ; } if ( original printer == null || original parser == null || original printer != original parser || ! ( original printer instanceof field formatter ) ) { throw new illegal state exception ( str ) ; } clear prefix ( ) ; field formatter new field = new field formatter ( ( field formatter ) original printer , suffix ) ; i element pairs . set ( i element pairs . size ( ) - num , new field ) ; i element pairs . set ( i element pairs . size ( ) - num , new field ) ; i field formatters [ new field . get field type ( ) ] = new field ; return this ; }	append a field suffix which applies only to the last appended field.
public collection < cube > all ( ) { return collections . unmodifiable collection ( cubes ) ; }	retrieve a collection of all cubes within this storage . the collection is non - modifiable.
public static short read u ( byte buffer buffer ) { byte b = buffer . get ( ) ; return ( short ) ( b & num ) ; }	get one unsigned byte as short type.
public static double most toxic row ( gate g ) { return collections . min ( g . get toxicity ( ) ) ; }	a gate toxicity score = = worst toxicity score among all rows of the truth table.
public multi server ( ) { this ( network config . default tcp port , network config . default udp port ) ; }	constructs and configures a multi server with default ports no network operation is done at this point .
protected string url string ( ) throws parse exception { string buffer retval = new string buffer ( ) ; lexer . select lexer ( str ) ; while ( lexer . has more chars ( ) ) { char la = lexer . look ahead ( num ) ; if ( la == str || la == str || la == str || la == str || la == str ) break ; lexer . consume ( num ) ; retval . append ( la ) ; } return retval . to string ( ) ; }	scan forward until you hit a terminating character for a url.
public xml element ( byte [ ] encoded document ) { if ( encoded document == null ) throw new illegal argument exception ( str ) ; this . encoded = encoded document . clone ( ) ; }	create xml element with utf8 encoded xml document .
public void add ( int position , int height ) { int curr height = m map . get ( position , - num ) ; if ( curr height != height ) { if ( curr height == - num ) { if ( m map . size ( ) == m max size ) { m map . delete ( m order . remove ( num ) ) ; } } else { m order . remove ( ( integer ) position ) ; } m map . put ( position , height ) ; m order . add ( position ) ; } }	add item height at position if doesn ' t already exist .
public void testmod inverse pos2 ( ) { byte a bytes [ ] = { num , num , num , num , - num , - num , - num , - num , num , num , num , num , num , num , - num , num , - num } ; byte m bytes [ ] = { num , num , num , num , num } ; int a sign = num ; int m sign = num ; byte r bytes [ ] = { num , - num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer modulus = new big integer ( m sign , m bytes ) ; big integer result = a number . mod inverse ( modulus ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	modinverse : positive number ( another case : a < 0 ).
@ get @ path ( str ) @ produces ( { media type . application xml , media type . application json } ) @ check permission ( roles = { role . security admin } ) public os list coprhd os tenants ( ) { log . debug ( str ) ; list < os > tenants = get os tenants from coprhd db ( ) ; return map ( tenants ) ; }	gets a list of coprhd representation of openstack tenants ( ostenant ) .
public int read ( final byte [ ] data ) { init ( ) ; if ( data != null ) { raw data = byte buffer . wrap ( data ) ; raw data . rewind ( ) ; raw data . order ( byte order . little endian ) ; read header ( ) ; if ( ! err ( ) ) { read contents ( ) ; if ( frame count < num ) { status = status format error ; } } } else { status = status open error ; } return status ; }	reads gif image from byte array.
private void calculate unique value ( object [ ] min value , object [ ] unique value ) { for ( int i = num ; i < measure count ; i ++ ) { if ( type [ i ] == carbon common constants . big int measure ) { unique value [ i ] = ( long ) min value [ i ] - num ; } else if ( type [ i ] == carbon common constants . big decimal measure ) { big decimal val = ( big decimal ) min value [ i ] ; unique value [ i ] = ( val . subtract ( new big decimal ( num ) ) ) ; } else { unique value [ i ] = ( double ) min value [ i ] - num ; } } }	this method will calculate the unique value which will be used as storage key for null values of measures.
@ request mapping ( value = str ) public void sso binding error ( locale locale , @ path variable ( value = str ) string tenant , http servlet response response ) throws io { logger . info ( str + locale . to string ( ) + str + tenant ) ; sso default tenant binding error ( locale , response ) ; }	handle request sent with a wrong binding.
public long env end ( ) { return long . parse long ( fields [ num ] ) ; }	( since linux 3.
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return strings ; case num : return hello ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public x509 trust chain key selector ( x509 certificate ... trusted roots ) { log = logger factory . get logger ( x509 trust chain key selector . class ) ; check ctor args not null ( trusted roots ) ; trust anchors = new hash set < trust anchor > ( ) ; for ( x509 certificate cert : trusted roots ) { trust anchors . add ( new trust anchor ( cert , null ) ) ; } }	create an x509trustchainkeyselector instance which will accept a chain rooted at any of the provided certificates .
@ override public void remove attribute ns ( string namespace uri , string local name ) { if ( owner document . error checking && is read only ( ) ) { string msg = dom . format message ( dom . dom domain , str , null ) ; throw new dom ( dom . no modification allowed err , msg ) ; } if ( needs sync data ( ) ) { synchronize data ( ) ; } if ( attributes == null ) { return ; } attributes . safe remove named item ns ( namespace uri , local name ) ; }	introduced in dom level 2.
public boolean draw image ( image img , affine transform xform , image observer obs ) { if ( img == null ) { return bool ; } boolean result ; int src width = img . get width ( null ) ; int src height = img . get height ( null ) ; if ( src width < num || src height < num ) { result = bool ; } else { result = draw image to platform ( img , xform , null , num , num , src width , src height , bool ) ; } return result ; }	draws an image , applying a transform from image space into user space before drawing.
public void handle button1 request ( request invocation event event ) throws model control exception { server site model model = ( server site model ) get model ( ) ; am ps = ( am ) get child ( property attribute ) ; string server name = ( string ) get page session attribute ( pg attr server name ) ; string name = ( string ) get display field value ( tf name ) ; name = name . trim ( ) ; if ( name . length ( ) > num ) { try { model . clone server ( server name , name ) ; back trail ( ) ; server site view bean vb = ( server site view bean ) get view bean ( server site view bean . class ) ; pass pg session map ( vb ) ; vb . forward to ( get request context ( ) ) ; } catch ( am e ) { set inline alert message ( cc . type error , str , e . get message ( ) ) ; forward to ( ) ; } } else { set inline alert message ( cc . type error , str , str ) ; forward to ( ) ; } }	handles clone server request .
public static < tk , fv > feature value collection < fv > combine ( derivation < tk , fv > hyp ) { counter < fv > counter = new classic counter < fv > ( ) ; for ( ; hyp != null ; hyp = hyp . parent ) { if ( hyp . features != null ) { for ( feature value < fv > feature : hyp . features ) { counter . increment count ( feature . name , feature . value ) ; } } } set < fv > feature names = new tree set < fv > ( counter . key set ( ) ) ; feature value collection < fv > combined list = new feature value list < fv > ( feature names . size ( ) ) ; for ( fv feature : feature names ) { combined list . add ( new feature value < fv > ( feature , counter . get count ( feature ) ) ) ; } return combined list ; }	aggregate feature values stored in a chain of hypotheses .
public void send titles ( ) { if ( listeners == null ) { return ; } string builder labels = new string builder ( str ) ; labels . append ( str + bundle . get message ( str ) + str ) ; labels . append ( str + manager . get closed text ( ) + str ) ; labels . append ( str + manager . get thrown text ( ) + str ) ; string message = labels . to string ( ) ; for ( controller interface listener : listeners ) { listener . send packet to device ( message ) ; } }	send info on turnouts to devices , not specific to any one turnout . format : ptt ] \ [ value } | { turnoutkey ] \ [ value } | { closedkey ] \ [ value } | { thrownkey.
public static void close session ( ) throws hibernate exception { session session = ( session ) thread local . get ( ) ; thread local . set ( null ) ; if ( session != null ) { session . close ( ) ; } }	close the single hibernate session instance .
protected calendar ( ) { zone = time zone . get default ( ) ; fields = new int [ field count ] ; is set = new boolean [ field count ] ; are fields set = is time set = bool ; set time in millis ( system . current time millis ( ) ) ; }	constructs a calendar with the default time zone.
public static boolean is xm ( int c ) { return ( c < num && ( xm chars [ c ] & mask xm space ) != num ) ; }	returns true if the specified character is a space character as amdended in the xml 1.
public void unregister player listener ( cheerleader player listener listener ) { check state ( ) ; m cheerleader player listeners . remove ( listener ) ; }	unregister listener used to catch player events .
public output stream open output stream ( uri uri , boolean append ) throws io { assert background thread ( ) ; switch ( get uri type ( uri ) ) { case uri type file : { file local file = new file ( uri . get path ( ) ) ; file parent = local file . get parent file ( ) ; if ( parent != null ) { parent . mkdirs ( ) ; } return new file output stream ( local file , append ) ; } case uri type content : case uri type resource : { asset file descriptor asset fd = content resolver . open asset file descriptor ( uri , append ? str : str ) ; return asset fd . create output stream ( ) ; } } throw new file not found exception ( str + uri ) ; }	opens a stream to the given uri .
protected integer adjust integer value ( integer orig value , integer min value , integer max value ) { integer result value = orig value ; if ( result value . compare to ( min value ) < num ) { result value = min value ; } if ( result value . compare to ( max value ) > num ) { result value = max value ; } return result value ; }	adjusts an integer value according to the specified range of values .
private void init paints ( resources res ) { final string month typeface = res . get string ( r . string . date picker month typeface ) ; final string day of week typeface = res . get string ( r . string . date picker day of week typeface ) ; final string day typeface = res . get string ( r . string . date picker day typeface ) ; final int month text size = res . get dimension pixel size ( r . dimen . date picker month text size ) ; final int day of week text size = res . get dimension pixel size ( r . dimen . date picker day of week text size ) ; final int day text size = res . get dimension pixel size ( r . dimen . date picker day text size ) ; m month paint . set anti alias ( bool ) ; m month paint . set text size ( month text size ) ; m month paint . set typeface ( typeface . create ( month typeface , num ) ) ; m month paint . set text align ( align . center ) ; m month paint . set style ( style . fill ) ; m day of week paint . set anti alias ( bool ) ; m day of week paint . set text size ( day of week text size ) ; m day of week paint . set typeface ( typeface . create ( day of week typeface , num ) ) ; m day of week paint . set text align ( align . center ) ; m day of week paint . set style ( style . fill ) ; m day selector paint . set anti alias ( bool ) ; m day selector paint . set style ( style . fill ) ; m day highlight paint . set anti alias ( bool ) ; m day highlight paint . set style ( style . fill ) ; m day paint . set anti alias ( bool ) ; m day paint . set text size ( day text size ) ; m day paint . set typeface ( typeface . create ( day typeface , num ) ) ; m day paint . set text align ( align . center ) ; m day paint . set style ( style . fill ) ; }	sets up the text and style properties for painting .
public int size ( ) { return rules . size ( ) ; }	returns the number of rules contained in this grammar .
private void copy arrays ( ) { string [ ] old syms = symbols ; int size = old syms . length ; symbols = new string [ size ] ; system . arraycopy ( old syms , num , symbols , num , size ) ; bucket [ ] old buckets = buckets ; size = old buckets . length ; buckets = new bucket [ size ] ; system . arraycopy ( old buckets , num , buckets , num , size ) ; }	method called when copy - on - write is needed ; generally when first change is made to a derived symbol table .
@ procedure @ performs writes @ description ( str ) public stream < relationship refactor result > from ( @ name ( str ) relationship rel , @ name ( str ) node new node ) { relationship refactor result result = new relationship refactor result ( rel . get id ( ) ) ; try { relationship new rel = new node . create relationship to ( rel . get end node ( ) , rel . get type ( ) ) ; copy properties ( rel , new rel ) ; rel . delete ( ) ; return stream . of ( result . with other ( new rel ) ) ; } catch ( exception e ) { return stream . of ( result . with error ( e ) ) ; } }	redirects a relationships to a new target node .
public static long max fill ( final long n , final float f ) { return math . min ( ( long ) math . ceil ( n * f ) , n - num ) ; }	returns the maximum number of entries that can be filled before rehashing .
public static void print ( char x ) { out . print ( x ) ; out . flush ( ) ; }	prints a character to standard output and flushes standard output .
public void clear source elements ( ) { for ( p node : source elements ) { source handle . remove source handle from ( node ) ; } source elements . clear ( ) ; selection model . fire selection changed ( ) ; }	clear all source elements .
public static double [ ] [ ] read matrix ( int number of rows , int number of columns , boolean ignore first line , string file name ) { double [ ] [ ] matrix = new double [ number of rows ] [ number of columns ] ; try { file reader fr = new file reader ( file name ) ; buffered reader br = new buffered reader ( fr ) ; string line ; string tokenizer tokenizer ; string token ; if ( ignore first line ) { br . read line ( ) ; } line = br . read line ( ) ; int row id = num ; while ( line != null ) { tokenizer = new string tokenizer ( line ) ; for ( int i = num ; i < number of columns ; i ++ ) { token = tokenizer . next token ( ) ; double parsed number = double . parse double ( token ) ; matrix [ row id ] [ i ] = parsed number ; } if ( tokenizer . has more tokens ( ) ) { throw new runtime exception ( str ) ; } line = br . read line ( ) ; row id ++ ; } if ( row id != number of rows ) { throw new runtime exception ( str ) ; } } catch ( runtime exception e ) { throw e ; } catch ( exception e ) { e . print stack trace ( ) ; throw new runtime exception ( str ) ; } return matrix ; }	reads in data from a file .
@ override protected boolean read into buffer ( int min length ) { if ( buffer space left ( ) < min length ) { increase buffer size ( min length + currently in buffer ( ) ) ; } else if ( buf . length - write pos < min length ) { compact ( ) ; } int read sum = num ; while ( read sum < min length && ! datagrams . is empty ( ) ) { datagram next = datagrams . remove first ( ) ; int length = ( int ) next . get duration ( ) ; if ( buf . length < write pos + length ) { increase buffer size ( write pos + length ) ; } int read = read datagram ( next , buf , write pos ) ; write pos += read ; read sum += read ; } if ( data processor != null ) { data processor . apply inline ( buf , write pos - read sum , read sum ) ; } return read sum >= min length ; }	attempt to get more data from the input source.
private int height of phi ( int phi ) { if ( phi == num ) { return - num ; } int tau = num ; int modul = num ; while ( phi % modul == num ) { modul *= num ; tau += num ; } return tau - num ; }	returns the largest h such that 2 ^ h | phi.
@ not null public clarifai client build sync ( ) { return new clarifai client impl ( this ) ; }	builds the api client , blocking until an access token has been retrieved.
public void mouse released ( mouse event e ) { visualization viewer < ? , ? > vv = ( visualization viewer < ? , ? > ) e . get source ( ) ; down = null ; vv . set cursor ( cursor . get predefined cursor ( cursor . default cursor ) ) ; }	unset the ' down ' point and change the cursoe back to the system default cursor.
@ nullable public static class < ? > class for name ( @ nullable string cls , @ nullable class < ? > dflt , boolean include primitive types ) { class < ? > clazz ; if ( cls == null ) clazz = dflt ; else if ( ! include primitive types || cls . length ( ) > num || ( clazz = primitive map . get ( cls ) ) == null ) { try { clazz = class . for name ( cls ) ; } catch ( class not found exception ignore ) { clazz = dflt ; } } return clazz ; }	gets class for the given name if it can be loaded or default given class .
public string check write protected ( int res id action , final file ... files to be modified ) { if ( files to be modified != null ) { for ( file file : files to be modified ) { if ( ( file != null ) && ( file . exists ( ) ) && ( ! file . can write ( ) ) ) { string action = ( res id action == num ) ? str : m context . get string ( res id action ) ; return m context . get string ( r . string . file err writeprotected , file . get absolute path ( ) , action ) ; } } } return null ; }	check if all files in selectedfilenamestobemodified are not write protected .
@ not null @ contract ( pure = bool ) public static string strip ( @ not null final string s , @ not null final char filter filter ) { final string builder result = new string builder ( s . length ( ) ) ; for ( int i = num ; i < s . length ( ) ; i ++ ) { char ch = s . char at ( i ) ; if ( filter . accept ( ch ) ) { result . append ( ch ) ; } } return result . to string ( ) ; }	strip out all characters not accepted by given filter.
protected void add component ( xml component ) { if ( f components . contains ( component ) ) { return ; } f components . add ( component ) ; add recognized params and set defaults ( component ) ; }	adds a component to the parser configuration.
public void test local instances distribution ( ) { matsim random . reset ( num ) ; random local1a = matsim random . get local instance ( ) ; double value1 = local1a . next double ( ) ; matsim random . reset ( num ) ; random local2a = matsim random . get local instance ( ) ; double value2a = local2a . next double ( ) ; random local2b = matsim random . get local instance ( ) ; double value2b = local2b . next double ( ) ; assert true ( math . abs ( value1 - value2a ) > epsilon ) ; assert true ( math . abs ( value2a - value2b ) > epsilon ) ; assert true ( math . abs ( value1 - value2b ) > epsilon ) ; }	tests that multiple local instance return different random numbers , and that they are more or less evenly distributed .
public final void test roundtrip ( ) { boolean performed = bool ; for ( int i = num ; i < alg name . length ; i ++ ) { try { test data generator g = new test data generator ( alg name [ i ] [ num ] , alg name [ i ] [ num ] , private key info damaged , null ) ; encrypted private key info epki ; if ( g . ap ( ) == null ) { epki = new encrypted private key info ( alg name [ i ] [ num ] , g . ct ( ) ) ; } else { epki = new encrypted private key info ( g . ap ( ) , g . ct ( ) ) ; } try { epki . get key spec ( g . pub k ( ) == null ? g . k ( ) : g . pub k ( ) ) ; fail ( alg name [ i ] [ num ] + str + alg name [ i ] [ num ] ) ; } catch ( invalid key exception e ) { } performed = bool ; } catch ( test data generator . allowed failure allowed failure ) { } catch ( no such algorithm exception allowed failure ) { } } assert true ( str , performed ) ; }	encrypted data contains invalid pkcs8 key info encoding.
public void clear ( i bean ) { for ( binding b : opt components . values ( ) ) { b . clear ( bean ) ; } for ( binding b : bindings . values ( ) ) { b . clear ( bean ) ; } modified = bool ; }	clear all components , set them to their default values.
public boolean has credentials ( ) { return has credentials ; }	checks if the credentials are generated .
public boolean is recursive attr set ( elem attribute set attr set ) { if ( null == m attr set stack ) { m attr set stack = new stack ( ) ; } if ( ! m attr set stack . empty ( ) ) { int loc = m attr set stack . search ( attr set ) ; if ( loc > - num ) { return bool ; } } return bool ; }	check to see if this is a recursive attribute definition .
public void clear ( absolute table identifier absolute table identifier ) { table lock map . remove ( absolute table identifier ) ; table segment map . remove ( absolute table identifier ) ; }	remove all the details of a table this will be used in case of drop table.
public static input stream to input stream ( char sequence input ) { return to input stream ( input . to string ( ) ) ; }	convert the specified charsequence to an input stream , encoded as bytes using the default character encoding of the platform .
@ override public void process ( number tuple ) { values . add ( tuple . double value ( ) ) ; }	computes sum and count with each tuple.
public void grant write permission ( collection attribute names ) { iterator it = attribute names . iterator ( ) ; if ( it != null ) { while ( it . has next ( ) ) { string temp = ( string ) it . next ( ) ; writables . add ( temp . to lower case ( ) ) ; } } }	grant write permission to attributes .
public void save data ( file file ) throws io { synchronized ( accumulators ) { object output stream oos = null ; try { oos = new object output stream ( new file output stream ( file ) ) ; oos . write object ( accumulators ) ; } finally { if ( oos != null ) { oos . close ( ) ; } } } }	saves all results stored in this controller to the specified file .
public static ingredient from cursor ( cursor cursor ) { ingredient ingredient = new ingredient ( ) ; for ( int c = num ; c < cursor . get column count ( ) ; c ++ ) { string column name = cursor . get column name ( c ) ; if ( column name . equals ( recipe ingredient table . amount column ) ) { ingredient . set amount ( cursor . get string ( c ) ) ; } else if ( column name . equals ( recipe ingredient table . description column ) ) { ingredient . set description ( cursor . get string ( c ) ) ; } } return ingredient ; }	static helper method for populating attributes from a database cursor .
public void append ( char c [ ] , int off , int len ) { int rest length = buffer . length - pos ; if ( len < rest length ) { system . arraycopy ( c , off , buffer , pos , len ) ; pos += len ; } else { system . arraycopy ( c , off , buffer , pos , rest length ) ; curr . next = new entity ( buffer ) ; curr = curr . next ; length += buffer . length ; buffer = new char [ ( buffer . length > len - rest length ) ? buffer . length : len - rest length ] ; system . arraycopy ( c , off + rest length , buffer , num , len - rest length ) ; pos = len - rest length ; } }	method to append a part of a char array.
public boolean contains ( string voice name ) { return ( get voice ( voice name ) != null ) ; }	check if there is a voice provides with the given name .
public static boolean is enterprise edition ( string server version ) { return server version . contains ( str ) || server version . contains ( str ) || server version . contains ( str ) ; }	checks whether the given server version string is a mysql enterprise edition.
@ override public category item renderer state initialise ( d g2 , d data area , category plot plot , int renderer index , plot rendering info info ) { category item renderer state state = super . initialise ( g2 , data area , plot , renderer index , info ) ; category axis domain axis = get domain axis ( plot , renderer index ) ; category dataset dataset = plot . get dataset ( renderer index ) ; if ( dataset != null ) { int columns = dataset . get column count ( ) ; int rows = dataset . get row count ( ) ; double space = num ; plot orientation orientation = plot . get orientation ( ) ; if ( orientation == plot orientation . horizontal ) { space = data area . get height ( ) ; } else if ( orientation == plot orientation . vertical ) { space = data area . get width ( ) ; } double max width = space * get maximum bar width ( ) ; double category margin = num ; double current item margin = num ; if ( columns > num ) { category margin = domain axis . get category margin ( ) ; } if ( rows > num ) { current item margin = get item margin ( ) ; } double used = space * ( num - domain axis . get lower margin ( ) - domain axis . get upper margin ( ) - category margin - current item margin ) ; if ( ( rows * columns ) > num ) { state . set bar width ( math . min ( used / ( dataset . get column count ( ) * dataset . get row count ( ) ) , max width ) ) ; } else { state . set bar width ( math . min ( used , max width ) ) ; } } return state ; }	initialises the renderer . this method gets called once at the start of the process of drawing a chart .
lua string load string ( ) throws io { int size = this . luac sizeof size t == num ? ( int ) load int64 ( ) : load int ( ) ; if ( size == num ) return null ; byte [ ] bytes = new byte [ size ] ; is . read fully ( bytes , num , size ) ; return lua string . value of ( bytes , num , bytes . length - num ) ; }	load a lua strin gvalue from the input stream.
protected abstract preferences ( abstract preferences parent , string name ) { if ( parent == null ) { if ( ! name . equals ( str ) ) throw new illegal argument exception ( str + name + str ) ; this . absolute path = str ; root = this ; } else { if ( name . index of ( str ) != - num ) throw new illegal argument exception ( str + name + str ) ; if ( name . equals ( str ) ) throw new illegal argument exception ( str ) ; root = parent . root ; absolute path = ( parent == root ? str + name : parent . absolute path ( ) + str + name ) ; } this . name = name ; this . parent = parent ; }	creates a preference node with the specified parent and the specified name relative to its parent .
static class < ? > canonicalize ( class < ? > t , int how ) { class < ? > ct ; if ( t == object . class ) { } else if ( ! t . is primitive ( ) ) { switch ( how ) { case unwrap : ct = wrapper . as primitive type ( t ) ; if ( ct != t ) return ct ; break ; case raw return : case erase : return object . class ; } } else if ( t == void . class ) { switch ( how ) { case raw return : return int . class ; case wrap : return void . class ; } } else { switch ( how ) { case wrap : return wrapper . as wrapper type ( t ) ; case ints : if ( t == int . class || t == long . class ) return null ; if ( t == double . class ) return long . class ; return int . class ; case longs : if ( t == long . class ) return null ; return long . class ; case raw return : if ( t == int . class || t == long . class || t == float . class || t == double . class ) return null ; return int . class ; } } return null ; }	canonicalize the given return or param type.
protected string extract substring ( string psz src ) { int n bracket = num ; int i ; string psz return ; for ( i = num ; i < psz src . length ( ) && ( n bracket > num || psz src . char at ( i ) != str ) ; i ++ ) { if ( psz src . char at ( i ) == str ) { n bracket ++ ; } else if ( psz src . char at ( i ) == str ) { n bracket -- ; } } if ( psz src . char at ( num ) == str ) { psz return = psz src . substring ( num , i - num ) ; } else { psz return = psz src . substring ( num , i ) ; } return psz return ; }	extract a substring terminated by a comma ( or end of string ).
public void read ( appendable dest ) throws io { if ( input stream == null ) throw new io ( str ) ; while ( bool ) { if ( start >= end ) { start = num ; end = input stream . read ( bytes , num , bytes . length ) ; if ( end <= num ) { break ; } } byte b = bytes [ start ] ; if ( b >= num ) { dest . append ( ( char ) b ) ; start ++ ; } else { int code = read2 ( ) ; if ( code < num ) { dest . append ( ( char ) code ) ; } else if ( code <= num ) { dest . append ( ( char ) ( ( ( code - num ) > > num ) + num ) ) ; dest . append ( ( char ) ( ( ( code - num ) & num ) + num ) ) ; } else { throw new char conversion exception ( str + integer . to hex string ( code ) + str ) ; } } } }	reads characters into the specified appendable.
public boolean is monitoring ( ) { return m . is monitoring ( ) ; }	returns whether the thread is still running .
static final color hex to color ( string value ) { string digits ; int n = value . length ( ) ; if ( value . starts with ( str ) ) { digits = value . substring ( num , math . min ( value . length ( ) , num ) ) ; } else { digits = value ; } string hstr = str + digits ; color c ; try { c = color . decode ( hstr ) ; } catch ( number format exception nfe ) { c = null ; } return c ; }	convert a " # ffffff " hex string to a color.
public final boolean content equals ( java . lang . char sequence csq ) { if ( csq . length ( ) != length ) return bool ; for ( int i = num ; i < length ; ) { char c = high [ i > > b1 ] [ i & m1 ] ; if ( csq . char at ( i ++ ) != c ) return bool ; } return bool ; }	indicates if this text builder has the same character content as the specified character sequence .
private void populate available data stores ( ) { data access factory fac ; logger . debug ( str ) ; iterator < data store factory spi > iterator = data store finder . get available data stores ( ) ; while ( iterator . has next ( ) ) { fac = ( data access factory ) iterator . next ( ) ; logger . debug ( str + fac . get display name ( ) ) ; available data store list . add ( fac . get display name ( ) ) ; } }	populates the list of available data stores that can be connected to .
protected void add ( double value , int group ) { if ( ( group < num ) || ( group >= number of groups ) ) { throw new illegal argument exception ( str ) ; } data . add ( new observation ( value , group ) ) ; }	adds a new observation with the specified value and group .
protected static string make option string ( script script ) { string buffer result ; enumeration < option > enm ; option option ; result = new string buffer ( str ) ; result . append ( str ) ; result . append ( str ) ; result . append ( str ) ; result . append ( str ) ; result . append ( str ) ; enm = script . list options ( ) ; while ( enm . has more elements ( ) ) { option = enm . next element ( ) ; result . append ( option . synopsis ( ) + str ) ; result . append ( option . description ( ) + str ) ; } result . append ( str ) ; result . append ( str ) ; result . append ( str ) ; result . append ( str ) ; return result . to string ( ) ; }	make up the help string giving all the command line options .
public registration builder add contact ( uri contact ) { contacts . add ( contact ) ; return this ; }	add a contact uri to the list of contacts .
public static void close quietly ( auto closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( runtime exception rethrown ) { throw rethrown ; } catch ( exception ignored ) { } } }	closes ' closeable ' , ignoring any checked exceptions.
string format time ( int hour , int minute ) { string s = str ; string t = integer . to string ( hour ) ; if ( t . length ( ) == num ) { s = t + str ; } else if ( t . length ( ) == num ) { s = str + t + str ; } t = integer . to string ( minute ) ; if ( t . length ( ) == num ) { s = s + t ; } else if ( t . length ( ) == num ) { s = s + str + t ; } if ( s . length ( ) != num ) { s = str ; } return s ; }	formats time to hh : mm given integer hour and minute.
public boolean is empty ( ) { return ( sentence type == sentence type . undefined ) && expressions . is empty ( ) ; }	return true if the sentence is empty .
@ override public void init ( abstract addressbook manager a boo mgr ) { set address book manager ( a boo mgr ) ; reload settings ( ) ; try { connection = driver manager . get connection ( identitydb connect string ) ; } catch ( sql e ) { logger . error ( str + identitydb connect string , e ) ; } statement statement ; try { statement = connection . create statement ( ) ; statement . set query timeout ( num ) ; statement . execute update ( str + table identity + str ) ; statement . execute update ( str + table cloudprovider + str ) ; statement . execute update ( str + table cloudprovider map + str ) ; a boo mgr . init ( ) ; } catch ( sql e ) { logger . error ( str , e ) ; } finally { if ( connection != null ) { try { connection . close ( ) ; } catch ( sql e ) { logger . error ( str , e ) ; } } } }	creates the initial set of db tables for the sqlite db to store our identity and addressbook entries.
private buffer check error packet ( int command ) throws sql { buffer result packet = null ; this . server status = num ; try { result packet = reuse and read packet ( this . reusable packet ) ; } catch ( sql sql ex ) { throw sql ex ; } catch ( exception fall thru ) { throw sql . create communications exception ( this . connection , this . last packet sent time ms , this . last packet received time ms , fall thru , get exception interceptor ( ) ) ; } check error packet ( result packet ) ; return result packet ; }	checks for errors in the reply packet , and if none , returns the reply packet , ready for reading.
public void apply settings ( boolean load core components ) throws apply settings exception { list < string > errors = new array list < string > ( num ) ; apply torrent data save folder settings ( errors ) ; apply torrent seeding settings ( errors ) ; if ( ! errors . is empty ( ) ) { throw new apply settings exception ( string utils . explode ( errors , str ) ) ; } }	overrides applysettings method in setupwindow.
public boolean should select cell ( event object e ) { return bool ; }	the editing cell should be selected or not.
method info find method ( string s ) { method info m ; int i ; for ( i = num ; i < methods count ; i ++ ) { m = methods [ i ] ; if ( s . equals ( m . to name ( constant pool ) ) ) { return m ; } } return null ; }	locates a method by name .
private void wait until readable ( ) throws io { read timeout . enter ( ) ; try { while ( read buffer . size ( ) == num && ! finished && ! closed && error code == null ) { wait for io ( ) ; } } finally { read timeout . exit and throw if timed out ( ) ; } }	returns once the source is either readable or finished .
public static < x extends exception > string to string ( iteration < ? , x > iter , string separator ) throws x { string builder sb = new string builder ( ) ; to string ( iter , separator , sb ) ; return sb . to string ( ) ; }	converts an iteration to a string by concatenating all of the string representations of objects in the iteration , divided by a separator .
@ suppress warnings ( str ) @ override public boolean contains ( final object obj ) { if ( null != obj ) { iterator < e > it = new array deque iterator < e > ( ) ; while ( it . has next ( ) ) { if ( obj . equals ( ( e ) it . next ( ) ) ) { return bool ; } } } return bool ; }	returns true if the specified element is in the deque .
public static synchronized grid test print stream acquire err ( ) { if ( test err == null ) test err = new grid test print stream ( sys err ) ; if ( err cnt == num ) system . set err ( test err ) ; err cnt ++ ; return test err ; }	acquires output stream for logging errors in tests .
private void write object ( object output stream out ) throws io { out . default write object ( ) ; do write object ( out ) ; }	write the map out using a custom routine .
private static boolean is property name ( string name ) { return ( ( name . length ( ) > num ) && character . is upper case ( name . char at ( num ) ) ) || ( ( name . length ( ) > num ) && character . is upper case ( name . char at ( num ) ) ) ; }	determine if this method name suffix is a legitimate bean property name.
public void remove rtcp listener ( rtcp event listener listener ) { if ( s logger . is activated ( ) ) { s logger . debug ( str ) ; } m listeners . remove element ( listener ) ; }	remove a rtcp event listener.
private static void collect all times ( tree tree , node ref node , node ref [ ] exclude below , array list times , array list < integer > childs ) { times . add ( new comparable double ( tree . get node height ( node ) ) ) ; childs . add ( tree . get child count ( node ) ) ; for ( int i = num ; i < tree . get child count ( node ) ; i ++ ) { node ref child = tree . get child ( node , i ) ; if ( exclude below == null ) { collect all times ( tree , child , exclude below , times , childs ) ; } else { boolean include = bool ; for ( node ref an exclude below : exclude below ) { if ( an exclude below . get number ( ) == child . get number ( ) ) { include = bool ; break ; } } if ( include ) collect all times ( tree , child , exclude below , times , childs ) ; } } }	extract coalescent times and tip information into arraylist times from tree .
protected void paint text ( final graphics g , final j c , final rectangle local text rect , final string text ) { final d g2d = g instanceof d ? ( d ) g : null ; final abstract button b = ( abstract button ) c ; final button model model = b . get model ( ) ; final font metrics fm = g . get font metrics ( ) ; final int mnemonic index = aqua mnemonic handler . is mnemonic hidden ( ) ? - num : b . get displayed mnemonic index ( ) ; if ( model . is enabled ( ) ) { g . set color ( b . get foreground ( ) ) ; } else { g . set color ( default disabled text color ) ; } swing utilities2 . draw string underline char at ( c , g , text , mnemonic index , local text rect . x , local text rect . y + fm . get ascent ( ) ) ; }	as of java 2 platform v 1.
public static constraint widget [ ] infer table list ( widgets scene list ) { for ( constraint widget widget : list . get widgets ( ) ) { widget . reset anchors ( ) ; } return infer table list ( list . get root ( ) ) ; }	given a collection of widgets evaluates probability of a connection and makes connections.
public void if present ( long consumer consumer ) { if ( is present ) consumer . accept ( value ) ; }	have the specified consumer accept the value if a value is present , otherwise do nothing .
public void update ( string [ ] columns , object [ ] column values , string [ ] conditions , object [ ] condition values ) throws data access exception { if ( columns . length != column values . length || conditions . length != condition values . length ) { logger . error ( str ) ; return ; } object [ ] values = arrays . copy of ( column values , column values . length + condition values . length ) ; system . arraycopy ( condition values , num , values , column values . length , condition values . length ) ; final string sql = prepared statement util . prepare update template with column ( table name , columns , conditions ) ; execute ( sql , values ) ; }	use jdbc template preparedstatement to update row in database by setting columns with conditions.
public static string replica set used in ( string addresses ) { if ( addresses . starts with ( str ) ) { return null ; } int index = addresses . index of ( str ) ; if ( index < num ) return null ; return addresses . substring ( num , index ) ; }	find the name of the replica set precedes the host addresses .
public void on progress ( long bytes written , long total size ) { log . v ( log tag , string . format ( str , bytes written , total size , ( total size > num ) ? ( bytes written * num / total size ) * num : - num ) ) ; }	fired when the request progress , override to handle in your own code.
public string self ( type declaration decl ) { if ( decl instanceof constructor ) { decl = ( type declaration ) decl . get container ( ) ; } string name = js utils . escape string literal ( decl . get name ( ) ) ; if ( decl . is shared ( ) || decl . is toplevel ( ) ) { name += nesting suffix ( decl , bool ) ; } else { name = str + long . to string ( get uid ( decl ) , num ) ; } return string . format ( str , character . to lower case ( name . char at ( num ) ) , name . substring ( num ) ) ; }	determine the identifier to be used for the self variable of the given type .
public double elapsed time ( ) { long now = thread timer . get current thread cpu time ( ) ; return ( now - start ) / nanoseconds per second ; }	returns the elapsed cpu time ( in seconds ) since the stopwatch was created .
public static void sort list ( list list ) { if ( system utils . is java 1 7 && list instanceof copy on write array list ) { list temp list = new array list ( list ) ; collections . sort ( temp list ) ; list . clear ( ) ; list . add all ( temp list ) ; } else { collections . sort ( list ) ; } }	sorts the list . since copyonwritearraylists are not sortable with java7 , we need this wrapper to sort it differently on java7 .
public static < t > t [ ] concat ( t [ ] first , t [ ] second , class < t > type ) { t [ ] result = new array ( type , first . length + second . length ) ; system . arraycopy ( first , num , result , num , first . length ) ; system . arraycopy ( second , num , result , first . length , second . length ) ; return result ; }	returns a new array that contains the concatenated contents of two arrays .
public synchronized void write to remote ( byte b ) { remote buffer . add ( b ) ; }	used by sut to simulate sending of data to remote host.
@ override public void draw series ( canvas canvas , paint paint , list < float > points , list < double > values , xy series renderer , support series render support series render , float y axis value , int series index , int start index ) { int series nr = m dataset . get series count ( ) ; int length = points . size ( ) ; paint . set color ( series renderer . get color ( ) ) ; paint . set style ( style . fill ) ; float half diff x = get half diff x ( points , length , series nr ) ; int start = num ; if ( start index > num ) { start = num ; } for ( int i = start ; i < length ; i += num ) { if ( points . size ( ) > i + num ) { float x min = points . get ( i ) ; float y min = points . get ( i + num ) ; float x max = points . get ( i + num ) ; float y max = points . get ( i + num ) ; draw bar ( canvas , x min , y min , x max , y max , half diff x , series nr , series index , paint ) ; } } paint . set color ( series renderer . get color ( ) ) ; }	the graphical representation of a series .
private void begin gesture ( int scroll offset y , int scroll extent y ) { m initial translation y = get translation y ( ) ; boolean is initially visible = m initial translation y < m total height ; int starting y = is initially visible ? scroll offset y : math . min ( scroll offset y , m total height ) ; m initial offset y = starting y + scroll extent y ; }	records the conditions of the page when a gesture is initiated .
@ override public void add ( string ... identifiers ) { whitelist . add all ( arrays . as list ( identifiers ) ) ; }	adds identifiers to the exclusion strategy .
public static void clear ( ) { shop id . set ( num ) ; shop code . set ( str ) ; }	clear thread locals at the end of the request.
@ override public boolean communication initiated ( ) { return bugs populated . get count ( ) == num && communication initiated && network client . ready ( ) ; }	returns true if communication has already been initiated ( and perhaps completed ) .
@ override public void dump ( string prefix , file descriptor fd , print writer writer , string [ ] args ) { super . dump ( prefix , fd , writer , args ) ; writer . print ( prefix ) ; writer . print ( str ) ; writer . println ( raw query ) ; writer . print ( prefix ) ; writer . print ( str ) ; writer . println ( arrays . to string ( args ) ) ; }	writes a semi - user - readable roster of contents to supplied output .
public void add contig field ( contig field field ) { add id field ( m contig lines , field ) ; }	add an alt field.
boolean remove index entry ( string resource name , string policy name ) { iterator iter = top level entries . iterator ( ) ; boolean processed = bool ; while ( ! processed && ( iter . has next ( ) ) ) { resource index entry resource index entry = ( resource index entry ) iter . next ( ) ; if ( resource index entry . remove index entry ( resource type , resource name , policy name ) ) { processed = bool ; } } return processed ; }	removes an index entry.
public static double pdf ( double x , double mu , double shape ) { if ( ! ( x > num ) || x == double . positive infinity ) { return num ; } final double v = ( x - mu ) / mu ; double t1 = math . sqrt ( shape / ( math util . twopi * x * x * x ) ) ; return t1 > num ? t1 * math . exp ( - shape * v * v * num / x ) : num ; }	probability density function of the wald distribution .
@ override public void on stop tracking touch ( seek bar seek bar ) { final int pos = m item list . index of ( m selected tracker ) ; final int delta = num / m item list . size ( ) ; cp mover . set progress ( pos * delta + delta / num ) ; }	set the seek bar position relative to the selected button .
public static int max profit ( int [ ] prices ) { if ( prices == null || prices . length < num ) { return num ; } int max = num ; int min = prices [ num ] ; for ( int i = num ; i < prices . length ; i ++ ) { min = math . min ( min , prices [ i ] ) ; if ( prices [ i ] > prices [ i - num ] ) { max = math . max ( max , prices [ i ] - min ) ; } } return max ; }	optimized bottom - up approach o ( n ) time , o ( 1 ) space just record yesterday ' s profit update min , max and profit if next price is bigger , it ' s only possible to update the profit if next price is smaller or equal , it ' s only possible to update min.
public void add ( string string ) { elements . add ( string == null ? json null . instance : new json primitive ( string ) ) ; }	adds the specified string to self .
public void component added ( container event e ) { layer child layer = ( layer ) e . get child ( ) ; add projection listener ( child layer ) ; if ( ! removed layers . remove element ( child layer ) ) { added layers . add element ( child layer ) ; } change layers ( e ) ; }	containerlistener interface method . should not be called directly . part of the containerlistener interface , and it ' s here to make the mapbean a good container citizen .
public void processing instruction ( string target , string data ) throws sax { characters flush ( ) ; int data index = m data . size ( ) ; m previous = add node ( dtm . processing instruction node , dtm . processing instruction node , m parents . peek ( ) , m previous , - data index , bool ) ; m data . add element ( m values or prefixes . string to index ( target ) ) ; m values . add element ( data ) ; m data . add element ( m value index ++ ) ; }	override the processinginstruction ( ) interface in sax2dtm2.
protected void panic ( string msg ) throws sax { sax spe = new sax ( msg , this ) ; m hand err . fatal error ( spe ) ; throw spe ; }	notifies the handler about fatal parsing error .
private void update namespace permissions ( user namespace authorization entity user namespace authorization entity , list < namespace permission enum > namespace permissions ) { user namespace authorization entity . set read permission ( namespace permissions . contains ( namespace permission enum . read ) ) ; user namespace authorization entity . set write permission ( namespace permissions . contains ( namespace permission enum . write ) ) ; user namespace authorization entity . set execute permission ( namespace permissions . contains ( namespace permission enum . execute ) ) ; user namespace authorization entity . set grant permission ( namespace permissions . contains ( namespace permission enum . grant ) ) ; }	sets relative flags on the user namespace authorization entity as per specified list of namespace permissions .
public static void report ( ) { if ( ! booted ) return ; controller thread . report ( ) ; runtime measurements . report ( ) ; for ( enumeration < organizer > e = organizers . elements ( ) ; e . has more elements ( ) ; ) { organizer organizer = e . next element ( ) ; organizer . report ( ) ; } if ( options . final report level >= num ) { edge counts . dump counts ( ) ; dcg . dump graph ( ) ; } if ( options . report interrupt stats ) { vm . sys writeln ( str ) ; vm . sys writeln ( str , rvm . timer ticks ) ; vm . sys writeln ( str , controller clock ) ; vm . sys writeln ( str , ( int ) method samples . get total number of samples ( ) ) ; } }	this method is called when the vm is exiting to provide a hook to allow the adaptive optimization subsystem to generate a summary report.
public static set < ? > convert array to set ( object [ ] source ) { set < object > set = new hash set < object > ( ) ; for ( object element : source ) { set . add ( element ) ; } return set ; }	convert array to set , removing duplicates.
public static int intersect line rectangle ( d l , d r , d [ ] pts ) { double a1x = l . get x1 ( ) , a1y = l . get y1 ( ) ; double a2x = l . get x2 ( ) , a2y = l . get y2 ( ) ; double mxx = r . get max x ( ) , mxy = r . get max y ( ) ; double mnx = r . get min x ( ) , mny = r . get min y ( ) ; if ( pts [ num ] == null ) pts [ num ] = new d . double ( ) ; if ( pts [ num ] == null ) pts [ num ] = new d . double ( ) ; int i = num ; if ( intersect line line ( mnx , mny , mxx , mny , a1x , a1y , a2x , a2y , pts [ i ] ) > num ) i ++ ; if ( intersect line line ( mxx , mny , mxx , mxy , a1x , a1y , a2x , a2y , pts [ i ] ) > num ) i ++ ; if ( i == num ) return i ; if ( intersect line line ( mxx , mxy , mnx , mxy , a1x , a1y , a2x , a2y , pts [ i ] ) > num ) i ++ ; if ( i == num ) return i ; if ( intersect line line ( mnx , mxy , mnx , mny , a1x , a1y , a2x , a2y , pts [ i ] ) > num ) i ++ ; return i ; }	compute the intersection of a line and a rectangle .
public static string cidr mask to net mask ( string cidr mask ) { if ( cidr mask == null ) { return null ; } int cidr mask value = num ; try { cidr mask value = integer . parse int ( cidr mask ) ; } catch ( number format exception e ) { return null ; } int cidr mask full = num << ( num - cidr mask value ) ; int cidr mask bits1 = cidr mask full > > num & num ; int cidr mask bits2 = cidr mask full > > num & num ; int cidr mask bits3 = cidr mask full > > num & num ; int cidr mask bits4 = cidr mask full > > num & num ; string buffer net mask buf = new string buffer ( ) ; net mask buf . append ( cidr mask bits1 ) ; net mask buf . append ( str ) ; net mask buf . append ( cidr mask bits2 ) ; net mask buf . append ( str ) ; net mask buf . append ( cidr mask bits3 ) ; net mask buf . append ( str ) ; net mask buf . append ( cidr mask bits4 ) ; return net mask buf . to string ( ) ; }	transforms a cidr formatted mask into a regular network mask.
public boolean in bounds ( mouse event e ) { return e . get x ( ) > x && e . get x ( ) < x + width && e . get y ( ) > y && e . get y ( ) < y + height ; }	checks if the mouse is within the bounds of this object .
public class path ( @ nonnull iterable < dex file > class path , boolean check package private access ) { iterable < dex file > dex files = iterables . concat ( class path , lists . new array list ( get basic classes ( ) ) ) ; unknown class = new unknown class proto ( this ) ; loaded classes . put ( unknown class . get type ( ) , unknown class ) ; this . check package private access = check package private access ; load primitive type ( str ) ; load primitive type ( str ) ; load primitive type ( str ) ; load primitive type ( str ) ; load primitive type ( str ) ; load primitive type ( str ) ; load primitive type ( str ) ; load primitive type ( str ) ; load primitive type ( str ) ; for ( dex file dex file : dex files ) { for ( class def class def : dex file . get classes ( ) ) { class def prev = available classes . get ( class def . get type ( ) ) ; if ( prev == null ) { available classes . put ( class def . get type ( ) , class def ) ; } } } }	creates a new classpath instance that can load classes from the given dex files.
private boolean ask to save ( ) { if ( main frame . is project changed ( ) ) { int response = j . show confirm dialog ( main frame , n . get local string ( str , str ) , n . get local string ( str , str ) , j . yes no cancel option , j . warning message ) ; if ( response == j . yes option ) { if ( main frame . get save file ( ) != null ) { save ( ) ; } else { save as ( ) ; } } else if ( response == j . cancel option ) { return bool ; } } return bool ; }	returns true if cancelled.
public map cursor add cursor ( map cursor cursor ) { cursors . add ( cursor ) ; return cursor ; }	add a cursor to the collection .
private boolean discard upstream media chunks ( int queue length ) { if ( media chunks . size ( ) <= queue length ) { return bool ; } long start time us = num ; long end time us = media chunks . get last ( ) . end time us ; base media chunk removed = null ; while ( media chunks . size ( ) > queue length ) { removed = media chunks . remove last ( ) ; start time us = removed . start time us ; } sample queue . discard upstream samples ( removed . get first sample index ( ) ) ; notify upstream discarded ( start time us , end time us ) ; return bool ; }	discard upstream media chunks until the queue length is equal to the length specified .
public metalink file builder add file ( string name ) { metalink file builder new file = new metalink file builder ( name ) ; files . add ( new file ) ; return new file ; }	adds a file to this metalink document.
private void send after connect ( channel ch , netty channel context context final , operation request , netty channel group group ) { if ( request . get status code ( ) < operation . status code failure threshold ) { request . complete ( ) ; } else { request . fail ( request . get status code ( ) ) ; } }	now that the connection is open ( and if using http / 2 , settings have been negotiated ) , send the request .
protected string check production ( final territory to , final collection < unit > units , final id player ) { final list < territory > producers = get all producers ( to , player , units ) ; if ( producers . is empty ( ) ) { return str + to . get name ( ) ; } collections . sort ( producers , get best producer comparator ( to , units , player ) ) ; if ( ! get can all units with requires units be placed correctly ( units , to ) ) { return str ; } final int max units to be placed = get max units to be placed ( units , to , player , bool ) ; if ( ( max units to be placed != - num ) && ( max units to be placed < units . size ( ) ) ) { return str + units . size ( ) + str + to . get name ( ) ; } return null ; }	test whether or not the territory has the factory resources to support the placement.
@ override public void close write ( ) throws io { if ( is write closed ) { return ; } is write closed = bool ; socket stream stream = stream impl ; if ( stream != null ) { stream . close write ( ) ; } else if ( s != null ) { try { s . shutdown output ( ) ; } catch ( unsupported operation exception e ) { log . log ( level . finest , e . to string ( ) , e ) ; } catch ( exception e ) { log . finer ( e . to string ( ) ) ; log . log ( level . finest , e . to string ( ) , e ) ; } } }	closes the write half of the stream .
public boolean equals ( object that ) { return ( that instanceof char set ) && arrays . equals ( chars , ( ( char set ) that ) . chars ) ; }	returns true if " that " is another instance of charset containing the exact same characters as this one.
public static void process records ( list < kinesis event record > input records , kinesis user record processor processor ) { list < record > raw records = new linked list < > ( ) ; for ( kinesis event record rec : input records ) { raw records . add ( rec . get kinesis ( ) ) ; } return processor . process ( user record . deaggregate ( raw records ) ) ; }	method to process a set of kinesis user records from a list of kinesis event records using pre - streams style api.
protected font resolve font ( shared context ctx , string font , float size , ident value weight , ident value style , ident value variant ) { if ( font . starts with ( str ) ) { font = font . substring ( num ) ; } if ( font . ends with ( str ) ) { font = font . substring ( num , font . length ( ) - num ) ; } if ( font . equals ignore case ( str ) ) { font = str ; } if ( font . equals ignore case ( str ) ) { font = str ; } if ( font . equals ignore case ( str ) ) { font = str ; } if ( font . equals ( str ) && style == ident value . oblique ) { font = str ; } if ( font . equals ( str ) && style == ident value . italic ) { font = str ; } string font instance name = get font instance hash name ( ctx , font , size , weight , style , variant ) ; if ( instance hash . contains key ( font instance name ) ) { return instance hash . get ( font instance name ) ; } if ( available fonts hash . contains key ( font ) ) { font possibly null font = available fonts hash . get ( font ) ; font root font = null ; if ( possibly null font != null ) { root font = possibly null font ; } else { root font = new font ( font , font . plain , num ) ; available fonts hash . put ( font , root font ) ; } font fnt = create font ( ctx , root font , size , weight , style , variant ) ; instance hash . put ( font instance name , fnt ) ; return fnt ; } return null ; }	resolves a single font name.
public array real vector ( double [ ] d , int pos , int size ) throws math illegal argument exception , null argument exception { if ( d == null ) { throw new null argument exception ( ) ; } if ( d . length < pos + size ) { throw new math illegal argument exception ( localized core formats . number too large , pos + size , d . length ) ; } data = new double [ size ] ; system . arraycopy ( d , pos , data , num , size ) ; }	construct a vector from part of a array .
public void clear payment methods by id ( list < string > payment method ids to remove ) { if ( util validate . is empty ( payment method ids to remove ) ) return ; for ( iterator < cart payment info > iter = payment info . iterator ( ) ; iter . has next ( ) ; ) { cart payment info info = iter . next ( ) ; if ( payment method ids to remove . contains ( info . payment method id ) ) { iter . remove ( ) ; } } }	remove all the paymentmethods based on the paymentmethodids.
@ override public void clean ( ) { set current points ( num ) ; check state ( ) ; }	clean means to remove the attack request , set the current points to zero and check the plugin state .
public void handle button2 request ( request invocation event event ) { set page session attribute ( get tracking tab id ( ) , am . fed tab id ) ; set page session attribute ( am . previous tab id , get tracking tab id ( ) ) ; federation view bean vb = ( federation view bean ) get view bean ( federation view bean . class ) ; back trail ( ) ; pass pg session map ( vb ) ; vb . forward to ( get request context ( ) ) ; }	handles page cancel request .
@ override public void perform request ( string request ) { if ( request . compare to ( str ) == num ) { stop ( ) ; } else { throw new illegal argument exception ( request + str ) ; } }	perform the named request.
public byte [ ] to bytes ( ) { byte [ ] return bytes = new byte [ bytes length ] ; system . arraycopy ( bytes , num , return bytes , num , bytes length ) ; return return bytes ; }	get the composed bytes of pdu .
public void start check ( ) { checker = new thread ( new check for update ( ) ) ; checker . set priority ( thread . min priority ) ; checker . start ( ) ; }	start key pair generation in a separate thread .
@ override public boolean e is set ( int feature id ) { switch ( feature id ) { case s . transition trigger : return trigger != null ; case s . transition effect : return effect != null ; case s . transition properties : return properties != null && ! properties . is empty ( ) ; case s . transition documentation : return documentation edefault == null ? documentation != null : ! documentation edefault . equals ( documentation ) ; case s . transition target : return target != null ; case s . transition source : return basic get source ( ) != null ; } return super . e is set ( feature id ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
public boolean is ack seen ( ) { return this . ack seen ; }	return true if the dialog has already seen the ack .
protected void uninstall listeners ( ) { super . uninstall listeners ( ) ; split pane . remove property change listener ( this ) ; }	uninstalls the event listeners for the ui .
private static collector < segment info , ? , map < string , segment info > > partitions to map collector ( ) { return collector . of ( null , null , null ) ; }	a collector to aggregate all partitions of a segment into a map .
public boolean is crc ( ) { return is flags ( flag cached values checked & flag crc calced ) ; }	find out if privatecrc value known ( and not simply cached ) . can be used to find out if the privatecrc can be retrieved via getcrc ( ) without forcing it be calculated.
public int size ( ) { return queue . size ( ) ; }	this reports the # of items in the queue .
@ override public string buffer format ( double number , string buffer result , field position field position ) { boolean try fast path = bool ; if ( field position == dont care field position . instance ) try fast path = bool ; else { field position . set begin index ( num ) ; field position . set end index ( num ) ; } if ( try fast path ) { string temp result = fast format ( number ) ; if ( temp result != null ) { result . append ( temp result ) ; return result ; } } return format ( number , result , field position . get field delegate ( ) ) ; }	formats a double to produce a string .
private void build cursor conditionally ( matrix cursor cursor , character record cr , string selection , string [ ] selection args ) { if ( selection args == null ) cursor . add row ( new object [ ] { cr . get id ( ) , cr . get name ( ) , cr . get race ( ) } ) ; else for ( string item : selection args ) if ( ( selection . equals ( character contract . character entry . column name ) && item . equals ( cr . get name ( ) ) ) || ( selection . equals ( character contract . character entry . column race ) && item . equals ( cr . get race ( ) ) ) ) { cursor . add row ( new object [ ] { cr . get id ( ) , cr . get name ( ) , cr . get race ( ) } ) ; } }	build a matrixcursor that matches the parameters.
public modpack file selection panel ( wizard controller controller , map wizard data , file game dir , bi function < string , boolean , integer > black list ) { init components ( ) ; this . controller = controller ; this . wizard data = wizard data ; this . black list = black list ; check box tree node root = create ( game dir , str ) ; j tree1 . set model ( new default tree model ( root ) ) ; j tree1 . set cell renderer ( new check box tree cell renderer ( ) ) ; j tree1 . add mouse listener ( new check box tree node selection listener ( ) ) ; wizard data . put ( str , root ) ; }	creates new form modpackfileselectionpanel.
private void create container if necessary ( ) { if ( container . is full ( ) ) { container = new timer raw container ( ) ; data . add ( container ) ; } }	creates a new container if it is necessary .
private void process update counts ( int [ ] update counts , int commands in batch ) { if ( update counts . length < commands in batch ) { error . emit ( tuples . get ( update counts . length + batch start idx ) ) ; error tuples ++ ; tuples written successfully += update counts . length ; batch start idx += update counts . length + num ; if ( ( tuples . size ( ) - batch start idx ) > num ) { process batch ( ) ; } } else { tuples written successfully = commands in batch ; for ( int i = num ; i < commands in batch ; i ++ ) { if ( update counts [ i ] == statement . execute failed ) { error . emit ( tuples . get ( i + batch start idx ) ) ; error tuples ++ ; tuples written successfully -- ; } } } }	identify which commands in the batch failed and redirect these on the error port.
public int choose protocol version ( ) { return preferred protocol version ; }	returns the protocol version to use for sending multicast requests or announcements , or initiating unicast discovery .
public sensor create new sensor ( string system name , string user name ) { sensor s ; string s name = acela address . normalize system name ( system name ) ; if ( s name . equals ( str ) ) { log . error ( str + system name ) ; return null ; } s = get by system name ( s name ) ; if ( s != null ) { log . error ( str + system name ) ; return null ; } string alt name = acela address . convert system name to alternate ( s name ) ; s = get by system name ( alt name ) ; if ( s != null ) { log . error ( str + system name + str + alt name + str ) ; return null ; } int bit = acela address . get bit from system name ( s name ) ; if ( ( bit < num ) || ( bit >= num ) ) { log . error ( str + integer . to string ( bit ) + str ) ; return null ; } if ( user name == null ) { s = new acela sensor ( s name ) ; } else { s = new acela sensor ( s name , user name ) ; } acela node node = acela address . get node from system name ( s name , memo ) ; if ( node == null ) { log . warn ( str + s name + str ) ; return s ; } if ( ! node . has active sensors ) { int newnodeaddress ; newnodeaddress = node . get node address ( ) ; log . warn ( str + newnodeaddress ) ; return s ; } node . register sensor ( s , bit ) ; return s ; }	create a new sensor if all checks are passed system name is normalized to ensure uniqueness .
public static input stream need stream ( string property name ) throws no such property exception , file not found exception , mary configuration exception { mary properties . need property ( property name ) ; return get stream ( property name ) ; }	for the named property , attempt to get an open input stream.
public static boolean equal ( object a , object b ) { return a == b || ( a != null && a . equals ( b ) ) ; }	returns true if two possibly - null objects are equal .
public static string network name to string ( byte [ ] data , int offset , int length ) { string ret ; if ( ( data [ offset ] & num ) != num || length < num ) { return str ; } switch ( ( data [ offset ] > > > num ) & num ) { case num : int count septets ; int unused bits = data [ offset ] & num ; count septets = ( ( ( length - num ) * num ) - unused bits ) / num ; ret = gsm alphabet . gsm7 bit packed to string ( data , offset + num , count septets ) ; break ; case num : try { ret = new string ( data , offset + num , length - num , str ) ; } catch ( unsupported encoding exception ex ) { ret = str ; log . e ( log tag , str , ex ) ; } break ; default : ret = str ; break ; } if ( ( data [ offset ] & num ) != num ) { } return ret ; }	convert a ts 24.
public void add ( marker marker ) { m items . add ( marker ) ; }	add the marker . important : markers added in a markerclusterer should not be added in the map overlays .
private static map . entry < date time , time series value > find name ( list < time series collection > c , group name name ) { list iterator < time series collection > iter = c . list iterator ( ) ; while ( iter . has next ( ) ) { final int idx = iter . next index ( ) ; final time series collection tsdata = iter . next ( ) ; final optional < time series value > found = tsdata . get ( name ) ; if ( found . is present ( ) ) return simple map entry . create ( tsdata . get timestamp ( ) , found . get ( ) ) ; } throw new illegal state exception ( str ) ; }	finds the first resolution of name in the given timeseriescollections.
public map < string , object > finalize order entry payment ( string check out payment id , big decimal amount , boolean single use , boolean append ) { map < string , object > result = service util . return success ( ) ; if ( util validate . is not empty ( check out payment id ) ) { if ( ! append ) { cart . clear payments ( ) ; } cart . add payment amount ( check out payment id , amount , single use ) ; } return result ; }	sets the payment id to use during the checkout process.
public void deploy ( string route id , string route name , json value route config ) throws router handler exception { reject . if null ( route name ) ; write . lock ( ) ; try { load ( route id , route name , route config . copy ( ) ) ; directory monitor . store ( route id , route config ) ; logger . info ( str , route id , route name ) ; } catch ( io e ) { throw new router handler exception ( format ( str , route id ) , e ) ; } finally { write . unlock ( ) ; } }	deploy a route , meaning that it loads it but also stores it in a file .
private static char [ ] subscript for digit ( int digit ) { return character . to chars ( num + digit ) ; }	gets the unicode subscript character ( u + 2080 - u + 2089 ) for the specified digit .
private fs permission permission ( igfs file file ) { string perm = file . property ( igfs utils . prop permission , null ) ; if ( perm == null ) return fs permission . get default ( ) ; try { return new fs permission ( ( short ) integer . parse int ( perm , num ) ) ; } catch ( number format exception ignore ) { return fs permission . get default ( ) ; } }	convert igfs file attributes into hadoop permission .
public acl ( ) { this . entries = collections . empty map ( ) ; }	creates a new instance of simplemailboxacl containing no entries .
private void read stream result ( in h3 h in , headers amp headers ) throws io { service ref amp service ref = read to address ( h in ) ; long id = h in . read long ( ) ; query ref amp query ref = service ref . get query ref ( id ) ; if ( query ref != null ) { class loader loader = query ref . get class loader ( ) ; thread thread = thread . current thread ( ) ; thread . set context class loader ( loader ) ; } int sequence = h in . read int ( ) ; list < object > values = ( list ) h in . read object ( ) ; throwable exn = ( throwable ) h in . read object ( throwable . class ) ; boolean is complete = h in . read boolean ( ) ; if ( log . is loggable ( log level ) ) { log . log ( log level , str + values + str + is complete + str + this + str + str + id + str + service ref + str + headers + str ) ; } if ( query ref != null ) { if ( query ref . accept ( headers , values , sequence , is complete ) ) { service ref . remove query ref ( id ) ; } if ( exn != null ) { service ref . remove query ref ( id ) ; query ref . fail ( headers , exn ) ; } } else if ( log . is loggable ( level . warning ) ) { log . warning ( str + id + str + service ref + str + headers ) ; } }	the stream result message is a partial or final result from the target ' s stream .
public void update field visibility ( neuron update rule rule ) { boolean bounded = rule instanceof bounded update rule ; boolean clip = bool ; set bounds panel visible ( bounded ) ; if ( bounded ) { clip = rule instanceof clippable update rule ; clipping drop down . set selected ( clip ) ; } set clipping panel visible ( clip ) ; set bounds enabled ( bounded ) ; }	update field visibility based on whether rule is bounded and / or clipped.
@ override public int hash code ( ) { int hash = num ; if ( alt format != null ) { hash += alt format . hash code ( ) ; } if ( projection != null ) { hash = hash * num ; hash += projection . hash code ( ) ; } if ( version != null ) { hash = hash * num ; hash += version . hash code ( ) ; } return hash ; }	the hashcode for a context is just the hashcode of its parts .
public void remove ok listener ( action listener a ) { m ok but . remove action listener ( a ) ; }	this is used to remove an action listener from the ok button .
void change item shape ( brd item p item , int p shape no , shape tile p new shape ) { awtree node leaf [ ] old entries = p item . get search tree entries ( this ) ; awtree node leaf [ ] new leaf arr = new awtree node leaf [ old entries . length ] ; shape tile [ ] new precalculated tree shapes = new shape tile [ old entries . length ] ; remove leaf ( old entries [ p shape no ] ) ; for ( int i = num ; i < new precalculated tree shapes . length ; ++ i ) { if ( i == p shape no ) { new precalculated tree shapes [ i ] = p new shape ; } else { new precalculated tree shapes [ i ] = p item . get tree shape ( this , i ) ; new leaf arr [ i ] = old entries [ i ] ; } } p item . set precalculated tree shapes ( new precalculated tree shapes , this ) ; new leaf arr [ p shape no ] = insert ( p item , p shape no ) ; p item . set search tree entries ( this , new leaf arr ) ; }	changes the shape with index p_shape_no of this item to p_new_shape and updates the entry in the tree .
public j ( kse frame kse frame ) { super ( gradient color 1 , gradient color 2 ) ; this . kse frame = kse frame ; new drop target ( this , this ) ; init components ( ) ; }	construct quick start pane .
public static string indent ( final int depth ) { if ( depth < num ) { return str ; } return ws . substring ( num , math . min ( ws . length ( ) , depth * num ) ) ; }	returns a string that may be used to indent a dump of the nodes in the tree.
public exceptionless output stream ( output stream out ) { super ( new data output stream ( out ) ) ; dos = ( data output stream ) this . out ; }	creates a new data output stream to write data to the specified underlying output stream .
public t advance to element ( predicate < t > predicate ) { node < t > start = head ; if ( head == null ) return null ; do { t curr element = advance ( ) ; if ( predicate . test ( curr element ) ) { return curr element ; } } while ( head != start ) ; return null ; }	advances through the circular list returning the first element for which the predicate evaluates to true.
public void add trace ( final trace trace ) { trace list . add ( trace ) ; add ( trace ) ; revalidate ( ) ; }	add a trace to the plot area .
public static void ping all devices ( string message ) throws io { sender sender = new sender ( ids . api key ) ; for ( device info device info : endpoint . list device info ( ) ) { do send via gcm ( message , sender , device info ) ; } }	ping all registered devices with the message .
private void find matches in contexts ( list < number context > contexts , boolean is valid , boolean is possible , string region , string number ) { if ( is valid ) { do test in context ( number , region , contexts , leniency . valid ) ; } else { for ( number context context : contexts ) { string text = context . leading text + number + context . trailing text ; assert true ( str + text , has no matches ( phone util . find numbers ( text , region ) ) ) ; } } if ( is possible ) { do test in context ( number , region , contexts , leniency . possible ) ; } else { for ( number context context : contexts ) { string text = context . leading text + number + context . trailing text ; assert true ( str + text , has no matches ( phone util . find numbers ( text , region , leniency . possible , long . max value ) ) ) ; } } }	helper method which tests the contexts provided and ensures that : - - if isvalid is true , they all find a test number inserted in the middle when leniency of matching is set to valid ; else no test number should be extracted at that leniency level - - if ispossible is true , they all find a test number inserted in the middle when leniency of matching is set to possible ; else no test number should be extracted at that leniency level.
public void test general punctuation category ( ) { string [ ] s = { str , str , str , str , str , str , str , str , str , str , str , str } ; string regexp = str ; for ( int i = num ; i < s . length ; i ++ ) { pattern pattern = pattern . compile ( regexp ) ; matcher matcher = pattern . matcher ( s [ i ] ) ; assert true ( matcher . find ( ) ) ; } }	regression test for harmony - 3360.
@ override public int hash code ( ) { int code = num ; if ( e subjects != null ) { for ( entitlement subject e subject : e subjects ) { code += e subject . hash code ( ) ; } } if ( p subject name != null ) { code += p subject name . hash code ( ) ; } return code ; }	returns hash code of the object.
private void assign random lower triangular matrix ( int n , secure random sr ) { num rows = n ; num columns = n ; length = ( n + num ) > > > num ; matrix = new int [ num rows ] [ length ] ; for ( int i = num ; i < num rows ; i ++ ) { int q = i > > > num ; int r = i & num ; int s = num - r ; r = num << r ; for ( int j = num ; j < q ; j ++ ) { matrix [ i ] [ j ] = sr . next int ( ) ; } matrix [ i ] [ q ] = ( sr . next int ( ) > > > s ) | r ; for ( int j = q + num ; j < length ; j ++ ) { matrix [ i ] [ j ] = num ; } } }	create a nxn random lower triangular matrix .
private boolean load with inspect it class loader ( string class name ) { return class name . starts with ( class name prefix ) ; }	defines if the class should be loaded with our class loader .
public static void add custom commands ( string commands , context menu m ) { matcher matcher = custom commands pattern . matcher ( commands ) ; boolean sep = bool ; while ( matcher . find ( ) ) { string match = matcher . group ( ) ; if ( match . equals ( str ) ) { sep = bool ; } else { string command = matcher . group ( num ) ; string submenu = null ; if ( match . starts with ( str ) ) { submenu = custom commands submenu ; } if ( sep ) { m . add separator ( submenu ) ; } m . add sub item ( str + command , helper . replace underscore with space ( command ) , submenu ) ; sep = bool ; } } }	parses the given commands setting and adds menu items to the given contextmenu .
public int next clear bit ( int from index ) { int i = from index > > address bits ; int max = data . length ; for ( ; i < max ; i ++ ) { if ( data [ i ] == - num ) { continue ; } int j = math . max ( from index , i << address bits ) ; for ( int end = j + num ; j < end ; j ++ ) { if ( ! get ( j ) ) { return j ; } } } return max << address bits ; }	get the index of the next bit that is not set .
private final void next request ( ) { pacing timer . stop ( ) ; pacing timer . restart ( ) ; reply try count = num ; }	starts the pacing timer , which , at timeout , will begin the next opsw access request .
@ override public boolean equals ( object o ) { if ( this == o ) { return bool ; } if ( o == null || get class ( ) != o . get class ( ) ) { return bool ; } account account = ( account ) o ; if ( username != null ? ! username . equals ( account . username ) : account . username != null ) { return bool ; } return bool ; }	equals and hashcode use ` username ` instead of accountid for easier testing . username is unique so it is safe.
public static int identify pid ( final string name ) throws pid unavailable exception { try { final int index = name . index of ( str ) ; if ( index < num ) { throw new pid unavailable exception ( str + name ) ; } return integer . value of ( name . substring ( num , index ) ) ; } catch ( number format exception e ) { throw new pid unavailable exception ( str + name , e ) ; } }	returns the pid for this process using the specified name from runtimemxbean .
abstract protected void process command ( string line ) throws exception ;	process the command provided in line .
protected object next ( ) { int i = num ; char [ ] c ; try { i = st . next token ( ) ; } catch ( io e ) { debug . error ( str + e . to string ( ) + str ) ; } if ( ( i == stream tokenizer . tt eof ) || ( i == num ) ) return eof ; if ( i == stream tokenizer . tt word ) return new symbol ( st . sval , num ) ; if ( ( i == str ) || ( i == str ) ) return st . sval ; if ( i == stream tokenizer . tt number ) return new double ( st . nval ) ; if ( ( i == str ) || ( i == str ) || ( i == str ) ) return lp ; if ( ( i == str ) || ( i == str ) || ( i == str ) ) return rp ; c = new char [ num ] ; c [ num ] = ( char ) i ; return new symbol ( new string ( c ) , num ) ; }	break the next token into an object .
public static void copy ( file source , file dest ) throws io { if ( source . is directory ( ) ) { dest . mkdir ( ) ; for ( file child : list files ( source ) ) { copy ( child , new file ( dest , child . get name ( ) ) ) ; } } else { if ( source . exists ( ) ) { long lm = source . last modified ( ) ; if ( dest . is directory ( ) ) { dest = new file ( dest , source . get name ( ) ) ; } file output stream fos = new file output stream ( dest ) ; try { file input stream fis = new file input stream ( source ) ; try { if ( use nio ) { nio copy ( fos , fis ) ; } else { oio copy ( source , fos , fis ) ; } } finally { fis . close ( ) ; } } finally { fos . close ( ) ; } dest . set executable ( source . can execute ( ) , bool ) ; dest . set last modified ( lm ) ; } } }	copy a file from the source file to the destination file.
public static int class index ( int lua state , class clazz , string search name ) throws lua exception { synchronized ( lua state factory . get existing state ( lua state ) ) { int res ; res = check field ( lua state , clazz , search name ) ; if ( res != num ) { return num ; } res = check method ( lua state , clazz , search name ) ; if ( res != num ) { return num ; } return num ; } }	java function to be called when a java class metamethod __index is called . this function returns 1 if there is a field with searchname and 2 if there is a method if the searchname.
private void notify resource event listeners ( resource event event , object resource ) { for ( iterator < resource events listener > iter = resource listeners . iterator ( ) ; iter . has next ( ) ; ) { try { resource events listener listener = ( resource events listener ) iter . next ( ) ; listener . handle event ( event , resource ) ; } catch ( cancel exception e ) { } catch ( gem fire security exception | management exception ex ) { if ( event == resource event . cache create ) { throw ex ; } else { logger . warn ( ex . get message ( ) , ex ) ; } } catch ( exception err ) { logger . warn ( err . get message ( ) , err ) ; } catch ( virtual machine error e ) { system failure . initiate failure ( e ) ; throw e ; } catch ( throwable t ) { system failure . check failure ( ) ; logger . warn ( t . get message ( ) , t ) ; } } }	notifies all resource event listeners . all exceptions are caught here and only a warning message is printed in the log.
private void infer caller ( ) { need to infer caller = bool ; throwable throwable = new throwable ( ) ; boolean looking for logger = bool ; for ( final stack trace element frame : throwable . get stack trace ( ) ) { string cname = frame . get class name ( ) ; boolean is logger impl = is logger impl frame ( cname ) ; if ( looking for logger ) { if ( is logger impl ) { looking for logger = bool ; } } else { if ( ! is logger impl ) { if ( ! cname . starts with ( str ) && ! cname . starts with ( str ) ) { set source class name ( cname ) ; set source method name ( frame . get method name ( ) ) ; return ; } } } } }	determines the source information for the caller of the logger ( class name , method name , and line number ).
final int record exceptional completion ( throwable ex ) { int s ; if ( ( s = status ) >= num ) { int h = system . identity hash code ( this ) ; final reentrant lock lock = exception table lock ; lock . lock ( ) ; try { expunge stale exceptions ( ) ; exception node [ ] t = exception table ; int i = h & ( t . length - num ) ; for ( exception node e = t [ i ] ; ; e = e . next ) { if ( e == null ) { t [ i ] = new exception node ( this , ex , t [ i ] , exception table ref queue ) ; break ; } if ( e . get ( ) == this ) break ; } } finally { lock . unlock ( ) ; } s = set completion ( exceptional ) ; } return s ; }	records exception and sets status .
private void analyze resulting tls context and write file ( tls context tls context , string folder , string field name , string workflow name , long phase ) throws jaxb , io { if ( tls context analyzer . contains full workflow with missing message ( tls context ) || tls context analyzer . contains server finished with modified handshake ( tls context ) || tls context analyzer . contains full workflow with modified message ( tls context ) ) { string file name basic = create file name ( folder , phase , tls context , field name ) ; file output stream fos = new file output stream ( file name basic + workflow name + str ) ; workflow trace serializer . write ( fos , tls context . get workflow trace ( ) ) ; } }	analyzes the resulting workflow.
private static string to variable name ( string str ) { string buffer rtn = new string buffer ( ) ; char [ ] chars = str . to char array ( ) ; long changes = num ; boolean do correct = bool ; for ( int i = num ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( i == num && ( c >= str && c <= str ) ) rtn . append ( str + c ) ; else if ( ( c >= str && c <= str ) || ( c >= str && c <= str ) || ( c >= str && c <= str ) || c == str || c == str ) rtn . append ( c ) ; else { do correct = bool ; rtn . append ( str ) ; changes += ( c * ( i + num ) ) ; } } if ( changes > num ) rtn . append ( changes ) ; if ( do correct ) return correct reserved word ( rtn . to string ( ) ) ; return rtn . to string ( ) ; }	translate a string to a valid variable string.
public year ( int year ) { if ( ( year < year . minimum year ) || ( year > year . maximum year ) ) { throw new illegal argument exception ( str + year + str ) ; } this . year = ( short ) year ; peg ( calendar . get instance ( ) ) ; }	creates a time period representing a single year .
@ suppress warnings ( str ) public list < string > host vcenter change details ( uri host id , uri cluster id , uri datacenter id , boolean is vcenter ) { list < string > result = lists . new array list ( ) ; host host = db client . query object ( host . class , host id ) ; vcenter data center datacenter = db client . query object ( vcenter data center . class , datacenter id ) ; if ( host != null && datacenter != null ) { result . add ( compute system dialog properties . get message ( str , host . get label ( ) , datacenter . get label ( ) ) ) ; result . add all ( host cluster change details ( host id , cluster id , datacenter id , is vcenter ) ) ; } return result ; }	get details for the hostvcenterchange method note : in order to maintain backwards compatibility , do not change the signature of this method .
public boolean delete statement ( test case test , int position ) throws construction failed exception { if ( ! constraint verifier . can delete ( test , position ) ) { return bool ; } logger . debug ( str , position ) ; set < integer > to delete = new linked hash set < > ( ) ; recursive delete inclusion ( test , to delete , position ) ; list < integer > pos = new array list < > ( to delete ) ; collections . sort ( pos , collections . reverse order ( ) ) ; for ( integer i : pos ) { logger . debug ( str , i ) ; test . remove ( i ) ; } return bool ; }	delete the statement at position from the test case and remove all references to it.
public boolean is compound ( ) { return splits . size ( ) != num ; }	checks if this instance is a compounding word .
@ override public set < statement > sum ( final igas < set < statement > , set < statement > , set < statement > > state , final set < statement > left , final set < statement > right ) { final set < statement > tmp = new linked hash set < statement > ( left ) ; tmp . add all ( right ) ; return tmp ; }	set union over the gathered edges .
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return host ; case num : return port ; case num : return id ; case num : return v nodes ; case num : return ping frequency ; case num : return service name ; case num : return state ; case num : return timestamp ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
private static int categorize by year2014 method ( context c ) { array list < integer > component years = new array list < integer > ( ) ; conditionally add ( component years , get num cores year ( ) ) ; conditionally add ( component years , get clock speed year ( ) ) ; conditionally add ( component years , get ram year ( c ) ) ; if ( component years . is empty ( ) ) return class unknown ; collections . sort ( component years ) ; if ( ( component years . size ( ) & num ) == num ) { return component years . get ( component years . size ( ) / num ) ; } else { int base index = component years . size ( ) / num - num ; return component years . get ( base index ) + ( component years . get ( base index + num ) - component years . get ( base index ) ) / num ; } }	calculates the " best - in - class year " of the device.
public action request helper then ( action request helper next action ) { m next . add ( next action ) ; return this ; }	this request will be executed if the current request succeed .
public boolean is current ( string str ) { if ( pos + str . length ( ) > lc text . length ) return bool ; for ( int i = str . length ( ) - num ; i >= num ; i -- ) { if ( str . char at ( i ) != lc text [ pos + i ] ) return bool ; } return bool ; }	returns if the current character ( internal pointer ) and the following are the same as the given input.
private static string matchable path ( string path ) { if ( path == null ) { return str ; } else if ( path . ends with ( str ) ) { return path ; } else { return path + str ; } }	returns a non - null path ending in " / " .
public void assert usable ( ) throws io { if ( throwable . get ( ) == null ) { if ( connection == null ) { throw new io ( str ) ; } return ; } throwable t = throwable . get ( ) ; if ( t instanceof io ) { throw ( io ) t ; } else { throw throwables . propagate ( t ) ; } }	before the websocket is used , it ' s recommended to call this method to ensure that any exceptions caught while processing the messages received are acknowledged .
protected static double compute h ( final int i , double [ ] dist i , double [ ] pij i , double mbeta ) { double sum p = num ; for ( int j = num ; j < i ; j ++ ) { sum p += ( pij i [ j ] = math . exp ( dist i [ j ] * mbeta ) ) ; } for ( int j = i + num ; j < dist i . length ; j ++ ) { sum p += ( pij i [ j ] = math . exp ( dist i [ j ] * mbeta ) ) ; } if ( ! ( sum p > num ) ) { return double . negative infinity ; } final double s = num / sum p ; double sum = num ; for ( int j = num ; j < dist i . length ; j ++ ) { sum += dist i [ j ] * ( pij i [ j ] *= s ) ; } return math . log ( sum p ) - mbeta * sum ; }	compute h ( observed perplexity ) for row i , and the row pij_i .
public static string add protocol to url ( string url ) { if ( ! url . starts with ( http protocol prefix ) && ! url . starts with ( https protocol prefix ) && ! url . starts with ( file protocol prefix ) ) { if ( url . starts with ( file prefix ) ) { url = file protocol prefix + url ; } else { url = http protocol prefix + url ; } } return url ; }	this method add the protocol to the url if the protocol is missing.
public static string method name to property name ( string method name ) { if ( method name . starts with ( str ) ) method name = method name . substring ( num ) ; else if ( method name . starts with ( str ) ) method name = method name . substring ( num ) ; else if ( method name . starts with ( str ) ) method name = method name . substring ( num ) ; if ( method name . length ( ) == num ) return null ; char ch = method name . char at ( num ) ; if ( character . is upper case ( ch ) && ( method name . length ( ) == num || ! character . is upper case ( method name . char at ( num ) ) ) ) { method name = character . to lower case ( ch ) + method name . substring ( num ) ; } return method name ; }	converts a user ' s property name to a bean method name .
private string builder create indent ( int indent ) { string builder one indent = create indent ( ) ; string builder ret = new string builder ( ) ; while ( indent -- > num ) { ret . append ( one indent ) ; } return ret ; }	creates a string that represents the given number of indents ( can be spaces or tabs.
protected class loader ( ) { this ( get system class loader ( ) ) ; }	constructs a new instance of this class with the system class loader as its parent .
public static void matchv pool with storage pools ( virtual pool vpool , list < storage pool > pools , db client db client , coordinator client coordinator , string matcher group name , string buffer error message ) { list < storage pool > filter pools = get matched pool with storage pools ( vpool , pools , virtual pool . get protection settings ( vpool , db client ) , virtual pool . get remote protection settings ( vpool , db client ) , virtual pool . get file remote protection settings ( vpool , db client ) , db client , coordinator , matcher group name , error message ) ; update invalid and matched pools for vpool ( vpool , filter pools , pools , db client ) ; }	matches given virtualpool with list of pools provided and update matched / invalid pools in virtualpool .
static < t > boolean remove if ( iterable < t > remove from , predicate < ? super t > predicate ) { if ( remove from instanceof random access && remove from instanceof list ) { return remove if from random access list ( ( list < t > ) remove from , check not null ( predicate ) ) ; } return iterators . remove if ( remove from . iterator ( ) , predicate ) ; }	removes , from an iterable , every element that satisfies the provided predicate .
@ before class public static void create ecom connection ( ) { boolean was exception = bool ; try { connection = new ecom connection ( create connection info ( ) , create listener ( ) , new cim filter map ( ) ) ; } catch ( exception e ) { was exception = bool ; } assert . assert false ( was exception ) ; }	creates a connection required by the ecom processor .
protected void init ( final i uri resolver , final i < bigdata value > config , final collection < i < ? extends bigdata value > > extensions ) { }	give subclasses a chance to add extensions .
public mx rectangle graph model changed ( mx i sender , list < mx undoable change > changes , boolean rv ) { int thresh = get changes repaint threshold ( ) ; boolean ignore dirty = thresh > num && changes . size ( ) > thresh ; if ( ! ignore dirty ) { iterator < mx undoable change > it = changes . iterator ( ) ; while ( it . has next ( ) ) { if ( it . next ( ) instanceof mx root change ) { ignore dirty = bool ; break ; } } } array list < object > changed cells = new array list < object > ( ) ; mx rectangle dirty = process changes ( changes , bool , ignore dirty , changed cells ) ; if ( ! rv ) { if ( changed cells != null ) { for ( object changed cell : changed cells ) { mx cell state parent state = view . get state ( model . get parent ( changed cell ) , bool ) ; view . validate ( parent state , changed cell , bool ) ; } } } else view . validate ( ) ; if ( ! ignore dirty ) { mx rectangle tmp = process changes ( changes , bool , ignore dirty ) ; if ( tmp != null ) { if ( dirty == null ) { dirty = tmp ; } else { dirty . add ( tmp ) ; } } } remove selection cells ( get removed cells for changes ( changes ) ) ; return dirty ; }	called when the graph model changes.
public void test set bit exception ( ) { byte a bytes [ ] = { - num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = num ; int number = - num ; big integer a number = new big integer ( a sign , a bytes ) ; try { a number . set bit ( number ) ; fail ( str ) ; } catch ( arithmetic exception e ) { } }	setbit ( int n ) of a negative n.
public void guard ( final guard r ) throws interrupted exception { inc thread ( ) ; try { r . run ( ) ; } catch ( interrupted exception e ) { throw e ; } catch ( exception e ) { throw new runtime exception ( e ) ; } finally { dec thread ( ) ; } }	execute a critical region which needs to be interrupted if some condition is violated .
public void log ( date time , string message ) { try { print writer w = new print writer ( new file writer ( filename , bool ) ) ; w . println ( str + format . format ( time ) + str + message ) ; w . close ( ) ; } catch ( io e ) { } }	emits a message to the log , timestamped with the specified time .
protected resource info new element ( int type ) { resource info result = null ; switch ( type ) { case i . file : case i . folder : result = new resource info ( type ) ; break ; case i . project : result = new resource info ( type ) ; break ; case i . root : result = new resource info ( type ) ; break ; } return result ; }	create and return a new tree element of the given type .
private boolean is model useful ( contingency matrix cm ) { return bool ; }	helper method to decide whether a model improves the training error enough to be considered.
public void register player observer ( player events observer observer , boolean reply immediately ) { if ( this . connection == null ) return ; player events observers . add ( observer ) ; if ( reply immediately ) reply with last result ( observer ) ; if ( player events observers . size ( ) == num ) { if ( connection . get protocol ( ) == host connection . protocol tcp ) { connection . register player notifications observer ( this , checker handler ) ; connection . register system notifications observer ( this , checker handler ) ; connection . register input notifications observer ( this , checker handler ) ; checker handler . post ( tcp checker runnable ) ; } else { checker handler . post ( http checker runnable ) ; } } }	registers a new observer that will be notified about player events.
@ override public int num elements ( ) throws exception { if ( m zero r != null ) { return num ; } return m . num nodes ( ) ; }	returns the number of elements in the partition .
public boolean is highlightable ( om omg ) { return bool ; }	query asking if omgraphic is highlight - able , which means that something in the gui should change when the mouse is moved or dragged over the given omgraphic.
public void test virtual destinations dinamically included behavior3 ( ) throws exception { final string topic = str ; final string vq = str + topic ; start all brokers ( ) ; final int msgs1 = num ; final int msgs2 = num ; destination t dest = create destination ( topic , bool ) ; destination vq dest = create destination ( vq , bool ) ; message consumer client b1t = create consumer ( str , t dest ) ; message consumer client b2t = create consumer ( str , t dest ) ; message consumer client b1vq = create consumer ( str , vq dest ) ; thread . sleep ( num * num ) ; send messages ( str , t dest , msgs1 ) ; send messages ( str , t dest , msgs2 ) ; thread . sleep ( num ) ; message id list msgs b1t = get consumer messages ( str , client b1t ) ; msgs b1t . wait for messages to arrive ( msgs1 + msgs2 ) ; assert equals ( msgs1 + msgs2 , msgs b1t . get message count ( ) ) ; message id list msgs b2t = get consumer messages ( str , client b2t ) ; msgs b2t . wait for messages to arrive ( msgs1 + msgs2 ) ; assert equals ( msgs1 + msgs2 , msgs b2t . get message count ( ) ) ; message id list msgs b1vq = get consumer messages ( str , client b1vq ) ; msgs b1vq . wait for messages to arrive ( msgs1 + msgs2 ) ; assert equals ( msgs1 + msgs2 , msgs b1vq . get message count ( ) ) ; assert equals ( num , get queue size ( str , ( mq ) vq dest ) ) ; assert equals ( num , get queue size ( str , ( mq ) vq dest ) ) ; destroy all brokers ( ) ; }	brokera - > brokerb & & brokerb - > brokera.
public rpc client peer with ( peer info server info , bootstrap bootstrap , map < string , object > attributes ) throws io { inet socket address remote address = new inet socket address ( server info . get host name ( ) , server info . get port ( ) ) ; return peer with ( remote address , bootstrap , attributes ) ; }	create a new client with the provided attributes to the remoteaddress .
public grid reversed lines file reader ( final file file , final int block size , final string encoding ) throws io { this ( file , block size , charset . for name ( encoding ) ) ; }	creates a reverselinereader with the given block size and encoding .
private void before name ( ) throws io { int context = peek ( ) ; if ( context == nonempty object ) { out . write ( str ) ; } else if ( context != empty object ) { throw new illegal state exception ( str ) ; } newline ( ) ; replace top ( dangling name ) ; }	inserts any necessary separators and whitespace before a name.
protected string const name ( ) { return str + name . to upper case ( ) ; }	convert array name into all uppercase internal scanner constant name .
public boolean is timestamp within interval ( date time timestamp , string interval string ) throws illegal argument exception { interval interval = interval . parse ( interval string ) ; return interval . contains ( timestamp ) ; }	returns true if the supplied timestamp is within the specified time interval . the supplied interval string should contain an iso 8601 formatted interval string and may be of the formats ' datetime / datetime ' , ' datetime / period ' or ' period / datetime '.
private void process ansi os command ( ) { if ( ansi os command . char at ( num ) != str || ansi os command . char at ( num ) != str ) { logger . log ( str + ansi os command + str ) ; return ; } }	this method is called when we have parsed an os command escape sequence.
public boolean remove trigger group to never delete ( string group ) { if ( group != null ) return trigger groups to never delete . remove ( group ) ; return bool ; }	remove the given group to the list of trigger groups that will never be deleted by this processor , even if a pre - processing - command to delete the group is encountered .
public void remove ( rule rule ) { rules . remove ( rule ) ; }	removes a rule from this grammar .
@ check return value @ deprecated @ nonnull public static string join ( @ nonnull string [ ] s , @ nonnull string delimiter ) { string builder buffer = new string builder ( ) ; for ( int i = num ; i < s . length ; i ++ ) { buffer . append ( s [ i ] ) ; if ( i < s . length - num ) { buffer . append ( delimiter ) ; } } return buffer . to string ( ) ; }	join an array of strings , separated by a delimiter.
private void init select position ( int position ) { if ( m select mode == i . select mode single ) { if ( m selected position == i . invalid position ) { m selected position = position ; } } else if ( m select mode == i . select mode multi ) { if ( ! m selected positions . contains ( position ) ) m selected positions . add ( position ) ; } else { throw new runtime exception ( ) ; } }	this will only called once .
@ override public path impl scheme walk ( string user path , map < string , object > attributes , string file path , int offset ) { if ( ! is windows ( ) ) { return super . scheme walk ( user path , attributes , file path , offset ) ; } string canonical path ; if ( file path . length ( ) < offset + num ) { return super . scheme walk ( user path , attributes , file path , offset ) ; } char ch1 = file path . char at ( offset + num ) ; char ch2 = file path . char at ( offset ) ; if ( ( ch2 == str || ch2 == separator char ) && ( ch1 == str || ch1 == separator char ) ) return super . scheme walk ( user path , attributes , convert from windows path ( file path . substring ( offset ) ) , num ) ; else return super . scheme walk ( user path , attributes , file path , offset ) ; }	lookup the path , handling windows weirdness.
void init properties ( string default level , string default filter , string default formatter , string default encoding ) { log manager manager = log manager . get log manager ( ) ; final string filter name = manager . get property ( prefix + str ) ; if ( filter name != null ) { try { filter = ( filter ) get customize instance ( filter name ) ; } catch ( exception e1 ) { print invalid prop message ( str , filter name , e1 ) ; filter = ( filter ) get default instance ( default filter ) ; } } else { filter = ( filter ) get default instance ( default filter ) ; } string level name = manager . get property ( prefix + str ) ; if ( level name != null ) { try { level = level . parse ( level name ) ; } catch ( exception e ) { print invalid prop message ( str , level name , e ) ; level = level . parse ( default level ) ; } } else { level = level . parse ( default level ) ; } final string formatter name = manager . get property ( prefix + str ) ; if ( formatter name != null ) { try { formatter = ( formatter ) get customize instance ( formatter name ) ; } catch ( exception e ) { print invalid prop message ( str , formatter name , e ) ; formatter = ( formatter ) get default instance ( default formatter ) ; } } else { formatter = ( formatter ) get default instance ( default formatter ) ; } final string encoding name = manager . get property ( prefix + str ) ; try { internal set encoding ( encoding name ) ; } catch ( unsupported encoding exception e ) { print invalid prop message ( str , encoding name , e ) ; } }	init the common properties , including filter , level , formatter , and encoding.
public static void write unsigned vl ( long data , data output out ) throws io { while ( bool ) { if ( ( data & ~ num ) == num ) { out . write byte ( ( int ) data ) ; return ; } else { out . write byte ( ( ( int ) data & num ) | num ) ; data >>>= num ; } } }	encode a long as a variable length array.
public json names ( ) { json ja = new json ( ) ; iterator keys = keys ( ) ; while ( keys . has next ( ) ) { ja . put ( keys . next ( ) ) ; } return ja . length ( ) == num ? null : ja ; }	produce a jsonarray containing the names of the elements of this jsonobject .
public void add table with alias ( string table , string alias ) { query table data table data = new query table data ( ) ; table data . set table name ( table ) ; table data . set table alias ( alias ) ; table data . set table index ( tables data . size ( ) ) ; tables data . add ( table data ) ; if ( alias == null ) tables . put ( table , table data ) ; else { tables . put ( alias , table data ) ; tables . put ( table , table data ) ; } }	add an alias - table mapping . if no alias exists , we ' ll use the table name.
private int encrypt block ( byte [ ] in , int in off , byte [ ] out , int out off ) throws data length exception , illegal state exception { if ( ( in off + block size ) > in . length ) { throw new data length exception ( str ) ; } for ( int i = num ; i < block size ; i ++ ) { cbc v [ i ] ^= in [ in off + i ] ; } int length = cipher . process block ( cbc v , num , out , out off ) ; system . arraycopy ( out , out off , cbc v , num , cbc v . length ) ; return length ; }	do the appropriate chaining step for cbc mode encryption .
private void render axes ( camera camera ) { gl push matrix ( ) ; gl load identity ( ) ; float rot x = camera . get rotation ( ) . x ; float rot y = camera . get rotation ( ) . y ; float rot z = num ; gl rotatef ( rot x , num , num , num ) ; gl rotatef ( rot y , num , num , num ) ; gl rotatef ( rot z , num , num , num ) ; gl line width ( num ) ; gl begin ( gl lines ) ; gl color3f ( num , num , num ) ; gl vertex3f ( num , num , num ) ; gl vertex3f ( num , num , num ) ; gl color3f ( num , num , num ) ; gl vertex3f ( num , num , num ) ; gl vertex3f ( num , num , num ) ; gl color3f ( num , num , num ) ; gl vertex3f ( num , num , num ) ; gl vertex3f ( num , num , num ) ; gl end ( ) ; gl pop matrix ( ) ; }	renders the three axis in space ( for debugging purposes only.
@ override public object clone ( ) throws clone not supported exception { period axis label info clone = ( period axis label info ) super . clone ( ) ; return clone ; }	returns a clone of the object .
public long skip ( long n ) throws io { if ( n < num ) { throw new illegal argument exception ( str ) ; } ensure open ( ) ; int max = ( int ) math . min ( n , integer . max value ) ; int total = num ; while ( total < max ) { int len = max - total ; if ( len > tmpbuf . length ) { len = tmpbuf . length ; } len = read ( tmpbuf , num , len ) ; if ( len == - num ) { entry eof = bool ; break ; } total += len ; } return total ; }	skips specified number of bytes in the current zip entry .
private path convert path ( path path ) throws exception { if ( mode != proxy ) return path ; else { uri secondary uri = new uri ( secondary uri ) ; uri path uri = path . to uri ( ) ; return new path ( new uri ( path uri . get scheme ( ) != null ? secondary uri . get scheme ( ) : null , path uri . get authority ( ) != null ? secondary uri . get authority ( ) : null , path uri . get path ( ) , null , null ) ) ; } }	convert path for exception message testing purposes .
private static string join array ( string [ ] array , string delimiter ) { string buffer buffer = new string buffer ( ) ; for ( int index = num ; index < array . length ; index ++ ) { buffer . append ( array [ index ] ) ; if ( index < array . length - num ) { buffer . append ( delimiter ) ; } } return buffer . to string ( ) ; }	returns a string created by each element of the array , separated by delimiter .
private void output partners ( properties ctx , print writer out , int partner id , boolean include any ) { out . println ( str ) ; if ( include any ) { out . println ( str ) ; if ( partner id == num ) out . println ( str ) ; out . println ( str ) ; } for ( mb partner : get all partners ( ctx ) ) { out . print ( str + partner . get id ( ) + str ) ; if ( partner id == partner . get id ( ) ) out . print ( str ) ; out . println ( str + util . mask html ( partner . get name ( ) ) + str ) ; } out . println ( str ) ; }	output xml list of business partners.
public void stop ( ) { m cancel = bool ; if ( m running . compare and set ( bool , bool ) ) { if ( m sample dispatcher task != null ) { m sample dispatcher task . cancel ( bool ) ; m filled buffers . clear ( ) ; } } }	stops the sample fetching thread.
public chess square ( composite parent , chess board chess board , int id , boolean is light ) { super ( parent , swt . double buffered | swt . no background ) ; board = chess board ; this . id = id ; this . is light = is light ; add paint listener ( paint listener ) ; add control listener ( control listener ) ; add mouse listener ( mouse listener ) ; add listener ( swt . mouse wheel , mouse wheel listener ) ; add listener ( swt . mouse down , dnd listener ) ; add listener ( swt . mouse up , dnd listener ) ; }	creates a chesssquare tied to the specified board .
@ override protected void stop service ( ) { thread t = keep alive thread ; keep alive thread = null ; if ( t != null ) { t . interrupt ( ) ; } }	stops the engine monitor .
public static int truncated compare to ( final calendar cal1 , final calendar cal2 , final int field ) { final calendar truncated cal1 = truncate ( cal1 , field ) ; final calendar truncated cal2 = truncate ( cal2 , field ) ; return truncated cal1 . compare to ( truncated cal2 ) ; }	determines how two calendars compare up to no more than the specified most significant field .
public boolean is port usable ( storage port storage port ) { return is port usable ( storage port , bool ) ; }	convenient method to check whether given storage port is usable to compute port metric.
@ override public void action performed ( action event event ) { string command = event . get action command ( ) ; if ( command . equals ( str ) ) { attempt font selection ( ) ; } else if ( command . equals ( str ) ) { attempt paint selection ( ) ; } else if ( command . equals ( str ) ) { attempt modify show title ( ) ; } }	handles button clicks by passing control to an appropriate handler method .
void remove attribute values ( string attr name , set values ) throws sms { if ( attr name != null ) { map attrs = get attributes ( ) ; set orig values = ( set ) attrs . get ( attr name ) ; if ( orig values != null && ! orig values . is empty ( ) ) { set new values = new hash set ( orig values ) ; new values . remove all ( values ) ; if ( new values . is empty ( ) ) { remove attribute ( attr name ) ; } else { map new attrs = new hash map ( ) ; new attrs . put ( attr name , new values ) ; set attributes ( new attrs ) ; } } } }	removes the specified attribute values from amsdk organization.
private static boolean check content characters ( string chars ) throws char conversion exception { boolean escape = bool ; for ( int i = num ; i < chars . length ( ) ; i ++ ) { char ch = chars . char at ( i ) ; if ( ch <= num ) { switch ( ch ) { case num : case num : case num : continue ; case str : if ( escape ) { continue ; } escape = ( i > num ) && ( chars . char at ( i - num ) == str ) ; continue ; case str : case str : escape = bool ; continue ; default : if ( ch < num ) { throw new char conversion exception ( str + ( ( int ) ch ) + str ) ; } } } } return escape == bool ; }	check if all passed characters match xml expression [ 2 ] .
public void test find app deployments ( ) throws exception { war war = create war ( ) ; test config war ( ) ; list < element > l = deployer . select app deployments ( war , domain ) ; assert equals ( num , l . size ( ) ) ; deployer . remove deployable from domain ( war , domain ) ; l = deployer . select app deployments ( war , domain ) ; assert equals ( num , l . size ( ) ) ; }	test deployments analysis in config.
@ override public void draw top ( final d g2d ) { final rectangle r = get area ( ) ; if ( is contained ( ) ) { r . set location ( num , num ) ; } else { if ( ! is on screen ( g2d , r ) ) { return ; } } final composite old composite = g2d . get composite ( ) ; try { g2d . set composite ( entity composite ) ; draw top ( g2d , r . x , r . y , r . width , r . height ) ; } finally { g2d . set composite ( old composite ) ; } }	draw the top layer parts of an entity.
protected void init debug ( ) { set debug ( ( get init parameter ( str ) == null ) ? bool : boolean . value of ( get init parameter ( str ) ) ) ; }	initializer for property debug .
protected static rpc pair resolve rpc pair ( ast node , peer type resolver peer resolver ) { method declaration method decl = ast . find parent method declaration ( node ) ; type declaration type decl = ( type declaration ) ast . find ancestor ( node , ast . type declaration ) ; assert ( type decl != null ) ; i dst type = peer resolver . get peer type ( type decl ) ; if ( dst type == null ) { return null ; } compilation unit ast root = ast . create quick fix ast ( dst type . get compilation unit ( ) , null ) ; type declaration dst type decl = ast . find type declaration ( ast root , dst type . get fully qualified name ( str ) ) ; if ( dst type decl == null ) { return null ; } return new rpc pair ( type decl , method decl , dst type decl ) ; }	finds the related rpc components for a given method : declaring type & peer type .
public static void assert equals ( field matrix < ? extends field element < ? > > expected , field matrix < ? extends field element < ? > > observed ) { assert . assert not null ( str , observed ) ; if ( expected . get column dimension ( ) != observed . get column dimension ( ) || expected . get row dimension ( ) != observed . get row dimension ( ) ) { string builder message buffer = new string builder ( ) ; message buffer . append ( str ) ; message buffer . append ( str + observed . get row dimension ( ) + str + observed . get column dimension ( ) ) ; message buffer . append ( str + expected . get row dimension ( ) + str + expected . get column dimension ( ) ) ; assert . fail ( message buffer . to string ( ) ) ; } for ( int i = num ; i < expected . get row dimension ( ) ; ++ i ) { for ( int j = num ; j < expected . get column dimension ( ) ; ++ j ) { field element < ? > eij = expected . get entry ( i , j ) ; field element < ? > oij = observed . get entry ( i , j ) ; assert . assert equals ( eij , oij ) ; } } }	verifies that two matrices are equal.
public void add addition ( string addition ) { additions . add ( addition ) ; }	adds a new addition date.
private void start new transition ( ) { if ( ! has bounds ( ) ) { throw new unsupported operation exception ( str + str ) ; } m current trans = m trans gen . generate next transition ( m drawable rect , m viewport rect ) ; m elapsed time = num ; m last frame time = system . current time millis ( ) ; fire transition start ( m current trans ) ; }	generates and starts a transition .
protected void rotate orthogonal ( ) { active . set rotation ( active . get rotation ( ) + num , this ) ; error . set rotation ( error . get rotation ( ) + num , this ) ; display state ( ) ; repaint ( ) ; }	* * * * * * popup abstractaction . actionperformed method overrides.
private string convert to element name ( string attribute name ) { return attribute name . replace ( str , str ) ; }	converts an attribute name ( with space ) to an xml element name ( with underscores ) .
private boolean has other map and reduce parent node ( lop tmp node , array list < lop > node list , lop node ) { if ( tmp node . get exec location ( ) == exec location . map and reduce ) return bool ; for ( lop n : tmp node . get outputs ( ) ) { if ( node list . contains ( n ) && is child ( n , node , id ) ) { if ( ! n . equals ( node ) && n . get exec location ( ) == exec location . map and reduce ) return bool ; else return has other map and reduce parent node ( n , node list , node ) ; } } return bool ; }	method to see if there is a node of type mapandreduce between tmpnode and node in given node collection.
@ nullable string find longest name prefix ( node name , set < string > namespaces ) { if ( namespaces . contains ( name . get qualified name ( ) ) ) { return name . get qualified name ( ) ; } else if ( name . is get prop ( ) ) { return find longest name prefix ( name . get first child ( ) , namespaces ) ; } return null ; }	gets the longest namespace that is a prefix of the name node.
public static log writer create log writer ( final properties properties ) { properties non default = properties ; if ( non default == null ) { non default = new properties ( ) ; } distributed test utils . add hydra properties ( non default ) ; distribution config dc = new distribution config impl ( non default ) ; log writer logger = log writer factory . create log writer logger ( bool , bool , dc , bool ) ; non default . put ( distribution config . log writer name , logger ) ; return logger ; }	creates a new logwriter and adds it to the config properties.
public int session ( ) { return integer . parse int ( fields [ num ] ) ; }	the session id of the process .
public boolean on back pressed ( ) { if ( does drawer exist ( ) ) { if ( m drawer . is drawer visible ( gravity . start ) ) { m drawer . close drawer ( gravity . start ) ; return bool ; } } if ( m content view . on back pressed ( ) ) return bool ; if ( ! m state stack . empty ( ) ) { m state stack . pop ( ) ; if ( ! m state stack . empty ( ) ) { set state ( m state stack . pop ( ) ) ; return bool ; } } return bool ; }	called when the user presses the back key.
public void simulate method ( soot method method , reference variable this var , reference variable return var , reference variable params [ ] ) { string sub signature = method . get sub signature ( ) ; if ( sub signature . equals ( str ) ) { java io latest user defined loader ( method , this var , return var , params ) ; return ; } else if ( sub signature . equals ( str ) ) { java io allocate new object ( method , this var , return var , params ) ; return ; } else if ( sub signature . equals ( str ) ) { java io allocate new array ( method , this var , return var , params ) ; return ; } else { default method ( method , this var , return var , params ) ; return ; } }	implements the abstract method simulatemethod.
public shard iterator only node selector active initializing shards it ( string node attribute , discovery nodes discovery nodes ) { array list < shard routing > ordered = new array list < > ( active shards . size ( ) + all initializing shards . size ( ) ) ; set < string > selected nodes = sets . new hash set ( discovery nodes . resolve nodes ids ( node attribute ) ) ; for ( shard routing shard routing : active shards ) { if ( selected nodes . contains ( shard routing . current node id ( ) ) ) { ordered . add ( shard routing ) ; } } for ( shard routing shard routing : all initializing shards ) { if ( selected nodes . contains ( shard routing . current node id ( ) ) ) { ordered . add ( shard routing ) ; } } if ( ordered . is empty ( ) ) { throw new illegal argument exception ( str + node attribute + str ) ; } return new plain shard iterator ( shard id , ordered ) ; }	returns shards based on nodeattributes given such as node name , node attribute , node ip supports node specifications in cluster api.
private void check changes ( ) { settings . clear movie nfo filenames ( ) ; if ( cb movie nfo filename1 . is selected ( ) ) { settings . add movie nfo filename ( movie nfo naming . filename nfo ) ; } if ( cb movie nfo filename2 . is selected ( ) ) { settings . add movie nfo filename ( movie nfo naming . movie nfo ) ; } if ( cb movie nfo filename3 . is selected ( ) ) { settings . add movie nfo filename ( movie nfo naming . disc nfo ) ; } certification style wrapper wrapper = ( certification style wrapper ) cb certification style . get selected item ( ) ; if ( wrapper != null && settings . get movie certification style ( ) != wrapper . style ) { settings . set movie certification style ( wrapper . style ) ; } }	check changes of checkboxes.
x [ ] copy items ( ) { synchronized ( get menu tree lock ( ) ) { return ( x [ ] ) items . to array ( new x [ ] { } ) ; } }	thread - safely creates a copy of the items vector.
public static void connection closed ( ) { num connections . get and decrement ( ) ; }	informs system metrics of a connection closed event .
public static string build chat sdp ( string ip address , int local port , string protocol , string accept types , string wrapper types , string setup , string path , string direction ) { return build sdp ( ip address , local port , protocol , accept types , wrapper types , null , null , null , setup , path , direction , null , num ) ; }	build an sdp block for an one - 2 - one chat sessions.
int [ ] determine dimensions ( int source code words , int error correction code words ) throws writer exception { float ratio = num ; int [ ] dimension = null ; for ( int cols = min cols ; cols <= max cols ; cols ++ ) { int rows = calculate number of rows ( source code words , error correction code words , cols ) ; if ( rows < min rows ) { break ; } if ( rows > max rows ) { continue ; } float new ratio = ( ( num * cols + num ) * default module width ) / ( rows * height ) ; if ( dimension != null && math . abs ( new ratio - preferred ratio ) > math . abs ( ratio - preferred ratio ) ) { continue ; } ratio = new ratio ; dimension = new int [ ] { cols , rows } ; } if ( dimension == null ) { int rows = calculate number of rows ( source code words , error correction code words , min cols ) ; if ( rows < min rows ) { dimension = new int [ ] { min cols , min rows } ; } } if ( dimension == null ) { throw new writer exception ( str ) ; } return dimension ; }	determine optimal nr of columns and rows for the specified number of codewords .
private static void s ucumm ( sparse block a , double [ ] agg , double [ ] c , int m , int n , int rl , int ru ) { double [ ] cprod = ( agg != null ) ? agg : new double [ n ] ; if ( agg == null ) arrays . fill ( cprod , num ) ; int [ ] cnt = new int [ n ] ; for ( int i = rl , ix = rl * n ; i < ru ; i ++ , ix += n ) { if ( ! a . is empty ( i ) ) { int apos = a . pos ( i ) ; int alen = a . size ( i ) ; int [ ] aix = a . indexes ( i ) ; double [ ] avals = a . values ( i ) ; product agg ( avals , cprod , aix , apos , num , alen ) ; count agg ( avals , cnt , aix , apos , alen ) ; } for ( int j = num ; j < n ; j ++ ) if ( cnt [ j ] < i + num ) cprod [ j ] *= num ; system . arraycopy ( cprod , num , c , ix , n ) ; } }	cumprod , opcode : ucum * , sparse input .
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add ( new option ( str + str , str , num , str ) ) ; new vector . add all ( collections . list ( super . list options ( ) ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public static shopping cart item make item ( integer cart location , string item type , string item description , string product category id , big decimal base price , big decimal selected amount , big decimal quantity , map < string , object > attributes , string prod catalog id , shopping cart . shopping cart item group item group , local dispatcher dispatcher , shopping cart cart , boolean trigger external ops bool ) throws cart item modify exception { delegator delegator = cart . get delegator ( ) ; shopping cart item new item = new shopping cart item ( delegator , item type , item description , product category id , base price , attributes , prod catalog id , cart . get locale ( ) , item group ) ; if ( cart location == null ) { cart . add item to end ( new item ) ; } else { cart . add item ( cart location . int value ( ) , new item ) ; } boolean trigger external ops = trigger external ops bool == null ? bool : trigger external ops bool . boolean value ( ) ; try { new item . set quantity ( quantity , dispatcher , cart , trigger external ops ) ; } catch ( cart item modify exception e ) { cart . remove empty cart items ( ) ; throw e ; } if ( selected amount != null ) { new item . set selected amount ( selected amount ) ; } return new item ; }	makes a non - product shoppingcartitem and adds it to the cart . note : this is only for non - product items ; items without a product entity ( work items , bulk items , etc ).
private native synchronized static void hook method native ( member method , class < ? > declaring class , int slot , object additional info ) ;	intercept every call to the specified method and call a handler function instead .
private static cluster properties from properties ( properties props ) { cluster properties prop = new cluster properties ( ) ; prop . cluster name = get string property ( ignite cluster name , props , default cluster name ) ; prop . cpu per node = get double property ( ignite run cpu per node , props , default cpu per node ) ; prop . mem per node = get double property ( ignite memory per node , props , default mem per node ) ; prop . mem over head per node = get double property ( ignite memory overhead per node , props , math . max ( num * prop . mem per node , default minimum mem overhead per node ) ) ; prop . node cnt = get double property ( ignite node count , props , default ignite node count ) ; prop . ignite url = get string property ( ignite url , props , null ) ; prop . ignite path = get string property ( ignite path , props , null ) ; prop . licence path = get string property ( licence path , props , null ) ; prop . jvm opts = get string property ( ignite jvm opts , props , null ) ; prop . ignite work dir = get string property ( ignite working dir , props , default ignite work dir ) ; prop . ignite local work dir = get string property ( ignite local work dir , props , default ignite local work dir ) ; prop . ignite releases dir = get string property ( ignite releases dir , props , default ignite releases dir ) ; prop . ignite cfg = get string property ( ignite config xml , props , null ) ; prop . user libs = get string property ( ignite users libs , props , null ) ; string pattern = get string property ( ignite hostname constraint , props , null ) ; if ( pattern != null ) { try { prop . hostname constraint = pattern . compile ( pattern ) ; } catch ( pattern syntax exception e ) { log . log ( level . warning , str , e ) ; } } return prop ; }	instantiate a clusterproperties from a set of properties .
public static string generate native guid ( storage system device ) { return string . format ( str , device type map . get ( device . get system type ( ) ) , device . get serial number ( ) ) ; }	the format of this native guid is storagesystem + serialnumber.
public vector2 floor ( ) { x = ( float ) math . floor ( x ) ; z = ( float ) math . floor ( z ) ; return this ; }	rounds the x and y values of this vector2 down to the nearest integer value .
public static location create location ( final string raw json ) throws twitter exception { try { final json json = new json ( raw json ) ; return location constructor . new instance ( json ) ; } catch ( final instantiation exception e ) { throw new twitter exception ( e ) ; } catch ( final illegal access exception e ) { throw new assertion error ( e ) ; } catch ( final invocation target exception e ) { throw new twitter exception ( e ) ; } catch ( final json e ) { throw new twitter exception ( e ) ; } }	constructs a location object from rawjson string .
@ override protected int calc attack value ( ) { int av = num ; if ( b direct ) { av = math . min ( av + ( to hit . get mo s ( ) / num ) , av * num ) ; } if ( b glancing ) { av = ( int ) math . floor ( av / num ) ; } av = ( int ) math . floor ( get bracketing multiplier ( ) * av ) ; return av ; }	calculate the attack value based on range.
public void test write immutable ( ) { final i store = get store ( ) ; try { final int len = num ; final byte [ ] expected1 = new byte [ len ] ; r . next bytes ( expected1 ) ; final byte buffer tmp = byte buffer . wrap ( expected1 ) ; final long addr1 = store . write ( tmp ) ; assert equals ( len , tmp . position ( ) ) ; assert equals ( tmp . position ( ) , tmp . limit ( ) ) ; assert equals ( expected1 , store . read ( addr1 ) ) ; final byte [ ] expected2 = expected1 . clone ( ) ; r . next bytes ( expected1 ) ; assert equals ( expected2 , store . read ( addr1 ) ) ; } finally { store . destroy ( ) ; } }	test verifies that write does not permit changes to the store state by modifying the supplied buffer after the write operation ( i.
@ override public string query to retrieve data ( ) { string parameterized query ; if ( query . contains ( str ) ) { parameterized query = query . replace ( str , start row + str ) ; } else { parameterized query = query ; } return parameterized query ; }	this method replaces the parameters in query with actual values given by user . example of retrievequery : select * from % t where % p > % s batchsize % l ;.
public string to string ( ) { string classname = util . get unqualified name ( get class ( ) ) ; return ( ref == null ) ? classname : classname + str + ref . remote to string ( ) + str ; }	returns a string that represents the value of this remote object .
private static void initialise ( ) { hints hints = new hints ( hints . crs , crs . wg ) ; position factory position factory = geometry factory finder . get position factory ( hints ) ; geometry factory geometry factory = geometry factory finder . get geometry factory ( hints ) ; primitive factory primitive factory = geometry factory finder . get primitive factory ( hints ) ; aggregate factory aggregate factory = geometry factory finder . get aggregate factory ( hints ) ; wkt parser = new wkt ( geometry factory , primitive factory , position factory , aggregate factory ) ; wkt type list . add ( new wkt ( wkt point , bool , num , str , bool ) ) ; wkt type list . add ( new wkt ( wkt multipoint , bool , num , str , bool ) ) ; wkt type list . add ( new wkt ( wkt linestring , bool , num , str , bool ) ) ; wkt type list . add ( new wkt ( str , bool , num , str , bool ) ) ; wkt type list . add ( new wkt ( wkt multilinestring , bool , num , str , bool ) ) ; wkt type list . add ( new wkt ( wkt polygon , bool , - num , str , bool ) ) ; wkt type list . add ( new wkt ( wkt multipolygon , bool , - num , str , bool , bool ) ) ; for ( wkt wky type : wkt type list ) { wkt type map . put ( wky type . get name ( ) , wky type ) ; } }	initialise the wktparser object.
public instances prune to k ( instances neighbours , double [ ] distances , int k ) { if ( neighbours == null || distances == null || neighbours . num instances ( ) == num ) { return null ; } if ( k < num ) { k = num ; } int current k = num ; double current dist ; for ( int i = num ; i < neighbours . num instances ( ) ; i ++ ) { current k ++ ; current dist = distances [ i ] ; if ( current k > k && current dist != distances [ i - num ] ) { current k -- ; neighbours = new instances ( neighbours , num , current k ) ; break ; } } return neighbours ; }	prunes the list to contain the k nearest neighbors.
@ override protected string do in background ( string ... f url ) { int count ; input stream input = null ; output stream output = null ; try { url url = new url ( f url [ num ] ) ; url connection = url . open connection ( ) ; connection . connect ( ) ; int length of file = connection . get content length ( ) ; input = new buffered input stream ( url . open stream ( ) , num ) ; output = new file output stream ( f url [ num ] ) ; byte data [ ] = new byte [ num ] ; long total = num ; while ( ( count = input . read ( data ) ) != - num ) { total += count ; publish progress ( integer . to string ( ( int ) ( ( total * num ) / length of file ) ) ) ; output . write ( data , num , count ) ; } output . flush ( ) ; } catch ( exception e ) { log . e ( str , e . get message ( ) ) ; } finally { try { if ( output != null ) output . close ( ) ; } catch ( exception e ) { log . e ( str , e . get message ( ) ) ; } try { if ( input != null ) input . close ( ) ; } catch ( exception e ) { log . e ( str , e . get message ( ) ) ; } } return null ; }	downloading file in background thread.
public void error ( string msg ) { print ( str + msg , out . err ) ; }	print an error to printstream.
public static void load arm v7a library ( application like application like , string lib name ) { if ( lib name == null || lib name . is empty ( ) || application like == null ) { throw new tinker runtime exception ( str ) ; } if ( tinker application helper . is tinker enable for native lib ( application like ) ) { if ( tinker application helper . load library from tinker ( application like , str , lib name ) ) { return ; } } system . load library ( lib name ) ; }	only support auto load lib / armeabi - v7a library from patch . in some process , you may not want to install tinker and you can load patch dex and library without install tinker ! }.
atomic sequence ( final long initial value ) { updater . lazy set ( this , initial value ) ; }	create a sequence with a specified initial value .
public void key released ( key event e ) { if ( e . is shift down ( ) && e . get key code ( ) == next throttle key ) { request focus for next frame ( ) ; } else if ( e . is shift down ( ) && e . get key code ( ) == prev throttle key ) { request focus for previous frame ( ) ; } }	description of the method.
protected static long convert string to buckecting long ( string string to be converted ) { if ( string to be converted == null || string to be converted . equals ( str ) ) { return null ; } byte [ ] byte string = string to be converted . get bytes ( ) ; if ( byte string . length < num ) { byte [ ] new byte string = new byte [ num ] ; for ( int i = num ; i < new byte string . length ; i ++ ) { if ( i < byte string . length ) { new byte string [ i ] = byte string [ i ] ; } else { new byte string [ i ] = num ; } } byte string = new byte string ; } byte buffer bb = byte buffer . wrap ( byte string ) ; long byte method = bb . get long ( ) ; byte method = math . abs ( byte method ) ; return byte method ; }	converts a string into long values takes the first 8 bytes and uses those to convert them into long , if the string does not contain 8 bytes we pad them with zeros.
@ override public void close invoked ( ) { }	invoked when the connection receives the close request not used for now .
private void pending event ( event reg reg , id sid , item item , int transition , boolean copy item ) { if ( item != null && copy item ) item = copy item ( item ) ; new notifies . add ( new event task ( reg , sid , item , transition ) ) ; }	add a pending eventtask for this event registration .
public static void writeln ( string file name , object [ ] objects ) { if ( writer == null ) { create writer ( file name ) ; for ( object obj : objects ) { writeln ( obj . to string ( ) ) ; } close writer ( ) ; } }	writes an array of objects to a text file , each on a line .
protected double regression prediction ( instance transformed instance , boolean [ ] selected attributes , double [ ] coefficients ) throws exception { double result = num ; int column = num ; for ( int j = num ; j < transformed instance . num attributes ( ) ; j ++ ) { if ( ( m != j ) && ( selected attributes [ j ] ) ) { result += coefficients [ column ] * transformed instance . value ( j ) ; column ++ ; } } result += coefficients [ column ] ; return result ; }	calculate the dependent value for a given instance for a given regression model .
public qlf ( list < f > list , string docno , map < string , string > extra props ) { feature list = new memory local feature list < f > ( list ) ; iterator = list . iterator ( ) ; if ( extra props != null ) props . put all ( extra props ) ; props . put ( str , docno ) ; }	construct a new qlfdocument instance from the contents of the given feature list .
@ override protected template model invoke generic get ( map key map , class clazz , string key ) throws template model exception { map map = ( map ) object ; object val = map . get ( key ) ; if ( val == null ) { if ( key . length ( ) == num ) { character char key = character . value of ( key . char at ( num ) ) ; val = map . get ( char key ) ; if ( val == null && ! ( map . contains key ( key ) || map . contains key ( char key ) ) ) { return unknown ; } } else if ( ! map . contains key ( key ) ) { return unknown ; } } return wrap ( val ) ; }	overridden to invoke the generic get method by casting to map instead of through reflection - should yield better performance .
public byte [ ] to z ( final big integer big int ) { final int num dimensions = datatype config . get num dimensions ( ) ; final byte [ ] big int as byte arr = big int . to byte array ( ) ; final int padded array size = num dimensions * base size + num ; final byte [ ] big int as byte arr pad = new byte [ padded array size ] ; int idx = num ; for ( int i = num ; i < padded array size - big int as byte arr . length ; i ++ ) { big int as byte arr pad [ idx ++ ] = num ; } for ( int i = num ; i < big int as byte arr . length ; i ++ ) { big int as byte arr pad [ idx ++ ] = big int as byte arr [ i ] ; } final byte [ ] big int as byte arr unsigned = unpad leading zero ( big int as byte arr pad ) ; return big int as byte arr unsigned ; }	decodes a biginteger into a zorder byte [ ] ( without leading zero ).
public void clear logcat ( @ not null i device , @ not null project project ) { synchronized ( my lock ) { executor service executor = my executors . get ( device ) ; if ( executor != null ) { stop receiving ( device ) ; executor . submit ( null ) ; start receiving ( device ) ; } } }	clears logs for the current device .
private string set discover volume snaps ( storage system system , list < snap > snaps , string parent guid , string set parent matched v , vn api client , db client db client , map < string , list < un managed volume > > host volumes map , vn lun , boolean is snap in cg , string cg name ) throws exception { string set snapsets = new string set ( ) ; for ( snap snap detail : snaps ) { un managed volume un managed volume = null ; string managed snap native guid = guid . generate native guid for volume or block snap shot ( system . get native guid ( ) , snap detail . get id ( ) ) ; block snapshot vipr snap = discovery utils . check block snapshot exists in db ( db client , managed snap native guid ) ; if ( null != vipr snap ) { log . info ( str , managed snap native guid ) ; snapsets . add ( managed snap native guid ) ; continue ; } string un managed volume natvie guid = guid . generate native guid for pre existing volume ( system . get native guid ( ) , snap detail . get id ( ) ) ; un managed volume = discovery utils . check un managed volume exists in db ( db client , un managed volume natvie guid ) ; un managed volume = create un managed volume for snap ( un managed volume , un managed volume natvie guid , lun , system , db client , host volumes map , snap detail ) ; populate snap info ( un managed volume , snap detail , parent guid , parent matched v ) ; snapsets . add ( un managed volume natvie guid ) ; un managed volumes returned from provider . add ( un managed volume . get id ( ) ) ; if ( is snap in cg ) { add object to un managed consistency group ( api client , un managed volume , cg name , system , db client ) ; } } return snapsets ; }	discover lun snaps , and create unmanagedvolume for the snaps.
public void receive ( final call event event ) { if ( event . is valid ( ) ) { if ( ! m events . contains ( event ) ) { m events . add ( num , event ) ; fire table rows inserted ( num , num ) ; prune ( ) ; } else { int row = m events . index of ( event ) ; fire table rows updated ( row , row ) ; } } else { if ( m events . contains ( event ) ) { int row = m events . index of ( event ) ; m events . remove ( event ) ; fire table rows deleted ( row , row ) ; } } }	adds , updates or deletes the event from the model.
public pet find one ( string id ) { log . debug ( str , id ) ; pet pet = pet repository . find one ( uuid . from string ( id ) ) ; return pet ; }	get one pet by id .
public final void clear ( ) { m active issues . clear ( ) ; }	clears all the issues for this health check .
public static void await data ready ( ) { synchronized ( m db helper lock ) { if ( m db helper == null ) { try { m db helper lock . wait ( ) ; } catch ( interrupted exception e ) { e . print stack trace ( ) ; } } } }	this method blocks until the underlying data store is ready.
protected abstract io session ( io service service ) { this . service = service ; this . handler = service . get handler ( ) ; long current time = system . current time millis ( ) ; creation time = current time ; last throughput calculation time = current time ; last read time = current time ; last write time = current time ; last idle time for both = current time ; last idle time for read = current time ; last idle time for write = current time ; close future . add listener ( scheduled counter resetter ) ; session id = id generator . increment and get ( ) ; }	todo add method documentation.
private string process float token ( string token ) { string result = token . replace all ( group separator , str ) ; if ( ! decimal separator . equals ( str ) ) result = result . replace all ( decimal separator , str ) ; boolean is negative = bool ; int pre len = negative prefix . length ( ) ; if ( ( pre len > num ) && result . starts with ( negative prefix ) ) { is negative = bool ; result = result . substring ( pre len ) ; } int suf len = negative suffix . length ( ) ; if ( ( suf len > num ) && result . ends with ( negative suffix ) ) { is negative = bool ; result = result . substring ( result . length ( ) - suf len , result . length ( ) ) ; } if ( result . equals ( nan string ) ) result = str ; if ( result . equals ( infinity string ) ) result = str ; if ( is negative ) result = str + result ; matcher m = non ascii digit . matcher ( result ) ; if ( m . find ( ) ) { string builder in ascii = new string builder ( ) ; for ( int i = num ; i < result . length ( ) ; i ++ ) { char next char = result . char at ( i ) ; if ( character . is digit ( next char ) ) { int d = character . digit ( next char , num ) ; if ( d != - num ) in ascii . append ( d ) ; else in ascii . append ( next char ) ; } else { in ascii . append ( next char ) ; } } result = in ascii . to string ( ) ; } return result ; }	the float token must be stripped of prefixes , group separators , and suffixes , non ascii digits must be converted into ascii digits before parsefloat will accept it.
internal window ( string title ) { set layout ( new border layout ( ) ) ; title bar = new title bar ( ) ; add ( title bar , border layout . north ) ; title bar . set layout ( new s ( s . horizontal , titlebar padding ) ) ; title label = new j ( ) ; set title ( title ) ; title label . set minimum size ( new dimension ( num , num ) ) ; title bar . add ( title label ) ; s . add spring ( title bar ) ; minimize button = new j ( minimize icon ) ; minimize button . set margin ( new insets ( num , num , num , num ) ) ; minimize button . set border ( border factory . create empty border ( ) ) ; minimize button . set focusable ( bool ) ; minimize button . add action listener ( new minimize listener ( ) ) ; title bar . add ( minimize button ) ; close button = new j ( close icon ) ; close button . set margin ( new insets ( num , num , num , num ) ) ; close button . set border ( border factory . create empty border ( ) ) ; close button . set focusable ( bool ) ; close button . add action listener ( new close action listener ( ) ) ; title bar . add ( close button ) ; cache = new component paint cache ( this ) ; }	create a new internalwindow .
@ suppress warnings ( str ) public static map < string , object > load stream ( input stream input stream ) { log . fine ( str ) ; yaml yaml = new yaml ( ) ; map < object , object > props yaml = ( map < object , object > ) yaml . load ( input stream ) ; log . fine ( str ) ; map < string , object > typed map = new hash map < > ( ) ; for ( object key : props yaml . key set ( ) ) { typed map . put ( key . to string ( ) , props yaml . get ( key ) ) ; } return typed map ; }	load config from the given yaml stream.
string [ ] split ( final string string to split ) { if ( string utils . is not blank ( string to split ) ) { int str lenght = string to split . length ( ) ; int split num = str lenght / chunk size ; if ( str lenght % chunk size > num ) { split num += num ; } string [ ] result = new string [ split num ] ; for ( int i = num ; i < split num ; i ++ ) { int start pos = i * chunk size ; int end pos = start pos + chunk size ; if ( end pos > str lenght ) { end pos = str lenght ; } result [ i ] = string to split . substring ( start pos , end pos ) ; } return result ; } return null ; }	split string to chunks by size .
public void log velocity message ( int level , string message ) { synchronized ( this ) { object [ ] data = new object [ num ] ; data [ num ] = new integer ( level ) ; data [ num ] = message ; pending messages . add element ( data ) ; } }	logs messages . all we do is store them until ' later ' .
public void test shift right neg non zeroes ( ) { byte a bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , num , num , num , num , num , num , num } ; int a sign = - num ; int number = num ; byte r bytes [ ] = { - num , - num , num , - num , num , - num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . shift right ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , result . signum ( ) ) ; }	shiftright a negative number ; shift distance is not multiple of 32 ; shifted bits are not zeroes .
public void remove all addresses ( ) { addresses . clear ( ) ; }	removes all addresses from this user.
public static boolean is show tooltips ( ) { return show tooltips ; }	indicates whether tooltips should be shown when the keys in the vkb are pressed.
public static boolean is property field ( string field name ) { return ! id field name . equals ( field name ) && ! uri field name . equals ( field name ) && ! text field name . equals ( field name ) && ! context field name . equals ( field name ) && field name . char at ( num ) != str ; }	determines whether the specified field name is a property field name .
public static void check access ( int modifiers ) { if ( system . get security manager ( ) != null && ! modifier . is public ( modifiers ) ) { throw new security exception ( str ) ; } }	utility method that throws securityexception if securitymanager is set and modifiers are not public.
protected void print indent ( string builder ddl ) { ddl . append ( get indent ( ) ) ; }	prints the characters used to indent sql .
public n merge ( n a , n b ) throws merge failed { if ( a != null && b == null ) return a ; if ( a == null && b != null ) return b ; if ( a == null && b == null ) return null ; if ( a . equals ( b ) ) return a ; try { return dispatcher . dispatch ( get class ( ) , this , str , a , b ) ; } catch ( no such method exception e ) { throw new merge failed ( str , a , b ) ; } }	merge a and b .
public static string format ( string s , string col ) { string s1 = ( s + padd ) ; return s1 . substring ( num , math . min ( col . length ( ) , s1 . length ( ) ) ) ; }	pad a string from right .
protected static void load end ( m info , hash map lookup ) { if ( info . is validated && lookup . size ( ) > num ) s loaded lookups . put ( get key ( info ) , lookup ) ; }	mlookup loader ends loading , so add it to cache.
public static void info ( final string message ) { info logger . accept ( message ) ; }	logs a message to the configured info logger .
private void check no characters missing ( int total length , list < token > tokens ) { if ( ! tokens . is empty ( ) && tokens . get ( tokens . size ( ) - num ) . right != total length ) { string error = string . format ( str , tokens . get ( tokens . size ( ) - num ) . right , total length ) ; throw new runtime exception ( error ) ; } int start = num ; for ( int i = num ; i < tokens . size ( ) ; i ++ ) { token token = tokens . get ( i ) ; if ( token . left != start ) { throw new runtime exception ( str + start ) ; } start = token . right ; } }	temporary debugging code . we need to tokenize every character in the input string .
public boolean validate service attributes ( string token , string validator class , set values ) throws sms , sso , remote exception { initialize ( ) ; if ( debug . message enabled ( ) ) { debug . message ( str + validator class + str + values ) ; } try { class clazz = class . for name ( validator class ) ; service attribute validator v = ( service attribute validator ) clazz . new instance ( ) ; return v . validate ( values ) ; } catch ( instantiation exception ex ) { throw new sms ( str ) ; } catch ( illegal access exception ex ) { throw new sms ( str ) ; } catch ( class not found exception ex ) { throw new sms ( str ) ; } }	validates service configuration attributes .
public synchronized void animate pan to ( d p , long duration ) { d pp = new d . double ( ) ; m itransform . transform ( p , pp ) ; animate pan to abs ( pp , duration ) ; }	animate a pan to the specified location in screen ( pixel ) co - ordinates using the provided duration .
public static void assert equals with relative error or both na n ( string message , double expected , double actual ) { if ( expected == actual ) { return ; } if ( double . is na n ( expected ) && ! double . is na n ( actual ) ) { throw new assertion failed error ( message + str + expected + str + actual + str ) ; } if ( ! double . is na n ( expected ) && double . is na n ( actual ) ) { throw new assertion failed error ( message + str + expected + str + actual + str ) ; } double relative error ; if ( math . abs ( actual ) > math . abs ( expected ) ) { relative error = math . abs ( ( expected - actual ) / actual ) ; } else { relative error = math . abs ( ( expected - actual ) / expected ) ; } if ( relative error > max relative error ) { throw new assertion failed error ( message + str + expected + str + actual + str ) ; } }	attention : does not work with values near 0 ! !.
protected void assert exception ( final abstract exception case exception case ) throws throwable { assert exception ( exception case , null ) ; }	checks that code block throw corresponding exception .
@ override public service host start ( ) throws throwable { super . start ( ) ; start default core services synchronously ( ) ; super . start service ( new root namespace service ( ) ) ; super . start service ( new sample service with shared custom ui ( ) ) ; super . start service ( new sample factory service with custom ui ( ) ) ; super . start factory ( new sample simple echo service ( ) ) ; super . start factory ( new sample previous echo service ( ) ) ; super . start factory ( new example service ( ) ) ; super . start factory ( new example task service ( ) ) ; super . start service ( new ui service ( ) ) ; start swagger descriptor service ( ) ; return this ; }	start services : a host can run multiple services .
@ override public void end of stream ( ) throws ade exception { for ( msg data data : m msg data . values ( ) ) { if ( data . m total log counts > num ) { data . m lambda = data . m total log counts / data . m interval count ; m min lambda = math . min ( data . m lambda , m min lambda ) ; if ( locate mismatching distributions ( data ) ) { data . m bad fit = bool ; } } } m trained = bool ; }	at the end of the stream , for all the message data we ' ve collected , we calculate the lamba value and determine if the message data is a " bad fit " i.
static binary tree < integer > build complete ( int n ) { binary tree < integer > bt = new binary tree < integer > ( ) ; int b = ( int ) math . pow ( num , n - num ) ; for ( int i = num ; i < n ; i ++ ) { bt . insert ( b ) ; for ( int j = num ; j <= math . pow ( num , i ) - num ; j ++ ) { bt . insert ( b + num * b * j ) ; } b = b / num ; } return bt ; }	build a complete tree with 2 ^ n - 1 nodes .
public void erase ( ) { byte [ ] bytes = null ; for ( byte buffer buffer : buffers ) { if ( bytes == null || bytes . length < buffer . limit ( ) ) bytes = new byte [ buffer . limit ( ) ] ; buffer . position ( num ) ; buffer . put ( bytes , num , buffer . limit ( ) ) ; buffer . position ( num ) ; } }	erase file by setting all bytes to 0.
public void log purchase ( big decimal purchase amount , currency currency , bundle parameters ) { if ( purchase amount == null ) { notify developer error ( str ) ; return ; } else if ( currency == null ) { notify developer error ( str ) ; return ; } if ( parameters == null ) { parameters = new bundle ( ) ; } parameters . put string ( app events constants . event param currency , currency . get currency code ( ) ) ; log event ( app events constants . event name purchased , purchase amount . double value ( ) , parameters ) ; eager flush ( ) ; }	logs a purchase event with facebook , in the specified amount and with the specified currency.
public static string pad between ( final string first , final int length , final string last ) { final int padlen = length - ( first . length ( ) + last . length ( ) ) ; return first + ( padlen > num ? get space string ( padlen ) : str ) + last ; }	pads out two string by inserting spaces between them .
public void apply from resolve info ( package manager pm , resolve info info , widget preview loader loader ) { m info = info ; char sequence label = info . load label ( pm ) ; m widget name . set text ( label ) ; m widget dims . set text ( string . format ( m dimensions format string , num , num ) ) ; m widget preview loader = loader ; }	apply the resolve info to the view .
private queue connection impl create new primary ( set excluded servers ) { queue connection impl primary = null ; while ( primary == null && pool . get pool or cache cancel in progress ( ) == null ) { list servers = find queue servers ( excluded servers , num , bool , print primary not found error , localized strings . could not find server to create primary client queue ) ; print primary not found error = bool ; if ( servers == null || servers . is empty ( ) ) { break ; } connection connection = null ; try { connection = factory . create client to server connection ( ( server location ) servers . get ( num ) , bool ) ; } catch ( gem fire security exception e ) { throw e ; } catch ( exception e ) { if ( logger . is debug enabled ( ) ) { logger . debug ( str , servers . get ( num ) ) ; } } if ( connection != null ) { primary = initialize queue connection ( connection , bool , queue connections . get failed updater ( ) ) ; } excluded servers . add all ( servers ) ; } if ( primary != null && sent client ready && primary . send client ready ( ) ) { ready for events after failover ( primary ) ; } return primary ; }	create a new primary server from a non - redundant server.
public static int read int ( ) { return scanner . next int ( ) ; }	reads the next token from standard input , parses it as an integer , and returns the integer .
public csv guess ( ) { try { buffered reader b in = new buffered reader ( new input stream reader ( get input stream ( ) , standard charsets . utf 8 ) ) ; string [ ] lines = new string [ num ] ; string line = null ; int counter = num ; while ( ( line = b in . read line ( ) ) != null && counter <= num ) { lines [ counter ] = line ; counter ++ ; } if ( counter < num ) { string [ ] new lines = new string [ counter ] ; system . arraycopy ( lines , num , new lines , num , counter ) ; lines = new lines ; } analyse lines ( lines ) ; } catch ( exception e ) { e . print stack trace ( ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( exception e ) { } } } csv conf = config ; config = null ; return conf ; }	guess the config based on the first 10 ( or less when less available ) records of a csv file .
private void update design ( data set design data set design , i conn , string query text ) throws oda exception { i query = conn . new query ( null ) ; query . prepare ( query text ) ; query . set property ( query . prop setup query text , get setup query text ( ) ) ; try { i md = query . get meta data ( ) ; update result set design ( md , data set design ) ; } catch ( oda exception e ) { data set design . set result sets ( null ) ; e . print stack trace ( ) ; } try { i param md = query . get parameter meta data ( ) ; update parameter design ( param md , data set design ) ; } catch ( oda exception ex ) { data set design . set parameters ( null ) ; ex . print stack trace ( ) ; } }	updates the given datasetdesign with the querytext and its derived metadata obtained from the oda runtime connection .
public void run test ( ) throws throwable { document doc ; node list element list ; node name node ; character data child ; string bad substring ; doc = ( document ) load ( str , bool ) ; element list = doc . get elements by tag name ( str ) ; name node = element list . item ( num ) ; child = ( character data ) name node . get first child ( ) ; { boolean success = bool ; try { bad substring = child . substring data ( num , - num ) ; } catch ( dom ex ) { success = ( ex . code == dom . index size err ) ; } assert true ( str , success ) ; } }	runs the test case .
public static string to string ( json jo ) throws json { string buffer sb = new string buffer ( ) ; sb . append ( escape ( jo . get string ( str ) ) ) ; sb . append ( str ) ; sb . append ( escape ( jo . get string ( str ) ) ) ; if ( jo . has ( str ) ) { sb . append ( str ) ; sb . append ( jo . get string ( str ) ) ; } if ( jo . has ( str ) ) { sb . append ( str ) ; sb . append ( escape ( jo . get string ( str ) ) ) ; } if ( jo . has ( str ) ) { sb . append ( str ) ; sb . append ( escape ( jo . get string ( str ) ) ) ; } if ( jo . opt boolean ( str ) ) { sb . append ( str ) ; } return sb . to string ( ) ; }	convert a jsonobject into a cookie specification string.
@ override public boolean equals ( object other rule ) { if ( other rule == this ) { return bool ; } if ( other rule instanceof zone offset transition rule ) { zone offset transition rule other = ( zone offset transition rule ) other rule ; return month == other . month && dom == other . dom && dow == other . dow && time definition == other . time definition && time . equals ( other . time ) && time end of day == other . time end of day && standard offset . equals ( other . standard offset ) && offset before . equals ( other . offset before ) && offset after . equals ( other . offset after ) ; } return bool ; }	checks if this object equals another.
private void initialize membership matrix ( ) { for ( int i = num ; i < points . size ( ) ; i ++ ) { for ( int j = num ; j < k ; j ++ ) { membership matrix [ i ] [ j ] = random . next double ( ) ; } membership matrix [ i ] = math arrays . normalize array ( membership matrix [ i ] , num ) ; } }	initialize the membership matrix with random values .
public static void write all ( output stream stream , object [ ] o ) throws exception { object output stream oos ; int i ; if ( ! ( stream instanceof buffered output stream ) ) { stream = new buffered output stream ( stream ) ; } oos = new object output stream ( stream ) ; for ( i = num ; i < o . length ; i ++ ) { oos . write object ( o [ i ] ) ; } oos . flush ( ) ; oos . close ( ) ; }	serializes the given objects to the specified stream .
public synchronized void reset ( ) { m buf vertices . position ( num ) ; m buf colors . position ( num ) ; if ( draw texture ) { m buf tex coords . position ( num ) ; } for ( int i = num ; i < num ; ++ i ) { vertex tmp = m arr temp vertices . get ( num ) ; tmp . set ( m rectangle [ i ] ) ; if ( m flip texture ) { tmp . m tex x *= m texture rect back . right ; tmp . m tex y *= m texture rect back . bottom ; tmp . m color = m texture page . get color ( curl page . side back ) ; } else { tmp . m tex x *= m texture rect front . right ; tmp . m tex y *= m texture rect front . bottom ; tmp . m color = m texture page . get color ( curl page . side front ) ; } add vertex ( tmp ) ; } m vertices count front = num ; m vertices count back = num ; m buf vertices . position ( num ) ; m buf colors . position ( num ) ; if ( draw texture ) { m buf tex coords . position ( num ) ; } m drop shadow count = m self shadow count = num ; }	resets mesh to ' initial ' state.
public b css ( @ non nls string classes ) { return css ( classes , null ) ; }	sets the css classes for the last added element .
public static argument exception adapt property exception ( property exception e , abstract managed object definition < ? , ? > d ) { return new argument exception ( e . get message object ( ) ) ; }	creates an argument exception from a property exception .
private consumer < operation > create notification target ( ) { return null ; }	this creates a lambda to receive notifications.
public void write ( byte [ ] bytes ) throws io { data output . write ( bytes ) ; offset += bytes . length ; }	writes a byte array completely .
static synchronized boolean is shaping supported ( ) { if ( is shaping supported == null ) { x . awt lock ( ) ; try { is shaping supported = xlib wrapper . x ( x . get display ( ) , xlib wrapper . larg1 , xlib wrapper . larg2 ) ; } finally { x . awt unlock ( ) ; } } return is shaping supported . boolean value ( ) ; }	returns whether the xshape extension available.
private boolean is id char ( int ch ) { return is alpha ( ch ) || is digit ( ch ) || ch == str || ch == str || ch == str || ch == str || character . is letter ( ch ) ; }	from html 4 . 0 [ 4 ] namechar : : = letter | digit | ' . ' | ' - ' | ' _ ' | ' : ' | combiningchar | extender [ 5 ] name : : = ( letter | ' _ ' | ' : ' ) ( namechar ) [ 6 ] names : : = name ( # x20 name ) [ 7 ] nmtoken : : = ( namechar ) + [ 8 ] nmtokens : : = nmtoken ( # x20 nmtoken ).
protected string handle timeseal ( string text ) throws io { string result = text ; if ( log . is debug enabled ( ) ) log . debug ( str + result ) ; while ( result . contains ( str ) ) { send ack ( ) ; result = result . replace first ( str , str ) ; if ( log . is debug enabled ( ) ) log . debug ( str + result ) ; } if ( log . is debug enabled ( ) ) log . debug ( str + result ) ; return result ; }	handles sending the timeseal ack .
protected location handler ( location location , option ... options ) { this . location = location ; this . options = options . length == num ? enum set . none of ( option . class ) : enum set . copy of ( arrays . as list ( options ) ) ; }	create a handler . the location and options provide a way to map from a location or an option to the corresponding handler .
private void init ( ) { logger . debug ( str ) ; list = new concurrent linked queue < arrived indication > ( ) ; intermediate processor intermediate processor = new intermediate processor ( list , processor ) ; indication process timer = executors . new single thread scheduled executor ( ) ; indication process timer . schedule with fixed delay ( intermediate processor , cim . indication process interval , periodic delay , time unit . seconds ) ; }	will get called during construction phase , configured through spring xml configuration.
public static final string long to hex string ( long a ) { string buffer sb = new string buffer ( num ) ; for ( int i = num ; i < num ; i ++ ) sb . append ( nibble [ ( int ) ( a > > > ( num - num * i ) ) & num ] ) ; return sb . to string ( ) ; }	convert a long to a string of hexadecimal digits .
private date watch core start at ( solr server client , final long timeout , final date min ) throws interrupted exception , io , solr server exception { final long sleep interval = num ; long time slept = num ; solr params p = params ( str , str , str , str ) ; while ( time slept < timeout ) { query request req = new query request ( p ) ; req . set path ( str ) ; try { named list data = client . request ( req ) ; for ( string k : new string [ ] { str , str } ) { object o = data . get ( k ) ; assert not null ( str + k , o ) ; data = ( named list ) o ; } date start time = ( date ) data . get ( str ) ; assert not null ( str , start time ) ; if ( null == min || start time . after ( min ) ) { return start time ; } } catch ( solr exception e ) { if ( num != e . code ( ) ) { throw e ; } } time slept += sleep interval ; thread . sleep ( sleep interval ) ; } fail ( str + min ) ; return min ; }	polls the solrcore stats using the specified client until the " starttime " time for collection is after the specified " min ".
@ override public params request condition combine ( params request condition other ) { set < param expression > set = new linked hash set < > ( this . expressions ) ; set . add all ( other . expressions ) ; return new params request condition ( set ) ; }	returns a new instance with the union of the param expressions from " this " and the " other " instance .
@ override public boolean equals ( object obj ) { if ( obj == this ) { return bool ; } if ( ! ( obj instanceof time series collection ) ) { return bool ; } time series collection that = ( time series collection ) obj ; if ( this . x position != that . x position ) { return bool ; } if ( this . domain is points in time != that . domain is points in time ) { return bool ; } if ( ! object utilities . equal ( this . data , that . data ) ) { return bool ; } return bool ; }	tests this time series collection for equality with another object .
private void parse rules ( attributes attributes ) { start mode = get mode attribute ( attributes , str ) ; if ( start mode == null ) { start mode = lookup create mode ( implicit mode name ) ; md . current mode = start mode ; start mode . note defined ( null ) ; } start mode . note used ( locator ) ; if ( attributes schema ) { mode wrapper = lookup create mode ( wrapper mode name ) ; action set actions = new action set ( ) ; actions . add no result action ( new allow action ( new mode usage ( start mode , start mode ) ) ) ; wrapper . bind element ( namespace specification . any namespace , namespace specification . default wildcard , actions ) ; wrapper . note defined ( null ) ; start mode = wrapper ; } default schema type = get schema type ( attributes ) ; }	parse the rules element . initializes the start mode the current mode the defaultschematype.
public void fill ( byte value ) { value &= num ; arrays . fill ( data , ( byte ) ( value << num | value ) ) ; }	fill the nibble array with the specified value .
private static void parse ( input stream in , encoding encoding , content handler content handler ) throws io , sax { try { xml reader = new expat reader ( ) ; reader . set content handler ( content handler ) ; input source source = new input source ( in ) ; source . set encoding ( encoding . expat name ) ; reader . parse ( source ) ; } catch ( io e ) { throw new assertion error ( e ) ; } }	parses xml from the given input stream and fires events on the given sax handler .
@ override public list < foo > find by field2 ( boolean field2 ) { return find by field2 ( field2 , query util . all pos , query util . all pos , null ) ; }	returns all the foos where field2 = & # 63 ; .
public void add to associated ( message as message ) { associated messages . add ( as message ) ; }	adding a message as associated to this message.
private static void parse property assignments ( properties p , string [ ] assignments ) { for ( string assignment : assignments ) { int split = assignment . index of ( str ) ; string key = assignment . substring ( num , split ) ; string value = assignment . substring ( split + num ) ; p . put ( key , value ) ; } }	adds each element of ' assignments ' to ' p ' , treating each element as an assignment in the form " key = value " .
public static search scope value of ( final int int value ) { search scope result = null ; if ( num <= int value && int value < elements . length ) { result = elements [ int value ] ; } if ( result == null ) { result = new search scope ( int value , str + int value + str , enum . unknown ) ; } return result ; }	returns the search scope having the specified integer value as defined in rfc 4511 section 4.
public static i add class folder ( i jproject , string container name , i source attach path , i source attach root ) throws core exception { i project = jproject . get project ( ) ; i container = null ; if ( container name == null || container name . length ( ) == num ) { container = project ; } else { i folder = project . get folder ( container name ) ; if ( ! folder . exists ( ) ) { core utility . create folder ( folder , bool , bool , null ) ; } container = folder ; } i cpe = java core . new library entry ( container . get full path ( ) , source attach path , source attach root ) ; add to classpath ( jproject , cpe ) ; return jproject . get package fragment root ( container ) ; }	creates and adds a class folder to the class path .
private void previous window ( calendar start time ) { if ( is daily ( ) ) { start time . add ( calendar . day of month , - num ) ; } else if ( is weekly ( ) ) { start time . add ( calendar . week of month , - num ) ; } else if ( is monthly ( ) ) { int month = start time . get ( calendar . month ) ; adjust day of month ( start time , month + - num ) ; } }	changes to the previous window start time .
private < t > t [ ] copy elements ( t [ ] a ) { if ( head < tail ) { system . arraycopy ( elements , head , a , num , size ( ) ) ; } else if ( head > tail ) { int head portion len = elements . length - head ; system . arraycopy ( elements , head , a , num , head portion len ) ; system . arraycopy ( elements , num , a , head portion len , tail ) ; } return a ; }	copies the elements from our element array into the specified array , in order ( from first to last element in the deque ).
abstract void execute on handler task ( runnable task ) ;	wakes up a thread waiting for i / o events to execute the given task .
public instance calc pivot ( my idx list list1 , my idx list list2 , instances insts ) { int class idx = m . class index ( ) ; double [ ] attr vals = new double [ insts . num attributes ( ) ] ; instance temp ; for ( int i = num ; i < list1 . length ( ) ; i ++ ) { temp = insts . instance ( list1 . get ( i ) . idx ) ; for ( int k = num ; k < temp . num values ( ) ; k ++ ) { if ( temp . index ( k ) == class idx ) { continue ; } attr vals [ k ] += temp . value sparse ( k ) ; } } for ( int j = num ; j < list2 . length ( ) ; j ++ ) { temp = insts . instance ( list2 . get ( j ) . idx ) ; for ( int k = num ; k < temp . num values ( ) ; k ++ ) { if ( temp . index ( k ) == class idx ) { continue ; } attr vals [ k ] += temp . value sparse ( k ) ; } } for ( int j = num , num insts = list1 . length ( ) + list2 . length ( ) ; j < attr vals . length ; j ++ ) { attr vals [ j ] /= num insts ; } temp = new dense instance ( num , attr vals ) ; return temp ; }	calculates the centroid pivot of a node based on the list of points that it contains ( tbe two lists of its children are provided ) .
default optional < list < t > > parse optional ( byte [ ] parse message ) { return optional . of nullable ( parse ( parse message ) ) ; }	take raw data and convert it to an optional list of messages .
public static void initialize for client use ( ) { embedded utils . initialize for client use ( ) ; }	initialises opendj for client use , used by the cli tools.
public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str + str + str + str + str + str + str + str + str , str , num , str ) ) ; new vector . add all ( collections . list ( super . list options ( ) ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public void add all ( @ non null list < t > item list ) { synchronized ( lock ) { if ( items == null ) { items = new array list < > ( ) ; } items . add all ( item list ) ; } if ( notify on change ) { if ( items . size ( ) - item list . size ( ) != num ) { notify item range changed ( items . size ( ) - item list . size ( ) , item list . size ( ) ) ; } else { notify data set changed ( ) ; } } }	adds all the specified items to the list.
public void write ( int a ) throws io { outs . write ( a ) ; position ++ ; }	write a single byte.
public void test insert1 ( ) throws sql { database creator . fill parent table ( conn ) ; database creator . fill fk ( conn ) ; database creator . fill fk ( conn ) ; statement . execute ( str + database creator . fkstrict table + str ) ; statement . execute ( str + database creator . fkcascade table + str ) ; }	insertfunctionalitytest # testinsert1 ( ) . attempts to insert row into table with integrity checking.
public boolean is starts with mode ( ) { return starts with mode ; }	when enabled this makes the filter check that the string starts with rather than within the index.
public builder with threads ( int threads ) { properties . set property ( netty options . threads , string . value of ( assert . arg not ( threads , threads <= num , str ) ) ) ; return this ; }	sets the number of netty event loop threads .
public void paint tabbed pane tab area background ( synth context context , graphics g , int x , int y , int w , int h , int orientation ) { if ( orientation == j . left ) { affine transform transform = new affine transform ( ) ; transform . scale ( - num , num ) ; transform . rotate ( math . to radians ( num ) ) ; paint background ( context , g , y , x , h , w , transform ) ; } else if ( orientation == j . right ) { affine transform transform = new affine transform ( ) ; transform . rotate ( math . to radians ( num ) ) ; transform . translate ( num , - ( x + w ) ) ; paint background ( context , g , y , num , h , w , transform ) ; } else if ( orientation == j . bottom ) { affine transform transform = new affine transform ( ) ; transform . translate ( x , y ) ; paint background ( context , g , num , num , w , h , transform ) ; } else { paint background ( context , g , x , y , w , h , null ) ; } }	paints the background of the area behind the tabs of a tabbed pane.
@ override public void end cdata ( augmentations augs ) throws xni { try { if ( f lexical handler != null ) { f lexical handler . end cdata ( ) ; } } catch ( sax e ) { throw new xni ( e ) ; } }	the end of a cdata section .
public static media locator create media locator ( string url ) { media locator ml ; if ( url . index of ( str ) > num && ( ml = new media locator ( url ) ) != null ) return ml ; if ( url . starts with ( file . separator ) ) { if ( ( ml = new media locator ( str + url ) ) != null ) return ml ; } else { string file = str + system . get property ( str ) + file . separator + url ; if ( ( ml = new media locator ( file ) ) != null ) return ml ; } return null ; }	create a media locator from the given location .
private static void invoke remote clear and wait ( vm remote vm , vm this vm ) { remote vm . invoke ( null ) ; try { clear latch . await ( ) ; } catch ( interrupted exception e ) { fail ( str ) ; } }	this method clears the region and notifies the other member when complete.
public void key ( string skey ) throws sq . exception { synchronized ( this ) { byte ekey [ ] = null ; if ( skey != null && skey . length ( ) > num ) { ekey = new byte [ skey . length ( ) ] ; for ( int i = num ; i < skey . length ( ) ; i ++ ) { char c = skey . char at ( i ) ; ekey [ i ] = ( byte ) ( ( c & num ) ^ ( c > > num ) ) ; } } key ( ekey ) ; } }	specify key for encrypted database.
public void test shared test data ( ) throws exception { assert equals ( test sql date , date . value of ( test local date ) ) ; assert equals ( test sql time , time . value of ( test local time ) ) ; assert equals ( test sql time stamp , timestamp . value of ( test local date time ) ) ; assert equals ( test local date , test sql date . to local date ( ) ) ; assert equals ( test local time , test sql time . to local time ( ) ) ; assert equals ( test local date time , test sql time stamp . to local date time ( ) ) ; }	test shared test data validity .
public void characters ( char ch [ ] , int start , int length ) { if ( title pending ) { title . append ( ch , start , length ) ; } else if ( desc pending ) { desc . append ( ch , start , length ) ; } }	the contents of an xml elt.
private void close injector resource ( shard id shard id , injector shard injector , class < ? extends closeable > ... to close ) { for ( class < ? extends closeable > closeable : to close ) { if ( close injector optional resource ( shard id , shard injector , closeable ) == bool ) { logger . warn ( str , shard id , closeable . get simple name ( ) ) ; } } }	this method gets an instance for each of the given classes passed and calls # close ( ) on the returned instance . note : this method swallows all exceptions thrown from the close method of the injector and logs them as debug log.
public final void increment id counter to ( int id ) { int diff = id - m id counter . get ( ) ; if ( diff < num ) return ; m id counter . add and get ( diff ) ; update shared preference ( ) ; }	ensures the counter is at least as high as the specified value.
private static int clear branding resource map cache ( content resolver cr , long provider id ) { string builder where = new string builder ( ) ; where . append ( imps . branding resource map cache . provider id ) ; where . append ( str ) ; where . append ( provider id ) ; return cr . delete ( imps . branding resource map cache . content uri , where . to string ( ) , null ) ; }	clear the branding resource map cache .
public byte [ ] to byte array ( ) { final int out len = nonce . length + ( long . size / byte . size ) ; final byte buffer out = byte buffer . allocate ( out len ) ; out . put ( nonce ) ; out . put long ( content length ) ; return out . array ( ) ; }	serialize the header into a byte array .
public void add interface ( cp ifc ) { add cp ( ifc ) ; interfaces . add element ( ifc ) ; }	add this cp to the list of interfaces supposedly implemented by this class.
public builder add constraint ( @ job constraint int constraint ) { int [ ] new constraints = new int [ m constraints == null ? num : m constraints . length + num ] ; if ( m constraints != null && m constraints . length != num ) { system . arraycopy ( m constraints , num , new constraints , num , m constraints . length ) ; } new constraints [ new constraints . length - num ] = constraint ; m constraints = new constraints ; return this ; }	adds the provided constraint to the current list of runtime constraints .
void cleanup parameters ( string relay state ) { if ( debug . message enabled ( ) ) { debug . message ( str + str + relay state ) ; } relay state map . remove ( relay state ) ; user session map . remove ( relay state ) ; user id . remove ( relay state ) ; is soap . remove ( relay state ) ; is soap . remove ( relay state ) ; is idp . remove ( relay state ) ; orig protocol map . remove ( relay state ) ; protocol list map . remove ( relay state ) ; realm map . remove ( relay state ) ; idp entity id . remove ( relay state ) ; sp entity id . remove ( relay state ) ; slo request xml . remove ( relay state ) ; slo response xml . remove ( relay state ) ; current status map . remove ( relay state ) ; }	removes saved parameters from internal cache map.
private boolean extra entity ( string output string , int char to map ) { boolean extra = bool ; if ( char to map < ascii max ) { switch ( char to map ) { case str : if ( ! output string . equals ( str ) ) extra = bool ; break ; case str : if ( ! output string . equals ( str ) ) extra = bool ; break ; case str : if ( ! output string . equals ( str ) ) extra = bool ; break ; case str : if ( ! output string . equals ( str ) ) extra = bool ; break ; default : extra = bool ; } } return extra ; }	this method returns true if there are some non - standard mappings to entities other than quot , amp , lt , gt , and its only purpose is for performance .
protected void draw point ( d g , point style point style , double x , double y , color color , color border color ) { shape point shape = point style . create shape ( x , y ) ; g . set color ( color ) ; g . fill ( point shape ) ; g . set color ( border color ) ; g . draw ( point shape ) ; }	this helper method can be used to draw a point in the given graphics object .
int retry time ( ) { return retry time . decrement and get ( ) ; }	get retry time , the retry time will decrease automatically after invoking this method .
public datepicker combo ( final composite parent , final int style ) { this ( parent , style , date format . get date time instance ( ) ) ; }	creates a new datepickercombo , using the default locale and default dateformat to format dates that are selected using the popup datepicker control .
public void test pow positive num ( ) { byte a bytes [ ] = { num , - num , num , num , num , num , num , - num , - num , num } ; int a sign = num ; int exp = num ; byte r bytes [ ] = { num , num , num , num , num , - num , num , num , - num , num , - num , - num , num , - num , num , - num , num , - num , - num , num , - num , num , - num , num , - num , - num , - num , - num , num , - num , - num , - num , num , num , - num , num , num , num , num , - num , num , - num , num , - num , num , - num , - num , num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . pow ( exp ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	exponentiation of a positive number .
protected void draw mark hilighted ( d g2 , float x , float y ) { d bounds = mark . get bounds2 d ( ) ; float w = ( float ) bounds . get width ( ) ; float h = ( float ) bounds . get height ( ) ; x = x - ( w / num ) ; y = y - ( h / num ) ; g2 . translate ( x , y ) ; if ( hilighted mark fill paint != null ) { g2 . set paint ( hilighted mark fill paint ) ; g2 . fill ( mark ) ; } g2 . set paint ( hilighted mark paint ) ; g2 . set stroke ( hilighted mark stroke ) ; g2 . draw ( mark ) ; g2 . translate ( - x , - y ) ; d rect = new d . float ( x , y , w , h ) ; mark bounds . add ( rect ) ; }	draw a mark transforming co - ordinates to each axis.
public static string trim trailing whitespace ( string str ) { if ( ! has length ( str ) ) { return str ; } string builder sb = new string builder ( str ) ; while ( sb . length ( ) > num && character . is whitespace ( sb . char at ( sb . length ( ) - num ) ) ) { sb . delete char at ( sb . length ( ) - num ) ; } return sb . to string ( ) ; }	trim trailing whitespace from the given string .
private static mks ticket response check get mks ticket response ( mks ticket response mks ticket response ) throws rpc exception { logger . info ( str , mks ticket response ) ; switch ( mks ticket response . get result ( ) ) { case ok : break ; case system error : throw new system error exception ( mks ticket response . get error ( ) ) ; case vm not found : throw new vm not found exception ( mks ticket response . get error ( ) ) ; case invalid vm power state : throw new invalid vm power state exception ( mks ticket response . get error ( ) ) ; default : throw new rpc exception ( string . format ( str , mks ticket response . get result ( ) ) ) ; } return mks ticket response ; }	this method validates a mksticketresponse object , raising an exception if the response reflects an operation failure .
@ not null default b append ( double d , int decimal places ) throws buffer overflow exception { if ( decimal places < num ) { double d2 = d * maths . tens ( decimal places ) ; if ( d2 <= long . max value && d2 >= long . min value ) { return append decimal ( math . round ( d2 ) , decimal places ) ; } } return append ( d ) ; }	append a double in decimal notation to a specific number of decimal places.
public completable future < t > complete async ( supplier < ? extends t > supplier , executor executor ) { if ( supplier == null || executor == null ) throw new null pointer exception ( ) ; executor . execute ( new async supply < t > ( this , supplier ) ) ; return this ; }	completes this completablefuture with the result of the given supplier function invoked from an asynchronous task using the given executor .
private movie subtitle chooser model ( ) { name = bundle . get string ( str ) ; }	create the empty search result .
public static java . sql . timestamp now timestamp ( ) { return get timestamp ( system . current time millis ( ) ) ; }	return a timestamp for right now.
private void revoke encrypt policy ( org . wso2 . emm . agent . beans . operation operation ) { boolean encrypt status = ( device policy manager . get storage encryption status ( ) != device policy manager . encryption status unsupported && ( device policy manager . get storage encryption status ( ) == device policy manager . encryption status active || device policy manager . get storage encryption status ( ) == device policy manager . encryption status activating ) ) ; if ( operation . is enabled ( ) && encrypt status ) { device policy manager . set storage encryption ( device admin , bool ) ; } }	revokes device encrypt policy on the device ( device external storage encryption ) .
public json close hash ( ) { if ( stack . empty ( ) || stack . peek ( ) != operand . hash ) { throw new json ( str ) ; } remove separator ( ) ; buffer . append ( str ) ; stack . pop ( ) ; add separator ( ) ; return this ; }	close an hash context .
private static byte [ ] generate seed ( ) { try { byte array output stream seed buffer = new byte array output stream ( ) ; data output stream seed buffer out = new data output stream ( seed buffer ) ; seed buffer out . write long ( system . current time millis ( ) ) ; seed buffer out . write long ( system . nano time ( ) ) ; seed buffer out . write ( build fingerprint and device serial ) ; seed buffer out . close ( ) ; return seed buffer . to byte array ( ) ; } catch ( io e ) { throw new security exception ( str , e ) ; } }	generates a device - and invocation - specific seed to be mixed into the linux prng .
private void init ( snmp mib my mib ) { if ( debug == null ) { final key < debug > key = key . get ( debug . class , names . named ( core token constants . cts monitor debug ) ) ; debug = injector holder . get instance ( key ) ; } final list < operation entry > operation entries = new array list < operation entry > ( ) ; final list < token entry > token entries = new array list < token entry > ( ) ; for ( enum e : crud items ) { final operation entry entry = new operation entry ( my mib ) ; entry . operation type = e . name ( ) ; entry . operation table index = ( long ) e . ordinal ( ) + num ; operation entries . add ( entry ) ; } for ( enum e : token items ) { final token entry entry = new token entry ( my mib ) ; entry . token type = e . name ( ) ; entry . token table index = ( long ) e . ordinal ( ) + num ; token entries . add ( entry ) ; } try { for ( operation entry ce : operation entries ) { operation table . add entry ( ce ) ; } for ( token entry te : token entries ) { token table . add entry ( te ) ; } create crud ( my mib , crud , operation entries , token entries ) ; create crud ( my mib , crud , operation entries ) ; create token operations table ( my mib , cts token operations table , token entries ) ; } catch ( snmp status exception e ) { if ( debug . message enabled ( ) ) { debug . error ( str , e ) ; } } }	performs the majority of the work setting up the tables such that they can be queried as pass - throughs to the data structures they act as queryable endpoints for .
@ override public void disconnection notification ( string event name , object source ) { m listenees . remove ( source ) ; if ( m listenees . size ( ) == num ) { m listenee types . clear ( ) ; } }	notify this object that it has been deregistered as a listener with a source for named event.
@ override public to double function < stream < tuple2 < f , double > > > dist ( stream < tuple2 < f , double > > features1 ) { object2 double map < f > aux map = new object2 double open hash map < > ( ) ; aux map . default return value ( num ) ; double adder norm1 = new double adder ( ) ; features1 . for each ( null ) ; if ( norm1 . double value ( ) == num ) { return null ; } return null ; }	returns a function that returns the feature - based similarity to the features of an item .
public load metadata details [ ] read load metadata ( string table folder path ) { gson gson object to read = new gson ( ) ; data input stream data input stream = null ; buffered reader buff reader = null ; input stream reader in stream = null ; string metadata file name = table folder path + carbon common constants . file separator + carbon common constants . loadmetadata filename ; load metadata details [ ] list of load folder details array ; atomic file operations file operation = new atomic file operations impl ( metadata file name , file factory . get file type ( metadata file name ) ) ; try { if ( ! file factory . is file exist ( metadata file name , file factory . get file type ( metadata file name ) ) ) { return new load metadata details [ num ] ; } data input stream = file operation . open for read ( ) ; in stream = new input stream reader ( data input stream , charset . for name ( carbon common constants . default charset ) ) ; buff reader = new buffered reader ( in stream ) ; list of load folder details array = gson object to read . from json ( buff reader , load metadata details [ ] . class ) ; } catch ( io e ) { return new load metadata details [ num ] ; } finally { close streams ( buff reader , in stream , data input stream ) ; } return list of load folder details array ; }	this method reads the load metadata file.
public string to inner html ( node node , appendable appendable ) { node visitor renderer = create renderer ( appendable ) ; node . visit children ( renderer ) ; return appendable . to string ( ) ; }	renders node children to appendable .
private void update storage view info ( v storage view info ) { v discovery mgr = vplex api client . get discovery manager ( ) ; discovery mgr . update storage view info ( storage view info ) ; }	updates a vplexstorageviewinfo object with detailed attributes .
static list < string > decode all ( collection < string > event keys ) { list < string > event ids = lists . new array list ( ) ; for ( string event key : event keys ) { decode to ( event key , event ids ) ; } return event ids ; }	split databus event keys into eventstore event ids .
public void test zero one ( ) { big integer a number = big integer . zero ; big integer b number = big integer . one ; big integer result = a number . and ( b number ) ; assert true ( result . equals ( big integer . zero ) ) ; assert equals ( str , num , result . signum ( ) ) ; }	and for zero and one.
public byte [ ] to byte array ( string ascii ) { if ( ascii == null ) { return empty byte array ; } return from ascii ( ascii . to char array ( ) ) ; }	decodes a string where each char of the string represents an ascii ' 0 ' or ' 1 ' .
public static boolean [ ] copy of range ( boolean [ ] original , int start , int end ) { if ( start <= end ) { if ( original . length >= start && num <= start ) { int length = end - start ; int copy length = math . min ( length , original . length - start ) ; boolean [ ] copy = new boolean [ length ] ; system . arraycopy ( original , start , copy , num , copy length ) ; return copy ; } throw new array index out of bounds exception ( ) ; } throw new illegal argument exception ( ) ; }	copies elements in original array to a new array , from index start ( inclusive ) to end ( exclusive ).
private static map < direction , sprite [ ] > split tiles ( sprite store st , sprite orig ) { int twidth = num attack frames * tile size ; int theight = num * tile size ; map < direction , sprite [ ] > map = new enum map < direction , sprite [ ] > ( direction . class ) ; int y = num ; map . put ( direction . up , st . get tiles ( orig , num , y , num attack frames , twidth , theight ) ) ; y += theight ; map . put ( direction . right , st . get tiles ( orig , num , y , num attack frames , twidth , theight ) ) ; y += theight ; map . put ( direction . down , st . get tiles ( orig , num , y , num attack frames , twidth , theight ) ) ; y += theight ; map . put ( direction . left , st . get tiles ( orig , num , y , num attack frames , twidth , theight ) ) ; return map ; }	split a sprite to a set of attack images .
void increment schema ( string schema name ) { if ( schema name != null ) { integer count = db map . get ( schema name ) ; if ( count == null ) db map . put ( schema name , num ) ; else db map . put ( schema name , count . int value ( ) + num ) ; } last db = schema name ; }	add a schema name , thereby incrementing counts .
private string build event data ( ) throws jaxb { if ( event parameters != null ) { try { jaxb jaxb context = jaxb . new instance ( event parameters . class ) ; marshaller marshaller = jaxb context . create marshaller ( ) ; marshaller . set property ( marshaller . jaxb formatted output , bool ) ; writer out writer = new string writer ( ) ; stream result result = new stream result ( out writer ) ; marshaller . marshal ( event parameters , result ) ; return out writer . to string ( ) ; } catch ( jaxb e ) { log . error ( str + e . get message ( ) ) ; throw e ; } } else { return null ; } }	build events data as marshalled string of xml data .
public boolean is projected ( ) { return projected ; }	tests whether the projection references have been configured .
private boolean normalize attr value ( xml attributes , int index ) { boolean leading space = bool ; boolean space start = bool ; boolean reading non space = bool ; int count = num ; int eaten = num ; string attr value = attributes . get value ( index ) ; char [ ] att value = new char [ attr value . length ( ) ] ; f buffer . set length ( num ) ; attr value . get chars ( num , attr value . length ( ) , att value , num ) ; for ( int i = num ; i < att value . length ; i ++ ) { if ( att value [ i ] == str ) { if ( reading non space ) { space start = bool ; reading non space = bool ; } if ( space start && ! leading space ) { space start = bool ; f buffer . append ( att value [ i ] ) ; count ++ ; } else { if ( leading space || ! space start ) { eaten ++ ; } } } else { reading non space = bool ; space start = bool ; leading space = bool ; f buffer . append ( att value [ i ] ) ; count ++ ; } } if ( count > num && f buffer . char at ( count - num ) == str ) { f buffer . set length ( count - num ) ; } string new value = f buffer . to string ( ) ; attributes . set value ( index , new value ) ; return ! attr value . equals ( new value ) ; }	normalize the attribute value of a non cdata attributes collapsing sequences of space characters ( x20 ).
private shape decode mark interior ( int width , int height ) { double left = width / num - num ; double top = height / num - num ; path . reset ( ) ; path . move to ( left + num , top + num ) ; path . line to ( left + num , top + num ) ; path . line to ( left + num , top + num ) ; path . close path ( ) ; return path ; }	create the mark interior shape .
public monotone solver ( final i < graph node > graph , final lattice lattice , final i < graph node , lattice element > start vector , final i < graph node , lattice element > transformation provider , final i < graph node , object type > walker ) { if ( graph == null ) { throw new illegal argument exception ( str ) ; } if ( lattice == null ) { throw new illegal argument exception ( str ) ; } if ( start vector == null ) { throw new illegal argument exception ( str ) ; } if ( transformation provider == null ) { throw new illegal argument exception ( str ) ; } final list < graph node > nodes = graph . get nodes ( ) ; if ( nodes . size ( ) != start vector . size ( ) ) { throw new illegal argument exception ( string . format ( str , start vector . size ( ) , nodes . size ( ) ) ) ; } for ( final graph node node : nodes ) { if ( ! start vector . has state ( node ) ) { throw new illegal argument exception ( str + node + str ) ; } } this . graph = graph ; this . lattice = lattice ; this . state = start vector ; this . transformation list = transformation provider ; this . walker = walker ; }	creates a new instance of a monotone solver .
private stat prepare port stat info ( string native id , uri resource id , long iops , long time sample ) { stat ip port stat = new stat ( ) ; ip port stat . set service type ( constants . file ) ; ip port stat . set time collected ( time sample ) ; ip port stat . set resource id ( resource id ) ; ip port stat . set native guid ( native id ) ; ip port stat . set total i ( iops ) ; return ip port stat ; }	prepare the port stat information.
public void test insert3 ( ) throws sql { database creator . fill parent table ( conn ) ; database creator . fill fk ( conn ) ; statement . execute ( str + database creator . test tabl + str + str + database creator . fkstrict table + str ) ; result set r = statement . execute query ( str + database creator . test tabl ) ; r . next ( ) ; assert equals ( str , num , r . get int ( num ) ) ; r . close ( ) ; }	insertfunctionalitytest # testinsert3 ( ).
public int compare to ( app version other ) { int result = major - other . major ; if ( result == num ) { result = minor - other . minor ; } if ( result == num ) { result = patch - other . patch ; } if ( result == num && ( milestone > - num || other . milestone > - num ) ) { if ( milestone > - num ) { if ( other . milestone == - num ) { result = - num ; } else { result = milestone - other . milestone ; } } else { if ( other . milestone > - num ) { result = num ; } } } if ( result == num && ! object util . null equals ( modifier , other . modifier ) ) { if ( modifier == null ) { result = num ; } else if ( other . modifier == null ) { result = - num ; } else { result = modifier . compare to ignore case ( other . modifier ) ; } } return result ; }	compares two version numbers according to their major , minor , patch and milestone version numbers , ordering from oldest to newest version.
public stream consumer ( input stream stream , string charset ) { in = new buffered input stream ( stream ) ; this . charset = charset ; thread . start ( ) ; }	creates a streamconsumer for consuming the data from the input stream .
public media size ( int x , int y , int units ) { super ( x , y , units ) ; if ( x > y ) { throw new illegal argument exception ( str ) ; } size vector . add ( this ) ; }	construct a new media size attribute from the given integer values .
private peer construct peer pojo ( final peer data peer data ) throws peer exception { preconditions . check not null ( peer data , str ) ; try { peer info peer info = from json ( peer data . get info ( ) , peer info . class ) ; if ( local peer id . equals ( peer data . get id ( ) ) ) { local peer . set peer info ( peer info ) ; return local peer ; } remote peer impl remote peer = new remote peer impl ( local peer id , security manager , peer info , messenger , command response listener , message response listener , provider , this ) ; relation info meta relation info meta = new relation info meta ( ) ; map < string , string > traits = relation info meta . get relation traits ( ) ; traits . put ( str , str ) ; traits . put ( str , str ) ; traits . put ( str , str ) ; user peer owner = identity manager . get user by key id ( identity manager . get peer owner id ( ) ) ; relation meta relation meta = new relation meta ( peer owner , local peer , remote peer , local peer . get key id ( ) ) ; relation relation = relation manager . build relation ( relation info meta , relation meta ) ; relation . set relation status ( relation status . verified ) ; relation manager . save relation ( relation ) ; return remote peer ; } catch ( exception e ) { throw new peer exception ( str , e ) ; } }	creates the peer instance by provided peer data.
public void load workspace contents ( string xml ) throws blockly parser exception { load workspace contents ( new byte array input stream ( xml . get bytes ( ) ) ) ; }	reads the workspace in from a xml stream.
public boolean load ( string file location , int type ) { if ( m has loaded ) { return bool ; } string shader code ; try { shader code = shader utils . get string from file in assets ( m context , file location , bool ) ; } catch ( io e ) { e . print stack trace ( ) ; m is compiled = bool ; return bool ; } m has loaded = bool ; m shader id = gle . gl create shader ( type ) ; if ( m shader id == num ) { string msg = ( type == gle . gl vertex shader ? str : str ) ; log . e ( tag , str + msg ) ; return bool ; } gle . gl shader source ( m shader id , shader code ) ; gle . gl compile shader ( m shader id ) ; int [ ] compile status = new int [ num ] ; gle . gl get shaderiv ( m shader id , gle . gl compile status , compile status , num ) ; m is compiled = ( compile status [ num ] == gle . gl true ) ; if ( ! m is compiled ) { string compile error = gle . gl get shader info log ( m shader id ) ; log . e ( tag , compile error ) ; gle . gl delete shader ( m shader id ) ; } return m is compiled && m has loaded ; }	load the shaders source file into a shader.
public void add child ( pdf layer child layer ) { if ( child layer . parent != null ) throw new illegal argument exception ( str ) ; child layer . parent = this ; if ( children == null ) children = new array list < > ( ) ; children . add ( child layer ) ; }	adds a child layer.
protected void move randomly ( om point , double factor , projection proj ) { double hor = math . random ( ) - num ; double vert = math . random ( ) - num ; d map point = proj . forward ( point . get lat ( ) , point . get lon ( ) ) ; map point . set location ( map point . get x ( ) + ( hor * factor ) , map point . get y ( ) + ( vert * factor ) ) ; d llp = proj . inverse ( map point ) ; point . set lat ( llp . get y ( ) ) ; point . set lon ( llp . get x ( ) ) ; }	simple method to move an ompoint around randomly .
private void initialize context ( ) throws io { string working dir = system . get property ( str ) ; file dataset = file utils . get file ( working dir + str ) ; file log4j file = file utils . get file ( working dir + str ) ; file dataset folder = new file ( destination folder + str ) ; file log4j folder = new file ( destination folder + str ) ; dataset . mkdirs ( ) ; log4j file . mkdirs ( ) ; file utils . copy file to directory ( dataset , dataset folder ) ; file utils . copy file to directory ( log4j file , log4j folder ) ; }	this method sets the working directory and copies the static context files such as log4j or xmldataset ( needed by hsqldb ) to the appropriate path .
public static int parse int ( fxg node , string value , string name ) { try { return integer . parse int ( value ) ; } catch ( number format exception e ) { throw new fxg ( node . get start line ( ) , node . get start column ( ) , str , name , value ) ; } }	convert an fxg string value to a integer .
public void close ( ) throws io { article idx writer . close ( ) ; chrono idx writer . close ( ) ; revision idx writer . close ( ) ; }	closes the file or the database connection .
private final byte [ ] zero extend ( byte [ ] data to pad ) { assert null != data to pad ; final int target length = num ; if ( target length <= data to pad . length ) return data to pad ; byte padded [ ] = new byte [ target length ] ; for ( int i = num ; i < data to pad . length ; i ++ ) padded [ i ] = data to pad [ i ] ; for ( int i = data to pad . length ; i < padded . length ; i ++ ) padded [ i ] = ( byte ) num ; return padded ; }	if the parameter is shorter than 4 bytes , then create and return a new 4 byte array with the input array ' s bytes followed by zero bytes.
private static boolean is certificate entry ( string alias ) throws key store exception { return s key store . is certificate entry ( alias ) ; }	check if a certificate is in the keystore.
public void test unwrap 06 ( ) { string host = str ; int port = num ; byte buffer [ ] bb a = { byte buffer . allocate ( num ) , byte buffer . allocate ( num ) , byte buffer . allocate ( num ) } ; byte buffer bb = byte buffer . allocate ( num ) ; ssl sse = get engine ( host , port ) ; sse . set use client mode ( bool ) ; try { ssl res = sse . unwrap ( bb , bb a , num , bb a . length ) ; assert equals ( num , res . bytes consumed ( ) ) ; assert equals ( num , res . bytes produced ( ) ) ; } catch ( exception ex ) { fail ( str + ex ) ; } }	javax . net . ssl . sslengine # unwrap ( bytebuffer src , bytebuffer [ ] dsts , int offset , int length ).
public static window window for word in position ( int window size , int word pos , list < string > sentence ) { list < string > window = new array list < > ( ) ; list < string > only tokens = new array list < > ( ) ; int context size = ( int ) math . floor ( ( window size - num ) / num ) ; for ( int i = word pos - context size ; i <= word pos + context size ; i ++ ) { if ( i < num ) window . add ( str ) ; else if ( i >= sentence . size ( ) ) window . add ( str ) ; else { only tokens . add ( sentence . get ( i ) ) ; window . add ( sentence . get ( i ) ) ; } } string whole sentence = string utils . join ( sentence ) ; string window2 = string utils . join ( only tokens ) ; int begin = whole sentence . index of ( window2 ) ; int end = begin + window2 . length ( ) ; return new window ( window , begin , end ) ; }	creates a sliding window from text.
public void enable ( ) { list < entry > entries = remove intersected entries ( tree . get selected entries ( ) ) ; boolean enable = bool ; for ( entry entry : entries ) { if ( entry == null ) { enable = bool ; break ; } if ( ! required selection type . is instance ( entry ) ) { enable = bool ; break ; } if ( needs write access && entry . is read only ( ) ) { enable = bool ; break ; } } if ( entries . is empty ( ) ) { enable = bool ; } set enabled ( enable ) ; }	enables action , if every entry exists and can be written if needed .
public string to string ( ) { string buffer buffer = new string buffer ( ) ; if ( get name ( ) != null ) { buffer . append ( get name ( ) ) ; } buffer . append ( str ) ; if ( get enclosing type name ( ) != null ) { buffer . append ( get enclosing type name ( ) ) ; } buffer . append ( str ) ; if ( get source name ( ) != null ) { buffer . append ( get source name ( ) ) ; } return buffer . to string ( ) ; }	answer the string representation of the receiver.
protected void mark ( ) throws compilation failed exception { apply to source units ( mark ) ; }	updates the phase marker on all sources .
private boolean label to keep rec ( node v , set < integer > ids , node set keep ) { boolean has below = bool ; int id = ( integer ) v . get info ( ) ; if ( ids . size ( ) == num || ids . contains ( id ) ) has below = bool ; for ( edge e = v . get first out edge ( ) ; e != null ; e = v . get next out edge ( e ) ) { node w = e . get target ( ) ; if ( label to keep rec ( w , ids , keep ) ) has below = bool ; } if ( has below ) keep . add ( v ) ; return has below ; }	label all nodes in tree that we must keep in induced tree.
public void put external property ( sso client token , string key , string value ) throws session exception { try { session utils wrapper . check permission to set property ( client token , key , value ) ; } catch ( session exception se ) { fire session event ( session event type . protected property ) ; session logging . log event ( to session info ( ) , session event type . protected property ) ; throw se ; } internal put property ( key , value ) ; debug . message ( str ) ; }	sets the key - value pair in the internalsession property table if it is not protected.
void add edge ( method parameter in , method parameter out ) { set < method parameter > outs = graph . get ( in ) ; if ( outs == null ) { outs = new hash set < > ( ) ; graph . put ( in , outs ) ; } outs . add ( out ) ; }	adds edge to the string passthru graph.
public static int [ ] random number ( int n ) { int [ ] num = new int [ n ] ; for ( int i = num ; i < num . length ; i ++ ) { num [ i ] = ( int ) ( r gen . next double ( ) * num ) ; } return num ; }	generate random number of size n .
public boolean is device tv ( context context ) { if ( build . version . sdk int >= build . version codes . lollipop ) { ui mode manager ui manager = ( ui mode manager ) context . get system service ( context . ui mode service ) ; return ui manager != null && ui manager . get current mode type ( ) == configuration . ui mode type television ; } return bool ; }	determines if the current device is a tv .
protected void rcpt to authors ( final recipient type rt ) { for ( final account . id id : authors ) { add ( rt , id ) ; } }	to or cc all vested parties ( change owner , patch set uploader , author ) .
public object create shape data ( shape shape ) { return null ; }	creates a data object to be associated with a newly created shape .
private protection set create protection set ( recover point volume ingestion context volume context ) { un managed protection set umpset = volume context . get un managed protection set ( ) ; protection set pset = volume ingestion util . find or create protection set ( volume context , volume context . get unmanaged volume ( ) , umpset , db client ) ; volume context . set managed protection set ( pset ) ; return pset ; }	create the managed protection set associated with the ingested rp volumes.
public synchronized void dispose ( ) { if ( is disposed ) { return ; } is disposed = bool ; array list < pooled connection > list = recycled connections ; for ( int i = num , size = list . size ( ) ; i < size ; i ++ ) { close connection ( list . get ( i ) ) ; } }	closes all unused pooled connections.
public void write to ( byte [ ] bytes , int offset ) throws io { flush ( ) ; final long end = file . length ; long pos = num ; int buffer = num ; int bytes upto = offset ; while ( pos < end ) { int length = buffer size ; long next pos = pos + length ; if ( next pos > end ) { length = ( int ) ( end - pos ) ; } system . arraycopy ( file . get buffer ( buffer ++ ) , num , bytes , bytes upto , length ) ; bytes upto += length ; pos = next pos ; } }	copy the current contents of this buffer to output byte array.
protected int calcn cluster ( ) { return num ; }	calculate the clustering of the hits.
public static void validate service name ( string service code , string service name ) { if ( ! service name . starts with ( service code ) ) { throw new coded exception ( x inconsistent headers , str + str ) ; } }	checks that the service name matches in header and body .
protected static void init cmyk ( ) { if ( icc rgb == null ) { rgb model = new component color model ( rgb cs , new int [ ] { num , num , num } , bool , bool , color model . opaque , data buffer . type byte ) ; } else { final int comp count = rgb cs . get num components ( ) ; final int [ ] values = new int [ comp count ] ; for ( int i = num ; i < comp count ; i ++ ) { values [ i ] = num ; } rgb model = new component color model ( rgb cs , values , bool , bool , color model . opaque , data buffer . type byte ) ; } final cmyk cmyk cs = new cmyk ( ) ; cs rgb = new color convert op ( cmyk cs , rgb cs , color spaces . hints ) ; }	initialise all the colorspaces when first needed.
private void add notification category separator ( j panel ) { j jsep = new j ( swing constants . horizontal ) ; jsep . set maximum size ( new dimension ( short . max value , num ) ) ; panel . add ( jsep ) ; }	adds a new horizontal separator to the notifications list .
public void clear dragged operators ( ) { this . dragged operators = collections . unmodifiable list ( collections . < operator > empty list ( ) ) ; }	clears the dragged operators .
public fake clock reset time ( ) { fake now ms . set ( base time ms ) ; return this ; }	reset the given clock back to the base time with which the fakeclock was initially constructed .
public gser ( char sequence value ) { reject . check not null ( value ) ; this . gser value = value . to string ( ) ; this . pos = num ; this . length = value . length ( ) ; }	creates a new gser parser .
public slice ( double start , double end , boolean visible ) { this . start = start ; this . end = end ; this . visible = visible ; }	initializes a new slice with start and end value .
public static void inject to target ( object target , bundle data ) { if ( target == null || data == null ) return ; parcel injector injector ; try { injector = get injector by class ( target . get class ( ) ) ; injector . inject data to target ( target , data ) ; } catch ( exception e ) { throw new runtime exception ( string . format ( str , e . get message ( ) ) , e ) ; } }	inject some data from data to target .
public static boolean are backend initiators ( list < initiator > initiators ) { boolean backend = bool ; for ( initiator initiator : initiators ) { if ( ! null column value getter . is null uri ( initiator . get host ( ) ) && uri . is type ( initiator . get host ( ) , host . class ) ) { backend = bool ; break ; } } return backend ; }	checks if any of the initiators belongs to a true host and returns true if all initiators do not belong to a host.
public boolean contains value ( object value ) { return map . contains value ( value ) ; }	this method is used to determine whether any pair that has been inserted into the internal map had the presented value.
public boolean has skins ( ) { return system . get property ( str ) != null || system . get property ( str ) != null ; }	subclasses of this implementation might override this to return builtin skins for a specific implementation.
public string to string ( ) { string builder builder = new string builder ( ) ; if ( type != null ) { name ( builder ) ; attributes ( builder ) ; } return builder . to string ( ) ; }	this is used to build a string from the annotation.
public void make immutable ( ) { if ( ! is immutable ) { overflow entries = overflow entries . is empty ( ) ? collections . < k , v > empty map ( ) : collections . unmodifiable map ( overflow entries ) ; is immutable = bool ; } }	make this map immutable from this point forward .
protected void parse names ( ) { while ( reader . has next character ( ) ) { final char character = next ( ) ; if ( strings . is whitespace ( character ) ) { add name ( ) ; continue ; } else if ( character == block opening ) { add name ( ) ; break ; } else { builder . append ( character ) ; } } if ( gdx arrays . is empty ( tags ) ) { throw exception ( str ) ; } }	parses names proceeding styles block .
protected void write zip64 central directory ( ) throws io { if ( zip64 mode == zip64 mode . never ) { return ; } if ( ! has used zip64 && ( cd offset >= zi magic || cd length >= zi magic || entries . size ( ) >= zi magic short ) ) { has used zip64 = bool ; } if ( ! has used zip64 ) { return ; } long offset = written ; write out ( zi eocd sig ) ; write out ( zip eight byte integer . get bytes ( short + short + word + word + dword + dword + dword + dword ) ) ; write out ( zip short . get bytes ( zi min version ) ) ; write out ( zip short . get bytes ( zi min version ) ) ; write out ( lzero ) ; write out ( lzero ) ; byte [ ] num = zip eight byte integer . get bytes ( entries . size ( ) ) ; write out ( num ) ; write out ( num ) ; write out ( zip eight byte integer . get bytes ( cd length ) ) ; write out ( zip eight byte integer . get bytes ( cd offset ) ) ; write out ( zi eocd loc sig ) ; write out ( lzero ) ; write out ( zip eight byte integer . get bytes ( offset ) ) ; write out ( one ) ; }	writes the & quot ; zip64 end of central dir record & quot ; and & quot ; zip64 end of central dir locator & quot ; .
public boolean is cache valid ( int row ) { return m valid . get ( row ) ; }	check if this expressioncolumn has a valid cached value at the given row .
public void finish ( ) throws io { check closed ( ) ; write ( ) ; }	finishes writing current uncompressed data into the inflateroutputstream without closing it .
public final void read fully ( byte [ ] b , int off , int len ) throws java . io . io { if ( len < num ) { throw new index out of bounds exception ( ) ; } int n = num ; while ( n < len ) { int count = read ( b , off + n , len - n ) ; if ( count < num ) { throw new eof ( ) ; } n += count ; } }	see the general contract of the readfully method of datainput.
public svg ( input stream istream ) { this . input = new transcoder input ( istream ) ; }	constructs a new svgrasterizer converter .
private static future < ? > direct execute ( runnable runnable , int delay ) { future < ? > future = null ; if ( delay > num ) { if ( ! ( executor instanceof scheduled executor service ) ) { throw new illegal argument exception ( str ) ; } scheduled executor service scheduled executor service = ( scheduled executor service ) executor ; future = scheduled executor service . schedule ( runnable , delay , time unit . milliseconds ) ; } else { if ( executor instanceof executor service ) { executor service executor service = ( executor service ) executor ; future = executor service . submit ( runnable ) ; } else { executor . execute ( runnable ) ; } } return future ; }	execute a runnable after the given delay .
@ override public void on patch version check fail ( file patch file , share patch info old patch info , string patch file version , boolean is upgrade patch ) { tinker log . i ( tag , str , patch file . get absolute path ( ) , patch file version , is upgrade patch ) ; }	for upgrade patch , patchfileversion can ' t equal oldversion or newversion in oldpatchinfo for repair patch , oldpatchinfo can ' t be null , and patchfileversion must equal with oldversion and newversion.
public void init ( boolean for encryption , cipher parameters params ) throws illegal argument exception { if ( ! ( params instanceof iv ) ) { throw new illegal argument exception ( str ) ; } iv iv params = ( iv ) params ; byte [ ] iv = iv params . get iv ( ) ; if ( iv == null || iv . length != num ) { throw new illegal argument exception ( str ) ; } if ( ! ( iv params . get parameters ( ) instanceof key parameter ) ) { throw new illegal argument exception ( str ) ; } key parameter key = ( key parameter ) iv params . get parameters ( ) ; working iv = new byte [ key . get key ( ) . length ] ; working key = new byte [ key . get key ( ) . length ] ; lfsr = new int [ state size ] ; nfsr = new int [ state size ] ; out = new byte [ num ] ; system . arraycopy ( iv , num , working iv , num , iv . length ) ; system . arraycopy ( key . get key ( ) , num , working key , num , key . get key ( ) . length ) ; reset ( ) ; }	initialize a grain v1 cipher .
grid memcached message ( ) { }	creates empty packet which will be filled in parser .
public extension forced user ( ) { super ( ) ; initialize ( ) ; }	instantiates a new forced user extension .
private string replace placeholders ( string query , map < string , string > replacements ) { string result query = query ; for ( map . entry < string , string > entry : replacements . entry set ( ) ) { result query = result query . replace ( entry . get key ( ) , entry . get value ( ) ) ; } return result query ; }	replaces the placeholders with concrete values.
public void destroy bucket ( auto mix bucket bucket ) { shared preferences prefs = get prefs ( ) ; shared preferences . editor editor = prefs . edit ( ) ; set < string > set = new tree set < > ( prefs . get string set ( pref buckets ids , new tree set < string > ( ) ) ) ; set . remove ( bucket . get session id ( ) ) ; editor . put string set ( pref buckets ids , set ) ; editor . apply ( ) ; m buckets . remove ( bucket ) ; }	destroys the provided bucket.
public void clear changed ( ) { changed . set ( bool ) ; }	clears the changed flag .
public static object [ ] convert params ( object [ ] source , class < ? > [ ] target ) { object [ ] converted = new object [ target . length ] ; for ( int i = num ; i < target . length ; i ++ ) { converted [ i ] = convert ( source [ i ] , target [ i ] ) ; } return converted ; }	convert parameters using methods of this utility class.
private void r probe and add hops to candidate set ( hop hop , hash set < hop > probe set , hash set < pair < hop , hop > > cand set ) { if ( hop . get visited ( ) == visit status . done ) return ; if ( hop . get input ( ) != null ) for ( hop c : hop . get input ( ) ) { if ( ! probe set . contains ( c ) ) r probe and add hops to candidate set ( c , probe set , cand set ) ; else { cand set . add ( new pair < hop , hop > ( hop , c ) ) ; } } hop . set visited ( visit status . done ) ; }	note : candset is a set of parent - child pairs because a parent might have multiple references to replicated hops .
protected void parse ( data input stream stream ) throws exception { value = stream . read int ( ) ; }	loading method . ( see nbt_tag ).
list < string > as list ( ) { if ( more ) { list . set ( list . size ( ) - num , str ) ; } return collections . unmodifiable list ( list ) ; }	get the name list of the added entities .
public void test not neg ( ) { byte a bytes [ ] = { - num , num , num , - num , - num , num , num , num , num , - num , num , num , - num } ; int a sign = - num ; byte r bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . not ( ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	not for a negative number.
public cache stat resource ( string resource identifier , cache resource cache resource ) { super ( resource identifier ) ; this . cache resource = cache resource ; relative cache stats = cache resource . get cache stats ( ) ; }	instantiates a new debug resource .
public map < uri , list < uri > > add target volume full copies ( ) { list < uri > full copies = lists . new array list ( ) ; map < uri , list < uri > > full copies map = new hash map < > ( ) ; uri target cg = null ; for ( uri volume id : uris ( volume ids ) ) { list < uri > targets = get targets ( volume id ) ; for ( uri target : targets ) { if ( target cg == null ) { target cg = get consistency group ( target ) ; } list < uri > volume full copies = get full copies ( target ) ; full copies . add all ( volume full copies ) ; full copies map . put ( target , volume full copies ) ; } } if ( ! full copies . is empty ( ) && target cg != null ) { block storage utils . add volumes to consistency group ( target cg , full copies ) ; } return full copies map ; }	adds all target volumes ' full copies to the target consistency group.
weather attribute ( int max , string ... desc ) { max value = max ; value = rand . rand ( max + num ) ; this . desc = desc ; }	create a weatherattribute with a maximum value and a set of descriptions .
protected class loader ( class loader parent loader ) { security manager sc = system . get security manager ( ) ; if ( sc != null ) { sc . check create class loader ( ) ; } parent class loader = parent loader ; defined packages = new hash map < string , package > ( ) ; loaded classes = new hash map < string , class < ? > > ( ) ; package certificates = new hashtable < string , certificate [ ] > ( ) ; }	constructs a new instance of this class with the given class loader as its parent .
static public double log10 ( double in value ) { return math . log ( in value ) / math . log ( num ) ; }	a static method that uses the natural log to obtain log to base10.
void update feature counts ( int [ ] translation ids , list < list < rich translation < i , string > > > nbest lists ) { for ( int i = num ; i < translation ids . length ; i ++ ) { set < string > features = new hash set < string > ( ) ; for ( rich translation < i , string > trans : nbest lists . get ( i ) ) { for ( feature value < string > f : trans . features ) { features . add ( f . name ) ; } } synchronized ( clipped feature index ) { for ( string f name : features ) { set < integer > ids = clipped feature index . get ( f name ) ; if ( ids == null ) { ids = new tree set < integer > ( ) ; clipped feature index . put ( f name , ids ) ; } if ( ids . size ( ) < min feature count ) { ids . add ( translation ids [ i ] ) ; } } } } }	update counts of the number of times we have seen each feature . features are only counted ounce per source sentence.
private void add native express ads ( ) { for ( int i = num ; i <= m recycler view items . size ( ) ; i += items per ad ) { final native express ad view ad view = new native express ad view ( main activity . this ) ; m recycler view items . add ( i , ad view ) ; } }	adds native express ads to the items list .
protected boolean accept ( final i record ) { return bool ; }	subclasses can override this to only record history on certain change events .
public final t allocate ( ) { atomic integer top ref = top ; while ( bool ) { final int top = top ref . get ( ) ; if ( top <= num ) { return null ; } else if ( top ref . compare and set ( top , top - num ) ) { t value = free stack . get and set ( top - num , null ) ; if ( value != null ) { return value ; } } } }	try to get an object from the free list.
public void put response get all resources ( list < string > resources ) { logger . debug ( str ) ; resource set resource set = new resource set ( ) ; for ( string res : resources ) { remote resource resource = gson . from json ( res , remote resource . class ) ; resource . set resource pool connector ( this ) ; resource set . add ( resource ) ; } synchronized ( get all resource response ) { get all resource response . add ( resource set ) ; get all resource response . notify ( ) ; } }	supposed to call from remoteinterpretereventpoller.
public static map < string , set < string > > to av pair map ( final set < string > names , final string value ) { if ( value == null ) { return collections . empty map ; } if ( names == null || names . is empty ( ) ) { return new hash map ( ) ; } final map < string , set < string > > map = new hash map < string , set < string > > ( names . size ( ) ) ; final set < string > set = new hash set < string > ( num ) ; set . add ( value ) ; for ( final string name : names ) { map . put ( name , set ) ; } return map ; }	creates a hash map , of names mapped to the provided value.
public prefix tagger ( maxent tagger maxent tagger ) { super ( maxent tagger ) ; this . left window = left window ( ) ; this . right window = right window ( ) ; this . offset = left window ( ) ; }	creates a new prefixtagger .
private iterable < int [ ] > split array ( int [ ] arr ) { int len1 = arr . length / num ; int len2 = len1 + arr . length % num ; int [ ] a1 = new int [ len1 ] ; int [ ] a2 = new int [ len2 ] ; system . arraycopy ( arr , num , a1 , num , len1 ) ; system . arraycopy ( arr , len1 , a2 , num , len2 ) ; return arrays . as list ( a1 , a2 ) ; }	splits the array into two parts.
@ ignore @ test public void should capture query event data ( ) throws exception { start client ( null ) ; counters . consume all ( num , time unit . seconds ) ; list < query event data > all query events = recorded event data ( query event data . class , - num ) ; all query events . for each ( null ) ; }	test case that is normally commented out since it is only useful to print out the ddl statements recorded by the binlog during a mysql server initialization and startup .
private list < validation error > check for no rates present ( ) { if ( overhead rates != null && overhead rates . is empty ( ) ) return arrays . as list ( new validation error ( str , str ) ) ; else return null ; }	this method checks if no overhead rates have been entered for the overhead .
public void modify export ( string id , string zone name , isilon export exp ) throws isilon exception { string uri with zone name = get uri ( id , zone name ) ; modify ( base url . resolve ( uri nfs exports ) , uri with zone name , str , exp ) ; }	modify export in access zone.
public double measure num iterations ( ) { return m . size ( ) ; }	return the number of iterations ( base classifiers ) completed.
public int count ( ) { return dict . size ( ) ; }	counts the number of contained key - value pairs .
public static boolean above or equal ( int a , int b ) { return integer . compare unsigned ( a , b ) >= num ; }	unsigned comparison aboveorequal for two numbers .
protected void await completion compute values and shutdown ( ) { { run executor and await completion ( ) ; } if ( logger . is debug enabled ( ) ) print stats ( ) ; executor . shutdown ( ) ; while ( ! executor . is terminated ( ) ) { try { thread . sleep ( num ) ; } catch ( interrupted exception e ) { e . print stack trace ( ) ; } } }	awaits the completion of the exploded super graph.
public flags flag list ( ) throws decoding exception { flags flags = new flags ( ) ; next word char ( ) ; consume char ( str ) ; character validator validator = new noop char validator ( ) ; string next word = consume word ( validator ) ; while ( ! next word . ends with ( str ) ) { decoder utils . set flag ( next word , flags ) ; next word = consume word ( validator ) ; } if ( next word . length ( ) > num ) { int paren index = next word . index of ( str ) ; if ( paren index > num ) { final string next flag = next word . substring ( num , paren index ) ; decoder utils . set flag ( next flag , flags ) ; } } return flags ; }	reads a " flags - list " argument from the request .
protected rest client itf create new rest client ( uri endpoint , string username , string password , string version , client client ) { io xio client = null ; if ( version != null && ! version . is empty ( ) && integer . value of ( version . split ( dot operator ) [ num ] ) >= xio min 4 x version ) { xio client = new io ( endpoint , username , password , client ) ; } else { xio client = new io ( endpoint , username , password , client ) ; } return xio client ; }	create a new xtremio rest client for the given endpoint , username , password and xtremio version.
public string diff text2 ( linked list < diff > diffs ) { string builder text = new string builder ( ) ; for ( diff a diff : diffs ) { if ( a diff . operation != operation . delete ) { text . append ( a diff . text ) ; } } return text . to string ( ) ; }	compute and return the destination text ( all equalities and insertions ) .
static private < e > list < e > to java list ( list < e > values , int rows , int columns ) { list < e > result = new array list < > ( values . size ( ) ) ; for ( int i = num ; i < values . size ( ) ; i ++ ) { int row = i / columns ; int column = i % columns ; e value = values . get ( ( column * rows ) + row ) ; result . add ( value ) ; } return result ; }	translates a column - major ( ie.
public string to html ( node node , appendable appendable ) { node visitor renderer = create renderer ( appendable ) ; node . visit ( renderer ) ; return appendable . to string ( ) ; }	renders node to appendable .
public static string [ ] to comma separated array ( string str ) throws io { return str . split ( str ) ; }	returns a value as a string array.
@ override public final object put ( string key , object value ) { return set ( key , value ) ; }	put the key - value in bean .
private void append float type ( string builder sb , field type field type , int field width ) { sb . append ( str ) ; }	output the sql type for a java float .
private http entity params to entity ( request params params , response handler interface response handler ) { http entity entity = null ; try { if ( params != null ) { entity = params . get entity ( response handler ) ; } } catch ( throwable t ) { if ( response handler != null ) response handler . send failure message ( num , null , null , t ) ; else t . print stack trace ( ) ; } return entity ; }	returns httpentity containing data from requestparams included with request declaration . allows also passing progress from upload via provided responsehandler.
public static boolean is installable editing ( enum set < embedding flags > flag set ) { return flag set . is empty ( ) ; }	takes an enumset \ < embeddingflags \ > representation of the fstype and returns whether or not the fstype is installable embedding.
public void test multiply scale pos pos ( ) { string a = str ; int a scale = num ; string b = str ; int b scale = num ; string c = str ; int c scale = num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; big decimal result = a number . multiply ( b number ) ; assert equals ( str , c , result . to string ( ) ) ; assert equals ( str , c scale , result . scale ( ) ) ; }	multiply two numbers of positive scales.
public iterator < resource > resource iterator ( ) { return resource list . iterator ( ) ; }	get an iterator over all resources in the method.
public double next uniform ( double lower , double upper ) { if ( upper <= lower ) { throw new math illegal argument exception ( localized core formats . lower bound not below upper bound , lower , upper ) ; } if ( double . is infinite ( lower ) || double . is infinite ( upper ) ) { throw new math illegal argument exception ( localized core formats . infinite bound ) ; } if ( double . is na n ( lower ) || double . is na n ( upper ) ) { throw new math illegal argument exception ( localized core formats . nan not allowed ) ; } final double u = random generator . next double ( ) ; return u * upper + ( num - u ) * lower ; }	returns a double value uniformly distributed over [ lower , upper ].
public shape tile box bounding box ( ) { pla point int lower left = new pla point int ( math . floor ( v x ) , math . floor ( v y ) ) ; pla point int upper right = new pla point int ( math . ceil ( v x ) , math . ceil ( v y ) ) ; return new shape tile box ( lower left , upper right ) ; }	creates the smallest intbox containing this point .
public void add interface ( string name ) { cached interfaces = null ; int info = const pool . add class info ( name ) ; if ( interfaces == null ) { interfaces = new int [ num ] ; interfaces [ num ] = info ; } else { int n = interfaces . length ; int [ ] newarray = new int [ n + num ] ; system . arraycopy ( interfaces , num , newarray , num , n ) ; newarray [ n ] = info ; interfaces = newarray ; } }	appends an interface to the interfaces implemented by the class .
@ suppress warnings ( str ) public static m create ( properties ctx , string hex input ) { hash map hm in = null ; try { byte [ ] byte array = secure . convert hex string ( hex input ) ; byte array input stream b in = new byte array input stream ( byte array ) ; object input stream o in = new object input stream ( b in ) ; hm in = ( hash map ) o in . read object ( ) ; } catch ( exception e ) { s log . log ( level . severe , str , e ) ; return null ; } m issue = new m ( ctx , ( hash map < string , string > ) hm in ) ; return issue ; }	create from decoded hash map string.
void flush buffer ( ) throws io { se . flush buffer ( ) ; }	flushes the output buffer to the underlying byte stream , without flushing the byte stream itself.
public static void show unknown error ( context context , throwable t , dialog interface . on cancel listener listener ) { show error ( context , string . format ( context . get string ( r . string . afc pmsg unknown error ) , t ) , listener ) ; }	shows an unknown error .
public void add button ( final j the button ) { custom button panel . add ( the button ) ; }	adds a new button to the panel .
void swap cursor ( long month millis , @ nullable event cursor cursor , content observer content observer ) { for ( int i = num ; i < m months . size ( ) ; i ++ ) { if ( calendar utils . same month ( month millis , m months . get ( i ) ) ) { swap cursor ( i , cursor , content observer ) ; break ; } } }	swaps cursor for calendar events for given month closes previously bound cursor , unregisters observer if any.
final boolean close ( ) { return ! closed . get and set ( bool ) ; }	logically closes this invocation handler.
public byte [ ] encrypt raw ( byte [ ] base key , int usage , byte [ ] ivec , byte [ ] plaintext , int start , int len ) throws general security exception , krb crypto exception { if ( ! key usage . is valid ( usage ) ) { throw new general security exception ( str + usage ) ; } byte [ ] output = encrypt cts ( base key , usage , ivec , null , plaintext , start , len , bool ) ; return output ; }	performs encryption using derived key ; does not add confounder .
private void fixbug ( document doc ) { element element = doc . get document element ( ) ; if ( element != null ) { fixbug ( element ) ; } }	this is to fix a bug generated by version 3.
private string to hex string ( byte [ ] block ) { string buffer buf = new string buffer ( ) ; int len = block . length ; for ( int i = num ; i < len ; i ++ ) { byte2hex ( block [ i ] , buf ) ; if ( i < len - num ) { buf . append ( str ) ; } } return buf . to string ( ) ; }	converts a byte array to hex string.
public static string remove deploy uri ( string uri ) { if ( ( uri == null ) || ( uri . length ( ) == num ) ) { return uri ; } int loc = uri . index of ( str , num ) ; if ( loc == - num ) { return null ; } else { return uri . substring ( loc ) ; } }	removes deployment uri from the pass down string.
public static double loss ( double pred , double y ) { return math . abs ( y - pred ) ; }	computes the absolute loss.
public boolean need signature file bytes ( ) { return sf bytes == null ; }	returns true if we need the . sf file.
public void insert ( t object , int index ) { synchronized ( m lock ) { m objects . add ( index , object ) ; } if ( m notify on change ) notify item inserted ( index ) ; }	inserts the specified object at the specified index in the array .
private void load target modules ( ) { for ( final module module : target . get modules ( ) ) { module . add listener ( module keeper listener ) ; modules . add ( module ) ; if ( ! module . is loaded ( ) ) { try { module . load ( ) ; } catch ( final couldnt load data exception e ) { error loading module ( module , e ) ; return ; } } } step ++ ; }	loads the modules that belong to the target .
public bloom filter ( double false positive probability , int expected number of elements ) { this ( math . ceil ( - ( math . log ( false positive probability ) / math . log ( num ) ) ) / math . log ( num ) , expected number of elements , ( int ) math . ceil ( - ( math . log ( false positive probability ) / math . log ( num ) ) ) ) ; }	constructs an empty bloom filter with a given false positive probability.
public synchronized void notify band ( final int times , final int on time , final int off time , final int flash colour ) { final list < ble > list = new array list < > ( ) ; byte [ ] colors = convert rgb ( flash colour ) ; list . add ( new wait action ( num ) ) ; list . add ( new write action ( profile . uuid char control point , protocol . vibration without led ) ) ; list . add ( new wait action ( num ) ) ; list . add ( new write action ( profile . uuid char control point , colors ) ) ; queue ( list ) ; }	notifies the mi band with vibration and colour.
public void test security cert ( ) { try { cert path parameters parameters = new my cert path parameters ( ) ; cert path trust manager parameters p = new cert path trust manager parameters ( parameters ) ; assert not same ( str , parameters , p . get parameters ( ) ) ; } catch ( exception e ) { fail ( str + e . to string ( ) ) ; } try { new cert path trust manager parameters ( null ) ; fail ( str ) ; } catch ( null pointer exception npe ) { } }	javax . net . ssl . certpathtrustmanagerparameters # certpathtrustmanagerparameters ( java . security . cert . certpathparameters ) case 1 : try to construct object . case 2 : check nullpointerexception .
private static int build request code ( long thread id , int action ) { action ++ ; return ( int ) ( action * num + thread id ) ; }	creates a unique action id for notification actions ( open , mark read , call , etc ).
public outer join qualifier add ( string property left , string property right ) { additional properties . add ( new property value expression pair ( new property value expression ( property left ) , new property value expression ( property right ) ) ) ; return this ; }	add additional properties to the on - clause , which are logical - and to existing properties.
public void insert element at ( int value , int at ) { if ( null == m map ) { m map = new int [ m blocksize ] ; m map size = m blocksize ; } else if ( ( m first free + num ) >= m map size ) { m map size += m blocksize ; int new map [ ] = new int [ m map size ] ; system . arraycopy ( m map , num , new map , num , m first free + num ) ; m map = new map ; } if ( at <= ( m first free - num ) ) { system . arraycopy ( m map , at , m map , at + num , m first free - at ) ; } m map [ at ] = value ; m first free ++ ; }	inserts the specified node in this vector at the specified index.
protected static dfp atan internal ( final dfp a ) { dfp y = new dfp ( a ) ; dfp x = new dfp ( y ) ; dfp py = new dfp ( y ) ; for ( int i = num ; i < num ; i += num ) { x = x . multiply ( a ) ; x = x . multiply ( a ) ; x = x . negate ( ) ; y = y . add ( x . divide ( i ) ) ; if ( y . equals ( py ) ) { break ; } py = new dfp ( y ) ; } return y ; }	computes the arc - tangent of the argument .
public static string parse segment name ( string filename ) { int idx = index of segment name ( filename ) ; if ( idx != - num ) { filename = filename . substring ( num , idx ) ; } return filename ; }	parses the segment name out of the given file name .
private static tree generate sub tree ( hash map < integer , pair < indexed word , list < integer > > > dependencies , int root ) { list < integer > children = dependencies . get ( root ) . second ; indexed word tw = dependencies . get ( root ) . first ; tree tree = new labeled scored tree node ( tw ) ; boolean added head = children . is empty ( ) ; list < integer > sorted children = collection utils . sorted ( children ) ; for ( integer c : sorted children ) { if ( c > root && ! added head ) { tree child = new labeled scored tree node ( tw ) ; tree . add child ( child ) ; added head = bool ; } tree child = generate sub tree ( dependencies , c ) ; tree . add child ( child ) ; } if ( ! added head ) { tree child = new labeled scored tree node ( tw ) ; tree . add child ( child ) ; } return tree ; }	recursively generates a shallow constituent tree rooted at root .
@ hle ( nid = num , version = num , check inside interrupt = bool ) public int sce sas rev param ( int sas core , int delay , int feedback ) { check sas handle good ( sas core ) ; waveform effect delay = delay ; waveform effect feedback = feedback ; return num ; }	set the wave form effect delay and feedback parameters ( unknown parameters ) .
static boolean is possible fp ( string val ) { final int length = val . length ( ) ; for ( int i = num ; i < length ; ++ i ) { char c = val . char at ( i ) ; if ( ! ( c >= str && c <= str || c == str || c == str || c == str || c == str || c == str ) ) { return bool ; } } return bool ; }	returns true if it ' s possible that the given string represents a valid floating point value ( excluding nan , inf and - inf ) .
public boolean delete track ( track track ) { synchronized ( tracks ) { return tracks . remove element ( track ) ; } }	removes the specified track from the sequence .
protected static array list < geo point > parse kml coordinates ( string input ) { linked list < geo point > tmp coords = new linked list < geo point > ( ) ; int i = num ; int tuple start = num ; int length = input . length ( ) ; boolean start reading tuple = bool ; while ( i < length ) { char c = input . char at ( i ) ; if ( c == str || c == str || c == str ) { if ( start reading tuple ) { string tuple = input . substring ( tuple start , i ) ; geo point p = parse kml coord ( tuple ) ; if ( p != null ) tmp coords . add ( p ) ; start reading tuple = bool ; } } else { if ( ! start reading tuple ) { start reading tuple = bool ; tuple start = i ; } if ( i == length - num ) { string tuple = input . substring ( tuple start , i + num ) ; geo point p = parse kml coord ( tuple ) ; if ( p != null ) tmp coords . add ( p ) ; } } i ++ ; } array list < geo point > coordinates = new array list < geo point > ( tmp coords . size ( ) ) ; coordinates . add all ( tmp coords ) ; return coordinates ; }	kml coordinates are : lon , lat { , alt } tuples separated by separators ( space , tab , cr ) .
public void paint ( d g ) { for ( int i = num ; i < m nodes . size ( ) ; i ++ ) { wf node = m nodes . get ( i ) ; rectangle rect = node . get bounds ( ) ; g . set color ( color . black ) ; g . draw rect ( rect . x , rect . y , rect . width , rect . height ) ; d t = ( d ) g . create ( rect . x , rect . y , rect . width , rect . height ) ; node . paint ( t ) ; t . dispose ( ) ; } create lines ( ) ; for ( int i = num ; i < m lines . size ( ) ; i ++ ) { wf line = ( wf ) m lines . get ( i ) ; line . paint ( g ) ; } }	paint component . paint lines directly as not added .
server session context register request ( long sequence , runnable runnable ) { commands . put ( sequence , runnable ) ; return this ; }	adds a command to be executed in sequence .
public void add preferences button ( ) { j prefs button = new j ( str ) ; prefs button . set hide action text ( bool ) ; prefs button . set action ( time series plot actions . get properties dialog action ( this ) ) ; button panel . add ( prefs button ) ; }	add button for showing preferences .
public static void find index matches ( search pattern pattern , index index , index query requestor requestor , search participant participant , i scope , i monitor ) throws io { pattern . find index matches ( index , requestor , participant , scope , monitor ) ; }	query a given index for matching entries.
public static void log info ( string message , object ... args ) { message = message format . format ( message , args ) ; log ( i . info , i . ok , message , null ) ; }	log the specified information .
public static boolean occupy ( int wait ms ) { if ( occupied until != null && occupied until . after ( new date ( ) ) ) { return bool ; } occupied until = date utils . add milliseconds ( new date ( ) , wait ms ) ; return bool ; }	tries to occupy the onclick enabler .
public boolean [ ] [ ] moralize ( bayes net bayes net ) { int n nodes = bayes net . get nr of nodes ( ) ; boolean [ ] [ ] b adjacency matrix = new boolean [ n nodes ] [ n nodes ] ; for ( int i node = num ; i node < n nodes ; i node ++ ) { parent set parents = bayes net . get parent sets ( ) [ i node ] ; moralize node ( parents , i node , b adjacency matrix ) ; } return b adjacency matrix ; }	moralize dag and calculate adjacency matrix representation for a bayes network , effecively converting the directed acyclic graph to an undirected graph .
public void add divider ( image view v ) { relative layout . layout params divider params = new relative layout . layout params ( layout params . fill parent , layout params . wrap content ) ; if ( m image view != null ) { divider params . add rule ( relative layout . below , m image view . get id ( ) ) ; } else if ( m missing image != null ) { divider params . add rule ( relative layout . below , m missing image . get id ( ) ) ; } else if ( m video button != null ) { divider params . add rule ( relative layout . below , m video button . get id ( ) ) ; } else if ( m audio button != null ) { divider params . add rule ( relative layout . below , m audio button . get id ( ) ) ; } else if ( m view != null ) { divider params . add rule ( relative layout . below , m view . get id ( ) ) ; } else { log . e ( t , str ) ; return ; } add view ( v , divider params ) ; }	this adds a divider at the bottom of this layout.
private double find length ( point origin point , point target point ) { int x1 = origin point . x ; int y1 = origin point . y ; int x2 = target point . x ; int y2 = target point . y ; double side a = x2 - x1 ; double side b = ( y1 > y2 ? ( y1 - y2 ) : ( y2 - y1 ) ) ; if ( side b == num ) { return side a ; } return math . sqrt ( math . pow ( side a , num ) + math . pow ( side b , num ) ) ; }	uses trig to find legth of the hypotenuse.
public void test case4 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; int a sign = num ; int b sign = - num ; byte r bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . subtract ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( num , result . signum ( ) ) ; }	subtract two numbers of the same length and different signs.
public static void write ( input stream in , output stream out , boolean close both ) throws io { byte [ ] buff = new byte [ num ] ; int read = num ; while ( ( read = in . read ( buff ) ) > num ) { out . write ( buff , num , read ) ; } out . flush ( ) ; if ( close both ) { safe close streams ( in , out ) ; } }	writes the input stream to the output stream.
public static double distance ( dd p1 , dd p2 , units units ) { final double lat p1 = p1 . north south ; final double lat p2 = p2 . north south ; final double lon p1 = p1 . east west ; final double lon p2 = p2 . east west ; if ( lat p1 == lat p2 && lon p1 == lon p2 ) return num ; double dist rad = math . acos ( math . sin ( to radians ( lat p1 ) ) * math . sin ( to radians ( lat p2 ) ) + math . cos ( to radians ( lat p1 ) ) * math . cos ( to radians ( lat p2 ) ) * math . cos ( to radians ( lon p1 - lon p2 ) ) ) ; final double dist as degree = to degrees ( dist rad ) ; return meters to units ( dist as degree * num * num * num , units ) ; }	computes the distance between two coordinates .
public static liquid network init network ( ) { random random = new random ( system . current time millis ( ) ) ; int id = random . next int ( ) ; while ( used ids . contains ( id ) ) { id = random . next int ( ) ; } ; liquid network net = new liquid network ( ) ; used ids . add ( id ) ; net . network id = id ; return net ; }	create a new network and get an id.
public string export xml ( ) throws io { byte array output stream output stream = new byte array output stream ( ) ; export xml ( output stream ) ; return output stream . to string ( ) ; }	dumps fetch data in xml format .
public pattern replace filter ( token stream in , pattern p , string replacement , boolean all ) { super ( in ) ; this . replacement = ( null == replacement ) ? str : replacement ; this . all = all ; this . m = p . matcher ( term att ) ; }	constructs an instance to replace either the first , or all occurances.
public static int [ ] stable sort ( double [ ] array ) { int [ ] index = new int [ array . length ] ; int [ ] new index = new int [ array . length ] ; int [ ] help index ; int num equal ; array = ( double [ ] ) array . clone ( ) ; for ( int i = num ; i < index . length ; i ++ ) { index [ i ] = i ; if ( double . is na n ( array [ i ] ) ) { array [ i ] = double . max value ; } } quick sort ( array , index , num , array . length - num ) ; int i = num ; while ( i < index . length ) { num equal = num ; for ( int j = i + num ; ( ( j < index . length ) && utils . eq ( array [ index [ i ] ] , array [ index [ j ] ] ) ) ; j ++ ) num equal ++ ; if ( num equal > num ) { help index = new int [ num equal ] ; for ( int j = num ; j < num equal ; j ++ ) help index [ j ] = i + j ; quick sort ( index , help index , num , num equal - num ) ; for ( int j = num ; j < num equal ; j ++ ) new index [ i + j ] = index [ help index [ j ] ] ; i += num equal ; } else { new index [ i ] = index [ i ] ; i ++ ; } } return new index ; }	sorts a given array of doubles in ascending order and returns an array of integers with the positions of the elements of the original array in the sorted array.
public void reopen read write ( ) { synchronized ( m lock ) { throw if not open locked ( ) ; if ( ! is read only locked ( ) ) { return ; } final int old open flags = m configuration locked . open flags ; m configuration locked . open flags = ( m configuration locked . open flags & ~ open read mask ) | open readwrite ; try { m connection pool locked . reconfigure ( m configuration locked ) ; } catch ( runtime exception ex ) { m configuration locked . open flags = old open flags ; throw ex ; } } }	reopens the database in read - write mode.
public static int read chars ( reader r , char [ ] char array ) throws io { int total chars read = num ; int chars read = r . read ( char array ) ; while ( chars read >= num ) { total chars read += chars read ; if ( total chars read == char array . length ) { break ; } chars read = r . read ( char array , total chars read , char array . length - total chars read ) ; } return total chars read ; }	fills the supplied character array with characters read from the specified reader.
public void remove direction ( final direction dir , final boolean face ) { rp action ; int size ; action = new rp ( ) ; action . put ( str , str ) ; action . put ( str , - dir . get ( ) ) ; send ( action ) ; directions . remove ( dir ) ; size = directions . size ( ) ; if ( size == num ) { action = new rp ( ) ; action . put ( str , str ) ; } else { if ( face ) { action = new rp ( directions . get ( size - num ) ) ; } else { action = new rp ( directions . get ( size - num ) ) ; } } send ( action ) ; }	remove a player movement direction .
public static double [ ] ndary ( int n ) { double d [ ] = new double [ n ] ; for ( int i = num ; i < n ; i ++ ) { d [ i ] = r . next gaussian ( ) ; } return d ; }	generates a one - dimensional array of normal random doubles .
private float apply bounce ( float velocity , float dist out of bounds , float simulation rate ) { if ( is zero ( dist out of bounds ) ) { return velocity ; } velocity *= - num ; float bounce = bounce multiplier * math . abs ( dist out of bounds / m iris radius ) ; if ( velocity > num ) { velocity += bounce * simulation rate ; } else { velocity -= bounce * simulation rate ; } return velocity ; }	update velocity in response to bouncing off the sides of the eye ( i.
private double dot ( final int k0 , final int k1 , final int [ ] assignment0 , final int [ ] assignment1 ) { double dot = num ; final int n = x . size ( ) ; int a = num , b = num ; for ( int i = num ; i < n ; i ++ ) { if ( assignment0 [ i ] != k0 ) continue ; a ++ ; for ( int j = num ; j < n ; j ++ ) { if ( assignment1 [ j ] != k1 ) continue ; dot += kernel . eval ( i , j , x , accel ) ; } } for ( int j = num ; j < n ; j ++ ) if ( assignment1 [ j ] == k1 ) b ++ ; return dot / ( a * b ) ; }	dot product between two different clusters from different sets of cluster assignments.
public void remove all textures ( ) { for ( weak reference < cc d > tex sr : textures . values ( ) ) { cc d tex = tex sr . get ( ) ; if ( tex != null ) tex . release texture ( cc . gl ) ; } textures . clear ( ) ; }	purges the dictionary of loaded textures . call this method if you receive the " memory warning " in the short term : it will free some resources preventing your app from being killed in the medium term : it will allocate more resources in the long term : it will be the same.
public synchronized void add to queue ( final image resource loader image resource loader , final string uri , final fs mfsi , final int width , final int height ) { xr . general ( level . fine , str + uri ) ; load queue . add last ( new image load item ( image resource loader , uri , mfsi , width , height ) ) ; notify all ( ) ; }	queues a new item to be loaded.
private jni ( context context ) { context . put ( jni writer key , this ) ; file manager = context . get ( java file manager . class ) ; log = log . instance ( context ) ; options options = options . instance ( context ) ; verbose = options . is set ( verbose ) ; check all = options . is set ( str ) ; this . context = context ; syms = symtab . instance ( context ) ; line sep = system . get property ( str ) ; }	construct a class writer , given an options table .
public josm xml ( sink sink , xml reader , boolean enable date parsing ) { this . sink = sink ; this . enable date parsing = enable date parsing ; this . reader = reader ; if ( enable date parsing ) { timestamp format = new xml timestamp format ( ) ; } else { calendar calendar ; calendar = calendar . get instance ( ) ; calendar . set ( calendar . millisecond , num ) ; dummy timestamp container = new simple timestamp container ( calendar . get time ( ) ) ; } member type parser = new member type parser ( ) ; }	creates a new instance .
public hashtable ( int initial capacity , float load factor ) { if ( initial capacity < num ) { throw new illegal argument exception ( str + initial capacity ) ; } if ( load factor <= num || float . is na n ( load factor ) ) { throw new illegal argument exception ( str + load factor ) ; } if ( initial capacity == num ) initial capacity = num ; this . load factor = load factor ; table = new entry [ initial capacity ] ; threshold = ( int ) ( initial capacity * load factor ) ; }	constructs a new , empty hashtable with the specified initial capacity and the specified load factor .
public static string extract reminder ( string public url , string access url ) { return public url . substring ( access url . length ( ) ) ; }	extracts container / object from http : / / hostname / v1 / auth_id / container / object.
public void create underlying ( ) { if ( options != null ) { options . create underlying ( ) ; if ( platform . is fx application thread ( ) ) { line = new com . lynden . gmapsfx . shapes . polyline ( options . convert ( ) ) ; } } }	creates the gmapsfx model polyline.
private void init raster program ( ) { int buffer props = buffer utils . create int buffer ( num ) ; int buffer params = buffer utils . create int buffer ( num ) ; int uniforms resource index = gl get program resource index ( raster program , gl uniform block , str ) ; compute ubo binding = params . get ( num ) ; props . put ( num , gl buffer binding ) ; gl get program resourceiv ( raster program , gl uniform block , uniforms resource index , props , null , params ) ; raster ubo binding = params . get ( num ) ; }	initialize the raster program .
private void install voice data ( ) { if ( text utils . is empty ( get engine name ( ) ) ) return ; intent intent = new intent ( text to speech . engine . action install tts data ) ; intent . add flags ( intent . flag activity new task ) ; intent . set package ( get engine name ( ) ) ; try { log . v ( tag , str + intent . to uri ( num ) ) ; start activity ( intent ) ; } catch ( activity not found exception ex ) { log . e ( tag , str + intent + str ) ; } }	ask the current default engine to launch the matching install_tts_data activity so the required tts files are properly installed .
public bitmap load bitmap ( string uri , int req width , int req height ) { bitmap bitmap = load bitmap from mem cache ( uri ) ; if ( bitmap != null ) { log . d ( tag , str + uri ) ; return bitmap ; } try { bitmap = load bitmap from disk cache ( uri , req width , req height ) ; if ( bitmap != null ) { log . d ( tag , str + uri ) ; return bitmap ; } bitmap = load bitmap from http ( uri , req width , req height ) ; log . d ( tag , str + uri ) ; } catch ( io e ) { e . print stack trace ( ) ; } if ( bitmap == null && ! m is disk lru cache created ) { log . w ( tag , str ) ; bitmap = download bitmap from url ( uri ) ; } return bitmap ; }	load bitmap from memory cache or disk cache or network .
public boolean is safe to execute sut ( ) { thread current = thread . current thread ( ) ; if ( ! privileged threads . contains ( current ) ) { return bool ; } else { return privileged thread to ignore == current ; } }	check if running sut code on current thread would be done inside the sandbox.
public void test case17 ( ) { byte a bytes [ ] = { num } ; byte b bytes [ ] = { num , num , num , num , num , num , num } ; byte r bytes [ ] = { num , num , num , num , num , num , num } ; int a sign = num ; int b sign = num ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . add ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	add a number to zero.
public string [ ] read directory ( string dir ) { if ( dir == null ) { throw new null pointer exception ( str ) ; } string array out list out = new string array out ( ) ; try { check result ( i . afc read directory ( get ref ( ) , dir , list out ) ) ; string array list = list out . get value ( ) ; array list < string > result = new array list < string > ( ) ; if ( list != null ) { for ( int i = num ; ; i ++ ) { string s = list . get ( i ) ; if ( s == null ) { break ; } result . add ( s ) ; } } return result . to array ( new string [ result . size ( ) ] ) ; } finally { i . delete values z ( list out . get value ( ) ) ; list out . delete ( ) ; } }	returns a directory listing of the specified directory .
public static string create args string ( list < string > args ) { if ( args == null ) { return str ; } string builder args sb = new string builder ( ) ; for ( string arg : args ) { if ( ( arg . contains ( str ) || arg . contains ( str ) ) && ! string utilities . is quoted ( arg ) ) { args sb . append ( string utilities . quote ( arg ) ) ; } else { args sb . append ( arg ) ; } args sb . append ( str ) ; } if ( args sb . length ( ) > num ) { args sb . set length ( args sb . length ( ) - num ) ; } return args sb . to string ( ) ; }	creates an argument string from the given list of arguments.
public void add element ( int value ) { int index relative to cache = m first free - m build cache start index ; if ( index relative to cache >= num && index relative to cache < m blocksize ) { m build cache [ index relative to cache ] = value ; ++ m first free ; } else { int index = m first free > > > m shift ; int offset = m first free & m mask ; if ( index >= m map . length ) { int newsize = index + m numblocks ; int [ ] [ ] new map = new int [ newsize ] [ ] ; system . arraycopy ( m map , num , new map , num , m map . length ) ; m map = new map ; } int [ ] block = m map [ index ] ; if ( null == block ) block = m map [ index ] = new int [ m blocksize ] ; block [ offset ] = value ; m build cache = block ; m build cache start index = m first free - offset ; ++ m first free ; } }	append a int onto the vector .
public static < t > list < list < t > > overlap ( list < list < t > > lists , int before , int after ) { if ( before < num ) { throw new illegal argument exception ( str ) ; } if ( after < num ) { throw new illegal argument exception ( str ) ; } list iterator < list < t > > iter = lists . list iterator ( ) ; list < list < t > > result = new array list < list < t > > ( ) ; for ( ; iter . has next ( ) ; ) { list < t > current = new array list < t > ( iter . next ( ) ) ; list < t > prev = before > num ? find previous ( iter ) : null ; list < t > next = after > num ? find next ( iter ) : null ; if ( prev != null ) { list < t > overlap = prev . sub list ( prev . size ( ) - before , prev . size ( ) ) ; current . add all ( num , overlap ) ; } if ( next != null ) { list < t > overlap = next . sub list ( num , after ) ; current . add all ( overlap ) ; } result . add ( current ) ; } return result ; }	introduces overlap into a series of lists .
public double [ ] [ ] extract main set jacobian ( final ode state ) { final double [ ] p = state . get secondary state ( index ) ; final double [ ] [ ] d yd y0 = new double [ state dim ] [ state dim ] ; int j = num ; for ( int i = num ; i < state dim ; i ++ ) { system . arraycopy ( p , j , d yd y0 [ i ] , num , state dim ) ; j += state dim ; } return d yd y0 ; }	extract the jacobian matrix with respect to state .
private void handle get candidate result ( placement task current state , operation post operation , map < string , server address > candidates , stopwatch placement watch ) { service utils . log info ( this , str , placement watch . elapsed ( time unit . milliseconds ) ) ; if ( candidates . is empty ( ) ) { string msg = string . format ( str , current state . resource ) ; placement task patch state = build patch ( task state . task stage . failed , current state . task state . is direct , null ) ; patch state . result code = place result code . no such resource ; patch state . error = msg ; fail task ( patch state , new throwable ( msg ) , post operation ) ; return ; } service utils . log info ( this , str , candidates , current state . timeout ms ) ; stopwatch score candidates stopwatch = stopwatch . create started ( ) ; query hosts for scores ( current state . resource , candidates , null ) ; }	helper method to process the candidates returned by getpotentialcandidates .
public boolean contains ( json element element ) { return elements . contains ( element ) ; }	returns true if this array contains the specified element .
private void append path ( path cp , final path p ) { if ( p != null && p . size ( ) > num ) { cp . append ( p ) ; } }	append path to class path if the appened path is not empty and is not null.
public static void do default layout ( composite parent , dialog field [ ] editors , boolean label on top ) { do default layout ( parent , editors , label on top , num , num ) ; }	creates a composite and fills in the given editors .
protected void parse ( data input stream stream ) throws exception { value = stream . read utf ( ) ; }	loading method . ( see nbt_tag ).
public void remove drag event handlers ( ) { node . remove event handler ( touch event . any , touch handler ) ; node . remove event handler ( mouse event . any , mouse handler ) ; }	make the attached node stop acting on drag actions by removing drag event handlers.
protected void install listeners ( ) { super . install listeners ( ) ; table . add property change listener ( this ) ; }	attaches listeners to the jtable .
public void test compare to zero pos ( ) { byte b bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num , num , num , num , num } ; int b sign = num ; big integer a number = big integer . zero ; big integer b number = new big integer ( b sign , b bytes ) ; assert equals ( - num , a number . compare to ( b number ) ) ; }	compareto ( biginteger a ).
public void shutdown ( ) throws connection manager exception { s logger . info ( str ) ; connection lock . lock ( ) ; try { close all connections ( ) ; if ( listener != null ) { listener . stop ( ) ; listener = null ; } executor service . shutdown ( ) ; } catch ( exception e ) { throw new connection manager exception ( str , e ) ; } finally { connection lock . unlock ( ) ; } }	shutdown the application . stops the listener ( which releases its tcp port ) .
private void close writer execution service ( executor service service ) throws carbon data writer exception { try { service . shutdown ( ) ; service . await termination ( num , time unit . days ) ; } catch ( interrupted exception e ) { logger . error ( e , e . get message ( ) ) ; throw new carbon data writer exception ( e . get message ( ) ) ; } }	this method will close writer execution service and get the node holders and add them to node holder list.
public void remove job ( string job id ) { if ( jobs . contains ( job id ) ) { jobs . remove ( job id ) ; } }	removes a job ' s id from the list of jobs in this group .
public string format time millis ( long ts ) { synchronized ( time formatter ) { return time formatter . format ( new date ( ts ) ) ; } }	formats an archive timestamp in way consistent with gemfire log dates.
protected static final int position coordinate2 d ( float value ) { return ( int ) ( value + num ) ; }	transform a floating - point 2d position coordinate to a screen coordinate.
@ override public object clone ( ) { try { identity hash map < k , v > clone hash map = ( identity hash map < k , v > ) super . clone ( ) ; clone hash map . element data = new element array ( element data . length ) ; system . arraycopy ( element data , num , clone hash map . element data , num , element data . length ) ; return clone hash map ; } catch ( clone not supported exception e ) { throw new assertion error ( e ) ; } }	returns a new identityhashmap with the same mappings and size as this one .
public int trap ( int [ ] a ) { if ( a == null || a . length == num ) return num ; int l = num ; int r = a . length - num ; int level = num ; int all = num ; int block = num ; while ( l <= r ) { int cur level = math . min ( a [ l ] , a [ r ] ) ; if ( cur level > level ) { all += ( cur level - level ) * ( r - l + num ) ; level = cur level ; } if ( a [ l ] < a [ r ] ) block += a [ l ++ ] ; else block += a [ r -- ] ; } return all - block ; }	calculate the area of all and blocks then return all - block to get the trapped water start from two sides if min of a [ l ] and a [ r ] is larger than current level update all and curlevel then move lower pointer towards center.
public void search ( ) { perform search ( ) ; }	imitates a click on the search button to initiate a search .
public remote session ( http session session ) { super ( ) ; debug = debug . get instance ( str ) ; this . session = ( http session ) session ; creation time = session . get creation time ( ) ; id = session . get id ( ) ; last accessed time = session . get last accessed time ( ) ; max inactive interval = session . get max inactive interval ( ) ; is new = session . is new ( ) ; internal attributes = new hash map ( ) ; enumeration a names = get attribute names ( ) ; while ( a names . has more elements ( ) ) { string attribute name = ( string ) a names . next element ( ) ; if ( is serializable ( get attribute ( attribute name ) ) && ! attribute name . equals ( str ) && ! attribute name . equals ( str ) ) { internal attributes . put ( attribute name , get attribute ( attribute name ) ) ; internal attribute names . add ( attribute name ) ; debug . message ( str + attribute name + str + get attribute ( attribute name ) ) ; } } }	construct a new session facade.
@ override public snmp mib handler add mib ( snmp mib agent mib ) throws illegal argument exception { if ( mib == null ) { throw new illegal argument exception ( ) ; } if ( ! mibs . contains ( mib ) ) mibs . add element ( mib ) ; root . register ( mib ) ; return this ; }	adds a new mib in the snmp mib handler .
public boolean exist ( ) { return production run != null ; }	test if the productionrun exist .
public static sort clause create ( string item , string order ) { return new sort clause ( item , order . value of ( order ) ) ; }	creates a sortclause based on item and order.
public long end time ( ) { return get timestamp ( ) + calculate duration ( ) ; }	this method returns the end time of the trace fragment .
protected void build leaves middle out ( ball node node ) throws exception { if ( node . m != null && node . m != null ) { build leaves middle out ( node . m ) ; build leaves middle out ( node . m ) ; } else if ( node . m != null || node . m != null ) { throw new exception ( str ) ; } else { ball node n2 = build tree middle out ( node . m , node . m ) ; if ( n2 . m != null && n2 . m != null ) { node . m = n2 . m ; node . m = n2 . m ; build leaves middle out ( node ) ; } else if ( n2 . m != null || n2 . m != null ) { throw new exception ( str ) ; } } }	applies the middle out build procedure to the leaves of the tree.
@ deprecated public static int [ ] decode value ( string a ) { return to int array ( a . split ( str ) ) ; }	encode value . " 0 + 3 + 2 " - & gt ; [ 0 , 3 , 2 ] deprecated - use labelset or labelvector.
public weight vector ( weight vector wv ) { float in [ ] = wv . get internal array ( ) ; u = new float [ in . length ] ; system . arraycopy ( in , num , u , num , in . length ) ; size = in . length ; }	duplicate a weight vector.
public void wait until done ( ) { count lock . lock ( ) ; try { equal count cv . await ( ) ; } catch ( interrupted exception e ) { throw new runtime exception ( str ) ; } finally { count lock . unlock ( ) ; } }	wait for the number of finished jobs to equal to the number of submitted jobs .
public java . lang . string builder insert ( int offset , long l ) { return insert ( offset , long . to string ( l ) ) ; }	inserts the string representation of the long argument into this string buffer.
public projection preferences dialog ( projector projector ) { this . projector = projector ; string tolerance tool tip = str + str ; j tolerance label = new j ( str ) ; tolerance . set tool tip text ( tolerance tool tip ) ; tolerance label . set tool tip text ( tolerance tool tip ) ; main panel . add item label ( tolerance label , tolerance ) ; if ( projector . get projection method ( ) instanceof project coordinate ) { main panel . add item ( str , auto find ) ; } fill field values ( ) ; set content pane ( main panel ) ; }	construct the preference dialog .
public void add table value change listener ( table value change listener listener ) { if ( listener == null ) { return ; } m listeners . add ( listener ) ; }	add a listener for changes in the table ' s component values .
@ override public int print ( graphics g , page format page format , int page index ) { if ( page index > num ) { return ( no such page ) ; } else { d g2d = ( d ) g ; g2d . translate ( page format . get imageable x ( ) , page format . get imageable y ( ) ) ; double f height = page format . get imageable height ( ) ; double f width = page format . get imageable width ( ) ; int x max = num ; int y max = num ; for ( int i node = num ; i node < m . get nr of nodes ( ) ; i node ++ ) { if ( x max < m . get position x ( i node ) ) { x max = m . get position x ( i node ) ; } if ( y max < m . get position y ( i node ) ) { y max = m . get position y ( i node ) ; } } double f current scale = m f scale ; x max += m n padded node width + num ; if ( f width / x max < f height / y max ) { m f scale = f width / x max ; } else { m f scale = f height / y max ; } paint ( g2d ) ; m f scale = f current scale ; return ( page exists ) ; } }	implementation of printable , used for printing.
public linked hash map < pokemon , nickname pokemon response . result > bulk rename with pattern ( final string pattern , final bi consumer < nickname pokemon response . result , pokemon > per poke callback ) { final linked hash map < pokemon , nickname pokemon response . result > results = new linked hash map < > ( ) ; mons . for each ( null ) ; return results ; }	rename a bunch of pokemon based on a pattern.
public static assignment create default ( string ... variables ) { return create default ( arrays . as list ( variables ) ) ; }	creates an assignment with only none values for the variable labels given as argument .
private void on stop attack ( ) { attacking = null ; }	called when this entity stops attacking .
void calculate pressed ( action event e ) { if ( check edit conditional ( ) ) { return ; } if ( num conditionals > num ) { string c name = str ; conditional c = null ; for ( int i = num ; i < num conditionals ; i ++ ) { c name = cur logix . get conditional by number order ( i ) ; if ( c name != null ) { c = conditional manager . get by system name ( c name ) ; if ( c == null ) { log . error ( str + c name ) ; } else { c . calculate ( bool , null ) ; } } else { log . error ( str ) ; } } conditional table model . fire table data changed ( ) ; } }	responds to the calculate button in the edit logix window.
public static function alias new instance ( schema schema , int id , string name , string java class method , boolean force , boolean buffer result set to local temp ) { function alias alias = new function alias ( schema , id , name ) ; int paren = java class method . index of ( str ) ; int last dot = java class method . last index of ( str , paren < num ? java class method . length ( ) : paren ) ; if ( last dot < num ) { throw db exception . get ( error code . syntax error 1 , java class method ) ; } alias . class name = java class method . substring ( num , last dot ) ; alias . method name = java class method . substring ( last dot + num ) ; alias . buffer result set to local temp = buffer result set to local temp ; alias . init ( force ) ; return alias ; }	create a new alias based on a method name .
protected void update menu ( ) { boolean present ; boolean initializing ; boolean running ; boolean stopping ; boolean active ; if ( m == null ) return ; present = ( m != null ) ; initializing = present && m . is initializing ( ) ; running = present && m . is running ( ) ; stopping = present && m . is stopping ( ) ; active = initializing || running || stopping ; m . set enabled ( ! active ) ; m . set enabled ( ! active ) ; m . set enabled ( present && ( get current file ( ) != null ) ) ; m . set enabled ( present ) ; m . set enabled ( ! active ) ; m . set enabled ( present && ! active ) ; m . set enabled ( present && running ) ; for ( abstract experimenter menu item item : m . key set ( ) ) item . update ( this , m . get ( item ) ) ; }	updates the enabled / disabled state of the menu items .
@ not null @ c ( str ) public configuration builder add auto join group ( string group token or short name ) { auto join groups . add ( group token or short name ) ; return this ; }	adding group to auto join of users.
public boolean has value info ( ) { return ! receiver value . equals ( str ) || method argument values != null ; }	returns true if there are computed values info on one of the method arguments .
protected void drop car ( print writer file , car car , boolean is manifest ) { if ( is manifest ) { string buffer buf = new string buffer ( pad and truncate string ( setup . get drop car prefix ( ) , setup . get manifest prefix length ( ) ) ) ; string [ ] format = setup . get drop manifest message format ( ) ; boolean is local = is local move ( car ) ; if ( is local ) { buf = new string buffer ( pad and truncate string ( setup . get local prefix ( ) , setup . get manifest prefix length ( ) ) ) ; format = setup . get local manifest message format ( ) ; } drop car ( file , car , buf , format , is local , is manifest ) ; } else { string buffer buf = new string buffer ( pad and truncate string ( setup . get switch list drop car prefix ( ) , setup . get switch list prefix length ( ) ) ) ; string [ ] format = setup . get drop switch list message format ( ) ; boolean is local = is local move ( car ) ; if ( is local ) { buf = new string buffer ( pad and truncate string ( setup . get switch list local prefix ( ) , setup . get switch list prefix length ( ) ) ) ; format = setup . get local switch list message format ( ) ; } drop car ( file , car , buf , format , is local , is manifest ) ; } }	adds the car ' s set out string to the output file using the manifest or switch list format.
@ after method public void delete storage ( ) throws business exception , io , serialization exception { if ( null != storage data ) { if ( storage manager . get recording state ( ) == recording state . on ) { storage manager . stop recording ( ) ; } if ( ! storage manager . is storage closed ( storage data ) ) { storage manager . close storage ( storage data ) ; } storage manager . delete storage ( storage data ) ; storage data = null ; } assert that ( storage manager . get existing storages ( ) , is ( empty ( ) ) ) ; }	after processing to delete storage that might be created in the test .
public final void remove element at ( int i ) { if ( i > m first free ) system . arraycopy ( m map , i + num , m map , i , m first free ) ; else m map [ i ] = java . lang . integer . min value ; m first free -- ; }	deletes the component at the specified index.
protected int key on list ( string key , list < string > list ) { int ret = - num ; int index = num ; if ( list != null ) { for ( string list key : list ) { if ( list key . equals ignore case ( key ) ) { ret = index ; break ; } index ++ ; } } return ret ; }	figure out if the string key is in the provided list , and provide the location index of it is .
private boolean increment sentence ( ) throws io { if ( length == num ) return bool ; while ( bool ) { int start = iterator . current ( ) ; if ( start == break iterator . done ) return bool ; int end = iterator . next ( ) ; if ( end == break iterator . done ) return bool ; set next sentence ( start , end ) ; if ( increment word ( ) ) { return bool ; } } }	return true if there is a token from the buffer , or null if it is exhausted .
enumeration < crypto permission entry > permission elements ( ) { return permission entries . elements ( ) ; }	enumerate all the permission entries in this grantentry .
private static void populate access request ( access request access request ) { access request . set access license number ( props . get property ( license number ) ) ; access request . set user id ( props . get property ( user name ) ) ; access request . set password ( props . get property ( password ) ) ; }	populates the access request object .
public binary table ( header my header ) throws fits exception { long heap size l = my header . get long value ( pcount ) ; long heap offset l = my header . get long value ( theap ) ; if ( heap offset l > max integer value ) { throw new fits exception ( str ) ; } if ( heap size l > max integer value ) { throw new fits exception ( str ) ; } if ( heap size l - heap offset l > max integer value ) { throw new fits exception ( str ) ; } this . heap offset = ( int ) heap offset l ; int heap size = ( int ) heap size l ; int rwsz = my header . get int value ( naxi ) ; this . n row = my header . get int value ( naxi ) ; if ( this . heap offset > num ) { this . heap offset -= this . n row * rwsz ; } if ( this . heap offset < num || this . heap offset > heap size ) { throw new fits exception ( str ) ; } this . heap = new fits heap ( heap size - this . heap offset ) ; int n col = my header . get int value ( tfields ) ; this . row len = num ; for ( int col = num ; col < n col ; col ++ ) { this . row len += process col ( my header , col ) ; } header card card = my header . find card ( naxi ) ; card . set value ( string . value of ( this . row len ) ) ; my header . update line ( naxi , card ) ; }	create a binary table from given header information .
public static task context current ( ) { final deque < task context > stack = context stacks . get ( ) ; if ( stack == null ) { return null ; } return stack . peek last ( ) ; }	gets the current execution context for this thread from the stack .
public static byte [ ] concat ( final byte [ ] ... arrays ) { int total size = num ; for ( final byte [ ] array : arrays ) { total size += array . length ; } int start index = num ; final byte [ ] result = new byte [ total size ] ; for ( final byte [ ] array : arrays ) { system . arraycopy ( array , num , result , start index , array . length ) ; start index += array . length ; } return result ; }	concatenates byte arrays and returns the result .
public jk ( final string url , final string prefix ) { logger . info ( string . format ( str , url , prefix ) ) ; this . url = url ; this . prefix = prefix ; }	instantiates a new jk namespace .
public boolean is lifo ( ) { string cm = get costing method ( ) ; return cm != null && cm . equals ( costingmethod ) && costelementtype . equals ( get cost element type ( ) ) ; }	is lifo costing method.
public static void main ( string [ ] args ) throws exception { final string cfg = str ; final class < ? extends benchmark driver > benchmark = ignite sql query benchmark . class ; final int threads = num ; final boolean client driver node = bool ; final int extra nodes = num ; final int warm up = num ; final int duration = num ; final int range = num ; final boolean throughput latency probe = bool ; for ( int i = num ; i < extra nodes ; i ++ ) { ignite configuration node cfg = ignition . load spring bean ( cfg , str ) ; node cfg . set grid name ( str + i ) ; node cfg . set metrics log frequency ( num ) ; ignition . start ( node cfg ) ; } array list < string > args0 = new array list < > ( ) ; add arg ( args0 , str , threads ) ; add arg ( args0 , str , warm up ) ; add arg ( args0 , str , duration ) ; add arg ( args0 , str , range ) ; add arg ( args0 , str , benchmark . get simple name ( ) ) ; add arg ( args0 , str , str ) ; add arg ( args0 , str , cfg ) ; if ( throughput latency probe ) add arg ( args0 , str , str ) ; if ( client driver node ) args0 . add ( str ) ; benchmark driver start up . main ( args0 . to array ( new string [ args0 . size ( ) ] ) ) ; }	starts nodes / driver in single jvm for quick benchmarks testing .
public static boolean safe navigation operator defined ( string nested field name ) { if ( nested field name . contains ( safe navigation operator ) ) if ( ! nested field name . starts with ( safe navigation operator ) ) throw new mapping exception ( str ) ; else return bool ; return bool ; }	it checks the presence of the elvis operator and how it is used .
public static boolean is enabled ( ) { if ( s enabled == null ) { s enabled = detect enabled ( ) ; } return s enabled . boolean value ( ) ; }	checks the current variations parameters associated with the active group as well as the chrome preference to determine if the service is enabled .
public boolean intersects ( geo bounds other ) { boolean rv = bool ; for ( d r1 : rects ) { for ( d r2 : other . rects ) { rv = r1 . intersects ( r2 ) ; if ( rv ) { break ; } } if ( rv ) { break ; } } return rv ; }	determines if this bounds intersects the other bounds .
public void dispose ( ) { m listeners . clear ( ) ; }	clear listeners to prepare for garbage collection.
public void open image gallery ( final action listener response ) { open gallery ( response , display . gallery image ) ; }	opens the device image gallery.
private void read object ( final java . io . object input stream in ) throws io , class not found exception { inequality symbol = ( string ) in . read object ( ) ; time stamp = in . read long ( ) ; }	deserialize the state of the object .
string pop base indentifier ( ) { return ( string ) m base identifiers . pop ( ) ; }	pop a base uri from the stack .
@ nullable public static file resolve drawable ( @ not null render resources resources , @ nullable resource value drawable , @ not null project project ) { if ( drawable != null ) { drawable = resources . resolve res value ( drawable ) ; } if ( drawable == null ) { return null ; } string result = drawable . get value ( ) ; state list state list = resolve state list ( resources , drawable , project ) ; if ( state list != null ) { list < state list state > states = state list . get states ( ) ; if ( ! states . is empty ( ) ) { state list state state = states . get ( states . size ( ) - num ) ; result = state . get value ( ) ; } } if ( result == null ) { return null ; } final file file = new file ( result ) ; return file . is file ( ) ? file : null ; }	tries to resolve the given resource value to an actual drawable bitmap file.
public static void delete ( string code , jda jda ) { invite invite = resolve ( code ) ; if ( invite == null ) throw new illegal argument exception ( str + str + code ) ; delete ( invite , jda ) ; }	tells discord to delete the specified invite from the server.
private void update header separator ( ) { final string best date time pattern = date format utils . get best date time pattern ( m current locale , ( m is24 hour view ) ? str : str ) ; final string separator text ; final char [ ] hour formats = { str , str , str , str } ; int h index = last index of any ( best date time pattern , hour formats ) ; if ( h index == - num ) { separator text = str ; } else { separator text = character . to string ( best date time pattern . char at ( h index + num ) ) ; } m separator view . set text ( separator text ) ; }	the time separator is defined in the unicode cldr and cannot be supposed to be " : ".
protected void connection failed ( channel failed channel , io cause ) { failure cause = io . create ( cause ) ; channel = failed channel ; connected . set ( bool ) ; connect latch . count down ( ) ; }	called when the transport connection failed and an error should be returned .
public void test missing application ( ) throws exception { m enabled . add ( launcher activity detector . issue more than one launcher ) ; m enabled . add ( launcher activity detector . issue missing launcher ) ; m enabled . add ( launcher activity detector . issue launcher activity in library ) ; string expected = str ; string result = lint project ( xml ( fn android manifest xml , str + str + str + str + str ) ) ; assert equals ( expected , result ) ; }	test that a manifest without an application tag has no warnings .
public string to string ( ) { array list fields = new array list ( num ) ; fields . add ( codebase ) ; fields . add ( policy ) ; fields . add ( classpath ) ; fields . add ( impl class name ) ; fields . add ( ( ( server config args == null ) ? null : arrays . as list ( server config args ) ) ) ; fields . add ( life cycle ) ; fields . add ( service preparer ) ; return fields . to string ( ) ; }	prints out a field summary.
public drawable create from path ( string path name ) { return drawable . create from path ( path name ) ; }	create a drawable from file path name .
@ override public void parse ( reader reader , string base uri ) throws io , rdf , rdf { if ( reader == null ) { throw new illegal argument exception ( str ) ; } if ( base uri == null ) { throw new illegal argument exception ( str ) ; } input source input source = new input source ( reader ) ; input source . set system id ( base uri ) ; parse ( input source ) ; }	parses the data from the supplied reader , using the supplied baseuri to resolve any relative uri references .
final public void print ( double v ) { try { out . print ( v ) ; } catch ( io e ) { log . log ( level . fine , e . to string ( ) , e ) ; } }	prints a double followed by a newline .
public static boolean is empty ( string string ) { return string == null || string . length ( ) == num ; }	returns true if the string is null or empty .
public static boolean is xm ( string name ) { int length = name . length ( ) ; if ( length == num ) return bool ; int i = num ; char ch = name . char at ( num ) ; if ( ! is xm ( ch ) ) { if ( length > num && is xm ( ch ) ) { char ch2 = name . char at ( num ) ; if ( ! xml . is low surrogate ( ch2 ) || ! is xm ( xml . supplemental ( ch , ch2 ) ) ) { return bool ; } i = num ; } else { return bool ; } } while ( i < length ) { ch = name . char at ( i ) ; if ( ! is xm ( ch ) ) { if ( ++ i < length && is xm ( ch ) ) { char ch2 = name . char at ( i ) ; if ( ! xml . is low surrogate ( ch2 ) || ! is xm ( xml . supplemental ( ch , ch2 ) ) ) { return bool ; } } else { return bool ; } } ++ i ; } return bool ; }	check to see if a string is a valid name according to [ 5 ] in the xml 1 . 1 recommendation.
public void reset ( ) { m expected events . clear ( ) ; m expected interrupt = bool ; m replaying = bool ; }	resets this instance so it can be reused .
string generate digest ( file file dir , string file name ) { final string algorithm = str ; input stream file stream = null ; digest input stream d = null ; try { file stream = get file stream ( file dir , file name ) ; message digest md = message digest . get instance ( algorithm ) ; d = new digest input stream ( file stream , md ) ; byte [ ] buffer = new byte [ num ] ; while ( d . read ( buffer ) != - num ) { } return to hex string ( md . digest ( ) ) ; } catch ( no such algorithm exception e ) { return algorithm + str ; } catch ( io e ) { c . e ( e ) ; } finally { stream util . close stream ( d ) ; stream util . close stream ( file stream ) ; } return str ; }	generate a sha1sum digest for a file.
private void initialize name goals ( map < test case , set < test fitness function > > test to goals ) { for ( map . entry < test case , set < test fitness function > > entry : test to goals . entry set ( ) ) { set < test fitness function > goals = new linked hash set < > ( ) ; list < test fitness function > top goals = get top goals ( entry . get value ( ) ) ; if ( top goals . is empty ( ) ) { } else if ( top goals . size ( ) <= max similar goals ) { for ( test fitness function goal : top goals ) { goals . add ( goal ) ; string goal name = get test name ( entry . get key ( ) , goals ) ; if ( goal name . length ( ) > max chars ) { goals . remove ( goal ) ; break ; } } } else { goals . add ( choose representative goal ( entry . get key ( ) , top goals ) ) ; } test to goals . put ( entry . get key ( ) , goals ) ; } }	initially , set to the top level goals.
public boolean is parse robots txt ( ) { return parse robots txt ; }	checks if the spider should parse the robots.
public string byte array to base64 ( byte [ ] bytes ) { return base64 . encode base64 string ( bytes ) ; }	get a byte array ' s base64 endcoding.
private void validate index storage ( ) { closeable iterator < index store entry > iterator = null ; try { array list structure list = new array list ( ) ; iterator = index data structure . iterator ( null ) ; while ( iterator . has next ( ) ) { index store entry ie = iterator . next ( ) ; if ( entries contains ( ie ) ) { structure list . add ( ie ) ; } else { fail ( str + ie ) ; } } assert equals ( str , entries . size ( ) , structure list . size ( ) ) ; } finally { if ( iterator != null ) { iterator . close ( ) ; } } }	iterates through the index storage structure and compares size with the test list.
private int quantize ( long x ) { return num + ( int ) math . floor ( math . log ( x ) / math . log ( quantization base ) ) ; }	logarithmically quantizes raw counts.
public static boolean validate output directory ( file directory ) { if ( directory . exists ( ) ) { diagnostic . error ( error type . directory exists , directory . get path ( ) ) ; return bool ; } return bool ; }	test if the supplied directory already exists .
@ override public void on web socket close ( int status code , string reason ) { super . on web socket close ( status code , reason ) ; log . info ( str , peer id , integer . to string ( status code ) + str + reason ) ; store . unsubscribe ( handle ) ; }	called by jetty when the websocket connection is gracefully closed due to a ' close ' event .
@ override public double log density ( double value ) { update boundaries and or weights ( ) ; if ( m == null ) { return math . log ( double . min value ) ; } int index = arrays . binary search ( m , value ) ; if ( ( index == - num ) || ( index == - m . length - num ) ) { double val = num ; if ( index == - num ) { val = m tm . first key ( ) - value ; } else { val = value - m tm . last key ( ) ; } return ( const - math . log ( m ) - num * ( val * val / ( m * m ) ) ) - math . log ( m + num ) ; } if ( index == m . length - num ) { index -- ; } else { if ( index < num ) { index = - index - num ; } } double width = m [ index + num ] - m [ index ] ; double dens smeared out = num / ( ( m + num ) * ( m [ m . length - num ] - m [ num ] ) ) ; if ( m [ index ] <= num ) { return math . log ( dens smeared out ) ; } else { return math . log ( dens smeared out + m [ index ] / ( ( m + num ) * width ) ) ; } }	returns the natural logarithm of the density estimate at the given point .
public void draw point ( graphics sc , i p ) { double x1 = p . get x ( ) ; double y1 = p . get y ( ) ; sc . draw oval ( ( int ) x1 - num , ( int ) y1 - num , num , num ) ; }	core functionality to draw a point in the canvas .
private static int compute capacity ( final int expected size ) { if ( expected size == num ) { return num ; } final int capacity = ( int ) fast math . ceil ( expected size / load factor ) ; final int power of two = integer . highest one bit ( capacity ) ; if ( power of two == capacity ) { return capacity ; } return next power of two ( capacity ) ; }	compute the capacity needed for a given size .
public void add callback ( callback callback ) { if ( ! m callbacks . contains ( callback ) ) { m callbacks . add ( callback ) ; } }	add a callback to our alexaaudioplayer , this is added to our list of callbacks.
public j ( document builder setting [ ] settings ) throws dom { super ( settings ) ; try { class loader class loader = class loader . get system class loader ( ) ; class tidy class = class loader . load class ( str ) ; tidy constructor = tidy class . get constructor ( no classes ) ; parse dom = tidy class . get method ( str , new class [ ] { java . io . input stream . class , java . io . output stream . class } ) ; dom impl = new j dom ( ) ; } catch ( exception ex ) { throw new dom ( ex , null ) ; } if ( settings != null ) { for ( int i = num ; i < settings . length ; i ++ ) { } } }	creates a implementation of domtestdocumentbuilderfactory using jtidy ' s html parser and dom implementation.
public void enqueue ( terminating runnable r ) { synchronized ( queue ) { queue . add ( r ) ; queue . notify all ( ) ; } }	add an object to the queue of threads to run.
protected void do process message ( dtls message ) throws handshake exception , general security exception { }	does the specific processing of a message received from a peer in the course of an ongoing handshake.
void disconnect ( ) { synchronized ( lock ) { disconnected = bool ; lock . notify all ( ) ; } }	disconnect this stream from all connection activity .
public simple rate limiter ( double mb per sec ) { set mb ( mb per sec ) ; last ns = system . nano time ( ) ; }	mbpersec is the mb / sec max io rate.
private long wc ( string text ) { long wc = num ; string [ ] lines = text . split ( str ) ; for ( string line : lines ) { wc += line . split ( str ) . length ; } return wc ; }	count the words of a text file .
public boolean unbind ( ) { boolean worked = bool ; if ( m rx thread == null ) worked = bool ; else m stop rx = bool ; return worked ; }	shutdown our receive thread.
public void register ( schedule schedule ) { integer old size = integer . value of ( schedule hash table . size ( ) ) ; schedule hash table . put ( schedule . get id ( ) , schedule ) ; int id = integer . parse int ( schedule . get id ( ) ) ; if ( id > id ) { id = id ; } set dirty and fire property change ( listlength changed property , old size , integer . value of ( schedule hash table . size ( ) ) ) ; }	remember a namedbean object created outside the manager .
public final void write maple ascii string ( final string s ) { write short ( ( short ) s . length ( ) ) ; write ascii string ( s ) ; }	writes a maple - convention ascii string to the stream .
public static boolean has uid ( string classname ) { boolean result ; try { result = has uid ( class . for name ( classname ) ) ; } catch ( exception e ) { result = bool ; } return result ; }	checks whether the given class contains a serialversionuid .
public static boolean remove directory ( string path to dir ) { return delete recursive ( new file ( path to dir ) ) ; }	remove directory and all its sub - resources with specified path.
public static final boolean validate group name ( string s group name ) { if ( s group name . length ( ) == num ) { return bool ; } return s group name . matches ( str ) ; }	validates a duplex group name.
private void init ( configuration conf ) { try { if ( this . id > num ) { default listener d = new default listener ( ) ; d . upgrade ( conf , this ) ; } if ( ! x . is empty ( listener ) ) { string name = listener ; if ( name != null ) { try { class < ? > c = class . for name ( name , bool , class loader ) ; object o = c . new instance ( ) ; if ( o instanceof i ) { log . info ( str + name ) ; i l = ( i ) o ; l . upgrade ( conf , this ) ; l . on start ( conf , this ) ; } } catch ( throwable e ) { log . error ( this . name + str + name , e ) ; } } } } catch ( throwable e ) { log . error ( e . get message ( ) , e ) ; } }	invoke the life listener of the module.
private boolean is scan root available ( url url ) { for ( scan root scan root : pending scan roots ) { if ( url . equals ( scan root . get url ( ) ) ) return bool ; } return bool ; }	adds a scan listener .
public sequential listener manager add listener executor ( int index , listener listener , listener executor executor ) { if ( listeners . contains ( listener ) ) throw new illegal argument exception ( str + listener ) ; listeners . add ( index , listener ) ; listener executors . add ( index , executor ) ; return this ; }	add a listener at the given index to be executed by the supplied executor.
private boolean has as parent ( i child , i direct parent ) { i parent = child ; while ( parent != null ) { if ( parent == direct parent ) return bool ; parent = parent . get parent ( ) ; } return bool ; }	test if directparent is in parent - chain .
public void clear markers ( ) { m google map . clear ( ) ; markers . clear ( ) ; }	clears all markers from the map .
@ override public double cloudlet submit ( cloudlet cl ) { return cloudlet submit ( cl , num ) ; }	receives an cloudlet to be executed in the vm managed by this scheduler .
public void verifying token ( ) { set token info ( str ) ; verify token . set enabled ( bool ) ; }	change status to verifying token .
public certificate build certificate ( string cert string ) throws invalid certificate { try { string base64 cert = format certificate ( cert string ) ; input stream in bytes = new byte array input stream ( base64 cert . get bytes ( ) ) ; certificate factory cf = certificate factory . get instance ( str ) ; assert in bytes . available ( ) > num ; certificate certificate = cf . generate certificate ( in bytes ) ; in bytes . close ( ) ; return certificate ; } catch ( exception e ) { log . debug ( str + e + str ) ; throw fault util . invalid certificate ( str ) ; } }	buildcertificate build a certificate from a base64 formatted , pkcs # 7 encoding of the certificate.
private page leaf impl compact ( table kelp table ) { long now = current time . current time ( ) / num ; set < page leaf entry > entries = fill entries ( table ) ; array list < block leaf > blocks = new array list < > ( ) ; block leaf block = new block leaf ( get id ( ) ) ; blocks . add ( block ) ; row row = table . row ( ) ; for ( page leaf entry entry : entries ) { if ( entry . get code ( ) != insert && entry . get expires ( ) <= now ) { continue ; } while ( ! block . add entry ( row , entry ) ) { block = new block leaf ( get id ( ) ) ; blocks . add ( block ) ; } } page leaf impl new page = new page leaf impl ( get id ( ) , get next id ( ) , get sequence ( ) , table , get min key ( ) , get max key ( ) , blocks ) ; new page . validate ( table ) ; new page . to sorted ( table ) ; if ( is dirty ( ) ) { new page . set dirty ( ) ; } if ( stub != null ) { stub . copy to compact ( new page ) ; } return new page ; }	compacts the leaf by rebuilding the delta entries and discarding obsolete removed entries .
public sabres query ( class < t > clazz ) { this . clazz = clazz ; name = clazz . get simple name ( ) ; inner queries = null ; }	constructs a query for a sabresobject subclass type.
public string backup now ( string backup file prefix ) throws mc exception , io { logger . debug ( str ) ; return backup . backup ( backup file prefix ) ; }	call this method to run immediate system backup.
public boolean is clustered host ( storage system storage , list < initiator > initiators ) { return is clustered host ( storage , initiators , null ) ; }	validates if the host is part of a cluster on xiv system . uses initiators to find out the hosts.
public static list < substring replacer match rule > match rules from internal ( string match replace details , instances input structure , string status message prefix , logger log , environment env ) { list < substring replacer match rule > match rules = new array list < substring replacer match rule > ( ) ; string [ ] mr parts = match replace details . split ( str ) ; for ( string p : mr parts ) { substring replacer match rule mr = new substring replacer match rule ( p . trim ( ) ) ; mr . m status message prefix = status message prefix ; mr . m logger = log ; mr . init ( env , input structure ) ; match rules . add ( mr ) ; } return match rules ; }	get a list of match rules from an internally encoded match specification.
public static object [ ] merge and extract params ( map < string , ? extends object > global config , map < string , ? extends object > local params , collection < string > ignore params , map < string , external resource description > resources ) { set < string > unique params = new hash set < > ( ) ; unique params . add all ( local params . key set ( ) ) ; unique params . add all ( global config . key set ( ) ) ; if ( ignore params != null ) { unique params . remove all ( ignore params ) ; } object [ ] params = new object [ resources . size ( ) * num + unique params . size ( ) * num ] ; int i = num ; for ( entry < string , external resource description > entry : resources . entry set ( ) ) { params [ i ++ ] = entry . get key ( ) ; params [ i ++ ] = entry . get value ( ) ; } for ( string key : unique params ) { params [ i ++ ] = key ; if ( local params . contains key ( key ) ) { params [ i ++ ] = cpe builder utils . convert to parameter value ( local params . get ( key ) ) ; } else { params [ i ++ ] = cpe builder utils . convert to parameter value ( global config . get ( key ) ) ; } } return params ; }	merges local parameters and resources with global parameters , with local parameters taking precedence over global parameters where there is a conflict.
public void store properties ( string artifact , string version , properties props ) throws io { path properties file = get properties file ( artifact , version ) ; path dir = properties file . get parent ( ) ; if ( ! files . exists ( dir ) ) { files . create directories ( dir ) ; } try ( output stream out = new buffered output stream ( new output stream ( properties file ) ) ) { props . store ( out , null ) ; } }	stores the properties of the artifact .
public static string make descriptor ( class [ ] params , class ret type ) { string buffer sbuf = new string buffer ( ) ; sbuf . append ( str ) ; for ( int i = num ; i < params . length ; i ++ ) make desc ( sbuf , params [ i ] ) ; sbuf . append ( str ) ; if ( ret type != null ) make desc ( sbuf , ret type ) ; return sbuf . to string ( ) ; }	makes a descriptor for a given method .
public boolean is loggable ( level lev ) { return logger . is loggable ( lev ) ; }	verify if logging is enabled at that particular level .
@ override public boolean supports knowledge ( ) { return bool ; }	by default , algorithm do not support knowledge.
@ data provider public object [ ] [ ] invalid id provider ( ) { return new object [ ] [ ] { new object [ ] { str , str , http status . sc not found } , new object [ ] { str , str , http status . sc not found } , new object [ ] { str , str , http status . sc internal server error } , new object [ ] { str , str , http status . sc internal server error } , new object [ ] { str , str , http status . sc internal server error } } ; }	provides invalid ids and their expected results .
public final static header element parse header element ( final string value , header value parser parser ) throws parse exception { if ( value == null ) { throw new illegal argument exception ( str ) ; } if ( parser == null ) parser = basic header value parser . default ; char array buffer buffer = new char array buffer ( value . length ( ) ) ; buffer . append ( value ) ; parser cursor cursor = new parser cursor ( num , value . length ( ) ) ; return parser . parse header element ( buffer , cursor ) ; }	parses an element with the given parser .
private void clear state ( ) { allocated resources . clear ( ) ; requests to count map . clear ( ) ; requests queue . clear ( ) ; }	clears all the state variables performed when there are no more unfulfilled requests.
public static double [ ] vector box corner ( double [ ] center , double [ ] result , double distance , boolean upper right ) { if ( result == null || result . length != center . length ) { result = new double [ center . length ] ; } if ( upper right == bool ) { distance = - distance ; } distance = sin pi div 4 * distance ; for ( int i = num ; i < center . length ; i ++ ) { result [ i ] = center [ i ] + distance ; } return result ; }	return the coordinates of a vector that is the corner of a box ( upper right or lower left ) , assuming a rectangular coordinate system.
public void to array ( int [ ] array ) { system . arraycopy ( data , num , array , num , size ) ; }	convert this list to an array.
public fixed secure random ( boolean int pad , byte [ ] [ ] values ) { byte array output stream b out = new byte array output stream ( ) ; for ( int i = num ; i != values . length ; i ++ ) { try { b out . write ( values [ i ] ) ; } catch ( io e ) { throw new illegal argument exception ( str ) ; } } data = b out . to byte array ( ) ; if ( int pad ) { int pad = data . length % num ; } }	pad the data on integer boundaries.
@ override protected void ensure number of columns ( int number of columns ) { if ( data . length >= number of columns ) { return ; } long [ ] new data = new long [ number of columns ] ; system . arraycopy ( data , num , new data , num , data . length ) ; data = new data ; }	creates a new array of the given size if necessary and copies the data into the new array .
public void invoke hook spout ack ( object message id , long complete latency ns ) { if ( task hooks . size ( ) != num ) { spout ack info ack info = new spout ack info ( message id , get this task id ( ) , complete latency ns / constants . milliseconds to nanoseconds ) ; for ( i task hook : task hooks ) { task hook . spout ack ( ack info ) ; } } }	task hook called in spout every time a tuple gets acked.
stub skeleton writer ( batch environment env , remote class remote class , stub version version ) { this . env = env ; this . remote class = remote class ; this . version = version ; stub class name = util . binary name of ( remote class . class doc ( ) ) + str ; skeleton class name = util . binary name of ( remote class . class doc ( ) ) + str ; int i = stub class name . last index of ( str ) ; package name = ( i != - num ? stub class name . substring ( num , i ) : str ) ; stub class simple name = stub class name . substring ( i + num ) ; skeleton class simple name = skeleton class name . substring ( i + num ) ; remote methods = remote class . remote methods ( ) ; method field names = name method fields ( remote methods ) ; }	creates a stubskeletonwriter instance for the specified remote implementation class.
public void put ( string key , object value , boolean error on fail ) { if ( value == null ) { put null ( key ) ; } else if ( value instanceof boolean ) { put ( key , ( boolean ) value ) ; } else if ( value instanceof byte ) { put ( key , ( byte ) value ) ; } else if ( value instanceof double ) { put ( key , ( double ) value ) ; } else if ( value instanceof float ) { put ( key , ( float ) value ) ; } else if ( value instanceof integer ) { put ( key , ( integer ) value ) ; } else if ( value instanceof long ) { put ( key , ( long ) value ) ; } else if ( value instanceof short ) { put ( key , ( short ) value ) ; } else if ( value instanceof string ) { put ( key , ( string ) value ) ; } else if ( value instanceof byte [ ] ) { put ( key , ( byte [ ] ) value ) ; } else if ( error on fail ) { throw new unsupported operation exception ( str + value . get class ( ) ) ; } }	add a value of unknown type to the set if it is one of the accepted types.
private void step ( ) { casings . for each ( null ) ; casings . for each ( null ) ; casings . for each ( null ) ; step pipes ( ) ; step forwarders ( ) ; }	advance all computer parts by one step .
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return host ; case num : return port ; case num : return id ; case num : return state ; case num : return timestamp ; case num : return version ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
private static d xdistance old ( d matrix , int norm ) { return null ; }	constructs and returns the distance matrix of the given matrix.
public map < string , string > map ( ) { return hash map ( ) ; }	returns a shallow copy of the underlying map as a generic map .
private static void add query fields ( document doc , node parent , collection < pojo field > fields ) { if ( ! fields . is empty ( ) ) { element prop = add property ( doc , parent , str , null ) ; element map = add element ( doc , prop , str , str , str ) ; for ( pojo field field : fields ) add element ( doc , map , str , str , field . java name ( ) , str , generator utils . box primitive type ( field . java type name ( ) ) ) ; } }	add query fields to xml document .
public void test simple valid string ( ) throws exception { json factory json f = new json factory ( ) ; data format detector detector = new data format detector ( json f ) ; final string json = str ; data format matcher matcher = detector . find format ( new byte array input stream ( json . get bytes ( str ) ) ) ; assert true ( matcher . has match ( ) ) ; assert equals ( str , matcher . get matched format name ( ) ) ; assert same ( json f , matcher . get match ( ) ) ; assert equals ( match strength . weak match , matcher . get match strength ( ) ) ; json parser jp = matcher . create parser with match ( ) ; assert token ( json token . value string , jp . next token ( ) ) ; assert equals ( str , jp . get text ( ) ) ; assert null ( jp . next token ( ) ) ; jp . close ( ) ; }	while json string is not a strong match alone , it should be detected unless some better match is available.
protected boolean do start ( ) { if ( ! lifecycle . is active ( ) ) { return bool ; } if ( ! is enable ( ) ) { return bool ; } int starting count = starting count . get and increment ( ) ; int thread count = thread count . get ( ) + starting count ; if ( thread max < thread count ) { starting count . decrement and get ( ) ; on thread max ( ) ; return bool ; } else if ( is idle too low ( starting count ) ) { return bool ; } else { starting count . decrement and get ( ) ; return bool ; } }	checks if the launcher should start another thread .
@ override public string global info ( ) { return str + str ; }	global info for this bean.
public static long stream skip ( input stream stream , long count ) throws io { long skipped = stream . skip ( count ) ; if ( skipped < num ) { final byte [ ] temp = new byte [ num ] ; skipped = stream . read ( temp , num , math . min ( ( int ) count , num ) ) ; } return skipped ; }	a wrapper for stream . skip that is guaranteed to skip at least 1 byte when called.
public boolean managed object exists ( managed object path < ? , ? > path ) { dn target dn = dn . create ( path ) ; try { return config repository . get entry ( target dn ) != null ; } catch ( config exception e ) { return bool ; } }	determines whether the named managed object exists .
public vector2 rotate ( double theta ) { double cos = math . cos ( theta ) ; double sin = math . sin ( theta ) ; double x = this . x ; double y = this . y ; this . x = x * cos - y * sin ; this . y = x * sin + y * cos ; return this ; }	rotates about the origin .
public void remove permission ( permission type permission ) { removed permissions . add ( permission ) ; }	queues the given permission to be removed.
static void export prefs ( preferences prefs , output stream stream , boolean with sub tree ) throws io , backing store exception { indent = - num ; buffered writer out = new buffered writer ( new output stream writer ( stream , str ) ) ; out . write ( header ) ; out . new line ( ) ; out . new line ( ) ; out . write ( doctype ) ; out . write ( str ) ; out . write ( prefs dtd name ) ; out . write ( str ) ; out . new line ( ) ; out . new line ( ) ; flush start tag ( str , new string [ ] { str } , new string [ ] { string . value of ( xml version ) } , out ) ; flush start tag ( str , new string [ ] { str } , new string [ ] { prefs . is user node ( ) ? str : str } , out ) ; flush empty element ( str , out ) ; string tokenizer ancestors = new string tokenizer ( prefs . absolute path ( ) , str ) ; export node ( ancestors , prefs , with sub tree , out ) ; flush end tag ( str , out ) ; flush end tag ( str , out ) ; out . flush ( ) ; out = null ; }	utilities for preferences export.
protected void store in profiles map ( client client ) { set parent set = client . get properties ( parent id ) ; string client type = client . get client type ( ) ; map m = get styles profile map ( client type , parent set ) ; if ( m != null ) { m . put ( client type , client ) ; } return ; }	adds the client to its appropriate baseprofilemap & stylemap.
public void test bug4808 ( ) throws exception { mysql connection pool data source ds = new mysql connection pool data source ( ) ; ds . set url ( base test case . db url ) ; pooled connection close me twice = ds . get pooled connection ( ) ; close me twice . close ( ) ; close me twice . close ( ) ; }	tests fix for bug # 4808 - calling.
public void test compute z n ( ) { geometry linear geom = read ( str ) ; length indexed line indexed line = new length indexed line ( linear geom ) ; double proj index = indexed line . project ( new coordinate ( num , num ) ) ; coordinate proj pt = indexed line . extract point ( proj index ) ; assert true ( double . is na n ( proj pt . z ) ) ; }	tests that if the input does not have z ordinates , neither does the output .
public static int option length ( string option ) { if ( option . equals ( str ) ) return num ; if ( option . equals ( str ) ) return num ; if ( option . equals ( str ) ) return num ; return num ; }	method called from the javadoc environment to determint the options length.
public static float buffer create float buffer ( float [ ] coords ) { byte buffer bb = byte buffer . allocate direct ( coords . length * sizeof float ) ; bb . order ( byte order . native order ( ) ) ; float buffer fb = bb . as float buffer ( ) ; fb . put ( coords ) ; fb . position ( num ) ; return fb ; }	allocates a direct float buffer , and populates it with the float array data .
public int stream ex remove ( int predicate predicate ) { return filter ( predicate . negate ( ) ) ; }	returns a stream consisting of the elements of this stream that don ' t match the given predicate.
static void send raw line ( pirc bot bot , buffered writer bwriter , string line ) { if ( line . length ( ) > bot . get max line length ( ) - num ) { line = line . substring ( num , bot . get max line length ( ) - num ) ; } synchronized ( bwriter ) { try { bwriter . write ( line + str ) ; bwriter . flush ( ) ; } catch ( exception e ) { } } }	a static method to write a line to a bufferedoutputstream and then pass the line to the log method of the supplied pircbot instance .
entry kill ( ) { entry entry ; for ( int i = entries . size ( ) - num ; i >= num ; i -- ) { entry = entries . get ( i ) ; if ( ! entry . dead ) { entry . dead = bool ; return entry ; } } throw new illegal state exception ( str ) ; }	kill the latest alive entry.
protected void uninstall components ( ) { if ( scrollable tab layout enabled ( ) ) { tab pane . remove ( tab scroller . viewport ) ; tab pane . remove ( tab scroller . scroll forward button ) ; tab pane . remove ( tab scroller . scroll backward button ) ; tab scroller = null ; } }	removes any installed subcomponents from the jtabbedpane.
public void reset ( ) { forms = null ; }	clears out any references to elements or items created by this factory so far .
public static map < string , string > populate request properties ( map < string , string > request properties , int body length , media type content type , media type accept type ) { map < string , string > properties ; if ( request properties == null || request properties . is empty ( ) ) { properties = new hash map < > ( ) ; } else { properties = new hash map < > ( request properties ) ; } if ( accept type != null ) { properties . put ( header names . accept , accept type . to string ( ) ) ; } if ( content type != null ) { properties . put ( header names . content type , content type . to string ( ) ) ; } if ( body length > - num ) { properties . put ( header names . content length , string . value of ( body length ) ) ; } return properties ; }	util method for first populating request properties before execution .
private void check protocol already exists ( set < string > protocols , string protocol type ) { if ( ! protocols . contains ( protocol type ) ) { protocols . add ( protocol type ) ; } }	verify whether protocoltype already exists or not.
private static char v ( jni env , int obj jref , int method id , address arg address ) throws exception { if ( trace jni ) vm . sys write ( str ) ; runtime entrypoints . check jni gc ( ) ; try { object obj = env . get jni ( obj jref ) ; object return obj = jni . invoke with var arg ( obj , method id , arg address , type reference . char , bool ) ; return reflection . unwrap char ( return obj ) ; } catch ( throwable unexpected ) { if ( trace jni ) unexpected . print stack trace ( system . err ) ; env . record exception ( unexpected ) ; return num ; } }	callcharmethodv : invoke a virtual method that returns a char value.
public void test constr string with exponent with point3 ( ) { string a = str ; int a scale = num ; big integer b a = new big integer ( str ) ; big decimal a number = new big decimal ( a ) ; assert equals ( str , b a , a number . unscaled value ( ) ) ; assert equals ( str , a scale , a number . scale ( ) ) ; }	new bigdecimal ( string value ) ; value contains both exponent and decimal point.
public static boolean is composition playlist ( resource byte range provider resource byte range provider ) throws io { return imf . is composition playlist ( resource byte range provider ) ; }	a method that confirms if the inputstream corresponds to a composition document instance .
public static master private key decrypt ( string passphrase , byte [ ] encrypted ) throws hyper ledger exception { try { byte [ ] key = s . generate ( passphrase . get bytes ( str ) , bitcoin seed , num , num , num , num ) ; secret key spec keyspec = new secret key spec ( key , str ) ; cipher cipher = cipher . get instance ( str , str ) ; byte [ ] iv = arrays . copy of range ( encrypted , num , num ) ; byte [ ] data = arrays . copy of range ( encrypted , num , encrypted . length ) ; cipher . init ( cipher . decrypt mode , keyspec , new iv parameter spec ( iv ) ) ; return master private key . parse ( new string ( cipher . do final ( data ) ) ) ; } catch ( unsupported encoding exception | invalid algorithm parameter exception | no such padding exception | no such provider exception | no such algorithm exception | invalid key exception | bad padding exception | illegal block size exception e ) { throw new hyper ledger exception ( e ) ; } }	re - create a masterprivatekey from encrypted serialization.
protected boolean before release ( ) { return deque . size ( ) < max size ; }	called before releasing an object , returns true if the object should be recycled and false otherwise .
public void reset ( ) { system . arraycopy ( initial state , num , chain , num , chain . length ) ; ubi init ( param type message ) ; }	reset the engine to the initial state ( with the key and any pre - message parameters , ready to accept message input .
public synchronized void add ur ( list < url > urls ) { for ( url url : urls ) super . add url ( url ) ; array list search list = new array list ( ) ; search list . add all ( search path ) ; search list . add all ( urls ) ; search path = collections . unmodifiable list ( search path ) ; }	appends the specified urls to the list of urls to search for classes and resources .
protected byte [ ] http get ( final string url ) { http get http request = null ; http response http response = null ; closeable http client client = null ; try { final uri uri = new uri ( url . trim ( ) ) ; http request = new http get ( uri ) ; if ( content type != null ) { http request . set header ( content type , content type ) ; } client = get http client ( url ) ; http response = get http response ( client , http request , url ) ; final byte [ ] returned bytes = read http response ( url , http response ) ; return returned bytes ; } catch ( uri e ) { throw new dss ( e ) ; } finally { try { if ( http request != null ) { http request . release connection ( ) ; } if ( http response != null ) { entity utils . consume quietly ( http response . get entity ( ) ) ; } } finally { close client ( client ) ; } } }	this method retrieves data using http or https protocol and ' get ' method .
@ override public string to string ( ) { return as string ; }	this method returns the restriction as a string .
public final int read char ( ) throws io { if ( read encoding != null ) { int ch = read encoding . read ( ) ; return ch ; } if ( read length <= read offset ) { if ( ! read buffer ( ) ) return - num ; } return read buffer [ read offset ++ ] & num ; }	reads a character from the stream , returning - 1 on end of file .
public void write exif ( string jpeg file name , string exif out file name ) throws file not found exception , io { if ( jpeg file name == null || exif out file name == null ) { throw new illegal argument exception ( null argument string ) ; } input stream is = null ; try { is = new file input stream ( jpeg file name ) ; write exif ( is , exif out file name ) ; } catch ( io e ) { close silently ( is ) ; throw e ; } is . close ( ) ; }	writes the tags from this exifinterface object into a jpeg file , removing prior exif tags .
public void exec non query ( string sql , string [ ] selection args ) { for ( int i = num , count = selection args . length ; i < count ; i ++ ) sql = sql . replace first ( str , selection args [ i ] ) ; log utils . d ( sql ) ; database . exec sql ( sql ) ; }	execute non query sql with selectionargs , will replace ? s with selectionargs .
public d ( j parent , string title , general subtree general subtree ) { super ( parent , title , modality type . document modal ) ; init components ( general subtree ) ; }	constructs a new dgeneralsubtreechooser dialog .
public void insert ( undo object storable p object ) { if ( p object == null ) throw new illegal argument exception ( classname + str ) ; disable redo ( ) ; undo object node undoable object = new undo object node ( p object , stack level ) ; objects map . put ( p object , undoable object ) ; }	adds p_object to the undoableobjectslist a check is made to make sure that p_object is non null by doing this i am guarantee that a get will always return a non null object.
protected abstract simple entry entry data matched ( entry hierarchy data ehd ) ;	utility method - when iterating over the hierarchy , determine if the entry currently being considered is actually matched . if it is , return the corresponding simpleentry object so the details can be displayed.
@ override public enumeration < option > list options ( ) { vector < option > result = enum to vector ( super . list options ( ) ) ; result . add ( new option ( str + default noise percent ( ) + str , str , num , str ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
@ suppress warnings ( str ) protected void notify property change listener ( string property , object old value , object new value ) { if ( ( old value != null && old value . equals ( new value ) ) || old value == new value ) { log . error ( str ) ; } vector < property change listener > v ; synchronized ( this ) { v = ( vector < property change listener > ) listeners . clone ( ) ; } if ( log . is debug enabled ( ) ) { log . debug ( str + v . size ( ) + str + property ) ; } int cnt = v . size ( ) ; for ( int i = num ; i < cnt ; i ++ ) { property change listener client = v . element at ( i ) ; client . property change ( new property change event ( this , property , old value , new value ) ) ; } }	trigger the notification of all propertychangelisteners.
public element write bean visual ( element parent , object o , string name ) throws exception { element node ; bean visual visual ; if ( debug ) { trace ( new throwable ( ) , name ) ; } m = parent ; visual = ( bean visual ) o ; node = write to xml ( parent , o , name ) ; invoke write to xml ( node , visual . get icon path ( ) , val iconpath ) ; invoke write to xml ( node , visual . get animated icon path ( ) , val animatediconpath ) ; return node ; }	adds the given beanvisual to a dom structure .
private string display nameto back compat name ( string query name ) { final int last back slash = query name . last index of ( str ) ; if ( last back slash > num && last back slash < query name . length ( ) - num ) { query name = ( char ) num + query name ; query name = query name . substring ( num , last back slash + num ) + ( char ) num + str + query name . substring ( last back slash + num ) ; query name = query name . replace ( str , ( char ) num ) ; } return query name ; }	method to work around the query names that are expected when working in back - compat mode against stored queries .
public sq ( string path , int open flags ) { if ( path == null ) { throw new illegal argument exception ( str ) ; } this . path = path ; label = strip path for logs ( path ) ; this . open flags = open flags ; max sql cache size = num ; locale = locale . get default ( ) ; }	creates a database configuration with the required parameters for opening a database and default values for all other parameters .
public static string dump ( final endpoint descriptor descriptor ) { return string . format ( str + str + str + str + str + str + str + str + str + str , descriptor . b length ( ) , descriptor . b descriptor type ( ) , string . format ( str , descriptor . b endpoint address ( ) & num ) , descriptor . b endpoint address ( ) & num , get direction name ( descriptor . b endpoint address ( ) ) , descriptor . bm attributes ( ) & num , get transfer type name ( descriptor . bm attributes ( ) ) , get synch type name ( descriptor . bm attributes ( ) ) , get usage type name ( descriptor . bm attributes ( ) ) , descriptor . w max packet size ( ) & num , descriptor . b interval ( ) & num ) ; }	dumps the specified usb endpoint descriptor into a string and returns it .
public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str + str + str , str , num , str ) ) ; new vector . add all ( collections . list ( super . list options ( ) ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public static void print padding ( print writer out , int padding ) { for ( int i = num ; i < padding ; ++ i ) { out . print ( str ) ; } }	print a sequence of spaces.
protected void sneaky clear ( ) { list < e > collection = new e < > ( size , data ) ; sneaky do clear ( ) ; for ( iterator < e > i = collection . iterator ( ) ; i . has next ( ) ; ) { inverse remove ( i . next ( ) , null ) ; } }	avoid changes to the mod counter and events.
@ called by native public static bitmap create home screen icon from web icon ( context context , bitmap web icon ) { activity manager am = ( activity manager ) context . get system service ( context . activity service ) ; int max inner size = math . round ( am . get launcher large icon size ( ) * max inner size ratio ) ; int inner size = math . min ( max inner size , math . max ( web icon . get width ( ) , web icon . get height ( ) ) ) ; int padding = math . round ( icon padding ratio * inner size ) ; int outer size = inner size + num * padding ; bitmap bitmap = null ; try { bitmap = bitmap . create bitmap ( outer size , outer size , bitmap . config . argb 8888 ) ; } catch ( out of memory error e ) { log . w ( tag , str ) ; return web icon ; } canvas canvas = new canvas ( bitmap ) ; rect inner bounds = new rect ( padding , padding , outer size - padding , outer size - padding ) ; paint paint = new paint ( paint . anti alias flag ) ; paint . set filter bitmap ( bool ) ; canvas . draw bitmap ( web icon , null , inner bounds , paint ) ; int corner radius = math . round ( icon corner radius ratio * outer size ) ; path path = new path ( ) ; path . set fill type ( path . fill type . inverse winding ) ; f inner bounds f = new f ( inner bounds ) ; path . add round rect ( inner bounds f , corner radius , corner radius , path . direction . cw ) ; paint . set xfermode ( new porter duff xfermode ( porter duff . mode . clear ) ) ; canvas . draw path ( path , paint ) ; return bitmap ; }	adapts a website ' s icon ( e.
private static boolean is in overflow ( menu item item ) { return ! is action button ( item ) ; }	check if an item is in the overflow menu .
private static int determine consecutive binary count ( char sequence msg , byte [ ] bytes , int startpos ) throws writer exception { int len = msg . length ( ) ; int idx = startpos ; while ( idx < len ) { char ch = msg . char at ( idx ) ; int numeric count = num ; while ( numeric count < num && is digit ( ch ) ) { numeric count ++ ; int i = idx + numeric count ; if ( i >= len ) { break ; } ch = msg . char at ( i ) ; } if ( numeric count >= num ) { return idx - startpos ; } int text count = num ; while ( text count < num && is text ( ch ) ) { text count ++ ; int i = idx + text count ; if ( i >= len ) { break ; } ch = msg . char at ( i ) ; } if ( text count >= num ) { return idx - startpos ; } ch = msg . char at ( idx ) ; if ( bytes [ idx ] == num && ch != str ) { throw new writer exception ( str + ch + str + ( int ) ch + str ) ; } idx ++ ; } return idx - startpos ; }	determines the number of consecutive characters that are encodable using binary compaction .
void plugin message ( throwable ex ) { log . print lines ( prefix kind . javac , str ) ; ex . print stack trace ( log . get writer ( writer kind . notice ) ) ; }	print a message reporting an uncaught exception from an annotation processor .
public builder map ( string fully qualified column names , column mapper mapper ) { predicate < column id > column matcher = predicates . includes ( fully qualified column names , null ) ; rules . add ( new mapper rule ( column matcher , mapper ) ) ; return this ; }	set a mapping function for the columns with fully - qualified names that match the given comma - separated list of regular expression patterns .
public double theta ( ) { return math . atan2 ( y , x ) ; }	returns the angle of this point in polar coordinates .
public static int hash32 ( final string text , int from , int length ) { return hash32 ( text . substring ( from , from + length ) ) ; }	generates 32 bit hash from a substring .
protected void send closing message ( ) { try { send ( connection message . closing , network protocol . tcp ) ; } catch ( exception e ) { log . warning ( str + e . get message ( ) ) ; } try { send ( connection message . closing , network protocol . udp ) ; } catch ( exception e ) { log . warning ( str + e . get message ( ) ) ; } }	send a message ( hint ) that this end of connection is about to close.
public static string parse number to string ( int a number ) { boolean temp = bool , negative = bool ; if ( a number < num ) { a number *= - num ; negative = bool ; } string builder t string b = new string builder ( ) ; for ( int i = num ; i > num ; i /= num ) { int t digit = ( a number / i ) % num ; if ( temp && t digit != num ) temp = bool ; if ( ! temp ) { t string b . append ( t digit ) ; if ( i != num ) for ( int j = i ; j > num ; j /= num ) if ( j == num ) t string b . append ( str ) ; } } string t string = t string b . to string ( ) ; if ( t string . equals ( e ) ) t string = str ; return negative ? str + t string : t string ; }	converts a number to a string.
public void remove ( t graphic ) { synchronized ( m lock ) { m graphics . remove ( graphic ) ; if ( m first graphic != null && m first graphic . equals ( graphic ) ) { m first graphic = null ; } } post invalidate ( ) ; }	removes a graphic from the overlay .
public boolean valid system name config ( string system name ) { return ( bool ) ; }	public method to validate system name for configuration returns ' true ' if system name has a valid meaning in current configuration , else returns ' false ' for now , this method always returns ' true ' ; it is needed for the abstract light class.
public int read ( ) throws io { ensure open ( ) ; if ( next >= length ) { return - num ; } return str . char at ( next ++ ) ; }	reads a single character .
void add hidden channel listener ( hidden channel listener listener ) { listeners . add ( listener ) ; }	add a listener for following changes on hidden channel logs .
public boolean next to ( final entity entity , final double step ) { final d this area = new d . double ( x - step , y - step , area . get width ( ) + num * step , area . get height ( ) + num * step ) ; return this area . intersects ( entity . get area ( ) ) ; }	checks whether the given entity is near this entity .
private long rebalance nl ( final long n parent , final long n , long array unlinked ) { final long n l = unshared left ( n , unlinked ) ; final long n r = unshared right ( n , unlinked ) ; if ( ( n l == num || n r == num ) && v opt is null ( n ) ) { if ( attempt unlink nl ( n parent , n , unlinked ) ) { return fix height nl ( n parent ) ; } else { return n ; } } final int h n = height ( n ) ; final int h l0 = height ( n l ) ; final int h r0 = height ( n r ) ; final int h n = num + math . max ( h l0 , h r0 ) ; final int bal = h l0 - h r0 ; if ( bal > num ) { return rebalance to right nl ( n parent , n , n l , h r0 , unlinked ) ; } else if ( bal < - num ) { return rebalance to left nl ( n parent , n , n r , h l0 , unlinked ) ; } else if ( h n != h n ) { height ( n , h n ) ; return fix height nl ( n parent ) ; } else { return num ; } }	nparent and n must be locked on entry.
private void add conversations ( ) { tpp myphase = awaiting ; main npc . add ( conversation states . attending , arrays . as list ( str , str ) , new tpp ( myphase ) , conversation states . attending , str + str + str , null ) ; main npc . add ( conversation states . attending , str , new tpp ( myphase ) , conversation states . attending , null , new details killings action ( ) ) ; main npc . add ( conversation states . attending , str , new tpp ( myphase ) , conversation states . attending , null , new reward player action ( ) ) ; }	adds quest ' s related conversations to mayor.
public static void w ( string tag , string s , object ... args ) { if ( log . warn >= loglevel ) log . w ( tag , string . format ( s , args ) ) ; }	warning log message with printf formatting .
@ edu . umd . cs . findbugs . annotations . suppress warnings ( value = str , justification = str ) public void handle notification ( notification notification , object handback ) { if ( handback instanceof agent impl ) { agent impl agent = ( agent impl ) handback ; jmx jmx notifn = ( jmx ) notification ; if ( logger . is debug enabled ( ) ) { logger . debug ( str , jmx notifn . get connection id ( ) ) ; } agent . update rmi clients count ( ) ; } }	if the handback object passed is an agentimpl , updates the jmx client count.
public static boolean is blank ( string s ) { if ( s == null ) { return bool ; } int s len = s . length ( ) ; for ( int i = num ; i < s len ; i ++ ) { if ( ! character . is whitespace ( s . char at ( i ) ) ) { return bool ; } } return bool ; }	checks whether a string is whitespace , empty or null .
public plain text dictionary ( path path ) throws io { in = files . new buffered reader ( path , standard charsets . utf 8 ) ; }	creates a dictionary based on a path . < p > note : content is treated as utf - 8.
public boolean add alias by number ( string alias name , string number ) { if ( alias name . contains ( str ) ) return bool ; string contact name = contacts manager . get contact name or null ( ctx , number ) ; add or update ( alias name , number , contact name ) ; return bool ; }	adds an alias by a phone number if the alias contains an invalid character , false will be returned.
void split data ( node node , node new node , int offset ) { if ( ranges != null ) { notify ranges split data ( node , new node , offset ) ; } }	a method to be called when a text node has been split , so that live objects can be notified .
@ not null @ c ( str ) public configuration builder add trusted key ( string trusted key ) { trusted keys . add ( new trusted key ( trusted key ) ) ; return this ; }	adding trusted key for protocol encryption securing.
private void check is correct class ( ) { if ( check is sub class ( act name ) ) { type = element type . acttivity ; } else if ( check is sub class ( frag name ) || check is sub class ( frag name ) ) { type = element type . fragment ; } else { throw new illegal argument exception ( string . format ( str , element . get qualified name ( ) , act name , frag name , frag name ) ) ; } }	check out if is extends from activity or fragment.
string transform resource id to file name ( final string resource name ) { return resource name . replace ( str , str ) ; }	transform resource id in filename_extension format to filename . extension.
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return success ; case num : return msg ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
private void fill nodes in context ( site node root node , list < site node > nodes list ) { @ suppress warnings ( str ) enumeration < site node > en = root node . children ( ) ; while ( en . has more elements ( ) ) { site node sn = en . next element ( ) ; if ( is in context ( sn ) ) { nodes list . add ( sn ) ; } fill nodes in context ( sn , nodes list ) ; } }	fills a given list with nodes in scope , searching recursively .
@ suppress warnings ( { str , str } ) public boolean matches ( inventory crafting p 77569 1 , world p 77569 2 ) { array list arraylist = new array list ( this . recipe items ) ; for ( int i = num ; i < num ; ++ i ) { for ( int j = num ; j < num ; ++ j ) { item stack itemstack = p 77569 1 . get stack in row and column ( j , i ) ; if ( itemstack != null ) { boolean flag = bool ; iterator iterator = arraylist . iterator ( ) ; while ( iterator . has next ( ) ) { item stack itemstack1 = ( item stack ) iterator . next ( ) ; if ( itemstack . get item ( ) == itemstack1 . get item ( ) && ( itemstack1 . get item damage ( ) == num || itemstack . get item damage ( ) == itemstack1 . get item damage ( ) ) ) { flag = bool ; arraylist . remove ( itemstack1 ) ; break ; } } if ( ! flag ) { return bool ; } } } } return arraylist . is empty ( ) ; }	used to check if a recipe matches current crafting inventory.
public string builder dump statements ( final i < ispo > access path ) { final string builder sb = new string builder ( ) ; final bigdata statement iterator itr = as statement iterator ( access path . iterator ( ) ) ; try { while ( itr . has next ( ) ) { sb . append ( str + itr . next ( ) ) ; } return sb ; } finally { itr . close ( ) ; } }	dumps the access path , efficiently resolving term identifiers to terms .
public static element svg wait icon ( document document , double x , double y , double w , double h ) { element g = svg . svg element ( document , svg . svg g tag ) ; set att ( g , svg . svg transform attribute , str + x + str + y + str + w + str + h + str ) ; element thro = svg . svg element ( document , svg . svg path tag ) ; set att ( thro , svg . svg d attribute , throbber path ) ; set style ( thro , throbber style ) ; element anim = svg . svg element ( document , svg . svg animate transform tag ) ; set att ( anim , svg . svg attribute name attribute , svg . svg transform attribute ) ; set att ( anim , svg . svg attribute type attribute , str ) ; set att ( anim , svg . svg type attribute , svg . svg rotate attribute ) ; set att ( anim , svg . svg from attribute , str ) ; set att ( anim , svg . svg to attribute , str ) ; set att ( anim , svg . svg begin attribute , fmt ( math . random ( ) * num ) + str ) ; set att ( anim , svg . svg dur attribute , str ) ; set att ( anim , svg . svg repeat count attribute , str ) ; set att ( anim , svg . svg fill attribute , str ) ; thro . append child ( anim ) ; g . append child ( thro ) ; return g ; }	draw a simple " please wait " icon ( in - progress ) as placeholder for running renderings .
protected void on end ( pcap pcap ) { this . end = bool ; }	called after the pcap loop exits .
public void cd ( string dir ) { string builder buf = new string builder ( ) ; string command = string . format ( image server dialog properties . get string ( str ) , dir ) ; send wait for ( command , default timeout , prompts , buf ) ; log . debug ( buf . to string ( ) ) ; }	cd command in linux .
public void add request property ( string key , string value ) { jar file url . add request property ( key , value ) ; }	adds a general request property specified by a key - value pair.
public static void write spec info to files ( security spec model security spec model , string app root dir ) { write info flow summary to file ( security spec model , config . v ( ) . app root dir ) ; write info flow details to file ( security spec model , config . v ( ) . app root dir ) ; write value info to file ( security spec model , config . v ( ) . app root dir ) ; write points to info to file ( security spec model , config . v ( ) . app root dir ) ; }	writes info flow info , value flow info , and points to info associated with the security spec to separate files in the droidsafe folder of the current selected android app .
private void handle command ( int id , string command , string params ) { string origin command = command id . get ( id ) ; if ( origin command == null ) { origin command = str ; } handler . handle command ( id , command , params , origin command ) ; if ( command . equals ( str ) ) { logger . warning ( str + params ) ; } }	handle message already parsed into id , command and parameters .
private void close all dumps ( ) { object [ ] options = { str , str } ; int select value = j . show option dialog ( null , str , str , j . default option , j . question message , null , options , options [ num ] ) ; if ( select value == num ) { top nodes = new vector ( ) ; reset main panel ( ) ; } }	close all open dumps.
private void close counter data input stream ( ) throws data fallback exception { if ( log . is debug enabled ( ) ) log . debug ( str + counter file . get name ( ) ) ; if ( d input != null ) { try { d input . close ( ) ; } catch ( io e ) { throw new data fallback exception ( e . get message ( ) ) ; } finally { d input = null ; } } }	close the input stream opened for the counter file.
private static string remove file name extension ( string file name ) { if ( file name . last index of ( str ) == - num ) return file name ; return file name . substring ( num , file name . last index of ( str ) ) ; }	removes the extension ( whatever comes after the last '.
public void clear ( ) { read = write = count = num ; arrays . fill ( buffer , null ) ; }	clear the contents of this buffer .
private list < entry > reduce with douglas peuker ( list < entry > entries , double epsilon ) { if ( epsilon <= num || entries . size ( ) < num ) { return entries ; } keep [ num ] = bool ; keep [ entries . size ( ) - num ] = bool ; algorithm douglas peucker ( entries , epsilon , num , entries . size ( ) - num ) ; list < entry > reduced entries = new array list < > ( ) ; for ( int i = num ; i < entries . size ( ) ; i ++ ) { if ( keep [ i ] ) { entry cur entry = entries . get ( i ) ; reduced entries . add ( new entry ( cur entry . get val ( ) , cur entry . get x ( ) ) ) ; } } return reduced entries ; }	uses the douglas peuker algorithm to reduce the given list of entries.
static int hi bit pos ( long num ) { return num - long . number of leading zeros ( num ) ; }	zero based position of the highest one - bit of the given long.
public adaptive grid archive ( int capacity , problem problem , int number of divisions ) { this . capacity = capacity ; this . problem = problem ; this . number of divisions = number of divisions ; minimum = new double [ problem . get number of objectives ( ) ] ; maximum = new double [ problem . get number of objectives ( ) ] ; density = new int [ ( int ) math . pow ( number of divisions , problem . get number of objectives ( ) ) ] ; adapt grid ( ) ; }	constructs an adaptive grid archive with the specified capacity with the specified number of divisions along each objective .
begin line action ( string nm , boolean select ) { super ( nm ) ; this . select = select ; }	create this action with the appropriate identifier .
private void adjust window size ( container wrapper parent ) { bound size w bounds = lc . get pack width ( ) ; bound size h bounds = lc . get pack height ( ) ; if ( w bounds == null && h bounds == null ) return ; window win = ( ( window ) swing utilities . get ancestor of class ( window . class , ( component ) parent . get component ( ) ) ) ; if ( win == null ) return ; dimension pref size = win . get preferred size ( ) ; int targ w = constrain ( check parent ( win ) , win . get width ( ) , pref size . width , w bounds ) ; int targ h = constrain ( check parent ( win ) , win . get height ( ) , pref size . height , h bounds ) ; int x = math . round ( win . get x ( ) - ( ( targ w - win . get width ( ) ) * ( num - lc . get pack width align ( ) ) ) ) ; int y = math . round ( win . get y ( ) - ( ( targ h - win . get height ( ) ) * ( num - lc . get pack height align ( ) ) ) ) ; win . set bounds ( x , y , targ w , targ h ) ; }	checks the parent window if its size is within parameters as set by the lc .
@ override public void write ( list < byte [ ] > value list ) throws io { if ( is first time ) { init ( ) ; is first time = bool ; } for ( byte [ ] value : value list ) { one dictionary chunk list . add ( byte buffer . wrap ( value ) ) ; total record count ++ ; } }	this method will write the data in thrift format to disk . this method will not be guided by parameter dictionary_one_chunk_size and complete data will be written as one chunk.
public void proceed ( ) { idle . set ( bool ) ; subject . on next ( null ) ; }	signalizes that the backlog can proceed with the next item.
private static boolean ns equals ( string ns uri 1 , string ns uri 2 ) { if ( ns uri 1 == null ) { return ( ns uri 2 == null ) ; } else { return ns uri 1 . equals ( ns uri 2 ) ; } }	compares two namespace uris with an extra case for null entries.
public static void sleep ( long millis ) { if ( mock sleep queue == null ) { sleep uninterruptibly ( millis , time unit . milliseconds ) ; } else { try { boolean is multi pass = mock sleep queue . take ( ) ; roll mock clock millis ( millis ) ; if ( is multi pass ) mock sleep queue . offer ( bool ) ; } catch ( interrupted exception e ) { } } }	sleep for a span of time , or mock sleep if enabled.
public boolean is handle ( string handle ) { return client handle . equals ( handle ) ; }	determines if a given handle refers to this client.
public static void is gte ( string arg name , long i , long min ) { if ( i < min ) { throw new illegal argument exception ( string . format ( str , arg name , min , i ) ) ; } }	makes sure the given number is greater than or equal to the given minimum .
int adjust text offset ( int offset ) { max text offset = math . max ( max text offset , offset ) ; return max text offset ; }	adjusts the text offset needed to align text horizontally .
public static object value from class constant ( string key , object default value ) { configuration conf = instance ( ) ; string val = value for ( key ) ; if ( val == null ) { return default value ; } int idx = val . last index of ( str ) ; string klassname ; string cnst ; try { klassname = val . substring ( num , idx ) ; cnst = val . substring ( idx + num ) ; } catch ( index out of bounds exception e ) { conf . warning ( str + key + str + str + val ) ; return default value ; } class klass ; try { klass = class . for name ( klassname ) ; } catch ( class not found exception e ) { conf . warning ( str + key + str + klassname ) ; return default value ; } object cnst val ; try { field fld = klass . get declared field ( cnst ) ; try { cnst val = fld . get ( klass ) ; } catch ( illegal access exception e ) { conf . warning ( str + key + str + klassname + str + cnst ) ; return default value ; } } catch ( no such field exception e ) { conf . warning ( str + key + str + klassname ) ; return default value ; } return cnst val ; }	given a property , resolves the value to a public constant field on some class , where the field is of type object.
public static boolean is wifi connected ( context context ) { connectivity manager connectivity manager = ( connectivity manager ) context . get system service ( context . connectivity service ) ; network info network info = connectivity manager . get active network info ( ) ; return network info != null && network info . get type ( ) == connectivity manager . type wifi ; }	this method requires the caller to hold the permission access_network_state .
public str builder insert ( final int index , final char value ) { validate index ( index ) ; ensure capacity ( size + num ) ; system . arraycopy ( buffer , index , buffer , index + num , size - index ) ; buffer [ index ] = value ; size ++ ; return this ; }	inserts the value into this builder .
public list < byte [ ] > try decode ( final string target token ) { final byte buffer payload buf = extract valid payload fields ( target token ) ; if ( payload buf == null ) { return null ; } final list < byte [ ] > fields = new array list < > ( ) ; try { byte [ ] field = null ; while ( ( field = try read payload next field ( payload buf ) ) . length > num ) { fields . add ( field ) ; if ( fields . size ( ) > max field size ) { return null ; } } return fields ; } catch ( final buffer underflow exception e ) { return null ; } }	return null if token is malformed or expired.
@ namespace permission ( fields = str , permissions = namespace permission enum . write ) @ override public business object definition create business object definition ( business object definition create request request ) { validate business object definition create request ( request ) ; namespace entity namespace entity = namespace dao helper . get namespace entity ( request . get namespace ( ) ) ; data provider entity data provider entity = data provider dao helper . get data provider entity ( request . get data provider name ( ) ) ; business object definition key business object definition key = new business object definition key ( request . get namespace ( ) , request . get business object definition name ( ) ) ; business object definition entity business object definition entity = business object definition dao . get business object definition by key ( business object definition key ) ; if ( business object definition entity != null ) { throw new already exists exception ( string . format ( str , business object definition key . get business object definition name ( ) , business object definition key . get namespace ( ) ) ) ; } business object definition entity = create business object definition entity ( request , namespace entity , data provider entity ) ; return create business object definition from entity ( business object definition entity ) ; }	creates a new business object definition .
public void end block ( ) throws io { if ( indent . length ( ) <= num ) { indent = str ; } else if ( indent . length ( ) >= num ) { indent = indent . substring ( num ) ; } print ( str , null ) ; printer . println ( ) ; }	description of the method.
private void migrate block volumes ( ) { log . info ( str ) ; db client db client = get db client ( ) ; list < uri > volume ur = db client . query by type ( volume . class , bool ) ; iterator < volume > volumes = db client . query iterative objects ( volume . class , volume ur , bool ) ; list < block object > block objects = new array list < block object > ( ) ; while ( volumes . has next ( ) ) { block objects . add ( volumes . next ( ) ) ; } migrate block objects ( block objects ) ; }	update the volume object to migrate the old consistencygroups field into the new consistencygroup list field .
public server controller test ( string name ) { super ( name ) ; this . base dir = system . get property ( str ) ; }	creates a servercontrollertest testcase .
@ override public string encode ( ) { return value == int value ( ) ? integer . to string ( int value ( ) ) + unit . encode ( ) : double . to string ( value ) + unit . encode ( ) ; }	returns a parseable string representation of this constant size .
public host name parser ( lexer core lexer ) { this . lexer = lexer ; lexer . select lexer ( str ) ; strip address scope zones = boolean . get boolean ( str ) ; }	the lexer is initialized with the buffer .
private void load text ( input stream is ) { buffered reader reader ; string line ; if ( is == null ) { throw new error ( str ) ; } reader = new buffered reader ( new input stream reader ( is ) ) ; try { line = reader . read line ( ) ; line count ++ ; while ( line != null ) { if ( ! line . starts with ( str ) ) { parse and add ( line , reader ) ; } line = reader . read line ( ) ; } reader . close ( ) ; } catch ( io e ) { throw new error ( e . get message ( ) + str + line count ) ; } finally { } }	loads the database from the given input stream .
public void add email adress ( string an email address ) { if ( m emails . index of ( an email address ) < num ) { m emails . add ( an email address ) ; } }	add an email address to the list .
public static instances load dataset ( string options [ ] , char t ) throws exception { instances d = null ; string filename = utils . get option ( t , options ) ; if ( filename == null || filename . is empty ( ) ) throw new exception ( str ) ; file file = new file ( filename ) ; if ( ! file . exists ( ) ) throw new exception ( str + filename ) ; if ( file . is directory ( ) ) throw new exception ( str + filename + str ) ; try { data source source = new data source ( filename ) ; d = source . get data set ( ) ; } catch ( exception e ) { e . print stack trace ( ) ; throw new exception ( str + filename + str ) ; } return d ; }	loaddataset - load a dataset , given command line options specifying an arff file .
private boolean is typed time fully legal ( ) { if ( m is24 hour mode ) { int [ ] values = get entered time ( null ) ; return ( values [ num ] >= num && values [ num ] >= num && values [ num ] < num ) ; } else { return ( m typed times . contains ( get am or pm key code ( am ) ) || m typed times . contains ( get am or pm key code ( pm ) ) ) ; } }	check if the time that has been typed so far is completely legal , as is .
public void test group commit ( ) throws exception { final int write service core pool size = num ; final properties properties = get properties ( ) ; properties . set property ( test options . timeout , str ) ; properties . set property ( test options . ntasks , str ) ; properties . set property ( options . write service core pool size , str + write service core pool size ) ; properties . set property ( options . write service maximum pool size , str ) ; properties . set property ( options . write service prestart all core threads , str ) ; properties . set property ( options . write service queue capacity , str ) ; do comparison test ( properties ) ; }	runs a single condition .
@ override public void operate ( population pop ) throws exception { list < individual > new individuals = new linked list < individual > ( ) ; for ( int i = num ; i < pop . get number of individuals ( ) ; i ++ ) { list < individual > individuals = operate ( pop . get ( i ) ) ; new individuals . add all ( individuals ) ; } pop . clear ( ) ; pop . add all individuals ( new individuals ) ; }	operates on all individuals , removes the original individuals and adds the new ones .
public int size ( ) { return encoded names . size ( ) ; }	the number of key - value pairs in this form - encoded body .
public static byte [ ] to seed ( list < string > words , string passphrase ) { return to seed ( words , passphrase , version . 6 ) ; }	convert mnemonic word list to seed .
private array list < interval > find or create interval set ( register r ) { array list < interval > v = map . get ( r ) ; if ( v == null ) { v = new array list < interval > ( ) ; map . put ( r , v ) ; } return v ; }	find or create the set of intervals corresponding to a register r .
protected void remove columns ( collection < string > remove column names , string table name ) { if ( remove column names != null && ! remove column names . is empty ( ) ) { execute ( get remove column sq ( remove column names , table name ) , m db ) ; } }	when some fields are removed from class , the table should synchronize the changes by removing the corresponding columns .
public void register atmosphere ( i atmosphere ) { atmosphere registration . put ( atmosphere . get unlocalized name ( ) , atmosphere ) ; atmosphere list . add ( atmosphere ) ; }	registers the atmosphere with the mod.
public jx ( ) { this ( str ) ; }	creates a new search field with a default prompt .
private static void reply ( body body , mobile session ctx wsc , string role id ) { string form = null ; login login = new login ( wsc . ctx ) ; key name pair [ ] clients = login . get clients ( new key name pair ( integer . parse int ( role id ) , role id ) ) ; string buffer script = new string buffer ( str ) ; for ( int i = num ; i < clients . length ; i ++ ) { if ( i > num ) script . append ( str ) ; key name pair p = clients [ i ] ; script . append ( str ) ; script . append ( p . get name ( ) ) ; script . append ( str ) ; script . append ( p . get key ( ) ) ; script . append ( str ) ; } script . append ( str ) ; }	login 2nd page response - field role . < p > fill client , org , warehouse.
public void test create document type1 ( ) throws throwable { document doc ; dom dom impl ; document type new doc type ; document owner document ; string qualified name = str ; string public id ; string system id ; list < string > public ids = new array list < string > ( ) ; public ids . add ( str ) ; public ids . add ( str ) ; list < string > system ids = new array list < string > ( ) ; system ids . add ( str ) ; system ids . add ( str ) ; doc = ( document ) load ( str , builder ) ; dom impl = doc . get implementation ( ) ; for ( int index n1005 d = num ; index n1005 d < public ids . size ( ) ; index n1005 d ++ ) { public id = ( string ) public ids . get ( index n1005 d ) ; for ( int index n10061 = num ; index n10061 < system ids . size ( ) ; index n10061 ++ ) { system id = ( string ) system ids . get ( index n10061 ) ; new doc type = dom impl . create document type ( qualified name , public id , system id ) ; assert not null ( str , new doc type ) ; owner document = new doc type . get owner document ( ) ; assert null ( str , owner document ) ; } } }	runs the test case .
public final void run ( ) { if ( m start == num ) m start = system . current time millis ( ) ; m can continue = bool ; while ( m can continue ) { if ( is interrupted ( ) ) return ; m last start = system . current time millis ( ) ; m working = bool ; try { m poll count ++ ; if ( can do work ( ) ) { m can continue = do work ( ) ; m count ++ ; } } catch ( exception e ) { log . log ( level . severe , str , e ) ; } m working = bool ; long end = system . current time millis ( ) ; m time += ( end - m last start ) ; if ( is interrupted ( ) ) return ; try { log . fine ( str + m sleep seconds ) ; sleep ( m sleep seconds * num ) ; } catch ( interrupted exception e1 ) { log . warning ( str + e1 . get localized message ( ) ) ; return ; } } }	run - do the work.
public static solr document assert search one doc ( solr params p ) throws exception { solr document list docs = assert search ( p ) ; assert equals ( str + p . to string ( ) + str + docs . to string ( ) , num , docs . get num found ( ) ) ; assert equals ( str + p . to string ( ) + str + docs . to string ( ) , num , docs . size ( ) ) ; return docs . get ( num ) ; }	given a set of query params , executes as a query against a random solrclient and asserts that exactly one document is returned.
private static value source build source tree ( index schema schema , string expression , int source type ) { int expression type = get source type ( expression ) ; if ( source type != field type && expression type != field type && expression type != filter type && expression type != source type ) { return null ; } switch ( expression type ) { case number type : return build numeric source ( schema , expression ) ; case date type : return build date source ( schema , expression ) ; case string type : return build string source ( schema , expression ) ; case field type : return build field source ( schema , expression , source type ) ; case filter type : return build filter source ( schema , expression . substring ( expression . index of ( str ) + num , expression . last index of ( str ) ) , source type ) ; default : throw new solr exception ( error code . bad request , expression + str ) ; } }	builds a value source from a given string and a given source type.
public value predecessor ( ) { return predecessor . get ( ) ; }	return the vertex preceding this vertex on the shortest path .
public static double log pdf ( double x , double m , double sd ) { double a = num / ( math . sqrt ( num * math . pi ) * sd ) ; double b = - ( x - m ) * ( x - m ) / ( num * sd * sd ) ; return math . log ( a ) + b ; }	the natural log of the probability density function of the distribution.
public int value sparse int ( int index of index ) throws exception { return integer . parse int ( actual value ( index of index ) ) ; }	gets the value at indexofindex from the array.
public void test to engineering string zero pos exponent ( ) { string a = str ; big decimal a number = new big decimal ( a ) ; string result = str ; assert equals ( str , result , a number . to engineering string ( ) ) ; }	convert a negative bigdecimal to an engineering string representation.
public static int scan ( long v ) { return num - long . number of leading zeros ( v ) ; }	utility method with defined return value for 0 .
public static boolean is all upper case ( string str ) { if ( str == null ) return bool ; boolean has letters = bool ; char c ; for ( int i = str . length ( ) - num ; i >= num ; i -- ) { c = str . char at ( i ) ; if ( character . is letter ( c ) ) { if ( ! character . is upper case ( c ) ) return bool ; has letters = bool ; } } return has letters ; }	returns true if the input string has letters and they are all uppercase.
public static class path create class path ( string class path string , string sys class path string , string ext dirs string ) { path path = new path ( ) ; if ( sys class path string == null ) { sys class path string = system . get property ( str ) ; } if ( sys class path string != null ) { path . add files ( sys class path string ) ; } path . expand jar class paths ( bool ) ; if ( ext dirs string == null ) { ext dirs string = system . get property ( str ) ; } if ( ext dirs string != null ) { path . add directories ( ext dirs string ) ; } path . empty path default ( str ) ; if ( class path string == null ) { class path string = system . get property ( str ) ; if ( class path string == null ) { class path string = str ; } } path . add files ( class path string ) ; return new class path ( path . to array ( new string [ path . size ( ) ] ) ) ; }	create a classpath object for rmic from the relevant command line options for class path , boot class path , and extension directories .
protected abstract spined buffer ( int initial capacity ) { if ( initial capacity < num ) throw new illegal argument exception ( str + initial capacity ) ; this . initial chunk power = math . max ( min chunk power , integer . size - integer . number of leading zeros ( initial capacity - num ) ) ; }	construct with a specified initial capacity .
public static void u ( double [ ] x , double [ ] f , int nx ) { int count1 = num ; int count2 = num ; int count3 = num ; double sum1 = num ; double sum2 = num ; double sum3 = num ; double yj ; double e = num ; for ( int j = num ; j <= nx ; j ++ ) { yj = x [ j - num ] - num * x [ num ] * math . sin ( num * pi * x [ num ] + j * pi / nx ) ; if ( j % num == num ) { sum1 += yj * yj ; count1 ++ ; } else if ( j % num == num ) { sum2 += yj * yj ; count2 ++ ; } else { sum3 += yj * yj ; count3 ++ ; } } yj = ( num + e ) * ( num - num * ( num * x [ num ] - num ) * ( num * x [ num ] - num ) ) ; if ( yj < num ) { yj = num ; } f [ num ] = num * ( yj + num * x [ num ] ) * x [ num ] + num * sum1 / ( double ) count1 ; f [ num ] = num * ( yj - num * x [ num ] + num ) * x [ num ] + num * sum2 / ( double ) count2 ; f [ num ] = num - x [ num ] + num * sum3 / ( double ) count3 ; }	evaluates the uf9 problem .
private void cleaning text ( ) { int latin count = num , non latin count = num ; for ( int i = num ; i < text . length ( ) ; ++ i ) { char c = text . char at ( i ) ; if ( c <= str && c >= str ) { ++ latin count ; } else if ( c >= str && unicode block . of ( c ) != unicode block . latin extended additional ) { ++ non latin count ; } } if ( latin count * num < non latin count ) { string buffer text without latin = new string buffer ( ) ; for ( int i = num ; i < text . length ( ) ; ++ i ) { char c = text . char at ( i ) ; if ( c > str || c < str ) text without latin . append ( c ) ; } text = text without latin ; } }	cleaning text to detect ( eliminate url , e - mail address and latin sentence if it is not written in latin alphabet ).
public void begin apply interval ( ) { interval start millis = system . current time millis ( ) ; end millis = interval start millis ; state = task state . apply ; }	start an apply interval .
public void send messages ( list < producer record < string , string > > records ) { producer < string , string > producer = new kafka producer < > ( get producer config ( ) ) ; for ( producer record < string , string > rec : records ) producer . send ( rec ) ; producer . flush ( ) ; producer . close ( ) ; }	sends a message to kafka broker .
private static j create chart ( ) { xy series1 = new xy ( str ) ; series1 . add ( num , num ) ; series1 . add ( num , num ) ; series1 . add ( num , num ) ; xy dataset = new xy ( series1 ) ; return chart factory . create xy ( str , str , str , dataset , plot orientation . vertical , bool , bool , bool ) ; }	create a horizontal bar chart with sample data in the range - 3 to + 3 .
public boolean is number geographical ( phone number phone number ) { return is number geographical ( get number type ( phone number ) , phone number . get country code ( ) ) ; }	tests whether a phone number has a geographical association.
protected int weighted distribution ( int [ ] weights ) { int sum = num ; for ( int weight : weights ) { sum += weight ; } int val = ( int ) math . floor ( m random . next double ( ) * sum ) ; for ( int i = num ; i < weights . length ; i ++ ) { val -= weights [ i ] ; if ( val < num ) { return i ; } } return - num ; }	calculates a weighted distribution.
protected string clean up ( string classname ) { string result ; result = classname ; if ( result . index of ( str ) > - num ) { result = result . replace ( str , str ) ; } if ( result . index of ( str ) > - num ) { result = result . replace ( str , str ) ; } if ( result . ends with ( str ) ) { result = result . substring ( num , result . length ( ) - num ) ; } return result ; }	fixes the classname , turns " / " and " \ " into ".
public static boolean is assignable ( class target type , class value type ) { assert . not null ( target type , str ) ; assert . not null ( value type , str ) ; return ( target type . is assignable from ( value type ) || target type . equals ( primitive wrapper type map . get ( value type ) ) ) ; }	determine if the given target type is assignable from the given value type , assuming setting by reflection.
public dialog check box add dialog check box ( string description , string label text , boolean initial state ) { string [ ] args = new string [ num ] ; args [ num ] = str ; args [ num ] = description ; args [ num ] = label text ; args [ num ] = boolean . to string ( initial state ) ; dialog check box dcb = new dialog check box ( ) ; dcb . set args ( args ) ; components . add ( dcb ) ; main panel . add ( dcb ) ; return dcb ; }	adds a checkbox to the dialog.
private void perform restore ( file member dir , file backup dir ) throws exception { list < file > if files = file util . find all ( member dir , str ) ; for ( file file : if files ) { file . delete ( ) ; } list < file > oplogs = file util . find all ( member dir , oplog regex ) ; for ( file file : oplogs ) { file . delete ( ) ; } file restore script = new file ( backup dir , str ) ; if ( ! restore script . exists ( ) ) { restore script = new file ( backup dir , str ) ; } assert true ( restore script . exists ( ) ) ; assert equals ( num , execute ( restore script . get absolute path ( ) ) ) ; }	peforms an operation log restore for a member .
public static boolean download url to stream ( string url string , output stream output stream ) { disable connection reuse if necessary ( ) ; url url connection = null ; buffered output stream out = null ; buffered input stream in = null ; try { final url url = new url ( url string ) ; url connection = ( url ) url . open connection ( ) ; in = new buffered input stream ( url connection . get input stream ( ) , io buffer size ) ; out = new buffered output stream ( output stream , io buffer size ) ; int b ; while ( ( b = in . read ( ) ) != - num ) { out . write ( b ) ; } return bool ; } catch ( final io e ) { log . e ( tag , str + e ) ; } finally { if ( url connection != null ) { url connection . disconnect ( ) ; } try { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } catch ( final io e ) { } } return bool ; }	download a bitmap from a url and write the content to an output stream .
public boolean is payments adequate ( ) { return is payments adequate ( this . cart ) ; }	scipio : verifies if current payment methods in cart are adequate enough to cover the current order , or in other words the cart payments in current state can effectively be used to pay for the order .
@ override public void transaction commited ( final long commit time ) { if ( listeners . is empty ( ) ) { records . reset ( ) ; } else { records . flush ( ) ; listeners . for each ( null ) ; } }	notification of transaction committed .
public static m [ ] find ( mb b partner , boolean so , timestamp valid , int m id , string value , string name , string upc , string sku , string trx name ) { int m id = so ? b partner . get m id ( ) : b partner . get po id ( ) ; m pl = null ; if ( m id == num ) pl = m . get default ( b partner . get ctx ( ) , so ) ; else pl = m . get ( b partner . get ctx ( ) , m id , trx name ) ; if ( pl == null ) { s log . severe ( str ) ; return null ; } m plv = pl . get price list version ( valid ) ; if ( plv == null ) { s log . severe ( str + pl . get m id ( ) ) ; return null ; } return find ( b partner . get ctx ( ) , plv . get m id ( ) , m id , value , name , upc , sku , trx name ) ; }	find products in warehouse with price for customer.
private void read object ( object input stream in ) throws io , class not found exception { counter = new atomic integer ( ) ; serializers = new hash map < class , serializer wrapper > ( ) ; serializers array = new serializer [ num ] ; deserialize ( in , this ) ; }	deserializes this instance from an input stream .
public static date translate time ( date date , time zone src , time zone dest ) { date new date = new date ( ) ; int offset = ( dest . get offset ( date . get time ( ) ) - src . get offset ( date . get time ( ) ) ) ; new date . set time ( date . get time ( ) - offset ) ; return new date ; }	translate a date & time from a users time zone to the another ( probably server ) time zone to assist in creating a simple trigger with the right date & time .
private void show popup menu ( final mouse event event ) { final c menu = new c ( get filter field ( ) ) ; menu . show ( event . get component ( ) , event . get x ( ) , event . get y ( ) ) ; }	shows a context menu depending on the event .
private task resource rep finish deactivate task ( block consistency group consistency group , string task ) { uri id = consistency group . get id ( ) ; operation op = new operation ( ) ; op . ready ( ) ; op . set progress ( num ) ; op . set resource type ( resource operation type enum . delete consistency group ) ; operation status = db client . create task op status ( block consistency group . class , id , task , op ) ; return to task ( consistency group , task , status ) ; }	simply return a task that indicates that the operation completed .
public static severity parse severity ( string str ) throws illegal severity exception { if ( str . equals ignore case ( messages . error ) ) { return error ; } else if ( str . equals ignore case ( messages . warning ) ) { return warning ; } else { throw new illegal severity exception ( ) ; } }	parse str and convert to appropriate severity .
private void restore from keypress ( final key event key event , final int key number ) { if ( key event . is alt down ( ) ) { final int array index = ( key number > num ? key number : max recent messages ) - num ; if ( array index < recent messages . size ( ) ) { display message ( recent messages . get ( array index ) ) ; } key event . consume ( ) ; } }	restores message from the key event .
public void remove scrolling listener ( on wheel scroll listener listener ) { scrolling listeners . remove ( listener ) ; }	removes wheel scrolling listener.
public void fire ( session session , int type , boolean before action ) { if ( row based || before != before action || ( type mask & type ) == num ) { return ; } load ( ) ; connection c2 = session . create connection ( bool ) ; boolean old = bool ; if ( type != trigger . select ) { old = session . set commit or rollback disabled ( bool ) ; } value identity = session . get last scope identity ( ) ; try { trigger callback . fire ( c2 , null , null ) ; } catch ( throwable e ) { throw db exception . get ( error code . error executing trigger 3 , e , get name ( ) , trigger class name != null ? trigger class name : str , e . to string ( ) ) ; } finally { if ( session . get last trigger identity ( ) != null ) { session . set last scope identity ( session . get last trigger identity ( ) ) ; session . set last trigger identity ( null ) ; } else { session . set last scope identity ( identity ) ; } if ( type != trigger . select ) { session . set commit or rollback disabled ( old ) ; } } }	call the trigger class if required.
public boolean skips location ( string location id ) { return skip locations list . contains ( location id ) ; }	determines if this train skips a location ( doesn ' t service the location ) .
private list < race > parse races ( string json ) { list < race > result = new array list < > ( ) ; if ( json == null ) { return null ; } json parser = new json ( ) ; try { json root = ( json ) parser . parse ( json . trim ( ) ) ; json races = ( json ) root . get ( str ) ; for ( object o : races ) { if ( o instanceof json ) { race race = parse race ( ( json ) o ) ; if ( race != null ) { result . add ( race ) ; } } } } catch ( parse exception | class cast exception | null pointer exception ex ) { logger . warning ( str + ex ) ; return null ; } return result ; }	parses the races from the result .
public boolean is connected ( short node id ) { node connection nc = connections . get ( node id ) ; return ( nc != null && nc . state == node connection state . connected ) ; }	find out if a particular node is connected.
public object name manage system member ( distributed member distributed member ) throws admin exception , malformed object name exception { try { system member member = lookup system member ( distributed member ) ; if ( member == null ) return null ; system member jmx impl jmx = ( system member jmx impl ) member ; object name oname = new object name ( jmx . get m ( ) ) ; return oname ; } catch ( admin exception e ) { logger . warn ( e . get message ( ) , e ) ; throw e ; } catch ( runtime exception e ) { logger . warn ( e . get message ( ) , e ) ; throw e ; } catch ( virtual machine error err ) { system failure . initiate failure ( err ) ; throw err ; } catch ( error e ) { system failure . check failure ( ) ; logger . error ( e . get message ( ) , e ) ; throw e ; } }	return the objectname for the systemmembermbean representing the specified distributed member or null if the member is not found .
private void connect ( ) throws io { jmx url jmx url = new jmx url ( string . format ( fmt url , host , port ) ) ; jmxc = jmx . connect ( jmx url , null ) ; m mbean server conn = jmxc . get m ( ) ; try { object name name = new object name ( domainlist object name ) ; domain list proxy = m . new proxy instance ( mbean server conn , name , m . class , bool ) ; name = new object name ( virtualusertable object name ) ; virtual user table proxy = m . new proxy instance ( mbean server conn , name , m . class , bool ) ; name = new object name ( usersrepository object name ) ; users repository proxy = m . new proxy instance ( mbean server conn , name , m . class , bool ) ; name = new object name ( mailboxcopier object name ) ; mailbox copier management = m . new proxy instance ( mbean server conn , name , m . class , bool ) ; name = new object name ( mailboxmanager object name ) ; mailbox manager management = m . new proxy instance ( mbean server conn , name , m . class , bool ) ; name = new object name ( quotamanager object name ) ; quota management = m . new proxy instance ( mbean server conn , name , m . class , bool ) ; name = new object name ( reindexer object name ) ; re indexer management = m . new proxy instance ( mbean server conn , name , m . class , bool ) ; name = new object name ( sievemanager object name ) ; sieve repository management = m . new proxy instance ( mbean server conn , name , m . class , bool ) ; } catch ( malformed object name exception e ) { throw new runtime exception ( str , e ) ; } }	create a connection to the jmx agent and setup the m [ x ] bean proxies .
public static void show ( @ not null final j data component , @ nullable final j action listener component , @ not null final string title , @ not null final project project , @ nullable final collection < runnable > close listeners , @ not null final an action ... custom actions ) { final tool window api api = new tool window api ( project , title ) ; final collection < runnable > close listeners to add = new array list < runnable > ( collections . singleton ( new my tool window closer ( api ) ) ) ; if ( close listeners != null ) { close listeners to add . add all ( close listeners ) ; } api . add ( panel with actions . wrap ( data component , close listeners to add , action listener component , custom actions ) ) ; }	displays some component in the toolwindow.
public intent builder add email cc ( string address ) { if ( m cc addresses == null ) { m cc addresses = new array list < string > ( ) ; } m cc addresses . add ( address ) ; return this ; }	add an email address to be used in the " cc " field of the final intent .
private array list < string > extract n ( ) { array list < string > list = new array list < string > ( ) ; n ngram = new n ( ) ; for ( int i = num ; i < text . length ( ) ; ++ i ) { ngram . add char ( text . char at ( i ) ) ; for ( int n = num ; n <= n . n gram ; ++ n ) { string w = ngram . get ( n ) ; if ( w != null && word lang prob map . contains key ( w ) ) list . add ( w ) ; } } return list ; }	extract n - grams from target text.
protected void update keys ( ) { button info [ ] buttons = navigation buttons . load button map ( m context ) ; int visible count = num ; for ( int i = num ; i < buttons . length ; i ++ ) { int id = button ids [ i ] ; button info info = buttons [ m vertical ? buttons . length - i - num : i ] ; key button view button = ( key button view ) m parent . find view by id ( id ) ; boolean is small button = navigation buttons . is slot small [ i ] ; button . set info ( info , m vertical , is small button ) ; if ( ! info . equals ( navigation buttons . empty ) && ! is small button ) { visible count ++ ; } button . set translation x ( num ) ; m button views . set ( i , button ) ; } if ( is device phone ( m context ) ) { adjust padding ( visible count ) ; } update low lights ( visible count ) ; }	updates the buttons according to the key arrangement stored in settings provider.
public static final string read string ( byte [ ] bytes , string charset ) throws io { return read string ( bytes , num , bytes . length , charset . for name ( charset ) ) ; }	convert a byte array to a string ; consistently uses \ n line endings in java.
private void update command cache ( string group , string command , boolean need notify ) { string old command = command cache . get ( group ) ; if ( ! command . equals ( old command ) ) { command cache . put ( group , command ) ; if ( need notify ) { notify executor . execute ( new notify command ( group , command ) ) ; logger util . info ( string . format ( str , group , command ) ) ; } } else { logger util . info ( string . format ( str , group , command ) ) ; } }	update command cache of the group . update local cache when command changed , if need notify , notify command.
public void update language ( ) { create legend panel ( legend panel ) ; directory tree model . change root text ( i18n . tr ( str ) ) ; }	resets the text of various components to the current language .
public static byte [ ] decompress for zlib ( byte [ ] bytes to decompress ) { byte [ ] return values = null ; inflater inflater = new inflater ( ) ; int number of bytes to decompress = bytes to decompress . length ; inflater . set input ( bytes to decompress , num , number of bytes to decompress ) ; int buffer size in bytes = number of bytes to decompress ; int number of bytes decompressed so far = num ; list < byte > bytes decompressed so far = new array list < byte > ( ) ; try { while ( inflater . needs input ( ) == bool ) { byte [ ] bytes decompressed buffer = new byte [ buffer size in bytes ] ; int number of bytes decompressed this time = inflater . inflate ( bytes decompressed buffer ) ; number of bytes decompressed so far += number of bytes decompressed this time ; for ( int b = num ; b < number of bytes decompressed this time ; b ++ ) { bytes decompressed so far . add ( bytes decompressed buffer [ b ] ) ; } } return values = new byte [ bytes decompressed so far . size ( ) ] ; for ( int b = num ; b < return values . length ; b ++ ) { return values [ b ] = ( byte ) ( bytes decompressed so far . get ( b ) ) ; } } catch ( data format exception dfe ) { dfe . print stack trace ( ) ; } inflater . end ( ) ; return return values ; }	zlib decompress 2 byte.
protected boolean accept chunk ( final i < i > msg ) { if ( msg == null ) throw new illegal argument exception ( ) ; if ( ! msg . is materialized ( ) ) throw new illegal state exception ( ) ; final abstract running query q = get running query ( msg . get query id ( ) ) ; if ( q == null ) { throw new illegal state exception ( ) ; } if ( ! q . accept chunk ( msg ) ) { msg . release ( ) ; return bool ; } if ( ! is running ( ) ) { msg . release ( ) ; return bool ; } priority queue . add ( q ) ; return bool ; }	add a chunk of intermediate results for consumption by some query.
public string format ( object obj , string buffer to append to ) throws illegal argument exception { return format ( ( date ) obj , to append to ) ; }	format a given object .
void add member ( final type member member ) { preconditions . check not null ( member , str ) ; preconditions . check argument ( member . get parent type ( ) == this , str ) ; members . add ( member ) ; }	adds a member to this base type .
public synchronized void remove incremental classifier listener ( incremental classifier listener cl ) { m incremental classifier listeners . remove ( cl ) ; }	remove an incremental classifier listener.
public static number asinh ( number a ) { return fast math . asinh ( a . double value ( ) ) ; }	returns the hyperbolic arc sine of the number .
private string format names ( string [ ] names , int start index ) { string builder sb = new string builder ( ) ; if ( names != null ) { for ( string name : names ) { sb . append ( name . substring ( start index ) ) ; sb . append ( str ) ; } } return sb . to string ( ) ; }	converts an array of strings to a string delimited by a new line character for display purposes.
public string lookup prefix ( string uri ) { string found prefix = null ; enumeration prefixes = m namespaces . keys ( ) ; while ( prefixes . has more elements ( ) ) { string prefix = ( string ) prefixes . next element ( ) ; string uri2 = lookup namespace ( prefix ) ; if ( uri2 != null && uri2 . equals ( uri ) ) { found prefix = prefix ; break ; } } return found prefix ; }	given a namespace uri , and the namespaces mappings for the current element , return the current prefix for that uri .
public void remove all trailers ( ) { trailer . clear ( ) ; fire property change ( trailer , null , trailer ) ; }	removes the all trailers .
private static boolean version matches ( integer v1 , integer v2 ) { if ( v1 == null || v1 == num || v2 == null || v2 == num ) { return bool ; } return v1 . equals ( v2 ) ; }	determines if a kvno matches another kvno.
public static optional < string > package name ( string long name ) { if ( long name . contains ( dot ) ) { return optional . of ( long name . substring ( num , long name . last index of ( dot ) ) ) ; } else { return optional . empty ( ) ; } }	returns the ' package ' part of a long name.
public int [ ] [ ] e2f ( ) { int e dim = tgt end exclusive - tgt start inclusive ; int [ ] [ ] e2f = new int [ e dim ] [ ] ; for ( int i = tgt start inclusive ; i < tgt end exclusive ; ++ i ) { int local idx = i - tgt start inclusive ; int [ ] e2f i = sentence pair . e2f ( i ) ; int src align dim = e2f i . length ; e2f [ local idx ] = new int [ src align dim ] ; if ( src align dim > num ) { system . arraycopy ( e2f i , num , e2f [ local idx ] , num , src align dim ) ; for ( int j = num ; j < src align dim ; ++ j ) { e2f [ local idx ] [ j ] -= src start inclusive ; } } } return e2f ; }	return the rule - internal target - source alignment grid .
public void read exif ( string in file name ) throws file not found exception , io { if ( in file name == null ) { throw new illegal argument exception ( null argument string ) ; } input stream is = null ; try { is = ( input stream ) new buffered input stream ( new file input stream ( in file name ) ) ; read exif ( is ) ; } catch ( io e ) { close silently ( is ) ; throw e ; } is . close ( ) ; }	reads the exif tags from a file , clearing this exifinterface object ' s existing exif tags .
private void assert write result ( int size ) throws io { byte buffer buf = byte buffer . allocate ( size + num ) ; int count = num ; int total = num ; long begin time = system . current time millis ( ) ; while ( ( count = client channel . read ( buf ) ) != - num ) { total = total + count ; if ( system . current time millis ( ) - begin time > num ) { break ; } } assert equals ( total , size ) ; buf . flip ( ) ; for ( int i = num ; i < count ; i ++ ) { assert equals ( ( byte ) i , buf . get ( i ) ) ; } }	uses socketchannel . read ( bytebuffer ) to verify write result .
public static boolean is file upload available ( final boolean needs correct mime type ) { if ( build . version . sdk int == num ) { final string platform version = ( build . version . release == null ) ? str : build . version . release ; return ! needs correct mime type && ( platform version . starts with ( str ) || platform version . starts with ( str ) ) ; } else { return bool ; } }	returns whether file uploads can be used on the current device ( generally all platform versions except for 4.
@ override public string to string ( ) { if ( m b generate net ) { return to xmlbi ( ) ; } return m . to string ( ) ; }	returns either the net ( if bif format ) or the generated instances.
private boolean menu item action ( int screen x , int screen y , int action ) { list view list view = m app menu . get popup ( ) . get list view ( ) ; array list < view > item views = new array list < view > ( ) ; for ( int i = num ; i < list view . get child count ( ) ; ++ i ) { boolean has image buttons = bool ; if ( list view . get child at ( i ) instanceof linear layout ) { linear layout layout = ( linear layout ) list view . get child at ( i ) ; for ( int j = num ; j < layout . get child count ( ) ; ++ j ) { item views . add ( layout . get child at ( j ) ) ; if ( layout . get child at ( j ) instanceof image button ) has image buttons = bool ; } } if ( ! has image buttons ) item views . add ( list view . get child at ( i ) ) ; } boolean did perform click = bool ; for ( int i = num ; i < item views . size ( ) ; ++ i ) { view item view = item views . get ( i ) ; boolean should perform = item view . is enabled ( ) && item view . is shown ( ) && get screen visible rect ( item view ) . contains ( screen x , screen y ) ; switch ( action ) { case item action highlight : item view . set pressed ( should perform ) ; break ; case item action perform : if ( should perform ) { item view . perform click ( ) ; did perform click = bool ; } break ; case item action clear highlight all : item view . set pressed ( bool ) ; break ; default : assert bool ; break ; } } return did perform click ; }	performs the specified action on the menu item specified by the screen coordinate position .
public void toggle ( jfx drawer ) { if ( ! drawers . contains ( drawer ) ) add drawer ( drawer ) ; if ( drawer . is shown ( ) || drawer . is showing ( ) ) drawer . close ( ) ; else { update drawer position ( drawer ) ; drawer . open ( ) ; } }	toggle a drawer in the stack.
public static boolean is v ( ) { if ( is v != null ) { log . info ( str , is v . boolean value ( ) ) ; return is v . boolean value ( ) ; } final string [ ] cmd = { get ovf property cmd , is vapp } ; exec . result result = exec . sudo ( cmd timeout , cmd ) ; if ( ! result . exited normally ( ) ) { log . error ( str , result . get std error ( ) ) ; throw new illegal state exception ( str ) ; } if ( result . get exit value ( ) == num ) { log . info ( str ) ; is v = boolean . true ; return is v . boolean value ( ) ; } log . info ( str , result . get exit value ( ) ) ; is v = boolean . false ; return is v . boolean value ( ) ; }	check if current deployment is vmware vapp.
protected string to base64 ( byte [ ] data ) { return base64 . encode to string ( data , base64 . default ) ; }	return given bytes as a base64 encoded string .
@ override public string to verbose string ( ) { final string builder sb = new string builder ( ) ; print ( sb , num , verbosity . log with stacktrace ) ; return sb . to string ( ) ; }	provide a verbose string of the current allocator state.
public static long quantile ( long [ ] values , double quantile ) { if ( values == null ) throw new illegal argument exception ( str ) ; if ( quantile < num || quantile > num ) throw new illegal argument exception ( str ) ; long [ ] copy = new long [ values . length ] ; system . arraycopy ( values , num , copy , num , copy . length ) ; arrays . sort ( copy ) ; int index = ( int ) ( copy . length * quantile ) ; return copy [ index ] ; }	compute the requested quantile of the given array.
public void add tree update ( sld sld tree ) { tree update list . add ( sld tree ) ; }	adds the tree update .
public static double distance ( visual item vi1 , visual item vi2 ) { double dx = vi1 . get x ( ) - vi2 . get x ( ) ; double dy = vi1 . get y ( ) - vi2 . get y ( ) ; return math . sqrt ( dx * dx + dy * dy ) ; }	get the distance between the x , y points of two visualitems .
@ override public void validate request ( generic attribute resolve request request ) throws bad attribute resolve request exception { if ( log . is debug enabled ( ) ) log . debug ( str ) ; string site id = request . get site ( ) ; if ( null == site id ) throw new bad attribute resolve request exception ( hdfs . hdfs resource resolve format hint ) ; string file path = request . get query ( ) ; if ( null == file path || ! file path . starts with ( str ) ) throw new bad attribute resolve request exception ( hdfs . hdfs resource resolve format hint ) ; if ( log . is debug enabled ( ) ) log . debug ( str ) ; }	validate the passed request object it should have site id and file path.
public trigger when ( criterion criterion ) { if ( criterion != null ) { criterions . add ( criterion ) ; } return this ; }	set a conditional expression that restricts which rows will cause statements to be performed when the trigger is activated.
private static pair < string , string > offset ror ( final long offset , final i environment , final list < reil instruction > instructions , final string register node value1 , final string register node value2 , final string immediate node value ) { final string address = environment . get next variable string ( ) ; final string index = environment . get next variable string ( ) ; final string tmp var = environment . get next variable string ( ) ; final string tmp var1 = environment . get next variable string ( ) ; final string tmp var2 = environment . get next variable string ( ) ; final string tmp var3 = environment . get next variable string ( ) ; long base offset = offset ; instructions . add ( reil helpers . create bsh ( base offset ++ , dw , register node value2 , dw , str + integer . decode ( immediate node value ) , dw , tmp var1 ) ) ; instructions . add ( reil helpers . create bsh ( base offset ++ , dw , register node value2 , dw , string . value of ( num - integer . decode ( immediate node value ) ) , dw , tmp var2 ) ) ; instructions . add ( reil helpers . create or ( base offset ++ , dw , tmp var1 , dw , tmp var2 , dw , tmp var3 ) ) ; instructions . add ( reil helpers . create and ( base offset ++ , dw , tmp var3 , dw , d word bit mask , dw , index ) ) ; instructions . add ( reil helpers . create add ( base offset ++ , dw , register node value1 , dw , index , dw , tmp var ) ) ; instructions . add ( reil helpers . create and ( base offset ++ , dw , tmp var , dw , d word bit mask , dw , address ) ) ; return new pair < string , string > ( address , register node value1 ) ; }	operation : [ < rn > , + / - < rm > , ror # < shift_imm > ] 0b11 / ror or rrx / if shift_imm = = 0 then / rrx / index = ( c flag logical_shift_left 31 ) or ( rm logical_shift_right 1 ) else / ror / index = rm rotate_right shift_imm endcase if u = = 1 then address = rn + index else / u = = 0 / address = rn - index.
public void clear ( ) { m . clear ( ) ; m . clear ( ) ; try { add methods ( ) ; } catch ( exception e ) { e . print stack trace ( ) ; } }	removes all current methods and adds the methods according to the.
public static string join ( char sequence delimiter , object [ ] tokens ) { string builder sb = new string builder ( ) ; boolean first time = bool ; for ( object token : tokens ) { if ( first time ) { first time = bool ; } else { sb . append ( delimiter ) ; } sb . append ( token ) ; } return sb . to string ( ) ; }	returns a string containing the tokens joined by delimiters .
public static packet to packet ( byte buffer data ) { final byte code = data . get ( ) ; final short id = ( short ) ( ( data . get ( ) ) & num ) ; final short datalen = data . get short ( ) ; final byte [ ] auth data = new byte [ num ] ; data . get ( auth data ) ; final packet type type = packet type . get packet type ( code ) ; packet pkt = null ; switch ( type ) { case access accept : pkt = new access accept ( ) ; pkt . set authenticator ( new response authenticator ( auth data ) ) ; break ; case access challenge : pkt = new access challenge ( ) ; pkt . set authenticator ( new response authenticator ( auth data ) ) ; break ; case access reject : pkt = new access reject ( ) ; pkt . set authenticator ( new response authenticator ( auth data ) ) ; break ; case access request : pkt = new access request ( ) ; pkt . set authenticator ( new request authenticator ( auth data ) ) ; break ; case unknown : default : log . log ( level . warning , str + code + str ) ; return null ; } pkt . set identifier ( id ) ; attribute a = null ; while ( ( a = packet factory . next attribute ( data ) ) != null ) { pkt . add attribute ( a ) ; } return pkt ; }	unmarshalls from an bytebuffer the octet format of rfc 2865 and creates the corresponding package and instantiates its embedded authenticator and attributes .
public void unlock read locks ( ) { if ( database . is multi version ( ) ) { return ; } for ( int i = num ; i < locks . size ( ) ; i ++ ) { table t = locks . get ( i ) ; if ( ! t . is locked exclusively ( ) ) { synchronized ( database ) { t . unlock ( this ) ; locks . remove ( i ) ; } i -- ; } } }	unlock all read locks.
protected void process attributes ( ) { for ( final string tag : tags ) { for ( final string inherit : inherits ) { style sheet . add styles ( tag , style sheet . get styles ( inherit ) ) ; } style sheet . add styles ( tag , attributes ) ; } }	adds the stored attribute values to the style sheet.
private boolean is image ( string url ) { return url . matches ( regex . image pattern ) ; }	verifies if the url is an image.
public static boolean point in rotated rect ( float [ ] point , f bound , float rot ) { matrix m = new matrix ( ) ; float [ ] p = arrays . copy of ( point , num ) ; m . set rotate ( rot , bound . center x ( ) , bound . center y ( ) ) ; matrix m0 = new matrix ( ) ; if ( ! m . invert ( m0 ) ) return bool ; m0 . map points ( p ) ; return inclusive contains ( bound , p [ num ] , p [ num ] ) ; }	checks if a given point is within a rotated rectangle .
@ override public void warning ( string domain , string key , xml exception ) throws xni { if ( f error handler != null ) { sax sax exception = create sax ( exception ) ; try { f error handler . warning ( sax exception ) ; } catch ( sax e ) { throw create xml ( e ) ; } catch ( sax e ) { throw create xni ( e ) ; } } }	reports a warning . warnings are non - fatal and can be safely ignored by most applications .
public void modify all ( map < string , collection < dynamic modification > > modifications , collection < throwable > problems ) throws cannot compile exception { for ( string class name : modifications . key set ( ) ) { try { modify ( class name , modifications . get ( class name ) ) ; } catch ( not found exception e ) { log . warn ( str + class name , e ) ; problems . add ( e ) ; } catch ( class not found exception e ) { log . warn ( str + class name , e ) ; problems . add ( e ) ; } catch ( io e ) { log . warn ( str + class name , e ) ; problems . add ( e ) ; } } }	apply several modifications to multiple classes.
public mutable location to mutable location ( world w ) { return new mutable location ( x , y , z , w ) ; }	creates a new mutablelocation with the coordinates of this vector .
public void read graphics ( object input stream objstream ) throws io { debug . message ( str , str ) ; try { while ( bool ) { try { om omg = ( om ) objstream . read object ( ) ; graphics . add ( omg ) ; } catch ( class not found exception e ) { e . print stack trace ( ) ; } catch ( optional data exception ode ) { ode . print stack trace ( ) ; } } } catch ( eof e ) { } }	read a cache of omgraphics , given a objectinputstream .
public void create topics ( int num partitions , int replication factor , set < string > topics ) { create topics ( num partitions , replication factor , topics . to array ( new string [ topics . size ( ) ] ) ) ; }	create the specified topics .
public synchronized void remove listener ( listener l ) { listeners . remove ( l ) ; }	removes a listener receiving progress notifications .
public command line add ( string ... args ) { if ( args != null && args . length > num ) { collections . add all ( arguments , args ) ; } return this ; }	adds list of arguments to command line .
private void restore icon ( backup protos . key key , byte [ ] buffer , int data size ) throws io { if ( verbose ) log . v ( tag , str + key . id ) ; if ( debug ) log . d ( tag , str + buffer . length + str + base64 . encode to string ( buffer , num , data size , base64 . no wrap ) ) ; backup protos . resource res = unpack proto ( new backup protos . resource ( ) , buffer , data size ) ; if ( debug ) { log . d ( tag , str + res . dpi + str ) ; } bitmap icon = bitmap factory . decode byte array ( res . data , num , res . data . length ) ; if ( icon == null ) { log . w ( tag , str + key . name ) ; } else { if ( verbose ) log . v ( tag , str + key . name ) ; m icon cache . preload icon ( component name . unflatten from string ( key . name ) , icon , res . dpi , str , m user serial , m idp ) ; } }	read an icon from the stream.
public static int determine consecutive digit count ( char sequence msg , int startpos ) { int count = num ; int len = msg . length ( ) ; int idx = startpos ; if ( idx < len ) { char ch = msg . char at ( idx ) ; while ( is digit ( ch ) && idx < len ) { count ++ ; idx ++ ; if ( idx < len ) { ch = msg . char at ( idx ) ; } } } return count ; }	determines the number of consecutive characters that are encodable using numeric compaction .
public event store builder use ssl connection ( string certificate common name ) { settings builder . ssl settings ( ssl settings . trust certificate cn ( certificate common name ) ) ; return this ; }	enables connection encryption using ssl and trusts an x.
action map create action map ( ) { action map map = new ui ( ) ; map . put ( str , new show system menu action ( bool ) ) ; map . put ( str , new show system menu action ( bool ) ) ; return map ; }	create the action map for the system menu .
protected void paint content border left edge ( graphics g , int x , int y , int w , int h , boolean draw broken , rectangle sel rect , boolean is content border painted ) { if ( is content border painted ) { g . set color ( select highlight ) ; g . fill rect ( x , y , num , h - num ) ; } }	draws the left edge of the border around the content area . draw broken line if selected tab is visible and adjacent to content and tabplacement is same as painted edge.
private string field param comment ( field field , string param comment ) { string comment type = field type cardinality comment ( field ) ; string comment = string . format ( str , wrap if keyword or built in ( field . get simple name ( ) ) , comment type ) ; if ( param comment == null ) { param comment = documentation util . get scoped description ( field ) ; } if ( ! strings . is null or empty ( param comment ) ) { param comment = r . rdocify ( param comment ) ; comment += str + param comment . replace all ( str , str ) ; } return comment + str ; }	returns a yard comment string for the field as a parameter to a function .
public static long period end ( long now , long period ) { local date time time = local date time . of epoch second ( now / num , num , zone offset . utc ) ; long end time = period end ( now , period , time ) ; return end time ; }	calculates the next period end.
public static string generate chat id ( final string receiver id , final string sender id ) { string combined = null ; if ( receiver id . compare to ( sender id ) < num ) { combined = string . format ( locale . us , app constants . chat id format , receiver id , sender id ) ; } else { combined = string . format ( locale . us , app constants . chat id format , sender id , receiver id ) ; } string hashed = null ; try { hashed = utils . sha1 ( combined ) ; } catch ( final no such algorithm exception e ) { hashed = combined ; } return hashed ; }	generates as chat id which will be unique for a given sender / receiver pair.
void extract ( string fname , string files [ ] ) throws io { zip file zf = new zip file ( fname ) ; set < zip entry > dirs = new dir set ( ) ; enumeration < ? extends zip entry > zes = zf . entries ( ) ; while ( zes . has more elements ( ) ) { zip entry e = zes . next element ( ) ; if ( files == null ) { dirs . add ( extract file ( zf . get input stream ( e ) , e ) ) ; } else { string name = e . get name ( ) ; for ( string file : files ) { if ( name . starts with ( file ) ) { dirs . add ( extract file ( zf . get input stream ( e ) , e ) ) ; break ; } } } } zf . close ( ) ; update last modified time ( dirs ) ; }	extracts specified entries from jar file , via zipfile .
public void remove ( menu component m ) { synchronized ( get tree lock ( ) ) { int index = menus . index of ( m ) ; if ( index >= num ) { remove ( index ) ; } } }	removes the specified menu component from this menu bar .
public void test identity ( ) { assert not null ( new identity stub ( ) ) ; }	verify identity ( ) creates instance.
public void key released ( final key event k ) { }	task to perform when keyboard button is released .
public xml ( progress listener listener ) { progress listener = listener ; }	creates a new importer that reports progress to the given listener .
private static tree map < integer , long > load workspace screens db ( context context ) { final content resolver content resolver = context . get content resolver ( ) ; final uri screens uri = launcher settings . workspace screens . content uri ; final cursor sc = content resolver . query ( screens uri , null , null , null , null ) ; tree map < integer , long > ordered screens = new tree map < integer , long > ( ) ; try { final int id index = sc . get column index or throw ( launcher settings . workspace screens . id ) ; final int rank index = sc . get column index or throw ( launcher settings . workspace screens . screen rank ) ; while ( sc . move to next ( ) ) { try { long screen id = sc . get long ( id index ) ; int rank = sc . get int ( rank index ) ; ordered screens . put ( rank , screen id ) ; } catch ( exception e ) { launcher . add dump log ( tag , str + e , bool ) ; } } } finally { sc . close ( ) ; } launcher . add dump log ( tag , str , bool ) ; array list < string > ordered screens pairs = new array list < string > ( ) ; for ( integer i : ordered screens . key set ( ) ) { ordered screens pairs . add ( str + i + str + ordered screens . get ( i ) + str ) ; } launcher . add dump log ( tag , str + text utils . join ( str , ordered screens pairs ) , bool ) ; return ordered screens ; }	loads the workspace screens db into a map of rank - > screenid.
public observable < drive id > create file ( drive folder folder , final file file ) { return create file ( folder , file , file . get name ( ) ) ; }	creates a file on drive.
public static void validate context ( accel surface src data , accel surface dst data , region clip , composite comp , affine transform xform , paint paint , d sg2d , int flags ) { buffered context context = dst data . get context ( ) ; context . validate ( src data , dst data , clip , comp , xform , paint , sg2d , flags ) ; }	fetches the bufferedcontextcontext associated with the dst.
public label value comparator ( final locale locale ) { c = collator . get instance ( locale ) ; }	creates a new labelvaluecomparator object .
public refresher ( gl scene ) { preconditions . check not null ( scene ) ; this . scene = scene ; }	construct a refresher for the given scene .
public rect update fast scroller bounds ( int last touch y ) { m invalidate rect . set ( m bg bounds ) ; if ( is visible ( ) ) { int edge padding = m rv . get max scrollbar width ( ) ; int bg padding = ( m bg original size - m text bounds . height ( ) ) / num ; int bg height = m bg original size ; int bg width = math . max ( m bg original size , m text bounds . width ( ) + ( num * bg padding ) ) ; if ( utilities . is rtl ( m res ) ) { m bg bounds . left = m rv . get background padding ( ) . left + ( num * m rv . get max scrollbar width ( ) ) ; m bg bounds . right = m bg bounds . left + bg width ; } else { m bg bounds . right = m rv . get width ( ) - m rv . get background padding ( ) . right - ( num * m rv . get max scrollbar width ( ) ) ; m bg bounds . left = m bg bounds . right - bg width ; } m bg bounds . top = last touch y - ( int ) ( fast scroll overlay y offset factor * bg height ) ; m bg bounds . top = math . max ( edge padding , math . min ( m bg bounds . top , m rv . get height ( ) - edge padding - bg height ) ) ; m bg bounds . bottom = m bg bounds . top + bg height ; } else { m bg bounds . set empty ( ) ; } m invalidate rect . union ( m bg bounds ) ; return m invalidate rect ; }	updates the bounds for the fast scroller .
public void build unique id ( ) throws v { string name = get name ( ) ; if ( ! name . contains ( vplex name delim ) ) { s logger . warn ( str + name ) ; unique id = name ; return ; } int last delim index = name . last index of ( vplex name delim ) ; string suffix = name . substring ( last delim index + num ) ; s logger . info ( str , name , suffix ) ; unique id = suffix ; }	creates a unique id for the storage system based on the vplex system name.
public static string create base64 ( bitmap m bitmap ) { byte array output stream baos1 = new byte array output stream ( ) ; m bitmap . compress ( bitmap . compress format . jpeg , num , baos1 ) ; byte [ ] b1 = baos1 . to byte array ( ) ; return base64 . encode to string ( b1 , base64 . default ) ; }	generate base64 from bitmap image.
@ override public boolean equals ( object obj ) { if ( obj == this ) { return bool ; } if ( ! ( obj instanceof candlestick renderer ) ) { return bool ; } candlestick renderer that = ( candlestick renderer ) obj ; if ( this . candle width != that . candle width ) { return bool ; } if ( ! paint utilities . equal ( this . up paint , that . up paint ) ) { return bool ; } if ( ! paint utilities . equal ( this . down paint , that . down paint ) ) { return bool ; } if ( this . draw volume != that . draw volume ) { return bool ; } if ( this . max candle width in milliseconds != that . max candle width in milliseconds ) { return bool ; } if ( this . auto width method != that . auto width method ) { return bool ; } if ( this . auto width factor != that . auto width factor ) { return bool ; } if ( this . auto width gap != that . auto width gap ) { return bool ; } if ( this . use outline paint != that . use outline paint ) { return bool ; } if ( ! paint utilities . equal ( this . volume paint , that . volume paint ) ) { return bool ; } return super . equals ( obj ) ; }	tests this renderer for equality with another object .
public header iterator iterator ( ) { return new basic list header iterator ( this . headers , null ) ; }	returns an iterator over this group of headers .
public static < t1 , t2 > void transform ( collection < t1 > from , collection < t2 > to , transformer < t1 , t2 > transformer ) { for ( t1 instance : from ) { to . add ( transformer . transform ( instance ) ) ; } }	transforms a collection of one data type into another .
public static string generate code ( ) { return generate code ( codesize ) ; }	generates a pseudo random string using the allowed characters.
public void flush ( ) throws java . io . io { m os . flush ( ) ; }	flush the stream . if the stream has saved any characters from the various write ( ) methods in a buffer , write them immediately to their intended destination . then , if that destination is another character or byte stream , flush it . thus one flush ( ) invocation will flush all the buffers in a chain of writers and outputstreams .
private void combine entries ( array list < long [ ] > list , int total ) { collections . sort ( list , this ) ; for ( int min gap = num ; min gap < total ; min gap += min gap / num ) { for ( int i = num ; i < list . size ( ) - num ; i ++ ) { long [ ] current = list . get ( i ) ; long [ ] next = list . get ( i + num ) ; if ( current [ num ] + min gap >= next [ num ] ) { current [ num ] = next [ num ] ; list . remove ( i + num ) ; i -- ; } } int searched = num ; for ( long [ ] range : list ) { searched += range [ num ] - range [ num ] + num ; } if ( searched > num * total || list . size ( ) < num ) { break ; } } }	combine entries if the size of the list is too large .
@ override public void write string ( byte [ ] str , int offset , int length ) throws io { if ( str == null ) write int ( num ) ; else { if ( use compression && length >= compressor . min size for deflation ) { if ( byte buffer . length < length ) byte buffer = new byte [ num * length ] ; int number of bytes = compressor . deflate string2 byte array ( str , offset , length , byte buffer ) ; write int ( number of bytes ) ; io . write ( byte buffer , num , math . abs ( number of bytes ) ) ; } else { write int ( length ) ; io . write ( str , offset , length ) ; } } }	write a string , compressed , if long enough.
public void test generate domain limit ( ) throws exception { array list < url > list = new array list < url > ( ) ; list . add ( create url ( str , num , num ) ) ; list . add ( create url ( str , num , num ) ) ; list . add ( create url ( str , num , num ) ) ; create crawl db ( list ) ; configuration my configuration = new configuration ( conf ) ; my configuration . set int ( generator . generator max count , num ) ; my configuration . set ( generator . generator count mode , generator . generator count value domain ) ; path generated segment = generate fetchlist ( integer . max value , my configuration , bool ) ; path fetchlist path = new path ( new path ( generated segment , crawl datum . generate dir name ) , str ) ; array list < url > fetch list = read contents ( fetchlist path ) ; assert equals ( num , fetch list . size ( ) ) ; my configuration = new configuration ( my configuration ) ; my configuration . set int ( generator . generator max count , num ) ; generated segment = generate fetchlist ( integer . max value , my configuration , bool ) ; fetchlist path = new path ( new path ( generated segment , crawl datum . generate dir name ) , str ) ; fetch list = read contents ( fetchlist path ) ; assert equals ( num , fetch list . size ( ) ) ; my configuration = new configuration ( my configuration ) ; my configuration . set int ( generator . generator max count , num ) ; generated segment = generate fetchlist ( integer . max value , my configuration , bool ) ; fetchlist path = new path ( new path ( generated segment , crawl datum . generate dir name ) , str ) ; fetch list = read contents ( fetchlist path ) ; assert equals ( num , fetch list . size ( ) ) ; }	test that generator obeys the property " generator.
protected void write column not nullable stmt ( string builder ddl ) { ddl . append ( str ) ; }	prints that a column is not nullable .
private static output stream wrap output stream ( final output stream stream ) { string os = system . get property ( str ) ; if ( os . starts with ( str ) ) { try { return new windows ansi output stream ( stream ) ; } catch ( throwable ignore ) { } return new ansi output stream ( stream ) ; } return stream ; }	returns an ansi output stream handler.
@ override public set < location > unmarshal ( locations type locations type ) { set < location > locations = new linked hash set < location > ( ) ; locations . add all ( locations type . get rps blast locations ( ) ) ; locations . add all ( locations type . get hmmer2 locations ( ) ) ; locations . add all ( locations type . get hmmer3 locations ( ) ) ; locations . add all ( locations type . get super family hmmer3 locations ( ) ) ; locations . add all ( locations type . get finger prints locations ( ) ) ; locations . add all ( locations type . get blast pro dom locations ( ) ) ; locations . add all ( locations type . get pattern scan locations ( ) ) ; locations . add all ( locations type . get profile scan locations ( ) ) ; locations . add all ( locations type . get phobius locations ( ) ) ; locations . add all ( locations type . get coils locations ( ) ) ; locations . add all ( locations type . get panther locations ( ) ) ; locations . add all ( locations type . get signal p ( ) ) ; locations . add all ( locations type . get tmhmm ( ) ) ; return locations ; }	map xml type to java.
public int write key ( output stream out ) throws io { out . write ( block buffer , key offset , klen ) ; return klen ; }	writing the key to the output stream.
boolean descends from ( class file cf ) { return descends from ( cf . to string ( ) ) ; }	answers whether this class is an immediate descendant ( as subclass or as an implementation of an interface ) of the given class .
protected object write pre process ( object o ) throws exception { return o ; }	enables derived classes to due some pre - processing on the objects , that ' s about to be serialized.
public expression parser builder with dynamics ( resolver resolver ) { dynamics resolvers . add ( resolver ) ; return this ; }	adds the resolver as a resolver for dynamic variables ( [ variable_name ] or variable_name in the expression ) .
void warn missing names ( file file ) { string result = check missing names ( file ) ; if ( result . equals ( str ) ) { j . show message dialog ( who , str ) ; } else { j . show message dialog ( who , result ) ; } }	check for names in programer that are not in names . xml.
public void add ( int position , wishlist item wishlist item ) { notify item inserted ( position ) ; wishlist items . add ( position , wishlist item ) ; }	add item to list , and notify concrete addition .
protected void print band ( byte [ ] bgr data , int x , int y , int width , int height ) throws printer exception { m ps . println ( image save ) ; int ps bytes per row = num * width ; while ( ps bytes per row > max psstr ) { ps bytes per row /= num ; } m ps . println ( ps bytes per row + image str ) ; m ps . println ( str + width + str + str + height + str + x + str + y + str ) ; m ps . println ( width + str + height + str + num + str + width + str + str + - height + str + height + str + str ) ; int index = num ; byte [ ] rgb data = new byte [ width * num ] ; try { for ( int i = num ; i < height ; i ++ ) { index = swap bg rgb ( bgr data , index , rgb data ) ; byte [ ] encoded data = rl encode ( rgb data ) ; byte [ ] ascii data = ascii85 encode ( encoded data ) ; m ps . write ( ascii data ) ; m ps . println ( str ) ; } } catch ( io e ) { throw new io ( e ) ; } m ps . println ( image restore ) ; }	prints the contents of the array of ints , ' data ' to the current page.
private void init panel ( final i < c > root tag ) { final j main panel = new j ( new border layout ( ) ) ; main panel . set border ( new titled border ( str ) ) ; create tree ( root tag ) ; final j pane = new j ( m tag tree ) ; pane . set vertical scroll bar policy ( scroll pane constants . vertical scrollbar as needed ) ; pane . set horizontal scroll bar policy ( scroll pane constants . horizontal scrollbar as needed ) ; final j any tag panel = new j ( ) ; any tag panel . add ( m any tag box ) ; main panel . add ( pane , border layout . center ) ; main panel . add ( m any tag box , border layout . south ) ; add ( main panel , border layout . center ) ; }	initializes the gui of the tag .
public final void append ( string value ) { if ( value == null ) return ; int strlen = value . length ( ) ; if ( num == strlen ) return ; int copyfrom = num ; char [ ] chunk = m array [ m last chunk ] ; int available = m chunk size - m first free ; while ( strlen > num ) { if ( available > strlen ) available = strlen ; value . get chars ( copyfrom , copyfrom + available , m array [ m last chunk ] , m first free ) ; strlen -= available ; copyfrom += available ; if ( strlen > num ) { int i = m array . length ; if ( m last chunk + num == i ) { char [ ] [ ] newarray = new char [ i + num ] [ ] ; system . arraycopy ( m array , num , newarray , num , i ) ; m array = newarray ; } chunk = m array [ ++ m last chunk ] ; if ( chunk == null ) { if ( m last chunk == num << m rebundle bits && m chunk bits < m max chunk bits ) { m inner fsb = new fast string buffer ( this ) ; } chunk = m array [ m last chunk ] = new char [ m chunk size ] ; } available = m chunk size ; m first free = num ; } } m first free += available ; }	append the contents of a string onto the faststringbuffer , growing the storage if necessary.
protected void add prefix match ( string builder sb , string surface , string analyzed , string prefix token ) { if ( prefix token . length ( ) >= surface . length ( ) ) { add whole match ( sb , surface , analyzed ) ; return ; } sb . append ( str ) ; sb . append ( surface . substring ( num , prefix token . length ( ) ) ) ; sb . append ( str ) ; sb . append ( surface . substring ( prefix token . length ( ) ) ) ; }	called while highlighting a single result , to append a matched prefix token , to the provided fragments list .
public wallet data add wallet ( final bitcoin controller bitcoin controller , wallet wallet , string wallet filename ) { if ( wallet filename == null ) { return null ; } for ( wallet data loop model data : per wallet model data list ) { if ( wallet filename . equals ( loop model data . get wallet filename ( ) ) ) { return loop model data ; } } wallet data new per wallet model data = new wallet data ( ) ; new per wallet model data . set wallet ( wallet ) ; new per wallet model data . set wallet filename ( wallet filename ) ; new per wallet model data . set wallet table data list ( new array list < wallet table data > ( ) ) ; if ( there is no active wallet ( ) ) { per wallet model data list . remove ( active wallet model data ) ; active wallet model data = new per wallet model data ; } per wallet model data list . add ( new per wallet model data ) ; if ( wallet != null ) { wallet . add event listener ( bitcoin controller ) ; } create wallet table data ( bitcoin controller , wallet filename ) ; create address book receiving addresses ( wallet filename ) ; return new per wallet model data ; }	add a new wallet to the list of managed wallets .
public void add ( t object ) { synchronized ( m lock ) { if ( m original values != null ) { m original values . add ( object ) ; } else { m objects . add ( object ) ; } } if ( m notify on change ) notify data set changed ( ) ; }	adds the specified object at the end of the array .
public boolean equals ( object another ) { if ( another instanceof permission ) { permission p = ( permission ) another ; return permission . equals ( p . to string ( ) ) ; } else { return bool ; } }	this function returns true if the object passed matches the permission represented in this interface .
public static intent build start in terminal intent ( file script ) { final component name component name = constants . s a service launcher component name ; intent intent = new intent ( ) ; intent . set component ( component name ) ; intent . set action ( constants . action launch foreground script ) ; intent . put extra ( constants . extra script path , script . get absolute path ( ) ) ; return intent ; }	builds an intent that launches a script in a terminal .
public document load document ( resource file ) throws sax , io { dom parser = new dom ( ) ; input stream in = null ; try { in = file . get input stream ( ) ; input source source = new input source ( in ) ; parser . parse ( source ) ; } finally { io . close el ( in ) ; } return parser . get document ( ) ; }	load a xml document as dom representation.
public void reset filters ( boolean enabled ) { if ( logger . is loggable ( level . fine ) ) { logger . fine ( str + enabled ) ; } set keys = filters . key set ( ) ; for ( iterator it = keys . iterator ( ) ; it . has next ( ) ; ) { string title = ( string ) it . next ( ) ; set filter value ( title , enabled ) ; } update interface ( ) ; }	set the filters on / off so that all event handlers will return anything they have , and rebuild interface .
@ override public boolean generate event id ( ) { return bool ; }	eventids are generated for partitionedregion .
private void update utility ( ) { for ( individual individual : population ) { double old fitness = individual . get fitness ( ) ; double new fitness = fitness ( individual . get solution ( ) , ideal point ) ; double relative decrease = old fitness - new fitness ; if ( relative decrease > num ) { individual . set utility ( num ) ; } else { double utility = math . min ( num , num * ( num + delta / num ) * individual . get utility ( ) ) ; individual . set utility ( utility ) ; } individual . set fitness ( new fitness ) ; } }	updates the utility of each individual .
private void write keys with prefix ( string prefix ) { for ( string key : keys ) { if ( key . starts with ( prefix ) ) { ps . println ( key + str + prop . get property ( key ) ) ; } } ps . println ( ) ; }	writes all keys starting with the specified prefix in alphabetical order .
public list < operation > send and wait ( list < operation > ops ) { return send and wait ( ops , bool ) ; }	perform given operations in parallel , then wait all ops to finish with success.
public static void copy ( byte [ ] in , output stream out ) throws io { assert . not null ( in , str ) ; assert . not null ( out , str ) ; try { out . write ( in ) ; } finally { try { out . close ( ) ; } catch ( io ex ) { } } }	copy the contents of the given byte array to the given outputstream.
public action map to xacml ( string native action name , string service name ) throws xacml { return null ; }	returns xacml context action.
private int next int ( string tokenizer tok , string error msg ) throws sax { if ( ! tok . has more tokens ( ) ) { throw new sax ( error msg ) ; } try { return integer . parse int ( tok . next token ( ) ) ; } catch ( number format exception nfe ) { throw new sax ( error msg ) ; } }	convenience method to return the next int , or throw if there are no more valid ints .
public calculable ( string id , double value ) { set id ( id ) ; set value ( value ) ; set when ( system . current time millis ( ) ) ; }	create a new calculable that records the time.
public static boolean bookmark node exists ( context context , long node id ) { boolean result = chrome browser provider call ( boolean . class , chrome browser provider . client api bookmark node exists , context , args to bundle ( node id ) ) ; return result != null ? result . boolean value ( ) : bool ; }	verifies if a bookmark node given by its id exists in the bookmark model .
private void execute tasks simultaneously with barrier ( runnable ... tasks ) throws interrupted exception { count down latch latch = new count down latch ( tasks . length ) ; for ( runnable task : tasks ) { executor . execute ( null ) ; } latch . await ( ) ; }	runs given tasks simultaneously and wait until they finish .
private boolean is operator ( char tok ) { if ( operators . index of ( tok ) == - num ) { return bool ; } return bool ; }	returns true if a token is an operator.
protected string format iterable ( jc d , iterable < ? > it , locale l ) { string builder sbuf = new string builder ( ) ; string sep = str ; for ( object o : it ) { sbuf . append ( sep ) ; sbuf . append ( format argument ( d , o , l ) ) ; sep = str ; } return sbuf . to string ( ) ; }	format an iterable argument of a given diagnostic .
public static module version value of ( string string ) { return parse version ( string ) ; }	get the version from a string.
@ override public boolean equals ( object other obj ) { if ( other obj instanceof p2 model ) { return content . equals ( ( ( p2 model ) other obj ) . content ) ; } else { return bool ; } }	two models are equal if all their fields are equal .
public boolean show icons ( ) { return preferences . get boolean ( resources . get string ( r . string . key show icons ) , boolean . parse boolean ( resources . get string ( r . string . default show icons ) ) ) ; }	show icons to highlight special events.
private boolean check for key ( ) throws exception { string query = m query ; query = query . replace all ( str , str ) ; if ( ! query . starts with ( str ) ) { return bool ; } m order by . clear ( ) ; if ( ! m . is connected ( ) ) { m . connect to database ( ) ; } database meta data dmd = m . get meta data ( ) ; string table = end of query ( bool ) ; result set rs = dmd . get primary keys ( null , null , table ) ; while ( rs . next ( ) ) { m order by . add ( rs . get string ( num ) ) ; } rs . close ( ) ; if ( m order by . size ( ) != num ) { return bool ; } rs = dmd . get best row identifier ( null , null , table , database meta data . best row session , bool ) ; result set meta data rmd = rs . get meta data ( ) ; int help = num ; while ( rs . next ( ) ) { m order by . add ( rs . get string ( num ) ) ; help ++ ; } rs . close ( ) ; if ( help == rmd . get column count ( ) ) { m order by . clear ( ) ; } if ( m order by . size ( ) != num ) { return bool ; } return bool ; }	checks for a unique key using the jdbc driver ' s method : getprimarykey ( ) , getbestrowidentifier ( ).
public ignite striped thread pool executor ( int concurrent lvl , string grid name , string thread name prefix ) { execs = new executor service [ concurrent lvl ] ; thread factory factory = new ignite thread factory ( grid name , thread name prefix ) ; for ( int i = num ; i < concurrent lvl ; i ++ ) execs [ i ] = executors . new single thread executor ( factory ) ; }	create striped thread pool .
public static boolean is zip ( buffered input stream in ) { in . mark ( num ) ; byte [ ] b = new byte [ num ] ; byte [ ] zip sig = new byte [ num ] ; zip sig [ num ] = num ; zip sig [ num ] = num ; zip sig [ num ] = num ; zip sig [ num ] = num ; try { in . read ( b , num , num ) ; } catch ( exception ex ) { throw new runtime exception ( str , ex ) ; } try { in . reset ( ) ; } catch ( exception ex ) { throw new runtime exception ( str , ex ) ; } return arrays . equals ( b , zip sig ) ; }	test for zip stream signature .
public list < string > extract ( configuration config ) { list < string > features = new array list < string > ( ) ; for ( extractor fe : extractors ) { features . add ( fe . extract ( config ) ) ; } return features ; }	extracts all feature from this configuration .
public string to string ( ) { string buffer path = new string buffer ( ) ; if ( absolute ) path . append ( str ) ; for ( int i = num ; i < elements . size ( ) ; i ++ ) { if ( i > num ) path . append ( str ) ; path . append ( elements . get ( i ) ) ; } return path . to string ( ) ; }	returns a full path with leading " / " if absolute .
@ override protected boolean check ( file item ) { return item . exists ( ) ; }	checks the item after obtaining from the props file.
public property value editor ( console application app , management context context ) { this . app = app ; this . context = context ; }	create a new property value editor which will read from the provided application console .
@ override public void to data ( data output out ) throws io { out . write int ( max inactive interval ) ; out . write long ( last accessed time ) ; synchronized ( attributes ) { out . write int ( attributes . size ( ) ) ; for ( map . entry < string , object > entry : attributes . entry set ( ) ) { delta event delta = new delta event ( bool , entry . get key ( ) , entry . get value ( ) ) ; data serializer . write object ( delta , out ) ; } } out . write utf ( jvm owner id ) ; }	use deltaevents to propagate the actual attribute data - deltaevents turn the values into byte arrays which means that the actual domain classes are not required on the server .
public void create victory conditions ( ) { victory = vf . create victory ( str ) ; }	use victoryfactory to generate a new victorycondition checker provided that the victorycontext is saved properly , calling this method at any time is ok and should not affect anything unless the victorycondition - configoptions have changed .
public static i validate qualified module name ( string qualified name ) { string pckg = signature . get qualifier ( qualified name ) ; if ( ! util . is valid package name ( pckg ) ) { return util . new error status ( str ) ; } return validate simple module name ( signature . get simple name ( qualified name ) ) ; }	validates a fully - qualified module name.
public static < t1 , t2 > map < t1 , t2 > synchronized map ( ) { return collections . synchronized map ( new hash map < t1 , t2 > ( ) ) ; }	creates a new synchronized map .
private final int filter status bytes ( byte [ ] src , byte [ ] dest , int total bytes read , int max packet size ) { final int packets count = total bytes read / max packet size + ( total bytes read % max packet size == num ? num : num ) ; for ( int packet idx = num ; packet idx < packets count ; ++ packet idx ) { final int count = ( packet idx == ( packets count - num ) ) ? ( total bytes read % max packet size ) - modem status header length : max packet size - modem status header length ; if ( count > num ) { system . arraycopy ( src , packet idx * max packet size + modem status header length , dest , packet idx * ( max packet size - modem status header length ) , count ) ; } } return total bytes read - ( packets count * num ) ; }	filter ftdi status bytes from buffer.
public boolean contains ( string key ) { return m shared preferences . contains ( key ) ; }	returns whether the settings contains a specific key.
int register miss ( ) { return misses . increment and get ( ) ; }	register a miss to this cache.
public static char sequence partial escape ( char sequence s ) { string builder sb = new string builder ( ) ; for ( int i = num ; i < s . length ( ) ; i ++ ) { char c = s . char at ( i ) ; if ( c == str || c == str || c == str || c == str || c == str || c == str || c == str || c == str || c == str || c == str || c == str || c == str || c == str || c == str ) { sb . append ( str ) ; } sb . append ( c ) ; } return sb ; }	escapes all special characters except ' " ' , ' - ' , and ' + '.
public void finished ( long work , long latency ) { finished updater . get and increment ( this ) ; total work updater . get and add ( this , work ) ; total work squared updater . get and add ( this , work * work ) ; total latency updater . get and add ( this , latency ) ; total latency squared updater . get and add ( this , latency * latency ) ; }	indicate that we have just finished an operation on this resource.
public void close ( ) throws io { if ( m input stream != null ) { m input stream . close ( ) ; } else { throw new io ( str ) ; } m input stream = null ; }	closes the source file.
private windows security descriptor ( ) { this . sid list = null ; this . acl buffer = null ; this . sd buffer = null ; }	creates the " null " securitydescriptor.
public void print usage ( output stream os ) { int count = num ; print stream out = ut . print stream ( os ) ; for ( string option : option list ) { if ( option groups . contains key ( count ) ) { out . println ( str + option groups . get ( count ) ) ; } count ++ ; if ( unlisted options . contains ( option ) ) { continue ; } out . print ( str ) ; string builder buf = new string builder ( ) ; buf . append ( option ) ; if ( option extra part synopsis map . get ( option ) != null ) { string option extra part synopsis = option extra part synopsis map . get ( option ) ; buf . append ( str ) ; buf . append ( option extra part synopsis ) ; buf . append ( str ) ; } if ( requires argument set . contains ( option ) ) { buf . append ( str ) ; buf . append ( argument description map . get ( option ) ) ; buf . append ( str ) ; } print field ( out , buf . to string ( ) , max width + num ) ; out . println ( option description map . get ( option ) ) ; } out . flush ( ) ; }	print command line usage information to given stream .
public void clear shared variables ( ) { shared variables . clear ( ) ; load built in shared variables ( ) ; }	removes all shared sharedvariables , except the predefined ones ( compress , html_escape , etc.
public final void send packet ( ls server packet bp ) { synchronized ( guard ) { if ( is write disabled ( ) ) { return ; } log . debug ( str + bp ) ; send msg queue . add last ( bp ) ; enable write interest ( ) ; } }	sends gsserverpacket to this client .
private static map < string , object > process section ( string section , collection < map < string , object > > hosts , map < string , object > dflts , map < string , object > props ) throws ignite checked exception { if ( section == null || props == null ) return null ; if ( dflt section . equals ignore case ( section ) ) { if ( dflts != null ) throw new ignite checked exception ( str + dflt section + str ) ; return props ; } else { hosts . add ( props ) ; return null ; } }	processes section of parsed ini file .
public boolean is set ( final option option ) { return options == null ? bool : options . contains ( option ) ; }	whether the passed in option is currently set .
public void handle button1 request ( request invocation event event ) throws model control exception { list option data = restore options data ( ) ; cc cb force reset pwd = ( cc ) get child ( cb force reset pwd ) ; boolean force reset pwd = cb force reset pwd . is checked ( ) ; um model = ( um ) get model ( ) ; string user id = ( string ) get page session attribute ( entity edit view bean . universal id ) ; try { model . modify user option ( option data , user id , force reset pwd ) ; set inline alert message ( cc . type info , str , model . get localized string ( str ) ) ; } catch ( am e ) { set inline alert message ( cc . type error , str , e . get message ( ) ) ; } forward to ( ) ; }	handles save password options request .
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add all ( collections . list ( super . list options ( ) ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
@ override public boolean queue request ( operation op ) { authorization context ctx = op . get authorization context ( ) ; if ( ctx == null ) { op . fail ( new illegal argument exception ( str ) ) ; return bool ; } claims claims = ctx . get claims ( ) ; if ( claims == null ) { op . fail ( new illegal argument exception ( str ) ) ; return bool ; } string subject = claims . get subject ( ) ; if ( subject == null ) { op . fail ( new illegal argument exception ( str ) ) ; return bool ; } if ( op . has pragma directive ( operation . pragma directive clear auth cache ) ) { return handle cache clear request ( op , subject ) ; } if ( subject . equals ( system user service . self link ) ) { op . complete ( ) ; return bool ; } if ( ctx . get resource query filter ( op . get action ( ) ) != null ) { op . complete ( ) ; return bool ; } return bool ; }	the service host will invoke this method to allow a service to handle the request in - line or indicate it should be scheduled by service host .
public spannable string builder ( char sequence text ) { this ( text , num , text . length ( ) ) ; }	create a new spannablestringbuilder containing a copy of the specified text , including its spans if any .
public boolean has extra fields ( pdx type other ) { for ( pdx field ft : this . fields ) { if ( ! ft . is deleted ( ) && other . get pdx field ( ft . get field name ( ) ) == null ) { return bool ; } } return bool ; }	return true if the this type has a field that the other type does not have .
public void put ( string id , string str ) { tab . put ( id , str ) ; if ( str . ends with ( str ) ) { int i = str . last index of ( file . separator ) ; if ( i >= num ) { tab . put ( str . substring ( i + num , str . length ( ) - num ) , str ) ; } } }	add a mapping from a public identifier to a path .
public static list < uri > ref ids ( collection < ? extends related resource rep > refs ) { list < uri > ids = new array list < uri > ( ) ; if ( refs != null ) { for ( related resource rep ref : refs ) { ids . add ( ref . get id ( ) ) ; } } return ids ; }	gets a list of ids of data objects , null safe .
public static boolean has top category ( http servlet request request , string category id , list < string > path elements ) { if ( category worker . is category top ( request , category id ) ) { return bool ; } string top category id = category worker . get top category from trail ( request , path elements ) ; if ( top category id != null ) { return bool ; } list < string > trail = category worker . get trail ( request ) ; top category id = category worker . get top category from trail ( request , trail ) ; if ( top category id == null ) { return bool ; } return bool ; }	scipio : returns true if the given category or any of the path elements is a top - level category .
@ override public string append ( string path , input stream is ) throws url , io , authentication exception { string resp = null ; ensure valid token ( ) ; string redirect url = null ; url conn = authenticated url . open connection ( new url ( new url ( httpfs url ) , message format . format ( str , path ) ) , token ) ; conn . set request method ( str ) ; conn . set instance follow redirects ( bool ) ; conn . connect ( ) ; logger . info ( str + conn . get header field ( str ) ) ; resp = result ( conn , bool ) ; if ( conn . get response code ( ) == num ) redirect url = conn . get header field ( str ) ; conn . disconnect ( ) ; if ( redirect url != null ) { conn = authenticated url . open connection ( new url ( redirect url ) , token ) ; conn . set request method ( str ) ; conn . set do output ( bool ) ; conn . set do input ( bool ) ; conn . set use caches ( bool ) ; conn . set request property ( str , str ) ; final int size = is . available ( ) ; conn . set request property ( str , str + size ) ; conn . set fixed length streaming mode ( size ) ; conn . connect ( ) ; output stream os = conn . get output stream ( ) ; copy ( is , os ) ; is . close ( ) ; os . close ( ) ; resp = result ( conn , bool ) ; conn . disconnect ( ) ; } return resp ; }	curl - i - x post " http : / / < host > : < port > / webhdfs / v1 / < path > ? op = append [ & buffersize = < int > ] ".
public static void cache imgs ( string skin img dir , iterable < string > base image ur ) { string skin dir = get skin dir ( ) ; for ( string img : base image ur ) { img = img . replace ( str , skin dir + str ) ; img = img . replace ( str , skin dir + skin img dir ) ; image . prefetch ( img ) ; } }	cache a list of images.
public void clear buffer ( ) { buffer . clear ( ) ; }	clear the message buffer.
protected void append string ( final string text ) { final html doc = ( html ) text pane . get document ( ) ; try { final element root = doc . get paragraph element ( num ) ; doc . insert before end ( root , text ) ; } catch ( final bad location exception e ) { logger . error ( e , e ) ; } catch ( final io e ) { logger . error ( e , e ) ; } }	append html text to the end of the content.
public void scale to samples ( int usr samples ) { double ratio ; ratio = ( double ) usr samples / count ; count = num ; for ( int i = num ; i <= limits . length ; ++ i ) { results [ i ] = ( int ) math . round ( results [ i ] * ratio ) ; count += results [ i ] ; } }	use the current distribution but scale the samples close to the user specified one.
private void refresh selected ( int offset x ) { int offset = ( int ) ( offset x + m max over scroll distance ) ; int temp index = math . round ( offset / m interval dis ) ; temp index = clamp selected index ( temp index ) ; if ( m selected index == temp index ) { return ; } m selected index = temp index ; if ( null != on value change listener ) { on value change listener . on change ( this , m selected index , float . parse float ( format ( m selected index * m interval value + m min value ) ) ) ; } }	refresh current selected index.
@ override @ suppress warnings ( str ) public void reset frame ( ) { synchronized ( lock ) { sys name . set text ( str + counter ++ ) ; } user name . set text ( null ) ; url . set text ( null ) ; stream . set selected ( bool ) ; stream . set enabled ( bool ) ; loop start . set value ( long . value of ( num ) ) ; loop end . set value ( long . value of ( num ) ) ; this . new buffer = bool ; }	method to populate the edit buffer frame with default values.
public expected records < t > repeat all ( int times ) { list < t > to append = new array list < > ( ) ; for ( int i = num ; i < times ; i ++ ) { to append . add all ( expected records ) ; } expected records . add all ( to append ) ; return this ; }	expect the current output a number of times.
protected static geo point parse kml coord ( string input ) { int end1 = input . index of ( str ) ; int end2 = input . index of ( str , end1 + num ) ; try { if ( end2 == - num ) { double lon = double . parse double ( input . substring ( num , end1 ) ) ; double lat = double . parse double ( input . substring ( end1 + num , input . length ( ) ) ) ; return new geo point ( lat , lon ) ; } else { double lon = double . parse double ( input . substring ( num , end1 ) ) ; double lat = double . parse double ( input . substring ( end1 + num , end2 ) ) ; double alt = double . parse double ( input . substring ( end2 + num , input . length ( ) ) ) ; return new geo point ( lat , lon , alt ) ; } } catch ( number format exception e ) { return null ; } catch ( index out of bounds exception e ) { return null ; } }	similar to geopoint . frominverteddoublestring , with exceptions handling.
@ nullable public calendar detect date ( string input ) { check not null ( input ) ; time . set time zone ( get time zone ( ) ) ; options opt = new com . sk89q . jchronic . options ( ) ; opt . set now ( calendar . get instance ( get time zone ( ) ) ) ; span date = chronic . parse ( input , opt ) ; if ( date == null ) { return null ; } else { return date . get begin calendar ( ) ; } }	detect date from a user ' s input .
public synchronized void save commit point ( long index commit gen ) { atomic integer reserve count = saved commits . get ( index commit gen ) ; if ( reserve count == null ) reserve count = new atomic integer ( ) ; reserve count . increment and get ( ) ; saved commits . put ( index commit gen , reserve count ) ; }	permanently prevent this commit point from being deleted.
public void remove searchable ( search result searchable ) { if ( searchables . contains ( searchable ) ) searchables . remove ( search ) ; }	remove a searchable item.
public static boolean is64bit ( ) { boolean is64bit = bool ; if ( is windows ( ) ) { is64bit = ( system . getenv ( str ) != null ) ; } else { is64bit = ( os arch . contains ( str ) ) ; } return is64bit ; }	checks descriptor based on os.
private int resolve size and state respecting min size ( int min size , int measured size , int measure spec ) { if ( min size != size unspecified ) { final int desired width = math . max ( min size , measured size ) ; return resolve size and state ( desired width , measure spec , num ) ; } else { return measured size ; } }	utility to reconcile a desired size and state , with constraints imposed by a measurespec.
public static boolean delete directory and contents ( file root directory ) { if ( ( root directory == null ) || ! root directory . is directory ( ) ) { return bool ; } try { string [ ] directory contents = root directory . list ( ) ; for ( int i = num ; i < directory contents . length ; i ++ ) { boolean success = delete directory and contents ( new file ( root directory , directory contents [ i ] ) ) ; if ( ! success ) { return bool ; } } return root directory . delete ( ) ; } catch ( exception e ) { logger . debug ( e . to string ( ) + system . line separator ( ) + stack trace . get string from stack trace ( e ) ) ; return bool ; } }	this is a quiet method.
public static void nanosleep ( long nanos ) throws interrupted exception { if ( thread . interrupted ( ) ) throw new interrupted exception ( ) ; if ( nanos <= num ) { return ; } if ( nanos >= num ) { thread . sleep ( nanos / num , ( int ) ( nanos % num ) ) ; } else { if ( pure mode ) { thread . yield ( ) ; } else { nanosleep ( ( int ) nanos ) ; } } }	sleeps for the specified number of nanoseconds .
int pure length ( ) { return length - delimiter . length ( ) ; }	returns the pure ( without the line delimiter ) length of this line .
private void add elements ( int value , int number of elements ) { if ( m first free + number of elements < m blocksize ) for ( int i = num ; i < number of elements ; i ++ ) { m map0 [ m first free ++ ] = value ; } else { int index = m first free > > > m shift ; int offset = m first free & m mask ; m first free += number of elements ; while ( number of elements > num ) { if ( index >= m map . length ) { int newsize = index + m numblocks ; int [ ] [ ] new map = new int [ newsize ] [ ] ; system . arraycopy ( m map , num , new map , num , m map . length ) ; m map = new map ; } int [ ] block = m map [ index ] ; if ( null == block ) block = m map [ index ] = new int [ m blocksize ] ; int copied = ( m blocksize - offset < number of elements ) ? m blocksize - offset : number of elements ; number of elements -= copied ; while ( copied -- > num ) block [ offset ++ ] = value ; ++ index ; offset = num ; } } }	append several int values onto the vector .
public static string builder format to ( string builder buf , double [ ] d , string sep ) { if ( d == null ) { return buf . append ( str ) ; } if ( d . length == num ) { return buf ; } buf . append ( d [ num ] ) ; for ( int i = num ; i < d . length ; i ++ ) { buf . append ( sep ) ; buf . append ( d [ i ] ) ; } return buf ; }	formats the double array d with the default number format .
private view fill from left ( int next left ) { m first position = math . min ( m first position , m selected position ) ; m first position = math . min ( m first position , m item count - num ) ; if ( m first position < num ) { m first position = num ; } return fill right ( m first position , next left ) ; }	fills the list from top to bottom , starting with mfirstposition.
public tomcat slf4j logback factory accessor ( class loader cl ) throws class not found exception , illegal access exception , illegal argument exception , invocation target exception { class clazz = cl . load class ( str ) ; method get singleton = method utils . get accessible method ( clazz , str , new class [ num ] ) ; object singleton = get singleton . invoke ( null ) ; method get logger factory = method utils . get accessible method ( clazz , str , new class [ num ] ) ; object logger factory = get logger factory . invoke ( singleton ) ; class logger factory class = cl . load class ( str ) ; if ( ! logger factory class . is instance ( logger factory ) ) { throw new runtime exception ( str ) ; } set target ( logger factory ) ; }	attempts to initialize a tomcatslf4jlogback logger factory via the given class loader .
public quarter date format ( time zone zone , string [ ] quarter symbols , boolean quarter first ) { param checks . null not permitted ( zone , str ) ; this . calendar = new gregorian calendar ( zone ) ; this . quarters = quarter symbols ; this . quarter first = quarter first ; this . number format = number format . get number instance ( ) ; }	creates a new instance for the specified time zone .
public long restart ( ) { long start = start time nanos ; start time nanos = system . nano time ( ) ; return start time nanos - start ; }	sets the reference time and returns the amount of time between now and the previous time the reference time was set.
private static byte [ ] string to byte array ( string str ) { byte [ ] result = new byte [ str . length ( ) + num ] ; for ( int i = num ; i < str . length ( ) ; i ++ ) { result [ i ] = ( byte ) str . char at ( i ) ; } result [ str . length ( ) ] = num ; return result ; }	returns this java string as a null - terminated byte array.
public static boolean has joda ( ) { try { class . for name ( str ) ; return bool ; } catch ( class not found exception e ) { return bool ; } }	returns true if joda is found on classpath .
public remote service descriptor ( string base url , http json request factory request factory ) throws illegal argument exception { this . base url = base url ; try { base url url = new url ( base url ) ; final string protocol = base url url . get protocol ( ) ; if ( ! ( protocol . equals ( str ) || protocol . equals ( str ) ) ) { throw new illegal argument exception ( string . format ( str , base url ) ) ; } } catch ( url e ) { throw new illegal argument exception ( string . format ( str , base url ) ) ; } this . request factory = request factory ; }	creates new descriptor of remote restful service .
private int find activity element ( int activity index ) { for ( int element index = num ; element index < m activity list . size ( ) ; element index ++ ) { if ( m activity list . get ( element index ) . m activity index == activity index ) { return element index ; } } return - num ; }	finds the index of the activityelement corresponding to the given activityindex .
public void map volume to sdc ( string volume id , string sdc id ) throws exception { log . info ( str ) ; string uri = io . get map volume to sdcuri ( volume id ) ; io sdc map parm = new io sdc ( ) ; map parm . set sdc id ( sdc id ) ; map parm . set allow multiple mappings ( str ) ; post ( uri . create ( uri ) , get json for entity ( map parm ) ) ; }	map volume to sdc.
public void add obscured recipient ( string player name ) { obscured recipients . add element ( player name ) ; }	internal method . not for typical use . < p > adds the given player name to the report ' s list of players who received an obscured version of this report from the server at some time in the past .
private static void replace collapsed by eclipse source roots ( element lib element , library . modifiable model modifiable model ) { string [ ] src urls from classpath = modifiable model . get urls ( order root type . sources ) ; log . assert true ( src urls from classpath . length <= num ) ; final string eclipse url = src urls from classpath . length > num ? src urls from classpath [ num ] : null ; for ( element r : lib element . get children ( srcroot attr ) ) { final string url = r . get attribute value ( str ) ; final string bind attr = r . get attribute value ( srcroot bind attr ) ; boolean not bind = bind attr != null && ! boolean . parse boolean ( bind attr ) ; if ( not bind ) { modifiable model . add root ( url , order root type . sources ) ; } else if ( eclipse url != null && are urls point the same ( url , eclipse url ) && ! comparing . str equal ( url , eclipse url ) ) { modifiable model . add root ( url , order root type . sources ) ; if ( src urls from classpath != null && src urls from classpath . length == num ) { modifiable model . remove root ( eclipse url , order root type . sources ) ; src urls from classpath = null ; } } } }	eclipse detect sources inside zip automatically while idea doesn ' t.
public static byte [ ] hex to bytes ( string hex string ) { byte [ ] result = new byte [ hex string . length ( ) / num ] ; for ( int i = num ; i < result . length ; ++ i ) { int offset = i * num ; result [ i ] = ( byte ) integer . parse int ( hex string . substring ( offset , offset + num ) , num ) ; } return result ; }	takes a string in hexadecimal format and converts it to a binary byte array.
private static string replace last ( string str , char from , char to ) { int index = str . last index of ( from ) ; if ( index == - num ) return str ; return str . substring ( num , index ) + to + str . substring ( index + num ) ; }	replace the last occurrence of from with to.
private static void clean stale initiator references ( export group export group , db client db client ) { string set export group initiators = export group . get initiators ( ) ; if ( ! collection utils . is empty ( export group initiators ) && ! collection utils . is empty ( export group . get export masks ( ) ) ) { set < string > all mask initiators = new hash set < > ( ) ; for ( string mask : export group . get export masks ( ) ) { export mask mask obj = db client . query object ( export mask . class , uri . create ( mask ) ) ; if ( mask obj != null && ! collection utils . is empty ( mask obj . get initiators ( ) ) ) { all mask initiators . add all ( mask obj . get initiators ( ) ) ; } } set < string > stale initiators = sets . difference ( export group initiators , all mask initiators ) ; if ( ! collection utils . is empty ( stale initiators ) ) { collection < uri > stale initiator uris = collections2 . transform ( stale initiators , common transformer functions . fctn string to uri ) ; export group . remove initiators ( new array list < > ( stale initiator uris ) ) ; log . info ( str , stale initiator uris , export group . get id ( ) ) ; } } }	cleans stale initiator references from export group instance.
public static < t > t find resource by name ( iterable < has metadata > entities , class < t > clazz , string name ) { if ( entities != null ) { for ( has metadata entity : entities ) { if ( clazz . is instance ( entity ) && objects . equals ( name , get name ( entity ) ) ) { return clazz . cast ( entity ) ; } } } return null ; }	returns the resource of the given kind and name from the collection or null.
public static map ordinal map ( iterator tuples , string field , comparator cmp ) { object [ ] o = ordinal array ( tuples , field , cmp ) ; hash map map = new hash map ( ) ; for ( int i = num ; i < o . length ; ++ i ) map . put ( o [ i ] , new integer ( i ) ) ; return map ; }	get map mapping from column values ( as object instances ) to their ordinal index in a sorted array .
void add line monitor ( line monitor lm ) { if ( printer . trace ) printer . trace ( str + lm + str ) ; synchronized ( line monitors ) { if ( line monitors . index of ( lm ) >= num ) { if ( printer . trace ) printer . trace ( str ) ; return ; } if ( printer . debug ) printer . debug ( str + lm ) ; line monitors . add ( lm ) ; } synchronized ( this ) { notify all ( ) ; } if ( printer . debug ) printer . debug ( str + line monitors . size ( ) + str ) ; }	add this linemonitor instance to the list of monitors.
public static string to char ( byte b ) { if ( b >= num ) { return character . to string ( ( char ) b ) ; } else { return string . format ( str , b ) ; } }	convert a byte to a character for printing . if the byte value is & lt ; 32 - and hence unprintable - the byte is returned as a two digit hex value.
public static double pt seg dist ( double x1 , double y1 , double x2 , double y2 , double px , double py ) { return math . sqrt ( pt seg dist sq ( x1 , y1 , x2 , y2 , px , py ) ) ; }	returns the distance from a point to a line segment.
method type as spreader type ( class < ? > array type , int array length ) { assert ( parameter count ( ) >= array length ) ; int spread pos = ptypes . length - array length ; if ( array length == num ) return this ; if ( array type == object [ ] . class ) { if ( is generic ( ) ) return this ; if ( spread pos == num ) { method type res = generic method type ( array length ) ; if ( rtype != object . class ) { res = res . change return type ( rtype ) ; } return res ; } } class < ? > elem type = array type . get component type ( ) ; assert ( elem type != null ) ; for ( int i = spread pos ; i < ptypes . length ; i ++ ) { if ( ptypes [ i ] != elem type ) { class < ? > [ ] fixed ptypes = ptypes . clone ( ) ; arrays . fill ( fixed ptypes , i , ptypes . length , elem type ) ; return method type ( rtype , fixed ptypes ) ; } } return this ; }	replace the last arraylength parameter types with the component type of arraytype .
public static mx i resolve ( mx i root , string path ) { mx i parent = root ; string [ ] tokens = path . split ( pattern . quote ( path separator ) ) ; for ( int i = num ; i < tokens . length ; i ++ ) { parent = parent . get child at ( integer . parse int ( tokens [ i ] ) ) ; } return parent ; }	returns the cell for the specified cell path using the given root as the root of the path .
private static int next non quote index ( string trimmed , int i , boolean forward ) { while ( trimmed . char at ( i ) == str || trimmed . char at ( i ) == str || trimmed . char at ( i ) == str || trimmed . char at ( i ) == str || trimmed . char at ( i ) == str || trimmed . char at ( i ) == str || trimmed . char at ( i ) == str || trimmed . char at ( i ) == str ) { if ( forward ) i ++ ; else i -- ; } return i ; }	computes the index of the next character in the given string that is not a quote , starting from given index and going either forward or backward.
public static void reset ( ) { trace state . remove ( ) ; suspended state . clear ( ) ; }	this method resets the current thread , and suspended trace states , for testing purposes .
private string inclusive slice ( ) { if ( mark >= pos ) { return str ; } return sign . substring ( mark , pos + num ) ; }	inclusive slice ( includes current character ).
public byte [ ] to bytecode ( ) throws io , cannot compile exception { byte array output stream barray = new byte array output stream ( ) ; data output stream out = new data output stream ( barray ) ; try { to bytecode ( out ) ; } finally { out . close ( ) ; } return barray . to byte array ( ) ; }	converts this class to a class file.
public static void serialize path ( final object output os , final path iterator pi ) throws io { os . write object ( pi . get winding rule ( ) ) ; final list < java . io . serializable > list = new array list < java . io . serializable > ( ) ; while ( ! pi . is done ( ) ) { final float [ ] array = new float [ num ] ; final int type = pi . current segment ( array ) ; list . add ( type ) ; list . add ( array ) ; pi . next ( ) ; } os . write object ( list ) ; }	method to serialize a path . this method will iterate through the iterator passed in , and write out the base components of the path to the objectoutput.
public double calculate local swap total capacity ( int hostcount , int hostlocalswapsize ) { double d = ( double ) ( hostcount * hostlocalswapsize ) / num ; d *= - num ; d = ( double ) math . round ( d * num ) / num ; return d ; }	calculate total amount of virtual machine vswap saved in shared storage when local vswap option is enabled.
public void parse loggc file ( input stream loggc file stream , default mutable tree node root ) { buffered reader bis = new buffered reader ( new input stream reader ( loggc file stream ) ) ; vector histograms = new vector ( ) ; try { while ( bis . ready ( ) ) { bis . mark ( get mark size ( ) ) ; string next line = bis . read line ( ) ; if ( next line . starts with ( str ) ) { bis . reset ( ) ; histograms . add ( parse next class histogram ( bis ) ) ; } } for ( int i = histograms . size ( ) - num ; i >= num ; i -- ) { default mutable tree node dump = get next dump for histogram ( root ) ; if ( dump != null ) { add histogram to dump ( dump , ( histogram table model ) histograms . get ( i ) ) ; } } } catch ( io ex ) { ex . print stack trace ( ) ; } }	parses a loggc file stream and reads any found class histograms and adds the to the dump store.
private void resolve time macro ( string buffer result ) { calendar calendar = new gregorian calendar ( ) ; result . append ( calendar . get ( calendar . year ) + str ) ; string month = calendar . get ( calendar . month ) + num + str ; if ( month . length ( ) < num ) { month = str + month ; } result . append ( month + str ) ; string day = calendar . get ( calendar . day of month ) + str ; if ( day . length ( ) < num ) { day = str + day ; } result . append ( day + str ) ; int am pm = calendar . get ( calendar . am pm ) ; string am pm string = am pm == calendar . am ? str : str ; result . append ( am pm string + str ) ; string hour = calendar . get ( calendar . hour ) + str ; if ( hour . length ( ) < num ) { hour = str + hour ; } result . append ( hour + str ) ; string minute = calendar . get ( calendar . minute ) + str ; if ( minute . length ( ) < num ) { minute = str + minute ; } result . append ( minute + str ) ; string second = calendar . get ( calendar . second ) + str ; if ( second . length ( ) < num ) { second = str + second ; } result . append ( second ) ; }	resolves the macro t by writing the current date and time in the result buffer .
public boolean is empty ( ) { synchronized ( lock ) { return annotations draw order . is empty ( ) ; } }	returns whether this container contains any actual annotations .
default b append8bit ( @ not null char sequence cs , int start , int end ) throws illegal argument exception , buffer overflow exception , buffer underflow exception , index out of bounds exception { if ( cs instanceof bytes store ) { return write ( ( bytes store ) cs , ( long ) start , end ) ; } for ( int i = start ; i < end ; i ++ ) { char c = cs . char at ( i ) ; if ( c > num ) c = str ; write byte ( ( byte ) c ) ; } return ( b ) this ; }	append a portion of a string to the bytes in iso - 8859 - 1.
static void zero ( float [ ] [ ] array ) { for ( float [ ] a float : array ) { arrays . fill ( a float , - num ) ; } }	fill a 2d array of floats with 0 . 0.
@ override public boolean contains ( d . double p ) { d . double r = ( d . double ) roundrect . clone ( ) ; double grow = attribute keys . get perpendicular hit growth ( this ) ; r . x -= grow ; r . y -= grow ; r . width += grow * num ; r . height += grow * num ; r . arcwidth += grow * num ; r . archeight += grow * num ; return r . contains ( p ) ; }	checks if a point2d.
private void download update prop ( final boolean initial download ) { if ( boot prop != null ) { server folder = boot prop . get property ( str , client game configuration . get ( str ) ) + str ; string update properties file = boot prop . get property ( str , server folder + str ) ; final http client http client = new http client ( update properties file , initial download ) ; update prop = http client . fetch properties ( ) ; if ( update prop != null && update prop . contains key ( str ) ) { return ; } } string update properties file = client game configuration . get ( str ) + str ; http client http client = new http client ( update properties file , initial download ) ; update prop = http client . fetch properties ( ) ; if ( update prop != null && update prop . contains key ( str ) ) { return ; } update properties file = client game configuration . get ( str ) + str ; http client = new http client ( update properties file , initial download ) ; update prop = http client . fetch properties ( ) ; }	connects to the server and loads a property object which contains information about the files available for update .
private void merge method handle store ( final int index , final method handle method handle ) { local variables . merge ( index , new method handle ( method handle ) , null ) ; }	merges a stored method handle to the local variables .
public final int read ( byte ba [ ] , int off , int len ) throws io { return is . read ( ba , off , len ) ; }	read bytes . watch out , read may return fewer bytes than requested .
public context suggest field ( string name , string value , int weight , char sequence ... contexts ) { super ( name , value , weight ) ; validate ( value ) ; this . contexts = new hash set < > ( ( contexts != null ) ? contexts . length : num ) ; if ( contexts != null ) { collections . add all ( this . contexts , contexts ) ; } }	creates a context - enabled suggest field.
public activity put ( string key , activity activity ) { return ( activity ) m map . put ( key , activity ) ; }	associates the given key with the given activity.
public boolean is abstract ( ) { return modifier . is abstract ( get access flags ( ) ) ; }	returns true for an abstract class .
public void clear current request timed out ( ) { if ( current request timed out != null ) current request timed out . clear ( ) ; current request timed out = null ; }	discard timed out requests in this replica.
protected void show page ( int page ) { boolean is empty = page == page empty ; control control = is empty ? ( control ) f empty page label : get control ( ) ; if ( is empty ) { set content description ( str ) ; clear viewer ( ) ; } f pagebook . show page ( control ) ; }	shows the given page in the page book .
@ override public boolean equals ( object o ) { if ( this == o ) return bool ; if ( o == null || get class ( ) != o . get class ( ) ) return bool ; insets insets = ( insets ) o ; if ( bottom != insets . bottom ) return bool ; if ( left != insets . left ) return bool ; if ( right != insets . right ) return bool ; if ( top != insets . top ) return bool ; return bool ; }	two insets instances are equal iff they belong to the same class and their fields are pairwise equal .
public void remove documents ( list < query > queries ) { index writer writer = get writer ( ) ; for ( query query : queries ) { try { writer . delete documents ( query ) ; } catch ( exception e ) { e . print stack trace ( ) ; close writer ( writer ) ; throw new runtime exception ( e ) ; } } close writer ( writer ) ; }	removes the indexes of the documents .
protected string to string ( object parameter ) { if ( parameter == null ) { return null str ; } try { string result = misc . get as string ( parameter ) ; if ( result . length ( ) > default arg string max length ) { result = result . substring ( num , default arg string max length ) + default max string ending ; } return result ; } catch ( throwable e ) { return unknown ; } }	turns a single method parameter into a string.
public static secret key generate secret key ( secret key type secret key type , int key size ) throws crypto exception { try { key generator key generator = key generator . get instance ( secret key type . jce ( ) , bouncy castle . jce ( ) ) ; key generator . init ( key size , secure random . get instance ( str ) ) ; return key generator . generate key ( ) ; } catch ( general security exception ex ) { throw new crypto exception ( message format . format ( res . get string ( str ) , secret key type ) , ex ) ; } }	generate a secret key .
public cml delete cml ( i vo document ) { string id = document . get id ( ) ; reference reference = new reference ( store , id , null ) ; predicate predicate = new predicate ( new reference [ ] { reference } , null , null ) ; cml delete = new cml ( predicate ) ; cml cml = new cml ( ) ; cml . set delete ( new cml [ ] { delete } ) ; return cml ; }	metodo que borra un documento.
private synchronized void eval ( ) throws metadata evaluation exception { if ( cache strategy == cache strategy . never cache || internal value . get ( ) == null ) { try { object value = lazy value . call ( ) ; if ( value == null ) { value = actually null ; } internal value = new soft reference < object > ( value ) ; } catch ( exception e ) { throw new metadata evaluation exception ( e ) ; } } }	lazily evaluates the value of this metadata item .
public void add edge to bounds ( s2 point from , s2 point to ) { if ( ! bound set ) { bound set = bool ; xmin = xmax = from . x ; ymin = ymax = from . y ; zmin = zmax = from . z ; } xmin = math . min ( xmin , math . min ( to . x , from . x ) ) ; ymin = math . min ( ymin , math . min ( to . y , from . y ) ) ; zmin = math . min ( zmin , math . min ( to . z , from . z ) ) ; xmax = math . max ( xmax , math . max ( to . x , from . x ) ) ; ymax = math . max ( ymax , math . max ( to . y , from . y ) ) ; zmax = math . max ( zmax , math . max ( to . z , from . z ) ) ; double approx arc len = math . abs ( from . x - to . x ) + math . abs ( from . y - to . y ) + math . abs ( from . z - to . z ) ; if ( approx arc len < num ) { max deformation = math . max ( max deformation , approx arc len * num ) ; } else if ( approx arc len < num ) { max deformation = math . max ( max deformation , approx arc len * num ) ; } else { max deformation = approx arc len * num ; } }	accumulate a bounding rectangle from provided edges .
public static string hash ( string string ) { try { message digest sha1 = message digest . get instance ( str ) ; sha1 . update ( string . get bytes ( str ) ) ; return base64 . encode ( sha1 . digest ( ) ) ; } catch ( exception ex ) { debug debug = debug . get instance ( str ) ; if ( debug . warning enabled ( ) ) { debug . warning ( str , ex ) ; } return null ; } }	generates a sha1 digest of the string and returns base64 encoded digest .
static list < string > read extensions ( final substring reader reader ) throws decode exception { int length = num ; list < string > values ; reader . skip whitespaces ( ) ; reader . mark ( ) ; try { char c = reader . read ( ) ; if ( c == str ) { reader . mark ( ) ; while ( reader . read ( ) != str ) { length ++ ; } reader . reset ( ) ; values = collections . singleton list ( reader . read ( length ) ) ; reader . read ( ) ; } else if ( c == str ) { reader . skip whitespaces ( ) ; reader . mark ( ) ; c = reader . read ( ) ; if ( c == str ) { values = collections . empty list ( ) ; } else { values = new array list < > ( ) ; do { reader . reset ( ) ; values . add ( read quoted string ( reader ) ) ; reader . skip whitespaces ( ) ; reader . mark ( ) ; } while ( reader . read ( ) != str ) ; values = collections . unmodifiable list ( values ) ; } } else { do { length ++ ; } while ( reader . read ( ) != str ) ; reader . reset ( ) ; values = collections . singleton list ( reader . read ( length ) ) ; } return values ; } catch ( final string index out of bounds exception e ) { throw decode exception . error ( err attr syntax truncated valu . get ( ) ) ; } }	reads the value for an " extra " parameter.
private void n ( byte [ ] nv21bytes , byte [ ] i420bytes , int width , int height ) { system . arraycopy ( nv21bytes , num , i420bytes , num , width * height ) ; for ( int i = width * height ; i < nv21bytes . length ; i += num ) { i420bytes [ i ] = nv21bytes [ i + num ] ; i420bytes [ i + num ] = nv21bytes [ i ] ; } }	nv21 is a 4 : 2 : 0 ycbcr , for 1 nv21 pixel : yyyyyyyy vuvu i420yuvsemiplanar is a 4 : 2 : 0 yuv , for a single i420 pixel : yyyyyyyy uvuv apply nv21 to i420yuvsemiplanar ( nv12 ) refer to https : / / wiki.
public int read ( byte buffer dst ) throws io { if ( ! dst . has remaining ( ) ) return num ; if ( ! is hand shake complete ( ) ) { if ( is blocking ( ) ) { while ( ! is hand shake complete ( ) ) { process handshake ( ) ; } } else { process handshake ( ) ; if ( ! is hand shake complete ( ) ) { return num ; } } } int purged = read remaining ( dst ) ; if ( purged != num ) return purged ; assert ( in data . position ( ) == num ) ; in data . clear ( ) ; if ( ! in crypt . has remaining ( ) ) in crypt . clear ( ) ; else in crypt . compact ( ) ; if ( is blocking ( ) || read engine result . get status ( ) == status . buffer underflow ) if ( socket channel . read ( in crypt ) == - num ) { return - num ; } in crypt . flip ( ) ; unwrap ( ) ; int transfered = transfere to ( in data , dst ) ; if ( transfered == num && is blocking ( ) ) { return read ( dst ) ; } return transfered ; }	blocks when in blocking mode until at least one byte has been decoded.
private list < facet result > search ( ) throws io { directory reader index reader = directory reader . open ( index dir ) ; index searcher searcher = new index searcher ( index reader ) ; sorted set doc values reader state state = new default sorted set doc values reader state ( index reader ) ; facets collector fc = new facets collector ( ) ; facets collector . search ( searcher , new match all docs query ( ) , num , fc ) ; facets facets = new sorted set doc values facet counts ( state , fc ) ; list < facet result > results = new array list < > ( ) ; results . add ( facets . get top children ( num , str ) ) ; results . add ( facets . get top children ( num , str ) ) ; index reader . close ( ) ; return results ; }	user runs a query and counts facets .
public resource map relations ( resource object , json json object , list < resource > included ) throws exception { hash map < string , string > relationship names = get relationship names ( object . get class ( ) ) ; for ( string relationship : relationship names . key set ( ) ) { json relation json object = null ; try { relation json object = json object . get json ( relationship ) ; } catch ( json e ) { logger . debug ( str + relationship + str ) ; continue ; } json relation data object = null ; try { relation data object = relation json object . get json ( str ) ; resource relation object = factory . new object from json ( relation data object , null ) ; relation object = match included to relation ( relation object , included ) ; m deserializer . set field ( object , relationship names . get ( relationship ) , relation object ) ; } catch ( json e ) { logger . debug ( str ) ; } json relation data array = null ; try { relation data array = relation json object . get json ( str ) ; list < resource > relation array = factory . new object from json ( relation data array , null ) ; relation array = match included to relation ( relation array , included ) ; m deserializer . set field ( object , relationship names . get ( relationship ) , relation array ) ; } catch ( json e ) { logger . debug ( str ) ; } } return object ; }	loops through relation json array and maps annotated objects .
public int size ( ) { return rdns . size ( ) ; }	retrieves the number of components in this ldap name .
@ override public void do initialize ( uima context a context ) throws resource initialization exception { db db = mongo resource . get db ( ) ; collection = db . get collection ( collection name ) ; collection . create index ( new db ( field unique id , num ) ) ; collection . create index ( new db ( field publishedids , num ) ) ; stop features = new hash set < string > ( ) ; stop features . add ( str ) ; stop features . add ( str ) ; max content length = config utils . string to integer ( max content length string , num ) ; }	get the mongodb , collection and create some indexes.
protected void draw high far out ( double a radius , d g2 , double xx , double m ) { double side = a radius * num ; g2 . draw ( new d . double ( xx - side , m + side , xx + side , m + side ) ) ; g2 . draw ( new d . double ( xx - side , m + side , xx , m ) ) ; g2 . draw ( new d . double ( xx + side , m + side , xx , m ) ) ; }	draws a triangle to indicate the presence of far out values .
private void find large item sets ( ) throws exception { array list < object > k minus one sets , k sets ; hashtable < item set , integer > hashtable ; int nec support , i = num ; nec support = ( int ) ( m min support * m instances . num instances ( ) + num ) ; k sets = apriori item set . singletons ( m instances , m treat zero as missing ) ; if ( m treat zero as missing ) { apriori item set . up date counters treat zero as missing ( k sets , m instances ) ; } else { apriori item set . up date counters ( k sets , m instances ) ; } k sets = apriori item set . delete item sets ( k sets , nec support , m instances . num instances ( ) ) ; if ( k sets . size ( ) == num ) { return ; } do { m . add ( k sets ) ; k minus one sets = k sets ; k sets = apriori item set . merge all item sets ( k minus one sets , i , m instances . num instances ( ) ) ; hashtable = apriori item set . get hashtable ( k minus one sets , k minus one sets . size ( ) ) ; m hashtables . add ( hashtable ) ; k sets = apriori item set . prune item sets ( k sets , hashtable ) ; if ( m treat zero as missing ) { apriori item set . up date counters treat zero as missing ( k sets , m instances ) ; } else { apriori item set . up date counters ( k sets , m instances ) ; } k sets = apriori item set . delete item sets ( k sets , nec support , m instances . num instances ( ) ) ; i ++ ; } while ( k sets . size ( ) > num ) ; }	method that finds all large itemsets for the given set of instances .
public boolean is in allowed ( int x , int y ) { for ( shape r : arriving barriers ) { if ( r . contains ( x , y ) ) { return bool ; } } return bool ; }	check if teleporting to a location is allowed .
public void remove plugin interface ( string interfacename ) throws sms , sso { sms . validate token ( token ) ; validate service schema manager impl ( ) ; document schema doc = ssm . get document copy ( ) ; node schema node = xml . get root node ( schema doc , sms . schema ) ; node plugin node = xml . get named child node ( schema node , sms . plugin interface , sms . name , interfacename ) ; if ( plugin node != null ) { schema node . remove child ( plugin node ) ; replace schema ( schema doc ) ; } }	removes the plugin interface object from the service schema .
private boolean is same file ( path first , path second ) throws io { boolean same file size = files . size ( first ) == files . size ( second ) ; if ( ! same file size ) { return bool ; } byte [ ] first bytes = files . read all bytes ( first ) ; byte [ ] second bytes = files . read all bytes ( second ) ; return arrays . equals ( first bytes , second bytes ) ; }	compares the content of two paths by comparing them.
public static org . opcfoundation . ua . transport . security . key pair load key pair from protected store ( string store location , string alias , string store pw , string private pw ) throws key store exception , io , no such algorithm exception , certificate exception , unrecoverable key exception { key store store = null ; store = key store . get instance ( str ) ; file keystore file = new file ( store location ) ; file input stream in = new file input stream ( keystore file ) ; store . load ( in , store pw . to char array ( ) ) ; in . close ( ) ; x509 certificate cert = ( x509 certificate ) store . get certificate ( alias ) ; rsa key = ( rsa ) store . get key ( alias , private pw . to char array ( ) ) ; return new org . opcfoundation . ua . transport . security . key pair ( new cert ( cert ) , new priv key ( key ) ) ; }	load a keypair from a java key store .
@ override public graph query has not ( final string key , final object value ) { criteria . add ( new has not ( key , value ) ) ; return this ; }	filter out elements that have a property value equal to provided value.
private void init compute program ( ) { int buffer work group size = buffer utils . create int buffer ( num ) ; gl get programiv ( compute program , gl compute work group size , work group size ) ; work group size x = work group size . get ( num ) ; work group size y = work group size . get ( num ) ; int boxes resource index = gl get program resource index ( compute program , gl shader storage block , str ) ; int buffer props = buffer utils . create int buffer ( num ) ; int buffer params = buffer utils . create int buffer ( num ) ; props . put ( num , gl buffer binding ) ; gl get program resourceiv ( compute program , gl shader storage block , boxes resource index , props , null , params ) ; boxes ssbo binding = params . get ( num ) ; int uniforms resource index = gl get program resource index ( compute program , gl uniform block , str ) ; gl get program resourceiv ( compute program , gl uniform block , uniforms resource index , props , null , params ) ; compute ubo binding = params . get ( num ) ; int loc = gl get uniform location ( compute program , str ) ; gl get uniformiv ( compute program , loc , params ) ; framebuffer image binding = params . get ( num ) ; loc = gl get uniform location ( compute program , str ) ; gl get uniformiv ( compute program , loc , params ) ; world position image binding = params . get ( num ) ; loc = gl get uniform location ( compute program , str ) ; gl get uniformiv ( compute program , loc , params ) ; world normal image binding = params . get ( num ) ; }	initialize the compute shader .
ts ( byte [ ] ts reply ) throws io { parse ( ts reply ) ; }	constructs an object to store the response to a timestamp request .
public static void execute command ( process builder p ) throws io { process proc = p . start ( ) ; try ( buffered reader std input = new buffered reader ( new input stream reader ( proc . get input stream ( ) ) ) ; buffered reader std error = new buffered reader ( new input stream reader ( proc . get error stream ( ) ) ) ) { logger . info ( str ) ; string s ; while ( ( s = std input . read line ( ) ) != null ) { logger . info ( s ) ; } logger . info ( str ) ; while ( ( s = std error . read line ( ) ) != null ) { logger . info ( s ) ; } } }	method to execute process.
public boolean page setup dialog ( printer job job ) { print request attribute set prats = get print request attribute set ( ) ; page format pf = job . page dialog ( prats ) ; set print request attribute set ( prats ) ; return bool ; }	show dialog and set paper.
public static void assert not equals ( buffered image image1 , buffered image image2 ) { assert not equals ( str , image1 , image2 ) ; }	fails if the contents of two images are equal .
public depend ( path impl source , long digest , boolean require source ) { this ( source ) ; long new digest = source . get crc64 ( ) ; require source = require source ; if ( new digest == digest ) { } else if ( ! require source && new digest == num ) { } else if ( new digest == num ) { if ( log . is loggable ( level . fine ) ) log . fine ( source . get native path ( ) + str ) ; is digest modified = bool ; } else { is digest modified = bool ; } }	create a new dependency with a given digest .
public static boolean string to file ( final string data , final file target file , final boolean do append ) { if ( target file == null || ! is writable ( target file , bool ) ) { log . e ( file utils . class , str ) ; return bool ; } boolean is succeed = bool ; try { final file writer out = new file writer ( target file , do append ) ; out . write ( data ) ; out . flush ( ) ; out . close ( ) ; } catch ( io e ) { is succeed = bool ; } return is succeed ; }	writes a string to a file .
@ override public void cascade register new if required ( object object , unit of work impl uow , map visited objects ) { cascade register new if required ( object , uow , visited objects , bool ) ; }	internal : cascade registernew for create through mappings that require the cascade.
public static boolean parse bool ( string s ) { if ( s != null ) { if ( s . starts with ( str ) || s . starts with ( str ) || s . starts with ( str ) ) { return bool ; } if ( s . starts with ( str ) || s . starts with ( str ) || s . equals ( str ) ) { return bool ; } } throw new solr exception ( solr exception . error code . bad request , str + s ) ; }	how to transform a string into a boolean.
private static void read dna ( string filename ) { try { line number reader in = new line number reader ( new file reader ( filename ) ) ; process one line ( in , str , compilation rates ) ; process one line ( in , str , speedup rates ) ; } catch ( exception e ) { e . print stack trace ( ) ; vm . sys fail ( str ) ; } }	read a serialized representation of the dna info.
public void test eeee ( ) { enum set < enum with inner class > enum set = enum set . of ( enum with inner class . a , enum with inner class . b , enum with inner class . c , enum with inner class . d ) ; assert equals ( str , num , enum set . size ( ) ) ; assert true ( str , enum set . contains ( enum with inner class . a ) ) ; assert true ( str , enum set . contains ( enum with inner class . d ) ) ; try { enum set . of ( ( enum with inner class ) null , null , null , null ) ; fail ( str ) ; } catch ( null pointer exception npe ) { } enum set < huge enum with inner class > huge enum set = enum set . of ( huge enum with inner class . a , huge enum with inner class . b , huge enum with inner class . c , huge enum with inner class . d ) ; assert equals ( num , huge enum set . size ( ) ) ; assert true ( huge enum set . contains ( huge enum with inner class . a ) ) ; assert true ( huge enum set . contains ( huge enum with inner class . d ) ) ; try { enum set . of ( ( huge enum with inner class ) null , null , null , null ) ; fail ( str ) ; } catch ( null pointer exception npe ) { } }	java . util . enumset # of ( e , e , e , e ).
builder ( url swagger url ) { try { this . swagger location = swagger url . to uri ( ) ; } catch ( uri e ) { throw new illegal argument exception ( str , e ) ; } this . swagger = read swagger ( swagger url . to string ( ) ) ; }	creates a builder from a remote url .
@ override public void on save instance state ( @ non null bundle saved instance state ) { saved instance state . put parcelable ( location key , current location ) ; if ( last location update time != null ) { saved instance state . put long ( last location update time string key , last location update time . get time ( ) ) ; } if ( last wifi scan time != null ) { saved instance state . put long ( last wifi scan time string key , last wifi scan time . get time ( ) ) ; } saved instance state . put boolean ( logging enabled key , logging enabled ) ; super . on save instance state ( saved instance state ) ; }	stores activity data in the bundle .
public static string remove empty lines ( string text ) { text = text . replace all ( str + chinese language constants . space [ num ] + str , str ) ; text = text . replace all ( str + chinese language constants . space [ num ] + str , str ) ; return text ; }	remove empty lines . an empty line means a line ends in \ n or \ r \ n and contains only white space characters , or no characters at all .
public void keep only ( set < i > useful pointers ) { set < i > reps = new hash set < i > ( ) ; for ( i pn : useful pointers ) { reps . add ( pn . get representative ( ) ) ; } useful pointers . add all ( reps ) ; reps = null ; for ( i pn : pointers ) { if ( ! useful pointers . contains ( pn ) ) pn . delete all ( ) ; } system . gc ( ) ; }	keep only the pointers the users are interested in.
public static string encrypt cfb ( final byte [ ] concatenated hash value , final long turnover counter , final secret key symmetric key , int turn over counter length in bytes ) throws no such algorithm exception , no such provider exception , no such padding exception , invalid key exception , invalid algorithm parameter exception , illegal block size exception , bad padding exception { final byte buffer byte buffer iv = byte buffer . allocate ( num ) ; byte buffer iv . put ( concatenated hash value ) ; final byte [ ] iv = byte buffer iv . array ( ) ; final byte buffer byte buffer data = byte buffer . allocate ( num ) ; byte buffer data . put long ( turnover counter ) ; final byte [ ] data = byte buffer data . array ( ) ; byte [ ] turn over counter byte rep = get2 complement rep for long ( turnover counter , turn over counter length in bytes ) ; system . arraycopy ( turn over counter byte rep , num , data , num , turn over counter byte rep . length ) ; final iv parameter spec iv spec = new iv parameter spec ( iv ) ; final cipher cipher = cipher . get instance ( str , str ) ; cipher . init ( cipher . encrypt mode , symmetric key , iv spec ) ; final byte [ ] encrypted turn over value complete = cipher . do final ( data ) ; final byte [ ] encrypted turn over value = new byte [ turn over counter length in bytes ] ; system . arraycopy ( encrypted turn over value complete , num , encrypted turn over value , num , turn over counter length in bytes ) ; final string base64 encrypted turn over value = cash box utils . base64 encode ( encrypted turn over value , bool ) ; return base64 encrypted turn over value ; }	method for aes encryption in cfb mode ( for the first block cfb and ctr are exactly the same.
string public name from disk name ( string disk name ) { if ( ! should disk name be visible ( disk name ) ) { throw new illegal argument exception ( str + disk name ) ; } return disk name . substring ( m file prefix . length ( ) , disk name . length ( ) ) ; }	returns the public name ( everything following the prefix ) of the given diskname .
public double [ ] predict ( f feat ) { return predict ( feat , bool ) ; }	generates predictions for given feature vector .
public static < a > a [ ] append ( final a [ ] a , final a [ ] b ) { final int alen = a . length ; final int blen = b . length ; final a [ ] res = arrays . copy of ( a , alen + blen ) ; system . arraycopy ( b , num , res , alen , blen ) ; return res ; }	append two arrays creating a new array for the result .
public boolean add listener ( @ not null soft wrap aware document parsing listener listener ) { return my listeners . add ( listener ) ; }	registers given listener within the current manager .
private void assert array equals ( double [ ] expected , double [ ] actual , double delta , boolean check na n ) { assert . assert equals ( expected . length , actual . length ) ; for ( int index = num ; index < actual . length ; index ++ ) { double d1 = expected [ index ] ; double d2 = actual [ index ] ; if ( double . is na n ( d1 ) || double . is na n ( d2 ) ) { if ( check na n ) { assert . assert true ( double . is na n ( d1 ) == double . is na n ( d2 ) ) ; } assert . assert true ( bool ) ; } else { assert . assert equals ( d1 , d2 , delta ) ; } } }	this is an assertion for a special case when a loss full algorithm is used and a quantification with null checks.
protected void add to population ( solution new solution ) { list < integer > dominates = new array list < integer > ( ) ; boolean dominated = bool ; for ( int i = num ; i < population . size ( ) ; i ++ ) { int flag = dominance comparator . compare ( new solution , population . get ( i ) ) ; if ( flag < num ) { dominates . add ( i ) ; } else if ( flag > num ) { dominated = bool ; } } if ( ! dominates . is empty ( ) ) { population . remove ( dominates . get ( prng . next int ( dominates . size ( ) ) ) ) ; population . add ( new solution ) ; } else if ( ! dominated ) { population . remove ( prng . next int ( population . size ( ) ) ) ; population . add ( new solution ) ; } }	adds the new solution to the population if is non - dominated with the current population , removing either a randomly - selected dominated solution or a non - dominated solution .
private string generate blend mode import ( blend mode blend mode ) { if ( blend mode == blend mode . color ) return str ; else if ( blend mode == blend mode . colorburn ) return str ; else if ( blend mode == blend mode . colordodge ) return str ; else if ( blend mode == blend mode . exclusion ) return str ; else if ( blend mode == blend mode . hue ) return str ; else if ( blend mode == blend mode . luminosity ) return str ; else if ( blend mode == blend mode . saturation ) return str ; else if ( blend mode == blend mode . softlight ) return str ; else return null ; }	generates a snippet of actionscript source code that imports the correct class for the corresponding blend mode .
public static string parse int to metric suffix ( int x ) { string xint = string . value of ( x ) ; if ( xint . ends with ( str ) ) { xint = xint . replace all ( str , str ) ; } else if ( xint . ends with ( str ) ) { xint = xint . replace all ( str , str ) ; } return xint ; }	convert 000 and 000 , 000 to k and m suffix.
public sm auth status query ( string parameter , string secret , sm auth query code request , sm auth query response response ) { if ( null == response ) { return sm auth status . smauth failure ; } if ( sm auth query code . smauth query description == request ) { response . set response buffer ( scheme description ) ; response . set response code ( scheme version ) ; } else if ( sm auth query code . smauth query credentials req == request ) { response . set response code ( sm auth query response . smauth cred basic ) ; } else { return sm auth status . smauth failure ; } return sm auth status . smauth success ; }	returns information about the authentication scheme .
protected void add all transitive jars ( war archive merger wam ) throws mojo execution exception { dependency calculator dc = new dependency calculator ( artifact factory , resolver , local repository , remote repositories , maven project , maven project builder , installer , container ) ; try { for ( file f : dc . execute ( ) ) { wam . add merge item ( f ) ; } } catch ( exception ex ) { throw new mojo execution exception ( str , ex ) ; } }	add all jar files into the war file , calculated transitively and resolved in the normal ' maven ' way ( i.
private void add ( int col , graphical node graphical node ) { my graphical nodes . remove ( graphical node ) ; if ( nb cols - num < col ) { nb cols = col + num ; } int row = num ; while ( is occupied ( row , col ) ) { row ++ ; } graphical node . row = row ; graphical node . col = col ; my graphical nodes . add ( graphical node ) ; }	ajoute la graphical node dans la map position / liste des successeurs.
private int add tonal components ( float [ ] spectrum , int num components , tonal component [ ] components ) { int last pos = - num ; for ( int i = num ; i < num components ; i ++ ) { last pos = math . max ( components [ i ] . pos + components [ i ] . num coefs , last pos ) ; for ( int j = num ; j < components [ i ] . num coefs ; j ++ ) { spectrum [ components [ i ] . pos + j ] += components [ i ] . coef [ j ] ; } } return last pos ; }	combine the tonal band spectrum and regular band spectrum.
public static list < user layer > extract user layers ( styled layer descriptor sld ) { list < user layer > user layer list = new array list < user layer > ( ) ; if ( sld != null ) { for ( styled layer layer : sld . layers ( ) ) { if ( layer instanceof user layer ) { user layer user layer = ( user layer ) layer ; user layer list . add ( user layer ) ; } } } return user layer list ; }	extract user layers from an sld .
public static void close quiet ( @ nullable selector rsrc ) { if ( rsrc != null ) try { if ( rsrc . is open ( ) ) rsrc . close ( ) ; } catch ( io ignored ) { } }	quietly closes given resource ignoring possible checked exception .
public static boolean create compaction required file ( string meta folder path , compaction type compaction type ) { string status file ; if ( compaction type . equals ( compaction type . minor compaction ) ) { status file = meta folder path + carbon common constants . file separator + carbon common constants . minor compaction required file ; } else { status file = meta folder path + carbon common constants . file separator + carbon common constants . major compaction required file ; } try { if ( ! file factory . is file exist ( status file , file factory . get file type ( status file ) ) ) { if ( file factory . create new file ( status file , file factory . get file type ( status file ) ) ) { logger . info ( str + status file ) ; return bool ; } else { logger . error ( str + status file ) ; return bool ; } } else { logger . info ( str + status file + str ) ; } } catch ( io e ) { logger . error ( str + e . get message ( ) ) ; } return bool ; }	creation of the compaction request if someother compaction is in progress .
private boolean allow notification emission ( object name name , targeted notification tn ) { try { if ( check notification emission ) { check m ( name , str ) ; } if ( notification access controller != null ) { notification access controller . fetch notification ( connection id , name , tn . get notification ( ) , get subject ( ) ) ; } return bool ; } catch ( security exception e ) { if ( logger . debug on ( ) ) { logger . debug ( str , str + tn . get notification ( ) + str + str ) ; } return bool ; } catch ( exception e ) { if ( logger . debug on ( ) ) { logger . debug ( str , str + tn . get notification ( ) + str + str + e ) ; } return bool ; } }	check if the caller has the right to get the following notifications .
public void update throughput ( long current time ) { throughput calculation lock . lock ( ) ; try { int interval = ( int ) ( current time - last throughput calculation time ) ; long min interval = get throughput calculation interval in millis ( ) ; if ( ( min interval == num ) || ( interval < min interval ) ) { return ; } long read bytes = this . read bytes ; long written bytes = this . written bytes ; long read messages = this . read messages ; long written messages = this . written messages ; read bytes throughput = ( read bytes - last read bytes ) * num / interval ; written bytes throughput = ( written bytes - last written bytes ) * num / interval ; read messages throughput = ( read messages - last read messages ) * num / interval ; written messages throughput = ( written messages - last written messages ) * num / interval ; if ( read bytes throughput > largest read bytes throughput ) { largest read bytes throughput = read bytes throughput ; } if ( written bytes throughput > largest written bytes throughput ) { largest written bytes throughput = written bytes throughput ; } if ( read messages throughput > largest read messages throughput ) { largest read messages throughput = read messages throughput ; } if ( written messages throughput > largest written messages throughput ) { largest written messages throughput = written messages throughput ; } last read bytes = read bytes ; last written bytes = written bytes ; last read messages = read messages ; last written messages = written messages ; last throughput calculation time = current time ; } finally { throughput calculation lock . unlock ( ) ; } }	updates the throughput counters .
public list < ok > verify ( x509 certificate sign cert , x509 certificate issuer cert , date sign date ) throws general security exception , io { root store verifier root store verifier = new root store verifier ( verifier ) ; root store verifier . set root store ( root store ) ; crl crl verifier = new crl ( root store verifier , get cr dss ( ) ) ; crl verifier . set root store ( root store ) ; crl verifier . set online checking allowed ( latest revision || online checking allowed ) ; ocsp ocsp verifier = new ocsp ( crl verifier , get ocsp dss ( ) ) ; ocsp verifier . set root store ( root store ) ; ocsp verifier . set online checking allowed ( latest revision || online checking allowed ) ; return ocsp verifier . verify ( sign cert , issuer cert , sign date ) ; }	verifies certificates against a list of crls and ocsp responses .
protected boolean [ ] test wrt r ( classifier classifier , evaluation evaluation , instances train , instances test ) throws exception { boolean [ ] result = new boolean [ num ] ; evaluation . evaluate model ( classifier , test ) ; try { classifier zero r = new weka . classifiers . rules . r ( ) ; zero r . build classifier ( train ) ; evaluation zero r = new evaluation ( train ) ; zero r . evaluate model ( zero r , test ) ; result [ num ] = utils . gr or eq ( zero r . error rate ( ) , evaluation . error rate ( ) ) ; } catch ( exception ex ) { throw new error ( str + ex . get message ( ) ) ; } return result ; }	determine whether the scheme performs worse than zeror during testing.
public void println ( ) { if ( add newlines ) { try { out . write ( str ) ; } catch ( io ioe ) { throw new groovy runtime exception ( ioe ) ; } } }	prints an end - of - line character ( if enabled via addnewlines property ).
public void delivery complete ( final i token ) { logger . trace ( str , token . get message id ( ) ) ; }	handles completion of message delivery .
public d ( j parent , string entry alias ) { super ( parent , dialog . modality type . document modal ) ; this . entry alias = entry alias ; init components ( ) ; }	creates a new dexportpublickey dialog .
public static string escape unicode ( string s ) { int len = s . length ( ) ; int i = num ; while ( i < len ) { char ch = s . char at ( i ) ; if ( ch > num ) { string builder buf = new string builder ( ) ; buf . append ( s . substring ( num , i ) ) ; while ( i < len ) { ch = s . char at ( i ) ; if ( ch > num ) { buf . append ( str ) ; buf . append ( character . for digit ( ( ch > > num ) % num , num ) ) ; buf . append ( character . for digit ( ( ch > > num ) % num , num ) ) ; buf . append ( character . for digit ( ( ch > > num ) % num , num ) ) ; buf . append ( character . for digit ( ( ch ) % num , num ) ) ; } else { buf . append ( ch ) ; } i ++ ; } s = buf . to string ( ) ; } else { i ++ ; } } return s ; }	escape all unicode characters in string .
public void key pressed ( final int key code ) { if ( impl . get current form ( ) == null ) { return ; } add single argument event ( key pressed , key code ) ; last interaction was keypad = last interaction was keypad || ( key code != menu bar . left sk && key code != menu bar . clear sk && key code != menu bar . back sk ) ; key repeat charged = ( key code >= num || get game action ( key code ) > num ) || key code == impl . get clear key code ( ) ; long press charged = key repeat charged ; long key press time = system . current time millis ( ) ; key repeat value = key code ; next key repeat event = system . current time millis ( ) + key repeat initial interval time ; previous key pressed = last key pressed ; last key pressed = key code ; }	pushes a key press event with the given keycode into codename one.
public boolean is empty ( ) { return filter . is empty ( ) && query . is empty ( ) && sort . is empty ( ) ; }	returns if this search doesn ' t specify any filter , query or sort .
public static string fix line feeds ( string sql ) { if ( sql . index of ( str ) == - num ) { return sql ; } boolean has fixes = bool ; char [ ] fixed = sql . to char array ( ) ; for ( int i = num ; i < fixed . length ; i ++ ) { if ( fixed [ i ] == str && ( i == fixed . length - num || fixed [ i + num ] != str ) ) { fixed [ i ] = str ; has fixes = bool ; } } return has fixes ? string . value of ( fixed ) : sql ; }	replaces single \ r linefeeds with \ n ( some databases don ' t like them ).
public static string merge path ( string current , string real path ) throws url { string curr dir ; if ( current == null || current . index of ( str ) == - num ) curr dir = str ; else if ( current . ends with ( str ) ) curr dir = current ; else curr dir = current . substring ( num , current . last index of ( str ) + num ) ; string path ; if ( real path . starts with ( str ) ) path = curr dir + real path . substring ( num ) ; else if ( real path . starts with ( str ) ) path = real path ; else if ( ! real path . starts with ( str ) ) path = curr dir + real path ; else { while ( real path . starts with ( str ) || curr dir . length ( ) == num ) { real path = real path . substring ( num ) ; curr dir = curr dir . substring ( num , curr dir . length ( ) - num ) ; int index = curr dir . last index of ( str ) ; if ( index == - num ) throw new url ( str ) ; curr dir = curr dir . substring ( num , index + num ) ; } path = curr dir + real path ; } return path ; }	merge to pathes to one.
public void rollback ( ) throws sql { if ( use connection == null ) { log . info ( str ) ; return ; } try { use connection . rollback ( ) ; } catch ( sql e ) { log . warning ( str + e . get message ( ) ) ; throw e ; } }	if this sql object was created with a connection then this method rolls back the connection.
public byte [ ] to byte array ( ) { if ( header nonce == null || header tag == null ) { throw new aws crypto exception ( str ) ; } final byte [ ] serialized fields = serialize authenticated fields ( ) ; final int out len = serialized fields . length + header nonce . length + header tag . length ; final byte buffer serialized bytes = byte buffer . allocate ( out len ) ; serialized bytes . put ( serialized fields ) ; serialized bytes . put ( header nonce ) ; serialized bytes . put ( header tag ) ; return serialized bytes . array ( ) ; }	serialize the header fields into a byte array.
public boolean contains key ( object key ) { return context . get attribute ( ( string ) key ) != null ; }	returns true if the key name is bound in any scope in the context.
private void update limit ( int limit ) { current cycle . set limit ( limit ) ; update plan cycles ( ) ; confirm update . set text color ( resources . get color ( r . color . light gray ) ) ; }	update the limit of the specific cycle type update the corresponding views.
@ suppress warnings ( str ) public set < s > descendants ( ) { set < s > perms = new hash set < > ( ) ; for ( s child : children ) { perms . add ( child ) ; perms . add all ( child . descendants ( ) ) ; } return perms ; }	gets all child nodes recursively.
private string extract url ( string shared url ) { string final url ; final url = shared url . trim ( ) ; string [ ] possible urls = final url . split ( str ) ; for ( string url : possible urls ) { if ( network manager . is url ( url ) ) { final url = url ; break ; } } final url = final url . substring ( final url . last index of ( str ) + num ) ; final url = final url . substring ( final url . last index of ( str ) + num ) ; if ( network manager . is url ( str + final url ) && ! network manager . is url ( final url ) ) { final url = str + final url ; } if ( final url . contains ( str ) ) { final url = final url . substring ( num , final url . index of ( str ) ) ; } if ( final url . contains ( str ) ) { final url = final url . substring ( num , final url . index of ( str ) ) ; } if ( final url . contains ( str ) ) { final url = final url . substring ( num , final url . index of ( str ) ) ; } return final url ; }	method to extract the url from shared data and delete trackers.
public set entry set ( ) { return map . entry set ( ) ; }	returns a set view of entry in this map .
public static string encode ( string input ) { return base64 . encode base64 string ( input . get bytes ( standard charsets . utf 8 ) ) ; }	encode string to base64 string.
public void add split ( string split label ) { if ( m disabled ) return ; long now = system clock . elapsed realtime ( ) ; m splits . add ( now ) ; m split labels . add ( split label ) ; }	add a split for the current time , labeled with splitlabel.
protected string encode ( final string value ) { try { return url . encode ( value , str ) ; } catch ( exception exp ) { return value ; } }	encode value as url compatible utf - 8 .
private void check connect permission ( ) throws security exception { security manager security = system . get security manager ( ) ; if ( security == null ) return ; if ( security != cache security manager ) { ok context = null ; authcache = new weak hash map < access control context , reference < access control context > > ( ) ; cache security manager = security ; } access control context ctx = access controller . get context ( ) ; if ( ok context == null || ! ( ok context . equals ( ctx ) || authcache . contains key ( ctx ) ) ) { security . check connect ( ep . get host ( ) , ep . get port ( ) ) ; authcache . put ( ctx , new soft reference < access control context > ( ctx ) ) ; } ok context = ctx ; }	checks if the current caller has sufficient privilege to make a connection to the remote endpoint .
private boolean condition l0 ( string value , int index ) { if ( index == value . length ( ) - num && contains ( value , index - num , num , str , str , str ) ) { return bool ; } else if ( ( contains ( value , index - num , num , str , str ) || contains ( value , value . length ( ) - num , num , str , str ) ) && contains ( value , index - num , num , str ) ) { return bool ; } else { return bool ; } }	complex condition 0 for ' l '.
public static pagination context from context ( routing context context ) { http server request request = context . request ( ) ; string page str = request . get param ( pagination context . current page query param ) ; string per page str = request . get param ( pagination context . per page query param ) ; integer page = null ; integer per page = null ; try { if ( page str != null ) { page = integer . parse int ( page str ) ; } if ( per page str != null ) { per page = integer . parse int ( per page str ) ; } } catch ( number format exception e ) { default error handler . bad request ( context , str ) ; } if ( per page != null && per page > pagination context . max per page ) { default error handler . bad request ( context , str + pagination context . per page query param + str + pagination context . max per page ) ; } return new pagination context ( page , per page ) ; }	the preferred way to create a paginationcontext.
private void update data type state ( ) { boolean is sync enabled = m sync switch preference . is checked ( ) ; boolean sync everything = m sync everything . is checked ( ) ; boolean password sync configurable = m profile sync service . is backend initialized ( ) && m profile sync service . is cryptographer ready ( ) ; for ( check box preference pref : m all types ) { boolean can sync type = pref != m sync passwords || password sync configurable ; if ( ! is sync enabled ) { pref . set checked ( bool ) ; } else if ( sync everything ) { pref . set checked ( can sync type ) ; } pref . set enabled ( is sync enabled && ! sync everything && can sync type ) ; } if ( is sync enabled && ! sync everything ) { set < integer > sync types = m profile sync service . get preferred data types ( ) ; m sync autofill . set checked ( sync types . contains ( model type . autofill ) ) ; m sync bookmarks . set checked ( sync types . contains ( model type . bookmarks ) ) ; m sync omnibox . set checked ( sync types . contains ( model type . typed urls ) ) ; m sync passwords . set checked ( password sync configurable && sync types . contains ( model type . passwords ) ) ; m sync recent tabs . set checked ( sync types . contains ( model type . proxy tabs ) ) ; m sync settings . set checked ( sync types . contains ( model type . priority preferences ) ) ; } }	update the data type switch state.
void refresh ui ( string xml , dom m tree ) { if ( ( xml == null ) || xml . equals ( str ) ) { set error message ( str , str ) ; return ; } final document new root = get root ( xml ) ; if ( new root == null ) { set error message ( str , str ) ; return ; } m tree . set document ( new root ) ; }	refreshui is called when we have a new filename to parse .
private void cleanup protection set volumes ( protection set protection set , list < string > volume i , boolean mark protection set for deletion ) { if ( protection set != null ) { log . info ( str , protection set . get label ( ) , volume i . to string ( ) ) ; string set pset volumes = protection set . get volumes ( ) ; pset volumes . remove all ( volume i ) ; protection set . set volumes ( pset volumes ) ; if ( mark protection set for deletion ) { protection set . set inactive ( bool ) ; } db client . update object ( protection set ) ; } }	cleans up the given protectionset by removing volumes from it and marking for deletion if specified.
private static normalization determine normalization ( element model ) { normalization norm method = normalization . none ; string norm name = model . get attribute ( str ) ; if ( norm name . equals ( str ) ) { norm method = normalization . simplemax ; } else if ( norm name . equals ( str ) ) { norm method = normalization . softmax ; } else if ( norm name . equals ( str ) ) { norm method = normalization . logit ; } else if ( norm name . equals ( str ) ) { norm method = normalization . probit ; } else if ( norm name . equals ( str ) ) { norm method = normalization . cloglog ; } else if ( norm name . equals ( str ) ) { norm method = normalization . exp ; } else if ( norm name . equals ( str ) ) { norm method = normalization . loglog ; } else if ( norm name . equals ( str ) ) { norm method = normalization . cauchit ; } return norm method ; }	return the type of normalization used for this regression.
operand pop ( register s ) { stack < operand > stack = get ( s ) ; if ( stack == null ) { throw new optimizing compiler exception ( str ) ; } else { return stack . pop ( ) ; } }	pop the name at the top of the stack for a particular register.
@ override public void start element ( string uri , string local name , string q name , attributes attributes ) throws sax { element value = new string builder ( str ) ; element on = bool ; if ( local name . equals ( item title ) ) { episode = new episode ( ) ; is item = bool ; } if ( local name . equals ignore case ( m 1 ) && is item ) { episode . set length ( attributes . get value ( length ) ) ; episode . set audeo url ( attributes . get value ( m 3 ) ) ; } }	this will be called when the tags of the xml starts .
public static void back and forth ( hg < ? > rs , int window size , int iteration ) { boolean advance = bool ; for ( int i = num ; i < iteration ; i ++ ) { object x = rs . current ( ) ; int steps = random ( window size ) ; steps = forward ( rs , steps ) ; if ( back ( rs , steps ) != steps ) throw new runtime exception ( str + steps + str ) ; if ( ! x . equals ( rs . current ( ) ) ) throw new runtime exception ( str + steps + str + x ) ; if ( advance ) { forward ( rs , random ( window size ) ) ; if ( ! rs . has next ( ) ) { back ( rs , random ( window size ) ) ; advance = bool ; } } else { back ( rs , random ( window size ) ) ; if ( ! rs . has prev ( ) ) { forward ( rs , random ( window size ) ) ; advance = bool ; } } } }	go back and forth on a result set an ' iteration ' number of times.
@ override public void close ( ) throws io { synchronized ( lock ) { if ( decoder != null ) { decoder . reset ( ) ; } decoder = null ; if ( in != null ) { in . close ( ) ; in = null ; } } }	closes this reader . this implementation closes the source inputstream and releases all local storage .
private string buffer to pattern ( string buffer result , boolean escape unprintable ) { if ( pat != null ) { int i ; int backslash count = num ; for ( i = num ; i < pat . length ( ) ; ) { int c = ut . char at ( pat , i ) ; i += ut . get char count ( c ) ; if ( escape unprintable && utility . is unprintable ( c ) ) { if ( ( backslash count % num ) == num ) { result . set length ( result . length ( ) - num ) ; } utility . escape unprintable ( result , c ) ; backslash count = num ; } else { ut . append ( result , c ) ; if ( c == str ) { ++ backslash count ; } else { backslash count = num ; } } } return result ; } return generate pattern ( result , escape unprintable , bool ) ; }	append a string representation of this set to result.
private static version read workspace version ( final url workspace ) { final file version file = get version file ( workspace , bool ) ; if ( version file == null || ! version file . exists ( ) ) { return null ; } try { final properties props = new properties ( ) ; final file input stream is = new file input stream ( version file ) ; try { props . load ( is ) ; } finally { is . close ( ) ; } string version string = props . get property ( workspace check reference bundle name ) ; if ( version string != null ) { return version . parse version ( version string ) ; } version string = props . get property ( workspace check reference bundle name legacy ) ; if ( version string != null ) { return version . parse version ( version string ) ; } return null ; } catch ( final io e ) { ide . log ( str + version file , new status ( i . error , ide . ide workbench , i . error , e . get message ( ) == null ? str : e . get message ( ) , e ) ) ; return null ; } catch ( final illegal argument exception e ) { ide . log ( str + version file , new status ( i . error , ide . ide workbench , i . error , e . get message ( ) == null ? str : e . get message ( ) , e ) ) ; return null ; } }	look at the argument url for the workspace ' s version information.
public vector approximation calculate approximation ( dbid id , v dv ) { int [ ] approximation = new int [ dv . get dimensionality ( ) ] ; for ( int d = num ; d < split positions . length ; d ++ ) { final double val = dv . double value ( d ) ; final int last border index = split positions [ d ] . length - num ; if ( val < split positions [ d ] [ num ] ) { approximation [ d ] = num ; if ( id != null ) { log . warning ( str ) ; } } else if ( val > split positions [ d ] [ last border index ] ) { approximation [ d ] = last border index - num ; if ( id != null ) { log . warning ( str ) ; } } else { int pos = arrays . binary search ( split positions [ d ] , val ) ; pos = ( pos >= num ) ? pos : ( ( - pos ) - num ) ; approximation [ d ] = pos ; } } return new vector approximation ( id , approximation ) ; }	calculate the va file position given the existing borders .
private boolean check if volume size exceeding pool size ( cim [ ] in args , cim [ ] out args ) { if ( get volume size ( in args ) > get volume size ( out args ) ) { return bool ; } return bool ; }	method checks whether the requested volume size exceeds pool size.
@ suppress warnings ( str ) private void log ( string label , byte buffer buffer ) { string builder sb = new string builder ( ) ; sb . append ( label ) ; sb . append ( str ) ; sb . append ( buffer . get ( num ) ) ; sb . append ( str ) ; for ( int x = num ; x < num ; x ++ ) { sb . append ( string . format ( str , ( int ) ( buffer . get ( x ) & num ) ) ) ; sb . append ( str ) ; } m log . debug ( sb . to string ( ) ) ; }	convenience logger for debugging read / write operations.
private void read object ( object input stream ois ) throws class not found exception , io { ois . default read object ( ) ; boolean has font = ois . read boolean ( ) ; if ( has font ) { string name = ( string ) ois . read object ( ) ; int size = ois . read int ( ) ; int style = ois . read int ( ) ; font = new font ( name , style , size ) ; } else { font = om . default font ; } }	reconstitute from an objectinputstream .
public void add file ( string filename ) { if ( filename != null ) add file ( new file ( filename ) ) ; }	adds a file to the classpath if it exists .
public string format ( temporal accessor temporal ) { string builder buf = new string builder ( num ) ; format to ( temporal , buf ) ; return buf . to string ( ) ; }	formats a date - time object using this formatter.
public void paint toggle button background ( synth context context , graphics g , int x , int y , int w , int h ) { paint background ( context , g , x , y , w , h , null ) ; }	paints the background of a toggle button .
void save device profile ( @ nonnull string user , @ nonnull string realm , @ nonnull oath device settings device settings ) throws auth login exception { reject . if null ( user , realm , device settings ) ; try { devices dao . save device profiles ( user , realm , json utils . to json values ( collections . singleton list ( device settings ) ) ) ; } catch ( io e ) { debug . error ( str , user , realm , e ) ; throw new auth login exception ( e ) ; } }	saves the oath device settings to the user ' s profile , overwriting any existing device profile .
protected list < string > parameters to string list ( list < parameter > parameters ) { list < string > list = new array list < > ( ) ; for ( parameter parameter : parameters ) { list . add ( string . format ( str , parameter . get name ( ) , parameter . get value ( ) ) ) ; } return list ; }	converts a list of parameters to a list of string values .
public static boolean is matching name ( string name a , string name b ) { int a = name a . length ( ) ; int b = name b . length ( ) ; if ( a == b ) { return name a . equals ( name b ) ; } else if ( a < b - num ) { return name b . ends with ( name a ) && name b . char at ( b - a - num ) == str ; } else if ( b < a - num ) { return name a . ends with ( name b ) && name a . char at ( a - b - num ) == str ; } else { return bool ; } }	returns whether the two names match.
private void validate will ( string dest , object payload ) { if ( ( dest == null ) || ( payload == null ) ) { throw new illegal argument exception ( ) ; } mqtt async client . validate topic ( dest ) ; }	validates the will fields .
public static float ccp calc rotate ( final cg from , final cg to ) { float o = to . x - from . x ; float a = to . y - from . y ; float at = cc macros . cc radians to degrees ( ( float ) math . atan ( o / a ) ) ; if ( a < num ) { if ( o < num ) at = num + math . abs ( at ) ; else at = num - math . abs ( at ) ; } return at ; }	caculate the rotation ( in degrees ) between two points , so that when we move from one point to the other , we can set the correct rotation to head to that point .
public static string clean tabs ( string yaml ) { if ( yaml . contains ( str ) ) { logger . warn ( str + str + str , tab as spaces . length ( ) ) ; list < string > lines = newline splitter . split to list ( yaml ) ; string builder sb = new string builder ( ) ; for ( string line : lines ) { string clean line = replace starting tabs with spaces ( line ) ; sb . append ( clean line ) ; sb . append ( str ) ; } return sb . to string ( ) ; } else { return yaml ; } }	strips any tabs which are at the beginning on.
private static paint darker radial gradient paint ( radial gradient paint paint ) { final color [ ] paint colors = paint . get colors ( ) ; for ( int i = num ; i < paint colors . length ; i ++ ) { paint colors [ i ] = darker ( paint colors [ i ] ) ; } return new radial gradient paint ( paint . get center point ( ) , paint . get radius ( ) , paint . get focus point ( ) , paint . get fractions ( ) , paint colors , paint . get cycle method ( ) , paint . get color space ( ) , paint . get transform ( ) ) ; }	create a new gradient with its colours darkened .
public void test key builder ascii order ( ) { key builder key builder = ( key builder ) key builder . new instance ( ) ; kvo < string > [ ] a = new kvo [ ] { new kvo < string > ( test key builder . as sort key ( str ) , null , str ) , new kvo < string > ( test key builder . as sort key ( str ) , null , str ) , new kvo < string > ( test key builder . as sort key ( str ) , null , str ) , new kvo < string > ( test key builder . as sort key ( str ) , null , str ) } ; arrays . sort ( a ) ; assert equals ( str , a [ num ] . obj ) ; assert equals ( str , a [ num ] . obj ) ; assert equals ( str , a [ num ] . obj ) ; assert equals ( str , a [ num ] . obj ) ; }	test verifies the order for ascii sort keys , including verifying that the pad byte causes a prefix such as " bro " to sort before a term which extends that prefix , such as " brown " .
public boolean is click touch screen ( ) { string s = device info . get software version ( ) ; if ( s . length ( ) > num ) { int v = integer . parse int ( s . substring ( num , num ) ) ; return v <= num ; } return bool ; }	currently we assume the ' click screen ' is relevant to platform 5 and 4.
public dom new instance ( document builder setting [ ] new settings ) throws dom { if ( new settings == null ) { return this ; } document builder setting [ ] merged settings = merge settings ( new settings ) ; return new ls ( merged settings ) ; }	create new instance of document builder factory reflecting specified settings.
public void reset ( ) { index = num ; if ( file != null ) { list index = num ; if ( ! written ) { write all rows ( ) ; written = bool ; } list . clear ( ) ; file . seek ( file store . header length ) ; } }	remove all rows from the list .
public void add ( geometry function func ) { functions . add ( func ) ; sorted functions . put ( func . get name ( ) , func ) ; categorized functions . put ( func . get category ( ) , func . get name ( ) , func ) ; if ( has geometry result ( func ) ) categorized geometry functions . put ( func . get category ( ) , func . get name ( ) , func ) ; }	adds a function if it does not currently exist in the registry , or replaces the existing one with the same signature .
public void fire state changed ( ) { change event e = new change event ( this ) ; for ( change listener listener : listeners ) { listener . state changed ( e ) ; } }	should be called whenever a field was updated.
public static clusters convert to clusters ( graph cluster graph , list < node > measured variables ) { list < string > latents = new array list < > ( ) ; clusters clusters = new clusters ( ) ; cluster graph = graph utils . replace nodes ( cluster graph , measured variables ) ; for ( node node : cluster graph . get nodes ( ) ) { if ( ! measured variables . contains ( node ) ) { latents . add ( node . get name ( ) ) ; } } collections . sort ( latents ) ; for ( int i = num ; i < latents . size ( ) ; i ++ ) { string name = latents . get ( i ) ; clusters . set cluster name ( i , name ) ; node latent = cluster graph . get node ( name ) ; list < node > measured = cluster graph . get nodes out to ( latent , endpoint . arrow ) ; for ( node node : measured ) { if ( measured variables . contains ( node ) ) { clusters . add to cluster ( i , node . get name ( ) ) ; } } } return clusters ; }	converts a disconnected multiple indicator model into a set of clusters.
final short rlshort ( data input stream dis ) throws io { short s = num ; short high , low ; s = dis . read short ( ) ; high = ( short ) ( ( s & num ) << num ) ; low = ( short ) ( ( s & num ) > > > num ) ; s = ( short ) ( high | low ) ; return s ; }	rlshort protected helper method to read 16 bits value.
public void encode cell ( mx i cell , node node , boolean include children ) { node . append child ( encode ( cell ) ) ; if ( include children ) { int child count = cell . get child count ( ) ; for ( int i = num ; i < child count ; i ++ ) { encode cell ( cell . get child at ( i ) , node , include children ) ; } } }	encoding of cell hierarchies is built - into the core , but is a higher - level function that needs to be explicitely used by the respective object encoders ( eg.
public date time formatter with locale ( locale locale ) { if ( locale == get locale ( ) || ( locale != null && locale . equals ( get locale ( ) ) ) ) { return this ; } return new date time formatter ( i printer , i parser , locale , i offset parsed , i chrono , i zone , i pivot year , i default year ) ; }	returns a new formatter with a different locale that will be used for printing and parsing.
public void test iterate ( ) { final range range = create range ( num , num ) ; int next = num ; final iterator iter = range . iterator ( ) ; while ( iter . has next ( ) ) { final object value = iter . next ( ) ; assert equals ( str , create value ( next ++ ) , value ) ; } assert equals ( str , num , next ) ; try { iter . next ( ) ; fail ( str ) ; } catch ( no such element exception ignore ) { } }	tests iterating over a non - reversed range .
public string next string ( char quote ) throws json { char c ; string builder sb = new string builder ( ) ; for ( ; ; ) { c = next ( ) ; switch ( c ) { case num : case str : case str : throw syntax error ( str ) ; case str : c = next ( ) ; switch ( c ) { case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( str ) ; break ; case str : sb . append ( ( char ) integer . parse int ( next ( num ) , num ) ) ; break ; case str : case str : case str : case str : sb . append ( c ) ; break ; default : throw syntax error ( str ) ; } break ; default : if ( c == quote ) { return sb . to string ( ) ; } sb . append ( c ) ; } } }	return the characters up to the next close quote character.
public static response parse xml ( string xml ) throws saml { document doc = xml . to dom ( xml , saml . debug ) ; element root = doc . get document element ( ) ; return new response ( root ) ; }	returns response object based on the xml document received from server.
public sql register param type ( string param name , string data type ) { if ( param types == null ) { param types = new hash map ( ) ; } param types . put ( param name , data type ) ; return this ; }	register the datatype for a sql param .
public void begin step ( int step , string step title , logging logger ) { set processed ( step - num ) ; this . step title = step title ; logger . progress ( this ) ; }	do a new step and log it.
public boolean equals ( object obj ) { if ( this == obj ) { return bool ; } else if ( ! ( obj instanceof method desc ) ) { return bool ; } method desc od = ( method desc ) obj ; return ( ( name == null ? od . name == null : name . equals ( od . name ) ) && arrays . equals ( types , od . types ) && ( constraints == null ? od . constraints == null : constraints . equals ( od . constraints ) ) ) ; }	two instances of this class are equal if they have the same name , the same parameter types , and the same constraints .
public set < string > add content ( dialogue state new state ) { if ( ! paused ) { cur state . add to state ( new state ) ; return update ( ) ; } else { log . info ( str + new state ) ; return collections . empty set ( ) ; } }	merges the dialogue state included as argument into the current one , and updates the dialogue state .
public long remove index ( int index ) { if ( index >= size ) throw new index out of bounds exception ( string . value of ( index ) ) ; long [ ] items = this . items ; long value = items [ index ] ; size -- ; if ( ordered ) system . arraycopy ( items , index + num , items , index , size - index ) ; else items [ index ] = items [ size ] ; return value ; }	removes and returns the item at the specified index .
public fd load model ( string filename , string cwd ) { string fn = filename ; if ( fn == null ) return null ; if ( ! fn . ends with ( str + file extension ) ) { fn += str + file extension ; } model persistence handler persistence handler = create model persistence handler ( resource set provider . get ( ) ) ; return ( fd ) persistence handler . load model ( fn , cwd ) ; }	load franca deployment model file ( *.
public boolean save current configuration ( ) { if ( current config . to string ( ) == null ) { return ( bool ) ; } int answer = j . show confirm dialog ( null , str , str , j . yes no cancel option , j . question message , icons . get image icon ( str ) ) ; if ( answer == j . cancel option ) { return ( bool ) ; } else if ( answer == j . no option ) { return ( bool ) ; } return ( save current configuration as ( bool ) ) ; }	save the current configuration.
public static double [ ] normalise ( double [ ] init probs ) { for ( int i = num ; i < init probs . length ; i ++ ) { if ( init probs [ i ] < num ) { init probs [ i ] = num ; } } double sum = num ; for ( double prob : init probs ) { sum += prob ; } double [ ] result = new double [ init probs . length ] ; if ( sum > num ) { for ( int i = num ; i < init probs . length ; i ++ ) { result [ i ] = init probs [ i ] / sum ; } } else { for ( int i = num ; i < init probs . length ; i ++ ) { result [ i ] = num / init probs . length ; } } return result ; }	normalises the double array ( ensuring that the sum is equal to 1.
protected string builder append search string param if necessary ( string builder sb ) { string search string param = get encoded search string param ( ) ; if ( search string param != null ) { if ( sb . index of ( str ) == - num ) { sb . append ( str ) ; } else { sb . append ( str ) ; } sb . append ( search string param ) ; } return sb ; }	if a search has been executed , appends a url - encoded string representation of the search criteria to the given stringbuilder , as a get parameter.
public static class info find or create class ( string full name ) { class info u = find class ( full name ) ; if ( u == null ) { u = new class info ( full name ) ; if ( u . is array ( ) ) { find or create class ( full name . substring ( num ) ) ; } } return u ; }	find a class representation with give name.
pla point rational ( big integer p x , big integer p y , big integer p z ) { rp x = p x ; rp y = p y ; rp z = p z ; is nan = p z . signum ( ) <= num ; }	creates a retionalpoint from 3 bigintegers p_x , p_y and p_z.
public boolean is null value ( ) { return string utils . trim to null ( value ) == null && string utils . trim to null ( comment ) == null ; }	indicates whether the value is null .
private map < long , pair < string , long > > recover pending large messages ( ) throws exception { map < long , pair < string , long > > large messages = new hash map < > ( ) ; list < string > filenames = large messages factory . list files ( str ) ; list < long > id list = new array list < > ( ) ; for ( string filename : filenames ) { long id = get large message id from filename ( filename ) ; if ( ! large messages to delete . contains ( id ) ) { id list . add ( id ) ; sequential file seq file = large messages factory . create sequential file ( filename ) ; long size = seq file . size ( ) ; large messages . put ( id , new pair < > ( filename , size ) ) ; } } return large messages ; }	sets a list of large message files into the replicationmanager for synchronization.
private void check for fragment id ( attributes attributes ) { if ( ! m should process ) { if ( ( null != attributes ) && ( null != m fragment id ) ) { int n = attributes . get length ( ) ; for ( int i = num ; i < n ; i ++ ) { string name = attributes . get q ( i ) ; if ( name . equals ( constants . attrname id ) ) { string val = attributes . get value ( i ) ; if ( val . equals ignore case ( m fragment id ) ) { m should process = bool ; m fragment id = m element id ; } } } } } }	check to see if an id attribute matched the # id , called from startelement .
public void unparsed entity decl ( string name , xml identifier , string notation , augmentations augs ) throws xni { try { if ( f dtd != null ) { string public id = identifier . get public id ( ) ; string system id = f resolve dtdur ? identifier . get expanded system id ( ) : identifier . get literal system id ( ) ; f dtd . unparsed entity decl ( name , public id , system id , notation ) ; } } catch ( sax e ) { throw new xni ( e ) ; } }	an unparsed entity declaration .
public void wait for paxos to finish ( ) { propose lock . lock ( ) ; can propose . await uninterruptibly ( ) ; propose lock . unlock ( ) ; }	this method blocks until the paw algorithm is finished.
public static response data parse ( string response data ) { int index = response data . index of ( str ) ; string main data , extra data ; if ( - num == index ) { main data = response data ; extra data = str ; } else { main data = response data . substring ( num , index ) ; extra data = index >= response data . length ( ) ? str : response data . substring ( index + num ) ; } string [ ] fields = text utils . split ( main data , pattern . quote ( str ) ) ; if ( fields . length < num ) { throw new illegal argument exception ( str ) ; } response data data = new response data ( ) ; data . extra = extra data ; data . response code = integer . parse int ( fields [ num ] ) ; data . nonce = integer . parse int ( fields [ num ] ) ; data . package name = fields [ num ] ; data . version code = fields [ num ] ; data . user id = fields [ num ] ; data . timestamp = long . parse long ( fields [ num ] ) ; return data ; }	parses response string into responsedata .
public void test set login config adding ( ) throws exception { string xml = webapp test header + str ; web xml web xml = web xml io . parse web xml ( new byte array input stream ( xml . get bytes ( str ) ) , get entity resolver ( ) ) ; web xml utils . set login config ( web xml , str , str ) ; assert true ( web xml utils . has login config ( web xml ) ) ; assert equals ( str , web xml utils . get login config auth method ( web xml ) ) ; }	tests retrieving the authentication method from a descriptor .
public void validate ( ) throws am { if ( is selected ( ) ) { if ( is personal question ( ) ) { if ( ( question . length ( ) == num ) || ( answer . length ( ) == num ) ) { throw new am ( str ) ; } } else { if ( answer . length ( ) == num ) { throw new am ( str ) ; } } } }	validates data for correctness.
public static void assert true ( boolean b , object message ) { if ( ! b ) { throw error ( message ) ; } }	assert that a boolean value is true.
private string [ ] spliterator ( string phrase ) { string [ ] split = phrase . split ( str ) ; string [ ] out = new string [ split . length ] ; for ( int ix = num ; ix < split . length ; ix ++ ) { string temp = split [ ix - num ] ; temp += str + split [ ix ] ; out [ ix - num ] = temp ; } return out ; }	splits the phrase into groups of two , with overlap this is for achieving a chain length of three.
protected signature ( string algorithm ) { this . algorithm = algorithm ; }	creates a signature object for the specified algorithm .
private final void augment token list ( ) { token [ ] temp = new token [ size + increment ] ; system . arraycopy ( token list , num , temp , num , size ) ; size += increment ; token list = temp ; for ( int i = num ; i < increment ; i ++ ) { token list [ size - i - num ] = create internal use only token ( ) ; } }	adds tokens to the internal token list.
public string calculate from string ( string data ) throws exception { log . trace ( str , algo uri , data ) ; return calculate from bytes ( data . get bytes ( standard charsets . utf 8 ) ) ; }	calculates hash value in base64 format .
public void add channels ( list < channel > channels ) { for ( channel channel : channels ) { add channel ( channel ) ; } }	bulk loading of channel list.
public static string [ ] merge string arrays ( string [ ] array1 , string [ ] array2 ) { if ( object utils . is empty ( array1 ) ) { return array2 ; } if ( object utils . is empty ( array2 ) ) { return array1 ; } list < string > result = new array list < string > ( ) ; result . add all ( arrays . as list ( array1 ) ) ; for ( string str : array2 ) { if ( ! result . contains ( str ) ) { result . add ( str ) ; } } return to string array ( result ) ; }	merge the given string arrays into one , with overlapping array elements only included once.
private double damp ( double value ) { return math . sqrt ( value ) ; }	rescales the interpolated value to make it smoother .
public void add measurement ( double measurement ) { double keep constant = num - m decay constant ; if ( m count > m cutover ) { m value = math . exp ( keep constant * math . log ( m value ) + m decay constant * math . log ( measurement ) ) ; } else if ( m count > num ) { double retained = keep constant * m count / ( m count + num ) ; double newcomer = num - retained ; m value = math . exp ( retained * math . log ( m value ) + newcomer * math . log ( measurement ) ) ; } else { m value = measurement ; } m count ++ ; }	adds a new measurement to the moving average .
@ suppress warnings ( str ) private string next unquoted value ( ) throws io { string builder builder = null ; int i = num ; find non literal character : while ( bool ) { for ( ; pos + i < limit ; i ++ ) { switch ( buffer [ pos + i ] ) { case str : case str : case str : case str : case str : check lenient ( ) ; case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : break find non literal character ; } } if ( i < buffer . length ) { if ( fill buffer ( i + num ) ) { continue ; } else { break ; } } if ( builder == null ) { builder = new string builder ( ) ; } builder . append ( buffer , pos , i ) ; pos += i ; i = num ; if ( ! fill buffer ( num ) ) { break ; } } string result ; if ( builder == null ) { result = new string ( buffer , pos , i ) ; } else { builder . append ( buffer , pos , i ) ; result = builder . to string ( ) ; } pos += i ; return result ; }	returns an unquoted value as a string .
public long arg end ( ) { return long . parse long ( fields [ num ] ) ; }	( since linux 3.
static list < i > compute classpath ( i java project ) throws core exception { i [ ] unresolved runtime classpath = java runtime . compute unresolved runtime classpath ( java project ) ; list < i > resolved runtime classpath = new array list < i > ( ) ; for ( i unresolved classpath entry : unresolved runtime classpath ) { if ( java runtime . is vm ( unresolved classpath entry ) ) { continue ; } resolved runtime classpath . add all ( arrays . as list ( java runtime . resolve runtime classpath entry ( unresolved classpath entry , java project ) ) ) ; } try { resolved runtime classpath . add all ( num , gwt . get gwt ( java project , bool ) ) ; } catch ( sdk exception e ) { throw new core exception ( new status ( i . error , gwt . plugin id , e . get localized message ( ) , e ) ) ; } gwt sdk gwt runtime = gwt sdk . find sdk for ( java project ) ; if ( gwt runtime == null ) { gwt . log warning ( str + java project . get element name ( ) + str ) ; return resolved runtime classpath ; } i validation status = gwt runtime . validate ( ) ; if ( ! validation status . is ok ( ) ) { gwt . log warning ( str + java project . get element name ( ) + str + validation status . get message ( ) + str ) ; return resolved runtime classpath ; } try { file gwt dev jar = gwt runtime . get dev jar ( ) ; resolved runtime classpath . add ( java runtime . new archive runtime classpath entry ( path . from os ( gwt dev jar . get absolute path ( ) ) ) ) ; } catch ( sdk exception e ) { gwt . log warning ( e , str ) ; } return resolved runtime classpath ; }	computes a gwt compiler - tailored list of classpath entries for the given java project .
@ suppress warnings ( str ) public throwing mock token filter factory ( map < string , string > args ) { super ( args ) ; string exception class name = args . get ( str ) ; if ( exception class name == null ) { throw new runtime exception ( str ) ; } try { exception class = ( class < ? extends runtime exception > ) class . for name ( exception class name ) ; } catch ( class not found exception e ) { throw new runtime exception ( e ) ; } }	initialize this factory via a set of key - value pairs .
public pattern guard expr ( string namespace , string name , list < expression > parameters , pattern expr guarded pattern ) { super ( namespace , name , parameters ) ; this . guarded = new array list < pattern expr > ( ) ; guarded . add ( guarded pattern ) ; }	ctor - for use to create a pattern expression tree , without pattern child expression .
private long start new track ( ) { if ( is recording ( ) ) { log . d ( tag , str ) ; return - num ; } long now = system . current time millis ( ) ; track trip statistics updater = new trip statistics updater ( now ) ; marker trip statistics updater = new trip statistics updater ( now ) ; track track = new track ( ) ; uri uri = my tracks provider utils . insert track ( track ) ; long track id = long . parse long ( uri . get last path segment ( ) ) ; update recording state ( track id , bool ) ; preferences utils . set int ( this , r . string . auto resume track current retry key , num ) ; preferences utils . set int ( this , r . string . activity recognition type key , preferences utils . activity recognition type default ) ; track . set id ( track id ) ; track . set name ( track name utils . get track name ( this , track id , now , null ) ) ; string category = preferences utils . get string ( this , r . string . default activity key , preferences utils . default activity default ) ; track . set category ( category ) ; track . set icon ( track icon utils . get icon value ( this , category ) ) ; track . set trip statistics ( track trip statistics updater . get trip statistics ( ) ) ; my tracks provider utils . update track ( track ) ; insert waypoint ( waypoint creation request . default start track ) ; start recording ( bool ) ; return track id ; }	starts a new track .
protected mr poll message ( ) { if ( disable poll ) { return null ; } if ( ! poll queue . is empty ( ) ) { poll message pm = poll queue . peek ( ) ; if ( pm != null ) { return pm . get message ( ) ; } } return null ; }	check tams mc for updates .
private boolean is suppress warnings test ( string base name ) { return base name . equals ( str ) ; }	return true if the test name is " suppress_warnings " .
protected static string apply limit clause ( final string query , int limit , final int query result set limit ) { matcher matcher = select expr pattern . matcher ( query ) ; if ( matcher . matches ( ) ) { matcher limit matcher = select with limit expr pattern . matcher ( query ) ; boolean query already has limit clause = limit matcher . matches ( ) ; if ( ! query already has limit clause ) { if ( limit == num ) { limit = query result set limit ; } string result = query ; result += str + limit ; return result ; } } return query ; }	matches the input query with query with limit pattern.
public void unmaximise component ( ) { if ( maximised component == null ) { return ; } container . remove ( maximised component ) ; container . add ( container child ) ; parent maximised component . add ( maximised component ) ; container . validate ( ) ; container child = null ; parent maximised component = null ; maximised component = null ; }	unmaximises the current maximised component.
default char seq join ( char sequence delimiter , char sequence prefix , char sequence suffix ) { string builder string builder = new string builder ( prefix ) ; for each ( null ) ; string builder . append ( suffix ) ; return char seq . of ( string builder . to string ( ) ) ; }	convert all elements into string , and connect each string together to a single string , following the same order of the seq.
public void remove listener ( t listener ) { if ( listeners != null ) { list < t > newlisteners = new array list < t > ( ) ; newlisteners . add all ( listeners ) ; newlisteners . remove ( listener ) ; listeners = newlisteners ; } }	remove the given listener.
public static void save as ascii ( ns root , file out ) throws io { output stream writer w = new output stream writer ( new file output stream ( out ) , str ) ; w . write ( root . to ascii ( ) ) ; w . close ( ) ; }	saves a property list with the given object as root into a ascii file .
public static void filter outbound ( string builder message ) { for ( int i = num ; i < message . length ( ) ; i ++ ) { char current char = message . char at ( i ) ; if ( legal characters . index of ( current char ) == - num ) { if ( current char > num ) { int char as int = current char ; string string version = integer . to string ( char as int , num ) ; string replacement = str + string version + str ; message . replace ( i , i + num , replacement ) ; i += replacement . length ( ) - num ; } else { message . delete char at ( i ) ; i -- ; } } } }	filters out illegal chars , and appends a \ n to the passed in message.
public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . sax { if ( ch == null || start < num || length >= ( ch . length - start ) || length < num ) return ; append ( m doc . create comment ( new string ( ch , start , length ) ) ) ; }	report an xml comment anywhere in the document.
public boolean is empty ( ) { return array list . is empty ( ) ; }	returns true for empty .
public arbitrary length path node ( final term node left , final term node right , final var node t var left , final var node t var right , final path mod mod ) { this ( new b [ ] { new join group node ( ) } , nv . as map ( new nv ( annotations . left term , left ) , new nv ( annotations . right term , right ) , new nv ( annotations . transitivity var left , t var left ) , new nv ( annotations . transitivity var right , t var right ) , new nv ( annotations . lower bound , mod == path mod . one or more ? num : num ) , new nv ( annotations . upper bound , mod == path mod . zero or one ? num : long . max value ) ) ) ; final set < var node > drop vars = new linked hash set < > ( ) ; drop vars . add ( t var left ) ; drop vars . add ( t var right ) ; set property ( annotations . drop vars , drop vars ) ; }	fully construct an arbitrary length path node with all required annotations .
static void check flags ( int flags ) { int allowed flags = read only flag mask | empty flag mask | compact flag mask | ordered flag mask ; int flags mask = ~ allowed flags ; if ( ( flags & flags mask ) > num ) { throw new sketches argument exception ( str + integer . to binary string ( flags ) ) ; } }	checks just the flags field of the preamble.
public static array list < object > delete item sets ( array list < object > item sets , int min support , int max support ) { array list < object > new vector = new array list < object > ( item sets . size ( ) ) ; for ( int i = num ; i < item sets . size ( ) ; i ++ ) { labeled item set current = ( labeled item set ) item sets . get ( i ) ; if ( ( current . m rule sup counter >= min support ) && ( current . m rule sup counter <= max support ) ) { new vector . add ( current ) ; } } return new vector ; }	deletes all item sets that don ' t have minimum support and have more than maximum support.
private static synchronized string make date string ( date date ) { return sdf default . format ( date ) ; }	generates a string representation of a java date object.
public static string generate native guid ( db client db client , file share file share ) throws io { storage system device = db client . query object ( storage system . class , file share . get storage device ( ) ) ; return string . format ( str + filesystem + str , device type map . get ( device . get system type ( ) ) , device . get serial number ( ) , file share . get native id ( ) ) ; }	generates the format storagesystem + serialnumber + filesystem + nativeid native guid for fileshare objects.
public string to string ( ) { string buffer result = new string buffer ( ) ; int temp ; temp = ip address & num ; result . append ( temp ) ; result . append ( str ) ; temp = ( ip address > > num ) & num ; result . append ( temp ) ; result . append ( str ) ; temp = ( ip address > > num ) & num ; result . append ( temp ) ; result . append ( str ) ; temp = ( ip address > > num ) & num ; result . append ( temp ) ; return result . to string ( ) ; }	return the string representation of the ip address following the common decimal - dotted notation xxx.
private static double distance ( point p1 , point p2 ) { double x = p1 . x - p2 . x ; double y = p1 . y - p2 . y ; return math . sqrt ( x * x + y * y ) ; }	calculate the distance between two points.
public void add hyperedge in node ( hyper edge hyper edge ) { if ( hyper edge != null ) { if ( null == hyperedges ) hyperedges = new array list < > ( ) ; hyperedges . add ( hyper edge ) ; semiring plus ( hyper edge ) ; } }	adds the hyperedge to the list of incoming hyperedges ( i.
public rotated problems ( ) { super ( ) ; }	constructs a problem provider for rotated problems .
public docker port mapping with host port ( int host port ) { docker port mapping new mapping = new docker port mapping ( ) ; new mapping . protocol = protocol ; new mapping . container port = container port ; new mapping . host ip = host ip ; new mapping . host port = string . value of ( host port ) ; return new mapping ; }	create a copy of this mapping with the given host port.
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return i ; case num : return i ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
@ override public int length ( ) { return str . length ( ) ; }	returns the string length.
public void clear all haptics ( ) { m haptics . clear ( ) ; }	clears all haptic patterns associated with this fragment .
public void encode ( final mq buffer ) { buffer . write string ( name ) ; buffer . write string ( factory class name ) ; buffer . write int ( params == null ? num : params . size ( ) ) ; if ( params != null ) { encode map ( buffer , params ) ; } if ( extra props != null ) { encode map ( buffer , extra props ) ; } }	encodes this transportconfiguration into a buffer.
@ override public void write ( byte [ ] b , int off , int len ) throws io { flush bits ( ) ; out . write ( b , off , len ) ; }	commit any outstanding bit writes and then write some bytes to the underlying output stream .
public static double log2 ( double x ) { return math . log ( x ) / lo ; }	the base 2 logarithm of the input value.
boolean is name used ( string name ) { list < integer > columns with name = column names . get ( name ) ; return columns with name != null && ! columns with name . is empty ( ) ; }	checks if the given column name is already in use .
public state interactive complete ( ) { if ( return state != this && actlog != null ) { actlog . start scope ( logfile scope . complete scope ) ; } return return state ; }	action to be taken , when this state is completed and exited.
private work queue find non empty steal queue ( ) { work queue [ ] ws ; int wl ; int r = tl . next secondary seed ( ) ; if ( ( ws = work queues ) != null && ( wl = ws . length ) > num ) { int m = wl - num , origin = r & m ; for ( int k = origin , old sum = num , check sum = num ; ; ) { work queue q ; int b ; if ( ( q = ws [ k ] ) != null ) { if ( ( b = q . base ) - q . top < num ) return q ; check sum += b ; } if ( ( k = ( k + num ) & m ) == origin ) { if ( old sum == ( old sum = check sum ) ) break ; check sum = num ; } } } return null ; }	returns a ( probably ) non - empty steal queue , if one is found during a scan , else null.
private void do ddp orientation ( node d , node a , node b , node c , graph graph ) { list < node > sepset = get sepset ( d , c ) ; if ( sepset == null ) { return ; } if ( sepset . contains ( b ) ) { graph . set endpoint ( c , b , endpoint . tail ) ; if ( verbose ) { logger . log ( str , search log utils . edge oriented msg ( str + d , graph . get edge ( b , c ) ) ) ; out . println ( search log utils . edge oriented msg ( str + d , graph . get edge ( b , c ) ) ) ; } change flag = bool ; } else { if ( ! is arrowpoint allowed ( a , b , graph ) ) { return ; } if ( ! is arrowpoint allowed ( c , b , graph ) ) { return ; } graph . set endpoint ( a , b , endpoint . arrow ) ; graph . set endpoint ( c , b , endpoint . arrow ) ; logger . log ( str , search log utils . collider oriented msg ( str + d , a , b , c ) ) ; change flag = bool ; } }	orients the edges inside the definte discriminating path triangle.
public void handle tbl bootstrap res off href action request ( request invocation event event ) throws model control exception { try { map values = get values ( ) ; on before save profile ( values ) ; set page session attribute ( property attribute , ( hash map ) values ) ; sm vb = ( sm ) get view bean ( sm . class ) ; unlock page trail ( ) ; pass pg session map ( vb ) ; vb . populate values ( ( string ) get display field value ( tbl bootstrap res off href action ) ) ; vb . forward to ( get request context ( ) ) ; } catch ( am e ) { set inline alert message ( cc . type error , str , e . get message ( ) ) ; } }	handles edit bootstrap resource offering request .
@ visible for testing string post request ( long timestamp , string xml ) throws request failure exception { string response = null ; url url connection = null ; try { url connection = create connection ( ) ; set up post request ( timestamp , url connection , xml ) ; send request to server ( url connection , xml ) ; response = read response from server ( url connection ) ; } finally { if ( url connection != null ) { url connection . disconnect ( ) ; } } return response ; }	posts the request to the omaha server .
private void generate key ( ) throws exception { key generator keygen = key generator . get instance ( algo ) ; secret key key = keygen . generate key ( ) ; persist key ( key ) ; }	generates a new key and persists it to coordinator.
public http request event fire http request event ( string request , output stream output ) throws io { http request event event = new http request event ( this , request , output ) ; http request listener listener ; vector list = ( vector ) listeners . clone ( ) ; enumeration e = list . elements ( ) ; while ( e . has more elements ( ) ) { listener = ( http request listener ) e . next element ( ) ; listener . http request ( event ) ; } return event ; }	creates a httprequestevent and sends it to all registered listeners .
private void parse record ( element unit node ) { node list nl = unit node . get child nodes ( ) ; for ( int i = num ; i < nl . get length ( ) ; i ++ ) { node curr node = nl . item ( i ) ; if ( curr node . get parent node ( ) != unit node ) { continue ; } int node type = curr node . get node type ( ) ; if ( node type == node . element node ) { string node name = curr node . get node name ( ) ; if ( node name . equals ignore case ( unit ) ) { parse unit ( ( element ) curr node , entities ) ; } else if ( node name . equals ignore case ( survivors ) ) { parse unit ( ( element ) curr node , survivors ) ; } else if ( node name . equals ignore case ( allies ) ) { parse unit ( ( element ) curr node , allies ) ; } else if ( node name . equals ignore case ( salvage ) ) { parse unit ( ( element ) curr node , salvage ) ; } else if ( node name . equals ignore case ( devastated ) ) { parse unit ( ( element ) curr node , devastated ) ; } else if ( node name . equals ignore case ( kills ) ) { parse kills ( ( element ) curr node ) ; } else if ( node name . equals ignore case ( entity ) ) { parse unit ( ( element ) curr node , entities ) ; } else if ( node name . equals ignore case ( pilot ) ) { parse pilot ( ( element ) curr node ) ; } } else { continue ; } } }	parse a unit tag.
public void cancel ( ) { synchronized ( lock ) { if ( this . latency == no target ) { throw new illegal state exception ( str + str ) ; } if ( ! requests . remove ( this ) ) { throw new internal error ( str + this + str ) ; } if ( requests . is empty ( ) ) requests = null ; this . latency = no target ; adjust latency if needed ( ) ; } }	cancels this latency request .
void merge success ( merge policy . one merge merge ) { }	hook that ' s called when the specified merge is complete .
void start event tracker ( ) { list < event tracking service > services = get enabled services for type ( event tracking service . class ) ; if ( services != null && ! services . is empty ( ) ) { if ( event tracker == null ) { event tracker = new event tracker ( context , services , foam api keys . wifi only ( ) ) ; } if ( ! event tracker . is running ( ) ) { event tracker . start ( ) ; } } }	start foam event tracker.
@ override public int preceding ( int offset ) { character iterator text = get text ( ) ; check offset ( offset , text ) ; if ( cached break positions == null || offset <= cached break positions [ num ] || offset > cached break positions [ cached break positions . length - num ] ) { cached break positions = null ; return super . preceding ( offset ) ; } else { position in cache = num ; while ( position in cache < cached break positions . length && offset > cached break positions [ position in cache ] ) { ++ position in cache ; } -- position in cache ; text . set index ( cached break positions [ position in cache ] ) ; return text . get index ( ) ; } }	sets the current iteration position to the last boundary position before the specified position .
protected static boolean signed fits in nibble ( int value ) { return ( value >= - num ) && ( value <= num ) ; }	helper method to determine if a signed int value fits in a nibble .
@ override public void mouse pressed ( mouse event e ) { events . clear ( ) ; if ( map drag operation from modifiers ( e ) != d . action none ) { try { motion threshold = drag source . get drag threshold ( ) ; } catch ( exception exc ) { motion threshold = num ; } append event ( e ) ; } }	invoked when a mouse button has been pressed on a component .
public void simple element ( string name , string value ) throws io { simple element ( null , name , null , value ) ; }	emits a simple element ( without child elements ) .
public static boolean is valid i ( string address ) { if ( address . length ( ) == num ) { return bool ; } int octet ; int octets = num ; string temp = address + str ; int pos ; int start = num ; while ( start < temp . length ( ) && ( pos = temp . index of ( str , start ) ) > start ) { if ( octets == num ) { return bool ; } try { octet = integer . parse int ( temp . substring ( start , pos ) ) ; } catch ( number format exception ex ) { return bool ; } if ( octet < num || octet > num ) { return bool ; } start = pos + num ; octets ++ ; } return octets == num ; }	validate the given ipv4 address .
private void validate dimension csv ( schema info schema info , string fact table name , string dim table name , carbon file dim file , string partition id , carbon data load schema schema , string delimiter ) throws data loading exception { string [ ] column names = get dim column names ( schema info , fact table name , dim table name , partition id , schema ) ; if ( null == column names || column names . length < num ) { return ; } if ( ! check all columns present ( column names , dim file . get absolute path ( ) , delimiter ) ) { logger . error ( str + str + dim file . get name ( ) ) ; throw new data loading exception ( data processor constants . csv validation errror code , str + str + dim file . get name ( ) ) ; } }	validate the dimension csv files .
public boolean remove tuple ( tuple t ) { table table = t . get table ( ) ; if ( m sets . contains ( table ) ) { return table . remove tuple ( t ) ; } else { return bool ; } }	removes the tuple from its source set if that source set is contained within this composite .
private boolean is dark theme set ( ) { shared preferences shared preferences = preference manager . get default shared preferences ( get activity ( ) ) ; string key = get string ( r . string . theme preference key ) ; string default value = get string ( r . string . theme preference default value ) ; return integer . value of ( shared preferences . get string ( key , default value ) ) != num ; }	returns , whether the app uses the dark theme , or not .
@ deprecated public void add prefix ns ( string prefix , string ns uri ) { if ( ns uri . length ( ) == num ) { throw new illegal argument exception ( str ) ; } if ( prefix . length ( ) == num ) { throw new illegal argument exception ( str ) ; } if ( prefix . equals ( no ns prefix ) ) { throw new illegal argument exception ( str + prefix + str ) ; } if ( prefix to namespace uri . contains key ( prefix ) ) { throw new illegal argument exception ( str + prefix + str ) ; } if ( namespace uri . contains key ( ns uri ) ) { throw new illegal argument exception ( str + ns uri + str ) ; } if ( prefix . equals ( default namespace prefix ) ) { this . default ns = ns uri ; } else { prefix to namespace uri . put ( prefix , ns uri ) ; namespace uri . put ( ns uri , prefix ) ; } }	this is used internally .
protected message create response message ( ) { return new message ( num , version . current ) ; }	by default just create a normal one part msg.
public static void o ( double a ) { o ( a , parameters . output field width , parameters . output frac places ) ; }	prints a double in default e format .
public void write field ( string name , string value ) throws io { if ( name == null ) { throw new illegal argument exception ( str ) ; } out . write bytes ( prefix ) ; out . write bytes ( boundary ) ; out . write bytes ( newline ) ; out . write bytes ( str + name + str ) ; out . write bytes ( newline ) ; out . write bytes ( newline ) ; if ( value != null ) { out . write bytes ( value ) ; } out . write bytes ( newline ) ; out . flush ( ) ; }	writes a string field value .
public int drain to ( collection < ? super e > c ) { int result = buffer . drain to ( c ) ; if ( producer != null ) { producer . wake up ( ) ; } return result ; }	removes all available elements from this queue and adds them to the given collection.
protected void grow ( ) { if ( dists == empty dists ) { dists = new double [ initial size ] ; ids = new int [ initial size ] ; return ; } final int len = dists . length ; final int newlength = len + ( len > > num ) ; double [ ] odists = dists ; dists = new double [ newlength ] ; system . arraycopy ( odists , num , dists , num , odists . length ) ; int [ ] oids = ids ; ids = new int [ newlength ] ; system . arraycopy ( oids , num , ids , num , oids . length ) ; }	grow the data storage .
igfs input stream impl ( igfs context igfs ctx , igfs path path , @ nullable igfs entry info file info , int prefetch blocks , int seq reads before prefetch , @ nullable igfs secondary file system positioned readable sec reader , long len , int block size , long blocks cnt , boolean proxy ) { assert igfs ctx != null ; assert path != null ; this . igfs ctx = igfs ctx ; this . path = path ; this . file info = file info ; this . prefetch blocks = prefetch blocks ; this . seq reads before prefetch = seq reads before prefetch ; this . sec reader = sec reader ; this . len = len ; this . block size = block size ; this . blocks cnt = blocks cnt ; this . proxy = proxy ; log = igfs ctx . kernal context ( ) . log ( igfs input stream . class ) ; max loc cache size = ( prefetch blocks > num ? prefetch blocks : num ) * num / num ; loc cache = new linked hash map < > ( max loc cache size , num ) ; pending futs = new grid concurrent hash set < > ( prefetch blocks > num ? prefetch blocks : num ) ; igfs ctx . metrics ( ) . increment files opened for read ( ) ; }	constructs file output stream .
public abstract scale out client index view ( final abstract scale out federation fed , final string name , final long timestamp , final i metadata index ) { if ( fed == null ) throw new illegal argument exception ( ) ; if ( name == null ) throw new illegal argument exception ( ) ; if ( metadata index == null ) throw new illegal argument exception ( ) ; this . fed = fed ; this . name = name ; this . timestamp = timestamp ; this . metadata index = metadata index ; this . metadata index metadata = metadata index . get index metadata ( ) ; final abstract client < ? > client = fed . get client ( ) ; this . capacity = client . get default range query capacity ( ) ; this . batch only = client . get batch api only ( ) ; this . task timeout = client . get task timeout ( ) ; this . read consistent = client . is read consistent ( ) ; }	create a view on a scale - out index .
public boolean can send event ( ) { try { validate send event ( ) ; return bool ; } catch ( exception e ) { return bool ; } }	returns true if connectemc is configured and it is control node .
public static final string capitalize ( string str , char ... delimiters ) { final int delim len = delimiters == null ? - num : delimiters . length ; if ( text utils . is empty ( str ) || delim len == num ) { return str ; } final char [ ] buffer = str . to char array ( ) ; boolean capitalize next = bool ; for ( int i = num ; i < buffer . length ; i ++ ) { char ch = buffer [ i ] ; if ( is delimiter ( ch , delimiters ) ) { capitalize next = bool ; } else if ( capitalize next ) { buffer [ i ] = character . to title case ( ch ) ; capitalize next = bool ; } } return new string ( buffer ) ; }	capitalizes the first character in a string.
public void test compare to neg zero ( ) { byte a bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num , num , num , num , num } ; int a sign = - num ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = big integer . zero ; assert equals ( - num , a number . compare to ( b number ) ) ; }	compareto ( biginteger a ).
public void write ( output stream out ) throws socks exception , io { if ( data == null ) { socks5 message msg ; if ( addr type == socks atyp domainname ) msg = new socks5 message ( command , host , port ) ; else { if ( ip == null ) { try { ip = inet address . get by name ( host ) ; } catch ( unknown host exception uh ex ) { throw new socks exception ( socks constants . socks just error ) ; } } msg = new socks5 message ( command , ip , port ) ; } data = msg . data ; } out . write ( data ) ; }	writes the message to the stream .
public static byte [ ] compress for zlib ( byte [ ] bytes to compress ) { deflater deflater = new deflater ( ) ; deflater . set input ( bytes to compress ) ; deflater . finish ( ) ; byte [ ] bytes compressed = new byte [ short . max value ] ; int number of bytes after compression = deflater . deflate ( bytes compressed ) ; byte [ ] return values = new byte [ number of bytes after compression ] ; system . arraycopy ( bytes compressed , num , return values , num , number of bytes after compression ) ; return return values ; }	zlib compress 2 byte.
private static byte buffer generate wav data ( int sample count , int freq hz ) { final int num data bytes = sample count * num channels * bits per sample / num ; final double freq = freq hz ; byte buffer buf = byte buffer . allocate ( num data bytes ) ; buf . order ( byte order . little endian ) ; if ( bits per sample == num ) { final double peak = num ; for ( int i = num ; i < sample count ; i ++ ) { double time sec = i / ( double ) sample rate ; double sin value = math . sin ( num * math . pi * freq * time sec ) ; if ( game surface renderer . extra check ) { int output = ( int ) ( peak * sin value + num ) ; if ( output < num || output >= num ) { throw new runtime exception ( str ) ; } } buf . put ( ( byte ) ( peak * sin value + num ) ) ; } } else if ( bits per sample == num ) { final double peak = num ; short buffer sbuf = buf . as short buffer ( ) ; for ( int i = num ; i < sample count ; i ++ ) { double time sec = i / ( double ) sample rate ; double sin value = math . sin ( num * math . pi * freq * time sec ) ; sbuf . put ( ( short ) ( peak * sin value ) ) ; } } buf . position ( num ) ; return buf ; }	generates the raw wav - compatible audio data .
protected static string h2c ( string hyphenated , boolean studly ) { string builder b = new string builder ( hyphenated . length ( ) ) ; boolean cap next = studly ; for ( int i = num ; i < hyphenated . length ( ) ; ++ i ) { char c = hyphenated . char at ( i ) ; if ( c == str ) cap next = bool ; else { b . append ( cap next ? character . to upper case ( c ) : c ) ; cap next = bool ; } } return b . to string ( ) ; }	convert hyphenated to studlycaps or camelcase.
public synchronized void on write event ( ) throws io { lrmi trace = null ; try { while ( ! contexts . is empty ( ) ) { context current = contexts . peek ( ) ; trace = current . get trace ( ) ; if ( trace != null ) lrmi . update context ( trace , null , null , null , null , bool , null , null ) ; none blocking write ( current ) ; if ( current . get phase ( ) != context . phase . finish ) { set write interest ( ) ; break ; } else { trace context total write time ( current ) ; contexts . poll ( ) ; pending writes . decrement ( ) ; } } if ( contexts . is empty ( ) ) { remove write interest ( bool ) ; } } finally { if ( trace != null ) lrmi . reset context ( ) ; } }	called from writeselectorthread to complete pending write requests . this is synchronized to ensure mutual exclusion with writebytestochannelnoneblocking method.
public static void add ( object spy ) { spies . add ( spy ) ; }	add a new spy .
void init leaf calc ( byte [ ] seed0 ) { this . i = num ; this . j = num ; byte [ ] dummy = new byte [ mdsize ] ; system . arraycopy ( seed0 , num , dummy , num , seed . length ) ; this . seed = gmss random . next seed ( dummy ) ; }	initialize the distributed leaf calculation reset i , j and compute otsseed with seed0.
@ override public boolean download file ( string path , string dest ) { try { file output stream fos = new file output stream ( new file ( dest ) ) ; m db . get file ( path , null , fos , null ) ; fos . close ( ) ; return bool ; } catch ( dropbox exception e ) { e . print stack trace ( ) ; return bool ; } catch ( file not found exception e ) { e . print stack trace ( ) ; return bool ; } catch ( io e ) { e . print stack trace ( ) ; return bool ; } }	downloads a file from the dropbox to a given location.
boolean does occur ( q ref name ) { return m refs . contains ( ref name ) ; }	tell if the given qualified name occurs in the list of qualified names collected .
public static date format to date format ( string date format , time zone tz , locale locale ) { date format df = null ; if ( util validate . is empty ( date format ) ) { df = date format . get date instance ( date format . short , locale ) ; } else { df = new simple date format ( date format , locale == null ? locale . get default ( ) : locale ) ; } df . set time zone ( tz ) ; return df ; }	returns an initialized dateformat object .
public integer load id name values ( db output statement statement , integer idx ) throws exception { int index = idx . int value ( ) ; if ( logger . is debug enabled ( ) ) logger . debug ( str ) ; id = statement . get long integer ( index ++ ) ; name = statement . get short text ( index ++ ) ; return new integer ( index ) ; }	recupera de la base de datos el identificador y el nombre del usuario .
private byte [ ] pad password ( byte [ ] password ) { if ( password == null ) { password = new byte [ num ] ; } byte [ ] padded = new byte [ num ] ; final int num contributing password bytes = password . length > padded . length ? padded . length : password . length ; system . arraycopy ( password , num , padded , num , num contributing password bytes ) ; if ( password . length < padded . length ) { system . arraycopy ( pw padding , num , padded , password . length , padded . length - password . length ) ; } return padded ; }	pad a password as per step 1 of algorithm 3.
public final int move made ( long now , boolean use increment ) { stop timer ( now ) ; array list < time control field > tc = tc data . get tc ( white to move ) ; pair < integer , integer > tc info = get current tc ( white to move ) ; int tc idx = tc info . first ; int moves to tc = tc info . second ; int remaining = get remaining time ( white to move , now ) ; if ( use increment ) { remaining += tc . get ( tc idx ) . increment ; if ( moves to tc == num ) { if ( tc idx + num < tc . size ( ) ) tc idx ++ ; remaining += tc . get ( tc idx ) . time control ; } } elapsed = num ; return remaining ; }	compute new remaining time after a move is made .
public static properties prefix properties ( properties props , string prefix ) { properties prefix props = new properties ( ) ; for ( string key : props . string property names ( ) ) { if ( key . starts with ( prefix ) ) { string key without prefix = key . substring ( prefix . length ( ) ) ; prefix props . set property ( key without prefix , props . get property ( key ) ) ; } } return prefix props ; }	extract only the properties that match a prefix , and with the prefix removed .
public final void test set regex ( ) { regex constraint regex constraint = new regex constraint ( pattern . compile ( str ) ) ; regex constraint . set regex ( regex ) ; assert equals ( regex , regex constraint . get regex ( ) ) ; }	tests the functionality of the method , which allows to set the regular expression .
public synchronized void start ( ) { if ( is started ) { return ; } if ( is stopped ) { throw new illegal state exception ( str ) ; } logger . info ( str + tor . get full version ( ) + str ) ; verify unlimited strength policy installed ( ) ; directory downloader . start ( directory ) ; circuit manager . start building circuits ( ) ; if ( dashboard . is enabled by property ( ) ) { dashboard . start listening ( ) ; } is started = bool ; }	start running the tor client service .
public static cipher parameters make pbe ( pbe key spec , int type , int hash , int key size , int iv size ) { pbe generator = make pbe ( type , hash ) ; byte [ ] key ; cipher parameters param ; key = convert password ( type , key spec ) ; generator . init ( key , key spec . get salt ( ) , key spec . get iteration count ( ) ) ; if ( iv size != num ) { param = generator . generate derived parameters ( key size , iv size ) ; } else { param = generator . generate derived parameters ( key size ) ; } for ( int i = num ; i != key . length ; i ++ ) { key [ i ] = num ; } return param ; }	construct a key and iv ( if necessary ) suitable for use with a cipher .
@ override public double value ( int att index ) { int index = locate index ( att index ) ; if ( ( index >= num ) && ( m [ index ] == att index ) ) { return num ; } else { return num ; } }	returns an instance ' s attribute value in internal format .
private void fetch filter seeds ( ) { if ( seed list == null || seed list . is empty ( ) ) { return ; } for ( iterator < uri > it = seed list . iterator ( ) ; it . has next ( ) ; ) { uri seed = it . next ( ) ; for ( fetch filter filter : controller . get fetch filters ( ) ) { fetch status filter reason = filter . check filter ( seed ) ; if ( filter reason != fetch status . valid ) { if ( log . is debug enabled ( ) ) { log . debug ( str + seed + str + filter reason ) ; } it . remove ( ) ; break ; } } } }	filters the seed list using the current fetch filters , preventing any non - valid seed from being accessed .
public xy ( xy label generator , xyurl url generator ) { super ( ) ; this . show outline = bool ; set base tool tip generator ( label generator ) ; set url ( url generator ) ; general path area = new general path ( ) ; area . move to ( num , - num ) ; area . line to ( num , - num ) ; area . line to ( num , num ) ; area . line to ( - num , num ) ; area . line to ( - num , - num ) ; area . close path ( ) ; this . legend area = area ; }	constructs a new renderer .
public static boolean is primitive or wrapper ( class < ? > clazz ) { assert . not null ( clazz , str ) ; return ( clazz . is primitive ( ) || is primitive wrapper ( clazz ) ) ; }	check if the given class represents a primitive ( i.
private void assert file contains ( list < string > expected , string filename ) throws exception { try ( buffered reader reader = new buffered reader ( new file reader ( filename ) ) ) { list < string > actual = new array list < > ( ) ; for ( ; ; ) { string line = reader . read line ( ) ; if ( line == null ) { break ; } actual . add ( line ) ; } assert equals ( expected , actual ) ; } }	assert that a file contains the lines provided , in the same order as expected .
private void report exception ( kind kind , element element , throwable t ) { string writer buf = new string writer ( ) ; t . print stack trace ( new print writer ( buf ) ) ; buf . to string ( ) ; message ( kind , element , str , buf . to string ( ) ) ; }	bugs in an annotation processor can cause silent failure so try to report any exception throws as errors .
public void add ( string [ ] titles , double [ ] values ) { add ( m categories . size ( ) + str , titles , values ) ; }	adds a new value to the series .
static string parse authority ( string uri string , int ssi ) { int length = uri string . length ( ) ; if ( length > ssi + num && uri string . char at ( ssi + num ) == str && uri string . char at ( ssi + num ) == str ) { int end = ssi + num ; loop : while ( end < length ) { switch ( uri string . char at ( end ) ) { case str : case str : case str : break loop ; } end ++ ; } return uri string . substring ( ssi + num , end ) ; } else { return null ; } }	parses an authority out of the given uri string .
public static void sort ( list < ? > list ) { if ( list . size ( ) > num ) { collections . sort ( list , instance ) ; } }	sort the given list with a default annotationawareordercomparator.
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public void add datatransfer progress listener ( on datatransfer progress listener listener , oc oc upload ) { if ( oc upload == null || listener == null ) return ; string target key = build remote name ( oc upload . get account name ( ) , oc upload . get remote path ( ) ) ; m bound listeners . put ( target key , listener ) ; }	adds a listener interested in the progress of the upload for a concrete file .
protected string [ ] read next ( line number reader reader ) throws io { string [ ] row def = null ; do { string next line = reader . read line ( ) ; if ( next line == null ) { has next = bool ; return row def ; } string [ ] r = parser . parse line multi ( next line ) ; if ( r . length > num ) { if ( row def == null ) { row def = r ; } else { string [ ] t = new string [ row def . length + r . length ] ; system . arraycopy ( row def , num , t , num , row def . length ) ; system . arraycopy ( r , num , t , row def . length , r . length ) ; row def = t ; } } } while ( parser . is pending ( ) ) ; return row def ; }	load the next set of csv values from the file.
private void verify property source value ( reloadable property source reloadable property source , string expected value ) { logger . debug ( str + test key + str + expected value ) ; logger . debug ( str + properties . get ( test key ) + str + reloadable property source . get property ( test key ) ) ; string value = ( string ) reloadable property source . get property ( test key ) ; assert equals ( expected value , value ) ; }	reads the test key from the reloadable property source and verifies that it is set to the specified expected value .
private void update center panel ( ) { long now = system . current time millis ( ) ; if ( next update time > now ) return ; next update time = now + num * num ; center panel . remove all ( ) ; center component = new j ( ) ; grid bag constraints gbc = new grid bag constraints ( ) ; gbc . gridx = num ; gbc . gridy = num ; gbc . weightx = num ; gbc . fill = grid bag constraints . none ; gbc . anchor = grid bag constraints . center ; center panel . add ( center component , gbc ) ; refresh ( ) ; }	updates the center panel if non - pro.
public void service request queue ( ) throws cli { if ( is verbose ( ) ) { output writer . println message ( rb messages . get string ( str ) ) ; } try { while ( ! request queue . is empty ( ) ) { cli req = ( cli ) request queue . remove ( num ) ; try { req . process ( this ) ; if ( status os != null ) { string status = format status ( req . get options ( ) , num ) ; status os . write ( status . get bytes ( ) ) ; } } catch ( cli e ) { if ( is verbose ( ) ) { e . print stack trace ( system . out ) ; } if ( status os != null ) { string status = format status ( req . get options ( ) , e . get exit code ( ) ) ; status os . write ( status . get bytes ( ) ) ; } if ( b continue ) { output writer . println error ( e . get message ( ) ) ; } else { throw e ; } } } } catch ( io e ) { throw new cli ( e , exit codes . request cannot be processed ) ; } finally { if ( status os != null ) { try { status os . close ( ) ; } catch ( io ex ) { } status os = null ; } } }	services the request queue .
always identical key store state ( ) { super ( ) ; }	create an empty state .
public static byte [ ] pack byte buffer into single byte array ( byte buffer [ ] byte buffer arr ) { if ( null == byte buffer arr || byte buffer arr . length == num ) { return null ; } int no of col = byte buffer arr . length ; short offset len = ( short ) ( no of col * num ) ; int total bytes = calculate total bytes ( byte buffer arr ) + offset len ; byte buffer buffer = byte buffer . allocate ( total bytes ) ; buffer . put short ( offset len ) ; for ( int index = num ; index < byte buffer arr . length - num ; index ++ ) { byte buffer individual col = byte buffer arr [ index ] ; int no of bytes = individual col . capacity ( ) ; buffer . put short ( ( short ) ( offset len + no of bytes ) ) ; offset len += no of bytes ; individual col . rewind ( ) ; } for ( int index = num ; index < byte buffer arr . length ; index ++ ) { byte buffer individual col = byte buffer arr [ index ] ; buffer . put ( individual col . array ( ) ) ; } buffer . rewind ( ) ; return buffer . array ( ) ; }	this method will form one single byte [ ] for all the high card dims . first it will add all the indexes of variable length byte [ ] and then the actual value.
public void stop ( ) { m cancel = bool ; if ( m running . compare and set ( bool , bool ) ) { if ( m sample dispatcher task != null ) { m thread pool manager . cancel ( m sample dispatcher task ) ; m sample dispatcher task = null ; m filled buffers . clear ( ) ; } } }	stops the sample fetching thread.
public void add ( simple name ref ) { string type name = ref . get identifier ( ) ; if ( f imports added . contains ( type name ) ) { return ; } i binding = ref . resolve binding ( ) ; if ( binding != null ) { if ( binding . get kind ( ) != i . type ) { return ; } i type binding = ( i ) binding ; if ( type binding . is array ( ) ) { type binding = type binding . get element type ( ) ; } type binding = type binding . get type declaration ( ) ; if ( ! type binding . is recovered ( ) ) { if ( needs import ( type binding , ref ) ) { f imp structure . add import ( type binding ) ; f imports added . add ( type name ) ; } return ; } } else { if ( f do ignore lower case names && type name . length ( ) > num ) { char ch = type name . char at ( num ) ; if ( strings . is lower case ( ch ) && character . is letter ( ch ) ) { return ; } } } f imports added . add ( type name ) ; f unresolved types . put ( type name , new unresolved type data ( ref ) ) ; }	tries to find the given type name and add it to the import structure .
private static boolean check font ( string font name , string new name , string test string , boolean force ) { boolean displayable = bool ; font f = ui . get font ( font name ) ; if ( f != null && ! new name . equals ignore case ( f . get name ( ) ) ) { if ( ! gui . can display ( f , test string ) || force ) { f = new font ( new name , f . get style ( ) , f . get size ( ) ) ; if ( gui . can display ( f , test string ) ) ui . put ( font name , f ) ; else displayable = bool ; } } else if ( f != null ) { displayable = gui . can display ( f , test string ) ; } else { displayable = bool ; } return displayable ; }	updates the font of a given fontname to be newname .
public void add all searchables ( array list < ? extends search result > searchable ) { m searchable list . add all ( searchable ) ; }	add all searchable items.
public list < value box > add argument hotspots ( string signature , int arg ) { list < value box > sig spots = string analysis . get argument expressions ( signature , arg ) ; return add argument hotspots ( signature , arg , sig spots ) ; }	add a hotspot for matching calls .
public boolean is full ( ) { return counter . get ( ) == q size ; }	is queue is full .
public static string jq ( string request ) throws exception { int query start pos = request . index of ( str ) ; string query ; string path ; if ( - num == query start pos ) { query = str ; path = request ; } else { query = request . substring ( query start pos + num ) ; path = request . substring ( num , query start pos ) ; } query = set param ( query , str , str ) ; request = path + str + set param ( query , str , str ) ; string response ; boolean failed = bool ; try { response = rest test harness . query ( request ) ; failed = bool ; } finally { if ( failed ) { log . error ( str + request ) ; } } return response ; }	makes a query request and returns the json string response.
protected void shift end ( int new size ) { int old size = get array length ( ) ; int old gap end = g1 ; int upper size = old size - old gap end ; int array length = get new array size ( new size ) ; int new gap end = array length - upper size ; resize ( array length ) ; g1 = new gap end ; if ( upper size != num ) { system . arraycopy ( array , old gap end , array , new gap end , upper size ) ; } }	make the gap bigger , moving any necessary data and updating the appropriate marks.
public sam filter chain ( collection < sam filter > filters ) { m filters = filters . to array ( new sam filter [ filters . size ( ) ] ) ; }	construct a chain of sam filters.
previous word action ( string nm , boolean select ) { super ( nm ) ; this . select = select ; }	create this action with the appropriate identifier .
static unix stream < string > cat ( final string file path ) throws io { objects . require non null ( file path , str ) ; return new unix stream impl < > ( lines ( paths . get ( file path ) ) ) ; }	create a new unixstream of lines of the given file .
private static string encode base64 ( byte d [ ] , int len ) throws illegal argument exception { int off = num ; string buffer rs = new string buffer ( ) ; int c1 , c2 ; if ( len <= num || len > d . length ) { throw new illegal argument exception ( str ) ; } while ( off < len ) { c1 = d [ off ++ ] & num ; rs . append ( base64 code [ ( c1 > > num ) & num ] ) ; c1 = ( c1 & num ) << num ; if ( off >= len ) { rs . append ( base64 code [ c1 & num ] ) ; break ; } c2 = d [ off ++ ] & num ; c1 |= ( c2 > > num ) & num ; rs . append ( base64 code [ c1 & num ] ) ; c1 = ( c2 & num ) << num ; if ( off >= len ) { rs . append ( base64 code [ c1 & num ] ) ; break ; } c2 = d [ off ++ ] & num ; c1 |= ( c2 > > num ) & num ; rs . append ( base64 code [ c1 & num ] ) ; rs . append ( base64 code [ c2 & num ] ) ; } return rs . to string ( ) ; }	encode a byte array using bcrypt ' s slightly - modified base64 encoding scheme.
protected void eleminate redundent ( elem template element psuedo var recipient , vector paths ) { int n = paths . size ( ) ; int num paths eliminated = num ; int num unique paths eliminated = num ; for ( int i = num ; i < n ; i ++ ) { expression owner owner = ( expression owner ) paths . element at ( i ) ; if ( null != owner ) { int found = find and eliminate redundant ( i + num , i , owner , psuedo var recipient , paths ) ; if ( found > num ) num unique paths eliminated ++ ; num paths eliminated += found ; } } eleminate shared partial paths ( psuedo var recipient , paths ) ; if ( diagnose num paths reduced ) diagnose num paths ( paths , num paths eliminated , num unique paths eliminated ) ; }	method to be called after the all expressions within an node context have been visited.
public void commercial result ( string stream , string result text , request result result ) { set commercial result ( date time . current time ( ) + str + result text ) ; last commercial run attempt = system . current time millis ( ) ; set loading commercial ( bool ) ; if ( result == twitch api . request result . running commercial ) { last commercial . put ( stream , system . current time millis ( ) ) ; if ( stream != null && stream . equals ( current channel ) ) { last commercial run = system . current time millis ( ) ; } } }	the commercial result as returned from the api.
public void done ( ) throws io { if ( ! initial styles ) { write initial styles ( ) ; initial styles = bool ; } out . write u ( num , num ) ; out . flush bits ( ) ; if ( bout != null && glyph count > num ) { byte [ ] glyph bytes = bout . to byte array ( ) ; glyph byte arrays . add ( glyph bytes ) ; } if ( glyph count > num ) { bout = new byte array output stream ( ) ; out = new out stream ( bout ) ; glyph count -- ; fill1 index = num ; line index = num ; outstanding changes = bool ; initial styles = bool ; } else { if ( bout != null ) { finish font ( ) ; } writer . complete tag ( ) ; } }	description of the method.
private static iso check detach iso ( iso detach iso ) throws rpc exception { logger . info ( str , detach iso ) ; switch ( detach iso . get result ( ) ) { case ok : break ; case iso not attached : logger . warn ( str , detach iso ) ; throw new iso not attached exception ( detach iso . get error ( ) ) ; case system error : logger . warn ( str , detach iso ) ; throw new system error exception ( detach iso . get error ( ) ) ; case vm not found : logger . warn ( str , detach iso ) ; throw new vm not found exception ( detach iso . get error ( ) ) ; default : throw new rpc exception ( string . format ( str , detach iso . get result ( ) ) ) ; } return detach iso ; }	this method validates a detachisoresponse object , raising an exception if the response reflects an operation failure .
public boolean is terminal ( method or method context mc ) { stack < soot method > sys stack = new stack < soot method > ( ) ; boolean result ; if ( ! is system ( mc . method ( ) ) ) result = bool ; else { if ( ! process callbacks ) result = bool ; else { if ( ( stack . size ( ) > num ) && is system ( stack . peek ( ) ) ) result = ! calls app method ( mc , sys stack ) ; else { if ( can have callbacks ( mc . method ( ) ) ) result = ! calls app method ( mc , sys stack ) ; else result = bool ; } } } logger . info ( str , mc . method ( ) , result ) ; return result ; }	returns true if the specified method should terminate the call graph the call graph is terminated on system calls that do not have callbacks into application code .
boolean try match ( s s ) { if ( match == null && unsafe . compare and swap object ( this , match offset , null , s ) ) { thread w = waiter ; if ( w != null ) { waiter = null ; lock support . unpark ( w ) ; } return bool ; } return match == s ; }	tries to match node s to this node , if so , waking up thread.
public void add item ( int position , m model ) { m datas . add ( position , model ) ; notify item inserted ( position ) ; }	insert data for position.
public final set < string > aliases ( ) { return collections . unmodifiable set ( this . aliases set ) ; }	returns an unmodifiable set of this charset ' s aliases .
public void encode ( output stream out ) throws io { der output stream tmp = new der output stream ( ) ; if ( this . extension value == null ) { this . extension id = pkix . issuing distribution point id ; this . critical = bool ; encode this ( ) ; } super . encode ( tmp ) ; out . write ( tmp . to byte array ( ) ) ; }	encodes the issuing distribution point extension and writes it to the deroutputstream .
public final void read children ( object input stream ois ) throws io , class not found exception { int count = serializable ; while ( count -- > num ) { object child = null ; bean context support . bcs bscc = null ; try { child = ois . read object ( ) ; bscc = ( bean context support . bcs ) ois . read object ( ) ; } catch ( io ioe ) { continue ; } catch ( class not found exception cnfe ) { continue ; } synchronized ( child ) { bean context child bcc = null ; try { bcc = ( bean context child ) child ; } catch ( class cast exception cce ) { } if ( bcc != null ) { try { bcc . set bean context ( get bean context peer ( ) ) ; bcc . add property change listener ( str , child pcl ) ; bcc . add vetoable change listener ( str , child vcl ) ; } catch ( property veto exception pve ) { continue ; } } child deserialized hook ( child , bscc ) ; } } }	when an instance of this class is used as a delegate for the implementation of the beancontext protocols ( and its subprotocols ) there exists a ' chicken and egg ' problem during deserialization.
static boolean is christmas time ( calendar cal ) { int month = cal . get ( calendar . month ) ; int day = cal . get ( calendar . day of month ) ; if ( month >= num && month < num ) { return bool ; } if ( month == num ) { return day <= num ; } if ( month == num ) { return day >= num ; } return bool ; }	checks whether now is christmas time.
@ override public void zoom range axes ( double factor , plot rendering info info , d source ) { zoom range axes ( factor , info , source , bool ) ; }	multiplies the range on the range axis / axes by the specified factor .
private void board save image ( ) { if ( curfile image == null ) { board save as image ( ) ; return ; } j wait d = new j ( frame , messages . get string ( str ) ) ; wait d . add ( new j ( messages . get string ( str ) ) ) ; wait d . set size ( num , num ) ; wait d . set location ( ( frame . get size ( ) . width / num ) - ( wait d . get size ( ) . width / num ) , ( frame . get size ( ) . height / num ) - ( wait d . get size ( ) . height / num ) ) ; wait d . set visible ( bool ) ; frame . set cursor ( cursor . get predefined cursor ( cursor . wait cursor ) ) ; wait d . set cursor ( cursor . get predefined cursor ( cursor . wait cursor ) ) ; try { io . write ( bv . get entire board image ( ) , str , curfile image ) ; } catch ( io e ) { e . print stack trace ( ) ; } wait d . set visible ( bool ) ; frame . set cursor ( cursor . get default cursor ( ) ) ; }	saves the board in png image format .
public boolean contains name ( string type , string name ) { list < string > names = get names ( type ) ; return names . contains ( name ) ; }	determines if a car type can have a specific load name .
@ suppress warnings ( str ) public static < c extends result > array list < c > filter results ( result hierarchy hier , result r , class < ? super c > restriction class ) { array list < c > res = new array list < > ( ) ; if ( restriction class . is instance ( r ) ) { res . add ( ( c ) restriction class . cast ( r ) ) ; } for ( hierarchy . iter < result > iter = hier . iter descendants ( r ) ; iter . valid ( ) ; iter . advance ( ) ) { result result = iter . get ( ) ; if ( restriction class . is instance ( result ) ) { res . add ( ( c ) restriction class . cast ( result ) ) ; } } return res ; }	return only results of the given restriction class.
@ pure @ causes error ( { j . class , pure method parameter not immutable exception . class } ) public string test param1 bad ( object in1 , object in2 ) { object in3 = in2 ; j . immutable ( in1 , in2 ) ; return in3 . to string ( ) ; }	not going to be pure as we do something before checking.
protected boolean [ ] can handle missing ( boolean nominal predictor , boolean numeric predictor , boolean string predictor , boolean date predictor , boolean relational predictor , boolean multi instance , int class type , boolean predictor missing , boolean class missing , int missing level ) { if ( missing level == num ) { print ( str ) ; } print ( str ) ; if ( predictor missing ) { print ( str ) ; if ( class missing ) { print ( str ) ; } } if ( class missing ) { print ( str ) ; } print ( str ) ; print attribute summary ( nominal predictor , numeric predictor , string predictor , date predictor , relational predictor , multi instance , class type ) ; print ( str ) ; array list < string > accepts = new array list < string > ( ) ; accepts . add ( str ) ; accepts . add ( str ) ; accepts . add ( str ) ; accepts . add ( str ) ; int num train = get num instances ( ) , num classes = num ; return run basic test ( nominal predictor , numeric predictor , string predictor , date predictor , relational predictor , multi instance , class type , missing level , predictor missing , class missing , num train , num classes , accepts ) ; }	checks basic missing value handling of the scheme.
public set < brd item > pick items ( pla point p location , int p layer , item selection filter p filter ) { set < brd item > result = new tree set < brd item > ( ) ; shape tile box point shape = p location . to box ( ) ; collection < awtree object > overlaps = overlapping objects ( point shape , p layer ) ; for ( awtree object curr object : overlaps ) { if ( ! ( curr object instanceof brd item ) ) continue ; brd item curr item = ( brd item ) curr object ; if ( ! curr item . is selected by filter ( p filter ) ) continue ; result . add ( curr item ) ; } return result ; }	returns the list of items on the board , whose shape on layer p_layer contains the point at p_location.
public boolean is collinear with ( vector other ) { if ( x == num && y == num && z == num ) { return bool ; } final double other x = other . x ; final double other y = other . y ; final double other z = other . z ; if ( other x == num && other y == num && other z == num ) { return bool ; } if ( ( x == num ) != ( other x == num ) ) return bool ; if ( ( y == num ) != ( other y == num ) ) return bool ; if ( ( z == num ) != ( other z == num ) ) return bool ; final double quotient x = other x / x ; if ( ! double . is na n ( quotient x ) ) { return other . equals ( multiply ( quotient x ) ) ; } final double quotient y = other y / y ; if ( ! double . is na n ( quotient y ) ) { return other . equals ( multiply ( quotient y ) ) ; } final double quotient z = other z / z ; if ( ! double . is na n ( quotient z ) ) { return other . equals ( multiply ( quotient z ) ) ; } throw new runtime exception ( str ) ; }	returns whether this vector is collinear with another vector .
public void receive ( float [ ] current fft ) { if ( float . is infinite ( current fft [ num ] ) || float . is na n ( current fft [ num ] ) ) { current fft = new float [ current fft . length ] ; } if ( m display fft == null || m display fft . length != current fft . length ) { m display fft = current fft ; } float [ ] smoothed bins = m smoothing filter . filter ( current fft ) ; if ( m averaging > num ) { float gain = num / ( float ) m averaging ; for ( int x = num ; x < m display fft . length ; x ++ ) { m display fft [ x ] += ( smoothed bins [ x ] - m display fft [ x ] ) * gain ; } } else { m display fft = smoothed bins ; } repaint ( ) ; }	dftresultslistener interface for receiving the processed data to display.
@ override public void execution unit imported ( final execution unit process , final element element ) { node list children = element . get child nodes ( ) ; children = element . get child nodes ( ) ; for ( int i = num ; i < children . get length ( ) ; i ++ ) { node child = children . item ( i ) ; if ( child instanceof element ) { element background element = ( element ) child ; if ( xml tag background . equals ( background element . get tag name ( ) ) ) { string x str = background element . get attribute ( xml attribute x position ) ; string y str = background element . get attribute ( xml attribute y position ) ; string w str = background element . get attribute ( xml attribute width ) ; string h str = background element . get attribute ( xml attribute height ) ; string img loc str = background element . get attribute ( xml attribute location ) ; try { int x loc = integer . parse int ( x str ) ; int y loc = integer . parse int ( y str ) ; int w loc = integer . parse int ( w str ) ; int h loc = integer . parse int ( h str ) ; process background image bg img = new process background image ( x loc , y loc , w loc , h loc , img loc str , process ) ; set background image ( bg img ) ; } catch ( null pointer exception | illegal argument exception e ) { } } } } }	extracts port spacings from the xml element .
private void send mail to queue ( string to , string subject , string content , boolean is multipart , boolean is html ) { email params email params = new email params ( to , subject , content , is multipart , is html ) ; rabbit template . convert and send ( rabbitmq configuration . queue send email , email params ) ; }	send emails via rabbitmq queue.
private set < object instance > filter list of object instances ( set < object instance > list , query exp query ) { if ( query == null ) { return list ; } else { set < object instance > result = new hash set < object instance > ( ) ; for ( object instance oi : list ) { boolean res = bool ; m old server = query eval . get m ( ) ; query . set m ( server ) ; try { res = query . apply ( oi . get object name ( ) ) ; } catch ( exception e ) { res = bool ; } finally { query . set m ( old server ) ; } if ( res ) { result . add ( oi ) ; } } return result ; } }	applies the specified queries to the set of objectinstances .
@ path ( str ) @ timed @ exception metered @ get public automation secret response read secret by id ( @ auth automation client automation client , @ path param ( str ) long param secret id ) { optional < secret > secret = secret controller . get secret by id ( secret id . get ( ) ) ; if ( ! secret . is present ( ) ) { throw new not found exception ( str ) ; } immutable list < group > groups = immutable list . copy of ( acl dao . get groups for ( secret . get ( ) ) ) ; return automation secret response . from secret ( secret . get ( ) , groups ) ; }	retrieve secret by id.
protected void add action exception warning ( exception e ) { string msg = e . get message ( ) ; if ( msg != null ) { warnings . add ( msg ) ; } }	adds an exception message , if not null , to the action warnings .
private void generate field infos ( i type , i type info , hash map new elements , array list children handles ) { i [ ] fields = type info . get fields ( ) ; if ( fields == null ) { return ; } java model manager manager = ( ( java element ) type ) . manager ; for ( int i = num , field count = fields . length ; i < field count ; i ++ ) { i field info = fields [ i ] ; binary field field = new binary field ( ( java element ) type , manager , manager . intern ( new string ( field info . get name ( ) ) ) ) ; new elements . put ( field , field info ) ; children handles . add ( field ) ; generate annotations infos ( field , field info . get annotations ( ) , field info . get tag bits ( ) , new elements ) ; } }	creates the handles and infos for the fields of the given binary type.
public void test formatting year ( ) { format tester test = new format tester ( ) ; calendar cal = new gregorian calendar ( num , calendar . june , num , num , num , num ) ; test . test ( str , cal , str , date format . year field ) ; test . test ( str , cal , str , date format . year field ) ; test . test ( str , new gregorian calendar ( num , calendar . june , num ) , str , date format . year field ) ; test . test ( str , new gregorian calendar ( num , calendar . june , num ) , str , date format . year field ) ; test . test ( str , new gregorian calendar ( num , calendar . june , num ) , str , date format . year field ) ; test . test ( str , cal , str , date format . year field ) ; test . test ( str , cal , str , date format . year field ) ; test . test ( str , cal , str , date format . year field ) ; assert false ( test . tests failed ) ; }	this test assumes unicode behavior where ' y ' and ' yyy ' don ' t truncate , which means that it will fail on the ri .
public list < string > generate model ( string schema , string table , string package name , boolean annotate schema , boolean trim strings ) { try { list < string > models = new . array list ( ) ; list < table inspector > tables = get tables ( schema , table ) ; for ( table inspector t : tables ) { t . read ( meta data ) ; string model = t . generate model ( package name , annotate schema , trim strings ) ; models . add ( model ) ; } return models ; } catch ( sql s ) { throw new runtime exception ( s ) ; } }	generates models class skeletons for schemas and tables.
public static ed25519 encoded field element to encoded field element ( final big integer b ) { return new ed25519 encoded field element ( to byte array ( b ) ) ; }	converts a biginteger to an encoded field element .
protected array list < key name pair > load rma ( int c b id ) { array list < key name pair > list = new array list < key name pair > ( ) ; string sql stmt = str + str + str + str + str + str ; prepared statement pstmt = null ; try { pstmt = db . prepare statement ( sql stmt , null ) ; pstmt . set int ( num , c b id ) ; result set rs = pstmt . execute query ( ) ; while ( rs . next ( ) ) { list . add ( new key name pair ( rs . get int ( num ) , rs . get string ( num ) ) ) ; } rs . close ( ) ; } catch ( sql e ) { log . log ( level . severe , sql stmt . to string ( ) , e ) ; } finally { if ( pstmt != null ) { try { pstmt . close ( ) ; } catch ( exception ex ) { log . severe ( str ) ; } } } return list ; }	load pbartner dependent order / invoice / shipment field .
private void check send track to google ( ) { if ( ! send to google ( activity my tracks . get string ( r . string . export google maps ) ) || ! send to google ( activity my tracks . get string ( r . string . export google fusion tables ) ) || ! send to google ( activity my tracks . get string ( r . string . export google spreadsheets ) ) ) { return ; } assert true ( google utils . delete maps ( activity my tracks . get application context ( ) , google utils . account 1 , end to end test utils . track name ) ) ; assert true ( google utils . delete fusion tables ( activity my tracks . get application context ( ) , google utils . account 1 , end to end test utils . track name ) ) ; assert true ( google utils . delete spreadsheets row ( activity my tracks . get application context ( ) , google utils . account 1 , end to end test utils . track name ) ) ; }	checks the process of sending track to google .
public void on dependency changed ( preference dependency , boolean disable dependent ) { if ( m dependency met == disable dependent ) { m dependency met = ! disable dependent ; notify dependency change ( should disable dependents ( ) ) ; notify changed ( ) ; } }	called when the dependency changes .
@ override public double analyse ( double [ ] frame ) { if ( frame . length != get frame length samples ( ) ) throw new illegal argument exception ( str + get frame length samples ( ) + str + frame . length ) ; double total energy = num ; for ( int i = num ; i < frame . length ; i ++ ) { total energy += frame [ i ] * frame [ i ] ; } remember frame energy ( total energy ) ; return new double ( total energy ) ; }	apply this framebasedanalyser to the given data .
public static element first child element ( element element ) { if ( element == null ) return null ; node node = element . get first child ( ) ; if ( node != null ) { do { if ( node . get node type ( ) == node . element node ) { element child element = ( element ) node ; return child element ; } } while ( ( node = node . get next sibling ( ) ) != null ) ; } return null ; }	return the first child element returns the first element .
private static void partial match ( dimensional node node , boolean [ ] relevant , double [ ] keys , array list < i > results ) { i pt = node . point ; boolean match = bool ; for ( int i = num ; i < relevant . length ; i ++ ) { if ( ! relevant [ i ] ) continue ; if ( ! floating point . same ( pt . get coordinate ( i + num ) , keys [ i ] ) ) { match = bool ; break ; } } if ( match ) { results . add ( pt ) ; } int d = node . dimension ; if ( relevant [ d - num ] ) { if ( floating point . lesser equals ( keys [ d - num ] , pt . get coordinate ( d ) ) ) { dimensional node below = node . get below ( ) ; if ( below != null ) { partial match ( below , relevant , keys , results ) ; } } if ( floating point . greater equals ( keys [ d - num ] , pt . get coordinate ( d ) ) ) { dimensional node above = node . get above ( ) ; if ( above != null ) { partial match ( above , relevant , keys , results ) ; } } } else { dimensional node below = node . get below ( ) ; if ( below != null ) { partial match ( below , relevant , keys , results ) ; } dimensional node above = node . get above ( ) ; if ( above != null ) { partial match ( above , relevant , keys , results ) ; } } }	description of algorithm taken from bentley ' s original paper .
public static string encode for redirect ( final string str ) { string class method = str ; byte [ ] input ; try { input = str . get bytes ( str ) ; } catch ( unsupported encoding exception uee ) { debug . error ( class method + str , uee ) ; return null ; } deflater deflater = new deflater ( deflater . default compression , bool ) ; byte array output stream out = new byte array output stream ( ) ; deflater output stream deflater output stream = new deflater output stream ( out , deflater ) ; try { deflater output stream . write ( input ) ; } catch ( io e ) { debug . error ( class method + str , e ) ; return null ; } finally { io . close if not null ( deflater output stream ) ; } string encoded = url . encode ( base64 . encode ( out . to byte array ( ) ) ) ; if ( debug . message enabled ( ) ) { debug . message ( class method + str + encoded . length ( ) ) ; debug . message ( class method + str + encoded + str ) ; } return encoded ; }	returns the encoded request message.
private void save touch start ( motion event event ) { m saved matrix . set ( m matrix ) ; m touch start point . set ( event . get x ( ) , event . get y ( ) ) ; m closest data set to touch = m chart . get data set by touch point ( event . get x ( ) , event . get y ( ) ) ; }	saves the current matrix state and the touch - start point .
public static boolean is nested mapping ( string regex ) { return regex . starts with ( nested mapping starts symbol ) && regex . ends with ( nested mapping ends symbol ) ; }	returns true if this regex represents a nested mapping , false other cases .
public string to string ( ) { return super . to string ( ) + str + string . value of ( date ) ; }	returns a printable representation of the invalidity date .
private boolean has images ( i action to check ) { return action to check . get image descriptor ( ) != null || action to check . get hover image descriptor ( ) != null || action to check . get disabled image descriptor ( ) != null ; }	returns whether the given action has any images .
public double calc angle between lines ( entry start1 , entry end1 , entry start2 , entry end2 ) { double angle1 = calc angle with ratios ( start1 , end1 ) ; double angle2 = calc angle with ratios ( start2 , end2 ) ; return math . abs ( angle1 - angle2 ) ; }	calculates the angle between two given lines.
public double convert to attrib x ( double scx ) { double temp = m - m ; double temp2 = ( ( scx - m ) * ( m max x - m min x ) ) / temp ; temp2 = temp2 + m min x ; return temp2 ; }	convert a panel x coordinate to a raw x value .
public void complete executor task ( ) { executor queue item item = null ; synchronized ( executor lock ) { executor task count -- ; assert ( executor task count >= num ) ; if ( executor queue head != null ) { item = executor queue head ; executor queue head = item . next ; if ( executor queue head == null ) executor queue tail = null ; } } if ( item != null ) { runnable task = item . get runnable ( ) ; class loader loader = item . get loader ( ) ; boolean is priority = bool ; boolean is queue = bool ; boolean is wake = bool ; schedule impl ( task , loader , max expire , is priority , is queue , is wake ) ; } }	called when an executor task completes.
public static void force mkdir ( file directory ) throws io { if ( directory . exists ( ) ) { if ( ! directory . is directory ( ) ) { string message = str + directory + str + str ; throw new io ( message ) ; } } else { if ( ! directory . mkdirs ( ) ) { if ( ! directory . is directory ( ) ) { string message = str + directory ; throw new io ( message ) ; } } } }	makes a directory , including any necessary but nonexistent parent directories.
private < t > int count cleared refs ( list < weak reference < t > > refs ) { final iterator < weak reference < t > > itr = refs . iterator ( ) ; int n = num ; while ( itr . has next ( ) ) { final weak reference < t > ref = itr . next ( ) ; if ( ref . get ( ) == null ) n ++ ; } return n ; }	return the # of entries in the collection whose references have been cleared .
protected void read image ( ) { ix = read short ( ) ; iy = read short ( ) ; iw = read short ( ) ; ih = read short ( ) ; int packed = read ( ) ; lct flag = ( packed & num ) != num ; interlace = ( packed & num ) != num ; lct size = num << ( packed & num ) ; if ( lct flag ) { lct = read color table ( lct size ) ; act = lct ; } else { act = gct ; if ( bg index == trans index ) bg color = num ; } int save = num ; if ( transparency ) { save = act [ trans index ] ; act [ trans index ] = num ; } if ( act == null ) { status = status format error ; } if ( err ( ) ) return ; decode image data ( ) ; skip ( ) ; if ( err ( ) ) return ; frame count ++ ; image = new buffered image ( width , height , buffered image . type int argb pre ) ; set pixels ( ) ; frames . add ( new gif frame ( image , delay ) ) ; if ( transparency ) { act [ trans index ] = save ; } reset frame ( ) ; }	reads next frame image.
protected void add projected field ( string s ) { try { field f = in clazz . get declared field ( s ) ; type info t = new type info ( f . get name ( ) , class utils . primitive to wrapper ( f . get type ( ) ) ) ; t . getter = pojo utils . create getter ( in clazz , t . name , t . type ) ; t . setter = pojo utils . create setter ( projected clazz , t . name , t . type ) ; projected fields . add ( t ) ; } catch ( no such field exception e ) { throw new runtime exception ( str + s + str + in clazz , e ) ; } }	addprojectedfield : add field details ( name , type , getter and setter ) for field with given name in projectedfields list.
protected object evaluate left greater right ( list elements , string lvalue , string rvalue ) { list array ; if ( elements instanceof java . util . vector ) { array = new java . util . vector ( ) ; } else { array = new array list ( ) ; } for ( iterator e = elements . iterator ( ) ; e . has next ( ) ; ) { object o = e . next ( ) ; if ( o instanceof structured content ) { if ( ( o = evaluate left greater right ( ( structured content ) o , lvalue , rvalue ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == num ) { return ( structured content ) array . get ( num ) ; } return array ; }	override this element to handle testing a predicate expression where lvalue > rvalue.
public optional < double > avg ( ) { if ( is empty ( ) ) return optional . empty ( ) ; return optional . of ( sum ( ) / get event count ( ) ) ; }	return the average of the histogram .
public static boolean is su ( string shell ) { int pos = shell . index of ( str ) ; if ( pos >= num ) { shell = shell . substring ( num , pos ) ; } pos = shell . last index of ( str ) ; if ( pos >= num ) { shell = shell . substring ( pos + num ) ; } return shell . equals ( str ) ; }	attempts to deduce if the shell command refers to a su shell.
private boolean is valid ( int type , string value ) { if ( value == null ) { return bool ; } if ( allowed strings [ type ] != null ) { return verify string group ( value , allowed strings [ type ] ) ; } switch ( type ) { case type number : return verify ( value , digits , null ) ; case type pixels or percentage : if ( value . ends with ( str ) ) { value = value . substring ( num , value . length ( ) - num ) ; } else if ( value . ends with ( str ) ) { value = value . substring ( num , value . length ( ) - num ) ; } return verify ( value , digits , null ) ; case type char : return verify ( value , digits | abc , null , num , num ) ; case type color : if ( value . length ( ) == num ) { return bool ; } if ( value . char at ( num ) != str ) { return verify string group ( value , color strings ) ; } else { return verify ( value . substring ( num ) , hex , null , num , num ) ; } default : return bool ; } }	verifies that the specified value conforms with the attribute ' s type restrictions.
private int parse streams ( string json , set < stream info > stream infos ) { try { json parser = new json ( ) ; json streams array ; try { json root = ( json ) parser . parse ( json ) ; streams array = ( json ) root . get ( str ) ; } catch ( class cast exception ex ) { logger . warning ( str ) ; streams request error ( stream infos ) ; return - num ; } if ( streams array == null ) { logger . warning ( str ) ; streams request error ( stream infos ) ; return - num ; } for ( object obj : streams array ) { if ( obj instanceof json ) { stream info parsed info = parse stream ( ( json ) obj , stream infos == null ) ; if ( parsed info == null ) { logger . warning ( str + ( json ) obj ) ; } if ( stream infos != null ) { stream infos . remove ( parsed info ) ; } } else { logger . warning ( str + obj ) ; } } if ( stream infos != null ) { for ( stream info info : stream infos ) { info . set offline ( ) ; } } return streams array . size ( ) ; } catch ( parse exception ex ) { logger . warning ( str + ex . get localized message ( ) ) ; streams request error ( stream infos ) ; return - num ; } }	parses a list of stream objects.
public str tokenizer reset ( string input ) { reset ( ) ; if ( input != null ) { this . chars = input . to char array ( ) ; } else { this . chars = null ; } return this ; }	zkrestore this tokenizer , giving it a new input string to parse.
public void run test ( ) throws throwable { document doc ; entity reference ent ref ; character data ent text ; doc = ( document ) load ( str , bool ) ; ent ref = doc . create entity reference ( str ) ; assert not null ( str , ent ref ) ; ent text = ( character data ) ent ref . get first child ( ) ; assert not null ( str , ent text ) ; { boolean success = bool ; try { ent text . set node value ( str ) ; } catch ( dom ex ) { success = ( ex . code == dom . no modification allowed err ) ; } assert true ( str , success ) ; } }	runs the test case .
public void remove listener ( final i listener ) { listeners . remove ( listener ) ; }	removes a previously listening listener object .
@ c ( str ) public boolean is large dialog message ( content type content type ) { switch ( content type ) { case service : case service avatar : case service avatar removed : case service created : case service title : case service leave : case service registered : case service kick : case service add : case service joined : case service call ended : case service call missed : case service about : case service topic : return bool ; default : return bool ; } }	if dialog list message need to be wide in group chat as it is already includes performer in it ' s body .
public static boolean is logging behavior enabled ( logging behavior behavior ) { synchronized ( logging behaviors ) { return facebook sdk . is debug enabled ( ) && logging behaviors . contains ( behavior ) ; } }	certain logging behaviors are available for debugging beyond those that should be enabled in production.
private void on attacked ( final entity attacker ) { attackers . remove ( attacker ) ; attackers . add ( attacker ) ; }	when attacker attacks this entity .
private void handle disallow ( parse state state , robot token token ) { if ( state . is skip agents ( ) ) { return ; } state . set finished agent fields ( bool ) ; if ( ! state . is adding rules ( ) ) { return ; } string path = token . get data ( ) ; try { path = url . decode ( path , str ) ; if ( path . length ( ) == num ) { state . clear rules ( ) ; } else { state . add rule ( path , bool ) ; } } catch ( exception e ) { report warning ( str + path , state . get url ( ) ) ; } }	handle the disallow : directive.
public void hide column ( object column name ) { if ( column name == null ) { return ; } for ( int i = num ; i < column model . get column count ( ) ; i ++ ) { table column column = column model . get column ( i ) ; if ( column name . equals ( column . get header value ( ) ) ) { hide column ( column ) ; break ; } } }	hide a column from view in the table .
private boolean is ascii ( char c ) { return ( c >= str && c <= str ) ; }	tell if a character is an ascii digit .
public void accumulate all ( list < api > entities ) throws exception { for ( api entity : entities ) { accumulate ( entity ) ; } }	accumulate a list of entities.
protected void print identifier ( string identifier , string builder ddl ) { ddl . append ( get delimited identifier ( identifier ) ) ; }	prints the given identifier.
public static int darker ( int c ) { return rgba ( math . max ( num , ( int ) ( scale * red ( c ) ) ) , math . max ( num , ( int ) ( scale * green ( c ) ) ) , math . max ( num , ( int ) ( scale * blue ( c ) ) ) , alpha ( c ) ) ; }	get a darker shade of an input color .
private string to string ( final int size ) { if ( size < num ) { return string . format ( str , size ) ; } else if ( size < num * num ) { return string . format ( locale . english , str , num * size / num ) ; } else { return string . format ( locale . english , str , num * size / num / num ) ; } }	creates the section size formatter string depending on the size of the section .
@ known failure ( str ) public void test get columns arbitrary ( ) throws sql { result set set all null = null ; result set set mixed = null ; result set all arbitrary = null ; string [ ] tables name = { database creator . test tabl , database creator . test tabl } ; arrays . sort ( tables name ) ; int set size = num ; try { all arbitrary = meta . get columns ( str , str , str , str ) ; assert not null ( all arbitrary ) ; check columns shape ( all arbitrary ) ; set size = cross check get columns and result set meta data ( all arbitrary , bool ) ; assert equals ( num , set size ) ; set mixed = meta . get columns ( null , null , str , str ) ; assert not null ( set mixed ) ; check columns shape ( set mixed ) ; set size = cross check get columns and result set meta data ( set mixed , bool ) ; assert equals ( num , set size ) ; } catch ( sql e ) { fail ( str + e . get message ( ) ) ; } conn . close ( ) ; try { meta . get columns ( null , null , database creator . test tabl , str ) ; fail ( str ) ; } catch ( sql e ) { } }	java . sql . databasemetadata # getcolumns ( java . lang . string , java . lang . string , java . lang . string , java . lang . string ).
public static type mirror upper bound ( type mirror type ) { do { if ( type instanceof type variable ) { type variable tvar = ( type variable ) type ; if ( tvar . get upper bound ( ) != null ) { type = tvar . get upper bound ( ) ; } else { break ; } } else if ( type instanceof wildcard type ) { wildcard type wc = ( wildcard type ) type ; if ( wc . get extends bound ( ) != null ) { type = wc . get extends bound ( ) ; } else { break ; } } else { break ; } } while ( bool ) ; return type ; }	if the argument is a bounded typevariable or wildcardtype , return its non - variable , non - wildcard upper bound.
public synchronized object remove ( object key ) { remove blanks ( ) ; weak key reference key ref = new weak key reference ( key ) ; weak reference ref = ( weak reference ) table . remove ( key ref ) ; if ( ref == null ) return null ; return ref . get ( ) ; }	remove the object that the given key maps to.
public boolean remove element ( node s ) { if ( ! m mutable ) throw new runtime exception ( xsl . create xpath ( xpath . er nodeset not mutable , null ) ) ; if ( null == m map ) return bool ; for ( int i = num ; i < m first free ; i ++ ) { node node = m map [ i ] ; if ( ( null != node ) && node . equals ( s ) ) { if ( i < m first free - num ) system . arraycopy ( m map , i + num , m map , i , m first free - i - num ) ; m first free -- ; m map [ m first free ] = null ; return bool ; } } return bool ; }	removes the first occurrence of the argument from this vector.
@ override public inet address address local ( ) { socket s = get socket ( ) ; if ( s != null ) { return s . get local address ( ) ; } else { return null ; } }	returns the server inet address that accepted the request .
public boolean start connection ( ) { state state = state . get ( ) ; if ( state . is active ( ) ) { connection count . increment and get ( ) ; return bool ; } long now = current time . current time ( ) ; long last fail time = last fail time ; long recover timeout = dynamic recover timeout . get ( ) ; if ( now < last fail time + recover timeout ) { return bool ; } int count ; do { count = connection count . get ( ) ; if ( count > num ) { return bool ; } } while ( ! connection count . compare and set ( count , count + num ) ) ; return bool ; }	start a new connection.
public abstract nary operator ( final expr ... args ) { this ( arrays . as list ( args ) ) ; }	creates a new n - ary operator .
static boolean is registered ( object name object name ) { return mbean server != null && mbean server . is registered ( object name ) ; }	returns true if a mbean with given objectname is registered .
public static int find best sample size ( int actual width , int actual height , int desired width , int desired height ) { double wr = ( double ) actual width / desired width ; double hr = ( double ) actual height / desired height ; double ratio = math . min ( wr , hr ) ; float n = num ; while ( ( n * num ) <= ratio ) { n *= num ; } return ( int ) n ; }	returns the largest power - of - two divisor for use in downscaling a bitmap that will not result in the scaling past the desired dimensions .
public socket reader ( final socket socket ) throws io { preconditions . check not null ( socket , str ) ; m = new buffered input stream ( socket . get input stream ( ) ) ; }	creates a new socket reader object .
private boolean move to final scroller position ( scroller scroller ) { scroller . force finished ( bool ) ; if ( is horizontal mode ( ) ) { int amount to scroll = scroller . get final x ( ) - scroller . get curr x ( ) ; int future scroll offset = ( m current scroll offset + amount to scroll ) % m selector element size ; int overshoot adjustment = m initial scroll offset - future scroll offset ; if ( overshoot adjustment != num ) { if ( math . abs ( overshoot adjustment ) > m selector element size / num ) { if ( overshoot adjustment > num ) { overshoot adjustment -= m selector element size ; } else { overshoot adjustment += m selector element size ; } } amount to scroll += overshoot adjustment ; scroll by ( amount to scroll , num ) ; return bool ; } } else { int amount to scroll = scroller . get final y ( ) - scroller . get curr y ( ) ; int future scroll offset = ( m current scroll offset + amount to scroll ) % m selector element size ; int overshoot adjustment = m initial scroll offset - future scroll offset ; if ( overshoot adjustment != num ) { if ( math . abs ( overshoot adjustment ) > m selector element size / num ) { if ( overshoot adjustment > num ) { overshoot adjustment -= m selector element size ; } else { overshoot adjustment += m selector element size ; } } amount to scroll += overshoot adjustment ; scroll by ( num , amount to scroll ) ; return bool ; } } return bool ; }	move to the final position of a scroller.
public void add lon line ( double min lat , double max lat , double lon ) { string name = str + next shape ; next shape ++ ; b . append ( str + name + str ) ; double lat ; int steps = get step count ( min lat , lon , max lat , lon ) ; for ( lat = min lat ; lat <= max lat ; lat += ( max lat - min lat ) / steps ) { b . append ( str + lat + str + lon + str ) ; } b . append ( str + max lat + str + lon + str ) ; lat -= ( max lat - min lat ) / num ; for ( ; lat >= min lat ; lat -= ( max lat - min lat ) / steps ) { b . append ( str + lat + str + lon + str ) ; } b . append ( str ) ; b . append ( str + name + str ) ; }	draws a line a fixed longitude , spanning the min / max latitude.
@ override public double calculate k ( int [ ] x index , double [ ] x att , int [ ] y index , double [ ] y att ) { double result = num ; double tmp ; int xpos = x index . length - num ; int ypos = y index . length - num ; int zeros = dim ; while ( ( xpos >= num ) && ( ypos >= num ) ) { if ( x index [ xpos ] == y index [ ypos ] ) { tmp = x att [ xpos ] - y att [ ypos ] ; result += math . exp ( - sigma * tmp * tmp ) ; xpos -- ; ypos -- ; } else if ( x index [ xpos ] > y index [ ypos ] ) { tmp = x att [ xpos ] ; result += math . exp ( - sigma * tmp * tmp ) ; xpos -- ; } else { tmp = y att [ ypos ] ; result += math . exp ( - sigma * tmp * tmp ) ; ypos -- ; } zeros -- ; } while ( xpos >= num ) { tmp = x att [ xpos ] ; result += math . exp ( - sigma * tmp * tmp ) ; xpos -- ; zeros -- ; } while ( ypos >= num ) { tmp = y att [ ypos ] ; result += math . exp ( - sigma * tmp * tmp ) ; ypos -- ; zeros -- ; } result += zeros ; return math . pow ( result , degree ) ; }	calculates kernel value of vectors x and y .
private float sweep ( float tan1 x , float tan1 y , float tan2 x , float tan2 y ) { final float minor sweep = ( float ) math . to degrees ( num * ( math . asin ( num * geometry . distance ( tan1 x , tan1 y , tan2 x , tan2 y ) / m scaled touch slop ) ) ) ; return num - minor sweep ; }	find the angle in degrees between two tangent points.
sun cert path builder result ( cert path cert path , trust anchor trust anchor , policy node policy tree , public key subject public key , adjacency list adj list ) { super ( cert path , trust anchor , policy tree , subject public key ) ; this . adj list = adj list ; }	creates a suncertpathbuilderresult instance .
public static void attach ( final j parent , final i debugger , final c notifier ) { try { notifier . start ( ) ; debugger . connect ( ) ; } catch ( final debug exception wrapper exception ) { notifier . stop ( ) ; c . log exception ( exception ) ; final string inner message = str + str ; final string inner description = c . create description ( str , new string [ ] { str } , new string [ ] { str + str } ) ; navi error dialog . show ( parent , inner message , inner description , exception ) ; } }	attaches to a target process .
public boolean check addr pattern ( final string the addr pattern ) { return the addr pattern . equals ( addr pattern ( ) ) ; }	check if an address pattern equals a specific address pattern you are looking for.
@ medium test public void test stability in space ( ) { long t = system . current time millis ( ) ; velocity tracker vt = velocity tracker . obtain ( ) ; drag ( vt , num , num , num , num , num , t , num ) ; vt . compute current velocity ( num ) ; float first x = vt . get x ( ) ; float first y = vt . get y ( ) ; vt . clear ( ) ; drag ( vt , num , num , num , num , num , t , num ) ; vt . compute current velocity ( num ) ; float second x = vt . get x ( ) ; float second y = vt . get y ( ) ; assert equal fuzzy ( first x , second x , num ) ; assert equal fuzzy ( first y , second y , num ) ; vt . recycle ( ) ; }	velocity is independent of the position of the events , it only depends on their relative distance .
private view fill from top ( int next top ) { if ( debug ) log . i ( tag , str + next top + m first position + m first position ) ; m first position = math . min ( m first position , m selected position ) ; m first position = math . min ( m first position , m item count - num ) ; if ( m first position < num ) { m first position = num ; } m first position -= m first position % m num columns ; return fill down ( m first position , next top ) ; }	fills the list from top to bottom , starting with mfirstposition.
public static string sit ( enum map < sit , enum map < cit , boolean > > shp ) { string builder result = new string builder ( ) ; for ( sit key : shp . key set ( ) ) { result . append ( str + key . to string ( ) + str + cit ( shp . get ( key ) ) + str ) ; } return result . to string ( ) ; }	converts a sitmap into a human readable string.
public static map < string , object > update binary file ( dispatch context dctx , map < string , ? extends object > context ) { map < string , object > result = null ; try { result = update binary file method ( dctx , context ) ; } catch ( generic service exception e ) { return service util . return error ( e . get message ( ) ) ; } return result ; }	a service wrapper for the createbinaryfilemethod method.
public list < byte [ ] > write ( list < internal log > logs ) throws io { final list < put > puts = new array list < put > ( logs . size ( ) ) ; final list < byte [ ] > result = new array list < byte [ ] > ( logs . size ( ) ) ; for ( internal log log : logs ) { final byte [ ] rowkey = rowkey builder . build rowkey ( log ) ; final put p = new put ( rowkey ) ; populate column values ( p , log ) ; puts . add ( p ) ; final list < byte [ ] > index rowkeys = log . get index rowkeys ( ) ; if ( index rowkeys != null ) { write indexes ( rowkey , index rowkeys , puts ) ; } result . add ( rowkey ) ; } tbl . put ( puts ) ; return result ; }	todo need think about if multi - put is necessary , by checking if autoflush works.
public int read ( long file offset , byte [ ] buffer , int offset , int length ) throws io { log . info ( str + long . to hex string ( file offset ) + str + length + str ) ; return file . read ( file offset , buffer , offset , length ) ; }	reads a block from a given location .
public boolean validate current step ( int current step , int new step ) { return bool ; }	the default implementation returns true .
@ non null protected static list < rave error > must be true ( boolean input , @ non null validation context validation context ) { return input ? collections . < rave error > empty list ( ) : create new list ( new rave error ( validation context , rave error strings . must be true error ) ) ; }	verifies the input to be always true .
@ log message doc ( level = str , message = str , explanation = str + str , recommendation = log message doc . report controller bug ) public void queue hint ( string store name , byte array key , versioned < byte [ ] > value ) { try { hint key hk = new hint key ( store name , key ) ; hint lock . lock ( ) ; try { boolean needed = ! hints . contains key ( hk ) ; needed &= hints . doput ( hk , value ) ; if ( needed ) { hint queue . add ( hk ) ; hints available . signal ( ) ; } } finally { hint lock . unlock ( ) ; } } catch ( sync exception e ) { logger . error ( str + store name , e ) ; } }	add a key / value to the hint store for the given store.
public static dbid random sample ( dbi ids , random factory random ) { return random sample ( ids , random . get single threaded random ( ) ) ; }	draw a single random sample .
public void test add listener ( ) { simple listener listener1 = create mock simple listener ( num ) ; simple listener listener2 = create mock simple listener ( num ) ; assert equals ( num , adaptor . get num listeners ( ) ) ; adaptor . add listener ( listener1 ) ; assert equals ( num , adaptor . get num listeners ( ) ) ; adaptor . add listener ( listener2 ) ; assert equals ( num , adaptor . get num listeners ( ) ) ; adaptor . add listener ( listener1 ) ; assert equals ( num , adaptor . get num listeners ( ) ) ; list < simple listener > listeners = lists . as list ( adaptor . get listeners ( ) ) ; assert equals ( num , listeners . size ( ) ) ; assert true ( listeners . contains ( listener1 ) ) ; assert true ( listeners . contains ( listener2 ) ) ; easy mock . verify ( listener1 , listener2 ) ; }	ensures that when adding a listener that the count of the number of listeners is correctly incremented and that eventfired is called immediately on the listener .
public void on response ( discovery node node ) { boolean found = pending nodes . remove ( node ) ; assert found : str + node + str ; latch . count down ( ) ; }	called for each response obtained from non master nodes.
@ override public synchronized boolean add ( e object ) { if ( element count == element data . length ) { grow by one ( ) ; } element data [ element count ++ ] = object ; mod count ++ ; return bool ; }	adds the specified object at the end of this vector .
private static long copy ( input stream from , output stream to ) throws io { byte [ ] buf = new byte [ settings . buffer size ] ; long total = num ; while ( bool ) { int r = from . read ( buf ) ; if ( r == - num ) { break ; } to . write ( buf , num , r ) ; total += r ; } return total ; }	copies all bytes from the input stream to the output stream.
public void add value ( string value ) { if ( string values == null ) { setup string values ( ) ; } if ( ! string values . contains ( value ) ) { string values . add ( value ) ; } }	add a string value to the attribute.
public void write raw little endian32 ( final int value ) throws io { if ( buffer . remaining ( ) < num ) { throw new out of space exception ( buffer . position ( ) , buffer . limit ( ) ) ; } buffer . put int ( value ) ; }	write a little - endian 32 - bit integer .
private static url [ ] path to ur ( string path ) throws url { if ( path == null ) { return null ; } synchronized ( path to ur ) { object [ ] v = ( object [ ] ) path to ur . get ( path ) ; if ( v != null ) { return ( ( url [ ] ) v [ num ] ) ; } } string tokenizer st = new string tokenizer ( path ) ; url [ ] urls = new url [ st . count tokens ( ) ] ; for ( int i = num ; st . has more tokens ( ) ; i ++ ) { urls [ i ] = new url ( st . next token ( ) ) ; } synchronized ( path to ur ) { path to ur . put ( path , new object [ ] { urls , new soft reference ( path ) } ) ; } return urls ; }	convert a string containing a space - separated list of urls into a corresponding array of url objects , throwing a malformedurlexception if any of the urls are invalid.
public static int hash4 ( int hash , object x , object y , object z , object w ) { return num | ( hash + num * system . identity hash code ( x ) + num * system . identity hash code ( y ) + num * system . identity hash code ( z ) + num * system . identity hash code ( w ) ) ; }	utility method to combine a base hash with the identity hash of one or more objects .
public long skip ( long n ) throws io { if ( n < num ) { throw new illegal argument exception ( str ) ; } ensure open ( ) ; int max = ( int ) math . min ( n , integer . max value ) ; int total = num ; while ( total < max ) { int len = max - total ; if ( len > b . length ) { len = b . length ; } len = read ( b , num , len ) ; if ( len == - num ) { reach eof = bool ; break ; } total += len ; } return total ; }	skips specified number of bytes of uncompressed data .
private v do put ( k kkey , v value , boolean only if absent ) { comparable < ? super k > key = comparable ( kkey ) ; for ( ; ; ) { node < k , v > b = find predecessor ( key ) ; node < k , v > n = b . next ; for ( ; ; ) { if ( n != null ) { node < k , v > f = n . next ; if ( n != b . next ) break ; object v = n . value ; if ( v == null ) { n . help delete ( b , f ) ; break ; } if ( v == n || b . value == null ) break ; int c = key . compare to ( n . key ) ; if ( c > num ) { b = n ; n = f ; continue ; } if ( c == num ) { if ( only if absent || n . cas value ( v , value ) ) return ( v ) v ; else break ; } } node < k , v > z = new node < k , v > ( kkey , value , n ) ; if ( ! b . cas next ( n , z ) ) break ; int level = random level ( ) ; if ( level > num ) insert index ( z , level ) ; return null ; } } }	main insertion method . adds element if not present , or replaces value if present and onlyifabsent is false .
public void add fill outside line ( fill outside line fill ) { m fill below line . add ( fill ) ; }	sets if the line chart should be filled outside its line.
public void add ( final position change listener listener ) { listeners . add ( listener ) ; }	add a position change listener .
public void choose ( boolean enable , string what ) ;	choose a detector , plugin , etc .
public void test duplicate entries ( ) throws exception { string name1 = str ; string name2 = str ; byte array output stream baos = new byte array output stream ( ) ; zip output stream out = new zip output stream ( baos ) ; out . put next entry ( new zip entry ( name2 ) ) ; out . close entry ( ) ; out . put next entry ( new zip entry ( name1 ) ) ; out . close entry ( ) ; out . close ( ) ; byte [ ] buffer = baos . to byte array ( ) ; replace bytes ( buffer , name2 . get bytes ( ) , name1 . get bytes ( ) ) ; file bad zip = create temporary zip file ( ) ; write bytes ( bad zip , buffer ) ; try { zip file bad = new zip file ( bad zip ) ; fail ( ) ; } catch ( zip exception expected ) { } }	make sure we don ' t fail silently for duplicate entries . b / 8219321.
private void check size ( final int i ) { if ( i >= max size ) { final int old size = max size ; max size += increment size ; if ( max size <= i ) { max size = i + increment size + num ; } final int [ ] temp = items ; items = new int [ max size ] ; system . arraycopy ( temp , num , items , num , old size ) ; increment size = increment size ( increment size ) ; } }	check the size of the array and increase if needed.
public component print service ( component c , page format format ) { set page format ( format ) ; set printable ( this ) ; set component ( c ) ; rectangle component bounds = c . get bounds ( null ) ; set size ( component bounds . width , component bounds . height ) ; set scale ( num , num ) ; }	create a pageable that can print a swing jcomponent over multiple pages .
public void flush ( ) throws io { if ( writer != null ) { writer . flush ( ) ; } outstr . flush ( ) ; }	flushes all the streams for this response .
@ suppress warnings ( str ) protected synchronized v remove internal ( object key , boolean count remove ) { if ( key == null ) { if ( debug . verbose on ( ) ) debug . log verbose ( str + this . name , module ) ; } object nulled key = from key ( key ) ; cache line < v > old cache line ; v old value ; if ( file table != null ) { try { synchronized ( this ) { try { old value = file table . get ( nulled key ) ; } catch ( io e ) { old value = null ; throw e ; } file table . remove ( nulled key ) ; jdbm mgr . commit ( ) ; } } catch ( io e ) { old value = null ; debug . log error ( e , module ) ; } old cache line = memory table . remove ( nulled key ) ; } else { old cache line = memory table . remove ( nulled key ) ; old value = old cache line != null ? old cache line . get value ( ) : null ; } if ( old cache line != null ) { cancel ( old cache line ) ; } if ( old value != null ) { note removal ( ( k ) key , old value ) ; if ( count remove ) remove hit count . increment and get ( ) ; return old value ; } else { if ( count remove ) remove miss count . increment and get ( ) ; return null ; } }	this is used for internal remove calls because we only want to count external calls.
public void remove ( double value ) { if ( double . is na n ( value ) ) { return ; } int index = find insert index ( value ) ; if ( index == - num ) { throw new illegal state exception ( str ) ; } double value at index = values . get ( index ) ; if ( ( value at index != null ) && ( ! value at index . equals ( value ) ) ) { throw new illegal state exception ( str ) ; } values . remove ( index ) ; }	remove a value from the collection .
public void children removed ( bean context membership event bcme ) { iterator < ? > it = bcme . iterator ( ) ; while ( it . has next ( ) ) { find and undo ( it . next ( ) ) ; } }	beancontextmembershiplistener method . called when a new object is removed from the beancontext of this object . for the layer , this method doesn ' t do anything . if your layer does something with the childrenadded method , or findandinit , you should take steps in this method to unhook the layer from the object used in those methods .
void lightweight paint ( graphics g ) { super . lightweight paint ( g ) ; paint heavyweight components ( g ) ; }	simulates the peer callbacks into java.
private final void remove channel ( string channel ) { channel = channel . to lower case ( ) ; synchronized ( channels ) { channels . remove ( channel ) ; } }	removes an entire channel from our memory of users .
public void add change listener ( change listener cl ) { if ( ! listeners . contains ( cl ) ) listeners . add ( cl ) ; }	registers a listener for changeevents .
public static void expand number ( string number string , word relation word relation , item token item ) { int num digits = number string . length ( ) ; if ( num digits == num ) { } else if ( num digits == num ) { expand digits ( number string , word relation , token item ) ; } else if ( num digits == num ) { expand2 digit number ( number string , word relation , token item ) ; } else if ( num digits == num ) { expand3 digit number ( number string , word relation , token item ) ; } else if ( num digits < num ) { expand below7 digit number ( number string , word relation , token item ) ; } else if ( num digits < num ) { expand below10 digit number ( number string , word relation , token item ) ; } else if ( num digits < num ) { expand below13 digit number ( number string , word relation , token item ) ; } else { expand digits ( number string , word relation , token item ) ; } }	expands a digit string into a list of english words of those digits . for example , " 1234 " expands to " one two three four ".
private int measure short ( int measure spec ) { int result = num ; int spec mode = measure spec . get mode ( measure spec ) ; int spec size = measure spec . get size ( measure spec ) ; if ( spec mode == measure spec . exactly ) { result = spec size ; } else { result = ( int ) ( num * m radius + get padding top ( ) + get padding bottom ( ) + num ) ; if ( spec mode == measure spec . at most ) { result = math . min ( result , spec size ) ; } } return result ; }	determines the height of this view.
protected boolean can trigger walking ( ) { return bool ; }	returns if this entity triggers block.
public static string encrypt ecb ( final byte [ ] concatenated hash value , final long turnover counter , final secret key symmetric key , int turn over counter length in bytes ) throws no such algorithm exception , no such provider exception , no such padding exception , invalid key exception , illegal block size exception , bad padding exception { final byte buffer byte buffer iv = byte buffer . allocate ( num ) ; byte buffer iv . put ( concatenated hash value ) ; final byte [ ] iv = byte buffer iv . array ( ) ; final byte buffer byte buffer data = byte buffer . allocate ( num ) ; byte buffer data . put long ( turnover counter ) ; final byte [ ] data = byte buffer data . array ( ) ; byte [ ] turn over counter byte rep = get2 complement rep for long ( turnover counter , turn over counter length in bytes ) ; system . arraycopy ( turn over counter byte rep , num , data , num , turn over counter byte rep . length ) ; final cipher cipher = cipher . get instance ( str , str ) ; cipher . init ( cipher . encrypt mode , symmetric key ) ; final byte [ ] intermediate result = cipher . do final ( iv ) ; final byte [ ] result = new byte [ data . length ] ; for ( int i = num ; i < data . length ; i ++ ) { result [ i ] = ( byte ) ( ( data [ i ] ) ^ ( intermediate result [ i ] ) ) ; } final byte [ ] encrypted turn over value = new byte [ turn over counter length in bytes ] ; system . arraycopy ( result , num , encrypted turn over value , num , turn over counter length in bytes ) ; return cash box utils . base64 encode ( encrypted turn over value , bool ) ; }	method for aes encryption in ecb mode.
private static boolean is frost wire old ( string message version ) { if ( message version == null ) return bool ; string current version = frost wire utils . get frost wire version ( ) ; if ( current version . equals ( message version ) ) { return bool ; } try { string [ ] fw version parts = current version . split ( str ) ; int fw major = integer . parse int ( fw version parts [ num ] ) ; int fw release = integer . parse int ( fw version parts [ num ] ) ; int fw service = integer . parse int ( fw version parts [ num ] ) ; string [ ] msg version parts = message version . split ( str ) ; int msg major = integer . parse int ( msg version parts [ num ] ) ; int msg release = integer . parse int ( msg version parts [ num ] ) ; int msg service = integer . parse int ( msg version parts [ num ] ) ; if ( fw major < msg major ) { return bool ; } if ( fw major == msg major && fw release < msg release ) { return bool ; } if ( fw major == msg major && fw release == msg release && fw service < msg service ) { return bool ; } } catch ( exception e ) { return bool ; } return bool ; }	given a version string , it compares against the current frostwire version.
public synchronized void draw map ( ) { last draw map req = system . current time millis ( ) ; swing utilities . invoke later ( draw mapable ) ; }	this replaces the original drawmap to speed up updates this can be called any time necessary.
public void select table2 column ( index column ) { table2 columns . add ( column ) ; }	select table2 column name .
public list < string > extract ur ( final string text ) { if ( text == null || text . length ( ) == num ) return collections . empty list ( ) ; final array list < string > urls = new array list < string > ( ) ; for ( final entity entity : extract ur ( text ) ) { urls . add ( entity . value ) ; } return urls ; }	extract url references from tweet text .
public void find and undo ( iterator it ) { while ( it . has next ( ) ) { find and undo ( it . next ( ) ) ; } }	subclasses should no longer implement this method.
public static int [ ] scale down inside ( int in width , int in height , int max width , int max height ) { int scaled width ; int scaled height ; if ( in width <= max width && in height <= max height ) { scaled width = in width ; scaled height = in height ; } else { double width ratio = ( double ) in width / ( double ) max width ; double height ratio = ( double ) in height / ( double ) max height ; if ( width ratio > height ratio ) { scaled width = max width ; scaled height = ( int ) math . round ( ( double ) in height / width ratio ) ; } else { scaled height = max height ; scaled width = ( int ) math . round ( ( double ) in width / height ratio ) ; } } return new int [ ] { scaled width , scaled height } ; }	returns int [ ] { scaledwidth , scaledheight } for dimensions that fit within the given maxwidth , maxheight at the given inwidth , inheight aspect ratio.
public void rm ( string file or dir ) { string builder buf = new string builder ( ) ; string command = string . format ( image server dialog properties . get string ( str ) , file or dir ) ; send wait for ( command , default timeout , prompts , buf ) ; log . debug ( buf . to string ( ) ) ; }	remove file or directory using ' rm - rf ' command.
public void put map ( map < string , list < string > > m ) { for ( string key : m . key set ( ) ) { sorted set < string > vals = get ( key ) ; if ( vals == null ) { vals = new tree set < string > ( ) ; put ( key , vals ) ; } vals . add all ( m . get ( key ) ) ; } }	convenience method to merge a map < string , list < string > > .
public void add asset listener ( @ not null action listener listener ) { my asset listeners . add ( listener ) ; }	add a listener which will be triggered whenever the asset represented by this panel is modified in any way .
public undoable edit insert string ( int where , string str ) throws bad location exception { if ( where > length ( ) || where < num ) { throw new bad location exception ( str , length ( ) ) ; } char [ ] chars = str . to char array ( ) ; replace ( where , num , chars , chars . length ) ; return new insert undo ( where , str . length ( ) ) ; }	inserts a string into the content .
public static boolean is you tube url ( string url ) { if ( text utils . is empty ( url ) ) { return bool ; } uri uri = uri . parse ( url ) ; string authority = uri . get authority ( ) ; if ( ! text utils . is empty ( authority ) && authority . contains ( str ) ) { return bool ; } else { return bool ; } }	checks to see if the your contains the authority " youtube . com ".
public list < vo > find namespaces ( string app id , env env , string cluster name ) { list < dto > namespaces = namespace api . find namespace by cluster ( app id , env , cluster name ) ; if ( namespaces == null || namespaces . size ( ) == num ) { throw new bad request exception ( str ) ; } list < vo > namespace v = new linked list < > ( ) ; for ( dto namespace : namespaces ) { vo namespace vo = null ; try { namespace vo = parse namespace ( app id , env , cluster name , namespace ) ; namespace v . add ( namespace vo ) ; } catch ( exception e ) { logger . error ( str , app id , env , cluster name , namespace . get namespace name ( ) , e ) ; throw e ; } } return namespace v ; }	load cluster all namespace info with items.
public static void open share dialog ( context context , string title , @ suppress warnings ( str ) string uri , string share text , string share subject ) { intent share = new intent ( intent . action send ) ; share . set type ( str ) ; share . put extra ( intent . extra text , share text ) ; share . put extra ( intent . extra subject , share subject ) ; if ( ! text utils . is empty ( uri ) ) { share . set type ( str ) ; share . put extra ( intent . extra stream , uri . parse ( uri ) ) ; } context . start activity ( intent . create chooser ( share , title ) ) ; }	opens android share dialog pass one of uri or sharetext.
public void add matching ( final conversation states state , final string trigger string , final expression matcher matcher , final chat condition condition , boolean secondary , final conversation states next state , final string reply , final chat action action ) { collection < expression > trigger expressions = create unique trigger expressions ( state , arrays . as list ( trigger string ) , matcher , condition , reply , action ) ; add ( trigger expressions , state , condition , secondary , next state , reply , action ) ; }	adds a new transition with explicit expressionmatcher to fsm .
boolean drop items ( final player player , int item count ) { boolean result = bool ; final item collection items todo = new item collection ( ) ; items todo . add from quest state string ( player . get quest ( quest slot ) ) ; if ( player . drop ( item name , item count ) ) { if ( items todo . remove item ( item name , item count ) ) { result = bool ; } } else { final list < item > items = player . get all equipped ( item name ) ; if ( items != null ) { for ( final item item : items ) { final int quantity = item . get quantity ( ) ; final int n = math . min ( item count , quantity ) ; if ( player . drop ( item name , n ) ) { item count -= n ; if ( items todo . remove item ( item name , n ) ) { result = bool ; } } if ( item count == num ) { result = bool ; break ; } } } } if ( result ) { player . set quest ( quest slot , items todo . to string for quest state ( ) ) ; } return result ; }	drop specified amount of given item.
public void encode octet string ( byte tb [ ] , int tag , int tboffset , int length ) throws encode exception { encode byte ( tag ) ; encode length ( length ) ; if ( length > num ) { ensure free bytes ( length ) ; system . arraycopy ( tb , tboffset , buf , offset , length ) ; offset += length ; } }	encodes a portion of an octet string and a tag .
private void swap blocks ( int from , int second , int to ) { int len1 = second - from , len2 = to - second + num ; if ( len1 == num || len2 == num ) { return ; } if ( len1 < temp . length ) { system . arraycopy ( data , from , temp , num , len1 ) ; system . arraycopy ( data , second , data , from , len2 ) ; system . arraycopy ( temp , num , data , from + len2 , len1 ) ; return ; } else if ( len2 < temp . length ) { system . arraycopy ( data , second , temp , num , len2 ) ; system . arraycopy ( data , from , data , from + len2 , len1 ) ; system . arraycopy ( temp , num , data , from , len2 ) ; return ; } reverse block ( from , second - num ) ; reverse block ( second , to ) ; reverse block ( from , to ) ; }	swap the elements of two blocks in the data array.
private static long total size ( map < string , long > rel path to size ) { long total = num ; for ( long l : rel path to size . values ( ) ) { total += l ; } return total ; }	get the total size of the paths .
public static boolean is valid ( timestamp valid from , timestamp valid to , timestamp test date ) { if ( test date == null ) return bool ; if ( valid from == null && valid to == null ) return bool ; if ( valid from != null && valid from . after ( test date ) ) return bool ; if ( valid to != null && valid to . before ( test date ) ) return bool ; return bool ; }	is it valid on test date.
public pattern tokenizer ( attribute factory factory , pattern pattern , int group ) { super ( factory ) ; this . group = group ; matcher = pattern . matcher ( str ) ; if ( group >= num && group > matcher . group count ( ) ) { throw new illegal argument exception ( str + matcher . group count ( ) + str ) ; } }	creates a new patterntokenizer returning tokens from group ( - 1 for split functionality ).
@ override public double total estimated quantity for previous r ( final long wo activity id , long estimate id , final long activity id , final work order work order ) { if ( estimate id == null ) estimate id = - num ; object [ ] params = null ; double est quantity = null ; params = new object [ ] { estimate id , work order , work order , wo activity id , activity id } ; est quantity = ( double ) generic service . find by named query ( str , params ) ; double est quantity re = null ; params = new object [ ] { estimate id , work order , work order , activity id } ; est quantity re = ( double ) generic service . find by named query ( str , params ) ; if ( est quantity != null && est quantity re != null ) est quantity = est quantity + est quantity re ; if ( est quantity == null && est quantity re != null ) est quantity = est quantity re ; if ( est quantity == null ) return num ; else return est quantity . double value ( ) ; }	similar to totalestimatedquantityforre but will consider only previous res and not all res.
public boolean eval ( ) { if ( source file sets . size ( ) == num && source resources . size ( ) == num && source file == null ) { throw new build exception ( str ) ; } if ( ( source file sets . size ( ) > num || source resources . size ( ) > num ) && source file != null ) { throw new build exception ( str ) ; } if ( urlbase == null ) { throw new build exception ( str ) ; } if ( source file != null && ! source file . exists ( ) ) { throw new build exception ( source file . get absolute path ( ) + str ) ; } boolean up to date = bool ; if ( source file != null ) { resource file resource = new file resource ( source file ) ; up to date = is up to date ( file resource ) ; } if ( up to date ) { enumeration e = source file sets . elements ( ) ; while ( up to date && e . has more elements ( ) ) { file set fs = ( file set ) e . next element ( ) ; iterator it = fs . iterator ( ) ; while ( up to date && it . has next ( ) ) { resource r = ( resource ) it . next ( ) ; up to date = is up to date ( r ) ; } } } if ( up to date ) { resource [ ] r = source resources . list resources ( ) ; for ( int i = num ; up to date && i < r . length ; i ++ ) { up to date = is up to date ( r [ i ] ) ; } } return up to date ; }	evaluate ( all ) target and source file ( s ) to see if the target ( s ) is / are up - to - date .
private int handle aggregation packet ( buffer input , buffer output ) { byte [ ] buffer data = ( byte [ ] ) input . get data ( ) ; if ( aggregation positon + num >= buffer data . length ) { aggregation positon = num ; output . set discard ( bool ) ; return buffer processed ok ; } int nalu size = ( ( ( buffer data [ aggregation positon ] & num ) << num ) | ( buffer data [ aggregation positon + num ] & num ) ) ; aggregation positon += num ; if ( aggregation positon + nalu size > buffer data . length ) { aggregation positon = num ; return buffer processed failed ; } extract nal unit header ( aggregation positon , input ) ; if ( m nal unit header . is single nal unit packet ( ) ) { byte [ ] data = new byte [ nalu size ] ; system . arraycopy ( buffer data , aggregation positon , data , num , nalu size ) ; aggregation positon += nalu size ; output . set data ( data ) ; output . set length ( data . length ) ; output . set offset ( num ) ; output . set timestamp ( input . get timestamp ( ) ) ; output . set sequence number ( input . get sequence number ( ) ) ; output . set video orientation ( input . get video orientation ( ) ) ; output . set format ( input . get format ( ) ) ; output . set flags ( input . get flags ( ) ) ; return input buffer not consumed ; } aggregation positon = num ; return buffer processed failed ; }	handle aggregation nal unit packet.
protected int decode line prefix ( pushback input stream in stream , output stream out stream ) throws io { int i ; int n len , n seq ; byte xtmp [ ] ; int c ; crc . value = num ; while ( bool ) { c = in stream . read ( tmp , num , num ) ; if ( c == - num ) { throw new ce ( ) ; } if ( tmp [ num ] == str ) { break ; } } line and seq . reset ( ) ; decode atom ( in stream , line and seq , num ) ; xtmp = line and seq . to byte array ( ) ; n len = xtmp [ num ] & num ; n seq = xtmp [ num ] & num ; if ( n seq != sequence ) { throw new ce ( str ) ; } sequence = ( sequence + num ) & num ; return ( n len ) ; }	decodelineprefix reads the sequence number and the number of encoded bytes from the line.
protected void update cached awt ( final dimension min , final dimension pref , final dimension max ) { assert event queue . is dispatch thread ( ) ; if ( verbose size layout ) { system . err . println ( str + min + str + pref + str + max ) ; } last validated awt = ++ current awt ; boolean must notify ; synchronized ( this ) { must notify = cached sizes initialized == num ; if ( ! must notify ) { must notify = ! ( min . equals ( cached min size ) && pref . equals ( cached pref size ) && max . equals ( cached max size ) ) ; } if ( cached sizes initialized == num ) { cached sizes initialized = num ; } cached min size = min ; cached pref size = pref ; cached max size = max ; if ( initial client area workaround && initial client area != null ) { initial client area . width = cached pref size . width ; initial client area . height = cached pref size . height ; } } if ( must notify ) { final int on behalf awt = last validated awt ; threading handler . get instance ( ) . async exec ( display , null ) ; } }	given the minimum , preferred , and maximum sizes of the swing component , this method stores them in the cache and updates this control accordingly .
public boolean is decimal point ( ) { if ( m decimal point == null ) { decimal format symbols dfs = new decimal format symbols ( m locale ) ; m decimal point = new boolean ( dfs . get decimal separator ( ) == str ) ; } return m decimal point . boolean value ( ) ; }	returns true if decimal point ( not comma ).
public void remove layer ( layer layer ) { if ( layer != null && layer . is removable ( ) ) { list < layer > current layers = get layer list ( ) ; current layers . remove ( layer ) ; set layer list ( current layers ) ; } else { if ( layer != null ) { logger . warning ( str + layer . get name ( ) + str ) ; throw new com . bbn . openmap . util . handle error ( str + layer . get name ( ) + str ) ; } } }	remove a layer from the list of potentials .
public option [ ] find all option types ( final class option class ) { check . not null ( option class , str ) ; return find all option types ( new class [ ] { option class } ) ; }	finds all options that the user set for this command that match the given class .
public int via padstack count ( ) { return via padstacks . size ( ) ; }	the count of padstacks from this . padstacks , which can be used in routing.
public static boolean is earlier transaction ( m cd , int c id , int m id , int m id , string costing level ) { m trx = new m ( cd . get ctx ( ) , cd . get m id ( ) , cd . get ( ) ) ; m last cd = get last transaction ( trx , c id , m id , m id , costing level ) ; if ( last cd == null ) return bool ; if ( cd . get seq no ( ) <= last cd . get seq no ( ) && cd . get m id ( ) != last cd . get m id ( ) ) { return bool ; } return bool ; }	detect if cost detail delayed entry.
public void add out of context message ( consensus message m ) { out of context lock . lock ( ) ; if ( m . get type ( ) == message factory . propose ) { logger . println ( str + m ) ; out of context proposes . put ( m . get number ( ) , m ) ; } else { list < consensus message > messages = out of context . get ( m . get number ( ) ) ; if ( messages == null ) { messages = new linked list < consensus message > ( ) ; out of context . put ( m . get number ( ) , messages ) ; } logger . println ( str + m ) ; messages . add ( m ) ; } out of context lock . unlock ( ) ; }	stores a message established as being out of context ( a message that doesn ' t belong to current executing consensus ) .
private long calculate capacity ( long minimum capacity ) { long new capacity = math . min ( math . max ( capacity , num ) , minimum capacity ) ; while ( new capacity < math . min ( minimum capacity , max capacity ) ) { new capacity <<= num ; } return math . min ( new capacity , max capacity ) ; }	calculates the next capacity that meets the given minimum capacity .
protected object create resource ( ) throws resource unavailable exception { object resource = create ( ) ; freed . add ( resource ) ; num created ++ ; return ( resource ) ; }	creates a new resource and performs any initilization required to manage the resource.
public void upgrade ( ) throws exception { if ( ! check upgrade preconditions ( ) ) { return ; } backup manager . create open dj ( ) ; try ( buffered writer out = new buffered writer ( new file writer ( upgrade marker ) ) ) { out . write ( current version . to string ( ) ) ; out . write ( str ) ; } if ( current version . is older than ( dj 245 version ) ) { backup file ( str ) ; backup file ( str ) ; backup file ( str ) ; unpack zip file ( bool ) ; call old dj ( ) ; } else { unpack zip file ( bool ) ; if ( current version . equals ( dj 246 version ) ) { try { file bad schema = new file ( install root + file . separator + str + file . separator + str + file . separator + str ) ; delete ( bad schema ) ; } catch ( runtime exception e ) { } file good schema = new file ( servlet ctx . get real path ( file . separator + str + file . separator + str + file . separator + str + file . separator + str + file . separator + str ) ) ; file move to = new file ( install root + file . separator + str + file . separator + str + file . separator + str ) ; copy ( good schema . to path ( ) , move to . to path ( ) ) ; } int ret = call dj ( ) ; if ( ret == num ) { message ( str ) ; delete ( upgrade marker ) ; final string lock file = lock file manager . get server lock file name ( ) ; lock file manager . release lock ( lock file , new string builder ( ) ) ; } else { throw new upgrade exception ( str + ret ) ; } } }	upgrades the embedded ds instance to opendj 2.
public static final optional < file > find steam vr ( final array list < file > indexed steam folders ) { for ( final file f : indexed steam folders ) { final file current file = new file ( f . get absolute path ( ) + steam constants . steam vr apps manifest file location ) ; if ( current file . exists ( ) ) return optional . of nullable ( current file ) ; } return optional . empty ( ) ; }	attempts to find the steamvr manifest file within the given locations.
private static boolean is close ( float value , float target value ) { return math . abs ( value - target value ) < num ; }	returns true if value is close to target value .
public int size ( ) { return my tcp clients . size ( ) ; }	get the number of connected clients .
public static m add to movement cart ( properties ctx , stock movement bean bean , m cart bean , boolean is sales , boolean if add ) throws operation exception , product not found exception , product not on price list exception { array list < item bean > old items ; if ( cart bean == null ) { cart bean = new m ( ) ; old items = new array list < item bean > ( ) ; } else { old items = cart bean . get items ( ) ; } array list < item bean > old items clone = ( array list ) old items . clone ( ) ; array list items to be added = get m ( ctx , bean ) ; old items = add to m ( ctx , old items clone , items to be added , if add ) ; integer price list id = pos . get price list id ( ctx , is sales ) ; old items = set m ( ctx , price list id , old items , is sales ) ; cart bean . set items ( old items ) ; cart bean . set pricelist id ( price list id ) ; return cart bean ; }	add to movement cart ( stock transfer cart ).
private static list < field > filter field list ( list < field > fields , class < ? > filter class ) { list < field > filtered fields = new linked list < > ( ) ; for ( field f : fields ) { if ( ( filter class == null ) || filter class . is assignable from ( f . get type ( ) ) ) { filtered fields . add ( f ) ; } } return filtered fields ; }	takes a list of fields and returns only fields which are subclasses of the filterclass.
public static void render pairwise orthogonal ( complex vector vec1 , complex vector vec2 ) { incompatible vectors exception . check vectors compatible ( vec1 , vec2 ) ; if ( vec1 . get op mode ( ) != complex vector . mode . cartesian ) vec1 . to cartesian ( ) ; if ( vec2 . get op mode ( ) != complex vector . mode . cartesian ) vec2 . to cartesian ( ) ; float [ ] coordinates1 = vec1 . get coordinates ( ) ; float [ ] coordinates2 = vec2 . get coordinates ( ) ; for ( int i = num ; i < vec1 . get dimension ( ) * num ; i += num ) { double result this pair = coordinates1 [ i ] * coordinates2 [ i ] ; result this pair += coordinates1 [ i + num ] * coordinates2 [ i + num ] ; double norm1 = coordinates1 [ i ] * coordinates1 [ i ] ; norm1 += coordinates1 [ i + num ] * coordinates1 [ i + num ] ; double norm2 = coordinates2 [ i ] * coordinates2 [ i ] ; norm2 += coordinates2 [ i + num ] * coordinates2 [ i + num ] ; norm1 = math . sqrt ( norm1 ) ; norm2 = math . sqrt ( norm2 ) ; double cosine = num ; if ( norm1 > num && norm2 > num ) cosine = result this pair / ( norm1 * norm2 ) ; coordinates1 [ i ] = ( float ) ( coordinates1 [ i ] - cosine * coordinates2 [ i ] ) ; coordinates1 [ i + num ] = ( float ) ( coordinates1 [ i + num ] - cosine * coordinates2 [ i + num ] ) ; } }	experimental : renders each circular component of vec1 orthogonal to the corresponding component of vec2 both vectors are in put into cartesian mode .
protected simple java file object ( uri uri , kind kind ) { uri . get class ( ) ; kind . get class ( ) ; if ( uri . get path ( ) == null ) throw new illegal argument exception ( str + uri ) ; this . uri = uri ; this . kind = kind ; }	construct a simplejavafileobject of the given kind and with the given uri .
public int increment ( int val ) { if ( val < num ) { return decrement ( - val ) ; } lock . lock ( ) ; int new value = ( value += val ) ; lock . unlock ( ) ; return new value ; }	increments the counter by val .
protected void release internal ( ) { context translator . pts 1cfa map = null ; context translator . objs 1cfa map = null ; }	reset the pta and get it ready for another run .
public static void add constraint violations rdf ( list < constraint violation > cvs , model result , boolean create source ) { for ( constraint violation cv : cvs ) { resource r = result . create resource ( spin . constraint violation ) ; string message = cv . get message ( ) ; if ( message != null && message . length ( ) > num ) { r . add property ( rdfs . label , message ) ; } if ( cv . get root ( ) != null ) { r . add property ( spin . violation root , cv . get root ( ) ) ; } r . add property ( spin . violation level , cv . get level ( ) ) ; for ( simple property path path : cv . get paths ( ) ) { if ( path instanceof object property path ) { r . add property ( spin . violation path , path . get predicate ( ) ) ; } else { resource p = result . create resource ( sp . reverse path ) ; p . add property ( sp . path , path . get predicate ( ) ) ; r . add property ( spin . violation path , p ) ; } } if ( create source && cv . get source ( ) != null ) { r . add property ( spin . violation source , cv . get source ( ) ) ; } if ( cv . get value ( ) != null ) { r . add property ( spin . violation value , cv . get value ( ) ) ; } } }	creates an rdf representation ( instances of spin : constraintviolation ) from a collection of constraintviolation java objects .
public page copy ( long version ) { page new page = create ( map , version , keys , values , children , total count , get memory ( ) ) ; remove page ( ) ; new page . cached compare = cached compare ; return new page ; }	create a copy of this page .
public boolean start busytone ( final string busytone uri type ) { if ( busytone uri type . is empty ( ) ) { return bool ; } try { log . d ( tag , str + busytone uri type ) ; if ( m busytone != null ) { if ( m busytone . is playing ( ) ) { log . d ( tag , str ) ; return bool ; } else { stop busytone ( ) ; } } uri busytone uri ; map data = new hash map < string , object > ( ) ; data . put ( str , str ) ; if ( busytone uri type . equals ( str ) ) { m busytone = new my tone generator ( my tone generator . busy ) ; m busytone . start play ( data ) ; return bool ; } else { busytone uri = get busytone uri ( busytone uri type ) ; if ( busytone uri == null ) { log . d ( tag , str ) ; return bool ; } } m busytone = new my media player ( ) ; data . put ( str , busytone uri ) ; data . put ( str , bool ) ; data . put ( str , audio manager . stream voice call ) ; set media player events ( ( media player ) m busytone , str ) ; m busytone . start play ( data ) ; return bool ; } catch ( exception e ) { log . d ( tag , str ) ; log . d ( tag , e . get message ( ) ) ; return bool ; } }	this is part of start ( ) process.
private string move to folder ( final string file , final string folder ) { final file source = new file ( file ) ; final file destination = new file ( folder + file . separator + source . get name ( ) ) ; log . i ( tag , file + str + destination . get absolute path ( ) ) ; try { file utils . move file ( source , destination ) ; } catch ( final io e ) { log . e ( tag , str ) ; } return destination . get absolute path ( ) ; }	moves file to specified folder.
public void put all ( map m ) { set keys = m . key set ( ) ; for ( iterator iter = keys . iterator ( ) ; iter . has next ( ) ; ) { object key = iter . next ( ) ; put ( key , m . get ( key ) ) ; } }	puts all the elements in the map to this map .
protected string handle date ( result set rs , int column index , string date format string ) throws sql { java . sql . date date = rs . get date ( column index ) ; string value = null ; if ( date != null ) { simple date format date format = new simple date format ( date format string ) ; value = date format . format ( date ) ; } return value ; }	retrieves a date from the result set .
@ override public random access stream open file random access ( ) throws io { if ( is windows && is aux ( ) ) throw new file not found exception ( file . to string ( ) ) ; return new file random access stream ( new random access file ( get file ( ) , str ) ) ; }	returns the stream implementation for a random - access stream .
public q ( time zone zone , long now ) { time zone = zone ; if ( zone == gmt time zone ) { std name = gmt std name ; dst name = gmt dst name ; } else if ( zone == local time zone ) { std name = local std name ; dst name = local dst name ; } else { std name = time zone . get display name ( bool , time zone . short ) ; dst name = time zone . get display name ( bool , time zone . short ) ; } calendar = new gregorian calendar ( time zone ) ; if ( zone == gmt time zone ) set gmt ( now ) ; else set local time ( now ) ; }	creates the date from local or gmt .
public static void serialize ( serializable obj , byte array output stream bout ) { try { object output stream out = new object output stream ( bout ) ; out . write object ( obj ) ; out . close ( ) ; } catch ( io e ) { throw new illegal state exception ( str + obj , e ) ; } }	serialize the given object into the given stream.
public static string upper ( string s ) { return s . to upper case ( locale . english ) ; }	avoids turkish ' i ' problem .
private void accept ( socket socket ) { log . info ( str , socket . get inet address ( ) ) ; try { inet address server address = dns . get address ( str ) ; try ( connection client connection = new connection ( socket ) ; connection server connection = new connection ( new socket ( server address , clash port ) ) ) { proxy session session = proxy session . new session ( services . get message factory ( ) , client connection , server connection , filter chain ) ; log . info ( str , socket ) ; village analyzer . log session ( session ) ; } } catch ( io e ) { log . info ( str , socket . get inet address ( ) , e . to string ( ) ) ; } finally { try { socket . close ( ) ; } catch ( io e ) { } } }	accept a connection from a client and proxy it to the server.
public void remove process listener ( process listener l ) { listener list . remove ( l ) ; }	removes an process listener from the list of listeners .
public final static boolean is valid java identifier ( string s ) { if ( s == null || s . length ( ) == num ) { return bool ; } char [ ] c = s . to char array ( ) ; if ( ! character . is java identifier start ( c [ num ] ) ) { return bool ; } for ( int i = num ; i < c . length ; i ++ ) { if ( ! character . is java identifier part ( c [ i ] ) ) { return bool ; } } return bool ; }	check whether the given string is a valid identifier according to the java language specifications.
final void send help ( ) { array list < string > help = help ( ) ; if ( help . is empty ( ) ) { return ; } xmpp msg msg = new xmpp msg ( ) ; msg . add string array ( help . to array ( new string [ help . size ( ) ] ) ) ; send ( msg ) ; }	sends the help messages from the current command to the user , does nothing if there are no help messages available.
protected void init ( ) { log . info ( str ) ; long start time = system . current time millis ( ) ; bughouse sound keys = get sounds keys ( str ) ; sound keys = get sounds keys ( str ) ; init sound player ( ) ; init speech ( ) ; log . info ( str + ( system . current time millis ( ) - start time ) + str ) ; }	i have tried caching the clips.
private static void run conf client ( final process builder pb ) throws exception { int exit code = - num ; try { process process = pb . start ( ) ; exit code = process . wait for ( ) ; } catch ( io e ) { log . error ( str , e ) ; exit code = num ; throw e ; } catch ( exception e ) { log . error ( str , e ) ; throw e ; } switch ( exit code ) { case success : break ; case error code cannot download conf : throw new exception ( str + exit code + str ) ; case error code expired conf : throw new exception ( str + exit code + str ) ; case error code invalid signature value : throw new exception ( str + exit code + str ) ; case error code internal : throw new exception ( str + exit code + str ) ; default : throw new exception ( str + str + exit code + str + str + str ) ; } }	helper method for running the configuration client script .
public boolean do check site status ( url url ) { if ( debug . message enabled ( ) ) { debug . message ( str + url ) ; } url checker = get url ( url ) ; if ( checker != null && ( checker . get status ( ) == url . status unknown ) ) { synchronized ( checker ) { checker . cancel ( ) ; checker . notify ( ) ; } synchronized ( url checkers ) { url checkers . remove ( get thread name ( url ) ) ; } debug . error ( str + str + get thread name ( url ) ) ; return bool ; } else if ( ( checker != null ) && ( checker . get status ( ) == url . status available ) ) { return bool ; } else { return bool ; } }	the method that will be used by sitemonitor to check each site is alive .
protected void fill ( ) throws io { ensure open ( ) ; len = in . read ( buf , num , buf . length ) ; if ( len == - num ) { throw new eof ( str ) ; } inf . set input ( buf , num , len ) ; }	fills input buffer with more data to decompress .
private boolean overrides ( executable element e , class < ? > clazz , string method ) { type element clazz elt = elements . get type element ( clazz . get canonical name ( ) ) ; assert clazz elt != null ; for ( executable element elt : element filter . methods in ( clazz elt . get enclosed elements ( ) ) ) { if ( elt . get simple name ( ) . content equals ( method ) && elements . overrides ( e , elt , clazz elt ) ) { return bool ; } } return bool ; }	determines whether or not the given element overrides the named method in the named class .
public element sign xml ( document doc , string cert alias , string algorithm , string id attr name , string id , boolean include cert , string xpath ) throws xml { return sign xml ( doc , cert alias , null , algorithm , id attr name , id , include cert , xpath ) ; }	sign part of the xml document referred by the supplied id attribute using enveloped signatures and use exclusive xml canonicalization .
public int size ( ) { return attrs . size ( ) ; }	indicates the number of attributes held in the container .
protected socket open passive data connection ( int command , string arg ) throws io , ftp exception can not have data connection { socket socket ; if ( pasv ( ) != ftp . entering passive mode ) throw new ftp exception can not have data connection ( str + get reply string ( ) ) ; try { parse passive mode reply ( get reply strings ( ) [ num ] ) ; } catch ( malformed server reply exception e ) { throw new ftp exception can not have data connection ( e . get message ( ) ) ; } socket = socket factory . create socket ( passive host , passive port ) ; if ( ! ftp . is positive preliminary ( send command ( command , arg ) ) ) { socket . close ( ) ; return null ; } if ( remote verification enabled && ! verify remote ( socket ) ) { inet address host1 , host2 ; host1 = socket . get inet address ( ) ; host2 = get remote address ( ) ; socket . close ( ) ; throw new ftp exception can not have data connection ( str + host1 . get host address ( ) + str + host2 . get host address ( ) + str ) ; } if ( data timeout >= num ) socket . set so timeout ( data timeout ) ; return socket ; }	open a passive data connection socket.
public object invoke ( object proxy , method method , object [ ] args ) throws throwable { monitor mon = null ; if ( params . is interface enabled && params . is enabled ) { mon = monitor factory . start ( labeler int . get summary label ( method ) ) ; } try { if ( method . equals ( equals method ) ) return boolean . value of ( equals ( args [ num ] ) ) ; else return method . invoke ( monitored obj , args ) ; } catch ( invocation target exception e ) { if ( params . is enabled ) { string sql message = str ; string detail stack trace = null ; throwable root cause = e . get cause ( ) ; if ( root cause instanceof sql ) { sql sql exception = ( sql ) root cause ; sql message = str + sql exception . get error code ( ) + str + sql exception . get sql ( ) ; } track exception ( root cause , method , sql message ) ; } throw e . get cause ( ) ; } finally { if ( mon != null ) mon . stop ( ) ; } }	method that monitors method invocations of the proxied interface.
public static void copy stream ( final input stream from stream , final output stream to stream ) throws io { byte [ ] buffer = new byte [ num ] ; int bytes read ; while ( ( bytes read = from stream . read ( buffer ) ) != - num ) { to stream . write ( buffer , num , bytes read ) ; } }	copies the content from one stream to another stream .
private void load string value ( j comp , final string element name ) { string prop value = properties . get value ( element name ) ; if ( prop value != null && ! prop value . is empty ( ) ) { comp . set text ( prop value ) ; } }	gets the string value of a property and loads it into a jtextfield.
public builder label ( char label ) { this . label = character . to upper case ( label ) ; return this ; }	specifies a single uppercase alphanumeric character from the set { a - z , 0 - 9 } .
public static boolean is letter or digit ( char c ) { return character . is letter or digit ( c ) ; }	returns true if character c is a letter or digit .
public static int put long ( byte [ ] bytes , int offset , long val ) { if ( little endian ) { val = long . reverse bytes ( val ) ; } the unsafe . put long ( bytes , offset + byte array base offset , val ) ; return offset + bytes . sizeof long ; }	put a long value out to the specified byte array position in big - endian format .
private instruction schedule scalar defs early ( enumeration < operand > e , instruction early pos , instruction inst ) { while ( e . has more elements ( ) ) { operand op = e . next element ( ) ; instruction def = defining instruction ( op ) ; schedule early ( def ) ; if ( def . is branch ( ) ) def = dominance successor ( def , inst ) ; early pos = max dominator depth ( def , early pos ) ; } return early pos ; }	schedules an instruction as early as possible , but behind the definitions in e and behind earlypos.
public void make unique ( string [ ] columns , string conflict policy ) { uniques . add ( constraint unique + text utils . join ( str , columns ) + unique + text utils . join ( str , columns ) + on conflict + conflict policy + comma ) ; }	create a unique constraint to already declared columns using the specified conflict policy . atention : it does not add the columns to the table , you need to add the columns using addcolumn or addfk.
default < t > void for each matching field name with boolean ( string regex , bi consumer < string , boolean > function ) { for each matching field name with boolean ( pattern . compile ( regex ) , num , function ) ; }	for all fields whose names match the given regular expression , extract a boolean value from the first group in the regular expression and call the supplied function .
public void exit ( ) { cancel ( ) ; final float radius = lerp ( num , m outer radius , m tween radius ) ; final float remaining ; if ( m anim radius != null && m anim radius . is running ( ) ) { remaining = m outer radius - radius ; } else { remaining = m outer radius ; } final int radius duration = ( int ) ( num * math . sqrt ( remaining / ( wave touch up acceleration + wave touch down acceleration ) * m density ) + num ) ; final int opacity duration = ( int ) ( num * m opacity / wave opacity decay velocity + num ) ; exit software ( radius duration , opacity duration ) ; }	starts the exit animation .
public void test sealed object2 ( ) throws exception { try { new sealed object ( null ) { } ; fail ( str + str ) ; } catch ( null pointer exception e ) { } string secret = str ; cipher cipher = new null cipher ( ) ; sealed object so1 = new sealed object ( secret , cipher ) ; sealed object so2 = new sealed object ( so1 ) { } ; assert equals ( str + str , secret , so2 . get object ( cipher ) ) ; assert equals ( str + str + str , so1 . get algorithm ( ) , so2 . get algorithm ( ) ) ; }	sealedobject ( sealedobject so ) method testing.
@ override public void handle request body ( solr query request req , solr query response rsp ) throws parse exception , io , syntax error { string deletion query = get deletion query ( ) ; logger . info ( str , deletion query ) ; if ( older documents exists ( deletion query , req , rsp ) ) { update request processor processor = get processor ( req , rsp ) ; delete old documents ( deletion query , processor , req ) ; commit deletions ( processor , req ) ; } }	processes the request for the round robin update update handler .
public < v extends comparable < ? super v > > optional long max by ( long function < v > key extractor ) { obj long box < v > result = collect ( null , null , null ) ; return result . a == null ? optional long . empty ( ) : optional long . of ( result . b ) ; }	returns the maximum element of this stream according to the provided key extractor function.
public void query and compare shards ( solr params params ) throws exception { update mappings from zk ( jettys , clients ) ; list < string > shards = new array list < > ( shard to jetty . key set ( ) ) ; for ( string shard : shards ) { query and compare replicas ( params , shard ) ; } }	for each shard , executes a query against each live and active replica of that shard and asserts that the results are identical for each replica of the same shard.
public int index of ( int ch ) { return index of ( ch , num ) ; }	returns the index within this string of the first occurrence of the specified character.
private watcher init watcher ( solr zk client zk client ) { wrapped watcher = new buffer state watcher ( ) ; return zk client . wrap watcher ( wrapped watcher ) ; }	solrzkclient does not guarantee that a watch object will only be triggered once for a given notification if we does not wrap the watcher - see solr - 6621 .
public configuration ( ) { super ( ) ; }	creates an empty extended properties object .
public static < k , v > map < k , v > of ( k k1 , v v1 , k k2 , v v2 , k k3 , v v3 , k k4 , v v4 , k k5 , v v5 , k k6 , v v6 , k k7 , v v7 ) { map map = of ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; map . put ( k3 , v3 ) ; map . put ( k4 , v4 ) ; map . put ( k5 , v5 ) ; map . put ( k6 , v6 ) ; map . put ( k7 , v7 ) ; return map ; }	returns map containing the given entries .
public long long at ( int index ) { lb . position ( index ) ; return lb . get ( ) ; }	get the value of an element of the longarraycounter object .
private string start set to string ( ) { string buffer f = new string buffer ( ) ; boolean did print ; if ( m starting == null ) { return get start set ( ) ; } for ( int i = num ; i < m starting . length ; i ++ ) { did print = bool ; if ( ( m has class == bool ) || ( m has class == bool && i != m class index ) ) { f . append ( ( m starting [ i ] + num ) ) ; did print = bool ; } if ( i == ( m starting . length - num ) ) { f . append ( str ) ; } else { if ( did print ) { f . append ( str ) ; } } } return f . to string ( ) ; }	converts the array of starting attributes to a string.
public static string make tag class name ( string component family , string renderer type ) { if ( component family == null ) { return null ; } string tag class name = component family ; if ( renderer type != null ) { if ( ! component family . equals ( renderer type ) ) { tag class name = tag class name + renderer type ; } } return tag class name + str ; }	build the tag handler class name from componentfamily and renderertype .
public static void assert almost equals ( double expected , double actual , int decimals ) { assert almost equals ( null , new double ( expected ) , new double ( actual ) , decimals ) ; }	tests whether numbers are the same up to the specified decimals .
private static int snap vertical ( collection < constraint widget > widgets , constraint widget widget , constraint anchor anchor , int position , array list < snap candidate > snap candidates ) { snap candidate candidate = new snap candidate ( ) ; constraint handle handle = widget interaction targets . constraint handle ( anchor ) ; if ( handle == null ) { return position ; } handle . set draw y ( position ) ; snap placement . snap anchor ( widgets , widget , anchor , candidate ) ; if ( candidate . target != null ) { constraint handle target handle = widget interaction targets . constraint handle ( candidate . target ) ; int ty = candidate . y ; if ( target handle != null ) { ty = target handle . get draw y ( ) ; } position = ty + candidate . margin ; snap candidates . add ( candidate ) ; } return position ; }	utility function to gather snap candidates on the vertical axis.
public int send ( output stream out ) throws io { out . write ( this . file buff , this . offset , this . length ) ; return num ; }	send file content callback function , be called only once when the file uploaded.
private double sin ( double angle ) { while ( angle >= num ) { angle -= num ; } double value = ( angle / num * math . pi ) ; return math . sin ( value ) ; }	gets the sinus of the angle .
public static string last ( string list , string delimiter , boolean ignore empty ) { if ( string util . is empty ( list ) ) return str ; int len = list . length ( ) ; char [ ] del ; if ( string util . is empty ( delimiter ) ) { del = new char [ ] { str } ; } else del = delimiter . to char array ( ) ; int index ; int x ; while ( bool ) { index = - num ; for ( int i = num ; i < del . length ; i ++ ) { x = list . last index of ( del [ i ] ) ; if ( x > index ) index = x ; } if ( index == - num ) { return list ; } else if ( index + num == len ) { if ( ! ignore empty ) return str ; list = list . substring ( num , len - num ) ; len -- ; } else { return list . substring ( index + num ) ; } } }	return last element of the list.
private void try parse type attribute ( idom element ) { idom type attr = ( idom ) ui binder xml model utilities . get type attribute ( element ) ; if ( type attr == null ) { return ; } i value region = xml utilities . get attribute value region ( type attr ) ; if ( value region == null ) { return ; } string fq type = type attr . get node value ( ) ; if ( fq type == null ) { return ; } final i type = java model search . find type ( java project , fq type ) ; if ( ! java model search . is valid element ( type ) ) { problem marker manager . set type undefined error ( value region , fq type ) ; } else { if ( ui binder xml model utilities . is style element ( element ) ) { i css resource type = client bundle utilities . find css resource type ( java project ) ; if ( css resource type != null ) { try { if ( ! java utilities . is subtype ( css resource type , type ) ) { problem marker manager . set not css resource subtype error ( value region , fq type ) ; } } catch ( java model exception e ) { gwt . log warning ( e , str ) ; } } } } java type references . add ( fq type ) ; }	parses the " type " attribute on < ui : with > and < ui : style > elements .
public static list < m > retrieve types ( final po po , final int window id ) { if ( po . get ( ) . length != num ) { logger . severe ( po + str + po . get ( ) . length + str ) ; po . throw wrong key column count ( po ) ; } final string key column = po . get ( ) [ num ] ; final int col id = m . get column id ( po . get ( ) , key column ) ; final prepared statement pstmt = db . prepare statement ( sql , po . get ( ) ) ; result set rs = null ; try { pstmt . set int ( num , po . get id ( ) ) ; pstmt . set int ( num , col id ) ; rs = pstmt . execute query ( ) ; final list < m > result = eval result set ( po , window id , rs ) ; logger . info ( str + result . size ( ) + str + po ) ; return result ; } catch ( sql e ) { logger . severe ( e . get message ( ) ) ; throw new adempiere exception ( e ) ; } finally { db . close ( rs , pstmt ) ; } }	returns the types that define a relation which contains the given po.
public jdp jmx packet ( byte [ ] data ) throws jdp exception { jdp packet reader reader ; reader = new jdp packet reader ( data ) ; map < string , string > p = reader . get discovery data as map ( ) ; string s id = p . get ( uuid key ) ; this . id = ( s id == null ) ? null : uuid . from string ( s id ) ; this . jmx service url = p . get ( jmx service url key ) ; this . main class = p . get ( main class key ) ; this . instance name = p . get ( instance name key ) ; this . process id = p . get ( process id key ) ; this . rmi hostname = p . get ( rmi hostname key ) ; this . broadcast interval = p . get ( broadcast interval key ) ; }	create new instance from network data parse packet and set fields .
private uid range parse uid range ( string range ) throws decoding exception { int pos = range . index of ( str ) ; try { if ( pos == - num ) { if ( range . length ( ) == num && range . char at ( num ) == str ) { return new uid range ( message uid . max value ) ; } else { long value = parse unsigned integer ( range ) ; return new uid range ( message uid . of ( value ) ) ; } } else { long val1 = parse unsigned integer ( range . substring ( num , pos ) ) ; long val2 = parse unsigned integer ( range . substring ( pos + num ) ) ; if ( val1 == long . max value && val2 == long . max value ) { return new uid range ( message uid . max value ) ; } else if ( val1 <= val2 ) { return new uid range ( message uid . of ( val1 ) , message uid . of ( val2 ) ) ; } else if ( val1 == long . max value ) { return new uid range ( message uid . of ( val2 ) , message uid . max value ) ; } else { return new uid range ( message uid . of ( val2 ) , message uid . of ( val1 ) ) ; } } } catch ( number format exception e ) { throw new decoding exception ( human readable text . invalid messageset , str , e ) ; } }	parse a range which use a " : " as delimiter.
public void add fxgl ( fxgl listener ) { system listeners . add ( listener ) ; }	add listener for core fxgl callbacks .
public void add definition ( string definition ) { if ( ! string utils . is empty ( definition ) ) { definitions . add ( definition ) ; } }	adds a project preprocessor definition.
@ override public void receive event ( client state information information ) { if ( information . get state ( ) != current state ) { logger . info ( str + information ) ; if ( information . get state ( ) == client state . search ) { search start time = system . current time millis ( ) ; for ( sequence output variable factory < ? > factory : sequence output variable factories . values ( ) ) { factory . set start time ( search start time ) ; } } output variable < long > time = new output variable < long > ( str + current state . get name ( ) , system . current time millis ( ) - current state started ) ; output variables . put ( time . get name ( ) , time ) ; current state = information . get state ( ) ; current state started = system . current time millis ( ) ; } }	process status update event received from client.
public void test case11 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; int a sign = num ; int b sign = - num ; byte r bytes [ ] = { num , num , num , num , num , num , num , num , num , num , num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . subtract ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( num , result . signum ( ) ) ; }	subtract two numbers of different length and different signs.
public void add bug code ( bug code bug code ) { bug code list . add ( bug code ) ; }	add a bugcode reported by the plugin .
@ override public final void write ( int b ) { if ( this . ignore writes ) return ; check if writable ( ) ; ensure capacity ( num ) ; buffer . put ( ( byte ) b ) ; }	write the low - order 8 bits of the given int.
public void test nested allocation contexts ( ) { final i context = manager . new allocation context ( bool ) ; final string test = str ; final long addr1 = allocate ( manager , context , test ) ; final long addr2 = allocate ( manager , context , test ) ; assert true ( addr1 != addr2 ) ; final string res = get string ( addr1 ) ; assert true ( res . equals ( test ) ) ; manager . free ( addr1 , context ) ; final long addr3 = allocate ( manager , context , test ) ; assert true ( addr1 != addr3 ) ; manager . detach context ( context ) ; final i context2 = manager . new allocation context ( bool ) ; final long addr4 = allocate ( manager , context2 , test ) ; assert true ( addr1 == addr4 ) ; }	rather than creating contexts directly , instead associate with externally created context .
public static string underlines to camel case ( string string ) { string builder sb = new string builder ( string . length ( ) ) ; int n = string . length ( ) ; int i = num ; boolean upcase next = bool ; for ( ; i < n ; i ++ ) { char c = string . char at ( i ) ; if ( c == str ) { upcase next = bool ; } else { if ( upcase next ) { c = character . to upper case ( c ) ; } upcase next = bool ; sb . append ( c ) ; } } return sb . to string ( ) ; }	converts an underlined_word into a camelcase word.
protected best match finder ( string pattern ) { search pattern = pattern . to lower case ( ) ; }	creates a match finder for a given search pattern .
public int index of ( object key ) { return key == null ? index of null ( ) : index of ( key , key . hash code ( ) ) ; }	returns the index of a value in the set .
public long next action millis ( long now , long next retry time millis ) { for ( file download info info : downloads ) { long individual retry time millis = get next action millis for ( now , info ) ; next retry time millis = math . min ( individual retry time millis , next retry time millis ) ; } return next retry time millis ; }	return time when this download will be ready for its next action , in milliseconds after given time .
public integer count pages containing template names ( list < string > template names ) throws wiki api exception { return count filtered pages ( template names , bool ) ; }	returns the number of all pages that contain a template the name of which equals the given string .
static url fix pure query targets ( url base , string target ) throws url { if ( ! target . starts with ( str ) ) return new url ( base , target ) ; string base path = base . get path ( ) ; string base right most = str ; int base right most idx = base path . last index of ( str ) ; if ( base right most idx != - num ) { base right most = base path . substring ( base right most idx + num ) ; } if ( target . starts with ( str ) ) target = base right most + target ; return new url ( base , target ) ; }	handle the case in rfc3986 section 5.
synchronized void add ( object obj ) { if ( obj list != null ) { obj list . add ( obj ) ; } }	adds the specified reference to this dgcackhandler .
public void sort ( ) { collections . sort ( individuals , performance comparator ) ; }	sorts the individuals in ascending order according to their performance , thus the best one will be in last position .
void free interval ( spill location interval i ) { free intervals . add ( i ) ; }	records that a particular interval is potentially available for reuse .
private void check and write dictionary chunk to file ( ) throws io { if ( one dictionary chunk list . size ( ) >= dictionary one chunk size ) { write dictionary file ( ) ; create chunk list ( ) ; } }	check if the threshold has been reached for the number of values that can kept in memory and then flush the data to file.
private void ctrl select ( d node data ) { int insertion index = get insertion index ( node data ) ; insert and select node ( node data , insertion index , ! node data . equals ( selected nodes . get ( insertion index ) ) ) ; }	if ctrl is depressed then we simply search for the insertion point of the specified node in the already sorted select list.
private void read object ( object input stream ois ) throws io , class not found exception { byte [ ] asn1 enc principal = ( byte [ ] ) ois . read object ( ) ; byte [ ] enc realm = ( byte [ ] ) ois . read object ( ) ; try { realm realm object = new realm ( new der value ( enc realm ) ) ; principal name krb5 principal = new principal name ( new der value ( asn1 enc principal ) , realm object ) ; realm = realm object . to string ( ) ; full name = krb5 principal . to string ( ) ; name type = krb5 principal . get name type ( ) ; } catch ( exception e ) { throw new io ( e ) ; } }	reads this object from a stream ( i.
private static int read swapped integer ( final data input stream input ) throws io { final int value1 = input . read byte ( ) ; final int value2 = input . read byte ( ) ; final int value3 = input . read byte ( ) ; final int value4 = input . read byte ( ) ; return ( ( value1 & num ) << num ) + ( ( value2 & num ) << num ) + ( ( value3 & num ) << num ) + ( ( value4 & num ) << num ) ; }	reads a " int " value from an inputstream.
private void consume pre nested scroll ( int dx , int dy , int [ ] consumed ) { if ( m over scroll effect == over scroll effect . bounce && m unconsumed over scroll offset != num ) { int dest offset = m unconsumed over scroll offset - dy ; if ( ! math utils . same sign ( dest offset , m unconsumed over scroll offset ) ) { dest offset = num ; } else if ( math . abs ( dest offset ) > math . abs ( m unconsumed over scroll offset ) ) { dest offset = m unconsumed over scroll offset ; } consumed [ num ] = num ; consumed [ num ] = m unconsumed over scroll offset - dest offset ; m unconsumed over scroll offset = dest offset ; set scrolling offset ( get unconsumed scrolling offset ( ) ) ; } }	consume the pre nested scroll before all behaviors if need .
public str builder replace ( final int start index , int end index , final string replace str ) { end index = validate range ( start index , end index ) ; final int insert len = ( replace str == null ? num : replace str . length ( ) ) ; replace impl ( start index , end index , end index - start index , replace str , insert len ) ; return this ; }	replaces a portion of the string builder with another string.
public boolean is valid ( int value ) { return min <= value && value <= max ; }	performs basic sanity check of argument .
public plugins info info ( ) { return info ; }	get information about plugins ( jvm and site plugins ) .
public void fire property change ( string property name , int old value , int new value ) { fire property change ( property name , integer . value of ( old value ) , integer . value of ( new value ) ) ; }	fires a property change of an integer property with the given name.
static array list < field > all fields ( final class < ? > clazz ) { final array list < field > res = new array list < > ( ) ; class < ? > cl = clazz ; while ( cl != null ) { final field [ ] fields = cl . get declared fields ( ) ; collections . add all ( res , fields ) ; cl = cl . get superclass ( ) ; } return res ; }	get all the fields in this class and its super - classes .
private void update weather states ( ) { boolean changed = temperature . update ( ) ; changed |= rain . update ( ) ; changed |= fog . update ( ) ; changed |= thunder . update ( ) ; if ( changed ) { update zones ( ) ; } }	update the zone weather states .
public static render loops make render loops ( surface type src , composite type comp , surface type dst ) { render loops loops = new render loops ( ) ; loops . draw line loop = draw line . locate ( src , comp , dst ) ; loops . fill rect loop = fill rect . locate ( src , comp , dst ) ; loops . draw rect loop = draw rect . locate ( src , comp , dst ) ; loops . draw polygons loop = draw polygons . locate ( src , comp , dst ) ; loops . draw path loop = draw path . locate ( src , comp , dst ) ; loops . fill path loop = fill path . locate ( src , comp , dst ) ; loops . fill spans loop = fill spans . locate ( src , comp , dst ) ; loops . fill parallelogram loop = fill parallelogram . locate ( src , comp , dst ) ; loops . draw parallelogram loop = draw parallelogram . locate ( src , comp , dst ) ; loops . draw glyph list loop = draw glyph list . locate ( src , comp , dst ) ; loops . draw glyph list aa = aa . locate ( src , comp , dst ) ; loops . draw glyph list lcd = lcd . locate ( src , comp , dst ) ; return loops ; }	construct and return a renderloops object containing all of the basic graphicsprimitive objects for rendering to the destination surface with the given source , destination , and composite types .
public void edit ( object plot canvas ) { string label = j . show input dialog ( ( plot canvas ) plot canvas , str , label ) ; if ( label != null ) { set legend ( label ) ; } }	opens a dialog window and asks the user for the name of this axis .
protected boolean exclude file ( string file ) { if ( excluded == null ) return bool ; iterator < string > iter = excluded . iterator ( ) ; while ( iter . has next ( ) ) if ( file . ends with ( iter . next ( ) ) ) return bool ; return bool ; }	check if a file is excluded or not.
public builder delete user type ( ) { delete fields . add ( str ) ; return this ; }	deletes the user type of a existing user.
public final static boolean ends with ignore case ( string str , string end ) { int str length = str == null ? num : str . length ( ) ; int end length = end == null ? num : end . length ( ) ; if ( end length > str length ) return bool ; for ( int i = num ; i <= end length ; i ++ ) { if ( scanner helper . to lower case ( end . char at ( end length - i ) ) != scanner helper . to lower case ( str . char at ( str length - i ) ) ) return bool ; } return bool ; }	returns true iff str.
public void write ( int c ) throws io { internal out . write ( c ) ; }	writes a single character .
private < t extends client request result > collection < t > execute request ( final collection < long > ids , final class < t > clazz , final client request report listener report listener , final string request queue ) { logger . debug ( str ) ; client request impl < t > client request = new client request impl < t > ( clazz ) ; iterator < long > it = ids . iterator ( ) ; collection < future < collection < t > > > results = new array list < future < collection < t > > > ( ) ; int counter = num ; while ( it . has next ( ) ) { while ( it . has next ( ) && counter < max request size ) { client request . add tag id ( it . next ( ) ) ; counter ++ ; } request values task < t > task = new request values task < t > ( client request , report listener , request queue ) ; results . add ( executor . submit ( task ) ) ; client request = new client request impl < t > ( clazz ) ; counter = num ; } collection < t > final collection = new array list < t > ( ) ; for ( future < collection < t > > result : results ) { try { final collection . add all ( result . get ( ) ) ; } catch ( interrupted exception e ) { logger . error ( str , e ) ; throw new runtime exception ( e ) ; } catch ( execution exception e ) { logger . error ( str , e ) ; throw new runtime exception ( e ) ; } } logger . debug ( str ) ; return final collection ; }	splits and executes a id - base request , splitting the collection into smaller requests .
public static map < string , integer > class names to mapping ( list < string > labels ) { map < string , integer > mapping = new hash map < string , integer > ( ) ; for ( int i = num ; i < labels . size ( ) ; i ++ ) { mapping . put ( labels . get ( i ) , i ) ; } return mapping ; }	from a list of labels , creates a mapping from strings to indices .
public static string short number ( int number ) { if ( number >= num ) { int hundred = number % num / num ; if ( hundred != num ) return string . format ( str , number / num ) + str ; else return ( number / num ) + str ; } else return number + str ; }	1000 - > 1k , 1100 - > 1 . 1k.
public static void put unsigned short ( byte buffer bb , int v ) { bb . put short ( ( short ) ( v & num ) ) ; }	put an unsigned short into the specified bytebuffer at the current position.
public static string read file to string ( file f ) throws io { string writer sw = new string writer ( ) ; io . copy and close both ( common . as reader ut ( new file input stream ( f ) ) , sw ) ; return sw . to string ( ) ; }	read the contents of the given file into a string.
public void test wrap 05 ( ) { string host = str ; int port = num ; byte buffer bb = byte buffer . allocate ( num ) ; byte buffer [ ] bb a = { byte buffer . allocate ( num ) , byte buffer . allocate ( num ) , byte buffer . allocate ( num ) } ; ssl sse = get engine ( host , port ) ; sse . set use client mode ( bool ) ; try { ssl res = sse . wrap ( bb a , bb ) ; assert equals ( num , res . bytes consumed ( ) ) ; assert equals ( num , res . bytes produced ( ) ) ; } catch ( exception ex ) { fail ( str + ex ) ; } }	javax . net . ssl . sslengine # wrap ( bytebuffer [ ] srcs , bytebuffer dst ).
public void test topic dinamically included behavior ( ) throws exception { start all brokers ( ) ; destination dest = create destination ( str , bool ) ; message consumer client a = create consumer ( str , dest ) ; message consumer client b = create consumer ( str , dest ) ; thread . sleep ( num * num ) ; send messages ( str , dest , message count ) ; message id list msgs a = get consumer messages ( str , client a ) ; msgs a . wait for messages to arrive ( message count ) ; assert equals ( message count , msgs a . get message count ( ) ) ; message id list msgs b = get consumer messages ( str , client b ) ; msgs b . wait for messages to arrive ( message count ) ; assert equals ( num , msgs b . get message count ( ) ) ; }	brokera - > brokerb & & brokerb - > brokera.
private file create capture file ( int encoding type , string file name ) { if ( file name . is empty ( ) ) { file name = str ; } if ( encoding type == jpeg ) { file name = file name + str ; } else if ( encoding type == png ) { file name = file name + str ; } else { throw new illegal argument exception ( str + encoding type ) ; } return new file ( get temp directory path ( ) , file name ) ; }	create a file in the applications temporary directory based upon the supplied encoding .
public boolean validate token ( endpoint specification endpoint specification , security token to be validated token ) throws sts { sts client = get sts ( sts instance wsdl url , endpoint specification . service q , endpoint specification . port q ) ; client . set token type ( sts . status ) ; try { client . validate security token ( to be validated token ) ; return bool ; } catch ( trust exception e ) { return bool ; } catch ( exception e ) { throw new sts ( e . get message ( ) , e ) ; } }	invokes the soap - sts validate operation.
public static string strip function tags ( string label ) { if ( label . index of ( str ) > num ) return label . substring ( num , label . index of ( str ) ) ; else return label ; }	strips function tags from a given node label.
@ override public void play new video ( meta data current item meta data , video player view video player view , string video url ) { if ( show logs ) logger . v ( tag , str + video player view + str + m current player + str + video player view ) ; m player handler . pause queue processing ( tag ) ; boolean current player is active = m current player == video player view ; boolean is already playing the file = m current player != null && video url . equals ( m current player . get video url data source ( ) ) ; if ( show logs ) logger . v ( tag , str + is already playing the file ) ; if ( show logs ) logger . v ( tag , str + current player is active ) ; if ( current player is active ) { if ( is in playback state ( ) && is already playing the file ) { if ( show logs ) logger . v ( tag , str + video player view + str + m current player state ) ; } else { start new playback ( current item meta data , video player view , video url ) ; } } else { start new playback ( current item meta data , video player view , video url ) ; } m player handler . resume queue processing ( tag ) ; if ( show logs ) logger . v ( tag , str + video player view + str + video url ) ; }	call it if you have direct url or path to video source the logic is following : 1.
private void add trace and type ( string name ) { if ( traces type . get ( name ) == null ) { traces . add ( create trace ( name , trace type . real ) ) ; traces type . put ( name , trace type . real ) ; } else { traces . add ( create trace ( name , traces type . get ( name ) ) ) ; } }	add a trace for a statistic of the given name.
public static boolean is reserved stream name ( string name ) { return name . starts with ( str ) ; }	is it a reserved stream name in bkdl namespace ?.
public static volume mount [ ] format original container volume mount ( log draft log draft ) { list < volume mount > volume mounts = new array list < > ( ) ; int idx suffix = num ; for ( log item draft log item draft : log draft . get log item drafts ( ) ) { if ( log item draft . is auto collect ( ) || log item draft . is auto delete ( ) ) { volume mount volume mount = new volume mount ( ) ; volume mount . set name ( str + idx suffix ) ; volume mount . set mount path ( log item draft . get log parent path ( log item draft . get log path ( ) ) ) ; volume mounts . add ( volume mount ) ; idx suffix ++ ; } } return volume mounts . to array ( new volume mount [ ] { } ) ; }	if a container sets log path , then we need to mount the log path so that the flume container can access the log file.
public static double dnorm ( double x ) { return math . exp ( - x * x / num ) * psi ; }	returns the density of the standard normal .
public static long checksum cr ( file file ) throws io { cr crc = new cr ( ) ; checksum ( file , crc ) ; return crc . get value ( ) ; }	computes the checksum of a file using the crc32 checksum routine.
private void cmd annotate difference ( ) { big decimal previous value , actual value , difference ; previous value = ( big decimal ) v previous balance . get value ( ) ; actual value = ( big decimal ) v . get value ( ) ; difference = actual value . subtract ( previous value ) ; m cash book = new m ( p ctx , p pos . get c id ( ) , null ) ; timestamp today = time util . get day ( system . current time millis ( ) ) ; m cash = m . get ( p ctx , cash book . get c id ( ) , today , null ) ; if ( cash != null && cash . get id ( ) != num && difference . compare to ( cash . get statement difference ( ) ) != num ) { m cl = new m ( cash ) ; cl . set cash type ( m . cashtype ) ; cl . set amount ( difference ) ; cl . set description ( msg . translate ( p pos . get ctx ( ) , str ) + previous value + str + actual value ) ; cl . save ex ( ) ; } cash = m . get ( p pos . get ctx ( ) , p pos . get c id ( ) , today , null ) ; v previous balance . set value ( cash . get ending balance ( ) ) ; v . set value ( env . zero ) ; v difference . set value ( env . zero ) ; }	annotate the difference between previous balance and actual from cash scrutiny in the cash book.
public void write ( output stream out , java . util . list < figure > figures ) throws io { d . double drawing rect = null ; for ( figure f : figures ) { if ( drawing rect == null ) { drawing rect = f . get bounds ( ) ; } else { drawing rect . add ( f . get bounds ( ) ) ; } } affine transform tx = new affine transform ( ) ; tx . translate ( - math . min ( num , drawing rect . x ) , - math . min ( num , drawing rect . y ) ) ; write ( out , figures , tx , new dimension ( ( int ) ( math . abs ( drawing rect . x ) + drawing rect . width ) , ( int ) ( math . abs ( drawing rect . y ) + drawing rect . height ) ) ) ; }	all other write methods delegate their work to here .
fixed allocator ( final rw store , final int size ) { m disk addr = num ; m store = store ; m size = size ; m bit size = calc bit size ( bool , size , c min allocation , c mod allocation ) ; alloc block range = num * m bit size ; final int num blocks = num / ( m bit size + num ) ; m alloc blocks = new array list < alloc block > ( num blocks ) ; for ( int i = num ; i < num blocks ; i ++ ) { m alloc blocks . add ( new alloc block ( num , m bit size , this ) ) ; } m free transients = num ; m free bits = num * m bit size * num blocks ; }	calculating the number of ints ( m_bitsize ) cannot rely on a power of 2.
private void build get storage response ( mock closeable http response response , uri uri ) throws jaxb { pattern pattern = pattern . compile ( str ) ; matcher matcher = pattern . matcher ( uri . get path ( ) ) ; if ( matcher . find ( ) ) { storage storage = get new storage ( matcher . group ( num ) ) ; response . set entity ( get http entity ( storage ) ) ; } }	builds a get storage response .
public void assert equals ( string assert id , string expected , string actual ) { framework . assert equals ( this , assert id , expected , actual ) ; }	asserts that expected . equals ( actual ) is true.
public boolean on preference change ( preference preference , object new value ) { if ( boolean . parse boolean ( system properties . get ( telephony properties . property inecm mode ) ) ) { } else { set airplane mode on ( ( boolean ) new value ) ; } return bool ; }	called when someone clicks on the checkbox preference .
public static int estimate band pass order ( int sample rate , int pass band start , int pass band end , double pass band ripple db , double stop band ripple db ) { double df = ( double ) math . abs ( pass band end - pass band start ) / ( double ) sample rate ; double ddp = ( double ) math . log10 ( pass band ripple db ) ; double dds = ( double ) math . log10 ( stop band ripple db ) ; double a1 = num ; double a2 = num ; double a3 = - num ; double a4 = num ; double a5 = - num ; double a6 = - num ; double t1 = a1 * ddp * ddp ; double t2 = a2 * ddp ; double t3 = a4 * ddp * ddp ; double t4 = a5 * ddp ; double cinf = dds * ( t1 + t2 + a3 ) + t3 + t4 + a6 ; double ginf = - num * ( double ) math . log10 ( pass band ripple db / stop band ripple db ) - num ; double n = cinf / df + ginf * df + num ; return ( int ) math . ceil ( n ) ; }	estimates band pass filter length ;.
static public object string to value ( string s ) { if ( s . equals ( str ) ) { return s ; } if ( s . equals ignore case ( str ) ) { return boolean . true ; } if ( s . equals ignore case ( str ) ) { return boolean . false ; } if ( s . equals ignore case ( str ) ) { return json . null ; } char b = s . char at ( num ) ; if ( ( b >= str && b <= str ) || b == str || b == str || b == str ) { if ( b == str && s . length ( ) > num && ( s . char at ( num ) == str || s . char at ( num ) == str ) ) { try { return new integer ( integer . parse int ( s . substring ( num ) , num ) ) ; } catch ( exception ignore ) { } } try { if ( s . index of ( str ) > - num || s . index of ( str ) > - num || s . index of ( str ) > - num ) { return double . value of ( s ) ; } else { long my long = new long ( s ) ; if ( my long . long value ( ) == my long . int value ( ) ) { return new integer ( my long . int value ( ) ) ; } else { return my long ; } } } catch ( exception ignore ) { } } return s ; }	try to convert a string into a number , boolean , or null.
private float [ ] calc border values ( ) { float max = integer . min value ; float min = integer . max value ; for ( chart set set : chart view . data ) { for ( chart entry e : set . get entries ( ) ) { if ( e . get value ( ) >= max ) max = e . get value ( ) ; if ( e . get value ( ) <= min ) min = e . get value ( ) ; } } return new float [ ] { min , max } ; }	calculates the min / max value .
public static object apply or call ( boolean is apply , context cx , scriptable scope , scriptable this obj , object [ ] args ) { int l = args . length ; callable function = get callable ( this obj ) ; scriptable call this = null ; if ( l != num ) { call this = to object or null ( cx , args [ num ] ) ; } if ( call this == null ) { call this = get top call scope ( cx ) ; } object [ ] call args ; if ( is apply ) { call args = l <= num ? script runtime . empty args : get apply arguments ( cx , args [ num ] ) ; } else { if ( l <= num ) { call args = script runtime . empty args ; } else { call args = new object [ l - num ] ; system . arraycopy ( args , num , call args , num , l - num ) ; } } return function . call ( cx , scope , call this , call args ) ; }	function . prototype . apply and function . prototype . call see ecma 15 . 3 . 4 . [ 34 ].
public static void remove all children ( node node ) { node list children = node . get child nodes ( ) ; for ( int i = num , length = children . get length ( ) ; i < length ; i ++ ) { node . remove child ( children . item ( i ) ) ; } }	removes all children nodes from the specified node .
private void add unit to external qual map ( final class < ? extends annotation > anno class ) { annotation mirror mirror = units relations tools . build anno mirror with no prefix ( processing env , anno class ) ; if ( ! is aliased annotation ( mirror ) ) { string unit class name = anno class . get canonical name ( ) ; if ( ! external quals map . contains key ( unit class name ) ) { external quals map . put ( unit class name , anno class ) ; } } else { class < ? extends annotation > base unit class = get base unit anno class ( mirror ) ; if ( base unit class != null ) { string base unit class name = base unit class . get canonical name ( ) ; if ( ! external quals map . contains key ( base unit class name ) ) { load external unit ( base unit class name ) ; } aliased annotation ( mirror ) ; } else { } } add units relations ( anno class ) ; }	adds the annotation class to the external qualifier map if it is not an alias annotation .
@ override protected void on progress update ( integer ... values ) { if ( parent != null ) { if ( values [ num ] == on cache end ) { parent . on cache end ( ) ; } else if ( values [ num ] == on cache interrupted ) { log . i ( tag , str ) ; should be stopped = bool ; parent . on cache interrupted ( ) ; } else { parent . on cache progress ( task count , values [ num ] ) ; } } }	calls the parent method to update the progress - bar in the ui while articles are refreshed .
public double dot product ( double vector v ) { return x * v . x + y * v . y + z * v . z ; }	calculates the dot product ( or " scalar product " ) of this vector with the vector v .
public om ( object id , int render type , boolean interpolate , image icon ii ) { this ( id , render type , interpolate , ii . get image ( ) , num ) ; set max scale ( num ) ; set min scale ( num ) ; }	create an scaling icon that will be moved around .
@ override public void characters ( char [ ] ch , int start , int length ) throws sax { m string builder . append ( ch , start , length ) ; }	overrides org . xml . sax . helpers . defaulthandler # characters ( char [ ] , int , int ).
public int max length ( ) { if ( m is paired ) { return ( int ) math . max ( m left . max length ( ) , m right . max length ( ) ) ; } else { return ( int ) m single . max length ( ) ; } }	convenience method for getting the maximum sequence length.
public boolean equals ignore case ( str builder other ) { if ( this == other ) { return bool ; } if ( this . size != other . size ) { return bool ; } char this buf [ ] = this . buffer ; char other buf [ ] = other . buffer ; for ( int i = size - num ; i >= num ; i -- ) { char c1 = this buf [ i ] ; char c2 = other buf [ i ] ; if ( c1 != c2 && character . to upper case ( c1 ) != character . to upper case ( c2 ) ) { return bool ; } } return bool ; }	checks the contents of this builder against another to see if they contain the same character content ignoring case .
public path parser ( string path string ) { this . path string = path string . to char array ( ) ; }	create a path parser for the given path string .
public lua table ( varargs varargs , int firstarg ) { int nskip = firstarg - num ; int n = math . max ( varargs . narg ( ) - nskip , num ) ; presize ( n , num ) ; set ( n , value of ( n ) ) ; for ( int i = num ; i <= n ; i ++ ) set ( i , varargs . arg ( i + nskip ) ) ; }	construct table of unnamed elements .
public i ( byte buffer byte buffer , string logging filename ) throws invalid frame exception , invalid data type exception { set logging filename ( logging filename ) ; read ( byte buffer ) ; }	creates a new id3v24frame datatype by reading from bytebuffer .
public void disable pan ( bluetooth adapter adapter ) { if ( m pan == null ) m pan = ( bluetooth pan ) connect proxy ( adapter , bluetooth profile . pan ) ; assert not null ( m pan ) ; long start = system . current time millis ( ) ; m pan . set bluetooth tethering ( bool ) ; long stop = system . current time millis ( ) ; assert false ( m pan . is tethering on ( ) ) ; write output ( string . format ( str , ( stop - start ) ) ) ; }	disables pan tethering on the local device and checks to make sure that tethering is disabled .
public frame < v > init ( final frame < ? extends v > src ) { return value = src . return value ; system . arraycopy ( src . values , num , values , num , values . length ) ; top = src . top ; return this ; }	copies the state of the given frame into this frame .
public boolean ready ( ) throws io { if ( input == null ) throw new io ( str ) ; if ( index == input . length ( ) ) return bool ; return bool ; }	indicates if this stream is ready to be read .
protected void handle match ( t mapping , string lookup path , server web exchange exchange ) { }	invoked when a matching mapping is found .
public boolean is use ssl ( ) { return use ssl ; }	returns true if this server requires encrypted connections .
public void start ( ) { if ( ( m prox sensor == null ) || m is active ) { return ; } m is active = bool ; m should drop events = bool ; m sensor manager . register listener ( m listener , m prox sensor , sensor manager . sensor delay ui ) ; log utils . log ( this , log . verbose , str , system . current time millis ( ) ) ; m handler . post delayed ( m filter runnable , registration event filter timeout ) ; }	starts listening for sensor events .
public void test entity declarations ( ) { assert not null ( str , sp ) ; }	android ' s parsed dom doesn ' t include entity declarations.
@ nullable private tcp discovery node resolve coordinator ( @ nullable collection < tcp discovery node > filter ) { synchronized ( mux ) { collection < tcp discovery node > excluded = f . concat ( bool , failed nodes . key set ( ) , leaving nodes ) ; if ( ! f . is empty ( filter ) ) excluded = f . concat ( bool , excluded , filter ) ; return ring . coordinator ( excluded ) ; } }	resolves coordinator . nodes that are leaving or failed ( but are still in topology ) are removed from search as well as provided filter .
public static string [ ] splitc ( string src , string d ) { if ( ( d . length ( ) == num ) || ( src . length ( ) == num ) ) { return new string [ ] { src } ; } return splitc ( src , d . to char array ( ) ) ; }	splits a string in several parts ( tokens ) that are separated by delimiter characters.
public int deflate string2 byte array ( byte [ ] input , int input offset , int input length , byte [ ] bytes ) { if ( input length >= min size for deflation ) { deflater . set input ( input , input offset , input length ) ; deflater . finish ( ) ; int compressed data length = deflater . deflate ( bytes ) ; deflater . reset ( ) ; return - compressed data length ; } else { system . arraycopy ( input , input offset , bytes , num , input length ) ; return input length ; } }	compresses a string to an array of bytes.
public marker back to ( int idx ) throws am { int size = trail . size ( ) ; if ( idx >= size ) { throw new am ( str ) ; } for ( int i = size - num ; i > idx ; -- i ) { trail . remove ( i ) ; } return ( marker ) trail . get ( idx ) ; }	discards items from a given index ( exclusive ) to the end .
private static long copy ( input stream source , output stream sink ) throws io { long nread = num ; byte [ ] buf = new byte [ buffer size ] ; int n ; while ( ( n = source . read ( buf ) ) > num ) { sink . write ( buf , num , n ) ; nread += n ; } return nread ; }	reads all bytes from an input stream and writes them to an output stream .
public byte [ ] pack ( ) { if ( entries . size ( ) == num ) return null ; int entry length = owner . get type ( ) . nodes entry length ; byte [ ] buffer = new byte [ entries . size ( ) * entry length ] ; int max items = buffer . length / num ; int j = num ; for ( k e : entries ) { if ( j >= max items ) { break ; } pack util . pack bucket entry ( e , buffer , j * entry length , owner . get type ( ) ) ; j ++ ; } return buffer ; }	packs the results in a byte array .
public string to string ( ) { string buffer sb = new string buffer ( str ) ; for ( int i = num ; i < permissions . length ; i ++ ) { if ( i > num ) { sb . append ( str ) ; } sb . append ( permissions [ i ] ) ; } sb . append ( str ) ; return sb . to string ( ) ; }	returns a string representation of this object .
public void test invalid after close ( ) throws io { path temp path = create temp dir ( ) ; directory dir = get directory ( temp path ) ; lock l = dir . obtain lock ( str ) ; l . close ( ) ; expect throws ( already closed exception . class , null ) ; dir . close ( ) ; }	test ensurevalid throws exception after close.
public static gds type rule excludes ( string ... excluded types ) { final set < string > excluded types set = new hash set < > ( arrays . as list ( excluded types ) ) ; return new gds type rule ( not ( is in ( excluded types set ) ) ) ; }	creates an instance with a list of excluded test types .
public final set < string > aliases ( ) { if ( alias set != null ) return alias set ; int n = aliases . length ; hash set < string > hs = new hash set < string > ( n ) ; for ( int i = num ; i < n ; i ++ ) hs . add ( aliases [ i ] ) ; alias set = collections . unmodifiable set ( hs ) ; return alias set ; }	returns a set containing this charset ' s aliases .
public synchronized void unweave ( byte string id ) { if ( woven . contains key ( id ) ) { removed . add ( woven . remove ( id ) ) ; } }	remove the indicated weave on next installation.
private static map < string , virtual file > find siblings ( @ nullable virtual file directory , project project , set < virtual file > seen ) { if ( directory == null ) { return collections . empty map ( ) ; } else { if ( seen . contains ( directory ) ) { return find siblings ( null , project , seen ) ; } seen . add ( directory ) ; virtual file settings = directory . find child ( sdk constants . fn settings gradle ) ; if ( settings == null ) { return find siblings ( directory . get parent ( ) , project , seen ) ; } else { return gradle module importer . get sub projects ( settings , project ) ; } } }	recursively go up the file system tree to find parent project with settings.
@ override public int hash code ( ) { return arrays . hash code ( new immutable pair [ ] { ( immutable pair ) first , ( immutable pair ) second } ) ; }	returns a hash code value for this object .
@ suppress lint ( str ) public static string replace unicode digits ( string number ) { string builder normalized digits = new string builder ( number . length ( ) ) ; for ( char c : number . to char array ( ) ) { int digit = character . digit ( c , num ) ; if ( digit != - num ) { normalized digits . append ( digit ) ; } else { normalized digits . append ( c ) ; } } return normalized digits . to string ( ) ; }	replace arabic / unicode digits with decimal digits .
public string frie name ( string value ) { if ( value == null || value . length ( ) == num ) return str ; string ret value = value ; string sql = str ; try { prepared statement pstmt = db . prepare statement ( sql , null ) ; pstmt . set string ( num , value ) ; result set rs = pstmt . execute query ( ) ; if ( rs . next ( ) ) ret value = rs . get string ( num ) ; rs . close ( ) ; pstmt . close ( ) ; } catch ( sql e ) { log . log ( level . severe , sql , e ) ; } return ret value ; }	frie value - convert to standardized name.
public static boolean is compressed ( file file ) { input stream fis = null ; try { if ( file . exists ( ) ) { fis = new file input stream ( file ) ; int mag1 = fis . read ( ) ; int mag2 = fis . read ( ) ; fis . close ( ) ; return select compression provider ( mag1 , mag2 ) != null ; } } catch ( io e ) { log . log ( level . finest , str + file + str , e ) ; return bool ; } finally { safe close . close ( fis ) ; } return bool ; }	is a file compressed ? ( the magic number in the first 2 bytes is used to detect the compression .
@ override public int read int ( string file path ) { file channel file channel = update cache ( file path ) ; byte buffer byte bffer = read ( file channel , carbon common constants . int size in byte ) ; return byte bffer . get int ( ) ; }	this method will be used to read int from file from postion ( offset ) , here length will be always 4 bacause int byte size if 4.
private synchronized void close output stream quietly ( ) { if ( ! m closed ) { try { m output stream . close ( ) ; report decoded size if applicable ( ) ; } catch ( io e ) { c . write to console ( m network peer manager , console . message level . error , console . message source . network , str + e ) ; } finally { m closed = bool ; } } }	attempts to close all the output stream , and swallows any exceptions .
public void bind ( string address , service ref amp link service ) { link service map . put ( address , link service ) ; service close list . add ( link service ) ; }	adds a new link actor .
public boolean might have multi font metrics ( ) { return font config != null ; }	is it possible that this font ' s metrics require the multi - font calls ? this might be true , for example , if the font supports kerning .
private static boolean check offset ( string value , int offset , char expected ) { return ( offset < value . length ( ) ) && ( value . char at ( offset ) == expected ) ; }	check if the expected character exist at the given offset in the value .
void add split ( string split path ) { string [ ] splits = split path . split ( str ) ; for ( string split : splits ) { split = split . trim ( ) ; if ( split . starts with ( str ) ) throw new runtime exception ( str + split ) ; if ( split . length ( ) == num ) continue ; add field ( split , split , bool , bool ) ; } }	a ' | ' separated list of path expressions which define sub sections of the json stream that are to be emitted as separate records . it is possible to have multiple levels of split one for parent and one for child each child record ( or a list of records ) will be emitted as a part of the parent record with null as the key.
public void sort array ( t [ ] d , comparator < t > c ) { this . data = d ; this . comp = c ; int len = math . max ( ( int ) ( num * math . log ( d . length ) ) , temp size ) ; len = math . min ( d . length , len ) ; @ suppress warnings ( str ) t [ ] t = ( t [ ] ) new object [ len ] ; this . temp = t ; merge sort ( num , d . length - num ) ; }	sort an array using the given comparator .
public void cache unit ( unit interface unit ) { all units . add ( unit ) ; }	add new unit to cache.
public component find by name ( string name , component root component ) { component c = ( component ) root component . get client property ( str + name + str ) ; if ( c == null ) { container new root = get root ancestor ( root component ) ; if ( new root != null && root component != new root ) { return find by name ( name , new root ) ; } } return c ; }	finds the given component by its name.
protected void fetch metadata ( ) throws io { remaining = period ; int size = in . read ( ) ; if ( size < num ) return ; size <<= num ; if ( mbuffer . length < size ) { mbuffer = null ; mbuffer = new byte [ size ] ; log . d ( log , str + size + str ) ; } size = read fully ( mbuffer , num , size ) ; for ( int i = num ; i < size ; i ++ ) { if ( mbuffer [ i ] == num ) { size = i ; break ; } } string s ; try { s = new string ( mbuffer , num , size , character encoding ) ; } catch ( exception e ) { log . e ( log , str ) ; return ; } log . d ( log , str + s ) ; parse metadata ( s ) ; }	this method reads the metadata string.
public void start element ( ) { nss . push context ( ) ; in collecting mode = bool ; }	sets the current bindings aside and starts a new element context.
public final void remove helper text ( @ non null final char sequence helper text ) { ensure not null ( helper text , str ) ; ensure not empty ( helper text , str ) ; helper texts . remove ( helper text ) ; verify password strength ( ) ; }	removes a specific helper text , which should not be shown , depending on the password strength , anymore .
public final synchronized int max pv ( ) { if ( computer player == null ) return num ; return computer player . get max pv ( ) ; }	return maximum number of pvs supported by engine .
public object remove ( int index ) { range check ( index ) ; mod count ++ ; object old value = element data [ index ] ; int num moved = size - index - num ; if ( num moved > num ) system . arraycopy ( element data , index + num , element data , index , num moved ) ; element data [ -- size ] = null ; return old value ; }	removes the element at the specified position in this list.
public string read matching flags ( string text ) { clear ( ) ; if ( text . starts with ( pm separator ) ) { final string tokenizer tok = new string tokenizer ( text , pm separator ) ; while ( tok . has more tokens ( ) ) { final string flag = tok . next token ( ) ; if ( flag . equals ( pm type match ) ) { type matching = bool ; } else if ( flag . equals ( pm exact match ) ) { exact matching = bool ; } else if ( flag . equals ( pm similar match ) ) { similar matching = bool ; } else if ( flag . equals ( pm icase match ) ) { case insensitive = bool ; } else if ( flag . equals ( pm joker match ) ) { joker matching = bool ; } else { break ; } text = text . substring ( flag . length ( ) + num ) ; } if ( is any flag set ( ) ) { text = text . substring ( num ) ; } } return text ; }	read leading matching flags from the given text string and return the remaining text .
private tiny planet image create final tiny planet ( ) { m result lock . lock ( ) ; try { m result bitmap . recycle ( ) ; m result bitmap = null ; m source bitmap . recycle ( ) ; m source bitmap = null ; } finally { m result lock . unlock ( ) ; } bitmap source bitmap = create padded source image ( m source image uri , bool ) ; int width = source bitmap . get width ( ) ; int height = source bitmap . get height ( ) ; int output size = width / num ; bitmap result bitmap = bitmap . create bitmap ( output size , output size , bitmap . config . argb 8888 ) ; tiny planet native . process ( source bitmap , width , height , result bitmap , output size , m current zoom , m current angle ) ; source bitmap . recycle ( ) ; source bitmap = null ; byte array output stream jpeg = new byte array output stream ( ) ; result bitmap . compress ( compress format . jpeg , num , jpeg ) ; return new tiny planet image ( add exif ( jpeg . to byte array ( ) ) , output size ) ; }	creates the high quality tiny planet file and adds it to the media service.
private static int new float array ( jni env , int length ) { if ( trace jni ) vm . sys write ( str ) ; runtime entrypoints . check jni gc ( ) ; try { float [ ] new array = new float [ length ] ; return env . push jni ( new array ) ; } catch ( throwable unexpected ) { if ( trace jni ) unexpected . print stack trace ( system . err ) ; env . record exception ( unexpected ) ; return num ; } }	newfloatarray : create a new float array.
static int create shader ( string resource , int type ) throws io { return create shader ( resource , type , null ) ; }	create a shader object from the given classpath resource .
public model validate node against shape ( dataset dataset , uri shapes graph uri , node focus node , node shape , resource min severity , predicate < sh > constraint filter , function < rdf , string > label function , progress monitor monitor ) { model results = jena util . create memory model ( ) ; model old results = get current results model ( ) ; set current results model ( results ) ; add resource violations ( dataset , shapes graph uri , focus node , shape , shacl . get all constraint properties ( bool ) , min severity , constraint filter , results , label function , monitor ) ; set current results model ( old results ) ; return results ; }	validates a given resource against a given shape .
@ override public volatile image create back buffer ( w peer ) { component target = ( component ) peer . get target ( ) ; return new sun volatile image ( target , target . get width ( ) , target . get height ( ) , boolean . true ) ; }	creates a wgl - based backbuffer for the given peer and returns the image wrapper .
public void test single resource locking high concurrency100 ( ) throws exception { properties properties = new properties ( ) ; properties . set property ( test options . nthreads , str ) ; properties . set property ( test options . ntasks , str ) ; properties . set property ( test options . nresources , str ) ; properties . set property ( test options . min locks , str ) ; properties . set property ( test options . max locks , str ) ; properties . set property ( test options . predeclare locks , str ) ; properties . set property ( test options . sort lock requests , str ) ; do comparison test ( properties ) ; }	test where each operation locks only a single resource ( high concurrency ) .
public void push ( final double value ) { long bits = double . double to long bits ( value ) ; if ( bits == num || bits == num ) { mv . visit insn ( opcodes . dconst 0 + ( int ) value ) ; } else { mv . visit ldc insn ( value ) ; } }	generates the instruction to push the given value on the stack .
protected abstract void assign resource requests ( ) ;	assign resources from the cluster manager and matches them to run container processes on them .
public synchronized void add ( int position , abstract option option ) { abstract option search = get by name ( option . get name ( ) ) ; if ( search != null ) { log . warn ( str ) ; } else { list < abstract option > old options = new array list < abstract option > ( options ) ; options . add ( position , option ) ; option . set collection ( this ) ; list < abstract option > new options = get options ( ) ; fire indexed property change ( prop options , position , old options , new options ) ; } }	adds an abstractoption to the container at a specified position.
public boolean visiting method ( ) { return visiting method ; }	is the visitor currently visiting a method ?.
protected byte array output stream parse bytes ( byte array output stream bos ) throws io { int ch ; for ( ch = read ( ) ; ch >= num && ch != str ; ch = read ( ) ) { int b1 = ch ; int b2 = read ( ) ; int b3 = read ( ) ; int b4 = read ( ) ; if ( b4 != str ) { int chunk = ( ( base64 decode [ b1 ] << num ) + ( base64 decode [ b2 ] << num ) + ( base64 decode [ b3 ] << num ) + ( base64 decode [ b4 ] ) ) ; bos . write ( chunk > > num ) ; bos . write ( chunk > > num ) ; bos . write ( chunk ) ; } else if ( b3 != str ) { int chunk = ( ( base64 decode [ b1 ] << num ) + ( base64 decode [ b2 ] << num ) + ( base64 decode [ b3 ] ) ) ; bos . write ( chunk > > num ) ; bos . write ( chunk ) ; } else { int chunk = ( ( base64 decode [ b1 ] << num ) + ( base64 decode [ b2 ] ) ) ; bos . write ( chunk ) ; } } if ( ch == str ) peek = ch ; return bos ; }	parses a byte array .
public static void start upload activity for result ( activity activity , account account , int request code ) { intent action = new intent ( activity , upload files activity . class ) ; action . put extra ( extra account , ( account ) ) ; activity . start activity for result ( action , request code ) ; }	helper to launch the uploadfilesactivity for which you would like a result when it finished.
public void stop trace session ( int trace session id ) throws sql { try ( fb service service = attach service manager ( ) ) { service . start service action ( get trace spb ( service , isc action svc trace stop , trace session id ) ) ; queue service ( service ) ; } catch ( io ioe ) { throw new sql ( ioe ) ; } }	stops a trace session with the given trace session id.
string read substring ( string source , int ofs ) { return read substring ( source , ofs , source . length ( ) ) ; }	read an substring from source .
private synchronized boolean expunge stale entries ( ) { if ( this . size == num ) return bool ; object r ; boolean result = bool ; while ( ( r = queue . poll ( ) ) != null ) { result = bool ; single entry e = ( single entry ) r ; this . size -= e . cleanup pk table ( this . table ) ; this . non dated entry count -= e . cleanup semi unique table ( this . non dated table ) ; } return result ; }	expunge stale entries from the nondatedtable .
public void remove listener ( abstract serial transport listener listener ) { if ( listener != null ) { listeners . remove ( listener ) ; } }	removes a listener from the event callback chain.
private string restore nbt ( string str , array list < string > nbttags ) { int nbtidx = num ; for ( string capture : nbttags ) { str = str . replace ( str + nbtidx ++ , capture ) ; } return str ; }	and the reverse , restore the glorious nbt tags into a string loaded with their placeholders.
private void draw offsets ( final graphics g ) { if ( is enabled ( ) ) { g . set color ( m font color offsets ) ; } else { g . set color ( m disabled color != m bg color offset ? m disabled color : color . white ) ; } final int x = ( - m first column * m char width ) + num ; final int bytes to draw = get maximum visible bytes ( ) ; final string format string = m address mode == address mode . bi ? str : str ; for ( int i = num ; i < bytes to draw ; i += m bytes per row ) { final long address = m base address + ( m first row * m bytes per row ) + i ; final string offset string = string . format ( format string , address ) ; final int current row = i / m bytes per row ; g . draw string ( offset string , x , m padding top + ( current row * m row height ) ) ; } }	draws the offsets in the offset view .
public void touch ( date date ) { last seen = ( date ) date . clone ( ) ; }	set the time this peer was last seen to the given datetime .
public void test polyline ( ) throws exception { esri layer layer = new esri layer ( str , shape type polyline , num ) ; dbf table model model = layer . get model ( ) ; model . set decimal count ( num , ( byte ) num ) ; model . set length ( num , ( byte ) num ) ; model . set column name ( num , str ) ; model . set type ( num , ( byte ) dbf table model . type character ) ; model . set decimal count ( num , ( byte ) num ) ; model . set length ( num , ( byte ) num ) ; model . set column name ( num , str ) ; model . set type ( num , ( byte ) dbf table model . type numeric ) ; add polyline record1 ( layer ) ; add polyline record2 ( layer ) ; add polyline record3 ( layer ) ; esri graphic list list = layer . get esri graphic list ( ) ; shp output stream pos = new shp output stream ( new file output stream ( str ) ) ; int [ ] [ ] index data = pos . write geometry ( list ) ; shx output stream xos = new shx output stream ( new file output stream ( str ) ) ; xos . write index ( index data , list . get type ( ) , list . get extents ( ) ) ; dbf output stream dos = new dbf output stream ( new file output stream ( str ) ) ; dos . write model ( model ) ; }	creates a polyline shape file set.
public static int random ( int i , int j ) { return i + ( int ) ( math . random ( ) * ( j - i ) ) ; }	return a random integer between i ( inclusive ) and j ( exclusive ) .
public void remove ( string name ) { feature map . remove ( name ) ; }	removes the named feature from this set of features .
private list < column model > find columns to add ( ) { list < column model > columns to add = new array list < column model > ( ) ; for ( column model column model : m table model . get column models ( ) ) { string column name = column model . get column name ( ) ; if ( ! m table model db . contains column ( column name ) ) { columns to add . add ( column model ) ; } } return columns to add ; }	it will find the difference between class model and table model.
@ override public loader < cursor > on create loader ( int id , bundle args ) { uri uri = fm radio station . station . content uri ; string select = fm radio station . station . column station type + str ; string order = fm radio station . station . column station type + str + fm radio station . station . column station freq ; cursor loader cursor loader = new cursor loader ( this , uri , fm radio station . columns , select , new string [ ] { string . value of ( fm radio station . station type favorite ) , string . value of ( fm radio station . station type searched ) } , order ) ; return cursor loader ; }	create cursor loader to initial list view.
protected map < string , object > convert named list to map ( named list < ? > args ) { map < string , object > args map = new linked hash map < > ( ) ; if ( args != null ) { for ( map . entry < string , ? > entry : args ) { args map . put ( entry . get key ( ) , entry . get value ( ) ) ; } } return args map ; }	converts a namedlist & lt ; ? & gt ; into an ordered map for returning as json .
@ override public boolean equals ( final object other ) { if ( this == other ) { return bool ; } else if ( other == null ) { return bool ; } else if ( other instanceof expression matcher ) { final expression matcher o = ( expression matcher ) other ; if ( type matching != o . type matching ) { return bool ; } else if ( exact matching != o . exact matching ) { return bool ; } else if ( similar matching != o . similar matching ) { return bool ; } else if ( case insensitive != o . case insensitive ) { return bool ; } else { return ( joker matching == o . joker matching ) ; } } else { return bool ; } }	check for equality of two expressionmatcher objects .
public boolean has capabilities ( list < string > capabilities ) { string [ ] arr = new string [ capabilities . size ( ) ] ; capabilities . to array ( arr ) ; return has capabilities ( arr ) ; }	test to see if the capabilities array contains a given set of capabilities.
public static void assign buckets to partitions ( region < ? , ? > region ) { partitioned region pr = is partitioned check ( region ) ; recovery lock lock = null ; try { lock = pr . get recovery lock ( ) ; lock . lock ( ) ; for ( int i = num ; i < get number of buckets ( pr ) ; i ++ ) { pr . create bucket ( i , num , null ) ; } } finally { if ( lock != null ) { lock . unlock ( ) ; } } }	decide which partitions will host which buckets.
public synchronized void add listener ( listener l ) { listeners . add ( l ) ; }	adds a listener to receive progress notifications .
public boolean ends with ( final string str ) { if ( str == null ) { return bool ; } final int len = str . length ( ) ; if ( len == num ) { return bool ; } if ( len > size ) { return bool ; } int pos = size - len ; for ( int i = num ; i < len ; i ++ , pos ++ ) { if ( buffer [ pos ] != str . char at ( i ) ) { return bool ; } } return bool ; }	checks whether this builder ends with the specified string.
public void apply pattern ( string pattern ) { this . pattern = pattern ; if ( pattern tokens != null ) { pattern tokens . clear ( ) ; pattern tokens = null ; } }	apply a new pattern .
public int number of replies ( final resource comment ) { final iterator < resource > children = comment . list children ( ) ; int size = num ; while ( children . has next ( ) ) { children . next ( ) ; size ++ ; } return size ; }	get the number of replies for a given comment .
public static < t > string to string ( tree def < t > tree def , t root , function < ? super t , string > to string , string indent ) { string builder builder = new string builder ( ) ; builder . append ( to string . apply ( root ) ) ; builder . append ( str ) ; to string helper ( tree def , root , to string , indent , builder , indent ) ; return builder . to string ( ) ; }	converts the entire tree into a string - based representation .
public void clean up remote sessions ( ) { synchronized ( remote session set ) { for ( iterator iter = remote session set . iterator ( ) ; iter . has next ( ) ; ) { id session id = ( id ) iter . next ( ) ; string host server = null ; try { host server = get current host server ( session id ) ; } catch ( exception ex ) { } if ( ! server config . is local server ( host server ) ) { iter . remove ( ) ; } } } }	function to remove remote sessions when primary server is up .
public boolean column exists case sensitive ( database meta data db meta data , string table name , string column name ) throws sql { result set rs tables = db meta data . get columns ( null , null , table name , column name ) ; try { return rs tables . next ( ) ; } finally { close jdbc ( rs tables ) ; } }	checks database metadata to see if a column exists in a table.
public int read ( ) throws io { if ( ! buf . has remaining ( ) ) { return - num ; } return buf . get ( ) & num ; }	read an integer value from backed bytebuffer .
public void characters raw ( char ch [ ] , int start , int length ) throws org . xml . sax . sax { if ( is outside doc elem ( ) && xml . is white space ( ch , start , length ) ) return ; string s = new string ( ch , start , length ) ; append ( m doc . create processing instruction ( str , str ) ) ; append ( m doc . create text node ( s ) ) ; }	if available , when the disable - output - escaping attribute is used , output raw text without escaping.
private void handle release ( ) { float speed = math . max ( drag helper . get drag speed ( ) , animation speed ) ; if ( get top margin ( ) > initial margin || ( drag helper . get drag speed ( ) > animation speed && drag helper . get distance ( ) > num ) || ( get device type ( get context ( ) ) == device type . tablet && is maximized ( ) && get top margin ( ) > min margin ) ) { animate hide view ( parent height - get top margin ( ) , speed , new decelerate interpolator ( ) , bool ) ; } else { animate show view ( - ( get top margin ( ) - min margin ) , speed , new decelerate interpolator ( ) ) ; } }	handles when a drag gesture has been ended by the user .
private string normalize type value ( string type ) { if ( insert . equals ( type ) ) return insert ; if ( remove . equals ( type ) ) return remove ; return null ; }	computes the normalized type value to ensure that the implementation can use object identity rather than equality .
@ override public log seq num write to log ( ) { list < constant > rec = build record ( ) ; return log mgr . append ( rec . to array ( new constant [ rec . size ( ) ] ) ) ; }	writes a setval record to the log.
public static double gaussian ( ) { double r , x , y ; do { x = uniform ( - num , num ) ; y = uniform ( - num , num ) ; r = x * x + y * y ; } while ( r >= num || r == num ) ; return x * math . sqrt ( - num * math . log ( r ) / r ) ; }	returns a random real number from a standard gaussian distribution .
public void done with parameters ( ) { if ( info . parameter count == var args ) { int len = var args . size ( ) ; check parameter count ( len ) ; args = new expression [ len ] ; var args . to array ( args ) ; var args = null ; } else { int len = args . length ; if ( len > num && args [ len - num ] == null ) { throw db exception . get ( error code . invalid parameter count 2 , info . name , str + len ) ; } } }	this method is called after all the parameters have been set.
public void remove all x509 certificates ( ) { x509 certificates . clear ( ) ; }	removes all x509certificate ' s from this user.
public void update current state ( string what happened ) { undo event undo event = create undo event for current state ( what happened ) ; if ( undo event != null && undo stack != null ) { undo stack . set the way things are ( undo event ) ; } }	called by anything that knows that the eomg has arrived at a stable state that should be kept for undo actions .
protected void extend element ( element e ) { }	customizable method if you need to add anything more.
private string read response from server ( url url connection ) throws request failure exception { try { input stream reader reader = new input stream reader ( url connection . get input stream ( ) ) ; buffered reader in = new buffered reader ( reader ) ; try { string builder response = new string builder ( ) ; for ( string line = in . read line ( ) ; line != null ; line = in . read line ( ) ) { response . append ( line ) ; } check server response code ( url connection ) ; return response . to string ( ) ; } finally { in . close ( ) ; } } catch ( io e ) { throw new request failure exception ( str , e ) ; } }	reads the response from the omaha server .
public boolean is supported option ( string name ) { boolean is supported = bool ; for ( iterator i = mandatory options . iterator ( ) ; i . has next ( ) && ! is supported ; ) { string opt = ( string ) i . next ( ) ; is supported = opt . equals ( name ) ; } for ( iterator i = optional options . iterator ( ) ; i . has next ( ) && ! is supported ; ) { string opt = ( string ) i . next ( ) ; is supported = opt . equals ( name ) ; } return is supported ; }	returns < true > if the option is supported .
private boolean are all node ended ( ) { if ( protocol != null && protocol . has protocol ( ) ) { final collection < protocol node > protocol nodes = protocol node participant map . values ( ) ; if ( protocol nodes . is empty ( ) ) { return bool ; } for ( final protocol node node : protocol nodes ) { if ( ! ( node != null && node . is terminal ( ) ) ) { return bool ; } } return bool ; } final collection < fipa > final msgs = no protocol node participant map . values ( ) ; if ( final msgs . is empty ( ) ) { return bool ; } for ( final fipa final msg : final msgs ) { if ( final msg . get performative ( ) != fipa . performatives . end conversation ) { return bool ; } } return bool ; }	are all node ended .
public string builder encode body ( string builder retval ) { return retval . append ( option tag ) ; }	encode in canonical form .
public void add literal result attribute ( avt avt ) { if ( null == m avts ) m avts = new array list ( ) ; m avts . add ( avt ) ; }	set a literal result attribute ( avts only ) .
protected void move selection to first position ( ) { if ( selection table . get selection count ( ) == num ) { return ; } int index = num ; for ( final table item table item : selection table . get selection ( ) ) { final dl item = ( dl ) table item . get data ( ) ; selection . remove ( item ) ; selection . add ( index ++ , item ) ; } redraw tables ( ) ; selection table . select ( num , index - num ) ; selection table . force focus ( ) ; }	move the selected item to the first position.
private void items array to combined buffer ( t [ ] items array ) { final int extra = num ; min value = items array [ num ] ; max value = items array [ num ] ; system . arraycopy ( items array , extra , combined buffer , num , base buffer count ) ; long bits = bit pattern ; if ( bits > num ) { int index = extra + base buffer count ; for ( int level = num ; bits != num ; level ++ , bits >>>= num ) { if ( ( bits & num ) > num ) { system . arraycopy ( items array , index , combined buffer , ( num + level ) * k , k ) ; index += k ; } } } }	loads the combined buffer , min and max from the given items array.
public sql ( class < t > type , string sql expression , query result type query result type , object ... parameters ) { this ( sql expression , type . get name ( ) , null , query result type , parameters ) ; }	creates a sqlquery using the specified type , expression , result type and parameters .
public void bob ( mowzie model renderer box , float speed , float degree , boolean bounce , float f , float f1 ) { float bob = ( float ) ( math . sin ( f * speed ) * f1 * degree - f1 * degree ) ; if ( bounce ) bob = ( float ) - math . abs ( ( math . sin ( f * speed ) * f1 * degree ) ) ; box . rotation point y += bob ; }	moves a box up and down ( rotationpointy ).
private static void reject unsupported options ( properties p ) throws sql { if ( p . contains key ( data source factory . jdbc role name ) ) { throw new sql ( str + data source factory . jdbc role name + str ) ; } if ( p . contains key ( data source factory . jdbc datasource name ) ) { throw new sql ( str + data source factory . jdbc datasource name + str ) ; } }	checker method that will throw if any unsupported standard osgi options is present .
private void decrement worker count ( ) { do { } while ( ! compare and decrement worker count ( ctl . get ( ) ) ) ; }	decrements the workercount field of ctl.
public static float build float ( int mant , int exp ) { if ( exp < - num || mant == num ) { return num ; } if ( exp >= num ) { return ( mant > num ) ? float . positive infinity : float . negative infinity ; } if ( exp == num ) { return mant ; } if ( mant >= ( num << num ) ) { mant ++ ; } return ( float ) ( ( exp > num ) ? mant * pow10 [ exp ] : mant / pow10 [ - exp ] ) ; }	computes a float from mantissa and exponent .
public void clear values ( ) { m data sets . clear ( ) ; notify data changed ( ) ; }	clears this data object from all datasets and removes all entries.
public boolean has mode support ( ) { return is available ( ) && m capabilities . intersects ( m all modes ) ; }	checks if livedisplay has support for adaptive modes .
public void run test ( ) throws throwable { document doc ; node list gender list ; node gender node ; entity reference ent ref ; element ent element ; character data ent element text ; int node type ; doc = ( document ) load ( str , bool ) ; gender list = doc . get elements by tag name ( str ) ; gender node = gender list . item ( num ) ; ent ref = ( entity reference ) gender node . get first child ( ) ; assert not null ( str , ent ref ) ; node type = ( int ) ent ref . get node type ( ) ; if ( equals ( num , node type ) ) { ent ref = doc . create entity reference ( str ) ; assert not null ( str , ent ref ) ; } ent element = ( element ) ent ref . get first child ( ) ; assert not null ( str , ent element ) ; ent element text = ( character data ) ent element . get first child ( ) ; assert not null ( str , ent element text ) ; { boolean success = bool ; try { ent element text . set node value ( str ) ; } catch ( dom ex ) { success = ( ex . code == dom . no modification allowed err ) ; } assert true ( str , success ) ; } }	runs the test case .
public void test constr string with exponent with point2 ( ) { string a = str ; int a scale = num ; big integer b a = new big integer ( str ) ; big decimal a number = new big decimal ( a ) ; assert equals ( str , b a , a number . unscaled value ( ) ) ; assert equals ( str , a scale , a number . scale ( ) ) ; }	new bigdecimal ( string value ) ; value contains both exponent and decimal point.
public static void update item in database ( context context , final item info item ) { final content values values = new content values ( ) ; item . on add to database ( context , values ) ; update item in database helper ( context , values , item , str ) ; }	update an item to the database in a specified container .
@ override public string graph ( ) throws exception { string buffer text = new string buffer ( ) ; text . append ( str ) ; m cobweb tree . graph tree ( text ) ; text . append ( str ) ; return text . to string ( ) ; }	generates the graph string of the cobweb tree.
@ override public enumeration < option > list options ( ) { vector < option > result = enum to vector ( super . list options ( ) ) ; result . add element ( new option ( str + default num attributes ( ) + str , str , num , str ) ) ; result . add element ( new option ( str , str , num , str ) ) ; result . add element ( new option ( str , str , num , str ) ) ; result . add element ( new option ( str , str , num , str ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
public synchronized reference < ? extends t > remove ( long timeout millis ) throws interrupted exception { if ( timeout millis < num ) { throw new illegal argument exception ( str + timeout millis ) ; } if ( head != null ) { return poll ( ) ; } if ( timeout millis == num || ( timeout millis > long . max value / nanos per milli ) ) { do { wait ( num ) ; } while ( head == null ) ; return poll ( ) ; } long nanos to wait = timeout millis * nanos per milli ; int timeout nanos = num ; long start time = system . nano time ( ) ; while ( bool ) { wait ( timeout millis , timeout nanos ) ; if ( head != null ) { break ; } long nanos elapsed = system . nano time ( ) - start time ; long nanos remaining = nanos to wait - nanos elapsed ; if ( nanos remaining <= num ) { break ; } timeout millis = nanos remaining / nanos per milli ; timeout nanos = ( int ) ( nanos remaining - timeout millis * nanos per milli ) ; } return poll ( ) ; }	returns the next available reference from the queue , removing it in the process.
public path impl lookup impl ( string user path , map < string , object > new attributes , boolean is allow root ) { if ( user path == null ) { return lookup impl ( get path ( ) , new attributes , is allow root ) ; } if ( ! is allow root ) { return scheme walk ( user path , new attributes , user path , num ) ; } string scheme = scan scheme ( user path ) ; if ( scheme == null ) { return scheme walk ( user path , new attributes , user path , num ) ; } path impl path ; scheme map scheme map = scheme map ; if ( is windows ( ) ) { int length = scheme . length ( ) ; char ch ; if ( length == num && ( str <= ( ch = scheme . char at ( num ) ) && ch <= str || str <= ch && ch <= str ) ) { user path = character . to lower case ( ch ) + user path . substring ( num ) ; if ( is test windows ) return scheme walk ( user path , new attributes , str + user path , num ) ; path = scheme map . get ( str ) ; if ( path != null ) return path . scheme walk ( user path , new attributes , str + user path , num ) ; else return scheme walk ( user path , new attributes , str + user path , num ) ; } } path = scheme map . get ( scheme ) ; if ( path == null ) { return scheme walk ( user path , new attributes , user path , num ) ; } else { return path . scheme walk ( user path , new attributes , user path , scheme . length ( ) + num ) ; } }	returns a new path relative to the current one.
static integer read rule id ( final substring reader reader ) throws decode exception { int length = num ; reader . skip whitespaces ( ) ; reader . mark ( ) ; try { while ( reader . read ( ) != str ) { length ++ ; } if ( length == num ) { throw decode exception . error ( err attr syntax rule id no valu . get ( reader . pos ( ) - num ) ) ; } reader . reset ( ) ; final string rule id = reader . read ( length ) ; try { return integer . value of ( rule id ) ; } catch ( final number format exception e ) { throw decode exception . error ( err attr syntax rule id invali . get ( rule id ) ) ; } } catch ( final string index out of bounds exception e ) { throw decode exception . error ( err attr syntax truncated valu . get ( ) ) ; } }	reads the next ruleid from the definition , skipping over any leading spaces .
public void remove index ( i index ) { if ( index != null ) { indices . remove ( index ) ; } }	removes the given index .
private attribute action set process attribute section ( mode usage mode usage , string ns , int set index set , attributes attributes ) throws sax { mode mode = mode usage . get mode ( current section . context ) ; attribute action set actions = mode . get attribute actions ( ns ) ; if ( actions . get reject ( ) && ! attribute namespace rejected ) { attribute namespace rejected = bool ; if ( eh != null ) eh . error ( new sax ( localizer . message ( str , ns ) , locator ) ) ; } schema [ ] schemas = actions . get schemas ( ) ; for ( int j = num ; j < schemas . length ; j ++ ) { if ( attribute schemas . contains ( schemas [ j ] ) ) continue ; attribute schemas . add ( schemas [ j ] ) ; if ( filtered attributes == null ) filtered attributes = filter attributes ( index set , attributes ) ; validate attributes ( schemas [ j ] , filtered attributes ) ; } return actions ; }	process an attributes section in a specific mode usage .
@ override public double conf ( double total weight , double delta ) { return inverse normal ( num - delta / num ) / ( num * math . sqrt ( total weight ) ) ; }	calculate confidence intervall without a specific rule for instance averaging functions .
@ override public final int read unsigned byte ( ) throws io { return dis . read unsigned byte ( ) ; }	read an unsigned byte . note : returns an int , even though says byte ( non - javadoc ).
public synchronized static void ensure security manager ( @ suppress warnings ( str ) string [ ] args ) { security policy loader . load ( system boot . class , str ) ; system . set security manager ( new rmi ( ) ) ; }	utility routine that sets a security manager ( if one isn ' t already present ) and the security policy.
@ override public object clone ( ) throws clone not supported exception { return super . clone ( ) ; }	returns a clone of this instance .
public string ridge tip text ( ) { return str ; }	returns the tip text for this property.
public void update enable state swing items ( ) { if ( swing utilities . is event dispatch thread ( ) ) super . update enable state ( ) ; }	update the enable state for only the swing menu items.
public void reset ( ) { system . arraycopy ( iv , num , cbc v , num , iv . length ) ; arrays . fill ( cbc next v , ( byte ) num ) ; cipher . reset ( ) ; }	reset the chaining vector back to the iv and reset the underlying cipher .
protected final boolean load to have at least ( int min available ) throws io { if ( input stream == null ) { return bool ; } int amount = input end - input ptr ; if ( amount > num && input ptr > num ) { curr input processed += input ptr ; system . arraycopy ( input buffer , input ptr , input buffer , num , amount ) ; input end = amount ; } else { input end = num ; } input ptr = num ; while ( input end < min available ) { int count = input stream . read ( input buffer , input end , input buffer . length - input end ) ; if ( count < num ) { close input ( ) ; if ( count == num ) { throw new io ( str + amount + str ) ; } return bool ; } input end += count ; } return bool ; }	helper method that will try to load at least specified number bytes in input buffer , possible moving existing data around if necessary.
public data type parser register ( int jdbc type , string grammar ) { objects . require non null ( grammar , str ) ; data type pattern pattern = parser . parse ( jdbc type , grammar ) ; pattern . for each first token ( null ) ; return this ; }	register data type that may not contain a length / precision or scale.
public void close ( ) throws generic data source exception { if ( manual tx ) { if ( debug . verbose on ( ) ) debug . log verbose ( str + manual tx , module ) ; commit ( ) ; } sql = null ; if ( rs != null ) { try { rs . close ( ) ; if ( debug . verbose on ( ) ) debug . log verbose ( str + manual tx , module ) ; } catch ( sql sqle ) { debug . log warning ( sqle . get message ( ) , module ) ; } rs = null ; } if ( ps != null ) { try { ps . close ( ) ; if ( debug . verbose on ( ) ) debug . log verbose ( str + manual tx , module ) ; } catch ( sql sqle ) { debug . log warning ( sqle . get message ( ) , module ) ; } ps = null ; } if ( ( connection != null ) && b delete connection ) { try { connection . close ( ) ; if ( debug . verbose on ( ) ) debug . log verbose ( str + manual tx , module ) ; } catch ( sql sqle ) { debug . log warning ( sqle . get message ( ) , module ) ; } connection = null ; } }	commit if required and remove all allocated resources.
private default mutable tree node copy ( tree node node ) { return new default mutable tree node ( node ) ; }	defensive copy used in createtransferable .
public static void agentmain ( string args , instrumentation inst ) throws exception { logger . info ( str ) ; check transformer state ( ) ; inst . add transformer ( transformer , bool ) ; instrumentation = inst ; }	this is called by jvm when agent starts.
public byte [ ] data ( ) { byte array output stream bos = new byte array output stream ( ) ; try { to data ( bos ) ; } catch ( io e ) { throw new runtime exception ( e ) ; } return bos . to byte array ( ) ; }	serialize the row ' s metadata to enable upgrade .
@ safe varargs public static < t > reactive seq < t > of ( final t ... elements ) { final reversing array spliterator < t > array = new reversing array spliterator < t > ( elements , bool , num ) ; return stream utils . reactive seq ( stream support . stream ( array , bool ) , optional . of nullable ( array ) ) ; }	create an efficiently reversable sequence from the provided elements.
private void decode ltp ( long term prediction ltp , int max sfb ) { ltp . lag = br . read ( num ) ; ltp . coef = ltp coef [ br . read ( num ) ] ; for ( int sfb = num ; sfb < math . min ( max sfb , max ltp long sfb ) ; sfb ++ ) { ltp . used [ sfb ] = br . read bool ( ) ; } }	decode long term prediction data ; reference : table 4.
public static < t > list < t > instantiate all ( string [ ] classes , class loader class loader ) { list < t > clazzes = new array list < t > ( ) ; for ( string clazz : classes ) { if ( string utils . has length ( clazz ) ) { try { clazzes . add ( class utils . < t > instantiate ( clazz , class loader ) ) ; } catch ( exception e ) { throw new cassandra migration exception ( str + clazz , e ) ; } } } return clazzes ; }	instantiate all these classes .
static void clear instance cache ( ) { synchronized ( instance cache ) { instance cache . clear ( ) ; } }	for unit testing only.
public static < e extends enum < e > & bitmapable enum > enum set < e > to enum set ( class < e > type , int bitmap ) { if ( type == null ) throw new null pointer exception ( str ) ; enum set < e > s = enum set . none of ( type ) ; int all set bitmap = num ; for ( e element : type . get enum constants ( ) ) { if ( integer . bit count ( element . get value ( ) ) != num ) { string msg = string . format ( str + str + str , element . to string ( ) , element . get value ( ) , type . get name ( ) ) ; throw new illegal argument exception ( msg ) ; } all set bitmap |= element . get value ( ) ; if ( ( bitmap & element . get value ( ) ) != num ) s . add ( element ) ; } if ( ( ( ~ all set bitmap ) & bitmap ) != num ) { string msg = string . format ( str + str , bitmap , type . get name ( ) ) ; throw new illegal argument exception ( msg ) ; } return s ; }	convert an integer bitmap to an enumset . see class description for example.
public undirected graph node clone graph b ( undirected graph node node ) { map < integer , undirected graph node > map = new hash map < > ( ) ; return dfs ( node , map ) ; }	dfs . pass the node and map to its neighbors . add neighbors dfs result to its neighbors and return .
public synchronized void notify session borrowed ( ) { if ( logger . is trace enabled ( ) ) logger . log trace ( this + str ) ; current context = new transaction context ( resource , xa resource ) ; all contexts . add ( current context ) ; closed = bool ; }	notification that the session was gotten from the pool .
@ override public synchronized void close ( ) throws sql { try { debug code call ( str ) ; if ( session == null ) { return ; } close watcher . unregister ( watcher ) ; session . cancel ( ) ; if ( executing statement != null ) { try { executing statement . cancel ( ) ; } catch ( null pointer exception e ) { } } synchronized ( session ) { try { if ( ! session . is closed ( ) ) { try { if ( session . has pending transaction ( ) ) { if ( ! session . is reconnect needed ( bool ) ) { try { rollback internal ( ) ; } catch ( db exception e ) { if ( e . get error code ( ) != error code . connection broken 1 ) { throw e ; } } } session . after writing ( ) ; } close prepared commands ( ) ; } finally { session . close ( ) ; } } } finally { session = null ; } } } catch ( exception e ) { throw log and convert ( e ) ; } }	closes this connection . all open statements , prepared statements and result sets that where created by this connection become invalid after calling this method . if there is an uncommitted transaction , it will be rolled back .
public void test plus math context negative ( ) { string a = str ; int a scale = num ; int precision = num ; rounding mode rm = rounding mode . ceiling ; math context mc = new math context ( precision , rm ) ; string c = str ; int c scale = num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal res = a number . plus ( mc ) ; assert equals ( str , c , res . to string ( ) ) ; assert equals ( str , c scale , res . scale ( ) ) ; }	plus ( mathcontext ) for a negative bigdecimal.
public static wkt create empty ( wkt wkt type ) { wkt wkt geometry = new wkt ( ) ; wkt geometry . set geometry type ( wkt type ) ; return wkt geometry ; }	creates the empty wkt geometry.
public peer lookup task create peer lookup ( byte [ ] info hash ) { if ( ! is running ( ) ) { return null ; } key id = new key ( info hash ) ; rpc srv = server manager . get random active server ( bool ) ; if ( srv == null ) return null ; peer lookup task lookup task = new peer lookup task ( srv , node , id ) ; return lookup task ; }	returns a non - enqueued task for further configuration.
public void add child ( node ... nodes ) { for ( node node : nodes ) { node . detach from parent ( ) ; node . parent node = this ; init child nodes ( node ) ; child nodes . add ( node ) ; } reindex children on add ( nodes . length ) ; }	appends several child nodes at once.
public static void write string ascii ( byte buf stream , string str ) throws unsupported encoding exception { final byte [ ] bytes = str . get bytes ( str ) ; stream . write int ( str . length ( ) ) ; stream . write bytes ( bytes ) ; }	writes an ascii string to the stream , the first value will be an integer for the length of the string , followed by bytes.
@ override public void on detach ( ) { synchronized ( m thread ) { m progress bar = null ; m ready = bool ; m thread . notify ( ) ; } super . on detach ( ) ; }	this is called right before the fragment is detached from its current activity instance .
public void output source ( int module , int line , string s ) { string builder sb = new string builder ( ) ; append source ( sb , module , line , s , bool ) ; out ( sb . to string ( ) ) ; }	output a source line of code to the output channel formatting nicely.
sorted map < string , string > properties ( ) ;	returns a sorted map of the properties of this packer .
public static string suppress white space ( string str ) { int len = str . length ( ) ; string builder sb = new string builder ( len ) ; char c ; char buffer = num ; for ( int i = num ; i < len ; i ++ ) { c = str . char at ( i ) ; if ( c == str || c == str ) buffer = str ; else if ( is white space ( c ) ) { if ( buffer == num ) buffer = c ; } else { if ( buffer != num ) { sb . append ( buffer ) ; buffer = num ; } sb . append ( c ) ; } } if ( buffer != num ) sb . append ( buffer ) ; return sb . to string ( ) ; }	remove all white spaces followd by whitespaces.
private node < k , v > find predecessor ( comparable < ? super k > key ) { if ( key == null ) throw new null pointer exception ( ) ; for ( ; ; ) { index < k , v > q = head ; index < k , v > r = q . right ; for ( ; ; ) { if ( r != null ) { node < k , v > n = r . node ; k k = n . key ; if ( n . value == null ) { if ( ! q . unlink ( r ) ) break ; r = q . right ; continue ; } if ( key . compare to ( k ) > num ) { q = r ; r = r . right ; continue ; } } index < k , v > d = q . down ; if ( d != null ) { q = d ; r = d . right ; } else return q . node ; } } }	returns a base - level node with key strictly less than given key , or the base - level header if there is no such node.
public void not idle ( ) { if ( idle timeout msec . get ( ) > num ) last action msec . set ( system . current time millis ( ) ) ; }	a " not idle " event has occurred.
public static byte [ ] gzip ( final string input ) { final byte array output stream baos = new fast byte array output stream ( ) ; gzip gzos = null ; try { gzos = new gzip ( baos ) ; gzos . write ( input . get bytes ( str ) ) ; } catch ( final io e ) { main util . handle error ( e ) ; } finally { if ( gzos != null ) { try { gzos . close ( ) ; } catch ( final io ignore ) { } } } return baos . to byte array ( ) ; }	gzip compress a string of bytes.
protected abstract composite service builder ( ) { }	creates a new instance .
@ override public void end document ( ) throws sax { if ( resource != null ) { resource . add all resource ( js vector ) ; for ( object object : resource . get resource set ( ) ) { resource r = ( resource ) object ; if ( r . get resource ( ) != null ) { parser . set resource ( ( resource ) r ) ; parser . run ( ) ; js set . add ( parser . get result ( ) ) ; } } } }	event fired at the end of the document parse.
public void add method to display ( method ident method ident ) { methods . add ( method ident ) ; }	adds a method to be displayed later in this sub - tree .
@ override public enumeration < option > list options ( ) { vector < option > result = new vector < option > ( ) ; result . add element ( new option ( str + str , str , num , str ) ) ; result . add all ( collections . list ( super . list options ( ) ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
private void select connecting edges ( list < display node > display nodes ) { if ( ! is allow node edge selection ( ) ) { return ; } component [ ] components = get components ( ) ; for ( component comp : components ) { if ( comp instanceof i ) { i graph edge = ( i ) comp ; display node node1 = graph edge . get comp1 ( ) ; display node node2 = graph edge . get comp2 ( ) ; if ( node1 instanceof graph node error ) { continue ; } if ( node2 instanceof graph node error ) { continue ; } if ( node2 != null ) { boolean selected = display nodes . contains ( node1 ) && display nodes . contains ( node2 ) ; graph edge . set selected ( selected ) ; } } } }	selects all and only those edges that are connecting selected nodes.
public static string class name only ( string type name ) { string dotted = descriptor to dot ( type name ) ; int start = dotted . last index of ( str ) ; if ( start < num ) { return dotted ; } else { return dotted . substring ( start + num ) ; } }	extracts the class name from a type descriptor .
@ override public synchronized string to string ( ) { final string buffer sb result = new string buffer ( ) ; sb result . append ( str ) ; sb result . append ( get credentials string representation ( proxy cred ) ) ; sb result . append ( str ) ; sb result . append ( get credentials string representation ( cred map ) ) ; sb result . append ( str ) ; sb result . append ( get cookies string representation ( cookies ) ) ; sb result . append ( str ) ; final string str result = sb result . to string ( ) ; return str result ; }	returns a string representation of this http state .
public static list < library location > gather all libraries ( string [ ] dir paths ) { list < library location > libraries = new array list < library location > ( ) ; for ( int i = num ; i < dir paths . length ; i ++ ) { file ext dir = new file ( dir paths [ i ] ) ; if ( ext dir . is directory ( ) ) { string [ ] names = ext dir . list ( fg archive filter ) ; if ( names != null ) { for ( int j = num ; j < names . length ; j ++ ) { file jar = new file ( ext dir , names [ j ] ) ; if ( jar . is file ( ) ) { try { i lib path = new path ( jar . get canonical path ( ) ) ; i source path = path . empty ; i package root = path . empty ; url javadoc location = null ; url index location = null ; library location library = new library location ( lib path , source path , package root , javadoc location , index location ) ; libraries . add ( library ) ; } catch ( io e ) { launching . log ( e ) ; } } } } } } return libraries ; }	returns a list of all zip ' s and jars contained in the given directories .
public void request close ( ) { m lock . lock ( ) ; try { if ( m is shutdown ) { return ; } m target state = target state . closed ; update ( ) ; } finally { m lock . unlock ( ) ; } }	request that the state machine move towards a closed state .
private void reserve one doc ( ) { if ( pending num docs . increment and get ( ) > index writer . get actual max docs ( ) ) { pending num docs . decrement and get ( ) ; throw new illegal argument exception ( str + index writer . get actual max docs ( ) ) ; } }	anything that will add n docs to the index should reserve first to make sure it ' s allowed .
public static void stream content to browser ( http servlet response response , input stream in , int length , string content type , string file name ) throws io { set response browser proxy no cache ( response ) ; response . set content length ( length ) ; if ( content type != null ) { response . set content type ( content type ) ; } if ( file name != null ) { response . set header ( str , str + file name + str ) ; } output stream out = response . get output stream ( ) ; try { stream content ( out , in , length ) ; } catch ( io e ) { out . close ( ) ; throw e ; } out . flush ( ) ; out . close ( ) ; }	streams content from inputstream to the servletoutputstream this method will close the servletoutputstream when finished this method does not close the inputsteam passed.
@ override public string to string ( ) { return to string ( bool ) ; }	returns string representation of this object.
private static boolean is valid method name ( string method name ) { return method name . matches ( str ) ; }	determine whether the provided method name is valid in java .
public static byte [ ] to ut ( string s ) { byte [ ] result = new byte [ utf length ( s ) ] ; int result index = num ; for ( int i = num , n = s . length ( ) ; i < n ; ++ i ) { char c = s . char at ( i ) ; if ( ( ( ! write pseudo ut ) || ( c >= num ) ) && ( c <= num ) ) { result [ result index ++ ] = ( byte ) c ; } else if ( c > num ) { result [ result index ++ ] = ( byte ) ( num | ( byte ) ( c > > num ) ) ; result [ result index ++ ] = ( byte ) ( num | ( ( c & num ) > > num ) ) ; result [ result index ++ ] = ( byte ) ( num | ( c & num ) ) ; } else { result [ result index ++ ] = ( byte ) ( num | ( byte ) ( c > > num ) ) ; result [ result index ++ ] = ( byte ) ( num | ( c & num ) ) ; } } return result ; }	convert the given string into a sequence of ( pseudo - ) utf8 formatted bytes.
public void pln ( object o ) throws io { p ( o . to string ( ) ) ; pln ( ) ; }	write object ; end current line .
public void test reduce task ( ) throws exception { hadoop job grid job = get hadoop job ( igfs scheme ( ) + path input , igfs scheme ( ) + path output ) ; run task with input ( grid job , hadoop task type . reduce , num , str , str , str , str ) ; run task with input ( grid job , hadoop task type . reduce , num , str , str , str , str ) ; assert equals ( str + str , read and sort file ( path output + str + get output file name prefix ( ) + str ) ) ; assert equals ( str + str , read and sort file ( path output + str + get output file name prefix ( ) + str ) ) ; }	tests reduce task execution .
public static double expm1 ( double value ) { if ( use jdk math ) { return strict math ? strict math . expm1 ( value ) : math . expm1 ( value ) ; } if ( math . abs ( value ) < exp lo distance to zero ) { int i = ( int ) ( value * exp lo indexing ) ; double delta = value - i * ( num / exp lo indexing ) ; return exp lo pos tab [ i + exp lo tab mid index ] * ( exp lo neg tab [ i + exp lo tab mid index ] + delta * ( num + delta * ( num / num + delta * ( num / num + delta * ( num / num + delta * ( num / num ) ) ) ) ) ) ; } else { return fast math . exp ( value ) - num ; } }	much more accurate than exp ( value ) - 1 , for values close to zero .
public void delete conditional ( conditional c ) { deregister ( c ) ; }	remove an existing conditional.
private void add block to worklist ( ssa basic block ssa block ) { if ( ! executable blocks . get ( ssa block . get index ( ) ) ) { cfg worklist . add ( ssa block ) ; executable blocks . set ( ssa block . get index ( ) ) ; } else { cfg phi worklist . add ( ssa block ) ; } }	adds a ssa basic block to the cfg worklist if it ' s unexecuted , or to the cfg phi worklist if it ' s already executed .
private static boolean is32 bit jvm ( ) { integer bits = integer . get integer ( str ) ; return bits != null && bits == num ; }	uses the non - portable system property sun.
public float angle ( ) { return ( float ) math . atan2 ( y ( ) , x ( ) ) ; }	angle of this sample in radians.
public static string format number ( double value , int number of digits , boolean grouping characters ) { if ( double . is na n ( value ) ) { return str ; } int number digits = number of digits ; if ( number digits < num ) { number digits = number of fraction digits ; } number format . set minimum fraction digits ( number digits ) ; number format . set maximum fraction digits ( number digits ) ; number format . set grouping used ( grouping characters ) ; return number format . format ( value ) ; }	returns a formatted string of the given number ( uses the property rapidminer.
private static boolean is trash id ( ignite uuid id ) { if ( id == null ) return bool ; uuid gid = id . global id ( ) ; return id . local id ( ) == num && gid . get most significant bits ( ) == num && gid . get least significant bits ( ) > num && gid . get least significant bits ( ) <= trash concurrency ; }	check whether provided id is trash id .
private void on time element end ( ) throws sax { try { time ms = xml date time format . parse millis ( content . trim ( ) ) ; } catch ( illegal argument exception e ) { throw new sax ( create error message ( str + content ) , e ) ; } }	on time element end.
public static boolean is class present ( string fully qualified class name ) { try { class . for name ( fully qualified class name ) ; return bool ; } catch ( class not found exception e ) { return bool ; } }	returns true if the class is present in the current class loader .
void unlink ( node < e > p , node < e > trail ) { p . set value ( null ) ; trail . next = p . next ; if ( last == p ) last = trail ; if ( count . get and decrement ( ) == capacity ) not full . signal ( ) ; }	unlinks interior node p with predecessor trail .
@ target api ( build . version codes . jelly bean ) private int queue input buffer ( media codec codec , byte buffer [ ] input buffers , int index , speech record speech record ) { if ( speech record == null || speech record . get recording state ( ) != speech record . recordstate recording ) { return - num ; } if ( build . version . sdk int >= build . version codes . jelly bean ) { byte buffer input buffer = input buffers [ index ] ; input buffer . clear ( ) ; int size = input buffer . limit ( ) ; byte [ ] buffer = new byte [ size ] ; int status = read ( speech record , buffer ) ; if ( status < num ) { handle error ( str + status ) ; return - num ; } input buffer . put ( buffer ) ; codec . queue input buffer ( index , num , size , num , num ) ; return size ; } return - num ; }	copy audio from the recorder into the encoder .
@ override public final void sample ( ) { long count = count . get and set ( num ) ; long time = time . get and set ( num ) ; if ( count == num ) value = num ; else value = time / ( double ) count ; }	return the probe ' s next sample .
protected void validate properties ( final object entity , final entity data model edm ) throws o { final type type = edm . get type ( entity . get class ( ) ) ; if ( ! ( type instanceof structured type ) ) { return ; } visit properties ( edm , ( structured type ) type , null ) ; }	checks if all non - nullable properties of an entity are non - empty .
static adb response read adb response ( socket channel chan , boolean read diag string ) throws timeout exception , io { adb response resp = new adb response ( ) ; byte [ ] reply = new byte [ num ] ; read ( chan , reply ) ; if ( is okay ( reply ) ) { resp . okay = bool ; } else { read diag string = bool ; resp . okay = bool ; } try { while ( read diag string ) { byte [ ] len buf = new byte [ num ] ; read ( chan , len buf ) ; string len str = reply to string ( len buf ) ; int len ; try { len = integer . parse int ( len str , num ) ; } catch ( number format exception nfe ) { log . w ( str , str + len str + str + len buf [ num ] + str + len buf [ num ] + str + len buf [ num ] + str + len buf [ num ] ) ; log . w ( str , str + reply to string ( reply ) ) ; break ; } byte [ ] msg = new byte [ len ] ; read ( chan , msg ) ; resp . message = reply to string ( msg ) ; log . v ( str , str + reply to string ( reply ) + str + resp . message + str ) ; break ; } } catch ( exception e ) { } return resp ; }	reads the response from adb after a command .
public void remove mouse mode ( string id ) { for ( map mouse mode med : mouse modes ) { if ( id . equals ( med . get id ( ) ) ) { remove mouse mode ( med ) ; break ; } } }	removes a particular mapmousemode from the mousemode list , with the id given .
private boolean filter existing items ( list < post item > post items , post item item ) { if ( post items . contains ( item ) ) { int i = post items . index of ( item ) ; post items . remove ( i ) ; post items . add ( i , item ) ; return bool ; } return bool ; }	this function replaces the old item in the list with the new one only if both items have the same id.
date range build shifted range ( date range raw range , long cadence , long now ) { if ( raw range . get start ( ) > now ) { throw new illegal argument exception ( str ) ; } final date range rounded = raw range . rounded ( cadence ) ; final long now delta = now - rounded . get end ( ) ; if ( now delta > shift tolerance ) { return rounded ; } final long diff = math . abs ( math . min ( now delta , num ) ) + shift tolerance ; return rounded . shift ( - tolerance shift period ( diff , cadence ) ) ; }	given a range and a cadence , return a range that might be shifted in case the end period is too close or after ' now '.
public static void upto ( date self , date to , closure closure ) { if ( self . compare to ( to ) <= num ) { for ( date i = ( date ) self . clone ( ) ; i . compare to ( to ) <= num ; i = next ( i ) ) { closure . call ( i ) ; } } else throw new groovy runtime exception ( str + to + str + self + str ) ; }	iterates from this date up to the given date , inclusive , incrementing by one day each time .
public void run test ( ) throws throwable { document doc ; node list element list ; element test employee ; node first c ; string child name ; int node type ; character data employee id ; string employee id ; doc = ( document ) load ( str , bool ) ; element list = doc . get elements by tag name ( str ) ; test employee = ( element ) element list . item ( num ) ; first c = test employee . get first child ( ) ; node type = ( int ) first c . get node type ( ) ; while ( equals ( num , node type ) ) { first c = first c . get next sibling ( ) ; node type = ( int ) first c . get node type ( ) ; } child name = first c . get node name ( ) ; assert equals auto case ( str , str , str , child name ) ; employee id = ( character data ) first c . get first child ( ) ; employee id = employee id . get node value ( ) ; assert equals ( str , str , employee id ) ; }	runs the test case .
public inference context ( js ts , type system helper tsh , cancel indicator cancel indicator , rule environment g , inference variable ... inference variables ) { objects . require non null ( ts ) ; objects . require non null ( tsh ) ; objects . require non null ( cancel indicator ) ; objects . require non null ( g ) ; this . ts = ts ; this . tsh = tsh ; this . cancel indicator = cancel indicator ; this . g = g ; add inference variables ( bool , inference variables ) ; this . reducer = new reducer ( this , g , ts , tsh ) ; this . current bounds = new bound set ( this , g , ts ) ; }	creates a new , empty inference context for the given inference variables .
@ override public void run ( ) throws interrupted exception , camera access exception , camera capture session closed exception , resource acquisition failed exception { frame server . session session = m frame server . try create exclusive session ( ) ; if ( session == null ) { return ; } try { af af scan result = new af ( ) ; request builder idle builder = create af ( null ) ; session . submit request ( arrays . as list ( idle builder . build ( ) ) , frame server . request type . repeating ) ; request builder cancel builder = create af ( null ) ; session . submit request ( arrays . as list ( cancel builder . build ( ) ) , frame server . request type . non repeating ) ; idle builder = create af ( af scan result ) ; session . submit request ( arrays . as list ( idle builder . build ( ) ) , frame server . request type . repeating ) ; request builder trigger builder = create af ( af scan result ) ; session . submit request ( arrays . as list ( trigger builder . build ( ) ) , frame server . request type . non repeating ) ; af scan result . get ( ) ; } finally { session . close ( ) ; } }	performs an auto - focus scan , blocking until the scan starts , runs , and completes .
protected list < node > create discrete variable list ( discrete variable analysis variable analysis ) { list < node > nodes = new array list < > ( variable analysis . get num of cols ( ) ) ; discrete var info [ ] variables = variable analysis . get discrete var infos ( ) ; for ( discrete var info variable : variables ) { if ( variable != null ) { nodes . add ( new discrete variable ( variable . get name ( ) , variable . get categories ( ) ) ) ; } } return nodes ; }	create a list of nodes from variable analysis results .
public synchronized void remove series ( xy series ) { m series . remove ( series ) ; }	removes the xy series from the list .
public void remote restart coordinator ( string node id , string type ) throws local repository exception { final string prefix = string . format ( str , type , node id ) ; log . debug ( prefix ) ; final string [ ] cmd = { systool cmd , systool remote systool , node id , systool restart coordinator , type } ; final exec . result result = exec . sudo ( systool timeout , cmd ) ; check failure ( result , prefix ) ; }	restart a service on remote node.
private static string int to string ( int value , int digit ) { string builder string builder = new string builder ( digit ) ; string builder . append ( integer . to string ( value ) ) ; while ( string builder . length ( ) < digit ) { string builder . insert ( num , str ) ; } return string builder . to string ( ) ; }	create string representation of integer.
void add ( int n ) { if ( v == null ) { v = new int [ init size ] ; v [ num ] = n ; len = num ; return ; } if ( len == v . length ) { int [ ] newv = new int [ len * num ] ; system . arraycopy ( v , num , newv , num , len ) ; v = newv ; } if ( n > v [ len - num ] ) { v [ len ++ ] = n ; return ; } int i = num ; for ( ; i < len ; i ++ ) { if ( n <= v [ i ] ) { if ( n == v [ i ] ) return ; break ; } } for ( int j = len ; j >= i ; j -- ) v [ j + num ] = v [ j ] ; v [ i ] = n ; ++ len ; }	add a new value .
public static string replace ( string source , string target , string replacement ) { string buffer output = new string buffer ( ) ; int n = num ; while ( bool ) { int off = source . index of ( target , n ) ; if ( off == - num ) { output . append ( source . substring ( n ) ) ; break ; } output . append ( source . substring ( n , off ) ) ; output . append ( replacement ) ; n = off + target . length ( ) ; } return output . to string ( ) ; }	description of the method.
public void correct null receiver ( ) { if ( args [ num ] != null ) return ; handle = handle . bind to ( null object . get null object ( ) ) ; handle = method handles . drop arguments ( handle , num , target type . parameter type ( num ) ) ; if ( log enabled ) log . info ( str ) ; }	gives a replacement receiver for null.
public static boolean is paired end directory ( final file dir ) { if ( dir == null || ! dir . exists ( ) || ! dir . is directory ( ) ) { return bool ; } final file l dir = new file ( dir , str ) ; final file r dir = new file ( dir , str ) ; return l dir . exists ( ) && r dir . exists ( ) && l dir . is directory ( ) && r dir . is directory ( ) ; }	tells you if the directory passed in contains a paired end sdf left / right folder.
@ suppress warnings ( str ) private void check class not found ( ) throws exception { init gar = bool ; try { ignite ignite1 = start grid ( num ) ; ignite ignite2 = start grid ( num ) ; class task = ext ldr . load class ( task name ) ; try { ignite1 . compute ( ) . execute ( task , ignite2 . cluster ( ) . local node ( ) . id ( ) ) ; assert bool ; } catch ( ignite exception e ) { info ( str + e ) ; } } finally { stop grid ( num ) ; stop grid ( num ) ; } }	test what happens if peer class loading is disabled .
public string drop engine ( engine engine ) { string builder builder = new string builder ( ) ; for ( string attribute : setup . get drop engine message format ( ) ) { builder . append ( get engine attribute ( engine , attribute , ! pickup ) ) ; } return builder . to string ( ) ; }	returns the drop string for a loco.
protected void pop write context ( ) { write context = write context stack . pop ( ) ; }	pop the last write context off the stack.
public long calculate end time ( ) { if ( end time == num ) { return system . current time millis ( ) ; } else if ( end time < num ) { return system . current time millis ( ) - end time ; } return end time ; }	this method returns an end time based on the configured value.
protected string extract alternate open quote ( string token ) { return null ; }	extracts the alternate open quote from this token ( if any ) .
private boolean remove index entry ( service type resource type , string resource name , string policy name ) throws policy exception { resource index resource index = ( resource index ) resource indices . get ( resource type . get name ( ) ) ; if ( resource index == null ) { resource index = refresh resource index from data store ( resource type ) ; } return resource index . remove index entry ( resource name , policy name ) ; }	removes or updates an index entry.
public static text block parse text block ( parse context parse context ) { return text block section parser . parse text block ( parse context ) ; }	parses a single text block with equal indentation .
public final static boolean in long range ( char [ ] digit chars , int offset , int len , boolean negative ) { string cmp str = negative ? min long str no sign : max long str ; int cmp len = cmp str . length ( ) ; if ( len < cmp len ) return bool ; if ( len > cmp len ) return bool ; for ( int i = num ; i < cmp len ; ++ i ) { if ( digit chars [ offset + i ] > cmp str . char at ( i ) ) { return bool ; } } return bool ; }	helper method for determining if given string representation of an integral number would fit in 64 - bit java long or not.
public static collection < debugger exception > merge exceptions settings ( final debug target settings target , final collection < debugger exception > exceptions , final int debugger id ) throws couldnt load data exception { final map < long , debugger exception > exceptions map = get exceptions map ( exceptions ) ; for ( final debugger exception dbg exception : exceptions ) { final string setting = target . read setting ( debugger exception . get setting key ( dbg exception , debugger id ) ) ; if ( setting != null ) { final debugger exception handling action handling action = debugger exception handling action . convert to handling action ( integer . value of ( setting ) ) ; final debugger exception new exception = new debugger exception ( dbg exception . get exception name ( ) , dbg exception . get exception code ( ) , handling action ) ; exceptions map . put ( dbg exception . get exception code ( ) , new exception ) ; } } return exceptions map . values ( ) ; }	merge the exception settings from the database with the ones received from the debugger .
public void verify annotation ( string method name , string annotation name ) throws exception { class clazz = class . for name ( class name ) ; method method = clazz . get declared method ( method name ) ; class annotation clazz = class . for name ( annotation name ) ; java . lang . annotation . annotation annotation = method . get annotation ( annotation clazz ) ; assert . assert not null ( annotation ) ; }	verify the method does have the annotation.
public publisher amb < t > amb additional source ( publisher < ? extends t > source ) { if ( array != null ) { int n = array . length ; @ suppress warnings ( str ) publisher < ? extends t > [ ] new array = new publisher [ n + num ] ; system . arraycopy ( array , num , new array , num , n ) ; new array [ n ] = source ; return new publisher amb < > ( new array ) ; } return null ; }	returns a new instance which has the additional source to be amb ' d together with the current array of sources.
public void begin display ( display event event ) throws model control exception { super . begin display ( event ) ; string site name = ( string ) get page session attribute ( pg attr site name ) ; server site model model = ( server site model ) get model ( ) ; pt model . set page title text ( model . get edit site page title ( site name ) ) ; try { set display field value ( tf url , model . get site primary url ( site name ) ) ; get failover ur ( site name , model ) ; get servers ( site name , model ) ; } catch ( am e ) { set inline alert message ( cc . type error , str , e . get message ( ) ) ; } }	displays the profile of a site .
public boolean add ( accessible state state ) { if ( states == null ) { states = new vector ( ) ; } if ( ! states . contains ( state ) ) { states . add element ( state ) ; return bool ; } else { return bool ; } }	adds a new state to the current state set if it is not already present.
public static final string read file ( file file ) throws io { buffered input stream in = null ; try { in = new buffered input stream ( new file input stream ( file ) ) ; simple byte buffer buffer = new simple byte buffer ( ) ; byte [ ] buf = new byte [ num ] ; int len ; while ( ( len = in . read ( buf ) ) != - num ) { buffer . put ( buf , len ) ; } return new string ( buffer . buffer , num , buffer . write ) ; } finally { if ( null != in ) { in . close ( ) ; } } }	read small < 5mb text files to string .
void add decimal point ( ) { this . display mode = display mode . input ; if ( this . clear on next digit ) { set display string ( empty string ) ; } final string input string = get display string ( ) ; if ( input string . index of ( dot character ) < num ) { set display string ( input string + dot character ) ; } }	add a decimal point.
public void close ( ) throws java . io . io { m os . close ( ) ; }	close the stream , flushing it first.
void show ( ) { if ( m is visible ) return ; m is visible = bool ; m height px = math . round ( m default height px ) ; invalidate ( ) ; }	shows the peek promo.
public void record mirror operation ( db client db client , operation type enum op type , operation . status status , object ... ext param ) { try { boolean op status = ( operation . status . ready == status ) ? bool : bool ; string ev type ; ev type = op type . get ev type ( op status ) ; string ev desc = op type . get description ( ) ; string op stage = audit log manager . auditop end ; logger . info ( str , op type . to string ( ) , ev type . to string ( ) + str + ev desc ) ; record bourne mirror event ( db client , get id ( ) , ev type , status , ev desc ) ; switch ( op type ) { case create file mirror : case start file mirror : case suspend file mirror : case detach file mirror : case pause file mirror : case resume file mirror : case failover file mirror : case stop file mirror : case failback file mirror : case resync file mirror : case refresh file mirror : case modify file mirror rpo : audit file ( db client , op type , op status , op stage , ext param ) ; break ; default : logger . error ( str ) ; } } catch ( exception e ) { logger . error ( str , op type . to string ( ) , e ) ; } }	record fileshare related event and audit.
private void cancel take image ( ) { m shooted picture path = null ; m selected gallery items list . clear ( ) ; vector app . set saved camera image preview ( null ) ; start camera preview ( ) ; update ui configuration ( ui show camera preview , image origin camera ) ; }	cancel the current image preview , and setup the ui to start a new image capture .
protected int next grid to restart ( ) { if ( curr restart grid id == server count ( ) ) curr restart grid id = num ; return ++ curr restart grid id ; }	return the index of the next grid to restart .
private void remove stale iterator references ( ) { remove stale references ( iterator reference queue , iterators ) ; }	remove stale iterator references from the iterator list .
boolean destroy i ( boolean force ) { na element elem = new na element ( str ) ; elem . add new child ( str , name ) ; elem . add new child ( str , boolean . to string ( force ) ) ; try { server . invoke elem ( elem ) ; } catch ( exception e ) { string msg = str + name ; log . error ( msg , e ) ; throw new net app exception ( msg , e ) ; } return bool ; }	destroys an initiator group.
@ override public double finite difference epsilon ( ) { return num ; }	default epsilon for finite difference method :.
public void remove ( final http connection connection ) { log . debug ( str + connection . get id ( ) ) ; connection to added . remove ( connection ) ; }	removes the given connection from the list of connections to be closed when idle .
public void put byte ( long pos , byte val ) { unsafe . put byte ( pos + addr , val ) ; }	writes a byte to the specified position .
public void add reference ( message part reference ) { references . add ( reference ) ; }	adds a reference to the manifest.
protected date time data parse ( string str ) throws schema date time exception { date time data date = new date time data ( str , this ) ; int len = str . length ( ) ; if ( str . char at ( num ) != str || str . char at ( num ) != str || str . char at ( num ) != str ) { throw new schema date time exception ( str ) ; } date . year = year ; date . month = month ; date . day = parse int ( str , num , num ) ; if ( day size < len ) { if ( ! is next char utc ( str , day size , len ) ) { throw new schema date time exception ( str ) ; } else { get time zone ( str , date , day size , len ) ; } } validate date time ( date ) ; save unnormalized ( date ) ; if ( date . utc != num && date . utc != str ) { normalize ( date ) ; } date . position = num ; return date ; }	parses , validates and computes normalized version of gday object.
private void update period ( ) { for ( int i = num ; i < m conversion . size ( ) ; i ++ ) { int date type = m conversion . key at ( i ) ; time period slider slider = m time period sliders . get ( date type ) ; slider . set value ( m period . get ( m conversion . value at ( i ) ) ) ; } m time . set text ( get formatted period ( ) ) ; m duration = m period . to standard duration ( ) ; do validation ( ) ; }	updates the view to reflect changes in the period object.
public long start brk ( ) { return long . parse long ( fields [ num ] ) ; }	( since linux 3.
public static void validate participant ids equal ( string expected participant id , string actual participant id ) throws crypto exception { if ( ! expected participant id . equals ( actual participant id ) ) { throw new crypto exception ( str + actual participant id + str + expected participant id + str ) ; } }	validates that the given participant ids are equal.
protected void encode fields ( mx codec enc , object obj , node node ) { class type = obj . get class ( ) ; while ( type != null ) { field [ ] fields = type . get declared fields ( ) ; for ( int i = num ; i < fields . length ; i ++ ) { field f = fields [ i ] ; if ( ( f . get modifiers ( ) & modifier . transient ) != modifier . transient ) { string fieldname = f . get name ( ) ; object value = get field value ( obj , fieldname ) ; encode value ( enc , obj , fieldname , value , node ) ; } } type = type . get superclass ( ) ; } }	encodes the declared fields of the given object into the given node .
public void add vetoable change listener ( string property name , vetoable change listener in vcl ) { bean context child support . add vetoable change listener ( property name , in vcl ) ; }	method for beancontextchild interface .
private void log missing resource ( faces context ctx , string resource id , throwable t ) { level level ; if ( ! ctx . is project stage ( project stage . production ) ) { level = level . warning ; } else { level = ( ( t != null ) ? level . warning : level . fine ) ; } if ( logger . is loggable ( level ) ) { logger . log ( level , str , new object [ ] { resource id } ) ; if ( t != null ) { logger . log ( level , str , t ) ; } } }	log a message indicating a particular resource ( reference by name and / or library ) could not be found.
private void append aliased column ( string builder sb , string col name , string t alias ) { if ( t alias != null ) { sb . append ( t alias ) ; sb . append ( str ) ; } sb . append ( str ) ; sb . append ( col name ) ; sb . append ( str ) ; }	appends a quoted column name , prepending a table alias if necessary.
private midi event create scheduled event ( byte [ ] msg , int offset , int count , long timestamp ) { midi event event ; if ( count > pool event size ) { event = new midi event ( msg , offset , count , timestamp ) ; } else { event = ( midi event ) remove eventfrom pool ( ) ; if ( event == null ) { event = new midi event ( pool event size ) ; } system . arraycopy ( msg , offset , event . data , num , count ) ; event . count = count ; event . set timestamp ( timestamp ) ; } return event ; }	create an event that contains the message .
public void start element ( string namespace uri , string local name , string q name , attributes atts ) throws sax { try { elem type = ( sax handler base . element type ) element types . get ( local name ) ; if ( gather mode ) { if ( gathering element . gather element ( local name , atts ) ) { gather buffer . add ( new object [ ] { elem type , new attributes impl ( atts ) } ) ; } } else { if ( elem type == null ) { return ; } elem type . start element ( atts ) ; } elems . add ( elem type ) ; } catch ( sax saxex ) { throw saxex ; } catch ( exception ex ) { throw new sax ( ex ) ; } }	description of the method.
public static byte [ ] gzip ( string input ) { byte array output stream baos = new byte array output stream ( ) ; gzip gzos = null ; try { gzos = new gzip ( baos ) ; gzos . write ( input . get bytes ( str ) ) ; } catch ( io e ) { e . print stack trace ( ) ; } finally { if ( gzos != null ) try { gzos . close ( ) ; } catch ( io ignore ) { } } return baos . to byte array ( ) ; }	gzip compress a string of bytes.
public static double log pdf ( double x , double m , double shape ) { double a = math . sqrt ( shape / ( num * math . pi * x * x * x ) ) ; double b = ( ( - shape ) * ( x - m ) * ( x - m ) ) / ( num * m * m * x ) ; return math . log ( a ) + b ; }	the natural log of the probability density function of the distribution.
public void add edge connector ( ) { num edge connectors ++ ; string name = str ; boolean duplicate = bool ; while ( duplicate ) { name = str + num edge connectors ; if ( finder . find positionable point by name ( name ) == null ) { duplicate = bool ; } if ( duplicate ) { num edge connectors ++ ; } } positionable point o = new positionable point ( name , positionable point . edge connector , current point , this ) ; point list . add ( o ) ; set dirty ( bool ) ; }	add an edge connector point .
@ request mapping ( value = { str , str } , method = request method . get ) @ response body public rest wrapper list ( @ request param ( value = str , default value = str ) int start page , @ request param ( value = str , default value = str ) int page size , principal principal ) { rest wrapper rest wrapper = null ; try { integer counter = workflow type dao . total record count ( ) ; list < workflow type > workflow types = new array list < workflow type > ( ) ; list < com . wipro . ats . bdre . md . dao . jpa . workflow type > jpa workflow types = workflow type dao . list ( start page , page size ) ; for ( com . wipro . ats . bdre . md . dao . jpa . workflow type wf type : jpa workflow types ) { workflow type workflow type = new workflow type ( ) ; workflow type . set workflow id ( wf type . get workflow id ( ) ) ; workflow type . set workflow type name ( wf type . get workflow type name ( ) ) ; workflow type . set counter ( counter ) ; workflow types . add ( workflow type ) ; } rest wrapper = new rest wrapper ( workflow types , rest wrapper . ok ) ; logger . info ( str + principal . get name ( ) ) ; } catch ( exception e ) { logger . error ( e ) ; rest wrapper = new rest wrapper ( e . get message ( ) , rest wrapper . error ) ; } return rest wrapper ; }	this method calls proc getworkflowtypes and fetches the list of instances of workflowtype .
public void parse for class ( generic declaration generic decl , string signature ) { set input ( generic decl , signature ) ; if ( ! eof ) { parse class signature ( ) ; } else { if ( generic decl instanceof class ) { class c = ( class ) generic decl ; this . formal type parameters = empty array . type variable ; this . superclass type = c . get superclass ( ) ; class < ? > [ ] interfaces = c . get interfaces ( ) ; if ( interfaces . length == num ) { this . interface types = list of types . empty ; } else { this . interface types = new list of types ( interfaces ) ; } } else { this . formal type parameters = empty array . type variable ; this . superclass type = object . class ; this . interface types = list of types . empty ; } } }	parses the generic signature of a class and creates the data structure representing the signature .
static boolean try external unpush ( fork join task < ? > t ) { fork join pool p ; work queue [ ] ws ; work queue q ; submitter z ; fork join task < ? > [ ] a ; int m , s ; if ( t != null && ( z = submitters . get ( ) ) != null && ( p = common pool ) != null && ( ws = p . work queues ) != null && ( m = ws . length - num ) >= num && ( q = ws [ m & z . seed & sqmask ] ) != null && ( s = q . top ) != q . base && ( a = q . array ) != null ) { long j = ( ( ( a . length - num ) & ( s - num ) ) << ashift ) + abase ; if ( u . get object ( a , j ) == t && u . compare and swap int ( q , qlock , num , num ) ) { if ( q . array == a && q . top == s && u . compare and swap object ( a , j , t , null ) ) { q . top = s - num ; q . qlock = num ; return bool ; } q . qlock = num ; } } return bool ; }	tries to pop the given task from submitter ' s queue in common pool .
public static double [ ] quantiles ( int n , double [ ] values ) { values = ( double [ ] ) values . clone ( ) ; arrays . sort ( values ) ; double [ ] qtls = new double [ n + num ] ; for ( int i = num ; i <= n ; ++ i ) { qtls [ i ] = values [ ( ( values . length - num ) * i ) / n ] ; } return qtls ; }	compute the n - quantile boundaries for a set of values.
public query exception ( string message , int error code , sql states sql state , throwable cause ) { super ( message , cause ) ; this . message = message ; this . error code = error code ; this . sql state = sql state . get sql state ( ) ; }	creates a query exception with a message and a cause .
public void test constructor string radix16 ( ) { string value = str ; int radix = num ; byte r bytes [ ] = { num , - num , num , num , - num , num , - num , - num } ; big integer a number = new big integer ( value , radix ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = a number . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , a number . signum ( ) ) ; }	create a positive number from a string value and radix 16 .
private csv ( list < csv > records ) { this . records = objects . require non null ( records ) ; }	creates a new instance with the given records .
private workflow . method untag volumes method ( uri system uri , list < uri > volume ur ) { return new workflow . method ( str , system uri , volume ur ) ; }	return a workflow . method for untagvolumes .
private byte [ ] sh ( byte [ ] tobe hashed ) { sh digester = new sh ( ) ; byte [ ] ret value = new byte [ digester . get digest size ( ) ] ; digester . update ( tobe hashed , num , tobe hashed . length ) ; digester . do final ( ret value , num ) ; return ret value ; }	this is the sha - 256 hashing function that is performed on the public key.
@ data provider private static object [ ] [ ] ok resource responses ( ) { return new object [ ] [ ] { { new response ( ok ) } , { new response ( found ) } , { new response ( moved permanently ) } , { new response ( created ) } } ; }	all successful responses are returned without any process . ( not a 5xx server error or a 4xx client error ).
public synchronized void connect ( ) { if ( ! zk connection . is started ( ) ) { zk connection . start ( ) ; } if ( string utils . is empty ( site id ) ) { generate site id ( ) ; } }	connect to zk cluster.
static object convert java time to java sql ( object x ) { if ( x instanceof local date ) { return date . value of ( ( local date ) x ) ; } else if ( x instanceof local date time ) { return timestamp . value of ( ( local date time ) x ) ; } else if ( x instanceof local time ) { return time . value of ( ( local time ) x ) ; } return x ; }	jdbc 4 . 2 helper methods .
@ not null private static default mutable tree node update tree structure ( @ not null default mutable tree node tree node , @ not null zip file compressed apk ) { long compressed size = num ; apk entry entry = apk entry . from node ( tree node ) ; assert entry != null ; if ( tree node . get child count ( ) > num ) { for ( int i = num ; i < tree node . get child count ( ) ; i ++ ) { default mutable tree node child node = update tree structure ( ( default mutable tree node ) tree node . get child at ( i ) , compressed apk ) ; compressed size += ( ( apk entry ) child node . get user object ( ) ) . get compressed size ( ) ; } } else { zip entry ze = compressed apk . get entry ( apk file system . get instance ( ) . get relative path ( entry . get file ( ) ) ) ; if ( ze == null ) { compressed size = - num ; } else { compressed size = ze . get compressed size ( ) ; } } entry . set compressed size ( compressed size ) ; return tree node ; }	updates and returns the given tree structure with info about the compressed size of each node .
public long total memory ( ) { return total memory impl ( ) ; }	returns the total amount of memory in the java virtual machine.
public static void enable sync ( string account name ) { }	enables sync feature in mytracks settings .
public static void scan ( ) { list < scanner registration > scanners = get scanners to run ( ) ; if ( scanners . size ( ) > num ) { url [ ] urls = get search ur ( ) ; if ( urls == null ) { urls = fiter libs ( urls . get ur ( ) ) ; scan ( scanners , urls ) ; } else { scan ( scanners , urls ) ; } } }	scan the project and returns the result associated to the given scanner.
public final void turn to ( double angle ) { angle = geometric . clamp angle degree ( angle ) ; orientation = geometric . clamp angle degree ( angle ) ; geometric . rotate to ( velocity , math . to radians ( orientation ) ) ; }	turn the agent to the given angle given in degrees .
protected int start bridge server ( int port , boolean notify by subscription ) throws io { cache cache = get cache ( ) ; cache server bridge = cache . add cache server ( ) ; bridge . set port ( port ) ; bridge . set notify by subscription ( notify by subscription ) ; bridge . start ( ) ; bridge server port = bridge . get port ( ) ; return bridge . get port ( ) ; }	starts a bridge server on the given port , using the given deserializevalues and notifybysubscription to serve up the given region .
protected object to type ( calendar value ) { return value . get time ( ) ; }	convert from a calendar to the appropriate date type.
protected f restore last filter ( int dialog type ) { f result ; list < f > list ; int i ; result = null ; if ( dialog type == open dialog ) list = get open file filters ( ) ; else list = get save file filters ( ) ; if ( list . size ( ) > num ) { result = get default file filter ( dialog type ) ; set file filter ( result ) ; if ( m != null ) { for ( i = num ; i < list . size ( ) ; i ++ ) { if ( m . compare ( list . get ( i ) , m ) == num ) { result = ( f ) m ; set file filter ( m ) ; break ; } } } } return result ; }	attempts to restore the last filter in use .
public void test char based collisions ( ) { chars to name canonicalizer sym = chars to name canonicalizer . create root ( ) ; try { int first hash = num ; for ( string str : char collisions ) { int hash = sym . calc hash ( str ) ; if ( first hash == num ) { first hash = hash ; } else { assert equals ( first hash , hash ) ; } sym . find symbol ( str . to char array ( ) , num , str . length ( ) , hash ) ; } fail ( str ) ; } catch ( illegal state exception e ) { verify exception ( e , str ) ; assert equals ( chars to name canonicalizer . max coll chain length + num , sym . max collision length ( ) ) ; assert equals ( chars to name canonicalizer . max coll chain length + num , sym . collision count ( ) ) ; assert equals ( chars to name canonicalizer . max coll chain length + num , sym . size ( ) ) ; } }	test to see what happens with pre - computed collisions ; should get an exception .
public void handle tbl data site action href request ( request invocation event event ) throws model control exception { string site name = hex to string ( ( string ) get display field value ( tbl data site action href ) ) ; set page session attribute ( site edit view bean . pg attr site name , site name ) ; site edit view bean vb = ( site edit view bean ) get view bean ( site edit view bean . class ) ; unlock page trail ( ) ; pass pg session map ( vb ) ; vb . forward to ( get request context ( ) ) ; }	handles edit site request .
public static void normalize ( double [ ] doubles , double sum ) { if ( double . is na n ( sum ) ) { throw new illegal argument exception ( str ) ; } if ( sum == num ) { throw new illegal argument exception ( str ) ; } for ( int i = num ; i < doubles . length ; i ++ ) { doubles [ i ] /= sum ; } }	normalizes the doubles in the array using the given value .
private void expand array ( int shard id ) { int new num shards = math . max ( ( int ) math . ceil ( num shards * shard growth factor ) , shard id + num ) ; preconditions . check argument ( new num shards * shard length < integer . max value , str ) ; int [ ] [ ] new array = new int [ new num shards ] [ ] ; system . arraycopy ( reader accessible info . array , num , new array , num , reader accessible info . array . length ) ; reader accessible info = new reader accessible info ( new array ) ; num shards = new num shards ; }	synchronization comment : this method works fine without needing synchronization between the writer and the readers due to the wrapping of the arrays in readeraccessibleinfo.
protected < t > t wait for property value ( string document self link , class < t > type , string prop name , object prop value , boolean should match , atomic integer count ) throws throwable { @ suppress warnings ( str ) list < object > prop = prop value instanceof list ? ( list < object > ) prop value : arrays . as list ( prop value ) ; return wait for property value ( document self link , type , prop name , prop , should match , count ) ; }	waits until the specified document field matches the given value or differs from the given value.
public static string from i ( collection < integer > ip addresses ) { if ( ip addresses == null ) return str ; string buffer sb = new string buffer ( ) ; sb . append ( str ) ; for ( integer ip : ip addresses ) { sb . append ( from i ( ip ) ) ; sb . append ( str ) ; } sb . replace ( sb . length ( ) - num , sb . length ( ) , str ) ; return sb . to string ( ) ; }	accepts a collection of ipv4 addresses as integers and returns a single string useful in tostring method ' s containing collections of ip addresses .
public static final string make java identifier ( string identifier ) { string builder modified identifier = new string builder ( identifier . length ( ) ) ; if ( ! character . is java identifier start ( identifier . char at ( num ) ) ) { modified identifier . append ( str ) ; } for ( int i = num ; i < identifier . length ( ) ; i ++ ) { char ch = identifier . char at ( i ) ; if ( character . is java identifier part ( ch ) && ch != str ) { modified identifier . append ( ch ) ; } else if ( ch == str ) { modified identifier . append ( str ) ; } else { modified identifier . append ( mangle char ( ch ) ) ; } } if ( is java keyword ( modified identifier . to string ( ) ) ) { modified identifier . append ( str ) ; } return modified identifier . to string ( ) ; }	converts the given identifier to a legal java identifier.
public static string encrypt ( string input ) { if ( encryption service == null || input == null || input . length ( ) == num ) { return input ; } return encryption prefix + encryption service . encrypt ( input ) ; }	encrypts the provided string .
public static void create federated namespace ( uri namespace , zoo keeper client zkc ) throws interrupted exception , zoo keeper client . zoo keeper connection exception , keeper exception { string zk sub namespaces path = namespace . get path ( ) + str + znode sub namespaces ; utils . zk create full path optimistic ( zkc , zk sub namespaces path , new byte [ num ] , zkc . get default acl ( ) , create mode . persistent ) ; }	create the federated namespace .
public string process ( ) { while ( off < count ) { while ( off < count ) { char ch = text [ off ] ; if ( ! is special ( ch ) ) { break ; } off ++ ; } if ( ! acronym ( ) ) { token ( ) ; number ( ) ; } } return builder . to string ( ) ; }	this is used to process the internal string and convert it in to a styled string.
public static string bytes to bin hex ( byte [ ] data , int n start pos , int n num of bytes ) { string builder sbuf = new string builder ( ) ; sbuf . set length ( n num of bytes << num ) ; int n pos = num ; for ( int n i = num ; n i < n num of bytes ; n i ++ ) { sbuf . set char at ( n pos ++ , hextab [ ( data [ n i + n start pos ] > > num ) & num ] ) ; sbuf . set char at ( n pos ++ , hextab [ data [ n i + n start pos ] & num ] ) ; } return sbuf . to string ( ) ; }	converts a byte array to a binhex string.
public static void update last ( ) { client utils . last update = system . current time millis ( ) ; }	update the current time .
public replica sets ( collection < replica set > rs specs ) { if ( rs specs != null ) { rs specs . for each ( null ) ; } collections . sort ( non replica sets ) ; }	create a set of replica set specifications .
static private string byte ( ) { byte temp value = byte . max value ; return string . value of ( temp value ) ; }	get the max value for a byte.
protected path node path node ( string pattern ) { final string seq [ ] = pattern . split ( str ) ; final path elt elements [ ] = new path elt [ seq . length ] ; path mod mod = null ; for ( int i = num ; i < seq . length ; i ++ ) { final string s = seq [ i ] ; boolean inverse = s . char at ( num ) == str ; switch ( s . char at ( s . length ( ) - num ) ) { case str : mod = path mod . zero or more ; break ; case str : mod = path mod . one or more ; break ; case str : mod = path mod . zero or one ; break ; } string c = s . substring ( inverse ? num : num , s . length ( ) - ( mod != null ? num : num ) ) ; elements [ i ] = new path elt ( constant node ( c ) , inverse , mod ) ; } return new path node ( new path alternative ( new path sequence ( elements ) ) ) ; }	this method is only implemented in part.
@ override public int startup new worker ( int priority ) { int actual workers started = startup new worker ( priority , null , null ) ; return actual workers started ; }	runs a new worker jvm , by whatever mechanism ( e.
public void add impl interface ( string iname ) { impl interfaces . add ( iname ) ; }	adds implemented interface name .
private static synchronized boolean check folder permissions ( string builder a string builder , string a directory ) { file directory = new file ( a directory ) ; if ( ! directory . exists ( ) ) { directory . mkdirs ( ) ; } if ( ! directory . can read ( ) ) { a string builder . append ( str + directory + str + str ) ; return bool ; } if ( ! directory . can write ( ) ) { a string builder . append ( str + directory + str + str ) ; return bool ; } return bool ; }	checks if a directory already exists.
protected qualified item [ ] parse qualified items ( final string [ ] arguments , final version spec default version , final boolean allow version range , final int start index ) { check . not null ( arguments , str ) ; final list < qualified item > items = new array list < qualified item > ( arguments . length ) ; for ( int i = start index ; i < arguments . length ; i ++ ) { final string arg = arguments [ i ] ; if ( ! string util . is null or empty ( arg ) ) { try { final qualified item qi = new qualified item ( arg , version control constants . authenticated user , default version , allow version range ) ; items . add ( qi ) ; } catch ( final version spec parse exception e ) { report wrong argument ( arg , e ) ; } catch ( final label spec parse exception e ) { report wrong argument ( arg , e ) ; } } } return items . to array ( new qualified item [ items . size ( ) ] ) ; }	parses qualified items ( item specs with optional versions , version ranges , or deletion specifiers ) from the given strings .
public eip editor ( ) { super ( ) ; initialize editing domain ( ) ; }	this creates a model editor . < ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
public boolean delete entry ( basic pool entry entry ) { final boolean found = free entries . remove ( entry ) ; if ( found ) num entries -- ; return found ; }	deletes an entry from this pool.
public conversation service ( final string version date , string username , string password ) { this ( version date ) ; set username and password ( username , password ) ; }	returns an instance of the conversation service using the service ' s default endpoint ( url ) , username and password .
public custom optional < kinesis record > next ( ) throws transient kinesis exception { read more if necessary ( ) ; if ( data . is empty ( ) ) { return custom optional . absent ( ) ; } else { kinesis record record = data . remove first ( ) ; checkpoint = checkpoint . move after ( record ) ; return custom optional . of ( record ) ; } }	returns record if there ' s any present.
private snmp pdu packet execute sub request ( snmp pdu packet req , object user data ) { int error status = snmp definitions . snmp rsp no error ; int i ; if ( req . type == pdu set request pdu ) { i = num ; for ( enumeration < snmp sub request handler > e = subs . elements ( ) ; e . has more elements ( ) ; i ++ ) { snmp sub request handler sub = e . next element ( ) ; sub . set user data ( user data ) ; sub . type = pdu walk request ; sub . run ( ) ; sub . type = pdu set request pdu ; if ( sub . get error status ( ) != snmp definitions . snmp rsp no error ) { if ( snmp adaptor logger . is loggable ( level . finest ) ) { snmp adaptor logger . logp ( level . finest , dbg tag , str , str ) ; } return new error response pdu ( req , error status , sub . get error index ( ) + num ) ; } } } i = num ; for ( enumeration < snmp sub request handler > e = subs . elements ( ) ; e . has more elements ( ) ; i ++ ) { snmp sub request handler sub = e . next element ( ) ; sub . set user data ( user data ) ; sub . run ( ) ; if ( sub . get error status ( ) != snmp definitions . snmp rsp no error ) { if ( snmp adaptor logger . is loggable ( level . finest ) ) { snmp adaptor logger . logp ( level . finest , dbg tag , str , str ) ; } return new error response pdu ( req , error status , sub . get error index ( ) + num ) ; } } return null ; }	the method runs all the sub - requests associated to the current instance of snmprequesthandler .
method ( method doc method doc ) { this . method doc = method doc ; exception types = method doc . thrown exceptions ( ) ; arrays . sort ( exception types , new class doc comparator ( ) ) ; operation string = compute operation string ( ) ; name and descriptor = method doc . name ( ) + util . method descriptor of ( method doc ) ; method hash = compute method hash ( ) ; }	creates a new method instance for the specified method .
public deterministic key ( immutable list < child number > child number path , byte [ ] chain code , ec public as point , @ nullable big integer priv , @ nullable deterministic key parent ) { super ( priv , compress point ( check not null ( public as point ) ) ) ; check argument ( chain code . length == num ) ; this . parent = parent ; this . child number path = check not null ( child number path ) ; this . chain code = arrays . copy of ( chain code , chain code . length ) ; this . depth = parent == null ? num : parent . depth + num ; this . parent fingerprint = ( parent != null ) ? parent . get fingerprint ( ) : num ; }	constructs a key from its components.
private static void s ua col sum lt ge ( matrix block in , matrix block out , double [ ] bv , binary operator b op ) throws dml { int agg0 = sum row sum gt le col sum lt ge ( num , bv , b op ) ; out . allocate dense block ( bool ) ; arrays . fill ( out . get dense block ( ) , num , out . get num columns ( ) , agg0 ) ; if ( agg0 != num ) out . set non zeros ( out . get num columns ( ) ) ; if ( in . is empty block ( bool ) ) return ; sparse block sblock = in . get sparse block ( ) ; for ( int j = num ; j < sblock . num rows ( ) ; j ++ ) if ( ! sblock . is empty ( j ) ) { int apos = sblock . pos ( j ) ; int alen = sblock . size ( j ) ; int [ ] aix = sblock . indexes ( j ) ; double [ ] avals = sblock . values ( j ) ; for ( int i = apos ; i < apos + alen ; i ++ ) { int cnt = sum row sum gt le col sum lt ge ( avals [ i ] , bv , b op ) ; out . quick set value ( num , aix [ i ] , cnt ) ; } } }	uagg colsums sparse matrix for lessthan and greaterthanequal operator.
public held locks grant ( big integer grant id ) { this . grant id = preconditions . check not null ( grant id ) ; creation date ms = system . current time millis ( ) ; expiration date ms = - num ; lock map = lock collections . of ( ) ; lock timeout = null ; version id = null ; }	these grants should not be constructed by users.
public void test pos neg first shorter ( ) { byte a bytes [ ] = { - num , - num , - num , - num , num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { - num , num , num , num , - num , - num , num , num , num , num , - num , num , num , - num , num , num , - num , - num } ; int a sign = num ; int b sign = - num ; byte r bytes [ ] = { num , - num , - num , num , num , num , num , num , num , num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . and ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	and for a positive and a negative numbers ; the first is shorter.
public void remove from all listeners ( map bean map bean ) { if ( map bean != null ) { remove zoom listener ( ( zoom listener ) map bean ) ; map bean . remove projection listener ( this ) ; scale field . set text ( str ) ; } }	this function removes the mapbean object from its set of listeners.
public void test bug19169 ( ) throws exception { mysql data source to serialize = new mysql data source ( ) ; to serialize . set zero date time behavior ( str ) ; boolean test boolean flag = ! to serialize . get allow load local infile ( ) ; to serialize . set allow load local infile ( test boolean flag ) ; int test int flag = to serialize . get blob send chunk size ( ) + num ; to serialize . set blob send chunk size ( string . value of ( test int flag ) ) ; byte array output stream b out = new byte array output stream ( ) ; object output stream obj out = new object output stream ( b out ) ; obj out . write object ( to serialize ) ; obj out . flush ( ) ; object input stream obj in = new object input stream ( new byte array input stream ( b out . to byte array ( ) ) ) ; mysql data source thawed ds = ( mysql data source ) obj in . read object ( ) ; assert equals ( str , thawed ds . get zero date time behavior ( ) ) ; assert equals ( test boolean flag , thawed ds . get allow load local infile ( ) ) ; assert equals ( test int flag , thawed ds . get blob send chunk size ( ) ) ; }	tests fix for bug # 19169 - connectionproperties ( and thus some subclasses ) are not serializable , even though some j2ee containers expect them to be .
public static < t > w < t > of supplier ( final supplier < t > s ) { return w . of ( completable future . supply async ( s ) ) ; }	create a futurew object that asyncrhonously populates using the common forkjoinpool from the user provided supplier.
@ override public void to data ( data output out ) throws io { super . to data ( out ) ; out . write long ( refresh interval ) ; data serializer . write object array ( alert defs , out ) ; }	a callback used by gemfire data serialization mechanism to write to a stream .
public static boolean is string ( string str ) { return null != string hash table . get ( str ) ; }	a hash table containing all the string tokens found in the spec.
protected abstract void perform deployer action on single deployable ( org . codehaus . cargo . container . deployer . deployer deployer , org . codehaus . cargo . container . deployable . deployable deployable , org . codehaus . cargo . container . deployer . deployable monitor monitor ) ;	perform a deployer action on a single deployable .
@ override public tree < string > extract best max rule parse ( int start , int end , list < string > sentence ) { return extract best max rule parse1 ( start , end , num , sentence ) ; }	returns the best parse , the one with maximum expected labelled recall.
private instances vote dataset ( instances dataset ) throws exception { for ( int i = num ; i < dataset . num instances ( ) ; i ++ ) { instance inst = dataset . first instance ( ) ; inst = voted reclassify example ( inst ) ; dataset . add ( inst ) ; dataset . delete ( num ) ; } return dataset ; }	resets the class values of all instances using voting.
@ override public string choose client alias ( final string [ ] key type , final principal [ ] issuers , final socket socket ) { if ( key manager != null ) { return key manager . choose client alias ( key type , issuers , socket ) ; } return null ; }	choose an alias to authenticate the client side of a secure socket given the public key type and the list of certificate issuer authorities recognized by the peer ( if any ) .
css parse css ( input stream reader r , html html c ) throws io { ext input stream reader er = new ext input stream reader ( r ) ; return parse css ( er , html c , null , null ) ; }	reads a css file / stream and returns the tokenized css as a single level element tree with the root appearing as a " style ".
protected pooled connection create ( boolean increment counter ) { if ( increment counter ) size . increment and get ( ) ; pooled connection con = new pooled connection ( get pool properties ( ) , this ) ; return con ; }	create a new pooled connection object.
void release ( ) { if ( sd buffer != null ) sd buffer . release ( ) ; if ( acl buffer != null ) acl buffer . release ( ) ; if ( sid list != null ) { for ( long sid : sid list ) { local free ( sid ) ; } } }	releases memory associated with securitydescriptor.
private void parse session expiration time info ( element sess ) { string sid = null ; long exp time = null ; string temp = sess . get attribute ( str ) ; if ( temp != null ) { sid = temp ; } temp = sess . get attribute ( str ) ; if ( temp != null ) { exp time = new long ( temp ) ; } session response . add session for given uuid ( sid , exp time ) ; }	parses all the sessions expiration for the given user .
public static long generate ( string value ) { int len = value . length ( ) ; long crc = num ; for ( int i = num ; i < len ; i ++ ) crc = next ( crc , value . char at ( i ) ) ; return crc ; }	calculates crc from a string .
public replace dialog ( j text , find replace actions finder actions ) { super ( action utils . get frame for ( text ) , bool ) ; init components ( ) ; register key action ( this ) ; text component = text ; finder = finder actions ; text component . add caret listener ( this ) ; set location relative to ( text . get root pane ( ) ) ; }	creates new form finddialog.
public string dump ( x509 certificate certificate ) throws asn1 exception , io { try { return dump ( certificate . get encoded ( ) ) ; } catch ( io ex ) { throw new asn1 exception ( res . get string ( str ) , ex ) ; } catch ( certificate encoding exception ex ) { throw new asn1 exception ( res . get string ( str ) , ex ) ; } }	get dump of the supplied x.
list < string > find in package ( test test , string package name ) { list < string > local clsss or pkgs = new array list < string > ( ) ; package name = package name . replace ( str , str ) ; enumeration < url > urls ; try { urls = classloader . get resources ( package name ) ; if ( ! urls . has more elements ( ) ) { log . warn ( str + package name + str ) ; } } catch ( io ioe ) { log . warn ( str + package name ) ; return local clsss or pkgs ; } return find in package with urls ( test , package name , urls ) ; }	scans for classes starting at the package provided and descending into subpackages.
protected abstract element make tooltip ( dbid id , double x , double y , double dotsize ) ;	make a tooltip element for this id .
public cloud object ( string type , int permissions ) { access permissions = permissions ; values . put ( cloud storage . type field , type ) ; }	create an object with different permissions settings.
public double distance ( double vector v ) { double delta x = v . x - x , delta y = v . y - y , delta z = v . z - z ; return math . sqrt ( delta x * delta x + delta y * delta y + delta z * delta z ) ; }	calculates the squared distance between the point corresponding to this vector and the point corresponding to the vector v .
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( ) ; new vector . add ( new option ( str + str , str , num , str ) ) ; new vector . add ( new option ( str + str , str , num , str ) ) ; new vector . add ( new option ( str + str , str , num , str ) ) ; new vector . add ( new option ( str + str + str + str , str , num , str ) ) ; new vector . add ( new option ( str + str + str + str + str + str , str , num , str ) ) ; new vector . add ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add ( new option ( str + str + str , str , num , str ) ) ; return new vector . elements ( ) ; }	lists the available options.
@ override public void drop user ( user user , boolean ignore ) throws sql { string sql = string . format ( str , user . get login ( ) ) ; try { execute ( sql ) ; } catch ( sql e ) { if ( ! ignore ) { throw e ; } else if ( logger . is debug enabled ( ) ) { logger . debug ( str + sql , e ) ; } } }	drops user , ignoring errors if desired by caller .
@ override public boolean e is set ( int feature id ) { switch ( feature id ) { case information model package . functionblock property name : return name edefault == null ? name != null : ! name edefault . equals ( name ) ; case information model package . functionblock property description : return description edefault == null ? description != null : ! description edefault . equals ( description ) ; case information model package . functionblock property type : return type != null ; } return super . e is set ( feature id ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
public double normalized distance ( double [ ] point1 , double [ ] point2 ) throws exception { return math . sqrt ( distance2 ( point1 , point2 ) ) / point1 . length ; }	calculates the normalized euclidean distance between two points .
public static < t > void on next dropped ( t t ) { if ( t != null ) { consumer < object > hook = hooks . on next dropped hook ; if ( hook == null ) { throw exceptions . fail with cancel ( ) ; } hook . accept ( t ) ; } }	an unexpected event is about to be dropped .
public static int [ ] random ints ( int max , int count ) { int [ ] vals = new int [ count ] ; for ( int i = num ; i < count ; i ++ ) vals [ i ] = seeded random . next int ( max ) ; return vals ; }	return an array of length count containing random integers in the range ( 0 , max ) generated off the test rng .
void load strings ( ) throws io { int count = m header item . string ids size ; int string offsets [ ] = new int [ count ] ; seek ( m header item . string ids off ) ; for ( int i = num ; i < count ; i ++ ) { string offsets [ i ] = read int ( ) ; } m strings = new string [ count ] ; seek ( string offsets [ num ] ) ; for ( int i = num ; i < count ; i ++ ) { seek ( string offsets [ i ] ) ; m strings [ i ] = read string ( ) ; } }	loads the string table out of the dex.
public boolean add gps date time stamp tag ( long timestamp ) { exif tag t = build tag ( tag gps date stamp , m gps . format ( timestamp ) ) ; if ( t == null ) { return bool ; } set tag ( t ) ; m gps . set time in millis ( timestamp ) ; t = build tag ( tag gps time stamp , new rational [ ] { new rational ( m gps . get ( calendar . hour of day ) , num ) , new rational ( m gps . get ( calendar . minute ) , num ) , new rational ( m gps . get ( calendar . second ) , num ) } ) ; if ( t == null ) { return bool ; } set tag ( t ) ; return bool ; }	creates and sets the gps timestamp tag .
public void add area ( final time section area ) { if ( null == area ) return ; areas . add ( area ) ; collections . sort ( areas , new time section comparator ( ) ) ; fire update event ( section event ) ; }	adds the given timesection to the list of areas.
public string to string ( ) { return descriptor . to class name ( character . to string ( descriptor ) ) ; }	returns the string representation .
private void raise io ( string host , int port , string protocol ) { io io error = new io ( this , host , port , protocol ) ; sip provider . handle event ( io error , null ) ; set state ( sip . terminated state ) ; }	raise an io exception for asyncrhonous retransmission of responses.
public static double incomplete gamma complement ( double a , double x ) { double ans , ax , c , yc , r , t , y , z ; double pk , pkm1 , pkm2 , qk , qkm1 , qkm2 ; if ( x <= num || a <= num ) return num ; if ( x < num || x < a ) return num - incomplete gamma ( a , x ) ; ax = a * math . log ( x ) - x - ln gamma ( a ) ; if ( ax < - maxlog ) return num ; ax = math . exp ( ax ) ; y = num - a ; z = x + y + num ; c = num ; pkm2 = num ; qkm2 = x ; pkm1 = x + num ; qkm1 = z * x ; ans = pkm1 / qkm1 ; do { c += num ; y += num ; z += num ; yc = y * c ; pk = pkm1 * z - pkm2 * yc ; qk = qkm1 * z - qkm2 * yc ; if ( qk != num ) { r = pk / qk ; t = math . abs ( ( ans - r ) / r ) ; ans = r ; } else t = num ; pkm2 = pkm1 ; pkm1 = pk ; qkm2 = qkm1 ; qkm1 = qk ; if ( math . abs ( pk ) > big ) { pkm2 *= biginv ; pkm1 *= biginv ; qkm2 *= biginv ; qkm1 *= biginv ; } } while ( t > machep ) ; return ans * ax ; }	returns the complemented incomplete gamma function .
@ override public object deserialize typed from object ( json parser jp , deserialization context ctxt ) throws io , json processing exception { json token t = jp . get current token ( ) ; if ( t == json token . start object ) { t = jp . next token ( ) ; } else if ( t == json token . start array ) { return deserialize typed using default impl ( jp , ctxt , null ) ; } else if ( t != json token . field name ) { return deserialize typed using default impl ( jp , ctxt , null ) ; } token buffer tb = null ; for ( ; t == json token . field name ; t = jp . next token ( ) ) { string name = jp . get current name ( ) ; jp . next token ( ) ; if ( type property name . equals ( name ) ) { string type id = jp . get text ( ) ; json deserializer < object > deser = find deserializer ( ctxt , type id ) ; if ( tb != null ) { jp = json parser sequence . create flattened ( tb . as parser ( jp ) , jp ) ; } jp . next token ( ) ; return deser . deserialize ( jp , ctxt ) ; } if ( tb == null ) { tb = new token buffer ( null ) ; } tb . write field name ( name ) ; tb . copy current structure ( jp ) ; } return deserialize typed using default impl ( jp , ctxt , tb ) ; }	this is the trickiest thing to handle , since property we are looking for may be anywhere.
protected int layout row ( flow view fv , int row index , int p0 ) { int p1 = super . layout row ( fv , row index , p0 ) ; view row = fv . get view ( row index ) ; document doc = fv . get document ( ) ; object i18n flag = doc . get property ( abstract document . n ) ; if ( ( i18n flag != null ) && i18n flag . equals ( boolean . true ) ) { int n = row . get view count ( ) ; if ( n > num ) { abstract document d = ( abstract document ) fv . get document ( ) ; element bidi root = d . get bidi root element ( ) ; byte [ ] levels = new byte [ n ] ; view [ ] reorder = new view [ n ] ; for ( int i = num ; i < n ; i ++ ) { view v = row . get view ( i ) ; int bidi index = bidi root . get element index ( v . get start offset ( ) ) ; element bidi elem = bidi root . get element ( bidi index ) ; levels [ i ] = ( byte ) style constants . get bidi level ( bidi elem . get attributes ( ) ) ; reorder [ i ] = v ; } bidi utils . reorder visually ( levels , reorder ) ; row . replace ( num , n , reorder ) ; } } return p1 ; }	creates a row of views that will fit within the layout span of the row.
public generator ( string prop file ) { try { buffered input stream bi = null ; try { bi = new buffered input stream ( new file input stream ( prop file ) ) ; props . load ( bi ) ; } finally { if ( bi != null ) { bi . close ( ) ; } } } catch ( exception e ) { set default props ( ) ; } }	create a new generator object with properties loaded from a file.
public static void clear logging behaviors ( ) { synchronized ( logging behaviors ) { logging behaviors . clear ( ) ; } }	certain logging behaviors are available for debugging beyond those that should be enabled in production.
protected void audit op ( uri tenant id , uri user id , operation type enum op type , boolean operational status , string operation stage , object ... descparams ) { audit mgr . record audit log ( tenant id , user id , event service type , op type , system . current time millis ( ) , operational status ? audit log manager . auditlog success : audit log manager . auditlog failure , operation stage , descparams ) ; }	record audit log for services.
@ visible for testing protected process start executor process ( int container ) { return shell utils . run a ( get executor command ( container ) , new file ( local context . working directory ( config ) ) , integer . to string ( container ) ) ; }	start executor process via running an async shell process.
private boolean is item at position selectable ( int position ) { return ! m unselectable items . contains ( position ) ; }	return whether the item at position is selectable ( i.
public builder add engine settings ( final string engine name , final list < string > imports , final list < string > static imports , final list < string > scripts , final map < string , object > config ) { if ( null == imports ) throw new illegal argument exception ( str ) ; if ( null == static imports ) throw new illegal argument exception ( str ) ; if ( null == scripts ) throw new illegal argument exception ( str ) ; final map < string , object > m = null == config ? collections . empty map ( ) : config ; settings . put ( engine name , new engine settings ( imports , static imports , scripts , m ) ) ; return this ; }	add a particular script engine for the executor to instantiate .
private void display popup menu ( final mouse event event ) { final int selected index = get selection index ( event ) ; if ( selected index != - num ) { final j popup menu = get popup menu ( event . get x ( ) , event . get y ( ) , selected index ) ; if ( popup menu != null ) { popup menu . show ( this , event . get x ( ) , event . get y ( ) ) ; } } }	creates a popup menu depending on where the user clicked and shows that context menu in the table .
protected void handle selected ( structured selection selection ) { i status = new status ( i . ok , ui . plugin id , i . ok , empty string , null ) ; object [ ] last selection = current selection ; current selection = selection . to array ( ) ; if ( selection . size ( ) == num ) { status = new status ( i . error , ui . plugin id , i . error , empty string , null ) ; if ( last selection != null && get list selection label decorator ( ) != null ) { list . update ( last selection , null ) ; } current selection = null ; } else { status = new status ( i . error , ui . plugin id , i . error , empty string , null ) ; list items = selection . to list ( ) ; object item = null ; i temp status = null ; for ( iterator it = items . iterator ( ) ; it . has next ( ) ; ) { object o = it . next ( ) ; if ( o instanceof items list separator ) { continue ; } item = o ; temp status = validate item ( item ) ; if ( temp status . is ok ( ) ) { status = new status ( i . ok , ui . plugin id , i . ok , empty string , null ) ; } else { status = temp status ; break ; } } if ( last selection != null && get list selection label decorator ( ) != null ) { list . update ( last selection , null ) ; } if ( get list selection label decorator ( ) != null ) { list . update ( current selection , null ) ; } } refresh details ( ) ; update status ( status ) ; }	handle selection in the items list by updating labels of selected and unselected items and refresh the details field using the selection .
public linked list < diff > diff main ( string text1 , string text2 , boolean checklines ) { long deadline ; if ( diff timeout <= num ) { deadline = long . max value ; } else { deadline = system . current time millis ( ) + ( long ) ( diff timeout * num ) ; } return diff main ( text1 , text2 , checklines , deadline ) ; }	find the differences between two texts .
private void update alt deviceid ( fc fabric info , string fabric id , string fabric wwn , string key , map < string , network lite > fabric id2 network ) { if ( fabric info != null && fabric info . get alt network device id ( ) == null ) { if ( fabric id2 network . get ( key ) == null ) { network lite network = network util . get network lite by fabric id ( fabric id , fabric wwn , db client ) ; if ( network != null ) { fabric id2 network . put ( key , network ) ; uri id = fabric info . get network device id ( ) ; for ( string str uri : network . get network systems ( ) ) { if ( ! str uri . equals ( id . to string ( ) ) ) { id = uri . create ( str uri ) ; break ; } } fabric info . set alt network device id ( id ) ; } } } }	ensures every fabricinfo has its altnetworkdevice that is not null when the calling code did not already supply a value for this field .
public static network info from version ( final byte version ) { for ( final network info info : known networks ) { if ( version == info . get version ( ) ) { return info ; } } throw new illegal argument exception ( string . format ( str , version ) ) ; }	gets the network info from the version .
public void write ( byte code writer out ) throws io { out . write ut ( get name ( ) ) ; temp output stream ts = new temp output stream ( ) ; byte code writer o2 = new byte code writer ( ts , out . get java class ( ) ) ; o2 . write short ( exceptions . size ( ) ) ; for ( int i = num ; i < exceptions . size ( ) ; i ++ ) { string exn = exceptions . get ( i ) ; o2 . write class ( exn ) ; } ts . close ( ) ; out . write int ( ts . get length ( ) ) ; temp buffer ptr = ts . get head ( ) ; for ( ; ptr != null ; ptr = ptr . next ( ) ) out . write ( ptr . buffer ( ) , num , ptr . length ( ) ) ; ts . destroy ( ) ; }	writes the field to the output .
public synchronized addressbook entry remove ( string name , set < string > categories to remove ) { name = string util . to lower case ( name ) ; addressbook entry current entry = entries . get ( name ) ; if ( current entry != null ) { set < string > current categories = current entry . get categories ( ) ; for ( string category : categories to remove ) { current categories . remove ( category ) ; } addressbook entry changed entry = new addressbook entry ( name , current categories ) ; entries . put ( name , changed entry ) ; if ( ! current entry . equals fully ( changed entry ) ) { save on change ( ) ; } return changed entry ; } return null ; }	removes the given categories from the entry with the given name .
public string shortest match ( string input ) { trie node node = root ; for ( int i = input . length ( ) - num ; i >= num ; i -- ) { node = node . get child ( input . char at ( i ) ) ; if ( node == null ) return null ; if ( node . is terminal ( ) ) return input . substring ( i ) ; } return null ; }	returns the shortest suffix of < code > input < code > that is matched , or < code > null < code > if no match exists .
public static boolean is windows95 ( ) { return os name . index of ( str ) > - num && os version . equals ( str ) ; }	is operating system windows 95 ?.
public static rh has rh ( config impl config , extension defintion ed ) throws page exception , sax , io { xml admin = new xml ( config , null ) ; return admin . has rh ( config , ed ) ; }	returns the version if the extension is available.
public void add query to history ( string sql ) { query history . remove ( sql ) ; query history . add first ( sql ) ; while ( history size >= num && query history . size ( ) > history size ) { query history . remove last ( ) ; } }	adds the query to history .
public string builder encode body ( string builder retval ) { retval . append ( less than ) ; error info . encode ( retval ) ; retval . append ( greater than ) ; if ( ! parameters . is empty ( ) ) { retval . append ( semicolon ) ; parameters . encode ( retval ) ; } return retval ; }	encode into canonical form .
public final < r > parallel flux < r > reduce ( supplier < r > initial supplier , bi function < r , t , r > reducer ) { objects . require non null ( initial supplier , str ) ; objects . require non null ( reducer , str ) ; return on assembly ( new parallel reduce < > ( this , initial supplier , reducer ) ) ; }	reduces all values within a ' rail ' to a single value ( with a possibly different type ) via a reducer function that is initialized on each rail from an initialsupplier value.
private void handle button event ( final event event ) { switch ( event . type ) { case swt . focus in : { handle focus events ( swt . focus in ) ; break ; } case swt . selection : { change visibility of popup window ( ! is dropped ( ) ) ; break ; } } }	handle a button event.
private void perform update operations ( context context , request request , json value after value , json value before value ) throws resource exception { final string managed id = get managed object id ( context ) ; activity logger . log ( context , request , str , get managed object path ( context ) , before value , after value , status . success ) ; managed object set service . update ( context , new update request ( managed id , after value ) , managed id , null , before value , after value , new hash set < > ( arrays . as list ( property ptr ) ) , new hash set < > ( arrays . as list ( property ptr ) ) ) ; }	performs operations associated with the updated managed object.
public static boolean can string be inline encoded ( string skey ) { if ( skey . length ( ) > get max inline string key ( max longs used for string key , bool ) ) { return null ; } if ( is byte encoding ok ( skey ) ) { return boolean . true ; } else { if ( skey . length ( ) > get max inline string key ( max longs used for string key , bool ) ) { return null ; } else { return boolean . false ; } } }	return null if the given string can not be encoded inline.
public builder ( date created , date last modified ) { this . created = created != null ? new date ( created . get time ( ) ) : null ; this . last modified = last modified != null ? new date ( last modified . get time ( ) ) : null ; }	will set created to given value and lastmodified to system.
@ override public void write byte stream ( input stream is ) throws io { while ( bool ) { int len = size - offset - num ; if ( len < num ) { flush buffer ( ) ; len = size - offset - num ; } len = is . read ( buffer , offset + num , len ) ; if ( len <= num ) { buffer [ offset ++ ] = bc binary direct ; return ; } buffer [ offset + num ] = ( byte ) bc binary chunk ; buffer [ offset + num ] = ( byte ) ( len > > num ) ; buffer [ offset + num ] = ( byte ) ( len ) ; offset += len + num ; } }	writes a full output stream .
public void remove selection change listener ( final selection change listener listener ) { check widget ( ) ; if ( listener == null ) { swt . error ( swt . error null argument ) ; } if ( selection change listeners == null ) { return ; } selection change listeners . remove ( listener ) ; }	removes the listener from the collection of listeners who will be notified when the user changes the receiver ' s selection .
public track add track ( string name , string type ) { track track = get track by name ( name , type ) ; if ( track == null ) { id number ++ ; string id = id + str + integer . to string ( id number ) ; log . debug ( str , type , get name ( ) , name , id ) ; track = new track ( id , name , type , this ) ; register ( track ) ; } reset moves ( ) ; return track ; }	adds a track to this location.
sq register loader ( final sq loader , final string table ) { logger . d ( tag , str , table ) ; final sq entry = new sq ( loader , table ) ; m active loaders . add ( entry ) ; return entry ; }	register a loader for maintaining notify changes.
public void unbind tree ( container ui ) { int component count = ui . get component count ( ) ; for ( int iter = num ; iter < component count ; iter ++ ) { component c = ui . get component at ( iter ) ; if ( c instanceof container ) { unbind tree ( ( container ) c ) ; continue ; } string bind = c . get cloud bound property ( ) ; if ( bind != null && bind . length ( ) > num ) { string attribute name = c . get cloud destination property ( ) ; if ( attribute name != null ) { unbind property ( c , bind ) ; } } } }	clears the binding to this component tree.
protected list < item > to items ( list < model > models ) { if ( models == null ) { return collections . empty list ( ) ; } int size = models . size ( ) ; list < item > items = new array list < > ( size ) ; for ( int i = num ; i < size ; i ++ ) { items . add ( to item ( models . get ( i ) ) ) ; } return items ; }	helper to get a list of item from a list o model.
public void apply ( filter set filter set , filter service granular lock factory lock factory ) { for ( filter set entry entry : filter set . get filters ( ) ) { add ( entry . get filter value set ( ) , entry . get handle ( ) , lock factory ) ; } }	add the filters , from previously - taken filters .
public void add constraint command ( define command command ) { if ( command instanceof create index ) { constraint commands . add ( command ) ; } else { alter table add constraint con = ( alter table add constraint ) command ; boolean already set ; if ( con . get type ( ) == command interface . alter table add constraint primary key ) { already set = set primary key columns ( con . get index columns ( ) ) ; } else { already set = bool ; } if ( ! already set ) { constraint commands . add ( command ) ; } } }	add a constraint statement to this statement.
public void test invite cancel ( ) { do cancel test ( bool ) ; }	jvb : tests transmission of an invite followed by cancellation of that request - > invite < - 100 - > cancel < - ok < - 487 - > ack.
private static byte [ ] lmv2 response ( final byte [ ] hash , final byte [ ] challenge , final byte [ ] client data ) throws authentication exception { final hmacm hmac m = new hmacm ( hash ) ; hmac m . update ( challenge ) ; hmac m . update ( client data ) ; final byte [ ] mac = hmac m . get output ( ) ; final byte [ ] lmv2 response = new byte [ mac . length + client data . length ] ; system . arraycopy ( mac , num , lmv2 response , num , mac . length ) ; system . arraycopy ( client data , num , lmv2 response , mac . length , client data . length ) ; return lmv2 response ; }	creates the lmv2 response from the given hash , client data , and type 2 challenge .
static < e > e check type ( e obj , class < ? extends e > type ) { if ( obj != null && ! type . is instance ( obj ) ) { throw new class cast exception ( str + obj . get class ( ) + str + type ) ; } return obj ; }	checks if specified object is instance of specified class.
public void test value of long positive1 ( ) { long long val = num ; big integer a number = big integer . value of ( long val ) ; byte r bytes [ ] = { num , - num , - num , num , - num , - num , num , num } ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = a number . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , a number . signum ( ) ) ; }	valueof ( long val ) : convert a positive long value to a biginteger .
public void destroy ( ) { m filter config = null ; }	take this filter out of service .
@ override public parcelable on save instance state ( ) { string path = m photo file path . get ( ) ; if ( path == null ) return null ; bundle bundle = new bundle ( ) ; bundle . put string ( str , path ) ; return bundle ; }	saves photo file path during e.
public static boolean create folder ( string folder path ) { if ( ! text utils . is empty ( folder path ) ) { file folder = new file ( folder path ) ; return create folder ( folder ) ; } return bool ; }	create a folder , if the folder exists is not created .
public void test empty journal ( ) throws io , interrupted exception , execution exception { final file out = file . create temp file ( get name ( ) , options . jnl ) ; try { final journal src = get store ( get properties ( ) ) ; try { final future < map < string , base index stats > > f = src . warm up ( null ) ; final map < string , base index stats > map = f . get ( ) ; assert equals ( num , map . size ( ) ) ; } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }	verify operation ok when nothing has been written on the journal .
@ override public void key released ( key event e ) { char [ ] password1 = null ; char [ ] password2 = null ; if ( password field != null ) { password1 = password field . get password ( ) ; } if ( repeat password field != null ) { password2 = repeat password field . get password ( ) ; } boolean tick label visible = bool ; if ( password1 != null && password2 != null ) { if ( arrays . equals ( password1 , password2 ) ) { tick label visible = bool ; } } tick label . set visible ( tick label visible ) ; clear messages ( ) ; for ( int i = num ; i < password1 . length ; i ++ ) { password1 [ i ] = num ; } for ( int i = num ; i < password2 . length ; i ++ ) { password2 [ i ] = num ; } }	handle the key - released event from the text field .
private static period formatter and value select formatter ( period days period ) { int days = days period . get days ( ) ; if ( days > num ) { return pav ( day formatter , days ) ; } int hours = days period . get hours ( ) ; if ( hours > num ) { return pav ( hour formatter , hours ) ; } int minutes = days period . get minutes ( ) ; if ( minutes > num ) { return pav ( minute formatter , minutes ) ; } int seconds = days period . get seconds ( ) ; if ( seconds > num ) { return pav ( second formatter , seconds ) ; } return null ; }	best matching formatter of null if auction ended .
void add arg ( string arg ) { args . add ( arg ) ; }	add left - over unrecognized option / argument .
public java . lang . string buffer insert ( int offset , float f ) { internal . insert ( offset , f ) ; return this ; }	inserts the string representation of the float argument into this string buffer.
private void update gwt27 on ( i java project , list < string > program args , int index disabled , int index enabled , boolean super dev mode enabled ) { if ( index enabled > - num ) { program args . remove ( index enabled ) ; } if ( index disabled > - num ) { program args . remove ( index disabled ) ; } if ( ! super dev mode enabled ) { program args . add ( num , superdevmode disabled arg ) ; } }	update program args for project gwt > = 2.
default boolean smash block ( entity player player , world world , block pos pos , i state , tool tier tier ) { tool tier required = get required tier ( state ) ; if ( required != null && tier . is greater than or equal to ( required ) ) { float luck = tier . ordinal ( ) * num ; list < item stack > drops = get drops ( player , world , pos , state , luck ) ; if ( drops . size ( ) > num ) { if ( ! world . is remote ) { world . set block to air ( pos ) ; for ( item stack drop : drops ) { spawn as entity ( world , pos , drop ) ; } } return bool ; } } return bool ; }	called to smash this block.
protected string fetch native id ( string native guid ) { string [ ] token = native guid . split ( vnx . plus seperator ) ; return token [ token . length - num ] ; }	utility to get the filesharenativeid from nativeguid .
public static string to string ( final double value ) { return double . to string ( value ) ; }	converts the given value to the xml string value .
public long rss ( ) { return long . parse long ( fields [ num ] ) ; }	resident set size : number of pages the process has in real memory.
public static void init ( context context , boolean is top ) { camera manager = new camera manager ( context , is top ) ; }	initializes this static object with the context of the calling activity .
public static plain text plain ( float text ) { return plain ( float . to string ( text ) ) ; }	creates a new plaintext component with the given float.
public final void append ( char value ) { char [ ] chunk ; if ( m first free < m chunk size ) chunk = m array [ m last chunk ] ; else { int i = m array . length ; if ( m last chunk + num == i ) { char [ ] [ ] newarray = new char [ i + num ] [ ] ; system . arraycopy ( m array , num , newarray , num , i ) ; m array = newarray ; } chunk = m array [ ++ m last chunk ] ; if ( chunk == null ) { if ( m last chunk == num << m rebundle bits && m chunk bits < m max chunk bits ) { m inner fsb = new fast string buffer ( this ) ; } chunk = m array [ m last chunk ] = new char [ m chunk size ] ; } m first free = num ; } chunk [ m first free ++ ] = value ; }	append a single character onto the faststringbuffer , growing the storage if necessary.
public socket create socket ( inet address address , int port , inet address my address , int my port ) throws io { if ( my address != null ) { socket sock = new socket ( ) ; sock . bind ( new inet socket address ( my address , num ) ) ; try { sock . connect ( new inet socket address ( address , port ) , num ) ; } catch ( socket timeout exception e ) { throw new connect exception ( str + address + str + port ) ; } return sock ; } else { socket sock = new socket ( ) ; if ( my port != num ) { sock . bind ( new inet socket address ( port ) ) ; } try { sock . connect ( new inet socket address ( address , port ) , num ) ; } catch ( socket timeout exception e ) { throw new connect exception ( str + address + str + port ) ; } return sock ; } }	creates a new socket , binds it to myaddress : myport and connects it to address : port .
private static void update cluster tenant ( db client db client , uri data center id , uri tenant id ) { list < named element > clusters uris = list children ( db client , data center id , cluster . class , str , str ) ; for ( named element cluster uri : clusters uris ) { cluster cluster = db client . query object ( cluster . class , cluster uri . get id ( ) ) ; if ( cluster != null ) { cluster . set tenant ( tenant id ) ; db client . persist object ( cluster ) ; } } }	updates the cluster ' s tenant .
public static int prefix length ( char [ ] s1 , char [ ] s2 ) { int len = num ; int max = math . min ( s1 . length , s2 . length ) ; for ( int i = num ; i < max && s1 [ i ] == s2 [ i ] ; ++ i ) ++ len ; return len ; }	returns the length of the common prefix between s1 and s2 .
private static boolean is less than one week ( date date ) { calendar calendar = calendar . get instance ( ) ; calendar . add ( calendar . day of month , - num ) ; return date . after ( calendar . get time ( ) ) ; }	check if the date is less than 7 days from now.
private int col to loc ( int col , vector < mapping pair > vec ) { int loc = col ; for ( int i = num ; ( i < vec . size ( ) ) && ( vec . element at ( i ) . col <= col ) ; i ++ ) { loc = loc + vec . element at ( i ) . inc ; } return loc ; }	returns the string position to which the line - mapping defined by mappingpair vec maps the column col .
protected boolean [ ] can handle n ( attr types attr types , int num classes ) { print ( str ) ; print attribute summary ( attr types , attribute . nominal ) ; print ( str ) ; array list < string > accepts = new array list < string > ( ) ; accepts . add ( str ) ; accepts . add ( str ) ; int num train = get num instances ( ) , num test = get num instances ( ) , missing level = num ; boolean attribute missing = bool , class missing = bool ; int num attr = num , attr index = num ; return run basic test ( attr types , num attr , attr index , attribute . nominal , missing level , attribute missing , class missing , num train , num test , num classes , accepts ) ; }	checks whether nominal schemes can handle more than two classes.
public type variable type variable ( ) { int id = type variable list . size ( ) ; type variable list . add ( null ) ; type variable result = new type variable ( id , this ) ; type variable list . set ( id , result ) ; return result ; }	get new type variable.
public static char [ ] create type parameter signature ( char [ ] type parameter name , char [ ] [ ] bound signatures ) { int length = bound signatures . length ; if ( length == num ) { return char operation . append ( type parameter name , c colon ) ; } int bounds size = num ; for ( int i = num ; i < length ; i ++ ) { bounds size += bound signatures [ i ] . length + num ; } int name length = type parameter name . length ; char [ ] result = new char [ name length + bounds size ] ; system . arraycopy ( type parameter name , num , result , num , name length ) ; int index = name length ; for ( int i = num ; i < length ; i ++ ) { result [ index ++ ] = c colon ; int bound length = bound signatures [ i ] . length ; system . arraycopy ( bound signatures [ i ] , num , result , index , bound length ) ; index += bound length ; } return result ; }	creates a new type parameter signature with the given name and bounds .
void cancel statement ( string session id , int statement id ) { for ( tcp server thread c : new . array list ( running ) ) { if ( c != null ) { c . cancel statement ( session id , statement id ) ; } } }	cancel a running statement .
public static double parse double ( string s ) { if ( positive infinity . equals ( s ) ) { return double . positive infinity ; } else if ( negative infinity . equals ( s ) ) { return double . negative infinity ; } else if ( n . equals ( s ) ) { return double . n ; } else { s = trim plus sign ( s ) ; return double . parse double ( s ) ; } }	parses the supplied xsd : double string and returns its value .
public void finish zombie tasks with error ( ) { list < pollable task > zombie pollable tasks ; do { logger . debug ( str ) ; page request pageable = new page request ( num , num ) ; zombie pollable tasks = pollable task repository . find zombie pollable tasks ( pageable ) ; for ( pollable task zombie pollable task : zombie pollable tasks ) { mark as finished with error ( zombie pollable task ) ; } } while ( ! zombie pollable tasks . is empty ( ) ) ; }	marks zombie tasks as finished with error.
public cookie entity ( uri uri , http cookie cookie ) { this . uri = uri == null ? null : uri . to string ( ) ; this . name = cookie . get name ( ) ; this . value = cookie . get value ( ) ; this . comment = cookie . get comment ( ) ; this . comment url = cookie . get comment url ( ) ; this . discard = cookie . get discard ( ) ; this . domain = cookie . get domain ( ) ; long max age = cookie . get max age ( ) ; if ( max age != - num && max age > num ) { this . expiry = ( max age * num ) + system . current time millis ( ) ; if ( this . expiry < num ) this . expiry = header util . get max expiry millis ( ) ; } else this . expiry = - num ; this . path = cookie . get path ( ) ; if ( ! text utils . is empty ( path ) && path . length ( ) > num && path . ends with ( str ) ) { this . path = path . substring ( num , path . length ( ) - num ) ; } this . port list = cookie . get portlist ( ) ; this . secure = cookie . get secure ( ) ; this . version = cookie . get version ( ) ; }	cookie building database entities .
public void add value ( t value ) { list . add first ( value ) ; total += double . value of ( value . to string ( ) ) ; trim ( ) ; }	add a value to the averager.
private void update traffic mask ( ) { int queue size = traffic controlling sessions . size ( ) ; while ( queue size > num ) { s session = traffic controlling sessions . poll ( ) ; if ( session == null ) { return ; } session state state = get state ( session ) ; switch ( state ) { case opened : update traffic control ( session ) ; break ; case closing : break ; case opening : traffic controlling sessions . add ( session ) ; break ; default : throw new illegal state exception ( string . value of ( state ) ) ; } queue size -- ; } }	update the trafficcontrol for all the session .
public object create soft weak ref ( object o ) { return new weak reference ( o ) ; }	creates a soft / weak reference to an object that allows it to be collected yet caches it.
public boolean has entries ( ) { return ! f entries . is empty ( ) ; }	returns whether the status has entries or not .
protected string convert to string ( object value ) throws throwable { string result = null ; if ( use locale format && value instanceof number ) { number format format = get format ( ) ; format . set grouping used ( bool ) ; result = format . format ( value ) ; } else { result = value . to string ( ) ; } return result ; }	convert an input number object into a string .
public esri shape export ( om list , projection proj , string path to file ) { set graphic list ( list ) ; projection = proj ; file path = path to file ; debug = logger . is loggable ( level . fine ) ; }	create an esrishapeexport object .
private void check log folder ( ) { file folder = new file ( folder path ) ; if ( ! folder . exists ( ) ) { folder . mkdirs ( ) ; } }	make sure the folder of log file exists .
private void test complete on timeout times out ( integer v ) { long timeout millis = timeout millis ( ) ; completable future < integer > f = new completable future < > ( ) ; long start time = system . nano time ( ) ; assert same ( f , f . complete on timeout ( v , timeout millis , milliseconds ) ) ; assert same ( v , f . join ( ) ) ; assert true ( millis elapsed since ( start time ) >= timeout millis ) ; f . complete ( num ) ; check completed normally ( f , v ) ; }	completeontimeout completes with given value if not complete.
private synchronized void reschedule ( long millis ) { current fut = null ; if ( ! closed ) { scheduler . schedule ( null , millis , time unit . milliseconds ) ; } else { try { underlying . close ( ) ; } catch ( exception ex ) { log . log ( level . warning , str + underlying . config string ( ) , ex ) ; } } }	schedule next invocation of the update task .
public static content verifier provider create default content verifier ( public key key ) throws operator creation exception { if ( str == key . get algorithm ( ) ) { return sun verification builder . build ( key ) ; } else { return bc verification builder . build ( key ) ; } }	creates a new content verifier using default algorithm .
public void add rule ( final rule rule ) { rule . set id ( rule id counter ++ ) ; rules . add ( rule ) ; }	will add the rule to the rules list .
public static object serialize clone ( final object obj ) throws io , class not found exception { byte array output stream mem out = new byte array output stream ( ) ; object output stream obj out = new object output stream ( mem out ) ; obj out . write object ( obj ) ; obj out . close ( ) ; byte array input stream src = new byte array input stream ( mem out . to byte array ( ) ) ; object input stream obj is = new object input stream ( src ) ; return obj is . read object ( ) ; }	creates a clone by serializing object and deserializing byte stream .
private static string link for class name ( string name ) { return name . replace ( str , str ) + str ; }	return a link for the class name.
protected void handle element deleted ( i file editor input ) { fire element deleted ( file editor input ) ; }	sends out the notification that the file serving as document input has been deleted .
public void assert text present ( string expected , string actual ) { if ( ( actual == null ) || ( ! actual . contains ( expected ) ) ) { throw new assertion failed error ( str + expected + str + actual + str ) ; } }	asserts if the provided text is part of some text .
public void test using proxy selector ( ) throws exception { mock server server = new mock server ( str ) ; mock server proxy = new mock server ( str ) ; url url = new url ( str + server . port ( ) ) ; proxy selector def ps = proxy selector . get default ( ) ; proxy selector . set default ( new test proxy selector ( server . port ( ) , proxy . port ( ) ) ) ; try { url connection = ( url ) url . open connection ( ) ; connection . set connect timeout ( num ) ; connection . set read timeout ( num ) ; server . start ( ) ; synchronized ( bound ) { if ( ! server . started ) bound . wait ( num ) ; } proxy . start ( ) ; synchronized ( bound ) { if ( ! proxy . started ) bound . wait ( num ) ; } connection . connect ( ) ; server . join ( ) ; proxy . join ( ) ; assert true ( str , connection . using proxy ( ) ) ; assert true ( str , proxy . accepted ) ; connection . disconnect ( ) ; assert true ( str , connection . using proxy ( ) ) ; } finally { proxy selector . set default ( def ps ) ; } }	test checks if the proxy provided by proxy selector will be used for connection to the server.
public string code clean pipeline ( string contents ) { if ( contents == null ) { return values . emptystring ; } string builder index contents = new string builder ( ) ; char [ ] first replacements = { str , str , str , str , str , str , str , str , str } ; for ( char c : first replacements ) { contents = contents . replace ( c , str ) ; } index contents . append ( str ) ; index contents . append ( contents ) ; char [ ] second replacements = { str , str , str , str } ; for ( char c : second replacements ) { contents = contents . replace ( c , str ) ; } index contents . append ( str ) ; index contents . append ( contents ) ; char [ ] forth replacements = { str , str } ; for ( char c : forth replacements ) { contents = contents . replace ( c , str ) ; } index contents . append ( str ) ; index contents . append ( contents ) ; char [ ] replacements = { str , str , str , str , str , str , str , str , str , str , str , str , str } ; for ( char c : replacements ) { contents = contents . replace ( c , str ) ; } index contents . append ( str ) ; index contents . append ( contents ) ; char [ ] third replacements = { str } ; for ( char c : third replacements ) { contents = contents . replace ( c , str ) ; } index contents . append ( str ) ; index contents . append ( contents ) ; return index contents . to string ( ) ; }	cleans and formats the code into something that can be indexed by lucene while supporting searches such as i + + matching for ( int i = 0 ; i < 100 ; i + + ; ) {.
public static string mrpa2sampa ( string voice phoneme ) { if ( mrpa2sampa . contains key ( voice phoneme ) ) return mrpa2sampa . get ( voice phoneme ) ; else return voice phoneme ; }	converts a single phonetic symbol in mrpa representation representation into its equivalent in mary sampa representation .
public static x new instance intersect ( document doc , string xpath2filter ) { return new x ( doc , xpath2filter , x . att filter value intersect ) ; }	creates a new xpath2filtercontainer with the filter type " intersect " .
public void remove item changed listener ( item changed listener listener ) { item changed listeners . remove ( listener ) ; }	removes an item change listener from this controller .
public boolean has ambig prefix ( ) { return ( name . starts with ( ambig prefix ) ) ; }	determine whether an identifier has been marked as ambiguous .
public ordered thread pool executor ( int maximum pool size ) { this ( default initial thread pool size , maximum pool size , default keep alive , time unit . seconds , executors . default thread factory ( ) , null ) ; }	creates a default threadpool , with default values : - minimum pool size is 0 - keepalive set to 30 seconds - a default threadfactory - all events are accepted.
private string parse malformed ( string url string ) { if ( parts != null && ! parts . is empty ( ) ) { string ret ; for ( url part : parts ) { switch ( part ) { case protocol : ret = apply pattern ( regex protocol , url string ) ; break ; case port : ret = apply pattern ( regex port , url string ) ; break ; case query : ret = apply pattern ( regex query , url string ) ; break ; case whole : ret = url string ; break ; default : ret = url string ; } if ( ! strings . is null or empty ( ret ) ) { return ret ; } } } return url string ; }	attempt to parse a malformed url string.
private boolean relocate ( ) { boolean finished = bool ; for ( relocatable relocatable : this . relocatables ) { finished &= relocatable . relocate ( ) ; } return finished ; }	relocates all relocatables and aggregate their response into a single one .
private static set < type element > find all members injectors recursively ( collection < type element > members injectors ) { set < type element > result = new hash set < > ( ) ; for ( type element element : members injectors ) { result . add all ( find all members injectors recursively ( element ) ) ; } return result ; }	returns all the injected classes and them super interfaces .
public builder add sub button ( context context , int drawable , int [ ] two colors , string string ) { if ( drawables == null ) drawables = new array list < > ( ) ; drawables . add ( context compat . get drawable ( context , drawable ) ) ; if ( colors == null ) colors = new array list < > ( ) ; colors . add ( two colors ) ; if ( strings == null ) strings = new array list < > ( ) ; strings . add ( string ) ; return this ; }	add a sub button with 4 params .
public static boolean is fm ( ) { if ( instance type == null ) { instance type = ( string ) config tags . get ( str ) ; } return ( instance type != null && instance type . equals ignore case ( str ) ) ; }	checks if the instance is fm .
private boolean try release ( long c , work queue v , long inc ) { int sp = ( int ) c , ns = sp & ~ unsignalled ; if ( v != null ) { int vs = v . scan state ; long nc = ( v . stack pred & sp mask ) | ( uc mask & ( c + inc ) ) ; if ( sp == vs && u . compare and swap long ( this , ctl , c , nc ) ) { v . scan state = ns ; lock support . unpark ( v . parker ) ; return bool ; } } return bool ; }	signals and releases worker v if it is top of idle worker stack.
@ override public value sample ( assignment condition ) { double prob = get prob ( condition ) ; if ( sampler . next double ( ) < prob ) { return value factory . create ( bool ) ; } else { return value factory . create ( bool ) ; } }	generates a sample from the distribution given the conditional assignment .
boolean validate ( set attr vals , string i18n file name , boolean encode password ) throws sms { return validate ( attr vals , i18n file name , encode password , collections . empty map ) ; }	validates a map of attributes and values against service schema definition .
protected static void append big decimal numeric type ( string builder sb ) { sb . append ( str ) ; }	output the sql type for a bigdecimal object .
public double distance ( vector other ) { return math . sqrt ( math . pow ( other . x - x , num ) + math . pow ( other . y - y , num ) + math . pow ( other . z - z , num ) ) ; }	get the distance between this vector and another vector .
public static void take screenshot ( final string tag ) { if ( scenario == null ) { throw new screenshot exception ( str ) ; } spoon screenshot action . perform ( tag ) ; final file screenshot = spoon screenshot action . get last screenshot ( ) ; if ( screenshot == null ) { throw new screenshot exception ( str ) ; } file input stream screenshot stream = null ; try { screenshot stream = new file input stream ( screenshot ) ; final byte file content [ ] = new byte [ ( int ) screenshot . length ( ) ] ; final int read image bytes = screenshot stream . read ( file content ) ; if ( read image bytes != - num ) { scenario . embed ( file content , str ) ; } } catch ( final io ioe ) { throw new screenshot exception ( str + ioe ) ; } finally { try { if ( screenshot stream != null ) { screenshot stream . close ( ) ; } } catch ( final io ioe ) { throw new screenshot exception ( str + ioe ) ; } } }	take a screenshot of the current activity and embed it in the html report.
private void import runner environment ( import project import project , folder entry base project folder ) throws forbidden exception , server exception , conflict exception , io { import runner environment ( import project , base project folder , null ) ; }	import runner environment tha configure in importproject.
@ override public void do notify ( ) throws exception { log . info ( str ) ; scheduled executor service svc = service ; if ( svc != null ) { try { svc . schedule ( ( callable < object > ) this , num , time unit . microseconds ) ; } catch ( rejected execution exception ex ) { if ( svc . is shutdown ( ) ) { log . info ( str ) ; } else { throw ex ; } } } else { log . info ( str ) ; } }	called when related system properties are changed , and we need to reschedule.
public boolean check root by build tags ( ) { string build tags = android . os . build . tags ; if ( build tags != null && build tags . contains ( su tag ) ) { return bool ; } return bool ; }	returns true if the os build tags contains " test - keys " .
public boolean is user active ( string realm ) { boolean active = bool ; try { am user = id utils . get identity ( sso token , user id ) ; boolean is user active = user . is active ( ) ; string login status = get user attribute value ( user , user service login status , active ) ; string lockout = get user attribute value ( user , user service ns lockout , string false ) ; if ( ! is user active || ! login status . equals ignore case ( active ) || ! lockout . equals ignore case ( string false ) ) { error msg = get localized string ( str ) ; write log ( str , user id ) ; } else if ( is account expired ( user ) ) { error msg = get localized string ( str ) ; write log ( str , user id ) ; } else if ( is user lockout ( user id , realm ) ) { string obj [ ] = { user id } ; information msg = get localized string ( str ) ; write log ( str , user id ) ; } else { active = bool ; } } catch ( sso e ) { debug . warning ( str , e ) ; error msg = get error string ( e ) ; } catch ( id repo exception e ) { debug . warning ( str , e ) ; error msg = get error string ( e ) ; } return active ; }	returns true if the user is active and account is not expired.
@ override public < u > completable future < u > fold right ( final u seed , final bi function < ? super t , u , u > function ) { return completable future . supply async ( null , exec ) ; }	perform an asynchronous foldright operation.
private void algorithm douglas peucker ( list < entry > entries , double epsilon , int start , int end ) { if ( end <= start + num ) { return ; } int max dist index = num ; double dist max = num ; entry first entry = entries . get ( start ) ; entry last entry = entries . get ( end ) ; for ( int i = start + num ; i < end ; i ++ ) { double dist = calc angle between lines ( first entry , last entry , first entry , entries . get ( i ) ) ; if ( dist > dist max ) { dist max = dist ; max dist index = i ; } } if ( dist max > epsilon ) { keep [ max dist index ] = bool ; algorithm douglas peucker ( entries , epsilon , start , max dist index ) ; algorithm douglas peucker ( entries , epsilon , max dist index , end ) ; } }	apply the douglas - peucker - reduction to an list of entry with a given epsilon ( tolerance ).
public static void sort ( abstract list array , int [ ] indices ) { for ( int i = num ; i < indices . length ; i ++ ) { indices [ i ] = i ; } int temp ; int j , n = array . size ( ) ; for ( j = n / num ; j > num ; j -- ) { adjust ( array , indices , j , n ) ; } for ( j = n - num ; j > num ; j -- ) { temp = indices [ num ] ; indices [ num ] = indices [ j ] ; indices [ j ] = temp ; adjust ( array , indices , num , j ) ; } }	sorts an array of indices to vector of comparable objects into increasing order .
public static boolean save string to file ( string data input , string path ) { string filename = path ; file file = new file ( filename ) ; file output stream fos ; byte [ ] data = data input . get bytes ( ) ; try { fos = new file output stream ( file ) ; fos . write ( data ) ; fos . flush ( ) ; fos . close ( ) ; return bool ; } catch ( file not found exception e ) { e . print stack trace ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } return bool ; }	save string to file.
public static string quote ( string input ) { if ( input . contains ( str ) ) { return str + input + str ; } else { return input ; } }	quotes the given input string iff it contains whitespace .
public static void assert throws completion exception ( final consumer < void > consumer , final class < ? > exception class ) { try { consumer . accept ( null ) ; } catch ( final completion exception completion ex ) { final throwable ex = completion ex . get cause ( ) ; if ( ex . get class ( ) == exception class ) { return ; } assert . fail ( string . format ( str , ex . get class ( ) ) ) ; } assert . fail ( string . format ( str , exception class ) ) ; }	asserts that the execution of consumer throws a completion exception wrapping an exception of the specific class .
public object put ( object key , object value ) { object old value = null ; synchronized ( map ) { old value = map . put ( key , value ) ; if ( old value != null ) { remove element ( key ) ; } add element ( key ) ; } return old value ; }	puts the key and element to the map .
public double run ( ) { try { audio input stream in input = audio system . get audio input stream ( files [ num ] ) ; audio feature audio feature input = ( audio feature ) feature extractor input . calculate ( in input ) ; } catch ( exception e ) { } double avg distance = num ; for ( int i = num ; i < array feature extractor train set . size ( ) ; i ++ ) { double distance2 db = audio thread distance ( feature extractor input . get mfcc ( ) , array feature extractor train set . get ( i ) ) ; log . i ( str , str + distance2 db ) ; avg distance += distance2 db ; } log . i ( str , str + ( avg distance / array feature extractor train set . size ( ) ) ) ; return avg distance / array feature extractor train set . size ( ) ; }	starts processing the feature extraction batch job .
public predicate ( term t ) { terms . add ( t ) ; }	creates a predicate containing a single term .
private void add operations ( set < string > method signatures ) throws operation parse exception { for ( string sig : method signatures ) { typed operation operation = operation parser . parse ( sig ) ; operations . add ( operation ) ; } }	create operations obtained by parsing method signatures and add each to this model .
private void write log ( string log ) { file file = new file ( crash handler default . log default path + str + formatter . format ( new date ( ) ) + str ) ; try { file output stream file output stream = new file output stream ( file ) ; byte [ ] bytes = log . get bytes ( ) ; file output stream . write ( bytes ) ; file output stream . close ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } }	write log in file.
public rule ( string pattern , object token type , string next state ) { this . pattern = pattern . compile ( pattern ) ; this . token type = token type ; this . next state = next state ; }	initializes a new instance with the specified regular expression pattern , a type for generated tokens , and a name of a grammar state that should be triggered .
private void show popup ( final mouse event event ) { int [ ] rows = get selected rows ( ) ; if ( ( rows . length == num ) || ( rows . length == num ) ) { final int row = row at point ( event . get point ( ) ) ; final int column = column at point ( event . get point ( ) ) ; if ( ( row == - num ) || ( column == - num ) ) { return ; } change selection ( row , column , bool , bool ) ; rows = get selected rows ( ) ; } final j menu = new j ( ) ; menu . add ( new j ( c . proxy ( new c ( m bookmark manager , rows ) ) ) ) ; menu . show ( event . get component ( ) , event . get x ( ) , event . get y ( ) ) ; }	shows a context menu .
public static boolean has special chars ( final string str ) { final matcher matcher = spl char patrn . matcher ( str ) ; return matcher . find ( ) ; }	checks if the given string value contains special characters ( [ , & , ; , , , + , = , { , } , > , < , ^ , ( , ) , # , : , ~ , ` , / , \ , ! , ' , " , ] ).
@ override public int read ( byte b [ ] , int off , int len ) throws io { if ( bb == null ) { throw new io ( str ) ; } if ( b == null ) { throw new null pointer exception ( ) ; } else if ( off < num || len < num || len > b . length - off ) { throw new index out of bounds exception ( ) ; } else if ( len == num ) { return num ; } int length = math . min ( bb . remaining ( ) , len ) ; if ( length == num ) { return - num ; } bb . get ( b , off , length ) ; return length ; }	returns a byte array from the bytebuffer.
public void remove event listener ( multimedia messaging session listener listener ) throws rcs service not available exception , rcs generic exception { if ( m api == null ) { throw new rcs service not available exception ( ) ; } try { weak reference < i > weak ref = m multimedia messaging session listeners . remove ( listener ) ; if ( weak ref == null ) { return ; } i multimedia messaging session listener = weak ref . get ( ) ; if ( multimedia messaging session listener != null ) { m api . remove event listener2 ( multimedia messaging session listener ) ; } } catch ( exception e ) { rcs illegal argument exception . assert exception ( e ) ; throw new rcs generic exception ( e ) ; } }	removes a listener on multimedia messaging session events.
public widget proposal computer ( string text , int offset , element root element , element parent element , i java project ) throws java model exception , ui binder exception { super ( java project , text , offset , text . length ( ) ) ; this . root element = root element ; this . parent element = parent element ; package manager . read from element ( root element ) ; }	constructs a widget completion proposal computer .
public list < predicate < t > > parse ( final list < string > queries ) throws query parse exception { list < predicate < t > > predicates = new array list < > ( queries . size ( ) ) ; for ( string query : queries ) { predicates . add ( parse ( query ) ) ; } return predicates ; }	parse multiple user - supplied query strings into a list of predicates .
public static object deserialize stream ( final string witness ) throws exception { file input stream file is = new file input stream ( witness ) ; object input stream obj is = new object input stream ( file is ) ; return obj is . read object ( ) ; }	deserializes a specified file .
public static void rollback ( boolean began transaction , string cause message , throwable cause throwable ) throws generic transaction exception { if ( began transaction ) { transaction util . rollback ( cause throwable ) ; } else { transaction util . set rollback only ( cause message , cause throwable ) ; } }	rolls back transaction in the current thread if transactions are available and if begantransaction is true ; if begantransaction is not true , setrollbackonly is called to insure that the transaction will be rolled back.
public long array ( long array array ) { this . ordered = array . ordered ; size = array . size ; items = new long [ size ] ; system . arraycopy ( array . items , num , items , num , size ) ; }	creates a new array containing the elements in the specific array.
private static < t > t report get ( object r ) throws interrupted exception , execution exception { if ( r == null ) throw new interrupted exception ( ) ; if ( r instanceof alt result ) { throwable x , cause ; if ( ( x = ( ( alt result ) r ) . ex ) == null ) return null ; if ( x instanceof cancellation exception ) throw ( cancellation exception ) x ; if ( ( x instanceof completion exception ) && ( cause = x . get cause ( ) ) != null ) x = cause ; throw new execution exception ( x ) ; } @ suppress warnings ( str ) t t = ( t ) r ; return t ; }	reports result using future.
protected void garbage collect ( visual table labels ) { iterator iter = labels . tuples ( ) ; while ( iter . has next ( ) ) { visual item item = ( visual item ) iter . next ( ) ; if ( ! item . is start visible ( ) && ! item . is end visible ( ) ) { labels . remove tuple ( item ) ; } } }	remove axis labels no longer being used .
public boolean shares variable with ( def use du ) { return var name . equals ( du . var name ) ; }	determines whether the given defuse reads or writes the same variable as this defuse.
private void populate nav drawer ( ) { m nav drawer items . clear ( ) ; m nav drawer items . add ( navdrawer item activit ) ; m nav drawer items . add ( navdrawer item separator ) ; m nav drawer items . add ( navdrawer item activit ) ; m nav drawer items . add ( navdrawer item separator special ) ; m nav drawer items . add ( navdrawer item activit ) ; create nav drawer items ( ) ; }	populates the navigation drawer with the appropriate items .
public artifact coordinates ( final string group id , final string artifact id , final string version , final string classifier ) { this . group id = group id ; this . artifact id = artifact id ; this . version = version ; this . classifier = classifier ; }	construct a new instance .
private carbon iterator < batch result > execute block list ( list < table block info > block list ) throws query execution exception { query model . set table block infos ( block list ) ; this . query executor = query executor factory . get query executor ( ) ; carbon iterator < batch result > iter = null ; try { iter = query executor . execute ( query model ) ; } catch ( query execution exception e ) { logger . error ( e . get message ( ) ) ; throw e ; } return iter ; }	get executor and execute the query model .
protected link create link ( final string relation , final uri href ) { return new link ( relation , href ) ; }	creates a link with the specified relation and uri of the remote resource .
public void test flip bit positive inside2 ( ) { byte a bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = num ; int number = num ; byte r bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . flip bit ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	flipbit ( int n ) inside a positive number.
public static spannable create spannable from text with template ( string text , char sequence inner template ) { spannable string result = new spannable string ( text ) ; if ( inner template instanceof spanned ) { int index = text . index of ( inner template . to string ( ) ) ; if ( index >= num ) { copy spans ( result , ( spanned ) inner template , index ) ; } } return result ; }	create spannable from text that includes some charsequence . if the charsequence has any spans they would be copied to result spannable.
@ override public string to string ( ) { return xml file . get name ( ) ; }	returns the domain name .
public string to string ( ) { return string . value of ( stop time millis - start time millis ) + str ; }	returns a summary of the time that the stopwatch has recorded as a string .
public object graph plus graph ( list < object > activity scope modules ) { if ( activity scope modules == null ) { throw new illegal argument exception ( str ) ; } return graph . plus ( activity scope modules . to array ( ) ) ; }	given a list < object > with dagger modules inside performs a plus over the application graph and returns a new one with all the dependencies already created plus the one resolved with the list of modules passed as argument .
public group category set ( group category [ ] categories ) { assert . is not null ( categories ) ; f content = new array list ( categories . length ) ; for ( int i = num ; i < categories . length ; i ++ ) { if ( ! f content . contains ( categories [ i ] ) ) f content . add ( categories [ i ] ) ; } }	creates a new set of group categories initialized from the given array of group categories.
private boolean in same package ( class < ? > c1 , class < ? > c2 ) { string name c1 = c1 . get name ( ) ; string name c2 = c2 . get name ( ) ; int index dot c1 = name c1 . last index of ( str ) ; int index dot c2 = name c2 . last index of ( str ) ; if ( index dot c1 != index dot c2 ) { return bool ; } if ( index dot c1 == - num ) { return bool ; } return name c1 . region matches ( num , name c2 , num , index dot c1 ) ; }	checks if two classes belong to the same package .
private void write constraints to xml ( xml serializer out , job status job status ) throws io { out . start tag ( null , xml tag params constraints ) ; if ( job status . has unmetered constraint ( ) ) { out . attribute ( null , str , boolean . to string ( bool ) ) ; } if ( job status . has connectivity constraint ( ) ) { out . attribute ( null , str , boolean . to string ( bool ) ) ; } if ( job status . has idle constraint ( ) ) { out . attribute ( null , str , boolean . to string ( bool ) ) ; } if ( job status . has charging constraint ( ) ) { out . attribute ( null , str , boolean . to string ( bool ) ) ; } out . end tag ( null , xml tag params constraints ) ; }	write out a tag with data identifying this job ' s constraints.
public void fill conditional holes ( ) { value range possible cond pairs = new value range ( table . key set ( ) ) ; if ( possible cond pairs . get nb combinations ( ) < num ) { set < assignment > possible cond assignments = possible cond pairs . linearise ( ) ; possible cond assignments . remove ( new assignment ( ) ) ; for ( assignment possible cond : possible cond assignments ) { if ( ! table . contains key ( possible cond ) ) { add row ( possible cond , value factory . none ( ) , num ) ; } } } }	fill the " conditional holes " of the distribution - - that is , the possible conditional assignments y1 ,.
private boolean show app menu ( view view , boolean start dragging ) { if ( ! m menu handler . is app menu showing ( ) && m menu handler . show app menu ( view , start dragging ) ) { if ( ! start dragging ) record user action . record ( str ) ; if ( m on app menu shown listener != null ) { m on app menu shown listener . run ( ) ; } return bool ; } return bool ; }	shows the app menu if it is not already shown .
protected void write node text ( node node ) throws io { string text = node . get text ( ) ; if ( ( text != null ) && ( text . length ( ) > num ) ) { if ( escape text ) { text = escape element entities ( text ) ; } last output node type = node . text node ; writer . write ( text ) ; } }	this method is used to write out nodes that contain text and still allow for xml : space to be handled properly .
public void insert radians ( double [ ] latlons , int coord pair index , boolean replace ends of inserted at join ) { int min pnts needed for insertion = num ; boolean at end = bool ; boolean is closed = is geometry closed ( ) ; int insertion point = coord pair index * num ; if ( insertion point >= rawllpts . length ) { if ( is closed ) { insertion point = rawllpts . length - num ; } else { insertion point = rawllpts . length ; at end = bool ; } } else if ( insertion point <= num ) { if ( is closed ) { insertion point = num ; } else { insertion point = num ; at end = bool ; } } int new coord start = num ; int new coord length = latlons . length ; if ( replace ends of inserted at join ) { new coord start = num ; min pnts needed for insertion = num ; if ( at end ) { min pnts needed for insertion -= num ; new coord length -= num ; if ( insertion point == num ) { new coord start = num ; } } else { new coord length -= num ; } } if ( render type == om . rendertype latlon && latlons . length >= min pnts needed for insertion && latlons . length % num == num ) { double [ ] oldrawllpnts = rawllpts ; int old coords remaining = oldrawllpnts . length - insertion point ; rawllpts = new double [ oldrawllpnts . length + new coord length ] ; system . arraycopy ( oldrawllpnts , num , rawllpts , num , insertion point ) ; system . arraycopy ( latlons , new coord start , rawllpts , insertion point , new coord length ) ; system . arraycopy ( oldrawllpnts , insertion point , rawllpts , insertion point + new coord length , old coords remaining ) ; set need to regenerate ( bool ) ; } }	convenience function for adding some coordinates to the polygon , for lat / lon polygons.
public static boolean cancel potential work ( object data , image view image view ) { final bitmap worker task bitmap worker task = get bitmap worker task ( image view ) ; if ( bitmap worker task != null ) { final object bitmap data = bitmap worker task . data ; if ( bitmap data == null || ! bitmap data . equals ( data ) ) { bitmap worker task . cancel ( bool ) ; if ( build config . debug ) { log . d ( tag , str + data ) ; } } else { return bool ; } } return bool ; }	returns true if the current work has been canceled or if there was no work in progress on this image view.
private t3 < integer , integer , byte [ ] > random key ( random rnd ) { return keys [ rnd . next int ( keys . length ) ] ; }	gets random key from pregenerated array .
public string to string ( ) { string buffer buffer = new string buffer ( ) ; if ( override > num ) { buffer . append ( str + override + str ) ; if ( lineno > num ) buffer . append ( str + lineno + str ) ; } else { if ( location name == null && lineno > num ) { buffer . append ( str + lineno + str ) ; } else if ( location name != null ) { buffer . append ( location name + str ) ; if ( lineno > num ) buffer . append ( lineno + str ) ; } } buffer . append ( description ) ; return buffer . to string ( ) ; }	returns a string representation of this error .
public void test searchables list real ( ) { my mock package manager mock pm = new my mock package manager ( m context . get package manager ( ) ) ; my mock context mock context = new my mock context ( m context , mock pm ) ; mock pm . set searchables mode ( my mock package manager . searchables passthrough ) ; searchables searchables = new searchables ( mock context , num ) ; searchables . build searchable list ( ) ; array list < searchable info > searchables list = searchables . get searchables list ( ) ; int count = searchables list . size ( ) ; assert true ( count >= num ) ; check searchables ( searchables list ) ; array list < searchable info > global = searchables . get searchables in global search list ( ) ; check searchables ( global ) ; }	this is an attempt to run the searchable info list with a mocked context.
private void fill example table ( data set data set , progress listener listener , int [ ] attribute columns , memory example table example table ) throws data set exception , process stopped exception , parse exception { attribute [ ] attributes = example table . get attributes ( ) ; data set . reset ( ) ; int number of rows = data set . get number of rows ( ) ; data row factory factory = new data row factory ( data management type , data row factory . point as decimal character ) ; boolean is running in process = is operator running ( ) ; while ( data set . has next ( ) ) { if ( is running in process ) { operator . check for stop ( ) ; } if ( should stop ) { throw new process stopped exception ( ) ; } data set row current row = data set . next row ( ) ; if ( listener != null ) { update process ( listener , data set . get current row index ( ) , number of rows ) ; } data row row = factory . create ( attributes . length ) ; example table . add data row ( row ) ; int attribute index = num ; for ( attribute attribute : attributes ) { if ( current row . is missing ( attribute columns [ attribute index ] ) ) { row . set ( attribute , double . n ) ; } else { switch ( attribute . get value type ( ) ) { case ontology . integer : case ontology . numerical : case ontology . real : row . set ( attribute , get number ( current row , attribute columns [ attribute index ] ) ) ; break ; case ontology . date time : case ontology . time : case ontology . date : row . set ( attribute , get date ( current row , attribute columns [ attribute index ] ) ) ; break ; default : row . set ( attribute , get string index ( attribute , current row , attribute columns [ attribute index ] ) ) ; } } attribute index ++ ; } } }	fills the exampletable with the data from the dataset .
public boolean is spurious ( int min cl size ) { return children . is empty ( ) && members . size ( ) < min cl size ; }	test if a cluster is spurious .
public aes decryptor ( byte [ ] key , int off , int len ) { this . key = new byte [ len ] ; system . arraycopy ( key , off , this . key , num , len ) ; }	creates a new instance of aesdecryption.
static string extract number from uri without formatting ( string uri ) { if ( uri == null ) { return null ; } int index0 = uri . index of ( uri start delimiter ) ; if ( index0 != - num ) { uri = uri . substring ( index0 + uri start delimiter . length ( ) , uri . index of ( uri end delimiter , index0 ) ) ; } int index1 = uri . index of ( tel uri header ) ; if ( index1 != - num ) { uri = uri . substring ( index1 + tel uri header . length ( ) ) ; } index1 = uri . index of ( sip uri header ) ; if ( index1 != - num ) { int index2 = uri . index of ( str , index1 ) ; uri = uri . substring ( index1 + sip uri header . length ( ) , index2 ) ; } int index2 = uri . index of ( str ) ; if ( index2 != - num ) { uri = uri . substring ( num , index2 ) ; } index2 = uri . index of ( str ) ; if ( index2 != - num ) { uri = uri . substring ( num , index2 ) ; } return uri ; }	extract user part phone number from a sip - uri or tel - uri or sip address.
public remote method call results invoke and wait ( final string end point name , final remote method call remote call ) { end point local ; synchronized ( m end point mutex ) { local = m local end points . get ( end point name ) ; } if ( local == null ) { return invoke and wait remote ( remote call ) ; } else { final long number = local . take a ( ) ; final list < remote method call results > results = local . invoke local ( remote call , number , get local node ( ) ) ; if ( results . size ( ) == num ) { throw new remote not found exception ( str + end point name ) ; } if ( results . size ( ) > num ) { throw new illegal state exception ( str + results ) ; } return results . get ( num ) ; } }	invoke and wait for all implementors on all vms to finish executing .
private void create element ( document doc , element parent element , string element name , boolean value ) { element element = doc . create element ( element name ) ; element . append child ( doc . create text node ( boolean . to string ( value ) ) ) ; parent element . append child ( element ) ; }	creates the xml element for a boolean value .
protected void annotation value to string ( final string builder sb , final b val , final int indent ) { sb . append ( val . to string ( ) ) ; }	add a string representation of a bop annotation value into a string builder.
public void run test ( ) throws throwable { document doc ; node list em list ; node em node ; character data em text ; node null child ; doc = ( document ) load ( str , bool ) ; em list = doc . get elements by tag name ( str ) ; em node = em list . item ( num ) ; em text = ( character data ) em node . get first child ( ) ; null child = em text . get last child ( ) ; assert null ( str , null child ) ; }	runs the test case .
public enumeration oids ( ) { return ordering . elements ( ) ; }	return an enumeration of the extension field ' s object ids .
@ override map < string , object > extract fields ( string line ) { if ( ! initialized ) { init ( ) ; initialized = bool ; } string [ ] values = fixed width parser . parse line ( line ) ; if ( has header && arrays . deep equals ( values , header ) ) { return null ; } map < string , object > map = maps . new hash map ( ) ; int i = num ; for ( fixed width field field : fields ) { map . put ( field . get name ( ) , get value ( field , values [ i ++ ] ) ) ; } return map ; }	extracts the fields from a fixed width record and returns a map containing field names and values.
protected double scaling function ( int i distance ) { return math . exp ( - math . pow ( ( i distance ) , num ) / ( num * math . pow ( correlation window , num ) ) ) ; }	a function providing a scaling factor according to the distance between any two n - grams .
protected void update ideal point ( ) { for ( solution solution : this ) { if ( solution . get number of objectives ( ) != number of objectives ) { throw new framework exception ( str ) ; } for ( int i = num ; i < number of objectives ; i ++ ) { ideal point [ i ] = math . min ( ideal point [ i ] , solution . get objective ( i ) ) ; } } }	updates the ideal point given the solutions currently in this population .
public search builder sort ( sort field builder ... builders ) { sort . add all ( arrays . as list ( builders ) ) ; return this ; }	adds the specified sorting fields .
@ override public final buffered image data to rgb ( byte [ ] data , final int width , final int height ) { buffered image image ; data = data to rgb ( data , width , height ) ; final data buffer db = new data buffer byte ( data , data . length ) ; final int [ ] bands = { num , num , num } ; image = new buffered image ( width , height , buffered image . type int rgb ) ; final raster raster = raster . create interleaved raster ( db , width , height , width * num , num , bands , null ) ; image . set data ( raster ) ; return image ; }	convert to rgb and return as an image.
protected void create file chooser ( ) { m = new j ( new file ( system . get property ( str ) ) ) ; m . set file selection mode ( j . files only ) ; }	creates the file chooser the user will use to save / load files with .
private boolean is noun ( string word ) { if ( nouns == null ) return bool ; return nouns . contains ( word . to lower case ( ) ) ; }	if this is word is a thing in our repository it is a noun.
public static void write document ( document document , string encoding , output stream out , writer writer , boolean omit xml ) throws io , xml { if ( writer == null ) { writer = new output stream writer ( out , encoding ) ; } transformer . set output property ( output keys . encoding , encoding ) ; transformer . set output property ( output keys . omit xml declaration , omit xml ? str : str ) ; source source = new dom ( document ) ; result result = new stream result ( writer ) ; try { transformer . transform ( source , result ) ; } catch ( transformer exception e ) { e . print stack trace ( ) ; throw new xml ( str , e ) ; } writer . flush ( ) ; }	writes the xml representation of a document object .
public static string int to string ( int value , int n chars ) { string str value = integer . to string ( value ) ; string builder str buf = new string builder ( n chars ) ; for ( int i = str value . length ( ) ; i < n chars ; i ++ ) { str buf . append ( str ) ; } str buf . append ( str value ) ; return str buf . to string ( ) ; }	method inttostring . converst an integer to nchars characters.
public boolean is quest completed ( final string name ) { return quests . is quest completed ( name ) ; }	checks whether the player has completed the given quest or not .
private void update button state ( boolean data changed ) { btn apply . set enabled ( data changed ) ; btn revert . set enabled ( data changed ) ; }	update button apply / revert state .
private void build menu ( ) { set visible ( bool ) ; remove all ( ) ; if ( recent searches . get length ( ) == num ) { j no recent = new j ( ui . get string ( str ) ) ; no recent . set enabled ( bool ) ; add ( no recent ) ; } else { j recent = new j ( ui . get string ( str ) ) ; recent . set enabled ( bool ) ; add ( recent ) ; for ( string search string : recent searches . get recent searches ( ) ) { j mi = new j ( search string ) ; mi . add action listener ( this ) ; add ( mi ) ; } add separator ( ) ; clear = new j ( ui . get string ( str ) ) ; clear . add action listener ( this ) ; add ( clear ) ; } }	rebuilds the menu according to the recent searches .
public static string convert u8 to hex string ( char u8 ) { return integer . to hex string ( u8 ) ; }	convert char ( uint8 ) to hex string.
public static byte [ ] join ( byte [ ] array a , byte ... array b ) { if ( ( array b == null ) || ( array b . length == num ) ) { return array a ; } if ( ( array a == null ) || ( array a . length == num ) ) { return array b ; } byte [ ] array = new byte [ array a . length + array b . length ] ; system . arraycopy ( array a , num , array , num , array a . length ) ; system . arraycopy ( array b , num , array , array a . length , array b . length ) ; return array ; }	joins 2 arrays together , if any array is null or empty then other array will be retuned without coping anything .
public void remove listener ( listener listener ) { m listeners . remove ( listener ) ; }	remove a listener from the listener list.
protected double constriction coefficient ( double c1 , double c2 ) { double rho = c1 + c2 ; if ( rho <= num ) { return num ; } else { return num / ( num - rho - math . sqrt ( math . pow ( rho , num ) - num * rho ) ) ; } }	returns the velocity constriction coefficient .
public synchronized void close ( ) { if ( is alive ) { is alive = bool ; task queue . clear ( ) ; interrupt ( ) ; } }	closes this threadpool and returns immediately.
public string remove after ( string original , string marker ) { int index = original . index of ( marker ) ; if ( index != - num ) { return original . substring ( num , index ) ; } return original ; }	this method removes the end part of a string beginning at a specified marker .
public address sub ( final object rhs ) { return new address ( m value . subtract ( get big integer ( rhs ) ) ) ; }	used to support sub operations on addresses in python scripts .
public static test configuration build default configuration ( string test source path , file test file , string checker name , list < string > options , boolean should emit debug info ) { list < file > java files = arrays . as list ( test file ) ; list < string > processors = arrays . as list ( checker name ) ; return build default configuration ( test source path , java files , processors , options , should emit debug info ) ; }	this is the default configuration used by checker framework junit tests .
private static boolean eq ( object o1 , object o2 ) { return ( o1 == null ? o2 == null : o1 . equals ( o2 ) ) ; }	test for equality , coping with nulls .
public void roll ( int field , int value ) { boolean increment = value >= num ; int count = increment ? value : - value ; for ( int i = num ; i < count ; i ++ ) { roll ( field , increment ) ; } }	adds the given amount to the given field and wraps the value of the field when it goes beyond the maximum or minimum value for the current date.
public string cluster results to string ( ) { return m clustering results . to string ( ) ; }	return the results of clustering .
private void generate get module method ( new binding key key , new dependency info dependency info ) { type element scope = scope calculator . calculate ( key ) ; generate get module method ( scope , dependency info ) ; }	creates get_foo_module ( ) for foomodule .
private void add calendar event ( string summary , date start , boolean all day , date end , string location , string description , string [ ] attendees ) { intent intent = new intent ( intent . action insert ) ; intent . set type ( str ) ; long start milliseconds = start . get time ( ) ; intent . put extra ( str , start milliseconds ) ; if ( all day ) { intent . put extra ( str , bool ) ; } long end milliseconds ; if ( end == null ) { if ( all day ) { end milliseconds = start milliseconds + num * num * num * num ; } else { end milliseconds = start milliseconds ; } } else { end milliseconds = end . get time ( ) ; } intent . put extra ( str , end milliseconds ) ; intent . put extra ( str , summary ) ; intent . put extra ( str , location ) ; intent . put extra ( str , description ) ; if ( attendees != null ) { intent . put extra ( intent . extra email , attendees ) ; } try { raw launch intent ( intent ) ; } catch ( activity not found exception anfe ) { log . w ( tag , str + intent . action insert ) ; intent . set action ( intent . action edit ) ; launch intent ( intent ) ; } }	sends an intent to create a new calendar event by prepopulating the add event ui.
private string [ ] separator and enclosures to array ( ) { string [ ] parts = m . split ( str ) ; string [ ] result = new string [ parts . length + num ] ; result [ num ] = m ; int index = num ; for ( string e : parts ) { if ( e . length ( ) > num || e . length ( ) == num ) { throw new illegal argument exception ( str ) ; } result [ index ++ ] = e ; } return result ; }	assemble the field separator and enclosures into an array of strings.
private static void release string chars ( jni env , int obj jref , address buf address ) { if ( trace jni ) vm . sys write ( str ) ; runtime entrypoints . check jni gc ( ) ; try { sys call . sys free ( buf address ) ; } catch ( throwable unexpected ) { if ( trace jni ) unexpected . print stack trace ( system . err ) ; env . record exception ( unexpected ) ; } }	releasestringchars : release buffer obtained via getstringchars.
private business object data notification registration entity create business object data notification entity ( namespace entity namespace entity , notification event type entity notification event type entity , business object definition entity business object definition entity , file type entity file type entity , storage entity storage entity , business object data status entity new business object data status entity , business object data status entity old business object data status entity , notification registration key key , business object data notification filter business object data notification filter , list < job action > job actions , notification registration status entity notification registration status entity ) { business object data notification registration entity business object data notification registration entity = new business object data notification registration entity ( ) ; business object data notification registration entity . set namespace ( namespace entity ) ; business object data notification registration entity . set name ( key . get notification name ( ) ) ; business object data notification registration entity . set notification event type ( notification event type entity ) ; business object data notification registration entity . set business object definition ( business object definition entity ) ; if ( string utils . is not blank ( business object data notification filter . get business object format usage ( ) ) ) { business object data notification registration entity . set usage ( business object data notification filter . get business object format usage ( ) ) ; } business object data notification registration entity . set file type ( file type entity ) ; business object data notification registration entity . set business object format version ( business object data notification filter . get business object format version ( ) ) ; business object data notification registration entity . set storage ( storage entity ) ; business object data notification registration entity . set new business object data status ( new business object data status entity ) ; business object data notification registration entity . set old business object data status ( old business object data status entity ) ; business object data notification registration entity . set notification registration status ( notification registration status entity ) ; list < notification action entity > notification action entities = new array list < > ( ) ; business object data notification registration entity . set notification actions ( notification action entities ) ; for ( job action job action : job actions ) { job definition entity job definition entity = job definition dao helper . get job definition entity ( job action . get namespace ( ) , job action . get job name ( ) ) ; notification job action entity notification job action entity = new notification job action entity ( ) ; notification action entities . add ( notification job action entity ) ; notification job action entity . set job definition ( job definition entity ) ; notification job action entity . set correlation data ( job action . get correlation data ( ) ) ; notification job action entity . set notification registration ( business object data notification registration entity ) ; } return business object data notification registration entity ; }	creates a new business object data notification registration entity from the request information .
void bind ( string jndi url , hashtable < ? , ? > attributes , rmi rmi server , boolean rebind ) throws naming exception , url { initial context ctx = new initial context ( attributes ) ; if ( rebind ) ctx . rebind ( jndi url , rmi server ) ; else ctx . bind ( jndi url , rmi server ) ; ctx . close ( ) ; }	bind a stub to a registry .
public string to string ( ) { if ( info == null || alg id == null || signature == null ) return str ; string builder sb = new string builder ( ) ; sb . append ( str ) ; sb . append ( info . to string ( ) + str ) ; sb . append ( str + alg id . to string ( ) + str ) ; hex dump encoder encoder = new hex dump encoder ( ) ; sb . append ( str + encoder . encode buffer ( signature ) ) ; sb . append ( str ) ; return sb . to string ( ) ; }	returns a printable representation of the certificate.
public void test obsolete dst zone name ( ) throws exception { simple date format format = new simple date format ( str , locale . us ) ; date normal = format . parse ( str ) ; date dst = format . parse ( str ) ; assert equals ( num * num * num , normal . get time ( ) - dst . get time ( ) ) ; }	africa / cairo standard time is eet and daylight time is eest.
public final void xprint latin1 no lf ( string string ) throws io { if ( source == null ) { return ; } if ( string == null ) { string = str ; } byte [ ] write buffer = write buffer ; int write length = write length ; int length = string . length ( ) ; int offset = num ; int chars length = chars length ; char [ ] chars = chars ; while ( length > num ) { int sublen = math . min ( chars length , write buffer . length - write length ) ; if ( sublen <= num ) { source . write ( write buffer , num , write length , bool ) ; position += write length ; is flush required = bool ; write length = num ; sublen = math . min ( chars length , write buffer . length - write length ) ; } sublen = math . min ( length , sublen ) ; string . get chars ( offset , sublen , chars , num ) ; for ( int i = num ; i < sublen ; i ++ ) { byte value = ( byte ) chars [ i ] ; if ( value == str || value == str ) { length = num ; break ; } write buffer [ write length ++ ] = value ; } offset += sublen ; length -= sublen ; } write length = write length ; }	prints the character buffer to the stream encoded as latin1 .
private int calculate stroke weight ( ) { int stroke weight = ( int ) ( get stroke width ( ) * num ) ; logger . trace ( str , stroke width ) ; return stroke weight ; }	calculates the stroke weight in actual pixels *.
private static list < match result > flatten results ( list < list < match result > > all results ) { list < match result > results = new array list < match result > ( ) ; results . add all ( all results . remove ( num ) ) ; for ( list < match result > rel results : all results ) { list < match result > new results = new array list < match result > ( ) ; for ( match result cur result : results ) { for ( match result rel result : rel results ) { match result new result = cur result . copy ( ) ; new result . add assignment ( rel result ) ; new results . add ( new result ) ; } } results = new results ; } return results ; }	creates the combination of all match results .
@ override public void visit ( mapping m , int line , int col , int next line , int next col ) throws io { if ( previous line != line ) { previous column = num ; } if ( line != next line || col != next col ) { if ( line < max line ) { if ( previous line == line ) { out . append ( str ) ; } write entry ( m , col ) ; previous line = line ; previous column = col ; } else { preconditions . check state ( m == null ) ; } } for ( int i = line ; i <= next line && i < max line ; i ++ ) { if ( i == next line ) { break ; } close line ( bool ) ; open line ( bool ) ; } }	as each segment is visited write out the appropriate line mapping .
public boolean on click ( int position ) { if ( m mode == mode multiple select ) { if ( m selected items . contains ( position ) ) { m selected items . remove ( position ) ; if ( m selected items . is empty ( ) ) { set mode ( mode single select ) ; } } else { m selected items . add ( position ) ; } notify selection changed ( position ) ; return bool ; } return bool ; }	to be invoked when an item in the list is clicked ( even when not in multi selection mode ) .
public void add session event url ( string url , id sid ) { set < id > sids = session event ur . get ( url ) ; if ( sids == null ) { sids = collections . new set from map ( new concurrent hash map < id , boolean > ( ) ) ; set < id > previous value = session event ur . put if absent ( url , sids ) ; if ( previous value != null ) { sids = previous value ; } } if ( sids . add ( sid ) ) { notify persistence manager ( ) ; } }	adds a listener for the associated session id .
abstract public long range count ( ) ;	the # of index entries .
public final void add inst with unknown ( instances source , int att index ) throws exception { double [ ] probs ; double weight , new weight ; int class index ; instance instance ; int j ; probs = new double [ m per bag . length ] ; for ( j = num ; j < m per bag . length ; j ++ ) { if ( utils . eq ( tota l , num ) ) { probs [ j ] = num / probs . length ; } else { probs [ j ] = m per bag [ j ] / tota l ; } } enumeration < instance > enu = source . enumerate instances ( ) ; while ( enu . has more elements ( ) ) { instance = enu . next element ( ) ; if ( instance . is missing ( att index ) ) { class index = ( int ) instance . class value ( ) ; weight = instance . weight ( ) ; m per class [ class index ] = m per class [ class index ] + weight ; tota l = tota l + weight ; for ( j = num ; j < m per bag . length ; j ++ ) { new weight = probs [ j ] * weight ; m per class per bag [ j ] [ class index ] = m per class per bag [ j ] [ class index ] + new weight ; m per bag [ j ] = m per bag [ j ] + new weight ; } } } }	adds all instances with unknown values for given attribute , weighted according to frequency of instances in each bag .
@ override public void on item click ( adapter view < ? > parent , view view , int position , long id ) { set selection ( position ) ; }	user selected an application.
public void traverse fragment ( node pos ) throws org . xml . sax . sax { node top = pos ; while ( null != pos ) { start node ( pos ) ; node next node = pos . get first child ( ) ; while ( null == next node ) { end node ( pos ) ; if ( top . equals ( pos ) ) break ; next node = pos . get next sibling ( ) ; if ( null == next node ) { pos = pos . get parent node ( ) ; if ( ( null == pos ) || ( top . equals ( pos ) ) ) { if ( null != pos ) end node ( pos ) ; next node = null ; break ; } } } pos = next node ; } }	perform a pre - order traversal non - recursive style.
public void update processor duration ( duration duration ) { processor duration = optional . of ( duration ) ; }	update the processor duration .
static object invoke or die ( method method , object object , object ... params ) { try { return method . invoke ( object , params ) ; } catch ( illegal access exception e ) { throw new runtime exception ( str + str , e ) ; } catch ( invocation target exception e ) { final throwable cause = e . get cause ( ) ; if ( cause instanceof runtime exception ) { throw ( runtime exception ) cause ; } else if ( cause instanceof error ) { throw ( error ) cause ; } else { throw new runtime exception ( str , cause ) ; } } }	calls invoke and throws a runtimeexception if it fails .
public void start element ( string uri , string local name , string q name , attributes atts ) throws sax { element level ++ ; ns support . push context ( ) ; if ( force dtd && ! has output dtd ) start dtd ( local name == null ? q name : local name , str , str ) ; write ( str ) ; write name ( uri , local name , q name , bool ) ; write attributes ( atts ) ; if ( element level == num ) { force ns ( ) ; } write ns ( ) ; write ( str ) ; if ( html mode && ( q name . equals ( str ) || q name . equals ( str ) ) ) { cdata element = bool ; } super . start element ( uri , local name , q name , atts ) ; }	write a start tag.
void init program ( ) { gl use program ( this . program ) ; view matrix uniform = gl get uniform location ( this . program , str ) ; proj matrix uniform = gl get uniform location ( this . program , str ) ; viewport size uniform = gl get uniform location ( this . program , str ) ; gl use program ( num ) ; }	initialize the shader program .
public static string [ ] sort copy ( string [ ] objects ) { int len = objects . length ; string [ ] copy = new string [ len ] ; system . arraycopy ( objects , num , copy , num , len ) ; sort ( copy ) ; return copy ; }	sorts an array of strings , returning a new array with the sorted items.
public iterator < sim event > iterator ( ) { return list . iterator ( ) ; }	returns an iterator to the events in the queue .
private static boolean accepts ( string accept header , string to accept ) { string [ ] accept values = accept header . split ( str ) ; arrays . sort ( accept values ) ; return arrays . binary search ( accept values , to accept ) > - num || arrays . binary search ( accept values , to accept . replace all ( str , str ) ) > - num || arrays . binary search ( accept values , str ) > - num ; }	returns true if the given accept header accepts the given value .
public string [ ] tokenize ( string raw string ) { vector < string > result = new vector < string > ( ) ; string tokenizer tk = new string tokenizer ( raw string , m ) ; while ( tk . has more tokens ( ) ) { result . add element ( tk . next token ( ) ) ; } string [ ] new strings = new string [ result . size ( ) ] ; for ( int i = num ; i < result . size ( ) ; i ++ ) { new strings [ i ] = result . element at ( i ) ; } return new strings ; }	tokenize the given string based on the seperator and put the tokens into an array of strings.
public synchronized void return log cursor ( log cursor log cursor ) { log cursor . set loaned ( bool ) ; }	returns a loaned log cursor.
void unassign policies ( string service name , set policy d , boolean to verify ) throws am , sso { if ( ( policy d == null ) || ( policy d . is empty ( ) ) ) { return ; } am template = get template ( service name , am . policy template ) ; unassign policies ( template , policy d , to verify ) ; }	unassigns the given policies from this object .
public boolean release lock ( string lock name ) { if ( lock name == null || lock name . is empty ( ) ) { s logger . info ( str ) ; return bool ; } try { inter process lock lock = s acquired locks . get ( lock name ) ; if ( lock != null ) { s acquired locks . remove ( lock name ) ; lock . release ( ) ; s logger . info ( str + lock name ) ; } else { return bool ; } return bool ; } catch ( exception e ) { s logger . error ( str , lock name , e ) ; return bool ; } }	release the passed lock .
@ parameterized . parameters ( name = str ) public static collection < payment channel client . version selector > data ( ) { return arrays . as list ( payment channel client . version selector . version 1 , payment channel client . version selector . version 2 allow 1 ) ; }	we use parameterized tests to run the channel connection tests with each version of the channel .
private view find intercepting view ( float pos , view v ) { for ( key button view other view : m button views ) { if ( other view == v ) { continue ; } if ( array utils . contains ( small button ids , other view . get id ( ) ) ) { continue ; } other view . get location on screen ( s location ) ; float other pos = s location [ m vertical ? num : num ] ; float other dimension = m vertical ? v . get height ( ) : v . get width ( ) ; if ( pos > ( other pos + other dimension / num ) && pos < ( other pos + other dimension ) ) { return other view ; } } return null ; }	find intersecting view in mbuttonviews.
public void detach disk async ( final string vm id , vm disk operation vm disk operation , final future callback < task > response callback ) throws io { string path = string . format ( str , get base path ( ) , vm id ) ; create object async ( path , serialize object as json ( vm disk operation ) , response callback ) ; }	detached a persistent disk to specified vm .
public static boolean is fp ( @ not null final string text ) { for ( int i = num ; i < text . length ( ) ; i ++ ) { final char c = text . char at ( i ) ; if ( character . is digit ( c ) && c != str ) return bool ; final char d = character . to upper case ( c ) ; if ( d == str || d == str ) break ; } return bool ; }	see jls 3 . 10 . 2 . floating - point literals.
public concurrent hash map pro ( map < ? extends k , ? extends v > m ) { this ( math . max ( ( int ) ( m . size ( ) / default load factor ) + num , default initial capacity ) , default load factor , default concurrency level ) ; put all ( m ) ; }	creates a new map with the same mappings as the given map.
private void initialise commands ( ) { reward = new achievement rewards ( this ) ; achievement display = new achievement display ( this ) ; give command = new give command ( this ) ; book command = new book command ( this ) ; top command = new top command ( this ) ; stats command = new stats command ( this ) ; info command = new info command ( this ) ; list command = new list command ( this ) ; help command = new help command ( this ) ; check command = new check command ( this ) ; delete command = new delete command ( this ) ; }	initialises the command modules .
public create custom metric ( monitoring monitoring service , string project resource ) { this . monitoring service = monitoring service ; this . project resource = project resource ; this . metric type = custom metric domain + str + default metric type ; this . metric name = project resource + str + metric type ; }	constructs an instance of the class using the default metric name .
public static boolean delete files in a ( string directory path ) { if ( ( directory path == null ) || directory path . is empty ( ) ) { return bool ; } boolean is successful delete = bool ; list < file > files = get list of files in a ( directory path ) ; if ( files == null ) { return bool ; } try { for ( file file : files ) { boolean file delete success = delete file ( directory path , file . get name ( ) ) ; if ( ! file delete success ) { is successful delete = bool ; } } } catch ( exception e ) { logger . debug ( e . to string ( ) + system . line separator ( ) + stack trace . get string from stack trace ( e ) ) ; is successful delete = bool ; } return is successful delete ; }	this is a quiet method .
public fs add ( fs a origin fs , fs a target fs , j a j , int a start , int a end , annotation feature a feature , object a label value ) throws brat annotation exception { if ( cross multiple sentence || is same sentence ( a j , a origin fs . get begin ( ) , a target fs . get end ( ) ) ) { return interal add to cas ( a j , a start , a end , a origin fs , a target fs , a label value , a feature ) ; } else { throw new arc crossed multiple sentence exception ( str ) ; } }	update the cas with new / modification of arc annotations from brat.
public void test equals null ( ) { string a = str ; int a scale = - num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; assert false ( a number . equals ( null ) ) ; }	equals ( ) for equal bigdecimals.
private string read line ( ) { string buffer sb = new string buffer ( ) ; while ( buf . remaining ( ) > num ) { char c = ( char ) buf . get ( ) ; if ( c == str ) { if ( buf . remaining ( ) > num ) { char n = ( char ) buf . get ( buf . position ( ) ) ; if ( n == str ) { buf . get ( ) ; } } break ; } else if ( c == str ) { break ; } sb . append ( c ) ; } return sb . to string ( ) ; }	read a line of text.
protected void write ( data output stream stream ) throws exception { stream . write int ( value ) ; }	saving method . ( see nbt_tag ).
@ override public int show open dialog ( component parent ) { file sel file ; int result ; m = open dialog ; init gui ( open dialog ) ; result = super . show open dialog ( parent ) ; m = unhandled dialog ; remove property change listener ( m ) ; sel file = get selected file ( ) ; if ( ( result == approve option ) && ( get file must exist ( ) ) && ( sel file == null ) ) { result = show open dialog ( parent ) ; } else if ( ( result == approve option ) && ( get file must exist ( ) ) && ( sel file != null ) && ( sel file . is file ( ) ) && ( ! sel file . exists ( ) ) ) { int ret val = j . show confirm dialog ( parent , str + sel file + str ) ; if ( ret val == j . ok option ) result = show open dialog ( parent ) ; else result = cancel option ; } if ( result == approve option ) { if ( get file filter ( ) instanceof extension file filter ) m = ( extension file filter ) get file filter ( ) ; else m = null ; if ( get selected file ( ) != null ) configure current handler hook ( open dialog ) ; } return result ; }	pops up an " open file " file chooser dialog .
public boolean is nearly equal to ( double vector v , double tolerance ) { return math . abs ( v . x - x ) < tolerance && math . abs ( v . y - y ) < tolerance && math . abs ( v . z - z ) < tolerance ; }	checks if this vector is nearly equals to the vector v , with some tolerance .
void create vertical snap animation ( boolean visible ) { float translation y = visible ? num : m total height ; float y difference = math . abs ( translation y - get translation y ( ) ) / m total height ; long duration = ( long ) ( ms animation duration * y difference ) ; create animation ( num , num , translation y , duration ) ; }	create an animation that snaps the view into position vertically .
@ override public int update ( byte [ ] input , int input offset , int input len , byte [ ] output , int output offset ) throws short buffer exception { return cipher . update ( input , input offset , input len , output , output offset ) ; }	continues a multiple - part encryption / decryption operation.
private string validate inputs ( ) { if ( jar radio . get selection ( ) ) { file f = new file ( jar path . get text ( ) ) ; if ( ! f . exists ( ) ) { return str ; } if ( ! f . can read ( ) ) { return str ; } } else { file f = new file ( dir path . get text ( ) ) ; if ( ! f . exists ( ) ) { return str ; } if ( ! f . can read ( ) ) { return str ; } } return null ; }	determine if the current set of analysis inputs are valid.
public static double parse double string ( string st , t context ) { double ret = num ; matcher m = double pattern . matcher ( st ) ; if ( m . looking at ( ) ) { string truncated = st . substring ( num , m . end ( ) ) ; if ( ! truncated . equals ( st ) ) { context . report truncate ( st , truncated ) ; } try { ret = double . parse double ( truncated ) ; } catch ( number format exception e ) { context . report bad value ( e . get message ( ) ) ; } } else context . report bad value ( st ) ; return ret ; }	parse the st for a double value mysql compat in that illegal digits will be truncated and won ' t cause numberformatexception.
public class path ( dex file ... class path ) throws io { this ( lists . new array list ( class path ) , num ) ; }	creates a new classpath instance that can load classes from the given dex files.
public double great circle azimuth ( location location ) { if ( location == null ) { throw new illegal argument exception ( logger . log message ( logger . error , str , str , str ) ) ; } double lat1 = math . to radians ( this . latitude ) ; double lon1 = math . to radians ( this . longitude ) ; double lat2 = math . to radians ( location . latitude ) ; double lon2 = math . to radians ( location . longitude ) ; if ( lat1 == lat2 && lon1 == lon2 ) { return num ; } if ( lon1 == lon2 ) { return lat1 > lat2 ? num : num ; } double y = math . cos ( lat2 ) * math . sin ( lon2 - lon1 ) ; double x = math . cos ( lat1 ) * math . sin ( lat2 ) - math . sin ( lat1 ) * math . cos ( lat2 ) * math . cos ( lon2 - lon1 ) ; double azimuth radians = math . atan2 ( y , x ) ; return double . is na n ( azimuth radians ) ? num : math . to degrees ( azimuth radians ) ; }	computes the azimuth angle ( clockwise from north ) for the great circle path between this location and a specified location.
private boolean [ ] define irrelevant ( random random ) { boolean [ ] irr = new boolean [ get num attributes ( ) ] ; for ( int i = num ; i < irr . length ; i ++ ) { irr [ i ] = bool ; } int num irr = num ; for ( int i = num ; ( num irr < get num irrelevant ( ) ) && ( i < get num attributes ( ) * num ) ; i ++ ) { int maybe next = ( int ) ( random . next double ( ) * irr . length ) ; if ( irr [ maybe next ] == bool ) { irr [ maybe next ] = bool ; num irr ++ ; } } return irr ; }	defines randomly the attributes as irrelevant.
public void add drop item ( final string name , final double probability , final int amount ) { drops items . add ( new drop item ( name , probability , amount ) ) ; }	adds a named item to the list of items that will be dropped on dead if cleardropitemlist hasn ' t been called first , this will change all creatures of this kind .
protected void unparsed ent decl ( string name , string pubid , string sysid , string notation ) throws sax { m hand dtd . unparsed entity decl ( name , pubid , sysid , notation ) ; }	reports unparsed entity name .
public enumeration < permission > elements ( ) { synchronized ( this ) { return collections . enumeration ( perms map . values ( ) ) ; } }	returns an enumeration of all the permission objects in the container .
private static string format list ( string [ ] string list , string list pattern , string list composition pattern ) { if ( list pattern == null || list composition pattern == null ) { string builder result = new string builder ( ) ; for ( int i = num ; i < string list . length ; ++ i ) { if ( i > num ) { result . append ( str ) ; } result . append ( string list [ i ] ) ; } return result . to string ( ) ; } if ( string list . length > num ) { message format format = new message format ( list composition pattern ) ; string list = compose list ( format , string list ) ; } object [ ] args = new object [ string list . length + num ] ; system . arraycopy ( string list , num , args , num , string list . length ) ; args [ num ] = new integer ( string list . length ) ; message format format = new message format ( list pattern ) ; return format . format ( args ) ; }	format a list using given pattern strings.
public json array add ( object value ) { list . add ( value ) ; return this ; }	adds an entry into the json array .
public string comment ( ) throws parse exception { string buffer retval = new string buffer ( ) ; if ( look ahead ( num ) != str ) return null ; consume ( num ) ; while ( bool ) { char next = get next char ( ) ; if ( next == str ) { break ; } else if ( next == str ) { throw new parse exception ( this . buffer + str , this . ptr ) ; } else if ( next == str ) { retval . append ( next ) ; next = get next char ( ) ; if ( next == str ) throw new parse exception ( this . buffer + str , this . ptr ) ; retval . append ( next ) ; } else { retval . append ( next ) ; } } return retval . to string ( ) ; }	parse a comment string cursor is at a " ( " . leave cursor at ).
public static boolean ignorable whitespace ( string value ) { matcher m ; m = whitespace pattern . matcher ( value ) ; if ( m . matches ( ) ) return bool ; else return bool ; }	determine if a string contains only ignorable white spaces .
public delphi workgroup ( file xml file ) throws io { if ( xml file == null ) { throw new illegal argument exception ( str ) ; } else if ( ! xml file . exists ( ) ) { throw new io ( str + xml file . get absolute path ( ) ) ; } parse file ( xml file ) ; }	c - tor , gets project list from xml file.
public buffered block cipher ( block cipher cipher ) { this . cipher = cipher ; buf = new byte [ cipher . get block size ( ) ] ; buf off = num ; string name = cipher . get algorithm name ( ) ; int idx = name . index of ( str ) + num ; pgp cfb = ( idx > num && name . starts with ( str , idx ) ) ; if ( pgp cfb || cipher instanceof stream cipher ) { partial block okay = bool ; } else { partial block okay = ( idx > num && ( name . starts with ( str , idx ) ) ) ; } }	create a buffered block cipher without padding .
public static int read ints ( final file f , final long index a , final long offset , final long addend ) throws io { return read ints ( f , num , ( int ) f . length ( ) / num , a , offset , addend ) ; }	read an array of longs from a file .
public void wait all sites db stable ( ) { string prefix = str ; log . info ( prefix ) ; db jmx client geo instance = get jmx client ( localhost ) ; list < uri > vdc id iter = query by type ( virtual data center . class , bool ) ; for ( uri vdc id : vdc id iter ) { log . info ( str , vdc id . to string ( ) ) ; virtual data center vdc = query object ( virtual data center . class , vdc id ) ; if ( ! should check db status ( vdc ) ) { log . error ( str , vdc id ) ; continue ; } if ( vdc . get connection status ( ) != connection status . disconnected ) { site active site = dr util . get active site ( vdc . get short id ( ) ) ; wait db nodes stable ( geo instance , vdc . get short id ( ) , active site . get node count ( ) ) ; } } }	waits for the db instances joined in all sites.
public void save hierarchy state ( bundle container ) { dispatch save instance state ( container ) ; }	store this preference hierarchy ' s frozen state into the given container .
private static void pipe ( input stream source , output stream dest ) throws io { byte [ ] buf = new byte [ num ] ; int read = num ; while ( ( read = source . read ( buf ) ) >= num ) { if ( null != dest ) dest . write ( buf , num , read ) ; } if ( null != dest ) dest . flush ( ) ; }	pipes everything from the source to the dest.
@ override public void init ( filter config config ) throws servlet exception { try { expiry = math . min ( math . max ( min expiry , long . parse long ( config . get init parameter ( cache control ) ) ) , max expiry ) ; } catch ( number format exception nfe ) { logger . warn ( str + cache control + str , nfe ) ; expiry = null ; } }	parse the cache - control configuration parameter as a long integer , and set the filter expiry value , modulo the minimum and maximum expiry constraints.
@ override public int hash code ( ) { int code = num ; if ( name != null ) { code += name . hash code ( ) ; } if ( application name != null ) { code += application name . hash code ( ) ; } if ( resource names != null ) { code += resource names . hash code ( ) ; } if ( action values != null ) { code += action values . hash code ( ) ; } if ( advices != null ) { code += advices . hash code ( ) ; } if ( attributes != null ) { code += attributes . hash code ( ) ; } return code ; }	returns hash code of the object.
public static boolean substract trading fee ( player player , int price ) { big decimal fee = calculate fee ( player , price ) ; return player . drop ( str , fee . int value ( ) ) ; }	substracts the trading fee from the player depending on the given price.
public complex parameter ( math expression expression ) { this . expression = expression ; }	constructs a new complex parameter with the given expression , assuming the list of parameters is provided as labels within the expression .
public sample driver ( ) { handlers = new array list < sample handler > ( ) ; handlers . add ( new certificate sample handler ( ) ) ; handlers . add ( new group sample handler ( ) ) ; handlers . add ( new solution user sample handler ( ) ) ; handlers . add ( new user sample handler ( ) ) ; }	initialize sample driver with a list of handlers .
public long [ ] read long array ( final int items , final jbbp byte order ) throws io { int pos = num ; if ( items < num ) { long [ ] buffer = new long [ initial array buffer size ] ; while ( has available data ( ) ) { final long next = read long ( byte order ) ; if ( buffer . length == pos ) { final long [ ] newbuffer = new long [ buffer . length << num ] ; system . arraycopy ( buffer , num , newbuffer , num , buffer . length ) ; buffer = newbuffer ; } buffer [ pos ++ ] = next ; } if ( buffer . length == pos ) { return buffer ; } final long [ ] result = new long [ pos ] ; system . arraycopy ( buffer , num , result , num , pos ) ; return result ; } else { final long [ ] buffer = new long [ items ] ; for ( int i = num ; i < items ; i ++ ) { buffer [ i ] = read long ( byte order ) ; } return buffer ; } }	read number of long items from the input stream .
private void log graphical buffer occupancy ( float buffer occupancy ) { string title = str ; int used = ( int ) ( buffer occupancy * width ) ; string builder sb = new string builder ( ) ; sb . append ( start end char ) ; sb . append ( str ) ; sb . append ( title ) ; for ( int i = title . length ( ) + num ; i < width ; i ++ ) { sb . append ( str ) ; } sb . append ( start end char ) ; log . info ( sb . to string ( ) ) ; sb = new string builder ( ) ; sb . append ( start end char ) ; for ( int i = num ; i < used ; i ++ ) { sb . append ( str ) ; } for ( int j = used ; j < width ; j ++ ) { sb . append ( str ) ; } sb . append ( start end char ) ; log . info ( sb . to string ( ) ) ; sb = new string builder ( ) ; sb . append ( start end char ) ; for ( int i = num ; i < width ; i ++ ) { sb . append ( str ) ; } sb . append ( start end char ) ; log . info ( sb . to string ( ) ) ; }	log a graphical version of buffer occupancy .
public boolean is terminated ( ) { return thread pool . is terminated ( ) ; }	checks if is terminated .
public boolean is match ( string domain , list < user mapping attribute > attributes , list < string > groups ) { return domain . equals ignore case ( domain ) && attributes match ( attributes ) && groups match ( groups ) ; }	check if the domain , attributes , and groups results in a match with this usermapping object.
public static void write spatial grid table ( spatial grid grid , string file name ) { log . info ( str + file name + str ) ; spatial grid table writer sg table writer = new spatial grid table writer ( ) ; try { sg table writer . write ( grid , file name ) ; log . info ( str ) ; } catch ( io e ) { e . print stack trace ( ) ; } }	stores measured accessibilities in a file.
@ suppress warnings ( str ) public output socket linked output socket ( string hint identifier ) { final output socket out socket = output socket factory . create ( new identifer overriding socket hint decorator ( this , hint identifier ) ) ; controlled output sockets . add ( out socket ) ; return out socket ; }	creates an input socket that is linked to this socket this output socket will automatically be disconnected when there is no longer an input socket to guarantee the type of this sockethint .
public void cancel ( ) { cancelled = bool ; thread thread = this . thread ; if ( thread != null ) { thread . interrupt ( ) ; } }	stop execution of the task.
void set text ( byte [ ] text ) { this . text = text ; this . props = null ; }	this is used internally by the framework.
private string prepare url ( ) { string str = str ; str += str ; for ( int i = num ; i < symbol list . size ( ) ; i ++ ) { if ( i != num ) { str += str ; } str += symbol list . get ( i ) ; } str += str ; for ( string format : parameter list ) { str += format ; } str += str ; return str ; }	prepare url from symbols and parameters.
public void initialize ( ) { texture state ts = new texture state ( ) ; ts . set enabled ( bool ) ; set render state ( ts ) ; for ( int i = num ; i < tool list . size ( ) ; ++ i ) { tool state state = tool list . get ( i ) ; add tool ( state , bool ) ; } z buffer state = new z ( ) ; z buffer state . set function ( z . test function . less than or equal to ) ; z buffer state . set enabled ( bool ) ; set render state ( z buffer state ) ; }	create and add the tools to the scene graph.
private static void init ( ) { encoders = new hash map ( ) ; encoders . put ( str , str ) ; encoders . put ( str , str ) ; }	sets up default encoders ( uses sun png encoder if jdk 1.
public static boolean check image size ( final input stream stream , final i conf ) throws io { buffered image bi = io . read ( stream ) ; stream . close ( ) ; if ( bi == null ) { return bool ; } if ( bi . get height ( ) > conf . get img height ( ) || bi . get width ( ) > conf . get img width ( ) ) { return bool ; } return bool ; }	check if image size isn ' t bigger then bigest allowed .
private static boolean compare array case ( final string value , final int comparator , final object [ ] array ) { for ( int i = num ; i < array . length ; i ++ ) { final object obj = array [ i ] ; if ( obj instanceof string ) { if ( compare string case ( value , comparator , ( string ) obj ) ) { return bool ; } } else if ( obj instanceof number ) { if ( compare number ( value . trim ( ) , comparator , ( number ) obj ) ) { return bool ; } } else { if ( compare reflective ( value , comparator , obj ) ) { return bool ; } } } return bool ; }	compare arrays . case sensitive .
public double value at ( double x ) { return constant * math . pow ( num - x * x , outside exp ) ; }	calculates the value of the function at the given domain point .
protected double generate wait time ( ) { if ( state == state walking elsewhere ) { if ( location . equals ( latest bus stop ) ) { state = state waiting for bus ; } } if ( state == state travelling on bus ) { state = state waiting for bus ; } return num ; }	switches state between getpath ( ) calls.
@ override public enumeration < url > find resources ( final string name ) throws io { if ( name == null ) { return null ; } array list < url > result = new array list < url > ( ) ; int n = num ; while ( bool ) { url handler = get handler ( n ++ ) ; if ( handler == null ) { break ; } handler . find resources ( name , result ) ; } return collections . enumeration ( result ) ; }	returns all known urls which point to the specified resource .
protected void write graphic ctrl ext ( ) throws io { out . write ( num ) ; out . write ( num ) ; out . write ( num ) ; int transp , disp ; if ( transparent == null ) { transp = num ; disp = num ; } else { transp = num ; disp = num ; } if ( dispose >= num ) { disp = dispose & num ; } disp <<= num ; out . write ( num | disp | num | transp ) ; write short ( delay ) ; out . write ( trans index ) ; out . write ( num ) ; }	writes graphic control extension.
public static void write element list ( xml xml output , string tag name , iterable < string > list values ) throws io { write element list ( xml output , tag name , list values . iterator ( ) ) ; }	write a list of strings to document as elements with given tag name .
public static date string to date ( string date as string ) { try { date format df = new simple date format ( date format ) ; df . set time zone ( utc ) ; return df . parse ( date as string ) ; } catch ( parse exception e ) { return null ; } catch ( null pointer exception e ) { return null ; } }	converts a string representation of a date to its respective date object .
public simple http request builder content ( string chars , charset charset ) { return content ( chars . get bytes ( charset ) ) ; }	sets the given string to be used as the request content , decoding to bytes with the given charset .
private double adjust transform ( ) { double x min = double . positive infinity ; double x max = double . negative infinity ; double y min = double . positive infinity ; double y max = double . negative infinity ; for ( variable var : csp . get variables ( ) ) { d point = get position ( var ) ; x min = math . min ( x min , point . get x ( ) ) ; x max = math . max ( x max , point . get x ( ) ) ; y min = math . min ( y min , point . get y ( ) ) ; y max = math . max ( y max , point . get y ( ) ) ; } double scale = math . min ( pane . get width ( ) / ( x max - x min + num ) , pane . get height ( ) / ( y max - y min + num ) ) ; pane . set translate x ( ( scale * ( pane . get width ( ) - x min - x max ) / num ) ) ; pane . set translate y ( ( scale * ( pane . get height ( ) - y min - y max ) / num ) ) ; pane . set scale x ( scale ) ; pane . set scale y ( scale ) ; return scale ; }	computes transforms ( translations and scaling ) and applies them to the environment state view.
public void add table model listener ( w listener ) { if ( listener == null ) { return ; } if ( ! m listeners . contains ( listener ) ) { m listeners . add ( listener ) ; } return ; }	add a listener for events from the data model.
public boolean can traverse outside subtree ( ) { if ( null != m parts ) { int n = m parts . size ( ) ; for ( int i = num ; i < n ; i ++ ) { avt part = ( avt ) m parts . element at ( i ) ; if ( part . can traverse outside subtree ( ) ) return bool ; } } return bool ; }	tell if this expression or it ' s subexpressions can traverse outside the current subtree .
private int [ ] parse ymd ( string string ) { string = string . trim ( ) ; try { if ( string . char at ( num ) != str || string . char at ( num ) != str ) { throw new illegal argument exception ( str ) ; } int [ ] ymd = new int [ num ] ; ymd [ num ] = integer . value of ( string . substring ( num , num ) ) ; ymd [ num ] = integer . value of ( string . substring ( num , num ) ) ; ymd [ num ] = integer . value of ( string . substring ( num , num ) ) ; return ymd ; } catch ( number format exception ex ) { throw new illegal argument exception ( str , ex ) ; } }	parse yyyy - mm - dd into a 3 element array [ yyyy , mm , dd ] .
public abstract point renderer ( ) { shape = new d . double ( - num , - num , num , num ) ; color = new single color ( color . black ) ; value visible = bool ; value column = num ; value location = location . center ; value alignment x = num ; value alignment y = num ; value rotation = num ; value distance = num ; value color = new single color ( color . black ) ; value font = font . decode ( null ) ; error visible = bool ; error column top = num ; error column bottom = num ; error color = new single color ( color . black ) ; error shape = new d . double ( - num , num , num , num ) ; error stroke = new basic stroke ( num ) ; }	creates a new abstractpointrenderer object with default shape and color .
public object put ( string key , object value ) { object old value = context . get attribute ( key , engine scope ) ; context . set attribute ( key , value , engine scope ) ; return old value ; }	set the key , value binding in the engine_scope of the context .
public void test get lowest set bit pos ( ) { byte a bytes [ ] = { - num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = num ; int i number = num ; big integer a number = new big integer ( a sign , a bytes ) ; int result = a number . get lowest set bit ( ) ; assert true ( str , result == i number ) ; byte [ ] a bytes = { num , num , num } ; i number = num ; a number = new big integer ( a sign , a bytes ) ; result = a number . get lowest set bit ( ) ; assert true ( str , result == i number ) ; byte [ ] a bytes = { - num , num , num } ; i number = num ; a number = new big integer ( a sign , a bytes ) ; result = a number . get lowest set bit ( ) ; assert true ( str , result == i number ) ; }	java . math . biginteger # getlowestsetbit ( ) getlowestsetbit for positive biginteger.
private void execute another request ( ) throws sql { random random = new random ( ) ; int value = random . next int ( ) ; prepared statement prepared statement = shared connection . prepare statement ( str + value ) ; result set rs = prepared statement . execute query ( ) ; rs . next ( ) ; assert equals ( value , rs . get int ( num ) ) ; }	execute another query to verify exchange integrity .
public static int hash ( byte [ ] data , int seed ) { return hash ( byte buffer . wrap ( data ) , seed ) ; }	hashes bytes in an array .
public int parse ( char c , char [ ] ia , int ip , int il ) { assert ( ia [ ip ] == c ) ; if ( surrogate . is high ( c ) ) { if ( il - ip < num ) { error = coder result . underflow ; return - num ; } char d = ia [ ip + num ] ; if ( surrogate . is low ( d ) ) { character = to uc ( c , d ) ; is pair = bool ; error = null ; return character ; } error = coder result . malformed for length ( num ) ; return - num ; } if ( surrogate . is low ( c ) ) { error = coder result . malformed for length ( num ) ; return - num ; } character = c ; is pair = bool ; error = null ; return character ; }	parses a ucs - 4 character from the given source buffer , handling surrogates .
public void perform start operation async ( final string vm id , final future callback < task > response callback ) throws io { string path = string . format ( str , get base path ( ) , vm id ) ; create object async ( path , null , response callback ) ; }	perform a vm start operation on specified vm .
public boolean this device speaks to ( bluetooth device other ) throws no such algorithm exception , unsupported encoding exception { if ( murmur service . use backoff ) return bool ; if ( other == null ) { log . info ( str ) ; return bool ; } string other addr = other . get address ( ) ; if ( other addr == null ) { log . info ( str + other + str ) ; return bool ; } string my addr = m bluetooth speaker . get address ( ) ; if ( my addr . equals ( which initiates ( my addr , other addr ) ) ) { return bool ; } else { return bool ; } }	check whether this device should start an exchange with the other device or allow that device to start an exchange , based on their addresses .
public static < k , v > list < key value < k , v > > wait until min key value records received ( properties consumer config , string topic , int expected num records , long wait time ) throws interrupted exception { list < key value < k , v > > accum data = new array list < > ( ) ; long start time = system . current time millis ( ) ; while ( bool ) { list < key value < k , v > > read data = read key values ( topic , consumer config ) ; accum data . add all ( read data ) ; if ( accum data . size ( ) >= expected num records ) return accum data ; if ( system . current time millis ( ) > start time + wait time ) throw new assertion error ( str + expected num records + str + accum data . size ( ) + str + wait time + str ) ; thread . sleep ( math . min ( wait time , num ) ) ; } }	wait until enough data ( key - value records ) has been consumed .
public static < t > combined download task < t > single ( download task < t > task ) { objects . require non null ( task ) ; return new single combined task < t > ( task ) ; }	creates a combineddownloadtask from a downloadtask .
public void add hex listener ( final i listener ) { preconditions . check not null ( listener , str ) ; if ( ! m listeners . contains ( listener ) ) { m listeners . add ( listener ) ; } }	adds a new event listener to the list of event listeners .
public static < t extends serializable entity > deserializer roundtrip serializable entity with binary serializer ( final t original entity , final account lookup account lookup ) { final binary serializer binary serializer = new binary serializer ( ) ; original entity . serialize ( binary serializer ) ; return new binary deserializer ( binary serializer . get bytes ( ) , new deserialization context ( account lookup ) ) ; }	serializes originalentity and returns a binary deserializer that can deserialize it .
@ deprecated public static string encode ( final string s , final string encoding , bit set safe octets , boolean plus for space ) throws unsupported encoding exception { string builder out = new string builder ( s . length ( ) * num ) ; boolean needs encoding ; try { needs encoding = encode ( s , encoding , safe octets , plus for space , out ) ; } catch ( unsupported encoding exception e ) { throw e ; } catch ( io e ) { throw new assertion error ( e ) ; } if ( needs encoding ) { return out . to string ( ) ; } else { return s ; } }	url - escapes s by encoding it with the specified character encoding , and then escaping all octets not included in safeoctets .
public static void fire clipboard changed ( ) { for ( iterator i = listener list . iterator ( ) ; i . has next ( ) ; ) { clipboard listener listener = ( clipboard listener ) i . next ( ) ; listener . clipboard changed ( ) ; } }	fire a clipboard changed event to all registered model listeners .
public boolean is empty ( ) { return window . is empty ( ) ; }	returns true to indicate the window is empty , or false if the view is not empty .
public boolean contains ( t listener ) { if ( m listeners != null ) { return m listeners . contains ( listener ) ; } else { return bool ; } }	gets whether the specified listener object is contained in the chain .
public simple dictionary ( string ... a words ) { words = new hash set < string > ( ) ; for ( string word : a words ) { words . add ( word . to lower case ( ) ) ; } }	create a simple dictionary from a list of string . this can be used for testing.
public long read long le ( ) throws io { input stream . read fully ( work space , num , num ) ; return ( ( long ) ( work space [ num ] & num ) << num ) | ( ( long ) ( work space [ num ] & num ) << num ) | ( ( long ) ( work space [ num ] & num ) << num ) | ( ( long ) ( work space [ num ] & num ) << num ) | ( ( long ) ( work space [ num ] & num ) << num ) | ( ( long ) ( work space [ num ] & num ) << num ) | ( ( long ) ( work space [ num ] & num ) << num ) | ( ( long ) ( work space [ num ] & num ) ) ; }	read a 64bit long in le.
public void test set public key2 ( ) throws exception { identity i2 = new identity stub ( str , identity scope . get system scope ( ) ) ; new public key stub ( str , str , new byte [ ] { num , num , num , num , num } ) ; try { i2 . set public key ( null ) ; } catch ( key management exception ok ) { } }	verify identity . setpublickey ( ) throws keymanagementexception if key is invalid.
@ layoutlib delegate static long elapsed realtime ( ) { return system . current time millis ( ) - s boot time ; }	returns milliseconds since boot , including time spent in sleep .
@ override public void fill assigned keys ( set < string > keys ) { keys . add ( key column . name ( ) ) ; }	returns all the keys assigned statically , e.
@ override public void remove instance listener ( instance listener dsl ) { m instance listeners . remove ( dsl ) ; }	remove an instance listener.
public double eccentricity ( ) { return math . sqrt ( num - ( semi minor axis ( ) * semi minor axis ( ) ) / ( semi major axis ( ) * semi major axis ( ) ) ) ; }	gets the eccentricity of the ellipse , between 0 ( inclusive ) and 1 ( exclusive ).
private void simple apply ( i document , string string , configurable completion proposal proposal ) throws bad location exception { proposal . set cursor position ( string . length ( ) ) ; document . replace ( proposal . get replacement offset ( ) , proposal . get replacement length ( ) , string ) ; }	just insert the string at the replacement offset.
public string pull dump2 pc ( ) { string serial = device . get serial number ( ) ; file dest = new file ( file utils . get temp directory ( ) , serial + str ) ; string path = dest . get path ( ) ; log . debug ( str , path ) ; command line commandpull = adb command ( str , str , path ) ; string out = execute command quietly ( commandpull ) ; log . debug ( str , out ) ; return path ; }	pull dump file from android device to pc.
@ after public void execute test ( ) throws throwable { try { test env . execute test ( ) ; } catch ( assertion error assertion error ) { if ( test env . has been stopped ( ) ) { throw new assertion error ( str + assertion error . get message ( ) ) ; } throw assertion error ; } }	executes the test and verifies the output received .
public void validate emr cluster definition key ( emr cluster definition key key ) throws illegal argument exception { assert . not null ( key , str ) ; key . set namespace ( alternate key helper . validate string parameter ( str , key . get namespace ( ) ) ) ; key . set emr cluster definition name ( alternate key helper . validate string parameter ( str , str , key . get emr cluster definition name ( ) ) ) ; }	validates the emr cluster definition key.
@ target api ( version codes . kitkat ) private void handle sms received ( intent intent ) { if ( build config . debug ) log . v ( str ) ; bundle bundle = intent . get extras ( ) ; if ( bundle != null ) { sms message [ ] messages = null ; if ( sms popup utils . has kit kat ( ) ) { messages = intents . get messages from intent ( intent ) ; } else { messages = sms popup utils . get messages from intent ( intent ) ; } if ( messages != null ) { notify message received ( new sms mms message ( context , messages , system . current time millis ( ) ) ) ; } } }	handle receiving a sms message.
public static long install age ( long current timestamp , long install timestamp , boolean send install event ) { if ( send install event ) { return install age immediately after installing ; } else { return math . max ( num , ( current timestamp - install timestamp ) / ms per day ) ; } }	determine how long it ' s been since chrome was first installed.
public boolean is distributed ( ) { return ! is local ( ) ; }	returns true if the virtual volume is a distributed volume .
public void test value of long negative1 ( ) { long long val = - num ; big integer a number = big integer . value of ( long val ) ; byte r bytes [ ] = { - num , num , num , - num , num , num , - num , - num } ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = a number . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , a number . signum ( ) ) ; }	valueof ( long val ) : convert a negative long value to a biginteger .
public synchronized boolean is consumer ( image consumer ic ) { return the consumers . contains ( ic ) ; }	determines if an imageconsumer is on the list of consumers currently interested in data for this image .
public static boolean verify signature ( signature initialized signature engine , byte [ ] message , byte [ ] signature ) throws signature exception { initialized signature engine . update ( message ) ; return initialized signature engine . verify ( signature ) ; }	verify the signature of a message .
public static void write var int ( output stream out , int x ) throws io { while ( ( x & ~ num ) != num ) { out . write ( ( byte ) ( num | ( x & num ) ) ) ; x >>>= num ; } out . write ( ( byte ) x ) ; }	write a variable size int .
public segment path complete ( end type etype ) { segment path result ; if ( data == null || w < num ) { return null ; } if ( w == data . length ) { result = new segment path ( data , etype ) ; reset ( num ) ; } else { double [ ] data to adopt = new double [ w ] ; system . arraycopy ( data , num , data to adopt , num , w ) ; result = new segment path ( data to adopt , etype ) ; reset ( num ) ; } return result ; }	complete building a segmentpath.
@ deprecated public static bundle parse url ( string url ) { url = url . replace ( str , str ) ; try { url u = new url ( url ) ; bundle b = decode url ( u . get query ( ) ) ; b . put all ( decode url ( u . get ref ( ) ) ) ; return b ; } catch ( url e ) { return new bundle ( ) ; } }	parse a url query and fragment parameters into a key - value bundle .
private static void create tmp file ( completable future < new file > file creation , path dest dir , list < ts > files ) { log . log ( level . fine , str ) ; try { collections . sort ( files , comparator . comparing ( null ) ) ; final file channel fd = file util . create temp file ( dest dir , str , str ) ; try { final date time begin ; try ( to xdr tables output = new to xdr tables ( fd , compression . default optimized ) ) { while ( ! files . is empty ( ) ) { ts tsdata = files . remove ( num ) ; if ( file creation . is cancelled ( ) ) throw new io ( str ) ; output . add all ( tsdata ) ; } begin = new date time ( output . get hdr begin ( ) , date time zone . utc ) ; if ( file creation . is cancelled ( ) ) throw new io ( str ) ; } if ( file creation . is cancelled ( ) ) throw new io ( str ) ; install pool . execute ( null ) ; } catch ( error | runtime exception | io ex ) { try { fd . close ( ) ; } catch ( error | runtime exception | io ex1 ) { ex . add suppressed ( ex1 ) ; } throw ex ; } } catch ( error | runtime exception | io ex ) { log . log ( level . warning , str , ex ) ; synchronized ( outstanding ) { outstanding . remove ( file creation ) ; } file creation . complete exceptionally ( ex ) ; } }	the fork - join task that creates a new file.
public void content tag ( string tag , string name , string value , string content ) { spacing ( ) ; m out . print ( str ) ; m out . print ( tag ) ; m out . print ( str ) ; m out . print ( name ) ; m out . print ( str ) ; m out . print ( str ) ; escape string ( value ) ; m out . print ( str ) ; m out . print ( str ) ; escape string ( content ) ; m out . print ( str ) ; m out . print ( str ) ; m out . print ( tag ) ; m out . print ( str ) ; println ( ) ; }	print a new content tag with a single attribute , consisting of an open tag , content text , and a closing tag , all on one line .
public void add child ( component child ) { components . add ( child ) ; child . set parent ( this ) ; }	adds a child to this composite at the end of the list .
public boolean open ( int max rows ) { log . info ( str + max rows ) ; m max rows = max rows ; if ( m open ) { log . fine ( str ) ; data refresh all ( ) ; return bool ; } if ( m virtual ) { verify virtual ( ) ; } create select sql ( ) ; if ( m sql == null || m sql . equals ( str ) ) { log . log ( level . severe , str ) ; return bool ; } m loader = new loader ( ) ; m row count = m loader . open ( max rows ) ; if ( m virtual ) { m buffer = null ; m virtual buffer = new hash map < integer , object [ ] > ( num ) ; } else { m buffer = new array list < object [ ] > ( m row count + num ) ; } m sort = new array list < m > ( m row count + num ) ; if ( m row count > num ) { if ( m row count < num ) m loader . run ( ) ; else { m loader thread = new thread ( m loader , str ) ; m loader thread . start ( ) ; } } else m loader . close ( ) ; m open = bool ; m changed = bool ; m row changed = - num ; m inserting = bool ; return bool ; }	open database . if already opened , data is refreshed.
public void add message listener ( i listener ) { listeners . add ( listener ) ; }	add input stream message listener.
protected void sync flush vdc config to local ( ) throws exception { if ( vdc prop barrier == null ) { vdc prop barrier = new vdc property barrier ( target site info , vdc op barrier timeout ) ; } vdc prop barrier . enter ( ) ; try { flush vdc config to local ( ) ; } finally { boolean all left = vdc prop barrier . leave ( ) ; if ( ! all left ) { log . info ( str ) ; thread . sleep ( ipsec restart delay ) ; } } vdc prop barrier = null ; }	simulaneously flush vdc config on all nodes in current site . via barrier.
public corrupt index exception ( string message , data input input , throwable cause ) { this ( message , objects . to string ( input ) , cause ) ; }	create exception with message and root cause .
protected void remove from quarantine queue ( node port tuple npt ) { while ( quarantine queue . remove ( npt ) ) ; }	remove a switch port from the quarantine queue .
public boolean has expired ( ) { if ( max age == num ) return bool ; if ( max age == max age unspecified ) return bool ; long delta second = ( system . current time millis ( ) - when created ) / num ; if ( delta second > max age ) return bool ; else return bool ; }	reports whether this http cookie has expired or not .
public static string repeat character ( char c , int repetitions ) { string builder s = new string builder ( repetitions ) ; for ( int i = num ; i < repetitions ; i ++ ) { s . append ( c ) ; } return s . to string ( ) ; }	forms a string by repeating the character the given number of times .
public static string check and replace literals ( string inst str ) { string tmp = inst str ; if ( tmp . contains ( components delim ) ) { tmp = tmp . replace all ( components delim , str ) ; log . warn ( str + components delim + str ) ; } if ( tmp . contains ( element delim ) ) { tmp = tmp . replace all ( element delim , str ) ; log . warn ( str + element delim + str ) ; } if ( tmp . contains ( levelin ) ) { tmp = tmp . replace all ( levelin , str ) ; log . warn ( str + levelin + str ) ; } if ( tmp . contains ( levelout ) ) { tmp = tmp . replace all ( levelout , str ) ; log . warn ( str + levelout + str ) ; } if ( tmp . contains ( parfor cdata end ) ) { tmp = tmp . replace all ( parfor cdata end , str ) ; log . warn ( str + parfor cdata end + str ) ; } return tmp ; }	replacement of internal delimiters occurring in literals of instructions in order to ensure robustness of serialization and parsing.
public static < t > t with writer ( writer writer , @ closure params ( first param . class ) closure < t > closure ) throws io { try { t result = closure . call ( writer ) ; try { writer . flush ( ) ; } catch ( io e ) { } writer temp = writer ; writer = null ; temp . close ( ) ; return result ; } finally { close with warning ( writer ) ; } }	allows this writer to be used within the closure , ensuring that it is flushed and closed before this method returns .
public static int round ( double value ) { int rounded value = value > num ? ( int ) ( value + num ) : - ( int ) ( math . abs ( value ) + num ) ; return rounded value ; }	rounds a double to the next nearest integer value.
private service registrar [ ] build service registrar ( ) { int k = num ; service registrar [ ] proxys = new service registrar [ discovered locators . size ( ) ] ; iterator iter = discovered locators . iterator ( ) ; while ( iter . has next ( ) ) { locator reg reg = ( locator reg ) iter . next ( ) ; proxys [ k ++ ] = reg . proxy ; } return proxys ; }	from each element of the set of locatorreg objects that correspond to lookup services that have been discovered , this method extracts the serviceregistrar reference and returns all of the references in an array of serviceregistrar .
public void rewind to ws ( ) { if ( next offset == num ) { return ; } next offset -- ; while ( next offset > num && ! character . is whitespace ( s . char at ( next offset ) ) ) { next offset -- ; } this . offset = next offset - num ; }	sets next offset to the next preceeding ws - - this method must not be called during parsing of jsdoc , but only for completion hint !.
private static permission [ ] flatten ( permission [ ] pa ) { list l = new array list ( pa . length ) ; for ( int i = num ; i < pa . length ; i ++ ) { permission p = pa [ i ] ; if ( p instanceof grant permission ) { l . add all ( arrays . as list ( ( ( grant permission ) p ) . grants ) ) ; } else { l . add ( p ) ; } } return ( permission [ ] ) l . to array ( new permission [ l . size ( ) ] ) ; }	returns an array containing all non - grantpermission permissions in the given permission array , including those contained in nested grantpermissions in the array .
protected void start document internal ( ) throws sax { if ( m need to call start document ) { super . start document internal ( ) ; m sax handler . start document ( ) ; m need to call start document = bool ; } }	pass callback to the sax handler.
public static boolean is anonymous ( string class name ) { int i = class name . last index of ( str ) ; if ( i >= num && ++ i < class name . length ( ) ) { while ( i < class name . length ( ) ) { if ( ! character . is digit ( class name . char at ( i ) ) ) { return bool ; } i ++ ; } return bool ; } return bool ; }	does a class name appear to designate an anonymous class ? only the name is analyzed.
string descriptor ( boolean include this ) { string builder result = new string builder ( ) ; result . append ( str ) ; if ( include this ) { result . append ( declaring type . name ) ; } for ( type id t : parameters . types ) { result . append ( t . name ) ; } result . append ( str ) ; result . append ( return type . name ) ; return result . to string ( ) ; }	returns a descriptor like " ( ljava / lang / class ; [ i ) ljava / lang / object ; " .
public void test single file ( ) throws exception { j mojo = new mojo ( str ) ; mojo . execute ( ) ; file produced = get expected output file ( mojo ) ; assert true ( str + produced , produced . is file ( ) ) ; long size = produced . length ( ) ; boolean correct size = ( size > num ) && ( size < num ) ; assert true ( str + size , correct size ) ; }	tests configuration with a single input file .
public final static boolean is potential zip archive ( string name ) { int last dot = name . last index of ( str ) ; if ( last dot == - num ) { return bool ; } if ( name . last index of ( file . separator char ) > last dot ) { return bool ; } int length = name . length ( ) ; int extension length = length - last dot - num ; if ( extension length == extension java . length ( ) ) { for ( int i = extension length - num ; i >= num ; i -- ) { if ( character . to lower case ( name . char at ( length - extension length + i ) ) != extension java . char at ( i ) ) { break ; } if ( i == num ) { return bool ; } } } if ( extension length == extension class . length ( ) ) { for ( int i = extension length - num ; i >= num ; i -- ) { if ( character . to lower case ( name . char at ( length - extension length + i ) ) != extension class . char at ( i ) ) { return bool ; } } return bool ; } return bool ; }	returns whether the given name is potentially a zip archive file name ( it has a file extension and it is not ".
void add term ( map builder term type type , j jclass , string alias ) { map builder term new term = new map builder term ( ) ; new term . type = type ; new term . jclass = jclass ; new term . alias = alias ; terms . add ( new term ) ; }	add a term to the map builder .
@ suppress warnings ( str ) protected void write path ( shape s ) { path iterator segments = s . get path iterator ( null ) ; double [ ] coords = new double [ num ] ; for ( int i = num ; ! segments . is done ( ) ; i ++ , segments . next ( ) ) { if ( i > num ) { write ( str ) ; } int segment type = segments . current segment ( coords ) ; switch ( segment type ) { case path iterator . seg moveto : write ( str , coords [ num ] , str , coords [ num ] ) ; break ; case path iterator . seg lineto : write ( str , coords [ num ] , str , coords [ num ] ) ; break ; case path iterator . seg cubicto : write ( str , coords [ num ] , str , coords [ num ] , str , coords [ num ] , str , coords [ num ] , str , coords [ num ] , str , coords [ num ] ) ; break ; case path iterator . seg quadto : write ( str , coords [ num ] , str , coords [ num ] , str , coords [ num ] , str , coords [ num ] ) ; break ; case path iterator . seg close : write ( str ) ; break ; default : throw new illegal state exception ( str ) ; } } }	writes the beginning of the specified shape without any closing commands .
@ override public int port remote ( ) { if ( channel != null ) { try { socket address addr = channel . get remote address ( ) ; return num ; } catch ( exception e ) { e . print stack trace ( ) ; return num ; } } else return num ; }	returns the remote client ' s port .
public void add drop target ( drop target target ) { m drop targets . add ( target ) ; }	add a droptarget to the list of potential places to receive drop events .
@ override public void start element ( final string namespace uri , final string local name , final string q name , final attributes atts ) throws sax { object object to load = null ; if ( open nodes . size ( ) == num ) object to load = root object ; else object to load = create child ( q name , atts ) ; if ( object to load != null ) { if ( atts . get index ( str ) < num ) object get setter . set ( object to load , str , q name ) ; object get setter . set all ( object to load , atts ) ; } open nodes . push ( new stacked object ( object to load ) ) ; }	call back methods used by saxloader . startelement ( ) and endelement ( ).
public final int put ( object key , int value , boolean is replace ) { int prime = prime ; int hash = math . abs ( system . identity hash code ( key ) % prime ) ; object [ ] keys = keys ; while ( bool ) { object test key = keys [ hash ] ; if ( test key == null ) { keys [ hash ] = key ; values [ hash ] = value ; size ++ ; if ( keys . length <= num * size ) resize ( num * keys . length ) ; return value ; } else if ( key != test key ) { hash = ( hash + num ) % prime ; continue ; } else if ( is replace ) { int old = values [ hash ] ; values [ hash ] = value ; return old ; } else { return values [ hash ] ; } } }	puts a new value in the property table with the appropriate flags.
public int add all absent ( collection c ) { int num new = c . size ( ) ; if ( num new == num ) return num ; synchronized ( this ) { object [ ] elements = get array ( ) ; int len = elements . length ; object [ ] temp = new object [ num new ] ; int added = num ; for ( iterator itr = c . iterator ( ) ; itr . has next ( ) ; ) { object e = itr . next ( ) ; if ( index of ( e , elements , num , len ) < num && index of ( e , temp , num , added ) < num ) temp [ added ++ ] = e ; } if ( added != num ) { object [ ] new elements = new object [ len + added ] ; system . arraycopy ( elements , num , new elements , num , len ) ; system . arraycopy ( temp , num , new elements , len , added ) ; set array ( new elements ) ; } return added ; } }	appends all of the elements in the specified collection that are not already contained in this list , to the end of this list , in the order that they are returned by the specified collection ' s iterator .
protected static void register library ( i external library manager , string dataverse , string library name ) throws exception { class loader class loader = get library class loader ( dataverse , library name ) ; external library manager . register library class loader ( dataverse , library name , class loader ) ; }	register the library class loader with the external library manager.
public void auto size ( ) { if ( ! auto resize ) return ; }	size columns . uses mimimum column size.
public void test case9 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num , num , num , num , num , num , num , num , num } ; int a sign = num ; byte r bytes [ ] = { num , num , num , num , num , num , num , num , num , num , num , num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = big integer . one ; big integer result = a number . multiply ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	multiply a positive number by one .
public static string raw m ( string s ) { return binl2rstr ( binl2md5 ( rstr2binl ( s ) , s . length ( ) * num ) ) ; }	calculate the md5 of a raw string.
public boolean is quest completed ( final string name ) { final string info = get quest ( name , num ) ; if ( info == null ) { return bool ; } return info . equals ( str ) ; }	checks whether the player has completed the given quest or not .
@ layoutlib delegate static float ceil ( float value ) { return ( float ) math . ceil ( value ) ; }	returns the float conversion of the most negative ( i.
private final user remove user ( string channel , string nick ) { channel = channel . to lower case ( ) ; user user = new user ( str , nick ) ; synchronized ( channels ) { hashtable < user , user > users = channels . get ( channel ) ; if ( users != null ) { return users . remove ( user ) ; } } return null ; }	remove a user from the specified channel in our memory .
public static void translate pos ( collection < graph node > move nodes , map < graph node , d > positions , translater into region ) { for ( graph node node : move nodes ) { d location = translate node ( node , positions , into region ) ; if ( null == location ) { continue ; } positions . put ( node , location ) ; } }	update positions of movenodes using the supplied translator.
public void if present or else ( long consumer action , runnable empty action ) { if ( is present ) { action . accept ( value ) ; } else { empty action . run ( ) ; } }	if a value is present , performs the given action with the value , otherwise performs the given empty - based action .
public void test to big integer pos2 ( ) { string a = str ; big integer b number = new big integer ( str ) ; big decimal a number = new big decimal ( a ) ; big integer result = a number . to big integer ( ) ; assert true ( str , result . equals ( b number ) ) ; }	convert a positive bigdecimal to biginteger.
private string cleanup path ( string file name ) { if ( file name == null ) { return null ; } file name = file name . replace ( str , str ) ; file name = file name . replace ( str , str ) ; if ( file name . starts with ( str ) ) { return file name ; } if ( file name . starts with ( str ) ) { return str + file name ; } return str + file name ; }	clean up the path so that is looks like " . / usr / local / file ".
public static class < ? > invocation handler return type ( class < ? > type ) { if ( type == byte . class ) return byte . class ; if ( type == char . class ) return character . class ; if ( type == double . class ) return double . class ; if ( type == float . class ) return float . class ; if ( type == int . class ) return integer . class ; if ( type == long . class ) return long . class ; if ( type == short . class ) return short . class ; if ( type == boolean . class ) return boolean . class ; return type ; }	returns the type that must be returned by the invocation handler of a dynamic proxy in order to have the dynamic proxy return the specified type ( which is assumed to be a legal member type for an annotation ) .
private static script script from string ( string script string , script type script type ) { return new script ( script string , script type ) ; }	create a dml or pydml script object based on a string .
private void finish nested mode ( ) throws sax { md = ( mode data ) mode data stack . pop ( ) ; }	notification that the mode element ends .
public void add property change listener ( final property change listener listener ) { property change support . add property change listener ( listener ) ; }	add the specified property change listener .
protected int skip whitespace ( int c ) throws io { while ( c == str || c == str ) { c = reader . read ( ) ; } return c ; }	reads characters from reader until it finds a character that is not a space or tab , and returns this last character.
public builder no cache ( ) { this . no cache = bool ; return this ; }	don ' t accept an unvalidated cached response .
@ suppress warnings ( str ) public void compute closest points ( ) { float center x = content rect . center x ( ) ; float closest distance = float . max value ; for ( int i = num ; i < points count within x * num ; i += num ) { float x = get draw x ( x range points [ i ] ) ; float distance = math . abs ( x - center x ) ; if ( distance <= closest distance ) { if ( distance == closest distance ) { closest points count ++ ; } else { closest points count = num ; } closest distance = distance ; if ( closest points buffer . length < ( closest points count * num + num ) ) { closest points buffer = new float [ closest points buffer . length * num ] ; } closest points buffer [ closest points count * num + num ] = x range points [ i ] ; closest points buffer [ closest points count * num + num ] = x range points [ i + num ] ; } } if ( points count within x > num ) { closest points count ++ ; } }	compute closest to central line points . several points will be written to array only if they have same x values.
protected transformed string stem ( string words ) { string builder builder = new string builder ( ) ; map < integer , integer > index map = new hash map < > ( ) ; integer index = num ; string content = words . to lower case ( ) ; while ( ! content . is empty ( ) ) { index map . put ( builder . length ( ) , index ) ; if ( character . is alphabetic ( content . char at ( num ) ) ) { matcher m = word pattern . matcher ( content ) ; m . find ( ) ; string match = m . group ( ) ; char sequence stemmed match = stemmer . stem ( match ) ; builder . append ( stemmed match ) ; index += match . length ( ) ; content = content . substring ( match . length ( ) ) ; } else { builder . append ( content . substring ( num , num ) ) ; content = content . substring ( num ) ; index ++ ; } } index map . put ( builder . length ( ) , index ) ; return new transformed string ( words , builder . to string ( ) , index map ) ; }	convert a word , or words , into their stemmed form and return it along with a mapping between the original and transformed strings.
void clear ( ) { value numbers unconditionally dereferenced . clear ( ) ; deref location set map . clear ( ) ; }	clear the deref set.
public string [ ] list ( ) throws remote exception { string [ ] names ; synchronized ( bindings ) { int i = bindings . size ( ) ; names = new string [ i ] ; enumeration < string > enum = bindings . keys ( ) ; while ( ( -- i ) >= num ) names [ i ] = enum . next element ( ) ; } return names ; }	returns an enumeration of the names in the registry .
public static void assert q ( string message , solr query request req , int code ) { try { ignore exception ( str ) ; h . query ( req ) ; fail ( message ) ; } catch ( solr exception sex ) { assert equals ( code , sex . code ( ) ) ; } catch ( exception e2 ) { throw new runtime exception ( str , e2 ) ; } finally { un ignore exception ( str ) ; } }	makes sure a query throws a solrexception with the listed response code.
public static void copy file ( string from file , string to file ) throws io { copy file ( new file ( from file ) , new file ( to file ) ) ; }	helper method to copy file to a new location.
@ edu . umd . cs . findbugs . annotations . fb ( value = str , justification = str ) public void change loco speed ( dcc throttle t , section sec , float speed ) { if ( sec == referenced && speed == desired speed step ) { if ( log . is debug enabled ( ) ) { log . debug ( str ) ; } return ; } float section length = sec . get actual length ( ) ; if ( log . is debug enabled ( ) ) { log . debug ( str + sec . get display name ( ) ) ; } if ( sec == referenced ) { distance remaining = distance remaining - get distance travelled ( throttle . get is forward ( ) , throttle . get speed setting ( ) , ( ( float ) ( system . nano time ( ) - last time timer started ) / num ) ) ; section length = distance remaining ; } else { referenced = sec ; } change loco speed ( t , section length , speed ) ; }	set speed of a throttle to a speeed set by a float , using the section for the length details.
private void draw offsets ( final graphics g ) { final int lines to draw = get number of visible rows ( ) ; final string format string = m address mode == address mode . bi ? str : str ; final long element size = get element size ( ) ; final long base address = m model . get start address ( ) == - num ? num : m model . get start address ( ) ; for ( int i = num ; i < lines to draw ; i ++ ) { final int element index = m first row + i ; final long element address = base address + ( element index * element size ) ; final string offset string = string . format ( format string , element address ) ; if ( element address == m model . get stack pointer ( ) ) { highlight stack pointer ( g , i ) ; } if ( is enabled ( ) ) { g . set color ( m font color offsets ) ; } else { g . set color ( m disabled color != m bg color offset ? m disabled color : color . white ) ; } g . draw string ( offset string , padding left - ( m char width * m first column ) , m padding top + ( i * m row height ) ) ; } }	draws the offsets in the offset view .
public static boolean prefixed with ( string a , string b ) { if ( a . equals ( b ) ) { return bool ; } return a . starts with ( b ) ; }	return true of both a and b are non - null , and b is a prefix ( but not equal to ) a .
public static string read stream ( input stream input stream ) throws io { if ( input stream == null ) { return null ; } byte array output stream bout = new byte array output stream ( ) ; byte [ ] buf = new byte [ num ] ; int r ; while ( ( r = input stream . read ( buf ) ) != - num ) { bout . write ( buf , num , r ) ; } return bout . to string ( str ) ; }	reads bytes from input stream and builds a string from them .
private instances make header ( ) { array list < attribute > fv = new array list < attribute > ( ) ; fv . add ( new attribute ( str ) ) ; fv . add ( new attribute ( str ) ) ; fv . add ( new attribute ( str ) ) ; return new instances ( str , fv , num ) ; }	creates an instances object with the attributes we will be calculating .
private static i < i > iterator ( final i running query ) { final i < i [ ] > it1 = running query . iterator ( ) ; final i < i > it2 = new dechunkerator < i > ( it1 ) ; final i < i > it3 = new running query closeable iterator < i > ( running query , it2 ) ; return it3 ; }	dechunkify the running query and monitor the sesame iterator .
public final double do operation ( ) throws operator failed exception { final int dim = parameter . get dimension ( ) ; final int dim1 = math utils . next int ( dim ) ; int dim2 = dim1 ; while ( dim1 == dim2 ) { dim2 = math utils . next int ( dim ) ; } double scalar1 = parameter . get parameter value ( dim1 ) ; double scalar2 = parameter . get parameter value ( dim2 ) ; final double d = math utils . next double ( ) * delta * scalar1 ; scalar1 -= d ; if ( parameter weights [ dim1 ] != parameter weights [ dim2 ] ) { scalar2 += d * ( double ) parameter weights [ dim1 ] / ( double ) parameter weights [ dim2 ] ; } else { scalar2 += d ; } parameter . set parameter value ( dim1 , scalar1 ) ; parameter . set parameter value ( dim2 , scalar2 ) ; return math . log ( scalar2 / ( scalar1 + d ) ) ; }	change the parameter and return the hastings ratio.
@ override public final boolean is open ( ) { return is open . get ( ) ; }	returns true if this selector is open .
private static stream tokenizer create tokenizer ( string s ) { stream tokenizer st = new stream tokenizer ( new string reader ( s ) ) ; st . reset syntax ( ) ; st . word chars ( str , str ) ; st . word chars ( str , str ) ; st . word chars ( str , str ) ; st . word chars ( str , str ) ; st . word chars ( str , str ) ; st . word chars ( str , str ) ; st . word chars ( num + num , num ) ; st . whitespace chars ( num , str ) ; st . lower case mode ( bool ) ; st . ordinary char ( str ) ; st . slash slash comments ( bool ) ; st . slash star comments ( bool ) ; return st ; }	returns tokenizer for parsing given string.
public static string remove chars ( string str , string oldchars ) { int pos = index of chars ( str , oldchars ) ; if ( pos == - num ) { return str ; } string builder buf = new string builder ( ) ; int start = num ; do { buf . append ( str . substring ( start , pos ) ) ; start = pos + num ; pos = index of chars ( str , oldchars , start ) ; } while ( pos != - num ) ; if ( start < str . length ( ) ) { buf . append ( str . substring ( start ) ) ; } return buf . to string ( ) ; }	remove any occurrances of ' oldchars ' in ' str ' . example : removechars ( " hello , world ! " , " , ! " ) returns " hello world ".
private void sort units to move ( final list < unit > units , final route route ) { if ( units == null || units . is empty ( ) ) { return ; } else if ( route == null ) { final exception null route error = ( new illegal argument exception ( str ) ) ; client logger . log quietly ( str , null route error ) ; } final comparator < unit > unit comparator ; if ( route . is unload ( ) && match . some match ( units , matches . unit is land ) ) { unit comparator = unit comparator . get unloadable units comparator ( units , route , get unit owner ( units ) ) ; } else { unit comparator = unit comparator . get movable units comparator ( units , route ) ; } collections . sort ( units , unit comparator ) ; }	sort the specified units in preferred movement or unload order .
public road ( int id , string name , intersection from , intersection to , road class road class , road layer road layer ) { this . id = id ; this . name = name ; this . road layer = road layer ; points = new waypoint [ num ] ; set intersections ( from , to ) ; this . road class = road class ; create lines ( ) ; modified = bool ; }	create a road between two intersections.
@ override public void process ( watched event event ) { keeper state event state = event . get state ( ) ; event type event type = event . get type ( ) ; log . info ( str , event state , event type ) ; if ( event state == keeper state . sync connected ) { connected signal . count down ( ) ; log . info ( str , connection string ) ; } }	interface method , do things after receiving event from server watcher.
private void init properties ( string file properties name ) { read from class path ( file properties name ) ; path cur dir path = get file in current dir ( file properties name ) ; if ( files . exists ( cur dir path ) ) { try ( input stream cur folder = files . new input stream ( cur dir path ) ) { if ( cur folder != null ) { load ( cur folder ) ; } } catch ( exception e ) { throw new runtime exception ( str + file properties name , e ) ; } } }	first loads properties file from class path after that from current folder.
private void reset bounds ( ) { bottom protein id = null ; top protein id = null ; }	helper method that sets the upper and lower bounds to null .
private string property ( string class id , string key , string instance id ) { return prefix ovf prop + make property key ( class id , key , instance id ) ; }	produces a string usable as key in customproperties.
public string list ( string dir ) throws io { passive ( ) ; send ( str + dir ) ; read code ( num ) ; byte array output stream out = new byte array output stream ( ) ; io . copy and close ( in data , out ) ; read code ( num ) ; byte [ ] data = out . to byte array ( ) ; return new string ( data ) ; }	get the directory listing ( list ) .
public static int convert px to sp ( int px size ) { return math . round ( ( float ) px size * get display density4 fonts ( ) ) ; }	convert absolute pixels to scale dependent pixels . this scales the size by scale dependent screen density ( accessibility setting ) and the global display setting for message composition fields.
private void persist consistency groups ( collection < block consistency group > cgs to persist ) { if ( null != cgs to persist && ! cgs to persist . is empty ( ) ) { list < block consistency group > cgs to create = new array list < block consistency group > ( ) ; list < block consistency group > cgs to update = new array list < block consistency group > ( ) ; for ( block consistency group cg : cgs to persist ) { if ( null == cg . get creation time ( ) ) { cgs to create . add ( cg ) ; } else { cgs to update . add ( cg ) ; } } if ( ! cgs to create . is empty ( ) ) { db client . create object ( cgs to create ) ; } if ( ! cgs to update . is empty ( ) ) { db client . update object ( cgs to update ) ; } } }	persist the consistencygroups in db .
public void request password changed time ( ) { operations . add ( password policy state operation type . get password changed time ) ; }	returns the password changed time .
public static byte [ ] encode region name ( string region name ) { byte [ ] metadata ; try { json json object = new json ( ) ; json object . put ( json field tag , region name ) ; string json = json object . to string ( ) ; metadata = json . get bytes ( json charset ) ; } catch ( exception e ) { log . e ( tag , str + e . get message ( ) ) ; metadata = null ; } return metadata ; }	build the metadata array byte.
public boolean is valid ( ) { boolean valid = bool ; if ( endtime . get time ( ) < system . current time millis ( ) ) { valid = bool ; } else if ( starttime != null ) { if ( starttime . get time ( ) > system . current time millis ( ) ) { valid = bool ; } } else { if ( authtime . get time ( ) > system . current time millis ( ) ) { valid = bool ; } } return valid ; }	checks if this credential is expired.
public void test get elements by tag name n ( ) throws throwable { document doc ; document new doc ; document type doc type = null ; dom dom impl ; node list child list ; string null ns = null ; doc = ( document ) load ( str , builder ) ; dom impl = doc . get implementation ( ) ; new doc = dom impl . create document ( null ns , str , doc type ) ; child list = new doc . get elements by tag name ns ( str , str ) ; assert equals ( str , num , child list . get length ( ) ) ; }	runs the test case .
public static boolean add separator if needed ( j popup menu ) { final int menu component count = popup menu . get component count ( ) ; if ( menu component count == num ) { return bool ; } final component last menu component = popup menu . get component ( menu component count - num ) ; if ( is popup menu separator ( last menu component ) ) { return bool ; } popup menu . add separator ( ) ; return bool ; }	appends a separator to the end of the menu if it exists at least one non separator menu component immediately before and if there isn ' t , already , a separator at the end of the menu .
public int group size ( string grp name ) { int res = num ; for ( hadoop counter counter : cntrs . values ( ) ) { if ( grp name . equals ( counter . group ( ) ) ) res ++ ; } return res ; }	returns size of a group .
public resource bundle enumeration ( set < string > set , enumeration < string > enumeration ) { this . set = set ; this . iterator = set . iterator ( ) ; this . enumeration = enumeration ; }	constructs a resource bundle enumeration .
public static int to rgb ( color space color space , float ... components ) { float [ ] rgb = color space . to rgb ( components ) ; if ( rgb [ num ] < num || rgb [ num ] < num || rgb [ num ] < num || rgb [ num ] > num || rgb [ num ] > num || rgb [ num ] > num ) { return num ; } return num | ( ( int ) ( rgb [ num ] * num ) << num ) | ( ( int ) ( rgb [ num ] * num ) << num ) | ( int ) ( rgb [ num ] * num ) ; }	returns an rgb value from color components in the specified color space .
private static void skip names ( byte buffer table buffer , int count ) { for ( int i = num ; i < count ; ++ i ) { byte util . forward ( table buffer , table buffer . get short ( ) ) ; } }	skips the given number of names in the table buffer .
private log source ( ) { }	don ' t allow others to create instances.
public object2 int open hash map < int [ ] > support map ( ) { list < item set > item sets = learn ( ) ; object2 int open hash map < int [ ] > confidence map = new object2 int open hash map < > ( item sets . size ( ) ) ; for ( item set item set : item sets ) { confidence map . put ( item set . items , item set . support ) ; } return confidence map ; }	returns a map of discovered itemsets and their support , where the support is the number of times the combination appears in the input data.
public static list < string > make feature id list from prefixed ( map < string , object > parameters ) { list < string > feature id list = fast list . new instance ( ) ; if ( parameters == null ) return feature id list ; for ( map . entry < string , object > entry : parameters . entry set ( ) ) { string parameter name = entry . get key ( ) ; if ( parameter name . starts with ( str ) ) { string product feature id = ( string ) entry . get value ( ) ; if ( util validate . is not empty ( product feature id ) ) { feature id list . add ( product feature id ) ; } } } return feature id list ; }	handles parameters coming in prefixed with " search_feat " where the parameter value is a productfeatureid ; meant to be used with text entry boxes or check - boxes and such.
private void update overscroll animation ( final int scrolled offset ) { if ( m edge glow left == null || m edge glow right == null ) return ; int next scroll position = m current x + scrolled offset ; if ( m fling tracker == null || m fling tracker . is finished ( ) ) { if ( next scroll position < num ) { int overscroll = math . abs ( scrolled offset ) ; m edge glow left . on pull ( ( float ) overscroll / get render width ( ) ) ; if ( ! m edge glow right . is finished ( ) ) { m edge glow right . on release ( ) ; } } else if ( next scroll position > m max x ) { int overscroll = math . abs ( scrolled offset ) ; m edge glow right . on pull ( ( float ) overscroll / get render width ( ) ) ; if ( ! m edge glow left . is finished ( ) ) { m edge glow left . on release ( ) ; } } } }	updates the over scroll animation based on the scrolled offset .
public void validate ( ) { final list < validation exception > exception list = new array list < validation exception > ( ) ; validate ( exception list ) ; if ( ! exception list . is empty ( ) ) throw exception list . get ( num ) ; }	validates this sootclass for logical errors.
protected void install components ( ) { if ( ( renderer pane = create cell renderer pane ( ) ) != null ) { tree . add ( renderer pane ) ; } }	intalls the subcomponents of the tree , which is the renderer pane .
public c ( final j parent , final i trace provider , final trace list trace1 , final trace list trace2 ) { super ( string . format ( str , trace1 . get name ( ) , trace2 . get name ( ) ) ) ; m parent = parent ; m trace provider = trace provider ; m trace1 = trace1 ; m trace2 = trace2 ; }	creates a new action object .
public static void copy file ( file from file , file to file ) throws io { file input stream file input stream = new file input stream ( from file ) ; file output stream file output stream = new file output stream ( to file ) ; int i ; byte bytes [ ] = new byte [ num ] ; while ( ( i = file input stream . read ( bytes ) ) != - num ) { file output stream . write ( bytes , num , i ) ; } file input stream . close ( ) ; file output stream . close ( ) ; }	helper method to copy file to a new location.
public final void update time control title ( ) { int [ ] tmp info = ctrl . get time limit ( ) ; string builder sb = new string builder ( ) ; int tc = tmp info [ num ] ; int mps = tmp info [ num ] ; int inc = tmp info [ num ] ; if ( mps > num ) { sb . append ( mps ) ; sb . append ( str ) ; } sb . append ( time to string ( tc ) ) ; if ( ( inc > num ) || ( mps <= num ) ) { sb . append ( str ) ; sb . append ( tmp info [ num ] / num ) ; } summary title text . set text ( sb . to string ( ) ) ; }	update center field in second header line .
@ after public void after ( ) throws sql { connection connection = null ; statement statement = null ; try { connection = get new connection ( bool ) ; statement = connection . create statement ( ) ; statement . execute query ( str ) ; } finally { if ( statement != null ) { statement . close ( ) ; } if ( connection != null ) { connection . close ( ) ; } } }	takes down the table created solely for these tests .
@ action ( value = str ) public string list workflow ( ) { if ( wf action != null && wf action . equals ( collection constants . wf action approve ) ) fetch receipts ( collection constants . wf action approve ) ; else fetch receipts ( collection constants . wf action submit ) ; return index ; }	action that will be called from the workflow inbox . the inbox also passes the id of the clicked item which is of the form : < next - workflow - action > - servicecode - userid - counterid.
public static final list < geo > poly near poly ( geo array s , geo array r , double near ) { int rlen = r . get size ( ) ; int slen = s . get size ( ) ; geo pl0 = r . get ( rlen - num ) ; geo pl1 = new geo ( ) ; geo sl0 = s . get ( slen - num ) ; geo sl1 = new geo ( ) ; list < geo > list = null ; for ( int j = num ; j < rlen ; j ++ ) { pl1 = r . get ( j , pl1 ) ; for ( int i = num ; i < slen ; i ++ ) { sl1 = s . get ( i , sl1 ) ; geo ret = segments intersect or near ( sl0 , sl1 , pl0 , pl1 , near ) ; if ( ret != null ) { if ( list == null ) { list = new linked list < geo > ( ) ; } list . add ( ret ) ; } sl0 = sl1 ; } pl0 = pl1 ; } return list ; }	is one region ' s boundary within ' near ' range of a region ? note : good practice is s describes a smaller area than r .
public void init param ( object obj ) { param object = obj ; enumeration < abstract param panel > en = table panel . elements ( ) ; abstract param panel panel = null ; while ( en . has more elements ( ) ) { panel = en . next element ( ) ; panel . init param ( obj ) ; } }	initialises all panels with the given object .
public void update topic ( string topic , db context rule rule ) { topic = string utils . to lower english ( topic ) ; rule head head = rule map . get ( topic ) ; if ( head == null ) { head = new rule head ( str , topic , rule ) ; rule map . put ( topic , head ) ; statements . add ( head ) ; } else { head . set rule ( rule ) ; } }	update a topic with a context specific rule.
public static double log10 ( double x ) { return math . log ( x ) / lo ; }	the base 10 logarithm of the input value.
public static int is button on screen ( final string button key ) { component on screen ; try { on screen = bubble window . find button ( button key , gui . get main frame ( ) ) ; } catch ( null pointer exception e ) { return object not on screen ; } if ( on screen == null ) { return object not on screen ; } int xposition = on screen . get location on screen ( ) . x ; int yposition = on screen . get location on screen ( ) . y ; int other xposition = xposition + on screen . get width ( ) ; int other yposition = yposition + on screen . get height ( ) ; window frame = gui . get main frame ( ) ; if ( other xposition <= frame . get width ( ) && other yposition <= frame . get height ( ) && xposition > num && yposition > num ) { return object showing on screen ; } else { return object not showing ; } }	method to get to know whether the abstractbutton with the given key is on screen.
public static boolean reachable ( inet address addr , int reach timeout ) { try { return addr . is reachable ( reach timeout ) ; } catch ( io ignore ) { return bool ; } }	checks if address can be reached using one argument inetaddress.
protected static string timestr ( long time val , long total time ) { boolean neg ; long ms = num ; long sec = num ; long percent10 ; string pad ; neg = time val < num ; if ( neg ) time val = - time val ; ms = time val % num ; sec = time val / num ; if ( sec < num ) pad = str ; else if ( sec < num ) pad = str ; else if ( sec < num ) pad = str ; else pad = str ; percent10 = ( time val * num ) / total time ; return ( neg ? str : str ) + pad + sec + str + ( ( ms % num ) / num ) + ( ( ms % num ) / num ) + ( ms % num ) + str + str + percent10 / num + str + percent10 % num + str ; }	helper routine to format a decimal based display of seconds and percentage of total time given counts of milliseconds.
public static tree rotate by name ( tree tree ) { return new simple tree ( rotate node by name ( tree , tree . get root ( ) ) ) ; }	recursive function for constructing a newick tree representation in the given buffer .
@ subscribe public void on event ( search in position event ) { list < lat lng > list = map helper . get search area ( event . get steps ( ) , new lat lng ( event . get position ( ) . latitude , event . get position ( ) . longitude ) ) ; snack me ( get string ( r . string . toast searching ) ) ; niantic manager . get gyms ( event . get position ( ) . latitude , event . get position ( ) . longitude , num ) ; niantic manager . get poke stops ( event . get position ( ) . latitude , event . get position ( ) . longitude , num ) ; niantic manager . get lured pokemon ( event . get position ( ) . latitude , event . get position ( ) . longitude , num ) ; for ( lat lng p : list ) { niantic manager . get catchable pokemon ( p . latitude , p . longitude , num ) ; } }	called whenever a use whats to search pokemons on a different position.
public void save ( on save log listener listener ) { file dir = get log dir ( ) ; if ( dir == null ) { listener . on error ( str + str ) ; return ; } file writer file writer = null ; try { file output = new file ( dir , get log file name ( ) ) ; file writer = new file writer ( output , bool ) ; list < log entry > entries = buffered logs ( ) ; for ( log entry entry : entries ) { file writer . write ( entry . pretty print ( ) + str ) ; } listener . on save ( output ) ; } catch ( io e ) { listener . on error ( e . get message ( ) ) ; e . print stack trace ( ) ; } finally { if ( file writer != null ) { try { file writer . close ( ) ; } catch ( io e ) { listener . on error ( e . get message ( ) ) ; e . print stack trace ( ) ; } } } }	save the current logs to disk .
protected ha check adapter exists in db ( string native guid ) throws io { ha adapter = null ; list < ha > adapter in db = custom query utility . get active storage ha ( db client , native guid ) ; if ( adapter in db != null && ! adapter in db . is empty ( ) ) { adapter = adapter in db . get ( num ) ; } return adapter ; }	check if adapter exists in db .
protected coordinate [ ] to coordinate array ( stack stack ) { coordinate [ ] coordinates = new coordinate [ stack . size ( ) ] ; for ( int i = num ; i < stack . size ( ) ; i ++ ) { coordinate coordinate = ( coordinate ) stack . get ( i ) ; coordinates [ i ] = coordinate ; } return coordinates ; }	an alternative to stack.
private void prepare user for ranking ( user user ) { user updated user = user repository . find one ( user . get id ( ) , num ) ; if ( updated user . get imported ( ) == null || ! updated user . get imported ( ) ) { updated user . set imported ( bool ) ; updated user . set pagerank ( null ) ; updated user . set last page rank ( null ) ; updated user . set current rank ( null ) ; updated user . set previous rank ( null ) ; user repository . save ( updated user , num ) ; } }	prepares a user to be ranked for the first time after having follower data imported , resetting the previous pageranks and preparing for a new calculation and ranking .
private static list < comment > order comments ( list < comment > comments ) { map < string , list < comment > > parent map = new hash map < > ( ) ; list < comment > root comments = new array list < > ( ) ; for ( comment c : comments ) { string parent uuid = c . parent uuid ; list < comment > l = parent map . get ( parent uuid ) ; if ( l == null ) { l = new array list < > ( ) ; parent map . put ( parent uuid , l ) ; } l . add ( c ) ; if ( parent uuid == null ) { root comments . add ( c ) ; } } list < comment > result = new array list < > ( ) ; add children ( parent map , root comments , result ) ; return result ; }	order the comments based on their parent_uuid parent.
protected static final void log raw diagnostic ( string msg ) { if ( diagnostics stream != null ) { diagnostics stream . println ( msg ) ; diagnostics stream . flush ( ) ; } }	write the specified message to the internal logging destination .
public void initialize ( subject subject , callback handler callback handler , map < string , ? > shared state , map < string , ? > options ) { unauthenticated identity = ( string ) options . get ( str ) ; handler = callback handler ; this . subject = subject ; }	initialize the login module , get options from configuration.
public boolean contains ( symbol sym ) { return all . contains key ( sym . name ( ) ) ; }	determine if the set contains a particular symbol .
private pie data generate data pie ( int cnt ) { array list < entry > entries = new array list < entry > ( ) ; for ( int i = num ; i < num ; i ++ ) { entries . add ( new entry ( ( int ) ( math . random ( ) * num ) + num , i ) ) ; } pie data set d = new pie data set ( entries , str ) ; d . set slice space ( num ) ; d . set colors ( color template . vordiplom colors ) ; pie data cd = new pie data ( get quarters ( ) , d ) ; return cd ; }	generates a random chartdata object with just one dataset.
public void send user delete notification ( map attributes ) { try { if ( delete notify list != null && ! delete notify list . is empty ( ) ) { send email ( delete notify list , attributes , str , str , str ) ; } } catch ( messaging exception e ) { if ( debug . warning enabled ( ) ) { debug . warning ( str + str + str + entry dn , e ) ; } } }	the proper setuser < > notificationlist method should be called before calling this method .
public void add maps id mapping ( database mapping mapping ) { maps id mappings . add ( mapping ) ; }	internal : in jpa users may specify a maps id mapping on a shared embeddable descriptor.
public int task size ( ) { return tasks . size ( ) ; }	number of tasks in this item .
public void add muted ip ( final string ip , final date mute till ) { if ( is ip muted ( ip ) ) { remove muted ip ( ip ) ; } timestamp mute till ts = null ; if ( mute till != null ) { mute till ts = new timestamp ( mute till . get time ( ) ) ; } s logger . fine ( str + ip ) ; final connection con = database . get connection ( ) ; try { final prepared statement ps = con . prepare statement ( str ) ; ps . set string ( num , ip ) ; ps . set timestamp ( num , mute till ts ) ; ps . execute ( ) ; ps . close ( ) ; con . commit ( ) ; } catch ( final sql sqle ) { if ( sqle . get error code ( ) == num ) { s logger . info ( str + ip + str + sqle . get message ( ) ) ; return ; } s logger . log ( level . severe , str + ip , sqle ) ; throw new illegal state exception ( sqle . get message ( ) ) ; } finally { db util . close connection ( con ) ; } }	mute the given ip.
public boolean is rsl url signed ( string url ) { if ( url == null ) { return bool ; } return url . ends with ( signed rsl url dot extension ) ; }	test is the url is signed .
public void remove user lockout entry ( string user dn ) { pw reset fail hash . remove ( user dn ) ; user warning count = num ; }	removes the user dn from the fail map entry .
public void create database entities for business object data search testing ( ) { business object data dao test helper . create business object data entity ( abstract service test . namespace , abstract service test . bdef name , abstract service test . format usage code , abstract service test . format file type code , abstract service test . format version , abstract service test . partition value , abstract service test . no subpartition values , abstract service test . data version , abstract service test . latest version flag set , business object data status entity . valid ) ; business object data dao test helper . create business object data entity ( abstract service test . namespace , abstract service test . bdef name , abstract service test . format usage code 2 , abstract service test . format file type code , abstract service test . format version , abstract service test . partition value , abstract service test . no subpartition values , abstract service test . data version , abstract service test . latest version flag set , business object data status entity . invalid ) ; business object data dao test helper . create business object data entity ( abstract service test . namespace 2 , abstract service test . bdef name 2 , abstract service test . format usage code 2 , abstract service test . format file type code , abstract service test . format version 2 , abstract service test . partition value , abstract service test . no subpartition values , abstract service test . data version , abstract service test . latest version flag set , business object data status entity . invalid ) ; business object data dao test helper . create business object data entity ( abstract service test . namespace 2 , abstract service test . bdef name 2 , abstract service test . format usage code 2 , abstract service test . format file type code 2 , abstract service test . format version 2 , abstract service test . partition value , abstract service test . no subpartition values , abstract service test . data version , abstract service test . latest version flag set , business object data status entity . valid ) ; }	creates database entities for business object data search testing .
@ skip validation @ action ( value = str ) public string reset ( ) { if ( logger . is debug enabled ( ) ) logger . debug ( str + owner name + str + zone id + str + ward id + str + property type + str + notice type + str + notice number + str + notice from date + str + notice to date + str + index number + str + house number ) ; owner name = str ; zone id = - num ; ward id = - num ; property type = str ; notice type = str ; notice number = str ; notice from date = null ; notice to date = null ; index number = str ; house number = str ; if ( logger . is debug enabled ( ) ) logger . debug ( str ) ; return index ; }	reset all the values.
public void check options valid ( ) { if ( alias ratio < num || alias ratio > num ) { throw new runtime exception ( str ) ; } if ( null ratio < num || null ratio > num ) { throw new runtime exception ( str ) ; } if ( maxsize <= num ) { throw new runtime exception ( str + maxsize ) ; } if ( ! literals file . is empty ( ) && literals level == class literals mode . none ) { throw new runtime exception ( str ) ; } }	check that the options given satisfy any specified constraints , and fail if they do not .
@ override public uuid session id ( ) { if ( session id == null ) session id = uuid . random uuid ( ) ; return session id ; }	used to uniquely identify the session.
private void read object ( final object input stream in ) throws io , class not found exception { in . default read object ( ) ; final calendar defining calendar = calendar . get instance ( time zone , locale ) ; init ( defining calendar ) ; }	create the object after serialization.
@ override public mem chunk holder < p > create chunk ( long size , boolean autoreclaim ) { mem chunk holder < p > ret = null ; long addr = m nvmasvc . allocate ( m nid , size , bool ) ; if ( ( null == addr || num == addr ) && m activegc ) { force gc ( ) ; addr = m nvmasvc . allocate ( m nid , size , bool ) ; } if ( null != addr && num != addr ) { ret = new mem chunk holder < p > ( this , addr , size ) ; ret . set collector ( m chunkcollector ) ; if ( autoreclaim ) { m chunkcollector . register ( ret ) ; } } return ret ; }	create a memory chunk that is managed by its holder .
public int hash code ( ) { int result = num ; if ( table name != null ) { result = num * table name . hash code ( ) ; } if ( repository name != null ) { result = num * repository name . hash code ( ) ; } return result ; }	provide a hash code that is consistent with equals for this class.
private void to string ( string builder acc , int prec , boolean expand ) { if ( this . meta != null && ! expand ) { acc . append ( this . meta ) ; return ; } boolean paren = op . get prec ( ) < prec ; if ( paren ) acc . append ( str ) ; to string ( acc , expand ) ; if ( paren ) acc . append ( str ) ; }	this handles adding parens , as necessary .
public static boolean is not null value ( string s ) { return ( ( s != null ) && ! s . is empty ( ) && ! s . equals ( null column value getter . get null str ( ) ) ) ; }	checks to see if a string value is null .
public static string remove all ( string source , char to remove ) { int to remove index = source . index of ( to remove ) ; if ( to remove index != - num ) { string builder result = new string builder ( source . length ( ) ) ; int source index = num ; while ( to remove index != - num ) { result . append ( source . substring ( source index , to remove index ) ) ; source index = to remove index + num ; to remove index = source . index of ( to remove , source index ) ; if ( to remove index == - num ) { result . append ( source . substring ( source index , source . length ( ) ) ) ; } } return result . to string ( ) ; } else { return source ; } }	a fast utility method that does ' nt use regex and removes all of toremove from source .
public list < entry < e > > as list ( ) { if ( non null list == null ) { if ( array == null || array . length ( ) == num ) { non null list = collections . empty list ( ) ; } else { list < entry < e > > list = new array list < > ( array . length ( ) ) ; for ( int i = num ; i < array . length ( ) ; i ++ ) { e e = array . get ( i ) ; if ( e != null ) { list . add ( new entry < > ( i , e ) ) ; } } non null list = list ; } } return non null list ; }	returns the it as a non null list , with an entry wrapping each value allowing to retain its index .
public static range find cumulative range bounds ( category dataset dataset ) { param checks . null not permitted ( dataset , str ) ; boolean all items null = bool ; double minimum = num ; double maximum = num ; for ( int row = num ; row < dataset . get row count ( ) ; row ++ ) { double running total = num ; for ( int column = num ; column <= dataset . get column count ( ) - num ; column ++ ) { number n = dataset . get value ( row , column ) ; if ( n != null ) { all items null = bool ; double value = n . double value ( ) ; if ( ! double . is na n ( value ) ) { running total = running total + value ; minimum = math . min ( minimum , running total ) ; maximum = math . max ( maximum , running total ) ; } } } } if ( ! all items null ) { return new range ( minimum , maximum ) ; } else { return null ; } }	calculates the range of values for a dataset where each item is the running total of the items for the current series .
private void add hotkeys ( j pane ) { for ( hotkey hotkey : hotkeys ) { if ( does hotkey have action ( hotkey ) && hotkey . type == type . regular ) { if ( pane == null ) { add hotkey ( hotkey , main . get root pane ( ) ) ; for ( j popout : popouts . key set ( ) ) { add hotkey ( hotkey , popout . get root pane ( ) ) ; } } else { add hotkey ( hotkey , pane ) ; } } } }	adds all regular hotkeys to the given jrootpane , or to all ( main and popouts ) if the pane is null .
static < t > replay promise < void > all replay ( final duration timeout , final list < promise < t > > promises ) { return all replay ( timeout , system . current time millis ( ) , promises . to array ( new promise [ promises . size ( ) ] ) ) ; }	all promises must complete .
public void check and setup boot strap info ( db client db client ) { if ( on standby ) { log . info ( str ) ; return ; } if ( vdc list != null && vdc list . size ( ) > num ) { log . info ( str , vdc list . size ( ) ) ; return ; } int retry interval secs = dbinit retry interval ; boolean done = bool ; boolean wait ; while ( ! done ) { wait = bool ; inter process lock lock = null ; try { lock = coordinator . get lock ( get bootstrap lock name ( ) ) ; log . info ( str ) ; lock . acquire ( ) ; if ( is geo dbsvc ( ) ) { insert default root tenant ( db client ) ; } else { insert my vdc info ( db client ) ; insert vdc version ( db client ) ; insert password history ( db client ) ; } done = bool ; } catch ( exception e ) { if ( e instanceof illegal state exception ) { throw ( illegal state exception ) e ; } else { log . warn ( str , retry interval secs , e ) ; wait = bool ; } } finally { if ( lock != null ) { try { lock . release ( ) ; } catch ( exception e ) { log . error ( str , e ) ; } } } if ( wait ) { try { thread . sleep ( retry interval secs * num ) ; } catch ( interrupted exception ex ) { log . warn ( str , ex ) ; } } } }	init the bootstrap info , including : check and setup root tenant or my vdc info , if it doesn ' t exist.
object process expr ( stylesheet handler handler , string uri , string name , string raw name , string value , elem template element owner ) throws org . xml . sax . sax { try { x expr = handler . create x ( value , owner ) ; return expr ; } catch ( transformer exception te ) { throw new org . xml . sax . sax ( te ) ; } }	process an attribute string of type t_expr into an xpath value .
private void check access ( unix path file , boolean check read , boolean check write ) { security manager sm = system . get security manager ( ) ; if ( sm != null ) { if ( check read ) file . check read ( ) ; if ( check write ) file . check write ( ) ; sm . check permission ( new runtime permission ( str ) ) ; } }	permission checks to access file.
private static spanned remove image span objects ( spanned spanned ) { spannable string builder builder = ( spannable string builder ) spanned ; object [ ] spanned objects = builder . get spans ( num , builder . length ( ) , object . class ) ; for ( int i = num ; i < spanned objects . length ; i ++ ) { if ( spanned objects [ i ] instanceof image span ) { image span image span = ( image span ) spanned objects [ i ] ; builder . replace ( spanned . get span start ( image span ) , builder . get span end ( image span ) , str ) ; } } return spanned ; }	replaces all image objects in a spannable with nothing essentially removes them.
public future < string > classify ( string snippet ) { final executor service service = executors . new single thread executor ( ) ; return service . submit ( new classifying task ( snippet ) ) ; }	creates code snippet language classifying task .
public abstract byte [ ] embed data ( byte [ ] msg , string msg file name , byte [ ] cover , string cover file name , string stego file name ) throws open stego exception ;	method to embed the message into the cover data.
public void add setter ( int i ) { for ( scatter plot setter setter : setter list ) { if ( setter . get index ( ) == i ) { return ; } } setter list . add ( new scatter plot setter ( i ) ) ; }	add a setter with the specified index .
@ override public synchronized void initialize ( ) { if ( ! m root directory . exists ( ) ) { if ( ! m root directory . mkdirs ( ) ) { loger . debug ( string . format ( str , m root directory . get absolute path ( ) ) ) ; } return ; } file [ ] files = m root directory . list files ( ) ; if ( files == null ) { return ; } for ( file file : files ) { buffered input stream fis = null ; try { fis = new buffered input stream ( new file input stream ( file ) ) ; cache header entry = cache header . read header ( fis ) ; entry . size = file . length ( ) ; put entry ( entry . key , entry ) ; } catch ( io e ) { file . delete ( ) ; } finally { file utils . close io ( fis ) ; } } }	initializes the diskbasedcache by scanning for all files currently in the specified root directory.
public client ( final server socket channel server ) throws io { try { client = server . accept ( ) ; client . configure blocking ( bool ) ; if ( ! client . finish connect ( ) ) throw new io ( str ) ; client selector = selector . open ( ) ; client key = client . register ( client selector , selection key . op read ) ; if ( log . is info enabled ( ) ) log . info ( str ) ; } catch ( io ex ) { close ( ) ; throw ex ; } }	gets the client connection and open the channel in a non - blocking mode so we will read whatever is available and loop until all data has been read .
public transfer write bytes ( byte [ ] data ) throws io { if ( data == null ) { write int ( - num ) ; } else { write int ( data . length ) ; out . write ( data ) ; } return this ; }	write a byte array .
public static void stop ( string [ ] args ) { log . info ( str ) ; system . exit ( num ) ; }	stopping the service container .
public boolean add ( object o ) { if ( ! list . contains ( o ) ) { list . add ( o ) ; return bool ; } return bool ; }	adds the specified element to this set if it is not already present ( optional operation ) .
public static void log error ( throwable exception , string message , object ... args ) { message = message format . format ( message , args ) ; log ( i . error , i . ok , message , exception ) ; }	log the specified error .
public void add ( row r ) { list . add ( r ) ; memory += r . get memory ( ) + constants . memory pointer ; if ( max memory > num && memory > max memory ) { write all rows ( ) ; } size ++ ; }	add a row to the list .
private message list view render conversation ( conversation info conv info , view parent ) { message list view list = new message list view ( parent . get context ( ) ) ; conv info . view = list ; list . set on item click listener ( message click listener . get instance ( ) ) ; message list adapter adapter = conv info . adapter ; if ( adapter == null ) { adapter = new message list adapter ( conv info . conv , parent . get context ( ) ) ; conv info . adapter = adapter ; } list . set adapter ( adapter ) ; list . set selection ( adapter . get count ( ) - num ) ; return list ; }	render the given conversation and return the new view .
public static int define tag ( int ifd id , short tag id ) { return ( tag id & num ) | ( ifd id << num ) ; }	returns the constant representing a tag with a given tid and default ifd .
public application id verifier ( set < string > supported application ids ) { this . supported application ids = collections . unmodifiable set ( new hash set < string > ( supported application ids ) ) ; }	constructs a new application id verifier with the provided set of supported application ids.
public query response search ( resource resource , solr query query ) throws solr server exception , io { string id query = term query ( search fields . uri field name , search fields . get resource id ( resource ) ) ; query . set query ( query . get query ( ) + str + id query ) ; return search ( query ) ; }	evaluates the given query only for the given resource .
public static local date to date ( string data , string modelo ) { return local date . parse ( data , formatter ( modelo ) ) ; }	converte string em localdate indicando o formato.
public static final criterion all ( ) { return all criterion . all ( ) ; }	creates a filter matching all messages .
public static void transform ( input stream src stream , output stream dest stream , input stream stylesheet stream , string output format ) throws fop { stream source src = new stream source ( src stream ) ; stream source stylesheet = stylesheet stream == null ? null : new stream source ( stylesheet stream ) ; fop fop = create fop instance ( dest stream , output format ) ; transform ( src , stylesheet , fop ) ; }	transform an xsl - fo inputstream to the specified outputstream format .
public boolean insert sym ( int type , string id , string context , string c type , int line , int col ) { int i ; if ( type == procedurevar || type == processvar || type == parameter ) { i = find sym ( global , id , str ) ; if ( i < symtab . size ( ) ) return bool ; i = find sym ( id , context ) ; if ( i < symtab . size ( ) ) return bool ; } else { i = find sym ( type , id , context ) ; if ( i < symtab . size ( ) ) return bool ; } sym tab entry se = new sym tab entry ( type , id , context , c type , line , col ) ; symtab . add element ( se ) ; return bool ; }	true if inserted ; false if was already in table can not insert a variable of name x if there is a global with name x or another variable in the same context with name x . /.
public static schema schema for struct type ( struct type struct type ) { list < string > field names = lists . new array list ( ) ; list < string > field types = lists . new array list ( ) ; for ( struct field field : struct type . fields ( ) ) { field names . add ( field . name ( ) ) ; data type field type = field . data type ( ) ; if ( field type . equals ( data types . string type ) ) { field types . add ( str ) ; } else if ( field type . equals ( data types . float type ) ) { field types . add ( str ) ; } else if ( field type . equals ( data types . double type ) ) { field types . add ( str ) ; } else if ( field type . equals ( data types . integer type ) ) { field types . add ( str ) ; } else if ( field type . equals ( data types . long type ) ) { field types . add ( str ) ; } else if ( field type . equals ( data types . boolean type ) ) { field types . add ( str ) ; } else { throw new runtime exception ( str + field type ) ; } } return record utils . schema for ( field names , field types ) ; }	the equivalent avro schema for the given spark sql schema .
public jetty solr runner start jetty solr runner ( jetty solr runner jetty ) throws exception { jetty . start ( bool ) ; jettys . add ( jetty ) ; return jetty ; }	add a previously stopped node back to the cluster.
public map < cim , set < string > > find any slo ( storage system for provider , storage system storage , string policy name , boolean associated to view ) throws wbem { closeable iterator < cim > group instance itr = null ; closeable iterator < cim > volume path itr = null ; map < cim , set < string > > group paths = new concurrent hash map < cim , set < string > > ( ) ; try { cim controller config svc path = cim path . get controller config svc path ( storage ) ; log . info ( str ) ; group instance itr = get associator instances ( for provider , controller config svc path , null , se device masking group , null , null , ps storage group properties ) ; while ( group instance itr . has next ( ) ) { cim group instance = group instance itr . next ( ) ; cim group path = group instance . get object path ( ) ; string group name = cim . get property value ( group instance , cp element name ) ; string fast setting = cim . get property value ( group instance , cp fast setting ) ; string group associated to view = cim . get property value ( group instance , cp associated to view ) ; set < string > returned native guids = new hash set < string > ( ) ; if ( fast setting . equals ( policy name ) && associated to view == boolean . parse boolean ( group associated to view ) && group name . starts with ( constants . storage group prefix ) ) { log . debug ( str , group name ) ; volume path itr = get associator names ( for provider , group path , null , cim storage volume , null , null ) ; while ( volume path itr . has next ( ) ) { returned native guids . add ( get volume native guid ( volume path itr . next ( ) ) ) ; } group paths . put ( group path , returned native guids ) ; } } } finally { close cim ( group instance itr ) ; close cim ( volume path itr ) ; } return group paths ; }	this method is used for vmax3 storage system to find exiting storage group with a specified slo for parking volumes .
remover add ( t listener ) ;	registers a new listener .
public j ( j cl , string digest ) { class name = cl . get name ( ) ; string new digest = get digest ( ) ; if ( ! new digest . equals ( digest ) ) { if ( log . is loggable ( level . fine ) ) log . fine ( class name + str ) ; is digest modified = bool ; } }	create a new dependency with a given digest .
public void dump ( object data , writer output ) { list < object > list = new array list < object > ( num ) ; list . add ( data ) ; dump all ( list . iterator ( ) , output , null ) ; }	serialize a java object into a yaml stream .
public void clear ( ) { final reentrant lock lock = this . lock ; lock . lock ( ) ; try { object [ ] array = queue ; int n = size ; size = num ; for ( int i = num ; i < n ; i ++ ) array [ i ] = null ; } finally { lock . unlock ( ) ; } }	atomically removes all of the elements from this queue.
public void add insn to head ( insn insn ) { ssa insn new insn = ssa insn . make from rop ( insn , this ) ; insns . add ( get count phi insns ( ) , new insn ) ; parent . on insn added ( new insn ) ; }	adds an insn to the head of this basic block , just after any phi insns .
public static string encode for url ( string str ) { string buffer result = new string buffer ( ) ; for ( int i = num ; i < str . length ( ) ; i ++ ) { char ch = str . char at ( i ) ; if ( ch >= str && ch <= str || ch >= str && ch <= str || ch >= str && ch <= str ) result . append ( ch ) ; else { switch ( ch ) { case str : case str : case str : case str : case str : case str : case str : case str : case str : result . append ( ch ) ; break ; default : result . append ( str ) ; result . append ( hexchars [ ( ch & num ) > > num ] ) ; result . append ( hexchars [ ch & num ] ) ; break ; } } } return result . to string ( ) ; }	escapes special characters not suitable for urls with " % xx ".
public void select object ( multi touch object multi touch object , point info touch point ) { curr touch point . set ( touch point ) ; if ( multi touch object != null ) { m images . remove ( multi touch object ) ; m images . add ( multi touch object ) ; if ( listener != null ) { listener . on image object selected ( multi touch object ) ; } } else { if ( listener != null ) { listener . on image object dropped ( ) ; } } invalidate ( ) ; }	select an object for dragging.
void verify ( ) { byte [ ] d = digest . digest ( ) ; if ( ! message digest . is equal ( d , base64 . decode ( hash , base64 . default ) ) ) { throw invalid digest ( jar file . manifest name , name , jar name ) ; } verified entries . put ( name , certificates ) ; }	verifies that the digests stored in the manifest match the decrypted digests from the.
public void randomize incoming weights ( ) { for ( neuron n : get neuron list ( ) ) { for ( synapse s : n . get fan in ( ) ) { s . set lower bound ( num ) ; s . set strength ( s . get upper bound ( ) * math . random ( ) ) ; } } }	randomize all weights coming in to this network.
public void remove ( queue event event ) throws keeper exception , interrupted exception { timer context time = stats . time ( dir + str ) ; try { string path = event . get id ( ) ; string response path = dir + str + response prefix + path . substring ( path . last index of ( str ) + num ) ; if ( zookeeper . exists ( response path , bool ) ) { zookeeper . set data ( response path , event . get bytes ( ) , bool ) ; } else { log . info ( str + response path + str + str ) ; } try { zookeeper . delete ( path , - num , bool ) ; } catch ( keeper exception . no node exception ignored ) { } } finally { time . stop ( ) ; } }	remove the event and save the response into the other path .
public list < point > read points ( string shapefile ) { list < point > list = new array list < point > ( ) ; for ( simple feature feature : shape file reader . get all features ( shapefile ) ) { geometry geo = ( geometry ) feature . get default geometry ( ) ; if ( geo instanceof point ) { point ps = ( point ) geo ; for ( int i = num ; i < ps . get num geometries ( ) ; i ++ ) { point p = ( point ) ps . get geometry n ( i ) ; list . add ( p ) ; } } else { throw new runtime exception ( str ) ; } } return list ; }	reads a point feature shapefile .
public string rate ( properties ctx , int window no , grid tab m tab , grid field m field , object value ) { if ( value == null ) return str ; integer id = ( integer ) m tab . get value ( str ) ; int c id = id . int value ( ) ; integer id = ( integer ) m tab . get value ( str ) ; int c id = id . int value ( ) ; timestamp date acct = ( timestamp ) m tab . get value ( str ) ; if ( date acct == null ) date acct = new timestamp ( system . current time millis ( ) ) ; int c id = env . get context as int ( ctx , window no , str ) ; m as = m . get ( ctx , c id ) ; int ad id = env . get context as int ( ctx , window no , str ) ; int ad id = env . get context as int ( ctx , window no , str ) ; big decimal currency rate = m . get rate ( c id , as . get c id ( ) , date acct , c id , ad id , ad id ) ; log . fine ( str + currency rate ) ; if ( currency rate == null ) currency rate = env . zero ; m tab . set value ( str , currency rate ) ; return str ; }	journal / line - rate . set currencyrate from dateacct , c_conversiontype_id , c_currency_id.
public boolean has alpha changed from ( float v ) { return ( float . compare ( alpha , v ) != num ) ; }	convenience functions to compare against current property values.
public completable future < void > destroy ( ) { completable future < void > ret ; if ( controller proxy != null ) { ret = controller proxy . destroy ( ) ; controller proxy = null ; } else { ret = new completable future < > ( ) ; ret . complete ( null ) ; } return ret ; }	by calling this method the mvc group will be destroyed.
@ override public request < string > logs ( project reference project reference , long task id ) { list < dummy runner status > statuses = available runner statuses . get ( project reference . name ( ) ) ; if ( statuses != null && ! statuses . is empty ( ) ) { for ( dummy runner status runner status : statuses ) { if ( task id == runner status . process id ( ) ) { return new dummy request < > ( runner status . get log ( ) ) ; } } } return new dummy request < > ( null ) ; }	gets the logs of the builder with the given task id .
protected static action result info perform action ( generic value product promo action , shopping cart cart , delegator delegator , local dispatcher dispatcher , timestamp now timestamp ) throws generic entity exception , cart item modify exception { action result info action result info = new action result info ( ) ; perform action ( action result info , product promo action , cart , delegator , dispatcher , now timestamp ) ; return action result info ; }	returns true if the cart was changed and rules need to be re - evaluted.
private boolean contains expression ( string to search , string expression ) { if ( to search == null ) { return bool ; } return to search . equals ( expression ) || to search . index of ( expression ) >= num ; }	checks if the tosearch string contains the expression .
public void clear listeners ( ) { listeners . clear ( ) ; }	clears the list of listeners.
private var add property ( var property property ) { if ( property . is unique ( ) ) { test unique property ( ( unique var property ) property ) ; } properties . add ( property ) ; return this ; }	add a non - unique property.
public boolean is open ( ) { return open . get ( ) ; }	gets the status of the java process .
public void free ( long pos , int length ) { int start = get block ( pos ) ; int blocks = get block count ( length ) ; set . clear ( start , start + blocks ) ; }	mark the space as free .
private void on connection status changed ( int old status , int status ) { if ( s settings mgr . show status icon ) { notification compat . builder builder = new notification compat . builder ( this ) ; builder . set when ( system . current time millis ( ) ) ; switch ( status ) { case xmpp manager . connected : builder . set content text ( get string ( r . string . main service connected , get connection status action ( ) ) ) ; builder . set small icon ( get image status ( status icon green ) ) ; break ; case xmpp manager . connecting : builder . set content text ( get string ( r . string . main service connecting ) ) ; builder . set small icon ( get image status ( status icon orange ) ) ; break ; case xmpp manager . disconnected : builder . set content text ( get string ( r . string . main service disconnected ) ) ; builder . set small icon ( get image status ( status icon red ) ) ; break ; case xmpp manager . disconnecting : builder . set content text ( get string ( r . string . main service disconnecting ) ) ; builder . set small icon ( get image status ( status icon orange ) ) ; break ; case xmpp manager . waiting to connect : case xmpp manager . waiting for network : builder . set content text ( get string ( r . string . main service waiting to connect ) + str + get connection status action ( ) ) ; builder . set small icon ( get image status ( status icon blue ) ) ; break ; default : return ; } builder . set content intent ( s pending intent launch application ) ; builder . set content title ( tools . app name ) ; start foreground ( notification connection , builder . get notification ( ) ) ; } }	updates the status about the service state ( and the status bar ).
private static file find guacamole home ( ) { file guac home ; string desired dir = system . get property ( str ) ; if ( desired dir == null ) desired dir = system . getenv ( str ) ; if ( desired dir != null ) guac home = new file ( desired dir ) ; else guac home = new file ( system . get property ( str ) , str ) ; return guac home ; }	locates the guacamole home directory by checking , in order : the guacamole.
void wait for server start ( ) throws interrupted exception { started . await ( get test timeout ( ) , time unit . milliseconds ) ; }	blocks the executing thread until at least one server has started .
private static void draw left tab ( int x , int y , int w , int h , d g2 , ui color ) { double r top = rapid look and feel . corner tab radius * num ; g2 . set color ( color ) ; g2 . fill ( create left tab shape ( x + num , y + num , w - num , h , r top , bool ) ) ; g2 . set color ( colors . tab border ) ; g2 . draw ( create left tab shape ( x , y , w - num , h , r top , bool ) ) ; }	draw a left tab at the given location and size with the given background color .
private list < int [ ] > prepare expected data ( ) { list < int [ ] > index list = new array list < > ( num ) ; int [ ] sort index = { num , num , num , num , num } ; int [ ] sort index inverted = { num , num , num , num , num } ; index list . add ( num , sort index ) ; index list . add ( num , sort index inverted ) ; return index list ; }	method return the list of sortindex and sortindexinverted array.
public byte [ ] read bytes ( final int count ) { int bytes to read = count ; if ( bytes to read < num ) bytes to read = byte stream . available ( ) ; byte [ ] bytes = new byte [ bytes to read ] ; if ( current bit index >= num ) { for ( int i = num ; i < bytes to read ; i ++ ) { bytes [ i ] = ( byte ) read ( byte . size ) ; } } else { byte stream . read ( bytes , num , bytes . length ) ; } return bytes ; }	reads a sequence of bytes from the stream .
public ssl ( ) { this ( bool , bool ) ; }	creates an ssltestconfig that does not use ssl or client authentication.
@ override public int hash code ( ) { return num + arrays . hash code ( fields ) ; }	returns a hash code value for this object .
public static string format path ( list < child number > path ) { return path joiner . join ( iterables . concat ( collections . singleton ( str ) , path ) ) ; }	convert to a string path , starting with " m / ".
public static object read invocation result ( platform context ctx , binary raw reader ex reader ) throws ignite checked exception { boolean success = reader . read boolean ( ) ; if ( success ) return reader . read object detached ( ) ; else { boolean has exception = reader . read boolean ( ) ; if ( has exception ) { object native err = reader . read object detached ( ) ; assert native err != null ; throw ctx . create native exception ( native err ) ; } else { string err msg = reader . read string ( ) ; assert err msg != null ; throw new ignite checked exception ( err msg ) ; } } }	reads invocation result ( of a job / service / etc ) using a common protocol .
public final void test generate seedint02 ( ) { for ( int i = num ; i < length ; i ++ ) { byte [ ] my bytes = sr . generate seed ( i ) ; assert false ( str + i + str + my bytes . length , my bytes . length != i ) ; } }	test against the " void generateseed ( int ) " method ; it checks out that number of bits returned is equal to one requested ; the check includes case for argument ' s value = = 0 ;.
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return string thing ; case num : return byte thing ; case num : return thing ; case num : return thing ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
private list < string > replace dot in mustache keys ( final list < string > mustache keys ) { final list < string > fixed mustache keys = new array list < > ( ) ; for ( string mustache key : mustache keys ) { fixed mustache keys . add ( mustache key . replace ( str , str ) ) ; } return fixed mustache keys ; }	todo : trivial components does not support foo.
public static i create ( string key ) { i result = standard keys . get ( key ) ; if ( result == null ) { result = new fits header impl ( key , source . unknown , hdu . any , value . any , str ) ; } return result ; }	create a fits header key from a free string.
protected string parse payload ( string payload ) { string json = null ; if ( payload != null ) { try { json = ( payload . index of ( str ) == - num ) ? new string ( files . read all bytes ( paths . get ( payload ) ) ) : payload ; } catch ( io e ) { log . fatal ( str + payload , e ) ; system . exit ( num ) ; } } return json ; }	parses payload argument from command line and returns the json .
boolean add entry ( policy entry pe , int index ) { if ( index < num ) { policy entries . add element ( pe ) ; parser . add ( pe . get grant entry ( ) ) ; } else { policy entry orig pe = policy entries . element at ( index ) ; parser . replace ( orig pe . get grant entry ( ) , pe . get grant entry ( ) ) ; policy entries . set element at ( pe , index ) ; } return bool ; }	add a grant entry to the overall policy at the specified index.
public writable raster create compatible writable raster ( int w , int h ) { if ( w <= num || h <= num ) { throw new raster format exception ( str + ( ( w <= num ) ? str : str ) ) ; } sample model sm = sample model . create compatible sample model ( w , h ) ; return new integer component raster ( sm , new point ( num , num ) ) ; }	creates a raster with the same band layout but using a different width and height , and with new zeroed data arrays .
public void test case1 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; int a sign = num ; int b sign = num ; byte r bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . subtract ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( num , result . signum ( ) ) ; }	subtract two positive numbers of the same length.
public static void create or clear destination folder ( string path ) { file fpath = new file ( path ) ; fpath . mkdirs ( ) ; delete directory contents ( path , bool ) ; }	creates a directory with given path if it does not exist and clears the contents of the directory in case it exists .
static synchronized jmri user interface configuration provider find provider ( profile project ) { if ( providers . get ( project ) == null ) { providers . put ( project , new jmri user interface configuration provider ( project ) ) ; } return providers . get ( project ) ; }	get the jmriprefererncesprovider for the specified profile .
protected static long [ ] insert ( long [ ] old , int old size , int pos , long x ) { long [ ] result ; if ( old != null && old . length > old size ) { result = old ; } else { result = new long [ old size + num + copy threshold ] ; if ( pos > num ) { system . arraycopy ( old , num , result , num , pos ) ; } } if ( old != null && old size - pos > num ) { system . arraycopy ( old , pos , result , pos + num , old size - pos ) ; } result [ pos ] = x ; return result ; }	insert a value in an array.
private boolean discard upstream media chunks ( int queue length ) { if ( media chunks . size ( ) <= queue length ) { return bool ; } long start time us = num ; long end time us = media chunks . get last ( ) . end time us ; base media chunk removed = null ; while ( media chunks . size ( ) > queue length ) { removed = media chunks . remove last ( ) ; start time us = removed . start time us ; loading finished = bool ; } sample queue . discard upstream samples ( removed . get first sample index ( ) ) ; notify upstream discarded ( start time us , end time us ) ; return bool ; }	discard upstream media chunks until the queue length is equal to the length specified .
public void close ( ) { animation . set rate ( - num ) ; animation . play ( ) ; animation . set on finished ( null ) ; }	close the popup , by default the popup will close when clicking outside the popup content and inside its container.
map < string , set < call location model > > compute filtered taint sources map ( set < call location model > sources ) { if ( ! sources . is empty ( ) ) { if ( f filtered taint sources map != null && ! f filtered taint sources map . is empty ( ) ) { map < string , set < call location model > > result = new tree map < string , set < call location model > > ( ) ; for ( entry < string , set < call location model > > entry : f filtered taint sources map . entry set ( ) ) { set < call location model > filtered sources = new tree set < call location model > ( ) ; for ( call location model source : entry . get value ( ) ) { if ( sources . contains ( source ) ) { filtered sources . add ( source ) ; } } if ( ! filtered sources . is empty ( ) ) { string taint kind = entry . get key ( ) ; result . put ( taint kind , filtered sources ) ; } } return result ; } } return collections . empty map ; }	given a set of info sources , computes the set of filtered info sources using the filtering info stored in the field ffilteredtaintsourcesmap.
public static boolean contains ( string s , property expected ) { if ( s == null || s . length ( ) == num ) { return bool ; } int i = num ; while ( i < s . length ( ) ) { int codepoint = character . code point at ( s , i ) ; emoji e = map . get ( codepoint ) ; if ( e == null ) { return bool ; } if ( ! e . is ( expected ) ) { return bool ; } i += codepoint >= num ? num : num ; } return bool ; }	returns whether any of the characters in s has the expected properties .
public class to class ( string codebase ) throws io , class not found exception { if ( name . char at ( num ) != str ) { return class loading . load class ( codebase , name , null , integrity , null ) ; } string tokenizer st = new string tokenizer ( name , str ) ; string [ ] ifs = new string [ st . count tokens ( ) ] ; for ( int i = num ; i < ifs . length ; i ++ ) { ifs [ i ] = st . next token ( ) ; } return class loading . load proxy class ( codebase , ifs , null , integrity , null ) ; }	converts this descriptor to a class instance , loading from codebase.
public static < t > optional < t > lowest common ancestor ( tree def . parented < t > tree def , list < t > nodes ) { if ( nodes . size ( ) == num ) { return optional . empty ( ) ; } else { optional < t > so far = optional . of ( nodes . get ( num ) ) ; for ( int i = num ; i < nodes . size ( ) && so far . is present ( ) ; ++ i ) { so far = lowest common ancestor ( tree def , so far . get ( ) , nodes . get ( i ) ) ; } return so far ; } }	returns the common parent of n elements .
public void copy value nodes to me ( entity from ) { for ( value node from child : from . get children ( value node . class ) ) { value node to child = get child ( from child . get name ( ) , value node . class ) ; to child . set value ( from child . get value ( ) ) ; } }	copies the values nodes from the input entity to this object.
public static world icon image from pixel transparency ( buffered image image ) { int image margin top = find first solid pixel from top ( image ) ; int image margin bottom = find first solid pixel from bottom ( image ) ; int frame height = math . max ( num , image . get height ( ) - image margin top - image margin bottom ) ; return new world icon image ( image , num , image margin top , image . get width ( ) , frame height ) ; }	use pixel transparency along the left edge of the icon to automatically determine the vertical frame position.
private map < string , string > check vip diff ( property info ext local props , property info rest rep rep ) { string vip addr v4 = rep . get property ( str ) ; string vip addr v6 = rep . get property ( str ) ; map < string , string > diff props = new hash map < string , string > ( ) ; if ( ! vip addr v4 . equals ( local props . get property ( str ) ) ) { diff props . put ( str , vip addr v4 ) ; log . warn ( str , vip addr v4 , local props . get property ( str ) ) ; } if ( ! vip addr v6 . equals ( local props . get property ( str ) ) ) { diff props . put ( str , vip addr v6 ) ; log . warn ( str , vip addr v6 , local props . get property ( str ) ) ; } return diff props ; }	check if vip changed comparing locally cached vip vs vip get from controller diff.
private static double distance sq ( color a , color b ) { double r mean = ( a . get red ( ) + b . get red ( ) ) / num / num ; double dr = ( a . get red ( ) - b . get red ( ) ) / num ; double dg = ( a . get green ( ) - b . get green ( ) ) / num ; double db = ( a . get blue ( ) - b . get blue ( ) ) / num ; double d = ( num + r mean ) * dr * dr + num * dg * dg + ( num + num - r mean ) * db * db ; return d / num ; }	calculates the square of the distance between the two specified colors .
@ override public boolean e is set ( int feature id ) { switch ( feature id ) { case s . specification element specification : return specification edefault == null ? specification != null : ! specification edefault . equals ( specification ) ; } return super . e is set ( feature id ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
private static application type new type ( final string name ) throws illegal access exception , instantiation exception { return new application type ( name , new hash map < string , boolean > ( type actions ) , dumb search index . class , dumb save index . class , dumb resource name . class ) ; }	creates a new application type .
public int compare ( source file o1 , source file o2 ) { string n1 = o1 . get name ( ) ; string n2 = o2 . get name ( ) ; return n1 . compare to ( n2 ) ; }	comparator interface for sorting sourcefiles.
protected boolean process dynamic property nodes ( node parent , dynamic property property , model model ) { collection nodes = parent . get children ( ) ; string name = property . get name ( ) ; string state = property . get state name ( ) ; cdata cdata = get text content ( nodes , bool ) ; if ( cdata != null ) { return process dynamic property text ( name , cdata . image , text origin . from child ( cdata . in cdata ) , cdata . begin line , model , state ) ; } else { if ( ( state == null ) && model . has property ( name ) ) { log ( parent , new multiple property initializer error ( name ) ) ; } object rvalue = process r ( property , nodes , model ) ; if ( rvalue != null ) { model . set dynamic property ( type table . object type , name , rvalue , state , parent . begin line ) ; return bool ; } else { return bool ; } } }	note : nodes must not be empty.
private static < t extends psi element > boolean process children of type ( psi element element , processor < t > processor , class < t > psi class , boolean reverse order ) { psi element child = reverse order ? element . get last child ( ) : element . get first child ( ) ; while ( child != null ) { if ( psi class . is instance ( child ) ) { if ( ! processor . process ( ( t ) child ) ) { return bool ; } } if ( process children of type ( child , processor , psi class , reverse order ) ) { return bool ; } child = reverse order ? child . get prev sibling ( ) : child . get next sibling ( ) ; } return bool ; }	walk through entire psi tree rooted at ' element ' , processing all children of the given type .
public instances generate ( ) throws exception { return generate ( str ) ; }	generates a new dataset.
protected void load chars ( mr msg , data input stream istream ) throws io { int i ; for ( i = num ; i < msg . max size ( ) ; i ++ ) { byte char1 = read byte protected ( istream ) ; if ( flush receive chars ) { log . warn ( str , msg . to string ( ) ) ; msg . flush ( ) ; i = num ; flush receive chars = bool ; } if ( can receive ( ) ) { msg . set element ( i , char1 ) ; if ( end of message ( msg ) ) { break ; } } else { i -- ; log . error ( str , integer . to hex string ( char1 ) ) ; } } }	get characters from the input source , and file a message.
public string evaluate ( associator associator , instances data ) throws exception { long start time ; long end time ; start time = system . current time millis ( ) ; associator . build associations ( data ) ; end time = system . current time millis ( ) ; m = new string buffer ( associator . to string ( ) ) ; m . append ( str ) ; m . append ( str + ( ( ( double ) ( end time - start time ) ) / num ) + str ) ; m . append ( str ) ; return m . to string ( ) ; }	evaluates the associator with the given commandline options and returns the evaluation string .
public static integer int value ( string prop name , integer dflt ) { string sys prop = get property ( prop name ) ; return ( sys prop != null && ! sys prop . is empty ( ) ) ? integer . get integer ( sys prop ) : dflt ; }	returns boolean value from system property or provided function .
private int compare version parts ( string version1 , string version2 ) { int compare = num ; integer v1 ; integer v2 ; try { v1 = version1 != null ? integer . parse int ( version1 ) : num ; } catch ( number format exception e ) { v1 = num ; } try { v2 = version2 != null ? integer . parse int ( version2 ) : num ; } catch ( number format exception e ) { v2 = num ; } if ( v1 > v2 ) { compare = num ; } else if ( v1 < v2 ) { compare = - num ; } else { compare = num ; } return compare ; }	compare 2 version number strings.
public void pre save init ( ) { persistent data . clear ( ) ; for ( int i = num ; i < get num points ( ) ; i ++ ) { persistent data . add ( get point ( i ) ) ; } }	initializes persistent data . initializes dataset from persistent data .
public void essential ( final consumer < on complete > fn ) { this . essential = fn ; if ( done ) { fn . accept ( build on complete ( ) ) ; } }	called at least once on complete.
public void add listener ( i new listener ) { synchronized ( listeners ) { listeners . add ( new listener ) ; } }	add a new listener.
public void test get type ( ) { assert equals ( str , tbt crl . get type ( ) , str ) ; }	gettype ( ) method testing.
public void add words ( string phrase ) { if ( phrase . equals ( str ) || phrase . equals ( str ) ) return ; string [ ] words = spliterator ( phrase ) ; if ( words . length < num ) return ; for ( int i = num ; i < words . length ; i ++ ) { if ( i == num ) { vector < string > start words = chain . get ( str ) ; start words . add ( words [ i ] ) ; vector < string > suffix = chain . get ( words [ i ] ) ; if ( suffix == null ) { suffix = new vector < > ( ) ; suffix . add ( words [ i + num ] ) ; chain . put ( words [ i ] , suffix ) ; } } else if ( i == words . length - num ) { vector < string > end words = chain . get ( str ) ; end words . add ( words [ i ] ) ; } else { vector < string > suffix = chain . get ( words [ i ] ) ; if ( suffix == null ) { suffix = new vector < > ( ) ; suffix . add ( words [ i + num ] ) ; chain . put ( words [ i ] , suffix ) ; } else { suffix . add ( words [ i + num ] ) ; chain . put ( words [ i ] , suffix ) ; } } } }	add words from phrase to chain.
@ hle @ hle ( nid = num , version = num ) public int sce net adhoc matching abort send data ( @ check argument ( str ) int matching id , psp net mac address mac address ) { return num ; }	abort a data send to a matching target.
public short buffer put ( short [ ] src , int src offset , int short count ) { arrays . check offset and count ( src . length , src offset , short count ) ; if ( short count > remaining ( ) ) { throw new buffer overflow exception ( ) ; } for ( int i = src offset ; i < src offset + short count ; ++ i ) { put ( src [ i ] ) ; } return this ; }	writes shorts from the given short array , starting from the specified offset , to the current position and increases the position by the number of shorts written .
public boolean handle directory ( file directory ) { if ( debug ) { logger . fine ( str + directory . get absolute path ( ) ) ; } return bool ; }	does nothing , nothing is done for directories .
public static void choose ( int n , int [ ] results ) { int k = results . length ; for ( int i = num ; i < k ; i ++ ) { boolean done = bool ; while ( ! done ) { results [ i ] = random . next int ( n ) ; done = bool ; for ( int j = num ; j < i ; j ++ ) { if ( results [ j ] == results [ i ] ) { done = bool ; } } } } }	choose random numbers from 0 to n - 1.
public string print leaf models tip text ( ) { return str ; }	returns the tip text for this property.
public set register client interest list ( object input client id , list keys , boolean updates as invalidates ) { long client id = get client id ( input client id ) ; set keys registered = new hash set ( keys ) ; synchronized ( interest list lock ) { map < object , set > koi = updates as invalidates ? get keys of interest inv ( ) : get keys of interest ( ) ; copy on write hash set interest list = ( copy on write hash set ) koi . get ( client id ) ; if ( interest list == null ) { interest list = new copy on write hash set ( ) ; koi . put ( client id , interest list ) ; } else { keys registered . remove all ( interest list . get snapshot ( ) ) ; } interest list . add all ( keys ) ; if ( this . region != null && this . is local profile ) { send profile operation ( client id , operation type . register keys , keys , updates as invalidates ) ; } } return keys registered ; }	registers interest in a set of keys for a client.
public static list < string > to path parts ( string encoded path ) { if ( encoded path == null || encoded path . length ( ) == num ) { return null ; } list < string > result = new array list < string > ( ) ; int cur = num ; boolean not done = bool ; while ( not done ) { int slash = encoded path . index of ( str , cur ) ; not done = slash != - num ; string sub ; if ( not done ) { sub = encoded path . substring ( cur , slash ) ; } else { sub = encoded path . substring ( cur ) ; } result . add ( char escapers . decode uri ( sub ) ) ; cur = slash + num ; } return result ; }	returns the decoded path parts for the given encoded path .
@ suppress warnings ( str ) public < t extends d > t inverse ( double x , double y , t ret val ) { if ( ret val == null ) { ret val = ( t ) new lat lon point . double ( ) ; } double px = x + ul . x ; double py = - y + ul . y + oy ; if ( px > proj math . round adjust ( world . x / num ) ) { px = proj math . round adjust ( world . x / num ) ; } else if ( px < proj math . round adjust ( - world . x / num ) ) { px = proj math . round adjust ( - world . x / num ) ; } if ( py > proj math . round adjust ( world . y / num ) ) { py = proj math . round adjust ( world . y / num ) ; } else if ( py < proj math . round adjust ( - world . y / num ) ) { py = proj math . round adjust ( - world . y / num ) ; } double lat = normalize latitude ( py / spps y ) ; double lon = wrap longitude ( ( px / spps x ) + center x ) ; ret val . set location ( math . to degrees ( lon ) , math . to degrees ( lat ) ) ; return ret val ; }	inverse project x , y coordinates into a latlonpoint . < p >.
public void install ( j c ) { c . add caret listener ( input attribute updater ) ; c . add property change listener ( input attribute updater ) ; caret caret = c . get caret ( ) ; if ( caret != null ) { input attribute updater . update input attributes ( caret . get dot ( ) , caret . get mark ( ) , c ) ; } }	called when the kit is being installed into a jeditorpane .
@ override public enumeration < option > list options ( ) { vector < option > result = new vector < option > ( ) ; enumeration < option > enm = super . list options ( ) ; while ( enm . has more elements ( ) ) result . add ( enm . next element ( ) ) ; result . add element ( new option ( str + stopwords tip text ( ) + str + str , str , num , str ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
private void enable operation buttons ( ) { btn or . set enabled ( bool ) ; btn and . set enabled ( bool ) ; btn right paren . set enabled ( bool ) ; }	convenience method for enabling the buttons related to filter operations for filtering ( btnand , btnor , etc ).
private double compute modifier unbounded ( final double x ) { return exp multiplier * math . exp ( - x * x / exp member ) ; }	compute the value of the modifier.
@ override public boolean on unit ( graphics g , int x , int y , int w , int h ) { font metrics fm = g . get font metrics ( ) ; int l = ( int ) ( m x * w ) - fm . string width ( m id ) / num ; int t = ( int ) ( m y * h ) - fm . get height ( ) / num ; if ( x < l || x > l + fm . string width ( m id ) + num || y < t || y > t + fm . get height ( ) + fm . get descent ( ) + num ) { return bool ; } return bool ; }	call this function to determine if the point at x , y is on the unit .
public static integer to integer ( string str ) { try { return integer . value of ( str ) ; } catch ( exception ex ) { return null ; } }	casts string to integer or returns null if value is not integer.
private static void fill with empty rows ( data table data , int count ) { while ( data . get row count ( ) < count ) { double [ ] empty row = new double [ data . get column count ( ) ] ; arrays . fill ( empty row , num ) ; data . add ( empty row ) ; } }	utility method that fills a data table with empty rows .
public void test division knuth1 ( ) { byte a bytes [ ] = { - num , - num , - num , - num , - num , - num , - num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { - num , - num , - num , - num } ; int a sign = num ; int b sign = num ; byte r bytes [ ] = { num , - num , - num , - num , - num , - num , - num , - num , num , num , num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . divide ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	verifies the case when borrow ! = 0 in the private divide method .
public fragmented handshake message ( byte [ ] fragmented bytes , handshake type type , int fragment offset , int message length , inet socket address peer address ) { super ( peer address ) ; this . type = type ; this . message length = message length ; this . fragmented bytes = arrays . copy of ( fragmented bytes , fragmented bytes . length ) ; set fragment offset ( fragment offset ) ; set fragment length ( fragmented bytes . length ) ; }	called when fragmenting a handshake message .
private static void delete retry counter ( weak reference < context > weak context , string filename , int max retry attempts ) { context context = null ; if ( weak context != null ) { context = weak context . get ( ) ; if ( context != null ) { shared preferences preferences = context . get shared preferences ( artisan sdk , context . mode private ) ; shared preferences . editor editor = preferences . edit ( ) ; editor . remove ( str + filename ) ; editor . apply ( ) ; } } }	delete the retry counter if stacktrace is uploaded or retry limit is reached .
private void initialize sparse slider ( ) { connection density slider . set major tick spacing ( num ) ; connection density slider . set minor tick spacing ( num ) ; connection density slider . set paint ticks ( bool ) ; hashtable < integer , j > label table2 = new hashtable < integer , j > ( ) ; label table2 . put ( new integer ( num ) , new j ( str ) ) ; label table2 . put ( new integer ( num ) , new j ( str ) ) ; connection density slider . set label table ( label table2 ) ; connection density slider . set paint labels ( bool ) ; }	initializes the sparse slider .
protected void update tree ( document event event ) { updating selection = bool ; try { tree model model = get tree model ( ) ; object root = model . get root ( ) ; for ( int counter = model . get child count ( root ) - num ; counter >= num ; counter -- ) { update tree ( event , ( element ) model . get child ( root , counter ) ) ; } } finally { updating selection = bool ; } }	updates the tree based on the event type.
private static shape bottom edge ( buffered image image , general path path , int start ) { int lastj = num ; d p1 = path . get current point ( ) ; d p2 = null ; d line = new d . float ( ) ; for ( int i = start ; i < image . get width ( ) ; i += sample ) { boolean a point exists on this line = bool ; for ( int j = image . get height ( ) - num ; j >= num ; j -= sample ) { if ( ( image . get rgb ( i , j ) & num ) != num ) { d p = new d . float ( i , j ) ; a point exists on this line = bool ; p2 = detect line ( p1 , p2 , p , line , path ) ; lastj = j ; break ; } } if ( a point exists on this line == bool ) { break ; } } return right edge ( image , path , lastj ) ; }	trace the bottom of the image.
@ form url encoded @ post ( str ) call < authentication response > authorize ( @ field map map < string , string > auth map ) ;	asynchronously obtains an oauth token .
private boolean repeating preview ( object tag ) { try { capture request . builder builder = m device . create capture request ( camera device . template preview ) ; builder . add target ( m preview surface ) ; builder . set ( capture request . control mode , camera metadata . control mode auto ) ; add baseline capture keys to request ( builder ) ; m capture session . set repeating request ( builder . build ( ) , m capture callback , m camera handler ) ; log . v ( tag , string . format ( str , m zoom value ) ) ; return bool ; } catch ( camera access exception ex ) { log . e ( tag , str , ex ) ; return bool ; } }	request preview capture stream with af_mode_continuous_picture .
private xml new element ( string name , string value , array list attributes ) throws exception { return new element ( name , value , attributes , bool ) ; }	factory method for creating a new element with the given name , given value and given attributes.
public void mouse pressed ( mouse event e ) { if ( log . is debug enabled ( ) ) { log . debug ( str + ( e . get modifiers ( ) & mouse event . butto mask ) + str + e . is popup trigger ( ) + str + ( e . get modifiers ( ) & ( mouse event . alt mask + mouse event . meta mask + mouse event . ctrl mask ) ) + ( str + mouse event . alt mask + str + mouse event . meta mask + str + mouse event . ctrl mask ) ) ; } if ( e . is popup trigger ( ) && parent frame . is selected ( ) ) { try { menu . show ( e . get component ( ) , e . get x ( ) , e . get y ( ) ) ; } catch ( java . awt . illegal component state exception cs ) { } e . consume ( ) ; } }	if the event is the popup trigger , which is dependent on the platform , present the popup menu.
public void define fill style ( color [ ] colors , int [ ] ratios , transform matrix , boolean radial ) { gradient fill fill = new gradient fill ( colors , ratios , matrix , radial ) ; elements . add ( fill ) ; for ( int i = num ; i < colors . length ; i ++ ) { if ( colors [ i ] == null ) { continue ; } if ( colors [ i ] instanceof alpha color ) { has alpha = bool ; } } }	define a gradient fill.
public boolean is orphan ( sha256 hash block ) { lock . lock ( ) ; try { return orphan blocks . contains key ( block ) ; } finally { lock . unlock ( ) ; } }	returns true if the given block is currently in the orphan blocks list .
protected boolean val ( boolean b ) { this . b = b ; }	creates the boolean value ( protected , use the valuefactory to create it ).
public list < volume > validate volumes ( storage system storage system , list < volume > volumes , boolean delete , boolean remediate , val ck ... checks ) { try { client = v . get v api ( v . get instance ( ) , storage system , get db client ( ) ) ; for ( volume volume : volumes ) { try { log . info ( string . format ( str , volume . get label ( ) , volume . get native id ( ) , volume . get id ( ) , checks . to string ( ) ) ) ; validate volume ( volume , delete , remediate , checks ) ; } catch ( exception ex ) { log . error ( str + volume . get id ( ) , ex ) ; } } } catch ( exception ex ) { log . error ( str + storage system . get id ( ) , ex ) ; } return remediated volumes ; }	validates the given volumes .
private void draw x ( canvas canvas , double value , number format number format , int spacing ) { string marker = chart by distance ? number format . format ( value ) : string utils . format elapsed time ( ( long ) value ) ; rect rect = get rect ( x axis marker paint , marker ) ; canvas . draw text ( marker , get x ( value ) , top border + effective height + spacing + rect . height ( ) , x axis marker paint ) ; }	draws a x axis marker .
public static < e > array list < e > list ( e ... elements ) { array list < e > list = new array list < e > ( ) ; for ( e element : elements ) list . add ( element ) ; return list ; }	add elements to an arraylist .
public static string encode ( array list < geo point > polyline , int precision ) { string builder encoded points = new string builder ( ) ; int prev lat = num , prev lng = num ; for ( geo point trackpoint : polyline ) { int lat = trackpoint . get latitude e6 ( ) / precision ; int lng = trackpoint . get longitude e6 ( ) / precision ; encoded points . append ( encode signed number ( lat - prev lat ) ) ; encoded points . append ( encode signed number ( lng - prev lng ) ) ; prev lat = lat ; prev lng = lng ; } return encoded points . to string ( ) ; }	encode a polyline with google polyline encoding method.
private static boolean is text obscured ( j c , string s ) { graphics g = c . get graphics ( ) ; font metrics fm = g . get font metrics ( c . get font ( ) ) ; int sw = fm . string width ( s ) ; return ( sw > c . get width ( ) ) ; }	check if any label text is obscured .
public void add ( permission permission ) { perms . put ( permission , permission ) ; }	adds the argument to the collection .
public void test all connected broker network ( ) throws exception { bridge brokers ( str , str ) ; bridge brokers ( str , str ) ; bridge brokers ( str , str ) ; bridge brokers ( str , str ) ; bridge brokers ( str , str ) ; bridge brokers ( str , str ) ; start all brokers ( ) ; destination dest = create destination ( str , bool ) ; message consumer client a = create consumer ( str , dest ) ; message consumer client b = create consumer ( str , dest ) ; message consumer client c = create consumer ( str , dest ) ; thread . sleep ( num ) ; send messages ( str , dest , message count ) ; send messages ( str , dest , message count ) ; send messages ( str , dest , message count ) ; message id list msgs a = get consumer messages ( str , client a ) ; message id list msgs b = get consumer messages ( str , client b ) ; message id list msgs c = get consumer messages ( str , client c ) ; msgs a . wait for messages to arrive ( message count * num ) ; msgs b . wait for messages to arrive ( message count * num ) ; msgs c . wait for messages to arrive ( message count * num ) ; assert equals ( message count * num , msgs a . get message count ( ) ) ; assert equals ( message count * num , msgs b . get message count ( ) ) ; assert equals ( message count * num , msgs c . get message count ( ) ) ; }	brokera < - > brokerb < - > brokerc.
private int encrypted column length ( int col length ) { string str = str ; for ( int i = num ; i < col length ; i ++ ) { str += str ; } str = secure engine . encrypt ( str ) ; return str . length ( ) ; }	determines the length of the encrypted column .
private a unify links ( a source element , a destination element ) throws command exception { for ( a link down : source element . get links down ( ) ) { create link ( destination element , link down . get dependency ( ) , link down . get relation id ( ) ) ; } for ( a link up : source element . get links up ( ) ) { create link ( link up . get dependant ( ) , destination element , link up . get relation id ( ) ) ; } return destination element ; }	copies all links from the source element to the destination element .
private boolean flush accumulated region ( ) { boolean success = bool ; if ( accumulated x != integer . max value ) { sub region showable bs sub region = ( sub region showable ) buffer strategy ; boolean contents lost = buffer strategy . contents lost ( ) ; if ( ! contents lost ) { bs sub region . show ( accumulated x , accumulated y , accumulated max x , accumulated max y ) ; contents lost = buffer strategy . contents lost ( ) ; } if ( contents lost ) { if ( logger . is loggable ( platform logger . level . finer ) ) { logger . finer ( str ) ; } buffer info . set in sync ( bool ) ; success = bool ; } } reset accumulated ( ) ; return success ; }	renders the bufferstrategy to the screen .
public void test bit length positive1 ( ) { byte a bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num , num , num , num , num } ; int a sign = num ; big integer a number = new big integer ( a sign , a bytes ) ; assert equals ( num , a number . bit length ( ) ) ; }	bitlength ( ) of a positive number .
public void clear pie segments ( ) { m pie segment list . clear ( ) ; }	clears the pie segments list .
public static string random alphanumerical ( final int len ) { final string builder sb = new string builder ( len ) ; for ( int i = num ; i < len ; i ++ ) { sb . append ( ab . char at ( random . next int ( ab . length ( ) ) ) ) ; } return sb . to string ( ) ; }	generates a random alphanumerical string of the given length . the used characters are : < br > < br > 0123456789abcdefghijklmnopqrstuvwxyz.
static int svd imax ( int a , int b ) { return math . max ( a , b ) ; }	returns the larger of two integers.
private boolean is mime format ( long format , string primary type ) { string nat = get native for format ( format ) ; if ( nat == null ) { return bool ; } try { data flavor df = new data flavor ( nat ) ; if ( primary type . equals ( df . get primary type ( ) ) ) { return bool ; } } catch ( exception e ) { } return bool ; }	returns true if and only if the name of the specified format atom constitutes a valid mime type with the specified primary type .
private static string convert relevance ( int relevance ) { string builder sb = new string builder ( ) ; while ( relevance > num ) { sb . insert ( num , reverse char map [ relevance % num ] ) ; relevance = relevance / num ; } return sb . to string ( ) ; }	converts the relevance to a sort text.
int extract version from filename ( final file file ) { final matcher matcher = versioned pattern . matcher ( file . get absolute path ( ) ) ; matcher . find ( ) ; return integer . parse int ( matcher . group ( num ) ) ; }	find the version number that ' s embedded in the name of this file.
static int measure child for cells ( view child , int cell size , int cells remaining , int parent height measure spec , int parent height padding ) { final layout params lp = ( layout params ) child . get layout params ( ) ; final int child height size = measure spec . get size ( parent height measure spec ) - parent height padding ; final int child height mode = measure spec . get mode ( parent height measure spec ) ; final int child height spec = measure spec . make measure spec ( child height size , child height mode ) ; int cells used = num ; if ( cells remaining > num ) { final int child width spec = measure spec . make measure spec ( cell size * cells remaining , measure spec . at most ) ; child . measure ( child width spec , child height spec ) ; final int measured width = child . get measured width ( ) ; cells used = measured width / cell size ; if ( measured width % cell size != num ) cells used ++ ; } final action menu item view item view = child instanceof action menu item view ? ( action menu item view ) child : null ; final boolean expandable = ! lp . is overflow button && item view != null && item view . has text ( ) ; lp . expandable = expandable ; lp . cells used = cells used ; final int target width = cells used * cell size ; child . measure ( measure spec . make measure spec ( target width , measure spec . exactly ) , child height spec ) ; return cells used ; }	measure a child view to fit within cell - based formatting.
private boolean is specialized handler available ( intent intent ) { package manager pm = m activity . get package manager ( ) ; list < resolve info > handlers = pm . query intent activities ( intent , package manager . get resolved filter ) ; if ( handlers == null || handlers . size ( ) == num ) { return bool ; } for ( resolve info resolve info : handlers ) { intent filter filter = resolve info . filter ; if ( filter == null ) { continue ; } if ( filter . count data authorities ( ) == num && filter . count data paths ( ) == num ) { continue ; } return bool ; } return bool ; }	search for intent handlers that are specific to this url aka , specialized apps like google maps or youtube.
private void convert error ( char buffer buf , int line ) { string src filename = null ; int dest line = num ; int src line = num ; int src tail line = integer . max value ; for ( int i = num ; i < lines . size ( ) ; i ++ ) { line map = ( line ) lines . get ( i ) ; if ( map . dst line <= line && line <= map . get last destination line ( ) ) { src filename = map . src filename ; dest line = map . dst line ; src line = map . get source line ( line ) ; break ; } } if ( src filename != null ) { } else if ( lines . size ( ) > num ) src filename = ( ( line ) lines . get ( num ) ) . src filename ; else src filename = str ; buf . append ( src filename ) ; if ( line >= num ) { buf . append ( str ) ; buf . append ( src line + ( line - dest line ) ) ; } }	maps a destination line to an error location .
public static string slurp gburl ( url u ) { try { return slurp gburl ( u ) ; } catch ( exception e ) { e . print stack trace ( ) ; return null ; } }	returns all the text at the given url .
public void undo ( ) { if ( ! undo stack . is empty ( ) ) { undoable action last event = undo stack . pop ( ) ; last event . undo ( ) ; redo stack . push ( last event ) ; } }	undo the last undoable action .
public pair < solr core , solr core > replicate to destination ( solr core bestsrc core , solr core destination core ) throws exception { pair < solr core , solr core > replication request pair = null ; try { solr interaction utils . replicate index ( destination core . host , destination core . name , bestsrc core . host , bestsrc core . name ) ; string full replication = str ; string replicator = string . format ( full replication , destination core . host , solr interaction utils . default solr port , destination core . name , bestsrc core . host , solr interaction utils . default solr port , bestsrc core . name ) ; logger . info ( str + replicator ) ; replication request pair = new pair < solr core , solr core > ( destination core , bestsrc core ) ; logger . info ( str + destination core . host + str + destination core . name + str + bestsrc core . host + str + bestsrc core . name ) ; } catch ( exception e ) { logger . info ( str + destination core . host + str + bestsrc core . host ) ; if ( ! replicator config . should skip replication failures ( ) ) { throw new replication failure exception ( str + destination core . host + str + bestsrc core . host ) ; } } return replication request pair ; }	given source and destionation cores , issue the solr replication command between them.
public static os calculate os ( ) { string os name = system . get property ( str ) ; os name = os name . to lower case ( locale . english ) ; if ( os name . starts with ( str ) ) { return os . apple ; } if ( os name . starts with ( str ) ) { return os . windows ; } if ( os name . starts with ( str ) ) { return os . linux ; } if ( os name . starts with ( str ) ) { return os . sun ; } return os . unknown ; }	calculates the current ostype.
private static int count duplicates ( stack trace element [ ] current stack , stack trace element [ ] parent stack ) { int duplicates = num ; int parent index = parent stack . length ; for ( int i = current stack . length ; -- i >= num && -- parent index >= num ; ) { stack trace element parent frame = parent stack [ parent index ] ; if ( parent frame . equals ( current stack [ i ] ) ) { duplicates ++ ; } else { break ; } } return duplicates ; }	count the number of duplicate stack frames , starting from the end of the stack .
public void recycle ( ) { synchronized ( s pool ) { if ( s pool . size ( ) < max pool size ) { s pool . add ( this ) ; } } }	do not call this unless you obtained this via expandablelistposition.
public final boolean exists ( ) { return config != null ; }	checks whether the configuration is loaded correctly .
@ override public synchronized void remove test set listener ( test set listener tsl ) { m test listeners . remove element ( tsl ) ; }	remove a test set listener.
private boolean has colinear ( array list < pla point int > corners list , pla point int a point ) { int count = corners list . size ( ) ; if ( count < num ) return bool ; for ( int index = num ; index < count - num ; index ++ ) { pla point int start = corners list . get ( index ) ; pla point int end = corners list . get ( index + num ) ; if ( a point . side of ( start , end ) != pla side . collinear ) continue ; double d start p = start . distance square ( a point ) ; double d p end = a point . distance square ( end ) ; double d start end = start . distance square ( end ) ; if ( d start end >= d start p ) { if ( d start end >= d p end ) { return bool ; } else { corners list . set ( index , a point ) ; return bool ; } } else { if ( d start end >= d p end ) { corners list . set ( index + num , a point ) ; return bool ; } else { corners list . set ( index , a point ) ; return bool ; } } } return bool ; }	thest if the given point is somewhat colinear and should not be inserted note it is quite possible that the given point replaces a point already in the list.
public boolean contains ( string key ) { return my properties . contains key ( key ) ; }	returns true if the store contains a value for the given key .
protected snmp cached data update cached datas ( object user data ) { final string [ ] path = jvm runtime impl . get library path ( user data ) ; final long time = system . current time millis ( ) ; final int len = path . length ; snmp oid indexes [ ] = new snmp oid [ len ] ; for ( int i = num ; i < len ; i ++ ) { indexes [ i ] = new snmp oid ( i + num ) ; } return new snmp cached data ( time , indexes , path ) ; }	return a table handler containing the thread indexes.
public static byte [ ] decode hex ( string hex string ) { int length = hex string . length ( ) ; if ( ( length & num ) != num ) { throw new illegal argument exception ( str ) ; } boolean bad hex = bool ; byte [ ] out = new byte [ length > > num ] ; for ( int i = num , j = num ; j < length ; i ++ ) { int c1 = hex string . char at ( j ++ ) ; if ( c1 > str ) { bad hex = bool ; break ; } final byte d1 = digits [ c1 ] ; if ( d1 == - num ) { bad hex = bool ; break ; } int c2 = hex string . char at ( j ++ ) ; if ( c2 > str ) { bad hex = bool ; break ; } final byte d2 = digits [ c2 ] ; if ( d2 == - num ) { bad hex = bool ; break ; } out [ i ] = ( byte ) ( d1 << num | d2 ) ; } if ( bad hex ) { throw new illegal argument exception ( str + hex string ) ; } return out ; }	quickly converts a hexadecimal string to a byte array .
public static void delete player ( player account data acc data ) { if ( acc data . get deletion date ( ) != null ) { return ; } acc data . set deletion date ( new timestamp ( system . current time millis ( ) + num * num * num ) ) ; store deletion time ( acc data ) ; }	starts player deletion process if its possible.
public void test buffered ( ) { instances icopy = new instances ( m ) ; instances result = null ; try { m . set input format ( icopy ) ; } catch ( exception ex ) { ex . print stack trace ( ) ; fail ( str + ex . get message ( ) ) ; } try { result = filter . use filter ( icopy , m ) ; assert not null ( result ) ; } catch ( exception ex ) { ex . print stack trace ( ) ; fail ( str + ex . get message ( ) ) ; } string writer sw = new string writer ( num ) ; sw . write ( result . to string ( ) ) ; assert true ( icopy . equal headers ( m ) ) ; assert equals ( icopy . num instances ( ) , m . num instances ( ) ) ; instances result2 = null ; try { m . set input format ( icopy ) ; } catch ( exception ex ) { ex . print stack trace ( ) ; fail ( str + ex . get message ( ) ) ; } try { result2 = filter . use filter ( icopy , m ) ; assert not null ( result2 ) ; } catch ( exception ex ) { ex . print stack trace ( ) ; fail ( str + ex . get message ( ) ) ; } assert true ( icopy . equal headers ( m ) ) ; assert equals ( icopy . num instances ( ) , m . num instances ( ) ) ; assert true ( result . equal headers ( result2 ) ) ; assert equals ( result . num instances ( ) , result2 . num instances ( ) ) ; }	test buffered operation . output instances are only collected after all instances are passed through.
private string parse css ( final string css ) { final map < string , string > map = new hash map < string , string > ( ) ; final string buffer sb = new string buffer ( ) ; final matcher m = pattern variables definition . matcher ( css ) ; while ( m . find ( ) ) { final string variables body = m . group ( num ) ; map . put all ( extract variables ( variables body ) ) ; m . append replacement ( sb , str ) ; } m . append tail ( sb ) ; return replace variables ( sb . to string ( ) , map ) ; }	parse css , find all defined variables & replace them .
private void shutdown ( ) { if ( exec svc != null ) exec svc . shutdown ( num ) ; if ( msg exec svc != null ) msg exec svc . shutdown now ( ) ; try { job . dispose ( bool ) ; } catch ( ignite checked exception e ) { u . error ( log , str , e ) ; } }	stops all executors and running tasks .
public void start cdata ( ) throws org . xml . sax . sax { m in c = bool ; append ( m doc . create cdata ( str ) ) ; }	report the start of a cdata section .
public void add all ( list < fragment > a splits ) { splits . add all ( a splits ) ; }	adds a list of split elements .
protected synchronized int currentchunkoffset ( ) throws io { long fp = backing random access file . get file pointer ( ) ; if ( fp < f header . header size ( ) ) { return - num ; } else { fp -= f header . header size ( ) ; if ( fp == num ) { return num ; } else { return ( int ) ( ( fp % chunk enc size ) - chunk iv size ) ; } } }	indicates to which data offset within the current chunk the file pointer currently points.
protected int decode line prefix ( pushback input stream a stream , output stream b stream ) throws io { return ( bytes per line ( ) ) ; }	103 * this method should return , if it knows , the number of bytes 104 that will be decoded.
private static lookup locator [ ] unmarshal locators ( object input stream in ) throws io , class not found exception { list l = new array list ( ) ; marshalled instance mi ; while ( ( mi = ( marshalled instance ) in . read object ( ) ) != null ) { try { l . add ( ( lookup locator ) mi . get ( bool ) ) ; } catch ( throwable e ) { if ( e instanceof error && throwable constants . retryable ( e ) == throwable constants . bad object ) { throw ( error ) e ; } logger . log ( level . warning , str , e ) ; } } return ( lookup locator [ ] ) l . to array ( new lookup locator [ l . size ( ) ] ) ; }	returns locators unmarshalled from a null - terminated list of marshalledinstances read from the given stream , logging ( but tolerating ) unmarshalling failures .
static public string number to string ( number n ) throws json { if ( n == null ) { throw new json ( str ) ; } test validity ( n ) ; string s = n . to string ( ) ; if ( s . index of ( str ) > num && s . index of ( str ) < num && s . index of ( str ) < num ) { while ( s . ends with ( str ) ) { s = s . substring ( num , s . length ( ) - num ) ; } if ( s . ends with ( str ) ) { s = s . substring ( num , s . length ( ) - num ) ; } } return s ; }	produce a string from a number .
public int children ( ) { return children . size ( ) ; }	returns the number of child layers in this group .
public void create v ( string display name ) throws exception { log . info ( str ) ; client response client resp = null ; string payload = str + display name + str ; log . info ( str , uri create cg . to string ( ) , payload ) ; try { client resp = post ( uri create cg , payload ) ; if ( client resp == null ) { log . error ( str ) ; throw new h par ( str ) ; } else if ( client resp . get status ( ) != num ) { string err resp = get response details ( client resp ) ; log . error ( str , err resp ) ; throw new h par ( err resp ) ; } else { log . info ( str ) ; } } catch ( exception e ) { throw e ; } finally { if ( client resp != null ) { client resp . close ( ) ; } log . info ( str ) ; } }	vv set is a hp3par term for consistency group . this deals with creation of cg , volumes will be added to the cg in create volume.
protected void connection failed ( channel failed channel , io cause ) { failure cause = io . create ( cause ) ; channel = failed channel ; connected . set ( bool ) ; handshake future . set failure ( cause ) ; }	called when the transport connection failed and an error should be returned .
public void add attribute ( string uri , string local name , string raw name , string type , string value , boolean xsl ) throws sax { if ( m elem context . m start tag open ) { ensure prefix is declared ( uri , raw name ) ; add attribute always ( uri , local name , raw name , type , value , bool ) ; } }	adds the given attribute to the set of attributes , and also makes sure that the needed prefix / uri mapping is declared , but only if there is a currently open element .
private string markdown blockquote ( string value ) { return str + value . replace ( str , str ) ; }	blockquotes a string in markdown format .
protected string hash ( string key ) { try { message digest gen = hash generator . get ( ) ; byte [ ] key bytes = key . get bytes ( str ) ; gen . update ( key bytes , num , key bytes . length ) ; byte [ ] binaryhash = gen . digest ( ) ; return encoder . encode to string ( binaryhash ) ; } catch ( exception e ) { log . warn ( str , key , e ) ; } return null ; }	get the hash encoding of a key string .
public static boolean is input type ( string type string ) { return input types . contains ( type string ) ; }	checks if a given type is a known input type .
public static point destination ( point point1 , double distance , double bearing , string units ) throws turf exception { double degrees2radians = math . pi / num ; double radians2degrees = num / math . pi ; position coordinates1 = point1 . get coordinates ( ) ; double longitude1 = degrees2radians * coordinates1 . get longitude ( ) ; double latitude1 = degrees2radians * coordinates1 . get latitude ( ) ; double bearing rad = degrees2radians * bearing ; double radians = turf helpers . distance to radians ( distance , units ) ; double latitude2 = math . asin ( math . sin ( latitude1 ) * math . cos ( radians ) + math . cos ( latitude1 ) * math . sin ( radians ) * math . cos ( bearing rad ) ) ; double longitude2 = longitude1 + math . atan2 ( math . sin ( bearing rad ) * math . sin ( radians ) * math . cos ( latitude1 ) , math . cos ( radians ) - math . sin ( latitude1 ) * math . sin ( latitude2 ) ) ; return point . from coordinates ( position . from coordinates ( radians2degrees * longitude2 , radians2degrees * latitude2 ) ) ; }	takes a point and calculates the location of a destination point given a distance in degrees , radians , miles , or kilometers ; and bearing in degrees.
public void clear ( ) { synchronized ( m lock ) { m graphics . clear ( ) ; m first graphic = null ; } post invalidate ( ) ; }	removes all graphics from the overlay .
@ suppress warnings ( str ) public node panel ( shader node variable single out , node panel . node type type ) { super ( ) ; list < shader node variable > outputs = new array list < shader node variable > ( ) ; outputs . add ( single out ) ; this . type = type ; init ( new array list < shader node variable > ( ) , outputs ) ; add key listener ( this ) ; tool bar = new node tool bar ( this ) ; }	creates new form nodepanel.
public static string stringify exception ( throwable e ) { string writer stm = new string writer ( ) ; print writer wrt = new print writer ( stm ) ; e . print stack trace ( wrt ) ; wrt . close ( ) ; return stm . to string ( ) ; }	make a string representation of the exception .
private heron reef utils ( ) { }	this is a utility class and should not be instantiated .
public static boolean is solaris ( ) { return ( os . index of ( str ) >= num ) ; }	checks if is solaris .
public double sum inlink hub score ( page page ) { list < string > in links = page . get inlinks ( ) ; double hub score = num ; for ( int i = num ; i < in links . size ( ) ; i ++ ) { page in link = p table . get ( in links . get ( i ) ) ; if ( in link != null ) { hub score += in link . hub ; } else { continue ; } } return hub score ; }	calculate the authority score of a page by summing the hub scores of that page ' s inlinks .
public short banded raster ( sample model sample model , data buffer data buffer , point origin ) { this ( sample model , data buffer , new rectangle ( origin . x , origin . y , sample model . get width ( ) , sample model . get height ( ) ) , origin , null ) ; }	constructs a shortbandedraster with the given samplemodel and databuffer.
public void remap mapped types ( ) { clear mapped types ( ) ; map possible types ( m items ) ; }	forces to remap all possible types for the recyclerview.
public void initialize ( ) throws execution exception { }	this method has to be implemented and cannot throw any exception .
public int num children ( int row ) { int count = num ; next valid row positions . clear ( ) ; for ( int i = num ; i < n ; i ++ ) { board [ row ] [ i ] = bool ; if ( valid ( row , i ) ) { count ++ ; next valid row positions . add ( i ) ; } board [ row ] [ i ] = bool ; } return count ; }	find out how many valid children states are found by trying to add a queen to the given row.
public void test neg neg same length ( ) { string num a = str ; string num b = str ; string res = str ; big integer a number = new big integer ( num a ) ; big integer b number = new big integer ( num b ) ; big integer result = a number . xor ( b number ) ; assert true ( res . equals ( result . to string ( ) ) ) ; }	xor for two negative numbers of the same length.
public static i create related projects scope ( i project , int include mask ) throws core exception { i [ ] projects = get related projects ( project ) ; return search engine . create java search scope ( projects , include mask ) ; }	creates a new search scope containing all projects which reference or are referenced by the specified project .
public confirmation ( ) { this ( null , null ) ; }	creates bearer type confirmation .
public vcs revision number original revision ( int line number ) { return get line revision number ( line number ) ; }	get revision number for the line .
private void check paused or canceled ( state state ) throws stop request { if ( m service . get control ( ) == downloader service . control paused ) { int status = m service . get status ( ) ; switch ( status ) { case downloader service . status paused by app : throw new stop request ( m service . get status ( ) , str ) ; } } }	check if the download has been paused or canceled , stopping the request appropriately if it has been .
void trace ( ) { gl use program ( compute program ) ; inv proj matrix . transform project ( tmp vector . set ( - num , - num , num ) ) ; gl uniform3f ( ray00 uniform , tmp vector . x , tmp vector . y , tmp vector . z ) ; inv proj matrix . transform project ( tmp vector . set ( - num , num , num ) ) ; gl uniform3f ( ray01 uniform , tmp vector . x , tmp vector . y , tmp vector . z ) ; inv proj matrix . transform project ( tmp vector . set ( num , - num , num ) ) ; gl uniform3f ( ray10 uniform , tmp vector . x , tmp vector . y , tmp vector . z ) ; inv proj matrix . transform project ( tmp vector . set ( num , num , num ) ) ; gl uniform3f ( ray11 uniform , tmp vector . x , tmp vector . y , tmp vector . z ) ; gl bind buffer base ( gl shader storage buffer , triangles ssbo binding , ssbo ) ; gl bind image texture ( framebuffer image binding , raytrace texture , num , bool , num , gl write only , gl rgb ) ; int worksize x = math round po t ( width ) ; int worksize y = math round po t ( height ) ; gl dispatch compute ( worksize x / work group size x , worksize y / work group size y , num ) ; gl memory barrier ( gl shader image access barrier bit ) ; gl bind image texture ( framebuffer image binding , num , num , bool , num , gl write only , gl rgb ) ; gl bind buffer base ( gl shader storage buffer , triangles ssbo binding , num ) ; gl use program ( num ) ; }	compute one frame by tracing the scene using our compute shader .
public void remove all action fire listeners ( ) { m action fired listeners . clear ( ) ; }	remove all listeners for action fired events .
public static string millis to string ( long millis ) { boolean negative = millis < num ; millis = math . abs ( millis ) ; millis /= num ; int sec = ( int ) ( millis % num ) ; millis /= num ; int min = ( int ) ( millis % num ) ; millis /= num ; int hours = ( int ) millis ; string time ; decimal format format = ( decimal format ) number format . get instance ( locale . us ) ; format . apply pattern ( str ) ; if ( millis > num ) { time = ( negative ? str : str ) + hours + str + format . format ( min ) + str + format . format ( sec ) ; } else { time = ( negative ? str : str ) + min + str + format . format ( sec ) ; } return time ; }	convert time to a string.
@ inline public static void to ut ( string s , byte buffer b ) { int result index = num ; for ( int i = num , n = s . length ( ) ; i < n ; ++ i ) { char c = s . char at ( i ) ; if ( ( ( ! write pseudo ut ) || ( c >= num ) ) && ( c <= num ) ) { b . put ( ( byte ) c ) ; } else if ( c > num ) { b . put ( ( byte ) ( num | ( byte ) ( c > > num ) ) ) ; b . put ( ( byte ) ( num | ( ( c & num ) > > num ) ) ) ; b . put ( ( byte ) ( num | ( c & num ) ) ) ; } else { b . put ( ( byte ) ( num | ( byte ) ( c > > num ) ) ) ; b . put ( ( byte ) ( num | ( c & num ) ) ) ; } } }	convert the given string into a sequence of ( pseudo - ) utf8 formatted bytes.
public copy on write array list ( e [ ] to copy in ) { set array ( arrays . copy of ( to copy in , to copy in . length , object [ ] . class ) ) ; }	creates a list holding a copy of the given array .
@ override public string buffer format ( long number , string buffer to append to , field position pos ) { return to append to . append ( get direction code ( number ) ) ; }	formats a number into the specified string buffer .
public static void main ( string [ ] args ) throws exception { digest command line arguments ( args ) ; boolean in headless mode = graphics environment . is headless ( ) ; boolean in convert mode = isin convert mode ( ) ; scxml editor = start editor ( in convert mode || in headless mode ) ; if ( isin convert mode ( ) ) { scxml . convert no gui ( editor ) ; } else if ( ! in headless mode ) { string input = get preset input ( ) ; if ( ! string utils . is empty string ( input ) ) { open action open = new open action ( new file ( input ) ) ; open . action performed ( new action event ( editor , num , str ) ) ; } } }	main of the editor application . creates the fsmeditor that is a customgraphcomponent ( jscrollpane ) contains an instance of customgraph ( mxgraph that is mxeventsource ) ) create the interface containing the customgraphcomponent : fsmeditor ( fsmgrapheditor ( jpanel ) ).
public void test equals unequal2 ( ) { string a = str ; int a scale = - num ; string b = str ; int b scale = num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; assert false ( a number . equals ( b number ) ) ; }	equals ( ) for unequal bigdecimals.
protected void enable retransmission timer ( int tick count ) { if ( is invite transaction ( ) && ( this instanceof sip ) ) { retransmission timer ticks left = tick count ; } else { retransmission timer ticks left = math . min ( tick count , get timer t2 ( ) ) ; } retransmission timer last tick count = retransmission timer ticks left ; }	enables retransmission timer events for this transaction to begin after the number of ticks passed to this routine .
private void schedule msg for all consumers ( jetstream message msg ) { if ( logger . is debug enabled ( ) ) logger . debug ( str + msg . to string ( ) ) ; event consumer info info = null ; array list < linked list < selection > > weighted list = m event topic registry . get ( msg . get topic ( ) ) ; if ( weighted list != null ) { iterator < linked list < selection > > weighted itr = weighted list . iterator ( ) ; while ( weighted itr . has next ( ) ) { linked list < selection > consumer list = weighted itr . next ( ) ; iterator < selection > itr = consumer list . iterator ( ) ; while ( itr . has next ( ) ) { info = ( event consumer info ) itr . next ( ) ; if ( info == null ) continue ; dispatch ( info , msg ) ; } } } else { if ( m advisory listener != null ) { post resend advisory ( msg ) ; m no consumer advisories . increment ( ) ; } else { m total msgs dropped . increment ( ) ; m drops for no consumer . increment ( ) ; } } }	spraytoallconsumers - this method is called when the message is tagged for spraying to all consumers .
@ override public void visit declared ( annotated declared type declared type , void a void ) { if ( pause ) { return null ; } parents . push ( declared type ) ; super . visit declared ( declared type , a void ) ; parents . pop ( ) ; return null ; }	sometimes the underlying type parameters of annotatedwildcardtypes are not available on the wildcards themselves.
public class create ( ) { set use cache ( bool ) ; return ( class ) super . create ( this ) ; }	create an interface using the current set of method signatures .
public static < t > list < t > tuple ( t ... objects ) { return collections . unmodifiable list ( list ( objects ) ) ; }	like py . list ( ) , but returns an immutable sequence . < p > named after the same concept in python , which in turn was named after the pre - existing mathematical concept of a " tuple ".
protected static set string array to set ( string [ ] strs ) { int count = strs . length ; set set = ( ( count > num ) ? new hash set ( count ) : new hash set ( ) ) ; for ( int i = num ; i < count ; i ++ ) { set . add ( strs [ i ] ) ; } return set ; }	method to convert a string array to a set.
public boolean authenticate ( final odd callback < auth token > callback ) { synchronized ( sync lock ) { if ( is expired ( ) ) { return bool ; } if ( ! authenticating ) { authenticating = bool ; timer = new timer ( ) ; timer task task = get poll task ( callback ) ; timer . schedule ( task , new date ( ) , interval ) ; timer task expired task = get expired task ( callback ) ; timer . schedule ( expired task , expiration date ) ; } return bool ; } }	if not expired then this will continue polling the server until time expires or an auth token is obtained callback.
public static void cancel notifications for room id ( string account id , string room id ) { log . d ( log tag , str + account id + str + room id ) ; if ( null != m active event stream service ) { m active event stream service . cancel notifications ( account id , room id ) ; } }	cancel the push notifications for a dedicated roomid.
public static optional < player profile > lookup ( uuid id ) { if ( bukkit . get player ( id ) != null ) { return optional . of ( from player ( bukkit . get player ( id ) ) ) ; } return lookup properties ( id ) ; }	lookup a profile with the given uuid the reuturned player profile may or may not include properties.
static double svd dmin ( double a , double b ) { return math . min ( a , b ) ; }	returns the smaller of two double precision numbers.
private storage port select storage port ( list < storage port > sp list ) { collections . shuffle ( sp list ) ; return sp list . get ( num ) ; }	select a storage port from a list of all ports in transport zone and its subset of ports already used for export . todo : - select ports based on load - select ports based on multipath requirement - select ports based on fault domains.
private void assimilate context ( nesting exception nesting exception ) { enumeration < exception context > enum exeptions = nesting exception . get exception contexts ( ) ; if ( enum exeptions . has more elements ( ) ) { while ( enum exeptions . has more elements ( ) ) { add exception context ( enum exeptions . next element ( ) ) ; } nesting exception . clear contexts ( ) ; } }	any outstanding context from the exception provided will be added to this exception.
public boolean equals ( object o ) { if ( o instanceof am ) { am subject = ( am ) o ; return ( subject values . equals ( subject . subject values ) ) ; } return ( bool ) ; }	indicates whether some other object is " equal to " this one .
public void update keyinfo ( string realm , string entity name , map < string , set < string > > ext values , map < string , set < string > > std values , boolean is idp ) throws am { string keysize = get result ( std values , tf key name ) ; string algorithm = get result ( std values , tf algorithm ) ; set < string > signing cert aliases ; set < string > encryption cert aliases ; if ( is idp ) { encryption cert aliases = ext values . get ( idp encrypt cert alias ) ; signing cert aliases = ext values . get ( idp sign cert alias ) ; } else { encryption cert aliases = ext values . get ( sp encrypt cert alias ) ; signing cert aliases = ext values . get ( sp sign cert alias ) ; } int keysi = ! string utils . is empty ( keysize ) ? integer . parse int ( keysize ) : num ; string alg = string utils . is empty ( algorithm ) ? xml . aes 128 : algorithm ; try { sam . update provider key info ( realm , entity name , signing cert aliases , bool , is idp , alg , keysi ) ; sam . update provider key info ( realm , entity name , encryption cert aliases , bool , is idp , alg , keysi ) ; } catch ( sam e ) { debug . warning ( str , e ) ; throw new am ( get error string ( e ) ) ; } }	saves the signing and encryption values for the entity .
public void update slider ( final double p , final boolean n ) { check widget ( ) ; double percentage = p ; if ( step != null ) { percentage = math . round ( percentage / step ) * step ; } this . notify = n ; if ( percentage < num ) { percentage = num ; } else if ( percentage > num ) { percentage = num ; } final int useful width = get client area ( ) . width - thumb width ; final int width = ( int ) math . round ( useful width * percentage ) ; move thumb horizontally ( width ) ; previous position = percentage ; this . notify = bool ; }	method to update current position of the slider.
@ override public boolean contains ( string identifier ) { return whitelist . contains ( identifier ) ; }	checks if an identifier is contained in this strategy .
public static final action [ ] augment list ( action [ ] list1 , action [ ] list2 ) { hashtable < string , action > h = new hashtable < string , action > ( ) ; for ( action a : list1 ) { string value = ( string ) a . get value ( action . name ) ; h . put ( ( value != null ? value : str ) , a ) ; } for ( action a : list2 ) { string value = ( string ) a . get value ( action . name ) ; h . put ( ( value != null ? value : str ) , a ) ; } action [ ] actions = new action [ h . size ( ) ] ; int index = num ; for ( enumeration e = h . elements ( ) ; e . has more elements ( ) ; ) { actions [ index ++ ] = ( action ) e . next element ( ) ; } return actions ; }	takes one list of commands and augments it with another list of commands.
public mv < k , v > open version ( long version ) { if ( read only ) { throw data utils . new unsupported operation exception ( str + str ) ; } data utils . check argument ( version >= create version , str , version , create version ) ; page newest = null ; page r = root ; if ( version >= r . get version ( ) && ( version == write version || r . get version ( ) >= num || version <= create version || store . get file store ( ) == null ) ) { newest = r ; } else { page last = old roots . peek first ( ) ; if ( last == null || version < last . get version ( ) ) { return store . open map version ( version , id , this ) ; } iterator < page > it = old roots . iterator ( ) ; while ( it . has next ( ) ) { page p = it . next ( ) ; if ( p . get version ( ) > version ) { break ; } last = p ; } newest = last ; } mv < k , v > m = open read only ( ) ; m . root = newest ; return m ; }	open an old version for the given map .
public dtm ( dtm mgr , source source , int dtm identity , dtmws white space filter , xml xstringfactory , boolean do indexing , int blocksize , boolean use prevsib , boolean new name table ) { int numblocks ; if ( blocksize <= num ) { numblocks = default numblocks small ; m dtm ident = new suballocated int vector ( num , num ) ; } else { numblocks = default numblocks ; m dtm ident = new suballocated int vector ( num ) ; } m exptype = new suballocated int vector ( blocksize , numblocks ) ; m firstch = new suballocated int vector ( blocksize , numblocks ) ; m nextsib = new suballocated int vector ( blocksize , numblocks ) ; m parent = new suballocated int vector ( blocksize , numblocks ) ; if ( use prevsib ) m prevsib = new suballocated int vector ( blocksize , numblocks ) ; m mgr = mgr ; if ( mgr instanceof dtm ) m mgr default = ( dtm ) mgr ; m document base uri = ( null != source ) ? source . get system id ( ) : null ; m dtm ident . set element at ( dtm identity , num ) ; m wsfilter = white space filter ; m xstrf = xstringfactory ; m indexing = do indexing ; if ( do indexing ) { m expanded name table = new expanded name table ( ) ; } else { m expanded name table = m mgr default . get expanded name table ( this ) ; } if ( null != white space filter ) { m should strip whitespace stack = new bool stack ( ) ; push should strip whitespace ( bool ) ; } }	construct a dtmdefaultbase object from a dom node .
private boolean less than or equal ( byte [ ] a , byte [ ] b ) { int len = math . min ( a . length , b . length ) ; for ( int i = num ; i != len ; ++ i ) { if ( a [ i ] != b [ i ] ) { return ( a [ i ] & num ) < ( b [ i ] & num ) ; } } return len == a . length ; }	return true if a < = b ( arrays are assumed padded with zeros ) .
protected void clear ( ) { parts . clear ( ) ; }	removes all parts from the message.
public static boolean is number ( string s ) { try { integer . value of ( s ) ; return bool ; } catch ( exception e ) { return bool ; } }	checks whether a string is a number .
private boolean is outer g ( ) { return m g . size ( ) == num ; }	return true if the current gstate is the outermost gstate and therefore should not be restored .
public void test case24 ( ) { byte r bytes [ ] = { num } ; big integer a number = big integer . one ; big integer b number = big integer . one ; big integer result = a number . subtract ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( num , result . signum ( ) ) ; }	subtract one from one .
void add ( super card toast super card toast ) { m list . add ( super card toast ) ; }	add a supercardtoast to the list .
static public tasker create ( ) { return new tasker ( ) ; }	simple create task to get us started.
public static string concern stack string ( block info block info ) { string result = str ; for ( string stack entry : block info . thread stack entries ) { if ( character . is letter ( stack entry . char at ( num ) ) ) { string [ ] lines = stack entry . split ( block info . separator ) ; for ( string line : lines ) { string key stack string = concern stack string ( line ) ; if ( key stack string != null ) { return key stack string ; } } return class simple name ( lines [ num ] ) ; } } return result ; }	get key stack string to show as title in ui list .
static string gravity to string ( @ edge gravity int gravity ) { if ( ( gravity & gravity . left ) == gravity . left ) { return str ; } if ( ( gravity & gravity . right ) == gravity . right ) { return str ; } if ( ( gravity & gravity . bottom ) == gravity . bottom ) { return str ; } return integer . to hex string ( gravity ) ; }	simple gravity to string - only supports left and right for debugging output .
public void remove all renderers ( ) { m renderers . clear ( ) ; }	removes all renderers from the multiple renderer .
public static int write speex header ( byte [ ] buf , int offset , int sample rate , int mode , int channels , boolean vbr , int nframes , int packetlength ) { write string ( buf , offset , str ) ; write string ( buf , offset + num , str ) ; system . arraycopy ( new byte [ num ] , num , buf , offset + num , num ) ; write int ( buf , offset + num , num ) ; write int ( buf , offset + num , num ) ; write int ( buf , offset + num , sample rate ) ; write int ( buf , offset + num , mode ) ; write int ( buf , offset + num , num ) ; write int ( buf , offset + num , channels ) ; write int ( buf , offset + num , - num ) ; write int ( buf , offset + num , num << mode ) ; write int ( buf , offset + num , vbr ? num : num ) ; write int ( buf , offset + num , nframes ) ; write int ( buf , offset + num , num ) ; write int ( buf , offset + num , packetlength ) ; write int ( buf , offset + num , num ) ; return num ; }	writes a speex header to the given byte array .
private static file ignite hadoop config ( string ignite home ) { path path = paths . get ( ignite home , str , str , str ) ; if ( ! files . exists ( path ) ) path = paths . get ( ignite home , str , str ) ; if ( files . exists ( path ) ) return path . to file ( ) ; else return new file ( ignite home , str ) ; }	get ignite hadoop config directory .
protected approximation line conservative knn distance approximation ( int k max ) { int k 0 = k max ; double y 1 = double . negative infinity ; double y kmax = double . negative infinity ; for ( int i = num ; i < get num entries ( ) ; i ++ ) { p entry = get entry ( i ) ; approximation line approx = entry . get conservative knn distance approximation ( ) ; k 0 = math . min ( approx . get k 0 ( ) , k 0 ) ; } for ( int i = num ; i < get num entries ( ) ; i ++ ) { p entry = get entry ( i ) ; approximation line approx = entry . get conservative knn distance approximation ( ) ; double entry y 1 = approx . get value at ( k 0 ) ; double entry y kmax = approx . get value at ( k max ) ; if ( ! double . is infinite ( entry y 1 ) ) { y 1 = math . max ( entry y 1 , y 1 ) ; } if ( ! double . is infinite ( entry y kmax ) ) { y kmax = math . max ( entry y kmax , y kmax ) ; } } double m = ( y kmax - y 1 ) / ( math . log ( k max ) - math . log ( k 0 ) ) ; double t = y 1 - m * math . log ( k 0 ) ; return new approximation line ( k 0 , m , t ) ; }	determines and returns the conservative approximation for the knn distances of this node as the maximum of the conservative approximations of all entries .
public final boolean shares layer ( brd item p other ) { int max first layer = math . max ( first layer ( ) , p other . first layer ( ) ) ; int min last layer = math . min ( last layer ( ) , p other . last layer ( ) ) ; return max first layer <= min last layer ; }	returns true , if some shapes of this item and p_other are on the same layer .
public coap client ( uri uri ) { this ( uri . to string ( ) ) ; }	constructs a new coapclient that sends request to the specified uri .
private void zero ( ) throws json { if ( probe ) { log ( num ) ; } write ( num , num ) ; }	output a zero bit .
public static boolean been done ( time unit time unit , long amount , string tag , count checker number of times ) { long time in millis = time unit . to millis ( amount ) ; return been done ( time in millis , tag , number of times ) ; }	checks if a tag has been marked done within a given time span a specific number of times.
public static string normalize ( string oid ) { return oid . starts with ( str ) ? oid . substring ( num ) : oid ; }	removes leading " oid . " from oid string passed.
public void reset ( ) { initialize ( ) ; }	wipe out existing jamon data.
private static void add listeners for real ( final service service , final set < listener > existing listeners , final listener listener , final executor executor ) { if ( ! existing listeners . contains ( listener ) ) { existing listeners . add ( listener ) ; service . add listener ( listener , executor ) ; } }	adds the given listener to the service.
public void prepend ( char sequence s ) { text . insert ( num , s ) ; }	add a string to the start of the first line of the buffer .
public static void send response with status ( http servlet request request , http servlet response response , print writer out , string idp meta alias , string idp entity id , string realm , authn request authn req , string relay state , string sp entity id , string firstlevel status code value , string secondlevel status code value ) throws sam { response res = sam . get error response ( authn req , firstlevel status code value , secondlevel status code value , null , idp entity id ) ; string buffer returned binding = new string buffer ( ) ; string acs url = idpsso . get ac ( sp entity id , realm , authn req , request , returned binding ) ; string acs binding = returned binding . to string ( ) ; send response ( request , response , out , acs binding , sp entity id , idp entity id , idp meta alias , realm , relay state , acs url , res , null ) ; }	a convenience method to construct response with first - level and second - level status code for saml authentication requests .
public static double mean2 ( connection conn , double ... values ) { conn . get class ( ) ; double sum = num ; for ( double x : values ) { sum += x ; } return sum / values . length ; }	this method is called via reflection from the database .
public boolean has long column info ( ) { return this . has long column info ; }	does the server send back extra column info ?.
public static string dom to string ( document dom doc ) { return dom to string ( dom doc . get document element ( ) , bool ) ; }	converts a dom to a string.
public static < t > t assert and cast ( class < ? extends t > clazz , object o ) { assert not null ( clazz ) ; assert not null ( o ) ; assert true ( clazz . is instance ( o ) ) ; return clazz . cast ( o ) ; }	given a type and an object asserts that the object is non - null and an instance of the specified type.
private string create mismatch message ( string mismatch , migration version version , object applied , object resolved ) { return string . format ( str + mismatch + str + str + str , version , applied , resolved ) ; }	creates a message for a mismatch .
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return ids ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public int compare to ( object o ) { split split = ( split ) o ; bit set p = get first part ( ) ; bit set q = split . get first part ( ) ; int a = p . next set bit ( num ) ; int b = q . next set bit ( num ) ; while ( a > - num && b > - num ) { if ( a < b ) return - num ; else if ( a > b ) return num ; a = p . next set bit ( a + num ) ; b = q . next set bit ( b + num ) ; } if ( a < b ) return - num ; else if ( a > b ) return num ; p = get second part ( ) ; q = split . get second part ( ) ; a = p . next set bit ( num ) ; b = q . next set bit ( num ) ; while ( a > - num && b > - num ) { if ( a < b ) return - num ; else if ( a > b ) return num ; a = p . next set bit ( a + num ) ; b = q . next set bit ( b + num ) ; } if ( a < b ) return - num ; else if ( a > b ) return num ; else return num ; }	compare to a split object.
public boolean is matching talkgroup ( ltr message ) { string talkgroup = message . get talkgroup id ( ) ; if ( talkgroup != null && get to id ( ) != null && talkgroup . content equals ( get to id ( ) ) ) { return bool ; } return is matching talkgroup ( message . get talkgroup id ( ) ) ; }	checks if the message ' s talkgroup matches this call event.
public void put ( byte [ ] source , int index , int length ) { if ( m buffer . capacity ( ) < ( m length + length ) ) { expand buffer ( m length + length + additional buffer size ) ; } m buffer . put ( source , index , length ) ; m length += length ; }	add data at the current position .
public void test set bit negative inside4 ( ) { string as = str ; int number = num ; big integer a number = new big integer ( as ) ; big integer result = a number . set bit ( number ) ; assert equals ( as , result . to string ( ) ) ; }	setbit ( 0 ) in the negative number of length 1 with all ones in bit representation.
public shape model to view ( int pos , shape a , position . bias b ) throws bad location exception { return m view . model to view ( pos , a , b ) ; }	provides a mapping from the document model coordinate space to the coordinate space of the view mapped to it .
private static int apply precision ( int dec exp , char [ ] digits , int n digits , int prec ) { if ( prec >= n digits || prec < num ) { return dec exp ; } if ( prec == num ) { if ( digits [ num ] >= str ) { digits [ num ] = str ; arrays . fill ( digits , num , n digits , str ) ; return dec exp + num ; } else { arrays . fill ( digits , num , n digits , str ) ; return dec exp ; } } int q = digits [ prec ] ; if ( q >= str ) { int i = prec ; q = digits [ -- i ] ; if ( q == str ) { while ( q == str && i > num ) { q = digits [ -- i ] ; } if ( q == str ) { digits [ num ] = str ; arrays . fill ( digits , num , n digits , str ) ; return dec exp + num ; } } digits [ i ] = ( char ) ( q + num ) ; arrays . fill ( digits , i + num , n digits , str ) ; } else { arrays . fill ( digits , prec , n digits , str ) ; } return dec exp ; }	returns new decexp in case of overflow .
public void delete ( @ non null key key ) { final reentrant read write lock . write lock lock = guard . write lock ( ) ; lock . lock ( ) ; try { if ( ! read keys . remove ( key ) ) throw new illegal argument exception ( str ) ; files . delete ( key . get file ( ) ) ; } catch ( io ex ) { log . log ( level . warning , str + key . get file ( ) , ex ) ; } finally { lock . unlock ( ) ; } }	removes the file associated with the given key .
public void write to file ( string file name ) throws io { print writer outfile = new print writer ( new file output stream ( file name ) ) ; outfile . println ( str ) ; outfile . println ( str ) ; outfile . println ( str + m nbins ) ; outfile . println ( str + m min ) ; outfile . println ( str + m max ) ; outfile . println ( str + m entries ) ; outfile . println ( str + m underflow ) ; outfile . println ( str + m overflow ) ; outfile . println ( str ) ; for ( int i = num ; i < m nbins ; i ++ ) { outfile . println ( i + str + m bin centers [ i ] + str + m hist [ i ] ) ; } outfile . println ( str ) ; outfile . close ( ) ; }	save the histogram data to a file.
public void outdent ( ) { final int length = indent . length ( ) ; if ( length == num ) { throw new illegal argument exception ( str ) ; } indent . delete ( length - num , length ) ; }	reduces the current indent level by two spaces , or crashes if the indent level is zero .
public static string extract from data matrix ( string code ) { if ( code . length ( ) < num ) { return null ; } if ( code . starts with ( str ) ) { return code . substring ( num , num ) ; } return null ; }	extracts a gtin from a gs1 datamatrix formatted bar code .
@ override public audio input stream synthesise one section ( string festival utt , voice voice ) throws io { write relation files ( festival utt ) ; file audio file = new file ( festival dir . get path ( ) + file . separator + str ) ; string festival voice cmd = str + voice . get name ( ) + str ; audio input stream sound = festival synthesise ( audio file , festival voice cmd ) ; return sound ; }	process a single utterance in festival_utt text format .
public int read ( byte [ ] buffer , int offset , int length ) throws io { log . finest ( str + long . to hex string ( get file pointer ( ) ) + str + length + str ) ; return file . read ( buffer , offset , length ) ; }	reads a block from a given location .
public static pattern create pattern ( string [ ] patterns , boolean is case sensitive , boolean is regex search ) throws pattern syntax exception { string buffer pattern = new string buffer ( ) ; for ( int i = num ; i < patterns . length ; i ++ ) { if ( i > num ) { pattern . append ( str ) ; } if ( is regex search ) { pattern . append ( patterns [ i ] ) ; } else { as reg ex ( patterns [ i ] , pattern ) ; } } return create pattern ( pattern . to string ( ) , is case sensitive , bool ) ; }	creates a pattern element from the pattern string which is either a reg - ex expression or in our old ' stringmatcher ' format .
public void add arc ( float lat point , float lon point , int w , int h , float s , float e , link properties properties ) throws io { link arc . write ( lat point , lon point , num , num , w , h , s , e , properties , link . dos ) ; }	write an arc with lat / lon placement .
public void on undeploy ( class loader ldr ) { for ( class < ? > cls : desc by cls . key set ( ) ) { if ( ldr . equals ( cls . get class loader ( ) ) ) desc by cls . remove ( cls ) ; } u . clear class cache ( ldr ) ; }	undeployment callback invoked when class loader is being undeployed.
@ override public boolean contains class ( string class name ) throws io { boolean contains class = bool ; string resource name = str + class name . replace ( str , str ) + str ; if ( get resource ( resource name ) != null ) { contains class = bool ; } for ( string resource : get resources ( str ) ) { jar archive jar = new default jar archive ( get resource ( resource ) ) ; if ( jar . contains class ( class name ) ) { contains class = bool ; } } return contains class ; }	returns whether a class of the specified name is contained in the web - app archive , either directly in web - inf / classes , or in one of the jars in web - inf / lib .
public tuple [ ] clear internal ( ) { tuple [ ] t = new tuple [ get tuple count ( ) ] ; iterator iter = tuples ( ) ; for ( int i = num ; iter . has next ( ) ; ++ i ) { t [ i ] = ( tuple ) iter . next ( ) ; } m tuples . clear ( ) ; return t ; }	clear the internal state without firing a notification .
private void ensure capacity ( int desired long count ) { if ( desired long count <= bits . length ) { return ; } int new length = math . max ( desired long count , bits . length * num ) ; long [ ] new bits = new long [ new length ] ; system . arraycopy ( bits , num , new bits , num , long count ) ; this . bits = new bits ; }	ensures that our long [ ] can hold at least 64 * desiredlongcount bits .
public boolean matches ( string query , string text ) { return text . contains ( query ) ; }	simple check if query string is a substring of a block of text .
private void find collapses from existing vertices ( list collapsed vertex indexes ) { for ( int i = num ; i < edge . size ( ) - num ; i ++ ) { coordinate p0 = edge . get coordinate ( i ) ; coordinate p1 = edge . get coordinate ( i + num ) ; coordinate p2 = edge . get coordinate ( i + num ) ; if ( p0 . equals2 d ( p2 ) ) { collapsed vertex indexes . add ( new integer ( i + num ) ) ; } } }	adds nodes for any collapsed edge pairs which are pre - existing in the vertex list .
public void close ( ) throws io { if ( debug . debugging ( str ) ) { debug . output ( str ) ; } try { if ( input file != null ) input file . close ( ) ; } catch ( exception e ) { e . print stack trace ( ) ; } input file = null ; }	closes the underlying file.
public static boolean check pool properties changed ( set < string > existing value , set < string > new value ) { boolean property changed = bool ; if ( existing value == null && ( new value != null && ! new value . is empty ( ) ) ) { property changed = bool ; } else if ( new value == null && ( existing value != null && ! existing value . is empty ( ) ) ) { property changed = bool ; } else if ( existing value != null && new value != null ) { if ( existing value . size ( ) != new value . size ( ) || ! ( existing value . contains all ( new value ) ) ) { property changed = bool ; } } return property changed ; }	compares the two given sets.
public static output stream left shift ( output stream self , input stream in ) throws io { byte [ ] buf = new byte [ num ] ; while ( bool ) { int count = in . read ( buf , num , buf . length ) ; if ( count == - num ) break ; if ( count == num ) { thread . yield ( ) ; continue ; } self . write ( buf , num , count ) ; } self . flush ( ) ; return self ; }	pipe an inputstream into an outputstream for efficient stream copying .
public static boolean git local config ( final atomic reference < string > path ) throws io { return git local config ( environment . get current directory ( ) , path ) ; }	gets the path to the git local configuration file based on the current working directory .
public void verify ( ) { super . verify ( ) ; assert equals ( str , confirmed , collection ) ; assert equals ( str , confirmed . hash code ( ) , collection . hash code ( ) ) ; collection set = make confirmed collection ( ) ; iterator iterator = collection . iterator ( ) ; while ( iterator . has next ( ) ) { assert true ( str , set . add ( iterator . next ( ) ) ) ; } }	provides additional verifications for sets .
public static cg ccp rotate by angle ( cg v , cg pivot , float angle ) { cg r = ccp sub ( v , pivot ) ; float t = r . x ; float cosa = ( float ) math . cos ( angle ) ; float sina = ( float ) math . sin ( angle ) ; r . x = t * cosa - r . y * sina ; r . y = t * sina + r . y * cosa ; r = ccp add ( r , pivot ) ; return r ; }	rotates a point counter clockwise by the angle around a pivot.
private void open context menu ( mouse event e ) { if ( e . is popup trigger ( ) ) { collection < string > streams = new hash set < > ( ) ; int [ ] selected rows = table . get selected rows ( ) ; for ( int selected row : selected rows ) { follower selected = followers . get ( selected row ) ; streams . add ( string util . to lower case ( selected . name ) ) ; } if ( ! streams . is empty ( ) ) { streams context menu m = new streams context menu ( streams , context menu listener ) ; m . show ( table , e . get x ( ) , e . get y ( ) ) ; } } }	open the context menu for the given mouseevent if it is the popup trigger and rows are selected .
public static workflow . method expand volumes method ( uri storage , uri pool , uri volume , long size ) { return new workflow . method ( str , storage , pool , volume , size ) ; }	return a workflow . method for expandvolume .
void close silently ( socket socket ) { try { socket . close ( ) ; } catch ( exception e ) { } }	close a socket , ignoring errors.
public static boolean equals ( byte [ ] array1 , byte [ ] array2 ) { if ( array1 == array2 ) return bool ; if ( array1 == null || array2 == null || array1 . length != array2 . length ) return bool ; for ( int i = num ; i < array1 . length ; i ++ ) { if ( array1 [ i ] != array2 [ i ] ) return bool ; } return bool ; }	compares the two arrays .
private static string create id from jndi location if not null ( string jndi location ) { string id = null ; if ( jndi location != null ) { id = create id from jndi location ( jndi location ) ; } return id ; }	return a string that can be used to name this configuration or null , if jndilocation was not specified .
protected set < node > closure ( dependency kind ... dep kinds ) { boolean progress = bool ; set < node > closure = new hash set < node > ( ) ; closure . add ( this ) ; while ( progress ) { progress = bool ; for ( node n1 : new hash set < node > ( closure ) ) { progress = closure . add all ( n1 . get dependencies ( dep kinds ) ) ; } } return closure ; }	compute closure of a give node , by recursively walking through all its dependencies ( of given kinds ).
public vector ( collection c ) { element count = c . size ( ) ; element data = new object [ ( int ) math . min ( ( element count * num ) / num , integer . max value ) ] ; c . to array ( element data ) ; }	constructs a vector containing the elements of the specified collection , in the order they are returned by the collection ' s iterator .
public static < a extends annotation > a create annotation ( class < ? extends annotation > annotation type , annotation member [ ] elements ) { annotation factory factory = new annotation factory ( annotation type , elements ) ; return ( a ) proxy . new proxy instance ( annotation type . get class loader ( ) , new class [ ] { annotation type } , factory ) ; }	provides a new annotation instance .
public linking morphemes ( string ... a morphemes ) { morphemes = new array list < string > ( ) ; for ( string string : a morphemes ) { morphemes . add ( string ) ; } }	create a linking morphemes object from a array of morphemes.
@ override public void execute ( metric time series time series , function value map function value map ) { if ( time series . size ( ) <= num ) { function value map . add ( this , double . n ) ; return ; } time series . sort ( ) ; double first value = time series . get value ( num ) ; double last value = time series . get value ( time series . size ( ) - num ) ; function value map . add ( this , math . abs ( first value - last value ) ) ; }	calculate the difference between the first and the last value of a given time series.
public static url [ ] find resource bases ( string base resource , class loader loader ) { array list < url > list = new array list < url > ( ) ; try { enumeration < url > urls = loader . get resources ( base resource ) ; while ( urls . has more elements ( ) ) { url url = urls . next element ( ) ; list . add ( find resource base ( url , base resource ) ) ; } } catch ( io e ) { throw new runtime exception ( e ) ; } return list . to array ( new url [ list . size ( ) ] ) ; }	find the classpath urls for a specific classpath resource.
public writable raster create writable child ( int x , int y , int width , int height , int x0 , int y0 , int band list [ ] ) { if ( x < this . min x ) { throw new raster format exception ( str ) ; } if ( y < this . min y ) { throw new raster format exception ( str ) ; } if ( ( x + width < x ) || ( x + width > this . width + this . min x ) ) { throw new raster format exception ( str ) ; } if ( ( y + height < y ) || ( y + height > this . height + this . min y ) ) { throw new raster format exception ( str ) ; } sample model sm ; if ( band list != null ) sm = sample model . create subset sample model ( band list ) ; else sm = sample model ; int delta x = x0 - x ; int delta y = y0 - y ; return new byte banded raster ( sm , data buffer , new rectangle ( x0 , y0 , width , height ) , new point ( sample model translate x + delta x , sample model translate y + delta y ) , this ) ; }	creates a writable subraster given a region of the raster.
protected void move up item ( ) { if ( selection table . get selection count ( ) == num ) { return ; } for ( final int index : selection table . get selection indices ( ) ) { if ( index == num ) { selection table . force focus ( ) ; return ; } } final int [ ] new selection = new int [ selection table . get selection count ( ) ] ; int new selection index = num ; for ( final table item table item : selection table . get selection ( ) ) { final int position = selection . index of ( table item . get data ( ) ) ; swap ( position , position - num ) ; new selection [ new selection index ++ ] = position - num ; } redraw tables ( ) ; selection table . select ( new selection ) ; selection table . force focus ( ) ; }	move the selected item up.
protected void maybe fire bounds invalidated ( rectangle invalidated area ) { drawing d = get drawing ( ) ; d . double canvas bounds = new d . double ( num , num , num , num ) ; if ( d . get ( canvas width ) != null ) { canvas bounds . width += d . get ( canvas width ) ; } if ( d . get ( canvas height ) != null ) { canvas bounds . height += d . get ( canvas height ) ; } if ( ! canvas bounds . contains ( invalidated area ) ) { fire bounds invalidated ( invalidated area ) ; } }	notify all listenerlist that have registered interest for notification on this event type.
public void suspend ( string id ) { trace state ts = trace state . get ( ) ; if ( log . is loggable ( level . finest ) ) { log . finest ( str + ts + str + id ) ; } if ( ts != null ) { set expire ( ts ) ; try { suspended state lock . lock ( ) ; if ( suspended state . contains key ( id ) && log . is loggable ( level . finest ) ) { log . finest ( str + suspended state . get ( id ) + str + id ) ; } suspended state . put ( id , ts ) ; trace state . remove ( ) ; } finally { suspended state lock . unlock ( ) ; } } }	this method suspends any current trace state , associated with this thread , and associates it with the supplied id.
public static int hash code ( final object obj ) { return ( obj == null ? num : obj . hash code ( ) ) ; }	a null - safe computation of the specified object ' s hash value.
public static int max level ( ) { return levels - num ; }	gets the highest level.
public void property change ( property change event evt ) { repaint ( ) ; }	react to property changes by repainting .
public static boolean remove bean or folder ( string path ) { return remove path ( path . split ( path separator ) , s directory , num ) > num ; }	removes a bean or tree from the directory .
private void update selection ( mode mode , d proj , svg p1 , svg p2 ) { dbid sel context = context . get selection ( ) ; dbi selection ; if ( sel context == null || mode == mode . replace ) { selection = dbid . new hash set ( ) ; } else { selection = dbid . new hash set ( sel context . get selected ids ( ) ) ; } for ( dbid iditer = rel . iter dbi ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { double [ ] vec = proj . fast project data to render space ( rel . get ( iditer ) ) ; if ( vec [ num ] >= math . min ( p1 . get x ( ) , p2 . get x ( ) ) && vec [ num ] <= math . max ( p1 . get x ( ) , p2 . get x ( ) ) && vec [ num ] >= math . min ( p1 . get y ( ) , p2 . get y ( ) ) && vec [ num ] <= math . max ( p1 . get y ( ) , p2 . get y ( ) ) ) { if ( mode == mode . invert ) { if ( ! selection . contains ( iditer ) ) { selection . add ( iditer ) ; } else { selection . remove ( iditer ) ; } } else { selection . add ( iditer ) ; } } } context . set selection ( new dbid ( selection ) ) ; }	updates the selection in the context . < br >.
public eclipse ini launcher ( file installation root ) throws file not found exception , io { file misc . assert mac app ( installation root ) ; objects . require non null ( installation root ) ; eclipse ini = eclipse ini . parse from ( new file ( installation root , file misc . mac contents eclipse ( ) + str ) ) ; }	wraps a directory of jars in the launcher api , and ensures the the directory contains the plugins required to run a barebones equinox instance .
public boolean can add member ( string realm name , string id type , string container id ) throws am { boolean can = bool ; try { id type type = id utils . get type ( id type ) ; set can add = type . can add members ( ) ; id type ctype = id utils . get type ( container id ) ; can = can add . contains ( ctype ) ; } catch ( id repo exception e ) { debug . warning ( str , e ) ; throw new am ( get error string ( e ) ) ; } return can ; }	returns true of members can be added to a type .
public static double cos quick ( double angle ) { if ( use jdk math ) { return strict math ? strict math . cos ( angle ) : math . cos ( angle ) ; } return cos tab [ ( ( int ) ( math . abs ( angle ) * sin cos indexer + num ) ) & ( sin cos tabs size - num ) ] ; }	quick cosine , with accuracy of about 1.
public void read security header ( sip response response ) throws payload exception { www www header = ( www ) response . get header ( www . name ) ; authentication info header info header = ( authentication info header ) response . get header ( authentication info header . name ) ; if ( www header != null ) { m digest . set realm ( www header . get realm ( ) ) ; m digest . set opaque ( www header . get opaque ( ) ) ; m digest . set qop ( www header . get qop ( ) ) ; m digest . set nextnonce ( www header . get nonce ( ) ) ; } else if ( info header != null ) { if ( info header . get next nonce ( ) != null ) { m digest . set nextnonce ( info header . get next nonce ( ) ) ; } } }	read security header from register response.
private void layout panel ( ) { set border ( border factory . create empty border ( num , num , num , num ) ) ; set layout ( new border layout ( ) ) ; add ( new labelled item ( str , cb distribution ) , border layout . north ) ; add ( card panel , border layout . center ) ; cb item listener . item state changed ( new item event ( cb distribution , item event . selected , card panel , item event . item state changed ) ) ; repaint ( ) ; revalidate ( ) ; }	lays out the panel.
@ override public int compare to ( double double pair other ) { int fdiff = double . compare ( this . first , other . first ) ; if ( fdiff != num ) { return fdiff ; } return double . compare ( this . second , other . second ) ; }	implementation of comparable interface , sorting by first then second .
private static boolean file exists ( string file path ) { file file = new file ( file path ) ; return file . exists ( ) ; }	check if a file exists on device.
public static string class version to jdk ( int version ) { return str + integer . to string ( version - num ) ; }	converts a class file version number jdk string like 1.
private bit set create bit set ( final string binary string ) { final bit set bset = new bit set ( binary string . length ( ) ) ; boolean bit true = bool ; for ( int i = num ; i < binary string . length ( ) ; i ++ ) { if ( binary string . char at ( i ) == str ) { bit true = bool ; } else { bit true = bool ; } bset . set ( i , bit true ) ; } return bset ; }	creates a bitset based on a string representation of binary digits .
public void flush ( ) { buffer . force ( ) ; }	flushes the mapped buffer to disk .
public void remove ( product product ) { try { solr dao . remove ( product . get id ( ) ) ; } catch ( io | solr server exception ex ) { logger . error ( str + product . get identifier ( ) + str , ex ) ; } }	removes the given product from the index .
public void start background fetch service ( ) { local notification n = new local notification ( ) ; n . set id ( background fetch notification id ) ; cancel local notification ( background fetch notification id ) ; schedule local notification ( n , system . current time millis ( ) + get preferred background fetch interval ( ) * num , num ) ; }	starts the background fetch service .
protected void show models ( boolean show , epoxy model < ? > ... models ) { show models ( arrays . as list ( models ) , show ) ; }	sets the visibility of the given models , and notifies that the items changed if the new visibility is different from the previous .
static void check ( public key key , crl crl ) throws cert path validator exception { crl x509 crl = null ; try { x509 crl = crl . to impl ( crl ) ; } catch ( crl ce ) { throw new cert path validator exception ( ce ) ; } algorithm id algorithm id = x509 crl . get sig alg id ( ) ; check ( key , algorithm id ) ; }	check the signature algorithm with the specified public key .
public void test user data handler notified of only shallow adoptions ( ) throws exception { dom to string ( document ) ; recording handler handler = new recording handler ( ) ; name . set user data ( str , str , handler ) ; name . set user data ( str , str , handler ) ; standard . set user data ( str , str , handler ) ; waffles . set user data ( str , str , handler ) ; document new document = builder . new document ( ) ; assert same ( name , new document . adopt node ( name ) ) ; assert same ( new document , name . get owner document ( ) ) ; assert same ( new document , standard . get owner document ( ) ) ; assert same ( new document , waffles . get owner document ( ) ) ; set < string > expected = new hash set < string > ( ) ; expected . add ( notification ( node adopted , str , str , name , null ) ) ; expected . add ( notification ( node adopted , str , str , name , null ) ) ; assert equals ( expected , handler . calls ) ; }	there should be notifications for adopted node itself but none of its children.
public void reset ( ) { node list . clear ( ) ; }	sets the stack to empty .
public string name list ( string dir ) throws io { passive ( ) ; send ( str + dir ) ; read code ( num ) ; byte array output stream out = new byte array output stream ( ) ; io . copy and close ( in data , out ) ; read code ( num ) ; byte [ ] data = out . to byte array ( ) ; return new string ( data ) ; }	get the directory listing ( nlst ) .
public vn add luns to lun group ( string lun group id , list < string > luns ) { lun group modify param param = new lun group modify param ( ) ; list < lun add param > lun adds = new array list < lun add param > ( ) ; for ( string lun id : luns ) { vn lun = new vn ( lun id ) ; lun add param lun add = new lun add param ( ) ; lun add . set lun ( lun ) ; lun adds . add ( lun add ) ; } param . set lun add ( lun adds ) ; lun group requests req = new lun group requests ( kh client ) ; return req . modify lun group sync ( lun group id , param ) ; }	add luns to lungroup.
public static constant expression constant ( object value , class constant type ) { return new constant expression ( value , constant type . get name ( ) ) ; }	constant , use when the value is null .
public void end element ( string uri , string local name , string q name ) throws sax { if ( ! ( html mode && ( uri . equals ( str ) || uri . equals ( str ) ) && ( q name . equals ( str ) || q name . equals ( str ) || q name . equals ( str ) || q name . equals ( str ) || q name . equals ( str ) || q name . equals ( str ) || q name . equals ( str ) || q name . equals ( str ) || q name . equals ( str ) || q name . equals ( str ) || q name . equals ( str ) || q name . equals ( str ) || q name . equals ( str ) ) ) ) { write ( str ) ; write name ( uri , local name , q name , bool ) ; write ( str ) ; } if ( element level == num ) { write ( str ) ; } cdata element = bool ; super . end element ( uri , local name , q name ) ; ns support . pop context ( ) ; element level -- ; }	write an end tag.
static void find all visible childs ( final view group view group , final list < view > ordored childs ) { for ( int child view index = num ; child view index < view group . get child count ( ) ; child view index ++ ) { final view child view = view group . get child at ( child view index ) ; if ( child view instanceof view group ) { find all visible childs ( ( view group ) child view , ordored childs ) ; continue ; } if ( child view . get visibility ( ) == view . visible ) { ordored childs . add ( child view ) ; } } }	helps to find recursivly all visible childs in a view group .
public boolean log modified ( logger log ) { if ( is modified ( ) ) { log . info ( class name + str ) ; return bool ; } else return bool ; }	returns true if the underlying resource has changed .
public string serialize ( object obj ) throws api exception { try { if ( obj != null ) return mapper . write value as string ( obj ) ; else return null ; } catch ( exception e ) { throw new api exception ( num , e . get message ( ) ) ; } }	serialize the given java object into json string .
private void initialize sparse slider ( ) { sparsity slider . set major tick spacing ( num ) ; sparsity slider . set minor tick spacing ( num ) ; sparsity slider . set paint ticks ( bool ) ; hashtable < integer , j > label table2 = new hashtable < integer , j > ( ) ; label table2 . put ( new integer ( num ) , new j ( str ) ) ; label table2 . put ( new integer ( num ) , new j ( str ) ) ; sparsity slider . set label table ( label table2 ) ; sparsity slider . set paint labels ( bool ) ; }	initializes the sparse slider .
@ override protected void auto adjust range ( ) { plot plot = get plot ( ) ; if ( plot == null ) { return ; } if ( plot instanceof value axis plot ) { value axis plot vap = ( value axis plot ) plot ; range r = vap . get data range ( this ) ; if ( r == null ) { r = get default auto range ( ) ; } double upper = r . get upper bound ( ) ; double lower = math . max ( r . get lower bound ( ) , this . smallest value ) ; double range = upper - lower ; double fixed auto range = get fixed auto range ( ) ; if ( fixed auto range > num ) { lower = math . max ( upper - fixed auto range , this . smallest value ) ; } else { double min range = get auto range minimum size ( ) ; if ( range < min range ) { double expand = ( min range - range ) / num ; upper = upper + expand ; lower = lower - expand ; } double log upper = calculate log ( upper ) ; double log lower = calculate log ( lower ) ; double log range = log upper - log lower ; log upper = log upper + get upper margin ( ) * log range ; log lower = log lower - get lower margin ( ) * log range ; upper = calculate value no inf ( log upper ) ; lower = calculate value no inf ( log lower ) ; } set range ( new range ( lower , upper ) , bool , bool ) ; } }	adjusts the axis range to match the data range that the axis is required to display .
public synchronized void add ( long value ) { long res = get ( ) + value ; lb . put ( num , res ) ; }	adds the given value to the perf counter .
public void add iv ( int attack iv , int defense iv , int stamina iv ) { int sum iv = attack iv + defense iv + stamina iv ; int percent perfect = math . round ( sum iv / num * num ) ; if ( ( percent perfect < low percent ) || ( percent perfect == low percent ) && ( attack iv < low attack ) ) { low percent = percent perfect ; low attack = attack iv ; low defense = defense iv ; low stamina = stamina iv ; } if ( ( percent perfect > high percent ) || ( percent perfect == high percent ) && ( attack iv > high attack ) ) { high percent = percent perfect ; high attack = attack iv ; high defense = defense iv ; high stamina = stamina iv ; } i v . add ( new iv ( attack iv , defense iv , stamina iv ) ) ; }	adds an iv possibility to the scan results .
@ nullable public bitmap generate icon for url ( string url , boolean include private registries ) { if ( text utils . is empty ( url ) ) return null ; string text = get icon text for url ( url , include private registries ) ; if ( text utils . is empty ( text ) ) return null ; return generate icon for text ( text ) ; }	returns a bitmap representing the icon to be used for | url | .
public boolean contains prefix ( final char sequence prefix ) { return contains prefix ( prefix , num , prefix . length ( ) ) ; }	checks if the given string is a prefix of a key in the trie .
public int compare to ( object p other ) { if ( p other == null ) return num ; if ( p other instanceof brd component ) { return name . compare to ignore case ( ( ( brd component ) p other ) . name ) ; } return num ; }	compares 2 components by name.
public void fatal ( string message ) throws sax { sax spe = new sax ( message , this ) ; if ( error handler != null ) { error handler . fatal error ( spe ) ; } throw spe ; }	reports an condition that would make the infoset incompatible with xml 1.
protected final void fire property change ( string property name , boolean old value , boolean new value ) { property change support a change support = this . change support ; if ( a change support == null ) { return ; } a change support . fire property change ( property name , old value , new value ) ; }	support for reporting bound property changes for boolean properties.
private iterator < binding set > join binding set entry ( map . entry < string , binding set > entry ) { list < collection < binding set > > matches = new array list < > ( ) ; if ( type == hash join type . constant join var ) { if ( binding join var hash . contains key ( entry . get key ( ) ) ) { matches . add ( binding join var hash . get ( entry . get key ( ) ) ) ; } } else { list < string > val orders = get value orders ( entry . get key ( ) ) ; for ( string s : val orders ) { if ( binding join var hash . contains key ( s ) ) { matches . add ( binding join var hash . get ( s ) ) ; } } } if ( matches . size ( ) == num ) { return collections . empty iterator ( ) ; } else { return new binding set collections join iterator ( entry . get value ( ) , matches ) ; } }	this method returns an iterator which joins the given entry ' s bindingset to all bindingsets which matching the entry ' s key .
@ override public void test ( number t ) throws parameter exception { if ( t . double value ( ) >= constraint value . double value ( ) ) { throw new wrong parameter value exception ( str + str + constraint value . to string ( ) + str + t . double value ( ) + str ) ; } }	checks if the number value given by the number parameter is less than the constraint value.
public void test find users active directory ( ) throws exception { ldap manager mgr = get ldap ad ( ) ; list ret = null ; and filter filter = new and filter ( ) ; filter . and ( new like filter ( mgr . get users returning attribute ( ldap user attribute constants . ldap user attribute given name ) , str ) ) ; try { vo search mgr vo = new vo ( ) ; search mgr vo . set filter ( filter ) ; search mgr vo . set add user classes ( bool ) ; ret = mgr . find users ( search mgr vo ) ; } catch ( exception e ) { } assert equals ( num , ret . size ( ) ) ; }	test de busqueda de varios usuarios para active directory.
public boolean reserve ( object object ) { reserved ids lock . lock ( ) ; if ( reserved objects . contains ( object ) ) { reserved ids lock . unlock ( ) ; return bool ; } reserved objects . add ( object ) ; reserved ids lock . unlock ( ) ; return bool ; }	reserve an object , returning true when successfully reserved or false when the object is already reserved .
private boolean save stored jpeg ( string file name , final buffered image image , final boolean file name is path ) { if ( ! file name is path ) { file name = temp dir + key + file name ; } final string s = file name . to lower case ( ) ; if ( ! s . ends with ( str ) && ! s . ends with ( str ) ) { file name += str ; } try { default image helper . write ( image , str , file name ) ; temp file names . put ( file name , str ) ; } catch ( final exception e ) { log writer . write log ( str + e + str + image + str + file name ) ; } return bool ; }	save buffered image as jpeg.
public static scheduled executor service create scheduler ( ) { final scheduled executor service scheduler = executors . new scheduled thread pool ( num , new daemon thread factory ( default scheduler name ) ) ; schedulers . add ( scheduler ) ; return scheduler ; }	creates a single - threaded scheduler that is registered by this class in order to shut it down later ( when it becomes necessary ) .
protected static void fail ( ) { system . exit ( num ) ; }	exit with a process failure code .
private void print arguments ( list < expression > args , object arg ) { printer . print ( str ) ; if ( args != null ) { for ( iterator < expression > i = args . iterator ( ) ; i . has next ( ) ; ) { expression e = i . next ( ) ; e . accept ( this , arg ) ; if ( i . has next ( ) ) { printer . print ( str ) ; } } } printer . print ( str ) ; }	print a list of method arguments in between parentheses .
private void calculate delta ( double [ ] b ) { double numerator = num ; double denominator = num ; double sign = num ; for ( int k = num ; k < b . length ; k ++ ) { if ( k < m extremal indices . size ( ) ) { int extremal index = m extremal indices . get ( k ) ; numerator += ( b [ k ] * m grid . get desired response ( ) [ extremal index ] ) ; denominator += b [ k ] * sign / m grid . get weight ( ) [ extremal index ] ; sign = - sign ; } else { m log . error ( str ) ; } } m delta = numerator / denominator ; }	calculates the value of delta that represents the maximum ripple for the current set of extremal indices ( l + 2 ) implements oppenheim / schafer discrete time signal processing , 3e , 2016 , equation 114.
private void add fallback selector ( properties settings , protocol dispatch selector ps ) { string proxy = settings . get property ( str ) ; if ( proxy != null ) { ps . set fallback selector ( proxy util . parse proxy settings ( proxy ) ) ; } }	installs a fallback selector that is used whenever no protocol specific selector is defined .
private void read data ( ) throws io { while ( ! is closed ) { int code = is . read ( ) ; switch ( code ) { case str : case str : case str : case str : break ; case str : { int channel = ( is . read ( ) << num ) + is . read ( ) ; input ready [ channel ] = bool ; return ; } case str : { int channel = ( is . read ( ) << num ) + is . read ( ) ; int status = ( is . read ( ) << num ) + is . read ( ) ; input ready [ channel ] = bool ; return ; } case - num : close ( ) ; return ; default : close ( ) ; return ; } } return ; }	reads data until a channel packet ' c ' or error ' e ' is received .
@ override protected boolean validate connection ( connection conn ) { try { return ( ! conn . is closed ( ) ) ; } catch ( sql e ) { return bool ; } }	returns true if the connection is not closed .
public pac proxy selector ( string pac url ) { if ( pac url == null ) { throw new null pointer exception ( ) ; } this . pac url = pac url ; }	construct pacproxyselector using an automatic proxy configuration url.
public void delete alerting definition ( alerting definition alerting definition ) throws io { string id = alerting definition . get id ( ) ; alerting definition local = existing alerting definitions . remove ( id ) ; if ( local != null ) { files . delete if exists ( path resolver . get alerting definition file path ( local ) ) ; event publisher . publish event ( new abstract alerting definition event . alerting definition deleted event ( this , local ) ) ; } }	deletes the alerting definition .
public void add file ( file file ) { file list . add first ( file ) ; }	add the given file to the collection.
private void pull event ( ) { final int new scroll value ; final int item dimension ; final float initial motion value , last motion value ; switch ( get pull to refresh scroll direction ( ) ) { case horizontal : initial motion value = m initial motion x ; last motion value = m last motion x ; break ; case vertical : default : initial motion value = m initial motion y ; last motion value = m last motion y ; break ; } switch ( m current mode ) { case pull from end : new scroll value = math . round ( math . max ( initial motion value - last motion value , num ) / friction ) ; item dimension = get footer size ( ) ; break ; case pull from start : default : new scroll value = math . round ( math . min ( initial motion value - last motion value , num ) / friction ) ; item dimension = get header size ( ) ; break ; } set header scroll ( new scroll value ) ; if ( new scroll value != num && ! is refreshing ( ) ) { float scale = math . abs ( new scroll value ) / ( float ) item dimension ; switch ( m current mode ) { case pull from end : m footer layout . on pull ( scale ) ; break ; case pull from start : default : m header layout . on pull ( scale ) ; break ; } if ( m state != state . pull to refresh && item dimension >= math . abs ( new scroll value ) ) { set state ( state . pull to refresh ) ; } else if ( m state != state . release to refresh && item dimension < math . abs ( new scroll value ) ) { set state ( state . release to refresh ) ; } } }	actions a pull event.
public boolean requires connection ( ) { return bool ; }	this semaphore implementation does use the database .
public static double tile2lat ( int y , int z ) { double n = math . pi - ( num * math . pi * y ) / math . pow ( num , z ) ; return math . to degrees ( math . atan ( math . sinh ( n ) ) ) ; }	returns the longitude for an y tile.
@ override public synchronized time series collection update collection ( ) { return super . update collection ( ) ; }	run an update cycle . an update cycle consists of : - gathering raw metrics - creating a new , minimal context - applying decorators against the current and previous values - storing the collection values as the most recent capture.
public char skip ( int n ) { pos += n ; if ( length <= pos ) { pos = string . length ( ) ; return done ; } else return string . char at ( pos ) ; }	skips the next n characters.
private boolean should inform ( local client info info ) { long now = system . current time millis ( ) ; if ( now < next allowed time ) return bool ; long allowed = bug times . get ( info . get parsed bug ( ) ) ; return allowed == null || now >= allowed . long value ( ) ; }	determines if the bug has already been reported enough.
public void post ( runnable runnable ) { synchronized ( m queue ) { m queue . add ( runnable ) ; if ( m queue . size ( ) == num ) { schedule next locked ( ) ; } } }	schedule runnable to run after everything that ' s on the queue right now .
public static void clear ( ) { clear count ++ ; state count = num ; state = str ; feature map . clear ( ) ; }	clears the internal state.
public static string to string pretty ( json object json obj , int level ) { string buffer buf = new string buffer ( ) ; buf . append ( str ) ; buf . append ( fields to string pretty ( json obj , level + num ) ) ; buf . append ( str ) ; return buf . to string ( ) ; }	returns a pretty printed string of the given json object , indented at the given level .
public boolean is launched from jar ( ) { return ( lst jar file . size ( ) > num ) ; }	checks how the application was loaded : from jar or file system .
public log stream print ( double d ) { if ( ps != null ) { indent ( ) ; line buffer . append ( d ) ; } return this ; }	writes a double value to this stream .
public static void delete directory recursively ( context context , file f , boolean only content ) throws io { if ( f . is directory ( ) ) { for ( file c : f . list files ( ) ) { delete directory recursively ( context , c , bool ) ; } } if ( ! only content ) { if ( ! f . delete ( ) ) { throw new io ( str + f ) ; } context . send broadcast ( new intent ( intent . action media scanner scan file , uri . parse ( str + f . get absolute path ( ) ) ) ) ; } }	delete a directory recursively.
public static string node sub type to string ( int sub type ) { string val = str ; switch ( sub type ) { case node representation . and type : val = str ; break ; case node representation . or type : val = str ; break ; case node representation . implies type : val = str ; break ; case node representation . forall type : val = str ; break ; case node representation . exists type : val = str ; break ; case node representation . sqsub type : val = str ; break ; case node representation . other type : val = str ; break ; } return val ; }	converts a noderepresentation subtype to a string.
public static void dispose graphics config ( long p config info ) { ogl rq = get instance ( ) ; rq . lock ( ) ; try { ogl . set scratch surface ( p config info ) ; render buffer buf = rq . get buffer ( ) ; rq . ensure capacity and alignment ( num , num ) ; buf . put int ( dispose config ) ; buf . put long ( p config info ) ; rq . flush now ( ) ; } finally { rq . unlock ( ) ; } }	disposes the native memory associated with the given native graphics config info pointer on the single queue flushing thread .
private void add term ( string term ) { integer index = term to index . get ( term ) ; if ( index == null ) { synchronized ( this ) { index = term to index . get ( term ) ; if ( index == null ) { index = integer . value of ( term index counter . get and increment ( ) ) ; term to index . put ( term , index ) ; } } } }	adds the term to the list of terms and gives it an index , or if the term has already been added , does nothing .
@ override public list < period > generate periods ( date time unit date time unit ) { calendar cal = get calendar ( ) ; boolean past = date time unit . get month ( ) >= ( get base month ( ) + num ) ; list < period > periods = lists . new array list ( ) ; date time unit = cal . minus years ( date time unit , past ? num : num ) ; date time unit . set month ( get base month ( ) + num ) ; date time unit . set day ( num ) ; calendar calendar = get calendar ( ) ; for ( int i = num ; i < num ; i ++ ) { periods . add ( create period ( date time unit , cal ) ) ; date time unit = calendar . plus years ( date time unit , num ) ; } return periods ; }	generates financial yearly periods for the last 5 , current and next 5 financial years .
public final boolean is dragging ( ) { return dragging ; }	whether this title bar is currently being dragged .
@ override public void escape ( char [ ] buffer , int start , int length , boolean is attribute value , writer output writer ) throws io { for ( int i = start ; i < start + length ; i ++ ) { char ch = buffer [ i ] ; if ( ch == str ) { output writer . write ( str ) ; continue ; } if ( ch == str ) { output writer . write ( str ) ; continue ; } if ( ch == str ) { output writer . write ( str ) ; continue ; } if ( ch == str && is attribute value ) { output writer . write ( str ) ; continue ; } if ( ch == str && is attribute value ) { output writer . write ( str ) ; continue ; } if ( is xml11 restricted character ( ch ) ) { output writer . write ( str ) ; output writer . write ( integer . to hex string ( ch ) ) ; output writer . write ( str ) ; continue ; } output writer . write ( ch ) ; } }	escape restricted xml 1.
void encrypt ( byte buffer src ) throws ssl { if ( ! handshake complete ) { throw new illegal state exception ( ) ; } if ( ! src . has remaining ( ) ) { if ( out net buffer == null ) { out net buffer = empty buffer ; } return ; } create out net buffer ( src . remaining ( ) ) ; while ( src . has remaining ( ) ) { ssl result = ssl engine . wrap ( src , out net buffer . buf ( ) ) ; if ( result . get status ( ) == ssl . status . ok ) { if ( result . get handshake status ( ) == ssl . handshake status . need task ) { do tasks ( ) ; } } else if ( result . get status ( ) == ssl . status . buffer overflow ) { out net buffer . capacity ( out net buffer . capacity ( ) << num ) ; out net buffer . limit ( out net buffer . capacity ( ) ) ; } else { throw new ssl ( str + result . get status ( ) + str + src + str + out net buffer ) ; } } out net buffer . flip ( ) ; }	encrypt provided buffer . encrypted data returned by getoutnetbuffer ( ) .
public boolean code matches ( string query code ) { int length = id . length ( ) ; if ( debug . debugging ( str ) ) { debug . output ( str + query code + str + id + str + start index + str + length ) ; } return query code . region matches ( bool , start index , id , num , length ) ; }	a query method that answers of the given 15 digit code applies to this symbol part .
private static int parse notification id ( string id ) { try { return integer . parse int ( id ) ; } catch ( number format exception nfe ) { log . w ( tag , str + id ) ; return - num ; } }	parse the notification id from a string object .
private < t > property < t > prepare ( string key , property < t > property , t initial value ) { final change listener < t > change = null ; property . set value ( initial value ) ; property . add listener ( change ) ; change . changed ( property , null , initial value ) ; return property ; }	adds a listener to the specified property so that changes to it are reflected down to the source map .
protected void read till eol ( ) throws io { while ( m . next token ( ) != stream tokenizer . tt eol ) { } m . push back ( ) ; }	reads and skips all tokens before next end of line token .
@ override public void clear answer ( ) { date time ldt = new date time ( ) ; m time picker . set current hour ( ldt . get hour of day ( ) ) ; m time picker . set current minute ( ldt . get minute of hour ( ) ) ; }	resets time to today .
public string read line ( ) throws io { return keep carriage returns ? read until newline ( ) : reader . read line ( ) ; }	reads the next line from the reader .
@ override public void do work ( ) throws operator exception { super . do work ( ) ; run vector output . deliver ( run vector ) ; }	overwrite to also return the performance ( run - ) vector.
public simple user context ( authentication provider auth provider , string username , map < string , guacamole configuration > configs ) { collection < string > connection identifiers = new array list < string > ( configs . size ( ) ) ; collection < string > connection group identifiers = collections . singleton ( root identifier ) ; collection < connection > connections = new array list < connection > ( configs . size ( ) ) ; for ( map . entry < string , guacamole configuration > config entry : configs . entry set ( ) ) { string identifier = config entry . get key ( ) ; guacamole configuration config = config entry . get value ( ) ; connection connection = new simple connection ( identifier , identifier , config ) ; connection . set parent identifier ( root identifier ) ; connections . add ( connection ) ; connection identifiers . add ( identifier ) ; } this . root group = new simple connection group ( root identifier , root identifier , connection identifiers , collections . < string > empty list ( ) ) ; this . self = new simple user ( username , connection identifiers , connection group identifiers ) ; this . user directory = new simple user directory ( self ) ; this . connection directory = new simple connection directory ( connections ) ; this . connection group directory = new simple connection group directory ( collections . singleton ( this . root group ) ) ; this . auth provider = auth provider ; }	creates a new simpleusercontext for the user with the given username which provides access to only those configurations within the given map .
public void reset ( ) { visited get . clear ( ) ; visited post . clear ( ) ; for ( spider parser parser : parsers ) { parser . remove spider parser listener ( this ) ; } }	clears the previous process .
private static float v ( jni env , int class jref , int method id , address arg address ) throws exception { if ( trace jni ) vm . sys write ( str ) ; runtime entrypoints . check jni gc ( ) ; try { object return obj = jni . invoke with var arg ( method id , arg address , type reference . float ) ; return reflection . unwrap float ( return obj ) ; } catch ( throwable unexpected ) { if ( trace jni ) unexpected . print stack trace ( system . err ) ; env . record exception ( unexpected ) ; return num ; } }	callstaticfloatmethodv : invoke a static method that returns a float value.
public named list < object > to named list ( ) { final simple ordered map < object > result = new simple ordered map < > ( ) ; for ( iterator < string > it = get parameter names iterator ( ) ; it . has next ( ) ; ) { final string name = it . next ( ) ; final string [ ] values = get params ( name ) ; if ( values . length == num ) { result . add ( name , values [ num ] ) ; } else { result . add ( name , values ) ; } } return result ; }	convert this to a namedlist.
private boolean is representing tab ( string text ) { if ( text == null ) return bool ; if ( is inserting spaces for tab ( ) ) { if ( text . length ( ) == num || text . length ( ) > get visual tab length preference ( ) ) return bool ; for ( int i = num ; i < text . length ( ) ; i ++ ) { if ( text . char at ( i ) != str ) return bool ; } return bool ; } else return text . length ( ) == num && text . char at ( num ) == str ; }	tells whether the given inserted string represents hitting the tab key .
public monitor thread ( string name ) { super ( name ) ; }	creates a new schedulingthread object .
@ override public units relations init ( processing environment env ) { elements = env . get element utils ( ) ; m = units relations tools . build anno mirror with default prefix ( env , m . class ) ; km = units relations tools . build anno mirror with specific prefix ( env , m . class , prefix . kilo ) ; mm = units relations tools . build anno mirror with specific prefix ( env , m . class , prefix . milli ) ; m2 = units relations tools . build anno mirror with no prefix ( env , m2 . class ) ; km2 = units relations tools . build anno mirror with no prefix ( env , km2 . class ) ; mm2 = units relations tools . build anno mirror with no prefix ( env , mm2 . class ) ; s = units relations tools . build anno mirror with default prefix ( env , s . class ) ; h = units relations tools . build anno mirror with no prefix ( env , h . class ) ; m pe = units relations tools . build anno mirror with no prefix ( env , m pe . class ) ; km pe = units relations tools . build anno mirror with no prefix ( env , km pe . class ) ; m pe = units relations tools . build anno mirror with no prefix ( env , m pe . class ) ; return this ; }	constructs various annotationmirrors representing specific checker - framework provided units involved in the rules resolved in this unitsrelations implementation.
public static string [ ] to string array ( collection < string > collection ) { if ( collection == null ) { return null ; } return collection . to array ( new string [ collection . size ( ) ] ) ; }	copy the given collection into a string array.
public void persist ( repository proxy cache proxy cache ) { persist ( proxy cache , proxy cache . get file name ( ) ) ; }	warning : this is an i / o operation and this method is going to be performed in a different thread .
public string format delete nfs export cmd ( string data mover , string path ) { string builder cmd = new string builder ( ) ; cmd . append ( str ) ; cmd . append ( data mover ) ; cmd . append ( str ) ; cmd . append ( str ) ; cmd . append ( path ) ; return cmd . to string ( ) ; }	create the command string for deleting file system export .
public final string match categories ( set < string > categories ) { if ( categories == null ) { return null ; } iterator < string > it = categories . iterator ( ) ; if ( m categories == null ) { return it . has next ( ) ? it . next ( ) : null ; } while ( it . has next ( ) ) { final string category = it . next ( ) ; if ( ! m categories . contains ( category ) ) { return category ; } } return null ; }	match this filter against an intent ' s categories.
@ override public void run ( ) { try { class reader reader = new class reader ( new file input stream ( this . class file ) ) ; asm class visitor visitor = new asm class visitor ( this . data provider , this . config ) ; reader . accept ( visitor , class reader . skip debug ) ; } catch ( exception e ) { logger . log ( level . severe , e . get message ( ) , e ) ; } }	main run method from runnable interface.
private void add location and track property change ( ) { for ( location loc : location manager . get list ( ) ) { loc . add property change listener ( this ) ; for ( track track : loc . get track list ( ) ) { track . add property change listener ( this ) ; schedule schedule = track . get schedule ( ) ; if ( schedule != null ) { schedule . add property change listener ( this ) ; } } } }	add property listeners for locations and tracks.
private void schedule ( activity a , long start time ) { if ( a . is scheduled ( ) ) { try { notify all ( ) ; } catch ( exception e ) { } return ; } a . set start time ( start time ) ; synchronized ( this ) { m activities . add ( a ) ; a . set scheduled ( bool ) ; if ( start time < m next time ) { m next time = start time ; notify ( ) ; } } }	schedules an activity with the manager .
void unregister callback ( bluetooth callback callback ) { synchronized ( m callbacks ) { m callbacks . remove ( callback ) ; } }	unregister to stop receiving callbacks for bluetooth events .
public void test hash code unequal ( ) { string a = str ; int a scale = num ; string b = str ; int b scale = - num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; assert true ( str , a number . hash code ( ) != b number . hash code ( ) ) ; }	hashcode ( ) for unequal bigdecimals.
@ visible for testing static string escape sql string ( string string ) { return string . replace all ( str , str ) ; }	escapes a sql string.
public static string [ ] to array ( string arg ) { if ( arg == null ) { return new string [ num ] ; } string tokenizer tok = new string tokenizer ( arg , str ) ; string [ ] array = new string [ tok . count tokens ( ) ] ; int i = num ; while ( tok . has more tokens ( ) ) { array [ i ] = tok . next token ( ) ; i ++ ; } return ( array ) ; }	convert comma delimited and / or space string to array of strings.
private void append uploaded entry to log ( string id ) throws io { file writer writer = new file writer ( m logfile , bool ) ; string builder sb = new string builder ( ) ; sb . append ( system . current time millis ( ) / num ) ; sb . append ( str ) ; sb . append ( id ) ; sb . append ( str ) ; try { writer . write ( sb . to string ( ) ) ; } finally { writer . close ( ) ; } }	records the upload entry to a log file similar to what is done in chrome / app / breakpad_linux . cc.
private void render leaf node ( final c tree node ) { final navi node graph node = tree node . get node ( ) ; if ( graph node . is selected ( ) && graph node . is visible ( ) ) { set foreground ( selected font color ) ; } else if ( ! graph node . is visible ( ) ) { set foreground ( invisible font color ) ; } set tool tip text ( build tool tip ( graph node ) ) ; }	renders a leaf node .
public sector union ( double latitude , double longitude ) { if ( this . min latitude < this . max latitude && this . min longitude < this . max longitude ) { this . max latitude = math . max ( this . max latitude , latitude ) ; this . min latitude = math . min ( this . min latitude , latitude ) ; this . max longitude = math . max ( this . max longitude , longitude ) ; this . min longitude = math . min ( this . min longitude , longitude ) ; } else if ( ! double . is na n ( this . min latitude ) && ! double . is na n ( this . min longitude ) ) { this . max latitude = math . max ( this . min latitude , latitude ) ; this . max longitude = math . max ( this . min longitude , longitude ) ; this . min latitude = math . min ( this . min latitude , latitude ) ; this . min longitude = math . min ( this . min longitude , longitude ) ; } else { this . min latitude = latitude ; this . min longitude = longitude ; this . max latitude = double . n ; this . max longitude = double . n ; } return this ; }	sets this sector to the union of itself and a specified location .
public d ( j parent , public key authority public key , x500 name authority cert name , big integer authority cert serial number ) { super ( parent ) ; set title ( res . get string ( str ) ) ; this . authority public key = authority public key ; init components ( ) ; prepopulate with authority cert details ( authority cert name , authority cert serial number ) ; }	creates a new dauthoritykeyidentifier dialog .
static void write utf ( output stream out , string str ) throws io { for ( int i = num , len = str . length ( ) ; i < len ; i ++ ) { int c = str . char at ( i ) ; if ( ( c >= num ) && ( c <= num ) ) { out . write ( c ) ; } else { if ( c > num ) { out . write ( num | ( ( c > > num ) & num ) ) ; out . write ( num | ( ( c > > num ) & num ) ) ; out . write ( num | ( ( c > > num ) & num ) ) ; } else { out . write ( num | ( ( c > > num ) & num ) ) ; out . write ( num | ( ( c > > num ) & num ) ) ; } } } }	write a utf string with a length to a stream .
public void test get iterator ( ) { string test = str ; try { attributed string attr string = new attributed string ( test ) ; attributed character iterator it = attr string . get iterator ( ) ; assert equals ( str , it . first ( ) , test . char at ( num ) ) ; } catch ( exception e ) { fail ( str + e . to string ( ) ) ; } }	java . text . attributedstring # getiterator ( ) test of method java . text . attributedstring # getiterator ( ) .
private void handle normal unassociated ( ) { int sz ssa regs = ssa meth . get reg count ( ) ; for ( int ssa reg = num ; ssa reg < sz ssa regs ; ssa reg ++ ) { if ( ssa regs mapped . get ( ssa reg ) ) { continue ; } register spec ssa spec = get definition spec for ssa reg ( ssa reg ) ; if ( ssa spec == null ) continue ; int category = ssa spec . get category ( ) ; int rop reg = find next unreserved rop reg ( param range end , category ) ; while ( ! can map reg ( ssa spec , rop reg ) ) { rop reg = find next unreserved rop reg ( rop reg + num , category ) ; } add mapping ( ssa spec , rop reg ) ; } }	maps all non - parameter , non - local variable registers .
public void create underlying ( ) { if ( platform . is fx application thread ( ) ) { options . create underlying ( ) ; this . marker = new com . lynden . gmapsfx . javascript . object . marker ( options . convert ( ) ) ; } }	creates the underlying javascript peers.
private void on action up ( motion event event ) { if ( is down ) { this . start x = num ; this . start y = num ; this . is down = bool ; } }	this method defines processes on motionevent . action_down.
private d create aligned rectangle2 d ( d dimensions , d frame , horizontal alignment h align , vertical alignment v align ) { double x = double . n ; double y = double . n ; if ( h align == horizontal alignment . left ) { x = frame . get x ( ) ; } else if ( h align == horizontal alignment . center ) { x = frame . get center x ( ) - ( dimensions . width / num ) ; } else if ( h align == horizontal alignment . right ) { x = frame . get max x ( ) - dimensions . width ; } if ( v align == vertical alignment . top ) { y = frame . get y ( ) ; } else if ( v align == vertical alignment . center ) { y = frame . get center y ( ) - ( dimensions . height / num ) ; } else if ( v align == vertical alignment . bottom ) { y = frame . get max y ( ) - dimensions . height ; } return new d . double ( x , y , dimensions . width , dimensions . height ) ; }	creates a rectangle that is aligned to the frame .
public mail address ( internet address address ) throws address exception { this ( address . get address ( ) ) ; }	constructs a mailaddress from an internetaddress , using only the email address portion ( an " addr - spec " , not " name - addr " , as defined in the rfc2822 3.
public double [ ] [ ] confusion matrix ( ) { double [ ] [ ] new matrix = new double [ m . length ] [ num ] ; for ( int i = num ; i < m . length ; i ++ ) { new matrix [ i ] = new double [ m [ i ] . length ] ; system . arraycopy ( m [ i ] , num , new matrix [ i ] , num , m [ i ] . length ) ; } return new matrix ; }	returns a copy of the confusion matrix .
public void print ( int x ) { out . print ( x ) ; out . flush ( ) ; }	prints an integer to this output stream and flushes this output stream .
public static void begin starting service ( context context , intent intent ) { synchronized ( m starting service sync ) { if ( m starting service == null ) { power manager pm = ( power manager ) context . get system service ( context . power service ) ; m starting service = pm . new wake lock ( power manager . partial wake lock , str ) ; m starting service . set reference counted ( bool ) ; } m starting service . acquire ( ) ; context . start service ( intent ) ; } }	start the service to process the current event notifications , acquiring the wake lock before returning to ensure that the service will run .
public scanner exception ( error messages message , int line ) { this ( null , error messages . get ( message ) , message , line , - num ) ; }	creates a new scannerexception with a message and line number .
private int find scheme separator ( ) { return cached ssi == not calculated ? cached ssi = uri string . index of ( str ) : cached ssi ; }	finds the first ' : '.
@ override public boolean test ( object receiver , string property , object [ ] args , object expected value ) { if ( is angular cli project property . equals ( property ) ) { return test is angular cli ( receiver ) ; } return bool ; }	tests if the receiver object is a project is a angular cli project and false otherwise .
public void refresh ( ) { label . set text ( string . value of ( math helper . round ( val , num ) ) ) ; if ( val == min ) minus . set enabled ( bool ) ; else minus . set enabled ( bool ) ; if ( val == max ) plus . set enabled ( bool ) ; else plus . set enabled ( bool ) ; if ( cb != null ) cb . callback ( val ) ; plus . repaint ( ) ; minus . repaint ( ) ; if ( progress != null ) { progress . set value ( val / max ) ; } }	refresh the element . this enables / disables any + or - buttons if the clamp is reached , as well as call the callback if required .
public void remove callback ( callback callback ) { m callbacks . remove ( callback ) ; }	removes a previously added callback interface from this holder .
private boolean expect vlv response ( ) { boolean expected = boolean . false ; try { expected = ( boolean ) get ( expect vlv response ) ; } catch ( exception e ) { } return expected == null ? bool : expected . boolean value ( ) ; }	check if this search result expects a vlv response control.
public void layout container ( final container parent ) { check layout ( get model ( ) ) ; final insets insets = parent . get insets ( ) ; final dimension size = parent . get size ( ) ; final int width = size . width - ( insets . left + insets . right ) ; final int height = size . height - ( insets . top + insets . bottom ) ; final rectangle bounds = new rectangle ( insets . left , insets . top , width , height ) ; layout1 ( get model ( ) , bounds ) ; layout2 ( get model ( ) , bounds ) ; }	compute the bounds of all of the split / divider / leaf nodes in the layout model , and then set the bounds of each child component with a matching leaf node .
@ override public invocation . builder accept ( string ... media types ) { client request context . set accept response types str ( arrays . as list ( media types ) ) ; return this ; }	set accept media types .
public stream consumer ( input stream stream ) { in = new buffered input stream ( stream ) ; thread . start ( ) ; }	creates a streamconsumer for consuming the data from the input stream .
public static string sub string ( string string , int begin index , int length ) { if ( string == null ) { return null ; } final int end index = begin index + length ; if ( begin index >= string . length ( ) ) { return empty ; } if ( end index > string . length ( ) ) { return string . substring ( begin index , string . length ( ) ) ; } return string . substring ( begin index , end index ) ; }	gets the sub string of the given string.
private static socket impl create socket impl ( ) { try { return socket impl ctor . new instance ( ) ; } catch ( instantiation exception x ) { throw new assertion error ( x ) ; } catch ( illegal access exception x ) { throw new assertion error ( x ) ; } catch ( invocation target exception x ) { throw new assertion error ( x ) ; } }	creates a sdp enabled socketimpl.
@ override public string encode ( ) { return name . substring ( num , num ) ; }	returns a parseable string representation of this componentsize .
void cancel all ( ) { synchronized ( current requests ) { for ( download request request : current requests ) { request . cancel ( ) ; } } current requests . clear ( ) ; }	cancel all the download .
protected void add docs ( string index , string type , int number ) throws json processing exception { object mapper mapper = new object mapper ( ) ; for ( int i = num ; i < number ; i ++ ) { index ( index , type , str + i , mapper . write value as string ( test document . create simple doc ( i ) ) ) ; } flush ( ) ; }	adds the specified number of docs to the type within index.
public void test pow negative num to zero exp ( ) { byte a bytes [ ] = { num , - num , num , num , num , num , num , - num , - num , num } ; int a sign = - num ; int exp = num ; byte r bytes [ ] = { num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . pow ( exp ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	exponentiation of a negative number to zero exponent .
public final parallel flux < t > do on error ( consumer < ? super throwable > on error ) { objects . require non null ( on error , str ) ; return do on signal ( this , null , null , on error , null , null , null , null , null ) ; }	call the specified consumer with the exception passing through any ' rail ' .
public void simulate method ( soot method method , reference variable this var , reference variable return var , reference variable params [ ] ) { string sub signature = method . get sub signature ( ) ; if ( sub signature . equals ( str ) ) { java lang arraycopy ( method , this var , return var , params ) ; return ; } else if ( sub signature . equals ( str ) ) { java lang set in0 ( method , this var , return var , params ) ; return ; } else if ( sub signature . equals ( str ) ) { java lang set out0 ( method , this var , return var , params ) ; return ; } else if ( sub signature . equals ( str ) ) { java lang set err0 ( method , this var , return var , params ) ; return ; } else if ( sub signature . equals ( str ) ) { java lang init properties ( method , this var , return var , params ) ; return ; } else if ( sub signature . equals ( str ) ) { java lang map library name ( method , this var , return var , params ) ; return ; } else if ( sub signature . equals ( str ) ) { java lang get caller class ( method , this var , return var , params ) ; return ; } else { default method ( method , this var , return var , params ) ; return ; } }	implements the abstract method simulatemethod.
protected void load value ( string s value ) { try { value = long . parse long ( s value . trim ( ) ) ; } catch ( number format exception nfe ) { revert to default ( ) ; } }	load value from property string value.
public void check bounds ( ) { tf low bound . set enabled ( ts clipping . is selected ( ) ) ; tf up bound . set enabled ( ts clipping . is selected ( ) ) ; }	enable or disable the upper and lower bounds fields depending on state of rounding button .
public void remove ( int index ) { m categories . remove ( index ) ; m titles . remove ( index ) ; m values . remove ( index ) ; }	removes an existing value from the series .
public static boolean delete files and dirs recursive ( final file directory ) { if ( directory == null || ! directory . is directory ( ) ) { log . e ( file utils . class , str ) ; return bool ; } return delete files and dirs ( directory ) ; }	method deletes all files and subdirectories recursively from given directory . returns true if all files deleted false if at least one doesn ' t.
void render ( graphics context g , d viewport origin ) { g . set global alpha ( life ) ; g . set global blend mode ( blend mode ) ; if ( image != null ) { g . save ( ) ; g . translate ( x - viewport origin . get x ( ) , y - viewport origin . get y ( ) ) ; g . scale ( radius x * num / image . get width ( ) , radius y * num / image . get height ( ) ) ; g . draw image ( image , num , num ) ; g . restore ( ) ; } else { g . set fill ( color ) ; g . fill oval ( x - viewport origin . get x ( ) , y - viewport origin . get y ( ) , radius x * num , radius y * num ) ; } }	renders particle to g context.
public int position ( ) { return buff . position ( ) ; }	get the current position .
@ override public void write ( string str , int off , int len ) throws io { final int off plus len = off + len ; for ( int i = off ; i < off plus len ; ) { char c = str . char at ( i ++ ) ; if ( c < num ) { bytes [ index ] = ( byte ) c ; if ( ++ index >= bytes . length ) { flush buffer ( ) ; } } else { write ( c ) ; } } }	writes a portion of a string .
public void write to nbt ( final nbt nbt ) { final nbt modules nbt = new nbt ( ) ; for ( final module module : modules ) { final nbt module nbt = new nbt ( ) ; if ( module != null ) { module . write to nbt ( module nbt ) ; } modules nbt . append tag ( module nbt ) ; } nbt . set tag ( tag modules , modules nbt ) ; lock . if present ( null ) ; lock . if present ( null ) ; }	write the state of all modules and pipes to the specified nbt tag .
void send buffer if not empty ( ) throws io { if ( buf != null && buf . position ( ) > num ) send buffer ( ) ; }	send local buffer if at least something is stored there .
public void on shared preference changed ( shared preferences shared preferences , string key ) { if ( key . equals ( get string ( r . string . pref key notification ) ) ) { set notification ( shared preferences . get boolean ( key , bool ) ) ; } else if ( key . equals ( get string ( r . string . pref key gmail signature ) ) ) { set gmail signature pref description ( shared preferences . get boolean ( key , bool ) ) ; } else if ( key . equals ( get string ( r . string . pref key sms signature ) ) ) { set sms signature pref description ( shared preferences . get boolean ( key , bool ) ) ; } }	general change monitor that can be used to call updates based on the preference that was updated .
public void init port parameters ( serial port port ) { initialized = bool ; if ( port != null ) { cb port . set selected item ( port . get name ( ) ) ; cb baudrate . set selected item ( string . value of ( port . get baud rate ( ) ) ) ; cb parity . set selected index ( port . get parity ( ) ) ; cb data bits . set selected index ( port . get data bits ( ) - num ) ; cb stop bits . set selected index ( port . get stop bits ( ) - num ) ; int prt = port . get flow control mode ( ) ; cb protocol rx . set selected index ( ( prt & serial port . flowcontrol rtscts in ) != num ? num : ( prt & serial port . flowcontrol xonxoff in ) != num ? num : num ) ; cb protocol tx . set selected index ( ( prt & serial port . flowcontrol rtscts out ) != num ? num : ( prt & serial port . flowcontrol xonxoff out ) != num ? num : num ) ; btn dsr . set selected ( port . is dsr ( ) ) ; btn cts . set selected ( port . is cts ( ) ) ; btn cd . set selected ( port . is cd ( ) ) ; btn dtr . set selected ( port . is dtr ( ) ) ; btn rts . set selected ( port . is rts ( ) ) ; } initialized = bool ; }	initialize all port parameters port - & gt ; dialog.
public void add preload entry ( grid cache entry info info ) { if ( preload entries == null ) preload entries = new array list < > ( ) ; preload entries . add ( info ) ; }	adds preload entry to lock response .
private void put off uniform ( final player player ) { if ( uniform . is part of ( player . get outfit ( ) ) ) { player . return to original outfit ( ) ; } }	takes away the player ' s uniform , if the he is wearing it .
public static void move file ( final file src file , final file dest file ) throws io { if ( src file == null ) { throw new null pointer exception ( str ) ; } if ( dest file == null ) { throw new null pointer exception ( str ) ; } if ( ! src file . exists ( ) ) { throw new file not found exception ( str + src file + str ) ; } if ( src file . is directory ( ) ) { throw new io ( str + src file + str ) ; } if ( dest file . exists ( ) ) { throw new io ( str + dest file + str ) ; } if ( dest file . is directory ( ) ) { throw new io ( str + dest file + str ) ; } final boolean rename = src file . rename to ( dest file ) ; if ( ! rename ) { copy file ( src file , dest file ) ; if ( ! src file . delete ( ) ) { parse file utils . delete quietly ( dest file ) ; throw new io ( str + src file + str + dest file + str ) ; } } }	moves a file . < p > when the destination file is on another file system , do a " copy and delete " .
public synchronized scan manager config read from file ( ) throws io { final file f = new file ( file ) ; if ( ! f . exists ( ) ) throw new io ( str + file ) ; if ( ! f . can read ( ) ) throw new io ( str + file ) ; try { return read ( f ) ; } catch ( jaxb x ) { final io io = new io ( str + file + str + x , x ) ; throw io ; } }	reads the configuration from the xml configuration file .
public void delete ( string name ) throws io { if ( name . equals ignore case ( issuer ) ) { names = null ; } else { throw new io ( str + str ) ; } encode this ( ) ; }	deletes the attribute value .
public compile class not found ( exception cause ) { super ( cause . get message ( ) ) ; cause = cause ; }	create a compileclassnotfound exception wrapped around a root cause .
public sym graph ( motif motif ) { this . motif = motif ; colors to recheck = new hash set < integer > ( ) ; top motifnode to color = new int [ motif . get nr motif nodes ( ) ] ; color to bottom motifnode = new hash map < integer , list < integer > > ( ) ; color to top motifnode = new hash map < integer , list < integer > > ( ) ; array list < integer > list1 = new array list < integer > ( ) ; array list < integer > list2 = new array list < integer > ( ) ; for ( int i = num ; i < top motifnode to color . length ; i ++ ) { list1 . add ( i ) ; list2 . add ( i ) ; } color to bottom motifnode . put ( num , list2 ) ; color to top motifnode . put ( num , list1 ) ; }	create an initial opp.
public static boolean any dimension has items ( collection < dimensional object > dimensions ) { if ( dimensions == null || dimensions . is empty ( ) ) { return bool ; } for ( dimensional object dim : dimensions ) { if ( dim . has items ( ) ) { return bool ; } } return bool ; }	indicates whether at least one of the given dimenions has at least one item .
private void open current and maybe next ( final boolean open next ) { log . info ( str ) ; synchronized ( this ) { log . info ( str ) ; close cursor ( ) ; if ( m play list len == num || m play list == null ) { return ; } stop ( bool ) ; m play pos = math . min ( m play pos , m play list . length - num ) ; update cursor ( m play list [ m play pos ] ) ; while ( bool ) { if ( m cursor != null && ! m cursor . is closed ( ) && open file ( media store . audio . media . external content uri + str + m cursor . get long ( idcolidx ) ) ) { break ; } close cursor ( ) ; if ( m open failed counter ++ < num && m play list len > num ) { final int pos = get next position ( bool ) ; if ( schedule shutdown and notify play state change ( pos ) ) return ; m play pos = pos ; stop ( bool ) ; m play pos = pos ; update cursor ( m play list [ m play pos ] ) ; } else { m open failed counter = num ; log . warn ( str ) ; schedule delayed shutdown ( ) ; if ( m is supposed to be playing ) { m is supposed to be playing = bool ; notify change ( playstate changed ) ; } return ; } } if ( open next ) { set next track ( ) ; } } }	called to open a new file as the current track and prepare the next for playback.
protected om create dtd ( ) throws om { throw new om ( str ) ; }	method createdtd . overriding the default behaviour as a soapmessage should not have a dtd .
private iv ( ) { }	creates a new instance of ivgenerator.
private void create overview page ( ) { remap overview overview = new remap overview ( migration task , get container ( ) ) ; int index = add page ( overview . get control ( ) ) ; set page text ( index , str ) ; task listeners . add ( overview ) ; }	create the overview page showing informations about the migrationtask .
public void warning2 ( final string filename , int ln , int col , object msg , string source ) { warning ( filename , ln , col , msg . to string ( ) , source ) ; }	c : the error ( ) and warning ( ) reporting system use error codes.
public soap open soap ( ) throws soap { return soap connection factory . create connection ( ) ; }	opens a soap connection .
public static < u , v > string print map ( final map < u , v > map , final converter < u > key converter , final converter < v > value converter ) { final string builder sb = new string builder ( str ) ; string separator = str ; for ( final entry < u , v > entry : map . entry set ( ) ) { sb . append ( separator ) ; sb . append ( key converter . convert ( entry . get key ( ) ) ) ; sb . append ( str ) ; sb . append ( value converter . convert ( entry . get value ( ) ) ) ; separator = str ; } sb . append ( str ) ; return sb . to string ( ) ; }	pretty prints a map , using the provided converters for the keys and values .
public void find and init ( object some obj ) { if ( some obj instanceof com . bbn . openmap . map bean ) { debug . message ( str , str ) ; set source map ( ( map bean ) some obj ) ; } }	called when the overviewmaphandler is added to the beancontext , and whenever an object is added to the beancontext after that.
public static double cdf ( double x , double mu , double shape ) { if ( ! ( x > num ) ) { return num ; } final double v0 = x / mu ; final double v1 = math . sqrt ( shape / x ) ; if ( v1 == num ) { return v0 > num ? num : num ; } double c1 = normal distribution . standard normal cdf ( v1 * ( v0 - num ) ) ; double c2 = normal distribution . standard normal cdf ( - v1 * ( v0 + num ) ) ; return ( c2 > num ) ? c1 + math . exp ( num * shape / mu ) * c2 : c1 ; }	cumulative probability density function ( cdf ) of a wald distribution .
protected void bflash ( ) throws sax { if ( m buff idx >= num ) { m hand cont . characters ( m buff , num , ( m buff idx + num ) ) ; m buff idx = - num ; } }	reports characters and empties the parser ' s buffer.
protected mac ( mac spi mac spi , provider provider , string algorithm ) { this . spi = mac spi ; this . provider = provider ; this . algorithm = algorithm ; service iterator = null ; lock = null ; }	creates a mac object .
public static string path to string ( string dim , string [ ] path ) { string [ ] full path = new string [ num + path . length ] ; full path [ num ] = dim ; system . arraycopy ( path , num , full path , num , path . length ) ; return path to string ( full path , full path . length ) ; }	turns a dim + path into an encoded string .
public static cdc session create cdc session via domain auth ( string server name , string user name , string user password ) { if ( server name == null || server name . length ( ) == num ) { throw new illegal argument exception ( str ) ; } if ( user name == null || user name . length ( ) == num ) { throw new illegal argument exception ( str ) ; } return new cdc session ( server name , user name , user password ) ; }	instantiates a cdcsession for a specified domain user for a specified server .
protected static dfp exp internal ( final dfp a ) { dfp y = a . get one ( ) ; dfp x = a . get one ( ) ; dfp fact = a . get one ( ) ; dfp py = new dfp ( y ) ; for ( int i = num ; i < num ; i ++ ) { x = x . multiply ( a ) ; fact = fact . divide ( i ) ; y = y . add ( x . multiply ( fact ) ) ; if ( y . equals ( py ) ) { break ; } py = new dfp ( y ) ; } return y ; }	computes e to the given power.
public url open connection ( ) throws io { return stream handler . open connection ( this ) ; }	returns a new connection to the resource referred to by this url .
public static array list < string [ ] > lines to array ( array list < string > in line ) { array list < string [ ] > frames en tab = new array list < > ( ) ; for ( int i = num ; i < in line . size ( ) ; i ++ ) { frames en tab . add ( line to array ( in line . get ( i ) ) ) ; } return frames en tab ; }	convert arraylist of string into arraylist of string [ ] ( split with spaces ).
@ override public int la ( int i ) { int la = super . la ( i ) ; return character . to lower case ( la ) ; }	overrides antlrstringstream lookahead for case insensitivity .
public void deselect all ( ) { arrays . fill ( sel array , bool ) ; }	deselects all item types .
@ override public boolean can transfer criticals ( int loc ) { return bool ; }	protos can ' t transfer crits .
private void calculate sizes ( final graphics g ) { m row height = get row height ( g ) ; m char height = get char height ( g ) ; m char width = get character width ( g ) ; }	calculates current character and row sizes .
public static iterable < gateway meta state . index meta write info > resolve states to be written ( immutable set < string > previously written indices , set < string > potentially unwritten indices , meta data previous meta data , meta data new meta data ) { list < gateway meta state . index meta write info > indices to write = new array list < > ( ) ; for ( string index : potentially unwritten indices ) { index meta data new index meta data = new meta data . index ( index ) ; index meta data previous index meta data = previous meta data == null ? null : previous meta data . index ( index ) ; string write reason = null ; if ( previously written indices . contains ( index ) == bool || previous index meta data == null ) { write reason = str ; } else if ( previous index meta data . get version ( ) != new index meta data . get version ( ) ) { write reason = str + previous index meta data . get version ( ) + str + new index meta data . get version ( ) + str ; } if ( write reason != null ) { indices to write . add ( new gateway meta state . index meta write info ( new index meta data , previous index meta data , write reason ) ) ; } } return indices to write ; }	loads the current meta state for each index in the new cluster state and checks if it has to be persisted.
protected double apply function ( double value ) { switch ( m operator ) { case str : return math . log ( value ) ; case str : return math . abs ( value ) ; case str : return math . cos ( value ) ; case str : return math . exp ( value ) ; case str : return math . sqrt ( value ) ; case str : return math . floor ( value ) ; case str : return math . ceil ( value ) ; case str : return math . rint ( value ) ; case str : return math . tan ( value ) ; case str : return math . sin ( value ) ; } return double . n ; }	apply this operator ( function ) to the supplied argument.
public remote event dequeue ( ) { uuid uuid = ready events . poll ( ) ; if ( uuid == null ) return null ; single producer producer = get producer ( uuid ) ; return producer . pop next ready event ( ) ; }	remove and return the next event in queue.
public tcp discovery vm ip finder ( ) { }	constructs new ip finder .
public invalid properties format exception ( string message ) { super ( message ) ; }	constructs an invalidpropertiesformatexception with the specified detail message .
public sub command ( i definition , resource bundle rb , string name , list mandatory options , list optional options , list option aliases , string impl class name , boolean web support , string deprecation warning ) throws cli { this . definition = definition ; this . name = name ; this . rb = rb ; this . impl class name = impl class name ; this . web support = web support ; this . deprecation warning = deprecation warning ; set short options = new hash set ( ) ; parse options ( mandatory options , this . mandatory options , short options ) ; parse options ( optional options , this . optional options , short options ) ; parse aliases ( option aliases ) ; }	creates a sub command object .
public static boolean can add class in package of ( class < ? > cls ) { final package bean package = cls . get package ( ) ; if ( bean package != null ) { if ( bean package . is sealed ( ) ) { return bool ; } string pname = bean package . get name ( ) ; if ( pname . starts with ( str ) || pname . starts with ( str ) ) { return bool ; } } return bool ; }	helper method called to check whether it is acceptable to create a new class in package that given class is part of.
public static json token deserialize ( final string jwt ) throws exception { json token parser parser = new json token parser ( verifier providers , new abelana token audience checker ( backend constants . token issuer ) ) ; return parser . deserialize ( jwt ) ; }	deserializes the jwt signed token .
public void swap suggestions ( final list < ? extends search suggestion > new search suggestions ) { collections . reverse ( new search suggestions ) ; swap suggestions ( new search suggestions , bool ) ; }	clears the current suggestions and replaces it with the provided list of new suggestions .
boolean should animate search provider icon ( selection type selection type , boolean is showing ) { if ( is showing || contextual search field trial . are extra search bar animations disabled ( ) ) { return bool ; } if ( selection type == selection type . tap ) { long current time millis = system . current time millis ( ) ; long last animated time millis = m preference manager . get contextual search last animation time ( ) ; if ( math . abs ( current time millis - last animated time millis ) > one day in millis ) { m preference manager . set contextual search last animation time ( current time millis ) ; return bool ; } else { return bool ; } } else if ( selection type == selection type . long press ) { return get promo open count ( ) == num ; } return bool ; }	the search provider icon is animated every time on long press if the user has never opened the panel before and once a day on tap .
public void wait for ( ) { check started ( ) ; try { if ( my input processor != null && my process != null ) { my input processor . process ( my process . get output stream ( ) ) ; } } finally { wait for process ( ) ; } }	wait for process termination.
public static string extract uri from address ( string addr ) { string uri = addr ; int index = addr . index of ( str ) ; if ( index != - num ) { uri = addr . substring ( index + num , addr . index of ( str , index ) ) ; } return uri ; }	extract the uri part of a sip address.
pbkd ( pbe key spec , string prf algo ) throws invalid key spec exception { char [ ] passwd = key spec . get password ( ) ; if ( passwd == null ) { this . passwd = new char [ num ] ; } else { this . passwd = passwd . clone ( ) ; } byte [ ] passwd bytes = get password bytes ( this . passwd ) ; this . salt = key spec . get salt ( ) ; if ( salt == null ) { throw new invalid key spec exception ( str ) ; } this . iter count = key spec . get iteration count ( ) ; if ( iter count == num ) { throw new invalid key spec exception ( str ) ; } else if ( iter count < num ) { throw new invalid key spec exception ( str ) ; } int key length = key spec . get key length ( ) ; if ( key length == num ) { throw new invalid key spec exception ( str ) ; } else if ( key length < num ) { throw new invalid key spec exception ( str ) ; } try { this . prf = mac . get instance ( prf algo , jce . get instance ( ) ) ; } catch ( no such algorithm exception nsae ) { invalid key spec exception ike = new invalid key spec exception ( ) ; ike . init cause ( nsae ) ; throw ike ; } this . key = derive key ( prf , passwd bytes , salt , iter count , key length ) ; }	creates a pbe key from a given pbe key specification .
private static void show directory creation error ( final string directory ) { final string message = str + str ; final string description = c . create description ( string . format ( str , directory ) , new string [ ] { str } , new string [ ] { str , str } ) ; navi error dialog . show ( null , message , description ) ; }	shows a error dialog in case creating a directory failed .
static byte [ ] pad ( byte [ ] data ) { int len ; if ( data . length < num ) len = data . length ; else len = data . length % num ; if ( len == num ) return data ; else { byte [ ] padding = new byte [ num - len + data . length ] ; for ( int i = padding . length - num ; i > data . length - num ; i -- ) { padding [ i ] = num ; } system . arraycopy ( data , num , padding , num , data . length ) ; return padding ; } }	pads the data so that its length is a multiple of 8 bytes .
public void serialize ( data output out ) throws io { out . write utf ( id ) ; out . write utf ( version ) ; out . write int ( source files . size ( ) ) ; for ( entry < string , list < revision file > > e : source files . entry set ( ) ) { out . write utf ( e . get key ( ) ) ; list < revision file > files = e . get value ( ) ; out . write int ( files . size ( ) ) ; for ( revision file file : files ) { out . write utf ( file . file name ) ; out . write long ( file . size ) ; } } }	serialize the token data for communication between server and client .
public named column projection ( string [ ] names , boolean include ) { m names = new hash set ( ) ; for ( int i = num ; i < names . length ; ++ i ) m names . add ( names [ i ] ) ; m include = include ; }	create a new namedcolumnprojection .
public static time series data serializable instance ( ) { list < string > var names = new array list < > ( ) ; var names . add ( str ) ; var names . add ( str ) ; return new time series data ( new tetrad matrix ( num , num ) , var names ) ; }	generates a simple exemplar of this class to test serialization .
@ override public void write vertices ( final output stream output stream , final iterator < vertex > vertex iterator , final direction direction ) throws io { final buffered writer writer = new buffered writer ( new output stream writer ( output stream ) ) ; try ( final byte array output stream baos = new byte array output stream ( ) ) { if ( wrap adjacency list ) writer . write ( str + son . vertices + str ) ; while ( vertex iterator . has next ( ) ) { write vertex ( baos , vertex iterator . next ( ) , direction ) ; writer . write ( new string ( baos . to byte array ( ) ) ) ; if ( wrap adjacency list ) { if ( vertex iterator . has next ( ) ) writer . write ( str ) ; } else { writer . new line ( ) ; } baos . reset ( ) ; } if ( wrap adjacency list ) writer . write ( str ) ; } writer . flush ( ) ; }	writes a list of vertices in adjacency list format where vertices are written with edges from both directions.
collection < ? extends client request result > handle retrieve configurations request ( final client request configuration request , final session session , final destination reply destination ) { if ( configuration request . get request parameter ( ) != null ) { return configuration loader . get configuration reports ( configuration request . get request parameter ( ) ) ; } else { return configuration loader . get configuration reports ( ) ; } }	inner method which handles a request to retrieve configuration reports.
public static boolean contains class ( @ not null file file , string class name ) { string entry path = class name . replace ( str , str ) + str ; return contains entry ( file , entry path ) ; }	returns true if the given.
private double sin ( double angle ) { while ( angle >= num ) { angle -= num ; } double value = angle / num * math . pi ; return math . sin ( value ) ; }	gets the sinus of the angle .
public void remove ( t graphic ) { synchronized ( m lock ) { m graphics . remove ( graphic ) ; } post invalidate ( ) ; }	removes a graphic from the overlay .
private static void launch debugger ( string dml script str , string fname opt config , map < string , string > arg vals , boolean parse py dml ) throws parse exception , io , dml , dml , language exception , hops exception , lops exception { dml dbprog = new dml ( ) ; dml conf = dml . read configuration file ( fname opt config ) ; configuration manager . set global config ( conf ) ; a parser = a . create parser ( parse py dml ) ; dml prog = parser . parse ( dml file path antlr parser , dml script str , arg vals ) ; dml dmlt = new dml ( prog ) ; dmlt . live variable analysis ( prog ) ; dmlt . validate parse tree ( prog ) ; dmlt . construct hops ( prog ) ; dmlt . rewrite hops dag ( prog ) ; dmlt . construct lops ( prog ) ; dbprog . rtprog = prog . get runtime program ( conf ) ; try { init hadoop execution ( conf ) ; dml m = new dml ( dbprog , dml script str ) ; m . run system ml ( ) ; } finally { cleanup hadoop execution ( conf ) ; } }	launchdebugger : launcher for dml debugger . this method should be called after execution and debug properties have been correctly set , and customized parameters have been put into _argvals.
public static final index create test bank index approved on ( ) { index lastname = new index ( str ) ; lastname . is unique ( bool ) ; array list < index field > fields = new array list < > ( num ) ; fields . add ( new index field ( str , field data type . date time ) ) ; lastname . set fields ( fields ) ; lastname . set table ( fixtures . create test world bank table ( ) ) ; return lastname ; }	creates at test index for bank load approved on date.
public synchronized void accessed ( object object ) { history list . remove ( object ) ; history list . add ( object ) ; }	adds object to history .
public static boolean is empty ( string string ) { return string == null || string . length ( ) <= num ; }	check string is null or empty.
@ override @ suppress warnings ( str ) protected void heapify up comparable ( int pos , object elem ) { final comparable < object > cur = ( comparable < object > ) elem ; while ( pos > num ) { final int parent = ( pos - num ) > > > num ; object par = queue [ parent ] ; if ( cur . compare to ( par ) >= num ) { break ; } queue [ pos ] = par ; index . put ( par , pos ) ; pos = parent ; } queue [ pos ] = cur ; index . put ( cur , pos ) ; }	execute a " heapify upwards " aka " siftup ".
private void update release locks ( ) throws cache exception { if ( num locks . add and get ( - num ) < num ) { throw new cache exception ( str ) ; } if ( eviction policy == eviction policy . lru ) { timestamp . set ( system . nano time ( ) ) ; } else if ( eviction policy == eviction policy . lfu ) { timestamp . add and get ( num ) ; } else if ( eviction policy == eviction policy . min evict ) { } else { throw new cache exception ( str + eviction policy . name ( ) ) ; } }	updates the locks depending on the eviction policy selected.
public static short to short ( char c ) { return short . value of ( to short value ( c ) ) ; }	cast a char value to a short object ( reference type ).
public static void encode dimension ( float value , byte dest [ ] , int offset ) { numeric utils . int to sortable bytes ( numeric utils . float to sortable int ( value ) , dest , offset ) ; }	encode single float dimension.
public long minflt ( ) { return long . parse long ( fields [ num ] ) ; }	the number of minor faults the process has made which have not required loading a memory page from disk .
public static string to string ( final float value ) { return float . to string ( value ) ; }	converts the given value to the xml string value .
public void end filter interval ( ) { end millis = system . current time millis ( ) ; total filter millis += ( end millis - interval start millis ) ; state = task state . other ; }	add time for a filter operation interval .
public string process ( string to process ) { if ( to process == null || to process . length ( ) == num ) return str ; string tmp = str ; string tokenizer st = new string tokenizer ( to process , str , bool ) ; string buffer new value = new string buffer ( to process . length ( ) + num ) ; while ( st . has more tokens ( ) ) { tmp = st . next token ( ) ; if ( has attribute ( tmp ) ) new value . append ( ( string ) get ( tmp ) ) ; else new value . append ( tmp ) ; } return new value . to string ( ) ; }	this method actually performs the filtering .
@ benchmark public long test2 ( ) throws io { long i = num ; for ( map . entry < integer , integer > pair : map . entry set ( ) ) { i += pair . get key ( ) + pair . get value ( ) ; } return i ; }	2 . using foreach and map . entry.
public static final void write list xml ( list val , string name , xml serializer out ) throws xml pull parser exception , java . io . io { if ( val == null ) { out . start tag ( null , str ) ; out . end tag ( null , str ) ; return ; } out . start tag ( null , str ) ; if ( name != null ) { out . attribute ( null , str , name ) ; } int n = val . size ( ) ; int i = num ; while ( i < n ) { write value xml ( val . get ( i ) , null , out ) ; i ++ ; } out . end tag ( null , str ) ; }	flatten a list into an xmlserializer.
public int hash code ( object key ) { return ( key . hash code ( ) & num ) % this . key table . length ; }	return the hashcode for the key parameter.
public atomic array base ( e [ ] array ) { this . array = arrays . copy of ( array , array . length , object [ ] . class ) ; }	creates a new atomicarraybase with the same length as , and all elements copied from , the given array .
public void apply ( ) { set speed map ( ) ; set n ( ) ; }	apply to classes that use this data.
public void push ( final string value ) { if ( value == null ) { mv . visit insn ( opcodes . aconst null ) ; } else { mv . visit ldc insn ( value ) ; } }	generates the instruction to push the given value on the stack .
public void init ( ) { m project tree . set selection path ( new tree path ( m project tree . get root node ( ) ) ) ; }	selects the root node of the project tree .
public int read ( ) throws io { return is . read ( ) ; }	reads the next character .
private void display calendar ( ) { key name pair pp = ( key name pair ) field resource . get selected item ( ) ; if ( pp == null ) return ; int s id = pp . get key ( ) ; m m assignment . set s id ( s id ) ; timestamp date = field date . get timestamp ( ) ; int index = time pane . get selected index ( ) ; log . config ( str + index + str + s id + str + date ) ; m loading = bool ; if ( index == num ) day schedule . recreate ( s id , date ) ; else if ( index == num ) week schedule . recreate ( s id , date ) ; else month schedule . recreate ( s id , date ) ; m loading = bool ; repaint ( ) ; }	display calendar for selected resource , time ( day / week / month ) and date.
public static void assert exception ( runtime exception exception , runnable expression , string error message ) { if ( verbose ) { log ( str + exception + str + expression + str + error message + str ) ; } try { expression . run ( ) ; } catch ( runtime exception failure ) { if ( exception . get class ( ) != failure . get class ( ) ) { test utils . fail ( error message ) ; } return ; } test utils . fail ( error message ) ; }	asserts that a certain exception is raised.
public boolean is parity correct ( byte [ ] [ ] shards , int first byte , int byte count ) { check buffers and sizes ( shards , first byte , byte count ) ; byte [ ] [ ] to check = new byte [ parity shard count ] [ ] ; system . arraycopy ( shards , data shard count , to check , num , parity shard count ) ; return coding loop . check some shards ( parity rows , shards , data shard count , to check , parity shard count , first byte , byte count , null ) ; }	returns true if the parity shards contain the right data .
protected void on send success ( record buffer < r > buffer ) { send success . increment and get ( ) ; logger . trace ( str , name ( ) , buffer ) ; try { checkpointer . save checkpoint ( buffer ) ; } catch ( exception e ) { logger . error ( str , name ( ) , buffer , e ) ; } }	this method should not raise any exceptions .
private boolean is dirty ( ) { return ! objects . equals ( input list . key set ( ) , cmr repository manager . get cmr repository definitions ( ) ) ; }	where there changes performed by user .
public void write ( string s , int off , int len ) { if ( text != null ) { text . append ( s . substring ( off , off + len ) ) ; if ( ( col += len ) > wrap ) println ( ) ; } else { super . write ( s , off , len ) ; flush ( ) ; } }	write a portion of a string .
public zoneset show active zoneset ( integer vsan id ) throws network device controller exception { list < zoneset > zonesets = show zoneset ( vsan id , bool , null , bool , bool ) ; return zonesets . is empty ( ) ? null : zonesets . get ( num ) ; }	collect the active zoneset , and its zones , members for a specified vsan id .
private final short validate perm split factor ( string split factor ) throws ade flow exception { short perm split factor = short . parse short ( split factor ) ; if ( perm split factor <= num || ( ( m outer framing flow . get duration ( ) / perm split factor ) < milliseconds in one minute ) ) { throw new ade flow exception ( str ) ; } return perm split factor ; }	validation for the permanent split factor.
public static calendar to calendar ( string datestring , string format ) { date d = parse ( datestring , format ) ; calendar cal = calendar . get instance ( ) ; cal . set time in millis ( d . get time ( ) ) ; return cal ; }	returns a calendar from a given string using the provided format .
public void test compare to diff signs2 ( ) { byte a bytes [ ] = { num , num , num , - num , - num , num , num , num , num , - num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; int a sign = - num ; int b sign = num ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; assert equals ( - num , a number . compare to ( b number ) ) ; }	compareto ( biginteger a ).
private static void translate compatibility to paths ( rp action ) { if ( action . has ( equip action consts . base object ) ) { list < string > path = arrays . as list ( action . get ( equip action consts . base object ) , action . get ( equip action consts . base slot ) , action . get ( equip action consts . base item ) ) ; action . put ( equip action consts . source path , path ) ; } else { list < string > path = arrays . as list ( action . get ( equip action consts . base item ) ) ; action . put ( equip action consts . source path , path ) ; } }	translate old style object reference to entity path .
public builder add menu item ( @ non null string label , @ non null pending intent pending intent ) { if ( m menu items == null ) m menu items = new array list < > ( ) ; bundle bundle = new bundle ( ) ; bundle . put string ( key menu item title , label ) ; bundle . put parcelable ( key pending intent , pending intent ) ; m menu items . add ( bundle ) ; return this ; }	adds a menu item .
public sparse float vector ( t values , int dimensionality ) throws illegal argument exception { if ( values . size ( ) > dimensionality ) { throw new illegal argument exception ( str ) ; } this . indexes = new int [ values . size ( ) ] ; this . values = new float [ values . size ( ) ] ; { t iter = values . iterator ( ) ; for ( int i = num ; iter . has next ( ) ; i ++ ) { iter . advance ( ) ; this . indexes [ i ] = iter . key ( ) ; } arrays . sort ( this . indexes ) ; } { for ( int i = num ; i < values . size ( ) ; i ++ ) { this . values [ i ] = values . get ( this . indexes [ i ] ) ; } } this . dimensionality = dimensionality ; final int maxdim = get max dim ( ) ; if ( maxdim > dimensionality ) { throw new illegal argument exception ( str + dimensionality + str + maxdim + str ) ; } }	create a sparsefloatvector consisting of double values according to the specified mapping of indices and values .
public byte [ ] canon serialize to byte array ( node node ) throws exception { byte array output stream baos = new byte array output stream ( ) ; canon . set writer ( baos ) ; canon . not reset ( ) ; canon . canonicalize subtree ( node ) ; return baos . to byte array ( ) ; }	use the canonicalizer to serialize the node.
public defined method add description ( string description ) { this . description = optional . of ( description ) ; return this ; }	adds a description to this method .
public int add flattened column ( object o , int [ ] dims ) throws fits exception { return add flattened column ( o , dims , bool ) ; }	add a column where the data is already flattened .
public final void write to stream ( data output stream dos ) throws io { dos . write utf ( event ) ; dos . write utf ( site ) ; dos . write utf ( date ) ; dos . write utf ( round ) ; dos . write utf ( white ) ; dos . write utf ( black ) ; dos . write utf ( io . to fen ( start pos ) ) ; dos . write utf ( time control ) ; dos . write utf ( white time control ) ; dos . write utf ( black time control ) ; int n tags = tag pairs . size ( ) ; dos . write int ( n tags ) ; for ( int i = num ; i < n tags ; i ++ ) { dos . write utf ( tag pairs . get ( i ) . tag name ) ; dos . write utf ( tag pairs . get ( i ) . tag value ) ; } node . write to stream ( dos , root node ) ; array list < integer > path from root = current node . get path from root ( ) ; int path len = path from root . size ( ) ; dos . write int ( path len ) ; for ( int i = num ; i < path len ; i ++ ) dos . write int ( path from root . get ( i ) ) ; }	serialize to output stream .
public void register source ( progress source pi ) { synchronized ( progress source list ) { if ( progress source list . contains ( pi ) ) return ; progress source list . add ( pi ) ; } if ( progress listener list . size ( ) > num ) { array list < progress listener > listeners = new array list < progress listener > ( ) ; synchronized ( progress listener list ) { for ( iterator < progress listener > iter = progress listener list . iterator ( ) ; iter . has next ( ) ; ) { listeners . add ( iter . next ( ) ) ; } } for ( iterator < progress listener > iter = listeners . iterator ( ) ; iter . has next ( ) ; ) { progress listener pl = iter . next ( ) ; progress event pe = new progress event ( pi , pi . get url ( ) , pi . get method ( ) , pi . get content type ( ) , pi . get state ( ) , pi . get progress ( ) , pi . get expected ( ) ) ; pl . progress start ( pe ) ; } } }	register progress source when progress is began .
private static map < string , string > extract key value pairs ( string props , object name mbean ) { map < string , string > map = new linked hash map < string , string > ( ) ; int eq = props . index of ( str ) ; while ( eq != - num ) { string key = props . substring ( num , eq ) ; string value = mbean . get key property ( key ) ; map . put ( key , value ) ; props = props . substring ( key . length ( ) + num + value . length ( ) ) ; if ( props . starts with ( str ) ) { props = props . substring ( num ) ; } eq = props . index of ( str ) ; } return map ; }	parses the mbean objectname comma - separated properties string and puts the individual key / value pairs into the map.
protected void paint content border left edge ( graphics g , int tab placement , int selected index , int x , int y , int w , int h ) { rectangle sel rect = selected index < num ? null : get tab bounds ( selected index , calc rect ) ; g . set color ( select highlight ) ; if ( tab placement != left || selected index < num || ( sel rect . x + sel rect . width + num < x ) || ( sel rect . y < y || sel rect . y > y + h ) ) { g . draw line ( x , y , x , y + h - num ) ; } else { g . draw line ( x , y , x , sel rect . y + num ) ; if ( sel rect . y + sel rect . height < y + h - num ) g . draw line ( x , sel rect . y + sel rect . height + num , x , y + h - num ) ; } }	paint left content border edge.
public final flux < t > sample ( duration timespan ) { return sample millis ( timespan . to millis ( ) ) ; }	emit latest value for every given period of time.
@ override public boolean has values description ( ) { return restriction class != null && restriction class != object . class ; }	this class sometimes provides a list of value descriptions .
public smb file ( string url ) throws url { this ( new url ( null , url , handler . smb handler ) ) ; }	constructs an smbfile representing a resource on an smb network such as a file or directory.
public static boolean is audio ( string mime type ) { if ( mime type != null ) { if ( mime type . starts with ( str ) ) return bool ; else return bool ; } else return bool ; }	returns true if the mime type is a standard audio mime type.
private void restore widget ( key key , byte [ ] buffer , int data size ) throws io { if ( verbose ) log . v ( tag , str + key . id ) ; if ( debug ) log . d ( tag , str + buffer . length + str + base64 . encode to string ( buffer , num , data size , base64 . no wrap ) ) ; widget widget = unpack proto ( new widget ( ) , buffer , data size ) ; if ( debug ) log . d ( tag , str + widget . provider ) ; if ( widget . icon . data != null ) { bitmap icon = bitmap factory . decode byte array ( widget . icon . data , num , widget . icon . data . length ) ; if ( icon == null ) { log . w ( tag , str + key . name ) ; } else { icon cache . preload icon ( m context , component name . unflatten from string ( widget . provider ) , icon , widget . icon . dpi ) ; } } }	read a widget from the stream.
protected int assert line terminates ( int c ) throws io , rdf { c = reader . read ( ) ; c = skip whitespace ( c ) ; if ( c != - num && c != str && c != str ) { report fatal error ( str ) ; } return c ; }	verifies that there is only whitespace until the end of the line .
static private xml construct event ( int event type , wb xml stream reader stream ) throws xml { log . log ( level . fine , str ) ; xml event ; switch ( event type ) { case xml . start document : event = new wb xml start document event ( stream ) ; break ; case xml . end document : event = new wb xml end document event ( stream ) ; break ; case xml . start element : event = new wb xml start element event ( stream ) ; break ; case xml . end element : event = new wb xml end element event ( stream ) ; break ; case xml . characters : case xml . cdata : event = new wb xml characters event ( stream ) ; break ; default : throw new unsupported operation exception ( string . format ( str , event type ) ) ; } log . log ( level . fine , str , event ) ; return event ; }	constructs the events based on the one read from the xmlstreamwriter .
private void verify grid state ( ) { integer row length = null ; int row pos = num ; for ( list < object > row : grid ) { if ( row length != null && row length != row . size ( ) ) { throw new illegal state exception ( str + row length + str + row . size ( ) + str + row pos ) ; } row pos ++ ; row length = row . size ( ) ; } }	verifies that all grid rows are of the same length .
public static string read string and close ( reader in , int length ) throws io { try { if ( length <= num ) { length = integer . max value ; } int block = math . min ( constants . io buffer size , length ) ; string writer out = new string writer ( block ) ; copy and close input ( in , out , length ) ; return out . to string ( ) ; } finally { in . close ( ) ; } }	read a number of characters from a reader and close it .
protected void begin path ( ) { prep drawing ( ) ; m ps . println ( newpath str ) ; m pen x = num ; m pen y = num ; }	called to mark the start of a new path .
private void send tcp request ( socket socket , string request ) throws api exception { try { log utils . logd ( tag , str + request ) ; buffered writer writer = new buffered writer ( new output stream writer ( socket . get output stream ( ) ) ) ; writer . write ( request ) ; writer . flush ( ) ; } catch ( exception e ) { log utils . logw ( tag , str , e ) ; disconnect ( ) ; throw new api exception ( api exception . io exception while sending request , e ) ; } }	send a tcp request.
public static string clean string ( string src ) { if ( src == null ) { return null ; } boolean found bad = bool ; final character iterator it = new string character iterator ( src ) ; for ( char c = it . first ( ) ; c != character iterator . done ; c = it . next ( ) ) { if ( c < ascii printable low || c >= ascii printable hi ) { found bad = bool ; break ; } } if ( ! found bad ) { return src ; } final string builder res = new string builder ( ) ; for ( char c = it . first ( ) ; c != character iterator . done ; c = it . next ( ) ) { if ( c < ascii printable low || c >= ascii printable hi ) { res . append ( ascii space ) ; } else { res . append ( c ) ; } } return res . to string ( ) ; }	returns a string based on the input string , but with all characters with ordinal values < 32 or > = 128 replaced with ' ' .
public static manual lag graph serializable instance ( ) { return new manual lag graph ( manual lag graph params . serializable instance ( ) ) ; }	generates a simple exemplar of this class to test serialization .
public void update actions ( ) { string text ; action a = r . get action ( r . undo action ) ; if ( can undo ( ) ) { a . set enabled ( bool ) ; text = get undo presentation name ( ) ; a . put value ( action . name , text ) ; a . put value ( action . short description , text ) ; } else { if ( a . is enabled ( ) ) { a . set enabled ( bool ) ; text = cant undo text ; a . put value ( action . name , text ) ; a . put value ( action . short description , text ) ; } } a = r . get action ( r . redo action ) ; if ( can redo ( ) ) { a . set enabled ( bool ) ; text = get redo presentation name ( ) ; a . put value ( action . name , text ) ; a . put value ( action . short description , text ) ; } else { if ( a . is enabled ( ) ) { a . set enabled ( bool ) ; text = cant redo text ; a . put value ( action . name , text ) ; a . put value ( action . short description , text ) ; } } }	ensures that undo / redo actions are enabled appropriately and have descriptive text at all times .
public void add scrolling listener ( on wheel scroll listener listener ) { scrolling listeners . add ( listener ) ; }	adds wheel scrolling listener.
public static boolean has dependency ( maven project project , string group id ) { set < artifact > artifacts = project . get artifacts ( ) ; if ( artifacts != null ) { for ( artifact artifact : artifacts ) { string scope = artifact . get scope ( ) ; if ( objects . equal ( str , scope ) ) { continue ; } if ( objects . equal ( group id , artifact . get group id ( ) ) ) { return bool ; } } } return bool ; }	returns true if the maven project has a dependency with the given groupid.
public contour generator ( url url , float model mean , float model stddev ) throws io { this . model mean = model mean ; this . model stddev = model stddev ; list terms list = new array list ( ) ; string line ; buffered reader reader = new buffered reader ( new input stream reader ( url . open stream ( ) ) ) ; line = reader . read line ( ) ; while ( line != null ) { if ( ! line . starts with ( str ) ) { parse and add ( terms list , line ) ; } line = reader . read line ( ) ; } terms = ( f0 model term [ ] ) terms list . to array ( terms ) ; reader . close ( ) ; }	creates a contourgenerator utterance processor .
public void add comment ( string comment ) { if ( frame != null ) { chat tab . add comment ( comment ) ; } if ( tabbed pane . get selected index ( ) == num ) { editor tab . display comment ( comment ) ; } }	adds a comment to the chat window.
private void decompose ( list < object > element pairs , list < object > printer list , list < object > parser list ) { int size = element pairs . size ( ) ; for ( int i = num ; i < size ; i += num ) { object element = element pairs . get ( i ) ; if ( element instanceof date time printer ) { if ( element instanceof composite ) { add array to list ( printer list , ( ( composite ) element ) . i printers ) ; } else { printer list . add ( element ) ; } } element = element pairs . get ( i + num ) ; if ( element instanceof date time parser ) { if ( element instanceof composite ) { add array to list ( parser list , ( ( composite ) element ) . i parsers ) ; } else { parser list . add ( element ) ; } } } }	processes the element pairs , putting results into the given printer and parser lists .
private string process integer token ( string token ) { string result = token . replace all ( str + group separator , str ) ; boolean is negative = bool ; int pre len = negative prefix . length ( ) ; if ( ( pre len > num ) && result . starts with ( negative prefix ) ) { is negative = bool ; result = result . substring ( pre len ) ; } int suf len = negative suffix . length ( ) ; if ( ( suf len > num ) && result . ends with ( negative suffix ) ) { is negative = bool ; result = result . substring ( result . length ( ) - suf len , result . length ( ) ) ; } if ( is negative ) result = str + result ; return result ; }	the integer token must be stripped of prefixes , group separators , and suffixes , non ascii digits must be converted into ascii digits before parse will accept it .
public void write graphics ( string graphics save file ) throws io { file output stream ostream = new file output stream ( graphics save file ) ; object output stream objectstream = new object output stream ( ostream ) ; write graphics ( objectstream ) ; objectstream . close ( ) ; }	write the graphics out to a file.
@ override public void add input node ( b input node ) { super . add input node ( input node ) ; }	adds a new ( input ) relation for the node.
public void remove dependency ( task dependency dep ) { node src node = my node map . get ( dep . get dependee ( ) ) ; node dst node = my node map . get ( dep . get dependant ( ) ) ; if ( src node == null && dst node == null ) { return ; } assert ( src node != null && dst node != null ) : str + dep + str ; dependency edge died edge = find explicit dependency ( dep , src node , dst node ) ; if ( died edge == null ) { return ; } remove edge ( died edge ) ; for ( dependency edge edge : lists . new array list ( src node . get outgoing ( ) ) ) { if ( edge instanceof implicit inherited dependency ) { if ( ( ( implicit inherited dependency ) edge ) . my explicit dep == died edge ) { remove edge ( edge ) ; } } } fire graph changed ( ) ; }	removes explicit dependency . also removes all inherited dependencies constructed from that one.
public vn modify consistency group async ( string id , lun group modify param param ) { string builder url bld = new string builder ( url modif ) ; url bld . append ( id ) ; url bld . append ( url modif ) ; url = url bld . to string ( ) ; return post request async ( param ) ; }	modify consistency group in async mode.
public object read remote ( ) throws io { string type = read type ( ) ; string url = read string ( ) ; return resolve remote ( type , url ) ; }	reads a remote object .
private static j create chart ( ) { xy series1 = new xy ( str ) ; series1 . add ( num , num ) ; series1 . add ( num , num ) ; series1 . add ( num , num ) ; xy dataset = new xy ( series1 ) ; return chart factory . create time series chart ( str , str , str , dataset , bool , bool , bool ) ; }	create a horizontal bar chart with sample data in the range - 3 to + 3 .
private void dt ( ) throws sax , io { final java . io . writer writer = m writer ; if ( m need to output doc type decl ) { output doc type decl ( m elem context . m element name , bool ) ; m need to output doc type decl = bool ; } if ( m in doctype ) { writer . write ( str ) ; writer . write ( m line sep , num , m line sep len ) ; m in doctype = bool ; } }	a private helper method to output the.
public cache set query sequential ( predicate ... selectors ) { check not null ( selectors ) ; collection < object > result collection = new array list < > ( items ) ; collection < object > filter collection = new linked list < > ( ) ; collection < object > temp collection ; int i = num ; while ( ( i < selectors . length ) && ( result collection . size ( ) > num ) ) { collection utils . select ( result collection , selectors [ i ] , filter collection ) ; temp collection = result collection ; result collection = filter collection ; filter collection = temp collection ; filter collection . clear ( ) ; i ++ ; } return new cache set ( result collection ) ; }	sequential filtering by selectors.
@ override public boolean is error enabled ( ) { return logger . is loggable ( level . severe ) ; }	is this logger instance enabled for level severe ?.
public static < a > t < a > from stream ( final m < stream < a > > monads ) { return of ( monads . map ( null ) ) ; }	create a sett from an anym that wraps a monad containing a stream.
public static cc fnt ( string fnt file ) { cc ret = null ; if ( configurations == null ) configurations = new hash map < string , cc > ( ) ; ret = configurations . get ( fnt file ) ; if ( ret == null ) { ret = cc . configuration ( fnt file ) ; configurations . put ( fnt file , ret ) ; } return ret ; }	free function that parses a fnt file a place it on the cache.
public void add criteria ( criteria other criteria ) { if ( other criteria instanceof advanced criteria || other criteria instanceof criterion ) { throw new illegal argument exception ( str + str ) ; } map other map = other criteria . get values ( ) ; set other keys = other map . key set ( ) ; for ( iterator i = other keys . iterator ( ) ; i . has next ( ) ; ) { string field = ( string ) i . next ( ) ; object value = other map . get ( field ) ; jso . set attribute ( js obj , field , value ) ; } }	adds the criteria from the passed criteria object .
public d ( j parent , byte [ ] value ) throws io { super ( parent ) ; set title ( res . get string ( str ) ) ; init components ( ) ; prepopulate with value ( value ) ; }	creates a new dnetscapesslservername dialog .
public static event bean [ ] resize array ( event bean [ ] old array , int new size ) { if ( old array == null ) { return null ; } if ( old array . length == new size ) { return old array ; } event bean [ ] new array = new event bean [ new size ] ; int preserve length = math . min ( old array . length , new size ) ; if ( preserve length > num ) { system . arraycopy ( old array , num , new array , num , preserve length ) ; } return new array ; }	resizes an array of events to a new size.
public static spannable string span text ( char sequence text , object ... spans ) { spannable string spannable string = new spannable string ( text ) ; for ( object span : spans ) { spannable string . set span ( span , num , text . length ( ) , spanned . span exclusive exclusive ) ; } return spannable string ; }	sets span objects to the text.
@ suppress warnings ( str ) protected < t > list < t > query ( class < t > model class , string [ ] columns , string selection , string [ ] selection args , string group by , string having , string order by , string limit , list < associations info > foreign key associations ) { list < t > data list = new array list < t > ( ) ; cursor cursor = null ; try { list < field > supported fields = get supported fields ( model class . get name ( ) ) ; string table name = get table name ( model class ) ; string [ ] customized columns = get customized columns ( columns , foreign key associations ) ; cursor = m database . query ( table name , customized columns , selection , selection args , group by , having , order by , limit ) ; if ( cursor . move to first ( ) ) { sparse array < query info cache > query info cache sparse array = new sparse array < query info cache > ( ) ; do { t model instance = ( t ) create instance from class ( model class ) ; give base obj id value ( ( data support ) model instance , cursor . get long ( cursor . get column index or throw ( str ) ) ) ; set value to model ( model instance , supported fields , foreign key associations , cursor , query info cache sparse array ) ; if ( foreign key associations != null ) { set associated model ( ( data support ) model instance ) ; } data list . add ( model instance ) ; } while ( cursor . move to next ( ) ) ; query info cache sparse array . clear ( ) ; } return data list ; } catch ( exception e ) { e . print stack trace ( ) ; throw new data support exception ( e . get message ( ) ) ; } finally { if ( cursor != null ) { cursor . close ( ) ; } } }	query the table of the given model , returning a model list over the result set .
private mlt build query for field ( string field name , priority queue < mlt > q , boolean query query , boolean content stream query ) { list < mlt > interesting terms = new array list < mlt > ( ) ; int qterms = num ; int max terms = max query terms per field ; if ( max terms <= num ) { max terms = integer . max value ; } boolean query tmp query = new boolean query ( ) ; double sum quared boost = num ; mlt cur ; while ( ( cur = q . pop ( ) ) != null ) { query tq = null ; final term term = new term ( cur . get field name ( ) , cur . get word ( ) ) ; if ( is payload field ( cur . get field name ( ) ) ) { tq = new payload term query ( term , new average payload function ( ) , bool ) ; } else { tq = new term query ( term ) ; } if ( boost ) { float boost = cur . get score ( ) ; tq . set boost ( boost ) ; sum quared boost += boost * boost ; } else { sum quared boost += num ; } try { tmp query . add ( tq , boolean clause . occur . should ) ; interesting terms . add ( cur ) ; qterms ++ ; } catch ( boolean query . too many clauses ignore ) { break ; } if ( qterms >= max terms ) { break ; } } double vector length = math . sqrt ( sum quared boost ) ; if ( vector length <= num ) { return new mlt ( interesting terms , query ) ; } build boosted normalized query ( field name , tmp query , query , vector length , content stream query ) ; return new mlt ( interesting terms , query ) ; }	build the more queryfromdocuments query from a priorityqueue and an initial boolean query.
@ suppress warnings ( str ) protected void sequentially ( consumer < marker > ... functions ) { if ( functions == null || functions . length == num ) return ; collection < parsing exception > errors = new array list < > ( ) ; marker marker = tokens . mark ( ) ; for ( consumer < marker > function : functions ) { try { function . accept ( marker ) ; return ; } catch ( parsing exception e ) { errors . add ( e ) ; tokens . rewind ( marker ) ; } } parsing failed ( marker . position ( ) , errors , str ) ; }	try calling the supplied functions in sequence , stopping as soon as one of them succeeds .
public pid file ( final file file ) throws file not found exception { if ( ! file . exists ( ) || ! file . is file ( ) ) { throw new file not found exception ( str + file + str ) ; } this . pid file = file ; }	constructs a pidfile for reading pid stored in a file .
public void add child node ( exec node child node ) { child nodes . add ( child node ) ; }	add a child node .
static private double quick select ( i x , int k , int start , int end ) { if ( k < start || k > end ) { throw new ade core illegal argument exception ( str ) ; } final int pivot index = ( ( int ) math . random ( ) * ( end - start + num ) ) + start ; final int pivot position = partition ( x , start , end , pivot index ) ; if ( pivot position == k ) { return x . get ( k ) ; } else if ( pivot position < k ) { return quick select ( x , k , pivot position + num , end ) ; } else { return quick select ( x , k , start , pivot position - num ) ; } }	quicksort like algorithm to select k ' th member.
public bayes im editor obs ( bayes im wrapper obs bayes im wrapper obs ) { this ( bayes im wrapper obs , bayes im wrapper obs . get bayes im ( ) ) ; }	constructs a new instanted model editor from a bayes im wrapper .
private list < string > convert byte array list to string value list ( list < byte [ ] > dictionary byte array list ) { list < string > value list = new array list < > ( dictionary byte array list . size ( ) ) ; for ( byte [ ] value : dictionary byte array list ) { value list . add ( new string ( value , charset . for name ( carbon common constants . default charset ) ) ) ; } return value list ; }	this method will convert list of byte array to list of string.
public file tree node ( file parent , string name ) throws security exception , file not found exception { this ( parent . to path ( ) , name ) ; }	instantiates a new file tree node .
private list < node > possible parents ( node x , list < node > adjx , i knowledge ) { list < node > possible parents = new linked list < > ( ) ; string x = x . get name ( ) ; for ( node z : adjx ) { string z = z . get name ( ) ; if ( possible parent of ( z , x , knowledge ) ) { possible parents . add ( z ) ; } } return possible parents ; }	removes from the list of nodes any that cannot be parents of x given the background knowledge .
public synchronized void remove ( abstract option option ) { if ( options . contains ( option ) ) { int position = index of ( option ) ; list < abstract option > old options = new array list < abstract option > ( options ) ; options . remove ( option ) ; list < abstract option > new options = get options ( ) ; option . set collection ( null ) ; fire indexed property change ( prop options , position , old options , new options ) ; } }	removes an abstractoption from the container.
private float [ ] calculate pointer position ( float angle ) { float x = ( float ) ( m color wheel radius * math . cos ( angle ) ) ; float y = ( float ) ( m color wheel radius * math . sin ( angle ) ) ; return new float [ ] { x , y } ; }	calculate the pointer ' s coordinates on the color wheel using the supplied angle .
private void handle process error ( job definition job , process process ) throws io { string buffer sb = new string buffer ( ) ; buffered reader in = new buffered reader ( new input stream reader ( process . get input stream ( ) ) ) ; int data = num ; while ( data != - num && ! is interrupted ( ) ) { data = in . read ( ) ; if ( data != - num ) { sb . append ( ( char ) data ) ; } } logger . warn ( str + job . cut + str + sb . to string ( ) ) ; }	print process console output if it died , as its logs on disks might not have been generated yet.
private void check class and sync ( class < ? extends i > clazz ) { if ( ! registered classes . contains ( clazz ) ) { throw new runtime exception ( str + clazz + str ) ; } while ( is currently sending semaphor ) { thread . yield ( ) ; } is currently sending semaphor = bool ; }	since the crash that happens if we dont do this is complete garbage.
private static int calculate displayed width ( string string ) { final int tab width = default tab width ; int column = num ; for ( int i = num ; i < string . length ( ) ; i ++ ) { if ( str == string . char at ( i ) ) { column += tab width - ( column % tab width ) ; } else { column ++ ; } } return column ; }	returns the displayed width of a string , taking in account the displayed tab width.
@ override public int read ( ) { if ( idx >= char sequence . length ( ) ) { return - num ; } else { return char sequence . char at ( idx ++ ) ; } }	read a single character .
public void test get client aliases ( ) { init ( client ) ; assert null ( manager . get client aliases ( null , null ) ) ; assert null ( manager . get client aliases ( str , null ) ) ; string [ ] res array = manager . get client aliases ( type rsa , null ) ; assert not null ( res array ) ; assert equals ( num , res array . length ) ; assert known aliases ( res array ) ; }	x509keymanager # getclientaliases ( string keytype , principal [ ] issuers ).
public static void println ( char x ) { out . println ( x ) ; }	prints a character to standard output and then terminates the line .
private boolean should position avatar on right ( ) { final boolean is rtl = build . version . sdk int >= build . version codes . jelly bean m ? get layout direction ( ) == layout direction rtl : bool ; final boolean assigned position = m avatar position == avatar position end ; return is rtl ? ! assigned position : assigned position ; }	returns true if the avatar should be positioned at the right edge of the chip.
public static void fail ( string message ) { throw new illegal state exception ( message == null ? str : message ) ; }	fails a test with the given message .
public void memset buffer ( byte buffer buffer ) { memset buffer ( buffer , buffer . limit ( ) ) ; }	it will reset all the positions on the buffer to 0 , using memset .
protected list < item type > select fold test items ( list < item type > items , int n folds , int fold ) { list < item type > test items = new array list < item type > ( ) ; for ( int i = num ; i < items . size ( ) ; ++ i ) { if ( i % n folds == fold ) { test items . add ( items . get ( i ) ) ; } } return test items ; }	determines which items should be used for testing in one fold of a cross - validation.
public final char sequence translator with ( final char sequence translator ... translators ) { final char sequence translator [ ] new array = new char sequence translator [ translators . length + num ] ; new array [ num ] = this ; system . arraycopy ( translators , num , new array , num , translators . length ) ; return new aggregate translator ( new array ) ; }	helper method to create a merger of this translator with another set of translators.
@ override public boolean equals ( object other ) { if ( ! ( other instanceof sha256 hash ) ) return bool ; return arrays . equals ( bytes , ( ( sha256 hash ) other ) . bytes ) ; }	returns true if the hashes are equal .
public config ( solr resource loader loader , string name ) throws parser configuration exception , io , sax { this ( loader , name , null , null ) ; }	builds a config from a resource name with no xpath prefix .
private static hash map < string , field > build field cache ( class < ? > cls ) { final hash map < string , field > cache = new hash map < > ( ) ; final list < field > fields = get all fields ( cls ) ; for ( field fld : fields ) { string name = null ; final reference ref ann = fld . get annotation ( reference . class ) ; if ( ref ann != null ) name = select column name ( ref ann , fld ) ; if ( name == null ) { final column col ann = fld . get annotation ( column . class ) ; if ( col ann != null ) name = select column name ( col ann , fld ) ; } if ( name == null ) continue ; cache . put ( name , fld ) ; } return cache ; }	avoids the need to loop over fields for every column by caching them ahead of time .
public static long convert duration ( final string from unit , final string to unit , long value ) { time unit from time unit = to time unit ( from unit ) ; time unit to time unit = to time unit ( to unit ) ; if ( from time unit != null && to time unit != null ) { return to time unit . convert ( value , from time unit ) ; } else { throw new dss ( str + from unit + str + to unit + str + value + str ) ; } }	converts the given time duration ( value ) in the given unit ( fromunit ) to given unit ( tounit ) .
public static file search for groovy script file ( string input ) { string script file name = input . trim ( ) ; file script file = new file ( script file name ) ; string [ ] standard extensions = { str , str , str , str } ; int i = num ; while ( i < standard extensions . length && ! script file . exists ( ) ) { script file = new file ( script file name + standard extensions [ i ] ) ; i ++ ; } if ( ! script file . exists ( ) ) { script file = new file ( script file name ) ; } return script file ; }	search for the script file , doesn ' t bother if it is named precisely.
public x execute ( x xctxt ) throws javax . xml . transform . transformer exception { if ( xctxt . is secure processing ( ) ) throw new javax . xml . transform . transformer exception ( xpath . create xpath ( xpath . er extension function cannot be invoked , new object [ ] { to string ( ) } ) ) ; x result ; vector arg vec = new vector ( ) ; int n args = m arg vec . size ( ) ; for ( int i = num ; i < n args ; i ++ ) { expression arg = ( expression ) m arg vec . element at ( i ) ; x xobj = arg . execute ( xctxt ) ; xobj . allow detach to release ( bool ) ; arg vec . add element ( xobj ) ; } extensions provider ext provider = ( extensions provider ) xctxt . get owner object ( ) ; object val = ext provider . ext function ( this , arg vec ) ; if ( null != val ) { result = x . create ( val , xctxt ) ; } else { result = new x ( ) ; } return result ; }	execute the function . the function must return a valid object .
private header create security header ( ) { return new basic header ( str , str + create auth ( ) ) ; }	todo : currently the repo only supports form based authentication.
public picture ( file file ) { try { image = io . read ( file ) ; } catch ( io e ) { e . print stack trace ( ) ; throw new runtime exception ( str + file ) ; } if ( image == null ) { throw new runtime exception ( str + file ) ; } width = image . get width ( null ) ; height = image . get height ( null ) ; filename = file . get name ( ) ; }	initializes a picture by reading in a.
static annotation strategy strategy for ( annotation annotation ) { check not null ( annotation , str ) ; class < ? extends annotation > annotation type = annotation . annotation type ( ) ; ensure retained at runtime ( annotation type ) ; ensure is binding annotation ( annotation type ) ; if ( annotation type . get declared methods ( ) . length == num ) { return new annotation type strategy ( annotation type , annotation ) ; } return new annotation instance strategy ( annotation ) ; }	gets the strategy for an annotation .
private void add volume to block consistency group ( uri cg uri , volume volume ) { volume . add consistency group ( cg uri . to string ( ) ) ; db client . persist object ( volume ) ; }	associates a volume with a given blockconsistencygroup uri .
public static boolean lazy gaussian elimination ( final int var2 eq [ ] [ ] , final long [ ] c , final int [ ] variable , final long [ ] solution ) { return lazy gaussian elimination ( null , var2 eq , c , variable , solution ) ; }	solves a system using lazy gaussian elimination .
public void compress my own way ( int [ ] indexes ) { list < integer > list = new array list < integer > ( carbon common constants . constant size ten ) ; list < integer > map = new array list < integer > ( carbon common constants . constant size ten ) ; int k = num ; int i = num ; for ( ; i < indexes . length ; i ++ ) { if ( indexes [ i ] - indexes [ i - num ] == num ) { k ++ ; } else { if ( k > num ) { map . add ( ( list . size ( ) ) ) ; list . add ( indexes [ i - k - num ] ) ; list . add ( indexes [ i - num ] ) ; } else { list . add ( indexes [ i - num ] ) ; } k = num ; } } if ( k > num ) { map . add ( ( list . size ( ) ) ) ; list . add ( indexes [ i - k - num ] ) ; list . add ( indexes [ i - num ] ) ; } else { list . add ( indexes [ i - num ] ) ; } data after comp = convert to array ( list ) ; if ( indexes . length == data after comp . length ) { index map = new int [ num ] ; } else { index map = convert to array ( map ) ; } if ( data after comp . length == num && index map . length == num ) { already sorted = bool ; } }	it compresses depends up on the sequence numbers.
private void prepend decrement ( basic block bb , ir ir ) { if ( debug ) vm . sys write ( str + bb + str ) ; register operand use = cbs reg . copy ro ( ) ; register operand def = use . copy u2 d ( ) ; instruction inc = binary . create ( int add , def , use , ir . ic ( - num ) ) ; bb . prepend instruction ( inc ) ; }	append a decrement of the global counter to the given basic block . tested in lir only !.
public void add listener ( connectable device listener listener ) { if ( ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } }	adds the connectabledevicelistener to the list of listeners for this connectabledevice to receive certain events .
private static final string to hex string ( final byte [ ] bs ) { string hex = str ; string builder res = new string builder ( ) ; for ( byte b : bs ) { res . append ( hex . char at ( ( ( b > > > num ) & num ) ) ) ; res . append ( hex . char at ( ( b & num ) ) ) ; } return res . to string ( ) ; }	convert and array of bytes to a hex string .
public double distance to the left ( pla line int p line ) { double result = integer . max value ; for ( int index = num ; index < border line count ( ) ; ++ index ) { pla point float curr corner = corner approx ( index ) ; pla side line side = p line . side of ( curr corner , num ) ; if ( line side == pla side . collinear ) { line side = p line . side of ( corner ( index ) ) ; } if ( line side == pla side . on the right ) return - num ; result = math . min ( result , p line . distance signed ( curr corner ) ) ; } return result ; }	calculates the minimal distance of p_line to this shape , assuming , that p_line is on the left of this shape .
public boolean display topic from names ( string [ ] names ) { if ( names . length == num ) return display topic ( default ) ; else { string buffer help name = new string buffer ( ) ; for ( string name : names ) { if ( help name . length ( ) > num ) help name . append ( str ) ; help name . append ( name ) ; } return display topic ( help name . to string ( ) ) ; } }	display help for a topic.
public boolean accept identical ( string file path , string file name ) { if ( file name glob == null ) return bool ; if ( file name != null && file name . equals ignore case ( file name glob ) ) return bool ; if ( file path != null ) { int last unix pos = file path . last index of ( str ) ; int last windows pos = file path . last index of ( str ) ; int index = math . max ( last unix pos , last windows pos ) ; string filename = file path . substring ( index + num ) ; return filename != null && filename . equals ignore case ( file name glob ) ; } return bool ; }	returns true if the buffer path or name is identical to the file name glob.
private void validate num cores block sort ( ) { string num cores str = carbon properties . get property ( carbon common constants . num cores block sort , carbon common constants . num cores block sort default val ) ; try { int num cores = integer . parse int ( num cores str ) ; if ( num cores < carbon common constants . num cores block sort min val || num cores > carbon common constants . num cores block sort max val ) { logger . info ( str + num cores str + str + carbon common constants . num cores block sort default val ) ; carbon properties . set property ( carbon common constants . num cores block sort , carbon common constants . num cores block sort default val ) ; } } catch ( number format exception e ) { logger . info ( str + num cores str + str + carbon common constants . num cores block sort default val ) ; carbon properties . set property ( carbon common constants . num cores block sort , carbon common constants . num cores block sort default val ) ; } }	this method validates the number cores specified for mdk block sort.
public static memory match fragment new instance ( ) { return new memory match fragment ( ) ; }	create a new instance of this fragment .
static void create file from resource ( string resource , resource file ) throws io { create file from resource ( resource , file , null ) ; }	creates a file and his content froma a resurce.
public static void perspective m ( double [ ] m , int offset , double fovy , double aspect , double z near , double z far ) { double f = num / math . tan ( fovy * ( math . pi / num ) ) ; double range reciprocal = num / ( z near - z far ) ; m [ offset + num ] = f / aspect ; m [ offset + num ] = num ; m [ offset + num ] = num ; m [ offset + num ] = num ; m [ offset + num ] = num ; m [ offset + num ] = f ; m [ offset + num ] = num ; m [ offset + num ] = num ; m [ offset + num ] = num ; m [ offset + num ] = num ; m [ offset + num ] = ( z far + z near ) * range reciprocal ; m [ offset + num ] = - num ; m [ offset + num ] = num ; m [ offset + num ] = num ; m [ offset + num ] = num * z far * z near * range reciprocal ; m [ offset + num ] = num ; }	define a projection matrix in terms of a field of view angle , an aspect ratio , and z clip planes.
protected double compute ( string value ) { if ( value != null ) { try { return double . parse double ( value ) ; } catch ( number format exception e ) { if ( positive infinity string . equals ( value ) ) { return double . positive infinity ; } else if ( negative infinity string . equals ( value ) ) { return double . negative infinity ; } return double . n ; } } return double . n ; }	computes the result for one input string value .
boolean is duplicate role column ( int column ) { return duplicate role column . contains ( column ) ; }	whether the column has a role that is also used in another column .
public timestamp speechlet request verifier ( long tolerance , time unit unit ) { if ( tolerance < num ) { throw new illegal argument exception ( str ) ; } tolerance in milliseconds = unit . to millis ( tolerance ) ; }	constructs a new timestamp verifier with the provided tolerance ( in the provided units ) .
public void shutdown ( ) { count down latch wait l ; synchronized ( this ) { wait l = wait shutdown ; } ind = bool ; try { if ( wait l != null ) { if ( wait l . await ( num , time unit . milliseconds ) ) log . info ( str ) ; else log . warn ( str ) ; } else { log . info ( str ) ; } } catch ( interrupted exception int exc ) { log . warn ( str ) ; } }	shut down the service , waiting up to 3 seconds for the service to terminate .
void paint strokes ( rectangle r , graphics g , int axis , int [ ] length pattern , color [ ] color pattern ) { boolean x axis = ( axis == view . x axis ) ; int start = num ; int end = ( x axis ? r . width : r . height ) ; while ( start < end ) { for ( int i = num ; i < length pattern . length ; i ++ ) { if ( start >= end ) { break ; } int length = length pattern [ i ] ; color c = color pattern [ i ] ; if ( c != null ) { int x = r . x + ( x axis ? start : num ) ; int y = r . y + ( x axis ? num : start ) ; int width = x axis ? length : r . width ; int height = x axis ? r . height : length ; g . set color ( c ) ; g . fill rect ( x , y , width , height ) ; } start += length ; } } }	paint strokes repeatedly using the given length and color patterns .
public string fill param with event attrib ( string param data , event event ) { if ( ! database . is open ( ) ) { throw new illegal state exception ( tag + str ) ; } string builder ret val = new string builder ( ) ; int cursor = num ; while ( cursor < param data . length ( ) ) { int open bracket idx = param data . index of ( str , cursor ) ; int close bracket idx = param data . index of ( str , cursor ) ; if ( open bracket idx == - num || close bracket idx == - num || open bracket idx + num >= close bracket idx ) { ret val . append ( param data . substring ( cursor ) ) ; break ; } string attr = param data . substring ( open bracket idx + num , close bracket idx ) ; string param = param data . substring ( open bracket idx , close bracket idx + num ) ; string param attr ; try { param attr = event . get attribute ( attr ) ; } catch ( illegal argument exception e ) { param attr = param ; } ret val . append ( param data . substring ( cursor , open bracket idx ) ) ; ret val . append ( param attr ) ; cursor = close bracket idx + num ; } log . d ( str , param data + str + ret val . to string ( ) ) ; return ret val . to string ( ) ; }	this method checks the parameter data to see if it already has value or it should extract value from the event.
public static double two pow ( int power ) { if ( power <= - max double exponent ) { if ( power >= min double exponent ) { return double . long bits to double ( num > > ( - ( power + max double exponent ) ) ) ; } else { return num ; } } else if ( power > max double exponent ) { return double . positive infinity ; } else { return double . long bits to double ( ( ( long ) ( power + max double exponent ) ) << num ) ; } }	net . jodk . fastmath class has a typically faster version of this method , using look - up tables . returns the exact result , provided it ' s in double range , i . e . if power is in [ - 1074 , 1023 ] .
@ suppress warnings ( str ) public static type resolve type variable ( type variable name , class declaring class , class top class ) { type type = resolve type variable ( name , declaring class , new hash map < > ( ) , top class ) ; if ( type == null ) { type = object . class ; } return type ; }	given a type variable , find what it resolves to given the declaring class where type variable was found and a top class that extends the declaring class .
private resource impl aggregate ( resource impl resource a , resource impl resource b ) throws not found exception { final string type id = resource a . get type ( ) ; final resource type resource type = get resource type ( type id ) ; return resource type . aggregate ( resource a , resource b ) ; }	aggregates two resources which have the same type .
public static boolean rename file ( string file path , string old filename , string new filename ) { if ( ( file path == null ) || file path . is empty ( ) || ( old filename == null ) || old filename . is empty ( ) || ( new filename == null ) || new filename . is empty ( ) ) { return bool ; } file old file = new file ( file path + file . separator + old filename ) ; file new file = new file ( file path + file . separator + new filename ) ; boolean is successful rename ; try { is successful rename = old file . rename to ( new file ) ; } catch ( exception e ) { logger . debug ( e . to string ( ) + system . line separator ( ) + stack trace . get string from stack trace ( e ) ) ; is successful rename = bool ; } return is successful rename ; }	this is a quiet method .
@ rpc method public void start image scan ( string data store , long scan rate , long timeout , async method callback < host . async client . start image scan call > handler ) throws rpc exception { ensure client ( ) ; start image scan request request = new start image scan request ( data store ) ; if ( null != scan rate ) { request . set scan rate ( scan rate ) ; } if ( null != timeout ) { request . set timeout ( timeout ) ; } try { logger . info ( str , get host ip ( ) , request ) ; client proxy . set timeout ( start image scan timeout ms ) ; client proxy . start image scan ( request , handler ) ; } catch ( t e ) { throw new rpc exception ( e . get message ( ) ) ; } }	this method performs an asynchronous thrift call to start an image scan on a datastore .
public static string format ( int n , string col ) { string res = padd + n ; return res . substring ( res . length ( ) - col . length ( ) ) ; }	pad a number from left .
public git conflict exception ( string message ) { super ( message ) ; }	constrcut a new gitconflictexception based on message.
private void trace ( ) { gl use program ( photon trace program ) ; long this time = system . nano time ( ) ; float elapsed seconds = ( this time - first time ) / num ; gl uniform1f ( time uniform , elapsed seconds ) ; gl bind buffer base ( gl shader storage buffer , boxes ssbo binding , ssbo ) ; gl bind buffer base ( gl uniform buffer , images ubo binding , image handles ubo ) ; int invocations per dimension = photons per frame ; int worksize x = math round po t ( invocations per dimension ) ; int worksize y = math round po t ( invocations per dimension ) ; if ( variable group size ) { arb . gl dispatch compute group size arb ( worksize x / work group size x , worksize y / work group size y , num , work group size x , work group size y , num ) ; } else { gl dispatch compute ( worksize x / work group size x , worksize y / work group size y , num ) ; } gl memory barrier ( gl shader image access barrier bit ) ; gl bind buffer base ( gl shader storage buffer , boxes ssbo binding , num ) ; gl bind buffer base ( gl uniform buffer , images ubo binding , num ) ; gl use program ( num ) ; }	trace some rays from the light .
public caption add element ( string element ) { add element to registry ( integer . to string ( element . hash code ( ) ) , element ) ; return ( this ) ; }	add an element to the element.
protected void do reset current position ( ) { this . current position = this . position ; }	method to reset the current position.
public float buffer put ( float [ ] src , int src offset , int float count ) { j . check offset and count ( src . length , src offset , float count ) ; if ( float count > remaining ( ) ) { throw new buffer overflow exception ( ) ; } for ( int i = src offset ; i < src offset + float count ; ++ i ) { put ( src [ i ] ) ; } return this ; }	writes floats from the given float array , starting from the specified offset , to the current position and increases the position by the number of floats written .
private boolean message changed ( string old message , string new message ) { return ( ( new message == null ) && ( old message != null ) ) || ( ( new message != null ) && ! new message . equals ( old message ) ) ; }	check if a message string has changed .
private multi line string read multi line ( ora geom ora geom ) { int n elem = ora geom . num elements ( ) ; list geoms = new array list ( ) ; for ( int i = num ; i < n elem ; i ++ ) { int etype = ora geom . e type ( i ) ; if ( etype != ora geom . etype . line ) break ; geoms . add ( read line ( ora geom , i ) ) ; } multi line string lines = geometry factory . create multi line string ( geometry factory . to line string array ( geoms ) ) ; return lines ; }	create multilinestring as encoded by eleminfo .
public boolean is called method ( string class name , string method name ) { if ( to test methods . is empty ( ) ) compute interesting classes ( graph ) ; if ( to test methods . contains ( class name + method name ) ) { return bool ; } return bool ; }	determine if methodname of classname can be called through the target class.
public explanation idf explain ( collection statistics collection stats , term statistics term stats [ ] ) { final long doc count = collection stats . doc count ( ) == - num ? collection stats . max doc ( ) : collection stats . doc count ( ) ; float idf = num ; list < explanation > details = new array list < > ( ) ; for ( final term statistics stat : term stats ) { final long df = stat . doc freq ( ) ; final float term idf = idf ( df , doc count ) ; details . add ( explanation . match ( term idf , str + df + str + doc count + str ) ) ; idf += term idf ; } return explanation . match ( idf , str , details ) ; }	computes a score factor for a phrase.
public void remove area ( final section area ) { if ( null == area ) return ; areas . remove ( area ) ; collections . sort ( areas , new section comparator ( ) ) ; fire update event ( section event ) ; }	removes the given section from the list of areas.
public void test empty run index ( ) { string rs = str ; settings s = new settings ( str ) ; s . set secondary namespace ( str ) ; assert equals ( s . get int ( rs ) , num ) ; settings . set run index ( num ) ; assert equals ( s . get int ( rs ) , num ) ; settings . set run index ( num ) ; assert equals ( s . get int ( rs ) , num ) ; settings . set run index ( num ) ; assert equals ( s . get int ( rs ) , num ) ; }	test filling empty values of run index from secondary namespace.
@ suppress warnings ( str ) public void connect ( final bluetooth device device , final i session ) { if ( m managed devices . contains ( device ) ) return ; m managed devices . add ( device ) ; ble manager < ble manager callbacks > manager = m ble managers . get ( device ) ; if ( manager != null ) { if ( session != null ) manager . set logger ( session ) ; manager . connect ( device ) ; } else { m ble managers . put ( device , manager = initialize manager ( ) ) ; manager . set gatt callbacks ( ble multiconnect profile service . this ) ; manager . set logger ( session ) ; manager . connect ( device ) ; } }	adds the given device to managed and stars connecting to it.
public scanner exception ( error messages message ) { this ( null , error messages . get ( message ) , message , - num , - num ) ; }	creates a new scannerexception with a message only .
private static void format time zone ( calendar cal , string builder buf ) { time zone tz = cal . get time zone ( ) ; if ( tz == null ) return ; int offset ; if ( tz . in daylight time ( cal . get time ( ) ) ) { offset = tz . get raw offset ( ) + ( tz . use daylight time ( ) ? num : num ) ; } else { offset = tz . get raw offset ( ) ; } if ( offset == num ) { buf . append ( str ) ; return ; } if ( offset >= num ) buf . append ( str ) ; else { buf . append ( str ) ; offset *= - num ; } offset /= num * num ; format two digits ( offset / num , buf ) ; buf . append ( str ) ; format two digits ( offset % num , buf ) ; }	formats time zone specifier .
public mutable string ( final mutable string s ) { make compact mutable string ( s . length ( ) ) ; system . arraycopy ( s . array , num , array , num , array . length ) ; }	creates a new compact mutable string copying a given mutable string .
private void request ( ) { if ( is visible ( ) && stream != null && ! stream . is empty ( ) ) { loading = bool ; if ( type == type . followers ) { api . get followers ( stream ) ; } else if ( type == type . subscribers ) { api . get subscribers ( stream ) ; } } }	try to request new data if the dialog is open and a stream is set .
public list < statement > munged style ( ) { list < statement > st = built ( ) ; if ( include basic entity for subject ) { st . remove ( entity data about decl ) ; st . remove ( entity data version decl ) ; st . remove ( entity data date modified decl ) ; statement ( st , uris . entity ( ) + entity , schema dot org . version , version ) ; statement ( st , uris . entity ( ) + entity , schema dot org . date modified , date modified ) ; } st . remove ( statement type decl ) ; for ( extra info e : extra info ) { e . munge ( st ) ; } return st ; }	get the results in munged style .
private void write request ( final next filter next filter , final socks proxy request request , int step ) { try { io buffer buf = null ; if ( step == socks proxy constants . sock greeting step ) { buf = encode initial greeting packet ( request ) ; } else if ( step == socks proxy constants . sock auth step ) { buf = encode authentication packet ( request ) ; if ( buf == null ) { step = socks proxy constants . sock request step ; } } if ( step == socks proxy constants . sock request step ) { buf = encode proxy request packet ( request ) ; } buf . flip ( ) ; write data ( next filter , buf ) ; } catch ( exception ex ) { close session ( str , ex ) ; } }	encodes a socks5 request and writes it to the next filter so it can be sent to the proxy server .
public synchronized void put as int ( object key , int value ) { put ( key , new integer ( value ) ) ; }	set attribute of selected key to selected value overridden method to allow notification of process var changes.
public void close ( ) throws io { if ( writer != null ) { writer . close ( ) ; } else { cb = null ; closed = bool ; } }	close the stream , flushing it first.
private cert path build cert path ( x509 certificate end cert ) throws certificate path building exception { cert path builder cpb = null ; try { cpb = cert path builder . get instance ( str ) ; } catch ( no such algorithm exception e ) { throw new certificate path building exception ( str + e . get message ( ) , e ) ; } pkix params = pkix ( end cert ) ; cert path builder result cpb result ; try { cpb result = cpb . build ( params ) ; } catch ( cert path builder exception e ) { throw new certificate path building exception ( e . get message ( ) , e . get cause ( ) ) ; } catch ( invalid algorithm parameter exception e ) { throw new certificate path building exception ( e . get message ( ) , e ) ; } cert path cp = cpb result . get cert path ( ) ; return cp ; }	build and validate cert path from end certificate.
public void add configuration ( input stream in ) throws sms , sso { service manager sm = new service manager ( token ) ; document doc = sms . get xml ( in ) ; node list nodes = doc . get elements by tag name ( sms . service ) ; for ( int i = num ; ( nodes != null ) && ( i < nodes . get length ( ) ) ; i ++ ) { node service node = nodes . item ( i ) ; string s name = xml . get node attribute value ( service node , sms . name ) ; string s version = xml . get node attribute value ( service node , sms . version ) ; node config node ; if ( s name . equals ( service name ) && ( s version . equals ( version ) ) && ( ( config node = xml . get child node ( service node , sms . configuration ) ) != null ) ) { create service config . create service ( sm , s name , s version , config node , null ) ; } } }	adds instances , global and organization configurations.
public static int string to dict id ( string str ) { try { byte [ ] bytes = str . get bytes ( str ) ; return bytes util . read unsigned ( bytes , num , bytes . length ) ; } catch ( unsupported encoding exception e ) { return num ; } }	the reverse of dictidtostring ( ) , returns integer id.
public void start ( ) throws io , mqtt exception { final string method name = str ; try { log . fine ( class name , method name , str , new object [ ] { host , new integer ( port ) , new long ( con timeout * num ) } ) ; socket address sockaddr = new inet socket address ( host , port ) ; socket = factory . create socket ( ) ; socket . connect ( sockaddr , con timeout * num ) ; } catch ( connect exception ex ) { log . fine ( class name , method name , str , null , ex ) ; throw new mqtt exception ( mqtt exception . reason code server connect error , ex ) ; } }	starts the module , by creating a tcp socket to the server .
public void call serially and wait ( runnable r ) { if ( is edt ( ) ) { throw new runtime exception ( str ) ; } runnable wrapper c = new runnable wrapper ( r , num ) ; call serially ( c ) ; flush edt ( ) ; synchronized ( lock ) { while ( ! c . is done ( ) ) { try { lock . wait ( num ) ; } catch ( interrupted exception err ) { } } } }	identical to callserially with the added benefit of waiting for the runnable method to complete .
public list < contact > find ( ) { list < long > ids = new array list < > ( ) ; if ( inner queries != null ) { for ( query query : inner queries ) { ids . add all ( query . find inner ( ) ) ; } } else { if ( mime where . is empty ( ) ) { return find ( null ) ; } for ( map . entry < string , where > entry : mime where . entry set ( ) ) { ids = find ids ( ids , entry . get key ( ) , entry . get value ( ) ) ; } } return find ( ids ) ; }	retrieves a list of contacts that satisfy this query .
public void persist bean data ( object bean , boolean print only ) { persist bean try catch ( bean ) ; call persist emitted key value ( print only ) ; }	this method make bean persist depending on annotations used .
private void refill ( ) throws io { offset += usable length ; int leftover = length - usable length ; system . arraycopy ( buffer , usable length , buffer , num , leftover ) ; int requested = buffer . length - leftover ; int returned = read ( input , buffer , leftover , requested ) ; length = returned < num ? leftover : returned + leftover ; if ( returned < requested ) usable length = length ; else { usable length = find safe end ( ) ; if ( usable length < num ) usable length = length ; } wrapper . set text ( buffer , num , math . max ( num , usable length ) ) ; iterator . set text ( wrapper ) ; }	refill the buffer , accumulating the offset and setting usablelength to the last unambiguous break position.
protected void fire insert update ( document event evt ) { if ( token marker != null ) { document event . element change ch = evt . get change ( get default root element ( ) ) ; if ( ch != null ) { token marker . insert lines ( ch . get index ( ) + num , ch . get children added ( ) . length - ch . get children removed ( ) . length ) ; } } super . fire insert update ( evt ) ; }	we overwrite this method to update the token marker state immediately so that any event listeners get a consistent token marker .
int pending ( ) { return pending . get ( ) ; }	number of pending operations.
private boolean is included ( final http servlet request request ) { string uri = ( string ) request . get attribute ( str ) ; boolean include request = ! ( uri == null ) ; if ( include request && log . is debug enabled ( ) ) { log . debug ( str + str , request . get request url ( ) ) ; } return include request ; }	checks if the request uri is an include.
public void draw domain marker ( d g2 , contour plot plot , value axis domain axis , marker marker , d data area ) { if ( marker instanceof value marker ) { value marker vm = ( value marker ) marker ; double value = vm . get value ( ) ; range range = domain axis . get range ( ) ; if ( ! range . contains ( value ) ) { return ; } double x = domain axis . value to java2 d ( value , data area , rectangle edge . bottom ) ; d line = new d . double ( x , data area . get min y ( ) , x , data area . get max y ( ) ) ; paint paint = marker . get outline paint ( ) ; stroke stroke = marker . get outline stroke ( ) ; g2 . set paint ( paint != null ? paint : plot . default outline paint ) ; g2 . set stroke ( stroke != null ? stroke : plot . default outline stroke ) ; g2 . draw ( line ) ; } }	draws a vertical line on the chart to represent a ' range marker ' .
public void remove ( string attr name , string del value ) { int index = index of ( attr name ) ; if ( index != - num ) { attr attr = ( attr ) attrs . get ( index ) ; attr . remove value ( del value ) ; if ( attr . size ( ) == num ) { attrs . remove ( index ) ; } } }	remove a specified value for an attribute in the set.
private applied migration create applied schema migration ( ) { return new applied migration ( num , num , migration version . from version ( integer . to string ( num ) ) , str , migration type . schema , str , null , new date ( ) , str , num , bool ) ; }	creates a new applied schema migration with this version .
public static string make sig alg ( string dig alg , string enc alg ) { dig alg = dig alg . replace ( str , str ) ; if ( enc alg . equals ignore case ( str ) ) enc alg = str ; return dig alg + str + enc alg ; }	creates a signature algorithm name from a digest algorithm name and a encryption algorithm name .
public static int index of ( byte [ ] src , byte [ ] target , int from idx ) { final int to = src . length - target . length + num ; for ( int i = from idx ; i < to ; i ++ ) { if ( src [ i ] == target [ num ] ) { boolean equals = bool ; for ( int j = num , k = i + num ; j < target . length && equals ; j ++ , k ++ ) { if ( src [ k ] != target [ j ] ) { equals = bool ; } } if ( equals ) { return i ; } } } return - num ; }	searches for target bytes in the source bytes .
@ override public int read ( byte [ ] buf , int offset , int length ) throws io { try { if ( channel == null ) { return - num ; } int remaining = read buffer . remaining ( ) ; if ( remaining > num ) { read buffer . get ( buf , offset , remaining ) ; return remaining ; } read buffer . clear ( ) ; int channel read = channel . read ( read buffer ) ; read buffer . flip ( ) ; if ( channel read < num ) return - num ; read buffer . get ( buf , offset , channel read ) ; return channel read ; } catch ( io e ) { if ( throw read interrupts ) throw e ; log . log ( level . finest , e . to string ( ) , e ) ; } catch ( io e ) { if ( throw read interrupts ) throw e ; log . log ( level . finer , e . to string ( ) , e ) ; } return - num ; }	reads bytes from the socket .
string read utf ( byte data [ ] , int off , int len ) { int offset = off ; string buffer buf = new string buffer ( ) ; for ( int end = offset + len ; offset < end ; ) { int ch = data [ offset ++ ] & num ; switch ( ch > > num ) { case num : case num : case num : case num : case num : case num : case num : case num : break ; case num : case num : if ( offset >= len ) { return null ; } ch = ( ( ch & num ) << num ) | ( data [ offset ++ ] & num ) ; break ; case num : if ( offset + num >= len ) { return null ; } ch = ( ( ch & num ) << num ) | ( ( data [ offset ++ ] & num ) << num ) | ( data [ offset ++ ] & num ) ; break ; default : if ( offset + num >= len ) { return null ; } ch = ( ( ch & num ) << num ) | ( data [ offset ++ ] & num ) ; break ; } buf . append ( ( char ) ch ) ; } return buf . to string ( ) ; }	read data bytes as a utf stream .
public turtle writer ( output stream out ) { this ( new output stream writer ( out , charset . for name ( str ) ) ) ; }	creates a new turtlewriter that will write to the supplied outputstream .
private char lookahead ( ) { return cur char index < pattern . length ( ) - num ? pattern . char at ( cur char index + num ) : eof ; }	returns the next character in the input pattern without advancing .
public static boolean is number ( string s ) { if ( s . length ( ) == num ) { return bool ; } for ( char c : s . to char array ( ) ) { if ( ! character . is digit ( c ) ) { return bool ; } } return bool ; }	check if this string is a decimal number .
private state ( circuit state circuit state , duration timeout duration , event counter counter ) { this . circuit state = circuit state ; this . counter = counter ; if ( timeout duration . is zero ( ) || timeout duration . is negative ( ) ) { timed out time nanos = num ; } else { timed out time nanos = ticker . read ( ) + timeout duration . to nanos ( ) ; } }	creates a new instance .
public void cleanup ( button group bg ) { if ( bg != null ) { bg . remove ( layer name ) ; } cleanup ( ) ; }	same as cleanup , except the layer name toggle button gets removed from the given button group .
public static map < meta key , string > union ( final map < meta key , string > provided meta data , final map < meta key , string > extracted meta data ) { final int size1 = provided meta data != null ? provided meta data . size ( ) : num ; final int size2 = extracted meta data != null ? extracted meta data . size ( ) : num ; if ( size1 + size2 == num ) { return collections . empty map ( ) ; } final map < meta key , string > result = new hash map < > ( size1 + size2 ) ; if ( extracted meta data != null ) { result . put all ( extracted meta data ) ; } if ( provided meta data != null ) { result . put all ( provided meta data ) ; } return collections . unmodifiable map ( result ) ; }	return an unmodifiable map of provided and extracted meta data.
public static void format double ( double source , int decimals , int precision , string buffer target ) { int scale = ( math . abs ( source ) >= num ) ? decimals : precision ; if ( too many digits used ( source , scale ) || too close to round ( source , scale ) ) { format double precise ( source , decimals , precision , target ) ; } else { format double fast ( source , decimals , precision , target ) ; } }	rounds the given source value at the given precision and writes the rounded value into the given target.
protected view create child ( string name ) { view view = null ; if ( name . equals ( tf parentid ) || name . equals ( tf client type ) ) { view = new cc ( this , name , str ) ; } else if ( name . equals ( sec mh common ) ) { view = new cc ( this , name ) ; } else if ( name . equals ( pgtitle ) ) { view = new cc ( this , pt model , name ) ; } else if ( pt model . is child supported ( name ) ) { view = pt model . create child ( this , name ) ; } else if ( name . equals ( property attribute ) ) { view = new am ( this , property sheet model , name ) ; } else if ( property sheet model . is child supported ( name ) ) { view = property sheet model . create child ( this , name , get model ( ) ) ; } else { view = super . create child ( name ) ; } return view ; }	creates user interface components used by this view bean .
public synchronized void draw ( final d gfx , final float x , final float y ) { if ( ! is empty ( ) ) { m text layout . draw ( gfx , x , y ) ; for ( final c highlighting : new array list < c > ( m highlighting ) ) { final double bp x = ( x + highlighting . get start ( ) ) - num ; final double bp y = ( y - m char height ) + num ; final double bp w = highlighting . get end ( ) + num ; final double bp h = m char height - num ; draw highlighting ( gfx , bp x , bp y , bp w , bp h , highlighting . get color ( ) ) ; } } }	draws the line onto a graphics context .
public boolean is abstract ( ) { return modifier . is abstract ( flags ) ; }	utility method to query the modifier flags of this member .
public static file relative file ( file f ) { if ( f . is absolute ( ) ) { f = relative file ( new file ( str ) , f ) ; } return f ; }	turns the given path , if absolute , into a path relative to the vm ' s current working directory and leaves it alone otherwise.
public xml ( final string namespace , final string [ ] schemas ) throws xml { try { jaxb jc = jaxb . new instance ( namespace ) ; marshaller = jc . create marshaller ( ) ; marshaller . set schema ( xml . create schema ( schemas ) ) ; unmarshaller = jc . create unmarshaller ( ) ; unmarshaller . set schema ( xml . create schema ( schemas ) ) ; } catch ( jaxb e ) { throw new xml ( str + namespace , e ) ; } }	creates the xmlparser with the namespace and schema files for validation .
public string [ ] split resource name ( string service type name , string resource name ) throws name not found exception , sso , policy exception { service type st = get service type ( service type name ) ; set prefixes = get managed resource names ( service type name ) ; string [ ] ret val = new string [ num ] ; if ( prefixes . is empty ( ) ) { ret val [ num ] = str ; ret val [ num ] = resource name ; return ret val ; } iterator iter = prefixes . iterator ( ) ; string tmp = null ; resource match match result = null ; boolean found super match = bool ; boolean found exact match = bool ; while ( iter . has next ( ) ) { tmp = ( string ) iter . next ( ) ; match result = st . compare ( resource name , tmp ) ; if ( match result . equals ( resource match . super resource match ) ) { found super match = bool ; break ; } if ( match result . equals ( resource match . exact match ) ) { found exact match = bool ; break ; } } if ( found super match ) { ret val [ num ] = tmp ; ret val [ num ] = st . get sub resource ( resource name , tmp ) ; return ret val ; } if ( found exact match ) { ret val [ num ] = tmp ; ret val [ num ] = str ; return ret val ; } ret val [ num ] = str ; ret val [ num ] = resource name ; return ret val ; }	returns the resource prefix ( super - resource ) and the rest of the resource name ( sub - resource ).
void materialize ( ) { if ( cachefill < num ) { return ; } double min = double . max value , max = double . min value ; for ( int i = num ; i < cachefill ; i ++ ) { min = math . min ( min , cachec [ i ] ) ; max = math . max ( max , cachec [ i ] ) ; } linear scale scale = new linear scale ( min , max ) ; min = scale . get min ( ) ; max = scale . get max ( ) ; this . base = min ; this . max = max ; this . binsize = ( max - min ) / this . destsize ; this . data = new long [ this . destsize << num ] ; size = destsize ; final int end = cachefill ; cachefill = - num ; for ( int i = num ; i < end ; i ++ ) { increment ( cachec [ i ] , cachev [ i ] ) ; } cachec = null ; cachev = null ; }	materialize the histogram from the cache .
public array field vector ( field < t > field , t [ ] v1 , t [ ] v2 ) throws math illegal argument exception , null argument exception { math utils . check not null ( v1 ) ; math utils . check not null ( v2 ) ; if ( v1 . length + v2 . length == num ) { throw new math illegal argument exception ( localized core formats . vector must have at least one element ) ; } data = math arrays . build array ( field , v1 . length + v2 . length ) ; system . arraycopy ( v1 , num , data , num , v1 . length ) ; system . arraycopy ( v2 , num , data , v1 . length , v2 . length ) ; this . field = field ; }	construct a vector by appending one vector to another vector .
private void verify target session is local or stateless ( session request req , id sid ) throws session exception , session request exception , forward session request exception { if ( stateless session manager . contains jwt ( sid ) ) { return ; } string host server id = foreign session handler . get current host server ( sid ) ; if ( ! server config . is local server ( host server id ) ) { try { throw new forward session request exception ( forward ( session service url service . get session service url ( host server id ) , req ) ) ; } catch ( session exception se ) { if ( ! session service . check server up ( host server id ) ) { string retry host server id = foreign session handler . get current host server ( sid ) ; if ( retry host server id . equals ( host server id ) ) { throw se ; } else { if ( ! server config . is local server ( retry host server id ) ) { throw new forward session request exception ( forward ( session service url service . get session service url ( host server id ) , req ) ) ; } } } else { throw se ; } } } if ( ! session service . check session local ( sid ) ) { throw new session request exception ( sid , session bundle . get string ( str ) ) ; } }	verify that this server is the correct host for the session and the session can be found ( or recovered ) locally.
public static boolean is java builtin data type ( class clazz ) { if ( clazz == null ) { return bool ; } class clazz boxed = get boxed type ( clazz ) ; if ( is numeric ( clazz boxed ) ) { return bool ; } if ( is boolean ( clazz boxed ) ) { return bool ; } if ( clazz boxed . equals ( string . class ) ) { return bool ; } if ( ( clazz boxed . equals ( char . class ) ) || ( clazz boxed . equals ( character . class ) ) ) { return bool ; } if ( clazz boxed . equals ( void . class ) ) { return bool ; } return bool ; }	returns true if the class passed in is a java built - in data type ( primitive or wrapper ) including string and ' null ' .
protected boolean is control char ( char ch ) { return character . is iso ( ch ) && ! character . is whitespace ( ch ) ; }	determines if the character is a control character .
public void encode ( output stream out ) throws io { der output stream tmp = new der output stream ( ) ; if ( extension value == null ) { extension id = pkix . policy constraints id ; critical = bool ; encode this ( ) ; } super . encode ( tmp ) ; out . write ( tmp . to byte array ( ) ) ; }	write the extension to the deroutputstream .
< t > list < t > on find all ( class < t > model class , boolean is eager , long ... ids ) { list < t > data list ; if ( is affect all lines ( ids ) ) { data list = query ( model class , null , null , null , null , null , str , null , get foreign key associations ( model class . get name ( ) , is eager ) ) ; } else { data list = query ( model class , null , get where of ids with or ( ids ) , null , null , null , str , null , get foreign key associations ( model class . get name ( ) , is eager ) ) ; } return data list ; }	the open interface for other classes in crud package to query multiple records by an id array.
public boolean is cached ( string request url , int max width , int max height ) { return is cached ( request url , max width , max height , scale type . center inside ) ; }	checks if the item is available in the cache .
public style add style ( string nm , style parent ) { style context styles = ( style context ) get attribute context ( ) ; return styles . add style ( nm , parent ) ; }	adds a new style into the logical style hierarchy.
public static text with mnemonic parse text ( final string text with mnemonic ) { if ( text with mnemonic == null ) { throw new illegal argument exception ( str ) ; } int index = - num ; final string buffer plain text = new string buffer ( ) ; for ( int i = num ; i < text with mnemonic . length ( ) ; i ++ ) { char ch = text with mnemonic . char at ( i ) ; if ( ch == str ) { i ++ ; if ( i >= text with mnemonic . length ( ) ) { break ; } ch = text with mnemonic . char at ( i ) ; if ( ch != str ) { index = plain text . length ( ) ; } } plain text . append ( ch ) ; } return new text with mnemonic ( plain text . to string ( ) , index ) ; }	parses text that might contain mnemonic and returns structure which contains plain text and index of mnemonic char ( if any ).
public void check permissions ( namespace entity namespace entity , string ... requested iam role names ) { check permissions ( namespace entity , arrays . as list ( requested iam role names ) ) ; }	throws accessdeniedexception if the given namespace is not authorized to access any of the given iam role names.
private static annotated type mirror as outer super ( types types , annotated type factory atype factory , annotated type mirror type , annotated type mirror super type ) { if ( type . get kind ( ) == type kind . declared ) { annotated declared type dt = ( annotated declared type ) type ; annotated declared type enclosing type = dt ; type mirror super type mirror = types . erasure ( super type . get underlying type ( ) ) ; while ( enclosing type != null ) { type mirror enclosing type mirror = types . erasure ( enclosing type . get underlying type ( ) ) ; if ( types . is subtype ( enclosing type mirror , super type mirror ) ) { dt = enclosing type ; break ; } enclosing type = enclosing type . get enclosing type ( ) ; } if ( enclosing type == null ) { return super type ; } return as super ( atype factory , dt , super type ) ; } return as super ( atype factory , type , super type ) ; }	return the base type of type or any of its outer types that starts with the given type.
public void reload ( solr core core , solr index searcher searcher ) throws io { log . info ( str ) ; if ( dictionary == null && store dir != null ) { file input stream is = new file input stream ( new file ( store dir , factory . store file name ( ) ) ) ; try { if ( lookup . load ( is ) ) { return ; } } finally { io . close while handling exception ( is ) ; } log . debug ( str ) ; } build ( core , searcher ) ; }	reloads the underlying lucene suggester.
public static string as string ( string json path , map < string , object > json ) { return path as ( string . class , json path , json ) ; }	helper function for reading a string value from a json object tree .
@ override public server heartbeat server dyn ( string address , int port , boolean is ssl , string cluster id , string display name ) { objects . require non null ( address ) ; objects . require non null ( cluster id ) ; cluster heartbeat cluster = create cluster ( cluster id ) ; server heartbeat server = cluster . create server ( address , port , is ssl ) ; if ( display name != null ) { server . set display name ( display name ) ; } cluster . add dynamic server ( server ) ; return server ; }	create an external / configured server.
public void run test ( ) throws throwable { document doc ; node list gender list ; node gender node ; character data ent text ; entity reference ent reference ; node appended node ; doc = ( document ) load ( str , bool ) ; gender list = doc . get elements by tag name ( str ) ; gender node = gender list . item ( num ) ; ent reference = doc . create entity reference ( str ) ; assert not null ( str , ent reference ) ; appended node = gender node . append child ( ent reference ) ; ent text = ( character data ) ent reference . get first child ( ) ; assert not null ( str , ent text ) ; { boolean success = bool ; try { ent text . replace data ( num , num , str ) ; } catch ( dom ex ) { success = ( ex . code == dom . no modification allowed err ) ; } assert true ( str , success ) ; } }	runs the test case .
public void remove all ( ) { m parts . clear ( ) ; }	remove all of the parts .
public static boolean executable exists ( string executable ) { file direct file = new file ( executable ) ; if ( direct file . exists ( ) && direct file . can execute ( ) ) { return bool ; } for ( string path string : get system path ( ) ) { path path = paths . get ( path string ) ; if ( files . exists ( path . resolve ( executable ) ) && files . is executable ( path . resolve ( executable ) ) ) { return bool ; } } return bool ; }	check whether an executable exists , either at a specific path ( if a full path is given ) or on the path .
@ override public string to string ( ) { string builder buf = new string builder ( ) ; int i = num ; for ( pseudo op op : contents ) { buf . append ( string . format ( str , i ++ , op ) ) ; } return buf . to string ( ) ; }	format the p - code for this method.
private list < file > combine ( list < file > list a , list < file > list b ) { linked hash set < file > combined projects = sets . new linked hash set ( list a ) ; combined projects . add all ( list b ) ; return new array list < > ( combined projects ) ; }	combine lista and listb to a single list without duplicates .
public long generate new ping id ( ) { preference store prefs = get preference store ( ) ; random rnd = new random ( ) ; long id = rnd . next long ( ) ; synchronized ( ddms preference store . class ) { prefs . set value ( ping id , id ) ; try { prefs . save ( ) ; } catch ( io e ) { } } return id ; }	generates a new random ping id and saves it in the preference store .
public boolean is valid ( ) { return system . current time millis ( ) < creation time + lifetime + ( lifetime / num ) ; }	return security token validity.
public static model read from ( virtual file file ) throws server exception , forbidden exception , io { require non null ( file , str ) ; return fetch model ( xml . from ( file . get content ( ) ) ) ; }	reads model from given virtual file .
public boolean is value exist for key ( string key ) { boolean is value exists ; try { string string = get string ( key , str ) ; is value exists = ! string . equals ignore case ( str ) ; } catch ( class cast exception e ) { try { int an int = get int ( key , num ) ; is value exists = an int != num ; } catch ( class cast exception e1 ) { try { long a long = get long ( key , num ) ; is value exists = a long != num ; } catch ( class cast exception e2 ) { try { float a float = get float ( key , num ) ; is value exists = a float != num ; } catch ( class cast exception e3 ) { try { boolean a boolean = get boolean ( key , bool ) ; is value exists = ! a boolean ; } catch ( exception e4 ) { is value exists = bool ; e . print stack trace ( ) ; } } } } } catch ( exception e ) { is value exists = bool ; } return is value exists ; }	check if value exists for key .
public void update viewport ( ) { set to ortho ( bool , virtual viewport . get width ( ) , virtual viewport . get height ( ) ) ; }	this must be called in applicationlistener.
public string to string ( ) { if ( key usages == null ) return str ; string usage = str ; boolean first = bool ; for ( object identifier oid : key usages ) { if ( ! first ) { usage += str ; } string result = map . get ( oid ) ; if ( result != null ) { usage += result ; } else { usage += oid . to string ( ) ; } first = bool ; } return super . to string ( ) + str + usage + str ; }	return the extension as user readable string .
public static void write boxplot ( t < double [ ] > table , string file ) throws io { int max size = num ; t < double [ ] > it = table . iterator ( ) ; for ( int i = num ; i < table . size ( ) ; i ++ ) { it . advance ( ) ; max size = math . max ( max size , it . value ( ) . length ) ; } double keys [ ] = table . keys ( ) ; arrays . sort ( keys ) ; buffered writer writer = new buffered writer ( new file writer ( file ) ) ; for ( int k = num ; k < keys . length ; k ++ ) { writer . write ( string . value of ( keys [ k ] ) ) ; if ( k + num < keys . length ) writer . write ( tab ) ; } writer . new line ( ) ; for ( int i = num ; i < max size ; i ++ ) { for ( int k = num ; k < keys . length ; k ++ ) { double [ ] list = table . get ( keys [ k ] ) ; if ( i < list . length ) { writer . write ( string . value of ( list [ i ] ) ) ; } else { writer . write ( na ) ; } if ( k + num < keys . length ) writer . write ( tab ) ; } writer . new line ( ) ; } writer . close ( ) ; }	writes a table with one column for each map entry.
public void test clear bit negative inside3 ( ) { string as = str ; int number = num ; big integer a number = new big integer ( as ) ; big integer result = a number . clear bit ( number ) ; assert equals ( as , result . to string ( ) ) ; }	clearbit ( 2 ) in the negative number with all ones in bit representation.
@ theory public void log entries have same order as indexes ( object [ ] data point ) { int index1 = ( int ) data point [ num ] ; int index2 = ( int ) data point [ num ] ; log entry first = log entries [ index1 ] ; log entry second = log entries [ index2 ] ; log . debug ( str , index1 , index2 ) ; int result = tested . compare ( first , second ) ; int expected = integer . compare ( index1 , index2 ) ; assert that have same signum ( expected , result ) ; }	the assumption here is that log entries in array were created in ascending order .
public static void copy all ( file root , file dest ) throws io { if ( root . is directory ( ) ) { for ( file child : root . list files ( ) ) { file child dest = new file ( dest , child . get name ( ) ) ; if ( child . is directory ( ) ) { if ( ! child dest . exists ( ) && ! mkdirs ( child dest ) ) throw new io ( str + child dest . get path ( ) ) ; copy all ( child , child dest ) ; } else { files . copy ( child . to path ( ) , child dest . to path ( ) , standard copy option . copy attributes ) ; } } } else { file child dest = new file ( dest , root . get name ( ) ) ; if ( ! dest . exists ( ) && ! mkdirs ( dest ) ) throw new io ( str + dest . get path ( ) ) ; files . copy ( root . to path ( ) , child dest . to path ( ) , standard copy option . copy attributes ) ; } }	recursively copy every file / folder from root to dest.
public void paint line ( d pt1 , d pt2 ) { if ( pt1 != null && pt2 != null ) { om c line = new om ( pt1 . get y ( ) , pt1 . get x ( ) , pt2 . get y ( ) , pt2 . get x ( ) , om . linetype greatcircle ) ; projection proj = the map . get projection ( ) ; c line . generate ( proj ) ; distance list . add ( c line ) ; } }	draw a rubberband line between two points.
public static boolean has export mask for storage and v ( db client db client , export group export group , uri storage uri ) { set < string > storage port ur v = export mask utils . get storage port uris associated with varray and storage array ( storage uri , export group . get virtual array ( ) , db client ) ; string set mask uri set = export group . get export masks ( ) ; if ( mask uri set != null ) { for ( string mask uri string : mask uri set ) { export mask mask = db client . query object ( export mask . class , uri . create ( mask uri string ) ) ; uri mask storage uri = mask . get storage device ( ) ; if ( mask storage uri . equals ( storage uri ) ) { for ( string storage port : mask . get storage ports ( ) ) { if ( storage port ur v . contains ( storage port ) ) return bool ; } } } } return bool ; }	for a given export group and storage system , this will check wheather there are any export mask exists in storage system which matches export group and storage ports in varray.
private void preload ( int first , boolean increasing ) { final int start ; final int end ; if ( increasing ) { start = math . max ( first , m last end ) ; end = math . min ( first + m load ahead items , m item source . get count ( ) ) ; } else { start = math . max ( num , first - m load ahead items ) ; end = math . min ( first , m last start ) ; } log . v ( tag , str + first + str + increasing + str + start + str + end ) ; m last end = end ; m last start = start ; if ( start == num && end == num ) { return ; } final list < t > items = m item source . get items in range ( start , end ) ; if ( ! increasing ) { collections . reverse ( items ) ; } register load tokens ( m item loader . preload items ( items ) ) ; }	initiates a pre load .
private void init rmi ( ) throws exception { if ( rmi host master == null || rmi port master == null ) { file conf dir = replicator runtime conf . locate replicator conf dir ( ) ; file props file = new file ( conf dir , replication service manager . config services ) ; println ( string . format ( str , props file ) ) ; tungsten properties service props = properties manager . load properties ( props file ) ; if ( rmi port master == null ) rmi port master = service props . get string ( replicator conf . rmi port , replicator conf . rmi default port , bool ) ; if ( rmi host master == null ) rmi host master = replication service manager . get host name ( service props ) ; } }	tries to load services.
public string encode key ( final string key ) { if ( string utils . is empty ( key ) ) { throw new illegal argument exception ( str ) ; } try { return hex . encode hex string ( key . get bytes ( str ) ) ; } catch ( unsupported encoding exception uee ) { throw new illegal state exception ( uee ) ; } }	encode the given key to hexadecimal .
private static void global union test ( final i schema version ) throws io { final writer output = open output ( schema version , str , test type . union ) ; final hll hll = new hll ( hll . empty ) ; final hll empty hll = new hll ( hll . empty ) ; cumulative union line ( output , hll , empty hll , schema version ) ; for ( int i = num ; i < num ; i ++ ) { final hll random hll = generate random hll ( ) ; cumulative union line ( output , hll , random hll , schema version ) ; } output . flush ( ) ; output . close ( ) ; }	unions an empty accumulator with random hlls . format : cumulative union tests : - hopefully all union possibilities.
public static boolean restore ( ) { file restore config = new file ( restoration properties ) ; if ( restore config . exists ( ) && restore config . is file ( ) ) { logger . info ( str ) ; try ( file input stream stream = new file input stream ( restore config ) ) { properties properties = new properties ( ) ; properties . load ( stream ) ; restore database ( properties ) ; restore solr index ( properties ) ; } catch ( unsupported operation exception e ) { logger . error ( str , e ) ; system . set property ( str , str ) ; } catch ( exception e ) { logger . fatal ( str , e ) ; return bool ; } finally { restore config . delete ( ) ; } } return bool ; }	restores dhus in a previous state .
public void test set bit positive inside4 ( ) { byte a bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = num ; int number = num ; byte r bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . set bit ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	setbit ( int n ) inside a positive number.
@ override public void write comment ( string data ) throws xml { log . log ( level . fine , str , data ) ; }	writes an xml comment with the data enclosed.
public static file from data uri ( string data uri , string file name ) { return file . create if supported ( from data uri ( data uri ) , file name ) ; }	create a new file from the datauri string.
protected list extract discovery information ( xrds xrds , xri identifier identifier , resolver xri resolver ) throws discovery exception { array list endpoints = new array list ( ) ; xrd xrd = xrds . get final xrd ( ) ; extract discovery information open id ( xri resolver , endpoints , xrd , identifier , discovery information . openi op , bool ) ; extract discovery information open id ( xri resolver , endpoints , xrd , identifier , discovery information . openi , bool ) ; extract discovery information open id ( xri resolver , endpoints , xrd , identifier , discovery information . openi , bool ) ; extract discovery information open id ( xri resolver , endpoints , xrd , identifier , discovery information . openi , bool ) ; if ( endpoints . size ( ) == num ) log . info ( str ) ; return endpoints ; }	extracts openid discovery endpoints from a xrds discovery result for xri identifiers .
public static void clear recent files ( ) { string str = program properties . get ( recentfiles , str ) ; if ( str . length ( ) != num ) { program properties . put ( recentfiles , str ) ; notify list change ( recentfiles ) ; } }	clears the list of recent files.
public static boolean are equivalent ( final type reference a , final type reference b ) { return are equivalent ( a , b , bool ) ; }	returns whether two type references refer to the same type.
private static char v ( jni env , int class jref , int method id , address arg address ) throws exception { if ( trace jni ) vm . sys write ( str ) ; runtime entrypoints . check jni gc ( ) ; try { object return obj = jni . invoke with var arg ( method id , arg address , type reference . char ) ; return reflection . unwrap char ( return obj ) ; } catch ( throwable unexpected ) { if ( trace jni ) unexpected . print stack trace ( system . err ) ; env . record exception ( unexpected ) ; return num ; } }	callstaticcharmethodv : invoke a static method that returns a char value.
private boolean init x ( final string prop name ) { if ( ! loaded x && ( prop name . starts with ( str ) || prop name . equals ( sun toolkit . desktopfonthints ) || prop name . starts with ( dnd prefix ) ) ) { loaded x = bool ; if ( ! graphics environment . is headless ( ) ) { load x ( ) ; if ( desktop properties . get ( sun toolkit . desktopfonthints ) == null ) { if ( xwm . is kd ( ) ) { object hint = fc manager . get font config aa ( ) ; if ( hint != null ) { desktop properties . put ( unix . fontconfigaahint , hint ) ; } } desktop properties . put ( sun toolkit . desktopfonthints , sun toolkit . get desktop font hints ( ) ) ; } return bool ; } } return bool ; }	initializes xawtxsettings if a property for a given property name is provided by xsettings and they are not initialized yet .
private void update sorting icons ( ) { for ( sorting type type : sorting type . values ( ) ) { sorting direction direction = model . get sorting direction ( type ) ; image icon icon ; switch ( direction ) { case descending : icon = icon arrow down ; break ; case ascending : icon = icon arrow up ; break ; case undefined : icon = null ; break ; default : icon = null ; } switch ( type ) { case name : sorting label att name . set icon ( icon ) ; break ; case type : sorting label att type . set icon ( icon ) ; break ; case missing : sorting label att missings . set icon ( icon ) ; break ; default : sorting label att name . set icon ( null ) ; sorting label att type . set icon ( null ) ; sorting label att missings . set icon ( null ) ; } } }	updates the sorting icons .
private void restore icon ( key key , byte [ ] buffer , int data size ) throws io { if ( verbose ) log . v ( tag , str + key . id ) ; if ( debug ) log . d ( tag , str + buffer . length + str + base64 . encode to string ( buffer , num , data size , base64 . no wrap ) ) ; resource res = unpack proto ( new resource ( ) , buffer , data size ) ; if ( debug ) { log . d ( tag , str + res . dpi + str ) ; } bitmap icon = bitmap factory . decode byte array ( res . data , num , res . data . length ) ; if ( icon == null ) { log . w ( tag , str + key . name ) ; } if ( verbose ) log . v ( tag , str + key . name ) ; icon cache . preload icon ( m context , component name . unflatten from string ( key . name ) , icon , res . dpi ) ; }	read an icon from the stream.
public boolean is expired ( ) { return payment details . has expires ( ) && system . current time millis ( ) / num > payment details . get expires ( ) ; }	this should always be called before attempting to call sendpayment .
public static void read bytes ( input stream is , byte [ ] b , int offset , int len ) { if ( len == num ) return ; try { int read = num ; while ( read < len ) { int n = is . read ( b , offset + read , len - read ) ; if ( n < num ) throw new pngj input exception ( str + n + str + len ) ; read += n ; } } catch ( io e ) { throw new pngj input exception ( str , e ) ; } }	guaranteed to read exactly len bytes . throws error if it can ' t.
public character match ( char [ ] chars ) { assert . is not null ( chars ) ; assert . is true ( chars . length > num ) ; f chars = chars ; arrays . sort ( chars ) ; }	creates a new instance .
public void add action listener ( action listener new a ) { m . add ( new a ) ; }	add a listener interested in kowing about editor status changes.
public boolean remove container and cancel if necessary ( image container container ) { m containers . remove ( container ) ; if ( m containers . size ( ) == num ) { m request . cancel ( ) ; return bool ; } return bool ; }	detatches the bitmap container from the request and cancels the request if no one is left listening .
public static byte [ ] encode ( byte [ ] data , int off , int length ) { byte array output stream b out = new byte array output stream ( ) ; try { encoder . encode ( data , off , length , b out ) ; } catch ( exception e ) { throw new encoder exception ( str + e . get message ( ) , e ) ; } return b out . to byte array ( ) ; }	encode the input data producing a hex encoded byte array .
@ not null public list < player nbt > create multiplayer player nbts ( ) { list < player nbt > result = new array list < player nbt > ( ) ; for ( file playerdata file : get playerdata files ( ) ) { if ( playerdata file . is file ( ) ) { result . add ( create playerdata player nbt ( get player uuid ( playerdata file ) ) ) ; } } if ( ! result . is empty ( ) ) { log . i ( str ) ; return result ; } for ( file players file : get players files ( ) ) { if ( players file . is file ( ) ) { result . add ( create players player nbt ( get player name from players file ( players file ) ) ) ; } } if ( ! result . is empty ( ) ) { log . i ( str ) ; return result ; } log . i ( str ) ; return result ; }	since version 1 . 7 . 6 , minecraft stores players in the playerdata directory and uses the player uuid as filename .
private void show ( setup window window ) { window . handle window opening event ( ) ; setup window holder . show ( window . get key ( ) ) ; current window = window ; }	show the specified window.
private static string replace stars ( string init ) { string builder builder = new string builder ( ) ; char [ ] chars = init . to char array ( ) ; for ( int i = num ; i < chars . length ; i ++ ) { if ( chars [ i ] == str && i == num && chars . length > num && chars [ i + num ] == str ) { builder . append ( str ) ; i ++ ; } else if ( chars [ i ] == str && i < ( chars . length - num ) && i > num && chars [ i + num ] == str && chars [ i - num ] == str ) { builder . delete char at ( builder . length ( ) - num ) ; builder . append ( str ) ; } else if ( chars [ i ] == str && i == ( chars . length - num ) && i > num && chars [ i - num ] == str ) { builder . delete char at ( builder . length ( ) - num ) ; builder . append ( str ) ; } else if ( chars [ i ] == str ) { builder . append ( str ) ; } else { builder . append ( chars [ i ] ) ; } } return builder . to string ( ) ; }	replaces the * characters in the string by a proper regular expression.
public void start option group ( string description ) { option groups . put ( option list . size ( ) , description ) ; }	start a new group of related command - line options .
public final void expect at least one result ( result set rs ) throws ade internal exception , sql { if ( ! rs . next ( ) ) { throw new ade internal exception ( str + m sql ) ; } }	verifies given result set contains at least one row.
public sequence ( ) { this ( initial value ) ; }	create a sequence initialised to - 1 .
public static optional < mongo credential > create credentials ( string username , string password , string database ) { if ( ! strings . is null or empty ( username ) && ! strings . is null or empty ( password ) && ! strings . is null or empty ( database ) ) { return optional . of ( mongo credential . create mongo cr ( username , database , password . to char array ( ) ) ) ; } else { return optional . absent ( ) ; } }	creates a mongocredential if a username , password and database are supplied , or returns absent ( ) otherwise.
@ override public void stop ( ) { if ( executor service != null ) { executor service . shutdown ( ) ; } rest template = null ; }	stops communication with and closes all connections to the remote http server ( service ) .
public result record ( directory scanner config scan , action [ ] actions , file f ) { directory scanner = scan . get name ( ) ; this . actions = actions ; date = new date ( ) ; filename = f . get absolute path ( ) ; }	creates a new instance of resultrecord .
private method doc find impl method ( method doc interface method ) { string name = interface method . name ( ) ; string desc = util . method descriptor of ( interface method ) ; for ( method doc impl method : impl class . methods ( ) ) { if ( name . equals ( impl method . name ( ) ) && desc . equals ( util . method descriptor of ( impl method ) ) ) { return impl method ; } } return null ; }	returns the methoddoc for the method of this remote implementation class that implements the specified remote method of a remote interface.
protected static list < string > extract boot class path ( final list < string > args ) { return extract opt with pattern ( boot class path regex , bool , args ) ; }	remove all - xbootclasspath / p : or - j - xbootclasspath / p : arguments from args and add them to the returned list.
public abstract object from open value ( object open value ) throws invalid object exception ;	< p > convert an instance of the open type into the java type .
public contour path ( contour attrib attr , int level index , double [ ] x , double [ ] y ) { x arr = x ; y arr = y ; this . level index = level index ; attributes = attr ; int np = x arr . length ; if ( math . abs ( x [ num ] - x [ np - num ] ) < k small x && math . abs ( y [ num ] - y [ np - num ] ) < k small y ) { closed = bool ; x [ np - num ] = x [ num ] ; y [ np - num ] = y [ num ] ; } else closed = bool ; }	construct a contour path or line using the given arrays of x & y values .
protected void print ( string mnemonic , string [ ] args ) { printer . print ( indent + str ) ; write padded string ( mnemonic + str , num ) ; if ( args != null ) { for ( int i = num ; i < args . length ; i ++ ) { if ( i > num ) { printer . print ( str ) ; } printer . print ( args [ i ] ) ; } } printer . println ( ) ; }	description of the method.
@ override public void remove connection event listener ( connection event listener listener ) { debug code ( str ) ; listeners . remove ( listener ) ; }	remove the event listener .
public boolean is downloadable ( ) { list < string > topics = get exact topics ( ) ; for ( string xt : topics ) if ( xt . starts with ( str ) ) return bool ; if ( get default ur ( ) . length > num ) { return bool ; } return bool ; }	returns true if there are enough pieces of information to start a download from it.
public boolean is satisfied by ( date date ) { calendar test date cal = calendar . get instance ( get time zone ( ) ) ; test date cal . set time ( date ) ; test date cal . set ( calendar . millisecond , num ) ; date original date = test date cal . get time ( ) ; test date cal . add ( calendar . second , - num ) ; date time after = get time after ( test date cal . get time ( ) ) ; return ( ( time after != null ) && ( time after . equals ( original date ) ) ) ; }	indicates whether the given date satisfies the cron expression.
public static vector < string > scan for dir logs ( final string current path ) { if ( cfg . debug ) { check . requires ( current path != null , str ) ; } file fc ; final vector < string > vector = new vector < string > ( ) ; try { fc = new file ( current path ) ; if ( fc . is directory ( ) ) { final string [ ] file logs = fc . list ( ) ; for ( final string dir : file logs ) { final file fdir = new file ( current path + dir ) ; if ( fdir . is directory ( ) ) { vector . add element ( dir + str ) ; if ( cfg . debug ) { check . log ( tag + str + dir ) ; } } } } } catch ( final exception e ) { if ( cfg . exception ) { check . log ( e ) ; } if ( cfg . debug ) { check . log ( tag + str + e ) ; } } if ( cfg . debug ) { check . log ( tag + str + vector . size ( ) ) ; } return vector ; }	restituisce la lista ordinata dele dir secondo il nome .
private static array list < string > flatten rows ( cursor cursor , int limit ) { util . throw if not ( limit >= num ) ; array list < string > flat list = new array list < > ( ) ; final int num columns = cursor . get column count ( ) ; for ( int row = num ; row < limit && cursor . move to next ( ) ; row ++ ) { for ( int column = num ; column < num columns ; column ++ ) { switch ( cursor . get type ( column ) ) { case cursor . field type null : flat list . add ( null ) ; break ; case cursor . field type integer : flat list . add ( string . value of ( cursor . get long ( column ) ) ) ; break ; case cursor . field type float : flat list . add ( string . value of ( cursor . get double ( column ) ) ) ; break ; case cursor . field type blob : flat list . add ( blob to string ( cursor . get blob ( column ) ) ) ; break ; case cursor . field type string : default : flat list . add ( cursor . get string ( column ) ) ; break ; } } } if ( ! cursor . is after last ( ) ) { for ( int column = num ; column < num columns ; column ++ ) { flat list . add ( str ) ; } } return flat list ; }	flatten all columns and all rows of a cursor to a single array.
public void collapse all parents ( ) { if ( m data list != null && ! m data list . is empty ( ) ) { array list < object > expandable list items = get parents ( bool ) ; if ( expandable list items != null && ! expandable list items . is empty ( ) ) { final int expanded item size = expandable list items . size ( ) ; if ( expanded item size > num ) { for ( int i = num ; i < expanded item size ; i ++ ) { object o = expandable list items . get ( i ) ; int index of = m data list . index of ( o ) ; if ( index of >= num ) collapse list item ( index of , ( base expandable observable ) o , bool ) ; } } } } }	collapses all parents in the list .
@ deprecated protected x draw push button appearance ( float width , float height , string text , pdf font font , int font size ) { return draw push button appearance ( width , height , text , font , ( float ) font size ) ; }	draws the appearance for a push button .
public nbt load file ( file save directory , string filename ) { return load file ( new file ( save directory , filename + str ) ) ; }	reads nbt data from the world folder .
public boolean dns domain is ( string host , string domain ) { return host . ends with ( domain ) ; }	tests if an url is in a given domain .
@ suppress warnings ( str ) public selection builder reset ( ) { m table = null ; if ( m projection map != null ) { m projection map . clear ( ) ; } if ( m selection != null ) { m selection . set length ( num ) ; } if ( m selection args != null ) { m selection args . clear ( ) ; } return this ; }	reset any internal state , allowing this builder to be recycled .
private final synchronized enumeration < policy entry > elements ( ) { return policy entries . elements ( ) ; }	enumerate all the entries in the global policy object.
public string format ( calendar calendar , calendar smsc calendar ) { if ( calendar == null || smsc calendar == null ) { return null ; } long diff time in millis = calendar . get time in millis ( ) - smsc calendar . get time in millis ( ) ; if ( diff time in millis < num ) { throw new illegal argument exception ( str ) ; } calendar offset epoch = calendar . get instance ( utc time zone ) ; offset epoch . set time in millis ( diff time in millis ) ; int years = offset epoch . get ( calendar . year ) - num ; int months = offset epoch . get ( calendar . month ) ; int days = offset epoch . get ( calendar . day of month ) - num ; int hours = offset epoch . get ( calendar . hour of day ) ; int minutes = offset epoch . get ( calendar . minute ) ; int seconds = offset epoch . get ( calendar . second ) ; if ( years >= num ) { throw new illegal argument exception ( str + years + str ) ; } return format ( years , months , days , hours , minutes , seconds ) ; }	return the relative time from the calendar datetime against the smsc datetime .
public void test bug20685022 ( ) throws exception { if ( ! is community edition ( ) ) { return ; } final properties props = new properties ( ) ; props . clear ( ) ; props . set property ( str , str ) ; props . set property ( str , str ) ; props . set property ( str , str ) ; get connection with props ( props ) ; props . clear ( ) ; props . set property ( str , str ) ; props . set property ( str , str ) ; props . set property ( str , str ) ; props . set property ( str , str ) ; props . set property ( str , str ) ; props . set property ( str , str ) ; get connection with props ( props ) ; props . clear ( ) ; props . set property ( str , str ) ; props . set property ( str , str ) ; props . set property ( str , str ) ; string trust store path = str ; system . set property ( str , trust store path ) ; system . set property ( str , str ) ; system . set property ( str , trust store path ) ; system . set property ( str , str ) ; get connection with props ( props ) ; }	tests fix for bug # 20685022 - ssl connection to mysql 5.
public static boolean can run ( final file file ) { return manager . get engine by extension ( file utils . get file extension ( file ) ) != null ; }	determines whether a file has the file extension of a valid script file .
public void parse element ( string tag name , map < string , object > attrs ) { if ( canvas == null && tag name . equals ignore case ( str ) ) { scale = mx utils . get double ( attrs , str , num ) ; canvas = create canvas ( attrs ) ; if ( canvas != null ) { canvas . set scale ( scale ) ; } } else if ( canvas != null ) { boolean draw label = bool ; if ( tag name . equals ignore case ( str ) || tag name . equals ignore case ( str ) ) { draw vertex ( attrs ) ; draw label = bool ; } else if ( tag name . equals ignore case ( str ) ) { draw edge ( attrs ) ; draw label = bool ; } if ( draw label ) { draw label ( tag name . equals ignore case ( str ) , attrs ) ; } } }	parses the given element and paints it onto the canvas .
private void start precaching ( ) { log . v ( tag , str ) ; prepare native libraries ( ) ; s is precaching = bool ; acquire precaching wake lock ( ) ; m precache launcher . start ( ) ; }	begin a precache cycle .
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public word alignment state ( final rule rule , final int start ) { trg points = new linked list < > ( ) ; src length = rule . get french ( ) . length ; num nt = rule . get arity ( ) ; src start = start ; final map < integer , list < integer > > alignment map = rule . get alignment map ( ) ; final int [ ] non terminal source positions = rule . get non terminal source positions ( ) ; final int [ ] trg = rule . get english ( ) ; for ( int trg index = num ; trg index < trg . length ; trg index ++ ) { final aligned source tokens trg point = new aligned source tokens ( ) ; if ( trg [ trg index ] >= num ) { if ( alignment map . contains key ( trg index ) ) { for ( int src idx : alignment map . get ( trg index ) ) { trg point . add ( src start + src idx ) ; } } else { trg point . set null ( ) ; } } else { trg point . set non terminal ( ) ; final int absolute non terminal source position = src start + non terminal source positions [ math . abs ( trg [ trg index ] ) - num ] ; trg point . add ( absolute non terminal source position ) ; } trg points . add ( trg point ) ; } }	construct alignmentstate object from a virgin rule and its source span . determines if state is complete ( if no nt present ).
protected void configure image reader loaders ( ) { image reader loaders = new vector < image reader loader > ( ) ; image reader loader idl = ( image reader loader ) component factory . create ( str ) ; if ( idl != null ) { image reader loaders . add ( idl ) ; } else { logger . warning ( str ) ; } idl = ( image reader loader ) component factory . create ( str ) ; if ( idl != null ) { image reader loaders . add ( idl ) ; } else { logger . warning ( str ) ; } }	internal callback method for subclasses to use to be able to configure imagereaderloader vector with specific imagereaderloaders.
protected void handle special substitution ( string replace , string replace with , int start pos , string description ) { if ( replace . equals ( str ) ) { if ( replace with . char at ( num ) == str ) { error ( str , start pos , description ) ; } ignore chars = char set . parse string ( replace with ) ; } }	this function defines a protocol for handling substitution names that are " special , " i.
@ override public void count example ( example example ) { double plabel ; double label = example . get value ( label attribute ) ; if ( ! predicted attribute . is nominal ( ) ) { plabel = example . get value ( predicted attribute ) ; } else { string label s = example . get value as string ( label attribute ) ; plabel = example . get confidence ( label s ) ; label = num ; } double weight = num ; if ( weight attribute != null ) { weight = example . get value ( weight attribute ) ; } double diff = weight * math . abs ( label - plabel ) ; deviation sum += diff ; double rel diff = math . abs ( weight * label - ( true label sum / example counter ) ) ; relative sum += rel diff ; }	calculates the error for the current example .
private void add decl annotations ( map < string , set < annotation mirror > > decl annos , element elt ) { if ( from stub file != null ) { set < annotation mirror > annos = decl annos . get ( element utils . get verbose name ( elt ) ) ; if ( annos == null ) { annos = annotation utils . create annotation set ( ) ; put or add to map ( decl annos , element utils . get verbose name ( elt ) , annos ) ; } annos . add ( from stub file ) ; } }	adds a declannotation to every method in the stub file .
private void inspect conditions with booleans ( linked list < psi element > obj branch conditions ) { for ( psi element obj expression : obj branch conditions ) { if ( ! ( obj expression instanceof constant reference ) ) { continue ; } if ( expression semantic util . is boolean ( ( constant reference ) obj expression ) ) { holder . register problem ( obj expression , str problem description booleans , problem highlight type . generic error or warning ) ; } } }	checks if any of conditions is boolean.
public static x x content type ( char sequence content ) { int length = content . length ( ) < guess header length ? content . length ( ) : guess header length ; if ( length == num ) { return null ; } char first = content . char at ( num ) ; if ( first == str ) { return x . json ; } if ( length > num && first == smile constants . header byte 1 && content . char at ( num ) == smile constants . header byte 2 && content . char at ( num ) == smile constants . header byte 3 ) { return x . smile ; } if ( length > num && first == str && content . char at ( num ) == str && content . char at ( num ) == str ) { return x . yaml ; } for ( int i = num ; i < length ; i ++ ) { char c = content . char at ( i ) ; if ( c == str ) { return x . json ; } if ( character . is whitespace ( c ) == bool ) { break ; } } return null ; }	guesses the content type based on the provided char sequence .
@ request mapping ( value = str , method = request method . delete ) public response entity < bookmark > delete bookmark ( @ path variable ( value = str ) string username , @ path variable ( value = str ) int bookmark id ) throws bookmark not found exception { optional < bookmark > optional = bookmarks repository . find by id and user username ( bookmark id , username ) ; if ( optional . is present ( ) ) { bookmarks repository . delete ( optional . get ( ) ) ; return new response entity < > ( optional . get ( ) , http status . ok ) ; } else { throw new bookmark not found exception ( str + bookmark id ) ; } }	a method to delete a bookmark identified by id .
public static object load instance ( class clazz , object default value ) { try { return clazz . new instance ( ) ; } catch ( throwable t ) { return default value ; } }	loads a class from a string classname.
public static string to json ( object value ) { final string writer writer = new string writer ( ) ; try { write json ( value , writer ) ; return writer . to string ( ) ; } catch ( io e ) { throw new runtime exception ( e ) ; } }	convert an object to json text.
public static final < a > x < a > to lazy collection ( final stream < a > stream ) { return seq utils . to lazy collection ( stream . iterator ( ) ) ; }	projects an immutable collection of this stream.
static unit value of ( string name , boolean horizontal ) { if ( name . length ( ) == num ) { unit default unit = sizes . get default unit ( ) ; if ( default unit != null ) { return default unit ; } return horizontal ? dialog units x : dialog units y ; } else if ( name . equals ( str ) ) { return pixel ; } else if ( name . equals ( str ) ) { return horizontal ? dialog units x : dialog units y ; } else if ( name . equals ( str ) ) { return point ; } else if ( name . equals ( str ) ) { return inch ; } else if ( name . equals ( str ) ) { return millimeter ; } else if ( name . equals ( str ) ) { return centimeter ; } else { throw new illegal argument exception ( str + name + str + str ) ; } }	returns a unit that corresponds to the specified string .
public void check number args ( int arg num ) throws wrong number args exception { if ( ( arg num < num ) || ( arg num > num ) ) report wrong number args ( ) ; }	overide the superclass method to allow one or two arguments .
