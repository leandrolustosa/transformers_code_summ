code	desc
public int hashcode ( ) { return value . hashcode ( ) ; }	this returns the hash code for the key.
public void onstart ( ) { }	fired when the request is started , override to handle in your own code.
@ override protected void propertychange ( propertychangeevent evt ) { if ( seaglasslookandfeel . shouldupdatestyle ( evt ) ) { updatestyle ( ( jtextcomponent ) evt . getsource ( ) ) ; } super . propertychange ( evt ) ; }	this method gets called when a bound property is changed on the associated jtextcomponent.
@ notnull public psiquery filter ( @ notnull final class < ? extends psinamedelement > clazz , @ notnull final string name ) { final set < psielement > result = new hashset < psielement > ( arrays . aslist ( mypsielements ) ) ; for ( final psielement element : mypsielements ) { final psinamedelement namedelement = pyutil . as ( element , clazz ) ; if ( ( namedelement == null ) || ( ! name . equals ( namedelement . getname ( ) ) ) ) { result . remove ( element ) ; } } return new psiquery ( result . toarray ( new psielement [ result . size ( ) ] ) ) ; }	filter elements by class and name.
protected void writequalifiedname ( string nsalias , string name ) throws ioexception { if ( nsalias != null && nsalias . length ( ) > _num ) { writer . write ( nsalias ) ; writer . write ( _str ) ; } writer . write ( name ) ; }	writes a namespace qualified element or attribute name .
public texteditor deleteall ( string pattern ) { return replaceall ( pattern , _str ) ; }	remove all occurrences of the given regex pattern , replacing them with the empty string .
public synchronized gcmhelper addregistrationcallback ( @ nonnull context context , @ nonnull gcmregistrationlistener registrationlistener , boolean sticky ) { if ( null == registrationcallbacks ) { registrationcallbacks = new concurrentlinkedqueue < > ( ) ; } registrationcallbacks . add ( registrationlistener ) ; if ( sticky && ! textutils . isempty ( this . pushtoken ) ) { registrationlistener . ontokenavailable ( context , pushtoken , _bool ) ; } return this ; }	add a gcm registration listener . this does not replace the existing listeners but adds to the list of listeners.
@ override public void accepttrainingset ( trainingsetevent e ) { instances trainingset = e . gettrainingset ( ) ; datasetevent dse = new datasetevent ( this , trainingset ) ; acceptdataset ( dse ) ; }	accept a training set.
< t > list < t > onfind ( class < t > modelclass , string [ ] columns , string [ ] conditions , string orderby , string limit , boolean iseager ) { baseutility . checkconditionscorrect ( conditions ) ; list < t > datalist = query ( modelclass , columns , getwhereclause ( conditions ) , getwhereargs ( conditions ) , null , null , orderby , limit , getforeignkeyassociations ( modelclass . getname ( ) , iseager ) ) ; return datalist ; }	the open interface for other classes in crud package to query multiple records by parameters .
public static byte [ ] calendartorawbytes ( calendar timestamp , boolean honordevicetimeoffset ) { if ( honordevicetimeoffset ) { int offsetinhours = mibandcoordinator . getdevicetimeoffsethours ( ) ; if ( offsetinhours != _num ) { timestamp . add ( calendar . hour_of_day , offsetinhours ) ; } } byte [ ] year = fromuint16 ( timestamp . get ( calendar . year ) ) ; return new byte [ ] { year [ _num ] , year [ _num ] , fromuint8 ( timestamp . get ( calendar . month ) + _num ) , fromuint8 ( timestamp . get ( calendar . date ) ) , fromuint8 ( timestamp . get ( calendar . hour_of_day ) ) , fromuint8 ( timestamp . get ( calendar . minute ) ) , fromuint8 ( timestamp . get ( calendar . second ) ) , dayofweektorawbytes ( timestamp ) , _num } ; }	converts a timestamp to the byte sequence to be sent to the current time characteristic.
protected void initbporderdetails ( int c_bpartner_id , boolean forinvoice ) { log . config ( _str + c_bpartner_id ) ; keynamepair pp = new keynamepair ( _num , _str ) ; orderfield . removeactionlistener ( this ) ; orderfield . removeallitems ( ) ; orderfield . additem ( pp ) ; arraylist < keynamepair > list = loadorderdata ( c_bpartner_id , forinvoice , samewarehousecb . isselected ( ) ) ; for ( keynamepair knp : list ) orderfield . additem ( knp ) ; orderfield . setselectedindex ( _num ) ; orderfield . addactionlistener ( this ) ; initbpdetails ( c_bpartner_id ) ; }	load pbartner dependent order / invoice / shipment field .
public modpackinitializationpanel ( wizardcontroller controller , map wizarddata , vector < string > versions , string selversion ) { initcomponents ( ) ; this . controller = controller ; this . wizarddata = wizarddata ; wizarddata . put ( key_game_version , versions ) ; wizarddata . put ( _str , selversion ) ; wizarddata . put ( key_including_launcher , _bool ) ; configurecombocontents ( ) ; checkproblem ( ) ; }	creates new form modpackinitializationpanel.
public synchronized void remove ( int index ) { super . remove ( index ) ; double removedvalue = mvalue . remove ( index ) ; if ( removedvalue == mminvalue || removedvalue == mmaxvalue ) { initrange ( ) ; } }	removes an existing value from the series .
private boolean coordiscalendarcell ( float y ) { return y > cellheight ; }	y is bigger than the head of the calendar , meaning that the coordination may represent a day of the calendar.
private int attributemap ( string name ) { integer num = map . get ( name ) ; if ( num == null ) { return _num ; } return num . intvalue ( ) ; }	returns the integer attribute number for the passed attribute name .
public string list ( ) throws ioexception , tomcatmanagerexception { return invoke ( _str , null , null ) ; }	list currently deployed webapps .
public attributefiller ( attributesimpl attributes , po potoautofill ) { attributes . clear ( ) ; atts = attributes ; po = potoautofill ; }	will clear attributes ! ! !.
@ requestmapping ( value = { _str , _str } , method = requestmethod . put ) @ responsebody public restwrapper insert ( @ modelattribute ( _str ) @ valid file file , bindingresult bindingresult , principal principal ) { restwrapper restwrapper = null ; if ( bindingresult . haserrors ( ) ) { bindingresulterror bindingresulterror = new bindingresulterror ( ) ; return bindingresulterror . errormessage ( bindingresult ) ; } try { file . setcreationts ( dateconverter . stringtodate ( file . gettablecreationts ( ) ) ) ; filedao . insert ( file ) ; restwrapper = new restwrapper ( file , restwrapper . ok ) ; logger . info ( _str + file . getbatchid ( ) + _str + principal . getname ( ) + file ) ; } catch ( metadataexception e ) { logger . error ( e ) ; restwrapper = new restwrapper ( e . getmessage ( ) , restwrapper . error ) ; } return restwrapper ; }	this method calls proc insertfile and adds a record of file.
private void enableupdates ( ) { if ( lmgr != null ) { try { lmgr . addgpsstatuslistener ( this ) ; lmgr . requestlocationupdates ( locationmanager . gps_provider , gpslogginginterval , _num , this ) ; } catch ( securityexception e ) { log . e ( tag , _str ) ; } } }	request gps update notification.
private void addinteger ( ) { int oldpos = pos - _num ; string literal = scaninteger ( ) ; final string substring ; final int radix ; if ( literal . startswith ( _str ) || literal . startswith ( _str ) ) { radix = _num ; substring = literal . substring ( _num ) ; } else if ( literal . startswith ( _str ) && literal . length ( ) > _num ) { radix = _num ; substring = literal . substring ( _num ) ; } else { radix = _num ; substring = literal ; } int value = _num ; try { value = integer . parseint ( substring , radix ) ; } catch ( numberformatexception e ) { error ( _str + radix + _str + literal ) ; } addtoken ( tokenkind . int , oldpos , pos , value ) ; }	scans an addinteger literal.
public void removemouselistener ( globalmouselistener listener ) { listeners . remove ( listener ) ; }	removes a global mouse listener.
public xmldocument ( double version , boolean standalone ) { prolog = new vector < object > ( _num ) ; stringbuffer versionstr = new stringbuffer ( ) ; versionstr . append ( _str ) ; versionstr . append ( version ) ; versionstr . append ( _str ) ; if ( standalone ) versionstr . append ( _str ) ; else versionstr . append ( _str ) ; this . versiondecl = versionstr . tostring ( ) ; }	this sets the document up . since an xml document can be pretty much anything , all this does is create the xml instruction with the version specified , and identifies the document as standalone if set.
public objectname createdistributionlocator ( string host , int port , string workingdirectory , string productdirectory , string remotecommand ) throws malformedobjectnameexception { try { distributionlocatorjmximpl locator = ( distributionlocatorjmximpl ) adddistributionlocator ( ) ; distributionlocatorconfig config = locator . getconfig ( ) ; config . sethost ( host ) ; config . setport ( port ) ; config . setworkingdirectory ( workingdirectory ) ; config . setproductdirectory ( productdirectory ) ; config . setremotecommand ( remotecommand ) ; return new objectname ( locator . getmbeanname ( ) ) ; } catch ( runtimeexception e ) { logger . warn ( e . getmessage ( ) , e ) ; throw e ; } catch ( virtualmachineerror err ) { systemfailure . initiatefailure ( err ) ; throw err ; } catch ( error e ) { systemfailure . checkfailure ( ) ; logger . error ( e . getmessage ( ) , e ) ; throw e ; } }	creates a new distributionlocator for this system and registers an mbean for managing it.
void applycenterpanel ( grassmarlin ui ) { if ( treeviewcomponent != null ) { centerpanelcomponent . add ( treeviewcomponent , splitpane . position . center ) ; } centerpanelcomponent . add ( graphcomponent , splitpane . position . right ) ; centerpanelcomponent . add ( logcomponent , splitpane . position . left_bottom ) ; border b = borderfactory . creatematteborder ( _num , _num , _num , _num , color . gray ) ; border b2 = borderfactory . creatematteborder ( _num , _num , _num , _num , color . gray ) ; treeviewcomponent . setborder ( b2 ) ; graphcomponent . setborder ( b ) ; logcomponent . setborder ( b2 ) ; centerpanelcomponent . setinitialsize ( x , y ) ; dimension d = new dimension ( _num , _num ) ; ui . add ( new filler ( d , d , d ) , borderlayout . west ) ; ui . add ( new filler ( d , d , d ) , borderlayout . east ) ; ui . add ( centerpanelcomponent , borderlayout . center ) ; }	positions the center two components into something that extends a jsplitpane.
private boolean isabstract ( string source ) { int nonterminalcount = _num ; for ( string t : source . split ( _str ) ) { if ( ! t . matches ( nt_regex ) ) return _bool ; nonterminalcount ++ ; } return nonterminalcount != _num ; }	determines whether a rule is an abstract rule.
public static string uriforportablepath ( string path ) { if ( path . startswith ( fileutil . preferences ) ) { return path . replacefirst ( fileutil . preferences , _str ) ; } else if ( path . startswith ( fileutil . program ) ) { return path . replacefirst ( fileutil . program , _str ) ; } else { return null ; } }	get the public uri for a portable path.
public int hashcode ( ) { return float . floattointbits ( value ) ; }	returns a hash code for this floatconstant object .
public static void log ( throwable error , string message , object ... args ) { if ( loggingenabled ) { log . d ( tag , args . length == _num ? message : string . format ( message , args ) , error ) ; } }	send a log message if logging is enabled .
public void addextensionnamespace ( string uri , extensionhandler extns ) { m_extensionfunctionnamespaces . put ( uri , extns ) ; }	register an extension namespace handler.
private void generatetypeparameterinfos ( binarymember parent , char [ ] signature , hashmap newelements , arraylist typeparameterhandles ) { if ( signature == null ) return ; char [ ] [ ] typeparametersignatures = signature . gettypeparameters ( signature ) ; for ( int i = _num , typeparametercount = typeparametersignatures . length ; i < typeparametercount ; i ++ ) { char [ ] typeparametersignature = typeparametersignatures [ i ] ; char [ ] typeparametername = signature . gettypevariable ( typeparametersignature ) ; charoperation . replace ( typeparametersignature , _str , _str ) ; char [ ] [ ] typeparameterboundsignatures = signature . gettypeparameterbounds ( typeparametersignature ) ; int boundlength = typeparameterboundsignatures . length ; char [ ] [ ] typeparameterbounds = new char [ boundlength ] [ ] ; for ( int j = _num ; j < boundlength ; j ++ ) { typeparameterbounds [ j ] = signature . tochararray ( typeparameterboundsignatures [ j ] ) ; } typeparameter typeparameter = new typeparameter ( parent , parent . manager , new string ( typeparametername ) ) ; typeparameterelementinfo info = new typeparameterelementinfo ( ) ; info . bounds = typeparameterbounds ; info . boundssignatures = typeparameterboundsignatures ; typeparameterhandles . add ( typeparameter ) ; while ( newelements . containskey ( typeparameter ) ) typeparameter . occurrencecount ++ ; newelements . put ( typeparameter , info ) ; } }	creates the handles and infos for the type parameter of the given binary member.
public routinginfo ( object o ) { this . text = o . tostring ( ) ; }	creates a routing info based on any object.
public static certchainkeypair generatesigned ( string fqdn , x509certificate issuercertificate , privatekey issuerprivatekey ) { try { return generatecertificateandsign ( fqdn , issuercertificate , issuerprivatekey , getserverextensions ( issuercertificate ) ) ; } catch ( certificateexception | operatorcreationexception | nosuchalgorithmexception | ioexception e ) { throw new runtimeexception ( string . format ( _str , e . getmessage ( ) ) , e ) ; } }	generates a signed certificate and a private key .
public void addrequest ( request request ) { requestset . add ( request ) ; }	adds a request object to this object .
public static double logpmf ( double x , int n , double p ) { if ( x < _num || x > n ) { return double . negative_infinity ; } if ( p <= _num ) { return x == _num ? _num : double . negative_infinity ; } if ( p >= _num ) { return x == n ? _num : double . negative_infinity ; } final double q = _num - p ; if ( x == _num ) { if ( p < _num ) { return - devianceterm ( n , n * q ) - n * p ; } else { return n * math . log ( q ) ; } } if ( x == n ) { if ( p > _num ) { return - devianceterm ( n , n * p ) - n * q ; } else { return n * math . log ( p ) ; } } final double lc = stirlingerror ( n ) - stirlingerror ( x ) - stirlingerror ( n - x ) - devianceterm ( x , n * p ) - devianceterm ( n - x , n * q ) ; final double f = ( mathutil . twopi * x * ( n - x ) ) / n ; return lc - _num * math . log ( f ) ; }	poisson probability mass function ( pmf ) for integer values .
private void byte2hex ( byte b , stringbuffer buf ) { char [ ] hexchars = { _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str } ; int high = ( ( b & _num ) > > _num ) ; int low = ( b & _num ) ; buf . append ( hexchars [ high ] ) ; buf . append ( hexchars [ low ] ) ; }	converts a byte to hex digit and writes to the supplied buffer.
protected void checksignature ( byte [ ] buf ) { if ( ! arrays . equals ( buf , pnghelperinternal . getpngidsignature ( ) ) ) throw new pngjinputexception ( _str ) ; }	throws pngjinputexception if bad signature.
private void twowaymergeinternal ( final reservoirlongssketch sketchin , final boolean ismodifiable ) { if ( sketchin . getn ( ) <= sketchin . getk ( ) ) { twowaymergeinternalstandard ( sketchin ) ; } else if ( gadget_ . getn ( ) < gadget_ . getk ( ) ) { final reservoirlongssketch tmpsketch = gadget_ ; gadget_ = ( ismodifiable ? sketchin : sketchin . copy ( ) ) ; twowaymergeinternalstandard ( tmpsketch ) ; } else if ( sketchin . getimplicitsampleweight ( ) < gadget_ . getn ( ) / ( ( double ) ( gadget_ . getk ( ) - _num ) ) ) { twowaymergeinternalweighted ( sketchin ) ; } else { final reservoirlongssketch tmpsketch = gadget_ ; gadget_ = ( ismodifiable ? sketchin : sketchin . copy ( ) ) ; twowaymergeinternalweighted ( tmpsketch ) ; } }	this either merges sketchin into gadget_ or gadget_ into sketchin.
final public void print ( object v ) { writer out = this . out ; if ( out == null ) return ; try { if ( v == null ) out . write ( _nullchars , _num , _nullchars . length ) ; else { string s = v . tostring ( ) ; out . write ( s , _num , s . length ( ) ) ; } } catch ( ioexception e ) { log . log ( level . fine , e . tostring ( ) , e ) ; } }	prints the value of the object .
public void subscribeto ( final k key , final subscriber < v > subscriber , final executor subscribeon ) { completablefuture . runasync ( null , subscribeon ) ; }	subscribe asynchronously to a pipe.
private void refreshbuffer ( ) throws ioexception { if ( output == null ) { throw new outofspaceexception ( ) ; } output . write ( buffer , _num , position ) ; position = _num ; }	internal helper that writes the current buffer to the output.
public string damagebaydoor ( ) { string baytype = _str ; vector < bay > potential ; potential = new vector < bay > ( ) ; enumeration < transporter > iter = transports . elements ( ) ; while ( iter . hasmoreelements ( ) ) { transporter next = iter . nextelement ( ) ; if ( next instanceof bay ) { bay nextbay = ( bay ) next ; if ( nextbay . getdoors ( ) > _num ) { potential . add ( nextbay ) ; } } } if ( potential . size ( ) > _num ) { bay chosenbay = potential . elementat ( compute . randomint ( potential . size ( ) ) ) ; chosenbay . destroydoor ( ) ; chosenbay . resetdoors ( ) ; chosenbay . setdoors ( chosenbay . getdoors ( ) - _num ) ; baytype = chosenbay . gettype ( ) ; } return baytype ; }	damages a randomly determined bay door on the entity , if one exists.
public void updateenabledstate ( ) { boolean b = ( getsimulationthread ( ) == null ) ; boolean prep = b && controller != null && controller . isprepared ( ) ; clearbutton . setenabled ( b ) ; preparebutton . setenabled ( b ) ; runbutton . setenabled ( prep ) ; if ( b ) pausebutton . setselected ( _bool ) ; pausebutton . setenabled ( ! b ) ; stepbutton . setenabled ( prep ) ; cancelbutton . setenabled ( ! b ) ; for ( jcombobox < object > combo : selectors . combos ) combo . setenabled ( b ) ; }	enables / disables combos and buttons .
private void preparevolumedata ( ) throws exception { preparevplexvolumedata ( ) ; preparerpvolumedata ( ) ; }	prepares the data for volume tests .
private static int determineiconidbymimetypelist ( list < string > mimetypes ) { if ( mimetypes == null || mimetypes . size ( ) < _num ) { return r . drawable . file ; } else { for ( string mimetype : mimetypes ) { integer iconid = mimetype_to_icon_mapping . get ( mimetype ) ; if ( iconid != null ) { return iconid ; } } for ( string mimetype : mimetypes ) { string mainmimetypepart = mimetype . split ( _str ) [ _num ] ; integer iconid = mainmimetype_to_icon_mapping . get ( mainmimetypepart ) ; if ( iconid != null ) { return iconid ; } } } return r . drawable . file ; }	determines the icon based on the mime type .
public smsmmsmessage ( context _context , long _messageid , long _threadid , long _timestamp , string _messagebody , int _unreadcount , int _messagetype ) { context = _context ; messageid = _messageid ; threadid = _threadid ; timestamp = _timestamp ; messagebody = _messagebody ; unreadcount = _unreadcount ; messagetype = _messagetype ; fromaddress = smspopuputils . getmmsaddress ( context , messageid ) ; fromemailgateway = _bool ; contactname = phonenumberutils . formatnumber ( fromaddress ) ; contactidentification contactidentify = smspopuputils . getpersonidfromphonenumber ( context , fromaddress ) ; if ( contactidentify == null ) { contactidentify = smspopuputils . getpersonidfromemail ( context , fromaddress ) ; if ( contactidentify != null ) { fromemailgateway = _bool ; } } if ( contactidentify != null ) { contactid = contactidentify . contactid ; contactlookupkey = contactidentify . contactlookup ; contactname = contactidentify . contactname ; } }	construct smsmmsmessage for getmmsdetails ( ) - fetched from the mms database table.
public void attributeasclass ( ) { datasortedtablemodel model ; if ( m_currentcol == - _num ) { return ; } model = ( datasortedtablemodel ) m_tabledata . getmodel ( ) ; if ( model . getattributeat ( m_currentcol ) == null ) { return ; } setcursor ( cursor . getpredefinedcursor ( cursor . wait_cursor ) ) ; model . attributeasclassat ( m_currentcol ) ; setcursor ( cursor . getpredefinedcursor ( cursor . default_cursor ) ) ; }	sets the current attribute as class attribute , i.
public void addlistener ( refreshlistener listener ) { if ( listener == null ) { throw new nullpointerexception ( _str ) ; } refreshlisteners . add ( listener ) ; }	adds a listener , to be notified when a reference is refreshed / swapped .
public final void doexport ( final string trackname , final file target , int verbosity ) throws ioexception { log . i ( tag , _str + target . getabsolutepath ( ) ) ; mdbhelper = new databasehelper ( mcontext . getapplicationcontext ( ) ) ; final bufferedwriter bw = new bufferedwriter ( new filewriter ( target ) ) ; bw . write ( xml_header ) ; bw . write ( tag_gpx ) ; if ( verbosity == verbosity_track_and_waypoints || verbosity == verbosity_waypoints_only || verbosity == verbosity_all ) { writewaypoints ( bw ) ; } if ( verbosity == verbosity_track_and_waypoints || verbosity == verbosity_all ) { writetrackpoints ( trackname , bw ) ; } bw . flush ( ) ; if ( verbosity == verbosity_all ) { writewifis ( bw ) ; bw . flush ( ) ; writecells ( bw ) ; bw . flush ( ) ; } bw . write ( tag_gpx_close ) ; bw . close ( ) ; mdbhelper . close ( ) ; log . i ( tag , _str ) ; }	writes the gpx file.
public list < v > valuesinselection ( richedittext editor , int spantype ) { list < v > result = new arraylist < v > ( ) ; selection expandedselection = getexpandedselection ( editor , spantype ) ; if ( expandedselection != null ) { for ( span < v > span : getspans ( editor . gettext ( ) , expandedselection ) ) { result . add ( span . getvalue ( ) ) ; } } return result ; }	returns the value of this effect in the current selection .
private boolean isgtedelta ( double value ) { return math . abs ( value ) - math . abs ( mdelta ) > - _num ; }	indicates if the absolute value of the argument is greater than or equal to the delta value with accuracy to 14 digits of precision.
public static string rowtostring ( jsonarray ja ) { stringbuilder sb = new stringbuilder ( ) ; for ( int i = _num ; i < ja . length ( ) ; i += _num ) { if ( i > _num ) { sb . append ( _str ) ; } object object = ja . opt ( i ) ; if ( object != null ) { string string = object . tostring ( ) ; if ( string . length ( ) > _num && ( string . indexof ( _str ) >= _num || string . indexof ( _str ) >= _num || string . indexof ( _str ) >= _num || string . indexof ( _num ) >= _num || string . charat ( _num ) == _str ) ) { sb . append ( _str ) ; int length = string . length ( ) ; for ( int j = _num ; j < length ; j += _num ) { char c = string . charat ( j ) ; if ( c >= _str && c != _str ) { sb . append ( c ) ; } } sb . append ( _str ) ; } else { sb . append ( string ) ; } } } sb . append ( _str ) ; return sb . tostring ( ) ; }	produce a comma delimited text row from a jsonarray.
@ override public boolean contains ( object object ) { if ( object == null ) { return _bool ; } for ( int i = _num ; i < size ; i ++ ) { if ( object . equals ( elements [ i ] ) ) { return _bool ; } } return _bool ; }	answers if there is an element in this queue equals to the object .
public void close ( ) throws ioexception { writer . close ( ) ; }	closes the xmlwriter and the underlying output writer .
public static void substituteproperties ( node node , properties properties ) { node child ; node next = node . getfirstchild ( ) ; while ( ( child = next ) != null ) { next = child . getnextsibling ( ) ; if ( child . getnodetype ( ) == node . text_node ) { child . setnodevalue ( propertiesutil . substituteproperty ( child . getnodevalue ( ) , properties ) ) ; } else if ( child . getnodetype ( ) == node . element_node ) { namednodemap attributes = child . getattributes ( ) ; for ( int i = _num ; i < attributes . getlength ( ) ; i ++ ) { node attribute = attributes . item ( i ) ; attribute . setnodevalue ( propertiesutil . substituteproperty ( attribute . getnodevalue ( ) , properties ) ) ; } substituteproperties ( child , properties ) ; } } }	replaces $ { property [ : default value ] } references in all attributes and text nodes of supplied node.
@ suppresswarnings ( _str ) public pseudofunctionselector ( string functionname , string expression ) { super ( type . pseudo_function ) ; this . pseudofunction = ( pseudofunction < e > ) lookuppseudofunction ( functionname . trim ( ) ) ; this . expression = expression ; this . parsedexpression = pseudofunction . parseexpression ( expression ) ; }	creates pseudo function selector for given function and expression .
public static string fixquerymistakes ( string q ) { q = q . replaceall ( _str , _str ) ; q = q . replaceall ( _str , _str ) ; return q ; }	fixing a query mistake covers most common wrong queries from the user.
public byte [ ] readbytes ( ) throws ioexception { if ( ! parsetag ( ) ) throw new burlapprotocolexception ( _str ) ; string tag = sbuf . tostring ( ) ; if ( tag . equals ( _str ) ) { expectendtag ( _str ) ; return null ; } else if ( tag . equals ( _str ) ) { sbuf . setlength ( _num ) ; byte [ ] value = parsebytes ( ) ; expectendtag ( _str ) ; return value ; } else throw expectbegintag ( _str , tag ) ; }	reads a byte array from the input stream.
public synchronized utterance pend ( ) { utterance utterance = null ; while ( list . size ( ) == _num ) { try { wait ( ) ; } catch ( interruptedexception ie ) { return null ; } } utterance = ( utterance ) list . removefirst ( ) ; notify ( ) ; return utterance ; }	blocks until there is an utterance in the queue .
public void testlongvaluepos ( ) { string a = _str ; bigdecimal anumber = new bigdecimal ( a ) ; long result = _num ; asserttrue ( _str , anumber . longvalue ( ) == result ) ; }	long value of a positive bigdecimal.
public static evaluationresult findorcreate ( resulthierarchy hierarchy , result parent , string name , string shortname ) { arraylist < evaluationresult > ers = resultutil . filterresults ( hierarchy , parent , evaluationresult . class ) ; evaluationresult ev = null ; for ( evaluationresult e : ers ) { if ( shortname . equals ( e . getshortname ( ) ) ) { ev = e ; break ; } } if ( ev == null ) { ev = new evaluationresult ( name , shortname ) ; hierarchy . add ( parent , ev ) ; } return ev ; }	find or create an evaluation result .
public static boolean isrunningjavawebstart ( ) { boolean hasjnlp = _bool ; try { class . forname ( _str ) ; hasjnlp = _bool ; } catch ( classnotfoundexception ex ) { hasjnlp = _bool ; } return hasjnlp ; }	are we running from a webstart instance ?.
public boolean isconnected ( ) { return connected . get ( ) ; }	returns the connection status .
private void tryscheduleaction ( runnable action ) { try { scheduler . submit ( action ) ; } catch ( rejectedexecutionexception e ) { } }	tries to schedule a runnable on the underlying executor.
private static double scoresequence ( list < latlong > pts ) { latlong prev = pts . get ( pts . size ( ) - _num ) ; latlong prevprev = pts . get ( pts . size ( ) - _num ) ; double prevangle = math . atan2 ( prev . lat - prevprev . lat , prev . lng - prevprev . lng ) ; double score = _num ; for ( latlong pt : pts ) { double angle = math . atan2 ( pt . lat - prev . lat , pt . lng - prev . lng ) ; double diff = prevangle - angle ; if ( diff > math . pi ) diff -= math . pi * _num ; else if ( diff < - math . pi ) diff += math . pi * _num ; if ( diff < _num ) score += _num ; else score += diff ; prev = pt ; prevangle = angle ; } return score ; }	how ' good ' does this sequence of points look ? the sequence must be clockwise and have the least acute angles possible .
public void addwebappdebugmodellistener ( iwebappdebugmodellistener listener ) { synchronized ( privateinstancelock ) { webappdebugmodellisteners . add ( listener ) ; } }	add a listener for changes to the model .
public void simulatemethod ( sootmethod method , referencevariable thisvar , referencevariable returnvar , referencevariable params [ ] ) { string subsignature = method . getsubsignature ( ) ; if ( subsignature . equals ( _str ) ) { java_lang_securitymanager_getclasscontext ( method , thisvar , returnvar , params ) ; return ; } else if ( subsignature . equals ( _str ) ) { java_lang_securitymanager_currentclassloader0 ( method , thisvar , returnvar , params ) ; return ; } else if ( subsignature . equals ( _str ) ) { java_lang_securitymanager_currentloadedclass0 ( method , thisvar , returnvar , params ) ; return ; } else { defaultmethod ( method , thisvar , returnvar , params ) ; return ; } }	implements the abstract method simulatemethod.
public static boolean isfileexists ( final string path ) { if ( textutils . isempty ( path ) ) { log . e ( fileutils . class , _str ) ; return _bool ; } final file filetocheck = new file ( path ) ; return filetocheck . exists ( ) && ! filetocheck . isdirectory ( ) ; }	check if given path is a file and if it exists.
private list < reference > createsignaturereferences ( xmlsignaturefactory xmlsigfactory , list < string > referenceidlist ) throws nosuchalgorithmexception , invalidalgorithmparameterexception { list < reference > result = new arraylist < reference > ( ) ; for ( string refid : referenceidlist ) { if ( refid == null ) { continue ; } reference ref = xmlsigfactory . newreference ( _str + refid , xmlsigfactory . newdigestmethod ( digestmethod . sha512 , null ) , collections . singletonlist ( xmlsigfactory . newcanonicalizationmethod ( canonicalizationmethod . exclusive , ( c14nmethodparameterspec ) null ) ) , null , null ) ; result . add ( ref ) ; } return collections . unmodifiablelist ( result ) ; }	creates all references needed for this signature.
public boolean removenetworkconnection ( networkconnection networkconnection ) { return networkconnections . remove ( networkconnection ) ; }	remove a networkconnection from a vm ' s networks .
@ override public enumeration < option > listoptions ( ) { vector < option > result = new vector < option > ( ) ; result . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str , _str , _num , _str ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
protected object convertarray ( object value ) { return value ; }	returns the value unchanged .
public static string encodestring ( string s ) { return new string ( encode ( s . getbytes ( ) ) ) ; }	encodes a string into base64 format.
gridlucenefile ( gridlucenedirectory dir ) { this . dir = dir ; filescnt . incrementandget ( ) ; }	file used as buffer , in no ramdirectory.
public void addattributes ( attributes atts ) throws saxexception { int natts = atts . getlength ( ) ; for ( int i = _num ; i < natts ; i ++ ) { string uri = atts . geturi ( i ) ; if ( null == uri ) uri = _str ; addattributealways ( uri , atts . getlocalname ( i ) , atts . getqname ( i ) , atts . gettype ( i ) , atts . getvalue ( i ) , _bool ) ; } }	add the given attributes to the currently collected ones.
public synchronized void addpanlistener ( panlistener listener ) { mpanlisteners . add ( listener ) ; }	adds a new pan listener .
public synchronized long lastonlineago ( ) { return ( system . currenttimemillis ( ) - lastonline ) / _num ; }	how long ago the stream was last online.
public double distance_weighted ( plapointfloat p_other , double p_horizontal_weight , double p_vertical_weight ) { double delta_x = v_x - p_other . v_x ; double delta_y = v_y - p_other . v_y ; delta_x *= p_horizontal_weight ; delta_y *= p_vertical_weight ; double result = math . sqrt ( delta_x * delta_x + delta_y * delta_y ) ; return result ; }	computes the weighted distance to p_other .
public namespace swap ( namespace newtop ) { namespace oldtop = ( namespace ) ( stack . elementat ( _num ) ) ; stack . setelementat ( newtop , _num ) ; return oldtop ; }	swap in the value as the new top of the stack and return the old value .
public static list < string > classespath ( ) throws filenotfoundexception , loadingfileexception { list < file > files = getjavafiles ( ) ; list < string > paths = new arraylist < string > ( ) ; for ( file file : files ) paths . add ( file . getpath ( ) ) ; return paths ; }	returns a list with the paths of all java classes .
public static deleteparticipant [ ] loaddeleteparticipants ( refactoringstatus status , refactoringprocessor processor , object element , deletearguments arguments , iparticipantdescriptorfilter filter , string [ ] affectednatures , sharableparticipants shared ) { refactoringparticipant [ ] participants = fgdeleteinstance . getparticipants ( status , processor , element , arguments , filter , affectednatures , shared ) ; deleteparticipant [ ] result = new deleteparticipant [ participants . length ] ; system . arraycopy ( participants , _num , result , _num , participants . length ) ; return result ; }	loads the delete participants for the given element .
public putresult ( string successcount , string failcount , list < string > errormessages ) { _successcount = successcount ; _failcount = failcount ; _errormessages = new arraylist < > ( ) ; if ( errormessages != null ) { _errormessages . addall ( errormessages ) ; } }	creates a new putresult object .
@ override public int hashcode ( ) { int myposition = position ; int hash = _num ; while ( myposition < limit ) { hash = hash + get ( myposition ++ ) ; } return hash ; }	calculates this buffer ' s hash code from the remaining chars.
public void print ( charsequence text ) throws ioexception { int size = text . length ( ) ; int pos = _num ; for ( int i = _num ; i < size ; i ++ ) { if ( text . charat ( i ) == _str ) { write ( text . subsequence ( pos , size ) , i - pos + _num ) ; pos = i + _num ; atstartofline = _bool ; } } write ( text . subsequence ( pos , size ) , size - pos ) ; }	print text to the output stream .
public void closerunningapp ( string deviceid , string app_package ) throws interruptedexception , ioexception { cmd . runcommand ( _str + deviceid + _str + app_package ) ; }	this method will close the running app.
@ androidonly ( _str ) public void test_unwrap_05 ( ) { string host = _str ; int port = _num ; bytebuffer [ ] bba = { bytebuffer . allocate ( _num ) , bytebuffer . allocate ( _num ) , bytebuffer . allocate ( _num ) } ; bytebuffer bb = bytebuffer . allocate ( _num ) ; sslengine sse = getengine ( host , port ) ; try { sse . unwrap ( bb , bba , _num , bba . length ) ; fail ( _str ) ; } catch ( illegalstateexception iobe ) { } catch ( exception e ) { fail ( e + _str ) ; } }	javax . net . ssl . sslengine # unwrap ( bytebuffer src , bytebuffer [ ] dsts , int offset , int length ) exception case : illegalstateexception should be thrown .
public boolean filteroutinvalidation ( t tag , tagqualitystatus statustoadd , string statusdescription , timestamp timestamp ) { return filterout ( tag , tag . getvalue ( ) , tag . getvaluedescription ( ) , statustoadd , statusdescription , timestamp ) ; }	as for general filterout method , but for invalidation only .
public void bindy ( doubleproperty yproperty ) { minyworld . bind ( yproperty . add ( getminy ( ) ) ) ; maxyworld . bind ( minyworld . add ( getheight ( ) ) ) ; }	bind to y property of entity .
private void copyfieldattributes ( ) { if ( ( loadfields == null ) || fields == null ) { return ; } for ( int i = _num ; i < loadfields . length ; i ++ ) { objectstreamfield loadfield = loadfields [ i ] ; string name = loadfield . getname ( ) ; for ( int j = _num ; j < fields . length ; j ++ ) { objectstreamfield field = fields [ j ] ; if ( name . equals ( field . getname ( ) ) ) { loadfield . setunshared ( field . isunshared ( ) ) ; loadfield . setoffset ( field . getoffset ( ) ) ; break ; } } } }	if a class uses " serialpersistentfields " to define the serialized fields , this.
public static uri . builder appendid ( uri . builder builder , long id ) { return builder . appendencodedpath ( string . valueof ( id ) ) ; }	appends the given id to the end of the path .
private static void beginstartingservice ( context context , intent intent ) { synchronized ( sstartingservicesync ) { if ( sstartingservice == null ) { powermanager pm = ( powermanager ) context . getsystemservice ( context . power_service ) ; sstartingservice = pm . newwakelock ( powermanager . partial_wake_lock , _str ) ; } sstartingservice . acquire ( ) ; if ( context . startservice ( intent ) == null ) { log . e ( tag , _str ) ; } } }	start the service to process the current event notifications , acquiring the wake lock before returning to ensure that the service will run .
public static double stddev ( double [ ] a ) { return math . sqrt ( var ( a ) ) ; }	returns the sample standard deviation in the specified array .
public simpleargumentsbundle ( @ nonnull map < string , string > arguments , @ nonnull displaymetrics metrics ) { marguments = arguments ; mmetrics = metrics ; }	create a new simple arguments bundle implementation from provided key - & gt ; value map .
public static string collapsewhitespace ( string str ) { return collapse ( str , white_spaces , _str ) ; }	replaces any string of adjacent whitespace characters with the whitespace character " " .
private void adjustasiandcollectfollowelements ( custominternaln4jsparser previousparser , boolean strict , set < followelement > result ) { observablextexttokenstream tokens = ( observablextexttokenstream ) previousparser . gettokenstream ( ) ; int lasttokenindex = tokens . size ( ) - _num ; if ( lasttokenindex >= _num ) { commontoken lasttoken = ( commontoken ) tokens . lt ( - _num ) ; @ suppresswarnings ( _str ) list < token > tokenlist = tokens . gettokens ( ) ; if ( lasttoken == null ) { return ; } if ( shouldskipasi ( lasttoken ) ) { if ( mayskipasi ( lasttoken , tokens ) ) { tokenlist . remove ( lasttokenindex ) ; result . addall ( resetandgetfollowelements ( tokens , strict ) ) ; removepostfixoperator ( result ) ; } } else if ( shouldaddsyntheticsemicolon ( previousparser , lasttokenindex , lasttoken ) ) { commontoken token = new commontoken ( semi ) ; tokenlist . add ( token ) ; result . addall ( resetandgetfollowelements ( tokens , strict ) ) ; removepostfixoperator ( result ) ; } } }	the second pass over the given input.
public linkedlist < patch > patch_make ( string text1 , string text2 ) { if ( text1 == null || text2 == null ) { throw new illegalargumentexception ( _str ) ; } linkedlist < diff > diffs = diff_main ( text1 , text2 , _bool ) ; if ( diffs . size ( ) > _num ) { diff_cleanupsemantic ( diffs ) ; diff_cleanupefficiency ( diffs ) ; } return patch_make ( text1 , diffs ) ; }	compute a list of patches to turn text1 into text2.
public void testbasicsv6 ( ) throws exception { directory dir = newdirectory ( ) ; randomindexwriter writer = new randomindexwriter ( random ( ) , dir ) ; document document = new document ( ) ; inetaddress address = inetaddress . getbyname ( _str ) ; document . add ( new inetaddresspoint ( _str , address ) ) ; writer . adddocument ( document ) ; indexreader reader = writer . getreader ( ) ; indexsearcher searcher = newsearcher ( reader ) ; assertequals ( _num , searcher . count ( inetaddresspoint . newexactquery ( _str , address ) ) ) ; assertequals ( _num , searcher . count ( inetaddresspoint . newprefixquery ( _str , address , _num ) ) ) ; assertequals ( _num , searcher . count ( inetaddresspoint . newrangequery ( _str , inetaddress . getbyname ( _str ) , inetaddress . getbyname ( _str ) ) ) ) ; reader . close ( ) ; writer . close ( ) ; dir . close ( ) ; }	add a single address and search for it.
private boolean isminorversionupgrade ( string currentversion , string targetversion ) { string currentdbschemaversion = vdcutil . getdbschemaversion ( currentversion ) ; if ( currentdbschemaversion == null ) { return _bool ; } return currentdbschemaversion . equals ( vdcutil . getdbschemaversion ( targetversion ) ) ; }	check if the current upgrade is a sp / patch / hotfix upgrade .
public static final void exception ( throwable e ) { logexpensive ( level . severe , e . getmessage ( ) , e ) ; }	static version to log a severe exception .
private static defaultalignment valueof ( string str , boolean ishorizontal ) { if ( str . equals ( _str ) || str . equals ( _str ) ) { return fill_align ; } else if ( str . equals ( _str ) || str . equals ( _str ) ) { return center_align ; } else if ( ishorizontal ) { if ( str . equals ( _str ) || str . equals ( _str ) ) { return right_align ; } else if ( str . equals ( _str ) || str . equals ( _str ) ) { return left_align ; } else { return null ; } } else if ( str . equals ( _str ) || str . equals ( _str ) ) { return top_align ; } else if ( str . equals ( _str ) || str . equals ( _str ) ) { return bottom_align ; } else { return null ; } }	returns a defaultalignment that corresponds to the specified string , null if no such alignment exists .
public void combinesets ( hashmap < string , set < string > > containeraffinities , operatorpair pair ) { set < string > set1 = containeraffinities . get ( pair . first ) ; set < string > set2 = containeraffinities . get ( pair . second ) ; set1 . addall ( set2 ) ; containeraffinities . put ( pair . first , set1 ) ; containeraffinities . put ( pair . second , set1 ) ; }	combine affinity sets for operators with affinity.
protected void firepropertychange ( string propertyname , object oldvalue , object newvalue ) { propertychangesupport . firepropertychange ( propertyname , oldvalue , newvalue ) ; }	support for reporting bound property changes for object properties.
@ override public boolean isbusy ( ) { return ( m_splitthread != null ) ; }	returns true if . at this time , the bean is busy with some ( i . e . perhaps a worker thread is performing some calculation ) .
public static < e > boolean isnotempty ( charsequence c ) { return ( ( c != null ) && ( c . length ( ) > _num ) ) ; }	check whether charsequence c is not empty .
@ override public boolean eisset ( int featureid ) { switch ( featureid ) { case eippackage . composite_processor__name : return name_edefault == null ? name != null : ! name_edefault . equals ( name ) ; case eippackage . composite_processor__to_channels : return tochannels != null && ! tochannels . isempty ( ) ; case eippackage . composite_processor__from_channels : return fromchannels != null && ! fromchannels . isempty ( ) ; case eippackage . composite_processor__owned_endpoints : return ownedendpoints != null && ! ownedendpoints . isempty ( ) ; } return super . eisset ( featureid ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
private void addinfobutton ( jpanel panel , object o , string clientprop ) { jbutton hbutton ; hbutton = new jbutton ( o . tostring ( ) ) ; hbutton . putclientproperty ( clientprop , o ) ; hbutton . addactionlistener ( this ) ; hbutton . setfont ( font ) ; hbutton . setmargin ( new insets ( _num , _num , _num , _num ) ) ; hbutton . setbackground ( log_button_bg ) ; panel . add ( hbutton ) ; }	adds a new button to a log entry panel and attaches a client property into it.
public void removenetworklistener ( networklistener networklistener ) { networklisteners . remove ( networklistener ) ; }	remove a network listener .
public static string chomp ( string s ) { if ( s . endswith ( _str ) ) return s . substring ( _num , s . length ( ) - _num ) ; if ( s . endswith ( _str ) || s . endswith ( _str ) ) return s . substring ( _num , s . length ( ) - _num ) ; return s ; }	removes a line - break from the end of the string ( if there ' s any ) .
private void validatesurrogatesettings ( ) { faultysurrogatesradiobutton . setenabled ( _bool ) ; discardsurrogatesarticleradiobutton . setenabled ( _bool ) ; replacesurrogatesradiobutton . setenabled ( _bool ) ; discardsurrogatesrevisionradiobutton . setselected ( _bool ) ; }	validates the surrogate settings .
static diskid creatediskid ( long maxoplogsize , boolean ispersistencetype , boolean needslinkedlist ) { long bytes = maxoplogsize * _num * _num ; if ( bytes > integer . max_value ) { if ( ispersistencetype ) { if ( needslinkedlist ) { return new persistencewithlongoffset ( ) ; } else { return new persistencewithlongoffsetnoll ( ) ; } } else { if ( needslinkedlist ) { return new overflowonlywithlongoffset ( ) ; } else { return new overflowonlywithlongoffsetnoll ( ) ; } } } else { if ( ispersistencetype ) { if ( needslinkedlist ) { return new persistencewithintoffset ( ) ; } else { return new persistencewithintoffsetnoll ( ) ; } } else { if ( needslinkedlist ) { return new overflowonlywithintoffset ( ) ; } else { return new overflowonlywithintoffsetnoll ( ) ; } } } }	creates appropriate instance of diskid depending upon the maxoplogsize set by the user.
public static long sizeof ( class clazz ) { long maxsize = headersize ( clazz ) ; while ( clazz != object . class ) { for ( field f : clazz . getdeclaredfields ( ) ) { if ( ( f . getmodifiers ( ) & modifier . static ) == _num ) { long offset = unsafe . objectfieldoffset ( f ) ; if ( offset > maxsize ) { maxsize = offset + _num ; } } } clazz = clazz . getsuperclass ( ) ; } return roundupto8 ( maxsize ) ; }	returns the size of an instance of this class ( in bytes ).
public void addhandler ( string columnname , sqldatahandler handler ) { if ( m_overrides == null ) m_overrides = new hashmap ( _num ) ; m_overrides . put ( columnname , handler ) ; }	add a custom data handler for a given column name .
public void addnearevicted ( keycacheobject key ) { if ( nearevicted == null ) nearevicted = new arraylist < > ( ) ; nearevicted . add ( key ) ; }	adds near evicted key.
public word ( string word , string displayas , string ... soundslike ) { this ( ) ; this . word = word ; this . displayas = displayas ; this . soundslike = arrays . aslist ( soundslike ) ; }	instantiates a new word .
public enumerateddistribution ( final list < pair < t , double > > pmf ) throws mathillegalargumentexception { singletons = new arraylist < > ( pmf . size ( ) ) ; final double [ ] probs = new double [ pmf . size ( ) ] ; for ( int i = _num ; i < pmf . size ( ) ; i ++ ) { final pair < t , double > sample = pmf . get ( i ) ; singletons . add ( sample . getkey ( ) ) ; final double p = sample . getvalue ( ) ; probs [ i ] = p ; } probabilities = checkandnormalize ( probs ) ; cumulativeprobabilities = new double [ probabilities . length ] ; double sum = _num ; for ( int i = _num ; i < probabilities . length ; i ++ ) { sum += probabilities [ i ] ; cumulativeprobabilities [ i ] = sum ; } }	create an enumerated distribution using the given probability mass function enumeration .
@ override public calendar next ( ) { if ( spot . equals ( endfinal ) ) { throw new nosuchelementexception ( ) ; } spot . add ( calendar . date , _num ) ; return ( calendar ) spot . clone ( ) ; }	return the next calendar in the iteration.
public void pausework ( ) { mexittasksearly = _bool ; setpause ( _bool ) ; if ( debug ) { log . d ( log_tag , string . format ( _str , this ) ) ; } }	temporarily hand up work , you can call this when the view is scrolling .
public static list < errorlogger . errorobject > isvirtualtrackincplconformed ( payloadrecord cplpayloadrecord , virtualtrack virtualtrack , list < payloadrecord > essencesheaderpartitionpayloads ) throws ioexception { list < virtualtrack > virtualtracks = new arraylist < > ( ) ; imferrorlogger imferrorlogger = new imferrorloggerimpl ( ) ; virtualtracks . add ( virtualtrack ) ; imferrorlogger . addallerrors ( checkvirtualtrackandessencesheaderpartitionpayloadrecords ( virtualtracks , essencesheaderpartitionpayloads ) ) ; if ( imferrorlogger . hasfatalerrors ( ) ) { return imferrorlogger . geterrors ( ) ; } imferrorlogger . addallerrors ( conformvirtualtracksincpl ( cplpayloadrecord , essencesheaderpartitionpayloads , _bool ) ) ; return imferrorlogger . geterrors ( ) ; }	a stateless method that can be used to determine if a virtual track in a composition is conformant . conformance checks perform deeper inspection of the composition and the essencedescriptors corresponding to the virtual track.
public static string encode ( byte [ ] input ) { if ( input . length == _num ) { return _str ; } int zeros = _num ; while ( zeros < input . length && input [ zeros ] == _num ) { ++ zeros ; } input = arrays . copyof ( input , input . length ) ; char [ ] encoded = new char [ input . length * _num ] ; int outputstart = encoded . length ; for ( int inputstart = zeros ; inputstart < input . length ; ) { encoded [ -- outputstart ] = alphabet [ divmod ( input , inputstart , _num , _num ) ] ; if ( input [ inputstart ] == _num ) { ++ inputstart ; } } while ( outputstart < encoded . length && encoded [ outputstart ] == encoded_zero ) { ++ outputstart ; } while ( -- zeros >= _num ) { encoded [ -- outputstart ] = encoded_zero ; } return new string ( encoded , outputstart , encoded . length - outputstart ) ; }	encodes the given bytes as a base58 string ( no checksum is appended ) .
public static int [ ] cells ( int [ ] start , int [ ] end ) { arrays . sort ( start ) ; arrays . sort ( end ) ; int overlap = _num ; int gaps = _num ; for ( int i = _num , j = _num ; j < end . length ; ) { if ( i < start . length && start [ i ] < end [ j ] ) { overlap ++ ; i ++ ; } else { j ++ ; overlap -- ; } if ( overlap == _num ) { gaps ++ ; } } int [ ] cells = new int [ gaps * _num ] ; overlap = _num ; gaps = _num ; int previousoverlap = _num ; for ( int i = _num , j = _num ; j < end . length ; ) { if ( i < start . length && start [ i ] < end [ j ] ) { overlap ++ ; if ( previousoverlap == _num ) { cells [ gaps ++ ] = start [ i ] ; } i ++ ; } else { overlap -- ; if ( overlap == _num ) { cells [ gaps ++ ] = end [ j ] ; } j ++ ; } previousoverlap = overlap ; } return cells ; }	calculate the ranges for the cells.
@ override public instore openread ( long address , int size ) { if ( filesize ( ) < address + size ) { throw new illegalstateexception ( l . l ( _str , this , address , size , filesize ( ) ) ) ; } if ( _isclosed . get ( ) ) { throw new illegalstateexception ( l . l ( _str , this ) ) ; } if ( _filesize < address + size ) { throw new illegalstateexception ( l . l ( _str , long . tohexstring ( address ) , size ) ) ; } try { streamopen ( address , size ) ; return openreadimpl ( address , size ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }	opens the underlying file to the database .
list < address > geodecode ( string searchedlocation ) { try { geocoder geo = new geocoder ( scontext , locale . getdefault ( ) ) ; list < address > addresses = geo . getfromlocationname ( searchedlocation , _num ) ; if ( addresses != null && addresses . size ( ) > _num ) { return addresses ; } } catch ( exception ex ) { } return null ; }	return list of < address > from searched location.
private boolean isidentifierstartchar ( int position ) { if ( _len >= _num && position >= _len ) { return _bool ; } char ch = _working [ position ] ; return character . isunicodeidentifierstart ( ch ) ; }	checks if character at specified position can be identifier start .
public void destroy ( ) { fallbackstorage . clear ( ) ; fileutils . deletequietly ( fallbackstoragefile ) ; }	destroy the persisted storage and all stored data .
public static selectclause create ( string ... propertynames ) { list < selectclauseelement > selectlist = new arraylist < selectclauseelement > ( ) ; for ( string name : propertynames ) { selectlist . add ( new selectclauseexpression ( new propertyvalueexpression ( name ) ) ) ; } return new selectclause ( streamselector . istream_only , selectlist ) ; }	creates a select - clause consisting of a list of property names .
public static string makemargintransform ( double owidth , double oheight , double iwidth , double iheight , double lmargin , double tmargin , double rmargin , double bmargin ) { double swidth = iwidth + lmargin + rmargin ; double sheight = iheight + tmargin + bmargin ; double scale = math . max ( swidth / owidth , sheight / oheight ) ; double offx = ( scale * owidth - swidth ) * _num + lmargin ; double offy = ( scale * oheight - sheight ) * _num + tmargin ; return _str + fmt ( _num / scale ) + _str + fmt ( offx ) + _str + fmt ( offy ) + _str ; }	make a transform string to add margins.
public static boolean isattachment ( string contentdisposition ) { return contentdisposition != null && contentdisposition . regionmatches ( _bool , _num , _str , _num , _num ) ; }	returns true if the download meant to be treated as an attachment .
private jmenu createinsertmenu ( ) { jmenu insertmenu = new jmenu ( _str ) ; insertmenu . add ( actionmanager . getnewnetworkaction ( ) ) ; jmenu newgaugesubmenu = new jmenu ( _str ) ; for ( action action : actionmanager . getplotactions ( ) ) { newgaugesubmenu . add ( action ) ; } insertmenu . add ( newgaugesubmenu ) ; jmenu newworldsubmenu = new jmenu ( _str ) ; for ( action action : actionmanager . getnewworldactions ( ) ) { newworldsubmenu . add ( action ) ; } insertmenu . add ( newworldsubmenu ) ; insertmenu . addseparator ( ) ; insertmenu . add ( actionmanager . getnewdocvieweraction ( ) ) ; insertmenu . add ( actionmanager . getnewconsoleaction ( ) ) ; return insertmenu ; }	create the workspace insert menu .
public static vector < string > findpackages ( ) { vector < string > result ; enumeration < string > packages ; initcache ( ) ; result = new vector < string > ( ) ; packages = m_classcache . packages ( ) ; while ( packages . hasmoreelements ( ) ) { result . add ( packages . nextelement ( ) ) ; } collections . sort ( result , new stringcompare ( ) ) ; return result ; }	lists all packages it can find in the classpath .
public static string convertsystemnametoalternate ( string systemname ) { if ( ! validsystemnameformat ( systemname , systemname . charat ( _num ) , _str ) ) { return _str ; } string altname = _str ; altname = systemname ; return altname ; }	public static method to convert one format acela system name for the alternate format.
private void initializeuserdirectives ( ) { userdirectives = new arraylist < > ( ) ; ieclipsepreferences preferences = velocitycoreplugin . getpreferences ( ) ; string directives = preferences . get ( ipreferencesconstants . velocity_user_directives , _str ) ; stringtokenizer st = new stringtokenizer ( directives , _str ) ; while ( st . hasmoreelements ( ) ) { string directive = ( string ) st . nextelement ( ) ; string name = directive . substring ( _num , directive . indexof ( _str ) ) ; int type = ( directive . endswith ( _str ) ? directive . block : directive . line ) ; userdirectives . add ( _str + name ) ; adddirective ( new velocitydirective ( name , type ) ) ; } }	this methods initializes all user directives .
private synchronized void storetimestampandsetstatus ( timestamper . timestampsucceeded message , timestamprecord timestamprecord ) throws exception { try { persisttimestamprecord ( message , timestamprecord ) ; settimestampsucceeded ( ) ; } catch ( exception e ) { log . error ( _str , e ) ; settimestampfailedregardlessofqueue ( new datetime ( ) ) ; throw e ; } }	stores timestamped records , and sets status to succeeded if everything went as expected . this method is synchronized so that these two operations are executed atomically and do not disturb each other : 1 ) storetimestampandsetstatus : stores timestamp records and sets status 2 ) settimestampfailed : reads status , checks existence of unstamped records and sets status.
public static character [ ] valuesof ( char [ ] array ) { character [ ] dest = new character [ array . length ] ; for ( int i = _num ; i < array . length ; i ++ ) { dest [ i ] = character . valueof ( array [ i ] ) ; } return dest ; }	converts to object array .
public void mark ( int readlimit ) { stream . mark ( readlimit ) ; if ( marksupported ( ) ) { markpos = framepos ; markpushbacklen = pushbacklen ; if ( markpushbacklen > _num ) { if ( markpushbackbuffer == null ) { markpushbackbuffer = new byte [ framesize ] ; } system . arraycopy ( pushbackbuffer , _num , markpushbackbuffer , _num , markpushbacklen ) ; } } }	marks the current position in this audio input stream .
public void testcreatinglauncherwithjetty1 ( ) { swtbotprojectcreation . createmavengwtprojectiscreated1 ( bot , project_name , package_name ) ; swtbotprojectdebug . launchgwtdevmodewithjettythenterminateit ( bot , project_name ) ; string persistedargs = swtbotprojectdebug . gettheprogramargstextbox ( bot ) ; asserttrue ( persistedargs . contains ( _str ) ) ; }	gwt maven plugin 1 test launch.
public static boolean needsdefaultformatter ( valueformatter formatter ) { if ( formatter == null ) return _bool ; if ( formatter instanceof defaultvalueformatter ) return _bool ; return _bool ; }	if this component has no valueformatter or is only equipped with the default one ( no custom set ) , return true .
public boolean putgrammar ( schemagrammar grammar , boolean deep , boolean ignoreconflict ) { if ( ! ignoreconflict ) { return putgrammar ( grammar , deep ) ; } schemagrammar sg = getgrammar ( grammar . ftargetnamespace ) ; if ( sg == null ) { putgrammar ( grammar ) ; } if ( ! deep ) { return _bool ; } vector currgrammars = grammar . getimportedgrammars ( ) ; if ( currgrammars == null ) { return _bool ; } vector grammars = ( ( vector ) currgrammars . clone ( ) ) ; schemagrammar sg1 , sg2 ; vector gs ; for ( int i = _num ; i < grammars . size ( ) ; i ++ ) { sg1 = ( schemagrammar ) grammars . elementat ( i ) ; sg2 = getgrammar ( sg1 . ftargetnamespace ) ; if ( sg2 == null ) { gs = sg1 . getimportedgrammars ( ) ; if ( gs == null ) continue ; for ( int j = gs . size ( ) - _num ; j >= _num ; j -- ) { sg2 = ( schemagrammar ) gs . elementat ( j ) ; if ( ! grammars . contains ( sg2 ) ) grammars . addelement ( sg2 ) ; } } else { grammars . remove ( sg1 ) ; } } for ( int i = grammars . size ( ) - _num ; i >= _num ; i -- ) { putgrammar ( ( schemagrammar ) grammars . elementat ( i ) ) ; } return _bool ; }	put a schema grammar and any grammars imported by it ( directly or inderectly ) into the registry.
public list < n > nodes ( @ nullable object key , int cnt ) { return nodes ( key , cnt , null , null ) ; }	gets specified count of adjacent nodes for a given key.
public boolean isexistskey ( connection connection , object [ ] keys ) { stringbuilder builder = new stringbuilder ( ) ; builder . append ( _str ) ; builder . append ( tablename ) ; builder . append ( _str ) ; string delimiter = _str ; for ( string keyfield : keyfieldnames ) { builder . append ( delimiter ) ; builder . append ( keyfield ) ; builder . append ( _str ) ; delimiter = _str ; } string query = builder . tostring ( ) ; preparedstatement statement = null ; try { if ( ( executionpathdebuglog . isdebugenabled ) && ( log . isdebugenabled ( ) ) ) { log . debug ( _str + query + _str + print ( keys ) + _str ) ; } statement = connection . preparestatement ( query ) ; for ( int i = _num ; i < keys . length ; i ++ ) { statement . setobject ( i + _num , keys [ i ] ) ; } resultset rs = statement . executequery ( ) ; if ( ! rs . next ( ) ) { return _bool ; } return _bool ; } catch ( sqlexception ex ) { string message = _str + query + _str + ex . getmessage ( ) ; log . error ( message , ex ) ; storeexceptionhandler . handle ( message , ex ) ; throw new storeexceptiondbrel ( message , ex ) ; } finally { try { if ( statement != null ) statement . close ( ) ; } catch ( sqlexception e ) { } } }	determine if the key exists .
public static < t > t implement ( class < t > type , object object ) { if ( type . isinstance ( object ) ) { return type . cast ( object ) ; } return type . cast ( proxy . newproxyinstance ( type . getclassloader ( ) , new class [ ] { type } , new ducktype ( object ) ) ) ; }	causes object to implement the interfacetoimplement and returns an instance of the object implementing interfacetoimplement even if interfacetoimplement was not declared in object.
public boolean isivrvsan ( int vsanid ) { boolean inrange = vsans . contains ( vsanid ) ; if ( ! inrange ) { for ( intrange range : getvsansranges ( ) ) { inrange = range . containsinteger ( vsanid ) ; if ( inrange ) { break ; } } } return inrange ; }	determine if given vsan is an ivr vsan.
private void addbomlines ( mproduct product , bigdecimal qty ) { mppproductbom bom = mppproductbom . getdefault ( product , null ) ; mppproductbomline [ ] bomlines = bom . getlines ( _bool ) ; for ( int i = _num ; i < bomlines . length ; i ++ ) addbomline ( bomlines [ i ] , qty ) ; log . fine ( _str + bomlines . length ) ; }	add bom lines to this . called recursively.
@ override public foo fetchbyuuid_c_last ( string uuid , long companyid , orderbycomparator < foo > orderbycomparator ) { int count = countbyuuid_c ( uuid , companyid ) ; if ( count == _num ) { return null ; } list < foo > list = findbyuuid_c ( uuid , companyid , count - _num , count , orderbycomparator ) ; if ( ! list . isempty ( ) ) { return list . get ( _num ) ; } return null ; }	returns the last foo in the ordered set where uuid = & # 63 ; and companyid = & # 63 ; .
public final boolean at ( string str , charsequence csq ) { int i = index ; int length = csq . length ( ) ; for ( int j = _num ; j < str . length ( ) ; ) { if ( ( i >= length ) || ( str . charat ( j ++ ) != csq . charat ( i ++ ) ) ) return _bool ; } return _bool ; }	indicates if this cursor points to the specified characters in the specified sequence .
public static int findlastof ( string container , string charseq , int begin ) { for ( int i = begin ; i < container . length ( ) && i >= _num ; -- i ) { if ( charseq . contains ( _str + container . charat ( i ) ) ) return i ; } return - _num ; }	find the last occurrence .
private static cookieorigin adjusteffectivehost ( final cookieorigin origin ) { string host = origin . gethost ( ) ; boolean islocalhost = _bool ; for ( int i = _num ; i < host . length ( ) ; i ++ ) { char ch = host . charat ( i ) ; if ( ch == _str || ch == _str ) { islocalhost = _bool ; break ; } } if ( islocalhost ) { host += _str ; return new cookieorigin ( host , origin . getport ( ) , origin . getpath ( ) , origin . issecure ( ) ) ; } else { return origin ; } }	set ' effective host name ' as defined in rfc 2965.
protected final void finalize ( ) { }	enum classes cannot have finalize methods .
public boolean addbound ( typebound bound ) { if ( bound . istrivial ( ) ) { return _bool ; } final boolean wasadded = internal_addbound ( bound ) ; if ( debug ) { final string suffix = wasadded ? _str : _str ; log ( _str + bound + suffix ) ; } return wasadded ; }	adds a type bound to this set.
public boolean remove ( simevent event ) { return sortedset . remove ( event ) ; }	removes the event from the queue .
public static final void printthreadcputime ( final thread thread ) { if ( tbe . isthreadcputimeenabled ( ) ) { log . info ( _str + thread . getname ( ) + _str + getthreadcputime ( thread ) + _str ) ; } }	prints the cpu time for the given thread , i.
public static version frombits ( int major , int minor , int bugfix ) { return new version ( major , minor , bugfix ) ; }	returns a new version based on raw numbers.
private static imultipoint [ ] randompoints ( int n , int d , int scale ) { imultipoint points [ ] = new imultipoint [ n ] ; for ( int i = _num ; i < n ; i ++ ) { stringbuilder sb = new stringbuilder ( ) ; for ( int j = _num ; j < d ; j ++ ) { sb . append ( rgen . nextdouble ( ) * scale ) ; if ( j < d - _num ) { sb . append ( _str ) ; } } points [ i ] = new hyperpoint ( sb . tostring ( ) ) ; } return points ; }	generate array of n d - dimensional points whose coordinates are values in the range 0.
public static string bytestostring ( int [ ] b ) { if ( b . length < _num ) { return _str ; } return string . format ( _str , b [ _num ] , b [ _num ] , b [ _num ] , b [ _num ] ) ; }	prints a int [ ] as a string separated by ".
private string converttoisodatetime ( string humanreadabledatetime ) throws parseexception { dateformat dfinitial = new simpledateformat ( _str ) ; date initialdatetime = dfinitial . parse ( humanreadabledatetime ) ; dateformat df = new simpledateformat ( _str ) ; return df . format ( initialdatetime ) ; }	convert string of datetime of format " yyyy - mm - dd hh : mm : ss " into iso 8601 format " yyyy - mm - dd ' t ' hh : mm : ss . s ' z ' ".
private static boolean classnamesequal ( string name1 , string name2 ) { name1 = name1 . substring ( name1 . lastindexof ( _str ) + _num ) ; name2 = name2 . substring ( name2 . lastindexof ( _str ) + _num ) ; return name1 . equals ( name2 ) ; }	compares class names for equality , ignoring package names.
public boolean optboolean ( int index ) { return optboolean ( index , _bool ) ; }	get the optional boolean value associated with an index.
public commandbuilder withlongswitchifpresent ( map < string , object > properties , string ... keys ) { withlongswitchifpresent ( properties , unaryoperator . identity ( ) , keys ) ; return this ; }	if the given key ( s ) is present in the map , create a long switch ( - - switch ) with the same name as the key.
private void oncollectionclicked ( long collectionid ) { intent intent = new intent ( this , productlistactivity . class ) ; if ( collectionid != null ) { intent . putextra ( productlistactivity . extra_collection_id , collectionid ) ; } startactivity ( intent ) ; }	when the user picks a collection , launch the product list activity to display the products in that collection .
public boolean isitemstackregisteredforname ( itemstack stack , string orename ) { final int [ ] oreids = oredictionary . getoreids ( stack ) ; for ( final int oreid : oreids ) { if ( orename . equals ( oredictionary . getorename ( oreid ) ) ) { return _bool ; } } return _bool ; }	is the itemstack registered under the specified ore name ? < p > test for this thread : http : / / www.
private static @ nonnull url [ ] createclassloaderurls ( @ nonnull url url ) throws pluginexception { list < url > urls = new arraylist < url > ( ) ; urls . add ( url ) ; manifest mf = null ; file f = new file ( url . getpath ( ) ) ; if ( ! f . isdirectory ( ) ) { jarinputstream jis = null ; try { jis = new jarinputstream ( url . openstream ( ) ) ; mf = jis . getmanifest ( ) ; } catch ( ioexception ioe ) { throw new pluginexception ( _str + url , ioe ) ; } finally { io . close ( jis ) ; } } else { file manifest = guessmanifest ( f ) ; if ( manifest != null ) { fileinputstream is = null ; try { is = new fileinputstream ( manifest ) ; mf = new manifest ( is ) ; } catch ( ioexception e ) { throw new pluginexception ( _str + url , e ) ; } finally { io . close ( is ) ; } } } if ( mf != null ) { try { addclasspathfrommanifest ( url , urls , mf ) ; } catch ( malformedurlexception e ) { throw new pluginexception ( _str + url , e ) ; } } return urls . toarray ( new url [ urls . size ( ) ] ) ; }	patch for issue 3429143 : allow plugins load classes / resources from 3rd party jars.
@ override public void write ( string str , int st , int end ) throws ioexception { out . write ( str , st , end ) ; }	write the specified characters from a string .
public boolean isawake ( ) { return isawake ; }	returns whether the node is awake .
private static void transferstreams ( inputstream source , outputstream destination ) { byte [ ] buffer = new byte [ _num ] ; try { while ( _bool ) { int bytesread = - _num ; try { bytesread = source . read ( buffer ) ; } catch ( ioexception e ) { return ; } if ( bytesread == - _num ) break ; try { destination . write ( buffer , _num , bytesread ) ; } catch ( ioexception e ) { return ; } } } finally { try { source . close ( ) ; } catch ( ioexception e ) { } finally { try { destination . close ( ) ; } catch ( ioexception e ) { } } } }	transfers all available bytes from the given input stream to the given output stream.
public static void gc ( ) { if ( startedgc ) { forcegc = _bool ; gcshouldloop = _bool ; } startgcthread ( ) ; synchronized ( lock ) { lock . notify ( ) ; } try { thread . sleep ( _num ) ; } catch ( interruptedexception er ) { } }	runs the garbage collector.
public static blobentry isblobentryforstoring ( string repositorylocation , string mimetype ) { repositorylocation location ; try { location = new repositorylocation ( repositorylocation ) ; entry entry = location . locateentry ( ) ; if ( entry instanceof blobentry ) { blobentry blobentry = ( blobentry ) entry ; if ( mimetype . equals ( blobentry . getmimetype ( ) ) ) { return blobentry ; } else { swingtools . showsimpleerrormessage ( _str , blobentry . getname ( ) ) ; return null ; } } else if ( entry == null ) { return createblobentry ( repositorylocation ) ; } else { swingtools . showsimpleerrormessage ( _str , entry . getname ( ) ) ; } } catch ( repositoryexception e ) { swingtools . showsimpleerrormessage ( _str , e ) ; } catch ( malformedrepositorylocationexception e ) { swingtools . showsimpleerrormessage ( _str , e ) ; } return null ; }	this method will check if the given location is either empty or is an blobentry of the given mimetype.
@ requestmapping ( value = { _str , _str } , method = requestmethod . put ) @ responsebody public restwrapper insert ( @ modelattribute ( _str ) @ valid batch batch , bindingresult bindingresult , principal principal ) { restwrapper restwrapper = null ; if ( bindingresult . haserrors ( ) ) { bindingresulterror bindingresulterror = new bindingresulterror ( ) ; return bindingresulterror . errormessage ( bindingresult ) ; } try { com . wipro . ats . bdre . md . dao . jpa . batch jpabatch = new com . wipro . ats . bdre . md . dao . jpa . batch ( ) ; jpabatch . setbatchtype ( batch . getbatchtype ( ) ) ; instanceexec instanceexec = new instanceexec ( ) ; if ( batch . getsourceinstanceexecid ( ) != null ) { instanceexec . setinstanceexecid ( batch . getsourceinstanceexecid ( ) ) ; jpabatch . setinstanceexec ( instanceexec ) ; } long autogenbatchid = batchdao . insert ( jpabatch ) ; batch . setbatchid ( autogenbatchid ) ; restwrapper = new restwrapper ( batch , restwrapper . ok ) ; logger . info ( recordwithid + batch . getbatchid ( ) + _str + principal . getname ( ) + batch ) ; } catch ( metadataexception e ) { logger . error ( e ) ; restwrapper = new restwrapper ( e . getmessage ( ) , restwrapper . error ) ; } return restwrapper ; }	this method calls proc insertbatch and adds a record in database.
private void onclickgalleryimage ( final recentmedia amediaitem ) { if ( null != mcamera ) { mcamera . stoppreview ( ) ; } mselectedgalleryitemslist . add ( amediaitem ) ; if ( ( null != amediaitem . mthumbnail ) && ! misavatarmode ) { updateuiconfiguration ( ui_show_taken_image , image_origin_gallery ) ; mimagepreviewimageview . setimagebitmap ( amediaitem . mthumbnail ) ; vectorapp . setsavedcameraimagepreview ( amediaitem . mthumbnail ) ; } else if ( null != amediaitem . mfileuri ) { displayimagepreview ( null , null , amediaitem . mfileuri , image_origin_gallery ) ; } else { log . e ( log_tag , _str ) ; } mimagepreviewimageview . settag ( amediaitem . mfileuri ) ; }	the user clicked on a gallery image.
public static double pareto ( double alpha ) { if ( ! ( alpha > _num ) ) throw new illegalargumentexception ( _str ) ; return math . pow ( _num - uniform ( ) , - _num / alpha ) - _num ; }	returns a random real number from a pareto distribution with shape parameter & alpha ; .
public void disconnectfrombroker ( final mqttasyncconnection connection ) { try { connection . disconnect ( new mqttdisconnectionresulthandler ( ) ) ; } catch ( spyexception e ) { platform . runlater ( new mqtteventhandler ( new mqttdisconnectionattemptfailureevent ( connection , e ) ) ) ; logger . error ( e . getmessage ( ) , e ) ; } }	disconnects the specified connection from the broker .
public object [ ] copyall ( ) { return arrays . copyof ( args , args . length ) ; }	returns all arguments in the argument list in a freshly - allocated array .
public void start ( ) { log . info ( _str , port , loglevel ) ; try { component . start ( ) ; } catch ( exception e ) { throw new illegalstateexception ( _str , e ) ; } log . info ( _str , port ) ; running = _bool ; started = system . currenttimemillis ( ) ; }	starts the nutch server printing some logging to the log file .
public fsaccountfedinfo readaccountfedinfo ( string userid , string providerid ) throws fsaccountmgmtexception { return readaccountfedinfo ( userid , providerid , null ) ; }	reads account ' s federation info from data store for given providerid and returns value as fedinfo object . returns null if value not found for given providerid.
public response ( string status , string mimetype , string txt ) { this . status = status ; this . mimetype = mimetype ; try { this . data = new bytearrayinputstream ( txt . getbytes ( _str ) ) ; } catch ( java . io . unsupportedencodingexception uee ) { uee . printstacktrace ( ) ; } }	convenience method that makes an inputstream out of given text .
@ parallel @ realtime ( limit = linear ) public e reduce ( binaryoperator < e > operator ) { iterator < e > itr = iterator ( ) ; if ( ! itr . hasnext ( ) ) return null ; e accumulator = itr . next ( ) ; while ( itr . hasnext ( ) ) accumulator = operator . apply ( accumulator , itr . next ( ) ) ; return accumulator ; }	performs a reduction by applying the specified operator over the elements of this collection .
public void savehistory ( string filename ) throws exception { fileoutputstream fos = new fileoutputstream ( filename ) ; objectoutputstream oos = new objectoutputstream ( fos ) ; oos . writeobject ( gethistory ( ) ) ; oos . close ( ) ; }	save the utilization history to a file .
private void checksize ( final int i ) { if ( i >= max_size ) { final int old_size = max_size ; max_size += increment_size ; if ( max_size <= i ) { max_size = i + increment_size + _num ; } final double [ ] temp = items ; items = new double [ max_size ] ; system . arraycopy ( temp , _num , items , _num , old_size ) ; increment_size = incrementsize ( increment_size ) ; } }	check the size of the array and increase if needed.
public double nextgaussian ( ) { return random . nextgaussian ( ) ; }	get the next gaussian value .
private void readfromproperties ( final properties props , final boolean defaultminimized , final int defaultx , final int defaulty , final boolean defaultvisible ) { minimized = boolean . parseboolean ( props . getproperty ( _str + name + _str , boolean . tostring ( defaultminimized ) ) ) ; visible = boolean . parseboolean ( props . getproperty ( _str + name + _str , boolean . tostring ( defaultvisible ) ) ) ; x = integer . parseint ( props . getproperty ( _str + name + _str , integer . tostring ( defaultx ) ) ) ; y = integer . parseint ( props . getproperty ( _str + name + _str , integer . tostring ( defaulty ) ) ) ; }	read window configuration from properties .
public boolean sendemailattachments ( int ad_user_id , string subject , string message , collection < file > attachments , boolean html ) { muser to = muser . get ( getctx ( ) , ad_user_id ) ; string toemail = to . getemail ( ) ; if ( toemail == null || toemail . length ( ) == _num ) { log . warning ( _str + to ) ; return _bool ; } email email = createemail ( null , to , subject , message , html ) ; if ( email == null ) return _bool ; email . addattachments ( attachments ) ; try { return sendemailnow ( null , to , email ) ; } catch ( exception ex ) { log . severe ( getname ( ) + _str + ex . getlocalizedmessage ( ) ) ; return _bool ; } }	send email from request user - with trace.
private void addunittaxcalculationinfoclone ( final taxcalculationinfo taxcalinfo , final taxcalculationinfo clone ) { final list < unittaxcalculationinfo > units = new arraylist < unittaxcalculationinfo > ( ) ; final list < unittaxcalculationinfo > unitsbydate = new arraylist < unittaxcalculationinfo > ( ) ; for ( final unittaxcalculationinfo unitinfo : taxcalinfo . getunittaxcalculationinfos ( ) ) { final unittaxcalculationinfo newunitinfo = getunittaxcalculationinfoclone ( unitinfo ) ; unitsbydate . add ( newunitinfo ) ; } clone . setunittaxcalculationinfo ( units ) ; }	adds the unittaxcalculationinfo clones to clone.
public socketwrapper accept ( ) throws ioexception { for ( ; ; ) { try { socket sock = serversocket . accept ( ) ; return new socketwrapper ( sock ) ; } catch ( sockettimeoutexception e ) { } catch ( ioexception e ) { if ( done ) { throw new socketterminationexception ( _str , e ) ; } else { throw e ; } } } }	accepts a connection the server socket .
private string replacedotinmustachekeys ( final list < string > mustachekeys , final string plugincall ) { string fixedplugincall = plugincall ; for ( string mustachekey : mustachekeys ) { if ( mustachekey . contains ( _str ) ) { fixedplugincall = fixedplugincall . replace ( _str + mustachekey + _str , _str + mustachekey . replace ( _str , _str ) + _str ) ; } } return fixedplugincall ; }	todo : trivial components does not support foo.
protected synchronized instance processbuffers ( ) { if ( m_firstbuffer != null && m_secondbuffer != null && m_firstbuffer . size ( ) > _num && m_secondbuffer . size ( ) > _num ) { if ( m_stoprequested . get ( ) ) { return null ; } instanceholder firsth = m_firstbuffer . peek ( ) ; instanceholder secondh = m_secondbuffer . peek ( ) ; instance first = firsth . m_instance ; instance second = secondh . m_instance ; int cmp = compare ( first , second , firsth , secondh ) ; if ( cmp == _num ) { instance newinst = generatemergedinstance ( m_firstbuffer . remove ( ) , m_secondbuffer . remove ( ) ) ; return newinst ; } else if ( cmp < _num ) { do { m_firstbuffer . remove ( ) ; if ( m_firstbuffer . size ( ) > _num ) { firsth = m_firstbuffer . peek ( ) ; first = firsth . m_instance ; cmp = compare ( first , second , firsth , secondh ) ; } } while ( cmp < _num && m_firstbuffer . size ( ) > _num ) ; } else { do { m_secondbuffer . remove ( ) ; if ( m_secondbuffer . size ( ) > _num ) { secondh = m_secondbuffer . peek ( ) ; second = secondh . m_instance ; cmp = compare ( first , second , firsth , secondh ) ; } } while ( cmp > _num && m_secondbuffer . size ( ) > _num ) ; } } return null ; }	process the current state of the two buffers.
public boolean isthemeconstant ( string constantname , boolean def ) { string c = getthemeconstant ( constantname , null ) ; if ( c == null ) { return def ; } return c . equalsignorecase ( _str ) || c . equals ( _str ) ; }	returns a theme constant defined in the resource editor as a boolean value.
public void testdelete4 ( ) throws sqlexception { databasecreator . fillfkcascadetable ( conn ) ; statement . execute ( _str + databasecreator . parent_table + _str ) ; }	deletefunctionalitytest # testdelete4 ( ) . deletes row with no referencing ones and cascade action.
public void unmap ( int addr , int len ) { for ( int i = _num ; i < len ; i += page_size ) { int pte = getpte ( addr + i ) ; if ( getpage ( pte ) != null ) { readablememory [ pte ] = null ; writablememory [ pte ] = null ; executablememory [ pte ] = null ; } else { throw new error ( _str + integer . tohexstring ( addr ) + _str + len ) ; } } }	unmap a page of memory.
private synchronized void savetosettings ( ) { list < list > entriestosave = new arraylist < > ( ) ; for ( statushistoryentry entry : entries . values ( ) ) { entriestosave . add ( entrytolist ( entry ) ) ; } settings . putlist ( _str , entriestosave ) ; }	turns all entries into a list and adds them to a list that is saved in the settings .
protected void initfinished ( ) { }	a hook method after initialize ( ) and initgui have been called .
protected void addtomaintenancequeue ( nodeporttuple npt ) { if ( maintenancequeue . contains ( npt ) == _bool ) maintenancequeue . add ( npt ) ; }	add a switch port to maintenance queue .
public moviescrapermetadatapanel ( moviescrapermetadataconfig config ) { this . config = config ; initcomponents ( ) ; }	instantiates a new movie scraper metadata panel .
public static void assertpropsperrow ( iterator < eventbean > iterator , safeiterator < eventbean > safeiterator , string [ ] propertynames , object [ ] [ ] expected ) { assertpropsperrow ( epassertionutil . iteratortoarray ( iterator ) , propertynames , expected ) ; assertpropsperrow ( epassertionutil . iteratortoarray ( safeiterator ) , propertynames , expected ) ; safeiterator . close ( ) ; }	compare the property values returned by events of both iterators with the expected values , using exact - order semantics .
public void testget ( ) throws exception { ignitecache < long , long > cache = populate ( ) ; for ( long i = from ; i < to ; i ++ ) { long val = cache . get ( i ) ; assertnotnull ( val ) ; assertequals ( i , val . longvalue ( ) ) ; } assertequals ( _num , swappedcnt . get ( ) ) ; assertequals ( _num , offheapedcnt . get ( ) ) ; assertequals ( to - from , unswapedcnt . get ( ) + onheapedcnt . get ( ) ) ; checkentries ( cache ) ; assertequals ( to - from , unswapedcnt . get ( ) + onheapedcnt . get ( ) ) ; }	tests behavior on offheaped entries .
public int read ( ) throws ioexception { if ( hasnextchar ) { hasnextchar = _bool ; write ( nextchar ) ; return nextchar ; } if ( previousline != lexer . getline ( ) ) { numunicodeescapesfoundoncurrentline = _num ; previousline = lexer . getline ( ) ; } int c = reader . read ( ) ; if ( c != _str ) { write ( c ) ; return c ; } c = reader . read ( ) ; if ( c != _str ) { hasnextchar = _bool ; nextchar = c ; write ( _str ) ; return _str ; } int numberofuchars = _num ; do { numberofuchars ++ ; c = reader . read ( ) ; } while ( c == _str ) ; checkhexdigit ( c ) ; stringbuilder charnum = new stringbuilder ( ) ; charnum . append ( ( char ) c ) ; for ( int i = _num ; i < _num ; i ++ ) { c = reader . read ( ) ; checkhexdigit ( c ) ; charnum . append ( ( char ) c ) ; } int rv = integer . parseint ( charnum . tostring ( ) , _num ) ; write ( rv ) ; numunicodeescapesfound += _num + numberofuchars ; numunicodeescapesfoundoncurrentline += _num + numberofuchars ; return rv ; }	gets the next character from the underlying reader , translating escapes as required .
public boolean isempty ( ) { if ( ! built ) return itemboundables . isempty ( ) ; return root . isempty ( ) ; }	tests whether the index contains any items.
protected abstractwriter ( writer w , document doc , int pos , int len ) { this . doc = doc ; it = new elementiterator ( doc . getdefaultrootelement ( ) ) ; out = w ; startoffset = pos ; endoffset = pos + len ; object docnewline = doc . getproperty ( defaulteditorkit . endoflinestringproperty ) ; if ( docnewline instanceof string ) { setlineseparator ( ( string ) docnewline ) ; } else { string newline = null ; try { newline = system . getproperty ( _str ) ; } catch ( securityexception se ) { } if ( newline == null ) { newline = _str ; } setlineseparator ( newline ) ; } canwraplines = _bool ; }	creates a new abstractwriter.
protected void adjustpositiony ( int velocityy ) { if ( reverselayout ) velocityy *= - _num ; int childcount = getchildcount ( ) ; if ( childcount > _num ) { int curposition = viewutils . getcenterychildposition ( this ) ; int childheight = getheight ( ) - getpaddingtop ( ) - getpaddingbottom ( ) ; int flingcount = getflingcount ( velocityy , childheight ) ; int targetposition = curposition + flingcount ; if ( msinglepagefling ) { flingcount = math . max ( - _num , math . min ( _num , flingcount ) ) ; targetposition = flingcount == _num ? curposition : mpositionontouchdown + flingcount ; } targetposition = math . max ( targetposition , _num ) ; targetposition = math . min ( targetposition , getitemcount ( ) - _num ) ; if ( targetposition == curposition && ( ! msinglepagefling || mpositionontouchdown == curposition ) ) { view centerychild = viewutils . getcenterychild ( this ) ; if ( centerychild != null ) { if ( mtouchspan > centerychild . getheight ( ) * mtriggeroffset && targetposition != _num ) { if ( ! reverselayout ) targetposition -- ; else targetposition ++ ; } else if ( mtouchspan < centerychild . getheight ( ) * - mtriggeroffset && targetposition != getitemcount ( ) - _num ) { if ( ! reverselayout ) targetposition ++ ; else targetposition -- ; } } } if ( debug ) { log . d ( _str , _str + mtouchspan ) ; log . d ( _str , _str + targetposition ) ; } smoothscrolltoposition ( safetargetposition ( targetposition , getitemcount ( ) ) ) ; } }	adjust position before touch event complete and fling action start .
@ override public node importto ( document hostdocument ) { validateutil . validatenotnull ( hostdocument , _str ) ; element clonedtokenelement = ( element ) hostdocument . importnode ( _parsedtoken . getdocumentelement ( ) , _bool ) ; markassertionidattribute ( clonedtokenelement ) ; return clonedtokenelement ; }	imports a copy of the xml representation of the token into the given document as a first child of the provided node < p > the copied token signature will remain valid if the original one was .
public static matrix random ( int m , int n ) { matrix a = new matrix ( m , n ) ; double [ ] [ ] x = a . getarray ( ) ; for ( int i = _num ; i < m ; i ++ ) { for ( int j = _num ; j < n ; j ++ ) { x [ i ] [ j ] = math . random ( ) ; } } return a ; }	generate matrix with random elements.
public void addpriorityunit ( string id ) { if ( ! stringutil . ispositiveinteger ( id ) ) { return ; } addpriorityunit ( integer . parseint ( id ) ) ; }	add an enemy unit to the priority list .
private void calcintervaldis ( ) { if ( mmarktextpaint == null ) { return ; } string defaulttext = _str ; rect temp = new rect ( ) ; int max = _num ; if ( mitems != null && mitems . size ( ) > _num ) { for ( string i : mitems ) { mmarktextpaint . gettextbounds ( i , _num , i . length ( ) , temp ) ; if ( temp . width ( ) > max ) { max = temp . width ( ) ; } } } else { mmarktextpaint . gettextbounds ( defaulttext , _num , defaulttext . length ( ) , temp ) ; max = temp . width ( ) ; } if ( ! textutils . isempty ( madditioncentermark ) ) { mmarktextpaint . settextsize ( mnormaltextsize ) ; mmarktextpaint . gettextbounds ( madditioncentermark , _num , madditioncentermark . length ( ) , temp ) ; madditioncentermarkwidth = temp . width ( ) ; max += temp . width ( ) ; } mintervaldis = max * mintervalfactor ; }	calculate interval distance between items.
public boolean isusesoftkeys ( ) { return usesoftkeys ; }	when set to true softkeys are used to enable delete functionality.
public void testdivisionknuthfirstdigitsequal ( ) { byte abytes [ ] = { _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num } ; int asign = - _num ; int bsign = - _num ; byte rbytes [ ] = { _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . divide ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	verifies the case when the first digits of the dividend and divisor equal .
public void connectionclosed ( connectionevent event ) { if ( isactive ) { managedconnection conn = ( managedconnection ) event . getsource ( ) ; transactionmanagerimpl transmanager = transactionmanagerimpl . gettransactionmanager ( ) ; try { transaction txn = transmanager . gettransaction ( ) ; if ( txn == null ) { mannpoolcache . returnpooledconnectiontopool ( conn ) ; } } catch ( exception se ) { string exception = _str + se . getmessage ( ) ; if ( logger . isdebugenabled ( ) ) { logger . debug ( exception , se ) ; } } } }	callback for connection closed .
public metadatablockheader ( boolean islastblock , blocktype blocktype , int datalength ) { bytebuffer rawdata = bytebuffer . allocate ( header_length ) ; this . blocktype = blocktype ; this . islastblock = islastblock ; this . datalength = datalength ; byte type ; if ( islastblock ) { type = ( byte ) ( _num | blocktype . getid ( ) ) ; } else { type = ( byte ) blocktype . getid ( ) ; } rawdata . put ( type ) ; rawdata . put ( ( byte ) ( ( datalength & _num ) > > > _num ) ) ; rawdata . put ( ( byte ) ( ( datalength & _num ) > > > _num ) ) ; rawdata . put ( ( byte ) ( datalength & _num ) ) ; bytes = new byte [ header_length ] ; for ( int i = _num ; i < header_length ; i ++ ) { bytes [ i ] = rawdata . get ( i ) ; } }	construct a new header in order to write metadatablock to file.
private void checkfiletorun ( ) throws exitcodeexception { if ( runthisfile == null || ! runthisfile . exists ( ) ) { throw new exitcodeexception ( exitcode_module_to_run_not_found ) ; } }	check if the file is there .
@ managedoperation ( description = _str ) public void notifyalltagcachelisteners ( ) { logger . info ( _str ) ; for ( long key : controltagcache . getkeys ( ) ) { controltagcache . acquirewritelockonkey ( key ) ; try { controltag controltag = controltagcache . getcopy ( key ) ; long eventtime = system . currenttimemillis ( ) ; controltagcache . notifylistenerstatusconfirmation ( controltag , eventtime ) ; } finally { controltagcache . releasewritelockonkey ( key ) ; } } for ( long key : datatagcache . getkeys ( ) ) { datatagcache . acquirewritelockonkey ( key ) ; try { datatag datatag = datatagcache . getcopy ( key ) ; long eventtime = system . currenttimemillis ( ) ; datatagcache . notifylistenerstatusconfirmation ( datatag , eventtime ) ; } finally { datatagcache . releasewritelockonkey ( key ) ; } } logger . info ( _str ) ; }	notifies all tag cache listeners with the confirmstatus notification , so that all listeners receive up to date notifications ( notice alarm cache listeners are notified as these are all re - evaluated , both via tag and supervision status notification ; the ruletag cache is also left out here , as all rules are refreshes through datatag and controltag status confirmations ) .
public static long [ ] breakdown ( long t , @ nonnull timeunit unit , boolean roundmillis ) { long days = unit . todays ( t ) ; long hours = unit . tohours ( t ) % _num ; long minutes = unit . tominutes ( t ) % _num ; long seconds = unit . toseconds ( t ) % _num ; long msecs = unit . tomillis ( t ) % _num ; if ( roundmillis ) { if ( msecs >= _num ) { seconds ++ ; msecs = _num ; if ( seconds == _num ) { minutes ++ ; seconds = _num ; if ( minutes == _num ) { hours ++ ; minutes = _num ; if ( hours == _num ) { days ++ ; hours = _num ; } } } } } return new long [ ] { days , hours , minutes , seconds , msecs } ; }	returns a breakdown of a given time into its values in hours , minutes , seconds and milliseconds .
private int socksgetserverport ( ) { inetsocketaddress addr = ( inetsocketaddress ) proxy . address ( ) ; return addr . getport ( ) ; }	gets the socks proxy server port .
public static < t > reactiveseq < t > fromlist ( final list < t > list ) { objects . requirenonnull ( list ) ; final reversinglistspliterator array = new reversinglistspliterator < t > ( list , _bool ) ; return streamutils . reactiveseq ( streamsupport . stream ( array , _bool ) , optional . ofnullable ( array ) ) ; }	construct a reactiveseq from a list ( prefer this method if the source is a list , as it allows more efficient stream reversal ) .
private boolean processkeyup ( int keycode ) { if ( keycode == keyevent . keycode_del ) { if ( minkbmode ) { if ( ! mtypedtimes . isempty ( ) ) { int deleted = deletelasttypedkey ( ) ; string deletedkeystr ; if ( deleted == getamorpmkeycode ( am ) ) { deletedkeystr = mamtext ; } else if ( deleted == getamorpmkeycode ( pm ) ) { deletedkeystr = mpmtext ; } else { deletedkeystr = string . format ( _str , getvalfromkeycode ( deleted ) ) ; } viewcompatutils . announceforaccessibility ( mdelegator , string . format ( mdeletedkeyformat , deletedkeystr ) ) ; updatedisplay ( _bool ) ; } } } else if ( keycode == keyevent . keycode_0 || keycode == keyevent . keycode_1 || keycode == keyevent . keycode_2 || keycode == keyevent . keycode_3 || keycode == keyevent . keycode_4 || keycode == keyevent . keycode_5 || keycode == keyevent . keycode_6 || keycode == keyevent . keycode_7 || keycode == keyevent . keycode_8 || keycode == keyevent . keycode_9 || ( ! mis24hourview && ( keycode == getamorpmkeycode ( am ) || keycode == getamorpmkeycode ( pm ) ) ) ) { if ( ! minkbmode ) { if ( mradialtimepickerview == null ) { log . e ( tag , _str ) ; return _bool ; } mtypedtimes . clear ( ) ; trystartingkbmode ( keycode ) ; return _bool ; } if ( addkeyiflegal ( keycode ) ) { updatedisplay ( _bool ) ; } return _bool ; } return _bool ; }	for keyboard mode , processes key events .
public synchronized omgraphiclist prepare ( ) { omgraphiclist list = new omgraphiclist ( ) ; projection proj = getprojection ( ) ; if ( proj == null ) { return list ; } point2d upperleft = proj . getupperleft ( ) ; point2d lowerright = proj . getlowerright ( ) ; if ( upperleft . getx ( ) > lowerright . getx ( ) ) { getpoints ( new databounds ( upperleft , new point2d . double ( _num , lowerright . gety ( ) ) ) , list , proj ) ; getpoints ( new databounds ( new point2d . double ( - _num , upperleft . gety ( ) ) , lowerright ) , list , proj ) ; } else { getpoints ( new databounds ( upperleft , lowerright ) , list , proj ) ; } omtext statement = new omtext ( _num , proj . getheight ( ) - _num , getname ( ) + _str + list . size ( ) + _str + datasource . size ( ) + _str , omtext . justify_left ) ; statement . setfillpaint ( color . gray ) ; statement . generate ( proj ) ; list . add ( _num , statement ) ; return list ; }	this is an important layer method to override.
public x509name ( vector oids , vector values ) { this ( oids , values , new x509defaultentryconverter ( ) ) ; }	takes two vectors one of the oids and the other of the values .
void nextline ( ) { try { nextline = currentepisode . readline ( ) ; while ( nextline . equals ( _str ) ) nextline = currentepisode . readline ( ) ; } catch ( ioexception | nullpointerexception e ) { nextline = null ; } }	move to the next line.
public jobs subset ( string [ ] jobids ) { final list < job > subsetresult = new arraylist < job > ( ) ; for ( string jobid : jobids ) { job job = jobmap . get ( jobid ) ; if ( job . isanalysis ( ) ) { subsetresult . add ( job ) ; } } return new jobs ( subsetresult ) ; }	returns a subset of all of the defined jobs that are restricted by the jobids ( bean ids ) passed in.
public void addpropertychangelistener ( propertychangelistener listener ) { list < propertychangelistener > l = arrays . aslist ( listenerlist . getlisteners ( propertychangelistener . class ) ) ; if ( ! l . contains ( listener ) ) { listenerlist . add ( propertychangelistener . class , listener ) ; } }	add a listener for this pane ' s property change events.
public static byte [ ] fromhexstring ( string text ) { text = text . trim ( ) ; if ( text . length ( ) % _num != _num ) text = _str + text ; int reslen = text . length ( ) / _num ; int lonibble , hinibble ; byte [ ] res = new byte [ reslen ] ; for ( int i = _num ; i < reslen ; i ++ ) { int j = i << _num ; hinibble = chartonibble ( text . charat ( j ) ) ; lonibble = chartonibble ( text . charat ( j + _num ) ) ; if ( lonibble == - _num || hinibble == - _num ) return null ; res [ i ] = ( byte ) ( hinibble << _num | lonibble ) ; } return res ; }	convert a string containing consecutive ( no inside whitespace ) hexadecimal digits into a corresponding byte array.
protected static double variance ( double [ ] s , double [ ] ss , double [ ] sumofweights ) { double var = _num ; for ( int i = _num ; i < s . length ; i ++ ) { if ( sumofweights [ i ] > _num ) { var += singlevariance ( s [ i ] , ss [ i ] , sumofweights [ i ] ) ; } } return var ; }	computes variance for subsets .
public void write ( charsequence csq ) throws ioexception { final int length = csq . length ( ) ; for ( int i = _num ; i < length ; ) { char c = csq . charat ( i ++ ) ; if ( c < _num ) { _bytes [ _index ] = ( byte ) c ; if ( ++ _index >= _bytes . length ) { flushbuffer ( ) ; } } else { write ( c ) ; } } }	writes the specified character sequence .
public static boolean canresize ( list constraints ) { for ( iterator iter = constraints . iterator ( ) ; iter . hasnext ( ) ; ) { dockconstraint dc = ( dockconstraint ) iter . next ( ) ; if ( ! dc . canresize ( ) ) return _bool ; } return _bool ; }	determine property over a list of dockconstraint objects.
string readnumber ( string source , int ofs , string token , boolean adjacent ) { if ( adjacent ) { return source . substring ( ofs , ofs + token . length ( ) ) ; } int len = source . length ( ) ; for ( int i = ofs ; i < len ; i ++ ) { char ch = source . charat ( i ) ; if ( isnumeric ( ch ) == _bool ) { if ( i == _num ) { return null ; } return source . substring ( ofs , i ) ; } } return source . substring ( ofs ) ; }	read the number . does not attempt to parse .
private vec feedforward ( vec input ) { vec x = input ; for ( int i = _num ; i < ws . size ( ) ; i ++ ) { matrix w_i = ws . get ( i ) ; vec b_i = bs . get ( i ) ; vec a_i = w_i . multiply ( x ) ; a_i . mutableadd ( b_i ) ; a_i . applyfunction ( f ) ; x = a_i ; } return x ; }	feeds an input through the network.
private boolean split_wtrace_other ( brdtracep found_trace , collection < brdtracep > split_pieces , arraylist < plalineint > intersecting_lines , awtreefindentry found_entry ) { if ( found_trace == this ) return _bool ; boolean have_trace_split = _bool ; for ( plalineint inter_line : intersecting_lines ) { if ( have_trace_split ) break ; int line_no = found_entry . shape_index_in_object + _num ; arraylist < brdtracep > curr_split_pieces = found_trace . split_with_end_line ( line_no , inter_line ) ; if ( curr_split_pieces . size ( ) < _num ) continue ; have_trace_split = _bool ; split_pieces . addall ( curr_split_pieces ) ; } if ( ! have_trace_split ) split_pieces . add ( found_trace ) ; return have_trace_split ; }	return true if some other trace was split.
private void printsolution ( solution solution ) { if ( includevariables ) { for ( int i = _num ; i < solution . getnumberofvariables ( ) ; i ++ ) { if ( i > _num ) { writer . print ( _str ) ; } writer . print ( encode ( solution . getvariable ( i ) ) ) ; } } for ( int i = _num ; i < solution . getnumberofobjectives ( ) ; i ++ ) { if ( ( i > _num ) || ( includevariables && ( solution . getnumberofvariables ( ) > _num ) ) ) { writer . print ( _str ) ; } writer . print ( solution . getobjective ( i ) ) ; } writer . println ( ) ; }	prints the solution to the result file .
public void readnbt ( nbttagcompound nbt ) { if ( nbt . haskey ( _str , _num ) ) { this . decaylevel = nbt . getinteger ( _str ) ; this . decaysaturationlevel = nbt . getfloat ( _str ) ; this . decayaccelerationlevel = nbt . getfloat ( _str ) ; } }	reads the decay stats from nbt.
public void copyto ( positiontexturevertex [ ] verts , texturedquad [ ] quad ) { texturedpolygon [ ] poly = new texturedpolygon [ quad . length ] ; for ( int idx = _num ; idx < quad . length ; idx ++ ) { poly [ idx ] = new texturedpolygon ( ( positiontexturevertex [ ] ) quad [ idx ] . vertexpositions ) ; } copyto ( verts , poly ) ; }	copies an array of vertices and quads to the current shape.
public synchronized void deleteobserver ( observer observer ) { observers . remove ( observer ) ; }	removes the specified observer from the list of observers.
public accountattribute asaccountattribute ( account account ) { if ( account == null ) { return null ; } accountattribute who = new accountattribute ( ) ; who . name = account . getfullname ( ) ; who . email = account . getpreferredemail ( ) ; who . username = account . getusername ( ) ; return who ; }	create an authorattribute for the given account suitable for serialization to json .
public void delete ( templatepersistencedata data ) { if ( data . isuseradded ( ) ) ftemplates . remove ( data ) ; else data . setdeleted ( _bool ) ; }	removes a template from the store .
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str + _str + _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str + _str + _str + _str + _str + _str , _str , _num , _str ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public string consumeword ( ) { int start = pos ; while ( matchesword ( ) ) pos ++ ; return queue . substring ( start , pos ) ; }	retrieves the next run of word type ( letter or digit ) off the queue .
public static void printinlining ( final resolvedjavamethod method , final int bci , final int inliningdepth , final boolean success , final string msg , final object ... args ) { if ( hotspotprintinlining . getvalue ( ) ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( _str ) ; sb . append ( _str ) ; sb . append ( string . format ( _str , _str , method . issynchronized ( ) ? _str : _str , _str , _str , method . isnative ( ) ? _str : _str ) ) ; sb . append ( _str ) ; sb . append ( _str ) ; for ( int i = _num ; i < inliningdepth ; i ++ ) { sb . append ( _str ) ; } sb . append ( string . format ( _str , bci , methodname ( method ) , success ? _str : _str , string . format ( msg , args ) ) ) ; tty . println ( sb . tostring ( ) ) ; } }	print a hotspot - style inlining message to the console .
public static double calculatepvalue ( double t , int v ) { return _num * ( _num - studentstdistribution . cdf ( math . abs ( t ) , v ) ) ; }	calculates the two - sided p - value of the underlying t - distribution with v degrees of freedom.
public static void appendchild ( node parent , node child ) { document ownerdoc = getownerdocument ( parent ) ; if ( child . getownerdocument ( ) != ownerdoc ) { parent . appendchild ( ownerdoc . importnode ( child , _bool ) ) ; } else { parent . appendchild ( child ) ; } }	checks if child element has same owner document before appending to the parent , and imports it to the parent ' s document if necessary .
@ suppresslint ( _str ) private void prunescrapviews ( ) { final int maxviews = mactiveviews . length ; final int viewtypecount = mviewtypecount ; final arraylist < view > [ ] scrapviews = mscrapviews ; for ( int i = _num ; i < viewtypecount ; ++ i ) { final arraylist < view > scrappile = scrapviews [ i ] ; int size = scrappile . size ( ) ; final int extras = size - maxviews ; size -- ; for ( int j = _num ; j < extras ; j ++ ) { removedetachedview ( scrappile . remove ( size -- ) , _bool ) ; } } if ( mtransientstateviews != null ) { for ( int i = _num ; i < mtransientstateviews . size ( ) ; i ++ ) { final view v = mtransientstateviews . valueat ( i ) ; if ( ! v . hastransientstate ( ) ) { mtransientstateviews . removeat ( i ) ; i -- ; } } } }	makes sure that the size of mscrapviews does not exceed the size of mactiveviews.
private void updateworkamount ( double worktime ) { if ( worktime <= _num ) { currentworkamount *= _num ; } else { totaltimetaken += worktime ; completedworkamount += currentworkamount ; currentworkamount = ( int ) math . ceil ( targetexecutionms * completedworkamount / totaltimetaken ) ; } }	update the currentworkamount based upon the worktime it took to run the last command so running the worker will take ~ targetexecutionms .
public static boolean islafaqua ( ) { ensurevalidcache ( ) ; if ( cachedislafaqua == null ) { cachedislafaqua = boolean . valueof ( computeislafaqua ( ) ) ; } return cachedislafaqua . booleanvalue ( ) ; }	lazily checks and answers whether the aqua look & amp ; feel is active .
public void moverandomly ( ) { setrandompathfrom ( getx ( ) , gety ( ) , getmovementrange ( ) / _num ) ; }	give npc a random path.
public void plni ( object o ) throws ioexception { p ( o . tostring ( ) ) ; pln ( ) ; pi ( ) ; }	writes object ; ends current line ; indents in .
@ override public void writeentitytonbt ( nbttagcompound par1nbttagcompound ) { par1nbttagcompound . setshort ( _str , ( short ) this . xtile ) ; par1nbttagcompound . setshort ( _str , ( short ) this . ytile ) ; par1nbttagcompound . setshort ( _str , ( short ) this . ztile ) ; par1nbttagcompound . setinteger ( _str , block . getidfromblock ( this . intile ) ) ; par1nbttagcompound . setbyte ( _str , ( byte ) this . indata ) ; par1nbttagcompound . setbyte ( _str , ( byte ) this . arrowshake ) ; par1nbttagcompound . setbyte ( _str , ( byte ) ( this . inground ? _num : _num ) ) ; par1nbttagcompound . setboolean ( _str , this . isexplosive ) ; }	( abstract ) protected helper method to write subclass entity data to nbt .
@ override public stringbuffer format ( final double value , final stringbuffer buffer , final fieldposition position ) { return format ( double . valueof ( value ) , buffer , position ) ; }	formats a double value as a fraction and appends the result to a stringbuffer .
private object translatestreamtoinputstream ( inputstream str , dataflavor flavor , long format , transferable localetransferable ) throws ioexception { if ( isflavorcharsettexttype ( flavor ) && istextformat ( format ) ) { str = new reencodinginputstream ( str , format , datatransferer . gettextcharset ( flavor ) , localetransferable ) ; } return constructflavoredobject ( str , flavor , inputstream . class ) ; }	for arbitrary flavors , just use the raw inputstream.
private boolean isiptresourcefolder ( file dir ) { if ( dir . exists ( ) && dir . isdirectory ( ) ) { file persistencefile = new file ( dir , persistence_file ) ; file emlfile = new file ( dir , datadir . eml_xml_filename ) ; return persistencefile . isfile ( ) && emlfile . isfile ( ) ; } return _bool ; }	determine whether the directory represents an ipt resource directory or not.
public set < string > addspriteframes ( string plist , cctexture2d texture ) { hashmap < string , object > dict = plistparser . parse ( plist ) ; return addspriteframes ( dict , texture ) ; }	adds multiple sprite frames from a plist file.
public void addannotation ( final annotation annotation ) { annotationlist . add ( annotation ) ; annotation . setxygraph ( xygraph ) ; add ( annotation ) ; revalidate ( ) ; changesupport . firepropertychange ( _str , null , annotation ) ; }	add an annotation to the plot area .
public static void createoverviews ( asdocconfiguration config ) throws compilerexception { string templatespath = config . gettemplatespath ( ) ; string ditapath = config . getoutput ( ) + _str + file . separator ; bufferedwriter writer = null ; reader reader = null ; try { writer = new bufferedwriter ( new filewriter ( ditapath + _str ) ) ; if ( config . getpackagedescriptionfile ( ) != null ) { reader = new bufferedreader ( new filereader ( config . getpackagedescriptionfile ( ) ) ) ; } else { reader = new bufferedreader ( new filereader ( templatespath + _str ) ) ; } overviewshandler h = new overviewshandler ( writer , config ) ; inputsource source = new inputsource ( reader ) ; saxparserfactory factory = saxparserfactory . newinstance ( ) ; saxparser parser = factory . newsaxparser ( ) ; parser . parse ( source , h ) ; } catch ( exception e ) { if ( trace . error ) e . printstacktrace ( ) ; compilermessage c = new couldnotcreate ( _str , e . getmessage ( ) ) ; threadlocaltoolkit . log ( c ) ; throw c ; } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( ioexception ioe ) { } } if ( reader != null ) { try { reader . close ( ) ; } catch ( ioexception ioe ) { } } } }	reads the overviews_base . xml from the templates folder and creates a temporary overviews . xml in the output folder.
public createnewnoteintentbuilder addtags ( @ nullable arraylist < string > tags ) { arraylist < string > list = margs . getstringarraylist ( evernoteintent . extra_tag_name_list ) ; if ( list == null ) { list = tags ; } else if ( tags != null ) { list . addall ( tags ) ; } return settags ( list ) ; }	adds more tags . any existing tags aren ' t overwritten .
private remoteoperationresult refreshsharesforfolder ( owncloudclient client ) { remoteoperationresult result = null ; getremotesharesforfileoperation operation = new getremotesharesforfileoperation ( mlocalfolder . getremotepath ( ) , _bool , _bool ) ; result = operation . execute ( client ) ; if ( result . issuccess ( ) ) { arraylist < ocshare > shares = new arraylist < ocshare > ( ) ; for ( object obj : result . getdata ( ) ) { shares . add ( ( ocshare ) obj ) ; } mstoragemanager . savesharesinfolder ( shares , mlocalfolder ) ; } return result ; }	syncs the share resources for the files contained in the folder refreshed ( children , not deeper descendants ) .
public double dist ( math_vector other ) { double distx = this . x - other . x ; double disty = this . y - other . y ; return math . sqrt ( distx * distx + disty * disty ) ; }	calculate each vector ' s distance.
public static string parsestring ( string value ) { if ( ( value . startswith ( _str ) ) && ( value . endswith ( _str ) ) || ( value . startswith ( _str ) ) && ( value . endswith ( _str ) ) ) { if ( value . length ( ) > _num ) { if ( value . indexof ( _str ) != - _num ) { return unescape ( value . substring ( _num , value . length ( ) - _num ) ) ; } return value . substring ( _num , value . length ( ) - _num ) ; } } throw new illegalargumentexception ( _str + value + _str ) ; }	parse the string literal consisting of text between double - quotes or single - quotes .
private void definedesktoppanes ( uidefaults d ) { d . put ( _str , new coloruiresource ( _num ) ) ; string c = painter_prefix + _str ; string p = _str ; d . put ( p + _str , new lazypainter ( c , desktoppanepainter . which . background_enabled ) ) ; p = _str ; c = painter_prefix + _str ; d . put ( p + _str , new insetsuiresource ( _num , _num , _num , _num ) ) ; d . put ( p + _str , new lazypainter ( c , desktopiconpainter . which . background_enabled ) ) ; }	initialize the desktop pane ui settings .
objectanimator animateboundscroll ( ) { float curscroll = getstackscroll ( ) ; float newscroll = getboundedstackscroll ( curscroll ) ; if ( float . compare ( newscroll , curscroll ) != _num ) { animatescroll ( curscroll , newscroll , null ) ; } return mscrollanimator ; }	animates the stack scroll into bounds.
public intarray resize ( intarray array , long size ) { if ( array instanceof bigintarray ) { return resizeinplace ( ( bigintarray ) array , size ) ; } else { abstractarray arr = ( abstractarray ) array ; final intarray newarray = newintarray ( size , arr . clearonresize ) ; for ( long i = _num , end = math . min ( size , array . size ( ) ) ; i < end ; ++ i ) { newarray . set ( i , array . get ( i ) ) ; } array . close ( ) ; return newarray ; } }	resize the array to the exact provided size .
public static double pdf ( double x , double mu , double beta ) { final double z = ( x - mu ) / beta ; if ( x == double . negative_infinity ) { return _num ; } return math . exp ( - z - math . exp ( - z ) ) / beta ; }	pdf of gumbel distribution.
private static byte [ ] copy_buffer ( byte [ ] buffer , int soffset , int len ) { byte [ ] newdata = new byte [ len ] ; system . arraycopy ( buffer , soffset , newdata , _num , len ) ; return newdata ; }	wrapped system function arraycopy.
public sharedfscheckpointspi ( ) { dirpaths . offer ( dflt_dir_path ) ; }	initializes default directory paths .
public void pull ( final pullparams params , final progressmonitor progressmonitor ) throws ioexception { pull ( params , progressmonitor , dockerdaemonuri ) ; }	pulls docker image from registry .
public boolean isalive ( ) { if ( hassentdata ) { if ( system . currenttimemillis ( ) - lastsendtime < timeout ) return _bool ; return hasreceiveddata && lastreceivetime > lastsendtime ; } return _bool ; }	calculates whether this peer is alive : the peer is alive when the peer hasn ' t send data yet , or when data is received within the timeout after sending data .
private void removeselecteditems ( list items ) { for ( iterator iter = items . iterator ( ) ; iter . hasnext ( ) ; ) { object item = iter . next ( ) ; removehistoryitem ( item ) ; } refreshwithlastselection = _bool ; contentprovider . refresh ( ) ; }	removes selected items from history .
public static < k , v > map < k , v > of ( k k1 , v v1 , k k2 , v v2 , k k3 , v v3 , k k4 , v v4 ) { map map = of ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; map . put ( k3 , v3 ) ; map . put ( k4 , v4 ) ; return map ; }	returns map containing the given entries .
public static void disableconnectionreuseifnecessary ( ) { if ( build . version . sdk_int < build . version_codes . froyo ) { system . setproperty ( _str , _str ) ; } }	workaround for bug pre - froyo , see here for more info : http : / / android - developers.
public static long sizeof ( struct sct ) { iterator < entry < key , object > > it = sct . entryiterator ( ) ; entry < key , object > e ; long size = _num ; while ( it . hasnext ( ) ) { e = it . next ( ) ; size += sizeof . size ( e . getkey ( ) ) ; size += sizeof . size ( e . getvalue ( ) ) ; } return size ; }	return the size of given struct , size of values + keys.
@ override public boolean isenabled ( ) { if ( ( attributeselectionpanel != null ) && ! isvalueonly ( ) ) { return attributeselectionpanel . isenabled ( ) ; } else { if ( table != null ) { return table . isenabled ( ) ; } } return _bool ; }	checks if is enabled .
@ override public boolean isfactoryfortype ( object type ) { return supportedtypes . contains ( type ) || super . isfactoryfortype ( type ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
public void readcontent ( byte [ ] dst , int offset , int length ) { system . arraycopy ( content , _num , dst , offset , length ) ; }	reads this request ' s content into the destination buffer .
public static void putobjectfield ( object obj , long fieldoff , object val ) { unsafe . putobject ( obj , fieldoff , val ) ; }	stores reference value into object field .
public void onconfigurationchanged ( ) { int curfirst = pager . getcurrentscreen ( ) * page_size ; calpagesize ( ) ; int newpage = curfirst / page_size ; removeviewat ( _num ) ; afterplatformlistgot ( ) ; pager . setcurrentscreen ( newpage ) ; }	after the screen rotates , this method will be called to refresh the list of gridviews.
public list < functiondesc > listallfunctions ( ) { list < functiondesc > functions = new arraylist < functiondesc > ( ) ; for ( measuredesc m : measures ) { functions . add ( m . getfunction ( ) ) ; } return functions ; }	get all functions from each measure .
public boolean hasexplicitfield ( string fieldname ) { if ( fields . containskey ( fieldname ) ) { return _bool ; } for ( dynamicfield df : dynamicfields ) { if ( fieldname . equals ( df . getregex ( ) ) ) return _bool ; } return _bool ; }	does the schema explicitly define the specified field , i.
private static boolean instanceofany ( object o , collection < class > classes ) { for ( class c : classes ) { if ( c . isinstance ( o ) ) return _bool ; } return _bool ; }	returns true if the object ' o ' is an instance of any class in the collection.
public static iproposalcomputer newsetterattributeproposalcomputer ( contentassistrequest contentassistrequest , ijavaproject javaproject ) { idomnode node = ( idomnode ) contentassistrequest . getnode ( ) ; if ( node . getnodetype ( ) != idomnode . element_node ) { return null ; } string widgettypename = uibinderxmlmodelutilities . computequalifiedwidgettypename ( node ) ; if ( widgettypename == null ) { return null ; } string matchstring = contentassistrequest . getmatchstring ( ) ; return new setterattributeproposalcomputer ( node , widgettypename , javaproject , matchstring , contentassistrequest . getreplacementbeginposition ( ) , matchstring . length ( ) ) ; }	creates a proposal computer for widget attributes based on existing type setter methods .
public void omitall ( ) { if ( writechunk != null ) byteswritten += writechunk . position ( ) ; bytesread = byteswritten ; list . clear ( ) ; writechunk = null ; readchunk = null ; }	clears queue and moves read pointer to written pointer .
job loadpreview ( futurecallback < pair < omnibuildenvironment , omnigradlebuild > > resulthandler , list < progresslistener > listeners ) ;	loads the gradle project data required to populate the preview page .
private void refresh ( ilaunchconfiguration configuration ) { setlaunchconfiguration ( configuration ) ; try { fmodel = createclasspathmodel ( configuration ) ; } catch ( exception e ) { message = e . getmessage ( ) ; seterrormessage ( e . getmessage ( ) ) ; } fclasspathviewer . setlaunchconfiguration ( configuration ) ; fclasspathviewer . setinput ( fmodel ) ; setdirty ( _bool ) ; }	refreshes the classpath entries based on the current state of the given launch configuration .
public void computepackagefragmentroots ( iclasspathentry [ ] resolvedclasspath , objectvector accumulatedroots , hashset rootids , iclasspathentry referringentry , boolean retrieveexportedroots , map roottoresolvedentries ) throws javamodelexception { if ( referringentry == null ) { rootids . add ( rootid ( ) ) ; } for ( int i = _num , length = resolvedclasspath . length ; i < length ; i ++ ) { computepackagefragmentroots ( resolvedclasspath [ i ] , accumulatedroots , rootids , referringentry , retrieveexportedroots , roottoresolvedentries ) ; } }	returns ( local / all ) the package fragment roots identified by the given project ' s classpath.
private void init ( ) { settitle ( _str ) ; sompanel = new sompropertiespanel ( networkpanel , sompropspaneltype . create_group ) ; tablogic . add ( sompanel ) ; layoutpanel = new mainlayoutpanel ( _bool , this ) ; layoutpanel . setcurrentlayout ( somgroup . default_layout ) ; tablayout . add ( layoutpanel ) ; tabbedpane . addtab ( _str , tablogic ) ; tabbedpane . addtab ( _str , layoutpanel ) ; setcontentpane ( tabbedpane ) ; action helpaction = new showhelpaction ( sompanel . gethelppath ( ) ) ; addbutton ( new jbutton ( helpaction ) ) ; }	initializes all components used in dialog .
private string diff_linestocharsmunge ( string text , list < string > linearray , map < string , integer > linehash ) { int linestart = _num ; int lineend = - _num ; string line ; stringbuilder chars = new stringbuilder ( ) ; while ( lineend < text . length ( ) - _num ) { lineend = text . indexof ( _str , linestart ) ; if ( lineend == - _num ) { lineend = text . length ( ) - _num ; } line = text . substring ( linestart , lineend + _num ) ; linestart = lineend + _num ; if ( linehash . containskey ( line ) ) { chars . append ( string . valueof ( ( char ) ( int ) linehash . get ( line ) ) ) ; } else { linearray . add ( line ) ; linehash . put ( line , linearray . size ( ) - _num ) ; chars . append ( string . valueof ( ( char ) ( linearray . size ( ) - _num ) ) ) ; } } return chars . tostring ( ) ; }	split a text into a list of strings.
public void remove ( video video ) { videolist . remove ( video ) ; notifydatasetchanged ( ) ; }	removes a video from the adapter and notify the change .
public boolean caninvert ( ) { return _bool ; }	xbee turnouts do support inversion.
public void addallsearchables ( arraylist < ? extends searchresult > searchable ) { searchables . addall ( searchable ) ; }	add all searchable items.
public static string tostring ( final iterable < ? > iterable ) { if ( iterable instanceof collection ) { return iterable . tostring ( ) ; } else { final stringbuilder builder = new stringbuilder ( ) ; boolean firstvalue = _bool ; builder . append ( _str ) ; for ( final object value : iterable ) { if ( ! firstvalue ) { builder . append ( _str ) ; } builder . append ( value ) ; firstvalue = _bool ; } builder . append ( _str ) ; return builder . tostring ( ) ; } }	returns a string representation of the provided iterable composed of an opening square bracket , followed by each element separated by commas , and then a closing square bracket .
public static int parseint ( string text ) { return parseint ( text , _num ) ; }	parse a string to an int , returning 0 if it ' s not parsable .
@ override public void enddocument ( augmentations augs ) throws xniexception { try { if ( fdocumenthandler != null ) { fdocumenthandler . enddocument ( ) ; } if ( fcontenthandler != null ) { fcontenthandler . enddocument ( ) ; } } catch ( saxexception e ) { throw new xniexception ( e ) ; } }	the end of the document .
public string execcommand ( string command ) { stringbuilder buf = new stringbuilder ( ) ; sendwaitfor ( command , defaulttimeout , prompts , buf ) ; log . debug ( buf . tostring ( ) ) ; return cleanoutput ( buf ) ; }	expectation here is that the command is less than 80 characters and is terminated by new line !.
private void clientthreadrun ( ) throws ioexception { socketchannel channel = null ; try { log . debug ( _str , hostname , port , pending . size ( ) ) ; channel = socketchannel . open ( new inetsocketaddress ( hostname , port ) ) ; channel . configureblocking ( _bool ) ; clientthreadmainloop ( channel ) ; } finally { if ( channel != null ) { channel . close ( ) ; } if ( current != null ) { pending . offerfirst ( current ) ; current = null ; } } }	establishes a connection to the server , then runs the client thread main loop returns if connection fails or if the connection is interrupted.
@ override public pathimpl schemewalk ( string userpath , map < string , object > newattributes , string uri , int offset ) { int length = uri . length ( ) ; if ( length < _num + offset || uri . charat ( offset ) != _str || uri . charat ( _num + offset ) != _str ) throw new runtimeexception ( _str ) ; charbuffer buf = new charbuffer ( ) ; int i = _num + offset ; int ch = _num ; boolean isipv6 = _bool ; for ( ; ( i < length && ( ch = uri . charat ( i ) ) != _str && ch != _str && ! ( ch == _str && ! isipv6 ) ) ; i ++ ) { if ( ch == _str ) isipv6 = _bool ; else if ( ch == _str ) isipv6 = _bool ; buf . append ( ( char ) ch ) ; } string host = buf . tostring ( ) ; if ( host . length ( ) == _num ) throw new runtimeexception ( _str ) ; int port = _num ; if ( ch == _str ) { for ( i ++ ; i < length && ( ch = uri . charat ( i ) ) >= _str && ch <= _str ; i ++ ) { port = _num * port + uri . charat ( i ) - _str ; } } return create ( this , userpath , newattributes , host , port ) ; }	lookup the new path assuming we ' re the scheme root .
@ requestmapping ( value = _str ) public void ssodefaulttenantbindingerror ( locale locale , httpservletresponse response ) throws ioexception { logger . info ( _str + locale . tostring ( ) + _str ) ; senderror ( locale , response , _str ) ; }	handle default tenant request sent with a wrong binding.
@ override public void oncanstartvideoservicechanged ( boolean canstartvideoservice ) { log . i ( _str , _str + string . valueof ( canstartvideoservice ) ) ; if ( canstartvideoservice == _bool ) { mconversationhelper . startoutgoingvideo ( ) ; mconversationhelper . startincomingvideo ( ) ; } }	called when the video service on the established conversation can be started.
public manifest ( inputstream is ) throws ioexception { while ( is . available ( ) != _num ) { messageheader m = new messageheader ( is ) ; entries . addelement ( m ) ; } }	parse a manifest from a stream.
@ override public object readreply ( class expectedclass ) throws throwable { int tag = read ( ) ; if ( tag == _str ) return readobject ( expectedclass ) ; else if ( tag == _str ) { hashmap map = ( hashmap ) readobject ( hashmap . class ) ; throw preparefault ( map ) ; } else { stringbuilder sb = new stringbuilder ( ) ; sb . append ( ( char ) tag ) ; try { int ch ; while ( ( ch = read ( ) ) >= _num ) { sb . append ( ( char ) ch ) ; } } catch ( ioexception e ) { log . log ( level . fine , e . tostring ( ) , e ) ; } throw error ( _str + codename ( tag ) + _str + sb ) ; } }	reads a reply as an object.
public static string unexpandline ( charsequence self , int tabstop ) { stringbuilder builder = new stringbuilder ( self . tostring ( ) ) ; int index = _num ; while ( index + tabstop < builder . length ( ) ) { string piece = builder . substring ( index , index + tabstop ) ; int count = _num ; while ( ( count < tabstop ) && ( character . iswhitespace ( piece . charat ( tabstop - ( count + _num ) ) ) ) ) count ++ ; if ( count > _num ) { piece = piece . substring ( _num , tabstop - count ) + _str ; builder . replace ( index , index + tabstop , piece ) ; index = index + tabstop - ( count - _num ) ; } else index = index + tabstop ; } return builder . tostring ( ) ; }	replaces sequences of whitespaces with tabs within a line .
private void uninstall ( string rowtype ) { if ( extensionsbyrowtype . containskey ( rowtype ) ) { extensionsbyrowtype . remove ( rowtype ) ; file f = getextensionfile ( rowtype ) ; if ( f . exists ( ) ) { fileutils . deletequietly ( f ) ; } else { log . warn ( _str + rowtype ) ; } } else { log . warn ( _str + rowtype ) ; } }	uninstall extension by its unique rowtype .
public void addpropertychangelistener ( string propertyname , propertychangelistener in_pcl ) { pcsupport . addpropertychangelistener ( propertyname , in_pcl ) ; }	method for beancontextchild interface .
static final int tablesizefor ( int cap ) { int n = cap - _num ; n |= n > > > _num ; n |= n > > > _num ; n |= n > > > _num ; n |= n > > > _num ; n |= n > > > _num ; return ( n < _num ) ? _num : ( n >= maximum_capacity ) ? maximum_capacity : n + _num ; }	returns a power of two size for the given target capacity .
@ override public boolean connectionallowed ( string eventname ) { if ( ! eventname . equals ( _str ) && ! eventname . equals ( _str ) && ! eventname . equals ( _str ) && ! eventname . equals ( _str ) ) { return _bool ; } if ( m_listenee != null ) { return _bool ; } return _bool ; }	returns true if , at this time , the object will accept a connection via the named event.
protected void generateomgraphic ( omgraphic g ) { if ( g != null && g . getneedtoregenerate ( ) ) { projection proj = getprojection ( ) ; if ( proj != null ) { g . generate ( proj ) ; } else if ( debug ) { debug . output ( _str + g . getneedtoregenerate ( ) ) ; } } }	if the projection is not null , generate the omgraphic .
public void insertvariable ( ) { scriptstep variablestep = scriptstepfactory . createvariable ( getvariablekey ( ) , getvariablevalue ( ) ) ; steps . add ( getinsertindex ( ) , variablestep ) ; variablekey = _str ; variablevalue = _str ; reindexscriptsteps ( ) ; }	does something to insert a variable request into the script .
protected boolean [ ] canhandlezerotraining ( boolean nominalpredictor , boolean numericpredictor , boolean stringpredictor , boolean datepredictor , boolean relationalpredictor , boolean multiinstance , int classtype ) { print ( _str ) ; printattributesummary ( nominalpredictor , numericpredictor , stringpredictor , datepredictor , relationalpredictor , multiinstance , classtype ) ; print ( _str ) ; arraylist < string > accepts = new arraylist < string > ( ) ; accepts . add ( _str ) ; accepts . add ( _str ) ; int numtrain = _num , numtest = getnuminstances ( ) , numclasses = _num , missinglevel = _num ; boolean predictormissing = _bool , classmissing = _bool ; return runbasictest ( nominalpredictor , numericpredictor , stringpredictor , datepredictor , relationalpredictor , multiinstance , classtype , missinglevel , predictormissing , classmissing , numtrain , numtest , numclasses , accepts ) ; }	checks whether the scheme can handle zero training instances .
public static byte [ ] long2buff ( long n ) { byte [ ] bs ; bs = new byte [ _num ] ; bs [ _num ] = ( byte ) ( ( n > > _num ) & _num ) ; bs [ _num ] = ( byte ) ( ( n > > _num ) & _num ) ; bs [ _num ] = ( byte ) ( ( n > > _num ) & _num ) ; bs [ _num ] = ( byte ) ( ( n > > _num ) & _num ) ; bs [ _num ] = ( byte ) ( ( n > > _num ) & _num ) ; bs [ _num ] = ( byte ) ( ( n > > _num ) & _num ) ; bs [ _num ] = ( byte ) ( ( n > > _num ) & _num ) ; bs [ _num ] = ( byte ) ( n & _num ) ; return bs ; }	long convert to buff ( big - endian ).
final boolean trywritelock ( ) { thread current = thread . currentthread ( ) ; int c = getstate ( ) ; if ( c != _num ) { int w = exclusivecount ( c ) ; if ( w == _num || current != getexclusiveownerthread ( ) ) return _bool ; if ( w == max_count ) throw new error ( _str ) ; } if ( ! compareandsetstate ( c , c + _num ) ) return _bool ; setexclusiveownerthread ( current ) ; return _bool ; }	performs trylock for write , enabling barging in both modes.
public ioservicelistenersupport ( ioservice service ) { if ( service == null ) { throw new illegalargumentexception ( _str ) ; } this . service = service ; }	creates a new instance of the listenersupport .
private void canceleventleasedo ( long eventid , uuid leaseid ) throws unknownleaseexception { long now = system . currenttimemillis ( ) ; eventreg reg = ( eventreg ) eventbyid . get ( new long ( eventid ) ) ; if ( reg == null || reg . leaseexpiration <= now ) throw new unknownleaseexception ( ) ; deleteevent ( reg ) ; if ( reg . leaseexpiration == mineventexpiration ) concurrentobj . waiternotify ( eventnotifier ) ; }	the code that does the real work of canceleventlease .
public static boolean isvalidgday ( string value ) { string regex = _str ; if ( value . matches ( regex ) ) { return isvalidcalendarvalue ( value ) ; } else { return _bool ; } }	determines if the supplied value is a valid xsd : gday string .
protected void paint3drectlighting ( graphics2d g2 , int x , int y , int width , int height ) { g2 . setcolor ( color . white ) ; g2 . drawline ( x + _num , y + _num , x + _num , y + height - _num ) ; g2 . drawline ( x + _num , y + _num , x + width - _num , y + _num ) ; g2 . setcolor ( color . gray ) ; g2 . drawline ( x + _num , y + height - _num , x + width - _num , y + height - _num ) ; g2 . drawline ( x + width - _num , y + _num , x + width - _num , y + height - _num ) ; g2 . setcolor ( color . darkgray ) ; g2 . drawline ( x , y + height , x + width , y + height ) ; g2 . drawline ( x + width , y , x + width , y + height ) ; }	adds windows2k type 3d lighting effects.
@ deprecated public mediafile ( file f , mediafiletype type ) { this ( f . topath ( ) , type ) ; }	instantiates a new media file .
public commandline clear ( ) { line . clear ( ) ; return this ; }	removes all command line arguments .
public static string grepminusv ( string val , string pattern ) { return grepinner ( val , pattern , _bool ) ; }	like grep - v , but in java.
public dropdownpopupbuttonbuilder add ( action action ) { popupmenu . add ( action ) ; return this ; }	adds an action to the popup menu that is displayed when the button is clicked .
@ suppresslint ( _str ) private void attachimagefrommgallery ( ) { bundle condata = new bundle ( ) ; intent intent = new intent ( ) ; if ( ( mselectedgalleryitemslist . size ( ) == _num ) || ( build . version . sdk_int < build . version_codes . jelly_bean_mr2 ) ) { intent . setdata ( mselectedgalleryitemslist . get ( _num ) . mfileuri ) ; } else if ( mselectedgalleryitemslist . size ( ) > _num ) { clipdata . item firsturi = new clipdata . item ( null , null , null , mselectedgalleryitemslist . get ( _num ) . mfileuri ) ; string [ ] mimetype = { _str } ; clipdata clipdata = new clipdata ( _str , mimetype , firsturi ) ; for ( int index = _num ; index < mselectedgalleryitemslist . size ( ) ; index ++ ) { clipdata . item item = new clipdata . item ( null , null , null , mselectedgalleryitemslist . get ( index ) . mfileuri ) ; clipdata . additem ( item ) ; } intent . setclipdata ( clipdata ) ; } else { uri urisavedfromlifecycle = ( uri ) mimagepreviewimageview . gettag ( ) ; if ( null != urisavedfromlifecycle ) { intent . setdata ( urisavedfromlifecycle ) ; } } intent . putextras ( condata ) ; setresult ( result_ok , intent ) ; vectorapp . setsavedcameraimagepreview ( null ) ; finish ( ) ; }	return the taken image from the gallery to the calling activity.
public static void mkdirs ( file directory ) throws createdirectoryexception { if ( directory . exists ( ) ) { if ( directory . isdirectory ( ) ) { return ; } if ( ! directory . delete ( ) ) { throw new createdirectoryexception ( directory . getabsolutepath ( ) , new filedeleteexception ( directory . getabsolutepath ( ) ) ) ; } } if ( ! directory . mkdirs ( ) && ! directory . isdirectory ( ) ) { throw new createdirectoryexception ( directory . getabsolutepath ( ) ) ; } }	creates the specified directory , along with all parent paths if necessary.
public boolean hasdependency ( capability c ) { if ( donotcheckcapabilities ( ) ) { return _bool ; } return m_dependencies . contains ( c ) ; }	returns true if the classifier handler has a dependency for the specified capability.
private static int prefixlen ( string o1 , string o2 ) { final int l1 = o1 . length ( ) , l2 = o2 . length ( ) , l = l1 < l2 ? l1 : l2 ; int prefix = _num ; while ( prefix < l && ( o1 . charat ( prefix ) == o2 . charat ( prefix ) ) ) { prefix ++ ; } return prefix ; }	compute the length of the prefix .
@ override public void writeexternal ( objectoutput out ) throws ioexception { super . writeexternal ( out ) ; out . writedouble ( parentdistance ) ; }	calls the super method and writes the parentdistance of this entry to the specified stream .
public namedthreadfactory ( final string poolid ) { id = poolid ; }	create a new thread factory , using the specified pool id as a basis for naming each thread .
public void movelocationup ( routelocation rl ) { int sequenceid = rl . getsequenceid ( ) ; if ( sequenceid - _num <= _num ) { rl . setsequenceid ( _sequencenum + _num ) ; resequenceids ( ) ; } else { routelocation replacerl = getitembysequenceid ( sequenceid - _num ) ; if ( replacerl != null ) { replacerl . setsequenceid ( sequenceid ) ; rl . setsequenceid ( sequenceid - _num ) ; } else { resequenceids ( ) ; } } setdirtyandfirepropertychange ( listchange_changed_property , null , integer . tostring ( sequenceid ) ) ; }	places a routelocation earlier in the route .
public static string printcanopyassignments ( instances datapoints , list < long [ ] > canopyassignments ) { stringbuilder temp = new stringbuilder ( ) ; for ( int i = _num ; i < datapoints . size ( ) ; i ++ ) { temp . append ( _str + i + _str ) ; temp . append ( datapoints . instance ( i ) ) ; if ( canopyassignments != null && canopyassignments . size ( ) == datapoints . size ( ) ) { long [ ] assignments = canopyassignments . get ( i ) ; temp . append ( printsingleassignment ( assignments ) ) ; } temp . append ( _str ) ; } return temp . tostring ( ) ; }	print the supplied instances and their canopies.
public static void registerdefaultprefixes ( ) throws xmlsecurityexception { setdefaultprefix ( _str , _str ) ; setdefaultprefix ( _str , _str ) ; setdefaultprefix ( _str , _str ) ; setdefaultprefix ( _str , _str ) ; setdefaultprefix ( _str , _str ) ; setdefaultprefix ( _str , _str ) ; setdefaultprefix ( _str , _str ) ; setdefaultprefix ( _str , _str ) ; }	this method registers the default prefixes .
protected void initbporderdetails ( int c_bpartner_id , boolean forinvoice ) { log . config ( _str + c_bpartner_id ) ; keynamepair pp = new keynamepair ( _num , _str ) ; orderfield . removeactionlistener ( this ) ; orderfield . removeallitems ( ) ; orderfield . additem ( pp ) ; arraylist < keynamepair > list = loadorderdata ( c_bpartner_id , forinvoice , _bool ) ; for ( keynamepair knp : list ) orderfield . additem ( knp ) ; orderfield . setselectedindex ( _num ) ; orderfield . addactionlistener ( this ) ; dialog . pack ( ) ; initbpdetails ( c_bpartner_id ) ; }	load pbartner dependent order / invoice / shipment field .
private void writetoc ( bytebuffer datafilebuffer , toctype toctype , int entrycount , int firstentryoffset ) { datafilebuffer . putint ( toctype . identifier ) ; datafilebuffer . putint ( entrycount ) ; datafilebuffer . putlong ( firstentryoffset ) ; }	writes out a pcp mmv table - of - contents block .
public void startpart ( string contenttype , string [ ] headers ) throws ioexception { writecurrentboundary ( ) ; if ( contenttype != null ) { writestring ( mimeutils . header_content_type + _str + contenttype ) ; out . write ( crlf ) ; } for ( int i = _num ; headers != null && i < headers . length ; i ++ ) { writestring ( headers [ i ] ) ; out . write ( crlf ) ; } out . write ( crlf ) ; }	starts new mime part.
public embeddedmetaservice ( ) throws ioexception , executionexception { this ( system . getenv ( jolie_home_env ) ) ; }	creates an embedded metaservice instance , executing a jolie interpreter in the local jvm .
public int showdialog ( ) { m_result = cancel_option ; int [ ] origselected = m_list . getselectedindices ( ) ; setvisible ( _bool ) ; if ( m_result == cancel_option ) { m_list . setselectedindices ( origselected ) ; } return m_result ; }	pops up the modal dialog and waits for cancel or a selection .
public final void addalarmvalues ( final list < alarmvalueimpl > alarmvalues ) { if ( alarmvalues != null ) { for ( alarmvalueimpl alarmvalue : alarmvalues ) { if ( alarmvalue != null ) { addalarmvalue ( alarmvalue ) ; } } } }	adds the given alarm values to the transfer tag , except if an alarm with the same id id already present or , if the alarm values do not belong to the specified tag .
public string product ( properties ctx , int windowno , gridtab mtab , gridfield mfield , object value ) { integer m_product_id = ( integer ) value ; if ( m_product_id == null || m_product_id . intvalue ( ) == _num ) return _str ; if ( env . getcontextasint ( ctx , windowno , env . tab_info , _str ) == m_product_id . intvalue ( ) && env . getcontextasint ( ctx , windowno , env . tab_info , _str ) != _num ) mtab . setvalue ( _str , env . getcontextasint ( ctx , windowno , env . tab_info , _str ) ) ; else mtab . setvalue ( _str , null ) ; checkqtyavailable ( ctx , mtab , windowno , m_product_id , null ) ; return _str ; }	product modified set attribute set instance.
protected void processpacket ( simevent ev ) { cloudsim . cancelall ( getid ( ) , new predicatetype ( cloudsimtags . network_event_up ) ) ; schedule ( getid ( ) , switching_delay , cloudsimtags . network_event_up ) ; pktlist . add ( ( networkpacket ) ev . getdata ( ) ) ; }	process a received packet .
public void addchild ( controller controller ) { if ( children == null ) children = new arraylist < controller > ( ) ; children . add ( controller ) ; controller . parent = this ; }	add a child controller .
protected boolean checkturnoutsinsection ( section s , int seqnum , section nextsection , activetrain at , layouteditor le , section prevsection ) { return turnoututil ( s , seqnum , nextsection , at , le , _bool , _bool , prevsection ) ; }	check that all turnouts are correctly set for travel in the designated section to the next section.
protected string instancetomatlab ( instance inst ) { stringbuffer result ; int i ; result = new stringbuffer ( ) ; for ( i = _num ; i < inst . numattributes ( ) ; i ++ ) { if ( i > _num ) { result . append ( ( m_usetabs ? _str : _str ) ) ; } result . append ( m_format . format ( inst . value ( i ) ) ) ; } return result . tostring ( ) ; }	turns the instance into a matlab row .
private static double distance ( problem problem , solution a , solution b , double power ) { double distance = _num ; for ( int i = _num ; i < problem . getnumberofobjectives ( ) ; i ++ ) { distance += math . pow ( math . abs ( a . getobjective ( i ) - b . getobjective ( i ) ) , power ) ; } return math . pow ( distance , _num / power ) ; }	returns the distance in objective space between the two solutions .
private void printrainbowuser ( user user , string username , boolean action , specialcolor type , string id ) { simpleattributeset userstyle = new simpleattributeset ( styles . nick ( ) ) ; userstyle . addattribute ( attribute . is_user_message , _bool ) ; userstyle . addattribute ( attribute . user , user ) ; if ( id != null ) { userstyle . addattribute ( attribute . id , id ) ; } int length = username . length ( ) ; if ( action ) { print ( _str , styles . nick ( ) ) ; } for ( int i = _num ; i < length ; i ++ ) { color c ; if ( type == specialcolor . rainbow ) { c = makerainbowcolor ( i , length ) ; } else { c = makegoldcolor ( i , length ) ; } styleconstants . setforeground ( userstyle , c ) ; print ( username . substring ( i , i + _num ) , userstyle ) ; } }	output the username in rainbow colors.
public void notifyaddressthrottlefound ( dccthrottle t ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str ) ; } mthrottle = t ; setenabled ( _bool ) ; mthrottle . addpropertychangelistener ( this ) ; setfnbuttons ( ) ; }	get notification that a throttle has been found as we requested.
public boolean verify ( ) throws missingresourcefailureexception , xmlsecurityexception { return super . verifyreferences ( _bool ) ; }	tests core validation process.
public openidprompt ( string prompt ) { originalvalue = prompt ; if ( isempty ( prompt ) ) { prompts = collections . emptyset ( ) ; } else { prompts = stringtoset ( prompt . tolowercase ( ) ) ; } }	constructs a new openidprompt instance from the given prompt string.
private static boolean calculateisfailure ( ) { int randomvalue = random . nextint ( _num ) + _num ; return randomvalue <= error_pct ; }	randomly determine whether this call should result in a network failure .
private int checkuserlink ( spannablestringbuilder out , string in , int start ) { int pos = start + _num ; stringbuilder temp = new stringbuilder ( ) ; string targetstring = in . substring ( pos , math . min ( in . length ( ) , pos + _num ) ) ; for ( int i = _num ; i < targetstring . length ( ) ; i ++ ) { char c = targetstring . charat ( i ) ; if ( ( c >= _str && c <= _str ) || ( c >= _str && c <= _str ) || ( c >= _str && c <= _str ) || c == _str ) { temp . append ( c ) ; } else { break ; } } string username = temp . tostring ( ) ; if ( username . length ( ) < _num || username . equalsignorecase ( _str ) ) { return - _num ; } out . append ( username ) ; return pos + username . length ( ) - _num ; }	change this should review account . java.
public void clear ( ) { marraylist . clear ( ) ; }	clear out the adapter .
public void test_commontest_01 ( ) { sslcontextspiimpl ssl = new sslcontextspiimpl ( ) ; try { sslsessioncontext slsc = ssl . enginegetclientsessioncontext ( ) ; fail ( _str ) ; } catch ( runtimeexception re ) { string str = re . getmessage ( ) ; if ( ! str . equals ( _str ) ) fail ( _str + str ) ; } catch ( exception e ) { fail ( _str + e + _str ) ; } try { sslsessioncontext slsc = ssl . enginegetserversessioncontext ( ) ; fail ( _str ) ; } catch ( runtimeexception re ) { string str = re . getmessage ( ) ; if ( ! str . equals ( _str ) ) fail ( _str + str ) ; } catch ( exception e ) { fail ( _str + e + _str ) ; } try { sslserversocketfactory sssf = ssl . enginegetserversocketfactory ( ) ; fail ( _str ) ; } catch ( runtimeexception re ) { string str = re . getmessage ( ) ; if ( ! str . equals ( _str ) ) fail ( _str + str ) ; } catch ( exception e ) { fail ( _str + e + _str ) ; } try { sslsocketfactory ssf = ssl . enginegetsocketfactory ( ) ; fail ( _str ) ; } catch ( runtimeexception re ) { string str = re . getmessage ( ) ; if ( ! str . equals ( _str ) ) fail ( _str + str ) ; } catch ( exception e ) { fail ( _str + e + _str ) ; } }	sslcontextspi # enginegetclientsessioncontext ( ) sslcontextspi # enginegetserversessioncontext ( ) sslcontextspi # enginegetserversocketfactory ( ) sslcontextspi # enginegetsocketfactory ( ) verify exception when sslcontextspi object wasn ' t initialiazed .
public static classdescriptor createclassdescriptorfromresourcename ( string resourcename ) { if ( ! isclassresource ( resourcename ) ) { throw new illegalargumentexception ( _str + resourcename + _str ) ; } return createclassdescriptor ( resourcename . substring ( _num , resourcename . length ( ) - _num ) ) ; }	create a class descriptor from a resource name .
public static void show ( final window parent , final string content ) { final clogfiledialog dialog = new clogfiledialog ( parent , content ) ; guihelper . centerchildtoparent ( parent , dialog , _bool ) ; dialog . setvisible ( _bool ) ; }	shows a dialog that displays the content of the binnavi log file .
protected void endnode ( node node ) throws org . xml . sax . saxexception { switch ( node . getnodetype ( ) ) { case node . document_node : break ; case node . document_type_node : serializedoctype ( ( documenttype ) node , _bool ) ; break ; case node . element_node : serializeelement ( ( element ) node , _bool ) ; break ; case node . cdata_section_node : break ; case node . entity_reference_node : serializeentityreference ( ( entityreference ) node , _bool ) ; break ; default : } }	end processing of given node.
public createwindowclause addview ( string namespace , string name ) { views . add ( view . create ( namespace , name ) ) ; return this ; }	adds an un - parameterized view to the named window .
public int size ( ) { return set . size ( ) ; }	returns the number of keys in this set .
public void associateconnection ( object connection ) throws resourceexception { if ( ! connectionsharing ) disassociateconnections ( ) ; try { final fbconnection abstractconnection = ( fbconnection ) connection ; abstractconnection . setmanagedconnection ( this ) ; connectionhandles . add ( abstractconnection ) ; } catch ( classcastexception cce ) { throw new fbresourceexception ( _str , cce ) ; } }	used by the container to change the association of an application - level connection handle with a managedconneciton instance.
chronolocaldatetime < d > tolocaldatetime ( ) ;	gets the local date - time part of this date - time.
private void save ( ) { try { fileutils . write ( new file ( jarname + _str ) , text ) ; } catch ( ioexception e ) { joptionpane . showmessagedialog ( null , e . getmessage ( ) , _str , joptionpane . error_message ) ; } }	saves the scan to the filesystem .
private static void assertnotempty ( string message , string string ) { assertnotnull ( message , string ) ; assertfalse ( message , string . equals ( _str ) ) ; }	asserts that a string is non - null and non - empty.
private void generateentityconfig ( managedentityconfig config ) throws saxexception { string host = config . gethost ( ) ; if ( host != null ) { handler . startelement ( _str , host , host , empty ) ; handler . characters ( host . tochararray ( ) , _num , host . length ( ) ) ; handler . endelement ( _str , host , host ) ; } string remotecommand = config . getremotecommand ( ) ; if ( remotecommand != null ) { handler . startelement ( _str , remote_command , remote_command , empty ) ; handler . characters ( remotecommand . tochararray ( ) , _num , remotecommand . length ( ) ) ; handler . endelement ( _str , remote_command , remote_command ) ; } string workingdirectory = config . getworkingdirectory ( ) ; if ( workingdirectory != null ) { handler . startelement ( _str , working_directory , working_directory , empty ) ; handler . characters ( workingdirectory . tochararray ( ) , _num , workingdirectory . length ( ) ) ; handler . endelement ( _str , working_directory , working_directory ) ; } string productdirectory = config . getproductdirectory ( ) ; if ( productdirectory != null ) { handler . startelement ( _str , product_directory , product_directory , empty ) ; handler . characters ( productdirectory . tochararray ( ) , _num , productdirectory . length ( ) ) ; handler . endelement ( _str , product_directory , product_directory ) ; } }	generates xml for attributes common to all managed entities .
public void appendline ( charsequence line ) { lines . add ( line ) ; }	append the responseline to the smtpresponse.
public static void registernewaggregationfunction ( string name , class < ? extends aggregationfunction > clazz , aggregationfunctionmetadataprovider metadataprovider ) { aggreation_functions . put ( name , clazz ) ; aggregation_functions_meta_data_provider . put ( name , metadataprovider ) ; }	with this method extensions might register additional aggregation functions if needed .
private byte [ ] buildfileauthtag ( ) throws fileencryptionexception { secretkey key = backencrandomaccessfile . sharekey ; if ( key == null || key . getencoded ( ) . length == _num ) { throw new fileencryptionexception ( _str ) ; } else { authtaghmac . reset ( ) ; keyparameter keyparameter = new keyparameter ( key . getencoded ( ) ) ; authtaghmac . init ( keyparameter ) ; } if ( ataglist . size ( ) == _num ) { throw new fileencryptionexception ( _str ) ; } else { for ( int i = _num ; i < ataglist . size ( ) ; i ++ ) { byte [ ] curchunktag = ataglist . get ( i ) ; if ( ( curchunktag == null ) || ( curchunktag . length != chunk_auth_tag_length ) ) { throw new fileencryptionexception ( _str + i ) ; } else { authtaghmac . update ( curchunktag , _num , chunk_auth_tag_length ) ; } } byte [ ] tmp = new byte [ auth_tag_size ] ; authtaghmac . dofinal ( tmp , _num ) ; return tmp ; } }	builds and returns the root authentication tag.
public void updatedata ( mapelement mapelement ) { namelabel . settext ( mapelement . getname ( ) ) ; pinnedcheckbox . setselected ( mapelement . ispinned ( ) ) ; }	map element was renamed.
public int dofinal ( byte [ ] out , int outoff ) throws datalengthexception , illegalstateexception , invalidciphertextexception { try { int resultlen = _num ; if ( outoff + bufoff > out . length ) { throw new outputlengthexception ( _str ) ; } if ( bufoff != _num ) { if ( ! partialblockokay ) { throw new datalengthexception ( _str ) ; } cipher . processblock ( buf , _num , buf , _num ) ; resultlen = bufoff ; bufoff = _num ; system . arraycopy ( buf , _num , out , outoff , resultlen ) ; } return resultlen ; } finally { reset ( ) ; } }	process the last block in the buffer .
public priorityqueue ( int initialcapacity , comparator < ? super e > comparator ) { if ( initialcapacity < _num ) { throw new illegalargumentexception ( ) ; } elements = newelementarray ( initialcapacity ) ; this . comparator = comparator ; }	constructs a priority queue with the specified capacity and comparator .
public void readdata ( datainput input ) throws ioexception { readreference = input . readunsignedshort ( ) ; readcount = input . readunsignedshort ( ) ; writereference = input . readunsignedshort ( ) ; writecount = input . readunsignedshort ( ) ; int bytecount = input . readunsignedbyte ( ) ; if ( nonworddatahandler == null ) { byte buffer [ ] = new byte [ bytecount ] ; input . readfully ( buffer , _num , bytecount ) ; int offset = _num ; registers = new register [ writecount ] ; for ( int register = _num ; register < writecount ; register ++ ) { registers [ register ] = new simpleregister ( buffer [ offset ] , buffer [ offset + _num ] ) ; offset += _num ; } } else { nonworddatahandler . readdata ( input , writereference , writecount ) ; } }	readdata - - read the values of the registers to be written , along with the reference and count for the registers to be read .
private boolean istouchinsidelist ( motionevent ev ) { float x = ev . getx ( ) - mlistview . getx ( ) ; float y = ev . gety ( ) - mlistview . gety ( ) ; if ( x < _num || x > mlistview . getwidth ( ) || y < _num || y > mlistview . getheight ( ) ) { return _bool ; } return _bool ; }	checks whether a touch event is inside of the bounds of the mode list .
public static final void centerchildtoparent ( final component parent , final component child , final boolean bstayonscreen ) { int x = ( parent . getx ( ) + ( parent . getwidth ( ) / _num ) ) - ( child . getwidth ( ) / _num ) ; int y = ( parent . gety ( ) + ( parent . getheight ( ) / _num ) ) - ( child . getheight ( ) / _num ) ; if ( bstayonscreen ) { final toolkit tk = toolkit . getdefaulttoolkit ( ) ; final dimension ss = new dimension ( tk . getscreensize ( ) ) ; if ( ( x + child . getwidth ( ) ) > ss . getwidth ( ) ) { x = ( int ) ( ss . getwidth ( ) - child . getwidth ( ) ) ; } if ( ( y + child . getheight ( ) ) > ss . getheight ( ) ) { y = ( int ) ( ss . getheight ( ) - child . getheight ( ) ) ; } if ( x < _num ) { x = _num ; } if ( y < _num ) { y = _num ; } } child . setlocation ( x , y ) ; }	centers the child component relative to its parent component .
public boolean isconnecting ( ) { return start != null && preview != null && preview . isvisible ( ) ; }	returns true if the source terminal has been clicked and a new connection is currently being previewed .
public protectedproperties ( properties props ) { enumeration < ? > propenum = props . propertynames ( ) ; while ( propenum . hasmoreelements ( ) ) { string propname = ( string ) propenum . nextelement ( ) ; string propvalue = props . getproperty ( propname ) ; super . setproperty ( propname , propvalue ) ; } closed = _bool ; }	creates a set of protected properties from a set of normal ones .
public boolean isempty ( ) { return itemlist . isempty ( ) ; }	return whether or not the worklist is empty .
private static void fixnumericbyteorder ( byte [ ] bytes ) { for ( int i = _num ; i < bytes . length ; i += _num ) { byteutil . swap4bytes ( bytes , i ) ; } }	swaps the bytes of the given numeric in place .
public synchronized boolean hasscope ( ) { return ! scopestack . isempty ( ) ; }	returns true if this thread is executing inside a scope.
private boolean checkattributechanged ( string existing , string current ) { if ( existing == null && current == null ) { return _bool ; } if ( ( existing == null ) ^ ( current == null ) ) { return _bool ; } return ( ! existing . equalsignorecase ( current ) ) ; }	check that a single pair of attributes changed .
public boolean isempty ( ) { return count ( ) == _num ; }	checks if consistent hash has nodes added to it .
@ override public void addtablemodellistener ( tablemodellistener l ) { m_listeners . add ( l ) ; }	adds a listener to the list that is notified each time a change to data model occurs.
private static url [ ] pathtourls ( string path ) throws malformedurlexception { synchronized ( pathtourlscache ) { object [ ] v = pathtourlscache . get ( path ) ; if ( v != null ) { return ( ( url [ ] ) v [ _num ] ) ; } } stringtokenizer st = new stringtokenizer ( path ) ; url [ ] urls = new url [ st . counttokens ( ) ] ; for ( int i = _num ; st . hasmoretokens ( ) ; i ++ ) { urls [ i ] = new url ( st . nexttoken ( ) ) ; } synchronized ( pathtourlscache ) { pathtourlscache . put ( path , new object [ ] { urls , new softreference < string > ( path ) } ) ; } return urls ; }	convert a string containing a space - separated list of urls into a corresponding array of url objects , throwing a malformedurlexception if any of the urls are invalid .
boolean performwork ( taskmanager . task who , object param ) throws jobexception { integer tmp = null ; synchronized ( tasks ) { tmp = ( integer ) tasks . get ( who ) ; } if ( tmp == null ) throw new unknowntaskexception ( ) ; int rank = tmp . intvalue ( ) ; synchronized ( attempts ) { attempts [ rank ] ++ ; } object result = dowork ( who , param ) ; if ( result == null ) return _bool ; try { reportdone ( who , result ) ; } catch ( unknowntaskexception e ) { } catch ( partialresultexception e ) { } catch ( jobexception e ) { } return _bool ; }	used by a task to do a piece of work and record the number of attempts .
public list < order > loadalldeepfromcursor ( cursor cursor ) { int count = cursor . getcount ( ) ; list < order > list = new arraylist < order > ( count ) ; if ( cursor . movetofirst ( ) ) { if ( identityscope != null ) { identityscope . lock ( ) ; identityscope . reserveroom ( count ) ; } try { do { list . add ( loadcurrentdeep ( cursor , _bool ) ) ; } while ( cursor . movetonext ( ) ) ; } finally { if ( identityscope != null ) { identityscope . unlock ( ) ; } } } return list ; }	reads all available rows from the given cursor and returns a list of new imageto objects .
public static boolean isvalidauthtype ( string authtype ) { log . debug ( _str ) ; if ( authtype != null ) { if ( ! authtype . isempty ( ) ) { if ( authtype . equalsignorecase ( ldapauthbase . ldap_auth_type_simple ) ) return _bool ; if ( authtype . equalsignorecase ( ldapauthbase . ldap_auth_type_none ) ) return _bool ; } } return _bool ; }	determine if is a supported auth type.
public annotationmember ( string name , object val , class type , method m ) { this ( name , val ) ; definingmethod = m ; if ( type == int . class ) { elementtype = integer . class ; } else if ( type == boolean . class ) { elementtype = boolean . class ; } else if ( type == char . class ) { elementtype = character . class ; } else if ( type == float . class ) { elementtype = float . class ; } else if ( type == double . class ) { elementtype = double . class ; } else if ( type == long . class ) { elementtype = long . class ; } else if ( type == short . class ) { elementtype = short . class ; } else if ( type == byte . class ) { elementtype = byte . class ; } else { elementtype = type ; } }	creates the completely defined element .
public void unregisterpreferencechangelistener ( preferencechangelistener preferencechangelistener ) { mlisteners . remove ( preferencechangelistener ) ; }	removes the listener from receiving callbacks for any preference change event.
public static string join ( string separator , list < ? > elements ) { if ( elements == null || elements . size ( ) == _num ) { return _str ; } stringbuffer sb = new stringbuffer ( elements . size ( ) * _num ) ; int i = _num ; for ( object elem : elements ) { if ( i ++ > _num ) { sb . append ( separator ) ; } sb . append ( format ( elem ) ) ; } return sb . tostring ( ) ; }	returns a string containing all elements concatenated by a specified separator .
public boolean removetrace ( final trace trace ) { boolean result = tracelist . remove ( trace ) ; if ( result ) { remove ( trace ) ; revalidate ( ) ; } return result ; }	remove a trace from the plot area .
private void updaterandomvalues ( ) { for ( int i = _num ; i < mblocknumber ; i ++ ) { for ( int j = _num ; j < default_number_random_values ; j ++ ) { mblockvalues [ i ] [ j ] = mrandom . nextfloat ( ) ; if ( mblockvalues [ i ] [ j ] < _num ) { mblockvalues [ i ] [ j ] = _num ; } } } }	create random values to be picked when creating a new dynamics.
static private string byte_min_minus ( ) { long tempvalue = byte . min_value - _num ; return string . valueof ( tempvalue ) ; }	get the min value minus one for a byte.
public doubleaccumulator ( doublebinaryoperator accumulatorfunction , double identity ) { this . function = accumulatorfunction ; base = this . identity = double . doubletorawlongbits ( identity ) ; }	creates a new instance using the given accumulator function and identity element .
public static void bitmaptomat ( bitmap bmp , mat mat , boolean unpremultiplyalpha ) { if ( bmp == null ) throw new java . lang . illegalargumentexception ( _str ) ; if ( mat == null ) throw new java . lang . illegalargumentexception ( _str ) ; nbitmaptomat2 ( bmp , mat . nativeobj , unpremultiplyalpha ) ; }	converts android bitmap to opencv mat.
public static void sendmail ( context mcontext , string mailid ) { uri uri = uri . parse ( _str + mailid ) ; intent intent = new intent ( intent . action_sendto , uri ) ; mcontext . startactivity ( intent ) ; }	use for sending mail to any id.
public void push ( @ notnull statusnotification notification ) { stack . push ( notification ) ; }	push notification to message stack .
public void onpaintactions ( viewtransform transform , graphics2d g ) { if ( ! misselected ) { return ; } if ( mcolorset == null ) { return ; } if ( mwidget . getvisibility ( ) == constraintwidget . gone ) { return ; } if ( ! mshowresizehandles ) { return ; } if ( ! mshowactions ) { return ; } if ( mwidgetactions . size ( ) == _num ) { return ; } int l = transform . getswingfx ( mwidget . getdrawx ( ) ) ; int t = transform . getswingfy ( mwidget . getdrawy ( ) ) ; int h = transform . getswingdimension ( mwidget . getheight ( ) ) ; int x = l ; int y = t + h + connectiondraw . connection_anchor_size + _num ; g . setcolor ( mcolorset . getselectedframes ( ) ) ; for ( widgetaction action : mwidgetactions ) { action . update ( ) ; if ( ! action . isvisible ( ) ) { continue ; } action . onpaint ( transform , g , x , y ) ; x += action_size + connectiondraw . connection_anchor_size ; } }	paint the actions ( if any ) of this widget.
@ override public lookup createglobalcontext ( ) { if ( proxylookup == null ) { logger . config ( _str ) ; projectlookup = new abstractlookup ( content ) ; proxylookup = new proxylookup ( globalcontextlookup , projectlookup ) ; } return proxylookup ; }	returns a proxylookup that adds the current project instance to the global selection returned by utilities.
public void write ( byte [ ] bytes ) throws ioexception { flushbits ( ) ; if ( bytes != null && bytes . length > _num ) { out . write ( bytes ) ; byteswritten += bytes . length ; } }	write the given bytes to the output stream.
public static mutablelist < string > chunk ( string string , int size ) { if ( size <= _num ) { throw new illegalargumentexception ( _str + size ) ; } int length = string . length ( ) ; if ( length == _num ) { return fastlist . newlist ( ) ; } mutablelist < string > result = fastlist . newlist ( ( length + size - _num ) / size ) ; int startoffset = _num ; while ( startoffset < length ) { result . add ( string . substring ( startoffset , math . min ( startoffset + size , length ) ) ) ; startoffset += size ; } return result ; }	partitions string in fixed size chunks .
public void removeim ( imentity im ) { ims . remove ( im ) ; }	removes the given im from this user.
public languagesetting ( option opt ) { elem = null ; name = opt . getlanguage ( ) ; string [ ] suffixarray = opt . getsuffixes ( ) ; stringbuffer strbuf = new stringbuffer ( ) ; for ( int i = _num ; i < suffixarray . length ; i ++ ) { strbuf . append ( suffixarray [ i ] ) ; if ( i != suffixarray . length - _num ) strbuf . append ( _str ) ; } this . suffixes = strbuf . tostring ( ) ; minmatchlen = opt . getminimummatchlength ( ) ; clustertype = opt . getclustertype ( ) ; readsubdirs = opt . isreadsubdirs ( ) ; storematches = opt . getstorematches ( ) ; }	constructs an element - less languagesetting object out of a option object . the set methods may not be used for the resulting object !.
private double calcutil4performing ( final double typduration , final double actualduration ) { return _num * marginalutilperformingsec + marginalutilperformingsec * typduration * math . log ( actualduration / typduration ) ; }	only true if all activities have same priority.
public void clearallcache ( ) { clearmemorycache ( ) ; clearstoragecache ( ) ; }	clears the caches for this cache object.
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str + _str , _str , _num , _str ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public void addnotify ( ) { super . addnotify ( ) ; if ( textarea != null ) { l . install ( textarea ) ; } updatecellwidths ( ) ; updatecellheights ( ) ; }	overridden to set width of this component correctly when we are first displayed ( as keying off of the rtextarea gives us ( 0 , 0 ) when it isn ' t yet displayed .
@ description ( summary = _str ) public void maveninstalllocal ( ) { jarmvstore ( ) ; string pom = new string ( readfile ( new file ( _str ) ) ) ; pom = replaceall ( pom , _str , _str ) ; writefile ( new file ( _str ) , pom . getbytes ( ) ) ; execscript ( _str , args ( _str , _str , _str + getjarsuffix ( ) , _str , _str , _str , _str ) ) ; jar ( ) ; pom = new string ( readfile ( new file ( _str ) ) ) ; pom = replaceall ( pom , _str , _str ) ; writefile ( new file ( _str ) , pom . getbytes ( ) ) ; execscript ( _str , args ( _str , _str , _str + getjarsuffix ( ) , _str , _str , _str , _str ) ) ; }	this will build a ' snapshot ' h2.
public static boolean isdtogetter ( method method ) { if ( method . isannotationpresent ( delegateto . class ) ) { return _bool ; } if ( method . getparametertypes ( ) . length > _num ) { return _bool ; } string methodname = method . getname ( ) ; return methodname . startswith ( _str ) || ( methodname . startswith ( _str ) && ( ( method . getreturntype ( ) == boolean . class || method . getreturntype ( ) == boolean . class ) ) ) ; }	check is specified method is dto getter .
protected list < videodto > extractvideosfromcursor ( cursor cursor , int offset , int limit ) { list < videodto > videos = new arraylist < > ( ) ; int count = _num ; int begin = offset > _num ? offset : _num ; if ( cursor . movetoposition ( begin ) ) { do { videodto video = extractonevideofromcursor ( cursor ) ; videos . add ( video ) ; count ++ ; if ( limit > _num && count > limit ) { break ; } } while ( cursor . movetonext ( ) ) ; } cursor . close ( ) ; return videos ; }	extract a list of videodto from current cursor with the given offset and limit .
private static void computenextccwedges ( node node , long label ) { directededgestar destar = node . getoutedges ( ) ; polygonizedirectededge firstoutde = null ; polygonizedirectededge previnde = null ; list edges = destar . getedges ( ) ; for ( int i = edges . size ( ) - _num ; i >= _num ; i -- ) { polygonizedirectededge de = ( polygonizedirectededge ) edges . get ( i ) ; polygonizedirectededge sym = ( polygonizedirectededge ) de . getsym ( ) ; polygonizedirectededge outde = null ; if ( de . getlabel ( ) == label ) outde = de ; polygonizedirectededge inde = null ; if ( sym . getlabel ( ) == label ) inde = sym ; if ( outde == null && inde == null ) continue ; if ( inde != null ) { previnde = inde ; } if ( outde != null ) { if ( previnde != null ) { previnde . setnext ( outde ) ; previnde = null ; } if ( firstoutde == null ) firstoutde = outde ; } } if ( previnde != null ) { assert . istrue ( firstoutde != null ) ; previnde . setnext ( firstoutde ) ; } }	computes the next edge pointers going ccw around the given node , for the given edgering label . this algorithm has the effect of converting maximal edgerings into minimal edgerings.
@ override public boolean equals ( object other ) { if ( other instanceof intarraywrapper ) { return arrays . equals ( data , ( ( intarraywrapper ) other ) . data ) ; } return _bool ; }	this method will be used check to arraywrapper object is equal or not.
public static datetime todatesimple ( string str , timezone timezone ) throws pageexception { datetime dt = todatesimple ( str , converting_type_offset , _bool , timezone , null ) ; if ( dt == null ) throw new expressionexception ( _str + str + _str ) ; return dt ; }	converts a object to a datetime object , returns null if invalid string.
public boolean contains ( song s ) { return msongs . contains ( s ) ; }	returns whether or not this adapter contains the provided song.
private boolean zzrefill ( ) throws java . io . ioexception { if ( zzstartread > _num ) { zzendread += zzfinalhighsurrogate ; zzfinalhighsurrogate = _num ; system . arraycopy ( zzbuffer , zzstartread , zzbuffer , _num , zzendread - zzstartread ) ; zzendread -= zzstartread ; zzcurrentpos -= zzstartread ; zzmarkedpos -= zzstartread ; zzstartread = _num ; } if ( zzcurrentpos >= zzbuffer . length - zzfinalhighsurrogate ) { char newbuffer [ ] = new char [ zzbuffer . length * _num ] ; system . arraycopy ( zzbuffer , _num , newbuffer , _num , zzbuffer . length ) ; zzbuffer = newbuffer ; zzendread += zzfinalhighsurrogate ; zzfinalhighsurrogate = _num ; } int requested = zzbuffer . length - zzendread ; int numread = zzreader . read ( zzbuffer , zzendread , requested ) ; if ( numread == _num ) { throw new java . io . ioexception ( _str ) ; } if ( numread > _num ) { zzendread += numread ; if ( numread == requested ) { if ( character . ishighsurrogate ( zzbuffer [ zzendread - _num ] ) ) { -- zzendread ; zzfinalhighsurrogate = _num ; } } return _bool ; } return _bool ; }	refills the input buffer .
public int addpadding ( byte [ ] in , int inoff ) { byte code = ( byte ) ( in . length - inoff ) ; while ( inoff < in . length - _num ) { if ( random == null ) { in [ inoff ] = _num ; } else { in [ inoff ] = ( byte ) random . nextint ( ) ; } inoff ++ ; } in [ inoff ] = code ; return code ; }	add the pad bytes to the passed in block , returning the number of bytes added .
public static long makelong ( string s ) { if ( wwutil . isempty ( s ) ) { return null ; } try { return long . valueof ( s ) ; } catch ( numberformatexception e ) { return null ; } }	parses a string to a long value if the string can be parsed as a long.
private void verifyblocksnapshotmigration ( ) throws exception { log . info ( _str ) ; iterator < blocksnapshot > blocksnapshotitr = _dbclient . queryiterativeobjects ( blocksnapshot . class , blocksnapshoturis ) ; list < blockobject > blockobjects = new arraylist < blockobject > ( ) ; while ( blocksnapshotitr . hasnext ( ) ) { blockobjects . add ( blocksnapshotitr . next ( ) ) ; } verifyblockobjects ( blockobjects ) ; }	verify the blockmirror objects have been migrated correctly .
public static string edgetypetostring ( @ type int edgetype ) { switch ( edgetype ) { case fall_through_edge : return _str ; case ifcmp_edge : return _str ; case switch_edge : return _str ; case switch_default_edge : return _str ; case jsr_edge : return _str ; case ret_edge : return _str ; case goto_edge : return _str ; case return_edge : return _str ; case unhandled_exception_edge : return _str ; case handled_exception_edge : return _str ; case start_edge : return _str ; case backedge_target_edge : return _str ; case backedge_source_edge : return _str ; case exit_edge : return _str ; } throw new illegalstateexception ( _str + edgetype ) ; }	get string representing given edge type .
boolean checkgroups ( phonenumberutil util , phonenumber number , stringbuilder normalizedcandidate , string [ ] expectednumbergroups ) ;	returns true if the groups of digits found in our candidate phone number match our expectations .
private int insertunassignedgroup ( ) throws sqlexception { preparedstatement groupstatement ; final int ruleid = insertunassignedrule ( ) ; final int evaluationorder = getnumofgroups ( ) + _num ; string unassignedgroupsqlstatement = _str + groups_table + _str + _str + _str ; unassignedgroupsqlstatement = string . format ( unassignedgroupsqlstatement , unassigned_group , unassigned_group_type , unassigned_data_type , ruleid , evaluationorder ) ; groupstatement = preparestatement ( unassignedgroupsqlstatement , new string [ ] { _str } ) ; groupstatement . execute ( ) ; return getinternalid ( groupstatement ) ; }	this method returns the group internal id of the unassigned group.
public builder deleteextensionfield ( string urn , string fieldname ) { deletefields . add ( urn + _str + fieldname ) ; return this ; }	deletes the given extension field of a existing user.
@ suppresswarnings ( _str ) private list < list < groupattribute > > searchauthprovider ( filter querybuilder , string [ ] returnattributes , final long countlimit , attributesmapper mapper , validationfailurereason [ ] failurereason ) throws sizelimitexceededexception { searchcontrols groupsearchcontrols = new searchcontrols ( searchcontrols . subtree_scope , countlimit , _searchcontrols . gettimelimit ( ) , returnattributes , _searchcontrols . getreturningobjflag ( ) , _searchcontrols . getdereflinkflag ( ) ) ; list < list < groupattribute > > querygroupresults = null ; querygroupresults = safeldapsearch ( _basedn , querybuilder . encode ( ) , groupsearchcontrols , mapper , failurereason ) ; return querygroupresults ; }	searches the authentication provider ( either ldap or ad ) based on the given search controls and required return attributes and return count limit .
public depend ( pathimpl source , long lastmodified , long length ) { _source = source ; _lastmodified = lastmodified ; _length = length ; }	create a new dependency with an already known modified time and length .
public boolean hastaskoftypeinprogress ( @ notnull externalsystemtasktype type , @ notnull project project ) { string projectid = externalsystemtaskid . getprojectid ( project ) ; for ( externalsystemtaskid id : mytasksinprogress . keyset ( ) ) { if ( type . equals ( id . gettype ( ) ) && projectid . equals ( id . getideprojectid ( ) ) ) { return _bool ; } } return _bool ; }	allows to check if any task of the given type is being executed at the moment .
public final void removechangelistener ( changelistener listener ) { listeners . remove ( listener ) ; }	remove a changelistener . to be called in edt .
public static boolean containsignorecase ( string str , string query ) { if ( str != null && query != null ) { int limit = str . length ( ) - query . length ( ) + _num ; for ( int i = _num ; i < limit ; i ++ ) { if ( matchesignorecase ( str , query , i ) ) { return _bool ; } } } return _bool ; }	same as string . contains , but ignores case .
public string tomatrixstring ( ) throws exception { return tomatrixstring ( _str ) ; }	calls tomatrixstring ( ) with a default title .
public quadedge connect ( quadedge a , quadedge b ) { quadedge q = quadedge . connect ( a , b ) ; quadedges . add ( q ) ; return q ; }	creates a new quadedge connecting the destination of a to the origin of b , in such a way that all three have the same left face after the connection is complete.
public test findtest ( list < string > suitenames , string testclassname , string testname , boolean insertifmissing ) { if ( suitenames . size ( ) <= _num ) { testcase testcase = gettestcase ( testclassname ) ; return testcase . findtest ( testname , insertifmissing ) ; } else { string rootname = suitenames . remove ( _num ) ; testsuite suite = gettestsuite ( rootname ) ; return suite . findtest ( suitenames , testclassname , testname , insertifmissing ) ; } }	insert the given test result into this suite .
public job configure ( boolean issecured , string metastoreuris , string principal , string redishost , int redisport , string password , int redisdb , string inputdatabase , string inputtable , string inputfilter , string keyname , string valuename , string keyprefix , int numreducer , boolean replace , boolean pipeline , boolean flush , int commitsize , string [ ] anonfields , string exportsalt ) throws exception { this . issecured = issecured ; this . metastoreuris = metastoreuris ; this . principal = principal ; this . redishost = redishost ; this . redisport = redisport ; this . password = password ; this . redisdb = redisdb ; this . inputdatabase = inputdatabase ; this . inputtable = inputtable ; this . inputfilter = inputfilter ; this . keyname = keyname ; this . keyprefix = keyprefix ; this . valuename = valuename ; this . numreducer = numreducer ; this . replace = replace ; this . pipeline = pipeline ; this . flush = flush ; this . commitsize = commitsize ; this . anonfields = anonfields . clone ( ) ; this . exportsalt = exportsalt ; return configure ( ) ; }	this function takes all required parameters and returns a configured job object .
public static double log2 ( double a ) { return math . log ( a ) / log2 ; }	returns the logarithm of a for base 2 .
public void addsuggestions ( final @ nonnull suggestionsresult result , final @ nonnull string bucket , final @ nonnull tokensource source ) { querytoken query = result . getquerytoken ( ) ; synchronized ( mlock ) { mresultmap . put ( bucket , result ) ; set < string > waitingforbuckets = mwaitingforresults . get ( query ) ; if ( waitingforbuckets != null ) { waitingforbuckets . remove ( bucket ) ; if ( waitingforbuckets . size ( ) == _num ) { mwaitingforresults . remove ( query ) ; } } } string currenttokenstring = source . getcurrenttokenstring ( ) ; synchronized ( mlock ) { msuggestions . clear ( ) ; list < suggestible > suggestions = msuggestionslistbuilder . buildsuggestions ( mresultmap , currenttokenstring ) ; if ( suggestions . size ( ) > _num ) { msuggestions . addall ( suggestions ) ; msuggestionsvisibilitymanager . displaysuggestions ( _bool ) ; } else { hidesuggestionsifnecessary ( result . getquerytoken ( ) , source ) ; } } notifydatasetchanged ( ) ; }	add mention suggestions to a given bucket in the adapter.
public static < et extends enum < et > > enumresolver < et > constructfor ( class < et > enumcls , annotationintrospector ai ) { et [ ] enumvalues = enumcls . getenumconstants ( ) ; if ( enumvalues == null ) { throw new illegalargumentexception ( _str + enumcls . getname ( ) ) ; } hashmap < string , et > map = new hashmap < string , et > ( ) ; for ( et e : enumvalues ) { map . put ( ai . findenumvalue ( e ) , e ) ; } return new enumresolver < et > ( enumcls , enumvalues , map ) ; }	factory method for constructing resolver that maps from enum . name ( ) into enum value.
public static boolean replace ( rtextarea textarea , string tofind , string replacewith , boolean forward , boolean matchcase , boolean wholeword , boolean regex ) throws patternsyntaxexception { textarea . beginatomicedit ( ) ; try { if ( regex ) { return regexreplace ( textarea , tofind , replacewith , forward , matchcase , wholeword ) ; } makemarkanddotequal ( textarea , forward ) ; if ( find ( textarea , tofind , forward , matchcase , wholeword , _bool ) ) { textarea . replaceselection ( replacewith ) ; return _bool ; } } finally { textarea . endatomicedit ( ) ; } return _bool ; }	finds the next instance of the text / regular expression specified from the caret position.
public void presinglesignonrequest ( string hostedentityid , string idpentityid , string realm , httpservletrequest request , httpservletresponse response , authnrequest authnrequest ) throws saml2exception { return ; }	invokes before openam sends the single - sign - on request to idp .
public static imageicon createicon ( basicstroke stroke , int width , int height , boolean horizontalorientation ) { bufferedimage bigimage = new bufferedimage ( width , height , bufferedimage . type_int_argb ) ; graphics2d g = ( graphics2d ) bigimage . getgraphics ( ) ; g . setbackground ( omcolor . clear ) ; g . setpaint ( omcolor . clear ) ; g . fillrect ( _num , _num , width , height ) ; g . setpaint ( color . black ) ; g . setstroke ( stroke ) ; if ( horizontalorientation ) { g . drawline ( _num , height / _num , width , height / _num ) ; } else { g . drawline ( width / _num , _num , width / _num , height ) ; } return new imageicon ( bigimage ) ; }	given a basicstroke , create an imageicon that shows it .
public static final < t extends eobject > list < t > collectnodeswithinsamethisenvironment ( eobject root , class < t > cls ) { final list < t > result = new arraylist < > ( ) ; final treeiterator < eobject > iter = root . eallcontents ( ) ; while ( iter . hasnext ( ) ) { final eobject obj = iter . next ( ) ; if ( cls . isassignablefrom ( obj . getclass ( ) ) ) { @ suppresswarnings ( _str ) final t objcasted = ( t ) obj ; result . add ( objcasted ) ; } if ( obj instanceof thisargprovider ) { iter . prune ( ) ; } } return result ; }	root usually a function or other thisproviding environment .
protected abstract list < singlevariabledeclaration > adjustdstparams ( methoddeclaration method ) ;	returns the destination method parameters minus the async callback ( if applicable ) .
public string fullsource ( ) { if ( fullsource == null ) { fullsource = addsentencemarkers ( source ( ) ) ; } return fullsource ; }	returns a sentence with the start and stop symbols added to the beginning and the end of the sentence respectively.
private void updatedetaildata ( ) { final long start = mleftposition ; final long end = mrightposition ; final long now = mcurrenttime ; final context context = getcontext ( ) ; networkstatshistory . entry originalentry = moriginalnetworkstatshistory . getvalues ( start , end , now , null ) ; final long originaltotalbytes = originalentry . rxbytes ; moriginaltotalphrase = formatter . formatfilesize ( context , originaltotalbytes ) ; networkstatshistory . entry compressedentry = mreceivednetworkstatshistory . getvalues ( start , end , now , null ) ; final long compressedtotalbytes = compressedentry . rxbytes ; mreceivedtotalphrase = formatter . formatfilesize ( context , compressedtotalbytes ) ; float percentage = _num ; if ( originaltotalbytes > _num && originaltotalbytes > compressedtotalbytes ) { percentage = ( originaltotalbytes - compressedtotalbytes ) / ( float ) originaltotalbytes ; } mpercentreductionphrase = string . format ( _str , _num * percentage ) ; mstartdatephrase = formatdate ( context , start ) ; menddatephrase = formatdate ( context , end ) ; }	update data reduction statistics whenever the chart ' s inspection range changes.
public punctuationtrie < t > lookup ( charsequence s ) { punctuationtrie < t > t = this ; for ( int i = _num , n = s . length ( ) ; i < n ; ++ i ) { t = t . lookup ( s . charat ( i ) ) ; if ( null == t ) { break ; } } return t ; }	the descendant of this trie corresponding to the string for this trie appended with s .
private static file constructfilepaths ( string file1 , string file2 ) { file newpath ; if ( file2 . startswith ( file1 ) ) { newpath = new file ( file2 ) ; } else { newpath = new file ( file1 + _str + file2 ) ; } return newpath ; }	create a new file object from two file paths .
public string resolvetemplate ( itemplatetype templatetype , map < string , string > replacements ) throws ioexception { path path = gettemplatepath ( templatetype ) ; string template = new string ( files . readallbytes ( path ) , standardcharsets . utf_8 ) ; return insertproperties ( template , replacements ) ; }	resolves a template for the given template type and set of placeholder to replace .
public void execute ( ) { try { prep . execute ( ) ; } catch ( sqlexception e ) { throw convert ( e ) ; } }	execute the prepared statement .
private static byte [ ] unwrapcalculatedvalue ( byte [ ] data ) { if ( data . length < calc_data_offset ) { return data ; } bytebuffer buffer = pagechannel . wrap ( data ) ; buffer . position ( calc_data_len_offset ) ; int datalen = buffer . getint ( ) ; byte [ ] newdata = new byte [ math . min ( buffer . remaining ( ) , datalen ) ] ; buffer . get ( newdata ) ; return newdata ; }	grabs the real data bytes from a calculated value .
public synchronized typeinstance createinstance ( final string name , final string comment , final basetype basetype , final section section , final long sectionoffset ) throws couldntsavedataexception , couldntloaddataexception { preconditions . checknotnull ( name , _str ) ; preconditions . checkargument ( comment == null || ! comment . isempty ( ) , _str ) ; preconditions . checknotnull ( basetype , _str ) ; preconditions . checknotnull ( section , _str ) ; preconditions . checkargument ( sectionoffset >= _num , _str ) ; preconditions . checkargument ( ! instancesbyaddress . containskey ( new typeinstanceaddress ( section . getstartaddress ( ) , sectionoffset ) ) ) ; final typeinstance instance = backend . createtypeinstance ( name , comment , basetype , section , sectionoffset ) ; instancesbyaddress . put ( instance . getaddress ( ) , instance ) ; instances . add ( instance ) ; notifyinstanceadded ( instance ) ; return instance ; }	creates a new type instance instance and stores it in the database .
void showinputbox ( string message , consumer < string > resultcallback ) { showinputbox ( message , null , resultcallback ) ; }	shows input box with input field and ok button.
public void add ( field field ) { mfields . add ( field ) ; }	adds a single field to the end of this input .
public static long measuretime ( callable < object > c , int threadcnt ) throws exception { a . ensure ( threadcnt >= _num , _str ) ; long start = system . currenttimemillis ( ) ; if ( threadcnt == _num ) c . call ( ) ; else gridtestutils . runmultithreaded ( c , threadcnt , _str ) ; return system . currenttimemillis ( ) - start ; }	performs operation , measuring it ' s time .
@ override public boolean isclosed ( ) { return _isclosed . get ( ) ; }	returns true if closed .
protected statementlistnode generatedestructorbody ( context context , statementlistnode statementlist ) { model model = ( model ) value ; set < string > ids = new linkedhashset < string > ( ) ; if ( model . isdeclared ( ) ) ids . add ( model . getid ( ) ) ; collectdeclarations ( model . getsubinitializeriterator ( ) , ids ) ; nodefactory nodefactory = context . getnodefactory ( ) ; statementlistnode result = statementlist ; statementlistnode functionstatementlist = null ; for ( string id : ids ) { literalnullnode literalnull = nodefactory . literalnull ( ) ; identifiernode identifier = nodefactory . identifier ( id ) ; node expressionstatement = nodefactory . assignmentexpression ( identifier , assign_token , literalnull ) ; functionstatementlist = nodefactory . statementlist ( functionstatementlist , expressionstatement ) ; } functionsignaturenode functionsignature = nodefactory . functionsignature ( null , null ) ; functionsignature . void_anno = _bool ; identifiernode functionidentifier = nodefactory . identifier ( model . getdefinitionname ( ) + _str ) ; functioncommonnode functioncommon = nodefactory . functioncommon ( context , functionidentifier , functionsignature , functionstatementlist ) ; functioncommon . setuserdefinedbody ( _bool ) ; attributelistnode attributelist = abstractsyntaxtreeutil . generateprivateattribute ( nodefactory ) ; functionnamenode functionname = nodefactory . functionname ( tokens . empty_token , functionidentifier ) ; functiondefinitionnode functiondefinition = nodefactory . functiondefinition ( context , attributelist , functionname , functioncommon ) ; result = nodefactory . statementlist ( result , functiondefinition ) ; return result ; }	generates the destructor / reset method as necessary as required by itransientdeferredinstance rvalues .
protected synchronized void expire ( ) throws illegalmonitorstateexception { if ( owner == thread . currentthread ( ) ) { expired = _bool ; } else { throw new illegalmonitorstateexception ( _str ) ; } }	sets the status of the headtask to expired .
private stringbuffer prepareoptimizedinsertstatement ( onerowchange onerowchange ) { stringbuffer stmt ; stmt = new stringbuffer ( ) ; stmt . append ( _str ) ; stmt . append ( conn . getdatabaseobjectname ( onerowchange . getschemaname ( ) ) + _str + conn . getdatabaseobjectname ( onerowchange . gettablename ( ) ) ) ; stmt . append ( _str ) ; printcolumnspec ( stmt , onerowchange . getcolumnspec ( ) , null , null , printmode . names_only , _str ) ; stmt . append ( _str ) ; boolean firstrow = _bool ; for ( arraylist < columnval > onerowvalues : onerowchange . getcolumnvalues ( ) ) { if ( firstrow ) { firstrow = _bool ; } else stmt . append ( _str ) ; printcolumnspec ( stmt , onerowchange . getcolumnspec ( ) , null , onerowvalues , printmode . place_holder , _str ) ; stmt . append ( _str ) ; } return stmt ; }	build prepare statement for optimized inserts : < br > insert into table1 values (.
private boolean extractorqueueempty ( ) throws interruptedexception { if ( extractor . hasmoreevents ( ) ) return _bool ; else if ( blockcommitintervalmillis <= _num ) return _bool ; else { long nextcommitmillis = lastcommitmillis + blockcommitintervalmillis ; long sleepmillis = nextcommitmillis - system . currenttimemillis ( ) ; while ( sleepmillis > _num ) { thread . sleep ( _num ) ; if ( extractor . hasmoreevents ( ) ) return _bool ; sleepmillis = nextcommitmillis - system . currenttimemillis ( ) ; } return _bool ; } }	determines whether the extractor queue is currently empty.
public static void verify ( final classreader cr , final boolean dump , final printwriter pw ) { verify ( cr , null , dump , pw ) ; }	checks a given class.
public fileasynchttpresponsehandler ( context context ) { super ( ) ; this . file = gettemporaryfile ( context ) ; this . append = _bool ; this . renameifexists = _bool ; }	obtains new fileasynchttpresponsehandler against context with target being temporary file.
public static boolean iswindowopaque ( window window ) { if ( window == null ) { throw new nullpointerexception ( _str ) ; } return window . isopaque ( ) ; }	returns whether the window is opaque or translucent .
public static byte [ ] encode ( byte [ ] data , int off , int length ) { int len = ( length + _num ) / _num * _num ; bytearrayoutputstream bout = new bytearrayoutputstream ( len ) ; try { encoder . encode ( data , off , length , bout ) ; } catch ( exception e ) { throw new encoderexception ( _str + e . getmessage ( ) , e ) ; } return bout . tobytearray ( ) ; }	encode the input data producing a base 64 encoded byte array .
public double entropynmimin ( ) { return ( entropymutualinformation ( ) / math . min ( entropyfirst ( ) , entropysecond ( ) ) ) ; }	get the min - normalized mutual information ( normalized , 0 = unequal ).
public static void unregister ( closewatcher w ) { w . closeable = null ; refs . remove ( w ) ; }	unregister an object , so it is no longer tracked .
static labelnode [ ] clone ( final list < labelnode > labels , final map < labelnode , labelnode > map ) { labelnode [ ] clones = new labelnode [ labels . size ( ) ] ; for ( int i = _num ; i < clones . length ; ++ i ) { clones [ i ] = map . get ( labels . get ( i ) ) ; } return clones ; }	returns the clones of the given labels .
@ override public jettysolrrunner createjetty ( file solrhome , string datadir , string shardlist , string solrconfigoverride , string schemaoverride ) throws exception { return createproxiedjetty ( solrhome , datadir , shardlist , solrconfigoverride , schemaoverride ) ; }	overrides the parent implementation to install a socketproxy in - front of the jetty server .
public synchronized void addbatchclassifierlistener ( batchclassifierlistener cl ) { m_batchclassifierlisteners . addelement ( cl ) ; }	add a batch classifier listener.
private boolean matchandwriteoneauditlog ( bufferedwriter writer , auditlog auditlog , string keyword ) throws marshallingexcetion { try { auditlogutils . resetdesc ( auditlog , resb ) ; if ( auditlogutils . iskeywordcontained ( auditlog , keyword ) ) { if ( _count . getandincrement ( ) > _num ) { while ( ! _firstwritten . get ( ) ) { try { thread . sleep ( _num ) ; } catch ( interruptedexception e ) { _logger . warn ( _str ) ; } } writer . write ( _str + _mapper . writevalueasstring ( auditlog ) ) ; } else { writer . write ( _mapper . writevalueasstring ( auditlog ) ) ; _firstwritten . set ( _bool ) ; } return _bool ; } _logger . debug ( _str , auditlog . getdescription ( ) , keyword ) ; return _bool ; } catch ( jsongenerationexception e ) { throw new marshallingexcetion ( _str , e ) ; } catch ( jsonmappingexception e ) { throw new marshallingexcetion ( _str , e ) ; } catch ( ioexception e ) { throw new marshallingexcetion ( _str , e ) ; } }	match if auditlog description contains expected keyword , stream out the auditlog if matched , otherwise ignore this one piece of auditlog.
string tostring ( boolean includeprivatecredentials ) { string s = resourcesmgr . getstring ( _str ) ; string suffix = _str ; synchronized ( principals ) { iterator < principal > pi = principals . iterator ( ) ; while ( pi . hasnext ( ) ) { principal p = pi . next ( ) ; suffix = suffix + resourcesmgr . getstring ( _str ) + p . tostring ( ) + resourcesmgr . getstring ( _str ) ; } } synchronized ( pubcredentials ) { iterator < object > pi = pubcredentials . iterator ( ) ; while ( pi . hasnext ( ) ) { object o = pi . next ( ) ; suffix = suffix + resourcesmgr . getstring ( _str ) + o . tostring ( ) + resourcesmgr . getstring ( _str ) ; } } if ( includeprivatecredentials ) { synchronized ( privcredentials ) { iterator < object > pi = privcredentials . iterator ( ) ; while ( pi . hasnext ( ) ) { try { object o = pi . next ( ) ; suffix += resourcesmgr . getstring ( _str ) + o . tostring ( ) + resourcesmgr . getstring ( _str ) ; } catch ( securityexception se ) { suffix += resourcesmgr . getstring ( _str ) ; break ; } } } } return s + suffix ; }	package private convenience method to print out the subject without firing off a security check when trying to access the private credentials.
private void decodetonesphase ( int chnum , boolean bandhastones [ ] ) { wavesdata dst [ ] = ctx . channels [ chnum ] . tonesinfo ; for ( int sb = _num ; sb < ctx . wavesinfo . numtonebands ; sb ++ ) { if ( ! bandhastones [ sb ] ) { continue ; } int wparam = dst [ sb ] . startindex ; for ( int i = _num ; i < dst [ sb ] . numwavs ; i ++ ) { ctx . wavesinfo . waves [ wparam + i ] . phaseindex = br . read ( _num ) ; } } }	decode phase information for each subband of a channel .
public int encode ( byte [ ] data , int off , int length , outputstream out ) throws ioexception { for ( int i = off ; i < ( off + length ) ; i ++ ) { int v = data [ i ] & _num ; out . write ( encodingtable [ ( v > > > _num ) ] ) ; out . write ( encodingtable [ v & _num ] ) ; } return length * _num ; }	encode the input data producing a hex output stream .
public void clear ( ) { synchronized ( mlock ) { mgraphics . clear ( ) ; } postinvalidate ( ) ; }	removes all graphics from the overlay .
public static string removeall ( string str , string [ ] patterns ) { for ( string pattern : patterns ) str = str . replace ( pattern , _str ) ; return str ; }	removes all occurrences of each pattern in str.
public void addseriesrenderer ( simpleseriesrenderer renderer ) { mrenderers . add ( renderer ) ; }	adds a simple renderer to the multiple renderer .
public static void ccdrawcircle ( gl10 gl , cgpoint center , float r , float a , int segments , boolean drawlinetocenter ) { floatbuffer vertices = getvertices ( _num * ( segments + _num ) ) ; int additionalsegment = _num ; if ( drawlinetocenter ) additionalsegment ++ ; final float coef = _num * ( float ) math . pi / segments ; for ( int i = _num ; i <= segments ; i ++ ) { float rads = i * coef ; float j = ( float ) ( r * math . cos ( rads + a ) + center . x ) ; float k = ( float ) ( r * math . sin ( rads + a ) + center . y ) ; vertices . put ( j ) ; vertices . put ( k ) ; } vertices . put ( center . x ) ; vertices . put ( center . y ) ; vertices . position ( _num ) ; gl . gldisable ( gl_texture_2d ) ; gl . gldisableclientstate ( gl_texture_coord_array ) ; gl . gldisableclientstate ( gl_color_array ) ; gl . glvertexpointer ( _num , gl_float , _num , vertices ) ; gl . gldrawarrays ( gl_line_strip , _num , segments + additionalsegment ) ; gl . glenableclientstate ( gl_color_array ) ; gl . glenableclientstate ( gl_texture_coord_array ) ; gl . glenable ( gl_texture_2d ) ; }	draws a circle given the center , radius and number of segments .
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addall ( collections . list ( super . listoptions ( ) ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
@ override public boolean isparent ( file folder , file file ) { return folder . equals ( file . getparentfile ( ) ) ; }	checks whether folder is the same as file.
@ override public void print ( char c ) throws ioexception { boolean isws = character . iswhitespace ( c ) ; if ( isws ) { if ( isfirstchar ) return ; if ( c == char_return ) return ; if ( sb . length ( ) > _num ) { printbuffer ( ) ; lastchar = ( c == char_nl ) ? char_nl : c ; super . print ( lastchar ) ; return ; } } isfirstchar = _bool ; if ( c == char_gt && sb . length ( ) > _num ) printbuffer ( ) ; if ( isws || ! addtobuffer ( c ) ) { if ( depthsum == _num ) { if ( isws ) { if ( lastchar == char_nl ) return ; if ( c != char_nl ) { if ( character . iswhitespace ( lastchar ) ) return ; } } } lastchar = c ; super . print ( c ) ; } }	sends a character to output stream if it is not a consecutive white - space unless we ' re inside a pre or textarea tag .
public static tokenendpointauthmethod fromstring ( string type ) { if ( type != null ) { for ( tokenendpointauthmethod authmethod : tokenendpointauthmethod . values ( ) ) { if ( type . equalsignorecase ( authmethod . type ) ) { return authmethod ; } } } return null ; }	translates a string into a token endpoint auth method type .
public void put ( e e ) throws interruptedexception { if ( e == null ) throw new nullpointerexception ( ) ; int c = - _num ; final reentrantlock putlock = this . putlock ; final atomicinteger count = this . count ; putlock . lockinterruptibly ( ) ; try { while ( count . get ( ) >= capacity ) { notfull . await ( ) ; } enqueue ( e ) ; c = count . getandincrement ( ) ; if ( c + _num < capacity ) notfull . signal ( ) ; } finally { putlock . unlock ( ) ; } if ( c == _num ) signalnotempty ( ) ; }	inserts the specified element at the tail of this queue , waiting if necessary for space to become available .
private boolean compare ( list < string > remotemodules , list < string > expectedmodules ) { collections . sort ( remotemodules ) ; collections . sort ( expectedmodules ) ; return remotemodules . equals ( expectedmodules ) ; }	return true if the both lists contain the same content ( order doesn ' t matter ).
private void encodesize ( bytebuffer headerbuffer , int size ) { headerbuffer . put ( ( byte ) ( ( size & _num ) > > _num ) ) ; headerbuffer . put ( ( byte ) ( ( size & _num ) > > _num ) ) ; headerbuffer . put ( ( byte ) ( size & _num ) ) ; logger . fine ( _str + size + _str + integer . tobinarystring ( size ) + _str + integer . tohexstring ( size ) ) ; }	write frame size ( can now be accurately calculated , have to convert 4 byte int to 3 byte format .
public boolean thisisyou ( object n ) { return id . equals ( n ) ; }	checks the internal id against the given one .
@ override public synchronized void clear ( ) { file [ ] files = mrootdirectory . listfiles ( ) ; if ( files != null ) { for ( file file : files ) { file . delete ( ) ; } } mentries . clear ( ) ; mtotalsize = _num ; volleylog . d ( _str ) ; }	clears the cache . deletes all cached files from disk .
public void resetworkspace ( ) { mblockfactory . clearpriorblockreferences ( ) ; mrootblocks . clear ( ) ; mstats . clear ( ) ; mdeletedblocks . clear ( ) ; }	reset the workspace view when changing workspaces.
protected void oncomplete ( ) { }	meant to be overwritten by children classes that want to do something special after the download is completed .
public static bigdecimal paidtodate ( int p_c_invoice_id , int p_c_currency_id , int p_multiplierap , timestamp dateacct ) throws sqlexception { if ( p_c_invoice_id == _num || p_c_currency_id == _num ) return null ; bigdecimal multiplierap = new bigdecimal ( ( double ) p_multiplierap ) ; if ( p_multiplierap == _num ) multiplierap = adempiere . one ; int c_conversiontype_id = _num ; bigdecimal paymentamt = allocatedamttodate ( p_c_invoice_id , p_c_currency_id , c_conversiontype_id , multiplierap , dateacct ) ; return currency . round ( paymentamt , p_c_currency_id , null ) ; }	get invoice paid ( allocated ) amount . - invoicepaid.
public static list < window > windows ( inputstream words , tokenizerfactory tokenizerfactory , int windowsize ) { tokenizer tokenizer = tokenizerfactory . create ( words ) ; list < string > list = new arraylist < > ( ) ; while ( tokenizer . hasmoretokens ( ) ) list . add ( tokenizer . nexttoken ( ) ) ; if ( list . isempty ( ) ) throw new illegalstateexception ( _str ) ; return windows ( list , windowsize ) ; }	constructs a list of window of size windowsize.
public static double [ ] pagerank ( matrixinterface preparedmatrix , int maxiteration ) { double [ ] init = new double [ preparedmatrix . getrowscount ( ) ] ; for ( int i = _num ; i != init . length ; i ++ ) init [ i ] = _num ; return pagerank ( preparedmatrix , maxiteration , default_d , init ) ; }	call preparematrix or preparesparsematrix first.
public boolean hasmimetype ( string mimetype ) { if ( mimetype == null ) return _bool ; string type = mimetype ; if ( mimetype . indexof ( _str ) > _num ) { type = mimetype . substring ( _num , mimetype . indexof ( _str ) ) ; } for ( string mt : this . mimetypes ) { if ( mt . equalsignorecase ( mimetype ) ) { return _bool ; } if ( mimetype != type && mt . equalsignorecase ( type ) ) { return _bool ; } } return _bool ; }	checks if specified mime type matches one of the fileformat ' s mime types.
private void readobject ( java . io . objectinputstream s ) throws java . io . ioexception , classnotfoundexception { s . defaultreadobject ( ) ; key = key . clone ( ) ; }	readobject is called to restore the state of this key from a stream .
void unexecutensdecls ( transformerimpl transformer ) throws transformerexception { unexecutensdecls ( transformer , null ) ; }	send endprefixmapping events to the result tree handler for all declared prefix mappings in the stylesheet .
public boolean add ( protocolmessage pm ) { return protocolmessages . add ( pm ) ; }	adds protocol message to the list.
public void randominit ( ) { do { m_bits = new boolean [ m_nnodes * m_nnodes ] ; for ( int i = _num ; i < m_nnodes ; i ++ ) { int ipos ; do { ipos = m_random . nextint ( m_nnodes * m_nnodes ) ; } while ( issquare ( ipos ) ) ; m_bits [ ipos ] = _bool ; } } while ( hascycles ( ) ) ; calcglobalscore ( ) ; }	initialize with a random structure by randomly placing m_nnodes arcs .
public static int safeparseint ( string s ) { return safeparseint ( s , - _num ) ; }	parses the specified string argument to an unsigned decimal integer.
protected boolean hasreceiversfor ( distributedmember endpoint ) { synchronized ( this . receivers ) { for ( iterator it = receivers . iterator ( ) ; it . hasnext ( ) ; ) { connection con = ( connection ) it . next ( ) ; if ( endpoint . equals ( con . getremoteaddress ( ) ) ) { return _bool ; } } } return _bool ; }	check to see if there are still any receiver threads for the given end - point.
public void addrangerestriction ( string columnname , object code , object code_to , string infoname , string infodisplay , string infodisplay_to ) { restriction r = new restriction ( columnname , code , code_to , infoname , infodisplay , infodisplay_to , _bool , _num ) ; m_list . add ( r ) ; }	add range restriction ( between ).
public static string unsignedtostring ( final int value ) { if ( value >= _num ) { return integer . tostring ( value ) ; } else { return long . tostring ( value & _num ) ; } }	convert an unsigned 32 - bit integer to a string .
public static list < file > findall ( file basefile , string regex ) { arraylist < file > found = new arraylist < file > ( ) ; findall ( basefile , regex , found ) ; return found ; }	find a files in a given base directory that match a the given regex.
public void appendcssdefinition ( stringbuilder buf ) { buf . append ( _str ) ; buf . append ( name ) ; buf . append ( _str ) ; for ( pair < string , string > pair : statements ) { buf . append ( pair . getfirst ( ) ) ; buf . append ( _str ) ; buf . append ( pair . getsecond ( ) ) ; buf . append ( _str ) ; } buf . append ( _str ) ; }	append css definition to a stream.
@ override public boolean eisset ( int featureid ) { switch ( featureid ) { case datatypepackage . constraint__type : return type != type_edefault ; case datatypepackage . constraint__constraint_values : return constraint_values_edefault == null ? constraintvalues != null : ! constraint_values_edefault . equals ( constraintvalues ) ; } return super . eisset ( featureid ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
protected object cloneobject ( object obj ) { if ( obj == null ) { return null ; } if ( obj instanceof string || obj instanceof boolean || obj instanceof byte || obj instanceof short || obj instanceof character || obj instanceof integer || obj instanceof long || obj instanceof float || obj instanceof double ) { return obj ; } if ( obj instanceof byte [ ] ) { byte [ ] body = ( byte [ ] ) obj ; byte [ ] data = new byte [ body . length ] ; system . arraycopy ( body , _num , data , _num , body . length ) ; return data ; } return serializationhelper . deepclone ( obj ) ; }	returns a clone of the object .
private void assertwritevarint ( byte [ ] data , long value ) throws exception { if ( ( value > > > _num ) == _num ) { bytearrayoutputstream rawoutput = new bytearrayoutputstream ( ) ; codedoutputstream output = codedoutputstream . newinstance ( rawoutput ) ; output . writerawvarint32 ( ( int ) value ) ; output . flush ( ) ; assertequalbytes ( data , rawoutput . tobytearray ( ) ) ; assertequals ( data . length , codedoutputstream . computerawvarint32size ( ( int ) value ) ) ; } { bytearrayoutputstream rawoutput = new bytearrayoutputstream ( ) ; codedoutputstream output = codedoutputstream . newinstance ( rawoutput ) ; output . writerawvarint64 ( value ) ; output . flush ( ) ; assertequalbytes ( data , rawoutput . tobytearray ( ) ) ; assertequals ( data . length , codedoutputstream . computerawvarint64size ( value ) ) ; } for ( int blocksize = _num ; blocksize <= _num ; blocksize *= _num ) { if ( ( value > > > _num ) == _num ) { bytearrayoutputstream rawoutput = new bytearrayoutputstream ( ) ; codedoutputstream output = codedoutputstream . newinstance ( rawoutput , blocksize ) ; output . writerawvarint32 ( ( int ) value ) ; output . flush ( ) ; assertequalbytes ( data , rawoutput . tobytearray ( ) ) ; } { bytearrayoutputstream rawoutput = new bytearrayoutputstream ( ) ; codedoutputstream output = codedoutputstream . newinstance ( rawoutput , blocksize ) ; output . writerawvarint64 ( value ) ; output . flush ( ) ; assertequalbytes ( data , rawoutput . tobytearray ( ) ) ; } } }	writes the given value using writerawvarint32 ( ) and writerawvarint64 ( ) and checks that the result matches the given bytes .
public void attach ( actionobserver observer ) { observer . makeonetimeuse ( ) ; lock . lock ( ) ; try { onceusedobservers . add ( observer ) ; } finally { lock . unlock ( ) ; } }	once used observer add to observercontroller.
private void signcertificatechain ( ) { list < certificate > cc = new arraylist < > ( ) ; cc . add ( signcert ) ; list < certificate > oc = new arraylist < > ( certs ) ; for ( int k = _num ; k < oc . size ( ) ; ++ k ) { if ( signcert . equals ( oc . get ( k ) ) ) { oc . remove ( k ) ; -- k ; } } boolean found = _bool ; while ( found ) { x509certificate v = ( x509certificate ) cc . get ( cc . size ( ) - _num ) ; found = _bool ; for ( int k = _num ; k < oc . size ( ) ; ++ k ) { x509certificate issuer = ( x509certificate ) oc . get ( k ) ; try { v . verify ( issuer . getpublickey ( ) , provider ) ; found = _bool ; cc . add ( oc . get ( k ) ) ; oc . remove ( k ) ; break ; } catch ( exception ignored ) { } } } signcerts = cc ; }	helper method that creates the collection of certificates used for the main signature based on the complete list of certificates and the sign certificate .
public static string metertostring ( ofinstructionmeter inst , logger log ) { return long . tostring ( inst . getmeterid ( ) ) ; }	convert an ofinstructionmeter to string form.
public string charset ( ) { return parameter ( header_content_type , param_charset ) ; }	get ' charset ' parameter from ' content - type ' response header.
public dimension minimumlayoutsize ( container parent ) { dimension rd , mbd ; insets i = getinsets ( ) ; if ( contentpane != null ) { rd = contentpane . getminimumsize ( ) ; } else { rd = parent . getsize ( ) ; } if ( menubar != null && menubar . isvisible ( ) ) { mbd = menubar . getminimumsize ( ) ; } else { mbd = new dimension ( _num , _num ) ; } return new dimension ( math . max ( rd . width , mbd . width ) + i . left + i . right , rd . height + mbd . height + i . top + i . bottom ) ; }	returns the minimum amount of space the layout needs .
public static boolean checkifcanuse ( string classname ) { if ( mocklist . shouldbemocked ( classname ) ) { return _bool ; } for ( string s : classexceptions ) { if ( classname . startswith ( s ) ) { return _bool ; } } return _bool ; }	check if we can use the given class directly in a junit test.
public static int readall ( inputstream i , byte b [ ] ) throws ioexception { int len = b . length ; int n = _num ; while ( n < len ) { int count = i . read ( b , n , len - n ) ; if ( count < _num ) { return n ; } n += count ; } return n ; }	reads until the array is full or until the stream ends.
public void switchtosimple ( experiment exp ) { if ( exp == null ) { exp = m_advancedpanel . getexperiment ( ) ; } if ( exp != null && ! m_simplepanel . setexperiment ( exp ) ) { m_advancedsetuprbut . setselected ( _bool ) ; switchtoadvanced ( exp ) ; } else { remove ( m_advancedpanel ) ; m_advancedpanel . removenotesframe ( ) ; add ( m_simplepanel , borderlayout . center ) ; validate ( ) ; repaint ( ) ; } }	switches to the simple setup mode only if allowed to .
public static cachespan createcacheentry ( file file ) { matcher matcher = cache_file_pattern_v2 . matcher ( file . getname ( ) ) ; if ( ! matcher . matches ( ) ) { return null ; } string key = util . unescapefilename ( matcher . group ( _num ) ) ; return key == null ? null : createcacheentry ( key , long . parselong ( matcher . group ( _num ) ) , long . parselong ( matcher . group ( _num ) ) , file ) ; }	creates a cache span from an underlying cache file .
public boolean iscomponentpartofcurrentmenu ( component c ) { if ( selection . size ( ) > _num ) { menuelement me = selection . elementat ( _num ) ; return iscomponentpartofcurrentmenu ( me , c ) ; } else return _bool ; }	return true if c is part of the currently used menu.
public static int hsba ( float h , float s , float b , float a ) { return setalpha ( color . hsbtorgb ( h , s , b ) , ( int ) ( a * _num + _num ) & _num ) ; }	get the color code for the given hue , saturation , and brightness values , translating from hsb color space to rgb color space .
lambdaformbuffer replacefunctions ( namedfunction [ ] oldfns , namedfunction [ ] newfns , object ... forarguments ) { assert ( intrans ( ) ) ; if ( oldfns . length == _num ) return this ; for ( int i = arity ; i < length ; i ++ ) { name n = names [ i ] ; int nfi = indexof ( n . function , oldfns ) ; if ( nfi >= _num && arrays . equals ( n . arguments , forarguments ) ) { changename ( i , new name ( newfns [ nfi ] , n . arguments ) ) ; } } return this ; }	replace any name whose function is in oldfns with a copy whose function is in the corresponding position in newfns.
@ override public clientsocket openiflive ( ) { if ( _state . isclosed ( ) ) { return null ; } clientsocket stream = openrecycle ( ) ; if ( stream != null ) return stream ; long now = currenttime . currenttime ( ) ; if ( isfailed ( now ) ) return null ; else if ( _state == state . fail && _startingcount . get ( ) > _num ) { return null ; } return connect ( ) ; }	open a stream to the target server object persistence .
public void commit ( ) { info ( _str + solrurl + _str ) ; doget ( appendparam ( solrurl . tostring ( ) , _str ) ) ; }	does a simple commit operation.
public abstract void filesdropped ( java . io . file [ ] files ) ;	this method is called when files have been successfully dropped .
protected void waitforthreadtoenterwaitstate ( thread thread , long timeoutmillis ) { long starttime = _num ; for ( ; ; ) { thread . state s = thread . getstate ( ) ; if ( s == thread . state . blocked || s == thread . state . waiting || s == thread . state . timed_waiting ) return ; else if ( s == thread . state . terminated ) fail ( _str ) ; else if ( starttime == _num ) starttime = system . nanotime ( ) ; else if ( milliselapsedsince ( starttime ) > timeoutmillis ) { threadasserttrue ( thread . isalive ( ) ) ; return ; } thread . yield ( ) ; } }	spin - waits up to the specified number of milliseconds for the given thread to enter a wait state : blocked , waiting , or timed_waiting .
public void forcerewriteexif ( string filename , collection < exiftag > tags ) throws filenotfoundexception , ioexception { if ( ! rewriteexif ( filename , tags ) ) { exifdata tempdata = mdata ; mdata = new exifdata ( default_byte_order ) ; fileinputstream is = null ; bytearrayoutputstream bytes = null ; try { is = new fileinputstream ( filename ) ; bytes = new bytearrayoutputstream ( ) ; doexifstreamio ( is , bytes ) ; byte [ ] imagebytes = bytes . tobytearray ( ) ; readexif ( imagebytes ) ; settags ( tags ) ; writeexif ( imagebytes , filename ) ; } catch ( ioexception e ) { closesilently ( is ) ; throw e ; } finally { is . close ( ) ; mdata = tempdata ; } } }	attempts to do an in - place rewrite of the exif metadata.
public static latlng translatepoint ( latlng point , double distance , double bearing ) { distance = distance / _num ; double lat = math . toradians ( point . latitude ) ; double lng = math . toradians ( point . longitude ) ; bearing = math . toradians ( bearing ) ; double lat2 = math . asin ( ( math . sin ( lat ) * math . cos ( distance / earth ) ) + ( math . cos ( lat ) * math . sin ( distance / earth ) * math . cos ( bearing ) ) ) ; double long2 = lng + math . atan2 ( math . sin ( bearing ) * math . sin ( distance / earth ) * math . cos ( lat ) , math . cos ( distance / earth ) - ( math . sin ( lat ) * math . sin ( lat2 ) ) ) ; lat2 = math . todegrees ( lat2 ) ; long2 = math . todegrees ( long2 ) ; return new latlng ( lat2 , long2 ) ; }	returns the destination point from the starting point point having travelled the given distance on the given initial bearing ( bearing normally varies around path followed ) .
public static string detectpropertiespath ( ) { string override = system . getproperty ( _str ) ; if ( override != null ) { return override ; } string jarpath = detectjarpath ( ) ; string propfile = constants . props_file + _str ; return fixwhitespaces ( getparentdirectory ( jarpath ) + file . separator + propfile ) ; }	gets the path to qz - tray . properties.
static int formatfloat ( final char [ ] out , float val , int digits ) { boolean negative = _bool ; if ( val == _num ) { out [ _num ] = _str ; return _num ; } if ( val < _num ) { negative = _bool ; val = - val ; } if ( digits >= pow10 . length ) { digits = pow10 . length - _num ; } val *= pow10 [ digits ] ; long lval = math . round ( val ) ; int index = out . length - _num ; int charcount = _num ; while ( lval != _num || charcount < ( digits + _num ) ) { int digit = ( int ) ( lval % _num ) ; lval = lval / _num ; out [ index -- ] = ( char ) ( digit + _str ) ; charcount ++ ; if ( charcount == digits ) { out [ index -- ] = _str ; charcount ++ ; } } if ( negative ) { out [ index ] = _str ; charcount ++ ; } return charcount ; }	formats a float value to the given number of decimals.
public void acceptpackage ( char [ ] packagename ) { }	one result of the search consists of a new package .
public gaussiandensityfunction ( double mean , double variance ) { this . mean = new double [ ] { mean } ; this . variance = new double [ ] { variance } ; stddev = new double [ ] { math . sqrt ( variance ) } ; if ( variance < _num ) { log . warning ( _str + variance ) ; } }	creates a new , univariate density function with a given mean and variance.
int encryptfinal ( byte [ ] in , int inofs , int len , byte [ ] out , int outofs ) throws illegalblocksizeexception , shortbufferexception { if ( out . length - outofs < ( len + taglenbytes ) ) { throw new shortbufferexception ( _str ) ; } processaad ( ) ; if ( len > _num ) { dolastblock ( in , inofs , len , out , outofs , _bool ) ; } byte [ ] lengthblock = getlengthblock ( sizeofaad * _num , processed * _num ) ; ghashalltos . update ( lengthblock ) ; byte [ ] s = ghashalltos . digest ( ) ; byte [ ] sout = new byte [ s . length ] ; gctr gctrforstotag = new gctr ( embeddedcipher , this . precounterblock ) ; gctrforstotag . dofinal ( s , _num , s . length , sout , _num ) ; system . arraycopy ( sout , _num , out , ( outofs + len ) , taglenbytes ) ; return ( len + taglenbytes ) ; }	performs encryption operation for the last time .
public static string componenttoimagecolname ( string component ) { if ( component . equals ( mixnmatchcolumns . key_homescreen ) ) { return themescolumns . homescreen_uri ; } else if ( component . equals ( mixnmatchcolumns . key_lockscreen ) ) { return themescolumns . lockscreen_uri ; } else if ( component . equals ( mixnmatchcolumns . key_boot_anim ) ) { return themescolumns . boot_anim_uri ; } else if ( component . equals ( mixnmatchcolumns . key_font ) ) { return themescolumns . font_uri ; } else if ( component . equals ( mixnmatchcolumns . key_icons ) ) { return themescolumns . icon_uri ; } else if ( component . equals ( mixnmatchcolumns . key_status_bar ) ) { return themescolumns . statusbar_uri ; } else if ( component . equals ( mixnmatchcolumns . key_notifications ) ) { throw new illegalargumentexception ( _str ) ; } else if ( component . equals ( mixnmatchcolumns . key_ringtone ) ) { throw new illegalargumentexception ( _str ) ; } else if ( component . equals ( mixnmatchcolumns . key_overlays ) ) { return themescolumns . overlays_uri ; } else if ( component . equals ( mixnmatchcolumns . key_alarm ) ) { throw new illegalargumentexception ( _str ) ; } else if ( component . equals ( mixnmatchcolumns . key_navigation_bar ) ) { throw new illegalargumentexception ( _str ) ; } else if ( component . equals ( mixnmatchcolumns . key_live_lock_screen ) ) { throw new illegalargumentexception ( _str ) ; } return null ; }	for a given key value in the mixnmatch table , return the column associated with it in the themes table.
public boolean isabstract ( ) { return modifier . isabstract ( _method . getmodifiers ( ) ) ; }	returns true for an abstract method .
private static void parsecopyfields ( parsecontext context , fieldmapper fieldmapper , list < string > copytofields ) throws ioexception { if ( ! context . iswithincopyto ( ) && copytofields . isempty ( ) == _bool ) { context = context . createcopytocontext ( ) ; for ( string field : copytofields ) { parsecontext . document targetdoc = null ; for ( parsecontext . document doc = context . doc ( ) ; doc != null ; doc = doc . getparent ( ) ) { if ( field . startswith ( doc . getprefix ( ) ) ) { targetdoc = doc ; break ; } } assert targetdoc != null ; final parsecontext copytocontext ; if ( targetdoc == context . doc ( ) ) { copytocontext = context ; } else { copytocontext = context . switchdoc ( targetdoc ) ; } parsecopy ( field , copytocontext ) ; } } }	creates instances of the fields that the current field should be copied to.
protected file createobbfile ( string name , int rawresid ) { file outfile = null ; try { final file filesdir = mcontext . getfilesdir ( ) ; outfile = new file ( filesdir , name ) ; copyrawtofile ( rawresid , outfile ) ; } catch ( notfoundexception e ) { if ( outfile != null ) { outfile . delete ( ) ; } } return outfile ; }	creates an obb file ( with the given name ) , into the app ' s standard files directory.
public playsoundentity ( string sound , int radius , int volume ) { this . sounds = sound . split ( _str ) ; this . radius = radius ; this . volume = volume ; }	creates a new playsoundentity.
public repository ( string domain ) { this ( domain , _bool ) ; }	construct a new repository with the given default domain .
private void updateview ( int viewposition ) { notifyitemchanged ( viewposition ) ; }	update the contents of a view ( i.
public static string optimize ( string ... args ) { return simpletag ( _str , args ) ; }	helper that returns an & lt ; optimize & gt ; string with optional key / val pairs .
protected boolean isvalidserver ( final string server ) { boolean isvalid = checkserverprefixes ( server ) ; if ( isvalid ) { if ( server . startswith ( _str ) ) { isvalid = canconnect ( server ) ; } else if ( server . startswith ( _str ) ) { isvalid = isdirectory ( server ) ; } } return isvalid ; }	returns whether the given server can be connected to .
public concurrenthashmap ( map < ? extends k , ? extends v > m ) { this ( math . max ( ( int ) ( m . size ( ) / default_load_factor ) + _num , default_initial_capacity ) , default_load_factor , default_concurrency_level ) ; putall ( m ) ; }	creates a new map with the same mappings as the given map.
public mapmaker expiration ( long duration , timeunit unit ) { if ( expirationnanos != _num ) { throw new illegalstateexception ( _str + expirationnanos + _str ) ; } if ( duration <= _num ) { throw new illegalargumentexception ( _str + duration ) ; } this . expirationnanos = unit . tonanos ( duration ) ; usecustommap = _bool ; return this ; }	specifies that each entry should be automatically removed from the map once a fixed duration has passed since the entry ' s creation .
void initfromnode ( final node fromnode , final double starttime , final pseudoremovepriorityqueue < node > pendingnodes ) { dijkstranodedata data = getdata ( fromnode ) ; visitnode ( fromnode , data , pendingnodes , starttime , _num , null ) ; }	initializes the first node of a route .
public collection < htmltoken > tokenizehtml ( ) { list < htmltoken > tokens = new arraylist < htmltoken > ( ) ; string nestedtags = nestedtagsregex ( _num ) ; pattern p = pattern . compile ( _str + _str + _str + _str + _str + nestedtags + _str , pattern . case_insensitive ) ; matcher m = p . matcher ( text ) ; int lastpos = _num ; while ( m . find ( ) ) { if ( lastpos < m . start ( ) ) { tokens . add ( htmltoken . text ( text . substring ( lastpos , m . start ( ) ) ) ) ; } tokens . add ( htmltoken . tag ( text . substring ( m . start ( ) , m . end ( ) ) ) ) ; lastpos = m . end ( ) ; } if ( lastpos < text . length ( ) ) { tokens . add ( htmltoken . text ( text . substring ( lastpos , text . length ( ) ) ) ) ; } return tokens ; }	parse html tags , returning a collection of htmltoken objects .
public int decryptblock ( byte [ ] in , int inoff , byte [ ] out , int outoff ) throws datalengthexception , illegalstateexception { if ( ( inoff + blocksize ) > in . length ) { throw new datalengthexception ( _str ) ; } if ( ( outoff + blocksize ) > out . length ) { throw new datalengthexception ( _str ) ; } cipher . processblock ( cfbv , _num , cfboutv , _num ) ; system . arraycopy ( cfbv , blocksize , cfbv , _num , cfbv . length - blocksize ) ; system . arraycopy ( in , inoff , cfbv , cfbv . length - blocksize , blocksize ) ; for ( int i = _num ; i < blocksize ; i ++ ) { out [ outoff + i ] = ( byte ) ( cfboutv [ i ] ^ in [ inoff + i ] ) ; } return blocksize ; }	do the appropriate processing for cfb mode decryption .
private string computemd5hash ( string buffer ) { messagedigest md ; try { md = messagedigest . getinstance ( _str ) ; return bytestohex ( md . digest ( buffer . getbytes ( _str ) ) ) ; } catch ( nosuchalgorithmexception ignore ) { } catch ( unsupportedencodingexception e ) { } return _str ; }	needed for the digest access authentication .
public void run ( ) throws ioexception , interruptedexception { for ( int i = _num ; i < conncnt ; i ++ ) exec . submit ( new clientthread ( ) ) ; thread . sleep ( _num * _num * _num ) ; exec . shutdownnow ( ) ; }	runs single benchamark configuration .
public static string pluralize ( string word ) { if ( word == null ) { throw new illegalargumentexception ( ) ; } final string lowercaseword = word . tolowercase ( ) ; if ( endswithany ( lowercaseword , _str , _str , _str ) ) { return word + _str ; } if ( lowercaseword . endswith ( _str ) && ! lowercaseword . endswith ( _str ) || endswithany ( lowercaseword , _str , _str , _str ) ) { return word . substring ( _num , word . length ( ) - _num ) + _str ; } else { return word + _str ; } }	get the plural for the given english word .
protected void onnetworktypechange ( networkinfo oldnetwork , networkinfo newnetwork ) throws routerexception { log . info ( string . format ( _str , oldnetwork == null ? _str : oldnetwork . gettypename ( ) , newnetwork == null ? _str : newnetwork . gettypename ( ) ) ) ; if ( disable ( ) ) { log . info ( string . format ( _str , oldnetwork == null ? _str : oldnetwork . gettypename ( ) ) ) ; } networkinfo = newnetwork ; if ( enable ( ) ) { log . info ( string . format ( _str , newnetwork == null ? _str : newnetwork . gettypename ( ) ) ) ; } }	can be overriden by subclasses to do additional work .
private linkedhashmap < term , integer > repeatingterms ( ) { linkedhashmap < term , integer > tord = new linkedhashmap < > ( ) ; hashmap < term , integer > tcnt = new hashmap < > ( ) ; for ( phrasepositions pp : phrasepositions ) { for ( term t : pp . terms ) { integer cnt0 = tcnt . get ( t ) ; integer cnt = cnt0 == null ? new integer ( _num ) : new integer ( _num + cnt0 . intvalue ( ) ) ; tcnt . put ( t , cnt ) ; if ( cnt == _num ) { tord . put ( t , tord . size ( ) ) ; } } } return tord ; }	find repeating terms and assign them ordinal values.
public list < inetaddress > discoverhosts ( int udpport , int timeoutmillis ) { list < inetaddress > hosts = new arraylist < inetaddress > ( ) ; datagramsocket socket = null ; try { socket = new datagramsocket ( ) ; broadcast ( udpport , socket ) ; socket . setsotimeout ( timeoutmillis ) ; while ( _bool ) { datagrampacket packet = new datagrampacket ( new byte [ _num ] , _num ) ; try { socket . receive ( packet ) ; } catch ( sockettimeoutexception ex ) { if ( info ) info ( _str , _str ) ; return hosts ; } if ( info ) info ( _str , _str + packet . getaddress ( ) ) ; hosts . add ( packet . getaddress ( ) ) ; } } catch ( ioexception ex ) { if ( error ) error ( _str , _str , ex ) ; return hosts ; } finally { if ( socket != null ) socket . close ( ) ; } }	broadcasts a udp message on the lan to discover any running servers .
protected void reloadclusterconfiguration ( ) { synchronized ( this . cluster ) { loadclusterconfiguration ( ) ; } }	reload configuration for this cluster .
public double expectedutility ( nondominatedpopulation population ) { double sum = _num ; for ( int i = _num ; i < weights . length ; i ++ ) { double max = double . negative_infinity ; for ( solution solution : population ) { max = math . max ( max , utilityfunction . computeutility ( solution , weights [ i ] ) ) ; } sum += max ; } return sum / weights . length ; }	computes the expected utility for the given population .
public void count ( hashmap < string , treemap < string , integer > > table , string suffix , string tag ) { treemap < string , integer > counts = table . get ( suffix ) ; if ( counts == null ) { counts = new treemap < string , integer > ( ) ; table . put ( suffix , counts ) ; } integer count = counts . get ( tag ) ; if ( count == null ) count = _num ; counts . put ( tag , count + _num ) ; }	increments the count for the given suffix and tag .
public void addinputmode ( string mode , string [ ] [ ] inputchars ) { modesmap . put ( mode , inputchars ) ; }	add an input mode to the virtual keyboard.
public static void sleep ( int msec ) throws interruptedexception { thread . sleep ( msec ) ; }	description of the method.
public void propertychange ( propertychangeevent pce ) { if ( pce . getpropertyname ( ) == omdrawingtool . loadersproperty ) { object obj = pce . getnewvalue ( ) ; if ( obj instanceof vector ) { vector < edittoolloader > loaders = ( vector < edittoolloader > ) obj ; setloaders ( loaders . iterator ( ) ) ; resetgui ( ) ; } } }	propertychangelistener method , to listen for the omdrawingtool ' s list of loaders that may or may not change .
public void removeappoffer ( offer offer ) { int indextoremove = getindex ( offer ) ; if ( indextoremove != - _num ) { appoffers . remove ( indextoremove ) ; notifydatasetchanged ( ) ; } }	remove an appoffer from the binder when user adds to base plan.
public data transform ( data data , xmlcryptocontext xc ) throws transformexception { return spi . transform ( data , xc ) ; }	transforms the specified data using the underlying transform algorithm .
public static double quantile ( double val , double mu , double sigma , double xi ) { if ( val < _num || val > _num ) { return double . nan ; } if ( xi == _num ) { return mu - sigma * math . log ( _num - val ) ; } return mu - sigma / xi * ( _num - math . pow ( _num - val , - xi ) ) ; }	quantile function of gpd distribution.
oathdevicesettings createdeviceprofile ( int minsharedsecretlength ) { reject . iffalse ( minsharedsecretlength >= _num , _str ) ; int sharedsecretbytelength = math . max ( min_shared_secret_byte_length , ( int ) math . ceil ( minsharedsecretlength / _num ) ) ; byte [ ] secretbytes = new byte [ sharedsecretbytelength ] ; securerandom . nextbytes ( secretbytes ) ; string sharedsecret = datatypeconverter . printhexbinary ( secretbytes ) ; return new oathdevicesettings ( sharedsecret , device_name , initial_last_login_time , initial_counter_value ) ; }	creates and saves a fresh device profile for the given user.
public final void deleteselectedobjects ( ) { component [ ] components = getcomponents ( ) ; list < displaynode > graphnodes = new arraylist < > ( ) ; list < idisplayedge > graphedges = new arraylist < > ( ) ; for ( component comp : components ) { if ( comp instanceof displaynode ) { if ( ! isdeletevariablesallowed ( ) ) { continue ; } displaynode node = ( displaynode ) comp ; if ( node . isselected ( ) ) { graphnodes . add ( node ) ; } } else if ( comp instanceof idisplayedge ) { idisplayedge edge = ( idisplayedge ) comp ; if ( edge . isselected ( ) ) { graphedges . add ( edge ) ; } } } for ( displaynode graphnode : graphnodes ) { removenode ( graphnode ) ; } for ( idisplayedge displayedge : graphedges ) { try { removeedge ( displayedge ) ; resetedgeoffsets ( displayedge ) ; } catch ( exception e ) { if ( isnodeedgeerrorsreported ( ) ) { joptionpane . showmessagedialog ( joptionutils . centeringcomp ( ) , e . getmessage ( ) ) ; } } } }	deletes all selected nodes in the workbench plus any edges that have had one of their nodes deleted in the process .
protected final void initstatistics ( string who , string [ ] headerlines ) throws adeexception { setstatsfilepath ( ) ; if ( statsfilepath == null ) { throw new adeinternalexception ( _str ) ; } appendstatstring ( spacer ) ; appendstatstring ( string . format ( _str , currenttimestamp ( ) , who ) ) ; appendstatstring ( spacer ) ; for ( int i = _num ; i < headerlines . length ; i ++ ) { appendstatstring ( headerlines [ i ] ) ; } appendstatstring ( spacer ) ; }	method to create a new dedicated stats file for this instance , and to insert the input headerlines as first content to that text file .
protected void addclasspath ( string classpath ) { if ( classpath == null ) return ; string sep = classpath . indexof ( _str ) == - _num ? _str : _str ; string [ ] parsecp = classpath . split ( sep ) ; for ( string cpentry : parsecp ) { addentry ( cpentry ) ; } }	add classpath with path separator.
@ inject entryuploaderimpl ( entryinserter entryinserter , entryprovider entryprovider , entryupdater entryupdater ) { this . entryinserter = checknotnull ( entryinserter ) ; this . entryprovider = checknotnull ( entryprovider ) ; this . entryupdater = checknotnull ( entryupdater ) ; }	creates a new entryuploaderimpl with the given dependencies .
protected void add ( long bytesin , long bytesout ) { totalbytesin . addandget ( bytesin ) ; totalbytesout . addandget ( bytesout ) ; }	adds the input / output byes of a compression .
public static double vectordistance ( double [ ] vec1 , double [ ] vec2 , double power , double oneoverpower ) { double result = _num ; if ( power == _num ) { for ( int i = _num ; i < vec1 . length ; i ++ ) { result += vec1 [ i ] - vec2 [ i ] == _num ? _num : _num ; } } else if ( power == _num ) { for ( int i = _num ; i < vec1 . length ; i ++ ) { result += math . abs ( vec1 [ i ] - vec2 [ i ] ) ; } } else if ( power == _num ) { result = math . sqrt ( distsquaredcartesian ( vec1 , vec2 ) ) ; } else if ( power == integer . max_value || double . isinfinite ( power ) ) { for ( int i = _num ; i < vec1 . length ; i ++ ) { result = math . max ( result , math . max ( vec1 [ i ] , vec2 [ i ] ) ) ; } } else { for ( int i = _num ; i < vec1 . length ; i ++ ) { result += math . pow ( vec1 [ i ] - vec2 [ i ] , power ) ; } result = math . pow ( result , oneoverpower ) ; } return result ; }	calculate the p - norm ( i.
public static float [ ] randomvector ( int asize , long seed ) { random rand = new random ( seed ) ; float [ ] unk = new float [ asize ] ; for ( int i = _num ; i < unk . length ; i ++ ) { unk [ i ] = ( rand . nextfloat ( ) - _num ) / asize ; } return unk ; }	create a random vector.
public boolean wasraw ( ) { return wasraw ; }	returns true if the type was raw , that is , type arguments were not provided but instead inferred .
public table findtable ( string catalogname , string schemaname , string tablename , boolean casesensitive ) { string cachekey = catalogname + _str + schemaname + _str + tablename + _str + casesensitive ; integer tableindex = tableindexcache . get ( cachekey ) ; if ( tableindex != null ) { if ( tableindex < gettablecount ( ) ) { table table = gettable ( tableindex ) ; if ( doesmatch ( table , catalogname , schemaname , tablename , casesensitive ) ) { return table ; } } } table [ ] tables = gettables ( ) ; for ( int i = _num ; i < tables . length ; i ++ ) { table table = tables [ i ] ; if ( doesmatch ( table , catalogname , schemaname , tablename , casesensitive ) ) { tableindexcache . put ( cachekey , i ) ; return table ; } } return null ; }	catalog & schema aware finder for ddlutils database class.
public void testdomainmatchesonlocaladdresses ( ) { assertfalse ( httpcookie . domainmatches ( _str , _str ) ) ; assertfalse ( httpcookie . domainmatches ( _str , _str ) ) ; }	rfc 2109 and rfc 2965 disagree here.
public void flush ( ) { writedatablock ( ) ; }	used to dump any data contained in memory to disk .
protected crfpcoveragebox [ ] vectortocrfpcoverageboxes ( vector vector ) { int size = vector . size ( ) ; crfpcoveragebox [ ] rets = new crfpcoveragebox [ size ] ; for ( int i = _num ; i < size ; i ++ ) { rpfcoveragebox box = ( rpfcoveragebox ) vector . elementat ( i ) ; if ( box != null ) { rets [ i ] = new crfpcoveragebox ( ( float ) box . nw_lat , ( float ) box . nw_lon , ( float ) box . se_lat , ( float ) box . se_lon , box . subframelatinterval , box . subframeloninterval , box . chartcode , ( short ) box . zone , new xypoint ( ( short ) box . startindexes . x , ( short ) box . startindexes . y ) , new xypoint ( ( short ) box . endindexes . x , ( short ) box . endindexes . y ) , ( short ) box . tocnumber , ( short ) box . entrynumber , box . scale , box . percentcoverage ) ; } } return rets ; }	convert a vector of rpfcoveragebox to a crfpcoveragebox array .
public void notifylistenersofinitialization ( ) { if ( initialized ) { for ( actionlistener l : listeners ) { l . actionperformed ( new actionevent ( this , actionevent . action_performed , _str ) ) ; } } }	notifies all the listeners that initialization is finished.
public void checkpassword ( string password ) throws badrequestexception { if ( password == null ) { throw new badrequestexception ( _str ) ; } if ( password . length ( ) < _num ) { throw new badrequestexception ( _str ) ; } int numofletters = _num ; int numofdigits = _num ; for ( char passwordchar : password . tochararray ( ) ) { if ( character . isdigit ( passwordchar ) ) { numofdigits ++ ; } else if ( character . isletter ( passwordchar ) ) { numofletters ++ ; } } if ( numofdigits == _num || numofletters == _num ) { throw new badrequestexception ( _str ) ; } }	checks whether password is ok .
final node < k , v > find ( int h , object k ) { if ( k != null ) { for ( node < k , v > e = first ; e != null ; ) { int s ; k ek ; if ( ( ( s = lockstate ) & ( waiter | writer ) ) != _num ) { if ( e . hash == h && ( ( ek = e . key ) == k || ( ek != null && k . equals ( ek ) ) ) ) return e ; e = e . next ; } else if ( u . compareandswapint ( this , lockstate , s , s + reader ) ) { treenode < k , v > r , p ; try { p = ( ( r = root ) == null ? null : r . findtreenode ( h , k , null ) ) ; } finally { thread w ; if ( u . getandaddint ( this , lockstate , - reader ) == ( reader | waiter ) && ( w = waiter ) != null ) locksupport . unpark ( w ) ; } return p ; } } } return null ; }	returns matching node or null if none.
public synchronized boolean removesuspendedresponse ( workercategory category , response response ) { deque < response > deque = workersbycategory . get ( category ) ; if ( deque == null ) { return _bool ; } if ( deque . remove ( response ) ) { nwaitingconsumers -= _num ; log . debug ( _str ) ; return _bool ; } return _bool ; }	when we notice that a long poll connection has closed , we remove it here .
public static number sin ( number a ) { return math . sin ( a . doublevalue ( ) ) ; }	returns the trigonometric sine of the number .
private typedclassoperation instantiateoperationtypes ( typedclassoperation operation ) { list < typevariable > typeparameters = operation . gettypeparameters ( ) ; if ( typeparameters . isempty ( ) ) { return operation ; } substitution < referencetype > substitution = selectsubstitution ( typeparameters ) ; if ( substitution == null ) { return null ; } return operation . apply ( substitution ) ; }	selects an instantiation of the generic types of an operation , and returns a new operation with the types instantiated .
default t fold ( final t identity , final binaryoperator < t > accumulator ) { final optional < t > opt = tooptional ( ) ; if ( opt . ispresent ( ) ) return accumulator . apply ( identity , get ( ) ) ; return identity ; }	use the supplied identity value and function to reduce this value to a single result ( unwraps the value stored in this value if the provided monoid combination instance obeys the monoid laws ).
protected void load ( string filename , properties p ) throws filenotfoundexception { file file = new file ( filename ) ; if ( ! file . exists ( ) ) throw new filenotfoundexception ( filename ) ; classifier = new crfclassifier < corelabel > ( p ) ; try { classifier . loadclassifier ( file , p ) ; } catch ( classcastexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } }	load a serialized model .
public string resolvefont ( java . awt . font font ) { string ret = _str ; ret = ret . concat ( _str + font . getname ( ) ) ; if ( font . isbold ( ) ) ret = ret . concat ( _str ) ; else ret = ret . concat ( _str ) ; if ( font . isitalic ( ) ) ret = ret . concat ( _str ) ; else ret = ret . concat ( _str ) ; ret = ret . concat ( _str ) ; ret = ret . concat ( _str + font . getsize ( ) ) ; ret = ret . concat ( _str ) ; ret = ret . concat ( _str ) ; ret = ret . concat ( _str ) ; ret = ret . concat ( _str ) ; ret = ret . concat ( _str ) ; ret = ret . concat ( _str ) ; return ret ; }	in the idl , fonts are represented by a string.
public void addlinecontent ( final zylinecontent line ) { preconditions . checknotnull ( line , _str ) ; m_content . add ( line ) ; }	adds another line add the end of the label content .
public static boolean excludebypackage ( string pkg , list < string > excludepkg ) { for ( string ep : excludepkg ) { if ( pkg . matches ( ep ) ) { return _bool ; } } return _bool ; }	compare a package with a list of packages to determine whether the package should be excluded or not .
public regionversionholder ( long ver ) { this . version = ver ; }	this contructor should only be used for cloning a regionversionholder or initializing and invalid version holder ( with version - 1 ).
public static void writefully ( filechannel file , long pos , bytebuffer src ) { try { int off = _num ; do { int len = file . write ( src , pos + off ) ; off += len ; } while ( src . remaining ( ) > _num ) ; } catch ( ioexception e ) { throw newillegalstateexception ( error_writing_failed , _str , file , src . remaining ( ) , pos , e ) ; } }	write to a file channel .
public void updaterequesttimeout ( timespan span ) throws securityexception , applicationexception { checkwriteaccess ( ) ; boolean hasaccess = configwebutil . hasaccess ( config , securitymanager . type_setting ) ; if ( ! hasaccess ) throw new securityexception ( _str ) ; element scope = _getrootelement ( _str ) ; element application = _getrootelement ( _str ) ; if ( span != null ) { if ( span . getmillis ( ) <= _num ) throw new applicationexception ( _str ) ; application . setattribute ( _str , span . getday ( ) + _str + span . gethour ( ) + _str + span . getminute ( ) + _str + span . getsecond ( ) ) ; } else application . removeattribute ( _str ) ; if ( scope . hasattribute ( _str ) ) scope . removeattribute ( _str ) ; }	updates request timeout value.
@ override protected boolean calcproblem ( ) { string type = gettagwithkey ( tags . key_type ) ; if ( type == null || type . equals ( _str ) ) { return _bool ; } return super . calcproblem ( ) ; }	test if the relation has a problem .
public int readbyte ( ) throws ioexception { ++ length ; return in . read ( ) & _num ; }	read the next byte from the inputstream .
public void updateshapeshadowstocurrenttime ( boolean updateminutes , boolean updatehours , int currentminute , int currenthour ) { if ( updateminutes ) { int tens = ( int ) math . floor ( currentminute / _num ) ; int units = ( int ) math . floor ( currentminute % _num ) ; if ( minutestens . getcurrentvalue ( ) != tens ) { string mt = string . format ( _str , tens ) ; mt = mt . concat ( _str ) ; log . d ( tag , _str + mt ) ; minutestens . parsejson ( mt ) ; } if ( minutesunits . getcurrentvalue ( ) != units ) { string mu = string . format ( _str , units ) ; mu = mu . concat ( _str ) ; log . d ( tag , _str + mu ) ; minutesunits . parsejson ( mu ) ; } } if ( updatehours ) { int tens = ( int ) math . floor ( currenthour / _num ) ; int units = ( int ) math . floor ( currenthour % _num ) ; if ( hourstens . getcurrentvalue ( ) != tens ) { string ht = string . format ( _str , tens ) ; ht = ht . concat ( _str ) ; log . d ( tag , _str + ht ) ; hourstens . parsejson ( ht ) ; } if ( hoursunits . getcurrentvalue ( ) != units ) { string hu = string . format ( _str , units ) ; hu = hu . concat ( _str ) ; log . d ( tag , _str + hu ) ; hoursunits . parsejson ( hu ) ; } } }	updates the shadows of the numbers to the current time.
public set < rawprotein < superfamilyhmmer3rawmatch > > parse ( inputstream is ) throws ioexception { map < string , rawprotein < superfamilyhmmer3rawmatch > > data = new hashmap < string , rawprotein < superfamilyhmmer3rawmatch > > ( ) ; bufferedreader reader = null ; try { reader = new bufferedreader ( new inputstreamreader ( is ) ) ; string line ; while ( ( line = reader . readline ( ) ) != null ) { set < superfamilyhmmer3rawmatch > rawmatches = parseline ( line ) ; superfamilyhmmer3rawmatch rawmatch ; for ( superfamilyhmmer3rawmatch rawmatche : rawmatches ) { rawmatch = rawmatche ; string sequenceid = rawmatch . getsequenceidentifier ( ) ; if ( data . containskey ( sequenceid ) ) { rawprotein < superfamilyhmmer3rawmatch > rawprotein = data . get ( sequenceid ) ; rawprotein . addmatch ( rawmatch ) ; } else { rawprotein < superfamilyhmmer3rawmatch > rawprotein = new rawprotein < superfamilyhmmer3rawmatch > ( sequenceid ) ; rawprotein . addmatch ( rawmatch ) ; data . put ( sequenceid , rawprotein ) ; } } } } finally { if ( reader != null ) { reader . close ( ) ; } } return new hashset < rawprotein < superfamilyhmmer3rawmatch > > ( data . values ( ) ) ; }	parse the temporary file.
public string relationname ( ) { return m_relationname ; }	returns the relation ' s name .
@ requestmapping ( value = _str , method = requestmethod . post , produces = mediatype . text_plain_value ) @ timed public responseentity < ? > changepassword ( @ requestbody string password ) { if ( ! checkpasswordlength ( password ) ) { return new responseentity < > ( _str , httpstatus . bad_request ) ; } userservice . changepassword ( password ) ; return new responseentity < > ( httpstatus . ok ) ; }	post / account / change_password : changes the current user ' s password.
public void testbadsegment ( ) throws ioexception { directory dir = newdirectory ( ) ; indexwriter iw = new indexwriter ( dir , newindexwriterconfig ( new mockanalyzer ( random ( ) ) ) ) ; document document = new document ( ) ; fieldtype customtype = new fieldtype ( textfield . type_not_stored ) ; customtype . setstoretermvectors ( _bool ) ; document . add ( newfield ( _str , _str , customtype ) ) ; iw . adddocument ( document ) ; iw . close ( ) ; dir . close ( ) ; }	test that no nullpointerexception will be raised , when adding one document with a single , empty field and term vectors enabled .
public static int size ( string str ) { if ( str == null ) return _num ; int length = str . length ( ) ; int size = length ; try { size = str . getbytes ( _str ) . length ; } catch ( unsupportedencodingexception e ) { log . log ( level . severe , str , e ) ; } return size ; }	size of string in bytes.
protected void synchwithtarget ( ) throws monitorexception { long timelimit = system . currenttimemillis ( ) + syncwaitms ; log ( _str + lvmid + _str ) ; while ( ! prologue . isaccessible ( ) ) { log ( _str ) ; try { thread . sleep ( _num ) ; } catch ( interruptedexception e ) { } if ( system . currenttimemillis ( ) > timelimit ) { logln ( _str + lvmid ) ; throw new monitorexception ( _str ) ; } } logln ( _str + lvmid ) ; }	method that waits until the target jvm indicates that its shared memory is safe to access .
public static charsequence time ( context context , easycursor c ) { long now = system . currenttimemillis ( ) ; long when = c . getlong ( reviews . written_on ) ; return now - when > minute_in_millis ? dateutils . getrelativetimespanstring ( when , now , _num , format_abbrev_all ) : context . getstring ( r . string . recent_time ) ; }	get when the review was written .
private double screentonormalized ( float screencoord ) { int width = getwidth ( ) ; if ( width <= _num * padding ) { return _num ; } else { double result = ( screencoord - padding ) / ( width - _num * padding ) ; return math . min ( _num , math . max ( _num , result ) ) ; } }	converts screen space x - coordinates into normalized values .
public long roundtriptime ( ) throws interruptedexception { latch . await ( ) ; return received - sent ; }	returns the round trip time for this ping in nanoseconds , waiting for the response to arrive if necessary.
static private string useridfromrange ( string [ ] values , boolean include ) { int minid = integer . parseint ( values [ _num ] ) ; int maxid = integer . parseint ( values [ _num ] ) ; string exclusions = values . length > _num ? values [ _num ] : null ; stack < integer > stack = getstack ( minid , maxid , exclusions , include ) ; if ( stack . size ( ) > _num ) { return integer . tostring ( stack . pop ( ) ) ; } throw new illegalargumentexception ( _str ) ; }	generate a random user id as an integer.
public void testcase4 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num } ; byte rbytes [ ] = { - _num , - _num , - _num , - _num , - _num , - _num , - _num } ; int asign = - _num ; int bsign = _num ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . add ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , result . signum ( ) ) ; }	add two numbers of the same length.
public void actualizacampo ( int tipoficha , valorcampogenericovo campo ) { valorcampogenericovo campoanterior = retrieve ( tipoficha , campo . gettipo ( ) , campo . getidobjeto ( ) , campo . getidcampo ( ) , campo . getorden ( ) , campo . gettipoelemento ( ) ) ; if ( campoanterior == null ) insert ( tipoficha , campo ) ; else update ( tipoficha , campo , campoanterior . getvalorinfo ( ) ) ; }	actualiza el campo de la ficha .
public static int length ( regexp re ) { regexp2 r ; switch ( re . type ) { case sym . bar : { r = ( regexp2 ) re ; int l1 = length ( r . r1 ) ; if ( l1 < _num ) return - _num ; int l2 = length ( r . r2 ) ; if ( l1 == l2 ) return l1 ; else return - _num ; } case sym . concat : { r = ( regexp2 ) re ; int l1 = length ( r . r1 ) ; if ( l1 < _num ) return - _num ; int l2 = length ( r . r2 ) ; if ( l2 < _num ) return - _num ; return l1 + l2 ; } case sym . star : case sym . plus : case sym . question : return - _num ; case sym . cclass : case sym . cclassnot : case sym . char : case sym . char_i : return _num ; case sym . string : case sym . string_i : { string content = ( string ) ( ( regexp1 ) re ) . content ; return content . length ( ) ; } case sym . tilde : case sym . bang : return - _num ; case sym . macrouse : return length ( macros . getdefinition ( ( string ) ( ( regexp1 ) re ) . content ) ) ; } throw new error ( _str + re . type + _str + re ) ; }	returns length if expression has fixed length , - 1 otherwise.
public static timezone randomtimezone ( random random ) { string tzids [ ] = timezone . getavailableids ( ) ; return timezone . gettimezone ( tzids [ random . nextint ( tzids . length ) ] ) ; }	return a random timezone from the available timezones on the system.
public static string arraytolist ( string [ ] array , string delimiter ) { if ( arrayutil . isempty ( array ) ) return _str ; stringbuilder sb = new stringbuilder ( array [ _num ] ) ; if ( delimiter . length ( ) == _num ) { char c = delimiter . charat ( _num ) ; for ( int i = _num ; i < array . length ; i ++ ) { sb . append ( c ) ; sb . append ( array [ i ] ) ; } } else { for ( int i = _num ; i < array . length ; i ++ ) { sb . append ( delimiter ) ; sb . append ( array [ i ] ) ; } } return sb . tostring ( ) ; }	convert a string array to string list.
@ override public boolean addall ( collection < ? extends e > c ) { iterator < ? extends e > i = c . iterator ( ) ; boolean changed = _bool ; while ( i . hasnext ( ) ) { boolean ret = add ( i . next ( ) ) ; if ( ! changed ) { changed = ret ; } } return changed ; }	add all of the elements in the given collection to this list .
public void reset ( ) { mcodes . clear ( ) ; misfirstcharcapitalized = _bool ; mpreferredword = null ; mtypedword . setlength ( _num ) ; mcapscount = _num ; }	clear out the keys registered so far .
private string extractpath ( final string uri ) { return defaultwildcardstreamlocator . stripquerypath ( uri . replace ( prefix , stringutils . empty ) ) ; }	replaces the protocol specific prefix and removes the query path if it exist , since it should not be accepted .
public void addclassestocheck ( file basedir , string ... relativenames ) throws ioexception { addclassestocheck ( basedir , arrays . aslist ( relativenames ) ) ; }	parses and adds a multiple class files .
public static short toshort ( string str ) throws pageexception { return short . valueof ( toshortvalue ( str ) ) ; }	cast a object to a byte object ( reference type ).
public void testreadxmllangnewstyle ( ) throws exception { properties result = xmltoproperties ( _str ) ; assertnotnull ( result ) ; asserttrue ( ! result . isempty ( ) ) ; assertequals ( _num , result . size ( ) ) ; assertequals ( _str , result . getproperty ( _str ) ) ; }	new ( and correct ) style xml : lang value is en - au.
public boolean haspermission ( security security , genericvalue userlogin ) { return orderreadhelper . haspermission ( security , userlogin , orderheader ) ; }	checks to see if this user has read permission on this order.
protected boolean filterfiles ( list < file > files ) { if ( task . getnomtimecheck ( ) || isoutputrepositoryurl ( ) ) { return _bool ; } iterator < file > iter = files . iterator ( ) ; while ( iter . hasnext ( ) ) { file file = iter . next ( ) ; module module = infermodule ( file ) ; if ( module == null ) { task . log ( _str + file , project . msg_verbose ) ; continue ; } if ( module . getversion ( ) == null ) { task . log ( _str + module . getname ( ) , project . msg_verbose ) ; continue ; } long oldest = getartifactfiletime ( module , file ) ; if ( oldest == long . max_value ) { file outmoduledir = getartifactdir ( module ) ; oldest = oldestoutputartifact ( long . max_value , outmoduledir ) ; task . log ( _str + module + _str + new date ( oldest ) , project . msg_debug ) ; } else { task . log ( _str + file + _str + module + _str + new date ( oldest ) , project . msg_debug ) ; } long newestfile = file . lastmodified ( ) ; task . log ( _str + file + _str + new date ( newestfile ) , project . msg_debug ) ; if ( newestfile != long . min_value && oldest != long . max_value && newestfile < oldest ) { task . log ( _str + file + _str ) ; iter . remove ( ) ; } } return files . size ( ) == _num ; }	filters out all the source files which appear to not require compilation based on comparison of file modification times.
public void flush ( ) { outputstream . flush ( ) ; }	clears all buffers for the current writer and causes any buffered data to be written to the underlying device .
public int createmeasures ( mslagoal goal ) { string sql = _str + _str + _str + _str + _str + _str + _str + _str + _str + minout . table_id + _str ; int counter = _num ; preparedstatement pstmt = null ; resultset rs = null ; try { pstmt = db . preparestatement ( sql , null ) ; pstmt . setint ( _num , goal . getc_bpartner_id ( ) ) ; pstmt . setint ( _num , goal . getpa_sla_goal_id ( ) ) ; rs = pstmt . executequery ( ) ; while ( rs . next ( ) ) { int m_inout_id = rs . getint ( _num ) ; bigdecimal measureactual = rs . getbigdecimal ( _num ) ; timestamp movementdate = rs . gettimestamp ( _num ) ; string description = rs . getstring ( _num ) + _str + rs . gettimestamp ( _num ) ; if ( goal . isdatevalid ( movementdate ) ) { mslameasure measure = new mslameasure ( goal , movementdate , measureactual , description ) ; measure . setlink ( minout . table_id , m_inout_id ) ; if ( measure . save ( ) ) counter ++ ; } } } catch ( exception e ) { log . log ( level . severe , _str , e ) ; } finally { db . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } return counter ; }	create new measures for the goal.
@ override public string resolvevideourl ( @ nullable final video video , step step ) { if ( video == null ) return null ; string localpath = databasefacade . getpathtovideoifexist ( video ) ; if ( localpath != null && checkexistingondisk ( localpath , step ) ) { return localpath ; } else { list < videourl > urllist = video . geturls ( ) ; if ( urllist == null || urllist . size ( ) == _num ) return null ; return resolvefromweb ( urllist ) ; } }	don ' t call in main thread.
protected object lookupservice ( ) throws exception { object service = null ; servicetemplate templ ; if ( template == null ) { class < ? > [ ] types = ( serviceclass == null ? null : new class [ ] { serviceclass } ) ; entry [ ] entry = ( servicename == null ? null : new entry [ ] { new name ( servicename ) } ) ; templ = new servicetemplate ( null , types , entry ) ; } else { templ = template ; } lookuplocator [ ] lookuplocators = null ; if ( locators != null ) { lookuplocators = new lookuplocator [ locators . length ] ; for ( int i = _num ; i < locators . length ; i ++ ) { string locator = locators [ i ] ; if ( ! locator . startswith ( _str ) ) { locator = _str + locator ; } lookuplocators [ i ] = new lookuplocator ( locator ) ; } } servicediscoverymanager servicediscovery = null ; try { servicediscovery = shareddiscoverymanagement . getbackwardsservicediscoverymanager ( groups , lookuplocators , null ) ; serviceitem returnobject = servicediscovery . lookup ( templ , null , timeout ) ; if ( returnobject != null ) { service = returnobject . service ; } } finally { if ( servicediscovery != null ) { try { servicediscovery . terminate ( ) ; } catch ( exception e ) { logger . warn ( _str , e ) ; } } } return service ; }	a helper method to lookup the service .
public static boolean equals ( final object obj1 , final object obj2 ) { return ( obj1 != null && obj1 . equals ( obj2 ) ) ; }	determines whether 2 objects are equal in value.
public void testmergesamefilterwithinitparamintwodocuments ( ) throws exception { string srcxml = _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str ; webxml srcwebxml = webxmlio . parsewebxml ( new bytearrayinputstream ( srcxml . getbytes ( _str ) ) , null ) ; string mergexml = _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str ; webxml mergewebxml = webxmlio . parsewebxml ( new bytearrayinputstream ( mergexml . getbytes ( _str ) ) , null ) ; webxmlmerger merger = new webxmlmerger ( srcwebxml ) ; merger . mergefilters ( mergewebxml ) ; asserttrue ( webxmlutils . hasfilter ( srcwebxml , _str ) ) ; list < string > filterinitparamnames = webxmlutils . getfilterinitparamnames ( srcwebxml , _str ) ; asserttrue ( filterinitparamnames . size ( ) == _num ) ; assertequals ( _str , filterinitparamnames . get ( _num ) ) ; list < string > filtermappings = webxmlutils . getfiltermappings ( srcwebxml , _str ) ; assertequals ( _num , filtermappings . size ( ) ) ; assertequals ( _str , filtermappings . get ( _num ) ) ; }	tests whether the same filter in two different files is mapped correctly ( i.
public webapptemplateloader ( servletcontext servletcontext , string subdirpath ) { if ( servletcontext == null ) { throw new illegalargumentexception ( _str ) ; } if ( subdirpath == null ) { throw new illegalargumentexception ( _str ) ; } subdirpath = subdirpath . replace ( _str , _str ) ; if ( ! subdirpath . endswith ( _str ) ) { subdirpath += _str ; } if ( ! subdirpath . startswith ( _str ) ) { subdirpath = _str + subdirpath ; } this . subdirpath = subdirpath ; this . servletcontext = servletcontext ; }	creates a template loader that will use the specified servlet context to load the resources.
@ suppresswarnings ( { _str } ) public static < t > t [ ] insert ( t [ ] dest , t src , int offset , class componenttype ) { t [ ] temp = ( t [ ] ) array . newinstance ( componenttype , dest . length + _num ) ; system . arraycopy ( dest , _num , temp , _num , offset ) ; temp [ offset ] = src ; system . arraycopy ( dest , offset , temp , offset + _num , dest . length - offset ) ; return temp ; }	inserts one element into another array .
@ override public void flush ( ) throws ioexception { writer . write ( buffer , _num , fill ) ; fill = _num ; }	flushes the internal buffer but does not flush the wrapped writer .
public metricinstance withdependencymetricnames ( list < string > dependencymetricnames ) { return new metricinstance ( metricname , maker , dependencymetricnames . toarray ( new string [ dependencymetricnames . size ( ) ] ) ) ; }	makes a copy of the metric instance with new dependencymetricnames .
public static istatus validatemethodname ( string name ) { return validatemethodname ( name , compileroptions . version_1_3 , compileroptions . version_1_3 ) ; }	validate the given method name.
@ suppresswarnings ( _str ) void notifyalarmclock ( timeralarmclocknotification notification ) { timernotification timernotification = null ; date timerdate = null ; timeralarmclock alarmclock = ( timeralarmclock ) notification . getsource ( ) ; synchronized ( timer . this ) { for ( object [ ] obj : timertable . values ( ) ) { if ( obj [ alarm_clock_index ] == alarmclock ) { timernotification = ( timernotification ) obj [ timer_notif_index ] ; timerdate = ( date ) obj [ timer_date_index ] ; break ; } } } sendnotification ( timerdate , timernotification ) ; updatetimertable ( timernotification . getnotificationid ( ) ) ; }	this method is called by the timer each time the timeralarmclock has exceeded its timeout .
public profilerentity start ( ) { start_time = system . nanotime ( ) ; return this ; }	start the entity . call this when you are ready to start measuring . returns itself for easy chaining .
public static < e extends enum < e > > enumset < e > of ( e e1 , e e2 , e e3 ) { enumset < e > set = of ( e1 , e2 ) ; set . add ( e3 ) ; return set ; }	creates a new enum set , containing only the specified elements.
public pickrequest withcamerapicsdirectory ( @ nullable final file pdirfile ) { this . mcustomcamerapicsdirpath = pdirfile == null ? null : pdirfile . getabsolutepath ( ) ; return this ; }	set a directory to which pictures taken by camera will be saved . useful only when camera is a pick source.
public void preparefornextrun ( ) { for ( int i = _num ; i < _num ; i ++ ) { system . gc ( ) ; try { thread . sleep ( _num ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } }	try to give gc some time to settle down .
public void add ( chip chip ) { if ( ! mchiplist . contains ( chip ) || mtoleratingduplicate ) { mchiplist . add ( chip ) ; notifyupdate ( ) ; } }	wrapper to add a chip.
private boolean checktripzoneconsistency ( ) { log . info ( _str ) ; hashset < string > missingzones = new hashset < string > ( ) ; for ( trip t : trips . values ( ) ) { basiclocation zo = zones . getlocation ( id . create ( t . zone_o , zone . class ) ) ; basiclocation zd = zones . getlocation ( id . create ( t . zone_d , zone . class ) ) ; if ( zo == null ) { missingzones . add ( t . zone_o ) ; } if ( zd == null ) { missingzones . add ( t . zone_d ) ; } } if ( missingzones . size ( ) > _num ) { string msg = missingzones . size ( ) + _str ; for ( string s : missingzones ) msg += _str + s . tostring ( ) + _str ; log . error ( msg ) ; return _bool ; } else log . info ( _str ) ; return _bool ; }	checks that all trips start and end in zones represented in the zones file .
private int insertindexforlayer ( component comp , int layer , int position ) { int i , count , curlayer ; int layerstart = - _num ; int layerend = - _num ; int componentcount = getcomponentcount ( ) ; arraylist < component > complist = new arraylist < component > ( componentcount ) ; for ( int index = _num ; index < componentcount ; index ++ ) { if ( getcomponent ( index ) != comp ) { complist . add ( getcomponent ( index ) ) ; } } count = complist . size ( ) ; for ( i = _num ; i < count ; i ++ ) { curlayer = getlayer ( complist . get ( i ) ) ; if ( layerstart == - _num && curlayer == layer ) { layerstart = i ; } if ( curlayer < layer ) { if ( i == _num ) { layerstart = _num ; layerend = _num ; } else { layerend = i ; } break ; } } if ( layerstart == - _num && layerend == - _num ) return count ; if ( layerstart != - _num && layerend == - _num ) layerend = count ; if ( layerend != - _num && layerstart == - _num ) layerstart = layerend ; if ( position == - _num ) return layerend ; if ( position > - _num && layerstart + position <= layerend ) return layerstart + position ; return layerend ; }	this method is an extended version of insertindexforlayer ( ) to support setlayer which uses container.
public void testtimedinvokeall2 ( ) throws interruptedexception { executorservice e = new forkjoinpool ( _num ) ; poolcleaner cleaner = null ; try { cleaner = cleaner ( e ) ; list < future < string > > r = e . invokeall ( new arraylist < callable < string > > ( ) , medium_delay_ms , milliseconds ) ; asserttrue ( r . isempty ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }	timed invokeall ( empty collection ) returns empty collection.
public static waitdialog showdialog ( waitdialog . runnable runnable , string message , container container , int width , int height ) { waitdialog newdialog = null ; if ( container instanceof jdialog ) { newdialog = new waitdialog ( ( jdialog ) container ) ; } else if ( container instanceof jframe ) { newdialog = new waitdialog ( ( jframe ) container ) ; } else { newdialog = new waitdialog ( ( jdialog ) null ) ; newdialog . setlocationrelativeto ( container ) ; } newdialog . builddialog ( width , height ) ; runnable . setdialog ( newdialog ) ; newdialog . container = container ; newdialog . runnable = runnable ; newdialog . setmessage ( message ) ; thread processthread = new processthread ( newdialog ) ; processthread . start ( ) ; while ( ! newdialog . isvisible ( ) ) { try { thread . sleep ( _num ) ; } catch ( interruptedexception ie ) { } } return newdialog ; }	will display message in a modal jdialog while in the run method of runnable . will set the location of the jdialog relative to container.
public void testflipbitpositiveoutside2 ( ) { byte abytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = _num ; int number = _num ; byte rbytes [ ] = { _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . flipbit ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	flipbit ( int n ) outside a positive number.
public synchronized void write ( byte b [ ] , int off , int len ) throws ioexception { if ( len <= _num ) return ; int freespace = buffer . length - pos ; if ( len <= freespace ) { system . arraycopy ( b , off , buffer , pos , len ) ; pos += len ; return ; } flush ( ) ; int local_requested ; while ( _bool ) { synchronized ( lock ) { while ( ( local_requested = requested ) < _num && ! disconnected ) { try { lock . wait ( ) ; } catch ( interruptedexception e ) { } } if ( disconnected ) throw new ioexception ( _str ) ; } if ( local_requested < len ) { manager . sendtransmit ( info , b , off , local_requested ) ; off += local_requested ; len -= local_requested ; synchronized ( lock ) { requested -= local_requested ; } } else { manager . sendtransmit ( info , b , off , len ) ; synchronized ( lock ) { requested -= len ; } break ; } } }	write a subarray of bytes over connection .
protected alarm ( ) { this ( _str ) ; }	create a new wakeup alarm with a designated listener as a callback.
public void removemousemode ( mapmousemode med ) { boolean needtoadjustactivemode = _bool ; if ( med == null ) { return ; } if ( med . equals ( activemousemode ) ) { needtoadjustactivemode = _bool ; setinactive ( med ) ; } for ( mapmousemode checkmm : mousemodes ) { if ( med . equals ( checkmm ) ) { med . removeallmapmouselisteners ( ) ; } else if ( needtoadjustactivemode ) { setactive ( checkmm ) ; needtoadjustactivemode = _bool ; } } mousemodes . remove ( med ) ; firepropertychange ( mousemodesproperty , null , mousemodes ) ; }	removes a particular mapmousemode from the mousemode list .
@ override public boolean hasdispatchfunction ( ) { return _bool ; }	cbus does not have a dispatch function.
public void addmap ( map < k , v > map , k min , k max ) { if ( min != null && max != null && keytype . compare ( min , max ) > _num ) { datautils . newillegalargumentexception ( _str , min , max ) ; } int len = shards . length + _num ; shard < k , v > [ ] newshards = arrays . copyof ( shards , len ) ; shard < k , v > newshard = new shard < k , v > ( ) ; newshard . map = map ; newshard . minincluding = min ; newshard . maxexcluding = max ; newshards [ len - _num ] = newshard ; shards = newshards ; }	add the given shard .
private void retryfailedinterfaces ( ) { for ( iterator i = failedinterfaces . iterator ( ) ; i . hasnext ( ) ; ) { networkinterface nic = ( networkinterface ) i . next ( ) ; try { if ( nic != null ) { socket . setnetworkinterface ( nic ) ; } socket . joingroup ( requestaddr ) ; i . remove ( ) ; level l = multicastinterfacesspecified ? level . info : level . fine ; if ( logger . isloggable ( l ) ) { if ( nic != null ) { logger . log ( l , _str , new object [ ] { nic } ) ; } else { logger . log ( l , _str ) ; } } } catch ( ioexception e ) { } } }	attempts to configure each interface contained in the failedinterfaces list , removing it from the list if configuration succeeds.
public void writeheader ( ) throws ioexception { flvheader flvheader = new flvheader ( ) ; flvheader . setflagaudio ( _bool ) ; flvheader . setflagvideo ( _bool ) ; bytebuffer header = bytebuffer . allocate ( header_length + _num ) ; flvheader . write ( header ) ; file . setlength ( header_length + _num ) ; if ( header . hasarray ( ) ) { log . debug ( _str ) ; file . write ( header . array ( ) ) ; } else { log . debug ( _str ) ; byte [ ] tmp = new byte [ header_length + _num ] ; header . get ( tmp ) ; file . write ( tmp ) ; } byteswritten = file . length ( ) ; header . clear ( ) ; }	writes the header bytes.
public static future < ? > submit ( runnable task ) { return thread_pool . submit ( task ) ; }	submits a runnable task for execution and returns a future representing that task .
public boolean addoverlay ( overlay overlay , kmldocument kmldoc ) { if ( overlay == null ) return _bool ; kmlfeature kmlitem ; if ( overlay instanceof groundoverlay ) { kmlitem = new kmlgroundoverlay ( ( groundoverlay ) overlay ) ; } else if ( overlay instanceof folderoverlay ) { kmlitem = new kmlfolder ( ( folderoverlay ) overlay , kmldoc ) ; } else if ( overlay instanceof markerclusterer ) { kmlitem = new kmlfolder ( ( markerclusterer ) overlay , kmldoc ) ; } else if ( overlay instanceof marker ) { marker marker = ( marker ) overlay ; kmlitem = new kmlplacemark ( marker ) ; } else if ( overlay instanceof polygon ) { polygon polygon = ( polygon ) overlay ; kmlitem = new kmlplacemark ( polygon , kmldoc ) ; } else if ( overlay instanceof polyline ) { polyline polyline = ( polyline ) overlay ; kmlitem = new kmlplacemark ( polyline , kmldoc ) ; } else { return _bool ; } mitems . add ( kmlitem ) ; return _bool ; }	converts the overlay to a kmlfeature and add it inside this.
private < t extends sbresource > t lookforresource ( sbresourcetype type , class < t > clazz ) { list < t > resources = lookforresources ( type , clazz ) ; return resources != null && resources . size ( ) > _num ? resources . get ( _num ) : null ; }	find one resource by type.
private object produceevent ( ) throws invocationtargetexception { if ( ! valid ) { throw new illegalstateexception ( tostring ( ) + _str ) ; } try { return method . invoke ( target ) ; } catch ( illegalaccessexception e ) { throw new assertionerror ( e ) ; } catch ( invocationtargetexception e ) { if ( e . getcause ( ) instanceof error ) { throw ( error ) e . getcause ( ) ; } throw e ; } }	invokes the wrapped producer method .
private list < float > createdasharray ( string dashstring ) { string [ ] dashes = dashstring . split ( _str ) ; list < float > floatdasharray = new arraylist < float > ( ) ; for ( string dashvalue : dashes ) { try { floatdasharray . add ( float . parsefloat ( dashvalue ) ) ; } catch ( numberformatexception e ) { return null ; } } return floatdasharray ; }	creates the dash array .
public void cleanpatchbyversion ( string versionname ) { if ( patchdirectory == null || versionname == null ) { return ; } string path = patchdirectory . getabsolutepath ( ) + _str + versionname ; sharepatchfileutil . deletedir ( path ) ; }	clean the patch version files , such as tinker / patch - 641e634c.
public static boolean isvalidjavaclassname ( string input ) { if ( ! stringutils . hastext ( input ) ) { return _bool ; } if ( ! character . isjavaidentifierstart ( input . charat ( _num ) ) ) { return _bool ; } if ( input . length ( ) > _num ) { for ( int i = _num ; i < input . length ( ) ; i ++ ) { if ( ! character . isjavaidentifierpart ( input . charat ( i ) ) ) { return _bool ; } } } return _bool ; }	utility method to check if a string can be used as a valid class name.
public void test_create_empty ( ) { final string id = _str ; final map < string , object > metadata = new hashmap < string , object > ( ) ; metadata . put ( filemetadataschema . id , id ) ; metadata . put ( _str , _str ) ; final int version = repo . create ( metadata ) ; metadata . put ( filemetadataschema . version , integer . valueof ( version ) ) ; assertequals ( _str , _num , version ) ; repositorydocumentimpl doc = ( repositorydocumentimpl ) repo . read ( id ) ; asserttrue ( _str , doc . exists ( ) ) ; assertequals ( _str , version , doc . getversion ( ) ) ; assertnotsame ( _str , _num , doc . getversioncreatetime ( ) ) ; assertequals ( _str , doc . getversioncreatetime ( ) , doc . getearliestversioncreatetime ( ) ) ; assertequals ( _str , doc . getversioncreatetime ( ) , doc . getmetadataupdatetime ( ) ) ; map < string , object > actual = doc . asmap ( ) ; assertequals ( _str , id , actual . get ( filemetadataschema . id ) ) ; assertequals ( _str , version , actual . get ( filemetadataschema . version ) ) ; assertequals ( _str , _str , actual . get ( _str ) ) ; assertequals ( _str , metadata . size ( ) , actual . size ( ) ) ; }	create an empty file and verify its metadata .
public static string rename ( string desc , string oldname , string newname ) { if ( desc . indexof ( oldname ) < _num ) return desc ; stringbuffer newdesc = new stringbuffer ( ) ; int head = _num ; int i = _num ; for ( ; ; ) { int j = desc . indexof ( _str , i ) ; if ( j < _num ) break ; else if ( desc . startswith ( oldname , j + _num ) && desc . charat ( j + oldname . length ( ) + _num ) == _str ) { newdesc . append ( desc . substring ( head , j ) ) ; newdesc . append ( _str ) ; newdesc . append ( newname ) ; newdesc . append ( _str ) ; head = i = j + oldname . length ( ) + _num ; } else { i = desc . indexof ( _str , j ) + _num ; if ( i < _num ) break ; } } if ( head == _num ) return desc ; else { int len = desc . length ( ) ; if ( head < len ) newdesc . append ( desc . substring ( head , len ) ) ; return newdesc . tostring ( ) ; } }	substitutes a class name in the given descriptor string .
public void sort ( int attindex ) { double [ ] vals = new double [ numinstances ( ) ] ; instance [ ] backup = new instance [ vals . length ] ; for ( int i = _num ; i < vals . length ; i ++ ) { instance inst = instance ( i ) ; backup [ i ] = inst ; double val = inst . value ( attindex ) ; if ( utils . ismissingvalue ( val ) ) { vals [ i ] = double . max_value ; } else { vals [ i ] = val ; } } int [ ] sortorder = utils . sortwithnomissingvalues ( vals ) ; for ( int i = _num ; i < vals . length ; i ++ ) { m_instances . set ( i , backup [ sortorder [ i ] ] ) ; } }	sorts the instances based on an attribute.
private static byte callbytemethodv ( jnienvironment env , int objjref , int methodid , address argaddress ) throws exception { if ( tracejni ) vm . syswrite ( _str ) ; runtimeentrypoints . checkjnicountdowntogc ( ) ; try { object obj = env . getjniref ( objjref ) ; object returnobj = jnihelpers . invokewithvararg ( obj , methodid , argaddress , typereference . byte , _bool ) ; return reflection . unwrapbyte ( returnobj ) ; } catch ( throwable unexpected ) { if ( tracejni ) unexpected . printstacktrace ( system . err ) ; env . recordexception ( unexpected ) ; return _num ; } }	callbytemethodv : invoke a virtual method that returns a byte value.
public boolean adjustentry ( e entry ) { final spatialdirectoryentry se = ( spatialdirectoryentry ) entry ; final modifiablehyperboundingbox mbr = computembr ( ) ; boolean changed = _bool ; if ( se . hasmbr ( ) ) { final int dim = se . getdimensionality ( ) ; for ( int i = _num ; i < dim ; i ++ ) { if ( math . abs ( se . getmin ( i ) - mbr . getmin ( i ) ) > float . min_normal ) { changed = _bool ; break ; } if ( math . abs ( se . getmax ( i ) - mbr . getmax ( i ) ) > float . min_normal ) { changed = _bool ; break ; } } } else { changed = _bool ; } if ( changed ) { se . setmbr ( mbr ) ; } return changed ; }	adjusts the parameters of the entry representing this node .
private void traceobject ( objectreference object , boolean root ) { if ( verbose ) { trace . trace ( item . sanity , _str , objectmodel . getstring ( object ) ) ; } if ( object . isnull ( ) ) return ; boolean marked = blackset . contains ( object ) ; if ( ! marked ) { blackset . add ( object ) ; markstack . add ( object ) ; } visitor . visitobject ( object , root , marked ) ; }	trace an object , calling the appropriate visitor method.
private static int compare ( int fromindex , charsequence left , charsequence right ) { if ( left == null ) return - _num ; if ( right == null ) return _num ; for ( int i = fromindex , n = mathlib . min ( left . length ( ) , right . length ( ) ) ; i < n ; i ++ ) { char c1 = character . touppercase ( left . charat ( i ) ) ; char c2 = character . touppercase ( right . charat ( i ) ) ; if ( c1 != c2 ) return c1 - c2 ; } return left . length ( ) - right . length ( ) ; }	compares the two characters sequences starting at the specified index.
public boolean restoreaccessibilityfocus ( calendarday day ) { if ( ( day . year != myear ) || ( day . month != mmonth ) || ( day . day > mnumcells ) ) { return _bool ; } mtouchhelper . setfocusedvirtualview ( day . day ) ; return _bool ; }	attempts to restore accessibility focus to the specified date .
@ override public int hashcode ( ) { if ( hash == _num ) { int result = _num ; result = _num * result + range . hashcode ( ) ; long bitsweight = double . doubletolongbits ( weight ) ; result = _num * result + ( int ) ( bitsweight ^ ( bitsweight > > > _num ) ) ; hash = result ; } return hash ; }	returns a hash code value for the object .
@ override public void onclick ( view v ) { int position = math . min ( ( integer ) v . gettag ( ) , mitemlist . size ( ) - _num ) ; mselectedtracker = mitemlist . get ( position ) ; mtoggleconfighandler . showforselectedtoggle ( ) ; mtoggleconfighandler . showatlocation ( v ) ; mtoggleconfighandler . setarrowposition ( v ) ; }	called when a toggle button is clicked .
private int readfromdatasource ( byte [ ] target , int offset , int length , int bytesalreadyread , boolean allowendofinput ) throws interruptedexception , ioexception { if ( thread . interrupted ( ) ) { throw new interruptedexception ( ) ; } int bytesread = datasource . read ( target , offset + bytesalreadyread , length - bytesalreadyread ) ; if ( bytesread == c . result_end_of_input ) { if ( bytesalreadyread == _num && allowendofinput ) { return c . result_end_of_input ; } throw new eofexception ( ) ; } return bytesalreadyread + bytesread ; }	starts or continues a read from the data source .
public explanation explain ( int doc , explanation freq ) throws ioexception { return explanation . match ( score ( doc , freq . getvalue ( ) ) , _str + doc + _str + freq . getvalue ( ) + _str , collections . singleton ( freq ) ) ; }	explain the score for a single document.
public static stack < string > splitparts ( string name ) { while ( name . startswith ( _str ) ) name = name . substring ( _num ) ; stack < string > parts = new stack < > ( ) ; int last = _num ; int pos = _num ; string part ; while ( _bool ) { pos = last ; while ( _bool ) { pos = name . indexof ( _str , pos ) ; if ( pos < _num ) break ; if ( name . charat ( pos - _num ) == _str ) ++ pos ; else break ; } if ( pos < _num ) break ; part = name . substring ( last , pos ) ; if ( ! part . endswith ( _str ) ) part += _str ; parts . add ( part ) ; last = pos + _num ; } part = name . substring ( last ) ; if ( ! part . endswith ( _str ) ) part += _str ; parts . add ( part ) ; return parts ; }	splits a som name in the individual parts .
public set < sootmethod > collectsourcemethods ( ) { set < sootmethod > result = new hashset < sootmethod > ( ) ; for ( sourcecallchaininfo cci : entry_points ) { collectsourcemethods ( cci , result ) ; } return result ; }	returns a set of source methods included in the source call tree .
public void testprecisionandscale ( ) throws exception { testprecisionfortype ( _str , _num , - _num , _bool ) ; testprecisionfortype ( _str , _num , - _num , _bool ) ; testprecisionfortype ( _str , _num , - _num , _bool ) ; testprecisionfortype ( _str , _num , - _num , _bool ) ; testprecisionfortype ( _str , _num , - _num , _bool ) ; testprecisionfortype ( _str , _num , - _num , _bool ) ; testprecisionfortype ( _str , _num , - _num , _bool ) ; testprecisionfortype ( _str , _num , - _num , _bool ) ; testprecisionfortype ( _str , _num , - _num , _bool ) ; testprecisionfortype ( _str , _num , - _num , _bool ) ; testprecisionfortype ( _str , _num , _num , _bool ) ; testprecisionfortype ( _str , _num , _num , _bool ) ; testprecisionfortype ( _str , _num , _num , _bool ) ; testprecisionfortype ( _str , _num , _num , _bool ) ; testprecisionfortype ( _str , _num , _num , _bool ) ; testprecisionfortype ( _str , _num , _num , _bool ) ; testprecisionfortype ( _str , _num , _num , _bool ) ; testprecisionfortype ( _str , _num , _num , _bool ) ; }	tests that resultsetmetadata precision and scale methods work correctly for all numeric types .
public void register ( namedbean s ) { string systemname = s . getsystemname ( ) ; _tsys . put ( systemname , s ) ; string username = s . getusername ( ) ; if ( username != null ) { _tuser . put ( username , s ) ; } firepropertychange ( _str , null , integer . valueof ( _tsys . size ( ) ) ) ; s . addpropertychangelistener ( this , _str , _str ) ; }	remember a namedbean object created outside the manager.
protected void expandfor ( int i1 , int i2 , double d ) { if ( i1 >= sizes . size ( ) ) { int oldsize = sizes . size ( ) , capacity = vector . length ; sizes . set ( i1 , _num ) ; if ( capacity < sizes . size ( ) ) { while ( capacity < sizes . size ( ) ) capacity *= _num ; double [ ] [ ] t = new double [ capacity ] [ ] ; system . arraycopy ( vector , _num , t , _num , oldsize ) ; vector = t ; } for ( int i = oldsize ; i < sizes . size ( ) ; ++ i ) vector [ i ] = new double [ defaultcapacity2 ] ; } if ( i2 < sizes . get ( i1 ) ) return ; int oldsize = sizes . get ( i1 ) , capacity = vector [ i1 ] . length ; sizes . set ( i1 , i2 + _num ) ; if ( capacity >= sizes . get ( i1 ) ) return ; while ( capacity < sizes . get ( i1 ) ) capacity *= _num ; double [ ] t = new double [ capacity ] ; system . arraycopy ( vector [ i1 ] , _num , t , _num , oldsize ) ; if ( d != _num ) arrays . fill ( t , oldsize , sizes . get ( i1 ) , d ) ; vector [ i1 ] = t ; }	makes sure the capacities and sizes of the vectors can accomodate the given indexes.
public v put ( final k k , final v v ) { final weakreference < v > ref = newweakref ( k , v , referencequeue ) ; final weakreference < v > oldref = map . put ( k , ref ) ; final v oldval = oldref == null ? null : oldref . get ( ) ; if ( queue . add ( v ) && debug ) { log . debug ( _str + k + _str + v ) ; } didupdate ( k , ref , oldref ) ; return oldval ; }	adds the key - value mapping to the cache .
static void delay ( long millis ) throws interruptedexception { long nanos = millis * ( _num * _num ) ; final long wakeuptime = system . nanotime ( ) + nanos ; do { if ( millis > _num ) thread . sleep ( millis ) ; else thread . yield ( ) ; nanos = wakeuptime - system . nanotime ( ) ; millis = nanos / ( _num * _num ) ; } while ( nanos >= _num ) ; }	delays , via thread.
public void delete ( int key ) { int i = containerhelpers . binarysearch ( mkeys , msize , key ) ; if ( i >= _num ) { system . arraycopy ( mkeys , i + _num , mkeys , i , msize - ( i + _num ) ) ; system . arraycopy ( mvalues , i + _num , mvalues , i , msize - ( i + _num ) ) ; msize -- ; } }	removes the mapping from the specified key , if there was any .
public pageobjectcontext peek ( ) { return deque . peek ( ) ; }	return top context from the queue , without removing it .
protected void writenamespace ( string prefix , string uri ) throws ioexception { if ( ( prefix != null ) && ( prefix . length ( ) > _num ) ) { writer . write ( _str ) ; writer . write ( prefix ) ; writer . write ( _str ) ; } else { writer . write ( _str ) ; } writer . write ( uri ) ; writer . write ( _str ) ; }	writes the sax namepsaces.
public static void waitsometime ( int seconds ) { try { thread . sleep ( seconds * _num ) ; } catch ( interruptedexception e ) { } }	waits a few seconds .
public void encode ( string value , bytebuffer buffer ) throws bufferoverflowexception { if ( value == null ) { buffer . put ( ( byte ) ( _num ) ) ; return ; } int charcount = value . length ( ) ; if ( charcount == _num ) { buffer . put ( ( byte ) ( _num | _num ) ) ; return ; } int position = buffer . position ( ) ; boolean ascii = _bool ; if ( charcount > _num ) { for ( int i = _num ; i < charcount ; i ++ ) { int c = value . charat ( i ) ; if ( c > _num ) { ascii = _bool ; break ; } buffer . put ( ( byte ) c ) ; } } else { ascii = _bool ; } if ( ascii ) { position = buffer . position ( ) ; buffer . put ( position - _num , ( byte ) ( buffer . get ( position - _num ) | _num ) ) ; } else { buffer . position ( position ) ; writelength ( charcount + _num , buffer ) ; int charindex = _num ; for ( ; charindex < charcount ; charindex ++ ) { int c = value . charat ( charindex ) ; if ( c > _num ) break ; buffer . put ( ( byte ) c ) ; } writeutf8string ( value , charcount , charindex , buffer ) ; } }	encode the string to the buffer , null and empty string is allowable.
public void testbug71672statement ( int teststep , connection testconn , string query , int expectedupdatecount , int [ ] expectedkeys ) throws sqlexception { statement teststmt = testconn . createstatement ( ) ; if ( expectedupdatecount < _num ) { assertfalse ( teststep + _str , teststmt . execute ( query , statement . return_generated_keys ) ) ; } else { assertequals ( teststep + _str , expectedupdatecount , teststmt . executeupdate ( query , statement . return_generated_keys ) ) ; } resultset testrs = teststmt . getgeneratedkeys ( ) ; for ( int k : expectedkeys ) { asserttrue ( teststep + _str , testrs . next ( ) ) ; assertequals ( teststep + _str , k , testrs . getint ( _num ) ) ; } assertfalse ( teststep + _str , testrs . next ( ) ) ; testrs . close ( ) ; teststmt . close ( ) ; }	check the update count and returned keys for an insert query using a statement object.
public static pathimpl lookup ( string url ) { pathimpl pwd = getpwd ( ) ; if ( ! url . startswith ( _str ) ) { return pwd . lookup ( url , null ) ; } else { return pwd . lookup ( url , null ) ; } }	returns a new path relative to the current directory .
public static xmlgregoriancalendar now ( ) { return getxmlgregoriancalendarvalue ( null ) ; }	gets the current date / time as an xmlgregoriancalendar with the default time zone in the default locale .
protected void addscalardimension ( int i ) { for ( dimension dimension : dimensionlist ) { if ( dimension . getdimension ( ) == i ) { return ; } } dimensionlist . add ( new dimension ( i ) ) ; }	add a dimension object .
public void initialize ( ) { texturestate ts = new texturestate ( ) ; ts . setenabled ( _bool ) ; setrenderstate ( ts ) ; for ( int i = _num ; i < linesetlist . size ( ) ; ++ i ) { linesetstate state = linesetlist . get ( i ) ; addlineset ( state , _bool ) ; } zbufferstate = new zbufferstate ( ) ; zbufferstate . setfunction ( zbufferstate . testfunction . lessthanorequalto ) ; zbufferstate . setenabled ( _bool ) ; setrenderstate ( zbufferstate ) ; }	initialize this linesets object.
protected boolean regexpregionmatches ( string text , int tstart , string p , int pstart , int plen ) { while ( plen -- > _num ) { char tchar = text . charat ( tstart ++ ) ; char pchar = p . charat ( pstart ++ ) ; if ( ! this . fignorewildcards ) { if ( pchar == fsinglewildcard ) { continue ; } } if ( pchar == tchar ) { continue ; } if ( this . fignorecase ) { if ( character . touppercase ( tchar ) == character . touppercase ( pchar ) ) { continue ; } if ( character . tolowercase ( tchar ) == character . tolowercase ( pchar ) ) { continue ; } } return _bool ; } return _bool ; }	check for a match in a certain region .
public static void initkeys ( keystore keystore , properties props ) { if ( props . containskey ( configuration . webcall_kafka_aes ) ) { byte [ ] key = keystore . decodekey ( props . getproperty ( configuration . webcall_kafka_aes ) ) ; preconditions . checkargument ( ( _num == key . length || _num == key . length || _num == key . length ) , configuration . webcall_kafka_aes + _str ) ; keystore . setkey ( keystore . aes_kafka_webcall , key ) ; aeskey = key ; } if ( props . containskey ( configuration . webcall_kafka_mac ) ) { byte [ ] key = keystore . decodekey ( props . getproperty ( configuration . webcall_kafka_mac ) ) ; preconditions . checkargument ( ( _num == key . length ) , configuration . webcall_kafka_mac + _str ) ; keystore . setkey ( keystore . siphash_kafka_webcall , key ) ; siphashkey = key ; } }	extract the required keys if they exist.
public static boolean isempty ( stringbuilder str ) { return isnull ( str ) || str . length ( ) <= _num ; }	returns true if the str is empty , false otherwise .
public static gas register ( gas gas ) { if ( gas == null ) { return null ; } registeredgasses . add ( gas ) ; return getgas ( gas . getname ( ) ) ; }	register a new gas into gasregistry .
@ override public boolean lock ( ) { try { lockpath = zk . create ( this . locktypefolder + carboncommonconstants . file_separator + lockname , null , ids . open_acl_unsafe , createmode . ephemeral_sequential ) ; list < string > nodes = zk . getchildren ( this . locktypefolder , null ) ; collections . sort ( nodes ) ; if ( lockpath . endswith ( nodes . get ( _num ) ) ) { return _bool ; } else { zk . delete ( lockpath , - _num ) ; return _bool ; } } catch ( keeperexception | interruptedexception e ) { logger . error ( e , e . getmessage ( ) ) ; return _bool ; } }	handling of the locking mechanism using zoo keeper .
@ override protected void keytyped ( char par1 , int par2 ) { tokenbox . textboxkeytyped ( par1 , par2 ) ; if ( par2 == _num || par2 == _num ) actionperformed ( ( guibutton ) buttonlist . get ( _num ) ) ; }	fired when a key is typed.
private static boolean isalphanumeric ( final string label ) { boolean status = _bool ; if ( stringutils . isnotempty ( label ) ) { matcher matcher = patternalphanumeric . matcher ( label ) ; status = matcher . matches ( ) ; } return status ; }	validates if a label contains only alphanumeric values.
final static string trimurisubstring ( url src , string sub ) { final string s = src . toexternalform ( ) ; final int endindex = s . lastindexof ( sub ) ; final string t = s . substring ( _num , endindex ) ; return t ; }	convenience method to prune last substring occurance from url .
@ override public string globalinfo ( ) { return _str + _str + _str ; }	returns a string describing this result listener.
public boolean removerow ( int row ) { if ( m_rows . isvalidrow ( row ) ) { firetableevent ( row , row , tablemodelevent . all_columns , tablemodelevent . delete ) ; m_tuples . invalidate ( row ) ; m_rows . releaserow ( row ) ; for ( iterator cols = getcolumns ( ) ; cols . hasnext ( ) ; ) { column c = ( column ) cols . next ( ) ; c . reverttodefault ( row ) ; } return _bool ; } return _bool ; }	removes a row from this table .
private boolean isparsabletodouble ( string i ) { return i . matches ( _str ) ; }	quick method to test for a string , in a method to shield the exception from the caller .
protected string [ ] initpathsfromproperties ( string rawpaths ) { string [ ] retpaths = null ; if ( rawpaths != null ) { try { stringtokenizer token = new stringtokenizer ( rawpaths , file . pathseparator ) ; int numpaths = token . counttokens ( ) ; retpaths = new string [ numpaths ] ; for ( int i = _num ; i < numpaths ; i ++ ) { retpaths [ i ] = token . nexttoken ( ) ; } return retpaths ; } catch ( java . util . nosuchelementexception e ) { e . printstacktrace ( ) ; } } return retpaths ; }	takes a string of file.
private void registerdefaultvalidatorids ( application application , linkedhashset < string > defaultvalidatorids ) { if ( defaultvalidatorids == null ) { defaultvalidatorids = new linkedhashset < > ( ) ; if ( isbeanvalidatoravailable ( ) ) { webconfiguration webconfig = webconfiguration . getinstance ( ) ; if ( ! webconfig . isoptionenabled ( webconfiguration . booleanwebcontextinitparameter . disabledefaultbeanvalidator ) ) { defaultvalidatorids . add ( beanvalidator . validator_id ) ; } } } for ( string validatorid : defaultvalidatorids ) { if ( logger . isloggable ( level . fine ) ) { logger . log ( level . fine , messageformat . format ( _str , validatorid ) ) ; } application . adddefaultvalidatorid ( validatorid ) ; } }	if defaultvalidatorids is null , then no & lt ; default - validators & gt ; element appeared in any configuration file.
protected void initializelocation ( v v , point2d coord ) { point point = locations . get ( v ) ; coord . setlocation ( point . x , point . y ) ; }	sets persisted location for a vertex within the dimensions of the space.
public static date parsedate ( string datestr ) { string formatstring = _str ; if ( datestr . length ( ) == _num ) datestr = datestr . substring ( _num , _num ) ; if ( datestr . length ( ) == _num ) formatstring = _str ; if ( datestr . length ( ) == _num ) formatstring = _str ; simpledateformat formatter = new simpledateformat ( formatstring ) ; parseposition pos = new parseposition ( _num ) ; return formatter . parse ( datestr , pos ) ; }	returns a date object from a string .
@ suppresswarnings ( _str ) private void dounload ( markedproject markedproject , n4progressstaterecorder rec ) throws n4jscompileerrorexception { if ( createdebugoutput ) { println ( _str + markedproject . project ) ; } rec . markstartunloading ( markedproject ) ; for ( resource res : markedproject . resources ) { rec . markunloadingof ( res ) ; res . unload ( ) ; } rec . markfinishedunloading ( markedproject ) ; }	unload all referenced resources .
public void writefile ( arraylist < dcclocoaddress > consistlist , string filename ) throws ioexception { element root = new element ( _str ) ; document doc = newdocument ( root , dtdlocation + _str ) ; map < string , string > m = new hashmap < string , string > ( ) ; m . put ( _str , _str ) ; m . put ( _str , xsltlocation + _str ) ; processinginstruction p = new processinginstruction ( _str , m ) ; doc . addcontent ( _num , p ) ; element roster = new element ( _str ) ; for ( int i = _num ; i < consistlist . size ( ) ; i ++ ) { consist newconsist = consistman . getconsist ( consistlist . get ( i ) ) ; roster . addcontent ( consisttoxml ( newconsist ) ) ; } root . addcontent ( roster ) ; try { if ( ! checkfile ( filename ) ) { file file = new file ( filename ) ; file parentdir = file . getparentfile ( ) ; if ( ! parentdir . exists ( ) ) { if ( ! parentdir . mkdir ( ) ) { throw ( new ioexception ( ) ) ; } } if ( ! file . createnewfile ( ) ) { throw ( new ioexception ( ) ) ; } } writexml ( findfile ( filename ) , doc ) ; } catch ( ioexception ioe ) { log . error ( _str + ioe ) ; throw ( ioe ) ; } }	write all consists to a file .
public void train ( reader areader ) throws ioexception { bufferedreader in = new bufferedreader ( areader ) ; string line = in . readline ( ) ; while ( line != null ) { matcher m = word_pattern . matcher ( line . tolowercase ( ) ) ; while ( m . find ( ) ) { string word = m . group ( ) ; atomicinteger count = nwords . get ( word ) ; if ( count == null ) { count = new atomicinteger ( _num ) ; nwords . put ( word , count ) ; } count . incrementandget ( ) ; } line = in . readline ( ) ; } }	read words from the given reader and count their occurrences .
private void startclient ( ) { if ( flumeclient != null && ! flumeclient . isactive ( ) ) { flumeclient . close ( ) ; flumeclient = null ; } if ( flumeclient == null ) { try { flumeclient = rpcclientfactory . getdefaultinstance ( flumehostname , flumeport , maxspanbatchsize ) ; } catch ( flumeexception e ) { log . warn ( _str + e . getmessage ( ) ) ; } } }	create / reconnect flume rpc client.
public void vspan ( long start , long end , paint color , string legend ) { legendtext legendtext = new legendtext ( color , legend ) ; comments . add ( legendtext ) ; plotelements . add ( new vspan ( start , end , color , legendtext ) ) ; }	draws a vertical span into the graph and optionally adds a legend .
public void ondraw ( canvas canvas , int centerx , int centery ) { if ( ! mvisible ) { return ; } marcbounds = new rectf ( centerx - mprogressradius , centery - mprogressradius , centerx + mprogressradius , centery + mprogressradius ) ; canvas . drawcircle ( centerx , centery , mprogressradius , mprogressbasepaint ) ; canvas . drawarc ( marcbounds , - _num , mprogressangledegrees , _bool , mprogresspaint ) ; if ( mprogressangledegrees == _num && system . currenttimemillis ( ) > mtimetohide ) { mvisible = _bool ; if ( mvisibilitylistener != null ) { mvisibilitylistener . onhidden ( ) ; } } }	draw the current progress ( if < 100 % ) centered at the given location .
public boolean check ( ) { return ( m_file != null ) && ( m_handler != null ) && m_file . exists ( ) ; }	performs a check whether this setup is valid .
public static list < long > zscoretest ( geotimeserie gts , boolean usemedian , double d ) throws warpscriptexception { doublecheck ( gts ) ; list < long > anomalous_ticks = new arraylist < long > ( ) ; double [ ] musigma = madsigma ( gts , usemedian ) ; double m = musigma [ _num ] ; double std = musigma [ _num ] ; if ( _num == std ) { return anomalous_ticks ; } for ( int i = _num ; i < gts . values ; i ++ ) { double z = ( gts . doublevalues [ i ] - m ) / std ; if ( math . abs ( z ) >= d ) { anomalous_ticks . add ( gts . ticks [ i ] ) ; } } return anomalous_ticks ; }	applying z - score test if usemedian is true , then use modified z - score .
private void append ( printwriter pw , final string k , final string v ) { if ( v != null ) { pw . println ( k + _str + v ) ; } }	appends ' k : v ' to pw if v is non null .
default b withdefault ( string key , object value ) { return withdefault ( key , value != null ? value . tostring ( ) : null ) ; }	if there is no field with the specified key , then associate the given value with the specified key .
private void skipwhitespace ( ) { matcher . usepattern ( whitespace ) ; if ( matcher . lookingat ( ) ) { matcher . region ( matcher . end ( ) , matcher . regionend ( ) ) ; } }	skip over any whitespace so that the matcher region starts at the next token .
protected void createdynamicstyleforcomponents ( final textfield tagname , final textarea tagdesc , final string taregttagcolor ) { tagname . removestylename ( spuidefinitions . tag_name ) ; tagdesc . removestylename ( spuidefinitions . tag_desc ) ; gettargetdynamicstyles ( taregttagcolor ) ; tagname . addstylename ( tag_name_dynamic_style ) ; tagdesc . addstylename ( tag_desc_dynamic_style ) ; }	set tag name and desc field border color based on chosen color .
public void calculate_scores ( ) { score = _num ; if ( contents . length == _num ) { api api = api . v ( ) ; set < infokind > source = api . getsourceinfokinds ( method ) ; set < infokind > sink = api . getsinkinfokinds ( method ) ; if ( is_system ( method ) ) { if ( api . issafemethod ( method ) ) score = _num ; else if ( api . isspecmethod ( method ) ) score = _num ; else if ( api . isbannedmethod ( method ) ) score = _num ; if ( ! source . isempty ( ) ) score += _num ; else if ( ! sink . isempty ( ) ) score += _num ; } return ; } for ( callchaininfo cci : contents ) { cci . calculate_scores ( ) ; calls += cci . calls ; syscalls += cci . syscalls ; if ( cci . score > score ) score = cci . score ; } }	calculate the score for each entry in the call chain.
public < t > jsonarray < t > createlistdtofromjson ( string json , class < t > dtointerface ) { final dtoprovider < t > dtoprovider = getdtoprovider ( dtointerface ) ; final list < jsonelement > list = gson . fromjson ( json , listtypecache . getunchecked ( jsonelement . class ) ) ; final list < t > result = new arraylist < > ( list . size ( ) ) ; for ( jsonelement e : list ) { result . add ( dtoprovider . fromjson ( e ) ) ; } return new jsonarrayimpl < > ( result ) ; }	parses the json data from the specified sting into list of objects of the specified type .
public void startconsumption ( multithreadedbatchprocessor < t , tl > processor ) ;	called once at the start of processing.
public static long longforquery ( sqlitedatabase db , string query , string [ ] selectionargs ) { sqlitestatement prog = db . compilestatement ( query ) ; try { return longforquery ( prog , selectionargs ) ; } finally { prog . close ( ) ; } }	utility method to run the query on the db and return the value in the first column of the first row .
public void testoneone ( ) { string numa = _str ; string numb = _str ; string res = _str ; biginteger anumber = new biginteger ( numa ) ; biginteger bnumber = new biginteger ( numb ) ; biginteger result = anumber . xor ( bnumber ) ; asserttrue ( res . equals ( result . tostring ( ) ) ) ; }	xor for one and one.
public string tostring ( ) { string s = _str + ids . tostring ( ) + _str ; return ( s ) ; }	return printable form of the object .
@ override public void remove ( string ... identifiers ) { whitelist . removeall ( arrays . aslist ( identifiers ) ) ; }	removes identifiers from the serialization strategy .
public commafier ( final string initial ) { m_separator = default_separator ; sb . append ( initial ) ; }	creates a commafier object that starts with an initial string .
public void write ( file file ) throws ioexception { printwriter pw = new printwriter ( new outputstreamwriter ( new fileoutputstream ( file ) , _str ) , _bool ) ; if ( fromdir != null ) { pw . println ( _str + fromdir + _str + fromext ) ; } string str = null ; for ( int i = _num ; i < blist . size ( ) ; i ++ ) { str = ( string ) ( blist . elementat ( i ) ) ; pw . println ( str ) ; } }	write the basenamelist to a file .
private void log ( istatus status ) { resourcesplugin . log ( status ) ; }	adds an entry to the log of this plug - in for the given status.
static private stringbuilder replace ( stringbuilder input , java . util . regex . pattern pattern , string replacement ) { java . util . regex . matcher m = pattern . matcher ( input ) ; while ( m . find ( ) ) { if ( isescapedchar ( input . tostring ( ) , m . start ( ) ) ) { continue ; } input . replace ( m . start ( ) , m . end ( ) , replacement ) ; m . reset ( input ) ; } return input ; }	replaces strings matching a pattern with another string.
public static multisigaggregatemodificationtransaction createmultisigmodification ( ) { return new multisigaggregatemodificationtransaction ( timeinstant . zero , utils . generaterandomaccount ( ) , collections . singletonlist ( new multisigcosignatorymodification ( multisigmodificationtype . addcosignatory , utils . generaterandomaccount ( ) ) ) ) ; }	creates a multisig aggregate modification .
public static boolean isjarcacheenableddefault ( ) { return _isjarcacheenabled ; }	returns true if jar entries should be cached .
public void test_write_flush_update ( ) { final journal store = ( journal ) getstore ( ) ; try { rwstrategy bufferstrategy = ( rwstrategy ) store . getbufferstrategy ( ) ; final int nbytes = _num ; byte [ ] a = new byte [ nbytes ] ; r . nextbytes ( a ) ; final long addr = bufferstrategy . write ( bytebuffer . wrap ( a ) ) ; assertequals ( nbytes , store . getbytecount ( addr ) ) ; store . commit ( ) ; { final bytebuffer b = bufferstrategy . read ( addr ) ; assertnotnull ( b ) ; for ( int i = _num ; i < _num ; i ++ ) { assertequals ( _str + i , a [ i ] , b . get ( i ) ) ; } } } finally { store . destroy ( ) ; } }	ttest write ( ) + flush ( ) + update ( ) - for this case the data have been flushed from the write cache so the update will be a random write on the file rather than being buffered by the write cache .
public static void copy ( long [ ] src , int srcoffset , long [ ] dst , int dstoffset , int len ) { int srclimit = srcoffset + len ; while ( srcoffset < srclimit ) { int srcidx = srcoffset & _num ; int dstidx = dstoffset & _num ; int srcremainder = _num - srcidx ; int dstremainder = _num - dstidx ; int chunklen = math . min ( srcremainder , dstremainder ) ; long mask = maskbelow ( chunklen ) << srcidx ; dst [ dstoffset > > _num ] |= ( ( src [ srcoffset > > _num ] & mask ) > > > srcidx ) << dstoffset ; srcoffset += chunklen ; dstoffset += chunklen ; } }	copies a bit range from one vector to another .
public static int saved_xerror_handler ( long display , xerrorevent error ) { if ( saved_error_handler != _num ) { } if ( log . isloggable ( platformlogger . level . fine ) ) { log . fine ( _str + _str + error . get_resourceid ( ) + _str + _str + error . get_serial ( ) + _str + _str + error . get_error_code ( ) + _str + _str + error . get_request_code ( ) + _str + _str + error . get_minor_code ( ) ) ; } return _num ; }	should be called under lock .
protected int inborder ( int x , int y ) { border b = getborder ( ) ; if ( b == null ) { return undef ; } insets i = b . getborderinsets ( this ) ; if ( x <= i . left ) { return dock_west ; } if ( x >= getwidth ( ) - i . right ) { return dock_east ; } if ( y <= i . top ) { return dock_north ; } if ( y >= getheight ( ) - i . bottom ) { return dock_south ; } return undef ; }	get the border that mouse is in.
public wallforce ( float gravconst , float x1 , float y1 , float x2 , float y2 ) { params = new float [ ] { gravconst } ; minvalues = new float [ ] { default_min_grav_constant } ; maxvalues = new float [ ] { default_max_grav_constant } ; this . x1 = x1 ; this . y1 = y1 ; this . x2 = x2 ; this . y2 = y2 ; dx = x2 - x1 ; dy = y2 - y1 ; float r = ( float ) math . sqrt ( dx * dx + dy * dy ) ; if ( dx != _num ) dx /= r ; if ( dy != _num ) dy /= r ; }	create a new wallforce .
public static void writeln ( final outputstream out ) throws ioexception { out . write ( ls_bytes ) ; }	write an end of line to out .
public static boolean issystemapplication ( context context ) { if ( context == null ) { return _bool ; } return issystemapplication ( context , context . getpackagename ( ) ) ; }	whether context is system application.
public void testposzero ( ) { string numa = _str ; string numb = _str ; string res = _str ; biginteger anumber = new biginteger ( numa ) ; biginteger bnumber = new biginteger ( numb ) ; biginteger result = anumber . xor ( bnumber ) ; asserttrue ( res . equals ( result . tostring ( ) ) ) ; }	xor for a positive number and zero.
private static void initializereleaseplatform ( ) { string platformproperty = readconfigproperty ( platform_properties , platform_property_key ) ; if ( platformproperty == null ) { loginfo ( _str ) ; } else { currentplatform = platform . valueof ( platformproperty . touppercase ( locale . uk ) ) ; loginfo ( _str + currentplatform ) ; } }	loads release platform from properties file .
public static boolean isempty ( charsequence str ) { if ( str == null || str . length ( ) == _num ) { return _bool ; } else { return _bool ; } }	returns true if the string is null or 0 - length .
@ override public fsdatainputstream open ( path path , int buffersize ) throws ioexception { string table = gettablename ( _rootpath , path ) ; string split = getsplitname ( _rootpath , path ) ; split = splitnamewithoutgzipextension ( split ) ; return new fsdatainputstream ( new emosplitinputstream ( table , split ) ) ; }	opens a split for reading.
public void simulatemethod ( sootmethod method , referencevariable thisvar , referencevariable returnvar , referencevariable params [ ] ) { string subsignature = method . getsubsignature ( ) ; if ( subsignature . equals ( _str ) ) { java_lang_classloader_defineclass0 ( method , thisvar , returnvar , params ) ; return ; } else if ( subsignature . equals ( _str ) ) { java_lang_classloader_findbootstrapclass ( method , thisvar , returnvar , params ) ; return ; } else if ( subsignature . equals ( _str ) ) { java_lang_classloader_findloadedclass ( method , thisvar , returnvar , params ) ; return ; } else if ( subsignature . equals ( _str ) ) { java_lang_classloader_getcallerclassloader ( method , thisvar , returnvar , params ) ; return ; } else { defaultmethod ( method , thisvar , returnvar , params ) ; return ; } }	implements the abstract method simulatemethod.
public static final string extractiplidentityhostfrimwarerev ( loconetmessage m ) { stringbuilder s = new stringbuilder ( ) ; s . append ( integer . tostring ( ( m . getelement ( _num ) & _num ) > > _num ) ) ; s . append ( _str ) ; s . append ( integer . tostring ( ( m . getelement ( _num ) & _num ) ) ) ; return s . tostring ( ) ; }	returns the host firmware revision number from an ipl identity report message.
private void grow ( ) { if ( keys == null || nkeys >= keys . length ) { string [ ] nk = new string [ nkeys + _num ] ; string [ ] nv = new string [ nkeys + _num ] ; if ( keys != null ) system . arraycopy ( keys , _num , nk , _num , nkeys ) ; if ( values != null ) system . arraycopy ( values , _num , nv , _num , nkeys ) ; keys = nk ; values = nv ; } }	grow the key / value arrays as needed.
private list < t > filter ( final collection < t > collection ) { final list < t > nullfreelist = new arraylist < t > ( ) ; if ( collection != null ) { for ( final t item : collection ) { if ( item != null ) { nullfreelist . add ( item ) ; } } } return nullfreelist ; }	this filtering is required , in order to ensure that no nulls are passed ( which happens when using gson for deserializing json collection .
public boolean issystemclass ( sootclass clz ) { return allsystemclasses . contains ( clz ) ; }	return true if this class is a system class defined in android.
private byte [ ] trydecodehosttoip ( string host ) { if ( host . startswith ( _str ) && host . endswith ( _str ) ) { return trydecodehosttoipv6 ( host ) ; } return trydecodehosttoipv4 ( host ) ; }	checks if the host is an ip address . returns the byte representation of it.
public list < node > listavailablenodes ( class < ? > type ) { list < node > result = new arraylist < node > ( ) ; for ( node node : availablenodes ) { if ( type . isassignablefrom ( node . getreturntype ( ) ) ) { result . add ( node ) ; } } return result ; }	returns the list of all available nodes with the given return type .
private < t extends draft3resource > t lookforresource ( draft3resourcetype type , class < t > clazz ) { list < t > resources = lookforresources ( type , clazz ) ; return resources != null && resources . size ( ) > _num ? resources . get ( _num ) : null ; }	find one resource by type.
public static string readfiletostring ( file file ) throws ioexception { return readfiletostring ( file , charset . defaultcharset ( ) ) ; }	reads the contents of a file into a string using the default encoding for the vm.
private boolean islocked ( order order ) { lock . lock ( ) ; try { return activeorders . contains ( order . getid ( ) ) ; } finally { lock . unlock ( ) ; } }	determines if the order is locked .
private static byte [ ] longtobytearray ( long l ) { byte [ ] retval = new byte [ _num ] ; for ( int i = _num ; i < _num ; i ++ ) { retval [ i ] = ( byte ) l ; l >>= _num ; } return retval ; }	helper function to convert a long into a byte array ( least significant byte first ) .
public encodertestsuitebuilder encode ( final string expected , final string input ) { return encode ( _str + input , expected , input ) ; }	tells the suite builder that for the given input it should expect the given encoded output.
public void addmutedusername ( final string username ) { addmutedusername ( username , null ) ; }	mute the username permanently.
public void overridecurrenttime ( long time ) { starttime = system . currenttimemillis ( ) ; currenttime = _num ; storedtime = time ; }	forcefully sets the current time for the stopwatch .
public static string sc ( double score ) { string score_str = string . format ( _str , score ) ; return score_str ; }	synopsis [ ] four decimal places for double.
public static boolean validatebindaddress ( string bindaddress ) { if ( bindaddress == null || bindaddress . length ( ) == _num ) return _bool ; if ( inetaddressutil . validatehost ( bindaddress ) == null ) return _bool ; return _bool ; }	validates the bind address.
protected void fail ( string string ) { lastprint = _num ; if ( string . length ( ) > _num ) { char [ ] data = string . tochararray ( ) ; for ( int i = _num ; i < data . length ; i ++ ) { char c = data [ i ] ; if ( c >= _num || c < _num ) { data [ i ] = ( char ) ( _str + ( c & _num ) ) ; string = null ; } } if ( string == null ) { string = new string ( data ) ; } } println ( string ) ; throw new assertionerror ( string ) ; }	called if the test reached a point that was not expected .
public typecheckresult interpretresults ( testconfiguration config , compilationresult compilationresult ) { list < testdiagnostic > expecteddiagnostics = readdiagnostics ( config , compilationresult ) ; return typecheckresult . fromcompilationresults ( config , compilationresult , expecteddiagnostics ) ; }	reads the expected diagnostics for the given configuration and creates a typecheckresult which contains all of the missing and expected diagnostics.
public boolean istrustedxacmlprovider ( string realm , string entityid , string trustedentityid , string role ) throws saml2metaexception { boolean result = _bool ; if ( role != null ) { if ( role . equals ( saml2constants . pdp_role ) ) { xacmlpdpconfigelement pdpconfig = getpolicydecisionpointconfig ( realm , entityid ) ; if ( pdpconfig != null ) { result = issamecircleoftrust ( pdpconfig , realm , trustedentityid ) ; } } else if ( role . equals ( saml2constants . pep_role ) ) { xacmlauthzdecisionqueryconfigelement pepconfig = getpolicyenforcementpointconfig ( realm , entityid ) ; result = issamecircleoftrust ( pepconfig , realm , trustedentityid ) ; } } return result ; }	determines whether two entities are in the same circle of trust under the realm.
private propertyeditor loadpropertyeditor ( class clz ) { propertyeditor editor = null ; try { editor = ( propertyeditor ) clz . newinstance ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } return editor ; }	load propertyeditor from clz through reflection .
public distribution ( instances source , classifiersplitmodel modeltouse ) throws exception { int index ; instance instance ; double [ ] weights ; m_perclassperbag = new double [ modeltouse . numsubsets ( ) ] [ _num ] ; m_perbag = new double [ modeltouse . numsubsets ( ) ] ; total = _num ; m_perclass = new double [ source . numclasses ( ) ] ; for ( int i = _num ; i < modeltouse . numsubsets ( ) ; i ++ ) { m_perclassperbag [ i ] = new double [ source . numclasses ( ) ] ; } enumeration < instance > enu = source . enumerateinstances ( ) ; while ( enu . hasmoreelements ( ) ) { instance = enu . nextelement ( ) ; index = modeltouse . whichsubset ( instance ) ; if ( index != - _num ) { add ( index , instance ) ; } else { weights = modeltouse . weights ( instance ) ; addweights ( instance , weights ) ; } } }	creates a distribution according to given instances and split model .
public void writingrequestheaders ( ) { if ( sentrequestmillis != - _num ) throw new illegalstateexception ( ) ; sentrequestmillis = system . currenttimemillis ( ) ; }	called immediately before the transport transmits http request headers.
public list < dexlibabstractinstruction > instructionsafter ( dexlibabstractinstruction instruction ) { int i = instructions . indexof ( instruction ) ; if ( i == - _num ) throw new illegalargumentexception ( _str + instruction + _str ) ; return instructions . sublist ( i + _num , instructions . size ( ) ) ; }	return the instructions that appear ( lexically ) after the given instruction .
private alignment finetunealignment ( final alignment firstcompute , final int xframe , final int yframe , final point framelocation , final point componentlocation , final int compwidth , final int compheight ) { switch ( firstcompute ) { case topleft : case topright : if ( componentlocation . x - framelocation . x + compwidth / _num > xframe / _num ) { return alignment . topright ; } else { return alignment . topleft ; } case leftbottom : case lefttop : if ( componentlocation . y - framelocation . y + compheight / _num > yframe / _num ) { return alignment . leftbottom ; } else { return alignment . lefttop ; } case rightbottom : case righttop : if ( componentlocation . y - framelocation . y + compheight / _num > yframe / _num ) { return alignment . rightbottom ; } else { return alignment . righttop ; } case bottomleft : case bottomright : if ( componentlocation . x - framelocation . x + compwidth / _num > xframe / _num ) { return alignment . bottomright ; } else { return alignment . bottomleft ; } default : if ( realalignment == alignment . innerleft || realalignment == alignment . innerright ) { return realalignment ; } if ( componentlocation . x - framelocation . x > xframe + framelocation . x - ( compwidth + componentlocation . x ) ) { return alignment . innerright ; } else { return alignment . innerleft ; } } }	after the calculatealignment ( ) decided the optimal side , this method decides which is the optimal direction for the bubble.
public boolean isempty ( ) { return shapes == null ? _bool : shapes . isempty ( ) ; }	checks whether the plot does not contain any elements .
public static boolean isnetworkavailable ( context context ) { connectivitymanager cm = ( connectivitymanager ) context . getsystemservice ( context . connectivity_service ) ; networkinfo netinfo = cm . getactivenetworkinfo ( ) ; return netinfo != null && netinfo . isconnectedorconnecting ( ) ; }	check availability of internet.
public void resetdata ( ) { data . clear ( ) ; datanames . clear ( ) ; dataset . resetdata ( datanames , data , bins ) ; }	clears the data . currently just adds a single vector to each data source .
@ override public uri uploadpackage ( ) { boolean fileexists = new file ( topologypackagelocation ) . isfile ( ) ; if ( ! fileexists ) { log . info ( _str + topologypackagelocation + _str ) ; return null ; } path filepath = paths . get ( desttopologyfile ) ; file parentdirectory = filepath . getparent ( ) . tofile ( ) ; assert parentdirectory != null ; if ( ! parentdirectory . exists ( ) ) { log . fine ( _str ) ; if ( ! parentdirectory . mkdirs ( ) ) { log . severe ( _str + parentdirectory . getpath ( ) ) ; return null ; } } fileexists = new file ( filepath . tostring ( ) ) . isfile ( ) ; if ( fileexists ) { log . fine ( _str + filepath . tostring ( ) + _str ) ; } log . fine ( _str + topologypackagelocation + _str + filepath . tostring ( ) ) ; path source = paths . get ( topologypackagelocation ) ; try { copyoption [ ] options = new copyoption [ ] { standardcopyoption . replace_existing } ; files . copy ( source , filepath , options ) ; } catch ( ioexception ex ) { log . info ( _str + source . tostring ( ) + _str + ex ) ; return null ; } return geturi ( desttopologyfile ) ; }	upload the topology package to the destined location in local file system.
public static string stripescape ( string pattern ) { if ( pattern == null ) return null ; stringbuilder stripped = new stringbuilder ( pattern . length ( ) ) ; for ( int pos = _num ; pos < pattern . length ( ) ; pos ++ ) { char ch = pattern . charat ( pos ) ; if ( ch != _str ) { stripped . append ( ch ) ; } else if ( pos < pattern . length ( ) - _num && pattern . charat ( pos + _num ) == _str ) { stripped . append ( _str ) ; pos += _num ; } } return stripped . tostring ( ) ; }	strips all backslash - escapes from a string .
public long guest_time ( ) { return long . parselong ( fields [ _num ] ) ; }	( since linux 2.
public void auditoperation ( string operation , list < ? extends taggedlogapientity > entities , list < string > encodedrowkeys , entitydefinition entitydefinition ) { if ( isauditingrequired ( entitydefinition . getservice ( ) ) ) { list < genericauditentity > auditentities = buildauditentities ( operation , entities , encodedrowkeys , entitydefinition ) ; if ( null != auditentities && _num != auditentities . size ( ) ) { auditsupport . fireaudit ( entitydefinition . getservice ( ) , auditentities ) ; } } }	method to be invoked for firing audit event .
public void register ( string pattern , string result ) { assert . istrue ( matchers . size ( ) == results . size ( ) ) ; pattern = pattern . trim ( ) ; if ( pattern . length ( ) == _num ) { return ; } matchers . add ( new stringmatcher ( pattern , _bool , _bool ) ) ; results . add ( result ) ; }	register a pattern and an associated string.
@ override public boolean onitemuse ( itemstack par1itemstack , entityplayer par2entityplayer , world par3world , int x , int y , int z , int par7 , float par8 , float par9 , float par10 ) { if ( ! par3world . isremote ) { tileentity tileentity = par3world . gettileentity ( x , y , z ) ; if ( tileentity != null ) { if ( tileentity instanceof tilelauncherprefab ) { tilelauncherprefab missilelauncher = ( tilelauncherprefab ) tileentity ; if ( missilelauncher . getfrequency ( ) > _num ) { setfrequency ( missilelauncher . getfrequency ( ) , par1itemstack ) ; par2entityplayer . addchatmessage ( new chatcomponenttext ( reference . chat_desc + enumcolor . grey + _str + langutils . localize ( _str ) + _str + enumcolor . dark_grey + getfrequency ( par1itemstack ) ) ) ; } else { par2entityplayer . addchatmessage ( new chatcomponenttext ( reference . chat_desc + enumcolor . grey + _str + langutils . localize ( _str ) ) ) ; } } } } return _bool ; }	callback for item usage.
private static string parsederstring ( byte [ ] alternamevalue ) throws throwable { try { asn1streamparser p = new asn1streamparser ( alternamevalue ) ; asn1encodable d = p . readobject ( ) ; asn1primitive der = d . toasn1primitive ( ) ; return getstringfromobject ( der ) ; } catch ( throwable e ) { logger . error ( _str + e . getmessage ( ) ) ; throw e ; } }	parse der - encoded bytes to locate a string object.
public atlasmessagesadapter addcellfactories ( atlascellfactory ... cellfactories ) { for ( atlascellfactory cellfactory : cellfactories ) { cellfactory . setstyle ( mmessagestyle ) ; mcellfactories . add ( cellfactory ) ; mviewtypecount ++ ; celltype me = new celltype ( _bool , cellfactory ) ; mcelltypesbyviewtype . put ( mviewtypecount , me ) ; mmyviewtypesbycell . put ( cellfactory , mviewtypecount ) ; mviewtypecount ++ ; celltype notme = new celltype ( _bool , cellfactory ) ; mcelltypesbyviewtype . put ( mviewtypecount , notme ) ; mtheirviewtypesbycell . put ( cellfactory , mviewtypecount ) ; } return this ; }	registers one or more cellfactories for the atlasmessagesadapter to manage.
protected string consumebom ( inputstream stream , string encoding ) throws ioexception { byte [ ] b = new byte [ _num ] ; int count = _num ; stream . mark ( _num ) ; if ( encoding . equals ( _str ) ) { count = stream . read ( b , _num , _num ) ; if ( count == _num ) { final int b0 = b [ _num ] & _num ; final int b1 = b [ _num ] & _num ; final int b2 = b [ _num ] & _num ; if ( b0 != _num || b1 != _num || b2 != _num ) { stream . reset ( ) ; } } else { stream . reset ( ) ; } } else if ( encoding . startswith ( _str ) ) { count = stream . read ( b , _num , _num ) ; if ( count == _num ) { final int b0 = b [ _num ] & _num ; final int b1 = b [ _num ] & _num ; if ( b0 == _num && b1 == _num ) { return _str ; } else if ( b0 == _num && b1 == _num ) { return _str ; } } stream . reset ( ) ; } return encoding ; }	removes the byte order mark from the stream , if it exists and returns the encoding name .
public static int createwithidgeneration ( connection connection , string rawsqlquery , object ... parameters ) throws sqlexception { preparedstatement stmt = null ; resultset rs = null ; try { stmt = connection . preparestatement ( rawsqlquery , statement . return_generated_keys ) ; for ( int index = _num ; index < parameters . length ; index ++ ) { jdbcutils . bindparameter ( stmt , index + _num , parameters [ index ] ) ; } stmt . executeupdate ( ) ; rs = stmt . getgeneratedkeys ( ) ; rs . next ( ) ; return rs . getint ( _num ) ; } finally { jdbcutils . closeresultset ( rs ) ; jdbcutils . closestatement ( stmt ) ; } }	insert one row into database with the auto incremental id returned .
public static int andnot ( int a [ ] , int lena , int b [ ] , int lenb , int [ ] target ) { if ( lena == _num ) return _num ; if ( lenb == _num ) { system . arraycopy ( a , _num , target , _num , lena ) ; return lena ; } if ( ( lenb > > _num ) >= lena ) { return andnotbinarysearch ( a , lena , b , lenb , target ) ; } int count = _num ; int i = _num , j = _num ; int doca = a [ i ] , docb = b [ j ] ; for ( ; ; ) { if ( doca > docb ) { if ( ++ j >= lenb ) break ; docb = b [ j ] ; } else if ( doca < docb ) { target [ count ++ ] = doca ; if ( ++ i >= lena ) break ; doca = a [ i ] ; } else { if ( ++ i >= lena ) break ; doca = a [ i ] ; if ( ++ j >= lenb ) break ; docb = b [ j ] ; } } int leftover = lena - i ; if ( leftover > _num ) { system . arraycopy ( a , i , target , count , leftover ) ; count += leftover ; } return count ; }	puts the intersection of a and not b into the target array and returns the size.
void createbuttons ( ) { if ( scrollforwardbutton != null ) { tabpane . remove ( scrollforwardbutton ) ; scrollforwardbutton . removeactionlistener ( this ) ; tabpane . remove ( scrollbackwardbutton ) ; scrollbackwardbutton . removeactionlistener ( this ) ; } int tabplacement = tabpane . gettabplacement ( ) ; int width = uimanager . getint ( _str ) ; if ( tabplacement == top || tabplacement == bottom ) { scrollforwardbutton = new arrowbutton ( east , width ) ; scrollbackwardbutton = new arrowbutton ( west , width ) ; } else { scrollforwardbutton = new arrowbutton ( south , width ) ; scrollbackwardbutton = new arrowbutton ( north , width ) ; } scrollforwardbutton . addactionlistener ( this ) ; scrollbackwardbutton . addactionlistener ( this ) ; tabpane . add ( scrollforwardbutton ) ; tabpane . add ( scrollbackwardbutton ) ; }	recreates the scroll buttons and adds them to the tabbedpane .
public static string rmslashfromurl ( final string url ) { return url . endswith ( _str ) ? url . substring ( _num , url . length ( ) - _num ) : url ; }	remove the trailing slash from url .
protected void updatechartlayout ( ) { chartcontainer . removeall ( ) ; list < string > selectedmetrics = getselectedmetrics ( ) ; if ( selectedmetrics . size ( ) > _num ) { if ( selectedmetrics . size ( ) <= _num ) { chartcontainer . setlayout ( new gridlayout ( _num , _num ) ) ; } else if ( selectedmetrics . size ( ) <= _num ) { chartcontainer . setlayout ( new gridlayout ( _num , _num ) ) ; } else if ( selectedmetrics . size ( ) <= _num ) { chartcontainer . setlayout ( new gridlayout ( _num , _num ) ) ; } else if ( selectedmetrics . size ( ) <= _num ) { chartcontainer . setlayout ( new gridlayout ( _num , _num ) ) ; } else { chartcontainer . setlayout ( new gridlayout ( ( int ) math . ceil ( selectedmetrics . size ( ) / _num ) , _num ) ) ; } gridlayout layout = ( gridlayout ) chartcontainer . getlayout ( ) ; int spaces = layout . getrows ( ) * layout . getcolumns ( ) ; for ( int i = _num ; i < math . max ( spaces , selectedmetrics . size ( ) ) ; i ++ ) { if ( i < selectedmetrics . size ( ) ) { chartcontainer . add ( createchart ( selectedmetrics . get ( i ) ) ) ; } else { chartcontainer . add ( new emptyplot ( this ) ) ; } } } chartcontainer . revalidate ( ) ; }	updates the chart layout when the user changes which metrics to plot.
public string host ( properties props ) { return props . getproperty ( host_property_key , _str ) ; }	returns the hostname property.
void cancel ( ) { setvisible ( _bool ) ; }	cancel any updates made in this dialog , and closes it .
@ override public memchunkholder < volatilememallocator > createchunk ( long size , boolean autoreclaim ) { memchunkholder < volatilememallocator > ret = null ; long addr = m_vmasvc . allocate ( m_nid , size , _bool ) ; if ( _num == addr && m_activegc ) { m_chunkcollector . waitreclaimcooldown ( m_gctimeout ) ; addr = m_vmasvc . allocate ( m_nid , size , _bool ) ; } if ( _num != addr ) { ret = new memchunkholder < volatilememallocator > ( this , addr , size ) ; ret . setcollector ( m_chunkcollector ) ; if ( autoreclaim ) { m_chunkcollector . register ( ret ) ; } } return ret ; }	create a memory chunk that is managed by its holder .
public void waitforinvocation ( long msecwait , int numberofnewevents ) { long starttime = system . currenttimemillis ( ) ; while ( _bool ) { if ( ( system . currenttimemillis ( ) - starttime ) > msecwait ) { throw new runtimeexception ( _str + numberofnewevents + _str + getnewdatalistflattened ( ) . length ) ; } eventbean [ ] events = getnewdatalistflattened ( ) ; if ( events . length >= numberofnewevents ) { return ; } try { thread . sleep ( _num ) ; } catch ( interruptedexception e ) { return ; } } }	wait for the listener invocation for up to the given number of milliseconds .
private string versionname ( string prefix , int ver ) { return fname ( prefix ) + string . valueof ( ver ) ; }	generates a version filename prepended with the stable storage directory path with the given version number as a suffix .
private void requestpermissionifneeded ( ) { if ( build . version . sdk_int >= build . version_codes . m ) { int hasenablecoarselocationperm = checkselfpermission ( manifest . permission . access_coarse_location ) ; int hasenablefinelocationperm = checkselfpermission ( manifest . permission . access_fine_location ) ; int hasenableexternalwriteperm = checkselfpermission ( manifest . permission . write_external_storage ) ; list < string > permissiontorequest = new arraylist < > ( ) ; if ( hasenablecoarselocationperm == packagemanager . permission_denied ) { permissiontorequest . add ( manifest . permission . access_coarse_location ) ; } if ( hasenablefinelocationperm == packagemanager . permission_denied ) { permissiontorequest . add ( manifest . permission . access_fine_location ) ; } if ( hasenableexternalwriteperm == packagemanager . permission_denied ) { permissiontorequest . add ( manifest . permission . write_external_storage ) ; } if ( ! permissiontorequest . isempty ( ) ) { requestpermissions ( permissiontorequest . toarray ( new string [ permissiontorequest . size ( ) ] ) , allow_permissions ) ; } else { initevent ( ) ; } } }	this method must be called if the android version is 6.
public extractmethodrefactoring ( icompilationunit unit , int selectionstart , int selectionlength ) { fcunit = unit ; froot = null ; fmethodname = _str ; fselectionstart = selectionstart ; fselectionlength = selectionlength ; fvisibility = - _num ; }	creates a new extract method refactoring.
@ override public boolean done ( ) { if ( stoppingincrements && incrementsleft == _num ) return _bool ; else return _bool ; }	override incrementsaredone so that we can eventually stop .
public void parse ( ) throws java . lang . exception { int act ; symbol lhs_sym ; short handle_size , lhs_sym_num ; production_tab = production_table ( ) ; action_tab = action_table ( ) ; reduce_tab = reduce_table ( ) ; init_actions ( ) ; user_init ( ) ; cur_token = scan ( ) ; stack . push ( new symbol ( _num , start_state ( ) ) ) ; tos = _num ; for ( _done_parsing = _bool ; ! _done_parsing ; ) { act = get_action ( ( ( symbol ) stack . peek ( ) ) . parse_state , cur_token . sym ) ; if ( act > _num ) { cur_token . parse_state = act - _num ; stack . push ( cur_token ) ; tos ++ ; cur_token = scan ( ) ; } else if ( act < _num ) { lhs_sym = do_action ( ( - act ) - _num , this , stack , tos ) ; lhs_sym_num = production_tab [ ( - act ) - _num ] [ _num ] ; handle_size = production_tab [ ( - act ) - _num ] [ _num ] ; for ( int i = _num ; i < handle_size ; i ++ ) { stack . pop ( ) ; tos -- ; } act = get_reduce ( ( ( symbol ) stack . peek ( ) ) . parse_state , lhs_sym_num ) ; lhs_sym . parse_state = act ; stack . push ( lhs_sym ) ; tos ++ ; } else if ( act == _num ) { syntax_error ( cur_token ) ; if ( ! error_recovery ( _bool ) ) { unrecovered_syntax_error ( cur_token ) ; done_parsing ( ) ; } } } }	this method provides the main parsing routine.
private static void writeset1 ( final btree btree ) { log . info ( _str ) ; for ( int i = _num ; i < _num ; i ++ ) { btree . insert ( i , i ) ; } }	write a set of tuples having keys in [ 0 : 1000 ) and values equal to the keys .
private byte [ ] createsegmenttable ( int setupheaderlength , list < oggpageheader . packetstartandlength > extrapackets ) { bytearrayoutputstream resultbaos = new bytearrayoutputstream ( ) ; byte [ ] restshouldbe ; byte [ ] nextpacket ; restshouldbe = createsegments ( setupheaderlength , _bool ) ; try { resultbaos . write ( restshouldbe ) ; if ( extrapackets . size ( ) > _num ) { for ( oggpageheader . packetstartandlength packet : extrapackets ) { nextpacket = createsegments ( packet . getlength ( ) , _bool ) ; resultbaos . write ( nextpacket ) ; } } } catch ( ioexception ioe ) { throw new runtimeexception ( _str + ioe . getmessage ( ) ) ; } return resultbaos . tobytearray ( ) ; }	this method creates a new segment table for the second half of setup header.
public static int indexofignorecase ( string src , string sub , int startindex , int endindex ) { if ( startindex < _num ) { startindex = _num ; } int srclen = src . length ( ) ; if ( endindex > srclen ) { endindex = srclen ; } int sublen = sub . length ( ) ; if ( sublen == _num ) { return startindex > srclen ? srclen : startindex ; } sub = sub . tolowercase ( ) ; int total = endindex - sublen + _num ; char c = sub . charat ( _num ) ; mainloop : for ( int i = startindex ; i < total ; i ++ ) { if ( character . tolowercase ( src . charat ( i ) ) != c ) { continue ; } int j = _num ; int k = i + _num ; while ( j < sublen ) { char source = character . tolowercase ( src . charat ( k ) ) ; if ( sub . charat ( j ) != source ) { continue mainloop ; } j ++ ; k ++ ; } return i ; } return - _num ; }	finds first index of a substring in the given source string and range with ignored case .
private void addpolygonring ( linearring lr , int cwleft , int cwright ) { if ( lr . isempty ( ) ) return ; coordinate [ ] coord = coordinatearrays . removerepeatedpoints ( lr . getcoordinates ( ) ) ; if ( coord . length < _num ) { hastoofewpoints = _bool ; invalidpoint = coord [ _num ] ; return ; } int left = cwleft ; int right = cwright ; if ( cgalgorithms . isccw ( coord ) ) { left = cwright ; right = cwleft ; } edge e = new edge ( coord , new label ( argindex , location . boundary , left , right ) ) ; lineedgemap . put ( lr , e ) ; insertedge ( e ) ; insertpoint ( argindex , coord [ _num ] , location . boundary ) ; }	adds a polygon ring to the graph.
public boolean acceptsloadname ( string load ) { if ( _loadoption . equals ( all_loads ) ) { return _bool ; } if ( _loadoption . equals ( include_loads ) ) { return _loadlist . contains ( load ) ; } return ! _loadlist . contains ( load ) ; }	determine if track will service a specific receive load name .
public static void expandletters ( string letters , wordrelation wordrelation ) { letters = letters . tolowercase ( ) ; char c ; for ( int i = _num ; i < letters . length ( ) ; i ++ ) { c = letters . charat ( i ) ; if ( isdigit ( c ) ) { wordrelation . addword ( digit2num [ c - _str ] ) ; } else if ( letters . equals ( _str ) ) { wordrelation . addword ( _str ) ; } else { wordrelation . addword ( string . valueof ( c ) ) ; } } }	expands the given string of letters as a list of single char symbols .
public static void writestringtofile ( file file , string data , charset encoding , boolean append ) throws ioexception { outputstream out = null ; try { out = openoutputstream ( file , append ) ; ioutils . write ( data , out , encoding ) ; out . close ( ) ; } finally { ioutils . closequietly ( out ) ; } }	writes a string to a file creating the file if it does not exist .
@ deprecated public static void subtract ( string name , double amount ) throws userdoesnotexistexception , noloanpermittedexception { try { substract ( name , bigdecimal . valueof ( amount ) ) ; } catch ( arithmeticexception e ) { logger . log ( level . warning , _str + amount + _str + name + _str + e . getmessage ( ) , e ) ; } }	substracts money from the balance of a user.
public mnemoniccode ( inputstream wordstream , string wordlistdigest ) throws ioexception , illegalargumentexception { bufferedreader br = new bufferedreader ( new inputstreamreader ( wordstream , _str ) ) ; wordlist = new arraylist < string > ( _num ) ; string word ; while ( ( word = br . readline ( ) ) != null ) wordlist . add ( word ) ; br . close ( ) ; initializefromwords ( wordlist , wordlistdigest ) ; }	creates an mnemoniccode object , initializing with words read from the supplied input stream.
public qkdialog addmenuitem ( string title , long id ) { mmenuitems . add ( title ) ; mmenuitemids . add ( id ) ; return this ; }	adds a menu style item , allowing for dynamic ids for different items . this is useful when the item order is set dynamically , like in the messagelistitem if you use this method , always make sure to use # buildmenu ( onitemclicklistener ) to compile the items and add the click listener.
public anchorpane createfingerprintpanel ( arraylist < fppanel > fingerprintpanellist ) { return createfingerprintpanel ( fingerprintpanellist , null ) ; }	creates a new fingerprint panel from scratch ( new uuid ).
private static boolean ismemoryaccess ( final string value ) { return value . equals ( _str ) ; }	checks whether a string is a memory access identifier string .
public void addattribute ( attributeinfo info ) { attributeinfo . remove ( attributes , info . getname ( ) ) ; attributes . add ( info ) ; }	appends an attribute . if there is already an attribute with the same name , the new one substitutes for it .
private static boolean verifystringparam ( string str , int maxlength , string acceptablecharacters ) { return ! ( str == null || str . length ( ) == _num || str . length ( ) > maxlength || ! pattern . matches ( acceptablecharacters , str ) ) ; }	returns true if the specified string is non - null , greater then 0 in length , less than the specified length and matches the regex provided .
private int calculatedragsensitivity ( ) { int range = max_drag_sensitivity - min_drag_sensitivity ; return math . round ( ( _num - getdragsensitivity ( ) ) * range + min_drag_sensitivity ) ; }	calculates and returns the distance after which dragging has an effect on the bottom sheet in pixels.
public static string lowerfirstchar ( string string ) { if ( string == null ) return null ; if ( string . length ( ) <= _num ) return string . tolowercase ( ) ; stringbuilder sb = new stringbuilder ( string ) ; sb . setcharat ( _num , character . tolowercase ( sb . charat ( _num ) ) ) ; return sb . tostring ( ) ; }	changes the first letter of the passed string to lower case .
public void foreachblockposmutabletopdown ( predicate < blockpos > func ) { blockpos . mutableblockpos blockpos = new blockpos . mutableblockpos ( ) ; int basex = getminblockx ( ) ; int basez = getminblockz ( ) ; int blockymax = getmaxblocky ( ) ; for ( int x = _num ; x < _num ; x ++ ) { for ( int z = _num ; z < _num ; z ++ ) { blockpos . setpos ( basex + x , blockymax , basez + z ) ; for ( int y = _num ; y >= _num ; y -- ) { boolean cont = func . test ( blockpos ) ; blockpos . move ( enumfacing . down ) ; if ( ! cont ) { break ; } } } } }	for each x / z coordinate pair in this cube position - goes top - down and calls func for each blockpos.
public string visit ( type t , locale locale ) { return t . accept ( this , locale ) ; }	get a localized string representation for a given type .
public static final void writemapxml ( map val , xmlserializer out , writemapcallback callback ) throws xmlpullparserexception , java . io . ioexception { if ( val == null ) { return ; } set s = val . entryset ( ) ; iterator i = s . iterator ( ) ; while ( i . hasnext ( ) ) { map . entry e = ( map . entry ) i . next ( ) ; writevaluexml ( e . getvalue ( ) , ( string ) e . getkey ( ) , out , callback ) ; } }	flatten a map into an xmlserializer.
public static void droptable ( string table , connection connection ) { table = table . replace ( _str , _str ) ; stringbuilder droptablequery = new stringbuilder ( ) ; droptablequery . append ( _str ) ; droptablequery . append ( table ) ; log . info ( _str ) ; log . info ( droptablequery ) ; executestatementifexists ( droptablequery . tostring ( ) , connection ) ; }	drops a table from a database underneath the connection object .
private int freespace ( ) { return buffer . capacity ( ) - buffer . limit ( ) + buffer . position ( ) ; }	return the size of free space in a buffer.
@ override public list < node > generate ( int popsize ) { list < node > population = new arraylist < > ( ) ; for ( int i = _num ; i < popsize ; ) { node candidate = grow ( _num ) ; if ( candidate . isvalid ( ) ) { population . add ( candidate ) ; i ++ ; } } return population ; }	this method return a new population of the desired size . the population is generated by growth algorithm which creates individual with a depth from 1 to a specified max depth ,.
public synchronized void notifybeforeuse ( compositetransaction ct ) throws invalidsessionhandlestateexception { if ( closed ) throw new invalidsessionhandlestateexception ( _str ) ; try { transactioncontext suspended = null ; if ( ct != null ) { iterator < transactioncontext > it = allcontexts . iterator ( ) ; while ( it . hasnext ( ) && suspended == null ) { transactioncontext b = ( transactioncontext ) it . next ( ) ; if ( b . issuspendedintransaction ( ct ) ) { suspended = b ; } } } if ( suspended != null ) { if ( logger . isdebugenabled ( ) ) logger . logdebug ( this + _str + ct . gettid ( ) ) ; currentcontext = suspended ; currentcontext . transactionresumed ( ) ; } else { try { if ( logger . istraceenabled ( ) ) logger . logtrace ( this + _str + ct ) ; currentcontext . checkenlistbeforeuse ( ct ) ; } catch ( unexpectedtransactioncontextexception txboundarypassed ) { if ( logger . isdebugenabled ( ) ) logger . logdebug ( this + _str + ct ) ; currentcontext . transactionsuspended ( ) ; currentcontext = new transactioncontext ( resource , xaresource ) ; allcontexts . add ( currentcontext ) ; try { currentcontext . checkenlistbeforeuse ( ct ) ; } catch ( unexpectedtransactioncontextexception e ) { string msg = _str ; logger . logerror ( msg , e ) ; throw new invalidsessionhandlestateexception ( msg ) ; } } } } catch ( invalidsessionhandlestateexception e ) { notifysessionerroroccurred ( ) ; throw e ; } }	notification that the session handle is about to be used in the current transaction context ( i.
public void onactivityresult ( int requestcode , int resultcode , intent data ) { if ( minitializationcomplete ) { mactivitydelegate . onactivityresultwithnative ( requestcode , resultcode , data ) ; } else { if ( mpendingactivityresults == null ) { mpendingactivityresults = new arraylist < activityresult > ( _num ) ; } mpendingactivityresults . add ( new activityresult ( requestcode , resultcode , data ) ) ; } }	this is the android onactivityresult callback deferred , if necessary , to when the native library has loaded .
public void deleteselection ( arraylist < integer > nodes ) { for ( int i = _num ; i < nodes . size ( ) ; i ++ ) { for ( int j = i + _num ; j < nodes . size ( ) ; j ++ ) { if ( nodes . get ( i ) > nodes . get ( j ) ) { int h = nodes . get ( i ) ; nodes . set ( i , nodes . get ( j ) ) ; nodes . set ( j , h ) ; } } } if ( m_bneedsundoaction ) { addundoaction ( new deleteselectionaction ( nodes ) ) ; } boolean bneedsundoaction = m_bneedsundoaction ; m_bneedsundoaction = _bool ; try { for ( int inode = nodes . size ( ) - _num ; inode >= _num ; inode -- ) { deletenode ( nodes . get ( inode ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } m_bneedsundoaction = bneedsundoaction ; }	delete nodes with indexes in selection from the network , updating instances , parentsets , distributions conditional distributions are condensed by taking the values for the target node to be its first value.
protected void oncached ( ) { if ( logconfiguration . loggingisenabled ( ) ) { logger . log ( level . info , _str ) ; } uihandler . hidemessage ( ) ; updating = _bool ; fireapplicationcacheevent ( cacheevent . oncached ) ; }	called when a cached event is triggered.
public static void showstring ( string title , string content , dimension dimension ) { jtextarea area = new jtextarea ( content ) ; area . seteditable ( _bool ) ; jscrollpane scroll = new jscrollpane ( area ) ; scroll . setpreferredsize ( dimension ) ; joptionpane . showmessagedialog ( null , scroll , title , joptionpane . information_message ) ; }	display a string ( can be long ) inside a message dialogue.
private void markcgfordeletion ( blockconsistencygroup consistencygroup ) { if ( ! consistencygroup . getinactive ( ) ) { consistencygroup . setstoragecontroller ( null ) ; consistencygroup . setinactive ( _bool ) ; _dbclient . updateobject ( consistencygroup ) ; } }	update the cg so it is deleted .
public longbuffer put ( long [ ] src , int srcoffset , int longcount ) { jtranscarrays . checkoffsetandcount ( src . length , srcoffset , longcount ) ; if ( longcount > remaining ( ) ) { throw new bufferoverflowexception ( ) ; } for ( int i = srcoffset ; i < srcoffset + longcount ; ++ i ) { put ( src [ i ] ) ; } return this ; }	writes longs from the given long array , starting from the specified offset , to the current position and increases the position by the number of longs written .
@ override public void invokecommand ( int arglength , string [ ] args , string command ) { pattern regex = null ; if ( args . length == _num ) { regex = pattern . compile ( args [ _num ] ) ; } else if ( args . length != _num ) { throw new usageexception ( _str ) ; } for ( abstractcommand cmd : commandbus . commands ) tryregex ( regex , cmd ) ; for ( fuzzycommand cmd : commandbus . parsers ) tryregex ( regex , cmd ) ; }	invoke the command if the name matches the one to be triggered.
protected int parseandaddnode ( xmlresourceparser parser , hashmap < string , tagparser > tagparsermap , arraylist < long > screenids ) throws xmlpullparserexception , ioexception { if ( tag_include . equals ( parser . getname ( ) ) ) { final int resid = getattributeresourcevalue ( parser , attr_workspace , _num ) ; if ( resid != _num ) { return parselayout ( resid , screenids ) ; } else { return _num ; } } mvalues . clear ( ) ; parsecontainerandscreen ( parser , mtemp ) ; final long container = mtemp [ _num ] ; final long screenid = mtemp [ _num ] ; mvalues . put ( launchersettings . favorites . container , container ) ; mvalues . put ( launchersettings . favorites . screen , screenid ) ; mvalues . put ( launchersettings . favorites . cellx , converttodistancefromend ( getattributevalue ( parser , attr_x ) , mcolumncount ) ) ; mvalues . put ( launchersettings . favorites . celly , converttodistancefromend ( getattributevalue ( parser , attr_y ) , mrowcount ) ) ; tagparser tagparser = tagparsermap . get ( parser . getname ( ) ) ; if ( tagparser == null ) { if ( logd ) log . d ( tag , _str + parser . getname ( ) ) ; return _num ; } long newelementid = tagparser . parseandadd ( parser ) ; if ( newelementid >= _num ) { if ( ! screenids . contains ( screenid ) && container == launchersettings . favorites . container_desktop ) { screenids . add ( screenid ) ; } return _num ; } return _num ; }	parses the current node and returns the number of elements added .
public wordentry addnewword ( final string str ) { final string key = trimword ( str ) ; wordentry entry = words . get ( key ) ; if ( entry == null ) { entry = new wordentry ( ) ; entry . settype ( new expressiontype ( _str ) ) ; entry . setnormalized ( key ) ; words . put ( key , entry ) ; } else { logger . warn ( _str + str + _str + entry . getnormalized ( ) ) ; } return entry ; }	add a new word to the list in order to remember it later .
@ override public int insert ( string elem ) { int firstindex = ( int ) ( elem . charat ( _num ) - _str ) ; int middleindex = ( int ) ( elem . charat ( - _num + elem . length ( ) / _num ) - _str ) ; int lastindex = ( int ) ( elem . charat ( elem . length ( ) - _num ) - _str ) ; storage [ firstindex * _num + middleindex * _num + lastindex ] = elem ; return _num ; }	insert element into collection.
@ override protected void onmeasure ( int widthmeasurespec , int heightmeasurespec ) { mwidth = measurespec . getsize ( widthmeasurespec ) ; mheight = measurespec . getsize ( heightmeasurespec ) ; int minside = math . min ( mwidth , mheight ) ; mwidth = minside ; mheight = minside ; mcurrentprogressposition = calculatecurrentpositionfromcurrentseconds ( mcurrentseconds ) ; objectanimatorprogress . setfloatvalues ( mcurrentprogressposition / mwidth , _num ) ; objectanimatorprogress . setduration ( ( mmaxseconds - mcurrentseconds ) * _num ) ; if ( mbitmapcoverimage != null ) scalecoverbitmap ( mbitmapcoverimage ) ; rectfemptyprogress . set ( _num , mheight - mprogressheight , mwidth , mheight ) ; mdrawablebottomshadow . setbounds ( _num , ( _num * mheight ) / _num , mwidth , mheight ) ; if ( startrequested ) { startrequested = _bool ; start ( ) ; } super . onmeasure ( widthmeasurespec , heightmeasurespec ) ; }	calculate witdh , height and region values here.
protected list < command > handlecommands ( serverconnector serverconnector , list < command > commands ) { list < command > results = new arraylist < command > ( ) ; for ( command command : commands ) { if ( log . isloggable ( level . finest ) ) { log . finest ( _str + command ) ; } results . addall ( serverconnector . receive ( command ) ) ; } return results ; }	processes incoming commands and creates outgoing commands .
public static void uf5 ( double [ ] x , double [ ] f , int nx ) { int count1 = _num ; int count2 = _num ; double sum1 = _num ; double sum2 = _num ; double yj ; double hj ; double n = _num ; double e = _num ; for ( int j = _num ; j <= nx ; j ++ ) { yj = x [ j - _num ] - math . sin ( _num * pi * x [ _num ] + j * pi / nx ) ; hj = _num * yj * yj - math . cos ( _num * pi * yj ) + _num ; if ( j % _num == _num ) { sum2 += hj ; count2 ++ ; } else { sum1 += hj ; count1 ++ ; } } hj = ( _num / n + e ) * math . abs ( math . sin ( _num * n * pi * x [ _num ] ) ) ; f [ _num ] = x [ _num ] + hj + _num * sum1 / ( double ) count1 ; f [ _num ] = _num - x [ _num ] + hj + _num * sum2 / ( double ) count2 ; }	evaluates the uf5 problem .
private view fillup ( int pos , int nextbottom ) { if ( debug ) log . i ( tag , _str + pos + _str + nextbottom + m_first_position + mfirstposition ) ; view selectedview = null ; final int end = mlistpadding . top ; while ( nextbottom > end && pos >= _num ) { view temp = makerow ( pos , nextbottom , _bool ) ; if ( temp != null ) { selectedview = temp ; } nextbottom = mreferenceview . gettop ( ) - mverticalspacing ; mfirstposition = pos ; pos -= mnumcolumns ; } if ( mstackfrombottom ) { mfirstposition = math . max ( _num , pos + _num ) ; } return selectedview ; }	fills the list from pos up to the top of the list view .
private list < validationerror > validate ( ) { list < validationerror > errors = lists . newarraylist ( ) ; module module = getmodule ( ) ; errors . addall ( blazeandroidrunconfigurationvalidationutil . validatemodule ( module ) ) ; androidfacet facet = null ; if ( module != null ) { facet = androidfacet . getinstance ( module ) ; errors . addall ( blazeandroidrunconfigurationvalidationutil . validatefacet ( facet , module ) ) ; } errors . addall ( configstate . validate ( facet ) ) ; errors . addall ( blazeandroidrunconfigurationvalidationutil . validatelabel ( getlabel ( ) , configuration . getproject ( ) , kind . android_binary ) ) ; return errors ; }	we collect errors rather than throwing to avoid missing fatal errors by exiting early for a warning.
public void removechildjob ( job childjob ) { if ( ! childjobs . contains ( childjob ) ) { throw new runtimeexception ( _str + childjob + _str ) ; } boolean removed = childjobs . remove ( childjob ) ; if ( ! removed ) { throw new runtimeexception ( _str ) ; } }	removes a child job from this job ' s set of child jobs.
private pointf isflingingtodelete ( dragsource source ) { if ( mflingtodeletedroptarget == null ) return null ; if ( ! source . supportsflingtodelete ( ) ) return null ; viewconfiguration config = viewconfiguration . get ( mlauncher ) ; mvelocitytracker . computecurrentvelocity ( _num , config . getscaledmaximumflingvelocity ( ) ) ; if ( mvelocitytracker . getyvelocity ( ) < mflingtodeletethresholdvelocity ) { pointf vel = new pointf ( mvelocitytracker . getxvelocity ( ) , mvelocitytracker . getyvelocity ( ) ) ; pointf upvec = new pointf ( _num , - _num ) ; float theta = ( float ) math . acos ( ( ( vel . x * upvec . x ) + ( vel . y * upvec . y ) ) / ( vel . length ( ) * upvec . length ( ) ) ) ; if ( theta <= math . toradians ( max_fling_degrees ) ) { return vel ; } } return null ; }	determines whether the user flung the current item to delete it .
public static void runscript ( final file file , final list < pair < string , object > > bindings ) throws scriptexception , ioexception { final scriptengine engine = manager . getenginebyextension ( fileutils . getfileextension ( file ) ) ; preconditions . checknotnull ( engine , _str , file . getabsolutepath ( ) ) ; final string script = fileutils . readtextfile ( file ) ; runscript ( engine , script , bindings ) ; }	executes a script file.
public void addugraphic ( ugraphic ug ) { graphics . addelement ( ug ) ; }	add a new ugraphic to the graphiclist.
public void apply ( ) throws illegalstateexception { try { system . setsecuritymanager ( this ) ; } catch ( securityexception e ) { logger . error ( _str , e ) ; throw new illegalstateexception ( e ) ; } }	use this manager as security manager.
public static rule createagetpostrule ( string rulename , string ruleurl ) throws policyexception { map < string , set < string > > actionvalues = new hashmap < string , set < string > > ( ) ; set < string > set = new hashset < string > ( ) ; set . add ( allow_decision ) ; actionvalues . put ( get_action , set ) ; set = new hashset < string > ( ) ; set . add ( allow_decision ) ; actionvalues . put ( post_action , set ) ; return new rule ( rulename , iplanetamwebagentservice , ruleurl , actionvalues ) ; }	create a http get / post rule for the given url .
public fastarraylist ( collection < ? extends e > c ) { elementdata = c . toarray ( ) ; size = elementdata . length ; if ( elementdata . getclass ( ) != object [ ] . class ) elementdata = arrays . copyof ( elementdata , size , object [ ] . class ) ; }	constructs a list containing the elements of the specified collection , in the order they are returned by the collection ' s iterator .
void createscenevao ( ) { int vao = glgenvertexarrays ( ) ; int vbo = glgenbuffers ( ) ; glbindvertexarray ( vao ) ; glbindbuffer ( gl_array_buffer , vbo ) ; long buffersize = _num * ( _num + _num ) * mesh . numvertices ; long normalsoffset = _num * _num * mesh . numvertices ; glbufferdata ( gl_array_buffer , buffersize , gl_static_draw ) ; glbuffersubdata ( gl_array_buffer , _num , mesh . positions ) ; glbuffersubdata ( gl_array_buffer , normalsoffset , mesh . normals ) ; glenablevertexattribarray ( _num ) ; glvertexattribpointer ( _num , _num , gl_float , _bool , _num , _num ) ; glenablevertexattribarray ( _num ) ; glvertexattribpointer ( _num , _num , gl_float , _bool , _num , normalsoffset ) ; glbindbuffer ( gl_array_buffer , _num ) ; glbindvertexarray ( _num ) ; this . vaoscene = vao ; }	creates a vao for the scene .
public list < ? > endbatch ( ) { list < ? > result = null ; if ( operationsbatch . size ( ) > _num ) { result = doflush ( ) ; } usebatch = _bool ; operationsbatch = null ; return result ; }	after this call , the operations will be imediatelly sent to the remote peer.
public static collection removeinnerclassnames ( collection col ) { list list = new arraylist ( ) ; list . addall ( col ) ; iterator it = list . iterator ( ) ; while ( it . hasnext ( ) ) { string name = ( string ) it . next ( ) ; if ( name . indexof ( _str ) != - _num ) it . remove ( ) ; } return list ; }	return a new collection without any inner class names.
public trienode find ( string word ) { return ( word . length ( ) < _num ? null : find ( word , root , _num ) ) ; }	look up the given word in this trie.
private void testorderedindexes ( ) throws sqlexception { deletedb ( _str ) ; connection conn = getconnection ( _str ) ; statement stat = conn . createstatement ( ) ; stat . execute ( _str + _str ) ; stat . execute ( _str ) ; resultset rs = stat . executequery ( _str + _str ) ; rs . next ( ) ; assertcontains ( rs . getstring ( _num ) , _str ) ; stat . execute ( _str ) ; stat . execute ( _str ) ; stat . execute ( _str ) ; stat . execute ( _str ) ; rs = stat . executequery ( _str + _str ) ; rs . next ( ) ; assertcontains ( rs . getstring ( _num ) , _str ) ; conn . close ( ) ; }	where there are multiple indices , and we have an order by , select the index that already has the required ordering .
public string encode ( bytebuffer abuffer ) { byte [ ] buf = getbytes ( abuffer ) ; return encode ( buf ) ; }	260 * a ' streamless ' version of encode that simply takes a bytebuffer 261 * and returns a string containing the encoded buffer.
public static int clearlistinfo ( delegator delegator , string shoppinglistid ) throws genericentityexception { delegator . removebyand ( _str , utilmisc . tomap ( _str , shoppinglistid ) ) ; return delegator . removebyand ( _str , utilmisc . tomap ( _str , shoppinglistid ) ) ; }	remove all items from the given list .
private synchronized void handlewatchdog ( ) { final int exitcode ; if ( watchdog == null ) return ; if ( watchdogtimeout == _num ) return ; if ( ! isrunning ( ) ) { exitcode = oncommandresultlistener . shell_died ; debug . log ( string . format ( _str , shell . touppercase ( locale . english ) ) ) ; } else if ( watchdogcount ++ < watchdogtimeout ) { return ; } else { exitcode = oncommandresultlistener . watchdog_exit ; debug . log ( string . format ( _str , shell . touppercase ( locale . english ) ) ) ; } if ( handler != null ) { postcallback ( command , exitcode , buffer ) ; } command = null ; buffer = null ; idle = _bool ; watchdog . shutdown ( ) ; watchdog = null ; kill ( ) ; }	called from a scheduledthreadpoolexecutor timer thread every second when there is an outstanding command.
public synchronized boolean hasservice ( class serviceclass ) { if ( serviceclass == null ) throw new nullpointerexception ( _str ) ; synchronized ( beancontext . globalhierarchylock ) { if ( services . containskey ( serviceclass ) ) return _bool ; beancontextservices bcs = null ; try { bcs = ( beancontextservices ) getbeancontext ( ) ; } catch ( classcastexception cce ) { return _bool ; } return bcs == null ? _bool : bcs . hasservice ( serviceclass ) ; } }	has a service , which may be delegated.
public static string format ( integer i ) { if ( i == null ) return null ; return i . tostring ( ) ; }	formats the given integer in the format required by a numeric field .
public filenameutils ( ) { super ( ) ; }	instances should not be constructed in standard programming .
public static string convertmethodsignature ( string classname , string methodname , string methodsig , string pkgname ) { stringbuilder args = new stringbuilder ( ) ; signatureconverter converter = new signatureconverter ( methodsig ) ; converter . skip ( ) ; args . append ( _str ) ; while ( converter . getfirst ( ) != _str ) { if ( args . length ( ) > _num ) { args . append ( _str ) ; } args . append ( shorten ( pkgname , converter . parsenext ( ) ) ) ; } converter . skip ( ) ; args . append ( _str ) ; stringbuilder result = new stringbuilder ( ) ; result . append ( classname ) ; result . append ( _str ) ; result . append ( methodname ) ; result . append ( args . tostring ( ) ) ; return result . tostring ( ) ; }	convenience method for generating a method signature in human readable form .
protected void predicate ( ) throws javax . xml . transform . transformerexception { if ( tokenis ( _str ) ) { nexttoken ( ) ; predicateexpr ( ) ; consumeexpected ( _str ) ; } }	predicate : : = ' [ ' predicateexpr ' ] '.
public static string canonicalid ( string id ) { if ( id == null ) return _str ; int st = _num ; int len = id . length ( ) ; boolean substr = _bool ; int c ; while ( st < len && ( ( c = id . charat ( st ) ) == _str || c <= _str ) ) { st ++ ; substr = _bool ; } while ( st < len && ( ( c = id . charat ( len - _num ) ) == _str || c <= _str ) ) { len -- ; substr = _bool ; } return substr ? id . substring ( st , len ) : id ; }	convert a message - id string to canonical form ( strips off leading and trailing & lt ; & gt ; s ).
private static void encodebinary ( byte [ ] bytes , int startpos , int count , int startmode , stringbuilder sb ) { if ( count == _num && startmode == text_compaction ) { sb . append ( ( char ) shift_to_byte ) ; } else { boolean sixpack = ( ( count % _num ) == _num ) ; if ( sixpack ) { sb . append ( ( char ) latch_to_byte ) ; } else { sb . append ( ( char ) latch_to_byte_padded ) ; } } int idx = startpos ; if ( count >= _num ) { char [ ] chars = new char [ _num ] ; while ( ( startpos + count - idx ) >= _num ) { long t = _num ; for ( int i = _num ; i < _num ; i ++ ) { t <<= _num ; t += bytes [ idx + i ] & _num ; } for ( int i = _num ; i < _num ; i ++ ) { chars [ i ] = ( char ) ( t % _num ) ; t /= _num ; } for ( int i = chars . length - _num ; i >= _num ; i -- ) { sb . append ( chars [ i ] ) ; } idx += _num ; } } for ( int i = idx ; i < startpos + count ; i ++ ) { int ch = bytes [ i ] & _num ; sb . append ( ( char ) ch ) ; } }	encode parts of the message using byte compaction as described in iso / iec 15438 : 2001 ( e ) , chapter 4.
protected void copy2darray ( int from [ ] [ ] , int to [ ] [ ] ) { for ( int i = _num ; i < from . length ; i ++ ) { to [ i ] = new int [ from [ i ] . length ] ; system . arraycopy ( from [ i ] , _num , to [ i ] , _num , from [ i ] . length ) ; } }	copies one array of type int [ ] [ ] to another .
public static < k , v > map < k , v > of ( k k1 , v v1 , k k2 , v v2 , k k3 , v v3 ) { map map = of ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; map . put ( k3 , v3 ) ; return map ; }	returns map containing the given entries .
public boolean fill ( reader reader , int pos ) throws ioexception { int res = reader . read ( fbuf ) ; if ( res == - _num ) { foffset = pos ; flength = _num ; return _bool ; } int charsread = res ; while ( charsread < buffer_size ) { res = reader . read ( fbuf , charsread , buffer_size - charsread ) ; if ( res == - _num ) { foffset = pos ; flength = charsread ; return _bool ; } charsread += res ; } foffset = pos ; flength = buffer_size ; return _bool ; }	fills the buffer by reading from the given reader .
public void drawinrect ( gl10 gl , cgrect rect ) { gl . glenable ( gl_texture_2d ) ; loadtexture ( gl ) ; float vertices [ ] = { rect . origin . x , rect . origin . y , rect . origin . x + rect . size . width , rect . origin . y , rect . origin . x , rect . origin . y + rect . size . height , rect . origin . x + rect . size . width , rect . origin . y + rect . size . height } ; mvertices . put ( vertices ) ; mvertices . position ( _num ) ; float coordinates [ ] = { _num , _maxt , _maxs , _maxt , _num , _num , _maxs , _num } ; mcoordinates . put ( coordinates ) ; mcoordinates . position ( _num ) ; gl . glenableclientstate ( gl_vertex_array ) ; gl . glenableclientstate ( gl_texture_coord_array ) ; gl . glbindtexture ( gl_texture_2d , _name ) ; gl . gltexparameterx ( gl_texture_2d , gl_texture_wrap_s , gl_repeat ) ; gl . gltexparameterx ( gl_texture_2d , gl_texture_wrap_t , gl_repeat ) ; gl . glvertexpointer ( _num , gl_float , _num , mvertices ) ; gl . gltexcoordpointer ( _num , gl_float , _num , mcoordinates ) ; gl . gldrawarrays ( gl_triangle_strip , _num , _num ) ; gl . gldisableclientstate ( gl_vertex_array ) ; gl . gldisableclientstate ( gl_texture_coord_array ) ; gl . gldisable ( gl_texture_2d ) ; }	draws a texture inside a rect.
synchronized void executed ( rtedittext editor , operation op ) { stack < operation > undostack = getundostack ( editor ) ; stack < operation > redostack = getredostack ( editor ) ; while ( ! undostack . empty ( ) && op . canmerge ( undostack . peek ( ) ) ) { operation previousop = undostack . pop ( ) ; op . merge ( previousop ) ; } push ( op , undostack ) ; redostack . clear ( ) ; }	call this when an operation is performed to add it to the undo stack .
public static boolean isossbuild ( ) { boolean isossbuild = _bool ; string buildtype = system . getproperty ( _str ) ; if ( stringutils . isnotblank ( buildtype ) && buildtype . equalsignorecase ( _str ) ) { isossbuild = _bool ; } return isossbuild ; }	checks if the build is a open source build or emc enterprise build.
public void invokehookboltexecute ( tuple tuple , long executelatencyns ) { if ( taskhooks . size ( ) != _num ) { boltexecuteinfo executeinfo = new boltexecuteinfo ( tuple , getthistaskid ( ) , executelatencyns / constants . milliseconds_to_nanoseconds ) ; for ( itaskhook taskhook : taskhooks ) { taskhook . boltexecute ( executeinfo ) ; } } }	task hook called in bolt every time a tuple gets executed.
private void validateiamroles ( list < iamrole > iamroles ) { assert . notnull ( iamroles , _str ) ; assert . istrue ( iamroles . size ( ) > _num , _str ) ; for ( iamrole iamrole : iamroles ) { assert . notnull ( iamrole , _str ) ; assert . hastext ( iamrole . getiamrolename ( ) , _str ) ; } }	asserts that the given iam roles are valid as a user input.
public static intent buildstartinbackgroundintent ( file script ) { final componentname componentname = constants . sl4a_service_launcher_component_name ; intent intent = new intent ( ) ; intent . setcomponent ( componentname ) ; intent . setaction ( constants . action_launch_background_script ) ; intent . putextra ( constants . extra_script_path , script . getabsolutepath ( ) ) ; return intent ; }	builds an intent that will launch a script in the background .
public static java . lang . string valueof ( java . lang . object obj ) { return obj == null ? _str : obj . tostring ( ) ; }	returns the string representation of the object argument .
@ suppresswarnings ( { _str , _str } ) public spanmultitermquerywrapper ( q query ) { this . query = objects . requirenonnull ( query ) ; this . rewritemethod = selectrewritemethod ( query ) ; }	create a new spanmultitermquerywrapper .
public void writemapend ( ) throws ioexception { os . write ( _str ) ; }	writes the tail of the map to the stream .
public shape createarrowup ( final double x , final double y , final double w , final double h ) { path . reset ( ) ; path . moveto ( x , y + h ) ; path . lineto ( x + w / _num , y ) ; path . lineto ( x + w , y + h ) ; path . closepath ( ) ; return path ; }	return a path for an arrow pointing up .
protected void firevaluechanged ( ) { changeevent evt = new changeevent ( this ) ; for ( changelistener listener : listenerlist . getlisteners ( changelistener . class ) ) { listener . statechanged ( evt ) ; } }	notify listeners of a changed value .
public static void streamcontenttobrowser ( httpservletresponse response , inputstream in , int length , string contenttype , string filename ) throws ioexception { setresponsebrowserproxynocache ( response ) ; response . setcontentlength ( length ) ; if ( contenttype != null ) { response . setcontenttype ( contenttype ) ; } if ( filename != null ) { response . setheader ( _str , _str + filename ) ; } outputstream out = response . getoutputstream ( ) ; try { streamcontent ( out , in , length ) ; } catch ( ioexception e ) { out . close ( ) ; throw e ; } out . flush ( ) ; out . close ( ) ; }	streams content from inputstream to the servletoutputstream this method will close the servletoutputstream when finished this method does not close the inputsteam passed.
public static bytebuffer encode ( string string ) throws charactercodingexception { return encode ( string , _bool ) ; }	converts the provided string to bytes using the utf - 8 encoding.
public void disablerealtimestepsnotify ( ) { checkconnection ( ) ; final list < bleaction > list = new arraylist < > ( ) ; list . add ( new writeaction ( profile . uuid_char_control_point , protocol . disable_realtime_steps_notify ) ) ; queue ( list ) ; }	stops listening to step count in real time.
public static void unregistertilecodec ( int comp ) { xtifftilecodec cod = gettilecodec ( comp ) ; tilecodecs . remove ( cod ) ; }	unregister the xtifftilecodec corresponding to the tiff compression type .
public static void escape ( strbuilder toappend , string text , boolean escapequote , boolean escapeapos ) { if ( text == null ) { return ; } for ( int i = _num ; i < text . length ( ) ; i ++ ) { char ch = text . charat ( i ) ; switch ( ch ) { case _str : toappend . append ( _str ) ; break ; case _str : toappend . append ( _str ) ; break ; case _str : toappend . append ( _str ) ; break ; case _str : toappend . append ( escapequote ? _str : ch ) ; break ; case _str : toappend . append ( escapeapos ? _str : ch ) ; break ; default : toappend . append ( ch ) ; break ; } } }	escapes any xml entities in the text , appending the result to the strbuilder .
public void destroy ( ) { mlisteners . clear ( ) ; mspringsystem . deregisterspring ( this ) ; }	destroys this spring , meaning that it will be deregistered from its basespringsystem so it won ' t be iterated anymore and will clear its set of listeners.
@ override public synchronized void removeinstancelistener ( instancelistener tsl ) { m_instancelisteners . removeelement ( tsl ) ; }	remove an instance listener.
private void togglefavorite ( ) { for ( string game : list . getselectedvalueslist ( ) ) { if ( favorites . contains ( game ) ) { favorites . remove ( game ) ; } else { favorites . add ( game ) ; } } savefavorites ( ) ; update ( ) ; }	removes all selected favorites and adds all selected non - favorites as favorites .
private void createpartitionregion ( list vmlist , int startindexforregion , int endindexforregion , int localmaxmemory , int redundancy , boolean firstcreationflag , boolean multiplevmflag ) { iterator nodeiterator = vmlist . iterator ( ) ; while ( nodeiterator . hasnext ( ) ) { vm vm = ( vm ) nodeiterator . next ( ) ; vm . invoke ( createmultiplepartitionregion ( prprefix , startindexforregion , endindexforregion , redundancy , localmaxmemory , firstcreationflag , multiplevmflag ) ) ; } }	this function createas multiple partition regions on nodes specified in the vmlist.
public boolean hasextensionswithdeps ( ) { return ! extensionswithdeps . isempty ( ) ; }	tells whether or not this add - on has at least one extension with dependencies .
public synchronized void addseries ( xyseries series ) { mseries . add ( series ) ; }	adds a new xy series to the list .
private int [ ] calculatetaskcountpercontainer ( int taskcount , int prevcontainercount , int currentcontainercount ) { int [ ] newtaskcountpercontainer = new int [ math . max ( currentcontainercount , prevcontainercount ) ] ; arrays . fill ( newtaskcountpercontainer , _num ) ; for ( int i = _num ; i < currentcontainercount ; i ++ ) { newtaskcountpercontainer [ i ] = taskcount / currentcontainercount ; if ( taskcount % currentcontainercount > i ) { newtaskcountpercontainer [ i ] ++ ; } } return newtaskcountpercontainer ; }	calculates the expected number of tasks for each container.
@ override public void actionperform ( component component ) { if ( ! isenabled ( ) ) { return ; } if ( beforeactionperformedhandler != null ) { if ( ! beforeactionperformedhandler . beforeactionperformed ( ) ) return ; } set selected = target . getselected ( ) ; if ( ! selected . isempty ( ) ) { if ( confirm ) { confirmandremove ( selected ) ; } else { remove ( selected ) ; } } }	this method is invoked by the action owner component .
public void testcomparetopospos2 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , _num , _num } ; int asign = _num ; int bsign = _num ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; assertequals ( - _num , anumber . compareto ( bnumber ) ) ; }	compareto ( biginteger a ).
static public void generateseed ( byte [ ] result ) { instance . getseedbytes ( result ) ; }	fill result with bytes from the queue.
private double hammingdistancenumbervector ( numbervector o1 , numbervector o2 ) { final int d1 = o1 . getdimensionality ( ) , d2 = o2 . getdimensionality ( ) ; int differences = _num ; int d = _num ; for ( ; d < d1 && d < d2 ; d ++ ) { double v1 = o1 . doublevalue ( d ) , v2 = o2 . doublevalue ( d ) ; if ( v1 != v1 || v2 != v2 ) { continue ; } if ( v1 != v2 ) { ++ differences ; } } for ( ; d < d1 ; d ++ ) { double v1 = o1 . doublevalue ( d ) ; if ( v1 != _num && v1 == v1 ) { ++ differences ; } } for ( ; d < d2 ; d ++ ) { double v2 = o2 . doublevalue ( d ) ; if ( v2 != _num && v2 == v2 ) { ++ differences ; } } return differences ; }	version for number vectors .
public static kernel createkernel ( int kerneltype ) { switch ( kerneltype ) { case kernel_radial : return new kernelradial ( ) ; case kernel_polynomial : return new kernelpolynomial ( ) ; case kernel_neural : return new kernelneural ( ) ; default : return new kerneldot ( ) ; } }	creates a new kernel of the given type.
protected void checkforpendingtasks ( collection < uri > tenants , collection < ? extends dataobject > dataobjects ) { for ( uri tenant : tenants ) { checkforpendingtasks ( tenant , dataobjects ) ; } }	given a list of tenants and dataobject references , check if any of the dataobjects have pending tasks against them.
@ org . junit . test public void verifygetfloatresponse ( ) throws exception { map < string , string > queryparams = new hashmap < string , string > ( ) ; string str = client . invokeapi ( _str , _str , queryparams , null , new hashmap < string , string > ( ) , null , _str , null , new string [ _num ] ) ; assertequals ( str , string . valueof ( examplebuilder . sample_float_property_value ) ) ; }	verifies that the return value is automatically created.
public static double median ( final double [ ] values ) { final int len = values . length ; final double [ ] sortedvalues = arrays . copyof ( values , len ) ; arrays . sort ( sortedvalues ) ; if ( len % _num == _num ) { return ( ( double ) sortedvalues [ len / _num ] + ( double ) sortedvalues [ len / _num - _num ] ) / _num ; } else { return ( double ) sortedvalues [ len / _num ] ; } }	computes the median of the values in the input array .
private list < blockinfo > fillsegmentidtotableinfomap ( list < tableblockinfo > tableblockinfos , absolutetableidentifier absolutetableidentifier ) { map < string , list < blockinfo > > map = segmentidtoblocklistmap . get ( absolutetableidentifier ) ; if ( null == map ) { map = new concurrenthashmap < string , list < blockinfo > > ( ) ; segmentidtoblocklistmap . put ( absolutetableidentifier , map ) ; } blockinfo temp = null ; list < blockinfo > blockinfosneedtoload = new arraylist < > ( ) ; for ( tableblockinfo info : tableblockinfos ) { list < blockinfo > temptableblockinfos = map . get ( info . getsegmentid ( ) ) ; if ( null == temptableblockinfos ) { temptableblockinfos = new arraylist < > ( ) ; map . put ( info . getsegmentid ( ) , temptableblockinfos ) ; } temp = new blockinfo ( info ) ; if ( ! temptableblockinfos . contains ( temp ) ) { temptableblockinfos . add ( temp ) ; } blockinfosneedtoload . add ( temp ) ; } return blockinfosneedtoload ; }	below method will be used to fill segment id to its block mapping map . it will group all the table block info based on segment id and it will fill.
public charbuffer put ( string str , int start , int end ) { if ( isreadonly ( ) ) { throw new readonlybufferexception ( ) ; } if ( start < _num || end < start || end > str . length ( ) ) { throw new indexoutofboundsexception ( _str + str . length ( ) + _str + start + _str + end ) ; } if ( end - start > remaining ( ) ) { throw new bufferoverflowexception ( ) ; } for ( int i = start ; i < end ; i ++ ) { put ( str . charat ( i ) ) ; } return this ; }	writes chars of the given string to the current position of this buffer , and increases the position by the number of chars written .
public list < offerrecommendation > evaluate ( list < offer > offers ) { list < offerrecommendation > recommendations = new arraylist < offerrecommendation > ( ) ; int offerresourcecount = _num ; for ( offer offer : offers ) { offerresourcecount += offer . getresourcescount ( ) ; for ( resource todestroy : selectunexpectedresources ( expectedpersistentvolumeids , getpersistentvolumesbyid ( offer ) ) ) { recommendations . add ( new destroyofferrecommendation ( offer , todestroy ) ) ; } } int destroyrecommendationcount = recommendations . size ( ) ; for ( offer offer : offers ) { for ( resource tounreserve : selectunexpectedresources ( expectedreservedresourceids , getreservedresourcesbyid ( offer ) ) ) { recommendations . add ( new unreserveofferrecommendation ( offer , tounreserve ) ) ; } } logger . info ( _str , offers . size ( ) , offerresourcecount , destroyrecommendationcount , recommendations . size ( ) - destroyrecommendationcount ) ; return recommendations ; }	returns a list of operations which should be performed , given the provided list of offers from mesos.
@ override public int update ( bytebuffer inbuffer , bytebuffer outbuffer ) throws shortbufferexception { return cipher . update ( inbuffer , outbuffer ) ; }	continues a multiple - part encryption / decryption operation.
boolean displaycontextassump ( noderepresentation rep , int i ) { return rep . iscreated || ( ( ! state . splitchosen ( ) ) && showcontextvalue ) ; }	this returns true iff we should display a context assumption rep = state.
private void unregistermbeans ( ) { list < objectname > unregistered = new arraylist < objectname > ( ) ; for ( objectname name : mbeans ) { try { mbeanserver . unregistermbean ( name ) ; unregistered . add ( name ) ; } catch ( jmexception e ) { } } mbeans . removeall ( unregistered ) ; }	unregister all jmx mbeans.
public static void main ( string [ ] argv ) throws ioexception , saxexception { scanner s = new htmlscanner ( ) ; reader r = new inputstreamreader ( system . in , _str ) ; writer w = new outputstreamwriter ( system . out , _str ) ; pyxwriter pw = new pyxwriter ( w ) ; s . scan ( r , pw ) ; w . close ( ) ; }	test procedure . reads html from the standard input and writes pyx to the standard output .
private void createampresultstreammethod ( javaclass jclass , method method , int resultoffset ) { string methodname = method . getname ( ) ; class < ? > [ ] parametertypes = method . getparametertypes ( ) ; annotation [ ] [ ] parameteranns = method . getparameterannotations ( ) ; addmethod ( method ) ; codewriterattribute code = createmethodheader ( jclass , method ) ; code . setmaxlocals ( _num + _num * parametertypes . length ) ; code . setmaxstack ( _num + _num * parametertypes . length ) ; code . pushobjectvar ( _num ) ; code . getfield ( jclass . getthisclass ( ) , _str , messagefactoryamp . class ) ; int arglen = parametertypes . length - _num ; code . pushobjectvar ( getlength ( parametertypes , resultoffset ) + _num ) ; long timeout = _defaulttimeout ; code . pushconstant ( timeout ) ; code . pushobjectvar ( _num ) ; code . getfield ( jclass . getthisclass ( ) , _str , servicerefamp . class ) ; code . pushobjectvar ( _num ) ; code . getfield ( jclass . getthisclass ( ) , fieldname ( method ) , methodamp . class ) ; partitionmethod ( code , parametertypes , parameteranns ) ; pushparameters ( code , parametertypes , parameteranns , _num , _num , arglen + _num , resultoffset ) ; code . invokeinterface ( messagefactoryamp . class , _str , void . class , resultstream . class , long . class , servicerefamp . class , methodamp . class , object [ ] . class ) ; code . addreturn ( ) ; code . close ( ) ; }	void foo ( x a1 , y a2 , resultstream < t > result ) { stream ( __caucho_getcurrentcontext ( ) , cont , timeout , _methodref , new object [ ] { a1 , a2 } ) . send ( ) ; }.
private static synchronized void endtransaction ( connection c , boolean successful ) throws adeexception { logger . trace ( _str ) ; try { if ( successful ) { c . commit ( ) ; } else { c . rollback ( ) ; } c . setautocommit ( _bool ) ; } catch ( throwable t ) { surfacethrowable ( _str , t ) ; throw adeexceptionof ( t ) ; } logger . trace ( _str ) ; }	thin wrapper around jdbc connection.
public double [ ] estimatel2distancesquared ( datum querydatum ) { realvector vector = querydatum . metrics ( ) ; double [ ] estimates = new double [ _num ] ; for ( int i = _num ; i < k ; i ++ ) { double deltalo = vector . getentry ( i ) - this . boundaries [ i ] [ _num ] ; double deltahi = this . boundaries [ i ] [ _num ] - vector . getentry ( i ) ; double sqdeltalo = deltalo * deltalo ; double sqdeltahi = deltahi * deltahi ; if ( deltalo < _num || deltahi < _num ) { if ( sqdeltahi < sqdeltalo ) { estimates [ _num ] += sqdeltahi ; estimates [ _num ] += sqdeltalo ; } else { estimates [ _num ] += sqdeltalo ; estimates [ _num ] += sqdeltahi ; } } else { estimates [ _num ] += math . max ( sqdeltahi , sqdeltalo ) ; } } return estimates ; }	estimates bounds on the distance to a region.
private void deserializeclass ( file file ) throws runtimeexception { try { fileinputstream in = new fileinputstream ( file ) ; objectinputstream objin = new objectinputstream ( in ) ; object o = objin . readobject ( ) ; in . close ( ) ; } catch ( classnotfoundexception e ) { throw new runtimeexception ( _str + _str + file + _str + _str + _str , e ) ; } catch ( ioexception e ) { throw new runtimeexception ( _str + _str + file + _str , e ) ; } }	deserializes the information in the given file , returning the object represented .
private boolean canopen ( ) { for ( final inaviproject project : m_projects ) { if ( project . isloaded ( ) ) { return _bool ; } } return _bool ; }	determines whether all nodes for which the menu is built are unloaded .
public static array listwithquotestoarray ( string list , string delimiter , string quotes ) { if ( list . length ( ) == _num ) return new arrayimpl ( ) ; int len = list . length ( ) ; int last = _num ; char [ ] del = delimiter . tochararray ( ) ; char [ ] quo = quotes . tochararray ( ) ; char c ; char inside = _num ; arrayimpl array = new arrayimpl ( ) ; try { for ( int i = _num ; i < len ; i ++ ) { c = list . charat ( i ) ; for ( int y = _num ; y < quo . length ; y ++ ) { if ( c == quo [ y ] ) { if ( c == inside ) inside = _num ; else if ( inside == _num ) inside = c ; continue ; } } for ( int y = _num ; y < del . length ; y ++ ) { if ( inside == _num && c == del [ y ] ) { array . _append ( list . substring ( last , i ) ) ; last = i + _num ; break ; } } } if ( last <= len ) array . append ( list . substring ( last ) ) ; } catch ( expressionexception e ) { } return array ; }	casts a list to array object , the list can be have quoted ( " , ' ) arguments and delimter in this arguments are ignored . quotes are not removed example : listwithquotestoarray ( " aab , a ' a , b ' , a \ " a , b \ " " , " , " , " \ " ' " ) will be translated to [ " aab " , " a ' a , b ' " , " a \ " a , b \ " " ].
public mloutput execute ( string dmlscriptfilepath , arraylist < string > argsname , arraylist < string > argsvalues , string configfilepath ) throws ioexception , dmlexception , parseexception { hashmap < string , string > newnamedargs = new hashmap < string , string > ( ) ; if ( argsname . size ( ) != argsvalues . size ( ) ) { throw new dmlexception ( _str + argsname . size ( ) + _str + _str ) ; } for ( int i = _num ; i < argsname . size ( ) ; i ++ ) { string k = argsname . get ( i ) ; string v = argsvalues . get ( i ) ; newnamedargs . put ( k , v ) ; } return execute ( dmlscriptfilepath , newnamedargs , configfilepath ) ; }	execute dml script by passing positional arguments using specified config file.
public boolean isinmemorydb ( ) { return path . equalsignorecase ( memory_db_path ) ; }	returns true if the database is in - memory .
private static boolean testspecificvalue ( double x , double y , double expectedvalue , double interpvalue ) { logger . info ( _str + x + _str + y + _str + expectedvalue + _str + interpvalue + _str ) ; boolean specificvalueinterpuseful = _bool ; if ( interpvalue > expectedvalue + _num || interpvalue < expectedvalue - _num ) specificvalueinterpuseful = _bool ; return specificvalueinterpuseful ; }	tests the interpolation of a specific expected or known value.
@ override public string leavedtd ( ) { if ( _writer == _dtdwriter ) { _line . append ( _text ) ; _text = new stringbuffer ( _num ) ; flushline ( _bool ) ; _writer = _docwriter ; return _dtdwriter . tostring ( ) ; } return null ; }	called by the root element to leave dtd mode and if any dtd parts were printer , will return a string with their textual content .
private static classnode loadclass ( string name , config config ) throws exception { string filepath = config . getclassdumppath ( ) + name . replace ( _str , _str ) + _str ; classreader reader = new classreader ( new fileinputstream ( filepath ) ) ; classnode node = new classnode ( ) ; reader . accept ( node , classreader . expand_frames ) ; return node ; }	find and return the class of the given name.
public void write ( char [ ] cbuf , int off , int len ) throws ioexception { internalout . write ( cbuf , off , len ) ; }	writes a portion of an array of characters .
public void add ( final string clazz , final string subclazz , final boolean blocked ) { entries . add ( new entry ( clazz , subclazz , blocked ) ) ; }	add a criteria entry .
private synchronized void bufferchange ( ) throws readfailedexception { bytebuffer current = super . getbytebuffer ( ) ; if ( null != current ) { current . clear ( ) ; emptybuffers . add ( current ) ; } int tries = _num ; while ( _bool ) { try { bytebuffer buffer = fullbuffers . poll ( _num , timeunit . milliseconds ) ; if ( null != buffer ) { super . setbytebuffer ( buffer ) ; break ; } else { tries ++ ; if ( readfailed || ( tries > max_buffer_pool_tries ) ) { throw new readfailedexception ( _str ) ; } } } catch ( interruptedexception e ) { thread . interrupted ( ) ; } } }	changes the current buffer used for streaming with a full one .
protected synchronized class loadclass ( string name , boolean resolve ) throws classnotfoundexception { class c = findloadedclass ( name ) ; if ( c == null ) c = findclass ( name ) ; if ( c == null ) throw new classnotfoundexception ( name ) ; if ( resolve ) resolveclass ( c ) ; return c ; }	requests the class loader to load a class .
@ suppresswarnings ( { _str , _str } ) public static comparable < ? > max ( comparable < ? > [ ] ar ) { comparable ret = ar [ _num ] ; for ( int i = _num ; i < ar . length ; i ++ ) { if ( ret . compareto ( ar [ i ] ) < _num ) { ret = ar [ i ] ; } } return ret ; }	locate the maximum value from an array of comparables .
private void initbprmadetails ( int c_bpartner_id ) { rmafield . removeactionlistener ( this ) ; rmafield . removeallitems ( ) ; keynamepair pp = new keynamepair ( _num , _str ) ; rmafield . additem ( pp ) ; arraylist < keynamepair > list = loadrmadata ( c_bpartner_id ) ; for ( keynamepair knp : list ) rmafield . additem ( knp ) ; rmafield . setselectedindex ( _num ) ; rmafield . addactionlistener ( this ) ; }	load rma that are candidates for shipment.
protected void resetoptions ( ) { m_maxstale = _num ; m_searchdirection = selection_forward ; m_starting = null ; m_startrange = new range ( ) ; m_classindex = - _num ; m_totalevals = _num ; m_cachesize = _num ; m_debug = _bool ; }	reset options to default values.
@ override protected void teardown ( ) throws exception { try { takescreenshot ( ) ; } catch ( throwable throwable ) { throwable . printstacktrace ( ) ; } super . teardown ( ) ; }	takes a screenshot after every test.
private boolean itera_connect ( plapointint p_from_point , plapointint p_to_point ) { arraylist < plapointint > corners = angled_connection ( p_from_point , p_to_point ) ; boolean connection_succeeded = _bool ; for ( int index = _num ; index < corners . size ( ) ; ++ index ) { plapointint from_corner = corners . get ( index - _num ) ; plapointint to_corner = corners . get ( index ) ; timelimit time_limit = new timelimit ( s_check_forced_trace_time_max ) ; while ( ! from_corner . equals ( to_corner ) ) { plapointint curr_ok_point = r_board . insert_trace ( from_corner , to_corner , pen_half_width_arr [ layer_active_no ] , layer_active_no , net_nos , clearance_class , max_shove_trace_recursion_depth , max_shove_via_recursion_depth , max_spring_over_recursion_depth , itera_settings . trace_pullt_min_move , ! is_stitch_mode , time_limit ) ; if ( curr_ok_point == null ) { r_board . undo ( null ) ; return _bool ; } if ( curr_ok_point . equals ( from_corner ) && itera_settings . is_automatic_neckdown ( ) ) { curr_ok_point = try_neckdown_at_end ( from_corner , to_corner ) ; } if ( curr_ok_point . equals ( from_corner ) ) { prev_corner = from_corner ; connection_succeeded = _bool ; break ; } from_corner = curr_ok_point ; } } return connection_succeeded ; }	tries to make a trace connection from p_from_point to p_to_point according to the angle restriction .
private node < k , v > findpredecessoroflast ( ) { for ( ; ; ) { index < k , v > q = head ; for ( ; ; ) { index < k , v > d , r ; if ( ( r = q . right ) != null ) { if ( r . indexesdeletednode ( ) ) { q . unlink ( r ) ; break ; } if ( r . node . next != null ) { q = r ; continue ; } } if ( ( d = q . down ) != null ) q = d ; else return q . node ; } } }	specialized variant of findpredecessor to get predecessor of last valid node.
public boolean query ( int objecttoquery , long [ ] [ ] hashfunctions ) { for ( long [ ] h : hashfunctions ) { int i = hash ( h , ( long ) objecttoquery ) ; if ( ! bitset . get ( i ) ) return _bool ; } return _bool ; }	determines whether an item ( represented by an integer ) is present in the bloom filter .
@ safevarargs public static < v > set < v > createset ( v ... values ) { set < v > set = new linkedhashset < v > ( ) ; for ( v v : values ) { set . add ( v ) ; } return set ; }	create a set for the provided values .
public void stop ( ) { timemonindex = _num ; setexception ( ) ; iterator iter = iter ( ) ; while ( iter . hasnext ( ) ) { httpmonitem monitem = ( httpmonitem ) iter . next ( ) ; monitem . stop ( this ) ; } if ( stacktrace != null ) changedetails ( ) ; }	method called to stop any active http monitoring requests , and responses.
public void calcmintick ( ) { if ( mindata == _num ) mintick = _num ; else mintick = math . floor ( mindata / majortick ) * majortick ; }	calculate the optimum minimum tick . override to change default behaviour.
public static void switchtiming ( string nextphase ) { stopmostrecenttimer ( ) ; starttiming ( nextphase ) ; }	stop the most recent stopwatch and start this one.
public byte [ ] encode ( ) { char type = getattributetype ( ) ; if ( ! istypevalid ( type ) ) throw new illegalstateexception ( ( ( int ) type ) + _str ) ; byte binvalue [ ] = new byte [ header_length + getdatalength ( ) ] ; binvalue [ _num ] = ( byte ) ( type > > _num ) ; binvalue [ _num ] = ( byte ) ( type & _num ) ; binvalue [ _num ] = ( byte ) ( getdatalength ( ) > > _num ) ; binvalue [ _num ] = ( byte ) ( getdatalength ( ) & _num ) ; binvalue [ _num ] = _num ; binvalue [ _num ] = getfamily ( ) ; binvalue [ _num ] = ( byte ) ( getport ( ) > > _num ) ; binvalue [ _num ] = ( byte ) ( getport ( ) & _num ) ; if ( getfamily ( ) == address_family_ipv6 ) { system . arraycopy ( getaddressbytes ( ) , _num , binvalue , _num , _num ) ; } else { system . arraycopy ( getaddressbytes ( ) , _num , binvalue , _num , _num ) ; } return binvalue ; }	returns a binary representation of this attribute .
private void dodeleteentry ( string alias ) throws exception { if ( keystore . containsalias ( alias ) == _bool ) { messageformat form = new messageformat ( rb . getstring ( _str ) ) ; object [ ] source = { alias } ; throw new exception ( form . format ( source ) ) ; } keystore . deleteentry ( alias ) ; }	deletes an entry from the keystore .
protected integer mapthrowableflat ( throwable throwable ) { class < ? extends throwable > throwableclass = throwable . getclass ( ) ; integer resid = throwabletomsgidmap . get ( throwableclass ) ; if ( resid == null ) { class < ? extends throwable > closestclass = null ; set < entry < class < ? extends throwable > , integer > > mappings = throwabletomsgidmap . entryset ( ) ; for ( entry < class < ? extends throwable > , integer > mapping : mappings ) { class < ? extends throwable > candidate = mapping . getkey ( ) ; if ( candidate . isassignablefrom ( throwableclass ) ) { if ( closestclass == null || closestclass . isassignablefrom ( candidate ) ) { closestclass = candidate ; resid = mapping . getvalue ( ) ; } } } } return resid ; }	mapping without checking the cause ( done in mapthrowable ) .
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( ) ; newvector . add ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . add ( new option ( _str , _str , _num , _str ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public void assertcolumntype ( resultset rs ) throws sqlexception { resultsetmetadata md = rs . getmetadata ( ) ; int sqltype = md . getcolumntype ( mdi . getposition ( ) ) ; asserttrue ( string . format ( _str , sqltype , mdi ) , isallowedsqltype ( sqltype ) ) ; }	asserts the type of this column as reported by the resultsetmetadata of this resultset .
private void validatednsnames ( set dnsnameset ) throws policyexception { iterator dnsnames = dnsnameset . iterator ( ) ; while ( dnsnames . hasnext ( ) ) { string dnsname = ( string ) dnsnames . next ( ) ; validatednsname ( dnsname ) ; dnslist . add ( dnsname . tolowercase ( ) ) ; } }	validates if the value of property dns_name is correct and adheres to the expected format.
public static boolean ismopmethod ( string methodname ) { return ( methodname . startswith ( _str ) || methodname . startswith ( _str ) ) && ! methodname . contains ( _str ) ; }	method to determine if a method is a mop method.
protected void init ( ) { graphicsconfigtemplate3d template = new graphicsconfigtemplate3d ( ) ; graphicsenvironment env = graphicsenvironment . getlocalgraphicsenvironment ( ) ; graphicsdevice device = env . getdefaultscreendevice ( ) ; graphicsconfiguration config = device . getbestconfiguration ( template ) ; canvas = new canvas3d ( config ) ; canvas . setsize ( new dimension ( default_dimension , default_dimension ) ) ; objrootbg = new branchgroup ( ) ; objrootbg . setcapability ( group . allow_children_extend ) ; constructworld ( objrootbg ) ; }	set up the canvas and the universe .
private < delegated > presenterbinder < ? super delegated > findpresenterbinderforclass ( class < delegated > clazz ) throws illegalaccessexception , instantiationexception { presenterbinder < ? super delegated > presenterbinder ; string clsname = clazz . getname ( ) ; string classname = clsname + presenter_binder_suffix ; try { class < ? > presenterbinderclass = class . forname ( classname ) ; presenterbinder = ( presenterbinder < ? super delegated > ) presenterbinderclass . newinstance ( ) ; } catch ( classnotfoundexception e ) { return null ; } return presenterbinder ; }	find generated binder for class.
@ override final node < k , v > find ( int h , object k ) { if ( k != null ) { for ( node < k , v > e = first ; e != null ; ) { int s ; if ( ( ( s = lockstate ) & ( waiter | writer ) ) != _num ) { if ( e . hash == h && isequal ( ( k ) k , e . key , myhashingstrategy ) ) { return e ; } e = e . next ; } else if ( u . compareandswapint ( this , lockstate , s , s + reader ) ) { treenode < k , v > r , p ; try { p = ( ( r = root ) == null ? null : r . findtreenode ( h , k , null ) ) ; } finally { int ls ; do { } while ( ! u . compareandswapint ( this , lockstate , ls = lockstate , ls - reader ) ) ; thread w ; if ( ls == ( reader | waiter ) && ( w = waiter ) != null ) { locksupport . unpark ( w ) ; } } return p ; } } } return null ; }	returns matching node or null if none.
public void square ( double x , double y , double r ) { if ( r < _num ) throw new illegalargumentexception ( _str ) ; double xs = scalex ( x ) ; double ys = scaley ( y ) ; double ws = factorx ( _num * r ) ; double hs = factory ( _num * r ) ; if ( ws <= _num && hs <= _num ) pixel ( x , y ) ; else offscreen . draw ( new rectangle2d . double ( xs - ws / _num , ys - hs / _num , ws , hs ) ) ; draw ( ) ; }	draws a square of side length 2r , centered on ( x , y ) .
private int lowerheightmap ( int x , int y , int z ) { for ( -- y ; y >= _num ; -- y ) { if ( gettype ( x , z , y ) != _num ) { break ; } } return y + _num ; }	scan downwards to determine the new height map value .
public string tostring ( ) { stringbuffer result = new stringbuffer ( _str ) ; for ( int i = _num ; i < intervalls . size ( ) ; i ++ ) result . append ( intervalls . elementat ( i ) ) ; result . append ( _str ) ; return result . tostring ( ) ; }	make a string representation of this char set .
public void remove ( @ notnull statusnotification notification ) { stack . remove ( notification ) ; onclose ( notification ) ; }	remove notification from message stack .
private jobdefinitionentity createorupdatejobdefinitionentity ( jobdefinitionentity jobdefinitionentity , namespaceentity namespaceentity , string jobname , string description , string activitiid , list < parameter > parameters , s3propertieslocation s3propertieslocation ) { jobdefinitionentity jobdefinitionentitylocal = jobdefinitionentity ; if ( jobdefinitionentitylocal == null ) { jobdefinitionentitylocal = new jobdefinitionentity ( ) ; } jobdefinitionentitylocal . setname ( jobname ) ; jobdefinitionentitylocal . setnamespace ( namespaceentity ) ; jobdefinitionentitylocal . setdescription ( description ) ; jobdefinitionentitylocal . setactivitiid ( activitiid ) ; string bucketname = null ; string key = null ; if ( s3propertieslocation != null ) { bucketname = s3propertieslocation . getbucketname ( ) ; key = s3propertieslocation . getkey ( ) ; } jobdefinitionentitylocal . sets3bucketname ( bucketname ) ; jobdefinitionentitylocal . sets3objectkey ( key ) ; list < jobdefinitionparameterentity > parameterentities = new arraylist < > ( ) ; if ( ! collectionutils . isempty ( parameters ) ) { for ( parameter parameter : parameters ) { jobdefinitionparameterentity parameterentity = new jobdefinitionparameterentity ( ) ; parameterentities . add ( parameterentity ) ; parameterentity . setname ( parameter . getname ( ) ) ; parameterentity . setvalue ( parameter . getvalue ( ) ) ; } } jobdefinitionentitylocal . setparameters ( parameterentities ) ; return jobdefinitionentitylocal ; }	creates a new job definition entity from the request information .
@ requestmapping ( value = { _str , _str } , method = requestmethod . put ) @ responsebody public restwrapper insert ( @ modelattribute ( _str ) @ valid users users , bindingresult bindingresult , principal principal ) { restwrapper restwrapper = null ; if ( bindingresult . haserrors ( ) ) { bindingresulterror bindingresulterror = new bindingresulterror ( ) ; return bindingresulterror . errormessage ( bindingresult ) ; } try { string hashedpassword = digestutils . sha1hex ( users . getpassword ( ) ) ; com . wipro . ats . bdre . md . dao . jpa . users jpausers = new com . wipro . ats . bdre . md . dao . jpa . users ( ) ; jpausers . setpassword ( hashedpassword ) ; jpausers . setusername ( users . getusername ( ) ) ; jpausers . setenabled ( ( users . getenabled ( ) == _num ) ? _bool : _bool ) ; usersdao . insert ( jpausers ) ; restwrapper = new restwrapper ( users , restwrapper . ok ) ; logger . info ( _str + users . getusername ( ) + _str + principal . getname ( ) + users ) ; } catch ( exception e ) { logger . error ( e ) ; restwrapper = new restwrapper ( e . getmessage ( ) , restwrapper . error ) ; } return restwrapper ; }	this method calls insertusers and adds a record passed in users table.
public static string cappedint ( final long val ) { if ( val >= integer . max_value ) { return over ; } else if ( val <= integer . min_value ) { return under ; } return long . tostring ( val ) ; }	return a long as a string but capped as a 32 - bit signed value.
private void createfromassets ( string mydbname , file dbfile , inputstream assetfileinputstream ) { outputstream out = null ; try { string dbpath = dbfile . getabsolutepath ( ) ; dbpath = dbpath . substring ( _num , dbpath . lastindexof ( _str ) + _num ) ; file dbpathfile = new file ( dbpath ) ; if ( ! dbpathfile . exists ( ) ) dbpathfile . mkdirs ( ) ; file newdbfile = new file ( dbpath + mydbname ) ; out = new fileoutputstream ( newdbfile ) ; byte [ ] buf = new byte [ _num ] ; int len ; while ( ( len = assetfileinputstream . read ( buf ) ) > _num ) out . write ( buf , _num , len ) ; log . v ( _str , _str + newdbfile . getabsolutepath ( ) ) ; } catch ( ioexception ex ) { log . v ( _str , _str + ex . getmessage ( ) ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( ioexception ignored ) { } } } }	if a prepopulated db file exists in the assets folder it is copied to the dbpath.
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return person_property ; case _num : return page_property ; case _num : return equiv ; case _num : return page_view ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
protected string internalput ( string key , string newvalue ) { synchronized ( childandpropertylock ) { string oldvalue = properties . get ( key ) ; if ( oldvalue != null && oldvalue . equals ( newvalue ) ) return oldvalue ; properties = properties . put ( key , newvalue ) ; return oldvalue ; } }	stores the given ( key , value ) pair , performing lazy initialization of the properties field if necessary.
public polyline ( plapointint p_from_corner , plapointint p_to_corner ) { if ( p_from_corner . equals ( p_to_corner ) ) throw new illegalargumentexception ( classname + _str ) ; lines_list = new arraylist < plalineint > ( _num ) ; pladirection dir = new pladirection ( p_from_corner , p_to_corner ) ; lines_list . add ( new plalineint ( p_from_corner , dir . rotate_45_deg ( _num ) ) ) ; lines_list . add ( new plalineint ( p_from_corner , p_to_corner ) ) ; lines_list . add ( new plalineint ( p_to_corner , dir . rotate_45_deg ( _num ) ) ) ; corners_allocate ( corner_count ( ) ) ; precalculated_corners [ _num ] = p_from_corner ; precalculated_corners [ _num ] = p_to_corner ; }	creates a polyline consisting of 3 lines.
protected boolean isonsamescreenaschildren ( ) { return _bool ; }	whether this preference group should be shown on the same screen as its contained preferences .
public static string formatprice ( double price ) { if ( price == null ) return _str ; return formatprice ( price . doublevalue ( ) ) ; }	formats a double representing a price into a string.
static void checklogdir ( ) { if ( system . getproperty ( _str ) == null ) { log . error ( _str ) ; } }	checks whether mandatory log dir is given.
private static boolean ismoreabove ( string src , int index ) { int ch ; int cc ; int len = src . length ( ) ; for ( int i = index + character . charcount ( src . codepointat ( index ) ) ; i < len ; i += character . charcount ( ch ) ) { ch = src . codepointat ( i ) ; cc = normalizer . getcombiningclass ( ch ) ; if ( cc == combining_class_above ) { return _bool ; } else if ( cc == _num ) { return _bool ; } } return _bool ; }	implements the " more_above " condition specification : c is followed by one or more characters of combining class 230 ( above ) in the combining character sequence . regular expression : after c : [ { cc ! = 0 } ] * [ { cc = = 230 } ].
public void restorekey ( string key ) { if ( ! key . equalsignorecase ( _str ) ) { string originalkey = key . substring ( keytestmode . length ( ) ) ; object value = get ( key ) ; put ( originalkey , value ) ; clear ( key ) ; } }	restore the original value for the key after it has been changed in test mode .
public static comparable [ ] sortcopy ( comparable [ ] objects ) { int len = objects . length ; comparable [ ] copy = new comparable [ len ] ; system . arraycopy ( objects , _num , copy , _num , len ) ; sort ( copy ) ; return copy ; }	sorts an array of comparable objects , returning a new array with the sorted items.
private utf8constant parseutf8constant ( int index ) throws ioexception { int length = readshort ( ) ; stringbuilder cb = new stringbuilder ( ) ; for ( int i = _num ; i < length ; i ++ ) { int ch = read ( ) ; if ( ch < _num ) { cb . append ( ( char ) ch ) ; } else if ( ( ch & _num ) == _num ) { int ch2 = read ( ) ; i ++ ; cb . append ( ( char ) ( ( ( ch & _num ) << _num ) + ( ch2 & _num ) ) ) ; } else { int ch2 = read ( ) ; int ch3 = read ( ) ; i += _num ; cb . append ( ( char ) ( ( ( ch & _num ) << _num ) + ( ( ch2 & _num ) << _num ) + ( ( ch3 & _num ) ) ) ) ; } } return new utf8constant ( _class . getconstantpool ( ) , index , cb . tostring ( ) ) ; }	parses a utf - 8 constant pool entry .
@ override public boolean marknextsequence ( ) throws ioexception { if ( mseqsize < mlimit && mpointersize + mpointerentrysize <= mlimit ) { mpointers . writebyte ( ( int ) mchecksumseq . getvalue ( ) ) ; mchecksumseq . reset ( ) ; if ( mchecksumqual != null ) { mpointers . writebyte ( ( int ) mchecksumqual . getvalue ( ) ) ; mchecksumqual . reset ( ) ; } mpointers . writeint ( ( int ) mseqsize ) ; mpointersize += mpointerentrysize ; return _bool ; } return _bool ; }	declares the beginning of a sequence .
public final double sampleactivecount ( ) { return _activecount . get ( ) ; }	sample the active count.
private void preprocessdata ( map < integer , map < integer , list < integer > > > knotenvonspurnachspurmapping , map < integer , map < integer , string > > knotenspurlinkmapping ) { preprocessknotenspurlinkmapping ( knotenspurlinkmapping ) ; cleanknotenvonspurnachspurmapping ( knotenvonspurnachspurmapping , knotenspurlinkmapping ) ; mergelanesonsamelink ( knotenvonspurnachspurmapping , knotenspurlinkmapping ) ; }	calls several preprocessing procedures , the order of the calls is important !.
@ override public boolean mutate ( testcase test , testfactory factory ) { if ( randomness . nextdouble ( ) >= properties . p_change_parameter ) return _bool ; if ( ! isstatic ( ) ) { variablereference source = getsource ( ) ; list < variablereference > objects = test . getobjects ( source . gettype ( ) , getposition ( ) ) ; objects . remove ( source ) ; if ( ! objects . isempty ( ) ) { setsource ( randomness . choice ( objects ) ) ; return _bool ; } } return _bool ; }	try to replace source of field with all possible choices.
public xpath ( string exprstring , sourcelocator locator , prefixresolver prefixresolver , int type ) throws javax . xml . transform . transformerexception { this ( exprstring , locator , prefixresolver , type , null ) ; }	construct an xpath object.
private void addmenuitem ( jpopupmenu menu , string title , mwfnode node , int ad_wf_nodeto_id ) { wfpopupitem item = new wfpopupitem ( title , node , ad_wf_nodeto_id ) ; menu . add ( item ) ; item . addactionlistener ( this ) ; }	add menu item to - add new line to node.
public synchronized long allocate ( int length ) { int blocks = getblockcount ( length ) ; blockrange x = null ; for ( blockrange b : freespace ) { if ( b . blocks >= blocks ) { x = b ; break ; } } long pos = getpos ( x . start ) ; if ( x . blocks == blocks ) { freespace . remove ( x ) ; } else { x . start += blocks ; x . blocks -= blocks ; } return pos ; }	allocate a number of blocks and mark them as used .
public jenkinshttpclient ( uri uri , string username , string password ) { this ( uri ) ; if ( isnotblank ( username ) ) { credentialsprovider provider = client . getcredentialsprovider ( ) ; authscope scope = new authscope ( uri . gethost ( ) , uri . getport ( ) , authscope . any_realm ) ; usernamepasswordcredentials credentials = new usernamepasswordcredentials ( username , password ) ; provider . setcredentials ( scope , credentials ) ; localcontext = new basichttpcontext ( ) ; localcontext . setattribute ( _str , new basicscheme ( ) ) ; client . addrequestinterceptor ( new preemptiveauth ( ) , _num ) ; } }	create an authenticated jenkins http client.
public static set combineocs ( set one , set two ) { if ( one == null || one . isempty ( ) ) { return two ; } if ( two == null || two . isempty ( ) ) { return one ; } set resultset = new hashset ( ) ; iterator itr1 = one . iterator ( ) ; while ( itr1 . hasnext ( ) ) { string value1 = ( string ) itr1 . next ( ) ; resultset . add ( value1 . tolowercase ( ) ) ; } iterator itr2 = two . iterator ( ) ; while ( itr2 . hasnext ( ) ) { string value2 = ( string ) itr2 . next ( ) ; resultset . add ( value2 . tolowercase ( ) ) ; } return resultset ; }	combines two sets which contains objectclass values of an entry in a case insensitive manner . oc values are sometimes returned by ldap in mixed case and when duplicate values for objectclass exists in a mixed case , there is a object class violation note : there is a possibility that this method will return null.
private string wrap ( string str ) { stringbuilder buf = new stringbuilder ( str ) ; int len = linelength ; while ( len < buf . length ( ) ) { int idx = buf . lastindexof ( _str , len ) ; if ( idx != - _num ) { buf . replace ( idx , idx + _num , breaker ) ; len = idx + breaker . length ( ) + linelength ; } else { buf . insert ( len , breaker ) ; len += breaker . length ( ) + linelength ; } } buf . insert ( _num , _str ) ; return buf . tostring ( ) ; }	line - wrap the passed string as an html string with break strings inserted .
public static double pdf ( double x , double shape , double scale ) { if ( x < _num ) return _num ; if ( x == _num ) { if ( shape == _num ) return _num / scale ; else return _num ; } if ( shape == _num ) return _num / x ; if ( shape == - _num ) { return math . sqrt ( x ) ; } final double xs = x / scale ; if ( shape == _num ) { return math . exp ( - xs ) / scale ; } final double a = math . exp ( ( shape - _num ) * math . log ( xs ) - xs - gammafunction . lngamma ( shape ) ) ; return a / scale ; }	probability density function of the gamma distribution.
public void flush ( ) { synchronized ( list ) { int n = _num ; long m = _num ; for ( t b : list ) { if ( halt ) throw new runtimeexception ( firstcause . get ( ) ) ; final int size = b . size ( ) ; final long counter = b . flush ( ) ; m += counter ; if ( debug ) log . debug ( _str + size + _str + counter ) ; } if ( info ) log . info ( _str + n + _str + m + _str ) ; } }	flush each of the unsynchronized buffers onto their backing synchronized buffer .
public void loginfo ( string message ) { logger . info ( logprefix + message ) ; }	logs an information message using the logger of this interpreter .
private boolean matchaddress ( final byte [ ] remotemask ) { if ( ruletype == ruletype . allwildcard ) { return _bool ; } if ( prefixmask == null ) { return _bool ; } if ( remotemask . length != prefixmask . length ) { return _bool ; } for ( int i = _num ; i < prefixmask . length ; i ++ ) { if ( ! wildcard . get ( i ) && ( rulemask [ i ] & prefixmask [ i ] ) != ( remotemask [ i ] & prefixmask [ i ] ) ) { return _bool ; } } return _bool ; }	try to match remote client address using prefix mask and rule mask .
public static string sign ( string signingstring , privatekey privatekey ) throws invalidkeyexception , signatureexception { byte [ ] bytes = signingstring . getbytes ( standardcharsets . utf_8 ) ; signature sig ; try { sig = signature . getinstance ( sha256_with_rsa ) ; } catch ( nosuchalgorithmexception e ) { throw new illegalargumentexception ( _str , e ) ; } sig . initsign ( privatekey ) ; sig . update ( bytes ) ; return hex . encodehexstring ( sig . sign ( ) ) ; }	signs a string using the private key and sha 256 with rsa signing algorithm , and returns it as a hex - encoded string .
public object invoke ( method method , object target , extensioncontext extensioncontext , extensionregistry extensionregistry ) { @ suppresswarnings ( _str ) optional < object > optionaltarget = ( target instanceof optional ? ( optional < object > ) target : optional . ofnullable ( target ) ) ; return reflectionutils . invokemethod ( method , target , resolveparameters ( method , optionaltarget , extensioncontext , extensionregistry ) ) ; }	invoke the supplied method on the supplied target object with dynamic parameter resolution .
registeredproject putproject ( projectconfig config , folderentry folder , boolean updated , boolean detected ) throws serverexception , conflictexception , notfoundexception { final registeredproject project = new registeredproject ( folder , config , updated , detected , this . projecttyperegistry ) ; projects . put ( project . getpath ( ) , project ) ; return project ; }	creates registeredproject and caches it .
@ override public void removelistener ( final izynoderealizerlistener < ? > listener ) { m_listeners . removelistener ( listener ) ; }	removes a listener object from the realizer .
protected void assertresultrowcount ( int expected , resultset rs ) throws sqlexception { int i = _num ; while ( rs . next ( ) ) { i ++ ; } assertequals ( expected , i ) ; }	check that the result set row count matches .
private boolean ismodeluseful ( contingencymatrix cm ) { for ( int row = _num ; row < cm . getnumberofpredictions ( ) ; row ++ ) { for ( int col = _num ; col < cm . getnumberofclasses ( ) ; col ++ ) { if ( math . abs ( cm . getlift ( row , col ) - _num ) > min_advantage ) { return _bool ; } } } return _bool ; }	helper method to decide whether a model improves the training error enough to be considered .
public void scan ( classnode cn ) { list < threatresult > threats = new arraylist < threatresult > ( ) ; for ( classhandler classhandler : classhandlers ) { threatresult result = classhandler . scanclass ( cn ) ; if ( result != null ) { threats . add ( result ) ; } } for ( methodnode mn : cn . methods ) { for ( methodhandler methodhandler : methodhandlers ) { threatresult result = methodhandler . scanmethod ( mn ) ; if ( result != null ) { threats . add ( result ) ; } } } if ( threats . size ( ) > _num ) { threatsbyclass . put ( cn . name , threats ) ; } }	scans a class node .
public void reset ( ) { mchannelnumber = _num ; mactivecalls . clear ( ) ; mesns . clear ( ) ; mneighborids . clear ( ) ; mreceivefrequencies . clear ( ) ; msiteids . clear ( ) ; mtalkgroups . clear ( ) ; mtransmitfrequencies . clear ( ) ; muniqueids . clear ( ) ; resetstate ( ) ; }	performs a full reset.
public static string newicknolengths ( tree tree ) { stringbuffer buffer = new stringbuffer ( ) ; newick ( tree , tree . getroot ( ) , _bool , branchlengthtype . no_branch_lengths , null , null , null , null , buffer ) ; buffer . append ( _str ) ; return buffer . tostring ( ) ; }	recursive function for constructing a newick tree representation in the given buffer .
@ override public string tostring ( ) { return ( string . valueof ( gettype ( ) ) + _str + getkey ( ) + _str + getvalue ( ) ) ; }	return string representation of event.
@ post @ path ( _str ) @ produces ( { mediatype . application_xml , mediatype . application_json } ) @ consumes ( { mediatype . application_xml , mediatype . application_json } ) @ checkpermission ( roles = { role . security_admin , role . restricted_security_admin } , blockproxies = _bool ) public string rotateipseckey ( ) { ipsecmgr . verifyipsecopallowable ( ) ; string version = ipsecmgr . rotatekey ( ) ; auditmgr . recordauditlog ( null , null , ipsec_service_type , operationtypeenum . update_system_property , system . currenttimemillis ( ) , auditlogmanager . auditlog_success , null , _str + version ) ; return version ; }	rotate the vipr ipsec pre - shared key .
public int append ( char chunk [ ] ) throws guacamoleexception { return append ( chunk , _num , chunk . length ) ; }	appends data from the given buffer to the current instruction .
public byte [ ] reset ( byte [ ] data ) { byte [ ] bytes = null ; if ( ( data [ _num ] & _num ) < _num ) { bytes = new byte [ data [ _num ] + _num ] ; system . arraycopy ( data , _num , bytes , _num , data [ _num ] + _num ) ; } else { if ( ( data [ _num ] & _num ) > _num ) { int len = data [ _num ] & ( byte ) _num ; int result = _num ; for ( int i = _num ; i < len ; i ++ ) { result |= ( data [ i + _num ] & _num ) << ( _num * ( len - i - _num ) ) ; } bytes = new byte [ result + len + _num ] ; system . arraycopy ( data , _num , bytes , _num , result + len + _num ) ; } } return bytes ; }	reset asn . 1 data stream after decryption , remove redundant bytes .
public vectorclock ( ) { this ( new arraylist < clockentry > ( _num ) , system . currenttimemillis ( ) ) ; }	construct an empty vectorclock.
public analyzer add ( string name , nondominatedpopulation result ) { list < nondominatedpopulation > list = data . get ( name ) ; if ( list == null ) { list = new arraylist < nondominatedpopulation > ( ) ; data . put ( name , list ) ; } list . add ( result ) ; return this ; }	adds a new sample with the specified name.
public static void assertequals ( string msg , double [ ] expected , double [ ] observed , double tolerance ) { stringbuilder out = new stringbuilder ( msg ) ; if ( expected . length != observed . length ) { out . append ( _str ) ; out . append ( _str ) ; out . append ( expected . length ) ; out . append ( _str ) ; out . append ( observed . length ) ; assert . fail ( out . tostring ( ) ) ; } boolean failure = _bool ; for ( int i = _num ; i < expected . length ; i ++ ) { if ( ! precision . equalsincludingnan ( expected [ i ] , observed [ i ] , tolerance ) ) { failure = _bool ; out . append ( _str ) ; out . append ( i ) ; out . append ( _str ) ; out . append ( _str ) ; out . append ( expected [ i ] ) ; out . append ( _str ) ; out . append ( observed [ i ] ) ; } } if ( failure ) { assert . fail ( out . tostring ( ) ) ; } }	verifies that two arrays are close ( sup norm ).
public void initializeatomsforfinite ( list < datum > data , string filename , random random ) { beta = new double [ k ] ; dof = new double [ k ] ; omega = new arraylist < > ( k ) ; if ( filename != null ) { try { loc = batchmixturemodel . initializeclustersfromfile ( filename , k ) ; if ( loc . size ( ) < k ) { loc = batchmixturemodel . gonzalezinitializemixturecenters ( loc , data , k , random ) ; } } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; loc = batchmixturemodel . gonzalezinitializemixturecenters ( data , k , random ) ; } } else { loc = batchmixturemodel . gonzalezinitializemixturecenters ( data , k , random ) ; } log . debug ( _str , loc ) ; for ( int k = _num ; k < this . k ; k ++ ) { beta [ k ] = basebeta ; dof [ k ] = basenu ; omega . add ( baseomega ) ; } }	initializes atom ( component ) distributions.
@ override public void oninit ( list < ? extends indexcommit > commits ) throws ioexception { if ( commits . isempty ( ) ) { return ; } log . info ( _str , new commitslogginginfo ( commits ) ) ; log . debug ( _str , new commitsloggingdebug ( commits ) ) ; updatecommits ( commits ) ; }	internal use for lucene.
public boolean isloading ( ) { return state . equals ( loading ) ; }	check if loading state is shown.
charsequence convert ( object value , string key ) ;	converts a given object to a json value .
@ override public final void sample ( ) { synchronized ( _lock ) { long count = _count . get ( ) ; long lastcount = _lastavgcount ; _lastavgcount = count ; long sum = _sum . get ( ) ; double lastsum = _lastavgsum ; _lastavgsum = sum ; if ( count == lastcount ) _value = _num ; else _value = _scale * ( sum - lastsum ) / ( double ) ( count - lastcount ) ; } }	return the probe ' s next average .
public boolean login ( ) throws loginexception { try { loadpasswordfile ( ) ; } catch ( ioexception ioe ) { loginexception le = new loginexception ( _str + passwordfiledisplayname ) ; throw envhelp . initcause ( le , ioe ) ; } if ( usercredentials == null ) { throw new loginexception ( _str ) ; } if ( logger . debugon ( ) ) { logger . debug ( _str , _str + passwordfiledisplayname ) ; } if ( tryfirstpass ) { try { attemptauthentication ( _bool ) ; succeeded = _bool ; if ( logger . debugon ( ) ) { logger . debug ( _str , _str ) ; } return _bool ; } catch ( loginexception le ) { cleanstate ( ) ; logger . debug ( _str , _str ) ; } } else if ( usefirstpass ) { try { attemptauthentication ( _bool ) ; succeeded = _bool ; if ( logger . debugon ( ) ) { logger . debug ( _str , _str ) ; } return _bool ; } catch ( loginexception le ) { cleanstate ( ) ; logger . debug ( _str , _str ) ; throw le ; } } if ( logger . debugon ( ) ) { logger . debug ( _str , _str ) ; } try { attemptauthentication ( _bool ) ; succeeded = _bool ; if ( logger . debugon ( ) ) { logger . debug ( _str , _str ) ; } return _bool ; } catch ( loginexception le ) { cleanstate ( ) ; logger . debug ( _str , _str ) ; throw le ; } }	begin user authentication ( authentication phase 1 ).
public builder updateextension ( extension extension ) { extensions . add ( extension ) ; return this ; }	updates the given fields in the extension.
public void processutterance ( utterance utterance ) throws processexception { if ( utterance . getrelation ( relation . segment ) == null ) { throw new illegalstateexception ( _str ) ; } utterance . setobject ( sampleinfo . utt_name , diphonedatabase . getsampleinfo ( ) ) ; createunitrelation ( utterance ) ; }	generates the unit relation from the segment relation .
public static int copy ( inputstream in , outputstream out ) throws ioexception { assert . notnull ( in , _str ) ; assert . notnull ( out , _str ) ; try { return streamutils . copy ( in , out ) ; } finally { try { in . close ( ) ; } catch ( ioexception ex ) { } try { out . close ( ) ; } catch ( ioexception ex ) { } } }	copy the contents of the given inputstream to the given outputstream.
private string converttoattributename ( string localname ) { return localname . replace ( _str , _str ) ; }	converts an xml element local name ( with underscores ) to an attribute name ( with spaces ) .
public expandedstatementbuilder reference ( string property , object value ) { checkcanchange ( ) ; extrainfo . add ( new referenceinfo ( property , value ) ) ; return this ; }	add a reference to this statement .
@ targetapi ( build . version_codes . honeycomb ) protected void swipeview ( view child , float deltax , float deltay ) { if ( isfixedview ( child ) ) { deltax = deltax / _num ; } float deltaxabs = math . abs ( deltax ) ; float fractioncovered = deltaxabs / ( float ) child . getwidth ( ) ; child . settranslationx ( deltax ) ; child . setalpha ( _num - fractioncovered ) ; if ( deltax > _num ) child . setrotationy ( - _num * fractioncovered ) ; else child . setrotationy ( _num * fractioncovered ) ; }	swipe a view by moving distance.
private void verifyisroot ( ) { if ( hierarchyelements . size ( ) != _num ) { throw new illegalstateexception ( _str + _str + hierarchy ) ; } }	verify that this node is the root.
@ override public int size ( ) { final reentrantlock lock = this . lock ; lock . lock ( ) ; try { return count ; } finally { lock . unlock ( ) ; } }	returns the number of elements in this deque .
private void verifywithseparatesigningkey ( x509certificate cert , publickey prevkey , boolean signflag , set < x509certificate > stackedcerts ) throws certpathvalidatorexception { string msg = _str ; if ( debug != null ) { debug . println ( _str + _str + msg + _str ) ; } if ( ( stackedcerts != null ) && stackedcerts . contains ( cert ) ) { if ( debug != null ) { debug . println ( _str + _str ) ; } throw new certpathvalidatorexception ( _str , null , null , - _num , basicreason . undetermined_revocation_status ) ; } if ( ! signflag ) { buildtonewkey ( cert , null , stackedcerts ) ; } else { buildtonewkey ( cert , prevkey , stackedcerts ) ; } }	we have a cert whose revocation status couldn ' t be verified by a crl issued by the cert that issued the crl.
private boolean mappatternelempos ( int nesting , boolean isstart , boolean isattrname ) { if ( _num == nesting ) { if ( m_patternmapsize >= m_patternmap . length ) { int patternmap [ ] = m_patternmap ; int len = m_patternmap . length ; m_patternmap = new int [ m_patternmapsize + _num ] ; system . arraycopy ( patternmap , _num , m_patternmap , _num , len ) ; } if ( ! isstart ) { m_patternmap [ m_patternmapsize - _num ] -= targetextra ; } m_patternmap [ m_patternmapsize ] = ( m_compiler . gettokenqueuesize ( ) - ( isattrname ? _num : _num ) ) + targetextra ; m_patternmapsize ++ ; isstart = _bool ; } return isstart ; }	record the current position on the token queue as long as this is a top - level element.
public boolean addoperationatfirst ( operation operation ) { if ( isrunning ) { if ( operationhandlerthreadhandler == null ) return _bool ; return operationhandlerthreadhandler . postatfrontofqueue ( new androidoperation ( this , operation ) ) ; } else { return operationqueue . add ( new androidoperation ( this , operation , androidoperation . type . atfirst , null , _num ) ) ; } }	add operation to operationqueue.
public void testshiftleft1 ( ) { byte abytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = _num ; int number = _num ; byte rbytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . shiftleft ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	shiftleft ( int n ) , n = 0.
public static string tounitbytes ( long bytes ) { if ( bytes < _num ) { return _str + general_unit_kilobytes ; } long unitvalue ; string unitname ; if ( bytes < _num ) { unitvalue = _num ; unitname = general_unit_kilobytes ; } else if ( bytes < _num ) { unitvalue = _num ; unitname = general_unit_megabytes ; } else if ( bytes < _num ) { unitvalue = _num ; unitname = general_unit_gigabytes ; } else { unitvalue = _num ; unitname = general_unit_terabytes ; } numberformat numberformat ; if ( ( double ) bytes * _num / unitvalue < _num ) numberformat = number_format1 ; else numberformat = number_format0 ; try { return numberformat . format ( ( double ) bytes / unitvalue ) + _str + unitname ; } catch ( arithmeticexception ae ) { return _str + unitname ; } }	converts the passed in number of bytes into a byte - size string.
@ override public enumeration < option > listoptions ( ) { vector < option > result = new vector < option > ( ) ; result . addelement ( new option ( _str + _str + _str + _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str + _str + _str + _str , _str , _num , _str ) ) ; result . addall ( collections . list ( super . listoptions ( ) ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
public static string changepassword ( connection conn , string username , string password ) throws exception { preparedstatement prep = conn . preparestatement ( _str ) ; prep . setstring ( _num , password ) ; prep . setstring ( _num , username ) ; prep . executeupdate ( ) ; return password ; }	utility method to change a password of a user.
public object remove ( object key ) { processqueue ( ) ; return map . remove ( key . create ( key , null ) ) ; }	removes association for given key , returning value previously associated with key , or null if none .
protected rectangle computepopupbounds ( int px , int py , int pw , int ph ) { toolkit toolkit = toolkit . getdefaulttoolkit ( ) ; rectangle screenbounds ; graphicsconfiguration gc = combobox . getgraphicsconfiguration ( ) ; point p = new point ( ) ; swingutilities . convertpointfromscreen ( p , combobox ) ; if ( gc != null ) { insets screeninsets = toolkit . getscreeninsets ( gc ) ; screenbounds = gc . getbounds ( ) ; screenbounds . width -= ( screeninsets . left + screeninsets . right ) ; screenbounds . height -= ( screeninsets . top + screeninsets . bottom ) ; screenbounds . x += ( p . x + screeninsets . left ) ; screenbounds . y += ( p . y + screeninsets . top ) ; } else { screenbounds = new rectangle ( p , toolkit . getscreensize ( ) ) ; } rectangle rect = new rectangle ( px , py , pw , ph ) ; if ( py + ph > screenbounds . y + screenbounds . height && ph < screenbounds . height ) { rect . y = - rect . height ; } return rect ; }	calculate the placement and size of the popup portion of the combo box based on the combo box location and the enclosing screen bounds.
public static intent buildbackgroundshortcutintent ( file script , parcelable iconresource ) { intent intent = new intent ( ) ; intent . putextra ( intent . extra_shortcut_intent , buildstartinbackgroundintent ( script ) ) ; intent . putextra ( intent . extra_shortcut_name , script . getname ( ) ) ; intent . putextra ( intent . extra_shortcut_icon_resource , iconresource ) ; return intent ; }	builds an intent that creates a shortcut to launch the provided script in the background .
public static boolean isshown ( final actor actor ) { return actor != null && actor . getstage ( ) != null ; }	null - safe check if the actor has a stage.
public static void addlistener ( final diagnosticlistener listener ) { if ( listener != null ) { listeners . add ( listener ) ; } }	add the given listener to the those notified whenever a diagnostic occurs.
public void shuffletrainingset ( ) { utils . shufflelist ( trainingfiles ) ; }	shuffles ( randomizes the order of ) the files appearing in the training set .
public ntlmauthentication ( boolean isproxy , url url , passwordauthentication pw ) { super ( isproxy ? proxy_authentication : server_authentication , authscheme . ntlm , url , _str ) ; init ( pw ) ; }	create a ntlmauthentication : username may be specified as domain < backslash > username in the application authenticator.
public messagechannel createmessagechannel ( siprequest request , messageprocessor mp , hop nexthop ) throws ioexception { host targethost = new host ( ) ; targethost . sethostname ( nexthop . gethost ( ) ) ; hostport targethostport = new hostport ( ) ; targethostport . sethost ( targethost ) ; targethostport . setport ( nexthop . getport ( ) ) ; messagechannel returnchannel = mp . createmessagechannel ( targethostport ) ; return returnchannel ; }	creates a client transaction to handle a new request.
public static byte [ ] generatemac ( byte [ ] byteciphertext , secretkey integritykey ) throws nosuchalgorithmexception , invalidkeyexception { mac sha256_hmac = mac . getinstance ( hmac_algorithm ) ; sha256_hmac . init ( integritykey ) ; return sha256_hmac . dofinal ( byteciphertext ) ; }	generate the mac based on hmac_algorithm.
public void populateedittext ( string query ) { string text = query . trim ( ) ; setsearchstring ( text , _bool ) ; dispatchstatechange ( searchviewstate . search ) ; }	populate the persistentsearchview with search query.
public static byte [ ] concat ( byte [ ] b1 , byte [ ] b2 ) { byte [ ] out = new byte [ b1 . length + b2 . length ] ; system . arraycopy ( b1 , _num , out , _num , b1 . length ) ; system . arraycopy ( b2 , _num , out , b1 . length , b2 . length ) ; return out ; }	concatenates and returns the given byte arrays .
public static void putfloat ( string property , float val ) { simbrain_preferences . putfloat ( property , val ) ; }	set a property whose value is a float .
public int hashcode ( ) { return arrays . hashcode ( this . uid ) ; }	a method to generate hash code for this mxf uid.
private void advancerunstate ( int targetstate ) { for ( ; ; ) { int c = ctl . get ( ) ; if ( runstateatleast ( c , targetstate ) || ctl . compareandset ( c , ctlof ( targetstate , workercountof ( c ) ) ) ) break ; } }	transitions runstate to given target , or leaves it alone if already at least the given target .
public static final double [ ] copy ( final double [ ] v ) { return arrays . copyof ( v , v . length ) ; }	returns a copy of this vector .
public void addaction ( string action ) { object [ ] args = new string [ _num ] ; simpledateformat sdf = new simpledateformat ( context . getstring ( r . string . dateformat ) ) ; args [ _num ] = sdf . format ( new date ( ) ) ; string timestamp = context . getstring ( r . string . timestamp , args ) ; history . add ( action + timestamp ) ; notifylisteners ( new propertychangeevent ( this , activityconstants . historyproperty , null , null ) ) ; }	add an action to the history of the client.
private filteroperationcodes ( ) { }	don ' t let anyone instantiate this class .
@ override public string tostring ( ) { stringbuffer text = new stringbuffer ( ) ; if ( m_traininstances == null ) { text . append ( _str ) ; } else { text . append ( _str ) ; if ( ! m_missing_merge ) { text . append ( _str ) ; } } text . append ( _str ) ; return text . tostring ( ) ; }	return a description of the evaluator.
public charsequence subsequence ( int start , int end ) { return substring ( start , end ) ; }	has the same result as the substring function , but is present so that string may implement the charsequence interface .
private creationtemplate tocreationtemplate ( attrset t ) { attr nameattr = t . getattribute ( template_name ) ; string name = null ; if ( nameattr != null ) { name = nameattr . getvalue ( ) ; } attr namingattr = t . getattribute ( template_namingattribute ) ; string namingattribute = null ; if ( namingattr != null ) { namingattribute = namingattr . getvalue ( ) ; } attr classattr = t . getattribute ( template_javaclass ) ; string [ ] classnames = null ; if ( classattr != null ) { classnames = classattr . getstringvalues ( ) ; } attrset required = decodeattr ( t . getattribute ( template_required ) , _str ) ; attrset optional = decodeattr ( t . getattribute ( template_optional ) , _str ) ; attrset validated = decodeattr ( t . getattribute ( template_validated ) , _str ) ; creationtemplate template = new creationtemplate ( ) ; arraylist classes = new arraylist ( ) ; try { if ( classnames != null ) { for ( int i = _num ; i < classnames . length ; i ++ ) { class cls = class . forname ( classnames [ i ] ) ; classes . add ( cls ) ; } } template = new creationtemplate ( name , required , optional , classes ) ; } catch ( classnotfoundexception e ) { template = new creationtemplate ( name , required , optional ) ; } if ( validated != null ) { template . setvalidation ( validated ) ; } if ( namingattribute != null ) { template . setnamingattribute ( namingattribute ) ; } return template ; }	reads in a attribute set and converts name - value pairs to a creationtemplate object .
public void placeitem ( itemstack stack , blockpos pos , world world , boolean centreitem ) { double offset = ( centreitem ) ? _num : _num ; entityitem entityitem = new entityitem ( world , ( double ) pos . getx ( ) + offset , ( double ) pos . gety ( ) + offset , ( double ) pos . getz ( ) + offset , stack ) ; entityitem . motionx = _num ; entityitem . motiony = _num ; entityitem . motionz = _num ; entityitem . setdefaultpickupdelay ( ) ; world . spawnentityinworld ( entityitem ) ; }	spawn a single item at the specified position .
private < m extends configurationclient , p > managedobject < m > createnewmanagedobject ( managedobjectdefinition < m , ? > d , managedobjectpath < m , ? > p , propertydefinition < p > namingpropertydefinition , string name , collection < propertyexception > exceptions ) { propertyset childproperties = new propertyset ( ) ; for ( propertydefinition < ? > pd : d . getallpropertydefinitions ( ) ) { try { createproperty ( childproperties , p , pd ) ; } catch ( propertyexception e ) { if ( exceptions != null ) { exceptions . add ( e ) ; } } } if ( namingpropertydefinition != null ) { p value = namingpropertydefinition . decodevalue ( name ) ; childproperties . setpropertyvalues ( namingpropertydefinition , collections . singleton ( value ) ) ; } return newinstance ( d , p , childproperties , _bool , namingpropertydefinition ) ; }	creates a new managed object with no active values , just default values .
public abstract void initializeconstraints ( step step , settings settings ) ;	performs any initialization of the velocity and position constraints .
public void testemptycommits ( ) throws exception { clearindexwithreplication ( ) ; index ( masterclient , _str , _str , _str , _str ) ; emptyupdate ( masterclient , _str , _str ) ; pullfrommastertoslave ( ) ; rquery ( _num , _str , slaveclient ) ; assertversions ( masterclient , slaveclient ) ; emptyupdate ( masterclient , _str , _str ) ; pullfrommastertoslave ( ) ; index ( masterclient , _str , _str , _str , _str ) ; emptyupdate ( masterclient , _str , _str ) ; pullfrommastertoslave ( ) ; rquery ( _num , _str , slaveclient ) ; assertversions ( masterclient , slaveclient ) ; index ( masterclient , _str , _str , _str , _str ) ; emptyupdate ( masterclient , _str , _str , _str , _str ) ; pullfrommastertoslave ( ) ; rquery ( _num , _str , masterclient ) ; rquery ( _num , _str , slaveclient ) ; index ( masterclient , _str , _str , _str , _str ) ; emptyupdate ( masterclient , _str , _str ) ; pullfrommastertoslave ( ) ; string q = _str ; rquery ( _num , q , masterclient ) ; rquery ( _num , q , slaveclient ) ; assertversions ( masterclient , slaveclient ) ; }	verify that empty commits and / or commits with opensearcher = false on the master do not cause subsequent replication problems on the slave.
private byte [ ] decrypt ( byte [ ] d , int start , int end , int key , int skip ) { if ( end - start - skip < _num ) { skip = _num ; } byte [ ] o = new byte [ end - start - skip ] ; int r = key ; int ipos ; int c1 = _num ; int c2 = _num ; for ( ipos = start ; ipos < end ; ipos ++ ) { int c = d [ ipos ] & _num ; int p = ( c ^ ( r > > _num ) ) & _num ; r = ( ( c + r ) * c1 + c2 ) & _num ; if ( ipos - start - skip >= _num ) { o [ ipos - start - skip ] = ( byte ) p ; } } return o ; }	decrypt an array using the adobe type 1 font decryption algorithm .
@ override public final void insertall ( dbids ids ) { if ( ids . isempty ( ) || ( ids . size ( ) == _num ) ) { return ; } if ( canbulkload ( ) ) { list < rdknnentry > leafs = new arraylist < > ( ids . size ( ) ) ; for ( dbiditer iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { leafs . add ( createnewleafentry ( dbidutil . deref ( iter ) ) ) ; } bulkload ( leafs ) ; } else { for ( dbiditer iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { insert ( iter ) ; } } doextraintegritychecks ( ) ; }	inserts the specified objects into this index.
public void testcase14 ( ) { byte rbytes [ ] = { _num } ; biginteger anumber = biginteger . one ; biginteger bnumber = biginteger . one ; biginteger result = anumber . divide ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	divide one by one .
public static boolean issupplemental ( int c ) { return ( c >= _num && c <= _num ) ; }	returns true if the specified character is a supplemental character .
private final string _decodeshortunicodename ( int len ) throws ioexception { int outptr = _num ; char [ ] outbuf = _textbuffer . emptyandgetcurrentsegment ( ) ; int inptr = _inputptr ; _inputptr += len ; final int [ ] codes = smileconstants . sutf8unitlengths ; final byte [ ] inbuf = _inputbuffer ; for ( int end = inptr + len ; inptr < end ; ) { int i = inbuf [ inptr ++ ] & _num ; int code = codes [ i ] ; if ( code != _num ) { switch ( code ) { case _num : i = ( ( i & _num ) << _num ) | ( inbuf [ inptr ++ ] & _num ) ; break ; case _num : i = ( ( i & _num ) << _num ) | ( ( inbuf [ inptr ++ ] & _num ) << _num ) | ( inbuf [ inptr ++ ] & _num ) ; break ; case _num : i = ( ( i & _num ) << _num ) | ( ( inbuf [ inptr ++ ] & _num ) << _num ) | ( ( inbuf [ inptr ++ ] & _num ) << _num ) | ( inbuf [ inptr ++ ] & _num ) ; i -= _num ; outbuf [ outptr ++ ] = ( char ) ( _num | ( i > > _num ) ) ; i = _num | ( i & _num ) ; break ; default : _reporterror ( _str + integer . tohexstring ( i ) + _str ) ; } } outbuf [ outptr ++ ] = ( char ) i ; } return _textbuffer . setcurrentandreturn ( outptr ) ; }	helper method used to decode short unicode string , length for which actual length ( in bytes ) is known.
public void savedeviceprofile ( @ nonnull string user , @ nonnull string realm , @ nonnull pushdevicesettings devicesettings ) throws authloginexception { reject . ifnull ( user , realm , devicesettings ) ; try { devicesdao . savedeviceprofiles ( user , realm , jsonutils . tojsonvalues ( collections . singletonlist ( devicesettings ) ) ) ; } catch ( ioexception e ) { debug . error ( _str , user , realm , e ) ; throw new authloginexception ( e ) ; } }	saves the push device settings to the user ' s profile , overwriting any existing device profile .
public rankingimagelistprovider indays ( int days ) { mtime = integer . tostring ( days ) + _str ; return this ; }	sets time limit for a ranking list in days ( the default value is all time ) .
public void removeupdatelistener ( animatorupdatelistener listener ) { if ( mupdatelisteners == null ) { return ; } mupdatelisteners . remove ( listener ) ; if ( mupdatelisteners . size ( ) == _num ) { mupdatelisteners = null ; } }	removes a listener from the set listening to frame updates for this animation .
public final void dbunavailable ( final boolean alarmup , final string exceptionmsg , final string dbinfo ) { if ( alarmup == fallbackalarmsinterface . activated ) { arraylist recipients = new arraylist ( ) ; maildetailsbean maildetails = new maildetailsbean ( ) ; maildetails . setsender ( _str ) ; recipients . add ( _str ) ; maildetails . settorecipients ( recipients ) ; maildetails . setsubject ( _str ) ; maildetails . setmessage ( _str + dbinfo + _str + exceptionmsg ) ; maildetails . setserver ( _str ) ; smtpmailsender mailsender = new smtpmailsender ( ) ; try { mailsender . sendmail ( maildetails ) ; } catch ( mailsenderexception e ) { log . debug ( e . getmessage ( ) ) ; } } }	sends an email warning about the db problems.
public static string tidystring ( string string ) { if ( string . matches ( _str ) ) { return string ; } else { return string . replaceall ( _str , _str ) ; } }	removed punctuation from the begging or end of input if it does not appear to be a sentence ending with a period .
public select < t > sortdesc ( string ... columns ) { for ( string column : columns ) { msortingorderlist . add ( column + _str ) ; } return this ; }	sorts the specified columns in desc order.
public void testulpneg ( ) { string a = _str ; int ascale = _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal result = anumber . ulp ( ) ; string res = _str ; int resscale = _num ; assertequals ( _str , res , result . tostring ( ) ) ; assertequals ( _str , resscale , result . scale ( ) ) ; }	ulp ( ) of a negative bigdecimal.
public logrecord ( level level , string msg ) { level . getclass ( ) ; this . level = level ; message = msg ; sequencenumber = globalsequencenumber . getandincrement ( ) ; threadid = defaultthreadid ( ) ; millis = system . currenttimemillis ( ) ; needtoinfercaller = _bool ; }	construct a logrecord with the given level and message values.
public matrix correlation ( ) { final matrix corr = covariance ( ) ; final array v = corr . diagonal ( ) ; for ( int i = _num ; i < dimension_ ; i ++ ) { for ( int j = _num ; j < dimension_ ; j ++ ) { if ( i == j ) { if ( v . [ v . _ ( i ) ] == _num ) { corr . [ corr . _ ( i , j ) ] = _num ; } else { corr . [ corr . _ ( i , j ) ] *= _num / math . sqrt ( v . [ v . _ ( i ) ] * v . [ v . _ ( j ) ] ) ; } } else { if ( v . [ v . _ ( i ) ] == _num && v . [ v . _ ( j ) ] == _num ) { corr . [ corr . _ ( i , j ) ] = _num ; } else if ( v . [ v . _ ( i ) ] == _num || v . [ v . _ ( j ) ] == _num ) { corr . [ corr . _ ( i , j ) ] = _num ; } else { corr . [ corr . _ ( i , j ) ] *= _num / math . sqrt ( v . [ v . _ ( i ) ] * v . [ v . _ ( j ) ] ) ; } } } } return corr ; }	returns the correlation matrix.
@ notnull public static savedirectory from ( file file ) throws filenotfoundexception { file currentfile = file ; savedirectory result = null ; if ( currentfile == null ) { } else { result = createvalidsavedirectory ( currentfile ) ; currentfile = currentfile . getparentfile ( ) ; if ( result != null ) { return result ; } else if ( currentfile == null ) { } else { result = createvalidsavedirectory ( currentfile ) ; currentfile = currentfile . getparentfile ( ) ; if ( result != null ) { return result ; } else { } } } throw new filenotfoundexception ( _str + file ) ; }	returns a new valid instance of the class savedirectory.
public serializer serializer ( ) { return serializer ; }	returns the metastore serializer .
private void addincludedresources ( jsonapidocument jsonapidocument , persistentresource rec , list < string > requestedrelationpaths ) { requestedrelationpaths . foreach ( null ) ; }	adds the requested relation resources to the included block of the jsonapidocument .
private void shiftsegments ( int fromidx , int offset ) { for ( element element : elements ) { if ( element . end . left > fromidx ) { shiftsegment ( element . start , fromidx , offset ) ; shiftsegment ( element . end , fromidx , offset ) ; if ( element . text != null ) { for ( segment textsegment : element . text ) { shiftsegment ( textsegment , fromidx , offset ) ; } } } } }	iterates all existed elements and shifts their segments if needed.
public refupdate . result modifyfile ( changeedit edit , string file , rawinput content ) throws authexception , invalidchangeoperationexception , ioexception { return modify ( treeoperation . change_entry , edit , file , null , content ) ; }	modify file in existing change edit from its base commit .
private void startdocument ( final boolean multiobjectmode ) throws saxexception { if ( depth == _num ) { contenthandler . startdocument ( ) ; if ( multiobjectmode ) { depth ++ ; } } }	fires the sax startdocument event towards the configured contenthandler .
public void flush ( ) throws ioexception { writer . flush ( ) ; }	flushes the xmlwriter and the underlying output writer .
private static arraylist < gridcollisionjobcontextwrapper > slice ( collection < collisionjobcontext > src , int num ) { arraylist < gridcollisionjobcontextwrapper > slice = new arraylist < > ( ) ; iterator < collisionjobcontext > iter = src . iterator ( ) ; for ( int i = _num ; i < num && iter . hasnext ( ) ; i ++ ) slice . add ( new gridcollisionjobcontextwrapper ( iter . next ( ) , i ) ) ; return slice ; }	takes first n element from contexts list , wrap them and put it into a new list .
protected void calculateformatter ( float min , float max ) { float reference = _num ; if ( mdata == null || mdata . getxvalcount ( ) < _num ) { reference = math . max ( math . abs ( min ) , math . abs ( max ) ) ; } else { reference = math . abs ( max - min ) ; } int digits = utils . getdecimals ( reference ) ; mdefaultformatter = new defaultvalueformatter ( digits ) ; }	calculates the required number of digits for the values that might be drawn in the chart ( if enabled ) , and creates the default - value - formatter.
public request add ( request request ) { request . setrequestqueue ( this ) ; synchronized ( mcurrentrequests ) { mcurrentrequests . add ( request ) ; } request . setsequence ( getsequencenumber ( ) ) ; request . addmarker ( _str ) ; if ( ! request . shouldcache ( ) ) { mnetworkqueue . add ( request ) ; return request ; } synchronized ( mwaitingrequests ) { string cachekey = request . getcachekey ( ) ; if ( mwaitingrequests . containskey ( cachekey ) ) { queue < request > stagedrequests = mwaitingrequests . get ( cachekey ) ; if ( stagedrequests == null ) { stagedrequests = new linkedlist < request > ( ) ; } stagedrequests . add ( request ) ; mwaitingrequests . put ( cachekey , stagedrequests ) ; if ( volleylog . debug ) { volleylog . v ( _str , cachekey ) ; } } else { mwaitingrequests . put ( cachekey , null ) ; mcachequeue . add ( request ) ; } return request ; } }	adds a request to the dispatch queue .
public string lookup ( string data ) { iterator < string > it = map . getprefixedby ( data ) ; if ( ! it . hasnext ( ) ) return null ; return it . next ( ) ; }	return the last string in the set that can be prefixed by this string ( trie ' s are stored in alphabetical order ).
public static object loadmodule ( string homedir , scriptengine engine , string name ) throws filenotfoundexception , scriptexception { hashmap < string , file > mp = ( hashmap < string , file > ) engine . get ( _str ) ; object ret = load ( mp . get ( name ) , engine ) ; return ret ; }	load a module into the javascript engine.
@ override public void modifyvariableid ( string nodeid , string newid ) { map < assignment , utilityestimate > utilities2 = new hashmap < assignment , utilityestimate > ( ) ; for ( assignment a : table . keyset ( ) ) { assignment b = new assignment ( ) ; for ( string var : a . getvariables ( ) ) { string newvar = ( var . equals ( nodeid ) ) ? newid : var ; b . addpair ( newvar , a . getvalue ( var ) ) ; } utilities2 . put ( b , table . get ( a ) ) ; } table = utilities2 ; }	modifies a variable label with a new one.
public static long [ ] truncatei ( long [ ] v , int len ) { final int zap = ( v . length * long . size ) - len ; final int zapwords = ( zap > > > long_log2_size ) ; final int zapbits = zap & long_log2_mask ; arrays . fill ( v , v . length - zapwords , v . length , _num ) ; if ( zapbits > _num ) { v [ v . length - zapwords - _num ] &= ( long_all_bits > > > zapbits ) ; } return v ; }	truncate a bit string to the given length ( setting any higher bit to 0 ) .
public void test_noresourcesdoesnotwait_predeclarelocks_synchronousqueue ( ) throws exception { final properties properties = new properties ( ) ; final int ntasks = _num ; final int corepoolsize = _num ; final int maxpoolsize = ntasks ; properties . setproperty ( testoptions . synchronous_queue , _str ) ; properties . setproperty ( testoptions . core_pool_size , _str + corepoolsize ) ; properties . setproperty ( testoptions . max_pool_size , _str + maxpoolsize ) ; properties . setproperty ( testoptions . ntasks , _str + ntasks ) ; properties . setproperty ( testoptions . nresources , _str ) ; properties . setproperty ( testoptions . min_locks , _str ) ; properties . setproperty ( testoptions . max_locks , _str ) ; properties . setproperty ( testoptions . predeclare_locks , _str ) ; properties . setproperty ( testoptions . sort_lock_requests , _str ) ; final result result = docomparisontest ( properties ) ; assertequals ( _str , ntasks , integer . parseint ( result . get ( _str ) ) ) ; final int maxrunning = integer . parseint ( result . get ( _str ) ) ; asserttrue ( _str + maxrunning , corepoolsize <= maxrunning ) ; }	test where no locks are declared.
private void positionatcentraldirectory ( ) throws ioexception { boolean found = _bool ; long off = archive . length ( ) - min_eocd_size ; if ( off >= _num ) { archive . seek ( off ) ; byte [ ] sig = jbzipoutputstream . eocd_sig ; int curr = archive . read ( ) ; while ( curr != - _num ) { if ( curr == sig [ pos_0 ] ) { curr = archive . read ( ) ; if ( curr == sig [ pos_1 ] ) { curr = archive . read ( ) ; if ( curr == sig [ pos_2 ] ) { curr = archive . read ( ) ; if ( curr == sig [ pos_3 ] ) { found = _bool ; break ; } } } } archive . seek ( -- off ) ; curr = archive . read ( ) ; } } if ( ! found ) { throw new zipexception ( _str ) ; } archive . seek ( off + cfd_locator_offset ) ; byte [ ] cfdoffset = new byte [ word ] ; archive . readfully ( cfdoffset ) ; currentcfdfoffset = ziplong . getvalue ( cfdoffset ) ; archive . seek ( currentcfdfoffset ) ; }	searches for the & quot ; end of central dir record & quot ; , parses it and positions the stream at the first central directory record .
public list query ( double x1 , double x2 ) { return super . query ( new interval ( math . min ( x1 , x2 ) , math . max ( x1 , x2 ) ) ) ; }	returns items whose bounds intersect the given bounds .
public static boolean isnull ( object object ) { return object != null && object == null_cache . get ( object . getclass ( ) ) ; }	returns whether the given object is the magic object that represents the null value of its class .
public static void createdestinationfolder ( string path ) { file fpath = new file ( path ) ; fpath . mkdirs ( ) ; }	creates a folder with a given path , including all necessary nonexistent parent directories.
public void removeall ( ) { log . debug ( _str + connectiontoadded . size ( ) ) ; connectiontoadded . clear ( ) ; }	removes all connections referenced by this handler .
public float readfloat ( ) throws ioexception { return primitivetypes . readfloat ( ) ; }	reads a float ( 32 bit ) from the source stream .
public synchronized static int insertluastate ( luastate l ) { int i ; for ( i = _num ; i < states . size ( ) ; i ++ ) { luastate state = ( luastate ) states . get ( i ) ; if ( state != null ) { if ( state . getcptrpeer ( ) == l . getcptrpeer ( ) ) return i ; } } i = getnextstateindex ( ) ; states . set ( i , l ) ; return i ; }	receives a existing luastate and checks if it exists in the states list.
public phonenumbervalidator ( @ nonnull final charsequence errormessage ) { super ( errormessage , regex ) ; }	creates a new validator , which allows to validate texts to ensure , that they represent valid phone numbers .
@ override public int hashcode ( ) { return fullyqualifiedname . hashcode ( ) ; }	uses fullyqualifiedname to create a hashcode .
public point2d convertwindowtoreference ( point2d apt ) { if ( scrollbackreferencerect == null ) return null ; else return new point2d . double ( ( apt . getx ( ) - scrollbackreferencerect . getx ( ) ) / scrollbackreferencerect . getwidth ( ) , ( apt . gety ( ) - scrollbackreferencerect . gety ( ) ) / scrollbackreferencerect . getheight ( ) ) ; }	converts a point from window coordinates to reference coordinates.
public void clear ( ) { final reentrantlock lock = this . lock ; lock . lock ( ) ; try { for ( tenantqueue q : qs . values ( ) ) { q . clear ( ) ; } } finally { lock . unlock ( ) ; } }	atomically removes all of the elements from this delay queue.
public void printusage ( printwriter pw , int width , string cmdlinesyntax ) { int argpos = cmdlinesyntax . indexof ( _str ) + _num ; printwrapped ( pw , width , defaultsyntaxprefix . length ( ) + argpos , defaultsyntaxprefix + cmdlinesyntax ) ; }	print the cmdlinesyntax to the specified writer , using the specified width .
private void addnewline ( ) { if ( addlinedialog == null ) { addlinedialog = new addparallellinedialog ( ) ; } addlinedialog . setchartengine ( engine ) ; addlinedialog . showdialog ( ) ; if ( horizontallineradiobutton . isselected ( ) ) { sethorizontallineselected ( ) ; } else if ( verticallineradiobutton . isselected ( ) ) { setverticallineselected ( ) ; } }	adds a new line .
public final static < t > completablefuture < list < t > > streamtocompletablefuture ( final stream < t > stream ) { return completablefuture . completedfuture ( stream . collect ( cyclopscollectors . tolistx ( ) ) ) ; }	create a completablefuture containing a list materialized from a stream.
@ suppresswarnings ( _str ) public static boolean isgzipsupported ( final httpservletrequest request ) { if ( request != null ) { final enumeration < string > headernames = request . getheadernames ( ) ; if ( headernames != null ) { while ( headernames . hasmoreelements ( ) ) { final string headername = headernames . nextelement ( ) ; final matcher m = pattern_accept_encoding . matcher ( headername ) ; if ( m . find ( ) ) { final string headervalue = request . getheader ( headername ) ; final matcher mvalue = pattern_gzip . matcher ( headervalue ) ; return mvalue . find ( ) ; } } } } return _bool ; }	analyze headers of the request and searches for mangled ( by proxy ) for " accept - encoding " header and its mangled variations and gzip header value and its mangled variations .
private boolean islanguageallowed ( string languagekey ) { if ( allowedlanguages == null ) return _bool ; return allowedlanguages . contains ( languagekey ) ; }	returns whether a language having the given key should be allowed to be loaded.
public list < boundary > populateward ( final long zoneid ) { list < boundary > wardlist = new linkedlist < boundary > ( ) ; try { wardlist = boundaryservice . getchildboundariesbyboundaryid ( zoneid ) ; } catch ( final exception e ) { logger . error ( _str + e . getmessage ( ) ) ; throw new applicationruntimeexception ( _str , e ) ; } return wardlist ; }	populate the ward list by zone.
static object newinstance ( string classname , classloader cl , boolean dofallback ) throws configurationerror { try { class providerclass = findproviderclass ( classname , cl , dofallback ) ; object instance = providerclass . newinstance ( ) ; debugprintln ( _str + providerclass + _str + cl ) ; return instance ; } catch ( classnotfoundexception x ) { throw new configurationerror ( _str + classname + _str , x ) ; } catch ( exception x ) { throw new configurationerror ( _str + classname + _str + x , x ) ; } }	create an instance of a class using the specified classloader.
public void handlerequest ( list arguments ) { try { installlogger migratelog = new installlogger ( str_migrate ) ; multiplemigratedriver driver = new multiplemigratedriver ( ) ; if ( arguments . isempty ( ) ) { debug . log ( _str ) ; driver . migrate ( migratelog ) ; } else if ( arguments . size ( ) == _num ) { debug . log ( _str ) ; driver . migrate ( migratelog ) ; } } catch ( installabortexception ia ) { debug . log ( _str , ia ) ; console . printlnrawtext ( ia . getmessage ( ) ) ; } catch ( installexception ex ) { debug . log ( _str , ex ) ; printconsolemessage ( loc_hr_err_migrate , new object [ ] { ex . getmessage ( ) } ) ; } }	handle the request of migration .
public static synchronizerstatus makerunningstatus ( ) { return new synchronizerstatus ( status . running , new date ( ) , null ) ; }	makes a running status .
public static iterable < file > applycwd ( file cwd , iterable < file > files ) { if ( files != null ) { list < file > result = new arraylist < file > ( ) ; for ( file f : files ) { result . add ( applycwd ( cwd , f ) ) ; } return result ; } else { return null ; } }	given an iterable of files and a " current working directory " returns an iterable where the files that were relative are now absolute after having the " cwd " applied to them as their parent directory.
private void close ( boolean force ) { if ( closeguard . compareandset ( _bool , _bool ) ) hadoop . close ( force ) ; }	close underlying rpc handler .
mutablebiginteger divideknuth ( mutablebiginteger b , mutablebiginteger quotient , boolean needremainder ) { if ( b . intlen == _num ) throw new arithmeticexception ( _str ) ; if ( intlen == _num ) { quotient . intlen = quotient . offset = _num ; return needremainder ? new mutablebiginteger ( ) : null ; } int cmp = compare ( b ) ; if ( cmp < _num ) { quotient . intlen = quotient . offset = _num ; return needremainder ? new mutablebiginteger ( this ) : null ; } if ( cmp == _num ) { quotient . value [ _num ] = quotient . intlen = _num ; quotient . offset = _num ; return needremainder ? new mutablebiginteger ( ) : null ; } quotient . clear ( ) ; if ( b . intlen == _num ) { int r = divideoneword ( b . value [ b . offset ] , quotient ) ; if ( needremainder ) { if ( r == _num ) return new mutablebiginteger ( ) ; return new mutablebiginteger ( r ) ; } else { return null ; } } if ( intlen >= knuth_pow2_thresh_len ) { int trailingzerobits = math . min ( getlowestsetbit ( ) , b . getlowestsetbit ( ) ) ; if ( trailingzerobits >= knuth_pow2_thresh_zeros * _num ) { mutablebiginteger a = new mutablebiginteger ( this ) ; b = new mutablebiginteger ( b ) ; a . rightshift ( trailingzerobits ) ; b . rightshift ( trailingzerobits ) ; mutablebiginteger r = a . divideknuth ( b , quotient ) ; r . leftshift ( trailingzerobits ) ; return r ; } } return dividemagnitude ( b , quotient , needremainder ) ; }	calculates the quotient of this div b and places the quotient in the provided mutablebiginteger objects and the remainder object is returned.
@ suppresswarnings ( _str ) public void insert ( int id , comparable < e > priority ) { int i ; i = ++ _n ; elementh p = new elementh ( ) ; while ( i > _num ) { int pidx = i / _num ; elementh eidx = ( elementh ) _elements [ pidx ] ; p . id = eidx . id ; p . priority = eidx . priority ; if ( priority . compareto ( ( e ) p . priority ) > _num ) { break ; } elementh ei = ( elementh ) _elements [ i ] ; ei . id = p . id ; ei . priority = p . priority ; _pos [ p . id ] = i ; i = pidx ; } elementh ei = ( elementh ) _elements [ i ] ; ei . id = id ; ei . priority = priority ; _pos [ id ] = i ; }	insert the element ( id ) with given priority.
externalproblem ( socket socket ) throws ioexception { this ( socket . getinputstream ( ) , socket . getoutputstream ( ) ) ; }	constructs an external problem using the specified socket .
private static void stopgc ( ) { gcshouldloop = _bool ; synchronized ( lock ) { lock . notify ( ) ; } }	invoked from native code.
public final void insertelementat ( int value , int at ) { if ( ( m_firstfree + _num ) >= m_mapsize ) { m_mapsize += m_blocksize ; int newmap [ ] = new int [ m_mapsize ] ; system . arraycopy ( m_map , _num , newmap , _num , m_firstfree + _num ) ; m_map = newmap ; } if ( at <= ( m_firstfree - _num ) ) { system . arraycopy ( m_map , at , m_map , at + _num , m_firstfree - at ) ; } m_map [ at ] = value ; m_firstfree ++ ; }	inserts the specified node in this vector at the specified index.
public static @ nullable requestbody creategzip ( final mediatype mediatype , final string body ) { bytearrayoutputstream gzipbytearrayoutputstream = new bytearrayoutputstream ( ) ; try { outputstream gzipoutputstream = new gzipoutputstream ( gzipbytearrayoutputstream ) ; gzipoutputstream . write ( body . getbytes ( ) ) ; gzipoutputstream . close ( ) ; } catch ( ioexception e ) { return null ; } return requestbody . create ( mediatype , gzipbytearrayoutputstream . tobytearray ( ) ) ; }	creates a requestbody from a mediatype and gzip - ed body string.
public xintroactivitybuilder removefragment ( int fragmentpos ) { introfragmentmodellist . remove ( fragmentpos ) ; return this ; }	remove fragment from xintro activity builder .
public boolean update ( ) { return update ; }	perform updates if added documents already exist ?.
public treeviewerbuilder ( composite parent , int style ) { mappings = collections . emptymap ( ) ; checkable = ( style & swt . check ) == swt . check ; if ( checkable ) { viewer = new checkboxtreeviewer ( parent , style ) ; } else { viewer = new treeviewer ( parent , style ) ; } columnviewertooltipsupport . enablefor ( viewer , tooltip . no_recreate ) ; }	creates a new treeviewerbuilder .
@ override public void write ( byte [ ] buffer , int offset , int count ) throws ioexception { synchronized ( intthread ) { int avail = ( wroteindex - dataendindex + data . length ) % data . length ; if ( avail == _num ) avail = data . length ; if ( avail < count ) { throw new ioexception ( _str + avail + _str + count ) ; } if ( count > data . length - dataendindex ) { int firstpart = data . length - dataendindex ; int secondpart = count - firstpart ; system . arraycopy ( buffer , offset , data , dataendindex , firstpart ) ; system . arraycopy ( buffer , offset + firstpart , data , _num , secondpart ) ; dataendindex = secondpart ; } else { system . arraycopy ( buffer , offset , data , dataendindex , count ) ; dataendindex += count ; } intthread . notify ( ) ; } }	will never block . always write to memory.
public void pause ( ) { pauselock . lock ( ) ; try { paused = _bool ; } finally { pauselock . unlock ( ) ; } }	pauses the spider crawling .
public void addtoconsolitatedmsg ( final string message ) { if ( consolidatedmessage != null && consolidatedmessage . length ( ) > _num ) { consolidatedmessage = consolidatedmessage + _str ; } consolidatedmessage = consolidatedmessage + message ; }	add to the consolidated result message which will be displayed in the notification on closing the window . each message that will be added in new line of previous messages using html < br >.
public void sort ( final comparator < ? super t > comparator ) { synchronized ( mlock ) { collections . sort ( mlist , comparator ) ; } notifydatasetchanged ( ) ; }	sorts the content of this adapter using the specified comparator .
public string cropkeepfinalcharacter ( string string , char finalchar ) { string cropped = crop ( string ) ; if ( ( null == string ) || string . equals ( cropped ) ) { return string ; } if ( cropped . length ( ) == _num ) { return cropped ; } return cropped + finalchar ; }	crops the given string and adds the given final character to the string ' s end.
public static boolean isderivedadjective ( final string word ) { if ( word . length ( ) > _num ) { if ( word . endswith ( _str ) || word . endswith ( _str ) ) return _bool ; if ( word . endswith ( _str ) ) return _bool ; } return _bool ; }	check the given word for derived adjectives like " magical " or " nomadic " .
string renamefile ( string inputfilename ) { for ( pattern searchexp : regexmappings . keyset ( ) ) { matcher matcher = searchexp . matcher ( inputfilename ) ; if ( matcher . find ( ) ) { string renamed = matcher . replacefirst ( regexmappings . get ( searchexp ) ) ; return file_sep_char_matcher . trimleadingfrom ( renamed ) ; } } throw new moeproblem ( _str + _str , inputfilename ) ; }	returns the filename according to the rules in mappings .
private static int validateadbserverport ( @ nonnull string adbserverport ) throws illegalargumentexception { try { int port = integer . decode ( adbserverport ) ; if ( port <= _num || port >= _num ) { throw new illegalargumentexception ( _str ) ; } return port ; } catch ( numberformatexception e ) { throw new illegalargumentexception ( _str ) ; } }	returns the integer port value if it is a valid value for adb server port.
public static string formatelapsed ( timestamp start ) { if ( start == null ) return _str ; long starttime = start . gettime ( ) ; long endtime = system . currenttimemillis ( ) ; return formatelapsed ( endtime - starttime ) ; }	format elapsed time until now.
@ override public void stop ( ) { for ( thread thread : threads ) { thread . interrupt ( ) ; } try { for ( thread thread : threads ) { thread . join ( ) ; } } catch ( interruptedexception e ) { } }	kill all the threads , and shutdown .
private boolean verifypublisheddualinetaddress ( string nodeid ) { dualinetaddress dualaddress = null ; configuration config = queryconfiguration ( constants . node_dualinetaddr_config , nodeid ) ; if ( config != null ) { dualaddress = parseinetaddressconfig ( config ) ; } if ( ( dualaddress != null ) && dualaddress . equals ( inetaddresslookupmap . getdualinetaddress ( ) ) ) { return _bool ; } return _bool ; }	returns true is found published dualinetaddress for this node , and it matches with current configured.
public void testrecursivechains ( ) throws throwable { for ( executionmode m : executionmode . values ( ) ) for ( boolean adddeadends : new boolean [ ] { _bool , _bool } ) { final int val = _num ; final int n = expensivetests ? _num : _num ; completablefuture < integer > head = new completablefuture < > ( ) ; completablefuture < integer > tail = head ; for ( int i = _num ; i < n ; i ++ ) { if ( adddeadends ) m . thenapply ( tail , null ) ; tail = m . thenapply ( tail , null ) ; if ( adddeadends ) m . applytoeither ( tail , tail , null ) ; tail = m . applytoeither ( tail , tail , null ) ; if ( adddeadends ) m . thencombine ( tail , tail , null ) ; tail = m . thencombine ( tail , tail , null ) ; } head . complete ( val ) ; assertequals ( val + _num * n , ( int ) tail . join ( ) ) ; } }	test long recursive chains of completablefutures with cascading completions.
public boolean responseisstring ( string oid ) { return stringresponses . contains ( oid ) ; }	determine if the response to a given ldap extended operation ( specified by oid ) should be treated as a string.
private static int type ( final classwriter cw , final string desc ) { string t ; int index = desc . charat ( _num ) == _str ? desc . indexof ( _str ) + _num : _num ; switch ( desc . charat ( index ) ) { case _str : return _num ; case _str : case _str : case _str : case _str : case _str : return integer ; case _str : return float ; case _str : return long ; case _str : return double ; case _str : t = desc . substring ( index + _num , desc . length ( ) - _num ) ; return object | cw . addtype ( t ) ; default : int data ; int dims = index + _num ; while ( desc . charat ( dims ) == _str ) { ++ dims ; } switch ( desc . charat ( dims ) ) { case _str : data = boolean ; break ; case _str : data = char ; break ; case _str : data = byte ; break ; case _str : data = short ; break ; case _str : data = integer ; break ; case _str : data = float ; break ; case _str : data = long ; break ; case _str : data = double ; break ; default : t = desc . substring ( dims + _num , desc . length ( ) - _num ) ; data = object | cw . addtype ( t ) ; } return ( dims - index ) << _num | data ; } }	returns the int encoding of the given type .
public void logfine ( string message ) { logger . fine ( logprefix + message ) ; }	logs an information message using the logger of this interpreter ( logger level : fine ) .
public static optional < string > createinputdialog ( final window owner , final string title , final string label ) { final textinputdialog dialog = new textinputdialog ( ) ; dialog . settitle ( title ) ; dialog . setheadertext ( null ) ; dialog . setcontenttext ( label ) ; dialog . initowner ( owner ) ; return dialog . showandwait ( ) ; }	asks the user for input .
private static string encode ( final string text ) throws unsupportedencodingexception { return urlencoder . encode ( text , _str ) ; }	encode text as utf - 8.
public static string converttorgb ( int color ) { string red = integer . tohexstring ( color . red ( color ) ) ; string green = integer . tohexstring ( color . green ( color ) ) ; string blue = integer . tohexstring ( color . blue ( color ) ) ; if ( red . length ( ) == _num ) { red = _str + red ; } if ( green . length ( ) == _num ) { green = _str + green ; } if ( blue . length ( ) == _num ) { blue = _str + blue ; } return _str + red + green + blue ; }	method currently used by ongetdefaultvalue method to convert hex string provided in android : defaultvalue to color integer .
private static final void appendencodedbyte ( stringbuffer buffer , byte value , byte [ ] state ) { if ( state [ _num ] != _num ) { char c = ( char ) ( ( state [ _num ] << _num ) | ( ( ( int ) value ) & _num ) ) ; buffer . append ( c ) ; state [ _num ] = _num ; } else { state [ _num ] = _num ; state [ _num ] = value ; } }	append a byte to the given stringbuffer , packing two bytes into each character.
public sidedplane ( double px , double py , double pz , vector v , double d ) { super ( v , d ) ; signum = math . signum ( evaluate ( px , py , pz ) ) ; if ( signum == _num ) throw new illegalargumentexception ( _str ) ; }	construct a sided plane with a normal vector and offset .
public string buildunionquery ( string [ ] subqueries , string sortorder , string limit ) { stringbuilder query = new stringbuilder ( _num ) ; int subquerycount = subqueries . length ; string unionoperator = mdistinct ? _str : _str ; for ( int i = _num ; i < subquerycount ; i ++ ) { if ( i > _num ) { query . append ( unionoperator ) ; } query . append ( subqueries [ i ] ) ; } appendclause ( query , _str , sortorder ) ; appendclause ( query , _str , limit ) ; return query . tostring ( ) ; }	given a set of subqueries , all of which are select statements , construct a query that returns the union of what those subqueries return .
@ override public string tostring ( ) { stringbuffer sb = new stringbuffer ( ) ; sb . append ( clientid ) ; sb . append ( _str ) ; switch ( status ) { case connected : sb . append ( context . getstring ( r . string . connectedto ) ) ; break ; case disconnected : sb . append ( context . getstring ( r . string . disconnected ) ) ; break ; case none : sb . append ( context . getstring ( r . string . no_status ) ) ; break ; case connecting : sb . append ( context . getstring ( r . string . connecting ) ) ; break ; case disconnecting : sb . append ( context . getstring ( r . string . disconnecting ) ) ; break ; case error : sb . append ( context . getstring ( r . string . connectionerror ) ) ; } sb . append ( _str ) ; sb . append ( host ) ; return sb . tostring ( ) ; }	a string representing the state of the client this connection object represents.
void registercallback ( bluetoothcallback callback ) { synchronized ( mcallbacks ) { mcallbacks . add ( callback ) ; } }	register to start receiving callbacks for bluetooth events .
private void validatetablemetadatanorow ( string tablenamepattern , string [ ] types ) throws exception { try ( resultset tables = dbmd . gettables ( null , null , tablenamepattern , types ) ) { assertfalse ( string . format ( _str , tablenamepattern , arrays . tostring ( types ) ) , tables . next ( ) ) ; } }	helper method for test methods that retrieve metadata expecting no results .
void checkclassbounds ( diagnosticposition pos , type type ) { checkclassbounds ( pos , new hashmap < typesymbol , type > ( ) , type ) ; }	check that class c does not implement directly or indirectly the same parameterized interface with two different argument lists .
private static string parsetoken ( string pattern , int [ ] indexref ) { stringbuffer buf = new stringbuffer ( ) ; int i = indexref [ _num ] ; int length = pattern . length ( ) ; char c = pattern . charat ( i ) ; if ( c >= _str && c <= _str || c >= _str && c <= _str ) { buf . append ( c ) ; while ( i + _num < length ) { char peek = pattern . charat ( i + _num ) ; if ( peek == c ) { buf . append ( c ) ; i ++ ; } else { break ; } } } else { buf . append ( _str ) ; boolean inliteral = _bool ; for ( ; i < length ; i ++ ) { c = pattern . charat ( i ) ; if ( c == _str ) { if ( i + _num < length && pattern . charat ( i + _num ) == _str ) { i ++ ; buf . append ( c ) ; } else { inliteral = ! inliteral ; } } else if ( ! inliteral && ( c >= _str && c <= _str || c >= _str && c <= _str ) ) { i -- ; break ; } else { buf . append ( c ) ; } } } indexref [ _num ] = i ; return buf . tostring ( ) ; }	parses an individual token .
@ override public void nodedown ( long eventuid , string nodeid ) { try { lock . lock ( ) ; untriedconnectors . putall ( triedconnectors ) ; triedconnectors . clear ( ) ; if ( untriedconnectors . size ( ) > _num ) { condition . signal ( ) ; } } finally { lock . unlock ( ) ; } }	if a node goes down we try all the connectors again as one may now be available for replication < p > todo : there will be a better way to do this by finding which nodes backup has gone down .
public void removecartitem ( int index , boolean triggerexternalops , localdispatcher dispatcher ) throws cartitemmodifyexception { if ( isreadonlycart ( ) ) { throw new cartitemmodifyexception ( _str ) ; } if ( index < _num ) return ; if ( cartlines . size ( ) <= index ) return ; shoppingcartitem item = cartlines . remove ( index ) ; item . setquantity ( bigdecimal . zero , dispatcher , this , triggerexternalops , _bool , _bool , _bool ) ; }	scipio : remove an item from the cart object.
private final void accesscheck ( t obj ) { if ( ! cclass . isinstance ( obj ) ) throw accesscheckexception ( obj ) ; }	checks that target argument is instance of cclass.
protected void markfirsttime ( element elem ) { string elemname = elem . getname ( ) ; if ( elemname . equals ( _str ) ) { seenhtml = _bool ; } else if ( elemname . equals ( _str ) ) { seenhead = _bool ; } else if ( elemname . equals ( _str ) ) { if ( buf . length == _num ) { char [ ] newbuf = new char [ _num ] ; newbuf [ _num ] = buf [ _num ] ; buf = newbuf ; } seenbody = _bool ; } }	marks the first time a tag has been seen in a document.
public static string timetostring ( long period ) { period /= _num ; final long milsecs = period % _num ; period /= _num ; final long secs = period % _num ; period /= _num ; final long mins = period % _num ; period /= _num ; final long hours = period ; return string . format ( _str , hours , mins , secs , milsecs ) ; }	converts millisecond count to hh : mm : ss.
protected static boolean isuserdefinedproperty ( string propname ) { return ! standardpropnames . contains ( propname ) ; }	is this property a solr - standard property , or is it an extra property defined per - core by the user ?.
private boolean conditionm0 ( string value , int index ) { if ( charat ( value , index + _num ) == _str ) { return _bool ; } return contains ( value , index - _num , _num , _str ) && ( ( index + _num ) == value . length ( ) - _num || contains ( value , index + _num , _num , _str ) ) ; }	complex condition 0 for ' m '.
@ reference ( authors = _str , title = _str , booktitle = _str , url = _str ) public double computetau ( long c , long d , double m , long wd , long bd ) { double tie = ( wd * ( wd - _num ) + bd * ( bd - _num ) ) > > > _num ; return ( c - d ) / math . sqrt ( ( m - tie ) * m ) ; }	compute the tau correlation measure.
private void readobject ( objectinputstream in ) throws ioexception , classnotfoundexception { in . defaultreadobject ( ) ; serviceid = new serviceid ( in ) ; }	reads the service id , encoded as specified by the serviceid.
private void generatecreateevents ( list < igfspath > createdpaths , boolean file ) { if ( evts . isrecordable ( eventtype . evt_igfs_dir_created ) ) { for ( int i = _num ; i < createdpaths . size ( ) - _num ; i ++ ) igfsutils . sendevents ( igfsctx . kernalcontext ( ) , createdpaths . get ( i ) , eventtype . evt_igfs_dir_created ) ; } igfspath leafpath = createdpaths . get ( createdpaths . size ( ) - _num ) ; if ( file ) { igfsutils . sendevents ( igfsctx . kernalcontext ( ) , leafpath , eventtype . evt_igfs_file_created ) ; igfsutils . sendevents ( igfsctx . kernalcontext ( ) , leafpath , eventtype . evt_igfs_file_opened_write ) ; } else igfsutils . sendevents ( igfsctx . kernalcontext ( ) , leafpath , eventtype . evt_igfs_dir_created ) ; }	generate events for created file or directory .
public optintemplateclassresolver ( set allowedclasses , list trustedtemplates ) { this . allowedclasses = allowedclasses != null ? allowedclasses : collections . empty_set ; if ( trustedtemplates != null ) { trustedtemplatenames = new hashset ( ) ; trustedtemplateprefixes = new arraylist ( ) ; iterator it = trustedtemplates . iterator ( ) ; while ( it . hasnext ( ) ) { string li = ( string ) it . next ( ) ; if ( li . startswith ( _str ) ) li = li . substring ( _num ) ; if ( li . endswith ( _str ) ) { trustedtemplateprefixes . add ( li . substring ( _num , li . length ( ) - _num ) ) ; } else { trustedtemplatenames . add ( li ) ; } } } else { trustedtemplatenames = collections . empty_set ; trustedtemplateprefixes = collections . empty_list ; } }	creates a new instance .
protected void asyncoprelease ( ) { if ( asyncopssem != null ) asyncopssem . release ( ) ; }	releases asynchronous operations permit , if limited .
public static boolean validsystemnameconfig ( string systemname , char type ) { if ( ! validsystemnameformat ( systemname , type ) ) { return _bool ; } return _bool ; }	public static method to validate system name for configuration returns ' true ' if system name has a valid meaning in current configuration , else returns ' false '.
public void removeall ( ) { if ( mrecords . size ( ) >= _num ) { mrecords . clear ( ) ; mcurrentposition = - _num ; notifyobservers ( ) ; } }	clear the internal cursor data .
public synchronized boolean startreindexer ( string name , boolean force ) throws reindexeralreadyrunningexception { onlinereindexer < ? , ? , ? > reindexer = reindexers . get ( name ) ; validatereindexernotrunning ( reindexer ) ; if ( force || ! iscurrentindexversionlatest ( name , reindexer ) ) { reindexer . start ( ) ; return _bool ; } return _bool ; }	start the online reindexer if the current index is not already the latest .
@ override public void printstacktrace ( ) { super . printstacktrace ( ) ; if ( nested != null ) nested . printstacktrace ( ) ; }	prints the composite message to system.
private static void updatelastmodified ( file destdir , string warfilepath ) { file warfile = new file ( warfilepath ) ; destdir . setlastmodified ( warfile . lastmodified ( ) ) ; }	updates the last - modified timestamp of the webapp directory to that of the daemon war .
public void addchild ( baseassemblynode childnode ) { childnode . parentnode = this ; childnodes . add ( childnode ) ; }	add a child node .
protected void notifyhistorychangedlisteners ( ) { iterator < historychangedlistener > iter ; historychangedlistener l ; iter = m_historychangedlisteners . iterator ( ) ; while ( iter . hasnext ( ) ) { l = iter . next ( ) ; l . historychanged ( new historychangedevent ( this , history_name , gethistory ( ) ) ) ; } }	notifies the history listeners of the event .
private void signalnotfull ( ) { final reentrantlock putlock = this . putlock ; putlock . lock ( ) ; try { notfull . signal ( ) ; } finally { putlock . unlock ( ) ; } }	signals a waiting put.
private textview findtextviewbytagid ( final string tagid ) { for ( final textview view : mtagviewmap . values ( ) ) { final tag tag = ( tag ) view . gettag ( ) ; if ( tagid . equals ( tag . id ) ) { return view ; } } return null ; }	finds a textview by the tag id.
public space prune ( space prefix ) throws scopeexception { space x = this ; arraylist < space > stack = new arraylist < > ( ) ; while ( x != null && ! x . equals ( prefix ) ) { stack . add ( _num , x ) ; x = x . getparent ( ) ; } if ( x == null ) { throw new scopeexception ( _str ) ; } else { space result = new space ( universe , x . getdomain ( ) ) ; for ( space space : stack ) { result = result . s ( space . getrelation ( ) ) ; } return result ; } }	prune this space using the given prefix.
default void infof ( string format , object ... args ) { info ( string . format ( format , args ) ) ; }	log an info level message with given format and arguments .
public static int darker ( int color , float factor ) { int a = color . alpha ( color ) ; int r = color . red ( color ) ; int g = color . green ( color ) ; int b = color . blue ( color ) ; return color . argb ( a , math . max ( ( int ) ( r * factor ) , _num ) , math . max ( ( int ) ( g * factor ) , _num ) , math . max ( ( int ) ( b * factor ) , _num ) ) ; }	retuns a darker color from a specified color by the factor .
public < fv > fv extractrawjavafieldvalue ( object object ) throws sqlexception { object val ; if ( fieldgetmethod == null ) { try { val = field . get ( object ) ; } catch ( exception e ) { throw sqlexceptionutil . create ( _str + this , e ) ; } } else { try { val = fieldgetmethod . invoke ( object ) ; } catch ( exception e ) { throw sqlexceptionutil . create ( _str + fieldgetmethod + _str + this , e ) ; } } @ suppresswarnings ( _str ) fv converted = ( fv ) val ; return converted ; }	return the value from the field in the object that is defined by this fieldtype .
public static void writefile ( file file , byte [ ] data ) { try { randomaccessfile ra = new randomaccessfile ( file , _str ) ; ra . write ( data ) ; ra . setlength ( data . length ) ; ra . close ( ) ; } catch ( ioexception e ) { throw new runtimeexception ( _str + file , e ) ; } }	create or overwrite a file .
public static double [ ] thresholdstringtoarray ( string top , int l ) { if ( top . startswith ( _str ) ) { return mlutils . todoublearray ( top ) ; } else { double t [ ] = new double [ l ] ; arrays . fill ( t , double . parsedouble ( top ) ) ; return t ; } }	thresholdstringtoarray - parse a threshold option string to an array of l thresholds ( one for each label variable ) .
@ override public string [ ] determinecolumnconstraints ( resultproducer rp ) throws exception { return null ; }	determines if there are any constraints ( imposed by the destination ) on the result columns to be produced by resultproducers.
abstract set < string > initconfignames ( ) ;	let subclass start the needed config names.
public static int eval ( string url , string text ) throws ioexception { string returnvalue = null ; if ( url . startswith ( _str ) ) { returnvalue = dohttp ( url , text ) ; } else if ( url . startswith ( _str ) ) { returnvalue = dobsh ( url , text ) ; } else throw new ioexception ( _str + _str ) ; try { return integer . parseint ( returnvalue ) ; } catch ( exception e ) { return _num ; } }	evaluate text in the interpreter at url , returning a possible integer return value .
public dsaprivatekey ( byte [ ] encoded ) throws invalidkeyexception { clearoldkey ( ) ; decode ( encoded ) ; }	make a dsa private key from its der encoding ( pkcs # 8 ) .
private void sendbroadcastnewoperation ( target target , remoteoperation operation ) { intent intent = new intent ( action_operation_added ) ; if ( target . maccount != null ) { intent . putextra ( extra_account , target . maccount ) ; } else { intent . putextra ( extra_server_url , target . mserverurl ) ; } sendstickybroadcast ( intent ) ; }	sends a broadcast when a new operation is added to the queue . local broadcasts are only delivered to activities in the same process , but can ' t be done sticky : \.
int successful ( ) { return success . get ( ) ; }	total successful operations so far.
public void monitor ( string key ) { timer t = new timer ( _bool ) ; t . schedule ( new watchableregistration ( key ) , _num * _num , _num * _num ) ; }	activates a watchdog watching over a registration.
protected int checkriskattribute ( ) { int retval = _num ; if ( debug . messageenabled ( ) ) { debug . message ( _str , adaptive ) ; } if ( riskattributename != null && riskattributevalue != null ) { set < string > riskattributevalues = null ; riskattributevalues = getidentityattributeset ( riskattributename ) ; if ( riskattributevalues != null ) { for ( string riskattr : riskattributevalues ) { if ( riskattributevalue . equalsignorecase ( riskattr ) ) { if ( debug . messageenabled ( ) ) { debug . message ( _str , adaptive ) ; } retval = riskattributescore ; break ; } } } } if ( ! riskattributeinvert ) { retval = riskattributescore - retval ; } return retval ; }	check to see if the user profile has a risk attribute with value.
public static methexecutorresult executeinstance ( string receiver , string selector , class [ ] types , object [ ] args ) { try { class receiverclass = class . forname ( receiver ) ; constructor init = receiverclass . getdeclaredconstructor ( new class [ _num ] ) ; init . setaccessible ( _bool ) ; object target = init . newinstance ( new object [ _num ] ) ; object res = null ; try { method themethod = getmethod ( receiverclass , selector , types ) ; res = themethod . invoke ( target , args ) ; return new methexecutorresult ( res ) ; } catch ( invocationtargetexception invtargex ) { throwable targex = invtargex . gettargetexception ( ) ; if ( targex == null ) { return new methexecutorresult ( res ) ; } else { return new methexecutorresult ( targex ) ; } } } catch ( virtualmachineerror e ) { systemfailure . initiatefailure ( e ) ; throw e ; } catch ( throwable t ) { return new methexecutorresult ( t ) ; } }	send the message " selector " to an instance of the class named " receiver ".
private void writeobject ( objectoutputstream stream ) throws ioexception { stream . defaultwriteobject ( ) ; marshalattributes ( attrs , stream ) ; }	writes attributes as a null - terminated list of marshalledinstances .
@ override synchronized public void write ( byte b [ ] , int off , int len ) throws ioexception { if ( b == null ) { throw new nullpointerexception ( ) ; } else if ( off < _num || len < _num || len > b . length - off ) { throw new indexoutofboundsexception ( ) ; } else if ( len == _num ) { return ; } c . checkwrite ( ) ; boolean isfirstrecordofthepayload = _bool ; try { do { boolean holdrecord = _bool ; int howmuch ; if ( isfirstrecordofthepayload && c . needtosplitpayload ( ) ) { howmuch = math . min ( _num , r . availabledatabytes ( ) ) ; if ( ( len != _num ) && ( howmuch == _num ) ) { holdrecord = _bool ; } } else { howmuch = math . min ( len , r . availabledatabytes ( ) ) ; } if ( isfirstrecordofthepayload && howmuch != _num ) { isfirstrecordofthepayload = _bool ; } if ( howmuch > _num ) { r . write ( b , off , howmuch ) ; off += howmuch ; len -= howmuch ; } c . writerecord ( r , holdrecord ) ; c . checkwrite ( ) ; } while ( len > _num ) ; } catch ( exception e ) { c . handleexception ( e ) ; } }	write the data out , now .
public boolean onintercepttouchevent ( motionevent ev ) { @ suppresswarnings ( _str ) final boolean debug = _bool ; if ( debug ) { log . d ( launcher . tag , _str + ev + _str + mdragging ) ; } acquirevelocitytrackerandaddmovement ( ev ) ; final int action = ev . getaction ( ) ; final int [ ] draglayerpos = getclampeddraglayerpos ( ev . getx ( ) , ev . gety ( ) ) ; final int draglayerx = draglayerpos [ _num ] ; final int draglayery = draglayerpos [ _num ] ; switch ( action ) { case motionevent . action_move : break ; case motionevent . action_down : mmotiondownx = draglayerx ; mmotiondowny = draglayery ; mlastdroptarget = null ; break ; case motionevent . action_up : mlasttouchuptime = system . currenttimemillis ( ) ; if ( mdragging ) { pointf vec = isflingingtodelete ( mdragobject . dragsource ) ; if ( ! deletedroptarget . willacceptdrop ( mdragobject . draginfo ) ) { vec = null ; } if ( vec != null ) { droponflingtodeletetarget ( draglayerx , draglayery , vec ) ; } else { drop ( draglayerx , draglayery ) ; } } enddrag ( ) ; break ; case motionevent . action_cancel : canceldrag ( ) ; break ; } return mdragging ; }	call this from a drag source view .
public void test_concurrentkbcreateanddiscovery ( ) throws exception { final string namespace = getname ( ) ; final properties properties = getproperties ( ) ; journal jnl = null ; try { jnl = new journal ( properties ) ; doconcurrentcreateanddiscoverytest ( jnl , namespace ) ; } finally { if ( jnl != null ) jnl . destroy ( ) ; } }	basic test of the concurrent create and discovery of a kb .
private void resetdatabase ( tungstenproperties serviceprops , map < string , string > progress ) throws interruptedexception { datasourceadministrator admin = null ; string servicename = serviceprops . getstring ( replicatorconf . service_name ) ; try { admin = new datasourceadministrator ( serviceprops ) ; admin . prepare ( ) ; progress . put ( _str , servicename ) ; boolean cleared = admin . resetall ( ) ; if ( cleared ) { logger . info ( _str ) ; } else { logger . info ( _str + servicename ) ; } } catch ( replicatorexception e ) { logger . error ( string . format ( _str , servicename , e . getmessage ( ) ) , e ) ; } finally { if ( admin != null ) { admin . release ( ) ; } } }	resets all catalog data for data sources associated with current replicator .
private void initializeidealpoint ( ) { idealpoint = new double [ problem . getnumberofobjectives ( ) ] ; arrays . fill ( idealpoint , double . positive_infinity ) ; }	initializes the ideal point .
private long startwait ( ) { return system . nanotime ( ) ; }	initialize the timeout timer.
public static string [ ] readfontnames ( final fontdata fontdata ) { final string [ ] fontnames = new string [ _num ] ; fontnames [ _num ] = null ; final bufferedreader br = new bufferedreader ( new stringreader ( new string ( fontdata . getbytes ( _num , fontdata . length ( ) ) ) ) ) ; string line = null ; while ( _bool ) { try { line = br . readline ( ) ; } catch ( final ioexception e ) { logwriter . writelog ( _str + e . getmessage ( ) ) ; } if ( line == null ) { break ; } if ( line . startswith ( _str ) ) { final int namestart = line . indexof ( _str , _num ) ; if ( namestart != - _num ) { final int nameend = line . indexof ( _str , namestart ) ; if ( nameend != - _num ) { final string name = line . substring ( namestart + _num , nameend ) ; fontnames [ _num ] = name . tolowercase ( ) ; break ; } } } } if ( br != null ) { try { br . close ( ) ; } catch ( final exception e ) { logwriter . writelog ( _str + e + _str ) ; } } if ( fontdata != null ) { fontdata . close ( ) ; } return fontnames ; }	return name of font name will be lowercase to avoid issues of capitalisation when used for lookup - if no name , will default to null mode is pdfdecoder.
private void writeunitsofindentation ( int i ) throws ioexception { for ( ; i > _num ; i -- ) { writer . write ( indentation_unit ) ; } }	write the specified number of indentation units to the writer .
private patternparser ( ) throws hyphenationexception { token = new stringbuilder ( ) ; parser = createparser ( ) ; parser . setcontenthandler ( this ) ; parser . seterrorhandler ( this ) ; hyphenchar = _str ; }	construct a pattern parser .
public static int capbetween ( int min , int number , int max ) { asserttrue ( min <= max ) ; return math . min ( max , math . max ( min , number ) ) ; }	caps given number betwen given min and max , inclusive .
public boolean hasextensions ( ) { return extensions != null ; }	return whether or not the holder ' s attribute certificate contains extensions .
public void munge ( string entityid , collection < statement > statements , collection < string > existingvalues , collection < string > existingrefs , change sourcechange ) { if ( statements . isempty ( ) ) { return ; } mungeoperation op = new mungeoperation ( entityid , statements , existingvalues , existingrefs ) ; if ( sourcechange != null ) { op . importfromchange ( sourcechange ) ; } op . munge ( ) ; existingvalues . removeall ( op . extravalidsubjects ) ; existingrefs . removeall ( op . extravalidsubjects ) ; return ; }	adds and removes entries from the statements collection to munge wikibase rdf exports into a more queryable form .
public void showpropertydialog ( ) { if ( m_editor . getvalue ( ) != null ) { if ( m_pd == null ) { int x = getlocationonscreen ( ) . x ; int y = getlocationonscreen ( ) . y ; if ( propertydialog . getparentdialog ( this ) != null ) m_pd = new propertydialog ( propertydialog . getparentdialog ( this ) , m_editor , x , y ) ; else m_pd = new propertydialog ( propertydialog . getparentframe ( this ) , m_editor , x , y ) ; m_pd . setvisible ( _bool ) ; } else { m_pd . setvisible ( _bool ) ; } m_editor . setvalue ( m_editor . getvalue ( ) ) ; } }	displays the property edit dialog for the panel .
public lucene60codec ( mode mode ) { super ( _str ) ; this . storedfieldsformat = new lucene50storedfieldsformat ( objects . requirenonnull ( mode ) ) ; }	instantiates a new codec , specifying the stored fields compression mode to use .
public synchronized void remove ( string name ) { for ( int i = _num ; i < modifications . size ( ) ; i ++ ) { modification mod = modifications . get ( i ) ; attribute attr = mod . getattribute ( ) ; if ( name . equalsignorecase ( attr . getattributedescriptionasstring ( ) ) ) { modifications . remove ( i ) ; return ; } } }	removes the first attribute with the specified name in the set of modifications .
private boolean quietsleep ( long ms ) { try { thread . sleep ( ms ) ; } catch ( interruptedexception e ) { return _bool ; } return _bool ; }	wrapper around thread . sleep ( ) without that annoying interruptedexception .
public void pushframe ( localvariablemap vars , dmlprogramcounter pc ) { callstack . push ( new dmlframe ( vars , pc ) ) ; }	put current frame into stack due to function call.
protected void layoutgraphicmodifiers ( drawcontext dc , avlist modifiers , orderedsymbol osym ) { }	layout static graphic modifiers around the symbol.
public static synchronized void progress ( final string message ) { slastprogress = message ; final printstream prog = getprogressstream ( ) ; if ( prog != null ) { prog . println ( now ( ) + message ) ; prog . flush ( ) ; if ( prog . checkerror ( ) ) { sprogressstream = null ; } } }	write a message to the progress stream if a log file exists .
private static boolean match ( charsequence string , charsequence pattern , int sndx , int pndx ) { int plen = pattern . length ( ) ; if ( plen == _num ) { if ( pattern . charat ( _num ) == _str ) { return _bool ; } } int slen = string . length ( ) ; boolean nextisnotwildcard = _bool ; while ( _bool ) { if ( ( sndx >= slen ) == _bool ) { while ( ( pndx < plen ) && ( pattern . charat ( pndx ) == _str ) ) { pndx ++ ; } return pndx >= plen ; } if ( pndx >= plen ) { return _bool ; } char p = pattern . charat ( pndx ) ; if ( nextisnotwildcard == _bool ) { if ( p == _str ) { pndx ++ ; nextisnotwildcard = _bool ; continue ; } if ( p == _str ) { sndx ++ ; pndx ++ ; continue ; } if ( p == _str ) { char pnext = _num ; if ( pndx + _num < plen ) { pnext = pattern . charat ( pndx + _num ) ; } if ( pnext == _str ) { pndx ++ ; continue ; } int i ; pndx ++ ; for ( i = string . length ( ) ; i >= sndx ; i -- ) { if ( match ( string , pattern , i , pndx ) == _bool ) { return _bool ; } } return _bool ; } } else { nextisnotwildcard = _bool ; } if ( p != string . charat ( sndx ) ) { return _bool ; } sndx ++ ; pndx ++ ; } }	internal matching recursive function .
public void addgrammarfile ( string filename ) { grammarfiles . add ( filename ) ; }	adds a grammar file name .
private workflow . method rollbackdeletemirrordevicemethod ( uri vplexuri , uri vplexmirroruri ) { return new workflow . method ( rb_delete_mirror_device_method_name , vplexuri , vplexmirroruri ) ; }	returns a workflow . method for deactivating mirror.
private string findcipherandstrength ( byte [ ] supportedciphers , string [ ] tokens ) { byte s ; for ( int i = _num ; i < strength . length ; i ++ ) { if ( ( s = strength [ i ] ) != _num ) { for ( int j = _num ; j < supportedciphers . length ; j ++ ) { if ( s == supportedciphers [ j ] && ( specifiedcipher == null || specifiedcipher . equals ( tokens [ j ] ) ) ) { switch ( s ) { case high_strength : negotiatedstrength = _str ; break ; case medium_strength : negotiatedstrength = _str ; break ; case low_strength : negotiatedstrength = _str ; break ; } return tokens [ j ] ; } } } } return null ; }	steps through the ordered ' strength ' array , and compares it with the ' supportedciphers ' array.
public static string [ ] split ( string line , string delim ) { list list = new arraylist ( ) ; stringtokenizer t = new stringtokenizer ( line , delim ) ; while ( t . hasmoretokens ( ) ) { list . add ( t . nexttoken ( ) ) ; } return ( string [ ] ) list . toarray ( new string [ list . size ( ) ] ) ; }	create a string array from a string separated by delim.
public static string slurpfile ( file file ) throws ioexception { reader r = new filereader ( file ) ; return slurpreader ( r ) ; }	returns all the text in the given file .
@ override public string tostring ( ) { stringbuilder result = new stringbuilder ( limit - position ) ; for ( int i = position ; i < limit ; i ++ ) { result . append ( get ( i ) ) ; } return result . tostring ( ) ; }	returns a string representing the current remaining chars of this buffer .
public void testequalsunequal1 ( ) { string a = _str ; int ascale = - _num ; string b = _str ; int bscale = _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; assertfalse ( anumber . equals ( bnumber ) ) ; }	equals ( ) for unequal bigdecimals.
public void testcase8 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = - _num ; int bsign = _num ; byte rbytes [ ] = { - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . subtract ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( - _num , result . signum ( ) ) ; }	subtract two numbers of the same length and different signs.
public getformkeycmd ( string processdefinitionid , string taskdefinitionkey ) { setprocessdefinitionid ( processdefinitionid ) ; if ( taskdefinitionkey == null || taskdefinitionkey . length ( ) < _num ) { throw new activitiillegalargumentexception ( _str + taskdefinitionkey + _str ) ; } this . taskdefinitionkey = taskdefinitionkey ; }	retrieves a task form key .
protected abstract storagelevel storagelevel ( ) ;	returns the log storage level .
@ override public graphics create ( ) { if ( debug ) { m_printstream . println ( _str ) ; } postscriptgraphics psg = new postscriptgraphics ( this ) ; return ( psg ) ; }	clone a postscriptgraphics object.
private void parseactions ( ) { stringtokenizer st = new stringtokenizer ( actions , _str , _bool ) ; boolean comma = _bool ; while ( st . hasmoretokens ( ) ) { string act = st . nexttoken ( ) ; if ( act . equals ( _str ) ) { continue ; } else if ( comma ) { if ( ! act . equals ( _str ) ) { comma = _bool ; break ; } } else if ( act . equalsignorecase ( _str ) ) { mask |= connect ; } else if ( act . equalsignorecase ( _str ) ) { mask |= accept ; } else if ( act . equalsignorecase ( _str ) ) { mask |= delegate ; } else if ( act . equalsignorecase ( _str ) ) { mask |= listen ; } else { break ; } comma = ! comma ; } if ( ! comma ) { throw new illegalargumentexception ( _str ) ; } }	parses the actions field and initializes the transient mask field .
public static boolean isvalidname ( string name ) { if ( name == null ) { return _bool ; } return name . length ( ) > _num ; }	verifies that the specified name is valid for our service.
protected void addcounters ( basiccounters < mutablelong > target , basiccounters < mutablelong > source ) { for ( enum < readercounterkeys > key : readercounterkeys . values ( ) ) { mutablelong tcounter = target . getcounter ( key ) ; if ( tcounter == null ) { tcounter = new mutablelong ( ) ; target . setcounter ( key , tcounter ) ; } mutablelong scounter = source . getcounter ( key ) ; if ( scounter != null ) { tcounter . add ( scounter . longvalue ( ) ) ; } } }	transfers the counters in partitioning .
private void recomputeseperation ( double [ ] [ ] means , double [ ] sep ) { final int k = means . length ; assert ( sep . length == k ) ; boolean issquared = ( distancefunction instanceof squaredeuclideandistancefunction ) ; arrays . fill ( sep , double . positive_infinity ) ; for ( int i = _num ; i < k ; i ++ ) { doublevector m1 = doublevector . wrap ( means [ i ] ) ; for ( int j = _num ; j < i ; j ++ ) { double d = distancefunction . distance ( m1 , doublevector . wrap ( means [ j ] ) ) ; sep [ i ] = ( d < sep [ i ] ) ? d : sep [ i ] ; sep [ j ] = ( d < sep [ j ] ) ? d : sep [ j ] ; } } for ( int i = _num ; i < k ; i ++ ) { sep [ i ] = issquared ? math . sqrt ( sep [ i ] ) : sep [ i ] ; sep [ i ] *= _num ; } }	recompute the separation of cluster means .
private int transition ( int state , int symbol ) { for ( int i = state ; i < transitions . length ; i ++ ) { if ( ( transitions [ i ] % vocabularysize ) == symbol ) { return ( transitions [ i ] / vocabularysize ) ; } } return - _num ; }	causes this fsm to transition to the next state given the current state and input symbol .
public synchronized ceylonconfig merge ( ceylonconfig other ) { for ( string key : other . getoptionnames ( null ) ) { string [ ] values = other . getoptionvalues ( key ) ; setoptionvalues ( key , values ) ; } return this ; }	merges the options from the given configuration with the current one where duplicate options that exist locally will be overwritten by the ones encountered in the given configuration .
public static synchronized string rot13 ( string input ) { stringbuffer output = new stringbuffer ( ) ; if ( input != null ) { for ( int i = _num ; i < input . length ( ) ; i ++ ) { char inchar = input . charat ( i ) ; if ( ( inchar >= _str ) & ( inchar <= _str ) ) { inchar += _num ; if ( inchar > _str ) { inchar -= _num ; } } if ( ( inchar >= _str ) & ( inchar <= _str ) ) { inchar += _num ; if ( inchar > _str ) { inchar -= _num ; } } output . append ( inchar ) ; } } return output . tostring ( ) ; }	description of the method.
private long monthrange ( ) { valuerange startrange = chrono . range ( month_of_year ) ; if ( startrange . isfixed ( ) && startrange . isintvalue ( ) ) { return startrange . getmaximum ( ) - startrange . getminimum ( ) + _num ; } return - _num ; }	calculates the range of months .
public void animate ( markerwithposition marker , latlng from , latlng to ) { lock . lock ( ) ; manimationtasks . add ( new animationtask ( marker , from , to ) ) ; lock . unlock ( ) ; }	animates a markerwithposition some time in the future .
@ override public int compareto ( componentdescription o ) { int mypos = _num ; int opos = _num ; if ( this instanceof languagecomponentdescription ) { mypos = _num ; } else if ( this instanceof voicecomponentdescription ) { mypos = _num ; } if ( o instanceof languagecomponentdescription ) { opos = _num ; } else if ( o instanceof voicecomponentdescription ) { opos = _num ; } if ( opos - mypos != _num ) { return ( opos - mypos ) ; } return name . compareto ( o . name ) ; }	define a natural ordering for component descriptions.
public boolean [ ] testtostring ( ) { return super . testtostring ( ) ; }	checks whether the scheme ' s tostring ( ) method works even though the classifies hasn ' t been built yet .
public static byte [ ] escapeeasternunicodebytestream ( byte [ ] origbytes , string origstring ) { if ( origbytes == null ) { return null ; } if ( origbytes . length == _num ) { return new byte [ _num ] ; } int byteslen = origbytes . length ; int bufindex = _num ; int strindex = _num ; bytearrayoutputstream bytesout = new bytearrayoutputstream ( byteslen ) ; while ( _bool ) { if ( origstring . charat ( strindex ) == _str ) { bytesout . write ( origbytes [ bufindex ++ ] ) ; } else { int lobyte = origbytes [ bufindex ] ; if ( lobyte < _num ) { lobyte += _num ; } bytesout . write ( lobyte ) ; if ( lobyte >= _num ) { if ( bufindex < ( byteslen - _num ) ) { int hibyte = origbytes [ bufindex + _num ] ; if ( hibyte < _num ) { hibyte += _num ; } bytesout . write ( hibyte ) ; bufindex ++ ; if ( hibyte == _num ) { bytesout . write ( hibyte ) ; } } } else if ( lobyte == _num ) { if ( bufindex < ( byteslen - _num ) ) { int hibyte = origbytes [ bufindex + _num ] ; if ( hibyte < _num ) { hibyte += _num ; } if ( hibyte == _num ) { bytesout . write ( _num ) ; bytesout . write ( _num ) ; bufindex ++ ; } } } bufindex ++ ; } if ( bufindex >= byteslen ) { break ; } strindex ++ ; } return bytesout . tobytearray ( ) ; }	unfortunately , sjis has 0x5c as a high byte in some of its double - byte characters , so we need to escape it .
private static stringbuilder dump ( stringbuilder _lbuffer , long value ) { for ( int j = _num ; j < _num ; j ++ ) { _lbuffer . append ( chars [ ( int ) ( value > > shifts [ j ] ) & _num ] ) ; } return _lbuffer ; }	dump a long value into a stringbuilder .
public unionmemberdescriptionwitherror ( ieobjectdescription delegate , composedtyperef composedtyperef , iscope [ ] subscopes , boolean writeaccess ) { super ( delegate ) ; this . composedtyperef = composedtyperef ; this . subscopes = subscopes ; max = subscopes . length ; this . writeaccess = writeaccess ; }	creates a new instance of this wrapping description .
private void readobject ( objectinputstream oos ) throws ioexception , classnotfoundexception { iinstant = ( datemidnight ) oos . readobject ( ) ; datetimefieldtype type = ( datetimefieldtype ) oos . readobject ( ) ; ifield = type . getfield ( iinstant . getchronology ( ) ) ; }	reads the property from a safe serialization format .
public void generatelootchest ( world world , random random , blockpos pos , int min , int max , iblockstate state , resourcelocation loottable ) { world . setblockstate ( pos , state , _num ) ; tileentitychest chest = ( tileentitychest ) world . gettileentity ( pos ) ; if ( chest != null ) chest . setloottable ( loottable , random . nextlong ( ) ) ; }	generates a loot chest at a location.
private void drawautohit ( graphics g , coords hex ) { int basex = ( hex . getx ( ) * ( hexside [ zoom ] + hexsidebysin30 [ zoom ] ) ) + leftmargin + hexside [ zoom ] ; int basey = ( ( ( _num * hex . gety ( ) ) + _num + ( hex . getx ( ) % _num ) ) * hexsidebycos30 [ zoom ] ) + topmargin ; color alt = g . getcolor ( ) ; g . setcolor ( color . red ) ; g . drawoval ( basex - ( unitsize - _num ) , basey - ( unitsize - _num ) , ( _num * unitsize ) - _num , ( _num * unitsize ) - _num ) ; g . drawline ( basex - unitsize - _num , basey , ( basex - unitsize ) + _num , basey ) ; g . drawline ( basex + unitsize + _num , basey , ( basex + unitsize ) - _num , basey ) ; g . drawline ( basex , basey - unitsize - _num , basex , ( basey - unitsize ) + _num ) ; g . drawline ( basex , basey + unitsize + _num , basex , ( basey + unitsize ) - _num ) ; g . setcolor ( alt ) ; }	draws a red crosshair for artillery autohit hexes ( predesignated only ) .
public void remove ( ) throws recurrenceruleexception { try { rule . remove ( ) ; } catch ( genericentityexception e ) { throw new recurrenceruleexception ( e . getmessage ( ) , e ) ; } }	removes this rule from the persistant store .
private boolean shouldbeescaped ( char c ) { return c < _str || ( c >= _str && c < _str ) || ( c >= _str && c < _str ) ; }	json . org spec says that all control characters must be escaped .
public ceventtablemenu ( final jtable table , final list < itraceevent > traces ) { addopenfunction ( swingutilities . getwindowancestor ( table ) , traces ) ; add ( new jmenuitem ( cactionproxy . proxy ( new csearchtableaction ( swingutilities . getwindowancestor ( table ) , table ) ) ) ) ; add ( new copyselectionaction ( table ) ) ; }	creates a new menu object .
@ override public int available ( ) throws ioexception { return ( outbytes_ . length + inputstream_ . available ( ) ) ; }	returns metadata associated with the performed cryptographic operation .
public void addbugpattern ( bugpattern bugpattern ) { bugpatterns . add ( bugpattern ) ; }	add a bugpattern reported by the plugin .
public spidergitparser ( spiderparam params ) { super ( ) ; this . params = params ; }	instantiates a new spider git index parser .
public void onretry ( int retryno ) { log . d ( log_tag , string . format ( _str , retryno ) ) ; }	fired when a retry occurs , override to handle in your own code.
protected void analyzedtosettermethod ( method method , methodmodel methodmodel ) { methodmodel . setsetter ( _bool ) ; type fieldtype = method . getgenericparametertypes ( ) [ _num ] ; string fieldname = getsetterfieldname ( method ) ; fieldattributes . put ( fieldname , fieldtype ) ; methodmodel . setfieldname ( fieldname ) ; methodmodel . setfieldtype ( converttype ( fieldtype ) ) ; }	populate model from given reflect setter method.
public static string loadlastcolor ( context context ) { try { sharedpreferences sharedpreferences = context . getsharedpreferences ( _str , context . mode_private ) ; string s = sharedpreferences . getstring ( sp_key_last_color , null ) ; color . parsecolor ( s ) ; return s ; } catch ( exception e ) { e . printstacktrace ( ) ; return null ; } }	gets the color stored in shared preferences as the last picked color or null if it doesn ' t exist.
public bevelborder ( int beveltype , color highlight , color shadow ) { this ( beveltype , highlight . brighter ( ) , highlight , shadow , shadow . brighter ( ) ) ; }	creates a bevel border with the specified type , highlight and shadow colors .
protected final void refreshsessionlayer ( final location location ) { if ( ! mrefreshsessionpending && isvisible ( ) ) { log . d ( tag , _str ) ; mrefreshsessionpending = _bool ; triggersessionobjectsupdate ( null ) ; sessionobjectsrefreshtime = system . currenttimemillis ( ) ; sessionobjectsrefreshedat = location ; } else if ( ! isvisible ( ) ) { log . v ( tag , _str ) ; } else { log . v ( tag , _str ) ; } }	refreshes reference and session layer.
public static int mdategap ( string dayname ) { log . d ( _str , dayname ) ; if ( dayname . equals ( _str ) ) { return _num ; } else if ( dayname . equals ( _str ) ) { return _num ; } else if ( dayname . equals ( _str ) ) { return _num ; } else if ( dayname . equals ( _str ) ) { return _num ; } else if ( dayname . equals ( _str ) ) { return _num ; } else if ( dayname . equals ( _str ) ) { return _num ; } else { return _num ; } }	get the day difference in the selected day and the first day in the week.
public static string removeadditionalparty ( httpservletrequest request , httpservletresponse response ) { shoppingcart cart = getcartobject ( request ) ; string partyid = request . getparameter ( _str ) ; string roletypeid [ ] = request . getparametervalues ( _str ) ; list < string > eventlist = new linkedlist < string > ( ) ; locale locale = utilhttp . getlocale ( request ) ; int i ; if ( utilvalidate . isempty ( partyid ) || roletypeid . length < _num ) { request . setattribute ( _str , utilproperties . getmessage ( resource_error , _str , locale ) ) ; return _str ; } if ( request . getattribute ( _str ) != null ) { list < string > msg = utilgenerics . checklist ( request . getattribute ( _str ) ) ; eventlist . addall ( msg ) ; } for ( i = _num ; i < roletypeid . length ; i ++ ) { try { cart . removeadditionalpartyrole ( partyid , roletypeid [ i ] ) ; } catch ( exception e ) { debug . loginfo ( e . getlocalizedmessage ( ) , module ) ; eventlist . add ( e . getlocalizedmessage ( ) ) ; } } request . removeattribute ( _str ) ; request . setattribute ( _str , eventlist ) ; return _str ; }	removes a previously associated party to order.
public map < string , string [ ] > crop ( final map < string , string [ ] > original ) { map < string , string [ ] > result = new hashmap < string , string [ ] > ( original . size ( ) ) ; for ( map . entry < string , string [ ] > entry : original . entryset ( ) ) { string key = entry . getkey ( ) ; if ( null == key ) { continue ; } string [ ] value = entry . getvalue ( ) ; string [ ] convertedvalue ; if ( null == value ) { convertedvalue = new string [ _num ] ; convertedvalue [ _num ] = _str ; } else { boolean croppingwasneeded = _bool ; convertedvalue = value ; for ( int i = _num , l = value . length ; i < l ; i ++ ) { string curvalue = value [ i ] ; string croppingresult = crop ( curvalue ) ; if ( ( curvalue != croppingresult ) & ! croppingwasneeded ) { croppingwasneeded = _bool ; convertedvalue = new string [ value . length ] ; system . arraycopy ( value , _num , convertedvalue , _num , i ) ; convertedvalue [ i ] = croppingresult ; } if ( croppingwasneeded ) { convertedvalue [ i ] = croppingresult ; } } } result . put ( key , convertedvalue ) ; } return result ; }	analyzes the given map and tries to re - use the values in string arrays and the string arrays themself to converse memory.
@ override int lookforselectableposition ( int position , boolean lookdown ) { final listadapter adapter = madapter ; if ( adapter == null || isintouchmode ( ) ) { return invalid_position ; } final int count = adapter . getcount ( ) ; if ( ! mareallitemsselectable ) { if ( lookdown ) { position = math . max ( _num , position ) ; while ( position < count && ! adapter . isenabled ( position ) ) { position ++ ; } } else { position = math . min ( position , count - _num ) ; while ( position >= _num && ! adapter . isenabled ( position ) ) { position -- ; } } if ( position < _num || position >= count ) { return invalid_position ; } return position ; } else { if ( position < _num || position >= count ) { return invalid_position ; } return position ; } }	find a position that can be selected ( i.
public void populatebottomtabitems ( @ nonnull bottomtabsbuilder builder ) { if ( mcontainer . getchildcount ( ) >= min_bottom_navigation_items ) { checkbottomitemguidelines ( mcontainer . getchildcount ( ) ) ; } list < bottomnavigationitem > build = builder . build ( ) ; for ( int i = _num ; i < build . size ( ) ; i ++ ) { bottomnavigationitem item = build . get ( i ) ; item . setposition ( i ) ; addbottomnavigationitem ( item ) ; } updatebottomnavviews ( ) ; selecttabview ( ) ; }	convinient way to populate bottom navigation layout using bottomtabsbuilder.
public final int skipbytes ( int count ) throws java . io . ioexception { int skipped = _num ; long skip ; while ( skipped < count && ( skip = in . skip ( count - skipped ) ) != _num ) { skipped += skip ; } return skipped ; }	see the general contract of the skipbytes method of datainput.
public generalandersondarlingtest ( list < double > data , realdistribution dist ) { if ( dist == null ) { throw new nullpointerexception ( ) ; } this . dist = dist ; collections . sort ( data ) ; this . data = data ; runtest ( ) ; }	constructs an anderson - darling test for the given column of data .
private final void insert ( object text ) { buf . insert ( buf . length ( ) - _num , _str ) ; buf . insert ( buf . length ( ) - _num , text ) ; }	splices additional information for a node into the buffer .
public static void splittextures ( file destination , file texturepack , double scale , boolean alphas , progresscallback progress ) throws exception { if ( destination == null ) throw new illegalargumentexception ( _str ) ; log . info ( _str + destination + _str ) ; if ( ! destination . exists ( ) || ! destination . isdirectory ( ) ) { if ( destination . exists ( ) ) throw new runtimeexception ( _str ) ; if ( ! destination . mkdir ( ) ) throw new runtimeexception ( _str ) ; } gettextures ( texturepack , scale , progress , alphas , _bool , destination ) ; }	reads a minecraft texture pack and splits the individual block textures into.
public void testbuilder_rootonconstruct_multipleappends ( ) { sqlexception root = new sqlexception ( ) ; list < sqlexception > additionalexceptions = new arraylist < sqlexception > ( ) ; for ( int count = _num ; count <= _num ; count ++ ) { additionalexceptions . add ( new sqlexception ( integer . tostring ( count ) ) ) ; } sqlexceptionchainbuilder < sqlexception > builder = new sqlexceptionchainbuilder < sqlexception > ( root ) ; for ( sqlexception ex : additionalexceptions ) { builder . append ( ex ) ; } asserttrue ( _str , builder . hasexception ( ) ) ; sqlexception resultexception = builder . getexception ( ) ; assertsame ( _str , root , resultexception ) ; checkexceptionchain ( resultexception , additionalexceptions ) ; }	test for sqlexceptionchainbuilder constructed with a root sqlexception and multiple appends .
protected synchronized string nextcnxkey ( ) { if ( connectionscounter == integer . max_value ) connectionscounter = _num ; connectionscounter ++ ; int randlong = random . nextint ( integer . max_value ) ; return connectionscounter + ( randlong + _str + id_suffix ) ; }	according to the m_connfactorytype we decide what would be the connection key prefix.
public static boolean copyfilesafe ( final path srcfile , final path destfile ) throws ioexception { return copyfilesafe ( srcfile , destfile , _bool ) ; }	copy a file , preserving the attributes , but not overwrite it.
public static boolean isheader ( header header ) { string xten = header . getstringvalue ( xtension ) ; if ( xten == null ) { return _bool ; } xten = xten . trim ( ) ; return xten . equals ( xtension_bintable ) || xten . equals ( _str ) ; }	check that this is a valid binary table header .
final void putfloat ( int offset , float value ) { unsafe . putfloat ( offset + address , value ) ; }	writes a float at the specified offset from this native object ' s base address .
public void doctypedecl ( string rootelement , string publicid , string systemid , augmentations augs ) throws xniexception { findtd = _bool ; try { if ( flexicalhandler != null ) { flexicalhandler . startdtd ( rootelement , publicid , systemid ) ; } } catch ( saxexception e ) { throw new xniexception ( e ) ; } if ( fdeclhandler != null ) { fdeclaredattrs = new symbolhash ( ) ; } }	notifies of the presence of the doctype line in the document .
@ visiblefortesting static omaentry parseomaentry ( string entry ) { int index = entry . indexof ( _str ) ; long downloadid = long . parselong ( entry . substring ( _num , index ) ) ; return new omaentry ( downloadid , entry . substring ( index + _num ) ) ; }	parse oma entry from the sharedprefs string todo ( qinmin ) : use a file instead of sharedprefs to store the oma entry .
public void parse ( ) throws ioexception { long length = _num ; try { length = file . length ( ) ; } catch ( ioexception e ) { throw new ioexception ( _str ) ; } try { parse ( _str , length ) ; } catch ( ioexception e ) { throw new ioexception ( _str ) ; } }	parses the mp4 file .
public void test_selectunionitself ( ) throws sqlexception { string sql = _str + _str + databasecreator . customers_table + _str + databasecreator . customers_table + _str + _str + _str ; resultset result = statement . executequery ( sql ) ; hashmap < integer , string > value = new hashmap < integer , string > ( ) ; value . put ( _num , _str ) ; value . put ( _num , _str ) ; value . put ( _num , _str ) ; while ( result . next ( ) ) { int key = result . getint ( _str ) ; string val = result . getstring ( _str ) ; asserttrue ( _str , value . containskey ( key ) ) ; assertequals ( _str , value . get ( key ) , val ) ; value . remove ( key ) ; } asserttrue ( _str , value . isempty ( ) ) ; result . close ( ) ; }	selectfunctionalitytest # test_selectthreetables ( ) . selects records from a table using union.
public cfunctiontypepanel ( final listenerprovider < ifilterdialoglistener > listeners ) { super ( new borderlayout ( ) ) ; m_listeners = listeners ; final jpanel innerpanel = new jpanel ( new gridlayout ( _num , _num ) ) ; innerpanel . add ( buildrow ( _str , m_normalfunctioncheckbox ) ) ; innerpanel . add ( buildrow ( _str , m_importedfunctioncheckbox ) ) ; innerpanel . add ( buildrow ( _str , m_libraryfunctioncheckbox ) ) ; innerpanel . add ( buildrow ( _str , m_thunkfunctioncheckbox ) ) ; innerpanel . add ( buildrow ( _str , m_adjustorfunctioncheckbox ) ) ; add ( innerpanel , borderlayout . north ) ; setborder ( new titledborder ( _str ) ) ; }	creates a new function type panel object .
public dragcontext ( node draggable ) { this . node = draggable ; this . gotoforegroundoncontact = _bool ; this . touchid = null_id ; this . activated = _bool ; this . draglimits = new boundingbox ( _num , _num , integer . max_value , integer . max_value ) ; this . dragthreshold = _num ; this . dragstarted = _bool ; this . relocatethreshold = _num ; this . draginitaction = null ; this . dragfinishaction = null ; touchhandler = null ; mousehandler = null ; draggable . addeventhandler ( touchevent . any , touchhandler ) ; draggable . addeventhandler ( mouseevent . any , mousehandler ) ; }	creates a dragcontext keeping track of touch events , so that a node is made draggable .
protected x509certificate [ ] opencertificate ( file certificatefile ) { try { fileinputstream is = new fileinputstream ( certificatefile ) ; return opencertificate ( is , certificatefile . getname ( ) ) ; } catch ( filenotfoundexception ex ) { joptionpane . showmessagedialog ( frame , messageformat . format ( res . getstring ( _str ) , certificatefile ) , res . getstring ( _str ) , joptionpane . warning_message ) ; return null ; } }	open a certificate file .
public shapetilesimplex ( plalineintalist p_line_alist ) { lines_list = new arraylist < plalineint > ( p_line_alist . size ( ) ) ; for ( plalineint a_line : p_line_alist ) lines_list . add ( a_line ) ; collections . sort ( lines_list ) ; }	to be used when you know that the lines are surely ok example , when creating a new object from a mirros or rotate operation.
public properfractionformat ( numberformat format ) { this ( format , ( numberformat ) format . clone ( ) , ( numberformat ) format . clone ( ) ) ; }	create a proper formatting instance with a custom number format for the whole , numerator , and denominator .
private file createcapturefile ( int encodingtype ) { return createcapturefile ( encodingtype , _str ) ; }	create a file in the applications temporary directory based upon the supplied encoding .
public double [ ] [ ] extractmainsetjacobian ( final odestate state ) { final double [ ] p = state . getsecondarystate ( index ) ; final double [ ] [ ] dydy0 = new double [ jode . getdimension ( ) ] [ jode . getdimension ( ) ] ; int j = _num ; for ( int i = _num ; i < jode . getdimension ( ) ; i ++ ) { system . arraycopy ( p , j , dydy0 [ i ] , _num , jode . getdimension ( ) ) ; j += jode . getdimension ( ) ; } return dydy0 ; }	extract the jacobian matrix with respect to state .
public static string bytetohexstring ( byte [ ] bytearray ) { stringbuilder builder = new stringbuilder ( ) ; for ( int i = _num ; i < bytearray . length ; i ++ ) { int bytecode = bytearray [ i ] & _num ; if ( bytecode < _num ) { builder . append ( _num ) ; } builder . append ( integer . tohexstring ( bytecode ) ) ; } return builder . tostring ( ) ; }	byte to hex string.
public static void assertnotequal ( object expected , object actual ) { if ( verbose ) { log ( _str + expected + _str + actual + _str ) ; } testutils . assertbool ( ! expected . equals ( actual ) ) ; }	asserts that the given objects are not equal using the first object ' s . equal ( ) method.
private boolean isempty ( string value ) { return value . length ( ) == _num ; }	this method is used to determine if a root annotation value is an empty value.
public static objectstreamclass lookupany ( class < ? > cl ) { return lookupstreamclass ( cl ) ; }	returns the descriptor for any class , whether or not the class implements serializable or externalizable .
public static void main ( string [ ] args ) { try { int serverport = integer . parseint ( system . getproperty ( _str , _str ) ) ; ttransport transport ; transport = new tframedtransport ( new tsocket ( _str , serverport ) ) ; transport . open ( ) ; tprotocol protocol = new tbinaryprotocol ( transport ) ; packetstreamer . client client = new packetstreamer . client ( protocol ) ; sendpackets ( client , ( short ) _num , ofmessagetype . packet_in , _bool ) ; log . debug ( _str ) ; client . terminatesession ( _str ) ; transport . close ( ) ; } catch ( texception x ) { x . printstacktrace ( ) ; } }	main function entry point ;.
public configurationparser ( boolean verify , classloader loader ) throws parserconfigurationexception { factory = documentbuilderfactory . newinstance ( ) ; factory . setvalidating ( verify ) ; factory . setnamespaceaware ( _bool ) ; factory . setexpandentityreferences ( _bool ) ; factory . setcoalescing ( _bool ) ; builder = factory . newdocumentbuilder ( ) ; if ( verify ) builder . seterrorhandler ( new xmlerrorhandler ( ) ) ; if ( loader == null ) throw new nullpointerexception ( _str ) ; }	create a new configurationparser.
testenvironment ( systemtestenvironment systemtestenvironment , path workingdir , path sourcedir , path classdir , path jacocodir ) { this . systemtestenvironment = systemtestenvironment ; this . workingdir = workingdir ; this . sourcedir = sourcedir ; this . classdir = classdir ; this . jacocodir = jacocodir ; this . testclasspath = systemtestenvironment . classpath + _str + classdir . tostring ( ) ; }	creates a test environment for a specific system test method .
public application createjmxapplicationinteractive ( string connectionstring , string displayname , environmentprovider provider , boolean persistent ) { return createjmxapplicationinteractive ( connectionstring , displayname , provider , persistent , _bool ) ; }	creates new application defined by jmx connection and adds it to the applications tree.
public object referenceinsert ( string reference , object value ) { string s = null ; if ( value != null ) { s = reference_value ; } else { if ( reference . equals ( _str ) ) { s = no_reference_value ; } } return s ; }	event handler for when a reference is inserted into the output stream .
public graphiccomponent ( graphicattribute graphic , decoration decorator , int [ ] charsltov , byte [ ] levels , int start , int limit , affinetransform basetx ) { if ( limit <= start ) { throw new illegalargumentexception ( _str ) ; } this . graphic = graphic ; this . graphicadvance = graphic . getadvance ( ) ; this . decorator = decorator ; this . cm = createcoremetrics ( graphic ) ; this . basetx = basetx ; initlocalordering ( charsltov , levels , start , limit ) ; }	create a new graphiccomponent.
public static boolean hasvaliduserincontext ( securitycontext securitycontext ) { if ( ( securitycontext != null ) && ( securitycontext . getuserprincipal ( ) instanceof storageosuser ) ) { return _bool ; } else { return _bool ; } }	determine if the security context has a valid storageosuser object .
private void handleendofstream ( state state , innerstate innerstate ) throws stoprequest { minfo . mcurrentbytes = innerstate . mbytessofar ; mdb . updatedownload ( minfo ) ; boolean lengthmismatched = ( innerstate . mheadercontentlength != null ) && ( innerstate . mbytessofar != integer . parseint ( innerstate . mheadercontentlength ) ) ; if ( lengthmismatched ) { if ( cannotresume ( innerstate ) ) { throw new stoprequest ( downloaderservice . status_cannot_resume , _str ) ; } else { throw new stoprequest ( getfinalstatusforhttperror ( state ) , _str ) ; } } }	called when we ' ve reached the end of the http response stream , to update the database and check for consistency .
public string tostring ( ) { return m_formatter . format ( getstamp ( ) ) ; }	returns the timestamp as string in the specified format.
private string secondstotime ( int seconds ) { string time = _str ; string minutestext = string . valueof ( seconds / _num ) ; if ( minutestext . length ( ) == _num ) minutestext = _str + minutestext ; string secondstext = string . valueof ( seconds % _num ) ; if ( secondstext . length ( ) == _num ) secondstext = _str + secondstext ; time = minutestext + _str + secondstext ; return time ; }	convert seconds to time.
private void processnewport ( datapathid sw , ofport p ) { if ( islinkdiscoverysuppressed ( sw , p ) ) { return ; } iofswitch iofswitch = switchservice . getswitch ( sw ) ; if ( iofswitch == null ) { return ; } nodeporttuple npt = new nodeporttuple ( sw , p ) ; discover ( sw , p ) ; addtoquarantinequeue ( npt ) ; }	process a new port.
public amqpreceiver ( amqpsession session , string address , string receiverid ) { if ( address != null && address . isempty ( ) ) { throw new illegalargumentexception ( _str ) ; } this . userspecifiedsource = null ; this . session = session ; this . address = address ; this . receiverid = receiverid ; }	create a new receiver instance .
@ knownfailure ( _str ) public void test_getcolumnstablewithnocatalogschema ( ) throws sqlexception { try { resultset noschematable = meta . getcolumns ( _str , _str , databasecreator . test_table1 , _str ) ; assertnotnull ( noschematable ) ; noschematable . last ( ) ; int size = noschematable . getrow ( ) ; assertequals ( _str , _num , size ) ; } catch ( sqlexception e ) { fail ( _str + e . getmessage ( ) ) ; } try { resultset noschematable = meta . getcolumns ( _str , _str , databasecreator . test_table1 , _str ) ; assertnotnull ( noschematable ) ; noschematable . last ( ) ; int size = noschematable . getrow ( ) ; assertequals ( _str , _num , size ) ; } catch ( sqlexception e ) { fail ( _str + e . getmessage ( ) ) ; } try { resultset noschematable = meta . getcolumns ( _str , _str , _str , _str ) ; assertnotnull ( noschematable ) ; noschematable . last ( ) ; int size = noschematable . getrow ( ) ; assertequals ( _str , _num , size ) ; } catch ( sqlexception e ) { fail ( _str + e . getmessage ( ) ) ; } conn . close ( ) ; try { meta . getcolumns ( null , null , databasecreator . test_table1 , _str ) ; fail ( _str ) ; } catch ( sqlexception e ) { } }	java . sql . databasemetadata # getcolumns ( java . lang . string , java . lang . string , java . lang . string , java . lang . string ).
public static byte readbyte ( ) { return scanner . nextbyte ( ) ; }	reads the next token from standard input , parses it as a byte , and returns the byte .
public void clearvaluelocal ( string columnheader ) { values . remove ( columnheader . tolowercase ( ) ) ; }	locally clears the particular value.
public list closebucketadvisors ( ) { list primariesheld = collections . empty_list ; if ( this . buckets != null ) { for ( int i = _num ; i < this . buckets . length ; i ++ ) { proxybucketregion pbr = this . buckets [ i ] ; if ( pbr . isprimary ( ) ) { if ( primariesheld == collections . empty_list ) { primariesheld = new arraylist ( ) ; } primariesheld . add ( integer . valueof ( i ) ) ; } pbr . close ( ) ; } } return primariesheld ; }	close the bucket advisors , releasing any locks for primary buckets.
public boolean ismacmuted ( final string mac ) { final long mutetill = getmacunmutetime ( mac ) ; return mutetill > system . currenttimemillis ( ) ; }	is the given mac muted ? this may have the side effect of removing from the database any mac ' s whose mute has expired.
public abstract void insertspillbefore ( instruction s , register r , byte type , int location ) ;	insert a spill of a physical register before instruction s .
static public test suite ( ) { return proxysuitehelper . suitewhenstandalone ( testsparqlupdate . class , _str , new linkedhashset < buffermode > ( arrays . aslist ( new buffermode [ ] { buffermode . transient , buffermode . diskworm , buffermode . memstore , buffermode . diskrw } ) ) , testmode . quads ) ; }	we need to be running this test suite for each of the buffermodes that we want to support.
private synchronized void cleanupiscomplextypeattribute ( ) { firstattribute = null ; remainingattributes . clear ( ) ; iscomplextypeattribute = _bool ; }	cleanup the " is complex type attribute " info .
public static string lefttrim ( final string value ) { validate ( value , null_string_predicate , null_string_msg_supplier ) ; return value . replaceall ( _str , _str ) ; }	removes all spaces on left.
public float polarangle ( ) { return ( float ) math . todegrees ( angle ( ) ) ; }	angle of this sample in degrees.
public string checkparamsnonnegative ( ) { string ret = _str ; if ( param1 < _num ) { ret = ret . concat ( pdf . getparam1name ( ) + _str ) ; } if ( param2 < _num ) { ret = ret . concat ( pdf . getparam2name ( ) + _str ) ; } if ( upperbound < _num ) { ret = ret . concat ( _str ) ; } if ( lowerbound < _num ) { ret = ret . concat ( _str ) ; } return ret ; }	checks to make sure that there are no negative parameters .
public static boolean validate ( string str , string regex , debug tmpdebug ) { debug = tmpdebug ; if ( str == null || str . length ( ) == _num ) { debug . message ( _str ) ; return _bool ; } char [ ] value = str . tochararray ( ) ; int count = value . length ; set hset = new hashset ( ) ; stringtokenizer st = new stringtokenizer ( regex , seperator ) ; while ( st . hasmoretokens ( ) ) { hset . add ( st . nexttoken ( ) ) ; } iterator itr = hset . iterator ( ) ; while ( itr . hasnext ( ) ) { string obj = ( string ) itr . next ( ) ; if ( process ( value , obj , _num , count ) > - _num ) { debug . message ( _str ) ; return _bool ; } } return _bool ; }	checks for invalid characters in the source string .
public static float turbulence2 ( float x , float y , float octaves ) { float t = _num ; for ( float f = _num ; f <= octaves ; f *= _num ) t += math . abs ( noise2 ( f * x , f * y ) ) / f ; return t ; }	compute turbulence using perlin noise .
public void addmapobject ( internalmapobject mapobject ) { mapobjects . add ( mapobject ) ; }	adds a map object to this map layer .
public list < mockresponse > enqueue ( string ... paths ) { if ( paths == null ) { return null ; } list < mockresponse > mockresponselist = new arraylist < > ( ) ; for ( string path : paths ) { fixture fixture = fixture . parsefrom ( path , parser ) ; mockresponse mockresponse = new mockresponse ( ) ; if ( fixture . statuscode != _num ) { mockresponse . setresponsecode ( fixture . statuscode ) ; } if ( fixture . body != null ) { mockresponse . setbody ( fixture . body ) ; } if ( fixture . delay != _num ) { mockwebserver . setdispatcher ( new delayeddispatcher ( fixture . delay , timeunit . milliseconds ) ) ; } if ( fixture . headers != null ) { for ( string header : fixture . headers ) { mockresponse . addheader ( header ) ; } } mockwebserver . enqueue ( mockresponse ) ; mockresponselist . add ( mockresponse ) ; } return mockresponselist ; }	given paths will be parsed to fixtures and added to the queue . can be multiple.
@ override public void endofstream ( ) throws adeexception { double minprob = _num ; if ( m_totalintervalcount == _num ) { m_totalintervalcount = _num ; } for ( entry < string , bernoulliscore . msgdata > entry : m_msgdata . entryset ( ) ) { final fullbernoullimsgdata data = ( fullbernoullimsgdata ) entry . getvalue ( ) ; data . m_prob = ( ( double ) data . m_count + _num ) / ( m_totalintervalcount + _num ) ; if ( data . m_prob < _num || data . m_prob >= _num ) { logger . info ( entry . getkey ( ) + _str + data . m_prob + _str + data . m_count + _str + m_totalintervalcount + _str ) ; } if ( data . m_prob < minprob ) { minprob = data . m_prob ; } data . m_outofclusterprob = ( ( double ) data . m_outofclustercount + _num ) / ( m_totalintervalcount + _num ) ; if ( data . m_outofclustercount < minprob && data . m_outofclustercount > _num ) { minprob = data . m_outofclustercount ; } } for ( bernoulliscore . msgdata datasuper : m_msgdata . values ( ) ) { final fullbernoullimsgdata data = ( fullbernoullimsgdata ) datasuper ; final double probability = data . m_prob ; data . m_score = - math . log ( probability ) ; if ( data . m_score > _num ) { data . m_score = _num ; } final double outofcontextprobability = data . m_outofclusterprob ; data . m_outofcontextscore = - math . log ( outofcontextprobability ) ; if ( data . m_outofcontextscore > _num ) { data . m_outofcontextscore = _num ; } } m_trained = _bool ; }	calculate the probabilities and scores for each message ' s data after going through all the analyzed intervals.
public boolean hasnextkeytyped ( ) { synchronized ( keylock ) { return ! keystyped . isempty ( ) ; } }	returns true if the user has typed a key .
public void addoperator ( variation operator ) { operators . add ( operator ) ; }	adds an operator to be used in the auto - adaptive multi - method recombination .
public r paramstomultipartentity ( boolean isrepeatable ) { try { mhttpentity = createmultipartentity ( isrepeatable ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return ( r ) this ; }	convert params to multipart entity .
private static int parseint ( string value , int beginindex , int endindex ) throws numberformatexception { if ( beginindex < _num || endindex > value . length ( ) || beginindex > endindex ) { throw new numberformatexception ( value ) ; } int i = beginindex ; int result = _num ; int digit ; if ( i < endindex ) { digit = character . digit ( value . charat ( i ++ ) , _num ) ; if ( digit < _num ) { throw new numberformatexception ( _str + value . substring ( beginindex , endindex ) ) ; } result = - digit ; } while ( i < endindex ) { digit = character . digit ( value . charat ( i ++ ) , _num ) ; if ( digit < _num ) { throw new numberformatexception ( _str + value . substring ( beginindex , endindex ) ) ; } result *= _num ; result -= digit ; } return - result ; }	parse an integer located between 2 given offsets in a string.
public boolean isalertdefinitioncreated ( statalertdefinition alertdefinition ) { synchronized ( alert_definitions ) { return alert_definitions . containskey ( integer . valueof ( alertdefinition . getid ( ) ) ) ; } }	convenience method to check whether an alert definition is created .
public static double logpoissonpdfm1 ( double x_plus_1 , double lambda ) { if ( double . isinfinite ( lambda ) ) { return double . negative_infinity ; } if ( x_plus_1 > _num ) { return rawlogprobability ( x_plus_1 - _num , lambda ) ; } if ( lambda > math . abs ( x_plus_1 - _num ) * mathutil . log2 * double . max_exponent / _num ) { return - lambda - gammadistribution . loggamma ( x_plus_1 ) ; } else { return rawlogprobability ( x_plus_1 , lambda ) + math . log ( x_plus_1 / lambda ) ; } }	compute the poisson distribution pdf with an offset of + 1 log pdf ( x_plus_1 - 1 , lambda ).
public void checkandnotify ( ) { for ( filealterationlistener listener : listeners ) { listener . onstart ( this ) ; } file rootfile = rootentry . getfile ( ) ; if ( rootfile . exists ( ) ) { checkandnotify ( rootentry , rootentry . getchildren ( ) , listfiles ( rootfile ) ) ; } else if ( rootentry . isexists ( ) ) { checkandnotify ( rootentry , rootentry . getchildren ( ) , fileutils . empty_file_array ) ; } else { } for ( filealterationlistener listener : listeners ) { listener . onstop ( this ) ; } }	check whether the file and its chlidren have been created , modified or deleted .
private double allowableerror ( int rank ) { int size = samples . size ( ) ; final double error = calculateerror ( rank , size ) ; final double minerror = size + _num ; if ( error < minerror ) { return error ; } return minerror ; }	specifies the allowable error for this rank , depending on which quantiles are being targeted.
public retrypolicy withmaxduration ( long maxduration , timeunit timeunit ) { assert . notnull ( timeunit , _str ) ; assert . state ( timeunit . tonanos ( maxduration ) > delay . tonanos ( ) , _str ) ; this . maxduration = new duration ( maxduration , timeunit ) ; return this ; }	sets the max duration to perform retries for , else the execution will be failed .
private static final void cleanupnamespacenodes ( zookeeper zkc , string root , string selfbrokerurl ) throws exception { for ( string node : zkc . getchildren ( root , _bool ) ) { string currentpath = root + _str + node ; list < string > children = zkc . getchildren ( currentpath , _bool ) ; if ( children . size ( ) == _num ) { cleanupsinglenamespacenode ( zkc , currentpath , selfbrokerurl ) ; } else { cleanupnamespacenodes ( zkc , currentpath , selfbrokerurl ) ; } } }	cleanupnamespacenodes is only called when the namespaceservice is initialized.
string validatelogixreference ( string name ) { logix l = null ; if ( name != null ) { if ( name . length ( ) > _num ) { l = _logixmanager . getbyusername ( name ) ; if ( l != null ) { return name ; } } l = _logixmanager . getbysystemname ( name ) ; } if ( l == null ) { messageinvalidactionitemname ( name , _str ) ; return null ; } return name ; }	checks logix reference of text .
protected void clearmenuselection ( ) { popupmenugroup . clearselection ( ) ; updateselectionstatus ( ) ; }	clears the selection of the button and also the toggle button .
public double distance ( latlng ll ) { double er = _num ; double latfrom = math . toradians ( getlat ( ) ) ; double latto = math . toradians ( ll . getlat ( ) ) ; double lngfrom = math . toradians ( getlng ( ) ) ; double lngto = math . toradians ( ll . getlng ( ) ) ; double d = math . acos ( math . sin ( latfrom ) * math . sin ( latto ) + math . cos ( latfrom ) * math . cos ( latto ) * math . cos ( lngto - lngfrom ) ) * er ; return d ; }	calculate the surface distance in kilometres from the this latlng to the given latlng .
public static string encode ( string encode ) { stringbuilder str = new stringbuilder ( encode ) ; string key ; int i = _num ; while ( i < str . length ( ) ) { key = findvalue ( str . charat ( i ) ) ; if ( key != null ) { str . replace ( i , i + _num , key ) ; i += key . length ( ) ; } else { i ++ ; } } return str . tostring ( ) ; }	converts special characters in ascii into html entities ( e.
protected static boolean trytolock ( string servicename ) { distributedlockservice service = distributedlockservice . getservicenamed ( servicename ) ; boolean locked = service . lock ( _str , _num , - _num ) ; if ( locked ) { service . unlock ( _str ) ; } return boolean . valueof ( locked ) ; }	accessed via reflection . do not remove.
public int hashcode ( ) { latlonpoint llp = getlocation ( ) ; int hc1 = float . floattointbits ( llp . getlatitude ( ) ) ; int hc2 = float . floattointbits ( llp . getlongitude ( ) ) ; return hc1 ^ ( hc2 << _num ) ^ ( hc2 > > > _num ) ; }	override hashcode so that two intersections at the same location have the same hashcode .
private xpathfactory loadfromservicesfile ( string uri , string resourcename , inputstream in ) { if ( debug ) debugprintln ( _str + resourcename ) ; bufferedreader rd ; try { rd = new bufferedreader ( new inputstreamreader ( in , _str ) , default_line_length ) ; } catch ( java . io . unsupportedencodingexception e ) { rd = new bufferedreader ( new inputstreamreader ( in ) , default_line_length ) ; } string factoryclassname ; xpathfactory resultfactory = null ; while ( _bool ) { try { factoryclassname = rd . readline ( ) ; } catch ( ioexception x ) { break ; } if ( factoryclassname != null ) { int hashindex = factoryclassname . indexof ( _str ) ; if ( hashindex != - _num ) { factoryclassname = factoryclassname . substring ( _num , hashindex ) ; } factoryclassname = factoryclassname . trim ( ) ; if ( factoryclassname . length ( ) == _num ) { continue ; } try { xpathfactory foundfactory = createinstance ( factoryclassname ) ; if ( foundfactory . isobjectmodelsupported ( uri ) ) { resultfactory = foundfactory ; break ; } } catch ( exception ignored ) { } } else { break ; } } ioutils . closequietly ( rd ) ; return resultfactory ; }	searches for a xpathfactory for a given uri in a meta - inf / services file .
private synchronized void _stop ( ) { while ( m_activities . size ( ) > _num ) { activity a = ( activity ) m_activities . get ( m_activities . size ( ) - _num ) ; a . cancel ( ) ; } _setrunning ( _bool ) ; notify ( ) ; }	stops the activity manager thread.
public void runtest ( ) throws throwable { document doc ; nodelist elementlist ; node namenode ; characterdata child ; string childdata ; int childlength ; java . util . list result = new java . util . arraylist ( ) ; doc = ( document ) load ( _str , _bool ) ; elementlist = doc . getelementsbytagname ( _str ) ; namenode = elementlist . item ( _num ) ; child = ( characterdata ) namenode . getfirstchild ( ) ; child . deletedata ( _num , _num ) ; childdata = child . getdata ( ) ; assertequals ( _str , _str , childdata ) ; childlength = ( int ) child . getlength ( ) ; assertequals ( _str , _num , childlength ) ; }	runs the test case .
public rhythmgroup makegroup ( string title ) { final rhythmgroup group = new rhythmgroup ( ) ; group . mtitle = title ; group . mindex = mrhythmgroups . size ( ) ; group . mcontrol = this ; mrhythmgroups . add ( group ) ; if ( mcurrentnotificationgroupindex == notification_no_groups ) { mcurrentnotificationgroupindex = _num ; requestnotificationupdate ( ) ; } return group ; }	make a new rhythm group , registered in this rhythm control.
public void testmultiplymathcontextdiffscaleposneg ( ) { string a = _str ; int ascale = _num ; string b = _str ; int bscale = - _num ; string c = _str ; int cscale = - _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; mathcontext mc = new mathcontext ( _num , roundingmode . half_up ) ; bigdecimal result = anumber . multiply ( bnumber , mc ) ; assertequals ( _str , c , result . tostring ( ) ) ; assertequals ( _str , cscale , result . scale ( ) ) ; }	multiply two numbers of different scales using mathcontext.
public void writeto ( final outputstream out ) throws ioexception { for ( final block block : blocks ) { out . write ( block . data , _num , block . limit ) ; } }	write the entire buffer to output stream .
public void testmergeoneservletintodocumentwithsameservletandparam ( ) throws exception { string srcxml = _str + _str + _str + _str + _str + _str ; webxml srcwebxml = webxmlio . parsewebxml ( new bytearrayinputstream ( srcxml . getbytes ( _str ) ) , null ) ; string mergexml = _str + _str + _str + _str + _str + _str + _str + _str + _str + _str ; webxml mergewebxml = webxmlio . parsewebxml ( new bytearrayinputstream ( mergexml . getbytes ( _str ) ) , null ) ; webxmlmerger merger = new webxmlmerger ( srcwebxml ) ; merger . merge ( mergewebxml ) ; asserttrue ( webxmlutils . hasservlet ( srcwebxml , _str ) ) ; list < string > initparams = webxmlutils . getservletinitparamnames ( srcwebxml , _str ) ; assertequals ( _num , initparams . size ( ) ) ; assertequals ( _str , initparams . get ( _num ) ) ; assertequals ( _str , webxmlutils . getservletinitparam ( srcwebxml , _str , _str ) ) ; }	tets whether a servlet with an initialization parameter is correctly merged into a descriptor that contains the definition of a servlet with the same name .
public kmp ( string pat ) { this . r = _num ; this . pat = pat ; int m = pat . length ( ) ; dfa = new int [ r ] [ m ] ; dfa [ pat . charat ( _num ) ] [ _num ] = _num ; for ( int x = _num , j = _num ; j < m ; j ++ ) { for ( int c = _num ; c < r ; c ++ ) dfa [ c ] [ j ] = dfa [ c ] [ x ] ; dfa [ pat . charat ( j ) ] [ j ] = j + _num ; x = dfa [ pat . charat ( j ) ] [ x ] ; } }	preprocesses the pattern string .
private void loadconfiguration ( ) { mclientid = mconfigurationmanager . getstring ( pref_client_id , _str ) ; mclientkey = mconfigurationmanager . getstring ( pref_client_key , _str ) ; timber . i ( _str ) ; }	load the configuration of the component .
public static void putbooleanfield ( object obj , long fieldoff , boolean val ) { unsafe . putboolean ( obj , fieldoff , val ) ; }	stores boolean value into object field .
public void sort ( comparator < file > comparator ) { synchronized ( mlock ) { collections . sort ( filelist , comparator ) ; } notifydatasetchanged ( ) ; }	sorts the content of this adapter using the specified comparator .
public acceptrequestinterceptor ( final string accept ) { this . accept = accept ; checkargument ( ! accept . isempty ( ) , _str ) ; }	creates request interceptor which sets the accept header .
public void test_getlowestsetbitneg ( ) { byte abytes [ ] = { - _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = - _num ; int inumber = _num ; biginteger anumber = new biginteger ( asign , abytes ) ; int result = anumber . getlowestsetbit ( ) ; asserttrue ( _str , result == inumber ) ; }	java . math . biginteger # getlowestsetbit ( ) getlowestsetbit for negative biginteger.
private int tailingnonnewline ( string str , int off , int len ) { for ( int cnt = _num ; cnt < len ; cnt ++ ) { final int pos = off + ( len - _num ) - cnt ; if ( str . charat ( pos ) == unix_newline ) { return cnt ; } if ( str . charat ( pos ) == carriage_return ) { return cnt ; } } return len ; }	count the tailing non - newline characters .
@ override public void reset ( ) { _clear ( ) ; bnodes = null ; bnodestotalcount = _num ; bnodesresolvedcount = _num ; deferredstmts = null ; reifiedstmts = null ; if ( queue != null ) { final future < void > ft = this . ft ; if ( ft != null ) { ft . cancel ( _bool ) ; this . ft = null ; } queue . clear ( ) ; } }	clears all buffered data , including the canonicalizing mapping for blank nodes and deferred provenance statements .
public static byte [ ] readdata ( final inputstream input ) throws ioexception { final byte [ ] inputbuffer = new byte [ buffer_length ] ; final bytearrayoutputstream byteoutput = new bytearrayoutputstream ( buffer_length ) ; int bytesread ; while ( ( bytesread = input . read ( inputbuffer ) ) != - _num ) { byteoutput . write ( inputbuffer , _num , bytesread ) ; } final byte [ ] r = byteoutput . tobytearray ( ) ; byteoutput . close ( ) ; return r ; }	reads all the data from the supplied inputstream into a byte array .
@ override public synchronized void println ( ) { print ( _str ) ; }	prints a new line.
public boolean iscrash ( string testpath ) { for ( string prefix : getprefixes ( testpath ) ) { if ( mcrashlist . contains ( prefix ) ) { return _bool ; } } return _bool ; }	checks if test is expected to crash.
public abstractsitemap parsesitemap ( string contenttype , byte [ ] content , url url ) throws unknownformatexception , ioexception { mediatype mediatype = mediatype . parse ( contenttype ) ; while ( mediatype != null && ! mediatype . equals ( mediatype . octet_stream ) ) { if ( xml_media_types . contains ( mediatype ) ) { return processxml ( url , content ) ; } else if ( text_media_types . contains ( mediatype ) ) { return processtext ( url . tostring ( ) , content ) ; } else if ( gz_media_types . contains ( mediatype ) ) { return processgzip ( url , content ) ; } else { mediatype = media_type_registry . getsupertype ( mediatype ) ; return parsesitemap ( mediatype . tostring ( ) , content , url ) ; } } throw new unknownformatexception ( _str + contenttype + _str + url + _str ) ; }	parse a sitemap , given the mime type , the content bytes , and the url.
private void createdefaultmanagedobject ( managedobjectdefinition < ? , ? > d , managedobject < ? > child , defaultmanagedobject < ? , ? > dmo ) { for ( propertydefinition < ? > pd : d . getallpropertydefinitions ( ) ) { setpropertyvalues ( child , pd , dmo ) ; } try { child . commit ( ) ; } catch ( managedobjectalreadyexistsexception e ) { moaee = e ; } catch ( missingmandatorypropertiesexception e ) { mmpe = e ; } catch ( concurrentmodificationexception e ) { cme = e ; } catch ( operationrejectedexception e ) { ore = e ; } catch ( ldapexception e ) { ere = e ; } }	create the child managed object .
static string omitquotesifexist ( string str ) { if ( str == null ) { return null ; } if ( ( ( str . charat ( _num ) == _str ) || ( str . charat ( _num ) == _str ) ) && ( str . length ( ) >= _num ) ) { str = str . substring ( _num , str . length ( ) - _num ) ; } return str ; }	omits quotes of all kinds if they exist in the string.
static void make72safe ( stringbuffer line ) { int length = line . length ( ) ; if ( length > _num ) { int index = _num ; while ( index < length - _num ) { line . insert ( index , _str ) ; index += _num ; length += _num ; } } return ; }	adds line breaks to enforce a maximum 72 bytes per line .
@ override public int last ( ) { characteriterator t = gettext ( ) ; t . setindex ( t . getendindex ( ) ) ; return t . getindex ( ) ; }	sets the current iteration position to the end of the text.
public static void registerprotocol ( final string id , final protocol protocol ) { if ( id == null ) { throw new illegalargumentexception ( _str ) ; } if ( protocol == null ) { throw new illegalargumentexception ( _str ) ; } protocols . put ( id , protocol ) ; }	registers a new protocol with the given identifier.
public static int hash ( string key , int bitsize , string input , string hashtype ) { int bitlimitedhash ; try { messagedigest md = messagedigest . getinstance ( hashtype ) ; byte [ ] array = md . digest ( input . getbytes ( ) ) ; int hashint = frombytearray ( array ) ; bitlimitedhash = hashint ; if ( bitsize < _num ) { bitlimitedhash = ( _num > > > ( _num - bitsize ) ) & hashint ; } logger . debug ( _str + hashint + _str + bitlimitedhash ) ; } catch ( nosuchalgorithmexception e ) { logger . info ( e . tostring ( ) ) ; bitlimitedhash = hash ( key , bitsize , input ) ; } return bitlimitedhash ; }	hash method to optionally specify a hash type other than the default java hashcode ( ) hashtype must be md5 , sha - 1 , or sha - 256.
private offactory computeinitialfactory ( set < ofversion > ofversions ) { if ( ofversions == null || ofversions . isempty ( ) ) { throw new illegalstateexception ( _str ) ; } ofversion highest = null ; for ( ofversion v : ofversions ) { if ( highest == null ) { highest = v ; } else if ( v . compareto ( highest ) > _num ) { highest = v ; } } return offactories . getfactory ( highest ) ; }	find the max version supplied in the supported versions list and use it as the default , which will subsequently be used in our hello message header ' s version field.
public byte [ ] encodeframe ( ) { int length = this . payload . length + framelengthoverhead ; if ( this . payload . length > _num ) { length += _num ; } else if ( this . payload . length >= _num ) { length += _num ; } bytebuffer buffer = bytebuffer . allocate ( length ) ; appendfinandopcode ( buffer , this . opcode , this . fin ) ; byte mask [ ] = generatemaskingkey ( ) ; appendlengthandmask ( buffer , this . payload . length , mask ) ; for ( int i = _num ; i < this . payload . length ; i ++ ) { buffer . put ( ( byte ) ( this . payload [ i ] ^= mask [ i % _num ] ) ) ; } buffer . flip ( ) ; return buffer . array ( ) ; }	encodes the this websocketframe into a byte array .
public static void preloadicon ( context context , componentname componentname , bitmap icon , int dpi ) { try { packagemanager packagemanager = context . getpackagemanager ( ) ; packagemanager . getactivityicon ( componentname ) ; return ; } catch ( packagemanager . namenotfoundexception e ) { } final string key = componentname . flattentostring ( ) ; fileoutputstream resourcefile = null ; try { resourcefile = context . openfileoutput ( getresourcefilename ( componentname ) , context . mode_private ) ; bytearrayoutputstream os = new bytearrayoutputstream ( ) ; if ( icon . compress ( android . graphics . bitmap . compressformat . png , _num , os ) ) { byte [ ] buffer = os . tobytearray ( ) ; resourcefile . write ( buffer , _num , buffer . length ) ; } else { log . w ( tag , _str + key ) ; return ; } } catch ( filenotfoundexception e ) { log . w ( tag , _str + key , e ) ; } catch ( ioexception e ) { log . w ( tag , _str + key , e ) ; } finally { if ( resourcefile != null ) { try { resourcefile . close ( ) ; } catch ( ioexception e ) { log . d ( tag , _str + key , e ) ; } } } }	pre - load an icon into the persistent cache.
public void normalize ( ) { stringbuilder sb = new stringbuilder ( ) ; for ( string v : values ) { sb . append ( v ) ; } values . clear ( ) ; values . add ( sb . tostring ( ) ) ; compacted = _bool ; }	this method convert the list of values again into a only one value.
public void addattribute ( string key , string value ) { extrasessionattributes . put ( key , value ) ; }	adds attribute to the session .
string capitalise ( final string s ) { if ( s . length ( ) == _num ) { return s ; } final stringbuffer s1 = new stringbuffer ( s ) ; if ( character . islowercase ( s1 . charat ( _num ) ) ) { s1 . setcharat ( _num , character . touppercase ( s1 . charat ( _num ) ) ) ; } for ( int j = _num ; j < s1 . length ( ) ; j ++ ) { if ( character . isuppercase ( s1 . charat ( j ) ) ) { s1 . setcharat ( j , character . tolowercase ( s1 . charat ( j ) ) ) ; } } return s1 . tostring ( ) ; }	capitalizes the first letter and lower - cases every consecutive letter.
private geometry unionactual ( geometry g0 , geometry g1 ) { return restricttopolygons ( g0 . union ( g1 ) ) ; }	encapsulates the actual unioning of two polygonal geometries .
public boolean supports ( @ magicconstant ( flagsfromclass = features . class ) int capability ) { iandroidtarget target = gettarget ( ) ; if ( target != null ) { return renderservice . supportscapability ( getmodule ( ) , target , capability ) ; } return _bool ; }	returns true if this configuration supports the given rendering capability.
@ override public void transactionaborted ( ) { if ( listeners . isempty ( ) ) { records . reset ( ) ; } else { records . flush ( ) ; listeners . foreach ( null ) ; } }	notification of transaction aborted .
public standardcrosshairlabelgenerator ( ) { this ( _str , numberformat . getnumberinstance ( ) ) ; }	creates a new instance with default attributes .
private uri createethernetstorageport ( map < string , object > keymap , storageport port , string name , string portinstanceid , list < storageport > newports , list < storageport > existingports ) throws ioexception { storageport portinmemory = ( storageport ) keymap . get ( portinstanceid ) ; if ( null == port ) { portinmemory . setportnetworkid ( name ) ; portinmemory . setportendpointid ( name ) ; string portnativeguid = nativeguidgenerator . generatenativeguid ( _dbclient , portinmemory ) ; portinmemory . setnativeguid ( portnativeguid ) ; portinmemory . setlabel ( portnativeguid ) ; _dbclient . createobject ( portinmemory ) ; newports . add ( portinmemory ) ; return portinmemory . getid ( ) ; } else { port . setportname ( portinmemory . getportname ( ) ) ; port . setportspeed ( portinmemory . getportspeed ( ) ) ; port . setportendpointid ( name ) ; port . setcompatibilitystatus ( portinmemory . getcompatibilitystatus ( ) ) ; port . setdiscoverystatus ( portinmemory . getdiscoverystatus ( ) ) ; port . setoperationalstatus ( portinmemory . getoperationalstatus ( ) ) ; port . setporttype ( portinmemory . getporttype ( ) ) ; _dbclient . persistobject ( port ) ; existingports . add ( port ) ; return port . getid ( ) ; } }	create ethernet storage port.
default int add ( item stack ) { int itemsleft = stack . count ( ) ; for ( int i = _num ; i < size ( ) ; i ++ ) { itemsleft = add ( i , stack . withamount ( itemsleft ) ) ; } if ( itemsleft != stack . count ( ) ) { markchanged ( ) ; } return itemsleft ; }	adds items to this inventory.
public void mark ( long n ) { count . addandget ( n ) ; m1rate . update ( n ) ; m5rate . update ( n ) ; m15rate . update ( n ) ; }	mark the occurrence of a given number of events .
public string [ ] readalllines ( ) { arraylist < string > lines = new arraylist < string > ( ) ; while ( hasnextline ( ) ) { lines . add ( readline ( ) ) ; } return lines . toarray ( new string [ _num ] ) ; }	reads all remaining lines from this input stream and returns them as an array of strings .
protected qualifieditem [ ] parsequalifieditems ( final versionspec defaultversion , final boolean allowversionrange , final int startindex ) { return parsequalifieditems ( getfreearguments ( ) , defaultversion , allowversionrange , startindex ) ; }	parses qualified items ( item specs with optional versions , version ranges , or deletion specifiers ) from the free arguments .
public void changechangeenabled ( changeenabledstate state ) throws refactoringexception { refactoringsession session = getrefactoringsession ( state . getsessionid ( ) ) ; session . updatechangeenabled ( state . getchangeid ( ) , state . isenabled ( ) ) ; }	include / exclude refactoring change from refactoring.
public updatebuilder binduris ( string from , collection < string > uris ) { return binduris ( from , uris , _str ) ; }	bind some uris to a string .
public void populateall ( ) throws generalexception { for ( serviceecaaction ecaaction : serviceecarule . getecaactionlist ( ) ) { servicescalledbythisserviceeca . add ( aif . getserviceartifactinfo ( ecaaction . getservicename ( ) ) ) ; utilmisc . addtosortedsetinmap ( this , aif . allserviceecainfosreferringtoservicename , ecaaction . getservicename ( ) ) ; } }	this must be called after creation from the artifactinfofactory after this class has been put into the global map in order to avoid recursive initialization.
public void validationstatesremoved ( k key ) { hidemessage ( key ) ; validationerrorstates . remove ( key ) ; notifyupstream ( key , collections . < validationstate > emptyset ( ) ) ; }	removes all validation states for the given key .
public void killapplication ( string applicationid ) throws ioexception , yarnexception { log . info ( _str + applicationid ) ; yarnclient . killapplication ( getapplicationidfromstring ( applicationid ) ) ; }	this function kills an application given the applicationid.
public static string convert ( string prefix ) { stringbuilder sb = new stringbuilder ( ) ; prefix = prefix . replace ( _str , _str ) ; string [ ] lines = prefix . split ( _str ) ; for ( string line : lines ) { list < string > tokens = new arraylist < string > ( ) ; char [ ] c = unsafestring . getchars ( line ) ; int lastidx = _num ; int idx = _num ; while ( idx < c . length ) { while ( c [ idx ] != _str && c [ idx ] != _str && c [ idx ] != _str ) { idx ++ ; } if ( idx != lastidx ) { tokens . add ( new string ( c , lastidx , idx - lastidx ) ) ; } idx ++ ; lastidx = idx ; } collections . reverse ( tokens ) ; for ( string token : tokens ) { sb . append ( token ) ; sb . append ( _str ) ; } } return sb . tostring ( ) ; }	converts prefix to postfix , considering the arguments of the prefix notation are in the order they will be popped out of the stack.
public boolean toboolean ( element el , string attributename , boolean defaultvalue ) { string value = el . getattribute ( attributename ) ; if ( value == null ) return defaultvalue ; return caster . tobooleanvalue ( value , _bool ) ; }	reads a xml element attribute ans cast it to a boolean value.
protected void serializepreroot ( ) throws ioexception { int i ; if ( _preroot != null ) { for ( i = _num ; i < _preroot . size ( ) ; ++ i ) { printtext ( ( string ) _preroot . elementat ( i ) , _bool , _bool ) ; if ( _indenting ) _printer . breakline ( ) ; } _preroot . removeallelements ( ) ; } }	comments and pis cannot be serialized before the root element , because the root element serializes the document type , which generally comes first.
private void createschemacolumnentities ( list < schemacolumn > schemacolumns , boolean ispartitionlist , collection < schemacolumnentity > schemacolumnentitylist , map < string , schemacolumnentity > schemacolumnentitymap , businessobjectformatentity businessobjectformatentity ) { if ( ! collectionutils . isempty ( schemacolumns ) ) { int position = _num ; for ( schemacolumn schemacolumn : schemacolumns ) { schemacolumnentity schemacolumnentity = schemacolumnentitymap . get ( schemacolumn . getname ( ) ) ; if ( schemacolumnentity == null ) { schemacolumnentity = createschemacolumnentity ( schemacolumn , businessobjectformatentity ) ; schemacolumnentitylist . add ( schemacolumnentity ) ; schemacolumnentitymap . put ( schemacolumn . getname ( ) , schemacolumnentity ) ; } if ( ispartitionlist ) { schemacolumnentity . setpartitionlevel ( position ++ ) ; } else { schemacolumnentity . setposition ( position ++ ) ; } } } }	creates the schema column entities .
public static < t > string joinand ( final string delimiter , final string lastdelimiter , final collection < t > objs ) { if ( objs == null || objs . isempty ( ) ) return _str ; final iterator < t > iter = objs . iterator ( ) ; final stringbuilder buffer = new stringbuilder ( ) ; while ( iter . hasnext ( ) ) { final t obj = iter . next ( ) ; if ( notempty ( obj ) ) { if ( buffer . length ( ) != _num ) { buffer . append ( iter . hasnext ( ) ? delimiter : lastdelimiter ) ; } buffer . append ( strings . tostring ( obj ) ) ; } } return buffer . tostring ( ) ; }	like join , but allows for a distinct final delimiter.
public static string generatenativeguid ( dbclient dbclient , snapshot snapshot ) throws ioexception { fileshare fs = dbclient . queryobject ( fileshare . class , snapshot . getparent ( ) ) ; storagesystem device = dbclient . queryobject ( storagesystem . class , fs . getstoragedevice ( ) ) ; return string . format ( _str + snapshot + _str , _devicetypemap . get ( device . getsystemtype ( ) ) , device . getserialnumber ( ) , snapshot . getnativeid ( ) ) ; }	generates the format storagesystem + serialnumber + snapshot + nativeid native guid for snapshot objects.
public static map < string , object > updatefile ( dispatchcontext dctx , map < string , ? extends object > context ) { map < string , object > result = null ; try { result = updatefilemethod ( dctx , context ) ; } catch ( genericserviceexception e ) { return serviceutil . returnerror ( e . getmessage ( ) ) ; } return result ; }	a service wrapper for the updatefilemethod method.
public editsensorsdialog ( final collection < sensor > sensors ) { super ( ) ; if ( sensors == null ) { throw new illegalargumentexception ( _str ) ; } this . sensors = sensors ; settitle ( _str + sensors . size ( ) + _str ) ; initcomponents ( ) ; layoutcomponents ( ) ; }	create a new edit sensor dialog .
public string readtodelimiter ( char delim ) throws formatexception { stringbuffer buildretval = new stringbuffer ( ) ; char tmp ; try { while ( ( tmp = readchar ( ) ) != delim ) buildretval . append ( tmp ) ; } catch ( eofexception e ) { } catch ( formatexception fe ) { if ( buildretval . length ( ) == _num ) { throw fe ; } } return buildretval . tostring ( ) ; }	reads a string until the specified delimiter or eof is encountered.
default t call ( sourcesection source , t lhs , t argument1 , t argument2 ) { return call ( source , lhs , arrays . aslist ( argument ( argument1 ) , argument ( argument2 ) ) ) ; }	helper function : create a call with two unnamed arguments .
public void savelockpassword ( string password , int quality , boolean isfallback ) { final byte [ ] hash = passwordtohash ( password ) ; try { randomaccessfile raf = new randomaccessfile ( slockpasswordfilename , _str ) ; try { if ( password == null ) { raf . setlength ( _num ) ; } else { raf . write ( hash , _num , hash . length ) ; } } finally { if ( raf != null ) raf . close ( ) ; } } catch ( filenotfoundexception fnfe ) { logutil . e ( tag , _str + slockpasswordfilename ) ; } catch ( ioexception ioe ) { logutil . e ( tag , _str + slockpasswordfilename ) ; } }	save a lock password.
public boolean checkusernameexists ( string username ) throws dataaccessexception { return getuserinfo ( username ) != null ; }	checks to see if the username already exist in the user table.
public code39reader ( ) { usingcheckdigit = _bool ; extendedmode = _bool ; }	creates a reader that assumes all encoded data is data , and does not treat the final character as a check digit.
public static string encode ( final list < position > path , int precision ) { long lastlat = _num ; long lastlng = _num ; final stringbuffer result = new stringbuffer ( ) ; double factor = math . pow ( _num , precision ) ; for ( final position point : path ) { long lat = math . round ( point . getlatitude ( ) * factor ) ; long lng = math . round ( point . getlongitude ( ) * factor ) ; long dlat = lat - lastlat ; long dlng = lng - lastlng ; encode ( dlat , result ) ; encode ( dlng , result ) ; lastlat = lat ; lastlng = lng ; } return result . tostring ( ) ; }	encodes a sequence of positions into an encoded path string .
@ override public int compareto ( libpackage p_other ) { return pkg_name . comparetoignorecase ( p_other . pkg_name ) ; }	compares 2 packages by name.
public void writeexif ( bitmap bmap , string exifoutfilename ) throws filenotfoundexception , ioexception { if ( bmap == null || exifoutfilename == null ) { throw new illegalargumentexception ( null_argument_string ) ; } outputstream s = null ; try { s = getexifwriterstream ( exifoutfilename ) ; bmap . compress ( bitmap . compressformat . jpeg , _num , s ) ; s . flush ( ) ; } catch ( ioexception e ) { closesilently ( s ) ; throw e ; } s . close ( ) ; }	writes the tags from this exifinterface object into a jpeg compressed bitmap , removing prior exif tags .
public double entropy ( int [ ] x ) { double h = _num ; int n = x . length ; double ln2 = math . log ( _num ) ; int n0 = _num ; for ( int i = _num ; i < n ; i ++ ) { if ( x [ i ] == _num ) { n0 ++ ; } } double p ; if ( n0 == _num || n0 == n ) { return h ; } else { p = ( double ) n0 / ( double ) n ; h = - ( p * math . log ( p ) + ( _num - p ) * math . log ( _num - p ) ) / ln2 ; } return h ; }	this method computes the entropy of a binary signal stored in an int array.
private string [ ] addtoselectionargs ( final string argvalue , final string [ ] selectionargsin ) { string [ ] selectionargs = selectionargsin ; list < string > selectionargslist = new arraylist < > ( ) ; selectionargslist . add ( argvalue ) ; if ( null != selectionargsin ) { for ( final string arg : selectionargsin ) { selectionargslist . add ( arg ) ; } } selectionargs = selectionargslist . toarray ( new string [ _num ] ) ; selectionargslist . clear ( ) ; selectionargslist = null ; return selectionargs ; }	adds criteria to ( existing ) selection arguments criteria is always added as first element into ( existing ) selection arguments.
public void put ( string sample , string attribute , object value ) { if ( ! sampleorder . contains ( sample ) ) sampleorder . add ( sample ) ; if ( ! attributeorder . contains ( attribute ) ) attributeorder . add ( attribute ) ; table . put ( sample , attribute , value ) ; }	put a value in the table.
public boolean iscompacted ( ) { return compacted ; }	method that checks if the element has been compacted .
protected void center ( ) { container parent = getparent ( ) ; final dimension size = getpreferredsize ( ) ; setbounds ( ( parent . getwidth ( ) - size . width ) / _num , ( parent . getheight ( ) - size . height ) / _num , size . width , size . height ) ; }	center the window within the parent component .
public boolean iscarddismissible ( string tag ) { return mdismissiblecards . contains ( tag ) ; }	returns true if the card is shown and is dismissible .
public void write ( char cbuf [ ] , int off , int len ) throws ioexception { se . write ( cbuf , off , len ) ; }	writes a portion of an array of characters .
public boolean validate ( string telephone ) { char achar ; stringbuilder buf = new stringbuilder ( telephone ) ; for ( int aindex = _num ; aindex < buf . length ( ) ; aindex ++ ) { achar = buf . charat ( aindex ) ; if ( ! character . isspacechar ( achar ) ) { if ( ! character . isdigit ( achar ) && ! isvalidtelephonechars ( achar ) ) { return _bool ; } } } return _bool ; }	determines whether the specified string is a valid " basic " telephone number string.
public static void unpack ( hashmap < string , object > object , string key , object value ) { string [ ] split = key . split ( _str ) ; hashmap lobj = object ; for ( int cur = _num ; cur < split . length ; cur ++ ) { string current = split [ cur ] ; if ( ! ( lobj . containskey ( current ) && lobj . get ( current ) instanceof hashmap ) ) { lobj . put ( current , new hashmap < string , object > ( ) ) ; } if ( cur == split . length - _num ) { lobj . put ( current , value ) ; } else lobj = ( hashmap ) lobj . get ( current ) ; } }	unpack a period delimited string and get the object at that pointer.
public void removelistener ( dnslistener listener ) { _listeners . remove ( listener ) ; }	remove a listener from all outstanding questions.
static set < string > parseresourcepathparams ( string resourcepath ) { matcher matcher = param_url_regex . matcher ( resourcepath ) ; set < string > patterns = new linkedhashset < > ( ) ; while ( matcher . find ( ) ) { patterns . add ( matcher . group ( _num ) ) ; } return patterns ; }	gets the set of unique path parameters used in the given uri.
@ override public void close ( ) throws ioexception { if ( logger != null ) { logger . println ( _str + socket_was_closed ) ; } if ( ! socket_was_closed ) { if ( handshake_started ) { alertprotocol . alert ( alertprotocol . warning , alertprotocol . close_notify ) ; try { output . write ( alertprotocol . wrap ( ) ) ; } catch ( ioexception ex ) { } alertprotocol . setprocessed ( ) ; } shutdown ( ) ; closetransportlayer ( ) ; socket_was_closed = _bool ; } }	this method works according to the specification of implemented class .
public jrangeslider ( boundedrangemodel model , int orientation , int direction ) { super . setfocusable ( _bool ) ; this . model = model ; this . orientation = orientation ; this . direction = direction ; setforeground ( color . light_gray ) ; this . lstnr = createlistener ( ) ; model . addchangelistener ( lstnr ) ; addmouselistener ( this ) ; addmousemotionlistener ( this ) ; addkeylistener ( this ) ; }	create a new range slider .
public static boolean isautonew ( properties ctx ) { if ( ctx == null ) throw new illegalargumentexception ( _str ) ; string s = getcontext ( ctx , _str ) ; if ( s != null && s . equals ( _str ) ) return _bool ; return _bool ; }	is auto new record.
public boolean canread ( string path ) { try { zipentry entry = getzipentry ( path ) ; return entry != null && ! entry . isdirectory ( ) ; } catch ( ioexception e ) { log . log ( level . fine , e . tostring ( ) , e ) ; return _bool ; } }	readable if the jar is readable and the path refers to a file .
public static long [ ] andi ( long [ ] v , long [ ] o , int off ) { if ( off == _num ) { return andi ( v , o ) ; } if ( off < _num ) { throw new unsupportedoperationexception ( _str ) ; } final int shiftwords = off > > > long_log2_size ; final int shiftbits = off & long_log2_mask ; if ( shiftwords >= v . length ) { return v ; } if ( shiftbits == _num ) { final int end = math . min ( v . length , o . length + shiftwords ) ; for ( int i = shiftwords ; i < end ; i ++ ) { v [ i ] &= o [ i - shiftwords ] ; } arrays . fill ( v , _num , shiftwords , _num ) ; return v ; } final int unshiftbits = long . size - shiftbits ; final int end = math . min ( v . length , o . length + shiftwords ) - _num ; arrays . fill ( v , end + _num , v . length , _num ) ; for ( int i = end ; i > shiftwords ; i -- ) { final int src = i - shiftwords ; v [ i ] &= ( o [ src ] << shiftbits ) | ( o [ src - _num ] > > > unshiftbits ) ; } v [ shiftwords ] &= o [ _num ] << shiftbits ; arrays . fill ( v , _num , shiftwords , _num ) ; return v ; }	and o onto v inplace , i.
public boolean equals ( object p_test ) { if ( p_test instanceof uri ) { uri testuri = ( uri ) p_test ; if ( ( ( m_scheme == null && testuri . m_scheme == null ) || ( m_scheme != null && testuri . m_scheme != null && m_scheme . equals ( testuri . m_scheme ) ) ) && ( ( m_userinfo == null && testuri . m_userinfo == null ) || ( m_userinfo != null && testuri . m_userinfo != null && m_userinfo . equals ( testuri . m_userinfo ) ) ) && ( ( m_host == null && testuri . m_host == null ) || ( m_host != null && testuri . m_host != null && m_host . equals ( testuri . m_host ) ) ) && m_port == testuri . m_port && ( ( m_path == null && testuri . m_path == null ) || ( m_path != null && testuri . m_path != null && m_path . equals ( testuri . m_path ) ) ) && ( ( m_querystring == null && testuri . m_querystring == null ) || ( m_querystring != null && testuri . m_querystring != null && m_querystring . equals ( testuri . m_querystring ) ) ) && ( ( m_fragment == null && testuri . m_fragment == null ) || ( m_fragment != null && testuri . m_fragment != null && m_fragment . equals ( testuri . m_fragment ) ) ) ) { return _bool ; } } return _bool ; }	determines if the passed - in object is equivalent to this uri .
public void testcase5 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = _num ; int bsign = - _num ; byte rbytes [ ] = { - _num , - _num , - _num , _num , - _num , - _num , - _num , - _num , _num , - _num , - _num , - _num , _num , - _num , _num , _num , _num , - _num , - _num , _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . multiply ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , result . signum ( ) ) ; }	multiply two numbers of different length and different signs.
public isaacrandom ( ) { setseed ( system . currenttimemillis ( ) + system . identityhashcode ( this ) ) ; }	creates a new isaac random number generator.
public static boolean ismd5string ( final string string ) { preconditions . checknotnull ( string , _str ) ; return ( string . length ( ) == _num ) && ishexstring ( string ) ; }	tests whether a given string is a valid md5 string .
public synchronized void waitforsubmittedtasks ( ) throws interruptedexception { while ( currenttaskcount . get ( ) > _num ) { waitforsingletask ( ) ; } }	waits for all tasks that have been previously submitted to the pool to finish .
private int scantoken ( int startpos ) { int position = startpos ; while ( position < maxposition ) { if ( ! hassurrogates ) { char c = str . charat ( position ) ; if ( ( c <= maxdelimcodepoint ) && ( delimiters . indexof ( c ) >= _num ) ) break ; position ++ ; } else { int c = str . codepointat ( position ) ; if ( ( c <= maxdelimcodepoint ) && isdelimiter ( c ) ) break ; position += character . charcount ( c ) ; } } if ( retdelims && ( startpos == position ) ) { if ( ! hassurrogates ) { char c = str . charat ( position ) ; if ( ( c <= maxdelimcodepoint ) && ( delimiters . indexof ( c ) >= _num ) ) position ++ ; } else { int c = str . codepointat ( position ) ; if ( ( c <= maxdelimcodepoint ) && isdelimiter ( c ) ) position += character . charcount ( c ) ; } } return position ; }	skips ahead from startpos and returns the index of the next delimiter character encountered , or maxposition if no such delimiter is found .
public void zoomat ( double x , double y , double z , double zoomvalue ) { double [ ] diff = { targetxoff - x , targetyoff - y , z - targetzoff } ; double length = math . sqrt ( diff [ _num ] * diff [ _num ] + diff [ _num ] * diff [ _num ] + diff [ _num ] * diff [ _num ] ) ; if ( length == _num ) { length = _num ; } double [ ] normalized = { diff [ _num ] / length , diff [ _num ] / length , diff [ _num ] / length } ; double percent = zoomvalue / normalized [ _num ] ; movetoposition ( - ( float ) ( targetxoff + normalized [ _num ] * percent ) , - ( float ) ( targetyoff + normalized [ _num ] * percent ) ) ; zoomtocamera ( ( float ) ( targetzoff + normalized [ _num ] * percent ) ) ; }	move the eye in straight line toward the given world position , reducing ( or augmenting ) the distance between eye and point of zoomvalue .
private static int stringtohash ( string s ) { int len = s . length ( ) ; int hash2 = _num ; int hash = len ; hash <<= _num ; hash += s . charat ( _num ) - _num ; int j = len ; for ( int i = _num ; i < _num && j > _num ; i ++ ) { j -- ; hash <<= _num ; hash += s . charat ( j ) - _num ; hash2 <<= _num ; hash2 += s . charat ( i ) - _num ; } return hash ^ hash2 ; }	this method has to return a unique integer for each well - known lower - cased attribute name .
public void registerdensefeatures ( arraylist < featurefunction > featurefunctions ) { for ( featurefunction feature : featurefunctions ) { arraylist < string > names = feature . reportdensefeatures ( densefeatures . size ( ) ) ; for ( string name : names ) { dense_feature_names . add ( name ) ; densefeatures . add ( getsparse ( name ) ) ; sparsefeatures . remove ( name ) ; } } }	register one or more dense features with the global weight vector.
private void addflag ( final list < string > args , final string argname , final boolean value ) { if ( value ) { args . add ( argname ) ; } }	adds flag to arguments when value is true .
public static privatekey load ( inputstream is ) throws ioexception , cryptoexception { byte [ ] pvk = readutil . readfully ( is ) ; bytebuffer bb = bytebuffer . wrap ( pvk ) ; bb . order ( byteorder . little_endian ) ; long keytype = readreservedmagickeytype ( bb ) ; long encrypted = unsignedutil . getint ( bb ) ; if ( encrypted != pvk_unencrypted ) { throw new privatekeyencryptedexception ( messageformat . format ( res . getstring ( _str ) , long . tohexstring ( encrypted ) , long . tohexstring ( pvk_unencrypted ) ) ) ; } long saltlength = unsignedutil . getint ( bb ) ; if ( saltlength != unencrypted_salt_length ) { throw new cryptoexception ( messageformat . format ( res . getstring ( _str ) , long . tohexstring ( saltlength ) , long . tohexstring ( unencrypted_salt_length ) ) ) ; } long keylength = unsignedutil . getint ( bb ) ; readprivatekeyblobheader ( bb , keytype ) ; byte [ ] privatekeyblob = new byte [ bb . remaining ( ) ] ; bb . get ( privatekeyblob ) ; if ( keylength != ( privatekeyblob . length + blob_header_length ) ) { throw new cryptoexception ( messageformat . format ( res . getstring ( _str ) , long . tohexstring ( keylength ) , long . tohexstring ( privatekeyblob . length + blob_header_length ) ) ) ; } return blobtoprivatekey ( privatekeyblob ) ; }	load an unencrypted pvk private key from the stream .
public static byte [ ] keygenprivate ( byte [ ] randombytes ) throws nosuchalgorithmexception , digestexception { if ( randombytes . length < _num ) { throw new runtimeexception ( _str ) ; } messagedigest digest = messagedigest . getinstance ( _str ) ; digest . digest ( randombytes , _num , randombytes . length ) ; byte [ ] privatekey = digest . digest ( ) ; privatekey [ _num ] &= _num ; privatekey [ _num ] &= _num ; privatekey [ _num ] |= _num ; return privatekey ; }	generating private key . source : https : / / cr . yp . to / ecdh . html.
private boolean ischeckpointtableexists ( connection conn ) { statement st = null ; resultset rs = null ; try { st = conn . createstatement ( ) ; rs = st . executequery ( chktblexistssql ) ; return _bool ; } catch ( sqlexception ignored ) { return _bool ; } finally { u . close ( rs , log ) ; u . close ( st , log ) ; } }	this method accomplishes rdbms - independent table exists check .
public functiontablemodel ( ) { columnlist . add ( localisation . getstring ( functiontablemodel . class , _str ) ) ; columnlist . add ( localisation . getstring ( functiontablemodel . class , _str ) ) ; columnlist . add ( localisation . getstring ( functiontablemodel . class , _str ) ) ; columnlist . add ( localisation . getstring ( functiontablemodel . class , _str ) ) ; }	instantiates a new function table model .
private newcookie createwscookie ( string cookiename , string token , boolean setmaxage , string useragent ) { string ieexpires = _str ; int maxage = setmaxage ? _tokenmanager . getmaxtokenlifetimeinsecs ( ) : newcookie . default_max_age ; if ( setmaxage && stringutils . contains ( useragent , _str ) ) { ieexpires = _str + getexpiredtimegmt ( maxage ) ; _log . debug ( _str + ieexpires ) ; } if ( token != null && ! token . isempty ( ) ) { return new newcookie ( cookiename , token + _str + ieexpires , null , null , null , maxage , _bool ) ; } return null ; }	create and return a cookie object with the token.
protected void initview ( ) { p . setfakeboldtext ( _bool ) ; p . setantialias ( _bool ) ; p . settextsize ( mini_day_number_text_size ) ; p . setstyle ( style . fill ) ; mmonthnumpaint = new paint ( ) ; mmonthnumpaint . setfakeboldtext ( _bool ) ; mmonthnumpaint . setantialias ( _bool ) ; mmonthnumpaint . settextsize ( mini_day_number_text_size ) ; mmonthnumpaint . setcolor ( mfocusmonthcolor ) ; mmonthnumpaint . setstyle ( style . fill ) ; mmonthnumpaint . settextalign ( align . center ) ; }	sets up the text and style properties for painting.
scheduledfuturetask ( runnable r , v result , long ns , long period ) { super ( r , result ) ; this . time = ns ; this . period = period ; this . sequencenumber = sequencer . getandincrement ( ) ; }	creates a periodic action with given nano time and period .
public boolean verify ( x509certificate cert , provider sigprovider ) throws nosuchalgorithmexception , certificateexpiredexception , certificatenotyetvalidexception , cmsexception { time signingtime = getsigningtime ( ) ; if ( signingtime != null ) { cert . checkvalidity ( signingtime . getdate ( ) ) ; } return doverify ( cert . getpublickey ( ) , sigprovider ) ; }	verify that the given certificate successfully handles and confirms the signature associated with this signer and , if a signingtime attribute is available , that the certificate was valid at the time the signature was generated .
public geomark analyse ( final string text , final string [ ] tags , final int maxlength , final string salt ) { geolocation loc = geocode ( text , tags , maxlength ) ; if ( loc != null ) return new geomark ( loc , salt ) ; return reverse_geocode ( text ) ; }	analyse a text for the presence of a location name.
public void test_selectorderby ( ) throws sqlexception { string selectquery = _str + databasecreator . orders_table + _str ; resultset result = statement . executequery ( selectquery ) ; arraylist < integer > values = new arraylist < integer > ( ) ; values . add ( integer . valueof ( _num ) ) ; values . add ( integer . valueof ( _num ) ) ; values . add ( integer . valueof ( _num ) ) ; values . add ( integer . valueof ( _num ) ) ; values . add ( integer . valueof ( _num ) ) ; values . add ( integer . valueof ( _num ) ) ; values . add ( integer . valueof ( _num ) ) ; values . add ( integer . valueof ( _num ) ) ; values . add ( integer . valueof ( _num ) ) ; values . add ( integer . valueof ( _num ) ) ; int index = _num ; while ( result . next ( ) ) { integer onum = result . getint ( _str ) ; asserttrue ( _str , values . contains ( onum ) ) ; assertequals ( _str , index , values . indexof ( onum ) ) ; index ++ ; } result . close ( ) ; }	selectfunctionalitytest # test_selectorderby ( ) . selects records from a table using order by.
private static string formatto2digits ( string str ) { if ( str . length ( ) < _num ) { str = _str + str ; } return str ; }	makes values consist of 2 letters " 01 ".
protected static string quotesql ( object data , int type ) throws sqlexception { if ( data == null ) { return _str ; } switch ( type ) { case types . bit : case types . boolean : case types . integer : case types . bigint : case types . decimal : case types . double : case types . float : case types . numeric : case types . real : case types . smallint : case types . tinyint : return data . tostring ( ) ; case types . date : case types . time : case types . timestamp : case types . longvarchar : case types . char : case types . varchar : return quotestring ( data . tostring ( ) ) ; case types . varbinary : case types . longvarbinary : case types . binary : if ( data instanceof uuid ) { return _str + data . tostring ( ) + _str ; } return _str + stringutils . convertbytestohex ( ( byte [ ] ) data ) + _str ; case types . clob : case types . java_object : case types . other : case types . blob : case types . struct : case types . ref : case types . null : case types . array : case types . datalink : case types . distinct : throw throwexception ( _str + type ) ; default : return _str ; } }	internal . convert an object to a string as used in a sql statement .
public static int calculatedigitcount ( long value ) { if ( value < _num ) { if ( value != long . min_value ) { return calculatedigitcount ( - value ) + _num ; } else { return _num ; } } return ( value < _num ? _num : ( value < _num ? _num : ( value < _num ? _num : ( value < _num ? _num : ( ( int ) ( math . log ( value ) / log_10 ) + _num ) ) ) ) ) ; }	calculates the number of decimal digits for the given value , including the sign .
public string bytestringnosemicolon ( ) { stringbuilder retval = new stringbuilder ( ) ; try { while ( _bool ) { char next = lookahead ( _num ) ; if ( next == _str || next == _str || next == _str || next == _str ) { break ; } else { consume ( _num ) ; retval . append ( next ) ; } } } catch ( parseexception ex ) { return retval . tostring ( ) ; } return retval . tostring ( ) ; }	return a substring containing no semicolons .
public void testnegnegfirstlonger ( ) { byte abytes [ ] = { - _num , _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , - _num , _num , _num , - _num , - _num } ; byte bbytes [ ] = { - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = - _num ; int bsign = - _num ; byte rbytes [ ] = { - _num , _num , _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . or ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , result . signum ( ) ) ; }	or for two negative numbers ; the first is longer.
public static void println ( double x ) { out . println ( x ) ; }	prints a double to standard output and then terminates the line .
public boolean subscribetopic ( @ nonnull context context , @ nonnull string [ ] newtopics ) { if ( ! initialized ) init ( context ) ; if ( newtopics . length == _num ) return _bool ; if ( null == topics ) { topics = new arraylist < > ( ) ; } for ( string topic : newtopics ) { if ( topics . contains ( topic ) ) { return _bool ; } topics . add ( topic ) ; } savesubscibedtopics ( context ) ; intent intent = new intent ( context , registrationintentservice . class ) ; intent . setaction ( registrationintentservice . action_subscribe ) ; intent . putextra ( registrationintentservice . extra_topic_list , newtopics ) ; context . startservice ( intent ) ; return _bool ; }	subscribe to a list of topics .
public static string serialise ( node node ) { try { domimplementationregistry registry = domimplementationregistry . newinstance ( ) ; domimplementationls lsimpl = ( domimplementationls ) registry . getdomimplementation ( _str ) ; lsserializer serializer = lsimpl . createlsserializer ( ) ; return serializer . writetostring ( node ) ; } catch ( exception e ) { log . fine ( _str + e ) ; return _str ; } }	serialises the xml node into a string .
public static boolean isonsegment ( geo a , geo b , geo i ) { return ( ( a . distance ( i ) < a . distance ( b ) ) && ( b . distance ( i ) < b . distance ( a ) ) ) ; }	point i is on the great circle defined by the points a and b.
public void addextensionpoint ( extensionpoint extensionpoint ) { fextensionpoints . add ( extensionpoint ) ; }	adds a extension point .
private list addnodetolist ( int startindexfornode , int endindexfornode ) { list localvmlist = new arraylist ( ) ; for ( int i = startindexfornode ; i < endindexfornode ; i ++ ) { localvmlist . add ( vm [ i ] ) ; } return localvmlist ; }	this function adds nodes to node list.
public void addmetamethod ( metamethod method ) { if ( isinitialized ( ) ) { throw new runtimeexception ( _str + method ) ; } final cachedclass declaringclass = method . getdeclaringclass ( ) ; addmetamethodtoindex ( method , metamethodindex . getheader ( declaringclass . gettheclass ( ) ) ) ; }	adds a metamethod to this class.
public void waitforevent ( long timeout ) { thread thread = thread . currentthread ( ) ; semaphore semaphore = _semaphores . get ( thread ) ; if ( semaphore == null ) { semaphore = new semaphore ( _num , _bool ) ; semaphore . drainpermits ( ) ; _semaphores . putifabsent ( thread , semaphore ) ; } semaphore = _semaphores . get ( thread ) ; try { semaphore . tryacquire ( timeout , timeunit . milliseconds ) ; } catch ( interruptedexception exception ) { logger . log ( level . finer , _str , exception ) ; } }	blocks the current thread until the event arrives or the timeout expires .
public string stringvalue ( ) { object cv = assert . checknonnull ( constvalue ( ) ) ; return cv . tostring ( ) ; }	the constant value of this type , converted to string.
public date parsedate ( string str ) { try { return dateformat . parse ( str ) ; } catch ( java . text . parseexception e ) { throw new runtimeexception ( e ) ; } }	parse the given string into date object .
default int hash32 ( string value ) { return hash32 ( value . getbytes ( ) ) ; }	returns a 32 - bit hash of the given string .
public name addall ( name suffix ) throws invalidnameexception { return addall ( size ( ) , suffix ) ; }	adds the components of a name - - in order - - to the end of this name .
public final inputstream asinputstream ( ) throws unknownresourceexception { return toinputstream ( ) ; }	loads the resource and returns an inputstream from which to load it .
private static double euclideannorm ( double vector [ ] ) { int n = vector . length ; if ( n < _num ) { return _num ; } if ( n == _num ) { return math . abs ( vector [ _num ] ) ; } double scale = _num ; double sum = _num ; for ( int i = _num ; i < n ; i ++ ) { if ( vector [ i ] != _num ) { double abs = math . abs ( vector [ i ] ) ; if ( scale < abs ) { double t = scale / abs ; sum = _num + sum * ( t * t ) ; scale = abs ; } else { double t = abs / scale ; sum += t * t ; } } } return scale * math . sqrt ( sum ) ; }	returns the euclidean norm of a vector.
public static filedescriptor createsocket ( ) throws ioexception { if ( ! issupported ) throw new unsupportedoperationexception ( _str ) ; int fdval = create0 ( ) ; filedescriptor fd = new filedescriptor ( ) ; fdaccess . set ( fd , fdval ) ; return fd ; }	creates a sdp socket , returning file descriptor referencing the socket .
private static void extractfile ( zipinputstream zipin , string filepath ) throws ioexception { bufferedoutputstream bos = new bufferedoutputstream ( new fileoutputstream ( filepath ) ) ; byte [ ] bytesin = new byte [ buffer_size ] ; int read = _num ; while ( ( read = zipin . read ( bytesin ) ) != - _num ) { bos . write ( bytesin , _num , read ) ; } bos . close ( ) ; }	extracts a zip entry ( file entry ).
public static final string squaretostring ( int square ) { stringbuilder ret = new stringbuilder ( ) ; int x = position . getx ( square ) ; int y = position . gety ( square ) ; ret . append ( ( char ) ( x + _str ) ) ; ret . append ( ( char ) ( y + _str ) ) ; return ret . tostring ( ) ; }	convert a square number to a string , such as " e4 " .
public static boolean hasvalidcover ( igame game , coords pos , int elevation ) { if ( ( pos == null ) || ( elevation > _num ) ) { return _bool ; } boolean hasmovedentity = _bool ; for ( entity e : game . getentitiesvector ( pos ) ) { if ( e . isdone ( ) && ! ( e instanceof infantry ) && ( e . getelevation ( ) == elevation ) ) { hasmovedentity = _bool ; break ; } } if ( ! hasmovedentity ) { enumeration < entity > wrecks = game . getwreckedentities ( ) ; while ( wrecks . hasmoreelements ( ) ) { entity e = wrecks . nextelement ( ) ; if ( pos . equals ( e . getposition ( ) ) && ! ( e instanceof infantry ) ) { hasmovedentity = _bool ; } } } return hasmovedentity ; }	determines if there is valid cover for an infantry unit to utilize the using non - infantry as cover rules ( to pg 108 ) .
public static coordinate [ ] computetangentsthroughpoint ( coordinate circlecenter , double radius , coordinate point ) { coordinate [ ] ret = new coordinate [ _num ] ; double dx = ( point . x - circlecenter . x ) / _num ; double dy = ( point . y - circlecenter . y ) / _num ; double d = math . sqrt ( dx * dx + dy * dy ) ; double a = ( radius * radius ) / ( _num * d ) ; double x2 = circlecenter . x + ( dx * a / d ) ; double y2 = circlecenter . y + ( dy * a / d ) ; double h = math . sqrt ( radius * radius - a * a ) ; double rx = - dy * ( h / d ) ; double ry = dx * ( h / d ) ; double xi = x2 + rx ; double yi = y2 + ry ; double xiprime = x2 - rx ; double yiprime = y2 - ry ; ret [ _num ] = new coordinate ( point ) ; ret [ _num ] = new coordinate ( xi , yi ) ; ret [ _num ] = new coordinate ( xiprime , yiprime ) ; return ret ; }	computes both tangents of a circle running through a given point.
public void addgroup ( groupconfiginterface subgroup ) { subgrouplist . add ( subgroup ) ; }	adds the sub group .
public void startscanning ( final beaconserviceconnection serviceconnection ) { final cursor cursor = mdatabasehelper . getallregions ( ) ; while ( cursor . movetonext ( ) ) { final uuid uuid = uuid . fromstring ( cursor . getstring ( _num ) ) ; final int major = cursor . getint ( _num ) ; final int minor = cursor . getint ( _num ) ; final int event = cursor . getint ( _num ) ; serviceconnection . startrangingbeaconsinregion ( beaconsfragment . beacon_company_id , uuid , major , minor , this ) ; if ( event == beaconcontract . event_in_range || event == beaconcontract . event_out_of_range ) serviceconnection . startmonitoringforregion ( beaconsfragment . beacon_company_id , uuid , major , minor , this ) ; } }	registers for monitoring and ranging events for all regions in the database .
public void testdivideroundhalfdownneg1 ( ) { string a = _str ; int ascale = - _num ; string b = _str ; int bscale = _num ; string c = _str ; int resscale = - _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; bigdecimal result = anumber . divide ( bnumber , resscale , bigdecimal . round_half_down ) ; assertequals ( _str , c , result . tostring ( ) ) ; assertequals ( _str , resscale , result . scale ( ) ) ; }	divide : rounding mode is round_half_down , result is negative ; distance = 1.
public static boolean isheader ( header hdr ) { return hdr . getbooleanvalue ( zimage , _bool ) ; }	check that this hdu has a valid header for this type .
public static inforegister createfolder ( user user , integer bookid , list atts , list inter , map documents , string entidad , boolean consolidacion ) throws validationexception , securityexception , bookexception , sessionexception , tecdocexception , parseexception , attributesexception { inforegister result = new inforegister ( ) ; string sessionid = new string ( ) ; try { sessionid = login . login ( user , entidad ) ; setofficeuserregister ( entidad , sessionid , atts ) ; booksession . openbook ( sessionid , bookid , entidad ) ; integer launchdistoutregister = registerservicesutil . getinvesconfactions ( entidad ) ; registerservicesutil . cancreatefolder ( sessionid , bookid , documents , user , atts , entidad , consolidacion ) ; axsf axsfq = booksession . getformformat ( sessionid , bookid , entidad ) ; fieldformat fieldformat = registerservicesutil . getfieldformat ( sessionid , bookid ) ; map translatedids = registerservicesutil . getfieldswithsustitute ( atts , axsfq , sessionid , bookid , entidad ) ; axsf newaxsf = registerservicesutil . initinoroutfolder ( user , axsfq ) ; newaxsf = registerservicesutil . completefolder ( translatedids , axsfq , newaxsf , user . getlocale ( ) , atts , fieldformat , consolidacion ) ; folderdatasession data = register . createnewfolder ( sessionid , bookid , newaxsf , inter , documents , launchdistoutregister , user . getlocale ( ) , entidad , consolidacion ) ; result = consultregister . consultregisterinfo ( bookid , data . getaxsfnew ( ) , data . getnewregisterid ( ) , data . getscrofic ( ) , data . getusername ( ) , user . getlocale ( ) ) ; } finally { booksession . closebook ( sessionid , bookid ) ; securitysession . logout ( sessionid , entidad ) ; } return result ; }	metodo que crea un registro.
public void close ( ) throws ioexception { finputstream . close ( ) ; }	close the stream . once a stream has been closed , further read ( ) , ready ( ) , mark ( ) , or reset ( ) invocations will throw an ioexception . closing a previously - closed stream , however , has no effect .
private void handlesubscriptionerror ( azureallocationcontext ctx , string namespace , throwable e ) { if ( e instanceof cloudexception ) { cloudexception ce = ( cloudexception ) e ; clouderror body = ce . getbody ( ) ; if ( body != null ) { string code = body . getcode ( ) ; if ( missing_subscription_code . equals ( code ) ) { registersubscription ( ctx , namespace ) ; return ; } } } handleerror ( ctx , e ) ; }	this method tries to detect a subscription registration error and register subscription for given namespace.
public boolean hasshutdownhook ( runnable shutdownhook ) { return hooks . contains ( shutdownhook ) ; }	indicates if a shutdownhook is registered or not .
@ override public void endprocesssubtokens ( ) { if ( ! skey . isempty ( ) ) { map . put ( skey , sval ) ; skey = _str ; sval = _str ; } }	inserts subtoken key , val pair in subtoken hash . if there are multiple keys with the same value override this call and append values.
private void heapifydown ( comparable < object > cur ) { final int stop = size > > > _num ; int twopos = _num ; while ( twopos < stop ) { int bestchild = ( twopos << _num ) + _num ; comparable < object > best = twoheap [ bestchild ] ; final int right = bestchild + _num ; if ( right < size && best . compareto ( twoheap [ right ] ) > _num ) { bestchild = right ; best = twoheap [ right ] ; } if ( cur . compareto ( best ) <= _num ) { break ; } twoheap [ twopos ] = best ; twopos = bestchild ; } twoheap [ twopos ] = cur ; }	invoke heapify - down for the root object .
public void addfeature ( ifeaturevector fv ) { idxlist . addall ( ints . aslist ( fv . getindices ( ) ) ) ; vallist . addall ( floats . aslist ( fv . getvalues ( ) ) ) ; }	currentvector = currentvector + fv.
private boolean isinthumbrange ( float touchx , double normalizedthumbvalue ) { return math . abs ( touchx - normalizedtoscreen ( normalizedthumbvalue ) ) <= thumbhalfwidth ; }	decides if given x - coordinate in screen space needs to be interpreted as " within " the normalized thumb x - coordinate .
public static byte [ ] str2unicodebytearray ( final jbbpbyteorder byteorder , final string str ) { final byte [ ] result = new byte [ str . length ( ) << _num ] ; int index = _num ; for ( int i = _num ; i < str . length ( ) ; i ++ ) { final int val = str . charat ( i ) ; switch ( byteorder ) { case big_endian : { result [ index ++ ] = ( byte ) ( val > > _num ) ; result [ index ++ ] = ( byte ) val ; } break ; case little_endian : { result [ index ++ ] = ( byte ) val ; result [ index ++ ] = ( byte ) ( val > > _num ) ; } break ; default : throw new error ( _str + byteorder + _str ) ; } } return result ; }	convert chars of a string into a byte array contains the unicode codes .
private methoddef parse_method ( strtok st ) { string method_name = st . need_word ( ) ; st . need ( _str ) ; arraylist < string > args = new arraylist < > ( ) ; string tok = st . nexttoken ( ) ; if ( tok != _str ) { st . pushback ( ) ; do { tok = st . need_word ( ) ; args . add ( tok ) ; } while ( st . nexttoken ( ) == _str ) ; st . pushback ( ) ; st . need ( _str ) ; } type [ ] targs = new type [ args . size ( ) ] ; for ( int ii = _num ; ii < args . size ( ) ; ii ++ ) { targs [ ii ] = bcelutil . classname_to_type ( args . get ( ii ) ) ; } return new methoddef ( method_name , targs ) ; }	parse a method declaration.
private void writeexperiecedandcausingpersondelay ( ) { sortedmap < double , map < id < person > , double > > timebin2affectedperson2delay = getexperiencedpersondelay ( _num ) ; sortedmap < double , map < id < person > , double > > timebin2causingperson2delay = getcausingpersondelay ( _num ) ; if ( timebin2affectedperson2delay . size ( ) != _num ) throw new runtimeexception ( _str ) ; map < id < person > , double > affectedperson2delay = timebin2affectedperson2delay . get ( simulationendtime ) ; map < id < person > , double > causedperson2delay = timebin2causingperson2delay . get ( simulationendtime ) ; bufferedwriter writer = ioutils . getbufferedwriter ( rundir + _str + pricingscenario + suffixforsoring + _str ) ; try { writer . write ( _str ) ; for ( id < person > id : causedperson2delay . keyset ( ) ) { writer . write ( id + _str + pf . getmunichusergroupfrompersonid ( id ) + _str + affectedperson2delay . get ( id ) / _num + _str + causedperson2delay . get ( id ) / _num + _str ) ; } writer . close ( ) ; } catch ( exception e ) { throw new runtimeexception ( _str + e ) ; } }	writes < p > personid usergroup delayinhr.
static list < list < file > > partition ( final int bincount , final file ... files ) { final file [ ] sort = arrays . copyof ( files , files . length ) ; return binthem ( bincount , sort ) ; }	partition the given files into the specified bins trying to approximately balance the size of the bins according to the lengths of the files.
private void calcbitepoint ( int centerx , int centery , float circleedgex , float circleedgey , double biteline , boolean isfirstbite , boolean israndombite ) { double bitepercent ; if ( isfirstbite ) { bitex = ( int ) circleedgex ; bitey = ( int ) circleedgey ; } else { bitepercent = biteradius / biteline ; if ( israndombite ) { bitepercent *= bitestakenmap . get ( bitedirection ) ; } else { bitepercent *= ( numbitesforonedirection - numbitesforonedirectionleft ) ; } bitex = drawutils . getpointbetweentwopoints ( circleedgex , centerx , bitepercent ) ; bitey = drawutils . getpointbetweentwopoints ( circleedgey , centery , bitepercent ) ; } }	method for calculating bite point for random & one direction options.
private boolean zzrefill ( ) throws java . io . ioexception { if ( zzstartread > _num ) { system . arraycopy ( zzbuffer , zzstartread , zzbuffer , _num , zzendread - zzstartread ) ; zzendread -= zzstartread ; zzcurrentpos -= zzstartread ; zzmarkedpos -= zzstartread ; zzpushbackpos -= zzstartread ; zzstartread = _num ; } if ( zzcurrentpos >= zzbuffer . length ) { char newbuffer [ ] = new char [ zzcurrentpos * _num ] ; system . arraycopy ( zzbuffer , _num , newbuffer , _num , zzbuffer . length ) ; zzbuffer = newbuffer ; } int numread = zzreader . read ( zzbuffer , zzendread , zzbuffer . length - zzendread ) ; if ( numread < _num ) { return _bool ; } else { zzendread += numread ; return _bool ; } }	refills the input buffer .
private void updatebusinessobjectdefinitionentitydescriptiveinformation ( businessobjectdefinitionentity businessobjectdefinitionentity , businessobjectdefinitiondescriptiveinformationupdaterequest request ) { businessobjectdefinitionentity . setdescription ( request . getdescription ( ) ) ; businessobjectdefinitionentity . setdisplayname ( request . getdisplayname ( ) ) ; businessobjectdefinitiondao . saveandrefresh ( businessobjectdefinitionentity ) ; }	update and persist the business object definition descriptive information per specified update request .
@ override public void ondownloadprogress ( downloadprogressinfo progress ) { maveragespeed . settext ( getstring ( r . string . kilobytes_per_second , helpers . getspeedstring ( progress . mcurrentspeed ) ) ) ; mtimeremaining . settext ( getstring ( r . string . time_remaining , helpers . gettimeremaining ( progress . mtimeremaining ) ) ) ; progress . moveralltotal = progress . moveralltotal ; mpb . setmax ( ( int ) ( progress . moveralltotal > > _num ) ) ; mpb . setprogress ( ( int ) ( progress . moverallprogress > > _num ) ) ; mprogresspercent . settext ( long . tostring ( progress . moverallprogress * _num / progress . moveralltotal ) + _str ) ; mprogressfraction . settext ( helpers . getdownloadprogressstring ( progress . moverallprogress , progress . moveralltotal ) ) ; }	sets the state of the various controls based on the progressinfo object sent from the downloader service .
static public boolean issameday ( timestamp one , timestamp two ) { gregoriancalendar calone = new gregoriancalendar ( ) ; if ( one != null ) calone . settimeinmillis ( one . gettime ( ) ) ; gregoriancalendar caltwo = new gregoriancalendar ( ) ; if ( two != null ) caltwo . settimeinmillis ( two . gettime ( ) ) ; if ( calone . get ( calendar . year ) == caltwo . get ( calendar . year ) && calone . get ( calendar . month ) == caltwo . get ( calendar . month ) && calone . get ( calendar . day_of_month ) == caltwo . get ( calendar . day_of_month ) ) return _bool ; return _bool ; }	is it the same day.
public static void updateallforfacade ( datastore datastore , iterable < update > updates ) { updateallforfacade ( datastore , updates . iterator ( ) ) ; }	creates , updates or deletes zero or more pieces of content in the data store facades .
public arrayfieldvector ( fieldvector < t > v1 , fieldvector < t > v2 ) throws nullargumentexception { mathutils . checknotnull ( v1 ) ; mathutils . checknotnull ( v2 ) ; field = v1 . getfield ( ) ; final t [ ] v1data = ( v1 instanceof arrayfieldvector ) ? ( ( arrayfieldvector < t > ) v1 ) . data : v1 . toarray ( ) ; final t [ ] v2data = ( v2 instanceof arrayfieldvector ) ? ( ( arrayfieldvector < t > ) v2 ) . data : v2 . toarray ( ) ; data = matharrays . buildarray ( field , v1data . length + v2data . length ) ; system . arraycopy ( v1data , _num , data , _num , v1data . length ) ; system . arraycopy ( v2data , _num , data , v1data . length , v2data . length ) ; }	construct a vector by appending one vector to another vector .
public boolean equals ( object o ) { if ( o instanceof serviceconfigmanager ) { serviceconfigmanager oscm = ( serviceconfigmanager ) o ; if ( servicename . equals ( oscm . servicename ) && version . equals ( oscm . version ) ) { return ( _bool ) ; } } return ( _bool ) ; }	compares this object with the given object .
public void additemboundslistener ( itemboundslistener ibl ) { if ( m_bounders == null ) m_bounders = new copyonwritearraylist ( ) ; m_bounders . add ( ibl ) ; }	add an itemboundslistener to receive notifications when the bounds occupied by the visualitems in this display change .
public void increasedpi ( ) { if ( this . currentdpipos < ( this . dpisizes . length - _num ) ) { ++ this . currentdpipos ; } }	increase the image size ( dpi ) .
stringvector processprefix_urllist ( stylesheethandler handler , string uri , string name , string rawname , string value ) throws org . xml . sax . saxexception { stringtokenizer tokenizer = new stringtokenizer ( value , _str ) ; int nstrings = tokenizer . counttokens ( ) ; stringvector strings = new stringvector ( nstrings ) ; for ( int i = _num ; i < nstrings ; i ++ ) { string prefix = tokenizer . nexttoken ( ) ; string url = handler . getnamespaceforprefix ( prefix ) ; if ( url != null ) strings . addelement ( url ) ; else throw new org . xml . sax . saxexception ( xslmessages . createmessage ( xslterrorresources . er_cant_resolve_nsprefix , new object [ ] { prefix } ) ) ; } return strings ; }	process an attribute string of type t_urllist into a vector of prefixes that may be resolved to urls .
@ override public void write ( dataoutput out ) throws ioexception { out . writelong ( duration ) ; out . writeint ( getlength ( ) ) ; for ( int i = _num ; i < coeffs . length ; i ++ ) { out . writefloat ( coeffs [ i ] ) ; } }	write this datagram to a random access file or data output stream .
private void addsharingprofiles ( collection < sharingprofile > sharingprofiles ) throws guacamoleexception { for ( sharingprofile sharingprofile : sharingprofiles ) { string primaryconnectionidentifier = sharingprofile . getprimaryconnectionidentifier ( ) ; apiconnection primaryconnection = retrievedconnections . get ( primaryconnectionidentifier ) ; if ( primaryconnection != null ) { collection < apisharingprofile > children = primaryconnection . getsharingprofiles ( ) ; if ( children == null ) { children = new arraylist < apisharingprofile > ( ) ; primaryconnection . setsharingprofiles ( children ) ; } children . add ( new apisharingprofile ( sharingprofile ) ) ; } else logger . debug ( _str + _str + _str , sharingprofile . getidentifier ( ) , primaryconnectionidentifier ) ; } }	adds each of the provided sharing profiles to the current tree as children of their respective primary connections.
public void failovercopy ( rpcopyrequestparams copytofailoverto ) throws recoverpointexception { string bookmarkname = copytofailoverto . getbookmarkname ( ) ; date apittime = copytofailoverto . getapittime ( ) ; if ( bookmarkname != null ) { logger . info ( _str + bookmarkname ) ; } else if ( apittime != null ) { logger . info ( _str + apittime . tostring ( ) ) ; } else { logger . info ( _str ) ; } recoverpointimagemanagementutils imagemanager = new recoverpointimagemanagementutils ( ) ; imagemanager . enablecopyimage ( functionalapi , copytofailoverto , _bool ) ; }	perform a failover to the consistency group copy specified by the input request params .
private static void prepareloggingsystemenviroment ( ) { system . setproperty ( _str , getlogfolder ( ) ) ; }	initialize the logging system .
public stateattribute ( byte [ ] octets ) { super ( octets ) ; state = new string ( octets , _num , octets . length - _num , charset . forname ( _str ) ) ; }	creates a replymessageattribute from the on - the - wire octets .
private static long calcsize ( long size , long skip , long limit ) { return size >= _num ? math . max ( - _num , math . min ( size - skip , limit ) ) : - _num ; }	calculates the sliced size given the current size , number of elements skip , and the number of elements to limit .
public static collection < inetsocketaddress > resolveaddresses ( addressresolver addrrslvr , iterable < string > addrs , int port ) throws ignitespiexception { assert addrrslvr != null ; collection < inetsocketaddress > extaddrs = new hashset < > ( ) ; for ( string addr : addrs ) { inetsocketaddress sockaddr = new inetsocketaddress ( addr , port ) ; if ( ! sockaddr . isunresolved ( ) ) { collection < inetsocketaddress > extaddrs0 = resolveaddress ( addrrslvr , sockaddr ) ; if ( extaddrs0 != null ) extaddrs . addall ( extaddrs0 ) ; } } return extaddrs ; }	resolves all not loopback addresses and collect results .
@ override public void run ( ) { while ( ! isinterrupted ( ) ) { try { keyholder < k > ref = ( keyholder < k > ) _queue . remove ( ) ; v removed = _table . remove ( ref ) ; if ( _listener != null && removed != null ) _listener . weakentryremoved ( removed ) ; } catch ( interruptedexception e ) { interrupt ( ) ; break ; } } }	block on the queue until an entry is been cleaned by the gc.
public jobdefinitioncreaterequest createjobdefinitioncreaterequest ( string namespacecd , string jobname , string jobdescription , string activitixml , list < parameter > parameters ) { jobdefinitioncreaterequest request = new jobdefinitioncreaterequest ( ) ; request . setnamespace ( namespacecd ) ; request . setjobname ( jobname ) ; request . setdescription ( jobdescription ) ; request . setactivitijobxml ( activitixml ) ; request . setparameters ( parameters ) ; return request ; }	creates a new job definition create request based on user specified parameters .
public tabstate restoretabstate ( int tabid , boolean encrypted ) { return tabstate . restoretabstate ( gettabstatefile ( tabid , encrypted ) , encrypted ) ; }	restores the tabstate with the given id .
public ftpclient ( ) { addlistparser ( new unixlistparser ( ) ) ; addlistparser ( new doslistparser ( ) ) ; addlistparser ( new eplflistparser ( ) ) ; addlistparser ( new netwarelistparser ( ) ) ; addlistparser ( new mlsdlistparser ( ) ) ; }	builds and initializes the client .
public string addextension ( string testfilename ) { return testfilename + _str ; }	adds any specialized extension required by the implementation .
public < t > string makestringvaluesq ( t value ) { return value . tostring ( ) ; }	scipio : makes an escaped freemarker string value without enclosing single - quotes , as intended for a regular ( non - raw ) string.
private level descriptiontologlevel ( string description ) { level result = level . off ; if ( description . equals ( s_logger . localizemessage ( _str ) ) ) { result = level . off ; } else if ( description . equals ( s_logger . localizemessage ( _str ) ) ) { result = level . severe ; } else if ( description . equals ( s_logger . localizemessage ( _str ) ) ) { result = level . warning ; } else if ( description . equals ( s_logger . localizemessage ( _str ) ) ) { result = level . info ; } else if ( description . equals ( s_logger . localizemessage ( _str ) ) ) { result = level . config ; } else if ( description . equals ( s_logger . localizemessage ( _str ) ) ) { result = level . fine ; } else if ( description . equals ( s_logger . localizemessage ( _str ) ) ) { result = level . finer ; } else if ( description . equals ( s_logger . localizemessage ( _str ) ) ) { result = level . finest ; } else if ( description . equals ( s_logger . localizemessage ( _str ) ) ) { result = level . all ; } return result ; }	convert localized descriptive text to log level.
default boolean isimmutable ( ) { return _bool ; }	returns if this stream component will return the same stream result over time ( immutable or analytics type of data ) .
public long renew ( string entryuid , string classname , int objecttype , long duration , boolean fromreplication , boolean origin , boolean isfromgateway ) throws unknownleaseexception , internalspaceexception { try { extendleaseperiod ( entryuid , classname , objecttype , duration , fromreplication , origin , _bool , null , isfromgateway ) ; } catch ( unknownleaseexception unknownleaseexception ) { if ( _cachemanager . iscacheexternaldb ( ) && objecttype != objecttypes . notify_null_template && objecttype != objecttypes . notify_template ) { if ( _logger . isloggable ( level . fine ) ) { _logger . log ( level . fine , _str , unknownleaseexception ) ; } } else throw unknownleaseexception ; } return duration ; }	renews a lease for an additional period of time ( specified in milliseconds ) for a registered entry in this lease manager.
public jktagmapping ( ) { }	instantiates a new jk tag mapping .
public static void inrange ( final long value , final string name , final long mininclusive , final long maxinclusive ) { if ( value < mininclusive || value > maxinclusive ) { final string message = string . format ( _str , name , mininclusive , maxinclusive ) ; throw new illegalargumentexception ( message ) ; } }	throws an exception if the specified long value is not in the specified inclusive range .
public static file unziptotempfolder ( file zipfile ) { string zipfilename = zipfile . getname ( ) ; string tempfolderprefix = zipfilename . substring ( _num , zipfilename . lastindexof ( _str ) ) ; file tempfolder = createtempfolder ( tempfolderprefix ) ; try { puziputils . unzip ( zipfile , tempfolder ) ; return tempfolder ; } catch ( exception e ) { try { fileutils . deletefileordirectory ( tempfolder ) ; } catch ( runtimeexception ex ) { logger . debug ( _str + tempfolder , ex ) ; } throw new runtimeexception ( _str + zipfile + _str + tempfolder , e ) ; } }	unzips the specified zip file to a temp folder.
public void testascii ( ) throws exception { string str = _str ; bytearrayinputstream aa = new bytearrayinputstream ( str . getbytes ( _str ) ) ; inputstreamreader a = new inputstreamreader ( aa , _str ) ; try { int x = a . read ( ) ; assertequals ( _str , x ) ; char [ ] c = new char [ _num ] ; x = a . read ( c , _num , _num ) ; assertequals ( _str , a . getencoding ( ) ) ; assertequals ( _num , x ) ; assertequals ( _str , string . valueof ( c ) ) ; } finally { a . close ( ) ; } }	checks if ascii encoding works with inputstreamreader.
public void clear ( ) { m_reducedresults . clear ( ) ; m_currentsearchindex = _num ; }	resets the cursor and clears the current results .
public static void createaccessormethod ( sootmethod container , stmt stmt ) { body containerbody = container . getactivebody ( ) ; soot . util . chain containerstmts = containerbody . getunits ( ) ; if ( ! containerstmts . contains ( stmt ) ) throw new runtimeexception ( ) ; if ( stmt . containsinvokeexpr ( ) ) { createinvokeaccessor ( container , stmt ) ; } else if ( stmt instanceof assignstmt ) { assignstmt as = ( assignstmt ) stmt ; fieldref ref ; if ( as . getleftop ( ) instanceof fieldref ) { ref = ( fieldref ) as . getleftop ( ) ; createsetaccessor ( container , as , ref ) ; } else if ( as . getrightop ( ) instanceof fieldref ) { ref = ( fieldref ) as . getrightop ( ) ; creategetaccessor ( container , as , ref ) ; } else { throw new runtimeexception ( _str ) ; } } else throw new runtimeexception ( _str ) ; }	turns a field access or method call into a call to an accessor method . reuses existing accessors based on name mangling ( see createaccessorname ).
@ override public void displaychanged ( ) { updategc ( ) ; }	from the displaychangedlistener interface.
public final void pushpair ( node v1 , node v2 ) { if ( null == m_map ) { m_map = new node [ m_blocksize ] ; m_mapsize = m_blocksize ; } else { if ( ( m_firstfree + _num ) >= m_mapsize ) { m_mapsize += m_blocksize ; node newmap [ ] = new node [ m_mapsize ] ; system . arraycopy ( m_map , _num , newmap , _num , m_firstfree ) ; m_map = newmap ; } } m_map [ m_firstfree ] = v1 ; m_map [ m_firstfree + _num ] = v2 ; m_firstfree += _num ; }	push a pair of nodes into the stack.
final segment < k , v > segmentfor ( int hash ) { return segments [ ( hash > > > segmentshift ) & segmentmask ] ; }	returns the segment that should be used for key with given hash.
public static string serialize ( object toserialize ) throws exception { class < ? > xstreamclass ; java . lang . reflect . constructor < ? > constructor ; object xstream ; class < ? > [ ] serializeargsclasses = new class [ _num ] ; object [ ] serializeargs = new object [ _num ] ; java . lang . reflect . method methodserialize ; string result ; xstreamclass = class . forname ( _str ) ; constructor = xstreamclass . getconstructor ( ) ; xstream = constructor . newinstance ( ) ; serializeargsclasses [ _num ] = object . class ; serializeargs [ _num ] = toserialize ; methodserialize = xstreamclass . getmethod ( _str , serializeargsclasses ) ; try { result = ( string ) methodserialize . invoke ( xstream , serializeargs ) ; } catch ( exception ex ) { result = null ; } return result ; }	serializes the supplied object xml.
@ override public void release ( ) { super . release ( ) ; }	release aquired resources to enable tag reusage .
public void updateandtestcounter ( ofmessage ofm , string type ) { validatecounter ( type , _num ) ; counters . updatewritestats ( ofm ) ; counters . updatewritestats ( ofm ) ; counters . updatereadstats ( ofm ) ; counters . updatereadstats ( ofm ) ; validatecounter ( type , _num ) ; }	sends two messages of read and write for the given type and tests the counters.
public static < e > list < e > of ( ) { return collections . emptylist ( ) ; }	returns the empty list .
protected void drawdomaincrosshair ( graphics2d g2 , rectangle2d dataarea , plotorientation orientation , int datasetindex , comparable rowkey , comparable columnkey , stroke stroke , paint paint ) { categorydataset dataset = getdataset ( datasetindex ) ; categoryaxis axis = getdomainaxisfordataset ( datasetindex ) ; categoryitemrenderer renderer = getrenderer ( datasetindex ) ; line2d line ; if ( orientation == plotorientation . vertical ) { double xx = renderer . getitemmiddle ( rowkey , columnkey , dataset , axis , dataarea , rectangleedge . bottom ) ; line = new line2d . double ( xx , dataarea . getminy ( ) , xx , dataarea . getmaxy ( ) ) ; } else { double yy = renderer . getitemmiddle ( rowkey , columnkey , dataset , axis , dataarea , rectangleedge . left ) ; line = new line2d . double ( dataarea . getminx ( ) , yy , dataarea . getmaxx ( ) , yy ) ; } g2 . setstroke ( stroke ) ; g2 . setpaint ( paint ) ; g2 . draw ( line ) ; }	draws a domain crosshair .
@ override public table summary ( ) { table table = table . create ( _str + name ( ) ) ; categorycolumn measure = categorycolumn . create ( _str ) ; categorycolumn value = categorycolumn . create ( _str ) ; table . addcolumn ( measure ) ; table . addcolumn ( value ) ; measure . add ( _str ) ; value . add ( string . valueof ( size ( ) ) ) ; measure . add ( _str ) ; value . add ( string . valueof ( countmissing ( ) ) ) ; measure . add ( _str ) ; value . add ( string . valueof ( min ( ) ) ) ; measure . add ( _str ) ; value . add ( string . valueof ( max ( ) ) ) ; return table ; }	returns a table of dates and the number of observations of those dates.
public cvisibilitycriteriumpanel ( final cvisibilitycriterium criterium ) { super ( new borderlayout ( ) ) ; visibilitycriterium = criterium ; visibilitystatebox . addactionlistener ( visibilitystateboxlistener ) ; initpanel ( ) ; }	creates a new panel object .
public boolean isalteradd ( ) { return columnstoadd . size ( ) > _num ; }	true if the table has added columns .
private boolean processremovednode ( final inaviviewnode node ) { if ( node instanceof inavicodenode ) { final inavicodenode cnode = ( inavicodenode ) node ; try { final inavifunction targetfunction = cnode . getparentfunction ( ) ; if ( m_nodecounter . containskey ( targetfunction ) ) { final int newcounter = m_nodecounter . get ( targetfunction ) - _num ; if ( newcounter == _num ) { m_nodecounter . remove ( targetfunction ) ; final set < ccrossreference > todelete = new hashset < ccrossreference > ( ) ; for ( final ccrossreference reference : m_crossreferences ) { if ( reference . getcalledfunction ( ) == targetfunction ) { todelete . add ( reference ) ; } } m_crossreferences . removeall ( todelete ) ; return _bool ; } else { m_nodecounter . put ( targetfunction , newcounter ) ; } } } catch ( final maybenullexception exception ) { } } return _bool ; }	processes a removed node and updates the references list accordingly .
public long transferto ( long position , long count , outputstream dst ) throws ioexception { return transferto ( position , count , channels . newchannel ( dst ) ) ; }	convenience method for writing the selected portion of this channel to the given destination stream .
public void test_islenient ( ) { dateformat df = dateformat . getinstance ( ) ; calendar c = df . getcalendar ( ) ; if ( df . islenient ( ) ) { try { c . set ( calendar . day_of_month , _num ) ; c . get ( calendar . day_of_month ) ; } catch ( exception e ) { fail ( _str + e . tostring ( ) ) ; } c . setlenient ( _bool ) ; try { c . set ( calendar . day_of_month , _num ) ; c . get ( calendar . day_of_month ) ; fail ( _str ) ; } catch ( illegalargumentexception e ) { } catch ( exception e ) { fail ( _str + e . tostring ( ) ) ; } } else { try { c . set ( calendar . day_of_month , _num ) ; c . get ( calendar . day_of_month ) ; fail ( _str ) ; } catch ( illegalargumentexception e ) { } catch ( exception e ) { fail ( _str + e . tostring ( ) ) ; } c . setlenient ( _bool ) ; try { c . set ( calendar . day_of_month , _num ) ; c . get ( calendar . day_of_month ) ; } catch ( exception e ) { fail ( _str + e . tostring ( ) ) ; } } }	java . text . dateformat # islenient ( ) test of method java . text . dateformat # islenient ( ) .
private void writeindexfile ( ) throws ioexception , carbondatawriterexception { indexheader indexheader = carbonmetadatautil . getindexheader ( localcardinality , thriftcolumnschemalist ) ; list < blockindex > blockindexthrift = carbonmetadatautil . getblockindexinfo ( blockindexinfolist ) ; string filename = storelocation + file . separator + carbontablepath . getcarbonindexfilename ( carbondatafileattributes . gettaskid ( ) , carbondatafileattributes . getfacttimestamp ( ) ) ; carbonindexfilewriter writer = new carbonindexfilewriter ( ) ; writer . openthriftwriter ( filename ) ; writer . writethrift ( indexheader ) ; for ( blockindex blockindex : blockindexthrift ) { writer . writethrift ( blockindex ) ; } writer . close ( ) ; copycarbondatafiletocarbonstorepath ( filename ) ; }	below method will be used to write the idex file.
public void nackall ( pubsubreader < t > reader ) throws ioexception { checkstate ( this . reader == null , _str ) ; list < string > batchyettoackids = new arraylist < > ( math . min ( notyetreadids . size ( ) , ack_batch_size ) ) ; for ( string ackid : notyetreadids ) { batchyettoackids . add ( ackid ) ; if ( batchyettoackids . size ( ) >= ack_batch_size ) { long nowmssinceepoch = now ( reader ) ; reader . nackbatch ( nowmssinceepoch , batchyettoackids ) ; batchyettoackids . clear ( ) ; } } if ( ! batchyettoackids . isempty ( ) ) { long nowmssinceepoch = now ( reader ) ; reader . nackbatch ( nowmssinceepoch , batchyettoackids ) ; } }	blocking nack all messages which have been read from pubsub but not passed downstream.
static public void assertequals ( string message , object expected , object actual ) { if ( expected == null && actual == null ) return ; if ( expected != null && expected . equals ( actual ) ) return ; failnotequals ( message , expected , actual ) ; }	asserts that two objects are equal.
public final void computeindex ( ) { if ( indexcomputed ) { return ; } list < long > celllist = new arraylist ( ) ; list < integer > edgelist = new arraylist ( ) ; for ( int i = _num ; i < getnumedges ( ) ; ++ i ) { s2point from = edgefrom ( i ) ; s2point to = edgeto ( i ) ; arraylist < s2cellid > cover = new arraylist ( ) ; int level = getcovering ( from , to , _bool , cover ) ; minimums2levelused = math . min ( minimums2levelused , level ) ; for ( s2cellid cellid : cover ) { celllist . add ( cellid . id ( ) ) ; edgelist . add ( i ) ; } } cells = new long [ celllist . size ( ) ] ; edges = new int [ edgelist . size ( ) ] ; for ( int i = _num ; i < cells . length ; i ++ ) { cells [ i ] = celllist . get ( i ) ; edges [ i ] = edgelist . get ( i ) ; } sortindex ( ) ; indexcomputed = _bool ; }	computes the index ( if it has not been previously done ) .
public waitforanylistener ( int numberofresults ) { this ( numberofresults , null ) ; }	constructs a new listener with the number of executions this listener will be set on .
public static object stringtovalue ( string string ) { double d ; if ( string . equals ( _str ) ) { return string ; } if ( string . equalsignorecase ( _str ) ) { return boolean . true ; } if ( string . equalsignorecase ( _str ) ) { return boolean . false ; } if ( string . equalsignorecase ( _str ) ) { return jsonobject . null ; } char b = string . charat ( _num ) ; if ( ( b >= _str && b <= _str ) || b == _str || b == _str || b == _str ) { try { if ( string . indexof ( _str ) > - _num || string . indexof ( _str ) > - _num || string . indexof ( _str ) > - _num ) { d = double . valueof ( string ) ; if ( ! d . isinfinite ( ) && ! d . isnan ( ) ) { return d ; } } else { long mylong = new long ( string ) ; if ( mylong . longvalue ( ) == mylong . intvalue ( ) ) { return new integer ( mylong . intvalue ( ) ) ; } else { return mylong ; } } } catch ( exception ignore ) { } } return string ; }	try to convert a string into a number , boolean , or null.
public abstract void onpinset ( string pin ) ;	abstract method which gives the pin entered by user.
public void testcase9 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = - _num ; int bsign = - _num ; byte rbytes [ ] = { - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . add ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , result . signum ( ) ) ; }	add two negative numbers of different length.
public void removenodesfrompartition ( list < igroupmembernode > nodestoremove ) { for ( final igroupmembernode nodetoremove : nodestoremove ) { if ( nodetoremove != null ) { if ( ! nonoptionalnonminusnodes . remove ( nodetoremove ) ) { if ( nodetoremove . equals ( optionalorminus ) ) { optionalorminus = null ; } } } } recomputedefinitelyproduced ( ) ; }	removes the given set of nodes and updates the internal data structures .
public static void banner ( logger logger , class < ? > clazz , string methodname , string text ) { string string = clazz . getsimplename ( ) + _str + methodname ; if ( text != null ) { string += _str + text ; } logger . info ( _str ) ; logger . info ( _str ) ; logger . info ( _str + string ) ; logger . info ( _str ) ; }	log a banner containing the class and method name and text.
private void readobject ( objectinputstream in ) throws ioexception , classnotfoundexception { in . defaultreadobject ( ) ; if ( resourcebundlename != null ) { try { rb = resourcebundle . getbundle ( resourcebundlename ) ; } catch ( missingresourceexception e ) { rb = null ; } } }	serialization helper to setup transient resource bundle instance .
private static void exit ( @ nullable string errmsg , @ nullable options options , int exitcode ) { if ( errmsg != null ) echo ( _str + errmsg ) ; string runner = system . getproperty ( ignite_prog_name , _str ) ; int space = runner . indexof ( _str ) ; runner = runner . substring ( _num , space == - _num ? runner . length ( ) : space ) ; if ( options != null ) { helpformatter formatter = new helpformatter ( ) ; formatter . printhelp ( runner , options ) ; } system . exit ( exitcode ) ; }	exists with optional error message , usage show and exit code .
private static void replacealtspecialinstructions ( ) { fillinstructionmap ( _num , _num , new frinstruction ( instructionformat . d , _num , _num , _str , _str , _str , instruction . flowtype . none , _bool , _bool , andccru8simulationcode ) ) ; fillinstructionmap ( _num , _num , new frinstruction ( instructionformat . d , _num , _num , _str , _str , _str , instruction . flowtype . none , _bool , _bool , stilmu8simulationcode ) ) ; fillinstructionmap ( _num , _num , new frinstruction ( instructionformat . d , _num , _num , _str , _str , _str , instruction . flowtype . none , _bool , _bool , orccru8simulationcode ) ) ; fillinstructionmap ( _num , _num , new frinstruction ( instructionformat . d , _num , _num , _str , _str , _str , instruction . flowtype . none , _bool , _bool , addsps10simulationcode ) ) ; }	these are replacement names for dedicated opcodes working on ilm , ccr and sp so that they look the same as others.
@ override public boolean addsensortoroute ( string sensorname , int mode ) { if ( _controlsensorlist . size ( ) >= max_control_sensors ) { log . warn ( _str , getsystemname ( ) ) ; } controlsensor sensor = new controlsensor ( sensorname ) ; log . debug ( _str , getsystemname ( ) , sensorname ) ; if ( ! sensor . setstate ( mode ) ) { return _bool ; } if ( iscontrolsensorincluded ( sensor ) ) { log . debug ( _str , sensorname , getsystemname ( ) ) ; } else { _controlsensorlist . add ( sensor ) ; } return _bool ; }	method to add a sensor to the list of control sensors for this route .
private void eliminatebackfillstates ( int basestate ) { if ( statestobackfill . contains ( new integer ( basestate ) ) ) { statestobackfill . removeelement ( new integer ( basestate ) ) ; short [ ] state = tempstatetable . elementat ( basestate ) ; for ( int i = _num ; i < numcategories ; i ++ ) { if ( state [ i ] != _num ) { eliminatebackfillstates ( state [ i ] ) ; } } } }	this removes " ending states " and states reachable from them from the list of states to backfill .
static boolean separateconvexpolygons ( float [ ] verts1 , float [ ] verts2 , vector2 separation ) { final int length1 = verts1 . length ; final int length2 = verts2 . length ; for ( int i = _num ; i < length1 ; i += _num ) { final int j = ( i + _num ) % length1 ; float projx = verts1 [ j + _num ] - verts1 [ i + _num ] ; float projy = verts1 [ i ] - verts1 [ j ] ; final float length = ( float ) math . sqrt ( projx * projx + projy * projy ) ; projx /= length ; projy /= length ; float min1 = float . positive_infinity , max1 = float . negative_infinity ; for ( int k = _num ; k < length1 ; k += _num ) { final float dot = projx * verts1 [ k ] + projy * verts1 [ k + _num ] ; if ( dot < min1 ) min1 = dot ; if ( dot > max1 ) max1 = dot ; } float min2 = float . positive_infinity , max2 = float . negative_infinity ; for ( int k = _num ; k < length2 ; k += _num ) { final float dot = projx * verts2 [ k ] + projy * verts2 [ k + _num ] ; if ( dot < min2 ) min2 = dot ; if ( dot > max2 ) max2 = dot ; } if ( ( max1 < min2 ) || ( max2 < min1 ) ) { if ( null != separation ) separation . set ( projy , - projx ) ; return _bool ; } } return _bool ; }	check whether some of the first polygon ' s edges defined forms a separation axis of two polygons defined by the lists of vertices.
public string paymentterm ( properties ctx , int windowno , gridtab mtab , gridfield mfield , object value ) { integer c_paymentterm_id = ( integer ) value ; int c_invoice_id = env . getcontextasint ( ctx , windowno , _str ) ; if ( c_paymentterm_id == null || c_paymentterm_id . intvalue ( ) == _num || c_invoice_id == _num ) return _str ; mpaymentterm pt = new mpaymentterm ( ctx , c_paymentterm_id . intvalue ( ) , null ) ; if ( pt . get_id ( ) == _num ) return _str ; boolean valid = pt . apply ( c_invoice_id ) ; mtab . setvalue ( _str , valid ? _str : _str ) ; return _str ; }	set payment term . payment term has changed.
public static void transformcriteria ( properties formproperties , inputstream xslis , result result ) throws saxexception , ioexception , parserconfigurationexception , transformerexception { dbf . setnamespaceaware ( _bool ) ; documentbuilder builder = dbf . newdocumentbuilder ( ) ; org . w3c . dom . document xsldoc = builder . parse ( xslis ) ; domsource ds = new domsource ( xsldoc ) ; transformer transformer = null ; synchronized ( tfactory ) { transformer = tfactory . newtransformer ( ds ) ; } transformcriteria ( formproperties , transformer , result ) ; }	slower transformation using an uncompiled stylesheet ( suitable for development environment ).
public static list < byte [ ] > splitandpad ( byte [ ] bytearray , int blocksize ) { list < byte [ ] > blocks = new arraylist < byte [ ] > ( ) ; int numblocks = ( int ) math . ceil ( bytearray . length / ( double ) blocksize ) ; for ( int i = _num ; i < numblocks ; i ++ ) { byte [ ] block = new byte [ blocksize ] ; arrays . fill ( block , ( byte ) _num ) ; if ( i + _num == numblocks ) { int remainingbytes = bytearray . length - ( i * blocksize ) ; system . arraycopy ( bytearray , i * blocksize , block , _num , remainingbytes ) ; } else { system . arraycopy ( bytearray , i * blocksize , block , _num , blocksize ) ; } blocks . add ( block ) ; } return blocks ; }	splits the given array into blocks of given size and adds padding to the last one , if necessary .
public void put ( e item ) throws interruptedexception { if ( ! done . get ( ) ) { queue . put ( item ) ; } }	adds another item to the queue , blocking while the queue is full .
protected void notifycomplete ( ) { final string methodname = _str ; log . fine ( class_name , methodname , _str , new object [ ] { getkey ( ) , this . response , this . exception } ) ; synchronized ( responselock ) { if ( exception == null && pendingcomplete ) { completed = _bool ; pendingcomplete = _bool ; } else { pendingcomplete = _bool ; } responselock . notifyall ( ) ; } synchronized ( sentlock ) { sent = _bool ; sentlock . notifyall ( ) ; } }	notifies this token that a response message ( an ack or nack ) has been received .
private node < k , v > [ ] inittable ( ) { node < k , v > [ ] tab ; int sc ; while ( ( tab = table ) == null || tab . length == _num ) { if ( ( sc = sizectl ) < _num ) { thread . yield ( ) ; } else if ( u . compareandswapint ( this , sizectl , sc , - _num ) ) { try { if ( ( tab = table ) == null || tab . length == _num ) { int n = ( sc > _num ) ? sc : default_capacity ; @ suppresswarnings ( _str ) node < k , v > [ ] nt = ( node < k , v > [ ] ) new node < ? , ? > [ n ] ; table = tab = nt ; sc = n - ( n > > > _num ) ; } } finally { sizectl = sc ; } break ; } } return tab ; }	initializes table , using the size recorded in sizectl .
public synchronized boolean loadpublickey ( ) { if ( ! has ( _str ) || ! has ( _str ) ) return _bool ; string encodedkey = getstring ( _str ) ; string algorithm = getstring ( _str ) ; publickey pub = io . decodepublickey ( encodedkey , algorithm ) ; if ( pub != null ) { public_key = pub ; key_algorithm = algorithm ; setpeerhash ( ) ; return _bool ; } return _bool ; }	load public key from file.
private void loadtextdata ( datainputstream dis ) throws ioexception { for ( int f = _num ; f < numframes ; f ++ ) { times [ f ] = float . parsefloat ( general . readword ( dis ) ) ; general . readword ( dis ) ; for ( int c = _num ; c < numchannels ; c ++ ) { frames [ f ] [ c ] = float . parsefloat ( general . readword ( dis ) ) ; } } }	load the data section of the file as ascii text.
public static boolean isgzipcontent ( string contentencoding ) { return contentencoding != null && contentencoding . contains ( _str ) ; }	whether the content has been compressed .
public synchronized boolean checksize ( final int sizechecked ) { if ( ! started ) { throw new illegalstateexception ( _str ) ; } if ( sizechecked > buffersize ) { throw new illegalstateexception ( _str + buffersize + _str ) ; } if ( bufferlimit == _num || buffer . writerindex ( ) + sizechecked > bufferlimit ) { flush ( ) ; delayflush = _bool ; final int remaininginfile = bufferobserver . getremainingbytes ( ) ; if ( sizechecked > remaininginfile ) { return _bool ; } else { bufferlimit = math . min ( remaininginfile , buffersize ) ; return _bool ; } } else { delayflush = _bool ; return _bool ; } }	verify if the size fits the buffer.
public void testcomparelessscale1 ( ) { string a = _str ; int ascale = _num ; string b = _str ; int bscale = _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; int result = _num ; assertequals ( _str , result , anumber . compareto ( bnumber ) ) ; }	compare to a number of an less scale.
public void exit ( ) { exitcalled = _bool ; if ( threadmap != null ) { deleteallthreads ( ) ; log . info ( _str ) ; if ( durationstatistics . collectstatistics ) { statistics . exit ( ) ; log . info ( string . format ( _str , statistics . allcycles , statistics . getdurationmillis ( ) / _num ) ) ; collections . sort ( statistics . threads ) ; for ( statistics . threadstatistics threadstatistics : statistics . threads ) { double percentage = _num ; if ( statistics . allcycles != _num ) { percentage = ( threadstatistics . runclocks / ( double ) statistics . allcycles ) * _num ; } log . info ( string . format ( _str , threadstatistics . getquotedname ( ) , threadstatistics . runclocks , percentage ) ) ; } } } }	to be called when exiting the emulation.
private void formatnodeto ( formatter f , int level , radixtreenode < t > node ) { for ( int i = _num ; i < level ; i ++ ) { f . format ( _str ) ; } f . format ( _str ) ; for ( int i = _num ; i < level ; i ++ ) { f . format ( _str ) ; } if ( node . isreal ( ) == _bool ) f . format ( _str , node . getkey ( ) , node . getvalue ( ) ) ; else f . format ( _str , node . getkey ( ) ) ; for ( radixtreenode < t > child : node . getchildern ( ) ) { formatnodeto ( f , level + _num , child ) ; } }	warning ! do not use this for a large trie , it ' s for testing purpose only .
protected void startdownload ( int blocks ) { if ( blocks > _num ) log . info ( _str + blocks + _str + ( blocks > _num ? _str : _str ) ) ; }	called when download is initiated .
public void add ( int start , int end , int handler , int type ) { if ( start < end ) entries . add ( new exceptiontableentry ( start , end , handler , type ) ) ; }	appends a new entry at the end of the table .
private void freekick ( team offense ) { if ( gametime <= _num ) return ; else { if ( gametime < _num && ( ( gameposs && ( awayscore - homescore ) <= _num && ( awayscore - homescore ) > _num ) || ( ! gameposs && ( homescore - awayscore ) <= _num && ( homescore - awayscore ) > _num ) ) ) { if ( offense . getk ( _num ) . ratkickfum * math . random ( ) > _num || math . random ( ) < _num ) { gameeventlog += geteventprefix ( ) + offense . abbr + _str + offense . getk ( _num ) . name + _str + offense . abbr + _str ; gameyardline = _num ; gamedown = _num ; gameyardsneed = _num ; } else { gameeventlog += geteventprefix ( ) + offense . abbr + _str + offense . getk ( _num ) . name + _str ; gameposs = ! gameposs ; gameyardline = _num ; gamedown = _num ; gameyardsneed = _num ; } gametime -= _num + _num * math . random ( ) ; } else { gameyardline = ( int ) ( _num - ( offense . getk ( _num ) . ratkickpow + _num - _num * math . random ( ) ) ) ; if ( gameyardline <= _num ) gameyardline = _num ; gamedown = _num ; gameyardsneed = _num ; gameposs = ! gameposs ; gametime -= _num * math . random ( ) ; } } }	kick the ball off following a safety , turning the ball over to the other team.
private void processnewport ( long sw , short p ) { if ( islinkdiscoverysuppressed ( sw , p ) ) { return ; } iofswitch iofswitch = floodlightprovider . getswitch ( sw ) ; if ( iofswitch == null ) return ; if ( autoportfastfeature && iofswitch . isfastport ( p ) ) { return ; } nodeporttuple npt = new nodeporttuple ( sw , p ) ; discover ( sw , p ) ; if ( ! iofswitch . isfastport ( p ) ) { addtoquarantinequeue ( npt ) ; } else { addtomaintenancequeue ( npt ) ; } }	process a new port.
public static void put3byteint ( bytebuffer buffer , int val ) { put3byteint ( buffer , val , buffer . order ( ) ) ; }	put an integer into the given buffer at the given offset as a 3 - byte integer .
public static void assertnoexception ( runnable expression , string errormessage ) { if ( verbose ) { log ( _str + expression + _str + errormessage + _str ) ; } try { expression . run ( ) ; } catch ( runtimeexception failure ) { testutils . fail ( errormessage ) ; } }	asserts that no exception is raised.
@ override public int indexof ( object object ) { return indexof ( object , _num ) ; }	searches in this vector for the index of the specified object.
protected responseformattype generateacceptformat ( string format ) throws badapirequestexception { try { return format == null ? responseformattype . json : responseformattype . valueof ( format . touppercase ( locale . english ) ) ; } catch ( illegalargumentexception e ) { log . error ( accept_format_invalid . logformat ( format ) , e ) ; throw new badapirequestexception ( accept_format_invalid . format ( format ) ) ; } }	generates the format in which the response data is expected .
public sharedobject ( map < string , object > data , string name , string path , boolean persistent ) { super ( ) ; this . name = name ; this . path = path ; this . persistentso = persistent ; ownermessage = new sharedobjectmessage ( null , name , _num , persistent ) ; creationtime = system . currenttimemillis ( ) ; super . setattributes ( data ) ; }	creates new so from given data map , name , path and persistence option.
public static string datetostring ( date date ) { if ( date == null ) { return null ; } else { dateformat df = new simpledateformat ( dateformat ) ; df . settimezone ( utc ) ; return df . format ( date ) ; } }	converts a date object to a string representation .
public static string infofirstlastpixels ( imagelineint line ) { return line . imginfo . channels == _num ? string . format ( _str , line . scanline [ _num ] , line . scanline [ line . scanline . length - _num ] ) : string . format ( _str , line . scanline [ _num ] , line . scanline [ _num ] , line . scanline [ _num ] , line . scanline [ line . scanline . length - line . imginfo . channels ] , line . scanline [ line . scanline . length - line . imginfo . channels + _num ] , line . scanline [ line . scanline . length - line . imginfo . channels + _num ] ) ; }	just for basic info or debugging.
public static iterable < element > elements ( nodelist nodes ) { return null ; }	returns an iterable collection for the elements in the given node list .
public void addurl ( string url ) { set < string > urls = getcachedurls ( ) ; urls . add ( url ) ; putcachedurls ( urls ) ; updatenotification ( urls ) ; }	add a url to the store of urls.
public void testvalueoflongmax ( ) { long longval = long . max_value ; biginteger anumber = biginteger . valueof ( longval ) ; byte rbytes [ ] = { _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num } ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = anumber . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , anumber . signum ( ) ) ; }	valueof ( long val ) : convert long.
private void closedatabaseconnection ( connection connection ) { if ( connection == null ) return ; try { connection . close ( ) ; } catch ( sqlexception e ) { } connection = null ; return ; }	close a database connection.
@ override public boolean eisset ( int featureid ) { switch ( featureid ) { case informationmodelpackage . information_model__name : return name_edefault == null ? name != null : ! name_edefault . equals ( name ) ; case informationmodelpackage . information_model__namespace : return namespace_edefault == null ? namespace != null : ! namespace_edefault . equals ( namespace ) ; case informationmodelpackage . information_model__version : return version_edefault == null ? version != null : ! version_edefault . equals ( version ) ; case informationmodelpackage . information_model__references : return references != null && ! references . isempty ( ) ; case informationmodelpackage . information_model__description : return description_edefault == null ? description != null : ! description_edefault . equals ( description ) ; case informationmodelpackage . information_model__displayname : return displayname_edefault == null ? displayname != null : ! displayname_edefault . equals ( displayname ) ; case informationmodelpackage . information_model__category : return category_edefault == null ? category != null : ! category_edefault . equals ( category ) ; case informationmodelpackage . information_model__properties : return properties != null && ! properties . isempty ( ) ; } return super . eisset ( featureid ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
public void addunnamedtask ( tmmtask task ) { if ( unnamedtaskexecutor == null || unnamedtaskexecutor . isshutdown ( ) ) { unnamedtaskexecutor = createunnamedtaskexecutor ( ) ; } task . addlistener ( this ) ; task . setstate ( taskstate . queued ) ; unnamedtaskexecutor . execute ( task ) ; }	add a tasks which does not fit in the named queues ( like caching or tv show episode scraping task ).
public path ( final vertex v0 , final vertex v1 , final edgesample edgesample ) { if ( v0 == null ) throw new illegalargumentexception ( ) ; if ( v1 == null ) throw new illegalargumentexception ( ) ; if ( v0 . sample == null ) throw new illegalargumentexception ( ) ; if ( edgesample == null ) throw new illegalargumentexception ( ) ; if ( edgesample . getsample ( ) == null ) throw new illegalargumentexception ( ) ; this . vertices = new vertex [ ] { v0 , v1 } ; this . preds = getpredicates ( vertices ) ; this . edgesample = edgesample ; this . sumestread = v0 . sample . estcard + edgesample . estread ; this . sumestcard = edgesample . estcard ; this . sumestcost = getcost ( this . sumestread , this . sumestcard ) ; }	create a path from a single edge .
public boolean evaluate ( map record ) { object recval = record . get ( keyfield ) ; return op . evaluate ( this . val , recval ) ; }	asks the op class to evaluate the provided value against the rules value .
public char [ ] tochararray ( ) { charset utf8 = charset . forname ( _str ) ; charbuffer charbuffer = utf8 . decode ( bytebuffer . wrap ( buffer , offset , length ) ) ; char [ ] chars = new char [ charbuffer . remaining ( ) ] ; charbuffer . get ( chars ) ; return chars ; }	returns the utf - 8 decoded char array representation of this byte sequence .
public static byte [ ] chars2utf ( char [ ] src , int sindex , int len ) { byte [ ] dst = new byte [ len * _num ] ; int len1 = chars2utf ( src , sindex , dst , _num , len ) ; byte [ ] result = new byte [ len1 ] ; system . arraycopy ( dst , _num , result , _num , len1 ) ; return result ; }	return characters as an array of bytes in utf8 representation .
public static void agentmain ( string agentargs , instrumentation inst ) throws exception { synchronized ( jvmagent . class ) { if ( instance == null ) { instance = new jvmagent ( inst ) ; waitforinstance . countdown ( ) ; } } }	when the agent gets loaded , this method is called , giving us an instrumentation instance . voila !.
public void close ( ) { handler [ ] handlerarray = m_logger . gethandlers ( ) ; for ( int i = _num ; i < handlerarray . length ; i ++ ) { handler h = handlerarray [ i ] ; h . flush ( ) ; h . close ( ) ; m_logger . removehandler ( h ) ; } }	close and remove the handlers.
public string tostring ( ) { if ( val == null ) return _str ; if ( val instanceof long || val instanceof integer ) { return long . tostring ( val . longvalue ( ) ) ; } double d = val . doublevalue ( ) ; if ( double . isinfinite ( d ) ) return ( d > _num ) ? _str : _str ; if ( double . isnan ( d ) ) return _str ; return double . tostring ( d ) ; }	returns the string representing the object.
public static list < string > splittext ( string text ) { int startline = _num ; int i = _num ; int n = text . length ( ) ; arraylist < string > rc = new arraylist < string > ( ) ; while ( i < n ) { switch ( text . charat ( i ) ) { case _str : i ++ ; if ( i < n && text . charat ( i ) == _str ) { i ++ ; } rc . add ( text . substring ( startline , i ) ) ; startline = i ; break ; case _str : i ++ ; if ( i < n && text . charat ( i ) == _str ) { i ++ ; } rc . add ( text . substring ( startline , i ) ) ; startline = i ; break ; default : i ++ ; } } if ( startline == text . length ( ) ) { rc . add ( _str ) ; } else { rc . add ( text . substring ( startline , i ) ) ; } return rc ; }	split text into lines.
countrycodesource maybestripinternationalprefixandnormalize ( stringbuilder number , string possibleiddprefix ) { if ( number . length ( ) == _num ) { return countrycodesource . from_default_country ; } matcher m = plus_chars_pattern . matcher ( number ) ; if ( m . lookingat ( ) ) { number . delete ( _num , m . end ( ) ) ; normalize ( number ) ; return countrycodesource . from_number_with_plus_sign ; } pattern iddpattern = regexcache . getpatternforregex ( possibleiddprefix ) ; normalize ( number ) ; return parseprefixasidd ( iddpattern , number ) ? countrycodesource . from_number_with_idd : countrycodesource . from_default_country ; }	strips any international prefix ( such as + , 00 , 011 ) present in the number provided , normalizes the resulting number , and indicates if an international prefix was present .
@ override public void write ( int value ) { digest . update ( ( byte ) value ) ; }	updates a digest with one byte .
public boolean ismanufactured ( boolean ignoresupplierproducts ) { list < genericvalue > supplierproducts = null ; try { supplierproducts = product . getrelated ( _str , utilmisc . tomap ( _str , _str ) , utilmisc . tolist ( _str ) , _bool ) ; } catch ( genericentityexception gee ) { debug . logerror ( _str , module ) ; } supplierproducts = entityutil . filterbydate ( supplierproducts , utildatetime . nowtimestamp ( ) , _str , _str , _bool ) ; return childrennodes . size ( ) > _num && ( ignoresupplierproducts || utilvalidate . isempty ( supplierproducts ) ) ; }	a part is considered manufactured if it has child nodes and unless ignoresupplierproducts is set , if it also has no unexpired supplierproducts defined.
private void addcodefromfield ( stringbuilder sb , field f ) { try { sb . append ( f . getname ( ) + _str + f . getint ( keyevent . class ) ) ; } catch ( illegalargumentexception e ) { e . printstacktrace ( ) ; } catch ( illegalaccessexception e ) { e . printstacktrace ( ) ; } sb . append ( _str ) ; }	add a new line of code that defines the field constant.
protected boolean scrollup ( textview widget , spannable buffer , int amount ) { final layout layout = widget . getlayout ( ) ; final int top = widget . getscrolly ( ) ; int topline = layout . getlineforvertical ( top ) ; if ( layout . getlinetop ( topline ) == top ) { topline -= _num ; } if ( topline >= _num ) { topline = math . max ( topline - amount + _num , _num ) ; touch . scrollto ( widget , layout , widget . getscrollx ( ) , layout . getlinetop ( topline ) ) ; return _bool ; } return _bool ; }	performs a scroll up action.
public void load ( string filename ) { ++ nummappings ; loadclassfile ( filename ) ; }	load the class map from file .
protected void fillfacetoolbar ( jtoolbar facetb , buttongroup bg ) { for ( edittoolloader loader : loaderlist ) { string [ ] classnames = loader . geteditableclasses ( ) ; for ( int i = _num ; i < classnames . length ; i ++ ) { imageicon icon = loader . geticon ( classnames [ i ] ) ; jtogglebutton btn = new jtogglebutton ( icon , _bool ) ; btn . settooltiptext ( loader . getprettyname ( classnames [ i ] ) ) ; btn . setfocusable ( _bool ) ; btn . setactioncommand ( classnames [ i ] ) ; btn . addactionlistener ( this ) ; bg . add ( btn ) ; facetb . add ( btn ) ; } } }	fill the face ' s toolbar with buttons.
public void writetofile ( file filename ) throws ioexception { fileutils . stringtofile ( mtext . tostring ( ) , filename ) ; }	write the reference . txt to a file.
protected void transformrectstouch ( arraylist < rectf > rects ) { for ( int i = _num ; i < rects . size ( ) ; i ++ ) { mmatrixtouch . maprect ( rects . get ( i ) ) ; } }	transforms the given rect objects with the touch matrix only.
@ override public string tostring ( ) { stringbuilder buf = new stringbuilder ( ) ; for ( namevaluepair pair : namevaluepairlist ) { buf . append ( _str ) ; buf . append ( pair . getname ( ) ) ; buf . append ( _str ) ; buf . append ( _str ) ; buf . append ( getquotedattributevalue ( pair . getvalue ( ) ) ) ; buf . append ( _str ) ; } return buf . tostring ( ) ; }	return the attribute list as a string which can be directly output as part of an xml tag .
@ override public final int arrayoffset ( ) { return protectedarrayoffset ( ) ; }	returns the offset of the byte array which this buffer is based on , if there is one.
public domtestdocumentbuilderfactory newinstance ( documentbuildersetting [ ] newsettings ) throws domtestincompatibleexception { if ( newsettings == null ) { return this ; } documentbuildersetting [ ] mergedsettings = mergesettings ( newsettings ) ; return new batiktestdocumentbuilderfactory ( mergedsettings ) ; }	create new instance of document builder factory reflecting specified settings .
public float [ ] valuearray ( float [ ] array ) { if ( array == null || array . length != size ( ) ) { array = new float [ count ] ; } system . arraycopy ( values , _num , array , _num , count ) ; return array ; }	fill an already - allocated array with the values ( more efficient than creating a new array each time ).
public static set < typevariable > methodtypetotargets ( final annotatedexecutabletype methodtype ) { final list < annotatedtypevariable > annotatedtypevars = methodtype . gettypevariables ( ) ; final set < typevariable > targets = new linkedhashset < > ( annotatedtypevars . size ( ) ) ; for ( final annotatedtypevariable atv : annotatedtypevars ) { targets . add ( atv . getunderlyingtype ( ) ) ; } return targets ; }	given an annotatedexecutabletype return a set of type variables that represents the generic type parameters of that method.
private void validatetablemetadatasinglerow ( string tablenamepattern , string [ ] types , map < tablemetadata , object > validationrules ) throws exception { checkvalidationrulescomplete ( validationrules ) ; try ( resultset tables = dbmd . gettables ( null , null , tablenamepattern , types ) ) { asserttrue ( _str , tables . next ( ) ) ; validaterowvalues ( tables , validationrules ) ; assertfalse ( _str , tables . next ( ) ) ; } }	helper method for test methods that retrieve a single metadata row .
public void flush ( ) throws ioexception { try { _writer . write ( _buffer , _num , _pos ) ; _writer . flush ( ) ; } catch ( ioexception except ) { if ( _exception == null ) _exception = except ; throw except ; } _pos = _num ; }	flush the output stream.
private javascriptrelationsets ( ) { }	prevent instantiation of this name - space class .
private jmenu makeloglevelmenu ( ) { return new loglevelmenu ( ) ; }	creates the log level menu for the current log .
@ override public void close ( ) throws ioexception { synchronized ( lock ) { buf = null ; in . close ( ) ; } }	closes this reader . this implementation closes the source reader and releases the pushback buffer .
public dgetalias ( jframe parent , string title , string alias ) { super ( parent , title , dialog . modalitytype . document_modal ) ; initcomponents ( alias ) ; }	creates a new dgetalias dialog .
public static arraylist < hop > deepcopyhopsdag ( arraylist < hop > hops ) throws hopsexception { arraylist < hop > ret = new arraylist < hop > ( ) ; try { hashmap < long , hop > memo = new hashmap < long , hop > ( ) ; for ( hop hoproot : hops ) ret . add ( rdeepcopyhopsdag ( hoproot , memo ) ) ; } catch ( exception ex ) { throw new hopsexception ( ex ) ; } return ret ; }	deep copy of hops dags for parallel recompilation .
public void addall ( t ... items ) { if ( meventdelegate != null ) meventdelegate . adddata ( items == null ? _num : items . length ) ; if ( items != null && items . length != _num ) { synchronized ( mlock ) { collections . addall ( mobjects , items ) ; } } if ( mnotifyonchange ) notifydatasetchanged ( ) ; }	adds the specified items at the end of the array .
private void replaceimpl ( final int startindex , final int endindex , final int removelen , final string insertstr , final int insertlen ) { final int newsize = size - removelen + insertlen ; if ( insertlen != removelen ) { ensurecapacity ( newsize ) ; system . arraycopy ( buffer , endindex , buffer , startindex + insertlen , size - endindex ) ; size = newsize ; } if ( insertlen > _num ) { insertstr . getchars ( _num , insertlen , buffer , startindex ) ; } }	internal method to delete a range without validation .
public void updatecheque_dd_card_deposit_receipt ( final map instrumentdetailsmap ) { updateinstrumentandpayinsql ( instrumentdetailsmap ) ; addtobankreconcilationsql ( instrumentdetailsmap ) ; }	this method will be called for remit to bank in case of cheque / dd / card / atm / online deposit where a receipt voucher is generated this api will be used for only when it is called in loop.
public void testtestislast ( ) throws sqlexception { assertfalse ( target . islast ( ) ) ; target . absolute ( - _num ) ; asserttrue ( target . islast ( ) ) ; assertfalse ( emptytarget . islast ( ) ) ; assertfalse ( emptytarget . next ( ) ) ; assertfalse ( emptytarget . islast ( ) ) ; try { target . close ( ) ; target . islast ( ) ; fail ( _str ) ; } catch ( sqlexception e ) { } }	second block first assertion fails.
public final void addhelpertext ( @ nonnull final charsequence helpertext ) { ensurenotnull ( helpertext , _str ) ; ensurenotempty ( helpertext , _str ) ; if ( ! helpertexts . contains ( helpertext ) ) { helpertexts . add ( helpertext ) ; verifypasswordstrength ( ) ; } }	adds a new helper text , which should be shown , depending on the password strength.
void waitforlogentry ( int index , int timeout ) throws gondolaexception , interruptedexception , timeoutexception { reset ( ) ; this . index = index ; long endts = timeout < _num ? long . max_value : gondola . getclock ( ) . now ( ) + timeout ; lock . lock ( ) ; try { while ( status == command . status_none && gondola . getclock ( ) . now ( ) < endts ) { if ( timeout < _num ) { updatecond . await ( ) ; } else { updatecond . await ( timeout , timeunit . milliseconds ) ; } } if ( this . index != index ) { logger . error ( _str ) ; } } finally { lock . unlock ( ) ; } switch ( status ) { case command . status_none : status = command . status_timeout ; throw new timeoutexception ( string . format ( _str , timeout , index ) ) ; case command . status_not_leader : assert _bool ; break ; case command . status_slave_mode : throw new gondolaexception ( gondolaexception . code . slave_mode , cmember . memberid ) ; case command . status_error : throw new illegalstateexception ( _str + index + _str + errormessage ) ; case command . status_ok : break ; } }	this should not be called by clients.
public static string generatenativeguid ( dbclient dbclient , volume volume ) throws ioexception { storagesystem device = dbclient . queryobject ( storagesystem . class , volume . getstoragecontroller ( ) ) ; return string . format ( _str + volume + _str , _devicetypemap . get ( device . getsystemtype ( ) ) , device . getserialnumber ( ) , volume . getnativeid ( ) ) ; }	generates the format storagesystem + serialnumber + volume + nativeid native guid for volume objects.
public agentmappings saveagentmappings ( agentmappings agentmappings , boolean checkenvironments ) throws businessexception , jaxbexception , ioexception { if ( checkenvironments ) { checkenvironments ( agentmappings ) ; } agentmappings current ; do { current = agentmappingsreference . get ( ) ; if ( current . getrevision ( ) != agentmappings . getrevision ( ) ) { throw new businessexception ( _str , configurationinterfaceerrorcodeenum . revision_check_failed ) ; } } while ( ! agentmappingsreference . compareandset ( current , agentmappings ) ) ; agentmappings . setrevision ( agentmappings . getrevision ( ) + _num ) ; saveagentmapping ( agentmappings ) ; publishagentmappingsupdateevent ( ) ; return agentmappings ; }	sets the agent mappings to be used .
public e push ( e object ) { addelement ( object ) ; return object ; }	pushes the specified object onto the top of the stack .
protected void newcertbtnlistener ( ) { newcertificatedialogdata data = new newcertificatedialogdata ( ) ; newcertificatedialog dialog = new newcertificatedialog ( getshell ( ) , data , _str ) ; int returncode = dialog . open ( ) ; if ( returncode == window . ok ) { string certpath = data . getcerfilepath ( ) ; certtxt . settext ( certpath != null ? certpath . replace ( _str , _str ) : certpath ) ; certinfotxt . settext ( getcertinfo ( certtxt . gettext ( ) ) ) ; } }	listener for new button .
public static void generatemov ( final itranslationenvironment environment , final long baseoffset , final iinstruction instruction , final list < reilinstruction > instructions ) throws internaltranslationexception { preconditions . checknotnull ( environment , _str ) ; preconditions . checknotnull ( instruction , _str ) ; preconditions . checknotnull ( instructions , _str ) ; long reiloffset = baseoffset ; final list < ? extends ioperandtree > operands = instruction . getoperands ( ) ; final translationresult loadsource = helpers . translateoperand ( environment , reiloffset , operands . get ( _num ) , _bool ) ; instructions . addall ( loadsource . getinstructions ( ) ) ; reiloffset = baseoffset + instructions . size ( ) ; final translationresult loaddest = helpers . translateoperand ( environment , reiloffset , operands . get ( _num ) , _bool ) ; instructions . addall ( loaddest . getinstructions ( ) ) ; reiloffset = baseoffset + instructions . size ( ) ; helpers . writeback ( environment , reiloffset , operands . get ( _num ) , loadsource . getregister ( ) , loaddest . getsize ( ) , loaddest . getaddress ( ) , loaddest . gettype ( ) , instructions ) ; }	generates code for a mov or cmovcc instruction.
public void characters ( char ch [ ] , int start , int length ) throws org . xml . sax . saxexception { if ( ! m_shouldprocess ) return ; xsltelementprocessor elemprocessor = getcurrentprocessor ( ) ; xsltelementdef def = elemprocessor . getelemdef ( ) ; if ( def . gettype ( ) != xsltelementdef . t_pcdata ) elemprocessor = def . getprocessorfor ( null , _str ) ; if ( null == elemprocessor ) { if ( ! xmlcharacterrecognizer . iswhitespace ( ch , start , length ) ) error ( xslmessages . createmessage ( xslterrorresources . er_nonwhitespace_not_allowed_in_position , null ) , null ) ; } else elemprocessor . characters ( this , ch , start , length ) ; }	receive notification of character data inside an element .
public void testbug68562 ( ) throws exception { testbug68562batchwithsize ( _num ) ; testbug68562batchwithsize ( _num ) ; }	tests fix for bug # 68562 - combination rewritebatchedstatements and useaffectedrows not working as expected.
public vec2 tovector ( point2d v ) { return new vec2 ( tometers ( v . getx ( ) ) , tometers ( - v . gety ( ) ) ) ; }	converts a vector of type point2d to vector of type vec2.
@ override public void terminateanyrestoresessions ( storagesystem storage , blockobject from , uri volume , taskcompleter taskcompleter ) throws exception { blockobject blockobject = blockobject . fetch ( _dbclient , volume ) ; collection < cimobjectpath > syncobjects = null ; if ( storage . checkifvmax3 ( ) ) { syncobjects = _helper . getsettingsdefinestatepaths ( storage , blockobject , ( blocksnapshot ) from ) ; } else { syncobjects = getrestoredormixedstatesyncobjects ( storage , blockobject ) ; } for ( cimobjectpath syncobject : syncobjects ) { resumesnapshot ( storage , from , blockobject , syncobject , taskcompleter ) ; } }	given a snapshot and a uri of its parent volume , look up any existing restore sessions and terminate them .
public static < t > set < t > toset ( t obj1 , t obj2 , t obj3 , t obj4 , t obj5 , t obj6 ) { set < t > theset = new linkedhashset < t > ( ) ; theset . add ( obj1 ) ; theset . add ( obj2 ) ; theset . add ( obj3 ) ; theset . add ( obj4 ) ; theset . add ( obj5 ) ; theset . add ( obj6 ) ; return theset ; }	create a set from passed objx parameters.
protected void writegraphicctrlext ( ) throws ioexception { out . write ( _num ) ; out . write ( _num ) ; out . write ( _num ) ; int transp , disp ; if ( transparent == - _num ) { transp = _num ; disp = _num ; } else { transp = _num ; disp = _num ; } if ( dispose >= _num ) { disp = dispose & _num ; } disp <<= _num ; out . write ( _num | disp | _num | transp ) ; writeshort ( delay ) ; out . write ( transindex ) ; out . write ( _num ) ; }	writes graphic control extension.
public final double dooperation ( ) throws operatorfailedexception { int index ; if ( updatemap == null ) { index = mathutils . nextint ( parameter . getdimension ( ) ) ; } else { index = updatemap . get ( mathutils . nextint ( updatemapsize ) ) ; } double draw = ( _num * mathutils . nextdouble ( ) - _num ) * windowsize ; double newvalue = parameter . getparametervalue ( index ) + draw ; final bounds < double > bounds = parameter . getbounds ( ) ; final double lower = ( loweroperatorbound == null ? bounds . getlowerlimit ( index ) : math . max ( bounds . getlowerlimit ( index ) , loweroperatorbound ) ) ; final double upper = ( upperoperatorbound == null ? bounds . getupperlimit ( index ) : math . min ( bounds . getupperlimit ( index ) , upperoperatorbound ) ) ; if ( condition == boundarycondition . reflecting ) { newvalue = reflectvalue ( newvalue , lower , upper ) ; } else if ( condition == boundarycondition . absorbing && ( newvalue < lower || newvalue > upper ) ) { return _num ; } else if ( newvalue < lower || newvalue > upper ) { throw new operatorfailedexception ( _str ) ; } parameter . setparametervalue ( index , newvalue ) ; return _num ; }	change the parameter and return the hastings ratio .
public collection < object > injectables ( ) { return collections . emptylist ( ) ; }	this method returns spi internal instances that need to be injected as well.
private void updateeffectivedimensions ( ) { effectivewidth = math . max ( _num , width - leftborder - rightborder ) ; effectiveheight = math . max ( _num , height - topborder - bottomborder ) ; }	updates the effective dimensions .
public void addattribute ( attributeinfo info ) { if ( attribute == null ) attribute = new arraylist ( ) ; attributeinfo . remove ( attribute , info . getname ( ) ) ; attribute . add ( info ) ; }	appends an attribute . if there is already an attribute with the same name , the new one substitutes for it .
public void addline ( string text ) throws badlocationexception { if ( text == null || text . length ( ) == _num || text . equals ( _str ) ) { return ; } document . replace ( document . getlength ( ) , _num , text ) ; }	contrary to addincrement ( string ) , this method does not verify that the input terminates with the newline separator.
protected void mutebuttonpressed ( actionevent e ) { jtogglebutton b = ( jtogglebutton ) e . getsource ( ) ; log . debug ( _str + b . isselected ( ) ) ; firepropertychange ( propertychangeid . mute , ! b . isselected ( ) , b . isselected ( ) ) ; }	handle " mute " button press.
public twodpoint ( string s ) { stringtokenizer st = new stringtokenizer ( s , _str ) ; x = double . valueof ( st . nexttoken ( ) ) ; y = double . valueof ( st . nexttoken ( ) ) ; }	construct when given a comma - separated string of x , y values as double.
private void readobject ( final objectinputstream in ) throws ioexception , classnotfoundexception { in . defaultreadobject ( ) ; init ( ) ; }	create the object after serialization.
public static boolean isclasssupport ( string clzname ) { try { class . forname ( clzname ) ; return _bool ; } catch ( classnotfoundexception e ) { return _bool ; } }	check if the class is valid by clzname.
public void addpopuplistener ( final popuplistener listener ) { if ( ! popuplisteners . contains ( listener ) ) { popuplisteners . add ( listener ) ; } }	adds a listener which will be notified when the popup is opened .
public static byte [ ] decode ( byte [ ] data ) { int len = data . length / _num * _num ; bytearrayoutputstream bout = new bytearrayoutputstream ( len ) ; try { encoder . decode ( data , _num , data . length , bout ) ; } catch ( exception e ) { throw new decoderexception ( _str + e . getmessage ( ) , e ) ; } return bout . tobytearray ( ) ; }	decode the base 64 encoded input data.
public static string buildselectorfromattributetypeandvalue ( string attributetype , string attributevalue ) { stringbuilder strb = new stringbuilder ( ) ; strb . append ( open_bracket ) ; strb . append ( attributetype ) ; strb . append ( equal ) ; strb . append ( attributevalue ) ; strb . append ( close_bracket ) ; return strb . tostring ( ) ; }	create a selector of the form [ $ attributetype = $ attributevalue ].
public static bitmap scalefit ( bitmap src , int maxw , int maxh ) { float ratio = math . min ( maxw / ( float ) src . getwidth ( ) , maxh / ( float ) src . getheight ( ) ) ; int neww = ( int ) ( src . getwidth ( ) * ratio ) ; int newh = ( int ) ( src . getheight ( ) * ratio ) ; return scale ( src , neww , newh ) ; }	scaling bitmap to fit required sizes.
public file ( string dirpath , string name ) { if ( name == null ) { throw new nullpointerexception ( _str ) ; } if ( dirpath == null || dirpath . isempty ( ) ) { this . path = fixslashes ( name ) ; } else if ( name . isempty ( ) ) { this . path = fixslashes ( dirpath ) ; } else { this . path = fixslashes ( join ( dirpath , name ) ) ; } }	constructs a new file using the specified directory path and file name , placing a path separator between the two .
void decodeattributebody ( byte [ ] attributevalue , char offset , char length ) { username = new byte [ length ] ; system . arraycopy ( attributevalue , offset , username , _num , length ) ; }	copies the value of the username attribute from the specified attributevalue .
public static string normalizeinet4address ( string ip4string ) { final int [ ] octets = parseinet4address ( ip4string ) ; if ( octets == null ) { return null ; } stringbuilder sb = new stringbuilder ( ) ; for ( int i = _num ; i < _num ; i ++ ) { if ( i > _num ) { sb . append ( _str ) ; } sb . append ( octets [ i ] ) ; } return sb . tostring ( ) ; }	normalize a string representing an ipv4 address to the canonical representation with four decimal octets ( d.
public static int [ ] shuffle ( int [ ] input ) { list < integer > vals = new arraylist < integer > ( input . length ) ; for ( int i = _num ; i < input . length ; i ++ ) vals . add ( input [ i ] ) ; collections . shuffle ( vals , seeded_random ) ; int [ ] copy = new int [ input . length ] ; for ( int i = _num ; i < input . length ; i ++ ) copy [ i ] = vals . get ( i ) ; return copy ; }	weirdly java doesn ' t seem to have arrays.
public boolean offer ( pooledconnection pooledconnection ) { acquiredconnections . remove ( pooledconnection ) ; boolean offer = queue . offer ( pooledconnection ) ; if ( ! offer ) { pooledconnection . dispose ( ) ; } if ( isterminating . get ( ) ) { pooledconnection poll = queue . poll ( ) ; if ( poll != null ) { poll . dispose ( ) ; } } return offer ; }	offer a connections back to the queue.
private int parsestyleindefaultworkspace ( geoserverrestreader reader , int count , list < stylewrapper > stylelist ) { reststylelist geoserverstylelist = reader . getstyles ( ) ; for ( string style : geoserverstylelist . getnames ( ) ) { stylewrapper newstylewrapper = new stylewrapper ( default_workspace_name , style ) ; stylelist . add ( newstylewrapper ) ; if ( parentobj != null ) { parentobj . readstylesprogress ( connection , count , count ) ; } count ++ ; } return count ; }	parses the style in default workspace .
private classsignature loadclassfromjigsaw ( string classname ) throws ioexception { if ( method_class_getmodule == null || method_module_getname == null ) { return null ; } final class < ? > clazz ; final string modulename ; try { clazz = class . forname ( classname , _bool , loader ) ; final object module = method_class_getmodule . invoke ( clazz ) ; modulename = ( string ) method_module_getname . invoke ( module ) ; } catch ( exception e ) { return null ; } return new classsignature ( clazz , asmutils . isruntimemodule ( modulename ) ) ; }	loads the bytecode from java9 ' s module system.
public void testconnectantsensor_cadence ( ) { if ( ! runtest ) { log . d ( tag , bigtestutils . disable_message ) ; return ; } useantseonsor ( ) ; asserttrue ( checksensorsstatus_notrecording ( ) ) ; checkantsensorsstatus ( r . id . sensor_state_cadence ) ; }	tests connecting to a cadence ant + sensor .
@ override public boolean equals ( object obj ) { if ( this == obj ) { return _bool ; } if ( obj == null ) { return _bool ; } if ( getclass ( ) != obj . getclass ( ) ) { return _bool ; } diff other = ( diff ) obj ; if ( operation != other . operation ) { return _bool ; } if ( text == null ) { if ( other . text != null ) { return _bool ; } } else if ( ! text . equals ( other . text ) ) { return _bool ; } return _bool ; }	is this diff equivalent to another diff ?.
public void clearattributespecs ( ) { if ( m_attributespecs == null ) { m_attributespecs = new arraylist < attributespec > ( ) ; } m_attributespecs . clear ( ) ; }	clear the list of attribute specifications.
public void loadproperties ( boolean silent ) { loadpropertiesfile ( system . getproperty ( properties_file , _str ) , silent ) ; initializeproperties ( ) ; }	load and initialize a properties file from the default path.
@ override public void start ( ) { try { journalclientendpoint endpoint = connect ( ) ; if ( endpoint != null ) { outputstream os ; _os = os = endpoint . startmessage ( ) ; if ( os != null ) { os . write ( _str ) ; } } } catch ( exception e ) { log . finer ( e . tostring ( ) ) ; } }	start a journalled message .
static private int readbytes ( int c [ ] , int len , inputstream is ) throws ioexception { byte buf [ ] = new byte [ len ] ; if ( is . read ( buf , _num , len ) < len ) { return - _num ; } for ( int i = _num ; i < len ; i ++ ) { c [ i ] = buf [ i ] & _num ; } return _num ; }	tries to read the specified number of bytes from the stream returns - 1 , if eof is reached before len bytes are read , returns 0 otherwise.
public static void sort ( object [ ] array ) { if ( array . length > _num ) { arrays . sort ( array , instance ) ; } }	sort the given array with a default ordercomparator.
public static int expectedsizeofprobabilitytable ( randomvariable ... vars ) { int expectedsizeofdistribution = _num ; if ( null != vars ) { for ( randomvariable rv : vars ) { if ( ! ( rv . getdomain ( ) instanceof finitedomain ) ) { throw new illegalargumentexception ( _str + rv ) ; } finitedomain d = ( finitedomain ) rv . getdomain ( ) ; expectedsizeofdistribution *= d . size ( ) ; } } return expectedsizeofdistribution ; }	calculated the expected size of a probabilitytable for the provided random variables .
native private static void initialize ( string applicationid ) ;	com initialization should be invoked once per process.
public networkconnectivitylistener ( ) { mstate = state . unknown ; }	create a new networkconnectivitylistener .
vector processsimplepatternlist ( stylesheethandler handler , string uri , string name , string rawname , string value , elemtemplateelement owner ) throws org . xml . sax . saxexception { try { stringtokenizer tokenizer = new stringtokenizer ( value , _str ) ; int npatterns = tokenizer . counttokens ( ) ; vector patterns = new vector ( npatterns ) ; for ( int i = _num ; i < npatterns ; i ++ ) { xpath pattern = handler . creatematchpatternxpath ( tokenizer . nexttoken ( ) , owner ) ; patterns . addelement ( pattern ) ; } return patterns ; } catch ( transformerexception te ) { throw new org . xml . sax . saxexception ( te ) ; } }	process an attribute string of type t_simplepatternlist into a vector of xpath match patterns .
public void addcopy ( iresource copy , copyarguments arguments ) { if ( fcopy == null ) { fcopy = new arraylist ( _num ) ; fcopyarguments = new arraylist ( _num ) ; } fcopy . add ( copy ) ; fcopyarguments . add ( arguments ) ; addcopydelta ( copy , arguments ) ; }	adds the given resource to the list of resources to be copied .
public void insert_trace ( polyline p_polyline , int p_layer , int p_half_width , netnoslist p_net_no_arr , int p_clearance_class , itemfixstate p_fixed_state ) { brdtracep new_trace = insert_trace_without_cleaning ( p_polyline , p_layer , p_half_width , p_net_no_arr , p_clearance_class , p_fixed_state ) ; if ( new_trace == null ) return ; new_trace . normalize ( changed_area . get_area ( p_layer ) ) ; }	inserts a trace into the board , whose geometry is described by a polyline.
void sendtransmit ( multiplexconnectioninfo info , byte buf [ ] , int off , int len ) throws ioexception { synchronized ( dataout ) { if ( alive && ! info . closed ) try { dataout . writebyte ( transmit ) ; dataout . writeshort ( info . id ) ; dataout . writeint ( len ) ; dataout . write ( buf , off , len ) ; dataout . flush ( ) ; } catch ( ioexception e ) { multiplexlog . log ( log . brief , _str , e ) ; shutdown ( ) ; throw e ; } } }	send packet of requested data on connection to remote endpoint .
public < t extends sqlexception > t toflatsqlexception ( class < t > type ) throws classcastexception { return type . cast ( toflatsqlexception ( ) ) ; }	converts the builder to the appropriate sqlexception instance and casts to the specified type t .
public void addtotalresultcountcookie ( workbenchrequest req , httpservletresponse resp , int value ) { addcookie ( req , resp , _str , string . valueof ( value ) ) ; }	add a ' total_result_count ' cookie.
abstract void startpoll ( int fd , int events ) ;	register file descriptor with polling mechanism for given events.
private rectangle integerise ( rectangle2d rect ) { int x0 = ( int ) math . ceil ( rect . getminx ( ) ) ; int y0 = ( int ) math . ceil ( rect . getminy ( ) ) ; int x1 = ( int ) math . floor ( rect . getmaxx ( ) ) ; int y1 = ( int ) math . floor ( rect . getmaxy ( ) ) ; return new rectangle ( x0 , y0 , ( x1 - x0 ) , ( y1 - y0 ) ) ; }	trims a rectangle to integer coordinates .
@ override public void mousemoved ( mouseevent evt ) { delegate . mousemoved ( evt ) ; }	pass mouseevent straight through to delegate.
protected void validateconfig ( ) { a . notnull ( getstreamer ( ) , _str ) ; a . notnull ( getignite ( ) , _str ) ; a . notnull ( endpointurl , _str ) ; a . ensure ( getsingletupleextractor ( ) != null || getmultipletupleextractor ( ) != null , _str ) ; string followparam = apiparams . get ( site_user_id_key ) ; a . ensure ( followparam != null && followparam . matches ( _str ) , _str ) ; }	validates config at start .
public long [ ] selectzero ( long rank , long [ ] dest , final int offset , final int length ) { if ( length == _num ) return dest ; long s = selectzero ( rank ) ; dest [ offset ] = s ; int curr = ( int ) ( s / long . size ) ; long window = ~ bits [ curr ] & - _num << s ; window &= window - _num ; for ( int i = _num ; i < length ; i ++ ) { while ( window == _num ) window = ~ bits [ ++ curr ] ; dest [ offset + i ] = curr * long . size + long . numberoftrailingzeros ( window ) ; window &= window - _num ; } return dest ; }	performs a bulk select of consecutive ranks into a given array fragment .
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return string_field ; case _num : return set_field ; case _num : return list_field ; case _num : return binary_field ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public int size ( ) { synchronized ( children ) { return children . size ( ) ; } }	gets the number of children currently nested in this beancontext .
private string flattencomment ( string string ) { stringbuffer buffer = new stringbuffer ( string . length ( ) + _num ) ; boolean skipadjacentlineseparator = _bool ; for ( int i = _num ; i < string . length ( ) ; i ++ ) { char c = string . charat ( i ) ; if ( c == _str || c == _str ) { if ( ! skipadjacentlineseparator ) buffer . append ( policy . bind ( _str ) ) ; skipadjacentlineseparator = _bool ; } else { buffer . append ( c ) ; skipadjacentlineseparator = _bool ; } } return buffer . tostring ( ) ; }	flatten the given string so it contains no more line breaks.
private boolean isaccelerating ( sensorevent event ) { float ax = event . values [ _num ] ; float ay = event . values [ _num ] ; float az = event . values [ _num ] ; final double magnitude = math . sqrt ( ax * ax + ay * ay + az * az ) ; return magnitude > acceleration_threshold ; }	returns true if the device is currently accelerating .
@ override public byte [ ] readbytearray ( string filepath , int length ) { filechannel filechannel = updatecache ( filepath ) ; bytebuffer bytebffer = read ( filechannel , length ) ; return bytebffer . array ( ) ; }	this method will be used to read the byte array from file based on length ( number of bytes ).
public void popdragentry ( int index ) { if ( isindexinbound ( index ) ) { mdraggedentry = mdragentries . get ( index ) ; mdraggedentryindex = index ; mdragenteredentryindex = index ; markdroparea ( index ) ; } }	temporarily removes a contact from the list for ui refresh.
public void test_loadandverify_small_quadsmode ( ) throws exception { final string resource = _str ; final properties p = getproperties ( ) ; p . setproperty ( abstracttriplestore . options . quads , _str ) ; doloadandverifytest ( resource , p ) ; }	test with the " small.
public void addemail ( emailentity email ) { emails . add ( email ) ; }	adds a new email to this user.
private static int manhattandistance ( final int x1 , final int y1 , final int x2 , final int y2 ) { return math . abs ( x1 - x2 ) + math . abs ( y1 - y2 ) ; }	calculates the manhattan distance between to positions .
public void putgrammar ( schemagrammar grammar ) { if ( grammar . gettargetnamespace ( ) == null ) fnonsgrammar = grammar ; else fgrammarregistry . put ( grammar . gettargetnamespace ( ) , grammar ) ; }	put a schema grammar into the registry this method is for internal use only : it assumes that a grammar with the same target namespace is not already in the bucket .
public jsonarray optjsonarray ( string key ) { object o = opt ( key ) ; return o instanceof jsonarray ? ( jsonarray ) o : null ; }	get an optional jsonarray associated with a key.
private void status ( ) { ps . println ( _str ) ; ps . println ( _str ) ; ps . println ( _str ) ; ps . println ( _str ) ; writekeyswithprefix ( _str , _str ) ; }	writes the status help.
void pushimportsource ( source sourcefromuriresolver ) { m_importsourcestack . push ( sourcefromuriresolver ) ; }	push the source of an import href onto the stylesheet stack , obtained from a uriresolver , null if there is no uriresolver , or if that resolver returned null .
public static byte [ ] buildnalunit ( byte [ ] data , int offset , int length ) { byte [ ] nalunit = new byte [ length + nal_start_code . length ] ; system . arraycopy ( nal_start_code , _num , nalunit , _num , nal_start_code . length ) ; system . arraycopy ( data , offset , nalunit , nal_start_code . length , length ) ; return nalunit ; }	constructs a nal unit consisting of the nal start code followed by the specified data .
protected void dologoobmessageoutbound ( message message ) { if ( rpclogger != null ) { rpclogger . logoobmessage ( clientinfo , serverinfo , message , system . currenttimemillis ( ) ) ; } }	logger all information about an outbound oobmessage .
@ override public void stop ( ) { countdownlatch latch = stopped ; thread oldthread = thread . getandupdate ( null ) ; if ( oldthread != null && latch != null ) { try { latch . await ( _num , timeunit . seconds ) ; } catch ( interruptedexception e ) { thread . interrupted ( ) ; } } }	stop this executor from executing , and block until the thread has completed all work ( or until the timeout has occurred ).
@ override public byte [ ] encode ( bufferedimage bufferedimage ) throws ioexception { bytearrayoutputstream outputstream = new bytearrayoutputstream ( ) ; encode ( bufferedimage , outputstream ) ; return outputstream . tobytearray ( ) ; }	encodes an image in png format .
private jsonparserexception createhelpfulexception ( char first , char [ ] expected , int failureposition ) throws jsonparserexception { stringbuilder errortoken = new stringbuilder ( first + ( expected == null ? _str : new string ( expected , _num , failureposition ) ) ) ; while ( isasciiletter ( peekchar ( ) ) && errortoken . length ( ) < _num ) errortoken . append ( ( char ) advancechar ( ) ) ; return createparseexception ( null , _str + errortoken + _str + ( expected == null ? _str : _str + first + new string ( expected ) + _str ) , _bool ) ; }	throws a helpful exception based on the current alphanumeric token .
public void testconstructorbytespositive3 ( ) { byte abytes [ ] = { _num , _num , _num , - _num } ; byte rbytes [ ] = { _num , _num , _num , - _num } ; biginteger anumber = new biginteger ( abytes ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = anumber . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , anumber . signum ( ) ) ; }	create a positive number from an array of bytes.
public static void i ( string tag , string s , object ... args ) { if ( log . info >= loglevel ) log . i ( tag , string . format ( s , args ) ) ; }	info log message with printf formatting .
public void removelifecyclelistener ( lifecyclelistener lifecyclelistener ) { lifecyclelisteners . remove ( lifecyclelistener ) ; }	removes a previously added lifecycle listener.
private synchronized void initregistry ( boolean force ) throws matlabconnectionexception { if ( _registry == null || force ) { try { _registry = localhostrmihelper . createregistry ( _options . getport ( ) ) ; } catch ( exception e ) { try { _registry = localhostrmihelper . getregistry ( _options . getport ( ) ) ; } catch ( exception ex ) { throw new matlabconnectionexception ( _str , ex ) ; } } } }	initializes the registry if it has not already been set up .
public boolean phasehasturns ( igame . phase thisphase ) { switch ( thisphase ) { case phase_set_artyautohithexes : case phase_deploy_minefields : case phase_deployment : case phase_movement : case phase_firing : case phase_physical : case phase_targeting : case phase_offboard : return _bool ; default : return _bool ; } }	returns true if this phase has turns.
public int read ( ) throws ioexception { int ch1 = is . read ( ) ; int ch2 = is . read ( ) ; if ( ch2 < _num ) return - _num ; return ( ch2 << _num ) + ch1 ; }	reads into a character buffer using the correct encoding .
public static boolean isurl ( string resourcelocation ) { if ( resourcelocation == null ) { return _bool ; } if ( resourcelocation . startswith ( classpath_url_prefix ) ) { return _bool ; } try { new url ( resourcelocation ) ; return _bool ; } catch ( malformedurlexception ex ) { return _bool ; } }	return whether the given resource location is a url : either a special " classpath " pseudo url or a standard url .
public static string encodeurl ( string uri ) { charbuffer cb = charbuffer . allocate ( ) ; for ( int i = _num ; i < uri . length ( ) ; i ++ ) { char ch = uri . charat ( i ) ; switch ( ch ) { case _str : case _str : case _str : case _str : case _str : case _str : cb . append ( _str ) ; cb . append ( encodehex ( ch > > _num ) ) ; cb . append ( encodehex ( ch ) ) ; break ; default : cb . append ( ch ) ; } } return cb . close ( ) ; }	encode the url with ' % ' encoding .
public void close ( ) throws ioexception { if ( closed ) { return ; } if ( queuedforcleanup ) { return ; } try { if ( expected > count ) { long nskip = expected - count ; if ( nskip <= available ( ) ) { do { } while ( ( nskip = ( expected - count ) ) > _num && skip ( math . min ( nskip , available ( ) ) ) > _num ) ; } else if ( expected <= keepalivestreamcleaner . max_data_remaining && ! hurried ) { queueforcleanup ( new keepalivecleanerentry ( this , hc ) ) ; } else { hc . closeserver ( ) ; } } if ( ! closed && ! hurried && ! queuedforcleanup ) { hc . finished ( ) ; } } finally { if ( pi != null ) pi . finishtracking ( ) ; if ( ! queuedforcleanup ) { in = null ; hc = null ; closed = _bool ; } } }	attempt to cache this connection.
public boolean ispublic ( ) { return modifier . ispublic ( _method . getmodifiers ( ) ) ; }	returns true for a public method .
private object [ ] initializecallerhierarchyroots ( map < string , map < string , set < jsonelement > > > callermap ) { list < treeelement < sourcemethodnode , sourcemethodnode > > roots = new arraylist < treeelement < sourcemethodnode , sourcemethodnode > > ( ) ; callerhierarchy callerhierarchy = ( callerhierarchy ) finput ; sourcemethodnode rootnode = callerhierarchy . getroot ( ) ; set < sourcemethodnode > processednodes = new hashset < sourcemethodnode > ( ) ; treeelement < sourcemethodnode , sourcemethodnode > root = initializecallerhierarchy ( rootnode , processednodes , callermap ) ; return new object [ ] { root } ; }	creates tree elements for the caller hierarchy outline view.
private list < entry > reducewithdouglaspeuker ( list < entry > entries , double epsilon ) { if ( epsilon <= _num || entries . size ( ) < _num ) { return entries ; } keep [ _num ] = _bool ; keep [ entries . size ( ) - _num ] = _bool ; algorithmdouglaspeucker ( entries , epsilon , _num , entries . size ( ) - _num ) ; list < entry > reducedentries = new arraylist < entry > ( ) ; for ( int i = _num ; i < entries . size ( ) ; i ++ ) { if ( keep [ i ] ) { entry curentry = entries . get ( i ) ; reducedentries . add ( new entry ( curentry . getval ( ) , curentry . getxindex ( ) ) ) ; } } return reducedentries ; }	uses the douglas peuker algorithm to reduce the given list of entries.
public static double [ ] computelogamplitudespectrum ( final double [ ] signal ) { double [ ] spectrum = computeamplitudespectrum ( signal ) ; for ( int i = _num ; i < spectrum . length ; i ++ ) { spectrum [ i ] = math . log ( spectrum [ i ] ) ; } return spectrum ; }	convenience method for computing the log amplitude spectrum of a real signal.
private segment creatememorysegment ( segmentdescriptor descriptor ) { file segmentfile = segmentfile . createsegmentfile ( name , storage . directory ( ) , descriptor . id ( ) , descriptor . version ( ) ) ; buffer buffer = heapbuffer . allocate ( math . min ( default_buffer_size , descriptor . maxsegmentsize ( ) ) , integer . max_value ) ; descriptor . copyto ( buffer ) ; segment segment = new segment ( new segmentfile ( segmentfile ) , buffer . slice ( ) , descriptor , createindex ( descriptor ) , new offsetpredicate ( ) , serializer . clone ( ) , this ) ; logger . debug ( _str , segment ) ; return segment ; }	creates a new segment .
public static void init ( final asynccontext context ) { final securitycontext security = ( securitycontext ) context . getattribute ( asynccontext . security_ctx ) ; final boolean forcesetsecurity = forcesetsecuritycontext ( context ) ; if ( forcesetsecurity ) { securitycontextholder . setcontext ( security ) ; } ctx . set ( context ) ; }	initialise security context from async context.
private void cancelpreviouswebrtcnotifications ( ) { set < string > notificationids = msharedpreferences . getstringset ( webrtc_notification_ids , null ) ; if ( notificationids == null ) return ; iterator < string > iterator = notificationids . iterator ( ) ; while ( iterator . hasnext ( ) ) { mnotificationmanager . cancel ( notification_namespace , integer . parseint ( iterator . next ( ) ) ) ; } sharedpreferences . editor sharedpreferenceeditor = msharedpreferences . edit ( ) ; sharedpreferenceeditor . remove ( mediacapturenotificationservice . webrtc_notification_ids ) ; sharedpreferenceeditor . apply ( ) ; }	cancel all previously existing notifications.
public static final string readstring ( byte [ ] bytes , int offset , int length , string charset ) throws ioexception { return readstring ( bytes , _num , bytes . length , charset . forname ( charset ) ) ; }	convert a byte array to a string ; consistently uses \ n line endings in java.
private topologyupdaterthread ( ) { super ( id + _str ) ; }	creates topology refresh thread .
private void typeparametersrest ( list < ? extends typeparametertree > typeparameters , indent plusindent ) { builder . open ( plusindent ) ; builder . breakop ( ) ; builder . open ( zero ) ; boolean first = _bool ; for ( typeparametertree typeparameter : typeparameters ) { if ( ! first ) { token ( _str ) ; builder . breakop ( _str ) ; } scan ( typeparameter , null ) ; first = _bool ; } token ( _str ) ; builder . close ( ) ; builder . close ( ) ; }	does not omit the leading ' < ' , which should be associated with the type name .
public void writestring ( string str ) throws ioexception { if ( str == null ) writeint ( _num ) ; else { if ( usecompression && str . length ( ) >= compressor . min_size_for_deflation ) { byte [ ] bytes = compressor . deflatestring2bytearray ( str ) ; writeint ( - bytes . length ) ; outs . write ( bytes , _num , bytes . length ) ; position += bytes . length ; } else { byte [ ] bytes = str . getbytes ( _str ) ; writeint ( bytes . length ) ; outs . write ( bytes , _num , bytes . length ) ; position += bytes . length ; } } }	write a string , compressed , if long enough.
public void dequeuesound ( uri uri ) { maudioqueue . remove ( new audioqueueitem ( uri , null ) ) ; }	removes the first instance of a sound from the audio queue .
public void removebookmark ( final cbookmark bookmark ) { preconditions . checknotnull ( bookmark , _str ) ; preconditions . checkargument ( m_bookmarks . remove ( bookmark ) , _str ) ; for ( final ibookmarkmanagerlistener listener : m_listeners ) { try { listener . removedbookmark ( this , bookmark ) ; } catch ( final exception exception ) { cutilityfunctions . logexception ( exception ) ; } } }	removes the bookmark at the given index .
public static keystore loadkeystore ( string type , file file , char [ ] password ) throws exception { keystore keystore = keystore . getinstance ( type ) ; try ( fileinputstream fis = new fileinputstream ( file ) ) { keystore . load ( fis , password ) ; } return keystore ; }	loads a key store from a file .
public void loop ( double ellapsedmillis ) { for ( springsystemlistener listener : mlisteners ) { listener . onbeforeintegrate ( this ) ; } advance ( ellapsedmillis ) ; if ( mactivesprings . isempty ( ) ) { midle = _bool ; } for ( springsystemlistener listener : mlisteners ) { listener . onafterintegrate ( this ) ; } if ( midle ) { mspringlooper . stop ( ) ; } }	loop the system until idle.
private void updaterecordingtrack ( track track , long lasttrackpointid , boolean increasenumberofpoints ) { if ( lasttrackpointid >= _num ) { if ( track . getstartid ( ) < _num ) { track . setstartid ( lasttrackpointid ) ; } track . setstopid ( lasttrackpointid ) ; } if ( increasenumberofpoints ) { track . setnumberofpoints ( track . getnumberofpoints ( ) + _num ) ; } tracktripstatisticsupdater . updatetime ( system . currenttimemillis ( ) ) ; track . settripstatistics ( tracktripstatisticsupdater . gettripstatistics ( ) ) ; mytracksproviderutils . updatetrack ( track ) ; }	updates the recording track time.
@ override public void requeststartupupdates ( string from , byte [ ] tablekey , int podindex , long deltatime , result < boolean > cont ) { if ( log . isloggable ( level . finest ) ) { log . finest ( _str + from + _str + podindex + _str + deltatime ) ; } long accesstime = currenttime . currenttime ( ) + deltatime ; tablepod tablepod = _clientkraken . gettable ( tablekey ) ; if ( tablepod == null ) { if ( log . isloggable ( level . finest ) ) { log . finest ( l . l ( _str , hex . toshorthex ( tablekey ) , bartendersystem . getcurrentselfserver ( ) ) ) ; } cont . ok ( _bool ) ; return ; } tablepod . getupdatesfromlocal ( podindex , accesstime , cont ) ; }	asks for updates from the message.
private void refreshmutevideobutton ( ) { if ( ( null != mcall ) && mcall . isvideo ( ) ) { mmutelocalcameraview . setvisibility ( view . visible ) ; boolean ismuted = mcall . isvideorecordingmuted ( ) ; log . d ( log_tag , _str + ismuted ) ; int iconid = ismuted ? r . drawable . ic_material_videocam_off_pink_red : r . drawable . ic_material_videocam_off_grey ; mmutelocalcameraview . setimageresource ( iconid ) ; } else { log . d ( log_tag , _str ) ; mmutelocalcameraview . setvisibility ( view . invisible ) ; } }	update the mute video icon .
public boolean isautoupdatetrl ( string tablename ) { if ( super . ismultilingualdocument ( ) ) return _bool ; if ( tablename == null ) return _bool ; if ( tablename . startswith ( _str ) && getad_client_id ( ) == _num ) return _bool ; return _bool ; }	update trl tables automatically ?.
private void createpreferencecontrols ( composite parent , set < preferenceid > preferenceset , inputdefinition inputdefinition ) { for ( preferenceid preferenceidenum : preferenceset ) { ipreferencecontrol preferencecontrol = preferencecontrolfactory . createpreferencecontrols ( parent , toolkit , preferenceidenum , this , inputdefinition ) ; if ( null != preferencecontrol ) { preferencecontrollist . add ( preferencecontrol ) ; } } }	creates the preference controls in the preference control panel .
@ requestmapping ( value = _str , method = post , produces = application_json_value ) public responseentity < pageresponse < projectdto > > findall ( @ requestbody pagerequestbyexample < projectdto > prbe ) throws urisyntaxexception { pageresponse < projectdto > pageresponse = projectdtoservice . findall ( prbe ) ; return new responseentity < > ( pageresponse , new httpheaders ( ) , httpstatus . ok ) ; }	find a page of project using query by example .
public void testshaprovider ( ) { messagedigest md = null ; try { md = messagedigest . getinstance ( _str ) ; } catch ( nosuchalgorithmexception e ) { fail ( _str + e ) ; } byte [ ] bytes = new byte [ ] { _num , _num , _num , _num , _num } ; try { md . update ( bytes , - _num , _num ) ; fail ( _str ) ; } catch ( indexoutofboundsexception e ) { } try { md . update ( bytes , _num , - _num ) ; fail ( _str ) ; } catch ( indexoutofboundsexception e ) { } try { md = messagedigest . getinstance ( _str ) ; } catch ( nosuchalgorithmexception e ) { fail ( _str + e ) ; } try { md . digest ( bytes , _num , - _num ) ; fail ( _str ) ; } catch ( digestexception e ) { } try { md . digest ( bytes , - _num , _num ) ; fail ( _str ) ; } catch ( digestexception e ) { } try { md = messagedigest . getinstance ( _str ) ; fail ( _str ) ; } catch ( nosuchalgorithmexception e ) { } }	tests sha messagedigest provider.
static private double fac2 ( int j ) { long i = j ; if ( j < _num ) i = math . abs ( j ) ; double d = _num ; while ( i > _num ) d *= i -- ; if ( j < _num ) return - d ; else return d ; }	returns the factorial of the argument .
private static boolean isinputexhausted ( streamtokenizer input ) throws parseerror { try { if ( input . nexttoken ( ) == streamtokenizer . tt_eof ) { return _bool ; } input . pushback ( ) ; return _bool ; } catch ( ioexception e ) { throw new parseerror ( e . getmessage ( ) ) ; } }	determines if the input is exhausted .
public void clear ( ) { m . clear ( ) ; }	removes all of the elements from this set .
public static void writeunsafe ( packetoutputstream out , inputstream is , long length , boolean nobackslashescapes ) throws ioexception { out . writeunsafe ( quote ) ; byte [ ] buffer = new byte [ _num ] ; long bytesleft = length ; int len ; for ( ; ; ) { int bytestoread = ( int ) math . min ( bytesleft , buffer . length ) ; if ( bytestoread == _num ) { break ; } len = is . read ( buffer , _num , bytestoread ) ; if ( len <= _num ) { break ; } writebytesescapedunsafe ( out , buffer , len , nobackslashescapes ) ; bytesleft -= len ; } out . writeunsafe ( quote ) ; }	write stream in text format without checking buffer size .
public sqlquery ( class < t > type , string sqlexpression , queryresulttype queryresulttype ) { this ( sqlexpression , type . getname ( ) , null , queryresulttype , null ) ; }	creates a sqlquery using the specified type , expression and result type .
public builder retry ( long duration , timeunit timeunit ) { this . retry = timeunit . toseconds ( duration ) ; return this ; }	set the period after which , if no ack is received , the job is put again into the queue for delivery.
private recordbuffer < r > trytake ( long elapsedwaiting ) { recordbuffer < r > result = null ; if ( ! retryqueue . isempty ( ) ) { result = retryqueue . poll ( ) ; } else { result = neverpubqueue . poll ( ) ; } if ( result != null ) { return ontakesuccess ( result , elapsedwaiting ) ; } else if ( elapsedwaiting > _num ) { return ontaketimeout ( elapsedwaiting ) ; } else return null ; }	keep private . call only when holding lock .
public void testconstructorbytesnegative1 ( ) { byte abytes [ ] = { - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , _num , _num } ; byte rbytes [ ] = { - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( abytes ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = anumber . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , anumber . signum ( ) ) ; }	create a negative number from an array of bytes.
private < t > list < t > tosortedlist ( t [ ] array , comparator < t > comparator ) { list < t > list = new arraylist < > ( ) ; collections . addall ( list , array ) ; collections . sort ( list , comparator ) ; return list ; }	creates a sorted list from an array of elements using the given classcomparator .
private geomark reverse_geocode ( final string text ) { for ( string t : text . split ( _str ) ) { if ( t . length ( ) < _num ) continue ; string [ ] c = t . split ( _str ) ; if ( c . length != _num ) continue ; try { double lat = double . parsedouble ( c [ _num ] ) ; double lon = double . parsedouble ( c [ _num ] ) ; geomark mark = citynear ( lat , lon ) ; if ( mark == null ) continue ; return mark ; } catch ( numberformatexception e ) { continue ; } } return null ; }	find the geolocation for coordinates in a text.
public arraylist < platoupleint > entrance_points ( polyline p_polyline ) { arraylist < platoupleint > result = new arraylist < platoupleint > ( _num * p_polyline . plaline_len ( ) ) ; int prev_intersection_line_no = - _num ; int prev_intersection_edge_no = - _num ; for ( int line_no = _num ; line_no < p_polyline . plaline_len ( - _num ) ; ++ line_no ) { plasegmentint curr_line_seg = p_polyline . segment_get ( line_no ) ; int [ ] curr_intersections = curr_line_seg . border_intersections ( this ) ; for ( int index = _num ; index < curr_intersections . length ; ++ index ) { int edge_no = curr_intersections [ index ] ; if ( line_no != prev_intersection_line_no || edge_no != prev_intersection_edge_no ) { result . add ( new platoupleint ( line_no , edge_no ) ) ; prev_intersection_line_no = line_no ; prev_intersection_edge_no = edge_no ; } } } return result ; }	returns an arry of tuples of integers.
public static byte [ ] serializeasbytearray ( object b ) throws ioexception { bytearrayoutputstream bos = new bytearrayoutputstream ( ) ; objectoutputstream out = new objectoutputstream ( bos ) ; try { out . writeobject ( b ) ; } finally { out . close ( ) ; } return bos . tobytearray ( ) ; }	serialize an object as a raw byte array.
public static void putintle ( long addr , int val ) { if ( unaligned ) unsafe . putint ( addr , integer . reversebytes ( val ) ) ; else putintbybyte ( addr , val , _bool ) ; }	stores given integer value assuming that value should be stored in little - endian byte order and native byte order is big - endian.
public floatingactionbutton createsubfab ( char icon , string text ) { floatingactionbutton sub = new floatingactionbutton ( icon , text , _num ) ; if ( submenu == null ) { submenu = new arraylist < floatingactionbutton > ( ) ; } submenu . add ( sub ) ; return sub ; }	adds a sub fab to the floatingactionbutton instance.
public string readvalue ( inputnode from ) throws exception { if ( ! stack . isrelevant ( from ) ) { return null ; } int length = text . length ( ) ; if ( length <= _num ) { eventnode event = reader . peek ( ) ; if ( event . isend ( ) ) { if ( stack . top ( ) == from ) { return null ; } else { stack . pop ( ) ; } event = reader . next ( ) ; } } return readtext ( from ) ; }	read the contents of the characters between the specified xml element tags , if the read is currently at that element.
private void dispatchonthirdpartyregistered ( ) { synchronized ( this ) { for ( thirdpartyregistrationlistener listener : mthirdpartyregistrationlisteners ) { try { listener . onthirdpartyregistered ( ) ; } catch ( exception e ) { log . e ( log_tag , _str + e . getlocalizedmessage ( ) ) ; } } mthirdpartyregistrationlisteners . clear ( ) ; } }	dispatch the onthirdpartyregistered to the listeners .
void updatefordecodertypeid ( list < decoderfile > plist ) { decoderbox . setmodel ( decoderindexfile . jcomboboxmodelfromlist ( plist ) ) ; decoderbox . insertitemat ( _str , _num ) ; decoderbox . setselectedindex ( _num ) ; }	decoder identify has matched one or more specific types.
@ override public void actionperformed ( actionevent event ) { switch ( event . getactioncommand ( ) ) { case new_alias : addalias ( new alias ( _str ) ) ; break ; case copy_alias : for ( alias alias : getselectedaliases ( ) ) { addalias ( aliasfactory . copyof ( alias ) ) ; } break ; case delete_alias : list < alias > todelete = getselectedaliases ( ) ; if ( todelete != null && ! todelete . isempty ( ) ) { string title = todelete . size ( ) == _num ? _str : _str ; string prompt = todelete . size ( ) == _num ? _str : _str + todelete . size ( ) + _str ; int choice = joptionpane . showconfirmdialog ( aliascontroller . this , prompt , title , joptionpane . yes_no_option , joptionpane . warning_message ) ; if ( choice == joptionpane . yes_option ) { for ( alias alias : todelete ) { maliasmodel . removealias ( alias ) ; } } } break ; default : break ; } }	responds to new , copy and delete channel button invocations.
public boolean directionkeyispressed ( ) { return pressedstatekeys . contains ( keyevent . vk_up ) || pressedstatekeys . contains ( keyevent . vk_down ) || pressedstatekeys . contains ( keyevent . vk_left ) || pressedstatekeys . contains ( keyevent . vk_right ) || pressedstatekeys . contains ( keyevent . vk_kp_left ) || pressedstatekeys . contains ( keyevent . vk_kp_right ) || pressedstatekeys . contains ( keyevent . vk_kp_up ) || pressedstatekeys . contains ( keyevent . vk_kp_down ) ; }	check if any direction key is in " pressed " state .
public void addposition ( int offset , int length , string ... ids ) { textattribute highlighting = ids . length == _num ? attributeprovider . getattribute ( ids [ _num ] ) : attributeprovider . getmergedattributes ( ids ) ; boolean isexisting = _bool ; for ( int i = _num , n = removedpositions . size ( ) ; i < n ; i ++ ) { attributedposition position = removedpositions . get ( i ) ; if ( position == null ) continue ; if ( position . isequal ( offset , length , highlighting ) ) { isexisting = _bool ; removedpositions . set ( i , null ) ; removedpositioncount -- ; break ; } } if ( ! isexisting ) { attributedposition position = presenter . createhighlightedposition ( offset , length , highlighting ) ; addedpositions . add ( position ) ; } }	add a position with the given range and highlighting if it does not exist already .
static void exportmaskupdate ( exportmask exportmask , map < uri , integer > volumemap , list < initiator > initiators , list < uri > targets ) { if ( volumemap != null ) { for ( uri volume : volumemap . keyset ( ) ) { exportmask . addvolume ( volume , volumemap . get ( volume ) ) ; } } if ( initiators != null ) { for ( initiator initiator : initiators ) { exportmask . addinitiator ( initiator ) ; } } if ( targets != null ) { for ( uri target : targets ) { exportmask . addtarget ( target ) ; } } }	adds the volumes , initiators , and targets to an exportmask .
private void internaladdhead ( final messagereference ref ) { queuememorysize . addandget ( ref . getmessagememoryestimate ( ) ) ; refadded ( ref ) ; int priority = getpriority ( ref ) ; messagereferences . addhead ( ref , priority ) ; }	the caller of this method requires synchronized on the queue.
private boolean createnew ( mproduct product , macctschema as ) { mcost dimension = mcost . getorcreate ( product , _num , as , _num , _num , as . getm_costtype_id ( ) , m_ce . getm_costelement_id ( ) ) ; if ( dimension . is_new ( ) ) return dimension . save ( ) ; return _bool ; }	create new client level costing record.
@ override protected void step ( ) { while ( iter . hasnext ( ) ) { reg = ( svcreg ) iter . next ( ) ; if ( reg . leaseexpiration > now ) return ; } reg = null ; }	set reg to the next matching element , or null if none.
public enumeration < string > packages ( ) { return m_cache . keys ( ) ; }	returns all the stored packages .
protected int size ( ) { return document . length ( ) ; }	returns the number of bytes of the document .
public tps currentrow ( ) { return currentrow ( null ) ; }	filters for the current row ( most recent bindings ).
public final void deleteallentries ( ) { if ( numentries > _num ) { arrays . fill ( entries , null ) ; this . numentries = _num ; } }	deletes all entries in this node .
public list < map < string , object > > query ( final string indexname , final string q , final operator operator , final int offset , final int count ) { assert count > _num ; searchrequestbuilder request = elasticsearchclient . preparesearch ( indexname ) . setquery ( querybuilders . multimatchquery ( q , _str ) . operator ( operator ) . zerotermsquery ( zerotermsquery . all ) ) . setfrom ( offset ) . setsize ( count ) ; searchresponse response = request . execute ( ) . actionget ( ) ; searchhit [ ] hits = response . gethits ( ) . gethits ( ) ; arraylist < map < string , object > > result = new arraylist < map < string , object > > ( ) ; for ( searchhit hit : hits ) { map < string , object > map = hit . getsource ( ) ; result . add ( map ) ; } return result ; }	query with a string and boundaries.
public sortedset < string > plugins ( ) { sortedset < string > r = new treeset < > ( ) ; for ( namepair p : items . keyset ( ) ) { r . add ( p . pluginname ) ; } return collections . unmodifiablesortedset ( r ) ; }	get the names of all running plugins supplying this type .
public static void error ( int windowno , container c , string ad_message ) { error ( windowno , c , ad_message , null ) ; }	display error with error icon.
public reilfunction translate ( final itranslationenvironment environment , final iblockcontainer < instructiontype > function ) throws internaltranslationexception { return translate ( environment , function , new arraylist < itranslationextension < instructiontype > > ( ) ) ; }	translates a disassembled function to reil code .
public name parse ( string name ) throws namingexception { vector < string > comps = insstringtostringifiedcomps ( name ) ; return new cncompoundname ( comps . elements ( ) ) ; }	returns a compoundname given a string in ins syntax .
public csvdatasourcefactory ( ) { super ( _str , csv_mime_types , csv_file_endings , csvformatspecificationwizardstep . csv_format_specification_step_id ) ; }	constructs a new factory instance .
private void sendack ( string index , string message , guacamolestatus status ) { if ( status != guacamolestatus . success ) closeinterceptedstream ( index ) ; sendinstruction ( new guacamoleinstruction ( _str , index , message , integer . tostring ( status . getguacamolestatuscode ( ) ) ) ) ; }	injects an " ack " instruction into the outbound guacamole protocol stream , as if sent by the connected client.
public static boolean iswindowsplatform ( ) { string os = system . getproperty ( _str ) ; return ( os != null && os . startswith ( win_id ) ) ; }	try to determine whether this application is running under windows or some other platform by examing the " os.
static public int countrangesthatcollidezone ( list < bounds > ranges , list < bounds > zoneranges ) { int overalleoaa = _num ; collections . sort ( zoneranges ) ; for ( bounds extractedbounds : ranges ) { for ( bounds expectedbounds : zoneranges ) { if ( expectedbounds . start >= extractedbounds . end ) { break ; } if ( extractedbounds . overlaps ( expectedbounds ) ) { overalleoaa ++ ; break ; } } } return overalleoaa ; }	counts the number of checkedranges that overlaps with the zoneranges.
public static boolean timestampchanged ( string location ) { synchronized ( installlock ) { if ( fghaschanged . contains ( location ) ) { return _bool ; } file file = new file ( location ) ; if ( file . exists ( ) ) { if ( fginstalltimemap == null ) { readinstallinfo ( ) ; } long stamp = fginstalltimemap . get ( location ) ; long fstamp = file . lastmodified ( ) ; if ( stamp != null ) { if ( stamp . longvalue ( ) == fstamp ) { return _bool ; } } stamp = new long ( fstamp ) ; fginstalltimemap . put ( location , stamp ) ; writeinstallinfo ( ) ; fghaschanged . add ( location ) ; return _bool ; } } return _bool ; }	checks to see if the time stamp of the file describe by the given location string has been modified since the last recorded time stamp.
public static boolean [ ] valuesof ( boolean [ ] array ) { boolean [ ] dest = new boolean [ array . length ] ; for ( int i = _num ; i < array . length ; i ++ ) { dest [ i ] = boolean . valueof ( array [ i ] ) ; } return dest ; }	converts to object array .
private void correcttoohigh ( int childcount ) { int lastposition = mfirstposition + childcount - _num ; if ( lastposition == mitemcount - _num && childcount > _num ) { final int lastbottom = getlowestchildbottom ( ) ; final int end = ( getbottom ( ) - gettop ( ) ) - getlistpaddingbottom ( ) ; int bottomoffset = end - lastbottom ; final int firsttop = gethighestchildtop ( ) ; if ( bottomoffset > _num && ( mfirstposition > _num || firsttop < getlistpaddingtop ( ) ) ) { if ( mfirstposition == _num ) { bottomoffset = math . min ( bottomoffset , getlistpaddingtop ( ) - firsttop ) ; } offsetchildrentopandbottom ( bottomoffset ) ; if ( mfirstposition > _num ) { int previousposition = mfirstposition - _num ; fillup ( previousposition , getnextchildupsbottom ( previousposition ) ) ; adjustviewsupordown ( ) ; } } } }	check if we have dragged the bottom of the list too high ( we have pushed the top element off the top of the screen when we did not need to ).
public static boolean writeline ( string filename , string value ) { bufferedwriter writer = null ; try { writer = new bufferedwriter ( new filewriter ( filename ) ) ; writer . write ( value ) ; } catch ( filenotfoundexception e ) { log . w ( tag , _str + filename + _str , e ) ; return _bool ; } catch ( ioexception e ) { log . e ( tag , _str + filename , e ) ; return _bool ; } finally { try { if ( writer != null ) { writer . close ( ) ; } } catch ( ioexception e ) { } } return _bool ; }	writes the given value into the given file.
public void didrollback ( ) { synchronized ( this ) { if ( pending != null ) { pending . cancel ( _bool ) ; pending = null ; } docssincecommit . set ( _num ) ; } }	inform tracker that a rollback has occurred , cancel any pending commits.
@ override protected void calculatethumblocation ( ) { super . calculatethumblocation ( ) ; if ( slider . getsnaptoticks ( ) ) { int uppervalue = slider . getvalue ( ) + slider . getextent ( ) ; int snappedvalue = uppervalue ; int majortickspacing = slider . getmajortickspacing ( ) ; int minortickspacing = slider . getminortickspacing ( ) ; int tickspacing = _num ; if ( minortickspacing > _num ) { tickspacing = minortickspacing ; } else if ( majortickspacing > _num ) { tickspacing = majortickspacing ; } if ( tickspacing != _num ) { if ( ( uppervalue - slider . getminimum ( ) ) % tickspacing != _num ) { float temp = ( float ) ( uppervalue - slider . getminimum ( ) ) / ( float ) tickspacing ; int whichtick = math . round ( temp ) ; snappedvalue = slider . getminimum ( ) + ( whichtick * tickspacing ) ; } if ( snappedvalue != uppervalue ) { slider . setextent ( snappedvalue - slider . getvalue ( ) ) ; } } } if ( slider . getorientation ( ) == jslider . horizontal ) { int upperposition = xpositionforvalue ( slider . getvalue ( ) + slider . getextent ( ) ) ; upperthumbrect . x = upperposition - ( upperthumbrect . width / _num ) ; upperthumbrect . y = trackrect . y ; } else { int upperposition = ypositionforvalue ( slider . getvalue ( ) + slider . getextent ( ) ) ; upperthumbrect . x = trackrect . x ; upperthumbrect . y = upperposition - ( upperthumbrect . height / _num ) ; } }	updates the locations for both thumbs .
public void compile ( int throughphase ) throws compilationfailedexception { gotophase ( phases . initialization ) ; throughphase = math . min ( throughphase , phases . all ) ; while ( throughphase >= phase && phase <= phases . all ) { if ( phase == phases . semantic_analysis ) { dophaseoperation ( resolve ) ; if ( dequeued ( ) ) continue ; } processphaseoperations ( phase ) ; processnewphaseoperations ( phase ) ; if ( progresscallback != null ) progresscallback . call ( this , phase ) ; completephase ( ) ; applytosourceunits ( mark ) ; if ( dequeued ( ) ) continue ; gotophase ( phase + _num ) ; if ( phase == phases . class_generation ) { sortclasses ( ) ; } } errorcollector . failiferrors ( ) ; }	compiles the compilation unit from sources .
public string generatebearertoken ( string email , string username , map < string , string > payload ) { string token = tokengenerator . generate ( ) ; map < string , string > payloadcopy = payload == null ? new hashmap ( ) : new hashmap ( payload ) ; payloadcopy . put ( _str , email ) ; payloadcopy . put ( _str , username ) ; payloadcopy . put ( _str , long . tostring ( system . currenttimemillis ( ) ) ) ; tokenmap . put ( token , payloadcopy ) ; return token ; }	generate new token for given user .
public void enddocument ( augmentations augs ) throws xniexception { try { if ( fdocumenthandler != null ) { fdocumenthandler . enddocument ( ) ; } if ( fcontenthandler != null ) { fcontenthandler . enddocument ( ) ; } } catch ( saxexception e ) { throw new xniexception ( e ) ; } }	the end of the document .
public final connectionstate newinput ( ) throws ioexception { if ( in . hasremaining ( ) ) { throw new runtimeexception ( _str ) ; } in . clear ( ) ; int r = ch . read ( in ) ; if ( r == - _num ) throw new ioexception ( _str ) ; if ( r == _num ) return connectionstate . selector_wait_for_new_input ; in . flip ( ) ; return newrequestchunk ( ) ; }	new data available for the connection .
public boolean canmoveforward ( ) { return currentindex >= _num && currentindex < ( history . size ( ) - _num ) ; }	return true if there is a previous url in the list relative to the current position .
public void clearcache ( ) { disklrucache . clearcache ( mcachedir ) ; }	removes all disk cache entries from this instance cache dir.
public void addnaturaljoincolumn ( column c ) { if ( naturaljoincolumns == null ) { naturaljoincolumns = new . arraylist ( ) ; } naturaljoincolumns . add ( c ) ; }	add a column to the natural join key column list .
private refactoringstatus checkcancreateintermediarymethod ( ) throws javamodelexception { list < itypebinding > parameterbindings = new arraylist < itypebinding > ( ) ; if ( ! isstatictarget ( ) ) parameterbindings . add ( fintermediaryfirstparametertype ) ; parameterbindings . addall ( arrays . aslist ( ftargetmethodbinding . getparametertypes ( ) ) ) ; return checks . checkmethodintype ( fintermediarytypebinding , fintermediarymethodname , parameterbindings . toarray ( new itypebinding [ parameterbindings . size ( ) ] ) ) ; }	checks whether the target method can be created.
@ override public string generatetooltip ( xydataset data , int series , int item ) { return gettooltiptext ( series , item ) ; }	generates a tool tip text item for a particular item within a series .
private class < ? > findclassnondalvik ( string name ) throws classnotfoundexception { string pathname = class_path + name + _str ; file path = new file ( pathname ) ; randomaccessfile raf ; try { raf = new randomaccessfile ( path , _str ) ; } catch ( filenotfoundexception fnfe ) { throw new classnotfoundexception ( _str + pathname ) ; } byte [ ] filedata ; try { filedata = new byte [ ( int ) raf . length ( ) ] ; raf . readfully ( filedata ) ; } catch ( ioexception ioe ) { throw new classnotfoundexception ( _str + pathname ) ; } finally { try { raf . close ( ) ; } catch ( ioexception ioe ) { } } try { return defineclass ( name , filedata , _num , filedata . length ) ; } catch ( throwable th ) { throw new classnotfoundexception ( _str , th ) ; } }	finds the class with the specified binary name , from.
public static void load ( class < ? > parent ) { load ( parent , classloader . getsystemclassloader ( ) ) ; }	load the service file .
public void removechangelistener ( changelistener cl ) { listeners . remove ( cl ) ; }	removes a listener for changeevents .
@ guardedby ( _str ) void applyread ( node < k , v > node ) { if ( evictiondeque . contains ( node ) ) { evictiondeque . movetoback ( node ) ; } }	updates the node ' s location in the page replacement policy .
private void flushwritechunk ( ) { if ( writechunk == null ) return ; if ( writechunk . position ( ) == _num ) return ; if ( ! writechunk . hasremaining ( ) ) { byteswritten += writechunk . position ( ) ; writechunk . flip ( ) ; list . addlast ( writechunk ) ; writechunk = null ; return ; } byteswritten += writechunk . position ( ) ; bytebuffer flushchunk = writechunk ; writechunk = writechunk . slice ( ) ; writechunk . order ( order ) ; flushchunk . flip ( ) ; list . addlast ( flushchunk ) ; return ; }	flushes write chunk to internal buffer.
public final double sin ( ) { return math . sin ( this . radians ) ; }	obtains the sine of this angle .
public axislabellayout ( string group , int axis , valuedrangemodel values ) { this ( group , axis , values , null ) ; }	create a new axislabellayout layout .
public double angle ( imovingagent agent ) { return geometric . angle ( this . location , agent . getlocation ( ) ) ; }	return the angle between this agent and the given one.
@ override public boolean equals ( object obj ) { if ( obj == this ) { return _bool ; } if ( ! ( obj instanceof defaultdrawingsupplier ) ) { return _bool ; } defaultdrawingsupplier that = ( defaultdrawingsupplier ) obj ; if ( ! arrays . equals ( this . paintsequence , that . paintsequence ) ) { return _bool ; } if ( this . paintindex != that . paintindex ) { return _bool ; } if ( ! arrays . equals ( this . outlinepaintsequence , that . outlinepaintsequence ) ) { return _bool ; } if ( this . outlinepaintindex != that . outlinepaintindex ) { return _bool ; } if ( ! arrays . equals ( this . strokesequence , that . strokesequence ) ) { return _bool ; } if ( this . strokeindex != that . strokeindex ) { return _bool ; } if ( ! arrays . equals ( this . outlinestrokesequence , that . outlinestrokesequence ) ) { return _bool ; } if ( this . outlinestrokeindex != that . outlinestrokeindex ) { return _bool ; } if ( ! equalshapes ( this . shapesequence , that . shapesequence ) ) { return _bool ; } if ( this . shapeindex != that . shapeindex ) { return _bool ; } return _bool ; }	tests this object for equality with another object .
@ override protected void paintcomponent ( graphics g ) { super . paintcomponent ( g ) ; graphics2d g2 = ( graphics2d ) g ; if ( shoulddraw ) { drawdisplayliston ( g2 ) ; } }	note ! called from ed thread .
public void load ( inputstream in ) throws ioexception { properties . load ( in ) ; dirty = _bool ; }	loads this preference store from the given input stream.
@ override public void onbindviewholder ( vh holder , int position ) { if ( list . get ( position ) . type == type_item ) { onbinditemviewholder ( holder , position ) ; } else if ( list . get ( position ) . type == type_header ) { onbindheaderviewholder ( holder , position ) ; } }	splits onbindviewholder method into two separate methods for items and headers .
public static map < componentwrapper , cc > parsecomponentconstraints ( map < componentwrapper , string > constrmap ) { hashmap < componentwrapper , cc > flowconstrmap = new hashmap < componentwrapper , cc > ( ) ; for ( componentwrapper c : constrmap . keyset ( ) ) { flowconstrmap . put ( c , parsecomponentconstraint ( constrmap . get ( c ) ) ) ; } return flowconstrmap ; }	parses all component constraints and stores the parsed values in the transient ( cache ) member variables .
private void sendstageprogresspatch ( taskstate state ) { serviceutils . loginfo ( this , _str , state . stage , state . substage ) ; taskutils . sendselfpatch ( this , buildpatch ( state . stage , state . substage , null ) ) ; }	this method sends a patch operation to the current service instance to move to a new state .
public void testcommonprefix ( ) { string returned = m_trie . getcommonprefix ( ) ; assertequals ( _str , _num , returned . length ( ) ) ; string expected = _str ; trie t = buildtrie ( new string [ ] { m_data [ _num ] , m_data [ _num ] } ) ; returned = t . getcommonprefix ( ) ; assertequals ( _str , expected . length ( ) , returned . length ( ) ) ; }	tests whether the common prefix is determined correctly.
public string moveback ( ) { check . istrue ( currentindex > _num , _str ) ; currentindex -- ; return history . get ( currentindex ) ; }	return the previous url in the list ( relative to the current position ) and moves the index back to make this the now current position .
public static long hash64 ( final string text ) { final byte [ ] bytes = text . getbytes ( ) ; return hash64 ( bytes , bytes . length ) ; }	generates 64 bit hash from a string .
public static void deletecore ( ) { log . info ( _str ) ; if ( h != null ) { h . close ( ) ; } if ( factoryprop == null ) { system . clearproperty ( _str ) ; } solrconfig = null ; h = null ; lrf = null ; configstring = schemastring = null ; }	shuts down the test harness , and makes the best attempt possible to delete datadir , unless the system property " solr.
public static boolean cantab ( list constraints ) { for ( iterator iter = constraints . iterator ( ) ; iter . hasnext ( ) ; ) { dockconstraint dc = ( dockconstraint ) iter . next ( ) ; if ( ! dc . cantab ( ) ) return _bool ; } return _bool ; }	determine property over a list of dockconstraint objects.
public imdnparser parse ( ) throws parserconfigurationexception , saxexception , parsefailureexception { try { saxparserfactory factory = saxparserfactory . newinstance ( ) ; saxparser parser = factory . newsaxparser ( ) ; parser . parse ( minputsource , this ) ; return this ; } catch ( ioexception e ) { throw new parsefailureexception ( _str , e ) ; } }	parse the imdn parser.
public static biginteger tobiginteger ( final ed25519encodedfieldelement encoded ) { return tobiginteger ( encoded . getraw ( ) ) ; }	converts an encoded field element to a biginteger .
public string escapeldapsearchfilter ( string filter ) { stringbuilder sb = new stringbuilder ( ) ; for ( int i = _num ; i < filter . length ( ) ; i ++ ) { char curchar = filter . charat ( i ) ; switch ( curchar ) { case _str : sb . append ( _str ) ; break ; case _str : sb . append ( _str ) ; break ; case _str : sb . append ( _str ) ; break ; case _str : sb . append ( _str ) ; break ; case _str : sb . append ( _str ) ; break ; default : sb . append ( curchar ) ; } } return sb . tostring ( ) ; }	escapes the given string for use within an ldap search filter.
protected synchronized void save ( ) { int retval ; file file ; string text ; filewriter fwriter ; bufferedwriter bwriter ; retval = m_filechooser . showopendialog ( this ) ; if ( retval != mekafilechooser . approve_option ) return ; file = m_filechooser . getselectedfile ( ) ; text = m_textarea . gettext ( ) ; fwriter = null ; bwriter = null ; try { fwriter = new filewriter ( file ) ; bwriter = new bufferedwriter ( fwriter ) ; bwriter . write ( text ) ; bwriter . newline ( ) ; bwriter . flush ( ) ; log ( _str + file ) ; } catch ( exception e ) { handleexception ( _str + file , e ) ; } finally { fileutils . closequietly ( bwriter ) ; fileutils . closequietly ( fwriter ) ; } }	saves the logging content .
public eigenvaluedecomposition ( double [ ] [ ] a ) { n = a . length ; v = new double [ n ] [ n ] ; d = new double [ n ] ; e = new double [ n ] ; issymmetric = _bool ; for ( int j = _num ; ( j < n ) && issymmetric ; j ++ ) { for ( int i = _num ; ( i < n ) && issymmetric ; i ++ ) { issymmetric = ( a [ i ] [ j ] == a [ j ] [ i ] ) ; if ( double . isnan ( a [ i ] [ j ] ) ) { throw new illegalargumentexception ( _str ) ; } if ( double . isinfinite ( a [ i ] [ j ] ) ) { throw new illegalargumentexception ( _str ) ; } } } if ( issymmetric ) { for ( int i = _num ; i < n ; i ++ ) { system . arraycopy ( a [ i ] , _num , v [ i ] , _num , n ) ; } tred2 ( ) ; tql2 ( ) ; } else { h = new double [ n ] [ n ] ; ort = new double [ n ] ; for ( int j = _num ; j < n ; j ++ ) { for ( int i = _num ; i < n ; i ++ ) { h [ i ] [ j ] = a [ i ] [ j ] ; } } orthes ( ) ; hqr2 ( ) ; } }	check for symmetry , then construct the eigenvalue decomposition.
public searchsourcebuilder fields ( string ... fields ) { if ( fieldnames == null ) { fieldnames = new arraylist < > ( ) ; } collections . addall ( fieldnames , fields ) ; return this ; }	adds the fields to load and return as part of the search request.
public static stringbuilder formatto ( stringbuilder buf , boolean [ ] d , string sep ) { if ( d == null ) { return buf . append ( _str ) ; } if ( d . length == _num ) { return buf ; } buf . append ( d [ _num ] ) ; for ( int i = _num ; i < d . length ; i ++ ) { buf . append ( sep ) ; buf . append ( format ( d [ i ] ) ) ; } return buf ; }	formats the boolean array d .
public string tocompletestring ( ) { string ret = _str ; if ( ! lines . isempty ( ) && ! config . v ( ) . nosourceinfo ) { for ( sourcelocationtag line : lines ) { ret += _str + line + _str ; } } ret += tosignaturestring ( ) ; return ret ; }	return a string of all the information of this method object : line numbers , receiver and signature .
@ override public void updatereceiptdetails ( final set < billreceiptinfo > billreceipts ) { logger . debug ( _str + billreceipts ) ; final boolean status = _bool ; if ( billreceipts != null ) super . updatereceiptdetails ( billreceipts ) ; logger . debug ( _str + status ) ; }	this method is invoked from collections end when an event related to receipt in bill generation occurs .
public static void removemapentries ( map map , set set ) { if ( ( set != null ) && ! set . isempty ( ) ) { for ( iterator iter = set . iterator ( ) ; iter . hasnext ( ) ; ) { map . remove ( iter . next ( ) ) ; } } }	removes the mapping of which keys matches with items in a given set .
public static void putfile ( serviceclient h , final operation put , file f ) throws ioexception { final asynchronousfilechannel ch = asynchronousfilechannel . open ( f . topath ( ) , standardopenoption . read ) ; atomicinteger completioncount = new atomicinteger ( _num ) ; string contenttype = fileutils . getcontenttype ( f . touri ( ) ) ; final boolean [ ] fileisdone = { _bool } ; putchunks ( h , put , ch , contenttype , f . length ( ) , _num , completioncount , fileisdone ) ; }	given a post operation and a file , post the file to the uri .
protected stringbuilder processline ( string nextelement ) { stringbuilder sb = new stringbuilder ( initial_string_size ) ; for ( int j = _num ; j < nextelement . length ( ) ; j ++ ) { char nextchar = nextelement . charat ( j ) ; processcharacter ( sb , nextchar ) ; } return sb ; }	processes all the characters in a line .
public javarefactoringdescriptor ( final string id , final string project , final string description , final string comment , final map arguments , final int flags ) { super ( id , project , description , comment , flags ) ; farguments = arguments ; farguments . put ( attribute_version , value_version_1_0 ) ; }	creates a new java refactoring descriptor .
private static supportedgroup negotiatenamedcurve ( clienthello clienthello ) { supportedgroup result = null ; list < supportedgroup > preferredgroups = supportedgroup . getpreferredgroups ( ) ; supportedellipticcurvesextension extension = clienthello . getsupportedellipticcurvesextension ( ) ; if ( extension == null ) { if ( ! preferredgroups . isempty ( ) ) { result = preferredgroups . get ( _num ) ; } } else { for ( integer preferredgroupid : extension . getsupportedgroupids ( ) ) { supportedgroup group = supportedgroup . fromid ( preferredgroupid ) ; if ( group != null && group . isusable ( ) && preferredgroups . contains ( group ) ) { result = group ; break ; } } } return result ; }	determines the elliptic curve to use during the ec based dh key exchange .
public void zoom ( ) { if ( getselectedrowkey ( ) != null && getselectedrowkey ( ) > _num ) { mquery zoomquery = new mquery ( ) ; string column = getkeycolumn ( ) ; if ( column . indexof ( _str ) > _num ) column = column . substring ( column . indexof ( _str ) + _num ) ; zoomquery . addrestriction ( column , mquery . equal , getselectedrowkey ( ) ) ; zoomquery . setrecordcount ( _num ) ; zoomquery . settablename ( column . substring ( _num , column . length ( ) - _num ) ) ; aenv . zoom ( _num , zoomquery ) ; } }	zoom action to be overwritten by concrete classes.
public long avgrate ( ) { long sum = _num ; for ( sample s : samples ) { sum += s . rate ( ) ; } return ( long ) ( sum / ( long ) samples . size ( ) ) ; }	returns the average of the message rates in the samplegroup .
@ override public synchronized void close ( ) throws ioexception { try { if ( synctask != null ) { synctask . cancel ( ) ; } sync ( ) ; unmapfile ( ) ; } finally { super . close ( ) ; } }	closes the underlying rrd file .
public boolean mousemoved ( mouseevent e ) { omgraphic newselectedgraphic ; if ( show_plot_ && graph != null ) { newselectedgraphic = graph . selectpoint ( e . getx ( ) , e . gety ( ) , _num ) ; if ( newselectedgraphic != null ) { string infostring = ( string ) ( newselectedgraphic . getattribute ( omgraphic . app_object ) ) ; if ( infostring != null ) { firerequestinfoline ( infostring ) ; } } else { firerequestinfoline ( _str ) ; } return _bool ; } else { omgraphiclist list = getlist ( ) ; if ( list != null ) { newselectedgraphic = list . selectclosest ( e . getx ( ) , e . gety ( ) , _num ) ; if ( newselectedgraphic != null && ( selectedgraphic == null || newselectedgraphic != selectedgraphic ) ) { debug . message ( _str , _str ) ; selectedgraphic = newselectedgraphic ; selectedgraphic . regenerate ( getprojection ( ) ) ; globesite site = ( globesite ) ( newselectedgraphic . getattribute ( omgraphic . app_object ) ) ; if ( site != null ) { firerequestinfoline ( site . getinfo ( ) ) ; } repaint ( ) ; } else if ( selectedgraphic != null && newselectedgraphic == null ) { debug . message ( _str , _str ) ; selectedgraphic . regenerate ( getprojection ( ) ) ; firerequestinfoline ( _str ) ; selectedgraphic = null ; repaint ( ) ; } return _bool ; } } return _bool ; }	called whenever the mouse is moved on this layer and one of the requested mouse modes is active.
public void hidepopup ( ) { showpending = _bool ; if ( popup != null ) { popup . hide ( ) ; popup = null ; } }	hides the popup window .
public final runtimeexception processdomethodinvokeexception ( exception e , object object , object [ ] argumentarray ) { if ( e instanceof runtimeexception ) return ( runtimeexception ) e ; return metaclasshelper . createexceptiontext ( _str , this , object , argumentarray , e , _bool ) ; }	this method is called when an exception occurs while invoking this method .
protected boolean buildsubfielddefns ( string pszsublist ) { if ( pszsublist . charat ( _num ) == _str ) { brepeatingsubfields = _bool ; pszsublist = pszsublist . substring ( _num ) ; } vector papszsubfieldnames = proputils . parsemarkers ( pszsublist , _str ) ; paosubfielddefns = new vector ( ) ; for ( iterator it = papszsubfieldnames . iterator ( ) ; it . hasnext ( ) ; ) { ddfsubfielddefinition ddfsd = new ddfsubfielddefinition ( ) ; ddfsd . setname ( ( string ) it . next ( ) ) ; paosubfielddefns . add ( ddfsd ) ; } return _bool ; }	based on the list contained in the string , build a set of subfield definitions .
public boolean isrunning ( ) { return mrunning . get ( ) ; }	indicates if this thread is running.
private static map < string , boolean > objectmethodstogenerate ( list < executableelement > methods ) { map < string , boolean > vars = new treemap < string , boolean > ( ) ; vars . put ( _str , _bool ) ; vars . put ( _str , _bool ) ; vars . put ( _str , _bool ) ; for ( executableelement method : methods ) { if ( istostringorequalsorhashcode ( method ) ) { boolean cangenerate = method . getmodifiers ( ) . contains ( modifier . abstract ) || isjavalangobject ( ( typeelement ) method . getenclosingelement ( ) ) ; vars . put ( method . getsimplename ( ) . tostring ( ) , cangenerate ) ; } } assert vars . size ( ) == _num ; return vars ; }	given a list of all methods defined in or inherited by a class , returns a map with keys " tostring " , " equals " , " hashcode " and corresponding value true if that method should be generated .
public void addentrytime ( double time ) { if ( entrytimes == null ) { return ; } if ( time < _num ) { time = _num ; } entrytimes . add ( double . valueof ( time ) ) ; }	register the time the packet arrives at an entity such as a router or cloudresource.
public void test_singleresourcelocking_serialized_waitsfor_highconcurrency ( ) throws exception { final properties properties = new properties ( ) ; final int nthreads = _num ; final int ntasks = _num ; properties . setproperty ( testoptions . core_pool_size , _str + nthreads ) ; properties . setproperty ( testoptions . ntasks , _str + ntasks ) ; properties . setproperty ( testoptions . nresources , _str ) ; properties . setproperty ( testoptions . min_locks , _str ) ; properties . setproperty ( testoptions . max_locks , _str ) ; properties . setproperty ( testoptions . predeclare_locks , _str ) ; properties . setproperty ( testoptions . sort_lock_requests , _str ) ; final result result = docomparisontest ( properties ) ; assertequals ( _str , _num , integer . parseint ( result . get ( _str ) ) ) ; assertequals ( _str , _num , integer . parseint ( result . get ( _str ) ) ) ; assertequals ( _str , ntasks , integer . parseint ( result . get ( _str ) ) ) ; }	test where each operation locks only a single resource and there is only one resource to be locked so that all operations must be serialized .
public final double npv ( ) { calculate ( ) ; ql . require ( ! double . isnan ( this . npv ) , _str ) ; return npv ; }	returns the net present value of the instrument .
public arrayrealvector ( arrayrealvector v1 , realvector v2 ) { final int l1 = v1 . data . length ; final int l2 = v2 . getdimension ( ) ; data = new double [ l1 + l2 ] ; system . arraycopy ( v1 . data , _num , data , _num , l1 ) ; for ( int i = _num ; i < l2 ; ++ i ) { data [ l1 + i ] = v2 . getentry ( i ) ; } }	construct a vector by appending one vector to another vector .
public static map < string , object > deactivatecontentassoc ( dispatchcontext dctx , map < string , ? extends object > rcontext ) { map < string , object > context = utilmisc . makemapwritable ( rcontext ) ; context . put ( _str , _str ) ; list < string > targetoperationlist = contentworker . preptargetoperationlist ( context , _str ) ; list < string > contentpurposelist = contentworker . prepcontentpurposelist ( context ) ; context . put ( _str , targetoperationlist ) ; context . put ( _str , contentpurposelist ) ; context . put ( _str , null ) ; map < string , object > result = deactivatecontentassocmethod ( dctx , context ) ; return result ; }	update a contentassoc service.
public bytebuffer flushandreleasebuffer ( ) throws ioexception { _lock . lock ( ) ; try { _flushpending = _bool ; while ( _bufferusecount != _num ) { _flushready . await ( ) ; } _buffer . flip ( ) ; if ( _buffer . limit ( ) != _num && _modified ) { if ( _backingfile == null ) { _backingfile = files . createtempfile ( _str , _str ) ; } _log . debug ( _str , _startindex , _backingfile , _buffer . limit ( ) , _blocksize ) ; try ( bytechannel out = files . newbytechannel ( _backingfile , write ) ) { out . write ( _buffer ) ; } } else { _log . debug ( _str , _startindex ) ; } bytebuffer oldbuffer = _buffer ; _buffer = null ; _loaded = _bool ; return oldbuffer ; } catch ( interruptedexception e ) { throw throwables . propagate ( e ) ; } finally { _flushpending = _bool ; _flushcomplete . signalall ( ) ; _lock . unlock ( ) ; } }	flushes the block ' s buffer to disk and releases the buffer for use by another block.
public static boolean isdirectlygettingpowered ( world world , coord4d coord ) { for ( forgedirection side : forgedirection . valid_directions ) { coord4d sidecoord = coord . getfromside ( side ) ; if ( sidecoord . exists ( world ) ) { if ( world . isblockprovidingpowerto ( coord . xcoord , coord . ycoord , coord . zcoord , side . ordinal ( ) ) > _num ) { return _bool ; } } } return _bool ; }	checks if a block is directly getting powered by any of its neighbors without loading any chunks .
public < t extends propertycontainer > list < searchmatch < t > > search ( string query , class < t > clazz ) { searchresult result = doquery ( query , clazz ) ; list < searchmatch < t > > matches = buildsearchmatches ( result ) ; @ suppresswarnings ( _str ) function < searchmatch , t > resolver = ( function < searchmatch , t > ) ( clazz . equals ( node . class ) ? getnoderesolver ( ) : getrelationshipresolver ( ) ) ; return resolvematchitems ( matches , resolver ) ; }	search for nodes or relationships.
private synchronized void enumerate ( hashtable < string , object > h ) { if ( defaults != null ) { defaults . enumerate ( h ) ; } for ( enumeration < ? > e = keys ( ) ; e . hasmoreelements ( ) ; ) { string key = ( string ) e . nextelement ( ) ; h . put ( key , get ( key ) ) ; } }	enumerates all key / value pairs in the specified hashtable .
public void updatequantitycsv ( itembean original , itembean itemtoadd , boolean add ) { bigdecimal originalquantity = original . getqtycsv ( ) ; bigdecimal quantitytoadd = itemtoadd . getqtycsv ( ) ; bigdecimal finalquantity = null ; if ( ! add ) finalquantity = originalquantity . subtract ( quantitytoadd ) ; else finalquantity = originalquantity . add ( quantitytoadd ) ; original . setqtycsv ( finalquantity ) ; }	update quantity csv in inventory.
public static number abs ( number a ) { if ( isfloatingpoint ( a ) ) { return math . abs ( a . doublevalue ( ) ) ; } else { return math . abs ( a . longvalue ( ) ) ; } }	returns the absolute value of the number .
public user ( string id , string name , string email ) { this . id = id ; this . email = email ; this . name = name ; }	construct a user given an id , name , and email .
@ suppresswarnings ( _str ) public object [ ] toarray ( ) { final reentrantlock lock = this . lock ; lock . lock ( ) ; try { object [ ] a = new object [ count ] ; int k = _num ; for ( node < e > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }	returns an array containing all of the elements in this deque , in proper sequence ( from first to last element ).
public static asset createassetfrombitmap ( bitmap bitmap ) { if ( bitmap != null ) { final bytearrayoutputstream bytestream = new bytearrayoutputstream ( ) ; bitmap . compress ( bitmap . compressformat . png , _num , bytestream ) ; return asset . createfrombytes ( bytestream . tobytearray ( ) ) ; } return null ; }	create a wearable asset from a bitmap .
public boolean isipvalid ( session sess , string clientip ) throws ssoexception { boolean check = _bool ; try { inetaddress sessipaddress = inetaddress . getbyname ( sess . getproperty ( _str ) ) ; inetaddress clientipaddress = inetaddress . getbyname ( clientip ) ; if ( sessipaddress . equals ( clientipaddress ) ) { check = _bool ; } } catch ( exception e ) { if ( debug . messageenabled ( ) ) { debug . message ( _str , e ) ; } } return check ; }	validate the ip address of the client with the ip stored in session .
@ suppresswarnings ( _str ) private static void handlemethodnode ( getstaticgraph staticusagetree , classnode cn , methodnode mn , int depth ) { insnlist instructions = mn . instructions ; iterator < abstractinsnnode > iterator = instructions . iterator ( ) ; while ( iterator . hasnext ( ) ) { abstractinsnnode insn = iterator . next ( ) ; if ( insn instanceof methodinsnnode ) { handlemethodinsnnode ( staticusagetree , cn , mn , ( methodinsnnode ) insn , depth + _num ) ; } else if ( insn instanceof fieldinsnnode ) { handlefieldinsnnode ( staticusagetree , cn , mn , ( fieldinsnnode ) insn , depth + _num ) ; } } }	add all possible calls for a given method.
public void addparameter ( namevaluepair param ) throws illegalargumentexception { log . trace ( _str ) ; if ( param == null ) { throw new illegalargumentexception ( _str ) ; } addparameter ( param . getname ( ) , param . getvalue ( ) ) ; }	adds a new parameter to be used in the post request body .
private void readpolicies ( xmlpullparser parser ) throws ioexception , xmlpullparserexception { while ( parser . next ( ) != xmlpullparser . end_tag ) { if ( parser . geteventtype ( ) != xmlpullparser . start_tag ) { continue ; } string name = parser . getname ( ) ; if ( tag_user_restriction . equals ( name ) ) { string userrestriction = parser . getattributevalue ( null , attribute_name ) ; if ( userrestriction != null ) { muserrestrictions . add ( userrestriction ) ; } } else if ( tag_global_setting . equals ( name ) ) { string setting = parser . getattributevalue ( null , attribute_name ) ; string value = parser . getattributevalue ( null , attribute_value ) ; if ( setting != null && value != null ) { mglobalsettings . add ( new globalsetting ( setting , value ) ) ; } } else if ( tag_disable_status_bar . equals ( name ) ) { mdisablestatusbar = boolean . parseboolean ( parser . getattributevalue ( null , attribute_value ) ) ; } else if ( tag_disable_keyguard . equals ( name ) ) { mdisablekeyguard = boolean . parseboolean ( parser . getattributevalue ( null , attribute_value ) ) ; } else if ( tag_disable_camera . equals ( name ) ) { mdisablecamera = boolean . parseboolean ( parser . getattributevalue ( null , attribute_value ) ) ; } else if ( tag_disable_screen_capture . equals ( name ) ) { mdisablescreencapture = boolean . parseboolean ( parser . getattributevalue ( null , attribute_value ) ) ; } skipcurrenttag ( parser ) ; } }	read the policies to be set.
public boolean readheader ( randomaccessfile raf ) throws ioexception { stringbuffer id = new stringbuffer ( _num ) ; for ( int i = _num ; i < _num ; i ++ ) { int ch = raf . read ( ) ; if ( ch < _num ) { string hx = integer . tohexstring ( ch ) ; if ( hx . length ( ) < _num ) { hx = _str + hx ; } return _bool ; } id . append ( ( char ) ch ) ; } _chunkid = id . tostring ( ) ; _size = aiffutil . readuint32 ( raf ) ; return _bool ; }	reads the header of a chunk.
private xyplot initializeplot ( ) { jmxchart = new yintervalseriesimproved ( _str ) ; yintervalseriescollection yintervalseriescollection = new yintervalseriescollection ( ) ; yintervalseriescollection . addseries ( jmxchart ) ; deviationrenderer renderer = new deviationrenderer ( _bool , _bool ) ; renderer . setbaseshapesvisible ( _bool ) ; renderer . setseriesstroke ( _num , new basicstroke ( _num , basicstroke . cap_round , basicstroke . join_round ) ) ; renderer . setseriesfillpaint ( _num , new color ( _num , _num , _num ) ) ; renderer . setseriesoutlinestroke ( _num , new basicstroke ( _num ) ) ; renderer . setseriesshape ( _num , new ellipse2d . double ( - _num , - _num , _num , _num ) ) ; renderer . setbasetooltipgenerator ( new standardxytooltipgenerator ( standardxytooltipgenerator . default_tool_tip_format , dateformat . getdatetimeinstance ( ) , numberformat . getnumberinstance ( ) ) ) ; numberaxis rangeaxis = plotdatasolver . getaxis ( ) ; subplot = new xyplot ( yintervalseriescollection , null , rangeaxis , renderer ) ; subplot . setaxisoffset ( new rectangleinsets ( _num , _num , _num , _num ) ) ; subplot . setrangeaxislocation ( axislocation . top_or_left ) ; subplot . setrangecrosshairvisible ( _bool ) ; return subplot ; }	initializes the upper plot .
private boolean isfatalstate ( string sqlstate ) { if ( sqlstate == null || sqlstate . length ( ) < _num ) { return _bool ; } for ( string fatal_sql_state_class : fatal_sql_state_classes ) { if ( sqlstate . startswith ( fatal_sql_state_class ) ) { return _bool ; } } return _bool ; }	decides if the given sql state is a fatal connection error .
private void analyzefile ( file inputfile , optional < commontokenstream > opttokenstream , optional < toplevelcontext > opttree , formatter formatter , severity maxseverity , constructlengths constructlengths , set < rules > enabledrules ) throws cliargumentparserexception { try { printer printer = new printer ( inputfile , maxseverity , formatter ) ; if ( opttokenstream . ispresent ( ) && opttree . ispresent ( ) ) { commontokenstream tokenstream = opttokenstream . get ( ) ; toplevelcontext tree = opttree . get ( ) ; commentextractor commentextractor = new commentextractor ( tokenstream ) ; violationsuppressor disableanalysis = new violationsuppressor ( printer , commentextractor . getsinglelinecomments ( ) , commentextractor . getmultilinecomments ( ) ) ; disableanalysis . analyze ( ) ; list < swiftbaselistener > listeners = createlisteners ( enabledrules , printer , tokenstream , constructlengths , commentextractor ) ; walkparsetree ( listeners , tree ) ; try ( filelistener filelistener = new filelistener ( printer , inputfile , constructlengths , enabledrules ) ) { filelistener . verify ( ) ; } numerrors . addandget ( printer . getnumerrormessages ( ) ) ; numwarnings . addandget ( printer . getnumwarningmessages ( ) ) ; } else { printer . setshouldprintparseerrormessage ( _bool ) ; } printersforallfiles . add ( printer ) ; } catch ( ioexception e ) { handleioexception ( e ) ; } catch ( cliargumentparserexception e ) { handlecliexception ( e ) ; } }	analyzes an individual file by creating the corresponding listeners and walking the file ' s parse tree .
@ suppresswarnings ( _str ) public static < valuet > valuet toobject ( bytebuffer bf ) throws ioexception , classnotfoundexception { object obj = null ; inputstream is = null ; objectinputstream ois = null ; try { is = new bytebufferbackedinputstream ( bf ) ; ois = new objectinputstream ( is ) ; obj = ois . readobject ( ) ; } finally { if ( is != null ) { is . close ( ) ; } if ( ois != null ) { ois . close ( ) ; } } return ( valuet ) obj ; }	de - serialize an object from a bytebuffer object .
static private void scandeadlinequeue ( final long nownanos , final priorityblockingqueue < querydeadline > deadlinequeue ) { final list < querydeadline > c = new arraylist < querydeadline > ( deadline_queue_scan_size ) ; deadlinequeue . drainto ( c , deadline_queue_scan_size ) ; int ndropped = _num , nrunning = _num ; for ( querydeadline x : c ) { if ( x . checkdeadline ( nownanos ) != null ) { deadlinequeue . add ( x ) ; nrunning ++ ; } else { ndropped ++ ; } } if ( log . isinfoenabled ( ) ) log . info ( _str + deadline_queue_scan_size + _str + ndropped + _str + nrunning + _str + deadlinequeue . size ( ) ) ; }	queries with a deadline that lies significantly in the future can lie around in the priority queue until that deadline is reached if there are other queries in front of them that are not terminated and whose deadline has not be reached.
public int compare ( file file1 , file file2 ) { return casesensitivity . checkcompareto ( file1 . getname ( ) , file2 . getname ( ) ) ; }	compare the names of two files with the specified case sensitivity .
@ override public string laststring ( ) { return integer . tostring ( lastint ) ; }	return the previous string generated by the distribution ; e.
public boolean removeitemcontent ( string uid ) { if ( ! users . isempty ( ) ) { return removecontent ( uid , users ) ; } else if ( ! reports . isempty ( ) ) { return removecontent ( uid , reports ) ; } else { return removecontent ( uid , resources ) ; } }	removes the content with the given uid.
public void close ( ) { if ( dialog != null ) { dialog . setvisible ( _bool ) ; dialog . dispose ( ) ; dialog = null ; pane = null ; mybar = null ; } }	indicate that the operation is complete.
public static void expandordinal ( string rawnumberstring , wordrelation wordrelation ) { string numberstring = utilities . deletechar ( rawnumberstring , _str ) ; expandnumber ( numberstring , wordrelation ) ; item lastitem = wordrelation . gettail ( ) ; if ( lastitem != null ) { featureset featureset = lastitem . getfeatures ( ) ; string lastnumber = featureset . getstring ( _str ) ; string ordinal = findmatchinarray ( lastnumber , digit2num , ord2num ) ; if ( ordinal == null ) { ordinal = findmatchinarray ( lastnumber , digit2teen , ord2teen ) ; } if ( ordinal == null ) { ordinal = findmatchinarray ( lastnumber , digit2enty , ord2enty ) ; } if ( lastnumber . equals ( _str ) ) { ordinal = _str ; } else if ( lastnumber . equals ( _str ) ) { ordinal = _str ; } else if ( lastnumber . equals ( _str ) ) { ordinal = _str ; } if ( ordinal != null ) { wordrelation . setlastword ( ordinal ) ; } } }	expands the digit string of an ordinal number .
private void checkboundedtypeparameter ( method method ) { typevariable < method > typeparameter = gettypeparameter ( method ) ; assertequals ( _str , typeparameter . getname ( ) ) ; assertequals ( method , typeparameter . getgenericdeclaration ( ) ) ; type [ ] bounds = typeparameter . getbounds ( ) ; assertlenghtone ( bounds ) ; type bound = bounds [ _num ] ; assertequals ( boundedwildcardsgenericmethods . class , bound ) ; }	tests whether the type parameter is bounded by boundedgenericmethods like : < t extends boundedgenericmethods > .
public void registersensor ( sensor s , int i ) { if ( ( i < _num ) || ( i > ( inputbits [ nodetype ] - _num ) ) || ( i > maxsensors ) ) { log . error ( _str + integer . tostring ( i + _num ) ) ; return ; } hasactivesensors = _bool ; if ( sensorarray [ i ] == null ) { sensorarray [ i ] = s ; if ( lastusedsensor < i ) { lastusedsensor = i ; } } else { log . warn ( _str + integer . tostring ( ( getnodeaddress ( ) * serialsensormanager . sensorspernode ) + i + _num ) ) ; } }	the numbers here are 0 to maxsensors , not 1 to maxsensors .
public boolean hasorganisationunits ( ) { list < dimensionalitemobject > dimopts = getdimensionoptions ( orgunit_dim_id ) ; list < dimensionalitemobject > filteropts = getfilteroptions ( orgunit_dim_id ) ; return ! dimopts . isempty ( ) || ! filteropts . isempty ( ) ; }	indicates whether organisation units are present as dimension or filter .
protected void fixupblocks ( byte [ ] bytes2 ) { byte [ ] bytes = bytes2 ; for ( iterator enumerator = blocks . iterator ( ) ; enumerator . hasnext ( ) ; ) { int [ ] info = ( int [ ] ) enumerator . next ( ) ; int codesize = info [ _num ] ; int offset = info [ _num ] ; byte [ ] sizebytes = outstream . sintto2bytes ( codesize ) ; bytes [ offset ] = sizebytes [ _num ] ; bytes [ offset + _num ] = sizebytes [ _num ] ; } }	description of the method.
protected double negativeloglikelihood ( double [ ] [ ] datays , double [ ] [ ] probs ) { double loglikelihood = _num ; for ( int i = _num ; i < datays . length ; i ++ ) { for ( int j = _num ; j < m_numclasses ; j ++ ) { if ( datays [ i ] [ j ] == _num ) { loglikelihood -= math . log ( probs [ i ] [ j ] ) ; } } } return loglikelihood ; }	returns the negative loglikelihood of the y - values ( actual class probabilities ) given the p - values ( current probability estimates ) .
public static boolean validsystemnameconfig ( string systemname , char type , acelasystemconnectionmemo memo ) { if ( ! validsystemnameformat ( systemname , type , memo . getsystemprefix ( ) ) ) { return _bool ; } acelanode node = getnodefromsystemname ( systemname , memo ) ; if ( node == null ) { return _bool ; } int bit = getbitfromsystemname ( systemname ) ; if ( ( type == _str ) || ( type == _str ) ) { if ( ( bit < minoutputaddress ) || ( bit > maxoutputaddress ) ) { return _bool ; } } else if ( type == _str ) { if ( ( bit < minsensoraddress ) || ( bit > maxsensoraddress ) ) { return _bool ; } } else { log . error ( _str ) ; return _bool ; } return _bool ; }	public static method to validate acela system name for configuration returns ' true ' if system name has a valid meaning in current configuration , else returns ' false '.
public void addmember ( string playername ) { openinvites . remove ( playername ) ; membersandlastseen . put ( playername , long . valueof ( system . currenttimemillis ( ) ) ) ; if ( leader == null ) { leader = playername ; } sendgroupchangeevent ( ) ; }	adds a member to the group.
public bubblexyitemlabelgenerator ( ) { this ( default_format_string , numberformat . getnumberinstance ( ) , numberformat . getnumberinstance ( ) , numberformat . getnumberinstance ( ) ) ; }	creates a new tool tip generator using default number formatters for the x , y and z - values .
void addnodes ( list < node > newnodes , boolean atbeginning ) { if ( atbeginning ) { if ( ( nodes . size ( ) > _num ) && nodes . get ( _num ) == newnodes . get ( newnodes . size ( ) - _num ) ) { log . i ( debug_tag , _str ) ; if ( newnodes . size ( ) > _num ) { log . i ( debug_tag , _str ) ; newnodes . remove ( newnodes . size ( ) - _num ) ; addnodes ( newnodes , atbeginning ) ; } return ; } nodes . addall ( _num , newnodes ) ; } else { if ( ( nodes . size ( ) > _num ) && newnodes . get ( _num ) == nodes . get ( nodes . size ( ) - _num ) ) { log . i ( debug_tag , _str ) ; if ( newnodes . size ( ) > _num ) { log . i ( debug_tag , _str ) ; newnodes . remove ( _num ) ; addnodes ( newnodes , atbeginning ) ; } return ; } nodes . addall ( newnodes ) ; } }	adds multiple nodes to the way in the order in which they appear in the list.
public synchronized boolean updateavclientbystreamid ( string streamid , roomclient rcm ) { try { roomclient rclusual = getclientbypublicsid ( rcm . getpublicsid ( ) , _bool ) ; if ( rclusual != null ) { rclusual . setbroadcastid ( rcm . getbroadcastid ( ) ) ; rclusual . setavsettings ( rcm . getavsettings ( ) ) ; rclusual . setvheight ( rcm . getvheight ( ) ) ; rclusual . setvwidth ( rcm . getvwidth ( ) ) ; rclusual . setvx ( rcm . getvx ( ) ) ; rclusual . setvy ( rcm . getvy ( ) ) ; if ( clientlist . containskey ( rclusual . getstreamid ( ) ) ) { clientlist . put ( rclusual . getstreamid ( ) , rclusual ) ; } else { log . debug ( _str + rclusual . getstreamid ( ) ) ; } } updateclientbystreamid ( streamid , rcm ) ; } catch ( exception err ) { log . error ( _str , err ) ; } return null ; }	update the session object of the audio / video - connection and additionally swap the values to the session object of the user that holds the full session object.
public void addcolor ( int color ) { if ( mcolors == null ) mcolors = new arraylist < integer > ( ) ; mcolors . add ( color ) ; }	adds a new color to the colors array of the dataset .
private void clampstartingposition ( ) { final float cx = mbounds . exactcenterx ( ) ; final float cy = mbounds . exactcentery ( ) ; final float dx = mstartingx - cx ; final float dy = mstartingy - cy ; final float r = mtargetradius ; if ( dx * dx + dy * dy > r * r ) { final double angle = math . atan2 ( dy , dx ) ; mclampedstartingx = cx + ( float ) ( math . cos ( angle ) * r ) ; mclampedstartingy = cy + ( float ) ( math . sin ( angle ) * r ) ; } else { mclampedstartingx = mstartingx ; mclampedstartingy = mstartingy ; } }	clamps the starting position to fit within the ripple bounds .
public boolean isempty ( ) { if ( lastbatch != null ) { if ( ! lastbatch . isempty ( ) ) { return _bool ; } } return currentbatch . isempty ( ) ; }	returns true if the window is empty , or false if not empty .
@ suppresswarnings ( _str ) public dummydata ( int cols , int rows , comparable < ? > value ) { value . getclass ( ) ; this . cols = cols ; this . rows = rows ; this . value = value ; class < ? extends comparable < ? > > [ ] types = new class [ cols ] ; arrays . fill ( types , value . getclass ( ) ) ; setcolumntypes ( types ) ; }	creates a new instance with the specified number of columns and rows , which are filled all over with the same specified value .
public object clone ( ) throws clonenotsupportedexception { nodevector clone = ( nodevector ) super . clone ( ) ; if ( ( null != this . m_map ) && ( this . m_map == clone . m_map ) ) { clone . m_map = new int [ this . m_map . length ] ; system . arraycopy ( this . m_map , _num , clone . m_map , _num , this . m_map . length ) ; } return clone ; }	get a cloned locpathiterator .
public boolean matchwithpattern ( string pattern ) { if ( textutils . isempty ( pattern ) ) { mcurrentpattern = _str ; muppercasepattern = _str ; mlowercasepattern = _str ; } if ( textutils . isempty ( mdisplayname ) ) { return _bool ; } if ( textutils . isempty ( muppercasedisplayname ) ) { muppercasedisplayname = mdisplayname . tolowercase ( ) ; mlowercasedisplayname = mdisplayname . touppercase ( ) ; } if ( ! pattern . equals ( mcurrentpattern ) ) { mcurrentpattern = pattern ; muppercasepattern = pattern . touppercase ( ) ; mlowercasepattern = pattern . tolowercase ( ) ; } return ( muppercasedisplayname . indexof ( muppercasepattern ) >= _num ) || ( mlowercasedisplayname . indexof ( muppercasepattern ) >= _num ) ; }	test if some fields match with the pattern.
public boolean equals ( object obj ) { if ( obj == this ) { return _bool ; } if ( obj instanceof annotationmember ) { annotationmember that = ( annotationmember ) obj ; if ( name . equals ( that . name ) && tag == that . tag ) { if ( tag == array ) { return equalarrayvalue ( that . value ) ; } else if ( tag == error ) { return _bool ; } else { return value . equals ( that . value ) ; } } } return _bool ; }	returns true if the specified object represents equal element ( equivalent name - value pair ).
public static range iteratezbounds ( xyzdataset dataset , boolean includeinterval ) { double minimum = double . positive_infinity ; double maximum = double . negative_infinity ; int seriescount = dataset . getseriescount ( ) ; for ( int series = _num ; series < seriescount ; series ++ ) { int itemcount = dataset . getitemcount ( series ) ; for ( int item = _num ; item < itemcount ; item ++ ) { double value = dataset . getzvalue ( series , item ) ; if ( ! double . isnan ( value ) ) { minimum = math . min ( minimum , value ) ; maximum = math . max ( maximum , value ) ; } } } if ( minimum == double . positive_infinity ) { return null ; } else { return new range ( minimum , maximum ) ; } }	iterates over the data items of the xyz dataset to find the z - dimension bounds .
public void removeviewfromfadelist ( view view ) { if ( mfadeviewlist != null && view != null ) { mfadeviewlist . remove ( view ) ; } }	remove view that has been added by addviewtofadelist.
void addindifferentalgorithm ( string algorithm ) { indifferentalgorithms . add ( algorithm ) ; }	adds an algorithm with statistically similar performance to the current algorithm .
public unioniterator ( iterable < ? extends e > ... args ) { this ( arrays . aslist ( args ) ) ; }	creates a new unioniterator that returns the bag union of the results of a number of iterators .
public static string manglenativemethod ( string owner , string name , string desc ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( _str ) ; sb . append ( manglenativestring ( owner ) ) ; sb . append ( _str ) ; sb . append ( manglenativestring ( name ) ) ; if ( desc != null ) { sb . append ( _str ) ; sb . append ( manglenativestring ( desc . substring ( _num , desc . lastindexof ( _str ) ) ) ) ; } return sb . tostring ( ) ; }	returns the long version of the jni function name for a method .
public string readline ( ) throws ioexception { boolean gotcr = _bool , gotlf = _bool ; pos = _num ; linebuf = new stringbuffer ( ) ; while ( ! gotlf ) { int c = is . read ( ) ; if ( c == - _num ) { return null ; } if ( gotcr ) { if ( c == lf ) { gotlf = _bool ; } else { gotcr = _bool ; consume ( cr ) ; consume ( c ) ; } } else { if ( c == cr ) { gotcr = _bool ; } else { consume ( c ) ; } } } linebuf . append ( buf , _num , pos ) ; return new string ( linebuf ) ; }	read a line from the stream returning as a string.
public lobbyclient login ( ) { if ( ! m_serverproperties . isserveravailable ( ) ) { joptionpane . showmessagedialog ( m_parent , m_serverproperties . servererrormessage , _str , joptionpane . error_message ) ; return null ; } if ( m_serverproperties . port == - _num ) { if ( clientfilesystemhelper . areweoldextrajar ( ) ) { joptionpane . showmessagedialog ( m_parent , _str + urlconstants . latest_game_download_website + _str + _str , _str , joptionpane . error_message ) ; } else { joptionpane . showmessagedialog ( m_parent , _str + urlconstants . latest_game_download_website + _str , _str , joptionpane . error_message ) ; } return null ; } return logintoserver ( ) ; }	attempt to login to the lobbyserver < p > if we could not login , return null .
@ override public boolean eisset ( int featureid ) { switch ( featureid ) { case functionblockpackage . param__multiplicity : return multiplicity != multiplicity_edefault ; case functionblockpackage . param__name : return name_edefault == null ? name != null : ! name_edefault . equals ( name ) ; case functionblockpackage . param__description : return description_edefault == null ? description != null : ! description_edefault . equals ( description ) ; } return super . eisset ( featureid ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
protected node popnode ( stack < node > stack , class < ? extends node > cls , string uri ) { node top = stack . isempty ( ) ? null : stack . peek ( ) ; if ( top != null ) { if ( nodematches ( top , cls , uri ) ) { node node = stack . pop ( ) ; poppednodes . push ( node ) ; return node ; } else { for ( int i = stack . size ( ) - _num ; i >= _num ; i -- ) { if ( nodematches ( stack . get ( i ) , cls , uri ) ) { node node = stack . remove ( i ) ; poppednodes . push ( node ) ; return node ; } } } } return null ; }	this method pops a node of the defined class and optional uri from the stack.
public static double [ ] [ ] computeweightmatrix ( int bpp ) { final int dim = bpp * bpp * bpp ; final double [ ] [ ] m = new double [ dim ] [ dim ] ; final double max = _num * ( bpp - _num ) ; for ( int x = _num ; x < dim ; x ++ ) { final int rx = ( x / bpp ) / bpp ; final int gx = ( x / bpp ) % bpp ; final int bx = x % bpp ; for ( int y = x ; y < dim ; y ++ ) { final int ry = ( y / bpp ) / bpp ; final int gy = ( y / bpp ) % bpp ; final int by = y % bpp ; final double dr = math . abs ( rx - ry ) ; final double dg = math . abs ( gx - gy ) ; final double db = math . abs ( bx - by ) ; final double val = _num - ( dr + dg + db ) / max ; m [ x ] [ y ] = m [ y ] [ x ] = val ; } } return m ; }	compute weight matrix for a rgb color histogram.
private static boolean isgnome ( ) { return system . getenv ( _str ) != null ; }	checks if we are currently running under gnome desktop .
protected sizerequirements calculatemajoraxisrequirements ( int axis , sizerequirements r ) { sizerequirements req = super . calculatemajoraxisrequirements ( axis , r ) ; req . maximum = integer . max_value ; return req ; }	calculate the requirements needed along the major axis.
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public map < string , list < revisionfile > > currentrevisionfiles ( ) ;	returns the current revision files held by the handler .
public void endsubreport ( string subreport ) { if ( subreport . isempty ( ) ) { log . error ( string . format ( _str , subreport ) ) ; return ; } string topsubreport = subreports . peek ( ) ; if ( topsubreport . equals ( subreport ) ) { subreports . pop ( ) ; addlogentry ( new subreportendentry ( subreport ) ) ; return ; } log . error ( string . format ( _str , subreport ) ) ; }	closes the subreport . checks if the provided subreport name matches subreport name stored on the stack . if the names match , endsubreport will remove the subreport from stack and close it . otherwise , endsubreport will log an error in the report .
public static double dnormlog ( double x , double mean , double sd ) { if ( sd <= _num ) throw new illegalargumentexception ( _str ) ; return - math . log ( sd ) + dnormlog ( ( x - mean ) / sd ) ; }	returns the log - density value of a standard normal .
public static void delete ( file f ) { delete_ ( f , _bool ) ; }	delete a file or directory.
public boolean extendsentity ( class < ? > entitydefinition ) { return entitydefinition . getannotation ( extendsentity . class ) != null ; }	checks to see if the entity definition indicates that it extends another entity definition .
public void parse ( inputsource input ) throws ioexception , saxexception { if ( parsing ) { throw new saxexception ( _str ) ; } setupparser ( ) ; parsing = _bool ; try { parser . parse ( input ) ; } finally { parsing = _bool ; } parsing = _bool ; }	parse an xml document .
private void release0 ( long ptr , long size , atomiclong cnt ) { if ( ptr != _num ) { if ( safe_release ) fill ( ptr , size , ( byte ) _num ) ; gridunsafe . freememory ( ptr ) ; cnt . addandget ( - size ) ; if ( lsnr != null ) lsnr . onevent ( release ) ; } }	internal release procedure . decreases size of corresponding counter .
public void addservices ( list < servicedefinition > services ) throws exception { ensurepathexists ( ) ; set < string > remainingdescriptors = new hashset < > ( datamanager . getchildren ( zk_service_definition_path ) ) ; for ( servicedefinition service : services ) { log . debug ( string . format ( _str , service . serviceid ) ) ; string path = getservicedefinitionpath ( service . serviceid ) ; try { stat before = datamanager . checkexists ( path ) ; datamanager . putdata ( path , service ) ; stat after = datamanager . checkexists ( path ) ; nodeupdated ( path , before , after ) ; remainingdescriptors . remove ( service . serviceid ) ; } catch ( exception e ) { log . error ( string . format ( _str , service . serviceid , path ) , e ) ; throw e ; } } for ( string descriptorname : remainingdescriptors ) { log . info ( string . format ( _str , descriptorname ) ) ; datamanager . removenode ( zk_service_definition_path + _str + descriptorname ) ; } }	adds all the given service definitions to the zookeeper tree.
protected void readprops ( ) { int count ; properties props ; int i ; string itemstr ; t item ; m_ignorechanges = _bool ; props = loadprops ( ) ; count = integer . parseint ( props . getproperty ( expand ( getcountkey ( ) ) , _str ) ) ; m_recentitems . clear ( ) ; for ( i = count - _num ; i >= _num ; i -- ) { itemstr = props . getproperty ( getitemprefix ( ) + i , _str ) ; if ( itemstr . length ( ) > _num ) { item = fromstring ( itemstr ) ; if ( check ( item ) ) addrecentitem ( item ) ; } } m_ignorechanges = _bool ; }	reads the recent items from the props file .
public formindex stepindexout ( formindex index ) { if ( index . isterminal ( ) ) { return null ; } else { return new formindex ( stepindexout ( index . getnextlevel ( ) ) , index ) ; } }	used to go up one level in the formindex.
protected double kernelhelperlp ( int n , char [ ] s , int endindexs , char [ ] t , int endindext , int remainingmatchlength ) { if ( n == _num ) { return getreturnvalue ( n ) ; } if ( math . min ( endindexs + _num , endindext + _num ) < n ) { ; return getreturnvalue ( n ) ; } if ( remainingmatchlength < _num * n ) { return getreturnvalue ( n ) ; } int adr = _num ; if ( m_userecursioncache ) { adr = m_multx * n + m_multy * endindexs + m_multz * endindext + m_multzz * remainingmatchlength ; if ( cachekh2k [ adr % maxcache ] == adr + _num ) { return cachekh2 [ adr % maxcache ] ; } } int rml = _num ; double result = _num ; for ( int is = ( endindexs - remainingmatchlength ) ; is <= endindexs ; is ++ ) { result *= m_lambda ; result += kernelhelper2lp ( n , s , is , t , endindext , rml ++ ) ; } if ( m_userecursioncache && endindexs >= _num && endindext >= _num && n >= _num ) { cachekhk [ adr % maxcache ] = adr + _num ; cachekh [ adr % maxcache ] = result ; } return result ; }	helper function for the evaluation of the kernel ( k ' n ) using lambda pruning.
@ override protected synchronized void onmeasure ( int widthmeasurespec , int heightmeasurespec ) { int width = _num ; if ( measurespec . unspecified != measurespec . getmode ( widthmeasurespec ) ) { width = measurespec . getsize ( widthmeasurespec ) ; } int height = thumbimage . getheight ( ) ; if ( measurespec . unspecified != measurespec . getmode ( heightmeasurespec ) ) { height = math . min ( height , measurespec . getsize ( heightmeasurespec ) ) ; } setmeasureddimension ( width , height ) ; }	ensures correct size of the widget .
public void start ( ) { calculatepositionarray ( ) ; setpreferredsize ( calculatepreferredsize ( ) ) ; offset = getwidth ( ) ; timer = new timer ( interval , this ) ; timer . start ( ) ; }	start the ticker - do this only after the gui has been packed as the offset needs to know the actual width of the control to set itself correctly .
public static void writeplainfile ( string filepath , byte [ ] content ) throws ioexception { fileoutputstream fileouputstream = new fileoutputstream ( filepath ) ; fileouputstream . write ( content ) ; fileouputstream . close ( ) ; }	write byte array into a regular file.
public void transform ( affinetransform at ) { clip [ _num ] = clip [ _num ] ; clip [ _num ] = clip [ _num ] ; clip [ _num ] = clip [ _num ] ; clip [ _num ] = clip [ _num ] ; at . transform ( clip , _num , clip , _num , _num ) ; double xmin = clip [ _num ] , ymin = clip [ _num ] ; double xmax = clip [ _num ] , ymax = clip [ _num ] ; for ( int i = _num ; i < _num ; i += _num ) { if ( clip [ i ] < xmin ) xmin = clip [ i ] ; if ( clip [ i ] > xmax ) xmax = clip [ i ] ; if ( clip [ i + _num ] < ymin ) ymin = clip [ i + _num ] ; if ( clip [ i + _num ] > ymax ) ymax = clip [ i + _num ] ; } clip [ _num ] = xmin ; clip [ _num ] = ymin ; clip [ _num ] = xmax ; clip [ _num ] = ymax ; }	transform the clip contents.
@ suppresswarnings ( _str ) public boolean isportablefilename ( string filename ) { return ( filename . startswith ( program ) || filename . startswith ( home ) || filename . startswith ( preferences ) || filename . startswith ( scripts ) || filename . startswith ( profile ) || filename . startswith ( settings ) || filename . startswith ( file ) || filename . startswith ( resource ) ) ; }	test if the given filename is a portable filename.
void configurebasicauth ( httpserverrequest serverrequest , httpclientrequest httpclientrequest ) { final string authorization = serverrequest . getparam ( _str ) ; if ( authorization != null ) { httpclientrequest . putheader ( httpheaders . authorization , authorization ) ; } }	configure basic auth for proxied stream.
public boolean nodechange ( catalogtreenode node , string name ) { catalogtreenode cnode = getcorrespondingnode ( node ) ; cnode . setleaves ( node . getleaves ( ) ) ; abstractcatalogtree tree = ( abstractcatalogtree ) getcorespondingmodel ( node ) ; cnode . setuserobject ( name ) ; node . setuserobject ( name ) ; tree . nodechanged ( cnode ) ; _model . nodechanged ( node ) ; updatepanel ( ) ; imageindexeditor . indexchanged ( _bool ) ; updatepanel ( ) ; return _bool ; }	make a change to a node in the displayed tree . either its name or the contents of its leaves ( image references ).
public static enumeration all ( ) { return _all . elements ( ) ; }	access to all productions .
public boolean waituntilempty ( long timeout ) throws interruptedexception { if ( ! notifylock . trylock ( timeout , timeunit . milliseconds ) ) { return _bool ; } try { return pending . isempty ( ) || notifycondition . await ( timeout , timeunit . milliseconds ) ; } finally { notifylock . unlock ( ) ; } }	wait until the client ' s pending queue is empty . may not work if there are people concurrently adding to the queue.
public static set < javaclassandmethod > resolvemethodcalltargets ( referencetype receivertype , invokeinstruction invokeinstruction , constantpoolgen cpg ) throws classnotfoundexception { return resolvemethodcalltargets ( receivertype , invokeinstruction , cpg , _bool ) ; }	resolve possible instance method call targets.
private string safe ( string src ) { stringbuffer sb = new stringbuffer ( ) ; for ( int i = _num ; i < src . length ( ) ; i ++ ) { char c = src . charat ( i ) ; if ( c >= _num && c < _num ) { sb . append ( c ) ; } else { sb . append ( _str + ( int ) c + _str ) ; } } return sb . tostring ( ) ; }	convert a string to one in which any non - printable bytes are replaced by " < # # # > " where # # is the value of the byte .
public algorithm ( element el ) { requiredkey = el . getattribute ( _str ) ; jcename = el . getattribute ( _str ) ; algorithmclass = el . getattribute ( _str ) ; if ( el . hasattribute ( _str ) ) { keylength = integer . parseint ( el . getattribute ( _str ) ) ; } else { keylength = _num ; } }	gets data from element.
protected abstract boolean issslsocket ( ) ;	return if the socket is using ssl / tls.
private run consumerun ( int offset ) { char ch = ftext . charat ( offset ) ; int length = ftext . length ( ) ; run run = getrun ( ch ) ; while ( run . consume ( ch ) && offset < length - _num ) { offset ++ ; ch = ftext . charat ( offset ) ; } return run ; }	consumes a run of characters at the limits of which we introduce a break .
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addall ( collections . list ( super . listoptions ( ) ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public static string formatforui ( calendar today , calendar date ) { if ( today . get ( calendar . year ) == date . get ( calendar . year ) ) { if ( today . get ( calendar . day_of_year ) == date . get ( calendar . day_of_year ) ) { return _str ; } return currentyeardateformat ( date . gettimeinmillis ( ) ) ; } else { return format ( date . gettimeinmillis ( ) ) ; } }	formats the date in ui - friendly way.
public outputstreamwriter ( outputstream out , charsetencoder enc ) { super ( out ) ; if ( enc == null ) throw new nullpointerexception ( _str ) ; se = streamencoder . foroutputstreamwriter ( out , this , enc ) ; }	creates an outputstreamwriter that uses the given charset encoder .
public synchronized void free ( long pos , int length ) { int start = getblock ( pos ) ; int blocks = getblockcount ( length ) ; blockrange x = new blockrange ( start , blocks ) ; blockrange next = freespace . ceiling ( x ) ; if ( next == null ) { throw datautils . newillegalstateexception ( datautils . error_internal , _str ) ; } blockrange prev = freespace . lower ( x ) ; if ( prev != null ) { if ( prev . start + prev . blocks == start ) { prev . blocks += blocks ; if ( prev . start + prev . blocks == next . start ) { prev . blocks += next . blocks ; freespace . remove ( next ) ; } return ; } } if ( start + blocks == next . start ) { next . start -= blocks ; next . blocks += blocks ; return ; } freespace . add ( x ) ; }	mark the space as free .
public uri csrftoken ( ) { uribuilder builder = apibuilder ( ) ; builder . setparameter ( _str , _str ) ; builder . setparameter ( _str , _str ) ; builder . setparameter ( _str , _str ) ; return build ( builder ) ; }	uri to fetch a csrf token .
public distributedlogmultistreamwriter build ( ) { preconditions . checkargument ( ( null != _streams && ! _streams . isempty ( ) ) , _str ) ; preconditions . checknotnull ( _client , _str ) ; preconditions . checknotnull ( _codec , _str ) ; preconditions . checkargument ( _firstspeculativetimeoutms > _num && _firstspeculativetimeoutms <= _maxspeculativetimeoutms && _speculativebackoffmultiplier > _num && _maxspeculativetimeoutms < _requesttimeoutms , _str ) ; return new distributedlogmultistreamwriter ( _streams , _client , math . min ( _buffersize , max_logrecordset_size ) , _flushintervalms , _requesttimeoutms , _firstspeculativetimeoutms , _maxspeculativetimeoutms , _speculativebackoffmultiplier , _codec , _ticker , _executorservice ) ; }	build the multi stream writer .
private void writechars ( int number , char c ) throws ioexception { for ( ; number > _num ; number -- ) { writer . write ( c ) ; } }	writes an amount of chars , mostly spaces.
@ override public void error ( string msg , throwable t ) { if ( logger . isloggable ( level . severe ) ) { log ( self , level . severe , msg , t ) ; } }	log an exception ( throwable ) at the severe level with an accompanying message .
public int exit_signal ( ) { return integer . parseint ( fields [ _num ] ) ; }	( since linux 2.
public command ( ) { msgqueue = new linkedlist < message > ( ) ; msgqueue . clear ( ) ; }	instantiates a new command .
public synchronized int indexof ( v item ) { return items . indexof ( item ) ; }	looks for the particular item in the list and returns the index within the list ( starting from zero ) of that item if it is found , or - 1 otherwise.
protected void createnode ( defaultmutabletreenode top , string title , string info , string content , int linecount ) { defaultmutabletreenode threadinfo = null ; threadinfo = new defaultmutabletreenode ( new threadinfo ( title , info , content , linecount , getthreadtokens ( title ) ) ) ; top . add ( threadinfo ) ; }	create a tree node with the provided information.
public peer clone ( ) { peer clone = new peer ( network . clone ( ) , address ) ; return clone ; }	create a deep copy of the peer which references the same remote peer but whose peernetwork is a distinct object .
public static string generatenativeguid ( string devicetype , string serialnumber , string filesharenativeid ) { return string . format ( _str + filesystem + _str , _devicetypemap . get ( devicetype ) , serialnumber , filesharenativeid ) ; }	generates the format storagesystem + serialnumber + filesystem + nativeid native guid for fileshare objects.
public strbuilder ensurecapacity ( final int capacity ) { if ( capacity > buffer . length ) { final char [ ] old = buffer ; buffer = new char [ capacity * _num ] ; system . arraycopy ( old , _num , buffer , _num , size ) ; } return this ; }	checks the capacity and ensures that it is at least the size specified .
private void onstarttrackingtouch ( ) { misdragging = _bool ; }	this is called when the user has started touching this widget .
private static void createsuperforwarder ( classnode targetnode , methodnode forwarder , final map < string , classnode > genericsspec ) { list < classnode > interfaces = new arraylist < classnode > ( traits . collectallinterfacesreverseorder ( targetnode , new linkedhashset < classnode > ( ) ) ) ; string name = forwarder . getname ( ) ; parameter [ ] forwarderparameters = forwarder . getparameters ( ) ; linkedhashset < classnode > traits = new linkedhashset < classnode > ( ) ; list < methodnode > superforwarders = new linkedlist < methodnode > ( ) ; for ( classnode node : interfaces ) { if ( traits . istrait ( node ) ) { methodnode method = node . getdeclaredmethod ( name , forwarderparameters ) ; if ( method != null ) { traits . add ( node ) ; superforwarders . add ( method ) ; } } } for ( methodnode superforwarder : superforwarders ) { docreatesuperforwarder ( targetnode , superforwarder , traits . toarray ( new classnode [ traits . size ( ) ] ) , genericsspec ) ; } }	creates , if necessary , a super forwarder method , for stackable traits .
public void testcase15 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num } ; byte rbytes [ ] = { _num } ; int asign = - _num ; int bsign = _num ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . add ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	add two equal numbers of different signs.
public boolean isvirtualpoolaccessible ( virtualpool resource ) { return _permissionshelper . tenanthasusageacl ( uri . create ( _user . gettenantid ( ) ) , resource ) ; }	verify whether the user in the filter has access to the vpool based on resource acl.
public void testtimedinvokeallnulltimeunit ( ) throws throwable { executorservice e = new forkjoinpool ( _num ) ; poolcleaner cleaner = null ; try { cleaner = cleaner ( e ) ; list < callable < string > > l = new arraylist < callable < string > > ( ) ; l . add ( new stringtask ( ) ) ; try { e . invokeall ( l , medium_delay_ms , null ) ; shouldthrow ( ) ; } catch ( nullpointerexception success ) { } } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }	timed invokeall ( null time unit ) throws nullpointerexception.
private static boolean intersectsoneof ( final rectangle2d r , final collection < ? extends shape > shapes ) { if ( shapes . isempty ( ) ) { return _bool ; } for ( final shape item : shapes ) { if ( item . intersects ( r ) ) { return _bool ; } } return _bool ; }	java . lang . boolean intersectsoneof ( java . awt . geom . rectangle2d , java . tools . collection ) function to test if the given 2d rectangle intersects any of the shapes given in the collection .
private void expectedbyte ( int position , int count ) throws utfdataformatexception { throw new utfdataformatexception ( localizer . getmessage ( _str , integer . tostring ( position ) , integer . tostring ( count ) ) ) ; }	throws an exception for expected byte .
private list < string > checkconfiglist ( configuration config , string name ) { string peerips = config . getconfig ( name ) ; arraylist < string > peers = new arraylist < string > ( ) ; if ( peerips != null ) { for ( string ip : stringutils . split ( peerips , _str ) ) { peers . add ( ip ) ; } } return peers ; }	read a string list ( connected by ' , ' ) from given db config.
private void loadexternal ( ) { properties properties = new properties ( ) ; try { properties . loadfromxml ( new fileinputstream ( properties_path ) ) ; for ( string key : properties . stringpropertynames ( ) ) { externalsupport . put ( key , properties . getproperty ( key ) ) ; } } catch ( ioexception ignore ) { } }	load the properties for external utilities from a xml file.
public static uri parseuri ( string nuri , uri baseuri ) throws urisyntaxexception { int colonlocation = nuri . indexof ( _str ) ; int fragmentlocation = getfragmentlocation ( nuri ) ; if ( colonlocation == - _num || colonlocation > fragmentlocation ) { if ( baseuri == null ) throw new urisyntaxexception ( _str + nuri + _str + _str , nuri ) ; } string protocol = nuri . substring ( _num , colonlocation ) ; if ( protocol . equals ( _str ) ) { return parseurn ( nuri , colonlocation , fragmentlocation ) ; } else if ( protocol . equals ( _str ) ) { return new uri ( nuri ) ; } else if ( protocol . equals ( _str ) ) { return new uri ( nuri ) ; } else if ( protocol . equals ( _str ) ) { return new uri ( nuri ) ; } else { return parsegeneraluri ( nuri , colonlocation , fragmentlocation ) ; } }	constructs an uri from a string.
protected void updateus ( ) { try { settext ( m_editor . getastext ( ) ) ; } catch ( illegalargumentexception ex ) { } }	attempts to update the textfield value from the editor .
public file makedirty ( ) throws ioexception { file f = file . createtempfile ( _str , _str , repositorylocation . getparentfile ( ) ) ; filewriter fw = new filewriter ( f ) ; fw . write ( _str + system . currenttimemillis ( ) ) ; fw . flush ( ) ; fw . close ( ) ; return f ; }	creates a new file with dummy content inside the git repository to make it dirty .
public static bigdecimal allocated ( int p_c_payment_id , int p_c_currency_id ) throws sqlexception { bigdecimal payamt = null ; int c_charge_id = _num ; string sql = _str + _str + _str ; preparedstatement pstmt = adempiere . preparestatement ( sql ) ; pstmt . setint ( _num , p_c_payment_id ) ; resultset rs = pstmt . executequery ( ) ; if ( rs . next ( ) ) { payamt = rs . getbigdecimal ( _num ) ; c_charge_id = rs . getint ( _num ) ; } rs . close ( ) ; pstmt . close ( ) ; if ( c_charge_id > _num ) return payamt ; int c_conversiontype_id = _num ; bigdecimal allocatedamt = getallocatedamt ( p_c_payment_id , p_c_currency_id , c_conversiontype_id ) ; return currency . round ( allocatedamt , p_c_currency_id , null ) ; }	get allocated payment amount . - paymentallocated.
public static bytebuffer processoutboundpackage ( bytebuffer rodata , int exchangeid , boolean connectionok ) { rodata . rewind ( ) ; if ( buildconfig . debug ) { xposedbridge . log ( _str + integer . tostring ( rodata . remaining ( ) ) ) ; } try { synchronized ( sync ) { } } catch ( throwable e ) { xposedbridge . log ( e ) ; } return null ; }	processes single package going from client to server rodata is created by allocate and had to have array.
public void initialize ( ) { if ( isclosed . get ( ) ) { logger . info ( _str ) ; actorconfig . createandgetactorsystem ( ) ; httpclientstore . init ( ) ; tcpsshpingresourcestore . init ( ) ; paralleltaskmanager . getinstance ( ) ; isclosed . set ( _bool ) ; logger . info ( _str ) ; } else { logger . debug ( _str ) ; } }	initialize . create the httpclientstore , tcpclientstore.
@ notnull private static textrange processspaces ( @ notnull helper helper , @ notnull textrange range , int tabwidth ) { charsequence indent = helper . getcurrentlineindent ( ) ; int start = math . max ( _num , range . getstartoffset ( ) - helper . getcurrentlinestartoffset ( ) ) ; int end = math . min ( indent . length ( ) , range . getendoffset ( ) - helper . getcurrentlinestartoffset ( ) ) ; int tabsnumber = _num ; int indentoffset = end ; for ( int i = start ; i < end ; i ++ ) { char c = indent . charat ( i ) ; if ( c == _str ) { tabsnumber ++ ; } else if ( c != _str ) { indentoffset = i ; break ; } } if ( tabsnumber > _num ) { helper . replace ( start , indentoffset , stringutil . repeat ( _str , indentoffset - start - tabsnumber + tabsnumber * tabwidth ) ) ; return textrange . create ( range . getstartoffset ( ) , range . getendoffset ( ) - tabsnumber + tabsnumber * tabwidth ) ; } else { return range ; } }	converts tabulations to white spaces at the target line ' s indent space .
public void removealarm ( final alarm alarm ) { if ( alarms . contains ( alarm ) ) alarms . remove ( alarm ) ; }	removes the given alarm object from the list of alarms .
public int read ( ) throws java . io . ioexception { synchronized ( lock ) { char chararray [ ] = new char [ _num ] ; if ( read ( chararray , _num , _num ) != - _num ) { return chararray [ _num ] ; } return - _num ; } }	read a single character.
protected void checkparameters ( ) { if ( parameters != null ) { for ( int i = _num , size = parameters . size ( ) ; i < size ; i ++ ) { parameter param = parameters . get ( i ) ; param . checkset ( ) ; } } }	check if all parameters have been set .
private static properties createproperties1 ( string conflation ) { properties props = new properties ( ) ; props . setproperty ( delta_propagation , _str ) ; props . setproperty ( mcast_port , _str ) ; props . setproperty ( locators , _str ) ; props . setproperty ( conflate_events , conflation ) ; return props ; }	create properties for a loner vm.
public static void cf3 ( double [ ] x , double [ ] f , double [ ] c , int nx ) { int count1 = _num ; int count2 = _num ; double sum1 = _num ; double sum2 = _num ; double prod1 = _num ; double prod2 = _num ; double yj ; double pj ; double n = _num ; double a = _num ; for ( int j = _num ; j <= nx ; j ++ ) { yj = x [ j - _num ] - math . sin ( _num * pi * x [ _num ] + j * pi / nx ) ; pj = math . cos ( _num * yj * pi / math . sqrt ( j + _num ) ) ; if ( j % _num == _num ) { sum2 += yj * yj ; prod2 *= pj ; count2 ++ ; } else { sum1 += yj * yj ; prod1 *= pj ; count1 ++ ; } } f [ _num ] = x [ _num ] + _num * ( _num * sum1 - _num * prod1 + _num ) / ( double ) count1 ; f [ _num ] = _num - x [ _num ] * x [ _num ] + _num * ( _num * sum2 - _num * prod2 + _num ) / ( double ) count2 ; c [ _num ] = f [ _num ] + f [ _num ] * f [ _num ] - a * math . sin ( n * pi * ( f [ _num ] * f [ _num ] - f [ _num ] + _num ) ) - _num ; }	evaluates the cf3 problem .
public static void closesilently ( resultset rs ) { if ( rs != null ) { try { rs . close ( ) ; } catch ( sqlexception e ) { } } }	close a result set without throwing an exception .
public static void execute ( poolimpl pool , function function , object args , membermappedargument membermappedarg , boolean allservers , byte hasresult , boolean isfnserializationreqd , string [ ] groups ) { list servers = null ; abstractop op = new executefunctionnoackopimpl ( function , args , membermappedarg , hasresult , isfnserializationreqd , groups , allservers ) ; try { if ( allservers && groups . length == _num ) { if ( logger . isdebugenabled ( ) ) { logger . debug ( _str + op . getmessage ( ) + _str + pool ) ; } servers = pool . getcurrentservers ( ) ; iterator i = servers . iterator ( ) ; while ( i . hasnext ( ) ) { pool . executeon ( ( serverlocation ) i . next ( ) , op ) ; } } else { if ( logger . isdebugenabled ( ) ) { logger . debug ( _str + op . getmessage ( ) + _str + pool + _str + arrays . tostring ( groups ) + _str + allservers ) ; } pool . execute ( op , _num ) ; } } catch ( exception ex ) { if ( logger . isdebugenabled ( ) ) { logger . debug ( _str + op . getmessage ( ) + _str + pool , ex ) ; } if ( ex . getmessage ( ) != null ) throw new functionexception ( ex . getmessage ( ) , ex ) ; else throw new functionexception ( _str , ex ) ; } }	does a execute function on a server using connections from the given pool to communicate with the server .
public static script createmultisiginputscript ( transactionsignature ... signatures ) { return createmultisiginputscript ( arrays . aslist ( signatures ) ) ; }	create a program that satisfies an op_checkmultisig program .
object proxyifreturntypeisjdbcinterface ( class < ? > returntype , object toproxy ) { if ( toproxy != null ) { if ( util . isjdbcinterface ( returntype ) ) { class < ? > toproxyclass = toproxy . getclass ( ) ; return proxy . newproxyinstance ( toproxyclass . getclassloader ( ) , util . getimplementedinterfaces ( toproxyclass ) , getnewjdbcinterfaceproxy ( toproxy ) ) ; } } return toproxy ; }	if the given return type is or implements a jdbc interface , proxies the given object so that we can catch sql errors and fire a connection switch .
public final void empty ( ) { synchronized ( buffer ) { buffer . clear ( ) ; buffermap . clear ( ) ; } }	empties the synchrobuffer of all it ' s current content .
public void testmoderatelycomplextemplating ( ) throws exception { htmlpage page = getpage ( _str ) ; string text = page . astext ( ) ; asserttrue ( text . contains ( _str ) ) ; }	added for issue 1552 .
private valuerange rangebyweek ( temporalaccessor temporal , temporalfield field ) { int dow = localizeddayofweek ( temporal ) ; int offset = startofweekoffset ( temporal . get ( field ) , dow ) ; valuerange fieldrange = temporal . range ( field ) ; return valuerange . of ( computeweek ( offset , ( int ) fieldrange . getminimum ( ) ) , computeweek ( offset , ( int ) fieldrange . getmaximum ( ) ) ) ; }	map the field range to a week range.
public object apply ( object in ) { if ( in instanceof hasword ) { hasword w = ( hasword ) in ; string str = w . word ( ) ; string outstr = americanize ( str , capitalizetimex ) ; if ( ! outstr . equals ( str ) ) { w . setword ( outstr ) ; } return w ; } else { string str = ( string ) in ; return americanize ( str , capitalizetimex ) ; } }	americanize the hasword or string coming in .
public void addwayref ( mapway way , int nodeidx ) { if ( ways == null ) ways = new arraylist < wayref > ( _num ) ; if ( ways . isempty ( ) || ways . get ( _num ) != way ) ways . add ( new defaultwayref ( way , ( short ) nodeidx ) ) ; }	adds the information to the node that it is part of the specified way .
public double docrossvalidation ( iterable < t > data , int datasize ) throws interruptedexception , executionexception { stats = new onevariablestats ( ) ; log . info ( _str + ( new date ( ) ) ) ; log . info ( _str + numfolds + _str ) ; list < list < t > > splits = splitdata ( data , datasize ) ; log . info ( _str ) ; executorservice executor = executors . newfixedthreadpool ( numthreads ) ; list < futuretask < double > > folds = new arraylist < > ( ) ; for ( int i = _num ; i < numfolds ; i ++ ) { list < t > trainingset = new arraylist < > ( ) ; for ( int j = _num ; j < numfolds ; j ++ ) { if ( j != i ) trainingset . addall ( splits . get ( j ) ) ; } list < t > testset = splits . get ( i ) ; futuretask < double > fold = createfoldtask ( trainingset , testset , i ) ; executor . execute ( fold ) ; folds . add ( fold ) ; } executor . shutdown ( ) ; executor . awaittermination ( timeoutseconds , timeunit . seconds ) ; for ( futuretask < double > fold : folds ) { stats . add ( fold . get ( ) ) ; } log . info ( _str + ( new date ( ) ) ) ; return stats . mean ( ) ; }	note : this does not take care of shuffling or randomizing the data .
public entiretextbuilder addbackground ( @ colorint int bgcolor , int start , int end ) { backgroundholder backgroundholder = new backgroundholder ( bgcolor , start , end ) ; mbackgrounds . add ( backgroundholder ) ; return this ; }	add background to text .
public boolean matches ( string filename ) { if ( exts == null ) return _bool ; int j = filename . lastindexof ( _str ) ; if ( j == - _num || j == filename . length ( ) ) return _bool ; string suffix = filename . substring ( j + _num ) ; return exts . contains ( suffix ) ; }	returns true if a file with the given name is of this media type , i.
public rectangle [ ] computegaps ( ) { arraylist < rectangle > ret = new arraylist < > ( ) ; rectangle gap = new rectangle ( ) ; for ( int i = _num ; i < mrectlist . length ; i ++ ) { rectangle rectanglea = mrectlist [ i ] ; for ( int j = i + _num ; j < mrectlist . length ; j ++ ) { rectangle rectangleb = mrectlist [ j ] ; boolean viable = calculategap ( rectanglea , rectangleb , gap ) ; if ( viable ) { for ( int k = _num ; k < mrectlist . length ; k ++ ) { if ( k != j && k != i ) { if ( gap . intersects ( mrectlist [ k ] ) ) { viable = _bool ; break ; } } } } if ( viable ) { ret . add ( new rectangle ( gap ) ) ; } } } return ret . toarray ( new rectangle [ ret . size ( ) ] ) ; }	build a array of rectangles representing the gaps used for debugging purposes.
public synchronized methodcountset collecthotmethods ( int optlevel , double threshold ) { if ( debug ) validitycheck ( ) ; arraylist < hotmethodrecompilationevent > collect = new arraylist < hotmethodrecompilationevent > ( ) ; collecthotoptmethodsinternal ( _num , collect , hotnesstocounts ( threshold ) , optlevel ) ; int numhotmethods = collect . size ( ) ; double [ ] numcounts = new double [ numhotmethods ] ; compiledmethod [ ] hotmethods = new compiledmethod [ numhotmethods ] ; for ( int i = _num ; i < numhotmethods ; i ++ ) { hotmethodevent event = collect . get ( i ) ; hotmethods [ i ] = event . getcompiledmethod ( ) ; numcounts [ i ] = event . getnumsamples ( ) ; } return new methodcountset ( hotmethods , numcounts ) ; }	collect the hot methods that have been compiled at the given opt level .
public synchronized void addban ( long duration , string reason , string id ) { addline ( new banmessage ( system . currenttimemillis ( ) , duration , reason , id ) ) ; }	adds a single ban with the current time .
private void writeheader ( ) throws openstegoexception { dctdataheader header = null ; try { header = new dctdataheader ( this . datalength , this . filename , this . config ) ; if ( ( ( header . getheadersize ( ) + this . datalength ) * _num ) > ( this . imgwidth * this . imgheight / ( dct . njpeg * dct . njpeg ) ) ) { throw new openstegoexception ( null , dctlsbplugin . namespace , dctlsberrors . image_size_insufficient ) ; } this . coord = new coordinates ( ( header . getheadersize ( ) + this . datalength ) * _num ) ; write ( header . getheaderdata ( ) ) ; } catch ( ioexception ioex ) { throw new openstegoexception ( ioex ) ; } }	method to write header data to stream.
public int decrementsubscribercount ( ) { if ( isavailable ( ) ) { return jmdnssubscribercount . decrementandget ( ) ; } return _num ; }	decrements the count of jmdns subscribers .
public static boolean addshapelessenchantingrecipe ( itemstack aresult , enchantment [ ] aenchantmentsadded , int [ ] aenchantmentlevelsadded , object [ ] arecipe ) { return addshapelesscraftingrecipe ( aresult , aenchantmentsadded , aenchantmentlevelsadded , _bool , _bool , _bool , _bool , arecipe ) ; }	shapeless crafting recipes . deletes conflicting recipes too .
public void start ( ) throws tomcatexception { if ( cat == null ) init ( ) ; cat . start ( ) ; }	this method starts the tomcat server .
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options.
private boolean imageoutline ( defaultmutabletreenode node ) { boolean isoutline = _bool ; if ( node != null ) { defaultmutabletreenode parentnode = ( defaultmutabletreenode ) node . getparent ( ) ; if ( parentnode != null ) { if ( parentnode . getuserobject ( ) instanceof rastersymbolizer ) { isoutline = _bool ; } } } return isoutline ; }	check to see if symbolizer is an image outline .
private short addentry ( entry entry ) { pool . add ( entry ) ; if ( pool . size ( ) >= _num ) { throw new illegalargumentexception ( _str ) ; } return ( short ) pool . size ( ) ; }	add a new constant pool entry and return its index .
private boolean loadnextpage ( ) { result = pageable . getpage ( query , skip , pagesize ) ; index = _num ; if ( result == null || result . isempty ( ) ) { return _bool ; } return _bool ; }	retrieves results of next page of the query , and checks if a element is present in this new page .
public void close ( ) throws ioexception { if ( ! closed ) { if ( usesdefaultinflater ) inf . end ( ) ; in . close ( ) ; closed = _bool ; } }	closes this input stream and releases any system resources associated with the stream .
public fieldanalysisrequest addfieldtype ( string fieldtypename ) { if ( fieldtypes == null ) { fieldtypes = new linkedlist < > ( ) ; } fieldtypes . add ( fieldtypename ) ; return this ; }	adds the given field type for analysis .
public static bigfraction parseeditrate ( string editrate ) { editrate = editrate . contains ( _str ) ? rframeratetoeditrate ( editrate ) : editrate ; string [ ] parts = editrate . split ( _str ) ; try { if ( parts . length == _num ) { return new bigfraction ( long . parselong ( parts [ _num ] ) , long . parselong ( parts [ _num ] ) ) ; } else if ( parts . length == _num ) { return new bigfraction ( long . parselong ( parts [ _num ] ) ) ; } } catch ( numberformatexception e ) { throw new conversionhelperexception ( _str , e ) ; } throw new conversionhelperexception ( _str ) ; }	returns a fraction corresponding to the given edit rate string .
public fst < t > finish ( ) throws ioexception { final uncompilednode < t > root = frontier [ _num ] ; freezetail ( _num ) ; if ( root . inputcount < minsuffixcount1 || root . inputcount < minsuffixcount2 || root . numarcs == _num ) { if ( fst . emptyoutput == null ) { return null ; } else if ( minsuffixcount1 > _num || minsuffixcount2 > _num ) { return null ; } } else { if ( minsuffixcount2 != _num ) { compilealltargets ( root , lastinput . length ( ) ) ; } } fst . finish ( compilenode ( root , lastinput . length ( ) ) . node ) ; if ( dopackfst ) { return fst . pack ( this , _num , math . max ( _num , ( int ) ( getnodecount ( ) / _num ) ) , acceptableoverheadratio ) ; } else { return fst ; } }	returns final fst . note : this will return null if nothing is accepted by the fst .
public void onconfiguration ( contactsops . view view , boolean firsttimein ) { mcontactsview = new weakreference < > ( view ) ; if ( firsttimein ) { initializeaccount ( ) ; mcursoradapter = new simplecursoradapter ( view . getapplicationcontext ( ) , r . layout . list_layout , null , scolumnstodisplay , scolumnresids , _num ) ; } }	hook method dispatched by the genericactivity framework to initialize the contactsopsimpl object after it ' s been created .
public static final int randomunsetbit ( random r , bitset bits , final int max ) { if ( bits . cardinality ( ) == max + _num ) { return - _num ; } final int candidate = testutil . nextint ( r , _num , max ) ; if ( bits . get ( candidate ) ) { final int lo = bits . previousclearbit ( candidate ) ; final int hi = bits . nextclearbit ( candidate ) ; if ( lo < _num && max < hi ) { fail ( _str + bits . cardinality ( ) + _str + bits . size ( ) ) ; } else if ( lo < _num ) { return hi ; } else if ( max < hi ) { return lo ; } return ( ( candidate - lo ) < ( hi - candidate ) ) ? lo : hi ; } return candidate ; }	given a bitset , returns a random bit that is currently false , or - 1 if all bits are true.
@ override public void flush ( ) throws ioexception { synchronized ( lock ) { out . flush ( ) ; } }	flushes this writer to ensure all pending data is sent out to the target writer.
public double std ( ) { if ( min == max || num == _num ) { return _num ; } double m = mean ( ) ; return math . sqrt ( sigmax2 / num - m * m ) ; }	calculate the population standard deviation . $ \ sqrt ( \ frac { \ sum ( x - m ) ^ 2 } { n } ) $.
public boolean containsinstruction ( instructionhandle handle ) { iterator < instructionhandle > i = instructioniterator ( ) ; while ( i . hasnext ( ) ) { if ( i . next ( ) == handle ) { return _bool ; } } return _bool ; }	return whether or not the basic block contains the given instruction .
public string trimtosize ( string str , int maxstringlength ) { if ( str == null ) return null ; if ( str . length ( ) > maxstringlength ) { stringbuilder sb = new stringbuilder ( str ) ; sb . setlength ( maxstringlength ) ; str = sb . tostring ( ) ; } return str ; }	trim a given string to maxstringlength if it is over maxstringlength .
public subject login ( string username , string password ) { if ( stringutils . isblank ( username ) || stringutils . isblank ( password ) ) return null ; properties credentials = new properties ( ) ; credentials . setproperty ( resourceconstants . user_name , username ) ; credentials . setproperty ( resourceconstants . password , password ) ; return login ( credentials ) ; }	convenient method for testing.
@ timed @ exceptionmetered @ path ( _str ) @ get @ produces ( application_json ) public iterable < sanitizedsecret > secretlistingv2 ( @ auth automationclient automationclient , @ queryparam ( _str ) integer idx , @ queryparam ( _str ) integer num , @ defaultvalue ( _str ) @ queryparam ( _str ) boolean newestfirst ) { if ( idx != null && num != null ) { if ( idx < _num || num < _num ) { throw new badrequestexception ( _str ) ; } return secretcontroller . getsecretsbatched ( idx , num , newestfirst ) ; } return secretcontroller . getsanitizedsecrets ( null , null ) ; }	retrieve listing of secrets . if " idx " and " num " are both provided , retrieve " num " names starting at " idx " from a list of secrets ordered by creation date , with order depending on " newestfirst " ( which defaults to " true " ).
public void deselect ( iterable < integer > positions ) { iterator < integer > entries = positions . iterator ( ) ; while ( entries . hasnext ( ) ) { deselect ( entries . next ( ) , entries ) ; } }	deselects all items at the positions in the iteratable.
public static string map2oid ( string algname ) { checkcacheversion ( ) ; string result = alg2oidmap . get ( algname . touppercase ( locale . us ) ) ; if ( result != null ) { return result ; } algnamemappersource s = source ; if ( s != null ) { return s . mapnametooid ( algname ) ; } return null ; }	returns oid for algname.
private void endlist ( boolean orderedlist ) { if ( ! mparagraphstyles . isempty ( ) ) { accumulatedparagraphstyle style = mparagraphstyles . peek ( ) ; paragraphtype type = style . gettype ( ) ; if ( ( orderedlist && ( type . isnumbering ( ) || type == paragraphtype . indentation_ol ) ) || ( ! orderedlist && ( type . isbullet ( ) || type == paragraphtype . indentation_ul ) ) ) { int indent = style . getrelativeindent ( ) ; if ( indent > _num ) { style . setrelativeindent ( indent - _num ) ; style . setabsoluteindent ( style . getabsoluteindent ( ) - _num ) ; } else { mparagraphstyles . pop ( ) ; } } else { mparagraphstyles . pop ( ) ; endlist ( orderedlist ) ; } } }	handles ol and ul end tags.
public boolean isnaturaljoincolumn ( column c ) { return naturaljoincolumns != null && naturaljoincolumns . contains ( c ) ; }	check if the given column is a natural join column .
public int read ( byte [ ] b , int off , int len ) throws ioexception { ensureopen ( ) ; if ( b == null ) { throw new nullpointerexception ( _str ) ; } else if ( off < _num || len < _num || len > b . length - off ) { throw new indexoutofboundsexception ( ) ; } else if ( len == _num ) { return _num ; } int cnt = _num ; while ( len > _num && ! def . finished ( ) ) { int n ; if ( def . needsinput ( ) ) { n = in . read ( buf , _num , buf . length ) ; if ( n < _num ) { def . finish ( ) ; } else if ( n > _num ) { def . setinput ( buf , _num , n ) ; } } n = def . deflate ( b , off , len ) ; cnt += n ; off += n ; len -= n ; } if ( cnt == _num && def . finished ( ) ) { reacheof = _bool ; cnt = - _num ; } return cnt ; }	reads compressed data into a byte array.
@ override public void passivate ( ) { cleanupusertransaction ( ) ; super . passivate ( ) ; }	override passivate ( ) to ensure we always cleanup the usertransaction .
public builder delay ( long duration , timeunit timeunit ) { this . delay = timeunit . toseconds ( duration ) ; return this ; }	set the time that should elapse before the job is queued by any server .
private boolean contains ( int part ) { return parts . contains ( part ) ; }	checks if partition set contains given partition .
int keycount ( class clazz ) { map map = get ( clazz ) ; int count = map . size ( ) ; if ( map . containskey ( constructors_key ) ) count -- ; if ( map . containskey ( generic_get_key ) ) count -- ; if ( map . containskey ( argtypes_key ) ) count -- ; return count ; }	returns the number of introspected methods / properties that should be available via the templatehashmodel interface .
public mp4stcobox ( mp4boxheader header , bytebuffer originaldatabuffer , int adjustment ) { this . header = header ; this . databuffer = originaldatabuffer . slice ( ) ; databuffer . position ( databuffer . position ( ) + version_flag_length + other_flag_length ) ; this . noofoffsets = utils . getintbe ( databuffer , databuffer . position ( ) , ( databuffer . position ( ) + no_of_offsets_length - _num ) ) ; databuffer . position ( databuffer . position ( ) + no_of_offsets_length ) ; for ( int i = _num ; i < noofoffsets ; i ++ ) { int offset = utils . getintbe ( databuffer , databuffer . position ( ) , ( databuffer . position ( ) + no_of_offsets_length - _num ) ) ; offset = offset + adjustment ; databuffer . put ( utils . getsizebeint32 ( offset ) ) ; } }	construct box from data and adjust offets accordingly.
public static void createopusdirectories ( config config ) { log . info ( _str ) ; urbansimparameterconfigmodulev3 module = m4uconfigutils . geturbansimparameterconfigandpossiblyconvert ( config ) ; file tempfile = new file ( module . getopushome ( ) ) ; tempfile . mkdirs ( ) ; tempfile = new file ( module . getmatsim4opus ( ) ) ; tempfile . mkdirs ( ) ; tempfile = new file ( module . getmatsim4opusoutput ( ) ) ; tempfile . mkdirs ( ) ; tempfile = new file ( module . getmatsim4opustemp ( ) ) ; tempfile . mkdirs ( ) ; tempfile = new file ( module . getmatsim4opusconfig ( ) ) ; tempfile . mkdirs ( ) ; log . info ( _str ) ; }	create new temp directories.
public static string lcfirst ( string input ) { return withfirst ( input , null ) ; }	returns the specified text but with the first character lowercase .
void compress ( int page , byte [ ] old ) { byte [ ] [ ] array = data ; if ( page >= array . length ) { return ; } byte [ ] d = array [ page ] ; if ( d != old ) { return ; } synchronized ( lzf ) { int len = lzf . compress ( d , block_size , buffer , _num ) ; if ( len <= block_size ) { d = new byte [ len ] ; system . arraycopy ( buffer , _num , d , _num , len ) ; byte [ ] o = array [ page ] ; if ( o != old ) { return ; } array [ page ] = d ; } } }	compress the data in a byte array .
public hadoopprocessdescriptor localprocessdescriptor ( ) { return locprocdesc ; }	gets local process descriptor .
private pair < string , boolean > describerain ( calendar calendar , int temperaturemod ) { int month = calendar . get ( calendar . month ) ; month = _num * math . abs ( month - _num ) ; int hour = calendar . get ( calendar . hour_of_day ) ; hour = math . abs ( ( hour + _num ) % _num - _num ) / _num ; int temp = temperature . getvalue ( ) - hour - month + ( temperaturemod * _num ) ; logger . debug ( _str + temp + _str + temperaturemod ) ; if ( temp <= - _num ) { return new pair < string , boolean > ( _str , boolean . false ) ; } return new pair < string , boolean > ( _str , temp >= - _num && thunder . getdescription ( _num ) != null ) ; }	describe either rain or snow , depending on the time , temperature and temperature modifiers .
@ visiblefortesting @ calledbynativeunchecked ( _str ) public void addchild ( bookmarknode child ) { mchildren . add ( child ) ; }	adds a child to this node.
public void testgetmincrl ( ) { x509crlselector selector = new x509crlselector ( ) ; assertnull ( _str , selector . getmincrl ( ) ) ; biginteger mincrl = new biginteger ( _str ) ; selector . setmincrlnumber ( mincrl ) ; asserttrue ( _str , mincrl . equals ( selector . getmincrl ( ) ) ) ; }	getmincrl ( ) method testing.
public void testwhencomplete_exceptionalcompletion ( ) { for ( executionmode m : executionmode . values ( ) ) for ( boolean createincomplete : new boolean [ ] { _bool , _bool } ) { final atomicinteger a = new atomicinteger ( _num ) ; final cfexception ex = new cfexception ( ) ; final completablefuture < integer > f = new completablefuture < > ( ) ; if ( ! createincomplete ) f . completeexceptionally ( ex ) ; final completablefuture < integer > g = m . whencomplete ( f , null ) ; if ( createincomplete ) f . completeexceptionally ( ex ) ; checkcompletedwithwrappedexception ( g , ex ) ; checkcompletedexceptionally ( f , ex ) ; assertequals ( _num , a . get ( ) ) ; } }	whencomplete action executes on exceptional completion , propagating source result .
@ override public string read ( string pattern ) { return read ( pattern . compile ( pattern , pattern . dotall | pattern . multiline ) ) ; }	will attempt to read the string matching the given parameter.
private string constructiscsinamesquery ( string systemid , list < hoststoragedomain > hsdlist , string model ) { map < string , object > attributemap = new hashmap < string , object > ( ) ; storagearray array = new storagearray ( systemid ) ; add addop = new add ( hdsconstants . iscsi_name_for_hsd_target ) ; attributemap . put ( hdsconstants . storagearray , array ) ; attributemap . put ( hdsconstants . add , addop ) ; attributemap . put ( hdsconstants . model , model ) ; attributemap . put ( hdsconstants . hostgroup_list , hsdlist ) ; string addwwnquery = inputxmlgenerationclient . getinputxmlstring ( hdsconstants . batch_add_wwn_to_hsd_op , attributemap , hdsconstants . hitachi_input_xml_context_file , hdsconstants . hitachi_smooks_config_file ) ; return addwwnquery ; }	constructs a batch query for given hsd ' s and each with a set of worldwidename ' s to add.
public static void tryclaim ( publication publication , bufferfiller fillbuffer , int length , int timeout , timeunit timeunit ) { if ( publication . isclosed ( ) ) { throw new notconnectedexception ( ) ; } final bufferclaim bufferclaim = bufferclaims . get ( ) ; final long start = system . nanotime ( ) ; do { final long current = system . nanotime ( ) ; if ( ( current - start ) > timeunit . tonanos ( timeout ) ) { throw new timedoutexception ( ) ; } final long offer = publication . tryclaim ( length , bufferclaim ) ; if ( offer >= _num ) { try { final mutabledirectbuffer buffer = bufferclaim . buffer ( ) ; final int offset = bufferclaim . offset ( ) ; fillbuffer . fill ( offset , buffer ) ; break ; } finally { bufferclaim . commit ( ) ; } } else if ( publication . not_connected == offer ) { throw new notconnectedexception ( ) ; } } while ( _bool ) ; }	sends a message using tryclaim.
protected boolean tableexists ( table t ) throws sqlexception { string sql = _str + ( t . istemporary ( ) ? _str : ( _str + t . getschema ( ) + _str ) ) + _str + ( t . istemporary ( ) ? ( t . getschema ( ) + _str ) : _str ) + t . getname ( ) + _str ; statement stmt = dbconn . createstatement ( ) ; try { resultset rs = stmt . executequery ( sql ) ; return rs . next ( ) ; } finally { if ( stmt != null ) { try { stmt . close ( ) ; } catch ( sqlexception e ) { } } } }	checks whether the given table exists in the currently connected database.
private void readunlockedthread ( ) { final long thisthreadid = thread . currentthread ( ) . getid ( ) ; final integer entry = threadlockmap . get ( thisthreadid ) ; assert entry != null ; if ( entry . intvalue ( ) == _num ) { threadlockmap . remove ( thisthreadid ) ; } else { threadlockmap . put ( thisthreadid , entry . intvalue ( ) - _num ) ; } }	track the # of read locks by thread iff this is a read / write index view .
boolean issinglewindowstandardoffset ( ) { return windowend . equals ( localdatetime . max ) && timedefinition == timedefinition . wall && fixedsavingamountsecs == null && lastrulelist . isempty ( ) && rulelist . isempty ( ) ; }	checks if the window is empty .
public void add ( character ok ) { add ( ok . charvalue ( ) ) ; }	delegates to the corresponding type - specific method .
private workflow . method deletevolumesmethod ( uri systemuri , list < uri > volumeuris ) { return new workflow . method ( _str , systemuri , volumeuris ) ; }	return a workflow . method for deletevolumes .
public boolean remove ( accessiblestate state ) { if ( states == null ) { return _bool ; } else { return states . removeelement ( state ) ; } }	removes a state from the current state set.
public void testradix10pos ( ) { string value = _str ; int radix = _num ; biginteger anumber = new biginteger ( value , radix ) ; string result = anumber . tostring ( radix ) ; asserttrue ( result . equals ( value ) ) ; }	test positive number of radix 10.
public void outputexamplexml ( printwriter writer , attributerule rule ) { writer . print ( _str + rule . getname ( ) + _str ) ; if ( rule . hasexample ( ) ) { writer . print ( rule . getexample ( ) ) ; } else { outputattributevalue ( writer , rule . getattributeclass ( ) ) ; } writer . print ( _str ) ; }	outputs an example of a rule , using the syntax information .
public static double calculatejuliandate ( gregoriancalendar cal ) { int year = cal . get ( calendar . year ) ; int month = cal . get ( calendar . month ) ; int day = cal . get ( calendar . day_of_month ) ; month ++ ; if ( ( month == _num ) || ( month == _num ) ) { year -= _num ; month += _num ; } int a = year / _num ; int b = ( int ) ( _num - a + ( a / _num ) ) ; int c = ( int ) ( _num * ( float ) year ) ; int d = ( int ) ( _num * ( float ) ( month + _num ) ) ; double juliandate = ( double ) ( b + c + d + day ) + _num ; return juliandate ; }	given a date from a gregorian calendar , give back a julian date.
public boolean isuploadinprogress ( ) { return muploadstarted . get ( ) ; }	as soon as this method return true , upload can be cancel via cancel ( ) .
private int indexof ( int tabid ) { return mtabidlist . indexof ( tabid ) ; }	finds the index of the given tab id .
public ndefmessage ( ndefrecord record , ndefrecord ... records ) { if ( record == null ) throw new nullpointerexception ( _str ) ; for ( ndefrecord r : records ) { if ( r == null ) { throw new nullpointerexception ( _str ) ; } } mrecords = new ndefrecord [ _num + records . length ] ; mrecords [ _num ] = record ; system . arraycopy ( records , _num , mrecords , _num , records . length ) ; }	construct an ndef message from one or more ndef records .
private int findcheckpointposition ( int [ ] cids ) { if ( checkpointperiod < _num ) { return - _num ; } if ( cids . length == _num ) { throw new illegalargumentexception ( ) ; } int firstcid = cids [ _num ] ; if ( ( firstcid + _num ) % checkpointperiod == _num ) { return cidposition ( cids , firstcid ) ; } else { int nextckpindex = ( ( ( firstcid / checkpointperiod ) + _num ) * checkpointperiod ) - _num ; if ( nextckpindex <= cids [ cids . length - _num ] ) { return cidposition ( cids , nextckpindex ) ; } } return - _num ; }	iterates over the commands to find if the replica took a checkpoint.
private boolean readnextline ( ) throws ioexception { if ( headerlines . hasmoreelements ( ) ) { try { pos = _num ; string line = ( headerlines . nextelement ( ) + line_seperator ) ; if ( ! headerlines . hasmoreelements ( ) ) { line += line_seperator ; } currline = line . getbytes ( _str ) ; return _bool ; } catch ( unsupportedencodingexception e ) { throw new ioexception ( _str ) ; } } else { return _bool ; } }	load the next header line if possible.
private boolean pause ( ) { try { u . await ( pauselatch , remap_pause , milliseconds ) ; return _bool ; } catch ( igniteinterruptedcheckedexception e ) { ondone ( e ) ; return _bool ; } }	pause to avoid crazy resending in case of topology changes .
public static inputstream toinputstream ( final charsequence input ) { return ioutils . toinputstream ( input , charset . defaultcharset ( ) ) ; }	convert the specified charsequence to an input stream , encoded as bytes using the default character encoding of the platform .
public void write ( final int c ) throws ioexception { if ( m_writer != null ) m_writer . write ( c ) ; if ( count >= buf_length ) flushbuffer ( ) ; if ( c < _num ) { buf [ count ++ ] = ( byte ) ( c ) ; } else if ( c < _num ) { buf [ count ++ ] = ( byte ) ( _num + ( c > > _num ) ) ; buf [ count ++ ] = ( byte ) ( _num + ( c & _num ) ) ; } else { buf [ count ++ ] = ( byte ) ( _num + ( c > > _num ) ) ; buf [ count ++ ] = ( byte ) ( _num + ( ( c > > _num ) & _num ) ) ; buf [ count ++ ] = ( byte ) ( _num + ( c & _num ) ) ; } }	write a single character.
private static list < coperandtree > convert ( final inavimodule module , final list < operand > operands ) { final list < coperandtree > convertedoperands = new arraylist < coperandtree > ( ) ; for ( final operand operand : operands ) { convertedoperands . add ( module . createoperand ( convert ( module , operand . getrootnode ( ) , null ) ) ) ; } return convertedoperands ; }	converts api operands to internal operands .
public static string xmlescape ( string s ) { stringbuilder sb = new stringbuilder ( ) ; for ( int i = _num ; i < s . length ( ) ; i ++ ) { char ch = s . charat ( i ) ; switch ( ch ) { case _str : sb . append ( _str ) ; break ; case _str : sb . append ( _str ) ; break ; case _str : sb . append ( _str ) ; break ; case _str : sb . append ( _str ) ; break ; case _str : sb . append ( _str ) ; break ; case _str : sb . append ( _str ) ; break ; case _str : sb . append ( _str ) ; break ; case _str : sb . append ( _str ) ; break ; case _str : break ; default : sb . append ( ch ) ; break ; } } return sb . tostring ( ) ; }	returns a form of " s " appropriate for including in an xml document , after escaping certain special characters ( e.
public boolean writeheader ( outputstream os ) { try { writeint ( os , cache_magic ) ; writestring ( os , key ) ; writestring ( os , etag == null ? _str : etag ) ; writelong ( os , serverdate ) ; writelong ( os , ttl ) ; writelong ( os , softttl ) ; writestringstringmap ( responseheaders , os ) ; os . flush ( ) ; return _bool ; } catch ( ioexception e ) { volleylog . d ( _str , e . tostring ( ) ) ; return _bool ; } }	writes the contents of this cacheheader to the specified outputstream .
@ visiblefortesting public bitmap ensurenormalizedicon ( bitmap icon , string origin ) { if ( icon == null || icon . getwidth ( ) == _num ) { if ( micongenerator == null ) { int cornerradiuspx = math . min ( mlargeiconwidthpx , mlargeiconheightpx ) / _num ; micongenerator = new roundedicongenerator ( mlargeiconwidthpx , mlargeiconheightpx , cornerradiuspx , notification_icon_bg_color , notification_text_size_dp * mdensity ) ; } return micongenerator . generateiconforurl ( origin , _bool ) ; } if ( icon . getwidth ( ) > mlargeiconwidthpx || icon . getheight ( ) > mlargeiconheightpx ) { return icon . createscaledbitmap ( icon , mlargeiconwidthpx , mlargeiconheightpx , _bool ) ; } return icon ; }	ensures the availability of an icon for the notification.
protected boolean [ ] canhandlezerotraining ( boolean nominalpredictor , boolean numericpredictor , boolean stringpredictor , boolean datepredictor , boolean relationalpredictor , boolean multiinstance , int classtype ) { print ( _str ) ; printattributesummary ( nominalpredictor , numericpredictor , stringpredictor , datepredictor , relationalpredictor , multiinstance , classtype ) ; print ( _str ) ; arraylist < string > accepts = new arraylist < string > ( ) ; accepts . add ( _str ) ; accepts . add ( _str ) ; int numtrain = _num , numclasses = _num , missinglevel = _num ; boolean predictormissing = _bool , classmissing = _bool ; return runbasictest ( nominalpredictor , numericpredictor , stringpredictor , datepredictor , relationalpredictor , multiinstance , classtype , missinglevel , predictormissing , classmissing , numtrain , numclasses , accepts ) ; }	checks whether the scheme can handle zero training instances .
public sqlquery ( string typename , string sqlexpression ) { this ( sqlexpression , typename , null , default_query_result_type , null ) ; }	creates a sqlquery using the specified type and expression .
private static void checkoffset ( string value , int offset , char expected ) throws indexoutofboundsexception { char found = value . charat ( offset ) ; if ( found != expected ) { throw new indexoutofboundsexception ( _str + expected + _str + found + _str ) ; } }	check if the expected character exist at the given offset of the.
public boolean isinnet ( string host , string pattern , string mask ) { host = dnsresolve ( host ) ; if ( host == null || host . length ( ) == _num ) { return _bool ; } long lhost = parseipaddresstolong ( host ) ; long lpattern = parseipaddresstolong ( pattern ) ; long lmask = parseipaddresstolong ( mask ) ; return ( lhost & lmask ) == lpattern ; }	returns true if the ip address of the host matches the specified ip address pattern.
protected static pair < string , string > rrxregister ( final long offset , final itranslationenvironment environment , final list < reilinstruction > instructions , final string registernodevalue ) { final string shifteroperand = environment . getnextvariablestring ( ) ; final string shiftercarryout = environment . getnextvariablestring ( ) ; final string tmpvar1 = environment . getnextvariablestring ( ) ; final string tmpvar2 = environment . getnextvariablestring ( ) ; final string tmpvar3 = environment . getnextvariablestring ( ) ; long baseoffset = offset ; instructions . add ( reilhelpers . createbsh ( baseoffset ++ , bytesize , _str , wordsize , thirtyoneset , dwordsize , tmpvar1 ) ) ; instructions . add ( reilhelpers . createbsh ( baseoffset ++ , dwordsize , registernodevalue , bytesize , _str + oneset , dwordsize , tmpvar2 ) ) ; instructions . add ( reilhelpers . createor ( baseoffset ++ , dwordsize , tmpvar1 , dwordsize , tmpvar2 , dwordsize , tmpvar3 ) ) ; instructions . add ( reilhelpers . createand ( baseoffset ++ , dwordsize , tmpvar3 , dwordsize , bitmaskallbitsset , dwordsize , shifteroperand ) ) ; instructions . add ( reilhelpers . createand ( baseoffset ++ , dwordsize , registernodevalue , bytesize , string . valueof ( _num ) , bytesize , shiftercarryout ) ) ; return new pair < string , string > ( shifteroperand , shiftercarryout ) ; }	< rm > , rrx operation : shifter_operand = ( c flag logical_shift_left 31 ) or ( rm logical_shift_right 1 ) shifter_carry_out = rm [ 0 ].
public int enumerate ( thread [ ] threads ) { return enumerate ( threads , _bool ) ; }	iterates over all active threads in this group ( and its sub - groups ) and stores the threads in the given array.
public void findandundo ( object someobj ) { if ( someobj instanceof layerhandler ) { logger . fine ( _str ) ; if ( getlayerhandler ( ) == ( layerhandler ) someobj ) { setlayerhandler ( null ) ; } } if ( controls != null && someobj != this ) { controls . findandundo ( someobj ) ; } if ( someobj instanceof layer ) { panelookup . remove ( ( layer ) someobj ) ; } }	beancontextmembershiplistener method . called when an object has been removed from the parent beancontext . if a layerhandler is removed , and it ' s the current one being listened to , then the layers in the panel will be wiped clean .
public void start ( ) { log . info ( _str , this . name , this . frequencyinsecs ) ; stopped = _bool ; thread drhealthmonitorthread = new thread ( this ) ; drhealthmonitorthread . setname ( this . name ) ; drhealthmonitorthread . start ( ) ; }	start the health monitor.
public void connect ( string eventsourceurl ) throws ioexception { log . entering ( class_name , _str , eventsourceurl ) ; if ( stream != null ) { log . warning ( _str ) ; throw new illegalargumentexception ( _str ) ; } stream = new sseeventstream ( eventsourceurl ) ; stream . setlistener ( eventstreamlistener ) ; stream . connect ( ) ; }	connects the eventsource instance to the stream location .
private static string methodname ( @ nonnls final string method ) { return gitsshhandler . handler_name + _str + method ; }	get the full method name.
public datarow removedatarow ( int index ) { return datalist . remove ( index ) ; }	convenience method for removing data rows .
public void put ( object key , object value ) { int bucket = ( key . hashcode ( ) & _num ) % ftablesize ; entry entry = search ( key , bucket ) ; if ( entry != null ) { entry . value = value ; } else { entry = new entry ( key , value , fbuckets [ bucket ] ) ; fbuckets [ bucket ] = entry ; fnum ++ ; } }	adds the key / value mapping to the key table.
public void valuechanged ( listselectionevent e ) { if ( _table == null ) { return ; } int row = _table . getselectedrow ( ) ; if ( log . isdebugenabled ( ) ) { log . debug ( _str + row ) ; } if ( row >= _num ) { _addbutton . setenabled ( _bool ) ; _addbutton . settooltiptext ( null ) ; if ( _type != null && _type . equals ( _str ) ) { makeiconmap ( _picklistmodel . getbeanat ( row ) ) ; cleariconpanel ( ) ; doiconpanel ( ) ; } } else { _addbutton . setenabled ( _bool ) ; _addbutton . settooltiptext ( bundle . getmessage ( _str ) ) ; } validate ( ) ; }	when a pick list is installed , table selection controls the add button.
public static boolean isintermediatetable ( string tablename , sqlitedatabase db ) { if ( ! textutils . isempty ( tablename ) ) { if ( tablename . matches ( _str ) ) { cursor cursor = null ; try { cursor = db . query ( const . tableschema . table_name , null , null , null , null , null , null ) ; if ( cursor . movetofirst ( ) ) { do { string tablenamedb = cursor . getstring ( cursor . getcolumnindexorthrow ( const . tableschema . column_name ) ) ; if ( tablename . equalsignorecase ( tablenamedb ) ) { int tabletype = cursor . getint ( cursor . getcolumnindexorthrow ( const . tableschema . column_type ) ) ; if ( tabletype == const . tableschema . intermediate_join_table ) { return _bool ; } break ; } } while ( cursor . movetonext ( ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } finally { if ( cursor != null ) { cursor . close ( ) ; } } } } return _bool ; }	judge the table name is an intermediate table or not .
public static void initialize ( file helpdir ) throws helpexception { if ( helpdir . isdirectory ( ) && helpdir . exists ( ) ) helpmanager . helpdir = helpdir ; else throw new helpexception ( _str + helpdir . getabsolutepath ( ) , null ) ; }	initialize help . this must be called before fetching a help manager .
public realmatrix create ( ) { realmatrix rotation = newidentitymatrix ( ) ; for ( plane plane : planes ) { double theta = plane . gettheta ( ) ; if ( double . isnan ( theta ) ) { continue ; } rotation = rotation . multiply ( newrotationmatrix ( plane . getfirstaxis ( ) , plane . getsecondaxis ( ) , theta ) ) ; } return rotation ; }	returns the rotation matrix resulting from applying all 2d rotation planes and angles added to this builder .
public static string touppercase ( string str ) { return str . touppercase ( locale . english ) ; }	converts the characters in this string to upper case .
public boolean isdeclaredentity ( string entityname ) { entity entity = ( entity ) fentities . get ( entityname ) ; return entity != null ; }	checks whether an entity given by name is declared .
private void opencontextmenu ( mouseevent e ) { if ( e . ispopuptrigger ( ) ) { selectclicked ( e , _bool ) ; list < removedlistitem > selecteditems = list . getselectedvalueslist ( ) ; list < streaminfo > selected = new arraylist < > ( ) ; for ( removedlistitem item : selecteditems ) { selected . add ( item . getstreaminfo ( ) ) ; } streaminfoscontextmenu m = new streaminfoscontextmenu ( selected , _bool ) ; for ( contextmenulistener cml : contextmenulisteners ) { m . addcontextmenulistener ( cml ) ; } m . show ( list , e . getx ( ) , e . gety ( ) ) ; } }	open context menu for this user , if the event points at one .
private boolean put ( boolean isroot , vector names , int len , object value ) { if ( len == _num ) { if ( isroot ) { if ( rootvalue != null ) return _bool ; rootvalue = value ; } else { if ( othervalue != null ) return _bool ; othervalue = value ; } return _bool ; } else { object name = names . elementat ( len - _num ) ; contextmap nestedmap = ( contextmap ) nametable . get ( name ) ; if ( nestedmap == null ) { nestedmap = new contextmap ( ) ; nametable . put ( name , nestedmap ) ; } return nestedmap . put ( isroot , names , len - _num , value ) ; } }	adds a single path ( isroot , names ) and a mode to be used for this path = context .
protected void queue ( final path file ) throws interruptedexception { if ( null != base && file . startswith ( base ) ) { queue . put ( file . subpath ( base . getnamecount ( ) , file . getnamecount ( ) ) ) ; } else { queue . put ( file ) ; } }	queue a result from the scanner.
public inputstream openpath ( ) throws ioexception { path filepath = paths . get ( path ( ) ) ; if ( files . exists ( filepath ) ) { logger . info ( _str , filepath ) ; return files . newinputstream ( filepath ) ; } url resourceurl = resources . getresource ( path ( ) ) ; logger . info ( _str , resourceurl ) ; return resourceurl . openstream ( ) ; }	if the path does not exist on the filesystem , it is resolved as a resource .
public static string replacecharacters ( final conversionmethod conversionmethod , final string input , final int fromcharacter , final int tocharacter , final string wrap ) { string convertedtext = input ; for ( int i = fromcharacter ; i <= tocharacter ; i ++ ) { final string charactertoreplace = new string ( character . tochars ( i ) ) ; if ( wrap != null ) { convertedtext = convertedtext . replace ( charactertoreplace , wrap + converttext ( conversionmethod , charactertoreplace ) + wrap ) ; } else { convertedtext = convertedtext . replace ( charactertoreplace , converttext ( conversionmethod , charactertoreplace ) ) ; } } return convertedtext ; }	replaces characters using the given conversion method .
public static byte [ ] hmac_sha1 ( byte [ ] keybytes , byte [ ] text ) throws nosuchalgorithmexception , invalidkeyexception { mac hmacsha1 ; try { hmacsha1 = mac . getinstance ( _str ) ; } catch ( final nosuchalgorithmexception nsae ) { hmacsha1 = mac . getinstance ( _str ) ; } final secretkeyspec mackey = new secretkeyspec ( keybytes , _str ) ; hmacsha1 . init ( mackey ) ; return hmacsha1 . dofinal ( text ) ; }	this method uses the jce to provide the hmac - sha - 1 algorithm.
public static byte [ ] readbytesandclose ( inputstream in , int length ) throws ioexception { try { if ( length <= _num ) { length = integer . max_value ; } int block = math . min ( constants . io_buffer_size , length ) ; bytearrayoutputstream out = new bytearrayoutputstream ( block ) ; copy ( in , out , length ) ; return out . tobytearray ( ) ; } catch ( exception e ) { throw dbexception . converttoioexception ( e ) ; } finally { in . close ( ) ; } }	read a number of bytes from an input stream and close the stream .
public identvalue asidentvalue ( ) { if ( ! identisset ) { _identval = identvalue . getbyidentstring ( cssprimitivevalue . getcsstext ( ) ) ; identisset = _bool ; } return _identval ; }	description of the method.
public final testsuite build ( ) { rootsuite = new testsuite ( getsuitename ( ) ) ; currentclassname = null ; try { for ( testmethod test : testgrouping . gettests ( ) ) { if ( satisfiesallpredicates ( test ) ) { addtest ( test ) ; } } if ( testcases . size ( ) > _num ) { for ( testcase testcase : testcases ) { if ( satisfiesallpredicates ( new testmethod ( testcase ) ) ) { addtest ( testcase ) ; } } } } catch ( exception exception ) { log . i ( _str , _str , exception ) ; testsuite suite = new testsuite ( getsuitename ( ) ) ; suite . addtest ( new failedtocreatetests ( exception ) ) ; return suite ; } return rootsuite ; }	call this method once you ' ve configured your builder as desired .
public javax . naming . binding next ( ) throws namingexception { if ( more && counter >= _bindinglist . value . length ) { getmore ( ) ; } if ( more && counter < _bindinglist . value . length ) { org . omg . cosnaming . binding bndg = _bindinglist . value [ counter ] ; counter ++ ; return mapbinding ( bndg ) ; } else { throw new nosuchelementexception ( ) ; } }	returns the next binding in the list .
protected < t extends astnode > t movenode ( t oldnode , astrewrite rewrite ) { t movednode ; if ( astnodes . isexistingnode ( oldnode ) ) movednode = astnodes . createmovetarget ( rewrite , oldnode ) ; else movednode = astnodes . copysubtree ( rewrite . getast ( ) , oldnode ) ; return movednode ; }	if this occurrence update is called from within a declaration update ( i.
@ ignore @ test public void shouldbefasterwhenrunningprocessinginparallel ( ) throws exception { testmojowithconfigurablewromanagerfactorywithvalidconfigfileset ( ) ; final long begin = system . currenttimemillis ( ) ; victim . setparallelprocessing ( _bool ) ; testmojowithconfigurablewromanagerfactorywithvalidconfigfileset ( ) ; final long endserial = system . currenttimemillis ( ) ; victim . setparallelprocessing ( _bool ) ; testmojowithconfigurablewromanagerfactorywithvalidconfigfileset ( ) ; final long endparallel = system . currenttimemillis ( ) ; final long serial = endserial - begin ; final long parallel = endparallel - endserial ; log . info ( _str , serial ) ; log . info ( _str , parallel ) ; asserttrue ( string . format ( _str , serial , parallel ) , serial > parallel ) ; }	ignoring this test , since it is not reliable .
public void addconsumertype ( attributetype type ) { if ( ! consumertypes . contains ( type ) ) { consumertypes . add ( type ) ; } }	add a new type of consumer .
public final void printverbosemessage ( final localizablemessage msg ) { if ( isverbose ( ) ) { out . println ( wrap ( msg ) ) ; } }	displays a message to the output stream if verbose mode is enabled .
@ override public boolean isscraped ( ) { if ( ! scraped ) { if ( ! plot . isempty ( ) && ! ( year . isempty ( ) || year . equals ( _str ) ) && ! ( genres == null || genres . size ( ) == _num ) && ! ( actors == null || actors . size ( ) == _num ) ) { return _bool ; } } return scraped ; }	checks if this tv show has been scraped.
public void check ( final int api ) { if ( api == opcodes . asm4 ) { if ( visibletypeannotations != null && visibletypeannotations . size ( ) > _num ) { throw new runtimeexception ( ) ; } if ( invisibletypeannotations != null && invisibletypeannotations . size ( ) > _num ) { throw new runtimeexception ( ) ; } for ( fieldnode f : fields ) { f . check ( api ) ; } for ( methodnode m : methods ) { m . check ( api ) ; } } }	checks that this class node is compatible with the given asm api version.
public static string rtfenc ( string s ) { int ln = s . length ( ) ; int firstescidx = - _num ; int lastescidx = _num ; int plusoutln = _num ; for ( int i = _num ; i < ln ; i ++ ) { char c = s . charat ( i ) ; if ( c == _str || c == _str || c == _str ) { if ( firstescidx == - _num ) { firstescidx = i ; } lastescidx = i ; plusoutln ++ ; } } if ( firstescidx == - _num ) { return s ; } else { char [ ] esced = new char [ ln + plusoutln ] ; if ( firstescidx != _num ) { s . getchars ( _num , firstescidx , esced , _num ) ; } int dst = firstescidx ; for ( int i = firstescidx ; i <= lastescidx ; i ++ ) { char c = s . charat ( i ) ; if ( c == _str || c == _str || c == _str ) { esced [ dst ++ ] = _str ; } esced [ dst ++ ] = c ; } if ( lastescidx != ln - _num ) { s . getchars ( lastescidx + _num , ln , esced , dst ) ; } return string . valueof ( esced ) ; } }	rich text format encoding ( does not replace line breaks ).
public string tostring ( cp_info constant_pool [ ] ) { return integer . tostring ( ( int ) bytes ) ; }	returns a string representation of this entry .
public inetnetwork ( inetaddress inetaddress , int subnetbits ) { _inetaddress = inetaddress ; _address = inetaddress . getaddress ( ) ; if ( subnetbits < _num ) subnetbits = _num * _address . length ; _subnetbits = subnetbits ; _subnetbyte = subnetbits / _num ; _subnetmask = ~ ( ( _num << ( _num - subnetbits % _num ) ) - _num ) & _num ; }	create a internet mask .
@ override public hierarchywrapperoperation createsuboperation ( ) { return new tostringoperation ( builder , baseindent ) ; }	add the string to build and growing indent to sub operation.
protected final boolean execute ( ) throws adeexception { logger . info ( _str + m_requesttype . name ( ) ) ; final long start = system . currenttimemillis ( ) ; final boolean success = docontrollogic ( ) ; final long total = system . currenttimemillis ( ) - start ; logger . info ( m_requesttype . name ( ) + ( success ? _str : _str ) + _str + millisecondstohumantime ( total ) ) ; return success ; }	call the docontrollogic ( ) method defined in subclass , and provide additional traces , result handling to the docontrollogic ( ) .
public abstract jsonvalue sync ( ) throws synchronizationexception ;	performs the sync operation .
private boolean validconsist ( ) { int cn = validconsist ( consisttextfield . gettext ( ) ) ; if ( cn == - _num ) { consiststatus . settext ( rb . getstring ( _str ) ) ; joptionpane . showmessagedialog ( this , rb . getstring ( _str ) , rb . getstring ( _str ) , joptionpane . error_message ) ; return _bool ; } return _bool ; }	check for valid consist , popup error message if not.
private void activity ( ) { connectioncheckedcount = _num ; }	notifies the activity tracker that there was activity on the connection .
public void remove ( int position ) { mdata . remove ( position ) ; notifyitemremoved ( position + getheaderlayoutcount ( ) ) ; }	remove the item associated with the specified position of adapter.
public asyncbufferedoutputstream ( outputstream out , int bufsize , int maxbuffers ) { super ( out ) ; buffers = new concurrentlinkeddeque < > ( ) ; buf = new byte [ bufsize ] ; flusherthread . start ( ) ; }	creates an asynchronous buffered output stream .
public boolean startlistcontains ( string x ) { if ( startwords == null ) return _bool ; return startwords . contains ( x ) ; }	returns false if term is not in startlist , true otherwise ( including if no startlist exists ) .
private void closemediainfo ( ) { if ( mediainfo != null ) { mediainfo . close ( ) ; mediainfo = null ; } misnapshot = null ; }	closes the connection to the mediainfo lib .
public void addheader ( final header header ) { headers . add ( header ) ; }	adds the given header to the group.
private void readversion ( inputnode node , object source , label label ) throws exception { object value = readinstance ( node , source , label ) ; class expect = type . gettype ( ) ; if ( value != null ) { version version = context . getversion ( expect ) ; double actual = version . revision ( ) ; if ( ! value . equals ( revision ) ) { revision . compare ( actual , value ) ; } } }	this method is used to read the version from the provided input node.
protected ignite startgridwithigfs ( string gridname , string igfsname , igfsmode mode , @ nullable igfssecondaryfilesystem secondaryfs , @ nullable igfsipcendpointconfiguration restcfg ) throws exception { filesystemconfiguration igfscfg = new filesystemconfiguration ( ) ; igfscfg . setdatacachename ( _str ) ; igfscfg . setmetacachename ( _str ) ; igfscfg . setname ( igfsname ) ; igfscfg . setblocksize ( igfs_block_size ) ; igfscfg . setdefaultmode ( mode ) ; igfscfg . setipcendpointconfiguration ( restcfg ) ; igfscfg . setsecondaryfilesystem ( secondaryfs ) ; igfscfg . setprefetchblocks ( prefetch_blocks ) ; igfscfg . setsequentialreadsbeforeprefetch ( seq_reads_before_prefetch ) ; cacheconfiguration datacachecfg = defaultcacheconfiguration ( ) ; datacachecfg . setname ( _str ) ; datacachecfg . setcachemode ( partitioned ) ; datacachecfg . setnearconfiguration ( null ) ; datacachecfg . setwritesynchronizationmode ( cachewritesynchronizationmode . full_sync ) ; datacachecfg . setaffinitymapper ( new igfsgroupdatablockskeymapper ( _num ) ) ; datacachecfg . setbackups ( _num ) ; datacachecfg . setatomicitymode ( transactional ) ; datacachecfg . setoffheapmaxmemory ( _num ) ; cacheconfiguration metacachecfg = defaultcacheconfiguration ( ) ; metacachecfg . setname ( _str ) ; metacachecfg . setcachemode ( replicated ) ; metacachecfg . setwritesynchronizationmode ( cachewritesynchronizationmode . full_sync ) ; metacachecfg . setatomicitymode ( transactional ) ; igniteconfiguration cfg = new igniteconfiguration ( ) ; cfg . setgridname ( gridname ) ; tcpdiscoveryspi discospi = new tcpdiscoveryspi ( ) ; discospi . setipfinder ( new tcpdiscoveryvmipfinder ( _bool ) ) ; cfg . setdiscoveryspi ( discospi ) ; cfg . setcacheconfiguration ( datacachecfg , metacachecfg ) ; cfg . setfilesystemconfiguration ( igfscfg ) ; cfg . setlocalhost ( _str ) ; cfg . setconnectorconfiguration ( null ) ; return g . start ( cfg ) ; }	start grid with igfs .
private list < statistics > removefailed ( list < statistics > statistics ) { list < statistics > result = new arraylist < > ( ) ; for ( statistics statistic : statistics ) { if ( statistic . getsucceeded ( ) ) result . add ( statistic ) ; } return result ; }	returns a list which contains the succeeded statistic objects of the given statistics list.
public void addassociatedgefahr ( gefaehrdungsumsetzung gefaehrdung ) { if ( ! associatedgefaehrdungen . contains ( gefaehrdung ) ) { associatedgefaehrdungen . add ( gefaehrdung ) ; } }	adds a gefaehrdung to the list of all gefaehrdungen if gefaehrdung not already exits .
public static byte [ ] packbytebufferintosinglebytearray ( bytebuffer [ ] bytebufferarr ) { if ( null == bytebufferarr || bytebufferarr . length == _num ) { return null ; } int noofcol = bytebufferarr . length ; short todeterminelengthofbytearr = _num ; short offsetlen = ( short ) ( noofcol * _num + todeterminelengthofbytearr ) ; int totalbytes = calculatetotalbytes ( bytebufferarr ) + offsetlen ; bytebuffer buffer = bytebuffer . allocate ( totalbytes ) ; buffer . putshort ( ( short ) ( totalbytes - todeterminelengthofbytearr ) ) ; buffer . putshort ( offsetlen ) ; for ( int index = _num ; index < bytebufferarr . length - _num ; index ++ ) { bytebuffer individualcol = bytebufferarr [ index ] ; int noofbytes = individualcol . capacity ( ) ; buffer . putshort ( ( short ) ( offsetlen + noofbytes ) ) ; offsetlen += noofbytes ; individualcol . rewind ( ) ; } for ( int index = _num ; index < bytebufferarr . length ; index ++ ) { bytebuffer individualcol = bytebufferarr [ index ] ; buffer . put ( individualcol . array ( ) ) ; } buffer . rewind ( ) ; return buffer . array ( ) ; }	this method will form one single byte [ ] for all the high card dims .
public void connect ( socketaddress endpoint , int timeout ) throws ioexception { if ( endpoint == null ) throw new illegalargumentexception ( _str ) ; if ( timeout < _num ) throw new illegalargumentexception ( _str ) ; if ( isclosed ( ) ) throw new socketexception ( _str ) ; if ( ! oldimpl && isconnected ( ) ) throw new socketexception ( _str ) ; if ( ! ( endpoint instanceof inetsocketaddress ) ) throw new illegalargumentexception ( _str ) ; inetsocketaddress epoint = ( inetsocketaddress ) endpoint ; inetaddress addr = epoint . getaddress ( ) ; int port = epoint . getport ( ) ; checkaddress ( addr , _str ) ; securitymanager security = system . getsecuritymanager ( ) ; if ( security != null ) { if ( epoint . isunresolved ( ) ) security . checkconnect ( epoint . gethostname ( ) , port ) ; else security . checkconnect ( addr . gethostaddress ( ) , port ) ; } if ( ! created ) createimpl ( _bool ) ; if ( ! oldimpl ) impl . connect ( epoint , timeout ) ; else if ( timeout == _num ) { if ( epoint . isunresolved ( ) ) impl . connect ( addr . gethostname ( ) , port ) ; else impl . connect ( addr , port ) ; } else throw new unsupportedoperationexception ( _str ) ; connected = _bool ; bound = _bool ; }	connects this socket to the server with a specified timeout value.
private pair < hashsteptype , hashchaintype > fetchhashstep ( string uri , hashchaintype currentchain ) throws exception { int hashindex = uri . indexof ( _str ) ; if ( hashindex < _num ) { throw new codedexception ( x_malformed_hash_chain , _str , uri ) ; } string baseuri = uri . substring ( _num , hashindex ) ; string fragment = uri . substring ( hashindex + _num ) ; if ( fragment . isempty ( ) ) { throw new codedexception ( x_malformed_hash_chain , _str , uri ) ; } hashchaintype hashchain ; if ( baseuri . isempty ( ) ) { hashchain = currentchain ; } else { hashchain = gethashchain ( baseuri ) ; } for ( hashsteptype step : hashchain . gethashstep ( ) ) { if ( fragment . equals ( step . getid ( ) ) ) { return new immutablepair < > ( step , hashchain ) ; } } throw new codedexception ( x_malformed_hash_chain , _str , uri ) ; }	retrieve hash step based on the uri .
@ suppresswarnings ( _str ) public static boolean loadbycurrentclassloader ( string clsname ) { if ( clsname . startswith ( _str ) ) return _bool ; if ( clsname . startswith ( _str ) ) { if ( clsname . contains ( _str ) || clsname . contains ( _str ) || clsname . contains ( _str ) ) return _bool ; } return _bool ; }	check whether file must be loaded with current class loader , or normal delegation model should be used.
public void decrementtargetscountall ( ) { final long decrementandget = targetscountall . decrementandget ( ) ; if ( decrementandget < _num ) { targetscountall . set ( _num ) ; } }	decrement the targets all counter .
private void addnotavailablebusinessobjectdatastatuses ( list < businessobjectdatastatus > notavailablestatuses , list < storageunitentity > storageunitentities , set < businessobjectdataentity > archivedbusinessobjectdataentities ) { for ( storageunitentity storageunitentity : storageunitentities ) { notavailablestatuses . add ( createnotavailablebusinessobjectdatastatus ( storageunitentity , archivedbusinessobjectdataentities ) ) ; } }	adds business object data status instances created from the list of storage unit entities to the specified list of not - available statuses .
private list < jdbcstatement > createdefaultqueryjdbcstatements ( ) { list < jdbcstatement > jdbcstatements = new arraylist < > ( ) ; { jdbcstatement jdbcstatement = new jdbcstatement ( ) ; jdbcstatement . settype ( jdbcstatementtype . query ) ; jdbcstatement . setsql ( mockjdbcoperations . case_1_sql ) ; jdbcstatements . add ( jdbcstatement ) ; } return jdbcstatements ; }	returns a valid list of jdbc query statements . it contains only 1 statement , and the statement is case_1_sql in mock jdbc ( success , result 1 ).
private void testmemoryspatialindex ( ) throws sqlexception { deletedb ( _str ) ; connection conn = getconnection ( url ) ; statement stat = conn . createstatement ( ) ; stat . execute ( _str ) ; stat . execute ( _str ) ; stat . execute ( _str ) ; stat . execute ( _str ) ; resultset rs ; rs = stat . executequery ( _str + _str + _str ) ; assertfalse ( rs . next ( ) ) ; rs = stat . executequery ( _str + _str ) ; rs . next ( ) ; if ( config . mvstore ) { assertcontains ( rs . getstring ( _num ) , _str ) ; } stat . executequery ( _str + _str ) ; stat . executequery ( _str + _str ) ; rs = stat . executequery ( _str + _str ) ; asserttrue ( rs . next ( ) ) ; rs = stat . executequery ( _str + _str ) ; asserttrue ( rs . next ( ) ) ; rs = stat . executequery ( _str + _str ) ; assertfalse ( rs . next ( ) ) ; stat . execute ( _str ) ; conn . close ( ) ; deletedb ( _str ) ; }	test the in the in - memory spatial index.
public static boolean isvalid ( date expirationdate ) { date currentdate = new date ( ) ; string formatteddate = dateformat . format ( currentdate ) ; currentdate = convertdate ( formatteddate ) ; boolean isexpired = currentdate . after ( expirationdate ) ; boolean isequal = currentdate . equals ( expirationdate ) ; if ( isexpired == _bool || isequal == _bool ) { return _bool ; } return _bool ; }	validate the token expiration date .
public long contentlength ( ) { long size ; try { size = long . parselong ( request . getheader ( fileupload . content_length ) ) ; } catch ( numberformatexception e ) { size = request . getcontentlength ( ) ; } return size ; }	retrieve the content length of the request .
public void testzeropos ( ) { string numa = _str ; string numb = _str ; string res = _str ; biginteger anumber = new biginteger ( numa ) ; biginteger bnumber = new biginteger ( numb ) ; biginteger result = anumber . xor ( bnumber ) ; asserttrue ( res . equals ( result . tostring ( ) ) ) ; }	xor for zero and a positive number.
public checkbox addlistener ( listener listener ) { if ( listener != null && ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } return this ; }	adds a listener to this check box so that it will be notificed on certain user actions.
private void takepicture ( ) { log . d ( tag , _str ) ; lockfocus ( ) ; }	initiate a still image capture .
public static string showdialog ( final component component , final string title , final object message , final string ... buttons ) { return showdialog ( joptionpane . getframeforcomponent ( component ) , title , message , joptionpane . plain_message , buttons ) ; }	show a new modal dialog and block until the user press a button of closes the dialog.
public static void encode ( inputstream in , writer out ) throws ioexception { int column = _num ; while ( _bool ) { int byte1 = in . read ( ) ; int byte2 = in . read ( ) ; int byte3 = in . read ( ) ; if ( byte1 < _num ) { return ; } if ( column >= _num ) { column = _num ; out . write ( _str ) ; } out . write ( charset [ byte1 > > _num ] ) ; int index = ( byte1 & _num ) << _num ; if ( byte2 < _num ) { out . write ( charset [ index ] ) ; out . write ( paddingchar ) ; out . write ( paddingchar ) ; return ; } index += byte2 > > _num ; out . write ( charset [ index ] ) ; index = ( byte2 & _num ) << _num ; if ( byte3 < _num ) { out . write ( charset [ index ] ) ; out . write ( paddingchar ) ; return ; } index += byte3 > > _num ; out . write ( charset [ index ] ) ; out . write ( charset [ byte3 & _num ] ) ; column += _num ; } }	description of the method.
protected void sendmessage ( string handler , list < ? > arguments ) { ownermessage . addevent ( type . client_send_message , handler , arguments ) ; syncevents . add ( new sharedobjectevent ( type . client_send_message , handler , arguments ) ) ; sendstats . incrementandget ( ) ; }	broadcast event to event handler.
public void tasknow ( final runnable r , boolean async ) { if ( async ) { async ( r ) ; } else if ( r != null ) { r . run ( ) ; } }	run a task on the current thread or asynchronously - if it ' s already the main thread , it will jst call run ( ).
public void reset ( ) { cur . reset ( ) ; line . reset ( ) ; inuse = _bool ; word . setlength ( _num ) ; }	reset the pdftextformat for a new run.
protected void enginesetmode ( string mode ) throws nosuchalgorithmexception { if ( ( mode != null ) && ( ! mode . equalsignorecase ( _str ) ) ) { throw new nosuchalgorithmexception ( _str + mode ) ; } }	sets the mode of this cipher.
public static list < ? extends element > childelementlist ( documentfragment fragment ) { if ( fragment == null ) return null ; list < element > elements = new linkedlist < element > ( ) ; node node = fragment . getfirstchild ( ) ; if ( node != null ) { do { if ( node . getnodetype ( ) == node . element_node ) { element childelement = ( element ) node ; elements . add ( childelement ) ; } } while ( ( node = node . getnextsibling ( ) ) != null ) ; } return elements ; }	return a list of element objects that are children of the given documentfragment.
public void simulatemethod ( sootmethod method , referencevariable thisvar , referencevariable returnvar , referencevariable params [ ] ) { string subsignature = method . getsubsignature ( ) ; if ( subsignature . equals ( _str ) ) { java_lang_reflect_field_set ( method , thisvar , returnvar , params ) ; return ; } else if ( subsignature . equals ( _str ) ) { java_lang_reflect_field_get ( method , thisvar , returnvar , params ) ; return ; } else { defaultmethod ( method , thisvar , returnvar , params ) ; return ; } }	implements the abstract method simulatemethod.
public floatarray resize ( floatarray array , long size ) { if ( array instanceof bigfloatarray ) { return resizeinplace ( ( bigfloatarray ) array , size ) ; } else { abstractarray arr = ( abstractarray ) array ; final floatarray newarray = newfloatarray ( size , arr . clearonresize ) ; for ( long i = _num , end = math . min ( size , array . size ( ) ) ; i < end ; ++ i ) { newarray . set ( i , array . get ( i ) ) ; } arr . close ( ) ; return newarray ; } }	resize the array to the exact provided size .
@ override public boolean domainmatch ( final string host , string domain ) { if ( host . equals ( domain ) ) { return _bool ; } if ( ! domain . startswith ( _str ) ) { domain = _str + domain ; } return host . endswith ( domain ) || host . equals ( domain . substring ( _num ) ) ; }	performs domain - match as implemented in common browsers .
public boolean isdirty ( string key ) { return dirtykeys . contains ( key ) ; }	checks if a specific key was changed and not yet saved to the database .
final public void println ( float v ) { writer out = this . out ; if ( out == null ) return ; string s = string . valueof ( v ) ; try { out . write ( s , _num , s . length ( ) ) ; out . write ( _newline , _num , _newline . length ) ; } catch ( ioexception e ) { log . log ( level . fine , e . tostring ( ) , e ) ; } }	prints a float followed by a newline .
public double logdensityforinstance ( instance instance ) throws exception { double [ ] a = logjointdensitiesforinstance ( instance ) ; double max = a [ utils . maxindex ( a ) ] ; double sum = _num ; for ( int i = _num ; i < a . length ; i ++ ) { sum += math . exp ( a [ i ] - max ) ; } return max + math . log ( sum ) ; }	computes the density for a given instance .
public void testwhencomplete_sourcefailedactionfailed ( ) { for ( boolean createincomplete : new boolean [ ] { _bool , _bool } ) for ( executionmode m : executionmode . values ( ) ) { final atomicinteger a = new atomicinteger ( _num ) ; final cfexception ex1 = new cfexception ( ) ; final cfexception ex2 = new cfexception ( ) ; final completablefuture < integer > f = new completablefuture < > ( ) ; if ( ! createincomplete ) f . completeexceptionally ( ex1 ) ; final completablefuture < integer > g = m . whencomplete ( f , null ) ; if ( createincomplete ) f . completeexceptionally ( ex1 ) ; checkcompletedwithwrappedexception ( g , ex1 ) ; checkcompletedexceptionally ( f , ex1 ) ; assertequals ( _num , a . get ( ) ) ; } }	if a whencomplete action throws an exception when triggered by a source completion that also throws an exception , the source exception takes precedence ( unlike handle ).
public static angle greatcircledistance ( latlon p1 , latlon p2 ) { if ( ( p1 == null ) || ( p2 == null ) ) { throw new illegalargumentexception ( _str ) ; } double lat1 = p1 . getlatitude ( ) . radians ; double lon1 = p1 . getlongitude ( ) . radians ; double lat2 = p2 . getlatitude ( ) . radians ; double lon2 = p2 . getlongitude ( ) . radians ; if ( lat1 == lat2 && lon1 == lon2 ) return angle . zero ; double a = math . sin ( ( lat2 - lat1 ) / _num ) ; double b = math . sin ( ( lon2 - lon1 ) / _num ) ; double c = a * a + + math . cos ( lat1 ) * math . cos ( lat2 ) * b * b ; double distanceradians = _num * math . asin ( math . sqrt ( c ) ) ; return double . isnan ( distanceradians ) ? angle . zero : angle . fromradians ( distanceradians ) ; }	computes the great circle angular distance between two locations.
@ override public query rewrite ( indexreader reader ) throws ioexception { if ( disjuncts . length == _num ) { return disjuncts [ _num ] ; } boolean actuallyrewritten = _bool ; list < query > rewrittendisjuncts = new arraylist < > ( ) ; for ( query sub : disjuncts ) { query rewrittensub = sub . rewrite ( reader ) ; actuallyrewritten |= rewrittensub != sub ; rewrittendisjuncts . add ( rewrittensub ) ; } if ( actuallyrewritten ) { return new disjunctionmaxquery ( rewrittendisjuncts , tiebreakermultiplier ) ; } return super . rewrite ( reader ) ; }	optimize our representation and our subqueries representations.
public static string valueof ( long value ) { return long . tostring ( value ) ; }	converts the specified long to its string representation .
public static < t > boolean aresetsidentical ( final set < t > set1 , final set < t > set2 ) { if ( set1 == set2 ) return _bool ; if ( collectionutil . size ( set1 ) != collectionutil . size ( set2 ) ) return _bool ; if ( collectionutil . isempty ( set1 ) ) return _bool ; for ( final t t : set1 ) if ( ! set2 . contains ( t ) ) return _bool ; return _bool ; }	returns true iff all of the items on each set exist on the other set .
@ override public int compareto ( value o ) { return hashcode ( ) - o . hashcode ( ) ; }	compares the list value to another value.
private static void addoptions ( final list < string > cmd , map < checkerprop , object > props ) { for ( checkerprop cp : checkerprop . values ( ) ) { cmd . addall ( cp . getcmdline ( props ) ) ; } }	any options found in props to the cmd list.
public boolean obsolete ( ) { int [ ] stamp = new int [ _num ] ; boolean undeployed = usage . get ( stamp ) ; return undeployed && stamp [ _num ] == _num ; }	checks if deployment is obsolete , i.
boolean popnamespace ( string prefix ) { if ( prefix . startswith ( xml_prefix ) ) { return _bool ; } stack stack ; if ( ( stack = getprefixstack ( prefix ) ) != null ) { stack . pop ( ) ; return _bool ; } return _bool ; }	undeclare the namespace that is currently pointed to by a given prefix.
public void redolastaction ( ) { try { if ( undomanager . canredo ( ) ) undomanager . redo ( ) ; } catch ( cannotredoexception cre ) { cre . printstacktrace ( ) ; } }	attempt to redo the last action .
protected void continuewrite ( ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str ) ; } iterator < variablevalue > i = variables . iterator ( ) ; while ( i . hasnext ( ) ) { variablevalue v = i . next ( ) ; if ( v . istowrite ( ) && ( ! writingchanges || v . ischanged ( ) ) ) { amwriting = _bool ; setbusy ( _bool ) ; log . debug ( _str + v . label ( ) + _str + writingchanges ) ; if ( writingchanges ) { v . writechanges ( ) ; } else { v . writeall ( ) ; } log . debug ( _str ) ; return ; } } amwriting = _bool ; super . setstate ( stored ) ; setbusy ( _bool ) ; log . debug ( _str ) ; }	see if there ' s anything to write , and if so do it .
private void startgame ( gamelaunchmessage gamelaunchmessage , faction faction , ratingmode ratingmode , integer localrelayport ) { if ( isrunning ( ) ) { logger . warn ( _str ) ; return ; } stopsearchranked1v1 ( ) ; list < string > args = fixmalformedargs ( gamelaunchmessage . getargs ( ) ) ; try { localrelayserver . getport ( ) ; process = forgedallianceservice . startgame ( gamelaunchmessage . getuid ( ) , gamelaunchmessage . getmod ( ) , faction , args , ratingmode , localrelayport , rehostrequested ) ; setgamerunning ( _bool ) ; this . ratingmode = ratingmode ; spawnterminationlistener ( process ) ; } catch ( ioexception e ) { logger . warn ( _str , e ) ; notificationservice . addnotification ( new immediatenotification ( i18n . get ( _str ) , i18n . get ( _str ) , severity . error , e , arrays . aslist ( new reportaction ( i18n , reportingservice , e ) , new dismissaction ( i18n ) ) ) ) ; } }	actually starts the game.
public void addline ( string line ) { int index = line . indexof ( _str , _num ) ; if ( index != - _num ) { addlenient ( line . substring ( _num , index ) , line . substring ( index + _num ) ) ; } else if ( line . startswith ( _str ) ) { addlenient ( _str , line . substring ( _num ) ) ; } else { addlenient ( _str , line ) ; } }	add an http header line containing a field name , a literal colon , and a value.
private synchronized void addentries ( hashtable entries ) { entrydirectory . putall ( entries ) ; }	copy all the entries into the entrydirectory it will overwrite any duplicate keys .
public static void loadproject ( final jtree tree , final inaviproject project ) { preconditions . checknotnull ( tree , _str ) ; preconditions . checknotnull ( project , _str ) ; loadprojectthreaded ( swingutilities . getwindowancestor ( tree ) , project , tree ) ; }	loads a project while showing a progress dialog .
public enumeration listoptions ( ) { vector newvector = new vector ( _num ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public static datapolicy fromordinal ( byte ordinal ) { return values [ ordinal ] ; }	return the datapolicy represented by specified ordinal.
public static boolean isinstalled ( packagemanager packagemanager , string packagename ) { list < packageinfo > packs = packagemanager . getinstalledpackages ( _num ) ; for ( int i = _num ; i < packs . size ( ) ; i ++ ) { if ( textutils . equals ( packs . get ( i ) . packagename , packagename ) ) return _bool ; } return _bool ; }	checks if the app has been installed on the system .
public void addsetattribute ( final setattribute setattribute ) { setattributes . add ( setattribute ) ; }	will add the setattribute to the list .
static string applytemplate ( final string template , final map < string , object > map ) { configuration = getconfiguration ( ) ; try ( bytearrayoutputstream outputstream = new bytearrayoutputstream ( ) ; writer writer = new outputstreamwriter ( outputstream ) ) { template configurationtemplate = configuration . gettemplate ( template ) ; configurationtemplate . process ( map , writer ) ; return outputstream . tostring ( ) ; } catch ( exception e ) { throw new runtimeexception ( e . getmessage ( ) , e ) ; } }	returns the string result from applying a freemarker template .
final void putshort ( int offset , short value ) { unsafe . putshort ( offset + address , value ) ; }	writes a short at the specified offset from this native object ' s base address .
public static clob toclob ( object value ) throws pageexception { if ( value instanceof clob ) return ( clob ) value ; else if ( value instanceof char [ ] ) return toclob ( new string ( ( char [ ] ) value ) ) ; else if ( value instanceof reader ) { stringwriter sw = new stringwriter ( ) ; try { ioutil . copy ( ( reader ) value , sw , _bool , _bool ) ; } catch ( ioexception e ) { throw expressionexception . newinstance ( e ) ; } return toclob ( sw . tostring ( ) ) ; } return toclob ( caster . tostring ( value ) ) ; }	cast given value to a clob.
private jfreechart createhistogramchart ( exampleset exampleset ) { jfreechart chart = chartfactory . createhistogram ( null , null , null , createhistogramdataset ( exampleset ) , plotorientation . vertical , _bool , _bool , _bool ) ; abstractattributestatisticsmodel . setdefaultchartfonts ( chart ) ; chart . setbackgroundpaint ( null ) ; chart . setbackgroundimagealpha ( _num ) ; xyplot plot = ( xyplot ) chart . getplot ( ) ; plot . setrangegridlinesvisible ( _bool ) ; plot . setdomaingridlinesvisible ( _bool ) ; plot . setoutlinevisible ( _bool ) ; plot . setrangezerobaselinevisible ( _bool ) ; plot . setdomainzerobaselinevisible ( _bool ) ; plot . setbackgroundpaint ( color_invisible ) ; plot . setbackgroundimagealpha ( _num ) ; xybarrenderer renderer = ( xybarrenderer ) plot . getrenderer ( ) ; renderer . setseriespaint ( _num , attributeguitools . getcolorforvaluetype ( ontology . numerical ) ) ; renderer . setbarpainter ( new standardxybarpainter ( ) ) ; renderer . setdrawbaroutline ( _bool ) ; renderer . setshadowvisible ( _bool ) ; return chart ; }	creates the histogram chart .
list < type > save ( ) { listbuffer < type > buf = new listbuffer < > ( ) ; for ( type t : undetvars ) { undetvar uv = ( undetvar ) t ; undetvar uv2 = new undetvar ( ( typevar ) uv . qtype , types ) ; for ( inferencebound ib : inferencebound . values ( ) ) { for ( type b : uv . getbounds ( ib ) ) { uv2 . addbound ( ib , b , types ) ; } } uv2 . inst = uv . inst ; buf . add ( uv2 ) ; } return buf . tolist ( ) ; }	save the state of this inference context.
public int executeprocess ( ) { final list < string > processstrings = tokenizestring ( execcommand ) ; processstrings . addall ( tokenizestring ( script ) ) ; logger . info ( messageformat . format ( _str , processstrings ) ) ; final processbuilder processbuilder = new processbuilder ( processstrings ) ; if ( workingdirectory != null ) { final path dir = paths . get ( workingdirectory ) ; if ( files . notexists ( dir ) ) { try { files . createdirectories ( dir ) ; } catch ( ioexception e ) { logger . warning ( _str + workingdirectory ) ; return - _num ; } } else if ( ! files . isdirectory ( dir ) ) { logger . warning ( workingdirectory + _str ) ; return - _num ; } final file directory = dir . tofile ( ) ; processbuilder . directory ( directory ) ; } processbuilder . redirecterrorstream ( _bool ) ; integer exitvalue ; try { logger . info ( _str ) ; final process process = processbuilder . start ( ) ; sendinputstringtoprocess ( process ) ; handleprocessoutput ( process ) ; try { exitvalue = process . waitfor ( ) ; } catch ( interruptedexception e ) { logger . warning ( _str ) ; process . destroy ( ) ; exitvalue = - _num ; } logger . info ( _str + exitvalue + _str ) ; } catch ( ioexception e ) { logger . log ( severe , _str , e . getcause ( ) ) ; exitvalue = - _num ; } return exitvalue ; }	executes the process specified by execcommand , classname , and optionally , invaluesstring .
static void checkmethoddesc ( final string desc ) { if ( desc == null || desc . length ( ) == _num ) { throw new illegalargumentexception ( _str ) ; } if ( desc . charat ( _num ) != _str || desc . length ( ) < _num ) { throw new illegalargumentexception ( _str + desc ) ; } int start = _num ; if ( desc . charat ( start ) != _str ) { do { if ( desc . charat ( start ) == _str ) { throw new illegalargumentexception ( _str + desc ) ; } start = checkdesc ( desc , start , _bool ) ; } while ( start < desc . length ( ) && desc . charat ( start ) != _str ) ; } start = checkdesc ( desc , start + _num , _bool ) ; if ( start != desc . length ( ) ) { throw new illegalargumentexception ( _str + desc ) ; } }	checks that the given string is a valid method descriptor .
protected rectangle applymargins ( rectangle rect , float [ ] margins , boolean reverse ) { if ( ispositioned ( ) ) return rect ; return rect . < rectangle > applymargins ( margins [ _num ] , margins [ _num ] , margins [ _num ] , margins [ _num ] , reverse ) ; }	applies given margins on the given rectangle.
private void resetattempts ( ) { for ( final politicalactionattachment paa : politicalactionattachment . getpoliticalactionattachments ( m_player ) ) { paa . resetattempts ( getbridge ( ) ) ; } }	reset the attempts - counter for this action , so next round the player can try again for a number of attempts .
public static number minus ( character left , character right ) { return minus ( integer . valueof ( left ) , right ) ; }	subtract one character from another.
public void findandinit ( object someobj ) { if ( someobj instanceof mousedelegator ) { debug . message ( _str , _str ) ; setmousedelegator ( ( mousedelegator ) someobj ) ; } }	called when a component that is needed , and not available with an appropriate iterator from the beancontext.
public static int toint ( final string value ) { return integer . parseint ( value ) ; }	converts the given xml string to an integer value .
protected object evaluateleftlessright ( list elements , string lvalue , string rvalue ) { list array ; if ( elements instanceof java . util . vector ) { array = new java . util . vector ( ) ; } else { array = new arraylist ( ) ; } for ( iterator e = elements . iterator ( ) ; e . hasnext ( ) ; ) { object o = e . next ( ) ; if ( o instanceof structuredcontent ) { if ( ( o = evaluateleftlessright ( ( structuredcontent ) o , lvalue , rvalue ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == _num ) { return ( structuredcontent ) array . get ( _num ) ; } return array ; }	override this element to handle testing a predicate expression where lvalue < rvalue.
public void removecatchable ( catchablepokemon pokemon ) { if ( cachedcatchable . size ( ) > _num ) { cachedcatchable . remove ( pokemon ) ; } }	remove a catchable pokemon from the cache.
@ suppresswarnings ( _str ) @ override protected void fillbuffer ( ) { int oldp = p ; int index = tokens . size ( ) ; token t = tokensource . nexttoken ( ) ; while ( t != null && t . gettype ( ) != charstream . eof ) { int type = t . gettype ( ) ; if ( type == internaln4jslexer . solidus || type == internaln4jslexer . solidusequalssign || type == internaln4jslexer . rightcurlybracket ) { t . settokenindex ( index ) ; tokens . add ( t ) ; index ++ ; break ; } boolean discard = _bool ; if ( channeloverridemap != null ) { integer channeli = ( integer ) channeloverridemap . get ( integer . valueof ( type ) ) ; if ( channeli != null ) { t . setchannel ( channeli . intvalue ( ) ) ; } } if ( discardset != null && discardset . contains ( integer . valueof ( type ) ) ) { discard = _bool ; } else if ( discardoffchanneltokens && t . getchannel ( ) != this . channel ) { discard = _bool ; } if ( ! discard ) { t . settokenindex ( index ) ; tokens . add ( t ) ; index ++ ; } t = tokensource . nexttoken ( ) ; } p = oldp == - _num ? _num : oldp ; p = skipofftokenchannels ( p ) ; }	fills the buffer but stops on a div or div - equals token .
char casefold ( char c ) { if ( alternatecasing ) { if ( c == _str ) { return _str ; } else if ( c == _str ) { return _str ; } else { return character . tolowercase ( c ) ; } } else { return character . tolowercase ( c ) ; } }	folds single character ( according to lang if present ).
public void writecountscomparisonlist ( final string filename , final string format ) { if ( format . comparetoignorecase ( _str ) == _num ) { countsimcomparisonkmlwriter kmlwriter = new countsimcomparisonkmlwriter ( countscomparisonlist , this . network , transformationfactory . getcoordinatetransformation ( this . coordinatesystem , transformationfactory . wgs84 ) ) ; kmlwriter . writefile ( filename ) ; } else if ( format . comparetoignorecase ( _str ) == _num ) { countsimcomparisontablewriter writer = new countsimcomparisontablewriter ( countscomparisonlist , locale . us ) ; writer . writefile ( filename ) ; } else { throw new illegalargumentexception ( _str ) ; } comparisonerrorstatscalculator errorstats = new comparisonerrorstatscalculator ( countscomparisonlist ) ; double [ ] hours = new double [ _num ] ; for ( int i = _num ; i < _num ; i ++ ) { hours [ i - _num ] = i ; } doublearraytablewriter tablewriter = new doublearraytablewriter ( ) ; tablewriter . addcolumn ( hours ) ; tablewriter . addcolumn ( errorstats . getmeanrelerror ( ) ) ; tablewriter . writefile ( filename + _str ) ; }	writes the results of the comparison to a file.
public void putgrammar ( dtdgrammar grammar ) { xmldtddescription desc = ( xmldtddescription ) grammar . getgrammardescription ( ) ; fgrammars . put ( desc , grammar ) ; }	puts the specified grammar into the grammar pool and associate it to a root element name ( this being internal , the lack of generality is irrelevant ) .
public servicecall < translationresult > translate ( final string text , final language source , final language target ) { return translate ( collections . singletonlist ( text ) , source , target ) ; }	translate text using source and target languages . < br >.
@ override public int execute ( final formobject form , final int type , final string code , final int eventtype , final char keypressed ) { int messagecode ; final string js = code ; final string [ ] args = jsfunction . converttoarray ( js ) ; final string command = args [ _num ] ; if ( command . startswith ( _str ) ) { messagecode = handleafcommands ( form , command , js , args , eventtype , keypressed ) ; } else { executefunctions ( js , form , acro ) ; messagecode = actionhandler . valueschanged ; } if ( type == pdfdictionary . f ) { calcualteevent ( ) ; messagecode = actionhandler . valueschanged ; } return messagecode ; }	execute javascript and reset forms values.
private object readresolve ( ) { synchronized ( levels ) { for ( level level : levels ) { if ( value != level . value ) { continue ; } if ( ! name . equals ( level . name ) ) { continue ; } if ( objects . equal ( resourcebundlename , level . resourcebundlename ) ) { return level ; } } levels . add ( this ) ; return this ; } }	serialization helper method to maintain singletons and add any new levels .
private static void repeat ( string pattern , int count , appendable out ) throws ioexception { while ( count >= pattern . length ( ) ) { out . append ( pattern ) ; count -= pattern . length ( ) ; } if ( count > _num ) { out . append ( pattern , _num , count ) ; } }	append count characters from pattern onto out , repeating if necessary .
private void cleanup ( reference < ? > reference ) throws shutdown { method finalizereferentmethod = getfinalizereferentmethod ( ) ; do { reference . clear ( ) ; if ( reference == frqreference ) { throw new shutdown ( ) ; } try { finalizereferentmethod . invoke ( reference ) ; } catch ( throwable t ) { logger . log ( level . severe , _str , t ) ; } } while ( ( reference = queue . poll ( ) ) != null ) ; }	cleans up a single reference.
public @ checkfornull queue . item run2 ( @ nonnull string replacementmainscript , @ nonnull map < string , string > replacementloadedscripts ) { list < action > actions = new arraylist < action > ( ) ; cpsflowexecution execution = getexecution ( ) ; if ( execution == null ) { return null ; } actions . add ( new replayflowfactoryaction ( replacementmainscript , replacementloadedscripts , execution . issandbox ( ) ) ) ; actions . add ( new causeaction ( new cause . useridcause ( ) , new replaycause ( run ) ) ) ; for ( class < ? extends action > c : copied_actions ) { actions . addall ( run . getactions ( c ) ) ; } return parameterizedjobmixin . schedulebuild2 ( run . getparent ( ) , _num , actions . toarray ( new action [ actions . size ( ) ] ) ) ; }	for use in projects that want initiate a replay via the java api .
public static secretkeys keys ( string keysstr ) throws invalidkeyexception { string [ ] keysarr = keysstr . split ( _str ) ; if ( keysarr . length != _num ) { throw new illegalargumentexception ( _str ) ; } else { byte [ ] confidentialitykey = base64 . decode ( keysarr [ _num ] , base64_flags ) ; if ( confidentialitykey . length != aes_key_length_bits / _num ) { throw new invalidkeyexception ( _str + aes_key_length_bits + _str ) ; } byte [ ] integritykey = base64 . decode ( keysarr [ _num ] , base64_flags ) ; if ( integritykey . length != hmac_key_length_bits / _num ) { throw new invalidkeyexception ( _str + hmac_key_length_bits + _str ) ; } secretkeys secretkeys = new secretkeys ( ) ; secretkeyspec secretkeyspec = new secretkeyspec ( ) ; secretkeyspec . generate ( confidentialitykey , _num , confidentialitykey . length , cipher ) ; secretkeyspec secretkeyspec1 = new secretkeyspec ( ) ; secretkeyspec1 . generate ( integritykey , hmac_algorithm ) ; secretkeys . setconfidentialitykey ( secretkeyspec ) ; secretkeys . setintegritykey ( secretkeyspec1 ) ; return secretkeys ; } }	an aes key derived from a base64 encoded key.
public path [ ] choosestartingpaths ( final int nedges , final path [ ] paths ) { final list < path > tmp = new linkedlist < path > ( ) ; arrays . sort ( paths , _num , paths . length , estimatedcardinalitycomparator . instance ) ; for ( int i = _num ; i < paths . length && i < nedges ; i ++ ) { tmp . add ( paths [ i ] ) ; } return tmp . toarray ( new path [ tmp . size ( ) ] ) ; }	choose the starting vertices .
private void safebottomview ( ) { status status = getopenstatus ( ) ; viewgroup bottom = getbottomview ( ) ; if ( status == status . close ) { if ( bottom . getvisibility ( ) != invisible ) bottom . setvisibility ( invisible ) ; } else { if ( bottom . getvisibility ( ) != visible ) bottom . setvisibility ( visible ) ; } }	prevent bottom view get any touch event.
public static int uniform ( int n ) { if ( n <= _num ) throw new illegalargumentexception ( _str ) ; return random . nextint ( n ) ; }	returns a random integer uniformly in [ 0 , n ) .
private void viewdelta ( final item item ) { final deltafragment fragment = deltafragment . newinstance ( item ) ; navigatetofragment ( fragment ) ; }	starts up a new view delta viewer.
public message ( string type , double value ) { if ( ! valid_types . contains ( type ) ) { throw new illegalargumentexception ( type + _str + _str ) ; } this . type = type ; this . value = value ; }	creates a new message from the type and the value .
public void addall ( final casualtylist casualtylist ) { m_damaged . addall ( casualtylist . getdamaged ( ) ) ; m_killed . addall ( casualtylist . getkilled ( ) ) ; }	can have multiple of the same unit , to show multiple hits to that unit .
public static string importresultset ( resultset source , database db , string name , importfilter filter , boolean useexistingtable ) throws sqlexception , ioexception { resultsetmetadata md = source . getmetadata ( ) ; name = tablebuilder . escapeidentifier ( name ) ; table table = null ; if ( ! useexistingtable || ( ( table = db . gettable ( name ) ) == null ) ) { list < columnbuilder > columns = tocolumns ( md ) ; table = createuniquetable ( db , name , columns , md , filter ) ; } list < object [ ] > rows = new arraylist < object [ ] > ( copy_table_batch_size ) ; int numcolumns = md . getcolumncount ( ) ; while ( source . next ( ) ) { object [ ] row = new object [ numcolumns ] ; for ( int i = _num ; i < row . length ; i ++ ) { row [ i ] = source . getobject ( i + _num ) ; } row = filter . filterrow ( row ) ; if ( row == null ) { continue ; } rows . add ( row ) ; if ( rows . size ( ) == copy_table_batch_size ) { table . addrows ( rows ) ; rows . clear ( ) ; } } if ( rows . size ( ) > _num ) { table . addrows ( rows ) ; } return table . getname ( ) ; }	copy an existing jdbc resultset into a new ( or optionally existing ) table in this database .
@ override public long skip ( long n ) throws ioexception { long remaining = n ; final char [ ] ch = new char [ fbuffer . length ] ; do { int length = ch . length < remaining ? ch . length : ( int ) remaining ; int count = read ( ch , _num , length ) ; if ( count > _num ) { remaining -= count ; } else { break ; } } while ( remaining > _num ) ; long skipped = n - remaining ; return skipped ; }	skip characters . this method will block until some characters are available , an i / o error occurs , or the end of the stream is reached .
public static long [ ] hashtolongs ( double datum , long seed ) { double d = ( datum == _num ) ? _num : datum ; long [ ] data = { double . doubletolongbits ( d ) } ; return hash ( data , seed ) ; }	hash a double and long seed .
private boolean allowuploadcrashdump ( ) { if ( iscellularexperimentenabled ( ) ) return isusageandcrashreportingenabled ( ) ; if ( ismobilenetworkcapable ( ) ) { string option = msharedpreferences . getstring ( pref_crash_dump_upload , mcrashdumpneverupload ) ; return option . equals ( mcrashdumpalwaysupload ) || ( option . equals ( mcrashdumpwifionlyupload ) && iswifiorethernetnetwork ( ) ) ; } return msharedpreferences . getboolean ( pref_crash_dump_upload_no_cellular , _bool ) ; }	check whether to allow uploading usage and crash reporting.
private int [ ] joinmap ( int [ ] a , int [ ] b ) { if ( a == null ) { return b ; } if ( b == null ) { return a ; } int [ ] result = new int [ a . length + b . length ] ; system . arraycopy ( a , _num , result , _num , a . length ) ; system . arraycopy ( b , _num , result , a . length , b . length ) ; return result ; }	joins two map arrays ( int [ ] ) together .
private void readobject ( objectinputstream in ) throws classnotfoundexception , ioexception { in . defaultreadobject ( ) ; iter = col . iterator ( ) ; }	recreate inner state for object after deserialization .
public labelset ( int indices [ ] , boolean sort ) { this . indices = indices ; if ( sort == _bool ) arrays . sort ( this . indices ) ; }	a new labelset , indicating sort = true if indices they need to be sorted ( i.
public void diffequals ( ) { double [ ] col = null ; for ( int i = _num ; i < a . length ; i ++ ) { col = new double [ a [ i ] . length - _num ] ; for ( int j = _num ; j < a [ i ] . length ; j ++ ) col [ j - _num ] = math . abs ( a [ i ] [ j ] - a [ i ] [ j - _num ] ) ; a [ i ] = col ; } n -- ; }	x . diffequals ( ) calculates differences between adjacent columns of this matrix . consequently the size of the matrix is reduced by one . the result is stored in this matrix object again .
private static void printstacktraceelement ( stacktraceelement trace , printwriter out , classloader loader ) { try { linemap map = getscriptlinemap ( trace . getclassname ( ) , loader ) ; if ( map != null ) { linemap . line line = map . getline ( trace . getlinenumber ( ) ) ; if ( line != null ) { out . print ( trace . getclassname ( ) + _str + trace . getmethodname ( ) ) ; out . print ( _str + line . getsourcefilename ( ) + _str ) ; out . println ( line . getsourceline ( trace . getlinenumber ( ) ) + _str ) ; return ; } } } catch ( throwable e ) { } out . println ( trace ) ; }	prints a single stack trace element .
public void readinformationobject ( final pdfobject infoobj , final objectdecoder objectdecoder ) { try { objectdecoder . checkresolved ( infoobj ) ; } catch ( final exception e ) { logwriter . writelog ( _str + e . getmessage ( ) ) ; } string newvalue ; int id ; byte [ ] data ; final int count = pdffileinformation . information_field_ids . length ; for ( int i = _num ; i < count ; i ++ ) { id = pdffileinformation . information_field_ids [ i ] ; if ( id == pdfdictionary . trapped ) { newvalue = infoobj . getname ( id ) ; if ( newvalue == null ) { newvalue = _str ; } } else { data = infoobj . gettextstreamvalueasbyte ( id ) ; if ( data == null ) { newvalue = _str ; } else { newvalue = stringutils . gettextstring ( data , _bool ) ; } } setfieldvalue ( i , newvalue ) ; } }	read information object and return pointer to correct place.
private void cmd_calculatedifference ( ) { bigdecimal previousvalue , actualvalue ; timestamp today = timeutil . getday ( system . currenttimemillis ( ) ) ; mcash cash = mcash . get ( p_pos . getctx ( ) , p_pos . getc_cashbook_id ( ) , today , null ) ; v_previousbalance . setvalue ( cash . getendingbalance ( ) ) ; previousvalue = cash . getendingbalance ( ) ; actualvalue = ( bigdecimal ) v_actualbalance . getvalue ( ) ; v_difference . setvalue ( actualvalue . subtract ( previousvalue ) ) ; }	calculate difference between previous balance and actual for cash scrutiny.
public boolean testallocation ( ) { boolean change = _bool ; if ( isprocessed ( ) ) { bigdecimal alloc = getallocatedamt ( ) ; if ( alloc == null ) alloc = env . zero ; bigdecimal total = getgrandtotal ( ) ; if ( ! issotrx ( ) ) total = total . negate ( ) ; if ( iscreditmemo ( ) ) total = total . negate ( ) ; boolean test = total . compareto ( alloc ) == _num ; change = test != ispaid ( ) ; if ( change ) setispaid ( test ) ; log . fine ( _str + test + _str + alloc + _str + total + _str ) ; } return change ; }	test allocation ( and set paid flag ).
private void requestforupload ( ocfile file ) { fileuploader . uploadrequester requester = new fileuploader . uploadrequester ( ) ; requester . uploadupdate ( mcontext , maccount , file , fileuploader . local_behaviour_move , _bool ) ; mtransferwasrequested = _bool ; }	requests for an upload to the fileuploader service.
void refreshcustommasterlist ( ) { if ( custommastercountries == null || custommastercountries . length ( ) == _num ) { custommastercountrieslist = null ; } else { list < country > localcountrylist = new arraylist < > ( ) ; for ( string namecode : custommastercountries . split ( _str ) ) { country country = country . getcountryfornamecodefromlibrarymasterlist ( customlanguage , namecode ) ; if ( country != null ) { if ( ! isalreadyinlist ( country , localcountrylist ) ) { localcountrylist . add ( country ) ; } } } if ( localcountrylist . size ( ) == _num ) { custommastercountrieslist = null ; } else { custommastercountrieslist = localcountrylist ; } } if ( custommastercountrieslist != null ) { for ( country country : custommastercountrieslist ) { country . log ( ) ; } } else { } }	this will load preferredcountries based on countrypreference.
protected boolean isdtogetter ( method method ) { if ( method . isannotationpresent ( delegateto . class ) ) { return _bool ; } string methodname = method . getname ( ) ; if ( ( methodname . startswith ( _str ) || methodname . startswith ( _str ) ) && method . getparametertypes ( ) . length == _num ) { if ( methodname . length ( ) > _num && methodname . startswith ( _str ) ) { return method . getreturntype ( ) == boolean . class || method . getreturntype ( ) == boolean . class ; } return methodname . length ( ) > _num ; } return _bool ; }	check is specified method is dto getter .
protected void handleparseconversionexception ( exception e ) throws saxexception { if ( e instanceof runtimeexception ) throw ( runtimeexception ) e ; parseconversionevent pce = new parseconversioneventimpl ( validationevent . error , e . getmessage ( ) , new validationeventlocatorimpl ( context . getlocator ( ) ) , e ) ; context . handleevent ( pce , _bool ) ; }	this method is called by the generated derived class when a datatype parse method throws an exception .
public statusbar ( boolean showmemory ) { super ( new borderlayout ( ) ) ; add ( createinfopanel ( ) , borderlayout . west ) ; if ( showmemory ) { add ( creatememorystatus ( ) , borderlayout . center ) ; jpanel iconpanel = new jpanel ( new borderlayout ( ) ) ; iconpanel . add ( new jlabel ( new angledlineswindowscornericon ( ) ) , borderlayout . south ) ; add ( iconpanel , borderlayout . east ) ; } else { setbackground ( color . white ) ; } }	creates a new instance of statusbar.
public void execute ( final runnable task ) { string name = metadata . get ( metadata . resource_name_key ) ; if ( name != null ) { name = _str + name ; } else { name = _str ; } final thread thread = new thread ( task , name ) ; thread . setdaemon ( _bool ) ; thread . start ( ) ; }	executes the given task in a daemon thread .
static int stringsize ( string string ) { int size = _num ; if ( string != null ) { size += headers + _num * _num ; size += headers + _num * string . length ( ) ; } return size ; }	returns an estimate of the memory footprint , in bytes , of the given string .
public static graphrequest newpostopengraphobjectrequest ( accesstoken accesstoken , jsonobject opengraphobject , callback callback ) { if ( opengraphobject == null ) { throw new facebookexception ( _str ) ; } if ( utility . isnullorempty ( opengraphobject . optstring ( _str ) ) ) { throw new facebookexception ( _str ) ; } if ( utility . isnullorempty ( opengraphobject . optstring ( _str ) ) ) { throw new facebookexception ( _str ) ; } string path = string . format ( my_objects_format , opengraphobject . optstring ( _str ) ) ; bundle bundle = new bundle ( ) ; bundle . putstring ( object_param , opengraphobject . tostring ( ) ) ; return new graphrequest ( accesstoken , path , bundle , httpmethod . post , callback ) ; }	creates a new request configured to create a user owned open graph object .
public void addgraph ( graph g ) { graphs . add ( g ) ; }	gives a method for adding classes to the class .
private mrcmessage loadchars ( ) throws java . io . ioexception { int nchars ; byte [ ] rcvbuffer = new byte [ _num ] ; nchars = inpipe . read ( rcvbuffer , _num , _num ) ; mrcmessage msg = new mrcmessage ( nchars ) ; for ( int i = _num ; i < nchars ; i ++ ) { msg . setelement ( i , rcvbuffer [ i ] & _num ) ; } return msg ; }	get characters from the input source .
@ suppresswarnings ( _str ) @ override protected money handletransactionthatisalaterepaymentofinstallment ( final loanrepaymentscheduleinstallment currentinstallment , final list < loanrepaymentscheduleinstallment > installments , final loantransaction loantransaction , final money transactionamountunprocessed , list < loantransactiontorepaymentschedulemapping > transactionmappings ) { return handletransactionthatisontimepaymentofinstallment ( currentinstallment , loantransaction , transactionamountunprocessed , transactionmappings ) ; }	for late repayments , pay off in the same way as on - time payments , interest first then principal .
protected void firetupleevent ( table t , int start , int end , int type ) { if ( m_tuplelisteners != null && m_tuplelisteners . size ( ) > _num ) { object [ ] lstnrs = m_tuplelisteners . getarray ( ) ; tuple [ ] tuples = new tuple [ end - start + _num ] ; for ( int i = _num , r = start ; r <= end ; ++ r , ++ i ) { tuples [ i ] = t . gettuple ( r ) ; } for ( int i = _num ; i < lstnrs . length ; ++ i ) { tuplesetlistener tsl = ( tuplesetlistener ) lstnrs [ i ] ; if ( type == eventconstants . insert ) { tsl . tuplesetchanged ( this , tuples , empty_array ) ; } else { tsl . tuplesetchanged ( this , empty_array , tuples ) ; } } } }	fire a tuple event .
public string buildquery ( string [ ] projectionin , string selection , string groupby , string having , string sortorder , string limit ) { string [ ] projection = computeprojection ( projectionin ) ; stringbuilder where = new stringbuilder ( ) ; boolean hasbasewhereclause = mwhereclause != null && mwhereclause . length ( ) > _num ; if ( hasbasewhereclause ) { where . append ( mwhereclause . tostring ( ) ) ; where . append ( _str ) ; } if ( selection != null && selection . length ( ) > _num ) { if ( hasbasewhereclause ) { where . append ( _str ) ; } where . append ( _str ) ; where . append ( selection ) ; where . append ( _str ) ; } return buildquerystring ( mdistinct , mtables , projection , where . tostring ( ) , groupby , having , sortorder , limit ) ; }	construct a select statement suitable for use in a group of select statements that will be joined through union operators in buildunionquery .
public static boolean isexceptiontime ( calendar scheduletime , scheduleinfo scheduleinfo ) throws exception { if ( scheduleinfo . getdateexceptions ( ) != null ) { for ( string dateexception : scheduleinfo . getdateexceptions ( ) ) { dateformat formatter = new simpledateformat ( scheduleinfo . full_daytime_format ) ; date date = formatter . parse ( scheduleinfo . getstartdate ( ) ) ; calendar exceptiontime = calendar . getinstance ( timezone . gettimezone ( _str ) ) ; exceptiontime . settime ( date ) ; if ( exceptiontime . equals ( scheduletime ) ) { log . info ( _str , scheduletime . tostring ( ) ) ; return _bool ; } } } return _bool ; }	check if the schedule time is in exception list.
protected void initport ( ) { string portparam = getinitparameter ( _str ) ; setport ( ( portparam == null ) ? default_port : integer . parseint ( portparam ) ) ; if ( isdebug ( ) ) { log ( _str + getport ( ) ) ; } }	initializer for property port .
public jpegqtable ( int [ ] table ) { if ( table == null ) { throw new illegalargumentexception ( _str ) ; } if ( table . length != _num ) { throw new illegalargumentexception ( _str ) ; } qtable = arrays . copyof ( table , table . length ) ; }	constructs a quantization table from the argument , which must contain 64 elements in natural order ( not zig - zag order ).
public vnxenfsshare findsnapnfsshare ( string snapid , string sharename , string softwareversion ) { stringbuilder queryfilter = new stringbuilder ( vnxeconstants . name_filter ) ; if ( ! vnxeutils . ishigherversion ( softwareversion , vnxeconstants . vnxe_base_soft_ver ) ) { queryfilter . append ( sharename ) ; queryfilter . append ( vnxeconstants . and ) ; queryfilter . append ( vnxeconstants . snap_filter ) ; queryfilter . append ( snapid ) ; } else { queryfilter . append ( _str + sharename + _str ) ; queryfilter . append ( vnxeconstants . and ) ; queryfilter . append ( vnxeconstants . snap_filter_v31 ) ; queryfilter . append ( _str + snapid + _str ) ; } setfilter ( queryfilter . tostring ( ) ) ; vnxenfsshare result = null ; list < vnxenfsshare > sharelist = getdataforobjects ( vnxenfsshare . class ) ; if ( sharelist != null && ! sharelist . isempty ( ) ) { result = sharelist . get ( _num ) ; _logger . info ( _str , snapid , sharename ) ; } else { _logger . info ( _str , snapid , sharename ) ; } return result ; }	find snapshot nfsshare using snapshot id and share name.
@ override public final int read ( ) throws ioexception { bytebuffer bb = waitforavailabledata ( ) ; return ( bb . get ( ) & _num ) ; }	see the inputstream read method for javadocs . note that if an attempt to read past the end of the wrapped bytebuffer is done this method throws bufferunderflowexception.
protected tokenposition ( tokenposition other ) { objects . requirenonnull ( other ) ; this . line = other . line ; this . column = other . column ; this . offset = other . offset ; }	creates a new instance with the values of the given token position .
private jcomponent createdetailpanel ( throwable error ) { stacktracelist stl = new stacktracelist ( error ) ; jscrollpane detailpane = new extendedjscrollpane ( stl ) ; detailpane . setpreferredsize ( new dimension ( getwidth ( ) , _num ) ) ; detailpane . setborder ( null ) ; return detailpane ; }	creates a panel for the error details and attaches the exception to it , but doesn ' t add the panel to the dialog .
abstract boolean containskey ( t container , string key ) ;	checks if the container contains the key.
private jmxconnector connect ( string host , int port ) { try { if ( ! isnodeavailable ( host ) ) { log . info ( _str , host ) ; throw new illegalstateexception ( _str ) ; } log . debug ( _str , host , port ) ; string connectoraddress = string . format ( serviceurl , host , port ) ; jmxserviceurl jmxurl = new jmxserviceurl ( connectoraddress ) ; return jmxconnectorfactory . connect ( jmxurl ) ; } catch ( malformedurlexception e ) { log . error ( string . format ( _str , host , port ) , e ) ; throw new illegalstateexception ( _str ) ; } catch ( ioexception e ) { log . error ( string . format ( _str , host , port ) , e ) ; throw new illegalstateexception ( _str + host ) ; } }	create a connection to the jmx agent.
public taghandler processobjectvalue ( object value ) throws jspexception { if ( value instanceof attributedefinition ) { return processtypedattribute ( ( attributedefinition ) value ) ; } else if ( value instanceof componentdefinition ) { return processdefinition ( ( componentdefinition ) value ) ; } return processasdefinitionorurl ( value . tostring ( ) ) ; }	process an object retrieved as a bean or attribute.
public list < integer > emit ( string streamid , tuple anchor , list < object > tuple ) { return emit ( streamid , arrays . aslist ( anchor ) , tuple ) ; }	emits a new tuple to a specific stream with a single anchor.
private synchronized void writetooutputstream ( int onebyte ) { if ( mclosed ) { return ; } try { moutputstream . write ( onebyte ) ; reportdecodedsizeifapplicable ( ) ; } catch ( ioexception e ) { handleioexceptionwritingtostream ( e ) ; } }	writes the byte to all the output streams.
protected list < modelentity > makeentitymodeltouselist ( ) throws genericentityexception { list < genericvalue > entitysyncincludes = entitysync . getrelated ( _str , null , null , _bool ) ; list < genericvalue > entitysyncgroupincludes = entitysync . getrelated ( _str , null , null , _bool ) ; entitysyncincludes . addall ( entitysyncgroupincludes ) ; list < modelentity > entitymodeltouselist = entitygrouputil . getmodelentitiesfromrecords ( entitysyncincludes , delegator , _bool ) ; if ( debug . infoon ( ) ) debug . loginfo ( _str + entitysync . get ( _str ) + _str + entitymodeltouselist . size ( ) + _str , module ) ; return entitymodeltouselist ; }	prepare a list of all entities we want to synchronize : remove all view - entities and all entities that don ' t match the patterns attached to this entitysync.
private static string lz ( int num ) { return string . format ( _str , num ) ; }	add leadingzero if only 1 char.
public void onchildidlebegin ( ) { _idlecount . incrementandget ( ) ; }	called by the thread before going into the idle state .
private startupmode checkstartupmode ( configuration config ) throws ioexception { startupmode bootmode = checkstartupmodeondisk ( config ) ; if ( bootmode != null ) { return bootmode ; } if ( checkconfigbool ( config , constants . startupmode_restore_reinit ) ) { _log . info ( _str , constants . startupmode_restore_reinit ) ; geodbrestoremode mode = new geodbrestoremode ( config ) ; mode . setcoordinator ( _coordinator ) ; mode . setschemautil ( _schemautil ) ; mode . setdbdir ( dbdir ) ; return mode ; } if ( checkconfigbool ( config , constants . reinit_db ) ) { _log . info ( _str , constants . reinit_db ) ; dbreinitmode mode = new dbreinitmode ( config ) ; mode . setcoordinator ( _coordinator ) ; mode . setschemautil ( _schemautil ) ; mode . setdbdir ( dbdir ) ; return mode ; } list < string > obsoletepeers = checkconfiglist ( config , constants . obsolete_cassandra_peers ) ; if ( ! obsoletepeers . isempty ( ) ) { obsoletepeerscleanupmode mode = new obsoletepeerscleanupmode ( config ) ; mode . setcoordinator ( _coordinator ) ; mode . setschemautil ( _schemautil ) ; mode . setobsoletepeers ( obsoletepeers ) ; return mode ; } else { normalmode mode = new normalmode ( config ) ; mode . setcoordinator ( _coordinator ) ; mode . setschemautil ( _schemautil ) ; return mode ; } }	determine current startup mode.
private void writeobject ( java . io . objectoutputstream s ) throws java . io . ioexception { lock . lock ( ) ; try { q = new priorityqueue < e > ( math . max ( size , _num ) , comparator ) ; q . addall ( this ) ; s . defaultwriteobject ( ) ; } finally { q = null ; lock . unlock ( ) ; } }	saves this queue to a stream ( that is , serializes it ).
private void run ( ) { try { thread current = thread . currentthread ( ) ; byte [ ] buf = new byte [ _num ] ; for ( int len = in . read ( buf ) ; len != - _num ; len = in . read ( buf ) ) { buffer . write ( buf , _num , len ) ; if ( current != thread ) { break ; } } buffer . flush ( ) ; buffer . close ( ) ; } catch ( ioexception e ) { log . error ( e . getmessage ( ) , e ) ; } }	consumes the input stream until it runs out or is interrupted .
protected boolean shardavailable ( @ nullable indexshard shard ) { return shard != null && shard . canindex ( ) && can_update_index_buffer_states . contains ( shard . state ( ) ) ; }	returns true if shard exists and is availabe for updates.
synchronized void updateauthconfigglobals ( serviceschemamanager scm ) throws smsexception { serviceschema schema = scm . getorganizationschema ( ) ; schema = schema . getsubschema ( _str ) ; schema = schema . getsubschema ( _str ) ; map attrs = schema . getattributedefaults ( ) ; if ( attrs != null ) { defaultservicesuccessurlset = ( set ) attrs . get ( isauthconstants . login_success_url ) ; defaultservicefailureurlset = ( set ) attrs . get ( isauthconstants . login_failure_url ) ; } if ( debug . messageenabled ( ) ) { debug . message ( _str + defaultservicesuccessurlset ) ; debug . message ( _str + defaultservicefailureurlset ) ; } }	update the authconfiguration organization attributes .
public void increment ( ) { count . incrementandget ( ) ; ratewindow . incrementfortimestamp ( timergetter . now ( ) ) ; }	increments the cumulative count of evaluations and recalculates the rate.
long totalmemory ( ) ;	get total physical memory in bytes.
@ override public int preceding ( int offset ) { characteriterator text = gettext ( ) ; checkoffset ( offset , text ) ; text . setindex ( offset ) ; return previous ( ) ; }	sets the iterator to refer to the last boundary position before the specified position .
public void log ( string event , string message ) { boolean eventactive = iseventactive ( event ) ; if ( ( this . logging && eventactive && ! writers . isempty ( ) ) ) { try { for ( writer writer : writers . values ( ) ) { writer . write ( message ) ; writer . write ( _str ) ; writer . flush ( ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } } }	logs the given message with a newline associated with the given event .
public int write ( final bytebuffer bytebuffer ) throws ioexception { ensureopen ( ) ; final int remaining = bytebuffer . remaining ( ) ; if ( inspectable < buffer . length ) { final int tobuffer = math . min ( buffer . length - inspectable , remaining ) ; bytebuffer . get ( buffer , inspectable , tobuffer ) ; inspectable += tobuffer ; } if ( bytebuffer . hasremaining ( ) ) { filechannel . position ( writeposition ) ; writeposition += filechannel . write ( bytebuffer ) ; } return remaining ; }	appends the content of a specified buffer to the end of the currently represented stream .
public void copyinto ( int stroffset , byte [ ] bytes , int arrayoffset , int len ) { system . arraycopy ( m_bytes , m_offset + stroffset , bytes , arrayoffset , len ) ; }	copy the bytes of the string into the given byte array .
public static string repeatstring ( string pattern , int repeats ) { stringbuilder buffer = new stringbuilder ( pattern . length ( ) * repeats ) ; for ( int i = _num ; i < repeats ; i ++ ) { buffer . append ( pattern ) ; } return new string ( buffer ) ; }	returns a string made up of repetitions of the specified string .
private boolean ismusicplayer ( ) { return playersetting != null && playersetting . equalsignorecase ( _str ) ; }	helper method that tells us if we are using musicplayer.
public final static versioninfo [ ] loadversioninfo ( string [ ] pckgs , classloader clsldr ) { if ( pckgs == null ) { throw new illegalargumentexception ( _str ) ; } arraylist vil = new arraylist ( pckgs . length ) ; for ( int i = _num ; i < pckgs . length ; i ++ ) { versioninfo vi = loadversioninfo ( pckgs [ i ] , clsldr ) ; if ( vi != null ) vil . add ( vi ) ; } return ( versioninfo [ ] ) vil . toarray ( new versioninfo [ vil . size ( ) ] ) ; }	loads version information for a list of packages .
public static collection < contentstream > tocontentstreams ( final string str , final string contenttype ) { if ( str == null ) return null ; arraylist < contentstream > streams = new arraylist < > ( _num ) ; contentstreambase ccc = new contentstreambase . stringstream ( str ) ; ccc . setcontenttype ( contenttype ) ; streams . add ( ccc ) ; return streams ; }	take a string and make it an iterable contentstream.
void writerepeatedsqrt ( dd xdd ) { int count = _num ; while ( xdd . doublevalue ( ) > _num ) { count ++ ; double x = xdd . doublevalue ( ) ; dd xsqrt = xdd . sqrt ( ) ; string s = xsqrt . tostring ( ) ; dd xsqrt2 = dd . parse ( s ) ; dd xx = xsqrt2 . multiply ( xsqrt2 ) ; double err = math . abs ( xx . doublevalue ( ) - x ) ; xdd = xsqrt ; dd distfrom1dd = xsqrt . subtract ( dd . valueof ( _num ) ) ; double distfrom1 = distfrom1dd . doublevalue ( ) ; if ( math . abs ( distfrom1 ) < _num ) break ; } }	this routine simply tests for robustness of the tostring function .
public static boolean hasextension ( string extension ) { if ( extension == null || extension . isempty ( ) ) { return _bool ; } return extensiontomimetypemap . containskey ( extension ) ; }	returns true if the given extension has a registered mime type .
private float applyfriction ( float velocity , float simulationrate ) { if ( iszero ( velocity ) ) { velocity = _num ; } else if ( velocity > _num ) { velocity = math . max ( _num , velocity - ( friction * simulationrate ) ) ; } else { velocity = math . min ( _num , velocity + ( friction * simulationrate ) ) ; } return velocity ; }	friction slows velocity in the opposite direction of motion , until zero velocity is reached .
static boolean realisjunit4test ( class scriptclass , groovyclassloader loader ) { boolean istest = _bool ; try { try { class runwithannotationclass = loader . loadclass ( _str ) ; annotation annotation = scriptclass . getannotation ( runwithannotationclass ) ; if ( annotation != null ) { istest = _bool ; } else { class testannotationclass = loader . loadclass ( _str ) ; method [ ] methods = scriptclass . getmethods ( ) ; for ( int i = _num ; i < methods . length ; i ++ ) { method method = methods [ i ] ; annotation = method . getannotation ( testannotationclass ) ; if ( annotation != null ) { istest = _bool ; break ; } } } } catch ( classnotfoundexception e ) { } } catch ( throwable e ) { } return istest ? boolean . true : boolean . false ; }	utility method to check via reflection if the parsed class appears to be a junit4 test .
private static void parseexpression ( final reader reader , final boolean writingstring , final stringbuilder templateexpressions ) throws ioexception { if ( ! writingstring ) { templateexpressions . append ( _str ) ; } templateexpressions . append ( _str ) ; while ( _bool ) { int c = reader . read ( ) ; if ( c == - _num ) break ; if ( c == _str ) { c = reader . read ( ) ; if ( c == _str ) break ; templateexpressions . append ( _str ) ; } templateexpressions . append ( ( char ) c ) ; } templateexpressions . append ( _str ) ; }	parse a & lt ; % =.
protected void reduceparsetree ( compilationunitdeclaration unit ) { typedeclaration [ ] types = unit . types ; for ( int i = _num , l = types . length ; i < l ; i ++ ) purgemethodstatements ( types [ i ] , _bool ) ; }	called prior to the unit being resolved.
public static long findrevision ( final list < string > output , final pattern pattern ) { long revision = - _num ; for ( final string line : output ) { final matcher matcher = pattern . matcher ( line ) ; if ( matcher . find ( ) ) { revision = long . parselong ( matcher . group ( _num ) ) ; break ; } } return revision ; }	for the given pattern , find the revision number .
protected int choosehighwatermark ( int capacity , double maxload ) { return math . min ( capacity - _num , ( int ) ( capacity * maxload ) ) ; }	returns new high water mark threshold based on current capacity and maxloadfactor .
private accessgrant createaccessgrant ( map < string , string > params ) { accessgrant accessgrant = new accessgrant ( ) ; if ( params . get ( _str ) != null ) { string accesstoken = params . get ( _str ) ; integer expires = null ; if ( params . get ( _str ) != null ) { expires = integer . valueof ( params . get ( _str ) ) ; } accessgrant . setkey ( accesstoken ) ; accessgrant . setattribute ( _str , expires ) ; } accessgrant . setproviderid ( mprovidername . tostring ( ) ) ; return accessgrant ; }	internal method to create new create accessgrant.
protected final boolean _loadtohaveatleast ( int minavailable ) throws ioexception { if ( _inputstream == null ) { return _bool ; } int amount = _inputend - _inputptr ; if ( amount > _num && _inputptr > _num ) { _currinputprocessed += _inputptr ; _currinputrowstart -= _inputptr ; system . arraycopy ( _inputbuffer , _inputptr , _inputbuffer , _num , amount ) ; _inputend = amount ; } else { _inputend = _num ; } _inputptr = _num ; while ( _inputend < minavailable ) { int count = _inputstream . read ( _inputbuffer , _inputend , _inputbuffer . length - _inputend ) ; if ( count < _num ) { _closeinput ( ) ; if ( count == _num ) { throw new ioexception ( _str + amount + _str ) ; } return _bool ; } _inputend += count ; } return _bool ; }	helper method that will try to load at least specified number bytes in input buffer , possible moving existing data around if necessary.
public double logpdf ( double x ) { return math . log ( pdf ( x ) ) ; }	the natural log of the probability density function of the distribution.
private void selectfile ( int titlemsg , int buttonmsg , string settingsname , string defaultdir , int dialog , int result ) { setautomode ( automode . off ) ; string action = _str ; intent i = new intent ( action ) ; string currentfile = settings . getstring ( settingsname , _str ) ; string sep = file . separator ; if ( ! currentfile . contains ( sep ) ) currentfile = environment . getexternalstoragedirectory ( ) + sep + defaultdir + sep + currentfile ; i . setdata ( uri . fromfile ( new file ( currentfile ) ) ) ; i . putextra ( _str , getstring ( titlemsg ) ) ; i . putextra ( _str , getstring ( buttonmsg ) ) ; try { startactivityforresult ( i , result ) ; } catch ( activitynotfoundexception e ) { removedialog ( dialog ) ; showdialog ( dialog ) ; } }	open a load / save file dialog.
public string timerstring ( int level , string message ) { stringbuilder retstringbuf = new stringbuilder ( ) ; for ( int i = _num ; i < level ; i ++ ) { retstringbuf . append ( _str ) ; } retstringbuf . append ( _str ) ; string timesincestartstr = string . valueof ( timesincestart ( ) ) ; retstringbuf . append ( timesincestartstr + _str ) ; string timesincelaststr = string . valueof ( timesincelast ( ) ) ; retstringbuf . append ( timesincelaststr ) ; retstringbuf . append ( _str ) ; int spacecount = _num + ( _num * level ) - retstringbuf . length ( ) ; for ( int i = _num ; i < spacecount ; i ++ ) { retstringbuf . append ( _str ) ; } retstringbuf . append ( message ) ; lastmessagetime = system . currenttimemillis ( ) ; string retstring = retstringbuf . tostring ( ) ; if ( log && debug . timingon ( ) ) debug . logtiming ( retstring , module ) ; return retstring ; }	creates a string with information including the passed message , the time since the last call , and the time since the beginning.
public static int recompilewithopt ( normalmethod method ) { if ( vm . buildforoptcompiler ) { compilationplan plan = new compilationplan ( method , ( optimizationplanelement [ ] ) optimizationplan , null , ( optoptions ) options ) ; return recompilewithopt ( plan ) ; } else { if ( vm . verifyassertions ) vm . _assert ( vm . not_reached ) ; return - _num ; } }	a wrapper method for those callers who don ' t want to make optimization plans.
public string findmatch ( pattern pattern , string text ) { return findmatch ( pattern , text , _num ) ; }	finds the first match of the specified pattern and returns the first group .
private void addhit ( string cname , class < ? > c ) { if ( len == names . length ) { final int nl = ( len << _num ) + _num ; names = arrays . copyof ( names , nl ) ; clazzes = arrays . copyof ( clazzes , nl ) ; } names [ len ] = cname ; clazzes [ len ] = c ; ++ len ; }	if a name has been resolved , add it .
private object querycommandvalue ( final string commandidentifier ) { check . notnull ( commandidentifier , _str ) ; final stringbuffer cmd = new stringbuffer ( ) ; cmd . append ( _str ) ; cmd . append ( commandidentifier ) ; cmd . append ( _str ) ; return browser . evaluate ( cmd . tostring ( ) ) ; }	gets the value of the document , range , or selection for the given command .
public void line ( double x , double y ) { line line = new line ( x , y ) ; if ( x < minx ) { minx = x ; } if ( y < miny ) { miny = y ; } if ( x > maxx ) { maxx = x ; } if ( y > maxy ) { maxy = y ; } elements . add ( line ) ; }	draw a line in the current line style ( if any ).
@ override public list < cluster < t > > cluster ( final collection < t > points ) throws nullargumentexception { mathutils . checknotnull ( points ) ; final list < cluster < t > > clusters = new arraylist < cluster < t > > ( ) ; final map < clusterable , pointstatus > visited = new hashmap < clusterable , pointstatus > ( ) ; for ( final t point : points ) { if ( visited . get ( point ) != null ) { continue ; } final list < t > neighbors = getneighbors ( point , points ) ; if ( neighbors . size ( ) >= minpts ) { final cluster < t > cluster = new cluster < t > ( ) ; clusters . add ( expandcluster ( cluster , point , neighbors , points , visited ) ) ; } else { visited . put ( point , pointstatus . noise ) ; } } return clusters ; }	performs dbscan cluster analysis .
public void testgetversion25 ( ) throws exception { string xml = webapp_25_header + _str ; webxml webxml = webxmlio . parsewebxml ( new bytearrayinputstream ( xml . getbytes ( _str ) ) , getentityresolver ( ) ) ; assertequals ( webxmlversion . v2_5 , webxml . getversion ( ) ) ; }	tests whether a servlet api version 2.
@ override public void mousepressed ( mouseevent evt ) { int pos = ( slider . getorientation ( ) == jslider . horizontal ) ? evt . getx ( ) : evt . gety ( ) ; int loc = getlocationforvalue ( getsnappedvalue ( evt ) ) ; this . offset = ( loc < _num ) ? _num : pos - loc ; }	when the slider is clicked we need to record the offset from the thumb centre .
public void write ( int ch ) throws ioexception { outputstream os = getoutputstream ( ) ; os . write ( _str ) ; os . write ( _num ) ; os . write ( _num ) ; os . write ( ch ) ; }	writes a data byte to the output stream .
public static < s > serviceloader < s > loadinstalled ( class < s > service ) { classloader cl = classloader . getsystemclassloader ( ) ; if ( cl != null ) { while ( cl . getparent ( ) != null ) { cl = cl . getparent ( ) ; } } return serviceloader . load ( service , cl ) ; }	constructs a service loader , using the extension class loader .
private static iterator < operand > iteratereturnvalues ( ir ir ) { arraylist < operand > returnvalues = new arraylist < operand > ( ) ; for ( enumeration < instruction > e = ir . forwardinstrenumerator ( ) ; e . hasmoreelements ( ) ; ) { instruction s = e . nextelement ( ) ; if ( return . conforms ( s ) ) { returnvalues . add ( return . getval ( s ) ) ; } } return returnvalues . iterator ( ) ; }	todo : move this utility elsewhere.
public static pattern glob2pattern ( string ... globs ) { final stringbuilder regex = new stringbuilder ( ) ; boolean needor = _bool ; for ( string glob : globs ) { if ( needor ) { regex . append ( _str ) ; } int i = _num , len = glob . length ( ) ; while ( i < len ) { char c = glob . charat ( i ++ ) ; switch ( c ) { case _str : if ( i < len && glob . charat ( i ) == _str ) { regex . append ( _str ) ; i ++ ; } else { regex . append ( _str ) ; } break ; case _str : regex . append ( _str ) ; break ; default : if ( isregexmeta ( c ) ) { regex . append ( _str ) ; } regex . append ( c ) ; } } needor = _bool ; } return pattern . compile ( regex . tostring ( ) , _num ) ; }	returns a regex pattern that matches on any of the globs on class names ( e.
public static boolean containstraceexplorermoduleconflict ( string rootmodulename ) { string rootmodulefilename = rootmodulename ; if ( ! rootmodulename . endswith ( resourcehelper . tla_extension ) ) { rootmodulefilename = resourcehelper . getmodulefilename ( rootmodulename ) ; } list < string > extendedmodulenames = toolboxhandle . getextendedmodules ( rootmodulefilename ) ; iterator < string > it = extendedmodulenames . iterator ( ) ; while ( it . hasnext ( ) ) { string modulename = it . next ( ) ; if ( modulename . equals ( te_file_tla ) ) { return _bool ; } } return _bool ; }	determines if the spec with root module rootmodulename is dependent on a module with the same name as the root module used for trace exploration .
public void testflipbitnegativeinside2 ( ) { byte abytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = - _num ; int number = _num ; byte rbytes [ ] = { - _num , _num , - _num , - _num , _num , _num , - _num , - _num , - _num , - _num , _num , - _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . flipbit ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , result . signum ( ) ) ; }	flipbit ( int n ) inside a negative number.
private string buildfullmessage ( string msg , object arg0 , object arg1 , object arg2 , object [ ] argarray ) { stringbuilder sb = null ; int lastindex = _num ; int argc = _num ; while ( _bool ) { int argindex = msg . indexof ( arg_string , lastindex ) ; if ( argindex == - _num ) { break ; } if ( sb == null ) { sb = new stringbuilder ( _num ) ; } sb . append ( msg , lastindex , argindex ) ; lastindex = argindex + arg_string_length ; if ( argarray == null ) { if ( argc == _num ) { appendarg ( sb , arg0 ) ; } else if ( argc == _num ) { appendarg ( sb , arg1 ) ; } else if ( argc == _num ) { appendarg ( sb , arg2 ) ; } else { } } else if ( argc < argarray . length ) { appendarg ( sb , argarray [ argc ] ) ; } else { } argc ++ ; } if ( sb == null ) { return msg ; } else { sb . append ( msg , lastindex , msg . length ( ) ) ; return sb . tostring ( ) ; } }	return a combined single message from the msg ( with possible { } ) and optional arguments .
protected void removefromparentinfo ( openable child ) { openable parent = ( openable ) child . getparent ( ) ; if ( parent != null && parent . isopen ( ) ) { try { openableelementinfo info = ( openableelementinfo ) parent . getelementinfo ( ) ; info . removechild ( child ) ; } catch ( javamodelexception e ) { } } }	removes the given element from its parents cache of children.
public void removeallupdatelisteners ( ) { if ( mupdatelisteners == null ) { return ; } mupdatelisteners . clear ( ) ; mupdatelisteners = null ; }	removes all listeners from the set listening to frame updates for this animation .
public void executeplan ( taskcompleter completer , string successmessage , workflowcallbackhandler callbackhandler , object [ ] callbackhandlerargs , workflowrollbackhandler rollbackhandler , object [ ] rollbackhandlerargs ) throws workflowexception { this . _callbackhandler = callbackhandler ; if ( callbackhandlerargs != null ) { this . _callbackhandlerargs = callbackhandlerargs . clone ( ) ; } this . _rollbackhandler = rollbackhandler ; if ( rollbackhandlerargs != null ) { this . _rollbackhandlerargs = rollbackhandlerargs . clone ( ) ; } this . _taskcompleter = completer ; this . _successmessage = successmessage ; _service . executeplan ( this ) ; }	invokes the workflowplanexecutor to execute this workflow plan .
private osinfo ( ) { }	not meant to instantiate .
public boolean ismutable ( ) { return mutable ; }	checks if the object is mutable.
public void handlerequest ( requestcontext rc ) throws cliexception { super . handlerequest ( rc ) ; ldaplogin ( ) ; string servicename = getstringoptionvalue ( iargument . service_name ) ; string subconfigname = getstringoptionvalue ( iargument . sub_configuration_name ) ; string realmname = getstringoptionvalue ( iargument . realm_name ) ; if ( ( realmname == null ) || ( realmname . length ( ) == _num ) ) { deletesubconfigtoroot ( servicename , subconfigname ) ; } else { deletesubconfigfromrealm ( realmname , servicename , subconfigname ) ; } }	services a commandline request .
public void enforcecontext ( resource ... contexts ) { openrdfutil . verifycontextnotnull ( contexts ) ; this . contexts = arrays . copyof ( contexts , contexts . length ) ; }	enforces the supplied contexts upon all statements that are reported to this rdfinserter .
protected void runupload ( integer numofthreads , hashmap < string , string > attributes , boolean createnewversion , boolean force ) throws exception { runupload ( numofthreads , attributes , createnewversion , force , null , null ) ; }	runs a normal upload scenario .
public final collection < component > components ( ) { return new hashset < > ( components . values ( ) ) ; }	gets a set of components that this componentprovider provides .
protected boolean [ ] canpredict ( boolean nominalpredictor , boolean numericpredictor , boolean stringpredictor , boolean datepredictor , boolean relationalpredictor , boolean multiinstance , int classtype ) { print ( _str ) ; printattributesummary ( nominalpredictor , numericpredictor , stringpredictor , datepredictor , relationalpredictor , multiinstance , classtype ) ; print ( _str ) ; arraylist < string > accepts = new arraylist < string > ( ) ; accepts . add ( _str ) ; accepts . add ( _str ) ; accepts . add ( _str ) ; accepts . add ( _str ) ; accepts . add ( _str ) ; accepts . add ( _str ) ; accepts . add ( _str ) ; accepts . add ( _str ) ; accepts . add ( _str ) ; int numtrain = getnuminstances ( ) , numclasses = _num , missinglevel = _num ; boolean predictormissing = _bool , classmissing = _bool ; return runbasictest ( nominalpredictor , numericpredictor , stringpredictor , datepredictor , relationalpredictor , multiinstance , classtype , missinglevel , predictormissing , classmissing , numtrain , numclasses , accepts ) ; }	checks basic prediction of the scheme , for simple non - troublesome datasets .
public void test_historyindexdisabled ( ) throws sailexception { final properties properties = getproperties ( ) ; properties . setproperty ( com . bigdata . rdf . store . abstracttriplestore . options . history_service , _str ) ; final bigdatasail sail = getsail ( properties ) ; try { sail . initialize ( ) ; final bigdatasailconnection conn = sail . getconnection ( ) ; try { final iindex ndx = gethistoryindex ( conn . gettriplestore ( ) ) ; assertnull ( ndx ) ; conn . rollback ( ) ; } finally { conn . close ( ) ; } } finally { sail . __teardownunittest ( ) ; } }	unit test verifies that the history index is not created if the option is not enabled .
public void collapse ( ) { collapse ( _bool ) ; }	collapses all expanded items.
public int numinstances ( ) { return m_instances . size ( ) ; }	returns the number of instances in the dataset .
@ override public void startdocument ( xmllocator locator , string encoding , namespacecontext namespacecontext , augmentations augs ) throws xniexception { fnamespacecontext = namespacecontext ; try { if ( fdocumenthandler != null ) { if ( locator != null ) { fdocumenthandler . setdocumentlocator ( new locatorproxy ( locator ) ) ; } if ( fdocumenthandler != null ) { fdocumenthandler . startdocument ( ) ; } } if ( fcontenthandler != null ) { if ( locator != null ) { fcontenthandler . setdocumentlocator ( new locatorproxy ( locator ) ) ; } if ( fcontenthandler != null ) { fcontenthandler . startdocument ( ) ; } } } catch ( saxexception e ) { throw new xniexception ( e ) ; } }	the start of the document .
public static double parsenumberpercentwithseparaterange ( fxgnode node , string value , string name , double minnumber , double maxnumber , double minpercent , double maxpercent , double defaultvalue ) { if ( value . length ( ) != _num && value . charat ( value . length ( ) - _num ) == _str ) { string doublevalue = value . substring ( _num , value . length ( ) - _num ) ; try { return parsedouble ( node , doublevalue , name , minpercent , maxpercent , defaultvalue ) ; } catch ( fxgexception e ) { throw new fxgexception ( node . getstartline ( ) , node . getstartcolumn ( ) , _str , name , value ) ; } } else { return parsedouble ( node , value , name , minnumber , maxnumber , defaultvalue ) ; } }	convert an fxg string value to a double after taking care of the % sign.
private void checkdownloadcanproceed ( ) throws stoprequestexception { if ( clock . intervallessthan ( clock . interval . one_second ) ) { return ; } clock . startinterval ( ) ; checkispausedorcanceled ( ) ; checkclientrules ( ) ; }	check if the download has been paused or canceled , stopping the request appropriately if it has been .
private void deleteevent ( eventregkeyexpiration regexpiration , eventreg reg ) { listeners . dec ( ) ; synchronized ( reg ) { entryrep [ ] tmpls = reg . tmpl . attributesettemplates ; if ( tmpls != null ) { for ( int i = tmpls . length ; -- i >= _num ; ) { entryclass eclass = tmpls [ i ] . eclass ; eclass . setnumtemplates ( eclass . getnumtemplates ( ) - _num ) ; } } long id = reg . eventid ; eventbyid . remove ( id ) ; if ( regexpiration != null ) { eventbytime . remove ( regexpiration ) ; } else { eventbytime . remove ( new eventregkeyexpiration ( reg , reg . leaseexpiration ) ) ; } if ( reg . tmpl . serviceid != null ) { object val = subeventbyservice . get ( reg . tmpl . serviceid ) ; if ( val == reg ) { subeventbyservice . remove ( reg . tmpl . serviceid ) ; } else { object [ ] array = ( eventreg [ ] ) val ; array = arraydel ( array , indexof ( array , reg ) ) ; if ( array . length == _num ) val = array [ _num ] ; else val = array ; subeventbyservice . put ( reg . tmpl . serviceid , val ) ; } } else { subeventbyid . remove ( id ) ; } computemaxleases ( ) ; } }	remove an event registration from our state.
public string gtidset ( ) { return this . gtidset != null ? this . gtidset : null ; }	get the string representation of the gtid range for the mysql binary log file .
public static peer createmappeer ( map map ) throws messageexception { if ( ! map . containskey ( port ) || ! map . containskey ( address ) ) throw new messageexception ( _str ) ; int port = ( int ) ( long ) map . get ( port ) ; string address = ( string ) map . get ( address ) ; string peerid = null ; if ( map . containskey ( peer_id ) ) peerid = ( string ) map . get ( peer_id ) ; return new peer ( peerid , new inetsocketaddress ( address , port ) ) ; }	create a peer from a map .
private static int countgapsdashdotstar ( string sequence ) { int count = _num ; for ( int i = _num ; i < sequence . length ( ) ; i ++ ) { int a = sequence . charat ( i ) ; if ( a == _str || a == _str || a == _str ) count ++ ; } return count ; }	count the number of gaps ( ' - ' , ' . ' , ' * ' ) in a sequence.
public static void putdoublefield ( object obj , long fieldoff , double val ) { unsafe . putdouble ( obj , fieldoff , val ) ; }	stores double value into object field .
public string tooidstring ( ) { if ( soid == null ) { soid = _str + tostring ( ) ; } return soid ; }	add " oid . " to the beginning of string representation .
public void emitdirect ( int taskid , string streamid , tuple anchor , list < object > tuple ) { emitdirect ( taskid , streamid , arrays . aslist ( anchor ) , tuple ) ; }	emits a tuple directly to the specified task id on the specified stream.
protected void loadvalue ( string svalue ) { svalue = svalue . trim ( ) ; try { int r = integer . parseint ( svalue . substring ( _num , _num ) , _num ) ; int g = integer . parseint ( svalue . substring ( _num , _num ) , _num ) ; int b = integer . parseint ( svalue . substring ( _num , _num ) , _num ) ; value = new color ( r , g , b ) ; } catch ( numberformatexception nfe ) { reverttodefault ( ) ; } catch ( stringindexoutofboundsexception sioobe ) { reverttodefault ( ) ; } }	returns the value of this setting .
public void schemachanged ( string servicename , string version ) { updatestatus ( ) ; }	update the controller classes if the administration console service attributes is altered .
public kcresponse serve ( string uri , string method , properties header , properties parms , properties files ) { return servefile ( uri , header , myrootdir , _bool ) ; }	override this to customize the server.
protected void fillmemdata ( object data , int [ ] posits , int length , object output , int outputoffset , int dim ) { if ( data instanceof object [ ] ) { object [ ] xo = ( object [ ] ) data ; fillmemdata ( xo [ posits [ dim ] ] , posits , length , output , outputoffset , dim + _num ) ; } else { int startfrom = posits [ dim ] ; int startto = outputoffset ; int copylength = length ; if ( posits [ dim ] < _num ) { startfrom -= posits [ dim ] ; startto -= posits [ dim ] ; copylength += posits [ dim ] ; } if ( posits [ dim ] + length > this . dims [ dim ] ) { copylength -= posits [ dim ] + length - this . dims [ dim ] ; } system . arraycopy ( data , startfrom , output , startto , copylength ) ; } }	fill a single segment from memory.
public optional < string > startasyncjob ( string jobtype ) { try { final jobrunnable jobrunnable = findjobrunnable ( jobtype ) ; jobinfo jobinfo = createjobinfo ( jobtype ) ; repository . markjobasrunningifpossible ( jobinfo , mutexjobtypesfor ( jobtype ) ) ; repository . createorupdate ( jobinfo ) ; return optional . of ( startasync ( metered ( jobrunnable ) , jobinfo . getjobid ( ) ) ) ; } catch ( jobblockedexception e ) { log . info ( e . getmessage ( ) ) ; return optional . empty ( ) ; } }	starts a job asynchronously in the background .
public boolean islegalreplacement ( byte [ ] replacement ) { if ( decoder == null ) { decoder = charset . newdecoder ( ) ; decoder . onmalformedinput ( codingerroraction . report ) ; decoder . onunmappablecharacter ( codingerroraction . report ) ; } bytebuffer in = bytebuffer . wrap ( replacement ) ; charbuffer out = charbuffer . allocate ( ( int ) ( replacement . length * decoder . maxcharsperbyte ( ) ) ) ; coderresult result = decoder . decode ( in , out , _bool ) ; return ! result . iserror ( ) ; }	tests whether the given argument is legal as this encoder ' s replacement byte array.
public static void adapttable ( constrainttablelayout table ) { int width = table . getwidth ( ) ; int height = table . getheight ( ) ; constraintwidget . dimensionbehaviour horizontalbehaviour = table . gethorizontaldimensionbehaviour ( ) ; constraintwidget . dimensionbehaviour verticalbehaviour = table . getverticaldimensionbehaviour ( ) ; table . sethorizontaldimensionbehaviour ( constraintwidget . dimensionbehaviour . wrap_content ) ; table . setverticaldimensionbehaviour ( constraintwidget . dimensionbehaviour . wrap_content ) ; table . layout ( ) ; table . layout ( ) ; table . setminwidth ( table . getwidth ( ) ) ; table . setminheight ( table . getheight ( ) ) ; table . computeguidelinespercentpositions ( ) ; table . sethorizontaldimensionbehaviour ( horizontalbehaviour ) ; table . setverticaldimensionbehaviour ( verticalbehaviour ) ; table . setwidth ( width < table . getminwidth ( ) ? table . getminwidth ( ) : width ) ; table . setheight ( height < table . getminheight ( ) ? table . getminheight ( ) : height ) ; table . layout ( ) ; }	adapt the table ' s dimensions and columns or rows to its content.
public static < v , c extends collection < ? super v > > c addall ( c c , v ... vals ) { collections . addall ( c , vals ) ; return c ; }	adds values to collection and returns the same collection to allow chaining .
public static void addstrut ( jcomponent b , int layout , int size ) { if ( size < _num ) return ; b . add ( getaxis ( b , layout ) == boxlayout . x_axis ? box . createhorizontalstrut ( size ) : box . createverticalstrut ( size ) ) ; }	add a strut , or rigid spacing , to a ui component.
public void elementtype ( string name , int model , int memberof , int flags ) { elementtype e = new elementtype ( name , model , memberof , flags , this ) ; theelementtypes . put ( name . tolowercase ( ) , e ) ; if ( memberof == m_root ) theroot = e ; }	add or replace an element type for this schema .
public int arrayindexscale ( class clazz ) { if ( ! clazz . isarray ( ) ) { throw new illegalargumentexception ( _str ) ; } return arrayindexscale0 ( clazz ) ; }	gets the size of each element of the given array class .
public string strrep ( ) { return _str + rankteampollscore + _str + abbr + _str + wins + _str + losses + _str ; }	str rep of team , no bowl results.
@ override public string tostring ( ) { if ( eisproxy ( ) ) return super . tostring ( ) ; stringbuffer result = new stringbuffer ( super . tostring ( ) ) ; result . append ( _str ) ; result . append ( kind ) ; result . append ( _str ) ; return result . tostring ( ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
private void recordrpoperation ( dbclient dbclient , operationtypeenum optype , operation . status status , object ... extparam ) { try { boolean opstatus = ( operation . status . ready == status ) ? _bool : _bool ; string evtype ; evtype = optype . getevtype ( opstatus ) ; string evdesc = optype . getdescription ( ) ; string opstage = auditlogmanager . auditop_end ; _log . info ( _str , optype . tostring ( ) , evtype . tostring ( ) + _str + evdesc ) ; recordbournerpevent ( dbclient , getid ( ) , evtype , status , evdesc ) ; switch ( optype ) { case start_rp_link : case stop_rp_link : case pause_rp_link : case resume_rp_link : case failover_rp_link : case failover_cancel_rp_link : case change_rp_image_access_mode : case swap_rp_volume : auditblockutil . auditblock ( dbclient , optype , opstatus , opstage , extparam ) ; break ; default : _log . error ( _str ) ; } } catch ( exception e ) { _log . error ( _str , optype . tostring ( ) , e ) ; } }	record block volume related event and audit.
void autoclosingclipopened ( autoclosingclip clip ) { if ( printer . debug ) printer . debug ( _str ) ; int index = _num ; synchronized ( autoclosingclips ) { index = getautoclosingclipindex ( clip ) ; if ( index == - _num ) { if ( printer . debug ) printer . debug ( _str + clip ) ; autoclosingclips . add ( new clipinfo ( clip ) ) ; } } if ( index == - _num ) { synchronized ( this ) { notifyall ( ) ; } } if ( printer . debug ) printer . debug ( _str + autoclosingclips . size ( ) + _str ) ; }	called from auto - closing clips when one of their open ( ) method is called.
public boolean implies ( permission permission ) { if ( ! ( permission instanceof execoptionpermission ) ) return _bool ; execoptionpermission p = ( execoptionpermission ) permission ; if ( all_allowed ) return _bool ; string pname = p . getname ( ) ; permission x = permissions . get ( pname ) ; if ( x != null ) return x . implies ( permission ) ; int last , offset ; offset = pname . length ( ) - _num ; while ( ( last = pname . lastindexof ( _str , offset ) ) != - _num ) { pname = pname . substring ( _num , last + _num ) + _str ; x = permissions . get ( pname ) ; if ( x != null ) { return x . implies ( permission ) ; } offset = last - _num ; } pname = p . getname ( ) ; offset = pname . length ( ) - _num ; while ( ( last = pname . lastindexof ( _str , offset ) ) != - _num ) { pname = pname . substring ( _num , last + _num ) + _str ; x = permissions . get ( pname ) ; if ( x != null ) { return x . implies ( permission ) ; } offset = last - _num ; } return _bool ; }	check and see if this set of permissions implies the permissions expressed in " permission " .
private static byte [ ] save ( bitmap src , bitmap . compressformat format , int quality ) { bytearrayoutputstream outputstream = null ; try { outputstream = new bytearrayoutputstream ( ) ; src . compress ( format , quality , outputstream ) ; return outputstream . tobytearray ( ) ; } finally { if ( outputstream != null ) { try { outputstream . close ( ) ; } catch ( ioexception e1 ) { e1 . printstacktrace ( ) ; } } } }	saving image to byte array.
public boolean isexternal ( resource input ) { return externalresources . contains ( input ) ; }	tell if it is an external source .
protected final void writed ( bytebuffer buf , int value ) { buf . putint ( value ) ; }	write int to buffer .
public list < shoppingcartitem > items ( ) { list < shoppingcartitem > result = fastlist . newinstance ( ) ; result . addall ( cartlines ) ; return result ; }	returns a collection of items in the cart object .
mutablebiginteger ( biginteger b ) { intlen = b . mag . length ; value = arrays . copyof ( b . mag , intlen ) ; }	construct a new mutablebiginteger with a magnitude equal to the specified biginteger .
public boolean ishttp11 ( ) { if ( mversion . equalsignorecase ( http11 ) ) { return _bool ; } return _bool ; }	check if this header is http 1.
protected void deleteicon ( ) { if ( _selectedicon == null ) { return ; } if ( _iconmap . remove ( _selectedicon . getname ( ) ) != null ) { removeiconfamiliespanel ( ) ; addiconstopanel ( _iconmap ) ; deleteiconbutton . setenabled ( _bool ) ; validate ( ) ; } }	action item for initbuttonpanel.
public boolean equals ( object obj ) { if ( obj == null ) return _bool ; if ( this == obj ) return _bool ; if ( getclass ( ) != obj . getclass ( ) ) return _bool ; choiceformat other = ( choiceformat ) obj ; return ( arrays . equals ( choicelimits , other . choicelimits ) && arrays . equals ( choiceformats , other . choiceformats ) ) ; }	equality comparision between two.
public static date updated ( date self , map < object , integer > updates ) { calendar cal = calendar . getinstance ( ) ; cal . settime ( self ) ; set ( cal , updates ) ; return cal . gettime ( ) ; }	legacy alias for copywith.
public boolean displaytopic ( string name ) { string topic = null ; if ( name == null ) topic = default + file_type ; else topic = name . tolowercase ( ) + file_type ; file helpfile = new file ( helpdir , topic ) ; return display ( helpfile ) ; }	display help for a topic.
private void dashtowords ( string tokenval ) { int index = tokenval . indexof ( _str ) ; string aaa = tokenval . substring ( _num , index ) ; string bbb = tokenval . substring ( index + _num , tokenval . length ( ) ) ; if ( matches ( digitspattern , aaa ) && matches ( digitspattern , bbb ) ) { featureset featureset = tokenitem . getfeatures ( ) ; featureset . setstring ( _str , aaa ) ; tokentowords ( aaa ) ; wordrelation . addword ( _str ) ; featureset . setstring ( _str , bbb ) ; tokentowords ( bbb ) ; featureset . setstring ( _str , _str ) ; } else { tokentowords ( aaa ) ; tokentowords ( bbb ) ; } }	convert the given dashed string ( e.
public static int numberoftrailingzerossigned ( long [ ] v ) { for ( int p = _num ; ; p ++ ) { if ( p == v . length ) { return - _num ; } if ( v [ p ] != _num ) { return long . numberoftrailingzeros ( v [ p ] ) + p * long . size ; } } }	find the number of trailing zeros .
public static void applywmrule ( collection < mwminoutbound > lines , string boundtype ) { for ( mwminoutbound line : lines ) { for ( mwmdefinition definition : mwmdefinition . getall ( line . getctx ( ) , line . get_trxname ( ) ) ) { wmruleengine . validatedefinition ( line , definition , boundtype ) ; } } }	apply the wm rule by bound type.
public static float readfloat ( final jsonarray jsonarray , final int index , final boolean required , final boolean notnull ) throws jsonexception { if ( required ) { return ( float ) jsonarray . getdouble ( index ) ; } if ( notnull && jsonarray . isnull ( index ) ) { throw new jsonexception ( string . format ( locale . us , null_value_format_array , index ) ) ; } float value = _num ; if ( ! jsonarray . isnull ( index ) ) { value = ( float ) jsonarray . getdouble ( index ) ; } return value ; }	reads the float value from the json array for specified index.
public void flush ( ) throws ioexception { flushbits ( ) ; out . flush ( ) ; }	description of the method.
public final flux < t > onerrorresumewith ( predicate < ? super throwable > predicate , function < ? super throwable , ? extends publisher < ? extends t > > fallback ) { objects . requirenonnull ( predicate , _str ) ; return onerrorresumewith ( null ) ; }	subscribe to a returned fallback publisher when an error matching the given type occurs.
@ override public enumeration < option > listoptions ( ) { vector < option > result = new vector < option > ( ) ; result . addelement ( new option ( _str , _str , _num , _str ) ) ; result . addall ( collections . list ( super . listoptions ( ) ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
public @ test final void testsetusersnegative ( ) { role role = new role ( test_role ) ; thrown . expect ( illegalargumentexception . class ) ; role . setusers ( null ) ; }	setting the list of grants to null is not allowed .
private set < string > findresourcenames ( string path , string prefix , string suffix ) throws ioexception { set < string > resourcenames = findresourcenamesfromfilesystem ( path , new file ( path ) ) ; return filterresourcenames ( resourcenames , prefix , suffix ) ; }	finds the resources names present at this location and below on the classpath starting with this prefix and ending with this suffix .
public boolean add ( k key , v item ) { set < v > values = map . get ( key ) ; if ( values == null ) { values = ( sorted ? new treeset < v > ( ) : new hashset < v > ( ) ) ; map . put ( key , values ) ; } if ( item == null ) return _bool ; return values . add ( item ) ; }	adds item to the set of values associated with the key ( null items are not added ).
public void addecm ( ecminfo info ) { ecmeffects . add ( info ) ; }	added another ecminfo to the effects for a location .
protected void loadimage ( string filepath , omgraphiclist ret ) { file file = new file ( filepath ) ; if ( file . exists ( ) && file . isdirectory ( ) ) { string [ ] files = file . list ( ) ; for ( int i = _num ; i < files . length ; i ++ ) { loadimage ( filepath + _str + files [ i ] , ret ) ; } } else { firestatusupdate ( layerstatusevent . start_working ) ; try { url fileurl = proputils . getresourceorfileorurl ( filepath ) ; if ( fileurl != null ) { if ( imagereaderloaders != null ) { imagetile imagetile = null ; for ( imagereaderloader idl : imagereaderloaders ) { if ( idl . isloadable ( filepath ) ) { imagereader id = idl . getimagereader ( fileurl ) ; imagetile tmpimagetile = id . getimagetile ( imagecache ) ; if ( imagetile == null ) { imagetile = tmpimagetile ; } else if ( tmpimagetile != null && imagetile instanceof errimagetile ) { imagetile = tmpimagetile ; } if ( imagetile != null && ! ( imagetile instanceof errimagetile ) ) { break ; } } } if ( imagetile != null ) { addimagetolists ( imagetile , ret , fileurl ) ; } } else { logger . warning ( _str + getname ( ) + _str ) ; } } else { logger . warning ( _str + filepath ) ; } } catch ( malformedurlexception murle ) { } } }	if filepath is a file , the imagereaderloaders are used to try to load and place the image.
@ override protected final boolean writedata ( bytebuffer data ) { synchronized ( guard ) { gsserverpacket packet = sendmsgqueue . pollfirst ( ) ; if ( packet == null ) { return _bool ; } packet . write ( this , data ) ; return _bool ; } }	this method will be called by dispatcher , and will be repeated till return false .
public static exportmask createexportmask ( dbclient dbclient , exportgroup exportgroup , uri sduri , string maskname ) throws databaseexception { exportmask exportmask = new exportmask ( ) ; exportmask . setid ( uriutil . createid ( exportmask . class ) ) ; exportmask . setmaskname ( maskname ) ; exportmask . setstoragedevice ( sduri ) ; dbclient . createobject ( exportmask ) ; exportgroup . addexportmask ( exportmask . getid ( ) ) ; dbclient . updateobject ( exportgroup ) ; return exportmask ; }	create an export mask object.
public logentry ( string timestamp , string contents ) { this . timestamp = timestamp ; this . contents = contents ; }	creates a new log entry with the given timestamp and contents.
public static boolean cancelpotentialwork ( object data , imageview imageview ) { final bitmapworkertask bitmapworkertask = getbitmapworkertask ( imageview ) ; if ( bitmapworkertask != null ) { final object bitmapdata = bitmapworkertask . mdata ; if ( bitmapdata == null || ! bitmapdata . equals ( data ) ) { bitmapworkertask . cancel ( _bool ) ; if ( buildconfig . debug ) { log . d ( tag , _str + data ) ; } } else { return _bool ; } } return _bool ; }	returns true if the current work has been canceled or if there was no work in progress on this image view.
void replacepolicyinresourcetree ( policy oldpolicy , policy newpolicy ) throws policyexception , ssoexception { removepolicyfromresourcetree ( oldpolicy ) ; addpolicytoresourcetree ( newpolicy ) ; }	replaces resource names of a policy in the resource tree .
public oidctokens acquiretokensbysecurid ( string username , string passcode , securidretriever securidretriever , tokenspec tokenspec ) throws oidcclientexception , oidcserverexception , tokenvalidationexception , sslconnectionexception { validate . notempty ( username , _str ) ; validate . notempty ( passcode , _str ) ; validate . notnull ( securidretriever , _str ) ; validate . notnull ( tokenspec , _str ) ; httpresponse httpresponse = oidcclientutils . handlesecuridmultileggedgrant ( username , passcode , securidretriever , tokenspec , gettokenendpointuri ( ) , this . clientid , this . holderofkeyconfig , this . keystore ) ; return oidcclientutils . parsetokenresponse ( httpresponse , this . providerpublickey , this . issuer , this . clientid , this . clocktoleranceinseconds ) ; }	get tokens by securidretriever which handles multi - legged securidgrant.
public void loadnested ( environment env ) { loadnested ( env , _num ) ; }	called when an environment ties a binary definition to a declaration.
private promise < actionresponse , resourceexception > internalhandleaction ( string tokenid , context context , actionrequest request ) { final string action = request . getaction ( ) ; final actionhandler actionhandler = actionhandlers . get ( action ) ; if ( actionhandler != null ) { return actionhandler . handle ( tokenid , context , request ) ; } else { string message = string . format ( _str , action ) ; notsupportedexception e = new notsupportedexception ( message ) ; if ( logger . messageenabled ( ) ) { logger . message ( _str + message , e ) ; } return e . aspromise ( ) ; } }	handle the action specified by the user ( i.
public int compareto ( object obj ) { int diff = - _num ; if ( obj instanceof parsernotice ) { parsernotice p2 = ( parsernotice ) obj ; diff = level - p2 . getlevel ( ) ; if ( diff == _num ) { diff = line - p2 . getline ( ) ; if ( diff == _num ) { diff = message . compareto ( p2 . getmessage ( ) ) ; } } } return diff ; }	compares this parser notice to another .
protected abstract map < integer , filteroperationdelegateinvoker > dogetinvokerlookup ( ) ;	responsible for returning a lookup map of operation code to invoker .
public static void deletecollection ( string host , string collection ) throws exception { string deletecollectiontemplate = _str ; string deletecollectioncommand = string . format ( deletecollectiontemplate , host , default_solr_port , collection ) ; executesolrcommand ( deletecollectioncommand ) ; }	given a collection name , it deletes it.
private iterable < fragmentconstructor > createconstructors ( ) { return collections . unmodifiablelist ( arrays . aslist ( new biomedataconstructor ( resolution . quarter ) , new endislandsconstructor ( ) , new imageconstructor ( resolution . quarter , layerids . background ) , new imageconstructor ( resolution . chunk , layerids . slime ) ) ) ; }	this also defines the construction order .
@ nullable public static hkey psikey ( @ notnull psimethod psimethod , @ notnull direction direction , @ notnull messagedigest md ) { final psiclass psiclass = psitreeutil . getparentoftype ( psimethod , psiclass . class , _bool ) ; if ( psiclass == null ) { return null ; } byte [ ] classdigest = psiclassdigest ( psiclass , md ) ; if ( classdigest == null ) { return null ; } byte [ ] sigdigest = methoddigest ( psimethod , md ) ; if ( sigdigest == null ) { return null ; } byte [ ] digest = new byte [ hash_size ] ; system . arraycopy ( classdigest , _num , digest , _num , class_hash_size ) ; system . arraycopy ( sigdigest , _num , digest , class_hash_size , signature_hash_size ) ; return new hkey ( digest , mkdirectionkey ( direction ) , _bool ) ; }	converts a psi method to a small hash key ( hkey ).
public static boolean issdcardmounted ( ) { string status = environment . getexternalstoragestate ( ) ; if ( status . equals ( environment . media_mounted ) ) return _bool ; return _bool ; }	checks if the sd card is mounted on the device .
private void parseresource ( final element resourceelement , final collection < resource > resources ) { final string tagname = resourceelement . gettagname ( ) ; final string uri = resourceelement . gettextcontent ( ) ; if ( tag_group_ref . equals ( tagname ) ) { resources . addall ( getresourcesforgroup ( uri ) ) ; } if ( getresourcetype ( resourceelement ) != null ) { final resource resource = createresource ( resourceelement ) ; log . debug ( _str , resource ) ; resources . add ( resource ) ; } }	creates a resource from a given resourceelement.
@ override public void licencefile ( string texttoshow , file licencefile ) throws cancelexception { try { final fileinputstream content = new fileinputstream ( licencefile ) ; final stringwriter writer = new stringwriter ( ) ; ioutils . copy ( content , writer , _str ) ; content . close ( ) ; licence ( texttoshow , writer . tostring ( ) ) ; } catch ( ioexception e ) { throw new scriptfailureexception ( _str , e ) ; } }	show the content of a licence file.
public int meanallocation ( ) { if ( m_slotallocations == _num ) return _num ; return ( int ) ( m_sizeallocations / m_slotallocations ) ; }	meanallocation : ( total application bytes used across all allocations for this slot size ) / slotsallocated.
@ override public string tostring ( ) { return messageformat . format ( _str + _str + _str , getldapfilter ( ) , stringutils . join ( requestedattributes , _str ) ) ; }	presents the querybuilder in a human readable format.
public void testcase6 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = _num ; int bsign = - _num ; byte rbytes [ ] = { - _num , - _num , - _num , _num , - _num , - _num , - _num , - _num , _num , - _num , - _num , - _num , _num , - _num , _num , _num , _num , - _num , - _num , _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . multiply ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , result . signum ( ) ) ; }	multiply two numbers of different length and different signs.
public void animateprogressfill ( int animateto ) { manimationhandler . removemessages ( _num ) ; if ( animateto > mmax || animateto < _num ) { throw new illegalargumentexception ( string . format ( _str , animateto , mmax ) ) ; } manimationhandler . setanimateto ( animateto ) ; manimationhandler . sendemptymessage ( _num ) ; invalidate ( ) ; }	animates a progress fill of the view , using a handler .
static boolean isregistered ( objectname objectname ) { set < objectname > registeredobjectnames = mbeanserver . querynames ( objectname , null ) ; return ! registeredobjectnames . isempty ( ) ; }	checks whether an objectname is already registered .
public < t > pushablelazyfuturestream < t > futurestream ( final lazyreact s ) { final queue < t > q = createqueue ( ) ; return new pushablelazyfuturestream < t > ( q , s . fromstream ( q . stream ( ) ) ) ; }	create a pushable lazyfuturestream using the supplied reactpool.
public byte [ ] converthexstringtobinary ( string hexstring ) throws illegalargumentexception { int length = hexstring . length ( ) ; if ( length % _num != _num ) { throw new illegalargumentexception ( _str + length + _str + hexstring ) ; } byte [ ] binary = new byte [ length / _num ] ; for ( int i = _num ; i < length ; i += _num ) { char highbitschar = hexstring . charat ( i ) ; char lowbitschar = hexstring . charat ( i + _num ) ; int highbits = hexchartoint ( highbitschar , hexstring ) << _num ; int lowbits = hexchartoint ( lowbitschar , hexstring ) ; binary [ i / _num ] = ( byte ) ( highbits + lowbits ) ; } return binary ; }	convert the provided hex - string into a binary representation where each byte represents two characters of the hex string.
public void writefield ( final string name , final short value ) throws java . io . ioexception { writefield ( name , short . tostring ( value ) ) ; }	writes an short field value .
public static resultset select ( connection conn , string sql ) throws sqlexception { statement stat = conn . createstatement ( resultset . type_scroll_insensitive , resultset . concur_read_only ) ; return stat . executequery ( sql ) ; }	this method is called via reflection from the database .
public static void writesetoflongs ( set set , boolean haslongids , dataoutput out ) throws ioexception { if ( set == null ) { out . writeint ( - _num ) ; } else { out . writeint ( set . size ( ) ) ; out . writeboolean ( haslongids ) ; for ( iterator it = set . iterator ( ) ; it . hasnext ( ) ; ) { long l = ( long ) it . next ( ) ; if ( haslongids ) { out . writelong ( l . longvalue ( ) ) ; } else { out . writeint ( ( int ) l . longvalue ( ) ) ; } } } }	write a set of long objects.
private void restorewidget ( key key , byte [ ] buffer , int datasize ) throws ioexception { if ( verbose ) log . v ( tag , _str + key . id ) ; if ( debug ) log . d ( tag , _str + buffer . length + _str + base64 . encodetostring ( buffer , _num , datasize , base64 . no_wrap ) ) ; widget widget = unpackproto ( new widget ( ) , buffer , datasize ) ; if ( debug ) log . d ( tag , _str + widget . provider ) ; if ( widget . icon . data != null ) { bitmap icon = bitmapfactory . decodebytearray ( widget . icon . data , _num , widget . icon . data . length ) ; if ( icon == null ) { log . w ( tag , _str + key . name ) ; } else { miconcache . preloadicon ( componentname . unflattenfromstring ( widget . provider ) , icon , widget . icon . dpi , widget . label , muserserial , midp ) ; } } widgetsizes . add ( widget . provider + _str + _num + _str + _num ) ; }	read a widget from the stream.
public void considerregionxregion ( georegion r , georegion region ) { geoarray rboundary = r . getpoints ( ) ; geo rpoint = rboundary . get ( _num , new geo ( ) ) ; geoarray regionboundary = region . getpoints ( ) ; geo regionpoint = regionboundary . get ( _num , new geo ( ) ) ; if ( intersection . ispointinpolygon ( rpoint , regionboundary ) || intersection . ispointinpolygon ( regionpoint , rboundary ) ) { collector . collect ( r , region ) ; } else { for ( geopath . segmentiterator pit = r . segmentiterator ( ) ; pit . hasnext ( ) ; ) { geosegment seg = pit . nextsegment ( ) ; if ( filter . preconsider ( seg , region ) && considersegmentxregion ( seg , region ) ) { collector . collect ( seg , region ) ; return ; } } } }	puts the region in the collector if r intersects with it .
private char foldcase ( char ch ) { if ( ch < _num ) { if ( _str <= ch && ch <= _str ) { return ( char ) ( ch + ( _str - _str ) ) ; } return ch ; } return character . tolowercase ( character . touppercase ( ch ) ) ; }	this isn ' t equivalent to either of icu ' s u_foldcase case folds , and thus any of the unicode case folds , but it ' s what the ri uses .
public writableraster createcompatiblewritableraster ( int w , int h ) { if ( w <= _num || h <= _num ) { throw new rasterformatexception ( _str + ( ( w <= _num ) ? _str : _str ) ) ; } samplemodel sm = samplemodel . createcompatiblesamplemodel ( w , h ) ; return new bytebandedraster ( sm , new point ( _num , _num ) ) ; }	creates a raster with the same layout but using a different width and height , and with new zeroed data arrays .
@ targetapi ( version_codes . lollipop ) public static void reveal ( final view view , int cx , int cy ) { if ( ! haslollipop ( ) ) { view . setvisibility ( view . visible ) ; return ; } int finalradius = math . max ( view . getwidth ( ) , view . getheight ( ) ) ; animator animator = viewanimationutils . createcircularreveal ( view , cx , cy , _num , finalradius ) ; view . setvisibility ( view . visible ) ; animator . start ( ) ; }	create the reveal effect animation.
public topnmetric ( topnmetrictype type , string previousstop , sortdirection order ) { this ( type , previousstop ) ; if ( order == sortdirection . asc ) { this . type = topnmetrictype . inverted ; this . nested = optional . of ( new topnmetric ( type , previousstop ) ) ; this . previousstop = optional . empty ( ) ; } }	constructs a sort of the given type with a starting point and explicitly specifies the order ( ascending or descending ) .
public void removesupportedoptions ( set < string > unmatchedprocessoroptions ) { unmatchedprocessoroptions . removeall ( supportedoptionnames ) ; }	remove options that are matched by this processor .
protected void subscribe ( ) { if ( sampleclientsub == null ) { try { sampleclientsub = new sampleasynccallback ( url , clientidsub , cleansession , quietmode , username , password ) ; } catch ( mqttexception e ) { e . printstacktrace ( ) ; } } if ( sampleclientsub != null ) { string topic = _str ; int qos = _num ; try { sampleclientsub . subscribe ( topic , qos ) ; } catch ( throwable e ) { e . printstacktrace ( ) ; } } }	subscribe to a topic on an mqtt server once subscribed this method waits for the messages to arrive from the server that match the subscription . it continues listening for messages until pin 3 is pressed.
private boolean shouldcrop ( int width , int height ) { int pixelerror = _num ; pixelerror += math . round ( math . max ( width , height ) / _num ) ; return ( mmaxresultimagesizex > _num && mmaxresultimagesizey > _num ) || math . abs ( mcroprect . left - mcurrentimagerect . left ) > pixelerror || math . abs ( mcroprect . top - mcurrentimagerect . top ) > pixelerror || math . abs ( mcroprect . bottom - mcurrentimagerect . bottom ) > pixelerror || math . abs ( mcroprect . right - mcurrentimagerect . right ) > pixelerror ; }	check whether an image should be cropped at all or just file can be copied to the destination path.
public boolean exists ( ) { return doaccess ( f_ok ) ; }	returns a boolean indicating whether this file can be found on the underlying file system .
public shapetilebox bounding_box ( ) { if ( bounding_box != null ) return bounding_box ; plapointfloat start_corner = start_point_approx ( ) ; plapointfloat end_corner = end_point_approx ( ) ; double llx = math . min ( start_corner . v_x , end_corner . v_x ) ; double lly = math . min ( start_corner . v_y , end_corner . v_y ) ; double urx = math . max ( start_corner . v_x , end_corner . v_x ) ; double ury = math . max ( start_corner . v_y , end_corner . v_y ) ; plapointint lower_left = new plapointint ( math . floor ( llx ) , math . floor ( lly ) ) ; plapointint upper_right = new plapointint ( math . ceil ( urx ) , math . ceil ( ury ) ) ; bounding_box = new shapetilebox ( lower_left , upper_right ) ; return bounding_box ; }	calculates the smallest surrounding box of this line segmant.
public void testclasspathwar ( ) throws exception { final url url = new url ( _str + system . getproperty ( _str ) + _str ) ; final string expected = _str ; pingutils . assertpingtrue ( url . getpath ( ) + _str , expected , url , logger ) ; }	test changing of classpath with the websphere container .
protected abstract boolean isnullable ( ) ;	returns if this tuple can contain null elements .
public vec3 normalize ( ) { float x = this . m [ _num ] ; float y = this . m [ _num ] ; float z = this . m [ _num ] ; float s = _num / ( float ) math . sqrt ( x * x + y * y + z * z ) ; this . m [ _num ] = x * s ; this . m [ _num ] = y * s ; this . m [ _num ] = z * s ; return this ; }	\ brief this = normalize ( this ).
@ override public p readpage ( int pageid ) { try { countread ( ) ; long offset = ( ( long ) ( header . getreservedpages ( ) + pageid ) ) * ( long ) pagesize ; byte [ ] buffer = new byte [ pagesize ] ; file . seek ( offset ) ; file . read ( buffer ) ; return bytearraytopage ( buffer ) ; } catch ( ioexception e ) { throw new runtimeexception ( _str + pageid + _str , e ) ; } }	reads the page with the given id from this file .
public void addactionlistener ( actionlistener listener ) { forwardprojectionbutton . addactionlistener ( listener ) ; backprojectionbutton . addactionlistener ( listener ) ; }	adds a listener for events that shift the projection stack .
void writedatatofilelocked ( randomaccessfile file , boolean addmayo , boolean addtomato , int whichfilling ) throws ioexception { file . setlength ( _num ) ; file . writeint ( whichfilling ) ; file . writeboolean ( addmayo ) ; file . writeboolean ( addtomato ) ; log . v ( tag , _str + addmayo + _str + addtomato + _str + whichfilling ) ; }	handy helper routine to write the ui data to a file .
static type [ ] mapkeyandvaluetypes ( type context , class < ? > contextrawtype ) { if ( context == properties . class ) return new type [ ] { string . class , string . class } ; type maptype = getsupertype ( context , contextrawtype , map . class ) ; if ( maptype instanceof parameterizedtype ) { parameterizedtype mapparameterizedtype = ( parameterizedtype ) maptype ; return mapparameterizedtype . getactualtypearguments ( ) ; } return new type [ ] { object . class , object . class } ; }	returns a two element array containing this map ' s key and value types in positions 0 and 1 respectively .
static aggregatedhttpmessage of ( httpheaders headers , httpdata content , httpheaders trailingheaders ) { return of ( collections . emptylist ( ) , headers , content , trailingheaders ) ; }	creates a new http message .
public static boolean isletter ( char c ) { return character . isletter ( c ) ; }	returns true if character c is an english letter ( a.
protected list < treenode > createchildlist ( ) { branch branch = getxmlbranch ( ) ; int size = branch . nodecount ( ) ; list < treenode > childlist = new arraylist < treenode > ( size ) ; for ( int i = _num ; i < size ; i ++ ) { node node = branch . node ( i ) ; if ( node instanceof characterdata ) { string text = node . gettext ( ) ; if ( text == null ) { continue ; } text = text . trim ( ) ; if ( text . length ( ) <= _num ) { continue ; } } childlist . add ( createchildtreenode ( node ) ) ; } return childlist ; }	factory method to create list of children treenodes.
public set < value > mayaliases ( value v , unit u ) { set < value > res = new hashset < value > ( ) ; set < set < value > > flow = getflowbefore ( u ) ; for ( set < value > set : flow ) { if ( set . contains ( v ) ) res . addall ( set ) ; } return res ; }	returns all values that may - alias with v before u .
@ nullable private static string read ( @ nonnull socketchannel socket , @ nonnull byte [ ] buffer ) throws ioexception { bytebuffer buf = bytebuffer . wrap ( buffer , _num , buffer . length ) ; while ( buf . position ( ) != buf . limit ( ) ) { int count ; count = socket . read ( buf ) ; if ( count < _num ) { throw new ioexception ( _str ) ; } } try { return new string ( buffer , _num , buf . position ( ) , adbhelper . default_encoding ) ; } catch ( unsupportedencodingexception e ) { return null ; } }	fills a buffer by reading data from a socket .
public static datetimeunit createlocaldateunitinstance ( date date , org . hisp . dhis . calendar . calendar calendar ) { return calendar . fromiso ( datetimeunit . fromjdkdate ( date ) ) ; }	returns an instance of a dateunit .
public static boolean equal ( double a , double b ) { return ( math . abs ( a - b ) < epsilon ) ; }	returns if two double values are equal to within epsilon .
@ override public void addclassannotation ( char [ ] buffer , int offset , int length ) { string anntype = new string ( buffer , offset , length ) ; if ( _anntypes . contains ( anntype ) ) { addclass ( _classname ) ; } }	adds a class annotation.
static pathpart makeabsolute ( pathpart oldpart ) { @ suppresswarnings ( _str ) boolean encodedcached = oldpart . encoded != not_cached ; string oldpath = encodedcached ? oldpart . encoded : oldpart . decoded ; if ( oldpath == null || oldpath . length ( ) == _num || oldpath . startswith ( _str ) ) { return oldpart ; } string newencoded = encodedcached ? _str + oldpart . encoded : not_cached ; @ suppresswarnings ( _str ) boolean decodedcached = oldpart . decoded != not_cached ; string newdecoded = decodedcached ? _str + oldpart . decoded : not_cached ; return new pathpart ( newencoded , newdecoded ) ; }	prepends path values with " / " if they ' re present , not empty , and they don ' t already start with " / " .
public static int [ ] splitgt ( string gt ) { final int gtlen = gt . length ( ) ; if ( gtlen == _num ) { return new int [ ] { alleleid ( gt . charat ( _num ) ) } ; } else { int [ ] result = new int [ _num ] ; int ploid = _num ; int allelestart = _num ; for ( int i = _num ; i < gtlen ; i ++ ) { final char c = gt . charat ( i ) ; if ( c == phased_separator || c == unphased_separator ) { if ( ploid == result . length ) { result = arrays . copyof ( result , result . length + _num ) ; } result [ ploid ++ ] = alleleid ( gt , allelestart , i - allelestart ) ; allelestart = i + _num ; } } if ( allelestart < gtlen ) { if ( ploid == result . length ) { result = arrays . copyof ( result , result . length + _num ) ; } result [ ploid ++ ] = alleleid ( gt , allelestart , gtlen - allelestart ) ; } if ( ploid < result . length ) { result = arrays . copyof ( result , ploid ) ; } if ( ploid == _num ) { throw new numberformatexception ( _str + gt + _str ) ; } return result ; } }	utility method for splitting a vcf genotype subfield into an array of numeric allele identifiers .
public void testbug18041 ( ) throws exception { if ( versionmeetsminimum ( _num , _num ) ) { createtable ( _str , _str ) ; properties props = new properties ( ) ; props . setproperty ( _str , _str ) ; props . setproperty ( _str , _str ) ; connection truncconn = null ; preparedstatement stm = null ; try { truncconn = getconnectionwithprops ( props ) ; stm = truncconn . preparestatement ( _str ) ; stm . setint ( _num , _num ) ; stm . setstring ( _num , _str ) ; stm . executeupdate ( ) ; fail ( _str ) ; } catch ( datatruncation truncex ) { } finally { if ( truncconn != null ) { truncconn . close ( ) ; } } } }	tests fix for bug # 18041 - server - side prepared statements don ' t cause truncation exceptions to be thrown .
public void deletekernel ( string name ) { kernel kernel = getkernelbyname ( name ) ; if ( kernel != null ) { kernel . dispose ( ) ; integer oldsize = integer . valueof ( _kernelhashtable . size ( ) ) ; _kernelhashtable . remove ( name ) ; setdirtyandfirepropertychange ( kernel_listlength_changed_property , oldsize , integer . valueof ( _kernelhashtable . size ( ) ) ) ; } }	delete a kernel by name.
protected boolean shouldstop ( ) { return ispaused ( ) || iskilled ( ) ; }	returns true if the request is paused or killed , developers should call this method periodically to test whether they should quit the current io operation immediately.
public builder addtokenfilter ( string name , map < string , string > params ) throws ioexception { objects . requirenonnull ( name , _str ) ; tokenfilters . add ( applyresourceloader ( tokenfilterfactory . forname ( name , applydefaultparams ( params ) ) ) ) ; componentsadded = _bool ; return this ; }	adds the given token filter .
public styledtooltipui ( style style ) { this . style = style ; border = borderfactory . createlineborder ( style . getshadowcolor ( ) ) ; }	create a new styledtooltipui .
public final void addelements ( object value , int numberofelements ) { if ( ( m_firstfree + numberofelements ) >= m_mapsize ) { m_mapsize += ( m_blocksize + numberofelements ) ; object newmap [ ] = new object [ m_mapsize ] ; system . arraycopy ( m_map , _num , newmap , _num , m_firstfree + _num ) ; m_map = newmap ; } for ( int i = _num ; i < numberofelements ; i ++ ) { m_map [ m_firstfree ] = value ; m_firstfree ++ ; } }	append several object values onto the vector .
public void actionperformed ( actionevent e ) { super . actionperformed ( e ) ; string cmd = e . getactioncommand ( ) ; if ( cmd == showmapscommand ) { jcheckbox mapcheck = ( jcheckbox ) e . getsource ( ) ; viewattributes . showmaps = mapcheck . isselected ( ) ; repaint ( ) ; } else if ( cmd == showinfocommand ) { jcheckbox infocheck = ( jcheckbox ) e . getsource ( ) ; boolean showinfo = infocheck . isselected ( ) ; viewattributes . showinfo = showinfo ; showsubframes ( showinfo ) ; doprepare ( ) ; } else if ( cmd == lockseriescommand ) { jcheckbox lockcheck = ( jcheckbox ) e . getsource ( ) ; boolean locked = lockcheck . isselected ( ) ; if ( locked ) { list < rpfcoveragebox > coverageboxes = getcoverageboxes ( ) ; string seriesname ; if ( coverageboxes == null || coverageboxes . isempty ( ) ) { seriesname = rpfviewattributes . any ; } else { seriesname = coverageboxes . get ( _num ) . chartcode ; } if ( seriesname == null ) { seriesname = rpfviewattributes . any ; firerequestmessage ( _str + getname ( ) + _str ) ; } lockcheck . settext ( lockedbuttontitle + _str + seriesname ) ; viewattributes . chartseries = seriesname ; } else { lockcheck . settext ( unlockedbuttontitle ) ; viewattributes . chartseries = rpfviewattributes . any ; } } else if ( cmd == showcoveragecommand ) { if ( coverage != null ) { jcheckbox coveragecheck = ( jcheckbox ) e . getsource ( ) ; coverage . setinuse ( coveragecheck . isselected ( ) ) ; doprepare ( ) ; } } else { doprepare ( ) ; } }	the action listener method , that reacts to the palette widgets actions .
@ override public void run ( ) { if ( mdelay > _num ) { try { thread . sleep ( mdelay ) ; } catch ( interruptedexception e ) { logimpl . w ( tag , getname ( ) + _str + e . getmessage ( ) ) ; } } if ( mparenttask != null ) { synchronized ( this ) { try { wait ( ) ; } catch ( interruptedexception e ) { logimpl . w ( tag , getname ( ) + _str + e . getmessage ( ) ) ; } } } mstatus = status . status_executing ; long starttime = system . currenttimemillis ( ) ; start ( ) ; long endtime = system . currenttimemillis ( ) ; logimpl . i ( tag , getname ( ) + _str + ( endtime - starttime ) ) ; if ( mdonesignal != null ) { mdonesignal . countdown ( ) ; } if ( mchildtask != null ) { synchronized ( mchildtask ) { mchildtask . notify ( ) ; } } mstatus = status . status_done ; }	normally should not override it.
public boolean has ( final string name ) { return contents . containskey ( name . tolowercase ( ) ) ; }	checks whether an npc with the given name exists .
public void stop ( ) { isalive . set ( _bool ) ; for ( kafkaconsumer < byte [ ] , byte [ ] > c : consumers . values ( ) ) { c . wakeup ( ) ; } kafkaconsumerexecutor . shutdownnow ( ) ; holdingbuffer . clear ( ) ; ioutils . closequietly ( this ) ; }	the method is called in the deactivate method of the operator.
public string consumeelementselector ( ) { int start = pos ; while ( ! isempty ( ) && ( matchesword ( ) || matchesany ( _str , _str , _str ) ) ) pos ++ ; return queue . substring ( start , pos ) ; }	consume a css element selector ( tag name , but | instead of : for namespaces , to not conflict with : pseudo selects ) .
@ suppresswarnings ( _str ) public longmap ( int initialcapacity , float loadfactor ) { if ( initialcapacity < _num ) throw new illegalargumentexception ( _str + initialcapacity ) ; if ( initialcapacity > _num << _num ) throw new illegalargumentexception ( _str + initialcapacity ) ; capacity = nextpoweroftwo ( initialcapacity ) ; if ( loadfactor <= _num ) throw new illegalargumentexception ( _str + loadfactor ) ; this . loadfactor = loadfactor ; threshold = ( int ) ( capacity * loadfactor ) ; mask = capacity - _num ; hashshift = _num - long . numberoftrailingzeros ( capacity ) ; stashcapacity = math . max ( _num , ( int ) math . ceil ( math . log ( capacity ) ) * _num ) ; pushiterations = math . max ( math . min ( capacity , _num ) , ( int ) math . sqrt ( capacity ) / _num ) ; keytable = new long [ capacity + stashcapacity ] ; valuetable = ( v [ ] ) new object [ keytable . length ] ; }	creates a new map with the specified initial capacity and load factor.
public void endattributes ( ) throws saxexception { string uri = getcurrentelementuri ( ) ; string local = getcurrentelementlocal ( ) ; string prefix = nscontext . getprefix ( uri ) ; _assert ( prefix != null ) ; string qname ; if ( prefix . length ( ) != _num ) qname = prefix + _str + local ; else qname = local ; nscontext . iteratedeclaredprefixes ( startprefixcallback ) ; writer . startelement ( uri , local , qname , attributes ) ; attributes . clear ( ) ; textbuf . setlength ( _num ) ; }	switches to the " marshal child texts / elements " mode.
private string abbreviatescript ( string script ) { if ( script == null ) { return null ; } if ( script . length ( ) <= _num ) { return script ; } return _str + script . substring ( _num , _num ) ; }	abbreviates this script to a length that will fit in the database .
public static void expandid ( string numberstring , wordrelation wordrelation , item tokenitem ) { int numberdigits = numberstring . length ( ) ; if ( ( numberdigits == _num ) && ( numberstring . charat ( _num ) == _str ) && ( numberstring . charat ( _num ) == _str ) ) { if ( numberstring . charat ( _num ) == _str ) { expandnumber ( numberstring , wordrelation , tokenitem ) ; } else { expandnumber ( numberstring . substring ( _num , _num ) , wordrelation , tokenitem ) ; wordrelation . addword ( tokenitem , _str ) ; } } else if ( ( numberdigits == _num ) && ( numberstring . charat ( _num ) == _str ) ) { wordrelation . addword ( tokenitem , _str ) ; expanddigits ( numberstring . substring ( _num , _num ) , wordrelation , tokenitem ) ; } else if ( ( numberdigits == _num && numberstring . charat ( _num ) == _str ) || numberdigits < _num ) { expandnumber ( numberstring , wordrelation , tokenitem ) ; } else if ( numberdigits % _num == _num ) { string firstdigit = digit2num [ numberstring . charat ( _num ) - _str ] ; wordrelation . addword ( tokenitem , firstdigit ) ; expandid ( numberstring . substring ( _num , numberdigits ) , wordrelation , tokenitem ) ; } else { expandnumber ( numberstring . substring ( _num , _num ) , wordrelation , tokenitem ) ; expandid ( numberstring . substring ( _num , numberdigits ) , wordrelation , tokenitem ) ; } }	expands the given number string as pairs as in years or ids.
private static void unregistermbeansfrompropsfile ( mbeanserver mbeanserver ) throws exception { jamonpropertiesloader loader = new jamonpropertiesloader ( ) ; list < string > jamonjmxbeanproperties = loader . getmxbeans ( ) ; iterator < string > iter = jamonjmxbeanproperties . iterator ( ) ; while ( iter . hasnext ( ) ) { string beaninfo = iter . next ( ) ; monitormxbean mxbean = monitormxbeanfactory . create ( beaninfo ) ; mbeanserver . unregistermbean ( monitormxbeanfactory . getobjectname ( mxbean ) ) ; monitormxbean mxbeandelta = monitormxbeanfactory . createdelta ( beaninfo ) ; mbeanserver . unregistermbean ( monitormxbeanfactory . getdeltaobjectname ( mxbeandelta ) ) ; } }	read the properties file and unregister its configurable jamon jmx beans.
source popimportsource ( ) { return ( source ) m_importsourcestack . pop ( ) ; }	pop a source from a user provided uriresolver , corresponding to the url popped from the m_importstack .
public static date zerotimedate ( date date ) { final gregoriancalendar gregoriancalendar = new gregoriancalendar ( ) ; gregoriancalendar . settime ( date ) ; gregoriancalendar . set ( calendar . hour_of_day , _num ) ; gregoriancalendar . set ( calendar . minute , _num ) ; gregoriancalendar . set ( calendar . second , _num ) ; gregoriancalendar . set ( calendar . millisecond , _num ) ; return gregoriancalendar . gettime ( ) ; }	reset the time of a date.
public static final void writemapxml ( map val , string name , xmlserializer out ) throws xmlpullparserexception , ioexception { if ( val == null ) { out . starttag ( null , _str ) ; out . endtag ( null , _str ) ; return ; } set s = val . entryset ( ) ; iterator i = s . iterator ( ) ; out . starttag ( null , _str ) ; if ( name != null ) { out . attribute ( null , _str , name ) ; } while ( i . hasnext ( ) ) { map . entry e = ( map . entry ) i . next ( ) ; writevaluexml ( e . getvalue ( ) , ( string ) e . getkey ( ) , out ) ; } out . endtag ( null , _str ) ; }	flatten a map into an xmlserializer.
protected void export ( ) { int retval ; file file ; abstractfilesaver saver ; if ( m_filechooser == null ) m_filechooser = guihelper . newconverterfilechooser ( ) ; retval = m_filechooser . showsavedialog ( this ) ; if ( retval != converterfilechooser . approve_option ) return ; file = m_filechooser . getselectedfile ( ) ; saver = m_filechooser . getsaver ( ) ; try { saver . setinstances ( m_datapanel . getinstances ( ) ) ; saver . writebatch ( ) ; } catch ( exception e ) { joptionpane . showmessagedialog ( this , _str + file + _str + utils . throwabletostring ( e ) , _str , joptionpane . error_message ) ; } }	exports the data to a file .
public void sort ( int i ) { arrays . sort ( vector [ i ] , _num , sizes . get ( i ) ) ; }	sorts the selected row in increasing order .
private void createmapwhenneeded ( ) { if ( ismapinitialized ) { return ; } if ( resourcebundle != null ) { set < string > set = resourcebundle . keyset ( ) ; toplevelmap = new hashmap < string , object > ( set . size ( ) ) ; for ( string key : set ) { object value = resourcebundle . getobject ( key ) ; toplevelmap . put ( key , value ) ; } } else { toplevelmap = new hashmap < string , object > ( _num ) ; } toplevelmap . put ( _str , resourcebundle ) ; ismapinitialized = _bool ; }	creates the toplevelmap only when it is required.
public static vectorclock increment ( vectorclock clock , int ... nodes ) { for ( int n : nodes ) clock = clock . incremented ( ( short ) n , system . currenttimemillis ( ) ) ; return clock ; }	record events for the given sequence of nodes.
@ override public string tostring ( ) { return _str + set . tostring ( ) ; }	returns a string representation of the set.
void createheapphiinstruction ( basicblock bb , heapvariable < object > h ) { instruction s = makephiinstruction ( h , bb ) ; arraylist < instruction > heapphis = heapphi . get ( bb ) ; if ( heapphis == null ) { heapphis = new arraylist < instruction > ( _num ) ; heapphi . put ( bb , heapphis ) ; } heapphis . add ( s ) ; registerinstruction ( s , bb ) ; }	create a heap control phi instruction , and store it at the beginning of a basic block .
protected void printtime ( string s ) { simpledateformat dateformat = new simpledateformat ( _str ) ; println ( dateformat . format ( new java . util . date ( ) ) + _str + s ) ; }	print the current time and a message to system out .
public static int determinesamplesize ( imagerequest imagerequest , encodedimage encodedimage ) { if ( ! encodedimage . ismetadataavailable ( encodedimage ) ) { return default_sample_size ; } float ratio = determinedownsampleratio ( imagerequest , encodedimage ) ; int samplesize ; if ( encodedimage . getimageformat ( ) == imageformat . jpeg ) { samplesize = ratiotosamplesizejpeg ( ratio ) ; } else { samplesize = ratiotosamplesize ( ratio ) ; } int maxdimension = math . max ( encodedimage . getheight ( ) , encodedimage . getwidth ( ) ) ; while ( maxdimension / samplesize > max_bitmap_size ) { if ( encodedimage . getimageformat ( ) == imageformat . jpeg ) { samplesize *= _num ; } else { samplesize ++ ; } } return samplesize ; }	get the factor between the dimensions of the encodedimage ( actual image ) and the ones of the imagerequest ( requested size ) .
public skeleton ( printwriter out ) { this . out = out ; }	creates a new skeleton ( iterator ) instance .
public void disconnect ( ) { if ( conn != null ) { try { conn . close ( ) ; } catch ( sqlexception e ) { logger . warn ( _str , e ) ; } } try { closebinlog ( ) ; } catch ( ioexception e ) { logger . warn ( _str , e ) ; } }	clean up after termination .
@ override public int read ( byte [ ] b , int off , int len ) throws ioexception { int n = in . read ( b , off , len ) ; if ( n == - _num ) { throwiffalseeof ( ) ; } else { bytesread += n ; } return n ; }	java . io . inputstream # read ( byte [ ] , int , int ) swallows ioexception thrown from read ( ) so we have to override it .
@ override public generator < ilinesegment > construct ( string [ ] args ) { return new integergenerator ( integer . valueof ( args [ _num ] ) , integer . valueof ( args [ _num ] ) ) ; }	provide reflective behavior to construct instance of generator given an array of string arguments .
public spatialstrategy ( spatialcontext ctx , string fieldname ) { if ( ctx == null ) throw new illegalargumentexception ( _str ) ; this . ctx = ctx ; if ( fieldname == null || fieldname . length ( ) == _num ) throw new illegalargumentexception ( _str ) ; this . fieldname = fieldname ; }	constructs the spatial strategy with its mandatory arguments .
public void dispose ( ) { if ( keys != null ) { keys . clear ( ) ; keys = null ; } super . dispose ( ) ; }	dispose - free resources.
public boolean isfixeddisk ( string letter ) { if ( letter . length ( ) != _num ) throw new illegalargumentexception ( _str + letter ) ; char drive = character . touppercase ( letter . charat ( _num ) ) ; if ( drive < _str || drive > _str ) throw new illegalargumentexception ( _str + drive ) ; return getdrivetype ( drive + _str ) == _num ; }	feed it a drive letter ( such as ' a ' ) to see if it is a fixed disk .
private object [ ] compile ( string path ) { list list = new arraylist ( ) ; if ( path == null ) { return list . toarray ( ) ; } stringtokenizer tok = new stringtokenizer ( path , _str ) ; while ( tok . hasmoretokens ( ) ) { string token = tok . nexttoken ( ) ; openum op = openum . getinstance ( token ) ; if ( op == null ) { throw new error ( _str + path ) ; } list . add ( op ) ; if ( op == openum . relation ) { list . add ( tok . nexttoken ( ) ) ; } } return list . toarray ( ) ; }	compiles the given path into the compiled form.
private void splitchunk ( final memorychunk chunk , final long address ) { final byte [ ] olddata = chunk . getbytes ( ) ; final byte [ ] newdata1 = new byte [ ( int ) ( address - chunk . getaddress ( ) ) ] ; final byte [ ] newdata2 = new byte [ ( chunk . getlength ( ) - newdata1 . length ) ] ; system . arraycopy ( olddata , _num , newdata1 , _num , newdata1 . length ) ; system . arraycopy ( olddata , olddata . length - newdata2 . length , newdata2 , _num , newdata2 . length ) ; final memorychunk newchunk1 = new memorychunk ( chunk . getaddress ( ) , newdata1 ) ; final memorychunk newchunk2 = new memorychunk ( ( chunk . getaddress ( ) + chunk . getlength ( ) ) - newdata2 . length , newdata2 ) ; removechunk ( chunk ) ; insertchunk ( newchunk1 ) ; insertchunk ( newchunk2 ) ; }	splits a chunk into two chunks .
public boolean isdirty ( ) { return dirty ; }	check if preferences need to be saved .
private vector showtextfixedwidth ( string text , int align ) { vector comps = new vector ( ) ; if ( ( text == null ) || ( text . equals ( _str ) ) ) { return comps ; } int spacew = width - x ; vector words = getwords ( text , align , _bool ) ; if ( words . size ( ) > _num ) { int w = _num ; string wordstr = _str ; if ( ( cssparser . iswhitespace ( text . charat ( _num ) ) ) && ( curline . getcomponentcount ( ) != _num ) ) { wordstr = _str ; } while ( w < words . size ( ) ) { string nextword = ( string ) words . elementat ( w ) ; string space = _str ; if ( ( ! wordstr . equals ( _str ) ) && ( ! wordstr . equals ( _str ) ) ) { space = _str ; } if ( font . stringwidth ( wordstr + space + nextword ) > spacew - _num ) { comps . addelement ( addstring ( wordstr , align ) ) ; newlineifnotempty ( align ) ; spacew = width - x ; wordstr = nextword ; } else { wordstr += space + nextword ; } w ++ ; } if ( cssparser . iswhitespace ( text . charat ( text . length ( ) - _num ) ) ) { wordstr += _str ; } comps . addelement ( addstring ( wordstr , align ) ) ; } return comps ; }	shows the given text.
private void calculateslotusage ( ) { numentries = _num ; for ( int i = _num ; i < table . table . length ; i ++ ) { linkedlist < v > list = ( linkedlist < v > ) table . table [ i ] ; if ( list != null ) { numentries += list . size ( ) ; inthashtable [ i ] += list . size ( ) ; } } }	compute usages based upon the table .
public insert defaultvalues ( ) { defaultvalues = _bool ; columns . clear ( ) ; valuestoinsert . clear ( ) ; query = null ; invalidatecompilecache ( ) ; return this ; }	insert default values for the columns into the table.
public cfilenameformatter ( final file directory ) { preconditions . checkargument ( directory . exists ( ) , _str ) ; m_directory = directory ; }	filter for jformattedtextfield . ensures valid filenames . does not work for directories .
public t pop ( ) { return list . removelast ( ) ; }	removes the object at the top of this stack and returns that object as the value of this function .
public static string nodelisttostring ( list < ? extends node > list ) { stringbuffer buf = new stringbuffer ( ) ; buf . append ( _str ) ; if ( list . size ( ) > _num ) { buf . append ( _str + domtostring ( list . get ( _num ) ) + _str ) ; for ( int i = _num ; i < list . size ( ) ; ++ i ) { buf . append ( _str + i + _str + domtostring ( list . get ( _num ) ) + _str ) ; } buf . append ( _str ) ; } buf . append ( _str ) ; return buf . tostring ( ) ; }	* prettyprints a list < node >.
protected element adapt ( element source , elementmetadata < ? , ? > sourcemeta , string kind ) { elementkey < ? , ? > adaptorkey = sourcemeta . adapt ( kind ) ; if ( adaptorkey != null ) { try { return adapt ( adaptorkey , source ) ; } catch ( contentcreationexception e ) { logger . log ( level . severe , _str + source . getclass ( ) + _str + adaptorkey . getelementtype ( ) , e ) ; } } return source ; }	adapts an element based on a key.
public string convertaliastonumber ( string aliasname ) { if ( ! aliasname . contains ( _str ) && aliasdatabase . containsalias ( aliasname ) ) { string [ ] res = aliasdatabase . getalias ( aliasname ) ; return res [ _num ] ; } return aliasname ; }	converts an given alias to a unique phone number.
public attr ( string name , @ nullable format format ) { this . name = name ; if ( format != null ) { formats = collections . singletonlist ( format ) ; } }	construct a new attribute.
static streamtokenizer maketokenizer ( string tagvalue ) { streamtokenizer tokenizer = new streamtokenizer ( new stringreader ( tagvalue ) ) ; tokenizer . resetsyntax ( ) ; tokenizer . wordchars ( _str , _str ) ; tokenizer . wordchars ( _str , _str ) ; tokenizer . wordchars ( _str , _str ) ; tokenizer . wordchars ( _str , _str ) ; tokenizer . wordchars ( _str , _str ) ; tokenizer . wordchars ( _str , _str ) ; tokenizer . wordchars ( _str , _str ) ; tokenizer . wordchars ( _str , _str ) ; tokenizer . quotechar ( _str ) ; tokenizer . quotechar ( _str ) ; tokenizer . whitespacechars ( _str , _str ) ; tokenizer . whitespacechars ( _str , _str ) ; tokenizer . whitespacechars ( _str , _str ) ; tokenizer . whitespacechars ( _str , _str ) ; tokenizer . eolissignificant ( _bool ) ; return tokenizer ; }	create a streamtokenizer suitable for parsing the tag text .
private void sendrequest ( ) { int i = tabpane . getselectedindex ( ) ; string prompt = rb . getstring ( _str + i + _str ) ; if ( log . isdebugenabled ( ) ) { log . debug ( _str + prompt + _str + i ) ; } if ( source == null ) { log . error ( _str ) ; timer . stop ( ) ; return ; } source . sendbytes ( prompt . getbytes ( ) ) ; }	time to send the next request.
public void remove ( predicate filter ) { for ( intiterator ii = rows ( filter ) ; ii . hasnext ( ) ; ) removerow ( ii . nextint ( ) ) ; }	removes all table rows that meet the input predicate filter .
private void calculatetrimarea ( rect bounds ) { float size = math . min ( bounds . height ( ) , bounds . width ( ) ) ; float yoffset = ( bounds . height ( ) - size ) / _num ; float xoffset = ( bounds . width ( ) - size ) / _num ; float padding = mpadding + ( bounds . height ( ) - _num * mpadding ) * _num / _num ; minternalbounds . set ( bounds . left + padding + xoffset , bounds . top + padding + yoffset , bounds . right - padding - xoffset , bounds . bottom - padding - yoffset ) ; mcenter = minternalbounds . centerx ( ) ; msize = minternalbounds . width ( ) ; mplaytipoffset = _num / _num * msize ; mplaybaseoffset = _num * msize ; settransitionstate ( _num , _num ) ; }	this calculates the trim area for the icon as specified in the guidelines.
protected void initinstances ( operation post , servicedocument ... states ) { initinstances ( post , _bool , _bool , states ) ; }	initialize a list of service default states if not already created.
protected instance mergeinstances ( instance source , instance dest ) { instances outputformat = outputformatpeek ( ) ; double [ ] vals = new double [ outputformat . numattributes ( ) ] ; for ( int i = _num ; i < vals . length ; i ++ ) { if ( ( i != outputformat . classindex ( ) ) && ( m_selectedcols . isinrange ( i ) ) ) { if ( ( source != null ) && ! source . ismissing ( i ) && ! dest . ismissing ( i ) ) { vals [ i ] = dest . value ( i ) - source . value ( i ) ; } else { vals [ i ] = utils . missingvalue ( ) ; } } else { vals [ i ] = dest . value ( i ) ; } } instance inst = null ; if ( dest instanceof sparseinstance ) { inst = new sparseinstance ( dest . weight ( ) , vals ) ; } else { inst = new denseinstance ( dest . weight ( ) , vals ) ; } inst . setdataset ( dest . dataset ( ) ) ; return inst ; }	creates a new instance the same as one instance ( the " destination " ) but with some attribute values copied from another instance ( the " source " ).
public sourcecallchainbuilder ( int timeout , boolean process_callbacks ) { this . timeout = timeout ; this . process_callbacks = process_callbacks ; }	create a sourcecallchainbuilder with specified timeout and process_callbacks flag .
public synchronized float recoveredbytespercent ( ) { long total = _num ; long recovered = _num ; for ( file file : filedetails . values ( ) ) { if ( file . reused ( ) == _bool ) { total += file . length ( ) ; recovered += file . recovered ( ) ; } } if ( total == _num && filedetails . size ( ) == _num ) { return _num ; } if ( total == recovered ) { return _num ; } else { return _num * recovered / total ; } }	percent of bytes recovered out of total files bytes * to be * recovered.
public < e extends t > eventbinder < e > on ( ) { return new eventbinder < > ( optional . empty ( ) ) ; }	retrieves the eventbinder object to bind an eventlistener to ths eventbus that only accepts a specific subclass of & lt ; t & gt ;.
private boolean isvaluesupported ( object value ) { for ( int i = _num ; i < values . length ; i ++ ) { if ( value . equals ( values [ i ] ) ) { return _bool ; } } return _bool ; }	indicates whether the value specified is supported .
public static bitset frombytearray ( byte [ ] bytes ) { bitset bits = new bitset ( ) ; for ( int i = _num ; i < bytes . length * _num ; i ++ ) { if ( ( bytes [ bytes . length - i / _num - _num ] & ( _num << ( i % _num ) ) ) > _num ) { bits . set ( i ) ; } } return bits ; }	returns a bitset containing the values in bytes.
public repeattime createrepeattime ( int repeatinterval , int activeduration , int [ ] offsets ) { repeatfield repeattimefield = new repeatfield ( ) ; try { repeattimefield . setrepeatinterval ( repeatinterval ) ; repeattimefield . setactiveduration ( activeduration ) ; repeattimefield . setoffsetarray ( offsets ) ; } catch ( sdpexception s ) { s . printstacktrace ( ) ; } return repeattimefield ; }	returns a repeattime object with the specified interval , duration , and time offsets .
public void remove ( int i ) { if ( ( i >= array . length ) || ( i < _num ) ) throw new arrayindexoutofboundsexception ( _str + i + _str + array . length ) ; nsobject [ ] newarray = new nsobject [ array . length - _num ] ; system . arraycopy ( array , _num , newarray , _num , i ) ; system . arraycopy ( array , i + _num , newarray , i , array . length - i - _num ) ; array = newarray ; }	remove the i - th element from the array.
private time parsetime ( string timestring ) throws parseexception { java . util . date parseddate = timefield . parse ( timestring ) ; if ( parseddate == null ) return null ; return new time ( parseddate . gettime ( ) ) ; }	parses the given string into a corresponding time.
private void decrementcopyfieldtargetcount ( schemafield dest ) { integer count = copyfieldtargetcounts . get ( dest ) ; assert count != null ; if ( count <= _num ) { copyfieldtargetcounts . remove ( dest ) ; } else { copyfieldtargetcounts . put ( dest , count - _num ) ; } }	decrements the count for the given destination field in copyfieldtargetcounts .
public static calendar fromunixtime ( long unixtime , timeunit timeunit ) { calendar calendar = getcalendarinstance ( ) ; calendar . settimezone ( timezone . getdefault ( ) ) ; long millis = timeunit . tomillis ( unixtime ) ; calendar . settimeinmillis ( millis ) ; return calendar ; }	converts unix time in the given time units into java calendar time.
public boolean islayoutidinrecord ( int layoutid ) { return mlayoutids != null && mlayoutids . contains ( layoutid ) ; }	is the recorded layout id.
private void open_board_design_action ( ) { designfile design_file = open_dialog ( stat , main_options . design_dir_name ) ; if ( design_file == null ) { stat . userprintln ( resources . getstring ( _str ) ) ; return ; } string message = resources . getstring ( _str ) + _str + design_file . get_name ( ) ; stat . userprintln ( message ) ; boardframe board_frame = new boardframe ( design_file , stat ) ; importdesign d_import = new importdesign ( board_frame ) ; d_import . execute ( ) ; }	opens a board design from a binary file or a specctra dsn file need to detach from swing thread since messages are not printed.
public static string retrievedisplayname ( string id , boolean daylight , int style , locale locale ) { string [ ] names = retrievedisplaynamesimpl ( id , locale ) ; if ( objects . nonnull ( names ) ) { return names [ ( daylight ? _num : _num ) - style ] ; } else { return null ; } }	retrieves a standard or daylight - saving time name for the given time zone id .
protected query newfuzzyquery ( term term , float minimumsimilarity , int prefixlength ) { string text = term . text ( ) ; int numedits = fuzzyquery . floattoedits ( minimumsimilarity , text . codepointcount ( _num , text . length ( ) ) ) ; return new fuzzyquery ( term , numedits , prefixlength ) ; }	builds a new fuzzyquery instance.
@ override public void playvideo ( uri uri , string title ) { cameraactivity activity = mactivity . get ( ) ; if ( activity != null ) { camerautil . playvideo ( activity , uri , title ) ; } }	fires an intent to play the video with the given uri and title .
public void copyfrom ( path other ) { grow ( other . length - _num ) ; system . arraycopy ( other . blockidlist , _num , this . blockidlist , _num , other . length ) ; this . length = other . length ; this . cachedhashcode = other . cachedhashcode ; }	make this path identical to the given one .
void recovermessages ( ) throws rollbackfailedexception { if ( m_isqueue ) { if ( _logger . isloggable ( level . fine ) ) { _logger . log ( level . fine , _str ) ; } unackedmessages . clear ( ) ; if ( ! isautoack ( ) ) { rollbacklocaltransaction ( ) ; } } else { if ( _logger . isloggable ( level . fine ) ) { _logger . log ( level . fine , _str ) ; } unackedmessages . addall ( recovermessages ) ; linkedlist < messagequeueelement > temp = unackedmessages ; recovermessages . clear ( ) ; unackedmessages = recovermessages ; recovermessages = temp ; } }	performs session recovery . with topics , we redeliver the unacked messages that arrived to the session ( local redelivery ) . with queues , we return the messages to the space so they can be redelivered from there .
private map < key , array > store ( class clazz ) { method [ ] methods = clazz . getmethods ( ) ; map < key , array > methodsmap = new concurrenthashmap < key , array > ( ) ; for ( int i = _num ; i < methods . length ; i ++ ) { storemethod ( methods [ i ] , methodsmap ) ; } map . put ( clazz , methodsmap ) ; return methodsmap ; }	store a class with his methods.
protected int readfully ( inputstream in , byte buffer [ ] , int offset , int len ) throws ioexception { for ( int i = _num ; i < len ; i ++ ) { int q = in . read ( ) ; if ( q == - _num ) return ( ( i == _num ) ? - _num : i ) ; buffer [ i + offset ] = ( byte ) q ; } return len ; }	this method works around the bizarre semantics of bufferedinputstream ' s read method .
private long renewserviceleasedo ( serviceid serviceid , uuid leaseid , long renewduration ) throws unknownleaseexception { long now = system . currenttimemillis ( ) ; long renewexpiration = renewserviceleaseint ( serviceid , leaseid , renewduration , now ) ; addlogrecord ( new serviceleaserenewedlogobj ( serviceid , leaseid , renewexpiration ) ) ; return renewexpiration - now ; }	the code that does the real work of renewservicelease .
public blockswapper ( world world , entityplayer player , itemstack truncator , blockpos origcoords , int range , boolean leaves ) { this . world = world ; this . player = player ; this . truncator = truncator ; this . origin = origcoords ; this . range = range ; this . treatleavesspecial = leaves ; this . candidatequeue = new priorityqueue < > ( ) ; this . completedcoords = new hashset < > ( ) ; candidatequeue . offer ( new swapcandidate ( this . origin , this . range ) ) ; }	creates a new block swapper with the provided parameters .
public static string [ ] tostringarray ( enumeration < string > enumeration ) { if ( enumeration == null ) { return null ; } list < string > list = collections . list ( enumeration ) ; return list . toarray ( new string [ list . size ( ) ] ) ; }	copy the given enumeration into a string array.
public boolean overlapsave ( spherecluster other ) { double mindist = math . sqrt ( _num ) * ( getradius ( ) + other . getradius ( ) ) ; double diff = getcenterdistance ( other ) - mindist ; return diff > _num ; }	when a clusters looses points the new minimal bounding sphere can be partly outside of the originating cluster.
@ put @ consumes ( { mediatype . application_xml , mediatype . application_json } ) @ path ( _str ) @ produces ( { mediatype . application_xml , mediatype . application_json } ) @ checkpermission ( roles = { role . system_admin , role . restricted_system_admin } ) public filevirtualpoolrestrep updatefilevirtualpoolwithassignedpools ( @ pathparam ( _str ) uri id , virtualpoolpoolupdateparam param ) { virtualpool vpool = updatevirtualpoolwithassignedstoragepools ( id , param ) ; return tofilevirtualpool ( vpool , virtualpool . getfileremoteprotectionsettings ( vpool , _dbclient ) ) ; }	update file virtualpool only allows user to assign matching storage pools .
public static java . sql . date tosqldate ( int month , int day , int year ) { java . util . date newdate = todate ( month , day , year , _num , _num , _num ) ; if ( newdate != null ) { return new java . sql . date ( newdate . gettime ( ) ) ; } else { return null ; } }	makes a java . sql . date from separate ints for month , day , year.
public object readdefaultlistmodel ( element node ) throws exception { defaultlistmodel model ; vector < element > children ; element child ; int i ; int index ; int currindex ; if ( debug ) { trace ( new throwable ( ) , node . getattribute ( att_name ) ) ; } m_currentnode = node ; children = xmldocument . getchildtags ( node ) ; model = new defaultlistmodel ( ) ; index = children . size ( ) - _num ; for ( i = _num ; i < children . size ( ) ; i ++ ) { child = children . get ( i ) ; currindex = integer . parseint ( child . getattribute ( att_name ) ) ; if ( currindex > index ) { index = currindex ; } } model . setsize ( index + _num ) ; for ( i = _num ; i < children . size ( ) ; i ++ ) { child = children . get ( i ) ; model . set ( integer . parseint ( child . getattribute ( att_name ) ) , invokereadfromxml ( child ) ) ; } return model ; }	builds the defaultlistmodel from the given dom node .
private boolean resultsidentical ( string namedcurve , biginteger badx , biginteger bady , biginteger secret , int iter ) throws invalidalgorithmparameterexception , nosuchalgorithmexception , invalidkeyspecexception , invalidkeyexception { for ( int i = _num ; i < iter ; i ++ ) { secret = secret . add ( biginteger . one ) ; biginteger resultcustom = computesecretwithcustomalgorithm ( namedcurve , badx , bady , secret ) ; biginteger resultsun = computesecretwithsunalgorithm ( namedcurve , badx , bady , secret ) ; if ( resultsun != null && ! resultsun . equals ( resultcustom ) ) { return _bool ; } } return _bool ; }	executes point multiplication with custom and java sun computation.
public void enablelayers ( boolean enable ) { texturestate texturestate = ( texturestate ) getlocalrenderstate ( renderstate . statetype . texture ) ; texturestate . setenabled ( enable ) ; markdirty ( dirtytype . renderstate ) ; }	enable the layers on this mesh .
protected void starverandomly ( int limit ) { while ( population . size ( ) > limit ) { int removepos = randomness . nextint ( ) % population . size ( ) ; population . remove ( removepos ) ; } }	this method can be used to kick out random chromosomes in the current population until the given limit is reached again .
public void saveparam ( ) throws exception { enumeration < abstractparampanel > en = tablepanel . elements ( ) ; abstractparampanel panel = null ; while ( en . hasmoreelements ( ) ) { panel = en . nextelement ( ) ; panel . saveparam ( paramobject ) ; } }	saves the data of all panels , throwing an exception if there ' s any error.
@ suppresswarnings ( _str ) public static localstreamingcontainer waitforactivation ( stramlocalcluster localcluster , ptoperator operator ) throws interruptedexception { localstreamingcontainer container ; long startmillis = system . currenttimemillis ( ) ; while ( system . currenttimemillis ( ) < ( startmillis + default_timeout_millis ) ) { if ( operator . getstate ( ) == ptoperator . state . active ) { if ( ( container = localcluster . getcontainer ( operator ) ) != null ) { return container ; } } log . debug ( _str , new object [ ] { operator , operator . getstate ( ) , operator . getcontainer ( ) } ) ; thread . sleep ( _num ) ; } assert . fail ( _str + operator ) ; return null ; }	wait until instance of operator is deployed into a container and return the container reference.
protected string toexternalform ( url url ) { return toexternalform ( url , _bool ) ; }	returns the clear text representation of a given url using http format .
public resultset executequery ( string query ) throws sqlexception , noconnectionexception { if ( connection != null ) { statement st = connection . createstatement ( ) ; return st . executequery ( query ) ; } throw new noconnectionexception ( ) ; }	executes an sql query.
private void rejectaccessandterminateprocess ( radiusresponse response , contextholder holder ) { response . setresponsepacket ( new accessreject ( ) ) ; response . setuniversalid ( holder . getuniversalid ( ) ) ; terminateauthnprocess ( holder ) ; }	sends a radius accessreject response and cleans up the cache and authentication context if it not null by calling its logout method .
public scvolume createviewvolume ( string name , string instanceid ) throws storagecenterapiexception { log . debug ( _str , instanceid ) ; string errormessage = _str ; parameters params = new parameters ( ) ; params . add ( _str , name ) ; params . add ( _str , notes_string ) ; try { restresult result = restclient . post ( string . format ( _str , instanceid ) , params . tojson ( ) ) ; if ( checkresults ( result ) ) { return gson . fromjson ( result . getresult ( ) , scvolume . class ) ; } } catch ( exception e ) { errormessage = string . format ( _str , e ) ; log . warn ( errormessage ) ; } if ( errormessage . length ( ) == _num ) { errormessage = string . format ( _str , name , instanceid ) ; } throw new storagecenterapiexception ( errormessage ) ; }	creates a volume from a snapshot .
@ override public boolean contains ( object object ) { return indexof ( object , _num ) != - _num ; }	searches this vector for the specified object .
public void sync ( ) throws storagefault { final string methodname = _str ; log . debug ( methodname + _str ) ; try { log . trace ( methodname + _str ) ; _syncmanager . syncall ( ) ; } catch ( sosfailure e ) { log . error ( methodname + _str , e ) ; throw faultutil . storagefault ( e ) ; } log . debug ( methodname + _str ) ; }	caches project and tenant ids for further operations.
private void addmenuitem ( jpopupmenu menu , string title , mwfnodenext line ) { wfpopupitem item = new wfpopupitem ( title , line ) ; menu . add ( item ) ; item . addactionlistener ( this ) ; }	add menu item to - delete line.
public static matcher < bindingset > binds ( string name , class < ? > value ) { return new bindsmatcher < object > ( name , instanceof ( value ) ) ; }	check binding to specific class .
private void testadd ( ) throws exception { log . info ( _str ) ; long msgcount = messagemapper . countmessagesinmailbox ( mboxes . get ( _num ) ) ; log . info ( msgcount + _str + message_no . size ( ) ) ; assertequals ( message_no . size ( ) , msgcount ) ; }	test of add method , of class hbasemessagemapper .
public void canceltasknoexception ( task task ) { try { canceltask ( task ) ; } catch ( exception e ) { _log . error ( _str ) ; } }	cancels the vmware task without throwing an exception.
public string tostring ( ) { return toindentedstring ( _num ) ; }	returns an indented string representation of this element and any contained child elements .
public int read ( byte b [ ] , int off , int len ) throws ioexception , logexception { if ( length < len ) badread ( len ) ; len = in . read ( b , off , len ) ; length -= len ; return len ; }	reads data into an array of bytes.
public static void migratefrom6to7 ( sqlitedatabase db ) { string selectquery = _str + databasehelper . table_griditemrelations ; cursor c = db . rawquery ( selectquery , null ) ; if ( c . movetofirst ( ) ) { do { try { int griditemid = c . getint ( c . getcolumnindex ( databasehelper . key_id ) ) ; int pluginid = c . getint ( c . getcolumnindex ( databasehelper . key_griditemrelations_plugin ) ) ; string pluginpageurlquery = _str + databasehelper . key_muninplugins_pluginpageurl + _str + databasehelper . table_muninplugins + _str + databasehelper . key_id + _str + pluginid ; cursor c2 = db . rawquery ( pluginpageurlquery , null ) ; if ( c2 . movetofirst ( ) ) { string pluginpageurl = c2 . getstring ( c2 . getcolumnindex ( databasehelper . key_muninplugins_pluginpageurl ) ) ; contentvalues values = new contentvalues ( ) ; values . put ( databasehelper . key_griditemrelations_pluginpageurl , pluginpageurl ) ; db . update ( databasehelper . table_griditemrelations , values , databasehelper . key_id + _str , new string [ ] { string . valueof ( griditemid ) } ) ; } c2 . close ( ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; } } while ( c . movetonext ( ) ) ; } c . close ( ) ; }	from db version 7 , we began to store plugin page url in order to retrieve it whenever the plugin gets deleted.
@ override public void datasetchanged ( datasetchangeevent event ) { firedatasetchanged ( ) ; }	receives a change event from the underlying dataset and responds by firing a change event for this dataset .
public void drawingcomplete ( omgraphic omg , omaction action ) { if ( timerbutton . isselected ( ) ) { timer . restart ( ) ; } if ( omg instanceof ompoint ) { ompoint p = ( ompoint ) omg ; glpoint mp = new glpoint ( p . getlat ( ) , p . getlon ( ) , p . getradius ( ) , _bool ) ; mp . setname ( _str + ( pointcount ++ ) ) ; mp . setstationary ( _bool ) ; mp . showpalette ( ) ; points . put ( mp . getname ( ) , mp ) ; managegraphics ( ) ; } else if ( omg instanceof ompoly ) { ompoly poly = ( ompoly ) omg ; pathglpoint pmp = new pathglpoint ( poly , _num , _bool ) ; pmp . setname ( _str + ( pointcount ++ ) ) ; pmp . showpalette ( ) ; points . put ( pmp . getname ( ) , pmp ) ; managegraphics ( ) ; } addnodebutton . setenabled ( _bool ) ; addpathbutton . setenabled ( _bool ) ; }	the method where a graphic , and an action to take on the graphic , arrives .
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return cookie ; case _num : return user_id ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public charset charset ( ) { return charset != null ? charset . forname ( charset ) : null ; }	returns the charset of this media type , or null if this media type doesn ' t specify a charset .
public drivertask deletevolumemirror ( volumemirror mirror ) { log . info ( _str , mirror ) ; dellscdrivertask task = new dellscdrivertask ( _str ) ; try { storagecenterapi api = connectionmanager . getconnection ( mirror . getstoragesystemid ( ) ) ; sccopymirrormigrate cmm = api . getmirror ( mirror . getnativeid ( ) ) ; api . deletemirror ( cmm . instanceid ) ; api . deletevolume ( cmm . destinationvolume . instanceid ) ; task . setstatus ( taskstatus . ready ) ; } catch ( storagecenterapiexception | dellscdriverexception dex ) { string error = string . format ( _str , mirror . getnativeid ( ) , dex ) ; log . error ( error ) ; task . setfailed ( error ) ; } return task ; }	delete volume mirror and the destination volume .
public void testconnect_blocknoserver ( ) throws ioexception { connectwithoutserver ( ) ; disconnectafterconnected ( ) ; }	test method for ' datagramchannelimpl . connect ( socketaddress ) '.
public bytearraydataprovider ( byte [ ] bytes ) { this . bytes = arrays . copyof ( bytes , bytes . length ) ; }	instantiates a new mxf byte array data provider .
public static string generatenativeguidforphysicalnas ( string systemnativeguid , string pnasname ) { return string . format ( _str + physical_nas + _str , systemnativeguid , pnasname ) ; }	generates the nativeguid format as systemnativeguid + physicalnasname for physical nas .
private void expire ( ) { if ( m_expire != _num && m_timeexp < system . currenttimemillis ( ) ) { reset ( ) ; } }	expire cache if enabled.
private static int determineconsecutivebinarycount ( string msg , int startpos , charset encoding ) throws writerexception { final charsetencoder encoder = encoding . newencoder ( ) ; int len = msg . length ( ) ; int idx = startpos ; while ( idx < len ) { char ch = msg . charat ( idx ) ; int numericcount = _num ; while ( numericcount < _num && isdigit ( ch ) ) { numericcount ++ ; int i = idx + numericcount ; if ( i >= len ) { break ; } ch = msg . charat ( i ) ; } if ( numericcount >= _num ) { return idx - startpos ; } ch = msg . charat ( idx ) ; if ( ! encoder . canencode ( ch ) ) { throw new writerexception ( _str + ch + _str + ( int ) ch + _str ) ; } idx ++ ; } return idx - startpos ; }	determines the number of consecutive characters that are encodable using binary compaction .
private boolean apply ( gridclientpredicate < n > [ ] p , n n ) { if ( p != null ) { for ( gridclientpredicate < ? super n > r : p ) { if ( r != null && ! r . apply ( n ) ) return _bool ; } } return _bool ; }	apply predicate to the node .
public boolean hasname ( final string name ) { for ( final string n : names ) { if ( n . equalsignorecase ( name ) ) { return _bool ; } } return _bool ; }	indicates whether this schema definition has the specified name .
public void dup2x2 ( ) { mv . visitinsn ( opcodes . dup2_x2 ) ; }	generates a dup2_x2 instruction .
@ override public boolean contains ( object key ) { if ( key == null ) return _map . _nullvalue != null ; k1 [ ] keys = _map . _keys ; for ( int i = keys . length - _num ; i >= _num ; i -- ) { k1 testkey = keys [ i ] ; if ( key . equals ( testkey ) ) return _bool ; } return _bool ; }	returns true if the map contains the value .
public static void replacevalue ( exampleset exampleset , attribute attribute , string oldvalue , string newvalue ) { if ( ! attribute . isnominal ( ) ) { throw new runtimeexception ( _str ) ; } nominalmapping mapping = attribute . getmapping ( ) ; if ( oldvalue . equals ( _str ) ) { for ( example example : exampleset ) { if ( double . isnan ( example . getvalue ( attribute ) ) ) { example . setvalue ( attribute , mapping . mapstring ( newvalue ) ) ; } } } else { int oldindex = mapping . getindex ( oldvalue ) ; if ( oldindex < _num ) { throw new runtimeexception ( _str ) ; } if ( newvalue . equals ( _str ) ) { for ( example example : exampleset ) { int index = mapping . getindex ( example . getvalueasstring ( attribute ) ) ; if ( index == oldindex ) { example . setvalue ( attribute , double . nan ) ; } } return ; } int newindex = mapping . getindex ( newvalue ) ; if ( newindex >= _num ) { for ( example example : exampleset ) { int index = mapping . getindex ( example . getvalueasstring ( attribute ) ) ; if ( index == oldindex ) { example . setvalue ( attribute , newindex ) ; } } } else { mapping . setmapping ( newvalue , oldindex ) ; } } }	replaces the given value by the new one.
protected void encode ( bytesequenceswriter writer , bytearraydataoutput output , byte [ ] buffer , bytesref spare , bytesref payload , set < bytesref > contexts , long weight ) throws ioexception { int requiredlength = spare . length + _num + ( ( haspayloads ) ? _num + payload . length : _num ) ; if ( hascontexts ) { for ( bytesref ctx : contexts ) { requiredlength += _num + ctx . length ; } requiredlength += _num ; } if ( requiredlength >= buffer . length ) { buffer = arrayutil . grow ( buffer , requiredlength ) ; } output . reset ( buffer ) ; output . writebytes ( spare . bytes , spare . offset , spare . length ) ; if ( hascontexts ) { for ( bytesref ctx : contexts ) { output . writebytes ( ctx . bytes , ctx . offset , ctx . length ) ; output . writeshort ( ( short ) ctx . length ) ; } output . writeshort ( ( short ) contexts . size ( ) ) ; } if ( haspayloads ) { output . writebytes ( payload . bytes , payload . offset , payload . length ) ; output . writeshort ( ( short ) payload . length ) ; } output . writelong ( weight ) ; writer . write ( buffer , _num , output . getposition ( ) ) ; }	encodes an entry ( bytes + ( contexts ) + ( payload ) + weight ) to the provided writer.
private int skipquotedstring ( string str , int pos ) { int n = str . length ( ) ; pos += _num ; while ( pos < n ) { if ( str . charat ( pos ) == _str ) { if ( pos + _num < n && str . charat ( pos + _num ) == _str ) { pos += _num ; continue ; } return pos + _num ; } pos += _num ; } return n ; }	skips a quoted string , beginning at the index of the opening quote .
private datagrampacket [ ] encodemulticastrequest ( final multicastrequest req ) throws ioexception { final discovery disco = getdiscovery ( multicastrequestconstraints . chooseprotocolversion ( ) ) ; final list packets = new arraylist ( ) ; encodeiterator ei = disco . encodemulticastrequest ( req , multicastrequestconstraints . getmulticastmaxpacketsize ( default_max_packet_size ) , multicastrequestconstraints . getunfulfilledconstraints ( ) ) ; while ( ei . hasnext ( ) ) { try { packets . addall ( arrays . aslist ( ei . next ( ) ) ) ; } catch ( exception e ) { logger . log ( ( e instanceof unsupportedconstraintexception ) ? levels . handled : level . info , _str , e ) ; } } if ( packets . isempty ( ) ) { throw new discoveryprotocolexception ( _str ) ; } return ( datagrampacket [ ] ) packets . toarray ( new datagrampacket [ packets . size ( ) ] ) ; }	encodes outgoing multicast requests based on protocol in use , applying configured security constraints ( if any ) .
public featuretypeconstraintmodel ( featuretypeconstraintmodelupdateinterface parent ) { this . parentobj = parent ; columnlist . add ( localisation . getstring ( fieldconfigbase . class , _str ) ) ; columnlist . add ( localisation . getstring ( fieldconfigbase . class , _str ) ) ; }	instantiates a new feature type constraint model .
protected void deletedb ( string name ) { deletedb ( getbasedir ( ) , name ) ; }	delete all database files for this database .
private void pullevent ( ) { final int newscrollvalue ; final int itemdimension ; final float initialmotionvalue , lastmotionvalue ; switch ( getfilteredpulltorefreshscrolldirection ( ) ) { case horizontal : initialmotionvalue = minitialmotionx ; lastmotionvalue = mlastmotionx ; break ; case vertical : default : initialmotionvalue = minitialmotiony ; lastmotionvalue = mlastmotiony ; break ; } switch ( mcurrentmode ) { case pull_from_end : newscrollvalue = math . round ( math . max ( initialmotionvalue - lastmotionvalue , _num ) / mfriction ) ; itemdimension = getfootersize ( ) ; break ; case google_style : newscrollvalue = math . round ( math . min ( initialmotionvalue - lastmotionvalue , _num ) / mfriction ) ; itemdimension = getgooglestyleviewsize ( ) ; break ; case pull_from_start : default : newscrollvalue = math . round ( math . min ( initialmotionvalue - lastmotionvalue , _num ) / mfriction ) ; itemdimension = getheadersize ( ) ; break ; } setheaderscroll ( newscrollvalue ) ; if ( newscrollvalue != _num && ! isrefreshing ( ) ) { float scale = math . abs ( newscrollvalue ) / ( float ) itemdimension ; switch ( mcurrentmode ) { case pull_from_end : mfooterlayout . onpull ( scale ) ; break ; case google_style : mgooglestyleviewlayout . onpull ( scale ) ; mgooglestyleprogresslayout . onpull ( scale ) ; break ; case pull_from_start : default : mheaderlayout . onpull ( scale ) ; break ; } if ( mstate != state . pull_to_refresh && itemdimension >= math . abs ( newscrollvalue ) ) { setstate ( state . pull_to_refresh ) ; } else if ( mstate == state . pull_to_refresh && itemdimension < math . abs ( newscrollvalue ) ) { setstate ( state . release_to_refresh ) ; } } }	actions a pull event.
public statmonitorhandler ( ) { }	constructs a new statmonitorhandler instance.
public void addelements ( final double [ ] values ) { final double [ ] temparray = new double [ numelements + values . length + _num ] ; system . arraycopy ( internalarray , startindex , temparray , _num , numelements ) ; system . arraycopy ( values , _num , temparray , numelements , values . length ) ; internalarray = temparray ; startindex = _num ; numelements += values . length ; }	adds several element to the end of this expandable array .
@ override public enumeration < option > listoptions ( ) { vector < option > result = new vector < option > ( ) ; result . addelement ( new option ( _str + _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; result . addall ( collections . list ( super . listoptions ( ) ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
public map < uri , list < uri > > addsourcevolumesnapshots ( ) { list < uri > blocksnapshots = lists . newarraylist ( ) ; map < uri , list < uri > > snapshotsmap = new hashmap < > ( ) ; for ( uri volumeid : uris ( volumeids ) ) { list < uri > snapshots = getsnapshots ( volumeid ) ; blocksnapshots . addall ( snapshots ) ; snapshotsmap . put ( volumeid , snapshots ) ; } if ( ! blocksnapshots . isempty ( ) ) { blockstorageutils . addvolumestoconsistencygroup ( consistencygroup , blocksnapshots ) ; } return snapshotsmap ; }	adds all source volumes ' snapshots to the consistency group.
public static void loginitiator ( initiator initiator , networklite network ) { string networkname = ( network != null ? network . getlabel ( ) : _str ) ; _log . info ( string . format ( _str , initiator . getinitiatorport ( ) , initiator . gethostname ( ) , networkname ) ) ; }	emits an info message about an initiator containing the address , id , and network name .
public static final criterion and ( criterion one , criterion two ) { final list < criterion > criteria = new arraylist < criterion > ( ) ; criteria . add ( one ) ; criteria . add ( two ) ; return new conjunctioncriterion ( conjunction . and , criteria ) ; }	creates a filter composing the two different criteria .
public ccmenuitem ( object rec , string cb ) { targetcallback = rec ; selector = cb ; setanchorpoint ( cgpoint . make ( _num , _num ) ) ; invocation = null ; if ( rec != null && cb != null ) { class < ? > cls = rec . getclass ( ) ; try { invocation = cls . getmethod ( cb , object . class ) ; } catch ( securityexception e ) { e . printstacktrace ( ) ; } catch ( nosuchmethodexception e ) { e . printstacktrace ( ) ; } } isenabled_ = _bool ; isselected_ = _bool ; }	initializes a menu item with a target / selector.
public void addchildelement ( xmlelement child , boolean addafternewline ) throws exception { addchildelementat ( child , - _num , addafternewline ) ; }	appends the given child element to the end of the list of existing child elements .
public void edittext ( visualitem item , string attribute , rectangle r ) { if ( m_editing ) { stopediting ( ) ; } string txt = item . getstring ( attribute ) ; m_edititem = item ; m_editattribute = attribute ; color tc = colorlib . getcolor ( item . gettextcolor ( ) ) ; color fc = colorlib . getcolor ( item . getfillcolor ( ) ) ; m_editor . setforeground ( tc ) ; m_editor . setbackground ( fc ) ; edittext ( txt , r ) ; }	edit text for the given visualitem and field.
public static column column ( final string id , final string title , final int width , final int doubleprecision ) { return new column ( id , title , math . max ( width , title . length ( ) ) , doubleprecision ) ; }	creates a new column with the provided arguments .
public void printcount ( string kind , int count ) { if ( count != _num ) { string key ; if ( count == _num ) key = _str + kind ; else key = _str + kind + _str ; log . printlines ( writerkind . error , key , string . valueof ( count ) ) ; log . flush ( log . writerkind . error ) ; } }	print numbers of errors and warnings .
public static float screentoscroll ( float x , float warpsize ) { if ( x <= _num ) return _num ; if ( x >= warpsize ) return x + warpsize ; return ( float ) math . sqrt ( x * warpsize ) * _num ; }	unwarps x so it matches the above warp function .
public synchronized void recordstatistics ( querystatistic statistic ) { querystatistics . add ( statistic ) ; }	below method will be used to add the statistics.
protected double [ ] randomsubrange ( double boundstart , double boundlen ) { if ( boundlen >= _num && usually ( ) ) { int intboundstart = ( int ) math . ceil ( boundstart ) ; int intboundend = ( int ) ( boundstart + boundlen ) ; int intboundlen = intboundend - intboundstart ; int newlen = ( int ) randomgaussianmeanmax ( intboundlen / _num , intboundlen ) ; int newstart = intboundstart + randomint ( intboundlen - newlen ) ; return new double [ ] { newstart , newlen } ; } else { double newlen = randomgaussianmeanmax ( boundlen / _num , boundlen ) ; double newstart = boundstart + ( boundlen - newlen == _num ? _num : ( randomdouble ( ) % ( boundlen - newlen ) ) ) ; return new double [ ] { newstart , newlen } ; } }	returns new minstart and new length that is inside the range specified by the arguments .
private datetimezone generatetimezone ( string timezoneid , datetimezone systemtimezone ) { if ( timezoneid == null ) { return systemtimezone ; } try { return datetimezone . forid ( timezoneid ) ; } catch ( illegalargumentexception ignored ) { log . debug ( invalid_time_zone . logformat ( timezoneid ) ) ; throw new badapirequestexception ( invalid_time_zone . format ( timezoneid ) ) ; } }	get the timezone for the request .
protected string tostring ( string [ ] [ ] strings ) { int rows = strings . length ; int columns = strings . length <= _num ? _num : strings [ _num ] . length ; stringbuffer total = new stringbuffer ( ) ; stringbuffer s = new stringbuffer ( ) ; for ( int row = _num ; row < rows ; row ++ ) { s . setlength ( _num ) ; for ( int column = _num ; column < columns ; column ++ ) { s . append ( strings [ row ] [ column ] ) ; if ( column < columns - _num ) s . append ( columnseparator ) ; } total . append ( s ) ; if ( row < rows - _num ) total . append ( rowseparator ) ; } return total . tostring ( ) ; }	returns a single string representation of the given string matrix .
public void checkwarehouse ( boolean sbf ) { if ( warehouse == null ) { logger . fine ( _str ) ; warehouse = new vpfautofeaturegraphicwarehouse ( ) ; } }	if the warehouse gets set as a result of this method being called , the properties will beed to be reset on it .
public double maxdist ( spatialcomparable mbr1 , spatialcomparable mbr2 ) { final int dim1 = mbr1 . getdimensionality ( ) , dim2 = mbr2 . getdimensionality ( ) ; final int mindim = ( dim1 < dim2 ) ? dim1 : dim2 ; double agg = _num ; for ( int d = _num ; d < mindim ; d ++ ) { double d1 = mbr1 . getmax ( d ) - mbr2 . getmin ( d ) ; double d2 = mbr2 . getmax ( d ) - mbr1 . getmin ( d ) ; double delta = d1 > d2 ? d1 : d2 ; agg += delta * delta ; } for ( int d = mindim ; d < dim1 ; d ++ ) { double d1 = math . abs ( mbr1 . getmin ( d ) ) , d2 = math . abs ( mbr1 . getmax ( d ) ) ; double delta = d1 > d2 ? d1 : d2 ; agg += delta * delta ; } for ( int d = mindim ; d < dim2 ; d ++ ) { double d1 = math . abs ( mbr2 . getmin ( d ) ) , d2 = math . abs ( mbr2 . getmax ( d ) ) ; double delta = d1 > d2 ? d1 : d2 ; agg += delta * delta ; } return math . sqrt ( agg ) ; }	maximum distance of two objects .
public static void createlesson ( @ notnull final lesson lesson , @ notnull final virtualfile coursedir , @ notnull final file resourceroot , @ notnull final project project ) throws ioexception { string lessondirname = edunames . lesson + integer . tostring ( lesson . getindex ( ) ) ; virtualfile lessondir = coursedir . createchilddirectory ( project , lessondirname ) ; final list < task > tasklist = lesson . gettasklist ( ) ; for ( int i = _num ; i <= tasklist . size ( ) ; i ++ ) { task task = tasklist . get ( i - _num ) ; task . setindex ( i ) ; createtask ( task , lessondir , new file ( resourceroot , lessondir . getname ( ) ) , project ) ; } }	creates lesson directory in its course folder in project user created.
protected void rehash ( ) { int oldcapacity = table . length ; cacheentry oldtable [ ] = table ; int newcapacity = oldcapacity * _num + _num ; cacheentry newtable [ ] = new cacheentry [ newcapacity ] ; threshold = ( int ) ( newcapacity * loadfactor ) ; table = newtable ; for ( int i = oldcapacity ; i -- > _num ; ) { for ( cacheentry old = oldtable [ i ] ; old != null ; ) { cacheentry e = old ; old = old . next ; if ( e . check ( ) != null ) { int index = ( e . hash & _num ) % newcapacity ; e . next = newtable [ index ] ; newtable [ index ] = e ; } else count -- ; } } }	rehashes the contents of the table into a bigger table.
public void append ( byte [ ] utf8 , int start , int len ) { setcapacity ( length + len , _bool ) ; system . arraycopy ( utf8 , start , bytes , length , len ) ; length += len ; }	append a range of bytes to the end of the given text.
private void handleerror ( gcpstatsdataholder statsdata , throwable e ) { logsevere ( e ) ; statsdata . error = e ; statsdata . stage = statscollectionstage . error ; handlestatsrequest ( statsdata ) ; }	error handler for gcpstatsservice .
public java . lang . stringbuilder insert ( int offset , double d ) { return insert ( offset , double . tostring ( d ) ) ; }	inserts the string representation of the double argument into this string buffer.
public static boolean aremscapistoressupported ( ) { return security . getprovider ( ms_capi . jce ( ) ) != null ; }	are mscapi stores supported ?.
public boolean ispassthroughsupported ( string mimetype ) { return audiocapabilities != null && audiocapabilities . supportsencoding ( getencodingformimetype ( mimetype ) ) ; }	returns whether it is possible to play back input audio in the specified format using encoded audio passthrough .
string internalsprintf ( final object s ) { final string s2 ; if ( conversioncharacter == _str || conversioncharacter == _str ) { s2 = printsformat ( s . tostring ( ) ) ; } else { throw new illegalargumentexception ( _str + _str + conversioncharacter + _str ) ; } return s2 ; }	format an object argument using this conversion specification .
public t firstitem ( ) { if ( mdatalist == null || mdatalist . size ( ) == _num ) { return null ; } return mdatalist . get ( _num ) ; }	the first item in list.
public void addrequestproperty ( string field , string newvalue ) { checknotconnected ( ) ; if ( field == null ) { throw new nullpointerexception ( _str ) ; } }	adds the given property to the request header.
public double dooperation ( ) throws operatorfailedexception { double [ ] mean = sccs . getmode ( ) ; double [ ] currentvalue = parameter . getparametervalues ( ) ; double [ ] newvalue = new double [ dim ] ; set < integer > updateset = new hashset < integer > ( ) ; if ( setsizemean != - _num ) { final int listlength = poisson . nextpoisson ( setsizemean ) ; while ( updateset . size ( ) < listlength ) { int newint = mathutils . nextint ( parameter . getdimension ( ) ) ; if ( ! updateset . contains ( newint ) ) { updateset . add ( newint ) ; } } } else { for ( int i = _num ; i < dim ; ++ i ) { updateset . add ( i ) ; } } double logq = _num ; for ( integer i : updateset ) { newvalue [ i ] = mean [ i ] + scalefactor * mathutils . nextgaussian ( ) ; if ( update_all ) { parameter . setparametervaluequietly ( i , newvalue [ i ] ) ; } else { parameter . setparametervalue ( i , newvalue [ i ] ) ; } logq += ( normaldistribution . logpdf ( currentvalue [ i ] , mean [ i ] , scalefactor ) - normaldistribution . logpdf ( newvalue [ i ] , mean [ i ] , scalefactor ) ) ; } if ( update_all ) { parameter . setparametervaluenotifychangedall ( _num , parameter . getparametervalue ( _num ) ) ; } return logq ; }	change the parameter and return the hastings ratio .
public object load ( uri uri ) throws ioexception { inputstreamreader src = null ; try { src = new filereader ( new file ( uri ) ) ; return xstream . fromxml ( src ) ; } finally { if ( null != src ) { src . close ( ) ; } } }	load an object from the provided uri .
private synchronized void sendpendingstate ( ) { if ( ! mpendingclients . isempty ( ) ) { final message [ ] messages = new message [ ] { santaservicemessages . getbeginfullstatemessage ( ) , santaservicemessages . getswitchoffmessage ( mpreferences . getswitchoff ( ) ) , gettimeupdatemessage ( ) , santaservicemessages . getcastdisabledmessage ( mpreferences . getcastdisabled ( ) ) , santaservicemessages . getgamesmessage ( mpreferences . getgumballdisabled ( ) , mpreferences . getjetpackdisabled ( ) , mpreferences . getmemorydisabled ( ) , mpreferences . getrocketdisabled ( ) , mpreferences . getdancerdisabled ( ) , mpreferences . getsnowdowndisabled ( ) ) , santaservicemessages . getdestinationphotomessage ( mpreferences . getdestinationphotodisabled ( ) ) , santaservicemessages . getstatemessage ( mstate ) , santaservicemessages . getvideosmessage ( mpreferences . getvideos ( ) ) } ; for ( int i = _num ; i < mpendingclients . size ( ) ; i ++ ) { final messenger messenger = mpendingclients . get ( i ) ; try { for ( message msg : messages ) { messenger . send ( msg ) ; } mclients . add ( messenger ) ; } catch ( remoteexception e ) { } mpendingclients . remove ( i ) ; } } }	send the current state of the application to all pending clients .
private void fetchchunk ( bulkidparam input , list < t > results ) { list < t > items = getbulkresources ( input ) ; for ( t item : items ) { results . add ( item ) ; } }	fetches a chunk and filters ( if required ) .
public static void movedirectorytodirectory ( file src , file destdir , boolean createdestdir ) throws ioexception { if ( src == null ) { throw new nullpointerexception ( _str ) ; } if ( destdir == null ) { throw new nullpointerexception ( _str ) ; } if ( ! destdir . exists ( ) && createdestdir ) { destdir . mkdirs ( ) ; } if ( ! destdir . exists ( ) ) { throw new filenotfoundexception ( _str + destdir + _str + createdestdir + _str ) ; } if ( ! destdir . isdirectory ( ) ) { throw new ioexception ( _str + destdir + _str ) ; } movedirectory ( src , new file ( destdir , src . getname ( ) ) ) ; }	moves a directory to another directory .
public static responsedata parse ( string responsedata ) { int index = responsedata . indexof ( _str ) ; string maindata , extradata ; if ( - _num == index ) { maindata = responsedata ; extradata = _str ; } else { maindata = responsedata . substring ( _num , index ) ; extradata = index >= responsedata . length ( ) ? _str : responsedata . substring ( index + _num ) ; } string [ ] fields = textutils . split ( maindata , pattern . quote ( _str ) ) ; if ( fields . length < _num ) { throw new illegalargumentexception ( ) ; } responsedata data = new responsedata ( ) ; data . extra = extradata ; data . responsecode = integer . parseint ( fields [ _num ] ) ; data . nonce = integer . parseint ( fields [ _num ] ) ; data . packagename = fields [ _num ] ; data . versioncode = fields [ _num ] ; data . userid = fields [ _num ] ; data . timestamp = long . parselong ( fields [ _num ] ) ; return data ; }	parses response string into responsedata .
public int nooftabs ( ) { return m_curwintab . gettabcount ( ) ; }	get the number of tabs in the panels jtabbedpane .
public void testexceptionally_exceptionalcompletionactionfailed ( ) { for ( boolean createincomplete : new boolean [ ] { _bool , _bool } ) { final atomicinteger a = new atomicinteger ( _num ) ; final cfexception ex1 = new cfexception ( ) ; final cfexception ex2 = new cfexception ( ) ; final completablefuture < integer > f = new completablefuture < > ( ) ; if ( ! createincomplete ) f . completeexceptionally ( ex1 ) ; final completablefuture < integer > g = f . exceptionally ( null ) ; if ( createincomplete ) f . completeexceptionally ( ex1 ) ; checkcompletedwithwrappedexception ( g , ex2 ) ; checkcompletedexceptionally ( f , ex1 ) ; assertequals ( _num , a . get ( ) ) ; } }	if an " exceptionally action " throws an exception , it completes exceptionally with that exception.
private static void close ( closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( ioexception e ) { } } }	convenience method to close the closeable object and ignore the exception being thrown if there is one .
public static string converttimestamptodatestringcompact ( boolean useutc , long milli ) { date date = new date ( milli ) ; simpledateformat sourceformat = new simpledateformat ( _str ) ; sourceformat . settimezone ( useutc ? timezone . gettimezone ( _str ) : timezone . getdefault ( ) ) ; return sourceformat . format ( date ) ; }	convert a timestamp in milliseconds into a human readable string format.
public final double tanhalfangle ( ) { return math . tan ( _num * this . radians ) ; }	obtains the tangent of half of this angle .
abstract future < asynchronoussocketchannel > implaccept ( object attachment , completionhandler < asynchronoussocketchannel , object > handler ) ;	invoked by accept to accept connection.
public void parsesignaturesfile ( url url ) throws ioexception , parseexception { parsesignaturesfile ( url . openstream ( ) , url . tostring ( ) ) ; }	reads a list of api signatures from the given url .
public void addflare ( flare flare ) { flares . addelement ( flare ) ; processgameevent ( new gameboardchangeevent ( this ) ) ; }	add a new flare.
public static void objectstringnonrecursive ( @ unretained object obj , stringbuilder sb ) { if ( obj instanceof object [ ] ) { sb . append ( _str ) ; boolean first = _bool ; for ( object o : ( object [ ] ) obj ) { if ( ! first ) { sb . append ( _str ) ; sb . append ( o ) ; } else { first = _bool ; objectstringwithbytes ( o , sb ) ; } } sb . append ( _str ) ; } else { objectstringwithbytes ( obj , sb ) ; } }	get proper string for an an object including arrays with upto one dimension of arrays .
public void readosm ( file file ) { if ( file . exists ( ) ) { streetlayer . openosm ( file ) ; } else { log . info ( _str ) ; } }	opens osm mapdb database if it exists otherwise it prints a warning osm mapdb is used for names of streets.
public void startelement ( stylesheethandler handler , string uri , string localname , string rawname , attributes attributes ) throws saxexception { string msg = _str ; if ( ! ( handler . getelemtemplateelement ( ) instanceof stylesheet ) ) { msg = _str ; handler . error ( msg , new saxexception ( msg ) ) ; } super . startelement ( handler , uri , localname , rawname , attributes ) ; string val = attributes . getvalue ( _str ) ; int indexofcolon = val . indexof ( _str ) ; if ( indexofcolon > _num ) { } else { msg = _str ; handler . error ( msg , new saxexception ( msg ) ) ; } }	start an elemexsltfunction . verify that it is top level and that it has a name attribute with a namespace .
public void write ( byte [ ] buffer , int offset , int length ) throws ioexception { _file . write ( buffer , offset , length ) ; }	writes a block starting from the current file pointer .
public static boolean caninteract ( role issuer , role target ) { if ( issuer . getguild ( ) != target . getguild ( ) ) throw new illegalargumentexception ( _str ) ; return target . getposition ( ) < issuer . getposition ( ) ; }	checks if one given role can interact with a 2nd given role - in a permission sense ( kick / ban / modify perms ).
public webster ( ) throws bindexception { this . port = integer . getinteger ( webster_port , _num ) ; initialize ( ) ; }	create a new webster.
public boolean willthrowexceptionifkeywasnotfound ( ) { return throwex ; }	test whether formatter will throw exception if object for key was not found.
public void testcomputelocationwhenuberwarpackaging ( ) throws exception { deployable deployableelement = new deployable ( ) ; deployableelement . setgroupid ( _str ) ; deployableelement . setartifactid ( _str ) ; deployableelement . settype ( _str ) ; string location = deployableelement . computelocation ( createdefaultproject ( _str , null ) ) ; asserttrue ( location . endswith ( _str ) ) ; }	test compute location for uberwars .
public response createresponse ( string responsestring ) throws java . text . parseexception { if ( responsestring == null ) return new sipresponse ( ) ; stringmsgparser smp = new stringmsgparser ( ) ; sipmessage sipmessage = smp . parsesipmessage ( responsestring . getbytes ( ) , _bool , _bool , null ) ; if ( ! ( sipmessage instanceof sipresponse ) ) throw new parseexception ( responsestring , _num ) ; return ( sipresponse ) sipmessage ; }	create a response from a string.
private odestateandderivative state ( double t ) { return new odestateandderivative ( t , new double [ _num ] , new double [ _num ] ) ; }	create a state at a time .
public static class < ? > findcommonelementtype ( collection collection ) { if ( isempty ( collection ) ) { return null ; } class < ? > candidate = null ; for ( object val : collection ) { if ( val != null ) { if ( candidate == null ) { candidate = val . getclass ( ) ; } else if ( candidate != val . getclass ( ) ) { return null ; } } } return candidate ; }	find the common element type of the given collection , if any .
private static void decodehanzisegment ( bitsource bits , stringbuilder result , int count ) throws formatexception { if ( count * _num > bits . available ( ) ) { throw formatexception . getformatinstance ( ) ; } byte [ ] buffer = new byte [ _num * count ] ; int offset = _num ; while ( count > _num ) { int twobytes = bits . readbits ( _num ) ; int assembledtwobytes = ( ( twobytes / _num ) << _num ) | ( twobytes % _num ) ; if ( assembledtwobytes < _num ) { assembledtwobytes += _num ; } else { assembledtwobytes += _num ; } buffer [ offset ] = ( byte ) ( ( assembledtwobytes > > _num ) & _num ) ; buffer [ offset + _num ] = ( byte ) ( assembledtwobytes & _num ) ; offset += _num ; count -- ; } try { result . append ( new string ( buffer , stringutils . gb2312 ) ) ; } catch ( unsupportedencodingexception uee ) { throw formatexception . getformatinstance ( ) ; } }	see specification gbt 18284 - 2000.
protected void initpingintervalmilli ( ) { string pingintervalmilliparam = getinitparameter ( _str ) ; setpingintervalmilli ( ( pingintervalmilliparam == null ) ? default_ping_interval_milli : integer . parseint ( pingintervalmilliparam ) ) ; if ( isdebug ( ) ) { log ( _str + getpingintervalmilli ( ) ) ; } }	initializer for property pingintervalmilli .
public boolean ask ( final string querystr , string externalqueryid ) throws exception { final repositoryconnection cxn = cxn ( ) ; uuid queryid = null ; try { final booleanquery query = ( booleanquery ) cxn . preparebooleanquery ( querylanguage . sparql , querystr ) ; setmaxquerytime ( query ) ; if ( query instanceof bigdatasailbooleanquery && cxn instanceof bigdatasailrepositoryconnection ) { final bigdatasailbooleanquery bdtq = ( bigdatasailbooleanquery ) query ; queryid = setupquery ( ( bigdatasailrepositoryconnection ) cxn , bdtq . getastcontainer ( ) , querytype . ask , externalqueryid ) ; } final boolean result = query . evaluate ( ) ; return result ; } finally { if ( queryid != null ) { finalizequery ( queryid ) ; } } }	select results using a sparql query .
@ suppresswarnings ( _str ) private static int find ( object [ ] arr , net . sourceforge . retroweaver . harmony . runtime . java . lang . comparable val , int bnd , int l , int r ) { int m = l ; int d = _num ; while ( m <= r ) { if ( val . compareto ( arr [ m ] ) > bnd ) { l = m + _num ; } else { r = m - _num ; break ; } m += d ; d <<= _num ; } while ( l <= r ) { m = ( l + r ) > > > _num ; if ( val . compareto ( arr [ m ] ) > bnd ) { l = m + _num ; } else { r = m - _num ; } } return l - _num ; }	finds the place in the given range of specified sorted array , where the element should be inserted for getting sorted array.
public static string ashex ( byte [ ] bytes , string separator ) { stringbuilder sb = new stringbuilder ( ) ; for ( int i = _num ; i < bytes . length ; i ++ ) { string code = integer . tohexstring ( bytes [ i ] & _num ) ; if ( ( bytes [ i ] & _num ) < _num ) { sb . append ( _str ) ; } sb . append ( code ) ; if ( separator != null && i < bytes . length - _num ) { sb . append ( separator ) ; } } return sb . tostring ( ) ; }	returns a hexadecimal representation of the given byte array .
public void runtest ( ) throws throwable { document doc ; nodelist elementlist ; node namenode ; characterdata child ; string badstring ; doc = ( document ) load ( _str , _bool ) ; elementlist = doc . getelementsbytagname ( _str ) ; namenode = elementlist . item ( _num ) ; child = ( characterdata ) namenode . getfirstchild ( ) ; { boolean success = _bool ; try { badstring = child . substringdata ( _num , _num ) ; } catch ( domexception ex ) { success = ( ex . code == domexception . index_size_err ) ; } asserttrue ( _str , success ) ; } }	runs the test case .
public string tostring ( ) { return string . valueof ( val ) ; }	returns the string representing the object .
private static void callstaticvoidmethodv ( jnienvironment env , int classjref , int methodid , address argaddress ) throws exception { if ( tracejni ) vm . syswrite ( _str ) ; runtimeentrypoints . checkjnicountdowntogc ( ) ; try { jnihelpers . invokewithvararg ( methodid , argaddress , typereference . void ) ; } catch ( throwable unexpected ) { if ( tracejni ) unexpected . printstacktrace ( system . err ) ; env . recordexception ( unexpected ) ; } }	callstaticvoidmethoda : invoke a static method that returns void.
public static connection createconnection ( boolean autocommit , int trxlevel ) { connection conn = s_cc . getconnection ( autocommit , trxlevel ) ; if ( clogmgt . islevelfinest ( ) ) { } try { if ( conn != null && conn . getautocommit ( ) != autocommit ) { throw new illegalstateexception ( _str + autocommit + _str ) ; } } catch ( sqlexception e ) { } return conn ; }	create new connection . the connection must be closed explicitly by the application.
private boolean updatestatementdata ( statementdata sdata , matcher matcher , string toregex ) { if ( transformtables ) return _bool ; if ( matcher == null ) return _bool ; string schema = sdata . getdefaultschema ( ) ; if ( schema == null ) return _bool ; matcher . reset ( schema ) ; if ( matcher . matches ( ) ) { string oldschema = schema ; sdata . setdefaultschema ( matcher . replaceall ( toregex ) ) ; if ( logger . isdebugenabled ( ) ) logger . debug ( _str + oldschema + _str + sdata . getdefaultschema ( ) ) ; return _bool ; } return _bool ; }	updatestatementdata updates the schema name of the given statementdata object if it matches the regular expression.
public void stopifrequired ( ) { if ( system . currenttimemillis ( ) > stopat ) { throw new illegalstateexception ( ) ; } }	check if it ' s time to stop processing.
private void linkaccount ( final string principalid , final nameid nameid ) throws saml2metaexception , authenticationexception { final string spentityid = metamanager . getentitybymetaalias ( metaalias ) ; try { nameidinfo info = new nameidinfo ( spentityid , entityname , nameid , saml2constants . sp_role , _bool ) ; debug . message ( _str , principalid , nameid . getvalue ( ) ) ; if ( shouldpersistnameid ( spentityid ) ) { accountutils . setaccountfederation ( info , principalid ) ; } principal = new saml2principal ( principalid ) ; } catch ( saml2exception e ) { throw new authenticationexception ( bundle_name , _str , new object [ _num ] ) ; } }	links saml2 accounts once all local auth steps have completed and we have a local principalid , sets the local principal to a new saml2pricipal with that id .
private void enableactions ( ) { restoreaction . setenabled ( frame . ismaximum ( ) || frame . isicon ( ) ) ; maximizeaction . setenabled ( ( frame . ismaximizable ( ) && ! frame . ismaximum ( ) && ! frame . isicon ( ) ) || ( frame . ismaximizable ( ) && frame . isicon ( ) ) ) ; iconifyaction . setenabled ( frame . isiconifiable ( ) && ! frame . isicon ( ) ) ; closeaction . setenabled ( frame . isclosable ( ) ) ; sizeaction . setenabled ( _bool ) ; moveaction . setenabled ( _bool ) ; }	set the enable / disabled state for the buttons .
private list < string > addrules ( int filterid , list < string > rules , boolean usecosmetics ) { inputstream inputstream = null ; inputstreamreader inputstreamreader = null ; bufferedreader reader = null ; try { string filename = getorcreatefilterfile ( filterid ) ; inputstream = context . openfileinput ( filename ) ; inputstreamreader = new inputstreamreader ( inputstream ) ; reader = new bufferedreader ( inputstreamreader ) ; string line = reader . readline ( ) ; while ( line != null ) { if ( usecosmetics || ! filterrule . iscosmeticrule ( line ) ) { rules . add ( line ) ; } line = reader . readline ( ) ; } return rules ; } catch ( exception ex ) { log . error ( _str , filterid , ex ) ; throw new runtimeexception ( _str + filterid , ex ) ; } finally { ioutils . closequietly ( inputstream ) ; ioutils . closequietly ( inputstreamreader ) ; ioutils . closequietly ( reader ) ; } }	adds rules from the specified filter to the list.
public static string converttohexstring ( byte [ ] bytes ) { int size = bytes . length ; stringbuffer buffer = new stringbuffer ( size * _num ) ; for ( int i = _num ; i < size ; i ++ ) { int x = bytes [ i ] ; if ( x < _num ) x += _num ; string tmp = integer . tohexstring ( x ) ; if ( tmp . length ( ) == _num ) buffer . append ( _str ) ; buffer . append ( tmp ) ; } return buffer . tostring ( ) ; }	convert byte array to hex string.
public orderedtask ( string identifier , step ... steps ) { this ( identifier , arrays . aslist ( steps ) ) ; }	returns an initialized ordered task using the specified identifier and array of steps .
public void randomize ( list < cellindex > cellindices ) { random rand = new random ( ) ; int range = getupperbound ( ) - getlowerbound ( ) ; for ( cellindex cellindex : cellindices ) { int row = cellindex . row ; int col = cellindex . col ; double value = ( rand . nextdouble ( ) * range ) + getlowerbound ( ) ; setlogicalvalue ( row , col , value , _bool ) ; } firetabledatachanged ( ) ; }	randomize neurons within specified bounds .
public void addauditory ( int id ) { mauditoryfeedback . add ( id ) ; }	adds auditory feedback to this utterance .
public static void constantattributes ( simplemethod method , element element , string ... attributenames ) throws validationexception { for ( string name : attributenames ) { string attributevalue = element . getattribute ( name ) ; if ( ! minilangutil . isconstantattribute ( attributevalue ) ) { handleerror ( _str + name + _str , method , element ) ; } } }	tests if element attributes are constant type .
private void bindviewtype ( wxcomponent component ) { int id = generateviewtype ( component ) ; if ( mviewtypes == null ) { mviewtypes = new sparsearray < > ( ) ; } arraylist < wxcomponent > mtypes = mviewtypes . get ( id ) ; if ( mtypes == null ) { mtypes = new arraylist < > ( ) ; mviewtypes . put ( id , mtypes ) ; } mtypes . add ( component ) ; }	viewtype will be classified into { hashmap < integer , arraylist < integer > > mviewtypes }.
protected boolean isemptyvalue ( object rawvalue ) { return rawvalue == null || stringutils . isblank ( string . valueof ( rawvalue ) ) ; }	check if raw value is empty .
public ciphertextivmac ( byte [ ] c , byte [ ] i , byte [ ] h ) { ciphertext = new byte [ c . length ] ; system . arraycopy ( c , _num , ciphertext , _num , c . length ) ; iv = new byte [ i . length ] ; system . arraycopy ( i , _num , iv , _num , i . length ) ; mac = new byte [ h . length ] ; system . arraycopy ( h , _num , mac , _num , h . length ) ; }	construct a new bundle of ciphertext and iv .
public static masterprivatekey createfromencryptedseed ( string passphrase , byte [ ] encryptedseed ) throws hyperledgerexception { try { byte [ ] key = scrypt . generate ( passphrase . getbytes ( _str ) , bitcoin_seed , _num , _num , _num , _num ) ; secretkeyspec keyspec = new secretkeyspec ( key , _str ) ; if ( encryptedseed . length != _num ) { throw new hyperledgerexception ( _str ) ; } cipher cipher = cipher . getinstance ( _str , _str ) ; cipher . init ( cipher . decrypt_mode , keyspec ) ; return create ( cipher . dofinal ( encryptedseed ) ) ; } catch ( unsupportedencodingexception | nosuchpaddingexception | nosuchproviderexception | nosuchalgorithmexception | invalidkeyexception | badpaddingexception | illegalblocksizeexception e ) { throw new hyperledgerexception ( e ) ; } }	create a masterprivatekey from a seed , that is assumed to be encrypted.
public static list < jsonpointer > filter ( final string ... fields ) { final list < jsonpointer > result = new arraylist < > ( fields . length ) ; for ( final string field : fields ) { result . add ( new jsonpointer ( field ) ) ; } return result ; }	creates a list of json pointers from the provided string representations .
public boolean applyftproxy ( ) { return method . isannotationpresent ( astrixfaulttoleranceproxy . class ) ; }	if true , then a fault tolerance proxy should be applies to a library bean .
private void notifychange ( int previous , int current ) { msoundplayer . play ( msoundid , _num , _num , _num , _num , _num ) ; if ( monvaluechangelistener != null ) { monvaluechangelistener . onvaluechange ( this , previous , mvalue ) ; } }	notifies the listener , if registered , of a change of the value of this numberpicker .
public int count ( ) { return comments == null ? _num : comments . size ( ) ; }	return the number of comments.
private boolean isanypackagefromlistinstalled ( list < string > packages ) { boolean result = _bool ; packagemanager pm = mcontext . getpackagemanager ( ) ; for ( string packagename : packages ) { try { pm . getpackageinfo ( packagename , _num ) ; qlog . e ( packagename + _str ) ; result = _bool ; } catch ( packagemanager . namenotfoundexception e ) { continue ; } } return result ; }	check if any package in the list is installed.
public static string makesystemname ( string type , int bitnum ) { string nname = _str ; if ( ( ! type . equals ( _str ) ) && ( ! type . equals ( _str ) ) && ( ! type . equals ( _str ) ) ) { log . error ( _str + type ) ; return ( nname ) ; } if ( ( bitnum < _num ) || ( ( type . equals ( _str ) ) && ( bitnum > _num ) ) || ( bitnum > _num ) ) { log . error ( _str + bitnum ) ; return ( nname ) ; } nname = _str + type + integer . tostring ( bitnum ) ; return ( nname ) ; }	public static method to construct a system name from type character and bit number < p > this routine returns a system name in the clxxxx , ctxxxx , or csxxxx format.
public static void remove ( ) { auth_token . remove ( ) ; }	deletes the user id .
public abstract boolean conflicts ( copyjob other ) ;	return true if this job is trying to copy any of the same files as the other job.
public treenode deserialize ( string data ) { deque < string > nodes = new linkedlist < > ( ) ; nodes . addall ( arrays . aslist ( data . split ( spliter ) ) ) ; return buildtree ( nodes ) ; }	recursive . same as pre - order traversal . split data and create a queue of string values first . each time , poll a node from the queue , create the current root . then build left and right subtree recursively .
public void fill ( int fromindex , int toindex , short val ) { if ( toindex > _pos ) { ensurecapacity ( toindex ) ; _pos = toindex ; } arrays . fill ( _data , fromindex , toindex , val ) ; }	fills a range in the list with the specified value .
private void runpendingrequests ( ) { int maxstartid = - _num ; billingrequest request ; while ( ( request = mpendingrequests . peek ( ) ) != null ) { if ( request . runifconnected ( ) ) { mpendingrequests . remove ( ) ; if ( maxstartid < request . getstartid ( ) ) { maxstartid = request . getstartid ( ) ; } } else { bindtomarketbillingservice ( ) ; return ; } } if ( maxstartid >= _num ) { if ( consts . debug ) { log . i ( tag , _str + maxstartid ) ; } stopself ( maxstartid ) ; } }	runs any pending requests that are waiting for a connection to the service to be established.
public static void removeattributedefaultvalues ( string servicename , string schematype , string attrname , set defaultvalues , boolean isorgattrschema ) throws upgradeexception { string classmethod = _str ; serviceschema ss = null ; if ( debug . messageenabled ( ) ) { debug . message ( classmethod + _str + servicename ) ; debug . message ( classmethod + _str + schematype ) ; debug . message ( classmethod + _str + attrname ) ; debug . message ( classmethod + _str + defaultvalues ) ; debug . message ( classmethod + _str + isorgattrschema ) ; } try { if ( isorgattrschema ) { serviceschemamanager sm = getserviceschemamanager ( servicename ) ; ss = sm . getorganizationcreationschema ( ) ; } else { ss = getserviceschema ( servicename , null , schematype ) ; } if ( ss != null ) { attributeschema attrschema = ss . getattributeschema ( attrname ) ; for ( iterator i = defaultvalues . iterator ( ) ; i . hasnext ( ) ; ) { string defaultvalue = ( string ) i . next ( ) ; attrschema . removedefaultvalue ( defaultvalue ) ; } } } catch ( smsexception sme ) { debug . error ( classmethod + _str , sme ) ; } catch ( ssoexception ssoe ) { debug . error ( classmethod + _str , ssoe ) ; } }	removes attribute default values from service schema .
public void unlock ( final t tx ) { if ( debug ) log . debug ( _str ) ; lock . lock ( ) ; if ( debug ) log . debug ( _str ) ; try { assertnotdead ( ) ; assertownslock ( tx ) ; if ( queue . remove ( ) != tx ) { throw new assertionerror ( ) ; } if ( waitsfor != null ) { final iterator < t > itr = queue . iterator ( ) ; synchronized ( waitsfor ) { while ( itr . hasnext ( ) ) { final t pendingtx = itr . next ( ) ; try { waitsfor . removeedge ( pendingtx , tx ) ; } catch ( throwable t ) { log . warn ( t . getmessage ( ) , t ) ; } } } } if ( queue . isempty ( ) ) { if ( info ) log . info ( _str ) ; return ; } if ( info ) log . info ( _str ) ; available . signalall ( ) ; } finally { lock . unlock ( ) ; if ( debug ) log . debug ( _str ) ; } }	release the lock held by the tx on the resource .
public boolean isupdateavailable ( ) { return availableupdate != null ; }	inform whether an update is available for this component .
@ override public string tostringsummary ( ) { string result ; string titles ; int resultsetlength ; int i ; int j ; if ( m_nonsigwins == null ) { return _str ; } result = _str ; titles = _str ; resultsetlength = _num + math . max ( ( int ) ( math . log ( getcolcount ( ) ) / math . log ( _num ) ) , ( int ) ( math . log ( getrowcount ( ) ) / math . log ( _num ) ) ) ; for ( i = _num ; i < getcolcount ( ) ; i ++ ) { if ( getcolhidden ( i ) ) { continue ; } titles += _str + utils . padleft ( _str + getsummarytitle ( i ) , resultsetlength * _num + _num ) ; } result += titles + _str ; for ( i = _num ; i < getcolcount ( ) ; i ++ ) { if ( getcolhidden ( i ) ) { continue ; } for ( j = _num ; j < getcolcount ( ) ; j ++ ) { if ( getcolhidden ( j ) ) { continue ; } result += _str ; if ( j == i ) { result += utils . padleft ( _str , resultsetlength * _num + _num ) ; } else { result += utils . padleft ( _str + m_nonsigwins [ i ] [ j ] + _str + m_wins [ i ] [ j ] + _str , resultsetlength * _num + _num ) ; } } result += _str + getsummarytitle ( i ) + _str + getcolname ( i ) + _str ; } return result ; }	returns the summary as string .
public int read ( bufferedinputstream is ) { init ( ) ; if ( is != null ) { in = is ; readheader ( ) ; if ( ! err ( ) ) { readcontents ( ) ; if ( framecount < _num ) { status = status_format_error ; } } } else { status = status_open_error ; } try { is . close ( ) ; } catch ( ioexception e ) { } return status ; }	reads gif image from stream.
private static int determinetype ( byte [ ] bytes ) { int offset = _num ; if ( bytes . length >= _num && ( bytes [ _num ] & _num ) == _num && ( bytes [ _num ] & _num ) == _num && ( bytes [ _num ] & _num ) == _num ) { offset += _num ; } while ( offset < bytes . length && bytes [ offset ] == _str || bytes [ offset ] == _str || bytes [ offset ] == _str || bytes [ offset ] == _str || bytes [ offset ] == _str ) { offset ++ ; } return determinetype ( new string ( bytes , offset , math . min ( _num , bytes . length - offset ) ) ) ; }	determines the type of a property list by means of the first bytes of its data.
public void fixhttpsurlconnection ( ) { httpsurlconnection . setdefaultsslsocketfactory ( sslcontext . getsocketfactory ( ) ) ; }	makes httpsurlconnection trusts a set of certificates specified by the keystore.
@ override public datatable sample ( int newsize ) { int rowcount = getrownumber ( ) ; if ( rowcount <= newsize ) { return this ; } int [ ] sampledselectedindices = new int [ rowcount ] ; for ( int i = _num ; i < rowcount ; ++ i ) { sampledselectedindices [ i ] = i ; } random rng = new random ( _num ) ; int swapidx ; int tmpvalue ; for ( int i = _num ; i < rowcount ; ++ i ) { swapidx = rng . nextint ( rowcount ) ; tmpvalue = sampledselectedindices [ swapidx ] ; sampledselectedindices [ swapidx ] = sampledselectedindices [ i ] ; sampledselectedindices [ i ] = tmpvalue ; } datatableview sampleddatatable = new datatableview ( this ) ; vector < integer > sampledselectedindicesvector = new vector < integer > ( newsize ) ; for ( int i = _num ; i < newsize ; ++ i ) { sampledselectedindicesvector . add ( sampledselectedindices [ i ] ) ; } sampleddatatable . setselectedindices ( sampledselectedindicesvector ) ; return sampleddatatable ; }	performs a simple sampling without replacement.
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m_filterthread . isalive ( ) && m_state != idle ) { wait ( ) ; } } catch ( interruptedexception ex ) { } } else { notifyall ( ) ; } }	function used to stop code that calls accepttrainingset , accepttestset , or acceptdataset.
public void cancel ( ) { if ( muploadoperation == null ) { if ( muploadstarted . get ( ) ) { log_oc . d ( tag , _str ) ; mcancellationrequested . set ( _bool ) ; } else { log_oc . e ( tag , _str ) ; } } else { log_oc . d ( tag , _str ) ; muploadoperation . cancel ( ) ; } }	allows to cancel the actual upload operation.
public static void mergefiles ( final file file1 , final file file2 , final file outputfile ) { if ( ! isreadable ( file1 ) || ! isreadable ( file2 ) || ! outputfile . exists ( ) && ! makedirsforfile ( outputfile ) ) { return ; } try { fileinputstream fis1 = new fileinputstream ( file1 ) ; fileinputstream fis2 = new fileinputstream ( file2 ) ; sequenceinputstream sis = new sequenceinputstream ( fis1 , fis2 ) ; fileoutputstream fos = new fileoutputstream ( outputfile ) ; int count ; byte [ ] temp = new byte [ _num ] ; while ( ( count = sis . read ( temp ) ) != - _num ) { fos . write ( temp , _num , count ) ; } fileutils . sync ( fos ) ; fos . close ( ) ; sis . close ( ) ; fis1 . close ( ) ; fis2 . close ( ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }	merge two files into a new file.
public static snippetset parse ( final file file ) throws parseexception { return parse ( fileinputsupplier ( file . getparentfile ( ) ) , file . getname ( ) ) ; }	parses the input from a file and returns a snippet set .
public static string readfile ( class < ? > context , string name ) throws ioexception { try ( inputstream in = context . getresourceasstream ( name ) ) { if ( in == null ) { return null ; } return new string ( bytestreams . tobytearray ( in ) , enc ) ; } catch ( ioexception e ) { throw new ioexception ( _str + name , e ) ; } }	read a read a utf - 8 text file from our classpath and return it .
long ptstotimeus ( long pts ) { if ( lastpts != long . min_value ) { long closestwrapcount = ( lastpts + ( max_pts / _num ) ) / max_pts ; long ptswrapbelow = pts + ( max_pts * ( closestwrapcount - _num ) ) ; long ptswrapabove = pts + ( max_pts * closestwrapcount ) ; pts = math . abs ( ptswrapbelow - lastpts ) < math . abs ( ptswrapabove - lastpts ) ? ptswrapbelow : ptswrapabove ; } long timeus = ( pts * c . micros_per_second ) / _num ; if ( lastpts == long . min_value ) { timestampoffsetus = firstsampletimestamp - timeus ; } lastpts = pts ; return timeus + timestampoffsetus ; }	adjusts a pts value to the corresponding time in microseconds , accounting for pts wraparound .
public int remove ( object key ) { entry e = removeentryforkey ( key ) ; return ( e == null ? _num : e . value ) ; }	removes the mapping for the specified key from this map if present .
public boolean verifychallengetoken ( inetsocketaddress address , int token ) { return objects . equals ( challengetokens . get ( address ) , token ) ; }	verify that the request is using the correct challenge token .
protected void drawtriangle ( int x , int y , int w , int h , color fillcolor , paint fillpaint , color pencolor , boolean shadow , string direction ) { polygon triangle = new polygon ( ) ; if ( direction . equals ( mxconstants . direction_north ) ) { triangle . addpoint ( x , y + h ) ; triangle . addpoint ( x + w / _num , y ) ; triangle . addpoint ( x + w , y + h ) ; } else if ( direction . equals ( mxconstants . direction_south ) ) { triangle . addpoint ( x , y ) ; triangle . addpoint ( x + w / _num , y + h ) ; triangle . addpoint ( x + w , y ) ; } else if ( direction . equals ( mxconstants . direction_west ) ) { triangle . addpoint ( x + w , y ) ; triangle . addpoint ( x , y + h / _num ) ; triangle . addpoint ( x + w , y + h ) ; } else { triangle . addpoint ( x , y ) ; triangle . addpoint ( x + w , y + h / _num ) ; triangle . addpoint ( x , y + h ) ; } drawpolygon ( triangle , fillcolor , fillpaint , pencolor , shadow ) ; }	draws a triangle shape for the given parameters .
private static map < string , string > resourcebundlemap ( resourcebundle bundle ) { final hashmap < string , string > map = new hashmap < string , string > ( ) ; final enumeration < string > e = bundle . getkeys ( ) ; while ( e . hasmoreelements ( ) ) { final string key = e . nextelement ( ) ; map . put ( key , ( string ) bundle . getobject ( key ) ) ; } return collections . unmodifiablemap ( map ) ; }	returns an unmodifiable map of the given bundle .
public int compareto ( intbuffer otherbuffer ) { int compareremaining = ( remaining ( ) < otherbuffer . remaining ( ) ) ? remaining ( ) : otherbuffer . remaining ( ) ; int thispos = position ; int otherpos = otherbuffer . position ; int thisint , otherint ; while ( compareremaining > _num ) { thisint = get ( thispos ) ; otherint = otherbuffer . get ( otherpos ) ; if ( thisint != otherint ) { return thisint < otherint ? - _num : _num ; } thispos ++ ; otherpos ++ ; compareremaining -- ; } return remaining ( ) - otherbuffer . remaining ( ) ; }	compares the remaining ints of this buffer to another int buffer ' s remaining ints .
private boolean isblack ( final int x , final int y ) { if ( ! inbounds ( x , y ) ) { return _bool ; } return ( m_bufferedimage . getrgb ( x , y ) & _num ) == _num ; }	java . lang . boolean isblack ( java . lang . int , java . lang . int ) checks to see if the x / y coordinates from a given point are inbounds and if so is it black .
public void addjob ( runnable job ) { mjobs . add ( job ) ; }	adds a job to be executed after the chart - view is setup ( after onsizechanged (.
@ override public void close ( ) throws ioexception { if ( in != null ) { in . close ( ) ; in = null ; buf = null ; } }	closes this stream . this implementation closes the source stream and releases the pushback buffer .
public static collection < vector2d > reducepoints ( final collection < vector2d > points ) { int size = _num ; vector2d minx = null ; vector2d maxx = null ; vector2d miny = null ; vector2d maxy = null ; for ( vector2d p : points ) { if ( minx == null || p . getx ( ) < minx . getx ( ) ) { minx = p ; } if ( maxx == null || p . getx ( ) > maxx . getx ( ) ) { maxx = p ; } if ( miny == null || p . gety ( ) < miny . gety ( ) ) { miny = p ; } if ( maxy == null || p . gety ( ) > maxy . gety ( ) ) { maxy = p ; } size ++ ; } if ( size < _num ) { return points ; } final list < vector2d > quadrilateral = buildquadrilateral ( miny , maxx , maxy , minx ) ; if ( quadrilateral . size ( ) < _num ) { return points ; } final list < vector2d > reducedpoints = new arraylist < vector2d > ( quadrilateral ) ; for ( final vector2d p : points ) { if ( ! insidequadrilateral ( p , quadrilateral ) ) { reducedpoints . add ( p ) ; } } return reducedpoints ; }	returns a point set that is reduced by all points for which it is safe to assume that they are not part of the convex hull .
private ignitebituple < string , integer > hostport ( string connstr , string hostportstr ) throws ignitecheckedexception { string [ ] tokens = hostportstr . split ( _str , - _num ) ; string host = tokens [ _num ] ; if ( f . isempty ( host ) ) host = localhost ; int port ; if ( tokens . length == _num ) port = igfsipcendpointconfiguration . dflt_port ; else if ( tokens . length == _num ) { string portstr = tokens [ _num ] ; try { port = integer . valueof ( portstr ) ; if ( port < _num || port > _num ) throw new ignitecheckedexception ( _str + connstr ) ; } catch ( numberformatexception e ) { throw new ignitecheckedexception ( _str + connstr ) ; } } else throw new ignitecheckedexception ( _str + connstr ) ; return f . t ( host , port ) ; }	parse host and port .
public boolean ismissilegoingtohit ( entitymissile missile ) { if ( missile == null || missile . targetvector == null ) { return _bool ; } return ( vector2 . distance ( new vector2 ( new pos3d ( missile ) ) , new vector2 ( xcoord , zcoord ) ) < alarmrange && vector2 . distance ( new vector2 ( missile . targetvector ) , new vector2 ( xcoord , zcoord ) ) < safetyrange ) ; }	checks to see if the missile will hit within the range of the radar station.
public static usericon parsemodicon ( string json ) { try { jsonparser parser = new jsonparser ( ) ; jsonobject o = ( jsonobject ) parser . parse ( json ) ; jsonobject room = ( jsonobject ) o . get ( _str ) ; string roomid = ( string ) room . get ( _str ) ; string modbadgeurl = ( string ) room . get ( _str ) ; if ( modbadgeurl == null ) { return null ; } return usericonfactory . createtwitchlikeicon ( usericon . type . mod , roomid , modbadgeurl , usericon . source_ffz , _str ) ; } catch ( parseexception | classcastexception | nullpointerexception ex ) { } return null ; }	parses the mod icon . request : / room / : room.
public static long length ( url url ) throws ioexception { httpresponse http = httpengine . head ( url , null , null , - _num , _bool , null , constants . name , null , null ) ; return http . getcontentlength ( ) ; }	return the length of a file defined by a url .
@ override public request < list < workspace > > all ( ) { list < workspace > workspacestoreturn = new arraylist < > ( ) ; for ( workspace dummyworkspace : workspaces . values ( ) ) { workspacestoreturn . add ( dummyworkspace ) ; } return new dummyrequest < > ( workspacestoreturn ) ; }	retrieves all codenvy workspaces of the user identified by the authentication token .
public void subscribe ( eventsubscriber < ? > subscriber ) { final class < ? > eventtype = geteventtype ( subscriber ) ; dosubscribe ( subscriber , eventtype ) ; }	subscribe event listener . the event to subscribe to is inferred by checking the generic type arguments of the given subscriber .
public static string readertostring ( final reader filereader ) throws ioexception { final stringbuilder sb = new stringbuilder ( ) ; try ( bufferedreader br = new bufferedreader ( filereader ) ) { final char [ ] buffer = fileutils . makebuffer ( ) ; final int eof = - _num ; for ( int len = br . read ( buffer ) ; len > eof ; len = br . read ( buffer ) ) { for ( int i = _num ; i < len ; i ++ ) { sb . append ( buffer [ i ] ) ; } } } return sb . tostring ( ) ; }	read the contents of a reader and turn it into a string .
public static string bytestohex ( byte [ ] bytes , boolean withspaces ) { stringbuilder sb = new stringbuilder ( ) ; for ( byte hashbyte : bytes ) { int intval = _num & hashbyte ; if ( intval < _num ) { sb . append ( _str ) ; } sb . append ( integer . tohexstring ( intval ) ) ; if ( withspaces ) { sb . append ( _str ) ; } } return sb . tostring ( ) ; }	takes the provided byte array and converts it into a hexadecimal string with two characters per byte .
private boolean isinterleaved ( componentsamplemodel sm ) { int numbands = samplemodel . getnumbands ( ) ; if ( numbands == _num ) { return _bool ; } int [ ] bankindices = sm . getbankindices ( ) ; for ( int i = _num ; i < numbands ; i ++ ) { if ( bankindices [ i ] != _num ) { return _bool ; } } int [ ] bandoffsets = sm . getbandoffsets ( ) ; int minoffset = bandoffsets [ _num ] ; int maxoffset = minoffset ; for ( int i = _num ; i < numbands ; i ++ ) { int offset = bandoffsets [ i ] ; if ( offset < minoffset ) { minoffset = offset ; } if ( offset > maxoffset ) { maxoffset = offset ; } } if ( maxoffset - minoffset >= sm . getpixelstride ( ) ) { return _bool ; } return _bool ; }	analyzes a componentsamplemodel to determine if it can function as a pixelinterleavedsamplemodel.
private int decodesize ( byte [ ] buffer ) { biginteger bi = new biginteger ( buffer ) ; int tmpsize = bi . intvalue ( ) ; if ( tmpsize < _num ) { logger . warning ( _str + tmpsize + _str + integer . tobinarystring ( tmpsize ) + _str + integer . tohexstring ( tmpsize ) ) ; } return tmpsize ; }	read frame size , which has to be decoded.
public certificateissuerextension ( boolean critical , object value ) throws ioexception { this . extensionid = pkixextensions . certificateissuer_id ; this . critical = critical . booleanvalue ( ) ; this . extensionvalue = ( byte [ ] ) value ; dervalue val = new dervalue ( this . extensionvalue ) ; this . names = new generalnames ( val ) ; }	create a certificateissuerextension from the specified der encoded value of the same .
@ override public void onsensorselectionclosed ( dialogfragment dialog ) { log . d ( tag , _str ) ; sensorselectiondialog = null ; }	will be called if the sensor selection dialog has been closed.
public void runtest ( ) throws throwable { document doc ; nodelist elementlist ; node namenode ; characterdata child ; string childdata ; string childvalue ; doc = ( document ) load ( _str , _bool ) ; elementlist = doc . getelementsbytagname ( _str ) ; namenode = elementlist . item ( _num ) ; child = ( characterdata ) namenode . getfirstchild ( ) ; child . setnodevalue ( _str ) ; childdata = child . getdata ( ) ; assertequals ( _str , _str , childdata ) ; childvalue = child . getnodevalue ( ) ; assertequals ( _str , _str , childvalue ) ; }	runs the test case .
public string toxml ( ) { stringbuffer str = new stringbuffer ( ) ; str . append ( _str ) ; str . append ( xml_root_element ) ; str . append ( _str ) ; str . append ( _str ) ; str . append ( xml_element_quality_code ) ; str . append ( _str ) ; str . append ( qualitycode ) ; str . append ( _str ) ; str . append ( xml_element_quality_code ) ; str . append ( _str ) ; if ( description != null ) { str . append ( _str ) ; str . append ( xml_element_quality_desc ) ; str . append ( _str ) ; str . append ( description ) ; str . append ( _str ) ; str . append ( xml_element_quality_desc ) ; str . append ( _str ) ; } str . append ( _str ) ; str . append ( xml_root_element ) ; str . append ( _str ) ; return str . tostring ( ) ; }	create an xml representation of a sourcedataquality object.
public byte [ ] decrypt ( facescontext context , byte [ ] securedata ) { try { byte [ ] macbytes = new byte [ maclength ] ; system . arraycopy ( securedata , _num , macbytes , _num , macbytes . length ) ; byte [ ] iv = new byte [ ivlength ] ; system . arraycopy ( securedata , macbytes . length , iv , _num , iv . length ) ; byte [ ] encdata = new byte [ securedata . length - macbytes . length - iv . length ] ; system . arraycopy ( securedata , macbytes . length + iv . length , encdata , _num , encdata . length ) ; byte [ ] rawkey = convertpasswordtokey ( getpasswordtosecurestate ( context ) ) ; mac mac = getmac ( rawkey ) ; mac . update ( iv ) ; mac . update ( encdata ) ; byte [ ] macbytescalculated = mac . dofinal ( ) ; if ( arrays . equals ( macbytes , macbytescalculated ) ) { cipher cipher = getblockcipherfordecryption ( rawkey , iv ) ; byte [ ] plaindata = cipher . dofinal ( encdata ) ; return plaindata ; } else { if ( logger . isloggable ( level . warning ) ) { logger . warning ( _str ) ; } return null ; } } catch ( exception e ) { if ( logger . isloggable ( level . severe ) ) { logger . log ( level . severe , e . getmessage ( ) , e . getcause ( ) ) ; } throw new runtimeexception ( e ) ; } }	decrypts the specified byte array using the specified password , and generates an inputstream from it.
public static set < string > commadelimitedlisttoset ( string str ) { set < string > set = new treeset < > ( ) ; string [ ] tokens = commadelimitedlisttostringarray ( str ) ; set . addall ( arrays . aslist ( tokens ) ) ; return set ; }	convenience method to convert a csv string list to a set.
public int hashcode ( ) { return objects . hash ( file , princ , bound ) ; }	returns a hashcode for this keytab .
public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addall ( collections . list ( super . listoptions ( ) ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
protected void tag ( string tag , string name , string value , boolean close ) { spacing ( ) ; m_out . print ( _str ) ; m_out . print ( tag ) ; m_out . print ( _str ) ; m_out . print ( name ) ; m_out . print ( _str ) ; m_out . print ( _str ) ; escapestring ( value ) ; m_out . print ( _str ) ; if ( close ) m_out . print ( _str ) ; m_out . print ( _str ) ; println ( ) ; if ( ! close ) { m_tagstack . add ( tag ) ; } }	internal method for printing a tag with a single attribute .
public static result evaluatemodel ( multilabelclassifier h , instances d ) throws exception { return evaluatemodelprequentialbasic ( h , d , _num , _num , _str , _str ) ; }	evaluatemodel - over 20 windows .
protected boolean isvalidstate ( mxcellstate state ) { return _bool ; }	returns true if the given state is a valid state.
public void testfindspringsundirectoryserverwithlimit ( ) { ldapproxy proxy = getldapsundirectoryserver ( ) ; list result = null ; int limit = _num ; try { result = proxy . find ( getldapsearchvo ( _str , limit , _str , _str , null , ldapscopeconstants . scope_subtree ) ) ; } catch ( exception e ) { } assertnotnull ( result ) ; if ( result != null ) { assertequals ( limit , result . size ( ) ) ; } }	test de busqueda sun directory server con limite.
public static boolean deletedir ( file dir ) { if ( dir == null ) { return _bool ; } if ( dir . isdirectory ( ) ) { string [ ] children = dir . list ( ) ; for ( string child : children ) { boolean success = deletedir ( new file ( dir , child ) ) ; if ( ! success ) { return _bool ; } } } return dir . delete ( ) ; }	delete a selected directory recursively.
private cimobjectpath createfilter ( cimmanagedfilterinfo filterinfo ) throws wbemexception { stringbuilder filternamebuilder = new stringbuilder ( ) ; filternamebuilder . append ( _subscriptionsidentifier ) ; filternamebuilder . append ( cimconstants . path_name_delimiter ) ; filternamebuilder . append ( filterinfo . getname ( ) ) ; string filtername = filternamebuilder . tostring ( ) ; string implns = _connection . getimplnamespace ( ) ; cimproperty < ? > nameproperty = new cimproperty < string > ( cimconstants . name_key , cimdatatype . string_t , filtername ) ; cimproperty < ? > srcnamespaceprop = new cimproperty < string > ( cimconstants . filter_prop_src_namespace , cimdatatype . string_t , implns ) ; cimproperty < ? > srcnamespacesprop = new cimproperty < string [ ] > ( cimconstants . filter_prop_src_namespaces , cimdatatype . string_array_t , new string [ ] { implns } ) ; cimproperty < ? > querylangprop = new cimproperty < string > ( cimconstants . filter_prop_query_language , cimdatatype . string_t , filterinfo . getquerylanguage ( ) ) ; cimproperty < ? > queryprop = new cimproperty < string > ( cimconstants . filter_prop_query , cimdatatype . string_t , filterinfo . getquery ( ) ) ; cimproperty < ? > [ ] filterproperties = new cimproperty [ ] { nameproperty , srcnamespaceprop , srcnamespacesprop , querylangprop , queryprop } ; cimobjectpath filterpath = createinstance ( cimconstants . cim_filter_name , filtername , filterproperties ) ; _filterpaths . add ( filterpath ) ; return filterpath ; }	creates an indication filter in the cimom for the given configuration .
public static arraylist < arraylist < string > > filetokenizer ( string fin ) { file file = new file ( fin ) ; bufferedreader br ; filereader fr ; arraylist < string > lines = new arraylist < string > ( ) ; try { fr = new filereader ( file ) ; br = new bufferedreader ( fr ) ; string line ; try { while ( ( line = br . readline ( ) ) != null ) { if ( line . length ( ) > _num ) { lines . add ( line ) ; } } } catch ( ioexception ex ) { } } catch ( filenotfoundexception ex ) { } arraylist < arraylist < string > > tokenized_list = new arraylist < arraylist < string > > ( ) ; for ( string s : lines ) { arraylist < string > tokens = new arraylist < string > ( ) ; stringtokenizer st = new stringtokenizer ( s , _str ) ; while ( st . hasmoretokens ( ) ) { tokens . add ( st . nexttoken ( ) ) ; } tokenized_list . add ( tokens ) ; } return tokenized_list ; }	synopsis [ ] outer arraylist = lines inner arraylist = tokens.
public activationgroupimpl ( activationgroupid id , marshalledobject < ? > data ) throws remoteexception { super ( id ) ; groupid = id ; unexportobject ( this , _bool ) ; rmiserversocketfactory ssf = new serversocketfactoryimpl ( ) ; unicastremoteobject . exportobject ( this , _num , null , ssf ) ; if ( system . getsecuritymanager ( ) == null ) { try { system . setsecuritymanager ( new securitymanager ( ) ) ; } catch ( exception e ) { throw new remoteexception ( _str , e ) ; } } }	creates a default activation group implementation .
public static double vectorlength ( double [ ] vector ) { double ret = _num ; if ( vector == null ) return ret ; else { for ( double avector : vector ) { ret += math . pow ( avector , _num ) ; } } return ret ; }	returns the vector length ( sqrt ( sum ( x_i ) ).
public static string encodequery ( string url ) { uri uri = uri . parse ( url ) ; try { string query = uri . getquery ( ) ; string encodedquery = query != null ? urlencoder . encode ( query , _str ) : null ; uri tmp = new uri ( uri . getscheme ( ) , uri . getauthority ( ) , uri . getpath ( ) , null , uri . getfragment ( ) ) ; return tmp + ( encodedquery != null && encodedquery . length ( ) > _num ? _str + encodedquery : _str ) ; } catch ( unsupportedencodingexception ignore ) { } catch ( urisyntaxexception ignore ) { } return uri . tostring ( ) ; }	this method encodes the query part of an url.
public void definefillstyle ( int bitmapid , matrix matrix , boolean clipped ) throws ioexception { fillstyles . add ( new fillstyle ( bitmapid , matrix , clipped ) ) ; outstandingchanges = _bool ; }	description of the method.
private static long writefile ( string path , byte [ ] data ) { fileoutputstream out = null ; try { out = new fileoutputstream ( path ) ; out . write ( data ) ; return data . length ; } catch ( exception e ) { log . e ( tag , _str , e ) ; } finally { try { out . close ( ) ; } catch ( exception e ) { log . e ( tag , _str , e ) ; } } return - _num ; }	writes the data to a file .
public void firepaletteevent ( componentevent event ) { if ( localhacklist == null ) { return ; } palette = ( container ) event . getsource ( ) ; int eventtype = event . getid ( ) ; for ( componentlistener listener : localhacklist ) { if ( eventtype == componentevent . component_hidden ) { listener . componenthidden ( event ) ; } else if ( eventtype == componentevent . component_shown ) { listener . componentshown ( event ) ; } } if ( eventtype == componentevent . component_hidden ) { palette = null ; } }	fire a component event to the layer component listeners , with the palette as the component , letting them know if it ' s visible or not .
public void removeentry ( rosterentry e ) { log . debug ( _str , e ) ; _list . remove ( e ) ; e . removepropertychangelistener ( this ) ; setdirty ( _bool ) ; firepropertychange ( remove , e , null ) ; }	remove a rosterentry object from the in - memory roster . this does not delete the file for the rosterentry !.
protected void logdiagnostic ( string msg ) { if ( isdiagnosticsenabled ( ) ) { lograwdiagnostic ( diagnosticprefix + msg ) ; } }	output a diagnostic message to a user - specified destination ( if the user has enabled diagnostic logging ) .
public void addurl ( final string url ) { while ( currentindex < history . size ( ) - _num ) { history . remove ( currentindex + _num ) ; } history . add ( url ) ; currentindex = history . size ( ) - _num ; }	add a new url to the browsing history.
public static valuetimestamp converttimestamp ( timestamp x , calendar calendar ) { if ( calendar == null ) { throw dbexception . getinvalidvalueexception ( _str , null ) ; } calendar cal = ( calendar ) calendar . clone ( ) ; cal . settimeinmillis ( x . gettime ( ) ) ; long datevalue = datevaluefromcalendar ( cal ) ; long nanos = nanosfromcalendar ( cal ) ; nanos += x . getnanos ( ) % _num ; return valuetimestamp . fromdatevalueandnanos ( datevalue , nanos ) ; }	convert the timestamp using the specified calendar .
private void element ( string segment ) { int index = segment . indexof ( _str ) ; string prefix = null ; if ( index > _num ) { prefix = segment . substring ( _num , index ) ; segment = segment . substring ( index + _num ) ; } string element = style . getelement ( segment ) ; prefixes . add ( prefix ) ; names . add ( element ) ; }	this will insert the path segment provided.
private void cleanuphandler ( contenthandler vh ) throws saxexception { for ( prefixmapping pm = prefixmapping ; pm != null ; pm = pm . parent ) vh . endprefixmapping ( pm . prefix ) ; vh . enddocument ( ) ; }	cleanup a handler . remove proxy namespace mappings calling endprefixmapping and calls also enddocument to signal that the source was ended .
public inputstream openclassfile ( string classname ) { try { urlconnection con = openclassfile0 ( classname ) ; if ( con != null ) return con . getinputstream ( ) ; } catch ( ioexception e ) { } return null ; }	opens a class file with http .
public void removeignoredview ( view v ) { mignoredviews . remove ( v ) ; }	removes the ignored view .
private double fitness ( solution solution , double [ ] weights ) { double max = double . negative_infinity ; for ( int i = _num ; i < solution . getnumberofobjectives ( ) ; i ++ ) { max = math . max ( max , math . max ( weights [ i ] , _num ) * math . abs ( solution . getobjective ( i ) - idealpoint [ i ] ) ) ; } if ( solution . violatesconstraints ( ) ) { max += _num ; } return max ; }	evaluates the fitness of the specified solution using the chebyshev weights .
private boolean selectitembyname ( ccombo combo , string name , string [ ] cstring ) { for ( int i = _num ; i < cstring . length ; i ++ ) { string propname = cstring [ i ] ; if ( name . equalsignorecase ( propname ) ) { combo . select ( i ) ; return _bool ; } } return _bool ; }	pre - select property if it has the same name as a csv table column.
public void addfile ( string path ) throws ioexception { file newfile = new file ( path ) ; if ( ! newfile . exists ( ) ) { throw new ioexception ( _str + newfile . getabsolutepath ( ) ) ; } if ( delphiutils . acceptfile ( newfile . getabsolutepath ( ) ) ) { files . add ( newfile ) ; } }	adds a source file to project.
public void removelimitline ( limitline l ) { mlimitlines . remove ( l ) ; }	removes the specified limitline from the axis .
public boolean iscontent ( ) { return state . equals ( content ) ; }	check if content is shown.
protected boolean columnsdiffer ( column currentcolumn , column desiredcolumn ) { string desireddefault = desiredcolumn . getdefaultvalue ( ) ; string currentdefault = currentcolumn . getdefaultvalue ( ) ; boolean defaultsequal = ( desireddefault == null ) || desireddefault . equals ( currentdefault ) ; boolean sizematters = databaseinfo . hassize ( currentcolumn . getmappedtypecode ( ) ) && ( desiredcolumn . getsize ( ) != null ) ; if ( ( databaseinfo . gettargetjdbctype ( desiredcolumn . getmappedtypecode ( ) ) != currentcolumn . getmappedtypecode ( ) ) || ( desiredcolumn . isrequired ( ) != currentcolumn . isrequired ( ) ) || ( sizematters && ! stringutils . equals ( desiredcolumn . getsize ( ) , currentcolumn . getsize ( ) ) ) || ! defaultsequal ) { return _bool ; } else { return _bool ; } }	compares the current column in the database with the desired one.
public static int readuint16 ( inputstream stream ) throws ioexception { int result = stream . read ( ) ; result |= stream . read ( ) << _num ; return result ; }	reads 2 bytes from stream and interprets them as uint16 . < br >.
private void preparemetadataconnection ( ) throws sqlexception , replicatorexception { if ( metadataconnection == null ) metadataconnection = datasourceimpl . getconnection ( ) ; long currenttime = system . currenttimemillis ( ) ; if ( lastconnectiontime == _num ) { lastconnectiontime = currenttime ; } else if ( reconnecttimeoutinseconds > _num && currenttime - lastconnectiontime > reconnecttimeoutinseconds * _num ) { datasourceimpl . releaseconnection ( metadataconnection ) ; metadataconnection = datasourceimpl . getconnection ( ) ; } }	prepare the metadata connection for use : connect or reconnect if needed .
public static string identifylinedelimiter ( string filecontent ) { if ( filecontent . matches ( _str ) ) { return _str ; } else if ( filecontent . matches ( _str ) ) { return _str ; } else if ( filecontent . matches ( _str ) ) { return _str ; } else { return _str ; } }	identify which line delimiter is used in a file.
public void additem ( forceitem item ) { items . add ( item ) ; }	add a forceitem to the simulation .
public void testconstructor2 ( ) { executor e = executors . newfixedthreadpool ( _num ) ; submissionpublisher < integer > p = new submissionpublisher < integer > ( e , _num ) ; checkinitialstate ( p ) ; assertsame ( p . getexecutor ( ) , e ) ; assertequals ( _num , p . getmaxbuffercapacity ( ) ) ; }	a new submissionpublisher has no subscribers , is not closed , has the given buffer size , and uses the given executor.
protected void parsecontainerandscreen ( xmlresourceparser parser , long [ ] out ) { if ( hotseat_container_name . equals ( getattributevalue ( parser , attr_container ) ) ) { out [ _num ] = launchersettings . favorites . container_hotseat ; long rank = long . parselong ( getattributevalue ( parser , attr_rank ) ) ; out [ _num ] = ( rank < mhotseatallappsrank ) ? rank : ( rank + _num ) ; } else { out [ _num ] = launchersettings . favorites . container_desktop ; out [ _num ] = long . parselong ( getattributevalue ( parser , attr_screen ) ) ; } }	parses container and screenid attribute from the current tag , and puts it in the out .
public defaulttreecolouring sampletreecolouring ( tree tree , colourchangematrix colourchangematrix , metapopulation mp ) { defaulttreecolouring colouring = new defaulttreecolouring ( _num , tree ) ; double [ ] n = mp . getpopulationsizes ( _num ) ; double [ ] rootpartials = prune ( tree , tree . getroot ( ) , colourchangematrix , n ) ; double normalization = _num ; for ( int i = _num ; i < rootpartials . length ; i ++ ) { normalization += colourchangematrix . getequilibrium ( i ) * rootpartials [ i ] ; } sampleinternalnodes ( tree , tree . getroot ( ) , colourchangematrix ) ; samplebranchcolourings ( colouring , tree , tree . getroot ( ) , colourchangematrix ) ; double logp = calculatelogprobabilitydensity ( colouring , tree , tree . getroot ( ) , colourchangematrix , n ) - math . log ( normalization ) ; colouring . setlogprobabilitydensity ( logp ) ; return colouring ; }	colours the tree probabilistically with the given migration rates.
public storedlistiterator < t > establishlistscan ( boolean random_scan ) { if ( isempty ( ) ) return null ; storedlistiterator < t > slh = _slholderpool . get ( ) ; storedlistiterator < t > res = establishpos ( random_scan , slh ) ; if ( res == null ) slh . release ( ) ; return res ; }	establish a scan position . if random scanning supported we select a random position.
public static string decode ( final string str , final string charsetname ) throws unsupportedencodingexception { return decode ( new string ( str . getbytes ( charsetname ) , _str ) ) ; }	transliterate an unicode object into an ascii string .
public servercommit acquire ( operationentry entry , serversessioncontext session , long timestamp ) { servercommit commit = pool . poll ( ) ; if ( commit == null ) { commit = new servercommit ( this , log ) ; } commit . reset ( entry , session , timestamp ) ; return commit ; }	acquires a commit from the pool .
public static synchronized double makenoise ( double mean , double standarddiviation ) { return random . nextgaussian ( ) * math . sqrt ( standarddiviation ) + mean ; }	create a gaussian noise around supplied mean value based on supplied standarddiviation.
void shutdown ( ) { try { sslengine . closeinbound ( ) ; } catch ( sslexception e ) { if ( log . isdebugenabled ( ) ) log . debug ( _str + e . getmessage ( ) + _str + ses + _str ) ; } }	shuts down the handler .
@ override public synchronized void removeinstancelistener ( instancelistener tsl ) { m_instancelisteners . remove ( tsl ) ; }	remove an instance listener.
public map < string , map < string , flt > > retrieveterms ( int docnum ) throws ioexception { return retrieveterms ( docnum , null ) ; }	find words for a more - queryfromdocuments - this query former .
boolean alias ( string src , string target ) { if ( src == null ) return _bool ; pluginholder < t > a = registry . get ( src ) ; if ( a == null ) return _bool ; pluginholder < t > b = registry . get ( target ) ; if ( b != null ) return _bool ; registry . put ( target , a ) ; return _bool ; }	make a plugin available in an alternate name . this is an internal api and not for public use.
public static < t extends charsequence > t eachmatch ( t self , pattern pattern , @ closureparams ( value = fromstring . class , options = { _str , _str } ) closure closure ) { eachmatch ( self . tostring ( ) , pattern , closure ) ; return self ; }	process each regex group matched substring of the given pattern.
public void switchsinglerow ( ) { if ( m_onlymultirow ) return ; cardlayout . first ( cardpanel ) ; m_singlerow = _bool ; dynamicdisplay ( _num ) ; }	switch to singlerow presentation.
private boolean isstringcontinuation ( int offset ) { int nextnonwscharposition = fscanner . findnonwhitespacebackwardinanypartition ( offset - _num , javaheuristicscanner . unbound ) ; try { if ( nextnonwscharposition != javaheuristicscanner . not_found && fdocument . getchar ( nextnonwscharposition ) == _str ) return _bool ; else return _bool ; } catch ( badlocationexception e ) { log . error ( javaindenter . class , e ) ; return _bool ; } }	tells whether the given string is a continuation expression .
final void push ( final object object ) { stack . add ( object ) ; }	push a new object onto the top of the object stack .
public void makeimmutable ( ) { mutable = _bool ; }	makes the object immutable .
public static < k , v > v atomicgetorcreate ( concurrentmap < k , v > map , k key , callable < v > ctor ) { v value = map . get ( key ) ; if ( value == null ) { try { value = ctor . call ( ) ; } catch ( exception e ) { throw new runtimeexception ( _str , e ) ; } v existing = map . putifabsent ( key , value ) ; if ( existing != null ) { return existing ; } } return value ; }	atomically returns a map element for the specifying key.
private void createmetricchartpanel ( int metric , datasetgenerator datasetgenerator , list < gcstatschartpanel > list ) { changingcategorydatasetwithttg dataset = datasetgenerator . newcategorydatasetwithttg ( metric , _bool ) ; gcstatschartpanel panel = new metricchartpanel ( chart_prefix + datasetgenerator . getmetricname ( metric ) , datasetgenerator . getunitname ( metric ) , dataset , locker ) ; list . add ( panel ) ; }	it adds a new metric chart panel to the tabbed pane set .
public void testconstrstringwithexponentwithoutpoint2 ( ) { string a = _str ; int ascale = _num ; biginteger ba = new biginteger ( _str ) ; bigdecimal anumber = new bigdecimal ( a ) ; assertequals ( _str , ba , anumber . unscaledvalue ( ) ) ; assertequals ( _str , ascale , anumber . scale ( ) ) ; }	new bigdecimal ( string value ) ; value contains exponent and does not contain decimal point.
public defaultclientwebrequestbuilder cookie ( string name , string value ) { return cookie ( new httpcookie ( name , value ) ) ; }	add a cookie to the http request.
private void addnewtilesets ( map map ) throws ioexception { for ( tileset set : map . gettilesets ( ) ) { setbyname . put ( set . gettilebmpfile ( ) , set ) ; } for ( string name : mapping . getnewsets ( ) ) { if ( name . equals ( _str ) ) { continue ; } if ( ! setbyname . containskey ( name ) ) { tileset set = new tileset ( ) ; set . setname ( constructtilesetname ( name ) ) ; basictilecutter cutter = new basictilecutter ( _num , _num , _num , _num ) ; set . importtilebitmap ( name , cutter ) ; setbyname . put ( name , set ) ; map . addtileset ( set ) ; } } }	add all the tilesets that the translation mapping uses to a map .
public static list < cssmetadata < ? extends styleable , ? > > createcssmetadatalist ( list < cssmetadata < ? extends styleable , ? > > baselist , cssmetadata < ? extends styleable , ? > ... metadata ) { list < cssmetadata < ? extends styleable , ? > > styleables = new arraylist < > ( baselist ) ; styleables . addall ( arrays . aslist ( metadata ) ) ; return collections . unmodifiablelist ( styleables ) ; }	creates a list of cssmetadata instances that is merged by the given parameters.
public void addextension ( asn1objectidentifier oid , boolean critical , byte [ ] value ) { if ( extensions . containskey ( oid ) ) { throw new illegalargumentexception ( _str + oid + _str ) ; } extordering . addelement ( oid ) ; extensions . put ( oid , new extension ( oid , critical , new deroctetstring ( value ) ) ) ; }	add an extension with the given oid and the passed in byte array to be wrapped in the octet string associated with the extension .
public void updateclientcookies ( boolean clientcookies ) throws securityexception { checkwriteaccess ( ) ; boolean hasaccess = configwebutil . hasaccess ( config , securitymanager . type_setting ) ; if ( ! hasaccess ) throw new securityexception ( _str ) ; element scope = _getrootelement ( _str ) ; scope . setattribute ( _str , caster . tostring ( clientcookies , _str ) ) ; }	set if client cookies are enabled or not.
public double [ ] subseriesbycopy ( double [ ] series , int start , int end ) throws indexoutofboundsexception { if ( ( start > end ) || ( start < _num ) || ( end > series . length ) ) { throw new indexoutofboundsexception ( _str + series . length + _str + start + _str + string . valueof ( end - start ) ) ; } return arrays . copyofrange ( series , start , end ) ; }	extract subseries out of series .
public static string createtempfile ( final string ... lines ) throws exception { final file f = file . createtempfile ( _str , _str ) ; f . deleteonexit ( ) ; try ( final filewriter w = new filewriter ( f ) ) { for ( final string s : lines ) { w . write ( s + system . getproperty ( _str ) ) ; } } return f . getabsolutepath ( ) ; }	creates a temporary text file with the specified contents.
public static void readskel ( bufferedreader reader ) throws ioexception { vector lines = new vector ( ) ; stringbuffer section = new stringbuffer ( ) ; string ln ; while ( ( ln = reader . readline ( ) ) != null ) { if ( ln . startswith ( _str ) ) { lines . addelement ( section . tostring ( ) ) ; section . setlength ( _num ) ; } else { section . append ( ln ) ; section . append ( nl ) ; } } if ( section . length ( ) > _num ) lines . addelement ( section . tostring ( ) ) ; if ( lines . size ( ) != size ) { out . error ( errormessages . wrong_skeleton ) ; throw new generatorexception ( ) ; } line = new string [ size ] ; for ( int i = _num ; i < size ; i ++ ) line [ i ] = ( string ) lines . elementat ( i ) ; }	reads an external skeleton file from a bufferedreader .
@ override public long readdouble ( string filepath , long offset ) { filechannel filechannel = updatecache ( filepath ) ; bytebuffer bytebffer = read ( filechannel , carboncommonconstants . long_size_in_byte , offset ) ; return bytebffer . getlong ( ) ; }	this method will be used to read int from file from postion ( offset ) , here length will be always 4 bacause int byte size if 4.
public luacompiler ( compilersettings settings ) { this . settings = objects . requirenonnull ( settings ) ; }	constructs a new compiler instance with the given settings .
public static void showaddressonmap ( context mcontext , string address ) { address = address . replace ( _str , _str ) ; intent geointent = new intent ( intent . action_view , uri . parse ( _str + address ) ) ; mcontext . startactivity ( geointent ) ; }	use to show address location pin on map .
public void testcopymap ( ) { serializer serializer = new serializer ( ) ; map < string , string > map = new hashmap < > ( ) ; map . put ( _str , _str ) ; map . put ( _str , _str ) ; map < string , string > result = serializer . copy ( map ) ; assertequals ( map , result ) ; assertequals ( map . get ( _str ) , _str ) ; assertequals ( map . get ( _str ) , _str ) ; }	tests copying a map .
private void findbouncedinstrument ( ) { for ( final receiptinstrumentinfo instrumentinfo : instrumentdetails ) if ( instrumentinfo . isbounced ( ) ) bouncedinstruments . add ( instrumentinfo ) ; }	finds all instruments of this receipt that are in bounced ( dishonored ) status and adds them to the set of bounced instruments .
public static set < string > convertarraytoset ( string [ ] array ) { set < string > resultset = new hashset < string > ( array . length ) ; collections . addall ( resultset , array ) ; return resultset ; }	transforms array of string objects to set.
public parsefile ( byte [ ] data ) { this ( null , data , null ) ; }	creates a new file from a byte array .
private storagepolicyentity createstoragepolicyentity ( namespaceentity namespaceentity , string storagepolicyname , storageentity storageentity , storageentity destinationstorageentity , storagepolicyruletypeentity storagepolicyruletypeentity , integer storagepolicyrulevalue , businessobjectdefinitionentity businessobjectdefinitionentity , string businessobjectformatusage , filetypeentity filetypeentity , storagepolicystatusentity storagepolicystatusentity , integer storagepolicyversion , boolean storagepolicylatestversion ) { storagepolicyentity storagepolicyentity = new storagepolicyentity ( ) ; storagepolicyentity . setnamespace ( namespaceentity ) ; storagepolicyentity . setname ( storagepolicyname ) ; storagepolicyentity . setstorage ( storageentity ) ; storagepolicyentity . setdestinationstorage ( destinationstorageentity ) ; storagepolicyentity . setstoragepolicyruletype ( storagepolicyruletypeentity ) ; storagepolicyentity . setstoragepolicyrulevalue ( storagepolicyrulevalue ) ; storagepolicyentity . setbusinessobjectdefinition ( businessobjectdefinitionentity ) ; if ( stringutils . isnotblank ( businessobjectformatusage ) ) { storagepolicyentity . setusage ( businessobjectformatusage ) ; } storagepolicyentity . setfiletype ( filetypeentity ) ; storagepolicyentity . setstatus ( storagepolicystatusentity ) ; storagepolicyentity . setversion ( storagepolicyversion ) ; storagepolicyentity . setlatestversion ( storagepolicylatestversion ) ; return storagepolicydao . saveandrefresh ( storagepolicyentity ) ; }	creates and persists a new storage policy entity .
public void drawstddevline ( graphics2d g2d , long stddevval , long ymaxmark , color color ) { float stddevperc = stddevval / ( float ) ymaxmark ; g2d . setcolor ( color ) ; int yposofline = this . graphbottom - math . round ( this . graphheight * stddevperc ) ; g2d . drawline ( this . graphleft , yposofline , this . graphright , yposofline ) ; }	used to draw the low and high standard devition lines on the line graph.
public samplevcpc ( independencetest independencetest ) { if ( independencetest == null ) { throw new nullpointerexception ( ) ; } if ( ! ( independencetest instanceof indtestfisherz ) ) { throw new illegalargumentexception ( _str ) ; } this . independencetest = independencetest ; this . dataset = ( dataset ) independencetest . getdata ( ) ; this . variables = dataset . getvariables ( ) ; this . covmatrix = new covariancematrix ( dataset ) ; list < node > nodes = covmatrix . getvariables ( ) ; this . indexmap = indexmap ( variables ) ; this . namemap = mapnames ( variables ) ; this . nodestovariables = new hashmap < > ( ) ; this . variablestonodes = new hashmap < > ( ) ; }	constructs a cpc algorithm that uses the given independence test as oracle . this does not make a copy of the independence test , for fear of duplicating the data set !.
private int nextavailableidx ( collection < integer > startedgrids , int maxtopsize , random rnd ) { while ( _bool ) { int idx = rnd . nextint ( maxtopsize ) ; if ( ! startedgrids . contains ( idx ) ) return idx ; } }	gets next available index .
public boolean hascolor ( ) { return typestring . contains ( color ) ; }	determine if the expression specifies a color .
public clearancematrix ( int p_class_count , brdlayerstructure p_layer_structure , string [ ] p_name_arr ) { class_count = math . max ( p_class_count , _num ) ; layer_structure = p_layer_structure ; clearance_rows = new clearancematrixrow [ class_count ] ; for ( int index = _num ; index < class_count ; ++ index ) { clearance_rows [ index ] = new clearancematrixrow ( this , p_name_arr [ index ] ) ; } max_value_on_layer = new int [ layer_structure . size ( ) ] ; }	creates a new instance for p_class_count clearance classes on p_layer_count layers . p_names is an array of dimension p_class_count ;.
public static char [ ] concat ( char [ ] base , char [ ] other , int appendcount ) { final int length = base . length ; char [ ] newarray = copyfrom ( base , base . length + appendcount ) ; system . arraycopy ( other , _num , newarray , length , appendcount ) ; return newarray ; }	appends appendcount number of elements of given array other to given array base.
public arrayrealvector ( arrayrealvector v1 , arrayrealvector v2 ) { data = new double [ v1 . data . length + v2 . data . length ] ; system . arraycopy ( v1 . data , _num , data , _num , v1 . data . length ) ; system . arraycopy ( v2 . data , _num , data , v1 . data . length , v2 . data . length ) ; }	construct a vector by appending one vector to another vector .
void addclasslist ( string classlistfilename ) { if ( classlistfilename . length ( ) > _num ) { setoption ( _str , classlistfilename ) ; loadclassnames ( classlistfilename ) ; } else { throw new illegalargumentexception ( _str ) ; } }	adds a class list filename to this set of options .
private start build ( start event ) { namednodemap list = event . getattributes ( ) ; int length = list . getlength ( ) ; for ( int i = _num ; i < length ; i ++ ) { node node = list . item ( i ) ; attribute value = attribute ( node ) ; if ( ! value . isreserved ( ) ) { event . add ( value ) ; } } return event ; }	this is used to build the attributes that are to be used to populate the start event.
public bytestonamecanonicalizer makechild ( boolean canonicalize , boolean intern ) { return new bytestonamecanonicalizer ( this , intern , _hashseed , _tableinfo . get ( ) ) ; }	factory method used to create actual symbol table instance to use for parsing .
public instances retrieveinstances ( ) throws exception { return retrieveinstances ( m_query ) ; }	makes a database query using the query set through the - q option to convert a table into a set of instances.
void extract ( inputstream in , string files [ ] ) throws ioexception { zipinputstream zis = new zipinputstream ( in ) ; zipentry e ; set < zipentry > dirs = newdirset ( ) ; while ( ( e = zis . getnextentry ( ) ) != null ) { if ( files == null ) { dirs . add ( extractfile ( zis , e ) ) ; } else { string name = e . getname ( ) ; for ( string file : files ) { if ( name . startswith ( file ) ) { dirs . add ( extractfile ( zis , e ) ) ; break ; } } } } updatelastmodifiedtime ( dirs ) ; }	extracts specified entries from jar file .
public void testgetaccentcolorsbyname ( ) { try { for ( string name : materialpalettes . colors_with_accent_names ) { list < integer > colorlist = materialpalettes . getaccentcolorsbyname ( name ) ; assertequals ( materialpalettes . accent_color_levels . length , colorlist . size ( ) ) ; } } catch ( illegalaccessexception iae ) { fail ( ) ; } }	tests that retrieving the accent colors gets the right count .
private static void drawchunk ( image image , graphics g , boolean stretch , int dx1 , int dy1 , int dx2 , int dy2 , int sx1 , int sy1 , int sx2 , int sy2 , boolean xdirection ) { if ( dx2 - dx1 <= _num || dy2 - dy1 <= _num || sx2 - sx1 <= _num || sy2 - sy1 <= _num ) { return ; } if ( stretch ) { g . drawimage ( image , dx1 , dy1 , dx2 , dy2 , sx1 , sy1 , sx2 , sy2 , null ) ; } else { int xsize = sx2 - sx1 ; int ysize = sy2 - sy1 ; int deltax ; int deltay ; if ( xdirection ) { deltax = xsize ; deltay = _num ; } else { deltax = _num ; deltay = ysize ; } while ( dx1 < dx2 && dy1 < dy2 ) { int newdx2 = math . min ( dx2 , dx1 + xsize ) ; int newdy2 = math . min ( dy2 , dy1 + ysize ) ; g . drawimage ( image , dx1 , dy1 , newdx2 , newdy2 , sx1 , sy1 , sx1 + newdx2 - dx1 , sy1 + newdy2 - dy1 , null ) ; dx1 += deltax ; dy1 += deltay ; } } }	draws a portion of an image , stretched or tiled .
private static void decodeedifactsegment ( bitsource bits , stringbuilder result ) { do { if ( bits . available ( ) <= _num ) { return ; } for ( int i = _num ; i < _num ; i ++ ) { int edifactvalue = bits . readbits ( _num ) ; if ( edifactvalue == _num ) { int bitsleft = _num - bits . getbitoffset ( ) ; if ( bitsleft != _num ) { bits . readbits ( bitsleft ) ; } return ; } if ( ( edifactvalue & _num ) == _num ) { edifactvalue |= _num ; } result . append ( ( char ) edifactvalue ) ; } } while ( bits . available ( ) > _num ) ; }	see iso 16022 : 2006 , 5.
public void write ( byte [ ] b , int offset , int length ) throws ioexception { out . write ( b , offset , length ) ; }	writes the array of bytes to the output stream and increments the number of bytes written by the size of the array .
public sampleset ( datainputstream is ) throws ioexception { int numsamples ; sampleinfo = new sampleinfo ( is ) ; numsamples = is . readint ( ) ; this . samples = new sample [ numsamples ] ; for ( int i = _num ; i < numsamples ; i ++ ) { samples [ i ] = sample . loadbinary ( is ) ; } }	creates a sampleset by reading it from the given input stream.
public void close ( ) { running = _bool ; synchronized ( histdata ) { histdata . notify ( ) ; } }	terminate the thread that autoscrolls the text .
public sqlitedatabaseconfiguration ( string path , @ sqlitedatabase . openflags int openflags ) { if ( path == null ) { throw new illegalargumentexception ( _str ) ; } this . path = path ; label = strippathforlogs ( path ) ; this . openflags = openflags ; maxsqlcachesize = _num ; locale = locale . getdefault ( ) ; }	creates a database configuration with the required parameters for opening a database and default values for all other parameters .
private void printproperties ( properties properties ) throws ioexception { stringwriter stringbuffer = new stringwriter ( ) ; bufferedreader reader = null ; properties . store ( stringbuffer , null ) ; try { reader = new bufferedreader ( new stringreader ( stringbuffer . tostring ( ) ) ) ; reader . readline ( ) ; string line = null ; while ( ( line = reader . readline ( ) ) != null ) { writer . print ( _str ) ; writer . println ( line ) ; } } finally { if ( reader != null ) { reader . close ( ) ; } } }	prints the properties to the result file.
public static < t > range < t > valueof ( string s , class < t > clazz ) { char lbm = s . charat ( _num ) ; if ( lbm != _str && lbm != _str ) throw new illegalargumentexception ( s ) ; char ubm = s . charat ( s . length ( ) - _num ) ; if ( ubm != _str && ubm != _str ) throw new illegalargumentexception ( s ) ; boundtype lbt = lbm == _str ? boundtype . closed : boundtype . open ; boundtype ubt = ubm == _str ? boundtype . closed : boundtype . open ; s = s . substring ( _num , s . length ( ) - _num ) ; string [ ] parts = s . split ( _str ) ; string lbs = parts [ _num ] ; string ubs = parts [ _num ] ; t lowerbound = lbs . equals ( _str ) ? null : boundvalue ( lbs , clazz ) ; t upperbound = ubs . equals ( _str ) ? null : boundvalue ( ubs , clazz ) ; return range ( lowerbound , lbt , upperbound , ubt ) ; }	create a range from a string produced by tostring ( ).
public static doublevector dchisq ( double x , doublevector ncp ) { int n = ncp . size ( ) ; doublevector d = new doublevector ( n ) ; double xh = math . sqrt ( x ) ; double mean ; for ( int i = _num ; i < n ; i ++ ) { mean = math . sqrt ( ncp . get ( i ) ) ; if ( ncp . get ( i ) == _num ) d . set ( i , dchisq ( x ) ) ; else d . set ( i , ( dnorm ( xh - mean ) + dnorm ( - xh - mean ) ) / ( _num * xh ) ) ; } return d ; }	returns the density of the noncentral chi - squared distribution .
@ override public void addpropertychangelistener ( propertychangelistener listener ) { propertychangesupport . addpropertychangelistener ( listener ) ; }	add a propertychangelistener to the listener list .
public void removeallbaudratequerycallbacks ( ) { baudratequerycallbacks . clear ( ) ; }	removes all baud rate query callbacks .
public void add ( abstractoption option ) { add ( options . size ( ) , option ) ; }	adds an abstractoption to the container.
private void loadverticesandrelatives ( ) { list < cnatreeelement > elementlist = new linkedlist < cnatreeelement > ( ) ; for ( igraphelementloader loader : getloaderlist ( ) ) { loader . setcnatreeelementdao ( getcnatreeelementdao ( ) ) ; elementlist . addall ( loader . loadelements ( ) ) ; } for ( cnatreeelement element : elementlist ) { graph . addvertex ( element ) ; if ( log . isdebugenabled ( ) ) { log . debug ( _str + element . gettitle ( ) ) ; } uuidmap . put ( element . getuuid ( ) , element ) ; } for ( cnatreeelement parent : elementlist ) { set < cnatreeelement > children = parent . getchildren ( ) ; for ( cnatreeelement child : children ) { createparentchildedge ( parent , child ) ; } } }	loads all vertices and adds them to the graph.
private boolean hasnonspecialattribute ( collection < string > keys ) { for ( string attr : keys ) { if ( ! attr . startswith ( _str ) ) { return _bool ; } } return _bool ; }	primitive implementation to decide if the object is a " full " or a partial .
public static final void shuffle ( double [ ] a , int start , int len , random r ) { for ( int i = start + len ; i > _num ; -- i ) { double t = a [ i ] ; int j = r . nextint ( i ) ; a [ i ] = a [ j ] ; a [ j ] = t ; } }	randomly permute the contents of a range an array .
public boolean isparitycorrect ( byte [ ] [ ] shards , int firstbyte , int bytecount , byte [ ] tempbuffer ) { checkbuffersandsizes ( shards , firstbyte , bytecount ) ; if ( tempbuffer . length < firstbyte + bytecount ) { throw new illegalargumentexception ( _str ) ; } byte [ ] [ ] tocheck = new byte [ parityshardcount ] [ ] ; system . arraycopy ( shards , datashardcount , tocheck , _num , parityshardcount ) ; return codingloop . checksomeshards ( parityrows , shards , datashardcount , tocheck , parityshardcount , firstbyte , bytecount , tempbuffer ) ; }	returns true if the parity shards contain the right data.
public static void writestream ( inputstream in , file file ) throws ioexception { fileoutputstream out = new fileoutputstream ( file ) ; try { transfer ( in , out ) ; } finally { try { out . flush ( ) ; } finally { out . close ( ) ; } } }	writes all data that can be read from the supplied inputstream to the specified file .
private static native long createentityparser ( long parentpointer , string context ) ;	creates a native entity parser .
public void firepropertychange ( string propertyname , byte oldvalue , byte newvalue ) { if ( changesupport == null || oldvalue == newvalue ) { return ; } firepropertychange ( propertyname , byte . valueof ( oldvalue ) , byte . valueof ( newvalue ) ) ; }	reports a bound property change .
private int adjustoffsetforunittests ( int offset ) { if ( system . getproperty ( _str ) == null ) return offset ; else return _num ; }	when running unit tests , we want byte offsets into the file to always be displayed as zero , so that the unit test expected results will match up with the actual results.
public static boolean isaix ( ) { return osname . indexof ( _str ) > - _num ; }	is operating system aix ?.
private double testfit ( double [ ] x , double [ ] test , distribution dist ) throws arithmeticexception { for ( int i = _num ; i < test . length ; i ++ ) { test [ i ] = dist . cdf ( x [ i ] ) ; if ( test [ i ] > _num ) { test [ i ] = _num ; } if ( test [ i ] < _num ) { test [ i ] = _num ; } if ( double . isnan ( test [ i ] ) ) { throw new arithmeticexception ( _str + dist . tostring ( ) ) ; } } arrays . sort ( test ) ; return kolmogorovsmirnovtest . simpletest ( test ) ; }	test the quality of a fit .
public boolean supportssql ( ) { return _bool ; }	returns true if the omgraphichandler can handle sql statements for filtering .
private static boolean isvalidipv4 ( final string ipaddress ) { boolean status = _bool ; if ( stringutils . isnotempty ( ipaddress ) ) { status = inetaddressutils . isipv4address ( ipaddress ) ; } return status ; }	validates ipv4 address using regex for the given ipaddress.
public static ptabridge v ( ) { return v ; }	return the static singleton for the pta.
public void registercacheupdateperiodchangelistener ( final propertychangelistener listener ) { cacheupdateperiodlisteners . add ( listener ) ; }	register a listener which is notified when the modelupdate period value is changed .
public void testnullstoredfield ( ) throws exception { directory dir = newdirectory ( ) ; analyzer analyzer = new mockanalyzer ( random ( ) ) ; indexwriter iw = new indexwriter ( dir , new indexwriterconfig ( analyzer ) ) ; document doc = new document ( ) ; iw . adddocument ( doc ) ; expectthrows ( illegalargumentexception . class , null ) ; assertnull ( iw . gettragicexception ( ) ) ; iw . close ( ) ; directoryreader r = directoryreader . open ( dir ) ; assertequals ( _num , r . numdocs ( ) ) ; r . close ( ) ; dir . close ( ) ; }	test a null string value doesn ' t abort the entire segment.
public static document readdocument ( string filename ) throws saxexception , ioexception { documentbuilder docbuilder ; document result = null ; documentbuilderfactory docbuilderfactory = documentbuilderfactory . newinstance ( ) ; docbuilderfactory . setignoringelementcontentwhitespace ( _bool ) ; try { docbuilder = docbuilderfactory . newdocumentbuilder ( ) ; } catch ( parserconfigurationexception e ) { throw new error ( e ) ; } file sourcefile = new file ( filename ) ; result = docbuilder . parse ( sourcefile ) ; return result ; }	reads document from file.
@ override public double [ ] analyse ( double [ ] aframe ) { if ( aframe . length != framelength ) throw new illegalargumentexception ( _str + framelength + _str + aframe . length ) ; double [ ] real = new double [ fftsize ] ; double [ ] imag = new double [ fftsize ] ; system . arraycopy ( aframe , _num , real , _num , aframe . length ) ; fft . transform ( real , imag , _bool ) ; mathutils . topolarcoordinates ( real , imag ) ; real = mathutils . log ( real ) ; arrays . fill ( imag , _num ) ; double b = _num ; int bindex = ( int ) ( b / frequencyresolution ) ; double [ ] invreal ; double [ ] invimag ; if ( invfftsize == fftsize ) { invreal = real ; invimag = imag ; } else { invreal = new double [ invfftsize ] ; system . arraycopy ( real , _num , invreal , _num , bindex + _num ) ; invimag = new double [ invfftsize ] ; } for ( int i = bindex + _num ; i < invfftsize / _num ; i ++ ) { invreal [ i ] = invreal [ bindex ] ; } for ( int i = _num ; i < invfftsize / _num ; i ++ ) { invreal [ invfftsize - i - _num ] = invreal [ i ] ; } fft . transform ( invreal , invimag , _bool ) ; return invreal ; }	apply this framebasedanalyser to the given data .
public searchsourcebuilder scriptfield ( string name , script script ) { if ( scriptfields == null ) { scriptfields = new arraylist < > ( ) ; } scriptfields . add ( new scriptfield ( name , script ) ) ; return this ; }	adds a script field under the given name with the provided script .
public static < t > t withobjectstreams ( socket socket , @ closureparams ( value = simpletype . class , options = { _str , _str } ) closure < t > closure ) throws ioexception { inputstream input = socket . getinputstream ( ) ; outputstream output = socket . getoutputstream ( ) ; objectoutputstream oos = new objectoutputstream ( output ) ; objectinputstream ois = new objectinputstream ( input ) ; try { t result = closure . call ( new object [ ] { ois , oos } ) ; inputstream temp1 = ois ; ois = null ; temp1 . close ( ) ; temp1 = input ; input = null ; temp1 . close ( ) ; outputstream temp2 = oos ; oos = null ; temp2 . close ( ) ; temp2 = output ; output = null ; temp2 . close ( ) ; return result ; } finally { closewithwarning ( ois ) ; closewithwarning ( input ) ; closewithwarning ( oos ) ; closewithwarning ( output ) ; } }	creates an inputobjectstream and an outputobjectstream from a socket , and passes them to the closure.
public jfiledatastorechooser ( shell parent , int style , final string [ ] extensions ) { this ( parent , style , associations ( arrays . aslist ( extensions ) ) ) ; }	create a dialog that filters for files with the specified extensions .
private void adjustalignment ( int align , int curalign ) { if ( ( ! fixed_width ) && ( align != curalign ) ) { if ( curline . getcomponentcount ( ) == _num ) { curline . setlayout ( new flowlayout ( curalign ) ) ; } } }	the following replaces the layout of the curline container with the correct alignment , in non fixed width alignment is done by flowlayout ' s orientation . in case the line is not empty , a new line will be opened by newlineifnotempty below.
public void removelistener ( trackinglistener listener ) { listeners . remove ( listener ) ; }	remove from listeners list.
void createimpl ( boolean stream ) throws socketexception { if ( impl == null ) setimpl ( ) ; try { impl . create ( stream ) ; created = _bool ; } catch ( ioexception e ) { throw new socketexception ( e . getmessage ( ) ) ; } }	creates the socket implementation .
public boolean shexpmatch ( string str , string shexp ) { stringtokenizer tokenizer = new stringtokenizer ( shexp , _str ) ; int startpos = _num ; while ( tokenizer . hasmoretokens ( ) ) { string token = tokenizer . nexttoken ( ) ; int temp = str . indexof ( token , startpos ) ; if ( startpos == _num && ! shexp . startswith ( _str ) && temp != _num ) { return _bool ; } if ( ! tokenizer . hasmoretokens ( ) && ! shexp . endswith ( _str ) && ! str . endswith ( token ) ) { return _bool ; } if ( temp == - _num ) { return _bool ; } else { startpos = temp + token . length ( ) ; } } return _bool ; }	returns true if the string matches the specified shell expression.
public char peek ( ) { return isempty ( ) ? _num : queue . charat ( pos ) ; }	retrieves but does not remove the first character from the queue .
private string [ ] parentkey ( string name , int idx ) { string [ ] parts = name . split ( _str ) ; if ( idx > parts . length ) return null ; string parent = _str ; string key = null ; if ( idx < parts . length ) key = parts [ idx ] ; for ( int i = _num ; i < idx ; i ++ ) { parent = parent . length ( ) > _num ? parent + _str + parts [ i ] : parts [ i ] ; } return new string [ ] { parent , key } ; }	splits a name formatted like a.
public diphoneunitdatabase ( url url , boolean isbinary ) throws ioexception { if ( ! useindexing || usecache ) { diphonemap = new linkedhashmap ( ) ; } inputstream is = utilities . getinputstream ( url ) ; indexname = getindexname ( url . tostring ( ) ) ; if ( isbinary ) { loadbinary ( is ) ; } else { loadtext ( is ) ; } is . close ( ) ; sampleinfo = new sampleinfo ( samplerate , numchannels , residualfold , lpcmin , lpcrange , _num ) ; }	creates the diphoneunitdatabase from the given input stream .
public static list < notificationdto > transformtodto ( list < notification > notifications ) { if ( notifications == null ) { throw new webapplicationexception ( _str , status . internal_server_error ) ; } list < notificationdto > result = new arraylist < notificationdto > ( ) ; for ( notification notification : notifications ) { result . add ( transformtodto ( notification ) ) ; } return result ; }	converts list of notification entity objects to list of notificationdto objects .
public void writeto ( final packetoutputstream os ) { os . write ( parameterwriter . quote ) ; os . write ( datetobyte ( ) ) ; parameterwriter . formatmicroseconds ( os , ts . getnanos ( ) / _num , fractionalseconds ) ; os . write ( parameterwriter . quote ) ; }	write timestamps to outputstream .
public long skip ( long n ) throws ioexception , logexception { if ( length < n ) badread ( ( int ) n ) ; n = in . skip ( n ) ; length -= ( int ) n ; return n ; }	skips n bytes of input .
public drivertask discoverstorageprovider ( storageprovider storageprovider , list < storagesystem > storagesystems ) { dellscdrivertask task = new dellscdrivertask ( _str ) ; try { log . info ( _str , storageprovider . getproviderhost ( ) , storageprovider . getportnumber ( ) , storageprovider . getusername ( ) ) ; storagecenterapi api = connectionmanager . getconnection ( storageprovider . getproviderhost ( ) , storageprovider . getportnumber ( ) , storageprovider . getusername ( ) , storageprovider . getpassword ( ) , _bool ) ; log . info ( _str , storageprovider . getproviderhost ( ) , storageprovider . getusername ( ) ) ; storageprovider . setaccessstatus ( accessstatus . read_write ) ; storageprovider . setmanufacturer ( _str ) ; storageprovider . setproviderversion ( driverversion ) ; storageprovider . setissupportedversion ( _bool ) ; emdatacollector em = api . getdsminfo ( ) ; if ( em != null ) { log . info ( _str , em . type , em . version , em . javaversion ) ; storageprovider . setproviderversion ( em . version ) ; } storagecenter [ ] scs = api . getstoragecenterinfo ( ) ; for ( storagecenter sc : scs ) { storagesystem storagesystem = util . getstoragesystemfromstoragecenter ( api , sc , null ) ; storagesystem . setsystemtype ( drivername ) ; storagesystems . add ( storagesystem ) ; } task . setstatus ( drivertask . taskstatus . ready ) ; } catch ( exception e ) { string msg = string . format ( _str , e ) ; log . error ( msg ) ; task . setfailed ( msg ) ; } return task ; }	perform discovery for a storage provider .
public void zoomin ( ) { zoomin ( null ) ; }	zooms into the graph by zoomfactor .
public void removeresponsecodelistener ( actionlistener a ) { responsecodelisteners . removeelement ( a ) ; }	removes a response listener.
public inputfielddialog ( final string caption_key , final string label_key ) { string caption = i18n . tr ( caption_key ) ; frame frame = guimediator . getappframe ( ) ; _dialog = new jdialog ( frame , caption , _bool ) ; _dialog . setsize ( _num , _num ) ; labeledcomponent component = new labeledcomponent ( label_key , text_field , labeledcomponent . left_glue ) ; string [ ] buttonlabelkeys = { i18n . tr ( _str ) , i18n . tr ( _str ) } ; string [ ] buttonlabeltips = { i18n . tr ( _str ) , i18n . tr ( _str ) } ; actionlistener [ ] buttonlisteners = { new oklistener ( ) , new cancellistener ( ) } ; buttonrow buttons = new buttonrow ( buttonlabelkeys , buttonlabeltips , buttonlisteners , buttonrow . x_axis , buttonrow . left_glue ) ; container contentpane = _dialog . getcontentpane ( ) ; boxpanel componentpanel = new boxpanel ( boxpanel . y_axis ) ; componentpanel . add ( box . createverticalglue ( ) ) ; componentpanel . add ( component . getcomponent ( ) ) ; componentpanel . add ( box . createverticalglue ( ) ) ; main_panel . add ( componentpanel ) ; main_panel . add ( box . createverticalglue ( ) ) ; main_panel . add ( buttons ) ; contentpane . add ( main_panel ) ; }	constructs an input field using the specified locale - specific keys for both the caption and the field label .
public entityloadinfo create ( entity entity ) { return create ( entity , null ) ; }	create a new info instance with empty view name .
public float ( point2d pt2d ) { setlatlon ( pt2d . gety ( ) , pt2d . getx ( ) , _bool ) ; }	create float version from point2d object , where the x , y values are expected to be decimal degrees .
public final static boolean ispotentialziparchive ( string name ) { int lastdot = name . lastindexof ( _str ) ; if ( lastdot == - _num ) return _bool ; if ( name . lastindexof ( file . separatorchar ) > lastdot ) return _bool ; int length = name . length ( ) ; int extensionlength = length - lastdot - _num ; if ( extensionlength == extension_java . length ( ) ) { for ( int i = extensionlength - _num ; i >= _num ; i -- ) { if ( character . tolowercase ( name . charat ( length - extensionlength + i ) ) != extension_java . charat ( i ) ) { break ; } if ( i == _num ) { return _bool ; } } } if ( extensionlength == extension_class . length ( ) ) { for ( int i = extensionlength - _num ; i >= _num ; i -- ) { if ( character . tolowercase ( name . charat ( length - extensionlength + i ) ) != extension_class . charat ( i ) ) { return _bool ; } } return _bool ; } return _bool ; }	returns whether the given name is potentially a zip archive file name ( it has a file extension and it is not ".
public void open ( ) throws ioexception { connection = new datagramsocket ( ) ; connection . setsotimeout ( timeout ) ; }	open the datagram connection.
default void foreachremaining ( intconsumer action ) { objects . requirenonnull ( action ) ; while ( hasnext ( ) ) action . accept ( nextint ( ) ) ; }	performs the given action for each remaining element until all elements have been processed or the action throws an exception.
private boolean isci ( ) { return objects . equals ( system . getenv ( _str ) , _str ) ; }	check if we are running as ci.
public docknode ( node contents , string title ) { this ( contents , title , null ) ; }	creates a default docknode with a default title bar and layout .
public void test2033092 ( ) { relativedateformat rdf = new relativedateformat ( ) ; rdf . setshowzerodays ( _bool ) ; rdf . setshowzerohours ( _bool ) ; rdf . setminutesuffix ( _str ) ; rdf . sethoursuffix ( _str ) ; rdf . setsecondsuffix ( _str ) ; decimalformat hoursformatter = new decimalformat ( ) ; hoursformatter . setmaximumfractiondigits ( _num ) ; hoursformatter . setmaximumintegerdigits ( _num ) ; hoursformatter . setminimumintegerdigits ( _num ) ; rdf . sethourformatter ( hoursformatter ) ; decimalformat minsformatter = new decimalformat ( ) ; minsformatter . setmaximumfractiondigits ( _num ) ; minsformatter . setmaximumintegerdigits ( _num ) ; minsformatter . setminimumintegerdigits ( _num ) ; rdf . setminuteformatter ( minsformatter ) ; decimalformat secondsformatter = new decimalformat ( ) ; secondsformatter . setmaximumfractiondigits ( _num ) ; secondsformatter . setmaximumintegerdigits ( _num ) ; secondsformatter . setminimumintegerdigits ( _num ) ; rdf . setsecondformatter ( secondsformatter ) ; string s = rdf . format ( new date ( _num * _num * _num * _num + _num ) ) ; assertequals ( _str , s ) ; }	test that we can configure the relativedateformat to show hh : mm : ss .
public static long parseid ( uri contenturi ) { string last = contenturi . getlastpathsegment ( ) ; return last == null ? - _num : long . parselong ( last ) ; }	converts the last path segment to a long.
public void disablevm ( string hostname , long durationmillis ) throws illegalstateexception { logger . info ( _str + hostname + _str + durationmillis + _str ) ; assignablevms . disableuntil ( hostname , system . currenttimemillis ( ) + durationmillis ) ; }	disable the virtual machine with the specified hostname.
protected final void endofinput ( ) throws ioexception { if ( cacherequest != null ) { cachebody . close ( ) ; } httpengine . release ( _bool ) ; }	closes the cache entry and makes the socket available for reuse.
public int left ( ) { return data . length ( ) - pos ; }	number of characters left .
public featureset combine ( final featureset other ) { final set < feature > enabled = new hashset < > ( this . enabled ) ; enabled . addall ( other . enabled ) ; final set < feature > disabled = new hashset < > ( this . disabled ) ; disabled . addall ( other . disabled ) ; return new featureset ( enabled , disabled ) ; }	combine this feature set with another .
public void removeinterval ( final batchwriter writer , final temporalinterval interval , final statement statement ) throws mutationsrejectedexception { final text cf = new text ( statementserializer . writecontext ( statement ) ) ; final text cqbegin = new text ( keyparts . cq_begin ) ; final text cqend = new text ( keyparts . cq_end ) ; text keytext = new text ( interval . getaskeybeginning ( ) ) ; keyparts . appenduniqueness ( statement , keytext ) ; mutation m = new mutation ( keytext ) ; m . putdelete ( cf , cqbegin ) ; writer . addmutation ( m ) ; keytext = new text ( interval . getaskeyend ( ) ) ; keyparts . appenduniqueness ( statement , keytext ) ; m = new mutation ( keytext ) ; m . putdelete ( cf , cqend ) ; writer . addmutation ( m ) ; }	remove an interval index todo : integrate into keyparts ( or eliminate ).
public static final string removedatafolderpath ( string fullpath ) { file sdcard = environment . getexternalstoragedirectory ( ) ; string datafolderpath = sdcard . getabsolutepath ( ) + _str + mainapp . getdatafolder ( ) + _str ; if ( fullpath . indexof ( datafolderpath ) == _num ) { return fullpath . substring ( datafolderpath . length ( ) ) ; } return fullpath ; }	takes a full path to owncloud file and removes beginning which is path to ownload data folder.
default completablefuture < optional < r > > matchasync ( final executor executor , final t value ) { return completablefuture . supplyasync ( null , executor ) ; }	similar to match , but executed asynchonously on supplied executor .
public static void main ( string [ ] args ) throws formatexception { debug . init ( ) ; if ( args . length == _num ) { debug . output ( _str ) ; system . exit ( _num ) ; } for ( int argsi = _num ; argsi < args . length ; argsi ++ ) { rootpath = args [ argsi ] ; libraryselectiontable lst = new libraryselectiontable ( rootpath ) ; if ( debug . debugging ( _str ) ) { debug . output ( _str + rootpath ) ; debug . output ( _str + lst . getdatabasename ( ) ) ; } println ( _str ) ; println ( _str + rootpath ) ; println ( _str + lst . getdatabasedescription ( ) ) ; list < string > libraries = lst . getlibrarynames ( ) ; if ( debug . debugging ( _str ) ) { print ( _str ) ; for ( string libraryname : libraries ) { print ( libraryname , _str ) ; } println ( ) ; println ( ) ; } for ( string libraryname : libraries ) { string prefix = lst . getdatabasename ( ) + _str + libraryname ; println ( _str + prefix ) ; printlibrary ( prefix , lst . getcat ( libraryname ) ) ; println ( ) ; } } }	the main program . takes path arguments , and prints the db it finds.
private static string wildcardtoregex ( string pattern ) { return _str + stringutils . replaceeach ( escaperegexp ( pattern ) , new string [ ] { _str , _str } , new string [ ] { _str , _str } ) + _str ; }	converts wildcard to regular expression.
protected void clearcache ( ) { if ( _cache != null ) { _cache . clear ( ) ; _cache = null ; } }	clears the cache soft reference if existing .
public string sqlad_getcustomentitytypes ( string vendorname , string catalogname , string schemaname ) { string tablename = _str ; arraylist < string > columnnames = new arraylist < string > ( ) ; columnnames . add ( _str ) ; arraylist < string > aliasnames = new arraylist < string > ( ) ; aliasnames . add ( _str ) ; arraylist < string > conditions = new arraylist < string > ( ) ; conditions . add ( _str ) ; arraylist < string > sortcolumns = new arraylist < string > ( ) ; sortcolumns . add ( _str ) ; return sql_select ( vendorname , catalogname , schemaname , tablename , null , columnnames , aliasnames , conditions , sortcolumns , _bool ) ; }	gets the database specific sql command to find custom entity types.
public void paintcomponent ( graphics g ) { int x = padding ; int y = padding ; g . drawimage ( picture , x , y , scalew , scaleh , null ) ; x += scalew + padding ; g . drawimage ( picture , x , y , x + scalew , y + scaleh , _num , _num , picture . getwidth ( ) , picture . getheight ( ) , null ) ; x += scalew + padding ; graphics2d g2d = ( graphics2d ) g . create ( ) ; g2d . translate ( x , y ) ; g2d . scale ( scale_factor , scale_factor ) ; g2d . drawimage ( picture , _num , _num , null ) ; g2d . dispose ( ) ; x += scalew + padding ; g2d = ( graphics2d ) g . create ( ) ; affinetransform at = new affinetransform ( ) ; at . translate ( x , y ) ; at . scale ( scale_factor , scale_factor ) ; g2d . drawimage ( picture , at , null ) ; g2d . dispose ( ) ; x += scalew + padding ; image scaledimg = picture . getscaledinstance ( scalew , scaleh , image . scale_default ) ; g . drawimage ( scaledimg , x , y , null ) ; }	draws the picture five times , using the five different scaling approaches described in the book.
public int hashcode ( ) { return idtype . hashcode ( ) ; }	returns the hash code of the object.
private static void backupaudioconfig ( ) { if ( null != mrestoreaudioconfigtimer ) { mrestoreaudioconfigtimer . cancel ( ) ; mrestoreaudioconfigtimer = null ; mrestoreaudioconfigtimermask = null ; } else if ( null == maudiomode ) { audiomanager audiomanager = getaudiomanager ( ) ; maudiomode = audiomanager . getmode ( ) ; misspeakeron = audiomanager . isspeakerphoneon ( ) ; } }	back up the current audio config .
public static string buildimdndeliveryreport ( string msgid , imdndocument . deliverystatus status , long timestamp ) { string method ; switch ( status ) { case displayed : method = _str ; break ; case delivered : method = _str ; break ; default : method = _str ; break ; } return _str + utf8_str + _str + crlf + _str + crlf + _str + msgid + _str + crlf + _str + dateutils . encodedate ( timestamp ) + _str + crlf + _str + method + _str + status + _str + method + _str + crlf + _str ; }	build a delivery report.
private speedrunsliverequest ( ) { super ( url ) ; }	creates a new request .
public static bitmap decoderesourcewithbackouts ( resources res , bitmapfactory . options options , int id ) { boolean nobitmap = _bool ; int num_tries = _num ; if ( options . insamplesize < _num ) { options . insamplesize = _num ; } bitmap bmap = null ; while ( nobitmap ) { try { bmap = bitmapfactory . decoderesource ( res , id , options ) ; nobitmap = _bool ; } catch ( java . lang . outofmemoryerror e ) { if ( ++ num_tries >= bitmap_load_backout_attempts ) { throw e ; } bmap = null ; system . gc ( ) ; options . insamplesize *= _num ; } } return bmap ; }	loads bitmap from a resource that may be downsampled in low - memory situations .
public void readdatafile ( string content ) throws datafileexception { if ( content == null || content . length ( ) <= _num ) throw new illegalstateexception ( _str ) ; bytearrayinputstream bis = new bytearrayinputstream ( content . getbytes ( ) ) ; readdatafile ( bis , null ) ; }	populates ( or reloads ) the data file with the text of the given content.
public static string readutf ( datainput in ) throws ioexception { return datainputstream . readutf ( in ) ; }	note . this is a static method !.
protected object lazilyloaddesktopproperty ( string name ) { if ( name . startswith ( _str ) ) { return lazilyloadgtkicon ( name ) ; } return super . lazilyloaddesktopproperty ( name ) ; }	overridden to handle gtk icon loading.
public oauthrsasha1signer ( string privatekeystring ) throws oauthexception { if ( privatekeystring == null ) { throw new oauthexception ( _str ) ; } else if ( privatekeystring . length ( ) == _num ) { throw new oauthexception ( _str ) ; } try { setprivatekey ( rsasha1privatekeyhelper . getprivatekey ( privatekeystring ) ) ; } catch ( base64decoderexception e ) { throw new oauthexception ( _str , e ) ; } catch ( nosuchalgorithmexception e ) { throw new oauthexception ( _str , e ) ; } catch ( invalidkeyspecexception e ) { throw new oauthexception ( _str , e ) ; } }	sets the rsa - sha1 private key object used to sign this request .
private map < string , volume > groupvolumesbyreplicationgroup ( list < volume > volumelist ) { map < string , volume > repgrouptovolumemap = new hashmap < string , volume > ( ) ; for ( volume volume : volumelist ) { string repgroupname = volume . getreplicationgroupinstance ( ) ; if ( volume . isvplexvolume ( _dbclient ) ) { volume backedvol = vplexutil . getvplexbackendvolume ( volume , _bool , _dbclient ) ; if ( backedvol != null ) { repgroupname = backedvol . getreplicationgroupinstance ( ) ; } } repgrouptovolumemap . put ( repgroupname , volume ) ; } return repgrouptovolumemap ; }	returns a map of replication group name to one of the volumes in the group .
public defaultfilefilter ( string extension , string description ) { ext = extension . tolowercase ( ) ; desc = description ; }	constructs a new filter for the specified extension and descpription .
public void appendcell ( boolean value ) { appendcell ( string . valueof ( value ) ) ; }	appends a new cell to the current row containing the provided boolean value .
public string name ( ) { return system . getproperty ( _str ) ; }	returns the name of the currently - running jvm .
protected void addurl ( url url ) { try { originalurls . add ( url ) ; searchlist . add ( createsearchurl ( url ) ) ; } catch ( malformedurlexception e ) { } }	adds the specified url to the search list .
public void initstructure ( ) throws exception { int nattribute = _num ; for ( int iorder = _num ; iorder < m_instances . numattributes ( ) ; iorder ++ ) { if ( nattribute == m_instances . classindex ( ) ) { nattribute ++ ; } } m_parentsets = new parentset [ m_instances . numattributes ( ) ] ; for ( int iattribute = _num ; iattribute < m_instances . numattributes ( ) ; iattribute ++ ) { m_parentsets [ iattribute ] = new parentset ( m_instances . numattributes ( ) ) ; } }	init structure initializes the structure to an empty graph or a naive bayes graph ( depending on the - n flag ) .
@ override public synchronized completablefuture < void > disconnect ( ) { closefuture = new completablefuture < > ( ) ; if ( ! consumers . isempty ( ) ) { consumers . foreach ( null ) ; if ( havependingread && cursor . cancelpendingreadrequest ( ) ) { havependingread = _bool ; } } else { closefuture . complete ( null ) ; } return closefuture ; }	disconnect all consumers on this dispatcher ( server side close ).
public static string readasciiline ( inputstream in ) throws ioexception { stringbuilder result = new stringbuilder ( _num ) ; while ( _bool ) { int c = in . read ( ) ; if ( c == - _num ) { throw new eofexception ( ) ; } else if ( c == _str ) { break ; } result . append ( ( char ) c ) ; } int length = result . length ( ) ; if ( length > _num && result . charat ( length - _num ) == _str ) { result . setlength ( length - _num ) ; } return result . tostring ( ) ; }	returns the ascii characters up to but not including the next " \ r \ n " , or " \ n " .
protected boolean ipisbroadcast ( int ipaddress ) { int inv_subnet_mask = ~ this . subnet_mask ; return ( ( ipaddress & inv_subnet_mask ) == inv_subnet_mask ) ; }	checks whether an ip address is a broadcast address or not ( determines using subnet mask ).
public void addcellappearancestoworklist ( df_latticecell cell ) { for ( enumeration < df_equation > e = getequations ( ) ; e . hasmoreelements ( ) ; ) { df_equation eq = e . nextelement ( ) ; if ( eq . hascell ( cell ) ) { addtoworklist ( eq ) ; } } }	add all equations which contain a given cell to the work list .
public void remove ( constraintwidget widget ) { element tounselect = null ; for ( element selection : mselectedwidgets ) { if ( selection . widget == widget ) { tounselect = selection ; break ; } } if ( tounselect != null ) { mselectedwidgets . remove ( tounselect ) ; } selectionhaschanged ( ) ; }	remove the widget from the current selection.
public static long hexstringtolong ( final string hexstring ) { preconditions . checknotnull ( hexstring , _str ) ; preconditions . checkargument ( ishexstring ( hexstring ) , string . format ( _str , hexstring ) ) ; if ( ( hexstring . length ( ) == _num ) && ( hexstring . charat ( _num ) >= _num ) ) { final string straddr1 = hexstring . substring ( _num , hexstring . length ( ) - _num ) ; final string straddr2 = hexstring . substring ( hexstring . length ( ) - _num ) ; return ( long . parselong ( straddr1 , _num ) << _num ) + long . parselong ( straddr2 , _num ) ; } return long . parselong ( hexstring , _num ) ; }	converts an hex string to long .
public static boolean containsfile ( @ notnull sourceprovider provider , @ notnull file file ) { collection < file > srcdirectories = getallsourcefolders ( provider ) ; if ( filesequal ( provider . getmanifestfile ( ) , file ) ) { return _bool ; } for ( file container : srcdirectories ) { file parent = container . getparentfile ( ) ; if ( parent != null && parent . isdirectory ( ) && filesequal ( parent , file ) ) { return _bool ; } if ( ! container . exists ( ) ) { continue ; } if ( isancestor ( container , file , _bool ) ) { return _bool ; } } return _bool ; }	returns true iff this sourceprovider provides the source folder that contains the given file .
public static string checknotempty ( string string , object errormessage ) { if ( exoplayerlibraryinfo . assertions_enabled && textutils . isempty ( string ) ) { throw new illegalargumentexception ( string . valueof ( errormessage ) ) ; } return string ; }	ensures that a string passed as an argument to the calling method is not null or 0 - length .
void runpostsearch ( int cntitems ) ;	runs when search results are retrieved .
private sslengineresult unwrap ( ) throws sslexception { if ( appbuffer == null ) { appbuffer = iobuffer . allocate ( innetbuffer . remaining ( ) ) ; } else { appbuffer . expand ( innetbuffer . remaining ( ) ) ; } sslengineresult res ; status status = null ; handshakestatus handshakestatus = null ; do { res = sslengine . unwrap ( innetbuffer . buf ( ) , appbuffer . buf ( ) ) ; status = res . getstatus ( ) ; handshakestatus = res . gethandshakestatus ( ) ; if ( status == sslengineresult . status . buffer_overflow ) { appbuffer . capacity ( appbuffer . capacity ( ) << _num ) ; appbuffer . limit ( appbuffer . capacity ( ) ) ; continue ; } } while ( ( ( status == sslengineresult . status . ok ) || ( status == sslengineresult . status . buffer_overflow ) ) && ( ( handshakestatus == sslengineresult . handshakestatus . not_handshaking ) || ( handshakestatus == sslengineresult . handshakestatus . need_unwrap ) ) ) ; return res ; }	decrypt the incoming buffer and move the decrypted data to an application buffer .
public certificate requestcertificate ( byte [ ] csr ) throws acmeexception { return requestcertificate ( csr , null , null ) ; }	requests a certificate for the given csr.
public void clear ( ) { mstrings . clear ( ) ; notifydatasetchanged ( ) ; }	remove all elements from the list .
@ suppresswarnings ( { _str } ) private static gridurideploymentfileprocessorresult processwithdescriptorfile ( gridurideploymentspringdocument doc , file file , string uri , ignitelogger log ) throws ignitespiexception { classloader clsldr = gridurideploymentclassloaderfactory . create ( u . gridclassloader ( ) , file , log ) ; list < class < ? extends computetask < ? , ? > > > tasks = doc . gettasks ( clsldr ) ; list < class < ? extends computetask < ? , ? > > > validtasks = null ; if ( ! f . isempty ( tasks ) ) { validtasks = new arraylist < > ( ) ; for ( class < ? extends computetask < ? , ? > > task : tasks ) { if ( ! isallowedtaskclass ( task ) ) { u . warn ( log , _str + _str + task + _str ) ; } else { if ( log . isdebugenabled ( ) ) log . debug ( _str + task . getname ( ) ) ; validtasks . add ( task ) ; } } } gridurideploymentfileprocessorresult res = new gridurideploymentfileprocessorresult ( ) ; res . setfile ( file ) ; res . setclassloader ( clsldr ) ; if ( ! f . isempty ( validtasks ) ) res . settaskclasses ( validtasks ) ; else if ( log . isdebugenabled ( ) ) log . debug ( _str + file . getabsolutepath ( ) + _str + u . hidepassword ( uri ) + _str ) ; return res ; }	processes given gar file and returns back all tasks which are in descriptor .
private < t extends dataobject > boolean testselections ( jclass jc , t dobj ) { list < jselection > list = jc . getselections ( ) ; for ( jselection js : list ) { if ( testselection ( jc , js , dobj ) == _bool ) { return _bool ; } } return _bool ; }	selections are logically and - ed together.
public void truncate ( ) { calculateidealpoint ( ) ; translatebyidealpoint ( ) ; list < list < solution > > members = associatetoreferencepoint ( this ) ; clear ( ) ; for ( int i = _num ; i < members . size ( ) ; i ++ ) { list < solution > associations = members . get ( i ) ; if ( associations . size ( ) > _num ) { add ( select ( associations , i ) ) ; } } }	truncates the population so that only one solution is associated with each reference vector .
protected void ondownloading ( ) { if ( logconfiguration . loggingisenabled ( ) ) { logger . log ( level . info , messages . downloadingresources ( ) ) ; } updating = _bool ; fireapplicationcacheevent ( cacheevent . ondownloading ) ; }	called when a downloading event is triggered.
protected synchronized void addtransitionlistener ( hashtable < txstate , hashtable < txstate , set < eventlistener > > > listeners , eventlistener lstnr , txstate from , txstate to ) { hashtable < txstate , set < eventlistener > > lstnrs = listeners . get ( from ) ; if ( lstnrs == null ) lstnrs = new hashtable < txstate , set < eventlistener > > ( ) ; set < eventlistener > tolstnrs = lstnrs . get ( to ) ; if ( tolstnrs == null ) tolstnrs = new hashset < eventlistener > ( ) ; if ( ! tolstnrs . contains ( lstnr ) ) tolstnrs . add ( lstnr ) ; lstnrs . put ( to , tolstnrs ) ; listeners . put ( from , lstnrs ) ; }	help function for adding transition listeners .
public boolean hasexclusion ( ) { return ! mexcludedclasses . isempty ( ) || ! mexcludedtests . isempty ( ) ; }	return true if there are exclusions rules defined .
private int ensurebaselineongrid ( ) { float baseline = getbaseline ( ) ; float gridalign = baseline % four_dip ; if ( gridalign != _num ) { extratoppadding = ( int ) ( four_dip - math . ceil ( gridalign ) ) ; } return extratoppadding ; }	ensure that the first line of text sits on the 4dp grid .
@ override public void compute ( ) { spliterator < p_in > rs = spliterator , ls ; long sizeestimate = rs . estimatesize ( ) ; long sizethreshold = gettargetsize ( sizeestimate ) ; boolean forkright = _bool ; @ suppresswarnings ( _str ) k task = ( k ) this ; atomicreference < r > sr = sharedresult ; r result ; while ( ( result = sr . get ( ) ) == null ) { if ( task . taskcanceled ( ) ) { result = task . getemptyresult ( ) ; break ; } if ( sizeestimate <= sizethreshold || ( ls = rs . trysplit ( ) ) == null ) { result = task . doleaf ( ) ; break ; } k leftchild , rightchild , tasktofork ; task . leftchild = leftchild = task . makechild ( ls ) ; task . rightchild = rightchild = task . makechild ( rs ) ; task . setpendingcount ( _num ) ; if ( forkright ) { forkright = _bool ; rs = ls ; task = leftchild ; tasktofork = rightchild ; } else { forkright = _bool ; task = rightchild ; tasktofork = leftchild ; } tasktofork . fork ( ) ; sizeestimate = rs . estimatesize ( ) ; } task . setlocalresult ( result ) ; task . trycomplete ( ) ; }	overrides abstracttask version to include checks for early exits while splitting or computing .
public static map < string , object > createcontentassoc ( dispatchcontext dctx , map < string , ? extends object > rcontext ) { map < string , object > context = utilmisc . makemapwritable ( rcontext ) ; context . put ( _str , _str ) ; list < string > targetoperationlist = contentworker . preptargetoperationlist ( context , _str ) ; list < string > contentpurposelist = contentworker . prepcontentpurposelist ( context ) ; context . put ( _str , targetoperationlist ) ; context . put ( _str , contentpurposelist ) ; context . put ( _str , null ) ; map < string , object > result = null ; try { result = createcontentassocmethod ( dctx , context ) ; } catch ( genericserviceexception e ) { return serviceutil . returnerror ( e . getmessage ( ) ) ; } catch ( genericentityexception e2 ) { return serviceutil . returnerror ( e2 . getmessage ( ) ) ; } catch ( exception e3 ) { return serviceutil . returnerror ( e3 . getmessage ( ) ) ; } return result ; }	create a contentassoc service.
public string formatwithlocale ( locale locale , string ... args ) { return string . format ( locale , this . content , ( object [ ] ) args ) ; }	formats the applied args into the template content.
private static < t extends abstractblockbase < t > > t addpathtolinearscanorder ( t block , list < t > order , priorityqueue < t > worklist , bitset visitedblocks ) { block . setlinearscannumber ( order . size ( ) ) ; order . add ( block ) ; t mostlikelysuccessor = findandmarkmostlikelysuccessor ( block , visitedblocks ) ; enqueuesuccessors ( block , worklist , visitedblocks ) ; if ( mostlikelysuccessor != null ) { if ( ! mostlikelysuccessor . isloopheader ( ) && mostlikelysuccessor . getpredecessorcount ( ) > _num ) { double unscheduledsum = _num ; for ( t pred : mostlikelysuccessor . getpredecessors ( ) ) { if ( pred . getlinearscannumber ( ) == - _num ) { unscheduledsum += pred . probability ( ) ; } } if ( unscheduledsum > block . probability ( ) / penalty_versus_unscheduled ) { visitedblocks . clear ( mostlikelysuccessor . getid ( ) ) ; return null ; } } return mostlikelysuccessor ; } return null ; }	add a linear path to the linear scan order greedily following the most likely successor .
private static dimension createthumbdimension ( final bufferedimage image , final int maxwidth , final int maxheight ) { dimension dimension = new dimension ( ) ; if ( image . getwidth ( ) >= image . getheight ( ) ) { if ( image . getwidth ( ) >= maxwidth ) { dimension . width = maxwidth ; dimension . height = math . round ( ( ( float ) maxwidth / image . getwidth ( ) ) * image . getheight ( ) ) ; } else { dimension . height = image . getheight ( ) ; dimension . width = image . getwidth ( ) ; } } else { if ( image . getheight ( ) >= maxheight ) { dimension . height = maxheight ; dimension . width = math . round ( ( ( ( float ) maxheight / image . getheight ( ) ) * image . getwidth ( ) ) ) ; } else { dimension . height = image . getheight ( ) ; dimension . width = image . getwidth ( ) ; } } return dimension ; }	creates dimension of thumb .
private boolean hascurrentaccountchanged ( ) { account account = accountutils . getcurrentowncloudaccount ( this ) ; if ( account == null ) { return _bool ; } else { return ! moriginalcurrentaccount . equals ( account . name ) ; } }	checks actual current account against current accounts when the activity has been started .
public int nextclearbit ( int index ) { int i = index > > _num ; if ( i >= wlen ) return - _num ; int subindex = index & _num ; long word = ~ bits . get ( i ) > > subindex ; if ( word != _num ) { return ( i << _num ) + subindex + long . numberoftrailingzeros ( word ) ; } while ( ++ i < wlen ) { word = ~ bits . get ( i ) ; if ( word != _num ) { return ( i << _num ) + long . numberoftrailingzeros ( word ) ; } } return - _num ; }	find the next clear bit in the bit set .
private static synchronized void appendmessage ( context c , final string msg ) { if ( msg . length ( ) == _num ) return ; string out = msg ; boolean timestamp = prefstore . istimestamp ( c ) ; int maxlines = prefstore . getmaxlines ( c ) ; int protocolsize = protocol . size ( ) ; if ( protocolsize > _num && lastchar != _str ) { protocol . remove ( protocolsize - _num ) ; out = lastline + out ; } lastchar = out . charat ( out . length ( ) - _num ) ; string [ ] lines = out . split ( _str ) ; for ( int i = _num , l = lines . length ; i < l ; i ++ ) { lastline = lines [ i ] ; if ( timestamp ) protocol . add ( gettimestamp ( ) + lastline ) ; else protocol . add ( lastline ) ; if ( protocolsize + i >= maxlines ) { protocol . remove ( _num ) ; } } show ( ) ; if ( prefstore . islogger ( c ) ) write ( c , msg ) ; }	append the message to protocol and show.
public object [ ] importcells ( object [ ] cells , double dx , double dy , object target , point location ) { if ( target == null && cells . length == _num && location != null ) { target = getcellat ( location . x , location . y ) ; if ( target instanceof mxicell && cells [ _num ] instanceof mxicell ) { mxicell targetcell = ( mxicell ) target ; mxicell dropcell = ( mxicell ) cells [ _num ] ; if ( targetcell . isvertex ( ) == dropcell . isvertex ( ) || targetcell . isedge ( ) == dropcell . isedge ( ) ) { mxigraphmodel model = graph . getmodel ( ) ; model . setstyle ( target , model . getstyle ( cells [ _num ] ) ) ; graph . setselectioncell ( target ) ; return null ; } } } return super . importcells ( cells , dx , dy , target , location ) ; }	overrides drop behaviour to set the cell style if the target is not a valid drop target and the cells are of the same type ( eg.
private void cancelsearch ( ) { entranttosearch = null ; }	don ' t continue the search if requested data is received.
public static resultset polar2cartesian ( double r , double alpha ) { simpleresultset rs = new simpleresultset ( ) ; rs . addcolumn ( _str , types . double , _num , _num ) ; rs . addcolumn ( _str , types . double , _num , _num ) ; if ( r != null && alpha != null ) { double x = r . doublevalue ( ) * math . cos ( alpha . doublevalue ( ) ) ; double y = r . doublevalue ( ) * math . sin ( alpha . doublevalue ( ) ) ; rs . addrow ( x , y ) ; } return rs ; }	convert polar coordinates to cartesian coordinates.
public void threadfail ( string reason ) { try { fail ( reason ) ; } catch ( assertionfailederror t ) { threadrecordfailure ( t ) ; throw t ; } }	just like fail ( reason ) , but additionally recording ( using threadrecordfailure ) any assertionfailederror thrown , so that the current testcase will fail .
@ override public void connectionlost ( throwable cause ) { ondisconnect ( _bool ) ; }	called when the connection to the server was lost.
private boolean istypedtimefullylegal ( ) { if ( mis24hourmode ) { int [ ] values = getenteredtime ( null ) ; return ( values [ _num ] >= _num && values [ _num ] >= _num && values [ _num ] < _num && values [ _num ] >= _num && values [ _num ] < _num ) ; } else { return ( mtypedtimes . contains ( getamorpmkeycode ( am ) ) || mtypedtimes . contains ( getamorpmkeycode ( pm ) ) ) ; } }	check if the time that has been typed so far is completely legal , as is .
public synchronized void clearannotations ( ) { mannotations . clear ( ) ; mstringxy . clear ( ) ; }	removes all the existing annotations from the series .
public table sample ( double proportion ) { int tablecount = ( int ) math . round ( rowcount ( ) * proportion ) ; selection table1selection = new bitmapbackedselection ( ) ; int [ ] selectedrecords = generateuniformbitmap ( tablecount , rowcount ( ) ) ; for ( int selectedrecord : selectedrecords ) { table1selection . add ( selectedrecord ) ; } return selectwhere ( table1selection ) ; }	returns a table consisting of randomly selected records from this table . the sample size is based on the given proportion.
public static messagedigest newdigest ( ) { try { return messagedigest . getinstance ( _str ) ; } catch ( nosuchalgorithmexception e ) { throw new runtimeexception ( e ) ; } }	returns a new sha - 256 messagedigest instance.
public container addchildat ( int location , @ nonnull displayobject displayobject ) { if ( mfps != default_fps ) { displayobject . setup ( mfps ) ; } mdisplaylist . add ( location , displayobject ) ; return this ; }	adds a child to the display list at the specified index , bumping children at equal or greater indexes up one , and setting its parent to this container.
private void add ( dimensionindex index ) { flatten . add ( index ) ; lookup . put ( index . getaxis ( ) , index ) ; }	populate the hierarchy with the indexes < li > this method is not thread - safe.
public static recipepetals registerpetalrecipe ( itemstack output , object ... inputs ) { preconditions . checkargument ( inputs . length <= _num ) ; recipepetals recipe = new recipepetals ( output , inputs ) ; petalrecipes . add ( recipe ) ; return recipe ; }	registers a petal recipe .
private void buildfirstline ( linepath path , rect r ) { int [ ] range = new int [ ] { - r . left , - r . top , r . right , r . bottom } ; int max = - _num ; int maxid = _num ; for ( int i = _num ; i < _num ; i ++ ) { if ( range [ i ] > max ) { max = range [ i ] ; maxid = i ; } } switch ( maxid ) { case _num : path . setendpoint ( r . left , utils . nextint ( r . height ( ) ) + r . top ) ; break ; case _num : path . setendpoint ( utils . nextint ( r . width ( ) ) + r . left , r . top ) ; break ; case _num : path . setendpoint ( r . right , utils . nextint ( r . height ( ) ) + r . top ) ; break ; case _num : path . setendpoint ( utils . nextint ( r . width ( ) ) + r . left , r . bottom ) ; break ; } path . linetoend ( ) ; }	line to the the farthest boundary , in case appear a super big piece .
public void testvalueofdoubleneg ( ) { double a = - _num ; bigdecimal result = bigdecimal . valueof ( a ) ; string res = _str ; int resscale = _num ; assertequals ( _str , res , result . tostring ( ) ) ; assertequals ( _str , resscale , result . scale ( ) ) ; }	create a bigdecimal from a negative double value.
public void testhugeterm ( ) throws ioexception { stringbuilder sb = new stringbuilder ( ) ; for ( int i = _num ; i < _num ; i ++ ) { sb . append ( _str ) ; } string input = sb . tostring ( ) ; char token [ ] = new char [ _num ] ; arrays . fill ( token , _str ) ; string expectedtoken = new string ( token ) ; string expected [ ] = { expectedtoken , expectedtoken , expectedtoken , expectedtoken , expectedtoken , expectedtoken , expectedtoken , expectedtoken , expectedtoken , expectedtoken } ; assertanalyzesto ( sentence , input , expected ) ; }	tests the handling of binary / malformed data.
public double calcdistance ( final double x , final double y ) { double distancex ; double distancey ; if ( this . minx <= x && x <= this . maxx ) { distancex = _num ; } else { distancex = math . min ( math . abs ( this . minx - x ) , math . abs ( this . maxx - x ) ) ; } if ( this . miny <= y && y <= this . maxy ) { distancey = _num ; } else { distancey = math . min ( math . abs ( this . miny - y ) , math . abs ( this . maxy - y ) ) ; } return math . sqrt ( distancex * distancex + distancey * distancey ) ; }	calculates the ( minimum ) distance of a given point to the border of the rectangle.
public synchronized void ensurecapacity ( int minimumcapacity ) { if ( elementdata . length < minimumcapacity ) { int next = ( capacityincrement <= _num ? elementdata . length : capacityincrement ) + elementdata . length ; grow ( minimumcapacity > next ? minimumcapacity : next ) ; } }	ensures that this vector can hold the specified number of elements without growing .
@ override public string tostring ( ) { return string . format ( _str , ledgerid , entryid ) ; }	string representation of virtual cursor - ledgerid : entryid.
public void trigger ( date time ) { tasklist . remove ( time ) ; }	implements the trigger function for triggerable interface .
cipher ( cipherspi cipherspi , string transformation ) { this . spi = cipherspi ; this . transformation = transformation ; this . cryptoperm = cryptoallpermission . instance ; this . lock = null ; }	creates a cipher object.
public void testflipbitpositiveoutside1 ( ) { byte abytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = _num ; int number = _num ; byte rbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . flipbit ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	flipbit ( int n ) outside a positive number.
private void writeobject ( objectoutputstream aoutputstream ) throws ioexception { aoutputstream . defaultwriteobject ( ) ; }	this is the default implementation of writeobject.
@ override public boolean ispanelenabled ( ) { return multioptiongroupenabled ; }	checks if is panel enabled .
public static string tounixnewline ( string input ) { return input . replace ( _str , _str ) ; }	enforces unix newlines on the given string .
private void outputindentation ( ) { for ( int i = _num ; i < m_indent ; i ++ ) { m_out . print ( m_basicindent ) ; } }	indent to the current level in multiples of basicindent.
protected bucket < t > createbucket ( long bucketkey ) { return new bucket < t > ( bucketkey ) ; }	create the bucket with the given key.
public abstractsitemap parsesitemap ( byte [ ] content , url url ) throws unknownformatexception , ioexception { if ( url == null ) { return null ; } string filename = filenameutils . getname ( url . getpath ( ) ) ; string contenttype = tika . detect ( content , filename ) ; return parsesitemap ( contenttype , content , url ) ; }	parse a sitemap , given the content bytes and the url .
public applicationmetadata ( final deserializer deserializer ) { this . appname = deserializer . readstring ( _str ) ; this . version = deserializer . readstring ( _str ) ; this . certificatesigner = deserializer . readoptionalstring ( _str ) ; this . starttime = timeinstant . readfrom ( deserializer , _str ) ; this . currenttime = timeinstant . readfrom ( deserializer , _str ) ; this . timeprovider = null ; }	deserializes an application meta data instance .
public static constraintsparameters loadpolicydata ( inputstream policydatastream ) { if ( policydatastream != null ) { return load ( policydatastream ) ; } if ( ( defaultpolicyconstraintslocation != null ) && ! defaultpolicyconstraintslocation . isempty ( ) ) { return load ( defaultpolicyconstraintslocation ) ; } return null ; }	this method loads the policy constraint file.
public static void close ( outputstream out ) { try { if ( out != null ) { out . close ( ) ; } } catch ( ioexception ioe ) { } }	closes an output stream .
@ override public boolean iscelleditable ( int row , int col ) { if ( isconnectedtodatasource ) { if ( col != field_column_id ) { return _bool ; } else { return _bool ; } } else { return _bool ; } }	checks if is cell editable .
private void savesortedpomfile ( final string sortedxml ) { fileutil . savepomfile ( sortedxml ) ; log . info ( _str + pomfile . getabsolutepath ( ) ) ; }	saves the sorted pom file .
private void appendstatements ( policytype policy , string prefix ) { list < statement > appendstatements = newstatements ( policy , prefix ) ; for ( statement statement : appendstatements ) { appendstatement ( statement ) ; } }	appends new statements for given policy type .
private void validatetotpparameters ( ) throws authloginexception { stringbuilder errormessages = new stringbuilder ( ) ; if ( stringutils . isempty ( logintimeattrname ) ) { errormessages . append ( _str ) ; } if ( clockdriftcheckenabled && stringutils . isempty ( observedclockdriftattrname ) ) { errormessages . append ( _str ) ; } if ( totptimestep <= _num ) { errormessages . append ( _str + totptimestep + _str ) ; } if ( totpstepsinwindow < _num ) { errormessages . append ( _str + totpstepsinwindow ) ; } if ( errormessages . length ( ) > _num ) { debug . error ( _str + errormessages . tostring ( ) ) ; throw new authloginexception ( amauthoath , _str , null ) ; } }	validate totp specific settings .
public static string removeurifragment ( string url ) { if ( url == null || url . length ( ) == _num ) { return null ; } string [ ] arr = url . split ( _str ) ; if ( arr . length == _num ) { return arr [ _num ] ; } else { return url ; } }	gets the uri without the fragment.
public static void writereceiptstofiles ( list < byte [ ] > printedreceipts , string prefix , file basedir ) { try { int index = _num ; for ( byte [ ] printedreceipt : printedreceipts ) { bytearrayinputstream bin = new bytearrayinputstream ( printedreceipt ) ; file receiptfile = new file ( basedir , prefix + _str + index + _str ) ; bufferedoutputstream bufferedoutputstream = new bufferedoutputstream ( new fileoutputstream ( receiptfile ) ) ; ioutils . copy ( bin , bufferedoutputstream ) ; bufferedoutputstream . close ( ) ; index ++ ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } }	helper method for storing printed pdf receipts to files.
public synchronized void renderdataforprojection ( projection proj , java . awt . graphics g ) { firestatusupdate ( layerstatusevent . finish_working ) ; if ( proj == null ) { logger . info ( _str ) ; return ; } else { settargetindex ( proj . getscale ( ) ) ; layer layer = getappropriatelayer ( ) ; layer . renderdataforprojection ( proj , g ) ; } }	implementing the projectionpainter interface .
private containerpanel createcontainerpanel ( ) { containerpanel containerpanel = new containerpanel ( ) ; containerpanel . setanimated ( _bool ) ; containerpanel . setminimumsize ( new dimension ( _num , _num ) ) ; character = new character ( ) ; containerpanel . addrepaintable ( character ) ; inventory = new slotwindow ( _str , _num , _num ) ; inventory . setacceptedtypes ( entitymap . getclass ( _str , null , null ) ) ; inventory . setcloseable ( _bool ) ; containerpanel . addrepaintable ( inventory ) ; keyring = new keyring ( ) ; keyring . setacceptedtypes ( entitymap . getclass ( _str , null , null ) ) ; containerpanel . addrepaintable ( keyring ) ; usercontext . addfeaturechangelistener ( keyring ) ; spells = new spells ( ) ; spells . setacceptedtypes ( entitymap . getclass ( _str , null , null ) ) ; containerpanel . addrepaintable ( spells ) ; usercontext . addfeaturechangelistener ( spells ) ; return containerpanel ; }	create the container panel ( right side panel ) , and its child components .
public void copyfromgeometry3d ( geometry3d geom ) { this . mnumindices = geom . getnumindices ( ) ; this . mnumvertices = geom . getnumvertices ( ) ; this . mvertexbufferinfo = geom . getvertexbufferinfo ( ) ; this . mindexbufferinfo = geom . getindexbufferinfo ( ) ; this . mtexcoordbufferinfo = geom . gettexcoordbufferinfo ( ) ; this . monlyshortbuffersupported = geom . areonlyshortbufferssupported ( ) ; if ( mcolors == null ) this . mcolorbufferinfo = geom . getcolorbufferinfo ( ) ; this . mnormalbufferinfo = geom . getnormalbufferinfo ( ) ; this . moriginalgeometry = geom ; this . mhasnormals = geom . hasnormals ( ) ; this . mhastexturecoordinates = geom . hastexturecoordinates ( ) ; }	copies another geometry3d ' s bufferinfo objects.
public static intent implicit2explicitintent ( context context , intent implicitintent ) { packagemanager pm = context . getpackagemanager ( ) ; list < resolveinfo > resolveinfo = pm . queryintentservices ( implicitintent , _num ) ; if ( resolveinfo == null || resolveinfo . size ( ) != _num ) { return null ; } resolveinfo serviceinfo = resolveinfo . get ( _num ) ; string packagename = serviceinfo . serviceinfo . packagename ; string classname = serviceinfo . serviceinfo . name ; componentname component = new componentname ( packagename , classname ) ; intent explicitintent = new intent ( implicitintent ) ; explicitintent . setcomponent ( component ) ; return explicitintent ; }	android l ( lollipop , api 21 ) introduced a new problem when trying to invoke implicit intent , " java.
private synchronized void garbagecollectpeer ( peer peer ) { log . debug ( _str + peer ) ; mcurrentpeers . remove ( peer ) ; }	invalidates a peer and removes it from the peermanager ' s list of current peers .
public void reset ( ) { synchronized ( this ) { queue . clear ( ) ; setbridgemode ( - _num ) ; } }	clears all messages and resets to the default bridge mode .
@ postconstruct public void initapplication ( ) throws ioexception { if ( env . getactiveprofiles ( ) . length == _num ) { log . warn ( _str ) ; } else { log . info ( _str , arrays . tostring ( env . getactiveprofiles ( ) ) ) ; } }	initializes csrs . < p / > spring profiles can be configured with a program arguments - - spring . profiles . active = your - active - profile < p / >.
private void indent ( ) { out . print ( currentindention ) ; }	indent the current line.
private void computeimplicitforwarddependencesuse ( register r , depgraphnode destnode ) { depgraphnode sourcenode = getdepgraphnode ( r ) ; if ( sourcenode != null ) { for ( enumeration < register > e = genericphysicaldefuse . enumerate ( genericphysicaldefuse . getmasktspdefs ( ) , ir ) ; e . hasmoreelements ( ) ; ) { register r2 = e . nextelement ( ) ; if ( r == r2 ) { sourcenode . insertoutedge ( destnode , reg_may_def ) ; return ; } } sourcenode . insertoutedge ( destnode , reg_true ) ; } }	compute implicit forward dependences from a given register use to a given node .
public string description ( ) { synchronized ( this ) { if ( messages == null ) { messages = resourcebundle . getbundle ( _str ) ; } } return messages . getstring ( _str ) ; }	return localized description of this transport service.
set findremovableacilist ( set acilist ) throws amexception , ssoexception { set resultset = new hashset ( ) ; if ( acilist == null ) { return resultset ; } iterator iter = acilist . iterator ( ) ; while ( iter . hasnext ( ) ) { string aci = ( string ) iter . next ( ) ; set objs = dsservices . search ( token , amstoreconnection . getamsdkbasedn ( ) , _str + amsearchfiltermanager . getglobalsearchfilter ( amobject . group ) + _str + aci + _str , amconstants . scope_sub ) ; if ( objs . size ( ) < _num ) { resultset . add ( aci ) ; } } return resultset ; }	gets the dn : aci that is not shared by more that 1 role .
protected final void unregisterdatasource ( datasource removed ) { unregisterdatasources ( collections . singleton ( removed ) ) ; }	unregisters removed datasource from this provider .
public string dump ( byte [ ] der ) throws asn1exception , ioexception { try { asn1primitive derobject = asn1primitive . frombytearray ( der ) ; if ( derobject . getencoded ( ) . length < der . length ) { throw new asn1exception ( res . getstring ( _str ) ) ; } return dump ( derobject ) ; } catch ( ioexception ex ) { throw new asn1exception ( res . getstring ( _str ) , ex ) ; } }	get dump of the supplied der encoded asn.
public static class needclass ( string property ) throws nosuchpropertyexception { string value = needproperty ( property ) ; class c = null ; try { c = class . forname ( value ) ; } catch ( classnotfoundexception e ) { throw new nosuchpropertyexception ( _str + value + _str + property + _str ) ; } return c ; }	get a class property from the underlying properties , throwing an exception if it is not defined .
dependencyspec createmoduledependency ( artifactresult i , boolean forceexport ) { if ( jdk_module_names . contains ( i . name ( ) ) ) return jdk_dependency ; final moduleidentifier mi = createmoduleidentifier ( i ) ; final boolean export = forceexport || ( i . importtype ( ) == importtype . export ) ; return dependencyspec . createmoduledependencyspec ( pathfilters . getmetainfsubdirectorieswithoutmetainffilter ( ) , ( export ? pathfilters . acceptall ( ) : pathfilters . rejectall ( ) ) , this , mi , i . importtype ( ) == importtype . optional ) ; }	create module dependency from import .
public void appendnodes ( nodeset nodes ) { int nnodes = nodes . size ( ) ; if ( null == m_map ) { m_mapsize = nnodes + m_blocksize ; m_map = new node [ m_mapsize ] ; } else if ( ( m_firstfree + nnodes ) >= m_mapsize ) { m_mapsize += ( nnodes + m_blocksize ) ; node newmap [ ] = new node [ m_mapsize ] ; system . arraycopy ( m_map , _num , newmap , _num , m_firstfree + nnodes ) ; m_map = newmap ; } system . arraycopy ( nodes . m_map , _num , m_map , m_firstfree , nnodes ) ; m_firstfree += nnodes ; }	append the nodes to the list .
private int readepoch ( file epochfile ) { int epoch = - _num ; if ( ! epochfile . exists ( ) ) { return epoch ; } try { scanner scanner = new scanner ( epochfile ) ; epoch = scanner . nextint ( ) ; log . debug ( _str , epoch , epochfile . getname ( ) ) ; } catch ( ioexception e ) { log . error ( _str , epochfile . getname ( ) , e ) ; } return epoch ; }	read epoch from epoch file.
private int fastmatch ( string sha1 ) { integer idx = _indexes . get ( sha1 ) ; if ( idx == null ) return - _num ; else return idx . intvalue ( ) ; }	fast match - - lookup in the table .
public static void format ( string format , object ... args ) { if ( ! isdisabled ( ) ) { print ( string . format ( format , args ) ) ; } }	prints a string formated as in string.
public void concatenate ( sipobjectlist otherlist ) { super . concatenate ( otherlist ) ; }	append a given list to the end of this list .
public builder withkeystorepassword ( string truststorepassword ) { properties . setproperty ( nettyoptions . ssl_key_store_password , assert . notnull ( truststorepassword , _str ) ) ; return this ; }	sets the ssl key store password .
public static string suffix ( string string , string suffix ) { if ( string . endswith ( suffix ) == _bool ) { string += suffix ; } return string ; }	appends suffix if doesn ' t exist .
public point2d ( double x , double y ) { if ( double . isinfinite ( x ) || double . isinfinite ( y ) ) throw new illegalargumentexception ( _str ) ; if ( double . isnan ( x ) || double . isnan ( y ) ) throw new illegalargumentexception ( _str ) ; if ( x == _num ) this . x = _num ; else this . x = x ; if ( y == _num ) this . y = _num ; else this . y = y ; }	initializes a new point ( x , y ) .
public static void serverfailed ( string servicename ) { if ( servicename . startswith ( validremoteurl ) ) { serverfailed = _bool ; } else { remotestubs . remove ( servicename ) ; } }	sets the service to be failed .
public requesthandler ( pokemongo api , okhttpclient client ) { this . api = api ; this . client = client ; apiendpoint = apisettings . api_endpoint ; asynchttpthread = new thread ( this , _str ) ; asynchttpthread . setdaemon ( _bool ) ; asynchttpthread . start ( ) ; }	instantiates a new request handler .
public string tostring ( ) { string s = _str ; enumeration names = getattributenames ( ) ; while ( names . hasmoreelements ( ) ) { object key = names . nextelement ( ) ; object value = getattribute ( key ) ; if ( value instanceof attributeset ) { s = s + key + _str ; } else { s = s + key + _str + value + _str ; } } return s ; }	converts the attribute set to a string .
public vnxecommandresult removelunsfromconsistencygroup ( string cgid , list < string > luns ) { lungroupmodifyparam param = new lungroupmodifyparam ( ) ; list < lunaddparam > lunremoves = new arraylist < lunaddparam > ( ) ; for ( string lunid : luns ) { vnxebase lun = new vnxebase ( lunid ) ; lunaddparam lunadd = new lunaddparam ( ) ; lunadd . setlun ( lun ) ; lunremoves . add ( lunadd ) ; } param . setlunremove ( lunremoves ) ; consistencygrouprequests req = new consistencygrouprequests ( _khclient ) ; return req . modifyconsistencygroupsync ( cgid , param ) ; }	remove luns from the consistency group.
public void readdata ( datainput din ) throws ioexception { status = din . readunsignedshort ( ) ; events = din . readunsignedshort ( ) ; }	readdata - - input the modbus message from din.
public void remove ( string identifier , activeconnectionrecord record ) { synchronized ( records ) { set < activeconnectionrecord > connections = records . get ( identifier ) ; assert ( connections != null ) ; connections . remove ( record ) ; if ( connections . isempty ( ) ) records . remove ( identifier ) ; } }	removes the given connection record from the list of active connections associated with the object having the given identifier .
private string buildmetroprointplacementstatusstring ( ) { stringbuffer placementstatusbuf = new stringbuffer ( ) ; if ( placementstatus != null ) { placementstatusbuf . append ( string . format ( _str ) ) ; placementstatusbuf . append ( placementstatus . tostring ( dbclient ) ) ; } if ( secondaryplacementstatus != null ) { placementstatusbuf . append ( string . format ( _str ) ) ; placementstatusbuf . append ( secondaryplacementstatus . tostring ( dbclient ) ) ; } return placementstatusbuf . tostring ( ) ; }	builds the placementstatus string for metropoint.
private boolean hassequence ( subgraph graph ) { int odddegreecount = _num ; for ( iterator i = graph . nodeiterator ( ) ; i . hasnext ( ) ; ) { node node = ( node ) i . next ( ) ; if ( node . getdegree ( ) % _num == _num ) odddegreecount ++ ; } return odddegreecount <= _num ; }	tests whether a complete unique path exists in a graph using euler ' s theorem .
public void ensureadditionalcapacity ( final int size ) { final int newcount = visible . position ( ) + size ; if ( newcount > visible . capacity ( ) ) { final bytebuffer newbytebuffer = bytebuffer . allocate ( math . max ( visible . capacity ( ) << _num , newcount ) ) ; visible . flip ( ) ; visible = newbytebuffer . put ( visible ) ; } }	ensures that the specified number of additional bytes will fit in the buffer and resizes it if necessary .
public void forcereload ( file file ) { ffilestoreoad . add ( file ) ; }	adds the given indicator file to the list of files need to be reloaded .
private static long longmultiplypowerten ( long val , int n ) { if ( val == _num || n <= _num ) return val ; long [ ] tab = long_ten_powers_table ; long [ ] bounds = thresholds_table ; if ( n < tab . length && n < bounds . length ) { long tenpower = tab [ n ] ; if ( val == _num ) return tenpower ; if ( math . abs ( val ) <= bounds [ n ] ) return val * tenpower ; } return inflated ; }	compute val * 10 ^ n ; return this product if it is representable as a long , inflated otherwise .
boolean comparemethods ( @ nullable method a , @ nullable method b ) { if ( ( a == null ) != ( b == null ) ) { return _bool ; } if ( a != null && b != null ) { if ( ! a . equals ( b ) ) { return _bool ; } } return _bool ; }	package private helper method for descriptor.
public object remove ( string markername ) { return prefixlibrarian . remove ( markername ) ; }	remove an object from the prefix librarian register , returning that object if it has been found .
string formatlastmodified ( string filename ) { synchronized ( dateformat ) { return dateformat . format ( new date ( fileutils . lastmodified ( filename ) ) ) ; } }	get the last modified date of a date and format it as required by the ftp protocol .
public truetypefont ( string platname , object nativenames , int findex , boolean javarasterizer , boolean usefilepool ) throws fontformatexception { super ( platname , nativenames ) ; usejavarasterizer = javarasterizer ; fontrank = font2d . ttf_rank ; try { verify ( usefilepool ) ; init ( findex ) ; if ( ! usefilepool ) { close ( ) ; } } catch ( throwable t ) { close ( ) ; if ( t instanceof fontformatexception ) { throw ( fontformatexception ) t ; } else { throw new fontformatexception ( _str ) ; } } disposer . addobjectrecord ( this , disposerrecord ) ; }	- does basic verification of the file - reads the header table for this font ( within a collection ) - reads the names ( full , family ).
public logarithmicaxis ( string label ) { super ( label ) ; setupnumberfmtobj ( ) ; }	creates a new axis .
protected final boolean has_cycle_recu ( set < brditem > p_visited_items , brditem p_search_item , brditem p_come_from_item , boolean p_ignore_areas ) { if ( p_ignore_areas && ( this instanceof brdareaconduction ) ) return _bool ; collection < brditem > contact_list = get_normal_contacts ( ) ; if ( contact_list == null ) return _bool ; for ( brditem curr_contact : contact_list ) { if ( curr_contact == p_come_from_item ) continue ; if ( curr_contact == p_search_item ) return _bool ; if ( ! p_visited_items . add ( curr_contact ) ) continue ; if ( curr_contact . has_cycle_recu ( p_visited_items , p_search_item , this , p_ignore_areas ) ) return _bool ; } return _bool ; }	recursive part of trace.
public static boolean iscallingclassreflectionavailable ( ) { return _bool ; }	determine whether or not the getcallingclass methods will return any sensible results.
private static string [ ] formgrams ( string text , int ng ) { int len = text . length ( ) ; string [ ] res = new string [ len - ng + _num ] ; for ( int i = _num ; i < len - ng + _num ; i ++ ) { res [ i ] = text . substring ( i , i + ng ) ; } return res ; }	form all ngrams for a given word .
public void loadsettingsfromjson ( ) { synchronized ( lock ) { loadsettingsfromjson ( defaultfile ) ; for ( string filename : files ) { loadsettingsfromjson ( filename ) ; } } }	loads the settings from a json file .
public void testflush ( ) throws exception { byte [ ] data = new byte [ ] { - _num , - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num } ; testoutputstream tos = new testoutputstream ( ) ; cipheroutputstream cos = new cipheroutputstream ( tos ) { } ; cos . write ( data ) ; cos . flush ( ) ; byte [ ] result = tos . tobytearray ( ) ; if ( ! arrays . equals ( result , data ) ) { fail ( _str ) ; } }	flush ( ) method testing.
public void loadtrainicons ( ) { for ( train train : gettrainsbyidlist ( ) ) { train . loadtrainicon ( ) ; } }	loads train icons if needed.
public final string translate ( final charsequence input ) { if ( input == null ) { return null ; } try { final stringwriter writer = new stringwriter ( input . length ( ) * _num ) ; translate ( input , writer ) ; return writer . tostring ( ) ; } catch ( final ioexception ioe ) { throw new runtimeexception ( ioe ) ; } }	helper for non - writer usage .
public void insertreversesorted ( final int idx , final double distance ) { int i = _num ; for ( listnode temp : m_list ) { if ( temp . distance < distance ) { break ; } i ++ ; } m_list . add ( i , new listnode ( idx , distance ) ) ; }	inserts an element in reverse sorted order in the list .
public double normaldistance ( final double x , final double y , final double z , final membership ... bounds ) { final double dist = evaluate ( x , y , z ) ; final double perpx = x - dist * this . x ; final double perpy = y - dist * this . y ; final double perpz = z - dist * this . z ; if ( ! meetsallbounds ( perpx , perpy , perpz , bounds ) ) { return double . positive_infinity ; } return math . abs ( dist ) ; }	compute normal distance from plane to a vector .
public void testbaandbcbrokernetworkwithselectorssendfirst ( ) throws exception { bridgebrokers ( _str , _str , _bool , _num , _bool ) ; bridgebrokers ( _str , _str , _bool , _num , _bool ) ; startallbrokers ( ) ; waitforbridgeformation ( ) ; destination dest = createdestination ( _str , _bool ) ; hashmap < string , object > props = new hashmap < > ( ) ; props . put ( _str , _str ) ; sendmessages ( _str , dest , message_count , props ) ; props . clear ( ) ; props . put ( _str , _str ) ; sendmessages ( _str , dest , message_count , props ) ; messageconsumer clienta = createconsumer ( _str , dest , _str ) ; messageconsumer clientc = createconsumer ( _str , dest , _str ) ; thread . sleep ( _num ) ; messageidlist msgsa = getconsumermessages ( _str , clienta ) ; messageidlist msgsc = getconsumermessages ( _str , clientc ) ; assertequals ( message_count , msgsa . getmessagecount ( ) ) ; assertequals ( message_count , msgsc . getmessagecount ( ) ) ; }	brokera < - brokerb - > brokerc.
public void access ( ) { lastaccessedtime = system . currenttimemillis ( ) ; }	updates this tunnel , marking it as recently accessed .
public void writetoobject ( object object ) { try { method method = beanutils . getwritemethod ( object . getclass ( ) , getname ( ) , gettype ( ) ) ; if ( method != null ) { method . invoke ( object , new object [ ] { getvalue ( ) } ) ; } } catch ( exception e ) { throw new runtimeexception ( e ) ; } }	writes the value of the property to the given object.
private httpurlconnection dohttppostrequest ( string location , string clientsessionid , map < string , string > metadata , string postbody ) throws communicationexception { outputstreamwriter writer = null ; try { url url = new url ( location ) ; httpurlconnection connection = ( httpurlconnection ) url . openconnection ( ) ; connection . setrequestmethod ( _str ) ; connection . addrequestproperty ( _str , _str ) ; if ( clientsessionid != null ) { connection . addrequestproperty ( http_header_session_id , _str + clientsessionid ) ; } if ( metadata != null ) { connection . addrequestproperty ( http_header_metadata , gcutil . getbase64encodedmetadata ( metadata ) ) ; } if ( constants . enable_request_logging ) { logrequest ( connection , postbody ) ; } connection . setdooutput ( _bool ) ; writer = new outputstreamwriter ( connection . getoutputstream ( ) , _str ) ; writer . write ( postbody ) ; writer . flush ( ) ; if ( connection . getresponsecode ( ) != _num ) { throw new communicationexception ( _str + connection . getresponsecode ( ) ) ; } return connection ; } catch ( malformedurlexception e ) { log . e ( tag , _str + location ) ; throw new communicationexception ( _str + location ) ; } catch ( ioexception e ) { log . e ( tag , _str + e . getmessage ( ) ) ; throw new communicationexception ( _str + e . getmessage ( ) , e ) ; } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( ioexception e ) { log . i ( tag , _str + e . getmessage ( ) ) ; } } } }	does a post request with httpclient.
void iomessage ( throwable ex ) { log . printlines ( prefixkind . javac , _str ) ; ex . printstacktrace ( log . getwriter ( writerkind . notice ) ) ; }	print a message reporting an input / output error .
public void runtest ( ) throws throwable { document doc ; nodelist elementlist ; node namenode ; characterdata child ; string substring ; doc = ( document ) load ( _str , _bool ) ; elementlist = doc . getelementsbytagname ( _str ) ; namenode = elementlist . item ( _num ) ; child = ( characterdata ) namenode . getfirstchild ( ) ; substring = child . substringdata ( _num , _num ) ; assertequals ( _str , _str , substring ) ; }	runs the test case .
public static collection < uuid > nodeids ( @ nullable collection < ? extends clusternode > nodes ) { if ( nodes == null || nodes . isempty ( ) ) return collections . emptylist ( ) ; return f . viewreadonly ( nodes , node2id ( ) ) ; }	convenient utility method that returns collection of node ids for a given collection of grid nodes.
public static inputstream toinputstream ( final charsequence input , final charset encoding ) { return ioutils . toinputstream ( input . tostring ( ) , encoding ) ; }	convert the specified charsequence to an input stream , encoded as bytes using the specified character encoding .
public static boolean matchesxmlstring ( char [ ] buf , int off , int end , string str ) { int len = str . length ( ) ; if ( len != end - off ) return _bool ; for ( int i = _num ; i < len ; off += _num , i ++ ) { if ( buf [ off ] != str . charat ( i ) ) return _bool ; } return _bool ; }	returns true if the specified char subarray is equal to the string.
public double r ( ) { return math . sqrt ( x * x + y * y ) ; }	returns the polar radius of this point .
public void sign ( keypair keypair ) throws ioexception { if ( namelist . isempty ( ) ) { throw new illegalstateexception ( _str ) ; } if ( keypair == null ) { throw new illegalargumentexception ( _str ) ; } try { generalname [ ] gns = new generalname [ namelist . size ( ) ] ; for ( int ix = _num ; ix < namelist . size ( ) ; ix ++ ) { gns [ ix ] = new generalname ( generalname . dnsname , namelist . get ( ix ) ) ; } generalnames subjectaltname = new generalnames ( gns ) ; pkcs10certificationrequestbuilder p10builder = new jcapkcs10certificationrequestbuilder ( namebuilder . build ( ) , keypair . getpublic ( ) ) ; extensionsgenerator extensionsgenerator = new extensionsgenerator ( ) ; extensionsgenerator . addextension ( extension . subjectalternativename , _bool , subjectaltname ) ; p10builder . addattribute ( pkcsobjectidentifiers . pkcs_9_at_extensionrequest , extensionsgenerator . generate ( ) ) ; privatekey pk = keypair . getprivate ( ) ; jcacontentsignerbuilder csbuilder = new jcacontentsignerbuilder ( pk instanceof eckey ? ec_signature_alg : signature_alg ) ; contentsigner signer = csbuilder . build ( pk ) ; csr = p10builder . build ( signer ) ; } catch ( operatorcreationexception ex ) { throw new ioexception ( _str , ex ) ; } }	signs the completed csr .
void removeemptyrows ( final list list ) { for ( final iterator < receiptdetailinfo > detail = list . iterator ( ) ; detail . hasnext ( ) ; ) if ( detail . next ( ) == null ) detail . remove ( ) ; }	removes the empty rows .
private void add ( string text , text textnode ) { int startindex = builder . length ( ) ; builder . append ( text ) ; int endindex = builder . length ( ) ; textruns . add ( new textrun ( textnode , startindex , endindex ) ) ; }	here we add a textnode and its postion to a list.
public dnetscapebaseurl ( jdialog parent ) { super ( parent ) ; settitle ( res . getstring ( _str ) ) ; initcomponents ( ) ; }	creates a new dnetscapebaseurl dialog .
private void readobject ( objectinputstream s ) throws ioexception , classnotfoundexception { s . defaultreadobject ( ) ; init ( getname ( ) ) ; }	readobject is called to restore the state of the basicpermission from a stream .
public void appendrow ( rowspec rowspec ) { checknotnull ( rowspec , _str ) ; rowspecs . add ( rowspec ) ; }	appends the given row specification to the bottom of all rows .
public static < t > reactiveseq < t > frompublisher ( final publisher < ? extends t > publisher ) { objects . requirenonnull ( publisher ) ; final seqsubscriber < t > sub = seqsubscriber . subscriber ( ) ; publisher . subscribe ( sub ) ; return sub . stream ( ) ; }	construct a reactiveseq from an publisher.
public void multiplyallvaluesby ( final double multiplyby , final int roundtype ) { for ( final t t : keyset ( ) ) { double val = m_values . get ( t ) ; switch ( roundtype ) { case _num : val = math . floor ( val * multiplyby ) ; break ; case _num : val = math . round ( val * multiplyby ) ; break ; case _num : val = math . ceil ( val * multiplyby ) ; break ; default : val = val * multiplyby ; break ; } put ( t , ( int ) val ) ; } }	will multiply all values by a given double.
public void ontabsallclosing ( long time , boolean incognito ) { }	called when all the tabs in the current stack need to be closed.
public final testsubscriber < t > await ( duration timeout ) { if ( cdl . getcount ( ) == _num ) { return this ; } try { if ( ! cdl . await ( timeout . tomillis ( ) , timeunit . milliseconds ) ) { throw new assertionerror ( _str ) ; } return this ; } catch ( interruptedexception ex ) { throw new assertionerror ( _str , ex ) ; } }	blocking method that waits until a complete successfully or error signal is received or until a timeout occurs .
protected void paintcontentborderbottomedge ( graphics g , int tabplacement , int selectedindex , int x , int y , int w , int h ) { boolean lefttoright = compiereutils . islefttoright ( tabpane ) ; int bottom = y + h - _num ; int right = x + w - _num ; rectangle selrect = selectedindex < _num ? null : gettabbounds ( selectedindex , calcrect ) ; g . setcolor ( shadow ) ; if ( tabplacement != bottom || selectedindex < _num || ( selrect . x < x || selrect . x > x + w ) ) { g . setcolor ( darkshadow ) ; g . drawline ( x , y + h - _num , x + w - _num , y + h - _num ) ; } else { boolean lastinrun = islastinrun ( selectedindex ) ; g . setcolor ( darkshadow ) ; if ( lefttoright || lastinrun ) g . drawline ( x , bottom , selrect . x , bottom ) ; else g . drawline ( x , bottom , selrect . x - _num , bottom ) ; if ( selrect . x + selrect . width < x + w - _num ) { if ( lefttoright && ! lastinrun ) g . drawline ( selrect . x + selrect . width , bottom , right , bottom ) ; else g . drawline ( selrect . x + selrect . width - _num , bottom , right , bottom ) ; } } }	paint bottom content area edge.
public static void upto ( double self , number to , @ closureparams ( firstparam . class ) closure closure ) { double to1 = to . doublevalue ( ) ; if ( self <= to1 ) { for ( double i = self ; i <= to1 ; i ++ ) { closure . call ( i ) ; } } else throw new groovyruntimeexception ( _str + to + _str + self + _str ) ; }	iterates from this number up to the given number , inclusive , incrementing by one each time .
public void save ( string type , list < elasticsearchdoc > docs ) { if ( docs != null && ! docs . isempty ( ) ) { list < list < elasticsearchdoc > > partitioneddocs = lists . partition ( docs , _num ) ; partitioneddocs . foreach ( null ) ; } }	bulk save of the entities.
public void error ( sourcelocator srclctr , string msg ) throws transformerexception { error ( srclctr , null , null , msg , null ) ; }	tell the user of an error , and probably throw an exception .
void removelistener ( string listenerid ) { if ( listenerobjects != null ) { synchronized ( listenerobjects ) { listenerobjects . remove ( listenerid ) ; if ( listenerobjects . isempty ( ) ) { deregisterlistener ( ) ; } } if ( debug . messageenabled ( ) ) { debug . message ( _str + servicename + _str + listenerid ) ; } } }	unregisters the listener from the service for the given listener id.
@ deprecated public void registercredentials ( usercredential authentication ) { wallet . put ( authentication . geturl ( ) , authentication ) ; }	adds the given credentials .
public void testdatabasedriverpropertiesuserandpasswordpropertyoverridedsuserandpassword ( ) { string driverpropertystring = _str ; properties props = new properties ( ) ; props . setproperty ( datasourcepropertyset . username , _str ) ; props . setproperty ( datasourcepropertyset . password , _str ) ; props . setproperty ( datasourcepropertyset . connection_properties , driverpropertystring ) ; datasource ds = datasourceconverter . fromproperties ( props ) ; assertequals ( _str , ds . getusername ( ) ) ; assertequals ( _str , ds . getpassword ( ) ) ; }	test the driver properties when the username and the password is set on datasource .
public boolean isagcenabled ( ) { return magcenabled . get ( ) ; }	indicates if agc is enabled.
protected linkedlist < string > splitintoallophones ( string phonestring ) { linkedlist < string > phonelist = new linkedlist < string > ( ) ; for ( int i = _num ; i < phonestring . length ( ) ; i ++ ) { string name = null ; for ( int j = _num ; j >= _num ; j -- ) { if ( i + j <= phonestring . length ( ) ) { string candidate = phonestring . substring ( i , i + j ) ; if ( getallophone ( candidate ) != null ) { name = candidate ; i += j - _num ; break ; } } } if ( name != null ) { phonelist . add ( name ) ; } } return phonelist ; }	convert a phone string into a list of string representations of individual phones.
private boolean execute ( boolean readresponse ) throws ioexception { try { httpengine . sendrequest ( ) ; if ( readresponse ) { httpengine . readresponse ( ) ; } return _bool ; } catch ( ioexception e ) { if ( handlefailure ( e ) ) { return _bool ; } else { throw e ; } } }	sends a request and optionally reads a response.
public bigdatasail ( final properties properties ) { this ( properties . getproperty ( options . namespace , options . default_namespace ) , new journal ( properties ) ) ; closeonshutdown = _bool ; if ( ! exists ( ) ) { try { create ( properties ) ; } catch ( interruptedexception | executionexception e ) { throw new runtimeexception ( e ) ; } } }	create or open a database instance configured using the specified properties .
public float convert ( ) { return float . intbitstofloat ( ( int ) bytes ) ; }	converts the internal representation to an actual float .
public fileprocesscontroller ( final filecontrollerparameters arguments , final int pid ) { this ( arguments , pid , long . getlong ( status_timeout_property , _num * _num ) , timeunit . milliseconds ) ; }	constructs an instance for controlling a local process .
public void testaddcertificate2 ( ) throws exception { identity i = new identitystub ( _str ) ; publickeystub pk1 = new publickeystub ( _str , _str , null ) ; certificatestub c1 = new certificatestub ( _str , null , null , pk1 ) ; i . addcertificate ( c1 ) ; assertsame ( c1 , i . certificates ( ) [ _num ] ) ; assertsame ( pk1 , i . getpublickey ( ) ) ; }	verify addcertificate ( certificate certificate ) adds a certificate for this identity.
protected set < future < void > > send ( string channelid , object message ) { collection < session > sessions = ( channelid != null ) ? socketsessions . get ( channelid ) : null ; if ( sessions != null && ! sessions . isempty ( ) ) { set < future < void > > results = new hashset < > ( sessions . size ( ) ) ; string json = json . encode ( message ) ; for ( session session : sessions ) { if ( session . isopen ( ) ) { send ( session , json , results ) ; } } return results ; } return emptyset ( ) ; }	encode the given message object as json and send it to all open web socket sessions associated with given web socket channel identifier .
public object attribute ( object key ) { return ( attributes != null ) ? attributes . get ( key ) : null ; }	provides lookup of attributes by key .
public response doput ( string url ) { return doput ( url , null ) ; }	does a http put with an empty body.
private static pair < string , string > offsetrrx ( final long offset , final itranslationenvironment environment , final list < reilinstruction > instructions , final string registernodevalue1 , final string registernodevalue2 ) { final string address = environment . getnextvariablestring ( ) ; final string index = environment . getnextvariablestring ( ) ; final string tmpvar = environment . getnextvariablestring ( ) ; final string tmpvar1 = environment . getnextvariablestring ( ) ; final string tmpvar2 = environment . getnextvariablestring ( ) ; final string tmpvar3 = environment . getnextvariablestring ( ) ; long baseoffset = offset ; instructions . add ( reilhelpers . createbsh ( baseoffset ++ , bt , _str , wd , string . valueof ( _num ) , dw , tmpvar1 ) ) ; instructions . add ( reilhelpers . createbsh ( baseoffset ++ , dw , registernodevalue2 , bt , string . valueof ( - _num ) , dw , tmpvar2 ) ) ; instructions . add ( reilhelpers . createor ( baseoffset ++ , dw , tmpvar1 , dw , tmpvar2 , dw , tmpvar3 ) ) ; instructions . add ( reilhelpers . createand ( baseoffset ++ , dw , tmpvar3 , dw , dwordbitmask , dw , index ) ) ; instructions . add ( reilhelpers . createadd ( baseoffset ++ , dw , registernodevalue1 , dw , index , dw , tmpvar ) ) ; instructions . add ( reilhelpers . createand ( baseoffset ++ , dw , tmpvar , dw , dwordbitmask , dw , address ) ) ; return new pair < string , string > ( address , registernodevalue1 ) ; }	operation : [ < rn > , + / - < rm > , rrx ] 0b11 / ror or rrx / if shift_imm = = 0 then / rrx / index = ( c flag logical_shift_left 31 ) or ( rm logical_shift_right 1 ) else / ror / index = rm rotate_right shift_imm endcase if u = = 1 then address = rn + index else / u = = 0 / address = rn - index.
public void unregisterdropcontrollers ( ) { dropcontrollerlist . clear ( ) ; }	unregister all dropcontrollers from this drag controller .
private static long callstaticlongmethodv ( jnienvironment env , int classjref , int methodid , address argaddress ) throws exception { if ( tracejni ) vm . syswrite ( _str ) ; runtimeentrypoints . checkjnicountdowntogc ( ) ; try { object returnobj = jnihelpers . invokewithvararg ( methodid , argaddress , typereference . long ) ; return reflection . unwraplong ( returnobj ) ; } catch ( throwable unexpected ) { if ( tracejni ) unexpected . printstacktrace ( system . err ) ; env . recordexception ( unexpected ) ; return _num ; } }	callstaticlongmethodv : invoke a static method that returns a long value.
public int size ( ) { return segments . size ( ) ; }	number of segments in the corpus .
public void addoperand ( int starttick , int endtick , string text , lifeline constraintlifeline ) throws sequencediagramcheckedexception { if ( operands . size ( ) == _num && this . starttick != starttick ) { throw new illegalargumentexception ( _str ) ; } operands . add ( new operand ( starttick , endtick , text , constraintlifeline ) ) ; }	adds an operand with an interaction constraint to the combined fragment .
public static number asin ( number a ) { return math . asin ( a . doublevalue ( ) ) ; }	returns the arc sine of the number .
private void createandattachevent ( long ov ) throws windowsexception { long hevent = createevent ( _bool , _bool ) ; unsafe . putaddress ( ov + offsetof_hevent , hevent ) ; }	creates an unnamed event and set it as the hevent field in the given overlapped structure.
public string tostring ( ) { stringbuffer result = new stringbuffer ( ) ; result . append ( _str ) ; int s1 = sizes . size ( ) ; for ( int i = _num ; i < s1 ; ++ i ) { int s2 = sizes . get ( i ) ; result . append ( _str ) ; for ( int j = _num ; j < s2 ; ++ j ) { result . append ( vector [ i ] [ j ] ) ; if ( j + _num < s2 ) result . append ( _str ) ; } result . append ( _str ) ; if ( i + _num < s1 ) result . append ( _str ) ; } result . append ( _str ) ; return result . tostring ( ) ; }	returns a text representation of this vector .
@ override public int compareto ( string o ) { int result ; int major ; int minor ; int revision ; int pnt ; int [ ] maj = new int [ _num ] ; int [ ] min = new int [ _num ] ; int [ ] rev = new int [ _num ] ; int [ ] point = new int [ _num ] ; parseversion ( o , maj , min , rev , point ) ; major = maj [ _num ] ; minor = min [ _num ] ; revision = rev [ _num ] ; pnt = point [ _num ] ; if ( major < major ) { result = - _num ; } else if ( major == major ) { if ( minor < minor ) { result = - _num ; } else if ( minor == minor ) { if ( revision < revision ) { result = - _num ; } else if ( revision == revision ) { if ( point < pnt ) { result = - _num ; } else if ( point == pnt ) { result = _num ; } else { result = _num ; } } else { result = _num ; } } else { result = _num ; } } else { result = _num ; } return result ; }	checks the version of this class against the given version - string.
private void generateintegritykeypair ( boolean clientmode ) throws unsupportedencodingexception , ioexception , nosuchalgorithmexception { byte [ ] cimagic = client_int_magic . getbytes ( encoding ) ; byte [ ] simagic = svr_int_magic . getbytes ( encoding ) ; messagedigest md5 = messagedigest . getinstance ( _str ) ; byte [ ] keybuffer = new byte [ h_a1 . length + cimagic . length ] ; system . arraycopy ( h_a1 , _num , keybuffer , _num , h_a1 . length ) ; system . arraycopy ( cimagic , _num , keybuffer , h_a1 . length , cimagic . length ) ; md5 . update ( keybuffer ) ; byte [ ] kic = md5 . digest ( ) ; system . arraycopy ( simagic , _num , keybuffer , h_a1 . length , simagic . length ) ; md5 . update ( keybuffer ) ; byte [ ] kis = md5 . digest ( ) ; if ( logger . isloggable ( level . finer ) ) { traceoutput ( di_class_name , _str , _str , kic ) ; traceoutput ( di_class_name , _str , _str , kis ) ; } if ( clientmode ) { myki = kic ; peerki = kis ; } else { myki = kis ; peerki = kic ; } }	generate client - server , server - client key pairs for digest - md5 integrity checking .
public static boolean islocalfileuri ( uri uri ) { final string scheme = getschemeornull ( uri ) ; return local_file_scheme . equals ( scheme ) ; }	check if uri represents local file.
completablefuture < writeresponse > write ( list < writevalue > writevalues ) ;	this service is used to write values to one or more attributes of one or more nodes .
public static boolean validsystemnameconfig ( string systemname , char type ) { if ( ! validsystemnameformat ( systemname , type ) ) { return _bool ; } int bit = getbitfromsystemname ( systemname ) ; if ( ( type == _str ) || ( type == _str ) ) { if ( ( bit <= _num ) || ( bit > outputbits . getnumoutputbits ( ) ) ) { return _bool ; } } else if ( type == _str ) { if ( ( bit <= _num ) || ( bit > inputbits . getnuminputbits ( ) ) ) { return _bool ; } } else { log . error ( _str ) ; return _bool ; } return _bool ; }	public static method to validate system name for configuration returns ' true ' if system name has a valid meaning in current configuration , else returns ' false '.
public boolean mousemoved ( mouseevent e ) { esrigraphiclist list = getesrigraphiclist ( ) ; boolean ret = _bool ; if ( list != null ) { omgraphic omg = list . findclosest ( e . getx ( ) , e . gety ( ) , _num ) ; if ( omg != null ) { int index ; integer i = ( ( integer ) omg . getattribute ( shape_index_attribute ) ) ; if ( i != null ) { index = i . intvalue ( ) ; } else { index = list . indexof ( omg ) ; } if ( parentlayer == null ) { component comp = getcomponent ( ) ; if ( comp instanceof layer ) { parentlayer = ( layer ) comp ; } } if ( parentlayer != null ) { parentlayer . firerequesttooltip ( getdescription ( index ) ) ; } ret = _bool ; } else if ( parentlayer != null ) { parentlayer . firehidetooltip ( ) ; } } return ret ; }	handle mouse moved events ( used for firing tool tip descriptions over graphics ).
public formatexception ( string s , throwable rootcause ) { super ( s + _str + rootcause . getlocalizedmessage ( ) ) ; this . rootcause = rootcause ; }	construct a formatexception with a detail message and root cause .
private pair < bigdecimal , bigdecimal > fillpayment ( final customerorder order , final customerorderdelivery delivery , final payment payment , final boolean singlepay , final bigdecimal runningtotal , final bigdecimal runningtotaltax , final boolean lastdelivery ) { if ( payment . gettransactionreferenceid ( ) == null ) { payment . settransactionreferenceid ( delivery . getdeliverynum ( ) ) ; } payment . setordershipment ( singlepay ? order . getordernum ( ) : delivery . getdeliverynum ( ) ) ; fillpaymentitems ( delivery , payment ) ; fillpaymentshipment ( order , delivery , payment ) ; return fillpaymentamount ( order , delivery , payment , singlepay , runningtotal , runningtotaltax , lastdelivery ) ; }	fill single payment with data.
void materialize ( ) { if ( cachefill < _num ) { return ; } double min = double . max_value , max = double . min_value ; for ( int i = _num ; i < cachefill ; i ++ ) { min = math . min ( min , cachec [ i ] ) ; max = math . max ( max , cachec [ i ] ) ; } linearscale scale = new linearscale ( min , max ) ; min = scale . getmin ( ) ; max = scale . getmax ( ) ; this . base = min ; this . max = max ; this . binsize = ( max - min ) / this . destsize ; this . data = new float [ this . destsize << _num ] ; size = destsize ; final int end = cachefill ; cachefill = - _num ; for ( int i = _num ; i < end ; i ++ ) { increment ( cachec [ i ] , cachev [ i ] ) ; } cachec = null ; cachev = null ; }	materialize the histogram from the cache .
public boolean buildhostpart ( appendable buffer , string url , boolean usessl ) throws webappconfigurationexception , ioexception { return buildhostpart ( buffer , url , usessl , _bool ) ; }	builds a partial url - including the scheme and host , but not the servlet path or resource.
public static < t > list < t > shiftelementstoend ( final list < t > source , final int count ) { final arraylist < t > rval = new arraylist < > ( source . size ( ) ) ; for ( int i = count ; i < source . size ( ) ; i ++ ) { rval . add ( source . get ( i ) ) ; } for ( int i = _num ; i < count ; i ++ ) { rval . add ( source . get ( i ) ) ; } if ( source . size ( ) != rval . size ( ) ) { throw new illegalstateexception ( _str + count + _str + source + _str + rval ) ; } return rval ; }	returns a list of everything in source , with the first count units moved to the end.
private boolean isleafpage ( bytebuffer buffer ) throws ioexception { byte pagetype = buffer . get ( _num ) ; if ( pagetype == pagetypes . index_leaf ) { return _bool ; } else if ( pagetype == pagetypes . index_node ) { return _bool ; } throw new ioexception ( witherrorcontext ( _str + pagetype ) ) ; }	determines if the given index page is a leaf or node page .
public void addjslibfiles ( file ... files ) { jslibfiles . addall ( arrays . aslist ( files ) ) ; }	add javascript libraries that are used for the javascript evaluation .
public void testwriteoffset ( ) { int len = _num ; int datalen = _num ; byte [ ] srcdata = getwdata ( datalen ) ; byte [ ] data = new byte [ datalen ] ; int noffset = _num ; bytefifobuffer instance = new bytefifobuffer ( len ) ; int result = instance . writeoffset ( srcdata , datalen , noffset ) ; int readcount = instance . readoffset ( data , _num , datalen , noffset ) ; assertequals ( result , readcount ) ; assertarrayequals ( srcdata , data ) ; byte [ ] halffilled = new byte [ datalen * _num ] ; system . arraycopy ( srcdata , _num , halffilled , datalen , datalen ) ; byte [ ] halffilledread = new byte [ datalen * _num ] ; instance . readoffset ( halffilledread , datalen , datalen , noffset ) ; assertarrayequals ( halffilled , halffilledread ) ; instance = new bytefifobuffer ( len ) ; instance . write ( srcdata , datalen ) ; instance . write ( srcdata , datalen / _num ) ; instance . read ( data , datalen ) ; instance . writeoffset ( srcdata , datalen , _num ) ; instance = new bytefifobuffer ( _num ) ; instance . writeoffset ( getwdata ( _num ) , _num , _num ) ; }	test of writeoffset method , of class bytefifobuffer .
private void initpropertiesifnecessary ( ) { if ( timer == null ) { toolkit t = toolkit . getdefaulttoolkit ( ) ; integer prop ; prop = ( integer ) t . getdesktopproperty ( _str ) ; timer = new timer ( prop == null ? _num : prop . intvalue ( ) , this ) ; prop = ( integer ) t . getdesktopproperty ( _str ) ; timer . setinitialdelay ( prop == null ? _num : prop . intvalue ( ) ) ; prop = ( integer ) t . getdesktopproperty ( _str ) ; if ( prop != null ) { hysteresis = prop . intvalue ( ) ; } } }	initializes the internal properties if they haven ' t been already inited.
public eobject loadmodel ( string filename , string cwd ) { uri fileuri = normalizeuri ( uri . createuri ( filename ) ) ; uri cwduri = normalizeuri ( uri . createuri ( cwd ) ) ; return loadmodel ( fileuri , cwduri ) ; }	load the model found in the filename.
static boolean pathiswindows ( string path ) { if ( path != null && path . length ( ) > _num ) { return ( character . isletter ( path . charat ( _num ) ) && path . charat ( _num ) == _str ) || ( path . startswith ( _str ) || path . startswith ( _str ) ) ; } return _bool ; }	returns true if the path is on windows .
public static boolean istestserver ( ) { return system . getproperty ( testserveronly . test_server_property ) != null ; }	determines if the current running server is a testserver.
@ suppresswarnings ( _str ) private < t > string generatetestfile ( string filename , list < t > elems , avrocoder < t > coder , string codec ) throws ioexception { file tmpfile = tmpfolder . newfile ( filename ) ; string path = tmpfile . tostring ( ) ; fileoutputstream os = new fileoutputstream ( tmpfile ) ; datumwriter < t > datumwriter = coder . createdatumwriter ( ) ; try ( datafilewriter < t > writer = new datafilewriter < > ( datumwriter ) ) { writer . setcodec ( codecfactory . fromstring ( codec ) ) ; writer . create ( coder . getschema ( ) , os ) ; for ( t elem : elems ) { writer . append ( elem ) ; } } return path ; }	generates an input avro file containing the given records in the temporary directory and returns the full path of the file .
public void notifyreturned ( notifycontext notifycontext , itemplateholder template ) { if ( notifycontext == null ) return ; if ( _filtermanager . _isfilter [ filteroperationcodes . after_notify_trigger ] ) { object [ ] entries = new object [ _num ] ; entries [ _num ] = notifycontext . getentry ( ) ; entries [ _num ] = template ; try { _filtermanager . invokefilters ( filteroperationcodes . after_notify_trigger , null , entries ) ; } catch ( exception e ) { if ( _logger . isloggable ( level . fine ) ) _logger . log ( level . fine , _str , e ) ; } } decreasecounter ( notifycontext ) ; }	called when a notification returned.
public static string normalizeslashes ( string path ) { return path . replaceall ( _str , _str ) ; }	replace ' \ ' with ' / ' from the given path because tsserver normalize it like this .
protected point2d correct ( point2d anchor , rectangle2d bounds ) { if ( anchor == null ) return anchor ; double x = anchor . getx ( ) , y = anchor . gety ( ) ; double x1 = bounds . getminx ( ) , y1 = bounds . getminy ( ) ; double x2 = bounds . getmaxx ( ) , y2 = bounds . getmaxy ( ) ; x = ( x < x1 ? x1 : ( x > x2 ? x2 : x ) ) ; y = ( y < y1 ? y1 : ( y > y2 ? y2 : y ) ) ; m_tmp . setlocation ( x , y ) ; return m_tmp ; }	corrects the anchor position , such that if the anchor is outside the layout bounds , the anchor is adjusted to be the nearest point on the edge of the bounds .
protected boolean loadfield ( ddfrecord record , string tagname , int fieldindex ) { if ( fields . get ( tagname ) == null ) { ddffield ddf = record . findfield ( tagname , fieldindex ) ; if ( ddf != null ) { fields . put ( tagname , ddf ) ; ddf . tostring ( ) ; return _bool ; } } return _bool ; }	if a field has not been loaded , load it from the ddfrecord if it exists and add it to the master field hashtable .
public httprequest ( final charsequence url , final string method ) throws httprequestexception { try { this . url = new url ( url . tostring ( ) ) ; } catch ( malformedurlexception e ) { throw new httprequestexception ( e ) ; } this . requestmethod = method ; }	create http connection wrapper.
private boolean iserror ( iproblem problem , type type ) { return _bool ; }	decides if a problem matters .
@ suppresswarnings ( { _str , _str } ) public recordsetpage ( input input ) { deserializer deserizalizer = new deserializer ( ) ; map mapresult = deserizalizer . deserialize ( input , map . class ) ; cursor = ( integer ) mapresult . get ( _str ) ; data = ( list < list < object > > ) mapresult . get ( _str ) ; }	creates recordset page from input object.
public optional < string > endpoint ( ) { return optional . ofnullable ( endpointarg ) ; }	returns the endpoint string.
public void testcollisions ( ) throws exception { map < integer , set < uuid > > map = new hashmap < > ( ) ; collection < uuid > nodes = new linkedhashset < > ( ) ; while ( nodes . size ( ) < _num ) { uuid uuid = uuid . randomuuid ( ) ; int hashcode = uuid . hashcode ( ) ; set < uuid > set = map . get ( hashcode ) ; if ( set == null ) map . put ( hashcode , set = new linkedhashset < > ( ) ) ; set . add ( uuid ) ; if ( set . size ( ) > _num ) nodes . addall ( set ) ; } map . clear ( ) ; gridclientconsistenthash < uuid > hash = new gridclientconsistenthash < > ( ) ; hash . addnodes ( nodes , replicas ) ; boolean fail = _bool ; for ( uuid exp : nodes ) { uuid act = hash . node ( _num , arrays . aslist ( exp ) ) ; if ( exp . equals ( act ) ) info ( _str + exp + _str + act + _str ) ; else { info ( _str + exp + _str + act + _str ) ; fail = _bool ; } } if ( fail ) fail ( _str + nodes ) ; }	test hash codes collisions .
void sendmessagetohandlerwithcontrollerreset ( list < ofmessage > messages ) throws exception { sendmessagetohandlernocontrollerreset ( messages ) ; }	reset , setup , and replay the messageevent mock for the given messages , mock controller send message to channel handler this method will reset , start replay on controller , and then verify.
public boolean isredeploymode ( ) { return scenario . equals ( propertyconstants . redeploy_mode ) ? _bool : _bool ; }	check if installer is running at redeploy mode .
public static rsaprivatekey loadfromkeystore ( url keystoreurl , string password ) throws ioexception , nosuchalgorithmexception , certificateexception , keystoreexception , unrecoverablekeyexception { logger . debug ( _str , keystoreurl ) ; urlconnection connection = keystoreurl . openconnection ( ) ; inputstream is = connection . getinputstream ( ) ; try { if ( logger . isdebugenabled ( ) ) logger . debug ( _str , arrays . tostring ( security . getproviders ( ) ) ) ; keystore keystore ; try { try { keystore = keystore . getinstance ( _str , _str ) ; } catch ( nosuchproviderexception e ) { keystore = keystore . getinstance ( _str , cryptoutil . getsecurityprovidername ( keystore . class ) ) ; } } catch ( nosuchproviderexception e ) { keystore = keystore . getinstance ( _str ) ; } logger . debug ( _str , keystore . getprovider ( ) ) ; keystore . load ( is , password == null ? null : password . tochararray ( ) ) ; enumeration < string > aliases = keystore . aliases ( ) ; key key = null ; while ( aliases . hasmoreelements ( ) ) { string a = ( string ) aliases . nextelement ( ) ; key = keystore . getkey ( a , password == null ? null : password . tochararray ( ) ) ; } return ( rsaprivatekey ) key ; } finally { is . close ( ) ; } }	load private key from a key store.
@ override public double confsmallm ( double totalexampleweight , double delta ) { double term = math . log ( _num / delta ) / ( _num * totalexampleweight ) ; return math . sqrt ( term ) + math . pow ( term , _num ) + math . pow ( term , _num ) ; }	calculate confidence intervall without a specific rule for small m .
public static < t > boolean contains ( iterator < t > iterator , t element ) { if ( iterator != null ) { while ( iterator . hasnext ( ) ) { t candidate = iterator . next ( ) ; if ( objectutils . nullsafeequals ( candidate , element ) ) return _bool ; } } return _bool ; }	check whether the given iterator contains the given element .
public void testconstructor6 ( ) { integer [ ] ints = new integer [ size ] ; for ( int i = _num ; i < size ; ++ i ) ints [ i ] = new integer ( i ) ; linkedblockingqueue q = new linkedblockingqueue ( arrays . aslist ( ints ) ) ; for ( int i = _num ; i < size ; ++ i ) assertequals ( ints [ i ] , q . poll ( ) ) ; }	queue contains all elements of collection used to initialize.
@ override public void drawdomaingridline ( graphics2d g2 , categoryplot plot , rectangle2d dataarea , double value ) { line2d line = null ; plotorientation orientation = plot . getorientation ( ) ; if ( orientation == plotorientation . horizontal ) { line = new line2d . double ( dataarea . getminx ( ) , value , dataarea . getmaxx ( ) , value ) ; } else if ( orientation == plotorientation . vertical ) { line = new line2d . double ( value , dataarea . getminy ( ) , value , dataarea . getmaxy ( ) ) ; } paint paint = plot . getdomaingridlinepaint ( ) ; if ( paint == null ) { paint = categoryplot . default_gridline_paint ; } g2 . setpaint ( paint ) ; stroke stroke = plot . getdomaingridlinestroke ( ) ; if ( stroke == null ) { stroke = categoryplot . default_gridline_stroke ; } g2 . setstroke ( stroke ) ; g2 . draw ( line ) ; }	draws a grid line against the domain axis.
public void addprebuiltclassifier ( classifier c ) { m_prebuiltclassifiers . add ( c ) ; }	add a prebuilt classifier to the list for use in the ensemble.
@ override public insnlist generate ( ) { return merge ( generatedinstructions . toarray ( ) ) ; }	generate final instruction list .
public static void putjavavariablesintoengine ( final scriptengine engine , final map < string , object > variables ) { final bindings bindings = new simplebindings ( ) ; for ( string key : variables . keyset ( ) ) { bindings . put ( key , variables . get ( key ) ) ; } engine . setbindings ( bindings , scriptcontext . engine_scope ) ; }	puts a the given map of variables into the engine .
public void deletewithmissing ( attribute att ) { deletewithmissing ( att . index ( ) ) ; }	removes all instances with missing values for a particular attribute from the dataset .
protected void sprint ( string a ) { if ( a == null ) { stringrepresentation += getindentation ( ) ; stringrepresentation += _str ; return ; } if ( a . compareto ( _str ) == _num || a . compareto ( _str ) == _num ) { indentation -- ; } stringrepresentation += getindentation ( ) ; stringrepresentation += a ; stringrepresentation += _str ; if ( a . compareto ( _str ) == _num || a . compareto ( _str ) == _num ) { indentation ++ ; } }	add a new string to the accumulated string representation .
public static java . sql . date tosqldate ( string monthstr , string daystr , string yearstr ) { java . util . date newdate = todate ( monthstr , daystr , yearstr , _str , _str , _str ) ; if ( newdate != null ) { return new java . sql . date ( newdate . gettime ( ) ) ; } else { return null ; } }	makes a java . sql . date from separate strings for month , day , year.
protected void savepngimage ( string filename , bufferedimage image ) throws ioexception { file file = new file ( filename ) ; imageio . write ( image , _str , file ) ; }	saves an image as png .
public void unsetpermission ( string name ) { permissions . remove ( name . tolowercase ( java . util . locale . english ) ) ; permissible . recalculatepermissions ( ) ; }	removes the specified permission from this attachment.
public void beforeinsert ( int index , byte element ) { if ( index > size || index < _num ) throw new indexoutofboundsexception ( _str + index + _str + size ) ; ensurecapacity ( size + _num ) ; system . arraycopy ( elements , index , elements , index + _num , size - index ) ; elements [ index ] = element ; size ++ ; }	inserts the specified element before the specified position into the receiver.
public omgraphiclist readcachedgraphics ( url url ) throws java . io . ioexception { if ( debug . debugging ( _str ) ) { debug . output ( _str ) ; } omgraphiclist omgraphics = new omgraphiclist ( ) ; if ( url != null ) { omgraphics . readgraphics ( url ) ; } return omgraphics ; }	read a cache of omgraphics.
int size ( ) { return noxitems . size ( ) ; }	returns the number of nox items to be loaded .
public < v > future < v > invoke ( string method , string path , map < string , ? > arguments , resulthandler < v > resulthandler ) { if ( method == null ) { throw new illegalargumentexception ( ) ; } if ( path == null ) { throw new illegalargumentexception ( ) ; } if ( arguments == null ) { throw new illegalargumentexception ( ) ; } return executorservice . submit ( new invocationcallback < > ( method , path , arguments , resulthandler ) ) ; }	executes a service operation .
@ override public string replacepath ( string inputuri ) { if ( inputuri . contains ( temporarydirectorymanager . directory_template ) ) { return inputuri . replace ( temporarydirectorymanager . directory_template , template_directory_name ) ; } return inputuri ; }	this method replaces ( if found ) the sub - string [ unique ] in any input string with the value template .
@ override public void create ( ) { assertwritable ( ) ; final string name = getnamespace ( ) + _str + name_search ; final iindexmanager indexmanager = getindexmanager ( ) ; final properties p = getproperties ( ) ; final indexmetadata indexmetadata = new indexmetadata ( indexmanager , p , name , uuid . randomuuid ( ) , indextypeenum . btree ) ; final ikeybuilderfactory keybuilderfactory ; { final properties tmp = new properties ( p ) ; tmp . setproperty ( keybuilder . options . strength , p . getproperty ( options . indexer_collator_strength , options . default_indexer_collator_strength ) ) ; keybuilderfactory = new defaultkeybuilderfactory ( tmp ) ; } final boolean fieldsenabled = boolean . parseboolean ( p . getproperty ( options . fields_enabled , options . default_fields_enabled ) ) ; if ( log . isinfoenabled ( ) ) log . info ( options . fields_enabled + _str + fieldsenabled ) ; indexmetadata . settupleserializer ( new fulltextindextupleserializer < v > ( keybuilderfactory , defaulttupleserializer . getdefaultleafkeyscoder ( ) , emptyrabavaluecoder . instance , fieldsenabled ) ) ; indexmanager . registerindex ( indexmetadata ) ; if ( log . isinfoenabled ( ) ) log . info ( _str + name ) ; }	conditionally registers the necessary index ( s ) .
public static pgppublickey mergesignatures ( pgppublickey targetkey , pgppublickey sourcekey ) throws pgpexception { if ( ! objects . deepequals ( targetkey . getfingerprint ( ) , sourcekey . getfingerprint ( ) ) ) { throw new illegalargumentexception ( _str ) ; } return copysignatures ( targetkey , sourcekey ) ; }	returns a public key containing signatures of two keys .
public static double info ( int counts [ ] ) { int total = _num ; double x = _num ; for ( int j = _num ; j < counts . length ; j ++ ) { x -= xlogx ( counts [ j ] ) ; total += counts [ j ] ; } return x + xlogx ( total ) ; }	computes entropy for an array of integers .
public computejobfailoverexception ( throwable cause ) { this ( cause . getmessage ( ) , cause ) ; }	creates new given throwable as a cause and source of error message .
public boolean hasnewerversion ( ) { return lateststable . compareto ( currentversion ) > _num ; }	compares if there is a newer version available .
@ override public void readnbt ( nbttagcompound compound ) { super . readnbt ( compound ) ; if ( compound . haskey ( _str ) ) { this . exhaustiontimer = compound . getinteger ( _str ) ; } if ( ! compound . haskey ( _str ) ) { setfoodlevel ( getfoodlevel ( ) * _num ) ; setsaturation ( _num ) ; } if ( getfoodlevel ( ) > _num ) setfoodlevel ( _num ) ; if ( getsaturationlevel ( ) > _num ) setsaturation ( _num ) ; }	reads the food data for the player .
private static boolean verifyxml ( string filename ) { schemafactory sf = schemafactory . newinstance ( w3c_xml_schema ) ; source xsdfile = new streamsource ( new file ( xsd_file_path ) ) ; source xmlfile = new streamsource ( new file ( filename ) ) ; boolean validxml = _bool ; try { schema schema = sf . newschema ( xsdfile ) ; validator validator = schema . newvalidator ( ) ; try { validator . validate ( xmlfile ) ; validxml = _bool ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } if ( ! validxml ) { new ioexception ( _str ) ; } } catch ( saxexception e ) { e . printstacktrace ( ) ; } return validxml ; }	checks whether the given xml is valid against the xsd for the new data format .
@ nullable public n node ( @ nullable object key , @ nullable collection < n > inc ) { return node ( key , inc , null ) ; }	gets node for a given key .
public void increment ( ) { counter . getandincrement ( ) ; }	increments the count of in - flight transactions to the resource being monitored .
public defaultdeploymentcache ( ) { this . cache = collections . synchronizedmap ( new hashmap < string , t > ( ) ) ; }	cache with no limit.
private int findinsertionpoint ( sortedlistentry entry ) { int insertionpoint = sortedmodel . size ( ) ; if ( sortorder != sortorder . unordered ) { insertionpoint = collections . binarysearch ( ( list ) sortedmodel , entry ) ; if ( insertionpoint < _num ) { insertionpoint = - ( insertionpoint + _num ) ; } } return insertionpoint ; }	internal helper method to find the insertion point for a new entry in the sorted model .
private boolean haveshownmessagebefore ( updatemessage msg ) { if ( ! msg . isshownonce ( ) ) return _bool ; loadseenmessages ( ) ; if ( _seenmessages == null || _seenmessages . size ( ) == _num || ! _seenmessages . contains ( msg ) ) { if ( _seenmessages == null ) _seenmessages = new hashset < > ( ) ; _seenmessages . add ( msg ) ; saveseenmessages ( ) ; return _bool ; } return _bool ; }	checks on a message map , if we ' ve seen this message before.
public void datasourceadded ( int index ) { update ( ) ; updatecoordinateprojectioncomboboxes ( ) ; }	update bottom stats when a data source is added .
public boolean fieldisstatic ( ) { return modifier . isstatic ( field . getmodifiers ( ) ) ; }	returns whether the field is marked with the static modifier .
void newequation ( df_latticecell lhs , df_operator operator , df_latticecell op1 , df_latticecell op2 , df_latticecell op3 ) { df_equation eq = new df_equation ( lhs , operator , op1 , op2 , op3 ) ; equations . addgraphnode ( eq ) ; equations . addgraphnode ( lhs ) ; equations . addgraphnode ( op1 ) ; equations . addgraphnode ( op2 ) ; equations . addgraphnode ( op3 ) ; newequations . add ( eq ) ; op1 . adduse ( eq ) ; op2 . adduse ( eq ) ; op3 . adduse ( eq ) ; lhs . adddef ( eq ) ; if ( eager && eq . evaluate ( ) ) changedcell ( lhs ) ; }	add an equation with three operands on the right - hand side .
@ override public void stop ( ) { if ( stopping . compareandset ( _bool , _bool ) ) { if ( log . isdebugenabled ( ) ) log . debug ( _str + cachename + _str ) ; wakeup ( ) ; boolean graceful = _bool ; for ( gridworker worker : flushthreads ) graceful &= u . join ( worker , log ) ; if ( ! graceful ) log . warning ( _str ) ; } }	performs shutdown logic for store.
private set < storageport > andstorageportsets ( set < storageport > a , set < storageport > b ) { set < storageport > result = new hashset < storageport > ( ) ; for ( storageport port : a ) { if ( b . contains ( port ) ) { result . add ( port ) ; } } return result ; }	logical and of a and b.
public static void addattributetoschema ( string servicename , string subschemaname , string schematype , node attributeschemanode , ssotoken admintoken ) throws upgradeexception { serviceschema ss = getserviceschema ( servicename , subschemaname , schematype , admintoken ) ; addattributetoschema ( ss , attributeschemanode ) ; }	adds new attribute schema to an existing service .
public int next ( int current ) { for ( int i = current + _num ; i < ( arguments != null ? arguments . size ( ) : _num ) ; i ++ ) { if ( getargument ( i ) instanceof mathcontainer ) { return i ; } } throw new arrayindexoutofboundsexception ( _str ) ; }	get index of next argument .
@ override public boolean supportsauthentication ( ) { if ( debug . messageenabled ( ) ) { debug . message ( _str ) ; } return _bool ; }	tells whether this identity repository supports authentication .
protected void reorderappdeploymentsafterconfigurationversion ( element domain ) { list < element > appdeployments = xmltool . selectelementsmatchingxpath ( _str , domain ) ; for ( element appdeployment : appdeployments ) { domain . removechild ( appdeployment ) ; } element configurationversion = xmltool . selectelementmatchingxpath ( _str , domain ) ; node before = null ; nodelist children = domain . getchildnodes ( ) ; for ( int i = _num ; i < children . getlength ( ) ; i ++ ) { if ( configurationversion . equals ( children . item ( i ) ) && i < children . getlength ( ) - _num ) { before = children . item ( i + _num ) ; } } if ( before != null ) { for ( element appdeployment : appdeployments ) { domain . insertbefore ( appdeployment , before ) ; } } else { for ( element appdeployment : appdeployments ) { domain . appendchild ( appdeployment ) ; } } }	per current schema of the weblogic domain , app - deployment elements need to come directly after the configuration - version element .
static facetmethod selectfacetmethod ( schemafield field , facetmethod method , integer mincount ) { fieldtype type = field . gettype ( ) ; if ( method == null ) { if ( type instanceof boolfield && ( field . indexed ( ) == _bool || field . hasdocvalues ( ) == _bool ) ) { method = facetmethod . enum ; } else if ( type . getnumerictype ( ) != null && ! field . multivalued ( ) ) { method = facetmethod . fcs ; } else { method = facetmethod . fc ; } } if ( method == facetmethod . fc && type . getnumerictype ( ) != null && ! field . multivalued ( ) ) { method = facetmethod . fcs ; } if ( method == facetmethod . uif && ! field . hasdocvalues ( ) && mincount == _num ) { method = field . multivalued ( ) ? facetmethod . fc : facetmethod . fcs ; } if ( method == facetmethod . enum && triefield . getmainvalueprefix ( type ) != null ) { method = field . multivalued ( ) ? facetmethod . fc : facetmethod . fcs ; } final boolean multitoken = field . multivalued ( ) || type . multivaluedfieldcache ( ) ; if ( method == facetmethod . fcs && multitoken ) { method = facetmethod . fc ; } return method ; }	this method will force the appropriate facet method even if the user provided a different one as a request parameter n.
public list < hashmap < string , object > > clearoverallchat ( ) { try { list < hashmap < string , object > > mychatlist = mychats . get ( overallchatroomname ) ; mychatlist = new linkedlist < hashmap < string , object > > ( ) ; mychats . put ( overallchatroomname , mychatlist ) ; map < integer , string > newmessage = new hashmap < integer , string > ( ) ; newmessage . put ( _num , _str ) ; scopeapplicationadapter . sendmessagetomembers ( newmessage ) ; return mychatlist ; } catch ( exception err ) { log . error ( _str , err ) ; return null ; } }	clear the overallchat history.
public dbschemachanger beginchange ( ) throws exception { backupfile = file . createtempfile ( _str , _str ) ; log . info ( _str , classfile . getabsolutepath ( ) , backupfile . getabsolutepath ( ) ) ; copyfile ( classfile , backupfile ) ; cc . defrost ( ) ; return this ; }	begin change the schema this method should be called before making any changes to the class.
void animatechallengeto ( int y , int velocity ) { if ( mchallengeview == null ) { return ; } canceltransitionsinprogress ( ) ; mchallengeinteractiveinternal = _bool ; mchallengeview . setlayertype ( layer_type_hardware , null ) ; final int sy = mchallengeview . getbottom ( ) ; final int dy = y - sy ; if ( dy == _num ) { completechallengescroll ( ) ; return ; } setscrollstate ( scroll_state_settling ) ; final int childheight = mchallengeview . getheight ( ) ; final int halfheight = childheight / _num ; final float distanceratio = math . min ( _num , _num * math . abs ( dy ) / childheight ) ; final float distance = halfheight + halfheight * distanceinfluenceforsnapduration ( distanceratio ) ; int duration = _num ; velocity = math . abs ( velocity ) ; if ( velocity > _num ) { duration = _num * math . round ( _num * math . abs ( distance / velocity ) ) ; } else { final float childdelta = ( float ) math . abs ( dy ) / childheight ; duration = ( int ) ( ( childdelta + _num ) * _num ) ; } duration = math . min ( duration , max_settle_duration ) ; mscroller . startscroll ( _num , sy , _num , dy , duration ) ; postinvalidateonanimation ( ) ; }	animate the bottom edge of the challenge view to the given position .
public jcax509v3certificatebuilder ( x500principal issuer , biginteger serial , date notbefore , date notafter , x500principal subject , publickey publickey ) { super ( x500name . getinstance ( issuer . getencoded ( ) ) , serial , notbefore , notafter , x500name . getinstance ( subject . getencoded ( ) ) , subjectpublickeyinfo . getinstance ( publickey . getencoded ( ) ) ) ; }	initialise the builder using x500principal objects and a publickey .
private void writeguidvalue ( bytebuffer buffer , object value ) throws ioexception { matcher m = guid_pattern . matcher ( tocharsequence ( value ) ) ; if ( ! m . matches ( ) ) { throw new ioexception ( witherrorcontext ( _str + value ) ) ; } bytebuffer origbuffer = null ; byte [ ] tmpbuf = null ; if ( buffer . order ( ) != byteorder . big_endian ) { origbuffer = buffer ; tmpbuf = new byte [ _num ] ; buffer = bytebuffer . wrap ( tmpbuf ) ; } byteutil . writehexstring ( buffer , m . group ( _num ) ) ; byteutil . writehexstring ( buffer , m . group ( _num ) ) ; byteutil . writehexstring ( buffer , m . group ( _num ) ) ; byteutil . writehexstring ( buffer , m . group ( _num ) ) ; byteutil . writehexstring ( buffer , m . group ( _num ) ) ; if ( tmpbuf != null ) { byteutil . swap4bytes ( tmpbuf , _num ) ; byteutil . swap2bytes ( tmpbuf , _num ) ; byteutil . swap2bytes ( tmpbuf , _num ) ; origbuffer . put ( tmpbuf ) ; } }	writes a guid value .
public neurongroup ( final network net , final list < neuron > neurons ) { super ( net ) ; neuronlist = new arraylist < neuron > ( neurons . size ( ) ) ; for ( neuron neuron : neurons ) { addneuron ( neuron ) ; } neuronlist = new copyonwritearraylist < neuron > ( neuronlist ) ; updaterule = getneurontype ( ) ; resetsubsamplingindices ( ) ; }	construct a new neuron group from a list of neurons .
@ logmessagedoc ( level = _str , message = _str , explanation = _str , recommendation = logmessagedoc . report_controller_bug ) public list < ldupdate > applyupdates ( ) { list < ldupdate > appliedupdates = new arraylist < ldupdate > ( ) ; ldupdate update = null ; while ( ldupdates . peek ( ) != null ) { try { update = ldupdates . take ( ) ; } catch ( exception e ) { log . error ( _str , e ) ; } if ( log . istraceenabled ( ) ) { log . trace ( _str , update ) ; } switch ( update . getoperation ( ) ) { case link_updated : addorupdatelink ( update . getsrc ( ) , update . getsrcport ( ) , update . getdst ( ) , update . getdstport ( ) , update . gettype ( ) ) ; break ; case link_removed : removelink ( update . getsrc ( ) , update . getsrcport ( ) , update . getdst ( ) , update . getdstport ( ) ) ; break ; case switch_updated : addorupdateswitch ( update . getsrc ( ) ) ; break ; case switch_removed : removeswitch ( update . getsrc ( ) ) ; break ; case tunnel_port_added : addtunnelport ( update . getsrc ( ) , update . getsrcport ( ) ) ; break ; case tunnel_port_removed : removetunnelport ( update . getsrc ( ) , update . getsrcport ( ) ) ; break ; case port_up : case port_down : break ; } appliedupdates . add ( update ) ; } return ( collections . unmodifiablelist ( appliedupdates ) ) ; }	updates concerning switch disconnect and port down are not processed.
boolean isempty ( ) { return mdescription . isempty ( ) && mtypes . isempty ( ) ; }	checks whether the information about the oma content is empty .
public star ( int points , float rotation , float insideness ) { float x = _num ; float y = _num ; float radius = _num ; points = points < _num ? _num : points ; rotation = rotation + ( float ) ( math . pi / _num ) ; boolean flat = insideness >= _num ; setcontrolpointsize ( flat ? points : _num * points ) ; final float pi2 = _num * ( float ) math . pi ; float insideradius = radius * insideness ; point2d . float pt ; for ( int p = _num ; p < points ; ++ p ) { double vertex = p ; double angle = vertex * pi2 / points + rotation ; pt = new point2d . float ( ( float ) ( x + math . cos ( angle ) * radius ) , ( float ) ( y + math . sin ( angle ) * radius ) ) ; pushpoint ( pt ) ; if ( ! flat ) { double angle2 = ( vertex + _num ) * pi2 / points + rotation ; pt = new point2d . float ( ( float ) ( x + math . cos ( angle2 ) * insideradius ) , ( float ) ( y + math . sin ( angle2 ) * insideradius ) ) ; pushpoint ( pt ) ; } } }	create a star , or a regular polygon if insideness is 1.
private static boolean isstatic ( method m ) { int mods = m . getmodifiers ( ) ; return ( mods & modifier . static ) != _num ; }	returns if a method is static.
public synchronized boolean trylock ( ) { try { lock = file . trylock ( ) ; return lock != null ; } catch ( exception e ) { return _bool ; } }	try to lock the file .
@ override public void nodedown ( topology topology , long eventuid , string nodeid ) { if ( targetserverid . equals ( nodeid ) ) { decideonaction ( topology ) ; } }	if the node going down is the node we are replicating from then decide on an action .
public boolean isvalid ( ) { return _bool ; }	returns true if all of the fields have legal values given their names.
private void rolloverlogtask ( ) { try { if ( _isinit ) { flush ( ) ; } } catch ( exception e ) { log . log ( level . warning , e . tostring ( ) , e ) ; } _isrollingover = _bool ; try { if ( ! _isinit ) return ; path savedpath = null ; long now = currenttime . currenttime ( ) ; long lastperiodend = _nextperiodend ; _nextperiodend = nextrollovertime ( now ) ; path path = getpath ( ) ; synchronized ( _loglock ) { flushtempstream ( ) ; long length = files . size ( path ) ; if ( lastperiodend <= now && lastperiodend > _num ) { closelogstream ( ) ; savedpath = getsavedpath ( lastperiodend - _num ) ; } else if ( path != null && getrolloversize ( ) <= length ) { closelogstream ( ) ; savedpath = getsavedpath ( now ) ; } } if ( savedpath != null ) { movepathtoarchive ( savedpath ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } finally { synchronized ( _loglock ) { _isrollingover = _bool ; flushtempstream ( ) ; } _rolloverlistener . requeue ( _rolloveralarm ) ; } }	called from rollover worker.
public boolean onscrollchanged ( int scrolly ) { boolean ispullingdownnow = scrolly < lastscrolly ; latestpullingdown . offer ( ispullingdownnow ) ; if ( latestpullingdown . size ( ) > pulling_down_time_max ) { latestpullingdown . poll ( ) ; } lastscrolly = scrolly ; return getpullingdowntime ( ) >= pulling_down_time_threshold ; }	call this when scroll changed.
@ exceptionhandler ( constraintviolationexception . class ) @ responsestatus ( value = httpstatus . bad_request ) public map < string , object > handleconstraintviolationexception ( constraintviolationexception ex ) { collection < fielderror > errors = fielderror . geterrors ( ex . getconstraintviolations ( ) ) ; log . warn ( _str + errors . tostring ( ) ) ; return lemonutil . mapof ( _str , _str , _str , errors ) ; }	handles constraint violation exceptions.
@ override public void readexternal ( objectinput in ) throws ioexception { b = new double [ in . readint ( ) ] ; for ( int p = _num ; p < b . length ; p ++ ) { b [ p ] = in . readdouble ( ) ; } }	the object implements the readexternal method to restore its contents by calling the methods of datainput for primitive types and readobject for objects , strings and arrays.
private synchronized void addtracker ( string path , object marker , filedeletestrategy deletestrategy ) { if ( exitwhenfinished ) { throw new illegalstateexception ( _str ) ; } if ( reaper == null ) { reaper = new reaper ( ) ; reaper . start ( ) ; } trackers . add ( new tracker ( path , deletestrategy , marker , q ) ) ; }	adds a tracker to the list of trackers .
list < issue > errors ( ) { return errors ; }	returns accumulated parsing errors .
public audiowife addoncompletionlistener ( oncompletionlistener listener ) { mcompletionlisteners . add ( _num , listener ) ; return this ; }	* add custom playback completion listener.
public void addvolumetoconsistencygroup ( string instanceid , string cgid ) throws storagecenterapiexception { restresult rr = restclient . get ( string . format ( _str , instanceid ) ) ; if ( ! checkresults ( rr ) ) { throw new storagecenterapiexception ( string . format ( _str , rr . geterrormsg ( ) ) ) ; } scvolumeconfiguration volconfig = gson . fromjson ( rr . getresult ( ) , scvolumeconfiguration . class ) ; list < string > profiles = new arraylist < > ( ) ; for ( scobject profile : volconfig . replayprofilelist ) { if ( ! cgid . equals ( profile . instanceid ) ) { profiles . add ( profile . instanceid ) ; } } profiles . add ( cgid ) ; parameters params = new parameters ( ) ; params . add ( _str , profiles . toarray ( new string [ _num ] ) ) ; rr = restclient . put ( string . format ( _str , instanceid ) , params . tojson ( ) ) ; if ( ! checkresults ( rr ) ) { throw new storagecenterapiexception ( string . format ( _str , rr . geterrormsg ( ) ) ) ; } }	adds a volume to a consistency group .
public static boolean isimplementsinterface ( class clazz , class interfaceclass ) { if ( ! ( interfaceclass . isinterface ( ) ) ) { throw new illegalargumentexception ( _str ) ; } boolean resultthisclass = recursiveisimplementsinterface ( clazz , interfaceclass ) ; if ( resultthisclass ) { return _bool ; } return recursivesuperclassimplementsinterface ( clazz , interfaceclass ) ; }	method to check if a given class , and its superclasses and interfaces ( deep ) , implement a given interface .
private static string replacechars ( string str ) { stringbuffer buf = new stringbuffer ( str ) ; int length = buf . length ( ) ; for ( int i = _num ; i < length ; i ++ ) { char currentchar = buf . charat ( i ) ; if ( currentchar == _str ) { buf . setcharat ( i , _str ) ; buf . insert ( i + _num , _str ) ; length = length + _num ; i = i + _num ; } else if ( currentchar == _str ) { buf . setcharat ( i , _str ) ; } } return buf . tostring ( ) ; }	replace spaces with " % 20 " and backslashes with forward slashes in the input string to generate a well - formed uri string .
private void addbinding ( final string key , final object value ) { m_bindings . put ( key , value ) ; }	adds an additional object binding .
public static < t extends enum < t > > t forkey ( string key , map < string , t > mapping , class < t > enumeration ) { t t = mapping . get ( key ) ; if ( t != null ) { return t ; } throw new illegalargumentexception ( _str + enumeration . tostring ( ) + _str + key ) ; }	boilerplate method to retrieve an enum method via an arbitrary key , rather than just the enum value .
private exchangerate directlookup ( final currency source , final currency target , final date date ) { if ( system . getproperty ( _str ) == null ) throw new unsupportedoperationexception ( _str ) ; exchangerate rate = null ; ql . require ( ( ( rate = fetch ( source , target , date ) ) != null ) , _str ) ; return rate ; }	fetches a exchange rate from the repository .
protected static int findnextnewlinechar ( charsequence s , int start ) { for ( int i = start ; i < s . length ( ) ; i ++ ) { if ( s . charat ( i ) == _str ) { return i ; } } return - _num ; }	find ' \ n ' from " start " position if not find , return - 1.
public skypebuilder withchat ( string id ) { if ( ! id . startswith ( _str ) ) throw new illegalargumentexception ( _str ) ; if ( password != null ) throw new illegalargumentexception ( _str ) ; this . chatid = id ; return this ; }	join a particular chat as a guest . will have no effect if a password is specified.
public static int compareto ( object left , object right ) { return comparetowithequalitycheck ( left , right , _bool ) ; }	compares the two objects handling nulls gracefully and performing numeric type coercion if required.
public static x509crlimpl toimpl ( x509crl crl ) throws crlexception { if ( crl instanceof x509crlimpl ) { return ( x509crlimpl ) crl ; } else { return x509factory . intern ( crl ) ; } }	utility method to convert an arbitrary instance of x509crl to a x509crlimpl.
public final void test_roundtrip_getkeyspeckeyprovider02 ( ) { boolean performed = _bool ; for ( int i = _num ; i < algname . length ; i ++ ) { for ( int l = _num ; l < provider . length ; l ++ ) { if ( provider [ l ] == null ) { continue ; } testdatagenerator g ; try { g = new testdatagenerator ( algname [ i ] [ _num ] , algname [ i ] [ _num ] , privatekeyinfodamaged , provider [ l ] ) ; } catch ( testdatagenerator . allowedfailure allowedfailure ) { continue ; } try { encryptedprivatekeyinfo epki ; if ( g . ap ( ) == null ) { epki = new encryptedprivatekeyinfo ( algname [ i ] [ _num ] , g . ct ( ) ) ; } else { epki = new encryptedprivatekeyinfo ( g . ap ( ) , g . ct ( ) ) ; } try { epki . getkeyspec ( g . pubk ( ) == null ? g . k ( ) : g . pubk ( ) , provider [ l ] ) ; fail ( algname [ i ] [ _num ] + _str + algname [ i ] [ _num ] ) ; } catch ( invalidkeyexception e ) { } performed = _bool ; } catch ( nosuchalgorithmexception allowedfailure ) { } } } asserttrue ( _str , performed ) ; }	encrypted data contains invalid pkcs8 key info encoding.
public final synchronized void closeall ( ) { if ( oncloseall ( ) ) { log . w ( tag , _str ) ; return ; } linkedlist < integer > ids = new linkedlist < integer > ( ) ; for ( int id : getexistingids ( ) ) { ids . add ( id ) ; } for ( int id : ids ) { close ( id ) ; } }	close all existing windows .
public void testposnegfirstshorter ( ) { byte abytes [ ] = { - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { - _num , _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , - _num , _num , _num , - _num , - _num } ; int asign = _num ; int bsign = - _num ; byte rbytes [ ] = { - _num , _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , _num , - _num , - _num , _num , - _num , - _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . or ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , result . signum ( ) ) ; }	or for a positive and a negative number ; the first is shorter.
private boolean startrandomgame ( ) { abstractlaunch [ ] pins = mcardadapter . getlaunchers ( ) ; list < abstractlaunch > games = new arraylist < abstractlaunch > ( pins . length ) ; for ( abstractlaunch pin : pins ) { if ( pin . isgame ( ) ) { if ( pin . mstate == abstractlaunch . state_ready ) { games . add ( pin ) ; } } } if ( games . size ( ) > _num ) { random r = new random ( ) ; int index = r . nextint ( games . size ( ) ) ; abstractlaunch game = games . get ( index ) ; log . d ( tag , string . format ( _str , game . mcontentdescription ) ) ; game . onclick ( game . getclicktarget ( ) ) ; measurementmanager . recordcustomevent ( mmeasurement , getstring ( r . string . analytics_event_category_launch ) , getstring ( r . string . analytics_launch_action_voice ) , game . mcontentdescription ) ; analyticsmanager . sendevent ( r . string . analytics_event_category_launch , r . string . analytics_launch_action_voice , game . mcontentdescription ) ; return _bool ; } else { return _bool ; } }	pick a game at random from the available games in state_ready state.
public void initdiskcache ( ) { synchronized ( mdiskcachelock ) { if ( mdisklrucache == null || mdisklrucache . isclosed ( ) ) { file diskcachedir = mcacheparams . diskcachedir ; if ( mcacheparams . diskcacheenabled && diskcachedir != null ) { if ( ! diskcachedir . exists ( ) ) { diskcachedir . mkdirs ( ) ; } if ( getusablespace ( diskcachedir ) > mcacheparams . diskcachesize ) { try { mdisklrucache = disklrucache . open ( diskcachedir , _num , _num , mcacheparams . diskcachesize ) ; if ( buildconfig . debug ) { log . d ( tag , _str ) ; } } catch ( final ioexception e ) { mcacheparams . diskcachedir = null ; log . e ( tag , _str + e ) ; } } } } mdiskcachestarting = _bool ; mdiskcachelock . notifyall ( ) ; } }	initializes the disk cache.
boolean isregisteredpermission ( permission permission ) ;	returns true if given permissions is registered in this manager .
public static int compare ( string id1 , string id2 ) { int result = - _num ; string seed1 = idgenerator . getseedfromid ( id1 ) ; string seed2 = idgenerator . getseedfromid ( id2 ) ; if ( seed1 != null && seed2 != null ) { result = seed1 . compareto ( seed2 ) ; if ( result == _num ) { long count1 = idgenerator . getsequencefromid ( id1 ) ; long count2 = idgenerator . getsequencefromid ( id2 ) ; result = ( int ) ( count1 - count2 ) ; } } return result ; }	does a proper compare on the id ' s.
public static element addchildelementnselement ( element element , string childelementname , document document , string namespaceurl ) { element newelement = document . createelementns ( namespaceurl , childelementname ) ; element . appendchild ( newelement ) ; return element ; }	creates a child element with the given namespace supportive name and appends it to the element child node list .
public vnxecommandresult modifyconsistencygroupsync ( string id , lungroupmodifyparam param ) { stringbuilder urlbld = new stringbuilder ( url_modify1 ) ; urlbld . append ( id ) ; urlbld . append ( url_modify2 ) ; _url = urlbld . tostring ( ) ; return postrequestsync ( param ) ; }	modify consistency group in sync mode.
protected query finishquery ( booleanquery . builder in , boolean alltermsrequired ) { return in . build ( ) ; }	subclass can override this to tweak the query before searching .
public long sum ( ) { long sum = _num ; for ( atomiclong value : map . values ( ) ) { sum = sum + value . get ( ) ; } return sum ; }	returns the sum of all values in this map.
public static string extractfullstacktrace ( throwable e ) { stringwriter stringwriter = new stringwriter ( ) ; printwriter printwriter = new printwriter ( stringwriter ) ; e . printstacktrace ( printwriter ) ; return stringwriter . tostring ( ) ; }	extract the full stack trace :.
public emptytilefactory ( tilefactoryinfo info ) { super ( info ) ; int tilesize = info . gettilesize ( info . getminimumzoomlevel ( ) ) ; emptytile = new bufferedimage ( tilesize , tilesize , bufferedimage . type_int_argb ) ; graphics2d g = emptytile . creategraphics ( ) ; g . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; g . setcolor ( color . gray ) ; g . fillrect ( _num , _num , tilesize , tilesize ) ; g . setcolor ( color . white ) ; g . drawoval ( _num , _num , tilesize - _num , tilesize - _num ) ; g . filloval ( _num , _num , _num , _num ) ; g . filloval ( tilesize - _num , _num , _num , _num ) ; g . filloval ( tilesize / _num - _num , tilesize / _num - _num , _num , _num ) ; g . dispose ( ) ; }	creates a new instance of emptytilefactory using the specified info .
public static void i ( string tag , string msg , object ... args ) { if ( slevel > level_info ) { return ; } if ( args . length > _num ) { msg = string . format ( msg , args ) ; } log . i ( tag , msg ) ; }	send an info log message.
public void close ( ) throws ioexception { guard . close ( ) ; randomaccessfile localraf = raf ; if ( localraf != null ) { synchronized ( localraf ) { raf = null ; localraf . close ( ) ; } if ( filetodeleteonclose != null ) { filetodeleteonclose . delete ( ) ; filetodeleteonclose = null ; } } }	closes this zip file.
public boolean matchwithregex ( string aregex ) { if ( textutils . isempty ( aregex ) ) { return _bool ; } boolean matched = _bool ; if ( ! textutils . isempty ( mdisplayname ) ) { matched = mdisplayname . matches ( aregex ) ; } if ( ! matched ) { for ( string email : memails ) { matched |= email . matches ( aregex ) ; } } return matched ; }	test if some fields match with the reg ex .
public string stemstring ( string str ) { stringbuffer result = new stringbuffer ( ) ; int start = - _num ; for ( int j = _num ; j < str . length ( ) ; j ++ ) { char c = str . charat ( j ) ; if ( character . isletterordigit ( c ) ) { if ( start == - _num ) { start = j ; } } else if ( c == _str ) { if ( start == - _num ) { result . append ( c ) ; } } else { if ( start != - _num ) { result . append ( stem ( str . substring ( start , j ) ) ) ; start = - _num ; } result . append ( c ) ; } } if ( start != - _num ) { result . append ( stem ( str . substring ( start , str . length ( ) ) ) ) ; } return result . tostring ( ) ; }	stems everything in the given string.
public static list < integer > parsenumericlist ( string string ) { arraylist < integer > list = new arraylist < > ( ) ; pattern ranges = pattern . compile ( _str ) ; matcher m = ranges . matcher ( string ) ; while ( m . find ( ) ) { string range = m . group ( _str ) ; string = string . replace ( range , _str ) ; parsenumericrange ( range , list ) ; } string [ ] numbers = string . split ( _str ) ; for ( int i = _num ; i < numbers . length ; ++ i ) { string number = numbers [ i ] ; if ( ! number . isempty ( ) ) { list . add ( integer . valueof ( number ) ) ; } } collections . sort ( list ) ; return list ; }	converts a natural language list of numerals into a list of integers.
protected void savepasscodeandexit ( ) { intent resultintent = new intent ( ) ; resultintent . putextra ( key_passcode , mpasscodedigits [ _num ] + mpasscodedigits [ _num ] + mpasscodedigits [ _num ] + mpasscodedigits [ _num ] ) ; setresult ( result_ok , resultintent ) ; finish ( ) ; }	saves the pass code input by the user as the current pass code .
public static void readfully ( filechannel file , long pos , bytebuffer dst ) { try { do { int len = file . read ( dst , pos ) ; if ( len < _num ) { throw new eofexception ( ) ; } pos += len ; } while ( dst . remaining ( ) > _num ) ; dst . rewind ( ) ; } catch ( ioexception e ) { long size ; try { size = file . size ( ) ; } catch ( ioexception e2 ) { size = - _num ; } throw newillegalstateexception ( error_reading_failed , _str + _str , file , size , dst . remaining ( ) , pos , e ) ; } }	read from a file channel until the buffer is full.
public void triggercycle ( ) { lock . lock ( ) ; triggercount ++ ; contextsparked = _num ; lock . broadcast ( ) ; lock . unlock ( ) ; }	wake up the parked threads in this group .
protected boolean heapifydowncomparator ( final int ipos , object cur ) { int pos = ipos ; final int half = size > > > _num ; while ( pos < half ) { int min = pos ; object best = cur ; final int lchild = ( pos << _num ) + _num ; object left = queue [ lchild ] ; if ( comparator . compare ( best , left ) > _num ) { min = lchild ; best = left ; } final int rchild = lchild + _num ; if ( rchild < size ) { object right = queue [ rchild ] ; if ( comparator . compare ( best , right ) > _num ) { min = rchild ; best = right ; } } if ( min == pos ) { break ; } queue [ pos ] = best ; pos = min ; } queue [ pos ] = cur ; return ( pos != ipos ) ; }	execute a " heapify downwards " aka " siftdown ".
public static boolean isstring ( string str ) { return ( ( str . startswith ( _str ) && str . endswith ( _str ) ) || ( str . startswith ( _str ) && str . endswith ( _str ) ) ) && str . length ( ) > _num ; }	check the given string is a string literal.
static public boolean hasphoto ( tweet tweet ) { return getphotoentity ( tweet ) != null ; }	returns true if there is a media entity with the type of " photo ".
public void testcase19 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num } ; byte rbytes [ ] = { _num , _num , _num , _num , _num , _num , _num } ; int asign = _num ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = biginteger . zero ; biginteger result = anumber . add ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	add zero to a number.
public static stringbuilder formatto ( stringbuilder buf , long [ ] d , string sep ) { if ( d == null ) { return buf . append ( _str ) ; } if ( d . length == _num ) { return buf ; } buf . append ( d [ _num ] ) ; for ( int i = _num ; i < d . length ; i ++ ) { buf . append ( sep ) ; buf . append ( d [ i ] ) ; } return buf ; }	formats the long array d .
public static < t > int upperbound ( final list < t > valuelist , int fromidx , int toidx , final comparable < t > value ) { int len = toidx - fromidx + ( toidx > fromidx ? _num : _num ) ; int from = fromidx ; int half ; int middle ; while ( len > _num ) { half = len > > _num ; middle = from ; middle = middle + half ; if ( value . compareto ( valuelist . get ( middle ) ) == - _num ) { len = half ; } else { from = middle ; from ++ ; len = len - half - _num ; } } return from ; }	this method is equivalent to c + + std : upper_bound function returns an index pointing to the first element in the ordered collection which is greater than passed value.
public int size ( ) { return data . size ( ) ; }	returns the number of observations used in this test .
public static synchronized void registeradditionalhyphenationfiledirectory ( string directory ) { if ( additionalhyphenationfiledirectories == null ) { additionalhyphenationfiledirectories = new arraylist < > ( ) ; } additionalhyphenationfiledirectories . add ( directory ) ; }	registers additional file directories .
private void insertnewdrivefiles ( ) throws ioexception { cursor cursor = null ; try { cursor = mytracksproviderutils . gettrackcursor ( syncutils . no_drive_id_tracks_query , null , null ) ; long recordingtrackid = preferencesutils . getlong ( context , r . string . recording_track_id_key ) ; if ( cursor != null && cursor . movetofirst ( ) ) { do { track track = mytracksproviderutils . createtrack ( cursor ) ; if ( track . getid ( ) == recordingtrackid ) { continue ; } syncutils . insertdrivefile ( drive , folderid , context , mytracksproviderutils , track , _bool , _bool ) ; } while ( cursor . movetonext ( ) ) ; } } finally { if ( cursor != null ) { cursor . close ( ) ; } } }	inserts new drive files from tracks without a drive id .
public void testhandle_normalcompletion ( ) { for ( executionmode m : executionmode . values ( ) ) for ( boolean createincomplete : new boolean [ ] { _bool , _bool } ) for ( integer v1 : new integer [ ] { _num , null } ) { final completablefuture < integer > f = new completablefuture < > ( ) ; final atomicinteger a = new atomicinteger ( _num ) ; if ( ! createincomplete ) asserttrue ( f . complete ( v1 ) ) ; final completablefuture < integer > g = m . handle ( f , null ) ; if ( createincomplete ) asserttrue ( f . complete ( v1 ) ) ; checkcompletednormally ( g , inc ( v1 ) ) ; checkcompletednormally ( f , v1 ) ; assertequals ( _num , a . get ( ) ) ; } }	handle action completes normally with function value on normal completion of source.
private static string unescape ( string s ) { int len = s . length ( ) , base = _num , idx ; string escapes = _str ; string chars = _str ; stringbuffer sbuf = null ; while ( ( idx = s . indexof ( _str , base ) ) != - _num ) { if ( sbuf != null ) sbuf . append ( s . substring ( base , idx ) ) ; if ( idx + _num == len ) break ; char c = s . charat ( idx + _num ) ; int cidx = escapes . indexof ( c ) ; if ( cidx == - _num ) { sbuf . append ( _str ) ; sbuf . append ( c ) ; } else { if ( sbuf == null ) sbuf = new stringbuffer ( s . substring ( base , idx ) ) ; sbuf . append ( chars . charat ( cidx ) ) ; } base = idx + _num ; } if ( sbuf != null && base < len ) sbuf . append ( s . substring ( base ) ) ; return ( sbuf == null ? s : sbuf . tostring ( ) ) ; }	replace escape sequences with represented characters.
public static void put ( string dbgtoken ) { dbgtable . put ( dbgtoken , boolean . true ) ; }	installs a new debug token.
public boolean removedataset ( t d ) { if ( d == null ) return _bool ; boolean removed = mdatasets . remove ( d ) ; if ( removed ) { myvalcount -= d . getentrycount ( ) ; myvaluesum -= d . getyvaluesum ( ) ; calcminmax ( mdatasets ) ; } return removed ; }	removes the given dataset from this data object.
public long reservedstore ( ) { return m_size * m_totalslots ; }	bytesreserved : the space reserved on the backing file for those allocation slots ( allocatorslots * slotsreserved ) .
public transfer writestring ( string s ) throws ioexception { if ( s == null ) { out . writeint ( - _num ) ; } else { int len = s . length ( ) ; out . writeint ( len ) ; for ( int i = _num ; i < len ; i ++ ) { out . writechar ( s . charat ( i ) ) ; } } return this ; }	write a string . the maximum string length is integer . max_value .
private void fillinsidedraw ( graphics g , int x , int y , int w , int h ) { g . setcolor ( color . black ) ; g . drawrect ( x , y , w , h ) ; g . setcolor ( color . light_gray ) ; g . fillrect ( x + _num , y + _num , w - _num , h - _num ) ; }	fill the area only inside the boundary ( no overlap ).
public drawerbuilder addstickydraweritems ( @ nonnull idraweritem ... stickydraweritems ) { if ( this . mstickydraweritems == null ) { this . mstickydraweritems = new arraylist < > ( ) ; } collections . addall ( this . mstickydraweritems , stickydraweritems ) ; return this ; }	add a initial draweritem or a draweritem array for the stickydrawerfooter.
public void appendtobuffer ( stringbuilder buf ) { iterator < polygon > iter = polygons . iterator ( ) ; while ( iter . hasnext ( ) ) { polygon poly = iter . next ( ) ; poly . appendtobuffer ( buf ) ; if ( iter . hasnext ( ) ) { buf . append ( _str ) ; } } }	append polygons to the buffer .
public void addfunction ( functioninterface activefunction ) { functions . add ( activefunction ) ; }	add function to current file.
public static charset tocharset ( charset charset ) { return charset == null ? charset . defaultcharset ( ) : charset ; }	returns the given charset or the default charset if the given charset is null .
public < t extends dataobject > joiner join ( class < t > clazz , string alias ) { if ( ! jclasses . isempty ( ) ) { throw new joinerexception ( _str ) ; } jclass jc = new jclass ( clazz , alias , jclasses . size ( ) ) ; jclasses . add ( jc ) ; lastjclass = jc ; aliasmap . put ( alias , jc ) ; return this ; }	starts a new query not related to a previous class query .
public launchoption ( version version , authenticator authenticator , minecraftdirectory minecraftdir ) { objects . requirenonnull ( version ) ; objects . requirenonnull ( authenticator ) ; objects . requirenonnull ( minecraftdir ) ; this . version = version ; this . authenticator = authenticator ; this . minecraftdirectory = minecraftdir ; this . runtimedirectory = minecraftdir ; this . javaenvironment = javaenvironment . current ( ) ; }	creates a launchoption using the default java environment .
protected boolean isstoppable ( ) { return ( isrunning ( ) && getlocator ( ) != null ) ; }	determines whether the locator can be stopped in - process , such as when a locator is embedded in an application and the locatorlauncher api is being used .
public void load ( string filename ) throws exception { if ( ! filename . endswith ( _str ) && ! filename . endswith ( _str ) ) { throw new exception ( _str + _str ) ; } if ( filename . endswith ( _str ) ) { loadbinary ( filename ) ; } else if ( filename . endswith ( _str ) ) { loadxml ( filename ) ; } }	load a serialized knowledgeflow ( either binary or xml ).
public bindings addoptcomponent ( string property , class clazz , jtogglebutton c , boolean enabledbydefault ) { binding b = new optcomponentbinding ( this , property , clazz , c , enabledbydefault ) ; if ( _optcomponents . containskey ( property ) ) { throw new bindingexception ( messages . getstring ( _str ) ) ; } _optcomponents . put ( property , b ) ; return this ; }	add an optional ( nullable ) java bean component of type clazz .
public static boolean copyfile ( file file , file copy ) { if ( file == null || copy == null ) throw new nullpointerexception ( _str ) ; if ( ! file . isfile ( ) || copy . isdirectory ( ) ) throw new illegalargumentexception ( _str ) ; fileinputstream fis = null ; fileoutputstream fos = null ; try { fis = new fileinputstream ( file ) ; fos = new fileoutputstream ( copy ) ; int bytes ; byte [ ] packet = new byte [ copy_packet_size ] ; while ( ( bytes = fis . read ( packet , _num , copy_packet_size ) ) != - _num ) fos . write ( packet , _num , bytes ) ; return _bool ; } catch ( exception e ) { logger . log ( level . severe , _str , e ) ; return _bool ; } finally { try { if ( fos != null ) fos . close ( ) ; } catch ( exception e ) { logger . log ( level . severe , _str , e ) ; } try { if ( fis != null ) fis . close ( ) ; } catch ( exception e ) { logger . log ( level . severe , _str , e ) ; } } }	copies source file to the destination file , returns true if the file was successfully copied .
public static byte [ ] encryptmysqlpassword ( string password , byte [ ] seed ) { if ( password == null || password . equals ( _str ) ) { return new byte [ _num ] ; } messagedigest digest = null ; try { digest = messagedigest . getinstance ( _str ) ; } catch ( nosuchalgorithmexception e ) { logger . error ( _str , e ) ; return new byte [ _num ] ; } byte [ ] stage1_hash = digest . digest ( password . getbytes ( ) ) ; digest . reset ( ) ; byte [ ] sha1_stage1 = digest . digest ( stage1_hash ) ; digest . reset ( ) ; digest . update ( seed ) ; digest . update ( sha1_stage1 ) ; byte [ ] finalsha1 = digest . digest ( ) ; byte [ ] token = new byte [ finalsha1 . length ] ; for ( int i = _num ; i < finalsha1 . length ; i ++ ) { token [ i ] = ( byte ) ( stage1_hash [ i ] ^ finalsha1 [ i ] ) ; } return token ; }	do a mysql specific encryption of the given password < br > algorithm is : < br > stage1_hash = sha1 ( password ) < br > token = sha1 ( scramble + sha1 ( stage1_hash ) ) xor stage1_hash.
protected void addurl ( url url ) { if ( urls . contains ( url ) ) { logger . info ( _str + url ) ; return ; } urls . add ( url ) ; logger . info ( _str + url ) ; }	adds an url to the list of crl urls.
private int [ ] definenumeric ( random random ) { int [ ] num = new int [ getnumattributes ( ) ] ; for ( int i = _num ; i < num . length ; i ++ ) { num [ i ] = attribute . nominal ; } int numnum = _num ; for ( int i = _num ; ( numnum < getnumnumeric ( ) ) && ( i < getnumattributes ( ) * _num ) ; i ++ ) { int maybenext = ( int ) ( random . nextdouble ( ) * num . length ) ; if ( num [ maybenext ] != attribute . numeric ) { num [ maybenext ] = attribute . numeric ; numnum ++ ; } } return num ; }	chooses randomly the attributes that get datatyp numeric .
public static boolean isfavoritestation ( context context , int istation ) { return isstationexist ( context , istation , station_type_favorite ) ; }	judge whether station is a favorite station.
protected void paintcaption ( graphics g , rectangle rect ) { string s = gettargetlabel ( ) ; if ( s . equals ( _str ) ) { return ; } g . setfont ( gettargetfont ( ) ) ; fontmetrics fm = g . getfontmetrics ( ) ; string str = gettargetlabel ( ) ; int width = fm . stringwidth ( str ) ; int textx = rect . x + ( rect . width - width ) / _num ; int texty = rect . y + caption_margin_top + fm . getascent ( ) ; int sepy = rect . y + rect . height - caption_separator_height / _num ; g . setcolor ( istargetenabled ( ) ? getforegroundcolor ( ) : getdisabledcolor ( ) ) ; g . drawstring ( s , textx , texty ) ; draw3drect ( g , rect . x , sepy , rect . width , _num , _bool ) ; }	paints menu window ' s caption.
public void putfloat ( float x ) { bb . putfloat ( space -= _num , x ) ; }	add a ` float ` to the buffer , backwards from the current location.
final void putint ( int offset , int value ) { unsafe . putint ( offset + address , value ) ; }	writes an int at the specified offset from this native object ' s base address .
private static boolean isunreservedcharacter ( char p_char ) { return ( isalphanum ( p_char ) || mark_characters . indexof ( p_char ) != - _num ) ; }	determine whether a char is an unreserved character .
public static inetsocketaddress parsesocketaddress ( string addr ) { string [ ] parts = addr . split ( colon ) ; preconditions . checkargument ( parts . length == _num ) ; string hostname = parts [ _num ] ; int port = integer . parseint ( parts [ _num ] ) ; return new inetsocketaddress ( hostname , port ) ; }	parse the inet socket address from the string representation .
public void messagearrived ( mqttpublish sendmessage ) { final string methodname = _str ; if ( mqttcallback != null || callbacks . size ( ) > _num ) { synchronized ( spaceavailable ) { while ( running && ! quiescing && messagequeue . size ( ) >= inbound_queue_size ) { try { log . fine ( class_name , methodname , _str ) ; spaceavailable . wait ( _num ) ; } catch ( interruptedexception ex ) { } } } if ( ! quiescing ) { messagequeue . addelement ( sendmessage ) ; synchronized ( workavailable ) { log . fine ( class_name , methodname , _str ) ; workavailable . notifyall ( ) ; } } } }	this method is called when a message arrives on a topic.
private void findhome ( ) { string home = system . getproperty ( _str ) ; if ( home == null ) home = system . getproperty ( _str ) ; if ( home == null ) home = system . getproperty ( _str ) ; if ( home == null ) home = system . getproperty ( _str ) ; if ( home != null ) manifestpath = home + file . separator + _str + file . separator + manifestfilename ; else manifestpath = manifestfilename ; }	find the home folder of installation .
public static final int [ ] tointarray ( string s [ ] ) { int u [ ] = new int [ s . length ] ; for ( int j = _num ; j < s . length ; j ++ ) { u [ j ] = integer . parseint ( s [ j ] ) ; } return u ; }	convert eg [ " 1 " , " 2 " ] to [ 1 , 2 ].
private list < string > checkallcolumnsincube ( cubeinstance cube , tabledesc table , map < string , hivetablemeta . hivetablecolumnmeta > fieldsmap ) { set < columndesc > usedcolumns = sets . newhashset ( ) ; for ( tblcolref col : cube . getallcolumns ( ) ) { usedcolumns . add ( col . getcolumndesc ( ) ) ; } list < string > violatecolumns = lists . newarraylist ( ) ; for ( columndesc column : table . getcolumns ( ) ) { if ( usedcolumns . contains ( column ) ) { hivetablemeta . hivetablecolumnmeta field = fieldsmap . get ( column . getname ( ) ) ; if ( field == null || ! iscolumncompatible ( column , field ) ) { violatecolumns . add ( column . getname ( ) ) ; } } } return violatecolumns ; }	check whether all columns used in ` cube ` has compatible schema in current hive schema denoted by ` fieldsmap ` .
public static string makeunifiedlinefeeds ( string query ) { if ( query . indexof ( _str ) == - _num ) { return query ; } stringbuilder result = new stringbuilder ( query . length ( ) ) ; for ( int i = _num ; i < query . length ( ) ; i ++ ) { char c = query . charat ( i ) ; if ( c == _str ) { continue ; } result . append ( c ) ; } return result . tostring ( ) ; }	removes \ \ r characters from query . actually this is done specially for oracle due to some bug in it ' s driver.
private void reflectmembervariablesinleftbutton ( ) { final boolean lastpagereached = ( viewpager . getcurrentitem ( ) + _num ) == pages . size ( ) ; final boolean buttonshouldbeinvisible = ( lastpagereached && disableleftbuttononlastpage ) || leftbuttondisabled ; final boolean buttoniscurrentlyinvisible = leftbutton . getvisibility ( ) == view . invisible ; final boolean shouldupdatebutton = buttonshouldbeinvisible != buttoniscurrentlyinvisible ; if ( shouldupdatebutton ) { final animator buttonanimator = buttonshouldbeinvisible ? buttonanimatorfactory . newleftbuttondisappearanimator ( leftbutton ) : buttonanimatorfactory . newleftbuttonappearanimator ( leftbutton ) ; if ( buttonshouldbeinvisible ) { disablebutton ( buttonanimator , leftbutton ) ; } else { enablebutton ( buttonanimator , leftbutton ) ; } } }	enables or disables the left button , so that it matches the current member variables .
public static void registersemidisposableblock ( string oredictname ) { semidisposableblocks . add ( oredictname ) ; }	registers a block as semi disposable using its ore dictionary name.
public boolean acceptstypename ( string type ) { return _typelist . contains ( type ) ; }	returns true if this train will service the type of car or engine .
public void deleteasync ( final string id , final futurecallback < task > responsecallback ) throws ioexception { deleteobjectasync ( id , responsecallback ) ; }	delete the specified project .
private boolean continueafteracceptfailure ( throwable t ) { rmifailurehandler fh = rmisocketfactory . getfailurehandler ( ) ; if ( fh != null ) { return fh . failure ( t instanceof exception ? ( exception ) t : new invocationtargetexception ( t ) ) ; } else { throttlelooponexception ( ) ; return _bool ; } }	returns true if the accept loop should continue after the specified exception has been caught , or false if the accept loop should terminate ( closing the server socket ).
private static void processpackage ( string tbname , packages pkg ) { string classnameprefix = stringutil . parsehumpname ( tbname , _bool , ishumpmodelclass ) ; pkg . setdao ( packageprefix + ( stringutil . isempty ( packageprefix ) || stringutil . isempty ( packagedao ) ? _str : _str ) + packagedao ) ; pkg . setdaoname ( classnameprefix + daosuffix ) ; pkg . setmodel ( packageprefix + ( stringutil . isempty ( packageprefix ) || stringutil . isempty ( packagemodel ) ? _str : _str ) + packagemodel ) ; pkg . setmodelname ( classnameprefix + modelsuffix ) ; pkg . setmapperxml ( packageprefix + ( stringutil . isempty ( packageprefix ) || stringutil . isempty ( packagemapperxml ) ? _str : _str ) + packagemapperxml ) ; pkg . setmapperxmlname ( classnameprefix + mapperxmlsuffix ) ; pkg . setmodelnamelowerfirst ( stringutil . lowerfirst ( pkg . getmodelname ( ) ) ) ; }	process package and filename.
public void addoncentralpositionchangedlistener ( oncentralpositionchangedlistener listener ) { moncentralpositionchangedlisteners . add ( listener ) ; }	adds a listener that will be called when the central item of the list changes .
public boolean addcall ( string sourceclass , string sourcemethod , string targetclass , string targetmethod ) { callgraphentry from = new callgraphentry ( targetclass , targetmethod ) ; callgraphentry to = new callgraphentry ( sourceclass , sourcemethod ) ; if ( sourceclass . equals ( classname ) ) cutnodes . add ( to ) ; if ( ! graph . containsedge ( from , to ) ) { graph . addedge ( from , to ) ; callgraphclasses . add ( targetclass . replaceall ( _str , _str ) ) ; return _bool ; } return _bool ; }	add call to the call graph.
private static void dothreaddump ( final httpservletrequest req , final httpservletresponse resp ) throws ioexception { resp . setstatus ( http_ok ) ; resp . addheader ( _str , _str ) ; resp . setcontenttype ( mime_text_plain ) ; final printwriter w = resp . getwriter ( ) ; try { bigdatastatics . threaddump ( w ) ; w . flush ( ) ; } catch ( throwable t ) { launderthrowable ( t , resp , _str ) ; } finally { w . close ( ) ; } }	write a thread dump onto the http response as an aid to diagnose both node - local and distributed deadlocks.
public static boolean isvalidnmtoken ( string nmtoken ) { final int length = nmtoken . length ( ) ; if ( length == _num ) { return _bool ; } for ( int i = _num ; i < length ; ++ i ) { char ch = nmtoken . charat ( i ) ; if ( ! isname ( ch ) ) { return _bool ; } } return _bool ; }	check to see if a string is a valid nmtoken according to [ 7 ] in the xml 1 . 0 recommendation.
public mmroll ( mmrandom rng ) { super ( _num , _num ) ; this . total = rng . randomint ( this . faces ) + this . min ; all . addelement ( this . total ) ; }	most tolls use standard six sided dice .
public void handlebutton3request ( requestinvocationevent event ) throws modelcontrolexception { returntohomepage ( ) ; }	handles return to home page request .
static < t > unixstream < t > unixify ( final stream < t > stream ) { objects . requirenonnull ( stream , _str ) ; return new unixstreamimpl < > ( stream ) ; }	create a new unixstream fro the given stream .
@ deprecated public mediafile ( file f ) { this ( f . topath ( ) , null ) ; }	instantiates a new media file .
public static keystore load ( file keystorefile , password password , keystoretype keystoretype ) throws cryptoexception , filenotfoundexception { if ( ! keystoretype . isfilebased ( ) ) { throw new cryptoexception ( messageformat . format ( res . getstring ( _str ) , keystoretype . jce ( ) ) ) ; } fileinputstream fis = new fileinputstream ( keystorefile ) ; keystore keystore = getkeystoreinstance ( keystoretype ) ; try { keystore . load ( fis , password . tochararray ( ) ) ; } catch ( certificateexception ex ) { throw new keystoreloadexception ( messageformat . format ( res . getstring ( _str ) , keystoretype ) , ex , keystoretype ) ; } catch ( nosuchalgorithmexception ex ) { throw new keystoreloadexception ( messageformat . format ( res . getstring ( _str ) , keystoretype ) , ex , keystoretype ) ; } catch ( filenotfoundexception ex ) { throw ex ; } catch ( ioexception ex ) { throw new keystoreloadexception ( messageformat . format ( res . getstring ( _str ) , keystoretype ) , ex , keystoretype ) ; } finally { ioutils . closequietly ( fis ) ; } return keystore ; }	load a keystore from a file accessed by a password .
public void dumplog ( string containerid , file logfile ) throws dockerexception , interruptedexception { logstream errorstream = null ; filechannel filechannel = null ; fileoutputstream fileoutputstream = null ; try { if ( logfile . exists ( ) ) { logfile . delete ( ) ; } logfile . createnewfile ( ) ; fileoutputstream = new fileoutputstream ( logfile ) ; filechannel = fileoutputstream . getchannel ( ) ; errorstream = dockerclient . logs ( containerid , logsparam . stderr ( ) ) ; while ( errorstream . hasnext ( ) ) { logmessage message = errorstream . next ( ) ; bytebuffer buffer = message . content ( ) ; filechannel . write ( buffer ) ; } } catch ( filenotfoundexception e ) { throw new dockerexception ( _str + logfile + _str ) ; } catch ( ioexception e ) { throw new dockerexception ( e ) ; } finally { if ( errorstream != null ) { errorstream . close ( ) ; } if ( filechannel != null ) { try { filechannel . close ( ) ; } catch ( ioexception e ) { logger . error ( _str , e ) ; } } if ( fileoutputstream != null ) { try { fileoutputstream . close ( ) ; } catch ( ioexception e ) { logger . error ( _str , e ) ; } } } }	helper method for dumping error logs from docker to file.
public static final void warning ( string message , throwable e ) { if ( message == null && e != null ) { message = e . getmessage ( ) ; } logexpensive ( level . warning , message , e ) ; }	static version to log a warning message .
public static indexedimage pack ( int [ ] rgb , int width , int height ) { int arraylength = width * height ; int [ ] temppalette = new int [ _num ] ; int palettelocation = _num ; for ( int iter = _num ; iter < arraylength ; iter ++ ) { int current = rgb [ iter ] ; if ( ! contains ( temppalette , palettelocation , current ) ) { if ( palettelocation > _num ) { return null ; } temppalette [ palettelocation ] = current ; palettelocation ++ ; } } if ( palettelocation != temppalette . length ) { int [ ] newarray = new int [ palettelocation ] ; system . arraycopy ( temppalette , _num , newarray , _num , palettelocation ) ; temppalette = newarray ; } indexedimage i = new indexedimage ( width , height , temppalette , rgb ) ; return i ; }	packs the source rgba image and returns null if it fails.
public void addhint ( component hintcomponent , component destinationcomponent , string position ) { hintcomponent . putclientproperty ( pos , position ) ; hintcomponent . putclientproperty ( dest , destinationcomponent ) ; vec . addelement ( hintcomponent ) ; }	places a hint within the glass in a position relative to the destinationcomponent , the position is indicated with border layout attributes.
public static int convertsrgbtolinearrgb ( int color ) { float input , output ; input = color / _num ; if ( input <= _num ) { output = input / _num ; } else { output = ( float ) math . pow ( ( input + _num ) / _num , _num ) ; } return math . round ( output * _num ) ; }	helper function to convert a color component in srgb space to linear rgb space.
public void vetoablechange ( propertychangeevent evt ) throws propertyvetoexception { log . info ( evt . tostring ( ) ) ; throw new propertyvetoexception ( _str , evt ) ; }	vetoable change . called from ccache to close connections.
public void finish ( ) throws sqlexception { statement statement = connection . createstatement ( ) ; statement . execute ( _str ) ; statement . close ( ) ; statement = connection . createstatement ( ) ; statement . execute ( _str ) ; statement . close ( ) ; statement = connection . createstatement ( ) ; statement . execute ( _str ) ; statement . close ( ) ; statement = connection . createstatement ( ) ; statement . execute ( _str ) ; statement . close ( ) ; }	wraps up the index generation process and writes all remaining statements e.
public authorizationcode ( string code , string resourceownerid , string clientid , string redirecturi , set < string > scope , string claims , long expirytime , string nonce , string realm , string authmodules , string acr , string ssotokenid , string codechallenge , string codechallengemethod , string authgrantid , string auditid ) { super ( new hashmap < string , object > ( ) ) ; setstringproperty ( id , code ) ; setstringproperty ( username , resourceownerid ) ; setstringproperty ( client_id , clientid ) ; setstringproperty ( redirect_uri , redirecturi ) ; setstringproperty ( expire_time , string . valueof ( expirytime ) ) ; put ( scope , newlist ( scope ) ) ; setstringproperty ( token_type , _str ) ; setstringproperty ( token_name , oauth_code_type ) ; setstringproperty ( nonce , nonce ) ; setstringproperty ( auth_modules , authmodules ) ; setstringproperty ( acr , acr ) ; setstringproperty ( code_challenge , codechallenge ) ; setstringproperty ( code_challenge_method , codechallengemethod ) ; setstringproperty ( auth_grant_id , authgrantid ) ; setstringproperty ( realm , realm == null || realm . isempty ( ) ? _str : realm ) ; setstringproperty ( sso_token_id , ssotokenid ) ; put ( claims , collectionutils . aslist ( claims ) ) ; setstringproperty ( audit_tracking_id , auditid ) ; }	constructs a new authorizationcode .
@ override public object draw ( graphics2d g2 , rectangle2d area , object params ) { draw ( g2 , area ) ; return null ; }	draws the block within the specified area .
public void testsetbitpositiveinside3 ( ) { byte abytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = _num ; int number = _num ; byte rbytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . setbit ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	setbit ( int n ) inside a positive number.
public boolean isrowvisible ( int row ) { if ( row != - _num ) { rectangle cellrect = getcellrect ( row , _num , _bool ) ; rectangle visiblerect = getvisiblerect ( ) ; return visiblerect . intersects ( cellrect ) ; } else return _bool ; }	determines if the given row is visible .
public static int fileintimerange ( file f , date start , date end ) { long time = getfiletime ( f ) ; if ( start != null && time < start . gettime ( ) ) { return - _num ; } if ( end != null && time > end . gettime ( ) ) { return _num ; } return _num ; }	check if file is modified during that period.
public object extfunction ( string ns , string funcname , vector argvec , object methodkey , expressioncontext exprcontext ) throws javax . xml . transform . transformerexception { object result = null ; if ( null != ns ) { extensionhandler extns = ( extensionhandler ) m_extensionfunctionnamespaces . get ( ns ) ; if ( null != extns ) { try { result = extns . callfunction ( funcname , argvec , methodkey , exprcontext ) ; } catch ( javax . xml . transform . transformerexception e ) { throw e ; } catch ( exception e ) { throw new javax . xml . transform . transformerexception ( e ) ; } } else { throw new xpathprocessorexception ( xslmessages . createmessage ( xslterrorresources . er_extension_func_unknown , new object [ ] { ns , funcname } ) ) ; } } return result ; }	handle an extension function .
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m_buildthread . isalive ( ) && m_state != idle ) { wait ( ) ; } } catch ( interruptedexception ex ) { } } else { notifyall ( ) ; } }	function used to stop code that calls accepttrainingset.
public set < resource > onclass ( ) { set < resource > targets = new hashset < > ( ) ; for ( owlclass c : qcclasses ) { targets . add ( c . geturi ( ) ) ; } return targets ; }	get all onclass relations for this property restriction .
public static int indexofchars ( string str , string chars , int fromindex ) { final int len = str . length ( ) ; for ( int pos = fromindex ; pos < len ; pos ++ ) { if ( chars . indexof ( str . charat ( pos ) ) >= _num ) { return pos ; } } return - _num ; }	like string . indexof ( ) except that it will look for any of the characters in ' chars ' ( similar to c ' s strpbrk ).
private synchronized void notifyzoomlisteners ( zoomevent e ) { for ( zoomlistener listener : mzoomlisteners ) { listener . zoomapplied ( e ) ; } }	notify the zoom listeners about a zoom change .
public static string buildstringfromlines ( string ... lines ) { int numchars = lines . length ; for ( string line : lines ) { numchars += line . length ( ) ; } stringbuilder builder = new stringbuilder ( numchars ) ; for ( string line : lines ) { builder . append ( line ) ; builder . append ( _str ) ; } return builder . tostring ( ) ; }	easy way to create a string from a bunch of lines .
public void init ( ) { if ( mcontext == null ) { return ; } if ( mname . isempty ( ) ) { mname = mcontext . getpackagename ( ) ; } if ( mmode == invalid_value || ( mmode != mode_private && mmode != mode_world_readable && mmode != mode_world_writeable ) ) { mmode = mode_private ; } msharedpreferences = mcontext . getsharedpreferences ( mname , mmode ) ; }	initial the instance of the preferences manager .
@ override public void mergeandoutputtransformationmetadata ( iterator < distinctvalue > values , string outputdir , int colid , filesystem fs , tfutils agents ) throws ioexception { double min = double . max_value ; double max = - double . max_value ; int nbins = _num ; distinctvalue val = new distinctvalue ( ) ; string w = null ; double d ; while ( values . hasnext ( ) ) { val . reset ( ) ; val = values . next ( ) ; w = val . getword ( ) ; if ( w . startswith ( min_prefix ) ) { d = utilfunctions . parsetodouble ( w . substring ( min_prefix . length ( ) ) ) ; if ( d < min ) min = d ; } else if ( w . startswith ( max_prefix ) ) { d = utilfunctions . parsetodouble ( w . substring ( max_prefix . length ( ) ) ) ; if ( d > max ) max = d ; } else if ( w . startswith ( nbins_prefix ) ) { nbins = ( int ) utilfunctions . parsetolong ( w . substring ( nbins_prefix . length ( ) ) ) ; } else throw new runtimeexception ( _str + w ) ; } double binwidth = ( max - min ) / nbins ; writetfmtd ( colid , double . tostring ( min ) , double . tostring ( max ) , double . tostring ( binwidth ) , integer . tostring ( nbins ) , outputdir , fs , agents ) ; }	method to merge map output transformation metadata .
static sqlwarning convertshowwarningstosqlwarnings ( connection connection ) throws sqlexception { return convertshowwarningstosqlwarnings ( connection , _num , _bool ) ; }	turns output of ' show warnings ' into jdbc sqlwarning instances.
public boolean hasemptyrow ( ) { if ( m_datavector . size ( ) == _num ) { return _bool ; } list < string > datarow = m_datavector . get ( m_datavector . size ( ) - _num ) ; for ( string s : datarow ) { if ( s . length ( ) != _num ) { return _bool ; } } return _bool ; }	returns true if the model has an empty row.
public node selectsinglenode ( node contextnode , string str , node namespacenode ) throws transformerexception { nodeiterator nl = selectnodeiterator ( contextnode , str , namespacenode ) ; return nl . nextnode ( ) ; }	use an xpath string to select a single node.
public synchronized void add ( string category , double value ) { mcategories . add ( category ) ; mvalues . add ( value ) ; }	adds a new value to the series .
public final void walkgraph ( hashtable semnodestable ) { integer uid = new integer ( myuid ) ; if ( semnodestable . get ( uid ) != null ) return ; semnodestable . put ( uid , this ) ; if ( assumeexpr != null ) { assumeexpr . walkgraph ( semnodestable ) ; } ; }	walkgraph finds all reachable nodes in the semantic graph and inserts them in the hashtable semnodestable for use by the explorer tool .
private list < valuecomboboxdatagroup > populatesymbollist ( class < ? > paneldetails ) { list < valuecomboboxdatagroup > combinedsymbollist = new arraylist < valuecomboboxdatagroup > ( ) ; for ( fieldstate panel : symboltypefieldlist ) { panel . populatesymbollist ( paneldetails , combinedsymbollist ) ; } return combinedsymbollist ; }	populate symbol type list.
@ override public int hashcode ( ) { long value = _num ; value += _num * value + double . doubletolongbits ( math . abs ( x ) ) ; value += _num * value + double . doubletolongbits ( math . abs ( y ) ) ; return ( int ) ( value ^ ( value > > > _num ) ) ; }	calcualates hashcode based on stored coordinates.
public void disconnect ( ) { socket . disconnect ( ) ; }	disconnects from the telemetry service.
protected void initcomponentdefaults ( uidefaults table ) { super . initcomponentdefaults ( table ) ; color c = table . getcolor ( _str ) ; table . put ( _str , c ) ; table . put ( _str , c ) ; }	for overwriting component defaults.
public int indexofcolumnname ( string columnname ) { return columnnamelist . indexof ( columnname . tolowercase ( ) ) ; }	get index of this column name.
public boolean clear ( t expect , boolean allowreset ) { sync . lock ( ) ; try { if ( expect != value ) { return _bool ; } valuestate prev = state ; clear ( allowreset ) ; return prev == valuestate . set ; } finally { sync . unlock ( ) ; } }	clears the cached value as long it matches the expected value .
public void copystream ( inputstream is ) throws ioexception { super . setcontentencoding ( null ) ; bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; while ( _bool ) { int b = is . read ( ) ; if ( b == - _num ) { content = baos . tobytearray ( ) ; is . close ( ) ; return ; } } }	set the content by copying the given stream.
public void test_readresolve ( ) { mockattributedcharacteriteratorattribute mac1 = new mockattributedcharacteriteratorattribute ( _str ) ; try { mac1 . readresolve ( ) ; fail ( _str ) ; } catch ( invalidobjectexception e ) { } objectoutputstream out = null ; objectinputstream in = null ; try { bytearrayoutputstream bytes = new bytearrayoutputstream ( ) ; out = new objectoutputstream ( bytes ) ; attributedcharacteriterator . attribute attr1 , attr2 ; attr1 = attributedcharacteriterator . attribute . language ; out . writeobject ( attr1 ) ; in = new objectinputstream ( new bytearrayinputstream ( bytes . tobytearray ( ) ) ) ; try { attr2 = ( attributedcharacteriterator . attribute ) in . readobject ( ) ; assertsame ( _str , attr1 , attr2 ) ; } catch ( illegalargumentexception e ) { fail ( _str + e ) ; } } catch ( ioexception e ) { fail ( _str + e ) ; } catch ( classnotfoundexception e ) { fail ( _str + e ) ; } finally { try { if ( out != null ) out . close ( ) ; if ( in != null ) in . close ( ) ; } catch ( ioexception e ) { } } }	java . text . attributedcharacteriterator . attribute # readresolve ( ) test of method java . text . attributedcharacteriterator . attribute # readresolve ( ) .
public void interrupt ( ) { thread t = threadvar . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } threadvar . clear ( ) ; }	a new method that interrupts the worker thread.
public final boolean issecure ( socket sock ) throws illegalargumentexception { if ( sock == null ) { throw new illegalargumentexception ( _str ) ; } if ( sock . getclass ( ) != socket . class ) { throw new illegalargumentexception ( _str ) ; } if ( sock . isclosed ( ) ) { throw new illegalargumentexception ( _str ) ; } return _bool ; }	checks whether a socket connection is secure.
protected boolean checklist ( string currentval , string tokenvalue ) { if ( currentval == null || tokenvalue == null ) { throw new nullpointerexception ( _str ) ; } if ( ! currentval . startswith ( _str ) && ! currentval . startswith ( _str ) ) { throw new illegalargumentexception ( _str ) ; } boolean negation = currentval . startswith ( _str ) ; string listname = currentval . substring ( currentval . indexof ( _str ) + _num ) ; object listobj = listmap . get ( listname ) ; if ( listobj == null ) return _bool ; boolean contains ; if ( listobj instanceof set ) { set < string > set = ( set ) listobj ; contains = set . contains ( tokenvalue ) ; } else { throw new illegalargumentexception ( _str + listobj ) ; } return ! ( contains && negation || ! contains && ! negation ) ; }	checks if tokenvalue is contained in list.
public static synchronized void addnativelibrarydependencies ( string name , string ... dependencynames ) { list < string > list = librarydependencies . get ( name ) ; if ( list == null ) { librarydependencies . put ( name , list = new arraylist < string > ( ) ) ; } for ( string dependencyname : dependencynames ) { if ( ! list . contains ( dependencyname ) ) { list . add ( dependencyname ) ; } } }	add names of library dependencies for a library.
@ override protected boolean hasoverflow ( flatrstartreenode node ) { if ( node . isleaf ( ) ) { return node . getnumentries ( ) == leafcapacity ; } else if ( node . getnumentries ( ) == node . getcapacity ( ) ) { node . increaseentries ( ) ; } return _bool ; }	returns true if in the specified node an overflow occurred , false otherwise .
public void processvolumeexpansion ( storagesystem storagesystem , uri storagepooluri , uri volumeid , cimargument [ ] outargs ) throws exception { stringbuilder logmsgbuilder = new stringbuilder ( string . format ( _str ) ) ; cimconnection connection = _cimconnection . getconnection ( storagesystem ) ; wbemclient client = connection . getcimclient ( ) ; storagepool storagepool = _dbclient . queryobject ( storagepool . class , storagepooluri ) ; stringmap reservationmap = storagepool . getreservedcapacitymap ( ) ; reservationmap . remove ( volumeid . tostring ( ) ) ; updatestoragepoolcapacity ( client , storagepool ) ; _dbclient . persistobject ( storagepool ) ; volume volume = _dbclient . queryobject ( volume . class , volumeid ) ; cimobjectpath volumepath = ( cimobjectpath ) _cimpath . getfromoutputargs ( outargs , ibmsmisconstants . cp_the_element ) ; boolean issuccess = _bool ; if ( volumepath != null ) { ciminstance volumeinstance = client . getinstance ( volumepath , _bool , _bool , null ) ; if ( volumeinstance != null ) { issuccess = _bool ; volume . setprovisionedcapacity ( getprovisionedcapacityinformation ( volumeinstance ) ) ; volume . setallocatedcapacity ( getallocatedcapacityinformation ( client , volumeinstance ) ) ; _dbclient . persistobject ( volume ) ; logmsgbuilder . append ( string . format ( _str , volume . getcapacity ( ) , volume . getprovisionedcapacity ( ) , volume . getallocatedcapacity ( ) ) ) ; } } if ( ! issuccess ) { unsignedinteger32 returncoede = ( unsignedinteger32 ) _cimpath . getfromoutputargs ( outargs , ibmsmisconstants . cp_return_code ) ; logmsgbuilder . append ( _str ) ; logmsgbuilder . append ( string . format ( _str , volume . getid ( ) , returncoede . tostring ( ) ) ) ; } _log . info ( logmsgbuilder . tostring ( ) ) ; }	update db with smi - s output .
private void addbesttestsuite ( file newlygeneratedtestsuite ) { string testname = extractclassname ( tmptests , newlygeneratedtestsuite ) ; string path = testname . replace ( _str , file . separator ) + _str ; file file = new file ( getbesttestfolder ( ) + file . separator + path ) ; file . delete ( ) ; try { fileutils . copyfile ( newlygeneratedtestsuite , file ) ; } catch ( ioexception e ) { logger . error ( _str + e . getmessage ( ) , e ) ; } }	from the test suites generated in the last ctg run , add the given one to the current best set.
@ override public void createconnectionfactory ( string name , boolean ha , boolean usediscovery , int cftype , string connectors , string bindings ) throws exception { createconnectionfactory ( name , ha , usediscovery , cftype , toarray ( connectors ) , toarray ( bindings ) ) ; }	create a jms connectionfactory with the specified name connected to a single live - backup pair of servers.
protected object evaluatesingle ( list elements , string expr ) { list array ; if ( elements instanceof java . util . vector ) { array = new java . util . vector ( ) ; } else { array = new arraylist ( ) ; } for ( iterator e = elements . iterator ( ) ; e . hasnext ( ) ; ) { object o = e . next ( ) ; if ( o instanceof structuredcontent ) { if ( ( o = evaluatesingle ( ( structuredcontent ) o , expr ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == _num ) { return ( structuredcontent ) array . get ( _num ) ; } return array ; }	override this element to handle testing a predicate expression with no comparator.
protected void onclose ( ) { }	override to trigger some behavior when the filesystem is closed.
private int doscale ( int number , double factor ) { return ( int ) strictmath . round ( number * factor ) ; }	scales the given number with the provided scale factor.
private int parsemessageid ( final byte [ ] b , final int off ) throws parseexception { final int messageidlen = constants . message_id_len ; final int len = b . length - off ; if ( len >= messageidlen ) { messageid_ = arrays . copyofrange ( b , off , off + messageidlen ) ; return messageidlen ; } else { throw new parseexception ( _str ) ; } }	parse the message id in the provided bytes.
public static string combineextensions ( final string [ ] extensions ) { check . notnull ( extensions , _str ) ; final stringbuffer ret = new stringbuffer ( ) ; for ( int i = _num ; i < extensions . length ; i ++ ) { if ( i > _num ) { ret . append ( _str ) ; } ret . append ( extensions [ i ] ) ; } return ret . tostring ( ) ; }	combines the given extensions strings into a single string , extensions separated by a comma .
public static void initializeproperties ( string file ) throws missingresourceexception { properties props = new properties ( ) ; resourcebundle bundle = resourcebundle . getbundle ( file ) ; for ( string key : bundle . keyset ( ) ) { props . put ( key , bundle . getstring ( key ) ) ; } initializeproperties ( props , _bool , _bool ) ; }	initializes properties bundle from the < code > file < code > passed .
private string tweaknativelaunchuri ( string uri , boolean fordebugging , launchinfo launchinfo ) throws ioexception , filenotfoundexception { if ( launchinfo . ishttporabout ( ) ) { boolean modify = ( getpreference ( pref_uri_modification ) != _num ) ; if ( modify && fordebugging && ! launchinfo . isabout ( ) ) { uri = urlhelper . escapespace ( uri ) ; urlhelper urlhelper = new urlhelper ( uri ) ; map < string , string > params = urlhelper . getparametermap ( ) ; params . put ( _str , _str ) ; urlhelper . setparametermap ( params ) ; uri = urlhelper . geturl ( ) ; } } else { file f = null ; if ( uri . startswith ( _str ) ) { try { f = new file ( new uri ( uri ) ) ; } catch ( urisyntaxexception e ) { ioexception ioe = new ioexception ( e . getmessage ( ) ) ; ioe . initcause ( e ) ; throw ioe ; } } else { f = new file ( uri ) ; } if ( f != null && f . exists ( ) ) { uri = f . getabsolutepath ( ) ; } else { throw new filenotfoundexception ( uri ) ; } } return uri ; }	tweaks the launch uri if necessary , e.
public void addlistener ( final listener listener ) { listeners . add ( listener ) ; }	adds a listener to the gui .
public list < t > queryaslist ( ) { quantumfluxcursor < t > cursor = queryascursor ( ) ; try { list < t > resultlist = new arraylist < > ( cursor . getcount ( ) ) ; while ( cursor . movetonext ( ) ) { resultlist . add ( cursor . inflate ( ) ) ; } return resultlist ; } finally { if ( cursor != null ) cursor . close ( ) ; } }	does the same as the query cursor , but packs all of the cursor items into a list , once the list is populated , the cursor will be closed .
@ override public void profile ( ) { recordstats ( ) ; }	profile memory usage and gc statistics.
public static final void saveinstanceidentifier ( string confpath , string instanceidentifier ) throws exception { path file = paths . get ( confpath , instance_identifier_file ) ; log . trace ( _str , file ) ; atomicsave . execute ( file . tostring ( ) , _str , instanceidentifier . getbytes ( standardcharsets . utf_8 ) ) ; }	saves the instance identifier of this security server to file .
part ( string contents , string property ) throws exception { this . contents = _str + contents ; this . property = property ; simplify ( ) ; }	create a new property by parsing the given string .
public static boolean issame ( object s1 , object s2 ) { if ( s1 == s2 ) return _bool ; if ( x . isempty ( s1 ) && x . isempty ( s2 ) ) return _bool ; if ( s1 != null ) { return s1 . equals ( s2 ) ; } return _bool ; }	test whether equals the two objects .
public static double standarddeviation ( double variance ) { return math . sqrt ( variance ) ; }	returns the standard deviation from a variance .
public void recordgcversions ( regionversionvector < t > other ) { assert other . membertogcversion != null : _str ; recordgcversion ( other . myid , other . localgcversion . get ( ) ) ; for ( map . entry < t , long > entry : other . membertogcversion . entryset ( ) ) { recordgcversion ( entry . getkey ( ) , entry . getvalue ( ) . longvalue ( ) ) ; } }	record all of the gc versions in the given vector.
boolean waitforstate ( processor p , int state ) { synchronized ( waitsync ) { try { while ( p . getstate ( ) < state && statetransitionok ) waitsync . wait ( ) ; } catch ( exception e ) { } } return statetransitionok ; }	block until the processor has transitioned to the given state.
private static boolean extractfile ( context c , string rootasset , string path ) { assetmanager assetmanager = c . getassets ( ) ; inputstream in = null ; outputstream out = null ; try { in = assetmanager . open ( rootasset + path ) ; string fullpath = prefstore . getenvdir ( c ) + path ; out = new fileoutputstream ( fullpath ) ; byte [ ] buffer = new byte [ _num ] ; int read ; while ( ( read = in . read ( buffer ) ) != - _num ) { out . write ( buffer , _num , read ) ; } out . flush ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; return _bool ; } finally { close ( in ) ; close ( out ) ; } return _bool ; }	extract file to env directory.
protected int never ( ) { synchronized ( sleeplock ) { while ( running ) { try { sleeplock . wait ( _num * _num * _num ) ; } catch ( interruptedexception e ) { continue ; } } return _num ; } }	method that never returns , e.
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return message_type ; case _num : return request_info ; case _num : return response_info ; case _num : return trace_info ; case _num : return global_context ; case _num : return local_context ; case _num : return heartbeat_info ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
protected void loadhistory ( boolean set ) { bufferedinputstream str ; file file ; int width ; int height ; try { file = new file ( gethistoryfilename ( ) ) ; if ( file . exists ( ) ) { str = new bufferedinputstream ( new fileinputstream ( gethistoryfilename ( ) ) ) ; m_history . load ( str ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } if ( set ) { m_connectionpanel . sethistory ( stringtomodel ( m_history . getproperty ( connectionpanel . history_name , _str ) ) ) ; m_querypanel . sethistory ( stringtomodel ( m_history . getproperty ( querypanel . history_name , _str ) ) ) ; m_querypanel . setmaxrows ( integer . parseint ( m_history . getproperty ( querypanel . max_rows , _str ) ) ) ; width = integer . parseint ( m_history . getproperty ( width , _str ) ) ; height = integer . parseint ( m_history . getproperty ( height , _str ) ) ; if ( ( width != _num ) && ( height != _num ) ) { setpreferredsize ( new dimension ( width , height ) ) ; } } }	loads the history properties of the sqlviewer in the user ' s home directory .
private void updatepanelforexpansion ( float percentage ) { updatepromovisibility ( _num ) ; float basebasey = mathutils . interpolate ( _num , getbasepagetargety ( ) , percentage ) ; mbasepagey = basebasey ; float brightness = mathutils . interpolate ( base_page_brightness_state_peeked , base_page_brightness_state_expanded , percentage ) ; mbasepagebrightness = brightness ; float searchbarheight = math . round ( mathutils . interpolate ( msearchbarheightpeeking , getsearchbarheightexpanded ( ) , percentage ) ) ; msearchbarheight = searchbarheight ; msearchbartextopacity = _num ; missearchbarbordervisible = _bool ; msearchbarbordery = searchbarheight - search_bar_border_height_dp + _num ; msearchiconopacity = search_icon_opacity_state_expanded ; marrowiconopacity = arrow_icon_opacity_state_expanded ; marrowiconrotation = math . round ( mathutils . interpolate ( arrow_icon_rotation_state_peeked , arrow_icon_rotation_state_expanded , percentage ) ) ; mcloseiconopacity = close_icon_opacity_state_expanded ; float peekedheight = getpanelheightfromstate ( panelstate . peeked ) ; float threshold = progress_bar_visibility_threshold_dp / mpxtodp ; float diff = math . min ( mheight - peekedheight , threshold ) ; float progressbaropacity = mathutils . interpolate ( _num , _num , diff / threshold ) ; mprogressbaropacity = progressbaropacity ; mprogressbary = searchbarheight - progress_bar_height_dp + _num ; updatesearchbarshadow ( ) ; }	updates the ui state for the peeked to expanded transition ( and vice versa ) , according to a completion | percentage | .
protected boolean [ ] updateableclusterer ( ) { boolean [ ] result = new boolean [ _num ] ; print ( _str ) ; if ( m_clusterer instanceof updateableclusterer ) { println ( _str ) ; result [ _num ] = _bool ; } else { println ( _str ) ; result [ _num ] = _bool ; } return result ; }	checks whether the scheme can build models incrementally .
public void addfield ( mappedmember mm ) { fields . add ( mm ) ; }	add a field to the class.
public static list < basemqttmessage > readandconvertmessagelog ( final file selectedfile ) throws spyexception { final list < string > lines = fileutils . readfileaslines ( selectedfile ) ; logger . info ( _str , lines . size ( ) , selectedfile . getabsolutefile ( ) ) ; return processmessagelog ( parsemessagelog ( lines , null , _num , _num ) , null , _num , _num ) ; }	this all - in - one method reads a message log from the given file and turns that into a list of mqtt message objects .
void readstream ( inputstream is ) throws exception { string line ; date start = new date ( ) ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( is ) ) ; while ( ( line = reader . readline ( ) ) != null && ! mstop ) { mresults . append ( line ) ; mresults . append ( tools . linesep ) ; date end = new date ( ) ; if ( ( end . gettime ( ) - start . gettime ( ) ) / _num > _num || mresults . length ( ) > _num ) { start = end ; int last = mresults . lastindexof ( _str ) ; if ( last != - _num ) { xmppmsg msg = new xmppmsg ( _font ) ; msg . append ( mresults . substring ( _num , last + _num ) ) ; mcmdbase . send ( mshellid , msg ) ; mresults . setlength ( _num ) ; } } } }	reads the given inputstream and sends a xmppmsg every 5000 chars or every 10 seconds , whatever comes first.
public void removeparentrelation ( long osmid ) { if ( parentrelations != null ) { arraylist < relation > temprellist = new arraylist < relation > ( parentrelations ) ; for ( relation r : temprellist ) { if ( osmid == r . getosmid ( ) ) parentrelations . remove ( r ) ; } } }	remove reference to parent relation.
public final void test_roundtrip_getkeyspeccipher01 ( ) { boolean performed = _bool ; for ( int i = _num ; i < algname . length ; i ++ ) { try { testdatagenerator g = new testdatagenerator ( algname [ i ] [ _num ] , algname [ i ] [ _num ] , privatekeyinfo , null ) ; encryptedprivatekeyinfo epki ; if ( g . ap ( ) == null ) { epki = new encryptedprivatekeyinfo ( algname [ i ] [ _num ] , g . ct ( ) ) ; } else { epki = new encryptedprivatekeyinfo ( g . ap ( ) , g . ct ( ) ) ; } try { pkcs8encodedkeyspec eks = epki . getkeyspec ( g . c ( ) ) ; if ( ! arrays . equals ( privatekeyinfo , eks . getencoded ( ) ) ) { fail ( algname [ i ] [ _num ] + _str + algname [ i ] [ _num ] ) ; } } catch ( invalidkeyspecexception e ) { fail ( algname [ i ] [ _num ] + _str + algname [ i ] [ _num ] + e + _str ) ; } performed = _bool ; } catch ( testdatagenerator . allowedfailure allowedfailure ) { } catch ( nosuchalgorithmexception allowed ) { } } asserttrue ( _str , performed ) ; }	encrypted data contains valid pkcs8 key info encoding.
void insert ( v val , k key ) { arraylist < k > list = map . get ( val ) ; if ( list == null ) { list = new arraylist < k > ( _num ) ; map . put ( clonevalue ( val ) , list ) ; } list . add ( key ) ; }	returns the arraylist stored for a key.
public serversocket createserversocket ( int nport , int backlog ) throws ioexception { return createserversocket ( nport , backlog , null ) ; }	return a serversocket possibly configured for ssl.
public static arraylist < integer > convertstringarraytointegerarray ( list < string > arraylist ) { arraylist < integer > integers = new arraylist < > ( ) ; for ( string str : arraylist ) { integers . add ( integer . valueof ( str ) ) ; } return integers ; }	create a integer arraylist from string arraylist.
public static string buildselectorfromclass ( string classvalue ) { stringbuilder strb = new stringbuilder ( ) ; strb . append ( class_selector_prefix ) ; strb . append ( classvalue ) ; return strb . tostring ( ) ; }	create a selector of the form . $ classvalue.
public void ensurecapacity ( int minimumcapacity ) { if ( minimumcapacity > value . length ) { int ourmin = value . length * _num + _num ; enlargebuffer ( math . max ( ourmin , minimumcapacity ) ) ; } }	ensures that the capacity of the buffer is at least equal to the specified minimum.
public string poolfooterstatements ( ) { stringbuilder sb = new stringbuilder ( ) ; for ( string footerstatement : footerstatements ) { sb . append ( _str ) ; sb . append ( footerstatement ) ; sb . append ( _str ) ; } footerstatements . clear ( ) ; return sb . tostring ( ) ; }	gets and clears the footer statements .
private void handlenodequeue ( serialmessage incomingmessage ) { if ( currentstage == zwavenodeinitstage . done ) { return ; } logger . debug ( _str , node . getnodeid ( ) , msgqueue . size ( ) ) ; if ( msgqueue . contains ( incomingmessage ) ) { msgqueue . remove ( incomingmessage ) ; logger . debug ( _str , node . getnodeid ( ) , msgqueue . size ( ) ) ; freetosend = _bool ; advancenodestage ( incomingmessage . getmessageclass ( ) ) ; } else if ( msgqueue . isempty ( ) && currentstage == zwavenodeinitstage . security_report ) { logger . debug ( _str , node . getnodeid ( ) ) ; advancenodestage ( incomingmessage . getmessageclass ( ) ) ; } }	handles the removal of frames from the send queue.
public static predicate < string > matches ( final string regexp ) { objects . requirenonnull ( regexp , _str ) ; return null ; }	create a new predicate returning true when the input string matches the given regexp .
public boolean hasset ( string name ) { return m_map . containskey ( name ) ; }	indicates if this composite contains a tupleset with the given name .
public void clearparsers ( ) { timer . stop ( ) ; clearparsernoticehighlights ( ) ; parsers . clear ( ) ; textarea . fireparsernoticeschange ( ) ; }	removes all parsers and any highlights they have created .
protected propertydefinition ( abstractmanagedobjectdefinition < ? , ? > d , class < t > theclass , string propertyname , enumset < propertyoption > options , administratoraction adminaction , defaultbehaviorprovider < t > defaultbehavior ) { reject . ifnull ( d , theclass , propertyname , options , adminaction , defaultbehavior ) ; this . definition = d ; this . theclass = theclass ; this . propertyname = propertyname ; this . options = enumset . copyof ( options ) ; this . adminaction = adminaction ; this . defaultbehavior = defaultbehavior ; }	create a property definition .
public datetimeparseexception ( string message , charsequence parseddata , int errorindex , throwable cause ) { super ( message , cause ) ; this . parsedstring = parseddata . tostring ( ) ; this . errorindex = errorindex ; }	constructs a new exception with the specified message and cause .
public configurexmlattributecountdialog_nb ( xmlattributecount xmlattributecount ) { this . xmlattributecount = xmlattributecount ; initcomponents ( ) ; final iteratemodel numberoftagsiterator = xmlattributecount . getnumberofattributesiterator ( ) ; configureiteratemodel_nb2 . setstartat ( string . valueof ( numberoftagsiterator . getstartat ( ) ) ) ; configureiteratemodel_nb2 . setstopat ( string . valueof ( numberoftagsiterator . getstopat ( ) ) ) ; configureiteratemodel_nb2 . setincrement ( string . valueof ( numberoftagsiterator . getincrement ( ) ) ) ; configureiteratemodel_nb2 . setiteratestrategie ( numberoftagsiterator . getiteratestrategie ( ) ) ; list < string > names = arrays . aslist ( xmlattributecount . getnames ( ) ) ; configurestringlist_nb1 . setstringlist ( names ) ; }	creates new form configurecoerceiveparsingdialog_nb.
public void onmenudismissed ( ) { mreloadmenuitem = null ; }	notify the delegate that menu was dismissed .
public static thread consumeprocessoutputstream ( process self , outputstream output ) { thread thread = new thread ( new bytedumper ( self . getinputstream ( ) , output ) ) ; thread . start ( ) ; return thread ; }	gets the output stream from a process and reads it to keep the process from blocking due to a full output buffer.
public static angle greatcircleazimuth ( latlon p1 , latlon p2 ) { if ( ( p1 == null ) || ( p2 == null ) ) { throw new illegalargumentexception ( _str ) ; } double lat1 = p1 . getlatitude ( ) . radians ; double lon1 = p1 . getlongitude ( ) . radians ; double lat2 = p2 . getlatitude ( ) . radians ; double lon2 = p2 . getlongitude ( ) . radians ; if ( lat1 == lat2 && lon1 == lon2 ) return angle . zero ; if ( lon1 == lon2 ) return lat1 > lat2 ? angle . pos180 : angle . zero ; double y = math . cos ( lat2 ) * math . sin ( lon2 - lon1 ) ; double x = math . cos ( lat1 ) * math . sin ( lat2 ) - math . sin ( lat1 ) * math . cos ( lat2 ) * math . cos ( lon2 - lon1 ) ; double azimuthradians = math . atan2 ( y , x ) ; return double . isnan ( azimuthradians ) ? angle . zero : angle . fromradians ( azimuthradians ) ; }	computes the azimuth angle ( clockwise from north ) that points from the first location to the second location.
public void addalltagsof ( host h ) { list < tag > tags = h . gettags ( ) ; if ( tags . isempty ( ) ) return ; if ( mtaglist == null ) { mtaglist = new arraylist < tag > ( tags . size ( ) ) ; } mtaglist . addall ( tags ) ; }	adds all the tags from h to this host .
public static boolean isnumberswithpunctuation ( string token ) { boolean hasdigit = _bool ; int len = token . length ( ) ; for ( int i = _num ; i < len ; ++ i ) { char c = token . charat ( i ) ; hasdigit = hasdigit || character . isdigit ( c ) ; if ( ! ( character . isdigit ( c ) || characters . ispunctuation ( c ) ) ) { return _bool ; } } return hasdigit ; }	true if the input string contains at least one digit and 0 or more punctuation characters.
private boolean ispaintlineseperators ( jcomponent c ) { boolean paintlines = c instanceof jtextarea ; string globaloverride = system . getproperty ( _str ) ; if ( globaloverride != null && globaloverride . length ( ) > _num ) { paintlines = boolean . valueof ( globaloverride ) ; } boolean overrideproperty = ( boolean ) c . getclientproperty ( _str ) ; if ( overrideproperty != null ) { paintlines = overrideproperty ; } return paintlines ; }	test if we should also paint the line seperators .
public static db open ( datasource ds ) { try { return new db ( ds . getconnection ( ) ) ; } catch ( sqlexception e ) { throw convert ( e ) ; } }	create a new database instance using a data source.
@ override public void basicputpart3 ( entryeventimpl event , regionentry entry , boolean isinitialized , long lastmodified , boolean invokecallbacks , boolean ifnew , boolean ifold , object expectedoldvalue , boolean requireoldvalue ) { distributeupdate ( event , lastmodified , _bool , _bool , null , _bool ) ; super . basicputpart3 ( event , entry , isinitialized , lastmodified , invokecallbacks , ifnew , ifold , expectedoldvalue , requireoldvalue ) ; }	distribution and listener notification.
public languagerange ( string range ) { this . range = range . split ( _str ) ; full = range ; }	note range must be in lower case , this is not verified .
protected void removecontainer ( ) throws throwable { if ( containerid == null ) { return ; } senddeletecontainerrequest ( ) ; waitforpropertyvalue ( provisioningtasklink , mocktaskstate . class , _str , taskstate . taskstage . finished ) ; if ( ! ismocktarget ( ) ) { thread . sleep ( _num ) ; } verifycontainerdoesnotexist ( containerid ) ; }	remove the container previously created using createcontainer ( ).
public int size ( ) { return list . size ( ) ; }	returns the number of elements in this set ( its cardinality ) .
public transformerhandler newtransformerhandler ( templates templates ) throws transformerconfigurationexception { try { transformerimpl transformer = ( transformerimpl ) templates . newtransformer ( ) ; transformer . seturiresolver ( m_uriresolver ) ; transformerhandler th = ( transformerhandler ) transformer . getinputcontenthandler ( _bool ) ; return th ; } catch ( transformerconfigurationexception ex ) { if ( m_errorlistener != null ) { try { m_errorlistener . fatalerror ( ex ) ; return null ; } catch ( transformerconfigurationexception ex1 ) { throw ex1 ; } catch ( transformerexception ex1 ) { throw new transformerconfigurationexception ( ex1 ) ; } } throw ex ; } }	get a transformerhandler object that can process sax contenthandler events into a result , based on the templates argument .
public void addfield ( fieldref fref ) { mfieldrefs . add ( fref ) ; }	adds the field to the field list .
public string render ( valueexpr theexpr ) throws exception { reset ( ) ; theexpr . visit ( this ) ; return mbuffer . tostring ( ) ; }	return the rendering of the valueexpr object.
public void add ( final vector2d [ ] bloop ) throws mathillegalargumentexception { add ( new nestedloops ( bloop , tolerance ) ) ; }	add a loop in a tree .
@ notnull public static < t > list < t > aslist ( @ nullable final collection < ? > expression , @ notnull final class < t > elementclass ) { if ( ( expression == null ) || expression . isempty ( ) ) { return collections . emptylist ( ) ; } final list < t > result = new arraylist < t > ( ) ; for ( final object element : expression ) { final t toadd = as ( element , elementclass ) ; if ( toadd != null ) { result . add ( toadd ) ; } } return result ; }	converts collection to list of certain type.
private void startnewtransition ( ) { if ( ! hasbounds ( ) ) { return ; } mcurrenttrans = mtransgen . generatenexttransition ( mdrawablerect , mviewportrect ) ; melapsedtime = _num ; mlastframetime = system . currenttimemillis ( ) ; firetransitionstart ( mcurrenttrans ) ; }	generates and starts a transition .
@ override protected void makefinished ( ) { byte [ ] verify_data ; if ( serverhello . server_version [ _num ] == _num ) { verify_data = new byte [ _num ] ; computerverifydatatls ( _str , verify_data ) ; } else { verify_data = new byte [ _num ] ; computerverifydatasslv3 ( sslv3constants . client , verify_data ) ; } clientfinished = new finished ( verify_data ) ; send ( clientfinished ) ; if ( isresuming ) { session . lastaccessedtime = system . currenttimemillis ( ) ; status = finished ; } else { if ( serverhello . server_version [ _num ] == _num ) { computerreferenceverifydatatls ( _str ) ; } else { computerreferenceverifydatasslv3 ( sslv3constants . server ) ; } status = need_unwrap ; } }	creates and sends finished message.
public static file removeextension ( file file ) { string absolutepath = file . getabsolutepath ( ) ; if ( absolutepath . contains ( _str ) ) { return new file ( absolutepath . substring ( _num , absolutepath . lastindexof ( _str ) ) ) ; } else { return file ; } }	remove the last extension of file.
public void update ( ) { if ( bgisopaque ) { int w = math . max ( getsize ( ) . width , minwidth ) ; int h = math . max ( getsize ( ) . height , minheight ) ; offscr = createimage ( w , h ) ; if ( offscr == null ) return ; graphics g = offscr . getgraphics ( ) ; drawinto ( g ) ; repaint ( ) ; g . dispose ( ) ; } else { repaint ( ) ; } }	updates all changes in areas state and repaints component .
public static final int readint ( inputstream is ) throws ioexception { return ( ( ( _num & is . read ( ) ) << _num ) | ( _num & is . read ( ) ) ) ; }	reads a two byte integer value from an inputstream .
private void savedynamicactions ( facescontext context , statecontext statecontext , map < string , object > statemap ) { if ( logger . isloggable ( level . finest ) ) { logger . finest ( _str ) ; } list < componentstruct > actions = statecontext . getdynamicactions ( ) ; hashmap < string , uicomponent > componentmap = statecontext . getdynamiccomponents ( ) ; if ( actions != null ) { list < object > savedactions = new arraylist < > ( actions . size ( ) ) ; for ( componentstruct action : actions ) { uicomponent component = componentmap . get ( action . clientid ) ; if ( component == null && context . isprojectstage ( projectstage . development ) ) { logger . log ( level . warning , _str , action . clientid ) ; } if ( component != null ) { savedactions . add ( action . savestate ( context ) ) ; } } statemap . put ( dynamic_actions , savedactions ) ; } }	save the dynamic actions .
private instance generateexample ( instances format , random randomg , subspaceclusterdefinition cl , string cname ) { boolean makeinteger = cl . isinteger ( ) ; int num = - _num ; instance example = null ; int numatts = m_numattributes ; if ( getclassflag ( ) ) { numatts ++ ; } example = new denseinstance ( numatts ) ; example . setdataset ( format ) ; boolean [ ] attributes = cl . getattributes ( ) ; double [ ] minvalue = cl . getminvalue ( ) ; double [ ] maxvalue = cl . getmaxvalue ( ) ; double value ; int clusteri = - _num ; for ( int i = _num ; i < m_numattributes ; i ++ ) { if ( attributes [ i ] ) { clusteri ++ ; num ++ ; if ( isboolean ( i ) || isnominal ( i ) ) { if ( minvalue [ clusteri ] == maxvalue [ clusteri ] ) { value = minvalue [ clusteri ] ; } else { int numvalues = ( int ) ( maxvalue [ clusteri ] - minvalue [ clusteri ] + _num ) ; value = randomg . nextint ( numvalues ) ; value += minvalue [ clusteri ] ; } } else { value = randomg . nextdouble ( ) * ( maxvalue [ num ] - minvalue [ num ] ) + minvalue [ num ] ; if ( makeinteger ) { value = math . round ( value ) ; } } example . setvalue ( i , value ) ; } else { example . setmissing ( i ) ; } } if ( getclassflag ( ) ) { example . setclassvalue ( cname ) ; } return example ; }	generate an example of the dataset .
@ override public long skip ( long n ) { if ( n < _num ) { throw new illegalargumentexception ( _str + n ) ; } if ( idx >= charsequence . length ( ) ) { return - _num ; } int dest = ( int ) math . min ( charsequence . length ( ) , idx + n ) ; int count = dest - idx ; idx = dest ; return count ; }	skip the specified number of characters .
public defaultconsolepanel ( ) { setlayout ( new borderlayout ( _num , _num ) ) ; textpane = new jtextarea ( ) ; textpane . setrows ( _num ) ; textpane . seteditable ( _bool ) ; jscrollpane jp = new jscrollpane ( textpane ) ; add ( jp , borderlayout . center ) ; }	instantiates a new console panel .
public void push ( ) { level . add ( null ) ; cloned = _bool ; }	push a frame for a node.
private static void loadpluginsfromclassloader ( classloader classloader ) { serviceloader < gdsfactoryplugin > pluginloader = serviceloader . load ( gdsfactoryplugin . class , classloader ) ; for ( gdsfactoryplugin plugin : pluginloader ) { registerplugin ( plugin ) ; } }	load all existing plugins from the specified class loader .
public string redo ( ) { if ( ! canredo ( ) ) { return _str ; } m_ncurrenteditaction ++ ; undoaction undoaction = m_undostack . get ( m_ncurrenteditaction ) ; m_bneedsundoaction = _bool ; undoaction . redo ( ) ; m_bneedsundoaction = _bool ; return undoaction . getredomsg ( ) ; }	redo the last edit action performed on the network.
@ override public inetsocketaddress iplocal ( ) { socketchannel s = _channel ; if ( s != null ) { try { return ( inetsocketaddress ) s . getlocaladdress ( ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } } else { return null ; } }	returns the server inet address that accepted the request .
@ nonnull private static nodedisk findnodedisk ( string diskid , list < nodedisk > nodedisks , string nodename ) throws ioexception { nodedisk selected = null ; for ( nodedisk nodedisk : nodedisks ) { if ( diskid . equals ( nodedisk . getdiskrefid ( ) ) ) { selected = nodedisk ; break ; } } if ( selected == null ) { string message = format ( _str , nodename , diskid ) ; throw new abortexception ( message ) ; } if ( selected . getnodemountpoint ( ) == null ) { string message = format ( _str , nodename , diskid ) ; throw new abortexception ( message ) ; } return selected ; }	finds the disk definition from the given disks list that matches the given disk id .
private int stripmultipartheaders ( byte [ ] b , int offset ) { int i = _num ; for ( i = offset ; i < b . length ; i ++ ) { if ( b [ i ] == _str && b [ ++ i ] == _str && b [ ++ i ] == _str && b [ ++ i ] == _str ) break ; } return i + _num ; }	it returns the offset separating multipart file headers from the file ' s data .
void seek ( int position ) throws ioexception { mdexfile . seek ( position ) ; }	seeks the dex file to the specified absolute position .
@ override public list < column > columns ( ) { return columnlist ; }	returns the list of columns.
public static void writefloat ( dataoutputstream dos , boolean isbigendian , float val ) throws ioexception { if ( ! isbigendian ) { writelittleendianfloat ( dos , val ) ; } else { dos . writefloat ( val ) ; } }	write a float from the output stream , byte - swapping as necessary.
public void testflipbitpositiveinside1 ( ) { byte abytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = _num ; int number = _num ; byte rbytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , - _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . flipbit ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	flipbit ( int n ) inside a positive number.
public static instruction _osrhelper ( instruction barrier , generationcontext gc ) { instruction inst = osrpoint . create ( yieldpoint_osr , null , _num ) ; gc . saveosrbarrierforinst ( barrier , inst ) ; return inst ; }	creates an osr point instruction with its dependent osrbarrier which provides type and variable information.
protected void initializestate ( s current ) { initializationutils . initialize ( current ) ; if ( current . documentexpirationtimemicros <= _num ) { current . documentexpirationtimemicros = serviceutils . computeexpirationtime ( serviceutils . default_doc_expiration_time_micros ) ; } }	initialize state with defaults .
@ suppresswarnings ( _str ) public inputstream fetchvolumestats ( final argument argument , final map < string , object > keymap , int index ) throws vnxfilepluginexception { _logger . info ( _str ) ; inputstream istream = null ; list < querystats > statlist = new arraylist < querystats > ( ) ; try { set < string > movers = ( set < string > ) keymap . get ( vnxfileconstants . moverlist ) ; if ( null != movers && ! movers . isempty ( ) ) { for ( string moverid : movers ) { querystats querystats = new querystats ( ) ; volumestatssetqueryparams params = new volumestatssetqueryparams ( ) ; params . setstatsset ( volumestatssettype . all ) ; params . setmover ( moverid ) ; querystats . setvolumestats ( params ) ; statlist . add ( querystats ) ; } istream = _vnxfileinputrequestbuilder . getmultirequestquerystatspacket ( statlist ) ; } else { _logger . error ( _str ) ; } } catch ( jaxbexception jaxbexception ) { throw new vnxfilepluginexception ( _str , jaxbexception . getcause ( ) ) ; } return istream ; }	create volume stats xml request query and returns a stream after marshalling .
private static boolean isdirectory ( url url ) { string file = url . getfile ( ) ; return ( file . length ( ) > _num && file . charat ( file . length ( ) - _num ) == _str ) ; }	determines if the url is pointing to a directory .
@ override public final string readutf ( ) throws ioexception { return dis . readutf ( ) ; }	read utf counted string .
@ nullable public static networkparameters fromid ( string id ) { if ( id . equals ( id_mainnet ) ) { return mainnetparams . get ( ) ; } else if ( id . equals ( id_testnet ) ) { return testnet3params . get ( ) ; } else if ( id . equals ( id_unittestnet ) ) { return unittestparams . get ( ) ; } else { return null ; } }	returns the network parameters for the given string id or null if not recognized .
final synchronized void releasesocket ( ) { running = _bool ; sender . interrupt ( ) ; outboundmessages . clear ( ) ; if ( socket != null ) { socket . close ( ) ; socket = null ; } maximumtransmissionunit = _num ; }	stops the sender and receiver threads and closes the socket used for sending and receiving datagrams .
public boolean addpart ( pdupart part ) { if ( null == part ) { throw new nullpointerexception ( ) ; } putparttomaps ( part ) ; return mparts . add ( part ) ; }	appends the specified part to the end of this body .
public string codeowner ( list < codeowner > codeowners ) { long currentunix = system . currenttimemillis ( ) / _num ; double best = _num ; string owner = _str ; for ( codeowner codeowner : codeowners ) { double age = ( currentunix - codeowner . getmostrecentunixcommittimestamp ( ) ) / _num / _num ; double calc = codeowner . getnolines ( ) / math . pow ( ( age ) , _num ) ; if ( calc > best ) { best = calc ; owner = codeowner . getname ( ) ; } } return owner ; }	determines who owns a piece of code weighted by time based on current second ( ie time now ) nb if a commit is very close to this time it will always win.
public map read ( ssotoken token , string objname ) throws smsexception , ssoexception { if ( objname == null || objname . length ( ) == _num ) { throw new illegalargumentexception ( _str ) ; } string objkey = objname . tolowercase ( ) ; map attrmap = null ; mrwlock . readrequest ( ) ; try { string filepath = mnamemap . getproperty ( objkey ) ; if ( filepath == null ) { if ( mdebug . messageenabled ( ) ) { mdebug . message ( _str + objname + _str ) ; } } else { file filehandle = new file ( filepath ) ; properties props = null ; try { props = loadproperties ( filehandle , objname ) ; } catch ( servicenotfoundexception e ) { } if ( props != null ) { attrmap = new caseinsensitivehashmap ( ) ; enumeration keys = props . propertynames ( ) ; while ( keys . hasmoreelements ( ) ) { string key = ( string ) keys . nextelement ( ) ; string vals = props . getproperty ( key ) ; if ( ( vals != null ) && ( vals . length ( ) > _num ) ) { attrmap . put ( key , tovalset ( key , vals ) ) ; } } } } } finally { mrwlock . readdone ( ) ; } return attrmap ; }	reads in attributes of a configuration object .
public static double parsedouble ( string s ) { s = s . trim ( ) ; int length = s . length ( ) ; if ( length == _num ) { throw invalidreal ( s , _bool ) ; } char last = s . charat ( length - _num ) ; if ( last == _str || last == _str ) { return parsename ( s , _bool ) ; } stringexponentpair info = initialparse ( s , length , _bool ) ; if ( info . infinity || info . zero ) { return info . specialvalue ( ) ; } double result = parsedblimpl ( info . s , ( int ) info . e ) ; if ( double . doubletolongbits ( result ) == _num ) { throw invalidreal ( s , _bool ) ; } return info . negative ? - result : result ; }	returns the closest double value to the real number in the string .
public byte readbyte ( ) throws ioexception { byte v = datainput . readbyte ( ) ; offset += _num ; available -= _num ; return v ; }	reads a single byte .
public static imultipoint [ ] randompoints ( int n , int d ) { imultipoint points [ ] = new imultipoint [ n ] ; for ( int i = _num ; i < n ; i ++ ) { stringbuilder sb = new stringbuilder ( ) ; for ( int j = _num ; j < d ; j ++ ) { sb . append ( rgen . nextdouble ( ) ) ; if ( j < d - _num ) { sb . append ( _str ) ; } } points [ i ] = new hyperpoint ( sb . tostring ( ) ) ; } return points ; }	generate array of n d - dimensional points whose coordinates are values in the range 0.
private string verifyrestorecode ( string restorecode , string code ) { if ( code == null ) { return _str ; } if ( restorecode == null ) { return _str ; } boolean validcode = passwordmanager . matches ( code , restorecode ) ; return validcode ? null : _str + code + _str + restorecode + _str ; }	verifies a user supplied restore code against the stored restore code.
public static void appendpaddedinteger ( stringbuffer buf , long value , int size ) { int intvalue = ( int ) value ; if ( intvalue == value ) { appendpaddedinteger ( buf , intvalue , size ) ; } else if ( size <= _num ) { buf . append ( long . tostring ( value ) ) ; } else { if ( value < _num ) { buf . append ( _str ) ; if ( value != long . min_value ) { value = - value ; } else { for ( ; size > _num ; size -- ) { buf . append ( _str ) ; } buf . append ( _str ) ; return ; } } int digits = ( int ) ( math . log ( value ) / log_10 ) + _num ; for ( ; size > digits ; size -- ) { buf . append ( _str ) ; } buf . append ( long . tostring ( value ) ) ; } }	converts an integer to a string , prepended with a variable amount of ' 0 ' pad characters , and appends it to the given buffer.
@ override public void flush ( ) { if ( ! queue . isempty ( ) ) { list < alertstreamevent > events = new arraylist < > ( ) ; queue . drainto ( events ) ; events . foreach ( null ) ; log . info ( _str , events . size ( ) ) ; } lastflushtime . set ( system . currenttimemillis ( ) ) ; }	flush will be called in synchronous way like stormbolt . execute ( ) as storm outputcollector is not thread - safe.
@ override public void addundopoint ( ) { file tempfile ; objectoutputstream oos ; if ( ! isundoenabled ( ) ) { return ; } if ( getinstances ( ) != null ) { try { tempfile = file . createtempfile ( _str , null ) ; tempfile . deleteonexit ( ) ; oos = new objectoutputstream ( new bufferedoutputstream ( new fileoutputstream ( tempfile ) ) ) ; oos . writeobject ( getinstances ( ) ) ; oos . flush ( ) ; oos . close ( ) ; m_undolist . add ( tempfile ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } }	adds an undo point to the undo history , if the undo support is enabled.
public final void addchildnode ( rowregexexprnode childnode ) { childnodes . add ( childnode ) ; }	adds a child node .
private list < string > makelist ( final string ... strings ) { final list < string > result = new arraylist < > ( ) ; for ( string string : strings ) { result . add ( string ) ; } return result ; }	builds a list from the parameters .
public int numberofshardswithstate ( shardroutingstate ... states ) { int count = _num ; for ( shardrouting shardentry : this ) { for ( shardroutingstate state : states ) { if ( shardentry . state ( ) == state ) { count ++ ; } } } return count ; }	determine the number of shards with a specific state.
@ override public void notifycommit ( final long committime ) { lock . lock ( ) ; try { updatereleasetimeforbarecommit ( committime ) ; } finally { lock . unlock ( ) ; } }	the basic implementation advances the release time periodically as commits occur even when there are no transactions in use.
public static int showyesnocancelquestion ( final component parent , final string msg ) { return joptionpane . showconfirmdialog ( isiconified ( parent ) ? null : parent , msg , system . getproperty ( default_window_title_property ) , joptionpane . yes_no_cancel_option , joptionpane . question_message ) ; }	shows a question the user can answer with yes / no / cancel .
public static string quantityplnouncreature ( final int quantity , final string noun ) { if ( noun . equals ( _str ) ) { final string end = plnouncreature ( quantity , noun ) ; return integer . tostring ( quantity ) + _str + end ; } return quantityplnoun ( quantity , noun ) ; }	returns either the plural or singular form of the given noun , depending on the quantity ; also prefixes the quantity . method to prevent collision of items and creatures.
static int copybytes ( outputstream os , inputstream is , byte [ ] iobuffer , int maxsize ) throws ioexception { int totalsize = _num ; while ( totalsize < maxsize ) { int rc = is . read ( iobuffer , _num , math . min ( maxsize - totalsize , iobuffer . length ) ) ; if ( rc == - _num ) { break ; } os . write ( iobuffer , _num , rc ) ; totalsize += rc ; } return totalsize ; }	pumps all the bytes ( but no more that maxsize ) from given input stream through iobuffer to given output stream and returns number of moved bytes .
void composemessage ( final mail mail , final string textcontent , final string htmlcontent , final map < string , byte [ ] > attachments , final list < string > mailtemplatechain , final string shopcode , final string locale , final string templatename ) throws messagingexception , classnotfoundexception , ioexception { if ( textcontent == null || htmlcontent == null ) { if ( textcontent != null ) { mail . settextversion ( textcontent ) ; } if ( htmlcontent != null ) { mail . sethtmlversion ( htmlcontent ) ; inlineresources ( mail , htmlcontent , mailtemplatechain , shopcode , locale , templatename ) ; addattachments ( mail , attachments ) ; } } else { mail . settextversion ( textcontent ) ; mail . sethtmlversion ( htmlcontent ) ; inlineresources ( mail , htmlcontent , mailtemplatechain , shopcode , locale , templatename ) ; addattachments ( mail , attachments ) ; } }	fill mail message . at least one of the templates must be given .
private void handlelaunchmessageevent ( messageevent messageevent ) { datamap datamap = datamap . frombytearray ( messageevent . getdata ( ) ) ; boolean relaunchifrunning = datamap . getboolean ( key_start_activity_relaunch , _bool ) ; datamap bundledata = datamap . getdatamap ( key_start_activity_bundle ) ; string activityname = datamap . getstring ( key_start_activity_name ) ; bundle bundle = null ; if ( bundledata != null ) { bundle = bundledata . tobundle ( ) ; } if ( activityname == null ) { for ( wearconsumer consumer : mwearconsumers ) { consumer . onwearableapplicationlaunchrequestreceived ( bundle , relaunchifrunning ) ; } } else { try { if ( ! textutils . isempty ( activityname ) ) { class < ? > targetactivity = class . forname ( activityname ) ; intent intent = new intent ( mcontext , targetactivity ) ; intent . setflags ( intent . flag_activity_new_task ) ; if ( bundle != null ) { intent . putextras ( bundle ) ; } if ( ! mappforeground || relaunchifrunning ) { mcontext . startactivity ( intent ) ; } } else { log . e ( tag , _str ) ; } } catch ( classnotfoundexception e ) { log . e ( tag , _str , e ) ; } } }	handles the special message to launch an activity .
@ override public void close ( ) throws ioexception { closed = _bool ; def . end ( ) ; in . close ( ) ; }	closes the underlying input stream and discards any remaining uncompressed data .
public static string escapecoloninstring ( string str ) { if ( str != null ) { if ( str . indexof ( _str ) >= _num ) { str = str . replaceall ( _str , _str ) ; } } return str ; }	escapes colons ( " : " ) in the supplied string to " & # 58 ; ".
protected void teardown ( ) throws exception { file file ; file = new file ( m_exportfilenamedata ) ; if ( file . exists ( ) ) file . delete ( ) ; m_exportfilenamedata = null ; super . teardown ( ) ; }	called by junit after each test method.
private static saxparserfactory createsaxparserfactory ( ) { try { saxparserfactory factory = saxparserfactory . newinstance ( ) ; try { saxparserfactory securefactory = securegenericxmlfactory . getsaxparserfactory ( factory ) ; securefactory . newsaxparser ( ) ; factory = securefactory ; } catch ( parserconfigurationexception e ) { } factory . setnamespaceaware ( _bool ) ; return factory ; } catch ( saxexception e ) { throw new illegalstateexception ( _str , e ) ; } }	creates a secure sax parser , which is secured against xxe attacks .
public static void saveasxml ( nsobject root , file out ) throws ioexception { file parent = out . getparentfile ( ) ; if ( ! parent . exists ( ) && ! parent . mkdirs ( ) ) { throw new ioexception ( _str ) ; } fileoutputstream fous = new fileoutputstream ( out ) ; saveasxml ( root , fous ) ; fous . close ( ) ; }	saves a property list with the given object as root into a xml file .
public static boolean containschroot ( string zkhost ) { return zkhost . contains ( _str ) ; }	validates if zkhost contains a chroot.
public final void lazyset ( int newvalue ) { unsafe . putorderedint ( this , valueoffset , newvalue ) ; }	eventually sets to the given value .
public feature ( string line , map cpstr2int , map lbstr2int , map fmap ) { stringtokenizer strtok = new stringtokenizer ( line , _str ) ; int len = strtok . counttokens ( ) ; string stridstr = strtok . nexttoken ( ) ; int idx = integer . parseint ( strtok . nexttoken ( ) ) ; float val = _num ; double wgt = double . parsedouble ( strtok . nexttoken ( ) ) ; stringtokenizer stridtok = new stringtokenizer ( stridstr , _str ) ; string prefix = stridtok . nexttoken ( ) ; if ( prefix . comparetoignorecase ( _str ) == _num ) { integer yint = ( integer ) lbstr2int . get ( stridtok . nexttoken ( ) ) ; integer ypint = ( integer ) lbstr2int . get ( stridtok . nexttoken ( ) ) ; if ( yint != null && ypint != null ) { efeature1init ( yint . intvalue ( ) , ypint . intvalue ( ) ) ; } } else if ( prefix . comparetoignorecase ( _str ) == _num ) { integer yint = ( integer ) lbstr2int . get ( stridtok . nexttoken ( ) ) ; integer cpint = ( integer ) cpstr2int . get ( stridtok . nexttoken ( ) ) ; if ( yint != null && cpint != null ) { sfeature1init ( yint . intvalue ( ) , cpint . intvalue ( ) ) ; } } this . idx = idx ; this . val = val ; this . wgt = wgt ; strid2idxadd ( fmap ) ; }	instantiates a new feature .
public static int patchfast ( inputstream oldinputstream , inputstream diffinputstream , file newfile ) throws ioexception { if ( oldinputstream == null ) { return return_old_file_err ; } if ( newfile == null ) { return return_new_file_err ; } if ( diffinputstream == null ) { return return_diff_file_err ; } byte [ ] oldbytes = bsutil . inputstreamtobyte ( oldinputstream ) ; byte [ ] diffbytes = bsutil . inputstreamtobyte ( diffinputstream ) ; byte [ ] newbytes = patchfast ( oldbytes , oldbytes . length , diffbytes , diffbytes . length , _num ) ; outputstream newoutputstream = new fileoutputstream ( newfile ) ; try { newoutputstream . write ( newbytes ) ; } finally { newoutputstream . close ( ) ; } return return_success ; }	this patch method is fast , but using more memory . memory size = oldbuf + diffbuf + newbuf.
public static byte [ ] readfullynoclose ( inputstream in ) throws ioexception { bytearrayoutputstream bytes = new bytearrayoutputstream ( ) ; byte [ ] buffer = new byte [ _num ] ; int count ; while ( ( count = in . read ( buffer ) ) != - _num ) { bytes . write ( buffer , _num , count ) ; } return bytes . tobytearray ( ) ; }	returns a byte [ ] containing the remainder of ' in ' .
public contentstorage ( contentstoragebo contentstoragebo , list < genericpackage > genericpackagelist , list < essencecontainerdata > essencecontainerdatalist ) { this . contentstoragebo = contentstoragebo ; this . genericpackagelist = collections . unmodifiablelist ( genericpackagelist ) ; this . essencecontainerdatalist = collections . unmodifiablelist ( essencecontainerdatalist ) ; }	instantiates a new contentstorage object.
public scaleiovolume queryvolume ( string volid ) throws exception { clientresponse response = get ( uri . create ( scaleioconstants . getvolumeuri ( volid ) ) ) ; return getresponseobject ( scaleiovolume . class , response ) ; }	query the volume details.
public void removeeventlistener ( sipdialogeventlistener oldlistener ) { eventlisteners . remove ( oldlistener ) ; }	removed an event listener from this dialog .
protected static object primitivearrayput ( object self , int idx , object newvalue ) { array . set ( self , normaliseindex ( idx , array . getlength ( self ) ) , newvalue ) ; return newvalue ; }	implements the setat ( int idx ) method for primitive type arrays .
public void toaxisangle ( vector4f output ) { if ( getw ( ) > _num ) { normalise ( ) ; } float angle = _num * ( float ) math . todegrees ( math . acos ( getw ( ) ) ) ; float x ; float y ; float z ; float s = ( float ) math . sqrt ( _num - getw ( ) * getw ( ) ) ; if ( s < _num ) { x = points [ _num ] ; y = points [ _num ] ; z = points [ _num ] ; } else { x = points [ _num ] / s ; y = points [ _num ] / s ; z = points [ _num ] / s ; } output . points [ _num ] = x ; output . points [ _num ] = y ; output . points [ _num ] = z ; output . points [ _num ] = angle ; }	get an axis angle representation of this quaternion .
private qnamemap < bindingexpression > processbindingattributes ( node node ) { qnamemap < bindingexpression > attributebindings = null ; for ( iterator < qname > i = node . getattributenames ( ) ; i != null && i . hasnext ( ) ; ) { qname qname = i . next ( ) ; string value = ( string ) node . getattributevalue ( qname ) ; bindingexpression be = textparser . parsebindingexpression ( value , node . beginline ) ; if ( be != null ) { if ( attributebindings == null ) { attributebindings = new qnamemap < bindingexpression > ( ) ; } attributebindings . put ( qname , be ) ; i . remove ( ) ; } } return attributebindings ; }	collects / processes binding attributes from the node , and then removes them from the node .
public void load ( string filename ) throws ioexception { bufferedreader bfr = new bufferedreader ( new inputstreamreader ( new fileinputstream ( filename ) , _str ) ) ; if ( blist == null ) blist = new vector ( default_increment , default_increment ) ; string line = bfr . readline ( ) ; if ( line . indexof ( _str ) != - _num ) { line = line . substring ( _num ) ; string [ ] parts = new string [ _num ] ; parts = line . split ( _str , _num ) ; fromdir = parts [ _num ] ; fromext = parts [ _num ] ; } else if ( ! ( line . matches ( _str ) ) ) add ( line ) ; while ( ( line = bfr . readline ( ) ) != null ) { if ( ! ( line . matches ( _str ) ) ) add ( line ) ; } }	read the basenamelist from a file.
private void verifyregisterdefs ( string where ) { defuse . computedu ( this ) ; for ( register r = regpool . getfirstsymbolicregister ( ) ; r != null ; r = r . getnext ( ) ) { if ( r . isphysical ( ) ) continue ; if ( r . uselist != null ) { if ( r . deflist == null ) { printinstructions ( ) ; verror ( where , _str + r + _str ) ; } } } }	verify that every non - physical , non - parameter symbolic register that has a use also has at least one def.
private static void findsnap ( collection < constraintwidget > widgets , constraintwidget widget , snapcandidate candidate , boolean checkhorizontal ) { arraylist < constraintanchor > anchorssource = widget . getanchors ( ) ; for ( constraintwidget w : widgets ) { if ( w == widget ) { continue ; } arraylist < constraintanchor > anchorstarget = w . getanchors ( ) ; for ( constraintanchor as : anchorssource ) { if ( checkhorizontal && as . isverticalanchor ( ) ) { continue ; } else if ( ! checkhorizontal && ! as . isverticalanchor ( ) ) { continue ; } for ( constraintanchor at : anchorstarget ) { snapcheck ( as , at , candidate , connection_slope ) ; } } } }	utility function iterating through the anchors of a widget , comparing their position with all the anchors of other widgets , and calling the snapcheck ( ) function .
protected string padstring ( string s , int length , boolean left ) { string result ; int i ; result = s ; for ( i = s . length ( ) ; i < length ; i ++ ) { if ( left ) { result = _str + result ; } else { result = result + _str ; } } if ( ( length > _num ) && ( result . length ( ) > length ) ) { result = result . substring ( _num , length ) ; } return result ; }	pads the given string until it reaches the given length , if longer cuts it down.
void recomposekeys ( keydeclaration keydecl ) { m_keydecls . addelement ( keydecl ) ; }	recompose the key declarations .
public < t > jsonarray < t > createlistdtofromjson ( reader json , class < t > dtointerface ) throws ioexception { final dtoprovider < t > dtoprovider = getdtoprovider ( dtointerface ) ; final list < jsonelement > list ; try { list = gson . fromjson ( json , listtypecache . get ( jsonelement . class ) ) ; } catch ( jsonsyntaxexception e ) { final throwable cause = e . getcause ( ) ; if ( cause instanceof ioexception ) { throw ( ioexception ) cause ; } throw e ; } final list < t > result = new arraylist < > ( list . size ( ) ) ; for ( jsonelement e : list ) { result . add ( dtoprovider . fromjson ( e ) ) ; } return new jsonarrayimpl < > ( result ) ; }	parses the json data from the specified reader into list of objects of the specified type .
private view fillfromtop ( int nexttop ) { mfirstposition = math . min ( mfirstposition , - _num ) ; mfirstposition = math . min ( mfirstposition , mitemcount - _num ) ; if ( mfirstposition < _num ) { mfirstposition = _num ; } return filldown ( mfirstposition , nexttop ) ; }	fills the list from top to bottom , starting with mfirstposition.
public void connectionopen ( ) { lock . lock ( ) ; try { log . info ( _str ) ; connectionopen = _bool ; } finally { lock . unlock ( ) ; } }	called to indicate the connection has been opened and messages can now be generated for the client .
public static float rotatey ( float px , float py , float cx , float cy , float angleindegrees ) { double angle = math . toradians ( angleindegrees ) ; return ( float ) ( math . sin ( angle ) * ( px - cx ) + math . cos ( angle ) * ( py - cy ) + cy ) ; }	rotate point p around center point c .
public void list ( printstream out ) { properties . list ( out ) ; }	prints the contents of this preference store to the given print stream .
protected layerpane findselectedpane ( ) { for ( layerpane pane : getpanes ( ) ) { if ( pane . isselected ( ) ) { return pane ; } } return null ; }	find the selected layerpane in the current layerpane list.
private final void scalenoisearray ( final int sealevel ) { for ( int x = _num ; x < x_sections ; x ++ ) { for ( int z = _num ; z < z_sections ; z ++ ) { for ( int y = _num ; y < y_sections ; y ++ ) { this . rawdensity [ x ] [ y ] [ z ] *= max_elev ; this . rawdensity [ x ] [ y ] [ z ] += sealevel ; } } } }	if rawdensity is ranged from - 1 to 1 , use this to scale it up.
public object [ ] toarray ( ) { arraylist < e > al = new arraylist < e > ( ) ; for ( node < e > p = first ( ) ; p != null ; p = succ ( p ) ) { e item = p . item ; if ( item != null ) al . add ( item ) ; } return al . toarray ( ) ; }	returns an array containing all of the elements in this queue , in proper sequence.
public microservicesrunner ( int ... ports ) { configuretransport ( ports ) ; }	creates a microservicesrunner instance which will be used for deploying microservices.
public static boolean deletecontents ( file directory ) { file [ ] files = directory . listfiles ( ) ; boolean success = _bool ; if ( files != null ) { for ( file file : files ) { success &= deleterecursively ( file ) ; } } return success ; }	deletes all files and subdirectories in directory ( doesn ' t delete the directory passed as parameter ) .
private void handleresponse ( avsresponse response ) { meventmanager . post ( new commandevent ( commandevent . type_command_searching , keyword_alexa ) ) ; if ( response != null ) { for ( int i = response . size ( ) - _num ; i >= _num ; i -- ) { if ( response . get ( i ) instanceof avsreplaceallitem || response . get ( i ) instanceof avsreplaceenqueueditem ) { mavsqueue . clear ( ) ; response . remove ( i ) ; } } timber . i ( _str , response . size ( ) ) ; mavsqueue . addall ( response ) ; } checkqueue ( ) ; }	handle the response sent back from alexa ' s parsing of the intent , these can be any of the avsitem types ( play , speak , stop , clear , listen ).
public static list < string > tolist ( charsequence self ) { string s = self . tostring ( ) ; int size = s . length ( ) ; list < string > answer = new arraylist < string > ( size ) ; for ( int i = _num ; i < size ; i ++ ) { answer . add ( s . substring ( i , i + _num ) ) ; } return answer ; }	converts the given charsequence into a list of strings of one character .
void appendarraygenerictype ( stringbuilder sb , type [ ] types ) { if ( types . length > _num ) { appendgenerictype ( sb , types [ _num ] ) ; for ( int i = _num ; i < types . length ; i ++ ) { sb . append ( _str ) ; appendgenerictype ( sb , types [ i ] ) ; } } }	appends names of the specified array classes to the buffer.
public void checkreinitfile ( final boolean needreinit ) throws ioexception { file bootmodefile = new file ( rootdir , constants . startupmode ) ; if ( ! needreinit ) { log . info ( _str ) ; if ( bootmodefile . exists ( ) ) { bootmodefile . delete ( ) ; } return ; } if ( ! bootmodefile . exists ( ) ) { setdbstartupmodeasrestorereinit ( rootdir ) ; } chown ( bootmodefile , backupconstants . storageos_user , backupconstants . storageos_group ) ; log . info ( _str , bootmodefile . getabsolutepath ( ) ) ; }	checks reinit file according to argument needreinit.
public void readdot ( reader input ) { dotparser dp = new dotparser ( input , m_nodes , m_edges ) ; graphid = dp . parse ( ) ; setappropriatenodesize ( ) ; if ( m_le != null ) { m_le . setnodesize ( paddednodewidth , nodeheight ) ; jbtlayout . setenabled ( _bool ) ; layoutgraph ( ) ; } }	dot reader < br > reads a graph description in dot format from a string.
private void notifyallentity ( ) { log . printconcatline ( super . getname ( ) , _str ) ; signalshutdown ( reslist ) ; signalshutdown ( gislist ) ; reslist . clear ( ) ; gislist . clear ( ) ; }	tells all registered entities about the end of simulation .
public synchronized boolean hasalerts ( ) { if ( alerts == null ) { return _bool ; } return ! alerts . isempty ( ) ; }	tells whether or not this history reference has alerts .
public void testcomparetopospos1 ( ) { byte abytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = _num ; int bsign = _num ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; assertequals ( _num , anumber . compareto ( bnumber ) ) ; }	compareto ( biginteger a ).
protected collection < ? extends annotationmirror > replacepolyall ( collection < ? extends annotationmirror > annos ) { set < annotationmirror > returnannos = annotationutils . createannotationset ( ) ; for ( annotationmirror top : gettopannotations ( ) ) { annotationmirror annotationinhierarchy = findannotationinhierarchy ( annos , top ) ; if ( annotationinhierarchy != null ) { returnannos . add ( annotationinhierarchy ) ; } } return returnannos ; }	returns a new set that is the passed set , but polyall has been replaced by a polymorphic qualifiers , for hierarchies that do not have an annotation in the set .
public synchronized void resetinputs ( ) throws ioexception { source . printstatistics ( _str ) ; setconfig ( config , source ) ; source . resetinputs ( ) ; numdocscreated . set ( _num ) ; resetleftovers ( ) ; }	reset inputs so that the test run would behave , input wise , as if it just started .
public void removematchingcoupling ( coupling < ? > toremove ) { for ( coupling < ? > coupling : getcouplings ( ) ) { boolean consumersmatch = attributesmatch ( coupling . getconsumer ( ) , toremove . getconsumer ( ) ) ; boolean producersmatch = attributesmatch ( coupling . getproducer ( ) , toremove . getproducer ( ) ) ; if ( consumersmatch && producersmatch ) { removecoupling ( coupling ) ; } } }	remove coupling ( if any ) that is essentially a copy of the supplied coupling .
public string toshortstring ( ) { stringbuilder sb = new stringbuilder ( ) ; if ( xroadinstance != null ) { sb . append ( xroadinstance ) ; } for ( string part : getfieldsforstringformat ( ) ) { if ( part != null ) { if ( sb . length ( ) > _num ) { sb . append ( _str ) ; } sb . append ( part ) ; } } return sb . tostring ( ) ; }	returns short string representation of the identifier that is more suitable for user interface usage than output of the tostring ( ) method .
private boolean checkpattern ( ) { if ( pattern == null ) { return _bool ; } char leftseparator = getleftseparator ( ) ; char rightseparator = getrightseparator ( ) ; stack < character > separatorstack = new stack < character > ( ) ; for ( int i = _num ; i < pattern . length ( ) ; i ++ ) { char cur = pattern . charat ( i ) ; if ( cur == leftseparator ) { separatorstack . push ( cur ) ; } else if ( cur == rightseparator ) { if ( ! separatorstack . isempty ( ) && ( separatorstack . pop ( ) == leftseparator ) ) { continue ; } else { return _bool ; } } } return separatorstack . isempty ( ) ; }	check if the pattern has legal separators.
public static sqlitedatabase openorcreatedatabase ( file file , cursorfactory factory ) { return openorcreatedatabase ( file . getpath ( ) , factory ) ; }	equivalent to opendatabase ( file.
public wildcard ( string pattern , int regexpoptions ) { this . regexpoptions = regexpoptions ; regexp = pattern . compile ( wildcardtoregex ( pattern ) , regexpoptions ) ; shortcut = extractshortcut ( pattern ) ; }	initializes a wildcard with the given search pattern and options .
private string local_number ( ) throws parseexception { stringbuffer s = new stringbuffer ( ) ; if ( debug ) dbg_enter ( _str ) ; try { int lc = _num ; while ( lexer . hasmorechars ( ) ) { char la = lexer . lookahead ( _num ) ; if ( la == _str || la == _str || la == _str || la == _str || la == _str || la == _str || lexer . ishexdigit ( la ) ) { lexer . consume ( _num ) ; s . append ( la ) ; lc ++ ; } else if ( lc > _num ) break ; else throw createparseexception ( _str + la ) ; } return s . tostring ( ) ; } finally { if ( debug ) dbg_leave ( _str ) ; } }	parser for the local phone # .
private static void appenddefaultvalue ( stringbuilder sb , fieldtype fieldtype , object defaultvalue ) { if ( fieldtype . isescapeddefaultvalue ( ) ) { appendescapedword ( sb , defaultvalue . tostring ( ) ) ; } else { sb . append ( defaultvalue ) ; } }	output the sql type for the default value for the type .
public metadatablockdatapicture ( bytebuffer rawdata ) throws ioexception , invalidframeexception { initfrombytebuffer ( rawdata ) ; }	initialize metablockdatapicture from bytebuffer.
public void previous ( ) { if ( current ( ) == null ) { return ; } m_currentsearchindex -- ; m_isbeforefirst = _bool ; m_isafterlast = _bool ; if ( m_currentsearchindex < _num ) { m_currentsearchindex = m_reducedresults . size ( ) - _num ; m_isbeforefirst = _bool ; } }	moves search result iteration to the previous search result .
@ nullable public static method findmethod ( class c , string name , object ... params ) { class [ ] paramtypes = getparamtypes ( params ) ; method method = null ; try { method = c . getdeclaredmethod ( name , paramtypes ) ; } catch ( nosuchmethodexception e ) { try { method = c . getmethod ( name , paramtypes ) ; } catch ( nosuchmethodexception e1 ) { } } if ( method != null ) method . setaccessible ( _bool ) ; return method ; }	searches for a method by its name and arguments .
public void testposzero ( ) { byte abytes [ ] = { - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num } ; int asign = _num ; int bsign = _num ; byte rbytes [ ] = { _num , - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . or ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	or for a positive number and zero.
public boolean closeallsessions ( ) { while ( existssession ( ) ) { sessioneditor sessioneditor = getfrontmostsessioneditor ( ) ; sessioneditorworkbench workbench = sessioneditor . getsessionworkbench ( ) ; sessionwrapper wrapper = workbench . getsessionwrapper ( ) ; if ( ! wrapper . issessionchanged ( ) ) { closefrontmostsession ( ) ; continue ; } string name = sessioneditor . getname ( ) ; int ret = joptionpane . showconfirmdialog ( joptionutils . centeringcomp ( ) , _str + name + _str , _str , joptionpane . yes_no_cancel_option ) ; if ( ret == joptionpane . no_option ) { closefrontmostsession ( ) ; continue ; } else if ( ret == joptionpane . cancel_option ) { return _bool ; } savesessionasaction action = new savesessionasaction ( ) ; action . actionperformed ( new actionevent ( this , actionevent . action_performed , _str ) ) ; if ( ! action . issaved ( ) ) { int ret2 = joptionpane . showconfirmdialog ( joptionutils . centeringcomp ( ) , _str , _str , joptionpane . ok_cancel_option ) ; if ( ret2 == joptionpane . cancel_option ) { return _bool ; } } closefrontmostsession ( ) ; } return _bool ; }	queries the user as to whether they would like to save their sessions .
private void removenonvisibleviews ( final int offset ) { int childcount = getchildcount ( ) ; if ( mlastitemposition != madapter . getcount ( ) - _num && childcount > _num ) { view firstchild = getchildat ( _num ) ; while ( firstchild != null && getchildbottom ( firstchild ) + offset < _num ) { removeviewinlayout ( firstchild ) ; childcount -- ; mcacheditemviews . addlast ( firstchild ) ; mfirstitemposition ++ ; mlisttopoffset += getchildheight ( firstchild ) ; if ( childcount > _num ) { firstchild = getchildat ( _num ) ; } else { firstchild = null ; } } } if ( mfirstitemposition != _num && childcount > _num ) { view lastchild = getchildat ( childcount - _num ) ; while ( lastchild != null && getchildtop ( lastchild ) + offset > getheight ( ) ) { removeviewinlayout ( lastchild ) ; childcount -- ; mcacheditemviews . addlast ( lastchild ) ; mlastitemposition -- ; if ( childcount > _num ) { lastchild = getchildat ( childcount - _num ) ; } else { lastchild = null ; } } } }	removes view that are outside of the visible part of the list.
public repeatedfieldbuilder < mtype , btype , itype > addmessage ( int index , mtype message ) { if ( message == null ) { throw new nullpointerexception ( ) ; } ensuremutablemessagelist ( ) ; messages . add ( index , message ) ; if ( builders != null ) { builders . add ( index , null ) ; } onchanged ( ) ; incrementmodcounts ( ) ; return this ; }	inserts the specified message at the specified position in this list.
void unlock ( table t ) { locks . remove ( t ) ; }	unlock just this table .
public void onexceededdatabasequota ( string url , string databaseidentifier , long currentquota , long estimatedsize , long totalusedquota , webstorage . quotaupdater quotaupdater ) { if ( logv_enabled ) { log . v ( logtag , _str + url + _str + databaseidentifier + _str + currentquota + _str + totalusedquota + _str ) ; } long totalunusedquota = mgloballimit - totalusedquota - mappcachemaxsize ; if ( totalunusedquota <= _num ) { if ( totalusedquota > _num ) { scheduleoutofspacenotification ( ) ; } quotaupdater . updatequota ( currentquota ) ; if ( logv_enabled ) { log . v ( logtag , _str ) ; } return ; } long neworiginquota = currentquota ; if ( neworiginquota == _num ) { if ( totalunusedquota >= estimatedsize ) { neworiginquota = estimatedsize ; } else { if ( logv_enabled ) { log . v ( logtag , _str + _str + _str + estimatedsize + _str + totalunusedquota ) ; } neworiginquota = _num ; } } else { long quotaincrease = estimatedsize == _num ? math . min ( quota_increase_step , totalunusedquota ) : estimatedsize ; neworiginquota += quotaincrease ; if ( quotaincrease > totalunusedquota ) { neworiginquota = currentquota ; } } quotaupdater . updatequota ( neworiginquota ) ; if ( logv_enabled ) { log . v ( logtag , _str + neworiginquota ) ; } }	the origin has exceeded its database quota .
protected string tovalstring ( set vals ) { stringbuilder sb = new stringbuilder ( ) ; boolean first = _bool ; for ( iterator i = vals . iterator ( ) ; i . hasnext ( ) ; ) { string val = ( string ) i . next ( ) ; val = encodeval ( val ) ; if ( first ) { first = _bool ; } else { sb . append ( _str ) ; } sb . append ( val ) ; } return sb . tostring ( ) ; }	converts a set of values for an attribute into a string , encoding special characters in the values as necessary .
public static jsonarray readjsonarray ( final jsonarray jsonarray , final int index , final boolean required , final boolean notnull ) throws jsonexception { if ( required ) { return jsonarray . getjsonarray ( index ) ; } if ( notnull && jsonarray . isnull ( index ) ) { throw new jsonexception ( string . format ( locale . us , null_value_format_array , index ) ) ; } jsonarray value = null ; if ( ! jsonarray . isnull ( index ) ) { value = jsonarray . getjsonarray ( index ) ; } return value ; }	reads the json array value from the json array for specified index.
private static bitmap resizephoto ( bitmap realimage , float maximagesize , boolean filter ) { float ratio = math . min ( ( float ) maximagesize / realimage . getwidth ( ) , ( float ) maximagesize / realimage . getheight ( ) ) ; int width = math . round ( ( float ) ratio * realimage . getwidth ( ) ) ; int height = math . round ( ( float ) ratio * realimage . getheight ( ) ) ; bitmap newbitmap = bitmap . createscaledbitmap ( realimage , width , height , filter ) ; return newbitmap ; }	this method resize the photo.
private element createkeyvalue ( ) throws exception { element keyvalueele = null ; privatekey key = idmclient . gettenantprivatekey ( tenantname ) ; if ( key != null ) { rsaprivatekey rsakey = ( rsaprivatekey ) key ; element rsakeyele = creatersakeyvalue ( rsakey ) ; if ( rsakeyele != null ) { keyvalueele = doc . createelement ( samlnames . ds_keyvalue ) ; keyvalueele . appendchild ( rsakeyele ) ; } } return keyvalueele ; }	return a ds : keyvalue element in dom . keyvalue | - - - - - rsakeyvalue.
static protected void expandelement ( element el , list < element > list ) { list . addall ( el . getchildren ( _str ) ) ; list < element > children = el . getchildren ( ) ; for ( int i = _num ; i < children . size ( ) ; i ++ ) { expandelement ( children . get ( i ) , list ) ; } }	find all of the display elements descending from this element.
static void load ( ) { }	this method may be used to force initialize the static members in the class.
public static string dump ( map < ? , ? > map ) { stringbuilder stringbuilder = new stringbuilder ( ) ; for ( map . entry < ? , ? > entry : map . entryset ( ) ) { stringbuilder . append ( entry . getkey ( ) ) ; stringbuilder . append ( _str ) ; stringbuilder . append ( entry . getvalue ( ) ) ; } return stringbuilder . tostring ( ) ; }	dump map value into string .
public void changedupdate ( documentevent e ) { }	called when the document is modified .
private void mergecollapse ( ) { while ( stacksize > _num ) { int n = stacksize - _num ; if ( n > _num && runlen [ n - _num ] <= runlen [ n ] + runlen [ n + _num ] ) { if ( runlen [ n - _num ] < runlen [ n + _num ] ) n -- ; mergeat ( n ) ; } else if ( runlen [ n ] <= runlen [ n + _num ] ) { mergeat ( n ) ; } else { break ; } } }	examines the stack of runs waiting to be merged and merges adjacent runs until the stack invariants are reestablished : 1.
protected void removefrommaps ( string clienttype ) { client client = ( client ) clienttypemap . get ( clienttype ) ; externalclientdata . remove ( clienttype ) ; map map = ( map ) internalclientdata . get ( clienttype ) ; if ( map == null ) { removefromclientmap ( clienttype , client ) ; } else { handleparentchange ( clienttype , map ) ; } unloadclient ( clienttype ) ; }	remove all references to this client.
public string serialize ( object object ) throws converterexception { deep = _num ; stringbuilder sb = new stringbuilder ( ) ; _serialize ( object , sb , new hashset < object > ( ) ) ; return sb . tostring ( ) ; }	serialize a object to his literal format.
private static < t > void finduniquegoals ( map < testcase , set < t > > testtogoals ) { map < testcase , set < t > > goalmapcopy = new linkedhashmap < > ( ) ; for ( map . entry < testcase , set < t > > entry : testtogoals . entryset ( ) ) { set < t > goalset = new linkedhashset < t > ( entry . getvalue ( ) ) ; for ( map . entry < testcase , set < t > > otherentry : testtogoals . entryset ( ) ) { if ( entry == otherentry ) continue ; goalset . removeall ( otherentry . getvalue ( ) ) ; } goalmapcopy . put ( entry . getkey ( ) , goalset ) ; } testtogoals . clear ( ) ; testtogoals . putall ( goalmapcopy ) ; }	determine for each test the set of coverage goals uniquely covered by this test.
private static string formhead ( string hair , string face , string neck ) { return string . join ( _str , hair , face , neck ) ; }	i ' ll form the head !.
public void terminate ( ) { listeners . clear ( ) ; lookupdisc . terminate ( ) ; locatordisc . terminate ( ) ; if ( dynamiclocatordisc != null ) dynamiclocatordisc . terminate ( ) ; }	terminates all threads , ending all discovery processing being performed by the current instance of this class.
public void start ( ) { start = system . currenttimemillis ( ) ; }	starts the bandwidth measurement .
@ nullable public static string extractprotocol ( @ notnull string url ) { int index = url . indexof ( urlutil . scheme_separator ) ; if ( index < _num ) return null ; return url . substring ( _num , index ) ; }	extracts protocol from the given url.
protected void loadbuffer ( ) { int residx = minutespacing / _num ; if ( residx < _num ) residx = _num ; else if ( residx > _num ) residx = _num ; string filename = path + etopofilenames [ residx ] ; databuffer = null ; try { binarybufferedfile binfile = new binarybufferedfile ( filename ) ; binfile . byteorder ( _bool ) ; bufferwidth = etopowidths [ residx ] ; bufferheight = etopoheights [ residx ] ; int spacer = _num ; switch ( minutespacing ) { case ( _num ) : spacer = _num + this . spacer ; break ; case ( _num ) : spacer = _num + this . spacer ; break ; default : spacer = _num + this . spacer ; } databuffer = new short [ ( bufferwidth + spacer ) * bufferheight ] ; for ( int i = _num ; i < bufferwidth * bufferheight ; i ++ ) databuffer [ i ] = binfile . readshort ( ) ; binfile . close ( ) ; bufferwidth += spacer ; } catch ( filenotfoundexception e ) { debug . error ( _str + filename + _str ) ; } catch ( ioexception e ) { debug . error ( _str + e . tostring ( ) ) ; } catch ( formatexception e ) { debug . error ( _str + e . tostring ( ) ) ; } }	loads the database from the appropriate file based on the current resolution.
protected versiontag fetchremoteversiontag ( object key ) { versiontag tag = null ; assert this . datapolicy != datapolicy . replicate ; transactionid txid = cache . getcachetransactionmanager ( ) . suspend ( ) ; try { boolean retry = _bool ; internaldistributedmember member = getrandomreplicate ( ) ; while ( retry ) { try { if ( member == null ) { break ; } fetchversionresponse response = remotefetchversionmessage . send ( member , this , key ) ; tag = response . waitforresponse ( ) ; retry = _bool ; } catch ( remoteoperationexception e ) { member = getrandomreplicate ( ) ; if ( member != null ) { if ( logger . isdebugenabled ( ) ) { logger . debug ( _str , member ) ; } } } } } finally { if ( txid != null ) { cache . getcachetransactionmanager ( ) . resume ( txid ) ; } } return tag ; }	fetch version for the given key from a remote replicate member .
public node replacechild ( node newchild , node oldchild ) throws domexception { if ( oldchild == null || oldchild . getparentnode ( ) != this ) return null ; elemtemplateelement newchildelem = ( ( elemtemplateelement ) newchild ) ; elemtemplateelement oldchildelem = ( ( elemtemplateelement ) oldchild ) ; elemtemplateelement prev = ( elemtemplateelement ) oldchildelem . getprevioussibling ( ) ; if ( null != prev ) prev . m_nextsibling = newchildelem ; if ( m_firstchild == oldchildelem ) m_firstchild = newchildelem ; newchildelem . m_parentnode = this ; oldchildelem . m_parentnode = null ; newchildelem . m_nextsibling = oldchildelem . m_nextsibling ; oldchildelem . m_nextsibling = null ; return newchildelem ; }	replace the old child with a new child .
public static fsize calctextsize ( paint paint , string demotext ) { rect r = new rect ( ) ; paint . gettextbounds ( demotext , _num , demotext . length ( ) , r ) ; return new fsize ( r . width ( ) , r . height ( ) ) ; }	calculates the approximate size of a text , depending on a demo text avoid repeated calls ( e.
private boolean parsedelimiters ( delimiterprocessor delimiterprocessor , char delimiterchar ) { delimiterdata res = scandelimiters ( delimiterprocessor , delimiterchar ) ; if ( res == null ) { return _bool ; } int numdelims = res . count ; int startindex = index ; index += numdelims ; text node = appendtext ( input , startindex , index ) ; lastdelimiter = new delimiter ( node , delimiterchar , res . canopen , res . canclose , lastdelimiter ) ; lastdelimiter . numdelims = numdelims ; if ( lastdelimiter . previous != null ) { lastdelimiter . previous . next = lastdelimiter ; } return _bool ; }	attempt to parse delimiters like emphasis , strong emphasis or custom delimiters .
private void clearmoney ( ) { money . clear ( ) ; updatemoney ( ) ; }	remove all the money objects.
public void exec ( string [ ] args ) throws throwable { urlclassloader urlclassloader = new urlclassloader ( classpath . toarray ( new url [ classpath . size ( ) ] ) ) ; class < ? > cls = urlclassloader . loadclass ( mainclass ) ; method method = cls . getdeclaredmethod ( _str , string [ ] . class ) ; method . setaccessible ( _bool ) ; try { method . invoke ( null , new object [ ] { args } ) ; } catch ( invocationtargetexception e ) { throw e . gettargetexception ( ) ; } }	execute with given arguments.
void rollbacklocaltransaction ( ) throws rollbackfailedexception { if ( _tx == null ) { return ; } try { if ( _logger . isloggable ( level . finest ) ) { _logger . log ( level . finest , _str + _tx ) ; } _tx . abort ( ) ; } catch ( exception e ) { if ( _logger . isloggable ( level . severe ) ) { _logger . log ( level . severe , _str + _tx , e ) ; } throw new rollbackfailedexception ( e ) ; } }	rolls back the local transaction .
public void write ( char c [ ] , int off , int len ) { if ( ( off < _num ) || ( off > c . length ) || ( len < _num ) || ( ( off + len ) > c . length ) || ( ( off + len ) < _num ) ) { throw new indexoutofboundsexception ( ) ; } else if ( len == _num ) { return ; } synchronized ( lock ) { int newcount = count + len ; if ( newcount > buf . length ) { buf = arrays . copyof ( buf , math . max ( buf . length << _num , newcount ) ) ; } system . arraycopy ( c , off , buf , count , len ) ; count = newcount ; } }	writes characters to the buffer .
private void writejarpostresource ( stringbuilder sb , string path ) { sb . append ( _str + jar_resource_set + _str ) ; sb . append ( path . replace ( _str , _str ) ) ; }	write jar post resource.
public static string normalize ( string value ) { if ( value == null ) return value ; value = value . trim ( ) ; if ( value . indexof ( _str ) == - _num ) return value ; boolean space = _bool ; int len = value . length ( ) ; stringbuffer b = new stringbuffer ( len ) ; for ( int i = _num ; i < len ; i ++ ) { char v = value . charat ( i ) ; if ( v == _str ) { if ( ! space ) b . append ( v ) ; space = _bool ; } else { b . append ( v ) ; space = _bool ; } } return b . tostring ( ) ; }	normalize an attribute value ( id - style ).
protected static void appenddecorations ( int basepos , string sourcecode , createsimplelexer langhandler , list < object > out ) { if ( sourcecode == null ) { throw new nullpointerexception ( _str ) ; } job job = new job ( ) ; job . setsourcecode ( sourcecode ) ; job . setbasepos ( basepos ) ; langhandler . decorate ( job ) ; out . addall ( job . getdecorations ( ) ) ; }	apply the given language handler to sourcecode and add the resulting decorations to out .
protected carbondictionarycolumnmetachunk readlastchunkfromdictionarymetadatafile ( dictionarycolumnuniqueidentifier dictionarycolumnuniqueidentifier ) throws ioexception { dictionaryservice dictservice = carboncommonfactory . getdictionaryservice ( ) ; carbondictionarymetadatareader columnmetadatareaderimpl = dictservice . getdictionarymetadatareader ( dictionarycolumnuniqueidentifier . getcarbontableidentifier ( ) , dictionarycolumnuniqueidentifier . getcolumnidentifier ( ) , carbonstorepath ) ; carbondictionarycolumnmetachunk carbondictionarycolumnmetachunk = null ; try { carbondictionarycolumnmetachunk = columnmetadatareaderimpl . readlastentryofdictionarymetachunk ( ) ; } finally { columnmetadatareaderimpl . close ( ) ; } return carbondictionarycolumnmetachunk ; }	this method will read dictionary metadata file and return the dictionary meta chunks.
public static externalappid determineexternalintentsource ( string packagename , intent intent ) { string appid = intentutils . safegetstringextra ( intent , browser . extra_application_id ) ; externalappid externalid = externalappid . other ; if ( appid == null ) { string url = geturlfromintent ( intent ) ; if ( url != null && url . startswith ( twitter_link_prefix ) ) { externalid = externalappid . twitter ; } else if ( url != null && url . startswith ( facebook_link_prefix ) ) { externalid = externalappid . facebook ; } else if ( url != null && url . startswith ( news_link_prefix ) ) { externalid = externalappid . news ; } } else { if ( appid . equals ( package_plus ) ) { externalid = externalappid . plus ; } else if ( appid . equals ( package_gmail ) ) { externalid = externalappid . gmail ; } else if ( appid . equals ( package_hangouts ) ) { externalid = externalappid . hangouts ; } else if ( appid . equals ( package_messenger ) ) { externalid = externalappid . messenger ; } else if ( appid . equals ( package_line ) ) { externalid = externalappid . line ; } else if ( appid . equals ( package_whatsapp ) ) { externalid = externalappid . whatsapp ; } else if ( appid . equals ( package_gsa ) ) { externalid = externalappid . gsa ; } else if ( appid . equals ( packagename ) ) { externalid = externalappid . chrome ; } } return externalid ; }	determines what app was used to fire this intent .
protected tablehdu ( header hdr , t td ) { super ( hdr , td ) ; }	create the tablehdu . note that this will normally only be invoked by subclasses in the fits package .
public void pushstylesheet ( stylesheet s ) { if ( m_stylesheets . size ( ) == _num ) m_stylesheetroot = ( stylesheetroot ) s ; m_stylesheets . push ( s ) ; }	push the current stylesheet being constructed.
public boolean isblank ( final charsequence cs ) { int strlen ; if ( cs == null || ( strlen = cs . length ( ) ) == _num ) { return _bool ; } for ( int i = _num ; i < strlen ; i ++ ) { if ( ! character . iswhitespace ( cs . charat ( i ) ) ) { return _bool ; } } return _bool ; }	checks if a charsequence is whitespace , empty ( " " ) or null .
public void stop ( ) throws ioexception , interruptedexception { thread . interrupt ( ) ; selector . wakeup ( ) ; }	disconnects and stops the client .
private document parse ( final string data , documentbuilder docbuilder ) { if ( docbuilder == null || data == null ) { return null ; } document document = null ; try { stringbuilder buf = new stringbuilder ( _num ) ; if ( ! data . startswith ( _str ) ) { buf . append ( begin_part ) ; } buf . append ( data ) ; if ( ! data . endswith ( end_part ) ) { buf . append ( end_part ) ; } inputsource inputsource = new inputsource ( new stringreader ( buf . tostring ( ) ) ) ; document = docbuilder . parse ( inputsource ) ; } catch ( exception e ) { logger . warn ( _str + e . getmessage ( ) ) ; } return document ; }	converts the loggingevent data in xml string format into an actual xml document class instance .
private xnetreply loadchars ( java . io . bufferedreader istream ) throws java . io . ioexception { string s = _str ; s = istream . readline ( ) ; if ( log . isdebugenabled ( ) ) { log . debug ( _str + s ) ; } if ( s == null ) { return null ; } else { return new xnetreply ( s ) ; } }	get characters from the input source , and file a message.
public synchronized void removeconnectionmanager ( final httpconnectionmanager connectionmanager ) { if ( shutdown ) { throw new illegalstateexception ( _str ) ; } connectionmanagers . remove ( connectionmanager ) ; }	removes the connection manager from this class.
private boolean addstate ( long statenumber ) { if ( firststate < _num ) { firststate = statenumber ; } else if ( stepsize < _num ) { stepsize = ( int ) ( statenumber - firststate ) ; } else { int step = ( int ) ( statenumber - laststate ) ; if ( step != stepsize ) { return _bool ; } } laststate = statenumber ; return _bool ; }	add a state number for these traces.
public void reset ( ) { adler = _num ; }	resets the checksum to initial value .
public static boolean islibraryresourceroot ( @ nullable virtualfile res ) { if ( res != null ) { virtualfile aar = res . getparent ( ) ; if ( aar != null ) { virtualfile exploded = aar . getparent ( ) ; if ( exploded != null ) { string name = exploded . getname ( ) ; if ( name . equals ( exploded_bundles ) || name . equals ( exploded_aar ) ) { return _bool ; } } } } return _bool ; }	returns true if the given resource folder ( such as a given " res " folder , a parent of say a layout folder ) is an extracted library ( aar ) resource folder.
public void failengine ( string reason , @ nullable throwable failure ) { if ( failenginelock . trylock ( ) ) { store . incref ( ) ; try { try { closenolock ( _str + reason + _str ) ; } finally { if ( failedengine != null ) { logger . debug ( _str , reason , failure ) ; return ; } logger . warn ( _str , failure , reason ) ; failedengine = ( failure != null ) ? failure : new illegalstateexception ( reason ) ; if ( lucene . iscorruptionexception ( failure ) ) { try { store . markstorecorrupted ( new ioexception ( _str + reason + _str , exceptionshelper . unwrapcorruption ( failure ) ) ) ; } catch ( ioexception e ) { logger . warn ( _str , e ) ; } } failedenginelistener . onfailedengine ( shardid , reason , failure ) ; } } catch ( throwable t ) { logger . warn ( _str , t ) ; } finally { store . decref ( ) ; } } else { logger . debug ( _str , reason , failure ) ; } }	fail engine due to some error.
public void clear ( ) { values . clear ( ) ; }	clear out the collection .
@ override default completablefuture < optionalint > maxint ( final tointfunction < ? super t > fn ) { return completablefuture . supplyasync ( null , getexec ( ) ) ; }	perform an asynchronous max operation.
private void addvnxfilestoragesystemintocache ( string storagesystemuri , distributedqueueitemprocessedcallback callback ) { if ( stringutils . isnotempty ( storagesystemuri ) ) { vnxfile_cache . put ( storagesystemuri , callback ) ; } }	adds vnxfile ' s uri and callback instance into cache.
void resettopreferredsizes ( int availablesize ) { int [ ] testsizes = getpreferredsizes ( ) ; int totalsize = _num ; for ( int counter = _num ; counter < _num ; counter ++ ) { if ( testsizes [ counter ] != - _num ) { totalsize += testsizes [ counter ] ; } } if ( totalsize > availablesize ) { testsizes = getminimumsizes ( ) ; totalsize = _num ; for ( int counter = _num ; counter < _num ; counter ++ ) { if ( testsizes [ counter ] != - _num ) { totalsize += testsizes [ counter ] ; } } } setsizes ( testsizes ) ; distributespace ( availablesize - totalsize , _bool ) ; }	resets the components to their preferred sizes .
public boolean isprocessing ( ) { return mrunning . get ( ) ; }	indicates if this processing chain is currently receiving samples from a source and sending those samples to the decoders .
private static inputstreamreader decompresswith7zip ( final string archivepath ) throws configurationexception { path_program_7zip = ( string ) config . getconfigparameter ( configurationkeys . path_program_7zip ) ; if ( path_program_7zip == null ) { throw errorfactory . createconfigurationexception ( errorkeys . configuration_parameter_undefined ) ; } try { runtime runtime = runtime . getruntime ( ) ; process p = runtime . exec ( path_program_7zip + _str + archivepath + _str ) ; return new inputstreamreader ( p . getinputstream ( ) , wikipedia_encoding ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } }	starts a decompression process using the 7zip program .
public void send ( string data ) throws ioexception { datagrampacket dp = new datagrampacket ( data . getbytes ( ) , data . length ( ) , multicastgroup ) ; datagramsocket . send ( dp ) ; }	used to send ssdp packet.
private void removestalerangereferences ( ) { removestalereferences ( rangereferencequeue , ranges ) ; }	remove stale range references from the range list .
private boolean isexported ( uri id , list < uri > exportedvolumes ) { return exportedvolumes . contains ( id ) ; }	check if volume is exported .
private string fixmonitorlinks ( string fixstring , string dumpname ) { if ( fixstring . indexof ( _str ) > _num ) { fixstring = fixstring . replaceall ( _str , _str + dumpname + _str ) ; } return ( fixstring ) ; }	fix the monitor links for proper navigation to the monitor in the right dump .
protected static testdimensionconfig buildstandarddimensionconfig ( testapidimensionname dimensionname ) { return new testdimensionconfig ( dimensionname , dimensionname . asname ( ) , getdefaultkeyvaluestore ( dimensionname ) , getdefaultsearchprovider ( ) , getdefaultfields ( ) , getdefaultfields ( ) ) ; }	build a standard - config dimension config .
public string tostring ( ) { stringbuffer sb = new stringbuffer ( _str ) ; if ( type != set_constraints ) { sb . append ( type == as_is ? _str : _str ) ; } sb . append ( loader ) ; sb . append ( _str ) ; for ( int i = _num ; i < contextelements . length ; i ++ ) { if ( i > _num ) { sb . append ( _str ) ; } sb . append ( contextelements [ i ] ) ; } if ( principals == null ) { sb . append ( _str ) ; } else { sb . append ( _str ) ; for ( int i = _num ; i < principals . length ; i ++ ) { if ( i > _num ) { sb . append ( _str ) ; } sb . append ( principals [ i ] ) ; } sb . append ( _str ) ; } for ( int i = _num ; i < permissions . length ; i ++ ) { if ( i > _num ) { sb . append ( _str ) ; } sb . append ( permissions [ i ] ) ; } sb . append ( _str ) ; return sb . tostring ( ) ; }	returns a string representation of this object .
public synchronized void cachereposts ( list < long > newrepostids ) { treeset < long > reposts = new treeset < > ( ) ; reposts . addall ( longs . aslist ( repostcache . get ( ) ) ) ; reposts . addall ( newrepostids ) ; repostcache . set ( longs . toarray ( reposts ) ) ; }	caches the given items as reposts .
protected final class < ? > defineclass ( string classname , byte [ ] classrep , int offset , int length ) throws classformaterror { return defineclass ( classname , classrep , offset , length , null ) ; }	constructs a new class from an array of bytes containing a class definition in class file format .
public boolean rewriteexif ( bytebuffer buf , collection < exiftag > tags ) throws ioexception { exifmodifier mod = null ; try { mod = new exifmodifier ( buf , this ) ; for ( exiftag t : tags ) { mod . modifytag ( t ) ; } return mod . commit ( ) ; } catch ( exifinvalidformatexception e ) { throw new ioexception ( _str + e ) ; } }	attempts to do an in - place rewrite the exif metadata in a bytebuffer for the given tags.
private void writenewlineondebug ( xmlstreamwriter out ) throws xmlstreamexception { if ( log . isdebugging ( ) ) { out . writecharacters ( _str ) ; } }	print a newline when debugging .
public requesthandle put ( string url , responsehandlerinterface responsehandler ) { return put ( null , url , null , responsehandler ) ; }	perform a http put request , without any parameters .
public discretize ( element discretize , fieldmetainfo . optype optype , arraylist < attribute > fielddefs ) throws exception { super ( optype , fielddefs ) ; m_fieldname = discretize . getattribute ( _str ) ; m_mapmissingto = discretize . getattribute ( _str ) ; if ( m_mapmissingto != null && m_mapmissingto . length ( ) > _num ) { m_mapmissingdefined = _bool ; } m_defaultvalue = discretize . getattribute ( _str ) ; if ( m_defaultvalue != null && m_defaultvalue . length ( ) > _num ) { m_defaultvaluedefined = _bool ; } nodelist dbl = discretize . getelementsbytagname ( _str ) ; for ( int i = _num ; i < dbl . getlength ( ) ; i ++ ) { node dbn = dbl . item ( i ) ; if ( dbn . getnodetype ( ) == node . element_node ) { element dbe = ( element ) dbn ; discretizebin db = new discretizebin ( dbe , m_optype ) ; m_bins . add ( db ) ; } } if ( fielddefs != null ) { setupfield ( ) ; } }	constructs a discretize expression.
private static string quadtree ( final maptile atile ) { stringbuilder quadkey = new stringbuilder ( ) ; for ( int i = atile . zoomlevel ; i > _num ; i -- ) { int digit = _num ; int mask = _num << ( i - _num ) ; if ( ( atile . x & mask ) != _num ) digit += _num ; if ( ( atile . y & mask ) != _num ) digit += _num ; quadkey . append ( digit ) ; } return quadkey . tostring ( ) ; }	converts tms tile coordinates to quadtree.
public static long [ ] ones ( int bits ) { long [ ] v = new long [ ( ( bits - _num ) > > > long_log2_size ) + _num ] ; final int fillwords = bits > > > long_log2_size ; final int fillbits = bits & long_log2_mask ; arrays . fill ( v , _num , fillwords , long_all_bits ) ; if ( fillwords < v . length ) { v [ v . length - _num ] = ( _num << fillbits ) - _num ; } return v ; }	create a vector initialized with " bits " ones .
private boolean checkcurrentkeyage ( ) throws numberformatexception { long currenttokenkeyts = long . parselong ( _cachedtokenkeysbundle . getcurrentkeyentry ( ) ) ; long now = system . currenttimemillis ( ) ; long diff = now - currenttokenkeyts ; if ( diff >= _keyrotationintervalinmsecs ) { return _bool ; } return _bool ; }	looks at the current key timestamp.
public final void pushcontextnodelist ( dtmiterator nl ) { m_contextnodelists . push ( nl ) ; }	set the current context node list .
public void note ( element e , string msg ) { messager . printmessage ( diagnostic . kind . note , msg , e ) ; }	triggered if a note issued during processing.
public static publickey generatepublickey ( string encodedpublickey ) { try { byte [ ] decodedkey = base64 . decode ( encodedpublickey , base64 . default ) ; keyfactory keyfactory = keyfactory . getinstance ( key_factory_algorithm ) ; return keyfactory . generatepublic ( new x509encodedkeyspec ( decodedkey ) ) ; } catch ( nosuchalgorithmexception e ) { throw new runtimeexception ( e ) ; } catch ( invalidkeyspecexception e ) { log . e ( tag , _str ) ; throw new illegalargumentexception ( e ) ; } }	generates a publickey instance from a string containing the base64 - encoded public key .
@ override public enumeration < option > listoptions ( ) { vector < option > result = new vector < option > ( ) ; result . addall ( collections . list ( super . listoptions ( ) ) ) ; result . addelement ( new option ( _str , _str , _num , _str ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
public trustsource add ( file trustedcapemfile ) { if ( trustedcapemfile == null ) { throw new illegalargumentexception ( _str ) ; } string pemfilecontents ; try { pemfilecontents = files . tostring ( trustedcapemfile , charset . forname ( _str ) ) ; } catch ( ioexception e ) { throw new uncheckedioexception ( _str + trustedcapemfile . getabsolutepath ( ) , e ) ; } return add ( pemfilecontents ) ; }	returns a new trustsource containing the same trusted cas as this trustsource , plus zero or more cas contained in the pem - encoded file.
stringvector processstringlist ( stylesheethandler handler , string uri , string name , string rawname , string value ) { stringtokenizer tokenizer = new stringtokenizer ( value , _str ) ; int nstrings = tokenizer . counttokens ( ) ; stringvector strings = new stringvector ( nstrings ) ; for ( int i = _num ; i < nstrings ; i ++ ) { strings . addelement ( tokenizer . nexttoken ( ) ) ; } return strings ; }	process an attribute string of type t_stringlist into a vector of xpath match patterns .
public static attributedescription objectclass ( ) { return object_class ; }	returns an attribute description representing the object class attribute type with no options .
public void addkeyvaluecomment ( string keyname , string value ) { int keyindex ; if ( ( keyindex = findkeycommentindex ( keyname ) ) < _num ) { keyvalcomments . add ( _str + keyname + _str + value + _str ) ; return ; } log . warn ( _str + keyname + _str ) ; keyvalcomments . set ( keyindex , _str + keyname + _str + value + _str ) ; }	updates the internal key / value storage to reflect the parameters.
private string isinputchecked ( string dataset , string value ) { if ( dataset != null && dataset . equals ( value ) ) { return _str ; } return _str ; }	returns a string which indicates if the input was checked in a submitted form .
public final void popsubcontextlist ( ) { m_axesiteratorstack . pop ( ) ; }	pop the last pushed axes iterator .
private drivertask createdrivertask ( string tasktype ) { string taskid = string . format ( _str , hp3parconstants . driver_name , tasktype , uuid . randomuuid ( ) ) ; drivertask task = new hp3pardrivertask ( taskid ) ; return task ; }	create driver task for task type.
public void store ( element cat , list < string > trees ) { catalogtreemanager manager = instancemanager . getdefault ( jmri . catalogtreemanager . class ) ; cat . setattribute ( _str , _str ) ; iterator < string > iter = trees . iterator ( ) ; while ( iter . hasnext ( ) ) { string sname = iter . next ( ) ; if ( sname == null ) { log . error ( _str ) ; continue ; } if ( log . isdebugenabled ( ) ) { log . debug ( _str + sname ) ; } if ( sname . charat ( _num ) != catalogtree . xml ) { continue ; } catalogtree ct = manager . getbysystemname ( sname ) ; element elem = new element ( _str ) ; elem . setattribute ( _str , sname ) ; string uname = ct . getusername ( ) ; if ( uname != null ) { elem . setattribute ( _str , uname ) ; } storenode ( elem , ct . getroot ( ) ) ; if ( log . isdebugenabled ( ) ) { log . debug ( _str + sname ) ; } cat . addcontent ( elem ) ; } }	default implementation for storing the contents of a catalogtreemanager.
public boolean isenabled ( ) { return enabled ; }	tells if this processor is enabled or not.
public static boolean loadtexture ( int glid , int file ) { inputstream is = resource . getresinputstream ( file ) ; bitmap bitmap = null ; try { bitmapfactory . options opts = new bitmapfactory . options ( ) ; opts . inscaled = _bool ; bitmap = bitmapfactory . decodestream ( is , null , opts ) ; } catch ( exception e ) { log . e ( tag , _str + file , e ) ; return _bool ; } finally { try { is . close ( ) ; } catch ( exception e ) { log . e ( tag , _str , e ) ; } } return loadtexture ( glid , bitmap ) ; }	loads one texture file.
public static int roll1d100 ( ) { return rand . nextint ( _num ) + _num ; }	simulates rolling a dice with 100 sides .
public zipfiangenerator ( long min , long max , double _zipfianconstant , double _zetan ) { items = max - min + _num ; base = min ; zipfianconstant = _zipfianconstant ; theta = zipfianconstant ; zeta2theta = zeta ( _num , theta ) ; alpha = _num / ( _num - theta ) ; zetan = _zetan ; countforzeta = items ; eta = ( _num - math . pow ( _num / items , _num - theta ) ) / ( _num - zeta2theta / zetan ) ; nextint ( ) ; }	create a zipfian generator for items between min and max ( inclusive ) for the specified zipfian constant , using the precomputed value of zeta .
public void removerole ( roleentity role ) { roles . remove ( role ) ; }	removes the given role from this user.
private map processevent ( matchresult result ) { map map = new hashmap ( ) ; for ( int i = _num ; i < result . groupcount ( ) + _num ; i ++ ) { object key = matchingkeywords . get ( i - _num ) ; object value = result . group ( i ) ; map . put ( key , value ) ; } return map ; }	convert the match into a map . < p > relies on the fact that the matchingkeywords list is in the same order as the groups in the regular expression.
public void addextension ( string ext ) { exts . add ( ext . tolowercase ( ) ) ; }	add a file extension to this file filter .
public boolean equals ( object o ) { if ( o == this ) return _bool ; if ( ! ( o instanceof mbeanattributeinfo ) ) return _bool ; mbeanattributeinfo p = ( mbeanattributeinfo ) o ; return ( objects . equals ( p . getname ( ) , getname ( ) ) && objects . equals ( p . gettype ( ) , gettype ( ) ) && objects . equals ( p . getdescription ( ) , getdescription ( ) ) && objects . equals ( p . getdescriptor ( ) , getdescriptor ( ) ) && p . isreadable ( ) == isreadable ( ) && p . iswritable ( ) == iswritable ( ) && p . isis ( ) == isis ( ) ) ; }	compare this mbeanattributeinfo to another .
protected boolean handledirectory ( file directory , string [ ] contentnames ) throws securityexception { boolean continuewandering = _bool ; for ( string child : contentnames ) { boolean keepgoing = handleentry ( new file ( directory . getabsolutepath ( ) + file . separator , child ) ) ; if ( ! keepgoing ) { continuewandering = exhaustivesearch ; if ( ! continuewandering ) { break ; } } } return continuewandering ; }	management method for the wanderer , that steps through the children of the directory and calls handleentry for them .
int size ( ) { return integer . bitcount ( set ) ; }	returns the number of settings that have values assigned .
public boolean hasnext ( ) { return iterator . hasnext ( ) ; }	tells if there are more sockectchannel left in the iterator.
public static string formatnumber ( final long number ) { long divided = number ; final stringbuffer sb = new stringbuffer ( ) ; while ( divided > _num ) { long rest = divided % _num ; sb . insert ( _num , _str + string . format ( _str , rest ) ) ; divided = divided / _num ; } long rest = divided % _num ; sb . insert ( _num , rest ) ; return sb . tostring ( ) ; }	formats the given number into one where thousands are separated by a space .
private boolean issubsumed ( string selector , iterable < string > others ) { for ( string other : others ) { if ( subsumes ( other , selector ) ) { return _bool ; } } return _bool ; }	check whether selector is subsumed by any of other selectors .
private void displayvalues ( ) { log ( _str , project . msg_info ) ; log ( _str + this . spec ) ; log ( _str + getspecabsolutepath ( ) ) ; log ( _str + getserializedspecabsolutepath ( ) ) ; log ( _str + this . specdir ) ; log ( _str + this . cup2srcdir ) ; log ( _str + this . classpath ) ; log ( _str + this . algorithm ) ; log ( _str + this . verbose ) ; log ( _str + this . parsetable ) ; log ( _str ) ; }	display all field values.
private boolean checktouchingmintarget ( int index , motionevent event ) { if ( istouchingmintarget ( index , event ) ) { lasttouchedmin = _bool ; istouchingmintarget . add ( event . getpointerid ( index ) ) ; if ( ! minanimator . isrunning ( ) ) { minanimator = getmintargetanimator ( _bool ) ; minanimator . start ( ) ; } return _bool ; } return _bool ; }	checks if given index is touching the min target.
public boolean iscanceled ( ) { if ( pane == null ) return _bool ; object v = pane . getvalue ( ) ; return ( ( v != null ) && ( canceloption . length == _num ) && ( v . equals ( canceloption [ _num ] ) ) ) ; }	returns true if the user hits the cancel button in the progress dialog .
public int availableprocessors ( ) { return rvmthread . availableprocessors ; }	return the number of processors , always at least one .
public final static void debug ( string s ) { if ( debug ) debug . println ( _str + s ) ; }	print a debug message on debug stream associated with this interpreter only if debugging is turned on .
public static final void writelongarrayxml ( long [ ] val , string name , xmlserializer out ) throws xmlpullparserexception , ioexception { if ( val == null ) { out . starttag ( null , _str ) ; out . endtag ( null , _str ) ; return ; } out . starttag ( null , _str ) ; if ( name != null ) { out . attribute ( null , _str , name ) ; } final int n = val . length ; out . attribute ( null , _str , integer . tostring ( n ) ) ; for ( int i = _num ; i < n ; i ++ ) { out . starttag ( null , _str ) ; out . attribute ( null , _str , long . tostring ( val [ i ] ) ) ; out . endtag ( null , _str ) ; } out . endtag ( null , _str ) ; }	flatten a long [ ] into an xmlserializer.
public static < t extends genericentity > list < t > filterbyor ( list < t > values , list < ? extends entitycondition > exprs ) { if ( values == null ) return null ; if ( utilvalidate . isempty ( exprs ) ) { return values ; } list < t > result = new linkedlist < t > ( ) ; for ( t value : values ) { boolean include = _bool ; for ( entitycondition condition : exprs ) { include = condition . entitymatches ( value ) ; if ( include ) break ; } if ( include ) { result . add ( value ) ; } } return result ; }	returns the values that match any of the exprs in list.
@ override public res next ( req req ) { writetracelog ( req , middlewarename ) ; if ( predicate . test ( req ) ) { res res = middleware . handle ( req , next ) ; writetracelog ( res , middlewarename ) ; return res ; } else if ( next != null ) { res res = ( res ) next . next ( req ) ; writetracelog ( res , middlewarename ) ; return res ; } else { return null ; } }	dispatches a request to the next chain of middleware .
protected void read ( long offset , byte [ ] b ) throws ioexception { rafile . seek ( offset ) ; if ( rafile . read ( b ) != b . length ) { throw new ioexception ( _str + getpath ( ) ) ; } }	reads a number of bytes from the rrd file on the disk.
public void run ( ) { final fetcherinfo info = fetcherinfo . getfetcherinfo ( ) ; try { fetchloop ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } finally { synchronized ( info . waitlist ) { thread me = thread . currentthread ( ) ; for ( int i = _num ; i < info . fetchers . length ; i ++ ) { if ( info . fetchers [ i ] == me ) { info . fetchers [ i ] = null ; info . numfetchers -- ; } } } } }	the main run ( ) method of an imagefetcher thread.
public ctclass makeannotation ( string name ) throws runtimeexception { try { ctclass cc = makeinterface ( name , get ( _str ) ) ; cc . setmodifiers ( cc . getmodifiers ( ) | modifier . annotation ) ; return cc ; } catch ( notfoundexception e ) { throw new runtimeexception ( e . getmessage ( ) , e ) ; } }	creates a new annotation.
public void testnegatemathcontextnegative ( ) { string a = _str ; int ascale = _num ; int precision = _num ; roundingmode rm = roundingmode . ceiling ; mathcontext mc = new mathcontext ( precision , rm ) ; string c = _str ; int cscale = _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal res = anumber . negate ( mc ) ; assertequals ( _str , c , res . tostring ( ) ) ; assertequals ( _str , cscale , res . scale ( ) ) ; }	negate ( mathcontext ) for a negative bigdecimal.
public void add ( node node ) { availablenodes . add ( node ) ; }	adds a node that can appear in programs produced using these rules .
public void write ( outputstream out ) throws ioexception { dataoutputstream dataout = new dataoutputstream ( out ) ; dataout . writeshort ( pool . size ( ) + _num ) ; for ( entry e : pool ) { e . write ( dataout ) ; } }	write this constant pool to a stream as part of the class file format.
protected foreignkeyconstraint buildforeignkeyconstraint ( list < string > fkfieldnames , list < string > pkfieldnames , tabledefinition targettable , databaseplatform platform ) { assert fkfieldnames . size ( ) > _num && fkfieldnames . size ( ) == pkfieldnames . size ( ) ; foreignkeyconstraint fkconstraint = new foreignkeyconstraint ( ) ; for ( int i = _num ; i < fkfieldnames . size ( ) ; i ++ ) { fkconstraint . getsourcefields ( ) . add ( fkfieldnames . get ( i ) ) ; fkconstraint . gettargetfields ( ) . add ( pkfieldnames . get ( i ) ) ; } fkconstraint . settargettable ( targettable . getfullname ( ) ) ; string fkfieldname = fkfieldnames . get ( _num ) ; string name = buildforeignkeyconstraintname ( this . getname ( ) , fkfieldname , platform . getmaxforeignkeynamesize ( ) , platform ) ; fkconstraint . setname ( name ) ; return fkconstraint ; }	build a foreign key constraint .
public serverbuilder ( config config ) { objects . requirenonnull ( config ) ; _config = config ; }	creates a new server builder .
private static ldapfilter createsubstringfilter ( substringfilter sf ) throws ldapexception , ioexception { list < object > anyo = sf . getany ( ) ; arraylist < bytestring > subanyelements = new arraylist < > ( anyo . size ( ) ) ; for ( object o : anyo ) { subanyelements . add ( bytestringutility . convertvalue ( o ) ) ; } if ( sf . getinitial ( ) == null && subanyelements . isempty ( ) && sf . getfinal ( ) == null ) { localizablemessage message = err_ldap_filter_decode_null . get ( ) ; throw new ldapexception ( ldapresultcode . protocol_error , message ) ; } return ldapfilter . createsubstringfilter ( sf . getname ( ) , sf . getinitial ( ) == null ? null : bytestringutility . convertvalue ( sf . getinitial ( ) ) , subanyelements , sf . getfinal ( ) == null ? null : bytestringutility . convertvalue ( sf . getfinal ( ) ) ) ; }	returns a new substring search filter with the provided information .
@ override protected void onsizechanged ( int w , int h , int oldw , int oldh ) { if ( readysent ) { setscaleandcenter ( getscale ( ) , getcenter ( ) ) ; } }	on resize , preserve center and scale.
protected void disown ( abstractnode child ) throws illegalstateexception { ensureparentage ( child ) ; child . parent = null ; }	disowns a direct child ( it will be parentless after this call ) .
public string qname2string ( qname qname , boolean writens ) { string prefix = null ; string namespaceuri = qname . getnamespace ( ) ; string localpart = qname . getlocalpart ( ) ; if ( localpart != null && localpart . length ( ) > _num ) { int index = localpart . indexof ( _str ) ; if ( index != - _num ) { prefix = localpart . substring ( _num , index ) ; if ( prefix . length ( ) > _num && ! prefix . equals ( _str ) ) { registerprefixforuri ( prefix , namespaceuri ) ; localpart = localpart . substring ( index + _num ) ; } else { prefix = null ; } } localpart = getlastlocalpart ( localpart ) ; } if ( namespaceuri . length ( ) == _num ) { if ( writens ) { string defaultns = nsstack . getnamespaceuri ( _str ) ; if ( defaultns != null && defaultns . length ( ) > _num ) { registerprefixforuri ( _str , _str ) ; } } } else { prefix = getprefixforuri ( namespaceuri , qname . getpreferredprefix ( ) ) ; } if ( ( prefix == null ) || ( prefix . length ( ) == _num ) ) return localpart ; return prefix + _str + localpart ; }	convert qname to a string of the form < prefix > : < localpart >.
@ override public void close ( ) throws xmlstreamexception { log . log ( level . fine , _str ) ; stream . close ( ) ; }	frees any resources associated with this stream.
public void testdivideroundhalfupneg2 ( ) { string a = _str ; int ascale = _num ; string b = _str ; int bscale = _num ; string c = _str ; int resscale = - _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; bigdecimal result = anumber . divide ( bnumber , resscale , bigdecimal . round_half_up ) ; assertequals ( _str , c , result . tostring ( ) ) ; assertequals ( _str , resscale , result . scale ( ) ) ; }	divide : rounding mode is round_half_up , result is negative ; equidistant.
@ override public string readline ( ) throws ioexception { if ( this . pointer >= this . data . length - _num ) { return null ; } else { final stringbuilder buf = new stringbuilder ( ) ; int c ; while ( ( c = read ( ) ) >= _num ) { if ( ( c == _num ) || ( c == _num ) ) { if ( ( ( peek ( ) == _num ) || ( peek ( ) == _num ) ) && ( peek ( ) != c ) ) { read ( ) ; } break ; } buf . append ( ( char ) c ) ; } return buf . tostring ( ) ; } }	return next line ( returns null if no line ).
protected static map attrsettomap ( attrset attrset , boolean fetchbytevalues ) { map attributesmap = new amhashmap ( fetchbytevalues ) ; if ( attrset == null ) { return attributesmap ; } int attrsetsize = attrset . size ( ) ; if ( ! fetchbytevalues ) { for ( int i = _num ; i < attrsetsize ; i ++ ) { attr attr = attrset . elementat ( i ) ; string values [ ] = attr . getstringvalues ( ) ; attributesmap . put ( attr . getname ( ) , stringarraytoset ( values ) ) ; } } else { for ( int i = _num ; i < attrsetsize ; i ++ ) { attr attr = attrset . elementat ( i ) ; attributesmap . put ( attr . getname ( ) , attr . getbytevalues ( ) ) ; } } return attributesmap ; }	method to convert a attrset object to map .
public < e > e parseresponsedata ( gdatarequest req , class < e > resulttype ) throws ioexception , serviceexception { inputproperties inputproperties = new clientinputproperties ( req , resulttype ) ; return parseresponsedata ( req . getparsesource ( ) , inputproperties , resulttype ) ; }	parses the response stream for a request based upon request properties and an expected result type.
public void addrtpstreamlistener ( rtpstreamlistener rtpstreamlistener ) { mrtpstreamlistener = rtpstreamlistener ; }	adds the rtp stream listener.
public synchronized byte [ ] tobytearray ( ) { int remaining = count ; if ( remaining == _num ) { return empty_byte_array ; } byte [ ] newbuf = new byte [ remaining ] ; int pos = _num ; for ( byte [ ] buf : buffers ) { int c = math . min ( buf . length , remaining ) ; system . arraycopy ( buf , _num , newbuf , pos , c ) ; pos += c ; remaining -= c ; if ( remaining == _num ) { break ; } } return newbuf ; }	gets the curent contents of this byte stream as a byte array.
public void addvolumestoconsistencygroup ( string cgname , list < string > virtualvolumenames ) throws vplexapiexception { s_logger . info ( _str , _baseuri ) ; _cgmgr . addvolumestoconsistencygroup ( cgname , virtualvolumenames ) ; }	adds the volumes with the passed names to the consistency group with the passed name .
public void testconstructorsignbytespositive6 ( ) { byte abytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , - _num } ; int asign = _num ; byte rbytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = anumber . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , anumber . signum ( ) ) ; }	create a positive number from a sign and an array of bytes.
public static boolean lookslikeafontstyle ( string val ) { return font_styles . indexof ( val ) >= _num ; }	description of the method.
public static void dumpcursor ( icursor cursor , int maxcolumnwidth ) { stringbuilder builder = new stringbuilder ( _str ) ; dumpcursor ( cursor , maxcolumnwidth , builder ) ; logger . d ( logger . log_tag , builder . tostring ( ) ) ; }	dump the contents of the cursor to the system log , formatted in a readable way.
static int computevalidlevels ( long bitpattern ) { return long . bitcount ( bitpattern ) ; }	computes the number of valid levels above the base buffer.
public static void rununderlock ( reentrantlock lock , runnable runnable ) { lock . lock ( ) ; try { runnable . run ( ) ; } finally { lock . unlock ( ) ; } }	run given runnable under given lock.
@ override public int insert ( string elem ) { int firstindex = ( int ) ( elem . charat ( _num ) - _str ) ; int lastindex = ( int ) ( elem . charat ( elem . length ( ) - _num ) - _str ) ; storage [ firstindex * _num + lastindex ] = elem ; return _num ; }	insert element into collection.
public void clearmovementdata ( ) { pathsprites = new arraylist < stepsprite > ( ) ; movementtarget = null ; checkfovheximagecacheclear ( ) ; repaint ( ) ; refreshmovevectors ( ) ; }	clears current movement data from the screen.
public void threadrecordfailure ( throwable t ) { threadfailure . compareandset ( null , t ) ; }	records an exception so that it can be rethrown later in the test harness thread , triggering a test case failure.
protected boolean replaycompletion ( participant participant ) throws illegalstateexception { if ( ! replaystack_ . contains ( participant ) ) { replaystack_ . push ( participant ) ; } return committed_ ; }	handle a replay request for a participant.
public void testdecoder7 ( ) { boolean res ; string originalappidname = mappidname ; int originalcontenttypevalue = mcontenttypevalue ; random rd = new random ( ) ; for ( int i = _num ; i < oma_content_type_names . length ; i ++ ) { mcontenttypename = oma_content_type_names [ i ] ; byte [ ] pdu = createpdu ( _num ) ; wsptypedecoder pdudecoder = new wsptypedecoder ( pdu ) ; res = pdudecoder . decodecontenttype ( mwspcontenttypestart ) ; asserttrue ( res ) ; log . d ( log_tag , _str + mcontenttypename + _str + pdudecoder . getvaluestring ( ) + _str ) ; asserttrue ( mcontenttypename . equals ( pdudecoder . getvaluestring ( ) ) ) ; } mappidname = originalappidname ; mcontenttypevalue = originalcontenttypevalue ; }	wsptypedecoder test , decode oma content type.
public void shutdownnow ( ) { shutdown = _bool ; final future < ? > f = enginefuture . get ( ) ; if ( f != null ) { if ( log . isinfoenabled ( ) ) log . info ( _str + this ) ; f . cancel ( _bool ) ; } final executorservice s = engineservice . get ( ) ; if ( s != null ) { if ( log . isinfoenabled ( ) ) log . info ( _str + this ) ; s . shutdownnow ( ) ; } final httpclient cm = clientconnectionmanagerref . get ( ) ; if ( cm != null ) { if ( log . isinfoenabled ( ) ) log . info ( _str + this ) ; try { cm . stop ( ) ; } catch ( exception e ) { log . error ( _str , e ) ; } } for ( abstractrunningquery q : runningqueries . values ( ) ) { q . cancel ( _bool ) ; } priorityqueue . clear ( ) ; deadlinequeue . clear ( ) ; enginefuture . set ( null ) ; engineservice . set ( null ) ; clientconnectionmanagerref . set ( null ) ; }	do not accept new queries and halt any running binding set chunk tasks .
static public void addnotificationlistener ( jmxconnector jmxconnector , class < ? > mbeanclass , notificationlistener notificationlistener ) throws instancenotfoundexception , exception { mbeanserverconnection mbsc = jmxconnector . getmbeanserverconnection ( ) ; objectname objectname = generatembeanobjectname ( mbeanclass ) ; mbsc . addnotificationlistener ( objectname , notificationlistener , null , null ) ; }	attach notificationlistener that can be used to listen notifications emitted by mbean server .
protected string tohtml ( string s ) { string result ; result = s ; result = result . replaceall ( _str , _str ) ; result = result . replaceall ( _str , _str ) ; result = result . replaceall ( _str , _str ) ; result = result . replaceall ( _str , _str ) ; result = result . replaceall ( _str , _str ) ; return result ; }	converts the given string into html , i.
protected void normalizescores ( ) { double hub_ssum = _num ; double auth_ssum = _num ; for ( v v : graph . getvertices ( ) ) { double hub_val = getoutputvalue ( v ) . hub ; double auth_val = getoutputvalue ( v ) . authority ; hub_ssum += ( hub_val * hub_val ) ; auth_ssum += ( auth_val * auth_val ) ; } hub_ssum = math . sqrt ( hub_ssum ) ; auth_ssum = math . sqrt ( auth_ssum ) ; for ( v v : graph . getvertices ( ) ) { hits . scores values = getoutputvalue ( v ) ; setoutputvalue ( v , new hits . scores ( values . hub / hub_ssum , values . authority / auth_ssum ) ) ; } }	normalizes scores so that sum of their squares = 1.
public static int absolutemax ( int [ ] intarray ) { int max = integer . min_value ; for ( int i = _num ; i < intarray . length ; i ++ ) { if ( math . abs ( intarray [ i ] ) > max && intarray [ i ] != _num ) { max = intarray [ i ] ; } } return max == integer . min_value ? _num : max ; }	gets the absolute maximum element of an integer array .
private boolean doacquirenanos ( long arg , long nanostimeout ) throws interruptedexception { if ( nanostimeout <= _num ) return _bool ; final long deadline = system . nanotime ( ) + nanostimeout ; final node node = addwaiter ( node . exclusive ) ; boolean failed = _bool ; try { for ( ; ; ) { final node p = node . predecessor ( ) ; if ( p == head && tryacquire ( arg ) ) { sethead ( node ) ; p . next = null ; failed = _bool ; return _bool ; } nanostimeout = deadline - system . nanotime ( ) ; if ( nanostimeout <= _num ) return _bool ; if ( shouldparkafterfailedacquire ( p , node ) && nanostimeout > spinfortimeoutthreshold ) locksupport . parknanos ( this , nanostimeout ) ; if ( thread . interrupted ( ) ) throw new interruptedexception ( ) ; } } finally { if ( failed ) cancelacquire ( node ) ; } }	acquires in exclusive timed mode .
boolean hasminfeaturecount ( string feature ) { if ( minfeaturecount == _num ) return _bool ; set < integer > ids = clippedfeatureindex . get ( feature ) ; if ( ids == null ) return _bool ; return ids . size ( ) >= minfeaturecount ; }	determine whether a feature has been seen enough times to learn a decoding model weight for it.
void mutate ( ) { do { int ibit ; do { ibit = m_random . nextint ( m_nnodes * m_nnodes ) ; } while ( issquare ( ibit ) ) ; m_bits [ ibit ] = ! m_bits [ ibit ] ; } while ( hascycles ( ) ) ; calcscore ( ) ; }	apply mutation operation to bayesnet calculate score and as a side effect sets bayesnet parent sets .
public void put ( e e ) throws interruptedexception { checknotnull ( e ) ; final reentrantlock lock = this . lock ; lock . lockinterruptibly ( ) ; try { while ( count == items . length ) notfull . await ( ) ; enqueue ( e ) ; } finally { lock . unlock ( ) ; } }	inserts the specified element at the tail of this queue , waiting for space to become available if the queue is full .
private void deletecomments ( spanmanager sm ) { int start = _num ; while ( ( start = sm . indexof ( _str , start ) ) != - _num ) { int end = sm . indexof ( _str , start + _num ) + _num ; if ( end == - _num + _num ) { end = sm . length ( ) ; } try { if ( lineseparator . equals ( sm . substring ( start - lineseparator . length ( ) , start ) ) && lineseparator . equals ( sm . substring ( end , end + lineseparator . length ( ) ) ) ) { end += lineseparator . length ( ) ; } } catch ( indexoutofboundsexception e ) { } sm . delete ( start , end ) ; } }	deleting all comments out of the spanmanager.
datetimeparsecontext ( datetimeformatter formatter ) { super ( ) ; this . formatter = formatter ; parsed . add ( new parsed ( ) ) ; }	creates a new instance of the context .
public static boolean isnetworktypecellular ( string networktype ) { return networktype . equals ( _str ) ; }	check if connected to cellular provider.
private void defineinternalframeclosebuttons ( uidefaults d ) { string p = _str ; string c = painter_prefix + _str ; d . put ( p + _str , _str ) ; d . put ( p + _str , new titlepaneclosebuttonwindownotfocusedstate ( ) ) ; d . put ( p + _str , new insetsuiresource ( _num , _num , _num , _num ) ) ; d . put ( p + _str , new lazypainter ( c , titlepaneclosebuttonpainter . which . background_disabled ) ) ; d . put ( p + _str , new lazypainter ( c , titlepaneclosebuttonpainter . which . background_enabled ) ) ; d . put ( p + _str , new lazypainter ( c , titlepaneclosebuttonpainter . which . background_mouseover ) ) ; d . put ( p + _str , new lazypainter ( c , titlepaneclosebuttonpainter . which . background_pressed ) ) ; d . put ( p + _str , new lazypainter ( c , titlepaneclosebuttonpainter . which . background_enabled_windownotfocused ) ) ; d . put ( p + _str , new lazypainter ( c , titlepaneclosebuttonpainter . which . background_mouseover ) ) ; d . put ( p + _str , new lazypainter ( c , titlepaneclosebuttonpainter . which . background_pressed_windownotfocused ) ) ; d . put ( p + _str , new seaglassicon ( p , _str , _num , _num ) ) ; }	initialize the internal frame close button settings .
private void modify ( storageport port , string portnetworkid ) { port . setportnetworkid ( portnetworkid ) ; dbclient . persistobject ( port ) ; modifiedstorageportslist . add ( port ) ; }	modify the port with new port network id .
public boolean is ( string word ) { return m_words . contains ( word . tolowercase ( ) ) ; }	returns true if the given string is a stop word .
public static final string removemultiplespacesandreturns ( final string data ) { final stringbuilder all_data = new stringbuilder ( data ) ; int i = _num ; while ( i < all_data . length ( ) ) { if ( ( ( all_data . charat ( i ) == _str ) && ( all_data . charat ( i - _num ) == _str ) ) || ( ( all_data . charat ( i ) == character . line_separator ) && ( all_data . charat ( i - _num ) == character . line_separator ) ) ) { all_data . deletecharat ( i ) ; } else { i ++ ; } } return all_data . tostring ( ) ; }	remove multiple spaces and returns so just single value if multiples together - if it fails will just return data.
public void removelistener ( connectabledevicelistener listener ) { listeners . remove ( listener ) ; }	removes a previously added conenctabledevicelistener from the list of listeners for this connectabledevice .
private void notifiydownloadstate ( ) { synchronized ( mdownloadmonitor ) { log . v ( log_tag , _str ) ; mdownloadmonitor . notify ( ) ; } }	send a notification via the mdownloadmonitor when a download is complete .
private pkixbuilderparameters createpkixbuilderparameters ( x509certificate endcert ) throws certificatepathbuildingexception { x509certselector targetconstraints = new x509certselector ( ) ; targetconstraints . setcertificate ( endcert ) ; pkixbuilderparameters params ; try { params = new pkixbuilderparameters ( truststore , targetconstraints ) ; params . setrevocationenabled ( _bool ) ; } catch ( keystoreexception e ) { throw new certificatepathbuildingexception ( _str + e . getmessage ( ) , e ) ; } catch ( invalidalgorithmparameterexception e ) { throw new certificatepathbuildingexception ( _str + e . getmessage ( ) , e ) ; } catch ( throwable e ) { throw new certificatepathbuildingexception ( _str + e . getmessage ( ) , e ) ; } collection < object > certcollection = new arraylist < object > ( ) ; addcertificatecandidates ( endcert , certcollection ) ; if ( ! certcollection . isempty ( ) ) { try { certstore certstore = certstore . getinstance ( _str , new collectioncertstoreparameters ( certcollection ) ) ; params . addcertstore ( certstore ) ; } catch ( invalidalgorithmparameterexception e ) { throw new certificatepathbuildingexception ( _str + e . getmessage ( ) , e ) ; } catch ( nosuchalgorithmexception e ) { throw new certificatepathbuildingexception ( _str + e . getmessage ( ) , e ) ; } } else { logger . debug ( _str ) ; } return params ; }	create and init pkixbuilderparameters for certpathbuilder .
public void printstacktrace ( ) { throwable t ; stringwriter writer ; writer = new stringwriter ( ) ; t = new throwable ( ) ; t . fillinstacktrace ( ) ; t . printstacktrace ( new printwriter ( writer ) ) ; println ( writer . tostring ( ) ) ; }	prints the current stacktrace.
protected int effectivebandsize ( final int dim1 , final int dim2 ) { if ( bandsize == double . positive_infinity ) { return ( dim1 > dim2 ) ? dim1 : dim2 ; } if ( bandsize >= _num ) { return ( int ) bandsize ; } return ( int ) math . ceil ( ( dim1 >= dim2 ? dim1 : dim2 ) * bandsize ) ; }	compute the effective band size .
public static int encodelongitudeceil ( double longitude ) { geoutils . checklongitude ( longitude ) ; if ( longitude == _num ) { longitude = math . nextdown ( longitude ) ; } return ( int ) math . ceil ( longitude / lon_decode ) ; }	quantizes double ( 64 bit ) longitude into 32 bits ( rounding up : in the direction of + 180 ).
private linkedlist < diff > diff_linemode ( string text1 , string text2 , long deadline ) { linestocharsresult b = diff_linestochars ( text1 , text2 ) ; text1 = b . chars1 ; text2 = b . chars2 ; list < string > linearray = b . linearray ; linkedlist < diff > diffs = diff_main ( text1 , text2 , _bool , deadline ) ; diff_charstolines ( diffs , linearray ) ; diff_cleanupsemantic ( diffs ) ; diffs . add ( new diff ( operation . equal , _str ) ) ; int count_delete = _num ; int count_insert = _num ; string text_delete = _str ; string text_insert = _str ; listiterator < diff > pointer = diffs . listiterator ( ) ; diff thisdiff = pointer . next ( ) ; while ( thisdiff != null ) { switch ( thisdiff . operation ) { case insert : count_insert ++ ; text_insert += thisdiff . text ; break ; case delete : count_delete ++ ; text_delete += thisdiff . text ; break ; case equal : if ( count_delete >= _num && count_insert >= _num ) { pointer . previous ( ) ; for ( int j = _num ; j < count_delete + count_insert ; j ++ ) { pointer . previous ( ) ; pointer . remove ( ) ; } for ( diff newdiff : diff_main ( text_delete , text_insert , _bool , deadline ) ) { pointer . add ( newdiff ) ; } } count_insert = _num ; count_delete = _num ; text_delete = _str ; text_insert = _str ; break ; } thisdiff = pointer . hasnext ( ) ? pointer . next ( ) : null ; } diffs . removelast ( ) ; return diffs ; }	do a quick line - level diff on both strings , then rediff the parts for greater accuracy.
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return id ; case _num : return create_time ; case _num : return update_time ; case _num : return operation ; case _num : return status ; case _num : return src_path ; case _num : return src_cluster ; case _num : return src_db ; case _num : return src_table ; case _num : return src_partitions ; case _num : return src_modified_time ; case _num : return rename_to_db ; case _num : return rename_to_table ; case _num : return rename_to_path ; case _num : return extras ; case _num : return waiting_on_jobs ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public jsonbuffer appendkeyhash ( object key ) { if ( stack . empty ( ) || stack . peek ( ) != operand . hash ) { throw new jsonexception ( _str ) ; } addquotedstring ( key ) ; buffer . append ( _str ) ; buffer . append ( _str ) ; stack . push ( operand . hash ) ; return this ; }	append a key an start a new hash.
static replaypromise < void > anyreplay ( final duration timeout , final promise < ? > ... promises ) { return anyreplay ( timeout , system . currenttimemillis ( ) , promises ) ; }	any promises must complete .
public static policyservice sendpllrequest ( url policyserviceurl , policyrequest preq ) throws sendrequestexception , policyexception { string lbcookie = null ; try { lbcookie = getlbcookie ( preq ) ; } catch ( exception e ) { throw new sendrequestexception ( e ) ; } policyservice policyservice = new policyservice ( ) ; policyservice . setmethodid ( policyservice . policy_request_id ) ; policyservice . setpolicyrequest ( preq ) ; string xmlstring = policyservice . toxmlstring ( ) ; request request = new request ( xmlstring ) ; requestset requestset = new requestset ( policyservice . policy_service ) ; requestset . addrequest ( request ) ; if ( debug . messageenabled ( ) ) { debug . message ( _str + _str + policyserviceurl + _str + xmlstring ) ; } vector responses = pllclient . send ( policyserviceurl , lbcookie , requestset ) ; response response = ( response ) responses . elementat ( _num ) ; policyservice ps = policyservice . parsexml ( response . getcontent ( ) ) ; if ( debug . messageenabled ( ) ) { debug . message ( _str + _str + ps . toxmlstring ( ) ) ; } return ps ; }	return a policyservice object based on the xml document received from remote policy server.
public static uri createid ( class < ? extends dataobject > clazz ) { return newid ( clazz , getlocation ( clazz ) ) ; }	creates a uri for an object of type clazz.
public static double log2 ( double x ) { return math . log ( x ) * one_by_log2 ; }	compute the base 2 logarithm .
public void insertelementat ( node value , int at ) { if ( ! m_mutable ) throw new runtimeexception ( xslmessages . createxpathmessage ( xpatherrorresources . er_nodeset_not_mutable , null ) ) ; if ( null == m_map ) { m_map = new node [ m_blocksize ] ; m_mapsize = m_blocksize ; } else if ( ( m_firstfree + _num ) >= m_mapsize ) { m_mapsize += m_blocksize ; node newmap [ ] = new node [ m_mapsize ] ; system . arraycopy ( m_map , _num , newmap , _num , m_firstfree + _num ) ; m_map = newmap ; } if ( at <= ( m_firstfree - _num ) ) { system . arraycopy ( m_map , at , m_map , at + _num , m_firstfree - at ) ; } m_map [ at ] = value ; m_firstfree ++ ; }	inserts the specified node in this vector at the specified index.
public result regress ( discretevariable x , list < node > regressors ) { if ( ! binary ( x ) ) { throw new illegalargumentexception ( _str ) ; } for ( node node : regressors ) { if ( ! ( node instanceof continuousvariable || binary ( node ) ) ) { throw new illegalargumentexception ( _str ) ; } } double [ ] [ ] _regressors = new double [ regressors . size ( ) ] [ getrows ( ) . length ] ; for ( int j = _num ; j < regressors . size ( ) ; j ++ ) { int col = dataset . getcolumn ( regressors . get ( j ) ) ; double [ ] datacol = datacols [ col ] ; for ( int i = _num ; i < getrows ( ) . length ; i ++ ) { _regressors [ j ] [ i ] = datacol [ getrows ( ) [ i ] ] ; } } int [ ] target = new int [ getrows ( ) . length ] ; int col = dataset . getcolumn ( dataset . getvariable ( x . getname ( ) ) ) ; for ( int i = _num ; i < getrows ( ) . length ; i ++ ) { target [ i ] = dataset . getint ( getrows ( ) [ i ] , col ) ; } list < string > regressornames = new arraylist < > ( ) ; for ( node node : regressors ) { regressornames . add ( node . getname ( ) ) ; } return regress ( target , x . getname ( ) , _regressors , regressornames ) ; }	x must be binary ; regressors must be continuous or binary .
void copyfile ( string source , string target ) ;	copy a file from a source to a destination.
static public list < sequence < istring > > tokenizefile ( string filename , boolean donist ) { list < sequence < istring > > sequences = new arraylist < > ( ) ; linenumberreader reader = iotools . getreaderfromfile ( filename ) ; try { for ( string line ; ( line = reader . readline ( ) ) != null ; ) { if ( donist ) line = nisttokenizer . tokenize ( line ) ; sequences . add ( istrings . tokenize ( line ) ) ; } reader . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return sequences ; }	convert a newline - delimited file to a list of sequences , optionally applying nist tokenization .
public statement like ( string expr ) { statement . append ( _str ) ; appendescapedsqlstring ( statement , expr ) ; return this ; }	appending the like operator clause .
public static kdbxheader readkdbxheader ( kdbxheader kdbxheader , inputstream inputstream ) throws ioexception { messagedigest digest = encryption . getmessagedigestinstance ( ) ; digestinputstream digestinputstream = new digestinputstream ( inputstream , digest ) ; littleendiandatainputstream ledis = new littleendiandatainputstream ( digestinputstream ) ; if ( ! verifymagicnumber ( ledis ) ) { throw new illegalstateexception ( _str ) ; } if ( ! verifyfileversion ( ledis ) ) { throw new illegalstateexception ( _str ) ; } byte headertype ; while ( ( headertype = ledis . readbyte ( ) ) != headertype . end ) { switch ( headertype ) { case headertype . comment : getbytearray ( ledis ) ; break ; case headertype . cipher_id : kdbxheader . setcipheruuid ( getbytearray ( ledis ) ) ; break ; case headertype . compression_flags : kdbxheader . setcompressionflags ( getint ( ledis ) ) ; break ; case headertype . master_seed : kdbxheader . setmasterseed ( getbytearray ( ledis ) ) ; break ; case headertype . transform_seed : kdbxheader . settransformseed ( getbytearray ( ledis ) ) ; break ; case headertype . transform_rounds : kdbxheader . settransformrounds ( getlong ( ledis ) ) ; break ; case headertype . encryption_iv : kdbxheader . setencryptioniv ( getbytearray ( ledis ) ) ; break ; case headertype . protected_stream_key : kdbxheader . setprotectedstreamkey ( getbytearray ( ledis ) ) ; break ; case headertype . stream_start_bytes : kdbxheader . setstreamstartbytes ( getbytearray ( ledis ) ) ; break ; case headertype . inner_random_stream_id : kdbxheader . setinnerrandomstreamid ( getint ( ledis ) ) ; break ; default : throw new illegalstateexception ( _str ) ; } } getbytearray ( ledis ) ; kdbxheader . setheaderhash ( digest . digest ( ) ) ; return kdbxheader ; }	populate a kdbxheader from the input stream supplied.
public static byte [ ] copytobytearray ( inputstream in ) throws ioexception { bytearrayoutputstream out = new bytearrayoutputstream ( buffer_size ) ; copy ( in , out ) ; return out . tobytearray ( ) ; }	copy the contents of the given inputstream into a new byte array.
public boolean isenumconstant ( ) { return ( getmodifiers ( ) & modifier . enum ) != _num ; }	indicates whether or not this field is an enumeration constant .
public boolean containsany ( collection < taxon > taxa ) { for ( taxon taxon : taxa ) { if ( taxa . contains ( taxon ) ) { return _bool ; } } return _bool ; }	returns true if at least 1 member of taxonlist is contained in this taxa .
@ suppresswarnings ( _str ) public synchronized t dequeuetask ( ) throws interruptedexception { while ( _data . isempty ( ) ) { if ( ! _closedinput ) wait ( ) ; else return ( t ) no_more_tasks ; } t t = _data . removefirst ( ) ; notify ( ) ; return t ; }	synchronized read and delete from the top of the fifo queue .
@ override public void readexternal ( objectinput in ) throws ioexception , classnotfoundexception { super . readexternal ( in ) ; this . facetname = in . readutf ( ) ; }	read the facet node in .
private boolean stringtoboolean ( string condition ) { boolean result = _bool ; if ( condition != null && condition . length ( ) > _num ) { string s = condition . substring ( _num , _num ) ; if ( s . equalsignorecase ( _str ) || s . equals ( _str ) || s . equalsignorecase ( _str ) ) result = _bool ; } return result ; }	converts string to boolean.
public static void writeuint32 ( long number , outputstream out ) throws ioexception { if ( number < _num ) { throw new illegalargumentexception ( _str ) ; } byte [ ] towrite = new byte [ _num ] ; for ( int i = _num ; i <= _num ; i += _num ) { towrite [ i / _num ] = ( byte ) ( ( number > > i ) & _num ) ; } out . write ( towrite ) ; }	writes the given value as uint32 into the stream .
public remotemetadataimpl ( schema schema ) throws remoteexception { this . schema = schema ; fields . addall ( schema . fields ( ) ) ; }	creates a metadata object that wraps the specified schema.
public void addswitchwithoptionalextrapart ( string option , string optionextrapartsynopsis , string description ) { optionlist . add ( option ) ; optionextrapartsynopsismap . put ( option , optionextrapartsynopsis ) ; optiondescriptionmap . put ( option , description ) ; int length = option . length ( ) + optionextrapartsynopsis . length ( ) + _num ; if ( length > maxwidth ) { maxwidth = length ; } }	add a command line switch that allows optional extra information to be specified as part of it .
public static object detectlinuxdefaultfilebrowser ( map < string , object > filebrowsers ) { arraylist < string > command = new arraylist < string > ( ) ; command . add ( _str ) ; command . add ( _str ) ; command . add ( _str ) ; command . add ( _str ) ; if ( filebrowsers == null ) { filebrowsers = new hashmap < string , object > ( ) ; filebrowsers . put ( _str , _str ) ; } return utils . isexpectedcommandoutput ( command , filebrowsers ) ; }	detects programs from $ desktop_session.
public void updated ( ) { currentcolor = htmlcolors . decode ( getsettingvalue ( ) ) ; secondarycolor = htmlcolors . decode ( basecolor ) ; color foregroundcolor ; color backgroundcolor ; if ( type == foreground ) { foregroundcolor = currentcolor ; backgroundcolor = secondarycolor ; } else { foregroundcolor = secondarycolor ; backgroundcolor = currentcolor ; } preview . setforeground ( foregroundcolor ) ; preview . setbackground ( backgroundcolor ) ; }	updates the preview and current color objects based on the saved colors .
public collection < ? extends immutableclasstype > removeinstrumentationpoints ( final collection < ? extends immutabletype > types ) { return removeinstrumentationpoints ( types , collections . < iinstrumentationapplier > singleton ( removeallinstrumentationapplier . getinstance ( ) ) ) ; }	removes all instrumentation point from the given types .
private record createrecord ( recordproperties recordproperties ) throws recordexception { string debugdirectory ; if ( isrecording ( ) ) { debugdirectory = previousdebugdirectory ; } else { debugdirectory = systempropertiesmanager . get ( debugconstants . config_debug_directory ) ; } string recorddirectory = debugdirectory + file . separator + recordconstants . record_folder_name + file . separator + recordproperties . getissueid ( ) + file . separator + recordproperties . getreferenceid ( ) ; record record = new record ( recordproperties , recorddirectory ) ; try { createfolder ( record . getfolderpath ( ) ) ; printwriter printwriterinfo = getprintwriterforfile ( record , recordconstants . info_file_name ) ; jsonvalue info = recordreport . inforeport ( record ) ; try { jsonobject json = new jsonobject ( info . tostring ( ) ) ; printwriterinfo . println ( json . tostring ( _num ) ) ; } catch ( jsonexception e ) { debug . warning ( _str , info , e ) ; printwriterinfo . println ( info ) ; } printwriterinfo . flush ( ) ; return record ; } catch ( ioexception e ) { debug . error ( _str , recordproperties , e ) ; throw new recordexception ( _str + recordproperties . getissueid ( ) + _str , e ) ; } }	create a new recorddebug.
public static laggededge serializableinstance ( ) { return new laggededge ( _str , laggedfactor . serializableinstance ( ) ) ; }	generates a simple exemplar of this class to test serialization .
private static int lengthofmimenames ( string val ) { int len = val . indexof ( _str ) ; if ( len < _num ) len = val . length ( ) ; return len ; }	get the length of the mime names within the property value.
public static boolean issha1string ( final string string ) { preconditions . checknotnull ( string , _str ) ; return ( string . length ( ) == _num ) && ishexstring ( string ) ; }	tests whether a given string is a valid sha1 string .
public boolean iswatched ( ) { return watched ; }	checks if is watched .
public void adddatechangelistener ( datechangelistener listener ) { datechangelisteners . add ( listener ) ; }	adddatechangelistener , this adds a date change listener to this date picker.
public static string stripfileprotocol ( string uristring ) { if ( uristring . startswith ( _str ) ) { uristring = uristring . substring ( _num ) ; } return uristring ; }	removes the " file : / / " prefix from the given uri string , if applicable.
public void replacetemplate ( elemtemplate v , int i ) throws transformerexception { if ( null == m_templates ) throw new arrayindexoutofboundsexception ( ) ; replacechild ( v , ( elemtemplateelement ) m_templates . elementat ( i ) ) ; m_templates . setelementat ( v , i ) ; v . setstylesheet ( this ) ; }	replace an " xsl : template " property.
public rotatedproblem ( problem problem , realmatrix rotation ) { super ( ) ; this . problem = problem ; this . rotation = rotation ; solution solution = problem . newsolution ( ) ; center = new double [ getnumberofvariables ( ) ] ; lowerbounds = new double [ getnumberofvariables ( ) ] ; upperbounds = new double [ getnumberofvariables ( ) ] ; for ( int i = _num ; i < getnumberofvariables ( ) ; i ++ ) { realvariable variable = ( realvariable ) solution . getvariable ( i ) ; center [ i ] = ( variable . getlowerbound ( ) + variable . getupperbound ( ) ) / _num ; lowerbounds [ i ] = math . sqrt ( _num ) * ( variable . getlowerbound ( ) - center [ i ] ) ; upperbounds [ i ] = math . sqrt ( _num ) * ( variable . getupperbound ( ) - center [ i ] ) ; } }	decorates the specified problem , creating a rotated instance using the specified rotation matrix .
public void characters ( char ch [ ] , int start , int length ) throws saxexception { m_curvalue . append ( ch , start , length ) ; }	receive notification of character data inside an element .
public boolean regenerate ( projection proj ) { boolean ret = super . regenerate ( proj ) ; if ( proj != null && ! ret ) { ret = generate ( proj ) ; } return ret ; }	overrides omgraphicadapter version to handle omrasterobject getneedtoreposition .
@ override public byte [ ] unwrap ( final byte [ ] incoming , final int offset , final int len ) throws ldapexception { final byte [ ] copy = new byte [ len ] ; system . arraycopy ( incoming , offset , copy , _num , len ) ; return copy ; }	default implementation just returns the copy of the bytes .
private int sequentialforwardselection ( string datafile , string [ ] features , int indvarcolnumber , int x [ ] , int y [ ] , double j [ ] , int rowini , int rowend ) { double sig [ ] = new double [ y . length ] ; int sigindex [ ] = new int [ y . length ] ; double corxplusy [ ] = new double [ y . length ] ; double corx ; if ( x . length > _num ) { regression reg = new regression ( ) ; reg . multiplelinearregression ( datafile , indvarcolnumber , x , features , interceptterm , rowini , rowend ) ; corx = reg . getcorrelation ( ) ; } else corx = _num ; for ( int i = _num ; i < y . length ; i ++ ) { corxplusy [ i ] = correlationofnewfeature ( datafile , features , indvarcolnumber , x , y [ i ] , rowini , rowend ) ; sig [ i ] = corxplusy [ i ] - corx ; sigindex [ i ] = y [ i ] ; } int minsig = mathutils . getminindex ( sig ) ; j [ _num ] = corxplusy [ minsig ] ; j [ _num ] = corx ; int maxsig = mathutils . getmaxindex ( sig ) ; j [ _num ] = corxplusy [ maxsig ] ; return sigindex [ maxsig ] ; }	find the f feature in y that maximise j ( x + y ).
private static byte [ ] codestobytes ( string codes , boolean required ) { if ( codes . length ( ) == _num ) { if ( required ) { throw new illegalstateexception ( _str ) ; } return null ; } if ( ( codes . length ( ) % _num ) != _num ) { codes = _str + codes ; } byte [ ] bytes = new byte [ codes . length ( ) / _num ] ; for ( int i = _num ; i < bytes . length ; ++ i ) { int charidx = i * _num ; bytes [ i ] = ( byte ) ( integer . parseint ( codes . substring ( charidx , charidx + _num ) , _num ) ) ; } return bytes ; }	converts a string of hex encoded bytes to a byte [ ] , optionally throwing an exception if no codes are given .
public dragentry dragselectedentry ( ) { try { keystorehistory history = getactivekeystorehistory ( ) ; if ( history == null ) { return null ; } keystorestate currentstate = history . getcurrentstate ( ) ; keystore keystore = currentstate . getkeystore ( ) ; string alias = getselectedentryalias ( ) ; if ( alias == null ) { return null ; } if ( keystoreutil . iskeyentry ( alias , keystore ) ) { joptionpane . showmessagedialog ( frame , res . getstring ( _str ) , kse . getapplicationname ( ) , joptionpane . warning_message ) ; return null ; } if ( keystoreutil . iskeypairentry ( alias , keystore ) ) { password password = currentstate . getentrypassword ( alias ) ; keystoretype type = keystoretype . resolvejce ( keystore . gettype ( ) ) ; if ( password == null && type . hasentrypasswords ( ) ) { joptionpane . showmessagedialog ( frame , res . getstring ( _str ) , kse . getapplicationname ( ) , joptionpane . warning_message ) ; return null ; } privatekey privatekey = ( privatekey ) keystore . getkey ( alias , password . tochararray ( ) ) ; certificate [ ] certificatechain = keystore . getcertificatechain ( alias ) ; return new dragkeypairentry ( alias , privatekey , password , certificatechain ) ; } else { certificate trustedcertificate = keystore . getcertificate ( alias ) ; return new dragtrustedcertificateentry ( alias , trustedcertificate ) ; } } catch ( exception ex ) { derror . displayerror ( frame , ex ) ; return null ; } }	get a the selected entry as a drag entry for dnd .
public void insert ( t object , int index ) { synchronized ( mlock ) { if ( moriginalvalues != null ) { moriginalvalues . add ( index , object ) ; } else { mobjects . add ( index , object ) ; } } if ( mnotifyonchange ) notifydatasetchanged ( ) ; }	inserts the specified object at the specified index in the array .
public double reduce ( string numericcolumnname , numericreducefunction function ) { column column = column ( numericcolumnname ) ; return function . reduce ( column . todoublearray ( ) ) ; }	returns the result of applying the given function to the specified column.
public void testsetbitnegativeoutside1 ( ) { byte abytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = - _num ; int number = _num ; byte rbytes [ ] = { - _num , _num , - _num , - _num , _num , _num , - _num , - _num , - _num , - _num , _num , - _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . setbit ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , result . signum ( ) ) ; }	setbit ( int n ) outside a negative number.
static public string formatuint8char ( byte b ) { string ch = new string ( new byte [ ] { b } ) ; ch = ch . replaceall ( _str , _str ) ; return formatuint8 ( b ) + _str + ch ; }	utility method to print a byte in hexa an ascii.
public static final arraylist < move > removeillegal ( position pos , arraylist < move > movelist ) { arraylist < move > ret = new arraylist < move > ( ) ; undoinfo ui = new undoinfo ( ) ; int mlsize = movelist . size ( ) ; for ( int mi = _num ; mi < mlsize ; mi ++ ) { move m = movelist . get ( mi ) ; pos . makemove ( m , ui ) ; pos . setwhitemove ( ! pos . whitemove ) ; if ( ! incheck ( pos ) ) ret . add ( m ) ; pos . setwhitemove ( ! pos . whitemove ) ; pos . unmakemove ( m , ui ) ; } return ret ; }	remove all illegal moves from movelist.
public static int applymaskpenaltyrule4 ( bytematrix matrix ) { int numdarkcells = _num ; byte [ ] [ ] array = matrix . getarray ( ) ; int width = matrix . getwidth ( ) ; int height = matrix . getheight ( ) ; for ( int y = _num ; y < height ; ++ y ) { for ( int x = _num ; x < width ; ++ x ) { if ( array [ y ] [ x ] == _num ) { numdarkcells += _num ; } } } int numtotalcells = matrix . getheight ( ) * matrix . getwidth ( ) ; double darkratio = ( double ) numdarkcells / numtotalcells ; return math . abs ( ( int ) ( darkratio * _num - _num ) ) / _num * _num ; }	apply mask penalty rule 4 and return the penalty.
private void checkstate ( ) { if ( diagramretrieved ) { throw new illegalstateexception ( _str ) ; } }	throws an exception if the diagram was already returned.
static hashtable converttohash ( map m ) { hashtable rethash = new hashtable ( ) ; set s = m . keyset ( ) ; iterator iter = s . iterator ( ) ; while ( iter . hasnext ( ) ) { string key = ( string ) iter . next ( ) ; set val = ( set ) m . get ( key ) ; rethash . put ( key , settostring ( val ) ) ; } return rethash ; }	this will convert updated naming attributes map into naming hashtable.
public void actionperformed ( actionevent evt ) { }	this method is called when the soft button / menu item is clicked.
public boolean equal_at_start ( plapointint p_point ) { if ( p_point == null ) return _bool ; plapoint first = corner_first ( ) ; return first . equals ( p_point ) ; }	returns true of the given point is equal at start of polyline.
public void foreachblockdepthfirst ( boolean reverse , ssabasicblock . visitor v ) { bitset visited = new bitset ( blocks . size ( ) ) ; stack < ssabasicblock > stack = new stack < ssabasicblock > ( ) ; ssabasicblock rootblock = reverse ? getexitblock ( ) : getentryblock ( ) ; if ( rootblock == null ) { return ; } stack . add ( null ) ; stack . add ( rootblock ) ; while ( stack . size ( ) > _num ) { ssabasicblock cur = stack . pop ( ) ; ssabasicblock parent = stack . pop ( ) ; if ( ! visited . get ( cur . getindex ( ) ) ) { bitset children = reverse ? cur . getpredecessors ( ) : cur . getsuccessors ( ) ; for ( int i = children . nextsetbit ( _num ) ; i >= _num ; i = children . nextsetbit ( i + _num ) ) { stack . add ( cur ) ; stack . add ( blocks . get ( i ) ) ; } visited . set ( cur . getindex ( ) ) ; v . visitblock ( cur , parent ) ; } } }	walks the basic block tree in depth - first order , calling the visitor method once for every block.
protected void fillpath ( ) { mpsstream . println ( mfillopstr ) ; }	fill the current path using the current fill mode and color .
public boolean islastwindow ( accessibilitywindowinfo basewindow , int windowtype ) { int index = getwindowindex ( basewindow ) ; if ( index == wrong_index ) { return _bool ; } int count = mwindows . size ( ) ; for ( int i = index + _num ; i < count ; i ++ ) { accessibilitywindowinfo window = mwindows . get ( i ) ; if ( window != null && window . gettype ( ) == windowtype ) { return _bool ; } } return _bool ; }	returns true if there is no window with windowtype after basewindow.
public void passpgsessionmapex ( viewbean other ) { map attributes = getpagesessionattributes ( ) ; for ( iterator i = retainpagesessionsbtwtabs . iterator ( ) ; i . hasnext ( ) ; ) { string key = ( string ) i . next ( ) ; other . setpagesessionattribute ( key , ( serializable ) attributes . get ( key ) ) ; } other . setpagesessionattribute ( gettrackingtabidname ( ) , ( serializable ) attributes . get ( gettrackingtabidname ( ) ) ) ; }	pass session attribute map to other view bean .
public long time ( ) { return heartbeattime ; }	returns the current commit time .
public boolean hitclip ( int x , int y , int width , int height ) { return g . hitclip ( x , y , width , height ) ; }	returns true if the specified rectangular area intersects the bounding rectangle of the current clipping area.
public static closewatcher pollunclosed ( ) { referencequeue < object > q = queue ; if ( q == null ) { return null ; } while ( _bool ) { closewatcher cw = ( closewatcher ) q . poll ( ) ; if ( cw == null ) { return null ; } if ( refs != null ) { refs . remove ( cw ) ; } if ( cw . closeable != null ) { return cw ; } } }	check for an collected object .
private static boolean appendodexestoclasspath ( context cxt , file dexdir , string [ ] names ) { string strdexdir = dexdir . getabsolutepath ( ) ; arraylist < string > jarpaths = new arraylist < string > ( ) ; for ( int i = _num ; i < names . length ; i ++ ) { string jarpath = strdexdir + _str + names [ i ] ; file f = new file ( jarpath ) ; if ( f . isfile ( ) ) { jarpaths . add ( jarpath ) ; } } string [ ] jarsofdex = new string [ jarpaths . size ( ) ] ; jarpaths . toarray ( jarsofdex ) ; pathclassloader pcl = ( pathclassloader ) cxt . getclassloader ( ) ; try { if ( build . version . sdk_int < sdk_int_ics ) { frameworkhack . appenddexlistimplunderics ( jarsofdex , pcl , dexdir ) ; } else { boolean kitkatplus = build . version . sdk_int >= sdk_int_kitkat ; boolean marshmallowplus = build . version . sdk_int >= sdk_int_marshmallow ; arraylist < file > jarfiles = dexdex . strings2files ( jarsofdex ) ; frameworkhack . appenddexlistimplics ( jarfiles , pcl , dexdir , kitkatplus , marshmallowplus ) ; } for ( string jarname : names ) { theappended . add ( jarname ) ; } if ( debug ) { log . d ( tag , _str + pcl ) ; log . d ( tag , _str + theappended ) ; } } catch ( exception ex ) { throw new runtimeexception ( ex ) ; } return _bool ; }	append dexoptimized dex files to the classpath .
@ override public final int readint ( ) throws ioexception { dis . readfully ( work , _num , _num ) ; return ( work [ _num ] ) << _num | ( work [ _num ] & _num ) << _num | ( work [ _num ] & _num ) << _num | ( work [ _num ] & _num ) ; }	read an int , 32 - bits.
private void assertserializeanddesdatetime ( string datetimestring ) throws ryatyperesolverexception { assertserializeanddesdatetime ( datetimestring , datetimestring ) ; }	do the test on the datetime.
public boolean ishardmode ( ) { return ishardmode ; }	gets whether it is hard mode.
protected string doit ( ) throws exception { setup ( ) ; for ( mwarehouse warehouse : warehouses ) for ( mcosttype costtype : costtypes ) for ( mcostelement costelement : costelements ) for ( int productid : products ) generateinventoryvalue ( productid , costtype . getm_costtype_id ( ) , costelement . getm_costelement_id ( ) , warehouse . getm_warehouse_id ( ) ) ; pstmt . executebatch ( ) ; commitex ( ) ; db . close ( pstmt ) ; db . executeupdate ( _str + db . to_date ( p_datevalue ) + _str , getad_pinstance_id ( ) , get_trxname ( ) ) ; return _str + count ; }	execute the valuation effective date.
public void run ( ) { setup ( ) ; log . info ( _str ) ; for ( taskstoragemanager taskstoragemanager : taskstoragemanagers ) { taskstoragemanager . init ( ) ; taskstoragemanager . stopstores ( ) ; log . debug ( _str + taskstoragemanager . tostring ( ) ) ; } log . info ( _str + storebasedir . tostring ( ) ) ; }	run the setup phase and restore all the task storages.
public void read ( int i ) { variablevalue v = rowvector . elementat ( i ) ; v . readall ( ) ; }	command reading of a particular variable.
protected list < expression > transformexpressions ( list < ? extends expression > expressions , expressiontransformer transformer ) { list < expression > list = new arraylist < expression > ( expressions . size ( ) ) ; for ( expression expr : expressions ) { list . add ( transformer . transform ( expr ) ) ; } return list ; }	transforms the list of expressions.
public string prefixforward ( int length ) { final string prefix = prefix ( length ) ; this . pointer += length ; this . index += length ; this . column += length ; return prefix ; }	prefix ( length ) immediately followed by forward ( length ).
private boolean canaddtask ( ) { return tcur == null ; }	returns whether the task queue is not full .
public void flush ( ) throws ioexception { if ( printwriter != null ) { printwriter . flush ( ) ; } if ( gzipoutputstream != null ) { gzipoutputstream . flush ( ) ; } }	flushes all the streams for this response .
public int start ( ) { started . compareandset ( _bool , _bool ) ; server . start ( ) ; return server . getserverport ( ) ; }	start the server and return the port that the server bound to .
public static double angle ( tuple3d a , tuple3d b ) { double dx = b . x - a . x ; double dy = b . y - a . y ; double angle = _num ; if ( dx == _num ) { if ( dy == _num ) angle = _num ; else if ( dy > _num ) angle = math . pi / _num ; else angle = ( math . pi * _num ) / _num ; } else if ( dy == _num ) { if ( dx > _num ) angle = _num ; else angle = math . pi ; } else { if ( dx < _num ) angle = math . atan ( dy / dx ) + math . pi ; else if ( dy < _num ) angle = math . atan ( dy / dx ) + ( _num * math . pi ) ; else angle = math . atan ( dy / dx ) ; } return angle ; }	compute the angle between the first and second point .
public void addstringtotable ( byte [ ] oldstring , byte newstring ) { int length = oldstring . length ; byte [ ] str = new byte [ length + _num ] ; system . arraycopy ( oldstring , _num , str , _num , length ) ; str [ length ] = newstring ; stringtable [ tableindex ++ ] = str ; if ( tableindex == _num ) { bitstoget = _num ; } else if ( tableindex == _num ) { bitstoget = _num ; } else if ( tableindex == _num ) { bitstoget = _num ; } }	add a new string to the string table .
public static boolean identical ( uri first , uri second ) { if ( ( first != null ) && ( second != null ) ) { return first . equals ( second ) ; } return _bool ; }	determines if the ids are equal ( and non - null ) .
default < st > xor < st , t > toxor ( final st secondary ) { final optional < t > o = tooptional ( ) ; return o . ispresent ( ) ? xor . primary ( o . get ( ) ) : xor . secondary ( secondary ) ; }	convert to an xor where the secondary value will be used if no primary value is present.
public void processinvite ( requestevent requestevent , servertransaction servertransaction ) { sipprovider sipprovider = ( sipprovider ) requestevent . getsource ( ) ; request request = requestevent . getrequest ( ) ; logger . info ( _str + request ) ; timer . schedule ( new delayedinviteresponsestask ( requestevent , sipprovider ) , _num ) ; }	process the invite request .
protected instances datafromxml ( instances header ) throws exception { instances result ; element node ; vector < element > list ; list = getchildtags ( m_document . getdocumentelement ( ) , tag_body ) ; node = list . get ( _num ) ; list = getchildtags ( node , tag_instances ) ; node = list . get ( _num ) ; result = createinstances ( header , node ) ; return result ; }	generates the complete dataset from the xml document.
private static string prependifmissing ( final string str , final charsequence prefix , final boolean ignorecase , final charsequence ... prefixes ) { if ( str == null || isempty ( prefix ) || startswith ( str , prefix , ignorecase ) ) { return str ; } if ( prefixes != null && prefixes . length > _num ) { for ( final charsequence p : prefixes ) { if ( startswith ( str , p , ignorecase ) ) { return str ; } } } return prefix . tostring ( ) + str ; }	prepends the prefix to the start of the string if the string does not already start with any of the prefixes .
protected cachedistributionadvisor createdistributionadvisor ( internalregionarguments internalregionargs ) { return cachedistributionadvisor . createcachedistributionadvisor ( this ) ; }	intended for used during construction of a distributedregion.
public void addmouselistener ( globalmouselistener listener ) { listeners . add ( listener ) ; }	adds a global mouse listener.
private vector1d finiteornullpoint ( final double x ) { return double . isinfinite ( x ) ? null : new vector1d ( x ) ; }	build a finite point .
public void loadpdf ( final file input ) { if ( input == null ) { return ; } scale = _num ; pdffile = input . getabsolutepath ( ) ; fileloc . settext ( pdffile ) ; openfile ( input , null , _bool ) ; }	take a file handle to pdf file on local filesystem and displays in pdf viewer.
public charbuffer append ( object obj ) { return append ( string . valueof ( obj ) ) ; }	appends the string representation of the object to the buffer .
public void testintbyint1 ( ) { byte abytes [ ] = { _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num } ; int asign = _num ; int bsign = - _num ; byte rbytes [ ] = { - _num , - _num , - _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . multiply ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , result . signum ( ) ) ; }	multiply two numbers of 4 bytes length .
private static void checkfilevalidation ( file file ) { if ( file == null ) throw new nullpointerexception ( _str ) ; if ( ! file . exists ( ) ) { throw new illegalargumentexception ( _str + file . getpath ( ) + _str ) ; } file . canread ( ) ; }	checks if the file is a valid file and readable .
public < resultt > set < resultt > toset ( converter < resultt > converter ) { try { if ( isempty ( cursor ) ) { return collections . emptyset ( ) ; } return populate ( converter , new hashset < resultt > ( cursor . getcount ( ) ) ) ; } finally { close ( ) ; } }	transforms all rows from the cursor and put them in a read - only set .
public static void stashdisableassertionarg ( string arg ) { if ( arg == null || arg . equals ( _str ) ) { assertionsenabled = _bool ; } else { disabledassertionstrings = arg . split ( _str ) ; } }	remember the given disable assertions string.
public iterator < stream > memberiterator ( ) { return memberset . iterator ( ) ; }	get iterator over the members of the class .
private void cleanmapping ( ) { arraylist < integer > toremove = new arraylist < integer > ( ) ; int size = mlistmapping . size ( ) ; for ( int i = _num ; i < size ; ++ i ) { if ( mlistmapping . keyat ( i ) == mlistmapping . valueat ( i ) ) { toremove . add ( mlistmapping . keyat ( i ) ) ; } } size = toremove . size ( ) ; for ( int i = _num ; i < size ; ++ i ) { mlistmapping . delete ( toremove . get ( i ) ) ; } }	remove unnecessary mappings from sparse array .
public static string timeuntil ( final int seconds , final boolean forceseconds ) { final stringbuilder sbuf = new stringbuilder ( ) ; timeuntil ( sbuf , seconds , forceseconds ) ; return sbuf . tostring ( ) ; }	create a text representing a saying of time until .
public void remove ( t item ) { if ( set . remove ( item ) ) { firecontentschanged ( this , _num , getsize ( ) - _num ) ; } }	removes the specified item from this list model .
public static void append ( file file , reader reader , string charset ) throws ioexception { append ( file , reader , charset , _bool ) ; }	append the text supplied by the reader at the end of the file without writing a bom , using a specified encoding .
void parseignoredsection ( ) throws ioexception { int depth = _num ; in . replace ++ ; while ( _bool ) { switch ( ch ) { case _str : if ( ( ch = in . read ( ) ) == _str ) { if ( ( ch = in . read ( ) ) == _str ) { ch = in . read ( ) ; depth ++ ; } } break ; case _str : if ( ( ch = in . read ( ) ) == _str ) { if ( ( ch = in . read ( ) ) == _str ) { ch = in . read ( ) ; if ( -- depth == _num ) { in . replace -- ; return ; } } } break ; case - _num : error ( _str ) ; in . replace -- ; return ; default : ch = in . read ( ) ; break ; } } }	parse an ignored section until ] ] > is encountered .
private synchronized int readrecordlength ( ) throws ioexception { if ( in . getpos ( ) >= end ) { return - _num ; } int length = in . readint ( ) ; if ( sync != null && length == sync_escape ) { in . readfully ( synccheck ) ; if ( ! arrays . equals ( sync , synccheck ) ) { throw new ioexception ( _str ) ; } syncseen = _bool ; if ( in . getpos ( ) >= end ) { return - _num ; } length = in . readint ( ) ; } else { syncseen = _bool ; } return length ; }	read and return the next record length , potentially skipping over a sync block .
public void addslide ( @ nonnull fragment fragment ) { fragments . add ( fragment ) ; if ( iswizardmode ) { setoffscreenpagelimit ( fragments . size ( ) ) ; } mpageradapter . notifydatasetchanged ( ) ; }	adds a new slide.
public defaultintervalcategorydataset ( comparable [ ] serieskeys , comparable [ ] categorykeys , number [ ] [ ] starts , number [ ] [ ] ends ) { this . startdata = starts ; this . enddata = ends ; if ( starts != null && ends != null ) { string basename = _str ; resourcebundle resources = resourcebundlewrapper . getbundle ( basename ) ; int seriescount = starts . length ; if ( seriescount != ends . length ) { string errmsg = _str + _str + _str + _str ; throw new illegalargumentexception ( errmsg ) ; } if ( seriescount > _num ) { if ( serieskeys != null ) { if ( serieskeys . length != seriescount ) { throw new illegalargumentexception ( _str + _str ) ; } this . serieskeys = serieskeys ; } else { string prefix = resources . getstring ( _str ) + _str ; this . serieskeys = generatekeys ( seriescount , prefix ) ; } int categorycount = starts [ _num ] . length ; if ( categorycount != ends [ _num ] . length ) { string errmsg = _str + _str + _str + _str ; throw new illegalargumentexception ( errmsg ) ; } if ( categorykeys != null ) { if ( categorykeys . length != categorycount ) { throw new illegalargumentexception ( _str + _str ) ; } this . categorykeys = categorykeys ; } else { string prefix = resources . getstring ( _str ) + _str ; this . categorykeys = generatekeys ( categorycount , prefix ) ; } } else { this . serieskeys = new comparable [ _num ] ; this . categorykeys = new comparable [ _num ] ; } } }	constructs a defaultintervalcategorydataset , populates it with data from the arrays , and uses the supplied names for the series and the supplied objects for the categories .
public void translate ( double dx , double dy ) { if ( ! isrelative ( ) ) { x += dx ; y += dy ; } if ( sourcepoint != null ) { sourcepoint . setx ( sourcepoint . getx ( ) + dx ) ; sourcepoint . sety ( sourcepoint . gety ( ) + dy ) ; } if ( targetpoint != null ) { targetpoint . setx ( targetpoint . getx ( ) + dx ) ; targetpoint . sety ( targetpoint . gety ( ) + dy ) ; } if ( translate_control_points && points != null ) { int count = points . size ( ) ; for ( int i = _num ; i < count ; i ++ ) { mxpoint pt = ( mxpoint ) points . get ( i ) ; pt . setx ( pt . getx ( ) + dx ) ; pt . sety ( pt . gety ( ) + dy ) ; } } }	translates the geometry by the specified amount.
public abstract void fill ( bytebuffer buffer , long id ) ;	this method adds to the byte - buffer , the token indicating the type of the passed ' id ' ( threadid or sequenceid ) and the optimal byte array representing the id depending on the value of the ' id ' .
private string anonymizepassword ( string password ) { if ( password == null ) { return _str ; } stringbuilder sb = new stringbuilder ( ) ; for ( int i = _num ; i < password . length ( ) ; i ++ ) { sb . append ( _str ) ; } return sb . tostring ( ) ; }	make a password into asterisks of the right length , for logging .
public final void write ( final byte [ ] data ) { bytebuffer . put ( data ) ; }	write the data in the buffer .
public void close ( ) throws ioexception { inputstream . close ( ) ; }	closes the underlying parser .
public address malloc ( int size , int howmany ) { int result = nextreservableaddress ; nextreservableaddress += size * howmany ; if ( nextreservableaddress > ( memsize + memaddressstart ) ) { addressoutofrange = _bool ; return null ; } return new address ( op . mem , size , result ) ; }	allocates / reservates memory : a specified block size in bytes , multiplied by a given number of blocks.
public static string maskleft ( string s , int len , char mask_ch ) { if ( len <= _num ) { return s ; } len = math . min ( len , s . length ( ) ) ; stringbuilder sb = new stringbuilder ( ) ; for ( int i = _num ; i < len ; i ++ ) { sb . append ( mask_ch ) ; } sb . append ( s . substring ( len ) ) ; return sb . tostring ( ) ; }	returns a string consisting of " s " , with each of the first " len " characters replaced by " mask_ch " character .
public static double pdf ( double x , double mu , double sigma , double skew ) { x = ( x - mu ) / sigma ; if ( math . abs ( skew ) > _num ) { x = - math . log ( _num - skew * x ) / skew ; } return mathutil . sqrthalf * math . exp ( - _num * x * x ) / sigma / ( _num - skew * x ) ; }	probability density function of the skewed normal distribution .
public composer to ( long animduration , float x , float y , int alpha , float scalex , float scaley , float rotation , ease ease ) { mtweenparameterlist . add ( new tweenparameter ( x , y , alpha , scalex , scaley , rotation , animduration , ease ) ) ; return this ; }	queues a tween from the current values to the target properties.
@ override public string tostring ( ) { stringbuilder buffer = new stringbuilder ( _num ) ; try { print ( buffer ) ; } catch ( ioexception e ) { throw new runtimeexception ( _str , e ) ; } return buffer . tostring ( ) ; }	returns the string representation ( in ion format ) of this timestamp in its local time .
@ override public memchunkholder < bigdatamemallocator > createchunk ( long size , boolean autoreclaim ) { memchunkholder < bigdatamemallocator > ret = null ; long addr = m_vmasvc . allocate ( m_nid , size , _bool ) ; if ( _num == addr && m_activegc ) { forcegc ( ) ; addr = m_vmasvc . allocate ( m_nid , size , _bool ) ; } if ( _num != addr ) { ret = new memchunkholder < bigdatamemallocator > ( this , addr , size ) ; ret . setcollector ( m_chunkcollector ) ; if ( autoreclaim ) { m_chunkcollector . register ( ret ) ; } } return ret ; }	create a memory chunk that is managed by its holder .
public single < taccesstoken > grantnewaccesstoken ( oauth2grant < taccesstoken > grant ) { return grantnewaccesstoken ( grant , calendar . getinstance ( ) ) ; }	grants a new access token using the given oauth2 grant .
public static number floor ( number a ) { if ( isfloatingpoint ( a ) ) { return math . floor ( a . doublevalue ( ) ) ; } else { return a . longvalue ( ) ; } }	returns the largest integer value less than or equal to the given number .
private void readdefselement ( ixmlelement elem ) throws ioexception { for ( ixmlelement child : elem . getchildren ( ) ) { figure childfigure = readelement ( child ) ; } }	reads an svg " defs " element .
@ nullable private static activitywrapper findlauncheractivityfordevice ( @ notnull list < activitywrapper > launchableactivities , @ notnull idevice device ) { if ( device . supportsfeature ( idevice . hardwarefeature . tv ) ) { return findleanbacklauncher ( launchableactivities ) ; } return null ; }	returns a launchable activity specific to the given device .
public boolean isqueryrunning ( final boundentity song ) { synchronized ( mrunningqueries ) { return mrunningqueries . contains ( song ) ; } }	returns whether or not a query is currently running for the provided song.
private response < bitmap > doparse ( networkresponse response ) { byte [ ] data = response . data ; bitmapfactory . options decodeoptions = new bitmapfactory . options ( ) ; bitmap bitmap = null ; if ( mmaxwidth == _num && mmaxheight == _num ) { decodeoptions . inpreferredconfig = mdecodeconfig ; bitmap = bitmapfactory . decodebytearray ( data , _num , data . length , decodeoptions ) ; } else { decodeoptions . injustdecodebounds = _bool ; bitmapfactory . decodebytearray ( data , _num , data . length , decodeoptions ) ; int actualwidth = decodeoptions . outwidth ; int actualheight = decodeoptions . outheight ; int desiredwidth = getresizeddimension ( mmaxwidth , mmaxheight , actualwidth , actualheight ) ; int desiredheight = getresizeddimension ( mmaxheight , mmaxwidth , actualheight , actualwidth ) ; decodeoptions . injustdecodebounds = _bool ; decodeoptions . insamplesize = findbestsamplesize ( actualwidth , actualheight , desiredwidth , desiredheight ) ; bitmap tempbitmap = bitmapfactory . decodebytearray ( data , _num , data . length , decodeoptions ) ; if ( tempbitmap != null && ( tempbitmap . getwidth ( ) > desiredwidth || tempbitmap . getheight ( ) > desiredheight ) ) { bitmap = bitmap . createscaledbitmap ( tempbitmap , desiredwidth , desiredheight , _bool ) ; tempbitmap . recycle ( ) ; } else { bitmap = tempbitmap ; } } if ( bitmap == null ) { return response . error ( new parseerror ( response ) ) ; } else { return response . success ( bitmap , httpheaderparser . parsecacheheaders ( response ) ) ; } }	the real guts of parsenetworkresponse.
private map < string , extensionfilefilter > addextensions ( jfilechooser chooser ) { map < string , extensionfilefilter > filters = new hashmap < string , extensionfilefilter > ( ) ; for ( map . entry < string , string > entry : exts . entryset ( ) ) { extensionfilefilter filter = new extensionfilefilter ( entry . getkey ( ) , entry . getvalue ( ) ) ; filters . put ( entry . getkey ( ) , filter ) ; chooser . addchoosablefilefilter ( filter ) ; } return filters ; }	adds the filters for the extensions to the provided chooser .
public static string withnodeinfo ( accessibilitynodeinfo nodeinfo ) { if ( nodeinfo == null ) { return null ; } return string . format ( _str , nodeinfo . gettext ( ) , nodeinfo . getcontentdescription ( ) ) ; }	return the identify string of a node.
static int allparametersandargumentsmatchwithdefaultparams ( parameter [ ] params , classnode [ ] args ) { int dist = _num ; classnode ptype = null ; for ( int i = _num , j = _num ; i < params . length ; i ++ ) { parameter param = params [ i ] ; classnode paramtype = param . gettype ( ) ; classnode arg = j >= args . length ? null : args [ j ] ; if ( arg == null || ! isassignableto ( arg , paramtype ) ) { if ( ! param . hasinitialexpression ( ) && ( ptype == null || ! ptype . equals ( paramtype ) ) ) { return - _num ; } ptype = null ; } else { j ++ ; if ( ! paramtype . equals ( arg ) ) dist += getdistance ( arg , paramtype ) ; if ( param . hasinitialexpression ( ) ) { ptype = arg ; } else { ptype = null ; } } } return dist ; }	checks that arguments and parameter types match , expecting that the number of parameters is strictly greater than the number of arguments , allowing possible inclusion of default parameters .
private void expect ( char expectedsymbol ) throws parseexception { if ( ! accept ( expectedsymbol ) ) throw new parseexception ( _str + expectedsymbol + _str + ( char ) data [ index ] + _str , index ) ; }	expects the input to have the given symbol at the current parsing position .
public abstract void initparameters ( int [ ] acircuitdata , iredstonecircuitblock aredstonecircuitblock ) ;	initializes the parameters of this circuit , all parameters have been set to 0 right before calling this.
public contentlet executesafefirst ( ) { list < contentlet > result = executesafe ( ) ; if ( result . size ( ) > _num ) { return result . get ( _num ) ; } return null ; }	executes the query and returns the first result.
public static boolean isfileexist ( string filepath , filetype filetype , boolean performfilecheck ) throws ioexception { filepath = filepath . replace ( _str , _str ) ; switch ( filetype ) { case hdfs : case viewfs : path path = new path ( filepath ) ; filesystem fs = path . getfilesystem ( configuration ) ; if ( performfilecheck ) { return fs . exists ( path ) && fs . isfile ( path ) ; } else { return fs . exists ( path ) ; } case local : default : file defaultfile = new file ( filepath ) ; if ( performfilecheck ) { return defaultfile . exists ( ) && defaultfile . isfile ( ) ; } else { return defaultfile . exists ( ) ; } } }	this method checks the given path exists or not and also is it file or not if the performfilecheck is true.
private doublefactor pointwiseproduct ( list < doublefactor > factors ) { if ( factors . isempty ( ) ) { doublefactor factor = new doublefactor ( ) ; factor . addentry ( new assignment ( ) , _num , _num ) ; return factor ; } else if ( factors . size ( ) == _num ) { return factors . get ( _num ) ; } doublefactor factor = factors . get ( _num ) ; factors . remove ( _num ) ; for ( doublefactor f : factors ) { doublefactor tempfactor = new doublefactor ( ) ; set < string > sharedvars = new hashset < string > ( f . getvariables ( ) ) ; sharedvars . retainall ( factor . getvariables ( ) ) ; for ( assignment a : f . getvalues ( ) ) { double [ ] entry = f . getentry ( a ) ; double prob = entry [ _num ] ; double util = entry [ _num ] ; for ( assignment b : factor . getvalues ( ) ) { if ( b . consistentwith ( a , sharedvars ) ) { double [ ] entry2 = factor . getentry ( b ) ; double prob2 = entry2 [ _num ] ; double util2 = entry2 [ _num ] ; double product = prob * prob2 ; double sum = util + util2 ; tempfactor . addentry ( new assignment ( a , b ) , product , sum ) ; } } } factor = tempfactor ; } return factor ; }	computes the pointwise matrix product of the list of factors.
public classpath ( ) { string syscp = system . getproperty ( _str ) ; string envcp = system . getproperty ( _str ) ; if ( envcp == null ) envcp = _str ; string cp = syscp + file . pathseparator + envcp ; init ( cp ) ; }	build a default class path from the path strings specified by the properties sun.
protected static boolean uninstalladdonextension ( addon addon , extension extension , addonuninstallationprogresscallback callback ) { boolean uninstalledwithouterrors = _bool ; if ( extension . isenabled ( ) ) { string extuiname = extension . getuiname ( ) ; if ( extension . canunload ( ) ) { logger . debug ( _str + extension . getname ( ) ) ; try { extension . unload ( ) ; extensionfactory . unloadaddonextension ( extension ) ; } catch ( exception e ) { logger . error ( _str + extension . getname ( ) + _str + addon . getid ( ) + _str , e ) ; uninstalledwithouterrors = _bool ; } } else { logger . debug ( _str + extension . getname ( ) ) ; uninstalledwithouterrors = _bool ; } callback . extensionremoved ( extuiname ) ; } addon . removeloadedextension ( extension ) ; return uninstalledwithouterrors ; }	uninstalls the given extension .
private static string pickrandomstatsfields ( string [ ] fieldnames ) { string fieldname ; do { fieldname = fieldnames [ testutil . nextint ( random ( ) , _num , fieldnames . length - _num ) ] ; } while ( fieldname . endswith ( _str ) || fieldname . endswith ( _str ) ) ; return fieldname ; }	picks a random field to use for stats.
@ override public synchronized void dodeletechild ( basesolrresource endpoint , string childid ) { string key = getignorecase ( ) ? childid . tolowercase ( locale . root ) : childid ; if ( ! managedwords . contains ( key ) ) throw new solrexception ( errorcode . not_found , string . format ( locale . root , _str , childid , getresourceid ( ) ) ) ; managedwords . remove ( key ) ; storemanageddata ( managedwords ) ; log . info ( _str , key ) ; }	deletes words managed by this resource .
public dexportprivatekeytype ( jframe parent ) { super ( parent , dialog . modalitytype . document_modal ) ; settitle ( res . getstring ( _str ) ) ; initcomponents ( ) ; }	creates a new dexportprivatekeytype dialog .
public static ipoint [ ] copyof ( ipoint [ ] original , int newlength ) { ipoint [ ] copy = new ipoint [ newlength ] ; system . arraycopy ( original , _num , copy , _num , math . min ( original . length , newlength ) ) ; return copy ; }	this method comes with jdk 1.
public void writefooter ( ) { ps . println ( _str ) ; ps . println ( _str ) ; ps . println ( _str ) ; }	writes the html footer .
protected void saveobject ( object object ) { if ( m_filechooser == null ) { createfilechooser ( ) ; } int returnval = m_filechooser . showsavedialog ( this ) ; if ( returnval == jfilechooser . approve_option ) { file sfile = m_filechooser . getselectedfile ( ) ; try { objectoutputstream oo = new objectoutputstream ( new bufferedoutputstream ( new fileoutputstream ( sfile ) ) ) ; oo . writeobject ( object ) ; oo . close ( ) ; } catch ( exception ex ) { joptionpane . showmessagedialog ( this , _str + sfile . getname ( ) + _str + ex . getmessage ( ) , _str , joptionpane . error_message ) ; } } }	saves an object to a file selected by the user .
@ override public void write ( dataoutput out ) throws ioexception { if ( use_hadoop_text ) text . writestring ( out , term ) ; else out . writeutf ( term ) ; writableutils . writevint ( out , splitno ) ; writableutils . writevint ( out , flushno ) ; }	write out this term key to output stream ' out '.
public static string stripnondigits ( string str ) { stringbuffer result = new stringbuffer ( str . length ( ) ) ; for ( char candidate : str . tochararray ( ) ) { if ( character . isdigit ( candidate ) ) { result . append ( candidate ) ; } } return result . tostring ( ) ; }	strips all non - digit characters from a string.
protected collection < communicationsummarystatistics > dogetcommunicationsummarystatistics ( string tenantid , criteria criteria ) { string index = client . getindex ( tenantid ) ; map < string , communicationsummarystatistics > stats = new hashmap < > ( ) ; if ( ! criteria . transactionwide ( ) ) { criteria txnwidecriteria = criteria . derivetransactionwide ( ) ; buildcommunicationsummarystatistics ( stats , index , txnwidecriteria , _bool ) ; } buildcommunicationsummarystatistics ( stats , index , criteria , _bool ) ; return stats . values ( ) ; }	this method returns the flat list of communication summary stats .
public void removecontent ( string variableid ) { if ( ! paused ) { curstate . removefromstate ( variableid ) ; update ( ) ; } else { log . info ( _str + variableid ) ; } }	removes the variable from the dialogue state.
public void addcommandlistener ( actionlistener l ) { if ( globalcommandlisteners == null ) { globalcommandlisteners = new eventdispatcher ( ) ; } globalcommandlisteners . addlistener ( l ) ; }	adds a command listener that would be bound to all forms in the gui seamlessly.
public static void completebackgroundtasks ( long timeoutmillis ) { boolean fifoempty = _bool ; boolean asyncthreadscompleted = _bool ; long abstimeout = system . currenttimemillis ( ) + timeoutmillis ; while ( system . currenttimemillis ( ) < abstimeout ) { synchronized ( fifo ) { fifoempty = fifo . size ( ) == _num ; } synchronized ( jgoogleanalyticstracker . class ) { asyncthreadscompleted = asyncthreadsrunning == _num ; } if ( fifoempty && asyncthreadscompleted ) break ; try { thread . sleep ( _num ) ; } catch ( interruptedexception e ) { break ; } } }	wait for background tasks to complete.
private synchronized void writeobject ( java . io . objectoutputstream s ) throws ioexception { if ( actions == null ) getactions ( ) ; s . defaultwriteobject ( ) ; }	writeobject is called to save the state of the propertypermission to a stream.
public static final byte [ ] decode ( bufferedreader reader ) throws ioexception , base64decodingexception { byte [ ] retbytes = null ; unsyncbytearrayoutputstream baos = null ; try { baos = new unsyncbytearrayoutputstream ( ) ; string line ; while ( null != ( line = reader . readline ( ) ) ) { byte [ ] bytes = decode ( line ) ; baos . write ( bytes ) ; } retbytes = baos . tobytearray ( ) ; } finally { baos . close ( ) ; } return retbytes ; }	base64 decode the lines from the reader and return an inputstream with the bytes .
public boolean isdefinedinenv ( ) { if ( envvars == null || paramnames . length == _num ) { return _bool ; } for ( string var : envvars ) { if ( system . getenv ( var ) == null ) { return _bool ; } } return _bool ; }	determines if the argument provisioning has been done via the environment .
public void apply ( animator animator , float currvalue , float endvalue , float velocity ) { apply ( animator , currvalue , endvalue , velocity , math . abs ( endvalue - currvalue ) ) ; }	applies the interpolator and length to the animator , such that the fling animation is consistent with the finger motion .
public void addnotice ( parsernotice notice ) { notices . add ( notice ) ; }	adds a parser notice .
@ override public string tostring ( ) { int len = sessionid . length ; stringbuffer s = new stringbuffer ( _num + _num * len ) ; s . append ( _str ) ; for ( int i = _num ; i < len ; i ++ ) { s . append ( _num & sessionid [ i ] ) ; if ( i != ( len - _num ) ) s . append ( _str ) ; } s . append ( _str ) ; return s . tostring ( ) ; }	returns the id as a string.
public eventbinder < e > after ( string name ) { after . add ( name ) ; return this ; }	sets the event to occur after another event with given name .
public point2d forward ( point2d llp , point2d pt ) { return forward ( llp . gety ( ) , llp . getx ( ) , pt , _bool ) ; }	forward project a point .
private static int maxnumarcsfordedupbyte ( int currentnumdedupbytes ) { int maxarcs = _num + ( _num * currentnumdedupbytes ) ; if ( currentnumdedupbytes > _num ) { maxarcs *= currentnumdedupbytes ; } return math . min ( maxarcs , _num ) ; }	num arcs for nth dedup byte : if n < = 5 : 1 + ( 2 * n ) else : ( 1 + ( 2 * n ) ) * n < p > todo : is there a better way to make the fst built to be more topnsearcher friendly ?.
public jobcreaterequest createjobcreaterequest ( string namespacecd , string jobname ) { list < parameter > parameters = new arraylist < > ( ) ; parameter parameter = new parameter ( abstractservicetest . attribute_name_2_mixed_case , abstractservicetest . attribute_value_2 ) ; parameters . add ( parameter ) ; parameter = new parameter ( _str , null ) ; parameters . add ( parameter ) ; return createjobcreaterequest ( namespacecd , jobname , parameters ) ; }	creates job create request using a specified namespace code and job name , but test hard coded parameters will be used .
private void load ( ) throws repositoryexception , rdfparseexception , ioexception { final repositoryconnection conn = repository . getconnection ( ) ; string ttlstring = model_ttl ; inputstream stringinput = new bytearrayinputstream ( ttlstring . getbytes ( ) ) ; conn . add ( stringinput , _str , rdfformat . turtle , new resource [ ] { } ) ; ttlstring = bucket_ttl ; stringinput = new bytearrayinputstream ( ttlstring . getbytes ( ) ) ; conn . add ( stringinput , _str , rdfformat . turtle , new resource [ ] { } ) ; conn . commit ( ) ; conn . close ( ) ; }	load the t - box and a - box turtle from strings defined within this class .
public boolean istaxincluded ( ) { if ( m_m_pricelist_id == _num ) { m_m_pricelist_id = db . getsqlvalue ( get_trxname ( ) , _str , getc_order_id ( ) ) ; } mpricelist pl = mpricelist . get ( getctx ( ) , m_m_pricelist_id , get_trxname ( ) ) ; return pl . istaxincluded ( ) ; }	is tax included in amount.
protected webresource createrequest ( string uripath ) { ensureinitialization ( ) ; return clientrequesthelper . createrequest ( client , serviceuri , uri . create ( uripath ) ) ; }	create a request object for the specified path , resolved against the service base uri and using the appropriate client configuration.
public void nexttable ( ) throws sqlexception { if ( tables . hasnext ( ) ) { currenttable = tables . next ( ) ; openrows ( ) ; } }	move reference of the current table up by one.
public ddistinguishednamechooser ( jframe parent , string title , x500name distinguishedname , boolean editable ) { super ( parent , title , dialog . modalitytype . document_modal ) ; this . distinguishedname = distinguishedname ; this . editable = editable ; initcomponents ( ) ; }	creates a new ddistinguishednamechooser dialog .
public static boolean deletefile ( string filepathandname ) { if ( ( filepathandname == null ) || filepathandname . isempty ( ) ) { return _bool ; } boolean issuccessfuldelete = _bool ; try { file filetodelete = new file ( filepathandname ) ; issuccessfuldelete = filetodelete . delete ( ) ; } catch ( exception e ) { logger . debug ( e . tostring ( ) + system . lineseparator ( ) + stacktrace . getstringfromstacktrace ( e ) ) ; issuccessfuldelete = _bool ; } return issuccessfuldelete ; }	this is a quiet method .
public tungstenpropertiesio ( file path ) { this ( new javafileio ( ) , new filepath ( path . getabsolutepath ( ) ) ) ; }	creates a new instance for os file system operating on the caller - specified file .
@ override public int compareto ( final timeinstant rhs ) { return integer . compare ( this . time , rhs . time ) ; }	compares this instant to another timeinstant .
private boolean writetocharacteristic ( bluetoothgattcharacteristic charc , byte [ ] data ) { charc . setvalue ( data ) ; boolean result = mgattclient . writecharacteristic ( charc ) ; if ( result ) { log . d ( tag , _str + charc . getuuid ( ) + _str + arrays . tostring ( data ) ) ; } else { log . e ( tag , _str + charc . getuuid ( ) + _str + arrays . tostring ( data ) ) ; } return result ; }	write to a oad characteristic.
public char skipto ( char to ) { char c ; int index = this . myindex ; do { c = next ( ) ; if ( c == _num ) { this . myindex = index ; return c ; } } while ( c != to ) ; back ( ) ; return c ; }	skip characters until the next character is the requested character.
public int checkversionsize ( final softwareversion version ) { url imageurl = getimageurl ( version ) ; httpurlconnection urlconnection = invokerequest ( imageurl ) ; return urlconnection . getcontentlength ( ) ; }	get the size of the image file of a version.
private static datetimeformatter createformatterforstyle ( string style ) { if ( style == null || style . length ( ) != _num ) { throw new illegalargumentexception ( _str + style ) ; } int datestyle = selectstyle ( style . charat ( _num ) ) ; int timestyle = selectstyle ( style . charat ( _num ) ) ; if ( datestyle == none && timestyle == none ) { throw new illegalargumentexception ( _str ) ; } return createformatterforstyleindex ( datestyle , timestyle ) ; }	select a format from a two character style pattern.
public boolean acknextchunkid ( string id ) { if ( state . isterminated ( ) ) return _bool ; else if ( id . equals ( chunkid ) ) { return _bool ; } else { if ( ! allowotherchunksinbetween ( id ) ) { if ( state . isdone ( ) ) { if ( ! isterminated ( ) ) terminate ( ) ; return _bool ; } else { throw new pngjinputexception ( _str + id + _str + chunkid + _str ) ; } } else return _bool ; } }	this will be called by the owner to report us the next chunk to come.
private topdocs combine ( topdocs in , topdocs resorted , queryrescorecontext ctx ) { system . arraycopy ( resorted . scoredocs , _num , in . scoredocs , _num , resorted . scoredocs . length ) ; if ( in . scoredocs . length > resorted . scoredocs . length ) { for ( int i = resorted . scoredocs . length ; i < in . scoredocs . length ; i ++ ) { in . scoredocs [ i ] . score *= ctx . queryweight ( ) ; } arrays . sort ( in . scoredocs , score_doc_comparator ) ; } return in ; }	modifies incoming topdocs ( in ) by replacing the top hits with resorted ' s hits , and then resorting all hits .
public void testpospossamelength ( ) { byte abytes [ ] = { - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , - _num } ; byte bbytes [ ] = { - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = _num ; int bsign = _num ; byte rbytes [ ] = { _num , - _num , - _num , - _num , - _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . or ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	or for two positive numbers of the same length.
@ override public void pause ( boolean topause ) { ispaused = topause ; }	pauses or unpauses the recogniser .
public static string replaceall ( string original , string oldsubstring , string newsubstring ) { return replace ( original , oldsubstring , newsubstring , _bool ) ; }	returns original with all occurrences of oldsubstring replaced by newsubstring.
public long add ( final addop add ) throws exception { return add ( add , uuid . randomuuid ( ) ) ; }	adds rdf data to the remote repository .
protected boolean issmall ( ) { return this . scale * this . textsizeinmeters < this . pixelsizeinmeters ; }	determine if the text is too small to draw .
public byte [ ] decompress ( datainput is ) { bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; try { while ( _bool ) { byte b = is . readbyte ( ) ; if ( b == - _num ) break ; baos . write ( b ) ; } } catch ( eofexception ex ) { } catch ( ioexception ex ) { throw new runtimeexception ( ex ) ; } return decompress ( baos . tobytearray ( ) ) ; }	decompress an input stream until eof .
public int borrowspareregister ( int category ) { int result = spareregisterbase + borrowedspareregisters ; borrowedspareregisters += category ; registercount = math . max ( registercount , result + category ) ; return result ; }	borrows a register to use as a temp.
public void true ( boolean expression , object errormessage ) { if ( ! expression ) { throw new illegalargumentexception ( string . valueof ( errormessage ) ) ; } }	ensures the truth of an expression involving one or more parameters to the calling method .
private void processfields ( final object component , final context context , final contextdestroyer contextdestroyer ) { class < ? > componentclass = component . getclass ( ) ; while ( componentclass != null && ! componentclass . equals ( object . class ) ) { final field [ ] fields = classreflection . getdeclaredfields ( componentclass ) ; if ( fields != null && fields . length > _num ) { processfields ( component , fields , context , contextdestroyer ) ; } componentclass = componentclass . getsuperclass ( ) ; } }	scans class tree of component to process all its fields .
public static string replaceall ( string input , string regularexpression , string replacement ) { return input . replaceall ( regularexpression , replacement ) ; }	replace all occurrences in the original string of the oldstring with the newstring .
void requestnotificationupdate ( ) { if ( mcurrentnotificationgroupindex != notification_off ) { rhythmnotificationservice . shownotification ( mcontext , mnotificationid ) ; } }	should be called whenever notification state is changed ( e.
public static int countlowercase ( final string text ) { int count = _num ; for ( final char chr : text . tochararray ( ) ) { if ( character . islowercase ( chr ) ) { count ++ ; } } return count ; }	counts the number of lower case characters .
@ override protected void createbuttonsforbuttonbar ( final composite parent ) { for ( final iterator it = buttondescriptions . iterator ( ) ; it . hasnext ( ) ; ) { final buttondescription buttondescription = ( buttondescription ) it . next ( ) ; createbutton ( parent , buttondescription . buttonid , buttondescription . buttonlabel , buttondescription . isdefault ) ; } if ( includedefaultbuttons ) { super . createbuttonsforbuttonbar ( parent ) ; } hookafterbuttonscreated ( ) ; }	subclasses may override this method to do their own button bar handling.
private boolean checkfilemodifications ( ) throws exception { long destfiletime = destfile . lastmodified ( ) ; if ( sourcefile . lastmodified ( ) > destfiletime ) { logger . debug ( _str ) ; return _bool ; } properties metadata = restorefilemodifications ( metadatafile ) ; if ( metadata == null ) { return _bool ; } saxparserfactory parserfactory = saxparserfactory . newinstance ( ) ; saxparser parser = parserfactory . newsaxparser ( ) ; timecheckerhandler handler = new timecheckerhandler ( basedir , metadata ) ; parser . parse ( sourcefile , handler ) ; return handler . ismodified ( ) ; }	check for modifications of included files .
public static number mul ( number a , number b ) { if ( isfloatingpoint ( a ) || isfloatingpoint ( b ) ) { return a . doublevalue ( ) * b . doublevalue ( ) ; } else { return a . longvalue ( ) * b . longvalue ( ) ; } }	returns the value of multiplying the two numbers .
private final int findwidestaxis ( ) { int widest = _num ; double width = ( maxlimit [ _num ] - minlimit [ _num ] ) * getaxisweighthint ( _num ) ; if ( double . isnan ( width ) ) { width = _num ; } for ( int i = _num ; i < dimensions ; i ++ ) { double nwidth = ( maxlimit [ i ] - minlimit [ i ] ) * getaxisweighthint ( i ) ; if ( double . isnan ( nwidth ) ) { nwidth = _num ; } if ( nwidth > width ) { widest = i ; width = nwidth ; } } return widest ; }	find the widest axis of the bounds of this node.
public void addsortkey ( int column , comparator < string > comparator ) { sortkeys . add ( column ) ; sortcomparators . add ( comparator ) ; }	adds a table sort key.
public static string tagswap ( string content , map < string , string > tagswapmap ) { for ( map . entry < string , string > entry : tagswapmap . entryset ( ) ) { content = content . replace ( entry . getkey ( ) , entry . getvalue ( ) ) ; } return content ; }	swaps content with tags with the provided tag values .
public static runstats delegategetbucketforintegers ( int buckets ) throws exception { long starttime = system . currenttimemillis ( ) ; primaryindexbucketgeneratorimpl ibg = new primaryindexbucketgeneratorimpl ( fielddatatype . integer , buckets ) ; primaryindexbucketlocatorimpl locator = new primaryindexbucketlocatorimpl ( null , null , null , ibg . generatebuckets ( ) , null , null , null , null , null ) ; logger . debug ( _str ) ; hashmap < long , list < object > > hm = new hashmap < > ( ) ; summarystatistics stats = new summarystatistics ( ) ; for ( int inputint = - _num ; inputint < _num ; inputint ++ ) { long bucketid = locator . getbucket ( inputint , fielddatatype . integer ) ; calculate ( hm , stats , bucketid , inputint ) ; } long runtime = system . currenttimemillis ( ) - starttime ; runstats runstats = new runstats ( _str , fielddatatype . integer , runtime , stats , hm ) ; logger . debug ( runstats . tostring ( ) ) ; return runstats ; }	test to check the bucket distribution for the common integer values.
public static long countsubstr ( final string value , final string substr , final boolean casesensitive , boolean allowoverlapping ) { validate ( value , null_string_predicate , null_string_msg_supplier ) ; return countsubstr ( casesensitive ? value : value . tolowercase ( ) , casesensitive ? substr : substr . tolowercase ( ) , allowoverlapping , _num ) ; }	count the number of times substr appears in value.
private void dropindex ( string indexname ) throws oracleexception { preparedstatement stmt = null ; if ( indexname == null ) throw sodautils . makeexception ( sodamessage . ex_arg_cannot_be_null , _str ) ; indexname = collectiondescriptor . stringtoidentifier ( indexname ) ; string sqltext = dropindexddl ( indexname ) ; try { metrics . starttiming ( ) ; stmt = conn . preparestatement ( sqltext ) ; stmt . execute ( ) ; if ( oraclelog . isloggingenabled ( ) ) log . info ( _str + indexname ) ; stmt . close ( ) ; stmt = null ; metrics . recordddl ( ) ; } catch ( sqlexception e ) { int errcode = e . geterrorcode ( ) ; if ( ( errcode == ora_sql_object_not_exists ) || ( errcode == ora_sql_index_not_exists ) ) { if ( oraclelog . isloggingenabled ( ) ) log . warning ( e . tostring ( ) ) ; } else { if ( oraclelog . isloggingenabled ( ) ) log . warning ( e . tostring ( ) ) ; throw sodautils . makeexceptionwithsqltext ( e , sqltext ) ; } } finally { for ( string message : sodautils . closecursor ( stmt , null ) ) { if ( oraclelog . isloggingenabled ( ) ) log . severe ( message ) ; } } }	drop the named index.
void unlaunch ( ) { if ( server != null ) { server . die ( ) ; server = null ; } frame . setvisible ( _bool ) ; client = null ; system . gc ( ) ; system . runfinalization ( ) ; }	un - hides the main menu and tries to clean up the client or server .
public int postfiles ( file [ ] files , int startindexinargs , outputstream out , string type ) { reset ( ) ; int filesposted = _num ; for ( file srcfile : files ) { if ( srcfile . isdirectory ( ) && srcfile . canread ( ) ) { filesposted += postdirectory ( srcfile , out , type ) ; } else if ( srcfile . isfile ( ) && srcfile . canread ( ) ) { filesposted += postfiles ( new file [ ] { srcfile } , out , type ) ; } else { file parent = srcfile . getparentfile ( ) ; if ( parent == null ) parent = new file ( _str ) ; string fileglob = srcfile . getname ( ) ; globfilefilter ff = new globfilefilter ( fileglob , _bool ) ; file [ ] filelist = parent . listfiles ( ff ) ; if ( filelist == null || filelist . length == _num ) { warn ( _str + srcfile ) ; continue ; } filesposted += postfiles ( filelist , out , type ) ; } } return filesposted ; }	post all filenames provided in args.
private static string unicode2html ( final string text , final boolean amp , final boolean html ) { if ( text == null ) return null ; final stringbuilder sb = new stringbuilder ( text . length ( ) * _num / _num ) ; int textpos = _num ; string r ; char c ; while ( textpos < text . length ( ) ) { c = text . charat ( textpos ) ; if ( amp && c == amp_unicode ) { sb . append ( amp_html ) ; textpos ++ ; continue ; } if ( ( r = unicode2html4xml . get ( c ) ) != null ) { sb . append ( r ) ; textpos ++ ; continue ; } if ( html && ( r = unicode2html4html . get ( c ) ) != null ) { sb . append ( r ) ; textpos ++ ; continue ; } sb . append ( c ) ; textpos ++ ; } return sb . tostring ( ) ; }	replaces characters which have special representation in html or xml .
public string addplaylist ( string playlistname ) { contentvalues minserts = new contentvalues ( ) ; minserts . put ( mediastore . audio . playlists . name , playlistname ) ; minserts . put ( mediastore . audio . playlists . date_added , system . currenttimemillis ( ) ) ; minserts . put ( mediastore . audio . playlists . date_modified , system . currenttimemillis ( ) ) ; uri uri = mcontentresolver . insert ( mediastore . audio . playlists . external_content_uri , minserts ) ; if ( uri == null ) { return null ; } else { string ref = prefix_playlist + getplaylistuniquename ( long . tostring ( contenturis . parseid ( uri ) ) ) ; playlist pl = new playlist ( ref ) ; pl . setname ( playlistname ) ; pl . setisloaded ( _bool ) ; mplaylists . put ( ref , pl ) ; mcallback . playlistupdated ( pl ) ; return ref ; } }	adds a new playlist.
public static jsonarray readjsonarray ( final jsonobject jsonobject , final string key , final boolean required , final boolean notnull ) throws jsonexception { if ( required ) { return jsonobject . getjsonarray ( key ) ; } if ( notnull && jsonobject . isnull ( key ) ) { throw new jsonexception ( string . format ( locale . us , null_value_format_object , key ) ) ; } jsonarray value = null ; if ( ! jsonobject . isnull ( key ) ) { value = jsonobject . getjsonarray ( key ) ; } return value ; }	reads the json array value from the json object for specified tag .
default int copyto ( @ notnull byte [ ] bytes ) throws bufferunderflowexception { int len = ( int ) math . min ( bytes . length , readremaining ( ) ) ; for ( int i = _num ; i < len ; i ++ ) bytes [ i ] = readbyte ( start ( ) + i ) ; return len ; }	read a byte [ ] from memory .
private static float [ ] randompoints ( random random , int wavescount , float width , float shiftcoef ) { float shift ; float [ ] points = new float [ wavescount + _num ] ; for ( int i = _num ; i < points . length ; i ++ ) { if ( i == _num ) { points [ i ] = - _num ; } else if ( i == points . length - _num ) { points [ i ] = _num ; } else { shift = random . nextfloat ( ) * shiftcoef * width ; shift *= random . nextboolean ( ) ? _num : - _num ; points [ i ] = - _num + i * width + shift ; } } return points ; }	generate random points for wave .
private void addcharacters ( final map < string , rpobject > characters ) { for ( entry < string , rpobject > character : characters . entryset ( ) ) { jbutton button = createcharacterbutton ( character . getkey ( ) , character . getvalue ( ) ) ; characterpanel . add ( button ) ; } }	add the available characters .
public void runtest ( ) throws throwable { document doc ; nodelist genderlist ; node gendernode ; characterdata enttext ; entityreference entreference ; doc = ( document ) load ( _str , _bool ) ; genderlist = doc . getelementsbytagname ( _str ) ; gendernode = genderlist . item ( _num ) ; entreference = doc . createentityreference ( _str ) ; assertnotnull ( _str , entreference ) ; enttext = ( characterdata ) entreference . getfirstchild ( ) ; assertnotnull ( _str , enttext ) ; { boolean success = _bool ; try { enttext . insertdata ( _num , _str ) ; } catch ( domexception ex ) { success = ( ex . code == domexception . no_modification_allowed_err ) ; } asserttrue ( _str , success ) ; } }	runs the test case .
@ override public void unbindview ( vh holder ) { }	called when the view is unbound.
public static boolean ispresent ( rule rule ) { if ( rule == null ) { return _bool ; } return ( ! isnotset ( rule . getminscaledenominator ( ) ) || ! isnotset ( rule . getmaxscaledenominator ( ) ) ) ; }	checks if rule has minimum or maximum scale denominator set.
public long startcode ( ) { return long . parselong ( fields [ _num ] ) ; }	the address above which program text can run .
public static void registerdefaultresolvers ( ) { list < keyresolver > keyresolverlist = new arraylist < keyresolver > ( ) ; keyresolverlist . add ( new keyresolver ( new rsakeyvalueresolver ( ) ) ) ; keyresolverlist . add ( new keyresolver ( new dsakeyvalueresolver ( ) ) ) ; keyresolverlist . add ( new keyresolver ( new x509certificateresolver ( ) ) ) ; keyresolverlist . add ( new keyresolver ( new x509skiresolver ( ) ) ) ; keyresolverlist . add ( new keyresolver ( new retrievalmethodresolver ( ) ) ) ; keyresolverlist . add ( new keyresolver ( new x509subjectnameresolver ( ) ) ) ; keyresolverlist . add ( new keyresolver ( new x509issuerserialresolver ( ) ) ) ; keyresolverlist . add ( new keyresolver ( new derencodedkeyvalueresolver ( ) ) ) ; keyresolverlist . add ( new keyresolver ( new keyinforeferenceresolver ( ) ) ) ; keyresolverlist . add ( new keyresolver ( new x509digestresolver ( ) ) ) ; resolvervector . addall ( keyresolverlist ) ; }	this method registers the default resolvers .
public static final void delete ( string filename ) { file file = new file ( filename ) ; if ( ! file . delete ( ) ) { log . error ( _str , file ) ; } file metadatafile = new file ( filename + metadata_suffix ) ; if ( ! metadatafile . delete ( ) ) { log . error ( _str , metadatafile ) ; } file directory = file . getparentfile ( ) ; if ( directory . isdirectory ( ) ) { directory . delete ( ) ; } }	deletes the file and accompanying expire date .
@ override public boolean equals ( object obj ) { if ( obj == this ) { return _bool ; } if ( ! ( obj instanceof timeperiodvaluescollection ) ) { return _bool ; } timeperiodvaluescollection that = ( timeperiodvaluescollection ) obj ; if ( this . domainispointsintime != that . domainispointsintime ) { return _bool ; } if ( this . xposition != that . xposition ) { return _bool ; } if ( ! objectutilities . equal ( this . data , that . data ) ) { return _bool ; } return _bool ; }	tests this instance for equality with an arbitrary object .
public void print ( jtextpane pane ) { setdocument ( pane ) ; printdialog ( ) ; }	prints the document in the jtextpane .
private boolean ensurescrollwheeladjusted ( ) { int deltay = minitialscrolloffset - mcurrentscrolloffset ; if ( deltay != _num ) { mpreviousscrollery = _num ; if ( math . abs ( deltay ) > mselectorelementheight / _num ) { deltay += ( deltay > _num ) ? - mselectorelementheight : mselectorelementheight ; } madjustscroller . startscroll ( _num , _num , _num , deltay , selector_adjustment_duration_millis ) ; invalidate ( ) ; return _bool ; } return _bool ; }	ensures that the scroll wheel is adjusted i.
private string sortxml ( final string originalxml ) { string errormsg = _str ; xmlprocessinginstructionparser . scanforignoredsections ( originalxml ) ; string xml = xmlprocessinginstructionparser . replaceignoredsections ( ) ; insertxmlinxmlprocessor ( xml , errormsg ) ; xmlprocessor . sortxml ( ) ; try ( bytearrayoutputstream sortedxmloutputstream = xmlprocessor . getsortedxml ( ) ) { string sortedxml = sortedxmloutputstream . tostring ( encoding ) ; if ( xmlprocessinginstructionparser . existsignoredsections ( ) ) { sortedxml = xmlprocessinginstructionparser . revertignoredsections ( sortedxml ) ; } return sortedxml ; } catch ( ioexception e ) { throw new failureexception ( errormsg + xml , e ) ; } }	sorts the incoming xml .
void waitfordictionaryloading ( ) { while ( mupdatingdictionary ) { try { thread . sleep ( _num ) ; } catch ( interruptedexception e ) { } } }	used only for testing purposes this function will wait for loading from database to be done.
private void publishdata ( string path , byte [ ] data ) { try { if ( data != null && data . length > _num ) { bytearrayinputstream bii = new bytearrayinputstream ( data ) ; objectinputstream ois = new objectinputstream ( bii ) ; object dataobj = ois . readobject ( ) ; zookeeperdatawrapper wrapper = ( zookeeperdatawrapper ) ( dataobj ) ; jetstreammessage tm = ( jetstreammessage ) wrapper . getorginaldata ( ) ; string trackerkey = createkey ( path , wrapper ) ; m_changetracker . put ( trackerkey , wrapper . gettimestamp ( ) ) ; try { logger . warn ( _str + path + _str + trackerkey + _str + wrapper . gettimestamp ( ) ) ; m_transportlistener . postmessage ( tm , m_queuestats ) ; } catch ( throwable mse ) { stringbuffer buf = new stringbuffer ( ) ; buf . append ( _str ) ; buf . append ( mse . getlocalizedmessage ( ) ) ; logger . error ( _str + path + buf . tostring ( ) , mse ) ; } m_totalmsgsrcvd . increment ( ) ; m_msgsrcvdpersec . increment ( ) ; } } catch ( classnotfoundexception e ) { logger . error ( _str + path , e ) ; } catch ( ioexception e ) { logger . error ( _str + path , e ) ; } }	post notifications on to transport listeners.
static public long nextaddr ( random r , wormaddressmanager am ) { if ( r . nextint ( _num ) < _num ) return _num ; return nextnonzeroaddr ( r , am ) ; }	returns a legal random address and null 5 % of the time .
public void undoableedithappened ( mxundoableedit undoableedit ) { if ( enabled ) { if ( undoableedit . gettransparent ( ) ) { } else if ( ! undoableedit . getundoable ( ) ) { notundoableedithappened ( ) ; } else if ( collection ) { collected . add ( undoableedit ) ; fireevent ( new mxeventobject ( mxevent . add , _str , undoableedit ) ) ; } else { collected . add ( undoableedit ) ; addeventlist ( ) ; fireevent ( new mxeventobject ( mxevent . add , _str , undoableedit ) ) ; } } }	method to be called to add new undoable edits to the history .
public file ( file dir , string name ) { this ( dir == null ? null : dir . getpath ( ) , name ) ; }	constructs a new file using the specified directory and name .
public void removedraglistener ( draglistener l ) { mlisteners . remove ( l ) ; }	remove a previously installed drag listener .
private hightidevalues findhightide ( jsonobject responseobject ) throws jsonexception , parseexception { jsonarray predictions = ( jsonarray ) responseobject . get ( _str ) ; jsonobject lastprediction = null , firsthightide = null , secondhightide = null , lowtide = null ; boolean firsttidedone = _bool ; for ( int i = _num ; i < predictions . length ( ) ; i ++ ) { jsonobject prediction = ( jsonobject ) predictions . get ( i ) ; if ( lastprediction == null ) { lastprediction = prediction ; continue ; } if ( istideincreasing ( lastprediction , prediction ) ) { if ( ! firsttidedone ) { firsthightide = prediction ; } else { secondhightide = prediction ; } } else { if ( ! firsttidedone && firsthightide != null ) { firsttidedone = _bool ; } else if ( secondhightide != null ) { break ; } if ( firsttidedone ) { lowtide = prediction ; } } lastprediction = prediction ; } dateformat dateformat = new simpledateformat ( _str ) ; return new hightidevalues ( alexadateutil . getformattedtime ( dateformat . parse ( firsthightide . getstring ( _str ) ) ) , getformattedheight ( firsthightide . getstring ( _str ) ) , alexadateutil . getformattedtime ( dateformat . parse ( lowtide . getstring ( _str ) ) ) , getformattedheight ( lowtide . getstring ( _str ) ) , alexadateutil . getformattedtime ( dateformat . parse ( secondhightide . getstring ( _str ) ) ) , getformattedheight ( secondhightide . getstring ( _str ) ) ) ; }	algorithm to find the 2 high tides for the day , the first of which is smaller and occurs mid - day , the second of which is larger and typically in the evening .
public static boolean isipaddress ( string ipaddress ) { matcher m1 = validipv4pattern . matcher ( ipaddress ) ; if ( m1 . matches ( ) ) { return _bool ; } matcher m2 = validipv6pattern . matcher ( ipaddress ) ; return m2 . matches ( ) ; }	determine if the given string is a valid ipv4 or ipv6 address.
@ override public synchronized void removetrainingsetlistener ( trainingsetlistener tsl ) { m_traininglisteners . removeelement ( tsl ) ; }	remove a training set listener.
public void renameattributevalue ( attribute att , string val , string name ) { int v = att . indexofvalue ( val ) ; if ( v == - _num ) { throw new illegalargumentexception ( val + _str ) ; } renameattributevalue ( att . index ( ) , v , name ) ; }	renames the value of a nominal ( or string ) attribute value.
private static void s_uacmean ( sparseblock a , double [ ] c , int m , int n , kahanobject kbuff , mean kmean , int rl , int ru ) { arrays . fill ( c , n , n * _num , ru - rl ) ; if ( a . iscontiguous ( ) ) { countdisagg ( a . values ( rl ) , c , a . indexes ( rl ) , a . pos ( rl ) , n , ( int ) a . size ( rl , ru ) ) ; } else { for ( int i = rl ; i < ru ; i ++ ) { if ( ! a . isempty ( i ) ) countdisagg ( a . values ( i ) , c , a . indexes ( i ) , a . pos ( i ) , n , a . size ( i ) ) ; } } if ( a . iscontiguous ( ) ) { meanagg ( a . values ( rl ) , c , a . indexes ( rl ) , a . pos ( rl ) , ( int ) a . size ( rl , ru ) , n , kbuff , kmean ) ; } else { for ( int i = rl ; i < ru ; i ++ ) { if ( ! a . isempty ( i ) ) meanagg ( a . values ( i ) , c , a . indexes ( i ) , a . pos ( i ) , a . size ( i ) , n , kbuff , kmean ) ; } } }	colmean , opcode : uacmean , sparse input .
public boolean ispdfattachment ( ) { if ( getpo ( ) == null ) return _bool ; return m_po . ispdfattachment ( ) ; }	does the underlying po ( ! ) object have a pdf attachment.
private int nametoindex ( string parametername ) throws sqlexception { parametermetadata . readmetadatafromdbifrequired ( ) ; for ( int i = _num ; i <= parametermetadata . getparametercount ( ) ; i ++ ) { string name = parametermetadata . getname ( i ) ; if ( name != null && name . equalsignorecase ( parametername ) ) { return i ; } } throw new sqlexception ( _str + parametername ) ; }	convert parameter name to parameter index in the query .
public void sort ( comparator < ? super subrange > comparator ) { collections . sort ( data , comparator ) ; }	sort aggregated sub ranges with providen comparator.
private void add ( treemap < string , object > map , string key , object value ) { vector < object > v = getlist ( map , key ) ; if ( v == null ) { v = new vector < > ( ) ; synchronized ( map ) { map . put ( key , v ) ; } } if ( ! v . contains ( value ) ) { v . add ( value ) ; } }	generic method for adding into a map.
public void test_singleresourcelocking_serialized_waitsfor_highconcurrency_tasktimeout ( ) throws exception { final properties properties = new properties ( ) ; final int nthreads = _num ; final int ntasks = _num ; properties . setproperty ( testoptions . core_pool_size , _str + nthreads ) ; properties . setproperty ( testoptions . ntasks , _str + ntasks ) ; properties . setproperty ( testoptions . nresources , _str ) ; properties . setproperty ( testoptions . min_locks , _str ) ; properties . setproperty ( testoptions . max_locks , _str ) ; properties . setproperty ( testoptions . task_timeout , _str ) ; properties . setproperty ( testoptions . predeclare_locks , _str ) ; properties . setproperty ( testoptions . sort_lock_requests , _str ) ; final result result = docomparisontest ( properties ) ; assertequals ( _str , _num , integer . parseint ( result . get ( _str ) ) ) ; assertequals ( _str , _num , integer . parseint ( result . get ( _str ) ) ) ; final int ncancel = integer . parseint ( result . get ( _str ) ) ; asserttrue ( _str , ncancel > _num ) ; }	test where each operation locks only a single resource and there is only one resource to be locked so that all operations must be serialized.
private void blackmanharris3s ( int size ) { int start = ( windowfunction . length - size ) / _num ; int stop = ( windowfunction . length + size ) / _num ; double scale = _num / ( double ) size / _num ; for ( int i = _num ; start < stop ; start ++ , i ++ ) windowfunction [ i ] = scale * ( _num - _num * math . cos ( twopi * i / size ) + _num * math . cos ( _num * twopi * i / size ) ) ; }	fill an array with the values of a 61 - db 3 - sample blackman - harris window function.
private weekfields ( dayofweek firstdayofweek , int minimaldaysinfirstweek ) { objects . requirenonnull ( firstdayofweek , _str ) ; if ( minimaldaysinfirstweek < _num || minimaldaysinfirstweek > _num ) { throw new illegalargumentexception ( _str ) ; } this . firstdayofweek = firstdayofweek ; this . minimaldays = minimaldaysinfirstweek ; }	creates an instance of the definition .
static heapdoublessketch copy ( doublessketch sketch ) { heapdoublessketch qscopy ; qscopy = heapdoublessketch . newinstance ( sketch . getk ( ) ) ; qscopy . n_ = sketch . getn ( ) ; qscopy . minvalue_ = sketch . getminvalue ( ) ; qscopy . maxvalue_ = sketch . getmaxvalue ( ) ; qscopy . combinedbufferitemcapacity_ = sketch . getcombinedbufferitemcapacity ( ) ; qscopy . basebuffercount_ = sketch . getbasebuffercount ( ) ; qscopy . bitpattern_ = sketch . getbitpattern ( ) ; double [ ] combbuf = sketch . getcombinedbuffer ( ) ; qscopy . combinedbuffer_ = arrays . copyof ( combbuf , combbuf . length ) ; return qscopy ; }	returns an on - heap copy of the given sketch.
public list < verificationok > verify ( list < verificationok > result ) throws ioexception , generalsecurityexception { if ( result == null ) result = new arraylist < > ( ) ; while ( pkcs7 != null ) { result . addall ( verifysignature ( ) ) ; } return result ; }	verifies all the document - level timestamps and all the signatures in the document .
public schemafield ( string name , fieldtype type ) { this ( name , type , type . properties , null ) ; }	create a new schemafield with the given name and type , using all the default properties from the type .
private void createdayslot ( arraylist < massignmentslot > list , massignmentslot ma ) { timestamp start = ma . getstarttime ( ) ; gregoriancalendar calstart = new gregoriancalendar ( ) ; calstart . settime ( start ) ; calstart . set ( calendar . hour_of_day , _num ) ; calstart . set ( calendar . minute , _num ) ; calstart . set ( calendar . second , _num ) ; calstart . set ( calendar . millisecond , _num ) ; timestamp end = ma . getendtime ( ) ; gregoriancalendar calend = new gregoriancalendar ( ) ; calend . settime ( end ) ; calend . set ( calendar . hour_of_day , _num ) ; calend . set ( calendar . minute , _num ) ; calend . set ( calendar . second , _num ) ; calend . set ( calendar . millisecond , _num ) ; while ( calstart . before ( calend ) ) { timestamp xstart = new timestamp ( calstart . gettimeinmillis ( ) ) ; calstart . add ( calendar . day_of_year , _num ) ; timestamp xend = new timestamp ( calstart . gettimeinmillis ( ) ) ; massignmentslot myma = new massignmentslot ( xstart , xend , ma . getname ( ) , ma . getdescription ( ) , ma . getstatus ( ) ) ; list . add ( myma ) ; } }	create a day slot for range.
public boolean isattachment ( string filename ) { return filename . startswith ( entry_attachment ) ; }	true if the given file is an attachment .
public optimized ( int n , int s , int t , iterator < edgeinfo > edges ) { super ( n , s , t ) ; queue = new int [ n ] ; queue_size = n ; capacity = new int [ n ] [ n ] ; flow = new int [ n ] [ n ] ; previous = new int [ n ] ; visited = new int [ n ] ; while ( edges . hasnext ( ) ) { edgeinfo ei = edges . next ( ) ; capacity [ ei . start ] [ ei . end ] = ei . capacity ; } }	load up information for this network problem .
public static map < string , object > badexpireevenprocessor ( dispatchcontext dctx , map < string , ? extends object > context ) { genericvalue creditcard = ( genericvalue ) context . get ( _str ) ; string expiredate = creditcard . getstring ( _str ) ; string lastnumberstr = expiredate . substring ( expiredate . length ( ) - _num ) ; int lastnumber = integer . parseint ( lastnumberstr ) ; if ( lastnumber % _num == _num ) { return alwaysbadexpireprocessor ( dctx , context ) ; } else { return alwaysapproveprocessor ( dctx , context ) ; } }	fail / bad expire date when year is even processor.
public expressiontype negate ( ) { if ( isnegated ( ) ) { return new expressiontype ( typestring . replace ( suffix_negated , _str ) ) ; } else { return new expressiontype ( typestring + suffix_negated ) ; } }	negate the type . this are the two typical cases : ver - > ver - neg ver - neg - > ver.
protected void updatepathgreyness ( treepath ancestor ) { boolean value = ispathcheckbox ( ancestor ) ; object ancestornode = ancestor . getlastpathcomponent ( ) ; if ( ! ispathcheckbox ( ancestor ) ) { addtocheckboxpathsset ( ancestor ) ; return ; } }	updates the greyness value value for the given path if there are children with different values.
protected arraylist < string > usetokenizer ( string s ) throws exception { string [ ] tokens ; arraylist < string > result ; int i ; tokens = tokenizer . tokenize ( m_tokenizer , new string [ ] { s } ) ; result = new arraylist < string > ( ) ; for ( i = _num ; i < tokens . length ; i ++ ) { result . add ( tokens [ i ] ) ; } return result ; }	runs the tokenizer over the given string and returns the generated tokens .
public domstorableinputoutputformat ( domfactory factory , string description , string fileextension , string mimetype ) { this . factory = factory ; this . description = description ; this . fileextension = fileextension ; this . mimetype = mimetype ; try { this . dataflavor = new dataflavor ( mimetype ) ; } catch ( classnotfoundexception ex ) { internalerror error = new internalerror ( _str + mimetype ) ; error . initcause ( ex ) ; throw error ; } }	creates a new instance using the specified parameters .
default typeparameterdeclaration astypeparameter ( ) { throw new unsupportedoperationexception ( string . format ( _str , this ) ) ; }	return this as a typeparameterdeclaration or throw unsupportedoperationexception .
public void addcolumn ( string header ) { if ( getmodel ( ) instanceof defaulttablemodel ) { defaulttablemodel model = ( defaulttablemodel ) getmodel ( ) ; model . addcolumn ( util . cleanamp ( header ) ) ; } else throw new illegalargumentexception ( _str ) ; }	add table column . after adding a column , you need to set the column classes again ( defaulttablemodel fires tablestructurechanged , which calls jtable . tablechanged . . createdefaultcolumnsfrommodel.
public void addmovescript ( string pathname ) { _movescripts . add ( pathname ) ; setdirtyandfirepropertychange ( _str , pathname , null ) ; }	add a script to run when train is moved.
private void checkandaddresizehandler ( ) { component parent = getparent ( ) ; if ( parent != null && resizable && resizehandler == null ) { resizehandler = new resizehandler ( ) ; parent . addcomponentlistener ( resizehandler ) ; } }	checks conditions and adds resize handler if they are met .
static public void usexalanxpathsupport ( ) throws exception { class . forname ( _str ) ; class c = class . forname ( _str ) ; synchronized ( static_lock ) { xpathsupportclass = c ; } if ( log . isdebugenabled ( ) ) { log . debug ( _str ) ; } }	convenience method . tells the system to use xalan for xpath queries .
public int numberofowningshards ( ) { int count = _num ; for ( shardrouting shardentry : this ) { if ( shardentry . state ( ) != shardroutingstate . relocating ) { count ++ ; } } return count ; }	the number of shards on this node that will not be eventually relocated .
public string convertbinarytohexstring ( byte [ ] bytes ) { stringbuilder builder = new stringbuilder ( bytes . length * _num ) ; for ( byte b : bytes ) { int highbitsint = ( b > > _num ) & _num ; int lowbitsint = b & _num ; builder . append ( hex_chars [ highbitsint ] ) ; builder . append ( hex_chars [ lowbitsint ] ) ; } return builder . tostring ( ) ; }	convert the provided binary into a hex - string representation where each character represents 4 bits of the provided binary , i.
protected static void writeheader ( xmlwriter writer ) { xmlwriterutil . writecommentlinebreak ( writer ) ; xmlwriterutil . writecomment ( writer , _str ) ; dateformat dateformat = new simpledateformat ( _str ) ; xmlwriterutil . writecomment ( writer , _str + dateformat . format ( new date ( system . currenttimemillis ( ) ) ) ) ; xmlwriterutil . writecomment ( writer , _str ) ; xmlwriterutil . writecomment ( writer , _str ) ; xmlwriterutil . writecommentlinebreak ( writer ) ; xmlwriterutil . writelinebreak ( writer ) ; }	method from org . apache . maven . plugins . help . abstracteffectivemojo write comments in the effective pom / settings header .
protected void close ( ) { try { if ( to != null ) to . close ( ) ; if ( from != null ) from . close ( ) ; } catch ( ioexception e ) { } if ( process != null ) process . destroy ( ) ; process = null ; to = null ; from = null ; errorlogger = null ; }	closes the external process ' s input and output streams , and destroys the process .
public void clearparseissues ( ) { parseissues . clear ( ) ; }	clear the list of parse issues .
private static string unsignedtostring ( final int value ) { if ( value >= _num ) { return integer . tostring ( value ) ; } else { return long . tostring ( ( ( long ) value ) & _num ) ; } }	convert an unsigned 32 - bit integer to a string .
public connectionmanager ( connectionmanagerconfiguration configuration ) throws exception { _configuration = configuration ; if ( _configuration == null ) { throw new connectionmanagerexception ( _str ) ; } }	constructs a connection manager instance .
@ suppresswarnings ( _str ) public pids ( ) { arrays . sort ( pids , pidcomparator ) ; }	creates a new instance of pids.
public void handleheadercolumnreleased ( point p ) { table . setpressedcolumnindex ( - _num ) ; jtableheader th = table . gettableheader ( ) ; int col = th . columnatpoint ( p ) ; if ( col != - _num ) th . repaint ( th . getheaderrect ( col ) ) ; }	tell the table something is not pressed .
public void createdevices ( @ notnull list < device > devices ) { if ( ! initifnecessary ( ) ) { return ; } for ( device device : devices ) { string deviceidbase = device . getid ( ) ; string devicenamebase = device . getdisplayname ( ) ; int i = _num ; while ( isuserdevice ( device ) ) { string id = string . format ( locale . getdefault ( ) , _str , deviceidbase , i ) ; string name = string . format ( locale . getdefault ( ) , _str , devicenamebase , i ) ; device = clonedevicewithnewidandname ( device , id , name ) ; } ourdevicemanager . adduserdevice ( device ) ; } ourdevicemanager . saveuserdevices ( ) ; }	create the given devices.
public writableraster createcompatiblewritableraster ( int w , int h ) { if ( w <= _num || h <= _num ) { throw new rasterformatexception ( _str + ( ( w <= _num ) ? _str : _str ) ) ; } samplemodel sm = samplemodel . createcompatiblesamplemodel ( w , h ) ; return new shortbandedraster ( sm , new point ( _num , _num ) ) ; }	creates a raster with the same layout but using a different width and height , and with new zeroed data arrays .
public void write ( printwriter writer ) { for ( int i = _num ; i < count ; i ++ ) { writer . println ( keys [ i ] + _str + values [ i ] ) ; } writer . flush ( ) ; }	write tab - delimited entries out to.
@ workerthread public synchronized int stoprecord ( ) { if ( mrecorder == null ) { mstate = state_idle ; return - _num ; } int length = - _num ; switch ( mstate ) { case state_recording : try { thread . sleep ( stop_audio_record_delay_millis ) ; mrecorder . stop ( ) ; length = ( int ) ( ( system . currenttimemillis ( ) - msamplestart ) / _num ) ; } catch ( runtimeexception e ) { log . w ( tag , _str + e . getmessage ( ) ) ; } catch ( interruptedexception e ) { log . w ( tag , _str + e . getmessage ( ) ) ; } case state_prepared : case state_idle : default : try { mrecorder . reset ( ) ; } catch ( runtimeexception e ) { log . w ( tag , _str + e . getmessage ( ) ) ; } mrecorder . release ( ) ; mrecorder = null ; mstate = state_idle ; break ; } return length ; }	stop record , and save audio file .
public xmlparser ( final class classtobebound , final string [ ] schemas ) throws xmlexception { try { jaxbcontext jc = jaxbcontext . newinstance ( classtobebound ) ; marshaller = jc . createmarshaller ( ) ; marshaller . setschema ( xmlschemautils . createschema ( schemas ) ) ; unmarshaller = jc . createunmarshaller ( ) ; unmarshaller . setschema ( xmlschemautils . createschema ( schemas ) ) ; } catch ( jaxbexception e ) { throw new xmlexception ( _str + classtobebound , e ) ; } }	creates the xmlparser with the given class as root and schema files for validation .
private void abort ( throwable t ) { throwable = t ; }	set the throwable and abort run loop . the throwable will be thrown from the run loop thread.
@ override public final string readnullterminatedasciistring ( ) { bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; byte b ; while ( _bool ) { b = readbyte ( ) ; if ( b == _num ) { break ; } baos . write ( b ) ; } byte [ ] buf = baos . tobytearray ( ) ; char [ ] chrbuf = new char [ buf . length ] ; for ( int x = _num ; x < buf . length ; x ++ ) { chrbuf [ x ] = ( char ) buf [ x ] ; } return string . valueof ( chrbuf ) ; }	reads a null - terminated string from the stream .
void closesilently ( serversocket socket ) { try { socket . close ( ) ; } catch ( exception e ) { } }	close a server socket , ignoring errors.
public expressionparserbuilder withprocess ( process process ) { this . process = process ; return this ; }	adds the process which enables process dependent functions .
void addassociatedcomponentat ( int index , component cmp ) { if ( comps == null ) { comps = new vector ( ) ; } comps . insertelementat ( cmp , index ) ; }	adds the given component to be associated with this element.
private static byte [ ] readclass ( final inputstream is ) throws ioexception { if ( is == null ) { throw new ioexception ( _str ) ; } byte [ ] b = new byte [ is . available ( ) ] ; int len = _num ; while ( _bool ) { int n = is . read ( b , len , b . length - len ) ; if ( n == - _num ) { if ( len < b . length ) { byte [ ] c = new byte [ len ] ; system . arraycopy ( b , _num , c , _num , len ) ; b = c ; } return b ; } len += n ; if ( len == b . length ) { int last = is . read ( ) ; if ( last < _num ) { return b ; } byte [ ] c = new byte [ b . length + _num ] ; system . arraycopy ( b , _num , c , _num , len ) ; c [ len ++ ] = ( byte ) last ; b = c ; } } }	reads the bytecode of a class .
static string stringfrompacket ( datagrampacket packet ) { return new string ( packet . getdata ( ) , _num , packet . getlength ( ) ) ; }	converts a given datagram packet ' s contents to a string .
private string readattributename ( boolean returnlowercase ) { skipwhitespace ( ) ; int c = find ( attribute_name_terminators ) ; string forsubstring = returnlowercase ? inputlowercase : input ; string result = pos < c ? forsubstring . substring ( pos , c ) : null ; pos = c ; return result ; }	returns the next attribute name , or null if the input has been exhausted.
public boolean contains ( final entity entity ) { if ( entity == null ) { return _bool ; } final irpzone entityzone = entity . getzone ( ) ; return zone . equals ( entityzone ) && zone . has ( entity . getid ( ) ) && shape . contains ( entity . getx ( ) , entity . gety ( ) ) ; }	checks whether an entity is in this area ( e.
protected void checkoffscreenimage ( dimension d ) { if ( doublebuffered ) { if ( offscreen == null || offscreen . getwidth ( ) != d . width || offscreen . getheight ( ) != d . height ) { offscreen = new bufferedimage ( d . width , d . height , bufferedimage . type_int_argb ) ; offscreeng2d = offscreen . creategraphics ( ) ; } } }	ensure that , if doublebuffering is enabled , the offscreen image buffer exists and is the correct size .
public void warning ( org . xml . sax . saxparseexception e ) throws org . xml . sax . saxexception { string formattedmsg = e . getmessage ( ) ; saxsourcelocator locator = getlocator ( ) ; errorlistener handler = m_stylesheetprocessor . geterrorlistener ( ) ; try { handler . warning ( new transformerexception ( formattedmsg , locator ) ) ; } catch ( transformerexception te ) { throw new org . xml . sax . saxexception ( te ) ; } }	receive notification of a xslt processing warning .
public static boolean checkchrootpath ( string zkhost , boolean create ) throws keeperexception , interruptedexception { if ( ! containschroot ( zkhost ) ) { return _bool ; } log . info ( _str ) ; string chrootpath = zkhost . substring ( zkhost . indexof ( _str ) , zkhost . length ( ) ) ; solrzkclient tmpclient = new solrzkclient ( zkhost . substring ( _num , zkhost . indexof ( _str ) ) , _num * _num ) ; boolean exists = tmpclient . exists ( chrootpath , _bool ) ; if ( ! exists && create ) { tmpclient . makepath ( chrootpath , _bool , _bool ) ; exists = _bool ; } tmpclient . close ( ) ; return exists ; }	validates if the chroot exists in zk ( or if it is successfully created ) . optionally , if create is set to true this method will create the path in case it doesn ' t exist.
public void addxvalue ( string xval ) { mxvalaveragelength = ( mxvalaveragelength + xval . length ( ) ) / _num ; mxvals . add ( xval ) ; }	adds a new x - value to the chart data .
public long timesincestart ( ) { long currenttime = system . currenttimemillis ( ) ; return currenttime - starttime ; }	returns the number of milliseconds since the timer started.
public formatter format ( locale l , string format , object ... args ) { ensureopen ( ) ; int last = - _num ; int lasto = - _num ; formatstring [ ] fsa = parse ( format ) ; for ( int i = _num ; i < fsa . length ; i ++ ) { formatstring fs = fsa [ i ] ; int index = fs . index ( ) ; try { switch ( index ) { case - _num : fs . print ( null , l ) ; break ; case - _num : if ( last < _num || ( args != null && last > args . length - _num ) ) throw new missingformatargumentexception ( fs . tostring ( ) ) ; fs . print ( ( args == null ? null : args [ last ] ) , l ) ; break ; case _num : lasto ++ ; last = lasto ; if ( args != null && lasto > args . length - _num ) throw new missingformatargumentexception ( fs . tostring ( ) ) ; fs . print ( ( args == null ? null : args [ lasto ] ) , l ) ; break ; default : last = index - _num ; if ( args != null && last > args . length - _num ) throw new missingformatargumentexception ( fs . tostring ( ) ) ; fs . print ( ( args == null ? null : args [ last ] ) , l ) ; break ; } } catch ( ioexception x ) { lastexception = x ; } } return this ; }	writes a formatted string to this object ' s destination using the specified locale , format string , and arguments .
public void testwritereadempty ( ) throws exception { bytearrayoutputstream out = new bytearrayoutputstream ( _num ) ; objectoutputstream os = new objectoutputstream ( out ) ; os . writeobject ( empty ) ; objectinputstream is = new objectinputstream ( new bytearrayinputstream ( out . tobytearray ( ) ) ) ; clusterpolicy copy = ( clusterpolicy ) is . readobject ( ) ; is . close ( ) ; os . close ( ) ; asserttrue ( helper . areequals ( empty , copy ) ) ; }	test read and write empty clusterpolicy object.
domstringlistimpl ( string [ ] params ) { fstrings = new vector ( ) ; if ( params != null ) { for ( int i = _num ; i < params . length ; i ++ ) { fstrings . add ( params [ i ] ) ; } } }	construct an empty list of domstringlistimpl.
public instant watermarkhold ( ) { long min = long . max_value ; for ( instant hold : watermarkholds . values ( ) ) { min = math . min ( min , hold . getmillis ( ) ) ; } return new instant ( min ) ; }	returns the minimum over all watermark holds .
@ override public final boolean iscappresent ( int cap ) { return ( ( oglcaps . getcaps ( ) & cap ) != _num ) ; }	returns true if the provided capability bit is present for this config.
public static < t > menuresult < t > again ( ) { return new menuresult < > ( type . again , collections . < t > emptylist ( ) ) ; }	creates a new menu result indicating that the menu should be displayed again.
@ suppresswarnings ( _str ) public v put ( k key , v value ) { final int hash = key . hashcode ( ) ; int index = indexof ( key , hash ) ; if ( index >= _num ) { index = ( index << _num ) + _num ; final v old = ( v ) marray [ index ] ; marray [ index ] = value ; return old ; } index = ~ index ; if ( msize >= mhashes . length ) { final int n = msize >= ( base_size * _num ) ? ( msize + ( msize > > _num ) ) : ( msize >= base_size ? ( base_size * _num ) : base_size ) ; final int [ ] ohashes = mhashes ; final object [ ] oarray = marray ; allocarrays ( n ) ; if ( mhashes . length > _num ) { system . arraycopy ( ohashes , _num , mhashes , _num , ohashes . length ) ; system . arraycopy ( oarray , _num , marray , _num , oarray . length ) ; } freearrays ( ohashes , oarray , msize ) ; } if ( index < msize ) { system . arraycopy ( mhashes , index , mhashes , index + _num , msize - index ) ; system . arraycopy ( marray , index << _num , marray , ( index + _num ) << _num , ( msize - index ) << _num ) ; } mhashes [ index ] = hash ; marray [ index << _num ] = key ; marray [ ( index << _num ) + _num ] = value ; msize ++ ; return null ; }	add a new value to the array map .
public long addnewuser ( string sid , string username , string userpass , string lastname , string firstname , string email , string additionalname , string street , string zip , string fax , long states_id , string town , long language_id , string baseurl ) throws axisfault { try { long users_id = sessionmanagement . checksession ( sid ) ; long user_level = usermanagement . getuserlevelbyid ( users_id ) ; if ( authlevelmanagement . checkwebservicelevel ( user_level ) ) { configuration conf = cfgmanagement . getconfkey ( _num , _str ) ; string jname_timezone = _str ; if ( conf != null ) { jname_timezone = conf . getconf_value ( ) ; } long user_id = usermanagement . registeruser ( username , userpass , lastname , firstname , email , new date ( ) , street , additionalname , fax , zip , states_id , town , language_id , _str , baseurl , _bool , jname_timezone ) ; if ( user_id == null || user_id < _num ) { return user_id ; } users user = usermanagement . getuserbyid ( user_id ) ; user . setstatus ( _num ) ; user . setupdatetime ( new date ( ) ) ; usermanagement . updateuser ( user ) ; return user_id ; } else { return new long ( - _num ) ; } } catch ( exception err ) { log . error ( _str , err ) ; throw new axisfault ( err . getmessage ( ) ) ; } }	adds a new usre like through the frontend , but also does activates the account to do sso see the methods to create a hash and use those ones !.
public static void interpreteronly ( runnable runnable ) { runnable . run ( ) ; }	directive for the compiler that the given runnable should only be executed in the interpreter and ignored in the compiled code .
public daddextensiontype ( jdialog parent , x509extension extensions ) { super ( parent , dialog . modalitytype . document_modal ) ; settitle ( res . getstring ( _str ) ) ; this . extensions = extensions ; initcomponents ( ) ; }	creates new daddextensiontype dialog .
private int hash ( graphicsconfiguration config , int w , int h , object ... args ) { int hash ; hash = ( config != null ? config . hashcode ( ) : _num ) ; hash = _num * hash + w ; hash = _num * hash + h ; hash = _num * hash + arrays . deephashcode ( args ) ; return hash ; }	create a unique hash from all the input.
protected void painttext ( graphics g , abstractbutton b , rectangle textrect , string text ) { painttext ( g , ( jcomponent ) b , textrect , text ) ; }	method which renders the text of the current button . < p >.
public static boolean usessecondoperand ( final integer mnemonic ) { return ! mnemonic . equals ( reilhelpers . _opcode_nop ) && ! mnemonic . equals ( reilhelpers . _opcode_bisz ) && ! mnemonic . equals ( reilhelpers . _opcode_str ) && ! mnemonic . equals ( reilhelpers . _opcode_stm ) && ! mnemonic . equals ( reilhelpers . _opcode_ldm ) && ! mnemonic . equals ( reilhelpers . _opcode_jcc ) ; }	checks whether an instruction with the given mnemonic uses its second operand .
public rhythmgroup addoverlay ( rhythmoverlay overlay ) { moverlays . add ( overlay ) ; if ( mcurrentoverlayindex == no_overlay ) { selectoverlay ( _num ) ; } return this ; }	add rhythm overlay to this group.
public char [ ] tochararray ( ) { char [ ] buffer = new char [ count ] ; system . arraycopy ( value , offset , buffer , _num , count ) ; return buffer ; }	converts this string to a new character array .
private file [ ] filterfiles ( final file [ ] tofilter , final string filename ) { if ( filename != null && tofilter != null ) { final file fileasfilter = new file ( filename ) ; for ( file file : tofilter ) { if ( file . compareto ( fileasfilter ) == _num ) { return new file [ ] { fileasfilter } ; } } return new file [ _num ] ; } return tofilter ; }	limit list of possible file to import .
private void pullevent ( ) { final int newscrollvalue ; final int itemdimension ; final float initialmotionvalue , lastmotionvalue ; switch ( getpulltorefreshscrolldirection ( ) ) { case horizontal : initialmotionvalue = minitialmotionx ; lastmotionvalue = mlastmotionx ; break ; case vertical : default : initialmotionvalue = minitialmotiony ; lastmotionvalue = mlastmotiony ; break ; } switch ( mcurrentmode ) { case pull_from_end : newscrollvalue = math . round ( math . max ( initialmotionvalue - lastmotionvalue , _num ) / friction ) ; itemdimension = getfootersize ( ) ; break ; case pull_from_start : default : newscrollvalue = math . round ( math . min ( initialmotionvalue - lastmotionvalue , _num ) / friction ) ; itemdimension = getheadersize ( ) ; break ; } setheaderscroll ( newscrollvalue ) ; if ( newscrollvalue != _num && ! isrefreshing ( ) ) { float scale = math . abs ( newscrollvalue ) / ( float ) itemdimension ; switch ( mcurrentmode ) { case pull_from_end : mfooterlayout . onpull ( scale ) ; break ; case pull_from_start : default : mheaderlayout . onpull ( scale ) ; break ; } if ( mstate != state . pull_to_refresh && itemdimension >= math . abs ( newscrollvalue ) ) { setstate ( state . pull_to_refresh ) ; } else if ( ( mstate == state . pull_to_refresh && itemdimension < math . abs ( newscrollvalue ) ) || ( mstate == state . reset && itemdimension < math . abs ( newscrollvalue ) ) ) { setstate ( state . release_to_refresh ) ; } } }	actions a pull event.
private file writeprivatekeyfile ( ) throws gitexception { final file keydirectory = new file ( rootfolder , host ) ; if ( ! keydirectory . exists ( ) ) { keydirectory . mkdirs ( ) ; } final file keyfile = new file ( keydirectory , default_key_name ) ; try ( fileoutputstream fos = new fileoutputstream ( keyfile ) ) { fos . write ( sshkey ) ; } catch ( ioexception e ) { log . error ( _str , e ) ; throw new gitexception ( _str ) ; } protectprivatekeyfile ( keyfile ) ; return keyfile ; }	writes private ssh key into file .
protected boolean drawleftborder ( component c , graphics g , int x , int y , int width , int height ) { if ( super . drawleftborder ( c , g , x , y , width , height ) && frame . isresizable ( ) ) { g . setcolor ( getframehighlight ( ) ) ; int topy = y + corner_size ; g . drawline ( x , topy , x + _num , topy ) ; int bottomy = height - corner_size ; g . drawline ( x + _num , bottomy , x + _num , bottomy ) ; g . setcolor ( getframeshadow ( ) ) ; g . drawline ( x + _num , topy - _num , x + _num , topy - _num ) ; g . drawline ( x + _num , bottomy - _num , x + _num , bottomy - _num ) ; return _bool ; } return _bool ; }	draws the internalframeborder ' s left border .
public static boolean isfilereadable ( string filename ) { final file file = new file ( filename ) ; return file . exists ( ) && file . canread ( ) ; }	checks whether the given file is readable.
public static string hintingsize ( font font ) { int instrsize = _num ; locatable locatable = fontutils . getlocatable ( font ) ; glyphtable glyftable = fontutils . getglyphtable ( font ) ; for ( int i = _num ; i < locatable . numglyphs ( ) ; i ++ ) { glyph glyph = glyftable . glyph ( locatable . glyphoffset ( i ) , locatable . glyphlength ( i ) ) ; instrsize += glyph . instructionsize ( ) ; } double percentage = instrsize * _num / glyftable . headerlength ( ) ; return string . format ( _str , instrsize , twodecimalplaces . format ( percentage ) ) ; }	gets the size of hinting instructions in the glyph table , both in bytes and as a fraction of the glyph table size .
public static void premain ( string agentargs , instrumentation inst ) { instrumentation = inst ; logger . info ( _str ) ; checkforcorrectsetup ( ) ; try { @ suppresswarnings ( _str ) inspectitclassloader classloader = new inspectitclassloader ( new url [ _num ] ) ; class < ? > agentclazz = classloader . loadclass ( inspectit_agent ) ; constructor < ? > constructor = agentclazz . getconstructor ( file . class ) ; object realagent = constructor . newinstance ( getinspectitagentjarfilelocation ( ) ) ; agent . agent = ( iagent ) realagent ; preloadclasses ( ) ; logger . info ( _str ) ; analyzealreadyloadedclasses ( ) ; inst . addtransformer ( new javaagent ( ) ) ; } catch ( exception e ) { logger . severe ( _str ) ; e . printstacktrace ( ) ; } }	the premain method will be executed before anything else .
private static float systempropertyvalue ( string name ) { string floatstring = system . getproperty ( name ) ; if ( floatstring == null ) return float . nan ; try { return float . parsefloat ( floatstring ) ; } catch ( numberformatexception ex ) { throw new illegalargumentexception ( string . format ( _str , name , floatstring ) ) ; } }	returns the value of the system property , or nan if not defined .
@ zapapiignore public boolean isconfirmremoveproxyexcludeddomain ( ) { return this . confirmremoveproxyexcludedomain ; }	tells whether or not the remotion of a proxy exclusion needs confirmation .
private boolean addlocalkey ( keycacheobject key , affinitytopologyversion topver , collection < keycacheobject > distributedkeys ) throws ignitecheckedexception { griddistributedcacheentry entry = cctx . colocated ( ) . entryexx ( key , topver , _bool ) ; assert ! entry . detached ( ) ; if ( ! cctx . isall ( entry , filter ) ) { if ( log . isdebugenabled ( ) ) log . debug ( _str + entry ) ; oncomplete ( _bool , _bool ) ; return _bool ; } gridcachemvcccandidate cand = addentry ( entry ) ; if ( cand != null && ! cand . reentry ( ) ) distributedkeys . add ( key ) ; return intx ( ) && cand == null ; }	adds local key future .
public void testradix10neg ( ) { string value = _str ; int radix = _num ; biginteger anumber = new biginteger ( value , radix ) ; string result = anumber . tostring ( radix ) ; asserttrue ( result . equals ( value ) ) ; }	test negative number of radix 10.
public synchronized int readintestfromsut ( ) { if ( remotebuffer . isempty ( ) ) { return - _num ; } return remotebuffer . poll ( ) & _num ; }	get the data sent by the sut.
public spatialindex ( string shpfilename ) throws ioexception { this . shpfilename = shpfilename ; if ( logger . isloggable ( level . fine ) ) { logger . fine ( _str + shpfilename + _str ) ; } }	opens a spatial index file for reading based on the location of the provided shp file .
public int invokecompiler ( ) { list < string > args = getexecarguments ( ) ; for ( int i = _num ; i < args . size ( ) ; i ++ ) { string arg = args . get ( i ) ; if ( arg . startswith ( _str ) ) { string filename = arg . substring ( _num ) ; args . remove ( i ) ; outputargumentstofile ( filename , args ) ; break ; } } return executil . execute ( args . toarray ( new string [ args . size ( ) ] ) , system . out , system . err ) ; }	invoke the jsr308 type annotations compiler with all relevant jars on its classpath or boot classpath.
protected void preupdatemenu ( ) { }	hook method which gets executed just before the menu gets updated.
public pojovaluefield ( propertydescriptor desc ) { super ( desc ) ; }	constructs ignite cache value field descriptor .
public urlfilterrule ( string ruletext ) { super ( ruletext ) ; string urlruletext = ruletext ; if ( stringutils . startswith ( urlruletext , mask_white_list ) ) { urlruletext = urlruletext . substring ( mask_white_list . length ( ) ) ; whitelistrule = _bool ; } int optionsindex = stringutils . lastindexof ( urlruletext , options_delimiter ) ; if ( optionsindex > - _num ) { urlruletext = urlruletext . substring ( _num , optionsindex ) ; } urlruletext = topunycode ( urlruletext ) ; boolean regexrule = urlruletext . startswith ( mask_regex_rule ) && urlruletext . endswith ( mask_regex_rule ) ; if ( ! regexrule ) { shortcut = findshortcut ( urlruletext ) ; } }	creates url filter rule.
public static boolean isdrmconvertneeded ( string mimetype ) { return mimetype_drm_message . equals ( mimetype ) ; }	checks if the media type needs to be drm converted.
public static string pad ( string original , int length , char padchar ) { if ( original . length ( ) >= length ) return original ; stringbuilder sb = new stringbuilder ( original ) ; while ( sb . length ( ) < length ) { sb . append ( padchar ) ; } return sb . tostring ( ) ; }	pad the string with the specific character to ensure the string is at least the specified length .
public void propertychange ( propertychangeevent evt ) { string propname = evt . getpropertyname ( ) ; if ( propname == mapbean . cursorproperty ) { fallbackmapbeancursor = ( ( cursor ) evt . getnewvalue ( ) ) ; } else { if ( propname == mousedelegator . activemodeproperty ) { mapmousemode mmm = ( mapmousemode ) evt . getnewvalue ( ) ; setresetcursor ( mmm . getmodecursor ( ) ) ; } else if ( propname == mapbean . layersproperty ) { resetforlayers ( ( layer [ ] ) evt . getnewvalue ( ) , ( layer [ ] ) evt . getoldvalue ( ) ) ; } else if ( propname != mapbean . projectionproperty ) { return ; } setalllabels ( fudgestring ) ; } inittooltip ( ) ; }	listen for changes to the active mouse mode and for any changes to the list of available mouse modes.
private void checkfornight ( final zoneddatetime time ) { int hour = time . gethour ( ) ; int minute = time . getminute ( ) ; if ( _num <= hour && minute >= _num && hour <= _num && minute <= _num || _num <= hour && minute <= _num && hour <= _num && minute <= _num ) { if ( isnightmode ( ) ) return ; setnightmode ( _bool ) ; } else { if ( ! isnightmode ( ) ) return ; setnightmode ( _bool ) ; } }	calling this method will check for the current time of the day and switches on / off the night mode .
@ override public int calculateoffsety ( ) { return - ( int ) ( math . sin ( this . angle ) * this . distance ) - this . shadowsize ; }	calculates the y - offset for drawing the shadow image relative to the source .
private double [ ] concatenatesamples ( final double [ ] x , final double [ ] y ) { final double [ ] z = new double [ x . length + y . length ] ; system . arraycopy ( x , _num , z , _num , x . length ) ; system . arraycopy ( y , _num , z , x . length , y . length ) ; return z ; }	concatenate the samples into one array .
public string handleword ( string aword ) { matcher m = conditionpattern . matcher ( aword ) ; if ( m != null && m . matches ( ) ) { if ( type . equals ( affixtype . prefix ) ) { return handleprefix ( aword ) ; } else if ( type . equals ( affixtype . suffix ) ) { return handlesuffix ( aword ) ; } } return null ; }	adopt this affix on a given word.
public static void round ( calendar c , string unit ) { integer uu = calendar_units . get ( unit ) ; if ( null == uu ) { throw new illegalargumentexception ( _str + unit ) ; } int u = uu . intvalue ( ) ; switch ( u ) { case calendar . year : c . clear ( calendar . month ) ; case calendar . month : c . clear ( calendar . day_of_month ) ; c . clear ( calendar . day_of_week ) ; c . clear ( calendar . day_of_week_in_month ) ; c . clear ( calendar . day_of_year ) ; c . clear ( calendar . week_of_month ) ; c . clear ( calendar . week_of_year ) ; case calendar . date : c . clear ( calendar . hour_of_day ) ; c . clear ( calendar . hour ) ; c . clear ( calendar . am_pm ) ; case calendar . hour_of_day : c . clear ( calendar . minute ) ; case calendar . minute : c . clear ( calendar . second ) ; case calendar . second : c . clear ( calendar . millisecond ) ; break ; default : throw new illegalstateexception ( _str + u + _str + unit ) ; } }	modifies the specified calendar by " rounding " down to the specified unit.
private static final char [ ] growbuffer ( char [ ] dest , int index , int size ) { char [ ] copy = new char [ size ] ; if ( index > _num ) { system . arraycopy ( dest , _num , copy , _num , index ) ; } return copy ; }	helper method to grow the character buffer as needed , this only happens once in a while so it ' s ok if it ' s in a method call.
protected jtextfield createeditorcomponent ( ) { jtextfield editor = new borderlesstextfield ( _str , _num ) ; editor . setborder ( null ) ; return editor ; }	creates the internal editor component.
private void addarg ( string key , object value ) { if ( requestarguments == null ) { requestarguments = new hashtable ( ) ; } if ( value == null || key == null ) { return ; } if ( post ) { setwriterequest ( _bool ) ; } requestarguments . put ( key , value ) ; }	add an argument to the request response.
public static double [ ] readfilecolumn ( string filename , int columnidx , int sizelimit ) throws ioexception , saxexception { path path = paths . get ( filename ) ; if ( ! ( files . exists ( path ) ) ) { throw new saxexception ( _str ) ; } bufferedreader br = new bufferedreader ( new inputstreamreader ( new fileinputstream ( filename ) , _str ) ) ; return readts ( br , columnidx , sizelimit ) ; }	reads timeseries from a file.
private void startreader ( connectiontable conntable ) { assert . asserttrue ( ! this . isrunning ) ; stopped = _bool ; this . isrunning = _bool ; conntable . executecommand ( this ) ; }	starts a reader thread.
public static boolean iscompactionrequiredfortable ( string metafolderpath ) { string minorcompactionstatusfile = metafolderpath + carboncommonconstants . file_separator + carboncommonconstants . minorcompactionrequiredfile ; string majorcompactionstatusfile = metafolderpath + carboncommonconstants . file_separator + carboncommonconstants . majorcompactionrequiredfile ; try { if ( filefactory . isfileexist ( minorcompactionstatusfile , filefactory . getfiletype ( minorcompactionstatusfile ) ) || filefactory . isfileexist ( majorcompactionstatusfile , filefactory . getfiletype ( majorcompactionstatusfile ) ) ) { return _bool ; } } catch ( ioexception e ) { logger . error ( _str + e . getmessage ( ) ) ; } return _bool ; }	check whether the file to indicate the compaction is present or not .
public void addexcludedclass ( string classname ) { mexcludedclasses . add ( classname ) ; }	adds a test class to the filter.
public bundlemessagesource ( locale locale ) { _messages = resourcebundle . getbundle ( base_name , locale ) ; }	creates a new message resource , based on the com.
private void createeditpanel ( ) { editpanel = new jpanel ( ) ; add ( editpanel , borderlayout . center ) ; cardlayout cardlayout = new cardlayout ( ) ; editpanel . setlayout ( cardlayout ) ; if ( colourrampmap != null ) { for ( colourramppanelinterface data : colourrampmap . keyset ( ) ) { data . setparent ( this ) ; string key = data . gettitle ( ) ; editpanel . add ( data . getpanel ( ) , key ) ; } } }	creates the edit panel .
public static long atol ( string s ) { int i = _num ; while ( i < s . length ( ) && character . iswhitespace ( s . charat ( i ) ) ) i ++ ; if ( i < s . length ( ) && s . charat ( i ) == _str ) { if ( i + _num < s . length ( ) && ( s . charat ( i + _num ) == _str || s . charat ( i + _num ) == _str ) ) return parselong ( s . substring ( i + _num ) , _num ) ; else return parselong ( s , _num ) ; } else return parselong ( s , _num ) ; }	converts a string of digits ( decimal , octal or hex ) to a long integer.
public object eval ( reader reader , scriptengine engine ) throws scriptexception { return engine . eval ( reader ) ; }	evaluate a script using the given scriptengine .
public void classforname ( sootmethod container , stmt fornameinvokestmt ) { set < string > classnames = reflectioninfo . classfornameclassnames ( container ) ; if ( classnames == null || classnames . isempty ( ) ) { registerguard ( container , fornameinvokestmt , _str ) ; } else { for ( string clsname : classnames ) { constantforname ( clsname , container , fornameinvokestmt ) ; } } }	adds an edge to all class initializers of all possible receivers of class.
private abstractrenderer createrenderer ( jtabbedpane tabbedpane ) { return hasembeddedtabs ( ) ? abstractrenderer . createembeddedrenderer ( tabbedpane ) : abstractrenderer . createrenderer ( tabpane ) ; }	creates the renderer used to lay out and paint the tabs .
public void readmap ( inputstream inputstream , mapbuilder builder ) { try { parsemap ( inputstream , builder ) ; if ( builder . noderefswithoutdefsadded ( ) ) log . warning ( _str ) ; } catch ( saxparseexception e ) { throw new osmruntimeexception ( _str + _str + e . getpublicid ( ) + _str + e . getsystemid ( ) + _str + e . getlinenumber ( ) + _str + e . getcolumnnumber ( ) + _str , e ) ; } catch ( saxexception e ) { throw new osmruntimeexception ( _str , e ) ; } catch ( ioexception e ) { throw new osmruntimeexception ( _str , e ) ; } finally { if ( inputstream != null ) { try { inputstream . close ( ) ; } catch ( ioexception e ) { log . log ( level . severe , _str , e ) ; } } } }	reads all data from the specified stream and sends it to the consumer.
private void processcomment ( ) { templatereader . nextcharacter ( ) ; if ( templatereader . startswith ( syntax . getdocumenttypeopening ( ) ) ) { processschemacomment ( ) ; return ; } else if ( nestedcomments ) { processnestedcomment ( ) ; return ; } while ( templatereader . hasnextcharacter ( ) ) { final char commentcharacter = templatereader . nextcharacter ( ) ; if ( iscommentclosingmarker ( commentcharacter ) && templatereader . hasnextcharacter ( ) && templatereader . peekcharacter ( ) == syntax . gettagclosing ( ) ) { templatereader . nextcharacter ( ) ; break ; } } }	found an open tag starting with comment sign.
private void emitpermutationsappcache ( treelogger logger , linkercontext context , artifactset artifacts , string startscreenid , offlinescreen offlinescreen ) throws unabletocompleteexception { for ( emittedartifact emitted : artifacts . find ( emittedartifact . class ) ) { if ( emitted . getvisibility ( ) == visibility . private ) { continue ; } string pathname = emitted . getpartialpath ( ) ; if ( acceptcachedresource ( pathname ) ) { if ( ! allartifacts . contains ( pathname ) ) { cachedartifacts . add ( pathname ) ; } } } set < artifactsgroup > keyset = artifactsbygroup . keyset ( ) ; for ( artifactsgroup group : keyset ) { set < string > set = artifactsbygroup . get ( group ) ; set . addall ( cachedartifacts ) ; artifacts . add ( createcachemanifest ( context , logger , set , group . getgroupid ( ) , startscreenid , offlinescreen ) ) ; artifacts . add ( createcachemanifestloader ( context , logger , group . getgroupid ( ) , startscreenid ) ) ; } }	manifest file manipulation methods.
public license ( final string filename , final string text ) { if ( filename == null ) { throw new nullpointerexception ( _str ) ; } if ( filename . isempty ( ) ) { throw new illegalargumentexception ( _str ) ; } this . filename = filename ; if ( text == null ) { throw new nullpointerexception ( _str ) ; } if ( text . isempty ( ) ) { throw new illegalargumentexception ( _str ) ; } this . text = text ; }	creates a new license with the given license text .
long calculatemidentry ( long loval , long hival , final double dfp , long loentry , long hientry ) { final double dhi = ( double ) hientry ; final double dlo = ( double ) loentry ; final double dhival = ( double ) hival ; final double dloval = ( double ) loval ; long midentry = loentry + ( long ) ( ( dhi - dlo ) * ( dfp - dloval ) / ( dhival - dloval ) ) ; if ( midentry == hientry ) { midentry -- ; } return midentry ; }	calculates a mid entry where to divide the interval.
@ suppresswarnings ( _str ) protected int hashfields ( int hash , map < fielddescriptor , object > map ) { for ( map . entry < fielddescriptor , object > entry : map . entryset ( ) ) { fielddescriptor field = entry . getkey ( ) ; object value = entry . getvalue ( ) ; hash = ( _num * hash ) + field . getnumber ( ) ; if ( field . gettype ( ) != fielddescriptor . type . enum ) { hash = ( _num * hash ) + value . hashcode ( ) ; } else if ( field . isrepeated ( ) ) { list < ? extends enumlite > list = ( list < ? extends enumlite > ) value ; hash = ( _num * hash ) + hashenumlist ( list ) ; } else { hash = ( _num * hash ) + hashenum ( ( enumlite ) value ) ; } } return hash ; }	get a hash code for given fields and values , using the given seed .
public dashboardservicehelper ( ) { attributesrequireupdate . add ( dashboard_class_name ) ; attributesrequireupdate . add ( dashboard_name ) ; attributesrequireupdate . add ( dashboard_display_name ) ; attributesrequireupdate . add ( dashboard_icon ) ; attributesrequireupdate . add ( dashboard_login ) ; attributesrequireupdate . add ( icf_identifier ) ; attributes . addall ( attributesrequireupdate ) ; }	constructs an instance of the dashboardservicehelper.
public static string javautilregexescape ( string s ) { if ( s . indexof ( _str ) == - _num ) { return _str + s + _str ; } stringbuilder sb = new stringbuilder ( ) ; for ( int i = _num ; i < s . length ( ) ; i ++ ) { sb . append ( _str ) ; sb . append ( s . charat ( i ) ) ; } return sb . tostring ( ) ; }	escapes the special characters from a string so it can be used as part of a regex pattern.
public void forgetffmpegpath ( ) { settings . put ( settings_ffmpeg_path , ffmpeg_path_unset ) ; }	makes the library forget about where the ffmpeg binary was located.
@ override public void printwarning ( final string message ) { printwarning ( message , preferencestore . getboolean ( uipreferenceconstants . console_show_on_new_warning ) ) ; }	prints a warning message to the console.
public static string revertnewlines ( string string ) { int index ; stringbuffer newstringbuffer = new stringbuffer ( ) ; while ( ( index = string . indexof ( _str ) ) != - _num ) { if ( index > _num ) { newstringbuffer . append ( string . substring ( _num , index ) ) ; } newstringbuffer . append ( _str ) ; if ( ( index + _num ) < string . length ( ) ) { string = string . substring ( index + _num ) ; } else { string = _str ; } } newstringbuffer . append ( string ) ; string = newstringbuffer . tostring ( ) ; newstringbuffer = new stringbuffer ( ) ; while ( ( index = string . indexof ( _str ) ) != - _num ) { if ( index > _num ) { newstringbuffer . append ( string . substring ( _num , index ) ) ; } newstringbuffer . append ( _str ) ; if ( ( index + _num ) < string . length ( ) ) { string = string . substring ( index + _num ) ; } else { string = _str ; } } newstringbuffer . append ( string ) ; return newstringbuffer . tostring ( ) ; }	reverts \ r and \ n in a string into carriage returns and new lines .
@ override public void oninsertcomplete ( int taskid , object cookie , long insertrowid ) { if ( taskid == appconstants . querytokens . insert_wallpost && insertrowid != - _num ) { logger . i ( tag , _str + insertrowid ) ; } }	method called when an asynchronous insert operation is done.
protected void parselist ( arraylist < string > list , string text ) { list . clear ( ) ; stringtokenizer st = new stringtokenizer ( text , _str ) ; while ( st . hasmoreelements ( ) ) { string line = ( string ) st . nextelement ( ) ; list . add ( line . trim ( ) ) ; } }	create a list of patterns from chunk of text , patterns are separated with newline.
protected list < node > splitassignments ( node node ) { if ( node instanceof assignmentnode ) { list < node > result = new arraylist < > ( ) ; assignmentnode a = ( assignmentnode ) node ; result . add ( a . gettarget ( ) ) ; result . addall ( splitassignments ( a . getexpression ( ) ) ) ; return result ; } else { return collections . singletonlist ( node ) ; } }	takes a node , and either returns the node itself again ( as a singleton list ) , or if the node is an assignment node , returns the lhs and rhs ( where splitassignments is applied recursively to the rhs ) .
public tree < string > extractbestmaxruleparse ( int start , int end , list < string > sentence ) { return extractbestmaxruleparse1 ( start , end , _num , sentence ) ; }	returns the best parse , the one with maximum expected labelled recall.
public static double normalize ( double val , double min , double max ) { if ( max < min ) throw new illegalargumentexception ( _str ) ; return ( val - min ) / ( max - min ) ; }	normalize a value ( val - min ) / ( max - min ).
private static boolean containsonlytransientandstaticfields ( list < field > fields ) { boolean containsnormalfield = _bool ; for ( field field : fields ) { if ( ! modifier . istransient ( field . getmodifiers ( ) ) && ! modifier . isstatic ( field . getmodifiers ( ) ) ) { containsnormalfield = _bool ; } } return ! containsnormalfield ; }	only contains transient or static fields , which is the case for a model that is empty , but says it " implements parcelable ".
@ override public void appendindexmapto ( appendable out , string name , list < sourcemapsection > sections ) throws ioexception { out . append ( _str ) ; appendfirstfield ( out , _str , _str ) ; appendfield ( out , _str , escapestring ( name ) ) ; appendfieldstart ( out , _str ) ; out . append ( _str ) ; boolean first = _bool ; for ( sourcemapsection section : sections ) { if ( first ) { first = _bool ; } else { out . append ( _str ) ; } out . append ( _str ) ; appendfirstfield ( out , _str , offsetvalue ( section . getline ( ) , section . getcolumn ( ) ) ) ; if ( section . getsectiontype ( ) == sourcemapsection . sectiontype . url ) { appendfield ( out , _str , escapestring ( section . getsectionvalue ( ) ) ) ; } else if ( section . getsectiontype ( ) == sourcemapsection . sectiontype . map ) { appendfield ( out , _str , section . getsectionvalue ( ) ) ; } else { throw new ioexception ( _str ) ; } out . append ( _str ) ; } out . append ( _str ) ; appendfieldend ( out ) ; out . append ( _str ) ; }	appends the index source map to the given buffer .
public builder addpart ( part part ) { if ( part == null ) throw new nullpointerexception ( _str ) ; parts . add ( part ) ; return this ; }	add a part to the body .
protected void notifygone ( l locator ) { synchronized ( this ) { if ( ! stalelocators . add ( locator . getpartitionid ( ) ) ) { fail ( _str + locator ) ; } } }	notify the data service that an index partition is no longer located on that data service .
@ override public void addvetoablechangelistener ( string name , vetoablechangelistener vcl ) { m_bcsupport . addvetoablechangelistener ( name , vcl ) ; }	add a vetoable change listener to this bean.
public string builduser ( ) { return properties . getproperty ( _str ) ; }	returns the username of the user that created this build .
private void updateidleexpiretime ( long now ) { _threadidleexpiretime . set ( now + _idletimeout ) ; }	updates the thread idle expire time .
protected ctclass createctclass ( string classname , boolean usecache ) { if ( classname . charat ( _num ) == _str ) classname = descriptor . toclassname ( classname ) ; if ( classname . endswith ( _str ) ) { string base = classname . substring ( _num , classname . indexof ( _str ) ) ; if ( ( ! usecache || getcached ( base ) == null ) && find ( base ) == null ) return null ; else return new ctarray ( classname , this ) ; } else if ( find ( classname ) == null ) return null ; else return new ctclasstype ( classname , this ) ; }	creates a ctclass object representing the specified class.
@ transactional public long createvoucherfrombill ( final int billid ) throws applicationruntimeexception { try { string voucherstatus = null ; final list vstatuslist = appconfigvaluesservice . getconfigvaluesbymoduleandkey ( _str , _str ) ; if ( ! vstatuslist . isempty ( ) && vstatuslist . size ( ) == _num ) { final appconfigvalues appval = ( appconfigvalues ) vstatuslist . get ( _num ) ; voucherstatus = appval . getvalue ( ) ; } else throw new applicationruntimeexception ( _str + missingmsg ) ; final long vh = createvoucher . createvoucherfrombill ( billid , voucherstatus , null , null ) ; return vh ; } catch ( final exception e ) { logger . error ( e . getmessage ( ) ) ; throw new applicationruntimeexception ( e . getmessage ( ) ) ; } }	api to create voucher from bill with normal flow.
public static float compareequivalance ( bitmap bitmap1 , bitmap bitmap2 ) { if ( bitmap1 == null || bitmap2 == null || bitmap1 . getwidth ( ) != bitmap2 . getwidth ( ) || bitmap1 . getheight ( ) != bitmap2 . getheight ( ) ) { return _num ; } bytebuffer buffer1 = bytebuffer . allocate ( bitmap1 . getheight ( ) * bitmap1 . getrowbytes ( ) ) ; bitmap1 . copypixelstobuffer ( buffer1 ) ; bytebuffer buffer2 = bytebuffer . allocate ( bitmap2 . getheight ( ) * bitmap2 . getrowbytes ( ) ) ; bitmap2 . copypixelstobuffer ( buffer2 ) ; byte [ ] array1 = buffer1 . array ( ) ; byte [ ] array2 = buffer2 . array ( ) ; int len = array1 . length ; int count = _num ; for ( int i = _num ; i < len ; i ++ ) { if ( array1 [ i ] == array2 [ i ] ) { count ++ ; } } return ( ( float ) ( count ) ) / len ; }	compares two bitmaps and gives the percentage of similarity.
public void handletblcharsetaliashrefactionrequest ( requestinvocationevent event ) throws modelcontrolexception { try { map values = getvalues ( ) ; onbeforesaveprofile ( values ) ; setpagesessionattribute ( property_attribute , ( hashmap ) values ) ; g11ncharsetaliaseditviewbean vb = ( g11ncharsetaliaseditviewbean ) getviewbean ( g11ncharsetaliaseditviewbean . class ) ; unlockpagetrail ( ) ; passpgsessionmap ( vb ) ; vb . populatevalues ( ( string ) getdisplayfieldvalue ( _str ) ) ; vb . forwardto ( getrequestcontext ( ) ) ; } catch ( amconsoleexception e ) { setinlinealertmessage ( ccalert . type_error , _str , e . getmessage ( ) ) ; } }	handles edit charset alias request .
public booleanglassgeneim ( booleanglassgenepm genepm , parameters parameters ) { try { this . genepm = genepm ; this . glassfunction = new booleanglassfunction ( genepm . getlaggraph ( ) ) ; this . initializer = new basalinitializer ( glassfunction , _num , _num ) ; this . history = new genehistory ( initializer , glassfunction ) ; this . simulator = new measurementsimulatorparams ( parameters ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }	obtains a boolean glass function from the boolean glass gene pm provided and uses it to create a glass history and a measurement simulator.
protected list < item_type > selectfoldtrainitems ( list < item_type > items , int nfolds , int fold ) { list < item_type > trainitems = new arraylist < item_type > ( ) ; for ( int i = _num ; i < items . size ( ) ; ++ i ) { if ( i % nfolds != fold ) { trainitems . add ( items . get ( i ) ) ; } } return trainitems ; }	determines which items should be used for training in one fold of a cross - validation.
protected void rehash ( int newcapacity ) { int oldcapacity = _set . length ; k oldkeys [ ] = ( k [ ] ) _set ; short oldvals [ ] = _values ; _set = new object [ newcapacity ] ; arrays . fill ( _set , free ) ; _values = new short [ newcapacity ] ; for ( int i = oldcapacity ; i -- > _num ; ) { if ( oldkeys [ i ] != free && oldkeys [ i ] != removed ) { k o = oldkeys [ i ] ; int index = insertionindex ( o ) ; if ( index < _num ) { throwobjectcontractviolation ( _set [ ( - index - _num ) ] , o ) ; } _set [ index ] = o ; _values [ index ] = oldvals [ i ] ; } } }	rehashes the map to the new capacity .
protected void addattributes ( element element , attributes attributes ) { boolean nonamespaceattributes = _bool ; if ( element instanceof abstractelement ) { abstractelement baseelement = ( abstractelement ) element ; baseelement . setattributes ( attributes , namespacestack , nonamespaceattributes ) ; } else { int size = attributes . getlength ( ) ; for ( int i = _num ; i < size ; i ++ ) { string attributeqname = attributes . getqname ( i ) ; if ( nonamespaceattributes || ! attributeqname . startswith ( _str ) ) { string attributeuri = attributes . geturi ( i ) ; string attributelocalname = attributes . getlocalname ( i ) ; string attributevalue = attributes . getvalue ( i ) ; qname qname = namespacestack . getattributeqname ( attributeuri , attributelocalname , attributeqname ) ; element . addattribute ( qname , attributevalue ) ; } } } }	add all the attributes to the given elements.
public static < t > boolean remove ( collection < t > collection , t element ) { if ( element == null ) { return _bool ; } if ( collectionutils . isempty ( collection ) ) { return _bool ; } return collection . remove ( element ) ; }	safe method to remove an element from collection.
private static void persistupdatedvpoollist ( list < virtualpool > updatedvpoollist , dbclient dbclient ) { if ( ! updatedvpoollist . isempty ( ) ) { dbclient . updateandreindexobject ( updatedvpoollist ) ; } }	persist all the virtualpool which are updated with matched pools .
void composetemplates ( elemtemplateelement templ ) throws transformerexception { templ . compose ( this ) ; for ( elemtemplateelement child = templ . getfirstchildelem ( ) ; child != null ; child = child . getnextsiblingelem ( ) ) { composetemplates ( child ) ; } templ . endcompose ( this ) ; }	call the compose function for each elemtemplateelement .
public static boolean classexists ( string classname ) { try { return class . forname ( classname ) != null ; } catch ( classnotfoundexception e ) { return _bool ; } }	helper method to safely check whether a class exists at runtime .
public static void createtoplevelclassesxml ( string outputdir , string templatespath , boolean lenient ) throws compilerexception { try { asdochelper asdochelp = new asdochelper ( outputdir + _str , outputdir + _str , outputdir , outputdir + _str + file . separator + _str ) ; asdochelp . createtoplevelclasses ( lenient ) ; } catch ( throwable t ) { t . printstacktrace ( ) ; compilermessage c = new couldnotcreate ( _str , t . getmessage ( ) ) ; threadlocaltoolkit . log ( c ) ; throw c ; } }	this method is called to kick off the dita generation process.
void drawshape ( graphics g , css . value type , int ax , int ay , int aw , int ah , float align ) { int gap = islefttoright ? - ( bulletgap + _num ) : ( aw + bulletgap ) ; int x = ax + gap ; int y = math . max ( ay , ay + ( int ) ( align * ah ) - _num ) ; if ( type == css . value . square ) { g . drawrect ( x , y , _num , _num ) ; } else if ( type == css . value . circle ) { g . drawoval ( x , y , _num , _num ) ; } else { g . filloval ( x , y , _num , _num ) ; } }	draws the graphical bullet item specified by the type argument .
public static void restore ( final context context ) { sharedpreferences prefs = preferencemanager . getdefaultsharedpreferences ( context ) ; if ( longtermorbits . issupported ( ) && prefs . getboolean ( key_location_toggle , _bool ) ) { savedownloaddatawifionlypref ( context ) ; alarmmanager am = ( alarmmanager ) context . getsystemservice ( context . alarm_service ) ; intent intent = new intent ( context , ltoservice . class ) ; pendingintent pi = pendingintent . getservice ( context , _num , intent , pendingintent . flag_update_current | pendingintent . flag_one_shot ) ; long nextltodownload = system . currenttimemillis ( ) + ( _num * _num * _num ) ; am . set ( alarmmanager . rtc , nextltodownload , pi ) ; } }	restore the properties associated with this preference on boot.
private void generatefile ( int wordcnt ) throws exception { random rnd = new random ( system . currenttimemillis ( ) ) ; try ( outputstreamwriter writer = new outputstreamwriter ( igfs . create ( file , _bool ) ) ) { int cnt = _num ; while ( cnt < wordcnt ) { string word = dictionary [ rnd . nextint ( dictionary . length ) ] ; writer . write ( word + _str ) ; cnt ++ ; } } }	generate file with random data and provided argument .
public void polygon ( double [ ] x , double [ ] y ) { int n = x . length ; generalpath path = new generalpath ( ) ; path . moveto ( ( float ) scalex ( x [ _num ] ) , ( float ) scaley ( y [ _num ] ) ) ; for ( int i = _num ; i < n ; i ++ ) path . lineto ( ( float ) scalex ( x [ i ] ) , ( float ) scaley ( y [ i ] ) ) ; path . closepath ( ) ; offscreen . draw ( path ) ; draw ( ) ; }	draws a polygon with the given ( x [ i ] , y [ i ] ) coordinates .
public void append ( int key , e value ) { if ( msize != _num && key <= mkeys [ msize - _num ] ) { put ( key , value ) ; return ; } if ( mgarbage && msize >= mkeys . length ) { gc ( ) ; } int pos = msize ; if ( pos >= mkeys . length ) { int n = containerhelpers . idealintarraysize ( pos + _num ) ; int [ ] nkeys = new int [ n ] ; object [ ] nvalues = new object [ n ] ; system . arraycopy ( mkeys , _num , nkeys , _num , mkeys . length ) ; system . arraycopy ( mvalues , _num , nvalues , _num , mvalues . length ) ; mkeys = nkeys ; mvalues = nvalues ; } mkeys [ pos ] = key ; mvalues [ pos ] = value ; msize = pos + _num ; }	puts a key / value pair into the array , optimizing for the case where the key is greater than all existing keys in the array .
public list < searchresult > searchbyobjectname ( string name ) { list < searchresult > all = new arraylist < > ( ) ; for ( layer layer : layers ) { if ( islayervisible ( layer ) ) { all . addall ( layer . searchbyobjectname ( name ) ) ; } } log . d ( tag , _str + all . size ( ) + _str + name ) ; return all ; }	search all visible layers for an object with the given name .
private void clearmessages ( ) { messages . clear ( ) ; }	clear the current list of pending messages.
public void cleartextedits ( ) { fedits . clear ( ) ; }	removes all text edits from this group .
public static void main ( string [ ] args ) { frame frame = new packettool ( ) ; frame . pack ( ) ; frame . setlocationrelativeto ( null ) ; frame . setvisible ( _bool ) ; }	display a window for testing the transmission of boards .
private void createtoolbar ( ) { toolbar = new jtoolbar ( _str ) ; if ( listener . runningasjconsoleplugin || listener . runningasvisualvmplugin ) { toolbar . add ( createtoolbarbutton ( _str , _str ) ) ; toolbar . setfloatable ( _bool ) ; } else { toolbar . add ( createtoolbarbutton ( _str , _str ) ) ; closetoolbarbutton = createtoolbarbutton ( _str , _str ) ; closetoolbarbutton . setenabled ( _bool ) ; toolbar . add ( closetoolbarbutton ) ; } toolbar . addseparator ( ) ; toolbar . add ( createtoolbarbutton ( _str , _str ) ) ; toolbar . addseparator ( ) ; expandbutton = createtoolbarbutton ( _str , _str ) ; expandbutton . setenabled ( _bool ) ; toolbar . add ( expandbutton ) ; collapsebutton = createtoolbarbutton ( _str , _str ) ; collapsebutton . setenabled ( _bool ) ; toolbar . add ( collapsebutton ) ; toolbar . addseparator ( ) ; findlrthreadsbutton = createtoolbarbutton ( _str , _str ) ; findlrthreadsbutton . setenabled ( _bool ) ; toolbar . add ( findlrthreadsbutton ) ; toolbar . add ( createtoolbarbutton ( _str , _str ) ) ; toolbar . add ( createtoolbarbutton ( _str , _str ) ) ; toolbar . addseparator ( ) ; }	create a toolbar showing the most important main menu entries .
public static map attrsettomap ( attrset attrset , boolean fetchbytevalues ) { map attributesmap = new amhashmap ( fetchbytevalues ) ; if ( attrset == null ) { return attributesmap ; } int attrsetsize = attrset . size ( ) ; if ( ! fetchbytevalues ) { for ( int i = _num ; i < attrsetsize ; i ++ ) { attr attr = attrset . elementat ( i ) ; string values [ ] = attr . getstringvalues ( ) ; attributesmap . put ( attr . getname ( ) , stringarraytoset ( values ) ) ; } } else { for ( int i = _num ; i < attrsetsize ; i ++ ) { attr attr = attrset . elementat ( i ) ; attributesmap . put ( attr . getname ( ) , attr . getbytevalues ( ) ) ; } } return attributesmap ; }	method to convert a attrset object to map .
public final iterator < string > schemesiterator ( ) { return mdataschemes != null ? mdataschemes . iterator ( ) : null ; }	return an iterator over the filter ' s data schemes .
public static void reinitrecompiler ( ) { _rewriter . set ( new programrewriter ( _bool , _bool ) ) ; }	re - initializes the recompiler according to the current optimizer flags .
default value remove ( optional < ? extends charsequence > name ) { return name . ispresent ( ) ? remove ( name . get ( ) ) : null ; }	if the supplied name is provided , then remove the field with the supplied name and return the value .
private string nexttointernal ( string excluded ) { int start = pos ; for ( ; pos < in . length ( ) ; pos ++ ) { char c = in . charat ( pos ) ; if ( c == _str || c == _str || excluded . indexof ( c ) != - _num ) { return in . substring ( start , pos ) ; } } return in . substring ( start ) ; }	returns the string up to but not including any of the given characters or a newline character.
accepttcp ( porttcp port , serversocketbar serversocket ) { objects . requirenonnull ( port ) ; objects . requirenonnull ( serversocket ) ; _port = port ; _serversocket = serversocket ; }	creates a new accept thread.
private static void updategrabbedcursor ( cursor cur ) { xbasewindow target = xawtstate . getgrabwindow ( ) ; if ( target instanceof xwindowpeer ) { xwindowpeer grabber = ( xwindowpeer ) target ; grabber . psetcursor ( cur ) ; } }	updates cursor on the grabber if it is window peer ( i.
protected void parseuri ( string uristring ) throws urisyntaxexception { string s = uristring ; int index = s . indexof ( fragment_separator ) ; if ( index != - _num ) { setfragment ( s . substring ( index + _num ) , _bool ) ; s = s . substring ( _num , index ) ; } index = s . indexof ( scheme_separator ) ; if ( index != - _num ) { string scheme = s . substring ( _num , index ) ; if ( isvalidscheme ( scheme ) ) { setscheme ( scheme ) ; s = s . substring ( index + _num ) ; } } parseschemespecificpart ( s , _bool ) ; }	rather than attempting to process the uri string in a linear fashion , this implementation works its way from outside - in.
@ override public boolean equals ( object obj ) { if ( ( obj instanceof keepalivekey ) == _bool ) return _bool ; keepalivekey kae = ( keepalivekey ) obj ; return host . equals ( kae . host ) && ( port == kae . port ) && protocol . equals ( kae . protocol ) && this . obj == kae . obj ; }	determine whether or not two objects of this type are equal.
protected static void appendlongstringtype ( stringbuilder sb ) { sb . append ( _str ) ; }	output the sql type for a java long string .
public void testconnectheadset ( ) { int iterations = bluetoothtestrunner . sconnectheadsetiterations ; if ( iterations == _num ) { return ; } bluetoothadapter adapter = bluetoothadapter . getdefaultadapter ( ) ; bluetoothdevice device = adapter . getremotedevice ( bluetoothtestrunner . sdeviceaddress ) ; mtestutils . disable ( adapter ) ; mtestutils . enable ( adapter ) ; mtestutils . unpair ( adapter , device ) ; mtestutils . pair ( adapter , device , bluetoothtestrunner . sdevicepairpasskey , bluetoothtestrunner . sdevicepairpin ) ; mtestutils . disconnectprofile ( adapter , device , bluetoothprofile . headset , null ) ; for ( int i = _num ; i < iterations ; i ++ ) { mtestutils . writeoutput ( _str + ( i + _num ) + _str + iterations ) ; mtestutils . connectprofile ( adapter , device , bluetoothprofile . headset , string . format ( _str , device ) ) ; mtestutils . disconnectprofile ( adapter , device , bluetoothprofile . headset , string . format ( _str , device ) ) ; } mtestutils . unpair ( adapter , device ) ; mtestutils . disable ( adapter ) ; }	stress test for connecting and disconnecting the hfp with a hands free device.
public static boolean isna ( string [ ] nastrings , string w ) { if ( nastrings == null ) return _bool ; for ( string na : nastrings ) { if ( w . equals ( na ) ) return _bool ; } return _bool ; }	function that checks if the given string is one of na strings .
private double [ ] evaluateprobability ( double [ ] data ) { double [ ] prob = new double [ m_numclasses ] , v = new double [ m_numclasses ] ; for ( int j = _num ; j < m_numclasses - _num ; j ++ ) { for ( int k = _num ; k <= m_numpredictors ; k ++ ) { v [ j ] += m_par [ k ] [ j ] * data [ k ] ; } } v [ m_numclasses - _num ] = _num ; for ( int m = _num ; m < m_numclasses ; m ++ ) { double sum = _num ; for ( int n = _num ; n < m_numclasses - _num ; n ++ ) { sum += math . exp ( v [ n ] - v [ m ] ) ; } prob [ m ] = _num / ( sum + math . exp ( - v [ m ] ) ) ; } return prob ; }	compute the posterior distribution using optimized parameter values and the testing instance .
public static final hashmap readmapxml ( inputstream in ) throws xmlpullparserexception , ioexception { xmlpullparser parser = xml . newpullparser ( ) ; parser . setinput ( in , null ) ; return ( hashmap ) readvaluexml ( parser , new string [ _num ] ) ; }	read a hashmap from an inputstream containing xml.
protected void modifyomgraphicforeditrender ( ) { }	a convenience method that gives an editableomgraphic a chance to modify the omgraphic so it can be drawn quickly , by turning off labels , etc , right before the xorpainting happens.
public observable < driveid > createfile ( drivefolder folder , file file , string title ) { return createfile ( folder , file , title , mimetypemap . getfileextensionfromurl ( file . getpath ( ) ) ) ; }	creates a file on drive.
public static string extractcollectionfrompath ( string path ) { string extractedcollectionname = null ; string pathmodified = removefromendofstring ( path , slash ) ; string [ ] pathsegments = pathmodified . split ( _str ) ; if ( pathsegments . length > _num ) { extractedcollectionname = pathsegments [ pathsegments . length - _num ] ; } return extractedcollectionname ; }	extracts the collection name from the given path . the collection name is known to be the last segment of the path.
public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addall ( collections . list ( super . listoptions ( ) ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public boolean isprivate ( ) { return modifier . isprivate ( _field . getmodifiers ( ) ) ; }	returns true for a private field .
public static final long longencode ( final string hash ) { int level = hash . length ( ) - _num ; long b ; long l = _num ; for ( char c : hash . tochararray ( ) ) { b = ( long ) ( base_32_string . indexof ( c ) ) ; l |= ( b << ( level -- * _num ) ) ; } return ( l << _num ) | hash . length ( ) ; }	encode from geohash string to the geohash based long format ( lon / lat interleaved , 4 least significant bits = level ).
@ override public void onsuccess ( t result ) { try { logger . debug ( _str , result ) ; queue . put ( result ) ; } catch ( interruptedexception e ) { logger . warn ( _str , e ) ; } }	on success we add the result to our blocking queue.
public void handletblproviderresourceidmapperbuttonaddrequest ( requestinvocationevent event ) throws modelcontrolexception { try { map values = getvalues ( ) ; onbeforesaveprofile ( values ) ; setpagesessionattribute ( property_attribute , ( hashmap ) values ) ; smdiscoveryproviderresourceidmapperaddviewbean vb = ( smdiscoveryproviderresourceidmapperaddviewbean ) getviewbean ( smdiscoveryproviderresourceidmapperaddviewbean . class ) ; removepagesessionattribute ( smdiscoveryproviderresourceidmapperaddviewbean . property_attribute ) ; unlockpagetrail ( ) ; passpgsessionmap ( vb ) ; vb . forwardto ( getrequestcontext ( ) ) ; } catch ( amconsoleexception e ) { setinlinealertmessage ( ccalert . type_error , _str , e . getmessage ( ) ) ; } }	handles add provider resource id mapper request .
public copenoriginalfunction ( final cgraphwindow parent , final iviewcontainer container , final inavifunction function ) { super ( string . format ( _str , function . getname ( ) ) ) ; m_parent = parent ; m_container = container ; m_function = function ; }	creates a new action object .
public int read ( char [ ] buffer , int offset , int length ) throws ioexception { byte [ ] bytes = new byte [ length ] ; int count = _file . read ( bytes , _num , length ) ; for ( int i = _num ; i < count ; i ++ ) { buffer [ offset + i ] = ( char ) bytes [ i ] ; } return count ; }	reads a block starting from the current file pointer .
public boolean equals ( object o ) { if ( ! ( o instanceof vector2f ) ) { return _bool ; } if ( this == o ) { return _bool ; } vector2f comp = ( vector2f ) o ; if ( float . compare ( x , comp . x ) != _num ) { return _bool ; } if ( float . compare ( y , comp . y ) != _num ) { return _bool ; } return _bool ; }	are these two vectors the same ? they are is they both have the same x and y values .
@ override protected eclass findinstantiablecompatible ( eclass etype ) { if ( ! isinstantiatablesubtype ( etype , etype ) ) { throw new illegalstateexception ( string . valueof ( etype ) ) ; } return etype ; }	later here have to be checked the inheritance hierarchy , too.
private int measurewidth ( int measurespec ) { int result = _num ; int specmode = measurespec . getmode ( measurespec ) ; int specsize = measurespec . getsize ( measurespec ) ; if ( specmode == measurespec . exactly ) { result = specsize ; } else { result = image_width + max_text_width + toast_height ; if ( specmode == measurespec . at_most ) { result = math . min ( result , specsize ) ; } } return result ; }	determines the width of this view.
public void restoretopology ( iterable < tcpdiscoverynode > nodes , long topver ) { assert ! f . isempty ( nodes ) ; assert topver > _num ; rwlock . writelock ( ) . lock ( ) ; try { locnode . internalorder ( topver ) ; clear ( ) ; boolean firstadd = _bool ; for ( tcpdiscoverynode node : nodes ) { if ( nodesmap . containskey ( node . id ( ) ) ) continue ; nodesmap . put ( node . id ( ) , node ) ; if ( firstadd ) { this . nodes = new treeset < > ( this . nodes ) ; firstadd = _bool ; } node . lastupdatetime ( u . currenttimemillis ( ) ) ; this . nodes . add ( node ) ; } nodeorder = topver ; initializeminimumversion ( ) ; } finally { rwlock . writelock ( ) . unlock ( ) ; } }	restores topology from parameters values.
final protected void startop ( final istartopmessage msg ) { if ( ! controller ) throw new unsupportedoperationexception ( err_not_controller ) ; if ( msg == null ) throw new illegalargumentexception ( ) ; if ( ! queryid . equals ( msg . getqueryid ( ) ) ) throw new illegalargumentexception ( ) ; lock . lock ( ) ; try { if ( log . istraceenabled ( ) ) log . trace ( msg . tostring ( ) ) ; if ( future . isdone ( ) ) throw new runtimeexception ( _str ) ; runstate . startop ( msg ) ; } catch ( timeoutexception ex ) { halt ( ex ) ; } finally { lock . unlock ( ) ; } }	message provides notice that the operator has started execution and will consume some specific number of binding set chunks .
public flux < in > drain ( ) { return flux . empty ( ) ; }	drain is a hot replication of the current buffer delivered if supported.
int traverseconsistencycheck ( texteditprocessor processor , document document , list < list < textedit > > sourceedits ) { int result = _num ; if ( fchildren != null ) { for ( int i = fchildren . size ( ) - _num ; i >= _num ; i -- ) { textedit child = ( textedit ) fchildren . get ( i ) ; result = math . max ( result , child . traverseconsistencycheck ( processor , document , sourceedits ) ) ; } } if ( processor . consideredit ( this ) ) { performconsistencycheck ( processor , document ) ; } return result ; }	traverses the edit tree to perform the consistency check .
public minute ( date time , timezone zone ) { this ( time , zone , locale . getdefault ( ) ) ; }	constructs a new minute , based on the supplied date / time and timezone .
private plan buildplan1 ( ) { plan plan = populationutils . createplan ( ) ; activity a = populationutils . createactivityfromcoord ( _str , coordutils . createcoord ( _num , _num ) ) ; a . setendtime ( time . parsetime ( _str ) ) ; plan . addactivity ( a ) ; plan . addleg ( populationutils . createleg ( _str ) ) ; double traveltime = time . parsetime ( _str ) ; double distance = math . round ( ( traveltime * chainchopper . average_speed ) / chainchopper . crowfly_factor ) ; activity b = populationutils . createactivityfromcoord ( _str , coordutils . createcoord ( distance , _num ) ) ; plan . addactivity ( b ) ; return plan ; }	a test plan for which the 24 - hour cut is along the journey . 16 : 00 | 08 : 00 a - - - | - - - > b | 24 : 00.
protected void encodeatom ( outputstream outstream , byte data [ ] , int offset , int len ) throws ioexception { byte a , b = _num , c = _num ; int c1 , c2 , c3 , c4 ; a = data [ offset ] ; if ( len > _num ) { b = data [ offset + _num ] ; } if ( len > _num ) { c = data [ offset + _num ] ; } c1 = ( a > > > _num ) & _num ; c2 = ( ( a << _num ) & _num ) | ( ( b > > > _num ) & _num ) ; c3 = ( ( b << _num ) & _num ) | ( ( c > > > _num ) & _num ) ; c4 = c & _num ; outstream . write ( c1 + _str ) ; outstream . write ( c2 + _str ) ; outstream . write ( c3 + _str ) ; outstream . write ( c4 + _str ) ; return ; }	encodeatom - take three bytes and encodes them into 4 characters if len is less than 3 then remaining bytes are filled with ' 1 '.
public void test_unwrap_bytebuffer_bytebuffer_05 ( ) { string host = _str ; int port = _num ; bytebuffer bbs = bytebuffer . allocate ( _num ) ; bytebuffer bbd = bytebuffer . allocate ( _num ) ; sslengine sse = getengine ( host , port ) ; sse . setuseclientmode ( _bool ) ; try { sslengineresult res = sse . unwrap ( bbs , bbd ) ; assertequals ( _num , res . bytesconsumed ( ) ) ; assertequals ( _num , res . bytesproduced ( ) ) ; } catch ( exception e ) { fail ( _str + e ) ; } }	javax . net . ssl . sslengine # unwrap ( bytebuffer src , bytebuffer dst ).
private int adjustalpha ( int color , float factor ) { int alpha = math . round ( color . alpha ( color ) * factor ) ; int red = color . red ( color ) ; int green = color . green ( color ) ; int blue = color . blue ( color ) ; return color . argb ( alpha , red , green , blue ) ; }	transparent the given color by the factor the more the factor closer to zero the more the color gets transparent.
private void initializeratioslider ( ) { ratioslider . setmajortickspacing ( _num ) ; ratioslider . setminortickspacing ( _num ) ; ratioslider . setpaintticks ( _bool ) ; hashtable < integer , jlabel > labeltable = new hashtable < integer , jlabel > ( ) ; labeltable . put ( new integer ( _num ) , new jlabel ( _str ) ) ; labeltable . put ( new integer ( _num ) , new jlabel ( _str ) ) ; labeltable . put ( new integer ( _num ) , new jlabel ( _str ) ) ; labeltable . put ( new integer ( _num ) , new jlabel ( _str ) ) ; labeltable . put ( new integer ( _num ) , new jlabel ( _str ) ) ; ratioslider . setlabeltable ( labeltable ) ; ratioslider . setpaintlabels ( _bool ) ; }	initializes the values of the gui ratio slider .
private static void initializesettings ( settings . builder output , settings input , boolean loaddefaults ) { output . put ( input ) ; if ( usesystemproperties ( input ) ) { if ( loaddefaults ) { for ( string prefix : property_defaults_prefixes ) { output . putproperties ( prefix , system . getproperties ( ) ) ; } } for ( string prefix : property_prefixes ) { output . putproperties ( prefix , system . getproperties ( ) , property_defaults_prefixes ) ; } } output . replacepropertyplaceholders ( ) ; }	initializes the builder with the given input settings , and loads system properties settings if allowed.
@ override public void drawoval ( int x , int y , int width , int height ) { setstatetolocal ( ) ; m_printstream . println ( xtransform ( xscale ( x ) ) + _str + ytransform ( yscale ( y ) ) + _str + xscale ( width ) + _str + yscale ( height ) + _str ) ; }	draw an oval outline in current pen color .
public string tostring ( int indentfactor ) throws jsonexception { return tostring ( indentfactor , _num ) ; }	make a prettyprinted json text of this jsonobject.
private void validatesqlfields ( ) { boolean flag = controller . isenablesqldatabaseoutput ( ) ; enablesqldatabaseconnection . setselected ( flag ) ; sqlhostlabel . setenabled ( flag ) ; sqlhostfield . setenabled ( flag ) ; sqldatabaselabel . setenabled ( flag ) ; sqldatabasefield . setenabled ( flag ) ; sqluserlabel . setenabled ( flag ) ; sqluserfield . setenabled ( flag ) ; sqlpasswordlabel . setenabled ( flag ) ; sqlpasswordfield . setenabled ( flag ) ; enablezipencodingcheckbox . setenabled ( flag ) ; }	validates the uncompressed settings .
public void readfromobject ( object object ) { try { method method = beanutils . getreadmethod ( object . getclass ( ) , getname ( ) ) ; if ( method != null ) { object value = method . invoke ( object , null ) ; initializevalue ( value ) ; if ( value != null ) { for ( iterator iter = subproperties . iterator ( ) ; iter . hasnext ( ) ; ) { property subproperty = ( property ) iter . next ( ) ; subproperty . readfromobject ( value ) ; } } } } catch ( exception e ) { throw new runtimeexception ( e ) ; } }	reads the value of this property from the given object.
private boolean internaloffertask ( aframetask task ) { synchronized ( mframetaskqueue ) { return mframetaskqueue . offer ( task ) ; } }	adds a task to the frame task queue .
public static string tostring ( bytebuffer bb ) { byte [ ] bytes = new byte [ bb . getint ( ) ] ; string s = _str ; try { if ( arrayutils . isnotempty ( bytes ) ) { bb . get ( bytes ) ; s = new string ( bytes , utf8 ) ; } } catch ( exception e ) { throw new runtimeexception ( _str + _str , e ) ; } return s ; }	this assumes the next position is the size as an int , and the following is a string if the size is not zero .
public static boolean validimage ( image image ) { return ( image != null && image . getwidth ( null ) > _num && image . getheight ( null ) > _num ) ; }	convenience method for testing the validity of an image .
private imagesize computesizetofit ( float maxside ) { if ( _num == maxside ) { return new imagesize ( _num , _num ) ; } imagesize resized = new imagesize ( this ) ; if ( ( this . mwidth > maxside ) || ( this . mheight > maxside ) ) { double ratiox = maxside / this . mwidth ; double ratioy = maxside / this . mheight ; double scale = math . min ( ratiox , ratioy ) ; scale = _num / integer . highestonebit ( ( int ) math . floor ( _num / scale ) ) ; resized . mwidth = ( int ) ( math . floor ( resized . mwidth * scale / _num ) * _num ) ; resized . mheight = ( int ) ( math . floor ( resized . mheight * scale / _num ) * _num ) ; } return resized ; }	compute the image size to fit in a square .
public static list < biginteger > embeddedselectortopartitions ( string selector , string type , datapartitioner partitioner ) throws pirexception { list < biginteger > parts ; int partitionbits = partitioner . getbits ( type ) ; if ( partitionbits > _num ) { int hashedselector = keyedhash . hash ( _str , _num , selector , _str ) ; parts = partitioner . topartitions ( hashedselector , primitivetypepartitioner . int ) ; } else { parts = partitioner . topartitions ( selector , type ) ; } return parts ; }	method to convert the given selector into the extracted biginteger partitions.
public static double stddevp ( double [ ] a , int lo , int hi ) { return math . sqrt ( varp ( a , lo , hi ) ) ; }	returns the population standard deviation in the specified subarray .
public void maybelookaheadscripts ( ) { }	housekeeping call to call when lookahead might be needed.
public java2typescripttranslator ( transpilationhandler loghandler , jsweetcontext context , jccompilationunit compilationunit , boolean preservesourcelinenumbers ) { super ( loghandler , context , compilationunit , new java2typescriptadapter ( context ) , preservesourcelinenumbers ) ; }	creates a new typescript translator .
@ override protected void onmeasure ( int widthmeasurespec , int heightmeasurespec ) { int count = getchildcount ( ) ; mleftwidth = _num ; mrightwidth = _num ; int maxheight = _num ; int maxwidth = _num ; int childstate = _num ; for ( int i = _num ; i < count ; i ++ ) { final view child = getchildat ( i ) ; if ( child . getvisibility ( ) != gone ) { measurechildwithmargins ( child , widthmeasurespec , _num , heightmeasurespec , _num ) ; final layoutparams lp = ( layoutparams ) child . getlayoutparams ( ) ; if ( lp . position == layoutparams . position_left ) { mleftwidth += math . max ( maxwidth , child . getmeasuredwidth ( ) + lp . leftmargin + lp . rightmargin ) ; } else if ( lp . position == layoutparams . position_right ) { mrightwidth += math . max ( maxwidth , child . getmeasuredwidth ( ) + lp . leftmargin + lp . rightmargin ) ; } else { maxwidth = math . max ( maxwidth , child . getmeasuredwidth ( ) + lp . leftmargin + lp . rightmargin ) ; } maxheight = math . max ( maxheight , child . getmeasuredheight ( ) + lp . topmargin + lp . bottommargin ) ; childstate = combinemeasuredstates ( childstate , child . getmeasuredstate ( ) ) ; } } maxwidth += mleftwidth + mrightwidth ; maxheight = math . max ( maxheight , getsuggestedminimumheight ( ) ) ; maxwidth = math . max ( maxwidth , getsuggestedminimumwidth ( ) ) ; setmeasureddimension ( resolvesizeandstate ( maxwidth , widthmeasurespec , childstate ) , resolvesizeandstate ( maxheight , heightmeasurespec , childstate << measured_height_state_shift ) ) ; }	ask all children to measure themselves and compute the measurement of this layout based on the children .
protected int exec ( string command , stringlist args ) { try { print ( command ) ; stringlist cmd = new stringlist ( ) ; cmd = cmd . plus ( command ) ; if ( args != null ) { for ( string a : args ) { print ( _str + a ) ; } cmd . addall ( args ) ; } println ( _str ) ; processbuilder pb = new processbuilder ( ) ; pb . command ( cmd . array ( ) ) ; pb . redirecterrorstream ( _bool ) ; process p = pb . start ( ) ; copyinthread ( p . getinputstream ( ) , quiet ? null : sysout ) ; p . waitfor ( ) ; return p . exitvalue ( ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } }	execute a program in a separate process .
@ ignore @ test public void testgatewaysendereventlistenerinvocationwithoutlocator ( ) { int mport = availableporthelper . getrandomavailableportfordunitsite ( ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; vm6 . invoke ( null ) ; vm7 . invoke ( null ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; startsenderinvms ( _str , vm4 , vm5 ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; vm6 . invoke ( null ) ; vm7 . invoke ( null ) ; final map keyvalues = new hashmap ( ) ; for ( int i = _num ; i < _num ; i ++ ) { keyvalues . put ( i , i ) ; } vm4 . invoke ( null ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; fail ( _str ) ; }	test validates whether the listener attached receives all the events.
protected applicationuser builduser ( map < string , string > headermap , boolean includeroles ) { logger . debug ( _str ) ; map < string , string > headernames = getheadernames ( ) ; applicationuser applicationuser = createnewapplicationuser ( ) ; builduserid ( applicationuser , headermap , headernames . get ( http_header_user_id ) ) ; buildfirstname ( applicationuser , headermap , headernames . get ( http_header_first_name ) ) ; buildlastname ( applicationuser , headermap , headernames . get ( http_header_last_name ) ) ; buildemail ( applicationuser , headermap , headernames . get ( http_header_email ) ) ; buildsessionid ( applicationuser , headermap , http_header_session_id ) ; buildsessioninittime ( applicationuser , headermap , headernames . get ( http_header_session_init_time ) ) ; usernamespaceauthorizationhelper . buildnamespaceauthorizations ( applicationuser ) ; if ( includeroles ) { buildroles ( applicationuser , headermap , headernames . get ( http_header_roles ) ) ; } logger . debug ( _str + applicationuser ) ; return applicationuser ; }	builds the application user from the header map .
@ interruptible public static void harnessend ( ) { stats . stopall ( ) ; insideharness = _bool ; }	generic hook to allow benchmarks to be harnessed.
public racegui ( string appname ) { uimanager . put ( _str , boolean . false ) ; jframe f = new jframe ( appname ) ; f . setdefaultcloseoperation ( jframe . exit_on_close ) ; f . setlayout ( new borderlayout ( ) ) ; track = new trackview ( ) ; f . add ( track , borderlayout . center ) ; controlpanel = new racecontrolpanel ( ) ; f . add ( controlpanel , borderlayout . south ) ; f . pack ( ) ; f . setvisible ( _bool ) ; }	creates a new instance of racegui.
public static iterable < string > tohexstrings ( iterable < bytearray > arrays ) { arraylist < string > ret = new arraylist < string > ( ) ; for ( bytearray array : arrays ) ret . add ( hexstring . tohexstring ( array . get ( ) ) ) ; return ret ; }	translate the each bytearray in an iterable into a hexidecimal string.
public void clear ( ) { documents . clear ( ) ; firemrulistchanged ( ) ; }	clears the list of documents mru.
public boolean isdirectlycontroldependenton ( basicblock insblock , branch b ) { set < controlflowedge > incomming = incomingedgesof ( insblock ) ; if ( incomming . size ( ) == _num ) { for ( controlflowedge e : incomming ) { if ( ! e . hascontroldependency ( ) && ! e . isexceptionedge ( ) ) { return isdirectlycontroldependenton ( getedgesource ( e ) , b ) ; } } } boolean isrootdependent = isrootdependent ( insblock ) ; if ( b == null ) return isrootdependent ; if ( isrootdependent && b != null ) return _bool ; for ( controlflowedge e : incomming ) { branch current = e . getbranchinstruction ( ) ; if ( e . isexceptionedge ( ) ) { if ( current != null ) throw new illegalstateexception ( _str ) ; else continue ; } if ( current == null ) continue ; if ( current . equals ( b ) ) return _bool ; } return _bool ; }	determines whether the given basicblock is directly control dependent on the given branch.
final boolean tryreadlock ( ) { thread current = thread . currentthread ( ) ; for ( ; ; ) { int c = getstate ( ) ; if ( exclusivecount ( c ) != _num && getexclusiveownerthread ( ) != current ) return _bool ; int r = sharedcount ( c ) ; if ( r == max_count ) throw new error ( _str ) ; if ( compareandsetstate ( c , c + shared_unit ) ) { if ( r == _num ) { firstreader = current ; firstreaderholdcount = _num ; } else if ( firstreader == current ) { firstreaderholdcount ++ ; } else { holdcounter rh = cachedholdcounter ; if ( rh == null || rh . tid != current . getid ( ) ) cachedholdcounter = rh = readholds . get ( ) ; else if ( rh . count == _num ) readholds . set ( rh ) ; rh . count ++ ; } return _bool ; } } }	performs trylock for read , enabling barging in both modes.
public void serializeformdef ( formdef fd , string filepath ) { string hash = fileutils . getmd5hash ( new file ( filepath ) ) ; file formdef = new file ( collect . cache_path + file . separator + hash + _str ) ; if ( ! formdef . exists ( ) ) { fileoutputstream fos ; try { fos = new fileoutputstream ( formdef ) ; dataoutputstream dos = new dataoutputstream ( fos ) ; fd . writeexternal ( dos ) ; dos . flush ( ) ; dos . close ( ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } }	write the formdef to the file system as a binary blog .
private void paintroute ( graphics2d graphics , jxmapviewer viewer , plottableentity entity ) { set < plottable > plottables = entity . getplottables ( ) ; if ( plottables . size ( ) > _num ) { graphics . setcolor ( color . black ) ; graphics . setstroke ( new basicstroke ( _num ) ) ; drawroute ( plottables , graphics , viewer ) ; graphics . setcolor ( entity . getcolor ( ) ) ; graphics . setstroke ( new basicstroke ( _num ) ) ; drawroute ( plottables , graphics , viewer ) ; } }	paints a two - tone route from the entity ' s list of plottables ( locations ).
private boolean installreply ( string alias , inputstream in ) throws exception { if ( alias == null ) { alias = keyalias ; } pair < key , char [ ] > objs = recoverkey ( alias , storepass , keypass ) ; privatekey privkey = ( privatekey ) objs . fst ; if ( keypass == null ) { keypass = objs . snd ; } certificate usercert = keystore . getcertificate ( alias ) ; if ( usercert == null ) { messageformat form = new messageformat ( rb . getstring ( _str ) ) ; object [ ] source = { alias } ; throw new exception ( form . format ( source ) ) ; } collection < ? extends certificate > c = cf . generatecertificates ( in ) ; if ( c . isempty ( ) ) { throw new exception ( rb . getstring ( _str ) ) ; } certificate [ ] replycerts = c . toarray ( new certificate [ c . size ( ) ] ) ; certificate [ ] newchain ; if ( replycerts . length == _num ) { newchain = establishcertchain ( usercert , replycerts [ _num ] ) ; } else { newchain = validatereply ( alias , usercert , replycerts ) ; } if ( newchain != null ) { keystore . setkeyentry ( alias , privkey , ( keypass != null ) ? keypass : storepass , newchain ) ; return _bool ; } else { return _bool ; } }	processes a certificate reply from a certificate authority.
@ override public boolean eisset ( int featureid ) { switch ( featureid ) { case eippackage . aggregator__name : return name_edefault == null ? name != null : ! name_edefault . equals ( name ) ; case eippackage . aggregator__to_channels : return tochannels != null && ! tochannels . isempty ( ) ; case eippackage . aggregator__from_channels : return fromchannels != null && ! fromchannels . isempty ( ) ; case eippackage . aggregator__part : return part != part_edefault ; case eippackage . aggregator__strategy : return strategy_edefault == null ? strategy != null : ! strategy_edefault . equals ( strategy ) ; case eippackage . aggregator__expression : return expression_edefault == null ? expression != null : ! expression_edefault . equals ( expression ) ; } return super . eisset ( featureid ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
public synchronized void mousewheel ( int wheelamt ) { peer . mousewheel ( wheelamt ) ; afterevent ( ) ; }	rotates the scroll wheel on wheel - equipped mice .
@ override public int length ( ) { return data . length / ( format . getframesize ( ) * _num ) ; }	returns the duration of the audio data ( in milliseconds ).
public static void deletedirectory ( final file dir , boolean checkforlinks ) { if ( dir . isfile ( ) ) { throw new illegalargumentexception ( _str + dir . getname ( ) + _str ) ; } else if ( checkforlinks && islink ( dir ) ) { throw new illegalargumentexception ( _str + dir . getname ( ) + _str ) ; } if ( dir . exists ( ) ) { ioutils . deletedir ( dir , checkforlinks ) ; } else { throw new illegalargumentexception ( _str + dir . getname ( ) + _str ) ; } }	this method recursively deletes the directory and all its contents.
private static marshaller createmarshaller ( jaxbcontext jaxbcontext , string schemapath ) throws saxexception , jaxbexception { schema schema = xmlparser . getschema ( new string [ ] { schemapath } ) ; marshaller jaxbmarshaller = jaxbcontext . createmarshaller ( ) ; jaxbmarshaller . setschema ( schema ) ; jaxbmarshaller . setproperty ( marshaller . jaxb_formatted_output , _bool ) ; jaxbmarshaller . setproperty ( marshaller . jaxb_encoding , _str ) ; return jaxbmarshaller ; }	create marshaller based on schema for itunes specific metadata format .
public static generalpath cardinalspline ( float pts [ ] , float slack , boolean closed ) { generalpath path = new generalpath ( ) ; path . moveto ( pts [ _num ] , pts [ _num ] ) ; return cardinalspline ( path , pts , slack , closed , _num , _num ) ; }	compute a cardinal spline , a series of cubic bezier splines smoothly connecting a set of points.
public static string makemethodsafe ( final string s ) { string name = makehtmlnamesafe ( s ) ; name = name . replace ( _str , _str ) ; return name ; }	replaces illegal characters that aren ' t allowed in code.
public builder addlistenurl ( string url ) { if ( urlutil . isurl ( url ) ) { if ( mlistenurls == null ) { mlistenurls = new hashset < string > ( ) ; } mlistenurls . add ( url ) ; } return this ; }	add the url for listening.
public void remove ( production production ) { productions . remove ( production ) ; }	removes a production from this rule .
private void writedelay ( ) { try { thread . sleep ( _num ) ; } catch ( interruptedexception e ) { fail ( _str ) ; } }	a very slight delay to ensure that successive groups of queries in the db cannot have the same timestamp .
public static void main ( string [ ] argv ) { argparser ap = new argparser ( _str ) ; ap . add ( _str , _str , _num ) ; if ( argv . length < _num ) { ap . bail ( _str , _bool ) ; } ap . parse ( argv ) ; string [ ] files = ap . getargvalues ( _str ) ; if ( files != null && files [ _num ] != null ) { string shp = files [ _num ] ; string dbf = null ; try { dbf = shp . substring ( _num , shp . lastindexof ( _str ) + _num ) + param_dbf ; dbftablemodel model = dbftablemodel . getdbftablemodel ( proputils . getresourceorfileorurl ( dbf ) ) ; esrigraphiclist list = esrigraphiclist . getesrigraphiclist ( proputils . getresourceorfileorurl ( shp ) , null , null ) ; logger . info ( list . getdescription ( ) ) ; esrishapeexport ese = new esrishapeexport ( list , model , null ) ; ese . export ( ) ; } catch ( malformedurlexception murle ) { logger . warning ( _str + murle . getmessage ( ) ) ; } catch ( nullpointerexception npe ) { logger . warning ( _str ) ; } catch ( exception exception ) { logger . warning ( _str + exception . getmessage ( ) ) ; exception . printstacktrace ( ) ; } } else { ap . bail ( _str , _bool ) ; } system . exit ( _num ) ; }	the main function is a test , reads in a shape file ( with the.
public void testmaxgreater ( ) { byte abytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , - _num , _num , _num , _num , _num } ; int asign = _num ; int bsign = _num ; byte rbytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . max ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } asserttrue ( _str , result . signum ( ) == _num ) ; }	max ( biginteger val ).
public static sortedset < interval > findfullavailabilitygaps ( set < interval > availableintervals , set < interval > neededintervals ) { comparator < interval > intervalstartcomparator = new intervalstartcomparator ( ) ; sortedset < interval > sortedavailableintervals = new treeset < > ( intervalstartcomparator ) ; sortedavailableintervals . addall ( availableintervals ) ; sortedset < interval > sortedneededintervals = new treeset < > ( intervalstartcomparator ) ; sortedneededintervals . addall ( neededintervals ) ; iterator < interval > availableintervalsiterator = sortedavailableintervals . iterator ( ) ; if ( ! availableintervalsiterator . hasnext ( ) ) { return sortedneededintervals ; } interval available = availableintervalsiterator . next ( ) ; sortedset < interval > missingintervals = new treeset < > ( intervalstartcomparator ) ; for ( interval needed : sortedneededintervals ) { while ( ! candetermineavailability ( available , needed ) && availableintervalsiterator . hasnext ( ) ) { available = availableintervalsiterator . next ( ) ; } if ( available . contains ( needed ) ) { continue ; } missingintervals . add ( needed ) ; } return missingintervals ; }	finds the gaps in available vs needed interval sets .
public static list < string > split ( string str , string delim ) { list < string > splitlist = null ; stringtokenizer st = null ; if ( str == null ) return splitlist ; if ( delim != null ) st = new stringtokenizer ( str , delim ) ; else st = new stringtokenizer ( str ) ; if ( st != null && st . hasmoretokens ( ) ) { splitlist = new linkedlist < string > ( ) ; while ( st . hasmoretokens ( ) ) splitlist . add ( st . nexttoken ( ) ) ; } return splitlist ; }	splits a string on a delimiter into a list of strings .
public void writeexif ( string jpegfilename , string exifoutfilename ) throws filenotfoundexception , ioexception { if ( jpegfilename == null || exifoutfilename == null ) { throw new illegalargumentexception ( null_argument_string ) ; } inputstream is = null ; is = new fileinputstream ( jpegfilename ) ; writeexif ( is , exifoutfilename ) ; is . close ( ) ; }	writes the tags from this exifinterface object into a jpeg file , removing prior exif tags .
public boolean isgenclass ( sootclass clz ) { return genclasses . contains ( clz . getname ( ) ) ; }	return true if this class is defined in gen / directory of android application .
public boolean hasextrastillimage ( ) { return isapng ( ) && ! firsidatapngframe ; }	true if it has a default image ( idat ) that is not part of the animation . in that case , we consider it as a pseudo - frame ( number - 1 ).
public void removechangelistener ( final ptpropertychangelistener listener ) { changelisteners . remove ( listener ) ; }	remove a change listener.
public static resultset optimizeinjoinselect ( ) { simpleresultset rs = new simpleresultset ( ) ; rs . addcolumn ( _str , types . integer , _num , _num ) ; rs . addrow ( _num ) ; return rs ; }	this method is called via reflection from the database .
public partitionsubstitutionmodel parsepaupblock ( beautioptions options , list < charset > charsets ) throws importexception , ioexception { partitionsubstitutionmodel model = new partitionsubstitutionmodel ( options , _str ) ; readtoplevelblock ( options , model , charsets ) ; return model ; }	parses a ' paup ' block .
private void zeventtoggletimemenubuttonmousepressed ( mouseevent e ) { togglepopup ( ) ; }	zeventtoggletimemenubuttonmousepressed , this is called when the user clicks on the " toggle time menu " button of the time picker.
private void addline ( gridfield field , veditor editor , boolean mandatory ) { log . fine ( _str + field ) ; jlabel label = veditorfactory . getlabel ( field ) ; label . setlabelfor ( ( component ) editor ) ; editor . setreadwrite ( _bool ) ; editor . setmandatory ( mandatory ) ; field . addpropertychangelistener ( editor ) ; if ( m_newrow ) { m_gbc . gridy = m_line ++ ; m_gbc . gridx = _num ; } else m_gbc . gridx = _num ; m_gbc . insets = m_labelinsets ; m_gbc . fill = gridbagconstraints . horizontal ; m_gbc . weightx = _num ; parameterpanel . add ( label , m_gbc ) ; if ( m_newrow ) m_gbc . gridx = _num ; else m_gbc . gridx = _num ; m_gbc . insets = m_fieldinsets ; m_gbc . fill = gridbagconstraints . horizontal ; m_gbc . weightx = _num ; parameterpanel . add ( ( component ) editor , m_gbc ) ; m_newrow = ! m_newrow ; }	add editor to parameterpanel alternative right / left depending on m_newrow . field value changes update editors.
protected object lazilyloaddesktopproperty ( string name ) { return null ; }	an opportunity to lazily evaluate desktop property values .
@ edu . umd . cs . findbugs . annotations . suppresswarnings ( value = _str , justification = _str ) public void initrecoveredversion ( t member , regionversionholder < t > v , boolean latestoplog ) { regionversionholder < t > recovered = v . clone ( ) ; if ( member == null || member . equals ( myid ) ) { synchronized ( localexceptions ) { if ( latestoplog || localversion . get ( ) == _num ) { localexceptions = recovered ; if ( logger . istraceenabled ( logmarker . rvv ) ) { logger . trace ( logmarker . rvv , _str , recovered . version ) ; } localversion . set ( recovered . version ) ; } } } else { long gcversion = membertogcversion . get ( member ) ; synchronized ( membertoversion ) { regionversionholder < t > oldversion = membertoversion . get ( member ) ; if ( latestoplog || oldversion == null || oldversion . version == _num ) { if ( gcversion != null ) { recovered . removeexceptionsolderthan ( gcversion ) ; } membertoversion . put ( member , recovered ) ; } } } }	records a version holder that we have recovered from disk.
protected void notifyclicklistenersaboutclick ( int item ) { if ( clickinglisteners . size ( ) > _num ) { for ( onwheelclickedlistener listener : clickinglisteners ) { listener . onitemclicked ( this , item ) ; } } else { setcurrentitem ( item , _bool , _num ) ; } }	notifies listeners about clicking.
@ override public synchronized void disconnectionnotification ( string eventname , object source ) { list < object > listenees = m_listenees . get ( eventname ) ; if ( listenees != null ) { listenees . remove ( source ) ; if ( listenees . size ( ) == _num ) { m_listenees . remove ( eventname ) ; } } if ( eventname . compareto ( _str ) == _num ) { stop ( ) ; } }	notify this object that it has been deregistered as a listener with a source with respect to the supplied event name.
public void testconstructorsignbyteszeronull1 ( ) { byte abytes [ ] = { } ; int asign = - _num ; byte rbytes [ ] = { _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = anumber . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , anumber . signum ( ) ) ; }	create a zero number from a sign and an array of zero length.
private string replaceillegalchar ( string data , char ch , string replacement ) { int idx = _num ; stringbuilder buffer = new stringbuilder ( data . length ( ) * _num ) ; while ( ( data != null ) && ( idx = data . indexof ( ch ) ) != - _num ) { buffer . append ( data . substring ( _num , idx ) ) ; buffer . append ( replacement ) ; data = data . substring ( idx + _num ) ; } if ( ( data != null ) && ( data . length ( ) > _num ) ) { buffer . append ( data ) ; } return buffer . tostring ( ) ; }	replacing illegal xml char with entity ref.
protected static final void adjustmodulename ( debugmodule d ) { d . name = adjustmodulename ( d . name ) ; }	royale enhancement request : 53160.
public org . dom4j . attribute createattribute ( element elem , attribute attr ) { return factory . createattribute ( elem , createqname ( attr . getname ( ) ) , attr . getvalue ( ) ) ; }	constructs a new dom4j attribute from the provided stax attribute event .
public logentry ( ) { index = entry_index . getandincrement ( ) ; time = system . currenttimemillis ( ) ; }	constructs the logentry and sets its timestamp to now .
public void testbitlengthpositive3 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = _num ; biginteger anumber = new biginteger ( asign , abytes ) ; assertequals ( _num , anumber . bitlength ( ) ) ; }	bitlength ( ) of a positive number which is a power of 2.
public boolean issignaturevalid ( ) { return eckey . verify ( utils . doubledigest ( content ) , signature , params . getalertsigningkey ( ) ) ; }	returns true if the digital signature attached to the message verifies.
private void validatecreateinformation ( date starttime , string taskname ) { assert . notnull ( starttime , _str ) ; if ( taskname != null && taskname . length ( ) > this . maxtasknamesize ) { throw new illegalargumentexception ( _str + this . maxtasknamesize + _str ) ; } }	validate starttime and taskname are valid .
private static object increment ( final object object , final number amount , final jsonpointer field ) throws badrequestexception { if ( object instanceof long ) { return ( ( long ) object ) + amount . longvalue ( ) ; } else if ( object instanceof integer ) { return ( ( integer ) object ) + amount . intvalue ( ) ; } else if ( object instanceof float ) { return ( ( float ) object ) + amount . floatvalue ( ) ; } else if ( object instanceof double ) { return ( ( double ) object ) + amount . doublevalue ( ) ; } else { throw new badrequestexception ( _str + field + _str ) ; } }	helper function to deal with typecasting and incrementing of object to appropriate number object ) .
public static linkedhashset < entity > findentites ( linkedhashset < entity > matches , hashset < entity > checked , entity entity , predicate predicate ) { if ( ! checked . add ( entity ) ) { return matches ; } if ( predicate . matches ( entity ) ) { matches . add ( entity ) ; } for ( refnode refnode : entity . getchildren ( refnode . class ) ) { entity e = refnode . getreference ( ) ; if ( e != null ) { findentites ( matches , checked , e , predicate ) ; } } for ( tomanynode tomanynode : entity . getchildren ( tomanynode . class ) ) { for ( entity e : tomanynode . getlist ( ) ) { if ( e != null ) { findentites ( matches , checked , e , predicate ) ; } } } return matches ; }	finds all entities by navigating the object graph from entity which match the given predicate . < br / >.
public string toxmlstring ( ) throws xacmlexception { return toxmlstring ( _bool , _bool ) ; }	returns a string representation.
public void addmemorypressurelistener ( memorypressurelistener listener ) { mlisteners . add ( listener ) ; }	add a listener to be notified of memory pressure events .
private void resetforot ( ) { if ( bottomot && homescore == awayscore ) { gameyardline = _num ; gameyardsneed = _num ; gamedown = _num ; numot ++ ; if ( ( numot % _num ) == _num ) gameposs = _bool ; else gameposs = _bool ; gametime = - _num ; bottomot = _bool ; } else if ( ! bottomot ) { gameposs = ! gameposs ; gameyardline = _num ; gameyardsneed = _num ; gamedown = _num ; gametime = - _num ; bottomot = _bool ; } else { playingot = _bool ; } }	give ball to correct team and reset yard line / down for new team.
public synchronized void startpolling ( ) { m_scheduler . scheduleatfixedrate ( m_notificationpoller , _num , _num , timeunit . milliseconds ) ; }	activates the scheduler and queues the notification poller .
private void dropproxy ( proxyreg reg ) { synchronized ( caches ) { iterator iter = caches . iterator ( ) ; while ( iter . hasnext ( ) ) { lookupcacheimpl cache = ( lookupcacheimpl ) iter . next ( ) ; cache . removeproxyreg ( reg ) ; } } }	removes the given proxy from all the caches maintained by the sdm .
public void testupdate4 ( ) { int newvalue1 = - _num ; int newvalue2 = - _num ; string updatequery = _str + databasecreator . test_table1 + _str + newvalue1 + _str + newvalue2 + _str ; try { int num = statement . executeupdate ( updatequery ) ; int expectedupdated = _num ; assertequals ( _str , expectedupdated , num ) ; string selectquery = _str + databasecreator . test_table1 ; resultset result = statement . executequery ( selectquery ) ; while ( result . next ( ) ) { int id = result . getint ( _str ) ; } result . close ( ) ; } catch ( sqlexception e ) { fail ( _str + e . getmessage ( ) ) ; } }	updatefunctionalitytest # testupdate4 ( ) . updates values in a several columns in the table using where condition in update command.
public long tolong ( ) { return m_value . longvalue ( ) ; }	returns the long value of the address .
public static int copyandcloseboth ( reader input , writer output ) throws ioexception { try { return copyandcloseoutput ( input , output ) ; } finally { input . close ( ) ; } }	copy input to output and close both the input and output streams before returning.
protected void writeheader ( ) throws ioexception { header = new byte [ shape_file_header_length ] ; writebeint ( header , _num , shape_file_code ) ; writebeint ( header , _num , _num ) ; writeleint ( header , _num , shape_file_version ) ; writeleint ( header , _num , shape_type_null ) ; writeledouble ( header , _num , _num ) ; writeledouble ( header , _num , _num ) ; writeledouble ( header , _num , _num ) ; writeledouble ( header , _num , _num ) ; raf . seek ( _num ) ; raf . write ( header , _num , shape_file_header_length ) ; }	writes a blank header into the shape file .
public string hashkeyfordisk ( string key ) { string cachekey ; try { final messagedigest mdigest = messagedigest . getinstance ( _str ) ; mdigest . update ( key . getbytes ( ) ) ; cachekey = bytestohexstring ( mdigest . digest ( ) ) ; } catch ( nosuchalgorithmexception e ) { cachekey = string . valueof ( key . hashcode ( ) ) ; } return cachekey ; }	using the md5 algorithm to encrypt the key of the incoming and return .
public static void unregister ( spinthreadfunctions old ) { if ( old != null ) { localfunctions . set ( old ) ; } else { localfunctions . remove ( ) ; } }	unregisters the current model for the current thread .
public static boolean loadproperties ( properties properties , inputstream propsin ) { try { properties . load ( propsin ) ; return _bool ; } catch ( java . io . ioexception e ) { if ( logger . isloggable ( level . fine ) ) { logger . warning ( _str ) ; } return _bool ; } }	loads properties from a java resource.
public complex sin ( ) { return new complex ( math . sin ( re ) * math . cosh ( im ) , math . cos ( re ) * math . sinh ( im ) ) ; }	returns the complex sine of this complex number .
@ onclick ( r . id . dismiss_button ) public void ondismissclick ( view view ) { if ( systemclock . elapsedrealtime ( ) - mlastclicktime < _num ) { return ; } mlastclicktime = systemclock . elapsedrealtime ( ) ; dismissoffer ( getadapterposition ( ) ) ; if ( snackbar != null ) { snackbar . dismiss ( ) ; } }	dismiss tapped offer and remove from offers list.
public table findtable ( string name ) { return findtable ( name , _bool ) ; }	finds the table with the specified name , using case insensitive matching.
public static void appendstring ( final stringbuffer buf , final string s ) { buf . append ( _str ) ; for ( int i = _num ; i < s . length ( ) ; ++ i ) { char c = s . charat ( i ) ; if ( c == _str ) { buf . append ( _str ) ; } else if ( c == _str ) { buf . append ( _str ) ; } else if ( c == _str ) { buf . append ( _str ) ; } else if ( c == _str ) { buf . append ( _str ) ; } else if ( c < _num || c > _num ) { buf . append ( _str ) ; if ( c < _num ) { buf . append ( _str ) ; } else if ( c < _num ) { buf . append ( _str ) ; } else if ( c < _num ) { buf . append ( _str ) ; } buf . append ( integer . tostring ( c , _num ) ) ; } else { buf . append ( c ) ; } } buf . append ( _str ) ; }	appends a quoted string to a given buffer .
public void draw ( final graphics g , final int height , final int width ) { int constantdim ; int changingdim ; if ( orientation == x_axis ) { changingdim = width ; constantdim = height ; } else { changingdim = height ; constantdim = width ; } int dimstep ; if ( fixedsteps ) { dimstep = changingdim / steps ; } else { dimstep = _num ; steps = changingdim / dimstep ; } float red = _redt ; float green = _greent ; float blue = _bluet ; int offset = _num ; for ( int i = _num ; i < steps ; i ++ ) { color c = new color ( round ( red ) , round ( green ) , round ( blue ) ) ; g . setcolor ( c ) ; drawrect ( g , offset , constantdim , dimstep ) ; offset += dimstep ; float value = shader . getvalue ( ( float ) i / ( float ) steps ) ; red = _redt + ( _redb - _redt ) * value ; green = _greent + ( _greenb - _greent ) * value ; blue = _bluet + ( _blueb - _bluet ) * value ; } color c = new color ( round ( red ) , round ( green ) , round ( blue ) ) ; g . setcolor ( c ) ; drawrect ( g , offset , constantdim , changingdim - offset ) ; }	draws the requested fade to g , with the given width and height .
private void sendmessages ( ) { list < murmurmessage > messages = getmessages ( _num ) ; murmurmessage exchangeinfomessage = new murmurmessage ( _str , integer . tostring ( messages . size ( ) ) , _num ) ; if ( lengthvaluewrite ( out , exchangeinfomessage . tojson ( murmurapplication . getcontext ( ) , _num , _num ) ) ) { for ( murmurmessage message : messages ) { list < murmurmessage > packet = new arraylist < > ( ) ; packet . add ( message ) ; cleartextmessages messagesmessage = new cleartextmessages ( ( arraylist < murmurmessage > ) packet ) ; lengthvaluewrite ( out , messagesmessage . tojson ( murmurapplication . getcontext ( ) ) ) ; } } }	get messages from the messagestore , encode them as a cleartextmessages protobuf object , and write that message out to the output stream .
protected void init ( string str ) { int len = str . length ( ) ; text = new char [ len ] ; lctext = new char [ len ] ; for ( int i = _num ; i < len ; i ++ ) { char c = str . charat ( i ) ; text [ i ] = c ; if ( c == _str || c == _str || c == _str ) { lctext [ i ] = _str ; } else lctext [ i ] = ( ( c >= _str && c <= _str ) || ( c >= _str && c <= _str ) ) ? c : character . tolowercase ( c ) ; } }	gemeinsame initialmethode der drei konstruktoren , diese erhaelt den cfml code als char [ ] und uebertraegt ihn , in die interen datenhaltung .
private void updateattrs ( svcreg reg , entryrep entry , object [ ] values ) { entryclass eclass = entry . eclass ; for ( int fldidx = values . length ; -- fldidx >= _num ; ) { object oval = entry . fields [ fldidx ] ; object nval = values [ fldidx ] ; if ( nval != null && ! nval . equals ( oval ) ) { eclass = getdefiningclass ( eclass , fldidx ) ; hashmap map = addattr ( reg , eclass , fldidx , nval ) ; entry . fields [ fldidx ] = nval ; if ( hasattr ( reg , eclass , fldidx , oval ) ) continue ; arraylist regs = ( arraylist ) map . get ( oval ) ; regs . remove ( regs . indexof ( reg ) ) ; if ( regs . isempty ( ) ) map . remove ( oval ) ; } } }	store all non - null elements of values into the given entry , and update servicebyattr to match .
public void finalizenetworkconstruction ( ) { set < motiflink > keyset = nodesetsdepartingfromlink . keyset ( ) ; nodeswithlink = new hashmap < motiflink , arraylist < node > > ( keyset . size ( ) ) ; for ( motiflink motiflink : keyset ) { set < node > nodes = nodesetsdepartingfromlink . get ( motiflink ) ; arraylist < node > n = new arraylist < node > ( nodes ) ; collections . sort ( n ) ; nodeswithlink . put ( motiflink , n ) ; } nodesetsdepartingfromlink = null ; }	optimises network structure for further processing.
public collection < aisvalidationfailure > failures ( ) { return collections . unmodifiablecollection ( failurelist ) ; }	gets all failures , if there were any.
public static getinactiveimagesresponse checkgetinactiveimagesresponse ( getinactiveimagesresponse response ) throws rpcexception { logger . info ( _str , response ) ; switch ( response . getresult ( ) ) { case ok : break ; case system_error : throw new systemerrorexception ( response . geterror ( ) ) ; case datastore_not_found : throw new datastorenotfoundexception ( response . geterror ( ) ) ; case operation_in_progress : throw new operationinprogressexception ( response . geterror ( ) ) ; default : throw new rpcexception ( string . format ( _str , response . getresult ( ) ) ) ; } return response ; }	validates a getinactiveimagesresponse object , raising an exception if the response code is not ' ok ' .
public void runtest ( ) throws throwable { document doc ; element root ; nodelist elementlist ; node firstchild ; nodelist textlist ; characterdata textnode ; string data ; doc = ( document ) load ( _str , _bool ) ; root = doc . getdocumentelement ( ) ; root . normalize ( ) ; elementlist = root . getelementsbytagname ( _str ) ; firstchild = elementlist . item ( _num ) ; textlist = firstchild . getchildnodes ( ) ; textnode = ( characterdata ) textlist . item ( _num ) ; data = textnode . getdata ( ) ; assertequals ( _str , _str , data ) ; }	runs the test case .
public double semideviation ( ) { return math . sqrt ( semivariance ( ) ) ; }	returns the semi deviation , defined as the square root of the semi variance .
private void checkpostsdisplayonrecyclerview ( list < post > poststocheck , int position ) { int columncount = _num ; int size = poststocheck . size ( ) + position ; int pos = _num ; for ( int i = position ; i < size ; i ++ ) { checkitematposition ( i , poststocheck . get ( pos ) ) ; if ( ( ( i + _num ) % columncount ) == _num ) { int nextrowstart = i + columncount ; int nextrowend = nextrowstart - columncount + _num ; for ( int n = nextrowstart ; n >= nextrowend ; n -- ) { checkitematposition ( n , poststocheck . get ( n - position ) ) ; } i = i + columncount ; } pos ++ ; } }	this method checks that the given list of posts display within the verticalgridview.
private void adddependentclassestoworklist ( gvcongruenceclass c ) { for ( valuegraphvertex v : c ) { for ( enumeration < graphnode > e = v . innodes ( ) ; e . hasmoreelements ( ) ; ) { valuegraphvertex in = ( valuegraphvertex ) e . nextelement ( ) ; int vn = in . getvaluenumber ( ) ; gvcongruenceclass x = b . get ( vn ) ; worklist . push ( x ) ; } } }	assuming congruence class c has changed : find all other classes that might be affected , and add them to the worklist.
public synchronized jsonobject tojsonobject ( ) { jsonobject res = new jsonobject ( ) ; res . putall ( this ) ; return res ; }	return a copy of the json content.
private shape createellipseinternal ( int x , int y , int w , int h ) { ellipse . setframe ( x , y , w , h ) ; return ellipse ; }	return a path for an ellipse .
public static string write ( stringbuilder sb , string ... strings ) { for ( string string : strings ) sb . append ( string ) ; return sb . tostring ( ) ; }	semplifies the concatenation of strings.
public importfoldervalidation validate ( final string path ) { check . notnull ( path , _str ) ; if ( validationcache == null ) { validationcache = new hashmap ( ) ; } else { if ( validationcache . containskey ( path ) ) { return ( importfoldervalidation ) validationcache . get ( path ) ; } } final importfoldervalidation validation = computevalidation ( path ) ; validationcache . put ( path , validation ) ; return validation ; }	validate a potential path for import.
private static byte [ ] hmac_sha ( string crypto , byte [ ] keybytes , byte [ ] text ) { try { mac hmac ; hmac = mac . getinstance ( crypto ) ; secretkeyspec mackey = new secretkeyspec ( keybytes , _str ) ; hmac . init ( mackey ) ; return hmac . dofinal ( text ) ; } catch ( generalsecurityexception gse ) { throw new undeclaredthrowableexception ( gse ) ; } }	this method uses the jce to provide the crypto algorithm.
public static string fetchcgname ( string clustercgname ) { string cgname = null ; if ( clustercgname != null && ! clustercgname . isempty ( ) ) { string [ ] tmp = clustercgname . split ( splitter ) ; cgname = tmp [ _num ] ; } return cgname ; }	parses out the consistency group name from the combined cluster / cg name .
public void test_chooseserveralias ( ) { init ( server ) ; assertnull ( manager . chooseserveralias ( null , null , new socket ( ) ) ) ; assertnull ( manager . chooseserveralias ( _str , null , new socket ( ) ) ) ; string res = manager . chooseserveralias ( type_rsa , null , null ) ; assertnotnull ( res ) ; assertequals ( _str , res . tolowercase ( ) ) ; res = manager . chooseserveralias ( type_rsa , null , new socket ( ) ) ; assertnotnull ( res ) ; assertequals ( _str , res . tolowercase ( ) ) ; }	x509keymanager # chooseserveralias ( string keytype , principal [ ] issuers , socket socket ).
public void add ( int index , entity entity ) { if ( entities . contains ( entity ) ) { throw new illegalstateexception ( _str + entity + _str ) ; } if ( entity . getentitytype ( ) != entitytype ) { throw new illegalstateexception ( _str + entity . getentitytype ( ) + _str + getparent ( ) + _str + getname ( ) ) ; } if ( entity . isclearlynotindatabase ( ) ) { newentities . add ( entity ) ; } entities . add ( index , entity ) ; }	we are adding an entity to this list .
public static controltagcacheobject createtestequipmentalive ( ) { controltagcacheobject cacheobject = new controltagcacheobject ( new long ( _num ) , _str , _str , datatagconstants . mode_test ) ; cacheobject . setdescription ( _str ) ; cacheobject . setlogged ( _bool ) ; cacheobject . setunit ( _str ) ; cacheobject . setdipaddress ( _str ) ; cacheobject . setjapcaddress ( _str ) ; cacheobject . setvalue ( new long ( system . currenttimemillis ( ) ) ) ; cacheobject . setvaluedescription ( _str ) ; cacheobject . setsimulated ( _bool ) ; cacheobject . setminvalue ( long . min_value ) ; cacheobject . setmaxvalue ( long . max_value ) ; cacheobject . setvaluedictionary ( new datatagvaluedictionary ( ) ) ; cacheobject . setaddress ( new datatagaddress ( ) ) ; cacheobject . setdatatagquality ( createvalidquality ( ) ) ; cacheobject . setcachetimestamp ( new timestamp ( system . currenttimemillis ( ) ) ) ; cacheobject . setdaqtimestamp ( new timestamp ( system . currenttimemillis ( ) ) ) ; cacheobject . setsourcetimestamp ( new timestamp ( system . currenttimemillis ( ) ) ) ; return cacheobject ; }	creates a an alivetimer for the equipment .
public distributedlogconfiguration ( ) { super ( ) ; addconfiguration ( new systemconfiguration ( ) ) ; }	construct distributedlog configuration with default settings.
public static double samplestandarddeviation ( int size , double samplevariance ) { double s , cn ; int n = size ; s = math . sqrt ( samplevariance ) ; if ( n > _num ) { cn = _num + _num / ( _num * ( n - _num ) ) ; } else { cn = math . sqrt ( ( n - _num ) * _num ) * gamma . gamma ( ( n - _num ) * _num ) / gamma . gamma ( n * _num ) ; } return cn * s ; }	returns the sample standard deviation.
void normalize ( ) throws ioexception { int end = chars . length ( ) ; if ( end == _num ) { return ; } int pos = _num ; int codepoint = character . codepointat ( chars , _num ) ; boolean escaped = _bool ; for ( int i = _num ; i < end ; ) { int charcount = character . charcount ( codepoint ) ; int i2 = i + charcount ; int nextcodepoint = i2 < end ? character . codepointat ( chars , i2 ) : - _num ; if ( escaped ) { escaped = _bool ; if ( escapeonecodepoint ( pos , i - _num , codepoint , nextcodepoint ) ) { pos = i2 ; } } else if ( codepoint == _str ) { escaped = _bool ; } else if ( escapeonecodepoint ( pos , i , codepoint , nextcodepoint ) ) { pos = i2 ; } i = i2 ; codepoint = nextcodepoint ; } out . append ( chars , pos , end ) ; }	like escape , but treats the input as an already escaped string and only tries to ensure that characters that might or need not be escaped for correctness are consistently escaped .
protected void rebuildlistmodel ( ) { defaultlistmodel dlm = ( defaultlistmodel ) getlistmodel ( ) ; omgraphiclist list = getlist ( ) ; int [ ] selectedindicies = null ; if ( list != null ) { if ( selectedtiles != null && selectedtiles . length > _num ) { selectedindicies = new int [ selectedtiles . length ] ; } int tilecount = _num ; int selectedindex = _num ; if ( selectedindicies != null ) { for ( omgraphic omg : list ) { imagetile imagetile = ( imagetile ) omg ; if ( imagetile . isselected ( ) && selectedindex < selectedindicies . length ) { selectedindicies [ selectedindex ++ ] = tilecount ; } tilecount ++ ; } } dlm . clear ( ) ; for ( omgraphic omg : list ) { tilecount ++ ; dlm . addelement ( omg ) ; } } if ( resultslist != null ) { if ( selectedindicies != null ) { resultslist . setselectedindices ( selectedindicies ) ; } resultslist . repaint ( ) ; } }	rebuild the list model contents based on the imagetiles contained on the omgraphiclist .
public void tick ( ) { tick ( _num ) ; }	advances a step down.
public result send ( email email , boolean ... sync ) { return service . send ( email , booltoint ( _bool , sync ) ) ; }	send email notification , synchronized if sync is absent .
private boolean ispopulating ( ) { return ispopulating ; }	checks if the panel is being populated .
public void processattributes ( java . io . writer writer , int nattrs ) throws ioexception , saxexception { string encoding = getencoding ( ) ; for ( int i = _num ; i < nattrs ; i ++ ) { final string name = m_attributes . getqname ( i ) ; final string value = m_attributes . getvalue ( i ) ; writer . write ( _str ) ; writer . write ( name ) ; writer . write ( _str ) ; writeattrstring ( writer , value , encoding ) ; writer . write ( _str ) ; } }	process the attributes , which means to write out the currently collected attributes to the writer . the attributes are not cleared by this method.
public int processor ( ) { return integer . parseint ( fields [ _num ] ) ; }	( since linux 2.
public void addnativechildat ( reactshadownode child , int nativeindex ) { assertions . assertcondition ( ! mislayoutonly ) ; assertions . assertcondition ( ! child . mislayoutonly ) ; if ( mnativechildren == null ) { mnativechildren = new arraylist < > ( _num ) ; } mnativechildren . add ( nativeindex , child ) ; child . mnativeparent = this ; }	adds a child that the native view hierarchy will have at this index in the native view corresponding to this node .
public boolean containskey ( final object ekey ) { return _elementorder . contains ( ekey ) ; }	checks to see if the element key exists .
private void handleexitmessage ( final component component , final long nativectxt ) { postdroptargetevent ( component , _num , _num , dndconstants . action_none , dndconstants . action_none , null , nativectxt , sundroptargetevent . mouse_exited , sundroptargetcontextpeer . dispatch_sync ) ; }	upcall to handle exit messages.
public void addparameterannotations ( cstmethodref method , annotationslist list ) { if ( parameterannotations == null ) { parameterannotations = new arraylist < parameterannotationstruct > ( ) ; } parameterannotations . add ( new parameterannotationstruct ( method , list ) ) ; }	adds a parameter annotations item to this instance .
public static string unhtmlsinglequotes ( final string str ) { return str . replaceall ( _str , _str ) ; }	replace single quotes html entities with equivalent character .
public void addinputmethodlistener ( inputmethodlistener l ) { m_textarea . addinputmethodlistener ( l ) ; }	add text input method listener.
public void initrawswap ( arraylist < s2cellid > cellids ) { this . cellids = new arraylist < s2cellid > ( cellids ) ; cellids . clear ( ) ; }	like init ( ) , but does not call normalize ( ).
protected void encryptfinal ( ) throws ioexception { inbuffer . flip ( ) ; outbuffer . clear ( ) ; try { cipher . dofinal ( inbuffer , outbuffer ) ; } catch ( shortbufferexception e ) { throw new ioexception ( e ) ; } catch ( illegalblocksizeexception e ) { throw new ioexception ( e ) ; } catch ( badpaddingexception e ) { throw new ioexception ( e ) ; } inbuffer . clear ( ) ; outbuffer . flip ( ) ; while ( outbuffer . hasremaining ( ) ) { output . write ( outbuffer ) ; } }	does final encryption of the last data .
private static boolean spanwilloverlap ( spannable spantext , urlspan [ ] spanlist , int start , int end ) { if ( start == end ) { return _bool ; } for ( urlspan span : spanlist ) { int existingstart = spantext . getspanstart ( span ) ; int existingend = spantext . getspanend ( span ) ; if ( ( start >= existingstart && start < existingend ) || end > existingstart && end <= existingend ) { if ( log . isloggable ( tag , log . verbose ) ) { charsequence seq = spantext . subsequence ( start , end ) ; log . v ( tag , _str + seq + _str ) ; } return _bool ; } } return _bool ; }	determines whether a new span at [ start , end ) will overlap with any existing span .
private hashmap < integer , trie > buildlookuptable ( final map < integer , list < trie > > childtries ) { hashmap < integer , trie > lookup = new hashmap < > ( childtries . size ( ) ) ; for ( int id : childtries . keyset ( ) ) { final list < trie > tries = childtries . get ( id ) ; if ( tries . size ( ) == _num ) { lookup . put ( id , tries . get ( _num ) ) ; } else { lookup . put ( id , new sliceaggregatingtrie ( tries ) ) ; } } return lookup ; }	build a lookup table for children tries.
public void addmarker ( int x , int z , color color ) { mapmarker marker = new mapmarker ( ) ; marker . x = x ; marker . z = z ; marker . color = color ; markers . add ( marker ) ; }	adds a marker to the map .
private void commitdiscard ( long time , boolean allowdiscard ) { if ( mdiscardingtab == null ) return ; assert mstacktabs != null ; stacktab discarded = mdiscardingtab ; if ( math . abs ( discarded . getdiscardamount ( ) ) / getdiscardrange ( ) > discard_commit_threshold && allowdiscard ) { mlayout . uirequestingclosetab ( time , discarded . getid ( ) ) ; recorduseraction . record ( _str ) ; recorduseraction . record ( _str ) ; } else { startanimation ( time , overviewanimationtype . undiscard ) ; } mdiscardingtab = null ; requestupdate ( ) ; }	commits or release the that currently being considered for discard.
public list < object > buildjavamethodparameters ( assetoptionscontext context , map < string , string > availableassets , assetoptionsmethodinfo assetmethod ) { final list < object > javamethodparameters = lists . newarraylist ( ) ; javamethodparameters . add ( context ) ; for ( string parentassetname : assetmethod . assetdependencies ) { string parentassetvalue = availableassets . get ( parentassetname ) ; int index = javamethodparameters . size ( ) ; object value = assetmethod . convertparameter ( index , parentassetvalue ) ; javamethodparameters . add ( value ) ; } return javamethodparameters ; }	build the list of parameter objects to hand in to the method invocation.
private static imageview pickgraphic ( restartableservice startstoppable ) { final boolean running = startstoppable . isrunning ( ) ; final imageview icon = running ? new imageview ( stopimage ) : new imageview ( startimage ) ; if ( ! running ) { final fadetransition ft = new fadetransition ( duration . millis ( _num ) , icon ) ; ft . settovalue ( _num ) ; ft . setcyclecount ( transition . indefinite ) ; ft . setautoreverse ( _bool ) ; ft . play ( ) ; } icon . setfitheight ( dpiutility . mini_icon_size ) ; icon . setfitwidth ( dpiutility . mini_icon_size ) ; return icon ; }	gets the graphic that should be used for the button given the current source ' s state.
public void createcashbasedjournalentriesandreversalsforsavingscharges ( final office office , final string currencycode , final cash_accounts_for_savings accounttypetobedebited , final cash_accounts_for_savings accounttypetobecredited , final long savingsproductid , final long paymenttypeid , final long loanid , final string transactionid , final date transactiondate , final bigdecimal totalamount , final boolean isreversal , final list < chargepaymentdto > chargepaymentdtos ) { if ( chargepaymentdtos . size ( ) != _num ) { throw new platformdataintegrityexception ( _str , _str ) ; } chargepaymentdto chargepaymentdto = chargepaymentdtos . get ( _num ) ; final glaccount chargespecificaccount = getlinkedglaccountforsavingscharges ( savingsproductid , accounttypetobecredited . getvalue ( ) , chargepaymentdto . getchargeid ( ) ) ; final glaccount savingscontrolaccount = getlinkedglaccountforsavingsproduct ( savingsproductid , accounttypetobedebited . getvalue ( ) , paymenttypeid ) ; if ( isreversal ) { createdebitjournalentryforsavings ( office , currencycode , chargespecificaccount , loanid , transactionid , transactiondate , totalamount ) ; createcreditjournalentryforsavings ( office , currencycode , savingscontrolaccount , loanid , transactionid , transactiondate , totalamount ) ; } else { createdebitjournalentryforsavings ( office , currencycode , savingscontrolaccount , loanid , transactionid , transactiondate , totalamount ) ; createcreditjournalentryforsavings ( office , currencycode , chargespecificaccount , loanid , transactionid , transactiondate , totalamount ) ; } }	convenience method that creates a pair of related debits and credits for cash based accounting . the target accounts for debits and credits are switched in case of a reversal.
public void addall ( jsonarray array ) { elements . addall ( array . elements ) ; }	adds all the elements of the specified array to self .
public double nextdouble ( double k ) { double u , v , w , c , z ; if ( k <= _num ) throw new illegalargumentexception ( ) ; if ( k_set != k ) { tau = _num + math . sqrt ( _num + _num * k * k ) ; rho = ( tau - math . sqrt ( _num * tau ) ) / ( _num * k ) ; r = ( _num + rho * rho ) / ( _num * rho ) ; k_set = k ; } do { u = randomgenerator . raw ( ) ; v = randomgenerator . raw ( ) ; z = math . cos ( math . pi * u ) ; w = ( _num + r * z ) / ( r + z ) ; c = k * ( r - w ) ; } while ( ( c * ( _num - c ) < v ) && ( math . log ( c / v ) + _num < c ) ) ; return ( randomgenerator . raw ( ) > _num ) ? math . acos ( w ) : - math . acos ( w ) ; }	returns a random number from the distribution ; bypasses the internal state .
public void testlistoptions ( ) { if ( m_optiontester . getoptionhandler ( ) != null ) { if ( ! m_optiontester . checklistoptions ( ) ) { fail ( _str ) ; } } }	tests the listing of the options.
@ override final public void mousereleased ( mouseevent e ) { if ( iscomponentpresseddown ) { mouseliberalclick ( e ) ; long now = system . currenttimemillis ( ) ; long timebetweenunusedclicks = now - lastunusedliberalsingleclicktimestamp ; if ( timebetweenunusedclicks <= slowestdoubleclickmilliseconds ) { mouseliberaldoubleclick ( e ) ; lastunusedliberalsingleclicktimestamp = _num ; } else { lastunusedliberalsingleclicktimestamp = system . currenttimemillis ( ) ; } } iscomponentpresseddown = _bool ; mouserelease ( e ) ; }	mousereleased , final function.
public static modificationtype valueof ( final int intvalue ) { modificationtype result = null ; if ( _num <= intvalue && intvalue < elements . length ) { result = elements [ intvalue ] ; } if ( result == null ) { result = new modificationtype ( intvalue , _str + intvalue + _str , enum . unknown ) ; } return result ; }	returns the modification change type having the specified integer value as defined in rfc 4511 section 4.
@ override public void fillheader ( header hdr ) { try { standard . context ( asciitable . class ) ; hdr . setxtension ( _str ) ; hdr . setbitpix ( basichdu . bitpix_byte ) ; hdr . setnaxes ( _num ) ; hdr . setnaxis ( _num , this . rowlen ) ; hdr . setnaxis ( _num , this . nrows ) ; cursor < string , headercard > iter = hdr . iterator ( ) ; iter . setkey ( naxis2 . key ( ) ) ; iter . next ( ) ; iter . add ( new headercard ( pcount . key ( ) , _num , pcount . comment ( ) ) ) ; iter . add ( new headercard ( gcount . key ( ) , _num , gcount . comment ( ) ) ) ; iter . add ( new headercard ( tfields . key ( ) , this . nfields , tfields . comment ( ) ) ) ; for ( int i = _num ; i < this . nfields ; i += _num ) { addcolinfo ( i , iter ) ; } } catch ( headercardexception e ) { log . log ( level . severe , _str + e . getmessage ( ) , e ) ; } finally { standard . context ( null ) ; } }	fill in a header with information that points to this data .
private boolean searchendmatch ( final string itemname ) { for ( map . entry < string , sentence > e : parsednames . entryset ( ) ) { sentence parsed = e . getvalue ( ) ; if ( itemname . endswith ( parsed . getoriginaltext ( ) ) || itemname . endswith ( parsed . getnormalized ( ) ) ) { name = e . getkey ( ) ; return _bool ; } } return _bool ; }	check for end matches while searching for item names .
private static byte expectednorm ( final defaultsimilarity sim , final int length , final float boost ) { return ( byte ) sim . encodenormvalue ( boost / ( ( float ) math . sqrt ( length ) ) ) ; }	given a length , and boost returns the expected encoded norm.
@ override public shapetilesimplex enlarge ( double p_offset ) { if ( p_offset == _num ) return this ; shapetilesimplex offset_simplex = offset ( p_offset ) ; shapetileoctagon bounding_oct = bounding_octagon ( ) ; if ( bounding_oct . is_nan ( ) ) return shapetilesimplex . empty ; shapetileoctagon offset_oct = bounding_oct . offset ( p_offset ) ; return offset_simplex . intersection ( offset_oct . to_simplex ( ) ) ; }	returns this simplex enlarged by p_offset . the result simplex is intersected with the by p_offset enlarged bounding octagon of this simplex.
v remove ( object key , int hash , object value ) { lock ( ) ; try { int c = cnt - _num ; he < k , v > [ ] tab = table ; int index = hash & ( tab . length - _num ) ; he < k , v > first = tab [ index ] ; he < k , v > e = first ; while ( e != null && ( e . hash != hash || ! key . equals ( e . k ) ) ) e = e . next ; v oldvalue = null ; if ( e != null ) { v v = e . v ; if ( value == null || value . equals ( v ) ) { oldvalue = v ; ++ modcnt ; he < k , v > newfirst = e . next ; for ( he < k , v > p = first ; p != e ; p = p . next ) newfirst = new he < k , v > ( p . k , p . hash , newfirst , p . v ) ; tab [ index ] = newfirst ; cnt = c ; } } return oldvalue ; } finally { unlock ( ) ; } }	remove ; match on key only if value null , else match both .
public static treepath pathtillofkind ( final treepath path , final tree . kind kind ) { return pathtillofkind ( path , enumset . of ( kind ) ) ; }	gets path to the first enclosing tree of the specified kind .
public bigdecimal readf2dot14 ( int index ) { throw new unsupportedoperationexception ( ) ; }	reads the f2dot14 at the given index .
public void addrenderinghints ( map < ? , ? > hints ) { mgraphics . addrenderinghints ( hints ) ; }	adds a number of preferences for the rendering algorithms.
private void createnewfieldsarray ( ) { for ( int i = _num ; i < personfieldsold . length ; i ++ ) { personfieldsnew [ i ] = personfieldsold [ i ] + _str ; } }	new fields are named like old ones with _link attached :.
public void removeallrelations ( ) { for ( bnode inputnode : new linkedlist < bnode > ( inputnodes . values ( ) ) ) { removeinputnode ( inputnode . getid ( ) ) ; } for ( bnode outputnode : new linkedlist < bnode > ( outputnodes . values ( ) ) ) { removeoutputnode ( outputnode . getid ( ) ) ; } }	removes all input and output relations to the node.
private void addexposedtypes ( class < ? > clazz , class < ? > cause ) { if ( pruned ( clazz ) ) { return ; } boolean alreadydone = done ( clazz ) ; visit ( clazz ) ; recordexposure ( clazz , cause ) ; if ( alreadydone || pruned ( clazz ) ) { return ; } typetoken < ? > token = typetoken . of ( clazz ) ; for ( typetoken < ? > supertype : token . gettypes ( ) ) { if ( ! supertype . equals ( token ) ) { logger . debug ( _str , supertype , clazz ) ; addexposedtypes ( supertype , clazz ) ; } } for ( class innerclass : clazz . getdeclaredclasses ( ) ) { if ( exposed ( innerclass . getmodifiers ( ) ) ) { logger . debug ( _str , innerclass , clazz ) ; addexposedtypes ( innerclass , clazz ) ; } } for ( field field : clazz . getdeclaredfields ( ) ) { if ( exposed ( field . getmodifiers ( ) ) ) { logger . debug ( _str , field , clazz ) ; addexposedtypes ( field , clazz ) ; } } for ( invokable invokable : getexposedinvokables ( token ) ) { logger . debug ( _str , invokable , clazz ) ; addexposedtypes ( invokable , clazz ) ; } }	adds a class and all of the types it exposes.
public void storelogs ( file folder ) { string path = folder . getabsolutepath ( ) ; mloggerfolder = new logthis ( path ) ; }	enables the sdk to start writing logs into a desired folder with the name of logthis . txt keep in mind that the sdk does not enable any storage permission , so the application must declare it and ask for it on android m and above.
@ override public object clone ( ) { return new locationpath ( this ) ; }	returns a clone of this object .
private assignment recursivebacktrackingsearch ( csp csp , assignment assignment ) { assignment result = null ; if ( assignment . iscomplete ( csp . getvariables ( ) ) ) { result = assignment ; } else { variable var = selectunassignedvariable ( assignment , csp ) ; for ( object value : orderdomainvalues ( var , assignment , csp ) ) { assignment . setassignment ( var , value ) ; firestatechanged ( assignment , csp ) ; if ( assignment . isconsistent ( csp . getconstraints ( var ) ) ) { domainrestoreinfo info = inference ( var , assignment , csp ) ; if ( ! info . isempty ( ) ) firestatechanged ( csp ) ; if ( ! info . isemptydomainfound ( ) ) { result = recursivebacktrackingsearch ( csp , assignment ) ; if ( result != null ) break ; } info . restoredomains ( csp ) ; } assignment . removeassignment ( var ) ; } } return result ; }	template method , which can be configured by overriding the three primitive operations below .
private static jsonobject createfiletransfererror ( int errorcode , string source , string target , string body , integer httpstatus ) { jsonobject error = null ; try { error = new jsonobject ( ) ; error . put ( _str , errorcode ) ; error . put ( _str , source ) ; error . put ( _str , target ) ; if ( body != null ) { error . put ( _str , body ) ; } if ( httpstatus != null ) { error . put ( _str , httpstatus ) ; } } catch ( jsonexception e ) { log . e ( log_tag , e . getmessage ( ) , e ) ; } return error ; }	create an error object based on the passed in errorcode.
public arraylist < value > keys ( ) { arraylist < value > list = new . arraylist ( size ) ; for ( value k : keys ) { if ( k != null && k != valuenull . deleted ) { list . add ( k ) ; } } return list ; }	get the list of keys .
private void close ( ) { if ( closed ) { return ; } closed = _bool ; try { resultset . close ( ) ; } catch ( final sqlexception e ) { logger . error ( e , e ) ; } try { if ( statement != null ) { statement . close ( ) ; } } catch ( final sqlexception e ) { logger . error ( e , e ) ; } }	closes the resultset and statement .
public deliverythread ( tomlayer tomlayer , servicereplica receiver , recoverable recoverer , serverviewcontroller controller ) { super ( _str ) ; this . decided = new linkedblockingqueue < > ( ) ; this . tomlayer = tomlayer ; this . receiver = receiver ; this . recoverer = recoverer ; this . controller = controller ; }	creates a new instance of deliverythread.
protected void addbuttonlistener ( ) { applicationinsightsadddialog dialog = new applicationinsightsadddialog ( getshell ( ) ) ; dialog . open ( ) ; tableviewer . refresh ( ) ; }	method opens dialog to add existing application insights resource in list .
public int [ ] toarray ( ) { int [ ] result = new int [ size ] ; system . arraycopy ( array , _num , result , _num , size ) ; return result ; }	returns an array containing all of the elements in this list in the correct order .
public block obtainblock ( string prototypename , @ nullable string uuid ) { block block ; if ( uuid != null ) { weakreference < block > ref = mblockrefs . get ( uuid ) ; if ( ref != null ) { block = ref . get ( ) ; if ( block != null ) { throw new illegalargumentexception ( _str + uuid + _str ) ; } } } if ( ! mblocktemplates . containskey ( prototypename ) ) { log . w ( tag , _str + prototypename + _str ) ; return null ; } block . builder builder = new block . builder ( mblocktemplates . get ( prototypename ) ) ; if ( uuid != null ) { builder . setuuid ( uuid ) ; } block = builder . build ( ) ; mblockrefs . put ( block . getid ( ) , new weakreference < block > ( block ) ) ; return block ; }	creates a block of the specified type using one of the master blocks known to this factory.
public smsconsoleserviceconfig ( ) { document doc = parsedocument ( config_filename ) ; configservices ( doc ) ; hiddenservices = collections . unmodifiableset ( services . get ( hidden_services ) ) ; }	generates the singleton smsconsoleserviceconfig by reading and parsing the appropriate xml config file .
private static string converttoquotedstring ( string s ) { if ( s == null || s . isempty ( ) ) { return null ; } if ( s . charat ( _num ) == _str && s . charat ( s . length ( ) - _num ) == _str ) { return s ; } return _str + s + _str ; }	encloses the incoming string inside double quotes , if it isn ' t already quoted .
public patternobserverexpr ( string namespace , string name , expression [ ] parameters ) { super ( namespace , name , arrays . aslist ( parameters ) ) ; }	ctor - for use to create a pattern expression tree , without pattern child expression .
public static string convertstringtohexstring ( string data ) { return conventbytestohexstring ( data . getbytes ( ) ) ; }	convert the string to hex string value .
public boolean istransient ( ) { return modifier . istransient ( getaccessflags ( ) ) ; }	returns true for a transient field .
public boolean isforhttpbasic ( ) { return ( negovalue != null ) ? negovalue . equalsignorecase ( http_httpbasic ) : _bool ; }	returns < code > true < code > if the callback is for httpbasic .
private string indent ( int level ) { final string s = _str ; if ( level == _num ) return _str ; stringbuilder sb = new stringbuilder ( level * s . length ( ) ) ; for ( int i = _num ; i < level ; i ++ ) { sb . append ( s ) ; } return s . tostring ( ) ; }	generates an indentation string .
public static string cut ( string line , intpredicate testfunction ) { string s = _str ; int pos = subparser . locate ( line , testfunction ) ; if ( pos != - _num ) { s = line . substring ( _num , pos ) ; } return s ; }	cuts the string from the beginning until the testfunction predicates .
public void addlistener ( updatemanagerlistener listener ) { listeners . add ( listener ) ; }	listen for updates to the update manager .
public void cancelauthentication ( ) { synchronized ( synclock ) { authenticating = _bool ; timer . cancel ( ) ; timer . purge ( ) ; } }	if this object is authenticating using the callback based authenticate method , then this will cancel future authentication requests.
private void checkvalidinterval ( duration pollinginterval , int retries , long timesleptmillis ) { long highsum = _num ; long lowsum = _num ; for ( int i = _num ; i < retries ; i ++ ) { double currentinterval = pollinginterval . getmillis ( ) * math . pow ( dataflowpipelinejob . default_backoff_exponent , i ) ; double randomoffset = _num * currentinterval ; highsum += math . round ( currentinterval + randomoffset ) ; lowsum += math . round ( currentinterval - randomoffset ) ; } assertthat ( timesleptmillis , allof ( greaterthanorequalto ( lowsum ) , lessthanorequalto ( highsum ) ) ) ; }	validates that a given time is valid for the total time slept by a attemptboundedexponentialbackoff given the number of retries and an initial polling interval .
public void write ( string str , int off , int len ) throws ioexception { if ( _outputstream == null ) throw new ioexception ( _str ) ; final int off_plus_len = off + len ; for ( int i = off ; i < off_plus_len ; ) { char c = str . charat ( i ++ ) ; if ( c < _num ) { _bytes [ _index ] = ( byte ) c ; if ( ++ _index >= _bytes . length ) { flushbuffer ( ) ; } } else { write ( c ) ; } } }	writes a portion of a string .
public commitrecordindex ( irawstore store , checkpoint checkpoint , indexmetadata metadata , boolean readonly ) { super ( store , checkpoint , metadata , readonly ) ; this . ser = new entry . entryserializer ( ) ; }	load from the store .
protected string encodebody ( ) { return long . tostring ( this . sequencenumber ) ; }	encode the body of this header ( the stuff that follows headername ).
private void checksize ( final int i ) { if ( i >= max_size ) { final int old_size = max_size ; max_size += increment_size ; if ( max_size <= i ) { max_size = i + increment_size + _num ; } final rectangle [ ] temp = items ; items = new rectangle [ max_size ] ; system . arraycopy ( temp , _num , items , _num , old_size ) ; increment_size = incrementsize ( increment_size ) ; } }	check the size of the array and increase if needed.
public double volume ( ) { if ( cachedvolume < _num ) { cachedvolume = _num ; ihypercube cube = this . region ; int nd = cube . dimensionality ( ) ; for ( int d = _num ; d <= nd ; d ++ ) { double right = cube . getright ( d ) ; double left = cube . getleft ( d ) ; if ( double . isinfinite ( right ) ) { right = + _num ; } if ( double . isinfinite ( left ) ) { left = - _num ; } if ( left == - _num && right == + _num ) { } else { cachedvolume *= ( right - left ) ; } } } return cachedvolume ; }	return volume of hypercube region associated with node.
static string _targetsofile ( string libname , int version ) { context context = mcontext ; if ( null == context ) { return _str ; } string path = _str + context . getpackagename ( ) + _str ; file f = context . getfilesdir ( ) ; if ( f != null ) { path = f . getpath ( ) ; } return path + _str + libname + _str + version + _str ; }	concatenate the path of the so library , including directory .
@ override public void stopmonitoring ( ) { stopmonitoring ( _bool ) ; }	stop monitoring off - heap usage .
@ override public object compute ( arraylist < map < string , object > > rows ) throws exception { if ( column . equals ( _str ) ) { return rows . size ( ) ; } long count = _num ; for ( map < string , object > row : rows ) { if ( row . containskey ( column ) && ( row . get ( column ) != null ) ) { count ++ ; } } return count ; }	count number of values of given column .
private property [ ] parseproperties ( final string contents ) { final string [ ] parts = contents . split ( _str ) ; final list < property > resultsaslist = new arraylist < property > ( ) ; for ( string part : parts ) { try { if ( ! stringutils . isempty ( part . trim ( ) ) ) { resultsaslist . add ( new property ( part ) ) ; } } catch ( final exception e ) { log . warn ( e . getmessage ( ) , e ) ; } } return resultsaslist . toarray ( new property [ resultsaslist . size ( ) ] ) ; }	parses out the properties of a selector ' s body .
public void requestsecondsuntilaccountexpiration ( ) { operations . add ( passwordpolicystateoperationtype . get_seconds_until_account_expiration ) ; }	returns the seconds until account expiration .
public final boolean equalsignorecase ( string a ) { int len = a . length ( ) ; if ( _length != len ) return _bool ; int offset = _offset ; char [ ] buffer = _buffer ; for ( int i = _num ; i < len ; i ++ ) { char ca = buffer [ offset + i ] ; char cb = a . charat ( i ) ; if ( ca == cb ) { } else if ( character . tolowercase ( ca ) != character . tolowercase ( cb ) ) return _bool ; } return _bool ; }	returns true if the charsegment equals the string .
public static int [ ] checkobjectstart ( pdftokenizer linetokenizer ) { try { linetokenizer . seek ( _num ) ; if ( ! linetokenizer . nexttoken ( ) || linetokenizer . gettokentype ( ) != tokentype . number ) return null ; int num = linetokenizer . getintvalue ( ) ; if ( ! linetokenizer . nexttoken ( ) || linetokenizer . gettokentype ( ) != tokentype . number ) return null ; int gen = linetokenizer . getintvalue ( ) ; if ( ! linetokenizer . nexttoken ( ) ) return null ; if ( ! arrays . equals ( obj , linetokenizer . getbytecontent ( ) ) ) return null ; return new int [ ] { num , gen } ; } catch ( exception ioe ) { } return null ; }	check whether line starts with object declaration .
private object singleelement ( int row , int col ) { object res = null ; if ( this . isnull == null || ! this . isnull [ row * this . nfields + col ] ) { res = arrayfuncs . newinstance ( this . types [ col ] , _num ) ; system . arraycopy ( this . data [ col ] , row , res , _num , _num ) ; } return res ; }	extract a single element from a table.
private char converttochar ( string kurzname ) { char result = kein_siegel ; if ( kurzname != null && ! kurzname . isempty ( ) ) { if ( kurzname . length ( ) > _num ) { result = kurzname . tochararray ( ) [ _num ] ; } else { result = kurzname . tochararray ( ) [ _num ] ; } } return result ; }	convert " > g < " , a , b , c , w , " - " , " - - - " to a char " > g < " is converted to g.
public nodesetdtm ( nodeiterator iterator , xpathcontext xctxt ) { super ( ) ; node node ; m_manager = xctxt . getdtmmanager ( ) ; while ( null != ( node = iterator . nextnode ( ) ) ) { int handle = xctxt . getdtmhandlefromnode ( node ) ; addnodeindocorder ( handle , xctxt ) ; } }	create a nodesetdtm , and copy the members of the given dtmiterator into it .
public static vec meanvector ( dataset dataset ) { densevector dv = new densevector ( dataset . getnumnumericalvars ( ) ) ; meanvector ( dv , dataset ) ; return dv ; }	computes the weighted mean of the given data set .
private void makecachedirectory ( ) { file cachedir = new file ( cache_directory ) ; if ( ! cachedir . exists ( ) ) { cachedir . mkdir ( ) ; } }	creates directory for cache files if it doesn ' t already exist.
public void inputkeyevent ( int value ) { executecommandquietly ( adbcommand ( _str , _str , _str , _str + value ) ) ; try { thread . sleep ( _num ) ; } catch ( interruptedexception e ) { log . warn ( _str , e ) ; } }	use adb to send a keyevent to the device.
public static void passmocksleep ( ) { mocksleepqueue . offer ( _bool ) ; }	let sleeping thread pass the synchronization point .
private querybuilder buildsort ( ) { querybuilder builder = new querybuilder ( ) ; iterator < string > sortiterator = msortingorderlist . iterator ( ) ; while ( sortiterator . hasnext ( ) ) { builder . append ( sortiterator . next ( ) ) ; if ( sortiterator . hasnext ( ) ) builder . append ( _str ) ; } return builder ; }	builds the sort query.
public void init ( int mode , byte [ ] key , byte [ ] iv ) { context = opensslnative . init ( context , mode , algorithm , padding , key , iv ) ; }	initialize this cipher with a key and iv .
private string diff_wordstocharsmunge ( string text , list < string > linearray , map < string , integer > linehash ) { int linestart = _num ; int lineend = - _num ; string line ; stringbuilder chars = new stringbuilder ( ) ; while ( lineend < text . length ( ) - _num ) { string patternstr = _str ; pattern pattern = pattern . compile ( patternstr ) ; matcher matcher = pattern . matcher ( text ) ; matcher . region ( linestart , text . length ( ) ) ; if ( matcher . find ( ) ) { lineend = matcher . start ( ) ; } else lineend = - _num ; if ( lineend == - _num ) { lineend = text . length ( ) - _num ; } line = text . substring ( linestart , lineend + _num ) ; linestart = lineend + _num ; if ( linehash . containskey ( line ) ) { chars . append ( string . valueof ( ( char ) ( int ) linehash . get ( line ) ) ) ; } else { linearray . add ( line ) ; linehash . put ( line , linearray . size ( ) - _num ) ; chars . append ( string . valueof ( ( char ) ( linearray . size ( ) - _num ) ) ) ; } } return chars . tostring ( ) ; }	split a text into a list of strings.
private void replacetop ( scope topofstack ) { stack . set ( stack . size ( ) - _num , topofstack ) ; }	replace the value on the top of the stack with the given value .
public boolean hasnext ( ) { return index < desc . length ( ) ; }	returns true if the iteration has more elements .
public void registersessionthread ( sessionthread newsession ) { synchronized ( this ) { list < sessionthread > toberemoved = new arraylist < sessionthread > ( ) ; for ( sessionthread sessionthread : sessionthreads ) { if ( ! sessionthread . isalive ( ) ) { log . d ( tag , _str ) ; try { sessionthread . join ( ) ; log . d ( tag , _str ) ; toberemoved . add ( sessionthread ) ; sessionthread . closesocket ( ) ; } catch ( interruptedexception e ) { log . d ( tag , _str ) ; } } } for ( sessionthread removethread : toberemoved ) { sessionthreads . remove ( removethread ) ; } sessionthreads . add ( newsession ) ; } log . d ( tag , _str ) ; }	the ftpserverservice must know about all running session threads so they can be terminated on exit.
protected iobjectinfo < t > store_impl ( segment < t > segment , objectinfo < t > oi ) { if ( _invalid ) return null ; _size . incrementandget ( ) ; segment . incrementsize ( ) ; objectinfo < t > tail = segment . gettail ( ) ; tail . setforwardref ( oi ) ; oi . setbackwardref ( tail ) ; segment . settail ( oi ) ; return oi ; }	store an element in segment.
public texformula ( ) { parser = new texparser ( _str , this , _bool ) ; }	creates an empty texformula .
public static void graytobinary ( binaryvariable variable ) { int n = variable . getnumberofbits ( ) ; bitset gray = variable . getbitset ( ) ; variable . set ( n - _num , gray . get ( n - _num ) ) ; for ( int i = n - _num ; i >= _num ; i -- ) { variable . set ( i , variable . get ( i + _num ) ^ gray . get ( i ) ) ; } }	converts a binary variable from a gray encoding to binary encoding .
private void updatetags ( movie movie ) { list < string > availabletags = new arraylist < > ( tagsobservable ) ; for ( string taginmovie : new arraylist < > ( movie . gettags ( ) ) ) { boolean tagfound = _bool ; for ( string tag : availabletags ) { if ( taginmovie . equals ( tag ) ) { tagfound = _bool ; break ; } } if ( ! tagfound ) { addtag ( taginmovie ) ; } } }	update tags used in movies .
protected void removenextprotocolmessages ( list < protocolmessage > protocolmessages , int fromindex ) { for ( int i = protocolmessages . size ( ) - _num ; i >= fromindex ; i -- ) { protocolmessages . remove ( i ) ; } }	in a case the protocol message received was not equal to the messages in our protocol message list , we have to clear our protocol message list .
public static double sigmoid ( double x ) { return _num / ( _num + math . pow ( math . e , - x ) ) ; }	1 / 1 + exp ( - x ).
public void testradix36neg ( ) { string value = _str ; int radix = _num ; biginteger anumber = new biginteger ( value , radix ) ; string result = anumber . tostring ( radix ) ; asserttrue ( result . equals ( value ) ) ; }	test negative number of radix 24.
public ucibestmove stop ( ) { if ( ! isconnected ( ) ) { throw new illegalstateexception ( _str ) ; } if ( log . isdebugenabled ( ) ) { log . debug ( _str ) ; } ucibestmove result = null ; synchronized ( stopsynch ) { if ( ! isprocessinggo ( ) ) { result = lastbestmove ; lastbestmove = null ; } else { long totalsleeptime = _num ; send ( _str ) ; while ( gorunnable != null && totalsleeptime < _num ) { try { thread . sleep ( _num ) ; totalsleeptime += _num ; } catch ( interruptedexception ie ) { } } result = lastbestmove ; lastbestmove = null ; } } return result ; }	stops a go that is in process.
@ override public boolean supportsdatadefinitionanddatamanipulationtransactions ( ) { debugcodecall ( _str ) ; return _bool ; }	returns whether data manipulation and create / drop is supported in transactions .
public static void removejavanooplogger ( collection < handler > rmvhnds ) { logger log = logger . getlogger ( _str ) ; for ( handler h : log . gethandlers ( ) ) log . removehandler ( h ) ; if ( ! f . isempty ( rmvhnds ) ) { for ( handler h : rmvhnds ) log . addhandler ( h ) ; } }	removes previously added no - op handler for root java logger .
private int binarysearch ( final int start , final int end , final sizetester sizetester , final rectf availablespace ) { int lastbest = start ; int low = start ; int high = end - _num ; int middle ; while ( low <= high ) { middle = low + high > > > _num ; final int midvalcmp = sizetester . ontestsize ( middle , availablespace ) ; if ( midvalcmp < _num ) { lastbest = low ; low = middle + _num ; } else if ( midvalcmp > _num ) { high = middle - _num ; lastbest = high ; } else return middle ; } return lastbest ; }	calculates best text size for current edittext size.
protected boolean isvaliddomain ( string domain ) { matcher ipdomainmatcher = ip_domain_pattern . matcher ( domain ) ; if ( ipdomainmatcher . matches ( ) ) { inetaddressvalidator inetaddressvalidator = inetaddressvalidator . getinstance ( ) ; return inetaddressvalidator . isvalid ( ipdomainmatcher . group ( _num ) ) ; } domainvalidator domainvalidator = domainvalidator . getinstance ( allowlocal ) ; return domainvalidator . isvalid ( domain ) || domainvalidator . isvalidtld ( domain ) ; }	returns true if the domain component of an email address is valid .
public void testtimedinvokeany4 ( ) throws throwable { executorservice e = new forkjoinpool ( _num ) ; poolcleaner cleaner = null ; try { cleaner = cleaner ( e ) ; long starttime = system . nanotime ( ) ; list < callable < string > > l = new arraylist < callable < string > > ( ) ; l . add ( new npetask ( ) ) ; try { e . invokeany ( l , long_delay_ms , milliseconds ) ; shouldthrow ( ) ; } catch ( executionexception success ) { asserttrue ( success . getcause ( ) instanceof nullpointerexception ) ; } asserttrue ( milliselapsedsince ( starttime ) < long_delay_ms ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }	timed invokeany ( c ) throws executionexception if no task completes.
private void parse ( file dir ) { file [ ] xmlfiles = dir . listfiles ( new xmlfilter ( ) ) ; for ( file xmlfile : xmlfiles ) { parsetestfromxml ( xmlfile ) ; } }	builds mtestmap based on directory contents.
public boolean hasnext ( int index ) { for ( int p = _num ; p < mask . length ; p ++ ) { if ( mask [ p ] ) { if ( index <= lastelementindex [ p ] ) { return _bool ; } } } return _bool ; }	returns true if the last possible index stored in lastelementindex for all currently selected partitions is not yet reached.
public static boolean isexternalstorageavailable ( ) { string state = environment . getexternalstoragestate ( ) ; if ( state . equals ( environment . media_mounted ) ) { return _bool ; } else { return _bool ; } }	checks if the external storage is available.
public tarentry ( byte [ ] headerbuf ) { this ( ) ; parsetarheader ( headerbuf ) ; }	construct an entry from an archive ' s header bytes.
public static void unregistermbeans ( mbeanserver mbeanserver ) { try { mbeanserver . unregistermbean ( log4jmxbeanimp . getobjectname ( ) ) ; mbeanserver . unregistermbean ( exceptionmxbeanimp . getobjectname ( ) ) ; mbeanserver . unregistermbean ( exceptiondeltamxbeanimp . getobjectname ( ) ) ; mbeanserver . unregistermbean ( log4jdeltamxbeanimp . getobjectname ( ) ) ; mbeanserver . unregistermbean ( jamonmxbeanimp . getobjectname ( ) ) ; mbeanserver . unregistermbean ( httpstatusmxbeanimp . getobjectname ( ) ) ; mbeanserver . unregistermbean ( httpstatusdeltamxbeanimp . getobjectname ( ) ) ; unregistergcmxbean ( mbeanserver ) ; unregistermbeansfrompropsfile ( mbeanserver ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } }	unregister all jamon related mbeans.
public static deterministickey createmasterprivatekey ( byte [ ] seed ) throws hdderivationexception { checkargument ( seed . length > _num , _str ) ; byte [ ] i = hdutils . hmacsha512 ( master_hmac_sha512 , seed ) ; checkstate ( i . length == _num , i . length ) ; byte [ ] il = arrays . copyofrange ( i , _num , _num ) ; byte [ ] ir = arrays . copyofrange ( i , _num , _num ) ; arrays . fill ( i , ( byte ) _num ) ; deterministickey masterprivkey = createmasterprivkeyfrombytes ( il , ir ) ; arrays . fill ( il , ( byte ) _num ) ; arrays . fill ( ir , ( byte ) _num ) ; return masterprivkey ; }	generates a new deterministic key from the given seed , which can be any arbitrary byte array.
public boolean isnanpacountry ( string regioncode ) { return nanparegions . contains ( regioncode ) ; }	checks if this is a region under the north american numbering plan administration ( nanpa ) .
public void parse ( inputstream in ) throws ioexception , saxexception { try { _xmlreader . setinput ( in ) ; parseall ( ) ; } catch ( xmlstreamexception e ) { if ( e . getnestedexception ( ) instanceof ioexception ) throw ( ioexception ) e . getnestedexception ( ) ; throw new saxexception ( e . getmessage ( ) ) ; } finally { _xmlreader . reset ( ) ; } }	parses an xml document from the specified input stream ( encoding retrieved from input source and the xml prolog if any ) .
@ override public void printstacktrace ( printstream ps ) { super . printstacktrace ( ps ) ; if ( nested != null ) nested . printstacktrace ( ps ) ; }	prints the composite message and the embedded stack trace to the specified stream ps .
public ampassword ( char [ ] pw ) { int i ; int length = pw . length ; cleared = _bool ; password = new char [ length ] ; system . arraycopy ( pw , _num , password , _num , length ) ; }	creates a password from a char array , then wipes the char array .
public void reset ( ) { firststep = _bool ; n3 = _num ; n4 = _num ; system . arraycopy ( iv , _num , ofbv , _num , iv . length ) ; bytecount = _num ; cipher . reset ( ) ; }	reset the feedback vector back to the iv and reset the underlying cipher .
private static img createcontrolbuttonimage ( string name , string js_command , boolean enabled ) { stringbuffer imgname = new stringbuffer ( _str + name ) ; if ( ! enabled ) imgname . append ( _str ) ; imgname . append ( _str ) ; img img = new img ( mobileenv . getimagedirectory ( imgname . tostring ( ) ) , name ) ; if ( enabled ) img . setalt ( msg . getmsg ( ad_language , name ) ) ; img . setid ( _str ) ; if ( js_command != null && js_command . length ( ) > _num && enabled ) { img . setonclick ( _str + form_name + _str + m_command + _str + name + _str + js_command ) ; } return img ; }	create image with name , id of button_name and set m_command onclick.
public string [ ] toarray ( ) throws exception { return utils . splitoptions ( tocommandline ( ) ) ; }	returns the current dom document as string array .
public static set < evalfactorynode > recursivegetchildnodes ( evalfactorynode currentnode , evalnodeutilfactoryfilter filter ) { set < evalfactorynode > result = new linkedhashset < evalfactorynode > ( ) ; if ( filter . consider ( currentnode ) ) { result . add ( currentnode ) ; } recursivegetchildnodes ( result , currentnode , filter ) ; return result ; }	returns all child nodes as a set .
void dispose ( ) { if ( popup != null ) { popup . removeall ( ) ; } popup = null ; }	clean up when this object is no longer needed . should not be called while the object is still displayed ; see remove ( ).
@ override public void endprefixmapping ( string str ) throws saxexception { }	this method does nothing .
@ override public void parse ( final cookie cookie , final string value ) throws malformedcookieexception { if ( cookie == null ) { throw new illegalargumentexception ( _str ) ; } if ( value == null ) { throw new malformedcookieexception ( _str ) ; } int age = - _num ; try { age = integer . parseint ( value ) ; } catch ( final numberformatexception e ) { age = - _num ; } if ( age < _num ) { throw new malformedcookieexception ( _str ) ; } cookie . setexpirydate ( new date ( system . currenttimemillis ( ) + age * _num ) ) ; }	parse cookie max - age attribute .
public variableconfigresource ( string configuration , textresource baseresource ) { this ( baseresource ) ; for ( string configurationline : configuration . split ( _str ) ) { string [ ] configsplit = configurationline . split ( _str ) ; addconfig ( configsplit [ _num ] , configsplit [ _num ] ) ; } }	constructs a textresource that substitutes variables with values in a wrapped textresource.
private static string readfile ( string filename ) { string classmethod = _str ; stringbuilder filedata = new stringbuilder ( ) ; string filestring = _str ; try { bufferedreader reader = new bufferedreader ( new filereader ( filename ) ) ; char [ ] buf = new char [ _num ] ; int numread = _num ; while ( ( numread = reader . read ( buf ) ) != - _num ) { string readdata = string . valueof ( buf , _num , numread ) ; filedata . append ( readdata ) ; buf = new char [ _num ] ; } reader . close ( ) ; filestring = filedata . tostring ( ) ; } catch ( exception e ) { debug . error ( classmethod + _str + filename ) ; } return filestring ; }	reads a file into a string .
public scaleiosnapshotvolumeresponse snapshotmultivolume ( map < string , string > id2snapshot , string systemid ) throws exception { string uri = scaleioconstants . getsnapshotvolumesuri ( systemid ) ; scaleiosnapshotvolumes spvol = new scaleiosnapshotvolumes ( ) ; for ( map . entry < string , string > entry : id2snapshot . entryset ( ) ) { spvol . addsnapshot ( entry . getkey ( ) , entry . getvalue ( ) ) ; } clientresponse response = post ( uri . create ( uri ) , getjsonforentity ( spvol ) ) ; return getresponseobject ( scaleiosnapshotvolumeresponse . class , response ) ; }	create multiple snapshots in a consistency group.
@ override public string tostring ( ) { return _str + m_width + _str + m_sumofweights + _str + m_tm . tostring ( ) ; }	returns textual description of this estimator .
public boolean isdraft ( ) { return draft != null && draft . booleanvalue ( ) ; }	checks the value of the app : draft tag .
private weatherupdater ( ) { onturnreached ( _num ) ; }	create a new weaterupdater instance.
protected void writedatatofile ( nodeholder nodeholder ) throws carbondatawriterexception { long offset = writedatatofile ( nodeholder , filechannel ) ; blockletinfocolumnar blockletinfo = getblockletinfo ( nodeholder , offset ) ; blockletinfolist . add ( blockletinfo ) ; }	this method will be used to write leaf data to file file format < key > < measure1 > < measure2 >.
protected container createsidenavigationcomponent ( vector commands ) { return createsidenavigationcomponent ( commands , null ) ; }	creates the side navigation component with the commands.
public static double min ( double [ ] a ) { double min = double . positive_infinity ; for ( int i = _num ; i < a . length ; i ++ ) { if ( double . isnan ( a [ i ] ) ) return double . nan ; if ( a [ i ] < min ) min = a [ i ] ; } return min ; }	returns the minimum value in the specified array .
@ override public void onupdateselection ( int oldselstart , int oldselend , int newselstart , int newselend , int candidatesstart , int candidatesend ) { super . onupdateselection ( oldselstart , oldselend , newselstart , newselend , candidatesstart , candidatesend ) ; if ( mcomposing . length ( ) > _num && ( newselstart != candidatesend || newselend != candidatesend ) ) { mcomposing . setlength ( _num ) ; updatecandidates ( ) ; inputconnection ic = getcurrentinputconnection ( ) ; if ( ic != null ) { ic . finishcomposingtext ( ) ; } } }	deal with the editor reporting movement of its cursor .
public < t > t mapto ( final class < t > mappingclass ) { return mapto ( mappingclass , null ) ; }	map the structure fields to a class fields .
private arraylist < spinnerlanguageelement > createspinnerlanguages ( int avoidlanguage ) { arraylist < spinnerlanguageelement > result = new arraylist < spinnerlanguageelement > ( ) ; list < string > languages = msessionoptions . alllanguages ( ) ; for ( int i = _num ; i < languages . size ( ) ; ++ i ) { if ( i != avoidlanguage ) { result . add ( new spinnerlanguageelement ( languages . get ( i ) , i ) ) ; } } return result ; }	determines what languages will be shown in the spinner .
private string useragent ( ) { return museragent ; }	returns the default user agent.
protected void collectproperties ( class < ? > type , type < ? > referencetype , map < string , property > properties ) { try { beaninfo beaninfo = introspector . getbeaninfo ( type ) ; propertydescriptor [ ] descriptors = beaninfo . getpropertydescriptors ( ) ; for ( final propertydescriptor pd : descriptors ) { try { method readmethod = getreadmethod ( pd , type ) ; method writemethod = getwritemethod ( pd , type , null ) ; property property = processproperty ( pd . getname ( ) , pd . getpropertytype ( ) , readmethod , writemethod , type , referencetype , properties ) ; postprocessproperty ( property , pd , readmethod , writemethod , type , referencetype , properties ) ; } catch ( final exception e ) { throw new runtimeexception ( _str + referencetype . getcanonicalname ( ) + _str + pd . getname ( ) + _str , e ) ; } } } catch ( introspectionexception e ) { throw new runtimeexception ( e ) ; } }	collects all properties for the specified type .
public void addheaderview ( view v , object data , boolean isselectable ) { if ( madapter != null && ! ( madapter instanceof headerviewlistadapter ) ) { throw new illegalstateexception ( _str ) ; } fixedviewinfo info = new fixedviewinfo ( ) ; info . view = v ; info . data = data ; info . isselectable = isselectable ; mheaderviewinfos . add ( info ) ; if ( madapter != null && mobserver != null ) { mobserver . onchanged ( ) ; } }	add a fixed view to appear at the top of the list.
private void renderoperatorbackground ( final operator operator , final graphics2d g2 ) { rectangle2d frame = model . getoperatorrect ( operator ) ; if ( frame == null ) { return ; } roundrectangle2d background = new roundrectangle2d . double ( frame . getx ( ) - _num , frame . gety ( ) - _num , frame . getwidth ( ) + _num , frame . getheight ( ) + _num , operator_bg_corner , operator_bg_corner ) ; g2 . setcolor ( color . white ) ; g2 . fill ( background ) ; rectangle2d namebounds = operator_font . getstringbounds ( operator . getname ( ) , g2 . getfontrendercontext ( ) ) ; if ( namebounds . getwidth ( ) > frame . getwidth ( ) ) { double relevantwidth = math . min ( namebounds . getwidth ( ) , frame . getwidth ( ) * max_header_ratio ) ; double offset = ( frame . getwidth ( ) - relevantwidth ) / _num ; int x = ( int ) ( frame . getx ( ) + offset ) ; int padding = _num ; roundrectangle2d namebackground = new roundrectangle2d . double ( ( int ) math . min ( frame . getx ( ) - padding , x - padding ) , frame . gety ( ) - _num , relevantwidth + _num * padding , processrenderermodel . header_height + _num , operator_bg_corner , operator_bg_corner ) ; g2 . fill ( namebackground ) ; } renderportsbackground ( operator . getinputports ( ) , g2 ) ; renderportsbackground ( operator . getoutputports ( ) , g2 ) ; }	draws the operator background ( white round rectangle ) .
public void makeexistingdemandbillinactive ( string assessmentno ) { demandbillservice demandbillservice = ( demandbillservice ) beanprovider . getbean ( _str ) ; demandbillservice . makedemandbillinactive ( assessmentno ) ; }	api to make the existing demandbill inactive.
public void write ( dataoutput out ) throws ioexception { writableutils . writevint ( out , length ) ; out . write ( bytes , _num , length ) ; }	serialize write this object to out length uses zero - compressed encoding.
@ override public int dofinal ( final byte [ ] out , final int outoff ) throws badciphertextexception { complete_ = _bool ; int written = contentcryptohandler_ . dofinal ( out , outoff ) ; updatetrailingsignature ( out , outoff , written ) ; if ( cryptoalgo_ . gettrailingsignaturelength ( ) > _num ) { try { ciphertextfooters footer = new ciphertextfooters ( trailingsig_ . sign ( ) ) ; byte [ ] fbytes = footer . tobytearray ( ) ; system . arraycopy ( fbytes , _num , out , outoff + written , fbytes . length ) ; return written + fbytes . length ; } catch ( final signatureexception ex ) { throw new awscryptoexception ( ex ) ; } } else { return written ; } }	finish encryption of the plaintext bytes .
public void hideallbudges ( ) { for ( relativelayout badge : badgelist ) { if ( badge . getvisibility ( ) == visible ) badgehelper . hidebadge ( badge ) ; } badgesaveinstancehashmap . clear ( ) ; }	hiding all available badges.
public element render ( svgplot svgp ) { element tag = svgp . svgelement ( svgconstants . svg_g_tag ) ; element button = svgp . svgrect ( x , y , w , h ) ; if ( ! double . isnan ( r ) ) { svgutil . setatt ( button , svgconstants . svg_rx_attribute , r ) ; svgutil . setatt ( button , svgconstants . svg_ry_attribute , r ) ; } svgutil . setatt ( button , svgconstants . svg_style_attribute , butcss . inlinecss ( ) ) ; tag . appendchild ( button ) ; if ( svgp . getidelement ( svgeffects . light_gradient_id ) != null ) { element light = svgp . svgrect ( x , y , w , h ) ; if ( ! double . isnan ( r ) ) { svgutil . setatt ( light , svgconstants . svg_rx_attribute , r ) ; svgutil . setatt ( light , svgconstants . svg_ry_attribute , r ) ; } svgutil . setatt ( light , svgconstants . svg_style_attribute , _str + svgeffects . light_gradient_id + _str ) ; tag . appendchild ( light ) ; } if ( svgp . getidelement ( svgeffects . shadow_id ) != null ) { button . setattribute ( svgconstants . svg_filter_attribute , _str + svgeffects . shadow_id + _str ) ; } if ( title != null ) { element label = svgp . svgtext ( x + w * _num , y + h * _num , title ) ; label . setattribute ( svgconstants . svg_style_attribute , titlecss . inlinecss ( ) ) ; tag . appendchild ( label ) ; } return tag ; }	produce the actual svg elements for the button .
public void add ( string gram ) { if ( name == null || gram == null ) return ; int len = gram . length ( ) ; if ( len < _num || len > ngram . n_gram ) return ; ++ n_words [ len - _num ] ; if ( freq . containskey ( gram ) ) { freq . put ( gram , freq . get ( gram ) + _num ) ; } else { freq . put ( gram , _num ) ; } }	add n - gram to profile.
public void test_addressing ( ) { final journal store = ( journal ) getstore ( ) ; try { final rwstrategy bufferstrategy = ( rwstrategy ) store . getbufferstrategy ( ) ; final rwstore rw = bufferstrategy . getstore ( ) ; final arraylist < integer > sizes = new arraylist < integer > ( ) ; final treemap < long , integer > paddrs = new treemap < long , integer > ( ) ; for ( int i = _num ; i < _num ; i ++ ) { final int s = r . nextint ( _num ) + _num ; sizes . add ( s ) ; final int a = rw . alloc ( s , null ) ; final long pa = rw . physicaladdress ( a ) ; asserttrue ( paddrs . get ( pa ) == null ) ; paddrs . put ( pa , a ) ; } for ( int i = _num ; i < _num ; i ++ ) { final int s = r . nextint ( _num ) + _num ; sizes . add ( s ) ; final int a = rw . alloc ( s , null ) ; final long pa = rw . physicaladdress ( a ) ; paddrs . put ( pa , a ) ; } } finally { store . destroy ( ) ; } }	ensures the allocation of unique addresses by mapping allocated address with uniqueness assertion against physical address .
public void handleclientmembership ( string clientid , int eventtype ) { string notiftype = null ; list < managedresource > cleanedup = null ; if ( eventtype == clientmembershipmessage . left ) { notiftype = notif_client_left ; cleanedup = cleanupbridgeclientresources ( clientid ) ; } else if ( eventtype == clientmembershipmessage . crashed ) { notiftype = notif_client_crashed ; cleanedup = cleanupbridgeclientresources ( clientid ) ; } else if ( eventtype == clientmembershipmessage . joined ) { notiftype = notif_client_joined ; } if ( cleanedup != null ) { for ( managedresource resource : cleanedup ) { mbeanutil . unregistermbean ( resource ) ; } } helper . sendnotification ( this , new notification ( notiftype , this . modelmbean , helper . getnextnotificationsequencenumber ( ) , clientid ) ) ; }	implementation handles client membership changes .
public < v extends comparable < ? super v > > optionaldouble maxby ( doublefunction < v > keyextractor ) { objdoublebox < v > result = collect ( null , null , null ) ; return result . a == null ? optionaldouble . empty ( ) : optionaldouble . of ( result . b ) ; }	returns the maximum element of this stream according to the provided key extractor function.
private jlabel addkeybindlabel ( jpanel panel , string labeltext ) { gridbagconstraints gbc = new gridbagconstraints ( ) ; gbc . anchor = gridbagconstraints . west ; gbc . insets = new insets ( _num , _num , _num , _num ) ; gbc . gridx = _num ; gbc . gridy = keybindlabelgridycounter ++ ; gbc . weightx = _num ; jlabel jlbl = new jlabel ( labeltext ) ; panel . add ( jlbl , gbc ) ; return jlbl ; }	adds a new label to the keybinds list.
public static boolean isletterornumber ( int c ) { return isletter ( c ) || isnumber ( c ) ; }	checks whether the supplied character is a letter or number according to the n - triples specification .
public string seasonsummarystr ( ) { setteamranks ( ) ; stringbuilder sb = new stringbuilder ( ) ; sb . append ( ncgsummarystr ( ) ) ; sb . append ( _str + userteam . seasonsummarystr ( ) ) ; sb . append ( _str + leaguerecords . brokenrecordsstr ( getyear ( ) , userteam . abbr ) ) ; return sb . tostring ( ) ; }	get summary of season .
public void addendbumper ( ) { numendbumpers ++ ; string name = _str ; boolean duplicate = _bool ; while ( duplicate ) { name = _str + numendbumpers ; if ( finder . findpositionablepointbyname ( name ) == null ) { duplicate = _bool ; } if ( duplicate ) { numendbumpers ++ ; } } positionablepoint o = new positionablepoint ( name , positionablepoint . end_bumper , currentpoint , this ) ; pointlist . add ( o ) ; setdirty ( _bool ) ; }	add an end bumper point .
public int pixelfor ( color c ) { return pixelfor ( c . getrgb ( ) ) ; }	returns the pixel data for the specified color packed into an integer for easy storage and conveyance.
void stripnoncompilednodes ( node n , set < string > filestocompile ) { for ( node child : n . children ( ) ) { if ( ! filestocompile . contains ( child . getsourcefilename ( ) ) ) { child . detachfromparent ( ) ; } } }	removes the root nodes for all the library files from the source node .
protected void restorebaseuri ( ) { fbaseuri . pop ( ) ; fliteralsystemid . pop ( ) ; fexpandedsystemid . pop ( ) ; fbaseuriscope . pop ( ) ; fcurrentbaseuri . setbasesystemid ( ( string ) fbaseuri . peek ( ) ) ; fcurrentbaseuri . setliteralsystemid ( ( string ) fliteralsystemid . peek ( ) ) ; fcurrentbaseuri . setexpandedsystemid ( ( string ) fexpandedsystemid . peek ( ) ) ; }	discards the uris at the top of the stack , and restores the ones beneath it .
public void testtobigintegerpos1 ( ) { string a = _str ; biginteger bnumber = new biginteger ( _str ) ; bigdecimal anumber = new bigdecimal ( a ) ; biginteger result = anumber . tobiginteger ( ) ; asserttrue ( _str , result . equals ( bnumber ) ) ; }	convert a positive bigdecimal to biginteger.
public static boolean asboolean ( charsequence string ) { return string . length ( ) > _num ; }	coerce a string ( an instance of charsequence ) to a boolean value.
public void initialize ( ) { texturestate ts = new texturestate ( ) ; ts . setenabled ( _bool ) ; setrenderstate ( ts ) ; for ( int i = _num ; i < landmarklist . size ( ) ; ++ i ) { landmarkstate state = landmarklist . get ( i ) ; addlandmark ( state , _bool ) ; } zbufferstate = new zbufferstate ( ) ; zbufferstate . setfunction ( zbufferstate . testfunction . lessthanorequalto ) ; zbufferstate . setenabled ( _bool ) ; setrenderstate ( zbufferstate ) ; }	initialize this object create landmark objects.
public list < jccompilationunit > entertrees ( list < jccompilationunit > roots ) { if ( ! tasklistener . isempty ( ) ) { for ( jccompilationunit unit : roots ) { taskevent e = new taskevent ( taskevent . kind . enter , unit ) ; tasklistener . started ( e ) ; } } enter . main ( roots ) ; if ( ! tasklistener . isempty ( ) ) { for ( jccompilationunit unit : roots ) { taskevent e = new taskevent ( taskevent . kind . enter , unit ) ; tasklistener . finished ( e ) ; } } if ( needrootclasses || sourceoutput || stuboutput ) { listbuffer < jcclassdecl > cdefs = new listbuffer < > ( ) ; for ( jccompilationunit unit : roots ) { for ( list < jctree > defs = unit . defs ; defs . nonempty ( ) ; defs = defs . tail ) { if ( defs . head instanceof jcclassdecl ) cdefs . append ( ( jcclassdecl ) defs . head ) ; } } rootclasses = cdefs . tolist ( ) ; } for ( jccompilationunit unit : roots ) { inputfiles . add ( unit . sourcefile ) ; } return roots ; }	enter the symbols found in a list of parse trees.
public static linebylinefileinputoperator checkpoint ( linebylinefileinputoperator oper , bytearrayoutputstream bos ) throws exception { kryo kryo = new kryo ( ) ; output loutput = new output ( bos ) ; kryo . writeobject ( loutput , oper ) ; loutput . close ( ) ; input linput = new input ( bos . tobytearray ( ) ) ; @ suppresswarnings ( _str ) linebylinefileinputoperator checkpointedoper = kryo . readobject ( linput , oper . getclass ( ) ) ; linput . close ( ) ; return checkpointedoper ; }	this method checkpoints the given operator .
public static string explode ( collection < string > collection , string delimiter ) { stringbuilder sb = new stringbuilder ( ) ; if ( ! collection . isempty ( ) ) { iterator < string > i = collection . iterator ( ) ; sb . append ( i . next ( ) ) ; while ( i . hasnext ( ) ) { sb . append ( delimiter ) ; sb . append ( i . next ( ) ) ; } } return sb . tostring ( ) ; }	returns the tokens of a collection concanated to a delimited by the given delimiter .
public static void writestatistics ( tdoubleobjecthashmap < descriptivestatistics > statsmap , string keylabel , string file ) throws ioexception { double [ ] keys = statsmap . keys ( ) ; arrays . sort ( keys ) ; bufferedwriter writer = new bufferedwriter ( new filewriter ( file ) ) ; writer . write ( keylabel ) ; writer . write ( tab ) ; writer . write ( _str ) ; writer . write ( tab ) ; writer . write ( _str ) ; writer . write ( tab ) ; writer . write ( _str ) ; writer . write ( tab ) ; writer . write ( _str ) ; writer . write ( tab ) ; writer . write ( _str ) ; writer . newline ( ) ; for ( double key : keys ) { descriptivestatistics stats = statsmap . get ( key ) ; writer . write ( string . valueof ( key ) ) ; writer . write ( tab ) ; writer . write ( string . valueof ( stats . getmean ( ) ) ) ; writer . write ( tab ) ; writer . write ( string . valueof ( stats . getpercentile ( _num ) ) ) ; writer . write ( tab ) ; writer . write ( string . valueof ( stats . getmin ( ) ) ) ; writer . write ( tab ) ; writer . write ( string . valueof ( stats . getmax ( ) ) ) ; writer . write ( tab ) ; writer . write ( string . valueof ( stats . getn ( ) ) ) ; writer . newline ( ) ; } writer . close ( ) ; }	writes a table with columns map - key and statistical indicators mean , median , min , max and number of samples.
public void actionperformed ( actionevent e ) { if ( ! checkmodified ( ) ) return ; if ( m_script . getfilename ( ) == null ) return ; try { m_script . start ( m_args ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; joptionpane . showmessagedialog ( filescriptingpanel . this , _str + ex , _str , joptionpane . error_message ) ; } }	fired when action got executed .
static string encodestub ( rmiserver rmiserver , map < string , ? > env ) throws ioexception { if ( iiophelper . isstub ( rmiserver ) ) return _str + encodeiiopstub ( rmiserver , env ) ; else return _str + encodejrmpstub ( rmiserver , env ) ; }	returns the ior of the given rmiserver .
public int linetoy ( int line ) { fontmetrics fm = painter . getfontmetrics ( ) ; return ( line - firstline ) * fm . getheight ( ) - ( fm . getleading ( ) + fm . getmaxdescent ( ) ) ; }	converts a line index to a y co - ordinate .
private void handledoubleclick ( doubleclickevent e ) { iselection selection = e . getselection ( ) ; if ( selection instanceof istructuredselection ) { istructuredselection structured = ( istructuredselection ) selection ; if ( structured . size ( ) == _num ) { object first = structured . getfirstelement ( ) ; if ( first instanceof isvnremotefile ) { openaction . selectionchanged ( null , selection ) ; openaction . run ( null ) ; } else { treeviewer . setexpandedstate ( first , ! treeviewer . getexpandedstate ( first ) ) ; } } } }	the mouse has been double - clicked in the tree , perform appropriate behaviour .
public csvresultsetconfiguration ( ) { }	this will create a completely empty result set configuration.
protected file choosefile ( int type ) { frame frame = getframe ( ) ; file f = null ; if ( filechooser == null ) filechooser = new jfilechooser ( ) ; filechooser . setcurrentdirectory ( e00file ) ; if ( type == _num ) filechooser . setdialogtype ( jfilechooser . open_dialog ) ; else filechooser . setdialogtype ( jfilechooser . save_dialog ) ; int retval = filechooser . showdialog ( frame , null ) ; if ( retval == jfilechooser . approve_option ) f = filechooser . getselectedfile ( ) ; return f ; }	description of the method.
public void pixellate ( fontrendercontext renderfrc , point2d loc , point pxresult ) { if ( renderfrc == null ) { renderfrc = frc ; } affinetransform at = renderfrc . gettransform ( ) ; at . transform ( loc , loc ) ; pxresult . x = ( int ) loc . getx ( ) ; pxresult . y = ( int ) loc . gety ( ) ; loc . setlocation ( pxresult . x , pxresult . y ) ; try { at . inversetransform ( loc , loc ) ; } catch ( noninvertibletransformexception e ) { throw new illegalargumentexception ( _str ) ; } }	! ! ! not used currently , but might be by getpixelbounds ?.
public static long starttime ( ) { return system . nanotime ( ) ; }	get a start time .
@ transactional public int deleteall ( ) { list < t > allentities = retrieveall ( ) ; for ( t entity : allentities ) { delete ( entity ) ; } return allentities . size ( ) ; }	deletes all instances of class t in the database .
private gsmessageimpl receivefromqueue ( long timeout ) throws receivefromqueueexception { transaction txn = m_session . gettransaction ( ) ; if ( _logger . isloggable ( level . fine ) ) { _logger . log ( level . fine , _str + txn ) ; } try { return ( gsmessageimpl ) m_space . take ( m_jmsmessagetemplate , txn , timeout ) ; } catch ( exception e ) { throw new receivefromqueueexception ( e ) ; } }	retrieves a message from the queue .
public string findnext ( boolean previousflipped ) { boolean resetisflipped = _bool ; if ( previousflipped && count > _num ) { if ( ! valueiterator . hasnext ( ) ) { valueiterator = values . iterator ( ) ; index = _num ; isflipped = _bool ; resetisflipped = _bool ; } else { index ++ ; } currentvalue = valueiterator . next ( ) ; } count ++ ; if ( resetisflipped ) { isflipped = _bool ; } return currentvalue ; }	find the next value of the value chain .
public static boolean isnotempty ( list < object > list ) { return ! list . isempty ( ) ; }	returns true if list if not empty .
private registrationresult checkpassword ( string password , string confirmpassword ) { if ( ( password == null ) || password . length ( ) == _num ) { if ( debug . messageenabled ( ) ) { debug . message ( _str ) ; } return registrationresult . no_password_error ; } else { if ( password . length ( ) < requiredpasswordlength ) { if ( debug . messageenabled ( ) ) { debug . message ( _str ) ; } return registrationresult . password_too_short ; } if ( ( confirmpassword == null ) || confirmpassword . length ( ) == _num ) { if ( debug . messageenabled ( ) ) { debug . message ( _str ) ; } return registrationresult . no_confirmation_error ; } else { if ( ! password . equals ( confirmpassword ) ) { return registrationresult . password_mismatch_error ; } } } return registrationresult . no_error ; }	checks the passwords and returned error state or succeeded if the passwords are valid .
private static ldapfilter createandfilter ( filterset filterset ) throws ldapexception , ioexception { list < jaxbelement < ? > > list = filterset . getfiltergroup ( ) ; arraylist < rawfilter > filters = new arraylist < > ( list . size ( ) ) ; for ( jaxbelement < ? > filter : list ) { filters . add ( createfilter ( filter ) ) ; } return ldapfilter . createandfilter ( filters ) ; }	returns a new and search filter with the provided filter components .
void calculateutility ( firingplan firingplan , int overheattolerance , boolean shooterisaero ) { int overheat = _num ; if ( firingplan . getheat ( ) > overheattolerance ) { overheat = firingplan . getheat ( ) - overheattolerance ; } double modifier = _num ; modifier += calccommandutility ( firingplan . gettarget ( ) ) ; modifier += calcstrategicbuildingtargetutility ( firingplan . gettarget ( ) ) ; modifier += calcpriorityunittargetutility ( firingplan . gettarget ( ) ) ; double utility = _num ; utility += damage_utility * firingplan . getexpecteddamage ( ) ; utility += critical_utility * firingplan . getexpectedcriticals ( ) ; utility += kill_utility * firingplan . getkillprobability ( ) ; utility *= calctargetpotentialdamagemultiplier ( firingplan . gettarget ( ) ) ; utility += target_hp_fraction_dealt_utility * calcdamageallocationutility ( firingplan . gettarget ( ) , firingplan . getexpecteddamage ( ) ) ; utility -= calcciviliantargetdisutility ( firingplan . gettarget ( ) ) ; utility *= modifier ; utility -= ( shooterisaero ? overheat_disutility_aero : overheat_disutility ) * overheat ; utility -= ( firingplan . gettarget ( ) instanceof mechwarrior ) ? ejected_pilot_disutility : _num ; firingplan . setutility ( utility ) ; }	calculates the ' utility ' of a firing plan . override this function if you have a better idea about what firing plans are good.
public void put ( string key , double value ) { if ( value == double . positive_infinity ) { put ( key , _str ) ; } else if ( value == double . negative_infinity ) { put ( key , _str ) ; } else { put ( key , double . tostring ( value ) ) ; } }	associates the specified double value with the specified key in this map.
public void test_fill fiif ( ) { float val = float . max_value ; float d [ ] = new float [ _num ] ; arrays . fill ( d , _num , d . length , val ) ; for ( int i = _num ; i < _num ; i ++ ) asserttrue ( _str , ! ( d [ i ] == val ) ) ; for ( int i = _num ; i < d . length ; i ++ ) asserttrue ( _str , d [ i ] == val ) ; try { arrays . fill ( d , _num , _num , val ) ; fail ( _str ) ; } catch ( illegalargumentexception e ) { } try { arrays . fill ( d , - _num , _num , val ) ; fail ( _str ) ; } catch ( arrayindexoutofboundsexception e ) { } try { arrays . fill ( d , _num , d . length + _num , val ) ; fail ( _str ) ; } catch ( arrayindexoutofboundsexception e ) { } }	java . util . arrays # fill ( float [ ] , int , int , float ).
public static long persiantojulian ( long year , int month , int day ) { return _num * ( ( ceil ( year - _num , _num ) + _num ) - _num ) + ( ( long ) math . floor ( ( _num * ( ceil ( year - _num , _num ) + _num ) - _num ) / _num ) ) + ( persiancalendarconstants . persian_epoch - _num ) + _num * ( ( long ) math . floor ( ( year - _num ) / _num ) ) + ( month < _num ? _num * month : _num * month + _num ) + day ; }	converts a provided persian ( shamsi ) date to the julian day number ( i.
@ override public void mousedragged ( mouseevent evt ) { int xtrans = _num ; int ytrans = _num ; if ( slider . getsnaptoticks ( ) ) { int pos = getlocationforvalue ( getsnappedvalue ( evt ) ) ; if ( pos > - _num ) { if ( slider . getorientation ( ) == jslider . horizontal ) { xtrans = pos - evt . getx ( ) + offset ; evt . translatepoint ( xtrans , _num ) ; } else { ytrans = pos - evt . gety ( ) + offset ; evt . translatepoint ( _num , ytrans ) ; } } } delegate . mousedragged ( evt ) ; evt . translatepoint ( xtrans , ytrans ) ; }	implements the actual ' snap while dragging ' behaviour.
@ override final node < k , v > find ( int h , object k ) { if ( k != null ) { for ( node < k , v > e = first ; e != null ; e = e . next ) { int s ; k ek ; if ( ( ( s = lockstate ) & ( waiter | writer ) ) != _num ) { if ( e . hash == h && ( ( ek = e . key ) == k || ( ek != null && k . equals ( ek ) ) ) ) return e ; } else if ( u . compareandswapint ( this , lockstate , s , s + reader ) ) { treenode < k , v > r , p ; try { p = ( ( r = root ) == null ? null : r . findtreenode ( h , k , null ) ) ; } finally { thread w ; int ls ; do { } while ( ! u . compareandswapint ( this , lockstate , ls = lockstate , ls - reader ) ) ; if ( ls == ( reader | waiter ) && ( w = waiter ) != null ) locksupport . unpark ( w ) ; } return p ; } } } return null ; }	returns matching node or null if none.
public void stopenumeration ( enumerationdeletioncontext aws ) { aws . computeenumerationrequest . enumerationaction = enumerationaction . stop ; handleenumerationrequestfordeletion ( aws ) ; }	signals enumeration stop to the aws enumeration adapter.
public static void dorestart ( context c ) { try { if ( c != null ) { packagemanager pm = c . getpackagemanager ( ) ; if ( pm != null ) { intent mstartactivity = pm . getlaunchintentforpackage ( c . getpackagename ( ) ) ; if ( mstartactivity != null ) { mstartactivity . addflags ( intent . flag_activity_clear_top ) ; int mpendingintentid = _num ; pendingintent mpendingintent = pendingintent . getactivity ( c , mpendingintentid , mstartactivity , pendingintent . flag_cancel_current ) ; alarmmanager mgr = ( alarmmanager ) c . getsystemservice ( context . alarm_service ) ; mgr . set ( alarmmanager . rtc , system . currenttimemillis ( ) + _num , mpendingintent ) ; system . exit ( _num ) ; } else { log . e ( _str , _str ) ; } } else { log . e ( _str , _str ) ; } } else { log . e ( _str , _str ) ; } } catch ( exception ex ) { log . e ( _str , _str ) ; } }	restarts the current application.
public collection < object > values ( ) { arraylist < object > answer = new arraylist < object > ( readmethods . size ( ) ) ; for ( iterator < object > iter = valueiterator ( ) ; iter . hasnext ( ) ; ) { answer . add ( iter . next ( ) ) ; } return collections . unmodifiablelist ( answer ) ; }	returns the values for the beanmap .
protected datetimedata parse ( string str ) throws schemadatetimeexception { datetimedata date = new datetimedata ( str , this ) ; int len = str . length ( ) ; int end = getyearmonth ( str , _num , len , date ) ; date . day = day ; parsetimezone ( str , end , len , date ) ; validatedatetime ( date ) ; saveunnormalized ( date ) ; if ( date . utc != _num && date . utc != _str ) { normalize ( date ) ; } date . position = _num ; return date ; }	parses , validates and computes normalized version of gyearmonth object.
public arrayval ( double [ ] values ) { this . array = new double [ values . length ] ; for ( int i = _num ; i < array . length ; i ++ ) { array [ i ] = values [ i ] ; } hashcode = arrays . hashcode ( array ) ; }	creates a new array of doubles.
public void addchild ( string child ) { if ( child == null ) { return ; } string childpath = path . endswith ( _str ) ? path + child : path + _str + child ; children . add ( new zknode ( childpath ) ) ; }	input is child name , not full path.
@ visiblefortesting public static boolean sendtotmaster ( string command , string topologyname , schedulerstatemanageradaptor statemanager , networkutils . tunnelconfig tunnelconfig ) { log . fine ( _str + topologyname ) ; topologymaster . tmasterlocation location = statemanager . gettmasterlocation ( topologyname ) ; if ( location == null ) { log . severe ( _str + topologyname ) ; return _bool ; } log . fine ( _str + topologyname ) ; string url = string . format ( _str , location . gethost ( ) , location . getcontrollerport ( ) , command , location . gettopologyid ( ) ) ; try { url endpoint = new url ( url ) ; log . fine ( _str + endpoint ) ; return sendgetrequest ( endpoint , command , tunnelconfig ) ; } catch ( malformedurlexception e ) { throw new runtimeexception ( _str + url , e ) ; } }	communicate with tmaster with command.
public static string fromdoc2string ( document doc ) throws exception { kxmlserializer serializer = new kxmlserializer ( ) ; bytearrayoutputstream bos = new bytearrayoutputstream ( ) ; dataoutputstream dos = new dataoutputstream ( bos ) ; try { serializer . setfeature ( _str , _bool ) ; serializer . setoutput ( dos , xformconstants . default_character_encoding ) ; doc . write ( serializer ) ; serializer . flush ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; return null ; } return new string ( bos . tobytearray ( ) , xformconstants . default_character_encoding ) ; }	converts an xml document to a string .
public int addorderterm ( genericvalue orderterm ) { orderterms . add ( orderterm ) ; return orderterms . indexof ( orderterm ) ; }	add an orderterm to the order.
public string tostring ( ) { stringbuilder stringbuilder = new stringbuilder ( ) ; for ( validationerrorobject error : errors ) { stringbuilder . append ( error . tostring ( ) ) ; } return stringbuilder . tostring ( ) ; }	a method that returns a string representation of a validationeventhandlerimpl object.
public static observablestringvalue decision ( observablebooleanvalue condition , observablestringvalue iftrue , observablestringvalue iffalse ) { stringproperty ret = new simplestringproperty ( ) ; condition . addlistener ( null ) ; iftrue . addlistener ( null ) ; iffalse . addlistener ( null ) ; ret . set ( condition . get ( ) ? iftrue . get ( ) : iffalse . get ( ) ) ; return ret ; }	returns a new observable string which contains either the contents of iftrue , or iffalse , depending on the condition.
public static final boolean readfromstream ( inputstream in , byte [ ] buf , int offset , int len ) throws ioexception { int totalbytesread = _num ; while ( totalbytesread < len ) { int bytesread = in . read ( buf , offset + totalbytesread , len - totalbytesread ) ; if ( bytesread < _num ) { return _bool ; } totalbytesread += bytesread ; } return _bool ; }	read from input stream and fill the given buffer from the given offset up to length len .
public static field findstaticfield ( class < ? > type , string name ) throws nosuchfieldexception { field field = findfield ( type , name ) ; if ( ! modifier . isstatic ( field . getmodifiers ( ) ) ) { throw new nosuchfieldexception ( _str + name + _str ) ; } return field ; }	finds public static field that is declared in public class .
public void newbraces ( editorstate editorstate , char ch ) { string casname = argumenthelper . readcharacters ( editorstate ) ; if ( ch == function_open_key && metamodel . isgeneral ( casname ) ) { delcharacters ( editorstate , casname . length ( ) ) ; newfunction ( editorstate , casname ) ; } else if ( ch == function_open_key && metamodel . isfunction ( casname ) ) { delcharacters ( editorstate , casname . length ( ) ) ; newfunction ( editorstate , casname ) ; } else { newarray ( editorstate , _num , ch ) ; } }	insert braces ( ) , [ ] , { } , " " .
@ override public xid [ ] recover ( int flag ) throws xaexception { debugcodecall ( _str , quoteflags ( flag ) ) ; checkopen ( ) ; try ( statement stat = physicalconn . createstatement ( ) ) { resultset rs = stat . executequery ( _str + _str ) ; arraylist < xid > list = new . arraylist ( ) ; while ( rs . next ( ) ) { string tid = rs . getstring ( _str ) ; int id = getnextid ( xid ) ; xid xid = new jdbcxid ( factory , id , tid ) ; list . add ( xid ) ; } rs . close ( ) ; xid [ ] result = new xid [ list . size ( ) ] ; list . toarray ( result ) ; if ( list . size ( ) > _num ) { prepared = _bool ; } return result ; } catch ( sqlexception e ) { xaexception xa = new xaexception ( xaexception . xaer_rmerr ) ; xa . initcause ( e ) ; throw xa ; } }	get the list of prepared transaction branches.
public void bind ( texture texture ) { faces . foreach ( null ) ; }	binds all the faces and all child models with this texture .
public final void clearpassword ( ) { arrays . fill ( password , _str ) ; password = null ; }	clears the password by overwriting it .
private static int newchararray ( jnienvironment env , int length ) { if ( tracejni ) vm . syswrite ( _str ) ; runtimeentrypoints . checkjnicountdowntogc ( ) ; try { char [ ] newarray = new char [ length ] ; return env . pushjniref ( newarray ) ; } catch ( throwable unexpected ) { if ( tracejni ) unexpected . printstacktrace ( system . err ) ; env . recordexception ( unexpected ) ; return _num ; } }	newchararray : create a new char array.
private void initquadprogram ( ) { gluseprogram ( quadprogram ) ; int texuniform = glgetuniformlocation ( quadprogram , _str ) ; gluniform1i ( texuniform , _num ) ; gluseprogram ( _num ) ; }	initialize the full - screen - quad program .
public void put ( e e ) throws interruptedexception { if ( e == null ) throw new nullpointerexception ( ) ; int c = - _num ; node < e > node = new node < e > ( e ) ; final reentrantlock putlock = this . putlock ; final atomicinteger count = this . count ; putlock . lockinterruptibly ( ) ; try { while ( count . get ( ) == capacity ) { notfull . await ( ) ; } enqueue ( node ) ; c = count . getandincrement ( ) ; if ( c + _num < capacity ) notfull . signal ( ) ; } finally { putlock . unlock ( ) ; } if ( c == _num ) signalnotempty ( ) ; }	inserts the specified element at the tail of this queue , waiting if necessary for space to become available .
public static boolean logfilezipped ( string file ) { return file . endswith ( _str ) || file . endswith ( _str ) || file . endswith ( _str ) ; }	check for a compressed file extension - for now ,.
private void validatehaschecksumfile ( file archivefile ) throws invalidarchiveupdateexception { try { resolvechecksumfile ( extractfiletodirectory ( archivefile , checksums_file_in_openidm ) ) ; } catch ( exception e ) { throw new invalidarchiveupdateexception ( archivefile . getname ( ) , _str + archivefile . getname ( ) + _str , e ) ; } }	check if the checksums file in the zip file is present and can be resolved .
protected string ratsproblem ( ) { final string text = _str + _str ; return ( text ) ; }	red alert ! rats in the ados city !.
public class < ? > lookupentityclass ( class < ? > objclass ) { for ( class < ? > cls = objclass ; cls != null ; cls = cls . getsuperclass ( ) ) { if ( entitybindings . containskey ( cls ) || cls . isannotationpresent ( entity . class ) ) { return cls ; } } throw new illegalargumentexception ( _str + objclass ) ; }	follow for this class or super - class for entity annotation .
private boolean iswhitespace ( int position ) { if ( _len >= _num && position >= _len ) { return _bool ; } return character . iswhitespace ( _working [ position ] ) ; }	checks if character at specified position is whitespace .
private void collectwrapperclasses ( classloader cl , string pkg , file file ) throws exception { for ( file f : file . listfiles ( ) ) { if ( f . isdirectory ( ) ) { collectwrapperclasses ( cl , pkg + f . getname ( ) + _str , f ) ; } else { addwrapperclasstowrapperclasseslist ( cl , pkg , f ) ; } } }	walk package tree for collecting wrapper classes .
public void clearimages ( ) { chunks . clear ( ) ; markers . clear ( ) ; redraw ( _bool ) ; shift_x = _num ; shift_y = _num ; zoom_level_pos = _num ; zoom_level = _num ; }	clears all the images in the preview .
public void test_fill jiij ( ) { long d [ ] = new long [ _num ] ; arrays . fill ( d , _num , d . length , long . max_value ) ; for ( int i = _num ; i < _num ; i ++ ) asserttrue ( _str , ! ( d [ i ] == long . max_value ) ) ; for ( int i = _num ; i < d . length ; i ++ ) asserttrue ( _str , d [ i ] == long . max_value ) ; try { arrays . fill ( d , _num , _num , long . min_value ) ; fail ( _str ) ; } catch ( illegalargumentexception e ) { } try { arrays . fill ( d , - _num , _num , long . max_value ) ; fail ( _str ) ; } catch ( arrayindexoutofboundsexception e ) { } try { arrays . fill ( d , _num , d . length + _num , long . max_value ) ; fail ( _str ) ; } catch ( arrayindexoutofboundsexception e ) { } }	java . util . arrays # fill ( long [ ] , int , int , long ).
private static void addcomponent ( final jpanel panel , final component component , final string description , final string hint ) { final jpanel settingpanel = new jpanel ( new borderlayout ( ) ) ; settingpanel . setborder ( standard_empty_border ) ; settingpanel . add ( new jlabel ( description ) , borderlayout . center ) ; final jpanel innerpanel = new jpanel ( new borderlayout ( ) ) ; innerpanel . add ( component , borderlayout . center ) ; final jhinticon hintpopup = new jhinticon ( hint ) ; hintpopup . setborder ( new emptyborder ( _num , _num , _num , _num ) ) ; innerpanel . add ( hintpopup , borderlayout . east ) ; settingpanel . add ( innerpanel , borderlayout . east ) ; panel . add ( settingpanel ) ; }	adds a component that is used to configure a setting .
public reversedlinesfilereader ( final file file , final int blocksize , final string encoding ) throws ioexception { this ( file , blocksize , charsets . tocharset ( encoding ) ) ; }	creates a reversedlinesfilereader with the given block size and encoding .
private void onconnect ( ) { connectionstate = connectionstate . connected ; checkforupdatedflight = _bool ; subscribe ( string . format ( trafficalertchannel , flightid ) ) ; subscribe ( string . format ( situationalawarenesschannel , flightid ) ) ; }	when connected , subscribe to the necessary channels to get properly notified.
public static double cdf ( double x , double sigma ) { if ( x <= _num ) { return _num ; } final double xs = x / sigma ; return _num - math . exp ( - _num * xs * xs ) ; }	cdf of rayleigh distribution.
public double gaussianshortfall ( double target ) { final cumulativenormaldistribution gintegral = new cumulativenormaldistribution ( mean ( ) , standarddeviation ( ) ) ; return gintegral . op ( target ) ; }	gaussian - assumption shortfall ( observations below target ).
@ override public int read ( char ch [ ] , int offset , int length ) throws ioexception { int bytelength = length << _num ; if ( bytelength > fbuffer . length ) { bytelength = fbuffer . length ; } int bytecount = finputstream . read ( fbuffer , _num , bytelength ) ; if ( bytecount == - _num ) { return - _num ; } if ( ( bytecount & _num ) != _num ) { int b = finputstream . read ( ) ; if ( b == - _num ) { expectedtwobytes ( ) ; } fbuffer [ bytecount ++ ] = ( byte ) b ; } final int charcount = bytecount > > _num ; if ( fisbigendian ) { processbe ( ch , offset , charcount ) ; } else { processle ( ch , offset , charcount ) ; } return charcount ; }	read characters into a portion of an array.
public static void endwrapper ( writer writer ) throws ioexception { writer . write ( _str ) ; writer . write ( _str ) ; writer . write ( _str ) ; writer . write ( _str ) ; writer . write ( _str ) ; }	writes the ending of the wrapper function for a js module .
protected document createconfigurationdocument ( avlist params ) { document doc = super . createconfigurationdocument ( params ) ; if ( doc == null || doc . getdocumentelement ( ) == null ) return doc ; dataconfigurationutils . createwmslayerconfigelements ( params , doc . getdocumentelement ( ) ) ; return doc ; }	appends wms basic elevation model configuration elements to the superclass configuration document .
public void registercallback ( string challenge , challengecallbackplugin plugin , httpmessage attack ) { cleanexpiredcallbacks ( ) ; regcallbacks . put ( challenge , new registeredcallback ( plugin , attack ) ) ; }	registers a new zap api challenge .
public static double min ( array array ) throws pageexception { if ( array . getdimension ( ) > _num ) throw new expressionexception ( _str ) ; if ( array . size ( ) == _num ) return _num ; double rtn = _todoublevalue ( array , _num ) ; int len = array . size ( ) ; try { for ( int i = _num ; i <= len ; i ++ ) { double v = _todoublevalue ( array , i ) ; if ( rtn > v ) rtn = v ; } } catch ( pageexception e ) { throw new expressionexception ( _str + e . getmessage ( ) ) ; } return rtn ; }	the smallest value , of all values inside the array , only work when all values are numeric.
public static byte [ ] writetoarray ( nsobject root ) throws ioexception { bytearrayoutputstream bout = new bytearrayoutputstream ( ) ; write ( bout , root ) ; return bout . tobytearray ( ) ; }	writes a binary plist serialization of the given object as the root into a byte array .
private static void loadlibraryresource ( string resourcesubdirectoryname , string libraryname , string tempsubdirectoryname , string ... dependentlibrarynames ) throws throwable { for ( string dependentlibraryname : dependentlibrarynames ) { logger . log ( level , _str + libraryname + _str + dependentlibraryname ) ; string dependentresourcesubdirectoryname = resourcesubdirectoryname + _str + osstring ( ) + _str + archstring ( ) ; string dependentlibrarytempsubdirectoryname = libraryname + _str + file . separator + osstring ( ) + file . separator + archstring ( ) + file . separator ; loadlibraryresource ( dependentresourcesubdirectoryname , dependentlibraryname , dependentlibrarytempsubdirectoryname ) ; } string libraryfilename = createlibraryfilename ( libraryname ) ; file librarytempfile = createtempfile ( tempsubdirectoryname , libraryfilename ) ; if ( ! librarytempfile . exists ( ) ) { string libraryresourcename = resourcesubdirectoryname + _str + libraryfilename ; logger . log ( level , _str + libraryresourcename ) ; logger . log ( level , _str + librarytempfile ) ; writeresourcetofile ( libraryresourcename , librarytempfile ) ; } logger . log ( level , _str + librarytempfile ) ; system . load ( librarytempfile . tostring ( ) ) ; logger . log ( level , _str + librarytempfile + _str ) ; }	load the library with the given name from a resource .
private jobdefinition createjobdefinition ( ) throws exception { namespacedaotesthelper . createnamespaceentity ( test_activiti_namespace_cd ) ; jobdefinitioncreaterequest request = jobdefinitionservicetesthelper . createjobdefinitioncreaterequest ( ) ; jobdefinition jobdefinition = jobdefinitionservice . createjobdefinition ( request , _bool ) ; validatejobdefinition ( jobdefinition ) ; return jobdefinition ; }	creates a new standard job definition .
private websocketinputstream openinputstream ( socket socket ) throws websocketexception { try { return new websocketinputstream ( new bufferedinputstream ( socket . getinputstream ( ) ) ) ; } catch ( ioexception e ) { throw new websocketexception ( websocketerror . socket_input_stream_failure , _str + e . getmessage ( ) , e ) ; } }	open the input stream of the websocket connection.
@ override protected void drawfirstpassshape ( graphics2d g2 , int pass , int series , int item , shape shape ) { if ( isshadowpass ( pass ) ) { if ( getwallpaint ( ) != null ) { g2 . setstroke ( getitemstroke ( series , item ) ) ; g2 . setpaint ( getwallpaint ( ) ) ; g2 . translate ( getxoffset ( ) , getyoffset ( ) ) ; g2 . draw ( shape ) ; g2 . translate ( - getxoffset ( ) , - getyoffset ( ) ) ; } } else { super . drawfirstpassshape ( g2 , pass , series , item , shape ) ; } }	overrides the method in the subclass to draw a shadow in the first pass .
public static double asdouble ( string str , double def ) { try { return double . parsedouble ( str ) ; } catch ( numberformatexception e ) { return def ; } }	parse string to double , if string can ' t be parsed to double , then it will return given default value .
public jmenu createhelpmenu ( ) { showhelpaction helpaction = new showhelpaction ( _str ) ; jmenu helpmenu = new jmenu ( _str ) ; helpmenu . add ( helpaction ) ; return helpmenu ; }	create and return a new help menu for this network panel .
public static void expanddigits ( string numberstring , wordrelation wordrelation , item tokenitem ) { int numberdigits = numberstring . length ( ) ; for ( int i = _num ; i < numberdigits ; i ++ ) { char digit = numberstring . charat ( i ) ; if ( isdigit ( digit ) ) { wordrelation . addword ( tokenitem , digit2num [ numberstring . charat ( i ) - _str ] ) ; } else { wordrelation . addword ( tokenitem , _str ) ; } } }	expands given token to list of words pronouncing it as digits.
public string longestmatch ( string input ) { trienode node = root ; string result = null ; for ( int i = input . length ( ) - _num ; i >= _num ; i -- ) { node = node . getchild ( input . charat ( i ) ) ; if ( node == null ) break ; if ( node . isterminal ( ) ) result = input . substring ( i ) ; } return result ; }	returns the longest suffix of < code > input < code > that is matched , or < code > null < code > if no match exists .
public void testmapsubclass ( ) throws exception { objectmapper mapper = new objectmapper ( ) ; mapsubclass result = mapper . readvalue ( _str , mapsubclass . class ) ; assertequals ( _num , result . size ( ) ) ; object value = result . get ( _str ) ; assertequals ( booleanwrapper . class , value . getclass ( ) ) ; booleanwrapper bw = ( booleanwrapper ) value ; assertequals ( boolean . true , bw . b ) ; }	verifying that sub - classing works ok wrt generics information.
@ override public void removepropertychangelistener ( propertychangelistener pcl ) { m_pcs . removepropertychangelistener ( pcl ) ; }	remove a property change listener.
public void addontagclicklistener ( tagsclicklistener listener ) { if ( clicklisteners == null ) { clicklisteners = new arraylist < > ( ) ; } clicklisteners . add ( listener ) ; }	adding single item click listener.
public void removealltrackingicons ( ) { if ( trackingicons != null && trackingicons . size ( ) > _num ) { trackingicons . clear ( ) ; repaint ( ) ; } }	removes all tracking icons .
private void readreference ( ) { arraylist < string > v_value = new arraylist < string > ( ) ; arraylist < string > v_name = new arraylist < string > ( ) ; arraylist < string > v_description = new arraylist < string > ( ) ; documentengine . readreferencelist ( v_value , v_name , v_description ) ; int size = v_value . size ( ) ; s_value = new string [ size ] ; s_name = new string [ size ] ; s_description = new string [ size ] ; for ( int i = _num ; i < size ; i ++ ) { s_value [ i ] = ( string ) v_value . get ( i ) ; s_name [ i ] = ( string ) v_name . get ( i ) ; s_description [ i ] = ( string ) v_description . get ( i ) ; } }	fill vector with docaction ref_list ( 135 ) values.
protected void assertroundtrip ( tps expected ) throws ioexception , classnotfoundexception { final byte [ ] serialized ; { bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; objectoutputstream oos = new objectoutputstream ( baos ) ; expected . writeexternal ( oos ) ; oos . flush ( ) ; serialized = baos . tobytearray ( ) ; } final tps actual ; { actual = new tps ( ) ; bytearrayinputstream bais = new bytearrayinputstream ( serialized ) ; objectinputstream ois = new objectinputstream ( bais ) ; actual . readexternal ( ois ) ; } assertequals ( expected , actual ) ; }	test helper for ( de - ) serialization tests .
public static double calculatecontrastratio ( double lum1 , double lum2 ) { if ( ( lum1 < _num ) || ( lum2 < _num ) ) { throw new illegalargumentexception ( _str ) ; } return ( math . max ( lum1 , lum2 ) + _num ) / ( math . min ( lum1 , lum2 ) + _num ) ; }	calculates the contrast ratio of two order - independent luminance values.
protected void reset ( ) throws xniexception { int count = fcomponents . size ( ) ; for ( int i = _num ; i < count ; i ++ ) { xmlcomponent c = ( xmlcomponent ) fcomponents . get ( i ) ; c . reset ( this ) ; } }	reset all xml 1 . 0 components before parsing and namespace context.
public synchronized void unregister ( string name ) { streamscope < ? > streamscope = bynamemap . remove ( name ) ; if ( streamscope == null ) return ; list < string > names = bystreamscopemap . get ( streamscope ) ; names . remove ( name ) ; if ( names . isempty ( ) ) bystreamscopemap . remove ( streamscope ) ; }	remove the specific name registration.
private string expandaffix ( string pattern , stringbuffer buffer ) { buffer . setlength ( _num ) ; for ( int i = _num ; i < pattern . length ( ) ; ) { char c = pattern . charat ( i ++ ) ; if ( c == quote ) { c = pattern . charat ( i ++ ) ; switch ( c ) { case currency_sign : if ( i < pattern . length ( ) && pattern . charat ( i ) == currency_sign ) { ++ i ; buffer . append ( symbols . getinternationalcurrencysymbol ( ) ) ; } else { buffer . append ( symbols . getcurrencysymbol ( ) ) ; } continue ; case pattern_percent : c = symbols . getpercent ( ) ; break ; case pattern_per_mille : c = symbols . getpermill ( ) ; break ; case pattern_minus : c = symbols . getminussign ( ) ; break ; } } buffer . append ( c ) ; } return buffer . tostring ( ) ; }	expand an affix pattern into an affix string.
public static queryfunctions extractfunctions ( string [ ] filterqueries ) { final queryfunctions result = new queryfunctions ( ) ; if ( isempty ( filterqueries ) ) { return result ; } string [ ] arguments = new string [ _num ] ; for ( string unmodifiedanalysis : filterqueries ) { string function = extractfunction ( unmodifiedanalysis ) ; string [ ] functions ; if ( function . contains ( function_argument_splitter ) ) { functions = function . split ( function_argument_splitter ) ; } else { functions = new string [ ] { function } ; } for ( string subfunction : functions ) { if ( subfunction . contains ( aggregation_argument_delimiter ) ) { arguments = extractaggregationparameter ( subfunction ) ; subfunction = subfunction . substring ( _num , subfunction . indexof ( aggregation_argument_delimiter ) ) ; } functiontype type = functiontype . valueof ( subfunction . touppercase ( ) ) ; addfunction ( result , type , arguments ) ; } } return result ; }	analyzes the filter queries and parses them for chronix fucntions.
protected final void firevetoablechange ( string propertyname , int oldvalue , int newvalue ) throws propertyvetoexception { vetoablechangesupport avetosupport = this . vetosupport ; if ( avetosupport == null ) { return ; } avetosupport . firevetoablechange ( propertyname , integer . valueof ( oldvalue ) , integer . valueof ( newvalue ) ) ; }	support for reporting changes for constrained integer properties.
protected boolean isvalidclassname ( string classname ) { return ( classname . indexof ( _str ) == - _num ) ; }	checks whether the classname is a valid one , i.
public static int number ( ) { return _all . size ( ) ; }	total number of non - terminals .
public string generateinvertedstring ( ) { return string . format ( _str , _num & generateinverted ( ) ) ; }	gets the string equivalent of the generated shade.
@ notnull public string extractpresentableurl ( @ notnull string path ) { return path . replace ( _str , file . separatorchar ) ; }	fetches presentable url of file with the given path in this file system .
public string convertswftohtml ( url in ) throws exception { httpurlconnection conn = ( httpurlconnection ) in . openconnection ( ) ; conn . setallowuserinteraction ( _bool ) ; conn . setrequestproperty ( _str , _str ) ; conn . setinstancefollowredirects ( _bool ) ; conn . connect ( ) ; return convertswftohtml ( conn . getinputstream ( ) ) ; }	description of the method.
private void initprogram ( ) { gluseprogram ( this . program ) ; viewprojmatrixuniform = glgetuniformlocation ( this . program , _str ) ; gluseprogram ( _num ) ; }	initialize the shader program .
private boolean isnegative ( final string input ) { requirenonnull ( input ) ; for ( final string negativestring : negativestrings ) { if ( input . equalsignorecase ( negativestring ) ) { return _bool ; } } return _bool ; }	checks if a user ' s input matches one of the negative strings .
@ override protected void senddispositionheader ( final outputstream out ) throws ioexception { log . trace ( _str ) ; super . senddispositionheader ( out ) ; final string filename = source . getfilename ( ) ; if ( filename != null ) { out . write ( file_name_bytes ) ; out . write ( quote_bytes ) ; out . write ( encodingutil . getasciibytes ( filename ) ) ; out . write ( quote_bytes ) ; } }	write the disposition header to the output stream.
private list < map < string , object > > prepareresultsfordisplay ( collection < scoredresult > scoredresults ) { arraylist < map < string , object > > output = new arraylist < map < string , object > > ( scoredresults . size ( ) ) ; for ( scoredresult result : scoredresults ) { map < string , object > resultmap = new hashmap < string , object > ( ) ; if ( result . track != null ) { preparetrackfordisplay ( result . track , resultmap ) ; } else { preparemarkerfordisplay ( result . waypoint , resultmap ) ; } output . add ( resultmap ) ; } return output ; }	prepares the result for display .
public long copy ( final inputstream from , final outputstream to ) throws ioexception { long count = _num ; byte [ ] tmp = mbytearraypool . get ( mtempbufsize ) ; try { while ( _bool ) { int read = from . read ( tmp , _num , mtempbufsize ) ; if ( read == - _num ) { return count ; } to . write ( tmp , _num , read ) ; count += read ; } } finally { mbytearraypool . release ( tmp ) ; } }	copy all bytes from inputstream to outputstream .
private static element infoaselement ( document doc , libraryinfo info ) { element libraryelement = doc . createelement ( _str ) ; libraryelement . setattribute ( _str , info . getversion ( ) ) ; appendpathelements ( doc , _str , libraryelement , info . getbootpath ( ) ) ; appendpathelements ( doc , _str , libraryelement , info . getextensiondirs ( ) ) ; appendpathelements ( doc , _str , libraryelement , info . getendorseddirs ( ) ) ; return libraryelement ; }	creates an xml element for the given info .
public void addchoicevalue ( string value , string i18nkey ) throws smsexception , ssoexception { map choicevalues = as . getchoicevaluesmap ( ) ; choicevalues . put ( value , i18nkey ) ; updatechoicevalues ( choicevalues ) ; }	adds a choice value and its i18n key to the existing set of choice values .
private void notifychange ( int previous , int current ) { if ( monvaluechangelistener != null ) { monvaluechangelistener . onvaluechange ( this , previous , mvalue ) ; } }	notifies the listener , if registered , of a change of the value of this numberpicker .
public void loadlibrary ( string libname ) { loadlibrary0 ( libname , rvmclass . getclassloaderfromstackframe ( _num ) , _bool ) ; }	loads and links the library specified by the argument .
public void handletbldataactionhrefrequest ( requestinvocationevent event ) { string idreponame = hextostring ( ( string ) getdisplayfieldvalue ( tbl_data_action_href ) ) ; string currealm = ( string ) getpagesessionattribute ( amadminconstants . current_realm ) ; try { idrepomodel model = ( idrepomodel ) getmodel ( ) ; setpagesessionattribute ( idrepoopviewbeanbase . idrepo_name , idreponame ) ; setpagesessionattribute ( idrepoopviewbeanbase . idrepo_type , model . getidrepotype ( currealm , idreponame ) ) ; idrepoeditviewbean vb = ( idrepoeditviewbean ) getviewbean ( idrepoeditviewbean . class ) ; unlockpagetrail ( ) ; passpgsessionmap ( vb ) ; vb . forwardto ( getrequestcontext ( ) ) ; } catch ( amconsoleexception e ) { setinlinealertmessage ( ccalert . type_error , _str , e . getmessage ( ) ) ; forwardto ( ) ; } }	forwards request to edit id repo view bean .
@ override public void loadheightmap ( raster raster ) throws ioexception { int stripheight = math . min ( strip_rows , rasterlength ) ; int stripwidth = rasterwidth * samplesperpixel ; int stripsize = stripwidth * stripheight * bytespersample ; int numstrips = ( int ) math . ceil ( ( double ) rasterlength / stripheight ) ; if ( stripsize > integer . max_value ) { throw new illegalargumentexception ( _str + integer . max_value + _str ) ; } if ( ( minimum == null ) || ( maximum == null ) ) { computeminmaxfromstrip ( datatype , numstrips , stripsize , stripwidth , stripheight ) ; } loadfromstrip ( datatype , numstrips , stripsize , stripwidth , stripheight , raster , _bool ) ; }	load data from height map file into a raster , converting data to float .
public void addfooter ( @ nonnull view view ) { if ( view == null ) { throw new illegalargumentexception ( _str ) ; } mfooters . add ( view ) ; }	adds a footer view .
public static pair < int [ ] , double [ ] > convert ( set < feature > features , lexicon lexicon , boolean trainingmode ) { tintdoublehashmap fmap = new tintdoublehashmap ( features . size ( ) ) ; for ( feature feature : features ) { final int featureid = featureutilities . getfeatureid ( lexicon , trainingmode , feature ) ; if ( featureid < _num ) continue ; double value = feature . getvalue ( ) + fmap . get ( featureid ) ; fmap . put ( featureid , value ) ; } int [ ] idsoriginal = fmap . keys ( ) ; int [ ] ids = new int [ idsoriginal . length ] ; system . arraycopy ( idsoriginal , _num , ids , _num , ids . length ) ; arrays . sort ( ids ) ; double [ ] vals = new double [ fmap . size ( ) ] ; int count = _num ; for ( int key : ids ) { vals [ count ++ ] = fmap . get ( key ) ; } return new pair < > ( ids , vals ) ; }	convert a feature set into a pair of arrays of integers and doubles by looking up the feature name in the provided lexicon .
private static string cretexmltotalcount ( int firstrow , int numpfis , int numpjur , int rdefault , int maxresults ) { string result = null ; document document = documenthelper . createdocument ( ) ; element root = document . addelement ( personkeys . xml_personas_text ) ; root . addattribute ( personkeys . xml_inicio_text , integer . tostring ( firstrow ) ) ; if ( ( firstrow + rdefault ) > ( numpfis + numpjur ) ) { root . addattribute ( personkeys . xml_fin_text , integer . tostring ( numpfis + numpjur ) ) ; } else { root . addattribute ( personkeys . xml_fin_text , integer . tostring ( firstrow + rdefault ) ) ; } root . addattribute ( personkeys . xml_total_text , integer . tostring ( numpfis + numpjur ) ) ; root . addattribute ( personkeys . xml_rango_text , integer . tostring ( rdefault ) ) ; root . addattribute ( personkeys . xml_result_max_text , integer . tostring ( maxresults ) ) ; result = document . asxml ( ) ; return result ; }	author : 66575267 - gabriel saiz metodo para crear un xml que indique el numero total de resultados encontrados .
public string tofeaturestring ( featurevector fv ) { if ( numbytefeatures != fv . getnumberofbytefeatures ( ) || numshortfeatures != fv . getnumberofshortfeatures ( ) || numcontinuousfeatures != fv . getnumberofcontinuousfeatures ( ) ) throw new illegalargumentexception ( _str + fv + _str ) ; stringbuilder buf = new stringbuilder ( ) ; for ( int i = _num ; i < numbytefeatures ; i ++ ) { if ( buf . length ( ) > _num ) buf . append ( _str ) ; buf . append ( getfeaturevalueasstring ( i , fv . getbytefeature ( i ) ) ) ; } for ( int i = numbytefeatures ; i < numbytefeatures + numshortfeatures ; i ++ ) { if ( buf . length ( ) > _num ) buf . append ( _str ) ; buf . append ( getfeaturevalueasstring ( i , fv . getshortfeature ( i ) ) ) ; } for ( int i = numbytefeatures + numshortfeatures ; i < numbytefeatures + numshortfeatures + numcontinuousfeatures ; i ++ ) { if ( buf . length ( ) > _num ) buf . append ( _str ) ; buf . append ( fv . getcontinuousfeature ( i ) ) ; } return buf . tostring ( ) ; }	convert a feature vector into a string representation .
protected void sortpopulation ( ) { if ( properties . shuffle_goals ) randomness . shuffle ( population ) ; if ( ismaximizationfunction ( ) ) { collections . sort ( population , collections . reverseorder ( ) ) ; } else { collections . sort ( population ) ; } }	sort the population by fitness warn : used only with singular objective algorithms , multi - objective algorithms should implement their own ' sort '.
public void clean ( ) { chronofullrevision cfr = firstcfr ; totalsize = size ; while ( cfr != null ) { totalsize += cfr . size ( ) ; cfr = cfr . getnext ( ) ; } if ( totalsize < max_storage_size ) { return ; } cfr = firstcfr ; while ( cfr != null ) { totalsize += cfr . clean ( revisionindex , _num ) ; cfr = cfr . getnext ( ) ; } chronostorageblock block ; while ( last != null && totalsize >= max_storage_size ) { block = last . getindexprev ( ) ; if ( storage . remove ( last . getrevisionindex ( ) ) == null ) { throw new runtimeexception ( _str ) ; } totalsize -= last . length ( ) ; size += last . length ( ) ; if ( block != null ) { block . setindexnext ( null ) ; } last . setindexprev ( null ) ; cfr = last . getchronofullrevision ( ) ; totalsize += cfr . size ( ) - cfr . clean ( revisionindex , last . getrevisionindex ( ) ) ; if ( last == first ) { first = null ; } last = block ; } system . gc ( ) ; }	reduces the amount of used storage by discarding chrono storage blocks .
public static number plus ( character left , character right ) { return plus ( integer . valueof ( left ) , right ) ; }	add one character to another.
boolean containrelaystate ( string relaystate ) { return relaystatemap . containskey ( relaystate ) ; }	returns true if the specified relay state is one of the keys in relaystatemap , false otherwise .
public void localsearchstarted ( ) { starttime = system . currenttimemillis ( ) ; endtime = starttime + properties . local_search_budget * _num ; tests = _num ; suites = _num ; fitnessevaluations = _num ; executedstart = maxstatementsstoppingcondition . getnumexecutedstatements ( ) ; }	indicates that the application of ls to the current population has started .
public synchronized int write ( inputstream in ) throws ioexception { int readcount = _num ; int inbufferpos = count - filledbuffersum ; int n = in . read ( currentbuffer , inbufferpos , currentbuffer . length - inbufferpos ) ; while ( n != - _num ) { readcount += n ; inbufferpos += n ; count += n ; if ( inbufferpos == currentbuffer . length ) { neednewbuffer ( currentbuffer . length ) ; inbufferpos = _num ; } n = in . read ( currentbuffer , inbufferpos , currentbuffer . length - inbufferpos ) ; } return readcount ; }	writes the entire contents of the specified input stream to this byte stream.
public static double normalizeradians ( double r ) { if ( r < _num && r >= - two_pi ) return r + two_pi ; if ( r >= two_pi && r < four_pi ) return r - two_pi ; if ( r >= _num && r < two_pi ) return r ; r -= two_pi * math . floor ( r * two_pi_inverse ) ; if ( r < _num ) r += two_pi ; return r ; }	reduce an angle in radians to the range ( 0 - 2 pi ) .
public static tetradmatrix convertcovtocorr ( tetradmatrix m ) { for ( int i = _num ; i < m . rows ( ) ; i ++ ) { for ( int j = _num ; j < m . columns ( ) ; j ++ ) { if ( double . isnan ( m . get ( i , j ) ) ) { throw new illegalargumentexception ( _str ) ; } } } return correlation ( m ) ; }	converts a covariance matrix to a correlation matrix in place ; the same matrix is returned for convenience , but m is modified in the process .
private byte [ ] ungzip ( byte [ ] body ) { bytearrayinputstream bytein = new bytearrayinputstream ( body ) ; try ( gzipinputstream gzin = new gzipinputstream ( bytein ) ; bytearrayoutputstream byteout = new bytearrayoutputstream ( ) ) { int res = _num ; byte buf [ ] = new byte [ _num ] ; while ( res >= _num ) { res = gzin . read ( buf , _num , buf . length ) ; if ( res > _num ) { byteout . write ( buf , _num , res ) ; } } byte uncompressed [ ] = byteout . tobytearray ( ) ; return uncompressed ; } catch ( ioexception e ) { } return null ; }	decompresses using gzip algorithm .
private boolean selectid ( int nodeid , boolean show ) { if ( m_root == null ) return _bool ; log . config ( _str + nodeid + _str + show + _str + m_root ) ; mtreenode node = m_root . findnode ( nodeid ) ; if ( node != null ) { treepath treepath = new treepath ( node . getpath ( ) ) ; log . config ( _str + node + _str + treepath . tostring ( ) ) ; tree . setselectionpath ( treepath ) ; if ( show ) { tree . makevisible ( treepath ) ; tree . scrollpathtovisible ( treepath ) ; } return _bool ; } log . info ( _str + nodeid ) ; return _bool ; }	select id in tree.
protected final boolean isliststate ( ) { return statetexttypes . charat ( state ) == _str ; }	checks if the current state is marked as a list state .
private static class < ? extends activity > guesserroractivityclass ( context context ) { class < ? extends activity > resolvedactivityclass ; resolvedactivityclass = customactivityoncrash . geterroractivityclasswithintentfilter ( context ) ; if ( resolvedactivityclass == null ) { resolvedactivityclass = defaulterroractivity . class ; } return resolvedactivityclass ; }	internal method used to guess which error activity must be called when the app crashes.
public void loadglyphs ( string chars ) throws noglyphexception { char [ ] chs = chars . tochararray ( ) ; for ( int i = _num ; i < chs . length ; i ++ ) { getglyph ( chs [ i ] , null ) ; } }	load the glyphs for the characters in the given string from the fontdefinition into this font .
private void initquestandaddtoworld ( final iquest quest ) { logger . info ( _str + quest . getname ( ) ) ; quest . addtoworld ( ) ; quests . add ( quest ) ; }	adds a quest to the world.
public static movecommand [ ] values ( int f , gameoptions opts , boolean forwardini ) { boolean manualshutdown = _bool , selfdestruct = _bool ; if ( opts != null ) { manualshutdown = opts . booleanoption ( _str ) ; selfdestruct = opts . booleanoption ( _str ) ; } arraylist < movecommand > flaggedcmds = new arraylist < movecommand > ( ) ; for ( movecommand cmd : movecommand . values ( ) ) { if ( ( cmd == move_shutdown || cmd == move_startup ) && ! manualshutdown ) { continue ; } if ( cmd == move_self_destruct && ! selfdestruct ) { continue ; } if ( cmd == move_forward_ini && ! forwardini ) { continue ; } if ( ( cmd . flag & f ) == f ) { flaggedcmds . add ( cmd ) ; } } return flaggedcmds . toarray ( new movecommand [ _num ] ) ; }	return a list of valid commands for the given parameters .
public boolean isldap ( ) { string host = getldaphost ( ) ; if ( host == null || host . length ( ) == _num ) return _bool ; string domain = getldapdomain ( ) ; return domain != null && domain . length ( ) > _num ; }	is ldap authentification defined.
public void shedcache ( ) { connection [ ] conn ; synchronized ( freelist ) { conn = freelist . toarray ( new connection [ freelist . size ( ) ] ) ; freelist . clear ( ) ; } for ( int i = conn . length ; -- i >= _num ; ) { connection c = conn [ i ] ; conn [ i ] = null ; try { c . close ( ) ; } catch ( java . io . ioexception e ) { } } }	closes all the connections in the cache , whether timed out or not .
public static byte [ ] hash ( inputstream in ) throws ioexception { if ( hash_digest == null ) { throw new evernoteutilexception ( edam_hash_algorithm + _str , new nosuchalgorithmexception ( edam_hash_algorithm ) ) ; } byte [ ] buf = new byte [ _num ] ; int n ; while ( ( n = in . read ( buf ) ) != - _num ) { hash_digest . update ( buf , _num , n ) ; } return hash_digest . digest ( ) ; }	returns an md5 checksum of the contents of the provided inputstream .
public abstract treenode createnode ( final int x , final int y ) ;	create a new treenode.
@ suppresswarnings ( _str ) public static < t extends featurestructure > list < t > tolist ( fsarray array ) { if ( array == null ) { return new arraylist < t > ( ) ; } else { return ( list < t > ) arrays . aslist ( array . toarray ( ) ) ; } }	create a new list from an fsarray.
protected static int todigit ( final char ch , final int index ) throws illegalargumentexception { final int digit = character . digit ( ch , _num ) ; if ( digit == - _num ) { throw new illegalargumentexception ( _str + ch + _str + index ) ; } return digit ; }	converts a hexadecimal character to an integer .
public static serversidesortrequestcontrol newcontrol ( final boolean iscritical , final collection < sortkey > keys ) { reject . ifnull ( keys ) ; reject . iffalse ( ! keys . isempty ( ) , _str ) ; return new serversidesortrequestcontrol ( iscritical , collections . unmodifiablelist ( new arraylist < sortkey > ( keys ) ) ) ; }	creates a new server side sort request control with the provided criticality and list of sort keys .
@ suppresswarnings ( { _str , _str } ) static < e extends comparable < e > > autosortedcollection < e > createautosortedcollection ( supplier < list < sortedlistelement < e > > > listsup , collection < ? extends e > values ) { list list = listsup . get ( ) ; if ( ! list . isempty ( ) ) { throw new illegalstateexception ( _str ) ; } autosortedcollection < e > sortedcollection = new autolistsortedcollection < > ( list , null ) ; sortedcollection . addall ( values ) ; return sortedcollection ; }	construct new auto sorted collection using natural order .
private void intstream ( ) { int [ ] ints = new int [ ] { _num , _num , _num , _num , _num } ; intstream intstream = intstream . of ( ints ) ; intstream . foreach ( null ) ; intstream intstream2 = intstream . of ( _num , _num , _num , _num , _num ) ; intstream2 . foreach ( null ) ; }	creating stream of ints - intstream.
@ suppresswarnings ( _str ) public boolean iscustomized ( ) { if ( m_customizationlevel == null ) { getelementid ( ) ; m_customizationlevel = new integer ( s_parameters . customnone ) ; if ( m_parent . iscustomprefix ( m_name ) ) { m_customizationlevel = new integer ( s_parameters . customprefixed ) ; } else { if ( m_parent . isobjectexists ( _str , m_parent . gettables ( ) ) && m_parent . isobjectexists ( _str , m_parent . gettables ( ) ) ) { string sql = s_dbengine . sqlad_gettablecolumnentitytype ( m_parent . getvendor ( ) , m_parent . getcatalog ( ) , m_parent . getschema ( ) , m_table , m_name ) ; statement stmt = m_parent . setstatement ( ) ; resultset rs = m_parent . executequery ( stmt , sql ) ; if ( m_parent . getresultsetnext ( rs ) ) { string s = m_parent . getresultsetstring ( rs , _str ) ; if ( m_parent . iscustomentitytype ( s ) ) m_customizationlevel = new integer ( s_parameters . custommarked ) ; } m_parent . releaseresultset ( rs ) ; m_parent . releasestatement ( stmt ) ; } } } if ( m_customizationlevel . intvalue ( ) > s_parameters . customnone ) return _bool ; else return _bool ; }	whether or not this column is a customization.
public final void scheduledforflush ( ) { scheduledforflush . set ( _bool ) ; }	schedule the session for flushed.
public imageinfo inspectimage ( string image ) throws ioexception { return inspectimage ( inspectimageparams . create ( image ) ) ; }	gets detailed information about docker image .
@ override public double prevcumulativequantity ( final long woactivityid , long mbheaderid ) { if ( mbheaderid == null ) mbheaderid = - _num ; final object [ ] params = new object [ ] { mbheaderid , mbheaderid , worksconstants . cancelled_status , woactivityid } ; final double pquant = ( double ) genericservice . findbynamedquery ( _str , params ) ; if ( pquant == null ) return _num ; else return pquant . doublevalue ( ) ; }	get previous cumulative amount ( approved , approval pending and draft entries ) based on workorder activity id.
void receive ( int length , datainputstream in ) throws ioexception { synchronized ( lock ) { if ( ( pos > _num ) && ( ( buffer . length - present ) < length ) ) { system . arraycopy ( buffer , pos , buffer , _num , present - pos ) ; present -= pos ; pos = _num ; } if ( ( buffer . length - present ) < length ) throw new ioexception ( _str ) ; in . readfully ( buffer , present , length ) ; present += length ; requested -= length ; lock . notifyall ( ) ; } }	receive bytes transmitted from connection at remote endpoint .
public jdabuilder removelistener ( object listener ) { listeners . remove ( listener ) ; return this ; }	removes a listener from the list of listeners .
private static list < string > readfile ( file file ) throws ioexception { filereader fr = new filereader ( file ) ; bufferedreader br = new bufferedreader ( fr ) ; list < string > lines = new arraylist < string > ( ) ; string line ; while ( ( line = br . readline ( ) ) != null ) lines . add ( line ) ; fr . close ( ) ; br . close ( ) ; return lines ; }	returns a list with the file lines .
flexiblenode readexternalnode ( hashmap < string , taxon > translationlist ) throws importexception , ioexception { flexiblenode node = new flexiblenode ( ) ; string label = readtoken ( _str ) ; taxon taxon ; if ( translationlist . size ( ) > _num ) { taxon = translationlist . get ( label ) ; if ( taxon == null ) { throw new unknowntaxonexception ( _str + label + _str ) ; } } else { taxon = new taxon ( label ) ; } if ( getlastmetacomment ( ) != null ) { parsemigrationstring ( getlastmetacomment ( ) , node ) ; clearlastmetacomment ( ) ; } node . settaxon ( taxon ) ; int pop = integer . parseint ( label . split ( _str ) [ _num ] ) ; node . setattribute ( pop , ( pop - _num ) ) ; return node ; }	reads an external node in .
static void plugtogetherpair ( inputstream in , outputstream out , inputstream in1 , outputstream out1 ) { thread inthread = null ; thread outthread = null ; int nexecs = getnumexec ( ) ; inthread = accesscontroller . doprivileged ( new newthreadaction ( new pipewriter ( in , out , _str , nexecs ) , _str , _bool ) ) ; outthread = accesscontroller . doprivileged ( new newthreadaction ( new pipewriter ( in1 , out1 , _str , nexecs ) , _str , _bool ) ) ; inthread . start ( ) ; outthread . start ( ) ; }	allow plugging together two pipes at a time , to associate output from an execed process.
@ nonnull public static storablefence and ( @ nonnull storablefence ... fences ) { return storablefence . and ( arrays . aslist ( fences ) ) ; }	creates a meta storable fence which is a logical ' and ' of all the given fences.
public mxfuid ( byte [ ] uid ) { this . uid = arrays . copyof ( uid , uid . length ) ; }	instantiates a new mxf uid .
public static datamodellist serializableinstance ( ) { return new datamodellist ( ) ; }	generates a simple exemplar of this class to test serialization .
@ override public mbheader findlastmbpagenoforlineitem ( final workorderactivity workorderactivity , final long mbheaderid ) { logger . info ( _str ) ; string query = _str ; object [ ] params ; final list < object > paramlist = new arraylist < object > ( ) ; query = query + _str + _str + _str + _str ; paramlist . add ( workorderactivity . getid ( ) ) ; paramlist . add ( mbheaderid ) ; paramlist . add ( worksconstants . approved ) ; paramlist . add ( mbheaderid ) ; params = new object [ paramlist . size ( ) ] ; params = paramlist . toarray ( params ) ; final list < mbheader > mbheaderlist = genericservice . findallby ( query , params ) ; mbheader result = null ; if ( mbheaderlist != null && ! mbheaderlist . isempty ( ) ) result = mbheaderlist . get ( _num ) ; return result ; }	this method will return topageno for a line item from the last mb entry .
synchronized private void outputbufferedchunk ( ) { if ( smallchunks == null || chunksize == _num ) { return ; } if ( smallchunks . size ( ) == _num ) { outputchunk ( smallchunks . get ( _num ) ) ; chunksize = _num ; smallchunks = null ; return ; } final ibindingset [ ] chunk = new ibindingset [ chunksize ] ; int destpos = _num ; for ( ibindingset [ ] e : smallchunks ) { system . arraycopy ( e , _num , chunk , destpos , e . length ) ; destpos += e . length ; } outputchunk ( chunk ) ; chunksize = _num ; smallchunks = null ; }	output the internal buffer .
private void waitloadcompete ( ) { if ( m_loadcomplete ) return ; m_loader . setpriority ( thread . norm_priority ) ; log . config ( _str ) ; while ( m_loader . isalive ( ) ) { try { thread . sleep ( _num ) ; } catch ( exception e ) { log . log ( level . severe , _str , e ) ; } } log . config ( _str ) ; }	wait until load is complete.
public void addclasses ( list < string > classnames ) { if ( handlerfactories == null ) { handlerfactories = new arraylist < string > ( ) ; } handlerfactories . addall ( classnames ) ; }	add a list of exception handler class names .
public static boolean isconstantname ( string name ) { return pattern . matches ( _str , name ) ; }	checks if given name is a constant name i . e if the name contains all caps and underscores only.
private void notifydead ( final rpentity dead ) { if ( ! rats . remove ( dead ) ) { logger . warn ( _str + dead . tostring ( ) + _str ) ; } if ( rats . size ( ) == _num ) { phasetodefaultphase ( new linkedlist < string > ( arrays . aslist ( _str ) ) ) ; } }	function to control amount of alive rats .
public static omgrid read ( datainputstream dis ) throws ioexception { return read ( dis , null ) ; }	read a grid off a datainputstream.
public varcharconstant ( string s ) { type = new varchartype ( s . length ( ) ) ; val = s ; }	create a constant by wrapping the specified string .
public boolean addchildplanet ( dimensionproperties child ) { if ( child == this ) return _bool ; childplanets . add ( child . getid ( ) ) ; child . setparentplanet ( this ) ; return _bool ; }	does not check for hierarchy loops !.
@ override public enumeration < string > enumeratemeasures ( ) { vector < string > newvector = new vector < string > ( _num ) ; newvector . add ( _str ) ; return newvector . elements ( ) ; }	returns an enumeration of the additional measure names.
int [ ] calculaterelative ( int [ ] absolute ) { int [ ] res = new int [ absolute . length ] ; res [ _num ] = absolute [ _num ] ; for ( int i = _num ; i < res . length ; i ++ ) { res [ i ] = absolute [ i ] - absolute [ i - _num ] ; } return res ; }	calcuates the relative offset.
@ afterclass public static void deletelogdir ( ) { if ( logdir != null ) { fileutils . deletequietly ( logdir ) ; } }	deletes the temporary log dir and all files within .
public string tostring ( ) { stringbuffer sb = new stringbuffer ( ) ; char [ ] separator = { _str , _str } ; int n = rows ( ) ; int m = columns ( ) ; for ( int i = _num ; i < n ; i ++ ) { separator [ _num ] = _str ; for ( int j = _num ; j < m ; j ++ ) { sb . append ( separator ) ; sb . append ( components [ i ] [ j ] ) ; separator [ _num ] = _str ; } sb . append ( _str ) ; sb . append ( _str ) ; } return sb . tostring ( ) ; }	returns a string representation of the system .
public static string [ ] splitstringintoarray ( string value ) { string [ ] values = new string [ _num ] ; if ( value != null && value . length ( ) > _num ) { if ( value . indexof ( cimconstants . comma_seperator ) != - _num ) { values = value . split ( _str ) ; } else { values = new string [ _num ] ; values [ _num ] = value ; } } return values ; }	this method will help you to split the string separated with comma into a string array.
public static string fromattrmodelingmodelclass ( string vamodelclass ) { return vamodelclass . split ( valueanalysis . model_package_prefix ) [ _num ] ; }	convert the string signature of an attr modeling model class to a string signature of a regular class.
public synchronized void add ( dcclocoaddress locoaddress , boolean directionnormal ) { if ( ! contains ( locoaddress ) ) { if ( consistlist . size ( ) == _num ) { byte command = ncebinarycommand . loco_cmd_fwd_consist_lead ; if ( ! directionnormal ) { command = ncebinarycommand . loco_cmd_rev_consist_lead ; } addlocotoconsist ( locoaddress . getnumber ( ) , locoaddress . islongaddress ( ) , command ) ; consistposition . put ( locoaddress , dccconsist . position_lead ) ; } else if ( consistlist . size ( ) == _num ) { byte command = ncebinarycommand . loco_cmd_fwd_consist_rear ; if ( ! directionnormal ) { command = ncebinarycommand . loco_cmd_rev_consist_rear ; } addlocotoconsist ( locoaddress . getnumber ( ) , locoaddress . islongaddress ( ) , command ) ; consistposition . put ( locoaddress , dccconsist . position_trail ) ; } else { byte command = ncebinarycommand . loco_cmd_fwd_consist_mid ; if ( ! directionnormal ) { command = ncebinarycommand . loco_cmd_rev_consist_mid ; } addlocotoconsist ( locoaddress . getnumber ( ) , locoaddress . islongaddress ( ) , command ) ; consistposition . put ( locoaddress , consistposition . size ( ) ) ; } consistlist . add ( locoaddress ) ; consistdir . put ( locoaddress , boolean . valueof ( directionnormal ) ) ; } else { log . error ( _str + locoaddress + _str + getconsistaddress ( ) ) ; } }	add a locomotive to a consist.
private gridclientconfiguration clientconfiguration ( ) { gridclientconfiguration cfg = new gridclientconfiguration ( ) ; cfg . settopologyrefreshfrequency ( topologyrefreshfrequency ( ) ) ; cfg . setmaxconnectionidletime ( maxconnectionidletime ( ) ) ; cfg . setprotocol ( protocol ( ) ) ; cfg . setservers ( arrays . aslist ( serveraddress ( ) ) ) ; cfg . setbalancer ( new gridclientroundrobinbalancer ( ) ) ; if ( usessl ( ) ) cfg . setsslcontextfactory ( sslcontextfactory ( ) ) ; gridclientdataconfiguration loc = new gridclientdataconfiguration ( ) ; gridclientdataconfiguration partitioned = new gridclientdataconfiguration ( ) ; partitioned . setname ( partitioned_cache_name ) ; partitioned . setaffinity ( new gridclientpartitionaffinity ( ) ) ; gridclientdataconfiguration partitionedasyncbackup = new gridclientdataconfiguration ( ) ; partitionedasyncbackup . setname ( partitioned_async_backup_cache_name ) ; partitionedasyncbackup . setaffinity ( new gridclientpartitionaffinity ( ) ) ; gridclientdataconfiguration replicated = new gridclientdataconfiguration ( ) ; replicated . setname ( replicated_cache_name ) ; gridclientdataconfiguration replicatedasync = new gridclientdataconfiguration ( ) ; replicatedasync . setname ( replicated_async_cache_name ) ; cfg . setdataconfigurations ( arrays . aslist ( loc , partitioned , replicated , replicatedasync , partitionedasyncbackup ) ) ; return cfg ; }	creates client that will try to connect to only first node in grid .
public final testsubscriber assertnotsubscribed ( ) { string prefix = _str ; if ( done . getcount ( ) != _num ) { prefix = _str ; } if ( subscription . get ( ) != null ) { fail ( prefix , _str , errors ) ; } else if ( ! errors . isempty ( ) ) { fail ( prefix , _str , errors ) ; } return this ; }	assert that the onsubscribe method hasn ' t been called at all .
public builder ( ) { setversioncode ( math . min ( freshair . getcurrentapplicationversion ( ) , _num ) ) ; setfeatures ( new linkedlist < featureinfo > ( ) ) ; }	constructs a new builder , assuming that the version code is the current app version .
protected string convertdateformat ( string pattern ) { boolean inside = _bool ; boolean mark = _bool ; boolean modifiedcommand = _bool ; stringbuilder buf = new stringbuilder ( ) ; for ( int i = _num ; i < pattern . length ( ) ; i ++ ) { char c = pattern . charat ( i ) ; if ( c == _str && ! mark ) { mark = _bool ; } else { if ( mark ) { if ( modifiedcommand ) { modifiedcommand = _bool ; mark = _bool ; } else { inside = translatecommand ( buf , pattern , i , inside ) ; if ( c == _str || c == _str ) { modifiedcommand = _bool ; } else { mark = _bool ; } } } else { if ( ! inside && c != _str ) { buf . append ( _str ) ; inside = _bool ; } buf . append ( c ) ; } } } if ( buf . length ( ) > _num ) { char lastchar = buf . charat ( buf . length ( ) - _num ) ; if ( lastchar != _str && inside ) { buf . append ( _str ) ; } } return buf . tostring ( ) ; }	search the provided pattern and get the c standard date / time formatting rules and convert them to the java equivalent .
public void addchildnode ( evalfactorynode childnode ) { childnodes . add ( childnode ) ; }	adds a child node .
public final void headto ( tuple3d p ) { double angle = geometric . angle ( this . location , p ) ; turnto ( math . todegrees ( angle ) ) ; }	head to the direction of the given point .
public void compactbuffer ( ) { if ( offset != buffer . length ) { byte [ ] newbuffer = new byte [ offset ] ; system . arraycopy ( buffer , _num , newbuffer , _num , offset ) ; buffer = newbuffer ; } }	reallocates the buffer in order to make it exactly the size of data it contains.
public static int putbytebuffer ( byte [ ] bytes , int offset , bytebuffer buf ) { int len = buf . remaining ( ) ; buf . get ( bytes , offset , len ) ; return offset + len ; }	add the whole content of the bytebuffer to the bytes arrays.
private void clearindextofirst ( ) { for ( ; ; ) { index < k , v > q = head ; for ( ; ; ) { index < k , v > r = q . right ; if ( r != null && r . indexesdeletednode ( ) && ! q . unlink ( r ) ) break ; if ( ( q = q . down ) == null ) { if ( head . right == null ) tryreducelevel ( ) ; return ; } } } }	clears out index nodes associated with deleted first entry .
final void tryterminate ( ) { for ( ; ; ) { int c = ctl . get ( ) ; if ( isrunning ( c ) || runstateatleast ( c , tidying ) || ( runstateof ( c ) == shutdown && ! workqueue . isempty ( ) ) ) return ; if ( workercountof ( c ) != _num ) { interruptidleworkers ( only_one ) ; return ; } final reentrantlock mainlock = this . mainlock ; mainlock . lock ( ) ; try { if ( ctl . compareandset ( c , ctlof ( tidying , _num ) ) ) { try { terminated ( ) ; } finally { ctl . set ( ctlof ( terminated , _num ) ) ; termination . signalall ( ) ; } return ; } } finally { mainlock . unlock ( ) ; } } }	transitions to terminated state if either ( shutdown and pool and queue empty ) or ( stop and pool empty ).
public void joinresource ( ) throws interruptedexception { if ( runobj != null ) { synchronized ( complete ) { if ( runobj != null ) complete . wait ( ) ; } } }	waits for the resource to complete.
public static string tojsonstring ( list list ) { if ( list == null ) return _str ; boolean first = _bool ; stringbuffer sb = new stringbuffer ( ) ; iterator iter = list . iterator ( ) ; sb . append ( _str ) ; while ( iter . hasnext ( ) ) { if ( first ) first = _bool ; else sb . append ( _str ) ; object value = iter . next ( ) ; if ( value == null ) { sb . append ( _str ) ; continue ; } sb . append ( jsonvalue . tojsonstring ( value ) ) ; } sb . append ( _str ) ; return sb . tostring ( ) ; }	convert a list to json text.
@ override public int hashcode ( ) { final int prime = _num ; int result = super . hashcode ( ) ; result = prime * result + ( tenant == null ? _num : tenant . hashcode ( ) ) ; return result ; }	tenant aware entities extend the equals / hashcode strategy with the tenant name.
public void loadaccessors ( mappedfield configuredfield , mappedfield targetfield ) { loadaccessors ( targetclass , configuredfield , targetfield ) ; }	fill fields with they custom methods .
public static matrixblock reshape ( matrixblock in , matrixblock out , int rows , int cols , boolean rowwise ) throws dmlruntimeexception { int rlen = in . rlen ; int clen = in . clen ; if ( ( ( long ) rlen ) * clen != ( ( long ) rows ) * cols ) throw new dmlruntimeexception ( _str + rlen + _str + clen + _str + rows + _str + cols + _str ) ; if ( rlen == rows && clen == cols ) { out . copy ( in ) ; return out ; } out . sparse = matrixblock . evalsparseformatinmemory ( rows , cols , in . nonzeros ) ; out . rlen = rows ; out . clen = cols ; out . nonzeros = in . nonzeros ; if ( ! in . sparse && ! out . sparse ) reshapedense ( in , out , rows , cols , rowwise ) ; else if ( in . sparse && out . sparse ) reshapesparse ( in , out , rows , cols , rowwise ) ; else if ( in . sparse ) reshapesparsetodense ( in , out , rows , cols , rowwise ) ; else reshapedensetosparse ( in , out , rows , cols , rowwise ) ; return out ; }	cp reshape operation ( single input , single output matrix ).
public static class < ? > [ ] toclassesfromobjects ( final object [ ] params ) { final class < ? > [ ] classes = new class < ? > [ params . length ] ; int i = _num ; for ( final object object : params ) { if ( object != null ) { classes [ i ++ ] = object . getclass ( ) ; } else { classes [ i ++ ] = object . class ; } } return classes ; }	to classes from objects .
public adminregion ( string localname , remotegemfirevm vm , string userattributedesc ) { string gn = localname ; int idx = localname . lastindexof ( namesep ) ; if ( idx != - _num ) { localname = localname . substring ( idx + _num ) ; } else { gn = namesep + gn ; } this . globalname = gn ; this . localname = localname ; this . userattributedesc = userattributedesc ; this . vm = vm ; }	creates a root region.
public element signwithwssx509tokenprofile ( document doc , java . security . cert . certificate cert , string algorithm , list ids ) throws xmlsignatureexception { return signwithwssx509tokenprofile ( doc , cert , algorithm , ids , soapbindingconstants . wsf_10_version ) ; }	sign part of the xml document referered by the supplied a list of id attributes of nodes.
public void addusermessagelistener ( usermessagelistener usermessagelistener ) { usermessagelisteners . add ( usermessagelistener ) ; }	adds a user message listener .
public iteratorbuilder addtemplate ( ispacequery query ) { templates . add ( query ) ; return this ; }	adds a template that will be used to control the matching entries the iterator will iterate over .
public string addtoclasspath ( final string path ) { this . classpath += ( system . getproperty ( _str ) + path ) ; return this . classpath ; }	add to the classpath used when compiling .
private static int newlongarray ( jnienvironment env , int length ) { if ( tracejni ) vm . syswrite ( _str ) ; runtimeentrypoints . checkjnicountdowntogc ( ) ; try { long [ ] newarray = new long [ length ] ; return env . pushjniref ( newarray ) ; } catch ( throwable unexpected ) { if ( tracejni ) unexpected . printstacktrace ( system . err ) ; env . recordexception ( unexpected ) ; return _num ; } }	newlongarray : create a new long array.
protected abstract void finalizeoutput ( final int [ ] sourceimagepixels , final int imagewidth , final int imageheight ) ;	override this if any action needs to be done at the end of the conversion .
public static boolean ignoringbatteryoptimizations ( ) { return ngnapplication . ignoringbatteryoptimizations ( null ) ; }	raises " action_ignore_battery_optimization_settings " intent.
private boolean retrydelayhaspassedby ( long lastfailtime ) { return lastfailtime == null || lastfailtime + this . retryafterms < system . currenttimemillis ( ) ; }	checks if the retry delay has passed .
public static java . lang . string valueof ( long l ) { return long . tostring ( l ) ; }	returns the string representation of the long argument.
private boolean usemetric ( metricrule rule , metric metric ) { if ( rule . awsdimensionselect == null && rule . awsdimensionselectregex == null ) { return _bool ; } if ( rule . awsdimensionselect != null && metricsisinawsdimensionselect ( rule , metric ) ) { return _bool ; } if ( rule . awsdimensionselectregex != null && metricisinawsdimensionselectregex ( rule , metric ) ) { return _bool ; } return _bool ; }	check if a metric should be used according to ` aws_dimension_select ` or ` aws_dimension_select_regex `.
final void addiconmanager ( abstractstatusiconmanager manager ) { iconmanagers . add ( manager ) ; }	add a new status icon manager .
public indexmetadata upgradeindexmetadata ( indexmetadata indexmetadata ) { if ( isupgraded ( indexmetadata ) ) { return indexmetadata ; } checksupportedversion ( indexmetadata ) ; indexmetadata newmetadata = upgradelegacyroutingsettings ( indexmetadata ) ; newmetadata = adddefaultunitsifneeded ( newmetadata ) ; checkmappingscompatibility ( newmetadata ) ; newmetadata = upgradesettings ( newmetadata ) ; newmetadata = markasupgraded ( newmetadata ) ; return newmetadata ; }	checks that the index can be upgraded to the current version of the master node.
static final void encode ( byte [ ] src , int srcoff , int len , byte [ ] dst , int dstoff ) { dst [ dstoff ] = ( byte ) encode_table . charat ( ( src [ srcoff ] > > _num ) & _num ) ; if ( len == _num ) { dst [ dstoff + _num ] = ( byte ) encode_table . charat ( ( ( src [ srcoff ] << _num ) & _num ) | ( ( src [ srcoff + _num ] > > _num ) & _num ) ) ; dst [ dstoff + _num ] = ( byte ) encode_table . charat ( ( ( src [ srcoff + _num ] << _num ) & _num ) | ( ( src [ srcoff + _num ] > > _num ) & _num ) ) ; dst [ dstoff + _num ] = ( byte ) encode_table . charat ( src [ srcoff + _num ] & _num ) ; } else if ( len == _num ) { dst [ dstoff + _num ] = ( byte ) encode_table . charat ( ( ( src [ srcoff ] << _num ) & _num ) | ( ( src [ srcoff + _num ] > > _num ) & _num ) ) ; dst [ dstoff + _num ] = ( byte ) encode_table . charat ( ( src [ srcoff + _num ] << _num ) & _num ) ; } else { dst [ dstoff + _num ] = ( byte ) encode_table . charat ( ( src [ srcoff ] << _num ) & _num ) ; } }	encode len bytes of data in src at offset srcoff , storing the result into dst at offset dstoff.
@ suppresswarnings ( _str ) public static map < string , configurationkey < ? > > registeredkeys ( ) { synchronized ( registeredkeys ) { if ( copy == null ) copy = collections . unmodifiablemap ( ( map < string , configurationkey < ? > > ) registeredkeys . clone ( ) ) ; return copy ; } }	returns a copy of the currently registered keys .
public static string md5 ( string stringtohash ) { if ( stringtohash != null ) { try { messagedigest md = messagedigest . getinstance ( _str ) ; byte [ ] bytes = md . digest ( stringtohash . getbytes ( ) ) ; stringbuilder sb = new stringbuilder ( _num * bytes . length ) ; for ( int i = _num ; i < bytes . length ; i ++ ) { int low = ( bytes [ i ] & _num ) ; int high = ( ( bytes [ i ] & _num ) > > _num ) ; sb . append ( constants . hexadecimal [ high ] ) ; sb . append ( constants . hexadecimal [ low ] ) ; } return sb . tostring ( ) ; } catch ( nosuchalgorithmexception e ) { return _str ; } } else { return _str ; } }	convierte un string a hash md5.
public string mostofstring ( ) { string typename = _str ; switch ( type ) { case builtin : typename = _str ; break ; case number : typename = _str ; break ; case string : typename = _str ; break ; case pf_step : typename = _str ; break ; case ident : typename = _str ; break ; case comment : typename = _str ; break ; case dashes : typename = _str ; break ; case end_module : typename = _str ; break ; case prolog : typename = _str ; break ; case epilog : typename = _str ; break ; case pcal_label : typename = _str ; break ; } ; string str = _str + string + _str ; if ( string == null ) { str = _str ; } ; string result = _str + str + _str + typename + _str + column + _str + getwidth ( ) ; if ( abovealign . line != - _num ) { result = result + _str + abovealign . tostring ( ) ; } ; if ( belowalign . line != - _num ) { result = result + _str + belowalign . tostring ( ) ; } ; if ( prespace != _num ) { result = result + _str + prespace ; } ; if ( isalignmentpoint ) { result = result + _str ; } ; if ( distfrommargin != _num ) { result = result + _str + distfrommargin ; } ; if ( subscript ) { result = result + _str ; } ; return result ; }	the following defines a tostring ( ) method for printing a token for debugging.
public createindexrequest mapping ( string type , xcontentbuilder source ) { if ( mappings . containskey ( type ) ) { throw new illegalstateexception ( _str + type + _str ) ; } try { mappings . put ( type , source . string ( ) ) ; } catch ( ioexception e ) { throw new illegalargumentexception ( _str , e ) ; } return this ; }	adds mapping that will be added when the index gets created .
private static void copyfile ( file src , file dst , integer port , boolean internalcompression ) throws ioexception { bufferedreader in = new bufferedreader ( new inputstreamreader ( new fileinputstream ( src ) , standardcharsets . utf_8 ) ) ; writer out = new outputstreamwriter ( new fileoutputstream ( dst ) , standardcharsets . utf_8 ) ; for ( string line = in . readline ( ) ; null != line ; line = in . readline ( ) ) { if ( null != port ) line = line . replace ( _str , port . tostring ( ) ) ; line = line . replace ( _str , internalcompression ? _str : _str ) ; out . write ( line ) ; } in . close ( ) ; out . close ( ) ; }	character copy of file using utf - 8.
public void asserteventlogcontains ( object event ) { if ( ! meventlog . contains ( event ) ) { fail ( _str + meventlog ) ; } }	fails the current test unless the event log contains a particular event .
private static boolean isallunderscores ( ) { int i = _num ; boolean result = _bool ; while ( result && ( i < token . length ( ) ) ) { if ( token . charat ( i ) != _str ) { result = _bool ; } ; i = i + _num ; } ; return result ; }	the following private methods are all procedures for use by the tokenize method .
public imagewarp ( bufferedimage bi , geocoordtransformation transform , databounds imagebounds ) { if ( bi != null ) { iwidth = bi . getwidth ( ) ; iheight = bi . getheight ( ) ; setgeotrans ( transform ) ; setimagebounds ( imagebounds ) ; pixels = getpixels ( bi , _num , _num , iwidth , iheight ) ; bi = null ; } }	create an image warp with some additional transform information .
public static equipmentloggerfactory createfactory ( final equipmentconfiguration econf , final processconfiguration pconf , boolean useequipmentloggers , boolean useequipmentappendersonly ) { return new equipmentloggerfactory ( econf . gethandlerclassname ( ) , long . valueof ( econf . getid ( ) ) , econf . getname ( ) , pconf . getprocessname ( ) , useequipmentloggers , useequipmentappendersonly ) ; }	creates a new equipmentlogger .
protected void assertequals ( integer expected , integer actual ) { if ( expected == null || actual == null ) { if ( expected != actual ) { assertequals ( _str + expected , _str + actual ) ; } } else { assertequals ( expected . intvalue ( ) , actual . intvalue ( ) ) ; } }	check if two values are equal , and if not throw an exception .
public static boolean vpoolspecifiessnapshots ( final virtualpool virtualpool ) { if ( virtualpool . getmaxnativesnapshots ( ) == null ) { return _bool ; } return virtualpool . getmaxnativesnapshots ( ) != max_disabled ; }	convenience method to determine if the virtual pool supports snapshots.
public void mapdatasettoaxis ( int index , int axisindex ) { list axisindices = new java . util . arraylist ( _num ) ; axisindices . add ( new integer ( axisindex ) ) ; mapdatasettoaxes ( index , axisindices ) ; }	maps a dataset to a particular axis.
public authenticatorappregistrationuribuilder ( amidentity id , string secrethex , int codelength , string issuer ) { reject . ifnull ( id , _str ) ; reject . ifnull ( secrethex , _str ) ; reject . iftrue ( stringutils . isblank ( issuer ) , _str ) ; reject . iftrue ( ( codelength < min_code_length ) , _str + min_code_length + _str ) ; if ( secrethex . length ( ) == _num ) { throw new illegalargumentexception ( _str ) ; } this . issuer = issuer ; this . id = id ; this . secrethex = secrethex ; this . codelength = codelength ; }	construct a builder which can be used to generate uris for registering oath devices with an oath authentication module .
protected void updateapplicationenabled ( ) { firepropertychange ( _str , boolean . valueof ( ! isenabled ( ) ) , boolean . valueof ( isenabled ( ) ) ) ; }	updates the enabled state of this action depending on the new enabled state of the application .
public personalityinsights ( final string versiondate , string username , string password ) { this ( versiondate ) ; setusernameandpassword ( username , password ) ; }	instantiates a new personality insights service by username and password .
public string signmessage ( string message ) throws illegalstateexception { validate . notnull ( getsignalgorithm ( ) , _str ) ; validate . notnull ( getprivatekey ( ) , _str ) ; validate . notempty ( message , _str ) ; log . debug ( _str + message + _str + getsignalgorithm ( ) ) ; try { signaturealgorithm algo = signaturealgorithm . getsignaturealgorithmforuri ( getsignalgorithm ( ) ) ; signature sig = signature . getinstance ( algo . getalgorithmname ( ) ) ; sig . initsign ( this . privatekey ) ; byte [ ] messagebytes = message . getbytes ( _str ) ; sig . update ( messagebytes ) ; byte [ ] sigbytes = sig . sign ( ) ; string signature = sharedutils . encodebytes ( sigbytes ) ; log . debug ( _str + signature ) ; return signature ; } catch ( exception e ) { log . error ( _str , e ) ; throw new illegalstateexception ( e ) ; } }	signs message with known private key and algorithm.
private void outputpricelists ( properties ctx , printwriter out , boolean includeany ) { out . println ( _str ) ; if ( includeany ) out . println ( _str ) ; out . println ( _str ) ; out . println ( _str ) ; out . println ( _str ) ; }	output xml list of pricelists.
public void clearbindings ( ) { if ( mbindargs != null ) { arrays . fill ( mbindargs , null ) ; } }	clears all existing bindings.
public boolean assignifbestmatch ( methoddeclaration declaration ) { assert ! finalized : _str ; if ( ! ismatch ( declaration . getparameters ( ) ) ) { return _bool ; } if ( this . bestmatchmethod . ispresent ( ) ) { if ( this . bestmatchmethod . get ( ) . getparameters ( ) . size ( ) > declaration . getparameters ( ) . size ( ) ) { return _bool ; } } this . bestmatchmethod = optional . of ( declaration ) ; return _bool ; }	assigns this methoddeclaration if it is a match to the params defined for this method .
public static list < user > from ( cursor c ) { list < user > users = null ; int count = c . getcount ( ) ; if ( count > _num ) { users = new arraylist < > ( count ) ; while ( c . movetonext ( ) ) { user user = new user ( ) ; syncing . from ( c , user ) ; int col = c . getcolumnindex ( email_hash ) ; if ( col >= _num ) { user . emailhash = c . getstring ( col ) ; } col = c . getcolumnindex ( following ) ; if ( col >= _num ) { user . isfollowing = c . getint ( col ) == _num ; } users . add ( user ) ; } } c . close ( ) ; return users ; }	get contacts from the cursor and then close it .
private void startcheckingstatus ( ) { future = executor . submit ( null ) ; }	start checking the status of the transactions in another thread .
private void addsignatureprofile ( signaturewrapper signature , xmlsignature xmlsignature ) { signaturetype signaturetype = signaturetype . na ; string certificateid = signature . getsigningcertificateid ( ) ; if ( certificateid != null ) { signaturetype = getsignaturetype ( certificateid ) ; } xmlsignature . setsignaturelevel ( signaturetype . name ( ) ) ; }	here we determine the type of the signature .
private static final int parsetimestring ( string str ) { str = str . trim ( ) ; int ret = _num ; boolean neg = _bool ; int i = _num ; if ( str . charat ( _num ) == _str ) { neg = _bool ; i ++ ; } int num = _num ; final int len = str . length ( ) ; for ( ; i < len ; i ++ ) { char c = str . charat ( i ) ; if ( ( c >= _str ) && ( c <= _str ) ) { num = num * _num + c - _str ; } else if ( c == _str ) { ret += num ; num = _num ; ret *= _num ; } } ret += num ; ret *= _num ; if ( neg ) ret = - ret ; return ret ; }	convert hh : mm : ss to milliseconds.
public synchronized void removeimagelistener ( imagelistener cl ) { m_imagelisteners . remove ( cl ) ; }	remove an image listener.
public arraylist < constraintwidget > buildlist ( scoutwidget [ ] list ) { arraylist < constraintwidget > ret = new arraylist < > ( ) ; for ( int i = mcontainset . nextsetbit ( _num ) ; i >= _num ; i = mcontainset . nextsetbit ( i + _num ) ) { ret . add ( list [ i ] . mconstraintwidget ) ; } return ret ; }	build list of constraintwidgets from the scoutwidget list.
private boolean nodeexists ( stringtokenizer path ) throws backingstoreexception { string token = path . nexttoken ( ) ; if ( token . equals ( _str ) ) throw new illegalargumentexception ( _str ) ; synchronized ( lock ) { abstractpreferences child = kidcache . get ( token ) ; if ( child == null ) child = getchild ( token ) ; if ( child == null ) return _bool ; if ( ! path . hasmoretokens ( ) ) return _bool ; path . nexttoken ( ) ; if ( ! path . hasmoretokens ( ) ) throw new illegalargumentexception ( _str ) ; return child . nodeexists ( path ) ; } }	tokenizer contains < name > { ' / ' < name > }.
public int size ( ) { return delegate . size ( ) ; }	returns the number of components in this list .
public networkaddressfactoryimpl ( ) throws initializationexception { this ( default_tcp_http_listen_port ) ; }	defaults to an ephemeral port .
public transparentglasspanepanel ( imageicon icon , string text , color backgroundcolor , float transparency ) { setlayout ( new gridbaglayout ( ) ) ; gridbagconstraints gbc = new gridbagconstraints ( ) ; gbc . gridy = _num ; gbc . gridx = _num ; jlabel iconlabel = new jlabel ( icon ) ; add ( iconlabel , gbc ) ; gbc . gridy += _num ; label = new jlabel ( text ) ; add ( label , gbc ) ; if ( transparency > _num ) { transparency = _num ; } else if ( transparency < _num ) { transparency = _num ; } color transparentcolor = new color ( backgroundcolor . getred ( ) , backgroundcolor . getgreen ( ) , backgroundcolor . getblue ( ) , ( int ) ( transparency * _num ) ) ; setbackground ( transparentcolor ) ; setopaque ( _bool ) ; }	creates a transparent panel with a loading icon and a text .
@ override protected void fillheader ( header head ) { try { standard . context ( undefineddata . class ) ; head . setxtension ( _str ) ; head . setbitpix ( basichdu . bitpix_byte ) ; head . setnaxes ( _num ) ; head . addvalue ( naxisn . n ( _num ) , this . data . length ) ; head . addvalue ( pcount , _num ) ; head . addvalue ( gcount , _num ) ; head . addvalue ( extend , _bool ) ; } catch ( headercardexception e ) { log . log ( level . severe , _str , e ) ; } finally { standard . context ( null ) ; } }	fill header with keywords that describe data .
protected void cleanstationsandnetwork ( ) { log . info ( _str ) ; cleanschedule ( ) ; removenonusedstopfacilities ( ) ; cleanmodes ( ) ; removenonusedlinks ( ) ; log . info ( _str ) ; }	after all lines created , clean all non - linked stations , all pt - exclusive links ( check allowed modes ) and all nodes which are non - linked to any link after the above cleaning.
private static string stripapplespanfrommarkup ( string markup ) { stringbuilder stripped = new stringbuilder ( markup ) ; int prefixbegidx = stripped . indexof ( apple_span_prefix ) ; while ( prefixbegidx >= _num ) { int prefixendidx = stripped . indexof ( _str , prefixbegidx ) + _num ; stripped . replace ( prefixbegidx , prefixendidx , _str ) ; int suffixbegidx = stripped . lastindexof ( apple_span_suffix ) ; int suffixendidx = suffixbegidx + apple_span_suffix . length ( ) ; stripped . replace ( suffixbegidx , suffixendidx , _str ) ; prefixbegidx = stripped . indexof ( apple_span_prefix ) ; } return stripped . tostring ( ) ; }	strips the apple span appended by webkit while generating the selection markup .
private invocationconstraints createinvocationconstraints ( ) { if ( min_retry >= sleeptime [ tryindx ] ) { return new invocationconstraints ( new connectionabsolutetime ( system . currenttimemillis ( ) + sleeptime [ tryindx ] ) , null ) ; } else { return invocationconstraints . empty ; } }	create the invocationconstraints with connection absolute time based on an increasing retry.
public void create ( ssotoken token , string dn , map attrs ) throws smsexception , ssoexception { create ( token . getprincipal ( ) , dn , attrs ) ; objectchanged ( dn , add ) ; }	create an entry in the directory.
@ override public void close ( ) throws ioexception { if ( ! closed ) { try { if ( ! eof ) { exhaustinputstream ( this ) ; } } finally { eof = _bool ; closed = _bool ; } } }	upon close , this reads the remainder of the chunked message , leaving the underlying socket at a position to start reading the next response without scanning .
private void discarddownstreammediachunk ( ) { mediachunk removed = mediachunks . removefirst ( ) ; long totalbytes = removed . bytesloaded ( ) ; removed . release ( ) ; notifydownstreamdiscarded ( removed . starttimeus , removed . endtimeus , totalbytes ) ; }	discards the first downstream media chunk .
public object executescript ( final script script , final scriptcontext context ) { final scriptengine engine = scriptengineprovider . getscriptengine ( script . gettype ( ) ) ; return executescript ( script , engine , context ) ; }	executes the given script with context as the scriptcontext.
public static placeholderfragment newinstance ( ) { placeholderfragment fragment = new placeholderfragment ( ) ; bundle args = new bundle ( ) ; fragment . setarguments ( args ) ; return fragment ; }	returns a new instance of this fragment for the given section number .
public t eval ( ) { return eval ( bindings ( ) ) ; }	convenient method to eval an expression that does not need a scope .
public void add ( xmppathsegment segment ) { segments . add ( segment ) ; }	append a path segment.
private void nextsync ( ) { if ( syncitemiterator . hasnext ( ) ) { partialstarttime = system . currenttimemillis ( ) ; currentsyncitem = syncitemiterator . next ( ) ; currentsyncitem . sync ( this , hostconnection , callbackhandler , contentresolver ) ; } else { logutils . logd ( tag , _str + ( system . currenttimemillis ( ) - starttime ) ) ; if ( listener != null ) { listener . onsyncfinished ( this ) ; } syncservice . stopself ( servicestartid ) ; } }	processes the next item on the sync list , or cleans up if it is finished .
public string decode ( string encoded ) { jsonobject object = new jsonobject ( encoded ) ; jsonarray headers = object . getjsonarray ( _str ) ; for ( object headerobj : headers ) { jsonarray header = ( jsonarray ) headerobj ; string key = header . getstring ( _num ) ; string value = header . getstring ( _num ) ; if ( key . equalsignorecase ( content_type ) && ( value . contains ( _str ) || value . contains ( application_json ) ) ) { try { object . put ( _str , new jsonobject ( new string ( object . getbinary ( payload ) , charset . forname ( utf_8 ) ) ) ) ; } catch ( decodeexception e ) { object . put ( _str , new string ( object . getbinary ( payload ) , charset . forname ( utf_8 ) ) ) ; } object . remove ( payload ) ; break ; } } return object . tostring ( ) ; }	decode the payload if the content - type is text or json .
public void test_doas_01 ( ) { subject subj = new subject ( ) ; privilegedaction < object > pa = new myprivilegedaction ( ) ; privilegedaction < object > panull = null ; try { object obj = subject . doas ( null , pa ) ; } catch ( exception e ) { fail ( _str + e ) ; } try { object obj = subject . doas ( subj , pa ) ; } catch ( exception e ) { fail ( _str + e ) ; } try { object obj = subject . doas ( subj , panull ) ; fail ( _str ) ; } catch ( nullpointerexception npe ) { } }	javax . security . auth . subject # doas ( subject subject , privilegedaction action ).
public void testdivideexplesszero ( ) { string a = _str ; int ascale = _num ; string b = _str ; int bscale = _num ; string c = _str ; int resscale = - _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; bigdecimal result = anumber . divide ( bnumber , resscale , bigdecimal . round_ceiling ) ; assertequals ( _str , c , result . tostring ( ) ) ; assertequals ( _str , resscale , result . scale ( ) ) ; }	divide : local variable exponent is less than zero.
public static boolean containswhitespace ( final charsequence seq ) { if ( isempty ( seq ) ) { return _bool ; } final int strlen = seq . length ( ) ; for ( int i = _num ; i < strlen ; i ++ ) { if ( character . iswhitespace ( seq . charat ( i ) ) ) { return _bool ; } } return _bool ; }	check whether the given charsequence contains any whitespace characters .
public boolean iswheelevent ( ) { return iswheelevent ; }	indicates a mouse wheel event .
public connection ( string clienthandle , string clientid , string host , int port , context context , mqttandroidclient client , boolean sslconnection ) { this . clienthandle = clienthandle ; this . clientid = clientid ; this . host = host ; this . port = port ; this . context = context ; this . client = client ; this . sslconnection = sslconnection ; history = new arraylist < string > ( ) ; stringbuffer sb = new stringbuffer ( ) ; sb . append ( _str ) ; sb . append ( clientid ) ; sb . append ( _str ) ; addaction ( sb . tostring ( ) ) ; }	creates a connection object with the server information and the client hand which is the reference used to pass the client around activities.
public void recordstate ( dialoguestate state , string name ) { if ( frame != null ) { statemonitortab . recordstate ( state , name ) ; } }	records a dialogue state in the component and makes it available for display in the network selection list on the left side.
public void characters ( org . w3c . dom . node node ) throws org . xml . sax . saxexception { flushpending ( ) ; string data = node . getnodevalue ( ) ; if ( data != null ) { final int length = data . length ( ) ; if ( length > m_charsbuff . length ) { m_charsbuff = new char [ length * _num + _num ] ; } data . getchars ( _num , length , m_charsbuff , _num ) ; characters ( m_charsbuff , _num , length ) ; } }	this method gets the nodes value as a string and uses that string as if it were an input character notification .
private void computefiltersfromdefault ( indicatorviewstate oldstate ) { filters = new arraylist < filter > ( ) ; set < string > defaultfilternames = new hashset < string > ( ) ; for ( filter defaultfilter : defaultfilters ) { filters . add ( defaultfilter ) ; if ( defaultfilter . name != null ) defaultfilternames . add ( defaultfilter . name ) ; } if ( oldstate != null ) { for ( filter oldfilter : oldstate . filters ) { if ( oldfilter . name == null || ! defaultfilternames . contains ( oldfilter . name ) ) filters . add ( oldfilter ) ; } } }	computes the filters by combining the default filters and the user - defined filters stored in the previously saved state .
private static data parsename ( set me , set peer ) { if ( me == null ) { throw new nullpointerexception ( _str ) ; } else if ( me . isempty ( ) ) { throw new illegalargumentexception ( _str ) ; } data data = new data ( ) ; stringbuffer b = new stringbuffer ( ) ; data . me = cons ( me , b ) ; if ( peer != null && ! peer . isempty ( ) ) { b . append ( _str ) ; data . peer = cons ( peer , b ) ; } data . name = b . tostring ( ) ; return data ; }	constructs the target name and transient field data for the specified principal sets .
public static boolean streamcontentequals ( inputstream s1 , inputstream s2 ) throws ioexception { try { int b1 , b2 ; do { b1 = s1 . read ( ) ; b2 = s2 . read ( ) ; } while ( ( b1 == b2 ) && ( b1 != - _num ) ) ; return b1 == b2 ; } finally { try { s1 . close ( ) ; s2 . close ( ) ; } catch ( exception e ) { } } }	checks if both inputstreams have the same content and length.
static public void add ( errors errors , string text ) { if ( errors == null ) { return ; } errors . add ( text ) ; }	helper function that discards the text if ` errors ` is null .
public synchronized void removeiconsforpkg ( string packagename , userhandlecompat user ) { removefrommemcachelocked ( packagename , user ) ; long userserial = musermanager . getserialnumberforuser ( user ) ; micondb . delete ( icondb . column_component + _str + icondb . column_user + _str , new string [ ] { packagename + _str , long . tostring ( userserial ) } ) ; }	removes the entries related to the given package in memory and persistent db .
public boolean contains ( string scategory ) { return categoryestimations . containskey ( scategory ) ; }	returns whether there is an estimation for a given category in the set of estimations .
public static final void frontendstatistics ( specobj spec ) { }	this method should print statistics about the specification it is obviously not finished .
public string tostring ( ) { if ( notbefore == null || notafter == null ) return _str ; return ( _str + notbefore . tostring ( ) + _str + notafter . tostring ( ) + _str ) ; }	return the validity period as user readable string .
public void zoom ( double x , double y , double factor ) { double rangex = math . abs ( currentextent . getmaxx ( ) - currentextent . getminx ( ) ) ; double rangey = math . abs ( currentextent . getmaxy ( ) - currentextent . getminy ( ) ) ; currentextent . setminx ( x - ( rangex * factor ) / _num ) ; currentextent . setminy ( y - ( rangey * factor ) / _num ) ; currentextent . setmaxx ( x + ( rangex * factor ) / _num ) ; currentextent . setmaxy ( y + ( rangey * factor ) / _num ) ; addtoextenthistory ( currentextent ) ; }	performs a zoom and center operation.
protected boolean isoutputlineexpected ( final string line , final string [ ] expectedprefixes , final boolean filepathsareexpected ) { final string trimmed = line != null ? line . trim ( ) : null ; if ( stringutils . isnotempty ( trimmed ) ) { if ( filepathsareexpected && isfilepath ( line ) ) { return _bool ; } if ( expectedprefixes != null ) { for ( final string prefix : expectedprefixes ) { if ( stringutils . startswithignorecase ( line , prefix ) ) { return _bool ; } } } return _bool ; } return _bool ; }	this method evaluates a line of output to see if it contains something that is expected.
public static string metertostring ( ofinstructionmeter inst , logger log ) { return str_sub_goto_meter_meter_id + _str + long . tostring ( inst . getmeterid ( ) ) ; }	convert an ofinstructionmeter to string form.
public boolean isimagecachable ( int w , int h ) { return ( w * h ) < maxsingleimagepixelsize ; }	check if the image size is to big to be stored in the cache .
public void freeentry ( basicpoolentry entry ) { if ( numentries < _num ) { throw new illegalstateexception ( _str + route ) ; } if ( numentries <= freeentries . size ( ) ) { throw new illegalstateexception ( _str + route ) ; } freeentries . add ( entry ) ; }	returns an allocated entry to this pool .
public boolean isin ( coords coords ) { return coordinates . contains ( coords ) ; }	determine if the building occupies given coordinates.
private dialogbaseunits computedialogbaseunits ( fontmetrics metrics ) { double averagecharwidth = computeaveragecharwidth ( metrics , averagecharwidthteststring ) ; int ascent = metrics . getascent ( ) ; double height = ascent > _num ? ascent : ascent + ( _num - ascent ) / _num ; dialogbaseunits dialogbaseunits = new dialogbaseunits ( averagecharwidth , height ) ; if ( logger . isloggable ( level . config ) ) { logger . config ( _str + dialogbaseunits + _str + metrics . getfont ( ) ) ; } return dialogbaseunits ; }	computes and returns the horizontal dialog base units.
public synchronized void close ( ) { try { writer . close ( ) ; } catch ( ioexception ioe ) { ioe . printstacktrace ( ) ; } }	closes the output writer .
public static boolean isproxyuri ( final string url ) { notnull ( url ) ; return url . contains ( getrequesthandlerpath ( ) ) ; }	checks if the provided url is a resource proxy request .
public void addaction ( action act ) { if ( act . entry != null && act . entry != this ) { log . e ( tag , _str + act . entry . id + _str + id ) ; return ; } if ( mactions == null ) { mactions = new arraylist < action > ( ) ; } if ( mactions . size ( ) == _num ) { log . w ( tag , _str ) ; return ; } act . entry = this ; mactions . add ( act ) ; }	add a action to this notification.
public abstract iterable < ? extends compilationunittree > parse ( ) throws ioexception ;	parse the specified files returning a list of abstract syntax trees .
private void name ( stringbuilder builder ) { string name = type . getname ( ) ; if ( name != null ) { builder . append ( _str ) ; builder . append ( name ) ; builder . append ( _str ) ; } }	this is used to build a string from the annotation.
boolean ensureprocesssizefits ( final executionunit process , final rectangle2d rect ) { dimension processsize = model . getprocesssize ( process ) ; if ( processsize == null ) { return _bool ; } if ( rect == null ) { return _bool ; } boolean needsresize = _bool ; double processwidth = processsize . getwidth ( ) * ( _num / model . getzoomfactor ( ) ) ; double processheight = processsize . getheight ( ) * ( _num / model . getzoomfactor ( ) ) ; double width = processwidth ; double height = processheight ; if ( processsize != null ) { if ( processwidth < rect . getmaxx ( ) + processdrawer . grid_x_offset ) { double diff = rect . getmaxx ( ) + processdrawer . grid_x_offset - processwidth ; if ( diff > processdrawer . grid_x_offset ) { width += diff ; } else { width += processdrawer . grid_x_offset ; } needsresize = _bool ; } if ( processheight < rect . getmaxy ( ) + processdrawer . grid_y_offset ) { double diff = rect . getmaxy ( ) + processdrawer . grid_y_offset - processheight ; if ( diff > processdrawer . grid_y_offset ) { height += diff ; } else { height += processdrawer . grid_y_offset ; } needsresize = _bool ; } if ( needsresize ) { model . setprocesswidth ( process , width ) ; model . setprocessheight ( process , height ) ; balance ( ) ; model . fireprocesssizechanged ( ) ; return _bool ; } } return _bool ; }	increases the process size if necessary for the given operator .
public void handletblhandlersbuttonaddrequest ( requestinvocationevent event ) throws modelcontrolexception { try { map values = getvalues ( ) ; onbeforesaveprofile ( values ) ; setpagesessionattribute ( property_attribute , ( hashmap ) values ) ; wsauthnserviceshandlersaddviewbean vb = ( wsauthnserviceshandlersaddviewbean ) getviewbean ( wsauthnserviceshandlersaddviewbean . class ) ; unlockpagetrail ( ) ; passpgsessionmap ( vb ) ; vb . forwardto ( getrequestcontext ( ) ) ; } catch ( amconsoleexception e ) { setinlinealertmessage ( ccalert . type_error , _str , e . getmessage ( ) ) ; } }	handles add handler request .
public void reducedl ( double expfprate , boolean checkerr ) { boolean needupdate = _bool ; double [ ] rulesetstat = new double [ _num ] ; for ( int j = _num ; j < m_simplestats . size ( ) ; j ++ ) { rulesetstat [ _num ] += m_simplestats . get ( j ) [ _num ] ; rulesetstat [ _num ] += m_simplestats . get ( j ) [ _num ] ; rulesetstat [ _num ] += m_simplestats . get ( j ) [ _num ] ; if ( j == m_simplestats . size ( ) - _num ) { rulesetstat [ _num ] = m_simplestats . get ( j ) [ _num ] ; rulesetstat [ _num ] = m_simplestats . get ( j ) [ _num ] ; rulesetstat [ _num ] = m_simplestats . get ( j ) [ _num ] ; } } for ( int k = m_simplestats . size ( ) - _num ; k >= _num ; k -- ) { double [ ] rulestat = m_simplestats . get ( k ) ; double ifdeleted = potential ( k , expfprate , rulesetstat , rulestat , checkerr ) ; if ( ! double . isnan ( ifdeleted ) ) { if ( k == ( m_simplestats . size ( ) - _num ) ) { removelast ( ) ; } else { m_ruleset . remove ( k ) ; needupdate = _bool ; } } } if ( needupdate ) { m_filtered = null ; m_simplestats = null ; countdata ( ) ; } }	try to reduce the dl of the ruleset by testing removing the rules one by one in reverse order and update all the stats.
@ override public void ondrawframe ( gl10 gl10 ) { gles20 . glclearcolor ( _num , _num , _num , _num ) ; gles20 . glclear ( gles20 . gl_color_buffer_bit | gles20 . gl_depth_buffer_bit ) ; gles20 . glenable ( gles20 . gl_depth_test ) ; gles20 . glenable ( gles20 . gl_cull_face ) ; gles20 . glenable ( gles20 . gl_blend ) ; gles20 . glblendfunc ( gles20 . gl_src_alpha , gles20 . gl_one_minus_src_alpha ) ; long currenttimemillis = system . currenttimemillis ( ) ; updatewithdelta ( currenttimemillis - lasttimemillis ) ; lasttimemillis = currenttimemillis ; }	glsurfaceview has default 16bit depth buffer.
public void removelinehighlight ( object tag ) { if ( tag instanceof linehighlightinfo ) { linehighlights . remove ( tag ) ; repaintline ( ( linehighlightinfo ) tag ) ; } }	removes a line highlight .
private element createsinglelogoutforcastleasidp ( string binding ) throws exception { string entityid = idmclient . getentityid ( tenantname ) ; string ssoloc = converttoipv6shortform ( entityid ) ; if ( ssoloc == null ) { ssoloc = tenantname ; } string sloloc = ssoloc . replaceall ( _str , _str ) ; element slosele = createendpoint ( samlnames . slos , binding , sloloc , null ) ; return slosele ; }	return singlelogoutservice element for castle as idp .
public static void unregistertransportmbean ( string containername ) throws exception { mbeanserver mbeanserver = getmbeanserver ( containername ) ; if ( mbeanserver == null ) return ; objectname transportmbeanobjectname = transportconstants . createtransportmbeanobjectname ( containername ) ; if ( mbeanserver . isregistered ( transportmbeanobjectname ) ) { mbeanserver . unregistermbean ( transportmbeanobjectname ) ; if ( _logger . isloggable ( level . fine ) ) { _logger . fine ( _str ) ; } } }	release transport mbean registration .
public void addnodesindocorder ( nodeiterator iterator , xpathcontext support ) { if ( ! m_mutable ) throw new runtimeexception ( xslmessages . createxpathmessage ( xpatherrorresources . er_nodeset_not_mutable , null ) ) ; node node ; while ( null != ( node = iterator . nextnode ( ) ) ) { addnodeindocorder ( node , support ) ; } }	copy nodelist members into this nodelist , adding in document order.
protected void uninstalldefaults ( ) { seaglasscontext context = getcontext ( splitpane , enabled ) ; style . uninstalldefaults ( context ) ; context . dispose ( ) ; style = null ; context = getcontext ( splitpane , region . split_pane_divider , enabled ) ; dividerstyle . uninstalldefaults ( context ) ; context . dispose ( ) ; dividerstyle = null ; super . uninstalldefaults ( ) ; }	uninstalls the ui defaults .
public void subtractamount ( final string amount ) { subtractamount ( integer . parseint ( amount ) ) ; }	subtract the specified amount from the still needed amount .
private synchronized void makecompositebuilder ( ) throws invalidobjectexception { if ( compositebuilder != null ) return ; class < ? > targetclass = ( class < ? > ) getjavatype ( ) ; compositebuilder [ ] [ ] builders = { { new compositebuilderviafrom ( targetclass , itemnames ) } , { new compositebuilderviaconstructor ( targetclass , itemnames ) } , { new compositebuildercheckgetters ( targetclass , itemnames , gettermappings ) , new compositebuilderviasetters ( targetclass , itemnames ) , new compositebuilderviaproxy ( targetclass , itemnames ) } } ; compositebuilder foundbuilder = null ; final stringbuilder whynots = new stringbuilder ( ) ; throwable possiblecause = null ; find : for ( compositebuilder [ ] relatedbuilders : builders ) { for ( int i = _num ; i < relatedbuilders . length ; i ++ ) { compositebuilder builder = relatedbuilders [ i ] ; string whynot = builder . applicable ( getters ) ; if ( whynot == null ) { foundbuilder = builder ; break find ; } throwable cause = builder . possiblecause ( ) ; if ( cause != null ) possiblecause = cause ; if ( whynot . length ( ) > _num ) { if ( whynots . length ( ) > _num ) whynots . append ( _str ) ; whynots . append ( whynot ) ; if ( i == _num ) break ; } } } if ( foundbuilder == null ) { string msg = _str + targetclass . getname ( ) + _str + whynots ; if ( possiblecause != null ) msg += _str ; throw invalidobjectexception ( msg , possiblecause ) ; } compositebuilder = foundbuilder ; }	determine how to convert back from the compositedata into the original java type.
public void invalidateall ( ) { if ( m_tuples == null ) return ; for ( int i = _num ; i < m_tuples . length ; ++ i ) invalidate ( i ) ; }	invalidate all tuples managed by this tuplemanager.
public void add ( final long addr ) { addrs . add ( addr ) ; }	add an address to this bucket .
@ androidonly ( _str ) public void test_wrap_bytebuffer_bytebuffer_04 ( ) { string host = _str ; int port = _num ; bytebuffer bbs = bytebuffer . allocate ( _num ) ; bytebuffer bbd = bytebuffer . allocate ( _num ) ; sslengine sse = getengine ( host , port ) ; try { sse . wrap ( bbs , bbd ) ; fail ( _str ) ; } catch ( illegalstateexception iobe ) { } catch ( exception e ) { fail ( e + _str ) ; } }	javax . net . ssl . sslengine # wrap ( bytebuffer src , bytebuffer dst ) illegalstateexception should be thrown .
public static boolean isblacklisted ( @ nonnull size size , @ nonnull string blackliststring ) { string [ ] blackliststringarray = blackliststring . split ( _str ) ; if ( blackliststringarray . length == _num ) { return _bool ; } set < string > blacklistedsizes = new hashset ( lists . newarraylist ( blackliststringarray ) ) ; return isblacklisted ( size , blacklistedsizes ) ; }	returns whether the given size is within the blacklist string .
static private void _writedecref ( writer out , char ch ) throws ioexception { if ( ch == _str ) { out . write ( _str ) ; return ; } out . write ( _str ) ; int i = ( int ) ch ; if ( i > _num ) { out . write ( _str + ( i / _num ) ) ; i = i % _num ; out . write ( _str + ( i / _num ) ) ; i = i % _num ; out . write ( _str + ( i / _num ) ) ; i = i % _num ; out . write ( _str + ( i / _num ) ) ; i = i % _num ; out . write ( _str + i ) ; } else if ( i > _num ) { out . write ( _str + ( i / _num ) ) ; i = i % _num ; out . write ( _str + ( i / _num ) ) ; i = i % _num ; out . write ( _str + ( i / _num ) ) ; i = i % _num ; out . write ( _str + i ) ; } else { out . write ( _str + ( i / _num ) ) ; i = i % _num ; out . write ( _str + ( i / _num ) ) ; i = i % _num ; out . write ( _str + i ) ; } out . write ( _str ) ; }	writes a character as a decimal escape.
protected byte [ ] inputstreamtobytearray ( inputstream is ) throws ioexception { bytearrayoutputstream bos = new bytearrayoutputstream ( ) ; int next = is . read ( ) ; while ( next > - _num ) { bos . write ( next ) ; next = is . read ( ) ; } bos . flush ( ) ; is . close ( ) ; return bos . tobytearray ( ) ; }	reads an input stream into a byte array.
@ override public string tostring ( ) { object value = get ( ) ; return value == null ? _str : value . tostring ( ) ; }	returns the value as string .
private boolean isareferencetag ( string str ) { if ( str == null ) { return _bool ; } return str . indexof ( _str ) == _num && str . lastindexof ( _str ) == ( str . length ( ) - _num ) ; }	check if the phone number is actually a reference to a data from the intent or external parameter .
protected static string encode ( string url ) { stringbuilder encoder = new stringbuilder ( ) ; for ( char chr : url . tochararray ( ) ) { byte chrbyte = ( byte ) chr ; if ( ( chrbyte <= _num || chrbyte >= _num || chr == _str || chr == _str ) ) { encoder . append ( string . format ( _str , chrbyte ) ) ; } else { encoder . append ( chr ) ; } } return encoder . tostring ( ) ; }	replaces all special characters in the url with hex strings .
public void testx509crlentry ( ) { tbtcrlentry tbt_crlentry = new tbtcrlentry ( ) ; assertnull ( tbt_crlentry . getcertificateissuer ( ) ) ; assertnull ( tbt_crlentry . getcriticalextensionoids ( ) ) ; try { assertnull ( tbt_crlentry . getencoded ( ) ) ; } catch ( crlexception e ) { fail ( _str + e . getmessage ( ) ) ; } assertnull ( tbt_crlentry . getnoncriticalextensionoids ( ) ) ; assertnull ( tbt_crlentry . getrevocationdate ( ) ) ; }	x509crlentry ( ) method testing.
private binlogposition findheartbeat ( maxwellreplicator r ) throws exception { r . startreplicator ( ) ; for ( rowmap row = r . getrow ( ) ; row != null ; row = r . getrow ( ) ) { if ( objects . equals ( r . getlastheartbeatread ( ) , recoveryinfo . heartbeat ) ) return row . getposition ( ) ; } return null ; }	try to find a given heartbeat value from the replicator .
private configure ( ) { properties p = new properties ( ) ; map args = new hashmap ( ) ; args . putall ( system . getenv ( ) ) ; args . putall ( system . getproperties ( ) ) ; p . putall ( args ) ; this . property = p ; reload ( _bool ) ; }	sometimes call by sample application , at that time normally set some properties directly.
private void handletruncatedinfo ( final statementinfo info ) throws sqlexception { final byte [ ] originalinfo = statement . getstatementinforequestitems ( ) ; final byte [ ] newinfoitems = new byte [ originalinfo . length + _num * _num ] ; int newindex = _num ; for ( final byte infoitem : originalinfo ) { assert newindex < newinfoitems . length : _str ; switch ( infoitem ) { case iscconstants . isc_info_sql_select : case iscconstants . isc_info_sql_bind : final rowdescriptorbuilder currentbuilder = infoitem == iscconstants . isc_info_sql_select ? info . fieldbuilder : info . parameterbuilder ; final int descriptorindex = currentbuilder != null ? currentbuilder . getfirstunprocessedindex ( ) + _num : _num ; newinfoitems [ newindex ++ ] = iscconstants . isc_info_sql_sqlda_start ; newinfoitems [ newindex ++ ] = _num ; newinfoitems [ newindex ++ ] = ( byte ) ( descriptorindex & _num ) ; newinfoitems [ newindex ++ ] = ( byte ) ( descriptorindex > > _num ) ; newinfoitems [ newindex ++ ] = infoitem ; break ; default : newinfoitems [ newindex ++ ] = infoitem ; break ; } } assert newindex == newinfoitems . length : _str ; info . requestbuffersize = math . min ( _num * info . requestbuffersize , statement . getmaxsqlinfosize ( ) ) ; info . buffer = statement . getsqlinfo ( newinfoitems , info . requestbuffersize ) ; info . currentindex = _num ; }	handles info buffer truncation by requesting new information.
public static string stripfileextension ( string name ) { int pos = name . lastindexof ( _str ) ; if ( pos > _num & pos < name . length ( ) - _num ) return name . substring ( _num , pos ) ; return name ; }	remove the extension from the file name.
private static void pushtransactionstartstamp ( transaction t ) { map < transaction , timestamp > map = suspendedtxstartstamps . get ( ) ; timestamp stamp = transactionstartstamp . get ( ) ; if ( stamp != null ) { map . put ( t , stamp ) ; } else { debug . logerror ( _str , module ) ; } }	put the stamp to remember later.
private int indexedbinarysearch ( list < s2cellid > l , s2cellid key , int low ) { int high = l . size ( ) - _num ; while ( low <= high ) { int mid = ( low + high ) > > _num ; s2cellid midval = l . get ( mid ) ; int cmp = midval . compareto ( key ) ; if ( cmp < _num ) { low = mid + _num ; } else if ( cmp > _num ) { high = mid - _num ; } else { return mid ; } } return low ; }	just as normal binary search , except that it allows specifying the starting value for the lower bound .
public variable [ ] findlocalarrays ( ) { list < variable > arrays = new arraylist < variable > ( ) ; for ( listiterator < variable > iterator = flocalvariables . listiterator ( flocalvariables . size ( ) ) ; iterator . hasprevious ( ) ; ) { variable localvariable = iterator . previous ( ) ; if ( localvariable . isarray ( ) ) arrays . add ( localvariable ) ; } return arrays . toarray ( new variable [ arrays . size ( ) ] ) ; }	returns all local arrays in the order that they appear .
public static int indexofjavalikeextension ( string filename ) { int filenamelength = filename . length ( ) ; char [ ] [ ] javalikeextensions = getjavalikeextensions ( ) ; extensions : for ( int i = _num , length = javalikeextensions . length ; i < length ; i ++ ) { char [ ] extension = javalikeextensions [ i ] ; int extensionlength = extension . length ; int extensionstart = filenamelength - extensionlength ; int dotindex = extensionstart - _num ; if ( dotindex < _num ) continue ; if ( filename . charat ( dotindex ) != _str ) continue ; for ( int j = _num ; j < extensionlength ; j ++ ) { if ( filename . charat ( extensionstart + j ) != extension [ j ] ) continue extensions ; } return dotindex ; } return - _num ; }	returns the index of the java like extension of the given file name or - 1 if it doesn ' t end with a known java like extension.
public shapetilesimplex remove_border_line ( int p_no ) { if ( p_no < _num || p_no >= lines_size ( ) ) { return this ; } arraylist < plalineint > new_arr = new arraylist < plalineint > ( lines_size ( ) ) ; new_arr . addall ( lines_list ) ; new_arr . remove ( p_no ) ; return new shapetilesimplex ( new_arr ) ; }	enlarges the simplex by removing the edge line with index p_no.
protected boolean waitbeforeexecution ( ) throws interruptedexception { return _bool ; }	provides an opportunity to pause before executing the protocol .
static boolean isvalidstreamingurl ( string url ) { return url != null && url . matches ( _str ) ; }	checks if a given string is a valid twitch url ( ie , one that will display " streaming " on the discord client .
public webserviceproxy ( url serverurl , executorservice executorservice ) { this ( serverurl , executorservice , _num , _num ) ; }	creates a new web service proxy .
private static byte [ ] exposebytearrayinputstreambytes ( bytearrayinputstream bais ) { byte [ ] buffer ; synchronized ( bais ) { byte [ ] buf ; int pos ; try { buf = ( byte [ ] ) bais_buf . get ( bais ) ; pos = bais_pos . getint ( bais ) ; } catch ( illegalaccessexception iae ) { throw new assertionerror ( iae ) ; } int available = bais . available ( ) ; if ( pos == _num && buf . length == available ) { buffer = buf ; } else { buffer = new byte [ available ] ; system . arraycopy ( buf , pos , buffer , _num , available ) ; } bais . skip ( available ) ; } return buffer ; }	returns a byte [ ] containing all the bytes from a bytearrayinputstream.
private void restoredata ( ) { map < string , ? > map = preferenceutils . getall ( ) ; set < string > strings = map . keyset ( ) ; for ( string string : strings ) { if ( string . startswith ( sharedpreferenceutils . keytestmode ) ) { preferenceutils . restorekey ( string ) ; } } refreshkeyvalues ( ) ; }	restore values of original keys stored .
public string putimage ( string thefolder , string theimagename , bitmap thebitmap ) { if ( thefolder == null || theimagename == null || thebitmap == null ) return null ; this . default_app_imagedata_directory = thefolder ; string mfullpath = setupfullpath ( theimagename ) ; if ( ! mfullpath . equals ( _str ) ) { lastimagepath = mfullpath ; savebitmap ( mfullpath , thebitmap ) ; } return mfullpath ; }	saves ' thebitmap ' into folder ' thefolder ' with the name ' theimagename '.
public class < ? > type ( ) { if ( isclass ) { return ( class < ? > ) object ; } else { return object . getclass ( ) ; } }	get the type of the wrapped object .
void addtoexternalcss ( csselement csselement ) { if ( externalcss == null ) { externalcss = new vector ( ) ; } externalcss . addelement ( csselement ) ; }	adds the specified csselement which represents an external css file to the external css vector.
private void remove ( string world , permissionholder holder , string permission ) { try { if ( world != null && ! world . equals ( _str ) ) { holder . unsetpermission ( permission , server , world ) ; } else { holder . unsetpermission ( permission , server ) ; } } catch ( objectlacksexception ignored ) { } save ( holder ) ; }	generic method to remove a permission from a holder.
private void action_treeaddall ( ) { log . info ( _str ) ; listmodel model = centerlist . getmodel ( ) ; int size = model . getsize ( ) ; int index = - _num ; for ( index = _num ; index < size ; index ++ ) { listitem item = ( listitem ) model . getelementat ( index ) ; action_treeadd ( item ) ; } }	action : add all nodes to tree.
private concurrentskiplistmap . node < k , v > hinode ( ) { if ( hi == null ) return m . findlast ( ) ; else if ( hiinclusive ) return m . findnear ( hi , lt | eq ) ; else return m . findnear ( hi , lt ) ; }	returns highest node . this node might not be in range , so most usages need to check bounds .
public static final imagepoint convertpoint ( mappoint mappoint , mapenvelope mapenv , int imgheight , int imgwidth ) { long imagey = math . round ( converty ( mappoint , mapenv , imgheight ) ) ; long imagex = math . round ( convertx ( mappoint , mapenv , imgwidth ) ) ; return new imagepoint ( imagex , imagey ) ; }	this method assumes that parameter p is a doittpoint in map coordinates and converts it under the assumption that the mapenv parameter field is properly set in map coordinates and that the imgheight and imgwidth are the dimensions of the map image in pixels .
private void checkusingadaptation ( ) { if ( tsuseadaptation . isselected ( ) ) { tfadaptationtime . setenabled ( _bool ) ; tfadaptationparam . setenabled ( _bool ) ; } else { tfadaptationtime . setenabled ( _bool ) ; tfadaptationparam . setenabled ( _bool ) ; } }	checks for using adaptation and enables or disables adaptation field accordingly .
public string combinemix ( list < string > files , string outfile ) { arraylist < string > cmd = new arraylist < string > ( ) ; cmd . add ( soxbin ) ; cmd . add ( _str ) ; for ( string file : files ) { cmd . add ( _str ) ; cmd . add ( _str ) ; cmd . add ( file ) ; } cmd . add ( outfile ) ; try { int rc = execsox ( cmd , callback ) ; if ( rc != _num ) { outfile = null ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } return outfile ; }	combine and mix audio files sox - m - v 1.
public quarter ( int quarter , year year ) { if ( ( quarter < first_quarter ) || ( quarter > last_quarter ) ) { throw new illegalargumentexception ( _str ) ; } this . year = ( short ) year . getyear ( ) ; this . quarter = ( byte ) quarter ; peg ( calendar . getinstance ( ) ) ; }	constructs a new quarter .
public void sendrequestvoterequest ( boolean isprevote ) throws gondolaexception { if ( ! enabled || masterid >= _num ) { return ; } if ( ! isprevote ) { currentterm ++ ; votedfor = - _num ; save ( currentterm , memberid ) ; votedfor = memberid ; } prevotesonly = isprevote ; message message = pool . checkout ( ) ; try { savequeue . getlatest ( savedrid ) ; message . requestvoterequest ( memberid , currentterm , isprevote , savedrid ) ; peers . foreach ( null ) ; } finally { message . release ( ) ; } prevotets = clock . now ( ) + ( long ) ( ( math . random ( ) * prevoteperiod ) ) ; if ( ! isprevote ) { prevotets += electiontimeout ; } }	if not a prevote , increments the current term before sending out the message .
private list < string > filtertargetsfromresponse ( set < string > varraytaggedportwwns , map < string , list < string > > initiatortargetmap , string initiatorkey ) { log . debug ( _str ) ; list < string > filteredtargetlist = new arraylist < string > ( ) ; list < string > targetportlistfromresponse = initiatortargetmap . get ( initiatorkey ) ; for ( string portwwn : targetportlistfromresponse ) { if ( varraytaggedportwwns . contains ( portwwn ) || varraytaggedportwwns . contains ( portwwn . touppercase ( ) ) ) { filteredtargetlist . add ( portwwn . touppercase ( ) ) ; } } log . debug ( _str ) ; return filteredtargetlist ; }	filters the target port list from the response based on the varray tagging .
public pilotingrolldata checkmaneuver ( movestep step , entitymovementtype overallmovetype ) { pilotingrolldata roll = getbasepilotingroll ( overallmovetype ) ; if ( ( step == null ) || ( step . gettype ( ) != movesteptype . maneuver ) ) { roll . addmodifier ( targetroll . check_false , _str ) ; return roll ; } boolean sideslipmod = ( this instanceof convfighter ) && isvstol ( ) ; roll . append ( new pilotingrolldata ( getid ( ) , maneuvertype . getmod ( step . getmaneuvertype ( ) , sideslipmod ) , maneuvertype . gettypename ( step . getmaneuvertype ( ) ) + _str ) ) ; return roll ; }	checks if a maneuver requires a control roll.
public static list < string > parseprogramargs ( ilaunchconfiguration launchconfig ) throws coreexception { return parseargs ( launchconfig . getattribute ( ijavalaunchconfigurationconstants . attr_program_arguments , _str ) ) ; }	parses the program arguments from the launch configuration into a list of arguments .
public abstract t decodevalue ( string value ) ;	parse and validate a string representation of a property value .
@ override public synchronized mxbeanmapping mappingfortype ( type objtype , mxbeanmappingfactory factory ) throws opendataexception { if ( inprogress . containskey ( objtype ) ) { throw new opendataexception ( _str + typename ( objtype ) ) ; } mxbeanmapping mapping ; mapping = getmapping ( objtype ) ; if ( mapping != null ) return mapping ; inprogress . put ( objtype , objtype ) ; try { mapping = makemapping ( objtype , factory ) ; } catch ( opendataexception e ) { throw opendataexception ( _str + typename ( objtype ) , e ) ; } finally { inprogress . remove ( objtype ) ; } putmapping ( objtype , mapping ) ; return mapping ; }	get the converter for the given java type , creating it if necessary .
public static element createelementinsignature11space ( document doc , string elementname ) { if ( doc == null ) { throw new runtimeexception ( _str ) ; } if ( ( ds11prefix == null ) || ( ds11prefix . length ( ) == _num ) ) { return doc . createelementns ( constants . signaturespec11ns , elementname ) ; } return doc . createelementns ( constants . signaturespec11ns , ds11prefix + _str + elementname ) ; }	creates an element in the xml signature 1.
public void removeelementat ( final int index ) { entries . remove ( index ) ; }	remove an element of the row represented by its index.
public static void c2ir ( double c [ ] , int nc , double hh [ ] , int leng ) { hh [ _num ] = math . exp ( c [ _num ] ) ; for ( int n = _num ; n < leng ; n ++ ) { double d = _num ; int upl = ( n >= nc ) ? nc - _num : n ; for ( int k = _num ; k <= upl ; k ++ ) d += k * c [ k ] * hh [ n - k ] ; hh [ n ] = d / n ; } }	c2ir : the minimum phase impulse response is evaluated from the minimum phase cepstrum.
public void close ( ) { _ncguards = null ; }	kill ncguards , so we do not use outdated mappings unintendedly later on.
public void processindication ( hashtable < string , string > cimnotification ) { string cimindicationtype = getcimindicationtype ( cimnotification ) ; if ( _monitoringpropertiesloader . istologindications ( ) ) { _logger . debug ( _str + getindicationdata ( cimnotification ) ) ; } if ( cimindicationtype != null && cimindicationtype . equals ( cimconstants . cim_alert_indication_type ) ) { if ( _monitoringpropertiesloader . istologindications ( ) ) { _logger . debug ( _str ) ; } _alertprocessor . processindication ( cimnotification ) ; } else if ( cimindicationtype != null && cimindicationtype . equals ( cimconstants . cim_inst_indication_type ) ) { if ( _monitoringpropertiesloader . istologindications ( ) ) { _logger . debug ( _str ) ; } _eventprocessor . processindication ( cimnotification ) ; } else { if ( _monitoringpropertiesloader . istologindications ( ) ) { _logger . debug ( _str , cimindicationtype ) ; } } }	indication will be inserted into cassandra provided timestamp as row key.
public replicationjob createjobforcopytable ( long auditlogid , long auditlogentrycreatetime , table table ) throws stateupdateexception { replicationoperation replicationoperation = hiveutils . ispartitioned ( table ) ? replicationoperation . copy_partitioned_table : replicationoperation . copy_unpartitioned_table ; map < string , string > extras = new hashmap < > ( ) ; extras . put ( persistedjobinfo . audit_log_id_extras_key , long . tostring ( auditlogid ) ) ; extras . put ( persistedjobinfo . audit_log_entry_create_time_key , long . tostring ( auditlogentrycreatetime ) ) ; persistedjobinfo persistedjobinfo = jobinfostore . resilientcreate ( replicationoperation , replicationstatus . pending , replicationutils . getlocation ( table ) , srccluster . getname ( ) , new hiveobjectspec ( table ) , collections . emptylist ( ) , replicationutils . gettldt ( table ) , optional . empty ( ) , optional . empty ( ) , extras ) ; hiveobjectspec spec = new hiveobjectspec ( table ) ; optional < path > tablelocation = replicationutils . getlocation ( table ) ; switch ( replicationoperation ) { case copy_unpartitioned_table : return new replicationjob ( conf , new copyunpartitionedtabletask ( conf , destinationobjectfactory , objectconflicthandler , srccluster , destcluster , spec , tablelocation , directorycopier , _bool ) , onstatechangehandler , persistedjobinfo ) ; case copy_partitioned_table : return new replicationjob ( conf , new copypartitionedtabletask ( conf , destinationobjectfactory , objectconflicthandler , srccluster , destcluster , spec , tablelocation ) , onstatechangehandler , persistedjobinfo ) ; default : throw new runtimeexception ( _str + replicationoperation ) ; } }	create a replication job to copy a table .
synchronized public void releasexmlreader ( xmlreader reader ) { if ( m_readermanager != null ) { m_readermanager . releasexmlreader ( reader ) ; } }	indicates that the xmlreader object is no longer in use for the transform.
public int unfinishsize ( ) { return munfinishqueue . size ( ) ; }	returns have started but not the end of the request queue size .
public void addsample ( int weight , float value ) { ensuresortedbyindex ( ) ; sample newsample = recycledsamplecount > _num ? recycledsamples [ -- recycledsamplecount ] : new sample ( ) ; newsample . index = nextsampleindex ++ ; newsample . weight = weight ; newsample . value = value ; samples . add ( newsample ) ; totalweight += weight ; while ( totalweight > maxweight ) { int excessweight = totalweight - maxweight ; sample oldestsample = samples . get ( _num ) ; if ( oldestsample . weight <= excessweight ) { totalweight -= oldestsample . weight ; samples . remove ( _num ) ; if ( recycledsamplecount < max_recycled_samples ) { recycledsamples [ recycledsamplecount ++ ] = oldestsample ; } } else { oldestsample . weight -= excessweight ; totalweight -= excessweight ; } } }	record a new observation.
private void specialisedpredicates ( ) { doublepredicate doublepredicate = null ; longpredicate longpredicate = null ; }	examples of double and long predicates.
private static final synchronized int nextpoolid ( ) { return ++ poolnumbersequence ; }	returns the next sequence number.
public static boolean seckeyverify ( byte [ ] seckey ) { preconditions . checkargument ( seckey . length == _num ) ; bytebuffer bytebuff = nativeecdsabuffer . get ( ) ; if ( bytebuff == null || bytebuff . capacity ( ) < seckey . length ) { bytebuff = bytebuffer . allocatedirect ( seckey . length ) ; bytebuff . order ( byteorder . nativeorder ( ) ) ; nativeecdsabuffer . set ( bytebuff ) ; } bytebuff . rewind ( ) ; bytebuff . put ( seckey ) ; r . lock ( ) ; try { return secp256k1_ec_seckey_verify ( bytebuff , secp256k1context . getcontext ( ) ) == _num ; } finally { r . unlock ( ) ; } }	libsecp256k1 seckey verify - returns 1 if valid , 0 if invalid.
public treenodeiterator ( node root , boolean preorder ) { m_preorder = preorder ; m_root = root ; m_stack = new arraylist ( ) ; m_stack . add ( root ) ; if ( ! preorder ) { for ( node n = root . getchild ( _num ) ; n != null ; n = n . getchild ( _num ) ) m_stack . add ( n ) ; } }	create a new treenodeiterator over the given subtree .
public static writablenativearray makenativearray ( list objects ) { writablenativearray nativearray = new writablenativearray ( ) ; if ( objects == null ) { return nativearray ; } for ( object elem : objects ) { elem = makenativeobject ( elem ) ; if ( elem == null ) { nativearray . pushnull ( ) ; } else if ( elem instanceof boolean ) { nativearray . pushboolean ( ( boolean ) elem ) ; } else if ( elem instanceof integer ) { nativearray . pushint ( ( integer ) elem ) ; } else if ( elem instanceof double ) { nativearray . pushdouble ( ( double ) elem ) ; } else if ( elem instanceof string ) { nativearray . pushstring ( ( string ) elem ) ; } else if ( elem instanceof writablenativearray ) { nativearray . pusharray ( ( writablenativearray ) elem ) ; } else if ( elem instanceof writablenativemap ) { nativearray . pushmap ( ( writablenativemap ) elem ) ; } else { throw new illegalargumentexception ( _str + elem . getclass ( ) ) ; } } return nativearray ; }	this method converts a list into a nativearray.
@ override public void nodechanged ( ) { log . info ( _str ) ; wakeup ( ) ; }	called when user update the site.
private static nodepair splitblock ( final view view , final function function , final codenode node , final instruction instruction ) { boolean before = _bool ; final list < instruction > beforeinstructions = new arraylist < instruction > ( ) ; final list < instruction > afterinstructions = new arraylist < instruction > ( ) ; for ( final instruction nodeinstruction : node . getinstructions ( ) ) { if ( before ) { beforeinstructions . add ( nodeinstruction ) ; } else { afterinstructions . add ( nodeinstruction ) ; } if ( nodeinstruction == instruction ) { before = _bool ; } } if ( afterinstructions . isempty ( ) ) { return new nodepair ( node , null ) ; } else { final codenode firstnode = view . createcodenode ( function , beforeinstructions ) ; final codenode secondnode = view . createcodenode ( function , afterinstructions ) ; firstnode . setcolor ( node . getcolor ( ) ) ; secondnode . setcolor ( default_block_color ) ; for ( final viewedge edge : node . getincomingedges ( ) ) { final viewedge newedge = view . createedge ( edge . getsource ( ) , firstnode , edge . gettype ( ) ) ; newedge . setcolor ( edge . getcolor ( ) ) ; } for ( final viewedge edge : node . getoutgoingedges ( ) ) { final viewedge newedge = view . createedge ( secondnode , edge . gettarget ( ) , edge . gettype ( ) ) ; newedge . setcolor ( edge . getcolor ( ) ) ; } view . deletenode ( node ) ; return new nodepair ( firstnode , secondnode ) ; } }	splits a code node into two nodes at a function call.
public pair < string , string > objecttostring ( final long shopid , final string currency , final bigdecimal regularprice ) { return new pair < string , string > ( _str + shopid + _str + currency , moneybridge . objecttostring ( regularprice ) ) ; }	create index value for given shop currency and price .
public string readline ( ) throws ioexception { stringbuilder line = new stringbuilder ( ) ; int i ; char c ; i = read ( ) ; if ( i == - _num ) return null ; while ( i > - _num && i != _str && i != _str ) { c = ( char ) ( i & _num ) ; line = line . append ( c ) ; i = read ( ) ; } if ( i == _str ) { if ( ( i = read ( ) ) != _str ) throw new ioexception ( _str + integer . tohexstring ( i ) + _str + line ) ; } return line . tostring ( ) ; }	a method to read a line from the stream up to and including the cr or crlf.
static public void forcecreationofnewindex ( ) { forcecreationofnewindex ( _bool ) ; }	force creation of a new user index without incrementing version.
public signalbarrier ( ) { _owner = null ; }	create a new signalbarrier without an owner .
private static float [ ] normalize ( float [ ] coefficients ) { float accumulator = _num ; for ( int x = _num ; x < coefficients . length ; x ++ ) { accumulator += math . abs ( coefficients [ x ] ) ; } for ( int x = _num ; x < coefficients . length ; x ++ ) { coefficients [ x ] = coefficients [ x ] / accumulator ; } return coefficients ; }	normalizes all filter coefficients to achieve unity ( 1 ) gain , by ensuring that the sum of the absolute value of all coefficients adds up to 1 .
protected void printtrack ( track track ) { defaultentityviewinfo vinfo = ( defaultentityviewinfo ) track . getviewinfo ( ) ; tmpnodebuffer . clear ( ) ; tmpnodebuffer . addall ( track . getnodes ( ) ) ; if ( ! tmpnodebuffer . isempty ( ) ) { printline ( imagebdr , tmpnodebuffer , vinfo , _bool , _bool , null ) ; printpoint ( imagebdr , tmpnodebuffer . get ( tmpnodebuffer . size ( ) - _num ) , vinfo , null ) ; } }	prints a track entity .
private periodformatterbuilder appendsuffix ( periodfieldaffix suffix ) { final object originalprinter ; final object originalparser ; if ( ielementpairs . size ( ) > _num ) { originalprinter = ielementpairs . get ( ielementpairs . size ( ) - _num ) ; originalparser = ielementpairs . get ( ielementpairs . size ( ) - _num ) ; } else { originalprinter = null ; originalparser = null ; } if ( originalprinter == null || originalparser == null || originalprinter != originalparser || ! ( originalprinter instanceof fieldformatter ) ) { throw new illegalstateexception ( _str ) ; } clearprefix ( ) ; fieldformatter newfield = new fieldformatter ( ( fieldformatter ) originalprinter , suffix ) ; ielementpairs . set ( ielementpairs . size ( ) - _num , newfield ) ; ielementpairs . set ( ielementpairs . size ( ) - _num , newfield ) ; ifieldformatters [ newfield . getfieldtype ( ) ] = newfield ; return this ; }	append a field suffix which applies only to the last appended field.
public collection < cube > all ( ) { return collections . unmodifiablecollection ( cubes ) ; }	retrieve a collection of all cubes within this storage . the collection is non - modifiable.
public static short readubyte ( bytebuffer buffer ) { byte b = buffer . get ( ) ; return ( short ) ( b & _num ) ; }	get one unsigned byte as short type.
public static double mosttoxicrow ( gate g ) { return collections . min ( g . get_toxicity ( ) ) ; }	a gate toxicity score = = worst toxicity score among all rows of the truth table.
public multiserver ( ) { this ( networkconfig . default_tcp_port , networkconfig . default_udp_port ) ; }	constructs and configures a multi server with default ports no network operation is done at this point .
protected string urlstring ( ) throws parseexception { stringbuffer retval = new stringbuffer ( ) ; lexer . selectlexer ( _str ) ; while ( lexer . hasmorechars ( ) ) { char la = lexer . lookahead ( _num ) ; if ( la == _str || la == _str || la == _str || la == _str || la == _str ) break ; lexer . consume ( _num ) ; retval . append ( la ) ; } return retval . tostring ( ) ; }	scan forward until you hit a terminating character for a url.
public xmlelement ( byte [ ] encodeddocument ) { if ( encodeddocument == null ) throw new illegalargumentexception ( _str ) ; this . encoded = encodeddocument . clone ( ) ; }	create xml element with utf8 encoded xml document .
public void add ( int position , int height ) { int currheight = mmap . get ( position , - _num ) ; if ( currheight != height ) { if ( currheight == - _num ) { if ( mmap . size ( ) == mmaxsize ) { mmap . delete ( morder . remove ( _num ) ) ; } } else { morder . remove ( ( integer ) position ) ; } mmap . put ( position , height ) ; morder . add ( position ) ; } }	add item height at position if doesn ' t already exist .
public void testmodinversepos2 ( ) { byte abytes [ ] = { _num , _num , _num , _num , - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num , _num , - _num , _num , - _num } ; byte mbytes [ ] = { _num , _num , _num , _num , _num } ; int asign = _num ; int msign = _num ; byte rbytes [ ] = { _num , - _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger modulus = new biginteger ( msign , mbytes ) ; biginteger result = anumber . modinverse ( modulus ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	modinverse : positive number ( another case : a < 0 ).
@ get @ path ( _str ) @ produces ( { mediatype . application_xml , mediatype . application_json } ) @ checkpermission ( roles = { role . security_admin } ) public ostenantlistrestrep listcoprhdostenants ( ) { _log . debug ( _str ) ; list < ostenant > tenants = getostenantsfromcoprhddb ( ) ; return map ( tenants ) ; }	gets a list of coprhd representation of openstack tenants ( ostenant ) .
public int read ( final byte [ ] data ) { init ( ) ; if ( data != null ) { rawdata = bytebuffer . wrap ( data ) ; rawdata . rewind ( ) ; rawdata . order ( byteorder . little_endian ) ; readheader ( ) ; if ( ! err ( ) ) { readcontents ( ) ; if ( framecount < _num ) { status = status_format_error ; } } } else { status = status_open_error ; } return status ; }	reads gif image from byte array.
private void calculateuniquevalue ( object [ ] minvalue , object [ ] uniquevalue ) { for ( int i = _num ; i < measurecount ; i ++ ) { if ( type [ i ] == carboncommonconstants . big_int_measure ) { uniquevalue [ i ] = ( long ) minvalue [ i ] - _num ; } else if ( type [ i ] == carboncommonconstants . big_decimal_measure ) { bigdecimal val = ( bigdecimal ) minvalue [ i ] ; uniquevalue [ i ] = ( val . subtract ( new bigdecimal ( _num ) ) ) ; } else { uniquevalue [ i ] = ( double ) minvalue [ i ] - _num ; } } }	this method will calculate the unique value which will be used as storage key for null values of measures.
@ requestmapping ( value = _str ) public void ssobindingerror ( locale locale , @ pathvariable ( value = _str ) string tenant , httpservletresponse response ) throws ioexception { logger . info ( _str + locale . tostring ( ) + _str + tenant ) ; ssodefaulttenantbindingerror ( locale , response ) ; }	handle request sent with a wrong binding.
public long env_end ( ) { return long . parselong ( fields [ _num ] ) ; }	( since linux 3.
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return strings ; case _num : return hello ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public x509trustchainkeyselector ( x509certificate ... trustedroots ) { _log = loggerfactory . getlogger ( x509trustchainkeyselector . class ) ; checkctorargsnotnull ( trustedroots ) ; _trustanchors = new hashset < trustanchor > ( ) ; for ( x509certificate cert : trustedroots ) { _trustanchors . add ( new trustanchor ( cert , null ) ) ; } }	create an x509trustchainkeyselector instance which will accept a chain rooted at any of the provided certificates .
@ override public void removeattributens ( string namespaceuri , string localname ) { if ( ownerdocument . errorchecking && isreadonly ( ) ) { string msg = dommessageformatter . formatmessage ( dommessageformatter . dom_domain , _str , null ) ; throw new domexception ( domexception . no_modification_allowed_err , msg ) ; } if ( needssyncdata ( ) ) { synchronizedata ( ) ; } if ( attributes == null ) { return ; } attributes . saferemovenameditemns ( namespaceuri , localname ) ; }	introduced in dom level 2.
public boolean drawimage ( image img , affinetransform xform , imageobserver obs ) { if ( img == null ) { return _bool ; } boolean result ; int srcwidth = img . getwidth ( null ) ; int srcheight = img . getheight ( null ) ; if ( srcwidth < _num || srcheight < _num ) { result = _bool ; } else { result = drawimagetoplatform ( img , xform , null , _num , _num , srcwidth , srcheight , _bool ) ; } return result ; }	draws an image , applying a transform from image space into user space before drawing.
public void handlebutton1request ( requestinvocationevent event ) throws modelcontrolexception { serversitemodel model = ( serversitemodel ) getmodel ( ) ; ampropertysheet ps = ( ampropertysheet ) getchild ( property_attribute ) ; string servername = ( string ) getpagesessionattribute ( pg_attr_server_name ) ; string name = ( string ) getdisplayfieldvalue ( tf_name ) ; name = name . trim ( ) ; if ( name . length ( ) > _num ) { try { model . cloneserver ( servername , name ) ; backtrail ( ) ; serversiteviewbean vb = ( serversiteviewbean ) getviewbean ( serversiteviewbean . class ) ; passpgsessionmap ( vb ) ; vb . forwardto ( getrequestcontext ( ) ) ; } catch ( amconsoleexception e ) { setinlinealertmessage ( ccalert . type_error , _str , e . getmessage ( ) ) ; forwardto ( ) ; } } else { setinlinealertmessage ( ccalert . type_error , _str , _str ) ; forwardto ( ) ; } }	handles clone server request .
public static < tk , fv > featurevaluecollection < fv > combine ( derivation < tk , fv > hyp ) { counter < fv > counter = new classiccounter < fv > ( ) ; for ( ; hyp != null ; hyp = hyp . parent ) { if ( hyp . features != null ) { for ( featurevalue < fv > feature : hyp . features ) { counter . incrementcount ( feature . name , feature . value ) ; } } } set < fv > featurenames = new treeset < fv > ( counter . keyset ( ) ) ; featurevaluecollection < fv > combinedlist = new featurevaluelist < fv > ( featurenames . size ( ) ) ; for ( fv feature : featurenames ) { combinedlist . add ( new featurevalue < fv > ( feature , counter . getcount ( feature ) ) ) ; } return combinedlist ; }	aggregate feature values stored in a chain of hypotheses .
public void sendtitles ( ) { if ( listeners == null ) { return ; } stringbuilder labels = new stringbuilder ( _str ) ; labels . append ( _str + bundle . getmessage ( _str ) + _str ) ; labels . append ( _str + manager . getclosedtext ( ) + _str ) ; labels . append ( _str + manager . getthrowntext ( ) + _str ) ; string message = labels . tostring ( ) ; for ( controllerinterface listener : listeners ) { listener . sendpackettodevice ( message ) ; } }	send info on turnouts to devices , not specific to any one turnout . format : ptt ] \ [ value } | { turnoutkey ] \ [ value } | { closedkey ] \ [ value } | { thrownkey.
public static void closesession ( ) throws hibernateexception { session session = ( session ) threadlocal . get ( ) ; threadlocal . set ( null ) ; if ( session != null ) { session . close ( ) ; } }	close the single hibernate session instance .
protected calendar ( ) { zone = timezone . getdefault ( ) ; fields = new int [ field_count ] ; isset = new boolean [ field_count ] ; arefieldsset = istimeset = _bool ; settimeinmillis ( system . currenttimemillis ( ) ) ; }	constructs a calendar with the default time zone.
public static boolean isxml11space ( int c ) { return ( c < _num && ( xml11chars [ c ] & mask_xml11_space ) != _num ) ; }	returns true if the specified character is a space character as amdended in the xml 1.
public void unregisterplayerlistener ( cheerleaderplayerlistener listener ) { checkstate ( ) ; mcheerleaderplayerlisteners . remove ( listener ) ; }	unregister listener used to catch player events .
public outputstream openoutputstream ( uri uri , boolean append ) throws ioexception { assertbackgroundthread ( ) ; switch ( geturitype ( uri ) ) { case uri_type_file : { file localfile = new file ( uri . getpath ( ) ) ; file parent = localfile . getparentfile ( ) ; if ( parent != null ) { parent . mkdirs ( ) ; } return new fileoutputstream ( localfile , append ) ; } case uri_type_content : case uri_type_resource : { assetfiledescriptor assetfd = contentresolver . openassetfiledescriptor ( uri , append ? _str : _str ) ; return assetfd . createoutputstream ( ) ; } } throw new filenotfoundexception ( _str + uri ) ; }	opens a stream to the given uri .
protected integer adjustintegervalue ( integer origvalue , integer minvalue , integer maxvalue ) { integer resultvalue = origvalue ; if ( resultvalue . compareto ( minvalue ) < _num ) { resultvalue = minvalue ; } if ( resultvalue . compareto ( maxvalue ) > _num ) { resultvalue = maxvalue ; } return resultvalue ; }	adjusts an integer value according to the specified range of values .
private void initpaints ( resources res ) { final string monthtypeface = res . getstring ( r . string . date_picker_month_typeface ) ; final string dayofweektypeface = res . getstring ( r . string . date_picker_day_of_week_typeface ) ; final string daytypeface = res . getstring ( r . string . date_picker_day_typeface ) ; final int monthtextsize = res . getdimensionpixelsize ( r . dimen . date_picker_month_text_size ) ; final int dayofweektextsize = res . getdimensionpixelsize ( r . dimen . date_picker_day_of_week_text_size ) ; final int daytextsize = res . getdimensionpixelsize ( r . dimen . date_picker_day_text_size ) ; mmonthpaint . setantialias ( _bool ) ; mmonthpaint . settextsize ( monthtextsize ) ; mmonthpaint . settypeface ( typeface . create ( monthtypeface , _num ) ) ; mmonthpaint . settextalign ( align . center ) ; mmonthpaint . setstyle ( style . fill ) ; mdayofweekpaint . setantialias ( _bool ) ; mdayofweekpaint . settextsize ( dayofweektextsize ) ; mdayofweekpaint . settypeface ( typeface . create ( dayofweektypeface , _num ) ) ; mdayofweekpaint . settextalign ( align . center ) ; mdayofweekpaint . setstyle ( style . fill ) ; mdayselectorpaint . setantialias ( _bool ) ; mdayselectorpaint . setstyle ( style . fill ) ; mdayhighlightpaint . setantialias ( _bool ) ; mdayhighlightpaint . setstyle ( style . fill ) ; mdaypaint . setantialias ( _bool ) ; mdaypaint . settextsize ( daytextsize ) ; mdaypaint . settypeface ( typeface . create ( daytypeface , _num ) ) ; mdaypaint . settextalign ( align . center ) ; mdaypaint . setstyle ( style . fill ) ; }	sets up the text and style properties for painting .
public int size ( ) { return rules . size ( ) ; }	returns the number of rules contained in this grammar .
private void copyarrays ( ) { string [ ] oldsyms = _symbols ; int size = oldsyms . length ; _symbols = new string [ size ] ; system . arraycopy ( oldsyms , _num , _symbols , _num , size ) ; bucket [ ] oldbuckets = _buckets ; size = oldbuckets . length ; _buckets = new bucket [ size ] ; system . arraycopy ( oldbuckets , _num , _buckets , _num , size ) ; }	method called when copy - on - write is needed ; generally when first change is made to a derived symbol table .
@ procedure @ performswrites @ description ( _str ) public stream < relationshiprefactorresult > from ( @ name ( _str ) relationship rel , @ name ( _str ) node newnode ) { relationshiprefactorresult result = new relationshiprefactorresult ( rel . getid ( ) ) ; try { relationship newrel = newnode . createrelationshipto ( rel . getendnode ( ) , rel . gettype ( ) ) ; copyproperties ( rel , newrel ) ; rel . delete ( ) ; return stream . of ( result . withother ( newrel ) ) ; } catch ( exception e ) { return stream . of ( result . witherror ( e ) ) ; } }	redirects a relationships to a new target node .
public static long maxfill ( final long n , final float f ) { return math . min ( ( long ) math . ceil ( n * f ) , n - _num ) ; }	returns the maximum number of entries that can be filled before rehashing .
public static void print ( char x ) { out . print ( x ) ; out . flush ( ) ; }	prints a character to standard output and flushes standard output .
public void clearsourceelements ( ) { for ( pnode node : sourceelements ) { sourcehandle . removesourcehandlefrom ( node ) ; } sourceelements . clear ( ) ; selectionmodel . fireselectionchanged ( ) ; }	clear all source elements .
public static double [ ] [ ] readmatrix ( int numberofrows , int numberofcolumns , boolean ignorefirstline , string filename ) { double [ ] [ ] matrix = new double [ numberofrows ] [ numberofcolumns ] ; try { filereader fr = new filereader ( filename ) ; bufferedreader br = new bufferedreader ( fr ) ; string line ; stringtokenizer tokenizer ; string token ; if ( ignorefirstline ) { br . readline ( ) ; } line = br . readline ( ) ; int rowid = _num ; while ( line != null ) { tokenizer = new stringtokenizer ( line ) ; for ( int i = _num ; i < numberofcolumns ; i ++ ) { token = tokenizer . nexttoken ( ) ; double parsednumber = double . parsedouble ( token ) ; matrix [ rowid ] [ i ] = parsednumber ; } if ( tokenizer . hasmoretokens ( ) ) { throw new runtimeexception ( _str ) ; } line = br . readline ( ) ; rowid ++ ; } if ( rowid != numberofrows ) { throw new runtimeexception ( _str ) ; } } catch ( runtimeexception e ) { throw e ; } catch ( exception e ) { e . printstacktrace ( ) ; throw new runtimeexception ( _str ) ; } return matrix ; }	reads in data from a file .
@ override protected boolean readintobuffer ( int minlength ) { if ( bufferspaceleft ( ) < minlength ) { increasebuffersize ( minlength + currentlyinbuffer ( ) ) ; } else if ( buf . length - writepos < minlength ) { compact ( ) ; } int readsum = _num ; while ( readsum < minlength && ! datagrams . isempty ( ) ) { datagram next = datagrams . removefirst ( ) ; int length = ( int ) next . getduration ( ) ; if ( buf . length < writepos + length ) { increasebuffersize ( writepos + length ) ; } int read = readdatagram ( next , buf , writepos ) ; writepos += read ; readsum += read ; } if ( dataprocessor != null ) { dataprocessor . applyinline ( buf , writepos - readsum , readsum ) ; } return readsum >= minlength ; }	attempt to get more data from the input source.
private int heightofphi ( int phi ) { if ( phi == _num ) { return - _num ; } int tau = _num ; int modul = _num ; while ( phi % modul == _num ) { modul *= _num ; tau += _num ; } return tau - _num ; }	returns the largest h such that 2 ^ h | phi.
@ notnull public clarifaiclient buildsync ( ) { return new clarifaiclientimpl ( this ) ; }	builds the api client , blocking until an access token has been retrieved.
public void mousereleased ( mouseevent e ) { visualizationviewer < ? , ? > vv = ( visualizationviewer < ? , ? > ) e . getsource ( ) ; down = null ; vv . setcursor ( cursor . getpredefinedcursor ( cursor . default_cursor ) ) ; }	unset the ' down ' point and change the cursoe back to the system default cursor.
@ nullable public static class < ? > classforname ( @ nullable string cls , @ nullable class < ? > dflt , boolean includeprimitivetypes ) { class < ? > clazz ; if ( cls == null ) clazz = dflt ; else if ( ! includeprimitivetypes || cls . length ( ) > _num || ( clazz = primitivemap . get ( cls ) ) == null ) { try { clazz = class . forname ( cls ) ; } catch ( classnotfoundexception ignore ) { clazz = dflt ; } } return clazz ; }	gets class for the given name if it can be loaded or default given class .
public string checkwriteprotected ( int residaction , final file ... filestobemodified ) { if ( filestobemodified != null ) { for ( file file : filestobemodified ) { if ( ( file != null ) && ( file . exists ( ) ) && ( ! file . canwrite ( ) ) ) { string action = ( residaction == _num ) ? _str : mcontext . getstring ( residaction ) ; return mcontext . getstring ( r . string . file_err_writeprotected , file . getabsolutepath ( ) , action ) ; } } } return null ; }	check if all files in selectedfilenamestobemodified are not write protected .
@ notnull @ contract ( pure = _bool ) public static string strip ( @ notnull final string s , @ notnull final charfilter filter ) { final stringbuilder result = new stringbuilder ( s . length ( ) ) ; for ( int i = _num ; i < s . length ( ) ; i ++ ) { char ch = s . charat ( i ) ; if ( filter . accept ( ch ) ) { result . append ( ch ) ; } } return result . tostring ( ) ; }	strip out all characters not accepted by given filter.
protected void addcomponent ( xmlcomponent component ) { if ( fcomponents . contains ( component ) ) { return ; } fcomponents . add ( component ) ; addrecognizedparamsandsetdefaults ( component ) ; }	adds a component to the parser configuration.
public void testlocalinstances_distribution ( ) { matsimrandom . reset ( _num ) ; random local1a = matsimrandom . getlocalinstance ( ) ; double value1 = local1a . nextdouble ( ) ; matsimrandom . reset ( _num ) ; random local2a = matsimrandom . getlocalinstance ( ) ; double value2a = local2a . nextdouble ( ) ; random local2b = matsimrandom . getlocalinstance ( ) ; double value2b = local2b . nextdouble ( ) ; asserttrue ( math . abs ( value1 - value2a ) > epsilon ) ; asserttrue ( math . abs ( value2a - value2b ) > epsilon ) ; asserttrue ( math . abs ( value1 - value2b ) > epsilon ) ; }	tests that multiple local instance return different random numbers , and that they are more or less evenly distributed .
public final void test_roundtrip_getkeyspeckey02 ( ) { boolean performed = _bool ; for ( int i = _num ; i < algname . length ; i ++ ) { try { testdatagenerator g = new testdatagenerator ( algname [ i ] [ _num ] , algname [ i ] [ _num ] , privatekeyinfodamaged , null ) ; encryptedprivatekeyinfo epki ; if ( g . ap ( ) == null ) { epki = new encryptedprivatekeyinfo ( algname [ i ] [ _num ] , g . ct ( ) ) ; } else { epki = new encryptedprivatekeyinfo ( g . ap ( ) , g . ct ( ) ) ; } try { epki . getkeyspec ( g . pubk ( ) == null ? g . k ( ) : g . pubk ( ) ) ; fail ( algname [ i ] [ _num ] + _str + algname [ i ] [ _num ] ) ; } catch ( invalidkeyexception e ) { } performed = _bool ; } catch ( testdatagenerator . allowedfailure allowedfailure ) { } catch ( nosuchalgorithmexception allowedfailure ) { } } asserttrue ( _str , performed ) ; }	encrypted data contains invalid pkcs8 key info encoding.
public void clear ( ivalidatable bean ) { for ( binding b : _optcomponents . values ( ) ) { b . clear ( bean ) ; } for ( binding b : _bindings . values ( ) ) { b . clear ( bean ) ; } _modified = _bool ; }	clear all components , set them to their default values.
public boolean hascredentials ( ) { return _hascredentials ; }	checks if the credentials are generated .
public boolean isrecursiveattrset ( elemattributeset attrset ) { if ( null == m_attrsetstack ) { m_attrsetstack = new stack ( ) ; } if ( ! m_attrsetstack . empty ( ) ) { int loc = m_attrsetstack . search ( attrset ) ; if ( loc > - _num ) { return _bool ; } } return _bool ; }	check to see if this is a recursive attribute definition .
public void clear ( absolutetableidentifier absolutetableidentifier ) { tablelockmap . remove ( absolutetableidentifier ) ; tablesegmentmap . remove ( absolutetableidentifier ) ; }	remove all the details of a table this will be used in case of drop table.
public static inputstream toinputstream ( charsequence input ) { return toinputstream ( input . tostring ( ) ) ; }	convert the specified charsequence to an input stream , encoded as bytes using the default character encoding of the platform .
@ override public void process ( number tuple ) { values . add ( tuple . doublevalue ( ) ) ; }	computes sum and count with each tuple.
public void grantwritepermission ( collection attributenames ) { iterator it = attributenames . iterator ( ) ; if ( it != null ) { while ( it . hasnext ( ) ) { string temp = ( string ) it . next ( ) ; writables . add ( temp . tolowercase ( ) ) ; } } }	grant write permission to attributes .
public void savedata ( file file ) throws ioexception { synchronized ( accumulators ) { objectoutputstream oos = null ; try { oos = new objectoutputstream ( new fileoutputstream ( file ) ) ; oos . writeobject ( accumulators ) ; } finally { if ( oos != null ) { oos . close ( ) ; } } } }	saves all results stored in this controller to the specified file .
public static ingredient fromcursor ( cursor cursor ) { ingredient ingredient = new ingredient ( ) ; for ( int c = _num ; c < cursor . getcolumncount ( ) ; c ++ ) { string columnname = cursor . getcolumnname ( c ) ; if ( columnname . equals ( recipeingredienttable . amount_column ) ) { ingredient . setamount ( cursor . getstring ( c ) ) ; } else if ( columnname . equals ( recipeingredienttable . description_column ) ) { ingredient . setdescription ( cursor . getstring ( c ) ) ; } } return ingredient ; }	static helper method for populating attributes from a database cursor .
public void append ( char c [ ] , int off , int len ) { int restlength = buffer . length - pos ; if ( len < restlength ) { system . arraycopy ( c , off , buffer , pos , len ) ; pos += len ; } else { system . arraycopy ( c , off , buffer , pos , restlength ) ; curr . next = new entity ( buffer ) ; curr = curr . next ; length += buffer . length ; buffer = new char [ ( buffer . length > len - restlength ) ? buffer . length : len - restlength ] ; system . arraycopy ( c , off + restlength , buffer , _num , len - restlength ) ; pos = len - restlength ; } }	method to append a part of a char array.
public boolean contains ( string voicename ) { return ( getvoice ( voicename ) != null ) ; }	check if there is a voice provides with the given name .
public static boolean isenterpriseedition ( string serverversion ) { return serverversion . contains ( _str ) || serverversion . contains ( _str ) || serverversion . contains ( _str ) ; }	checks whether the given server version string is a mysql enterprise edition.
@ override public categoryitemrendererstate initialise ( graphics2d g2 , rectangle2d dataarea , categoryplot plot , int rendererindex , plotrenderinginfo info ) { categoryitemrendererstate state = super . initialise ( g2 , dataarea , plot , rendererindex , info ) ; categoryaxis domainaxis = getdomainaxis ( plot , rendererindex ) ; categorydataset dataset = plot . getdataset ( rendererindex ) ; if ( dataset != null ) { int columns = dataset . getcolumncount ( ) ; int rows = dataset . getrowcount ( ) ; double space = _num ; plotorientation orientation = plot . getorientation ( ) ; if ( orientation == plotorientation . horizontal ) { space = dataarea . getheight ( ) ; } else if ( orientation == plotorientation . vertical ) { space = dataarea . getwidth ( ) ; } double maxwidth = space * getmaximumbarwidth ( ) ; double categorymargin = _num ; double currentitemmargin = _num ; if ( columns > _num ) { categorymargin = domainaxis . getcategorymargin ( ) ; } if ( rows > _num ) { currentitemmargin = getitemmargin ( ) ; } double used = space * ( _num - domainaxis . getlowermargin ( ) - domainaxis . getuppermargin ( ) - categorymargin - currentitemmargin ) ; if ( ( rows * columns ) > _num ) { state . setbarwidth ( math . min ( used / ( dataset . getcolumncount ( ) * dataset . getrowcount ( ) ) , maxwidth ) ) ; } else { state . setbarwidth ( math . min ( used , maxwidth ) ) ; } } return state ; }	initialises the renderer . this method gets called once at the start of the process of drawing a chart .
luastring loadstring ( ) throws ioexception { int size = this . luacsizeofsizet == _num ? ( int ) loadint64 ( ) : loadint ( ) ; if ( size == _num ) return null ; byte [ ] bytes = new byte [ size ] ; is . readfully ( bytes , _num , size ) ; return luastring . valueof ( bytes , _num , bytes . length - _num ) ; }	load a lua strin gvalue from the input stream.
protected abstractpreferences ( abstractpreferences parent , string name ) { if ( parent == null ) { if ( ! name . equals ( _str ) ) throw new illegalargumentexception ( _str + name + _str ) ; this . absolutepath = _str ; root = this ; } else { if ( name . indexof ( _str ) != - _num ) throw new illegalargumentexception ( _str + name + _str ) ; if ( name . equals ( _str ) ) throw new illegalargumentexception ( _str ) ; root = parent . root ; absolutepath = ( parent == root ? _str + name : parent . absolutepath ( ) + _str + name ) ; } this . name = name ; this . parent = parent ; }	creates a preference node with the specified parent and the specified name relative to its parent .
static class < ? > canonicalize ( class < ? > t , int how ) { class < ? > ct ; if ( t == object . class ) { } else if ( ! t . isprimitive ( ) ) { switch ( how ) { case unwrap : ct = wrapper . asprimitivetype ( t ) ; if ( ct != t ) return ct ; break ; case raw_return : case erase : return object . class ; } } else if ( t == void . class ) { switch ( how ) { case raw_return : return int . class ; case wrap : return void . class ; } } else { switch ( how ) { case wrap : return wrapper . aswrappertype ( t ) ; case ints : if ( t == int . class || t == long . class ) return null ; if ( t == double . class ) return long . class ; return int . class ; case longs : if ( t == long . class ) return null ; return long . class ; case raw_return : if ( t == int . class || t == long . class || t == float . class || t == double . class ) return null ; return int . class ; } } return null ; }	canonicalize the given return or param type.
protected string extractsubstring ( string pszsrc ) { int nbracket = _num ; int i ; string pszreturn ; for ( i = _num ; i < pszsrc . length ( ) && ( nbracket > _num || pszsrc . charat ( i ) != _str ) ; i ++ ) { if ( pszsrc . charat ( i ) == _str ) { nbracket ++ ; } else if ( pszsrc . charat ( i ) == _str ) { nbracket -- ; } } if ( pszsrc . charat ( _num ) == _str ) { pszreturn = pszsrc . substring ( _num , i - _num ) ; } else { pszreturn = pszsrc . substring ( _num , i ) ; } return pszreturn ; }	extract a substring terminated by a comma ( or end of string ).
public void read ( appendable dest ) throws ioexception { if ( _inputstream == null ) throw new ioexception ( _str ) ; while ( _bool ) { if ( _start >= _end ) { _start = _num ; _end = _inputstream . read ( _bytes , _num , _bytes . length ) ; if ( _end <= _num ) { break ; } } byte b = _bytes [ _start ] ; if ( b >= _num ) { dest . append ( ( char ) b ) ; _start ++ ; } else { int code = read2 ( ) ; if ( code < _num ) { dest . append ( ( char ) code ) ; } else if ( code <= _num ) { dest . append ( ( char ) ( ( ( code - _num ) > > _num ) + _num ) ) ; dest . append ( ( char ) ( ( ( code - _num ) & _num ) + _num ) ) ; } else { throw new charconversionexception ( _str + integer . tohexstring ( code ) + _str ) ; } } } }	reads characters into the specified appendable.
public boolean ismonitoring ( ) { return m_monitor . ismonitoring ( ) ; }	returns whether the thread is still running .
static final color hextocolor ( string value ) { string digits ; int n = value . length ( ) ; if ( value . startswith ( _str ) ) { digits = value . substring ( _num , math . min ( value . length ( ) , _num ) ) ; } else { digits = value ; } string hstr = _str + digits ; color c ; try { c = color . decode ( hstr ) ; } catch ( numberformatexception nfe ) { c = null ; } return c ; }	convert a " # ffffff " hex string to a color.
public final boolean contentequals ( java . lang . charsequence csq ) { if ( csq . length ( ) != _length ) return _bool ; for ( int i = _num ; i < _length ; ) { char c = _high [ i > > b1 ] [ i & m1 ] ; if ( csq . charat ( i ++ ) != c ) return _bool ; } return _bool ; }	indicates if this text builder has the same character content as the specified character sequence .
private void populateavailabledatastores ( ) { dataaccessfactory fac ; logger . debug ( _str ) ; iterator < datastorefactoryspi > iterator = datastorefinder . getavailabledatastores ( ) ; while ( iterator . hasnext ( ) ) { fac = ( dataaccessfactory ) iterator . next ( ) ; logger . debug ( _str + fac . getdisplayname ( ) ) ; availabledatastorelist . add ( fac . getdisplayname ( ) ) ; } }	populates the list of available data stores that can be connected to .
protected void add ( double value , int group ) { if ( ( group < _num ) || ( group >= numberofgroups ) ) { throw new illegalargumentexception ( _str ) ; } data . add ( new observation ( value , group ) ) ; }	adds a new observation with the specified value and group .
protected static string makeoptionstring ( script script ) { stringbuffer result ; enumeration < option > enm ; option option ; result = new stringbuffer ( _str ) ; result . append ( _str ) ; result . append ( _str ) ; result . append ( _str ) ; result . append ( _str ) ; result . append ( _str ) ; enm = script . listoptions ( ) ; while ( enm . hasmoreelements ( ) ) { option = enm . nextelement ( ) ; result . append ( option . synopsis ( ) + _str ) ; result . append ( option . description ( ) + _str ) ; } result . append ( _str ) ; result . append ( _str ) ; result . append ( _str ) ; result . append ( _str ) ; return result . tostring ( ) ; }	make up the help string giving all the command line options .
public registrationbuilder addcontact ( uri contact ) { contacts . add ( contact ) ; return this ; }	add a contact uri to the list of contacts .
public static void closequietly ( autocloseable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( runtimeexception rethrown ) { throw rethrown ; } catch ( exception ignored ) { } } }	closes ' closeable ' , ignoring any checked exceptions.
string formattime ( int hour , int minute ) { string s = _str ; string t = integer . tostring ( hour ) ; if ( t . length ( ) == _num ) { s = t + _str ; } else if ( t . length ( ) == _num ) { s = _str + t + _str ; } t = integer . tostring ( minute ) ; if ( t . length ( ) == _num ) { s = s + t ; } else if ( t . length ( ) == _num ) { s = s + _str + t ; } if ( s . length ( ) != _num ) { s = _str ; } return s ; }	formats time to hh : mm given integer hour and minute.
public boolean isempty ( ) { return ( sentencetype == sentencetype . undefined ) && expressions . isempty ( ) ; }	return true if the sentence is empty .
@ override public void init ( abstractaddressbookmanager aboomgr ) { setaddressbookmanager ( aboomgr ) ; reloadsettings ( ) ; try { connection = drivermanager . getconnection ( identitydb_connect_string ) ; } catch ( sqlexception e ) { logger . error ( _str + identitydb_connect_string , e ) ; } statement statement ; try { statement = connection . createstatement ( ) ; statement . setquerytimeout ( _num ) ; statement . executeupdate ( _str + table_identity + _str ) ; statement . executeupdate ( _str + table_cloudprovider + _str ) ; statement . executeupdate ( _str + table_cloudprovider_map + _str ) ; aboomgr . init ( ) ; } catch ( sqlexception e ) { logger . error ( _str , e ) ; } finally { if ( connection != null ) { try { connection . close ( ) ; } catch ( sqlexception e ) { logger . error ( _str , e ) ; } } } }	creates the initial set of db tables for the sqlite db to store our identity and addressbook entries.
private buffer checkerrorpacket ( int command ) throws sqlexception { buffer resultpacket = null ; this . serverstatus = _num ; try { resultpacket = reuseandreadpacket ( this . reusablepacket ) ; } catch ( sqlexception sqlex ) { throw sqlex ; } catch ( exception fallthru ) { throw sqlerror . createcommunicationsexception ( this . connection , this . lastpacketsenttimems , this . lastpacketreceivedtimems , fallthru , getexceptioninterceptor ( ) ) ; } checkerrorpacket ( resultpacket ) ; return resultpacket ; }	checks for errors in the reply packet , and if none , returns the reply packet , ready for reading.
public void applysettings ( boolean loadcorecomponents ) throws applysettingsexception { list < string > errors = new arraylist < string > ( _num ) ; applytorrentdatasavefoldersettings ( errors ) ; applytorrentseedingsettings ( errors ) ; if ( ! errors . isempty ( ) ) { throw new applysettingsexception ( stringutils . explode ( errors , _str ) ) ; } }	overrides applysettings method in setupwindow.
public boolean shouldselectcell ( eventobject e ) { return _bool ; }	the editing cell should be selected or not.
method_info findmethod ( string s ) { method_info m ; int i ; for ( i = _num ; i < methods_count ; i ++ ) { m = methods [ i ] ; if ( s . equals ( m . toname ( constant_pool ) ) ) { return m ; } } return null ; }	locates a method by name .
private void waituntilreadable ( ) throws ioexception { readtimeout . enter ( ) ; try { while ( readbuffer . size ( ) == _num && ! finished && ! closed && errorcode == null ) { waitforio ( ) ; } } finally { readtimeout . exitandthrowiftimedout ( ) ; } }	returns once the source is either readable or finished .
public static < x extends exception > string tostring ( iteration < ? , x > iter , string separator ) throws x { stringbuilder sb = new stringbuilder ( ) ; tostring ( iter , separator , sb ) ; return sb . tostring ( ) ; }	converts an iteration to a string by concatenating all of the string representations of objects in the iteration , divided by a separator .
@ suppresswarnings ( _str ) @ override public boolean contains ( final object obj ) { if ( null != obj ) { iterator < e > it = new arraydequeiterator < e > ( ) ; while ( it . hasnext ( ) ) { if ( obj . equals ( ( e ) it . next ( ) ) ) { return _bool ; } } } return _bool ; }	returns true if the specified element is in the deque .
public static synchronized gridtestprintstream acquireerr ( ) { if ( testerr == null ) testerr = new gridtestprintstream ( syserr ) ; if ( errcnt == _num ) system . seterr ( testerr ) ; errcnt ++ ; return testerr ; }	acquires output stream for logging errors in tests .
private void writeobject ( objectoutputstream out ) throws ioexception { out . defaultwriteobject ( ) ; dowriteobject ( out ) ; }	write the map out using a custom routine .
private static boolean ispropertyname ( string name ) { return ( ( name . length ( ) > _num ) && character . isuppercase ( name . charat ( _num ) ) ) || ( ( name . length ( ) > _num ) && character . isuppercase ( name . charat ( _num ) ) ) ; }	determine if this method name suffix is a legitimate bean property name.
public void removertcplistener ( rtcpeventlistener listener ) { if ( slogger . isactivated ( ) ) { slogger . debug ( _str ) ; } mlisteners . removeelement ( listener ) ; }	remove a rtcp event listener.
private static void collectalltimes ( tree tree , noderef node , noderef [ ] excludebelow , arraylist times , arraylist < integer > childs ) { times . add ( new comparabledouble ( tree . getnodeheight ( node ) ) ) ; childs . add ( tree . getchildcount ( node ) ) ; for ( int i = _num ; i < tree . getchildcount ( node ) ; i ++ ) { noderef child = tree . getchild ( node , i ) ; if ( excludebelow == null ) { collectalltimes ( tree , child , excludebelow , times , childs ) ; } else { boolean include = _bool ; for ( noderef anexcludebelow : excludebelow ) { if ( anexcludebelow . getnumber ( ) == child . getnumber ( ) ) { include = _bool ; break ; } } if ( include ) collectalltimes ( tree , child , excludebelow , times , childs ) ; } } }	extract coalescent times and tip information into arraylist times from tree .
protected void painttext ( final graphics g , final jcomponent c , final rectangle localtextrect , final string text ) { final graphics2d g2d = g instanceof graphics2d ? ( graphics2d ) g : null ; final abstractbutton b = ( abstractbutton ) c ; final buttonmodel model = b . getmodel ( ) ; final fontmetrics fm = g . getfontmetrics ( ) ; final int mnemonicindex = aquamnemonichandler . ismnemonichidden ( ) ? - _num : b . getdisplayedmnemonicindex ( ) ; if ( model . isenabled ( ) ) { g . setcolor ( b . getforeground ( ) ) ; } else { g . setcolor ( defaultdisabledtextcolor ) ; } swingutilities2 . drawstringunderlinecharat ( c , g , text , mnemonicindex , localtextrect . x , localtextrect . y + fm . getascent ( ) ) ; }	as of java 2 platform v 1.
public static constraintwidget [ ] infertablelist ( widgetsscene list ) { for ( constraintwidget widget : list . getwidgets ( ) ) { widget . resetanchors ( ) ; } return infertablelist ( list . getroot ( ) ) ; }	given a collection of widgets evaluates probability of a connection and makes connections.
public void ifpresent ( longconsumer consumer ) { if ( ispresent ) consumer . accept ( value ) ; }	have the specified consumer accept the value if a value is present , otherwise do nothing .
public void update ( string [ ] columns , object [ ] columnvalues , string [ ] conditions , object [ ] conditionvalues ) throws dataaccessexception { if ( columns . length != columnvalues . length || conditions . length != conditionvalues . length ) { logger . error ( _str ) ; return ; } object [ ] values = arrays . copyof ( columnvalues , columnvalues . length + conditionvalues . length ) ; system . arraycopy ( conditionvalues , _num , values , columnvalues . length , conditionvalues . length ) ; final string sql = preparedstatementutil . prepareupdatetemplatewithcolumn ( tablename , columns , conditions ) ; execute ( sql , values ) ; }	use jdbc template preparedstatement to update row in database by setting columns with conditions.
public static string replicasetusedin ( string addresses ) { if ( addresses . startswith ( _str ) ) { return null ; } int index = addresses . indexof ( _str ) ; if ( index < _num ) return null ; return addresses . substring ( _num , index ) ; }	find the name of the replica set precedes the host addresses .
public void onprogress ( long byteswritten , long totalsize ) { log . v ( log_tag , string . format ( _str , byteswritten , totalsize , ( totalsize > _num ) ? ( byteswritten * _num / totalsize ) * _num : - _num ) ) ; }	fired when the request progress , override to handle in your own code.
public string self ( typedeclaration decl ) { if ( decl instanceof constructor ) { decl = ( typedeclaration ) decl . getcontainer ( ) ; } string name = jsutils . escapestringliteral ( decl . getname ( ) ) ; if ( decl . isshared ( ) || decl . istoplevel ( ) ) { name += nestingsuffix ( decl , _bool ) ; } else { name = _str + long . tostring ( getuid ( decl ) , _num ) ; } return string . format ( _str , character . tolowercase ( name . charat ( _num ) ) , name . substring ( _num ) ) ; }	determine the identifier to be used for the self variable of the given type .
public double elapsedtime ( ) { long now = threadtimer . getcurrentthreadcputime ( ) ; return ( now - start ) / nanoseconds_per_second ; }	returns the elapsed cpu time ( in seconds ) since the stopwatch was created .
public static void sortlist ( list list ) { if ( systemutils . is_java_1_7 && list instanceof copyonwritearraylist ) { list templist = new arraylist ( list ) ; collections . sort ( templist ) ; list . clear ( ) ; list . addall ( templist ) ; } else { collections . sort ( list ) ; } }	sorts the list . since copyonwritearraylists are not sortable with java7 , we need this wrapper to sort it differently on java7 .
public static < t > t [ ] concat ( t [ ] first , t [ ] second , class < t > type ) { t [ ] result = newarray ( type , first . length + second . length ) ; system . arraycopy ( first , _num , result , _num , first . length ) ; system . arraycopy ( second , _num , result , first . length , second . length ) ; return result ; }	returns a new array that contains the concatenated contents of two arrays .
public synchronized void writetoremote ( byte b ) { remotebuffer . add ( b ) ; }	used by sut to simulate sending of data to remote host.
@ override public void drawseries ( canvas canvas , paint paint , list < float > points , list < double > values , xyseriesrenderer seriesrenderer , supportseriesrender supportseriesrender , float yaxisvalue , int seriesindex , int startindex ) { int seriesnr = mdataset . getseriescount ( ) ; int length = points . size ( ) ; paint . setcolor ( seriesrenderer . getcolor ( ) ) ; paint . setstyle ( style . fill ) ; float halfdiffx = gethalfdiffx ( points , length , seriesnr ) ; int start = _num ; if ( startindex > _num ) { start = _num ; } for ( int i = start ; i < length ; i += _num ) { if ( points . size ( ) > i + _num ) { float xmin = points . get ( i ) ; float ymin = points . get ( i + _num ) ; float xmax = points . get ( i + _num ) ; float ymax = points . get ( i + _num ) ; drawbar ( canvas , xmin , ymin , xmax , ymax , halfdiffx , seriesnr , seriesindex , paint ) ; } } paint . setcolor ( seriesrenderer . getcolor ( ) ) ; }	the graphical representation of a series .
private void begingesture ( int scrolloffsety , int scrollextenty ) { minitialtranslationy = gettranslationy ( ) ; boolean isinitiallyvisible = minitialtranslationy < mtotalheight ; int startingy = isinitiallyvisible ? scrolloffsety : math . min ( scrolloffsety , mtotalheight ) ; minitialoffsety = startingy + scrollextenty ; }	records the conditions of the page when a gesture is initiated .
@ override public void add ( string ... identifiers ) { whitelist . addall ( arrays . aslist ( identifiers ) ) ; }	adds identifiers to the exclusion strategy .
public static void clear ( ) { shopid . set ( _num ) ; shopcode . set ( _str ) ; }	clear thread locals at the end of the request.
@ override public boolean communicationinitiated ( ) { return bugspopulated . getcount ( ) == _num && communicationinitiated && networkclient . ready ( ) ; }	returns true if communication has already been initiated ( and perhaps completed ) .
@ override public void dump ( string prefix , filedescriptor fd , printwriter writer , string [ ] args ) { super . dump ( prefix , fd , writer , args ) ; writer . print ( prefix ) ; writer . print ( _str ) ; writer . println ( rawquery ) ; writer . print ( prefix ) ; writer . print ( _str ) ; writer . println ( arrays . tostring ( args ) ) ; }	writes a semi - user - readable roster of contents to supplied output .
public void addcontigfield ( contigfield field ) { addidfield ( mcontiglines , field ) ; }	add an alt field.
boolean removeindexentry ( string resourcename , string policyname ) { iterator iter = toplevelentries . iterator ( ) ; boolean processed = _bool ; while ( ! processed && ( iter . hasnext ( ) ) ) { resourceindexentry resourceindexentry = ( resourceindexentry ) iter . next ( ) ; if ( resourceindexentry . removeindexentry ( resourcetype , resourcename , policyname ) ) { processed = _bool ; } } return processed ; }	removes an index entry.
public static double pdf ( double x , double mu , double shape ) { if ( ! ( x > _num ) || x == double . positive_infinity ) { return _num ; } final double v = ( x - mu ) / mu ; double t1 = math . sqrt ( shape / ( mathutil . twopi * x * x * x ) ) ; return t1 > _num ? t1 * math . exp ( - shape * v * v * _num / x ) : _num ; }	probability density function of the wald distribution .
@ override public void onstoptrackingtouch ( seekbar seekbar ) { final int pos = mitemlist . indexof ( mselectedtracker ) ; final int delta = _num / mitemlist . size ( ) ; cp_mover . setprogress ( pos * delta + delta / _num ) ; }	set the seek bar position relative to the selected button .
public static int maxprofit ( int [ ] prices ) { if ( prices == null || prices . length < _num ) { return _num ; } int max = _num ; int min = prices [ _num ] ; for ( int i = _num ; i < prices . length ; i ++ ) { min = math . min ( min , prices [ i ] ) ; if ( prices [ i ] > prices [ i - _num ] ) { max = math . max ( max , prices [ i ] - min ) ; } } return max ; }	optimized bottom - up approach o ( n ) time , o ( 1 ) space just record yesterday ' s profit update min , max and profit if next price is bigger , it ' s only possible to update the profit if next price is smaller or equal , it ' s only possible to update min.
public void add ( string string ) { elements . add ( string == null ? jsonnull . instance : new jsonprimitive ( string ) ) ; }	adds the specified string to self .
public void componentadded ( containerevent e ) { layer childlayer = ( layer ) e . getchild ( ) ; addprojectionlistener ( childlayer ) ; if ( ! removedlayers . removeelement ( childlayer ) ) { addedlayers . addelement ( childlayer ) ; } changelayers ( e ) ; }	containerlistener interface method . should not be called directly . part of the containerlistener interface , and it ' s here to make the mapbean a good container citizen .
public void processinginstruction ( string target , string data ) throws saxexception { charactersflush ( ) ; int dataindex = m_data . size ( ) ; m_previous = addnode ( dtm . processing_instruction_node , dtm . processing_instruction_node , m_parents . peek ( ) , m_previous , - dataindex , _bool ) ; m_data . addelement ( m_valuesorprefixes . stringtoindex ( target ) ) ; m_values . addelement ( data ) ; m_data . addelement ( m_valueindex ++ ) ; }	override the processinginstruction ( ) interface in sax2dtm2.
protected void panic ( string msg ) throws saxexception { saxparseexception spe = new saxparseexception ( msg , this ) ; mhanderr . fatalerror ( spe ) ; throw spe ; }	notifies the handler about fatal parsing error .
private void updatenamespacepermissions ( usernamespaceauthorizationentity usernamespaceauthorizationentity , list < namespacepermissionenum > namespacepermissions ) { usernamespaceauthorizationentity . setreadpermission ( namespacepermissions . contains ( namespacepermissionenum . read ) ) ; usernamespaceauthorizationentity . setwritepermission ( namespacepermissions . contains ( namespacepermissionenum . write ) ) ; usernamespaceauthorizationentity . setexecutepermission ( namespacepermissions . contains ( namespacepermissionenum . execute ) ) ; usernamespaceauthorizationentity . setgrantpermission ( namespacepermissions . contains ( namespacepermissionenum . grant ) ) ; }	sets relative flags on the user namespace authorization entity as per specified list of namespace permissions .
public static void report ( ) { if ( ! booted ) return ; controllerthread . report ( ) ; runtimemeasurements . report ( ) ; for ( enumeration < organizer > e = organizers . elements ( ) ; e . hasmoreelements ( ) ; ) { organizer organizer = e . nextelement ( ) ; organizer . report ( ) ; } if ( options . final_report_level >= _num ) { edgecounts . dumpcounts ( ) ; dcg . dumpgraph ( ) ; } if ( options . report_interrupt_stats ) { vm . syswriteln ( _str ) ; vm . syswriteln ( _str , rvmthread . timerticks ) ; vm . syswriteln ( _str , controllerclock ) ; vm . syswriteln ( _str , ( int ) methodsamples . gettotalnumberofsamples ( ) ) ; } }	this method is called when the vm is exiting to provide a hook to allow the adaptive optimization subsystem to generate a summary report.
public static set < ? > convertarraytoset ( object [ ] source ) { set < object > set = new hashset < object > ( ) ; for ( object element : source ) { set . add ( element ) ; } return set ; }	convert array to set , removing duplicates.
public static int intersectlinerectangle ( line2d l , rectangle2d r , point2d [ ] pts ) { double a1x = l . getx1 ( ) , a1y = l . gety1 ( ) ; double a2x = l . getx2 ( ) , a2y = l . gety2 ( ) ; double mxx = r . getmaxx ( ) , mxy = r . getmaxy ( ) ; double mnx = r . getminx ( ) , mny = r . getminy ( ) ; if ( pts [ _num ] == null ) pts [ _num ] = new point2d . double ( ) ; if ( pts [ _num ] == null ) pts [ _num ] = new point2d . double ( ) ; int i = _num ; if ( intersectlineline ( mnx , mny , mxx , mny , a1x , a1y , a2x , a2y , pts [ i ] ) > _num ) i ++ ; if ( intersectlineline ( mxx , mny , mxx , mxy , a1x , a1y , a2x , a2y , pts [ i ] ) > _num ) i ++ ; if ( i == _num ) return i ; if ( intersectlineline ( mxx , mxy , mnx , mxy , a1x , a1y , a2x , a2y , pts [ i ] ) > _num ) i ++ ; if ( i == _num ) return i ; if ( intersectlineline ( mnx , mxy , mnx , mny , a1x , a1y , a2x , a2y , pts [ i ] ) > _num ) i ++ ; return i ; }	compute the intersection of a line and a rectangle .
public static string cidrmasktonetmask ( string cidrmask ) { if ( cidrmask == null ) { return null ; } int cidrmaskvalue = _num ; try { cidrmaskvalue = integer . parseint ( cidrmask ) ; } catch ( numberformatexception e ) { return null ; } int cidrmaskfull = _num << ( _num - cidrmaskvalue ) ; int cidrmaskbits1 = cidrmaskfull > > _num & _num ; int cidrmaskbits2 = cidrmaskfull > > _num & _num ; int cidrmaskbits3 = cidrmaskfull > > _num & _num ; int cidrmaskbits4 = cidrmaskfull > > _num & _num ; stringbuffer netmaskbuf = new stringbuffer ( ) ; netmaskbuf . append ( cidrmaskbits1 ) ; netmaskbuf . append ( _str ) ; netmaskbuf . append ( cidrmaskbits2 ) ; netmaskbuf . append ( _str ) ; netmaskbuf . append ( cidrmaskbits3 ) ; netmaskbuf . append ( _str ) ; netmaskbuf . append ( cidrmaskbits4 ) ; return netmaskbuf . tostring ( ) ; }	transforms a cidr formatted mask into a regular network mask.
public boolean inbounds ( mouseevent e ) { return e . getx ( ) > x && e . getx ( ) < x + width && e . gety ( ) > y && e . gety ( ) < y + height ; }	checks if the mouse is within the bounds of this object .
public classpath ( @ nonnull iterable < dexfile > classpath , boolean checkpackageprivateaccess ) { iterable < dexfile > dexfiles = iterables . concat ( classpath , lists . newarraylist ( getbasicclasses ( ) ) ) ; unknownclass = new unknownclassproto ( this ) ; loadedclasses . put ( unknownclass . gettype ( ) , unknownclass ) ; this . checkpackageprivateaccess = checkpackageprivateaccess ; loadprimitivetype ( _str ) ; loadprimitivetype ( _str ) ; loadprimitivetype ( _str ) ; loadprimitivetype ( _str ) ; loadprimitivetype ( _str ) ; loadprimitivetype ( _str ) ; loadprimitivetype ( _str ) ; loadprimitivetype ( _str ) ; loadprimitivetype ( _str ) ; for ( dexfile dexfile : dexfiles ) { for ( classdef classdef : dexfile . getclasses ( ) ) { classdef prev = availableclasses . get ( classdef . gettype ( ) ) ; if ( prev == null ) { availableclasses . put ( classdef . gettype ( ) , classdef ) ; } } } }	creates a new classpath instance that can load classes from the given dex files.
private boolean asktosave ( ) { if ( mainframe . isprojectchanged ( ) ) { int response = joptionpane . showconfirmdialog ( mainframe , l10n . getlocalstring ( _str , _str ) , l10n . getlocalstring ( _str , _str ) , joptionpane . yes_no_cancel_option , joptionpane . warning_message ) ; if ( response == joptionpane . yes_option ) { if ( mainframe . getsavefile ( ) != null ) { save ( ) ; } else { saveas ( ) ; } } else if ( response == joptionpane . cancel_option ) { return _bool ; } } return _bool ; }	returns true if cancelled.
public mapcursor addcursor ( mapcursor cursor ) { cursors . add ( cursor ) ; return cursor ; }	add a cursor to the collection .
private boolean discardupstreammediachunks ( int queuelength ) { if ( mediachunks . size ( ) <= queuelength ) { return _bool ; } long starttimeus = _num ; long endtimeus = mediachunks . getlast ( ) . endtimeus ; basemediachunk removed = null ; while ( mediachunks . size ( ) > queuelength ) { removed = mediachunks . removelast ( ) ; starttimeus = removed . starttimeus ; } samplequeue . discardupstreamsamples ( removed . getfirstsampleindex ( ) ) ; notifyupstreamdiscarded ( starttimeus , endtimeus ) ; return _bool ; }	discard upstream media chunks until the queue length is equal to the length specified .
public metalinkfilebuilder addfile ( string name ) { metalinkfilebuilder newfile = new metalinkfilebuilder ( name ) ; files . add ( newfile ) ; return newfile ; }	adds a file to this metalink document.
private void sendafterconnect ( channel ch , nettychannelcontext contextfinal , operation request , nettychannelgroup group ) { if ( request . getstatuscode ( ) < operation . status_code_failure_threshold ) { request . complete ( ) ; } else { request . fail ( request . getstatuscode ( ) ) ; } }	now that the connection is open ( and if using http / 2 , settings have been negotiated ) , send the request .
protected string checkproduction ( final territory to , final collection < unit > units , final playerid player ) { final list < territory > producers = getallproducers ( to , player , units ) ; if ( producers . isempty ( ) ) { return _str + to . getname ( ) ; } collections . sort ( producers , getbestproducercomparator ( to , units , player ) ) ; if ( ! getcanallunitswithrequiresunitsbeplacedcorrectly ( units , to ) ) { return _str ; } final int maxunitstobeplaced = getmaxunitstobeplaced ( units , to , player , _bool ) ; if ( ( maxunitstobeplaced != - _num ) && ( maxunitstobeplaced < units . size ( ) ) ) { return _str + units . size ( ) + _str + to . getname ( ) ; } return null ; }	test whether or not the territory has the factory resources to support the placement.
@ override public void closewrite ( ) throws ioexception { if ( _iswriteclosed ) { return ; } _iswriteclosed = _bool ; socketstream stream = _streamimpl ; if ( stream != null ) { stream . closewrite ( ) ; } else if ( _s != null ) { try { _s . shutdownoutput ( ) ; } catch ( unsupportedoperationexception e ) { log . log ( level . finest , e . tostring ( ) , e ) ; } catch ( exception e ) { log . finer ( e . tostring ( ) ) ; log . log ( level . finest , e . tostring ( ) , e ) ; } } }	closes the write half of the stream .
public boolean equals ( object that ) { return ( that instanceof charset ) && arrays . equals ( chars , ( ( charset ) that ) . chars ) ; }	returns true if " that " is another instance of charset containing the exact same characters as this one.
public static void processrecords ( list < kinesiseventrecord > inputrecords , kinesisuserrecordprocessor processor ) { list < record > rawrecords = new linkedlist < > ( ) ; for ( kinesiseventrecord rec : inputrecords ) { rawrecords . add ( rec . getkinesis ( ) ) ; } return processor . process ( userrecord . deaggregate ( rawrecords ) ) ; }	method to process a set of kinesis user records from a list of kinesis event records using pre - streams style api.
protected font resolvefont ( sharedcontext ctx , string font , float size , identvalue weight , identvalue style , identvalue variant ) { if ( font . startswith ( _str ) ) { font = font . substring ( _num ) ; } if ( font . endswith ( _str ) ) { font = font . substring ( _num , font . length ( ) - _num ) ; } if ( font . equalsignorecase ( _str ) ) { font = _str ; } if ( font . equalsignorecase ( _str ) ) { font = _str ; } if ( font . equalsignorecase ( _str ) ) { font = _str ; } if ( font . equals ( _str ) && style == identvalue . oblique ) { font = _str ; } if ( font . equals ( _str ) && style == identvalue . italic ) { font = _str ; } string fontinstancename = getfontinstancehashname ( ctx , font , size , weight , style , variant ) ; if ( instancehash . containskey ( fontinstancename ) ) { return instancehash . get ( fontinstancename ) ; } if ( availablefontshash . containskey ( font ) ) { font possiblynullfont = availablefontshash . get ( font ) ; font rootfont = null ; if ( possiblynullfont != null ) { rootfont = possiblynullfont ; } else { rootfont = new font ( font , font . plain , _num ) ; availablefontshash . put ( font , rootfont ) ; } font fnt = createfont ( ctx , rootfont , size , weight , style , variant ) ; instancehash . put ( fontinstancename , fnt ) ; return fnt ; } return null ; }	resolves a single font name.
public arrayrealvector ( double [ ] d , int pos , int size ) throws mathillegalargumentexception , nullargumentexception { if ( d == null ) { throw new nullargumentexception ( ) ; } if ( d . length < pos + size ) { throw new mathillegalargumentexception ( localizedcoreformats . number_too_large , pos + size , d . length ) ; } data = new double [ size ] ; system . arraycopy ( d , pos , data , _num , size ) ; }	construct a vector from part of a array .
public void clearpaymentmethodsbyid ( list < string > paymentmethodidstoremove ) { if ( utilvalidate . isempty ( paymentmethodidstoremove ) ) return ; for ( iterator < cartpaymentinfo > iter = paymentinfo . iterator ( ) ; iter . hasnext ( ) ; ) { cartpaymentinfo info = iter . next ( ) ; if ( paymentmethodidstoremove . contains ( info . paymentmethodid ) ) { iter . remove ( ) ; } } }	remove all the paymentmethods based on the paymentmethodids.
@ override public void clean ( ) { setcurrentpoints ( _num ) ; checkstate ( ) ; }	clean means to remove the attack request , set the current points to zero and check the plugin state .
public void handlebutton2request ( requestinvocationevent event ) { setpagesessionattribute ( gettrackingtabidname ( ) , amadminconstants . fed_tab_id ) ; setpagesessionattribute ( amadminconstants . previous_tab_id , gettrackingtabidname ( ) ) ; federationviewbean vb = ( federationviewbean ) getviewbean ( federationviewbean . class ) ; backtrail ( ) ; passpgsessionmap ( vb ) ; vb . forwardto ( getrequestcontext ( ) ) ; }	handles page cancel request .
@ override public void performrequest ( string request ) { if ( request . compareto ( _str ) == _num ) { stop ( ) ; } else { throw new illegalargumentexception ( request + _str ) ; } }	perform the named request.
public byte [ ] tobytes ( ) { byte [ ] returnbytes = new byte [ byteslength ] ; system . arraycopy ( bytes , _num , returnbytes , _num , byteslength ) ; return returnbytes ; }	get the composed bytes of pdu .
public void startcheck ( ) { checker = new thread ( new checkforupdate ( ) ) ; checker . setpriority ( thread . min_priority ) ; checker . start ( ) ; }	start key pair generation in a separate thread .
@ override public boolean eisset ( int featureid ) { switch ( featureid ) { case sgraphpackage . transition__trigger : return trigger != null ; case sgraphpackage . transition__effect : return effect != null ; case sgraphpackage . transition__properties : return properties != null && ! properties . isempty ( ) ; case sgraphpackage . transition__documentation : return documentation_edefault == null ? documentation != null : ! documentation_edefault . equals ( documentation ) ; case sgraphpackage . transition__target : return target != null ; case sgraphpackage . transition__source : return basicgetsource ( ) != null ; } return super . eisset ( featureid ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
public boolean isackseen ( ) { return this . ackseen ; }	return true if the dialog has already seen the ack .
protected void uninstalllisteners ( ) { super . uninstalllisteners ( ) ; splitpane . removepropertychangelistener ( this ) ; }	uninstalls the event listeners for the ui .
private static collector < segmentinfo , ? , map < string , segmentinfo > > partitionstomapcollector ( ) { return collector . of ( null , null , null ) ; }	a collector to aggregate all partitions of a segment into a map .
public boolean iscrc ( ) { return isflags ( flag_cached_values_checked & flag_crc_calced ) ; }	find out if privatecrc value known ( and not simply cached ) . can be used to find out if the privatecrc can be retrieved via getcrc ( ) without forcing it be calculated.
public int size ( ) { return queue . size ( ) ; }	this reports the # of items in the queue .
@ override public stringbuffer format ( double number , stringbuffer result , fieldposition fieldposition ) { boolean tryfastpath = _bool ; if ( fieldposition == dontcarefieldposition . instance ) tryfastpath = _bool ; else { fieldposition . setbeginindex ( _num ) ; fieldposition . setendindex ( _num ) ; } if ( tryfastpath ) { string tempresult = fastformat ( number ) ; if ( tempresult != null ) { result . append ( tempresult ) ; return result ; } } return format ( number , result , fieldposition . getfielddelegate ( ) ) ; }	formats a double to produce a string .
private void buildcursorconditionally ( matrixcursor cursor , characterrecord cr , string selection , string [ ] selectionargs ) { if ( selectionargs == null ) cursor . addrow ( new object [ ] { cr . getid ( ) , cr . getname ( ) , cr . getrace ( ) } ) ; else for ( string item : selectionargs ) if ( ( selection . equals ( charactercontract . characterentry . column_name ) && item . equals ( cr . getname ( ) ) ) || ( selection . equals ( charactercontract . characterentry . column_race ) && item . equals ( cr . getrace ( ) ) ) ) { cursor . addrow ( new object [ ] { cr . getid ( ) , cr . getname ( ) , cr . getrace ( ) } ) ; } }	build a matrixcursor that matches the parameters.
public modpackfileselectionpanel ( wizardcontroller controller , map wizarddata , file gamedir , bifunction < string , boolean , integer > blacklist ) { initcomponents ( ) ; this . controller = controller ; this . wizarddata = wizarddata ; this . blacklist = blacklist ; checkboxtreenode root = create ( gamedir , _str ) ; jtree1 . setmodel ( new defaulttreemodel ( root ) ) ; jtree1 . setcellrenderer ( new checkboxtreecellrenderer ( ) ) ; jtree1 . addmouselistener ( new checkboxtreenodeselectionlistener ( ) ) ; wizarddata . put ( _str , root ) ; }	creates new form modpackfileselectionpanel.
private void createcontainerifnecessary ( ) { if ( container . isfull ( ) ) { container = new timerrawcontainer ( ) ; data . add ( container ) ; } }	creates a new container if it is necessary .
private void processupdatecounts ( int [ ] updatecounts , int commandsinbatch ) { if ( updatecounts . length < commandsinbatch ) { error . emit ( tuples . get ( updatecounts . length + batchstartidx ) ) ; errortuples ++ ; tupleswrittensuccessfully += updatecounts . length ; batchstartidx += updatecounts . length + _num ; if ( ( tuples . size ( ) - batchstartidx ) > _num ) { processbatch ( ) ; } } else { tupleswrittensuccessfully = commandsinbatch ; for ( int i = _num ; i < commandsinbatch ; i ++ ) { if ( updatecounts [ i ] == statement . execute_failed ) { error . emit ( tuples . get ( i + batchstartidx ) ) ; errortuples ++ ; tupleswrittensuccessfully -- ; } } } }	identify which commands in the batch failed and redirect these on the error port.
public int chooseprotocolversion ( ) { return preferredprotocolversion ; }	returns the protocol version to use for sending multicast requests or announcements , or initiating unicast discovery .
public sensor createnewsensor ( string systemname , string username ) { sensor s ; string sname = acelaaddress . normalizesystemname ( systemname ) ; if ( sname . equals ( _str ) ) { log . error ( _str + systemname ) ; return null ; } s = getbysystemname ( sname ) ; if ( s != null ) { log . error ( _str + systemname ) ; return null ; } string altname = acelaaddress . convertsystemnametoalternate ( sname ) ; s = getbysystemname ( altname ) ; if ( s != null ) { log . error ( _str + systemname + _str + altname + _str ) ; return null ; } int bit = acelaaddress . getbitfromsystemname ( sname ) ; if ( ( bit < _num ) || ( bit >= _num ) ) { log . error ( _str + integer . tostring ( bit ) + _str ) ; return null ; } if ( username == null ) { s = new acelasensor ( sname ) ; } else { s = new acelasensor ( sname , username ) ; } acelanode node = acelaaddress . getnodefromsystemname ( sname , _memo ) ; if ( node == null ) { log . warn ( _str + sname + _str ) ; return s ; } if ( ! node . hasactivesensors ) { int newnodeaddress ; newnodeaddress = node . getnodeaddress ( ) ; log . warn ( _str + newnodeaddress ) ; return s ; } node . registersensor ( s , bit ) ; return s ; }	create a new sensor if all checks are passed system name is normalized to ensure uniqueness .
public static inputstream needstream ( string propertyname ) throws nosuchpropertyexception , filenotfoundexception , maryconfigurationexception { maryproperties . needproperty ( propertyname ) ; return getstream ( propertyname ) ; }	for the named property , attempt to get an open input stream.
public static boolean equal ( object a , object b ) { return a == b || ( a != null && a . equals ( b ) ) ; }	returns true if two possibly - null objects are equal .
public static string networknametostring ( byte [ ] data , int offset , int length ) { string ret ; if ( ( data [ offset ] & _num ) != _num || length < _num ) { return _str ; } switch ( ( data [ offset ] > > > _num ) & _num ) { case _num : int countseptets ; int unusedbits = data [ offset ] & _num ; countseptets = ( ( ( length - _num ) * _num ) - unusedbits ) / _num ; ret = gsmalphabet . gsm7bitpackedtostring ( data , offset + _num , countseptets ) ; break ; case _num : try { ret = new string ( data , offset + _num , length - _num , _str ) ; } catch ( unsupportedencodingexception ex ) { ret = _str ; log . e ( log_tag , _str , ex ) ; } break ; default : ret = _str ; break ; } if ( ( data [ offset ] & _num ) != _num ) { } return ret ; }	convert a ts 24.
public void add ( marker marker ) { mitems . add ( marker ) ; }	add the marker . important : markers added in a markerclusterer should not be added in the map overlays .
private static map . entry < datetime , timeseriesvalue > findname ( list < timeseriescollection > c , groupname name ) { listiterator < timeseriescollection > iter = c . listiterator ( ) ; while ( iter . hasnext ( ) ) { final int idx = iter . nextindex ( ) ; final timeseriescollection tsdata = iter . next ( ) ; final optional < timeseriesvalue > found = tsdata . get ( name ) ; if ( found . ispresent ( ) ) return simplemapentry . create ( tsdata . gettimestamp ( ) , found . get ( ) ) ; } throw new illegalstateexception ( _str ) ; }	finds the first resolution of name in the given timeseriescollections.
public map < string , object > finalizeorderentrypayment ( string checkoutpaymentid , bigdecimal amount , boolean singleuse , boolean append ) { map < string , object > result = serviceutil . returnsuccess ( ) ; if ( utilvalidate . isnotempty ( checkoutpaymentid ) ) { if ( ! append ) { cart . clearpayments ( ) ; } cart . addpaymentamount ( checkoutpaymentid , amount , singleuse ) ; } return result ; }	sets the payment id to use during the checkout process.
public void deploy ( string routeid , string routename , jsonvalue routeconfig ) throws routerhandlerexception { reject . ifnull ( routename ) ; write . lock ( ) ; try { load ( routeid , routename , routeconfig . copy ( ) ) ; directorymonitor . store ( routeid , routeconfig ) ; logger . info ( _str , routeid , routename ) ; } catch ( ioexception e ) { throw new routerhandlerexception ( format ( _str , routeid ) , e ) ; } finally { write . unlock ( ) ; } }	deploy a route , meaning that it loads it but also stores it in a file .
private static char [ ] subscriptfordigit ( int digit ) { return character . tochars ( _num + digit ) ; }	gets the unicode subscript character ( u + 2080 - u + 2089 ) for the specified digit .
private fspermission permission ( igfsfile file ) { string perm = file . property ( igfsutils . prop_permission , null ) ; if ( perm == null ) return fspermission . getdefault ( ) ; try { return new fspermission ( ( short ) integer . parseint ( perm , _num ) ) ; } catch ( numberformatexception ignore ) { return fspermission . getdefault ( ) ; } }	convert igfs file attributes into hadoop permission .
public simplemailboxacl ( ) { this . entries = collections . emptymap ( ) ; }	creates a new instance of simplemailboxacl containing no entries .
private void readstreamresult ( inh3 hin , headersamp headers ) throws ioexception { servicerefamp serviceref = readtoaddress ( hin ) ; long id = hin . readlong ( ) ; queryrefamp queryref = serviceref . getqueryref ( id ) ; if ( queryref != null ) { classloader loader = queryref . getclassloader ( ) ; thread thread = thread . currentthread ( ) ; thread . setcontextclassloader ( loader ) ; } int sequence = hin . readint ( ) ; list < object > values = ( list ) hin . readobject ( ) ; throwable exn = ( throwable ) hin . readobject ( throwable . class ) ; boolean iscomplete = hin . readboolean ( ) ; if ( log . isloggable ( _loglevel ) ) { log . log ( _loglevel , _str + values + _str + iscomplete + _str + this + _str + _str + id + _str + serviceref + _str + headers + _str ) ; } if ( queryref != null ) { if ( queryref . accept ( headers , values , sequence , iscomplete ) ) { serviceref . removequeryref ( id ) ; } if ( exn != null ) { serviceref . removequeryref ( id ) ; queryref . fail ( headers , exn ) ; } } else if ( log . isloggable ( level . warning ) ) { log . warning ( _str + id + _str + serviceref + _str + headers ) ; } }	the stream result message is a partial or final result from the target ' s stream .
public void updatefieldvisibility ( neuronupdaterule rule ) { boolean bounded = rule instanceof boundedupdaterule ; boolean clip = _bool ; setboundspanelvisible ( bounded ) ; if ( bounded ) { clip = rule instanceof clippableupdaterule ; clippingdropdown . setselected ( clip ) ; } setclippingpanelvisible ( clip ) ; setboundsenabled ( bounded ) ; }	update field visibility based on whether rule is bounded and / or clipped.
@ override public int hashcode ( ) { int hash = _num ; if ( altformat != null ) { hash += altformat . hashcode ( ) ; } if ( projection != null ) { hash = hash * _num ; hash += projection . hashcode ( ) ; } if ( version != null ) { hash = hash * _num ; hash += version . hashcode ( ) ; } return hash ; }	the hashcode for a context is just the hashcode of its parts .
public void removeoklistener ( actionlistener a ) { m_okbut . removeactionlistener ( a ) ; }	this is used to remove an action listener from the ok button .
void change_item_shape ( brditem p_item , int p_shape_no , shapetile p_new_shape ) { awtreenodeleaf [ ] old_entries = p_item . get_search_tree_entries ( this ) ; awtreenodeleaf [ ] new_leaf_arr = new awtreenodeleaf [ old_entries . length ] ; shapetile [ ] new_precalculated_tree_shapes = new shapetile [ old_entries . length ] ; remove_leaf ( old_entries [ p_shape_no ] ) ; for ( int i = _num ; i < new_precalculated_tree_shapes . length ; ++ i ) { if ( i == p_shape_no ) { new_precalculated_tree_shapes [ i ] = p_new_shape ; } else { new_precalculated_tree_shapes [ i ] = p_item . get_tree_shape ( this , i ) ; new_leaf_arr [ i ] = old_entries [ i ] ; } } p_item . set_precalculated_tree_shapes ( new_precalculated_tree_shapes , this ) ; new_leaf_arr [ p_shape_no ] = insert ( p_item , p_shape_no ) ; p_item . set_search_tree_entries ( this , new_leaf_arr ) ; }	changes the shape with index p_shape_no of this item to p_new_shape and updates the entry in the tree .
public jquickstartpane ( kseframe kseframe ) { super ( gradient_color_1 , gradient_color_2 ) ; this . kseframe = kseframe ; new droptarget ( this , this ) ; initcomponents ( ) ; }	construct quick start pane .
public static string indent ( final int depth ) { if ( depth < _num ) { return _str ; } return ws . substring ( _num , math . min ( ws . length ( ) , depth * _num ) ) ; }	returns a string that may be used to indent a dump of the nodes in the tree.
public exceptionlessoutputstream ( outputstream out ) { super ( new dataoutputstream ( out ) ) ; dos = ( dataoutputstream ) this . out ; }	creates a new data output stream to write data to the specified underlying output stream .
public t advancetoelement ( predicate < t > predicate ) { node < t > start = head ; if ( head == null ) return null ; do { t currelement = advance ( ) ; if ( predicate . test ( currelement ) ) { return currelement ; } } while ( head != start ) ; return null ; }	advances through the circular list returning the first element for which the predicate evaluates to true.
public void addtrace ( final trace trace ) { tracelist . add ( trace ) ; add ( trace ) ; revalidate ( ) ; }	add a trace to the plot area .
public static void pingalldevices ( string message ) throws ioexception { sender sender = new sender ( ids . api_key ) ; for ( deviceinfo deviceinfo : endpoint . listdeviceinfo ( ) ) { dosendviagcm ( message , sender , deviceinfo ) ; } }	ping all registered devices with the message .
private void findmatchesincontexts ( list < numbercontext > contexts , boolean isvalid , boolean ispossible , string region , string number ) { if ( isvalid ) { dotestincontext ( number , region , contexts , leniency . valid ) ; } else { for ( numbercontext context : contexts ) { string text = context . leadingtext + number + context . trailingtext ; asserttrue ( _str + text , hasnomatches ( phoneutil . findnumbers ( text , region ) ) ) ; } } if ( ispossible ) { dotestincontext ( number , region , contexts , leniency . possible ) ; } else { for ( numbercontext context : contexts ) { string text = context . leadingtext + number + context . trailingtext ; asserttrue ( _str + text , hasnomatches ( phoneutil . findnumbers ( text , region , leniency . possible , long . max_value ) ) ) ; } } }	helper method which tests the contexts provided and ensures that : - - if isvalid is true , they all find a test number inserted in the middle when leniency of matching is set to valid ; else no test number should be extracted at that leniency level - - if ispossible is true , they all find a test number inserted in the middle when leniency of matching is set to possible ; else no test number should be extracted at that leniency level.
public void testgeneralpunctuationcategory ( ) { string [ ] s = { _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str } ; string regexp = _str ; for ( int i = _num ; i < s . length ; i ++ ) { pattern pattern = pattern . compile ( regexp ) ; matcher matcher = pattern . matcher ( s [ i ] ) ; asserttrue ( matcher . find ( ) ) ; } }	regression test for harmony - 3360.
@ override public int hashcode ( ) { int code = _num ; if ( esubjects != null ) { for ( entitlementsubject esubject : esubjects ) { code += esubject . hashcode ( ) ; } } if ( psubjectname != null ) { code += psubjectname . hashcode ( ) ; } return code ; }	returns hash code of the object.
private void assignrandomlowertriangularmatrix ( int n , securerandom sr ) { numrows = n ; numcolumns = n ; length = ( n + _num ) > > > _num ; matrix = new int [ numrows ] [ length ] ; for ( int i = _num ; i < numrows ; i ++ ) { int q = i > > > _num ; int r = i & _num ; int s = _num - r ; r = _num << r ; for ( int j = _num ; j < q ; j ++ ) { matrix [ i ] [ j ] = sr . nextint ( ) ; } matrix [ i ] [ q ] = ( sr . nextint ( ) > > > s ) | r ; for ( int j = q + _num ; j < length ; j ++ ) { matrix [ i ] [ j ] = _num ; } } }	create a nxn random lower triangular matrix .
private boolean loadwithinspectitclassloader ( string classname ) { return classname . startswith ( class_name_prefix ) ; }	defines if the class should be loaded with our class loader .
public static void addcustomcommands ( string commands , contextmenu m ) { matcher matcher = custom_commands_pattern . matcher ( commands ) ; boolean sep = _bool ; while ( matcher . find ( ) ) { string match = matcher . group ( ) ; if ( match . equals ( _str ) ) { sep = _bool ; } else { string command = matcher . group ( _num ) ; string submenu = null ; if ( match . startswith ( _str ) ) { submenu = custom_commands_submenu ; } if ( sep ) { m . addseparator ( submenu ) ; } m . addsubitem ( _str + command , helper . replaceunderscorewithspace ( command ) , submenu ) ; sep = _bool ; } } }	parses the given commands setting and adds menu items to the given contextmenu .
public int nextclearbit ( int fromindex ) { int i = fromindex > > address_bits ; int max = data . length ; for ( ; i < max ; i ++ ) { if ( data [ i ] == - _num ) { continue ; } int j = math . max ( fromindex , i << address_bits ) ; for ( int end = j + _num ; j < end ; j ++ ) { if ( ! get ( j ) ) { return j ; } } } return max << address_bits ; }	get the index of the next bit that is not set .
private final void nextrequest ( ) { pacingtimer . stop ( ) ; pacingtimer . restart ( ) ; replytrycount = _num ; }	starts the pacing timer , which , at timeout , will begin the next opsw access request .
@ override public boolean equals ( object o ) { if ( this == o ) { return _bool ; } if ( o == null || getclass ( ) != o . getclass ( ) ) { return _bool ; } account account = ( account ) o ; if ( username != null ? ! username . equals ( account . username ) : account . username != null ) { return _bool ; } return _bool ; }	equals and hashcode use ` username ` instead of accountid for easier testing . username is unique so it is safe.
public static int identifypid ( final string name ) throws pidunavailableexception { try { final int index = name . indexof ( _str ) ; if ( index < _num ) { throw new pidunavailableexception ( _str + name ) ; } return integer . valueof ( name . substring ( _num , index ) ) ; } catch ( numberformatexception e ) { throw new pidunavailableexception ( _str + name , e ) ; } }	returns the pid for this process using the specified name from runtimemxbean .
abstract protected void processcommand ( string line ) throws exception ;	process the command provided in line .
protected object next ( ) { int i = _num ; char [ ] c ; try { i = st . nexttoken ( ) ; } catch ( ioexception e ) { debug . error ( _str + e . tostring ( ) + _str ) ; } if ( ( i == streamtokenizer . tt_eof ) || ( i == _num ) ) return eof ; if ( i == streamtokenizer . tt_word ) return new symbol ( st . sval , _num ) ; if ( ( i == _str ) || ( i == _str ) ) return st . sval ; if ( i == streamtokenizer . tt_number ) return new double ( st . nval ) ; if ( ( i == _str ) || ( i == _str ) || ( i == _str ) ) return lp ; if ( ( i == _str ) || ( i == _str ) || ( i == _str ) ) return rp ; c = new char [ _num ] ; c [ _num ] = ( char ) i ; return new symbol ( new string ( c ) , _num ) ; }	break the next token into an object .
public static void copy ( file source , file dest ) throws ioexception { if ( source . isdirectory ( ) ) { dest . mkdir ( ) ; for ( file child : listfiles ( source ) ) { copy ( child , new file ( dest , child . getname ( ) ) ) ; } } else { if ( source . exists ( ) ) { long lm = source . lastmodified ( ) ; if ( dest . isdirectory ( ) ) { dest = new file ( dest , source . getname ( ) ) ; } fileoutputstream fos = new fileoutputstream ( dest ) ; try { fileinputstream fis = new fileinputstream ( source ) ; try { if ( use_nio ) { niocopy ( fos , fis ) ; } else { oiocopy ( source , fos , fis ) ; } } finally { fis . close ( ) ; } } finally { fos . close ( ) ; } dest . setexecutable ( source . canexecute ( ) , _bool ) ; dest . setlastmodified ( lm ) ; } } }	copy a file from the source file to the destination file.
public static int classindex ( int luastate , class clazz , string searchname ) throws luaexception { synchronized ( luastatefactory . getexistingstate ( luastate ) ) { int res ; res = checkfield ( luastate , clazz , searchname ) ; if ( res != _num ) { return _num ; } res = checkmethod ( luastate , clazz , searchname ) ; if ( res != _num ) { return _num ; } return _num ; } }	java function to be called when a java class metamethod __index is called . this function returns 1 if there is a field with searchname and 2 if there is a method if the searchname.
private void notifyresourceeventlisteners ( resourceevent event , object resource ) { for ( iterator < resourceeventslistener > iter = resourcelisteners . iterator ( ) ; iter . hasnext ( ) ; ) { try { resourceeventslistener listener = ( resourceeventslistener ) iter . next ( ) ; listener . handleevent ( event , resource ) ; } catch ( cancelexception e ) { } catch ( gemfiresecurityexception | managementexception ex ) { if ( event == resourceevent . cache_create ) { throw ex ; } else { logger . warn ( ex . getmessage ( ) , ex ) ; } } catch ( exception err ) { logger . warn ( err . getmessage ( ) , err ) ; } catch ( virtualmachineerror e ) { systemfailure . initiatefailure ( e ) ; throw e ; } catch ( throwable t ) { systemfailure . checkfailure ( ) ; logger . warn ( t . getmessage ( ) , t ) ; } } }	notifies all resource event listeners . all exceptions are caught here and only a warning message is printed in the log.
private void infercaller ( ) { needtoinfercaller = _bool ; throwable throwable = new throwable ( ) ; boolean lookingforlogger = _bool ; for ( final stacktraceelement frame : throwable . getstacktrace ( ) ) { string cname = frame . getclassname ( ) ; boolean isloggerimpl = isloggerimplframe ( cname ) ; if ( lookingforlogger ) { if ( isloggerimpl ) { lookingforlogger = _bool ; } } else { if ( ! isloggerimpl ) { if ( ! cname . startswith ( _str ) && ! cname . startswith ( _str ) ) { setsourceclassname ( cname ) ; setsourcemethodname ( frame . getmethodname ( ) ) ; return ; } } } } }	determines the source information for the caller of the logger ( class name , method name , and line number ).
final int recordexceptionalcompletion ( throwable ex ) { int s ; if ( ( s = status ) >= _num ) { int h = system . identityhashcode ( this ) ; final reentrantlock lock = exceptiontablelock ; lock . lock ( ) ; try { expungestaleexceptions ( ) ; exceptionnode [ ] t = exceptiontable ; int i = h & ( t . length - _num ) ; for ( exceptionnode e = t [ i ] ; ; e = e . next ) { if ( e == null ) { t [ i ] = new exceptionnode ( this , ex , t [ i ] , exceptiontablerefqueue ) ; break ; } if ( e . get ( ) == this ) break ; } } finally { lock . unlock ( ) ; } s = setcompletion ( exceptional ) ; } return s ; }	records exception and sets status .
private void analyzeresultingtlscontextandwritefile ( tlscontext tlscontext , string folder , string fieldname , string workflowname , long phase ) throws jaxbexception , ioexception { if ( tlscontextanalyzer . containsfullworkflowwithmissingmessage ( tlscontext ) || tlscontextanalyzer . containsserverfinishedwithmodifiedhandshake ( tlscontext ) || tlscontextanalyzer . containsfullworkflowwithmodifiedmessage ( tlscontext ) ) { string filenamebasic = createfilename ( folder , phase , tlscontext , fieldname ) ; fileoutputstream fos = new fileoutputstream ( filenamebasic + workflowname + _str ) ; workflowtraceserializer . write ( fos , tlscontext . getworkflowtrace ( ) ) ; } }	analyzes the resulting workflow.
private static string tovariablename ( string str ) { stringbuffer rtn = new stringbuffer ( ) ; char [ ] chars = str . tochararray ( ) ; long changes = _num ; boolean docorrect = _bool ; for ( int i = _num ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( i == _num && ( c >= _str && c <= _str ) ) rtn . append ( _str + c ) ; else if ( ( c >= _str && c <= _str ) || ( c >= _str && c <= _str ) || ( c >= _str && c <= _str ) || c == _str || c == _str ) rtn . append ( c ) ; else { docorrect = _bool ; rtn . append ( _str ) ; changes += ( c * ( i + _num ) ) ; } } if ( changes > _num ) rtn . append ( changes ) ; if ( docorrect ) return correctreservedword ( rtn . tostring ( ) ) ; return rtn . tostring ( ) ; }	translate a string to a valid variable string.
public year ( int year ) { if ( ( year < year . minimum_year ) || ( year > year . maximum_year ) ) { throw new illegalargumentexception ( _str + year + _str ) ; } this . year = ( short ) year ; peg ( calendar . getinstance ( ) ) ; }	creates a time period representing a single year .
@ suppresswarnings ( _str ) public list < string > hostvcenterchangedetails ( uri hostid , uri clusterid , uri datacenterid , boolean isvcenter ) { list < string > result = lists . newarraylist ( ) ; host host = _dbclient . queryobject ( host . class , hostid ) ; vcenterdatacenter datacenter = _dbclient . queryobject ( vcenterdatacenter . class , datacenterid ) ; if ( host != null && datacenter != null ) { result . add ( computesystemdialogproperties . getmessage ( _str , host . getlabel ( ) , datacenter . getlabel ( ) ) ) ; result . addall ( hostclusterchangedetails ( hostid , clusterid , datacenterid , isvcenter ) ) ; } return result ; }	get details for the hostvcenterchange method note : in order to maintain backwards compatibility , do not change the signature of this method .
public boolean deletestatement ( testcase test , int position ) throws constructionfailedexception { if ( ! constraintverifier . candelete ( test , position ) ) { return _bool ; } logger . debug ( _str , position ) ; set < integer > todelete = new linkedhashset < > ( ) ; recursivedeleteinclusion ( test , todelete , position ) ; list < integer > pos = new arraylist < > ( todelete ) ; collections . sort ( pos , collections . reverseorder ( ) ) ; for ( integer i : pos ) { logger . debug ( _str , i ) ; test . remove ( i ) ; } return _bool ; }	delete the statement at position from the test case and remove all references to it.
public boolean iscompound ( ) { return splits . size ( ) != _num ; }	checks if this instance is a compounding word .
@ override public set < statement > sum ( final igasstate < set < statement > , set < statement > , set < statement > > state , final set < statement > left , final set < statement > right ) { final set < statement > tmp = new linkedhashset < statement > ( left ) ; tmp . addall ( right ) ; return tmp ; }	set union over the gathered edges .
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return host ; case _num : return port ; case _num : return id ; case _num : return v_nodes ; case _num : return ping_frequency ; case _num : return service_name ; case _num : return state ; case _num : return timestamp ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
private static int categorizebyyear2014method ( context c ) { arraylist < integer > componentyears = new arraylist < integer > ( ) ; conditionallyadd ( componentyears , getnumcoresyear ( ) ) ; conditionallyadd ( componentyears , getclockspeedyear ( ) ) ; conditionallyadd ( componentyears , getramyear ( c ) ) ; if ( componentyears . isempty ( ) ) return class_unknown ; collections . sort ( componentyears ) ; if ( ( componentyears . size ( ) & _num ) == _num ) { return componentyears . get ( componentyears . size ( ) / _num ) ; } else { int baseindex = componentyears . size ( ) / _num - _num ; return componentyears . get ( baseindex ) + ( componentyears . get ( baseindex + _num ) - componentyears . get ( baseindex ) ) / _num ; } }	calculates the " best - in - class year " of the device.
public actionrequesthelper then ( actionrequesthelper nextaction ) { mnext . add ( nextaction ) ; return this ; }	this request will be executed if the current request succeed .
public boolean iscurrent ( string str ) { if ( pos + str . length ( ) > lctext . length ) return _bool ; for ( int i = str . length ( ) - _num ; i >= _num ; i -- ) { if ( str . charat ( i ) != lctext [ pos + i ] ) return _bool ; } return _bool ; }	returns if the current character ( internal pointer ) and the following are the same as the given input.
private static string matchablepath ( string path ) { if ( path == null ) { return _str ; } else if ( path . endswith ( _str ) ) { return path ; } else { return path + _str ; } }	returns a non - null path ending in " / " .
public void assertusable ( ) throws ioexception { if ( throwable . get ( ) == null ) { if ( connection == null ) { throw new ioexception ( _str ) ; } return ; } throwable t = throwable . get ( ) ; if ( t instanceof ioexception ) { throw ( ioexception ) t ; } else { throw throwables . propagate ( t ) ; } }	before the websocket is used , it ' s recommended to call this method to ensure that any exceptions caught while processing the messages received are acknowledged .
protected static double computeh ( final int i , double [ ] dist_i , double [ ] pij_i , double mbeta ) { double sump = _num ; for ( int j = _num ; j < i ; j ++ ) { sump += ( pij_i [ j ] = math . exp ( dist_i [ j ] * mbeta ) ) ; } for ( int j = i + _num ; j < dist_i . length ; j ++ ) { sump += ( pij_i [ j ] = math . exp ( dist_i [ j ] * mbeta ) ) ; } if ( ! ( sump > _num ) ) { return double . negative_infinity ; } final double s = _num / sump ; double sum = _num ; for ( int j = _num ; j < dist_i . length ; j ++ ) { sum += dist_i [ j ] * ( pij_i [ j ] *= s ) ; } return math . log ( sump ) - mbeta * sum ; }	compute h ( observed perplexity ) for row i , and the row pij_i .
public static string addprotocoltourl ( string url ) { if ( ! url . startswith ( http_protocol_prefix ) && ! url . startswith ( https_protocol_prefix ) && ! url . startswith ( file_protocol_prefix ) ) { if ( url . startswith ( file_prefix ) ) { url = file_protocol_prefix + url ; } else { url = http_protocol_prefix + url ; } } return url ; }	this method add the protocol to the url if the protocol is missing.
public static string methodnametopropertyname ( string methodname ) { if ( methodname . startswith ( _str ) ) methodname = methodname . substring ( _num ) ; else if ( methodname . startswith ( _str ) ) methodname = methodname . substring ( _num ) ; else if ( methodname . startswith ( _str ) ) methodname = methodname . substring ( _num ) ; if ( methodname . length ( ) == _num ) return null ; char ch = methodname . charat ( _num ) ; if ( character . isuppercase ( ch ) && ( methodname . length ( ) == _num || ! character . isuppercase ( methodname . charat ( _num ) ) ) ) { methodname = character . tolowercase ( ch ) + methodname . substring ( _num ) ; } return methodname ; }	converts a user ' s property name to a bean method name .
private stringbuilder createindent ( int indent ) { stringbuilder oneindent = createindent ( ) ; stringbuilder ret = new stringbuilder ( ) ; while ( indent -- > _num ) { ret . append ( oneindent ) ; } return ret ; }	creates a string that represents the given number of indents ( can be spaces or tabs.
protected classloader ( ) { this ( getsystemclassloader ( ) ) ; }	constructs a new instance of this class with the system class loader as its parent .
public static void matchvpoolwithstoragepools ( virtualpool vpool , list < storagepool > pools , dbclient dbclient , coordinatorclient coordinator , string matchergroupname , stringbuffer errormessage ) { list < storagepool > filterpools = getmatchedpoolwithstoragepools ( vpool , pools , virtualpool . getprotectionsettings ( vpool , dbclient ) , virtualpool . getremoteprotectionsettings ( vpool , dbclient ) , virtualpool . getfileremoteprotectionsettings ( vpool , dbclient ) , dbclient , coordinator , matchergroupname , errormessage ) ; updateinvalidandmatchedpoolsforvpool ( vpool , filterpools , pools , dbclient ) ; }	matches given virtualpool with list of pools provided and update matched / invalid pools in virtualpool .
static < t > boolean removeif ( iterable < t > removefrom , predicate < ? super t > predicate ) { if ( removefrom instanceof randomaccess && removefrom instanceof list ) { return removeiffromrandomaccesslist ( ( list < t > ) removefrom , checknotnull ( predicate ) ) ; } return iterators . removeif ( removefrom . iterator ( ) , predicate ) ; }	removes , from an iterable , every element that satisfies the provided predicate .
@ beforeclass public static void createecomconnection ( ) { boolean wasexception = _bool ; try { _connection = new ecomconnection ( createconnectioninfo ( ) , createlistener ( ) , new cimfiltermap ( ) ) ; } catch ( exception e ) { wasexception = _bool ; } assert . assertfalse ( wasexception ) ; }	creates a connection required by the ecom processor .
protected void _init ( final idatatypeuriresolver resolver , final ilexiconconfiguration < bigdatavalue > config , final collection < iextension < ? extends bigdatavalue > > extensions ) { }	give subclasses a chance to add extensions .
public mxrectangle graphmodelchanged ( mxigraphmodel sender , list < mxundoablechange > changes , boolean rv ) { int thresh = getchangesrepaintthreshold ( ) ; boolean ignoredirty = thresh > _num && changes . size ( ) > thresh ; if ( ! ignoredirty ) { iterator < mxundoablechange > it = changes . iterator ( ) ; while ( it . hasnext ( ) ) { if ( it . next ( ) instanceof mxrootchange ) { ignoredirty = _bool ; break ; } } } arraylist < object > changedcells = new arraylist < object > ( ) ; mxrectangle dirty = processchanges ( changes , _bool , ignoredirty , changedcells ) ; if ( ! rv ) { if ( changedcells != null ) { for ( object changedcell : changedcells ) { mxcellstate parentstate = view . getstate ( model . getparent ( changedcell ) , _bool ) ; view . validate ( parentstate , changedcell , _bool ) ; } } } else view . validate ( ) ; if ( ! ignoredirty ) { mxrectangle tmp = processchanges ( changes , _bool , ignoredirty ) ; if ( tmp != null ) { if ( dirty == null ) { dirty = tmp ; } else { dirty . add ( tmp ) ; } } } removeselectioncells ( getremovedcellsforchanges ( changes ) ) ; return dirty ; }	called when the graph model changes.
public void testsetbitexception ( ) { byte abytes [ ] = { - _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = _num ; int number = - _num ; biginteger anumber = new biginteger ( asign , abytes ) ; try { anumber . setbit ( number ) ; fail ( _str ) ; } catch ( arithmeticexception e ) { } }	setbit ( int n ) of a negative n.
public void guard ( final guard r ) throws interruptedexception { incthread ( ) ; try { r . run ( ) ; } catch ( interruptedexception e ) { throw e ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } finally { decthread ( ) ; } }	execute a critical region which needs to be interrupted if some condition is violated .
public void log ( date time , string message ) { try { printwriter w = new printwriter ( new filewriter ( filename , _bool ) ) ; w . println ( _str + format . format ( time ) + _str + message ) ; w . close ( ) ; } catch ( ioexception e ) { } }	emits a message to the log , timestamped with the specified time .
protected resourceinfo newelement ( int type ) { resourceinfo result = null ; switch ( type ) { case iresource . file : case iresource . folder : result = new resourceinfo ( type ) ; break ; case iresource . project : result = new resourceinfo ( type ) ; break ; case iresource . root : result = new resourceinfo ( type ) ; break ; } return result ; }	create and return a new tree element of the given type .
private boolean ismodeluseful ( contingencymatrix cm ) { return _bool ; }	helper method to decide whether a model improves the training error enough to be considered.
public void registerplayerobserver ( playereventsobserver observer , boolean replyimmediately ) { if ( this . connection == null ) return ; playereventsobservers . add ( observer ) ; if ( replyimmediately ) replywithlastresult ( observer ) ; if ( playereventsobservers . size ( ) == _num ) { if ( connection . getprotocol ( ) == hostconnection . protocol_tcp ) { connection . registerplayernotificationsobserver ( this , checkerhandler ) ; connection . registersystemnotificationsobserver ( this , checkerhandler ) ; connection . registerinputnotificationsobserver ( this , checkerhandler ) ; checkerhandler . post ( tcpcheckerrunnable ) ; } else { checkerhandler . post ( httpcheckerrunnable ) ; } } }	registers a new observer that will be notified about player events.
@ override public int numelements ( ) throws exception { if ( m_zeror != null ) { return _num ; } return m_tree . numnodes ( ) ; }	returns the number of elements in the partition .
public boolean ishighlightable ( omgraphic omg ) { return _bool ; }	query asking if omgraphic is highlight - able , which means that something in the gui should change when the mouse is moved or dragged over the given omgraphic.
public void testvirtualdestinationsdinamicallyincludedbehavior3 ( ) throws exception { final string topic = _str ; final string vq = _str + topic ; startallbrokers ( ) ; final int msgs1 = _num ; final int msgs2 = _num ; destination tdest = createdestination ( topic , _bool ) ; destination vqdest = createdestination ( vq , _bool ) ; messageconsumer clientb1t = createconsumer ( _str , tdest ) ; messageconsumer clientb2t = createconsumer ( _str , tdest ) ; messageconsumer clientb1vq = createconsumer ( _str , vqdest ) ; thread . sleep ( _num * _num ) ; sendmessages ( _str , tdest , msgs1 ) ; sendmessages ( _str , tdest , msgs2 ) ; thread . sleep ( _num ) ; messageidlist msgsb1t = getconsumermessages ( _str , clientb1t ) ; msgsb1t . waitformessagestoarrive ( msgs1 + msgs2 ) ; assertequals ( msgs1 + msgs2 , msgsb1t . getmessagecount ( ) ) ; messageidlist msgsb2t = getconsumermessages ( _str , clientb2t ) ; msgsb2t . waitformessagestoarrive ( msgs1 + msgs2 ) ; assertequals ( msgs1 + msgs2 , msgsb2t . getmessagecount ( ) ) ; messageidlist msgsb1vq = getconsumermessages ( _str , clientb1vq ) ; msgsb1vq . waitformessagestoarrive ( msgs1 + msgs2 ) ; assertequals ( msgs1 + msgs2 , msgsb1vq . getmessagecount ( ) ) ; assertequals ( _num , getqueuesize ( _str , ( activemqdestination ) vqdest ) ) ; assertequals ( _num , getqueuesize ( _str , ( activemqdestination ) vqdest ) ) ; destroyallbrokers ( ) ; }	brokera - > brokerb & & brokerb - > brokera.
public rpcclient peerwith ( peerinfo serverinfo , bootstrap bootstrap , map < string , object > attributes ) throws ioexception { inetsocketaddress remoteaddress = new inetsocketaddress ( serverinfo . gethostname ( ) , serverinfo . getport ( ) ) ; return peerwith ( remoteaddress , bootstrap , attributes ) ; }	create a new client with the provided attributes to the remoteaddress .
public gridreversedlinesfilereader ( final file file , final int blocksize , final string encoding ) throws ioexception { this ( file , blocksize , charset . forname ( encoding ) ) ; }	creates a reverselinereader with the given block size and encoding .
private void beforename ( ) throws ioexception { int context = peek ( ) ; if ( context == nonempty_object ) { out . write ( _str ) ; } else if ( context != empty_object ) { throw new illegalstateexception ( _str ) ; } newline ( ) ; replacetop ( dangling_name ) ; }	inserts any necessary separators and whitespace before a name.
protected string constname ( ) { return _str + name . touppercase ( ) ; }	convert array name into all uppercase internal scanner constant name .
public boolean istimestampwithininterval ( datetime timestamp , string intervalstring ) throws illegalargumentexception { interval interval = interval . parse ( intervalstring ) ; return interval . contains ( timestamp ) ; }	returns true if the supplied timestamp is within the specified time interval . the supplied interval string should contain an iso 8601 formatted interval string and may be of the formats ' datetime / datetime ' , ' datetime / period ' or ' period / datetime '.
private void processansioscommand ( ) { if ( ansioscommand . charat ( _num ) != _str || ansioscommand . charat ( _num ) != _str ) { logger . log ( _str + ansioscommand + _str ) ; return ; } }	this method is called when we have parsed an os command escape sequence.
public boolean removetriggergrouptoneverdelete ( string group ) { if ( group != null ) return triggergroupstoneverdelete . remove ( group ) ; return _bool ; }	remove the given group to the list of trigger groups that will never be deleted by this processor , even if a pre - processing - command to delete the group is encountered .
public void remove ( rule rule ) { rules . remove ( rule ) ; }	removes a rule from this grammar .
@ checkreturnvalue @ deprecated @ nonnull public static string join ( @ nonnull string [ ] s , @ nonnull string delimiter ) { stringbuilder buffer = new stringbuilder ( ) ; for ( int i = _num ; i < s . length ; i ++ ) { buffer . append ( s [ i ] ) ; if ( i < s . length - _num ) { buffer . append ( delimiter ) ; } } return buffer . tostring ( ) ; }	join an array of strings , separated by a delimiter.
private void initselectposition ( int position ) { if ( mselectmode == iselectable . select_mode_single ) { if ( mselectedposition == iselectable . invalid_position ) { mselectedposition = position ; } } else if ( mselectmode == iselectable . select_mode_multi ) { if ( ! mselectedpositions . contains ( position ) ) mselectedpositions . add ( position ) ; } else { throw new runtimeexception ( ) ; } }	this will only called once .
@ override public pathimpl schemewalk ( string userpath , map < string , object > attributes , string filepath , int offset ) { if ( ! iswindows ( ) ) { return super . schemewalk ( userpath , attributes , filepath , offset ) ; } string canonicalpath ; if ( filepath . length ( ) < offset + _num ) { return super . schemewalk ( userpath , attributes , filepath , offset ) ; } char ch1 = filepath . charat ( offset + _num ) ; char ch2 = filepath . charat ( offset ) ; if ( ( ch2 == _str || ch2 == _separatorchar ) && ( ch1 == _str || ch1 == _separatorchar ) ) return super . schemewalk ( userpath , attributes , convertfromwindowspath ( filepath . substring ( offset ) ) , _num ) ; else return super . schemewalk ( userpath , attributes , filepath , offset ) ; }	lookup the path , handling windows weirdness.
void initproperties ( string defaultlevel , string defaultfilter , string defaultformatter , string defaultencoding ) { logmanager manager = logmanager . getlogmanager ( ) ; final string filtername = manager . getproperty ( prefix + _str ) ; if ( filtername != null ) { try { filter = ( filter ) getcustomizeinstance ( filtername ) ; } catch ( exception e1 ) { printinvalidpropmessage ( _str , filtername , e1 ) ; filter = ( filter ) getdefaultinstance ( defaultfilter ) ; } } else { filter = ( filter ) getdefaultinstance ( defaultfilter ) ; } string levelname = manager . getproperty ( prefix + _str ) ; if ( levelname != null ) { try { level = level . parse ( levelname ) ; } catch ( exception e ) { printinvalidpropmessage ( _str , levelname , e ) ; level = level . parse ( defaultlevel ) ; } } else { level = level . parse ( defaultlevel ) ; } final string formattername = manager . getproperty ( prefix + _str ) ; if ( formattername != null ) { try { formatter = ( formatter ) getcustomizeinstance ( formattername ) ; } catch ( exception e ) { printinvalidpropmessage ( _str , formattername , e ) ; formatter = ( formatter ) getdefaultinstance ( defaultformatter ) ; } } else { formatter = ( formatter ) getdefaultinstance ( defaultformatter ) ; } final string encodingname = manager . getproperty ( prefix + _str ) ; try { internalsetencoding ( encodingname ) ; } catch ( unsupportedencodingexception e ) { printinvalidpropmessage ( _str , encodingname , e ) ; } }	init the common properties , including filter , level , formatter , and encoding.
public static void writeunsignedvl ( long data , dataoutput out ) throws ioexception { while ( _bool ) { if ( ( data & ~ _num ) == _num ) { out . writebyte ( ( int ) data ) ; return ; } else { out . writebyte ( ( ( int ) data & _num ) | _num ) ; data >>>= _num ; } } }	encode a long as a variable length array.
public jsonarray names ( ) { jsonarray ja = new jsonarray ( ) ; iterator keys = keys ( ) ; while ( keys . hasnext ( ) ) { ja . put ( keys . next ( ) ) ; } return ja . length ( ) == _num ? null : ja ; }	produce a jsonarray containing the names of the elements of this jsonobject .
public void addtablewithalias ( string table , string alias ) { querytabledata tabledata = new querytabledata ( ) ; tabledata . settablename ( table ) ; tabledata . settablealias ( alias ) ; tabledata . settableindex ( _tablesdata . size ( ) ) ; _tablesdata . add ( tabledata ) ; if ( alias == null ) tables . put ( table , tabledata ) ; else { tables . put ( alias , tabledata ) ; tables . put ( table , tabledata ) ; } }	add an alias - table mapping . if no alias exists , we ' ll use the table name.
private int encryptblock ( byte [ ] in , int inoff , byte [ ] out , int outoff ) throws datalengthexception , illegalstateexception { if ( ( inoff + blocksize ) > in . length ) { throw new datalengthexception ( _str ) ; } for ( int i = _num ; i < blocksize ; i ++ ) { cbcv [ i ] ^= in [ inoff + i ] ; } int length = cipher . processblock ( cbcv , _num , out , outoff ) ; system . arraycopy ( out , outoff , cbcv , _num , cbcv . length ) ; return length ; }	do the appropriate chaining step for cbc mode encryption .
private void renderaxes ( camera camera ) { glpushmatrix ( ) ; glloadidentity ( ) ; float rotx = camera . getrotation ( ) . x ; float roty = camera . getrotation ( ) . y ; float rotz = _num ; glrotatef ( rotx , _num , _num , _num ) ; glrotatef ( roty , _num , _num , _num ) ; glrotatef ( rotz , _num , _num , _num ) ; gllinewidth ( _num ) ; glbegin ( gl_lines ) ; glcolor3f ( _num , _num , _num ) ; glvertex3f ( _num , _num , _num ) ; glvertex3f ( _num , _num , _num ) ; glcolor3f ( _num , _num , _num ) ; glvertex3f ( _num , _num , _num ) ; glvertex3f ( _num , _num , _num ) ; glcolor3f ( _num , _num , _num ) ; glvertex3f ( _num , _num , _num ) ; glvertex3f ( _num , _num , _num ) ; glend ( ) ; glpopmatrix ( ) ; }	renders the three axis in space ( for debugging purposes only.
@ override public object clone ( ) throws clonenotsupportedexception { periodaxislabelinfo clone = ( periodaxislabelinfo ) super . clone ( ) ; return clone ; }	returns a clone of the object .
public long skip ( long n ) throws ioexception { if ( n < _num ) { throw new illegalargumentexception ( _str ) ; } ensureopen ( ) ; int max = ( int ) math . min ( n , integer . max_value ) ; int total = _num ; while ( total < max ) { int len = max - total ; if ( len > tmpbuf . length ) { len = tmpbuf . length ; } len = read ( tmpbuf , _num , len ) ; if ( len == - _num ) { entryeof = _bool ; break ; } total += len ; } return total ; }	skips specified number of bytes in the current zip entry .
private path convertpath ( path path ) throws exception { if ( mode != proxy ) return path ; else { uri secondaryuri = new uri ( secondary_uri ) ; uri pathuri = path . touri ( ) ; return new path ( new uri ( pathuri . getscheme ( ) != null ? secondaryuri . getscheme ( ) : null , pathuri . getauthority ( ) != null ? secondaryuri . getauthority ( ) : null , pathuri . getpath ( ) , null , null ) ) ; } }	convert path for exception message testing purposes .
private static string joinarray ( string [ ] array , string delimiter ) { stringbuffer buffer = new stringbuffer ( ) ; for ( int index = _num ; index < array . length ; index ++ ) { buffer . append ( array [ index ] ) ; if ( index < array . length - _num ) { buffer . append ( delimiter ) ; } } return buffer . tostring ( ) ; }	returns a string created by each element of the array , separated by delimiter .
private void outputpartners ( properties ctx , printwriter out , int partnerid , boolean includeany ) { out . println ( _str ) ; if ( includeany ) { out . println ( _str ) ; if ( partnerid == _num ) out . println ( _str ) ; out . println ( _str ) ; } for ( mbpartner partner : getallpartners ( ctx ) ) { out . print ( _str + partner . get_id ( ) + _str ) ; if ( partnerid == partner . get_id ( ) ) out . print ( _str ) ; out . println ( _str + util . maskhtml ( partner . getname ( ) ) + _str ) ; } out . println ( _str ) ; }	output xml list of business partners.
public void stop ( ) { mcancel = _bool ; if ( mrunning . compareandset ( _bool , _bool ) ) { if ( msampledispatchertask != null ) { msampledispatchertask . cancel ( _bool ) ; mfilledbuffers . clear ( ) ; } } }	stops the sample fetching thread.
public chesssquare ( composite parent , chessboard chessboard , int id , boolean islight ) { super ( parent , swt . double_buffered | swt . no_background ) ; board = chessboard ; this . id = id ; this . islight = islight ; addpaintlistener ( paintlistener ) ; addcontrollistener ( controllistener ) ; addmouselistener ( mouselistener ) ; addlistener ( swt . mousewheel , mousewheellistener ) ; addlistener ( swt . mousedown , dndlistener ) ; addlistener ( swt . mouseup , dndlistener ) ; }	creates a chesssquare tied to the specified board .
@ override protected void stopservice ( ) { thread t = keepalivethread ; keepalivethread = null ; if ( t != null ) { t . interrupt ( ) ; } }	stops the engine monitor .
public static int truncatedcompareto ( final calendar cal1 , final calendar cal2 , final int field ) { final calendar truncatedcal1 = truncate ( cal1 , field ) ; final calendar truncatedcal2 = truncate ( cal2 , field ) ; return truncatedcal1 . compareto ( truncatedcal2 ) ; }	determines how two calendars compare up to no more than the specified most significant field .
public boolean isportusable ( storageport storageport ) { return isportusable ( storageport , _bool ) ; }	convenient method to check whether given storage port is usable to compute port metric.
@ override public void actionperformed ( actionevent event ) { string command = event . getactioncommand ( ) ; if ( command . equals ( _str ) ) { attemptfontselection ( ) ; } else if ( command . equals ( _str ) ) { attemptpaintselection ( ) ; } else if ( command . equals ( _str ) ) { attemptmodifyshowtitle ( ) ; } }	handles button clicks by passing control to an appropriate handler method .
void removeattributevalues ( string attrname , set values ) throws smsexception { if ( attrname != null ) { map attrs = getattributes ( ) ; set origvalues = ( set ) attrs . get ( attrname ) ; if ( origvalues != null && ! origvalues . isempty ( ) ) { set newvalues = new hashset ( origvalues ) ; newvalues . removeall ( values ) ; if ( newvalues . isempty ( ) ) { removeattribute ( attrname ) ; } else { map newattrs = new hashmap ( ) ; newattrs . put ( attrname , newvalues ) ; setattributes ( newattrs ) ; } } } }	removes the specified attribute values from amsdk organization.
private static boolean checkcontentcharacters ( string chars ) throws charconversionexception { boolean escape = _bool ; for ( int i = _num ; i < chars . length ( ) ; i ++ ) { char ch = chars . charat ( i ) ; if ( ch <= _num ) { switch ( ch ) { case _num : case _num : case _num : continue ; case _str : if ( escape ) { continue ; } escape = ( i > _num ) && ( chars . charat ( i - _num ) == _str ) ; continue ; case _str : case _str : escape = _bool ; continue ; default : if ( ch < _num ) { throw new charconversionexception ( _str + ( ( int ) ch ) + _str ) ; } } } } return escape == _bool ; }	check if all passed characters match xml expression [ 2 ] .
public void testfindappdeployments ( ) throws exception { war war = createwar ( ) ; testconfigwar ( ) ; list < element > l = deployer . selectappdeployments ( war , domain ) ; assertequals ( _num , l . size ( ) ) ; deployer . removedeployablefromdomain ( war , domain ) ; l = deployer . selectappdeployments ( war , domain ) ; assertequals ( _num , l . size ( ) ) ; }	test deployments analysis in config.
@ override public void drawtop ( final graphics2d g2d ) { final rectangle r = getarea ( ) ; if ( iscontained ( ) ) { r . setlocation ( _num , _num ) ; } else { if ( ! isonscreen ( g2d , r ) ) { return ; } } final composite oldcomposite = g2d . getcomposite ( ) ; try { g2d . setcomposite ( entitycomposite ) ; drawtop ( g2d , r . x , r . y , r . width , r . height ) ; } finally { g2d . setcomposite ( oldcomposite ) ; } }	draw the top layer parts of an entity.
protected void initdebug ( ) { setdebug ( ( getinitparameter ( _str ) == null ) ? _bool : boolean . valueof ( getinitparameter ( _str ) ) ) ; }	initializer for property debug .
protected static rpcpair resolverpcpair ( astnode node , peertyperesolver peerresolver ) { methoddeclaration methoddecl = astresolving . findparentmethoddeclaration ( node ) ; typedeclaration typedecl = ( typedeclaration ) astresolving . findancestor ( node , astnode . type_declaration ) ; assert ( typedecl != null ) ; itype dsttype = peerresolver . getpeertype ( typedecl ) ; if ( dsttype == null ) { return null ; } compilationunit astroot = astresolving . createquickfixast ( dsttype . getcompilationunit ( ) , null ) ; typedeclaration dsttypedecl = javaastutils . findtypedeclaration ( astroot , dsttype . getfullyqualifiedname ( _str ) ) ; if ( dsttypedecl == null ) { return null ; } return new rpcpair ( typedecl , methoddecl , dsttypedecl ) ; }	finds the related rpc components for a given method : declaring type & peer type .
public static void assertequals ( fieldmatrix < ? extends fieldelement < ? > > expected , fieldmatrix < ? extends fieldelement < ? > > observed ) { assert . assertnotnull ( _str , observed ) ; if ( expected . getcolumndimension ( ) != observed . getcolumndimension ( ) || expected . getrowdimension ( ) != observed . getrowdimension ( ) ) { stringbuilder messagebuffer = new stringbuilder ( ) ; messagebuffer . append ( _str ) ; messagebuffer . append ( _str + observed . getrowdimension ( ) + _str + observed . getcolumndimension ( ) ) ; messagebuffer . append ( _str + expected . getrowdimension ( ) + _str + expected . getcolumndimension ( ) ) ; assert . fail ( messagebuffer . tostring ( ) ) ; } for ( int i = _num ; i < expected . getrowdimension ( ) ; ++ i ) { for ( int j = _num ; j < expected . getcolumndimension ( ) ; ++ j ) { fieldelement < ? > eij = expected . getentry ( i , j ) ; fieldelement < ? > oij = observed . getentry ( i , j ) ; assert . assertequals ( eij , oij ) ; } } }	verifies that two matrices are equal.
public void addaddition ( string addition ) { additions . add ( addition ) ; }	adds a new addition date.
private void startnewtransition ( ) { if ( ! hasbounds ( ) ) { throw new unsupportedoperationexception ( _str + _str ) ; } mcurrenttrans = mtransgen . generatenexttransition ( mdrawablerect , mviewportrect ) ; melapsedtime = _num ; mlastframetime = system . currenttimemillis ( ) ; firetransitionstart ( mcurrenttrans ) ; }	generates and starts a transition .
protected void rotateorthogonal ( ) { active . setrotation ( active . getrotation ( ) + _num , this ) ; error . setrotation ( error . getrotation ( ) + _num , this ) ; displaystate ( ) ; repaint ( ) ; }	* * * * * * popup abstractaction . actionperformed method overrides.
private string converttoelementname ( string attributename ) { return attributename . replace ( _str , _str ) ; }	converts an attribute name ( with space ) to an xml element name ( with underscores ) .
private boolean hasothermapandreduceparentnode ( lop tmpnode , arraylist < lop > nodelist , lop node ) { if ( tmpnode . getexeclocation ( ) == execlocation . mapandreduce ) return _bool ; for ( lop n : tmpnode . getoutputs ( ) ) { if ( nodelist . contains ( n ) && ischild ( n , node , idmap ) ) { if ( ! n . equals ( node ) && n . getexeclocation ( ) == execlocation . mapandreduce ) return _bool ; else return hasothermapandreduceparentnode ( n , nodelist , node ) ; } } return _bool ; }	method to see if there is a node of type mapandreduce between tmpnode and node in given node collection.
@ nullable string findlongestnameprefix ( node name , set < string > namespaces ) { if ( namespaces . contains ( name . getqualifiedname ( ) ) ) { return name . getqualifiedname ( ) ; } else if ( name . isgetprop ( ) ) { return findlongestnameprefix ( name . getfirstchild ( ) , namespaces ) ; } return null ; }	gets the longest namespace that is a prefix of the name node.
public static logwriter createlogwriter ( final properties properties ) { properties nondefault = properties ; if ( nondefault == null ) { nondefault = new properties ( ) ; } distributedtestutils . addhydraproperties ( nondefault ) ; distributionconfig dc = new distributionconfigimpl ( nondefault ) ; logwriter logger = logwriterfactory . createlogwriterlogger ( _bool , _bool , dc , _bool ) ; nondefault . put ( distributionconfig . log_writer_name , logger ) ; return logger ; }	creates a new logwriter and adds it to the config properties.
public int session ( ) { return integer . parseint ( fields [ _num ] ) ; }	the session id of the process .
public boolean onbackpressed ( ) { if ( doesdrawerexist ( ) ) { if ( mdrawer . isdrawervisible ( gravity . start ) ) { mdrawer . closedrawer ( gravity . start ) ; return _bool ; } } if ( mcontentview . onbackpressed ( ) ) return _bool ; if ( ! mstatestack . empty ( ) ) { mstatestack . pop ( ) ; if ( ! mstatestack . empty ( ) ) { setstate ( mstatestack . pop ( ) ) ; return _bool ; } } return _bool ; }	called when the user presses the back key.
public void simulatemethod ( sootmethod method , referencevariable thisvar , referencevariable returnvar , referencevariable params [ ] ) { string subsignature = method . getsubsignature ( ) ; if ( subsignature . equals ( _str ) ) { java_io_objectinputstream_latestuserdefinedloader ( method , thisvar , returnvar , params ) ; return ; } else if ( subsignature . equals ( _str ) ) { java_io_objectinputstream_allocatenewobject ( method , thisvar , returnvar , params ) ; return ; } else if ( subsignature . equals ( _str ) ) { java_io_objectinputstream_allocatenewarray ( method , thisvar , returnvar , params ) ; return ; } else { defaultmethod ( method , thisvar , returnvar , params ) ; return ; } }	implements the abstract method simulatemethod.
public sharditerator onlynodeselectoractiveinitializingshardsit ( string nodeattribute , discoverynodes discoverynodes ) { arraylist < shardrouting > ordered = new arraylist < > ( activeshards . size ( ) + allinitializingshards . size ( ) ) ; set < string > selectednodes = sets . newhashset ( discoverynodes . resolvenodesids ( nodeattribute ) ) ; for ( shardrouting shardrouting : activeshards ) { if ( selectednodes . contains ( shardrouting . currentnodeid ( ) ) ) { ordered . add ( shardrouting ) ; } } for ( shardrouting shardrouting : allinitializingshards ) { if ( selectednodes . contains ( shardrouting . currentnodeid ( ) ) ) { ordered . add ( shardrouting ) ; } } if ( ordered . isempty ( ) ) { throw new illegalargumentexception ( _str + nodeattribute + _str ) ; } return new plainsharditerator ( shardid , ordered ) ; }	returns shards based on nodeattributes given such as node name , node attribute , node ip supports node specifications in cluster api.
private void checkchanges ( ) { settings . clearmovienfofilenames ( ) ; if ( cbmovienfofilename1 . isselected ( ) ) { settings . addmovienfofilename ( movienfonaming . filename_nfo ) ; } if ( cbmovienfofilename2 . isselected ( ) ) { settings . addmovienfofilename ( movienfonaming . movie_nfo ) ; } if ( cbmovienfofilename3 . isselected ( ) ) { settings . addmovienfofilename ( movienfonaming . disc_nfo ) ; } certificationstylewrapper wrapper = ( certificationstylewrapper ) cbcertificationstyle . getselecteditem ( ) ; if ( wrapper != null && settings . getmoviecertificationstyle ( ) != wrapper . style ) { settings . setmoviecertificationstyle ( wrapper . style ) ; } }	check changes of checkboxes.
xmenuitempeer [ ] copyitems ( ) { synchronized ( getmenutreelock ( ) ) { return ( xmenuitempeer [ ] ) items . toarray ( new xmenuitempeer [ ] { } ) ; } }	thread - safely creates a copy of the items vector.
public static void connectionclosed ( ) { numconnections . getanddecrement ( ) ; }	informs system metrics of a connection closed event .
public static string buildchatsdp ( string ipaddress , int localport , string protocol , string accepttypes , string wrappertypes , string setup , string path , string direction ) { return buildsdp ( ipaddress , localport , protocol , accepttypes , wrappertypes , null , null , null , setup , path , direction , null , _num ) ; }	build an sdp block for an one - 2 - one chat sessions.
int [ ] determinedimensions ( int sourcecodewords , int errorcorrectioncodewords ) throws writerexception { float ratio = _num ; int [ ] dimension = null ; for ( int cols = mincols ; cols <= maxcols ; cols ++ ) { int rows = calculatenumberofrows ( sourcecodewords , errorcorrectioncodewords , cols ) ; if ( rows < minrows ) { break ; } if ( rows > maxrows ) { continue ; } float newratio = ( ( _num * cols + _num ) * default_module_width ) / ( rows * height ) ; if ( dimension != null && math . abs ( newratio - preferred_ratio ) > math . abs ( ratio - preferred_ratio ) ) { continue ; } ratio = newratio ; dimension = new int [ ] { cols , rows } ; } if ( dimension == null ) { int rows = calculatenumberofrows ( sourcecodewords , errorcorrectioncodewords , mincols ) ; if ( rows < minrows ) { dimension = new int [ ] { mincols , minrows } ; } } if ( dimension == null ) { throw new writerexception ( _str ) ; } return dimension ; }	determine optimal nr of columns and rows for the specified number of codewords .
private static void s_ucumm ( sparseblock a , double [ ] agg , double [ ] c , int m , int n , int rl , int ru ) { double [ ] cprod = ( agg != null ) ? agg : new double [ n ] ; if ( agg == null ) arrays . fill ( cprod , _num ) ; int [ ] cnt = new int [ n ] ; for ( int i = rl , ix = rl * n ; i < ru ; i ++ , ix += n ) { if ( ! a . isempty ( i ) ) { int apos = a . pos ( i ) ; int alen = a . size ( i ) ; int [ ] aix = a . indexes ( i ) ; double [ ] avals = a . values ( i ) ; productagg ( avals , cprod , aix , apos , _num , alen ) ; countagg ( avals , cnt , aix , apos , alen ) ; } for ( int j = _num ; j < n ; j ++ ) if ( cnt [ j ] < i + _num ) cprod [ j ] *= _num ; system . arraycopy ( cprod , _num , c , ix , n ) ; } }	cumprod , opcode : ucum * , sparse input .
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . add ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addall ( collections . list ( super . listoptions ( ) ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public static shoppingcartitem makeitem ( integer cartlocation , string itemtype , string itemdescription , string productcategoryid , bigdecimal baseprice , bigdecimal selectedamount , bigdecimal quantity , map < string , object > attributes , string prodcatalogid , shoppingcart . shoppingcartitemgroup itemgroup , localdispatcher dispatcher , shoppingcart cart , boolean triggerexternalopsbool ) throws cartitemmodifyexception { delegator delegator = cart . getdelegator ( ) ; shoppingcartitem newitem = new shoppingcartitem ( delegator , itemtype , itemdescription , productcategoryid , baseprice , attributes , prodcatalogid , cart . getlocale ( ) , itemgroup ) ; if ( cartlocation == null ) { cart . additemtoend ( newitem ) ; } else { cart . additem ( cartlocation . intvalue ( ) , newitem ) ; } boolean triggerexternalops = triggerexternalopsbool == null ? _bool : triggerexternalopsbool . booleanvalue ( ) ; try { newitem . setquantity ( quantity , dispatcher , cart , triggerexternalops ) ; } catch ( cartitemmodifyexception e ) { cart . removeemptycartitems ( ) ; throw e ; } if ( selectedamount != null ) { newitem . setselectedamount ( selectedamount ) ; } return newitem ; }	makes a non - product shoppingcartitem and adds it to the cart . note : this is only for non - product items ; items without a product entity ( work items , bulk items , etc ).
private native synchronized static void hookmethodnative ( member method , class < ? > declaringclass , int slot , object additionalinfo ) ;	intercept every call to the specified method and call a handler function instead .
private static clusterproperties fromproperties ( properties props ) { clusterproperties prop = new clusterproperties ( ) ; prop . clustername = getstringproperty ( ignite_cluster_name , props , default_cluster_name ) ; prop . cpupernode = getdoubleproperty ( ignite_run_cpu_per_node , props , default_cpu_per_node ) ; prop . mempernode = getdoubleproperty ( ignite_memory_per_node , props , default_mem_per_node ) ; prop . memoverheadpernode = getdoubleproperty ( ignite_memory_overhead_per_node , props , math . max ( _num * prop . mempernode , default_minimum_mem_overhead_per_node ) ) ; prop . nodecnt = getdoubleproperty ( ignite_node_count , props , default_ignite_node_count ) ; prop . igniteurl = getstringproperty ( ignite_url , props , null ) ; prop . ignitepath = getstringproperty ( ignite_path , props , null ) ; prop . licencepath = getstringproperty ( licence_path , props , null ) ; prop . jvmopts = getstringproperty ( ignite_jvm_opts , props , null ) ; prop . igniteworkdir = getstringproperty ( ignite_working_dir , props , default_ignite_work_dir ) ; prop . ignitelocalworkdir = getstringproperty ( ignite_local_work_dir , props , default_ignite_local_work_dir ) ; prop . ignitereleasesdir = getstringproperty ( ignite_releases_dir , props , default_ignite_releases_dir ) ; prop . ignitecfg = getstringproperty ( ignite_config_xml , props , null ) ; prop . userlibs = getstringproperty ( ignite_users_libs , props , null ) ; string pattern = getstringproperty ( ignite_hostname_constraint , props , null ) ; if ( pattern != null ) { try { prop . hostnameconstraint = pattern . compile ( pattern ) ; } catch ( patternsyntaxexception e ) { log . log ( level . warning , _str , e ) ; } } return prop ; }	instantiate a clusterproperties from a set of properties .
public static string generatenativeguid ( storagesystem device ) { return string . format ( _str , _devicetypemap . get ( device . getsystemtype ( ) ) , device . getserialnumber ( ) ) ; }	the format of this native guid is storagesystem + serialnumber.
public vector2 floor ( ) { x = ( float ) math . floor ( x ) ; z = ( float ) math . floor ( z ) ; return this ; }	rounds the x and y values of this vector2 down to the nearest integer value .
public static location createlocation ( final string rawjson ) throws twitterexception { try { final jsonobject json = new jsonobject ( rawjson ) ; return locationconstructor . newinstance ( json ) ; } catch ( final instantiationexception e ) { throw new twitterexception ( e ) ; } catch ( final illegalaccessexception e ) { throw new assertionerror ( e ) ; } catch ( final invocationtargetexception e ) { throw new twitterexception ( e ) ; } catch ( final jsonexception e ) { throw new twitterexception ( e ) ; } }	constructs a location object from rawjson string .
@ override protected int calcattackvalue ( ) { int av = _num ; if ( bdirect ) { av = math . min ( av + ( tohit . getmos ( ) / _num ) , av * _num ) ; } if ( bglancing ) { av = ( int ) math . floor ( av / _num ) ; } av = ( int ) math . floor ( getbracketingmultiplier ( ) * av ) ; return av ; }	calculate the attack value based on range.
public void test_writeimmutable ( ) { final irawstore store = getstore ( ) ; try { final int len = _num ; final byte [ ] expected1 = new byte [ len ] ; r . nextbytes ( expected1 ) ; final bytebuffer tmp = bytebuffer . wrap ( expected1 ) ; final long addr1 = store . write ( tmp ) ; assertequals ( len , tmp . position ( ) ) ; assertequals ( tmp . position ( ) , tmp . limit ( ) ) ; assertequals ( expected1 , store . read ( addr1 ) ) ; final byte [ ] expected2 = expected1 . clone ( ) ; r . nextbytes ( expected1 ) ; assertequals ( expected2 , store . read ( addr1 ) ) ; } finally { store . destroy ( ) ; } }	test verifies that write does not permit changes to the store state by modifying the supplied buffer after the write operation ( i.
@ override public string querytoretrievedata ( ) { string parameterizedquery ; if ( query . contains ( _str ) ) { parameterizedquery = query . replace ( _str , startrow + _str ) ; } else { parameterizedquery = query ; } return parameterizedquery ; }	this method replaces the parameters in query with actual values given by user . example of retrievequery : select * from % t where % p > % s batchsize % l ;.
public string tostring ( ) { string classname = util . getunqualifiedname ( getclass ( ) ) ; return ( ref == null ) ? classname : classname + _str + ref . remotetostring ( ) + _str ; }	returns a string that represents the value of this remote object .
private static void initialise ( ) { hints hints = new hints ( hints . crs , defaultgeographiccrs . wgs84 ) ; positionfactory positionfactory = geometryfactoryfinder . getpositionfactory ( hints ) ; geometryfactory geometryfactory = geometryfactoryfinder . getgeometryfactory ( hints ) ; primitivefactory primitivefactory = geometryfactoryfinder . getprimitivefactory ( hints ) ; aggregatefactory aggregatefactory = geometryfactoryfinder . getaggregatefactory ( hints ) ; wktparser = new wktparser ( geometryfactory , primitivefactory , positionfactory , aggregatefactory ) ; wkttypelist . add ( new wkttype ( wkt_point , _bool , _num , _str , _bool ) ) ; wkttypelist . add ( new wkttype ( wkt_multipoint , _bool , _num , _str , _bool ) ) ; wkttypelist . add ( new wkttype ( wkt_linestring , _bool , _num , _str , _bool ) ) ; wkttypelist . add ( new wkttype ( _str , _bool , _num , _str , _bool ) ) ; wkttypelist . add ( new wkttype ( wkt_multilinestring , _bool , _num , _str , _bool ) ) ; wkttypelist . add ( new wkttype ( wkt_polygon , _bool , - _num , _str , _bool ) ) ; wkttypelist . add ( new wkttype ( wkt_multipolygon , _bool , - _num , _str , _bool , _bool ) ) ; for ( wkttype wkytype : wkttypelist ) { wkttypemap . put ( wkytype . getname ( ) , wkytype ) ; } }	initialise the wktparser object.
public instances prunetok ( instances neighbours , double [ ] distances , int k ) { if ( neighbours == null || distances == null || neighbours . numinstances ( ) == _num ) { return null ; } if ( k < _num ) { k = _num ; } int currentk = _num ; double currentdist ; for ( int i = _num ; i < neighbours . numinstances ( ) ; i ++ ) { currentk ++ ; currentdist = distances [ i ] ; if ( currentk > k && currentdist != distances [ i - _num ] ) { currentk -- ; neighbours = new instances ( neighbours , _num , currentk ) ; break ; } } return neighbours ; }	prunes the list to contain the k nearest neighbors.
@ override protected string doinbackground ( string ... f_url ) { int count ; inputstream input = null ; outputstream output = null ; try { url url = new url ( f_url [ _num ] ) ; urlconnection connection = url . openconnection ( ) ; connection . connect ( ) ; int lengthoffile = connection . getcontentlength ( ) ; input = new bufferedinputstream ( url . openstream ( ) , _num ) ; output = new fileoutputstream ( f_url [ _num ] ) ; byte data [ ] = new byte [ _num ] ; long total = _num ; while ( ( count = input . read ( data ) ) != - _num ) { total += count ; publishprogress ( integer . tostring ( ( int ) ( ( total * _num ) / lengthoffile ) ) ) ; output . write ( data , _num , count ) ; } output . flush ( ) ; } catch ( exception e ) { log . e ( _str , e . getmessage ( ) ) ; } finally { try { if ( output != null ) output . close ( ) ; } catch ( exception e ) { log . e ( _str , e . getmessage ( ) ) ; } try { if ( input != null ) input . close ( ) ; } catch ( exception e ) { log . e ( _str , e . getmessage ( ) ) ; } } return null ; }	downloading file in background thread.
public void error ( string msg ) { print ( _str + msg , out . err ) ; }	print an error to printstream.
public static void loadarmv7alibrary ( applicationlike applicationlike , string libname ) { if ( libname == null || libname . isempty ( ) || applicationlike == null ) { throw new tinkerruntimeexception ( _str ) ; } if ( tinkerapplicationhelper . istinkerenablefornativelib ( applicationlike ) ) { if ( tinkerapplicationhelper . loadlibraryfromtinker ( applicationlike , _str , libname ) ) { return ; } } system . loadlibrary ( libname ) ; }	only support auto load lib / armeabi - v7a library from patch . in some process , you may not want to install tinker and you can load patch dex and library without install tinker ! }.
atomicsequence ( final long initialvalue ) { updater . lazyset ( this , initialvalue ) ; }	create a sequence with a specified initial value .
public void keyreleased ( keyevent e ) { if ( e . isshiftdown ( ) && e . getkeycode ( ) == next_throttle_key ) { requestfocusfornextframe ( ) ; } else if ( e . isshiftdown ( ) && e . getkeycode ( ) == prev_throttle_key ) { requestfocusforpreviousframe ( ) ; } }	description of the method.
protected static long convertstringtobuckectinglong ( string stringtobeconverted ) { if ( stringtobeconverted == null || stringtobeconverted . equals ( _str ) ) { return null ; } byte [ ] bytestring = stringtobeconverted . getbytes ( ) ; if ( bytestring . length < _num ) { byte [ ] newbytestring = new byte [ _num ] ; for ( int i = _num ; i < newbytestring . length ; i ++ ) { if ( i < bytestring . length ) { newbytestring [ i ] = bytestring [ i ] ; } else { newbytestring [ i ] = _num ; } } bytestring = newbytestring ; } bytebuffer bb = bytebuffer . wrap ( bytestring ) ; long bytemethod = bb . getlong ( ) ; bytemethod = math . abs ( bytemethod ) ; return bytemethod ; }	converts a string into long values takes the first 8 bytes and uses those to convert them into long , if the string does not contain 8 bytes we pad them with zeros.
@ override public void closeinvoked ( ) { }	invoked when the connection receives the close request not used for now .
private void pendingevent ( eventreg reg , serviceid sid , item item , int transition , boolean copyitem ) { if ( item != null && copyitem ) item = copyitem ( item ) ; newnotifies . add ( new eventtask ( reg , sid , item , transition ) ) ; }	add a pending eventtask for this event registration .
public static void writeln ( string filename , object [ ] objects ) { if ( writer == null ) { createwriter ( filename ) ; for ( object obj : objects ) { writeln ( obj . tostring ( ) ) ; } closewriter ( ) ; } }	writes an array of objects to a text file , each on a line .
protected double regressionprediction ( instance transformedinstance , boolean [ ] selectedattributes , double [ ] coefficients ) throws exception { double result = _num ; int column = _num ; for ( int j = _num ; j < transformedinstance . numattributes ( ) ; j ++ ) { if ( ( m_classindex != j ) && ( selectedattributes [ j ] ) ) { result += coefficients [ column ] * transformedinstance . value ( j ) ; column ++ ; } } result += coefficients [ column ] ; return result ; }	calculate the dependent value for a given instance for a given regression model .
public qlfdocument ( list < f > list , string docno , map < string , string > extraprops ) { featurelist = new memorylocalfeaturelist < f > ( list ) ; iterator = list . iterator ( ) ; if ( extraprops != null ) props . putall ( extraprops ) ; props . put ( _str , docno ) ; }	construct a new qlfdocument instance from the contents of the given feature list .
@ override protected templatemodel invokegenericget ( map keymap , class clazz , string key ) throws templatemodelexception { map map = ( map ) object ; object val = map . get ( key ) ; if ( val == null ) { if ( key . length ( ) == _num ) { character charkey = character . valueof ( key . charat ( _num ) ) ; val = map . get ( charkey ) ; if ( val == null && ! ( map . containskey ( key ) || map . containskey ( charkey ) ) ) { return unknown ; } } else if ( ! map . containskey ( key ) ) { return unknown ; } } return wrap ( val ) ; }	overridden to invoke the generic get method by casting to map instead of through reflection - should yield better performance .
public byte [ ] tozorderbytearray ( final biginteger bigint ) { final int numdimensions = datatypeconfig . getnumdimensions ( ) ; final byte [ ] bigintasbytearr = bigint . tobytearray ( ) ; final int paddedarraysize = numdimensions * base_size + _num ; final byte [ ] bigintasbytearrpad = new byte [ paddedarraysize ] ; int idx = _num ; for ( int i = _num ; i < paddedarraysize - bigintasbytearr . length ; i ++ ) { bigintasbytearrpad [ idx ++ ] = _num ; } for ( int i = _num ; i < bigintasbytearr . length ; i ++ ) { bigintasbytearrpad [ idx ++ ] = bigintasbytearr [ i ] ; } final byte [ ] bigintasbytearrunsigned = unpadleadingzero ( bigintasbytearrpad ) ; return bigintasbytearrunsigned ; }	decodes a biginteger into a zorder byte [ ] ( without leading zero ).
public void clearlogcat ( @ notnull idevice device , @ notnull project project ) { synchronized ( mylock ) { executorservice executor = myexecutors . get ( device ) ; if ( executor != null ) { stopreceiving ( device ) ; executor . submit ( null ) ; startreceiving ( device ) ; } } }	clears logs for the current device .
private stringset discovervolumesnaps ( storagesystem system , list < snap > snaps , string parentguid , stringset parentmatchedvpools , vnxeapiclient apiclient , dbclient dbclient , map < string , list < unmanagedvolume > > hostvolumesmap , vnxelun lun , boolean issnapincg , string cgname ) throws exception { stringset snapsets = new stringset ( ) ; for ( snap snapdetail : snaps ) { unmanagedvolume unmanagedvolume = null ; string managedsnapnativeguid = nativeguidgenerator . generatenativeguidforvolumeorblocksnapshot ( system . getnativeguid ( ) , snapdetail . getid ( ) ) ; blocksnapshot viprsnap = discoveryutils . checkblocksnapshotexistsindb ( dbclient , managedsnapnativeguid ) ; if ( null != viprsnap ) { log . info ( _str , managedsnapnativeguid ) ; snapsets . add ( managedsnapnativeguid ) ; continue ; } string unmanagedvolumenatvieguid = nativeguidgenerator . generatenativeguidforpreexistingvolume ( system . getnativeguid ( ) , snapdetail . getid ( ) ) ; unmanagedvolume = discoveryutils . checkunmanagedvolumeexistsindb ( dbclient , unmanagedvolumenatvieguid ) ; unmanagedvolume = createunmanagedvolumeforsnap ( unmanagedvolume , unmanagedvolumenatvieguid , lun , system , dbclient , hostvolumesmap , snapdetail ) ; populatesnapinfo ( unmanagedvolume , snapdetail , parentguid , parentmatchedvpools ) ; snapsets . add ( unmanagedvolumenatvieguid ) ; unmanagedvolumesreturnedfromprovider . add ( unmanagedvolume . getid ( ) ) ; if ( issnapincg ) { addobjecttounmanagedconsistencygroup ( apiclient , unmanagedvolume , cgname , system , dbclient ) ; } } return snapsets ; }	discover lun snaps , and create unmanagedvolume for the snaps.
public void receive ( final callevent event ) { if ( event . isvalid ( ) ) { if ( ! mevents . contains ( event ) ) { mevents . add ( _num , event ) ; firetablerowsinserted ( _num , _num ) ; prune ( ) ; } else { int row = mevents . indexof ( event ) ; firetablerowsupdated ( row , row ) ; } } else { if ( mevents . contains ( event ) ) { int row = mevents . indexof ( event ) ; mevents . remove ( event ) ; firetablerowsdeleted ( row , row ) ; } } }	adds , updates or deletes the event from the model.
public pet findone ( string id ) { log . debug ( _str , id ) ; pet pet = petrepository . findone ( uuid . fromstring ( id ) ) ; return pet ; }	get one pet by id .
public final void clear ( ) { mactiveissues . clear ( ) ; }	clears all the issues for this health check .
public static void awaitdataready ( ) { synchronized ( mdbhelperlock ) { if ( mdbhelper == null ) { try { mdbhelperlock . wait ( ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } } }	this method blocks until the underlying data store is ready.
protected abstractiosession ( ioservice service ) { this . service = service ; this . handler = service . gethandler ( ) ; long currenttime = system . currenttimemillis ( ) ; creationtime = currenttime ; lastthroughputcalculationtime = currenttime ; lastreadtime = currenttime ; lastwritetime = currenttime ; lastidletimeforboth = currenttime ; lastidletimeforread = currenttime ; lastidletimeforwrite = currenttime ; closefuture . addlistener ( scheduled_counter_resetter ) ; sessionid = idgenerator . incrementandget ( ) ; }	todo add method documentation.
private string processfloattoken ( string token ) { string result = token . replaceall ( groupseparator , _str ) ; if ( ! decimalseparator . equals ( _str ) ) result = result . replaceall ( decimalseparator , _str ) ; boolean isnegative = _bool ; int prelen = negativeprefix . length ( ) ; if ( ( prelen > _num ) && result . startswith ( negativeprefix ) ) { isnegative = _bool ; result = result . substring ( prelen ) ; } int suflen = negativesuffix . length ( ) ; if ( ( suflen > _num ) && result . endswith ( negativesuffix ) ) { isnegative = _bool ; result = result . substring ( result . length ( ) - suflen , result . length ( ) ) ; } if ( result . equals ( nanstring ) ) result = _str ; if ( result . equals ( infinitystring ) ) result = _str ; if ( isnegative ) result = _str + result ; matcher m = non_ascii_digit . matcher ( result ) ; if ( m . find ( ) ) { stringbuilder inascii = new stringbuilder ( ) ; for ( int i = _num ; i < result . length ( ) ; i ++ ) { char nextchar = result . charat ( i ) ; if ( character . isdigit ( nextchar ) ) { int d = character . digit ( nextchar , _num ) ; if ( d != - _num ) inascii . append ( d ) ; else inascii . append ( nextchar ) ; } else { inascii . append ( nextchar ) ; } } result = inascii . tostring ( ) ; } return result ; }	the float token must be stripped of prefixes , group separators , and suffixes , non ascii digits must be converted into ascii digits before parsefloat will accept it.
internalwindow ( string title ) { setlayout ( new borderlayout ( ) ) ; titlebar = new titlebar ( ) ; add ( titlebar , borderlayout . north ) ; titlebar . setlayout ( new sboxlayout ( sboxlayout . horizontal , titlebar_padding ) ) ; titlelabel = new jlabel ( ) ; settitle ( title ) ; titlelabel . setminimumsize ( new dimension ( _num , _num ) ) ; titlebar . add ( titlelabel ) ; sboxlayout . addspring ( titlebar ) ; minimizebutton = new jbutton ( minimizeicon ) ; minimizebutton . setmargin ( new insets ( _num , _num , _num , _num ) ) ; minimizebutton . setborder ( borderfactory . createemptyborder ( ) ) ; minimizebutton . setfocusable ( _bool ) ; minimizebutton . addactionlistener ( new minimizelistener ( ) ) ; titlebar . add ( minimizebutton ) ; closebutton = new jbutton ( closeicon ) ; closebutton . setmargin ( new insets ( _num , _num , _num , _num ) ) ; closebutton . setborder ( borderfactory . createemptyborder ( ) ) ; closebutton . setfocusable ( _bool ) ; closebutton . addactionlistener ( new closeactionlistener ( ) ) ; titlebar . add ( closebutton ) ; cache = new componentpaintcache ( this ) ; }	create a new internalwindow .
@ suppresswarnings ( _str ) public static map < string , object > loadstream ( inputstream inputstream ) { log . fine ( _str ) ; yaml yaml = new yaml ( ) ; map < object , object > propsyaml = ( map < object , object > ) yaml . load ( inputstream ) ; log . fine ( _str ) ; map < string , object > typedmap = new hashmap < > ( ) ; for ( object key : propsyaml . keyset ( ) ) { typedmap . put ( key . tostring ( ) , propsyaml . get ( key ) ) ; } return typedmap ; }	load config from the given yaml stream.
string [ ] split ( final string stringtosplit ) { if ( stringutils . isnotblank ( stringtosplit ) ) { int strlenght = stringtosplit . length ( ) ; int splitnum = strlenght / chunksize ; if ( strlenght % chunksize > _num ) { splitnum += _num ; } string [ ] result = new string [ splitnum ] ; for ( int i = _num ; i < splitnum ; i ++ ) { int startpos = i * chunksize ; int endpos = startpos + chunksize ; if ( endpos > strlenght ) { endpos = strlenght ; } result [ i ] = stringtosplit . substring ( startpos , endpos ) ; } return result ; } return null ; }	split string to chunks by size .
public void logvelocitymessage ( int level , string message ) { synchronized ( this ) { object [ ] data = new object [ _num ] ; data [ _num ] = new integer ( level ) ; data [ _num ] = message ; pendingmessages . addelement ( data ) ; } }	logs messages . all we do is store them until ' later ' .
public void testshiftrightnegnonzeroes ( ) { byte abytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = - _num ; int number = _num ; byte rbytes [ ] = { - _num , - _num , _num , - _num , _num , - _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . shiftright ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , result . signum ( ) ) ; }	shiftright a negative number ; shift distance is not multiple of 32 ; shifted bits are not zeroes .
public void removealladdresses ( ) { addresses . clear ( ) ; }	removes all addresses from this user.
public static boolean isshowtooltips ( ) { return showtooltips ; }	indicates whether tooltips should be shown when the keys in the vkb are pressed.
public static boolean ispropertyfield ( string fieldname ) { return ! id_field_name . equals ( fieldname ) && ! uri_field_name . equals ( fieldname ) && ! text_field_name . equals ( fieldname ) && ! context_field_name . equals ( fieldname ) && fieldname . charat ( _num ) != _str ; }	determines whether the specified field name is a property field name .
public static void checkaccess ( int modifiers ) { if ( system . getsecuritymanager ( ) != null && ! modifier . ispublic ( modifiers ) ) { throw new securityexception ( _str ) ; } }	utility method that throws securityexception if securitymanager is set and modifiers are not public.
protected void printindent ( stringbuilder ddl ) { ddl . append ( getindent ( ) ) ; }	prints the characters used to indent sql .
public ntype merge ( ntype a , ntype b ) throws mergefailed { if ( a != null && b == null ) return a ; if ( a == null && b != null ) return b ; if ( a == null && b == null ) return null ; if ( a . equals ( b ) ) return a ; try { return dispatcher . dispatch ( getclass ( ) , this , _str , a , b ) ; } catch ( nosuchmethodexception e ) { throw new mergefailed ( _str , a , b ) ; } }	merge a and b .
public static string format ( string s , string col ) { string s1 = ( s + padd ) ; return s1 . substring ( _num , math . min ( col . length ( ) , s1 . length ( ) ) ) ; }	pad a string from right .
protected static void loadend ( mlookupinfo info , hashmap lookup ) { if ( info . isvalidated && lookup . size ( ) > _num ) s_loadedlookups . put ( getkey ( info ) , lookup ) ; }	mlookup loader ends loading , so add it to cache.
public static void info ( final string message ) { infologger . accept ( message ) ; }	logs a message to the configured info logger .
private void checknocharactersmissing ( int totallength , list < token > tokens ) { if ( ! tokens . isempty ( ) && tokens . get ( tokens . size ( ) - _num ) . right != totallength ) { string error = string . format ( _str , tokens . get ( tokens . size ( ) - _num ) . right , totallength ) ; throw new runtimeexception ( error ) ; } int start = _num ; for ( int i = _num ; i < tokens . size ( ) ; i ++ ) { token token = tokens . get ( i ) ; if ( token . left != start ) { throw new runtimeexception ( _str + start ) ; } start = token . right ; } }	temporary debugging code . we need to tokenize every character in the input string .
public boolean validateserviceattributes ( string token , string validatorclass , set values ) throws smsexception , ssoexception , remoteexception { initialize ( ) ; if ( debug . messageenabled ( ) ) { debug . message ( _str + validatorclass + _str + values ) ; } try { class clazz = class . forname ( validatorclass ) ; serviceattributevalidator v = ( serviceattributevalidator ) clazz . newinstance ( ) ; return v . validate ( values ) ; } catch ( instantiationexception ex ) { throw new smsexception ( _str ) ; } catch ( illegalaccessexception ex ) { throw new smsexception ( _str ) ; } catch ( classnotfoundexception ex ) { throw new smsexception ( _str ) ; } }	validates service configuration attributes .
public synchronized void animatepanto ( point2d p , long duration ) { point2d pp = new point2d . double ( ) ; m_itransform . transform ( p , pp ) ; animatepantoabs ( pp , duration ) ; }	animate a pan to the specified location in screen ( pixel ) co - ordinates using the provided duration .
public static void assertequalswithrelativeerrororbothnan ( string message , double expected , double actual ) { if ( expected == actual ) { return ; } if ( double . isnan ( expected ) && ! double . isnan ( actual ) ) { throw new assertionfailederror ( message + _str + expected + _str + actual + _str ) ; } if ( ! double . isnan ( expected ) && double . isnan ( actual ) ) { throw new assertionfailederror ( message + _str + expected + _str + actual + _str ) ; } double relativeerror ; if ( math . abs ( actual ) > math . abs ( expected ) ) { relativeerror = math . abs ( ( expected - actual ) / actual ) ; } else { relativeerror = math . abs ( ( expected - actual ) / expected ) ; } if ( relativeerror > max_relative_error ) { throw new assertionfailederror ( message + _str + expected + _str + actual + _str ) ; } }	attention : does not work with values near 0 ! !.
protected void assertexception ( final abstractexceptioncase exceptioncase ) throws throwable { assertexception ( exceptioncase , null ) ; }	checks that code block throw corresponding exception .
@ override public servicehost start ( ) throws throwable { super . start ( ) ; startdefaultcoreservicessynchronously ( ) ; super . startservice ( new rootnamespaceservice ( ) ) ; super . startservice ( new sampleservicewithsharedcustomui ( ) ) ; super . startservice ( new samplefactoryservicewithcustomui ( ) ) ; super . startfactory ( new samplesimpleechoservice ( ) ) ; super . startfactory ( new samplepreviousechoservice ( ) ) ; super . startfactory ( new exampleservice ( ) ) ; super . startfactory ( new exampletaskservice ( ) ) ; super . startservice ( new uiservice ( ) ) ; startswaggerdescriptorservice ( ) ; return this ; }	start services : a host can run multiple services .
@ override public void endofstream ( ) throws adeexception { for ( msgdata data : m_msgdata . values ( ) ) { if ( data . m_totallogcounts > _num ) { data . m_lambda = data . m_totallogcounts / data . m_intervalcount ; m_minlambda = math . min ( data . m_lambda , m_minlambda ) ; if ( locatemismatchingdistributions ( data ) ) { data . m_badfit = _bool ; } } } m_trained = _bool ; }	at the end of the stream , for all the message data we ' ve collected , we calculate the lamba value and determine if the message data is a " bad fit " i.
static binarytree < integer > buildcomplete ( int n ) { binarytree < integer > bt = new binarytree < integer > ( ) ; int b = ( int ) math . pow ( _num , n - _num ) ; for ( int i = _num ; i < n ; i ++ ) { bt . insert ( b ) ; for ( int j = _num ; j <= math . pow ( _num , i ) - _num ; j ++ ) { bt . insert ( b + _num * b * j ) ; } b = b / _num ; } return bt ; }	build a complete tree with 2 ^ n - 1 nodes .
public void erase ( ) { byte [ ] bytes = null ; for ( bytebuffer buffer : buffers ) { if ( bytes == null || bytes . length < buffer . limit ( ) ) bytes = new byte [ buffer . limit ( ) ] ; buffer . position ( _num ) ; buffer . put ( bytes , _num , buffer . limit ( ) ) ; buffer . position ( _num ) ; } }	erase file by setting all bytes to 0.
public void logpurchase ( bigdecimal purchaseamount , currency currency , bundle parameters ) { if ( purchaseamount == null ) { notifydevelopererror ( _str ) ; return ; } else if ( currency == null ) { notifydevelopererror ( _str ) ; return ; } if ( parameters == null ) { parameters = new bundle ( ) ; } parameters . putstring ( appeventsconstants . event_param_currency , currency . getcurrencycode ( ) ) ; logevent ( appeventsconstants . event_name_purchased , purchaseamount . doublevalue ( ) , parameters ) ; eagerflush ( ) ; }	logs a purchase event with facebook , in the specified amount and with the specified currency.
public static string padbetween ( final string first , final int length , final string last ) { final int padlen = length - ( first . length ( ) + last . length ( ) ) ; return first + ( padlen > _num ? getspacestring ( padlen ) : _str ) + last ; }	pads out two string by inserting spaces between them .
public void applyfromresolveinfo ( packagemanager pm , resolveinfo info , widgetpreviewloader loader ) { minfo = info ; charsequence label = info . loadlabel ( pm ) ; mwidgetname . settext ( label ) ; mwidgetdims . settext ( string . format ( mdimensionsformatstring , _num , _num ) ) ; mwidgetpreviewloader = loader ; }	apply the resolve info to the view .
private queueconnectionimpl createnewprimary ( set excludedservers ) { queueconnectionimpl primary = null ; while ( primary == null && pool . getpoolorcachecancelinprogress ( ) == null ) { list servers = findqueueservers ( excludedservers , _num , _bool , printprimarynotfounderror , localizedstrings . queuemanagerimpl_could_not_find_server_to_create_primary_client_queue ) ; printprimarynotfounderror = _bool ; if ( servers == null || servers . isempty ( ) ) { break ; } connection connection = null ; try { connection = factory . createclienttoserverconnection ( ( serverlocation ) servers . get ( _num ) , _bool ) ; } catch ( gemfiresecurityexception e ) { throw e ; } catch ( exception e ) { if ( logger . isdebugenabled ( ) ) { logger . debug ( _str , servers . get ( _num ) ) ; } } if ( connection != null ) { primary = initializequeueconnection ( connection , _bool , queueconnections . getfailedupdater ( ) ) ; } excludedservers . addall ( servers ) ; } if ( primary != null && sentclientready && primary . sendclientready ( ) ) { readyforeventsafterfailover ( primary ) ; } return primary ; }	create a new primary server from a non - redundant server.
public static int readint ( ) { return scanner . nextint ( ) ; }	reads the next token from standard input , parses it as an integer , and returns the integer .
public csvconfig guess ( ) { try { bufferedreader bin = new bufferedreader ( new inputstreamreader ( getinputstream ( ) , standardcharsets . utf_8 ) ) ; string [ ] lines = new string [ _num ] ; string line = null ; int counter = _num ; while ( ( line = bin . readline ( ) ) != null && counter <= _num ) { lines [ counter ] = line ; counter ++ ; } if ( counter < _num ) { string [ ] newlines = new string [ counter ] ; system . arraycopy ( lines , _num , newlines , _num , counter ) ; lines = newlines ; } analyselines ( lines ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( exception e ) { } } } csvconfig conf = config ; config = null ; return conf ; }	guess the config based on the first 10 ( or less when less available ) records of a csv file .
private void updatedesign ( datasetdesign datasetdesign , iconnection conn , string querytext ) throws odaexception { iquery query = conn . newquery ( null ) ; query . prepare ( querytext ) ; query . setproperty ( query . prop_setup_query_text , getsetupquerytext ( ) ) ; try { iresultsetmetadata md = query . getmetadata ( ) ; updateresultsetdesign ( md , datasetdesign ) ; } catch ( odaexception e ) { datasetdesign . setresultsets ( null ) ; e . printstacktrace ( ) ; } try { iparametermetadata parammd = query . getparametermetadata ( ) ; updateparameterdesign ( parammd , datasetdesign ) ; } catch ( odaexception ex ) { datasetdesign . setparameters ( null ) ; ex . printstacktrace ( ) ; } }	updates the given datasetdesign with the querytext and its derived metadata obtained from the oda runtime connection .
public void runtest ( ) throws throwable { document doc ; nodelist elementlist ; node namenode ; characterdata child ; string badsubstring ; doc = ( document ) load ( _str , _bool ) ; elementlist = doc . getelementsbytagname ( _str ) ; namenode = elementlist . item ( _num ) ; child = ( characterdata ) namenode . getfirstchild ( ) ; { boolean success = _bool ; try { badsubstring = child . substringdata ( _num , - _num ) ; } catch ( domexception ex ) { success = ( ex . code == domexception . index_size_err ) ; } asserttrue ( _str , success ) ; } }	runs the test case .
public static string tostring ( jsonobject jo ) throws jsonexception { stringbuffer sb = new stringbuffer ( ) ; sb . append ( escape ( jo . getstring ( _str ) ) ) ; sb . append ( _str ) ; sb . append ( escape ( jo . getstring ( _str ) ) ) ; if ( jo . has ( _str ) ) { sb . append ( _str ) ; sb . append ( jo . getstring ( _str ) ) ; } if ( jo . has ( _str ) ) { sb . append ( _str ) ; sb . append ( escape ( jo . getstring ( _str ) ) ) ; } if ( jo . has ( _str ) ) { sb . append ( _str ) ; sb . append ( escape ( jo . getstring ( _str ) ) ) ; } if ( jo . optboolean ( _str ) ) { sb . append ( _str ) ; } return sb . tostring ( ) ; }	convert a jsonobject into a cookie specification string.
@ override public boolean equals ( object otherrule ) { if ( otherrule == this ) { return _bool ; } if ( otherrule instanceof zoneoffsettransitionrule ) { zoneoffsettransitionrule other = ( zoneoffsettransitionrule ) otherrule ; return month == other . month && dom == other . dom && dow == other . dow && timedefinition == other . timedefinition && time . equals ( other . time ) && timeendofday == other . timeendofday && standardoffset . equals ( other . standardoffset ) && offsetbefore . equals ( other . offsetbefore ) && offsetafter . equals ( other . offsetafter ) ; } return _bool ; }	checks if this object equals another.
private void initializemembershipmatrix ( ) { for ( int i = _num ; i < points . size ( ) ; i ++ ) { for ( int j = _num ; j < k ; j ++ ) { membershipmatrix [ i ] [ j ] = random . nextdouble ( ) ; } membershipmatrix [ i ] = matharrays . normalizearray ( membershipmatrix [ i ] , _num ) ; } }	initialize the membership matrix with random values .
public static void writeall ( outputstream stream , object [ ] o ) throws exception { objectoutputstream oos ; int i ; if ( ! ( stream instanceof bufferedoutputstream ) ) { stream = new bufferedoutputstream ( stream ) ; } oos = new objectoutputstream ( stream ) ; for ( i = _num ; i < o . length ; i ++ ) { oos . writeobject ( o [ i ] ) ; } oos . flush ( ) ; oos . close ( ) ; }	serializes the given objects to the specified stream .
public synchronized void reset ( ) { mbufvertices . position ( _num ) ; mbufcolors . position ( _num ) ; if ( draw_texture ) { mbuftexcoords . position ( _num ) ; } for ( int i = _num ; i < _num ; ++ i ) { vertex tmp = marrtempvertices . get ( _num ) ; tmp . set ( mrectangle [ i ] ) ; if ( mfliptexture ) { tmp . mtexx *= mtexturerectback . right ; tmp . mtexy *= mtexturerectback . bottom ; tmp . mcolor = mtexturepage . getcolor ( curlpage . side_back ) ; } else { tmp . mtexx *= mtexturerectfront . right ; tmp . mtexy *= mtexturerectfront . bottom ; tmp . mcolor = mtexturepage . getcolor ( curlpage . side_front ) ; } addvertex ( tmp ) ; } mverticescountfront = _num ; mverticescountback = _num ; mbufvertices . position ( _num ) ; mbufcolors . position ( _num ) ; if ( draw_texture ) { mbuftexcoords . position ( _num ) ; } mdropshadowcount = mselfshadowcount = _num ; }	resets mesh to ' initial ' state.
public b css ( @ nonnls string classes ) { return css ( classes , null ) ; }	sets the css classes for the last added element .
public static argumentexception adaptpropertyexception ( propertyexception e , abstractmanagedobjectdefinition < ? , ? > d ) { return new argumentexception ( e . getmessageobject ( ) ) ; }	creates an argument exception from a property exception .
private consumer < operation > createnotificationtarget ( ) { return null ; }	this creates a lambda to receive notifications.
public void write ( byte [ ] bytes ) throws ioexception { dataoutput . write ( bytes ) ; offset += bytes . length ; }	writes a byte array completely .
static synchronized boolean isshapingsupported ( ) { if ( isshapingsupported == null ) { xtoolkit . awtlock ( ) ; try { isshapingsupported = xlibwrapper . xshapequeryextension ( xtoolkit . getdisplay ( ) , xlibwrapper . larg1 , xlibwrapper . larg2 ) ; } finally { xtoolkit . awtunlock ( ) ; } } return isshapingsupported . booleanvalue ( ) ; }	returns whether the xshape extension available.
private boolean isidchar ( int ch ) { return isalpha ( ch ) || isdigit ( ch ) || ch == _str || ch == _str || ch == _str || ch == _str || character . isletter ( ch ) ; }	from html 4 . 0 [ 4 ] namechar : : = letter | digit | ' . ' | ' - ' | ' _ ' | ' : ' | combiningchar | extender [ 5 ] name : : = ( letter | ' _ ' | ' : ' ) ( namechar ) [ 6 ] names : : = name ( # x20 name ) [ 7 ] nmtoken : : = ( namechar ) + [ 8 ] nmtokens : : = nmtoken ( # x20 nmtoken ).
protected string handletimeseal ( string text ) throws ioexception { string result = text ; if ( log . isdebugenabled ( ) ) log . debug ( _str + result ) ; while ( result . contains ( _str ) ) { sendack ( ) ; result = result . replacefirst ( _str , _str ) ; if ( log . isdebugenabled ( ) ) log . debug ( _str + result ) ; } if ( log . isdebugenabled ( ) ) log . debug ( _str + result ) ; return result ; }	handles sending the timeseal ack .
protected locationhandler ( location location , option ... options ) { this . location = location ; this . options = options . length == _num ? enumset . noneof ( option . class ) : enumset . copyof ( arrays . aslist ( options ) ) ; }	create a handler . the location and options provide a way to map from a location or an option to the corresponding handler .
private void init ( ) { _logger . debug ( _str ) ; list = new concurrentlinkedqueue < arrivedindication > ( ) ; intermediateprocessor intermediateprocessor = new intermediateprocessor ( list , _processor ) ; indicationprocesstimer = executors . newsinglethreadscheduledexecutor ( ) ; indicationprocesstimer . schedulewithfixeddelay ( intermediateprocessor , cimconstants . indication_process_interval , periodic_delay , timeunit . seconds ) ; }	will get called during construction phase , configured through spring xml configuration.
public static final string longtohexstring ( long a ) { stringbuffer sb = new stringbuffer ( _num ) ; for ( int i = _num ; i < _num ; i ++ ) sb . append ( nibble [ ( int ) ( a > > > ( _num - _num * i ) ) & _num ] ) ; return sb . tostring ( ) ; }	convert a long to a string of hexadecimal digits .
private date watchcorestartat ( solrserver client , final long timeout , final date min ) throws interruptedexception , ioexception , solrserverexception { final long sleepinterval = _num ; long timeslept = _num ; solrparams p = params ( _str , _str , _str , _str ) ; while ( timeslept < timeout ) { queryrequest req = new queryrequest ( p ) ; req . setpath ( _str ) ; try { namedlist data = client . request ( req ) ; for ( string k : new string [ ] { _str , _str } ) { object o = data . get ( k ) ; assertnotnull ( _str + k , o ) ; data = ( namedlist ) o ; } date starttime = ( date ) data . get ( _str ) ; assertnotnull ( _str , starttime ) ; if ( null == min || starttime . after ( min ) ) { return starttime ; } } catch ( solrexception e ) { if ( _num != e . code ( ) ) { throw e ; } } timeslept += sleepinterval ; thread . sleep ( sleepinterval ) ; } fail ( _str + min ) ; return min ; }	polls the solrcore stats using the specified client until the " starttime " time for collection is after the specified " min ".
@ override public paramsrequestcondition combine ( paramsrequestcondition other ) { set < paramexpression > set = new linkedhashset < > ( this . expressions ) ; set . addall ( other . expressions ) ; return new paramsrequestcondition ( set ) ; }	returns a new instance with the union of the param expressions from " this " and the " other " instance .
@ override public boolean equals ( object obj ) { if ( obj == this ) { return _bool ; } if ( ! ( obj instanceof timeseriescollection ) ) { return _bool ; } timeseriescollection that = ( timeseriescollection ) obj ; if ( this . xposition != that . xposition ) { return _bool ; } if ( this . domainispointsintime != that . domainispointsintime ) { return _bool ; } if ( ! objectutilities . equal ( this . data , that . data ) ) { return _bool ; } return _bool ; }	tests this time series collection for equality with another object .
private void parserules ( attributes attributes ) { startmode = getmodeattribute ( attributes , _str ) ; if ( startmode == null ) { startmode = lookupcreatemode ( implicit_mode_name ) ; md . currentmode = startmode ; startmode . notedefined ( null ) ; } startmode . noteused ( locator ) ; if ( attributesschema ) { mode wrapper = lookupcreatemode ( wrapper_mode_name ) ; actionset actions = new actionset ( ) ; actions . addnoresultaction ( new allowaction ( new modeusage ( startmode , startmode ) ) ) ; wrapper . bindelement ( namespacespecification . any_namespace , namespacespecification . default_wildcard , actions ) ; wrapper . notedefined ( null ) ; startmode = wrapper ; } defaultschematype = getschematype ( attributes ) ; }	parse the rules element . initializes the start mode the current mode the defaultschematype.
public void fill ( byte value ) { value &= _num ; arrays . fill ( data , ( byte ) ( value << _num | value ) ) ; }	fill the nibble array with the specified value .
private static void parse ( inputstream in , encoding encoding , contenthandler contenthandler ) throws ioexception , saxexception { try { xmlreader reader = new expatreader ( ) ; reader . setcontenthandler ( contenthandler ) ; inputsource source = new inputsource ( in ) ; source . setencoding ( encoding . expatname ) ; reader . parse ( source ) ; } catch ( ioexception e ) { throw new assertionerror ( e ) ; } }	parses xml from the given input stream and fires events on the given sax handler .
@ override public list < foo > findbyfield2 ( boolean field2 ) { return findbyfield2 ( field2 , queryutil . all_pos , queryutil . all_pos , null ) ; }	returns all the foos where field2 = & # 63 ; .
public void addtoassociated ( message asmessage ) { associatedmessages . add ( asmessage ) ; }	adding a message as associated to this message.
private static void parsepropertyassignments ( properties p , string [ ] assignments ) { for ( string assignment : assignments ) { int split = assignment . indexof ( _str ) ; string key = assignment . substring ( _num , split ) ; string value = assignment . substring ( split + _num ) ; p . put ( key , value ) ; } }	adds each element of ' assignments ' to ' p ' , treating each element as an assignment in the form " key = value " .
public static searchscope valueof ( final int intvalue ) { searchscope result = null ; if ( _num <= intvalue && intvalue < elements . length ) { result = elements [ intvalue ] ; } if ( result == null ) { result = new searchscope ( intvalue , _str + intvalue + _str , enum . unknown ) ; } return result ; }	returns the search scope having the specified integer value as defined in rfc 4511 section 4.
public static ipackagefragmentroot addclassfolder ( ijavaproject jproject , string containername , ipath sourceattachpath , ipath sourceattachroot ) throws coreexception { iproject project = jproject . getproject ( ) ; icontainer container = null ; if ( containername == null || containername . length ( ) == _num ) { container = project ; } else { ifolder folder = project . getfolder ( containername ) ; if ( ! folder . exists ( ) ) { coreutility . createfolder ( folder , _bool , _bool , null ) ; } container = folder ; } iclasspathentry cpe = javacore . newlibraryentry ( container . getfullpath ( ) , sourceattachpath , sourceattachroot ) ; addtoclasspath ( jproject , cpe ) ; return jproject . getpackagefragmentroot ( container ) ; }	creates and adds a class folder to the class path .
private void previouswindow ( calendar starttime ) { if ( isdaily ( ) ) { starttime . add ( calendar . day_of_month , - _num ) ; } else if ( isweekly ( ) ) { starttime . add ( calendar . week_of_month , - _num ) ; } else if ( ismonthly ( ) ) { int month = starttime . get ( calendar . month ) ; adjustdayofmonth ( starttime , month + - _num ) ; } }	changes to the previous window start time .
private < t > t [ ] copyelements ( t [ ] a ) { if ( head < tail ) { system . arraycopy ( elements , head , a , _num , size ( ) ) ; } else if ( head > tail ) { int headportionlen = elements . length - head ; system . arraycopy ( elements , head , a , _num , headportionlen ) ; system . arraycopy ( elements , _num , a , headportionlen , tail ) ; } return a ; }	copies the elements from our element array into the specified array , in order ( from first to last element in the deque ).
abstract void executeonhandlertask ( runnable task ) ;	wakes up a thread waiting for i / o events to execute the given task .
public instance calcpivot ( myidxlist list1 , myidxlist list2 , instances insts ) { int classidx = m_instances . classindex ( ) ; double [ ] attrvals = new double [ insts . numattributes ( ) ] ; instance temp ; for ( int i = _num ; i < list1 . length ( ) ; i ++ ) { temp = insts . instance ( list1 . get ( i ) . idx ) ; for ( int k = _num ; k < temp . numvalues ( ) ; k ++ ) { if ( temp . index ( k ) == classidx ) { continue ; } attrvals [ k ] += temp . valuesparse ( k ) ; } } for ( int j = _num ; j < list2 . length ( ) ; j ++ ) { temp = insts . instance ( list2 . get ( j ) . idx ) ; for ( int k = _num ; k < temp . numvalues ( ) ; k ++ ) { if ( temp . index ( k ) == classidx ) { continue ; } attrvals [ k ] += temp . valuesparse ( k ) ; } } for ( int j = _num , numinsts = list1 . length ( ) + list2 . length ( ) ; j < attrvals . length ; j ++ ) { attrvals [ j ] /= numinsts ; } temp = new denseinstance ( _num , attrvals ) ; return temp ; }	calculates the centroid pivot of a node based on the list of points that it contains ( tbe two lists of its children are provided ) .
default optional < list < t > > parseoptional ( byte [ ] parsemessage ) { return optional . ofnullable ( parse ( parsemessage ) ) ; }	take raw data and convert it to an optional list of messages .
public static void initializeforclientuse ( ) { embeddedutils . initializeforclientuse ( ) ; }	initialises opendj for client use , used by the cli tools.
public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str + _str + _str + _str + _str + _str + _str + _str , _str , _num , _str ) ) ; newvector . addall ( collections . list ( super . listoptions ( ) ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public void addall ( @ nonnull list < t > itemlist ) { synchronized ( lock ) { if ( items == null ) { items = new arraylist < > ( ) ; } items . addall ( itemlist ) ; } if ( notifyonchange ) { if ( items . size ( ) - itemlist . size ( ) != _num ) { notifyitemrangechanged ( items . size ( ) - itemlist . size ( ) , itemlist . size ( ) ) ; } else { notifydatasetchanged ( ) ; } } }	adds all the specified items to the list.
public void write ( int a ) throws ioexception { outs . write ( a ) ; position ++ ; }	write a single byte.
public void testinsert1 ( ) throws sqlexception { databasecreator . fillparenttable ( conn ) ; databasecreator . fillfkstricttable ( conn ) ; databasecreator . fillfkcascadetable ( conn ) ; statement . execute ( _str + databasecreator . fkstrict_table + _str ) ; statement . execute ( _str + databasecreator . fkcascade_table + _str ) ; }	insertfunctionalitytest # testinsert1 ( ) . attempts to insert row into table with integrity checking.
public boolean isstartswithmode ( ) { return startswithmode ; }	when enabled this makes the filter check that the string starts with rather than within the index.
public builder withthreads ( int threads ) { properties . setproperty ( nettyoptions . threads , string . valueof ( assert . argnot ( threads , threads <= _num , _str ) ) ) ; return this ; }	sets the number of netty event loop threads .
public void painttabbedpanetabareabackground ( synthcontext context , graphics g , int x , int y , int w , int h , int orientation ) { if ( orientation == jtabbedpane . left ) { affinetransform transform = new affinetransform ( ) ; transform . scale ( - _num , _num ) ; transform . rotate ( math . toradians ( _num ) ) ; paintbackground ( context , g , y , x , h , w , transform ) ; } else if ( orientation == jtabbedpane . right ) { affinetransform transform = new affinetransform ( ) ; transform . rotate ( math . toradians ( _num ) ) ; transform . translate ( _num , - ( x + w ) ) ; paintbackground ( context , g , y , _num , h , w , transform ) ; } else if ( orientation == jtabbedpane . bottom ) { affinetransform transform = new affinetransform ( ) ; transform . translate ( x , y ) ; paintbackground ( context , g , _num , _num , w , h , transform ) ; } else { paintbackground ( context , g , x , y , w , h , null ) ; } }	paints the background of the area behind the tabs of a tabbed pane.
@ override public void endcdata ( augmentations augs ) throws xniexception { try { if ( flexicalhandler != null ) { flexicalhandler . endcdata ( ) ; } } catch ( saxexception e ) { throw new xniexception ( e ) ; } }	the end of a cdata section .
public static medialocator createmedialocator ( string url ) { medialocator ml ; if ( url . indexof ( _str ) > _num && ( ml = new medialocator ( url ) ) != null ) return ml ; if ( url . startswith ( file . separator ) ) { if ( ( ml = new medialocator ( _str + url ) ) != null ) return ml ; } else { string file = _str + system . getproperty ( _str ) + file . separator + url ; if ( ( ml = new medialocator ( file ) ) != null ) return ml ; } return null ; }	create a media locator from the given location .
private static void invokeremoteclearandwait ( vm remotevm , vm thisvm ) { remotevm . invoke ( null ) ; try { clearlatch . await ( ) ; } catch ( interruptedexception e ) { fail ( _str ) ; } }	this method clears the region and notifies the other member when complete.
public void key ( string skey ) throws sqlite . exception { synchronized ( this ) { byte ekey [ ] = null ; if ( skey != null && skey . length ( ) > _num ) { ekey = new byte [ skey . length ( ) ] ; for ( int i = _num ; i < skey . length ( ) ; i ++ ) { char c = skey . charat ( i ) ; ekey [ i ] = ( byte ) ( ( c & _num ) ^ ( c > > _num ) ) ; } } _key ( ekey ) ; } }	specify key for encrypted database.
public void testsharedtestdata ( ) throws exception { assertequals ( testsqldate , date . valueof ( testlocaldate ) ) ; assertequals ( testsqltime , time . valueof ( testlocaltime ) ) ; assertequals ( testsqltimestamp , timestamp . valueof ( testlocaldatetime ) ) ; assertequals ( testlocaldate , testsqldate . tolocaldate ( ) ) ; assertequals ( testlocaltime , testsqltime . tolocaltime ( ) ) ; assertequals ( testlocaldatetime , testsqltimestamp . tolocaldatetime ( ) ) ; }	test shared test data validity .
public void characters ( char ch [ ] , int start , int length ) { if ( titlepending ) { title . append ( ch , start , length ) ; } else if ( descpending ) { desc . append ( ch , start , length ) ; } }	the contents of an xml elt.
private void closeinjectorresource ( shardid shardid , injector shardinjector , class < ? extends closeable > ... toclose ) { for ( class < ? extends closeable > closeable : toclose ) { if ( closeinjectoroptionalresource ( shardid , shardinjector , closeable ) == _bool ) { logger . warn ( _str , shardid , closeable . getsimplename ( ) ) ; } } }	this method gets an instance for each of the given classes passed and calls # close ( ) on the returned instance . note : this method swallows all exceptions thrown from the close method of the injector and logs them as debug log.
public final void incrementidcounterto ( int id ) { int diff = id - midcounter . get ( ) ; if ( diff < _num ) return ; midcounter . addandget ( diff ) ; updatesharedpreference ( ) ; }	ensures the counter is at least as high as the specified value.
private static int clearbrandingresourcemapcache ( contentresolver cr , long providerid ) { stringbuilder where = new stringbuilder ( ) ; where . append ( imps . brandingresourcemapcache . provider_id ) ; where . append ( _str ) ; where . append ( providerid ) ; return cr . delete ( imps . brandingresourcemapcache . content_uri , where . tostring ( ) , null ) ; }	clear the branding resource map cache .
public byte [ ] tobytearray ( ) { final int outlen = nonce_ . length + ( long . size / byte . size ) ; final bytebuffer out = bytebuffer . allocate ( outlen ) ; out . put ( nonce_ ) ; out . putlong ( contentlength_ ) ; return out . array ( ) ; }	serialize the header into a byte array .
public void addinterface ( cp ifc ) { addcpitem ( ifc ) ; interfaces . addelement ( ifc ) ; }	add this cp to the list of interfaces supposedly implemented by this class.
public builder addconstraint ( @ jobconstraint int constraint ) { int [ ] newconstraints = new int [ mconstraints == null ? _num : mconstraints . length + _num ] ; if ( mconstraints != null && mconstraints . length != _num ) { system . arraycopy ( mconstraints , _num , newconstraints , _num , mconstraints . length ) ; } newconstraints [ newconstraints . length - _num ] = constraint ; mconstraints = newconstraints ; return this ; }	adds the provided constraint to the current list of runtime constraints .
void cleanupparameters ( string relaystate ) { if ( debug . messageenabled ( ) ) { debug . message ( _str + _str + relaystate ) ; } relaystatemap . remove ( relaystate ) ; usersessionmap . remove ( relaystate ) ; useridmap . remove ( relaystate ) ; issoapinitiatedmap . remove ( relaystate ) ; issoapinitiatedmap . remove ( relaystate ) ; isidpinitiatedmap . remove ( relaystate ) ; origprotocolmap . remove ( relaystate ) ; protocollistmap . remove ( relaystate ) ; realmmap . remove ( relaystate ) ; idpentityidmap . remove ( relaystate ) ; spentityidmap . remove ( relaystate ) ; slorequestxmlmap . remove ( relaystate ) ; sloresponsexmlmap . remove ( relaystate ) ; currentstatusmap . remove ( relaystate ) ; }	removes saved parameters from internal cache map.
private boolean extraentity ( string outputstring , int chartomap ) { boolean extra = _bool ; if ( chartomap < ascii_max ) { switch ( chartomap ) { case _str : if ( ! outputstring . equals ( _str ) ) extra = _bool ; break ; case _str : if ( ! outputstring . equals ( _str ) ) extra = _bool ; break ; case _str : if ( ! outputstring . equals ( _str ) ) extra = _bool ; break ; case _str : if ( ! outputstring . equals ( _str ) ) extra = _bool ; break ; default : extra = _bool ; } } return extra ; }	this method returns true if there are some non - standard mappings to entities other than quot , amp , lt , gt , and its only purpose is for performance .
protected void drawpoint ( graphics2d g , pointstyle pointstyle , double x , double y , color color , color bordercolor ) { shape pointshape = pointstyle . createshape ( x , y ) ; g . setcolor ( color ) ; g . fill ( pointshape ) ; g . setcolor ( bordercolor ) ; g . draw ( pointshape ) ; }	this helper method can be used to draw a point in the given graphics object .
int retrytime ( ) { return retrytime . decrementandget ( ) ; }	get retry time , the retry time will decrease automatically after invoking this method .
public datepickercombo ( final composite parent , final int style ) { this ( parent , style , dateformat . getdatetimeinstance ( ) ) ; }	creates a new datepickercombo , using the default locale and default dateformat to format dates that are selected using the popup datepicker control .
public void testpowpositivenum ( ) { byte abytes [ ] = { _num , - _num , _num , _num , _num , _num , _num , - _num , - _num , _num } ; int asign = _num ; int exp = _num ; byte rbytes [ ] = { _num , _num , _num , _num , _num , - _num , _num , _num , - _num , _num , - _num , - _num , _num , - _num , _num , - _num , _num , - _num , - _num , _num , - _num , _num , - _num , _num , - _num , - _num , - _num , - _num , _num , - _num , - _num , - _num , _num , _num , - _num , _num , _num , _num , _num , - _num , _num , - _num , _num , - _num , _num , - _num , - _num , _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . pow ( exp ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	exponentiation of a positive number .
protected void drawmarkhilighted ( graphics2d g2 , float x , float y ) { rectangle2d bounds = mark . getbounds2d ( ) ; float w = ( float ) bounds . getwidth ( ) ; float h = ( float ) bounds . getheight ( ) ; x = x - ( w / _num ) ; y = y - ( h / _num ) ; g2 . translate ( x , y ) ; if ( hilightedmarkfillpaint != null ) { g2 . setpaint ( hilightedmarkfillpaint ) ; g2 . fill ( mark ) ; } g2 . setpaint ( hilightedmarkpaint ) ; g2 . setstroke ( hilightedmarkstroke ) ; g2 . draw ( mark ) ; g2 . translate ( - x , - y ) ; rectangle2d rect = new rectangle2d . float ( x , y , w , h ) ; markbounds . add ( rect ) ; }	draw a mark transforming co - ordinates to each axis.
public static string trimtrailingwhitespace ( string str ) { if ( ! haslength ( str ) ) { return str ; } stringbuilder sb = new stringbuilder ( str ) ; while ( sb . length ( ) > _num && character . iswhitespace ( sb . charat ( sb . length ( ) - _num ) ) ) { sb . deletecharat ( sb . length ( ) - _num ) ; } return sb . tostring ( ) ; }	trim trailing whitespace from the given string .
private static mksticketresponse checkgetmksticketresponse ( mksticketresponse mksticketresponse ) throws rpcexception { logger . info ( _str , mksticketresponse ) ; switch ( mksticketresponse . getresult ( ) ) { case ok : break ; case system_error : throw new systemerrorexception ( mksticketresponse . geterror ( ) ) ; case vm_not_found : throw new vmnotfoundexception ( mksticketresponse . geterror ( ) ) ; case invalid_vm_power_state : throw new invalidvmpowerstateexception ( mksticketresponse . geterror ( ) ) ; default : throw new rpcexception ( string . format ( _str , mksticketresponse . getresult ( ) ) ) ; } return mksticketresponse ; }	this method validates a mksticketresponse object , raising an exception if the response reflects an operation failure .
@ notnull default b append ( double d , int decimalplaces ) throws bufferoverflowexception { if ( decimalplaces < _num ) { double d2 = d * maths . tens ( decimalplaces ) ; if ( d2 <= long . max_value && d2 >= long . min_value ) { return appenddecimal ( math . round ( d2 ) , decimalplaces ) ; } } return append ( d ) ; }	append a double in decimal notation to a specific number of decimal places.
public completablefuture < t > completeasync ( supplier < ? extends t > supplier , executor executor ) { if ( supplier == null || executor == null ) throw new nullpointerexception ( ) ; executor . execute ( new asyncsupply < t > ( this , supplier ) ) ; return this ; }	completes this completablefuture with the result of the given supplier function invoked from an asynchronous task using the given executor .
private moviesubtitlechoosermodel ( ) { name = bundle . getstring ( _str ) ; }	create the empty search result .
public static java . sql . timestamp nowtimestamp ( ) { return gettimestamp ( system . currenttimemillis ( ) ) ; }	return a timestamp for right now.
private void revokeencryptpolicy ( org . wso2 . emm . agent . beans . operation operation ) { boolean encryptstatus = ( devicepolicymanager . getstorageencryptionstatus ( ) != devicepolicymanager . encryption_status_unsupported && ( devicepolicymanager . getstorageencryptionstatus ( ) == devicepolicymanager . encryption_status_active || devicepolicymanager . getstorageencryptionstatus ( ) == devicepolicymanager . encryption_status_activating ) ) ; if ( operation . isenabled ( ) && encryptstatus ) { devicepolicymanager . setstorageencryption ( deviceadmin , _bool ) ; } }	revokes device encrypt policy on the device ( device external storage encryption ) .
public jsonbuffer closehash ( ) { if ( stack . empty ( ) || stack . peek ( ) != operand . hash ) { throw new jsonexception ( _str ) ; } removeseparator ( ) ; buffer . append ( _str ) ; stack . pop ( ) ; addseparator ( ) ; return this ; }	close an hash context .
private static byte [ ] generateseed ( ) { try { bytearrayoutputstream seedbuffer = new bytearrayoutputstream ( ) ; dataoutputstream seedbufferout = new dataoutputstream ( seedbuffer ) ; seedbufferout . writelong ( system . currenttimemillis ( ) ) ; seedbufferout . writelong ( system . nanotime ( ) ) ; seedbufferout . write ( build_fingerprint_and_device_serial ) ; seedbufferout . close ( ) ; return seedbuffer . tobytearray ( ) ; } catch ( ioexception e ) { throw new securityexception ( _str , e ) ; } }	generates a device - and invocation - specific seed to be mixed into the linux prng .
private void init ( snmpmib mymib ) { if ( debug == null ) { final key < debug > key = key . get ( debug . class , names . named ( coretokenconstants . cts_monitor_debug ) ) ; debug = injectorholder . getinstance ( key ) ; } final list < operationentry > operationentries = new arraylist < operationentry > ( ) ; final list < tokenentry > tokenentries = new arraylist < tokenentry > ( ) ; for ( enum e : cruditems ) { final operationentry entry = new operationentry ( mymib ) ; entry . operationtype = e . name ( ) ; entry . operationtableindex = ( long ) e . ordinal ( ) + _num ; operationentries . add ( entry ) ; } for ( enum e : tokenitems ) { final tokenentry entry = new tokenentry ( mymib ) ; entry . tokentype = e . name ( ) ; entry . tokentableindex = ( long ) e . ordinal ( ) + _num ; tokenentries . add ( entry ) ; } try { for ( operationentry ce : operationentries ) { operationtable . addentry ( ce ) ; } for ( tokenentry te : tokenentries ) { tokentable . addentry ( te ) ; } createcrudoperationspertokentypetable ( mymib , ctscrudoperationspertokentypetable , operationentries , tokenentries ) ; createcrudoperationstable ( mymib , ctscrudoperationstable , operationentries ) ; createtokenoperationstable ( mymib , ctstokenoperationstable , tokenentries ) ; } catch ( snmpstatusexception e ) { if ( debug . messageenabled ( ) ) { debug . error ( _str , e ) ; } } }	performs the majority of the work setting up the tables such that they can be queried as pass - throughs to the data structures they act as queryable endpoints for .
@ override public void disconnectionnotification ( string eventname , object source ) { m_listenees . remove ( source ) ; if ( m_listenees . size ( ) == _num ) { m_listeneetypes . clear ( ) ; } }	notify this object that it has been deregistered as a listener with a source for named event.
@ override public todoublefunction < stream < tuple2 < f , double > > > dist ( stream < tuple2 < f , double > > features1 ) { object2doublemap < f > auxmap = new object2doubleopenhashmap < > ( ) ; auxmap . defaultreturnvalue ( _num ) ; doubleadder norm1 = new doubleadder ( ) ; features1 . foreach ( null ) ; if ( norm1 . doublevalue ( ) == _num ) { return null ; } return null ; }	returns a function that returns the feature - based similarity to the features of an item .
public loadmetadatadetails [ ] readloadmetadata ( string tablefolderpath ) { gson gsonobjecttoread = new gson ( ) ; datainputstream datainputstream = null ; bufferedreader buffreader = null ; inputstreamreader instream = null ; string metadatafilename = tablefolderpath + carboncommonconstants . file_separator + carboncommonconstants . loadmetadata_filename ; loadmetadatadetails [ ] listofloadfolderdetailsarray ; atomicfileoperations fileoperation = new atomicfileoperationsimpl ( metadatafilename , filefactory . getfiletype ( metadatafilename ) ) ; try { if ( ! filefactory . isfileexist ( metadatafilename , filefactory . getfiletype ( metadatafilename ) ) ) { return new loadmetadatadetails [ _num ] ; } datainputstream = fileoperation . openforread ( ) ; instream = new inputstreamreader ( datainputstream , charset . forname ( carboncommonconstants . default_charset ) ) ; buffreader = new bufferedreader ( instream ) ; listofloadfolderdetailsarray = gsonobjecttoread . fromjson ( buffreader , loadmetadatadetails [ ] . class ) ; } catch ( ioexception e ) { return new loadmetadatadetails [ _num ] ; } finally { closestreams ( buffreader , instream , datainputstream ) ; } return listofloadfolderdetailsarray ; }	this method reads the load metadata file.
public string toinnerhtml ( node node , appendable appendable ) { nodevisitor renderer = createrenderer ( appendable ) ; node . visitchildren ( renderer ) ; return appendable . tostring ( ) ; }	renders node children to appendable .
private void updatestorageviewinfo ( vplexstorageviewinfo storageviewinfo ) { vplexapidiscoverymanager discoverymgr = _vplexapiclient . getdiscoverymanager ( ) ; discoverymgr . updatestorageviewinfo ( storageviewinfo ) ; }	updates a vplexstorageviewinfo object with detailed attributes .
static list < string > decodeall ( collection < string > eventkeys ) { list < string > eventids = lists . newarraylist ( ) ; for ( string eventkey : eventkeys ) { decodeto ( eventkey , eventids ) ; } return eventids ; }	split databus event keys into eventstore event ids .
public void testzeroone ( ) { biginteger anumber = biginteger . zero ; biginteger bnumber = biginteger . one ; biginteger result = anumber . and ( bnumber ) ; asserttrue ( result . equals ( biginteger . zero ) ) ; assertequals ( _str , _num , result . signum ( ) ) ; }	and for zero and one.
public byte [ ] tobytearray ( string ascii ) { if ( ascii == null ) { return empty_byte_array ; } return fromascii ( ascii . tochararray ( ) ) ; }	decodes a string where each char of the string represents an ascii ' 0 ' or ' 1 ' .
public static boolean [ ] copyofrange ( boolean [ ] original , int start , int end ) { if ( start <= end ) { if ( original . length >= start && _num <= start ) { int length = end - start ; int copylength = math . min ( length , original . length - start ) ; boolean [ ] copy = new boolean [ length ] ; system . arraycopy ( original , start , copy , _num , copylength ) ; return copy ; } throw new arrayindexoutofboundsexception ( ) ; } throw new illegalargumentexception ( ) ; }	copies elements in original array to a new array , from index start ( inclusive ) to end ( exclusive ).
private static map < direction , sprite [ ] > splittiles ( spritestore st , sprite orig ) { int twidth = num_attack_frames * tile_size ; int theight = _num * tile_size ; map < direction , sprite [ ] > map = new enummap < direction , sprite [ ] > ( direction . class ) ; int y = _num ; map . put ( direction . up , st . gettiles ( orig , _num , y , num_attack_frames , twidth , theight ) ) ; y += theight ; map . put ( direction . right , st . gettiles ( orig , _num , y , num_attack_frames , twidth , theight ) ) ; y += theight ; map . put ( direction . down , st . gettiles ( orig , _num , y , num_attack_frames , twidth , theight ) ) ; y += theight ; map . put ( direction . left , st . gettiles ( orig , _num , y , num_attack_frames , twidth , theight ) ) ; return map ; }	split a sprite to a set of attack images .
void incrementschema ( string schemaname ) { if ( schemaname != null ) { integer count = dbmap . get ( schemaname ) ; if ( count == null ) dbmap . put ( schemaname , _num ) ; else dbmap . put ( schemaname , count . intvalue ( ) + _num ) ; } lastdb = schemaname ; }	add a schema name , thereby incrementing counts .
private string buildeventdata ( ) throws jaxbexception { if ( _eventparameters != null ) { try { jaxbcontext jaxbcontext = jaxbcontext . newinstance ( eventparameters . class ) ; marshaller marshaller = jaxbcontext . createmarshaller ( ) ; marshaller . setproperty ( marshaller . jaxb_formatted_output , _bool ) ; writer outwriter = new stringwriter ( ) ; streamresult result = new streamresult ( outwriter ) ; marshaller . marshal ( _eventparameters , result ) ; return outwriter . tostring ( ) ; } catch ( jaxbexception e ) { _log . error ( _str + e . getmessage ( ) ) ; throw e ; } } else { return null ; } }	build events data as marshalled string of xml data .
public boolean isprojected ( ) { return projected ; }	tests whether the projection references have been configured .
private boolean normalizeattrvalue ( xmlattributes attributes , int index ) { boolean leadingspace = _bool ; boolean spacestart = _bool ; boolean readingnonspace = _bool ; int count = _num ; int eaten = _num ; string attrvalue = attributes . getvalue ( index ) ; char [ ] attvalue = new char [ attrvalue . length ( ) ] ; fbuffer . setlength ( _num ) ; attrvalue . getchars ( _num , attrvalue . length ( ) , attvalue , _num ) ; for ( int i = _num ; i < attvalue . length ; i ++ ) { if ( attvalue [ i ] == _str ) { if ( readingnonspace ) { spacestart = _bool ; readingnonspace = _bool ; } if ( spacestart && ! leadingspace ) { spacestart = _bool ; fbuffer . append ( attvalue [ i ] ) ; count ++ ; } else { if ( leadingspace || ! spacestart ) { eaten ++ ; } } } else { readingnonspace = _bool ; spacestart = _bool ; leadingspace = _bool ; fbuffer . append ( attvalue [ i ] ) ; count ++ ; } } if ( count > _num && fbuffer . charat ( count - _num ) == _str ) { fbuffer . setlength ( count - _num ) ; } string newvalue = fbuffer . tostring ( ) ; attributes . setvalue ( index , newvalue ) ; return ! attrvalue . equals ( newvalue ) ; }	normalize the attribute value of a non cdata attributes collapsing sequences of space characters ( x20 ).
private shape decodemarkinterior ( int width , int height ) { double left = width / _num - _num ; double top = height / _num - _num ; path . reset ( ) ; path . moveto ( left + _num , top + _num ) ; path . lineto ( left + _num , top + _num ) ; path . lineto ( left + _num , top + _num ) ; path . closepath ( ) ; return path ; }	create the mark interior shape .
public monotonesolver ( final ilatticegraph < graphnode > graph , final lattice lattice , final istatevector < graphnode , latticeelement > startvector , final itransformationprovider < graphnode , latticeelement > transformationprovider , final igraphwalker < graphnode , objecttype > walker ) { if ( graph == null ) { throw new illegalargumentexception ( _str ) ; } if ( lattice == null ) { throw new illegalargumentexception ( _str ) ; } if ( startvector == null ) { throw new illegalargumentexception ( _str ) ; } if ( transformationprovider == null ) { throw new illegalargumentexception ( _str ) ; } final list < graphnode > nodes = graph . getnodes ( ) ; if ( nodes . size ( ) != startvector . size ( ) ) { throw new illegalargumentexception ( string . format ( _str , startvector . size ( ) , nodes . size ( ) ) ) ; } for ( final graphnode node : nodes ) { if ( ! startvector . hasstate ( node ) ) { throw new illegalargumentexception ( _str + node + _str ) ; } } this . graph = graph ; this . lattice = lattice ; this . state = startvector ; this . transformationlist = transformationprovider ; this . walker = walker ; }	creates a new instance of a monotone solver .
private stat prepareportstatinfo ( string nativeid , uri resourceid , long iops , long timesample ) { stat ipportstat = new stat ( ) ; ipportstat . setservicetype ( constants . _file ) ; ipportstat . settimecollected ( timesample ) ; ipportstat . setresourceid ( resourceid ) ; ipportstat . setnativeguid ( nativeid ) ; ipportstat . settotalios ( iops ) ; return ipportstat ; }	prepare the port stat information.
public void testinsert3 ( ) throws sqlexception { databasecreator . fillparenttable ( conn ) ; databasecreator . fillfkstricttable ( conn ) ; statement . execute ( _str + databasecreator . test_table5 + _str + _str + databasecreator . fkstrict_table + _str ) ; resultset r = statement . executequery ( _str + databasecreator . test_table5 ) ; r . next ( ) ; assertequals ( _str , _num , r . getint ( _num ) ) ; r . close ( ) ; }	insertfunctionalitytest # testinsert3 ( ).
public int compareto ( appversion other ) { int result = major - other . major ; if ( result == _num ) { result = minor - other . minor ; } if ( result == _num ) { result = patch - other . patch ; } if ( result == _num && ( milestone > - _num || other . milestone > - _num ) ) { if ( milestone > - _num ) { if ( other . milestone == - _num ) { result = - _num ; } else { result = milestone - other . milestone ; } } else { if ( other . milestone > - _num ) { result = _num ; } } } if ( result == _num && ! objectutil . nullequals ( modifier , other . modifier ) ) { if ( modifier == null ) { result = _num ; } else if ( other . modifier == null ) { result = - _num ; } else { result = modifier . comparetoignorecase ( other . modifier ) ; } } return result ; }	compares two version numbers according to their major , minor , patch and milestone version numbers , ordering from oldest to newest version.
public streamconsumer ( inputstream stream , string charset ) { in = new bufferedinputstream ( stream ) ; this . charset = charset ; thread . start ( ) ; }	creates a streamconsumer for consuming the data from the input stream .
public mediasize ( int x , int y , int units ) { super ( x , y , units ) ; if ( x > y ) { throw new illegalargumentexception ( _str ) ; } sizevector . add ( this ) ; }	construct a new media size attribute from the given integer values .
private peer constructpeerpojo ( final peerdata peerdata ) throws peerexception { preconditions . checknotnull ( peerdata , _str ) ; try { peerinfo peerinfo = fromjson ( peerdata . getinfo ( ) , peerinfo . class ) ; if ( localpeerid . equals ( peerdata . getid ( ) ) ) { localpeer . setpeerinfo ( peerinfo ) ; return localpeer ; } remotepeerimpl remotepeer = new remotepeerimpl ( localpeerid , securitymanager , peerinfo , messenger , commandresponselistener , messageresponselistener , provider , this ) ; relationinfometa relationinfometa = new relationinfometa ( ) ; map < string , string > traits = relationinfometa . getrelationtraits ( ) ; traits . put ( _str , _str ) ; traits . put ( _str , _str ) ; traits . put ( _str , _str ) ; user peerowner = identitymanager . getuserbykeyid ( identitymanager . getpeerownerid ( ) ) ; relationmeta relationmeta = new relationmeta ( peerowner , localpeer , remotepeer , localpeer . getkeyid ( ) ) ; relation relation = relationmanager . buildrelation ( relationinfometa , relationmeta ) ; relation . setrelationstatus ( relationstatus . verified ) ; relationmanager . saverelation ( relation ) ; return remotepeer ; } catch ( exception e ) { throw new peerexception ( _str , e ) ; } }	creates the peer instance by provided peer data.
public void loadworkspacecontents ( string xml ) throws blocklyparserexception { loadworkspacecontents ( new bytearrayinputstream ( xml . getbytes ( ) ) ) ; }	reads the workspace in from a xml stream.
public boolean load ( string filelocation , int type ) { if ( mhasloaded ) { return _bool ; } string shadercode ; try { shadercode = shaderutils . getstringfromfileinassets ( mcontext , filelocation , _bool ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; miscompiled = _bool ; return _bool ; } mhasloaded = _bool ; mshaderid = gles20 . glcreateshader ( type ) ; if ( mshaderid == _num ) { string msg = ( type == gles20 . gl_vertex_shader ? _str : _str ) ; log . e ( tag , _str + msg ) ; return _bool ; } gles20 . glshadersource ( mshaderid , shadercode ) ; gles20 . glcompileshader ( mshaderid ) ; int [ ] compilestatus = new int [ _num ] ; gles20 . glgetshaderiv ( mshaderid , gles20 . gl_compile_status , compilestatus , _num ) ; miscompiled = ( compilestatus [ _num ] == gles20 . gl_true ) ; if ( ! miscompiled ) { string compileerror = gles20 . glgetshaderinfolog ( mshaderid ) ; log . e ( tag , compileerror ) ; gles20 . gldeleteshader ( mshaderid ) ; } return miscompiled && mhasloaded ; }	load the shaders source file into a shader.
public void addchild ( pdflayer childlayer ) { if ( childlayer . parent != null ) throw new illegalargumentexception ( _str ) ; childlayer . parent = this ; if ( children == null ) children = new arraylist < > ( ) ; children . add ( childlayer ) ; }	adds a child layer.
protected void moverandomly ( ompoint point , double factor , projection proj ) { double hor = math . random ( ) - _num ; double vert = math . random ( ) - _num ; point2d mappoint = proj . forward ( point . getlat ( ) , point . getlon ( ) ) ; mappoint . setlocation ( mappoint . getx ( ) + ( hor * factor ) , mappoint . gety ( ) + ( vert * factor ) ) ; point2d llp = proj . inverse ( mappoint ) ; point . setlat ( llp . gety ( ) ) ; point . setlon ( llp . getx ( ) ) ; }	simple method to move an ompoint around randomly .
private void initializecontext ( ) throws ioexception { string workingdir = system . getproperty ( _str ) ; file dataset = fileutils . getfile ( workingdir + _str ) ; file log4jfile = fileutils . getfile ( workingdir + _str ) ; file datasetfolder = new file ( destinationfolder + _str ) ; file log4jfolder = new file ( destinationfolder + _str ) ; dataset . mkdirs ( ) ; log4jfile . mkdirs ( ) ; fileutils . copyfiletodirectory ( dataset , datasetfolder ) ; fileutils . copyfiletodirectory ( log4jfile , log4jfolder ) ; }	this method sets the working directory and copies the static context files such as log4j or xmldataset ( needed by hsqldb ) to the appropriate path .
public static int parseint ( fxgnode node , string value , string name ) { try { return integer . parseint ( value ) ; } catch ( numberformatexception e ) { throw new fxgexception ( node . getstartline ( ) , node . getstartcolumn ( ) , _str , name , value ) ; } }	convert an fxg string value to a integer .
public void close ( ) throws ioexception { articleidxwriter . close ( ) ; chronoidxwriter . close ( ) ; revisionidxwriter . close ( ) ; }	closes the file or the database connection .
private final byte [ ] zeroextend ( byte [ ] datatopad ) { assert null != datatopad ; final int targetlength = _num ; if ( targetlength <= datatopad . length ) return datatopad ; byte padded [ ] = new byte [ targetlength ] ; for ( int i = _num ; i < datatopad . length ; i ++ ) padded [ i ] = datatopad [ i ] ; for ( int i = datatopad . length ; i < padded . length ; i ++ ) padded [ i ] = ( byte ) _num ; return padded ; }	if the parameter is shorter than 4 bytes , then create and return a new 4 byte array with the input array ' s bytes followed by zero bytes.
private static boolean iscertificateentry ( string alias ) throws keystoreexception { return skeystore . iscertificateentry ( alias ) ; }	check if a certificate is in the keystore.
public void test_unwrap_06 ( ) { string host = _str ; int port = _num ; bytebuffer [ ] bba = { bytebuffer . allocate ( _num ) , bytebuffer . allocate ( _num ) , bytebuffer . allocate ( _num ) } ; bytebuffer bb = bytebuffer . allocate ( _num ) ; sslengine sse = getengine ( host , port ) ; sse . setuseclientmode ( _bool ) ; try { sslengineresult res = sse . unwrap ( bb , bba , _num , bba . length ) ; assertequals ( _num , res . bytesconsumed ( ) ) ; assertequals ( _num , res . bytesproduced ( ) ) ; } catch ( exception ex ) { fail ( _str + ex ) ; } }	javax . net . ssl . sslengine # unwrap ( bytebuffer src , bytebuffer [ ] dsts , int offset , int length ).
public static window windowforwordinposition ( int windowsize , int wordpos , list < string > sentence ) { list < string > window = new arraylist < > ( ) ; list < string > onlytokens = new arraylist < > ( ) ; int contextsize = ( int ) math . floor ( ( windowsize - _num ) / _num ) ; for ( int i = wordpos - contextsize ; i <= wordpos + contextsize ; i ++ ) { if ( i < _num ) window . add ( _str ) ; else if ( i >= sentence . size ( ) ) window . add ( _str ) ; else { onlytokens . add ( sentence . get ( i ) ) ; window . add ( sentence . get ( i ) ) ; } } string wholesentence = stringutils . join ( sentence ) ; string window2 = stringutils . join ( onlytokens ) ; int begin = wholesentence . indexof ( window2 ) ; int end = begin + window2 . length ( ) ; return new window ( window , begin , end ) ; }	creates a sliding window from text.
public void enable ( ) { list < entry > entries = removeintersectedentries ( tree . getselectedentries ( ) ) ; boolean enable = _bool ; for ( entry entry : entries ) { if ( entry == null ) { enable = _bool ; break ; } if ( ! requiredselectiontype . isinstance ( entry ) ) { enable = _bool ; break ; } if ( needswriteaccess && entry . isreadonly ( ) ) { enable = _bool ; break ; } } if ( entries . isempty ( ) ) { enable = _bool ; } setenabled ( enable ) ; }	enables action , if every entry exists and can be written if needed .
public string tostring ( ) { stringbuffer buffer = new stringbuffer ( ) ; if ( getname ( ) != null ) { buffer . append ( getname ( ) ) ; } buffer . append ( _str ) ; if ( getenclosingtypename ( ) != null ) { buffer . append ( getenclosingtypename ( ) ) ; } buffer . append ( _str ) ; if ( getsourcename ( ) != null ) { buffer . append ( getsourcename ( ) ) ; } return buffer . tostring ( ) ; }	answer the string representation of the receiver.
protected void mark ( ) throws compilationfailedexception { applytosourceunits ( mark ) ; }	updates the phase marker on all sources .
private boolean labeltokeeprec ( node v , set < integer > ids , nodeset keep ) { boolean hasbelow = _bool ; int id = ( integer ) v . getinfo ( ) ; if ( ids . size ( ) == _num || ids . contains ( id ) ) hasbelow = _bool ; for ( edge e = v . getfirstoutedge ( ) ; e != null ; e = v . getnextoutedge ( e ) ) { node w = e . gettarget ( ) ; if ( labeltokeeprec ( w , ids , keep ) ) hasbelow = _bool ; } if ( hasbelow ) keep . add ( v ) ; return hasbelow ; }	label all nodes in tree that we must keep in induced tree.
public void putexternalproperty ( ssotoken clienttoken , string key , string value ) throws sessionexception { try { sessionutilswrapper . checkpermissiontosetproperty ( clienttoken , key , value ) ; } catch ( sessionexception se ) { firesessionevent ( sessioneventtype . protected_property ) ; sessionlogging . logevent ( tosessioninfo ( ) , sessioneventtype . protected_property ) ; throw se ; } internalputproperty ( key , value ) ; debug . message ( _str ) ; }	sets the key - value pair in the internalsession property table if it is not protected.
void addedge ( methodparameter in , methodparameter out ) { set < methodparameter > outs = graph . get ( in ) ; if ( outs == null ) { outs = new hashset < > ( ) ; graph . put ( in , outs ) ; } outs . add ( out ) ; }	adds edge to the string passthru graph.
public static int [ ] randomnumber ( int n ) { int [ ] num = new int [ n ] ; for ( int i = _num ; i < num . length ; i ++ ) { num [ i ] = ( int ) ( rgen . nextdouble ( ) * _num ) ; } return num ; }	generate random number of size n .
public boolean isdevicetv ( context context ) { if ( build . version . sdk_int >= build . version_codes . lollipop ) { uimodemanager uimanager = ( uimodemanager ) context . getsystemservice ( context . ui_mode_service ) ; return uimanager != null && uimanager . getcurrentmodetype ( ) == configuration . ui_mode_type_television ; } return _bool ; }	determines if the current device is a tv .
protected void rcpttoauthors ( final recipienttype rt ) { for ( final account . id id : authors ) { add ( rt , id ) ; } }	to or cc all vested parties ( change owner , patch set uploader , author ) .
public object createshapedata ( shape shape ) { return null ; }	creates a data object to be associated with a newly created shape .
private protectionset createprotectionset ( recoverpointvolumeingestioncontext volumecontext ) { unmanagedprotectionset umpset = volumecontext . getunmanagedprotectionset ( ) ; protectionset pset = volumeingestionutil . findorcreateprotectionset ( volumecontext , volumecontext . getunmanagedvolume ( ) , umpset , _dbclient ) ; volumecontext . setmanagedprotectionset ( pset ) ; return pset ; }	create the managed protection set associated with the ingested rp volumes.
public synchronized void dispose ( ) { if ( isdisposed ) { return ; } isdisposed = _bool ; arraylist < pooledconnection > list = recycledconnections ; for ( int i = _num , size = list . size ( ) ; i < size ; i ++ ) { closeconnection ( list . get ( i ) ) ; } }	closes all unused pooled connections.
public void writeto ( byte [ ] bytes , int offset ) throws ioexception { flush ( ) ; final long end = file . length ; long pos = _num ; int buffer = _num ; int bytesupto = offset ; while ( pos < end ) { int length = buffer_size ; long nextpos = pos + length ; if ( nextpos > end ) { length = ( int ) ( end - pos ) ; } system . arraycopy ( file . getbuffer ( buffer ++ ) , _num , bytes , bytesupto , length ) ; bytesupto += length ; pos = nextpos ; } }	copy the current contents of this buffer to output byte array.
protected int calcncluster ( ) { return _num ; }	calculate the clustering of the hits.
public static void validateservicename ( string servicecode , string servicename ) { if ( ! servicename . startswith ( servicecode ) ) { throw new codedexception ( x_inconsistent_headers , _str + _str ) ; } }	checks that the service name matches in header and body .
protected static void initcmykcolorspace ( ) { if ( iccprofileforrgb == null ) { rgbmodel = new componentcolormodel ( rgbcs , new int [ ] { _num , _num , _num } , _bool , _bool , colormodel . opaque , databuffer . type_byte ) ; } else { final int compcount = rgbcs . getnumcomponents ( ) ; final int [ ] values = new int [ compcount ] ; for ( int i = _num ; i < compcount ; i ++ ) { values [ i ] = _num ; } rgbmodel = new componentcolormodel ( rgbcs , values , _bool , _bool , colormodel . opaque , databuffer . type_byte ) ; } final fastcolorspacecmyk cmykcs = new fastcolorspacecmyk ( ) ; cstorgb = new colorconvertop ( cmykcs , rgbcs , colorspaces . hints ) ; }	initialise all the colorspaces when first needed.
private void addnotificationcategoryseparator ( jpanel panel ) { jseparator jsep = new jseparator ( swingconstants . horizontal ) ; jsep . setmaximumsize ( new dimension ( short . max_value , _num ) ) ; panel . add ( jsep ) ; }	adds a new horizontal separator to the notifications list .
public void cleardraggedoperators ( ) { this . draggedoperators = collections . unmodifiablelist ( collections . < operator > emptylist ( ) ) ; }	clears the dragged operators .
public fakeclock resettime ( ) { fakenowms . set ( basetimems ) ; return this ; }	reset the given clock back to the base time with which the fakeclock was initially constructed .
public gserparser ( charsequence value ) { reject . checknotnull ( value ) ; this . gservalue = value . tostring ( ) ; this . pos = _num ; this . length = value . length ( ) ; }	creates a new gser parser .
public slice ( double start , double end , boolean visible ) { this . start = start ; this . end = end ; this . visible = visible ; }	initializes a new slice with start and end value .
public static void injecttotarget ( object target , bundle data ) { if ( target == null || data == null ) return ; parcelinjector injector ; try { injector = getinjectorbyclass ( target . getclass ( ) ) ; injector . injectdatatotarget ( target , data ) ; } catch ( exception e ) { throw new runtimeexception ( string . format ( _str , e . getmessage ( ) ) , e ) ; } }	inject some data from data to target .
public static boolean arebackendinitiators ( list < initiator > initiators ) { boolean backend = _bool ; for ( initiator initiator : initiators ) { if ( ! nullcolumnvaluegetter . isnulluri ( initiator . gethost ( ) ) && uriutil . istype ( initiator . gethost ( ) , host . class ) ) { backend = _bool ; break ; } } return backend ; }	checks if any of the initiators belongs to a true host and returns true if all initiators do not belong to a host.
public boolean containsvalue ( object value ) { return map . containsvalue ( value ) ; }	this method is used to determine whether any pair that has been inserted into the internal map had the presented value.
public boolean hasskins ( ) { return system . getproperty ( _str ) != null || system . getproperty ( _str ) != null ; }	subclasses of this implementation might override this to return builtin skins for a specific implementation.
public string tostring ( ) { stringbuilder builder = new stringbuilder ( ) ; if ( type != null ) { name ( builder ) ; attributes ( builder ) ; } return builder . tostring ( ) ; }	this is used to build a string from the annotation.
public void makeimmutable ( ) { if ( ! isimmutable ) { overflowentries = overflowentries . isempty ( ) ? collections . < k , v > emptymap ( ) : collections . unmodifiablemap ( overflowentries ) ; isimmutable = _bool ; } }	make this map immutable from this point forward .
protected void parsenames ( ) { while ( reader . hasnextcharacter ( ) ) { final char character = next ( ) ; if ( strings . iswhitespace ( character ) ) { addname ( ) ; continue ; } else if ( character == blockopening ) { addname ( ) ; break ; } else { builder . append ( character ) ; } } if ( gdxarrays . isempty ( tags ) ) { throwexception ( _str ) ; } }	parses names proceeding styles block .
protected void writezip64centraldirectory ( ) throws ioexception { if ( zip64mode == zip64mode . never ) { return ; } if ( ! hasusedzip64 && ( cdoffset >= zip64_magic || cdlength >= zip64_magic || entries . size ( ) >= zip64_magic_short ) ) { hasusedzip64 = _bool ; } if ( ! hasusedzip64 ) { return ; } long offset = written ; writeout ( zip64_eocd_sig ) ; writeout ( zipeightbyteinteger . getbytes ( short + short + word + word + dword + dword + dword + dword ) ) ; writeout ( zipshort . getbytes ( zip64_min_version ) ) ; writeout ( zipshort . getbytes ( zip64_min_version ) ) ; writeout ( lzero ) ; writeout ( lzero ) ; byte [ ] num = zipeightbyteinteger . getbytes ( entries . size ( ) ) ; writeout ( num ) ; writeout ( num ) ; writeout ( zipeightbyteinteger . getbytes ( cdlength ) ) ; writeout ( zipeightbyteinteger . getbytes ( cdoffset ) ) ; writeout ( zip64_eocd_loc_sig ) ; writeout ( lzero ) ; writeout ( zipeightbyteinteger . getbytes ( offset ) ) ; writeout ( one ) ; }	writes the & quot ; zip64 end of central dir record & quot ; and & quot ; zip64 end of central dir locator & quot ; .
public boolean iscachevalid ( int row ) { return m_valid . get ( row ) ; }	check if this expressioncolumn has a valid cached value at the given row .
public void finish ( ) throws ioexception { checkclosed ( ) ; write ( ) ; }	finishes writing current uncompressed data into the inflateroutputstream without closing it .
public final void readfully ( byte [ ] b , int off , int len ) throws java . io . ioexception { if ( len < _num ) { throw new indexoutofboundsexception ( ) ; } int n = _num ; while ( n < len ) { int count = read ( b , off + n , len - n ) ; if ( count < _num ) { throw new eofexception ( ) ; } n += count ; } }	see the general contract of the readfully method of datainput.
public svgrasterizer ( inputstream istream ) { this . input = new transcoderinput ( istream ) ; }	constructs a new svgrasterizer converter .
private static future < ? > directexecute ( runnable runnable , int delay ) { future < ? > future = null ; if ( delay > _num ) { if ( ! ( executor instanceof scheduledexecutorservice ) ) { throw new illegalargumentexception ( _str ) ; } scheduledexecutorservice scheduledexecutorservice = ( scheduledexecutorservice ) executor ; future = scheduledexecutorservice . schedule ( runnable , delay , timeunit . milliseconds ) ; } else { if ( executor instanceof executorservice ) { executorservice executorservice = ( executorservice ) executor ; future = executorservice . submit ( runnable ) ; } else { executor . execute ( runnable ) ; } } return future ; }	execute a runnable after the given delay .
@ override public void onpatchversioncheckfail ( file patchfile , sharepatchinfo oldpatchinfo , string patchfileversion , boolean isupgradepatch ) { tinkerlog . i ( tag , _str , patchfile . getabsolutepath ( ) , patchfileversion , isupgradepatch ) ; }	for upgrade patch , patchfileversion can ' t equal oldversion or newversion in oldpatchinfo for repair patch , oldpatchinfo can ' t be null , and patchfileversion must equal with oldversion and newversion.
public void init ( boolean forencryption , cipherparameters params ) throws illegalargumentexception { if ( ! ( params instanceof parameterswithiv ) ) { throw new illegalargumentexception ( _str ) ; } parameterswithiv ivparams = ( parameterswithiv ) params ; byte [ ] iv = ivparams . getiv ( ) ; if ( iv == null || iv . length != _num ) { throw new illegalargumentexception ( _str ) ; } if ( ! ( ivparams . getparameters ( ) instanceof keyparameter ) ) { throw new illegalargumentexception ( _str ) ; } keyparameter key = ( keyparameter ) ivparams . getparameters ( ) ; workingiv = new byte [ key . getkey ( ) . length ] ; workingkey = new byte [ key . getkey ( ) . length ] ; lfsr = new int [ state_size ] ; nfsr = new int [ state_size ] ; out = new byte [ _num ] ; system . arraycopy ( iv , _num , workingiv , _num , iv . length ) ; system . arraycopy ( key . getkey ( ) , _num , workingkey , _num , key . getkey ( ) . length ) ; reset ( ) ; }	initialize a grain v1 cipher .
gridmemcachedmessage ( ) { }	creates empty packet which will be filled in parser .
public extensionforceduser ( ) { super ( ) ; initialize ( ) ; }	instantiates a new forced user extension .
private string replaceplaceholders ( string query , map < string , string > replacements ) { string resultquery = query ; for ( map . entry < string , string > entry : replacements . entryset ( ) ) { resultquery = resultquery . replace ( entry . getkey ( ) , entry . getvalue ( ) ) ; } return resultquery ; }	replaces the placeholders with concrete values.
public void destroybucket ( automixbucket bucket ) { sharedpreferences prefs = getprefs ( ) ; sharedpreferences . editor editor = prefs . edit ( ) ; set < string > set = new treeset < > ( prefs . getstringset ( pref_buckets_ids , new treeset < string > ( ) ) ) ; set . remove ( bucket . getsessionid ( ) ) ; editor . putstringset ( pref_buckets_ids , set ) ; editor . apply ( ) ; mbuckets . remove ( bucket ) ; }	destroys the provided bucket.
public void clearchanged ( ) { changed . set ( _bool ) ; }	clears the changed flag .
public static object [ ] convertparams ( object [ ] source , class < ? > [ ] target ) { object [ ] converted = new object [ target . length ] ; for ( int i = _num ; i < target . length ; i ++ ) { converted [ i ] = convert ( source [ i ] , target [ i ] ) ; } return converted ; }	convert parameters using methods of this utility class.
private void rprobeandaddhopstocandidateset ( hop hop , hashset < hop > probeset , hashset < pair < hop , hop > > candset ) { if ( hop . getvisited ( ) == visitstatus . done ) return ; if ( hop . getinput ( ) != null ) for ( hop c : hop . getinput ( ) ) { if ( ! probeset . contains ( c ) ) rprobeandaddhopstocandidateset ( c , probeset , candset ) ; else { candset . add ( new pair < hop , hop > ( hop , c ) ) ; } } hop . setvisited ( visitstatus . done ) ; }	note : candset is a set of parent - child pairs because a parent might have multiple references to replicated hops .
protected void parse ( datainputstream stream ) throws exception { value = stream . readint ( ) ; }	loading method . ( see nbt_tag ).
list < string > aslist ( ) { if ( more ) { list . set ( list . size ( ) - _num , _str ) ; } return collections . unmodifiablelist ( list ) ; }	get the name list of the added entities .
public void testnotneg ( ) { byte abytes [ ] = { - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , - _num } ; int asign = - _num ; byte rbytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . not ( ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	not for a negative number.
public cachestatresource ( string resourceidentifier , cacheresource cacheresource ) { super ( resourceidentifier ) ; this . cacheresource = cacheresource ; relativecachestats = cacheresource . getcachestats ( ) ; }	instantiates a new debug resource .
public map < uri , list < uri > > addtargetvolumefullcopies ( ) { list < uri > fullcopies = lists . newarraylist ( ) ; map < uri , list < uri > > fullcopiesmap = new hashmap < > ( ) ; uri targetcg = null ; for ( uri volumeid : uris ( volumeids ) ) { list < uri > targets = gettargets ( volumeid ) ; for ( uri target : targets ) { if ( targetcg == null ) { targetcg = getconsistencygroup ( target ) ; } list < uri > volumefullcopies = getfullcopies ( target ) ; fullcopies . addall ( volumefullcopies ) ; fullcopiesmap . put ( target , volumefullcopies ) ; } } if ( ! fullcopies . isempty ( ) && targetcg != null ) { blockstorageutils . addvolumestoconsistencygroup ( targetcg , fullcopies ) ; } return fullcopiesmap ; }	adds all target volumes ' full copies to the target consistency group.
weatherattribute ( int max , string ... desc ) { maxvalue = max ; value = rand . rand ( max + _num ) ; this . desc = desc ; }	create a weatherattribute with a maximum value and a set of descriptions .
protected classloader ( classloader parentloader ) { securitymanager sc = system . getsecuritymanager ( ) ; if ( sc != null ) { sc . checkcreateclassloader ( ) ; } parentclassloader = parentloader ; definedpackages = new hashmap < string , package > ( ) ; loadedclasses = new hashmap < string , class < ? > > ( ) ; packagecertificates = new hashtable < string , certificate [ ] > ( ) ; }	constructs a new instance of this class with the given class loader as its parent .
static public double log10 ( double invalue ) { return math . log ( invalue ) / math . log ( _num ) ; }	a static method that uses the natural log to obtain log to base10.
void updatefeaturecounts ( int [ ] translationids , list < list < richtranslation < istring , string > > > nbestlists ) { for ( int i = _num ; i < translationids . length ; i ++ ) { set < string > features = new hashset < string > ( ) ; for ( richtranslation < istring , string > trans : nbestlists . get ( i ) ) { for ( featurevalue < string > f : trans . features ) { features . add ( f . name ) ; } } synchronized ( clippedfeatureindex ) { for ( string fname : features ) { set < integer > ids = clippedfeatureindex . get ( fname ) ; if ( ids == null ) { ids = new treeset < integer > ( ) ; clippedfeatureindex . put ( fname , ids ) ; } if ( ids . size ( ) < minfeaturecount ) { ids . add ( translationids [ i ] ) ; } } } } }	update counts of the number of times we have seen each feature . features are only counted ounce per source sentence.
private void addnativeexpressads ( ) { for ( int i = _num ; i <= mrecyclerviewitems . size ( ) ; i += items_per_ad ) { final nativeexpressadview adview = new nativeexpressadview ( mainactivity . this ) ; mrecyclerviewitems . add ( i , adview ) ; } }	adds native express ads to the items list .
protected boolean accept ( final ichangerecord record ) { return _bool ; }	subclasses can override this to only record history on certain change events .
public final t allocate ( ) { atomicinteger topref = _top ; while ( _bool ) { final int top = topref . get ( ) ; if ( top <= _num ) { return null ; } else if ( topref . compareandset ( top , top - _num ) ) { t value = _freestack . getandset ( top - _num , null ) ; if ( value != null ) { return value ; } } } }	try to get an object from the free list.
public void putresponsegetallresources ( list < string > resources ) { logger . debug ( _str ) ; resourceset resourceset = new resourceset ( ) ; for ( string res : resources ) { remoteresource resource = gson . fromjson ( res , remoteresource . class ) ; resource . setresourcepoolconnector ( this ) ; resourceset . add ( resource ) ; } synchronized ( getallresourceresponse ) { getallresourceresponse . add ( resourceset ) ; getallresourceresponse . notify ( ) ; } }	supposed to call from remoteinterpretereventpoller.
public static map < string , set < string > > toavpairmap ( final set < string > names , final string value ) { if ( value == null ) { return collections . empty_map ; } if ( names == null || names . isempty ( ) ) { return new hashmap ( ) ; } final map < string , set < string > > map = new hashmap < string , set < string > > ( names . size ( ) ) ; final set < string > set = new hashset < string > ( _num ) ; set . add ( value ) ; for ( final string name : names ) { map . put ( name , set ) ; } return map ; }	creates a hash map , of names mapped to the provided value.
public prefixtagger ( maxenttagger maxenttagger ) { super ( maxenttagger ) ; this . leftwindow = leftwindow ( ) ; this . rightwindow = rightwindow ( ) ; this . offset = leftwindow ( ) ; }	creates a new prefixtagger .
private iterable < int [ ] > splitarray ( int [ ] arr ) { int len1 = arr . length / _num ; int len2 = len1 + arr . length % _num ; int [ ] a1 = new int [ len1 ] ; int [ ] a2 = new int [ len2 ] ; system . arraycopy ( arr , _num , a1 , _num , len1 ) ; system . arraycopy ( arr , len1 , a2 , _num , len2 ) ; return arrays . aslist ( a1 , a2 ) ; }	splits the array into two parts.
@ ignore @ test public void shouldcapturequeryeventdata ( ) throws exception { startclient ( null ) ; counters . consumeall ( _num , timeunit . seconds ) ; list < queryeventdata > allqueryevents = recordedeventdata ( queryeventdata . class , - _num ) ; allqueryevents . foreach ( null ) ; }	test case that is normally commented out since it is only useful to print out the ddl statements recorded by the binlog during a mysql server initialization and startup .
private list < validationerror > checkfornoratespresent ( ) { if ( overheadrates != null && overheadrates . isempty ( ) ) return arrays . aslist ( new validationerror ( _str , _str ) ) ; else return null ; }	this method checks if no overhead rates have been entered for the overhead .
public void modifyexport ( string id , string zonename , isilonexport exp ) throws isilonexception { string uriwithzonename = geturiwithzonename ( id , zonename ) ; modify ( _baseurl . resolve ( uri_nfs_exports ) , uriwithzonename , _str , exp ) ; }	modify export in access zone.
public double measurenumiterations ( ) { return m_classifiers . size ( ) ; }	return the number of iterations ( base classifiers ) completed.
public int count ( ) { return dict . size ( ) ; }	counts the number of contained key - value pairs .
public static boolean aboveorequal ( int a , int b ) { return integer . compareunsigned ( a , b ) >= _num ; }	unsigned comparison aboveorequal for two numbers .
protected void awaitcompletioncomputevaluesandshutdown ( ) { { runexecutorandawaitcompletion ( ) ; } if ( logger . isdebugenabled ( ) ) printstats ( ) ; executor . shutdown ( ) ; while ( ! executor . isterminated ( ) ) { try { thread . sleep ( _num ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } }	awaits the completion of the exploded super graph.
public flags flaglist ( ) throws decodingexception { flags flags = new flags ( ) ; nextwordchar ( ) ; consumechar ( _str ) ; charactervalidator validator = new noopcharvalidator ( ) ; string nextword = consumeword ( validator ) ; while ( ! nextword . endswith ( _str ) ) { decoderutils . setflag ( nextword , flags ) ; nextword = consumeword ( validator ) ; } if ( nextword . length ( ) > _num ) { int parenindex = nextword . indexof ( _str ) ; if ( parenindex > _num ) { final string nextflag = nextword . substring ( _num , parenindex ) ; decoderutils . setflag ( nextflag , flags ) ; } } return flags ; }	reads a " flags - list " argument from the request .
protected restclientitf createnewrestclient ( uri endpoint , string username , string password , string version , client client ) { xtremioclient xioclient = null ; if ( version != null && ! version . isempty ( ) && integer . valueof ( version . split ( dot_operator ) [ _num ] ) >= xio_min_4x_version ) { xioclient = new xtremiov2client ( endpoint , username , password , client ) ; } else { xioclient = new xtremiov1client ( endpoint , username , password , client ) ; } return xioclient ; }	create a new xtremio rest client for the given endpoint , username , password and xtremio version.
public string diff_text2 ( linkedlist < diff > diffs ) { stringbuilder text = new stringbuilder ( ) ; for ( diff adiff : diffs ) { if ( adiff . operation != operation . delete ) { text . append ( adiff . text ) ; } } return text . tostring ( ) ; }	compute and return the destination text ( all equalities and insertions ) .
static private < e > list < e > tojavalist ( list < e > values , int rows , int columns ) { list < e > result = new arraylist < > ( values . size ( ) ) ; for ( int i = _num ; i < values . size ( ) ; i ++ ) { int row = i / columns ; int column = i % columns ; e value = values . get ( ( column * rows ) + row ) ; result . add ( value ) ; } return result ; }	translates a column - major ( ie.
public string tohtml ( node node , appendable appendable ) { nodevisitor renderer = createrenderer ( appendable ) ; node . visit ( renderer ) ; return appendable . tostring ( ) ; }	renders node to appendable .
public static string [ ] tocommaseparatedarray ( string str ) throws ioexception { return str . split ( _str ) ; }	returns a value as a string array.
@ override public final object put ( string key , object value ) { return set ( key , value ) ; }	put the key - value in bean .
private void appendfloattype ( stringbuilder sb , fieldtype fieldtype , int fieldwidth ) { sb . append ( _str ) ; }	output the sql type for a java float .
private httpentity paramstoentity ( requestparams params , responsehandlerinterface responsehandler ) { httpentity entity = null ; try { if ( params != null ) { entity = params . getentity ( responsehandler ) ; } } catch ( throwable t ) { if ( responsehandler != null ) responsehandler . sendfailuremessage ( _num , null , null , t ) ; else t . printstacktrace ( ) ; } return entity ; }	returns httpentity containing data from requestparams included with request declaration . allows also passing progress from upload via provided responsehandler.
public static boolean isinstallableediting ( enumset < embeddingflags > flagset ) { return flagset . isempty ( ) ; }	takes an enumset \ < embeddingflags \ > representation of the fstype and returns whether or not the fstype is installable embedding.
public void testmultiplyscalepospos ( ) { string a = _str ; int ascale = _num ; string b = _str ; int bscale = _num ; string c = _str ; int cscale = _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; bigdecimal result = anumber . multiply ( bnumber ) ; assertequals ( _str , c , result . tostring ( ) ) ; assertequals ( _str , cscale , result . scale ( ) ) ; }	multiply two numbers of positive scales.
public iterator < resource > resourceiterator ( ) { return resourcelist . iterator ( ) ; }	get an iterator over all resources in the method.
public double nextuniform ( double lower , double upper ) { if ( upper <= lower ) { throw new mathillegalargumentexception ( localizedcoreformats . lower_bound_not_below_upper_bound , lower , upper ) ; } if ( double . isinfinite ( lower ) || double . isinfinite ( upper ) ) { throw new mathillegalargumentexception ( localizedcoreformats . infinite_bound ) ; } if ( double . isnan ( lower ) || double . isnan ( upper ) ) { throw new mathillegalargumentexception ( localizedcoreformats . nan_not_allowed ) ; } final double u = randomgenerator . nextdouble ( ) ; return u * upper + ( _num - u ) * lower ; }	returns a double value uniformly distributed over [ lower , upper ].
public shapetilebox bounding_box ( ) { plapointint lower_left = new plapointint ( math . floor ( v_x ) , math . floor ( v_y ) ) ; plapointint upper_right = new plapointint ( math . ceil ( v_x ) , math . ceil ( v_y ) ) ; return new shapetilebox ( lower_left , upper_right ) ; }	creates the smallest intbox containing this point .
public void addinterface ( string name ) { cachedinterfaces = null ; int info = constpool . addclassinfo ( name ) ; if ( interfaces == null ) { interfaces = new int [ _num ] ; interfaces [ _num ] = info ; } else { int n = interfaces . length ; int [ ] newarray = new int [ n + _num ] ; system . arraycopy ( interfaces , _num , newarray , _num , n ) ; newarray [ n ] = info ; interfaces = newarray ; } }	appends an interface to the interfaces implemented by the class .
@ suppresswarnings ( _str ) public static missue create ( properties ctx , string hexinput ) { hashmap hmin = null ; try { byte [ ] bytearray = secure . converthexstring ( hexinput ) ; bytearrayinputstream bin = new bytearrayinputstream ( bytearray ) ; objectinputstream oin = new objectinputstream ( bin ) ; hmin = ( hashmap ) oin . readobject ( ) ; } catch ( exception e ) { s_log . log ( level . severe , _str , e ) ; return null ; } missue issue = new missue ( ctx , ( hashmap < string , string > ) hmin ) ; return issue ; }	create from decoded hash map string.
void flushbuffer ( ) throws ioexception { se . flushbuffer ( ) ; }	flushes the output buffer to the underlying byte stream , without flushing the byte stream itself.
public static void showunknownerror ( context context , throwable t , dialoginterface . oncancellistener listener ) { showerror ( context , string . format ( context . getstring ( r . string . afc_pmsg_unknown_error ) , t ) , listener ) ; }	shows an unknown error .
public void addbutton ( final jbutton thebutton ) { custombuttonpanel . add ( thebutton ) ; }	adds a new button to the panel .
void swapcursor ( long monthmillis , @ nullable eventcursor cursor , contentobserver contentobserver ) { for ( int i = _num ; i < mmonths . size ( ) ; i ++ ) { if ( calendarutils . samemonth ( monthmillis , mmonths . get ( i ) ) ) { swapcursor ( i , cursor , contentobserver ) ; break ; } } }	swaps cursor for calendar events for given month closes previously bound cursor , unregisters observer if any.
final boolean close ( ) { return ! closed . getandset ( _bool ) ; }	logically closes this invocation handler.
public byte [ ] encryptraw ( byte [ ] basekey , int usage , byte [ ] ivec , byte [ ] plaintext , int start , int len ) throws generalsecurityexception , krbcryptoexception { if ( ! keyusage . isvalid ( usage ) ) { throw new generalsecurityexception ( _str + usage ) ; } byte [ ] output = encryptcts ( basekey , usage , ivec , null , plaintext , start , len , _bool ) ; return output ; }	performs encryption using derived key ; does not add confounder .
private void fixbug ( document doc ) { element element = doc . getdocumentelement ( ) ; if ( element != null ) { fixbug ( element ) ; } }	this is to fix a bug generated by version 3.
private string tohexstring ( byte [ ] block ) { stringbuffer buf = new stringbuffer ( ) ; int len = block . length ; for ( int i = _num ; i < len ; i ++ ) { byte2hex ( block [ i ] , buf ) ; if ( i < len - _num ) { buf . append ( _str ) ; } } return buf . tostring ( ) ; }	converts a byte array to hex string.
public static string removedeployuri ( string uri ) { if ( ( uri == null ) || ( uri . length ( ) == _num ) ) { return uri ; } int loc = uri . indexof ( _str , _num ) ; if ( loc == - _num ) { return null ; } else { return uri . substring ( loc ) ; } }	removes deployment uri from the pass down string.
public static double loss ( double pred , double y ) { return math . abs ( y - pred ) ; }	computes the absolute loss.
public boolean needsignaturefilebytes ( ) { return sfbytes == null ; }	returns true if we need the . sf file.
public void insert ( t object , int index ) { synchronized ( mlock ) { mobjects . add ( index , object ) ; } if ( mnotifyonchange ) notifyiteminserted ( index ) ; }	inserts the specified object at the specified index in the array .
private void loadtargetmodules ( ) { for ( final module module : target . getmodules ( ) ) { module . addlistener ( modulekeeperlistener ) ; modules . add ( module ) ; if ( ! module . isloaded ( ) ) { try { module . load ( ) ; } catch ( final couldntloaddataexception e ) { errorloadingmodule ( module , e ) ; return ; } } } step ++ ; }	loads the modules that belong to the target .
public bloomfilter ( double falsepositiveprobability , int expectednumberofelements ) { this ( math . ceil ( - ( math . log ( falsepositiveprobability ) / math . log ( _num ) ) ) / math . log ( _num ) , expectednumberofelements , ( int ) math . ceil ( - ( math . log ( falsepositiveprobability ) / math . log ( _num ) ) ) ) ; }	constructs an empty bloom filter with a given false positive probability.
public synchronized void notifyband ( final int times , final int ontime , final int offtime , final int flashcolour ) { final list < bleaction > list = new arraylist < > ( ) ; byte [ ] colors = convertrgb ( flashcolour ) ; list . add ( new waitaction ( _num ) ) ; list . add ( new writeaction ( profile . uuid_char_control_point , protocol . vibration_without_led ) ) ; list . add ( new waitaction ( _num ) ) ; list . add ( new writeaction ( profile . uuid_char_control_point , colors ) ) ; queue ( list ) ; }	notifies the mi band with vibration and colour.
public void test_constructorljava_security_cert_certpathparameters ( ) { try { certpathparameters parameters = new mycertpathparameters ( ) ; certpathtrustmanagerparameters p = new certpathtrustmanagerparameters ( parameters ) ; assertnotsame ( _str , parameters , p . getparameters ( ) ) ; } catch ( exception e ) { fail ( _str + e . tostring ( ) ) ; } try { new certpathtrustmanagerparameters ( null ) ; fail ( _str ) ; } catch ( nullpointerexception npe ) { } }	javax . net . ssl . certpathtrustmanagerparameters # certpathtrustmanagerparameters ( java . security . cert . certpathparameters ) case 1 : try to construct object . case 2 : check nullpointerexception .
private static int buildrequestcode ( long threadid , int action ) { action ++ ; return ( int ) ( action * _num + threadid ) ; }	creates a unique action id for notification actions ( open , mark read , call , etc ).
public outerjoinqualifier add ( string propertyleft , string propertyright ) { additionalproperties . add ( new propertyvalueexpressionpair ( new propertyvalueexpression ( propertyleft ) , new propertyvalueexpression ( propertyright ) ) ) ; return this ; }	add additional properties to the on - clause , which are logical - and to existing properties.
public void insertelementat ( int value , int at ) { if ( null == m_map ) { m_map = new int [ m_blocksize ] ; m_mapsize = m_blocksize ; } else if ( ( m_firstfree + _num ) >= m_mapsize ) { m_mapsize += m_blocksize ; int newmap [ ] = new int [ m_mapsize ] ; system . arraycopy ( m_map , _num , newmap , _num , m_firstfree + _num ) ; m_map = newmap ; } if ( at <= ( m_firstfree - _num ) ) { system . arraycopy ( m_map , at , m_map , at + _num , m_firstfree - at ) ; } m_map [ at ] = value ; m_firstfree ++ ; }	inserts the specified node in this vector at the specified index.
protected static dfp ataninternal ( final dfp a ) { dfp y = new dfp ( a ) ; dfp x = new dfp ( y ) ; dfp py = new dfp ( y ) ; for ( int i = _num ; i < _num ; i += _num ) { x = x . multiply ( a ) ; x = x . multiply ( a ) ; x = x . negate ( ) ; y = y . add ( x . divide ( i ) ) ; if ( y . equals ( py ) ) { break ; } py = new dfp ( y ) ; } return y ; }	computes the arc - tangent of the argument .
public static string parsesegmentname ( string filename ) { int idx = indexofsegmentname ( filename ) ; if ( idx != - _num ) { filename = filename . substring ( _num , idx ) ; } return filename ; }	parses the segment name out of the given file name .
private static tree generatesubtree ( hashmap < integer , pair < indexedword , list < integer > > > dependencies , int root ) { list < integer > children = dependencies . get ( root ) . second ; indexedword tw = dependencies . get ( root ) . first ; tree tree = new labeledscoredtreenode ( tw ) ; boolean addedhead = children . isempty ( ) ; list < integer > sortedchildren = collectionutils . sorted ( children ) ; for ( integer c : sortedchildren ) { if ( c > root && ! addedhead ) { tree child = new labeledscoredtreenode ( tw ) ; tree . addchild ( child ) ; addedhead = _bool ; } tree child = generatesubtree ( dependencies , c ) ; tree . addchild ( child ) ; } if ( ! addedhead ) { tree child = new labeledscoredtreenode ( tw ) ; tree . addchild ( child ) ; } return tree ; }	recursively generates a shallow constituent tree rooted at root .
@ hlefunction ( nid = _num , version = _num , checkinsideinterrupt = _bool ) public int __scesasrevparam ( int sascore , int delay , int feedback ) { checksashandlegood ( sascore ) ; waveformeffectdelay = delay ; waveformeffectfeedback = feedback ; return _num ; }	set the wave form effect delay and feedback parameters ( unknown parameters ) .
static boolean ispossiblefp ( string val ) { final int length = val . length ( ) ; for ( int i = _num ; i < length ; ++ i ) { char c = val . charat ( i ) ; if ( ! ( c >= _str && c <= _str || c == _str || c == _str || c == _str || c == _str || c == _str ) ) { return _bool ; } } return _bool ; }	returns true if it ' s possible that the given string represents a valid floating point value ( excluding nan , inf and - inf ) .
public boolean deletetrack ( track track ) { synchronized ( tracks ) { return tracks . removeelement ( track ) ; } }	removes the specified track from the sequence .
protected static arraylist < geopoint > parsekmlcoordinates ( string input ) { linkedlist < geopoint > tmpcoords = new linkedlist < geopoint > ( ) ; int i = _num ; int tuplestart = _num ; int length = input . length ( ) ; boolean startreadingtuple = _bool ; while ( i < length ) { char c = input . charat ( i ) ; if ( c == _str || c == _str || c == _str ) { if ( startreadingtuple ) { string tuple = input . substring ( tuplestart , i ) ; geopoint p = parsekmlcoord ( tuple ) ; if ( p != null ) tmpcoords . add ( p ) ; startreadingtuple = _bool ; } } else { if ( ! startreadingtuple ) { startreadingtuple = _bool ; tuplestart = i ; } if ( i == length - _num ) { string tuple = input . substring ( tuplestart , i + _num ) ; geopoint p = parsekmlcoord ( tuple ) ; if ( p != null ) tmpcoords . add ( p ) ; } } i ++ ; } arraylist < geopoint > coordinates = new arraylist < geopoint > ( tmpcoords . size ( ) ) ; coordinates . addall ( tmpcoords ) ; return coordinates ; }	kml coordinates are : lon , lat { , alt } tuples separated by separators ( space , tab , cr ) .
public void paint ( graphics2d g ) { for ( int i = _num ; i < m_nodes . size ( ) ; i ++ ) { wfnode node = m_nodes . get ( i ) ; rectangle rect = node . getbounds ( ) ; g . setcolor ( color . black ) ; g . drawrect ( rect . x , rect . y , rect . width , rect . height ) ; graphics2d t = ( graphics2d ) g . create ( rect . x , rect . y , rect . width , rect . height ) ; node . paint ( t ) ; t . dispose ( ) ; } createlines ( ) ; for ( int i = _num ; i < m_lines . size ( ) ; i ++ ) { wfline line = ( wfline ) m_lines . get ( i ) ; line . paint ( g ) ; } }	paint component . paint lines directly as not added .
serversessioncontext registerrequest ( long sequence , runnable runnable ) { commands . put ( sequence , runnable ) ; return this ; }	adds a command to be executed in sequence .
public void addpreferencesbutton ( ) { jbutton prefsbutton = new jbutton ( _str ) ; prefsbutton . sethideactiontext ( _bool ) ; prefsbutton . setaction ( timeseriesplotactions . getpropertiesdialogaction ( this ) ) ; buttonpanel . add ( prefsbutton ) ; }	add button for showing preferences .
public static void findindexmatches ( searchpattern pattern , index index , indexqueryrequestor requestor , searchparticipant participant , ijavasearchscope scope , iprogressmonitor monitor ) throws ioexception { pattern . findindexmatches ( index , requestor , participant , scope , monitor ) ; }	query a given index for matching entries.
public static void loginfo ( string message , object ... args ) { message = messageformat . format ( message , args ) ; log ( istatus . info , istatus . ok , message , null ) ; }	log the specified information .
public static boolean occupy ( int waitms ) { if ( occupieduntil != null && occupieduntil . after ( new date ( ) ) ) { return _bool ; } occupieduntil = dateutils . addmilliseconds ( new date ( ) , waitms ) ; return _bool ; }	tries to occupy the onclick enabler .
public boolean [ ] [ ] moralize ( bayesnet bayesnet ) { int nnodes = bayesnet . getnrofnodes ( ) ; boolean [ ] [ ] badjacencymatrix = new boolean [ nnodes ] [ nnodes ] ; for ( int inode = _num ; inode < nnodes ; inode ++ ) { parentset parents = bayesnet . getparentsets ( ) [ inode ] ; moralizenode ( parents , inode , badjacencymatrix ) ; } return badjacencymatrix ; }	moralize dag and calculate adjacency matrix representation for a bayes network , effecively converting the directed acyclic graph to an undirected graph .
public void adddivider ( imageview v ) { relativelayout . layoutparams dividerparams = new relativelayout . layoutparams ( layoutparams . fill_parent , layoutparams . wrap_content ) ; if ( mimageview != null ) { dividerparams . addrule ( relativelayout . below , mimageview . getid ( ) ) ; } else if ( mmissingimage != null ) { dividerparams . addrule ( relativelayout . below , mmissingimage . getid ( ) ) ; } else if ( mvideobutton != null ) { dividerparams . addrule ( relativelayout . below , mvideobutton . getid ( ) ) ; } else if ( maudiobutton != null ) { dividerparams . addrule ( relativelayout . below , maudiobutton . getid ( ) ) ; } else if ( mview_text != null ) { dividerparams . addrule ( relativelayout . below , mview_text . getid ( ) ) ; } else { log . e ( t , _str ) ; return ; } addview ( v , dividerparams ) ; }	this adds a divider at the bottom of this layout.
private double findlength ( point originpoint , point targetpoint ) { int x1 = originpoint . x ; int y1 = originpoint . y ; int x2 = targetpoint . x ; int y2 = targetpoint . y ; double sidea = x2 - x1 ; double sideb = ( y1 > y2 ? ( y1 - y2 ) : ( y2 - y1 ) ) ; if ( sideb == _num ) { return sidea ; } return math . sqrt ( math . pow ( sidea , _num ) + math . pow ( sideb , _num ) ) ; }	uses trig to find legth of the hypotenuse.
public void testcase4 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = _num ; int bsign = - _num ; byte rbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . subtract ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _num , result . signum ( ) ) ; }	subtract two numbers of the same length and different signs.
public static void write ( inputstream in , outputstream out , boolean closeboth ) throws ioexception { byte [ ] buff = new byte [ _num ] ; int read = _num ; while ( ( read = in . read ( buff ) ) > _num ) { out . write ( buff , _num , read ) ; } out . flush ( ) ; if ( closeboth ) { safeclosestreams ( in , out ) ; } }	writes the input stream to the output stream.
public static double distance ( coordinatedd p1 , coordinatedd p2 , units units ) { final double latp1 = p1 . northsouth ; final double latp2 = p2 . northsouth ; final double lonp1 = p1 . eastwest ; final double lonp2 = p2 . eastwest ; if ( latp1 == latp2 && lonp1 == lonp2 ) return _num ; double distrad = math . acos ( math . sin ( toradians ( latp1 ) ) * math . sin ( toradians ( latp2 ) ) + math . cos ( toradians ( latp1 ) ) * math . cos ( toradians ( latp2 ) ) * math . cos ( toradians ( lonp1 - lonp2 ) ) ) ; final double distasdegree = todegrees ( distrad ) ; return meterstounits ( distasdegree * _num * _num * _num , units ) ; }	computes the distance between two coordinates .
public static liquidnetwork initnetwork ( ) { random random = new random ( system . currenttimemillis ( ) ) ; int id = random . nextint ( ) ; while ( usedids . contains ( id ) ) { id = random . nextint ( ) ; } ; liquidnetwork net = new liquidnetwork ( ) ; usedids . add ( id ) ; net . networkid = id ; return net ; }	create a new network and get an id.
public string exportxml ( ) throws ioexception { bytearrayoutputstream outputstream = new bytearrayoutputstream ( ) ; exportxml ( outputstream ) ; return outputstream . tostring ( ) ; }	dumps fetch data in xml format .
public patternreplacefilter ( tokenstream in , pattern p , string replacement , boolean all ) { super ( in ) ; this . replacement = ( null == replacement ) ? _str : replacement ; this . all = all ; this . m = p . matcher ( termatt ) ; }	constructs an instance to replace either the first , or all occurances.
public static int [ ] stablesort ( double [ ] array ) { int [ ] index = new int [ array . length ] ; int [ ] newindex = new int [ array . length ] ; int [ ] helpindex ; int numequal ; array = ( double [ ] ) array . clone ( ) ; for ( int i = _num ; i < index . length ; i ++ ) { index [ i ] = i ; if ( double . isnan ( array [ i ] ) ) { array [ i ] = double . max_value ; } } quicksort ( array , index , _num , array . length - _num ) ; int i = _num ; while ( i < index . length ) { numequal = _num ; for ( int j = i + _num ; ( ( j < index . length ) && utils . eq ( array [ index [ i ] ] , array [ index [ j ] ] ) ) ; j ++ ) numequal ++ ; if ( numequal > _num ) { helpindex = new int [ numequal ] ; for ( int j = _num ; j < numequal ; j ++ ) helpindex [ j ] = i + j ; quicksort ( index , helpindex , _num , numequal - _num ) ; for ( int j = _num ; j < numequal ; j ++ ) newindex [ i + j ] = index [ helpindex [ j ] ] ; i += numequal ; } else { newindex [ i ] = index [ i ] ; i ++ ; } } return newindex ; }	sorts a given array of doubles in ascending order and returns an array of integers with the positions of the elements of the original array in the sorted array.
public void reopenreadwrite ( ) { synchronized ( mlock ) { throwifnotopenlocked ( ) ; if ( ! isreadonlylocked ( ) ) { return ; } final int oldopenflags = mconfigurationlocked . openflags ; mconfigurationlocked . openflags = ( mconfigurationlocked . openflags & ~ open_read_mask ) | open_readwrite ; try { mconnectionpoollocked . reconfigure ( mconfigurationlocked ) ; } catch ( runtimeexception ex ) { mconfigurationlocked . openflags = oldopenflags ; throw ex ; } } }	reopens the database in read - write mode.
public static int readchars ( reader r , char [ ] chararray ) throws ioexception { int totalcharsread = _num ; int charsread = r . read ( chararray ) ; while ( charsread >= _num ) { totalcharsread += charsread ; if ( totalcharsread == chararray . length ) { break ; } charsread = r . read ( chararray , totalcharsread , chararray . length - totalcharsread ) ; } return totalcharsread ; }	fills the supplied character array with characters read from the specified reader.
public void removedirection ( final direction dir , final boolean face ) { rpaction action ; int size ; action = new rpaction ( ) ; action . put ( _str , _str ) ; action . put ( _str , - dir . get ( ) ) ; send ( action ) ; directions . remove ( dir ) ; size = directions . size ( ) ; if ( size == _num ) { action = new rpaction ( ) ; action . put ( _str , _str ) ; } else { if ( face ) { action = new facerpaction ( directions . get ( size - _num ) ) ; } else { action = new moverpaction ( directions . get ( size - _num ) ) ; } } send ( action ) ; }	remove a player movement direction .
public static double [ ] ndary ( int n ) { double d [ ] = new double [ n ] ; for ( int i = _num ; i < n ; i ++ ) { d [ i ] = r . nextgaussian ( ) ; } return d ; }	generates a one - dimensional array of normal random doubles .
private float applybounce ( float velocity , float distoutofbounds , float simulationrate ) { if ( iszero ( distoutofbounds ) ) { return velocity ; } velocity *= - _num ; float bounce = bounce_multiplier * math . abs ( distoutofbounds / mirisradius ) ; if ( velocity > _num ) { velocity += bounce * simulationrate ; } else { velocity -= bounce * simulationrate ; } return velocity ; }	update velocity in response to bouncing off the sides of the eye ( i.
private double dot ( final int k0 , final int k1 , final int [ ] assignment0 , final int [ ] assignment1 ) { double dot = _num ; final int n = x . size ( ) ; int a = _num , b = _num ; for ( int i = _num ; i < n ; i ++ ) { if ( assignment0 [ i ] != k0 ) continue ; a ++ ; for ( int j = _num ; j < n ; j ++ ) { if ( assignment1 [ j ] != k1 ) continue ; dot += kernel . eval ( i , j , x , accel ) ; } } for ( int j = _num ; j < n ; j ++ ) if ( assignment1 [ j ] == k1 ) b ++ ; return dot / ( a * b ) ; }	dot product between two different clusters from different sets of cluster assignments.
public void removealltextures ( ) { for ( weakreference < cctexture2d > texsr : textures . values ( ) ) { cctexture2d tex = texsr . get ( ) ; if ( tex != null ) tex . releasetexture ( ccdirector . gl ) ; } textures . clear ( ) ; }	purges the dictionary of loaded textures . call this method if you receive the " memory warning " in the short term : it will free some resources preventing your app from being killed in the medium term : it will allocate more resources in the long term : it will be the same.
public synchronized void addtoqueue ( final imageresourceloader imageresourceloader , final string uri , final mutablefsimage mfsi , final int width , final int height ) { xrlog . general ( level . fine , _str + uri ) ; _loadqueue . addlast ( new imageloaditem ( imageresourceloader , uri , mfsi , width , height ) ) ; notifyall ( ) ; }	queues a new item to be loaded.
private jniwriter ( context context ) { context . put ( jniwriterkey , this ) ; filemanager = context . get ( javafilemanager . class ) ; log = log . instance ( context ) ; options options = options . instance ( context ) ; verbose = options . isset ( verbose ) ; checkall = options . isset ( _str ) ; this . context = context ; syms = symtab . instance ( context ) ; linesep = system . getproperty ( _str ) ; }	construct a class writer , given an options table .
public josmtolerantfastxmlparser ( sink sink , xmlstreamreader reader , boolean enabledateparsing ) { this . sink = sink ; this . enabledateparsing = enabledateparsing ; this . reader = reader ; if ( enabledateparsing ) { timestampformat = new xmltimestampformat ( ) ; } else { calendar calendar ; calendar = calendar . getinstance ( ) ; calendar . set ( calendar . millisecond , _num ) ; dummytimestampcontainer = new simpletimestampcontainer ( calendar . gettime ( ) ) ; } membertypeparser = new membertypeparser ( ) ; }	creates a new instance .
public hashtable ( int initialcapacity , float loadfactor ) { if ( initialcapacity < _num ) { throw new illegalargumentexception ( _str + initialcapacity ) ; } if ( loadfactor <= _num || float . isnan ( loadfactor ) ) { throw new illegalargumentexception ( _str + loadfactor ) ; } if ( initialcapacity == _num ) initialcapacity = _num ; this . loadfactor = loadfactor ; table = new entry [ initialcapacity ] ; threshold = ( int ) ( initialcapacity * loadfactor ) ; }	constructs a new , empty hashtable with the specified initial capacity and the specified load factor .
public static string extractreminder ( string publicurl , string accessurl ) { return publicurl . substring ( accessurl . length ( ) ) ; }	extracts container / object from http : / / hostname / v1 / auth_id / container / object.
public void createunderlying ( ) { if ( options != null ) { options . createunderlying ( ) ; if ( platform . isfxapplicationthread ( ) ) { line = new com . lynden . gmapsfx . shapes . polyline ( options . convert ( ) ) ; } } }	creates the gmapsfx model polyline.
private void initrasterprogram ( ) { intbuffer props = bufferutils . createintbuffer ( _num ) ; intbuffer params = bufferutils . createintbuffer ( _num ) ; int uniformsresourceindex = glgetprogramresourceindex ( rasterprogram , gl_uniform_block , _str ) ; computeubobinding = params . get ( _num ) ; props . put ( _num , gl_buffer_binding ) ; glgetprogramresourceiv ( rasterprogram , gl_uniform_block , uniformsresourceindex , props , null , params ) ; rasterubobinding = params . get ( _num ) ; }	initialize the raster program .
private void installvoicedata ( ) { if ( textutils . isempty ( getenginename ( ) ) ) return ; intent intent = new intent ( texttospeech . engine . action_install_tts_data ) ; intent . addflags ( intent . flag_activity_new_task ) ; intent . setpackage ( getenginename ( ) ) ; try { log . v ( tag , _str + intent . touri ( _num ) ) ; startactivity ( intent ) ; } catch ( activitynotfoundexception ex ) { log . e ( tag , _str + intent + _str ) ; } }	ask the current default engine to launch the matching install_tts_data activity so the required tts files are properly installed .
public bitmap loadbitmap ( string uri , int reqwidth , int reqheight ) { bitmap bitmap = loadbitmapfrommemcache ( uri ) ; if ( bitmap != null ) { log . d ( tag , _str + uri ) ; return bitmap ; } try { bitmap = loadbitmapfromdiskcache ( uri , reqwidth , reqheight ) ; if ( bitmap != null ) { log . d ( tag , _str + uri ) ; return bitmap ; } bitmap = loadbitmapfromhttp ( uri , reqwidth , reqheight ) ; log . d ( tag , _str + uri ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } if ( bitmap == null && ! misdisklrucachecreated ) { log . w ( tag , _str ) ; bitmap = downloadbitmapfromurl ( uri ) ; } return bitmap ; }	load bitmap from memory cache or disk cache or network .
public boolean issafetoexecutesutcode ( ) { thread current = thread . currentthread ( ) ; if ( ! privilegedthreads . contains ( current ) ) { return _bool ; } else { return privilegedthreadtoignore == current ; } }	check if running sut code on current thread would be done inside the sandbox.
public void testcase17 ( ) { byte abytes [ ] = { _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num } ; byte rbytes [ ] = { _num , _num , _num , _num , _num , _num , _num } ; int asign = _num ; int bsign = _num ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . add ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	add a number to zero.
public string [ ] readdirectory ( string dir ) { if ( dir == null ) { throw new nullpointerexception ( _str ) ; } stringarrayout listout = new stringarrayout ( ) ; try { checkresult ( libimobiledevice . afc_read_directory ( getref ( ) , dir , listout ) ) ; stringarray list = listout . getvalue ( ) ; arraylist < string > result = new arraylist < string > ( ) ; if ( list != null ) { for ( int i = _num ; ; i ++ ) { string s = list . get ( i ) ; if ( s == null ) { break ; } result . add ( s ) ; } } return result . toarray ( new string [ result . size ( ) ] ) ; } finally { libimobiledevice . delete_stringarray_values_z ( listout . getvalue ( ) ) ; listout . delete ( ) ; } }	returns a directory listing of the specified directory .
public static string createargsstring ( list < string > args ) { if ( args == null ) { return _str ; } stringbuilder argssb = new stringbuilder ( ) ; for ( string arg : args ) { if ( ( arg . contains ( _str ) || arg . contains ( _str ) ) && ! stringutilities . isquoted ( arg ) ) { argssb . append ( stringutilities . quote ( arg ) ) ; } else { argssb . append ( arg ) ; } argssb . append ( _str ) ; } if ( argssb . length ( ) > _num ) { argssb . setlength ( argssb . length ( ) - _num ) ; } return argssb . tostring ( ) ; }	creates an argument string from the given list of arguments.
public void addelement ( int value ) { int indexrelativetocache = m_firstfree - m_buildcachestartindex ; if ( indexrelativetocache >= _num && indexrelativetocache < m_blocksize ) { m_buildcache [ indexrelativetocache ] = value ; ++ m_firstfree ; } else { int index = m_firstfree > > > m_shift ; int offset = m_firstfree & m_mask ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; int [ ] [ ] newmap = new int [ newsize ] [ ] ; system . arraycopy ( m_map , _num , newmap , _num , m_map . length ) ; m_map = newmap ; } int [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new int [ m_blocksize ] ; block [ offset ] = value ; m_buildcache = block ; m_buildcachestartindex = m_firstfree - offset ; ++ m_firstfree ; } }	append a int onto the vector .
public static < t > list < list < t > > overlap ( list < list < t > > lists , int before , int after ) { if ( before < _num ) { throw new illegalargumentexception ( _str ) ; } if ( after < _num ) { throw new illegalargumentexception ( _str ) ; } listiterator < list < t > > iter = lists . listiterator ( ) ; list < list < t > > result = new arraylist < list < t > > ( ) ; for ( ; iter . hasnext ( ) ; ) { list < t > current = new arraylist < t > ( iter . next ( ) ) ; list < t > prev = before > _num ? findprevious ( iter ) : null ; list < t > next = after > _num ? findnext ( iter ) : null ; if ( prev != null ) { list < t > overlap = prev . sublist ( prev . size ( ) - before , prev . size ( ) ) ; current . addall ( _num , overlap ) ; } if ( next != null ) { list < t > overlap = next . sublist ( _num , after ) ; current . addall ( overlap ) ; } result . add ( current ) ; } return result ; }	introduces overlap into a series of lists .
public double [ ] [ ] extractmainsetjacobian ( final odestate state ) { final double [ ] p = state . getsecondarystate ( index ) ; final double [ ] [ ] dydy0 = new double [ statedim ] [ statedim ] ; int j = _num ; for ( int i = _num ; i < statedim ; i ++ ) { system . arraycopy ( p , j , dydy0 [ i ] , _num , statedim ) ; j += statedim ; } return dydy0 ; }	extract the jacobian matrix with respect to state .
private void handlegetcandidateresult ( placementtask currentstate , operation postoperation , map < string , serveraddress > candidates , stopwatch placementwatch ) { serviceutils . loginfo ( this , _str , placementwatch . elapsed ( timeunit . milliseconds ) ) ; if ( candidates . isempty ( ) ) { string msg = string . format ( _str , currentstate . resource ) ; placementtask patchstate = buildpatch ( taskstate . taskstage . failed , currentstate . taskstate . isdirect , null ) ; patchstate . resultcode = placeresultcode . no_such_resource ; patchstate . error = msg ; failtask ( patchstate , new throwable ( msg ) , postoperation ) ; return ; } serviceutils . loginfo ( this , _str , candidates , currentstate . timeoutms ) ; stopwatch scorecandidatesstopwatch = stopwatch . createstarted ( ) ; queryhostsforscores ( currentstate . resource , candidates , null ) ; }	helper method to process the candidates returned by getpotentialcandidates .
public boolean contains ( jsonelement element ) { return elements . contains ( element ) ; }	returns true if this array contains the specified element .
private void appendpath ( path cp , final path p ) { if ( p != null && p . size ( ) > _num ) { cp . append ( p ) ; } }	append path to class path if the appened path is not empty and is not null.
public static void dodefaultlayout ( composite parent , dialogfield [ ] editors , boolean labelontop ) { dodefaultlayout ( parent , editors , labelontop , _num , _num ) ; }	creates a composite and fills in the given editors .
protected void parse ( datainputstream stream ) throws exception { value = stream . readutf ( ) ; }	loading method . ( see nbt_tag ).
public void removedrageventhandlers ( ) { node . removeeventhandler ( touchevent . any , touchhandler ) ; node . removeeventhandler ( mouseevent . any , mousehandler ) ; }	make the attached node stop acting on drag actions by removing drag event handlers.
protected void installlisteners ( ) { super . installlisteners ( ) ; table . addpropertychangelistener ( this ) ; }	attaches listeners to the jtable .
public void testcomparetozeropos ( ) { byte bbytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , _num , _num } ; int bsign = _num ; biginteger anumber = biginteger . zero ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; assertequals ( - _num , anumber . compareto ( bnumber ) ) ; }	compareto ( biginteger a ).
public void shutdown ( ) throws connectionmanagerexception { s_logger . info ( _str ) ; connectionlock . lock ( ) ; try { closeallconnections ( ) ; if ( _listener != null ) { _listener . stop ( ) ; _listener = null ; } executorservice . shutdown ( ) ; } catch ( exception e ) { throw new connectionmanagerexception ( _str , e ) ; } finally { connectionlock . unlock ( ) ; } }	shutdown the application . stops the listener ( which releases its tcp port ) .
private void closewriterexecutionservice ( executorservice service ) throws carbondatawriterexception { try { service . shutdown ( ) ; service . awaittermination ( _num , timeunit . days ) ; } catch ( interruptedexception e ) { logger . error ( e , e . getmessage ( ) ) ; throw new carbondatawriterexception ( e . getmessage ( ) ) ; } }	this method will close writer execution service and get the node holders and add them to node holder list.
public void removejob ( string jobid ) { if ( jobs . contains ( jobid ) ) { jobs . remove ( jobid ) ; } }	removes a job ' s id from the list of jobs in this group .
public string formattimemillis ( long ts ) { synchronized ( timeformatter ) { return timeformatter . format ( new date ( ts ) ) ; } }	formats an archive timestamp in way consistent with gemfire log dates.
protected static final int positioncoordinate2d ( float value ) { return ( int ) ( value + _num ) ; }	transform a floating - point 2d position coordinate to a screen coordinate.
@ override public object clone ( ) { try { identityhashmap < k , v > clonehashmap = ( identityhashmap < k , v > ) super . clone ( ) ; clonehashmap . elementdata = newelementarray ( elementdata . length ) ; system . arraycopy ( elementdata , _num , clonehashmap . elementdata , _num , elementdata . length ) ; return clonehashmap ; } catch ( clonenotsupportedexception e ) { throw new assertionerror ( e ) ; } }	returns a new identityhashmap with the same mappings and size as this one .
public int trap ( int [ ] a ) { if ( a == null || a . length == _num ) return _num ; int l = _num ; int r = a . length - _num ; int level = _num ; int all = _num ; int block = _num ; while ( l <= r ) { int curlevel = math . min ( a [ l ] , a [ r ] ) ; if ( curlevel > level ) { all += ( curlevel - level ) * ( r - l + _num ) ; level = curlevel ; } if ( a [ l ] < a [ r ] ) block += a [ l ++ ] ; else block += a [ r -- ] ; } return all - block ; }	calculate the area of all and blocks then return all - block to get the trapped water start from two sides if min of a [ l ] and a [ r ] is larger than current level update all and curlevel then move lower pointer towards center.
public void search ( ) { performsearch ( ) ; }	imitates a click on the search button to initiate a search .
public remotesession ( httpsession session ) { super ( ) ; debug = debug . getinstance ( _str ) ; this . session = ( httpsession ) session ; creationtime = session . getcreationtime ( ) ; id = session . getid ( ) ; lastaccessedtime = session . getlastaccessedtime ( ) ; maxinactiveinterval = session . getmaxinactiveinterval ( ) ; isnew = session . isnew ( ) ; internalattributes = new hashmap ( ) ; enumeration anames = getattributenames ( ) ; while ( anames . hasmoreelements ( ) ) { string attributename = ( string ) anames . nextelement ( ) ; if ( isserializable ( getattribute ( attributename ) ) && ! attributename . equals ( _str ) && ! attributename . equals ( _str ) ) { internalattributes . put ( attributename , getattribute ( attributename ) ) ; internalattributenames . add ( attributename ) ; debug . message ( _str + attributename + _str + getattribute ( attributename ) ) ; } } }	construct a new session facade.
@ override public snmpmibhandler addmib ( snmpmibagent mib ) throws illegalargumentexception { if ( mib == null ) { throw new illegalargumentexception ( ) ; } if ( ! mibs . contains ( mib ) ) mibs . addelement ( mib ) ; root . register ( mib ) ; return this ; }	adds a new mib in the snmp mib handler .
public boolean exist ( ) { return productionrun != null ; }	test if the productionrun exist .
public static sortclause create ( string item , string order ) { return new sortclause ( item , order . valueof ( order ) ) ; }	creates a sortclause based on item and order.
public long endtime ( ) { return gettimestamp ( ) + calculateduration ( ) ; }	this method returns the end time of the trace fragment .
protected void buildleavesmiddleout ( ballnode node ) throws exception { if ( node . m_left != null && node . m_right != null ) { buildleavesmiddleout ( node . m_left ) ; buildleavesmiddleout ( node . m_right ) ; } else if ( node . m_left != null || node . m_right != null ) { throw new exception ( _str ) ; } else { ballnode n2 = buildtreemiddleout ( node . m_start , node . m_end ) ; if ( n2 . m_left != null && n2 . m_right != null ) { node . m_left = n2 . m_left ; node . m_right = n2 . m_right ; buildleavesmiddleout ( node ) ; } else if ( n2 . m_left != null || n2 . m_right != null ) { throw new exception ( _str ) ; } } }	applies the middle out build procedure to the leaves of the tree.
@ deprecated public static int [ ] decodevalue ( string a ) { return tointarray ( a . split ( _str ) ) ; }	encode value . " 0 + 3 + 2 " - & gt ; [ 0 , 3 , 2 ] deprecated - use labelset or labelvector.
public weightvector ( weightvector wv ) { float in [ ] = wv . getinternalarray ( ) ; u = new float [ in . length ] ; system . arraycopy ( in , _num , u , _num , in . length ) ; size = in . length ; }	duplicate a weight vector.
public void waituntildone ( ) { countlock . lock ( ) ; try { equalcountcv . await ( ) ; } catch ( interruptedexception e ) { throw new runtimeexception ( _str ) ; } finally { countlock . unlock ( ) ; } }	wait for the number of finished jobs to equal to the number of submitted jobs .
public java . lang . stringbuilder insert ( int offset , long l ) { return insert ( offset , long . tostring ( l ) ) ; }	inserts the string representation of the long argument into this string buffer.
public projectionpreferencesdialog ( projector projector ) { this . projector = projector ; string tolerancetooltip = _str + _str ; jlabel tolerancelabel = new jlabel ( _str ) ; tolerance . settooltiptext ( tolerancetooltip ) ; tolerancelabel . settooltiptext ( tolerancetooltip ) ; mainpanel . additemlabel ( tolerancelabel , tolerance ) ; if ( projector . getprojectionmethod ( ) instanceof projectcoordinate ) { mainpanel . additem ( _str , autofind ) ; } fillfieldvalues ( ) ; setcontentpane ( mainpanel ) ; }	construct the preference dialog .
public void addtablevaluechangelistener ( tablevaluechangelistener listener ) { if ( listener == null ) { return ; } m_listeners . add ( listener ) ; }	add a listener for changes in the table ' s component values .
@ override public int print ( graphics g , pageformat pageformat , int pageindex ) { if ( pageindex > _num ) { return ( no_such_page ) ; } else { graphics2d g2d = ( graphics2d ) g ; g2d . translate ( pageformat . getimageablex ( ) , pageformat . getimageabley ( ) ) ; double fheight = pageformat . getimageableheight ( ) ; double fwidth = pageformat . getimageablewidth ( ) ; int xmax = _num ; int ymax = _num ; for ( int inode = _num ; inode < m_bayesnet . getnrofnodes ( ) ; inode ++ ) { if ( xmax < m_bayesnet . getpositionx ( inode ) ) { xmax = m_bayesnet . getpositionx ( inode ) ; } if ( ymax < m_bayesnet . getpositiony ( inode ) ) { ymax = m_bayesnet . getpositiony ( inode ) ; } } double fcurrentscale = m_fscale ; xmax += m_npaddednodewidth + _num ; if ( fwidth / xmax < fheight / ymax ) { m_fscale = fwidth / xmax ; } else { m_fscale = fheight / ymax ; } paint ( g2d ) ; m_fscale = fcurrentscale ; return ( page_exists ) ; } }	implementation of printable , used for printing.
public linkedhashmap < pokemon , nicknamepokemonresponse . result > bulkrenamewithpattern ( final string pattern , final biconsumer < nicknamepokemonresponse . result , pokemon > perpokecallback ) { final linkedhashmap < pokemon , nicknamepokemonresponse . result > results = new linkedhashmap < > ( ) ; mons . foreach ( null ) ; return results ; }	rename a bunch of pokemon based on a pattern.
public static assignment createdefault ( string ... variables ) { return createdefault ( arrays . aslist ( variables ) ) ; }	creates an assignment with only none values for the variable labels given as argument .
private void onstopattack ( ) { attacking = null ; }	called when this entity stops attacking .
void calculatepressed ( actionevent e ) { if ( checkeditconditional ( ) ) { return ; } if ( numconditionals > _num ) { string cname = _str ; conditional c = null ; for ( int i = _num ; i < numconditionals ; i ++ ) { cname = _curlogix . getconditionalbynumberorder ( i ) ; if ( cname != null ) { c = _conditionalmanager . getbysystemname ( cname ) ; if ( c == null ) { log . error ( _str + cname ) ; } else { c . calculate ( _bool , null ) ; } } else { log . error ( _str ) ; } } conditionaltablemodel . firetabledatachanged ( ) ; } }	responds to the calculate button in the edit logix window.
public static functionalias newinstance ( schema schema , int id , string name , string javaclassmethod , boolean force , boolean bufferresultsettolocaltemp ) { functionalias alias = new functionalias ( schema , id , name ) ; int paren = javaclassmethod . indexof ( _str ) ; int lastdot = javaclassmethod . lastindexof ( _str , paren < _num ? javaclassmethod . length ( ) : paren ) ; if ( lastdot < _num ) { throw dbexception . get ( errorcode . syntax_error_1 , javaclassmethod ) ; } alias . classname = javaclassmethod . substring ( _num , lastdot ) ; alias . methodname = javaclassmethod . substring ( lastdot + _num ) ; alias . bufferresultsettolocaltemp = bufferresultsettolocaltemp ; alias . init ( force ) ; return alias ; }	create a new alias based on a method name .
protected void updatemenu ( ) { boolean present ; boolean initializing ; boolean running ; boolean stopping ; boolean active ; if ( m_menubar == null ) return ; present = ( m_experiment != null ) ; initializing = present && m_experiment . isinitializing ( ) ; running = present && m_experiment . isrunning ( ) ; stopping = present && m_experiment . isstopping ( ) ; active = initializing || running || stopping ; m_menuitemfilenew . setenabled ( ! active ) ; m_menuitemfileopen . setenabled ( ! active ) ; m_menuitemfilesave . setenabled ( present && ( getcurrentfile ( ) != null ) ) ; m_menuitemfilesaveas . setenabled ( present ) ; m_menuitemfileclose . setenabled ( ! active ) ; m_menuitemexecutionstart . setenabled ( present && ! active ) ; m_menuitemexecutionstop . setenabled ( present && running ) ; for ( abstractexperimentermenuitem item : m_additionalmenuitems . keyset ( ) ) item . update ( this , m_additionalmenuitems . get ( item ) ) ; }	updates the enabled / disabled state of the menu items .
@ notnull @ objectivecname ( _str ) public configurationbuilder addautojoingroup ( string grouptokenorshortname ) { autojoingroups . add ( grouptokenorshortname ) ; return this ; }	adding group to auto join of users.
public boolean hasvalueinfo ( ) { return ! receivervalue . equals ( _str ) || methodargumentvalues != null ; }	returns true if there are computed values info on one of the method arguments .
protected void dropcar ( printwriter file , car car , boolean ismanifest ) { if ( ismanifest ) { stringbuffer buf = new stringbuffer ( padandtruncatestring ( setup . getdropcarprefix ( ) , setup . getmanifestprefixlength ( ) ) ) ; string [ ] format = setup . getdropmanifestmessageformat ( ) ; boolean islocal = islocalmove ( car ) ; if ( islocal ) { buf = new stringbuffer ( padandtruncatestring ( setup . getlocalprefix ( ) , setup . getmanifestprefixlength ( ) ) ) ; format = setup . getlocalmanifestmessageformat ( ) ; } dropcar ( file , car , buf , format , islocal , ismanifest ) ; } else { stringbuffer buf = new stringbuffer ( padandtruncatestring ( setup . getswitchlistdropcarprefix ( ) , setup . getswitchlistprefixlength ( ) ) ) ; string [ ] format = setup . getdropswitchlistmessageformat ( ) ; boolean islocal = islocalmove ( car ) ; if ( islocal ) { buf = new stringbuffer ( padandtruncatestring ( setup . getswitchlistlocalprefix ( ) , setup . getswitchlistprefixlength ( ) ) ) ; format = setup . getlocalswitchlistmessageformat ( ) ; } dropcar ( file , car , buf , format , islocal , ismanifest ) ; } }	adds the car ' s set out string to the output file using the manifest or switch list format.
@ aftermethod public void deletestorage ( ) throws businessexception , ioexception , serializationexception { if ( null != storagedata ) { if ( storagemanager . getrecordingstate ( ) == recordingstate . on ) { storagemanager . stoprecording ( ) ; } if ( ! storagemanager . isstorageclosed ( storagedata ) ) { storagemanager . closestorage ( storagedata ) ; } storagemanager . deletestorage ( storagedata ) ; storagedata = null ; } assertthat ( storagemanager . getexistingstorages ( ) , is ( empty ( ) ) ) ; }	after processing to delete storage that might be created in the test .
public final void removeelementat ( int i ) { if ( i > m_firstfree ) system . arraycopy ( m_map , i + _num , m_map , i , m_firstfree ) ; else m_map [ i ] = java . lang . integer . min_value ; m_firstfree -- ; }	deletes the component at the specified index.
protected int keyonlist ( string key , list < string > list ) { int ret = - _num ; int index = _num ; if ( list != null ) { for ( string listkey : list ) { if ( listkey . equalsignorecase ( key ) ) { ret = index ; break ; } index ++ ; } } return ret ; }	figure out if the string key is in the provided list , and provide the location index of it is .
private boolean incrementsentence ( ) throws ioexception { if ( length == _num ) return _bool ; while ( _bool ) { int start = iterator . current ( ) ; if ( start == breakiterator . done ) return _bool ; int end = iterator . next ( ) ; if ( end == breakiterator . done ) return _bool ; setnextsentence ( start , end ) ; if ( incrementword ( ) ) { return _bool ; } } }	return true if there is a token from the buffer , or null if it is exhausted .
enumeration < cryptopermissionentry > permissionelements ( ) { return permissionentries . elements ( ) ; }	enumerate all the permission entries in this grantentry .
private static void populateaccessrequest ( accessrequest accessrequest ) { accessrequest . setaccesslicensenumber ( props . getproperty ( license_number ) ) ; accessrequest . setuserid ( props . getproperty ( user_name ) ) ; accessrequest . setpassword ( props . getproperty ( password ) ) ; }	populates the access request object .
public binarytable ( header myheader ) throws fitsexception { long heapsizel = myheader . getlongvalue ( pcount ) ; long heapoffsetl = myheader . getlongvalue ( theap ) ; if ( heapoffsetl > max_integer_value ) { throw new fitsexception ( _str ) ; } if ( heapsizel > max_integer_value ) { throw new fitsexception ( _str ) ; } if ( heapsizel - heapoffsetl > max_integer_value ) { throw new fitsexception ( _str ) ; } this . heapoffset = ( int ) heapoffsetl ; int heapsize = ( int ) heapsizel ; int rwsz = myheader . getintvalue ( naxis1 ) ; this . nrow = myheader . getintvalue ( naxis2 ) ; if ( this . heapoffset > _num ) { this . heapoffset -= this . nrow * rwsz ; } if ( this . heapoffset < _num || this . heapoffset > heapsize ) { throw new fitsexception ( _str ) ; } this . heap = new fitsheap ( heapsize - this . heapoffset ) ; int ncol = myheader . getintvalue ( tfields ) ; this . rowlen = _num ; for ( int col = _num ; col < ncol ; col ++ ) { this . rowlen += processcol ( myheader , col ) ; } headercard card = myheader . findcard ( naxis1 ) ; card . setvalue ( string . valueof ( this . rowlen ) ) ; myheader . updateline ( naxis1 , card ) ; }	create a binary table from given header information .
public static taskcontext current ( ) { final deque < taskcontext > stack = contextstacks . get ( ) ; if ( stack == null ) { return null ; } return stack . peeklast ( ) ; }	gets the current execution context for this thread from the stack .
public static byte [ ] concat ( final byte [ ] ... arrays ) { int totalsize = _num ; for ( final byte [ ] array : arrays ) { totalsize += array . length ; } int startindex = _num ; final byte [ ] result = new byte [ totalsize ] ; for ( final byte [ ] array : arrays ) { system . arraycopy ( array , _num , result , startindex , array . length ) ; startindex += array . length ; } return result ; }	concatenates byte arrays and returns the result .
public jknamespace ( final string url , final string prefix ) { logger . info ( string . format ( _str , url , prefix ) ) ; this . url = url ; this . prefix = prefix ; }	instantiates a new jk namespace .
public boolean islifo ( ) { string cm = getcostingmethod ( ) ; return cm != null && cm . equals ( costingmethod_lifo ) && costelementtype_material . equals ( getcostelementtype ( ) ) ; }	is lifo costing method.
public static void main ( string [ ] args ) throws exception { final string cfg = _str ; final class < ? extends benchmarkdriver > benchmark = ignitesqlquerybenchmark . class ; final int threads = _num ; final boolean clientdrivernode = _bool ; final int extranodes = _num ; final int warmup = _num ; final int duration = _num ; final int range = _num ; final boolean throughputlatencyprobe = _bool ; for ( int i = _num ; i < extranodes ; i ++ ) { igniteconfiguration nodecfg = ignition . loadspringbean ( cfg , _str ) ; nodecfg . setgridname ( _str + i ) ; nodecfg . setmetricslogfrequency ( _num ) ; ignition . start ( nodecfg ) ; } arraylist < string > args0 = new arraylist < > ( ) ; addarg ( args0 , _str , threads ) ; addarg ( args0 , _str , warmup ) ; addarg ( args0 , _str , duration ) ; addarg ( args0 , _str , range ) ; addarg ( args0 , _str , benchmark . getsimplename ( ) ) ; addarg ( args0 , _str , _str ) ; addarg ( args0 , _str , cfg ) ; if ( throughputlatencyprobe ) addarg ( args0 , _str , _str ) ; if ( clientdrivernode ) args0 . add ( _str ) ; benchmarkdriverstartup . main ( args0 . toarray ( new string [ args0 . size ( ) ] ) ) ; }	starts nodes / driver in single jvm for quick benchmarks testing .
public static boolean safenavigationoperatordefined ( string nestedfieldname ) { if ( nestedfieldname . contains ( safe_navigation_operator ) ) if ( ! nestedfieldname . startswith ( safe_navigation_operator ) ) throw new mappingexception ( _str ) ; else return _bool ; return _bool ; }	it checks the presence of the elvis operator and how it is used .
public static boolean isenabled ( ) { if ( senabled == null ) { senabled = detectenabled ( ) ; } return senabled . booleanvalue ( ) ; }	checks the current variations parameters associated with the active group as well as the chrome preference to determine if the service is enabled .
public boolean intersects ( geobounds other ) { boolean rv = _bool ; for ( rectangle2d r1 : rects ) { for ( rectangle2d r2 : other . rects ) { rv = r1 . intersects ( r2 ) ; if ( rv ) { break ; } } if ( rv ) { break ; } } return rv ; }	determines if this bounds intersects the other bounds .
public void dispose ( ) { mlisteners . clear ( ) ; }	clear listeners to prepare for garbage collection.
public void openimagegallery ( final actionlistener response ) { opengallery ( response , display . gallery_image ) ; }	opens the device image gallery.
private void readobject ( final java . io . objectinputstream in ) throws ioexception , classnotfoundexception { inequalitysymbol = ( string ) in . readobject ( ) ; timestamp = in . readlong ( ) ; }	deserialize the state of the object .
string popbaseindentifier ( ) { return ( string ) m_baseidentifiers . pop ( ) ; }	pop a base uri from the stack .
@ nullable public static file resolvedrawable ( @ notnull renderresources resources , @ nullable resourcevalue drawable , @ notnull project project ) { if ( drawable != null ) { drawable = resources . resolveresvalue ( drawable ) ; } if ( drawable == null ) { return null ; } string result = drawable . getvalue ( ) ; statelist statelist = resolvestatelist ( resources , drawable , project ) ; if ( statelist != null ) { list < stateliststate > states = statelist . getstates ( ) ; if ( ! states . isempty ( ) ) { stateliststate state = states . get ( states . size ( ) - _num ) ; result = state . getvalue ( ) ; } } if ( result == null ) { return null ; } final file file = new file ( result ) ; return file . isfile ( ) ? file : null ; }	tries to resolve the given resource value to an actual drawable bitmap file.
public static void delete ( string code , jda jda ) { invite invite = resolve ( code ) ; if ( invite == null ) throw new illegalargumentexception ( _str + _str + code ) ; delete ( invite , jda ) ; }	tells discord to delete the specified invite from the server.
private void updateheaderseparator ( ) { final string bestdatetimepattern = dateformatutils . getbestdatetimepattern ( mcurrentlocale , ( mis24hourview ) ? _str : _str ) ; final string separatortext ; final char [ ] hourformats = { _str , _str , _str , _str } ; int hindex = lastindexofany ( bestdatetimepattern , hourformats ) ; if ( hindex == - _num ) { separatortext = _str ; } else { separatortext = character . tostring ( bestdatetimepattern . charat ( hindex + _num ) ) ; } mseparatorview . settext ( separatortext ) ; }	the time separator is defined in the unicode cldr and cannot be supposed to be " : ".
protected void connectionfailed ( channel failedchannel , ioexception cause ) { failurecause = ioexceptionsupport . create ( cause ) ; channel = failedchannel ; connected . set ( _bool ) ; connectlatch . countdown ( ) ; }	called when the transport connection failed and an error should be returned .
public void testmissingapplication ( ) throws exception { menabled . add ( launcheractivitydetector . issue_more_than_one_launcher ) ; menabled . add ( launcheractivitydetector . issue_missing_launcher ) ; menabled . add ( launcheractivitydetector . issue_launcher_activity_in_library ) ; string expected = _str ; string result = lintproject ( xml ( fn_android_manifest_xml , _str + _str + _str + _str + _str ) ) ; assertequals ( expected , result ) ; }	test that a manifest without an application tag has no warnings .
public string tostring ( ) { arraylist fields = new arraylist ( _num ) ; fields . add ( codebase ) ; fields . add ( policy ) ; fields . add ( classpath ) ; fields . add ( implclassname ) ; fields . add ( ( ( serverconfigargs == null ) ? null : arrays . aslist ( serverconfigargs ) ) ) ; fields . add ( lifecycle ) ; fields . add ( servicepreparer ) ; return fields . tostring ( ) ; }	prints out a field summary.
public drawable createfrompath ( string pathname ) { return drawable . createfrompath ( pathname ) ; }	create a drawable from file path name .
@ override public void parse ( reader reader , string baseuri ) throws ioexception , rdfparseexception , rdfhandlerexception { if ( reader == null ) { throw new illegalargumentexception ( _str ) ; } if ( baseuri == null ) { throw new illegalargumentexception ( _str ) ; } inputsource inputsource = new inputsource ( reader ) ; inputsource . setsystemid ( baseuri ) ; parse ( inputsource ) ; }	parses the data from the supplied reader , using the supplied baseuri to resolve any relative uri references .
final public void print ( double v ) { try { _out . print ( v ) ; } catch ( ioexception e ) { log . log ( level . fine , e . tostring ( ) , e ) ; } }	prints a double followed by a newline .
public static boolean isempty ( string string ) { return string == null || string . length ( ) == _num ; }	returns true if the string is null or empty .
public static boolean isxml11validname ( string name ) { int length = name . length ( ) ; if ( length == _num ) return _bool ; int i = _num ; char ch = name . charat ( _num ) ; if ( ! isxml11namestart ( ch ) ) { if ( length > _num && isxml11namehighsurrogate ( ch ) ) { char ch2 = name . charat ( _num ) ; if ( ! xmlchar . islowsurrogate ( ch2 ) || ! isxml11namestart ( xmlchar . supplemental ( ch , ch2 ) ) ) { return _bool ; } i = _num ; } else { return _bool ; } } while ( i < length ) { ch = name . charat ( i ) ; if ( ! isxml11name ( ch ) ) { if ( ++ i < length && isxml11namehighsurrogate ( ch ) ) { char ch2 = name . charat ( i ) ; if ( ! xmlchar . islowsurrogate ( ch2 ) || ! isxml11name ( xmlchar . supplemental ( ch , ch2 ) ) ) { return _bool ; } } else { return _bool ; } } ++ i ; } return _bool ; }	check to see if a string is a valid name according to [ 5 ] in the xml 1 . 1 recommendation.
public void reset ( ) { mexpectedevents . clear ( ) ; mexpectedinterrupt = _bool ; mreplaying = _bool ; }	resets this instance so it can be reused .
string generatedigest ( file filedir , string filename ) { final string algorithm = _str ; inputstream filestream = null ; digestinputstream d = null ; try { filestream = getfilestream ( filedir , filename ) ; messagedigest md = messagedigest . getinstance ( algorithm ) ; d = new digestinputstream ( filestream , md ) ; byte [ ] buffer = new byte [ _num ] ; while ( d . read ( buffer ) != - _num ) { } return tohexstring ( md . digest ( ) ) ; } catch ( nosuchalgorithmexception e ) { return algorithm + _str ; } catch ( ioexception e ) { clog . e ( e ) ; } finally { streamutil . closestream ( d ) ; streamutil . closestream ( filestream ) ; } return _str ; }	generate a sha1sum digest for a file.
private void initializenamegoals ( map < testcase , set < testfitnessfunction > > testtogoals ) { for ( map . entry < testcase , set < testfitnessfunction > > entry : testtogoals . entryset ( ) ) { set < testfitnessfunction > goals = new linkedhashset < > ( ) ; list < testfitnessfunction > topgoals = gettopgoals ( entry . getvalue ( ) ) ; if ( topgoals . isempty ( ) ) { } else if ( topgoals . size ( ) <= max_similar_goals ) { for ( testfitnessfunction goal : topgoals ) { goals . add ( goal ) ; string goalname = gettestname ( entry . getkey ( ) , goals ) ; if ( goalname . length ( ) > max_chars ) { goals . remove ( goal ) ; break ; } } } else { goals . add ( chooserepresentativegoal ( entry . getkey ( ) , topgoals ) ) ; } testtogoals . put ( entry . getkey ( ) , goals ) ; } }	initially , set to the top level goals.
public boolean isparserobotstxt ( ) { return parserobotstxt ; }	checks if the spider should parse the robots.
public string bytearraytobase64 ( byte [ ] bytes ) { return base64 . encodebase64string ( bytes ) ; }	get a byte array ' s base64 endcoding.
private void validateindexstorage ( ) { closeableiterator < indexstoreentry > iterator = null ; try { arraylist structurelist = new arraylist ( ) ; iterator = indexdatastructure . iterator ( null ) ; while ( iterator . hasnext ( ) ) { indexstoreentry ie = iterator . next ( ) ; if ( entriescontains ( ie ) ) { structurelist . add ( ie ) ; } else { fail ( _str + ie ) ; } } assertequals ( _str , entries . size ( ) , structurelist . size ( ) ) ; } finally { if ( iterator != null ) { iterator . close ( ) ; } } }	iterates through the index storage structure and compares size with the test list.
private int quantize ( long x ) { return _num + ( int ) math . floor ( math . log ( x ) / math . log ( quantizationbase ) ) ; }	logarithmically quantizes raw counts.
public static boolean validateoutputdirectory ( file directory ) { if ( directory . exists ( ) ) { diagnostic . error ( errortype . directory_exists , directory . getpath ( ) ) ; return _bool ; } return _bool ; }	test if the supplied directory already exists .
@ override public void onwebsocketclose ( int statuscode , string reason ) { super . onwebsocketclose ( statuscode , reason ) ; log . info ( _str , peerid , integer . tostring ( statuscode ) + _str + reason ) ; store . unsubscribe ( handle ) ; }	called by jetty when the websocket connection is gracefully closed due to a ' close ' event .
@ override public double logdensity ( double value ) { updateboundariesandorweights ( ) ; if ( m_boundaries == null ) { return math . log ( double . min_value ) ; } int index = arrays . binarysearch ( m_boundaries , value ) ; if ( ( index == - _num ) || ( index == - m_boundaries . length - _num ) ) { double val = _num ; if ( index == - _num ) { val = m_tm . firstkey ( ) - value ; } else { val = value - m_tm . lastkey ( ) ; } return ( const - math . log ( m_width ) - _num * ( val * val / ( m_width * m_width ) ) ) - math . log ( m_sumofweights + _num ) ; } if ( index == m_boundaries . length - _num ) { index -- ; } else { if ( index < _num ) { index = - index - _num ; } } double width = m_boundaries [ index + _num ] - m_boundaries [ index ] ; double denssmearedout = _num / ( ( m_sumofweights + _num ) * ( m_boundaries [ m_boundaries . length - _num ] - m_boundaries [ _num ] ) ) ; if ( m_weights [ index ] <= _num ) { return math . log ( denssmearedout ) ; } else { return math . log ( denssmearedout + m_weights [ index ] / ( ( m_sumofweights + _num ) * width ) ) ; } }	returns the natural logarithm of the density estimate at the given point .
public void drawpoint ( graphics sc , ipoint p ) { double x1 = p . getx ( ) ; double y1 = p . gety ( ) ; sc . drawoval ( ( int ) x1 - _num , ( int ) y1 - _num , _num , _num ) ; }	core functionality to draw a point in the canvas .
private static int computecapacity ( final int expectedsize ) { if ( expectedsize == _num ) { return _num ; } final int capacity = ( int ) fastmath . ceil ( expectedsize / load_factor ) ; final int poweroftwo = integer . highestonebit ( capacity ) ; if ( poweroftwo == capacity ) { return capacity ; } return nextpoweroftwo ( capacity ) ; }	compute the capacity needed for a given size .
public void addcallback ( callback callback ) { if ( ! mcallbacks . contains ( callback ) ) { mcallbacks . add ( callback ) ; } }	add a callback to our alexaaudioplayer , this is added to our list of callbacks.
public jtidydocumentbuilderfactory ( documentbuildersetting [ ] settings ) throws domtestincompatibleexception { super ( settings ) ; try { classloader classloader = classloader . getsystemclassloader ( ) ; class tidyclass = classloader . loadclass ( _str ) ; tidyconstructor = tidyclass . getconstructor ( no_classes ) ; parsedommethod = tidyclass . getmethod ( _str , new class [ ] { java . io . inputstream . class , java . io . outputstream . class } ) ; domimpl = new jtidydomimplementation ( ) ; } catch ( exception ex ) { throw new domtestincompatibleexception ( ex , null ) ; } if ( settings != null ) { for ( int i = _num ; i < settings . length ; i ++ ) { } } }	creates a implementation of domtestdocumentbuilderfactory using jtidy ' s html parser and dom implementation.
public void enqueue ( terminatingrunnable r ) { synchronized ( queue ) { queue . add ( r ) ; queue . notifyall ( ) ; } }	add an object to the queue of threads to run.
protected void doprocessmessage ( dtlsmessage message ) throws handshakeexception , generalsecurityexception { }	does the specific processing of a message received from a peer in the course of an ongoing handshake.
void disconnect ( ) { synchronized ( lock ) { disconnected = _bool ; lock . notifyall ( ) ; } }	disconnect this stream from all connection activity .
public simpleratelimiter ( double mbpersec ) { setmbpersec ( mbpersec ) ; lastns = system . nanotime ( ) ; }	mbpersec is the mb / sec max io rate.
private long wc ( string text ) { long wc = _num ; string [ ] lines = text . split ( _str ) ; for ( string line : lines ) { wc += line . split ( _str ) . length ; } return wc ; }	count the words of a text file .
public boolean unbind ( ) { boolean worked = _bool ; if ( m_rxthread == null ) worked = _bool ; else m_stoprx = _bool ; return worked ; }	shutdown our receive thread.
public void register ( schedule schedule ) { integer oldsize = integer . valueof ( _schedulehashtable . size ( ) ) ; _schedulehashtable . put ( schedule . getid ( ) , schedule ) ; int id = integer . parseint ( schedule . getid ( ) ) ; if ( id > _id ) { _id = id ; } setdirtyandfirepropertychange ( listlength_changed_property , oldsize , integer . valueof ( _schedulehashtable . size ( ) ) ) ; }	remember a namedbean object created outside the manager .
public final void writemapleasciistring ( final string s ) { writeshort ( ( short ) s . length ( ) ) ; writeasciistring ( s ) ; }	writes a maple - convention ascii string to the stream .
public static boolean hasuid ( string classname ) { boolean result ; try { result = hasuid ( class . forname ( classname ) ) ; } catch ( exception e ) { result = _bool ; } return result ; }	checks whether the given class contains a serialversionuid .
public static boolean removedirectory ( string pathtodir ) { return deleterecursive ( new file ( pathtodir ) ) ; }	remove directory and all its sub - resources with specified path.
public static final boolean validategroupname ( string sgroupname ) { if ( sgroupname . length ( ) == _num ) { return _bool ; } return sgroupname . matches ( _str ) ; }	validates a duplex group name.
private void _init ( configuration conf ) { try { if ( this . id > _num ) { defaultlistener d = new defaultlistener ( ) ; d . upgrade ( conf , this ) ; } if ( ! x . isempty ( listener ) ) { string name = listener ; if ( name != null ) { try { class < ? > c = class . forname ( name , _bool , classloader ) ; object o = c . newinstance ( ) ; if ( o instanceof ilistener ) { log . info ( _str + name ) ; ilistener l = ( ilistener ) o ; l . upgrade ( conf , this ) ; l . onstart ( conf , this ) ; } } catch ( throwable e ) { log . error ( this . name + _str + name , e ) ; } } } } catch ( throwable e ) { log . error ( e . getmessage ( ) , e ) ; } }	invoke the life listener of the module.
private boolean isscanrootavailable ( url url ) { for ( scanroot scanroot : _pendingscanroots ) { if ( url . equals ( scanroot . geturl ( ) ) ) return _bool ; } return _bool ; }	adds a scan listener .
public sequentiallistenermanager addlistenerexecutor ( int index , listener listener , listenerexecutor executor ) { if ( listeners . contains ( listener ) ) throw new illegalargumentexception ( _str + listener ) ; listeners . add ( index , listener ) ; listenerexecutors . add ( index , executor ) ; return this ; }	add a listener at the given index to be executed by the supplied executor.
private boolean hasasparent ( inode child , icompositenode directparent ) { inode parent = child ; while ( parent != null ) { if ( parent == directparent ) return _bool ; parent = parent . getparent ( ) ; } return _bool ; }	test if directparent is in parent - chain .
public void clearmarkers ( ) { mgooglemap . clear ( ) ; markers . clear ( ) ; }	clears all markers from the map .
@ override public double cloudletsubmit ( cloudlet cl ) { return cloudletsubmit ( cl , _num ) ; }	receives an cloudlet to be executed in the vm managed by this scheduler .
public void verifyingtoken ( ) { settokeninfo ( _str ) ; verifytoken . setenabled ( _bool ) ; }	change status to verifying token .
public certificate buildcertificate ( string certstring ) throws invalidcertificate { try { string base64cert = formatcertificate ( certstring ) ; inputstream inbytes = new bytearrayinputstream ( base64cert . getbytes ( ) ) ; certificatefactory cf = certificatefactory . getinstance ( _str ) ; assert inbytes . available ( ) > _num ; certificate certificate = cf . generatecertificate ( inbytes ) ; inbytes . close ( ) ; return certificate ; } catch ( exception e ) { log . debug ( _str + e + _str ) ; throw faultutil . invalidcertificate ( _str ) ; } }	buildcertificate build a certificate from a base64 formatted , pkcs # 7 encoding of the certificate.
private pageleafimpl compact ( tablekelp table ) { long now = currenttime . currenttime ( ) / _num ; set < pageleafentry > entries = fillentries ( table ) ; arraylist < blockleaf > blocks = new arraylist < > ( ) ; blockleaf block = new blockleaf ( getid ( ) ) ; blocks . add ( block ) ; row row = table . row ( ) ; for ( pageleafentry entry : entries ) { if ( entry . getcode ( ) != insert && entry . getexpires ( ) <= now ) { continue ; } while ( ! block . addentry ( row , entry ) ) { block = new blockleaf ( getid ( ) ) ; blocks . add ( block ) ; } } pageleafimpl newpage = new pageleafimpl ( getid ( ) , getnextid ( ) , getsequence ( ) , _table , getminkey ( ) , getmaxkey ( ) , blocks ) ; newpage . validate ( table ) ; newpage . tosorted ( table ) ; if ( isdirty ( ) ) { newpage . setdirty ( ) ; } if ( _stub != null ) { _stub . copytocompact ( newpage ) ; } return newpage ; }	compacts the leaf by rebuilding the delta entries and discarding obsolete removed entries .
public sabresquery ( class < t > clazz ) { this . clazz = clazz ; name = clazz . getsimplename ( ) ; innerqueries = null ; }	constructs a query for a sabresobject subclass type.
public string backupnow ( string backupfileprefix ) throws mcexception , ioexception { _logger . debug ( _str ) ; return backup . backup ( backupfileprefix ) ; }	call this method to run immediate system backup.
public boolean isclusteredhost ( storagesystem storage , list < initiator > initiators ) { return isclusteredhost ( storage , initiators , null ) ; }	validates if the host is part of a cluster on xiv system . uses initiators to find out the hosts.
public static list < substringreplacermatchrule > matchrulesfrominternal ( string matchreplacedetails , instances inputstructure , string statusmessageprefix , logger log , environment env ) { list < substringreplacermatchrule > matchrules = new arraylist < substringreplacermatchrule > ( ) ; string [ ] mrparts = matchreplacedetails . split ( _str ) ; for ( string p : mrparts ) { substringreplacermatchrule mr = new substringreplacermatchrule ( p . trim ( ) ) ; mr . m_statusmessageprefix = statusmessageprefix ; mr . m_logger = log ; mr . init ( env , inputstructure ) ; matchrules . add ( mr ) ; } return matchrules ; }	get a list of match rules from an internally encoded match specification.
public static object [ ] mergeandextractparams ( map < string , ? extends object > globalconfig , map < string , ? extends object > localparams , collection < string > ignoreparams , map < string , externalresourcedescription > resources ) { set < string > uniqueparams = new hashset < > ( ) ; uniqueparams . addall ( localparams . keyset ( ) ) ; uniqueparams . addall ( globalconfig . keyset ( ) ) ; if ( ignoreparams != null ) { uniqueparams . removeall ( ignoreparams ) ; } object [ ] params = new object [ resources . size ( ) * _num + uniqueparams . size ( ) * _num ] ; int i = _num ; for ( entry < string , externalresourcedescription > entry : resources . entryset ( ) ) { params [ i ++ ] = entry . getkey ( ) ; params [ i ++ ] = entry . getvalue ( ) ; } for ( string key : uniqueparams ) { params [ i ++ ] = key ; if ( localparams . containskey ( key ) ) { params [ i ++ ] = cpebuilderutils . converttoparametervalue ( localparams . get ( key ) ) ; } else { params [ i ++ ] = cpebuilderutils . converttoparametervalue ( globalconfig . get ( key ) ) ; } } return params ; }	merges local parameters and resources with global parameters , with local parameters taking precedence over global parameters where there is a conflict.
public void storeproperties ( string artifact , string version , properties props ) throws ioexception { path propertiesfile = getpropertiesfile ( artifact , version ) ; path dir = propertiesfile . getparent ( ) ; if ( ! files . exists ( dir ) ) { files . createdirectories ( dir ) ; } try ( outputstream out = new bufferedoutputstream ( newoutputstream ( propertiesfile ) ) ) { props . store ( out , null ) ; } }	stores the properties of the artifact .
public static string makedescriptor ( class [ ] params , class rettype ) { stringbuffer sbuf = new stringbuffer ( ) ; sbuf . append ( _str ) ; for ( int i = _num ; i < params . length ; i ++ ) makedesc ( sbuf , params [ i ] ) ; sbuf . append ( _str ) ; if ( rettype != null ) makedesc ( sbuf , rettype ) ; return sbuf . tostring ( ) ; }	makes a descriptor for a given method .
public boolean isloggable ( level lev ) { return logger . isloggable ( lev ) ; }	verify if logging is enabled at that particular level .
@ override public boolean supportsknowledge ( ) { return _bool ; }	by default , algorithm do not support knowledge.
@ dataprovider public object [ ] [ ] invalididprovider ( ) { return new object [ ] [ ] { new object [ ] { _str , _str , httpstatus . sc_not_found } , new object [ ] { _str , _str , httpstatus . sc_not_found } , new object [ ] { _str , _str , httpstatus . sc_internal_server_error } , new object [ ] { _str , _str , httpstatus . sc_internal_server_error } , new object [ ] { _str , _str , httpstatus . sc_internal_server_error } } ; }	provides invalid ids and their expected results .
public final static headerelement parseheaderelement ( final string value , headervalueparser parser ) throws parseexception { if ( value == null ) { throw new illegalargumentexception ( _str ) ; } if ( parser == null ) parser = basicheadervalueparser . default ; chararraybuffer buffer = new chararraybuffer ( value . length ( ) ) ; buffer . append ( value ) ; parsercursor cursor = new parsercursor ( _num , value . length ( ) ) ; return parser . parseheaderelement ( buffer , cursor ) ; }	parses an element with the given parser .
private void clearstate ( ) { allocatedresources . clear ( ) ; requeststocountmap . clear ( ) ; requestsqueue . clear ( ) ; }	clears all the state variables performed when there are no more unfulfilled requests.
public static double [ ] vectorboxcorner ( double [ ] center , double [ ] result , double distance , boolean upperright ) { if ( result == null || result . length != center . length ) { result = new double [ center . length ] ; } if ( upperright == _bool ) { distance = - distance ; } distance = sin_pi_div_4 * distance ; for ( int i = _num ; i < center . length ; i ++ ) { result [ i ] = center [ i ] + distance ; } return result ; }	return the coordinates of a vector that is the corner of a box ( upper right or lower left ) , assuming a rectangular coordinate system.
public void toarray ( int [ ] array ) { system . arraycopy ( data , _num , array , _num , size ) ; }	convert this list to an array.
public fixedsecurerandom ( boolean intpad , byte [ ] [ ] values ) { bytearrayoutputstream bout = new bytearrayoutputstream ( ) ; for ( int i = _num ; i != values . length ; i ++ ) { try { bout . write ( values [ i ] ) ; } catch ( ioexception e ) { throw new illegalargumentexception ( _str ) ; } } _data = bout . tobytearray ( ) ; if ( intpad ) { _intpad = _data . length % _num ; } }	pad the data on integer boundaries.
@ override protected void ensurenumberofcolumns ( int numberofcolumns ) { if ( data . length >= numberofcolumns ) { return ; } long [ ] newdata = new long [ numberofcolumns ] ; system . arraycopy ( data , _num , newdata , _num , data . length ) ; data = newdata ; }	creates a new array of the given size if necessary and copies the data into the new array .
public void invokehookspoutack ( object messageid , long completelatencyns ) { if ( taskhooks . size ( ) != _num ) { spoutackinfo ackinfo = new spoutackinfo ( messageid , getthistaskid ( ) , completelatencyns / constants . milliseconds_to_nanoseconds ) ; for ( itaskhook taskhook : taskhooks ) { taskhook . spoutack ( ackinfo ) ; } } }	task hook called in spout every time a tuple gets acked.
stubskeletonwriter ( batchenvironment env , remoteclass remoteclass , stubversion version ) { this . env = env ; this . remoteclass = remoteclass ; this . version = version ; stubclassname = util . binarynameof ( remoteclass . classdoc ( ) ) + _str ; skeletonclassname = util . binarynameof ( remoteclass . classdoc ( ) ) + _str ; int i = stubclassname . lastindexof ( _str ) ; packagename = ( i != - _num ? stubclassname . substring ( _num , i ) : _str ) ; stubclasssimplename = stubclassname . substring ( i + _num ) ; skeletonclasssimplename = skeletonclassname . substring ( i + _num ) ; remotemethods = remoteclass . remotemethods ( ) ; methodfieldnames = namemethodfields ( remotemethods ) ; }	creates a stubskeletonwriter instance for the specified remote implementation class.
public void put ( string key , object value , boolean erroronfail ) { if ( value == null ) { putnull ( key ) ; } else if ( value instanceof boolean ) { put ( key , ( boolean ) value ) ; } else if ( value instanceof byte ) { put ( key , ( byte ) value ) ; } else if ( value instanceof double ) { put ( key , ( double ) value ) ; } else if ( value instanceof float ) { put ( key , ( float ) value ) ; } else if ( value instanceof integer ) { put ( key , ( integer ) value ) ; } else if ( value instanceof long ) { put ( key , ( long ) value ) ; } else if ( value instanceof short ) { put ( key , ( short ) value ) ; } else if ( value instanceof string ) { put ( key , ( string ) value ) ; } else if ( value instanceof byte [ ] ) { put ( key , ( byte [ ] ) value ) ; } else if ( erroronfail ) { throw new unsupportedoperationexception ( _str + value . getclass ( ) ) ; } }	add a value of unknown type to the set if it is one of the accepted types.
private void step ( ) { casings . foreach ( null ) ; casings . foreach ( null ) ; casings . foreach ( null ) ; steppipes ( ) ; stepforwarders ( ) ; }	advance all computer parts by one step .
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return host ; case _num : return port ; case _num : return id ; case _num : return state ; case _num : return timestamp ; case _num : return version ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
private static doublematrix2d xdistanceold ( doublematrix2d matrix , int norm ) { return null ; }	constructs and returns the distance matrix of the given matrix.
public map < string , string > map ( ) { return hashmap ( ) ; }	returns a shallow copy of the underlying map as a generic map .
private static void addqueryfields ( document doc , node parent , collection < pojofield > fields ) { if ( ! fields . isempty ( ) ) { element prop = addproperty ( doc , parent , _str , null ) ; element map = addelement ( doc , prop , _str , _str , _str ) ; for ( pojofield field : fields ) addelement ( doc , map , _str , _str , field . javaname ( ) , _str , generatorutils . boxprimitivetype ( field . javatypename ( ) ) ) ; } }	add query fields to xml document .
public void testsimplevalidstring ( ) throws exception { jsonfactory jsonf = new jsonfactory ( ) ; dataformatdetector detector = new dataformatdetector ( jsonf ) ; final string json = _str ; dataformatmatcher matcher = detector . findformat ( new bytearrayinputstream ( json . getbytes ( _str ) ) ) ; asserttrue ( matcher . hasmatch ( ) ) ; assertequals ( _str , matcher . getmatchedformatname ( ) ) ; assertsame ( jsonf , matcher . getmatch ( ) ) ; assertequals ( matchstrength . weak_match , matcher . getmatchstrength ( ) ) ; jsonparser jp = matcher . createparserwithmatch ( ) ; asserttoken ( jsontoken . value_string , jp . nexttoken ( ) ) ; assertequals ( _str , jp . gettext ( ) ) ; assertnull ( jp . nexttoken ( ) ) ; jp . close ( ) ; }	while json string is not a strong match alone , it should be detected unless some better match is available.
protected boolean dostart ( ) { if ( ! _lifecycle . isactive ( ) ) { return _bool ; } if ( ! isenable ( ) ) { return _bool ; } int startingcount = _startingcount . getandincrement ( ) ; int threadcount = _threadcount . get ( ) + startingcount ; if ( _threadmax < threadcount ) { _startingcount . decrementandget ( ) ; onthreadmax ( ) ; return _bool ; } else if ( isidletoolow ( startingcount ) ) { return _bool ; } else { _startingcount . decrementandget ( ) ; return _bool ; } }	checks if the launcher should start another thread .
@ override public string globalinfo ( ) { return _str + _str ; }	global info for this bean.
public static long streamskip ( inputstream stream , long count ) throws ioexception { long skipped = stream . skip ( count ) ; if ( skipped < _num ) { final byte [ ] temp = new byte [ _num ] ; skipped = stream . read ( temp , _num , math . min ( ( int ) count , _num ) ) ; } return skipped ; }	a wrapper for stream . skip that is guaranteed to skip at least 1 byte when called.
public boolean managedobjectexists ( managedobjectpath < ? , ? > path ) { dn targetdn = dnbuilder . create ( path ) ; try { return configrepository . getentry ( targetdn ) != null ; } catch ( configexception e ) { return _bool ; } }	determines whether the named managed object exists .
public vector2 rotate ( double theta ) { double cos = math . cos ( theta ) ; double sin = math . sin ( theta ) ; double x = this . x ; double y = this . y ; this . x = x * cos - y * sin ; this . y = x * sin + y * cos ; return this ; }	rotates about the origin .
public void removepermission ( permissiontype permission ) { removedpermissions . add ( permission ) ; }	queues the given permission to be removed.
static void exportprefs ( preferences prefs , outputstream stream , boolean withsubtree ) throws ioexception , backingstoreexception { indent = - _num ; bufferedwriter out = new bufferedwriter ( new outputstreamwriter ( stream , _str ) ) ; out . write ( header ) ; out . newline ( ) ; out . newline ( ) ; out . write ( doctype ) ; out . write ( _str ) ; out . write ( prefs_dtd_name ) ; out . write ( _str ) ; out . newline ( ) ; out . newline ( ) ; flushstarttag ( _str , new string [ ] { _str } , new string [ ] { string . valueof ( xml_version ) } , out ) ; flushstarttag ( _str , new string [ ] { _str } , new string [ ] { prefs . isusernode ( ) ? _str : _str } , out ) ; flushemptyelement ( _str , out ) ; stringtokenizer ancestors = new stringtokenizer ( prefs . absolutepath ( ) , _str ) ; exportnode ( ancestors , prefs , withsubtree , out ) ; flushendtag ( _str , out ) ; flushendtag ( _str , out ) ; out . flush ( ) ; out = null ; }	utilities for preferences export.
protected void storeinprofilesmap ( client client ) { set parentset = client . getproperties ( parent_id ) ; string clienttype = client . getclienttype ( ) ; map m = getstylesprofilemap ( clienttype , parentset ) ; if ( m != null ) { m . put ( clienttype , client ) ; } return ; }	adds the client to its appropriate baseprofilemap & stylemap.
public void testbug4808 ( ) throws exception { mysqlconnectionpooldatasource ds = new mysqlconnectionpooldatasource ( ) ; ds . seturl ( basetestcase . dburl ) ; pooledconnection closemetwice = ds . getpooledconnection ( ) ; closemetwice . close ( ) ; closemetwice . close ( ) ; }	tests fix for bug # 4808 - calling.
public void testcomputeznan ( ) { geometry lineargeom = read ( _str ) ; lengthindexedline indexedline = new lengthindexedline ( lineargeom ) ; double projindex = indexedline . project ( new coordinate ( _num , _num ) ) ; coordinate projpt = indexedline . extractpoint ( projindex ) ; asserttrue ( double . isnan ( projpt . z ) ) ; }	tests that if the input does not have z ordinates , neither does the output .
public static int optionlength ( string option ) { if ( option . equals ( _str ) ) return _num ; if ( option . equals ( _str ) ) return _num ; if ( option . equals ( _str ) ) return _num ; return _num ; }	method called from the javadoc environment to determint the options length.
public static floatbuffer createfloatbuffer ( float [ ] coords ) { bytebuffer bb = bytebuffer . allocatedirect ( coords . length * sizeof_float ) ; bb . order ( byteorder . nativeorder ( ) ) ; floatbuffer fb = bb . asfloatbuffer ( ) ; fb . put ( coords ) ; fb . position ( _num ) ; return fb ; }	allocates a direct float buffer , and populates it with the float array data .
public intstreamex remove ( intpredicate predicate ) { return filter ( predicate . negate ( ) ) ; }	returns a stream consisting of the elements of this stream that don ' t match the given predicate.
static void sendrawline ( pircbot bot , bufferedwriter bwriter , string line ) { if ( line . length ( ) > bot . getmaxlinelength ( ) - _num ) { line = line . substring ( _num , bot . getmaxlinelength ( ) - _num ) ; } synchronized ( bwriter ) { try { bwriter . write ( line + _str ) ; bwriter . flush ( ) ; } catch ( exception e ) { } } }	a static method to write a line to a bufferedoutputstream and then pass the line to the log method of the supplied pircbot instance .
entry kill ( ) { entry entry ; for ( int i = entries . size ( ) - _num ; i >= _num ; i -- ) { entry = entries . get ( i ) ; if ( ! entry . dead ) { entry . dead = _bool ; return entry ; } } throw new illegalstateexception ( _str ) ; }	kill the latest alive entry.
protected void uninstallcomponents ( ) { if ( scrollabletablayoutenabled ( ) ) { tabpane . remove ( tabscroller . viewport ) ; tabpane . remove ( tabscroller . scrollforwardbutton ) ; tabpane . remove ( tabscroller . scrollbackwardbutton ) ; tabscroller = null ; } }	removes any installed subcomponents from the jtabbedpane.
public void reset ( ) { forms = null ; }	clears out any references to elements or items created by this factory so far .
public static map < string , string > populaterequestproperties ( map < string , string > requestproperties , int bodylength , mediatype contenttype , mediatype accepttype ) { map < string , string > properties ; if ( requestproperties == null || requestproperties . isempty ( ) ) { properties = new hashmap < > ( ) ; } else { properties = new hashmap < > ( requestproperties ) ; } if ( accepttype != null ) { properties . put ( headernames . accept , accepttype . tostring ( ) ) ; } if ( contenttype != null ) { properties . put ( headernames . content_type , contenttype . tostring ( ) ) ; } if ( bodylength > - _num ) { properties . put ( headernames . content_length , string . valueof ( bodylength ) ) ; } return properties ; }	util method for first populating request properties before execution .
private void checkprotocolalreadyexists ( set < string > protocols , string protocoltype ) { if ( ! protocols . contains ( protocoltype ) ) { protocols . add ( protocoltype ) ; } }	verify whether protocoltype already exists or not.
private static char callcharmethodv ( jnienvironment env , int objjref , int methodid , address argaddress ) throws exception { if ( tracejni ) vm . syswrite ( _str ) ; runtimeentrypoints . checkjnicountdowntogc ( ) ; try { object obj = env . getjniref ( objjref ) ; object returnobj = jnihelpers . invokewithvararg ( obj , methodid , argaddress , typereference . char , _bool ) ; return reflection . unwrapchar ( returnobj ) ; } catch ( throwable unexpected ) { if ( tracejni ) unexpected . printstacktrace ( system . err ) ; env . recordexception ( unexpected ) ; return _num ; } }	callcharmethodv : invoke a virtual method that returns a char value.
public void testconstrstringwithexponentwithpoint3 ( ) { string a = _str ; int ascale = _num ; biginteger ba = new biginteger ( _str ) ; bigdecimal anumber = new bigdecimal ( a ) ; assertequals ( _str , ba , anumber . unscaledvalue ( ) ) ; assertequals ( _str , ascale , anumber . scale ( ) ) ; }	new bigdecimal ( string value ) ; value contains both exponent and decimal point.
public static boolean iscompositionplaylist ( resourcebyterangeprovider resourcebyterangeprovider ) throws ioexception { return imfcompositionplaylisttype . iscompositionplaylist ( resourcebyterangeprovider ) ; }	a method that confirms if the inputstream corresponds to a composition document instance .
public static masterprivatekey decrypt ( string passphrase , byte [ ] encrypted ) throws hyperledgerexception { try { byte [ ] key = scrypt . generate ( passphrase . getbytes ( _str ) , bitcoin_seed , _num , _num , _num , _num ) ; secretkeyspec keyspec = new secretkeyspec ( key , _str ) ; cipher cipher = cipher . getinstance ( _str , _str ) ; byte [ ] iv = arrays . copyofrange ( encrypted , _num , _num ) ; byte [ ] data = arrays . copyofrange ( encrypted , _num , encrypted . length ) ; cipher . init ( cipher . decrypt_mode , keyspec , new ivparameterspec ( iv ) ) ; return masterprivatekey . parse ( new string ( cipher . dofinal ( data ) ) ) ; } catch ( unsupportedencodingexception | invalidalgorithmparameterexception | nosuchpaddingexception | nosuchproviderexception | nosuchalgorithmexception | invalidkeyexception | badpaddingexception | illegalblocksizeexception e ) { throw new hyperledgerexception ( e ) ; } }	re - create a masterprivatekey from encrypted serialization.
protected boolean beforerelease ( ) { return deque . size ( ) < maxsize ; }	called before releasing an object , returns true if the object should be recycled and false otherwise .
public void reset ( ) { system . arraycopy ( initialstate , _num , chain , _num , chain . length ) ; ubiinit ( param_type_message ) ; }	reset the engine to the initial state ( with the key and any pre - message parameters , ready to accept message input .
public synchronized void addurls ( list < url > urls ) { for ( url url : urls ) super . addurl ( url ) ; arraylist searchlist = new arraylist ( ) ; searchlist . addall ( searchpath ) ; searchlist . addall ( urls ) ; searchpath = collections . unmodifiablelist ( searchpath ) ; }	appends the specified urls to the list of urls to search for classes and resources .
protected byte [ ] httpget ( final string url ) { httpget httprequest = null ; httpresponse httpresponse = null ; closeablehttpclient client = null ; try { final uri uri = new uri ( url . trim ( ) ) ; httprequest = new httpget ( uri ) ; if ( contenttype != null ) { httprequest . setheader ( content_type , contenttype ) ; } client = gethttpclient ( url ) ; httpresponse = gethttpresponse ( client , httprequest , url ) ; final byte [ ] returnedbytes = readhttpresponse ( url , httpresponse ) ; return returnedbytes ; } catch ( urisyntaxexception e ) { throw new dssexception ( e ) ; } finally { try { if ( httprequest != null ) { httprequest . releaseconnection ( ) ; } if ( httpresponse != null ) { entityutils . consumequietly ( httpresponse . getentity ( ) ) ; } } finally { closeclient ( client ) ; } } }	this method retrieves data using http or https protocol and ' get ' method .
@ override public string tostring ( ) { return asstring ; }	this method returns the restriction as a string .
public final int readchar ( ) throws ioexception { if ( _readencoding != null ) { int ch = _readencoding . read ( ) ; return ch ; } if ( _readlength <= _readoffset ) { if ( ! readbuffer ( ) ) return - _num ; } return _readbuffer [ _readoffset ++ ] & _num ; }	reads a character from the stream , returning - 1 on end of file .
public void writeexif ( string jpegfilename , string exifoutfilename ) throws filenotfoundexception , ioexception { if ( jpegfilename == null || exifoutfilename == null ) { throw new illegalargumentexception ( null_argument_string ) ; } inputstream is = null ; try { is = new fileinputstream ( jpegfilename ) ; writeexif ( is , exifoutfilename ) ; } catch ( ioexception e ) { closesilently ( is ) ; throw e ; } is . close ( ) ; }	writes the tags from this exifinterface object into a jpeg file , removing prior exif tags .
public void execnonquery ( string sql , string [ ] selectionargs ) { for ( int i = _num , count = selectionargs . length ; i < count ; i ++ ) sql = sql . replacefirst ( _str , selectionargs [ i ] ) ; logutils . d ( sql ) ; database . execsql ( sql ) ; }	execute non query sql with selectionargs , will replace ? s with selectionargs .
public dgeneralsubtreechooser ( jframe parent , string title , generalsubtree generalsubtree ) { super ( parent , title , modalitytype . document_modal ) ; initcomponents ( generalsubtree ) ; }	constructs a new dgeneralsubtreechooser dialog .
public void insert ( undoobjectstorable p_object ) { if ( p_object == null ) throw new illegalargumentexception ( classname + _str ) ; disable_redo ( ) ; undoobjectnode undoable_object = new undoobjectnode ( p_object , stack_level ) ; objects_map . put ( p_object , undoable_object ) ; }	adds p_object to the undoableobjectslist a check is made to make sure that p_object is non null by doing this i am guarantee that a get will always return a non null object.
protected abstract simpleentry entrydatamatched ( entryhierarchydata ehd ) ;	utility method - when iterating over the hierarchy , determine if the entry currently being considered is actually matched . if it is , return the corresponding simpleentry object so the details can be displayed.
@ override public enumeration < option > listoptions ( ) { vector < option > result = enumtovector ( super . listoptions ( ) ) ; result . add ( new option ( _str + defaultnoisepercent ( ) + _str , _str , _num , _str ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
@ suppresswarnings ( _str ) protected void notifypropertychangelistener ( string property , object oldvalue , object newvalue ) { if ( ( oldvalue != null && oldvalue . equals ( newvalue ) ) || oldvalue == newvalue ) { log . error ( _str ) ; } vector < propertychangelistener > v ; synchronized ( this ) { v = ( vector < propertychangelistener > ) listeners . clone ( ) ; } if ( log . isdebugenabled ( ) ) { log . debug ( _str + v . size ( ) + _str + property ) ; } int cnt = v . size ( ) ; for ( int i = _num ; i < cnt ; i ++ ) { propertychangelistener client = v . elementat ( i ) ; client . propertychange ( new propertychangeevent ( this , property , oldvalue , newvalue ) ) ; } }	trigger the notification of all propertychangelisteners.
public element writebeanvisual ( element parent , object o , string name ) throws exception { element node ; beanvisual visual ; if ( debug ) { trace ( new throwable ( ) , name ) ; } m_currentnode = parent ; visual = ( beanvisual ) o ; node = writetoxml ( parent , o , name ) ; invokewritetoxml ( node , visual . geticonpath ( ) , val_iconpath ) ; invokewritetoxml ( node , visual . getanimatediconpath ( ) , val_animatediconpath ) ; return node ; }	adds the given beanvisual to a dom structure .
private string displaynametobackcompatname ( string queryname ) { final int lastbackslash = queryname . lastindexof ( _str ) ; if ( lastbackslash > _num && lastbackslash < queryname . length ( ) - _num ) { queryname = ( char ) _num + queryname ; queryname = queryname . substring ( _num , lastbackslash + _num ) + ( char ) _num + _str + queryname . substring ( lastbackslash + _num ) ; queryname = queryname . replace ( _str , ( char ) _num ) ; } return queryname ; }	method to work around the query names that are expected when working in back - compat mode against stored queries .
public sqlitedatabaseconfiguration ( string path , int openflags ) { if ( path == null ) { throw new illegalargumentexception ( _str ) ; } this . path = path ; label = strippathforlogs ( path ) ; this . openflags = openflags ; maxsqlcachesize = _num ; locale = locale . getdefault ( ) ; }	creates a database configuration with the required parameters for opening a database and default values for all other parameters .
public static string dump ( final endpointdescriptor descriptor ) { return string . format ( _str + _str + _str + _str + _str + _str + _str + _str + _str + _str , descriptor . blength ( ) , descriptor . bdescriptortype ( ) , string . format ( _str , descriptor . bendpointaddress ( ) & _num ) , descriptor . bendpointaddress ( ) & _num , getdirectionname ( descriptor . bendpointaddress ( ) ) , descriptor . bmattributes ( ) & _num , gettransfertypename ( descriptor . bmattributes ( ) ) , getsynchtypename ( descriptor . bmattributes ( ) ) , getusagetypename ( descriptor . bmattributes ( ) ) , descriptor . wmaxpacketsize ( ) & _num , descriptor . binterval ( ) & _num ) ; }	dumps the specified usb endpoint descriptor into a string and returns it .
public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str + _str + _str , _str , _num , _str ) ) ; newvector . addall ( collections . list ( super . listoptions ( ) ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public static void printpadding ( printwriter out , int padding ) { for ( int i = _num ; i < padding ; ++ i ) { out . print ( _str ) ; } }	print a sequence of spaces.
protected void sneakyclear ( ) { list < eobject > collection = new unmodifiableelist < > ( size , data ) ; sneakydoclear ( ) ; for ( iterator < eobject > i = collection . iterator ( ) ; i . hasnext ( ) ; ) { inverseremove ( i . next ( ) , null ) ; } }	avoid changes to the mod counter and events.
@ calledbynative public static bitmap createhomescreeniconfromwebicon ( context context , bitmap webicon ) { activitymanager am = ( activitymanager ) context . getsystemservice ( context . activity_service ) ; int maxinnersize = math . round ( am . getlauncherlargeiconsize ( ) * max_inner_size_ratio ) ; int innersize = math . min ( maxinnersize , math . max ( webicon . getwidth ( ) , webicon . getheight ( ) ) ) ; int padding = math . round ( icon_padding_ratio * innersize ) ; int outersize = innersize + _num * padding ; bitmap bitmap = null ; try { bitmap = bitmap . createbitmap ( outersize , outersize , bitmap . config . argb_8888 ) ; } catch ( outofmemoryerror e ) { log . w ( tag , _str ) ; return webicon ; } canvas canvas = new canvas ( bitmap ) ; rect innerbounds = new rect ( padding , padding , outersize - padding , outersize - padding ) ; paint paint = new paint ( paint . anti_alias_flag ) ; paint . setfilterbitmap ( _bool ) ; canvas . drawbitmap ( webicon , null , innerbounds , paint ) ; int cornerradius = math . round ( icon_corner_radius_ratio * outersize ) ; path path = new path ( ) ; path . setfilltype ( path . filltype . inverse_winding ) ; rectf innerboundsf = new rectf ( innerbounds ) ; path . addroundrect ( innerboundsf , cornerradius , cornerradius , path . direction . cw ) ; paint . setxfermode ( new porterduffxfermode ( porterduff . mode . clear ) ) ; canvas . drawpath ( path , paint ) ; return bitmap ; }	adapts a website ' s icon ( e.
private static boolean isinoverflow ( menuitem item ) { return ! isactionbutton ( item ) ; }	check if an item is in the overflow menu .
private static int determineconsecutivebinarycount ( charsequence msg , byte [ ] bytes , int startpos ) throws writerexception { int len = msg . length ( ) ; int idx = startpos ; while ( idx < len ) { char ch = msg . charat ( idx ) ; int numericcount = _num ; while ( numericcount < _num && isdigit ( ch ) ) { numericcount ++ ; int i = idx + numericcount ; if ( i >= len ) { break ; } ch = msg . charat ( i ) ; } if ( numericcount >= _num ) { return idx - startpos ; } int textcount = _num ; while ( textcount < _num && istext ( ch ) ) { textcount ++ ; int i = idx + textcount ; if ( i >= len ) { break ; } ch = msg . charat ( i ) ; } if ( textcount >= _num ) { return idx - startpos ; } ch = msg . charat ( idx ) ; if ( bytes [ idx ] == _num && ch != _str ) { throw new writerexception ( _str + ch + _str + ( int ) ch + _str ) ; } idx ++ ; } return idx - startpos ; }	determines the number of consecutive characters that are encodable using binary compaction .
void pluginmessage ( throwable ex ) { log . printlines ( prefixkind . javac , _str ) ; ex . printstacktrace ( log . getwriter ( writerkind . notice ) ) ; }	print a message reporting an uncaught exception from an annotation processor .
public builder map ( string fullyqualifiedcolumnnames , columnmapper mapper ) { predicate < columnid > columnmatcher = predicates . includes ( fullyqualifiedcolumnnames , null ) ; rules . add ( new mapperrule ( columnmatcher , mapper ) ) ; return this ; }	set a mapping function for the columns with fully - qualified names that match the given comma - separated list of regular expression patterns .
public double theta ( ) { return math . atan2 ( y , x ) ; }	returns the angle of this point in polar coordinates .
public static int hash32 ( final string text , int from , int length ) { return hash32 ( text . substring ( from , from + length ) ) ; }	generates 32 bit hash from a substring .
protected void sendclosingmessage ( ) { try { send ( connectionmessage . closing , networkprotocol . tcp ) ; } catch ( exception e ) { log . warning ( _str + e . getmessage ( ) ) ; } try { send ( connectionmessage . closing , networkprotocol . udp ) ; } catch ( exception e ) { log . warning ( _str + e . getmessage ( ) ) ; } }	send a message ( hint ) that this end of connection is about to close.
public static string parsenumbertostring ( int anumber ) { boolean temp = _bool , negative = _bool ; if ( anumber < _num ) { anumber *= - _num ; negative = _bool ; } stringbuilder tstringb = new stringbuilder ( ) ; for ( int i = _num ; i > _num ; i /= _num ) { int tdigit = ( anumber / i ) % _num ; if ( temp && tdigit != _num ) temp = _bool ; if ( ! temp ) { tstringb . append ( tdigit ) ; if ( i != _num ) for ( int j = i ; j > _num ; j /= _num ) if ( j == _num ) tstringb . append ( _str ) ; } } string tstring = tstringb . tostring ( ) ; if ( tstring . equals ( e ) ) tstring = _str ; return negative ? _str + tstring : tstring ; }	converts a number to a string.
public void remove ( t graphic ) { synchronized ( mlock ) { mgraphics . remove ( graphic ) ; if ( mfirstgraphic != null && mfirstgraphic . equals ( graphic ) ) { mfirstgraphic = null ; } } postinvalidate ( ) ; }	removes a graphic from the overlay .
public boolean validsystemnameconfig ( string systemname ) { return ( _bool ) ; }	public method to validate system name for configuration returns ' true ' if system name has a valid meaning in current configuration , else returns ' false ' for now , this method always returns ' true ' ; it is needed for the abstract light class.
public int read ( ) throws ioexception { ensureopen ( ) ; if ( next >= length ) { return - _num ; } return str . charat ( next ++ ) ; }	reads a single character .
void addhiddenchannellistener ( hiddenchannellistener listener ) { listeners . add ( listener ) ; }	add a listener for following changes on hidden channel logs .
public boolean nextto ( final entity entity , final double step ) { final rectangle2d thisarea = new rectangle2d . double ( x - step , y - step , area . getwidth ( ) + _num * step , area . getheight ( ) + _num * step ) ; return thisarea . intersects ( entity . getarea ( ) ) ; }	checks whether the given entity is near this entity .
private long rebalance_nl ( final long nparent , final long n , longarray unlinked ) { final long nl = unsharedleft ( n , unlinked ) ; final long nr = unsharedright ( n , unlinked ) ; if ( ( nl == _num || nr == _num ) && voptisnull ( n ) ) { if ( attemptunlink_nl ( nparent , n , unlinked ) ) { return fixheight_nl ( nparent ) ; } else { return n ; } } final int hn = height ( n ) ; final int hl0 = height ( nl ) ; final int hr0 = height ( nr ) ; final int hnrepl = _num + math . max ( hl0 , hr0 ) ; final int bal = hl0 - hr0 ; if ( bal > _num ) { return rebalancetoright_nl ( nparent , n , nl , hr0 , unlinked ) ; } else if ( bal < - _num ) { return rebalancetoleft_nl ( nparent , n , nr , hl0 , unlinked ) ; } else if ( hnrepl != hn ) { height ( n , hnrepl ) ; return fixheight_nl ( nparent ) ; } else { return _num ; } }	nparent and n must be locked on entry.
private void addconversations ( ) { tpp_phase myphase = awaiting ; mainnpc . add ( conversationstates . attending , arrays . aslist ( _str , _str ) , new tppquestinphasecondition ( myphase ) , conversationstates . attending , _str + _str + _str , null ) ; mainnpc . add ( conversationstates . attending , _str , new tppquestinphasecondition ( myphase ) , conversationstates . attending , null , new detailskillingsaction ( ) ) ; mainnpc . add ( conversationstates . attending , _str , new tppquestinphasecondition ( myphase ) , conversationstates . attending , null , new rewardplayeraction ( ) ) ; }	adds quest ' s related conversations to mayor.
public static void w ( string tag , string s , object ... args ) { if ( log . warn >= loglevel ) log . w ( tag , string . format ( s , args ) ) ; }	warning log message with printf formatting .
@ edu . umd . cs . findbugs . annotations . suppresswarnings ( value = _str , justification = _str ) public void handlenotification ( notification notification , object handback ) { if ( handback instanceof agentimpl ) { agentimpl agent = ( agentimpl ) handback ; jmxconnectionnotification jmxnotifn = ( jmxconnectionnotification ) notification ; if ( logger . isdebugenabled ( ) ) { logger . debug ( _str , jmxnotifn . getconnectionid ( ) ) ; } agent . updatermiclientscount ( ) ; } }	if the handback object passed is an agentimpl , updates the jmx client count.
public static boolean isblank ( string s ) { if ( s == null ) { return _bool ; } int slen = s . length ( ) ; for ( int i = _num ; i < slen ; i ++ ) { if ( ! character . iswhitespace ( s . charat ( i ) ) ) { return _bool ; } } return _bool ; }	checks whether a string is whitespace , empty or null .
public plaintextdictionary ( path path ) throws ioexception { in = files . newbufferedreader ( path , standardcharsets . utf_8 ) ; }	creates a dictionary based on a path . < p > note : content is treated as utf - 8.
public boolean addaliasbynumber ( string aliasname , string number ) { if ( aliasname . contains ( _str ) ) return _bool ; string contactname = contactsmanager . getcontactnameornull ( ctx , number ) ; addorupdate ( aliasname , number , contactname ) ; return _bool ; }	adds an alias by a phone number if the alias contains an invalid character , false will be returned.
void splitdata ( node node , node newnode , int offset ) { if ( ranges != null ) { notifyrangessplitdata ( node , newnode , offset ) ; } }	a method to be called when a text node has been split , so that live objects can be notified .
@ notnull @ objectivecname ( _str ) public configurationbuilder addtrustedkey ( string trustedkey ) { trustedkeys . add ( new trustedkey ( trustedkey ) ) ; return this ; }	adding trusted key for protocol encryption securing.
private void checkiscorrectclass ( ) { if ( checkissubclass ( act_name ) ) { type = elementtype . acttivity ; } else if ( checkissubclass ( frag_name ) || checkissubclass ( v4_frag_name ) ) { type = elementtype . fragment ; } else { throw new illegalargumentexception ( string . format ( _str , element . getqualifiedname ( ) , act_name , frag_name , v4_frag_name ) ) ; } }	check out if is extends from activity or fragment.
string transformresourceidtofilename ( final string resourcename ) { return resourcename . replace ( _str , _str ) ; }	transform resource id in filename_extension format to filename . extension.
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return success ; case _num : return msg ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
private void fillnodesincontext ( sitenode rootnode , list < sitenode > nodeslist ) { @ suppresswarnings ( _str ) enumeration < sitenode > en = rootnode . children ( ) ; while ( en . hasmoreelements ( ) ) { sitenode sn = en . nextelement ( ) ; if ( isincontext ( sn ) ) { nodeslist . add ( sn ) ; } fillnodesincontext ( sn , nodeslist ) ; } }	fills a given list with nodes in scope , searching recursively .
@ suppresswarnings ( { _str , _str } ) public boolean matches ( inventorycrafting p_77569_1_ , world p_77569_2_ ) { arraylist arraylist = new arraylist ( this . recipeitems ) ; for ( int i = _num ; i < _num ; ++ i ) { for ( int j = _num ; j < _num ; ++ j ) { itemstack itemstack = p_77569_1_ . getstackinrowandcolumn ( j , i ) ; if ( itemstack != null ) { boolean flag = _bool ; iterator iterator = arraylist . iterator ( ) ; while ( iterator . hasnext ( ) ) { itemstack itemstack1 = ( itemstack ) iterator . next ( ) ; if ( itemstack . getitem ( ) == itemstack1 . getitem ( ) && ( itemstack1 . getitemdamage ( ) == _num || itemstack . getitemdamage ( ) == itemstack1 . getitemdamage ( ) ) ) { flag = _bool ; arraylist . remove ( itemstack1 ) ; break ; } } if ( ! flag ) { return _bool ; } } } } return arraylist . isempty ( ) ; }	used to check if a recipe matches current crafting inventory.
public stringbuilder dumpstatements ( final iaccesspath < ispo > accesspath ) { final stringbuilder sb = new stringbuilder ( ) ; final bigdatastatementiterator itr = asstatementiterator ( accesspath . iterator ( ) ) ; try { while ( itr . hasnext ( ) ) { sb . append ( _str + itr . next ( ) ) ; } return sb ; } finally { itr . close ( ) ; } }	dumps the access path , efficiently resolving term identifiers to terms .
public static element svgwaiticon ( document document , double x , double y , double w , double h ) { element g = svgutil . svgelement ( document , svgconstants . svg_g_tag ) ; setatt ( g , svgconstants . svg_transform_attribute , _str + x + _str + y + _str + w + _str + h + _str ) ; element thro = svgutil . svgelement ( document , svgconstants . svg_path_tag ) ; setatt ( thro , svgconstants . svg_d_attribute , throbber_path ) ; setstyle ( thro , throbber_style ) ; element anim = svgutil . svgelement ( document , svgconstants . svg_animate_transform_tag ) ; setatt ( anim , svgconstants . svg_attribute_name_attribute , svgconstants . svg_transform_attribute ) ; setatt ( anim , svgconstants . svg_attribute_type_attribute , _str ) ; setatt ( anim , svgconstants . svg_type_attribute , svgconstants . svg_rotate_attribute ) ; setatt ( anim , svgconstants . svg_from_attribute , _str ) ; setatt ( anim , svgconstants . svg_to_attribute , _str ) ; setatt ( anim , svgconstants . svg_begin_attribute , fmt ( math . random ( ) * _num ) + _str ) ; setatt ( anim , svgconstants . svg_dur_attribute , _str ) ; setatt ( anim , svgconstants . svg_repeat_count_attribute , _str ) ; setatt ( anim , svgconstants . svg_fill_attribute , _str ) ; thro . appendchild ( anim ) ; g . appendchild ( thro ) ; return g ; }	draw a simple " please wait " icon ( in - progress ) as placeholder for running renderings .
protected void onend ( pcap pcap ) { this . end = _bool ; }	called after the pcap loop exits .
public void cd ( string dir ) { stringbuilder buf = new stringbuilder ( ) ; string command = string . format ( imageserverdialogproperties . getstring ( _str ) , dir ) ; sendwaitfor ( command , defaulttimeout , prompts , buf ) ; log . debug ( buf . tostring ( ) ) ; }	cd command in linux .
public void addrequestproperty ( string key , string value ) { jarfileurlconnection . addrequestproperty ( key , value ) ; }	adds a general request property specified by a key - value pair.
public static void writespecinfotofiles ( securityspecmodel securityspecmodel , string app_root_dir ) { writeinfoflowsummarytofile ( securityspecmodel , config . v ( ) . app_root_dir ) ; writeinfoflowdetailstofile ( securityspecmodel , config . v ( ) . app_root_dir ) ; writevalueinfotofile ( securityspecmodel , config . v ( ) . app_root_dir ) ; writepointstoinfotofile ( securityspecmodel , config . v ( ) . app_root_dir ) ; }	writes info flow info , value flow info , and points to info associated with the security spec to separate files in the droidsafe folder of the current selected android app .
private void handlecommand ( int id , string command , string params ) { string origincommand = commandid . get ( id ) ; if ( origincommand == null ) { origincommand = _str ; } handler . handlecommand ( id , command , params , origincommand ) ; if ( command . equals ( _str ) ) { logger . warning ( _str + params ) ; } }	handle message already parsed into id , command and parameters .
private void closealldumps ( ) { object [ ] options = { _str , _str } ; int selectvalue = joptionpane . showoptiondialog ( null , _str , _str , joptionpane . default_option , joptionpane . question_message , null , options , options [ _num ] ) ; if ( selectvalue == _num ) { topnodes = new vector ( ) ; resetmainpanel ( ) ; } }	close all open dumps.
private void closecounterdatainputstream ( ) throws datafallbackexception { if ( log . isdebugenabled ( ) ) log . debug ( _str + counterfile . getname ( ) ) ; if ( dinput != null ) { try { dinput . close ( ) ; } catch ( ioexception e ) { throw new datafallbackexception ( e . getmessage ( ) ) ; } finally { dinput = null ; } } }	close the input stream opened for the counter file.
private static string removefilenameextension ( string filename ) { if ( filename . lastindexof ( _str ) == - _num ) return filename ; return filename . substring ( _num , filename . lastindexof ( _str ) ) ; }	removes the extension ( whatever comes after the last '.
public void clear ( ) { read = write = count = _num ; arrays . fill ( buffer , null ) ; }	clear the contents of this buffer .
private list < entry > reducewithdouglaspeuker ( list < entry > entries , double epsilon ) { if ( epsilon <= _num || entries . size ( ) < _num ) { return entries ; } keep [ _num ] = _bool ; keep [ entries . size ( ) - _num ] = _bool ; algorithmdouglaspeucker ( entries , epsilon , _num , entries . size ( ) - _num ) ; list < entry > reducedentries = new arraylist < > ( ) ; for ( int i = _num ; i < entries . size ( ) ; i ++ ) { if ( keep [ i ] ) { entry curentry = entries . get ( i ) ; reducedentries . add ( new entry ( curentry . getval ( ) , curentry . getxindex ( ) ) ) ; } } return reducedentries ; }	uses the douglas peuker algorithm to reduce the given list of entries.
static int hibitpos ( long num ) { return _num - long . numberofleadingzeros ( num ) ; }	zero based position of the highest one - bit of the given long.
public adaptivegridarchive ( int capacity , problem problem , int numberofdivisions ) { this . capacity = capacity ; this . problem = problem ; this . numberofdivisions = numberofdivisions ; minimum = new double [ problem . getnumberofobjectives ( ) ] ; maximum = new double [ problem . getnumberofobjectives ( ) ] ; density = new int [ ( int ) math . pow ( numberofdivisions , problem . getnumberofobjectives ( ) ) ] ; adaptgrid ( ) ; }	constructs an adaptive grid archive with the specified capacity with the specified number of divisions along each objective .
beginlineaction ( string nm , boolean select ) { super ( nm ) ; this . select = select ; }	create this action with the appropriate identifier .
private void adjustwindowsize ( containerwrapper parent ) { boundsize wbounds = lc . getpackwidth ( ) ; boundsize hbounds = lc . getpackheight ( ) ; if ( wbounds == null && hbounds == null ) return ; window win = ( ( window ) swingutilities . getancestorofclass ( window . class , ( component ) parent . getcomponent ( ) ) ) ; if ( win == null ) return ; dimension prefsize = win . getpreferredsize ( ) ; int targw = constrain ( checkparent ( win ) , win . getwidth ( ) , prefsize . width , wbounds ) ; int targh = constrain ( checkparent ( win ) , win . getheight ( ) , prefsize . height , hbounds ) ; int x = math . round ( win . getx ( ) - ( ( targw - win . getwidth ( ) ) * ( _num - lc . getpackwidthalign ( ) ) ) ) ; int y = math . round ( win . gety ( ) - ( ( targh - win . getheight ( ) ) * ( _num - lc . getpackheightalign ( ) ) ) ) ; win . setbounds ( x , y , targw , targh ) ; }	checks the parent window if its size is within parameters as set by the lc .
@ override public void write ( list < byte [ ] > valuelist ) throws ioexception { if ( isfirsttime ) { init ( ) ; isfirsttime = _bool ; } for ( byte [ ] value : valuelist ) { onedictionarychunklist . add ( bytebuffer . wrap ( value ) ) ; totalrecordcount ++ ; } }	this method will write the data in thrift format to disk . this method will not be guided by parameter dictionary_one_chunk_size and complete data will be written as one chunk.
public void proceed ( ) { idle . set ( _bool ) ; subject . onnext ( null ) ; }	signalizes that the backlog can proceed with the next item.
private static boolean nsequals ( string nsuri_1 , string nsuri_2 ) { if ( nsuri_1 == null ) { return ( nsuri_2 == null ) ; } else { return nsuri_1 . equals ( nsuri_2 ) ; } }	compares two namespace uris with an extra case for null entries.
public static void sleep ( long millis ) { if ( mocksleepqueue == null ) { sleepuninterruptibly ( millis , timeunit . milliseconds ) ; } else { try { boolean ismultipass = mocksleepqueue . take ( ) ; rollmockclockmillis ( millis ) ; if ( ismultipass ) mocksleepqueue . offer ( _bool ) ; } catch ( interruptedexception e ) { } } }	sleep for a span of time , or mock sleep if enabled.
public boolean ishandle ( string handle ) { return clienthandle . equals ( handle ) ; }	determines if a given handle refers to this client.
public static void isgte ( string argname , long i , long min ) { if ( i < min ) { throw new illegalargumentexception ( string . format ( _str , argname , min , i ) ) ; } }	makes sure the given number is greater than or equal to the given minimum .
int adjusttextoffset ( int offset ) { maxtextoffset = math . max ( maxtextoffset , offset ) ; return maxtextoffset ; }	adjusts the text offset needed to align text horizontally .
public static object valuefromclassconstant ( string key , object defaultvalue ) { configuration conf = instance ( ) ; string val = valuefor ( key ) ; if ( val == null ) { return defaultvalue ; } int idx = val . lastindexof ( _str ) ; string klassname ; string cnst ; try { klassname = val . substring ( _num , idx ) ; cnst = val . substring ( idx + _num ) ; } catch ( indexoutofboundsexception e ) { conf . warning ( _str + key + _str + _str + val ) ; return defaultvalue ; } class klass ; try { klass = class . forname ( klassname ) ; } catch ( classnotfoundexception e ) { conf . warning ( _str + key + _str + klassname ) ; return defaultvalue ; } object cnstval ; try { field fld = klass . getdeclaredfield ( cnst ) ; try { cnstval = fld . get ( klass ) ; } catch ( illegalaccessexception e ) { conf . warning ( _str + key + _str + klassname + _str + cnst ) ; return defaultvalue ; } } catch ( nosuchfieldexception e ) { conf . warning ( _str + key + _str + klassname ) ; return defaultvalue ; } return cnstval ; }	given a property , resolves the value to a public constant field on some class , where the field is of type object.
public static boolean iswificonnected ( context context ) { connectivitymanager connectivitymanager = ( connectivitymanager ) context . getsystemservice ( context . connectivity_service ) ; networkinfo networkinfo = connectivitymanager . getactivenetworkinfo ( ) ; return networkinfo != null && networkinfo . gettype ( ) == connectivitymanager . type_wifi ; }	this method requires the caller to hold the permission access_network_state .
public strbuilder insert ( final int index , final char value ) { validateindex ( index ) ; ensurecapacity ( size + _num ) ; system . arraycopy ( buffer , index , buffer , index + _num , size - index ) ; buffer [ index ] = value ; size ++ ; return this ; }	inserts the value into this builder .
public list < byte [ ] > trydecode ( final string targettoken ) { final bytebuffer payloadbuf = extractvalidpayloadfields ( targettoken ) ; if ( payloadbuf == null ) { return null ; } final list < byte [ ] > fields = new arraylist < > ( ) ; try { byte [ ] field = null ; while ( ( field = tryreadpayloadnextfield ( payloadbuf ) ) . length > _num ) { fields . add ( field ) ; if ( fields . size ( ) > max_field_size ) { return null ; } } return fields ; } catch ( final bufferunderflowexception e ) { return null ; } }	return null if token is malformed or expired.
@ namespacepermission ( fields = _str , permissions = namespacepermissionenum . write ) @ override public businessobjectdefinition createbusinessobjectdefinition ( businessobjectdefinitioncreaterequest request ) { validatebusinessobjectdefinitioncreaterequest ( request ) ; namespaceentity namespaceentity = namespacedaohelper . getnamespaceentity ( request . getnamespace ( ) ) ; dataproviderentity dataproviderentity = dataproviderdaohelper . getdataproviderentity ( request . getdataprovidername ( ) ) ; businessobjectdefinitionkey businessobjectdefinitionkey = new businessobjectdefinitionkey ( request . getnamespace ( ) , request . getbusinessobjectdefinitionname ( ) ) ; businessobjectdefinitionentity businessobjectdefinitionentity = businessobjectdefinitiondao . getbusinessobjectdefinitionbykey ( businessobjectdefinitionkey ) ; if ( businessobjectdefinitionentity != null ) { throw new alreadyexistsexception ( string . format ( _str , businessobjectdefinitionkey . getbusinessobjectdefinitionname ( ) , businessobjectdefinitionkey . getnamespace ( ) ) ) ; } businessobjectdefinitionentity = createbusinessobjectdefinitionentity ( request , namespaceentity , dataproviderentity ) ; return createbusinessobjectdefinitionfromentity ( businessobjectdefinitionentity ) ; }	creates a new business object definition .
public void endblock ( ) throws ioexception { if ( indent . length ( ) <= _num ) { indent = _str ; } else if ( indent . length ( ) >= _num ) { indent = indent . substring ( _num ) ; } print ( _str , null ) ; printer . println ( ) ; }	description of the method.
private void migrateblockvolumes ( ) { log . info ( _str ) ; dbclient dbclient = getdbclient ( ) ; list < uri > volumeuris = dbclient . querybytype ( volume . class , _bool ) ; iterator < volume > volumes = dbclient . queryiterativeobjects ( volume . class , volumeuris , _bool ) ; list < blockobject > blockobjects = new arraylist < blockobject > ( ) ; while ( volumes . hasnext ( ) ) { blockobjects . add ( volumes . next ( ) ) ; } migrateblockobjects ( blockobjects ) ; }	update the volume object to migrate the old consistencygroups field into the new consistencygroup list field .
public servercontrollertest ( string name ) { super ( name ) ; this . basedir = system . getproperty ( _str ) ; }	creates a servercontrollertest testcase .
@ override public string encode ( ) { return value == intvalue ( ) ? integer . tostring ( intvalue ( ) ) + unit . encode ( ) : double . tostring ( value ) + unit . encode ( ) ; }	returns a parseable string representation of this constant size .
public hostnameparser ( lexercore lexer ) { this . lexer = lexer ; lexer . selectlexer ( _str ) ; stripaddressscopezones = boolean . getboolean ( _str ) ; }	the lexer is initialized with the buffer .
private void loadtext ( inputstream is ) { bufferedreader reader ; string line ; if ( is == null ) { throw new error ( _str ) ; } reader = new bufferedreader ( new inputstreamreader ( is ) ) ; try { line = reader . readline ( ) ; linecount ++ ; while ( line != null ) { if ( ! line . startswith ( _str ) ) { parseandadd ( line , reader ) ; } line = reader . readline ( ) ; } reader . close ( ) ; } catch ( ioexception e ) { throw new error ( e . getmessage ( ) + _str + linecount ) ; } finally { } }	loads the database from the given input stream .
public void addemailadress ( string anemailaddress ) { if ( memails . indexof ( anemailaddress ) < _num ) { memails . add ( anemailaddress ) ; } }	add an email address to the list .
public static instances loaddataset ( string options [ ] , char t ) throws exception { instances d = null ; string filename = utils . getoption ( t , options ) ; if ( filename == null || filename . isempty ( ) ) throw new exception ( _str ) ; file file = new file ( filename ) ; if ( ! file . exists ( ) ) throw new exception ( _str + filename ) ; if ( file . isdirectory ( ) ) throw new exception ( _str + filename + _str ) ; try { datasource source = new datasource ( filename ) ; d = source . getdataset ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; throw new exception ( _str + filename + _str ) ; } return d ; }	loaddataset - load a dataset , given command line options specifying an arff file .
private boolean istypedtimefullylegal ( ) { if ( mis24hourmode ) { int [ ] values = getenteredtime ( null ) ; return ( values [ _num ] >= _num && values [ _num ] >= _num && values [ _num ] < _num ) ; } else { return ( mtypedtimes . contains ( getamorpmkeycode ( am ) ) || mtypedtimes . contains ( getamorpmkeycode ( pm ) ) ) ; } }	check if the time that has been typed so far is completely legal , as is .
public void test_groupcommit ( ) throws exception { final int writeservicecorepoolsize = _num ; final properties properties = getproperties ( ) ; properties . setproperty ( testoptions . timeout , _str ) ; properties . setproperty ( testoptions . ntasks , _str ) ; properties . setproperty ( options . write_service_core_pool_size , _str + writeservicecorepoolsize ) ; properties . setproperty ( options . write_service_maximum_pool_size , _str ) ; properties . setproperty ( options . write_service_prestart_all_core_threads , _str ) ; properties . setproperty ( options . write_service_queue_capacity , _str ) ; docomparisontest ( properties ) ; }	runs a single condition .
@ override public void operate ( population pop ) throws exception { list < individual > newindividuals = new linkedlist < individual > ( ) ; for ( int i = _num ; i < pop . getnumberofindividuals ( ) ; i ++ ) { list < individual > individuals = operate ( pop . get ( i ) ) ; newindividuals . addall ( individuals ) ; } pop . clear ( ) ; pop . addallindividuals ( newindividuals ) ; }	operates on all individuals , removes the original individuals and adds the new ones .
public int size ( ) { return encodednames . size ( ) ; }	the number of key - value pairs in this form - encoded body .
public static byte [ ] toseed ( list < string > words , string passphrase ) { return toseed ( words , passphrase , version . v0_6 ) ; }	convert mnemonic word list to seed .
private arraylist < interval > findorcreateintervalset ( register r ) { arraylist < interval > v = map . get ( r ) ; if ( v == null ) { v = new arraylist < interval > ( ) ; map . put ( r , v ) ; } return v ; }	find or create the set of intervals corresponding to a register r .
protected void removecolumns ( collection < string > removecolumnnames , string tablename ) { if ( removecolumnnames != null && ! removecolumnnames . isempty ( ) ) { execute ( getremovecolumnsqls ( removecolumnnames , tablename ) , mdb ) ; } }	when some fields are removed from class , the table should synchronize the changes by removing the corresponding columns .
public void registeratmosphere ( iatmosphere atmosphere ) { atmosphereregistration . put ( atmosphere . getunlocalizedname ( ) , atmosphere ) ; atmospherelist . add ( atmosphere ) ; }	registers the atmosphere with the mod.
public jxsearchfield ( ) { this ( _str ) ; }	creates a new search field with a default prompt .
private static void reply_login2_role ( body body , mobilesessionctx wsc , string roleid ) { string form = null ; login login = new login ( wsc . ctx ) ; keynamepair [ ] clients = login . getclients ( new keynamepair ( integer . parseint ( roleid ) , roleid ) ) ; stringbuffer script = new stringbuffer ( _str ) ; for ( int i = _num ; i < clients . length ; i ++ ) { if ( i > _num ) script . append ( _str ) ; keynamepair p = clients [ i ] ; script . append ( _str ) ; script . append ( p . getname ( ) ) ; script . append ( _str ) ; script . append ( p . getkey ( ) ) ; script . append ( _str ) ; } script . append ( _str ) ; }	login 2nd page response - field role . < p > fill client , org , warehouse.
public void testcreatedocumenttype1 ( ) throws throwable { document doc ; domimplementation domimpl ; documenttype newdoctype ; document ownerdocument ; string qualifiedname = _str ; string publicid ; string systemid ; list < string > publicids = new arraylist < string > ( ) ; publicids . add ( _str ) ; publicids . add ( _str ) ; list < string > systemids = new arraylist < string > ( ) ; systemids . add ( _str ) ; systemids . add ( _str ) ; doc = ( document ) load ( _str , builder ) ; domimpl = doc . getimplementation ( ) ; for ( int indexn1005d = _num ; indexn1005d < publicids . size ( ) ; indexn1005d ++ ) { publicid = ( string ) publicids . get ( indexn1005d ) ; for ( int indexn10061 = _num ; indexn10061 < systemids . size ( ) ; indexn10061 ++ ) { systemid = ( string ) systemids . get ( indexn10061 ) ; newdoctype = domimpl . createdocumenttype ( qualifiedname , publicid , systemid ) ; assertnotnull ( _str , newdoctype ) ; ownerdocument = newdoctype . getownerdocument ( ) ; assertnull ( _str , ownerdocument ) ; } } }	runs the test case .
public final void run ( ) { if ( m_start == _num ) m_start = system . currenttimemillis ( ) ; m_cancontinue = _bool ; while ( m_cancontinue ) { if ( isinterrupted ( ) ) return ; m_laststart = system . currenttimemillis ( ) ; m_working = _bool ; try { m_pollcount ++ ; if ( candowork ( ) ) { m_cancontinue = dowork ( ) ; m_count ++ ; } } catch ( exception e ) { log . log ( level . severe , _str , e ) ; } m_working = _bool ; long end = system . currenttimemillis ( ) ; m_time += ( end - m_laststart ) ; if ( isinterrupted ( ) ) return ; try { log . fine ( _str + m_sleepseconds ) ; sleep ( m_sleepseconds * _num ) ; } catch ( interruptedexception e1 ) { log . warning ( _str + e1 . getlocalizedmessage ( ) ) ; return ; } } }	run - do the work.
public static solrdocument assertsearchonedoc ( solrparams p ) throws exception { solrdocumentlist docs = assertsearch ( p ) ; assertequals ( _str + p . tostring ( ) + _str + docs . tostring ( ) , _num , docs . getnumfound ( ) ) ; assertequals ( _str + p . tostring ( ) + _str + docs . tostring ( ) , _num , docs . size ( ) ) ; return docs . get ( _num ) ; }	given a set of query params , executes as a query against a random solrclient and asserts that exactly one document is returned.
private static valuesource buildsourcetree ( indexschema schema , string expression , int sourcetype ) { int expressiontype = getsourcetype ( expression ) ; if ( sourcetype != field_type && expressiontype != field_type && expressiontype != filter_type && expressiontype != sourcetype ) { return null ; } switch ( expressiontype ) { case number_type : return buildnumericsource ( schema , expression ) ; case date_type : return builddatesource ( schema , expression ) ; case string_type : return buildstringsource ( schema , expression ) ; case field_type : return buildfieldsource ( schema , expression , sourcetype ) ; case filter_type : return buildfiltersource ( schema , expression . substring ( expression . indexof ( _str ) + _num , expression . lastindexof ( _str ) ) , sourcetype ) ; default : throw new solrexception ( errorcode . bad_request , expression + _str ) ; } }	builds a value source from a given string and a given source type.
public value predecessor ( ) { return predecessor . get ( ) ; }	return the vertex preceding this vertex on the shortest path .
public static double logpdf ( double x , double m , double sd ) { double a = _num / ( math . sqrt ( _num * math . pi ) * sd ) ; double b = - ( x - m ) * ( x - m ) / ( _num * sd * sd ) ; return math . log ( a ) + b ; }	the natural log of the probability density function of the distribution.
public int valuesparseint ( int indexofindex ) throws exception { return integer . parseint ( actualvalue ( indexofindex ) ) ; }	gets the value at indexofindex from the array.
public void testtoengineeringstringzeroposexponent ( ) { string a = _str ; bigdecimal anumber = new bigdecimal ( a ) ; string result = _str ; assertequals ( _str , result , anumber . toengineeringstring ( ) ) ; }	convert a negative bigdecimal to an engineering string representation.
public static int scan ( long v ) { return _num - long . numberofleadingzeros ( v ) ; }	utility method with defined return value for 0 .
public static boolean isalluppercase ( string str ) { if ( str == null ) return _bool ; boolean hasletters = _bool ; char c ; for ( int i = str . length ( ) - _num ; i >= _num ; i -- ) { c = str . charat ( i ) ; if ( character . isletter ( c ) ) { if ( ! character . isuppercase ( c ) ) return _bool ; hasletters = _bool ; } } return hasletters ; }	returns true if the input string has letters and they are all uppercase.
public static classpath createclasspath ( string classpathstring , string sysclasspathstring , string extdirsstring ) { path path = new path ( ) ; if ( sysclasspathstring == null ) { sysclasspathstring = system . getproperty ( _str ) ; } if ( sysclasspathstring != null ) { path . addfiles ( sysclasspathstring ) ; } path . expandjarclasspaths ( _bool ) ; if ( extdirsstring == null ) { extdirsstring = system . getproperty ( _str ) ; } if ( extdirsstring != null ) { path . adddirectories ( extdirsstring ) ; } path . emptypathdefault ( _str ) ; if ( classpathstring == null ) { classpathstring = system . getproperty ( _str ) ; if ( classpathstring == null ) { classpathstring = _str ; } } path . addfiles ( classpathstring ) ; return new classpath ( path . toarray ( new string [ path . size ( ) ] ) ) ; }	create a classpath object for rmic from the relevant command line options for class path , boot class path , and extension directories .
protected abstractspinedbuffer ( int initialcapacity ) { if ( initialcapacity < _num ) throw new illegalargumentexception ( _str + initialcapacity ) ; this . initialchunkpower = math . max ( min_chunk_power , integer . size - integer . numberofleadingzeros ( initialcapacity - _num ) ) ; }	construct with a specified initial capacity .
public static void uf9 ( double [ ] x , double [ ] f , int nx ) { int count1 = _num ; int count2 = _num ; int count3 = _num ; double sum1 = _num ; double sum2 = _num ; double sum3 = _num ; double yj ; double e = _num ; for ( int j = _num ; j <= nx ; j ++ ) { yj = x [ j - _num ] - _num * x [ _num ] * math . sin ( _num * pi * x [ _num ] + j * pi / nx ) ; if ( j % _num == _num ) { sum1 += yj * yj ; count1 ++ ; } else if ( j % _num == _num ) { sum2 += yj * yj ; count2 ++ ; } else { sum3 += yj * yj ; count3 ++ ; } } yj = ( _num + e ) * ( _num - _num * ( _num * x [ _num ] - _num ) * ( _num * x [ _num ] - _num ) ) ; if ( yj < _num ) { yj = _num ; } f [ _num ] = _num * ( yj + _num * x [ _num ] ) * x [ _num ] + _num * sum1 / ( double ) count1 ; f [ _num ] = _num * ( yj - _num * x [ _num ] + _num ) * x [ _num ] + _num * sum2 / ( double ) count2 ; f [ _num ] = _num - x [ _num ] + _num * sum3 / ( double ) count3 ; }	evaluates the uf9 problem .
private void cleaningtext ( ) { int latincount = _num , nonlatincount = _num ; for ( int i = _num ; i < text . length ( ) ; ++ i ) { char c = text . charat ( i ) ; if ( c <= _str && c >= _str ) { ++ latincount ; } else if ( c >= _str && unicodeblock . of ( c ) != unicodeblock . latin_extended_additional ) { ++ nonlatincount ; } } if ( latincount * _num < nonlatincount ) { stringbuffer textwithoutlatin = new stringbuffer ( ) ; for ( int i = _num ; i < text . length ( ) ; ++ i ) { char c = text . charat ( i ) ; if ( c > _str || c < _str ) textwithoutlatin . append ( c ) ; } text = textwithoutlatin ; } }	cleaning text to detect ( eliminate url , e - mail address and latin sentence if it is not written in latin alphabet ).
public void beginapplyinterval ( ) { intervalstartmillis = system . currenttimemillis ( ) ; endmillis = intervalstartmillis ; state = taskstate . apply ; }	start an apply interval .
public void sendmessages ( list < producerrecord < string , string > > records ) { producer < string , string > producer = new kafkaproducer < > ( getproducerconfig ( ) ) ; for ( producerrecord < string , string > rec : records ) producer . send ( rec ) ; producer . flush ( ) ; producer . close ( ) ; }	sends a message to kafka broker .
private static jfreechart createchart ( ) { xyseries series1 = new xyseries ( _str ) ; series1 . add ( _num , _num ) ; series1 . add ( _num , _num ) ; series1 . add ( _num , _num ) ; xydataset dataset = new xyseriescollection ( series1 ) ; return chartfactory . createxystepchart ( _str , _str , _str , dataset , plotorientation . vertical , _bool , _bool , _bool ) ; }	create a horizontal bar chart with sample data in the range - 3 to + 3 .
public boolean isnumbergeographical ( phonenumber phonenumber ) { return isnumbergeographical ( getnumbertype ( phonenumber ) , phonenumber . getcountrycode ( ) ) ; }	tests whether a phone number has a geographical association.
protected int weighteddistribution ( int [ ] weights ) { int sum = _num ; for ( int weight : weights ) { sum += weight ; } int val = ( int ) math . floor ( m_random . nextdouble ( ) * sum ) ; for ( int i = _num ; i < weights . length ; i ++ ) { val -= weights [ i ] ; if ( val < _num ) { return i ; } } return - _num ; }	calculates a weighted distribution.
protected string cleanup ( string classname ) { string result ; result = classname ; if ( result . indexof ( _str ) > - _num ) { result = result . replace ( _str , _str ) ; } if ( result . indexof ( _str ) > - _num ) { result = result . replace ( _str , _str ) ; } if ( result . endswith ( _str ) ) { result = result . substring ( _num , result . length ( ) - _num ) ; } return result ; }	fixes the classname , turns " / " and " \ " into ".
public static boolean isassignable ( class targettype , class valuetype ) { assert . notnull ( targettype , _str ) ; assert . notnull ( valuetype , _str ) ; return ( targettype . isassignablefrom ( valuetype ) || targettype . equals ( primitivewrappertypemap . get ( valuetype ) ) ) ; }	determine if the given target type is assignable from the given value type , assuming setting by reflection.
public dialogcheckbox adddialogcheckbox ( string description , string labeltext , boolean initialstate ) { string [ ] args = new string [ _num ] ; args [ _num ] = _str ; args [ _num ] = description ; args [ _num ] = labeltext ; args [ _num ] = boolean . tostring ( initialstate ) ; dialogcheckbox dcb = new dialogcheckbox ( ) ; dcb . setargs ( args ) ; components . add ( dcb ) ; mainpanel . add ( dcb ) ; return dcb ; }	adds a checkbox to the dialog.
private void performrestore ( file memberdir , file backupdir ) throws exception { list < file > iffiles = fileutil . findall ( memberdir , _str ) ; for ( file file : iffiles ) { file . delete ( ) ; } list < file > oplogs = fileutil . findall ( memberdir , oplog_regex ) ; for ( file file : oplogs ) { file . delete ( ) ; } file restorescript = new file ( backupdir , _str ) ; if ( ! restorescript . exists ( ) ) { restorescript = new file ( backupdir , _str ) ; } asserttrue ( restorescript . exists ( ) ) ; assertequals ( _num , execute ( restorescript . getabsolutepath ( ) ) ) ; }	peforms an operation log restore for a member .
public static boolean downloadurltostream ( string urlstring , outputstream outputstream ) { disableconnectionreuseifnecessary ( ) ; httpurlconnection urlconnection = null ; bufferedoutputstream out = null ; bufferedinputstream in = null ; try { final url url = new url ( urlstring ) ; urlconnection = ( httpurlconnection ) url . openconnection ( ) ; in = new bufferedinputstream ( urlconnection . getinputstream ( ) , io_buffer_size ) ; out = new bufferedoutputstream ( outputstream , io_buffer_size ) ; int b ; while ( ( b = in . read ( ) ) != - _num ) { out . write ( b ) ; } return _bool ; } catch ( final ioexception e ) { log . e ( tag , _str + e ) ; } finally { if ( urlconnection != null ) { urlconnection . disconnect ( ) ; } try { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } catch ( final ioexception e ) { } } return _bool ; }	download a bitmap from a url and write the content to an output stream .
public boolean ispaymentsadequate ( ) { return ispaymentsadequate ( this . cart ) ; }	scipio : verifies if current payment methods in cart are adequate enough to cover the current order , or in other words the cart payments in current state can effectively be used to pay for the order .
@ override public void transactioncommited ( final long committime ) { if ( listeners . isempty ( ) ) { records . reset ( ) ; } else { records . flush ( ) ; listeners . foreach ( null ) ; } }	notification of transaction committed .
public static mwarehouseprice [ ] find ( mbpartner bpartner , boolean issotrx , timestamp valid , int m_warehouse_id , string value , string name , string upc , string sku , string trxname ) { int m_pricelist_id = issotrx ? bpartner . getm_pricelist_id ( ) : bpartner . getpo_pricelist_id ( ) ; mpricelist pl = null ; if ( m_pricelist_id == _num ) pl = mpricelist . getdefault ( bpartner . getctx ( ) , issotrx ) ; else pl = mpricelist . get ( bpartner . getctx ( ) , m_pricelist_id , trxname ) ; if ( pl == null ) { s_log . severe ( _str ) ; return null ; } mpricelistversion plv = pl . getpricelistversion ( valid ) ; if ( plv == null ) { s_log . severe ( _str + pl . getm_pricelist_id ( ) ) ; return null ; } return find ( bpartner . getctx ( ) , plv . getm_pricelist_version_id ( ) , m_warehouse_id , value , name , upc , sku , trxname ) ; }	find products in warehouse with price for customer.
private void readobject ( objectinputstream in ) throws ioexception , classnotfoundexception { counter = new atomicinteger ( ) ; serializers = new hashmap < class , serializerwrapper > ( ) ; serializersarray = new serializer [ _num ] ; deserialize ( in , this ) ; }	deserializes this instance from an input stream .
public static date translatetime ( date date , timezone src , timezone dest ) { date newdate = new date ( ) ; int offset = ( dest . getoffset ( date . gettime ( ) ) - src . getoffset ( date . gettime ( ) ) ) ; newdate . settime ( date . gettime ( ) - offset ) ; return newdate ; }	translate a date & time from a users time zone to the another ( probably server ) time zone to assist in creating a simple trigger with the right date & time .
private void showpopupmenu ( final mouseevent event ) { final ctracestablefiltermenu menu = new ctracestablefiltermenu ( getfilterfield ( ) ) ; menu . show ( event . getcomponent ( ) , event . getx ( ) , event . gety ( ) ) ; }	shows a context menu depending on the event .
private taskresourcerep finishdeactivatetask ( blockconsistencygroup consistencygroup , string task ) { uri id = consistencygroup . getid ( ) ; operation op = new operation ( ) ; op . ready ( ) ; op . setprogress ( _num ) ; op . setresourcetype ( resourceoperationtypeenum . delete_consistency_group ) ; operation status = _dbclient . createtaskopstatus ( blockconsistencygroup . class , id , task , op ) ; return totask ( consistencygroup , task , status ) ; }	simply return a task that indicates that the operation completed .
public static severity parseseverity ( string str ) throws illegalseverityexception { if ( str . equalsignorecase ( messages . error ) ) { return error ; } else if ( str . equalsignorecase ( messages . warning ) ) { return warning ; } else { throw new illegalseverityexception ( ) ; } }	parse str and convert to appropriate severity .
private void restorefromkeypress ( final keyevent keyevent , final int keynumber ) { if ( keyevent . isaltdown ( ) ) { final int arrayindex = ( keynumber > _num ? keynumber : max_recent_messages ) - _num ; if ( arrayindex < recentmessages . size ( ) ) { displaymessage ( recentmessages . get ( arrayindex ) ) ; } keyevent . consume ( ) ; } }	restores message from the key event .
public void removescrollinglistener ( onwheelscrolllistener listener ) { scrollinglisteners . remove ( listener ) ; }	removes wheel scrolling listener.
public void fire ( session session , int type , boolean beforeaction ) { if ( rowbased || before != beforeaction || ( typemask & type ) == _num ) { return ; } load ( ) ; connection c2 = session . createconnection ( _bool ) ; boolean old = _bool ; if ( type != trigger . select ) { old = session . setcommitorrollbackdisabled ( _bool ) ; } value identity = session . getlastscopeidentity ( ) ; try { triggercallback . fire ( c2 , null , null ) ; } catch ( throwable e ) { throw dbexception . get ( errorcode . error_executing_trigger_3 , e , getname ( ) , triggerclassname != null ? triggerclassname : _str , e . tostring ( ) ) ; } finally { if ( session . getlasttriggeridentity ( ) != null ) { session . setlastscopeidentity ( session . getlasttriggeridentity ( ) ) ; session . setlasttriggeridentity ( null ) ; } else { session . setlastscopeidentity ( identity ) ; } if ( type != trigger . select ) { session . setcommitorrollbackdisabled ( old ) ; } } }	call the trigger class if required.
public boolean skipslocation ( string locationid ) { return _skiplocationslist . contains ( locationid ) ; }	determines if this train skips a location ( doesn ' t service the location ) .
private list < race > parseraces ( string json ) { list < race > result = new arraylist < > ( ) ; if ( json == null ) { return null ; } jsonparser parser = new jsonparser ( ) ; try { jsonobject root = ( jsonobject ) parser . parse ( json . trim ( ) ) ; jsonarray races = ( jsonarray ) root . get ( _str ) ; for ( object o : races ) { if ( o instanceof jsonobject ) { race race = parserace ( ( jsonobject ) o ) ; if ( race != null ) { result . add ( race ) ; } } } } catch ( parseexception | classcastexception | nullpointerexception ex ) { logger . warning ( _str + ex ) ; return null ; } return result ; }	parses the races from the result .
public boolean isconnected ( short nodeid ) { nodeconnection nc = connections . get ( nodeid ) ; return ( nc != null && nc . state == nodeconnectionstate . connected ) ; }	find out if a particular node is connected.
public objectname managesystemmember ( distributedmember distributedmember ) throws adminexception , malformedobjectnameexception { try { systemmember member = lookupsystemmember ( distributedmember ) ; if ( member == null ) return null ; systemmemberjmximpl jmx = ( systemmemberjmximpl ) member ; objectname oname = new objectname ( jmx . getmbeanname ( ) ) ; return oname ; } catch ( adminexception e ) { logger . warn ( e . getmessage ( ) , e ) ; throw e ; } catch ( runtimeexception e ) { logger . warn ( e . getmessage ( ) , e ) ; throw e ; } catch ( virtualmachineerror err ) { systemfailure . initiatefailure ( err ) ; throw err ; } catch ( error e ) { systemfailure . checkfailure ( ) ; logger . error ( e . getmessage ( ) , e ) ; throw e ; } }	return the objectname for the systemmembermbean representing the specified distributed member or null if the member is not found .
private void connect ( ) throws ioexception { jmxserviceurl jmxurl = new jmxserviceurl ( string . format ( fmturl , host , port ) ) ; jmxc = jmxconnectorfactory . connect ( jmxurl , null ) ; mbeanserverconnection mbeanserverconn = jmxc . getmbeanserverconnection ( ) ; try { objectname name = new objectname ( domainlist_object_name ) ; domainlistproxy = mbeanserverinvocationhandler . newproxyinstance ( mbeanserverconn , name , domainlistmanagementmbean . class , _bool ) ; name = new objectname ( virtualusertable_object_name ) ; virtualusertableproxy = mbeanserverinvocationhandler . newproxyinstance ( mbeanserverconn , name , recipientrewritetablemanagementmbean . class , _bool ) ; name = new objectname ( usersrepository_object_name ) ; usersrepositoryproxy = mbeanserverinvocationhandler . newproxyinstance ( mbeanserverconn , name , usersrepositorymanagementmbean . class , _bool ) ; name = new objectname ( mailboxcopier_object_name ) ; mailboxcopiermanagement = mbeanserverinvocationhandler . newproxyinstance ( mbeanserverconn , name , mailboxcopiermanagementmbean . class , _bool ) ; name = new objectname ( mailboxmanager_object_name ) ; mailboxmanagermanagement = mbeanserverinvocationhandler . newproxyinstance ( mbeanserverconn , name , mailboxmanagermanagementmbean . class , _bool ) ; name = new objectname ( quotamanager_object_name ) ; quotamanagement = mbeanserverinvocationhandler . newproxyinstance ( mbeanserverconn , name , quotamanagementmbean . class , _bool ) ; name = new objectname ( reindexer_object_name ) ; reindexermanagement = mbeanserverinvocationhandler . newproxyinstance ( mbeanserverconn , name , reindexermanagementmbean . class , _bool ) ; name = new objectname ( sievemanager_object_name ) ; sieverepositorymanagement = mbeanserverinvocationhandler . newproxyinstance ( mbeanserverconn , name , sieverepositorymanagementmbean . class , _bool ) ; } catch ( malformedobjectnameexception e ) { throw new runtimeexception ( _str , e ) ; } }	create a connection to the jmx agent and setup the m [ x ] bean proxies .
public static void show ( @ notnull final jcomponent datacomponent , @ nullable final jcomponent actionlistenercomponent , @ notnull final string title , @ notnull final project project , @ nullable final collection < runnable > closelisteners , @ notnull final anaction ... customactions ) { final toolwindowapi api = new toolwindowapi ( project , title ) ; final collection < runnable > closelistenerstoadd = new arraylist < runnable > ( collections . singleton ( new mytoolwindowcloser ( api ) ) ) ; if ( closelisteners != null ) { closelistenerstoadd . addall ( closelisteners ) ; } api . add ( panelwithactions . wrap ( datacomponent , closelistenerstoadd , actionlistenercomponent , customactions ) ) ; }	displays some component in the toolwindow.
public intentbuilder addemailcc ( string address ) { if ( mccaddresses == null ) { mccaddresses = new arraylist < string > ( ) ; } mccaddresses . add ( address ) ; return this ; }	add an email address to be used in the " cc " field of the final intent .
private arraylist < string > extractngrams ( ) { arraylist < string > list = new arraylist < string > ( ) ; ngram ngram = new ngram ( ) ; for ( int i = _num ; i < text . length ( ) ; ++ i ) { ngram . addchar ( text . charat ( i ) ) ; for ( int n = _num ; n <= ngram . n_gram ; ++ n ) { string w = ngram . get ( n ) ; if ( w != null && wordlangprobmap . containskey ( w ) ) list . add ( w ) ; } } return list ; }	extract n - grams from target text.
protected void updatekeys ( ) { buttoninfo [ ] buttons = navigationbuttons . loadbuttonmap ( mcontext ) ; int visiblecount = _num ; for ( int i = _num ; i < buttons . length ; i ++ ) { int id = button_ids [ i ] ; buttoninfo info = buttons [ mvertical ? buttons . length - i - _num : i ] ; keybuttonview button = ( keybuttonview ) mparent . findviewbyid ( id ) ; boolean issmallbutton = navigationbuttons . is_slot_small [ i ] ; button . setinfo ( info , mvertical , issmallbutton ) ; if ( ! info . equals ( navigationbuttons . empty ) && ! issmallbutton ) { visiblecount ++ ; } button . settranslationx ( _num ) ; mbuttonviews . set ( i , button ) ; } if ( isdevicephone ( mcontext ) ) { adjustpadding ( visiblecount ) ; } updatelowlights ( visiblecount ) ; }	updates the buttons according to the key arrangement stored in settings provider.
public static final string readstring ( byte [ ] bytes , string charset ) throws ioexception { return readstring ( bytes , _num , bytes . length , charset . forname ( charset ) ) ; }	convert a byte array to a string ; consistently uses \ n line endings in java.
private void updatecommandcache ( string group , string command , boolean neednotify ) { string oldcommand = commandcache . get ( group ) ; if ( ! command . equals ( oldcommand ) ) { commandcache . put ( group , command ) ; if ( neednotify ) { notifyexecutor . execute ( new notifycommand ( group , command ) ) ; loggerutil . info ( string . format ( _str , group , command ) ) ; } } else { loggerutil . info ( string . format ( _str , group , command ) ) ; } }	update command cache of the group . update local cache when command changed , if need notify , notify command.
public void updatelanguage ( ) { createlegendpanel ( legendpanel ) ; directorytreemodel . changeroottext ( i18n . tr ( _str ) ) ; }	resets the text of various components to the current language .
public static byte [ ] decompressforzlib ( byte [ ] bytestodecompress ) { byte [ ] returnvalues = null ; inflater inflater = new inflater ( ) ; int numberofbytestodecompress = bytestodecompress . length ; inflater . setinput ( bytestodecompress , _num , numberofbytestodecompress ) ; int buffersizeinbytes = numberofbytestodecompress ; int numberofbytesdecompressedsofar = _num ; list < byte > bytesdecompressedsofar = new arraylist < byte > ( ) ; try { while ( inflater . needsinput ( ) == _bool ) { byte [ ] bytesdecompressedbuffer = new byte [ buffersizeinbytes ] ; int numberofbytesdecompressedthistime = inflater . inflate ( bytesdecompressedbuffer ) ; numberofbytesdecompressedsofar += numberofbytesdecompressedthistime ; for ( int b = _num ; b < numberofbytesdecompressedthistime ; b ++ ) { bytesdecompressedsofar . add ( bytesdecompressedbuffer [ b ] ) ; } } returnvalues = new byte [ bytesdecompressedsofar . size ( ) ] ; for ( int b = _num ; b < returnvalues . length ; b ++ ) { returnvalues [ b ] = ( byte ) ( bytesdecompressedsofar . get ( b ) ) ; } } catch ( dataformatexception dfe ) { dfe . printstacktrace ( ) ; } inflater . end ( ) ; return returnvalues ; }	zlib decompress 2 byte.
protected boolean acceptchunk ( final ichunkmessage < ibindingset > msg ) { if ( msg == null ) throw new illegalargumentexception ( ) ; if ( ! msg . ismaterialized ( ) ) throw new illegalstateexception ( ) ; final abstractrunningquery q = getrunningquery ( msg . getqueryid ( ) ) ; if ( q == null ) { throw new illegalstateexception ( ) ; } if ( ! q . acceptchunk ( msg ) ) { msg . release ( ) ; return _bool ; } if ( ! isrunning ( ) ) { msg . release ( ) ; return _bool ; } priorityqueue . add ( q ) ; return _bool ; }	add a chunk of intermediate results for consumption by some query.
public string format ( object obj , stringbuffer toappendto ) throws illegalargumentexception { return format ( ( date ) obj , toappendto ) ; }	format a given object .
void addmember ( final typemember member ) { preconditions . checknotnull ( member , _str ) ; preconditions . checkargument ( member . getparenttype ( ) == this , _str ) ; members . add ( member ) ; }	adds a member to this base type .
public synchronized void removeincrementalclassifierlistener ( incrementalclassifierlistener cl ) { m_incrementalclassifierlisteners . remove ( cl ) ; }	remove an incremental classifier listener.
public static number asinh ( number a ) { return fastmath . asinh ( a . doublevalue ( ) ) ; }	returns the hyperbolic arc sine of the number .
private string formatnames ( string [ ] names , int startindex ) { stringbuilder sb = new stringbuilder ( ) ; if ( names != null ) { for ( string name : names ) { sb . append ( name . substring ( startindex ) ) ; sb . append ( _str ) ; } } return sb . tostring ( ) ; }	converts an array of strings to a string delimited by a new line character for display purposes.
public string lookupprefix ( string uri ) { string foundprefix = null ; enumeration prefixes = m_namespaces . keys ( ) ; while ( prefixes . hasmoreelements ( ) ) { string prefix = ( string ) prefixes . nextelement ( ) ; string uri2 = lookupnamespace ( prefix ) ; if ( uri2 != null && uri2 . equals ( uri ) ) { foundprefix = prefix ; break ; } } return foundprefix ; }	given a namespace uri , and the namespaces mappings for the current element , return the current prefix for that uri .
public void removealltrailers ( ) { trailer . clear ( ) ; firepropertychange ( trailer , null , trailer ) ; }	removes the all trailers .
private static boolean versionmatches ( integer v1 , integer v2 ) { if ( v1 == null || v1 == _num || v2 == null || v2 == _num ) { return _bool ; } return v1 . equals ( v2 ) ; }	determines if a kvno matches another kvno.
public static optional < string > packagename ( string longname ) { if ( longname . contains ( dot ) ) { return optional . of ( longname . substring ( _num , longname . lastindexof ( dot ) ) ) ; } else { return optional . empty ( ) ; } }	returns the ' package ' part of a long name.
public int [ ] [ ] e2f ( ) { int edim = tgtendexclusive - tgtstartinclusive ; int [ ] [ ] e2f = new int [ edim ] [ ] ; for ( int i = tgtstartinclusive ; i < tgtendexclusive ; ++ i ) { int localidx = i - tgtstartinclusive ; int [ ] e2fi = sentencepair . e2f ( i ) ; int srcaligndim = e2fi . length ; e2f [ localidx ] = new int [ srcaligndim ] ; if ( srcaligndim > _num ) { system . arraycopy ( e2fi , _num , e2f [ localidx ] , _num , srcaligndim ) ; for ( int j = _num ; j < srcaligndim ; ++ j ) { e2f [ localidx ] [ j ] -= srcstartinclusive ; } } } return e2f ; }	return the rule - internal target - source alignment grid .
public void readexif ( string infilename ) throws filenotfoundexception , ioexception { if ( infilename == null ) { throw new illegalargumentexception ( null_argument_string ) ; } inputstream is = null ; try { is = ( inputstream ) new bufferedinputstream ( new fileinputstream ( infilename ) ) ; readexif ( is ) ; } catch ( ioexception e ) { closesilently ( is ) ; throw e ; } is . close ( ) ; }	reads the exif tags from a file , clearing this exifinterface object ' s existing exif tags .
private void assertwriteresult ( int size ) throws ioexception { bytebuffer buf = bytebuffer . allocate ( size + _num ) ; int count = _num ; int total = _num ; long begintime = system . currenttimemillis ( ) ; while ( ( count = clientchannel . read ( buf ) ) != - _num ) { total = total + count ; if ( system . currenttimemillis ( ) - begintime > _num ) { break ; } } assertequals ( total , size ) ; buf . flip ( ) ; for ( int i = _num ; i < count ; i ++ ) { assertequals ( ( byte ) i , buf . get ( i ) ) ; } }	uses socketchannel . read ( bytebuffer ) to verify write result .
public static boolean isfileuploadavailable ( final boolean needscorrectmimetype ) { if ( build . version . sdk_int == _num ) { final string platformversion = ( build . version . release == null ) ? _str : build . version . release ; return ! needscorrectmimetype && ( platformversion . startswith ( _str ) || platformversion . startswith ( _str ) ) ; } else { return _bool ; } }	returns whether file uploads can be used on the current device ( generally all platform versions except for 4.
@ override public string tostring ( ) { if ( m_bgeneratenet ) { return toxmlbif03 ( ) ; } return m_instances . tostring ( ) ; }	returns either the net ( if bif format ) or the generated instances.
private boolean menuitemaction ( int screenx , int screeny , int action ) { listview listview = mappmenu . getpopup ( ) . getlistview ( ) ; arraylist < view > itemviews = new arraylist < view > ( ) ; for ( int i = _num ; i < listview . getchildcount ( ) ; ++ i ) { boolean hasimagebuttons = _bool ; if ( listview . getchildat ( i ) instanceof linearlayout ) { linearlayout layout = ( linearlayout ) listview . getchildat ( i ) ; for ( int j = _num ; j < layout . getchildcount ( ) ; ++ j ) { itemviews . add ( layout . getchildat ( j ) ) ; if ( layout . getchildat ( j ) instanceof imagebutton ) hasimagebuttons = _bool ; } } if ( ! hasimagebuttons ) itemviews . add ( listview . getchildat ( i ) ) ; } boolean didperformclick = _bool ; for ( int i = _num ; i < itemviews . size ( ) ; ++ i ) { view itemview = itemviews . get ( i ) ; boolean shouldperform = itemview . isenabled ( ) && itemview . isshown ( ) && getscreenvisiblerect ( itemview ) . contains ( screenx , screeny ) ; switch ( action ) { case item_action_highlight : itemview . setpressed ( shouldperform ) ; break ; case item_action_perform : if ( shouldperform ) { itemview . performclick ( ) ; didperformclick = _bool ; } break ; case item_action_clear_highlight_all : itemview . setpressed ( _bool ) ; break ; default : assert _bool ; break ; } } return didperformclick ; }	performs the specified action on the menu item specified by the screen coordinate position .
public void toggle ( jfxdrawer drawer ) { if ( ! drawers . contains ( drawer ) ) adddrawer ( drawer ) ; if ( drawer . isshown ( ) || drawer . isshowing ( ) ) drawer . close ( ) ; else { updatedrawerposition ( drawer ) ; drawer . open ( ) ; } }	toggle a drawer in the stack.
public static boolean isvmwarevapp ( ) { if ( isvmwarevapp != null ) { log . info ( _str , isvmwarevapp . booleanvalue ( ) ) ; return isvmwarevapp . booleanvalue ( ) ; } final string [ ] cmd = { get_ovf_property_cmd , is_vapp } ; exec . result result = exec . sudo ( cmd_timeout , cmd ) ; if ( ! result . exitednormally ( ) ) { log . error ( _str , result . getstderror ( ) ) ; throw new illegalstateexception ( _str ) ; } if ( result . getexitvalue ( ) == _num ) { log . info ( _str ) ; isvmwarevapp = boolean . true ; return isvmwarevapp . booleanvalue ( ) ; } log . info ( _str , result . getexitvalue ( ) ) ; isvmwarevapp = boolean . false ; return isvmwarevapp . booleanvalue ( ) ; }	check if current deployment is vmware vapp.
protected string tobase64 ( byte [ ] data ) { return base64 . encodetostring ( data , base64 . default ) ; }	return given bytes as a base64 encoded string .
@ override public string toverbosestring ( ) { final stringbuilder sb = new stringbuilder ( ) ; print ( sb , _num , verbosity . log_with_stacktrace ) ; return sb . tostring ( ) ; }	provide a verbose string of the current allocator state.
public static long quantile ( long [ ] values , double quantile ) { if ( values == null ) throw new illegalargumentexception ( _str ) ; if ( quantile < _num || quantile > _num ) throw new illegalargumentexception ( _str ) ; long [ ] copy = new long [ values . length ] ; system . arraycopy ( values , _num , copy , _num , copy . length ) ; arrays . sort ( copy ) ; int index = ( int ) ( copy . length * quantile ) ; return copy [ index ] ; }	compute the requested quantile of the given array.
public void addtreeupdate ( sldtreeupdatedinterface sldtree ) { treeupdatelist . add ( sldtree ) ; }	adds the tree update .
public static double distance ( visualitem vi1 , visualitem vi2 ) { double dx = vi1 . getx ( ) - vi2 . getx ( ) ; double dy = vi1 . gety ( ) - vi2 . gety ( ) ; return math . sqrt ( dx * dx + dy * dy ) ; }	get the distance between the x , y points of two visualitems .
@ override public void validaterequest ( genericattributeresolverequest request ) throws badattributeresolverequestexception { if ( log . isdebugenabled ( ) ) log . debug ( _str ) ; string siteid = request . getsite ( ) ; if ( null == siteid ) throw new badattributeresolverequestexception ( hdfsresourceconstants . hdfs_resource_resolve_format_hint ) ; string filepath = request . getquery ( ) ; if ( null == filepath || ! filepath . startswith ( _str ) ) throw new badattributeresolverequestexception ( hdfsresourceconstants . hdfs_resource_resolve_format_hint ) ; if ( log . isdebugenabled ( ) ) log . debug ( _str ) ; }	validate the passed request object it should have site id and file path.
public trigger when ( criterion criterion ) { if ( criterion != null ) { criterions . add ( criterion ) ; } return this ; }	set a conditional expression that restricts which rows will cause statements to be performed when the trigger is activated.
private static pair < string , string > offsetror ( final long offset , final itranslationenvironment environment , final list < reilinstruction > instructions , final string registernodevalue1 , final string registernodevalue2 , final string immediatenodevalue ) { final string address = environment . getnextvariablestring ( ) ; final string index = environment . getnextvariablestring ( ) ; final string tmpvar = environment . getnextvariablestring ( ) ; final string tmpvar1 = environment . getnextvariablestring ( ) ; final string tmpvar2 = environment . getnextvariablestring ( ) ; final string tmpvar3 = environment . getnextvariablestring ( ) ; long baseoffset = offset ; instructions . add ( reilhelpers . createbsh ( baseoffset ++ , dw , registernodevalue2 , dw , _str + integer . decode ( immediatenodevalue ) , dw , tmpvar1 ) ) ; instructions . add ( reilhelpers . createbsh ( baseoffset ++ , dw , registernodevalue2 , dw , string . valueof ( _num - integer . decode ( immediatenodevalue ) ) , dw , tmpvar2 ) ) ; instructions . add ( reilhelpers . createor ( baseoffset ++ , dw , tmpvar1 , dw , tmpvar2 , dw , tmpvar3 ) ) ; instructions . add ( reilhelpers . createand ( baseoffset ++ , dw , tmpvar3 , dw , dwordbitmask , dw , index ) ) ; instructions . add ( reilhelpers . createadd ( baseoffset ++ , dw , registernodevalue1 , dw , index , dw , tmpvar ) ) ; instructions . add ( reilhelpers . createand ( baseoffset ++ , dw , tmpvar , dw , dwordbitmask , dw , address ) ) ; return new pair < string , string > ( address , registernodevalue1 ) ; }	operation : [ < rn > , + / - < rm > , ror # < shift_imm > ] 0b11 / ror or rrx / if shift_imm = = 0 then / rrx / index = ( c flag logical_shift_left 31 ) or ( rm logical_shift_right 1 ) else / ror / index = rm rotate_right shift_imm endcase if u = = 1 then address = rn + index else / u = = 0 / address = rn - index.
public void clear ( ) { m_readmethods . clear ( ) ; m_writemethods . clear ( ) ; try { addmethods ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }	removes all current methods and adds the methods according to the.
public static string join ( charsequence delimiter , object [ ] tokens ) { stringbuilder sb = new stringbuilder ( ) ; boolean firsttime = _bool ; for ( object token : tokens ) { if ( firsttime ) { firsttime = _bool ; } else { sb . append ( delimiter ) ; } sb . append ( token ) ; } return sb . tostring ( ) ; }	returns a string containing the tokens joined by delimiters .
public static packet topacket ( bytebuffer data ) { final byte code = data . get ( ) ; final short id = ( short ) ( ( data . get ( ) ) & _num ) ; final short datalen = data . getshort ( ) ; final byte [ ] authdata = new byte [ _num ] ; data . get ( authdata ) ; final packettype type = packettype . getpackettype ( code ) ; packet pkt = null ; switch ( type ) { case access_accept : pkt = new accessaccept ( ) ; pkt . setauthenticator ( new responseauthenticator ( authdata ) ) ; break ; case access_challenge : pkt = new accesschallenge ( ) ; pkt . setauthenticator ( new responseauthenticator ( authdata ) ) ; break ; case access_reject : pkt = new accessreject ( ) ; pkt . setauthenticator ( new responseauthenticator ( authdata ) ) ; break ; case access_request : pkt = new accessrequest ( ) ; pkt . setauthenticator ( new requestauthenticator ( authdata ) ) ; break ; case unknown : default : log . log ( level . warning , _str + code + _str ) ; return null ; } pkt . setidentifier ( id ) ; attribute a = null ; while ( ( a = packetfactory . nextattribute ( data ) ) != null ) { pkt . addattribute ( a ) ; } return pkt ; }	unmarshalls from an bytebuffer the octet format of rfc 2865 and creates the corresponding package and instantiates its embedded authenticator and attributes .
public void unlockreadlocks ( ) { if ( database . ismultiversion ( ) ) { return ; } for ( int i = _num ; i < locks . size ( ) ; i ++ ) { table t = locks . get ( i ) ; if ( ! t . islockedexclusively ( ) ) { synchronized ( database ) { t . unlock ( this ) ; locks . remove ( i ) ; } i -- ; } } }	unlock all read locks.
protected void processattributes ( ) { for ( final string tag : tags ) { for ( final string inherit : inherits ) { stylesheet . addstyles ( tag , stylesheet . getstyles ( inherit ) ) ; } stylesheet . addstyles ( tag , attributes ) ; } }	adds the stored attribute values to the style sheet.
private boolean isimage ( string url ) { return url . matches ( regex . image_pattern ) ; }	verifies if the url is an image.
public static boolean pointinrotatedrect ( float [ ] point , rectf bound , float rot ) { matrix m = new matrix ( ) ; float [ ] p = arrays . copyof ( point , _num ) ; m . setrotate ( rot , bound . centerx ( ) , bound . centery ( ) ) ; matrix m0 = new matrix ( ) ; if ( ! m . invert ( m0 ) ) return _bool ; m0 . mappoints ( p ) ; return inclusivecontains ( bound , p [ _num ] , p [ _num ] ) ; }	checks if a given point is within a rotated rectangle .
@ override public void warning ( string domain , string key , xmlparseexception exception ) throws xniexception { if ( ferrorhandler != null ) { saxparseexception saxexception = createsaxparseexception ( exception ) ; try { ferrorhandler . warning ( saxexception ) ; } catch ( saxparseexception e ) { throw createxmlparseexception ( e ) ; } catch ( saxexception e ) { throw createxniexception ( e ) ; } } }	reports a warning . warnings are non - fatal and can be safely ignored by most applications .
public void modifyall ( map < string , collection < dynamicmodification > > modifications , collection < throwable > problems ) throws cannotcompileexception { for ( string classname : modifications . keyset ( ) ) { try { modify ( classname , modifications . get ( classname ) ) ; } catch ( notfoundexception e ) { log . warn ( _str + classname , e ) ; problems . add ( e ) ; } catch ( classnotfoundexception e ) { log . warn ( _str + classname , e ) ; problems . add ( e ) ; } catch ( ioexception e ) { log . warn ( _str + classname , e ) ; problems . add ( e ) ; } } }	apply several modifications to multiple classes.
public mutablelocation tomutablelocation ( world w ) { return new mutablelocation ( x , y , z , w ) ; }	creates a new mutablelocation with the coordinates of this vector .
public void readgraphics ( objectinputstream objstream ) throws ioexception { debug . message ( _str , _str ) ; try { while ( _bool ) { try { omgraphic omg = ( omgraphic ) objstream . readobject ( ) ; graphics . add ( omg ) ; } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } catch ( optionaldataexception ode ) { ode . printstacktrace ( ) ; } } } catch ( eofexception e ) { } }	read a cache of omgraphics , given a objectinputstream .
public void createtopics ( int numpartitions , int replicationfactor , set < string > topics ) { createtopics ( numpartitions , replicationfactor , topics . toarray ( new string [ topics . size ( ) ] ) ) ; }	create the specified topics .
public synchronized void removelistener ( listener l ) { listeners . remove ( l ) ; }	removes a listener receiving progress notifications .
public commandline add ( string ... args ) { if ( args != null && args . length > _num ) { collections . addall ( arguments , args ) ; } return this ; }	adds list of arguments to command line .
private void restoreicon ( backupprotos . key key , byte [ ] buffer , int datasize ) throws ioexception { if ( verbose ) log . v ( tag , _str + key . id ) ; if ( debug ) log . d ( tag , _str + buffer . length + _str + base64 . encodetostring ( buffer , _num , datasize , base64 . no_wrap ) ) ; backupprotos . resource res = unpackproto ( new backupprotos . resource ( ) , buffer , datasize ) ; if ( debug ) { log . d ( tag , _str + res . dpi + _str ) ; } bitmap icon = bitmapfactory . decodebytearray ( res . data , _num , res . data . length ) ; if ( icon == null ) { log . w ( tag , _str + key . name ) ; } else { if ( verbose ) log . v ( tag , _str + key . name ) ; miconcache . preloadicon ( componentname . unflattenfromstring ( key . name ) , icon , res . dpi , _str , muserserial , midp ) ; } }	read an icon from the stream.
public static int determineconsecutivedigitcount ( charsequence msg , int startpos ) { int count = _num ; int len = msg . length ( ) ; int idx = startpos ; if ( idx < len ) { char ch = msg . charat ( idx ) ; while ( isdigit ( ch ) && idx < len ) { count ++ ; idx ++ ; if ( idx < len ) { ch = msg . charat ( idx ) ; } } } return count ; }	determines the number of consecutive characters that are encodable using numeric compaction .
public eventstorebuilder usesslconnection ( string certificatecommonname ) { settingsbuilder . sslsettings ( sslsettings . trustcertificatecn ( certificatecommonname ) ) ; return this ; }	enables connection encryption using ssl and trusts an x.
actionmap createactionmap ( ) { actionmap map = new actionmapuiresource ( ) ; map . put ( _str , new showsystemmenuaction ( _bool ) ) ; map . put ( _str , new showsystemmenuaction ( _bool ) ) ; return map ; }	create the action map for the system menu .
protected void paintcontentborderleftedge ( graphics g , int x , int y , int w , int h , boolean drawbroken , rectangle selrect , boolean iscontentborderpainted ) { if ( iscontentborderpainted ) { g . setcolor ( selecthighlight ) ; g . fillrect ( x , y , _num , h - _num ) ; } }	draws the left edge of the border around the content area . draw broken line if selected tab is visible and adjacent to content and tabplacement is same as painted edge.
private string fieldparamcomment ( field field , string paramcomment ) { string commenttype = fieldtypecardinalitycomment ( field ) ; string comment = string . format ( _str , wrapifkeywordorbuiltin ( field . getsimplename ( ) ) , commenttype ) ; if ( paramcomment == null ) { paramcomment = documentationutil . getscopeddescription ( field ) ; } if ( ! strings . isnullorempty ( paramcomment ) ) { paramcomment = rdoccommentfixer . rdocify ( paramcomment ) ; comment += _str + paramcomment . replaceall ( _str , _str ) ; } return comment + _str ; }	returns a yard comment string for the field as a parameter to a function .
public static long periodend ( long now , long period ) { localdatetime time = localdatetime . ofepochsecond ( now / _num , _num , zoneoffset . utc ) ; long endtime = periodend ( now , period , time ) ; return endtime ; }	calculates the next period end.
public static string generatechatid ( final string receiverid , final string senderid ) { string combined = null ; if ( receiverid . compareto ( senderid ) < _num ) { combined = string . format ( locale . us , appconstants . chat_id_format , receiverid , senderid ) ; } else { combined = string . format ( locale . us , appconstants . chat_id_format , senderid , receiverid ) ; } string hashed = null ; try { hashed = utils . sha1 ( combined ) ; } catch ( final nosuchalgorithmexception e ) { hashed = combined ; } return hashed ; }	generates as chat id which will be unique for a given sender / receiver pair.
void extract ( string fname , string files [ ] ) throws ioexception { zipfile zf = new zipfile ( fname ) ; set < zipentry > dirs = newdirset ( ) ; enumeration < ? extends zipentry > zes = zf . entries ( ) ; while ( zes . hasmoreelements ( ) ) { zipentry e = zes . nextelement ( ) ; if ( files == null ) { dirs . add ( extractfile ( zf . getinputstream ( e ) , e ) ) ; } else { string name = e . getname ( ) ; for ( string file : files ) { if ( name . startswith ( file ) ) { dirs . add ( extractfile ( zf . getinputstream ( e ) , e ) ) ; break ; } } } } zf . close ( ) ; updatelastmodifiedtime ( dirs ) ; }	extracts specified entries from jar file , via zipfile .
public void remove ( menucomponent m ) { synchronized ( gettreelock ( ) ) { int index = menus . indexof ( m ) ; if ( index >= _num ) { remove ( index ) ; } } }	removes the specified menu component from this menu bar .
public void testidentity ( ) { assertnotnull ( new identitystub ( ) ) ; }	verify identity ( ) creates instance.
public void keyreleased ( final keyevent k ) { }	task to perform when keyboard button is released .
public xmlimporter ( progresslistener listener ) { progresslistener = listener ; }	creates a new importer that reports progress to the given listener .
private static treemap < integer , long > loadworkspacescreensdb ( context context ) { final contentresolver contentresolver = context . getcontentresolver ( ) ; final uri screensuri = launchersettings . workspacescreens . content_uri ; final cursor sc = contentresolver . query ( screensuri , null , null , null , null ) ; treemap < integer , long > orderedscreens = new treemap < integer , long > ( ) ; try { final int idindex = sc . getcolumnindexorthrow ( launchersettings . workspacescreens . _id ) ; final int rankindex = sc . getcolumnindexorthrow ( launchersettings . workspacescreens . screen_rank ) ; while ( sc . movetonext ( ) ) { try { long screenid = sc . getlong ( idindex ) ; int rank = sc . getint ( rankindex ) ; orderedscreens . put ( rank , screenid ) ; } catch ( exception e ) { launcher . adddumplog ( tag , _str + e , _bool ) ; } } } finally { sc . close ( ) ; } launcher . adddumplog ( tag , _str , _bool ) ; arraylist < string > orderedscreenspairs = new arraylist < string > ( ) ; for ( integer i : orderedscreens . keyset ( ) ) { orderedscreenspairs . add ( _str + i + _str + orderedscreens . get ( i ) + _str ) ; } launcher . adddumplog ( tag , _str + textutils . join ( _str , orderedscreenspairs ) , _bool ) ; return orderedscreens ; }	loads the workspace screens db into a map of rank - > screenid.
public observable < driveid > createfile ( drivefolder folder , final file file ) { return createfile ( folder , file , file . getname ( ) ) ; }	creates a file on drive.
public static void validatecontext ( accelsurface srcdata , accelsurface dstdata , region clip , composite comp , affinetransform xform , paint paint , sungraphics2d sg2d , int flags ) { bufferedcontext context = dstdata . getcontext ( ) ; context . validate ( srcdata , dstdata , clip , comp , xform , paint , sg2d , flags ) ; }	fetches the bufferedcontextcontext associated with the dst.
public labelvaluecomparator ( final locale locale ) { c = collator . getinstance ( locale ) ; }	creates a new labelvaluecomparator object .
public refresher ( glscene scene ) { preconditions . checknotnull ( scene ) ; this . scene = scene ; }	construct a refresher for the given scene .
public rect updatefastscrollerbounds ( int lasttouchy ) { minvalidaterect . set ( mbgbounds ) ; if ( isvisible ( ) ) { int edgepadding = mrv . getmaxscrollbarwidth ( ) ; int bgpadding = ( mbgoriginalsize - mtextbounds . height ( ) ) / _num ; int bgheight = mbgoriginalsize ; int bgwidth = math . max ( mbgoriginalsize , mtextbounds . width ( ) + ( _num * bgpadding ) ) ; if ( utilities . isrtl ( mres ) ) { mbgbounds . left = mrv . getbackgroundpadding ( ) . left + ( _num * mrv . getmaxscrollbarwidth ( ) ) ; mbgbounds . right = mbgbounds . left + bgwidth ; } else { mbgbounds . right = mrv . getwidth ( ) - mrv . getbackgroundpadding ( ) . right - ( _num * mrv . getmaxscrollbarwidth ( ) ) ; mbgbounds . left = mbgbounds . right - bgwidth ; } mbgbounds . top = lasttouchy - ( int ) ( fast_scroll_overlay_y_offset_factor * bgheight ) ; mbgbounds . top = math . max ( edgepadding , math . min ( mbgbounds . top , mrv . getheight ( ) - edgepadding - bgheight ) ) ; mbgbounds . bottom = mbgbounds . top + bgheight ; } else { mbgbounds . setempty ( ) ; } minvalidaterect . union ( mbgbounds ) ; return minvalidaterect ; }	updates the bounds for the fast scroller .
public void builduniqueid ( ) throws vplexapiexception { string name = getname ( ) ; if ( ! name . contains ( vplex_name_delim ) ) { s_logger . warn ( _str + name ) ; uniqueid = name ; return ; } int lastdelimindex = name . lastindexof ( vplex_name_delim ) ; string suffix = name . substring ( lastdelimindex + _num ) ; s_logger . info ( _str , name , suffix ) ; uniqueid = suffix ; }	creates a unique id for the storage system based on the vplex system name.
public static string createbase64 ( bitmap mbitmap ) { bytearrayoutputstream baos1 = new bytearrayoutputstream ( ) ; mbitmap . compress ( bitmap . compressformat . jpeg , _num , baos1 ) ; byte [ ] b1 = baos1 . tobytearray ( ) ; return base64 . encodetostring ( b1 , base64 . default ) ; }	generate base64 from bitmap image.
@ override public boolean equals ( object obj ) { if ( obj == this ) { return _bool ; } if ( ! ( obj instanceof candlestickrenderer ) ) { return _bool ; } candlestickrenderer that = ( candlestickrenderer ) obj ; if ( this . candlewidth != that . candlewidth ) { return _bool ; } if ( ! paintutilities . equal ( this . uppaint , that . uppaint ) ) { return _bool ; } if ( ! paintutilities . equal ( this . downpaint , that . downpaint ) ) { return _bool ; } if ( this . drawvolume != that . drawvolume ) { return _bool ; } if ( this . maxcandlewidthinmilliseconds != that . maxcandlewidthinmilliseconds ) { return _bool ; } if ( this . autowidthmethod != that . autowidthmethod ) { return _bool ; } if ( this . autowidthfactor != that . autowidthfactor ) { return _bool ; } if ( this . autowidthgap != that . autowidthgap ) { return _bool ; } if ( this . useoutlinepaint != that . useoutlinepaint ) { return _bool ; } if ( ! paintutilities . equal ( this . volumepaint , that . volumepaint ) ) { return _bool ; } return super . equals ( obj ) ; }	tests this renderer for equality with another object .
public headeriterator iterator ( ) { return new basiclistheaderiterator ( this . headers , null ) ; }	returns an iterator over this group of headers .
public static < t1 , t2 > void transform ( collection < t1 > from , collection < t2 > to , transformer < t1 , t2 > transformer ) { for ( t1 instance : from ) { to . add ( transformer . transform ( instance ) ) ; } }	transforms a collection of one data type into another .
public static string generatecode ( ) { return generatecode ( codesize ) ; }	generates a pseudo random string using the allowed characters.
public void flush ( ) throws java . io . ioexception { m_os . flush ( ) ; }	flush the stream . if the stream has saved any characters from the various write ( ) methods in a buffer , write them immediately to their intended destination . then , if that destination is another character or byte stream , flush it . thus one flush ( ) invocation will flush all the buffers in a chain of writers and outputstreams .
private void combineentries ( arraylist < long [ ] > list , int total ) { collections . sort ( list , this ) ; for ( int mingap = _num ; mingap < total ; mingap += mingap / _num ) { for ( int i = _num ; i < list . size ( ) - _num ; i ++ ) { long [ ] current = list . get ( i ) ; long [ ] next = list . get ( i + _num ) ; if ( current [ _num ] + mingap >= next [ _num ] ) { current [ _num ] = next [ _num ] ; list . remove ( i + _num ) ; i -- ; } } int searched = _num ; for ( long [ ] range : list ) { searched += range [ _num ] - range [ _num ] + _num ; } if ( searched > _num * total || list . size ( ) < _num ) { break ; } } }	combine entries if the size of the list is too large .
@ override public void writestring ( byte [ ] str , int offset , int length ) throws ioexception { if ( str == null ) writeint ( _num ) ; else { if ( usecompression && length >= compressor . min_size_for_deflation ) { if ( bytebuffer . length < length ) bytebuffer = new byte [ _num * length ] ; int numberofbytes = compressor . deflatestring2bytearray ( str , offset , length , bytebuffer ) ; writeint ( numberofbytes ) ; io . write ( bytebuffer , _num , math . abs ( numberofbytes ) ) ; } else { writeint ( length ) ; io . write ( str , offset , length ) ; } } }	write a string , compressed , if long enough.
public void testgeneratedomainlimit ( ) throws exception { arraylist < urlcrawldatum > list = new arraylist < urlcrawldatum > ( ) ; list . add ( createurlcrawldatum ( _str , _num , _num ) ) ; list . add ( createurlcrawldatum ( _str , _num , _num ) ) ; list . add ( createurlcrawldatum ( _str , _num , _num ) ) ; createcrawldb ( list ) ; configuration myconfiguration = new configuration ( conf ) ; myconfiguration . setint ( generator . generator_max_count , _num ) ; myconfiguration . set ( generator . generator_count_mode , generator . generator_count_value_domain ) ; path generatedsegment = generatefetchlist ( integer . max_value , myconfiguration , _bool ) ; path fetchlistpath = new path ( new path ( generatedsegment , crawldatum . generate_dir_name ) , _str ) ; arraylist < urlcrawldatum > fetchlist = readcontents ( fetchlistpath ) ; assertequals ( _num , fetchlist . size ( ) ) ; myconfiguration = new configuration ( myconfiguration ) ; myconfiguration . setint ( generator . generator_max_count , _num ) ; generatedsegment = generatefetchlist ( integer . max_value , myconfiguration , _bool ) ; fetchlistpath = new path ( new path ( generatedsegment , crawldatum . generate_dir_name ) , _str ) ; fetchlist = readcontents ( fetchlistpath ) ; assertequals ( _num , fetchlist . size ( ) ) ; myconfiguration = new configuration ( myconfiguration ) ; myconfiguration . setint ( generator . generator_max_count , _num ) ; generatedsegment = generatefetchlist ( integer . max_value , myconfiguration , _bool ) ; fetchlistpath = new path ( new path ( generatedsegment , crawldatum . generate_dir_name ) , _str ) ; fetchlist = readcontents ( fetchlistpath ) ; assertequals ( _num , fetchlist . size ( ) ) ; }	test that generator obeys the property " generator.
protected void writecolumnnotnullablestmt ( stringbuilder ddl ) { ddl . append ( _str ) ; }	prints that a column is not nullable .
private static outputstream wrapoutputstream ( final outputstream stream ) { string os = system . getproperty ( _str ) ; if ( os . startswith ( _str ) ) { try { return new windowsansioutputstream ( stream ) ; } catch ( throwable ignore ) { } return new ansioutputstream ( stream ) ; } return stream ; }	returns an ansi output stream handler.
@ override public set < location > unmarshal ( locationstype locationstype ) { set < location > locations = new linkedhashset < location > ( ) ; locations . addall ( locationstype . getrpsblastlocations ( ) ) ; locations . addall ( locationstype . gethmmer2locations ( ) ) ; locations . addall ( locationstype . gethmmer3locations ( ) ) ; locations . addall ( locationstype . getsuperfamilyhmmer3locations ( ) ) ; locations . addall ( locationstype . getfingerprintslocations ( ) ) ; locations . addall ( locationstype . getblastprodomlocations ( ) ) ; locations . addall ( locationstype . getpatternscanlocations ( ) ) ; locations . addall ( locationstype . getprofilescanlocations ( ) ) ; locations . addall ( locationstype . getphobiuslocations ( ) ) ; locations . addall ( locationstype . getcoilslocations ( ) ) ; locations . addall ( locationstype . getpantherlocations ( ) ) ; locations . addall ( locationstype . getsignalplocations ( ) ) ; locations . addall ( locationstype . gettmhmmlocations ( ) ) ; return locations ; }	map xml type to java.
public int writekey ( outputstream out ) throws ioexception { out . write ( blockbuffer , keyoffset , klen ) ; return klen ; }	writing the key to the output stream.
boolean descendsfrom ( classfile cf ) { return descendsfrom ( cf . tostring ( ) ) ; }	answers whether this class is an immediate descendant ( as subclass or as an implementation of an interface ) of the given class .
protected object writepreprocess ( object o ) throws exception { return o ; }	enables derived classes to due some pre - processing on the objects , that ' s about to be serialized.
public expressionparserbuilder withdynamics ( resolver resolver ) { dynamicsresolvers . add ( resolver ) ; return this ; }	adds the resolver as a resolver for dynamic variables ( [ variable_name ] or variable_name in the expression ) .
void warnmissingnames ( file file ) { string result = checkmissingnames ( file ) ; if ( result . equals ( _str ) ) { joptionpane . showmessagedialog ( _who , _str ) ; } else { joptionpane . showmessagedialog ( _who , result ) ; } }	check for names in programer that are not in names . xml.
public void add ( int position , wishlistitem wishlistitem ) { notifyiteminserted ( position ) ; wishlistitems . add ( position , wishlistitem ) ; }	add item to list , and notify concrete addition .
protected void printband ( byte [ ] bgrdata , int x , int y , int width , int height ) throws printerexception { mpsstream . println ( image_save ) ; int psbytesperrow = _num * width ; while ( psbytesperrow > max_psstr ) { psbytesperrow /= _num ; } mpsstream . println ( psbytesperrow + image_str ) ; mpsstream . println ( _str + width + _str + _str + height + _str + x + _str + y + _str ) ; mpsstream . println ( width + _str + height + _str + _num + _str + width + _str + _str + - height + _str + height + _str + _str ) ; int index = _num ; byte [ ] rgbdata = new byte [ width * _num ] ; try { for ( int i = _num ; i < height ; i ++ ) { index = swapbgrtorgb ( bgrdata , index , rgbdata ) ; byte [ ] encodeddata = rlencode ( rgbdata ) ; byte [ ] asciidata = ascii85encode ( encodeddata ) ; mpsstream . write ( asciidata ) ; mpsstream . println ( _str ) ; } } catch ( ioexception e ) { throw new printerioexception ( e ) ; } mpsstream . println ( image_restore ) ; }	prints the contents of the array of ints , ' data ' to the current page.
private void initpanel ( final itreenode < ctag > roottag ) { final jpanel mainpanel = new jpanel ( new borderlayout ( ) ) ; mainpanel . setborder ( new titledborder ( _str ) ) ; createtree ( roottag ) ; final jscrollpane pane = new jscrollpane ( m_tagtree ) ; pane . setverticalscrollbarpolicy ( scrollpaneconstants . vertical_scrollbar_as_needed ) ; pane . sethorizontalscrollbarpolicy ( scrollpaneconstants . horizontal_scrollbar_as_needed ) ; final jpanel anytagpanel = new jpanel ( ) ; anytagpanel . add ( m_anytagbox ) ; mainpanel . add ( pane , borderlayout . center ) ; mainpanel . add ( m_anytagbox , borderlayout . south ) ; add ( mainpanel , borderlayout . center ) ; }	initializes the gui of the tag .
public final void append ( string value ) { if ( value == null ) return ; int strlen = value . length ( ) ; if ( _num == strlen ) return ; int copyfrom = _num ; char [ ] chunk = m_array [ m_lastchunk ] ; int available = m_chunksize - m_firstfree ; while ( strlen > _num ) { if ( available > strlen ) available = strlen ; value . getchars ( copyfrom , copyfrom + available , m_array [ m_lastchunk ] , m_firstfree ) ; strlen -= available ; copyfrom += available ; if ( strlen > _num ) { int i = m_array . length ; if ( m_lastchunk + _num == i ) { char [ ] [ ] newarray = new char [ i + _num ] [ ] ; system . arraycopy ( m_array , _num , newarray , _num , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastchunk ] ; if ( chunk == null ) { if ( m_lastchunk == _num << m_rebundlebits && m_chunkbits < m_maxchunkbits ) { m_innerfsb = new faststringbuffer ( this ) ; } chunk = m_array [ m_lastchunk ] = new char [ m_chunksize ] ; } available = m_chunksize ; m_firstfree = _num ; } } m_firstfree += available ; }	append the contents of a string onto the faststringbuffer , growing the storage if necessary.
protected void addprefixmatch ( stringbuilder sb , string surface , string analyzed , string prefixtoken ) { if ( prefixtoken . length ( ) >= surface . length ( ) ) { addwholematch ( sb , surface , analyzed ) ; return ; } sb . append ( _str ) ; sb . append ( surface . substring ( _num , prefixtoken . length ( ) ) ) ; sb . append ( _str ) ; sb . append ( surface . substring ( prefixtoken . length ( ) ) ) ; }	called while highlighting a single result , to append a matched prefix token , to the provided fragments list .
public walletdata addwallet ( final bitcoincontroller bitcoincontroller , wallet wallet , string walletfilename ) { if ( walletfilename == null ) { return null ; } for ( walletdata loopmodeldata : perwalletmodeldatalist ) { if ( walletfilename . equals ( loopmodeldata . getwalletfilename ( ) ) ) { return loopmodeldata ; } } walletdata newperwalletmodeldata = new walletdata ( ) ; newperwalletmodeldata . setwallet ( wallet ) ; newperwalletmodeldata . setwalletfilename ( walletfilename ) ; newperwalletmodeldata . setwallettabledatalist ( new arraylist < wallettabledata > ( ) ) ; if ( thereisnoactivewallet ( ) ) { perwalletmodeldatalist . remove ( activewalletmodeldata ) ; activewalletmodeldata = newperwalletmodeldata ; } perwalletmodeldatalist . add ( newperwalletmodeldata ) ; if ( wallet != null ) { wallet . addeventlistener ( bitcoincontroller ) ; } createwallettabledata ( bitcoincontroller , walletfilename ) ; createaddressbookreceivingaddresses ( walletfilename ) ; return newperwalletmodeldata ; }	add a new wallet to the list of managed wallets .
public void add ( t object ) { synchronized ( mlock ) { if ( moriginalvalues != null ) { moriginalvalues . add ( object ) ; } else { mobjects . add ( object ) ; } } if ( mnotifyonchange ) notifydatasetchanged ( ) ; }	adds the specified object at the end of the array .
public boolean equals ( object another ) { if ( another instanceof permission ) { permission p = ( permission ) another ; return permission . equals ( p . tostring ( ) ) ; } else { return _bool ; } }	this function returns true if the object passed matches the permission represented in this interface .
public static intent buildstartinterminalintent ( file script ) { final componentname componentname = constants . sl4a_service_launcher_component_name ; intent intent = new intent ( ) ; intent . setcomponent ( componentname ) ; intent . setaction ( constants . action_launch_foreground_script ) ; intent . putextra ( constants . extra_script_path , script . getabsolutepath ( ) ) ; return intent ; }	builds an intent that launches a script in a terminal .
public document loaddocument ( resource file ) throws saxexception , ioexception { domparser parser = new domparser ( ) ; inputstream in = null ; try { in = file . getinputstream ( ) ; inputsource source = new inputsource ( in ) ; parser . parse ( source ) ; } finally { ioutil . closeel ( in ) ; } return parser . getdocument ( ) ; }	load a xml document as dom representation.
public void resetfilters ( boolean enabled ) { if ( logger . isloggable ( level . fine ) ) { logger . fine ( _str + enabled ) ; } set keys = filters . keyset ( ) ; for ( iterator it = keys . iterator ( ) ; it . hasnext ( ) ; ) { string title = ( string ) it . next ( ) ; setfiltervalue ( title , enabled ) ; } updateinterface ( ) ; }	set the filters on / off so that all event handlers will return anything they have , and rebuild interface .
@ override public boolean generateeventid ( ) { return _bool ; }	eventids are generated for partitionedregion .
private void updateutility ( ) { for ( individual individual : population ) { double oldfitness = individual . getfitness ( ) ; double newfitness = fitness ( individual . getsolution ( ) , idealpoint ) ; double relativedecrease = oldfitness - newfitness ; if ( relativedecrease > _num ) { individual . setutility ( _num ) ; } else { double utility = math . min ( _num , _num * ( _num + delta / _num ) * individual . getutility ( ) ) ; individual . setutility ( utility ) ; } individual . setfitness ( newfitness ) ; } }	updates the utility of each individual .
private void writekeyswithprefix ( string prefix ) { for ( string key : keys ) { if ( key . startswith ( prefix ) ) { ps . println ( key + _str + prop . getproperty ( key ) ) ; } } ps . println ( ) ; }	writes all keys starting with the specified prefix in alphabetical order .
public list < operation > sendandwait ( list < operation > ops ) { return sendandwait ( ops , _bool ) ; }	perform given operations in parallel , then wait all ops to finish with success.
public static void copy ( byte [ ] in , outputstream out ) throws ioexception { assert . notnull ( in , _str ) ; assert . notnull ( out , _str ) ; try { out . write ( in ) ; } finally { try { out . close ( ) ; } catch ( ioexception ex ) { } } }	copy the contents of the given byte array to the given outputstream.
public action maptoxacmlaction ( string nativeactionname , string servicename ) throws xacmlexception { return null ; }	returns xacml context action.
private int nextint ( stringtokenizer tok , string errormsg ) throws saxexception { if ( ! tok . hasmoretokens ( ) ) { throw new saxexception ( errormsg ) ; } try { return integer . parseint ( tok . nexttoken ( ) ) ; } catch ( numberformatexception nfe ) { throw new saxexception ( errormsg ) ; } }	convenience method to return the next int , or throw if there are no more valid ints .
public calculable ( string id , double value ) { setid ( id ) ; setvalue ( value ) ; setwhen ( system . currenttimemillis ( ) ) ; }	create a new calculable that records the time.
public static boolean bookmarknodeexists ( context context , long nodeid ) { boolean result = chromebrowserprovidercall ( boolean . class , chromebrowserprovider . client_api_bookmark_node_exists , context , argstobundle ( nodeid ) ) ; return result != null ? result . booleanvalue ( ) : _bool ; }	verifies if a bookmark node given by its id exists in the bookmark model .
private void executetaskssimultaneouslywithbarrier ( runnable ... tasks ) throws interruptedexception { countdownlatch latch = new countdownlatch ( tasks . length ) ; for ( runnable task : tasks ) { executor . execute ( null ) ; } latch . await ( ) ; }	runs given tasks simultaneously and wait until they finish .
private boolean isoperator ( char tok ) { if ( operators . indexof ( tok ) == - _num ) { return _bool ; } return _bool ; }	returns true if a token is an operator.
protected string formatiterable ( jcdiagnostic d , iterable < ? > it , locale l ) { stringbuilder sbuf = new stringbuilder ( ) ; string sep = _str ; for ( object o : it ) { sbuf . append ( sep ) ; sbuf . append ( formatargument ( d , o , l ) ) ; sep = _str ; } return sbuf . tostring ( ) ; }	format an iterable argument of a given diagnostic .
public static moduleversion valueof ( string string ) { return parseversion ( string ) ; }	get the version from a string.
@ override public boolean equals ( object otherobj ) { if ( otherobj instanceof p2model ) { return content . equals ( ( ( p2model ) otherobj ) . content ) ; } else { return _bool ; } }	two models are equal if all their fields are equal .
public boolean showicons ( ) { return preferences . getboolean ( resources . getstring ( r . string . key_show_icons ) , boolean . parseboolean ( resources . getstring ( r . string . default_show_icons ) ) ) ; }	show icons to highlight special events.
private boolean checkforkey ( ) throws exception { string query = m_query ; query = query . replaceall ( _str , _str ) ; if ( ! query . startswith ( _str ) ) { return _bool ; } m_orderby . clear ( ) ; if ( ! m_databaseconnection . isconnected ( ) ) { m_databaseconnection . connecttodatabase ( ) ; } databasemetadata dmd = m_databaseconnection . getmetadata ( ) ; string table = endofquery ( _bool ) ; resultset rs = dmd . getprimarykeys ( null , null , table ) ; while ( rs . next ( ) ) { m_orderby . add ( rs . getstring ( _num ) ) ; } rs . close ( ) ; if ( m_orderby . size ( ) != _num ) { return _bool ; } rs = dmd . getbestrowidentifier ( null , null , table , databasemetadata . bestrowsession , _bool ) ; resultsetmetadata rmd = rs . getmetadata ( ) ; int help = _num ; while ( rs . next ( ) ) { m_orderby . add ( rs . getstring ( _num ) ) ; help ++ ; } rs . close ( ) ; if ( help == rmd . getcolumncount ( ) ) { m_orderby . clear ( ) ; } if ( m_orderby . size ( ) != _num ) { return _bool ; } return _bool ; }	checks for a unique key using the jdbc driver ' s method : getprimarykey ( ) , getbestrowidentifier ( ).
public ignitestripedthreadpoolexecutor ( int concurrentlvl , string gridname , string threadnameprefix ) { execs = new executorservice [ concurrentlvl ] ; threadfactory factory = new ignitethreadfactory ( gridname , threadnameprefix ) ; for ( int i = _num ; i < concurrentlvl ; i ++ ) execs [ i ] = executors . newsinglethreadexecutor ( factory ) ; }	create striped thread pool .
public static boolean iszip ( bufferedinputstream in ) { in . mark ( _num ) ; byte [ ] b = new byte [ _num ] ; byte [ ] zipsig = new byte [ _num ] ; zipsig [ _num ] = _num ; zipsig [ _num ] = _num ; zipsig [ _num ] = _num ; zipsig [ _num ] = _num ; try { in . read ( b , _num , _num ) ; } catch ( exception ex ) { throw new runtimeexception ( _str , ex ) ; } try { in . reset ( ) ; } catch ( exception ex ) { throw new runtimeexception ( _str , ex ) ; } return arrays . equals ( b , zipsig ) ; }	test for zip stream signature .
public list < string > extract ( configuration config ) { list < string > features = new arraylist < string > ( ) ; for ( extractor fe : extractors ) { features . add ( fe . extract ( config ) ) ; } return features ; }	extracts all feature from this configuration .
public string tostring ( ) { stringbuffer path = new stringbuffer ( ) ; if ( absolute ) path . append ( _str ) ; for ( int i = _num ; i < elements . size ( ) ; i ++ ) { if ( i > _num ) path . append ( _str ) ; path . append ( elements . get ( i ) ) ; } return path . tostring ( ) ; }	returns a full path with leading " / " if absolute .
@ override protected boolean check ( file item ) { return item . exists ( ) ; }	checks the item after obtaining from the props file.
public propertyvalueeditor ( consoleapplication app , managementcontext context ) { this . app = app ; this . context = context ; }	create a new property value editor which will read from the provided application console .
@ override public void todata ( dataoutput out ) throws ioexception { out . writeint ( maxinactiveinterval ) ; out . writelong ( lastaccessedtime ) ; synchronized ( attributes ) { out . writeint ( attributes . size ( ) ) ; for ( map . entry < string , object > entry : attributes . entryset ( ) ) { deltaevent delta = new deltaevent ( _bool , entry . getkey ( ) , entry . getvalue ( ) ) ; dataserializer . writeobject ( delta , out ) ; } } out . writeutf ( jvmownerid ) ; }	use deltaevents to propagate the actual attribute data - deltaevents turn the values into byte arrays which means that the actual domain classes are not required on the server .
public void createvictoryconditions ( ) { victory = vf . createvictory ( _str ) ; }	use victoryfactory to generate a new victorycondition checker provided that the victorycontext is saved properly , calling this method at any time is ok and should not affect anything unless the victorycondition - configoptions have changed .
public static istatus validatequalifiedmodulename ( string qualifiedname ) { string pckg = signature . getqualifier ( qualifiedname ) ; if ( ! util . isvalidpackagename ( pckg ) ) { return util . newerrorstatus ( _str ) ; } return validatesimplemodulename ( signature . getsimplename ( qualifiedname ) ) ; }	validates a fully - qualified module name.
public static < t1 , t2 > map < t1 , t2 > synchronizedmap ( ) { return collections . synchronizedmap ( new hashmap < t1 , t2 > ( ) ) ; }	creates a new synchronized map .
private final int filterstatusbytes ( byte [ ] src , byte [ ] dest , int totalbytesread , int maxpacketsize ) { final int packetscount = totalbytesread / maxpacketsize + ( totalbytesread % maxpacketsize == _num ? _num : _num ) ; for ( int packetidx = _num ; packetidx < packetscount ; ++ packetidx ) { final int count = ( packetidx == ( packetscount - _num ) ) ? ( totalbytesread % maxpacketsize ) - modem_status_header_length : maxpacketsize - modem_status_header_length ; if ( count > _num ) { system . arraycopy ( src , packetidx * maxpacketsize + modem_status_header_length , dest , packetidx * ( maxpacketsize - modem_status_header_length ) , count ) ; } } return totalbytesread - ( packetscount * _num ) ; }	filter ftdi status bytes from buffer.
public boolean contains ( string key ) { return msharedpreferences . contains ( key ) ; }	returns whether the settings contains a specific key.
int registermiss ( ) { return misses . incrementandget ( ) ; }	register a miss to this cache.
public static charsequence partialescape ( charsequence s ) { stringbuilder sb = new stringbuilder ( ) ; for ( int i = _num ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; if ( c == _str || c == _str || c == _str || c == _str || c == _str || c == _str || c == _str || c == _str || c == _str || c == _str || c == _str || c == _str || c == _str || c == _str ) { sb . append ( _str ) ; } sb . append ( c ) ; } return sb ; }	escapes all special characters except ' " ' , ' - ' , and ' + '.
public void finished ( long work , long latency ) { finishedupdater . getandincrement ( this ) ; totalworkupdater . getandadd ( this , work ) ; totalworksquaredupdater . getandadd ( this , work * work ) ; totallatencyupdater . getandadd ( this , latency ) ; totallatencysquaredupdater . getandadd ( this , latency * latency ) ; }	indicate that we have just finished an operation on this resource.
public void close ( ) throws ioexception { if ( minputstream != null ) { minputstream . close ( ) ; } else { throw new ioexception ( _str ) ; } minputstream = null ; }	closes the source file.
private windowssecuritydescriptor ( ) { this . sidlist = null ; this . aclbuffer = null ; this . sdbuffer = null ; }	creates the " null " securitydescriptor.
public void printusage ( outputstream os ) { int count = _num ; printstream out = utf8 . printstream ( os ) ; for ( string option : optionlist ) { if ( optiongroups . containskey ( count ) ) { out . println ( _str + optiongroups . get ( count ) ) ; } count ++ ; if ( unlistedoptions . contains ( option ) ) { continue ; } out . print ( _str ) ; stringbuilder buf = new stringbuilder ( ) ; buf . append ( option ) ; if ( optionextrapartsynopsismap . get ( option ) != null ) { string optionextrapartsynopsis = optionextrapartsynopsismap . get ( option ) ; buf . append ( _str ) ; buf . append ( optionextrapartsynopsis ) ; buf . append ( _str ) ; } if ( requiresargumentset . contains ( option ) ) { buf . append ( _str ) ; buf . append ( argumentdescriptionmap . get ( option ) ) ; buf . append ( _str ) ; } printfield ( out , buf . tostring ( ) , maxwidth + _num ) ; out . println ( optiondescriptionmap . get ( option ) ) ; } out . flush ( ) ; }	print command line usage information to given stream .
public void clearsharedvariables ( ) { sharedvariables . clear ( ) ; loadbuiltinsharedvariables ( ) ; }	removes all shared sharedvariables , except the predefined ones ( compress , html_escape , etc.
public final void sendpacket ( lsserverpacket bp ) { synchronized ( guard ) { if ( iswritedisabled ( ) ) { return ; } log . debug ( _str + bp ) ; sendmsgqueue . addlast ( bp ) ; enablewriteinterest ( ) ; } }	sends gsserverpacket to this client .
private static map < string , object > processsection ( string section , collection < map < string , object > > hosts , map < string , object > dflts , map < string , object > props ) throws ignitecheckedexception { if ( section == null || props == null ) return null ; if ( dflt_section . equalsignorecase ( section ) ) { if ( dflts != null ) throw new ignitecheckedexception ( _str + dflt_section + _str ) ; return props ; } else { hosts . add ( props ) ; return null ; } }	processes section of parsed ini file .
public boolean isset ( final option option ) { return options == null ? _bool : options . contains ( option ) ; }	whether the passed in option is currently set .
public void handlebutton1request ( requestinvocationevent event ) throws modelcontrolexception { list optiondata = restoreoptionsdata ( ) ; cccheckbox cbforceresetpwd = ( cccheckbox ) getchild ( cb_force_reset_pwd ) ; boolean forceresetpwd = cbforceresetpwd . ischecked ( ) ; umuserpasswordresetoptionsmodel model = ( umuserpasswordresetoptionsmodel ) getmodel ( ) ; string userid = ( string ) getpagesessionattribute ( entityeditviewbean . universal_id ) ; try { model . modifyuseroption ( optiondata , userid , forceresetpwd ) ; setinlinealertmessage ( ccalert . type_info , _str , model . getlocalizedstring ( _str ) ) ; } catch ( amconsoleexception e ) { setinlinealertmessage ( ccalert . type_error , _str , e . getmessage ( ) ) ; } forwardto ( ) ; }	handles save password options request .
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addall ( collections . list ( super . listoptions ( ) ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
@ override public boolean queuerequest ( operation op ) { authorizationcontext ctx = op . getauthorizationcontext ( ) ; if ( ctx == null ) { op . fail ( new illegalargumentexception ( _str ) ) ; return _bool ; } claims claims = ctx . getclaims ( ) ; if ( claims == null ) { op . fail ( new illegalargumentexception ( _str ) ) ; return _bool ; } string subject = claims . getsubject ( ) ; if ( subject == null ) { op . fail ( new illegalargumentexception ( _str ) ) ; return _bool ; } if ( op . haspragmadirective ( operation . pragma_directive_clear_auth_cache ) ) { return handlecacheclearrequest ( op , subject ) ; } if ( subject . equals ( systemuserservice . self_link ) ) { op . complete ( ) ; return _bool ; } if ( ctx . getresourcequeryfilter ( op . getaction ( ) ) != null ) { op . complete ( ) ; return _bool ; } return _bool ; }	the service host will invoke this method to allow a service to handle the request in - line or indicate it should be scheduled by service host .
public spannablestringbuilder ( charsequence text ) { this ( text , _num , text . length ( ) ) ; }	create a new spannablestringbuilder containing a copy of the specified text , including its spans if any .
public boolean hasextrafields ( pdxtype other ) { for ( pdxfield ft : this . fields ) { if ( ! ft . isdeleted ( ) && other . getpdxfield ( ft . getfieldname ( ) ) == null ) { return _bool ; } } return _bool ; }	return true if the this type has a field that the other type does not have .
public void put ( string id , string str ) { tab . put ( id , str ) ; if ( str . endswith ( _str ) ) { int i = str . lastindexof ( file . separator ) ; if ( i >= _num ) { tab . put ( str . substring ( i + _num , str . length ( ) - _num ) , str ) ; } } }	add a mapping from a public identifier to a path .
public static list < uri > refids ( collection < ? extends relatedresourcerep > refs ) { list < uri > ids = new arraylist < uri > ( ) ; if ( refs != null ) { for ( relatedresourcerep ref : refs ) { ids . add ( ref . getid ( ) ) ; } } return ids ; }	gets a list of ids of data objects , null safe .
public static boolean hastopcategory ( httpservletrequest request , string categoryid , list < string > pathelements ) { if ( categoryworker . iscategorytop ( request , categoryid ) ) { return _bool ; } string topcategoryid = categoryworker . gettopcategoryfromtrail ( request , pathelements ) ; if ( topcategoryid != null ) { return _bool ; } list < string > trail = categoryworker . gettrail ( request ) ; topcategoryid = categoryworker . gettopcategoryfromtrail ( request , trail ) ; if ( topcategoryid == null ) { return _bool ; } return _bool ; }	scipio : returns true if the given category or any of the path elements is a top - level category .
@ override public string append ( string path , inputstream is ) throws malformedurlexception , ioexception , authenticationexception { string resp = null ; ensurevalidtoken ( ) ; string redirecturl = null ; httpurlconnection conn = authenticatedurl . openconnection ( new url ( new url ( httpfsurl ) , messageformat . format ( _str , path ) ) , token ) ; conn . setrequestmethod ( _str ) ; conn . setinstancefollowredirects ( _bool ) ; conn . connect ( ) ; logger . info ( _str + conn . getheaderfield ( _str ) ) ; resp = result ( conn , _bool ) ; if ( conn . getresponsecode ( ) == _num ) redirecturl = conn . getheaderfield ( _str ) ; conn . disconnect ( ) ; if ( redirecturl != null ) { conn = authenticatedurl . openconnection ( new url ( redirecturl ) , token ) ; conn . setrequestmethod ( _str ) ; conn . setdooutput ( _bool ) ; conn . setdoinput ( _bool ) ; conn . setusecaches ( _bool ) ; conn . setrequestproperty ( _str , _str ) ; final int _size = is . available ( ) ; conn . setrequestproperty ( _str , _str + _size ) ; conn . setfixedlengthstreamingmode ( _size ) ; conn . connect ( ) ; outputstream os = conn . getoutputstream ( ) ; copy ( is , os ) ; is . close ( ) ; os . close ( ) ; resp = result ( conn , _bool ) ; conn . disconnect ( ) ; } return resp ; }	curl - i - x post " http : / / < host > : < port > / webhdfs / v1 / < path > ? op = append [ & buffersize = < int > ] ".
public static void cacheimgs ( string skinimgdir , iterable < string > baseimageurls ) { string skindir = getskindir ( ) ; for ( string img : baseimageurls ) { img = img . replace ( _str , skindir + _str ) ; img = img . replace ( _str , skindir + skinimgdir ) ; image . prefetch ( img ) ; } }	cache a list of images.
public void clearbuffer ( ) { buffer . clear ( ) ; }	clear the message buffer.
protected void appendstring ( final string text ) { final htmldocument doc = ( htmldocument ) textpane . getdocument ( ) ; try { final element root = doc . getparagraphelement ( _num ) ; doc . insertbeforeend ( root , text ) ; } catch ( final badlocationexception e ) { logger . error ( e , e ) ; } catch ( final ioexception e ) { logger . error ( e , e ) ; } }	append html text to the end of the content.
public void scaletosamples ( int usrsamples ) { double ratio ; ratio = ( double ) usrsamples / count ; count = _num ; for ( int i = _num ; i <= limits . length ; ++ i ) { results [ i ] = ( int ) math . round ( results [ i ] * ratio ) ; count += results [ i ] ; } }	use the current distribution but scale the samples close to the user specified one.
private void refreshselected ( int offsetx ) { int offset = ( int ) ( offsetx + mmaxoverscrolldistance ) ; int tempindex = math . round ( offset / mintervaldis ) ; tempindex = clampselectedindex ( tempindex ) ; if ( mselectedindex == tempindex ) { return ; } mselectedindex = tempindex ; if ( null != onvaluechangelistener ) { onvaluechangelistener . onchange ( this , mselectedindex , float . parsefloat ( format ( mselectedindex * mintervalvalue + mminvalue ) ) ) ; } }	refresh current selected index.
@ override @ suppresswarnings ( _str ) public void resetframe ( ) { synchronized ( lock ) { sysname . settext ( _str + counter ++ ) ; } username . settext ( null ) ; url . settext ( null ) ; stream . setselected ( _bool ) ; stream . setenabled ( _bool ) ; loopstart . setvalue ( long . valueof ( _num ) ) ; loopend . setvalue ( long . valueof ( _num ) ) ; this . newbuffer = _bool ; }	method to populate the edit buffer frame with default values.
public expectedrecords < t > repeatall ( int times ) { list < t > toappend = new arraylist < > ( ) ; for ( int i = _num ; i < times ; i ++ ) { toappend . addall ( expectedrecords ) ; } expectedrecords . addall ( toappend ) ; return this ; }	expect the current output a number of times.
protected static geopoint parsekmlcoord ( string input ) { int end1 = input . indexof ( _str ) ; int end2 = input . indexof ( _str , end1 + _num ) ; try { if ( end2 == - _num ) { double lon = double . parsedouble ( input . substring ( _num , end1 ) ) ; double lat = double . parsedouble ( input . substring ( end1 + _num , input . length ( ) ) ) ; return new geopoint ( lat , lon ) ; } else { double lon = double . parsedouble ( input . substring ( _num , end1 ) ) ; double lat = double . parsedouble ( input . substring ( end1 + _num , end2 ) ) ; double alt = double . parsedouble ( input . substring ( end2 + _num , input . length ( ) ) ) ; return new geopoint ( lat , lon , alt ) ; } } catch ( numberformatexception e ) { return null ; } catch ( indexoutofboundsexception e ) { return null ; } }	similar to geopoint . frominverteddoublestring , with exceptions handling.
@ nullable public calendar detectdate ( string input ) { checknotnull ( input ) ; time . settimezone ( gettimezone ( ) ) ; options opt = new com . sk89q . jchronic . options ( ) ; opt . setnow ( calendar . getinstance ( gettimezone ( ) ) ) ; span date = chronic . parse ( input , opt ) ; if ( date == null ) { return null ; } else { return date . getbegincalendar ( ) ; } }	detect date from a user ' s input .
public synchronized void savecommitpoint ( long indexcommitgen ) { atomicinteger reservecount = savedcommits . get ( indexcommitgen ) ; if ( reservecount == null ) reservecount = new atomicinteger ( ) ; reservecount . incrementandget ( ) ; savedcommits . put ( indexcommitgen , reservecount ) ; }	permanently prevent this commit point from being deleted.
public void removesearchable ( searchresult searchable ) { if ( searchables . contains ( searchable ) ) searchables . remove ( search ) ; }	remove a searchable item.
public static boolean is64bit ( ) { boolean is64bit = _bool ; if ( iswindows ( ) ) { is64bit = ( system . getenv ( _str ) != null ) ; } else { is64bit = ( os_arch . contains ( _str ) ) ; } return is64bit ; }	checks descriptor based on os.
private int resolvesizeandstaterespectingminsize ( int minsize , int measuredsize , int measurespec ) { if ( minsize != size_unspecified ) { final int desiredwidth = math . max ( minsize , measuredsize ) ; return resolvesizeandstate ( desiredwidth , measurespec , _num ) ; } else { return measuredsize ; } }	utility to reconcile a desired size and state , with constraints imposed by a measurespec.
public static boolean deletedirectoryandcontents ( file rootdirectory ) { if ( ( rootdirectory == null ) || ! rootdirectory . isdirectory ( ) ) { return _bool ; } try { string [ ] directorycontents = rootdirectory . list ( ) ; for ( int i = _num ; i < directorycontents . length ; i ++ ) { boolean success = deletedirectoryandcontents ( new file ( rootdirectory , directorycontents [ i ] ) ) ; if ( ! success ) { return _bool ; } } return rootdirectory . delete ( ) ; } catch ( exception e ) { logger . debug ( e . tostring ( ) + system . lineseparator ( ) + stacktrace . getstringfromstacktrace ( e ) ) ; return _bool ; } }	this is a quiet method.
public static void nanosleep ( long nanos ) throws interruptedexception { if ( thread . interrupted ( ) ) throw new interruptedexception ( ) ; if ( nanos <= _num ) { return ; } if ( nanos >= _num ) { thread . sleep ( nanos / _num , ( int ) ( nanos % _num ) ) ; } else { if ( puremode ) { thread . yield ( ) ; } else { _nanosleep ( ( int ) nanos ) ; } } }	sleeps for the specified number of nanoseconds .
int purelength ( ) { return length - delimiter . length ( ) ; }	returns the pure ( without the line delimiter ) length of this line .
private void addelements ( int value , int numberofelements ) { if ( m_firstfree + numberofelements < m_blocksize ) for ( int i = _num ; i < numberofelements ; i ++ ) { m_map0 [ m_firstfree ++ ] = value ; } else { int index = m_firstfree > > > m_shift ; int offset = m_firstfree & m_mask ; m_firstfree += numberofelements ; while ( numberofelements > _num ) { if ( index >= m_map . length ) { int newsize = index + m_numblocks ; int [ ] [ ] newmap = new int [ newsize ] [ ] ; system . arraycopy ( m_map , _num , newmap , _num , m_map . length ) ; m_map = newmap ; } int [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new int [ m_blocksize ] ; int copied = ( m_blocksize - offset < numberofelements ) ? m_blocksize - offset : numberofelements ; numberofelements -= copied ; while ( copied -- > _num ) block [ offset ++ ] = value ; ++ index ; offset = _num ; } } }	append several int values onto the vector .
public static stringbuilder formatto ( stringbuilder buf , double [ ] d , string sep ) { if ( d == null ) { return buf . append ( _str ) ; } if ( d . length == _num ) { return buf ; } buf . append ( d [ _num ] ) ; for ( int i = _num ; i < d . length ; i ++ ) { buf . append ( sep ) ; buf . append ( d [ i ] ) ; } return buf ; }	formats the double array d with the default number format .
private view fillfromleft ( int nextleft ) { mfirstposition = math . min ( mfirstposition , mselectedposition ) ; mfirstposition = math . min ( mfirstposition , mitemcount - _num ) ; if ( mfirstposition < _num ) { mfirstposition = _num ; } return fillright ( mfirstposition , nextleft ) ; }	fills the list from top to bottom , starting with mfirstposition.
public tomcatslf4jlogbackfactoryaccessor ( classloader cl ) throws classnotfoundexception , illegalaccessexception , illegalargumentexception , invocationtargetexception { class clazz = cl . loadclass ( _str ) ; method getsingleton = methodutils . getaccessiblemethod ( clazz , _str , new class [ _num ] ) ; object singleton = getsingleton . invoke ( null ) ; method getloggerfactory = methodutils . getaccessiblemethod ( clazz , _str , new class [ _num ] ) ; object loggerfactory = getloggerfactory . invoke ( singleton ) ; class loggerfactoryclass = cl . loadclass ( _str ) ; if ( ! loggerfactoryclass . isinstance ( loggerfactory ) ) { throw new runtimeexception ( _str ) ; } settarget ( loggerfactory ) ; }	attempts to initialize a tomcatslf4jlogback logger factory via the given class loader .
public quarterdateformat ( timezone zone , string [ ] quartersymbols , boolean quarterfirst ) { paramchecks . nullnotpermitted ( zone , _str ) ; this . calendar = new gregoriancalendar ( zone ) ; this . quarters = quartersymbols ; this . quarterfirst = quarterfirst ; this . numberformat = numberformat . getnumberinstance ( ) ; }	creates a new instance for the specified time zone .
public long restart ( ) { long start = _starttimenanos ; _starttimenanos = system . nanotime ( ) ; return _starttimenanos - start ; }	sets the reference time and returns the amount of time between now and the previous time the reference time was set.
private static byte [ ] stringtobytearray ( string str ) { byte [ ] result = new byte [ str . length ( ) + _num ] ; for ( int i = _num ; i < str . length ( ) ; i ++ ) { result [ i ] = ( byte ) str . charat ( i ) ; } result [ str . length ( ) ] = _num ; return result ; }	returns this java string as a null - terminated byte array.
public static boolean hasjoda ( ) { try { class . forname ( _str ) ; return _bool ; } catch ( classnotfoundexception e ) { return _bool ; } }	returns true if joda is found on classpath .
public remoteservicedescriptor ( string baseurl , httpjsonrequestfactory requestfactory ) throws illegalargumentexception { this . baseurl = baseurl ; try { baseurlurl = new url ( baseurl ) ; final string protocol = baseurlurl . getprotocol ( ) ; if ( ! ( protocol . equals ( _str ) || protocol . equals ( _str ) ) ) { throw new illegalargumentexception ( string . format ( _str , baseurl ) ) ; } } catch ( malformedurlexception e ) { throw new illegalargumentexception ( string . format ( _str , baseurl ) ) ; } this . requestfactory = requestfactory ; }	creates new descriptor of remote restful service .
private int findactivityelement ( int activityindex ) { for ( int elementindex = _num ; elementindex < mactivitylist . size ( ) ; elementindex ++ ) { if ( mactivitylist . get ( elementindex ) . mactivityindex == activityindex ) { return elementindex ; } } return - _num ; }	finds the index of the activityelement corresponding to the given activityindex .
public void mapvolumetosdc ( string volumeid , string sdcid ) throws exception { log . info ( _str ) ; string uri = scaleioconstants . getmapvolumetosdcuri ( volumeid ) ; scaleiomapvolumetosdc mapparm = new scaleiomapvolumetosdc ( ) ; mapparm . setsdcid ( sdcid ) ; mapparm . setallowmultiplemappings ( _str ) ; post ( uri . create ( uri ) , getjsonforentity ( mapparm ) ) ; }	map volume to sdc.
public void addobscuredrecipient ( string playername ) { obscuredrecipients . addelement ( playername ) ; }	internal method . not for typical use . < p > adds the given player name to the report ' s list of players who received an obscured version of this report from the server at some time in the past .
private static void replacecollapsedbyeclipsesourceroots ( element libelement , library . modifiablemodel modifiablemodel ) { string [ ] srcurlsfromclasspath = modifiablemodel . geturls ( orderroottype . sources ) ; log . asserttrue ( srcurlsfromclasspath . length <= _num ) ; final string eclipseurl = srcurlsfromclasspath . length > _num ? srcurlsfromclasspath [ _num ] : null ; for ( element r : libelement . getchildren ( srcroot_attr ) ) { final string url = r . getattributevalue ( _str ) ; final string bindattr = r . getattributevalue ( srcroot_bind_attr ) ; boolean notbind = bindattr != null && ! boolean . parseboolean ( bindattr ) ; if ( notbind ) { modifiablemodel . addroot ( url , orderroottype . sources ) ; } else if ( eclipseurl != null && areurlspointthesame ( url , eclipseurl ) && ! comparing . strequal ( url , eclipseurl ) ) { modifiablemodel . addroot ( url , orderroottype . sources ) ; if ( srcurlsfromclasspath != null && srcurlsfromclasspath . length == _num ) { modifiablemodel . removeroot ( eclipseurl , orderroottype . sources ) ; srcurlsfromclasspath = null ; } } } }	eclipse detect sources inside zip automatically while idea doesn ' t.
public static byte [ ] hextobytes ( string hexstring ) { byte [ ] result = new byte [ hexstring . length ( ) / _num ] ; for ( int i = _num ; i < result . length ; ++ i ) { int offset = i * _num ; result [ i ] = ( byte ) integer . parseint ( hexstring . substring ( offset , offset + _num ) , _num ) ; } return result ; }	takes a string in hexadecimal format and converts it to a binary byte array.
private static string replacelast ( string str , char from , char to ) { int index = str . lastindexof ( from ) ; if ( index == - _num ) return str ; return str . substring ( _num , index ) + to + str . substring ( index + _num ) ; }	replace the last occurrence of from with to.
private static void cleanstaleinitiatorreferences ( exportgroup exportgroup , dbclient dbclient ) { stringset exportgroupinitiators = exportgroup . getinitiators ( ) ; if ( ! collectionutils . isempty ( exportgroupinitiators ) && ! collectionutils . isempty ( exportgroup . getexportmasks ( ) ) ) { set < string > allmaskinitiators = new hashset < > ( ) ; for ( string mask : exportgroup . getexportmasks ( ) ) { exportmask maskobj = dbclient . queryobject ( exportmask . class , uri . create ( mask ) ) ; if ( maskobj != null && ! collectionutils . isempty ( maskobj . getinitiators ( ) ) ) { allmaskinitiators . addall ( maskobj . getinitiators ( ) ) ; } } set < string > staleinitiators = sets . difference ( exportgroupinitiators , allmaskinitiators ) ; if ( ! collectionutils . isempty ( staleinitiators ) ) { collection < uri > staleinitiatoruris = collections2 . transform ( staleinitiators , commontransformerfunctions . fctn_string_to_uri ) ; exportgroup . removeinitiators ( new arraylist < > ( staleinitiatoruris ) ) ; _log . info ( _str , staleinitiatoruris , exportgroup . getid ( ) ) ; } } }	cleans stale initiator references from export group instance.
public static < t > t findresourcebyname ( iterable < hasmetadata > entities , class < t > clazz , string name ) { if ( entities != null ) { for ( hasmetadata entity : entities ) { if ( clazz . isinstance ( entity ) && objects . equals ( name , getname ( entity ) ) ) { return clazz . cast ( entity ) ; } } } return null ; }	returns the resource of the given kind and name from the collection or null.
public static map ordinalmap ( iterator tuples , string field , comparator cmp ) { object [ ] o = ordinalarray ( tuples , field , cmp ) ; hashmap map = new hashmap ( ) ; for ( int i = _num ; i < o . length ; ++ i ) map . put ( o [ i ] , new integer ( i ) ) ; return map ; }	get map mapping from column values ( as object instances ) to their ordinal index in a sorted array .
void addlinemonitor ( linemonitor lm ) { if ( printer . trace ) printer . trace ( _str + lm + _str ) ; synchronized ( linemonitors ) { if ( linemonitors . indexof ( lm ) >= _num ) { if ( printer . trace ) printer . trace ( _str ) ; return ; } if ( printer . debug ) printer . debug ( _str + lm ) ; linemonitors . add ( lm ) ; } synchronized ( this ) { notifyall ( ) ; } if ( printer . debug ) printer . debug ( _str + linemonitors . size ( ) + _str ) ; }	add this linemonitor instance to the list of monitors.
public static string tochar ( byte b ) { if ( b >= _num ) { return character . tostring ( ( char ) b ) ; } else { return string . format ( _str , b ) ; } }	convert a byte to a character for printing . if the byte value is & lt ; 32 - and hence unprintable - the byte is returned as a two digit hex value.
public static double ptsegdist ( double x1 , double y1 , double x2 , double y2 , double px , double py ) { return math . sqrt ( ptsegdistsq ( x1 , y1 , x2 , y2 , px , py ) ) ; }	returns the distance from a point to a line segment.
methodtype asspreadertype ( class < ? > arraytype , int arraylength ) { assert ( parametercount ( ) >= arraylength ) ; int spreadpos = ptypes . length - arraylength ; if ( arraylength == _num ) return this ; if ( arraytype == object [ ] . class ) { if ( isgeneric ( ) ) return this ; if ( spreadpos == _num ) { methodtype res = genericmethodtype ( arraylength ) ; if ( rtype != object . class ) { res = res . changereturntype ( rtype ) ; } return res ; } } class < ? > elemtype = arraytype . getcomponenttype ( ) ; assert ( elemtype != null ) ; for ( int i = spreadpos ; i < ptypes . length ; i ++ ) { if ( ptypes [ i ] != elemtype ) { class < ? > [ ] fixedptypes = ptypes . clone ( ) ; arrays . fill ( fixedptypes , i , ptypes . length , elemtype ) ; return methodtype ( rtype , fixedptypes ) ; } } return this ; }	replace the last arraylength parameter types with the component type of arraytype .
public static mxicell resolve ( mxicell root , string path ) { mxicell parent = root ; string [ ] tokens = path . split ( pattern . quote ( path_separator ) ) ; for ( int i = _num ; i < tokens . length ; i ++ ) { parent = parent . getchildat ( integer . parseint ( tokens [ i ] ) ) ; } return parent ; }	returns the cell for the specified cell path using the given root as the root of the path .
private static int nextnonquoteindex ( string trimmed , int i , boolean forward ) { while ( trimmed . charat ( i ) == _str || trimmed . charat ( i ) == _str || trimmed . charat ( i ) == _str || trimmed . charat ( i ) == _str || trimmed . charat ( i ) == _str || trimmed . charat ( i ) == _str || trimmed . charat ( i ) == _str || trimmed . charat ( i ) == _str ) { if ( forward ) i ++ ; else i -- ; } return i ; }	computes the index of the next character in the given string that is not a quote , starting from given index and going either forward or backward.
public static void reset ( ) { tracestate . remove ( ) ; suspendedstate . clear ( ) ; }	this method resets the current thread , and suspended trace states , for testing purposes .
private string inclusiveslice ( ) { if ( mark >= pos ) { return _str ; } return sign . substring ( mark , pos + _num ) ; }	inclusive slice ( includes current character ).
public byte [ ] tobytecode ( ) throws ioexception , cannotcompileexception { bytearrayoutputstream barray = new bytearrayoutputstream ( ) ; dataoutputstream out = new dataoutputstream ( barray ) ; try { tobytecode ( out ) ; } finally { out . close ( ) ; } return barray . tobytearray ( ) ; }	converts this class to a class file.
public static void serializepath ( final objectoutput os , final pathiterator pi ) throws ioexception { os . writeobject ( pi . getwindingrule ( ) ) ; final list < java . io . serializable > list = new arraylist < java . io . serializable > ( ) ; while ( ! pi . isdone ( ) ) { final float [ ] array = new float [ _num ] ; final int type = pi . currentsegment ( array ) ; list . add ( type ) ; list . add ( array ) ; pi . next ( ) ; } os . writeobject ( list ) ; }	method to serialize a path . this method will iterate through the iterator passed in , and write out the base components of the path to the objectoutput.
public double calculatelocalswaptotalcapacity ( int hostcount , int hostlocalswapsize ) { double d = ( double ) ( hostcount * hostlocalswapsize ) / _num ; d *= - _num ; d = ( double ) math . round ( d * _num ) / _num ; return d ; }	calculate total amount of virtual machine vswap saved in shared storage when local vswap option is enabled.
public void parseloggcfile ( inputstream loggcfilestream , defaultmutabletreenode root ) { bufferedreader bis = new bufferedreader ( new inputstreamreader ( loggcfilestream ) ) ; vector histograms = new vector ( ) ; try { while ( bis . ready ( ) ) { bis . mark ( getmarksize ( ) ) ; string nextline = bis . readline ( ) ; if ( nextline . startswith ( _str ) ) { bis . reset ( ) ; histograms . add ( parsenextclasshistogram ( bis ) ) ; } } for ( int i = histograms . size ( ) - _num ; i >= _num ; i -- ) { defaultmutabletreenode dump = getnextdumpforhistogram ( root ) ; if ( dump != null ) { addhistogramtodump ( dump , ( histogramtablemodel ) histograms . get ( i ) ) ; } } } catch ( ioexception ex ) { ex . printstacktrace ( ) ; } }	parses a loggc file stream and reads any found class histograms and adds the to the dump store.
private void resolvetimemacro ( stringbuffer result ) { calendar calendar = new gregoriancalendar ( ) ; result . append ( calendar . get ( calendar . year ) + _str ) ; string month = calendar . get ( calendar . month ) + _num + _str ; if ( month . length ( ) < _num ) { month = _str + month ; } result . append ( month + _str ) ; string day = calendar . get ( calendar . day_of_month ) + _str ; if ( day . length ( ) < _num ) { day = _str + day ; } result . append ( day + _str ) ; int ampm = calendar . get ( calendar . am_pm ) ; string ampmstring = ampm == calendar . am ? _str : _str ; result . append ( ampmstring + _str ) ; string hour = calendar . get ( calendar . hour ) + _str ; if ( hour . length ( ) < _num ) { hour = _str + hour ; } result . append ( hour + _str ) ; string minute = calendar . get ( calendar . minute ) + _str ; if ( minute . length ( ) < _num ) { minute = _str + minute ; } result . append ( minute + _str ) ; string second = calendar . get ( calendar . second ) + _str ; if ( second . length ( ) < _num ) { second = _str + second ; } result . append ( second ) ; }	resolves the macro t by writing the current date and time in the result buffer .
public boolean isempty ( ) { synchronized ( lock ) { return annotationsdraworder . isempty ( ) ; } }	returns whether this container contains any actual annotations .
default b append8bit ( @ notnull charsequence cs , int start , int end ) throws illegalargumentexception , bufferoverflowexception , bufferunderflowexception , indexoutofboundsexception { if ( cs instanceof bytesstore ) { return write ( ( bytesstore ) cs , ( long ) start , end ) ; } for ( int i = start ; i < end ; i ++ ) { char c = cs . charat ( i ) ; if ( c > _num ) c = _str ; writebyte ( ( byte ) c ) ; } return ( b ) this ; }	append a portion of a string to the bytes in iso - 8859 - 1.
static void zero ( float [ ] [ ] array ) { for ( float [ ] afloat : array ) { arrays . fill ( afloat , - _num ) ; } }	fill a 2d array of floats with 0 . 0.
@ override public boolean contains ( point2d . double p ) { roundrectangle2d . double r = ( roundrectangle2d . double ) roundrect . clone ( ) ; double grow = attributekeys . getperpendicularhitgrowth ( this ) ; r . x -= grow ; r . y -= grow ; r . width += grow * _num ; r . height += grow * _num ; r . arcwidth += grow * _num ; r . archeight += grow * _num ; return r . contains ( p ) ; }	checks if a point2d.
private void downloadupdateprop ( final boolean initialdownload ) { if ( bootprop != null ) { serverfolder = bootprop . getproperty ( _str , clientgameconfiguration . get ( _str ) ) + _str ; string updatepropertiesfile = bootprop . getproperty ( _str , serverfolder + _str ) ; final httpclient httpclient = new httpclient ( updatepropertiesfile , initialdownload ) ; updateprop = httpclient . fetchproperties ( ) ; if ( updateprop != null && updateprop . containskey ( _str ) ) { return ; } } string updatepropertiesfile = clientgameconfiguration . get ( _str ) + _str ; httpclient httpclient = new httpclient ( updatepropertiesfile , initialdownload ) ; updateprop = httpclient . fetchproperties ( ) ; if ( updateprop != null && updateprop . containskey ( _str ) ) { return ; } updatepropertiesfile = clientgameconfiguration . get ( _str ) + _str ; httpclient = new httpclient ( updatepropertiesfile , initialdownload ) ; updateprop = httpclient . fetchproperties ( ) ; }	connects to the server and loads a property object which contains information about the files available for update .
private void mergemethodhandlestore ( final int index , final methodhandle methodhandle ) { localvariables . merge ( index , new methodhandle ( methodhandle ) , null ) ; }	merges a stored method handle to the local variables .
public final int read ( byte ba [ ] , int off , int len ) throws ioexception { return is . read ( ba , off , len ) ; }	read bytes . watch out , read may return fewer bytes than requested .
public contextsuggestfield ( string name , string value , int weight , charsequence ... contexts ) { super ( name , value , weight ) ; validate ( value ) ; this . contexts = new hashset < > ( ( contexts != null ) ? contexts . length : _num ) ; if ( contexts != null ) { collections . addall ( this . contexts , contexts ) ; } }	creates a context - enabled suggest field.
public activity put ( string key , activity activity ) { return ( activity ) m_map . put ( key , activity ) ; }	associates the given key with the given activity.
public boolean isabstract ( ) { return modifier . isabstract ( getaccessflags ( ) ) ; }	returns true for an abstract class .
public void clearcurrentrequesttimedout ( ) { if ( currentrequesttimedout != null ) currentrequesttimedout . clear ( ) ; currentrequesttimedout = null ; }	discard timed out requests in this replica.
protected void showpage ( int page ) { boolean isempty = page == page_empty ; control control = isempty ? ( control ) femptypagelabel : getcontrol ( ) ; if ( isempty ) { setcontentdescription ( _str ) ; clearviewer ( ) ; } fpagebook . showpage ( control ) ; }	shows the given page in the page book .
@ override public boolean equals ( object o ) { if ( this == o ) return _bool ; if ( o == null || getclass ( ) != o . getclass ( ) ) return _bool ; insets insets = ( insets ) o ; if ( bottom != insets . bottom ) return _bool ; if ( left != insets . left ) return _bool ; if ( right != insets . right ) return _bool ; if ( top != insets . top ) return _bool ; return _bool ; }	two insets instances are equal iff they belong to the same class and their fields are pairwise equal .
public void removedocuments ( list < query > queries ) { indexwriter writer = getwriter ( ) ; for ( query query : queries ) { try { writer . deletedocuments ( query ) ; } catch ( exception e ) { e . printstacktrace ( ) ; closewriter ( writer ) ; throw new runtimeexception ( e ) ; } } closewriter ( writer ) ; }	removes the indexes of the documents .
protected string tostring ( object parameter ) { if ( parameter == null ) { return null_str ; } try { string result = misc . getasstring ( parameter ) ; if ( result . length ( ) > default_arg_string_max_length ) { result = result . substring ( _num , default_arg_string_max_length ) + default_max_string_ending ; } return result ; } catch ( throwable e ) { return unknown ; } }	turns a single method parameter into a string.
public static secretkey generatesecretkey ( secretkeytype secretkeytype , int keysize ) throws cryptoexception { try { keygenerator keygenerator = keygenerator . getinstance ( secretkeytype . jce ( ) , bouncy_castle . jce ( ) ) ; keygenerator . init ( keysize , securerandom . getinstance ( _str ) ) ; return keygenerator . generatekey ( ) ; } catch ( generalsecurityexception ex ) { throw new cryptoexception ( messageformat . format ( res . getstring ( _str ) , secretkeytype ) , ex ) ; } }	generate a secret key .
public cml deletecml ( isicresabstractdocumentvo document ) { string id = document . getid ( ) ; reference reference = new reference ( store , id , null ) ; predicate predicate = new predicate ( new reference [ ] { reference } , null , null ) ; cmldelete delete = new cmldelete ( predicate ) ; cml cml = new cml ( ) ; cml . setdelete ( new cmldelete [ ] { delete } ) ; return cml ; }	metodo que borra un documento.
private synchronized void eval ( ) throws metadataevaluationexception { if ( cachestrategy == cachestrategy . never_cache || internalvalue . get ( ) == null ) { try { object value = lazyvalue . call ( ) ; if ( value == null ) { value = actually_null ; } internalvalue = new softreference < object > ( value ) ; } catch ( exception e ) { throw new metadataevaluationexception ( e ) ; } } }	lazily evaluates the value of this metadata item .
public void addedgetobounds ( s2point from , s2point to ) { if ( ! boundset ) { boundset = _bool ; xmin = xmax = from . x ; ymin = ymax = from . y ; zmin = zmax = from . z ; } xmin = math . min ( xmin , math . min ( to . x , from . x ) ) ; ymin = math . min ( ymin , math . min ( to . y , from . y ) ) ; zmin = math . min ( zmin , math . min ( to . z , from . z ) ) ; xmax = math . max ( xmax , math . max ( to . x , from . x ) ) ; ymax = math . max ( ymax , math . max ( to . y , from . y ) ) ; zmax = math . max ( zmax , math . max ( to . z , from . z ) ) ; double approxarclen = math . abs ( from . x - to . x ) + math . abs ( from . y - to . y ) + math . abs ( from . z - to . z ) ; if ( approxarclen < _num ) { maxdeformation = math . max ( maxdeformation , approxarclen * _num ) ; } else if ( approxarclen < _num ) { maxdeformation = math . max ( maxdeformation , approxarclen * _num ) ; } else { maxdeformation = approxarclen * _num ; } }	accumulate a bounding rectangle from provided edges .
public static string hash ( string string ) { try { messagedigest sha1 = messagedigest . getinstance ( _str ) ; sha1 . update ( string . getbytes ( _str ) ) ; return base64 . encode ( sha1 . digest ( ) ) ; } catch ( exception ex ) { debug debug = debug . getinstance ( _str ) ; if ( debug . warningenabled ( ) ) { debug . warning ( _str , ex ) ; } return null ; } }	generates a sha1 digest of the string and returns base64 encoded digest .
static list < string > readextensions ( final substringreader reader ) throws decodeexception { int length = _num ; list < string > values ; reader . skipwhitespaces ( ) ; reader . mark ( ) ; try { char c = reader . read ( ) ; if ( c == _str ) { reader . mark ( ) ; while ( reader . read ( ) != _str ) { length ++ ; } reader . reset ( ) ; values = collections . singletonlist ( reader . read ( length ) ) ; reader . read ( ) ; } else if ( c == _str ) { reader . skipwhitespaces ( ) ; reader . mark ( ) ; c = reader . read ( ) ; if ( c == _str ) { values = collections . emptylist ( ) ; } else { values = new arraylist < > ( ) ; do { reader . reset ( ) ; values . add ( readquotedstring ( reader ) ) ; reader . skipwhitespaces ( ) ; reader . mark ( ) ; } while ( reader . read ( ) != _str ) ; values = collections . unmodifiablelist ( values ) ; } } else { do { length ++ ; } while ( reader . read ( ) != _str ) ; reader . reset ( ) ; values = collections . singletonlist ( reader . read ( length ) ) ; } return values ; } catch ( final stringindexoutofboundsexception e ) { throw decodeexception . error ( err_attr_syntax_truncated_value1 . get ( ) ) ; } }	reads the value for an " extra " parameter.
private void nv21toi420semiplanar ( byte [ ] nv21bytes , byte [ ] i420bytes , int width , int height ) { system . arraycopy ( nv21bytes , _num , i420bytes , _num , width * height ) ; for ( int i = width * height ; i < nv21bytes . length ; i += _num ) { i420bytes [ i ] = nv21bytes [ i + _num ] ; i420bytes [ i + _num ] = nv21bytes [ i ] ; } }	nv21 is a 4 : 2 : 0 ycbcr , for 1 nv21 pixel : yyyyyyyy vuvu i420yuvsemiplanar is a 4 : 2 : 0 yuv , for a single i420 pixel : yyyyyyyy uvuv apply nv21 to i420yuvsemiplanar ( nv12 ) refer to https : / / wiki.
public int read ( bytebuffer dst ) throws ioexception { if ( ! dst . hasremaining ( ) ) return _num ; if ( ! ishandshakecomplete ( ) ) { if ( isblocking ( ) ) { while ( ! ishandshakecomplete ( ) ) { processhandshake ( ) ; } } else { processhandshake ( ) ; if ( ! ishandshakecomplete ( ) ) { return _num ; } } } int purged = readremaining ( dst ) ; if ( purged != _num ) return purged ; assert ( indata . position ( ) == _num ) ; indata . clear ( ) ; if ( ! incrypt . hasremaining ( ) ) incrypt . clear ( ) ; else incrypt . compact ( ) ; if ( isblocking ( ) || readengineresult . getstatus ( ) == status . buffer_underflow ) if ( socketchannel . read ( incrypt ) == - _num ) { return - _num ; } incrypt . flip ( ) ; unwrap ( ) ; int transfered = transfereto ( indata , dst ) ; if ( transfered == _num && isblocking ( ) ) { return read ( dst ) ; } return transfered ; }	blocks when in blocking mode until at least one byte has been decoded.
private list < facetresult > search ( ) throws ioexception { directoryreader indexreader = directoryreader . open ( indexdir ) ; indexsearcher searcher = new indexsearcher ( indexreader ) ; sortedsetdocvaluesreaderstate state = new defaultsortedsetdocvaluesreaderstate ( indexreader ) ; facetscollector fc = new facetscollector ( ) ; facetscollector . search ( searcher , new matchalldocsquery ( ) , _num , fc ) ; facets facets = new sortedsetdocvaluesfacetcounts ( state , fc ) ; list < facetresult > results = new arraylist < > ( ) ; results . add ( facets . gettopchildren ( _num , _str ) ) ; results . add ( facets . gettopchildren ( _num , _str ) ) ; indexreader . close ( ) ; return results ; }	user runs a query and counts facets .
public resource maprelations ( resource object , jsonobject jsonobject , list < resource > included ) throws exception { hashmap < string , string > relationshipnames = getrelationshipnames ( object . getclass ( ) ) ; for ( string relationship : relationshipnames . keyset ( ) ) { jsonobject relationjsonobject = null ; try { relationjsonobject = jsonobject . getjsonobject ( relationship ) ; } catch ( jsonexception e ) { logger . debug ( _str + relationship + _str ) ; continue ; } jsonobject relationdataobject = null ; try { relationdataobject = relationjsonobject . getjsonobject ( _str ) ; resource relationobject = factory . newobjectfromjsonobject ( relationdataobject , null ) ; relationobject = matchincludedtorelation ( relationobject , included ) ; mdeserializer . setfield ( object , relationshipnames . get ( relationship ) , relationobject ) ; } catch ( jsonexception e ) { logger . debug ( _str ) ; } jsonarray relationdataarray = null ; try { relationdataarray = relationjsonobject . getjsonarray ( _str ) ; list < resource > relationarray = factory . newobjectfromjsonarray ( relationdataarray , null ) ; relationarray = matchincludedtorelation ( relationarray , included ) ; mdeserializer . setfield ( object , relationshipnames . get ( relationship ) , relationarray ) ; } catch ( jsonexception e ) { logger . debug ( _str ) ; } } return object ; }	loops through relation json array and maps annotated objects .
public int size ( ) { return rdns . size ( ) ; }	retrieves the number of components in this ldap name .
@ override public void doinitialize ( uimacontext acontext ) throws resourceinitializationexception { db db = mongoresource . getdb ( ) ; collection = db . getcollection ( collectionname ) ; collection . createindex ( new basicdbobject ( field_unique_id , _num ) ) ; collection . createindex ( new basicdbobject ( field_publishedids , _num ) ) ; stopfeatures = new hashset < string > ( ) ; stopfeatures . add ( _str ) ; stopfeatures . add ( _str ) ; maxcontentlength = configutils . stringtointeger ( maxcontentlengthstring , _num ) ; }	get the mongodb , collection and create some indexes.
protected void drawhighfarout ( double aradius , graphics2d g2 , double xx , double m ) { double side = aradius * _num ; g2 . draw ( new line2d . double ( xx - side , m + side , xx + side , m + side ) ) ; g2 . draw ( new line2d . double ( xx - side , m + side , xx , m ) ) ; g2 . draw ( new line2d . double ( xx + side , m + side , xx , m ) ) ; }	draws a triangle to indicate the presence of far out values .
private void findlargeitemsets ( ) throws exception { arraylist < object > kminusonesets , ksets ; hashtable < itemset , integer > hashtable ; int necsupport , i = _num ; necsupport = ( int ) ( m_minsupport * m_instances . numinstances ( ) + _num ) ; ksets = aprioriitemset . singletons ( m_instances , m_treatzeroasmissing ) ; if ( m_treatzeroasmissing ) { aprioriitemset . updatecounterstreatzeroasmissing ( ksets , m_instances ) ; } else { aprioriitemset . updatecounters ( ksets , m_instances ) ; } ksets = aprioriitemset . deleteitemsets ( ksets , necsupport , m_instances . numinstances ( ) ) ; if ( ksets . size ( ) == _num ) { return ; } do { m_ls . add ( ksets ) ; kminusonesets = ksets ; ksets = aprioriitemset . mergeallitemsets ( kminusonesets , i , m_instances . numinstances ( ) ) ; hashtable = aprioriitemset . gethashtable ( kminusonesets , kminusonesets . size ( ) ) ; m_hashtables . add ( hashtable ) ; ksets = aprioriitemset . pruneitemsets ( ksets , hashtable ) ; if ( m_treatzeroasmissing ) { aprioriitemset . updatecounterstreatzeroasmissing ( ksets , m_instances ) ; } else { aprioriitemset . updatecounters ( ksets , m_instances ) ; } ksets = aprioriitemset . deleteitemsets ( ksets , necsupport , m_instances . numinstances ( ) ) ; i ++ ; } while ( ksets . size ( ) > _num ) ; }	method that finds all large itemsets for the given set of instances .
public boolean isinallowed ( int x , int y ) { for ( shape r : arrivingbarriers ) { if ( r . contains ( x , y ) ) { return _bool ; } } return _bool ; }	check if teleporting to a location is allowed .
public void removeplugininterface ( string interfacename ) throws smsexception , ssoexception { smsentry . validatetoken ( token ) ; validateserviceschemamanagerimpl ( ) ; document schemadoc = ssm . getdocumentcopy ( ) ; node schemanode = xmlutils . getrootnode ( schemadoc , smsutils . schema ) ; node pluginnode = xmlutils . getnamedchildnode ( schemanode , smsutils . plugin_interface , smsutils . name , interfacename ) ; if ( pluginnode != null ) { schemanode . removechild ( pluginnode ) ; replaceschema ( schemadoc ) ; } }	removes the plugin interface object from the service schema .
private boolean issamefile ( path first , path second ) throws ioexception { boolean samefilesize = files . size ( first ) == files . size ( second ) ; if ( ! samefilesize ) { return _bool ; } byte [ ] firstbytes = files . readallbytes ( first ) ; byte [ ] secondbytes = files . readallbytes ( second ) ; return arrays . equals ( firstbytes , secondbytes ) ; }	compares the content of two paths by comparing them.
public static org . opcfoundation . ua . transport . security . keypair loadkeypairfromprotectedstore ( string storelocation , string alias , string storepw , string privatepw ) throws keystoreexception , ioexception , nosuchalgorithmexception , certificateexception , unrecoverablekeyexception { keystore store = null ; store = keystore . getinstance ( _str ) ; file keystorefile = new file ( storelocation ) ; fileinputstream in = new fileinputstream ( keystorefile ) ; store . load ( in , storepw . tochararray ( ) ) ; in . close ( ) ; x509certificate cert = ( x509certificate ) store . getcertificate ( alias ) ; rsaprivatekey key = ( rsaprivatekey ) store . getkey ( alias , privatepw . tochararray ( ) ) ; return new org . opcfoundation . ua . transport . security . keypair ( new cert ( cert ) , new privkey ( key ) ) ; }	load a keypair from a java key store .
@ override public graphquery hasnot ( final string key , final object value ) { criteria . add ( new hasnot ( key , value ) ) ; return this ; }	filter out elements that have a property value equal to provided value.
private void initcomputeprogram ( ) { intbuffer workgroupsize = bufferutils . createintbuffer ( _num ) ; glgetprogramiv ( computeprogram , gl_compute_work_group_size , workgroupsize ) ; workgroupsizex = workgroupsize . get ( _num ) ; workgroupsizey = workgroupsize . get ( _num ) ; int boxesresourceindex = glgetprogramresourceindex ( computeprogram , gl_shader_storage_block , _str ) ; intbuffer props = bufferutils . createintbuffer ( _num ) ; intbuffer params = bufferutils . createintbuffer ( _num ) ; props . put ( _num , gl_buffer_binding ) ; glgetprogramresourceiv ( computeprogram , gl_shader_storage_block , boxesresourceindex , props , null , params ) ; boxesssbobinding = params . get ( _num ) ; int uniformsresourceindex = glgetprogramresourceindex ( computeprogram , gl_uniform_block , _str ) ; glgetprogramresourceiv ( computeprogram , gl_uniform_block , uniformsresourceindex , props , null , params ) ; computeubobinding = params . get ( _num ) ; int loc = glgetuniformlocation ( computeprogram , _str ) ; glgetuniformiv ( computeprogram , loc , params ) ; framebufferimagebinding = params . get ( _num ) ; loc = glgetuniformlocation ( computeprogram , _str ) ; glgetuniformiv ( computeprogram , loc , params ) ; worldpositionimagebinding = params . get ( _num ) ; loc = glgetuniformlocation ( computeprogram , _str ) ; glgetuniformiv ( computeprogram , loc , params ) ; worldnormalimagebinding = params . get ( _num ) ; }	initialize the compute shader .
tsresponse ( byte [ ] tsreply ) throws ioexception { parse ( tsreply ) ; }	constructs an object to store the response to a timestamp request .
public static void executecommand ( processbuilder p ) throws ioexception { process proc = p . start ( ) ; try ( bufferedreader stdinput = new bufferedreader ( new inputstreamreader ( proc . getinputstream ( ) ) ) ; bufferedreader stderror = new bufferedreader ( new inputstreamreader ( proc . geterrorstream ( ) ) ) ) { logger . info ( _str ) ; string s ; while ( ( s = stdinput . readline ( ) ) != null ) { logger . info ( s ) ; } logger . info ( _str ) ; while ( ( s = stderror . readline ( ) ) != null ) { logger . info ( s ) ; } } }	method to execute process.
public boolean pagesetupdialog ( printerjob job ) { printrequestattributeset prats = getprintrequestattributeset ( ) ; pageformat pf = job . pagedialog ( prats ) ; setprintrequestattributeset ( prats ) ; return _bool ; }	show dialog and set paper.
public static void assertnotequals ( bufferedimage image1 , bufferedimage image2 ) { assertnotequals ( _str , image1 , image2 ) ; }	fails if the contents of two images are equal .
public depend ( pathimpl source , long digest , boolean requiresource ) { this ( source ) ; long newdigest = source . getcrc64 ( ) ; _requiresource = requiresource ; if ( newdigest == digest ) { } else if ( ! requiresource && newdigest == _num ) { } else if ( newdigest == _num ) { if ( log . isloggable ( level . fine ) ) log . fine ( _source . getnativepath ( ) + _str ) ; _isdigestmodified = _bool ; } else { _isdigestmodified = _bool ; } }	create a new dependency with a given digest .
public static boolean stringtofile ( final string data , final file targetfile , final boolean doappend ) { if ( targetfile == null || ! iswritable ( targetfile , _bool ) ) { log . e ( fileutils . class , _str ) ; return _bool ; } boolean issucceed = _bool ; try { final filewriter out = new filewriter ( targetfile , doappend ) ; out . write ( data ) ; out . flush ( ) ; out . close ( ) ; } catch ( ioexception e ) { issucceed = _bool ; } return issucceed ; }	writes a string to a file .
@ override public void cascaderegisternewifrequired ( object object , unitofworkimpl uow , map visitedobjects ) { cascaderegisternewifrequired ( object , uow , visitedobjects , _bool ) ; }	internal : cascade registernew for create through mappings that require the cascade.
public static boolean parsebool ( string s ) { if ( s != null ) { if ( s . startswith ( _str ) || s . startswith ( _str ) || s . startswith ( _str ) ) { return _bool ; } if ( s . startswith ( _str ) || s . startswith ( _str ) || s . equals ( _str ) ) { return _bool ; } } throw new solrexception ( solrexception . errorcode . bad_request , _str + s ) ; }	how to transform a string into a boolean.
private static void readdna ( string filename ) { try { linenumberreader in = new linenumberreader ( new filereader ( filename ) ) ; processoneline ( in , _str , compilationrates ) ; processoneline ( in , _str , speeduprates ) ; } catch ( exception e ) { e . printstacktrace ( ) ; vm . sysfail ( _str ) ; } }	read a serialized representation of the dna info.
public void test_of_eeee ( ) { enumset < enumwithinnerclass > enumset = enumset . of ( enumwithinnerclass . a , enumwithinnerclass . b , enumwithinnerclass . c , enumwithinnerclass . d ) ; assertequals ( _str , _num , enumset . size ( ) ) ; asserttrue ( _str , enumset . contains ( enumwithinnerclass . a ) ) ; asserttrue ( _str , enumset . contains ( enumwithinnerclass . d ) ) ; try { enumset . of ( ( enumwithinnerclass ) null , null , null , null ) ; fail ( _str ) ; } catch ( nullpointerexception npe ) { } enumset < hugeenumwithinnerclass > hugeenumset = enumset . of ( hugeenumwithinnerclass . a , hugeenumwithinnerclass . b , hugeenumwithinnerclass . c , hugeenumwithinnerclass . d ) ; assertequals ( _num , hugeenumset . size ( ) ) ; asserttrue ( hugeenumset . contains ( hugeenumwithinnerclass . a ) ) ; asserttrue ( hugeenumset . contains ( hugeenumwithinnerclass . d ) ) ; try { enumset . of ( ( hugeenumwithinnerclass ) null , null , null , null ) ; fail ( _str ) ; } catch ( nullpointerexception npe ) { } }	java . util . enumset # of ( e , e , e , e ).
builder ( url swaggerurl ) { try { this . swaggerlocation = swaggerurl . touri ( ) ; } catch ( urisyntaxexception e ) { throw new illegalargumentexception ( _str , e ) ; } this . swagger = readswagger ( swaggerurl . tostring ( ) ) ; }	creates a builder from a remote url .
@ override public void onsaveinstancestate ( @ nonnull bundle savedinstancestate ) { savedinstancestate . putparcelable ( location_key , currentlocation ) ; if ( lastlocationupdatetime != null ) { savedinstancestate . putlong ( last_location_update_time_string_key , lastlocationupdatetime . gettime ( ) ) ; } if ( lastwifiscantime != null ) { savedinstancestate . putlong ( last_wifi_scan_time_string_key , lastwifiscantime . gettime ( ) ) ; } savedinstancestate . putboolean ( logging_enabled_key , loggingenabled ) ; super . onsaveinstancestate ( savedinstancestate ) ; }	stores activity data in the bundle .
public static string removeemptylines ( string text ) { text = text . replaceall ( _str + chineselanguageconstants . space [ _num ] + _str , _str ) ; text = text . replaceall ( _str + chineselanguageconstants . space [ _num ] + _str , _str ) ; return text ; }	remove empty lines . an empty line means a line ends in \ n or \ r \ n and contains only white space characters , or no characters at all .
public void keeponly ( set < ivarabstraction > usefulpointers ) { set < ivarabstraction > reps = new hashset < ivarabstraction > ( ) ; for ( ivarabstraction pn : usefulpointers ) { reps . add ( pn . getrepresentative ( ) ) ; } usefulpointers . addall ( reps ) ; reps = null ; for ( ivarabstraction pn : pointers ) { if ( ! usefulpointers . contains ( pn ) ) pn . deleteall ( ) ; } system . gc ( ) ; }	keep only the pointers the users are interested in.
public static string encryptcfb ( final byte [ ] concatenatedhashvalue , final long turnovercounter , final secretkey symmetrickey , int turnovercounterlengthinbytes ) throws nosuchalgorithmexception , nosuchproviderexception , nosuchpaddingexception , invalidkeyexception , invalidalgorithmparameterexception , illegalblocksizeexception , badpaddingexception { final bytebuffer bytebufferiv = bytebuffer . allocate ( _num ) ; bytebufferiv . put ( concatenatedhashvalue ) ; final byte [ ] iv = bytebufferiv . array ( ) ; final bytebuffer bytebufferdata = bytebuffer . allocate ( _num ) ; bytebufferdata . putlong ( turnovercounter ) ; final byte [ ] data = bytebufferdata . array ( ) ; byte [ ] turnovercounterbyterep = get2complementrepforlong ( turnovercounter , turnovercounterlengthinbytes ) ; system . arraycopy ( turnovercounterbyterep , _num , data , _num , turnovercounterbyterep . length ) ; final ivparameterspec ivspec = new ivparameterspec ( iv ) ; final cipher cipher = cipher . getinstance ( _str , _str ) ; cipher . init ( cipher . encrypt_mode , symmetrickey , ivspec ) ; final byte [ ] encryptedturnovervaluecomplete = cipher . dofinal ( data ) ; final byte [ ] encryptedturnovervalue = new byte [ turnovercounterlengthinbytes ] ; system . arraycopy ( encryptedturnovervaluecomplete , _num , encryptedturnovervalue , _num , turnovercounterlengthinbytes ) ; final string base64encryptedturnovervalue = cashboxutils . base64encode ( encryptedturnovervalue , _bool ) ; return base64encryptedturnovervalue ; }	method for aes encryption in cfb mode ( for the first block cfb and ctr are exactly the same.
string publicnamefromdiskname ( string diskname ) { if ( ! shoulddisknamebevisible ( diskname ) ) { throw new illegalargumentexception ( _str + diskname ) ; } return diskname . substring ( mfileprefix . length ( ) , diskname . length ( ) ) ; }	returns the public name ( everything following the prefix ) of the given diskname .
public double [ ] predict ( fvec feat ) { return predict ( feat , _bool ) ; }	generates predictions for given feature vector .
public static < a > a [ ] append ( final a [ ] a , final a [ ] b ) { final int alen = a . length ; final int blen = b . length ; final a [ ] res = arrays . copyof ( a , alen + blen ) ; system . arraycopy ( b , _num , res , alen , blen ) ; return res ; }	append two arrays creating a new array for the result .
public boolean addlistener ( @ notnull softwrapawaredocumentparsinglistener listener ) { return mylisteners . add ( listener ) ; }	registers given listener within the current manager .
private void assertarrayequals ( double [ ] expected , double [ ] actual , double delta , boolean checknan ) { assert . assertequals ( expected . length , actual . length ) ; for ( int index = _num ; index < actual . length ; index ++ ) { double d1 = expected [ index ] ; double d2 = actual [ index ] ; if ( double . isnan ( d1 ) || double . isnan ( d2 ) ) { if ( checknan ) { assert . asserttrue ( double . isnan ( d1 ) == double . isnan ( d2 ) ) ; } assert . asserttrue ( _bool ) ; } else { assert . assertequals ( d1 , d2 , delta ) ; } } }	this is an assertion for a special case when a loss full algorithm is used and a quantification with null checks.
protected void addtopopulation ( solution newsolution ) { list < integer > dominates = new arraylist < integer > ( ) ; boolean dominated = _bool ; for ( int i = _num ; i < population . size ( ) ; i ++ ) { int flag = dominancecomparator . compare ( newsolution , population . get ( i ) ) ; if ( flag < _num ) { dominates . add ( i ) ; } else if ( flag > _num ) { dominated = _bool ; } } if ( ! dominates . isempty ( ) ) { population . remove ( dominates . get ( prng . nextint ( dominates . size ( ) ) ) ) ; population . add ( newsolution ) ; } else if ( ! dominated ) { population . remove ( prng . nextint ( population . size ( ) ) ) ; population . add ( newsolution ) ; } }	adds the new solution to the population if is non - dominated with the current population , removing either a randomly - selected dominated solution or a non - dominated solution .
private string generateblendmodeimport ( blendmode blendmode ) { if ( blendmode == blendmode . color ) return _str ; else if ( blendmode == blendmode . colorburn ) return _str ; else if ( blendmode == blendmode . colordodge ) return _str ; else if ( blendmode == blendmode . exclusion ) return _str ; else if ( blendmode == blendmode . hue ) return _str ; else if ( blendmode == blendmode . luminosity ) return _str ; else if ( blendmode == blendmode . saturation ) return _str ; else if ( blendmode == blendmode . softlight ) return _str ; else return null ; }	generates a snippet of actionscript source code that imports the correct class for the corresponding blend mode .
public static string parseinttometricsuffix ( int x ) { string xint = string . valueof ( x ) ; if ( xint . endswith ( _str ) ) { xint = xint . replaceall ( _str , _str ) ; } else if ( xint . endswith ( _str ) ) { xint = xint . replaceall ( _str , _str ) ; } return xint ; }	convert 000 and 000 , 000 to k and m suffix.
public smauthstatus query ( string parameter , string secret , smauthquerycode request , smauthqueryresponse response ) { if ( null == response ) { return smauthstatus . smauth_failure ; } if ( smauthquerycode . smauth_query_description == request ) { response . setresponsebuffer ( scheme_description ) ; response . setresponsecode ( scheme_version ) ; } else if ( smauthquerycode . smauth_query_credentials_req == request ) { response . setresponsecode ( smauthqueryresponse . smauth_cred_basic ) ; } else { return smauthstatus . smauth_failure ; } return smauthstatus . smauth_success ; }	returns information about the authentication scheme .
protected void addalltransitivejars ( wararchivemerger wam ) throws mojoexecutionexception { dependencycalculator dc = new dependencycalculator ( artifactfactory , resolver , localrepository , remoterepositories , mavenproject , mavenprojectbuilder , installer , container ) ; try { for ( file f : dc . execute ( ) ) { wam . addmergeitem ( f ) ; } } catch ( exception ex ) { throw new mojoexecutionexception ( _str , ex ) ; } }	add all jar files into the war file , calculated transitively and resolved in the normal ' maven ' way ( i.
private void add ( int col , graphicalnode graphicalnode ) { mygraphicalnodes . remove ( graphicalnode ) ; if ( nbcols - _num < col ) { nbcols = col + _num ; } int row = _num ; while ( isoccupied ( row , col ) ) { row ++ ; } graphicalnode . row = row ; graphicalnode . col = col ; mygraphicalnodes . add ( graphicalnode ) ; }	ajoute la graphical node dans la map position / liste des successeurs.
private int addtonalcomponents ( float [ ] spectrum , int numcomponents , tonalcomponent [ ] components ) { int lastpos = - _num ; for ( int i = _num ; i < numcomponents ; i ++ ) { lastpos = math . max ( components [ i ] . pos + components [ i ] . numcoefs , lastpos ) ; for ( int j = _num ; j < components [ i ] . numcoefs ; j ++ ) { spectrum [ components [ i ] . pos + j ] += components [ i ] . coef [ j ] ; } } return lastpos ; }	combine the tonal band spectrum and regular band spectrum.
public static list < userlayer > extractuserlayers ( styledlayerdescriptor sld ) { list < userlayer > userlayerlist = new arraylist < userlayer > ( ) ; if ( sld != null ) { for ( styledlayer layer : sld . layers ( ) ) { if ( layer instanceof userlayer ) { userlayer userlayer = ( userlayer ) layer ; userlayerlist . add ( userlayer ) ; } } } return userlayerlist ; }	extract user layers from an sld .
public static void closequiet ( @ nullable selector rsrc ) { if ( rsrc != null ) try { if ( rsrc . isopen ( ) ) rsrc . close ( ) ; } catch ( ioexception ignored ) { } }	quietly closes given resource ignoring possible checked exception .
public static boolean createcompactionrequiredfile ( string metafolderpath , compactiontype compactiontype ) { string statusfile ; if ( compactiontype . equals ( compactiontype . minor_compaction ) ) { statusfile = metafolderpath + carboncommonconstants . file_separator + carboncommonconstants . minorcompactionrequiredfile ; } else { statusfile = metafolderpath + carboncommonconstants . file_separator + carboncommonconstants . majorcompactionrequiredfile ; } try { if ( ! filefactory . isfileexist ( statusfile , filefactory . getfiletype ( statusfile ) ) ) { if ( filefactory . createnewfile ( statusfile , filefactory . getfiletype ( statusfile ) ) ) { logger . info ( _str + statusfile ) ; return _bool ; } else { logger . error ( _str + statusfile ) ; return _bool ; } } else { logger . info ( _str + statusfile + _str ) ; } } catch ( ioexception e ) { logger . error ( _str + e . getmessage ( ) ) ; } return _bool ; }	creation of the compaction request if someother compaction is in progress .
private boolean allownotificationemission ( objectname name , targetednotification tn ) { try { if ( checknotificationemission ) { checkmbeanpermission ( name , _str ) ; } if ( notificationaccesscontroller != null ) { notificationaccesscontroller . fetchnotification ( connectionid , name , tn . getnotification ( ) , getsubject ( ) ) ; } return _bool ; } catch ( securityexception e ) { if ( logger . debugon ( ) ) { logger . debug ( _str , _str + tn . getnotification ( ) + _str + _str ) ; } return _bool ; } catch ( exception e ) { if ( logger . debugon ( ) ) { logger . debug ( _str , _str + tn . getnotification ( ) + _str + _str + e ) ; } return _bool ; } }	check if the caller has the right to get the following notifications .
public void updatethroughput ( long currenttime ) { throughputcalculationlock . lock ( ) ; try { int interval = ( int ) ( currenttime - lastthroughputcalculationtime ) ; long mininterval = getthroughputcalculationintervalinmillis ( ) ; if ( ( mininterval == _num ) || ( interval < mininterval ) ) { return ; } long readbytes = this . readbytes ; long writtenbytes = this . writtenbytes ; long readmessages = this . readmessages ; long writtenmessages = this . writtenmessages ; readbytesthroughput = ( readbytes - lastreadbytes ) * _num / interval ; writtenbytesthroughput = ( writtenbytes - lastwrittenbytes ) * _num / interval ; readmessagesthroughput = ( readmessages - lastreadmessages ) * _num / interval ; writtenmessagesthroughput = ( writtenmessages - lastwrittenmessages ) * _num / interval ; if ( readbytesthroughput > largestreadbytesthroughput ) { largestreadbytesthroughput = readbytesthroughput ; } if ( writtenbytesthroughput > largestwrittenbytesthroughput ) { largestwrittenbytesthroughput = writtenbytesthroughput ; } if ( readmessagesthroughput > largestreadmessagesthroughput ) { largestreadmessagesthroughput = readmessagesthroughput ; } if ( writtenmessagesthroughput > largestwrittenmessagesthroughput ) { largestwrittenmessagesthroughput = writtenmessagesthroughput ; } lastreadbytes = readbytes ; lastwrittenbytes = writtenbytes ; lastreadmessages = readmessages ; lastwrittenmessages = writtenmessages ; lastthroughputcalculationtime = currenttime ; } finally { throughputcalculationlock . unlock ( ) ; } }	updates the throughput counters .
public list < verificationok > verify ( x509certificate signcert , x509certificate issuercert , date signdate ) throws generalsecurityexception , ioexception { rootstoreverifier rootstoreverifier = new rootstoreverifier ( verifier ) ; rootstoreverifier . setrootstore ( rootstore ) ; crlverifier crlverifier = new crlverifier ( rootstoreverifier , getcrlsfromdss ( ) ) ; crlverifier . setrootstore ( rootstore ) ; crlverifier . setonlinecheckingallowed ( latestrevision || onlinecheckingallowed ) ; ocspverifier ocspverifier = new ocspverifier ( crlverifier , getocspresponsesfromdss ( ) ) ; ocspverifier . setrootstore ( rootstore ) ; ocspverifier . setonlinecheckingallowed ( latestrevision || onlinecheckingallowed ) ; return ocspverifier . verify ( signcert , issuercert , signdate ) ; }	verifies certificates against a list of crls and ocsp responses .
protected boolean [ ] testwrtzeror ( classifier classifier , evaluation evaluation , instances train , instances test ) throws exception { boolean [ ] result = new boolean [ _num ] ; evaluation . evaluatemodel ( classifier , test ) ; try { classifier zeror = new weka . classifiers . rules . zeror ( ) ; zeror . buildclassifier ( train ) ; evaluation zeroreval = new evaluation ( train ) ; zeroreval . evaluatemodel ( zeror , test ) ; result [ _num ] = utils . groreq ( zeroreval . errorrate ( ) , evaluation . errorrate ( ) ) ; } catch ( exception ex ) { throw new error ( _str + ex . getmessage ( ) ) ; } return result ; }	determine whether the scheme performs worse than zeror during testing.
public void println ( ) { if ( addnewlines ) { try { out . write ( _str ) ; } catch ( ioexception ioe ) { throw new groovyruntimeexception ( ioe ) ; } } }	prints an end - of - line character ( if enabled via addnewlines property ).
public void deliverycomplete ( final imqttdeliverytoken token ) { logger . trace ( _str , token . getmessageid ( ) ) ; }	handles completion of message delivery .
public dexportpublickeyopenssl ( jframe parent , string entryalias ) { super ( parent , dialog . modalitytype . document_modal ) ; this . entryalias = entryalias ; initcomponents ( ) ; }	creates a new dexportpublickey dialog .
public static string escapeunicode ( string s ) { int len = s . length ( ) ; int i = _num ; while ( i < len ) { char ch = s . charat ( i ) ; if ( ch > _num ) { stringbuilder buf = new stringbuilder ( ) ; buf . append ( s . substring ( _num , i ) ) ; while ( i < len ) { ch = s . charat ( i ) ; if ( ch > _num ) { buf . append ( _str ) ; buf . append ( character . fordigit ( ( ch > > _num ) % _num , _num ) ) ; buf . append ( character . fordigit ( ( ch > > _num ) % _num , _num ) ) ; buf . append ( character . fordigit ( ( ch > > _num ) % _num , _num ) ) ; buf . append ( character . fordigit ( ( ch ) % _num , _num ) ) ; } else { buf . append ( ch ) ; } i ++ ; } s = buf . tostring ( ) ; } else { i ++ ; } } return s ; }	escape all unicode characters in string .
public void keypressed ( final int keycode ) { if ( impl . getcurrentform ( ) == null ) { return ; } addsingleargumentevent ( key_pressed , keycode ) ; lastinteractionwaskeypad = lastinteractionwaskeypad || ( keycode != menubar . leftsk && keycode != menubar . clearsk && keycode != menubar . backsk ) ; keyrepeatcharged = ( keycode >= _num || getgameaction ( keycode ) > _num ) || keycode == impl . getclearkeycode ( ) ; longpresscharged = keyrepeatcharged ; longkeypresstime = system . currenttimemillis ( ) ; keyrepeatvalue = keycode ; nextkeyrepeatevent = system . currenttimemillis ( ) + keyrepeatinitialintervaltime ; previouskeypressed = lastkeypressed ; lastkeypressed = keycode ; }	pushes a key press event with the given keycode into codename one.
public boolean isempty ( ) { return filter . isempty ( ) && query . isempty ( ) && sort . isempty ( ) ; }	returns if this search doesn ' t specify any filter , query or sort .
public static string fixlinefeeds ( string sql ) { if ( sql . indexof ( _str ) == - _num ) { return sql ; } boolean hasfixes = _bool ; char [ ] fixed = sql . tochararray ( ) ; for ( int i = _num ; i < fixed . length ; i ++ ) { if ( fixed [ i ] == _str && ( i == fixed . length - _num || fixed [ i + _num ] != _str ) ) { fixed [ i ] = _str ; hasfixes = _bool ; } } return hasfixes ? string . valueof ( fixed ) : sql ; }	replaces single \ r linefeeds with \ n ( some databases don ' t like them ).
public static string mergepath ( string current , string realpath ) throws malformedurlexception { string currdir ; if ( current == null || current . indexof ( _str ) == - _num ) currdir = _str ; else if ( current . endswith ( _str ) ) currdir = current ; else currdir = current . substring ( _num , current . lastindexof ( _str ) + _num ) ; string path ; if ( realpath . startswith ( _str ) ) path = currdir + realpath . substring ( _num ) ; else if ( realpath . startswith ( _str ) ) path = realpath ; else if ( ! realpath . startswith ( _str ) ) path = currdir + realpath ; else { while ( realpath . startswith ( _str ) || currdir . length ( ) == _num ) { realpath = realpath . substring ( _num ) ; currdir = currdir . substring ( _num , currdir . length ( ) - _num ) ; int index = currdir . lastindexof ( _str ) ; if ( index == - _num ) throw new malformedurlexception ( _str ) ; currdir = currdir . substring ( _num , index + _num ) ; } path = currdir + realpath ; } return path ; }	merge to pathes to one.
public void rollback ( ) throws sqlexception { if ( useconnection == null ) { log . info ( _str ) ; return ; } try { useconnection . rollback ( ) ; } catch ( sqlexception e ) { log . warning ( _str + e . getmessage ( ) ) ; throw e ; } }	if this sql object was created with a connection then this method rolls back the connection.
public byte [ ] tobytearray ( ) { if ( headernonce_ == null || headertag_ == null ) { throw new awscryptoexception ( _str ) ; } final byte [ ] serializedfields = serializeauthenticatedfields ( ) ; final int outlen = serializedfields . length + headernonce_ . length + headertag_ . length ; final bytebuffer serializedbytes = bytebuffer . allocate ( outlen ) ; serializedbytes . put ( serializedfields ) ; serializedbytes . put ( headernonce_ ) ; serializedbytes . put ( headertag_ ) ; return serializedbytes . array ( ) ; }	serialize the header fields into a byte array.
public boolean containskey ( object key ) { return context . getattribute ( ( string ) key ) != null ; }	returns true if the key name is bound in any scope in the context.
private void updatelimit ( int limit ) { currentcycle . setlimit ( limit ) ; updateplancycles ( ) ; confirmupdate . settextcolor ( resources . getcolor ( r . color . light_gray ) ) ; }	update the limit of the specific cycle type update the corresponding views.
@ suppresswarnings ( _str ) public set < s > descendants ( ) { set < s > perms = new hashset < > ( ) ; for ( s child : children ) { perms . add ( child ) ; perms . addall ( child . descendants ( ) ) ; } return perms ; }	gets all child nodes recursively.
private string extracturl ( string sharedurl ) { string finalurl ; finalurl = sharedurl . trim ( ) ; string [ ] possible_urls = finalurl . split ( _str ) ; for ( string url : possible_urls ) { if ( networkmanager . isurl ( url ) ) { finalurl = url ; break ; } } finalurl = finalurl . substring ( finalurl . lastindexof ( _str ) + _num ) ; finalurl = finalurl . substring ( finalurl . lastindexof ( _str ) + _num ) ; if ( networkmanager . isurl ( _str + finalurl ) && ! networkmanager . isurl ( finalurl ) ) { finalurl = _str + finalurl ; } if ( finalurl . contains ( _str ) ) { finalurl = finalurl . substring ( _num , finalurl . indexof ( _str ) ) ; } if ( finalurl . contains ( _str ) ) { finalurl = finalurl . substring ( _num , finalurl . indexof ( _str ) ) ; } if ( finalurl . contains ( _str ) ) { finalurl = finalurl . substring ( _num , finalurl . indexof ( _str ) ) ; } return finalurl ; }	method to extract the url from shared data and delete trackers.
public set entryset ( ) { return map . entryset ( ) ; }	returns a set view of entry in this map .
public static string encode ( string input ) { return base64 . encodebase64string ( input . getbytes ( standardcharsets . utf_8 ) ) ; }	encode string to base64 string.
public void addsplit ( string splitlabel ) { if ( mdisabled ) return ; long now = systemclock . elapsedrealtime ( ) ; msplits . add ( now ) ; msplitlabels . add ( splitlabel ) ; }	add a split for the current time , labeled with splitlabel.
protected string encode ( final string value ) { try { return urlencoder . encode ( value , _str ) ; } catch ( exception exp ) { return value ; } }	encode value as url compatible utf - 8 .
private void checkconnectpermission ( ) throws securityexception { securitymanager security = system . getsecuritymanager ( ) ; if ( security == null ) return ; if ( security != cachesecuritymanager ) { okcontext = null ; authcache = new weakhashmap < accesscontrolcontext , reference < accesscontrolcontext > > ( ) ; cachesecuritymanager = security ; } accesscontrolcontext ctx = accesscontroller . getcontext ( ) ; if ( okcontext == null || ! ( okcontext . equals ( ctx ) || authcache . containskey ( ctx ) ) ) { security . checkconnect ( ep . gethost ( ) , ep . getport ( ) ) ; authcache . put ( ctx , new softreference < accesscontrolcontext > ( ctx ) ) ; } okcontext = ctx ; }	checks if the current caller has sufficient privilege to make a connection to the remote endpoint .
private boolean conditionl0 ( string value , int index ) { if ( index == value . length ( ) - _num && contains ( value , index - _num , _num , _str , _str , _str ) ) { return _bool ; } else if ( ( contains ( value , index - _num , _num , _str , _str ) || contains ( value , value . length ( ) - _num , _num , _str , _str ) ) && contains ( value , index - _num , _num , _str ) ) { return _bool ; } else { return _bool ; } }	complex condition 0 for ' l '.
public static paginationcontext fromcontext ( routingcontext context ) { httpserverrequest request = context . request ( ) ; string pagestr = request . getparam ( paginationcontext . current_page_query_param ) ; string perpagestr = request . getparam ( paginationcontext . per_page_query_param ) ; integer page = null ; integer perpage = null ; try { if ( pagestr != null ) { page = integer . parseint ( pagestr ) ; } if ( perpagestr != null ) { perpage = integer . parseint ( perpagestr ) ; } } catch ( numberformatexception e ) { defaulterrorhandler . badrequest ( context , _str ) ; } if ( perpage != null && perpage > paginationcontext . max_per_page ) { defaulterrorhandler . badrequest ( context , _str + paginationcontext . per_page_query_param + _str + paginationcontext . max_per_page ) ; } return new paginationcontext ( page , perpage ) ; }	the preferred way to create a paginationcontext.
private void updatedatatypestate ( ) { boolean issyncenabled = msyncswitchpreference . ischecked ( ) ; boolean synceverything = msynceverything . ischecked ( ) ; boolean passwordsyncconfigurable = mprofilesyncservice . isbackendinitialized ( ) && mprofilesyncservice . iscryptographerready ( ) ; for ( checkboxpreference pref : malltypes ) { boolean cansynctype = pref != msyncpasswords || passwordsyncconfigurable ; if ( ! issyncenabled ) { pref . setchecked ( _bool ) ; } else if ( synceverything ) { pref . setchecked ( cansynctype ) ; } pref . setenabled ( issyncenabled && ! synceverything && cansynctype ) ; } if ( issyncenabled && ! synceverything ) { set < integer > synctypes = mprofilesyncservice . getpreferreddatatypes ( ) ; msyncautofill . setchecked ( synctypes . contains ( modeltype . autofill ) ) ; msyncbookmarks . setchecked ( synctypes . contains ( modeltype . bookmarks ) ) ; msyncomnibox . setchecked ( synctypes . contains ( modeltype . typed_urls ) ) ; msyncpasswords . setchecked ( passwordsyncconfigurable && synctypes . contains ( modeltype . passwords ) ) ; msyncrecenttabs . setchecked ( synctypes . contains ( modeltype . proxy_tabs ) ) ; msyncsettings . setchecked ( synctypes . contains ( modeltype . priority_preferences ) ) ; } }	update the data type switch state.
void refreshui ( string xml , domtree m_tree ) { if ( ( xml == null ) || xml . equals ( _str ) ) { seterrormessage ( _str , _str ) ; return ; } final document newroot = getroot ( xml ) ; if ( newroot == null ) { seterrormessage ( _str , _str ) ; return ; } m_tree . setdocument ( newroot ) ; }	refreshui is called when we have a new filename to parse .
private void cleanupprotectionsetvolumes ( protectionset protectionset , list < string > volumeids , boolean markprotectionsetfordeletion ) { if ( protectionset != null ) { _log . info ( _str , protectionset . getlabel ( ) , volumeids . tostring ( ) ) ; stringset psetvolumes = protectionset . getvolumes ( ) ; psetvolumes . removeall ( volumeids ) ; protectionset . setvolumes ( psetvolumes ) ; if ( markprotectionsetfordeletion ) { protectionset . setinactive ( _bool ) ; } _dbclient . updateobject ( protectionset ) ; } }	cleans up the given protectionset by removing volumes from it and marking for deletion if specified.
private static normalization determinenormalization ( element model ) { normalization normmethod = normalization . none ; string normname = model . getattribute ( _str ) ; if ( normname . equals ( _str ) ) { normmethod = normalization . simplemax ; } else if ( normname . equals ( _str ) ) { normmethod = normalization . softmax ; } else if ( normname . equals ( _str ) ) { normmethod = normalization . logit ; } else if ( normname . equals ( _str ) ) { normmethod = normalization . probit ; } else if ( normname . equals ( _str ) ) { normmethod = normalization . cloglog ; } else if ( normname . equals ( _str ) ) { normmethod = normalization . exp ; } else if ( normname . equals ( _str ) ) { normmethod = normalization . loglog ; } else if ( normname . equals ( _str ) ) { normmethod = normalization . cauchit ; } return normmethod ; }	return the type of normalization used for this regression.
operand pop ( register s ) { stack < operand > stack = get ( s ) ; if ( stack == null ) { throw new optimizingcompilerexception ( _str ) ; } else { return stack . pop ( ) ; } }	pop the name at the top of the stack for a particular register.
@ override public void startelement ( string uri , string localname , string qname , attributes attributes ) throws saxexception { elementvalue = new stringbuilder ( _str ) ; elementon = _bool ; if ( localname . equals ( item_title ) ) { episode = new episode ( ) ; isitem = _bool ; } if ( localname . equalsignorecase ( mp3_1 ) && isitem ) { episode . setlength ( attributes . getvalue ( length ) ) ; episode . setaudeourl ( attributes . getvalue ( mp3_3 ) ) ; } }	this will be called when the tags of the xml starts .
public static void backandforth ( hgsearchresult < ? > rs , int windowsize , int iteration ) { boolean advance = _bool ; for ( int i = _num ; i < iteration ; i ++ ) { object x = rs . current ( ) ; int steps = random ( windowsize ) ; steps = forward ( rs , steps ) ; if ( back ( rs , steps ) != steps ) throw new runtimeexception ( _str + steps + _str ) ; if ( ! x . equals ( rs . current ( ) ) ) throw new runtimeexception ( _str + steps + _str + x ) ; if ( advance ) { forward ( rs , random ( windowsize ) ) ; if ( ! rs . hasnext ( ) ) { back ( rs , random ( windowsize ) ) ; advance = _bool ; } } else { back ( rs , random ( windowsize ) ) ; if ( ! rs . hasprev ( ) ) { forward ( rs , random ( windowsize ) ) ; advance = _bool ; } } } }	go back and forth on a result set an ' iteration ' number of times.
@ override public void close ( ) throws ioexception { synchronized ( lock ) { if ( decoder != null ) { decoder . reset ( ) ; } decoder = null ; if ( in != null ) { in . close ( ) ; in = null ; } } }	closes this reader . this implementation closes the source inputstream and releases all local storage .
private stringbuffer _topattern ( stringbuffer result , boolean escapeunprintable ) { if ( pat != null ) { int i ; int backslashcount = _num ; for ( i = _num ; i < pat . length ( ) ; ) { int c = utf16 . charat ( pat , i ) ; i += utf16 . getcharcount ( c ) ; if ( escapeunprintable && utility . isunprintable ( c ) ) { if ( ( backslashcount % _num ) == _num ) { result . setlength ( result . length ( ) - _num ) ; } utility . escapeunprintable ( result , c ) ; backslashcount = _num ; } else { utf16 . append ( result , c ) ; if ( c == _str ) { ++ backslashcount ; } else { backslashcount = _num ; } } } return result ; } return _generatepattern ( result , escapeunprintable , _bool ) ; }	append a string representation of this set to result.
private static version readworkspaceversion ( final url workspace ) { final file versionfile = getversionfile ( workspace , _bool ) ; if ( versionfile == null || ! versionfile . exists ( ) ) { return null ; } try { final properties props = new properties ( ) ; final fileinputstream is = new fileinputstream ( versionfile ) ; try { props . load ( is ) ; } finally { is . close ( ) ; } string versionstring = props . getproperty ( workspace_check_reference_bundle_name ) ; if ( versionstring != null ) { return version . parseversion ( versionstring ) ; } versionstring = props . getproperty ( workspace_check_reference_bundle_name_legacy ) ; if ( versionstring != null ) { return version . parseversion ( versionstring ) ; } return null ; } catch ( final ioexception e ) { ideworkbenchplugin . log ( _str + versionfile , new status ( istatus . error , ideworkbenchplugin . ide_workbench , istatus . error , e . getmessage ( ) == null ? _str : e . getmessage ( ) , e ) ) ; return null ; } catch ( final illegalargumentexception e ) { ideworkbenchplugin . log ( _str + versionfile , new status ( istatus . error , ideworkbenchplugin . ide_workbench , istatus . error , e . getmessage ( ) == null ? _str : e . getmessage ( ) , e ) ) ; return null ; } }	look at the argument url for the workspace ' s version information.
public vectorapproximation calculateapproximation ( dbid id , v dv ) { int [ ] approximation = new int [ dv . getdimensionality ( ) ] ; for ( int d = _num ; d < splitpositions . length ; d ++ ) { final double val = dv . doublevalue ( d ) ; final int lastborderindex = splitpositions [ d ] . length - _num ; if ( val < splitpositions [ d ] [ _num ] ) { approximation [ d ] = _num ; if ( id != null ) { log . warning ( _str ) ; } } else if ( val > splitpositions [ d ] [ lastborderindex ] ) { approximation [ d ] = lastborderindex - _num ; if ( id != null ) { log . warning ( _str ) ; } } else { int pos = arrays . binarysearch ( splitpositions [ d ] , val ) ; pos = ( pos >= _num ) ? pos : ( ( - pos ) - _num ) ; approximation [ d ] = pos ; } } return new vectorapproximation ( id , approximation ) ; }	calculate the va file position given the existing borders .
private boolean checkifvolumesizeexceedingpoolsize ( cimargument [ ] inargs , cimargument [ ] outargs ) { if ( getvolumesize ( inargs ) > getvolumesize ( outargs ) ) { return _bool ; } return _bool ; }	method checks whether the requested volume size exceeds pool size.
@ suppresswarnings ( _str ) private void log ( string label , bytebuffer buffer ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( label ) ; sb . append ( _str ) ; sb . append ( buffer . get ( _num ) ) ; sb . append ( _str ) ; for ( int x = _num ; x < _num ; x ++ ) { sb . append ( string . format ( _str , ( int ) ( buffer . get ( x ) & _num ) ) ) ; sb . append ( _str ) ; } mlog . debug ( sb . tostring ( ) ) ; }	convenience logger for debugging read / write operations.
private void readobject ( objectinputstream ois ) throws classnotfoundexception , ioexception { ois . defaultreadobject ( ) ; boolean hasfont = ois . readboolean ( ) ; if ( hasfont ) { string name = ( string ) ois . readobject ( ) ; int size = ois . readint ( ) ; int style = ois . readint ( ) ; font = new font ( name , style , size ) ; } else { font = omtext . default_font ; } }	reconstitute from an objectinputstream .
public void addfile ( string filename ) { if ( filename != null ) addfile ( new file ( filename ) ) ; }	adds a file to the classpath if it exists .
public string format ( temporalaccessor temporal ) { stringbuilder buf = new stringbuilder ( _num ) ; formatto ( temporal , buf ) ; return buf . tostring ( ) ; }	formats a date - time object using this formatter.
public void painttogglebuttonbackground ( synthcontext context , graphics g , int x , int y , int w , int h ) { paintbackground ( context , g , x , y , w , h , null ) ; }	paints the background of a toggle button .
void savedeviceprofile ( @ nonnull string user , @ nonnull string realm , @ nonnull oathdevicesettings devicesettings ) throws authloginexception { reject . ifnull ( user , realm , devicesettings ) ; try { devicesdao . savedeviceprofiles ( user , realm , jsonutils . tojsonvalues ( collections . singletonlist ( devicesettings ) ) ) ; } catch ( ioexception e ) { debug . error ( _str , user , realm , e ) ; throw new authloginexception ( e ) ; } }	saves the oath device settings to the user ' s profile , overwriting any existing device profile .
protected list < string > parameterstostringlist ( list < parameter > parameters ) { list < string > list = new arraylist < > ( ) ; for ( parameter parameter : parameters ) { list . add ( string . format ( _str , parameter . getname ( ) , parameter . getvalue ( ) ) ) ; } return list ; }	converts a list of parameters to a list of string values .
public static boolean ismatchingname ( string namea , string nameb ) { int a = namea . length ( ) ; int b = nameb . length ( ) ; if ( a == b ) { return namea . equals ( nameb ) ; } else if ( a < b - _num ) { return nameb . endswith ( namea ) && nameb . charat ( b - a - _num ) == _str ; } else if ( b < a - _num ) { return namea . endswith ( nameb ) && namea . charat ( a - b - _num ) == _str ; } else { return _bool ; } }	returns whether the two names match.
private void validatewill ( string dest , object payload ) { if ( ( dest == null ) || ( payload == null ) ) { throw new illegalargumentexception ( ) ; } mqttasyncclient . validatetopic ( dest ) ; }	validates the will fields .
public static float ccpcalcrotate ( final cgpoint from , final cgpoint to ) { float o = to . x - from . x ; float a = to . y - from . y ; float at = ccmacros . cc_radians_to_degrees ( ( float ) math . atan ( o / a ) ) ; if ( a < _num ) { if ( o < _num ) at = _num + math . abs ( at ) ; else at = _num - math . abs ( at ) ; } return at ; }	caculate the rotation ( in degrees ) between two points , so that when we move from one point to the other , we can set the correct rotation to head to that point .
public static string cleantabs ( string yaml ) { if ( yaml . contains ( _str ) ) { logger . warn ( _str + _str + _str , tab_as_spaces . length ( ) ) ; list < string > lines = newline_splitter . splittolist ( yaml ) ; stringbuilder sb = new stringbuilder ( ) ; for ( string line : lines ) { string cleanline = replacestartingtabswithspaces ( line ) ; sb . append ( cleanline ) ; sb . append ( _str ) ; } return sb . tostring ( ) ; } else { return yaml ; } }	strips any tabs which are at the beginning on.
private static paint darkerradialgradientpaint ( radialgradientpaint paint ) { final color [ ] paintcolors = paint . getcolors ( ) ; for ( int i = _num ; i < paintcolors . length ; i ++ ) { paintcolors [ i ] = darker ( paintcolors [ i ] ) ; } return new radialgradientpaint ( paint . getcenterpoint ( ) , paint . getradius ( ) , paint . getfocuspoint ( ) , paint . getfractions ( ) , paintcolors , paint . getcyclemethod ( ) , paint . getcolorspace ( ) , paint . gettransform ( ) ) ; }	create a new gradient with its colours darkened .
public void test_keybuilder_ascii_order ( ) { keybuilder keybuilder = ( keybuilder ) keybuilder . newinstance ( ) ; kvo < string > [ ] a = new kvo [ ] { new kvo < string > ( testkeybuilder . assortkey ( _str ) , null , _str ) , new kvo < string > ( testkeybuilder . assortkey ( _str ) , null , _str ) , new kvo < string > ( testkeybuilder . assortkey ( _str ) , null , _str ) , new kvo < string > ( testkeybuilder . assortkey ( _str ) , null , _str ) } ; arrays . sort ( a ) ; assertequals ( _str , a [ _num ] . obj ) ; assertequals ( _str , a [ _num ] . obj ) ; assertequals ( _str , a [ _num ] . obj ) ; assertequals ( _str , a [ _num ] . obj ) ; }	test verifies the order for ascii sort keys , including verifying that the pad byte causes a prefix such as " bro " to sort before a term which extends that prefix , such as " brown " .
public boolean isclicktouchscreen ( ) { string s = deviceinfo . getsoftwareversion ( ) ; if ( s . length ( ) > _num ) { int v = integer . parseint ( s . substring ( _num , _num ) ) ; return v <= _num ; } return _bool ; }	currently we assume the ' click screen ' is relevant to platform 5 and 4.
public domtestdocumentbuilderfactory newinstance ( documentbuildersetting [ ] newsettings ) throws domtestincompatibleexception { if ( newsettings == null ) { return this ; } documentbuildersetting [ ] mergedsettings = mergesettings ( newsettings ) ; return new lsdocumentbuilderfactory ( mergedsettings ) ; }	create new instance of document builder factory reflecting specified settings.
public void reset ( ) { index = _num ; if ( file != null ) { listindex = _num ; if ( ! written ) { writeallrows ( ) ; written = _bool ; } list . clear ( ) ; file . seek ( filestore . header_length ) ; } }	remove all rows from the list .
public void add ( geometryfunction func ) { functions . add ( func ) ; sortedfunctions . put ( func . getname ( ) , func ) ; categorizedfunctions . put ( func . getcategory ( ) , func . getname ( ) , func ) ; if ( hasgeometryresult ( func ) ) categorizedgeometryfunctions . put ( func . getcategory ( ) , func . getname ( ) , func ) ; }	adds a function if it does not currently exist in the registry , or replaces the existing one with the same signature .
public void firestatechanged ( ) { changeevent e = new changeevent ( this ) ; for ( changelistener listener : listeners ) { listener . statechanged ( e ) ; } }	should be called whenever a field was updated.
public static clusters converttoclusters ( graph clustergraph , list < node > measuredvariables ) { list < string > latents = new arraylist < > ( ) ; clusters clusters = new clusters ( ) ; clustergraph = graphutils . replacenodes ( clustergraph , measuredvariables ) ; for ( node node : clustergraph . getnodes ( ) ) { if ( ! measuredvariables . contains ( node ) ) { latents . add ( node . getname ( ) ) ; } } collections . sort ( latents ) ; for ( int i = _num ; i < latents . size ( ) ; i ++ ) { string name = latents . get ( i ) ; clusters . setclustername ( i , name ) ; node latent = clustergraph . getnode ( name ) ; list < node > measured = clustergraph . getnodesoutto ( latent , endpoint . arrow ) ; for ( node _node : measured ) { if ( measuredvariables . contains ( _node ) ) { clusters . addtocluster ( i , _node . getname ( ) ) ; } } } return clusters ; }	converts a disconnected multiple indicator model into a set of clusters.
final short rlshort ( datainputstream dis ) throws ioexception { short s = _num ; short high , low ; s = dis . readshort ( ) ; high = ( short ) ( ( s & _num ) << _num ) ; low = ( short ) ( ( s & _num ) > > > _num ) ; s = ( short ) ( high | low ) ; return s ; }	rlshort protected helper method to read 16 bits value.
public void encodecell ( mxicell cell , node node , boolean includechildren ) { node . appendchild ( encode ( cell ) ) ; if ( includechildren ) { int childcount = cell . getchildcount ( ) ; for ( int i = _num ; i < childcount ; i ++ ) { encodecell ( cell . getchildat ( i ) , node , includechildren ) ; } } }	encoding of cell hierarchies is built - into the core , but is a higher - level function that needs to be explicitely used by the respective object encoders ( eg.
public datetimeformatter withlocale ( locale locale ) { if ( locale == getlocale ( ) || ( locale != null && locale . equals ( getlocale ( ) ) ) ) { return this ; } return new datetimeformatter ( iprinter , iparser , locale , ioffsetparsed , ichrono , izone , ipivotyear , idefaultyear ) ; }	returns a new formatter with a different locale that will be used for printing and parsing.
public void testiterate ( ) { final range range = createrange ( _num , _num ) ; int next = _num ; final iterator iter = range . iterator ( ) ; while ( iter . hasnext ( ) ) { final object value = iter . next ( ) ; assertequals ( _str , createvalue ( next ++ ) , value ) ; } assertequals ( _str , _num , next ) ; try { iter . next ( ) ; fail ( _str ) ; } catch ( nosuchelementexception ignore ) { } }	tests iterating over a non - reversed range .
public string nextstring ( char quote ) throws jsonexception { char c ; stringbuilder sb = new stringbuilder ( ) ; for ( ; ; ) { c = next ( ) ; switch ( c ) { case _num : case _str : case _str : throw syntaxerror ( _str ) ; case _str : c = next ( ) ; switch ( c ) { case _str : sb . append ( _str ) ; break ; case _str : sb . append ( _str ) ; break ; case _str : sb . append ( _str ) ; break ; case _str : sb . append ( _str ) ; break ; case _str : sb . append ( _str ) ; break ; case _str : sb . append ( ( char ) integer . parseint ( next ( _num ) , _num ) ) ; break ; case _str : case _str : case _str : case _str : sb . append ( c ) ; break ; default : throw syntaxerror ( _str ) ; } break ; default : if ( c == quote ) { return sb . tostring ( ) ; } sb . append ( c ) ; } } }	return the characters up to the next close quote character.
public static response parsexml ( string xml ) throws samlexception { document doc = xmlutils . todomdocument ( xml , samlutils . debug ) ; element root = doc . getdocumentelement ( ) ; return new response ( root ) ; }	returns response object based on the xml document received from server.
public compiledsql registerparamtype ( string paramname , string datatype ) { if ( paramtypes == null ) { paramtypes = new hashmap ( ) ; } paramtypes . put ( paramname , datatype ) ; return this ; }	register the datatype for a sql param .
public void beginstep ( int step , string steptitle , logging logger ) { setprocessed ( step - _num ) ; this . steptitle = steptitle ; logger . progress ( this ) ; }	do a new step and log it.
public boolean equals ( object obj ) { if ( this == obj ) { return _bool ; } else if ( ! ( obj instanceof methoddesc ) ) { return _bool ; } methoddesc od = ( methoddesc ) obj ; return ( ( name == null ? od . name == null : name . equals ( od . name ) ) && arrays . equals ( types , od . types ) && ( constraints == null ? od . constraints == null : constraints . equals ( od . constraints ) ) ) ; }	two instances of this class are equal if they have the same name , the same parameter types , and the same constraints .
public set < string > addcontent ( dialoguestate newstate ) { if ( ! paused ) { curstate . addtostate ( newstate ) ; return update ( ) ; } else { log . info ( _str + newstate ) ; return collections . emptyset ( ) ; } }	merges the dialogue state included as argument into the current one , and updates the dialogue state .
public long removeindex ( int index ) { if ( index >= size ) throw new indexoutofboundsexception ( string . valueof ( index ) ) ; long [ ] items = this . items ; long value = items [ index ] ; size -- ; if ( ordered ) system . arraycopy ( items , index + _num , items , index , size - index ) ; else items [ index ] = items [ size ] ; return value ; }	removes and returns the item at the specified index .
public fdmodel loadmodel ( string filename , string cwd ) { string fn = filename ; if ( fn == null ) return null ; if ( ! fn . endswith ( _str + fileextension ) ) { fn += _str + fileextension ; } modelpersistencehandler persistencehandler = createmodelpersistencehandler ( resourcesetprovider . get ( ) ) ; return ( fdmodel ) persistencehandler . loadmodel ( fn , cwd ) ; }	load franca deployment model file ( *.
public boolean savecurrentconfiguration ( ) { if ( currentconfig . tostring ( ) == null ) { return ( _bool ) ; } int answer = joptionpane . showconfirmdialog ( null , _str , _str , joptionpane . yes_no_cancel_option , joptionpane . question_message , icons . getimageicon ( _str ) ) ; if ( answer == joptionpane . cancel_option ) { return ( _bool ) ; } else if ( answer == joptionpane . no_option ) { return ( _bool ) ; } return ( savecurrentconfigurationas ( _bool ) ) ; }	save the current configuration.
public static double [ ] normalise ( double [ ] initprobs ) { for ( int i = _num ; i < initprobs . length ; i ++ ) { if ( initprobs [ i ] < _num ) { initprobs [ i ] = _num ; } } double sum = _num ; for ( double prob : initprobs ) { sum += prob ; } double [ ] result = new double [ initprobs . length ] ; if ( sum > _num ) { for ( int i = _num ; i < initprobs . length ; i ++ ) { result [ i ] = initprobs [ i ] / sum ; } } else { for ( int i = _num ; i < initprobs . length ; i ++ ) { result [ i ] = _num / initprobs . length ; } } return result ; }	normalises the double array ( ensuring that the sum is equal to 1.
protected stringbuilder appendsearchstringparamifnecessary ( stringbuilder sb ) { string searchstringparam = getencodedsearchstringparam ( ) ; if ( searchstringparam != null ) { if ( sb . indexof ( _str ) == - _num ) { sb . append ( _str ) ; } else { sb . append ( _str ) ; } sb . append ( searchstringparam ) ; } return sb ; }	if a search has been executed , appends a url - encoded string representation of the search criteria to the given stringbuilder , as a get parameter.
public static classinfo findorcreateclass ( string fullname ) { classinfo u = findclass ( fullname ) ; if ( u == null ) { u = new classinfo ( fullname ) ; if ( u . isarray ( ) ) { findorcreateclass ( fullname . substring ( _num ) ) ; } } return u ; }	find a class representation with give name.
plapointrational ( biginteger p_x , biginteger p_y , biginteger p_z ) { rp_x = p_x ; rp_y = p_y ; rp_z = p_z ; is_nan = p_z . signum ( ) <= _num ; }	creates a retionalpoint from 3 bigintegers p_x , p_y and p_z.
public boolean isnullvalue ( ) { return stringutils . trimtonull ( value ) == null && stringutils . trimtonull ( comment ) == null ; }	indicates whether the value is null .
private map < long , pair < string , long > > recoverpendinglargemessages ( ) throws exception { map < long , pair < string , long > > largemessages = new hashmap < > ( ) ; list < string > filenames = largemessagesfactory . listfiles ( _str ) ; list < long > idlist = new arraylist < > ( ) ; for ( string filename : filenames ) { long id = getlargemessageidfromfilename ( filename ) ; if ( ! largemessagestodelete . contains ( id ) ) { idlist . add ( id ) ; sequentialfile seqfile = largemessagesfactory . createsequentialfile ( filename ) ; long size = seqfile . size ( ) ; largemessages . put ( id , new pair < > ( filename , size ) ) ; } } return largemessages ; }	sets a list of large message files into the replicationmanager for synchronization.
private void checkforfragmentid ( attributes attributes ) { if ( ! m_shouldprocess ) { if ( ( null != attributes ) && ( null != m_fragmentidstring ) ) { int n = attributes . getlength ( ) ; for ( int i = _num ; i < n ; i ++ ) { string name = attributes . getqname ( i ) ; if ( name . equals ( constants . attrname_id ) ) { string val = attributes . getvalue ( i ) ; if ( val . equalsignorecase ( m_fragmentidstring ) ) { m_shouldprocess = _bool ; m_fragmentid = m_elementid ; } } } } } }	check to see if an id attribute matched the # id , called from startelement .
public void unparsedentitydecl ( string name , xmlresourceidentifier identifier , string notation , augmentations augs ) throws xniexception { try { if ( fdtdhandler != null ) { string publicid = identifier . getpublicid ( ) ; string systemid = fresolvedtduris ? identifier . getexpandedsystemid ( ) : identifier . getliteralsystemid ( ) ; fdtdhandler . unparsedentitydecl ( name , publicid , systemid , notation ) ; } } catch ( saxexception e ) { throw new xniexception ( e ) ; } }	an unparsed entity declaration .
public void waitforpaxostofinish ( ) { proposelock . lock ( ) ; canpropose . awaituninterruptibly ( ) ; proposelock . unlock ( ) ; }	this method blocks until the paw algorithm is finished.
public static responsedata parse ( string responsedata ) { int index = responsedata . indexof ( _str ) ; string maindata , extradata ; if ( - _num == index ) { maindata = responsedata ; extradata = _str ; } else { maindata = responsedata . substring ( _num , index ) ; extradata = index >= responsedata . length ( ) ? _str : responsedata . substring ( index + _num ) ; } string [ ] fields = textutils . split ( maindata , pattern . quote ( _str ) ) ; if ( fields . length < _num ) { throw new illegalargumentexception ( _str ) ; } responsedata data = new responsedata ( ) ; data . extra = extradata ; data . responsecode = integer . parseint ( fields [ _num ] ) ; data . nonce = integer . parseint ( fields [ _num ] ) ; data . packagename = fields [ _num ] ; data . versioncode = fields [ _num ] ; data . userid = fields [ _num ] ; data . timestamp = long . parselong ( fields [ _num ] ) ; return data ; }	parses response string into responsedata .
public void testsetloginconfigadding ( ) throws exception { string xml = webapp_test_header + _str ; webxml webxml = webxmlio . parsewebxml ( new bytearrayinputstream ( xml . getbytes ( _str ) ) , getentityresolver ( ) ) ; webxmlutils . setloginconfig ( webxml , _str , _str ) ; asserttrue ( webxmlutils . hasloginconfig ( webxml ) ) ; assertequals ( _str , webxmlutils . getloginconfigauthmethod ( webxml ) ) ; }	tests retrieving the authentication method from a descriptor .
public void validate ( ) throws amconsoleexception { if ( isselected ( ) ) { if ( ispersonalquestion ( ) ) { if ( ( question . length ( ) == _num ) || ( answer . length ( ) == _num ) ) { throw new amconsoleexception ( _str ) ; } } else { if ( answer . length ( ) == _num ) { throw new amconsoleexception ( _str ) ; } } } }	validates data for correctness.
public static void asserttrue ( boolean b , object message ) { if ( ! b ) { throwerror ( message ) ; } }	assert that a boolean value is true.
private string [ ] spliterator ( string phrase ) { string [ ] split = phrase . split ( _str ) ; string [ ] out = new string [ split . length ] ; for ( int ix = _num ; ix < split . length ; ix ++ ) { string temp = split [ ix - _num ] ; temp += _str + split [ ix ] ; out [ ix - _num ] = temp ; } return out ; }	splits the phrase into groups of two , with overlap this is for achieving a chain length of three.
protected signature ( string algorithm ) { this . algorithm = algorithm ; }	creates a signature object for the specified algorithm .
private final void augmenttokenlist ( ) { token [ ] temp = new token [ size + increment ] ; system . arraycopy ( tokenlist , _num , temp , _num , size ) ; size += increment ; tokenlist = temp ; for ( int i = _num ; i < increment ; i ++ ) { tokenlist [ size - i - _num ] = createinternaluseonlytoken ( ) ; } }	adds tokens to the internal token list.
public string calculatefromstring ( string data ) throws exception { log . trace ( _str , algouri , data ) ; return calculatefrombytes ( data . getbytes ( standardcharsets . utf_8 ) ) ; }	calculates hash value in base64 format .
public void addchannels ( list < channel > channels ) { for ( channel channel : channels ) { addchannel ( channel ) ; } }	bulk loading of channel list.
public static string [ ] mergestringarrays ( string [ ] array1 , string [ ] array2 ) { if ( objectutils . isempty ( array1 ) ) { return array2 ; } if ( objectutils . isempty ( array2 ) ) { return array1 ; } list < string > result = new arraylist < string > ( ) ; result . addall ( arrays . aslist ( array1 ) ) ; for ( string str : array2 ) { if ( ! result . contains ( str ) ) { result . add ( str ) ; } } return tostringarray ( result ) ; }	merge the given string arrays into one , with overlapping array elements only included once.
private double damp ( double value ) { return math . sqrt ( value ) ; }	rescales the interpolated value to make it smoother .
public void addmeasurement ( double measurement ) { double keepconstant = _num - mdecayconstant ; if ( mcount > mcutover ) { mvalue = math . exp ( keepconstant * math . log ( mvalue ) + mdecayconstant * math . log ( measurement ) ) ; } else if ( mcount > _num ) { double retained = keepconstant * mcount / ( mcount + _num ) ; double newcomer = _num - retained ; mvalue = math . exp ( retained * math . log ( mvalue ) + newcomer * math . log ( measurement ) ) ; } else { mvalue = measurement ; } mcount ++ ; }	adds a new measurement to the moving average .
@ suppresswarnings ( _str ) private string nextunquotedvalue ( ) throws ioexception { stringbuilder builder = null ; int i = _num ; findnonliteralcharacter : while ( _bool ) { for ( ; pos + i < limit ; i ++ ) { switch ( buffer [ pos + i ] ) { case _str : case _str : case _str : case _str : case _str : checklenient ( ) ; case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : break findnonliteralcharacter ; } } if ( i < buffer . length ) { if ( fillbuffer ( i + _num ) ) { continue ; } else { break ; } } if ( builder == null ) { builder = new stringbuilder ( ) ; } builder . append ( buffer , pos , i ) ; pos += i ; i = _num ; if ( ! fillbuffer ( _num ) ) { break ; } } string result ; if ( builder == null ) { result = new string ( buffer , pos , i ) ; } else { builder . append ( buffer , pos , i ) ; result = builder . tostring ( ) ; } pos += i ; return result ; }	returns an unquoted value as a string .
public long arg_end ( ) { return long . parselong ( fields [ _num ] ) ; }	( since linux 3.
static list < iruntimeclasspathentry > computeclasspath ( ijavaproject javaproject ) throws coreexception { iruntimeclasspathentry [ ] unresolvedruntimeclasspath = javaruntime . computeunresolvedruntimeclasspath ( javaproject ) ; list < iruntimeclasspathentry > resolvedruntimeclasspath = new arraylist < iruntimeclasspathentry > ( ) ; for ( iruntimeclasspathentry unresolvedclasspathentry : unresolvedruntimeclasspath ) { if ( javaruntime . isvminstallreference ( unresolvedclasspathentry ) ) { continue ; } resolvedruntimeclasspath . addall ( arrays . aslist ( javaruntime . resolveruntimeclasspathentry ( unresolvedclasspathentry , javaproject ) ) ) ; } try { resolvedruntimeclasspath . addall ( _num , gwtprojectutilities . getgwtsourcefolderpathsfromprojectanddependencies ( javaproject , _bool ) ) ; } catch ( sdkexception e ) { throw new coreexception ( new status ( istatus . error , gwtplugin . plugin_id , e . getlocalizedmessage ( ) , e ) ) ; } gwtsdk gwtruntime = gwtsdk . findsdkfor ( javaproject ) ; if ( gwtruntime == null ) { gwtpluginlog . logwarning ( _str + javaproject . getelementname ( ) + _str ) ; return resolvedruntimeclasspath ; } istatus validationstatus = gwtruntime . validate ( ) ; if ( ! validationstatus . isok ( ) ) { gwtpluginlog . logwarning ( _str + javaproject . getelementname ( ) + _str + validationstatus . getmessage ( ) + _str ) ; return resolvedruntimeclasspath ; } try { file gwtdevjar = gwtruntime . getdevjar ( ) ; resolvedruntimeclasspath . add ( javaruntime . newarchiveruntimeclasspathentry ( path . fromosstring ( gwtdevjar . getabsolutepath ( ) ) ) ) ; } catch ( sdkexception e ) { gwtpluginlog . logwarning ( e , _str ) ; } return resolvedruntimeclasspath ; }	computes a gwt compiler - tailored list of classpath entries for the given java project .
@ suppresswarnings ( _str ) public throwingmocktokenfilterfactory ( map < string , string > args ) { super ( args ) ; string exceptionclassname = args . get ( _str ) ; if ( exceptionclassname == null ) { throw new runtimeexception ( _str ) ; } try { exceptionclass = ( class < ? extends runtimeexception > ) class . forname ( exceptionclassname ) ; } catch ( classnotfoundexception e ) { throw new runtimeexception ( e ) ; } }	initialize this factory via a set of key - value pairs .
public patternguardexpr ( string namespace , string name , list < expression > parameters , patternexpr guardedpattern ) { super ( namespace , name , parameters ) ; this . guarded = new arraylist < patternexpr > ( ) ; guarded . add ( guardedpattern ) ; }	ctor - for use to create a pattern expression tree , without pattern child expression .
private long startnewtrack ( ) { if ( isrecording ( ) ) { log . d ( tag , _str ) ; return - _num ; } long now = system . currenttimemillis ( ) ; tracktripstatisticsupdater = new tripstatisticsupdater ( now ) ; markertripstatisticsupdater = new tripstatisticsupdater ( now ) ; track track = new track ( ) ; uri uri = mytracksproviderutils . inserttrack ( track ) ; long trackid = long . parselong ( uri . getlastpathsegment ( ) ) ; updaterecordingstate ( trackid , _bool ) ; preferencesutils . setint ( this , r . string . auto_resume_track_current_retry_key , _num ) ; preferencesutils . setint ( this , r . string . activity_recognition_type_key , preferencesutils . activity_recognition_type_default ) ; track . setid ( trackid ) ; track . setname ( tracknameutils . gettrackname ( this , trackid , now , null ) ) ; string category = preferencesutils . getstring ( this , r . string . default_activity_key , preferencesutils . default_activity_default ) ; track . setcategory ( category ) ; track . seticon ( trackiconutils . geticonvalue ( this , category ) ) ; track . settripstatistics ( tracktripstatisticsupdater . gettripstatistics ( ) ) ; mytracksproviderutils . updatetrack ( track ) ; insertwaypoint ( waypointcreationrequest . default_start_track ) ; startrecording ( _bool ) ; return trackid ; }	starts a new track .
protected abstractmrmessage pollmessage ( ) { if ( disablepoll ) { return null ; } if ( ! pollqueue . isempty ( ) ) { pollmessage pm = pollqueue . peek ( ) ; if ( pm != null ) { return pm . getmessage ( ) ; } } return null ; }	check tams mc for updates .
private boolean issuppresswarningstest ( string basename ) { return basename . equals ( _str ) ; }	return true if the test name is " suppress_warnings " .
protected static string applylimitclause ( final string query , int limit , final int queryresultsetlimit ) { matcher matcher = select_expr_pattern . matcher ( query ) ; if ( matcher . matches ( ) ) { matcher limit_matcher = select_with_limit_expr_pattern . matcher ( query ) ; boolean queryalreadyhaslimitclause = limit_matcher . matches ( ) ; if ( ! queryalreadyhaslimitclause ) { if ( limit == _num ) { limit = queryresultsetlimit ; } string result = query ; result += _str + limit ; return result ; } } return query ; }	matches the input query with query with limit pattern.
public void unmaximisecomponent ( ) { if ( maximisedcomponent == null ) { return ; } container . remove ( maximisedcomponent ) ; container . add ( containerchild ) ; parentmaximisedcomponent . add ( maximisedcomponent ) ; container . validate ( ) ; containerchild = null ; parentmaximisedcomponent = null ; maximisedcomponent = null ; }	unmaximises the current maximised component.
default charseq join ( charsequence delimiter , charsequence prefix , charsequence suffix ) { stringbuilder stringbuilder = new stringbuilder ( prefix ) ; foreach ( null ) ; stringbuilder . append ( suffix ) ; return charseq . of ( stringbuilder . tostring ( ) ) ; }	convert all elements into string , and connect each string together to a single string , following the same order of the seq.
public void removelistener ( t listener ) { if ( listeners != null ) { list < t > newlisteners = new arraylist < t > ( ) ; newlisteners . addall ( listeners ) ; newlisteners . remove ( listener ) ; listeners = newlisteners ; } }	remove the given listener.
public static void saveasascii ( nsarray root , file out ) throws ioexception { outputstreamwriter w = new outputstreamwriter ( new fileoutputstream ( out ) , _str ) ; w . write ( root . toasciipropertylist ( ) ) ; w . close ( ) ; }	saves a property list with the given object as root into a ascii file .
public static void filteroutbound ( stringbuilder message ) { for ( int i = _num ; i < message . length ( ) ; i ++ ) { char currentchar = message . charat ( i ) ; if ( legal_characters . indexof ( currentchar ) == - _num ) { if ( currentchar > _num ) { int charasint = currentchar ; string stringversion = integer . tostring ( charasint , _num ) ; string replacement = _str + stringversion + _str ; message . replace ( i , i + _num , replacement ) ; i += replacement . length ( ) - _num ; } else { message . deletecharat ( i ) ; i -- ; } } } }	filters out illegal chars , and appends a \ n to the passed in message.
public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . saxexception { if ( ch == null || start < _num || length >= ( ch . length - start ) || length < _num ) return ; append ( m_doc . createcomment ( new string ( ch , start , length ) ) ) ; }	report an xml comment anywhere in the document.
public boolean isempty ( ) { return arraylist . isempty ( ) ; }	returns true for empty .
public arbitrarylengthpathnode ( final termnode left , final termnode right , final varnode tvarleft , final varnode tvarright , final pathmod mod ) { this ( new bop [ ] { new joingroupnode ( ) } , nv . asmap ( new nv ( annotations . left_term , left ) , new nv ( annotations . right_term , right ) , new nv ( annotations . transitivity_var_left , tvarleft ) , new nv ( annotations . transitivity_var_right , tvarright ) , new nv ( annotations . lower_bound , mod == pathmod . one_or_more ? _num : _num ) , new nv ( annotations . upper_bound , mod == pathmod . zero_or_one ? _num : long . max_value ) ) ) ; final set < varnode > dropvars = new linkedhashset < > ( ) ; dropvars . add ( tvarleft ) ; dropvars . add ( tvarright ) ; setproperty ( annotations . drop_vars , dropvars ) ; }	fully construct an arbitrary length path node with all required annotations .
static void checkflags ( int flags ) { int allowedflags = read_only_flag_mask | empty_flag_mask | compact_flag_mask | ordered_flag_mask ; int flagsmask = ~ allowedflags ; if ( ( flags & flagsmask ) > _num ) { throw new sketchesargumentexception ( _str + integer . tobinarystring ( flags ) ) ; } }	checks just the flags field of the preamble.
public static arraylist < object > deleteitemsets ( arraylist < object > itemsets , int minsupport , int maxsupport ) { arraylist < object > newvector = new arraylist < object > ( itemsets . size ( ) ) ; for ( int i = _num ; i < itemsets . size ( ) ; i ++ ) { labeleditemset current = ( labeleditemset ) itemsets . get ( i ) ; if ( ( current . m_rulesupcounter >= minsupport ) && ( current . m_rulesupcounter <= maxsupport ) ) { newvector . add ( current ) ; } } return newvector ; }	deletes all item sets that don ' t have minimum support and have more than maximum support.
private static synchronized string makedatestring ( date date ) { return sdfdefault . format ( date ) ; }	generates a string representation of a java date object.
public static string generatenativeguid ( dbclient dbclient , fileshare fileshare ) throws ioexception { storagesystem device = dbclient . queryobject ( storagesystem . class , fileshare . getstoragedevice ( ) ) ; return string . format ( _str + filesystem + _str , _devicetypemap . get ( device . getsystemtype ( ) ) , device . getserialnumber ( ) , fileshare . getnativeid ( ) ) ; }	generates the format storagesystem + serialnumber + filesystem + nativeid native guid for fileshare objects.
public string tostring ( ) { stringbuffer result = new stringbuffer ( ) ; int temp ; temp = ipaddress & _num ; result . append ( temp ) ; result . append ( _str ) ; temp = ( ipaddress > > _num ) & _num ; result . append ( temp ) ; result . append ( _str ) ; temp = ( ipaddress > > _num ) & _num ; result . append ( temp ) ; result . append ( _str ) ; temp = ( ipaddress > > _num ) & _num ; result . append ( temp ) ; return result . tostring ( ) ; }	return the string representation of the ip address following the common decimal - dotted notation xxx.
private static double distance ( point p1 , point p2 ) { double x = p1 . x - p2 . x ; double y = p1 . y - p2 . y ; return math . sqrt ( x * x + y * y ) ; }	calculate the distance between two points.
public void addhyperedgeinnode ( hyperedge hyperedge ) { if ( hyperedge != null ) { if ( null == hyperedges ) hyperedges = new arraylist < > ( ) ; hyperedges . add ( hyperedge ) ; semiringplus ( hyperedge ) ; } }	adds the hyperedge to the list of incoming hyperedges ( i.
public rotatedproblems ( ) { super ( ) ; }	constructs a problem provider for rotated problems .
public dockerportmapping withhostport ( int hostport ) { dockerportmapping newmapping = new dockerportmapping ( ) ; newmapping . protocol = protocol ; newmapping . containerport = containerport ; newmapping . hostip = hostip ; newmapping . hostport = string . valueof ( hostport ) ; return newmapping ; }	create a copy of this mapping with the given host port.
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return id1 ; case _num : return id2 ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
@ override public int length ( ) { return str . length ( ) ; }	returns the string length.
public void clearallhaptics ( ) { mhaptics . clear ( ) ; }	clears all haptic patterns associated with this fragment .
public void encode ( final activemqbuffer buffer ) { buffer . writestring ( name ) ; buffer . writestring ( factoryclassname ) ; buffer . writeint ( params == null ? _num : params . size ( ) ) ; if ( params != null ) { encodemap ( buffer , params ) ; } if ( extraprops != null ) { encodemap ( buffer , extraprops ) ; } }	encodes this transportconfiguration into a buffer.
@ override public void write ( byte [ ] b , int off , int len ) throws ioexception { flushbits ( ) ; out . write ( b , off , len ) ; }	commit any outstanding bit writes and then write some bytes to the underlying output stream .
public static double log2 ( double x ) { return math . log ( x ) / log2 ; }	the base 2 logarithm of the input value.
boolean isnameused ( string name ) { list < integer > columnswithname = columnnames . get ( name ) ; return columnswithname != null && ! columnswithname . isempty ( ) ; }	checks if the given column name is already in use .
public stateinteractive complete ( ) { if ( return_state != this && actlog != null ) { actlog . start_scope ( logfilescope . complete_scope ) ; } return return_state ; }	action to be taken , when this state is completed and exited.
private workqueue findnonemptystealqueue ( ) { workqueue [ ] ws ; int wl ; int r = tlrandom . nextsecondaryseed ( ) ; if ( ( ws = workqueues ) != null && ( wl = ws . length ) > _num ) { int m = wl - _num , origin = r & m ; for ( int k = origin , oldsum = _num , checksum = _num ; ; ) { workqueue q ; int b ; if ( ( q = ws [ k ] ) != null ) { if ( ( b = q . base ) - q . top < _num ) return q ; checksum += b ; } if ( ( k = ( k + _num ) & m ) == origin ) { if ( oldsum == ( oldsum = checksum ) ) break ; checksum = _num ; } } } return null ; }	returns a ( probably ) non - empty steal queue , if one is found during a scan , else null.
private void doddporientation ( node d , node a , node b , node c , graph graph ) { list < node > sepset = getsepset ( d , c ) ; if ( sepset == null ) { return ; } if ( sepset . contains ( b ) ) { graph . setendpoint ( c , b , endpoint . tail ) ; if ( verbose ) { logger . log ( _str , searchlogutils . edgeorientedmsg ( _str + d , graph . getedge ( b , c ) ) ) ; out . println ( searchlogutils . edgeorientedmsg ( _str + d , graph . getedge ( b , c ) ) ) ; } changeflag = _bool ; } else { if ( ! isarrowpointallowed ( a , b , graph ) ) { return ; } if ( ! isarrowpointallowed ( c , b , graph ) ) { return ; } graph . setendpoint ( a , b , endpoint . arrow ) ; graph . setendpoint ( c , b , endpoint . arrow ) ; logger . log ( _str , searchlogutils . colliderorientedmsg ( _str + d , a , b , c ) ) ; changeflag = _bool ; } }	orients the edges inside the definte discriminating path triangle.
public void handletblbootstrapresoffhrefactionrequest ( requestinvocationevent event ) throws modelcontrolexception { try { map values = getvalues ( ) ; onbeforesaveprofile ( values ) ; setpagesessionattribute ( property_attribute , ( hashmap ) values ) ; smdiscoverybootstraprefoffeditviewbean vb = ( smdiscoverybootstraprefoffeditviewbean ) getviewbean ( smdiscoverybootstraprefoffeditviewbean . class ) ; unlockpagetrail ( ) ; passpgsessionmap ( vb ) ; vb . populatevalues ( ( string ) getdisplayfieldvalue ( tbl_bootstrap_res_off_href_action ) ) ; vb . forwardto ( getrequestcontext ( ) ) ; } catch ( amconsoleexception e ) { setinlinealertmessage ( ccalert . type_error , _str , e . getmessage ( ) ) ; } }	handles edit bootstrap resource offering request .
@ visiblefortesting string postrequest ( long timestamp , string xml ) throws requestfailureexception { string response = null ; httpurlconnection urlconnection = null ; try { urlconnection = createconnection ( ) ; setuppostrequest ( timestamp , urlconnection , xml ) ; sendrequesttoserver ( urlconnection , xml ) ; response = readresponsefromserver ( urlconnection ) ; } finally { if ( urlconnection != null ) { urlconnection . disconnect ( ) ; } } return response ; }	posts the request to the omaha server .
private void generatekey ( ) throws exception { keygenerator keygen = keygenerator . getinstance ( algo ) ; secretkey key = keygen . generatekey ( ) ; persistkey ( key ) ; }	generates a new key and persists it to coordinator.
public httprequestevent firehttprequestevent ( string request , outputstream output ) throws ioexception { httprequestevent event = new httprequestevent ( this , request , output ) ; httprequestlistener listener ; vector list = ( vector ) listeners . clone ( ) ; enumeration e = list . elements ( ) ; while ( e . hasmoreelements ( ) ) { listener = ( httprequestlistener ) e . nextelement ( ) ; listener . httprequest ( event ) ; } return event ; }	creates a httprequestevent and sends it to all registered listeners .
private void parserecord ( element unitnode ) { nodelist nl = unitnode . getchildnodes ( ) ; for ( int i = _num ; i < nl . getlength ( ) ; i ++ ) { node currnode = nl . item ( i ) ; if ( currnode . getparentnode ( ) != unitnode ) { continue ; } int nodetype = currnode . getnodetype ( ) ; if ( nodetype == node . element_node ) { string nodename = currnode . getnodename ( ) ; if ( nodename . equalsignorecase ( unit ) ) { parseunit ( ( element ) currnode , entities ) ; } else if ( nodename . equalsignorecase ( survivors ) ) { parseunit ( ( element ) currnode , survivors ) ; } else if ( nodename . equalsignorecase ( allies ) ) { parseunit ( ( element ) currnode , allies ) ; } else if ( nodename . equalsignorecase ( salvage ) ) { parseunit ( ( element ) currnode , salvage ) ; } else if ( nodename . equalsignorecase ( devastated ) ) { parseunit ( ( element ) currnode , devastated ) ; } else if ( nodename . equalsignorecase ( kills ) ) { parsekills ( ( element ) currnode ) ; } else if ( nodename . equalsignorecase ( entity ) ) { parseunit ( ( element ) currnode , entities ) ; } else if ( nodename . equalsignorecase ( pilot ) ) { parsepilot ( ( element ) currnode ) ; } } else { continue ; } } }	parse a unit tag.
public void cancel ( ) { synchronized ( lock ) { if ( this . latency == no_target ) { throw new illegalstateexception ( _str + _str ) ; } if ( ! requests . remove ( this ) ) { throw new internalerror ( _str + this + _str ) ; } if ( requests . isempty ( ) ) requests = null ; this . latency = no_target ; adjustlatencyifneeded ( ) ; } }	cancels this latency request .
void mergesuccess ( mergepolicy . onemerge merge ) { }	hook that ' s called when the specified merge is complete .
void starteventtracker ( ) { list < eventtrackingservice > services = getenabledservicesfortype ( eventtrackingservice . class ) ; if ( services != null && ! services . isempty ( ) ) { if ( eventtracker == null ) { eventtracker = new eventtracker ( context , services , foamapikeys . wifionly ( ) ) ; } if ( ! eventtracker . isrunning ( ) ) { eventtracker . start ( ) ; } } }	start foam event tracker.
@ override public int preceding ( int offset ) { characteriterator text = gettext ( ) ; checkoffset ( offset , text ) ; if ( cachedbreakpositions == null || offset <= cachedbreakpositions [ _num ] || offset > cachedbreakpositions [ cachedbreakpositions . length - _num ] ) { cachedbreakpositions = null ; return super . preceding ( offset ) ; } else { positionincache = _num ; while ( positionincache < cachedbreakpositions . length && offset > cachedbreakpositions [ positionincache ] ) { ++ positionincache ; } -- positionincache ; text . setindex ( cachedbreakpositions [ positionincache ] ) ; return text . getindex ( ) ; } }	sets the current iteration position to the last boundary position before the specified position .
protected static boolean signedfitsinnibble ( int value ) { return ( value >= - _num ) && ( value <= _num ) ; }	helper method to determine if a signed int value fits in a nibble .
@ override public void mousepressed ( mouseevent e ) { events . clear ( ) ; if ( mapdragoperationfrommodifiers ( e ) != dndconstants . action_none ) { try { motionthreshold = dragsource . getdragthreshold ( ) ; } catch ( exception exc ) { motionthreshold = _num ; } appendevent ( e ) ; } }	invoked when a mouse button has been pressed on a component .
public void simpleelement ( string name , string value ) throws ioexception { simpleelement ( null , name , null , value ) ; }	emits a simple element ( without child elements ) .
public static boolean isvalidipv4 ( string address ) { if ( address . length ( ) == _num ) { return _bool ; } int octet ; int octets = _num ; string temp = address + _str ; int pos ; int start = _num ; while ( start < temp . length ( ) && ( pos = temp . indexof ( _str , start ) ) > start ) { if ( octets == _num ) { return _bool ; } try { octet = integer . parseint ( temp . substring ( start , pos ) ) ; } catch ( numberformatexception ex ) { return _bool ; } if ( octet < _num || octet > _num ) { return _bool ; } start = pos + _num ; octets ++ ; } return octets == _num ; }	validate the given ipv4 address .
private void validatedimensioncsv ( schemainfo schemainfo , string facttablename , string dimtablename , carbonfile dimfile , string partitionid , carbondataloadschema schema , string delimiter ) throws dataloadingexception { string [ ] columnnames = getdimcolumnnames ( schemainfo , facttablename , dimtablename , partitionid , schema ) ; if ( null == columnnames || columnnames . length < _num ) { return ; } if ( ! checkallcolumnspresent ( columnnames , dimfile . getabsolutepath ( ) , delimiter ) ) { logger . error ( _str + _str + dimfile . getname ( ) ) ; throw new dataloadingexception ( dataprocessorconstants . csv_validation_errror_code , _str + _str + dimfile . getname ( ) ) ; } }	validate the dimension csv files .
public boolean removetuple ( tuple t ) { table table = t . gettable ( ) ; if ( m_sets . contains ( table ) ) { return table . removetuple ( t ) ; } else { return _bool ; } }	removes the tuple from its source set if that source set is contained within this composite .
private boolean isdarkthemeset ( ) { sharedpreferences sharedpreferences = preferencemanager . getdefaultsharedpreferences ( getactivity ( ) ) ; string key = getstring ( r . string . theme_preference_key ) ; string defaultvalue = getstring ( r . string . theme_preference_default_value ) ; return integer . valueof ( sharedpreferences . getstring ( key , defaultvalue ) ) != _num ; }	returns , whether the app uses the dark theme , or not .
@ deprecated public void addprefixnsmapping ( string prefix , string nsuri ) { if ( nsuri . length ( ) == _num ) { throw new illegalargumentexception ( _str ) ; } if ( prefix . length ( ) == _num ) { throw new illegalargumentexception ( _str ) ; } if ( prefix . equals ( no_ns_prefix ) ) { throw new illegalargumentexception ( _str + prefix + _str ) ; } if ( prefixtonamespaceurilookup . containskey ( prefix ) ) { throw new illegalargumentexception ( _str + prefix + _str ) ; } if ( namespaceuritoprefixlookup . containskey ( nsuri ) ) { throw new illegalargumentexception ( _str + nsuri + _str ) ; } if ( prefix . equals ( default_namespace_prefix ) ) { this . defaultns = nsuri ; } else { prefixtonamespaceurilookup . put ( prefix , nsuri ) ; namespaceuritoprefixlookup . put ( nsuri , prefix ) ; } }	this is used internally .
protected message createresponsemessage ( ) { return new message ( _num , version . current ) ; }	by default just create a normal one part msg.
public static void o ( double a ) { o ( a , parameters . outputfieldwidth , parameters . outputfracplaces ) ; }	prints a double in default e format .
public void writefield ( string name , string value ) throws ioexception { if ( name == null ) { throw new illegalargumentexception ( _str ) ; } out . writebytes ( prefix ) ; out . writebytes ( boundary ) ; out . writebytes ( newline ) ; out . writebytes ( _str + name + _str ) ; out . writebytes ( newline ) ; out . writebytes ( newline ) ; if ( value != null ) { out . writebytes ( value ) ; } out . writebytes ( newline ) ; out . flush ( ) ; }	writes a string field value .
public int drainto ( collection < ? super e > c ) { int result = buffer . drainto ( c ) ; if ( producer != null ) { producer . wakeup ( ) ; } return result ; }	removes all available elements from this queue and adds them to the given collection.
protected void grow ( ) { if ( dists == empty_dists ) { dists = new double [ initial_size ] ; ids = new int [ initial_size ] ; return ; } final int len = dists . length ; final int newlength = len + ( len > > _num ) ; double [ ] odists = dists ; dists = new double [ newlength ] ; system . arraycopy ( odists , _num , dists , _num , odists . length ) ; int [ ] oids = ids ; ids = new int [ newlength ] ; system . arraycopy ( oids , _num , ids , _num , oids . length ) ; }	grow the data storage .
igfsinputstreamimpl ( igfscontext igfsctx , igfspath path , @ nullable igfsentryinfo fileinfo , int prefetchblocks , int seqreadsbeforeprefetch , @ nullable igfssecondaryfilesystempositionedreadable secreader , long len , int blocksize , long blockscnt , boolean proxy ) { assert igfsctx != null ; assert path != null ; this . igfsctx = igfsctx ; this . path = path ; this . fileinfo = fileinfo ; this . prefetchblocks = prefetchblocks ; this . seqreadsbeforeprefetch = seqreadsbeforeprefetch ; this . secreader = secreader ; this . len = len ; this . blocksize = blocksize ; this . blockscnt = blockscnt ; this . proxy = proxy ; log = igfsctx . kernalcontext ( ) . log ( igfsinputstream . class ) ; maxloccachesize = ( prefetchblocks > _num ? prefetchblocks : _num ) * _num / _num ; loccache = new linkedhashmap < > ( maxloccachesize , _num ) ; pendingfuts = new gridconcurrenthashset < > ( prefetchblocks > _num ? prefetchblocks : _num ) ; igfsctx . metrics ( ) . incrementfilesopenedforread ( ) ; }	constructs file output stream .
public abstractscaleoutclientindexview ( final abstractscaleoutfederation fed , final string name , final long timestamp , final imetadataindex metadataindex ) { if ( fed == null ) throw new illegalargumentexception ( ) ; if ( name == null ) throw new illegalargumentexception ( ) ; if ( metadataindex == null ) throw new illegalargumentexception ( ) ; this . fed = fed ; this . name = name ; this . timestamp = timestamp ; this . metadataindex = metadataindex ; this . metadataindexmetadata = metadataindex . getindexmetadata ( ) ; final abstractclient < ? > client = fed . getclient ( ) ; this . capacity = client . getdefaultrangequerycapacity ( ) ; this . batchonly = client . getbatchapionly ( ) ; this . tasktimeout = client . gettasktimeout ( ) ; this . readconsistent = client . isreadconsistent ( ) ; }	create a view on a scale - out index .
public boolean cansendevent ( ) { try { validatesendevent ( ) ; return _bool ; } catch ( exception e ) { return _bool ; } }	returns true if connectemc is configured and it is control node .
public static final string capitalize ( string str , char ... delimiters ) { final int delimlen = delimiters == null ? - _num : delimiters . length ; if ( textutils . isempty ( str ) || delimlen == _num ) { return str ; } final char [ ] buffer = str . tochararray ( ) ; boolean capitalizenext = _bool ; for ( int i = _num ; i < buffer . length ; i ++ ) { char ch = buffer [ i ] ; if ( isdelimiter ( ch , delimiters ) ) { capitalizenext = _bool ; } else if ( capitalizenext ) { buffer [ i ] = character . totitlecase ( ch ) ; capitalizenext = _bool ; } } return new string ( buffer ) ; }	capitalizes the first character in a string.
public void testcomparetonegzero ( ) { byte abytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , _num , _num } ; int asign = - _num ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = biginteger . zero ; assertequals ( - _num , anumber . compareto ( bnumber ) ) ; }	compareto ( biginteger a ).
public void write ( outputstream out ) throws socksexception , ioexception { if ( data == null ) { socks5message msg ; if ( addrtype == socks_atyp_domainname ) msg = new socks5message ( command , host , port ) ; else { if ( ip == null ) { try { ip = inetaddress . getbyname ( host ) ; } catch ( unknownhostexception uh_ex ) { throw new socksexception ( socksconstants . socks_just_error ) ; } } msg = new socks5message ( command , ip , port ) ; } data = msg . data ; } out . write ( data ) ; }	writes the message to the stream .
public static byte [ ] compressforzlib ( byte [ ] bytestocompress ) { deflater deflater = new deflater ( ) ; deflater . setinput ( bytestocompress ) ; deflater . finish ( ) ; byte [ ] bytescompressed = new byte [ short . max_value ] ; int numberofbytesaftercompression = deflater . deflate ( bytescompressed ) ; byte [ ] returnvalues = new byte [ numberofbytesaftercompression ] ; system . arraycopy ( bytescompressed , _num , returnvalues , _num , numberofbytesaftercompression ) ; return returnvalues ; }	zlib compress 2 byte.
private static bytebuffer generatewavdata ( int samplecount , int freqhz ) { final int numdatabytes = samplecount * num_channels * bits_per_sample / _num ; final double freq = freqhz ; bytebuffer buf = bytebuffer . allocate ( numdatabytes ) ; buf . order ( byteorder . little_endian ) ; if ( bits_per_sample == _num ) { final double peak = _num ; for ( int i = _num ; i < samplecount ; i ++ ) { double timesec = i / ( double ) sample_rate ; double sinvalue = math . sin ( _num * math . pi * freq * timesec ) ; if ( gamesurfacerenderer . extra_check ) { int output = ( int ) ( peak * sinvalue + _num ) ; if ( output < _num || output >= _num ) { throw new runtimeexception ( _str ) ; } } buf . put ( ( byte ) ( peak * sinvalue + _num ) ) ; } } else if ( bits_per_sample == _num ) { final double peak = _num ; shortbuffer sbuf = buf . asshortbuffer ( ) ; for ( int i = _num ; i < samplecount ; i ++ ) { double timesec = i / ( double ) sample_rate ; double sinvalue = math . sin ( _num * math . pi * freq * timesec ) ; sbuf . put ( ( short ) ( peak * sinvalue ) ) ; } } buf . position ( _num ) ; return buf ; }	generates the raw wav - compatible audio data .
protected static string h2c ( string hyphenated , boolean studly ) { stringbuilder b = new stringbuilder ( hyphenated . length ( ) ) ; boolean capnext = studly ; for ( int i = _num ; i < hyphenated . length ( ) ; ++ i ) { char c = hyphenated . charat ( i ) ; if ( c == _str ) capnext = _bool ; else { b . append ( capnext ? character . touppercase ( c ) : c ) ; capnext = _bool ; } } return b . tostring ( ) ; }	convert hyphenated to studlycaps or camelcase.
public synchronized void onwriteevent ( ) throws ioexception { lrmiinvocationtrace trace = null ; try { while ( ! _contexts . isempty ( ) ) { context current = _contexts . peek ( ) ; trace = current . gettrace ( ) ; if ( trace != null ) lrmiinvocationcontext . updatecontext ( trace , null , null , null , null , _bool , null , null ) ; noneblockingwrite ( current ) ; if ( current . getphase ( ) != context . phase . finish ) { setwriteinterest ( ) ; break ; } else { tracecontexttotalwritetime ( current ) ; _contexts . poll ( ) ; pendingwrites . decrement ( ) ; } } if ( _contexts . isempty ( ) ) { removewriteinterest ( _bool ) ; } } finally { if ( trace != null ) lrmiinvocationcontext . resetcontext ( ) ; } }	called from writeselectorthread to complete pending write requests . this is synchronized to ensure mutual exclusion with writebytestochannelnoneblocking method.
public static void add ( object spy ) { spies . add ( spy ) ; }	add a new spy .
void initleafcalc ( byte [ ] seed0 ) { this . i = _num ; this . j = _num ; byte [ ] dummy = new byte [ mdsize ] ; system . arraycopy ( seed0 , _num , dummy , _num , seed . length ) ; this . seed = gmssrandom . nextseed ( dummy ) ; }	initialize the distributed leaf calculation reset i , j and compute otsseed with seed0.
@ override public boolean downloadfile ( string path , string dest ) { try { fileoutputstream fos = new fileoutputstream ( new file ( dest ) ) ; mdbapi . getfile ( path , null , fos , null ) ; fos . close ( ) ; return _bool ; } catch ( dropboxexception e ) { e . printstacktrace ( ) ; return _bool ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; return _bool ; } catch ( ioexception e ) { e . printstacktrace ( ) ; return _bool ; } }	downloads a file from the dropbox to a given location.
boolean doesoccur ( qname refname ) { return m_refs . contains ( refname ) ; }	tell if the given qualified name occurs in the list of qualified names collected .
public static dateformat todateformat ( string dateformat , timezone tz , locale locale ) { dateformat df = null ; if ( utilvalidate . isempty ( dateformat ) ) { df = dateformat . getdateinstance ( dateformat . short , locale ) ; } else { df = new simpledateformat ( dateformat , locale == null ? locale . getdefault ( ) : locale ) ; } df . settimezone ( tz ) ; return df ; }	returns an initialized dateformat object .
public integer loadidnamevalues ( dboutputstatement statement , integer idx ) throws exception { int index = idx . intvalue ( ) ; if ( _logger . isdebugenabled ( ) ) _logger . debug ( _str ) ; _id = statement . getlonginteger ( index ++ ) ; _name = statement . getshorttext ( index ++ ) ; return new integer ( index ) ; }	recupera de la base de datos el identificador y el nombre del usuario .
private byte [ ] padpassword ( byte [ ] password ) { if ( password == null ) { password = new byte [ _num ] ; } byte [ ] padded = new byte [ _num ] ; final int numcontributingpasswordbytes = password . length > padded . length ? padded . length : password . length ; system . arraycopy ( password , _num , padded , _num , numcontributingpasswordbytes ) ; if ( password . length < padded . length ) { system . arraycopy ( pw_padding , _num , padded , password . length , padded . length - password . length ) ; } return padded ; }	pad a password as per step 1 of algorithm 3.
public final int movemade ( long now , boolean useincrement ) { stoptimer ( now ) ; arraylist < timecontrolfield > tc = tcdata . gettc ( whitetomove ) ; pair < integer , integer > tcinfo = getcurrenttc ( whitetomove ) ; int tcidx = tcinfo . first ; int movestotc = tcinfo . second ; int remaining = getremainingtime ( whitetomove , now ) ; if ( useincrement ) { remaining += tc . get ( tcidx ) . increment ; if ( movestotc == _num ) { if ( tcidx + _num < tc . size ( ) ) tcidx ++ ; remaining += tc . get ( tcidx ) . timecontrol ; } } elapsed = _num ; return remaining ; }	compute new remaining time after a move is made .
public static properties prefixproperties ( properties props , string prefix ) { properties prefixprops = new properties ( ) ; for ( string key : props . stringpropertynames ( ) ) { if ( key . startswith ( prefix ) ) { string keywithoutprefix = key . substring ( prefix . length ( ) ) ; prefixprops . setproperty ( keywithoutprefix , props . getproperty ( key ) ) ; } } return prefixprops ; }	extract only the properties that match a prefix , and with the prefix removed .
public final void testsetregex ( ) { regexconstraint regexconstraint = new regexconstraint ( pattern . compile ( _str ) ) ; regexconstraint . setregex ( regex ) ; assertequals ( regex , regexconstraint . getregex ( ) ) ; }	tests the functionality of the method , which allows to set the regular expression .
public synchronized void start ( ) { if ( isstarted ) { return ; } if ( isstopped ) { throw new illegalstateexception ( _str ) ; } logger . info ( _str + tor . getfullversion ( ) + _str ) ; verifyunlimitedstrengthpolicyinstalled ( ) ; directorydownloader . start ( directory ) ; circuitmanager . startbuildingcircuits ( ) ; if ( dashboard . isenabledbyproperty ( ) ) { dashboard . startlistening ( ) ; } isstarted = _bool ; }	start running the tor client service .
public static cipherparameters makepbeparameters ( pbekeyspec keyspec , int type , int hash , int keysize , int ivsize ) { pbeparametersgenerator generator = makepbegenerator ( type , hash ) ; byte [ ] key ; cipherparameters param ; key = convertpassword ( type , keyspec ) ; generator . init ( key , keyspec . getsalt ( ) , keyspec . getiterationcount ( ) ) ; if ( ivsize != _num ) { param = generator . generatederivedparameters ( keysize , ivsize ) ; } else { param = generator . generatederivedparameters ( keysize ) ; } for ( int i = _num ; i != key . length ; i ++ ) { key [ i ] = _num ; } return param ; }	construct a key and iv ( if necessary ) suitable for use with a cipher .
@ override public double value ( int attindex ) { int index = locateindex ( attindex ) ; if ( ( index >= _num ) && ( m_indices [ index ] == attindex ) ) { return _num ; } else { return _num ; } }	returns an instance ' s attribute value in internal format .
private void fetchfilterseeds ( ) { if ( seedlist == null || seedlist . isempty ( ) ) { return ; } for ( iterator < uri > it = seedlist . iterator ( ) ; it . hasnext ( ) ; ) { uri seed = it . next ( ) ; for ( fetchfilter filter : controller . getfetchfilters ( ) ) { fetchstatus filterreason = filter . checkfilter ( seed ) ; if ( filterreason != fetchstatus . valid ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str + seed + _str + filterreason ) ; } it . remove ( ) ; break ; } } } }	filters the seed list using the current fetch filters , preventing any non - valid seed from being accessed .
public xyarearenderer2 ( xytooltipgenerator labelgenerator , xyurlgenerator urlgenerator ) { super ( ) ; this . showoutline = _bool ; setbasetooltipgenerator ( labelgenerator ) ; seturlgenerator ( urlgenerator ) ; generalpath area = new generalpath ( ) ; area . moveto ( _num , - _num ) ; area . lineto ( _num , - _num ) ; area . lineto ( _num , _num ) ; area . lineto ( - _num , _num ) ; area . lineto ( - _num , - _num ) ; area . closepath ( ) ; this . legendarea = area ; }	constructs a new renderer .
public static boolean isprimitiveorwrapper ( class < ? > clazz ) { assert . notnull ( clazz , _str ) ; return ( clazz . isprimitive ( ) || isprimitivewrapper ( clazz ) ) ; }	check if the given class represents a primitive ( i.
private void assertfilecontains ( list < string > expected , string filename ) throws exception { try ( bufferedreader reader = new bufferedreader ( new filereader ( filename ) ) ) { list < string > actual = new arraylist < > ( ) ; for ( ; ; ) { string line = reader . readline ( ) ; if ( line == null ) { break ; } actual . add ( line ) ; } assertequals ( expected , actual ) ; } }	assert that a file contains the lines provided , in the same order as expected .
private void reportexception ( kind kind , element element , throwable t ) { stringwriter buf = new stringwriter ( ) ; t . printstacktrace ( new printwriter ( buf ) ) ; buf . tostring ( ) ; message ( kind , element , _str , buf . tostring ( ) ) ; }	bugs in an annotation processor can cause silent failure so try to report any exception throws as errors .
public void add ( string [ ] titles , double [ ] values ) { add ( mcategories . size ( ) + _str , titles , values ) ; }	adds a new value to the series .
static string parseauthority ( string uristring , int ssi ) { int length = uristring . length ( ) ; if ( length > ssi + _num && uristring . charat ( ssi + _num ) == _str && uristring . charat ( ssi + _num ) == _str ) { int end = ssi + _num ; loop : while ( end < length ) { switch ( uristring . charat ( end ) ) { case _str : case _str : case _str : break loop ; } end ++ ; } return uristring . substring ( ssi + _num , end ) ; } else { return null ; } }	parses an authority out of the given uri string .
public static void sort ( list < ? > list ) { if ( list . size ( ) > _num ) { collections . sort ( list , instance ) ; } }	sort the given list with a default annotationawareordercomparator.
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public void adddatatransferprogresslistener ( ondatatransferprogresslistener listener , ocupload ocupload ) { if ( ocupload == null || listener == null ) return ; string targetkey = buildremotename ( ocupload . getaccountname ( ) , ocupload . getremotepath ( ) ) ; mboundlisteners . put ( targetkey , listener ) ; }	adds a listener interested in the progress of the upload for a concrete file .
protected string [ ] readnext ( linenumberreader reader ) throws ioexception { string [ ] rowdef = null ; do { string nextline = reader . readline ( ) ; if ( nextline == null ) { hasnext = _bool ; return rowdef ; } string [ ] r = parser . parselinemulti ( nextline ) ; if ( r . length > _num ) { if ( rowdef == null ) { rowdef = r ; } else { string [ ] t = new string [ rowdef . length + r . length ] ; system . arraycopy ( rowdef , _num , t , _num , rowdef . length ) ; system . arraycopy ( r , _num , t , rowdef . length , r . length ) ; rowdef = t ; } } } while ( parser . ispending ( ) ) ; return rowdef ; }	load the next set of csv values from the file.
private void verifypropertysourcevalue ( reloadablepropertysource reloadablepropertysource , string expectedvalue ) { logger . debug ( _str + test_key + _str + expectedvalue ) ; logger . debug ( _str + properties . get ( test_key ) + _str + reloadablepropertysource . getproperty ( test_key ) ) ; string value = ( string ) reloadablepropertysource . getproperty ( test_key ) ; assertequals ( expectedvalue , value ) ; }	reads the test key from the reloadable property source and verifies that it is set to the specified expected value .
private void updatecenterpanel ( ) { long now = system . currenttimemillis ( ) ; if ( _nextupdatetime > now ) return ; _nextupdatetime = now + _num * _num ; _centerpanel . removeall ( ) ; _centercomponent = new jlabel ( ) ; gridbagconstraints gbc = new gridbagconstraints ( ) ; gbc . gridx = _num ; gbc . gridy = _num ; gbc . weightx = _num ; gbc . fill = gridbagconstraints . none ; gbc . anchor = gridbagconstraints . center ; _centerpanel . add ( _centercomponent , gbc ) ; refresh ( ) ; }	updates the center panel if non - pro.
public void servicerequestqueue ( ) throws cliexception { if ( isverbose ( ) ) { outputwriter . printlnmessage ( rbmessages . getstring ( _str ) ) ; } try { while ( ! requestqueue . isempty ( ) ) { clirequest req = ( clirequest ) requestqueue . remove ( _num ) ; try { req . process ( this ) ; if ( statusos != null ) { string status = formatstatus ( req . getoptions ( ) , _num ) ; statusos . write ( status . getbytes ( ) ) ; } } catch ( cliexception e ) { if ( isverbose ( ) ) { e . printstacktrace ( system . out ) ; } if ( statusos != null ) { string status = formatstatus ( req . getoptions ( ) , e . getexitcode ( ) ) ; statusos . write ( status . getbytes ( ) ) ; } if ( bcontinue ) { outputwriter . printlnerror ( e . getmessage ( ) ) ; } else { throw e ; } } } } catch ( ioexception e ) { throw new cliexception ( e , exitcodes . request_cannot_be_processed ) ; } finally { if ( statusos != null ) { try { statusos . close ( ) ; } catch ( ioexception ex ) { } statusos = null ; } } }	services the request queue .
alwaysidenticalkeystorestate ( ) { super ( ) ; }	create an empty state .
public static byte [ ] packbytebufferintosinglebytearray ( bytebuffer [ ] bytebufferarr ) { if ( null == bytebufferarr || bytebufferarr . length == _num ) { return null ; } int noofcol = bytebufferarr . length ; short offsetlen = ( short ) ( noofcol * _num ) ; int totalbytes = calculatetotalbytes ( bytebufferarr ) + offsetlen ; bytebuffer buffer = bytebuffer . allocate ( totalbytes ) ; buffer . putshort ( offsetlen ) ; for ( int index = _num ; index < bytebufferarr . length - _num ; index ++ ) { bytebuffer individualcol = bytebufferarr [ index ] ; int noofbytes = individualcol . capacity ( ) ; buffer . putshort ( ( short ) ( offsetlen + noofbytes ) ) ; offsetlen += noofbytes ; individualcol . rewind ( ) ; } for ( int index = _num ; index < bytebufferarr . length ; index ++ ) { bytebuffer individualcol = bytebufferarr [ index ] ; buffer . put ( individualcol . array ( ) ) ; } buffer . rewind ( ) ; return buffer . array ( ) ; }	this method will form one single byte [ ] for all the high card dims . first it will add all the indexes of variable length byte [ ] and then the actual value.
public void stop ( ) { mcancel = _bool ; if ( mrunning . compareandset ( _bool , _bool ) ) { if ( msampledispatchertask != null ) { mthreadpoolmanager . cancel ( msampledispatchertask ) ; msampledispatchertask = null ; mfilledbuffers . clear ( ) ; } } }	stops the sample fetching thread.
public void add ( simplename ref ) { string typename = ref . getidentifier ( ) ; if ( fimportsadded . contains ( typename ) ) { return ; } ibinding binding = ref . resolvebinding ( ) ; if ( binding != null ) { if ( binding . getkind ( ) != ibinding . type ) { return ; } itypebinding typebinding = ( itypebinding ) binding ; if ( typebinding . isarray ( ) ) { typebinding = typebinding . getelementtype ( ) ; } typebinding = typebinding . gettypedeclaration ( ) ; if ( ! typebinding . isrecovered ( ) ) { if ( needsimport ( typebinding , ref ) ) { fimpstructure . addimport ( typebinding ) ; fimportsadded . add ( typename ) ; } return ; } } else { if ( fdoignorelowercasenames && typename . length ( ) > _num ) { char ch = typename . charat ( _num ) ; if ( strings . islowercase ( ch ) && character . isletter ( ch ) ) { return ; } } } fimportsadded . add ( typename ) ; funresolvedtypes . put ( typename , new unresolvedtypedata ( ref ) ) ; }	tries to find the given type name and add it to the import structure .
private static boolean checkfont ( string fontname , string newname , string teststring , boolean force ) { boolean displayable = _bool ; font f = uimanager . getfont ( fontname ) ; if ( f != null && ! newname . equalsignorecase ( f . getname ( ) ) ) { if ( ! guiutils . candisplay ( f , teststring ) || force ) { f = new font ( newname , f . getstyle ( ) , f . getsize ( ) ) ; if ( guiutils . candisplay ( f , teststring ) ) uimanager . put ( fontname , f ) ; else displayable = _bool ; } } else if ( f != null ) { displayable = guiutils . candisplay ( f , teststring ) ; } else { displayable = _bool ; } return displayable ; }	updates the font of a given fontname to be newname .
public void addallsearchables ( arraylist < ? extends searchresult > searchable ) { msearchablelist . addall ( searchable ) ; }	add all searchable items.
public list < valuebox > addargumenthotspots ( string signature , int arg ) { list < valuebox > sigspots = stringanalysis . getargumentexpressions ( signature , arg ) ; return addargumenthotspots ( signature , arg , sigspots ) ; }	add a hotspot for matching calls .
public boolean isfull ( ) { return counter . get ( ) == qsize ; }	is queue is full .
public static string jq ( string request ) throws exception { int querystartpos = request . indexof ( _str ) ; string query ; string path ; if ( - _num == querystartpos ) { query = _str ; path = request ; } else { query = request . substring ( querystartpos + _num ) ; path = request . substring ( _num , querystartpos ) ; } query = setparam ( query , _str , _str ) ; request = path + _str + setparam ( query , _str , _str ) ; string response ; boolean failed = _bool ; try { response = resttestharness . query ( request ) ; failed = _bool ; } finally { if ( failed ) { log . error ( _str + request ) ; } } return response ; }	makes a query request and returns the json string response.
protected void shiftend ( int newsize ) { int oldsize = getarraylength ( ) ; int oldgapend = g1 ; int uppersize = oldsize - oldgapend ; int arraylength = getnewarraysize ( newsize ) ; int newgapend = arraylength - uppersize ; resize ( arraylength ) ; g1 = newgapend ; if ( uppersize != _num ) { system . arraycopy ( array , oldgapend , array , newgapend , uppersize ) ; } }	make the gap bigger , moving any necessary data and updating the appropriate marks.
public samfilterchain ( collection < samfilter > filters ) { mfilters = filters . toarray ( new samfilter [ filters . size ( ) ] ) ; }	construct a chain of sam filters.
previouswordaction ( string nm , boolean select ) { super ( nm ) ; this . select = select ; }	create this action with the appropriate identifier .
static unixstream < string > cat ( final string filepath ) throws ioexception { objects . requirenonnull ( filepath , _str ) ; return new unixstreamimpl < > ( lines ( paths . get ( filepath ) ) ) ; }	create a new unixstream of lines of the given file .
private static string encode_base64 ( byte d [ ] , int len ) throws illegalargumentexception { int off = _num ; stringbuffer rs = new stringbuffer ( ) ; int c1 , c2 ; if ( len <= _num || len > d . length ) { throw new illegalargumentexception ( _str ) ; } while ( off < len ) { c1 = d [ off ++ ] & _num ; rs . append ( base64_code [ ( c1 > > _num ) & _num ] ) ; c1 = ( c1 & _num ) << _num ; if ( off >= len ) { rs . append ( base64_code [ c1 & _num ] ) ; break ; } c2 = d [ off ++ ] & _num ; c1 |= ( c2 > > _num ) & _num ; rs . append ( base64_code [ c1 & _num ] ) ; c1 = ( c2 & _num ) << _num ; if ( off >= len ) { rs . append ( base64_code [ c1 & _num ] ) ; break ; } c2 = d [ off ++ ] & _num ; c1 |= ( c2 > > _num ) & _num ; rs . append ( base64_code [ c1 & _num ] ) ; rs . append ( base64_code [ c2 & _num ] ) ; } return rs . tostring ( ) ; }	encode a byte array using bcrypt ' s slightly - modified base64 encoding scheme.
protected void eleminateredundent ( elemtemplateelement psuedovarrecipient , vector paths ) { int n = paths . size ( ) ; int numpathseliminated = _num ; int numuniquepathseliminated = _num ; for ( int i = _num ; i < n ; i ++ ) { expressionowner owner = ( expressionowner ) paths . elementat ( i ) ; if ( null != owner ) { int found = findandeliminateredundant ( i + _num , i , owner , psuedovarrecipient , paths ) ; if ( found > _num ) numuniquepathseliminated ++ ; numpathseliminated += found ; } } eleminatesharedpartialpaths ( psuedovarrecipient , paths ) ; if ( diagnose_num_paths_reduced ) diagnosenumpaths ( paths , numpathseliminated , numuniquepathseliminated ) ; }	method to be called after the all expressions within an node context have been visited.
public void commercialresult ( string stream , string resulttext , requestresult result ) { setcommercialresult ( datetime . currenttime ( ) + _str + resulttext ) ; lastcommercialrunattempt = system . currenttimemillis ( ) ; setloadingcommercial ( _bool ) ; if ( result == twitchapi . requestresult . running_commercial ) { lastcommercial . put ( stream , system . currenttimemillis ( ) ) ; if ( stream != null && stream . equals ( currentchannel ) ) { lastcommercialrun = system . currenttimemillis ( ) ; } } }	the commercial result as returned from the api.
public void done ( ) throws ioexception { if ( ! initialstyles ) { writeinitialstyles ( ) ; initialstyles = _bool ; } out . writeubits ( _num , _num ) ; out . flushbits ( ) ; if ( bout != null && glyphcount > _num ) { byte [ ] glyphbytes = bout . tobytearray ( ) ; glyphbytearrays . add ( glyphbytes ) ; } if ( glyphcount > _num ) { bout = new bytearrayoutputstream ( ) ; out = new outstream ( bout ) ; glyphcount -- ; fill1index = _num ; lineindex = _num ; outstandingchanges = _bool ; initialstyles = _bool ; } else { if ( bout != null ) { finishfont ( ) ; } writer . completetag ( ) ; } }	description of the method.
private static detachisoresponse checkdetachisoresponse ( detachisoresponse detachisoresponse ) throws rpcexception { logger . info ( _str , detachisoresponse ) ; switch ( detachisoresponse . getresult ( ) ) { case ok : break ; case iso_not_attached : logger . warn ( _str , detachisoresponse ) ; throw new isonotattachedexception ( detachisoresponse . geterror ( ) ) ; case system_error : logger . warn ( _str , detachisoresponse ) ; throw new systemerrorexception ( detachisoresponse . geterror ( ) ) ; case vm_not_found : logger . warn ( _str , detachisoresponse ) ; throw new vmnotfoundexception ( detachisoresponse . geterror ( ) ) ; default : throw new rpcexception ( string . format ( _str , detachisoresponse . getresult ( ) ) ) ; } return detachisoresponse ; }	this method validates a detachisoresponse object , raising an exception if the response reflects an operation failure .
public boolean is_terminal ( methodormethodcontext mc ) { stack < sootmethod > sys_stack = new stack < sootmethod > ( ) ; boolean result ; if ( ! is_system ( mc . method ( ) ) ) result = _bool ; else { if ( ! process_callbacks ) result = _bool ; else { if ( ( stack . size ( ) > _num ) && is_system ( stack . peek ( ) ) ) result = ! calls_app_method ( mc , sys_stack ) ; else { if ( can_have_callbacks ( mc . method ( ) ) ) result = ! calls_app_method ( mc , sys_stack ) ; else result = _bool ; } } } logger . info ( _str , mc . method ( ) , result ) ; return result ; }	returns true if the specified method should terminate the call graph the call graph is terminated on system calls that do not have callbacks into application code .
boolean trymatch ( snode s ) { if ( match == null && unsafe . compareandswapobject ( this , matchoffset , null , s ) ) { thread w = waiter ; if ( w != null ) { waiter = null ; locksupport . unpark ( w ) ; } return _bool ; } return match == s ; }	tries to match node s to this node , if so , waking up thread.
public void additem ( int position , m model ) { mdatas . add ( position , model ) ; notifyiteminserted ( position ) ; }	insert data for position.
public final set < string > aliases ( ) { return collections . unmodifiableset ( this . aliasesset ) ; }	returns an unmodifiable set of this charset ' s aliases .
public void encode ( outputstream out ) throws ioexception { deroutputstream tmp = new deroutputstream ( ) ; if ( this . extensionvalue == null ) { this . extensionid = pkixextensions . issuingdistributionpoint_id ; this . critical = _bool ; encodethis ( ) ; } super . encode ( tmp ) ; out . write ( tmp . tobytearray ( ) ) ; }	encodes the issuing distribution point extension and writes it to the deroutputstream .
public final void readchildren ( objectinputstream ois ) throws ioexception , classnotfoundexception { int count = serializable ; while ( count -- > _num ) { object child = null ; beancontextsupport . bcschild bscc = null ; try { child = ois . readobject ( ) ; bscc = ( beancontextsupport . bcschild ) ois . readobject ( ) ; } catch ( ioexception ioe ) { continue ; } catch ( classnotfoundexception cnfe ) { continue ; } synchronized ( child ) { beancontextchild bcc = null ; try { bcc = ( beancontextchild ) child ; } catch ( classcastexception cce ) { } if ( bcc != null ) { try { bcc . setbeancontext ( getbeancontextpeer ( ) ) ; bcc . addpropertychangelistener ( _str , childpcl ) ; bcc . addvetoablechangelistener ( _str , childvcl ) ; } catch ( propertyvetoexception pve ) { continue ; } } childdeserializedhook ( child , bscc ) ; } } }	when an instance of this class is used as a delegate for the implementation of the beancontext protocols ( and its subprotocols ) there exists a ' chicken and egg ' problem during deserialization.
static boolean ischristmastime ( calendar cal ) { int month = cal . get ( calendar . month ) ; int day = cal . get ( calendar . day_of_month ) ; if ( month >= _num && month < _num ) { return _bool ; } if ( month == _num ) { return day <= _num ; } if ( month == _num ) { return day >= _num ; } return _bool ; }	checks whether now is christmas time.
@ override public void zoomrangeaxes ( double factor , plotrenderinginfo info , point2d source ) { zoomrangeaxes ( factor , info , source , _bool ) ; }	multiplies the range on the range axis / axes by the specified factor .
private void boardsaveimage ( ) { if ( curfileimage == null ) { boardsaveasimage ( ) ; return ; } jdialog waitd = new jdialog ( frame , messages . getstring ( _str ) ) ; waitd . add ( new jlabel ( messages . getstring ( _str ) ) ) ; waitd . setsize ( _num , _num ) ; waitd . setlocation ( ( frame . getsize ( ) . width / _num ) - ( waitd . getsize ( ) . width / _num ) , ( frame . getsize ( ) . height / _num ) - ( waitd . getsize ( ) . height / _num ) ) ; waitd . setvisible ( _bool ) ; frame . setcursor ( cursor . getpredefinedcursor ( cursor . wait_cursor ) ) ; waitd . setcursor ( cursor . getpredefinedcursor ( cursor . wait_cursor ) ) ; try { imageio . write ( bv . getentireboardimage ( ) , _str , curfileimage ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } waitd . setvisible ( _bool ) ; frame . setcursor ( cursor . getdefaultcursor ( ) ) ; }	saves the board in png image format .
public boolean containsname ( string type , string name ) { list < string > names = getnames ( type ) ; return names . contains ( name ) ; }	determines if a car type can have a specific load name .
@ suppresswarnings ( _str ) public static < c extends result > arraylist < c > filterresults ( resulthierarchy hier , result r , class < ? super c > restrictionclass ) { arraylist < c > res = new arraylist < > ( ) ; if ( restrictionclass . isinstance ( r ) ) { res . add ( ( c ) restrictionclass . cast ( r ) ) ; } for ( hierarchy . iter < result > iter = hier . iterdescendants ( r ) ; iter . valid ( ) ; iter . advance ( ) ) { result result = iter . get ( ) ; if ( restrictionclass . isinstance ( result ) ) { res . add ( ( c ) restrictionclass . cast ( result ) ) ; } } return res ; }	return only results of the given restriction class.
@ pure @ causeserror ( { incorrectpure4jimmutablecallexception . class , puremethodparameternotimmutableexception . class } ) public string testparam1bad ( object in1 , object in2 ) { object in3 = in2 ; pure4j . immutable ( in1 , in2 ) ; return in3 . tostring ( ) ; }	not going to be pure as we do something before checking.
protected boolean [ ] canhandlemissing ( boolean nominalpredictor , boolean numericpredictor , boolean stringpredictor , boolean datepredictor , boolean relationalpredictor , boolean multiinstance , int classtype , boolean predictormissing , boolean classmissing , int missinglevel ) { if ( missinglevel == _num ) { print ( _str ) ; } print ( _str ) ; if ( predictormissing ) { print ( _str ) ; if ( classmissing ) { print ( _str ) ; } } if ( classmissing ) { print ( _str ) ; } print ( _str ) ; printattributesummary ( nominalpredictor , numericpredictor , stringpredictor , datepredictor , relationalpredictor , multiinstance , classtype ) ; print ( _str ) ; arraylist < string > accepts = new arraylist < string > ( ) ; accepts . add ( _str ) ; accepts . add ( _str ) ; accepts . add ( _str ) ; accepts . add ( _str ) ; int numtrain = getnuminstances ( ) , numclasses = _num ; return runbasictest ( nominalpredictor , numericpredictor , stringpredictor , datepredictor , relationalpredictor , multiinstance , classtype , missinglevel , predictormissing , classmissing , numtrain , numclasses , accepts ) ; }	checks basic missing value handling of the scheme.
public set < brditem > pick_items ( plapoint p_location , int p_layer , itemselectionfilter p_filter ) { set < brditem > result = new treeset < brditem > ( ) ; shapetilebox point_shape = p_location . to_box ( ) ; collection < awtreeobject > overlaps = overlapping_objects ( point_shape , p_layer ) ; for ( awtreeobject curr_object : overlaps ) { if ( ! ( curr_object instanceof brditem ) ) continue ; brditem curr_item = ( brditem ) curr_object ; if ( ! curr_item . is_selected_by_filter ( p_filter ) ) continue ; result . add ( curr_item ) ; } return result ; }	returns the list of items on the board , whose shape on layer p_layer contains the point at p_location.
public boolean iscollinearwith ( vector other ) { if ( x == _num && y == _num && z == _num ) { return _bool ; } final double otherx = other . x ; final double othery = other . y ; final double otherz = other . z ; if ( otherx == _num && othery == _num && otherz == _num ) { return _bool ; } if ( ( x == _num ) != ( otherx == _num ) ) return _bool ; if ( ( y == _num ) != ( othery == _num ) ) return _bool ; if ( ( z == _num ) != ( otherz == _num ) ) return _bool ; final double quotientx = otherx / x ; if ( ! double . isnan ( quotientx ) ) { return other . equals ( multiply ( quotientx ) ) ; } final double quotienty = othery / y ; if ( ! double . isnan ( quotienty ) ) { return other . equals ( multiply ( quotienty ) ) ; } final double quotientz = otherz / z ; if ( ! double . isnan ( quotientz ) ) { return other . equals ( multiply ( quotientz ) ) ; } throw new runtimeexception ( _str ) ; }	returns whether this vector is collinear with another vector .
public void receive ( float [ ] currentfftbins ) { if ( float . isinfinite ( currentfftbins [ _num ] ) || float . isnan ( currentfftbins [ _num ] ) ) { currentfftbins = new float [ currentfftbins . length ] ; } if ( mdisplayfftbins == null || mdisplayfftbins . length != currentfftbins . length ) { mdisplayfftbins = currentfftbins ; } float [ ] smoothedbins = msmoothingfilter . filter ( currentfftbins ) ; if ( maveraging > _num ) { float gain = _num / ( float ) maveraging ; for ( int x = _num ; x < mdisplayfftbins . length ; x ++ ) { mdisplayfftbins [ x ] += ( smoothedbins [ x ] - mdisplayfftbins [ x ] ) * gain ; } } else { mdisplayfftbins = smoothedbins ; } repaint ( ) ; }	dftresultslistener interface for receiving the processed data to display.
@ override public void executionunitimported ( final executionunit process , final element element ) { nodelist children = element . getchildnodes ( ) ; children = element . getchildnodes ( ) ; for ( int i = _num ; i < children . getlength ( ) ; i ++ ) { node child = children . item ( i ) ; if ( child instanceof element ) { element backgroundelement = ( element ) child ; if ( xml_tag_background . equals ( backgroundelement . gettagname ( ) ) ) { string xstr = backgroundelement . getattribute ( xml_attribute_x_position ) ; string ystr = backgroundelement . getattribute ( xml_attribute_y_position ) ; string wstr = backgroundelement . getattribute ( xml_attribute_width ) ; string hstr = backgroundelement . getattribute ( xml_attribute_height ) ; string imglocstr = backgroundelement . getattribute ( xml_attribute_location ) ; try { int xloc = integer . parseint ( xstr ) ; int yloc = integer . parseint ( ystr ) ; int wloc = integer . parseint ( wstr ) ; int hloc = integer . parseint ( hstr ) ; processbackgroundimage bgimg = new processbackgroundimage ( xloc , yloc , wloc , hloc , imglocstr , process ) ; setbackgroundimage ( bgimg ) ; } catch ( nullpointerexception | illegalargumentexception e ) { } } } } }	extracts port spacings from the xml element .
private void sendmailtoqueue ( string to , string subject , string content , boolean ismultipart , boolean ishtml ) { emailparams emailparams = new emailparams ( to , subject , content , ismultipart , ishtml ) ; rabbittemplate . convertandsend ( rabbitmqconfiguration . queue_send_email , emailparams ) ; }	send emails via rabbitmq queue.
private set < objectinstance > filterlistofobjectinstances ( set < objectinstance > list , queryexp query ) { if ( query == null ) { return list ; } else { set < objectinstance > result = new hashset < objectinstance > ( ) ; for ( objectinstance oi : list ) { boolean res = _bool ; mbeanserver oldserver = queryeval . getmbeanserver ( ) ; query . setmbeanserver ( server ) ; try { res = query . apply ( oi . getobjectname ( ) ) ; } catch ( exception e ) { res = _bool ; } finally { query . setmbeanserver ( oldserver ) ; } if ( res ) { result . add ( oi ) ; } } return result ; } }	applies the specified queries to the set of objectinstances .
@ path ( _str ) @ timed @ exceptionmetered @ get public automationsecretresponse readsecretbyid ( @ auth automationclient automationclient , @ pathparam ( _str ) longparam secretid ) { optional < secret > secret = secretcontroller . getsecretbyid ( secretid . get ( ) ) ; if ( ! secret . ispresent ( ) ) { throw new notfoundexception ( _str ) ; } immutablelist < group > groups = immutablelist . copyof ( acldao . getgroupsfor ( secret . get ( ) ) ) ; return automationsecretresponse . fromsecret ( secret . get ( ) , groups ) ; }	retrieve secret by id.
protected void addactionexceptionwarning ( exception e ) { string msg = e . getmessage ( ) ; if ( msg != null ) { warnings . add ( msg ) ; } }	adds an exception message , if not null , to the action warnings .
private void generatefieldinfos ( itype type , ibinarytype typeinfo , hashmap newelements , arraylist childrenhandles ) { ibinaryfield [ ] fields = typeinfo . getfields ( ) ; if ( fields == null ) { return ; } javamodelmanager manager = ( ( javaelement ) type ) . manager ; for ( int i = _num , fieldcount = fields . length ; i < fieldcount ; i ++ ) { ibinaryfield fieldinfo = fields [ i ] ; binaryfield field = new binaryfield ( ( javaelement ) type , manager , manager . intern ( new string ( fieldinfo . getname ( ) ) ) ) ; newelements . put ( field , fieldinfo ) ; childrenhandles . add ( field ) ; generateannotationsinfos ( field , fieldinfo . getannotations ( ) , fieldinfo . gettagbits ( ) , newelements ) ; } }	creates the handles and infos for the fields of the given binary type.
public void testformattingyear ( ) { formattester test = new formattester ( ) ; calendar cal = new gregoriancalendar ( _num , calendar . june , _num , _num , _num , _num ) ; test . test ( _str , cal , _str , dateformat . year_field ) ; test . test ( _str , cal , _str , dateformat . year_field ) ; test . test ( _str , new gregoriancalendar ( _num , calendar . june , _num ) , _str , dateformat . year_field ) ; test . test ( _str , new gregoriancalendar ( _num , calendar . june , _num ) , _str , dateformat . year_field ) ; test . test ( _str , new gregoriancalendar ( _num , calendar . june , _num ) , _str , dateformat . year_field ) ; test . test ( _str , cal , _str , dateformat . year_field ) ; test . test ( _str , cal , _str , dateformat . year_field ) ; test . test ( _str , cal , _str , dateformat . year_field ) ; assertfalse ( test . testsfailed ) ; }	this test assumes unicode behavior where ' y ' and ' yyy ' don ' t truncate , which means that it will fail on the ri .
public list < string > generatemodel ( string schema , string table , string packagename , boolean annotateschema , boolean trimstrings ) { try { list < string > models = new . arraylist ( ) ; list < tableinspector > tables = gettables ( schema , table ) ; for ( tableinspector t : tables ) { t . read ( metadata ) ; string model = t . generatemodel ( packagename , annotateschema , trimstrings ) ; models . add ( model ) ; } return models ; } catch ( sqlexception s ) { throw new runtimeexception ( s ) ; } }	generates models class skeletons for schemas and tables.
public static ed25519encodedfieldelement toencodedfieldelement ( final biginteger b ) { return new ed25519encodedfieldelement ( tobytearray ( b ) ) ; }	converts a biginteger to an encoded field element .
protected arraylist < keynamepair > loadrmadata ( int c_bpartner_id ) { arraylist < keynamepair > list = new arraylist < keynamepair > ( ) ; string sqlstmt = _str + _str + _str + _str + _str + _str ; preparedstatement pstmt = null ; try { pstmt = db . preparestatement ( sqlstmt , null ) ; pstmt . setint ( _num , c_bpartner_id ) ; resultset rs = pstmt . executequery ( ) ; while ( rs . next ( ) ) { list . add ( new keynamepair ( rs . getint ( _num ) , rs . getstring ( _num ) ) ) ; } rs . close ( ) ; } catch ( sqlexception e ) { log . log ( level . severe , sqlstmt . tostring ( ) , e ) ; } finally { if ( pstmt != null ) { try { pstmt . close ( ) ; } catch ( exception ex ) { log . severe ( _str ) ; } } } return list ; }	load pbartner dependent order / invoice / shipment field .
private void checksendtracktogoogle ( ) { if ( ! sendtogoogle ( activitymytracks . getstring ( r . string . export_google_maps ) ) || ! sendtogoogle ( activitymytracks . getstring ( r . string . export_google_fusion_tables ) ) || ! sendtogoogle ( activitymytracks . getstring ( r . string . export_google_spreadsheets ) ) ) { return ; } asserttrue ( googleutils . deletemaps ( activitymytracks . getapplicationcontext ( ) , googleutils . account_1 , endtoendtestutils . trackname ) ) ; asserttrue ( googleutils . deletefusiontables ( activitymytracks . getapplicationcontext ( ) , googleutils . account_1 , endtoendtestutils . trackname ) ) ; asserttrue ( googleutils . deletespreadsheetsrow ( activitymytracks . getapplicationcontext ( ) , googleutils . account_1 , endtoendtestutils . trackname ) ) ; }	checks the process of sending track to google .
public void ondependencychanged ( preference dependency , boolean disabledependent ) { if ( mdependencymet == disabledependent ) { mdependencymet = ! disabledependent ; notifydependencychange ( shoulddisabledependents ( ) ) ; notifychanged ( ) ; } }	called when the dependency changes .
@ override public double analyse ( double [ ] frame ) { if ( frame . length != getframelengthsamples ( ) ) throw new illegalargumentexception ( _str + getframelengthsamples ( ) + _str + frame . length ) ; double totalenergy = _num ; for ( int i = _num ; i < frame . length ; i ++ ) { totalenergy += frame [ i ] * frame [ i ] ; } rememberframeenergy ( totalenergy ) ; return new double ( totalenergy ) ; }	apply this framebasedanalyser to the given data .
public static element firstchildelement ( element element ) { if ( element == null ) return null ; node node = element . getfirstchild ( ) ; if ( node != null ) { do { if ( node . getnodetype ( ) == node . element_node ) { element childelement = ( element ) node ; return childelement ; } } while ( ( node = node . getnextsibling ( ) ) != null ) ; } return null ; }	return the first child element returns the first element .
private static void partialmatch ( dimensionalnode node , boolean [ ] relevant , double [ ] keys , arraylist < imultipoint > results ) { imultipoint pt = node . point ; boolean match = _bool ; for ( int i = _num ; i < relevant . length ; i ++ ) { if ( ! relevant [ i ] ) continue ; if ( ! floatingpoint . same ( pt . getcoordinate ( i + _num ) , keys [ i ] ) ) { match = _bool ; break ; } } if ( match ) { results . add ( pt ) ; } int d = node . dimension ; if ( relevant [ d - _num ] ) { if ( floatingpoint . lesserequals ( keys [ d - _num ] , pt . getcoordinate ( d ) ) ) { dimensionalnode below = node . getbelow ( ) ; if ( below != null ) { partialmatch ( below , relevant , keys , results ) ; } } if ( floatingpoint . greaterequals ( keys [ d - _num ] , pt . getcoordinate ( d ) ) ) { dimensionalnode above = node . getabove ( ) ; if ( above != null ) { partialmatch ( above , relevant , keys , results ) ; } } } else { dimensionalnode below = node . getbelow ( ) ; if ( below != null ) { partialmatch ( below , relevant , keys , results ) ; } dimensionalnode above = node . getabove ( ) ; if ( above != null ) { partialmatch ( above , relevant , keys , results ) ; } } }	description of algorithm taken from bentley ' s original paper .
public static string encodeforredirect ( final string str ) { string classmethod = _str ; byte [ ] input ; try { input = str . getbytes ( _str ) ; } catch ( unsupportedencodingexception uee ) { debug . error ( classmethod + _str , uee ) ; return null ; } deflater deflater = new deflater ( deflater . default_compression , _bool ) ; bytearrayoutputstream out = new bytearrayoutputstream ( ) ; deflateroutputstream deflateroutputstream = new deflateroutputstream ( out , deflater ) ; try { deflateroutputstream . write ( input ) ; } catch ( ioexception e ) { debug . error ( classmethod + _str , e ) ; return null ; } finally { ioutils . closeifnotnull ( deflateroutputstream ) ; } string encoded = urlencdec . encode ( base64 . encode ( out . tobytearray ( ) ) ) ; if ( debug . messageenabled ( ) ) { debug . message ( classmethod + _str + encoded . length ( ) ) ; debug . message ( classmethod + _str + encoded + _str ) ; } return encoded ; }	returns the encoded request message.
private void savetouchstart ( motionevent event ) { msavedmatrix . set ( mmatrix ) ; mtouchstartpoint . set ( event . getx ( ) , event . gety ( ) ) ; mclosestdatasettotouch = mchart . getdatasetbytouchpoint ( event . getx ( ) , event . gety ( ) ) ; }	saves the current matrix state and the touch - start point .
public static boolean isnestedmapping ( string regex ) { return regex . startswith ( nested_mapping_starts_symbol ) && regex . endswith ( nested_mapping_ends_symbol ) ; }	returns true if this regex represents a nested mapping , false other cases .
public string tostring ( ) { return super . tostring ( ) + _str + string . valueof ( date ) ; }	returns a printable representation of the invalidity date .
private boolean hasimages ( iaction actiontocheck ) { return actiontocheck . getimagedescriptor ( ) != null || actiontocheck . gethoverimagedescriptor ( ) != null || actiontocheck . getdisabledimagedescriptor ( ) != null ; }	returns whether the given action has any images .
public double calcanglebetweenlines ( entry start1 , entry end1 , entry start2 , entry end2 ) { double angle1 = calcanglewithratios ( start1 , end1 ) ; double angle2 = calcanglewithratios ( start2 , end2 ) ; return math . abs ( angle1 - angle2 ) ; }	calculates the angle between two given lines.
public double converttoattribx ( double scx ) { double temp = m_xaxisend - m_xaxisstart ; double temp2 = ( ( scx - m_xaxisstart ) * ( m_maxx - m_minx ) ) / temp ; temp2 = temp2 + m_minx ; return temp2 ; }	convert a panel x coordinate to a raw x value .
public void completeexecutortask ( ) { executorqueueitem item = null ; synchronized ( _executorlock ) { _executortaskcount -- ; assert ( _executortaskcount >= _num ) ; if ( _executorqueuehead != null ) { item = _executorqueuehead ; _executorqueuehead = item . _next ; if ( _executorqueuehead == null ) _executorqueuetail = null ; } } if ( item != null ) { runnable task = item . getrunnable ( ) ; classloader loader = item . getloader ( ) ; boolean ispriority = _bool ; boolean isqueue = _bool ; boolean iswake = _bool ; scheduleimpl ( task , loader , max_expire , ispriority , isqueue , iswake ) ; } }	called when an executor task completes.
public static void forcemkdir ( file directory ) throws ioexception { if ( directory . exists ( ) ) { if ( ! directory . isdirectory ( ) ) { string message = _str + directory + _str + _str ; throw new ioexception ( message ) ; } } else { if ( ! directory . mkdirs ( ) ) { if ( ! directory . isdirectory ( ) ) { string message = _str + directory ; throw new ioexception ( message ) ; } } } }	makes a directory , including any necessary but nonexistent parent directories.
private < t > int countclearedrefs ( list < weakreference < t > > refs ) { final iterator < weakreference < t > > itr = refs . iterator ( ) ; int n = _num ; while ( itr . hasnext ( ) ) { final weakreference < t > ref = itr . next ( ) ; if ( ref . get ( ) == null ) n ++ ; } return n ; }	return the # of entries in the collection whose references have been cleared .
protected void readimage ( ) { ix = readshort ( ) ; iy = readshort ( ) ; iw = readshort ( ) ; ih = readshort ( ) ; int packed = read ( ) ; lctflag = ( packed & _num ) != _num ; interlace = ( packed & _num ) != _num ; lctsize = _num << ( packed & _num ) ; if ( lctflag ) { lct = readcolortable ( lctsize ) ; act = lct ; } else { act = gct ; if ( bgindex == transindex ) bgcolor = _num ; } int save = _num ; if ( transparency ) { save = act [ transindex ] ; act [ transindex ] = _num ; } if ( act == null ) { status = status_format_error ; } if ( err ( ) ) return ; decodeimagedata ( ) ; skip ( ) ; if ( err ( ) ) return ; framecount ++ ; image = new bufferedimage ( width , height , bufferedimage . type_int_argb_pre ) ; setpixels ( ) ; frames . add ( new gifframe ( image , delay ) ) ; if ( transparency ) { act [ transindex ] = save ; } resetframe ( ) ; }	reads next frame image.
protected void addprojectedfield ( string s ) { try { field f = inclazz . getdeclaredfield ( s ) ; typeinfo t = new typeinfo ( f . getname ( ) , classutils . primitivetowrapper ( f . gettype ( ) ) ) ; t . getter = pojoutils . creategetter ( inclazz , t . name , t . type ) ; t . setter = pojoutils . createsetter ( projectedclazz , t . name , t . type ) ; projectedfields . add ( t ) ; } catch ( nosuchfieldexception e ) { throw new runtimeexception ( _str + s + _str + inclazz , e ) ; } }	addprojectedfield : add field details ( name , type , getter and setter ) for field with given name in projectedfields list.
protected object evaluateleftgreaterright ( list elements , string lvalue , string rvalue ) { list array ; if ( elements instanceof java . util . vector ) { array = new java . util . vector ( ) ; } else { array = new arraylist ( ) ; } for ( iterator e = elements . iterator ( ) ; e . hasnext ( ) ; ) { object o = e . next ( ) ; if ( o instanceof structuredcontent ) { if ( ( o = evaluateleftgreaterright ( ( structuredcontent ) o , lvalue , rvalue ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == _num ) { return ( structuredcontent ) array . get ( _num ) ; } return array ; }	override this element to handle testing a predicate expression where lvalue > rvalue.
public optional < double > avg ( ) { if ( isempty ( ) ) return optional . empty ( ) ; return optional . of ( sum ( ) / geteventcount ( ) ) ; }	return the average of the histogram .
public static boolean issu ( string shell ) { int pos = shell . indexof ( _str ) ; if ( pos >= _num ) { shell = shell . substring ( _num , pos ) ; } pos = shell . lastindexof ( _str ) ; if ( pos >= _num ) { shell = shell . substring ( pos + _num ) ; } return shell . equals ( _str ) ; }	attempts to deduce if the shell command refers to a su shell.
private boolean isvalid ( int type , string value ) { if ( value == null ) { return _bool ; } if ( allowed_strings [ type ] != null ) { return verifystringgroup ( value , allowed_strings [ type ] ) ; } switch ( type ) { case type_number : return verify ( value , digits , null ) ; case type_pixels_or_percentage : if ( value . endswith ( _str ) ) { value = value . substring ( _num , value . length ( ) - _num ) ; } else if ( value . endswith ( _str ) ) { value = value . substring ( _num , value . length ( ) - _num ) ; } return verify ( value , digits , null ) ; case type_char : return verify ( value , digits | abc , null , _num , _num ) ; case type_color : if ( value . length ( ) == _num ) { return _bool ; } if ( value . charat ( _num ) != _str ) { return verifystringgroup ( value , color_strings ) ; } else { return verify ( value . substring ( _num ) , hex , null , _num , _num ) ; } default : return _bool ; } }	verifies that the specified value conforms with the attribute ' s type restrictions.
private int parsestreams ( string json , set < streaminfo > streaminfos ) { try { jsonparser parser = new jsonparser ( ) ; jsonarray streamsarray ; try { jsonobject root = ( jsonobject ) parser . parse ( json ) ; streamsarray = ( jsonarray ) root . get ( _str ) ; } catch ( classcastexception ex ) { logger . warning ( _str ) ; streamsrequesterror ( streaminfos ) ; return - _num ; } if ( streamsarray == null ) { logger . warning ( _str ) ; streamsrequesterror ( streaminfos ) ; return - _num ; } for ( object obj : streamsarray ) { if ( obj instanceof jsonobject ) { streaminfo parsedinfo = parsestream ( ( jsonobject ) obj , streaminfos == null ) ; if ( parsedinfo == null ) { logger . warning ( _str + ( jsonobject ) obj ) ; } if ( streaminfos != null ) { streaminfos . remove ( parsedinfo ) ; } } else { logger . warning ( _str + obj ) ; } } if ( streaminfos != null ) { for ( streaminfo info : streaminfos ) { info . setoffline ( ) ; } } return streamsarray . size ( ) ; } catch ( parseexception ex ) { logger . warning ( _str + ex . getlocalizedmessage ( ) ) ; streamsrequesterror ( streaminfos ) ; return - _num ; } }	parses a list of stream objects.
public strtokenizer reset ( string input ) { reset ( ) ; if ( input != null ) { this . chars = input . tochararray ( ) ; } else { this . chars = null ; } return this ; }	zkrestore this tokenizer , giving it a new input string to parse.
public void runtest ( ) throws throwable { document doc ; entityreference entref ; characterdata enttext ; doc = ( document ) load ( _str , _bool ) ; entref = doc . createentityreference ( _str ) ; assertnotnull ( _str , entref ) ; enttext = ( characterdata ) entref . getfirstchild ( ) ; assertnotnull ( _str , enttext ) ; { boolean success = _bool ; try { enttext . setnodevalue ( _str ) ; } catch ( domexception ex ) { success = ( ex . code == domexception . no_modification_allowed_err ) ; } asserttrue ( _str , success ) ; } }	runs the test case .
public void removelistener ( final ivisualcoveragelistener listener ) { listeners . remove ( listener ) ; }	removes a previously listening listener object .
@ objectivecname ( _str ) public boolean islargedialogmessage ( contenttype contenttype ) { switch ( contenttype ) { case service : case service_avatar : case service_avatar_removed : case service_created : case service_title : case service_leave : case service_registered : case service_kick : case service_add : case service_joined : case service_call_ended : case service_call_missed : case service_about : case service_topic : return _bool ; default : return _bool ; } }	if dialog list message need to be wide in group chat as it is already includes performer in it ' s body .
public static boolean isloggingbehaviorenabled ( loggingbehavior behavior ) { synchronized ( loggingbehaviors ) { return facebooksdk . isdebugenabled ( ) && loggingbehaviors . contains ( behavior ) ; } }	certain logging behaviors are available for debugging beyond those that should be enabled in production.
private void onattacked ( final entity attacker ) { attackers . remove ( attacker ) ; attackers . add ( attacker ) ; }	when attacker attacks this entity .
private void handledisallow ( parsestate state , robottoken token ) { if ( state . isskipagents ( ) ) { return ; } state . setfinishedagentfields ( _bool ) ; if ( ! state . isaddingrules ( ) ) { return ; } string path = token . getdata ( ) ; try { path = urldecoder . decode ( path , _str ) ; if ( path . length ( ) == _num ) { state . clearrules ( ) ; } else { state . addrule ( path , _bool ) ; } } catch ( exception e ) { reportwarning ( _str + path , state . geturl ( ) ) ; } }	handle the disallow : directive.
public void hidecolumn ( object columnname ) { if ( columnname == null ) { return ; } for ( int i = _num ; i < columnmodel . getcolumncount ( ) ; i ++ ) { tablecolumn column = columnmodel . getcolumn ( i ) ; if ( columnname . equals ( column . getheadervalue ( ) ) ) { hidecolumn ( column ) ; break ; } } }	hide a column from view in the table .
private boolean isasciidigit ( char c ) { return ( c >= _str && c <= _str ) ; }	tell if a character is an ascii digit .
public void accumulateall ( list < taggedlogapientity > entities ) throws exception { for ( taggedlogapientity entity : entities ) { accumulate ( entity ) ; } }	accumulate a list of entities.
protected void printidentifier ( string identifier , stringbuilder ddl ) { ddl . append ( getdelimitedidentifier ( identifier ) ) ; }	prints the given identifier.
public static int darker ( int c ) { return rgba ( math . max ( _num , ( int ) ( scale * red ( c ) ) ) , math . max ( _num , ( int ) ( scale * green ( c ) ) ) , math . max ( _num , ( int ) ( scale * blue ( c ) ) ) , alpha ( c ) ) ; }	get a darker shade of an input color .
private string tostring ( final int size ) { if ( size < _num ) { return string . format ( _str , size ) ; } else if ( size < _num * _num ) { return string . format ( locale . english , _str , _num * size / _num ) ; } else { return string . format ( locale . english , _str , _num * size / _num / _num ) ; } }	creates the section size formatter string depending on the size of the section .
@ knownfailure ( _str ) public void test_getcolumnsarbitrary ( ) throws sqlexception { resultset setallnull = null ; resultset setmixed = null ; resultset allarbitrary = null ; string [ ] tablesname = { databasecreator . test_table1 , databasecreator . test_table3 } ; arrays . sort ( tablesname ) ; int setsize = _num ; try { allarbitrary = meta . getcolumns ( _str , _str , _str , _str ) ; assertnotnull ( allarbitrary ) ; checkcolumnsshape ( allarbitrary ) ; setsize = crosscheckgetcolumnsandresultsetmetadata ( allarbitrary , _bool ) ; assertequals ( _num , setsize ) ; setmixed = meta . getcolumns ( null , null , _str , _str ) ; assertnotnull ( setmixed ) ; checkcolumnsshape ( setmixed ) ; setsize = crosscheckgetcolumnsandresultsetmetadata ( setmixed , _bool ) ; assertequals ( _num , setsize ) ; } catch ( sqlexception e ) { fail ( _str + e . getmessage ( ) ) ; } conn . close ( ) ; try { meta . getcolumns ( null , null , databasecreator . test_table1 , _str ) ; fail ( _str ) ; } catch ( sqlexception e ) { } }	java . sql . databasemetadata # getcolumns ( java . lang . string , java . lang . string , java . lang . string , java . lang . string ).
public static typemirror upperbound ( typemirror type ) { do { if ( type instanceof typevariable ) { typevariable tvar = ( typevariable ) type ; if ( tvar . getupperbound ( ) != null ) { type = tvar . getupperbound ( ) ; } else { break ; } } else if ( type instanceof wildcardtype ) { wildcardtype wc = ( wildcardtype ) type ; if ( wc . getextendsbound ( ) != null ) { type = wc . getextendsbound ( ) ; } else { break ; } } else { break ; } } while ( _bool ) ; return type ; }	if the argument is a bounded typevariable or wildcardtype , return its non - variable , non - wildcard upper bound.
public synchronized object remove ( object key ) { removeblanks ( ) ; weakkeyreference keyref = new weakkeyreference ( key ) ; weakreference ref = ( weakreference ) table . remove ( keyref ) ; if ( ref == null ) return null ; return ref . get ( ) ; }	remove the object that the given key maps to.
public boolean removeelement ( node s ) { if ( ! m_mutable ) throw new runtimeexception ( xslmessages . createxpathmessage ( xpatherrorresources . er_nodeset_not_mutable , null ) ) ; if ( null == m_map ) return _bool ; for ( int i = _num ; i < m_firstfree ; i ++ ) { node node = m_map [ i ] ; if ( ( null != node ) && node . equals ( s ) ) { if ( i < m_firstfree - _num ) system . arraycopy ( m_map , i + _num , m_map , i , m_firstfree - i - _num ) ; m_firstfree -- ; m_map [ m_firstfree ] = null ; return _bool ; } } return _bool ; }	removes the first occurrence of the argument from this vector.
@ override public inetaddress addresslocal ( ) { socket s = getsocket ( ) ; if ( s != null ) { return s . getlocaladdress ( ) ; } else { return null ; } }	returns the server inet address that accepted the request .
public boolean startconnection ( ) { state state = _state . get ( ) ; if ( state . isactive ( ) ) { _connectioncount . incrementandget ( ) ; return _bool ; } long now = currenttime . currenttime ( ) ; long lastfailtime = _lastfailtime ; long recovertimeout = _dynamicrecovertimeout . get ( ) ; if ( now < lastfailtime + recovertimeout ) { return _bool ; } int count ; do { count = _connectioncount . get ( ) ; if ( count > _num ) { return _bool ; } } while ( ! _connectioncount . compareandset ( count , count + _num ) ) ; return _bool ; }	start a new connection.
public abstractnaryoperator ( final expr ... args ) { this ( arrays . aslist ( args ) ) ; }	creates a new n - ary operator .
static boolean isregistered ( objectname objectname ) { return mbeanserver != null && mbeanserver . isregistered ( objectname ) ; }	returns true if a mbean with given objectname is registered .
public static int findbestsamplesize ( int actualwidth , int actualheight , int desiredwidth , int desiredheight ) { double wr = ( double ) actualwidth / desiredwidth ; double hr = ( double ) actualheight / desiredheight ; double ratio = math . min ( wr , hr ) ; float n = _num ; while ( ( n * _num ) <= ratio ) { n *= _num ; } return ( int ) n ; }	returns the largest power - of - two divisor for use in downscaling a bitmap that will not result in the scaling past the desired dimensions .
public socketreader ( final socket socket ) throws ioexception { preconditions . checknotnull ( socket , _str ) ; m_inputstream = new bufferedinputstream ( socket . getinputstream ( ) ) ; }	creates a new socket reader object .
private boolean movetofinalscrollerposition ( scroller scroller ) { scroller . forcefinished ( _bool ) ; if ( ishorizontalmode ( ) ) { int amounttoscroll = scroller . getfinalx ( ) - scroller . getcurrx ( ) ; int futurescrolloffset = ( mcurrentscrolloffset + amounttoscroll ) % mselectorelementsize ; int overshootadjustment = minitialscrolloffset - futurescrolloffset ; if ( overshootadjustment != _num ) { if ( math . abs ( overshootadjustment ) > mselectorelementsize / _num ) { if ( overshootadjustment > _num ) { overshootadjustment -= mselectorelementsize ; } else { overshootadjustment += mselectorelementsize ; } } amounttoscroll += overshootadjustment ; scrollby ( amounttoscroll , _num ) ; return _bool ; } } else { int amounttoscroll = scroller . getfinaly ( ) - scroller . getcurry ( ) ; int futurescrolloffset = ( mcurrentscrolloffset + amounttoscroll ) % mselectorelementsize ; int overshootadjustment = minitialscrolloffset - futurescrolloffset ; if ( overshootadjustment != _num ) { if ( math . abs ( overshootadjustment ) > mselectorelementsize / _num ) { if ( overshootadjustment > _num ) { overshootadjustment -= mselectorelementsize ; } else { overshootadjustment += mselectorelementsize ; } } amounttoscroll += overshootadjustment ; scrollby ( _num , amounttoscroll ) ; return _bool ; } } return _bool ; }	move to the final position of a scroller.
public void addlonline ( double minlat , double maxlat , double lon ) { string name = _str + nextshape ; nextshape ++ ; b . append ( _str + name + _str ) ; double lat ; int steps = getstepcount ( minlat , lon , maxlat , lon ) ; for ( lat = minlat ; lat <= maxlat ; lat += ( maxlat - minlat ) / steps ) { b . append ( _str + lat + _str + lon + _str ) ; } b . append ( _str + maxlat + _str + lon + _str ) ; lat -= ( maxlat - minlat ) / _num ; for ( ; lat >= minlat ; lat -= ( maxlat - minlat ) / steps ) { b . append ( _str + lat + _str + lon + _str ) ; } b . append ( _str ) ; b . append ( _str + name + _str ) ; }	draws a line a fixed longitude , spanning the min / max latitude.
@ override public double calculate_k ( int [ ] x_index , double [ ] x_att , int [ ] y_index , double [ ] y_att ) { double result = _num ; double tmp ; int xpos = x_index . length - _num ; int ypos = y_index . length - _num ; int zeros = dim ; while ( ( xpos >= _num ) && ( ypos >= _num ) ) { if ( x_index [ xpos ] == y_index [ ypos ] ) { tmp = x_att [ xpos ] - y_att [ ypos ] ; result += math . exp ( - sigma * tmp * tmp ) ; xpos -- ; ypos -- ; } else if ( x_index [ xpos ] > y_index [ ypos ] ) { tmp = x_att [ xpos ] ; result += math . exp ( - sigma * tmp * tmp ) ; xpos -- ; } else { tmp = y_att [ ypos ] ; result += math . exp ( - sigma * tmp * tmp ) ; ypos -- ; } zeros -- ; } while ( xpos >= _num ) { tmp = x_att [ xpos ] ; result += math . exp ( - sigma * tmp * tmp ) ; xpos -- ; zeros -- ; } while ( ypos >= _num ) { tmp = y_att [ ypos ] ; result += math . exp ( - sigma * tmp * tmp ) ; ypos -- ; zeros -- ; } result += zeros ; return math . pow ( result , degree ) ; }	calculates kernel value of vectors x and y .
private float sweep ( float tan1x , float tan1y , float tan2x , float tan2y ) { final float minorsweep = ( float ) math . todegrees ( _num * ( math . asin ( _num * geometry . distance ( tan1x , tan1y , tan2x , tan2y ) / mscaledtouchslop ) ) ) ; return _num - minorsweep ; }	find the angle in degrees between two tangent points.
suncertpathbuilderresult ( certpath certpath , trustanchor trustanchor , policynode policytree , publickey subjectpublickey , adjacencylist adjlist ) { super ( certpath , trustanchor , policytree , subjectpublickey ) ; this . adjlist = adjlist ; }	creates a suncertpathbuilderresult instance .
public static void attach ( final jframe parent , final idebugger debugger , final cdebugeventnotifier notifier ) { try { notifier . start ( ) ; debugger . connect ( ) ; } catch ( final debugexceptionwrapper exception ) { notifier . stop ( ) ; cutilityfunctions . logexception ( exception ) ; final string innermessage = _str + _str ; final string innerdescription = cutilityfunctions . createdescription ( _str , new string [ ] { _str } , new string [ ] { _str + _str } ) ; navierrordialog . show ( parent , innermessage , innerdescription , exception ) ; } }	attaches to a target process .
public boolean checkaddrpattern ( final string theaddrpattern ) { return theaddrpattern . equals ( addrpattern ( ) ) ; }	check if an address pattern equals a specific address pattern you are looking for.
@ mediumtest public void teststabilityinspace ( ) { long t = system . currenttimemillis ( ) ; velocitytracker vt = velocitytracker . obtain ( ) ; drag ( vt , _num , _num , _num , _num , _num , t , _num ) ; vt . computecurrentvelocity ( _num ) ; float firstx = vt . getxvelocity ( ) ; float firsty = vt . getyvelocity ( ) ; vt . clear ( ) ; drag ( vt , _num , _num , _num , _num , _num , t , _num ) ; vt . computecurrentvelocity ( _num ) ; float secondx = vt . getxvelocity ( ) ; float secondy = vt . getyvelocity ( ) ; assertequalfuzzy ( firstx , secondx , _num ) ; assertequalfuzzy ( firsty , secondy , _num ) ; vt . recycle ( ) ; }	velocity is independent of the position of the events , it only depends on their relative distance .
private view fillfromtop ( int nexttop ) { if ( debug ) log . i ( tag , _str + nexttop + m_first_position + mfirstposition ) ; mfirstposition = math . min ( mfirstposition , mselectedposition ) ; mfirstposition = math . min ( mfirstposition , mitemcount - _num ) ; if ( mfirstposition < _num ) { mfirstposition = _num ; } mfirstposition -= mfirstposition % mnumcolumns ; return filldown ( mfirstposition , nexttop ) ; }	fills the list from top to bottom , starting with mfirstposition.
public static string sitinfo ( enummap < sit , enummap < cit , boolean > > shp ) { stringbuilder result = new stringbuilder ( ) ; for ( sit key : shp . keyset ( ) ) { result . append ( _str + key . tostring ( ) + _str + citinfo ( shp . get ( key ) ) + _str ) ; } return result . tostring ( ) ; }	converts a sitmap into a human readable string.
public static map < string , object > updatebinaryfile ( dispatchcontext dctx , map < string , ? extends object > context ) { map < string , object > result = null ; try { result = updatebinaryfilemethod ( dctx , context ) ; } catch ( genericserviceexception e ) { return serviceutil . returnerror ( e . getmessage ( ) ) ; } return result ; }	a service wrapper for the createbinaryfilemethod method.
public list < byte [ ] > write ( list < internallog > logs ) throws ioexception { final list < put > puts = new arraylist < put > ( logs . size ( ) ) ; final list < byte [ ] > result = new arraylist < byte [ ] > ( logs . size ( ) ) ; for ( internallog log : logs ) { final byte [ ] rowkey = rowkeybuilder . buildrowkey ( log ) ; final put p = new put ( rowkey ) ; populatecolumnvalues ( p , log ) ; puts . add ( p ) ; final list < byte [ ] > indexrowkeys = log . getindexrowkeys ( ) ; if ( indexrowkeys != null ) { writeindexes ( rowkey , indexrowkeys , puts ) ; } result . add ( rowkey ) ; } tbl . put ( puts ) ; return result ; }	todo need think about if multi - put is necessary , by checking if autoflush works.
public int read ( long fileoffset , byte [ ] buffer , int offset , int length ) throws ioexception { log . info ( _str + long . tohexstring ( fileoffset ) + _str + length + _str ) ; return _file . read ( fileoffset , buffer , offset , length ) ; }	reads a block from a given location .
public boolean validatecurrentstep ( int currentstep , int newstep ) { return _bool ; }	the default implementation returns true .
@ nonnull protected static list < raveerror > mustbetrue ( boolean input , @ nonnull validationcontext validationcontext ) { return input ? collections . < raveerror > emptylist ( ) : createnewlist ( new raveerror ( validationcontext , raveerrorstrings . must_be_true_error ) ) ; }	verifies the input to be always true .
@ logmessagedoc ( level = _str , message = _str , explanation = _str + _str , recommendation = logmessagedoc . report_controller_bug ) public void queuehint ( string storename , bytearray key , versioned < byte [ ] > value ) { try { hintkey hk = new hintkey ( storename , key ) ; hintlock . lock ( ) ; try { boolean needed = ! hints . containskey ( hk ) ; needed &= hints . doput ( hk , value ) ; if ( needed ) { hintqueue . add ( hk ) ; hintsavailable . signal ( ) ; } } finally { hintlock . unlock ( ) ; } } catch ( syncexception e ) { logger . error ( _str + storename , e ) ; } }	add a key / value to the hint store for the given store.
public static dbidvar randomsample ( dbids ids , randomfactory random ) { return randomsample ( ids , random . getsinglethreadedrandom ( ) ) ; }	draw a single random sample .
public void testaddlistener ( ) { simplelistener listener1 = createmocksimplelistener ( _num ) ; simplelistener listener2 = createmocksimplelistener ( _num ) ; assertequals ( _num , adaptor . getnumlisteners ( ) ) ; adaptor . addlistener ( listener1 ) ; assertequals ( _num , adaptor . getnumlisteners ( ) ) ; adaptor . addlistener ( listener2 ) ; assertequals ( _num , adaptor . getnumlisteners ( ) ) ; adaptor . addlistener ( listener1 ) ; assertequals ( _num , adaptor . getnumlisteners ( ) ) ; list < simplelistener > listeners = lists . aslist ( adaptor . getlisteners ( ) ) ; assertequals ( _num , listeners . size ( ) ) ; asserttrue ( listeners . contains ( listener1 ) ) ; asserttrue ( listeners . contains ( listener2 ) ) ; easymock . verify ( listener1 , listener2 ) ; }	ensures that when adding a listener that the count of the number of listeners is correctly incremented and that eventfired is called immediately on the listener .
public void onresponse ( discoverynode node ) { boolean found = pendingnodes . remove ( node ) ; assert found : _str + node + _str ; latch . countdown ( ) ; }	called for each response obtained from non master nodes.
@ override public synchronized boolean add ( e object ) { if ( elementcount == elementdata . length ) { growbyone ( ) ; } elementdata [ elementcount ++ ] = object ; modcount ++ ; return _bool ; }	adds the specified object at the end of this vector .
private static long copy ( inputstream from , outputstream to ) throws ioexception { byte [ ] buf = new byte [ settings . buffer_size ] ; long total = _num ; while ( _bool ) { int r = from . read ( buf ) ; if ( r == - _num ) { break ; } to . write ( buf , _num , r ) ; total += r ; } return total ; }	copies all bytes from the input stream to the output stream.
public void addvalue ( string value ) { if ( _stringvalues == null ) { setupstringvalues ( ) ; } if ( ! _stringvalues . contains ( value ) ) { _stringvalues . add ( value ) ; } }	add a string value to the attribute.
public void writerawlittleendian32 ( final int value ) throws ioexception { if ( buffer . remaining ( ) < _num ) { throw new outofspaceexception ( buffer . position ( ) , buffer . limit ( ) ) ; } buffer . putint ( value ) ; }	write a little - endian 32 - bit integer .
private static url [ ] pathtourls ( string path ) throws malformedurlexception { if ( path == null ) { return null ; } synchronized ( pathtourlscache ) { object [ ] v = ( object [ ] ) pathtourlscache . get ( path ) ; if ( v != null ) { return ( ( url [ ] ) v [ _num ] ) ; } } stringtokenizer st = new stringtokenizer ( path ) ; url [ ] urls = new url [ st . counttokens ( ) ] ; for ( int i = _num ; st . hasmoretokens ( ) ; i ++ ) { urls [ i ] = new url ( st . nexttoken ( ) ) ; } synchronized ( pathtourlscache ) { pathtourlscache . put ( path , new object [ ] { urls , new softreference ( path ) } ) ; } return urls ; }	convert a string containing a space - separated list of urls into a corresponding array of url objects , throwing a malformedurlexception if any of the urls are invalid.
public static int hash4 ( int hash , object x , object y , object z , object w ) { return _num | ( hash + _num * system . identityhashcode ( x ) + _num * system . identityhashcode ( y ) + _num * system . identityhashcode ( z ) + _num * system . identityhashcode ( w ) ) ; }	utility method to combine a base hash with the identity hash of one or more objects .
public long skip ( long n ) throws ioexception { if ( n < _num ) { throw new illegalargumentexception ( _str ) ; } ensureopen ( ) ; int max = ( int ) math . min ( n , integer . max_value ) ; int total = _num ; while ( total < max ) { int len = max - total ; if ( len > b . length ) { len = b . length ; } len = read ( b , _num , len ) ; if ( len == - _num ) { reacheof = _bool ; break ; } total += len ; } return total ; }	skips specified number of bytes of uncompressed data .
private v doput ( k kkey , v value , boolean onlyifabsent ) { comparable < ? super k > key = comparable ( kkey ) ; for ( ; ; ) { node < k , v > b = findpredecessor ( key ) ; node < k , v > n = b . next ; for ( ; ; ) { if ( n != null ) { node < k , v > f = n . next ; if ( n != b . next ) break ; object v = n . value ; if ( v == null ) { n . helpdelete ( b , f ) ; break ; } if ( v == n || b . value == null ) break ; int c = key . compareto ( n . key ) ; if ( c > _num ) { b = n ; n = f ; continue ; } if ( c == _num ) { if ( onlyifabsent || n . casvalue ( v , value ) ) return ( v ) v ; else break ; } } node < k , v > z = new node < k , v > ( kkey , value , n ) ; if ( ! b . casnext ( n , z ) ) break ; int level = randomlevel ( ) ; if ( level > _num ) insertindex ( z , level ) ; return null ; } } }	main insertion method . adds element if not present , or replaces value if present and onlyifabsent is false .
public void addfilloutsideline ( filloutsideline fill ) { mfillbelowline . add ( fill ) ; }	sets if the line chart should be filled outside its line.
public void add ( final positionchangelistener listener ) { listeners . add ( listener ) ; }	add a position change listener .
public void choose ( boolean enable , string what ) ;	choose a detector , plugin , etc .
public void testduplicateentries ( ) throws exception { string name1 = _str ; string name2 = _str ; bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; zipoutputstream out = new zipoutputstream ( baos ) ; out . putnextentry ( new zipentry ( name2 ) ) ; out . closeentry ( ) ; out . putnextentry ( new zipentry ( name1 ) ) ; out . closeentry ( ) ; out . close ( ) ; byte [ ] buffer = baos . tobytearray ( ) ; replacebytes ( buffer , name2 . getbytes ( ) , name1 . getbytes ( ) ) ; file badzip = createtemporaryzipfile ( ) ; writebytes ( badzip , buffer ) ; try { zipfile bad = new zipfile ( badzip ) ; fail ( ) ; } catch ( zipexception expected ) { } }	make sure we don ' t fail silently for duplicate entries . b / 8219321.
private void checksize ( final int i ) { if ( i >= max_size ) { final int old_size = max_size ; max_size += increment_size ; if ( max_size <= i ) { max_size = i + increment_size + _num ; } final int [ ] temp = items ; items = new int [ max_size ] ; system . arraycopy ( temp , _num , items , _num , old_size ) ; increment_size = incrementsize ( increment_size ) ; } }	check the size of the array and increase if needed.
public componentprintservice ( component c , pageformat format ) { setpageformat ( format ) ; setprintable ( this ) ; setcomponent ( c ) ; rectangle componentbounds = c . getbounds ( null ) ; setsize ( componentbounds . width , componentbounds . height ) ; setscale ( _num , _num ) ; }	create a pageable that can print a swing jcomponent over multiple pages .
public void flush ( ) throws ioexception { if ( writer != null ) { writer . flush ( ) ; } outstr . flush ( ) ; }	flushes all the streams for this response .
@ suppresswarnings ( _str ) protected synchronized v removeinternal ( object key , boolean countremove ) { if ( key == null ) { if ( debug . verboseon ( ) ) debug . logverbose ( _str + this . name , module ) ; } object nulledkey = fromkey ( key ) ; cacheline < v > oldcacheline ; v oldvalue ; if ( filetable != null ) { try { synchronized ( this ) { try { oldvalue = filetable . get ( nulledkey ) ; } catch ( ioexception e ) { oldvalue = null ; throw e ; } filetable . remove ( nulledkey ) ; jdbmmgr . commit ( ) ; } } catch ( ioexception e ) { oldvalue = null ; debug . logerror ( e , module ) ; } oldcacheline = memorytable . remove ( nulledkey ) ; } else { oldcacheline = memorytable . remove ( nulledkey ) ; oldvalue = oldcacheline != null ? oldcacheline . getvalue ( ) : null ; } if ( oldcacheline != null ) { cancel ( oldcacheline ) ; } if ( oldvalue != null ) { noteremoval ( ( k ) key , oldvalue ) ; if ( countremove ) removehitcount . incrementandget ( ) ; return oldvalue ; } else { if ( countremove ) removemisscount . incrementandget ( ) ; return null ; } }	this is used for internal remove calls because we only want to count external calls.
public void remove ( double value ) { if ( double . isnan ( value ) ) { return ; } int index = findinsertindex ( value ) ; if ( index == - _num ) { throw new illegalstateexception ( _str ) ; } double valueatindex = values . get ( index ) ; if ( ( valueatindex != null ) && ( ! valueatindex . equals ( value ) ) ) { throw new illegalstateexception ( _str ) ; } values . remove ( index ) ; }	remove a value from the collection .
public void childrenremoved ( beancontextmembershipevent bcme ) { iterator < ? > it = bcme . iterator ( ) ; while ( it . hasnext ( ) ) { findandundo ( it . next ( ) ) ; } }	beancontextmembershiplistener method . called when a new object is removed from the beancontext of this object . for the layer , this method doesn ' t do anything . if your layer does something with the childrenadded method , or findandinit , you should take steps in this method to unhook the layer from the object used in those methods .
void lightweightpaint ( graphics g ) { super . lightweightpaint ( g ) ; paintheavyweightcomponents ( g ) ; }	simulates the peer callbacks into java.
private final void removechannel ( string channel ) { channel = channel . tolowercase ( ) ; synchronized ( _channels ) { _channels . remove ( channel ) ; } }	removes an entire channel from our memory of users .
public void addchangelistener ( changelistener cl ) { if ( ! listeners . contains ( cl ) ) listeners . add ( cl ) ; }	registers a listener for changeevents .
public static void expandnumber ( string numberstring , wordrelation wordrelation , item tokenitem ) { int numdigits = numberstring . length ( ) ; if ( numdigits == _num ) { } else if ( numdigits == _num ) { expanddigits ( numberstring , wordrelation , tokenitem ) ; } else if ( numdigits == _num ) { expand2digitnumber ( numberstring , wordrelation , tokenitem ) ; } else if ( numdigits == _num ) { expand3digitnumber ( numberstring , wordrelation , tokenitem ) ; } else if ( numdigits < _num ) { expandbelow7digitnumber ( numberstring , wordrelation , tokenitem ) ; } else if ( numdigits < _num ) { expandbelow10digitnumber ( numberstring , wordrelation , tokenitem ) ; } else if ( numdigits < _num ) { expandbelow13digitnumber ( numberstring , wordrelation , tokenitem ) ; } else { expanddigits ( numberstring , wordrelation , tokenitem ) ; } }	expands a digit string into a list of english words of those digits . for example , " 1234 " expands to " one two three four ".
private int measureshort ( int measurespec ) { int result = _num ; int specmode = measurespec . getmode ( measurespec ) ; int specsize = measurespec . getsize ( measurespec ) ; if ( specmode == measurespec . exactly ) { result = specsize ; } else { result = ( int ) ( _num * mradius + getpaddingtop ( ) + getpaddingbottom ( ) + _num ) ; if ( specmode == measurespec . at_most ) { result = math . min ( result , specsize ) ; } } return result ; }	determines the height of this view.
protected boolean cantriggerwalking ( ) { return _bool ; }	returns if this entity triggers block.
public static string encryptecb ( final byte [ ] concatenatedhashvalue , final long turnovercounter , final secretkey symmetrickey , int turnovercounterlengthinbytes ) throws nosuchalgorithmexception , nosuchproviderexception , nosuchpaddingexception , invalidkeyexception , illegalblocksizeexception , badpaddingexception { final bytebuffer bytebufferiv = bytebuffer . allocate ( _num ) ; bytebufferiv . put ( concatenatedhashvalue ) ; final byte [ ] iv = bytebufferiv . array ( ) ; final bytebuffer bytebufferdata = bytebuffer . allocate ( _num ) ; bytebufferdata . putlong ( turnovercounter ) ; final byte [ ] data = bytebufferdata . array ( ) ; byte [ ] turnovercounterbyterep = get2complementrepforlong ( turnovercounter , turnovercounterlengthinbytes ) ; system . arraycopy ( turnovercounterbyterep , _num , data , _num , turnovercounterbyterep . length ) ; final cipher cipher = cipher . getinstance ( _str , _str ) ; cipher . init ( cipher . encrypt_mode , symmetrickey ) ; final byte [ ] intermediateresult = cipher . dofinal ( iv ) ; final byte [ ] result = new byte [ data . length ] ; for ( int i = _num ; i < data . length ; i ++ ) { result [ i ] = ( byte ) ( ( data [ i ] ) ^ ( intermediateresult [ i ] ) ) ; } final byte [ ] encryptedturnovervalue = new byte [ turnovercounterlengthinbytes ] ; system . arraycopy ( result , _num , encryptedturnovervalue , _num , turnovercounterlengthinbytes ) ; return cashboxutils . base64encode ( encryptedturnovervalue , _bool ) ; }	method for aes encryption in ecb mode.
private static boolean isfrostwireold ( string messageversion ) { if ( messageversion == null ) return _bool ; string currentversion = frostwireutils . getfrostwireversion ( ) ; if ( currentversion . equals ( messageversion ) ) { return _bool ; } try { string [ ] fwversionparts = currentversion . split ( _str ) ; int fw_major = integer . parseint ( fwversionparts [ _num ] ) ; int fw_release = integer . parseint ( fwversionparts [ _num ] ) ; int fw_service = integer . parseint ( fwversionparts [ _num ] ) ; string [ ] msgversionparts = messageversion . split ( _str ) ; int msg_major = integer . parseint ( msgversionparts [ _num ] ) ; int msg_release = integer . parseint ( msgversionparts [ _num ] ) ; int msg_service = integer . parseint ( msgversionparts [ _num ] ) ; if ( fw_major < msg_major ) { return _bool ; } if ( fw_major == msg_major && fw_release < msg_release ) { return _bool ; } if ( fw_major == msg_major && fw_release == msg_release && fw_service < msg_service ) { return _bool ; } } catch ( exception e ) { return _bool ; } return _bool ; }	given a version string , it compares against the current frostwire version.
public synchronized void drawmap ( ) { lastdrawmapreq = system . currenttimemillis ( ) ; swingutilities . invokelater ( drawmapable ) ; }	this replaces the original drawmap to speed up updates this can be called any time necessary.
public void selecttable2column ( index column ) { table2columns . add ( column ) ; }	select table2 column name .
public list < string > extracturls ( final string text ) { if ( text == null || text . length ( ) == _num ) return collections . emptylist ( ) ; final arraylist < string > urls = new arraylist < string > ( ) ; for ( final entity entity : extracturlswithindices ( text ) ) { urls . add ( entity . value ) ; } return urls ; }	extract url references from tweet text .
public void findandundo ( iterator it ) { while ( it . hasnext ( ) ) { findandundo ( it . next ( ) ) ; } }	subclasses should no longer implement this method.
public static int [ ] scaledowninside ( int inwidth , int inheight , int maxwidth , int maxheight ) { int scaledwidth ; int scaledheight ; if ( inwidth <= maxwidth && inheight <= maxheight ) { scaledwidth = inwidth ; scaledheight = inheight ; } else { double widthratio = ( double ) inwidth / ( double ) maxwidth ; double heightratio = ( double ) inheight / ( double ) maxheight ; if ( widthratio > heightratio ) { scaledwidth = maxwidth ; scaledheight = ( int ) math . round ( ( double ) inheight / widthratio ) ; } else { scaledheight = maxheight ; scaledwidth = ( int ) math . round ( ( double ) inwidth / heightratio ) ; } } return new int [ ] { scaledwidth , scaledheight } ; }	returns int [ ] { scaledwidth , scaledheight } for dimensions that fit within the given maxwidth , maxheight at the given inwidth , inheight aspect ratio.
public void rm ( string fileordir ) { stringbuilder buf = new stringbuilder ( ) ; string command = string . format ( imageserverdialogproperties . getstring ( _str ) , fileordir ) ; sendwaitfor ( command , defaulttimeout , prompts , buf ) ; log . debug ( buf . tostring ( ) ) ; }	remove file or directory using ' rm - rf ' command.
public void putmap ( map < string , list < string > > m ) { for ( string key : m . keyset ( ) ) { sortedset < string > vals = get ( key ) ; if ( vals == null ) { vals = new treeset < string > ( ) ; put ( key , vals ) ; } vals . addall ( m . get ( key ) ) ; } }	convenience method to merge a map < string , list < string > > .
public void addassetlistener ( @ notnull actionlistener listener ) { myassetlisteners . add ( listener ) ; }	add a listener which will be triggered whenever the asset represented by this panel is modified in any way .
public undoableedit insertstring ( int where , string str ) throws badlocationexception { if ( where > length ( ) || where < _num ) { throw new badlocationexception ( _str , length ( ) ) ; } char [ ] chars = str . tochararray ( ) ; replace ( where , _num , chars , chars . length ) ; return new insertundo ( where , str . length ( ) ) ; }	inserts a string into the content .
public static boolean isyoutubeurl ( string url ) { if ( textutils . isempty ( url ) ) { return _bool ; } uri uri = uri . parse ( url ) ; string authority = uri . getauthority ( ) ; if ( ! textutils . isempty ( authority ) && authority . contains ( _str ) ) { return _bool ; } else { return _bool ; } }	checks to see if the your contains the authority " youtube . com ".
public list < namespacevo > findnamespaces ( string appid , env env , string clustername ) { list < namespacedto > namespaces = namespaceapi . findnamespacebycluster ( appid , env , clustername ) ; if ( namespaces == null || namespaces . size ( ) == _num ) { throw new badrequestexception ( _str ) ; } list < namespacevo > namespacevos = new linkedlist < > ( ) ; for ( namespacedto namespace : namespaces ) { namespacevo namespacevo = null ; try { namespacevo = parsenamespace ( appid , env , clustername , namespace ) ; namespacevos . add ( namespacevo ) ; } catch ( exception e ) { logger . error ( _str , appid , env , clustername , namespace . getnamespacename ( ) , e ) ; throw e ; } } return namespacevos ; }	load cluster all namespace info with items.
public static void opensharedialog ( context context , string title , @ suppresswarnings ( _str ) string uri , string sharetext , string sharesubject ) { intent share = new intent ( intent . action_send ) ; share . settype ( _str ) ; share . putextra ( intent . extra_text , sharetext ) ; share . putextra ( intent . extra_subject , sharesubject ) ; if ( ! textutils . isempty ( uri ) ) { share . settype ( _str ) ; share . putextra ( intent . extra_stream , uri . parse ( uri ) ) ; } context . startactivity ( intent . createchooser ( share , title ) ) ; }	opens android share dialog pass one of uri or sharetext.
public void addmatching ( final conversationstates state , final string triggerstring , final expressionmatcher matcher , final chatcondition condition , boolean secondary , final conversationstates nextstate , final string reply , final chataction action ) { collection < expression > triggerexpressions = createuniquetriggerexpressions ( state , arrays . aslist ( triggerstring ) , matcher , condition , reply , action ) ; add ( triggerexpressions , state , condition , secondary , nextstate , reply , action ) ; }	adds a new transition with explicit expressionmatcher to fsm .
boolean dropitems ( final player player , int itemcount ) { boolean result = _bool ; final itemcollection itemstodo = new itemcollection ( ) ; itemstodo . addfromqueststatestring ( player . getquest ( questslot ) ) ; if ( player . drop ( itemname , itemcount ) ) { if ( itemstodo . removeitem ( itemname , itemcount ) ) { result = _bool ; } } else { final list < item > items = player . getallequipped ( itemname ) ; if ( items != null ) { for ( final item item : items ) { final int quantity = item . getquantity ( ) ; final int n = math . min ( itemcount , quantity ) ; if ( player . drop ( itemname , n ) ) { itemcount -= n ; if ( itemstodo . removeitem ( itemname , n ) ) { result = _bool ; } } if ( itemcount == _num ) { result = _bool ; break ; } } } } if ( result ) { player . setquest ( questslot , itemstodo . tostringforqueststate ( ) ) ; } return result ; }	drop specified amount of given item.
public void encodeoctetstring ( byte tb [ ] , int tag , int tboffset , int length ) throws encodeexception { encodebyte ( tag ) ; encodelength ( length ) ; if ( length > _num ) { ensurefreebytes ( length ) ; system . arraycopy ( tb , tboffset , buf , offset , length ) ; offset += length ; } }	encodes a portion of an octet string and a tag .
private void swapblocks ( int from , int second , int to ) { int len1 = second - from , len2 = to - second + _num ; if ( len1 == _num || len2 == _num ) { return ; } if ( len1 < temp . length ) { system . arraycopy ( data , from , temp , _num , len1 ) ; system . arraycopy ( data , second , data , from , len2 ) ; system . arraycopy ( temp , _num , data , from + len2 , len1 ) ; return ; } else if ( len2 < temp . length ) { system . arraycopy ( data , second , temp , _num , len2 ) ; system . arraycopy ( data , from , data , from + len2 , len1 ) ; system . arraycopy ( temp , _num , data , from , len2 ) ; return ; } reverseblock ( from , second - _num ) ; reverseblock ( second , to ) ; reverseblock ( from , to ) ; }	swap the elements of two blocks in the data array.
private static long totalsize ( map < string , long > relpathtosize ) { long total = _num ; for ( long l : relpathtosize . values ( ) ) { total += l ; } return total ; }	get the total size of the paths .
public static boolean isvalid ( timestamp validfrom , timestamp validto , timestamp testdate ) { if ( testdate == null ) return _bool ; if ( validfrom == null && validto == null ) return _bool ; if ( validfrom != null && validfrom . after ( testdate ) ) return _bool ; if ( validto != null && validto . before ( testdate ) ) return _bool ; return _bool ; }	is it valid on test date.
public patterntokenizer ( attributefactory factory , pattern pattern , int group ) { super ( factory ) ; this . group = group ; matcher = pattern . matcher ( _str ) ; if ( group >= _num && group > matcher . groupcount ( ) ) { throw new illegalargumentexception ( _str + matcher . groupcount ( ) + _str ) ; } }	creates a new patterntokenizer returning tokens from group ( - 1 for split functionality ).
@ override public double totalestimatedquantityforpreviousres ( final long woactivityid , long estimateid , final long activityid , final workorder workorder ) { if ( estimateid == null ) estimateid = - _num ; object [ ] params = null ; double estquantity = null ; params = new object [ ] { estimateid , workorder , workorder , woactivityid , activityid } ; estquantity = ( double ) genericservice . findbynamedquery ( _str , params ) ; double estquantityre = null ; params = new object [ ] { estimateid , workorder , workorder , activityid } ; estquantityre = ( double ) genericservice . findbynamedquery ( _str , params ) ; if ( estquantity != null && estquantityre != null ) estquantity = estquantity + estquantityre ; if ( estquantity == null && estquantityre != null ) estquantity = estquantityre ; if ( estquantity == null ) return _num ; else return estquantity . doublevalue ( ) ; }	similar to totalestimatedquantityforre but will consider only previous res and not all res.
public boolean eval ( ) { if ( sourcefilesets . size ( ) == _num && sourceresources . size ( ) == _num && sourcefile == null ) { throw new buildexception ( _str ) ; } if ( ( sourcefilesets . size ( ) > _num || sourceresources . size ( ) > _num ) && sourcefile != null ) { throw new buildexception ( _str ) ; } if ( urlbase == null ) { throw new buildexception ( _str ) ; } if ( sourcefile != null && ! sourcefile . exists ( ) ) { throw new buildexception ( sourcefile . getabsolutepath ( ) + _str ) ; } boolean uptodate = _bool ; if ( sourcefile != null ) { resource fileresource = new fileresource ( sourcefile ) ; uptodate = isuptodate ( fileresource ) ; } if ( uptodate ) { enumeration e = sourcefilesets . elements ( ) ; while ( uptodate && e . hasmoreelements ( ) ) { fileset fs = ( fileset ) e . nextelement ( ) ; iterator it = fs . iterator ( ) ; while ( uptodate && it . hasnext ( ) ) { resource r = ( resource ) it . next ( ) ; uptodate = isuptodate ( r ) ; } } } if ( uptodate ) { resource [ ] r = sourceresources . listresources ( ) ; for ( int i = _num ; uptodate && i < r . length ; i ++ ) { uptodate = isuptodate ( r [ i ] ) ; } } return uptodate ; }	evaluate ( all ) target and source file ( s ) to see if the target ( s ) is / are up - to - date .
private int handleaggregationpacket ( buffer input , buffer output ) { byte [ ] bufferdata = ( byte [ ] ) input . getdata ( ) ; if ( aggregationpositon + _num >= bufferdata . length ) { aggregationpositon = _num ; output . setdiscard ( _bool ) ; return buffer_processed_ok ; } int nalu_size = ( ( ( bufferdata [ aggregationpositon ] & _num ) << _num ) | ( bufferdata [ aggregationpositon + _num ] & _num ) ) ; aggregationpositon += _num ; if ( aggregationpositon + nalu_size > bufferdata . length ) { aggregationpositon = _num ; return buffer_processed_failed ; } extractnalunitheader ( aggregationpositon , input ) ; if ( mnalunitheader . issinglenalunitpacket ( ) ) { byte [ ] data = new byte [ nalu_size ] ; system . arraycopy ( bufferdata , aggregationpositon , data , _num , nalu_size ) ; aggregationpositon += nalu_size ; output . setdata ( data ) ; output . setlength ( data . length ) ; output . setoffset ( _num ) ; output . settimestamp ( input . gettimestamp ( ) ) ; output . setsequencenumber ( input . getsequencenumber ( ) ) ; output . setvideoorientation ( input . getvideoorientation ( ) ) ; output . setformat ( input . getformat ( ) ) ; output . setflags ( input . getflags ( ) ) ; return input_buffer_not_consumed ; } aggregationpositon = _num ; return buffer_processed_failed ; }	handle aggregation nal unit packet.
protected int decodelineprefix ( pushbackinputstream instream , outputstream outstream ) throws ioexception { int i ; int nlen , nseq ; byte xtmp [ ] ; int c ; crc . value = _num ; while ( _bool ) { c = instream . read ( tmp , _num , _num ) ; if ( c == - _num ) { throw new cestreamexhausted ( ) ; } if ( tmp [ _num ] == _str ) { break ; } } lineandseq . reset ( ) ; decodeatom ( instream , lineandseq , _num ) ; xtmp = lineandseq . tobytearray ( ) ; nlen = xtmp [ _num ] & _num ; nseq = xtmp [ _num ] & _num ; if ( nseq != sequence ) { throw new ceformatexception ( _str ) ; } sequence = ( sequence + _num ) & _num ; return ( nlen ) ; }	decodelineprefix reads the sequence number and the number of encoded bytes from the line.
protected void updatecachedawtsizes ( final dimension min , final dimension pref , final dimension max ) { assert eventqueue . isdispatchthread ( ) ; if ( verbosesizelayout ) { system . err . println ( _str + min + _str + pref + _str + max ) ; } lastvalidatedawttime = ++ currentawttime ; boolean mustnotify ; synchronized ( this ) { mustnotify = cachedsizesinitialized == _num ; if ( ! mustnotify ) { mustnotify = ! ( min . equals ( cachedminsize ) && pref . equals ( cachedprefsize ) && max . equals ( cachedmaxsize ) ) ; } if ( cachedsizesinitialized == _num ) { cachedsizesinitialized = _num ; } cachedminsize = min ; cachedprefsize = pref ; cachedmaxsize = max ; if ( initial_client_area_workaround && initialclientarea != null ) { initialclientarea . width = cachedprefsize . width ; initialclientarea . height = cachedprefsize . height ; } } if ( mustnotify ) { final int onbehalfawttime = lastvalidatedawttime ; threadinghandler . getinstance ( ) . asyncexec ( display , null ) ; } }	given the minimum , preferred , and maximum sizes of the swing component , this method stores them in the cache and updates this control accordingly .
public boolean isdecimalpoint ( ) { if ( m_decimalpoint == null ) { decimalformatsymbols dfs = new decimalformatsymbols ( m_locale ) ; m_decimalpoint = new boolean ( dfs . getdecimalseparator ( ) == _str ) ; } return m_decimalpoint . booleanvalue ( ) ; }	returns true if decimal point ( not comma ).
public void removelayer ( layer layer ) { if ( layer != null && layer . isremovable ( ) ) { list < layer > currentlayers = getlayerlist ( ) ; currentlayers . remove ( layer ) ; setlayerlist ( currentlayers ) ; } else { if ( layer != null ) { logger . warning ( _str + layer . getname ( ) + _str ) ; throw new com . bbn . openmap . util . handleerror ( _str + layer . getname ( ) + _str ) ; } } }	remove a layer from the list of potentials .
public option [ ] findalloptiontypes ( final class optionclass ) { check . notnull ( optionclass , _str ) ; return findalloptiontypes ( new class [ ] { optionclass } ) ; }	finds all options that the user set for this command that match the given class .
public int via_padstack_count ( ) { return via_padstacks . size ( ) ; }	the count of padstacks from this . padstacks , which can be used in routing.
public static boolean isearliertransaction ( mcostdetail cd , int c_acctschema_id , int m_costtype_id , int m_costelement_id , string costinglevel ) { mtransaction trx = new mtransaction ( cd . getctx ( ) , cd . getm_transaction_id ( ) , cd . get_trxname ( ) ) ; mcostdetail last_cd = getlasttransaction ( trx , c_acctschema_id , m_costtype_id , m_costelement_id , costinglevel ) ; if ( last_cd == null ) return _bool ; if ( cd . getseqno ( ) <= last_cd . getseqno ( ) && cd . getm_transaction_id ( ) != last_cd . getm_transaction_id ( ) ) { return _bool ; } return _bool ; }	detect if cost detail delayed entry.
public void addoutofcontextmessage ( consensusmessage m ) { outofcontextlock . lock ( ) ; if ( m . gettype ( ) == messagefactory . propose ) { logger . println ( _str + m ) ; outofcontextproposes . put ( m . getnumber ( ) , m ) ; } else { list < consensusmessage > messages = outofcontext . get ( m . getnumber ( ) ) ; if ( messages == null ) { messages = new linkedlist < consensusmessage > ( ) ; outofcontext . put ( m . getnumber ( ) , messages ) ; } logger . println ( _str + m ) ; messages . add ( m ) ; } outofcontextlock . unlock ( ) ; }	stores a message established as being out of context ( a message that doesn ' t belong to current executing consensus ) .
private long calculatecapacity ( long minimumcapacity ) { long newcapacity = math . min ( math . max ( capacity , _num ) , minimumcapacity ) ; while ( newcapacity < math . min ( minimumcapacity , maxcapacity ) ) { newcapacity <<= _num ; } return math . min ( newcapacity , maxcapacity ) ; }	calculates the next capacity that meets the given minimum capacity .
protected object createresource ( ) throws resourceunavailableexception { object resource = create ( ) ; freed . add ( resource ) ; numcreated ++ ; return ( resource ) ; }	creates a new resource and performs any initilization required to manage the resource.
public void upgrade ( ) throws exception { if ( ! checkupgradepreconditions ( ) ) { return ; } backupmanager . createopendjbackup ( ) ; try ( bufferedwriter out = new bufferedwriter ( new filewriter ( upgrademarker ) ) ) { out . write ( currentversion . tostring ( ) ) ; out . write ( _str ) ; } if ( currentversion . isolderthan ( dj_245_version ) ) { backupfile ( _str ) ; backupfile ( _str ) ; backupfile ( _str ) ; unpackzipfile ( _bool ) ; callolddjupgrade ( ) ; } else { unpackzipfile ( _bool ) ; if ( currentversion . equals ( dj_246_version ) ) { try { file badschema = new file ( installroot + file . separator + _str + file . separator + _str + file . separator + _str ) ; delete ( badschema ) ; } catch ( runtimeexception e ) { } file goodschema = new file ( servletctx . getrealpath ( file . separator + _str + file . separator + _str + file . separator + _str + file . separator + _str + file . separator + _str ) ) ; file moveto = new file ( installroot + file . separator + _str + file . separator + _str + file . separator + _str ) ; copy ( goodschema . topath ( ) , moveto . topath ( ) ) ; } int ret = calldjupgrademechanism ( ) ; if ( ret == _num ) { message ( _str ) ; delete ( upgrademarker ) ; final string lockfile = lockfilemanager . getserverlockfilename ( ) ; lockfilemanager . releaselock ( lockfile , new stringbuilder ( ) ) ; } else { throw new upgradeexception ( _str + ret ) ; } } }	upgrades the embedded ds instance to opendj 2.
public static final optional < file > findsteamvrmanifest ( final arraylist < file > indexedsteamfolders ) { for ( final file f : indexedsteamfolders ) { final file currentfile = new file ( f . getabsolutepath ( ) + steamconstants . steam_vr_apps_manifest_file_location ) ; if ( currentfile . exists ( ) ) return optional . ofnullable ( currentfile ) ; } return optional . empty ( ) ; }	attempts to find the steamvr manifest file within the given locations.
private static boolean isclose ( float value , float targetvalue ) { return math . abs ( value - targetvalue ) < _num ; }	returns true if value is close to target value .
public int size ( ) { return _mytcpclients . size ( ) ; }	get the number of connected clients .
public static mmovementcartbean addtomovementcart ( properties ctx , stockmovementbean bean , mmovementcartbean cartbean , boolean issales , boolean ifadd ) throws operationexception , productnotfoundexception , productnotonpricelistexception { arraylist < itembean > olditems ; if ( cartbean == null ) { cartbean = new mmovementcartbean ( ) ; olditems = new arraylist < itembean > ( ) ; } else { olditems = cartbean . getitems ( ) ; } arraylist < itembean > olditemsclone = ( arraylist ) olditems . clone ( ) ; arraylist itemstobeadded = getmmovementitems ( ctx , bean ) ; olditems = addtommovementlist ( ctx , olditemsclone , itemstobeadded , ifadd ) ; integer pricelistid = posterminalmanager . getpricelistid ( ctx , issales ) ; olditems = setmmovementitemcosts ( ctx , pricelistid , olditems , issales ) ; cartbean . setitems ( olditems ) ; cartbean . setpricelistid ( pricelistid ) ; return cartbean ; }	add to movement cart ( stock transfer cart ).
private static list < field > filterfieldlist ( list < field > fields , class < ? > filterclass ) { list < field > filteredfields = new linkedlist < > ( ) ; for ( field f : fields ) { if ( ( filterclass == null ) || filterclass . isassignablefrom ( f . gettype ( ) ) ) { filteredfields . add ( f ) ; } } return filteredfields ; }	takes a list of fields and returns only fields which are subclasses of the filterclass.
public static void renderpairwiseorthogonal ( complexvector vec1 , complexvector vec2 ) { incompatiblevectorsexception . checkvectorscompatible ( vec1 , vec2 ) ; if ( vec1 . getopmode ( ) != complexvector . mode . cartesian ) vec1 . tocartesian ( ) ; if ( vec2 . getopmode ( ) != complexvector . mode . cartesian ) vec2 . tocartesian ( ) ; float [ ] coordinates1 = vec1 . getcoordinates ( ) ; float [ ] coordinates2 = vec2 . getcoordinates ( ) ; for ( int i = _num ; i < vec1 . getdimension ( ) * _num ; i += _num ) { double resultthispair = coordinates1 [ i ] * coordinates2 [ i ] ; resultthispair += coordinates1 [ i + _num ] * coordinates2 [ i + _num ] ; double norm1 = coordinates1 [ i ] * coordinates1 [ i ] ; norm1 += coordinates1 [ i + _num ] * coordinates1 [ i + _num ] ; double norm2 = coordinates2 [ i ] * coordinates2 [ i ] ; norm2 += coordinates2 [ i + _num ] * coordinates2 [ i + _num ] ; norm1 = math . sqrt ( norm1 ) ; norm2 = math . sqrt ( norm2 ) ; double cosine = _num ; if ( norm1 > _num && norm2 > _num ) cosine = resultthispair / ( norm1 * norm2 ) ; coordinates1 [ i ] = ( float ) ( coordinates1 [ i ] - cosine * coordinates2 [ i ] ) ; coordinates1 [ i + _num ] = ( float ) ( coordinates1 [ i + _num ] - cosine * coordinates2 [ i + _num ] ) ; } }	experimental : renders each circular component of vec1 orthogonal to the corresponding component of vec2 both vectors are in put into cartesian mode .
protected simplejavafileobject ( uri uri , kind kind ) { uri . getclass ( ) ; kind . getclass ( ) ; if ( uri . getpath ( ) == null ) throw new illegalargumentexception ( _str + uri ) ; this . uri = uri ; this . kind = kind ; }	construct a simplejavafileobject of the given kind and with the given uri .
public int increment ( int val ) { if ( val < _num ) { return decrement ( - val ) ; } lock . lock ( ) ; int newvalue = ( value += val ) ; lock . unlock ( ) ; return newvalue ; }	increments the counter by val .
protected void releaseinternal ( ) { contexttranslator . pts_1cfa_map = null ; contexttranslator . objs_1cfa_map = null ; }	reset the pta and get it ready for another run .
public static void addconstraintviolationsrdf ( list < constraintviolation > cvs , model result , boolean createsource ) { for ( constraintviolation cv : cvs ) { resource r = result . createresource ( spin . constraintviolation ) ; string message = cv . getmessage ( ) ; if ( message != null && message . length ( ) > _num ) { r . addproperty ( rdfs . label , message ) ; } if ( cv . getroot ( ) != null ) { r . addproperty ( spin . violationroot , cv . getroot ( ) ) ; } r . addproperty ( spin . violationlevel , cv . getlevel ( ) ) ; for ( simplepropertypath path : cv . getpaths ( ) ) { if ( path instanceof objectpropertypath ) { r . addproperty ( spin . violationpath , path . getpredicate ( ) ) ; } else { resource p = result . createresource ( sp . reversepath ) ; p . addproperty ( sp . path , path . getpredicate ( ) ) ; r . addproperty ( spin . violationpath , p ) ; } } if ( createsource && cv . getsource ( ) != null ) { r . addproperty ( spin . violationsource , cv . getsource ( ) ) ; } if ( cv . getvalue ( ) != null ) { r . addproperty ( spin . violationvalue , cv . getvalue ( ) ) ; } } }	creates an rdf representation ( instances of spin : constraintviolation ) from a collection of constraintviolation java objects .
public page copy ( long version ) { page newpage = create ( map , version , keys , values , children , totalcount , getmemory ( ) ) ; removepage ( ) ; newpage . cachedcompare = cachedcompare ; return newpage ; }	create a copy of this page .
public boolean startbusytone ( final string busytoneuritype ) { if ( busytoneuritype . isempty ( ) ) { return _bool ; } try { log . d ( tag , _str + busytoneuritype ) ; if ( mbusytone != null ) { if ( mbusytone . isplaying ( ) ) { log . d ( tag , _str ) ; return _bool ; } else { stopbusytone ( ) ; } } uri busytoneuri ; map data = new hashmap < string , object > ( ) ; data . put ( _str , _str ) ; if ( busytoneuritype . equals ( _str ) ) { mbusytone = new mytonegenerator ( mytonegenerator . busy ) ; mbusytone . startplay ( data ) ; return _bool ; } else { busytoneuri = getbusytoneuri ( busytoneuritype ) ; if ( busytoneuri == null ) { log . d ( tag , _str ) ; return _bool ; } } mbusytone = new mymediaplayer ( ) ; data . put ( _str , busytoneuri ) ; data . put ( _str , _bool ) ; data . put ( _str , audiomanager . stream_voice_call ) ; setmediaplayerevents ( ( mediaplayer ) mbusytone , _str ) ; mbusytone . startplay ( data ) ; return _bool ; } catch ( exception e ) { log . d ( tag , _str ) ; log . d ( tag , e . getmessage ( ) ) ; return _bool ; } }	this is part of start ( ) process.
private string movetofolder ( final string file , final string folder ) { final file source = new file ( file ) ; final file destination = new file ( folder + file . separator + source . getname ( ) ) ; log . i ( tag , file + _str + destination . getabsolutepath ( ) ) ; try { fileutils . movefile ( source , destination ) ; } catch ( final ioexception e ) { log . e ( tag , _str ) ; } return destination . getabsolutepath ( ) ; }	moves file to specified folder.
public void putall ( map m ) { set keys = m . keyset ( ) ; for ( iterator iter = keys . iterator ( ) ; iter . hasnext ( ) ; ) { object key = iter . next ( ) ; put ( key , m . get ( key ) ) ; } }	puts all the elements in the map to this map .
protected string handledate ( resultset rs , int columnindex , string dateformatstring ) throws sqlexception { java . sql . date date = rs . getdate ( columnindex ) ; string value = null ; if ( date != null ) { simpledateformat dateformat = new simpledateformat ( dateformatstring ) ; value = dateformat . format ( date ) ; } return value ; }	retrieves a date from the result set .
@ override public randomaccessstream openfilerandomaccess ( ) throws ioexception { if ( _iswindows && isaux ( ) ) throw new filenotfoundexception ( _file . tostring ( ) ) ; return new filerandomaccessstream ( new randomaccessfile ( getfile ( ) , _str ) ) ; }	returns the stream implementation for a random - access stream .
public qdate ( timezone zone , long now ) { _timezone = zone ; if ( zone == _gmttimezone ) { _stdname = _gmtstdname ; _dstname = _gmtdstname ; } else if ( zone == _localtimezone ) { _stdname = _localstdname ; _dstname = _localdstname ; } else { _stdname = _timezone . getdisplayname ( _bool , timezone . short ) ; _dstname = _timezone . getdisplayname ( _bool , timezone . short ) ; } _calendar = new gregoriancalendar ( _timezone ) ; if ( zone == _gmttimezone ) setgmttime ( now ) ; else setlocaltime ( now ) ; }	creates the date from local or gmt .
public static void serialize ( serializable obj , bytearrayoutputstream bout ) { try { objectoutputstream out = new objectoutputstream ( bout ) ; out . writeobject ( obj ) ; out . close ( ) ; } catch ( ioexception e ) { throw new illegalstateexception ( _str + obj , e ) ; } }	serialize the given object into the given stream.
public static string upper ( string s ) { return s . touppercase ( locale . english ) ; }	avoids turkish ' i ' problem .
private void accept ( socket socket ) { log . info ( _str , socket . getinetaddress ( ) ) ; try { inetaddress serveraddress = dns . getaddress ( _str ) ; try ( connection clientconnection = new connection ( socket ) ; connection serverconnection = new connection ( new socket ( serveraddress , clash_port ) ) ) { proxysession session = proxysession . newsession ( services . getmessagefactory ( ) , clientconnection , serverconnection , filterchain ) ; log . info ( _str , socket ) ; villageanalyzer . logsession ( session ) ; } } catch ( ioexception e ) { log . info ( _str , socket . getinetaddress ( ) , e . tostring ( ) ) ; } finally { try { socket . close ( ) ; } catch ( ioexception e ) { } } }	accept a connection from a client and proxy it to the server.
public void removeprocesslistener ( processlistener l ) { listenerlist . remove ( l ) ; }	removes an process listener from the list of listeners .
public final static boolean isvalidjavaidentifier ( string s ) { if ( s == null || s . length ( ) == _num ) { return _bool ; } char [ ] c = s . tochararray ( ) ; if ( ! character . isjavaidentifierstart ( c [ _num ] ) ) { return _bool ; } for ( int i = _num ; i < c . length ; i ++ ) { if ( ! character . isjavaidentifierpart ( c [ i ] ) ) { return _bool ; } } return _bool ; }	check whether the given string is a valid identifier according to the java language specifications.
final void sendhelp ( ) { arraylist < string > help = help ( ) ; if ( help . isempty ( ) ) { return ; } xmppmsg msg = new xmppmsg ( ) ; msg . addstringarray ( help . toarray ( new string [ help . size ( ) ] ) ) ; send ( msg ) ; }	sends the help messages from the current command to the user , does nothing if there are no help messages available.
protected void init ( ) { log . info ( _str ) ; long starttime = system . currenttimemillis ( ) ; bughousesoundkeys = getsoundskeys ( _str ) ; soundkeys = getsoundskeys ( _str ) ; initsoundplayer ( ) ; initspeech ( ) ; log . info ( _str + ( system . currenttimemillis ( ) - starttime ) + _str ) ; }	i have tried caching the clips.
private static void runconfclient ( final processbuilder pb ) throws exception { int exitcode = - _num ; try { process process = pb . start ( ) ; exitcode = process . waitfor ( ) ; } catch ( ioexception e ) { log . error ( _str , e ) ; exitcode = _num ; throw e ; } catch ( exception e ) { log . error ( _str , e ) ; throw e ; } switch ( exitcode ) { case success : break ; case error_code_cannot_download_conf : throw new exception ( _str + exitcode + _str ) ; case error_code_expired_conf : throw new exception ( _str + exitcode + _str ) ; case error_code_invalid_signature_value : throw new exception ( _str + exitcode + _str ) ; case error_code_internal : throw new exception ( _str + exitcode + _str ) ; default : throw new exception ( _str + _str + exitcode + _str + _str + _str ) ; } }	helper method for running the configuration client script .
public boolean dochecksitestatus ( url url ) { if ( debug . messageenabled ( ) ) { debug . message ( _str + url ) ; } urlchecker checker = geturlchecker ( url ) ; if ( checker != null && ( checker . getstatus ( ) == urlstatus . status_unknown ) ) { synchronized ( checker ) { checker . cancel ( ) ; checker . notify ( ) ; } synchronized ( urlcheckers ) { urlcheckers . remove ( getthreadname ( url ) ) ; } debug . error ( _str + _str + getthreadname ( url ) ) ; return _bool ; } else if ( ( checker != null ) && ( checker . getstatus ( ) == urlstatus . status_available ) ) { return _bool ; } else { return _bool ; } }	the method that will be used by sitemonitor to check each site is alive .
protected void fill ( ) throws ioexception { ensureopen ( ) ; len = in . read ( buf , _num , buf . length ) ; if ( len == - _num ) { throw new eofexception ( _str ) ; } inf . setinput ( buf , _num , len ) ; }	fills input buffer with more data to decompress .
private boolean overrides ( executableelement e , class < ? > clazz , string method ) { typeelement clazzelt = elements . gettypeelement ( clazz . getcanonicalname ( ) ) ; assert clazzelt != null ; for ( executableelement elt : elementfilter . methodsin ( clazzelt . getenclosedelements ( ) ) ) { if ( elt . getsimplename ( ) . contentequals ( method ) && elements . overrides ( e , elt , clazzelt ) ) { return _bool ; } } return _bool ; }	determines whether or not the given element overrides the named method in the named class .
public element signxml ( document doc , string certalias , string algorithm , string idattrname , string id , boolean includecert , string xpath ) throws xmlsignatureexception { return signxmlusingkeypass ( doc , certalias , null , algorithm , idattrname , id , includecert , xpath ) ; }	sign part of the xml document referred by the supplied id attribute using enveloped signatures and use exclusive xml canonicalization .
public int size ( ) { return attrs . size ( ) ; }	indicates the number of attributes held in the container .
protected socket __openpassivedataconnection ( int command , string arg ) throws ioexception , ftpexceptioncannothavedataconnection { socket socket ; if ( pasv ( ) != ftpreply . entering_passive_mode ) throw new ftpexceptioncannothavedataconnection ( _str + getreplystring ( ) ) ; try { __parsepassivemodereply ( getreplystrings ( ) [ _num ] ) ; } catch ( malformedserverreplyexception e ) { throw new ftpexceptioncannothavedataconnection ( e . getmessage ( ) ) ; } socket = _socketfactory_ . createsocket ( __passivehost , __passiveport ) ; if ( ! ftpreply . ispositivepreliminary ( sendcommand ( command , arg ) ) ) { socket . close ( ) ; return null ; } if ( __remoteverificationenabled && ! verifyremote ( socket ) ) { inetaddress host1 , host2 ; host1 = socket . getinetaddress ( ) ; host2 = getremoteaddress ( ) ; socket . close ( ) ; throw new ftpexceptioncannothavedataconnection ( _str + host1 . gethostaddress ( ) + _str + host2 . gethostaddress ( ) + _str ) ; } if ( __datatimeout >= _num ) socket . setsotimeout ( __datatimeout ) ; return socket ; }	open a passive data connection socket.
public object invoke ( object proxy , method method , object [ ] args ) throws throwable { monitor mon = null ; if ( params . isinterfaceenabled && params . isenabled ) { mon = monitorfactory . start ( labelerint . getsummarylabel ( method ) ) ; } try { if ( method . equals ( equals_method ) ) return boolean . valueof ( equals ( args [ _num ] ) ) ; else return method . invoke ( monitoredobj , args ) ; } catch ( invocationtargetexception e ) { if ( params . isenabled ) { string sqlmessage = _str ; string detailstacktrace = null ; throwable rootcause = e . getcause ( ) ; if ( rootcause instanceof sqlexception ) { sqlexception sqlexception = ( sqlexception ) rootcause ; sqlmessage = _str + sqlexception . geterrorcode ( ) + _str + sqlexception . getsqlstate ( ) ; } trackexception ( rootcause , method , sqlmessage ) ; } throw e . getcause ( ) ; } finally { if ( mon != null ) mon . stop ( ) ; } }	method that monitors method invocations of the proxied interface.
public static void copystream ( final inputstream fromstream , final outputstream tostream ) throws ioexception { byte [ ] buffer = new byte [ _num ] ; int bytesread ; while ( ( bytesread = fromstream . read ( buffer ) ) != - _num ) { tostream . write ( buffer , _num , bytesread ) ; } }	copies the content from one stream to another stream .
private void loadstringvalue ( jtextfield comp , final string elementname ) { string propvalue = properties . getvalue ( elementname ) ; if ( propvalue != null && ! propvalue . isempty ( ) ) { comp . settext ( propvalue ) ; } }	gets the string value of a property and loads it into a jtextfield.
public builder label ( char label ) { this . label = character . touppercase ( label ) ; return this ; }	specifies a single uppercase alphanumeric character from the set { a - z , 0 - 9 } .
public static boolean isletterordigit ( char c ) { return character . isletterordigit ( c ) ; }	returns true if character c is a letter or digit .
public static int putlong ( byte [ ] bytes , int offset , long val ) { if ( littleendian ) { val = long . reversebytes ( val ) ; } theunsafe . putlong ( bytes , offset + byte_array_base_offset , val ) ; return offset + bytes . sizeof_long ; }	put a long value out to the specified byte array position in big - endian format .
private instruction schedulescalardefsearly ( enumeration < operand > e , instruction earlypos , instruction inst ) { while ( e . hasmoreelements ( ) ) { operand op = e . nextelement ( ) ; instruction def = defininginstruction ( op ) ; scheduleearly ( def ) ; if ( def . isbranch ( ) ) def = dominancesuccessor ( def , inst ) ; earlypos = maxdominatordepth ( def , earlypos ) ; } return earlypos ; }	schedules an instruction as early as possible , but behind the definitions in e and behind earlypos.
public void makeunique ( string [ ] columns , string conflictpolicy ) { uniques . add ( constraint_unique_ + textutils . join ( _str , columns ) + _unique__ + textutils . join ( _str , columns ) + __on_conflict_ + conflictpolicy + comma ) ; }	create a unique constraint to already declared columns using the specified conflict policy . atention : it does not add the columns to the table , you need to add the columns using addcolumn or addfk.
default < t > void foreachmatchingfieldnamewithboolean ( string regex , biconsumer < string , boolean > function ) { foreachmatchingfieldnamewithboolean ( pattern . compile ( regex ) , _num , function ) ; }	for all fields whose names match the given regular expression , extract a boolean value from the first group in the regular expression and call the supplied function .
public void exit ( ) { cancel ( ) ; final float radius = lerp ( _num , mouterradius , mtweenradius ) ; final float remaining ; if ( manimradius != null && manimradius . isrunning ( ) ) { remaining = mouterradius - radius ; } else { remaining = mouterradius ; } final int radiusduration = ( int ) ( _num * math . sqrt ( remaining / ( wave_touch_up_acceleration + wave_touch_down_acceleration ) * mdensity ) + _num ) ; final int opacityduration = ( int ) ( _num * mopacity / wave_opacity_decay_velocity + _num ) ; exitsoftware ( radiusduration , opacityduration ) ; }	starts the exit animation .
public void testsealedobject2 ( ) throws exception { try { new sealedobject ( null ) { } ; fail ( _str + _str ) ; } catch ( nullpointerexception e ) { } string secret = _str ; cipher cipher = new nullcipher ( ) ; sealedobject so1 = new sealedobject ( secret , cipher ) ; sealedobject so2 = new sealedobject ( so1 ) { } ; assertequals ( _str + _str , secret , so2 . getobject ( cipher ) ) ; assertequals ( _str + _str + _str , so1 . getalgorithm ( ) , so2 . getalgorithm ( ) ) ; }	sealedobject ( sealedobject so ) method testing.
@ override public void handlerequestbody ( solrqueryrequest req , solrqueryresponse rsp ) throws parseexception , ioexception , syntaxerror { string deletionquery = getdeletionquery ( ) ; logger . info ( _str , deletionquery ) ; if ( olderdocumentsexists ( deletionquery , req , rsp ) ) { updaterequestprocessor processor = getprocessor ( req , rsp ) ; deleteolddocuments ( deletionquery , processor , req ) ; commitdeletions ( processor , req ) ; } }	processes the request for the round robin update update handler .
public < v extends comparable < ? super v > > optionallong maxby ( longfunction < v > keyextractor ) { objlongbox < v > result = collect ( null , null , null ) ; return result . a == null ? optionallong . empty ( ) : optionallong . of ( result . b ) ; }	returns the maximum element of this stream according to the provided key extractor function.
public void queryandcompareshards ( solrparams params ) throws exception { updatemappingsfromzk ( jettys , clients ) ; list < string > shards = new arraylist < > ( shardtojetty . keyset ( ) ) ; for ( string shard : shards ) { queryandcomparereplicas ( params , shard ) ; } }	for each shard , executes a query against each live and active replica of that shard and asserts that the results are identical for each replica of the same shard.
public int indexof ( int ch ) { return indexof ( ch , _num ) ; }	returns the index within this string of the first occurrence of the specified character.
private watcher initwatcher ( solrzkclient zkclient ) { wrappedwatcher = new bufferstatewatcher ( ) ; return zkclient . wrapwatcher ( wrappedwatcher ) ; }	solrzkclient does not guarantee that a watch object will only be triggered once for a given notification if we does not wrap the watcher - see solr - 6621 .
public configuration ( ) { super ( ) ; }	creates an empty extended properties object .
public static < k , v > map < k , v > of ( k k1 , v v1 , k k2 , v v2 , k k3 , v v3 , k k4 , v v4 , k k5 , v v5 , k k6 , v v6 , k k7 , v v7 ) { map map = of ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; map . put ( k3 , v3 ) ; map . put ( k4 , v4 ) ; map . put ( k5 , v5 ) ; map . put ( k6 , v6 ) ; map . put ( k7 , v7 ) ; return map ; }	returns map containing the given entries .
public long longat ( int index ) { lb . position ( index ) ; return lb . get ( ) ; }	get the value of an element of the longarraycounter object .
private string startsettostring ( ) { stringbuffer fstring = new stringbuffer ( ) ; boolean didprint ; if ( m_starting == null ) { return getstartset ( ) ; } for ( int i = _num ; i < m_starting . length ; i ++ ) { didprint = _bool ; if ( ( m_hasclass == _bool ) || ( m_hasclass == _bool && i != m_classindex ) ) { fstring . append ( ( m_starting [ i ] + _num ) ) ; didprint = _bool ; } if ( i == ( m_starting . length - _num ) ) { fstring . append ( _str ) ; } else { if ( didprint ) { fstring . append ( _str ) ; } } } return fstring . tostring ( ) ; }	converts the array of starting attributes to a string.
public static string maketagclassname ( string componentfamily , string renderertype ) { if ( componentfamily == null ) { return null ; } string tagclassname = componentfamily ; if ( renderertype != null ) { if ( ! componentfamily . equals ( renderertype ) ) { tagclassname = tagclassname + renderertype ; } } return tagclassname + _str ; }	build the tag handler class name from componentfamily and renderertype .
public static void assertalmostequals ( double expected , double actual , int decimals ) { assertalmostequals ( null , new double ( expected ) , new double ( actual ) , decimals ) ; }	tests whether numbers are the same up to the specified decimals .
private static int snapvertical ( collection < constraintwidget > widgets , constraintwidget widget , constraintanchor anchor , int position , arraylist < snapcandidate > snapcandidates ) { snapcandidate candidate = new snapcandidate ( ) ; constrainthandle handle = widgetinteractiontargets . constrainthandle ( anchor ) ; if ( handle == null ) { return position ; } handle . setdrawy ( position ) ; snapplacement . snapanchor ( widgets , widget , anchor , candidate ) ; if ( candidate . target != null ) { constrainthandle targethandle = widgetinteractiontargets . constrainthandle ( candidate . target ) ; int ty = candidate . y ; if ( targethandle != null ) { ty = targethandle . getdrawy ( ) ; } position = ty + candidate . margin ; snapcandidates . add ( candidate ) ; } return position ; }	utility function to gather snap candidates on the vertical axis.
public int send ( outputstream out ) throws ioexception { out . write ( this . filebuff , this . offset , this . length ) ; return _num ; }	send file content callback function , be called only once when the file uploaded.
private double sin ( double angle ) { while ( angle >= _num ) { angle -= _num ; } double value = ( angle / _num * math . pi ) ; return math . sin ( value ) ; }	gets the sinus of the angle .
public static string last ( string list , string delimiter , boolean ignoreempty ) { if ( stringutil . isempty ( list ) ) return _str ; int len = list . length ( ) ; char [ ] del ; if ( stringutil . isempty ( delimiter ) ) { del = new char [ ] { _str } ; } else del = delimiter . tochararray ( ) ; int index ; int x ; while ( _bool ) { index = - _num ; for ( int i = _num ; i < del . length ; i ++ ) { x = list . lastindexof ( del [ i ] ) ; if ( x > index ) index = x ; } if ( index == - _num ) { return list ; } else if ( index + _num == len ) { if ( ! ignoreempty ) return _str ; list = list . substring ( _num , len - _num ) ; len -- ; } else { return list . substring ( index + _num ) ; } } }	return last element of the list.
private void tryparsetypeattribute ( idomelement element ) { idomattr typeattr = ( idomattr ) uibinderxmlmodelutilities . gettypeattribute ( element ) ; if ( typeattr == null ) { return ; } iregion valueregion = xmlutilities . getattributevalueregion ( typeattr ) ; if ( valueregion == null ) { return ; } string fqtype = typeattr . getnodevalue ( ) ; if ( fqtype == null ) { return ; } final itype type = javamodelsearch . findtype ( javaproject , fqtype ) ; if ( ! javamodelsearch . isvalidelement ( type ) ) { problemmarkermanager . settypeundefinederror ( valueregion , fqtype ) ; } else { if ( uibinderxmlmodelutilities . isstyleelement ( element ) ) { itype cssresourcetype = clientbundleutilities . findcssresourcetype ( javaproject ) ; if ( cssresourcetype != null ) { try { if ( ! javautilities . issubtype ( cssresourcetype , type ) ) { problemmarkermanager . setnotcssresourcesubtypeerror ( valueregion , fqtype ) ; } } catch ( javamodelexception e ) { gwtpluginlog . logwarning ( e , _str ) ; } } } } javatypereferences . add ( fqtype ) ; }	parses the " type " attribute on < ui : with > and < ui : style > elements .
public static list < mrelationtype > retrievetypes ( final po po , final int windowid ) { if ( po . get_keycolumns ( ) . length != _num ) { logger . severe ( po + _str + po . get_keycolumns ( ) . length + _str ) ; porelationexception . throwwrongkeycolumncount ( po ) ; } final string keycolumn = po . get_keycolumns ( ) [ _num ] ; final int colid = mcolumn . getcolumn_id ( po . get_tablename ( ) , keycolumn ) ; final preparedstatement pstmt = db . preparestatement ( sql , po . get_trxname ( ) ) ; resultset rs = null ; try { pstmt . setint ( _num , po . get_table_id ( ) ) ; pstmt . setint ( _num , colid ) ; rs = pstmt . executequery ( ) ; final list < mrelationtype > result = evalresultset ( po , windowid , rs ) ; logger . info ( _str + result . size ( ) + _str + po ) ; return result ; } catch ( sqlexception e ) { logger . severe ( e . getmessage ( ) ) ; throw new adempiereexception ( e ) ; } finally { db . close ( rs , pstmt ) ; } }	returns the types that define a relation which contains the given po.
public jdpjmxpacket ( byte [ ] data ) throws jdpexception { jdppacketreader reader ; reader = new jdppacketreader ( data ) ; map < string , string > p = reader . getdiscoverydataasmap ( ) ; string sid = p . get ( uuid_key ) ; this . id = ( sid == null ) ? null : uuid . fromstring ( sid ) ; this . jmxserviceurl = p . get ( jmx_service_url_key ) ; this . mainclass = p . get ( main_class_key ) ; this . instancename = p . get ( instance_name_key ) ; this . processid = p . get ( process_id_key ) ; this . rmihostname = p . get ( rmi_hostname_key ) ; this . broadcastinterval = p . get ( broadcast_interval_key ) ; }	create new instance from network data parse packet and set fields .
private uidrange parseuidrange ( string range ) throws decodingexception { int pos = range . indexof ( _str ) ; try { if ( pos == - _num ) { if ( range . length ( ) == _num && range . charat ( _num ) == _str ) { return new uidrange ( messageuid . max_value ) ; } else { long value = parseunsignedinteger ( range ) ; return new uidrange ( messageuid . of ( value ) ) ; } } else { long val1 = parseunsignedinteger ( range . substring ( _num , pos ) ) ; long val2 = parseunsignedinteger ( range . substring ( pos + _num ) ) ; if ( val1 == long . max_value && val2 == long . max_value ) { return new uidrange ( messageuid . max_value ) ; } else if ( val1 <= val2 ) { return new uidrange ( messageuid . of ( val1 ) , messageuid . of ( val2 ) ) ; } else if ( val1 == long . max_value ) { return new uidrange ( messageuid . of ( val2 ) , messageuid . max_value ) ; } else { return new uidrange ( messageuid . of ( val2 ) , messageuid . of ( val1 ) ) ; } } } catch ( numberformatexception e ) { throw new decodingexception ( humanreadabletext . invalid_messageset , _str , e ) ; } }	parse a range which use a " : " as delimiter.
public void addfxgllistener ( fxgllistener listener ) { systemlisteners . add ( listener ) ; }	add listener for core fxgl callbacks .
public void adddefinition ( string definition ) { if ( ! stringutils . isempty ( definition ) ) { definitions . add ( definition ) ; } }	adds a project preprocessor definition.
@ override public void receiveevent ( clientstateinformation information ) { if ( information . getstate ( ) != currentstate ) { logger . info ( _str + information ) ; if ( information . getstate ( ) == clientstate . search ) { searchstarttime = system . currenttimemillis ( ) ; for ( sequenceoutputvariablefactory < ? > factory : sequenceoutputvariablefactories . values ( ) ) { factory . setstarttime ( searchstarttime ) ; } } outputvariable < long > time = new outputvariable < long > ( _str + currentstate . getname ( ) , system . currenttimemillis ( ) - currentstatestarted ) ; outputvariables . put ( time . getname ( ) , time ) ; currentstate = information . getstate ( ) ; currentstatestarted = system . currenttimemillis ( ) ; } }	process status update event received from client.
public void testcase11 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = _num ; int bsign = - _num ; byte rbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . subtract ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _num , result . signum ( ) ) ; }	subtract two numbers of different length and different signs.
public void addbugcode ( bugcode bugcode ) { bugcodelist . add ( bugcode ) ; }	add a bugcode reported by the plugin .
@ override public final void write ( int b ) { if ( this . ignorewrites ) return ; checkifwritable ( ) ; ensurecapacity ( _num ) ; buffer . put ( ( byte ) b ) ; }	write the low - order 8 bits of the given int.
public void testnestedallocationcontexts ( ) { final iallocationcontext context = manager . newallocationcontext ( _bool ) ; final string test = _str ; final long addr1 = allocate ( manager , context , test ) ; final long addr2 = allocate ( manager , context , test ) ; asserttrue ( addr1 != addr2 ) ; final string res = getstring ( addr1 ) ; asserttrue ( res . equals ( test ) ) ; manager . free ( addr1 , context ) ; final long addr3 = allocate ( manager , context , test ) ; asserttrue ( addr1 != addr3 ) ; manager . detachcontext ( context ) ; final iallocationcontext context2 = manager . newallocationcontext ( _bool ) ; final long addr4 = allocate ( manager , context2 , test ) ; asserttrue ( addr1 == addr4 ) ; }	rather than creating contexts directly , instead associate with externally created context .
public static string underlinestocamelcase ( string string ) { stringbuilder sb = new stringbuilder ( string . length ( ) ) ; int n = string . length ( ) ; int i = _num ; boolean upcasenext = _bool ; for ( ; i < n ; i ++ ) { char c = string . charat ( i ) ; if ( c == _str ) { upcasenext = _bool ; } else { if ( upcasenext ) { c = character . touppercase ( c ) ; } upcasenext = _bool ; sb . append ( c ) ; } } return sb . tostring ( ) ; }	converts an underlined_word into a camelcase word.
protected bestmatchfinder ( string pattern ) { searchpattern = pattern . tolowercase ( ) ; }	creates a match finder for a given search pattern .
public int indexof ( object key ) { return key == null ? indexofnull ( ) : indexof ( key , key . hashcode ( ) ) ; }	returns the index of a value in the set .
public long nextactionmillis ( long now , long nextretrytimemillis ) { for ( filedownloadinfo info : downloads ) { long individualretrytimemillis = getnextactionmillisfor ( now , info ) ; nextretrytimemillis = math . min ( individualretrytimemillis , nextretrytimemillis ) ; } return nextretrytimemillis ; }	return time when this download will be ready for its next action , in milliseconds after given time .
public integer countpagescontainingtemplatenames ( list < string > templatenames ) throws wikiapiexception { return countfilteredpages ( templatenames , _bool ) ; }	returns the number of all pages that contain a template the name of which equals the given string .
static url fixpurequerytargets ( url base , string target ) throws malformedurlexception { if ( ! target . startswith ( _str ) ) return new url ( base , target ) ; string basepath = base . getpath ( ) ; string baserightmost = _str ; int baserightmostidx = basepath . lastindexof ( _str ) ; if ( baserightmostidx != - _num ) { baserightmost = basepath . substring ( baserightmostidx + _num ) ; } if ( target . startswith ( _str ) ) target = baserightmost + target ; return new url ( base , target ) ; }	handle the case in rfc3986 section 5.
synchronized void add ( object obj ) { if ( objlist != null ) { objlist . add ( obj ) ; } }	adds the specified reference to this dgcackhandler .
public void sort ( ) { collections . sort ( individuals , performance_comparator ) ; }	sorts the individuals in ascending order according to their performance , thus the best one will be in last position .
void freeinterval ( spilllocationinterval i ) { freeintervals . add ( i ) ; }	records that a particular interval is potentially available for reuse .
private void checkandwritedictionarychunktofile ( ) throws ioexception { if ( onedictionarychunklist . size ( ) >= dictionary_one_chunk_size ) { writedictionaryfile ( ) ; createchunklist ( ) ; } }	check if the threshold has been reached for the number of values that can kept in memory and then flush the data to file.
private void ctrlselect ( d nodedata ) { int insertionindex = getinsertionindex ( nodedata ) ; insertandselectnode ( nodedata , insertionindex , ! nodedata . equals ( selectednodes . get ( insertionindex ) ) ) ; }	if ctrl is depressed then we simply search for the insertion point of the specified node in the already sorted select list.
private void readobject ( objectinputstream ois ) throws ioexception , classnotfoundexception { byte [ ] asn1encprincipal = ( byte [ ] ) ois . readobject ( ) ; byte [ ] encrealm = ( byte [ ] ) ois . readobject ( ) ; try { realm realmobject = new realm ( new dervalue ( encrealm ) ) ; principalname krb5principal = new principalname ( new dervalue ( asn1encprincipal ) , realmobject ) ; realm = realmobject . tostring ( ) ; fullname = krb5principal . tostring ( ) ; nametype = krb5principal . getnametype ( ) ; } catch ( exception e ) { throw new ioexception ( e ) ; } }	reads this object from a stream ( i.
private static int readswappedinteger ( final datainputstream input ) throws ioexception { final int value1 = input . readbyte ( ) ; final int value2 = input . readbyte ( ) ; final int value3 = input . readbyte ( ) ; final int value4 = input . readbyte ( ) ; return ( ( value1 & _num ) << _num ) + ( ( value2 & _num ) << _num ) + ( ( value3 & _num ) << _num ) + ( ( value4 & _num ) << _num ) ; }	reads a " int " value from an inputstream.
private void consumeprenestedscroll ( int dx , int dy , int [ ] consumed ) { if ( moverscrolleffect == overscrolleffect . bounce && munconsumedoverscrolloffset != _num ) { int destoffset = munconsumedoverscrolloffset - dy ; if ( ! mathutils . samesign ( destoffset , munconsumedoverscrolloffset ) ) { destoffset = _num ; } else if ( math . abs ( destoffset ) > math . abs ( munconsumedoverscrolloffset ) ) { destoffset = munconsumedoverscrolloffset ; } consumed [ _num ] = _num ; consumed [ _num ] = munconsumedoverscrolloffset - destoffset ; munconsumedoverscrolloffset = destoffset ; setscrollingoffset ( getunconsumedscrollingoffset ( ) ) ; } }	consume the pre nested scroll before all behaviors if need .
public strbuilder replace ( final int startindex , int endindex , final string replacestr ) { endindex = validaterange ( startindex , endindex ) ; final int insertlen = ( replacestr == null ? _num : replacestr . length ( ) ) ; replaceimpl ( startindex , endindex , endindex - startindex , replacestr , insertlen ) ; return this ; }	replaces a portion of the string builder with another string.
public boolean isvalid ( int value ) { return min <= value && value <= max ; }	performs basic sanity check of argument .
public pluginsinfo info ( ) { return info ; }	get information about plugins ( jvm and site plugins ) .
public void firepropertychange ( string propertyname , int oldvalue , int newvalue ) { firepropertychange ( propertyname , integer . valueof ( oldvalue ) , integer . valueof ( newvalue ) ) ; }	fires a property change of an integer property with the given name.
static arraylist < field > allfields ( final class < ? > clazz ) { final arraylist < field > res = new arraylist < > ( ) ; class < ? > cl = clazz ; while ( cl != null ) { final field [ ] fields = cl . getdeclaredfields ( ) ; collections . addall ( res , fields ) ; cl = cl . getsuperclass ( ) ; } return res ; }	get all the fields in this class and its super - classes .
private void updateweatherstates ( ) { boolean changed = temperature . update ( ) ; changed |= rain . update ( ) ; changed |= fog . update ( ) ; changed |= thunder . update ( ) ; if ( changed ) { updatezones ( ) ; } }	update the zone weather states .
public static renderloops makerenderloops ( surfacetype src , compositetype comp , surfacetype dst ) { renderloops loops = new renderloops ( ) ; loops . drawlineloop = drawline . locate ( src , comp , dst ) ; loops . fillrectloop = fillrect . locate ( src , comp , dst ) ; loops . drawrectloop = drawrect . locate ( src , comp , dst ) ; loops . drawpolygonsloop = drawpolygons . locate ( src , comp , dst ) ; loops . drawpathloop = drawpath . locate ( src , comp , dst ) ; loops . fillpathloop = fillpath . locate ( src , comp , dst ) ; loops . fillspansloop = fillspans . locate ( src , comp , dst ) ; loops . fillparallelogramloop = fillparallelogram . locate ( src , comp , dst ) ; loops . drawparallelogramloop = drawparallelogram . locate ( src , comp , dst ) ; loops . drawglyphlistloop = drawglyphlist . locate ( src , comp , dst ) ; loops . drawglyphlistaaloop = drawglyphlistaa . locate ( src , comp , dst ) ; loops . drawglyphlistlcdloop = drawglyphlistlcd . locate ( src , comp , dst ) ; return loops ; }	construct and return a renderloops object containing all of the basic graphicsprimitive objects for rendering to the destination surface with the given source , destination , and composite types .
public void edit ( object plotcanvas ) { string _label = joptionpane . showinputdialog ( ( plotcanvas ) plotcanvas , _str , label ) ; if ( _label != null ) { setlegend ( _label ) ; } }	opens a dialog window and asks the user for the name of this axis .
protected boolean excludefile ( string file ) { if ( excluded == null ) return _bool ; iterator < string > iter = excluded . iterator ( ) ; while ( iter . hasnext ( ) ) if ( file . endswith ( iter . next ( ) ) ) return _bool ; return _bool ; }	check if a file is excluded or not.
public builder deleteusertype ( ) { deletefields . add ( _str ) ; return this ; }	deletes the user type of a existing user.
public final static boolean endswithignorecase ( string str , string end ) { int strlength = str == null ? _num : str . length ( ) ; int endlength = end == null ? _num : end . length ( ) ; if ( endlength > strlength ) return _bool ; for ( int i = _num ; i <= endlength ; i ++ ) { if ( scannerhelper . tolowercase ( end . charat ( endlength - i ) ) != scannerhelper . tolowercase ( str . charat ( strlength - i ) ) ) return _bool ; } return _bool ; }	returns true iff str.
public void write ( int c ) throws ioexception { internalout . write ( c ) ; }	writes a single character .
private < t extends clientrequestresult > collection < t > executerequest ( final collection < long > ids , final class < t > clazz , final clientrequestreportlistener reportlistener , final string requestqueue ) { logger . debug ( _str ) ; clientrequestimpl < t > clientrequest = new clientrequestimpl < t > ( clazz ) ; iterator < long > it = ids . iterator ( ) ; collection < future < collection < t > > > results = new arraylist < future < collection < t > > > ( ) ; int counter = _num ; while ( it . hasnext ( ) ) { while ( it . hasnext ( ) && counter < maxrequestsize ) { clientrequest . addtagid ( it . next ( ) ) ; counter ++ ; } requestvaluestask < t > task = new requestvaluestask < t > ( clientrequest , reportlistener , requestqueue ) ; results . add ( executor . submit ( task ) ) ; clientrequest = new clientrequestimpl < t > ( clazz ) ; counter = _num ; } collection < t > finalcollection = new arraylist < t > ( ) ; for ( future < collection < t > > result : results ) { try { finalcollection . addall ( result . get ( ) ) ; } catch ( interruptedexception e ) { logger . error ( _str , e ) ; throw new runtimeexception ( e ) ; } catch ( executionexception e ) { logger . error ( _str , e ) ; throw new runtimeexception ( e ) ; } } logger . debug ( _str ) ; return finalcollection ; }	splits and executes a id - base request , splitting the collection into smaller requests .
public static map < string , integer > classnamestomapping ( list < string > labels ) { map < string , integer > mapping = new hashmap < string , integer > ( ) ; for ( int i = _num ; i < labels . size ( ) ; i ++ ) { mapping . put ( labels . get ( i ) , i ) ; } return mapping ; }	from a list of labels , creates a mapping from strings to indices .
public static string shortnumber ( int number ) { if ( number >= _num ) { int hundred = number % _num / _num ; if ( hundred != _num ) return string . format ( _str , number / _num ) + _str ; else return ( number / _num ) + _str ; } else return number + _str ; }	1000 - > 1k , 1100 - > 1 . 1k.
public static void putunsignedshort ( bytebuffer bb , int v ) { bb . putshort ( ( short ) ( v & _num ) ) ; }	put an unsigned short into the specified bytebuffer at the current position.
public static string readfiletostring ( file f ) throws ioexception { stringwriter sw = new stringwriter ( ) ; io . copyandcloseboth ( common . asreaderutf8lenient ( new fileinputstream ( f ) ) , sw ) ; return sw . tostring ( ) ; }	read the contents of the given file into a string.
public void test_wrap_bytebuffer bytebuffer_05 ( ) { string host = _str ; int port = _num ; bytebuffer bb = bytebuffer . allocate ( _num ) ; bytebuffer [ ] bba = { bytebuffer . allocate ( _num ) , bytebuffer . allocate ( _num ) , bytebuffer . allocate ( _num ) } ; sslengine sse = getengine ( host , port ) ; sse . setuseclientmode ( _bool ) ; try { sslengineresult res = sse . wrap ( bba , bb ) ; assertequals ( _num , res . bytesconsumed ( ) ) ; assertequals ( _num , res . bytesproduced ( ) ) ; } catch ( exception ex ) { fail ( _str + ex ) ; } }	javax . net . ssl . sslengine # wrap ( bytebuffer [ ] srcs , bytebuffer dst ).
public void testtopicdinamicallyincludedbehavior ( ) throws exception { startallbrokers ( ) ; destination dest = createdestination ( _str , _bool ) ; messageconsumer clienta = createconsumer ( _str , dest ) ; messageconsumer clientb = createconsumer ( _str , dest ) ; thread . sleep ( _num * _num ) ; sendmessages ( _str , dest , message_count ) ; messageidlist msgsa = getconsumermessages ( _str , clienta ) ; msgsa . waitformessagestoarrive ( message_count ) ; assertequals ( message_count , msgsa . getmessagecount ( ) ) ; messageidlist msgsb = getconsumermessages ( _str , clientb ) ; msgsb . waitformessagestoarrive ( message_count ) ; assertequals ( _num , msgsb . getmessagecount ( ) ) ; }	brokera - > brokerb & & brokerb - > brokera.
private file createcapturefile ( int encodingtype , string filename ) { if ( filename . isempty ( ) ) { filename = _str ; } if ( encodingtype == jpeg ) { filename = filename + _str ; } else if ( encodingtype == png ) { filename = filename + _str ; } else { throw new illegalargumentexception ( _str + encodingtype ) ; } return new file ( gettempdirectorypath ( ) , filename ) ; }	create a file in the applications temporary directory based upon the supplied encoding .
public boolean validatetoken ( endpointspecification endpointspecification , securitytoken tobevalidatedtoken ) throws soapstsconsumerexception { stsclient client = getstsclient ( stsinstancewsdlurl , endpointspecification . serviceqname , endpointspecification . portqname ) ; client . settokentype ( stsconstants . status ) ; try { client . validatesecuritytoken ( tobevalidatedtoken ) ; return _bool ; } catch ( trustexception e ) { return _bool ; } catch ( exception e ) { throw new soapstsconsumerexception ( e . getmessage ( ) , e ) ; } }	invokes the soap - sts validate operation.
public static string stripfunctiontags ( string label ) { if ( label . indexof ( _str ) > _num ) return label . substring ( _num , label . indexof ( _str ) ) ; else return label ; }	strips function tags from a given node label.
@ override public void playnewvideo ( metadata currentitemmetadata , videoplayerview videoplayerview , string videourl ) { if ( show_logs ) logger . v ( tag , _str + videoplayerview + _str + mcurrentplayer + _str + videoplayerview ) ; mplayerhandler . pausequeueprocessing ( tag ) ; boolean currentplayerisactive = mcurrentplayer == videoplayerview ; boolean isalreadyplayingthefile = mcurrentplayer != null && videourl . equals ( mcurrentplayer . getvideourldatasource ( ) ) ; if ( show_logs ) logger . v ( tag , _str + isalreadyplayingthefile ) ; if ( show_logs ) logger . v ( tag , _str + currentplayerisactive ) ; if ( currentplayerisactive ) { if ( isinplaybackstate ( ) && isalreadyplayingthefile ) { if ( show_logs ) logger . v ( tag , _str + videoplayerview + _str + mcurrentplayerstate ) ; } else { startnewplayback ( currentitemmetadata , videoplayerview , videourl ) ; } } else { startnewplayback ( currentitemmetadata , videoplayerview , videourl ) ; } mplayerhandler . resumequeueprocessing ( tag ) ; if ( show_logs ) logger . v ( tag , _str + videoplayerview + _str + videourl ) ; }	call it if you have direct url or path to video source the logic is following : 1.
private void addtraceandtype ( string name ) { if ( tracestype . get ( name ) == null ) { traces . add ( createtrace ( name , tracetype . real ) ) ; tracestype . put ( name , tracetype . real ) ; } else { traces . add ( createtrace ( name , tracestype . get ( name ) ) ) ; } }	add a trace for a statistic of the given name.
public static boolean isreservedstreamname ( string name ) { return name . startswith ( _str ) ; }	is it a reserved stream name in bkdl namespace ?.
public static volumemount [ ] formatoriginalcontainervolumemount ( logdraft logdraft ) { list < volumemount > volumemounts = new arraylist < > ( ) ; int idxsuffix = _num ; for ( logitemdraft logitemdraft : logdraft . getlogitemdrafts ( ) ) { if ( logitemdraft . isautocollect ( ) || logitemdraft . isautodelete ( ) ) { volumemount volumemount = new volumemount ( ) ; volumemount . setname ( _str + idxsuffix ) ; volumemount . setmountpath ( logitemdraft . getlogparentpath ( logitemdraft . getlogpath ( ) ) ) ; volumemounts . add ( volumemount ) ; idxsuffix ++ ; } } return volumemounts . toarray ( new volumemount [ ] { } ) ; }	if a container sets log path , then we need to mount the log path so that the flume container can access the log file.
public static double dnorm ( double x ) { return math . exp ( - x * x / _num ) * psi ; }	returns the density of the standard normal .
public static long checksumcrc32 ( file file ) throws ioexception { crc32 crc = new crc32 ( ) ; checksum ( file , crc ) ; return crc . getvalue ( ) ; }	computes the checksum of a file using the crc32 checksum routine.
private void cmd_annotatedifference ( ) { bigdecimal previousvalue , actualvalue , difference ; previousvalue = ( bigdecimal ) v_previousbalance . getvalue ( ) ; actualvalue = ( bigdecimal ) v_actualbalance . getvalue ( ) ; difference = actualvalue . subtract ( previousvalue ) ; mcashbook cashbook = new mcashbook ( p_ctx , p_pos . getc_cashbook_id ( ) , null ) ; timestamp today = timeutil . getday ( system . currenttimemillis ( ) ) ; mcash cash = mcash . get ( p_ctx , cashbook . getc_cashbook_id ( ) , today , null ) ; if ( cash != null && cash . get_id ( ) != _num && difference . compareto ( cash . getstatementdifference ( ) ) != _num ) { mcashline cl = new mcashline ( cash ) ; cl . setcashtype ( mcashline . cashtype_difference ) ; cl . setamount ( difference ) ; cl . setdescription ( msg . translate ( p_pos . getctx ( ) , _str ) + previousvalue + _str + actualvalue ) ; cl . saveex ( ) ; } cash = mcash . get ( p_pos . getctx ( ) , p_pos . getc_cashbook_id ( ) , today , null ) ; v_previousbalance . setvalue ( cash . getendingbalance ( ) ) ; v_actualbalance . setvalue ( env . zero ) ; v_difference . setvalue ( env . zero ) ; }	annotate the difference between previous balance and actual from cash scrutiny in the cash book.
public void write ( outputstream out , java . util . list < figure > figures ) throws ioexception { rectangle2d . double drawingrect = null ; for ( figure f : figures ) { if ( drawingrect == null ) { drawingrect = f . getbounds ( ) ; } else { drawingrect . add ( f . getbounds ( ) ) ; } } affinetransform tx = new affinetransform ( ) ; tx . translate ( - math . min ( _num , drawingrect . x ) , - math . min ( _num , drawingrect . y ) ) ; write ( out , figures , tx , new dimension ( ( int ) ( math . abs ( drawingrect . x ) + drawingrect . width ) , ( int ) ( math . abs ( drawingrect . y ) + drawingrect . height ) ) ) ; }	all other write methods delegate their work to here .
fixedallocator ( final rwstore store , final int size ) { m_diskaddr = _num ; m_store = store ; m_size = size ; m_bitsize = calcbitsize ( _bool , size , cminallocation , cmodallocation ) ; allocblockrange = _num * m_bitsize ; final int numblocks = _num / ( m_bitsize + _num ) ; m_allocblocks = new arraylist < allocblock > ( numblocks ) ; for ( int i = _num ; i < numblocks ; i ++ ) { m_allocblocks . add ( new allocblock ( _num , m_bitsize , this ) ) ; } m_freetransients = _num ; m_freebits = _num * m_bitsize * numblocks ; }	calculating the number of ints ( m_bitsize ) cannot rely on a power of 2.
private void buildgetstorageresponse ( mockcloseablehttpresponse response , uri uri ) throws jaxbexception { pattern pattern = pattern . compile ( _str ) ; matcher matcher = pattern . matcher ( uri . getpath ( ) ) ; if ( matcher . find ( ) ) { storage storage = getnewstorage ( matcher . group ( _num ) ) ; response . setentity ( gethttpentity ( storage ) ) ; } }	builds a get storage response .
public void assertequals ( string assertid , string expected , string actual ) { framework . assertequals ( this , assertid , expected , actual ) ; }	asserts that expected . equals ( actual ) is true.
public boolean onpreferencechange ( preference preference , object newvalue ) { if ( boolean . parseboolean ( systemproperties . get ( telephonyproperties . property_inecm_mode ) ) ) { } else { setairplanemodeon ( ( boolean ) newvalue ) ; } return _bool ; }	called when someone clicks on the checkbox preference .
public static int estimatebandpassorder ( int samplerate , int passbandstart , int passbandend , double passbandrippledb , double stopbandrippledb ) { double df = ( double ) math . abs ( passbandend - passbandstart ) / ( double ) samplerate ; double ddp = ( double ) math . log10 ( passbandrippledb ) ; double dds = ( double ) math . log10 ( stopbandrippledb ) ; double a1 = _num ; double a2 = _num ; double a3 = - _num ; double a4 = _num ; double a5 = - _num ; double a6 = - _num ; double t1 = a1 * ddp * ddp ; double t2 = a2 * ddp ; double t3 = a4 * ddp * ddp ; double t4 = a5 * ddp ; double cinf = dds * ( t1 + t2 + a3 ) + t3 + t4 + a6 ; double ginf = - _num * ( double ) math . log10 ( passbandrippledb / stopbandrippledb ) - _num ; double n = cinf / df + ginf * df + _num ; return ( int ) math . ceil ( n ) ; }	estimates band pass filter length ;.
static public object stringtovalue ( string s ) { if ( s . equals ( _str ) ) { return s ; } if ( s . equalsignorecase ( _str ) ) { return boolean . true ; } if ( s . equalsignorecase ( _str ) ) { return boolean . false ; } if ( s . equalsignorecase ( _str ) ) { return jsonobject . null ; } char b = s . charat ( _num ) ; if ( ( b >= _str && b <= _str ) || b == _str || b == _str || b == _str ) { if ( b == _str && s . length ( ) > _num && ( s . charat ( _num ) == _str || s . charat ( _num ) == _str ) ) { try { return new integer ( integer . parseint ( s . substring ( _num ) , _num ) ) ; } catch ( exception ignore ) { } } try { if ( s . indexof ( _str ) > - _num || s . indexof ( _str ) > - _num || s . indexof ( _str ) > - _num ) { return double . valueof ( s ) ; } else { long mylong = new long ( s ) ; if ( mylong . longvalue ( ) == mylong . intvalue ( ) ) { return new integer ( mylong . intvalue ( ) ) ; } else { return mylong ; } } } catch ( exception ignore ) { } } return s ; }	try to convert a string into a number , boolean , or null.
private float [ ] calcbordervalues ( ) { float max = integer . min_value ; float min = integer . max_value ; for ( chartset set : chartview . data ) { for ( chartentry e : set . getentries ( ) ) { if ( e . getvalue ( ) >= max ) max = e . getvalue ( ) ; if ( e . getvalue ( ) <= min ) min = e . getvalue ( ) ; } } return new float [ ] { min , max } ; }	calculates the min / max value .
public static object applyorcall ( boolean isapply , context cx , scriptable scope , scriptable thisobj , object [ ] args ) { int l = args . length ; callable function = getcallable ( thisobj ) ; scriptable callthis = null ; if ( l != _num ) { callthis = toobjectornull ( cx , args [ _num ] ) ; } if ( callthis == null ) { callthis = gettopcallscope ( cx ) ; } object [ ] callargs ; if ( isapply ) { callargs = l <= _num ? scriptruntime . emptyargs : getapplyarguments ( cx , args [ _num ] ) ; } else { if ( l <= _num ) { callargs = scriptruntime . emptyargs ; } else { callargs = new object [ l - _num ] ; system . arraycopy ( args , _num , callargs , _num , l - _num ) ; } } return function . call ( cx , scope , callthis , callargs ) ; }	function . prototype . apply and function . prototype . call see ecma 15 . 3 . 4 . [ 34 ].
public static void removeallchildren ( node node ) { nodelist children = node . getchildnodes ( ) ; for ( int i = _num , length = children . getlength ( ) ; i < length ; i ++ ) { node . removechild ( children . item ( i ) ) ; } }	removes all children nodes from the specified node .
private void addunittoexternalqualmap ( final class < ? extends annotation > annoclass ) { annotationmirror mirror = unitsrelationstools . buildannomirrorwithnoprefix ( processingenv , annoclass ) ; if ( ! isaliasedannotation ( mirror ) ) { string unitclassname = annoclass . getcanonicalname ( ) ; if ( ! externalqualsmap . containskey ( unitclassname ) ) { externalqualsmap . put ( unitclassname , annoclass ) ; } } else { class < ? extends annotation > baseunitclass = getbaseunitannoclass ( mirror ) ; if ( baseunitclass != null ) { string baseunitclassname = baseunitclass . getcanonicalname ( ) ; if ( ! externalqualsmap . containskey ( baseunitclassname ) ) { loadexternalunit ( baseunitclassname ) ; } aliasedannotation ( mirror ) ; } else { } } addunitsrelations ( annoclass ) ; }	adds the annotation class to the external qualifier map if it is not an alias annotation .
@ override protected void onprogressupdate ( integer ... values ) { if ( parent != null ) { if ( values [ _num ] == on_cache_end ) { parent . oncacheend ( ) ; } else if ( values [ _num ] == on_cache_interrupted ) { log . i ( tag , _str ) ; shouldbestopped = _bool ; parent . oncacheinterrupted ( ) ; } else { parent . oncacheprogress ( taskcount , values [ _num ] ) ; } } }	calls the parent method to update the progress - bar in the ui while articles are refreshed .
public double dotproduct ( doublevector v ) { return x * v . x + y * v . y + z * v . z ; }	calculates the dot product ( or " scalar product " ) of this vector with the vector v .
public temporalomscalingicon ( object id , int rendertype , boolean interpolate , imageicon ii ) { this ( id , rendertype , interpolate , ii . getimage ( ) , _num ) ; setmaxscale ( _num ) ; setminscale ( _num ) ; }	create an scaling icon that will be moved around .
@ override public void characters ( char [ ] ch , int start , int length ) throws saxexception { mstringbuilder . append ( ch , start , length ) ; }	overrides org . xml . sax . helpers . defaulthandler # characters ( char [ ] , int , int ).
public int maxlength ( ) { if ( mispaired ) { return ( int ) math . max ( mleft . maxlength ( ) , mright . maxlength ( ) ) ; } else { return ( int ) msingle . maxlength ( ) ; } }	convenience method for getting the maximum sequence length.
public boolean equalsignorecase ( strbuilder other ) { if ( this == other ) { return _bool ; } if ( this . size != other . size ) { return _bool ; } char thisbuf [ ] = this . buffer ; char otherbuf [ ] = other . buffer ; for ( int i = size - _num ; i >= _num ; i -- ) { char c1 = thisbuf [ i ] ; char c2 = otherbuf [ i ] ; if ( c1 != c2 && character . touppercase ( c1 ) != character . touppercase ( c2 ) ) { return _bool ; } } return _bool ; }	checks the contents of this builder against another to see if they contain the same character content ignoring case .
public pathparser ( string pathstring ) { this . pathstring = pathstring . tochararray ( ) ; }	create a path parser for the given path string .
public luatable ( varargs varargs , int firstarg ) { int nskip = firstarg - _num ; int n = math . max ( varargs . narg ( ) - nskip , _num ) ; presize ( n , _num ) ; set ( n , valueof ( n ) ) ; for ( int i = _num ; i <= n ; i ++ ) set ( i , varargs . arg ( i + nskip ) ) ; }	construct table of unnamed elements .
public id3v24frame ( bytebuffer bytebuffer , string loggingfilename ) throws invalidframeexception , invaliddatatypeexception { setloggingfilename ( loggingfilename ) ; read ( bytebuffer ) ; }	creates a new id3v24frame datatype by reading from bytebuffer .
public void disablepan ( bluetoothadapter adapter ) { if ( mpan == null ) mpan = ( bluetoothpan ) connectproxy ( adapter , bluetoothprofile . pan ) ; assertnotnull ( mpan ) ; long start = system . currenttimemillis ( ) ; mpan . setbluetoothtethering ( _bool ) ; long stop = system . currenttimemillis ( ) ; assertfalse ( mpan . istetheringon ( ) ) ; writeoutput ( string . format ( _str , ( stop - start ) ) ) ; }	disables pan tethering on the local device and checks to make sure that tethering is disabled .
public frame < v > init ( final frame < ? extends v > src ) { returnvalue = src . returnvalue ; system . arraycopy ( src . values , _num , values , _num , values . length ) ; top = src . top ; return this ; }	copies the state of the given frame into this frame .
public boolean ready ( ) throws ioexception { if ( _input == null ) throw new ioexception ( _str ) ; if ( _index == _input . length ( ) ) return _bool ; return _bool ; }	indicates if this stream is ready to be read .
protected void handlematch ( t mapping , string lookuppath , serverwebexchange exchange ) { }	invoked when a matching mapping is found .
public boolean isusessl ( ) { return usessl ; }	returns true if this server requires encrypted connections .
public void start ( ) { if ( ( mproxsensor == null ) || misactive ) { return ; } misactive = _bool ; mshoulddropevents = _bool ; msensormanager . registerlistener ( mlistener , mproxsensor , sensormanager . sensor_delay_ui ) ; logutils . log ( this , log . verbose , _str , system . currenttimemillis ( ) ) ; mhandler . postdelayed ( mfilterrunnable , registration_event_filter_timeout ) ; }	starts listening for sensor events .
public void testentitydeclarations ( ) { assertnotnull ( _str , sp ) ; }	android ' s parsed dom doesn ' t include entity declarations.
@ nullable private tcpdiscoverynode resolvecoordinator ( @ nullable collection < tcpdiscoverynode > filter ) { synchronized ( mux ) { collection < tcpdiscoverynode > excluded = f . concat ( _bool , failednodes . keyset ( ) , leavingnodes ) ; if ( ! f . isempty ( filter ) ) excluded = f . concat ( _bool , excluded , filter ) ; return ring . coordinator ( excluded ) ; } }	resolves coordinator . nodes that are leaving or failed ( but are still in topology ) are removed from search as well as provided filter .
public static string [ ] splitc ( string src , string d ) { if ( ( d . length ( ) == _num ) || ( src . length ( ) == _num ) ) { return new string [ ] { src } ; } return splitc ( src , d . tochararray ( ) ) ; }	splits a string in several parts ( tokens ) that are separated by delimiter characters.
public int deflatestring2bytearray ( byte [ ] input , int inputoffset , int inputlength , byte [ ] bytes ) { if ( inputlength >= min_size_for_deflation ) { deflater . setinput ( input , inputoffset , inputlength ) ; deflater . finish ( ) ; int compresseddatalength = deflater . deflate ( bytes ) ; deflater . reset ( ) ; return - compresseddatalength ; } else { system . arraycopy ( input , inputoffset , bytes , _num , inputlength ) ; return inputlength ; } }	compresses a string to an array of bytes.
public marker backto ( int idx ) throws amconsoleexception { int size = trail . size ( ) ; if ( idx >= size ) { throw new amconsoleexception ( _str ) ; } for ( int i = size - _num ; i > idx ; -- i ) { trail . remove ( i ) ; } return ( marker ) trail . get ( idx ) ; }	discards items from a given index ( exclusive ) to the end .
private static long copy ( inputstream source , outputstream sink ) throws ioexception { long nread = _num ; byte [ ] buf = new byte [ buffer_size ] ; int n ; while ( ( n = source . read ( buf ) ) > _num ) { sink . write ( buf , _num , n ) ; nread += n ; } return nread ; }	reads all bytes from an input stream and writes them to an output stream .
public byte [ ] pack ( ) { if ( entries . size ( ) == _num ) return null ; int entrylength = owner . gettype ( ) . nodes_entry_length ; byte [ ] buffer = new byte [ entries . size ( ) * entrylength ] ; int max_items = buffer . length / _num ; int j = _num ; for ( kbucketentry e : entries ) { if ( j >= max_items ) { break ; } packutil . packbucketentry ( e , buffer , j * entrylength , owner . gettype ( ) ) ; j ++ ; } return buffer ; }	packs the results in a byte array .
public string tostring ( ) { stringbuffer sb = new stringbuffer ( _str ) ; for ( int i = _num ; i < permissions . length ; i ++ ) { if ( i > _num ) { sb . append ( _str ) ; } sb . append ( permissions [ i ] ) ; } sb . append ( _str ) ; return sb . tostring ( ) ; }	returns a string representation of this object .
public void testinvalidafterclose ( ) throws ioexception { path temppath = createtempdir ( ) ; directory dir = getdirectory ( temppath ) ; lock l = dir . obtainlock ( _str ) ; l . close ( ) ; expectthrows ( alreadyclosedexception . class , null ) ; dir . close ( ) ; }	test ensurevalid throws exception after close.
public static gdstyperule excludes ( string ... excludedtypes ) { final set < string > excludedtypesset = new hashset < > ( arrays . aslist ( excludedtypes ) ) ; return new gdstyperule ( not ( isin ( excludedtypesset ) ) ) ; }	creates an instance with a list of excluded test types .
public final set < string > aliases ( ) { if ( aliasset != null ) return aliasset ; int n = aliases . length ; hashset < string > hs = new hashset < string > ( n ) ; for ( int i = _num ; i < n ; i ++ ) hs . add ( aliases [ i ] ) ; aliasset = collections . unmodifiableset ( hs ) ; return aliasset ; }	returns a set containing this charset ' s aliases .
public synchronized void unweave ( bytestring id ) { if ( woven . containskey ( id ) ) { removed . add ( woven . remove ( id ) ) ; } }	remove the indicated weave on next installation.
private static map < string , virtualfile > findsiblings ( @ nullable virtualfile directory , project project , set < virtualfile > seen ) { if ( directory == null ) { return collections . emptymap ( ) ; } else { if ( seen . contains ( directory ) ) { return findsiblings ( null , project , seen ) ; } seen . add ( directory ) ; virtualfile settings = directory . findchild ( sdkconstants . fn_settings_gradle ) ; if ( settings == null ) { return findsiblings ( directory . getparent ( ) , project , seen ) ; } else { return gradlemoduleimporter . getsubprojects ( settings , project ) ; } } }	recursively go up the file system tree to find parent project with settings.
@ override public int hashcode ( ) { return arrays . hashcode ( new immutablepair [ ] { ( immutablepair ) first , ( immutablepair ) second } ) ; }	returns a hash code value for this object .
@ suppresslint ( _str ) public static string replaceunicodedigits ( string number ) { stringbuilder normalizeddigits = new stringbuilder ( number . length ( ) ) ; for ( char c : number . tochararray ( ) ) { int digit = character . digit ( c , _num ) ; if ( digit != - _num ) { normalizeddigits . append ( digit ) ; } else { normalizeddigits . append ( c ) ; } } return normalizeddigits . tostring ( ) ; }	replace arabic / unicode digits with decimal digits .
public string frie_name ( string value ) { if ( value == null || value . length ( ) == _num ) return _str ; string retvalue = value ; string sql = _str ; try { preparedstatement pstmt = db . preparestatement ( sql , null ) ; pstmt . setstring ( _num , value ) ; resultset rs = pstmt . executequery ( ) ; if ( rs . next ( ) ) retvalue = rs . getstring ( _num ) ; rs . close ( ) ; pstmt . close ( ) ; } catch ( sqlexception e ) { log . log ( level . severe , sql , e ) ; } return retvalue ; }	frie value - convert to standardized name.
public static boolean iscompressed ( file file ) { inputstream fis = null ; try { if ( file . exists ( ) ) { fis = new fileinputstream ( file ) ; int mag1 = fis . read ( ) ; int mag2 = fis . read ( ) ; fis . close ( ) ; return selectcompressionprovider ( mag1 , mag2 ) != null ; } } catch ( ioexception e ) { log . log ( level . finest , _str + file + _str , e ) ; return _bool ; } finally { safeclose . close ( fis ) ; } return _bool ; }	is a file compressed ? ( the magic number in the first 2 bytes is used to detect the compression .
@ override public int readint ( string filepath ) { filechannel filechannel = updatecache ( filepath ) ; bytebuffer bytebffer = read ( filechannel , carboncommonconstants . int_size_in_byte ) ; return bytebffer . getint ( ) ; }	this method will be used to read int from file from postion ( offset ) , here length will be always 4 bacause int byte size if 4.
private synchronized void closeoutputstreamquietly ( ) { if ( ! mclosed ) { try { moutputstream . close ( ) ; reportdecodedsizeifapplicable ( ) ; } catch ( ioexception e ) { clog . writetoconsole ( mnetworkpeermanager , console . messagelevel . error , console . messagesource . network , _str + e ) ; } finally { mclosed = _bool ; } } }	attempts to close all the output stream , and swallows any exceptions .
public void bind ( string address , servicerefamp linkservice ) { _linkservicemap . put ( address , linkservice ) ; _servicecloselist . add ( linkservice ) ; }	adds a new link actor .
public boolean mighthavemultifontmetrics ( ) { return fontconfig != null ; }	is it possible that this font ' s metrics require the multi - font calls ? this might be true , for example , if the font supports kerning .
private static boolean checkoffset ( string value , int offset , char expected ) { return ( offset < value . length ( ) ) && ( value . charat ( offset ) == expected ) ; }	check if the expected character exist at the given offset in the value .
void addsplit ( string splitpath ) { string [ ] splits = splitpath . split ( _str ) ; for ( string split : splits ) { split = split . trim ( ) ; if ( split . startswith ( _str ) ) throw new runtimeexception ( _str + split ) ; if ( split . length ( ) == _num ) continue ; addfield ( split , split , _bool , _bool ) ; } }	a ' | ' separated list of path expressions which define sub sections of the json stream that are to be emitted as separate records . it is possible to have multiple levels of split one for parent and one for child each child record ( or a list of records ) will be emitted as a part of the parent record with null as the key.
public void sortarray ( t [ ] d , comparator < t > c ) { this . data = d ; this . comp = c ; int len = math . max ( ( int ) ( _num * math . log ( d . length ) ) , temp_size ) ; len = math . min ( d . length , len ) ; @ suppresswarnings ( _str ) t [ ] t = ( t [ ] ) new object [ len ] ; this . temp = t ; mergesort ( _num , d . length - _num ) ; }	sort an array using the given comparator .
public void cacheunit ( unitinterface unit ) { allunits . add ( unit ) ; }	add new unit to cache.
public component findbyname ( string name , component rootcomponent ) { component c = ( component ) rootcomponent . getclientproperty ( _str + name + _str ) ; if ( c == null ) { container newroot = getrootancestor ( rootcomponent ) ; if ( newroot != null && rootcomponent != newroot ) { return findbyname ( name , newroot ) ; } } return c ; }	finds the given component by its name.
protected void fetchmetadata ( ) throws ioexception { remaining = period ; int size = in . read ( ) ; if ( size < _num ) return ; size <<= _num ; if ( mbuffer . length < size ) { mbuffer = null ; mbuffer = new byte [ size ] ; log . d ( log , _str + size + _str ) ; } size = readfully ( mbuffer , _num , size ) ; for ( int i = _num ; i < size ; i ++ ) { if ( mbuffer [ i ] == _num ) { size = i ; break ; } } string s ; try { s = new string ( mbuffer , _num , size , characterencoding ) ; } catch ( exception e ) { log . e ( log , _str ) ; return ; } log . d ( log , _str + s ) ; parsemetadata ( s ) ; }	this method reads the metadata string.
public void startelement ( ) { nss . pushcontext ( ) ; incollectingmode = _bool ; }	sets the current bindings aside and starts a new element context.
public final void removehelpertext ( @ nonnull final charsequence helpertext ) { ensurenotnull ( helpertext , _str ) ; ensurenotempty ( helpertext , _str ) ; helpertexts . remove ( helpertext ) ; verifypasswordstrength ( ) ; }	removes a specific helper text , which should not be shown , depending on the password strength , anymore .
public final synchronized int maxpv ( ) { if ( computerplayer == null ) return _num ; return computerplayer . getmaxpv ( ) ; }	return maximum number of pvs supported by engine .
public object remove ( int index ) { rangecheck ( index ) ; modcount ++ ; object oldvalue = elementdata [ index ] ; int nummoved = size - index - _num ; if ( nummoved > _num ) system . arraycopy ( elementdata , index + _num , elementdata , index , nummoved ) ; elementdata [ -- size ] = null ; return oldvalue ; }	removes the element at the specified position in this list.
public string readmatchingflags ( string text ) { clear ( ) ; if ( text . startswith ( pm_separator ) ) { final stringtokenizer tok = new stringtokenizer ( text , pm_separator ) ; while ( tok . hasmoretokens ( ) ) { final string flag = tok . nexttoken ( ) ; if ( flag . equals ( pm_type_match ) ) { typematching = _bool ; } else if ( flag . equals ( pm_exact_match ) ) { exactmatching = _bool ; } else if ( flag . equals ( pm_similar_match ) ) { similarmatching = _bool ; } else if ( flag . equals ( pm_icase_match ) ) { caseinsensitive = _bool ; } else if ( flag . equals ( pm_joker_match ) ) { jokermatching = _bool ; } else { break ; } text = text . substring ( flag . length ( ) + _num ) ; } if ( isanyflagset ( ) ) { text = text . substring ( _num ) ; } } return text ; }	read leading matching flags from the given text string and return the remaining text .
private tinyplanetimage createfinaltinyplanet ( ) { mresultlock . lock ( ) ; try { mresultbitmap . recycle ( ) ; mresultbitmap = null ; msourcebitmap . recycle ( ) ; msourcebitmap = null ; } finally { mresultlock . unlock ( ) ; } bitmap sourcebitmap = createpaddedsourceimage ( msourceimageuri , _bool ) ; int width = sourcebitmap . getwidth ( ) ; int height = sourcebitmap . getheight ( ) ; int outputsize = width / _num ; bitmap resultbitmap = bitmap . createbitmap ( outputsize , outputsize , bitmap . config . argb_8888 ) ; tinyplanetnative . process ( sourcebitmap , width , height , resultbitmap , outputsize , mcurrentzoom , mcurrentangle ) ; sourcebitmap . recycle ( ) ; sourcebitmap = null ; bytearrayoutputstream jpeg = new bytearrayoutputstream ( ) ; resultbitmap . compress ( compressformat . jpeg , _num , jpeg ) ; return new tinyplanetimage ( addexif ( jpeg . tobytearray ( ) ) , outputsize ) ; }	creates the high quality tiny planet file and adds it to the media service.
private static int newfloatarray ( jnienvironment env , int length ) { if ( tracejni ) vm . syswrite ( _str ) ; runtimeentrypoints . checkjnicountdowntogc ( ) ; try { float [ ] newarray = new float [ length ] ; return env . pushjniref ( newarray ) ; } catch ( throwable unexpected ) { if ( tracejni ) unexpected . printstacktrace ( system . err ) ; env . recordexception ( unexpected ) ; return _num ; } }	newfloatarray : create a new float array.
static int createshader ( string resource , int type ) throws ioexception { return createshader ( resource , type , null ) ; }	create a shader object from the given classpath resource .
public model validatenodeagainstshape ( dataset dataset , uri shapesgraphuri , node focusnode , node shape , resource minseverity , predicate < shconstraint > constraintfilter , function < rdfnode , string > labelfunction , progressmonitor monitor ) { model results = jenautil . creatememorymodel ( ) ; model oldresults = getcurrentresultsmodel ( ) ; setcurrentresultsmodel ( results ) ; addresourceviolations ( dataset , shapesgraphuri , focusnode , shape , shaclutil . getallconstraintproperties ( _bool ) , minseverity , constraintfilter , results , labelfunction , monitor ) ; setcurrentresultsmodel ( oldresults ) ; return results ; }	validates a given resource against a given shape .
@ override public volatileimage createbackbuffer ( wcomponentpeer peer ) { component target = ( component ) peer . gettarget ( ) ; return new sunvolatileimage ( target , target . getwidth ( ) , target . getheight ( ) , boolean . true ) ; }	creates a wgl - based backbuffer for the given peer and returns the image wrapper .
public void test_singleresourcelocking_highconcurrency100 ( ) throws exception { properties properties = new properties ( ) ; properties . setproperty ( testoptions . nthreads , _str ) ; properties . setproperty ( testoptions . ntasks , _str ) ; properties . setproperty ( testoptions . nresources , _str ) ; properties . setproperty ( testoptions . min_locks , _str ) ; properties . setproperty ( testoptions . max_locks , _str ) ; properties . setproperty ( testoptions . predeclare_locks , _str ) ; properties . setproperty ( testoptions . sort_lock_requests , _str ) ; docomparisontest ( properties ) ; }	test where each operation locks only a single resource ( high concurrency ) .
public void push ( final double value ) { long bits = double . doubletolongbits ( value ) ; if ( bits == _num || bits == _num ) { mv . visitinsn ( opcodes . dconst_0 + ( int ) value ) ; } else { mv . visitldcinsn ( value ) ; } }	generates the instruction to push the given value on the stack .
protected abstract void assignresourcerequests ( ) ;	assign resources from the cluster manager and matches them to run container processes on them .
public synchronized void add ( int position , abstractoption option ) { abstractoption search = getbyname ( option . getname ( ) ) ; if ( search != null ) { log . warn ( _str ) ; } else { list < abstractoption > oldoptions = new arraylist < abstractoption > ( options ) ; options . add ( position , option ) ; option . setcollection ( this ) ; list < abstractoption > newoptions = getoptions ( ) ; fireindexedpropertychange ( prop_options , position , oldoptions , newoptions ) ; } }	adds an abstractoption to the container at a specified position.
public boolean visitingmethod ( ) { return visitingmethod ; }	is the visitor currently visiting a method ?.
protected bytearrayoutputstream parsebytes ( bytearrayoutputstream bos ) throws ioexception { int ch ; for ( ch = read ( ) ; ch >= _num && ch != _str ; ch = read ( ) ) { int b1 = ch ; int b2 = read ( ) ; int b3 = read ( ) ; int b4 = read ( ) ; if ( b4 != _str ) { int chunk = ( ( base64decode [ b1 ] << _num ) + ( base64decode [ b2 ] << _num ) + ( base64decode [ b3 ] << _num ) + ( base64decode [ b4 ] ) ) ; bos . write ( chunk > > _num ) ; bos . write ( chunk > > _num ) ; bos . write ( chunk ) ; } else if ( b3 != _str ) { int chunk = ( ( base64decode [ b1 ] << _num ) + ( base64decode [ b2 ] << _num ) + ( base64decode [ b3 ] ) ) ; bos . write ( chunk > > _num ) ; bos . write ( chunk ) ; } else { int chunk = ( ( base64decode [ b1 ] << _num ) + ( base64decode [ b2 ] ) ) ; bos . write ( chunk ) ; } } if ( ch == _str ) peek = ch ; return bos ; }	parses a byte array .
public static void startuploadactivityforresult ( activity activity , account account , int requestcode ) { intent action = new intent ( activity , uploadfilesactivity . class ) ; action . putextra ( extra_account , ( account ) ) ; activity . startactivityforresult ( action , requestcode ) ; }	helper to launch the uploadfilesactivity for which you would like a result when it finished.
public void stoptracesession ( int tracesessionid ) throws sqlexception { try ( fbservice service = attachservicemanager ( ) ) { service . startserviceaction ( gettracespb ( service , isc_action_svc_trace_stop , tracesessionid ) ) ; queueservice ( service ) ; } catch ( ioexception ioe ) { throw new sqlexception ( ioe ) ; } }	stops a trace session with the given trace session id.
string readsubstring ( string source , int ofs ) { return readsubstring ( source , ofs , source . length ( ) ) ; }	read an substring from source .
private synchronized boolean expungestaleentries ( ) { if ( this . size == _num ) return _bool ; object r ; boolean result = _bool ; while ( ( r = queue . poll ( ) ) != null ) { result = _bool ; singleentry e = ( singleentry ) r ; this . size -= e . cleanuppktable ( this . table ) ; this . nondatedentrycount -= e . cleanupsemiuniquetable ( this . nondatedtable ) ; } return result ; }	expunge stale entries from the nondatedtable .
public void removelistener ( abstractserialtransportlistener listener ) { if ( listener != null ) { listeners . remove ( listener ) ; } }	removes a listener from the event callback chain.
private string restorenbttags ( string str , arraylist < string > nbttags ) { int nbtidx = _num ; for ( string capture : nbttags ) { str = str . replace ( _str + nbtidx ++ , capture ) ; } return str ; }	and the reverse , restore the glorious nbt tags into a string loaded with their placeholders.
private void drawoffsets ( final graphics g ) { if ( isenabled ( ) ) { g . setcolor ( m_fontcoloroffsets ) ; } else { g . setcolor ( m_disabledcolor != m_bgcoloroffset ? m_disabledcolor : color . white ) ; } final int x = ( - m_firstcolumn * m_charwidth ) + _num ; final int bytestodraw = getmaximumvisiblebytes ( ) ; final string formatstring = m_addressmode == addressmode . bit32 ? _str : _str ; for ( int i = _num ; i < bytestodraw ; i += m_bytesperrow ) { final long address = m_baseaddress + ( m_firstrow * m_bytesperrow ) + i ; final string offsetstring = string . format ( formatstring , address ) ; final int currentrow = i / m_bytesperrow ; g . drawstring ( offsetstring , x , m_paddingtop + ( currentrow * m_rowheight ) ) ; } }	draws the offsets in the offset view .
public void touch ( date date ) { lastseen = ( date ) date . clone ( ) ; }	set the time this peer was last seen to the given datetime .
public void testpolyline ( ) throws exception { esrilayer layer = new esrilayer ( _str , shape_type_polyline , _num ) ; dbftablemodel model = layer . getmodel ( ) ; model . setdecimalcount ( _num , ( byte ) _num ) ; model . setlength ( _num , ( byte ) _num ) ; model . setcolumnname ( _num , _str ) ; model . settype ( _num , ( byte ) dbftablemodel . type_character ) ; model . setdecimalcount ( _num , ( byte ) _num ) ; model . setlength ( _num , ( byte ) _num ) ; model . setcolumnname ( _num , _str ) ; model . settype ( _num , ( byte ) dbftablemodel . type_numeric ) ; addpolylinerecord1 ( layer ) ; addpolylinerecord2 ( layer ) ; addpolylinerecord3 ( layer ) ; esrigraphiclist list = layer . getesrigraphiclist ( ) ; shpoutputstream pos = new shpoutputstream ( new fileoutputstream ( _str ) ) ; int [ ] [ ] indexdata = pos . writegeometry ( list ) ; shxoutputstream xos = new shxoutputstream ( new fileoutputstream ( _str ) ) ; xos . writeindex ( indexdata , list . gettype ( ) , list . getextents ( ) ) ; dbfoutputstream dos = new dbfoutputstream ( new fileoutputstream ( _str ) ) ; dos . writemodel ( model ) ; }	creates a polyline shape file set.
public static int random ( int i , int j ) { return i + ( int ) ( math . random ( ) * ( j - i ) ) ; }	return a random integer between i ( inclusive ) and j ( exclusive ) .
public void remove ( string name ) { featuremap . remove ( name ) ; }	removes the named feature from this set of features .
private list < columnmodel > findcolumnstoadd ( ) { list < columnmodel > columnstoadd = new arraylist < columnmodel > ( ) ; for ( columnmodel columnmodel : mtablemodel . getcolumnmodels ( ) ) { string columnname = columnmodel . getcolumnname ( ) ; if ( ! mtablemodeldb . containscolumn ( columnname ) ) { columnstoadd . add ( columnmodel ) ; } } return columnstoadd ; }	it will find the difference between class model and table model.
@ override public loader < cursor > oncreateloader ( int id , bundle args ) { uri uri = fmradiostation . station . content_uri ; string select = fmradiostation . station . column_station_type + _str ; string order = fmradiostation . station . column_station_type + _str + fmradiostation . station . column_station_freq ; cursorloader cursorloader = new cursorloader ( this , uri , fmradiostation . columns , select , new string [ ] { string . valueof ( fmradiostation . station_type_favorite ) , string . valueof ( fmradiostation . station_type_searched ) } , order ) ; return cursorloader ; }	create cursor loader to initial list view.
protected map < string , object > convertnamedlisttomap ( namedlist < ? > args ) { map < string , object > argsmap = new linkedhashmap < > ( ) ; if ( args != null ) { for ( map . entry < string , ? > entry : args ) { argsmap . put ( entry . getkey ( ) , entry . getvalue ( ) ) ; } } return argsmap ; }	converts a namedlist & lt ; ? & gt ; into an ordered map for returning as json .
@ override public boolean equals ( final object other ) { if ( this == other ) { return _bool ; } else if ( other == null ) { return _bool ; } else if ( other instanceof expressionmatcher ) { final expressionmatcher o = ( expressionmatcher ) other ; if ( typematching != o . typematching ) { return _bool ; } else if ( exactmatching != o . exactmatching ) { return _bool ; } else if ( similarmatching != o . similarmatching ) { return _bool ; } else if ( caseinsensitive != o . caseinsensitive ) { return _bool ; } else { return ( jokermatching == o . jokermatching ) ; } } else { return _bool ; } }	check for equality of two expressionmatcher objects .
public boolean hascapabilities ( list < string > capabilities ) { string [ ] arr = new string [ capabilities . size ( ) ] ; capabilities . toarray ( arr ) ; return hascapabilities ( arr ) ; }	test to see if the capabilities array contains a given set of capabilities.
public static void assignbucketstopartitions ( region < ? , ? > region ) { partitionedregion pr = ispartitionedcheck ( region ) ; recoverylock lock = null ; try { lock = pr . getrecoverylock ( ) ; lock . lock ( ) ; for ( int i = _num ; i < getnumberofbuckets ( pr ) ; i ++ ) { pr . createbucket ( i , _num , null ) ; } } finally { if ( lock != null ) { lock . unlock ( ) ; } } }	decide which partitions will host which buckets.
public synchronized void addlistener ( listener l ) { listeners . add ( l ) ; }	adds a listener to receive progress notifications .
public boolean endswith ( final string str ) { if ( str == null ) { return _bool ; } final int len = str . length ( ) ; if ( len == _num ) { return _bool ; } if ( len > size ) { return _bool ; } int pos = size - len ; for ( int i = _num ; i < len ; i ++ , pos ++ ) { if ( buffer [ pos ] != str . charat ( i ) ) { return _bool ; } } return _bool ; }	checks whether this builder ends with the specified string.
public void applypattern ( string pattern ) { this . pattern = pattern ; if ( patterntokens != null ) { patterntokens . clear ( ) ; patterntokens = null ; } }	apply a new pattern .
public int numberofreplies ( final resource comment ) { final iterator < resource > children = comment . listchildren ( ) ; int size = _num ; while ( children . hasnext ( ) ) { children . next ( ) ; size ++ ; } return size ; }	get the number of replies for a given comment .
public static < t > string tostring ( treedef < t > treedef , t root , function < ? super t , string > tostring , string indent ) { stringbuilder builder = new stringbuilder ( ) ; builder . append ( tostring . apply ( root ) ) ; builder . append ( _str ) ; tostringhelper ( treedef , root , tostring , indent , builder , indent ) ; return builder . tostring ( ) ; }	converts the entire tree into a string - based representation .
public void cleanupremotesessions ( ) { synchronized ( remotesessionset ) { for ( iterator iter = remotesessionset . iterator ( ) ; iter . hasnext ( ) ; ) { sessionid sessionid = ( sessionid ) iter . next ( ) ; string hostserver = null ; try { hostserver = getcurrenthostserver ( sessionid ) ; } catch ( exception ex ) { } if ( ! serverconfig . islocalserver ( hostserver ) ) { iter . remove ( ) ; } } } }	function to remove remote sessions when primary server is up .
public boolean columnexistscasesensitive ( databasemetadata dbmetadata , string tablename , string columnname ) throws sqlexception { resultset rstables = dbmetadata . getcolumns ( null , null , tablename , columnname ) ; try { return rstables . next ( ) ; } finally { closejdbcresultset ( rstables ) ; } }	checks database metadata to see if a column exists in a table.
public int read ( ) throws ioexception { if ( ! buf . hasremaining ( ) ) { return - _num ; } return buf . get ( ) & _num ; }	read an integer value from backed bytebuffer .
public void charactersraw ( char ch [ ] , int start , int length ) throws org . xml . sax . saxexception { if ( isoutsidedocelem ( ) && xmlcharacterrecognizer . iswhitespace ( ch , start , length ) ) return ; string s = new string ( ch , start , length ) ; append ( m_doc . createprocessinginstruction ( _str , _str ) ) ; append ( m_doc . createtextnode ( s ) ) ; }	if available , when the disable - output - escaping attribute is used , output raw text without escaping.
private void handlerelease ( ) { float speed = math . max ( draghelper . getdragspeed ( ) , animationspeed ) ; if ( gettopmargin ( ) > initialmargin || ( draghelper . getdragspeed ( ) > animationspeed && draghelper . getdistance ( ) > _num ) || ( getdevicetype ( getcontext ( ) ) == devicetype . tablet && ismaximized ( ) && gettopmargin ( ) > minmargin ) ) { animatehideview ( parentheight - gettopmargin ( ) , speed , new decelerateinterpolator ( ) , _bool ) ; } else { animateshowview ( - ( gettopmargin ( ) - minmargin ) , speed , new decelerateinterpolator ( ) ) ; } }	handles when a drag gesture has been ended by the user .
private string normalizetypevalue ( string type ) { if ( insert . equals ( type ) ) return insert ; if ( remove . equals ( type ) ) return remove ; return null ; }	computes the normalized type value to ensure that the implementation can use object identity rather than equality .
@ override public logseqnum writetolog ( ) { list < constant > rec = buildrecord ( ) ; return logmgr . append ( rec . toarray ( new constant [ rec . size ( ) ] ) ) ; }	writes a setval record to the log.
public static double gaussian ( ) { double r , x , y ; do { x = uniform ( - _num , _num ) ; y = uniform ( - _num , _num ) ; r = x * x + y * y ; } while ( r >= _num || r == _num ) ; return x * math . sqrt ( - _num * math . log ( r ) / r ) ; }	returns a random real number from a standard gaussian distribution .
public void donewithparameters ( ) { if ( info . parametercount == var_args ) { int len = varargs . size ( ) ; checkparametercount ( len ) ; args = new expression [ len ] ; varargs . toarray ( args ) ; varargs = null ; } else { int len = args . length ; if ( len > _num && args [ len - _num ] == null ) { throw dbexception . get ( errorcode . invalid_parameter_count_2 , info . name , _str + len ) ; } } }	this method is called after all the parameters have been set.
public void removeallx509certificates ( ) { x509certificates . clear ( ) ; }	removes all x509certificate ' s from this user.
public void updatecurrentstate ( string whathappened ) { undoevent undoevent = createundoeventforcurrentstate ( whathappened ) ; if ( undoevent != null && undostack != null ) { undostack . setthewaythingsare ( undoevent ) ; } }	called by anything that knows that the eomg has arrived at a stable state that should be kept for undo actions .
protected void extendelement ( element e ) { }	customizable method if you need to add anything more.
private string readresponsefromserver ( httpurlconnection urlconnection ) throws requestfailureexception { try { inputstreamreader reader = new inputstreamreader ( urlconnection . getinputstream ( ) ) ; bufferedreader in = new bufferedreader ( reader ) ; try { stringbuilder response = new stringbuilder ( ) ; for ( string line = in . readline ( ) ; line != null ; line = in . readline ( ) ) { response . append ( line ) ; } checkserverresponsecode ( urlconnection ) ; return response . tostring ( ) ; } finally { in . close ( ) ; } } catch ( ioexception e ) { throw new requestfailureexception ( _str , e ) ; } }	reads the response from the omaha server .
public boolean issupportedoption ( string name ) { boolean issupported = _bool ; for ( iterator i = mandatoryoptions . iterator ( ) ; i . hasnext ( ) && ! issupported ; ) { string opt = ( string ) i . next ( ) ; issupported = opt . equals ( name ) ; } for ( iterator i = optionaloptions . iterator ( ) ; i . hasnext ( ) && ! issupported ; ) { string opt = ( string ) i . next ( ) ; issupported = opt . equals ( name ) ; } return issupported ; }	returns < true > if the option is supported .
private boolean areallnodeended ( ) { if ( protocol != null && protocol . hasprotocol ( ) ) { final collection < protocolnode > protocolnodes = protocolnodeparticipantmap . values ( ) ; if ( protocolnodes . isempty ( ) ) { return _bool ; } for ( final protocolnode node : protocolnodes ) { if ( ! ( node != null && node . isterminal ( ) ) ) { return _bool ; } } return _bool ; } final collection < fipamessage > finalmsgs = noprotocolnodeparticipantmap . values ( ) ; if ( finalmsgs . isempty ( ) ) { return _bool ; } for ( final fipamessage finalmsg : finalmsgs ) { if ( finalmsg . getperformative ( ) != fipaconstants . performatives . end_conversation ) { return _bool ; } } return _bool ; }	are all node ended .
public stringbuilder encodebody ( stringbuilder retval ) { return retval . append ( optiontag ) ; }	encode in canonical form .
public void addliteralresultattribute ( avt avt ) { if ( null == m_avts ) m_avts = new arraylist ( ) ; m_avts . add ( avt ) ; }	set a literal result attribute ( avts only ) .
protected void moveselectiontofirstposition ( ) { if ( selectiontable . getselectioncount ( ) == _num ) { return ; } int index = _num ; for ( final tableitem tableitem : selectiontable . getselection ( ) ) { final dlitem item = ( dlitem ) tableitem . getdata ( ) ; selection . remove ( item ) ; selection . add ( index ++ , item ) ; } redrawtables ( ) ; selectiontable . select ( _num , index - _num ) ; selectiontable . forcefocus ( ) ; }	move the selected item to the first position.
private void itemsarraytocombinedbuffer ( t [ ] itemsarray ) { final int extra = _num ; minvalue_ = itemsarray [ _num ] ; maxvalue_ = itemsarray [ _num ] ; system . arraycopy ( itemsarray , extra , combinedbuffer_ , _num , basebuffercount_ ) ; long bits = bitpattern_ ; if ( bits > _num ) { int index = extra + basebuffercount_ ; for ( int level = _num ; bits != _num ; level ++ , bits >>>= _num ) { if ( ( bits & _num ) > _num ) { system . arraycopy ( itemsarray , index , combinedbuffer_ , ( _num + level ) * k_ , k_ ) ; index += k_ ; } } } }	loads the combined buffer , min and max from the given items array.
public sqlquery ( class < t > type , string sqlexpression , queryresulttype queryresulttype , object ... parameters ) { this ( sqlexpression , type . getname ( ) , null , queryresulttype , parameters ) ; }	creates a sqlquery using the specified type , expression , result type and parameters .
public void bob ( mowziemodelrenderer box , float speed , float degree , boolean bounce , float f , float f1 ) { float bob = ( float ) ( math . sin ( f * speed ) * f1 * degree - f1 * degree ) ; if ( bounce ) bob = ( float ) - math . abs ( ( math . sin ( f * speed ) * f1 * degree ) ) ; box . rotationpointy += bob ; }	moves a box up and down ( rotationpointy ).
private static void rejectunsupportedoptions ( properties p ) throws sqlfeaturenotsupportedexception { if ( p . containskey ( datasourcefactory . jdbc_role_name ) ) { throw new sqlfeaturenotsupportedexception ( _str + datasourcefactory . jdbc_role_name + _str ) ; } if ( p . containskey ( datasourcefactory . jdbc_datasource_name ) ) { throw new sqlfeaturenotsupportedexception ( _str + datasourcefactory . jdbc_datasource_name + _str ) ; } }	checker method that will throw if any unsupported standard osgi options is present .
private void decrementworkercount ( ) { do { } while ( ! compareanddecrementworkercount ( ctl . get ( ) ) ) ; }	decrements the workercount field of ctl.
public static float buildfloat ( int mant , int exp ) { if ( exp < - _num || mant == _num ) { return _num ; } if ( exp >= _num ) { return ( mant > _num ) ? float . positive_infinity : float . negative_infinity ; } if ( exp == _num ) { return mant ; } if ( mant >= ( _num << _num ) ) { mant ++ ; } return ( float ) ( ( exp > _num ) ? mant * pow10 [ exp ] : mant / pow10 [ - exp ] ) ; }	computes a float from mantissa and exponent .
public void clearvalues ( ) { mdatasets . clear ( ) ; notifydatachanged ( ) ; }	clears this data object from all datasets and removes all entries.
public boolean hasmodesupport ( ) { return isavailable ( ) && mcapabilities . intersects ( mallmodes ) ; }	checks if livedisplay has support for adaptive modes .
public void runtest ( ) throws throwable { document doc ; nodelist genderlist ; node gendernode ; entityreference entref ; element entelement ; characterdata entelementtext ; int nodetype ; doc = ( document ) load ( _str , _bool ) ; genderlist = doc . getelementsbytagname ( _str ) ; gendernode = genderlist . item ( _num ) ; entref = ( entityreference ) gendernode . getfirstchild ( ) ; assertnotnull ( _str , entref ) ; nodetype = ( int ) entref . getnodetype ( ) ; if ( equals ( _num , nodetype ) ) { entref = doc . createentityreference ( _str ) ; assertnotnull ( _str , entref ) ; } entelement = ( element ) entref . getfirstchild ( ) ; assertnotnull ( _str , entelement ) ; entelementtext = ( characterdata ) entelement . getfirstchild ( ) ; assertnotnull ( _str , entelementtext ) ; { boolean success = _bool ; try { entelementtext . setnodevalue ( _str ) ; } catch ( domexception ex ) { success = ( ex . code == domexception . no_modification_allowed_err ) ; } asserttrue ( _str , success ) ; } }	runs the test case .
public void testconstrstringwithexponentwithpoint2 ( ) { string a = _str ; int ascale = _num ; biginteger ba = new biginteger ( _str ) ; bigdecimal anumber = new bigdecimal ( a ) ; assertequals ( _str , ba , anumber . unscaledvalue ( ) ) ; assertequals ( _str , ascale , anumber . scale ( ) ) ; }	new bigdecimal ( string value ) ; value contains both exponent and decimal point.
public static void updateitemindatabase ( context context , final iteminfo item ) { final contentvalues values = new contentvalues ( ) ; item . onaddtodatabase ( context , values ) ; updateitemindatabasehelper ( context , values , item , _str ) ; }	update an item to the database in a specified container .
@ override public string graph ( ) throws exception { stringbuffer text = new stringbuffer ( ) ; text . append ( _str ) ; m_cobwebtree . graphtree ( text ) ; text . append ( _str ) ; return text . tostring ( ) ; }	generates the graph string of the cobweb tree.
@ override public enumeration < option > listoptions ( ) { vector < option > result = enumtovector ( super . listoptions ( ) ) ; result . addelement ( new option ( _str + defaultnumattributes ( ) + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str , _str , _num , _str ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
public synchronized reference < ? extends t > remove ( long timeoutmillis ) throws interruptedexception { if ( timeoutmillis < _num ) { throw new illegalargumentexception ( _str + timeoutmillis ) ; } if ( head != null ) { return poll ( ) ; } if ( timeoutmillis == _num || ( timeoutmillis > long . max_value / nanos_per_milli ) ) { do { wait ( _num ) ; } while ( head == null ) ; return poll ( ) ; } long nanostowait = timeoutmillis * nanos_per_milli ; int timeoutnanos = _num ; long starttime = system . nanotime ( ) ; while ( _bool ) { wait ( timeoutmillis , timeoutnanos ) ; if ( head != null ) { break ; } long nanoselapsed = system . nanotime ( ) - starttime ; long nanosremaining = nanostowait - nanoselapsed ; if ( nanosremaining <= _num ) { break ; } timeoutmillis = nanosremaining / nanos_per_milli ; timeoutnanos = ( int ) ( nanosremaining - timeoutmillis * nanos_per_milli ) ; } return poll ( ) ; }	returns the next available reference from the queue , removing it in the process.
public pathimpl lookupimpl ( string userpath , map < string , object > newattributes , boolean isallowroot ) { if ( userpath == null ) { return lookupimpl ( getpath ( ) , newattributes , isallowroot ) ; } if ( ! isallowroot ) { return schemewalk ( userpath , newattributes , userpath , _num ) ; } string scheme = scanscheme ( userpath ) ; if ( scheme == null ) { return schemewalk ( userpath , newattributes , userpath , _num ) ; } pathimpl path ; schememap schememap = _schememap ; if ( iswindows ( ) ) { int length = scheme . length ( ) ; char ch ; if ( length == _num && ( _str <= ( ch = scheme . charat ( _num ) ) && ch <= _str || _str <= ch && ch <= _str ) ) { userpath = character . tolowercase ( ch ) + userpath . substring ( _num ) ; if ( _istestwindows ) return schemewalk ( userpath , newattributes , _str + userpath , _num ) ; path = schememap . get ( _str ) ; if ( path != null ) return path . schemewalk ( userpath , newattributes , _str + userpath , _num ) ; else return schemewalk ( userpath , newattributes , _str + userpath , _num ) ; } } path = schememap . get ( scheme ) ; if ( path == null ) { return schemewalk ( userpath , newattributes , userpath , _num ) ; } else { return path . schemewalk ( userpath , newattributes , userpath , scheme . length ( ) + _num ) ; } }	returns a new path relative to the current one.
static integer readruleid ( final substringreader reader ) throws decodeexception { int length = _num ; reader . skipwhitespaces ( ) ; reader . mark ( ) ; try { while ( reader . read ( ) != _str ) { length ++ ; } if ( length == _num ) { throw decodeexception . error ( err_attr_syntax_rule_id_no_value1 . get ( reader . pos ( ) - _num ) ) ; } reader . reset ( ) ; final string ruleid = reader . read ( length ) ; try { return integer . valueof ( ruleid ) ; } catch ( final numberformatexception e ) { throw decodeexception . error ( err_attr_syntax_rule_id_invalid1 . get ( ruleid ) ) ; } } catch ( final stringindexoutofboundsexception e ) { throw decodeexception . error ( err_attr_syntax_truncated_value1 . get ( ) ) ; } }	reads the next ruleid from the definition , skipping over any leading spaces .
public void removeindex ( iindex index ) { if ( index != null ) { indices . remove ( index ) ; } }	removes the given index .
private attributeactionset processattributesection ( modeusage modeusage , string ns , intset indexset , attributes attributes ) throws saxexception { mode mode = modeusage . getmode ( currentsection . context ) ; attributeactionset actions = mode . getattributeactions ( ns ) ; if ( actions . getreject ( ) && ! attributenamespacerejected ) { attributenamespacerejected = _bool ; if ( eh != null ) eh . error ( new saxparseexception ( localizer . message ( _str , ns ) , locator ) ) ; } schema [ ] schemas = actions . getschemas ( ) ; for ( int j = _num ; j < schemas . length ; j ++ ) { if ( attributeschemas . contains ( schemas [ j ] ) ) continue ; attributeschemas . add ( schemas [ j ] ) ; if ( filteredattributes == null ) filteredattributes = filterattributes ( indexset , attributes ) ; validateattributes ( schemas [ j ] , filteredattributes ) ; } return actions ; }	process an attributes section in a specific mode usage .
@ override public double conf ( double totalweight , double delta ) { return inversenormal ( _num - delta / _num ) / ( _num * math . sqrt ( totalweight ) ) ; }	calculate confidence intervall without a specific rule for instance averaging functions .
@ override public final int readunsignedbyte ( ) throws ioexception { return dis . readunsignedbyte ( ) ; }	read an unsigned byte . note : returns an int , even though says byte ( non - javadoc ).
public synchronized static void ensuresecuritymanager ( @ suppresswarnings ( _str ) string [ ] args ) { securitypolicyloader . load ( systemboot . class , _str ) ; system . setsecuritymanager ( new rmisecuritymanager ( ) ) ; }	utility routine that sets a security manager ( if one isn ' t already present ) and the security policy.
@ override public object clone ( ) throws clonenotsupportedexception { return super . clone ( ) ; }	returns a clone of this instance .
public string ridgetiptext ( ) { return _str ; }	returns the tip text for this property.
public void updateenablestateswingitems ( ) { if ( swingutilities . iseventdispatchthread ( ) ) super . updateenablestate ( ) ; }	update the enable state for only the swing menu items.
public void reset ( ) { system . arraycopy ( iv , _num , cbcv , _num , iv . length ) ; arrays . fill ( cbcnextv , ( byte ) _num ) ; cipher . reset ( ) ; }	reset the chaining vector back to the iv and reset the underlying cipher .
protected final boolean _loadtohaveatleast ( int minavailable ) throws ioexception { if ( _inputstream == null ) { return _bool ; } int amount = _inputend - _inputptr ; if ( amount > _num && _inputptr > _num ) { _currinputprocessed += _inputptr ; system . arraycopy ( _inputbuffer , _inputptr , _inputbuffer , _num , amount ) ; _inputend = amount ; } else { _inputend = _num ; } _inputptr = _num ; while ( _inputend < minavailable ) { int count = _inputstream . read ( _inputbuffer , _inputend , _inputbuffer . length - _inputend ) ; if ( count < _num ) { _closeinput ( ) ; if ( count == _num ) { throw new ioexception ( _str + amount + _str ) ; } return _bool ; } _inputend += count ; } return _bool ; }	helper method that will try to load at least specified number bytes in input buffer , possible moving existing data around if necessary.
public datatypeparser register ( int jdbctype , string grammar ) { objects . requirenonnull ( grammar , _str ) ; datatypepattern pattern = parser . parse ( jdbctype , grammar ) ; pattern . foreachfirsttoken ( null ) ; return this ; }	register data type that may not contain a length / precision or scale.
public void close ( ) throws genericdatasourceexception { if ( _manualtx ) { if ( debug . verboseon ( ) ) debug . logverbose ( _str + _manualtx , module ) ; commit ( ) ; } _sql = null ; if ( _rs != null ) { try { _rs . close ( ) ; if ( debug . verboseon ( ) ) debug . logverbose ( _str + _manualtx , module ) ; } catch ( sqlexception sqle ) { debug . logwarning ( sqle . getmessage ( ) , module ) ; } _rs = null ; } if ( _ps != null ) { try { _ps . close ( ) ; if ( debug . verboseon ( ) ) debug . logverbose ( _str + _manualtx , module ) ; } catch ( sqlexception sqle ) { debug . logwarning ( sqle . getmessage ( ) , module ) ; } _ps = null ; } if ( ( _connection != null ) && _bdeleteconnection ) { try { _connection . close ( ) ; if ( debug . verboseon ( ) ) debug . logverbose ( _str + _manualtx , module ) ; } catch ( sqlexception sqle ) { debug . logwarning ( sqle . getmessage ( ) , module ) ; } _connection = null ; } }	commit if required and remove all allocated resources.
private defaultmutabletreenode copy ( treenode node ) { return new defaultmutabletreenode ( node ) ; }	defensive copy used in createtransferable .
public static void agentmain ( string args , instrumentation inst ) throws exception { logger . info ( _str ) ; checktransformerstate ( ) ; inst . addtransformer ( transformer , _bool ) ; instrumentation = inst ; }	this is called by jvm when agent starts.
public byte [ ] data ( ) { bytearrayoutputstream bos = new bytearrayoutputstream ( ) ; try { todata ( bos ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } return bos . tobytearray ( ) ; }	serialize the row ' s metadata to enable upgrade .
@ safevarargs public static < t > reactiveseq < t > of ( final t ... elements ) { final reversingarrayspliterator < t > array = new reversingarrayspliterator < t > ( elements , _bool , _num ) ; return streamutils . reactiveseq ( streamsupport . stream ( array , _bool ) , optional . ofnullable ( array ) ) ; }	create an efficiently reversable sequence from the provided elements.
private void decodeltp ( longtermprediction ltp , int maxsfb ) { ltp . lag = br . read ( _num ) ; ltp . coef = ltp_coef [ br . read ( _num ) ] ; for ( int sfb = _num ; sfb < math . min ( maxsfb , max_ltp_long_sfb ) ; sfb ++ ) { ltp . used [ sfb ] = br . readbool ( ) ; } }	decode long term prediction data ; reference : table 4.
public static < t > list < t > instantiateall ( string [ ] classes , classloader classloader ) { list < t > clazzes = new arraylist < t > ( ) ; for ( string clazz : classes ) { if ( stringutils . haslength ( clazz ) ) { try { clazzes . add ( classutils . < t > instantiate ( clazz , classloader ) ) ; } catch ( exception e ) { throw new cassandramigrationexception ( _str + clazz , e ) ; } } } return clazzes ; }	instantiate all these classes .
static void clearinstancecache ( ) { synchronized ( instance_cache ) { instance_cache . clear ( ) ; } }	for unit testing only.
public static < e extends enum < e > & bitmapableenum > enumset < e > toenumset ( class < e > type , int bitmap ) { if ( type == null ) throw new nullpointerexception ( _str ) ; enumset < e > s = enumset . noneof ( type ) ; int allsetbitmap = _num ; for ( e element : type . getenumconstants ( ) ) { if ( integer . bitcount ( element . getvalue ( ) ) != _num ) { string msg = string . format ( _str + _str + _str , element . tostring ( ) , element . getvalue ( ) , type . getname ( ) ) ; throw new illegalargumentexception ( msg ) ; } allsetbitmap |= element . getvalue ( ) ; if ( ( bitmap & element . getvalue ( ) ) != _num ) s . add ( element ) ; } if ( ( ( ~ allsetbitmap ) & bitmap ) != _num ) { string msg = string . format ( _str + _str , bitmap , type . getname ( ) ) ; throw new illegalargumentexception ( msg ) ; } return s ; }	convert an integer bitmap to an enumset . see class description for example.
public undirectedgraphnode clonegraphb ( undirectedgraphnode node ) { map < integer , undirectedgraphnode > map = new hashmap < > ( ) ; return dfs ( node , map ) ; }	dfs . pass the node and map to its neighbors . add neighbors dfs result to its neighbors and return .
public synchronized void notifysessionborrowed ( ) { if ( logger . istraceenabled ( ) ) logger . logtrace ( this + _str ) ; currentcontext = new transactioncontext ( resource , xaresource ) ; allcontexts . add ( currentcontext ) ; closed = _bool ; }	notification that the session was gotten from the pool .
@ override public synchronized void close ( ) throws sqlexception { try { debugcodecall ( _str ) ; if ( session == null ) { return ; } closewatcher . unregister ( watcher ) ; session . cancel ( ) ; if ( executingstatement != null ) { try { executingstatement . cancel ( ) ; } catch ( nullpointerexception e ) { } } synchronized ( session ) { try { if ( ! session . isclosed ( ) ) { try { if ( session . haspendingtransaction ( ) ) { if ( ! session . isreconnectneeded ( _bool ) ) { try { rollbackinternal ( ) ; } catch ( dbexception e ) { if ( e . geterrorcode ( ) != errorcode . connection_broken_1 ) { throw e ; } } } session . afterwriting ( ) ; } closepreparedcommands ( ) ; } finally { session . close ( ) ; } } } finally { session = null ; } } } catch ( exception e ) { throw logandconvert ( e ) ; } }	closes this connection . all open statements , prepared statements and result sets that where created by this connection become invalid after calling this method . if there is an uncommitted transaction , it will be rolled back .
public void testplusmathcontextnegative ( ) { string a = _str ; int ascale = _num ; int precision = _num ; roundingmode rm = roundingmode . ceiling ; mathcontext mc = new mathcontext ( precision , rm ) ; string c = _str ; int cscale = _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal res = anumber . plus ( mc ) ; assertequals ( _str , c , res . tostring ( ) ) ; assertequals ( _str , cscale , res . scale ( ) ) ; }	plus ( mathcontext ) for a negative bigdecimal.
public static wktgeometry createempty ( wkttype wkttype ) { wktgeometry wktgeometry = new wktgeometry ( ) ; wktgeometry . setgeometrytype ( wkttype ) ; return wktgeometry ; }	creates the empty wkt geometry.
public peerlookuptask createpeerlookup ( byte [ ] info_hash ) { if ( ! isrunning ( ) ) { return null ; } key id = new key ( info_hash ) ; rpcserver srv = servermanager . getrandomactiveserver ( _bool ) ; if ( srv == null ) return null ; peerlookuptask lookuptask = new peerlookuptask ( srv , node , id ) ; return lookuptask ; }	returns a non - enqueued task for further configuration.
public void addchild ( node ... nodes ) { for ( node node : nodes ) { node . detachfromparent ( ) ; node . parentnode = this ; initchildnodes ( node ) ; childnodes . add ( node ) ; } reindexchildrenonadd ( nodes . length ) ; }	appends several child nodes at once.
public static void writestringascii ( bytebuf stream , string str ) throws unsupportedencodingexception { final byte [ ] bytes = str . getbytes ( _str ) ; stream . writeint ( str . length ( ) ) ; stream . writebytes ( bytes ) ; }	writes an ascii string to the stream , the first value will be an integer for the length of the string , followed by bytes.
@ override public void ondetach ( ) { synchronized ( mthread ) { mprogressbar = null ; mready = _bool ; mthread . notify ( ) ; } super . ondetach ( ) ; }	this is called right before the fragment is detached from its current activity instance .
public void outputsource ( int module , int line , string s ) { stringbuilder sb = new stringbuilder ( ) ; appendsource ( sb , module , line , s , _bool ) ; out ( sb . tostring ( ) ) ; }	output a source line of code to the output channel formatting nicely.
sortedmap < string , string > properties ( ) ;	returns a sorted map of the properties of this packer .
public static string suppresswhitespace ( string str ) { int len = str . length ( ) ; stringbuilder sb = new stringbuilder ( len ) ; char c ; char buffer = _num ; for ( int i = _num ; i < len ; i ++ ) { c = str . charat ( i ) ; if ( c == _str || c == _str ) buffer = _str ; else if ( iswhitespace ( c ) ) { if ( buffer == _num ) buffer = c ; } else { if ( buffer != _num ) { sb . append ( buffer ) ; buffer = _num ; } sb . append ( c ) ; } } if ( buffer != _num ) sb . append ( buffer ) ; return sb . tostring ( ) ; }	remove all white spaces followd by whitespaces.
private node < k , v > findpredecessor ( comparable < ? super k > key ) { if ( key == null ) throw new nullpointerexception ( ) ; for ( ; ; ) { index < k , v > q = head ; index < k , v > r = q . right ; for ( ; ; ) { if ( r != null ) { node < k , v > n = r . node ; k k = n . key ; if ( n . value == null ) { if ( ! q . unlink ( r ) ) break ; r = q . right ; continue ; } if ( key . compareto ( k ) > _num ) { q = r ; r = r . right ; continue ; } } index < k , v > d = q . down ; if ( d != null ) { q = d ; r = d . right ; } else return q . node ; } } }	returns a base - level node with key strictly less than given key , or the base - level header if there is no such node.
public void notidle ( ) { if ( idletimeoutmsec . get ( ) > _num ) lastactionmsec . set ( system . currenttimemillis ( ) ) ; }	a " not idle " event has occurred.
public static byte [ ] gzip ( final string input ) { final bytearrayoutputstream baos = new fastbytearrayoutputstream ( ) ; gzipoutputstream gzos = null ; try { gzos = new gzipoutputstream ( baos ) ; gzos . write ( input . getbytes ( _str ) ) ; } catch ( final ioexception e ) { mainutil . handleerror ( e ) ; } finally { if ( gzos != null ) { try { gzos . close ( ) ; } catch ( final ioexception ignore ) { } } } return baos . tobytearray ( ) ; }	gzip compress a string of bytes.
protected abstractcompositeservicebuilder ( ) { }	creates a new instance .
@ override public void enddocument ( ) throws saxexception { if ( resource != null ) { resource . addallresource ( jsvector ) ; for ( object object : resource . getresourceset ( ) ) { resource r = ( resource ) object ; if ( r . getresource ( ) != null ) { parser . setresource ( ( resource ) r ) ; parser . run ( ) ; jsset . add ( parser . getresult ( ) ) ; } } } }	event fired at the end of the document parse.
public void addmethodtodisplay ( methodident methodident ) { methods . add ( methodident ) ; }	adds a method to be displayed later in this sub - tree .
@ override public enumeration < option > listoptions ( ) { vector < option > result = new vector < option > ( ) ; result . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; result . addall ( collections . list ( super . listoptions ( ) ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
private void selectconnectingedges ( list < displaynode > displaynodes ) { if ( ! isallownodeedgeselection ( ) ) { return ; } component [ ] components = getcomponents ( ) ; for ( component comp : components ) { if ( comp instanceof idisplayedge ) { idisplayedge graphedge = ( idisplayedge ) comp ; displaynode node1 = graphedge . getcomp1 ( ) ; displaynode node2 = graphedge . getcomp2 ( ) ; if ( node1 instanceof graphnodeerror ) { continue ; } if ( node2 instanceof graphnodeerror ) { continue ; } if ( node2 != null ) { boolean selected = displaynodes . contains ( node1 ) && displaynodes . contains ( node2 ) ; graphedge . setselected ( selected ) ; } } } }	selects all and only those edges that are connecting selected nodes.
public static string classnameonly ( string typename ) { string dotted = descriptortodot ( typename ) ; int start = dotted . lastindexof ( _str ) ; if ( start < _num ) { return dotted ; } else { return dotted . substring ( start + _num ) ; } }	extracts the class name from a type descriptor .
@ override public synchronized string tostring ( ) { final stringbuffer sbresult = new stringbuffer ( ) ; sbresult . append ( _str ) ; sbresult . append ( getcredentialsstringrepresentation ( proxycred ) ) ; sbresult . append ( _str ) ; sbresult . append ( getcredentialsstringrepresentation ( credmap ) ) ; sbresult . append ( _str ) ; sbresult . append ( getcookiesstringrepresentation ( cookies ) ) ; sbresult . append ( _str ) ; final string strresult = sbresult . tostring ( ) ; return strresult ; }	returns a string representation of this http state .
public static list < librarylocation > gatheralllibraries ( string [ ] dirpaths ) { list < librarylocation > libraries = new arraylist < librarylocation > ( ) ; for ( int i = _num ; i < dirpaths . length ; i ++ ) { file extdir = new file ( dirpaths [ i ] ) ; if ( extdir . isdirectory ( ) ) { string [ ] names = extdir . list ( fgarchivefilter ) ; if ( names != null ) { for ( int j = _num ; j < names . length ; j ++ ) { file jar = new file ( extdir , names [ j ] ) ; if ( jar . isfile ( ) ) { try { ipath libpath = new path ( jar . getcanonicalpath ( ) ) ; ipath sourcepath = path . empty ; ipath packageroot = path . empty ; url javadoclocation = null ; url indexlocation = null ; librarylocation library = new librarylocation ( libpath , sourcepath , packageroot , javadoclocation , indexlocation ) ; libraries . add ( library ) ; } catch ( ioexception e ) { launching . log ( e ) ; } } } } } } return libraries ; }	returns a list of all zip ' s and jars contained in the given directories .
public void requestclose ( ) { mlock . lock ( ) ; try { if ( misshutdown ) { return ; } mtargetstate = targetstate . closed ; update ( ) ; } finally { mlock . unlock ( ) ; } }	request that the state machine move towards a closed state .
private void reserveonedoc ( ) { if ( pendingnumdocs . incrementandget ( ) > indexwriter . getactualmaxdocs ( ) ) { pendingnumdocs . decrementandget ( ) ; throw new illegalargumentexception ( _str + indexwriter . getactualmaxdocs ( ) ) ; } }	anything that will add n docs to the index should reserve first to make sure it ' s allowed .
public static void streamcontenttobrowser ( httpservletresponse response , inputstream in , int length , string contenttype , string filename ) throws ioexception { setresponsebrowserproxynocache ( response ) ; response . setcontentlength ( length ) ; if ( contenttype != null ) { response . setcontenttype ( contenttype ) ; } if ( filename != null ) { response . setheader ( _str , _str + filename + _str ) ; } outputstream out = response . getoutputstream ( ) ; try { streamcontent ( out , in , length ) ; } catch ( ioexception e ) { out . close ( ) ; throw e ; } out . flush ( ) ; out . close ( ) ; }	streams content from inputstream to the servletoutputstream this method will close the servletoutputstream when finished this method does not close the inputsteam passed.
@ override public string tostring ( ) { return tostring ( _bool ) ; }	returns string representation of this object.
private static boolean isvalidmethodname ( string methodname ) { return methodname . matches ( _str ) ; }	determine whether the provided method name is valid in java .
public static byte [ ] toutf8 ( string s ) { byte [ ] result = new byte [ utflength ( s ) ] ; int result_index = _num ; for ( int i = _num , n = s . length ( ) ; i < n ; ++ i ) { char c = s . charat ( i ) ; if ( ( ( ! write_pseudo_utf8 ) || ( c >= _num ) ) && ( c <= _num ) ) { result [ result_index ++ ] = ( byte ) c ; } else if ( c > _num ) { result [ result_index ++ ] = ( byte ) ( _num | ( byte ) ( c > > _num ) ) ; result [ result_index ++ ] = ( byte ) ( _num | ( ( c & _num ) > > _num ) ) ; result [ result_index ++ ] = ( byte ) ( _num | ( c & _num ) ) ; } else { result [ result_index ++ ] = ( byte ) ( _num | ( byte ) ( c > > _num ) ) ; result [ result_index ++ ] = ( byte ) ( _num | ( c & _num ) ) ; } } return result ; }	convert the given string into a sequence of ( pseudo - ) utf8 formatted bytes.
public void pln ( object o ) throws ioexception { p ( o . tostring ( ) ) ; pln ( ) ; }	write object ; end current line .
public void testreducetask ( ) throws exception { hadoopjob gridjob = gethadoopjob ( igfsscheme ( ) + path_input , igfsscheme ( ) + path_output ) ; runtaskwithinput ( gridjob , hadooptasktype . reduce , _num , _str , _str , _str , _str ) ; runtaskwithinput ( gridjob , hadooptasktype . reduce , _num , _str , _str , _str , _str ) ; assertequals ( _str + _str , readandsortfile ( path_output + _str + getoutputfilenameprefix ( ) + _str ) ) ; assertequals ( _str + _str , readandsortfile ( path_output + _str + getoutputfilenameprefix ( ) + _str ) ) ; }	tests reduce task execution .
public static double expm1 ( double value ) { if ( use_jdk_math ) { return strict_math ? strictmath . expm1 ( value ) : math . expm1 ( value ) ; } if ( math . abs ( value ) < exp_lo_distance_to_zero ) { int i = ( int ) ( value * exp_lo_indexing ) ; double delta = value - i * ( _num / exp_lo_indexing ) ; return explopostab [ i + exp_lo_tab_mid_index ] * ( explonegtab [ i + exp_lo_tab_mid_index ] + delta * ( _num + delta * ( _num / _num + delta * ( _num / _num + delta * ( _num / _num + delta * ( _num / _num ) ) ) ) ) ) ; } else { return fastmath . exp ( value ) - _num ; } }	much more accurate than exp ( value ) - 1 , for values close to zero .
public void deleteconditional ( conditional c ) { deregister ( c ) ; }	remove an existing conditional.
private void addblocktoworklist ( ssabasicblock ssablock ) { if ( ! executableblocks . get ( ssablock . getindex ( ) ) ) { cfgworklist . add ( ssablock ) ; executableblocks . set ( ssablock . getindex ( ) ) ; } else { cfgphiworklist . add ( ssablock ) ; } }	adds a ssa basic block to the cfg worklist if it ' s unexecuted , or to the cfg phi worklist if it ' s already executed .
private static boolean is32bitjvm ( ) { integer bits = integer . getinteger ( _str ) ; return bits != null && bits == _num ; }	uses the non - portable system property sun.
public float angle ( ) { return ( float ) math . atan2 ( y ( ) , x ( ) ) ; }	angle of this sample in radians.
public static string formatnumber ( double value , int numberofdigits , boolean groupingcharacters ) { if ( double . isnan ( value ) ) { return _str ; } int numberdigits = numberofdigits ; if ( numberdigits < _num ) { numberdigits = numberoffractiondigits ; } number_format . setminimumfractiondigits ( numberdigits ) ; number_format . setmaximumfractiondigits ( numberdigits ) ; number_format . setgroupingused ( groupingcharacters ) ; return number_format . format ( value ) ; }	returns a formatted string of the given number ( uses the property rapidminer.
private static boolean istrashid ( igniteuuid id ) { if ( id == null ) return _bool ; uuid gid = id . globalid ( ) ; return id . localid ( ) == _num && gid . getmostsignificantbits ( ) == _num && gid . getleastsignificantbits ( ) > _num && gid . getleastsignificantbits ( ) <= trash_concurrency ; }	check whether provided id is trash id .
private void ontimeelementend ( ) throws saxexception { try { timems = xml_date_time_format . parsemillis ( content . trim ( ) ) ; } catch ( illegalargumentexception e ) { throw new saxexception ( createerrormessage ( _str + content ) , e ) ; } }	on time element end.
public static boolean isclasspresent ( string fullyqualifiedclassname ) { try { class . forname ( fullyqualifiedclassname ) ; return _bool ; } catch ( classnotfoundexception e ) { return _bool ; } }	returns true if the class is present in the current class loader .
void unlink ( node < e > p , node < e > trail ) { p . setvalue ( null ) ; trail . next = p . next ; if ( last == p ) last = trail ; if ( count . getanddecrement ( ) == capacity ) notfull . signal ( ) ; }	unlinks interior node p with predecessor trail .
@ targetapi ( build . version_codes . jelly_bean ) private int queueinputbuffer ( mediacodec codec , bytebuffer [ ] inputbuffers , int index , speechrecord speechrecord ) { if ( speechrecord == null || speechrecord . getrecordingstate ( ) != speechrecord . recordstate_recording ) { return - _num ; } if ( build . version . sdk_int >= build . version_codes . jelly_bean ) { bytebuffer inputbuffer = inputbuffers [ index ] ; inputbuffer . clear ( ) ; int size = inputbuffer . limit ( ) ; byte [ ] buffer = new byte [ size ] ; int status = read ( speechrecord , buffer ) ; if ( status < _num ) { handleerror ( _str + status ) ; return - _num ; } inputbuffer . put ( buffer ) ; codec . queueinputbuffer ( index , _num , size , _num , _num ) ; return size ; } return - _num ; }	copy audio from the recorder into the encoder .
@ override public final void sample ( ) { long count = _count . getandset ( _num ) ; long time = _time . getandset ( _num ) ; if ( count == _num ) _value = _num ; else _value = time / ( double ) count ; }	return the probe ' s next sample .
protected void validateproperties ( final object entity , final entitydatamodel edm ) throws odataexception { final type type = edm . gettype ( entity . getclass ( ) ) ; if ( ! ( type instanceof structuredtype ) ) { return ; } visitproperties ( edm , ( structuredtype ) type , null ) ; }	checks if all non - nullable properties of an entity are non - empty .
static adbresponse readadbresponse ( socketchannel chan , boolean readdiagstring ) throws timeoutexception , ioexception { adbresponse resp = new adbresponse ( ) ; byte [ ] reply = new byte [ _num ] ; read ( chan , reply ) ; if ( isokay ( reply ) ) { resp . okay = _bool ; } else { readdiagstring = _bool ; resp . okay = _bool ; } try { while ( readdiagstring ) { byte [ ] lenbuf = new byte [ _num ] ; read ( chan , lenbuf ) ; string lenstr = replytostring ( lenbuf ) ; int len ; try { len = integer . parseint ( lenstr , _num ) ; } catch ( numberformatexception nfe ) { log . w ( _str , _str + lenstr + _str + lenbuf [ _num ] + _str + lenbuf [ _num ] + _str + lenbuf [ _num ] + _str + lenbuf [ _num ] ) ; log . w ( _str , _str + replytostring ( reply ) ) ; break ; } byte [ ] msg = new byte [ len ] ; read ( chan , msg ) ; resp . message = replytostring ( msg ) ; log . v ( _str , _str + replytostring ( reply ) + _str + resp . message + _str ) ; break ; } } catch ( exception e ) { } return resp ; }	reads the response from adb after a command .
public void removemousemode ( string id ) { for ( mapmousemode med : mousemodes ) { if ( id . equals ( med . getid ( ) ) ) { removemousemode ( med ) ; break ; } } }	removes a particular mapmousemode from the mousemode list , with the id given .
private boolean filterexistingitems ( list < postitem > postitems , postitem item ) { if ( postitems . contains ( item ) ) { int i = postitems . indexof ( item ) ; postitems . remove ( i ) ; postitems . add ( i , item ) ; return _bool ; } return _bool ; }	this function replaces the old item in the list with the new one only if both items have the same id.
daterange buildshiftedrange ( daterange rawrange , long cadence , long now ) { if ( rawrange . getstart ( ) > now ) { throw new illegalargumentexception ( _str ) ; } final daterange rounded = rawrange . rounded ( cadence ) ; final long nowdelta = now - rounded . getend ( ) ; if ( nowdelta > shift_tolerance ) { return rounded ; } final long diff = math . abs ( math . min ( nowdelta , _num ) ) + shift_tolerance ; return rounded . shift ( - toleranceshiftperiod ( diff , cadence ) ) ; }	given a range and a cadence , return a range that might be shifted in case the end period is too close or after ' now '.
public static void upto ( date self , date to , closure closure ) { if ( self . compareto ( to ) <= _num ) { for ( date i = ( date ) self . clone ( ) ; i . compareto ( to ) <= _num ; i = next ( i ) ) { closure . call ( i ) ; } } else throw new groovyruntimeexception ( _str + to + _str + self + _str ) ; }	iterates from this date up to the given date , inclusive , incrementing by one day each time .
public void runtest ( ) throws throwable { document doc ; nodelist elementlist ; element testemployee ; node firstc ; string childname ; int nodetype ; characterdata employeeidnode ; string employeeid ; doc = ( document ) load ( _str , _bool ) ; elementlist = doc . getelementsbytagname ( _str ) ; testemployee = ( element ) elementlist . item ( _num ) ; firstc = testemployee . getfirstchild ( ) ; nodetype = ( int ) firstc . getnodetype ( ) ; while ( equals ( _num , nodetype ) ) { firstc = firstc . getnextsibling ( ) ; nodetype = ( int ) firstc . getnodetype ( ) ; } childname = firstc . getnodename ( ) ; assertequalsautocase ( _str , _str , _str , childname ) ; employeeidnode = ( characterdata ) firstc . getfirstchild ( ) ; employeeid = employeeidnode . getnodevalue ( ) ; assertequals ( _str , _str , employeeid ) ; }	runs the test case .
public inferencecontext ( n4jstypesystem ts , typesystemhelper tsh , cancelindicator cancelindicator , ruleenvironment g , inferencevariable ... inferencevariables ) { objects . requirenonnull ( ts ) ; objects . requirenonnull ( tsh ) ; objects . requirenonnull ( cancelindicator ) ; objects . requirenonnull ( g ) ; this . ts = ts ; this . tsh = tsh ; this . cancelindicator = cancelindicator ; this . g = g ; addinferencevariables ( _bool , inferencevariables ) ; this . reducer = new reducer ( this , g , ts , tsh ) ; this . currentbounds = new boundset ( this , g , ts ) ; }	creates a new , empty inference context for the given inference variables .
@ override public void run ( ) throws interruptedexception , cameraaccessexception , cameracapturesessionclosedexception , resourceacquisitionfailedexception { frameserver . session session = mframeserver . trycreateexclusivesession ( ) ; if ( session == null ) { return ; } try { aftriggerresult afscanresult = new aftriggerresult ( ) ; requestbuilder idlebuilder = createafidlerequest ( null ) ; session . submitrequest ( arrays . aslist ( idlebuilder . build ( ) ) , frameserver . requesttype . repeating ) ; requestbuilder cancelbuilder = createafcancelrequest ( null ) ; session . submitrequest ( arrays . aslist ( cancelbuilder . build ( ) ) , frameserver . requesttype . non_repeating ) ; idlebuilder = createafidlerequest ( afscanresult ) ; session . submitrequest ( arrays . aslist ( idlebuilder . build ( ) ) , frameserver . requesttype . repeating ) ; requestbuilder triggerbuilder = createaftriggerrequest ( afscanresult ) ; session . submitrequest ( arrays . aslist ( triggerbuilder . build ( ) ) , frameserver . requesttype . non_repeating ) ; afscanresult . get ( ) ; } finally { session . close ( ) ; } }	performs an auto - focus scan , blocking until the scan starts , runs , and completes .
protected list < node > creatediscretevariablelist ( discretevariableanalysis variableanalysis ) { list < node > nodes = new arraylist < > ( variableanalysis . getnumofcols ( ) ) ; discretevarinfo [ ] variables = variableanalysis . getdiscretevarinfos ( ) ; for ( discretevarinfo variable : variables ) { if ( variable != null ) { nodes . add ( new discretevariable ( variable . getname ( ) , variable . getcategories ( ) ) ) ; } } return nodes ; }	create a list of nodes from variable analysis results .
public synchronized void removeseries ( xyseries series ) { mseries . remove ( series ) ; }	removes the xy series from the list .
public void remoterestartcoordinator ( string nodeid , string type ) throws localrepositoryexception { final string prefix = string . format ( _str , type , nodeid ) ; _log . debug ( prefix ) ; final string [ ] cmd = { _systool_cmd , _systool_remote_systool , nodeid , _systool_restart_coordinator , type } ; final exec . result result = exec . sudo ( _systool_timeout , cmd ) ; checkfailure ( result , prefix ) ; }	restart a service on remote node.
private static string inttostring ( int value , int digit ) { stringbuilder stringbuilder = new stringbuilder ( digit ) ; stringbuilder . append ( integer . tostring ( value ) ) ; while ( stringbuilder . length ( ) < digit ) { stringbuilder . insert ( _num , _str ) ; } return stringbuilder . tostring ( ) ; }	create string representation of integer.
void add ( int n ) { if ( v == null ) { v = new int [ init_size ] ; v [ _num ] = n ; len = _num ; return ; } if ( len == v . length ) { int [ ] newv = new int [ len * _num ] ; system . arraycopy ( v , _num , newv , _num , len ) ; v = newv ; } if ( n > v [ len - _num ] ) { v [ len ++ ] = n ; return ; } int i = _num ; for ( ; i < len ; i ++ ) { if ( n <= v [ i ] ) { if ( n == v [ i ] ) return ; break ; } } for ( int j = len ; j >= i ; j -- ) v [ j + _num ] = v [ j ] ; v [ i ] = n ; ++ len ; }	add a new value .
public static string replace ( string source , string target , string replacement ) { stringbuffer output = new stringbuffer ( ) ; int n = _num ; while ( _bool ) { int off = source . indexof ( target , n ) ; if ( off == - _num ) { output . append ( source . substring ( n ) ) ; break ; } output . append ( source . substring ( n , off ) ) ; output . append ( replacement ) ; n = off + target . length ( ) ; } return output . tostring ( ) ; }	description of the method.
public void correctnullreceiver ( ) { if ( args [ _num ] != null ) return ; handle = handle . bindto ( nullobject . getnullobject ( ) ) ; handle = methodhandles . droparguments ( handle , _num , targettype . parametertype ( _num ) ) ; if ( log_enabled ) log . info ( _str ) ; }	gives a replacement receiver for null.
public static boolean ispairedenddirectory ( final file dir ) { if ( dir == null || ! dir . exists ( ) || ! dir . isdirectory ( ) ) { return _bool ; } final file ldir = new file ( dir , _str ) ; final file rdir = new file ( dir , _str ) ; return ldir . exists ( ) && rdir . exists ( ) && ldir . isdirectory ( ) && rdir . isdirectory ( ) ; }	tells you if the directory passed in contains a paired end sdf left / right folder.
@ suppresswarnings ( _str ) private void checkclassnotfound ( ) throws exception { initgar = _bool ; try { ignite ignite1 = startgrid ( _num ) ; ignite ignite2 = startgrid ( _num ) ; class task = extldr . loadclass ( task_name ) ; try { ignite1 . compute ( ) . execute ( task , ignite2 . cluster ( ) . localnode ( ) . id ( ) ) ; assert _bool ; } catch ( igniteexception e ) { info ( _str + e ) ; } } finally { stopgrid ( _num ) ; stopgrid ( _num ) ; } }	test what happens if peer class loading is disabled .
public string dropengine ( engine engine ) { stringbuilder builder = new stringbuilder ( ) ; for ( string attribute : setup . getdropenginemessageformat ( ) ) { builder . append ( getengineattribute ( engine , attribute , ! pickup ) ) ; } return builder . tostring ( ) ; }	returns the drop string for a loco.
protected void popwritecontext ( ) { writecontext_ = writecontextstack_ . pop ( ) ; }	pop the last write context off the stack.
public long calculateendtime ( ) { if ( endtime == _num ) { return system . currenttimemillis ( ) ; } else if ( endtime < _num ) { return system . currenttimemillis ( ) - endtime ; } return endtime ; }	this method returns an end time based on the configured value.
protected string extractalternateopenquote ( string token ) { return null ; }	extracts the alternate open quote from this token ( if any ) .
private boolean removeindexentry ( servicetype resourcetype , string resourcename , string policyname ) throws policyexception { resourceindex resourceindex = ( resourceindex ) resourceindices . get ( resourcetype . getname ( ) ) ; if ( resourceindex == null ) { resourceindex = refreshresourceindexfromdatastore ( resourcetype ) ; } return resourceindex . removeindexentry ( resourcename , policyname ) ; }	removes or updates an index entry.
public static textblock parsetextblock ( parsecontext parsecontext ) { return textblocksectionparser . parsetextblock ( parsecontext ) ; }	parses a single text block with equal indentation .
public final static boolean inlongrange ( char [ ] digitchars , int offset , int len , boolean negative ) { string cmpstr = negative ? min_long_str_no_sign : max_long_str ; int cmplen = cmpstr . length ( ) ; if ( len < cmplen ) return _bool ; if ( len > cmplen ) return _bool ; for ( int i = _num ; i < cmplen ; ++ i ) { if ( digitchars [ offset + i ] > cmpstr . charat ( i ) ) { return _bool ; } } return _bool ; }	helper method for determining if given string representation of an integral number would fit in 64 - bit java long or not.
public static collection < debuggerexception > mergeexceptionssettings ( final debugtargetsettings target , final collection < debuggerexception > exceptions , final int debuggerid ) throws couldntloaddataexception { final map < long , debuggerexception > exceptionsmap = getexceptionsmap ( exceptions ) ; for ( final debuggerexception dbgexception : exceptions ) { final string setting = target . readsetting ( debuggerexception . getsettingkey ( dbgexception , debuggerid ) ) ; if ( setting != null ) { final debuggerexceptionhandlingaction handlingaction = debuggerexceptionhandlingaction . converttohandlingaction ( integer . valueof ( setting ) ) ; final debuggerexception newexception = new debuggerexception ( dbgexception . getexceptionname ( ) , dbgexception . getexceptioncode ( ) , handlingaction ) ; exceptionsmap . put ( dbgexception . getexceptioncode ( ) , newexception ) ; } } return exceptionsmap . values ( ) ; }	merge the exception settings from the database with the ones received from the debugger .
public void verifyannotation ( string methodname , string annotationname ) throws exception { class clazz = class . forname ( classname ) ; method method = clazz . getdeclaredmethod ( methodname ) ; class annotationclazz = class . forname ( annotationname ) ; java . lang . annotation . annotation annotation = method . getannotation ( annotationclazz ) ; assert . assertnotnull ( annotation ) ; }	verify the method does have the annotation.
public publisheramb < t > ambadditionalsource ( publisher < ? extends t > source ) { if ( array != null ) { int n = array . length ; @ suppresswarnings ( _str ) publisher < ? extends t > [ ] newarray = new publisher [ n + _num ] ; system . arraycopy ( array , _num , newarray , _num , n ) ; newarray [ n ] = source ; return new publisheramb < > ( newarray ) ; } return null ; }	returns a new instance which has the additional source to be amb ' d together with the current array of sources.
public void begindisplay ( displayevent event ) throws modelcontrolexception { super . begindisplay ( event ) ; string sitename = ( string ) getpagesessionattribute ( pg_attr_site_name ) ; serversitemodel model = ( serversitemodel ) getmodel ( ) ; ptmodel . setpagetitletext ( model . geteditsitepagetitle ( sitename ) ) ; try { setdisplayfieldvalue ( tf_url , model . getsiteprimaryurl ( sitename ) ) ; getfailoverurls ( sitename , model ) ; getservers ( sitename , model ) ; } catch ( amconsoleexception e ) { setinlinealertmessage ( ccalert . type_error , _str , e . getmessage ( ) ) ; } }	displays the profile of a site .
public boolean add ( accessiblestate state ) { if ( states == null ) { states = new vector ( ) ; } if ( ! states . contains ( state ) ) { states . addelement ( state ) ; return _bool ; } else { return _bool ; } }	adds a new state to the current state set if it is not already present.
public static final string readfile ( file file ) throws ioexception { bufferedinputstream in = null ; try { in = new bufferedinputstream ( new fileinputstream ( file ) ) ; simplebytebuffer buffer = new simplebytebuffer ( ) ; byte [ ] buf = new byte [ _num ] ; int len ; while ( ( len = in . read ( buf ) ) != - _num ) { buffer . put ( buf , len ) ; } return new string ( buffer . buffer , _num , buffer . write ) ; } finally { if ( null != in ) { in . close ( ) ; } } }	read small < 5mb text files to string .
void adddecimalpoint ( ) { this . displaymode = display_mode . input ; if ( this . clearonnextdigit ) { setdisplaystring ( empty_string ) ; } final string inputstring = getdisplaystring ( ) ; if ( inputstring . indexof ( dot_character ) < _num ) { setdisplaystring ( inputstring + dot_character ) ; } }	add a decimal point.
public void close ( ) throws java . io . ioexception { m_os . close ( ) ; }	close the stream , flushing it first.
void show ( ) { if ( misvisible ) return ; misvisible = _bool ; mheightpx = math . round ( mdefaultheightpx ) ; invalidate ( ) ; }	shows the peek promo.
public void recordmirroroperation ( dbclient dbclient , operationtypeenum optype , operation . status status , object ... extparam ) { try { boolean opstatus = ( operation . status . ready == status ) ? _bool : _bool ; string evtype ; evtype = optype . getevtype ( opstatus ) ; string evdesc = optype . getdescription ( ) ; string opstage = auditlogmanager . auditop_end ; _logger . info ( _str , optype . tostring ( ) , evtype . tostring ( ) + _str + evdesc ) ; recordbournemirrorevent ( dbclient , getid ( ) , evtype , status , evdesc ) ; switch ( optype ) { case create_file_mirror : case start_file_mirror : case suspend_file_mirror : case detach_file_mirror : case pause_file_mirror : case resume_file_mirror : case failover_file_mirror : case stop_file_mirror : case failback_file_mirror : case resync_file_mirror : case refresh_file_mirror : case modify_file_mirror_rpo : auditfile ( dbclient , optype , opstatus , opstage , extparam ) ; break ; default : _logger . error ( _str ) ; } } catch ( exception e ) { _logger . error ( _str , optype . tostring ( ) , e ) ; } }	record fileshare related event and audit.
private void canceltakeimage ( ) { mshootedpicturepath = null ; mselectedgalleryitemslist . clear ( ) ; vectorapp . setsavedcameraimagepreview ( null ) ; startcamerapreview ( ) ; updateuiconfiguration ( ui_show_camera_preview , image_origin_camera ) ; }	cancel the current image preview , and setup the ui to start a new image capture .
protected int nextgridtorestart ( ) { if ( currrestartgridid == servercount ( ) ) currrestartgridid = _num ; return ++ currrestartgridid ; }	return the index of the next grid to restart .
private void removestaleiteratorreferences ( ) { removestalereferences ( iteratorreferencequeue , iterators ) ; }	remove stale iterator references from the iterator list .
boolean destroyigroup ( boolean force ) { naelement elem = new naelement ( _str ) ; elem . addnewchild ( _str , name ) ; elem . addnewchild ( _str , boolean . tostring ( force ) ) ; try { server . invokeelem ( elem ) ; } catch ( exception e ) { string msg = _str + name ; log . error ( msg , e ) ; throw new netappexception ( msg , e ) ; } return _bool ; }	destroys an initiator group.
@ override public double finitedifferenceepsilon ( ) { return _num ; }	default epsilon for finite difference method :.
public void remove ( final httpconnection connection ) { log . debug ( _str + connection . getid ( ) ) ; connectiontoadded . remove ( connection ) ; }	removes the given connection from the list of connections to be closed when idle .
public void putbyte ( long pos , byte val ) { unsafe . putbyte ( pos + addr , val ) ; }	writes a byte to the specified position .
public void addreference ( messagepart reference ) { references . add ( reference ) ; }	adds a reference to the manifest.
protected datetimedata parse ( string str ) throws schemadatetimeexception { datetimedata date = new datetimedata ( str , this ) ; int len = str . length ( ) ; if ( str . charat ( _num ) != _str || str . charat ( _num ) != _str || str . charat ( _num ) != _str ) { throw new schemadatetimeexception ( _str ) ; } date . year = year ; date . month = month ; date . day = parseint ( str , _num , _num ) ; if ( day_size < len ) { if ( ! isnextcharutcsign ( str , day_size , len ) ) { throw new schemadatetimeexception ( _str ) ; } else { gettimezone ( str , date , day_size , len ) ; } } validatedatetime ( date ) ; saveunnormalized ( date ) ; if ( date . utc != _num && date . utc != _str ) { normalize ( date ) ; } date . position = _num ; return date ; }	parses , validates and computes normalized version of gday object.
private void updateperiod ( ) { for ( int i = _num ; i < mconversion . size ( ) ; i ++ ) { int datetype = mconversion . keyat ( i ) ; timeperiodslider slider = mtimeperiodsliders . get ( datetype ) ; slider . setvalue ( mperiod . get ( mconversion . valueat ( i ) ) ) ; } mtime . settext ( getformattedperiod ( ) ) ; mduration = mperiod . tostandardduration ( ) ; dovalidation ( ) ; }	updates the view to reflect changes in the period object.
public long start_brk ( ) { return long . parselong ( fields [ _num ] ) ; }	( since linux 3.
public static void validateparticipantidsequal ( string expectedparticipantid , string actualparticipantid ) throws cryptoexception { if ( ! expectedparticipantid . equals ( actualparticipantid ) ) { throw new cryptoexception ( _str + actualparticipantid + _str + expectedparticipantid + _str ) ; } }	validates that the given participant ids are equal.
protected void encodefields ( mxcodec enc , object obj , node node ) { class type = obj . getclass ( ) ; while ( type != null ) { field [ ] fields = type . getdeclaredfields ( ) ; for ( int i = _num ; i < fields . length ; i ++ ) { field f = fields [ i ] ; if ( ( f . getmodifiers ( ) & modifier . transient ) != modifier . transient ) { string fieldname = f . getname ( ) ; object value = getfieldvalue ( obj , fieldname ) ; encodevalue ( enc , obj , fieldname , value , node ) ; } } type = type . getsuperclass ( ) ; } }	encodes the declared fields of the given object into the given node .
public void addvetoablechangelistener ( string propertyname , vetoablechangelistener in_vcl ) { beancontextchildsupport . addvetoablechangelistener ( propertyname , in_vcl ) ; }	method for beancontextchild interface .
private void logmissingresource ( facescontext ctx , string resourceid , throwable t ) { level level ; if ( ! ctx . isprojectstage ( projectstage . production ) ) { level = level . warning ; } else { level = ( ( t != null ) ? level . warning : level . fine ) ; } if ( logger . isloggable ( level ) ) { logger . log ( level , _str , new object [ ] { resourceid } ) ; if ( t != null ) { logger . log ( level , _str , t ) ; } } }	log a message indicating a particular resource ( reference by name and / or library ) could not be found.
private void appendaliasedcolumn ( stringbuilder sb , string colname , string talias ) { if ( talias != null ) { sb . append ( talias ) ; sb . append ( _str ) ; } sb . append ( _str ) ; sb . append ( colname ) ; sb . append ( _str ) ; }	appends a quoted column name , prepending a table alias if necessary.
private midievent createscheduledevent ( byte [ ] msg , int offset , int count , long timestamp ) { midievent event ; if ( count > pool_event_size ) { event = new midievent ( msg , offset , count , timestamp ) ; } else { event = ( midievent ) removeeventfrompool ( ) ; if ( event == null ) { event = new midievent ( pool_event_size ) ; } system . arraycopy ( msg , offset , event . data , _num , count ) ; event . count = count ; event . settimestamp ( timestamp ) ; } return event ; }	create an event that contains the message .
public void startelement ( string namespaceuri , string localname , string qname , attributes atts ) throws saxexception { try { elemtype = ( saxhandlerbase . elementtype ) elementtypes . get ( localname ) ; if ( gathermode ) { if ( gatheringelement . gatherelement ( localname , atts ) ) { gatherbuffer . add ( new object [ ] { elemtype , new attributesimpl ( atts ) } ) ; } } else { if ( elemtype == null ) { return ; } elemtype . startelement ( atts ) ; } elems . add ( elemtype ) ; } catch ( saxexception saxex ) { throw saxex ; } catch ( exception ex ) { throw new saxexception ( ex ) ; } }	description of the method.
public static byte [ ] gzip ( string input ) { bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; gzipoutputstream gzos = null ; try { gzos = new gzipoutputstream ( baos ) ; gzos . write ( input . getbytes ( _str ) ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } finally { if ( gzos != null ) try { gzos . close ( ) ; } catch ( ioexception ignore ) { } } return baos . tobytearray ( ) ; }	gzip compress a string of bytes.
public static double logpdf ( double x , double m , double shape ) { double a = math . sqrt ( shape / ( _num * math . pi * x * x * x ) ) ; double b = ( ( - shape ) * ( x - m ) * ( x - m ) ) / ( _num * m * m * x ) ; return math . log ( a ) + b ; }	the natural log of the probability density function of the distribution.
public void addedgeconnector ( ) { numedgeconnectors ++ ; string name = _str ; boolean duplicate = _bool ; while ( duplicate ) { name = _str + numedgeconnectors ; if ( finder . findpositionablepointbyname ( name ) == null ) { duplicate = _bool ; } if ( duplicate ) { numedgeconnectors ++ ; } } positionablepoint o = new positionablepoint ( name , positionablepoint . edge_connector , currentpoint , this ) ; pointlist . add ( o ) ; setdirty ( _bool ) ; }	add an edge connector point .
@ requestmapping ( value = { _str , _str } , method = requestmethod . get ) @ responsebody public restwrapper list ( @ requestparam ( value = _str , defaultvalue = _str ) int startpage , @ requestparam ( value = _str , defaultvalue = _str ) int pagesize , principal principal ) { restwrapper restwrapper = null ; try { integer counter = workflowtypedao . totalrecordcount ( ) ; list < workflowtype > workflowtypes = new arraylist < workflowtype > ( ) ; list < com . wipro . ats . bdre . md . dao . jpa . workflowtype > jpaworkflowtypes = workflowtypedao . list ( startpage , pagesize ) ; for ( com . wipro . ats . bdre . md . dao . jpa . workflowtype wftype : jpaworkflowtypes ) { workflowtype workflowtype = new workflowtype ( ) ; workflowtype . setworkflowid ( wftype . getworkflowid ( ) ) ; workflowtype . setworkflowtypename ( wftype . getworkflowtypename ( ) ) ; workflowtype . setcounter ( counter ) ; workflowtypes . add ( workflowtype ) ; } restwrapper = new restwrapper ( workflowtypes , restwrapper . ok ) ; logger . info ( _str + principal . getname ( ) ) ; } catch ( exception e ) { logger . error ( e ) ; restwrapper = new restwrapper ( e . getmessage ( ) , restwrapper . error ) ; } return restwrapper ; }	this method calls proc getworkflowtypes and fetches the list of instances of workflowtype .
public void parseforclass ( genericdeclaration genericdecl , string signature ) { setinput ( genericdecl , signature ) ; if ( ! eof ) { parseclasssignature ( ) ; } else { if ( genericdecl instanceof class ) { class c = ( class ) genericdecl ; this . formaltypeparameters = emptyarray . type_variable ; this . superclasstype = c . getsuperclass ( ) ; class < ? > [ ] interfaces = c . getinterfaces ( ) ; if ( interfaces . length == _num ) { this . interfacetypes = listoftypes . empty ; } else { this . interfacetypes = new listoftypes ( interfaces ) ; } } else { this . formaltypeparameters = emptyarray . type_variable ; this . superclasstype = object . class ; this . interfacetypes = listoftypes . empty ; } } }	parses the generic signature of a class and creates the data structure representing the signature .
static boolean tryexternalunpush ( forkjointask < ? > t ) { forkjoinpool p ; workqueue [ ] ws ; workqueue q ; submitter z ; forkjointask < ? > [ ] a ; int m , s ; if ( t != null && ( z = submitters . get ( ) ) != null && ( p = commonpool ) != null && ( ws = p . workqueues ) != null && ( m = ws . length - _num ) >= _num && ( q = ws [ m & z . seed & sqmask ] ) != null && ( s = q . top ) != q . base && ( a = q . array ) != null ) { long j = ( ( ( a . length - _num ) & ( s - _num ) ) << ashift ) + abase ; if ( u . getobject ( a , j ) == t && u . compareandswapint ( q , qlock , _num , _num ) ) { if ( q . array == a && q . top == s && u . compareandswapobject ( a , j , t , null ) ) { q . top = s - _num ; q . qlock = _num ; return _bool ; } q . qlock = _num ; } } return _bool ; }	tries to pop the given task from submitter ' s queue in common pool .
public static double [ ] quantiles ( int n , double [ ] values ) { values = ( double [ ] ) values . clone ( ) ; arrays . sort ( values ) ; double [ ] qtls = new double [ n + _num ] ; for ( int i = _num ; i <= n ; ++ i ) { qtls [ i ] = values [ ( ( values . length - _num ) * i ) / n ] ; } return qtls ; }	compute the n - quantile boundaries for a set of values.
public queryexception ( string message , int errorcode , sqlstates sqlstate , throwable cause ) { super ( message , cause ) ; this . message = message ; this . errorcode = errorcode ; this . sqlstate = sqlstate . getsqlstate ( ) ; }	creates a query exception with a message and a cause .
public void testconstructorstringradix16 ( ) { string value = _str ; int radix = _num ; byte rbytes [ ] = { _num , - _num , _num , _num , - _num , _num , - _num , - _num } ; biginteger anumber = new biginteger ( value , radix ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = anumber . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , anumber . signum ( ) ) ; }	create a positive number from a string value and radix 16 .
private csvdata ( list < csvrecord > records ) { this . records = objects . requirenonnull ( records ) ; }	creates a new instance with the given records .
private workflow . method untagvolumesmethod ( uri systemuri , list < uri > volumeuris ) { return new workflow . method ( _str , systemuri , volumeuris ) ; }	return a workflow . method for untagvolumes .
private byte [ ] sha256hash ( byte [ ] tobehashed ) { sha256digest digester = new sha256digest ( ) ; byte [ ] retvalue = new byte [ digester . getdigestsize ( ) ] ; digester . update ( tobehashed , _num , tobehashed . length ) ; digester . dofinal ( retvalue , _num ) ; return retvalue ; }	this is the sha - 256 hashing function that is performed on the public key.
@ dataprovider private static object [ ] [ ] okresourceresponses ( ) { return new object [ ] [ ] { { new response ( ok ) } , { new response ( found ) } , { new response ( moved_permanently ) } , { new response ( created ) } } ; }	all successful responses are returned without any process . ( not a 5xx server error or a 4xx client error ).
public synchronized void connect ( ) { if ( ! _zkconnection . isstarted ( ) ) { _zkconnection . start ( ) ; } if ( stringutils . isempty ( siteid ) ) { generatesiteid ( ) ; } }	connect to zk cluster.
static object convertjavatimetojavasql ( object x ) { if ( x instanceof localdate ) { return date . valueof ( ( localdate ) x ) ; } else if ( x instanceof localdatetime ) { return timestamp . valueof ( ( localdatetime ) x ) ; } else if ( x instanceof localtime ) { return time . valueof ( ( localtime ) x ) ; } return x ; }	jdbc 4 . 2 helper methods .
@ notnull private static defaultmutabletreenode updatetreestructure ( @ notnull defaultmutabletreenode treenode , @ notnull zipfile compressedapk ) { long compressedsize = _num ; apkentry entry = apkentry . fromnode ( treenode ) ; assert entry != null ; if ( treenode . getchildcount ( ) > _num ) { for ( int i = _num ; i < treenode . getchildcount ( ) ; i ++ ) { defaultmutabletreenode childnode = updatetreestructure ( ( defaultmutabletreenode ) treenode . getchildat ( i ) , compressedapk ) ; compressedsize += ( ( apkentry ) childnode . getuserobject ( ) ) . getcompressedsize ( ) ; } } else { zipentry ze = compressedapk . getentry ( apkfilesystem . getinstance ( ) . getrelativepath ( entry . getfile ( ) ) ) ; if ( ze == null ) { compressedsize = - _num ; } else { compressedsize = ze . getcompressedsize ( ) ; } } entry . setcompressedsize ( compressedsize ) ; return treenode ; }	updates and returns the given tree structure with info about the compressed size of each node .
public long totalmemory ( ) { return totalmemoryimpl ( ) ; }	returns the total amount of memory in the java virtual machine.
public static void enablesync ( string accountname ) { }	enables sync feature in mytracks settings .
public static void scan ( ) { list < scannerregistration > scanners = getscannerstorun ( ) ; if ( scanners . size ( ) > _num ) { url [ ] urls = getsearchurls ( ) ; if ( urls == null ) { urls = fiterlibs ( scannerurls . geturlsforsearch ( ) ) ; scan ( scanners , urls ) ; } else { scan ( scanners , urls ) ; } } }	scan the project and returns the result associated to the given scanner.
public final void turnto ( double angle ) { angle = geometric . clampangledegree ( angle ) ; orientation = geometric . clampangledegree ( angle ) ; geometric . rotateto ( velocity , math . toradians ( orientation ) ) ; }	turn the agent to the given angle given in degrees .
protected int startbridgeserver ( int port , boolean notifybysubscription ) throws ioexception { cache cache = getcache ( ) ; cacheserver bridge = cache . addcacheserver ( ) ; bridge . setport ( port ) ; bridge . setnotifybysubscription ( notifybysubscription ) ; bridge . start ( ) ; bridgeserverport = bridge . getport ( ) ; return bridge . getport ( ) ; }	starts a bridge server on the given port , using the given deserializevalues and notifybysubscription to serve up the given region .
protected object totype ( calendar value ) { return value . gettime ( ) ; }	convert from a calendar to the appropriate date type.
protected f restorelastfilter ( int dialogtype ) { f result ; list < f > list ; int i ; result = null ; if ( dialogtype == open_dialog ) list = getopenfilefilters ( ) ; else list = getsavefilefilters ( ) ; if ( list . size ( ) > _num ) { result = getdefaultfilefilter ( dialogtype ) ; setfilefilter ( result ) ; if ( m_lastfilter != null ) { for ( i = _num ; i < list . size ( ) ; i ++ ) { if ( m_comparator . compare ( list . get ( i ) , m_lastfilter ) == _num ) { result = ( f ) m_lastfilter ; setfilefilter ( m_lastfilter ) ; break ; } } } } return result ; }	attempts to restore the last filter in use .
public void testcharbasedcollisions ( ) { charstonamecanonicalizer sym = charstonamecanonicalizer . createroot ( ) ; try { int firsthash = _num ; for ( string str : char_collisions ) { int hash = sym . calchash ( str ) ; if ( firsthash == _num ) { firsthash = hash ; } else { assertequals ( firsthash , hash ) ; } sym . findsymbol ( str . tochararray ( ) , _num , str . length ( ) , hash ) ; } fail ( _str ) ; } catch ( illegalstateexception e ) { verifyexception ( e , _str ) ; assertequals ( charstonamecanonicalizer . max_coll_chain_length + _num , sym . maxcollisionlength ( ) ) ; assertequals ( charstonamecanonicalizer . max_coll_chain_length + _num , sym . collisioncount ( ) ) ; assertequals ( charstonamecanonicalizer . max_coll_chain_length + _num , sym . size ( ) ) ; } }	test to see what happens with pre - computed collisions ; should get an exception .
public void handletbldatasiteactionhrefrequest ( requestinvocationevent event ) throws modelcontrolexception { string sitename = hextostring ( ( string ) getdisplayfieldvalue ( tbl_data_site_action_href ) ) ; setpagesessionattribute ( siteeditviewbean . pg_attr_site_name , sitename ) ; siteeditviewbean vb = ( siteeditviewbean ) getviewbean ( siteeditviewbean . class ) ; unlockpagetrail ( ) ; passpgsessionmap ( vb ) ; vb . forwardto ( getrequestcontext ( ) ) ; }	handles edit site request .
public static void normalize ( double [ ] doubles , double sum ) { if ( double . isnan ( sum ) ) { throw new illegalargumentexception ( _str ) ; } if ( sum == _num ) { throw new illegalargumentexception ( _str ) ; } for ( int i = _num ; i < doubles . length ; i ++ ) { doubles [ i ] /= sum ; } }	normalizes the doubles in the array using the given value .
private void expandarray ( int shardid ) { int newnumshards = math . max ( ( int ) math . ceil ( numshards * shard_growth_factor ) , shardid + _num ) ; preconditions . checkargument ( newnumshards * shardlength < integer . max_value , _str ) ; int [ ] [ ] newarray = new int [ newnumshards ] [ ] ; system . arraycopy ( readeraccessibleinfo . array , _num , newarray , _num , readeraccessibleinfo . array . length ) ; readeraccessibleinfo = new readeraccessibleinfo ( newarray ) ; numshards = newnumshards ; }	synchronization comment : this method works fine without needing synchronization between the writer and the readers due to the wrapping of the arrays in readeraccessibleinfo.
protected < t > t waitforpropertyvalue ( string documentselflink , class < t > type , string propname , object propvalue , boolean shouldmatch , atomicinteger count ) throws throwable { @ suppresswarnings ( _str ) list < object > prop = propvalue instanceof list ? ( list < object > ) propvalue : arrays . aslist ( propvalue ) ; return waitforpropertyvalue ( documentselflink , type , propname , prop , shouldmatch , count ) ; }	waits until the specified document field matches the given value or differs from the given value.
public static string fromipv4addresscollection ( collection < integer > ipaddresses ) { if ( ipaddresses == null ) return _str ; stringbuffer sb = new stringbuffer ( ) ; sb . append ( _str ) ; for ( integer ip : ipaddresses ) { sb . append ( fromipv4address ( ip ) ) ; sb . append ( _str ) ; } sb . replace ( sb . length ( ) - _num , sb . length ( ) , _str ) ; return sb . tostring ( ) ; }	accepts a collection of ipv4 addresses as integers and returns a single string useful in tostring method ' s containing collections of ip addresses .
public static final string makejavaidentifier ( string identifier ) { stringbuilder modifiedidentifier = new stringbuilder ( identifier . length ( ) ) ; if ( ! character . isjavaidentifierstart ( identifier . charat ( _num ) ) ) { modifiedidentifier . append ( _str ) ; } for ( int i = _num ; i < identifier . length ( ) ; i ++ ) { char ch = identifier . charat ( i ) ; if ( character . isjavaidentifierpart ( ch ) && ch != _str ) { modifiedidentifier . append ( ch ) ; } else if ( ch == _str ) { modifiedidentifier . append ( _str ) ; } else { modifiedidentifier . append ( manglechar ( ch ) ) ; } } if ( isjavakeyword ( modifiedidentifier . tostring ( ) ) ) { modifiedidentifier . append ( _str ) ; } return modifiedidentifier . tostring ( ) ; }	converts the given identifier to a legal java identifier.
public static string encrypt ( string input ) { if ( encryptionservice == null || input == null || input . length ( ) == _num ) { return input ; } return encryption_prefix + encryptionservice . encrypt ( input ) ; }	encrypts the provided string .
public static void createfederatednamespace ( uri namespace , zookeeperclient zkc ) throws interruptedexception , zookeeperclient . zookeeperconnectionexception , keeperexception { string zksubnamespacespath = namespace . getpath ( ) + _str + znode_sub_namespaces ; utils . zkcreatefullpathoptimistic ( zkc , zksubnamespacespath , new byte [ _num ] , zkc . getdefaultacl ( ) , createmode . persistent ) ; }	create the federated namespace .
public string process ( ) { while ( off < count ) { while ( off < count ) { char ch = text [ off ] ; if ( ! isspecial ( ch ) ) { break ; } off ++ ; } if ( ! acronym ( ) ) { token ( ) ; number ( ) ; } } return builder . tostring ( ) ; }	this is used to process the internal string and convert it in to a styled string.
public static string bytestobinhex ( byte [ ] data , int nstartpos , int nnumofbytes ) { stringbuilder sbuf = new stringbuilder ( ) ; sbuf . setlength ( nnumofbytes << _num ) ; int npos = _num ; for ( int ni = _num ; ni < nnumofbytes ; ni ++ ) { sbuf . setcharat ( npos ++ , hextab [ ( data [ ni + nstartpos ] > > _num ) & _num ] ) ; sbuf . setcharat ( npos ++ , hextab [ data [ ni + nstartpos ] & _num ] ) ; } return sbuf . tostring ( ) ; }	converts a byte array to a binhex string.
public static void updatelast ( ) { clientutils . lastupdate = system . currenttimemillis ( ) ; }	update the current time .
public replicasets ( collection < replicaset > rsspecs ) { if ( rsspecs != null ) { rsspecs . foreach ( null ) ; } collections . sort ( nonreplicasets ) ; }	create a set of replica set specifications .
static private string byte_max ( ) { byte tempvalue = byte . max_value ; return string . valueof ( tempvalue ) ; }	get the max value for a byte.
protected pathnode pathnode ( string pattern ) { final string seq [ ] = pattern . split ( _str ) ; final pathelt elements [ ] = new pathelt [ seq . length ] ; pathmod mod = null ; for ( int i = _num ; i < seq . length ; i ++ ) { final string s = seq [ i ] ; boolean inverse = s . charat ( _num ) == _str ; switch ( s . charat ( s . length ( ) - _num ) ) { case _str : mod = pathmod . zero_or_more ; break ; case _str : mod = pathmod . one_or_more ; break ; case _str : mod = pathmod . zero_or_one ; break ; } string c = s . substring ( inverse ? _num : _num , s . length ( ) - ( mod != null ? _num : _num ) ) ; elements [ i ] = new pathelt ( constantnode ( c ) , inverse , mod ) ; } return new pathnode ( new pathalternative ( new pathsequence ( elements ) ) ) ; }	this method is only implemented in part.
@ override public int startupnewworker ( int priority ) { int actualworkersstarted = startupnewworker ( priority , null , null ) ; return actualworkersstarted ; }	runs a new worker jvm , by whatever mechanism ( e.
public void addimplinterface ( string iname ) { implinterfaces . add ( iname ) ; }	adds implemented interface name .
private static synchronized boolean checkfolderpermissions ( stringbuilder astringbuilder , string adirectory ) { file directory = new file ( adirectory ) ; if ( ! directory . exists ( ) ) { directory . mkdirs ( ) ; } if ( ! directory . canread ( ) ) { astringbuilder . append ( _str + directory + _str + _str ) ; return _bool ; } if ( ! directory . canwrite ( ) ) { astringbuilder . append ( _str + directory + _str + _str ) ; return _bool ; } return _bool ; }	checks if a directory already exists.
protected qualifieditem [ ] parsequalifieditems ( final string [ ] arguments , final versionspec defaultversion , final boolean allowversionrange , final int startindex ) { check . notnull ( arguments , _str ) ; final list < qualifieditem > items = new arraylist < qualifieditem > ( arguments . length ) ; for ( int i = startindex ; i < arguments . length ; i ++ ) { final string arg = arguments [ i ] ; if ( ! stringutil . isnullorempty ( arg ) ) { try { final qualifieditem qi = new qualifieditem ( arg , versioncontrolconstants . authenticated_user , defaultversion , allowversionrange ) ; items . add ( qi ) ; } catch ( final versionspecparseexception e ) { reportwrongargument ( arg , e ) ; } catch ( final labelspecparseexception e ) { reportwrongargument ( arg , e ) ; } } } return items . toarray ( new qualifieditem [ items . size ( ) ] ) ; }	parses qualified items ( item specs with optional versions , version ranges , or deletion specifiers ) from the given strings .
public eipeditor ( ) { super ( ) ; initializeeditingdomain ( ) ; }	this creates a model editor . < ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
public boolean deleteentry ( basicpoolentry entry ) { final boolean found = freeentries . remove ( entry ) ; if ( found ) numentries -- ; return found ; }	deletes an entry from this pool.
public conversationservice ( final string versiondate , string username , string password ) { this ( versiondate ) ; setusernameandpassword ( username , password ) ; }	returns an instance of the conversation service using the service ' s default endpoint ( url ) , username and password .
public customoptional < kinesisrecord > next ( ) throws transientkinesisexception { readmoreifnecessary ( ) ; if ( data . isempty ( ) ) { return customoptional . absent ( ) ; } else { kinesisrecord record = data . removefirst ( ) ; checkpoint = checkpoint . moveafter ( record ) ; return customoptional . of ( record ) ; } }	returns record if there ' s any present.
private snmppdupacket executesubrequest ( snmppdupacket req , object userdata ) { int errorstatus = snmpdefinitions . snmprspnoerror ; int i ; if ( req . type == pdusetrequestpdu ) { i = _num ; for ( enumeration < snmpsubrequesthandler > e = subs . elements ( ) ; e . hasmoreelements ( ) ; i ++ ) { snmpsubrequesthandler sub = e . nextelement ( ) ; sub . setuserdata ( userdata ) ; sub . type = pduwalkrequest ; sub . run ( ) ; sub . type = pdusetrequestpdu ; if ( sub . geterrorstatus ( ) != snmpdefinitions . snmprspnoerror ) { if ( snmp_adaptor_logger . isloggable ( level . finest ) ) { snmp_adaptor_logger . logp ( level . finest , dbgtag , _str , _str ) ; } return newerrorresponsepdu ( req , errorstatus , sub . geterrorindex ( ) + _num ) ; } } } i = _num ; for ( enumeration < snmpsubrequesthandler > e = subs . elements ( ) ; e . hasmoreelements ( ) ; i ++ ) { snmpsubrequesthandler sub = e . nextelement ( ) ; sub . setuserdata ( userdata ) ; sub . run ( ) ; if ( sub . geterrorstatus ( ) != snmpdefinitions . snmprspnoerror ) { if ( snmp_adaptor_logger . isloggable ( level . finest ) ) { snmp_adaptor_logger . logp ( level . finest , dbgtag , _str , _str ) ; } return newerrorresponsepdu ( req , errorstatus , sub . geterrorindex ( ) + _num ) ; } } return null ; }	the method runs all the sub - requests associated to the current instance of snmprequesthandler .
method ( methoddoc methoddoc ) { this . methoddoc = methoddoc ; exceptiontypes = methoddoc . thrownexceptions ( ) ; arrays . sort ( exceptiontypes , new classdoccomparator ( ) ) ; operationstring = computeoperationstring ( ) ; nameanddescriptor = methoddoc . name ( ) + util . methoddescriptorof ( methoddoc ) ; methodhash = computemethodhash ( ) ; }	creates a new method instance for the specified method .
public deterministickey ( immutablelist < childnumber > childnumberpath , byte [ ] chaincode , lazyecpoint publicaspoint , @ nullable biginteger priv , @ nullable deterministickey parent ) { super ( priv , compresspoint ( checknotnull ( publicaspoint ) ) ) ; checkargument ( chaincode . length == _num ) ; this . parent = parent ; this . childnumberpath = checknotnull ( childnumberpath ) ; this . chaincode = arrays . copyof ( chaincode , chaincode . length ) ; this . depth = parent == null ? _num : parent . depth + _num ; this . parentfingerprint = ( parent != null ) ? parent . getfingerprint ( ) : _num ; }	constructs a key from its components.
private static void s_uacolsumltge ( matrixblock in , matrixblock out , double [ ] bv , binaryoperator bop ) throws dmlruntimeexception { int agg0 = sumrowsumgtlecolsumltge ( _num , bv , bop ) ; out . allocatedenseblock ( _bool ) ; arrays . fill ( out . getdenseblock ( ) , _num , out . getnumcolumns ( ) , agg0 ) ; if ( agg0 != _num ) out . setnonzeros ( out . getnumcolumns ( ) ) ; if ( in . isemptyblock ( _bool ) ) return ; sparseblock sblock = in . getsparseblock ( ) ; for ( int j = _num ; j < sblock . numrows ( ) ; j ++ ) if ( ! sblock . isempty ( j ) ) { int apos = sblock . pos ( j ) ; int alen = sblock . size ( j ) ; int [ ] aix = sblock . indexes ( j ) ; double [ ] avals = sblock . values ( j ) ; for ( int i = apos ; i < apos + alen ; i ++ ) { int cnt = sumrowsumgtlecolsumltge ( avals [ i ] , bv , bop ) ; out . quicksetvalue ( _num , aix [ i ] , cnt ) ; } } }	uagg colsums sparse matrix for lessthan and greaterthanequal operator.
public heldlocksgrant ( biginteger grantid ) { this . grantid = preconditions . checknotnull ( grantid ) ; creationdatems = system . currenttimemillis ( ) ; expirationdatems = - _num ; lockmap = lockcollections . of ( ) ; locktimeout = null ; versionid = null ; }	these grants should not be constructed by users.
public void testposnegfirstshorter ( ) { byte abytes [ ] = { - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { - _num , _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , - _num , _num , _num , - _num , - _num } ; int asign = _num ; int bsign = - _num ; byte rbytes [ ] = { _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . and ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	and for a positive and a negative numbers ; the first is shorter.
public void removefromalllisteners ( mapbean mapbean ) { if ( mapbean != null ) { removezoomlistener ( ( zoomlistener ) mapbean ) ; mapbean . removeprojectionlistener ( this ) ; scalefield . settext ( _str ) ; } }	this function removes the mapbean object from its set of listeners.
public void testbug19169 ( ) throws exception { mysqldatasource toserialize = new mysqldatasource ( ) ; toserialize . setzerodatetimebehavior ( _str ) ; boolean testbooleanflag = ! toserialize . getallowloadlocalinfile ( ) ; toserialize . setallowloadlocalinfile ( testbooleanflag ) ; int testintflag = toserialize . getblobsendchunksize ( ) + _num ; toserialize . setblobsendchunksize ( string . valueof ( testintflag ) ) ; bytearrayoutputstream bout = new bytearrayoutputstream ( ) ; objectoutputstream objout = new objectoutputstream ( bout ) ; objout . writeobject ( toserialize ) ; objout . flush ( ) ; objectinputstream objin = new objectinputstream ( new bytearrayinputstream ( bout . tobytearray ( ) ) ) ; mysqldatasource thawedds = ( mysqldatasource ) objin . readobject ( ) ; assertequals ( _str , thawedds . getzerodatetimebehavior ( ) ) ; assertequals ( testbooleanflag , thawedds . getallowloadlocalinfile ( ) ) ; assertequals ( testintflag , thawedds . getblobsendchunksize ( ) ) ; }	tests fix for bug # 19169 - connectionproperties ( and thus some subclasses ) are not serializable , even though some j2ee containers expect them to be .
public static < t > futurew < t > ofsupplier ( final supplier < t > s ) { return futurew . of ( completablefuture . supplyasync ( s ) ) ; }	create a futurew object that asyncrhonously populates using the common forkjoinpool from the user provided supplier.
@ override public void todata ( dataoutput out ) throws ioexception { super . todata ( out ) ; out . writelong ( refreshinterval ) ; dataserializer . writeobjectarray ( alertdefs , out ) ; }	a callback used by gemfire data serialization mechanism to write to a stream .
public static boolean isstring ( string str ) { return null != stringhashtable . get ( str ) ; }	a hash table containing all the string tokens found in the spec.
protected abstract void performdeployeractiononsingledeployable ( org . codehaus . cargo . container . deployer . deployer deployer , org . codehaus . cargo . container . deployable . deployable deployable , org . codehaus . cargo . container . deployer . deployablemonitor monitor ) ;	perform a deployer action on a single deployable .
@ override public tree < string > extractbestmaxruleparse ( int start , int end , list < string > sentence ) { return extractbestmaxruleparse1 ( start , end , _num , sentence ) ; }	returns the best parse , the one with maximum expected labelled recall.
private instances votedataset ( instances dataset ) throws exception { for ( int i = _num ; i < dataset . numinstances ( ) ; i ++ ) { instance inst = dataset . firstinstance ( ) ; inst = votedreclassifyexample ( inst ) ; dataset . add ( inst ) ; dataset . delete ( _num ) ; } return dataset ; }	resets the class values of all instances using voting.
@ override public string chooseclientalias ( final string [ ] keytype , final principal [ ] issuers , final socket socket ) { if ( keymanager != null ) { return keymanager . chooseclientalias ( keytype , issuers , socket ) ; } return null ; }	choose an alias to authenticate the client side of a secure socket given the public key type and the list of certificate issuer authorities recognized by the peer ( if any ) .
csselement parsecss ( inputstreamreader r , htmlcomponent htmlc ) throws ioexception { extinputstreamreader er = new extinputstreamreader ( r ) ; return parsecss ( er , htmlc , null , null ) ; }	reads a css file / stream and returns the tokenized css as a single level element tree with the root appearing as a " style ".
protected pooledconnection create ( boolean incrementcounter ) { if ( incrementcounter ) size . incrementandget ( ) ; pooledconnection con = new pooledconnection ( getpoolproperties ( ) , this ) ; return con ; }	create a new pooled connection object.
void release ( ) { if ( sdbuffer != null ) sdbuffer . release ( ) ; if ( aclbuffer != null ) aclbuffer . release ( ) ; if ( sidlist != null ) { for ( long sid : sidlist ) { localfree ( sid ) ; } } }	releases memory associated with securitydescriptor.
private void parsesessionexpirationtimeinfo ( element sess ) { string sid = null ; long exptime = null ; string temp = sess . getattribute ( _str ) ; if ( temp != null ) { sid = temp ; } temp = sess . getattribute ( _str ) ; if ( temp != null ) { exptime = new long ( temp ) ; } sessionresponse . addsessionforgivenuuid ( sid , exptime ) ; }	parses all the sessions expiration for the given user .
public static long generate ( string value ) { int len = value . length ( ) ; long crc = _num ; for ( int i = _num ; i < len ; i ++ ) crc = next ( crc , value . charat ( i ) ) ; return crc ; }	calculates crc from a string .
public replacedialog ( jtextcomponent text , findreplaceactions finderactions ) { super ( actionutils . getframefor ( text ) , _bool ) ; initcomponents ( ) ; registerkeyaction ( this ) ; textcomponent = text ; finder = finderactions ; textcomponent . addcaretlistener ( this ) ; setlocationrelativeto ( text . getrootpane ( ) ) ; }	creates new form finddialog.
public string dump ( x509certificate certificate ) throws asn1exception , ioexception { try { return dump ( certificate . getencoded ( ) ) ; } catch ( ioexception ex ) { throw new asn1exception ( res . getstring ( _str ) , ex ) ; } catch ( certificateencodingexception ex ) { throw new asn1exception ( res . getstring ( _str ) , ex ) ; } }	get dump of the supplied x.
list < string > findinpackage ( test test , string packagename ) { list < string > localclsssorpkgs = new arraylist < string > ( ) ; packagename = packagename . replace ( _str , _str ) ; enumeration < url > urls ; try { urls = classloader . getresources ( packagename ) ; if ( ! urls . hasmoreelements ( ) ) { log . warn ( _str + packagename + _str ) ; } } catch ( ioexception ioe ) { log . warn ( _str + packagename ) ; return localclsssorpkgs ; } return findinpackagewithurls ( test , packagename , urls ) ; }	scans for classes starting at the package provided and descending into subpackages.
protected abstract element maketooltip ( dbidref id , double x , double y , double dotsize ) ;	make a tooltip element for this id .
public cloudobject ( string type , int permissions ) { accesspermissions = permissions ; values . put ( cloudstorage . type_field , type ) ; }	create an object with different permissions settings.
public double distance ( doublevector v ) { double deltax = v . x - x , deltay = v . y - y , deltaz = v . z - z ; return math . sqrt ( deltax * deltax + deltay * deltay + deltaz * deltaz ) ; }	calculates the squared distance between the point corresponding to this vector and the point corresponding to the vector v .
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( ) ; newvector . add ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . add ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . add ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . add ( new option ( _str + _str + _str + _str , _str , _num , _str ) ) ; newvector . add ( new option ( _str + _str + _str + _str + _str + _str , _str , _num , _str ) ) ; newvector . add ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . add ( new option ( _str + _str + _str , _str , _num , _str ) ) ; return newvector . elements ( ) ; }	lists the available options.
@ override public void dropuser ( user user , boolean ignore ) throws sqlexception { string sql = string . format ( _str , user . getlogin ( ) ) ; try { execute ( sql ) ; } catch ( sqlexception e ) { if ( ! ignore ) { throw e ; } else if ( logger . isdebugenabled ( ) ) { logger . debug ( _str + sql , e ) ; } } }	drops user , ignoring errors if desired by caller .
@ override public boolean eisset ( int featureid ) { switch ( featureid ) { case informationmodelpackage . functionblock_property__name : return name_edefault == null ? name != null : ! name_edefault . equals ( name ) ; case informationmodelpackage . functionblock_property__description : return description_edefault == null ? description != null : ! description_edefault . equals ( description ) ; case informationmodelpackage . functionblock_property__type : return type != null ; } return super . eisset ( featureid ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
public double normalizeddistance ( double [ ] point1 , double [ ] point2 ) throws exception { return math . sqrt ( distance2 ( point1 , point2 ) ) / point1 . length ; }	calculates the normalized euclidean distance between two points .
public static < t > void onnextdropped ( t t ) { if ( t != null ) { consumer < object > hook = hooks . onnextdroppedhook ; if ( hook == null ) { throw exceptions . failwithcancel ( ) ; } hook . accept ( t ) ; } }	an unexpected event is about to be dropped .
public static int [ ] randomints ( int max , int count ) { int [ ] vals = new int [ count ] ; for ( int i = _num ; i < count ; i ++ ) vals [ i ] = seeded_random . nextint ( max ) ; return vals ; }	return an array of length count containing random integers in the range ( 0 , max ) generated off the test rng .
void loadstrings ( ) throws ioexception { int count = mheaderitem . stringidssize ; int stringoffsets [ ] = new int [ count ] ; seek ( mheaderitem . stringidsoff ) ; for ( int i = _num ; i < count ; i ++ ) { stringoffsets [ i ] = readint ( ) ; } mstrings = new string [ count ] ; seek ( stringoffsets [ _num ] ) ; for ( int i = _num ; i < count ; i ++ ) { seek ( stringoffsets [ i ] ) ; mstrings [ i ] = readstring ( ) ; } }	loads the string table out of the dex.
public boolean addgpsdatetimestamptag ( long timestamp ) { exiftag t = buildtag ( tag_gps_date_stamp , mgpsdatestampformat . format ( timestamp ) ) ; if ( t == null ) { return _bool ; } settag ( t ) ; mgpstimestampcalendar . settimeinmillis ( timestamp ) ; t = buildtag ( tag_gps_time_stamp , new rational [ ] { new rational ( mgpstimestampcalendar . get ( calendar . hour_of_day ) , _num ) , new rational ( mgpstimestampcalendar . get ( calendar . minute ) , _num ) , new rational ( mgpstimestampcalendar . get ( calendar . second ) , _num ) } ) ; if ( t == null ) { return _bool ; } settag ( t ) ; return _bool ; }	creates and sets the gps timestamp tag .
public void addarea ( final timesection area ) { if ( null == area ) return ; areas . add ( area ) ; collections . sort ( areas , new timesectioncomparator ( ) ) ; fireupdateevent ( section_event ) ; }	adds the given timesection to the list of areas.
public string tostring ( ) { return descriptor . toclassname ( character . tostring ( descriptor ) ) ; }	returns the string representation .
private void raiseioexception ( string host , int port , string protocol ) { ioexceptionevent ioerror = new ioexceptionevent ( this , host , port , protocol ) ; sipprovider . handleevent ( ioerror , null ) ; setstate ( sipdialog . terminated_state ) ; }	raise an io exception for asyncrhonous retransmission of responses.
public static double incompletegammacomplement ( double a , double x ) { double ans , ax , c , yc , r , t , y , z ; double pk , pkm1 , pkm2 , qk , qkm1 , qkm2 ; if ( x <= _num || a <= _num ) return _num ; if ( x < _num || x < a ) return _num - incompletegamma ( a , x ) ; ax = a * math . log ( x ) - x - lngamma ( a ) ; if ( ax < - maxlog ) return _num ; ax = math . exp ( ax ) ; y = _num - a ; z = x + y + _num ; c = _num ; pkm2 = _num ; qkm2 = x ; pkm1 = x + _num ; qkm1 = z * x ; ans = pkm1 / qkm1 ; do { c += _num ; y += _num ; z += _num ; yc = y * c ; pk = pkm1 * z - pkm2 * yc ; qk = qkm1 * z - qkm2 * yc ; if ( qk != _num ) { r = pk / qk ; t = math . abs ( ( ans - r ) / r ) ; ans = r ; } else t = _num ; pkm2 = pkm1 ; pkm1 = pk ; qkm2 = qkm1 ; qkm1 = qk ; if ( math . abs ( pk ) > big ) { pkm2 *= biginv ; pkm1 *= biginv ; qkm2 *= biginv ; qkm1 *= biginv ; } } while ( t > machep ) ; return ans * ax ; }	returns the complemented incomplete gamma function .
@ override public object deserializetypedfromobject ( jsonparser jp , deserializationcontext ctxt ) throws ioexception , jsonprocessingexception { jsontoken t = jp . getcurrenttoken ( ) ; if ( t == jsontoken . start_object ) { t = jp . nexttoken ( ) ; } else if ( t == jsontoken . start_array ) { return _deserializetypedusingdefaultimpl ( jp , ctxt , null ) ; } else if ( t != jsontoken . field_name ) { return _deserializetypedusingdefaultimpl ( jp , ctxt , null ) ; } tokenbuffer tb = null ; for ( ; t == jsontoken . field_name ; t = jp . nexttoken ( ) ) { string name = jp . getcurrentname ( ) ; jp . nexttoken ( ) ; if ( _typepropertyname . equals ( name ) ) { string typeid = jp . gettext ( ) ; jsondeserializer < object > deser = _finddeserializer ( ctxt , typeid ) ; if ( tb != null ) { jp = jsonparsersequence . createflattened ( tb . asparser ( jp ) , jp ) ; } jp . nexttoken ( ) ; return deser . deserialize ( jp , ctxt ) ; } if ( tb == null ) { tb = new tokenbuffer ( null ) ; } tb . writefieldname ( name ) ; tb . copycurrentstructure ( jp ) ; } return _deserializetypedusingdefaultimpl ( jp , ctxt , tb ) ; }	this is the trickiest thing to handle , since property we are looking for may be anywhere.
protected int layoutrow ( flowview fv , int rowindex , int p0 ) { int p1 = super . layoutrow ( fv , rowindex , p0 ) ; view row = fv . getview ( rowindex ) ; document doc = fv . getdocument ( ) ; object i18nflag = doc . getproperty ( abstractdocument . i18nproperty ) ; if ( ( i18nflag != null ) && i18nflag . equals ( boolean . true ) ) { int n = row . getviewcount ( ) ; if ( n > _num ) { abstractdocument d = ( abstractdocument ) fv . getdocument ( ) ; element bidiroot = d . getbidirootelement ( ) ; byte [ ] levels = new byte [ n ] ; view [ ] reorder = new view [ n ] ; for ( int i = _num ; i < n ; i ++ ) { view v = row . getview ( i ) ; int bidiindex = bidiroot . getelementindex ( v . getstartoffset ( ) ) ; element bidielem = bidiroot . getelement ( bidiindex ) ; levels [ i ] = ( byte ) styleconstants . getbidilevel ( bidielem . getattributes ( ) ) ; reorder [ i ] = v ; } bidiutils . reordervisually ( levels , reorder ) ; row . replace ( _num , n , reorder ) ; } } return p1 ; }	creates a row of views that will fit within the layout span of the row.
public generator ( string propfile ) { try { bufferedinputstream bi = null ; try { bi = new bufferedinputstream ( new fileinputstream ( propfile ) ) ; props . load ( bi ) ; } finally { if ( bi != null ) { bi . close ( ) ; } } } catch ( exception e ) { setdefaultprops ( ) ; } }	create a new generator object with properties loaded from a file.
public static void clearloggingbehaviors ( ) { synchronized ( loggingbehaviors ) { loggingbehaviors . clear ( ) ; } }	certain logging behaviors are available for debugging beyond those that should be enabled in production.
protected void auditop ( uri tenantid , uri userid , operationtypeenum optype , boolean operationalstatus , string operationstage , object ... descparams ) { _auditmgr . recordauditlog ( tenantid , userid , event_service_type , optype , system . currenttimemillis ( ) , operationalstatus ? auditlogmanager . auditlog_success : auditlogmanager . auditlog_failure , operationstage , descparams ) ; }	record audit log for services.
@ visiblefortesting protected process startexecutorprocess ( int container ) { return shellutils . runasyncprocess ( getexecutorcommand ( container ) , new file ( localcontext . workingdirectory ( config ) ) , integer . tostring ( container ) ) ; }	start executor process via running an async shell process.
private boolean isitematpositionselectable ( int position ) { return ! munselectableitems . contains ( position ) ; }	return whether the item at position is selectable ( i.
public builder addenginesettings ( final string enginename , final list < string > imports , final list < string > staticimports , final list < string > scripts , final map < string , object > config ) { if ( null == imports ) throw new illegalargumentexception ( _str ) ; if ( null == staticimports ) throw new illegalargumentexception ( _str ) ; if ( null == scripts ) throw new illegalargumentexception ( _str ) ; final map < string , object > m = null == config ? collections . emptymap ( ) : config ; settings . put ( enginename , new enginesettings ( imports , staticimports , scripts , m ) ) ; return this ; }	add a particular script engine for the executor to instantiate .
private void displaypopupmenu ( final mouseevent event ) { final int selectedindex = getselectionindex ( event ) ; if ( selectedindex != - _num ) { final jpopupmenu popupmenu = getpopupmenu ( event . getx ( ) , event . gety ( ) , selectedindex ) ; if ( popupmenu != null ) { popupmenu . show ( this , event . getx ( ) , event . gety ( ) ) ; } } }	creates a popup menu depending on where the user clicked and shows that context menu in the table .
protected void handleselected ( structuredselection selection ) { istatus status = new status ( istatus . ok , platformui . plugin_id , istatus . ok , empty_string , null ) ; object [ ] lastselection = currentselection ; currentselection = selection . toarray ( ) ; if ( selection . size ( ) == _num ) { status = new status ( istatus . error , platformui . plugin_id , istatus . error , empty_string , null ) ; if ( lastselection != null && getlistselectionlabeldecorator ( ) != null ) { list . update ( lastselection , null ) ; } currentselection = null ; } else { status = new status ( istatus . error , platformui . plugin_id , istatus . error , empty_string , null ) ; list items = selection . tolist ( ) ; object item = null ; istatus tempstatus = null ; for ( iterator it = items . iterator ( ) ; it . hasnext ( ) ; ) { object o = it . next ( ) ; if ( o instanceof itemslistseparator ) { continue ; } item = o ; tempstatus = validateitem ( item ) ; if ( tempstatus . isok ( ) ) { status = new status ( istatus . ok , platformui . plugin_id , istatus . ok , empty_string , null ) ; } else { status = tempstatus ; break ; } } if ( lastselection != null && getlistselectionlabeldecorator ( ) != null ) { list . update ( lastselection , null ) ; } if ( getlistselectionlabeldecorator ( ) != null ) { list . update ( currentselection , null ) ; } } refreshdetails ( ) ; updatestatus ( status ) ; }	handle selection in the items list by updating labels of selected and unselected items and refresh the details field using the selection .
public linkedlist < diff > diff_main ( string text1 , string text2 , boolean checklines ) { long deadline ; if ( diff_timeout <= _num ) { deadline = long . max_value ; } else { deadline = system . currenttimemillis ( ) + ( long ) ( diff_timeout * _num ) ; } return diff_main ( text1 , text2 , checklines , deadline ) ; }	find the differences between two texts .
private void updatealtdeviceid ( networkfczoneinfo fabricinfo , string fabricid , string fabricwwn , string key , map < string , networklite > fabricid2network ) { if ( fabricinfo != null && fabricinfo . getaltnetworkdeviceid ( ) == null ) { if ( fabricid2network . get ( key ) == null ) { networklite network = networkutil . getnetworklitebyfabricid ( fabricid , fabricwwn , _dbclient ) ; if ( network != null ) { fabricid2network . put ( key , network ) ; uri id = fabricinfo . getnetworkdeviceid ( ) ; for ( string struri : network . getnetworksystems ( ) ) { if ( ! struri . equals ( id . tostring ( ) ) ) { id = uri . create ( struri ) ; break ; } } fabricinfo . setaltnetworkdeviceid ( id ) ; } } } }	ensures every fabricinfo has its altnetworkdevice that is not null when the calling code did not already supply a value for this field .
public static networkinfo fromversion ( final byte version ) { for ( final networkinfo info : known_networks ) { if ( version == info . getversion ( ) ) { return info ; } } throw new illegalargumentexception ( string . format ( _str , version ) ) ; }	gets the network info from the version .
public void write ( bytecodewriter out ) throws ioexception { out . writeutf8const ( getname ( ) ) ; tempoutputstream ts = new tempoutputstream ( ) ; bytecodewriter o2 = new bytecodewriter ( ts , out . getjavaclass ( ) ) ; o2 . writeshort ( _exceptions . size ( ) ) ; for ( int i = _num ; i < _exceptions . size ( ) ; i ++ ) { string exn = _exceptions . get ( i ) ; o2 . writeclass ( exn ) ; } ts . close ( ) ; out . writeint ( ts . getlength ( ) ) ; tempbuffer ptr = ts . gethead ( ) ; for ( ; ptr != null ; ptr = ptr . next ( ) ) out . write ( ptr . buffer ( ) , _num , ptr . length ( ) ) ; ts . destroy ( ) ; }	writes the field to the output .
public synchronized addressbookentry remove ( string name , set < string > categoriestoremove ) { name = stringutil . tolowercase ( name ) ; addressbookentry currententry = entries . get ( name ) ; if ( currententry != null ) { set < string > currentcategories = currententry . getcategories ( ) ; for ( string category : categoriestoremove ) { currentcategories . remove ( category ) ; } addressbookentry changedentry = new addressbookentry ( name , currentcategories ) ; entries . put ( name , changedentry ) ; if ( ! currententry . equalsfully ( changedentry ) ) { saveonchange ( ) ; } return changedentry ; } return null ; }	removes the given categories from the entry with the given name .
public string shortestmatch ( string input ) { trienode node = root ; for ( int i = input . length ( ) - _num ; i >= _num ; i -- ) { node = node . getchild ( input . charat ( i ) ) ; if ( node == null ) return null ; if ( node . isterminal ( ) ) return input . substring ( i ) ; } return null ; }	returns the shortest suffix of < code > input < code > that is matched , or < code > null < code > if no match exists .
public static boolean iswindows95 ( ) { return osname . indexof ( _str ) > - _num && osversion . equals ( _str ) ; }	is operating system windows 95 ?.
public static rhextension hasrhextensions ( configimpl config , extensiondefintion ed ) throws pageexception , saxexception , ioexception { xmlconfigadmin admin = new xmlconfigadmin ( config , null ) ; return admin . _hasrhextensions ( config , ed ) ; }	returns the version if the extension is available.
public void addquerytohistory ( string sql ) { queryhistory . remove ( sql ) ; queryhistory . addfirst ( sql ) ; while ( historysize >= _num && queryhistory . size ( ) > historysize ) { queryhistory . removelast ( ) ; } }	adds the query to history .
public stringbuilder encodebody ( stringbuilder retval ) { retval . append ( less_than ) ; errorinfo . encode ( retval ) ; retval . append ( greater_than ) ; if ( ! parameters . isempty ( ) ) { retval . append ( semicolon ) ; parameters . encode ( retval ) ; } return retval ; }	encode into canonical form .
public final < r > parallelflux < r > reduce ( supplier < r > initialsupplier , bifunction < r , t , r > reducer ) { objects . requirenonnull ( initialsupplier , _str ) ; objects . requirenonnull ( reducer , _str ) ; return onassembly ( new parallelreduce < > ( this , initialsupplier , reducer ) ) ; }	reduces all values within a ' rail ' to a single value ( with a possibly different type ) via a reducer function that is initialized on each rail from an initialsupplier value.
private void handlebuttonevent ( final event event ) { switch ( event . type ) { case swt . focusin : { handlefocusevents ( swt . focusin ) ; break ; } case swt . selection : { changevisibilityofpopupwindow ( ! isdropped ( ) ) ; break ; } } }	handle a button event.
private void performupdateoperations ( context context , request request , jsonvalue aftervalue , jsonvalue beforevalue ) throws resourceexception { final string managedid = getmanagedobjectid ( context ) ; activitylogger . log ( context , request , _str , getmanagedobjectpath ( context ) , beforevalue , aftervalue , status . success ) ; managedobjectsetservice . update ( context , newupdaterequest ( managedid , aftervalue ) , managedid , null , beforevalue , aftervalue , new hashset < > ( arrays . aslist ( propertyptr ) ) , new hashset < > ( arrays . aslist ( propertyptr ) ) ) ; }	performs operations associated with the updated managed object.
public static boolean canstringbeinlineencoded ( string skey ) { if ( skey . length ( ) > getmaxinlinestringkey ( max_longs_used_for_string_key , _bool ) ) { return null ; } if ( isbyteencodingok ( skey ) ) { return boolean . true ; } else { if ( skey . length ( ) > getmaxinlinestringkey ( max_longs_used_for_string_key , _bool ) ) { return null ; } else { return boolean . false ; } } }	return null if the given string can not be encoded inline.
public builder ( date created , date lastmodified ) { this . created = created != null ? new date ( created . gettime ( ) ) : null ; this . lastmodified = lastmodified != null ? new date ( lastmodified . gettime ( ) ) : null ; }	will set created to given value and lastmodified to system.
@ override public void writebytestream ( inputstream is ) throws ioexception { while ( _bool ) { int len = size - _offset - _num ; if ( len < _num ) { flushbuffer ( ) ; len = size - _offset - _num ; } len = is . read ( _buffer , _offset + _num , len ) ; if ( len <= _num ) { _buffer [ _offset ++ ] = bc_binary_direct ; return ; } _buffer [ _offset + _num ] = ( byte ) bc_binary_chunk ; _buffer [ _offset + _num ] = ( byte ) ( len > > _num ) ; _buffer [ _offset + _num ] = ( byte ) ( len ) ; _offset += len + _num ; } }	writes a full output stream .
public void removeselectionchangelistener ( final selectionchangelistener listener ) { checkwidget ( ) ; if ( listener == null ) { swt . error ( swt . error_null_argument ) ; } if ( selectionchangelisteners == null ) { return ; } selectionchangelisteners . remove ( listener ) ; }	removes the listener from the collection of listeners who will be notified when the user changes the receiver ' s selection .
public track addtrack ( string name , string type ) { track track = gettrackbyname ( name , type ) ; if ( track == null ) { _idnumber ++ ; string id = _id + _str + integer . tostring ( _idnumber ) ; log . debug ( _str , type , getname ( ) , name , id ) ; track = new track ( id , name , type , this ) ; register ( track ) ; } resetmoves ( ) ; return track ; }	adds a track to this location.
sqliteloaderobserver registerloader ( final sqliteloader loader , final string table ) { logger . d ( tag , _str , table ) ; final sqliteloaderobserver entry = new sqliteloaderobserver ( loader , table ) ; mactiveloaders . add ( entry ) ; return entry ; }	register a loader for maintaining notify changes.
public void unbindtree ( container ui ) { int componentcount = ui . getcomponentcount ( ) ; for ( int iter = _num ; iter < componentcount ; iter ++ ) { component c = ui . getcomponentat ( iter ) ; if ( c instanceof container ) { unbindtree ( ( container ) c ) ; continue ; } string bind = c . getcloudboundproperty ( ) ; if ( bind != null && bind . length ( ) > _num ) { string attributename = c . getclouddestinationproperty ( ) ; if ( attributename != null ) { unbindproperty ( c , bind ) ; } } } }	clears the binding to this component tree.
protected list < item > toitems ( list < model > models ) { if ( models == null ) { return collections . emptylist ( ) ; } int size = models . size ( ) ; list < item > items = new arraylist < > ( size ) ; for ( int i = _num ; i < size ; i ++ ) { items . add ( toitem ( models . get ( i ) ) ) ; } return items ; }	helper to get a list of item from a list o model.
public void apply ( filterset filterset , filterservicegranularlockfactory lockfactory ) { for ( filtersetentry entry : filterset . getfilters ( ) ) { add ( entry . getfiltervalueset ( ) , entry . gethandle ( ) , lockfactory ) ; } }	add the filters , from previously - taken filters .
public void addconstraintcommand ( definecommand command ) { if ( command instanceof createindex ) { constraintcommands . add ( command ) ; } else { altertableaddconstraint con = ( altertableaddconstraint ) command ; boolean alreadyset ; if ( con . gettype ( ) == commandinterface . alter_table_add_constraint_primary_key ) { alreadyset = setprimarykeycolumns ( con . getindexcolumns ( ) ) ; } else { alreadyset = _bool ; } if ( ! alreadyset ) { constraintcommands . add ( command ) ; } } }	add a constraint statement to this statement.
public void testinvitecancel ( ) { docanceltest ( _bool ) ; }	jvb : tests transmission of an invite followed by cancellation of that request - > invite < - 100 - > cancel < - ok < - 487 - > ack.
private static byte [ ] lmv2response ( final byte [ ] hash , final byte [ ] challenge , final byte [ ] clientdata ) throws authenticationexception { final hmacmd5 hmacmd5 = new hmacmd5 ( hash ) ; hmacmd5 . update ( challenge ) ; hmacmd5 . update ( clientdata ) ; final byte [ ] mac = hmacmd5 . getoutput ( ) ; final byte [ ] lmv2response = new byte [ mac . length + clientdata . length ] ; system . arraycopy ( mac , _num , lmv2response , _num , mac . length ) ; system . arraycopy ( clientdata , _num , lmv2response , mac . length , clientdata . length ) ; return lmv2response ; }	creates the lmv2 response from the given hash , client data , and type 2 challenge .
static < e > e checktype ( e obj , class < ? extends e > type ) { if ( obj != null && ! type . isinstance ( obj ) ) { throw new classcastexception ( _str + obj . getclass ( ) + _str + type ) ; } return obj ; }	checks if specified object is instance of specified class.
public void testvalueoflongpositive1 ( ) { long longval = _num ; biginteger anumber = biginteger . valueof ( longval ) ; byte rbytes [ ] = { _num , - _num , - _num , _num , - _num , - _num , _num , _num } ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = anumber . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , anumber . signum ( ) ) ; }	valueof ( long val ) : convert a positive long value to a biginteger .
public void destroy ( ) { m_filterconfig = null ; }	take this filter out of service .
@ override public parcelable onsaveinstancestate ( ) { string path = mphotofilepath . get ( ) ; if ( path == null ) return null ; bundle bundle = new bundle ( ) ; bundle . putstring ( _str , path ) ; return bundle ; }	saves photo file path during e.
public static boolean createfolder ( string folderpath ) { if ( ! textutils . isempty ( folderpath ) ) { file folder = new file ( folderpath ) ; return createfolder ( folder ) ; } return _bool ; }	create a folder , if the folder exists is not created .
public void test_emptyjournal ( ) throws ioexception , interruptedexception , executionexception { final file out = file . createtempfile ( getname ( ) , options . jnl ) ; try { final journal src = getstore ( getproperties ( ) ) ; try { final future < map < string , baseindexstats > > f = src . warmup ( null ) ; final map < string , baseindexstats > map = f . get ( ) ; assertequals ( _num , map . size ( ) ) ; } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }	verify operation ok when nothing has been written on the journal .
@ override public void keyreleased ( keyevent e ) { char [ ] password1 = null ; char [ ] password2 = null ; if ( passwordfield != null ) { password1 = passwordfield . getpassword ( ) ; } if ( repeatpasswordfield != null ) { password2 = repeatpasswordfield . getpassword ( ) ; } boolean ticklabelvisible = _bool ; if ( password1 != null && password2 != null ) { if ( arrays . equals ( password1 , password2 ) ) { ticklabelvisible = _bool ; } } ticklabel . setvisible ( ticklabelvisible ) ; clearmessages ( ) ; for ( int i = _num ; i < password1 . length ; i ++ ) { password1 [ i ] = _num ; } for ( int i = _num ; i < password2 . length ; i ++ ) { password2 [ i ] = _num ; } }	handle the key - released event from the text field .
private static periodformatterandvalue selectformatter ( period daysperiod ) { int days = daysperiod . getdays ( ) ; if ( days > _num ) { return pav ( day_formatter , days ) ; } int hours = daysperiod . gethours ( ) ; if ( hours > _num ) { return pav ( hour_formatter , hours ) ; } int minutes = daysperiod . getminutes ( ) ; if ( minutes > _num ) { return pav ( minute_formatter , minutes ) ; } int seconds = daysperiod . getseconds ( ) ; if ( seconds > _num ) { return pav ( second_formatter , seconds ) ; } return null ; }	best matching formatter of null if auction ended .
void addarg ( string arg ) { args . add ( arg ) ; }	add left - over unrecognized option / argument .
public java . lang . stringbuffer insert ( int offset , float f ) { internal . insert ( offset , f ) ; return this ; }	inserts the string representation of the float argument into this string buffer.
private void updategwt27on ( ijavaproject javaproject , list < string > programargs , int indexdisabled , int indexenabled , boolean superdevmodeenabled ) { if ( indexenabled > - _num ) { programargs . remove ( indexenabled ) ; } if ( indexdisabled > - _num ) { programargs . remove ( indexdisabled ) ; } if ( ! superdevmodeenabled ) { programargs . add ( _num , superdevmode_disabled_arg ) ; } }	update program args for project gwt > = 2.
default boolean smashblock ( entityplayer player , world world , blockpos pos , iblockstate state , tooltier tier ) { tooltier required = getrequiredtier ( state ) ; if ( required != null && tier . isgreaterthanorequalto ( required ) ) { float luck = tier . ordinal ( ) * _num ; list < itemstack > drops = getdrops ( player , world , pos , state , luck ) ; if ( drops . size ( ) > _num ) { if ( ! world . isremote ) { world . setblocktoair ( pos ) ; for ( itemstack drop : drops ) { spawnasentity ( world , pos , drop ) ; } } return _bool ; } } return _bool ; }	called to smash this block.
protected string fetchnativeid ( string nativeguid ) { string [ ] token = nativeguid . split ( vnxfileconstants . plus_seperator ) ; return token [ token . length - _num ] ; }	utility to get the filesharenativeid from nativeguid .
public static string tostring ( final double value ) { return double . tostring ( value ) ; }	converts the given value to the xml string value .
public long rss ( ) { return long . parselong ( fields [ _num ] ) ; }	resident set size : number of pages the process has in real memory.
public static void init ( context context , boolean is_top ) { cameramanager = new cameramanager ( context , is_top ) ; }	initializes this static object with the context of the calling activity .
public static plaintext plain ( float text ) { return plain ( float . tostring ( text ) ) ; }	creates a new plaintext component with the given float.
public final void append ( char value ) { char [ ] chunk ; if ( m_firstfree < m_chunksize ) chunk = m_array [ m_lastchunk ] ; else { int i = m_array . length ; if ( m_lastchunk + _num == i ) { char [ ] [ ] newarray = new char [ i + _num ] [ ] ; system . arraycopy ( m_array , _num , newarray , _num , i ) ; m_array = newarray ; } chunk = m_array [ ++ m_lastchunk ] ; if ( chunk == null ) { if ( m_lastchunk == _num << m_rebundlebits && m_chunkbits < m_maxchunkbits ) { m_innerfsb = new faststringbuffer ( this ) ; } chunk = m_array [ m_lastchunk ] = new char [ m_chunksize ] ; } m_firstfree = _num ; } chunk [ m_firstfree ++ ] = value ; }	append a single character onto the faststringbuffer , growing the storage if necessary.
public socket createsocket ( inetaddress address , int port , inetaddress myaddress , int myport ) throws ioexception { if ( myaddress != null ) { socket sock = new socket ( ) ; sock . bind ( new inetsocketaddress ( myaddress , _num ) ) ; try { sock . connect ( new inetsocketaddress ( address , port ) , _num ) ; } catch ( sockettimeoutexception e ) { throw new connectexception ( _str + address + _str + port ) ; } return sock ; } else { socket sock = new socket ( ) ; if ( myport != _num ) { sock . bind ( new inetsocketaddress ( port ) ) ; } try { sock . connect ( new inetsocketaddress ( address , port ) , _num ) ; } catch ( sockettimeoutexception e ) { throw new connectexception ( _str + address + _str + port ) ; } return sock ; } }	creates a new socket , binds it to myaddress : myport and connects it to address : port .
private static void updateclustertenant ( dbclient dbclient , uri datacenterid , uri tenantid ) { list < namedelement > clustersuris = listchildren ( dbclient , datacenterid , cluster . class , _str , _str ) ; for ( namedelement clusteruri : clustersuris ) { cluster cluster = dbclient . queryobject ( cluster . class , clusteruri . getid ( ) ) ; if ( cluster != null ) { cluster . settenant ( tenantid ) ; dbclient . persistobject ( cluster ) ; } } }	updates the cluster ' s tenant .
public static int prefixlength ( char [ ] s1 , char [ ] s2 ) { int len = _num ; int max = math . min ( s1 . length , s2 . length ) ; for ( int i = _num ; i < max && s1 [ i ] == s2 [ i ] ; ++ i ) ++ len ; return len ; }	returns the length of the common prefix between s1 and s2 .
private static boolean islessthanoneweek ( date date ) { calendar calendar = calendar . getinstance ( ) ; calendar . add ( calendar . day_of_month , - _num ) ; return date . after ( calendar . gettime ( ) ) ; }	check if the date is less than 7 days from now.
private int coltoloc ( int col , vector < mappingpair > vec ) { int loc = col ; for ( int i = _num ; ( i < vec . size ( ) ) && ( vec . elementat ( i ) . col <= col ) ; i ++ ) { loc = loc + vec . elementat ( i ) . inc ; } return loc ; }	returns the string position to which the line - mapping defined by mappingpair vec maps the column col .
protected boolean [ ] canhandlenclasses ( attrtypes attrtypes , int numclasses ) { print ( _str ) ; printattributesummary ( attrtypes , attribute . nominal ) ; print ( _str ) ; arraylist < string > accepts = new arraylist < string > ( ) ; accepts . add ( _str ) ; accepts . add ( _str ) ; int numtrain = getnuminstances ( ) , numtest = getnuminstances ( ) , missinglevel = _num ; boolean attributemissing = _bool , classmissing = _bool ; int numattr = _num , attrindex = _num ; return runbasictest ( attrtypes , numattr , attrindex , attribute . nominal , missinglevel , attributemissing , classmissing , numtrain , numtest , numclasses , accepts ) ; }	checks whether nominal schemes can handle more than two classes.
public typevariable typevariable ( ) { int id = typevariablelist . size ( ) ; typevariablelist . add ( null ) ; typevariable result = new typevariable ( id , this ) ; typevariablelist . set ( id , result ) ; return result ; }	get new type variable.
public static char [ ] createtypeparametersignature ( char [ ] typeparametername , char [ ] [ ] boundsignatures ) { int length = boundsignatures . length ; if ( length == _num ) { return charoperation . append ( typeparametername , c_colon ) ; } int boundssize = _num ; for ( int i = _num ; i < length ; i ++ ) { boundssize += boundsignatures [ i ] . length + _num ; } int namelength = typeparametername . length ; char [ ] result = new char [ namelength + boundssize ] ; system . arraycopy ( typeparametername , _num , result , _num , namelength ) ; int index = namelength ; for ( int i = _num ; i < length ; i ++ ) { result [ index ++ ] = c_colon ; int boundlength = boundsignatures [ i ] . length ; system . arraycopy ( boundsignatures [ i ] , _num , result , index , boundlength ) ; index += boundlength ; } return result ; }	creates a new type parameter signature with the given name and bounds .
void cancelstatement ( string sessionid , int statementid ) { for ( tcpserverthread c : new . arraylist ( running ) ) { if ( c != null ) { c . cancelstatement ( sessionid , statementid ) ; } } }	cancel a running statement .
public static double parsedouble ( string s ) { if ( positive_infinity . equals ( s ) ) { return double . positive_infinity ; } else if ( negative_infinity . equals ( s ) ) { return double . negative_infinity ; } else if ( nan . equals ( s ) ) { return double . nan ; } else { s = trimplussign ( s ) ; return double . parsedouble ( s ) ; } }	parses the supplied xsd : double string and returns its value .
public void finishzombietaskswitherror ( ) { list < pollabletask > zombiepollabletasks ; do { logger . debug ( _str ) ; pagerequest pageable = new pagerequest ( _num , _num ) ; zombiepollabletasks = pollabletaskrepository . findzombiepollabletasks ( pageable ) ; for ( pollabletask zombiepollabletask : zombiepollabletasks ) { markasfinishedwitherror ( zombiepollabletask ) ; } } while ( ! zombiepollabletasks . isempty ( ) ) ; }	marks zombie tasks as finished with error.
public cookieentity ( uri uri , httpcookie cookie ) { this . uri = uri == null ? null : uri . tostring ( ) ; this . name = cookie . getname ( ) ; this . value = cookie . getvalue ( ) ; this . comment = cookie . getcomment ( ) ; this . commenturl = cookie . getcommenturl ( ) ; this . discard = cookie . getdiscard ( ) ; this . domain = cookie . getdomain ( ) ; long maxage = cookie . getmaxage ( ) ; if ( maxage != - _num && maxage > _num ) { this . expiry = ( maxage * _num ) + system . currenttimemillis ( ) ; if ( this . expiry < _num ) this . expiry = headerutil . getmaxexpirymillis ( ) ; } else this . expiry = - _num ; this . path = cookie . getpath ( ) ; if ( ! textutils . isempty ( path ) && path . length ( ) > _num && path . endswith ( _str ) ) { this . path = path . substring ( _num , path . length ( ) - _num ) ; } this . portlist = cookie . getportlist ( ) ; this . secure = cookie . getsecure ( ) ; this . version = cookie . getversion ( ) ; }	cookie building database entities .
public void addvalue ( t value ) { list . addfirst ( value ) ; total += double . valueof ( value . tostring ( ) ) ; trim ( ) ; }	add a value to the averager.
private void updatetrafficmask ( ) { int queuesize = trafficcontrollingsessions . size ( ) ; while ( queuesize > _num ) { s session = trafficcontrollingsessions . poll ( ) ; if ( session == null ) { return ; } sessionstate state = getstate ( session ) ; switch ( state ) { case opened : updatetrafficcontrol ( session ) ; break ; case closing : break ; case opening : trafficcontrollingsessions . add ( session ) ; break ; default : throw new illegalstateexception ( string . valueof ( state ) ) ; } queuesize -- ; } }	update the trafficcontrol for all the session .
public object createsoftweakref ( object o ) { return new weakreference ( o ) ; }	creates a soft / weak reference to an object that allows it to be collected yet caches it.
public boolean hasentries ( ) { return ! fentries . isempty ( ) ; }	returns whether the status has entries or not .
protected string converttostring ( object value ) throws throwable { string result = null ; if ( uselocaleformat && value instanceof number ) { numberformat format = getformat ( ) ; format . setgroupingused ( _bool ) ; result = format . format ( value ) ; } else { result = value . tostring ( ) ; } return result ; }	convert an input number object into a string .
public esrishapeexport ( omgraphiclist list , projection proj , string pathtofile ) { setgraphiclist ( list ) ; projection = proj ; filepath = pathtofile ; debug = logger . isloggable ( level . fine ) ; }	create an esrishapeexport object .
private void checklogfolder ( ) { file folder = new file ( folderpath ) ; if ( ! folder . exists ( ) ) { folder . mkdirs ( ) ; } }	make sure the folder of log file exists .
private void testcompleteontimeout_timesout ( integer v ) { long timeoutmillis = timeoutmillis ( ) ; completablefuture < integer > f = new completablefuture < > ( ) ; long starttime = system . nanotime ( ) ; assertsame ( f , f . completeontimeout ( v , timeoutmillis , milliseconds ) ) ; assertsame ( v , f . join ( ) ) ; asserttrue ( milliselapsedsince ( starttime ) >= timeoutmillis ) ; f . complete ( _num ) ; checkcompletednormally ( f , v ) ; }	completeontimeout completes with given value if not complete.
private synchronized void reschedule ( long millis ) { currentfut = null ; if ( ! closed ) { scheduler . schedule ( null , millis , timeunit . milliseconds ) ; } else { try { underlying . close ( ) ; } catch ( exception ex ) { log . log ( level . warning , _str + underlying . configstring ( ) , ex ) ; } } }	schedule next invocation of the update task .
public static contentverifierprovider createdefaultcontentverifier ( publickey key ) throws operatorcreationexception { if ( _str == key . getalgorithm ( ) ) { return sun_verification_builder . build ( key ) ; } else { return bc_verification_builder . build ( key ) ; } }	creates a new content verifier using default algorithm .
public void addrule ( final rule rule ) { rule . setid ( ruleidcounter ++ ) ; rules . add ( rule ) ; }	will add the rule to the rules list .
public static object serializeclone ( final object obj ) throws ioexception , classnotfoundexception { bytearrayoutputstream memout = new bytearrayoutputstream ( ) ; objectoutputstream objout = new objectoutputstream ( memout ) ; objout . writeobject ( obj ) ; objout . close ( ) ; bytearrayinputstream src = new bytearrayinputstream ( memout . tobytearray ( ) ) ; objectinputstream objis = new objectinputstream ( src ) ; return objis . readobject ( ) ; }	creates a clone by serializing object and deserializing byte stream .
private static string linkforclassname ( string name ) { return name . replace ( _str , _str ) + _str ; }	return a link for the class name.
protected void handleelementdeleted ( ieditorinput fileeditorinput ) { fireelementdeleted ( fileeditorinput ) ; }	sends out the notification that the file serving as document input has been deleted .
public void asserttextpresent ( string expected , string actual ) { if ( ( actual == null ) || ( ! actual . contains ( expected ) ) ) { throw new assertionfailederror ( _str + expected + _str + actual + _str ) ; } }	asserts if the provided text is part of some text .
public void testusingproxyselector ( ) throws exception { mockserver server = new mockserver ( _str ) ; mockserver proxy = new mockserver ( _str ) ; url url = new url ( _str + server . port ( ) ) ; proxyselector defps = proxyselector . getdefault ( ) ; proxyselector . setdefault ( new testproxyselector ( server . port ( ) , proxy . port ( ) ) ) ; try { httpurlconnection connection = ( httpurlconnection ) url . openconnection ( ) ; connection . setconnecttimeout ( _num ) ; connection . setreadtimeout ( _num ) ; server . start ( ) ; synchronized ( bound ) { if ( ! server . started ) bound . wait ( _num ) ; } proxy . start ( ) ; synchronized ( bound ) { if ( ! proxy . started ) bound . wait ( _num ) ; } connection . connect ( ) ; server . join ( ) ; proxy . join ( ) ; asserttrue ( _str , connection . usingproxy ( ) ) ; asserttrue ( _str , proxy . accepted ) ; connection . disconnect ( ) ; asserttrue ( _str , connection . usingproxy ( ) ) ; } finally { proxyselector . setdefault ( defps ) ; } }	test checks if the proxy provided by proxy selector will be used for connection to the server.
public string codecleanpipeline ( string contents ) { if ( contents == null ) { return values . emptystring ; } stringbuilder indexcontents = new stringbuilder ( ) ; char [ ] firstreplacements = { _str , _str , _str , _str , _str , _str , _str , _str , _str } ; for ( char c : firstreplacements ) { contents = contents . replace ( c , _str ) ; } indexcontents . append ( _str ) ; indexcontents . append ( contents ) ; char [ ] secondreplacements = { _str , _str , _str , _str } ; for ( char c : secondreplacements ) { contents = contents . replace ( c , _str ) ; } indexcontents . append ( _str ) ; indexcontents . append ( contents ) ; char [ ] forthreplacements = { _str , _str } ; for ( char c : forthreplacements ) { contents = contents . replace ( c , _str ) ; } indexcontents . append ( _str ) ; indexcontents . append ( contents ) ; char [ ] replacements = { _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str } ; for ( char c : replacements ) { contents = contents . replace ( c , _str ) ; } indexcontents . append ( _str ) ; indexcontents . append ( contents ) ; char [ ] thirdreplacements = { _str } ; for ( char c : thirdreplacements ) { contents = contents . replace ( c , _str ) ; } indexcontents . append ( _str ) ; indexcontents . append ( contents ) ; return indexcontents . tostring ( ) ; }	cleans and formats the code into something that can be indexed by lucene while supporting searches such as i + + matching for ( int i = 0 ; i < 100 ; i + + ; ) {.
public static string mrpa2sampa ( string voicephoneme ) { if ( mrpa2sampa . containskey ( voicephoneme ) ) return mrpa2sampa . get ( voicephoneme ) ; else return voicephoneme ; }	converts a single phonetic symbol in mrpa representation representation into its equivalent in mary sampa representation .
public static xpath2filtercontainer newinstanceintersect ( document doc , string xpath2filter ) { return new xpath2filtercontainer ( doc , xpath2filter , xpath2filtercontainer . _att_filter_value_intersect ) ; }	creates a new xpath2filtercontainer with the filter type " intersect " .
public void removeitemchangedlistener ( itemchangedlistener listener ) { itemchangedlisteners . remove ( listener ) ; }	removes an item change listener from this controller .
public boolean hasambigprefix ( ) { return ( name . startswith ( ambigprefix ) ) ; }	determine whether an identifier has been marked as ambiguous .
public orderedthreadpoolexecutor ( int maximumpoolsize ) { this ( default_initial_thread_pool_size , maximumpoolsize , default_keep_alive , timeunit . seconds , executors . defaultthreadfactory ( ) , null ) ; }	creates a default threadpool , with default values : - minimum pool size is 0 - keepalive set to 30 seconds - a default threadfactory - all events are accepted.
private string parsemalformed ( string urlstring ) { if ( parts != null && ! parts . isempty ( ) ) { string ret ; for ( urlpart part : parts ) { switch ( part ) { case protocol : ret = applypattern ( regex_protocol , urlstring ) ; break ; case port : ret = applypattern ( regex_port , urlstring ) ; break ; case query : ret = applypattern ( regex_query , urlstring ) ; break ; case whole : ret = urlstring ; break ; default : ret = urlstring ; } if ( ! strings . isnullorempty ( ret ) ) { return ret ; } } } return urlstring ; }	attempt to parse a malformed url string.
private boolean relocate ( ) { boolean finished = _bool ; for ( relocatable relocatable : this . relocatables ) { finished &= relocatable . relocate ( ) ; } return finished ; }	relocates all relocatables and aggregate their response into a single one .
private static set < typeelement > findallmembersinjectorsrecursively ( collection < typeelement > membersinjectors ) { set < typeelement > result = new hashset < > ( ) ; for ( typeelement element : membersinjectors ) { result . addall ( findallmembersinjectorsrecursively ( element ) ) ; } return result ; }	returns all the injected classes and them super interfaces .
public builder addsubbutton ( context context , int drawable , int [ ] twocolors , string string ) { if ( drawables == null ) drawables = new arraylist < > ( ) ; drawables . add ( contextcompat . getdrawable ( context , drawable ) ) ; if ( colors == null ) colors = new arraylist < > ( ) ; colors . add ( twocolors ) ; if ( strings == null ) strings = new arraylist < > ( ) ; strings . add ( string ) ; return this ; }	add a sub button with 4 params .
public static boolean isfminstance ( ) { if ( instancetype == null ) { instancetype = ( string ) configtags . get ( _str ) ; } return ( instancetype != null && instancetype . equalsignorecase ( _str ) ) ; }	checks if the instance is fm .
private boolean tryrelease ( long c , workqueue v , long inc ) { int sp = ( int ) c , ns = sp & ~ unsignalled ; if ( v != null ) { int vs = v . scanstate ; long nc = ( v . stackpred & sp_mask ) | ( uc_mask & ( c + inc ) ) ; if ( sp == vs && u . compareandswaplong ( this , ctl , c , nc ) ) { v . scanstate = ns ; locksupport . unpark ( v . parker ) ; return _bool ; } } return _bool ; }	signals and releases worker v if it is top of idle worker stack.
@ override public value sample ( assignment condition ) { double prob = getprob ( condition ) ; if ( sampler . nextdouble ( ) < prob ) { return valuefactory . create ( _bool ) ; } else { return valuefactory . create ( _bool ) ; } }	generates a sample from the distribution given the conditional assignment .
boolean validate ( set attrvals , string i18nfilename , boolean encodepassword ) throws smsexception { return validate ( attrvals , i18nfilename , encodepassword , collections . empty_map ) ; }	validates a map of attributes and values against service schema definition .
protected static void appendbigdecimalnumerictype ( stringbuilder sb ) { sb . append ( _str ) ; }	output the sql type for a bigdecimal object .
public double distance ( vector other ) { return math . sqrt ( math . pow ( other . x - x , _num ) + math . pow ( other . y - y , _num ) + math . pow ( other . z - z , _num ) ) ; }	get the distance between this vector and another vector .
public static void takescreenshot ( final string tag ) { if ( scenario == null ) { throw new screenshotexception ( _str ) ; } spoonscreenshotaction . perform ( tag ) ; final file screenshot = spoonscreenshotaction . getlastscreenshot ( ) ; if ( screenshot == null ) { throw new screenshotexception ( _str ) ; } fileinputstream screenshotstream = null ; try { screenshotstream = new fileinputstream ( screenshot ) ; final byte filecontent [ ] = new byte [ ( int ) screenshot . length ( ) ] ; final int readimagebytes = screenshotstream . read ( filecontent ) ; if ( readimagebytes != - _num ) { scenario . embed ( filecontent , _str ) ; } } catch ( final ioexception ioe ) { throw new screenshotexception ( _str + ioe ) ; } finally { try { if ( screenshotstream != null ) { screenshotstream . close ( ) ; } } catch ( final ioexception ioe ) { throw new screenshotexception ( _str + ioe ) ; } } }	take a screenshot of the current activity and embed it in the html report.
private void importrunnerenvironment ( importproject importproject , folderentry baseprojectfolder ) throws forbiddenexception , serverexception , conflictexception , ioexception { importrunnerenvironment ( importproject , baseprojectfolder , null ) ; }	import runner environment tha configure in importproject.
@ override public void donotify ( ) throws exception { log . info ( _str ) ; scheduledexecutorservice svc = service ; if ( svc != null ) { try { svc . schedule ( ( callable < object > ) this , _num , timeunit . microseconds ) ; } catch ( rejectedexecutionexception ex ) { if ( svc . isshutdown ( ) ) { log . info ( _str ) ; } else { throw ex ; } } } else { log . info ( _str ) ; } }	called when related system properties are changed , and we need to reschedule.
public boolean checkrootbybuildtags ( ) { string buildtags = android . os . build . tags ; if ( buildtags != null && buildtags . contains ( su_tag ) ) { return _bool ; } return _bool ; }	returns true if the os build tags contains " test - keys " .
public boolean isuseractive ( string realm ) { boolean active = _bool ; try { amidentity user = idutils . getidentity ( ssotoken , userid ) ; boolean isuseractive = user . isactive ( ) ; string loginstatus = getuserattributevalue ( user , user_service_login_status , active ) ; string lockout = getuserattributevalue ( user , user_service_ns_lockout , string_false ) ; if ( ! isuseractive || ! loginstatus . equalsignorecase ( active ) || ! lockout . equalsignorecase ( string_false ) ) { errormsg = getlocalizedstring ( _str ) ; writelog ( _str , userid ) ; } else if ( isaccountexpired ( user ) ) { errormsg = getlocalizedstring ( _str ) ; writelog ( _str , userid ) ; } else if ( isuserlockout ( userid , realm ) ) { string obj [ ] = { userid } ; informationmsg = getlocalizedstring ( _str ) ; writelog ( _str , userid ) ; } else { active = _bool ; } } catch ( ssoexception e ) { debug . warning ( _str , e ) ; errormsg = geterrorstring ( e ) ; } catch ( idrepoexception e ) { debug . warning ( _str , e ) ; errormsg = geterrorstring ( e ) ; } return active ; }	returns true if the user is active and account is not expired.
@ override public < u > completablefuture < u > foldright ( final u seed , final bifunction < ? super t , u , u > function ) { return completablefuture . supplyasync ( null , exec ) ; }	perform an asynchronous foldright operation.
private void algorithmdouglaspeucker ( list < entry > entries , double epsilon , int start , int end ) { if ( end <= start + _num ) { return ; } int maxdistindex = _num ; double distmax = _num ; entry firstentry = entries . get ( start ) ; entry lastentry = entries . get ( end ) ; for ( int i = start + _num ; i < end ; i ++ ) { double dist = calcanglebetweenlines ( firstentry , lastentry , firstentry , entries . get ( i ) ) ; if ( dist > distmax ) { distmax = dist ; maxdistindex = i ; } } if ( distmax > epsilon ) { keep [ maxdistindex ] = _bool ; algorithmdouglaspeucker ( entries , epsilon , start , maxdistindex ) ; algorithmdouglaspeucker ( entries , epsilon , maxdistindex , end ) ; } }	apply the douglas - peucker - reduction to an list of entry with a given epsilon ( tolerance ).
public static void sort ( abstractlist array , int [ ] indices ) { for ( int i = _num ; i < indices . length ; i ++ ) { indices [ i ] = i ; } int temp ; int j , n = array . size ( ) ; for ( j = n / _num ; j > _num ; j -- ) { adjust ( array , indices , j , n ) ; } for ( j = n - _num ; j > _num ; j -- ) { temp = indices [ _num ] ; indices [ _num ] = indices [ j ] ; indices [ j ] = temp ; adjust ( array , indices , _num , j ) ; } }	sorts an array of indices to vector of comparable objects into increasing order .
public static boolean savestringtofile ( string datainput , string path ) { string filename = path ; file file = new file ( filename ) ; fileoutputstream fos ; byte [ ] data = datainput . getbytes ( ) ; try { fos = new fileoutputstream ( file ) ; fos . write ( data ) ; fos . flush ( ) ; fos . close ( ) ; return _bool ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return _bool ; }	save string to file.
public static string quote ( string input ) { if ( input . contains ( _str ) ) { return _str + input + _str ; } else { return input ; } }	quotes the given input string iff it contains whitespace .
public static void assertthrowscompletionexception ( final consumer < void > consumer , final class < ? > exceptionclass ) { try { consumer . accept ( null ) ; } catch ( final completionexception completionex ) { final throwable ex = completionex . getcause ( ) ; if ( ex . getclass ( ) == exceptionclass ) { return ; } assert . fail ( string . format ( _str , ex . getclass ( ) ) ) ; } assert . fail ( string . format ( _str , exceptionclass ) ) ; }	asserts that the execution of consumer throws a completion exception wrapping an exception of the specific class .
public object put ( object key , object value ) { object oldvalue = null ; synchronized ( map ) { oldvalue = map . put ( key , value ) ; if ( oldvalue != null ) { removeelement ( key ) ; } addelement ( key ) ; } return oldvalue ; }	puts the key and element to the map .
public double run ( ) { try { audioinputstream ininput = audiosystem . getaudioinputstream ( files [ _num ] ) ; audiofeature audiofeatureinput = ( audiofeature ) featureextractorinput . calculate ( ininput ) ; } catch ( exception e ) { } double avgdistance = _num ; for ( int i = _num ; i < arrayfeatureextractortrainset . size ( ) ; i ++ ) { double distance2db = audiothreaddistance ( featureextractorinput . getmfcc ( ) , arrayfeatureextractortrainset . get ( i ) ) ; log . i ( _str , _str + distance2db ) ; avgdistance += distance2db ; } log . i ( _str , _str + ( avgdistance / arrayfeatureextractortrainset . size ( ) ) ) ; return avgdistance / arrayfeatureextractortrainset . size ( ) ; }	starts processing the feature extraction batch job .
public predicate ( term t ) { terms . add ( t ) ; }	creates a predicate containing a single term .
private void addoperations ( set < string > methodsignatures ) throws operationparseexception { for ( string sig : methodsignatures ) { typedoperation operation = operationparser . parse ( sig ) ; operations . add ( operation ) ; } }	create operations obtained by parsing method signatures and add each to this model .
private void writelog ( string log ) { file file = new file ( crashhandlerdefault . log_default_path + _str + formatter . format ( new date ( ) ) + _str ) ; try { fileoutputstream fileoutputstream = new fileoutputstream ( file ) ; byte [ ] bytes = log . getbytes ( ) ; fileoutputstream . write ( bytes ) ; fileoutputstream . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }	write log in file.
public rule ( string pattern , object tokentype , string nextstate ) { this . pattern = pattern . compile ( pattern ) ; this . tokentype = tokentype ; this . nextstate = nextstate ; }	initializes a new instance with the specified regular expression pattern , a type for generated tokens , and a name of a grammar state that should be triggered .
private void showpopup ( final mouseevent event ) { int [ ] rows = getselectedrows ( ) ; if ( ( rows . length == _num ) || ( rows . length == _num ) ) { final int row = rowatpoint ( event . getpoint ( ) ) ; final int column = columnatpoint ( event . getpoint ( ) ) ; if ( ( row == - _num ) || ( column == - _num ) ) { return ; } changeselection ( row , column , _bool , _bool ) ; rows = getselectedrows ( ) ; } final jpopupmenu menu = new jpopupmenu ( ) ; menu . add ( new jmenuitem ( cactionproxy . proxy ( new cdeletebookmarkaction ( m_bookmarkmanager , rows ) ) ) ) ; menu . show ( event . getcomponent ( ) , event . getx ( ) , event . gety ( ) ) ; }	shows a context menu .
public static boolean hasspecialchars ( final string str ) { final matcher matcher = spl_char_patrn . matcher ( str ) ; return matcher . find ( ) ; }	checks if the given string value contains special characters ( [ , & , ; , , , + , = , { , } , > , < , ^ , ( , ) , # , : , ~ , ` , / , \ , ! , ' , " , ] ).
@ override public int read ( byte b [ ] , int off , int len ) throws ioexception { if ( bb == null ) { throw new ioexception ( _str ) ; } if ( b == null ) { throw new nullpointerexception ( ) ; } else if ( off < _num || len < _num || len > b . length - off ) { throw new indexoutofboundsexception ( ) ; } else if ( len == _num ) { return _num ; } int length = math . min ( bb . remaining ( ) , len ) ; if ( length == _num ) { return - _num ; } bb . get ( b , off , length ) ; return length ; }	returns a byte array from the bytebuffer.
public void removeeventlistener ( multimediamessagingsessionlistener listener ) throws rcsservicenotavailableexception , rcsgenericexception { if ( mapi == null ) { throw new rcsservicenotavailableexception ( ) ; } try { weakreference < imultimediamessagingsessionlistener > weakref = mmultimediamessagingsessionlisteners . remove ( listener ) ; if ( weakref == null ) { return ; } imultimediamessagingsessionlistener multimediamessagingsessionlistener = weakref . get ( ) ; if ( multimediamessagingsessionlistener != null ) { mapi . removeeventlistener2 ( multimediamessagingsessionlistener ) ; } } catch ( exception e ) { rcsillegalargumentexception . assertexception ( e ) ; throw new rcsgenericexception ( e ) ; } }	removes a listener on multimedia messaging session events.
public widgetproposalcomputer ( string text , int offset , element rootelement , element parentelement , ijavaproject javaproject ) throws javamodelexception , uibinderexception { super ( javaproject , text , offset , text . length ( ) ) ; this . rootelement = rootelement ; this . parentelement = parentelement ; packagemanager . readfromelement ( rootelement ) ; }	constructs a widget completion proposal computer .
public list < predicate < t > > parse ( final list < string > queries ) throws queryparseexception { list < predicate < t > > predicates = new arraylist < > ( queries . size ( ) ) ; for ( string query : queries ) { predicates . add ( parse ( query ) ) ; } return predicates ; }	parse multiple user - supplied query strings into a list of predicates .
public static object deserializestream ( final string witness ) throws exception { fileinputstream fileis = new fileinputstream ( witness ) ; objectinputstream objis = new objectinputstream ( fileis ) ; return objis . readobject ( ) ; }	deserializes a specified file .
public static void rollback ( boolean begantransaction , string causemessage , throwable causethrowable ) throws generictransactionexception { if ( begantransaction ) { transactionutil . rollback ( causethrowable ) ; } else { transactionutil . setrollbackonly ( causemessage , causethrowable ) ; } }	rolls back transaction in the current thread if transactions are available and if begantransaction is true ; if begantransaction is not true , setrollbackonly is called to insure that the transaction will be rolled back.
public longarray ( longarray array ) { this . ordered = array . ordered ; size = array . size ; items = new long [ size ] ; system . arraycopy ( array . items , _num , items , _num , size ) ; }	creates a new array containing the elements in the specific array.
private static < t > t reportget ( object r ) throws interruptedexception , executionexception { if ( r == null ) throw new interruptedexception ( ) ; if ( r instanceof altresult ) { throwable x , cause ; if ( ( x = ( ( altresult ) r ) . ex ) == null ) return null ; if ( x instanceof cancellationexception ) throw ( cancellationexception ) x ; if ( ( x instanceof completionexception ) && ( cause = x . getcause ( ) ) != null ) x = cause ; throw new executionexception ( x ) ; } @ suppresswarnings ( _str ) t t = ( t ) r ; return t ; }	reports result using future.
protected void garbagecollect ( visualtable labels ) { iterator iter = labels . tuples ( ) ; while ( iter . hasnext ( ) ) { visualitem item = ( visualitem ) iter . next ( ) ; if ( ! item . isstartvisible ( ) && ! item . isendvisible ( ) ) { labels . removetuple ( item ) ; } } }	remove axis labels no longer being used .
public boolean sharesvariablewith ( defuse du ) { return varname . equals ( du . varname ) ; }	determines whether the given defuse reads or writes the same variable as this defuse.
private void populatenavdrawer ( ) { mnavdraweritems . clear ( ) ; mnavdraweritems . add ( navdrawer_item_activity1 ) ; mnavdraweritems . add ( navdrawer_item_separator ) ; mnavdraweritems . add ( navdrawer_item_activity2 ) ; mnavdraweritems . add ( navdrawer_item_separator_special ) ; mnavdraweritems . add ( navdrawer_item_activity3 ) ; createnavdraweritems ( ) ; }	populates the navigation drawer with the appropriate items .
public artifactcoordinates ( final string groupid , final string artifactid , final string version , final string classifier ) { this . groupid = groupid ; this . artifactid = artifactid ; this . version = version ; this . classifier = classifier ; }	construct a new instance .
private carboniterator < batchresult > executeblocklist ( list < tableblockinfo > blocklist ) throws queryexecutionexception { querymodel . settableblockinfos ( blocklist ) ; this . queryexecutor = queryexecutorfactory . getqueryexecutor ( ) ; carboniterator < batchresult > iter = null ; try { iter = queryexecutor . execute ( querymodel ) ; } catch ( queryexecutionexception e ) { logger . error ( e . getmessage ( ) ) ; throw e ; } return iter ; }	get executor and execute the query model .
protected link createlink ( final string relation , final uri href ) { return new link ( relation , href ) ; }	creates a link with the specified relation and uri of the remote resource .
public void testflipbitpositiveinside2 ( ) { byte abytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = _num ; int number = _num ; byte rbytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . flipbit ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	flipbit ( int n ) inside a positive number.
public static spannable createspannablefromtextwithtemplate ( string text , charsequence innertemplate ) { spannablestring result = new spannablestring ( text ) ; if ( innertemplate instanceof spanned ) { int index = text . indexof ( innertemplate . tostring ( ) ) ; if ( index >= _num ) { copyspans ( result , ( spanned ) innertemplate , index ) ; } } return result ; }	create spannable from text that includes some charsequence . if the charsequence has any spans they would be copied to result spannable.
@ override public string tostring ( ) { return xmlfile . getname ( ) ; }	returns the domain name .
public string tostring ( ) { return string . valueof ( stoptimemillis - starttimemillis ) + _str ; }	returns a summary of the time that the stopwatch has recorded as a string .
public objectgraph plusgraph ( list < object > activityscopemodules ) { if ( activityscopemodules == null ) { throw new illegalargumentexception ( _str ) ; } return graph . plus ( activityscopemodules . toarray ( ) ) ; }	given a list < object > with dagger modules inside performs a plus over the application graph and returns a new one with all the dependencies already created plus the one resolved with the list of modules passed as argument .
public groupcategoryset ( groupcategory [ ] categories ) { assert . isnotnull ( categories ) ; fcontent = new arraylist ( categories . length ) ; for ( int i = _num ; i < categories . length ; i ++ ) { if ( ! fcontent . contains ( categories [ i ] ) ) fcontent . add ( categories [ i ] ) ; } }	creates a new set of group categories initialized from the given array of group categories.
private boolean insamepackage ( class < ? > c1 , class < ? > c2 ) { string namec1 = c1 . getname ( ) ; string namec2 = c2 . getname ( ) ; int indexdotc1 = namec1 . lastindexof ( _str ) ; int indexdotc2 = namec2 . lastindexof ( _str ) ; if ( indexdotc1 != indexdotc2 ) { return _bool ; } if ( indexdotc1 == - _num ) { return _bool ; } return namec1 . regionmatches ( _num , namec2 , _num , indexdotc1 ) ; }	checks if two classes belong to the same package .
private void writeconstraintstoxml ( xmlserializer out , jobstatus jobstatus ) throws ioexception { out . starttag ( null , xml_tag_params_constraints ) ; if ( jobstatus . hasunmeteredconstraint ( ) ) { out . attribute ( null , _str , boolean . tostring ( _bool ) ) ; } if ( jobstatus . hasconnectivityconstraint ( ) ) { out . attribute ( null , _str , boolean . tostring ( _bool ) ) ; } if ( jobstatus . hasidleconstraint ( ) ) { out . attribute ( null , _str , boolean . tostring ( _bool ) ) ; } if ( jobstatus . haschargingconstraint ( ) ) { out . attribute ( null , _str , boolean . tostring ( _bool ) ) ; } out . endtag ( null , xml_tag_params_constraints ) ; }	write out a tag with data identifying this job ' s constraints.
public void fillconditionalholes ( ) { valuerange possiblecondpairs = new valuerange ( table . keyset ( ) ) ; if ( possiblecondpairs . getnbcombinations ( ) < _num ) { set < assignment > possiblecondassignments = possiblecondpairs . linearise ( ) ; possiblecondassignments . remove ( new assignment ( ) ) ; for ( assignment possiblecond : possiblecondassignments ) { if ( ! table . containskey ( possiblecond ) ) { addrow ( possiblecond , valuefactory . none ( ) , _num ) ; } } } }	fill the " conditional holes " of the distribution - - that is , the possible conditional assignments y1 ,.
private boolean showappmenu ( view view , boolean startdragging ) { if ( ! mmenuhandler . isappmenushowing ( ) && mmenuhandler . showappmenu ( view , startdragging ) ) { if ( ! startdragging ) recorduseraction . record ( _str ) ; if ( monappmenushownlistener != null ) { monappmenushownlistener . run ( ) ; } return _bool ; } return _bool ; }	shows the app menu if it is not already shown .
protected void writenodetext ( node node ) throws ioexception { string text = node . gettext ( ) ; if ( ( text != null ) && ( text . length ( ) > _num ) ) { if ( escapetext ) { text = escapeelemententities ( text ) ; } lastoutputnodetype = node . text_node ; writer . write ( text ) ; } }	this method is used to write out nodes that contain text and still allow for xml : space to be handled properly .
public void insertradians ( double [ ] latlons , int coordpairindex , boolean replaceendsofinsertedatjoin ) { int minpntsneededforinsertion = _num ; boolean atend = _bool ; boolean isclosed = isgeometryclosed ( ) ; int insertionpoint = coordpairindex * _num ; if ( insertionpoint >= rawllpts . length ) { if ( isclosed ) { insertionpoint = rawllpts . length - _num ; } else { insertionpoint = rawllpts . length ; atend = _bool ; } } else if ( insertionpoint <= _num ) { if ( isclosed ) { insertionpoint = _num ; } else { insertionpoint = _num ; atend = _bool ; } } int newcoordstart = _num ; int newcoordlength = latlons . length ; if ( replaceendsofinsertedatjoin ) { newcoordstart = _num ; minpntsneededforinsertion = _num ; if ( atend ) { minpntsneededforinsertion -= _num ; newcoordlength -= _num ; if ( insertionpoint == _num ) { newcoordstart = _num ; } } else { newcoordlength -= _num ; } } if ( rendertype == omgraphic . rendertype_latlon && latlons . length >= minpntsneededforinsertion && latlons . length % _num == _num ) { double [ ] oldrawllpnts = rawllpts ; int oldcoordsremaining = oldrawllpnts . length - insertionpoint ; rawllpts = new double [ oldrawllpnts . length + newcoordlength ] ; system . arraycopy ( oldrawllpnts , _num , rawllpts , _num , insertionpoint ) ; system . arraycopy ( latlons , newcoordstart , rawllpts , insertionpoint , newcoordlength ) ; system . arraycopy ( oldrawllpnts , insertionpoint , rawllpts , insertionpoint + newcoordlength , oldcoordsremaining ) ; setneedtoregenerate ( _bool ) ; } }	convenience function for adding some coordinates to the polygon , for lat / lon polygons.
public static boolean cancelpotentialwork ( object data , imageview imageview ) { final bitmapworkertask bitmapworkertask = getbitmapworkertask ( imageview ) ; if ( bitmapworkertask != null ) { final object bitmapdata = bitmapworkertask . data ; if ( bitmapdata == null || ! bitmapdata . equals ( data ) ) { bitmapworkertask . cancel ( _bool ) ; if ( buildconfig . debug ) { log . d ( tag , _str + data ) ; } } else { return _bool ; } } return _bool ; }	returns true if the current work has been canceled or if there was no work in progress on this image view.
private t3 < integer , integer , byte [ ] > randomkey ( random rnd ) { return keys [ rnd . nextint ( keys . length ) ] ; }	gets random key from pregenerated array .
public string tostring ( ) { stringbuffer buffer = new stringbuffer ( ) ; if ( override > _num ) { buffer . append ( _str + override + _str ) ; if ( lineno > _num ) buffer . append ( _str + lineno + _str ) ; } else { if ( locationname == null && lineno > _num ) { buffer . append ( _str + lineno + _str ) ; } else if ( locationname != null ) { buffer . append ( locationname + _str ) ; if ( lineno > _num ) buffer . append ( lineno + _str ) ; } } buffer . append ( description ) ; return buffer . tostring ( ) ; }	returns a string representation of this error .
public void testsearchableslistreal ( ) { mymockpackagemanager mockpm = new mymockpackagemanager ( mcontext . getpackagemanager ( ) ) ; mymockcontext mockcontext = new mymockcontext ( mcontext , mockpm ) ; mockpm . setsearchablesmode ( mymockpackagemanager . searchables_passthrough ) ; searchables searchables = new searchables ( mockcontext , _num ) ; searchables . buildsearchablelist ( ) ; arraylist < searchableinfo > searchableslist = searchables . getsearchableslist ( ) ; int count = searchableslist . size ( ) ; asserttrue ( count >= _num ) ; checksearchables ( searchableslist ) ; arraylist < searchableinfo > global = searchables . getsearchablesinglobalsearchlist ( ) ; checksearchables ( global ) ; }	this is an attempt to run the searchable info list with a mocked context.
private void fillexampletable ( dataset dataset , progresslistener listener , int [ ] attributecolumns , memoryexampletable exampletable ) throws datasetexception , processstoppedexception , parseexception { attribute [ ] attributes = exampletable . getattributes ( ) ; dataset . reset ( ) ; int numberofrows = dataset . getnumberofrows ( ) ; datarowfactory factory = new datarowfactory ( datamanagementtype , datarowfactory . point_as_decimal_character ) ; boolean isrunninginprocess = isoperatorrunning ( ) ; while ( dataset . hasnext ( ) ) { if ( isrunninginprocess ) { operator . checkforstop ( ) ; } if ( shouldstop ) { throw new processstoppedexception ( ) ; } datasetrow currentrow = dataset . nextrow ( ) ; if ( listener != null ) { updateprocess ( listener , dataset . getcurrentrowindex ( ) , numberofrows ) ; } datarow row = factory . create ( attributes . length ) ; exampletable . adddatarow ( row ) ; int attributeindex = _num ; for ( attribute attribute : attributes ) { if ( currentrow . ismissing ( attributecolumns [ attributeindex ] ) ) { row . set ( attribute , double . nan ) ; } else { switch ( attribute . getvaluetype ( ) ) { case ontology . integer : case ontology . numerical : case ontology . real : row . set ( attribute , getnumber ( currentrow , attributecolumns [ attributeindex ] ) ) ; break ; case ontology . date_time : case ontology . time : case ontology . date : row . set ( attribute , getdate ( currentrow , attributecolumns [ attributeindex ] ) ) ; break ; default : row . set ( attribute , getstringindex ( attribute , currentrow , attributecolumns [ attributeindex ] ) ) ; } } attributeindex ++ ; } } }	fills the exampletable with the data from the dataset .
public boolean isspurious ( int minclsize ) { return children . isempty ( ) && members . size ( ) < minclsize ; }	test if a cluster is spurious .
public aesdecryptor ( byte [ ] key , int off , int len ) { this . key = new byte [ len ] ; system . arraycopy ( key , off , this . key , _num , len ) ; }	creates a new instance of aesdecryption.
static string extractnumberfromuriwithoutformatting ( string uri ) { if ( uri == null ) { return null ; } int index0 = uri . indexof ( uri_start_delimiter ) ; if ( index0 != - _num ) { uri = uri . substring ( index0 + uri_start_delimiter . length ( ) , uri . indexof ( uri_end_delimiter , index0 ) ) ; } int index1 = uri . indexof ( tel_uri_header ) ; if ( index1 != - _num ) { uri = uri . substring ( index1 + tel_uri_header . length ( ) ) ; } index1 = uri . indexof ( sip_uri_header ) ; if ( index1 != - _num ) { int index2 = uri . indexof ( _str , index1 ) ; uri = uri . substring ( index1 + sip_uri_header . length ( ) , index2 ) ; } int index2 = uri . indexof ( _str ) ; if ( index2 != - _num ) { uri = uri . substring ( _num , index2 ) ; } index2 = uri . indexof ( _str ) ; if ( index2 != - _num ) { uri = uri . substring ( _num , index2 ) ; } return uri ; }	extract user part phone number from a sip - uri or tel - uri or sip address.
public remotemethodcallresults invokeandwait ( final string endpointname , final remotemethodcall remotecall ) { endpoint local ; synchronized ( m_endpointmutex ) { local = m_localendpoints . get ( endpointname ) ; } if ( local == null ) { return invokeandwaitremote ( remotecall ) ; } else { final long number = local . takeanumber ( ) ; final list < remotemethodcallresults > results = local . invokelocal ( remotecall , number , getlocalnode ( ) ) ; if ( results . size ( ) == _num ) { throw new remotenotfoundexception ( _str + endpointname ) ; } if ( results . size ( ) > _num ) { throw new illegalstateexception ( _str + results ) ; } return results . get ( _num ) ; } }	invoke and wait for all implementors on all vms to finish executing .
private void createelement ( document doc , element parentelement , string elementname , boolean value ) { element element = doc . createelement ( elementname ) ; element . appendchild ( doc . createtextnode ( boolean . tostring ( value ) ) ) ; parentelement . appendchild ( element ) ; }	creates the xml element for a boolean value .
protected void annotationvaluetostring ( final stringbuilder sb , final bop val , final int indent ) { sb . append ( val . tostring ( ) ) ; }	add a string representation of a bop annotation value into a string builder.
public void runtest ( ) throws throwable { document doc ; nodelist emlist ; node emnode ; characterdata emtext ; node nullchild ; doc = ( document ) load ( _str , _bool ) ; emlist = doc . getelementsbytagname ( _str ) ; emnode = emlist . item ( _num ) ; emtext = ( characterdata ) emnode . getfirstchild ( ) ; nullchild = emtext . getlastchild ( ) ; assertnull ( _str , nullchild ) ; }	runs the test case .
public enumeration oids ( ) { return ordering . elements ( ) ; }	return an enumeration of the extension field ' s object ids .
@ override map < string , object > extractfields ( string line ) { if ( ! initialized ) { init ( ) ; initialized = _bool ; } string [ ] values = fixedwidthparser . parseline ( line ) ; if ( hasheader && arrays . deepequals ( values , header ) ) { return null ; } map < string , object > map = maps . newhashmap ( ) ; int i = _num ; for ( fixedwidthfield field : fields ) { map . put ( field . getname ( ) , getvalue ( field , values [ i ++ ] ) ) ; } return map ; }	extracts the fields from a fixed width record and returns a map containing field names and values.
protected double scalingfunction ( int idistance ) { return math . exp ( - math . pow ( ( idistance ) , _num ) / ( _num * math . pow ( correlationwindow , _num ) ) ) ; }	a function providing a scaling factor according to the distance between any two n - grams .
protected void updateidealpoint ( ) { for ( solution solution : this ) { if ( solution . getnumberofobjectives ( ) != numberofobjectives ) { throw new frameworkexception ( _str ) ; } for ( int i = _num ; i < numberofobjectives ; i ++ ) { idealpoint [ i ] = math . min ( idealpoint [ i ] , solution . getobjective ( i ) ) ; } } }	updates the ideal point given the solutions currently in this population .
public searchbuilder sort ( sortfieldbuilder ... builders ) { sort . addall ( arrays . aslist ( builders ) ) ; return this ; }	adds the specified sorting fields .
@ override public final bufferedimage datatorgb ( byte [ ] data , final int width , final int height ) { bufferedimage image ; data = datatorgbbytearray ( data , width , height ) ; final databuffer db = new databufferbyte ( data , data . length ) ; final int [ ] bands = { _num , _num , _num } ; image = new bufferedimage ( width , height , bufferedimage . type_int_rgb ) ; final raster raster = raster . createinterleavedraster ( db , width , height , width * _num , _num , bands , null ) ; image . setdata ( raster ) ; return image ; }	convert to rgb and return as an image.
protected void createfilechooser ( ) { m_filechooser = new jfilechooser ( new file ( system . getproperty ( _str ) ) ) ; m_filechooser . setfileselectionmode ( jfilechooser . files_only ) ; }	creates the file chooser the user will use to save / load files with .
private boolean isnoun ( string word ) { if ( nouns == null ) return _bool ; return nouns . contains ( word . tolowercase ( ) ) ; }	if this is word is a thing in our repository it is a noun.
public static void writedocument ( document document , string encoding , outputstream out , writer writer , boolean omitxmldeclaration ) throws ioexception , xmlexception { if ( writer == null ) { writer = new outputstreamwriter ( out , encoding ) ; } transformer . setoutputproperty ( outputkeys . encoding , encoding ) ; transformer . setoutputproperty ( outputkeys . omit_xml_declaration , omitxmldeclaration ? _str : _str ) ; source source = new domsource ( document ) ; result result = new streamresult ( writer ) ; try { transformer . transform ( source , result ) ; } catch ( transformerexception e ) { e . printstacktrace ( ) ; throw new xmlexception ( _str , e ) ; } writer . flush ( ) ; }	writes the xml representation of a document object .
public static string inttostring ( int value , int nchars ) { string strvalue = integer . tostring ( value ) ; stringbuilder strbuf = new stringbuilder ( nchars ) ; for ( int i = strvalue . length ( ) ; i < nchars ; i ++ ) { strbuf . append ( _str ) ; } strbuf . append ( strvalue ) ; return strbuf . tostring ( ) ; }	method inttostring . converst an integer to nchars characters.
public boolean isquestcompleted ( final string name ) { return quests . isquestcompleted ( name ) ; }	checks whether the player has completed the given quest or not .
private void updatebuttonstate ( boolean datachanged ) { btnapply . setenabled ( datachanged ) ; btnrevert . setenabled ( datachanged ) ; }	update button apply / revert state .
private void buildmenu ( ) { setvisible ( _bool ) ; removeall ( ) ; if ( recentsearches . getlength ( ) == _num ) { jmenuitem norecent = new jmenuitem ( uimanager . getstring ( _str ) ) ; norecent . setenabled ( _bool ) ; add ( norecent ) ; } else { jmenuitem recent = new jmenuitem ( uimanager . getstring ( _str ) ) ; recent . setenabled ( _bool ) ; add ( recent ) ; for ( string searchstring : recentsearches . getrecentsearches ( ) ) { jmenuitem mi = new jmenuitem ( searchstring ) ; mi . addactionlistener ( this ) ; add ( mi ) ; } addseparator ( ) ; clear = new jmenuitem ( uimanager . getstring ( _str ) ) ; clear . addactionlistener ( this ) ; add ( clear ) ; } }	rebuilds the menu according to the recent searches .
public static string convertu8tohexstring ( char u8 ) { return integer . tohexstring ( u8 ) ; }	convert char ( uint8 ) to hex string.
public static byte [ ] join ( byte [ ] arraya , byte ... arrayb ) { if ( ( arrayb == null ) || ( arrayb . length == _num ) ) { return arraya ; } if ( ( arraya == null ) || ( arraya . length == _num ) ) { return arrayb ; } byte [ ] array = new byte [ arraya . length + arrayb . length ] ; system . arraycopy ( arraya , _num , array , _num , arraya . length ) ; system . arraycopy ( arrayb , _num , array , arraya . length , arrayb . length ) ; return array ; }	joins 2 arrays together , if any array is null or empty then other array will be retuned without coping anything .
public void removelistener ( listener listener ) { mlisteners . remove ( listener ) ; }	remove a listener from the listener list.
protected double constrictioncoefficient ( double c1 , double c2 ) { double rho = c1 + c2 ; if ( rho <= _num ) { return _num ; } else { return _num / ( _num - rho - math . sqrt ( math . pow ( rho , _num ) - _num * rho ) ) ; } }	returns the velocity constriction coefficient .
public synchronized void close ( ) { if ( isalive ) { isalive = _bool ; taskqueue . clear ( ) ; interrupt ( ) ; } }	closes this threadpool and returns immediately.
public string removeafter ( string original , string marker ) { int index = original . indexof ( marker ) ; if ( index != - _num ) { return original . substring ( _num , index ) ; } return original ; }	this method removes the end part of a string beginning at a specified marker .
public address __sub__ ( final object rhs ) { return new address ( m_value . subtract ( getbiginteger ( rhs ) ) ) ; }	used to support sub operations on addresses in python scripts .
public static testconfiguration builddefaultconfiguration ( string testsourcepath , file testfile , string checkername , list < string > options , boolean shouldemitdebuginfo ) { list < file > javafiles = arrays . aslist ( testfile ) ; list < string > processors = arrays . aslist ( checkername ) ; return builddefaultconfiguration ( testsourcepath , javafiles , processors , options , shouldemitdebuginfo ) ; }	this is the default configuration used by checker framework junit tests .
private static boolean eq ( object o1 , object o2 ) { return ( o1 == null ? o2 == null : o1 . equals ( o2 ) ) ; }	test for equality , coping with nulls .
public void roll ( int field , int value ) { boolean increment = value >= _num ; int count = increment ? value : - value ; for ( int i = _num ; i < count ; i ++ ) { roll ( field , increment ) ; } }	adds the given amount to the given field and wraps the value of the field when it goes beyond the maximum or minimum value for the current date.
public string clusterresultstostring ( ) { return m_clusteringresults . tostring ( ) ; }	return the results of clustering .
private void generategetmodulemethod ( newbindingkey key , newdependencyinfo dependencyinfo ) { typeelement scope = scopecalculator . calculate ( key ) ; generategetmodulemethod ( scope , dependencyinfo ) ; }	creates get_foo_module ( ) for foomodule .
private void addcalendarevent ( string summary , date start , boolean allday , date end , string location , string description , string [ ] attendees ) { intent intent = new intent ( intent . action_insert ) ; intent . settype ( _str ) ; long startmilliseconds = start . gettime ( ) ; intent . putextra ( _str , startmilliseconds ) ; if ( allday ) { intent . putextra ( _str , _bool ) ; } long endmilliseconds ; if ( end == null ) { if ( allday ) { endmilliseconds = startmilliseconds + _num * _num * _num * _num ; } else { endmilliseconds = startmilliseconds ; } } else { endmilliseconds = end . gettime ( ) ; } intent . putextra ( _str , endmilliseconds ) ; intent . putextra ( _str , summary ) ; intent . putextra ( _str , location ) ; intent . putextra ( _str , description ) ; if ( attendees != null ) { intent . putextra ( intent . extra_email , attendees ) ; } try { rawlaunchintent ( intent ) ; } catch ( activitynotfoundexception anfe ) { log . w ( tag , _str + intent . action_insert ) ; intent . setaction ( intent . action_edit ) ; launchintent ( intent ) ; } }	sends an intent to create a new calendar event by prepopulating the add event ui.
private string [ ] separatorandenclosurestoarray ( ) { string [ ] parts = m_enclosures . split ( _str ) ; string [ ] result = new string [ parts . length + _num ] ; result [ _num ] = m_fieldseparator ; int index = _num ; for ( string e : parts ) { if ( e . length ( ) > _num || e . length ( ) == _num ) { throw new illegalargumentexception ( _str ) ; } result [ index ++ ] = e ; } return result ; }	assemble the field separator and enclosures into an array of strings.
private static void releasestringchars ( jnienvironment env , int objjref , address bufaddress ) { if ( tracejni ) vm . syswrite ( _str ) ; runtimeentrypoints . checkjnicountdowntogc ( ) ; try { syscall . sysfree ( bufaddress ) ; } catch ( throwable unexpected ) { if ( tracejni ) unexpected . printstacktrace ( system . err ) ; env . recordexception ( unexpected ) ; } }	releasestringchars : release buffer obtained via getstringchars.
private businessobjectdatanotificationregistrationentity createbusinessobjectdatanotificationentity ( namespaceentity namespaceentity , notificationeventtypeentity notificationeventtypeentity , businessobjectdefinitionentity businessobjectdefinitionentity , filetypeentity filetypeentity , storageentity storageentity , businessobjectdatastatusentity newbusinessobjectdatastatusentity , businessobjectdatastatusentity oldbusinessobjectdatastatusentity , notificationregistrationkey key , businessobjectdatanotificationfilter businessobjectdatanotificationfilter , list < jobaction > jobactions , notificationregistrationstatusentity notificationregistrationstatusentity ) { businessobjectdatanotificationregistrationentity businessobjectdatanotificationregistrationentity = new businessobjectdatanotificationregistrationentity ( ) ; businessobjectdatanotificationregistrationentity . setnamespace ( namespaceentity ) ; businessobjectdatanotificationregistrationentity . setname ( key . getnotificationname ( ) ) ; businessobjectdatanotificationregistrationentity . setnotificationeventtype ( notificationeventtypeentity ) ; businessobjectdatanotificationregistrationentity . setbusinessobjectdefinition ( businessobjectdefinitionentity ) ; if ( stringutils . isnotblank ( businessobjectdatanotificationfilter . getbusinessobjectformatusage ( ) ) ) { businessobjectdatanotificationregistrationentity . setusage ( businessobjectdatanotificationfilter . getbusinessobjectformatusage ( ) ) ; } businessobjectdatanotificationregistrationentity . setfiletype ( filetypeentity ) ; businessobjectdatanotificationregistrationentity . setbusinessobjectformatversion ( businessobjectdatanotificationfilter . getbusinessobjectformatversion ( ) ) ; businessobjectdatanotificationregistrationentity . setstorage ( storageentity ) ; businessobjectdatanotificationregistrationentity . setnewbusinessobjectdatastatus ( newbusinessobjectdatastatusentity ) ; businessobjectdatanotificationregistrationentity . setoldbusinessobjectdatastatus ( oldbusinessobjectdatastatusentity ) ; businessobjectdatanotificationregistrationentity . setnotificationregistrationstatus ( notificationregistrationstatusentity ) ; list < notificationactionentity > notificationactionentities = new arraylist < > ( ) ; businessobjectdatanotificationregistrationentity . setnotificationactions ( notificationactionentities ) ; for ( jobaction jobaction : jobactions ) { jobdefinitionentity jobdefinitionentity = jobdefinitiondaohelper . getjobdefinitionentity ( jobaction . getnamespace ( ) , jobaction . getjobname ( ) ) ; notificationjobactionentity notificationjobactionentity = new notificationjobactionentity ( ) ; notificationactionentities . add ( notificationjobactionentity ) ; notificationjobactionentity . setjobdefinition ( jobdefinitionentity ) ; notificationjobactionentity . setcorrelationdata ( jobaction . getcorrelationdata ( ) ) ; notificationjobactionentity . setnotificationregistration ( businessobjectdatanotificationregistrationentity ) ; } return businessobjectdatanotificationregistrationentity ; }	creates a new business object data notification registration entity from the request information .
void bind ( string jndiurl , hashtable < ? , ? > attributes , rmiserver rmiserver , boolean rebind ) throws namingexception , malformedurlexception { initialcontext ctx = new initialcontext ( attributes ) ; if ( rebind ) ctx . rebind ( jndiurl , rmiserver ) ; else ctx . bind ( jndiurl , rmiserver ) ; ctx . close ( ) ; }	bind a stub to a registry .
public string tostring ( ) { if ( info == null || algid == null || signature == null ) return _str ; stringbuilder sb = new stringbuilder ( ) ; sb . append ( _str ) ; sb . append ( info . tostring ( ) + _str ) ; sb . append ( _str + algid . tostring ( ) + _str ) ; hexdumpencoder encoder = new hexdumpencoder ( ) ; sb . append ( _str + encoder . encodebuffer ( signature ) ) ; sb . append ( _str ) ; return sb . tostring ( ) ; }	returns a printable representation of the certificate.
public void testobsoletedstzonename ( ) throws exception { simpledateformat format = new simpledateformat ( _str , locale . us ) ; date normal = format . parse ( _str ) ; date dst = format . parse ( _str ) ; assertequals ( _num * _num * _num , normal . gettime ( ) - dst . gettime ( ) ) ; }	africa / cairo standard time is eet and daylight time is eest.
public final void xprintlatin1nolf ( string string ) throws ioexception { if ( _source == null ) { return ; } if ( string == null ) { string = _str ; } byte [ ] writebuffer = _writebuffer ; int writelength = _writelength ; int length = string . length ( ) ; int offset = _num ; int charslength = chars_length ; char [ ] chars = _chars ; while ( length > _num ) { int sublen = math . min ( charslength , writebuffer . length - writelength ) ; if ( sublen <= _num ) { _source . write ( writebuffer , _num , writelength , _bool ) ; _position += writelength ; _isflushrequired = _bool ; writelength = _num ; sublen = math . min ( charslength , writebuffer . length - writelength ) ; } sublen = math . min ( length , sublen ) ; string . getchars ( offset , sublen , chars , _num ) ; for ( int i = _num ; i < sublen ; i ++ ) { byte value = ( byte ) chars [ i ] ; if ( value == _str || value == _str ) { length = _num ; break ; } writebuffer [ writelength ++ ] = value ; } offset += sublen ; length -= sublen ; } _writelength = writelength ; }	prints the character buffer to the stream encoded as latin1 .
private int calculatestrokeweight ( ) { int strokeweight = ( int ) ( getstrokewidth ( ) * _num ) ; logger . trace ( _str , strokewidth ) ; return strokeweight ; }	calculates the stroke weight in actual pixels *.
private static list < matchresult > flattenresults ( list < list < matchresult > > allresults ) { list < matchresult > results = new arraylist < matchresult > ( ) ; results . addall ( allresults . remove ( _num ) ) ; for ( list < matchresult > relresults : allresults ) { list < matchresult > newresults = new arraylist < matchresult > ( ) ; for ( matchresult curresult : results ) { for ( matchresult relresult : relresults ) { matchresult newresult = curresult . copy ( ) ; newresult . addassignment ( relresult ) ; newresults . add ( newresult ) ; } } results = newresults ; } return results ; }	creates the combination of all match results .
@ override public void visit ( mapping m , int line , int col , int nextline , int nextcol ) throws ioexception { if ( previousline != line ) { previouscolumn = _num ; } if ( line != nextline || col != nextcol ) { if ( line < maxline ) { if ( previousline == line ) { out . append ( _str ) ; } writeentry ( m , col ) ; previousline = line ; previouscolumn = col ; } else { preconditions . checkstate ( m == null ) ; } } for ( int i = line ; i <= nextline && i < maxline ; i ++ ) { if ( i == nextline ) { break ; } closeline ( _bool ) ; openline ( _bool ) ; } }	as each segment is visited write out the appropriate line mapping .
public boolean onclick ( int position ) { if ( mmode == mode_multiple_select ) { if ( mselecteditems . contains ( position ) ) { mselecteditems . remove ( position ) ; if ( mselecteditems . isempty ( ) ) { setmode ( mode_single_select ) ; } } else { mselecteditems . add ( position ) ; } notifyselectionchanged ( position ) ; return _bool ; } return _bool ; }	to be invoked when an item in the list is clicked ( even when not in multi selection mode ) .
public void addsessioneventurl ( string url , sessionid sid ) { set < sessionid > sids = sessioneventurls . get ( url ) ; if ( sids == null ) { sids = collections . newsetfrommap ( new concurrenthashmap < sessionid , boolean > ( ) ) ; set < sessionid > previousvalue = sessioneventurls . putifabsent ( url , sids ) ; if ( previousvalue != null ) { sids = previousvalue ; } } if ( sids . add ( sid ) ) { notifypersistencemanager ( ) ; } }	adds a listener for the associated session id .
abstract public long rangecount ( ) ;	the # of index entries .
public final void addinstwithunknown ( instances source , int attindex ) throws exception { double [ ] probs ; double weight , newweight ; int classindex ; instance instance ; int j ; probs = new double [ m_perbag . length ] ; for ( j = _num ; j < m_perbag . length ; j ++ ) { if ( utils . eq ( total , _num ) ) { probs [ j ] = _num / probs . length ; } else { probs [ j ] = m_perbag [ j ] / total ; } } enumeration < instance > enu = source . enumerateinstances ( ) ; while ( enu . hasmoreelements ( ) ) { instance = enu . nextelement ( ) ; if ( instance . ismissing ( attindex ) ) { classindex = ( int ) instance . classvalue ( ) ; weight = instance . weight ( ) ; m_perclass [ classindex ] = m_perclass [ classindex ] + weight ; total = total + weight ; for ( j = _num ; j < m_perbag . length ; j ++ ) { newweight = probs [ j ] * weight ; m_perclassperbag [ j ] [ classindex ] = m_perclassperbag [ j ] [ classindex ] + newweight ; m_perbag [ j ] = m_perbag [ j ] + newweight ; } } } }	adds all instances with unknown values for given attribute , weighted according to frequency of instances in each bag .
@ override public void onitemclick ( adapterview < ? > parent , view view , int position , long id ) { setselection ( position ) ; }	user selected an application.
public void traversefragment ( node pos ) throws org . xml . sax . saxexception { node top = pos ; while ( null != pos ) { startnode ( pos ) ; node nextnode = pos . getfirstchild ( ) ; while ( null == nextnode ) { endnode ( pos ) ; if ( top . equals ( pos ) ) break ; nextnode = pos . getnextsibling ( ) ; if ( null == nextnode ) { pos = pos . getparentnode ( ) ; if ( ( null == pos ) || ( top . equals ( pos ) ) ) { if ( null != pos ) endnode ( pos ) ; nextnode = null ; break ; } } } pos = nextnode ; } }	perform a pre - order traversal non - recursive style.
public void updateprocessorduration ( duration duration ) { processor_duration_ = optional . of ( duration ) ; }	update the processor duration .
static object invokeordie ( method method , object object , object ... params ) { try { return method . invoke ( object , params ) ; } catch ( illegalaccessexception e ) { throw new runtimeexception ( _str + _str , e ) ; } catch ( invocationtargetexception e ) { final throwable cause = e . getcause ( ) ; if ( cause instanceof runtimeexception ) { throw ( runtimeexception ) cause ; } else if ( cause instanceof error ) { throw ( error ) cause ; } else { throw new runtimeexception ( _str , cause ) ; } } }	calls invoke and throws a runtimeexception if it fails .
public void startelement ( string uri , string localname , string qname , attributes atts ) throws saxexception { elementlevel ++ ; nssupport . pushcontext ( ) ; if ( forcedtd && ! hasoutputdtd ) startdtd ( localname == null ? qname : localname , _str , _str ) ; write ( _str ) ; writename ( uri , localname , qname , _bool ) ; writeattributes ( atts ) ; if ( elementlevel == _num ) { forcensdecls ( ) ; } writensdecls ( ) ; write ( _str ) ; if ( htmlmode && ( qname . equals ( _str ) || qname . equals ( _str ) ) ) { cdataelement = _bool ; } super . startelement ( uri , localname , qname , atts ) ; }	write a start tag.
void initprogram ( ) { gluseprogram ( this . program ) ; viewmatrixuniform = glgetuniformlocation ( this . program , _str ) ; projmatrixuniform = glgetuniformlocation ( this . program , _str ) ; viewportsizeuniform = glgetuniformlocation ( this . program , _str ) ; gluseprogram ( _num ) ; }	initialize the shader program .
public static string [ ] sortcopy ( string [ ] objects ) { int len = objects . length ; string [ ] copy = new string [ len ] ; system . arraycopy ( objects , _num , copy , _num , len ) ; sort ( copy ) ; return copy ; }	sorts an array of strings , returning a new array with the sorted items.
public iterator < simevent > iterator ( ) { return list . iterator ( ) ; }	returns an iterator to the events in the queue .
private static boolean accepts ( string accept_header , string to_accept ) { string [ ] acceptvalues = accept_header . split ( _str ) ; arrays . sort ( acceptvalues ) ; return arrays . binarysearch ( acceptvalues , to_accept ) > - _num || arrays . binarysearch ( acceptvalues , to_accept . replaceall ( _str , _str ) ) > - _num || arrays . binarysearch ( acceptvalues , _str ) > - _num ; }	returns true if the given accept header accepts the given value .
public string [ ] tokenize ( string rawstring ) { vector < string > result = new vector < string > ( ) ; stringtokenizer tk = new stringtokenizer ( rawstring , m_seperator ) ; while ( tk . hasmoretokens ( ) ) { result . addelement ( tk . nexttoken ( ) ) ; } string [ ] newstrings = new string [ result . size ( ) ] ; for ( int i = _num ; i < result . size ( ) ; i ++ ) { newstrings [ i ] = result . elementat ( i ) ; } return newstrings ; }	tokenize the given string based on the seperator and put the tokens into an array of strings.
public synchronized void returnlogcursor ( logcursor logcursor ) { logcursor . setloaned ( _bool ) ; }	returns a loaned log cursor.
void unassignpolicies ( string servicename , set policydns , boolean toverify ) throws amexception , ssoexception { if ( ( policydns == null ) || ( policydns . isempty ( ) ) ) { return ; } amtemplate template = gettemplate ( servicename , amtemplate . policy_template ) ; unassignpolicies ( template , policydns , toverify ) ; }	unassigns the given policies from this object .
public boolean releaselock ( string lockname ) { if ( lockname == null || lockname . isempty ( ) ) { s_logger . info ( _str ) ; return _bool ; } try { interprocesslock lock = s_acquiredlocks . get ( lockname ) ; if ( lock != null ) { s_acquiredlocks . remove ( lockname ) ; lock . release ( ) ; s_logger . info ( _str + lockname ) ; } else { return _bool ; } return _bool ; } catch ( exception e ) { s_logger . error ( _str , lockname , e ) ; return _bool ; } }	release the passed lock .
@ parameterized . parameters ( name = _str ) public static collection < paymentchannelclient . versionselector > data ( ) { return arrays . aslist ( paymentchannelclient . versionselector . version_1 , paymentchannelclient . versionselector . version_2_allow_1 ) ; }	we use parameterized tests to run the channel connection tests with each version of the channel .
private view findinterceptingview ( float pos , view v ) { for ( keybuttonview otherview : mbuttonviews ) { if ( otherview == v ) { continue ; } if ( arrayutils . contains ( small_button_ids , otherview . getid ( ) ) ) { continue ; } otherview . getlocationonscreen ( slocation ) ; float otherpos = slocation [ mvertical ? _num : _num ] ; float otherdimension = mvertical ? v . getheight ( ) : v . getwidth ( ) ; if ( pos > ( otherpos + otherdimension / _num ) && pos < ( otherpos + otherdimension ) ) { return otherview ; } } return null ; }	find intersecting view in mbuttonviews.
public void detachdiskasync ( final string vmid , vmdiskoperation vmdiskoperation , final futurecallback < task > responsecallback ) throws ioexception { string path = string . format ( _str , getbasepath ( ) , vmid ) ; createobjectasync ( path , serializeobjectasjson ( vmdiskoperation ) , responsecallback ) ; }	detached a persistent disk to specified vm .
public static boolean isfpzero ( @ notnull final string text ) { for ( int i = _num ; i < text . length ( ) ; i ++ ) { final char c = text . charat ( i ) ; if ( character . isdigit ( c ) && c != _str ) return _bool ; final char d = character . touppercase ( c ) ; if ( d == _str || d == _str ) break ; } return _bool ; }	see jls 3 . 10 . 2 . floating - point literals.
public concurrenthashmappro ( map < ? extends k , ? extends v > m ) { this ( math . max ( ( int ) ( m . size ( ) / default_load_factor ) + _num , default_initial_capacity ) , default_load_factor , default_concurrency_level ) ; putall ( m ) ; }	creates a new map with the same mappings as the given map.
private void initialisecommands ( ) { reward = new achievementrewards ( this ) ; achievementdisplay = new achievementdisplay ( this ) ; givecommand = new givecommand ( this ) ; bookcommand = new bookcommand ( this ) ; topcommand = new topcommand ( this ) ; statscommand = new statscommand ( this ) ; infocommand = new infocommand ( this ) ; listcommand = new listcommand ( this ) ; helpcommand = new helpcommand ( this ) ; checkcommand = new checkcommand ( this ) ; deletecommand = new deletecommand ( this ) ; }	initialises the command modules .
public createcustommetric ( monitoring monitoringservice , string projectresource ) { this . monitoringservice = monitoringservice ; this . projectresource = projectresource ; this . metrictype = custom_metric_domain + _str + default_metric_type ; this . metricname = projectresource + _str + metrictype ; }	constructs an instance of the class using the default metric name .
public static boolean deletefilesinadirectory ( string directorypath ) { if ( ( directorypath == null ) || directorypath . isempty ( ) ) { return _bool ; } boolean issuccessfuldelete = _bool ; list < file > files = getlistoffilesinadirectory ( directorypath ) ; if ( files == null ) { return _bool ; } try { for ( file file : files ) { boolean filedeletesuccess = deletefile ( directorypath , file . getname ( ) ) ; if ( ! filedeletesuccess ) { issuccessfuldelete = _bool ; } } } catch ( exception e ) { logger . debug ( e . tostring ( ) + system . lineseparator ( ) + stacktrace . getstringfromstacktrace ( e ) ) ; issuccessfuldelete = _bool ; } return issuccessfuldelete ; }	this is a quiet method .
public annotationfs add ( annotationfs aoriginfs , annotationfs atargetfs , jcas ajcas , int astart , int aend , annotationfeature afeature , object alabelvalue ) throws bratannotationexception { if ( crossmultiplesentence || issamesentence ( ajcas , aoriginfs . getbegin ( ) , atargetfs . getend ( ) ) ) { return interaladdtocas ( ajcas , astart , aend , aoriginfs , atargetfs , alabelvalue , afeature ) ; } else { throw new arccrossedmultiplesentenceexception ( _str ) ; } }	update the cas with new / modification of arc annotations from brat.
public void testequalsnull ( ) { string a = _str ; int ascale = - _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; assertfalse ( anumber . equals ( null ) ) ; }	equals ( ) for equal bigdecimals.
private string readline ( ) { stringbuffer sb = new stringbuffer ( ) ; while ( buf . remaining ( ) > _num ) { char c = ( char ) buf . get ( ) ; if ( c == _str ) { if ( buf . remaining ( ) > _num ) { char n = ( char ) buf . get ( buf . position ( ) ) ; if ( n == _str ) { buf . get ( ) ; } } break ; } else if ( c == _str ) { break ; } sb . append ( c ) ; } return sb . tostring ( ) ; }	read a line of text.
protected void write ( dataoutputstream stream ) throws exception { stream . writeint ( value ) ; }	saving method . ( see nbt_tag ).
@ override public int showopendialog ( component parent ) { file selfile ; int result ; m_dialogtype = open_dialog ; initgui ( open_dialog ) ; result = super . showopendialog ( parent ) ; m_dialogtype = unhandled_dialog ; removepropertychangelistener ( m_listener ) ; selfile = getselectedfile ( ) ; if ( ( result == approve_option ) && ( getfilemustexist ( ) ) && ( selfile == null ) ) { result = showopendialog ( parent ) ; } else if ( ( result == approve_option ) && ( getfilemustexist ( ) ) && ( selfile != null ) && ( selfile . isfile ( ) ) && ( ! selfile . exists ( ) ) ) { int retval = joptionpane . showconfirmdialog ( parent , _str + selfile + _str ) ; if ( retval == joptionpane . ok_option ) result = showopendialog ( parent ) ; else result = cancel_option ; } if ( result == approve_option ) { if ( getfilefilter ( ) instanceof extensionfilefilter ) m_lastfilter = ( extensionfilefilter ) getfilefilter ( ) ; else m_lastfilter = null ; if ( getselectedfile ( ) != null ) configurecurrenthandlerhook ( open_dialog ) ; } return result ; }	pops up an " open file " file chooser dialog .
public boolean isnearlyequalto ( doublevector v , double tolerance ) { return math . abs ( v . x - x ) < tolerance && math . abs ( v . y - y ) < tolerance && math . abs ( v . z - z ) < tolerance ; }	checks if this vector is nearly equals to the vector v , with some tolerance .
void createverticalsnapanimation ( boolean visible ) { float translationy = visible ? _num : mtotalheight ; float ydifference = math . abs ( translationy - gettranslationy ( ) ) / mtotalheight ; long duration = ( long ) ( ms_animation_duration * ydifference ) ; createanimation ( _num , _num , translationy , duration ) ; }	create an animation that snaps the view into position vertically .
@ override public int update ( byte [ ] input , int inputoffset , int inputlen , byte [ ] output , int outputoffset ) throws shortbufferexception { return cipher . update ( input , inputoffset , inputlen , output , outputoffset ) ; }	continues a multiple - part encryption / decryption operation.
private string validateinputs ( ) { if ( jarradio . getselection ( ) ) { file f = new file ( jarpath . gettext ( ) ) ; if ( ! f . exists ( ) ) { return _str ; } if ( ! f . canread ( ) ) { return _str ; } } else { file f = new file ( dirpath . gettext ( ) ) ; if ( ! f . exists ( ) ) { return _str ; } if ( ! f . canread ( ) ) { return _str ; } } return null ; }	determine if the current set of analysis inputs are valid.
public static double parsedoublestring ( string st , texecutioncontext context ) { double ret = _num ; matcher m = double_pattern . matcher ( st ) ; if ( m . lookingat ( ) ) { string truncated = st . substring ( _num , m . end ( ) ) ; if ( ! truncated . equals ( st ) ) { context . reporttruncate ( st , truncated ) ; } try { ret = double . parsedouble ( truncated ) ; } catch ( numberformatexception e ) { context . reportbadvalue ( e . getmessage ( ) ) ; } } else context . reportbadvalue ( st ) ; return ret ; }	parse the st for a double value mysql compat in that illegal digits will be truncated and won ' t cause numberformatexception.
public classpath ( dexfile ... classpath ) throws ioexception { this ( lists . newarraylist ( classpath ) , _num ) ; }	creates a new classpath instance that can load classes from the given dex files.
public double greatcircleazimuth ( location location ) { if ( location == null ) { throw new illegalargumentexception ( logger . logmessage ( logger . error , _str , _str , _str ) ) ; } double lat1 = math . toradians ( this . latitude ) ; double lon1 = math . toradians ( this . longitude ) ; double lat2 = math . toradians ( location . latitude ) ; double lon2 = math . toradians ( location . longitude ) ; if ( lat1 == lat2 && lon1 == lon2 ) { return _num ; } if ( lon1 == lon2 ) { return lat1 > lat2 ? _num : _num ; } double y = math . cos ( lat2 ) * math . sin ( lon2 - lon1 ) ; double x = math . cos ( lat1 ) * math . sin ( lat2 ) - math . sin ( lat1 ) * math . cos ( lat2 ) * math . cos ( lon2 - lon1 ) ; double azimuthradians = math . atan2 ( y , x ) ; return double . isnan ( azimuthradians ) ? _num : math . todegrees ( azimuthradians ) ; }	computes the azimuth angle ( clockwise from north ) for the great circle path between this location and a specified location.
private boolean [ ] defineirrelevant ( random random ) { boolean [ ] irr = new boolean [ getnumattributes ( ) ] ; for ( int i = _num ; i < irr . length ; i ++ ) { irr [ i ] = _bool ; } int numirr = _num ; for ( int i = _num ; ( numirr < getnumirrelevant ( ) ) && ( i < getnumattributes ( ) * _num ) ; i ++ ) { int maybenext = ( int ) ( random . nextdouble ( ) * irr . length ) ; if ( irr [ maybenext ] == _bool ) { irr [ maybenext ] = _bool ; numirr ++ ; } } return irr ; }	defines randomly the attributes as irrelevant.
public void adddropitem ( final string name , final double probability , final int amount ) { dropsitems . add ( new dropitem ( name , probability , amount ) ) ; }	adds a named item to the list of items that will be dropped on dead if cleardropitemlist hasn ' t been called first , this will change all creatures of this kind .
protected void unparsedentdecl ( string name , string pubid , string sysid , string notation ) throws saxexception { mhanddtd . unparsedentitydecl ( name , pubid , sysid , notation ) ; }	reports unparsed entity name .
public enumeration < permission > elements ( ) { synchronized ( this ) { return collections . enumeration ( permsmap . values ( ) ) ; } }	returns an enumeration of all the permission objects in the container .
private static string formatlist ( string [ ] stringlist , string listpattern , string listcompositionpattern ) { if ( listpattern == null || listcompositionpattern == null ) { stringbuilder result = new stringbuilder ( ) ; for ( int i = _num ; i < stringlist . length ; ++ i ) { if ( i > _num ) { result . append ( _str ) ; } result . append ( stringlist [ i ] ) ; } return result . tostring ( ) ; } if ( stringlist . length > _num ) { messageformat format = new messageformat ( listcompositionpattern ) ; stringlist = composelist ( format , stringlist ) ; } object [ ] args = new object [ stringlist . length + _num ] ; system . arraycopy ( stringlist , _num , args , _num , stringlist . length ) ; args [ _num ] = new integer ( stringlist . length ) ; messageformat format = new messageformat ( listpattern ) ; return format . format ( args ) ; }	format a list using given pattern strings.
public jsonarray add ( object value ) { list . add ( value ) ; return this ; }	adds an entry into the json array .
public string comment ( ) throws parseexception { stringbuffer retval = new stringbuffer ( ) ; if ( lookahead ( _num ) != _str ) return null ; consume ( _num ) ; while ( _bool ) { char next = getnextchar ( ) ; if ( next == _str ) { break ; } else if ( next == _str ) { throw new parseexception ( this . buffer + _str , this . ptr ) ; } else if ( next == _str ) { retval . append ( next ) ; next = getnextchar ( ) ; if ( next == _str ) throw new parseexception ( this . buffer + _str , this . ptr ) ; retval . append ( next ) ; } else { retval . append ( next ) ; } } return retval . tostring ( ) ; }	parse a comment string cursor is at a " ( " . leave cursor at ).
public static boolean ignorablewhitespace ( string value ) { matcher m ; m = whitespacepattern . matcher ( value ) ; if ( m . matches ( ) ) return _bool ; else return _bool ; }	determine if a string contains only ignorable white spaces .
public delphiworkgroup ( file xmlfile ) throws ioexception { if ( xmlfile == null ) { throw new illegalargumentexception ( _str ) ; } else if ( ! xmlfile . exists ( ) ) { throw new ioexception ( _str + xmlfile . getabsolutepath ( ) ) ; } parsefile ( xmlfile ) ; }	c - tor , gets project list from xml file.
public bufferedblockcipher ( blockcipher cipher ) { this . cipher = cipher ; buf = new byte [ cipher . getblocksize ( ) ] ; bufoff = _num ; string name = cipher . getalgorithmname ( ) ; int idx = name . indexof ( _str ) + _num ; pgpcfb = ( idx > _num && name . startswith ( _str , idx ) ) ; if ( pgpcfb || cipher instanceof streamcipher ) { partialblockokay = _bool ; } else { partialblockokay = ( idx > _num && ( name . startswith ( _str , idx ) ) ) ; } }	create a buffered block cipher without padding .
public static int readints ( final file f , final longindex a , final long offset , final long addend ) throws ioexception { return readints ( f , _num , ( int ) f . length ( ) / _num , a , offset , addend ) ; }	read an array of longs from a file .
public void waitallsitesdbstable ( ) { string prefix = _str ; log . info ( prefix ) ; dbjmxclient geoinstance = getjmxclient ( localhost ) ; list < uri > vdciditer = querybytype ( virtualdatacenter . class , _bool ) ; for ( uri vdcid : vdciditer ) { log . info ( _str , vdcid . tostring ( ) ) ; virtualdatacenter vdc = queryobject ( virtualdatacenter . class , vdcid ) ; if ( ! shouldcheckdbstatus ( vdc ) ) { log . error ( _str , vdcid ) ; continue ; } if ( vdc . getconnectionstatus ( ) != connectionstatus . disconnected ) { site activesite = drutil . getactivesite ( vdc . getshortid ( ) ) ; waitdbnodesstable ( geoinstance , vdc . getshortid ( ) , activesite . getnodecount ( ) ) ; } } }	waits for the db instances joined in all sites.
public void savehierarchystate ( bundle container ) { dispatchsaveinstancestate ( container ) ; }	store this preference hierarchy ' s frozen state into the given container .
private static void pipe ( inputstream source , outputstream dest ) throws ioexception { byte [ ] buf = new byte [ _num ] ; int read = _num ; while ( ( read = source . read ( buf ) ) >= _num ) { if ( null != dest ) dest . write ( buf , _num , read ) ; } if ( null != dest ) dest . flush ( ) ; }	pipes everything from the source to the dest.
@ override public void init ( filterconfig config ) throws servletexception { try { expiry = math . min ( math . max ( min_expiry , long . parselong ( config . getinitparameter ( cache_control ) ) ) , max_expiry ) ; } catch ( numberformatexception nfe ) { logger . warn ( _str + cache_control + _str , nfe ) ; expiry = null ; } }	parse the cache - control configuration parameter as a long integer , and set the filter expiry value , modulo the minimum and maximum expiry constraints.
@ override public int hashcode ( ) { int code = _num ; if ( name != null ) { code += name . hashcode ( ) ; } if ( applicationname != null ) { code += applicationname . hashcode ( ) ; } if ( resourcenames != null ) { code += resourcenames . hashcode ( ) ; } if ( actionvalues != null ) { code += actionvalues . hashcode ( ) ; } if ( advices != null ) { code += advices . hashcode ( ) ; } if ( attributes != null ) { code += attributes . hashcode ( ) ; } return code ; }	returns hash code of the object.
public static boolean substracttradingfee ( player player , int price ) { bigdecimal fee = calculatefee ( player , price ) ; return player . drop ( _str , fee . intvalue ( ) ) ; }	substracts the trading fee from the player depending on the given price.
public complexparameter ( mathexpression expression ) { this . expression = expression ; }	constructs a new complex parameter with the given expression , assuming the list of parameters is provided as labels within the expression .
public sampledriver ( ) { handlers = new arraylist < samplehandler > ( ) ; handlers . add ( new certificatesamplehandler ( ) ) ; handlers . add ( new groupsamplehandler ( ) ) ; handlers . add ( new solutionusersamplehandler ( ) ) ; handlers . add ( new usersamplehandler ( ) ) ; }	initialize sample driver with a list of handlers .
public long [ ] readlongarray ( final int items , final jbbpbyteorder byteorder ) throws ioexception { int pos = _num ; if ( items < _num ) { long [ ] buffer = new long [ initial_array_buffer_size ] ; while ( hasavailabledata ( ) ) { final long next = readlong ( byteorder ) ; if ( buffer . length == pos ) { final long [ ] newbuffer = new long [ buffer . length << _num ] ; system . arraycopy ( buffer , _num , newbuffer , _num , buffer . length ) ; buffer = newbuffer ; } buffer [ pos ++ ] = next ; } if ( buffer . length == pos ) { return buffer ; } final long [ ] result = new long [ pos ] ; system . arraycopy ( buffer , _num , result , _num , pos ) ; return result ; } else { final long [ ] buffer = new long [ items ] ; for ( int i = _num ; i < items ; i ++ ) { buffer [ i ] = readlong ( byteorder ) ; } return buffer ; } }	read number of long items from the input stream .
private void loggraphicalbufferoccupancy ( float bufferoccupancy ) { string title = _str ; int used = ( int ) ( bufferoccupancy * width ) ; stringbuilder sb = new stringbuilder ( ) ; sb . append ( start_end_char ) ; sb . append ( _str ) ; sb . append ( title ) ; for ( int i = title . length ( ) + _num ; i < width ; i ++ ) { sb . append ( _str ) ; } sb . append ( start_end_char ) ; log . info ( sb . tostring ( ) ) ; sb = new stringbuilder ( ) ; sb . append ( start_end_char ) ; for ( int i = _num ; i < used ; i ++ ) { sb . append ( _str ) ; } for ( int j = used ; j < width ; j ++ ) { sb . append ( _str ) ; } sb . append ( start_end_char ) ; log . info ( sb . tostring ( ) ) ; sb = new stringbuilder ( ) ; sb . append ( start_end_char ) ; for ( int i = _num ; i < width ; i ++ ) { sb . append ( _str ) ; } sb . append ( start_end_char ) ; log . info ( sb . tostring ( ) ) ; }	log a graphical version of buffer occupancy .
public boolean isterminated ( ) { return threadpool . isterminated ( ) ; }	checks if is terminated .
public boolean ismatch ( string domain , list < usermappingattribute > attributes , list < string > groups ) { return _domain . equalsignorecase ( domain ) && attributesmatch ( attributes ) && groupsmatch ( groups ) ; }	check if the domain , attributes , and groups results in a match with this usermapping object.
public static void writespatialgridtable ( spatialgrid grid , string filename ) { log . info ( _str + filename + _str ) ; spatialgridtablewriter sgtablewriter = new spatialgridtablewriter ( ) ; try { sgtablewriter . write ( grid , filename ) ; log . info ( _str ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }	stores measured accessibilities in a file.
@ suppresswarnings ( _str ) public outputsocket linkedoutputsocket ( string hintidentifier ) { final outputsocket outsocket = outputsocketfactory . create ( new identiferoverridingsockethintdecorator ( this , hintidentifier ) ) ; controlledoutputsockets . add ( outsocket ) ; return outsocket ; }	creates an input socket that is linked to this socket this output socket will automatically be disconnected when there is no longer an input socket to guarantee the type of this sockethint .
public void cancel ( ) { cancelled = _bool ; thread thread = this . thread ; if ( thread != null ) { thread . interrupt ( ) ; } }	stop execution of the task.
void _settext ( byte [ ] text ) { this . _text = text ; this . _props = null ; }	this is used internally by the framework.
private string prepareurl ( ) { string str = _str ; str += _str ; for ( int i = _num ; i < symbollist . size ( ) ; i ++ ) { if ( i != _num ) { str += _str ; } str += symbollist . get ( i ) ; } str += _str ; for ( string format : parameterlist ) { str += format ; } str += _str ; return str ; }	prepare url from symbols and parameters.
public void initialize ( ) { texturestate ts = new texturestate ( ) ; ts . setenabled ( _bool ) ; setrenderstate ( ts ) ; for ( int i = _num ; i < toollist . size ( ) ; ++ i ) { toolstate state = toollist . get ( i ) ; addtool ( state , _bool ) ; } zbufferstate = new zbufferstate ( ) ; zbufferstate . setfunction ( zbufferstate . testfunction . lessthanorequalto ) ; zbufferstate . setenabled ( _bool ) ; setrenderstate ( zbufferstate ) ; }	create and add the tools to the scene graph.
private static void init ( ) { encoders = new hashmap ( ) ; encoders . put ( _str , _str ) ; encoders . put ( _str , _str ) ; }	sets up default encoders ( uses sun png encoder if jdk 1.
public static boolean checkimagesize ( final inputstream stream , final iconfiguration conf ) throws ioexception { bufferedimage bi = imageio . read ( stream ) ; stream . close ( ) ; if ( bi == null ) { return _bool ; } if ( bi . getheight ( ) > conf . getimgheight ( ) || bi . getwidth ( ) > conf . getimgwidth ( ) ) { return _bool ; } return _bool ; }	check if image size isn ' t bigger then bigest allowed .
private static boolean comparearraycase ( final string value , final int comparator , final object [ ] array ) { for ( int i = _num ; i < array . length ; i ++ ) { final object obj = array [ i ] ; if ( obj instanceof string ) { if ( comparestringcase ( value , comparator , ( string ) obj ) ) { return _bool ; } } else if ( obj instanceof number ) { if ( comparenumber ( value . trim ( ) , comparator , ( number ) obj ) ) { return _bool ; } } else { if ( comparereflective ( value , comparator , obj ) ) { return _bool ; } } } return _bool ; }	compare arrays . case sensitive .
public double valueat ( double x ) { return constant * math . pow ( _num - x * x , outsideexp ) ; }	calculates the value of the function at the given domain point .
protected double generatewaittime ( ) { if ( state == state_walking_elsewhere ) { if ( location . equals ( latestbusstop ) ) { state = state_waiting_for_bus ; } } if ( state == state_travelling_on_bus ) { state = state_waiting_for_bus ; } return _num ; }	switches state between getpath ( ) calls.
@ override public enumeration < url > findresources ( final string name ) throws ioexception { if ( name == null ) { return null ; } arraylist < url > result = new arraylist < url > ( ) ; int n = _num ; while ( _bool ) { urlhandler handler = gethandler ( n ++ ) ; if ( handler == null ) { break ; } handler . findresources ( name , result ) ; } return collections . enumeration ( result ) ; }	returns all known urls which point to the specified resource .
protected void writegraphicctrlext ( ) throws ioexception { out . write ( _num ) ; out . write ( _num ) ; out . write ( _num ) ; int transp , disp ; if ( transparent == null ) { transp = _num ; disp = _num ; } else { transp = _num ; disp = _num ; } if ( dispose >= _num ) { disp = dispose & _num ; } disp <<= _num ; out . write ( _num | disp | _num | transp ) ; writeshort ( delay ) ; out . write ( transindex ) ; out . write ( _num ) ; }	writes graphic control extension.
public static void writeelementlist ( xmloutput xmloutput , string tagname , iterable < string > listvalues ) throws ioexception { writeelementlist ( xmloutput , tagname , listvalues . iterator ( ) ) ; }	write a list of strings to document as elements with given tag name .
public static date stringtodate ( string dateasstring ) { try { dateformat df = new simpledateformat ( dateformat ) ; df . settimezone ( utc ) ; return df . parse ( dateasstring ) ; } catch ( parseexception e ) { return null ; } catch ( nullpointerexception e ) { return null ; } }	converts a string representation of a date to its respective date object .
public simplehttprequestbuilder content ( string chars , charset charset ) { return content ( chars . getbytes ( charset ) ) ; }	sets the given string to be used as the request content , decoding to bytes with the given charset .
private double adjusttransform ( ) { double xmin = double . positive_infinity ; double xmax = double . negative_infinity ; double ymin = double . positive_infinity ; double ymax = double . negative_infinity ; for ( variable var : csp . getvariables ( ) ) { point2d point = getposition ( var ) ; xmin = math . min ( xmin , point . getx ( ) ) ; xmax = math . max ( xmax , point . getx ( ) ) ; ymin = math . min ( ymin , point . gety ( ) ) ; ymax = math . max ( ymax , point . gety ( ) ) ; } double scale = math . min ( pane . getwidth ( ) / ( xmax - xmin + _num ) , pane . getheight ( ) / ( ymax - ymin + _num ) ) ; pane . settranslatex ( ( scale * ( pane . getwidth ( ) - xmin - xmax ) / _num ) ) ; pane . settranslatey ( ( scale * ( pane . getheight ( ) - ymin - ymax ) / _num ) ) ; pane . setscalex ( scale ) ; pane . setscaley ( scale ) ; return scale ; }	computes transforms ( translations and scaling ) and applies them to the environment state view.
public void addtablemodellistener ( wtablemodellistener listener ) { if ( listener == null ) { return ; } if ( ! m_listeners . contains ( listener ) ) { m_listeners . add ( listener ) ; } return ; }	add a listener for events from the data model.
public boolean cantraverseoutsidesubtree ( ) { if ( null != m_parts ) { int n = m_parts . size ( ) ; for ( int i = _num ; i < n ; i ++ ) { avtpart part = ( avtpart ) m_parts . elementat ( i ) ; if ( part . cantraverseoutsidesubtree ( ) ) return _bool ; } } return _bool ; }	tell if this expression or it ' s subexpressions can traverse outside the current subtree .
private int [ ] parseymd ( string string ) { string = string . trim ( ) ; try { if ( string . charat ( _num ) != _str || string . charat ( _num ) != _str ) { throw new illegalargumentexception ( _str ) ; } int [ ] ymd = new int [ _num ] ; ymd [ _num ] = integer . valueof ( string . substring ( _num , _num ) ) ; ymd [ _num ] = integer . valueof ( string . substring ( _num , _num ) ) ; ymd [ _num ] = integer . valueof ( string . substring ( _num , _num ) ) ; return ymd ; } catch ( numberformatexception ex ) { throw new illegalargumentexception ( _str , ex ) ; } }	parse yyyy - mm - dd into a 3 element array [ yyyy , mm , dd ] .
public abstractpointrenderer ( ) { shape = new rectangle2d . double ( - _num , - _num , _num , _num ) ; color = new singlecolor ( color . black ) ; valuevisible = _bool ; valuecolumn = _num ; valuelocation = location . center ; valuealignmentx = _num ; valuealignmenty = _num ; valuerotation = _num ; valuedistance = _num ; valuecolor = new singlecolor ( color . black ) ; valuefont = font . decode ( null ) ; errorvisible = _bool ; errorcolumntop = _num ; errorcolumnbottom = _num ; errorcolor = new singlecolor ( color . black ) ; errorshape = new line2d . double ( - _num , _num , _num , _num ) ; errorstroke = new basicstroke ( _num ) ; }	creates a new abstractpointrenderer object with default shape and color .
public object put ( string key , object value ) { object oldvalue = context . getattribute ( key , engine_scope ) ; context . setattribute ( key , value , engine_scope ) ; return oldvalue ; }	set the key , value binding in the engine_scope of the context .
public void test_getlowestsetbitpos ( ) { byte abytes [ ] = { - _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = _num ; int inumber = _num ; biginteger anumber = new biginteger ( asign , abytes ) ; int result = anumber . getlowestsetbit ( ) ; asserttrue ( _str , result == inumber ) ; byte [ ] abytes_ = { _num , _num , _num } ; inumber = _num ; anumber = new biginteger ( asign , abytes_ ) ; result = anumber . getlowestsetbit ( ) ; asserttrue ( _str , result == inumber ) ; byte [ ] abytes__ = { - _num , _num , _num } ; inumber = _num ; anumber = new biginteger ( asign , abytes__ ) ; result = anumber . getlowestsetbit ( ) ; asserttrue ( _str , result == inumber ) ; }	java . math . biginteger # getlowestsetbit ( ) getlowestsetbit for positive biginteger.
private void executeanotherrequest ( ) throws sqlexception { random random = new random ( ) ; int value = random . nextint ( ) ; preparedstatement preparedstatement = sharedconnection . preparestatement ( _str + value ) ; resultset rs = preparedstatement . executequery ( ) ; rs . next ( ) ; assertequals ( value , rs . getint ( _num ) ) ; }	execute another query to verify exchange integrity .
public static int hash ( byte [ ] data , int seed ) { return hash ( bytebuffer . wrap ( data ) , seed ) ; }	hashes bytes in an array .
public int parse ( char c , char [ ] ia , int ip , int il ) { assert ( ia [ ip ] == c ) ; if ( surrogate . ishigh ( c ) ) { if ( il - ip < _num ) { error = coderresult . underflow ; return - _num ; } char d = ia [ ip + _num ] ; if ( surrogate . islow ( d ) ) { character = toucs4 ( c , d ) ; ispair = _bool ; error = null ; return character ; } error = coderresult . malformedforlength ( _num ) ; return - _num ; } if ( surrogate . islow ( c ) ) { error = coderresult . malformedforlength ( _num ) ; return - _num ; } character = c ; ispair = _bool ; error = null ; return character ; }	parses a ucs - 4 character from the given source buffer , handling surrogates .
public void performstartoperationasync ( final string vmid , final futurecallback < task > responsecallback ) throws ioexception { string path = string . format ( _str , getbasepath ( ) , vmid ) ; createobjectasync ( path , null , responsecallback ) ; }	perform a vm start operation on specified vm .
public boolean thisdevicespeaksto ( bluetoothdevice other ) throws nosuchalgorithmexception , unsupportedencodingexception { if ( murmurservice . use_backoff ) return _bool ; if ( other == null ) { log . info ( _str ) ; return _bool ; } string otheraddr = other . getaddress ( ) ; if ( otheraddr == null ) { log . info ( _str + other + _str ) ; return _bool ; } string myaddr = mbluetoothspeaker . getaddress ( ) ; if ( myaddr . equals ( whichinitiates ( myaddr , otheraddr ) ) ) { return _bool ; } else { return _bool ; } }	check whether this device should start an exchange with the other device or allow that device to start an exchange , based on their addresses .
public static < k , v > list < keyvalue < k , v > > waituntilminkeyvaluerecordsreceived ( properties consumerconfig , string topic , int expectednumrecords , long waittime ) throws interruptedexception { list < keyvalue < k , v > > accumdata = new arraylist < > ( ) ; long starttime = system . currenttimemillis ( ) ; while ( _bool ) { list < keyvalue < k , v > > readdata = readkeyvalues ( topic , consumerconfig ) ; accumdata . addall ( readdata ) ; if ( accumdata . size ( ) >= expectednumrecords ) return accumdata ; if ( system . currenttimemillis ( ) > starttime + waittime ) throw new assertionerror ( _str + expectednumrecords + _str + accumdata . size ( ) + _str + waittime + _str ) ; thread . sleep ( math . min ( waittime , _num ) ) ; } }	wait until enough data ( key - value records ) has been consumed .
public static < t > combineddownloadtask < t > single ( downloadtask < t > task ) { objects . requirenonnull ( task ) ; return new singlecombinedtask < t > ( task ) ; }	creates a combineddownloadtask from a downloadtask .
public void addhexlistener ( final ihexpanellistener listener ) { preconditions . checknotnull ( listener , _str ) ; if ( ! m_listeners . contains ( listener ) ) { m_listeners . add ( listener ) ; } }	adds a new event listener to the list of event listeners .
public static < t extends serializableentity > deserializer roundtripserializableentitywithbinaryserializer ( final t originalentity , final accountlookup accountlookup ) { final binaryserializer binaryserializer = new binaryserializer ( ) ; originalentity . serialize ( binaryserializer ) ; return new binarydeserializer ( binaryserializer . getbytes ( ) , new deserializationcontext ( accountlookup ) ) ; }	serializes originalentity and returns a binary deserializer that can deserialize it .
@ deprecated public static string encode ( final string s , final string encoding , bitset safeoctets , boolean plusforspace ) throws unsupportedencodingexception { stringbuilder out = new stringbuilder ( s . length ( ) * _num ) ; boolean needsencoding ; try { needsencoding = encode ( s , encoding , safeoctets , plusforspace , out ) ; } catch ( unsupportedencodingexception e ) { throw e ; } catch ( ioexception e ) { throw new assertionerror ( e ) ; } if ( needsencoding ) { return out . tostring ( ) ; } else { return s ; } }	url - escapes s by encoding it with the specified character encoding , and then escaping all octets not included in safeoctets .
public static void fireclipboardchanged ( ) { for ( iterator i = listenerlist . iterator ( ) ; i . hasnext ( ) ; ) { clipboardlistener listener = ( clipboardlistener ) i . next ( ) ; listener . clipboardchanged ( ) ; } }	fire a clipboard changed event to all registered model listeners .
public boolean isempty ( ) { return window . isempty ( ) ; }	returns true to indicate the window is empty , or false if the view is not empty .
public boolean contains ( t listener ) { if ( mlisteners != null ) { return mlisteners . contains ( listener ) ; } else { return _bool ; } }	gets whether the specified listener object is contained in the chain .
public simpledictionary ( string ... awords ) { words = new hashset < string > ( ) ; for ( string word : awords ) { words . add ( word . tolowercase ( ) ) ; } }	create a simple dictionary from a list of string . this can be used for testing.
public long readlongle ( ) throws ioexception { inputstream . readfully ( workspace , _num , _num ) ; return ( ( long ) ( workspace [ _num ] & _num ) << _num ) | ( ( long ) ( workspace [ _num ] & _num ) << _num ) | ( ( long ) ( workspace [ _num ] & _num ) << _num ) | ( ( long ) ( workspace [ _num ] & _num ) << _num ) | ( ( long ) ( workspace [ _num ] & _num ) << _num ) | ( ( long ) ( workspace [ _num ] & _num ) << _num ) | ( ( long ) ( workspace [ _num ] & _num ) << _num ) | ( ( long ) ( workspace [ _num ] & _num ) ) ; }	read a 64bit long in le.
public void testsetpublickey2 ( ) throws exception { identity i2 = new identitystub ( _str , identityscope . getsystemscope ( ) ) ; new publickeystub ( _str , _str , new byte [ ] { _num , _num , _num , _num , _num } ) ; try { i2 . setpublickey ( null ) ; } catch ( keymanagementexception ok ) { } }	verify identity . setpublickey ( ) throws keymanagementexception if key is invalid.
@ layoutlibdelegate static long elapsedrealtime ( ) { return system . currenttimemillis ( ) - sboottime ; }	returns milliseconds since boot , including time spent in sleep .
@ override public void fillassignedkeys ( set < string > keys ) { keys . add ( _keycolumn . name ( ) ) ; }	returns all the keys assigned statically , e.
@ override public void removeinstancelistener ( instancelistener dsl ) { m_instancelisteners . remove ( dsl ) ; }	remove an instance listener.
public double eccentricity ( ) { return math . sqrt ( _num - ( semiminoraxis ( ) * semiminoraxis ( ) ) / ( semimajoraxis ( ) * semimajoraxis ( ) ) ) ; }	gets the eccentricity of the ellipse , between 0 ( inclusive ) and 1 ( exclusive ).
private void simpleapply ( idocument document , string string , configurablecompletionproposal proposal ) throws badlocationexception { proposal . setcursorposition ( string . length ( ) ) ; document . replace ( proposal . getreplacementoffset ( ) , proposal . getreplacementlength ( ) , string ) ; }	just insert the string at the replacement offset.
public string pulldump2pc ( ) { string serial = device . getserialnumber ( ) ; file dest = new file ( fileutils . gettempdirectory ( ) , serial + _str ) ; string path = dest . getpath ( ) ; log . debug ( _str , path ) ; commandline commandpull = adbcommand ( _str , _str , path ) ; string out = executecommandquietly ( commandpull ) ; log . debug ( _str , out ) ; return path ; }	pull dump file from android device to pc.
@ after public void executetest ( ) throws throwable { try { testenv . executetest ( ) ; } catch ( assertionerror assertionerror ) { if ( testenv . hasbeenstopped ( ) ) { throw new assertionerror ( _str + assertionerror . getmessage ( ) ) ; } throw assertionerror ; } }	executes the test and verifies the output received .
public void validateemrclusterdefinitionkey ( emrclusterdefinitionkey key ) throws illegalargumentexception { assert . notnull ( key , _str ) ; key . setnamespace ( alternatekeyhelper . validatestringparameter ( _str , key . getnamespace ( ) ) ) ; key . setemrclusterdefinitionname ( alternatekeyhelper . validatestringparameter ( _str , _str , key . getemrclusterdefinitionname ( ) ) ) ; }	validates the emr cluster definition key.
@ targetapi ( version_codes . kitkat ) private void handlesmsreceived ( intent intent ) { if ( buildconfig . debug ) log . v ( _str ) ; bundle bundle = intent . getextras ( ) ; if ( bundle != null ) { smsmessage [ ] messages = null ; if ( smspopuputils . haskitkat ( ) ) { messages = intents . getmessagesfromintent ( intent ) ; } else { messages = smspopuputils . getmessagesfromintent ( intent ) ; } if ( messages != null ) { notifymessagereceived ( new smsmmsmessage ( context , messages , system . currenttimemillis ( ) ) ) ; } } }	handle receiving a sms message.
public static long installage ( long currenttimestamp , long installtimestamp , boolean sendinstallevent ) { if ( sendinstallevent ) { return install_age_immediately_after_installing ; } else { return math . max ( _num , ( currenttimestamp - installtimestamp ) / ms_per_day ) ; } }	determine how long it ' s been since chrome was first installed.
public boolean isdistributed ( ) { return ! islocal ( ) ; }	returns true if the virtual volume is a distributed volume .
public void testvalueoflongnegative1 ( ) { long longval = - _num ; biginteger anumber = biginteger . valueof ( longval ) ; byte rbytes [ ] = { - _num , _num , _num , - _num , _num , _num , - _num , - _num } ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = anumber . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , anumber . signum ( ) ) ; }	valueof ( long val ) : convert a negative long value to a biginteger .
public synchronized boolean isconsumer ( imageconsumer ic ) { return theconsumers . contains ( ic ) ; }	determines if an imageconsumer is on the list of consumers currently interested in data for this image .
public static boolean verifysignature ( signature initializedsignatureengine , byte [ ] message , byte [ ] signature ) throws signatureexception { initializedsignatureengine . update ( message ) ; return initializedsignatureengine . verify ( signature ) ; }	verify the signature of a message .
public static void writevarint ( outputstream out , int x ) throws ioexception { while ( ( x & ~ _num ) != _num ) { out . write ( ( byte ) ( _num | ( x & _num ) ) ) ; x >>>= _num ; } out . write ( ( byte ) x ) ; }	write a variable size int .
public segmentpath complete ( endtype etype ) { segmentpath result ; if ( data == null || w < _num ) { return null ; } if ( w == data . length ) { result = new segmentpath ( data , etype ) ; reset ( _num ) ; } else { double [ ] datatoadopt = new double [ w ] ; system . arraycopy ( data , _num , datatoadopt , _num , w ) ; result = new segmentpath ( datatoadopt , etype ) ; reset ( _num ) ; } return result ; }	complete building a segmentpath.
@ deprecated public static bundle parseurl ( string url ) { url = url . replace ( _str , _str ) ; try { url u = new url ( url ) ; bundle b = decodeurl ( u . getquery ( ) ) ; b . putall ( decodeurl ( u . getref ( ) ) ) ; return b ; } catch ( malformedurlexception e ) { return new bundle ( ) ; } }	parse a url query and fragment parameters into a key - value bundle .
private static void createtmpfile ( completablefuture < newfile > filecreation , path destdir , list < tsdata > files ) { log . log ( level . fine , _str ) ; try { collections . sort ( files , comparator . comparing ( null ) ) ; final filechannel fd = fileutil . createtempfile ( destdir , _str , _str ) ; try { final datetime begin ; try ( toxdrtables output = new toxdrtables ( fd , compression . default_optimized ) ) { while ( ! files . isempty ( ) ) { tsdata tsdata = files . remove ( _num ) ; if ( filecreation . iscancelled ( ) ) throw new ioexception ( _str ) ; output . addall ( tsdata ) ; } begin = new datetime ( output . gethdrbegin ( ) , datetimezone . utc ) ; if ( filecreation . iscancelled ( ) ) throw new ioexception ( _str ) ; } if ( filecreation . iscancelled ( ) ) throw new ioexception ( _str ) ; install_pool . execute ( null ) ; } catch ( error | runtimeexception | ioexception ex ) { try { fd . close ( ) ; } catch ( error | runtimeexception | ioexception ex1 ) { ex . addsuppressed ( ex1 ) ; } throw ex ; } } catch ( error | runtimeexception | ioexception ex ) { log . log ( level . warning , _str , ex ) ; synchronized ( outstanding ) { outstanding . remove ( filecreation ) ; } filecreation . completeexceptionally ( ex ) ; } }	the fork - join task that creates a new file.
public void contenttag ( string tag , string name , string value , string content ) { spacing ( ) ; m_out . print ( _str ) ; m_out . print ( tag ) ; m_out . print ( _str ) ; m_out . print ( name ) ; m_out . print ( _str ) ; m_out . print ( _str ) ; escapestring ( value ) ; m_out . print ( _str ) ; m_out . print ( _str ) ; escapestring ( content ) ; m_out . print ( _str ) ; m_out . print ( _str ) ; m_out . print ( tag ) ; m_out . print ( _str ) ; println ( ) ; }	print a new content tag with a single attribute , consisting of an open tag , content text , and a closing tag , all on one line .
public void addchild ( component child ) { components . add ( child ) ; child . setparent ( this ) ; }	adds a child to this composite at the end of the list .
public boolean open ( int maxrows ) { log . info ( _str + maxrows ) ; m_maxrows = maxrows ; if ( m_open ) { log . fine ( _str ) ; datarefreshall ( ) ; return _bool ; } if ( m_virtual ) { verifyvirtual ( ) ; } createselectsql ( ) ; if ( m_sql == null || m_sql . equals ( _str ) ) { log . log ( level . severe , _str ) ; return _bool ; } m_loader = new loader ( ) ; m_rowcount = m_loader . open ( maxrows ) ; if ( m_virtual ) { m_buffer = null ; m_virtualbuffer = new hashmap < integer , object [ ] > ( _num ) ; } else { m_buffer = new arraylist < object [ ] > ( m_rowcount + _num ) ; } m_sort = new arraylist < msort > ( m_rowcount + _num ) ; if ( m_rowcount > _num ) { if ( m_rowcount < _num ) m_loader . run ( ) ; else { m_loaderthread = new thread ( m_loader , _str ) ; m_loaderthread . start ( ) ; } } else m_loader . close ( ) ; m_open = _bool ; m_changed = _bool ; m_rowchanged = - _num ; m_inserting = _bool ; return _bool ; }	open database . if already opened , data is refreshed.
public void addmessagelistener ( imessagelistener listener ) { listeners . add ( listener ) ; }	add input stream message listener.
protected void syncflushvdcconfigtolocal ( ) throws exception { if ( vdcpropbarrier == null ) { vdcpropbarrier = new vdcpropertybarrier ( targetsiteinfo , vdc_op_barrier_timeout ) ; } vdcpropbarrier . enter ( ) ; try { flushvdcconfigtolocal ( ) ; } finally { boolean allleft = vdcpropbarrier . leave ( ) ; if ( ! allleft ) { log . info ( _str ) ; thread . sleep ( ipsec_restart_delay ) ; } } vdcpropbarrier = null ; }	simulaneously flush vdc config on all nodes in current site . via barrier.
public corruptindexexception ( string message , datainput input , throwable cause ) { this ( message , objects . tostring ( input ) , cause ) ; }	create exception with message and root cause .
protected void removefromquarantinequeue ( nodeporttuple npt ) { while ( quarantinequeue . remove ( npt ) ) ; }	remove a switch port from the quarantine queue .
public boolean hasexpired ( ) { if ( maxage == _num ) return _bool ; if ( maxage == max_age_unspecified ) return _bool ; long deltasecond = ( system . currenttimemillis ( ) - whencreated ) / _num ; if ( deltasecond > maxage ) return _bool ; else return _bool ; }	reports whether this http cookie has expired or not .
public static string repeatcharacter ( char c , int repetitions ) { stringbuilder s = new stringbuilder ( repetitions ) ; for ( int i = _num ; i < repetitions ; i ++ ) { s . append ( c ) ; } return s . tostring ( ) ; }	forms a string by repeating the character the given number of times .
public static string checkandreplaceliterals ( string inststr ) { string tmp = inststr ; if ( tmp . contains ( components_delim ) ) { tmp = tmp . replaceall ( components_delim , _str ) ; log . warn ( _str + components_delim + _str ) ; } if ( tmp . contains ( element_delim ) ) { tmp = tmp . replaceall ( element_delim , _str ) ; log . warn ( _str + element_delim + _str ) ; } if ( tmp . contains ( levelin ) ) { tmp = tmp . replaceall ( levelin , _str ) ; log . warn ( _str + levelin + _str ) ; } if ( tmp . contains ( levelout ) ) { tmp = tmp . replaceall ( levelout , _str ) ; log . warn ( _str + levelout + _str ) ; } if ( tmp . contains ( parfor_cdata_end ) ) { tmp = tmp . replaceall ( parfor_cdata_end , _str ) ; log . warn ( _str + parfor_cdata_end + _str ) ; } return tmp ; }	replacement of internal delimiters occurring in literals of instructions in order to ensure robustness of serialization and parsing.
public static < t > t withwriter ( writer writer , @ closureparams ( firstparam . class ) closure < t > closure ) throws ioexception { try { t result = closure . call ( writer ) ; try { writer . flush ( ) ; } catch ( ioexception e ) { } writer temp = writer ; writer = null ; temp . close ( ) ; return result ; } finally { closewithwarning ( writer ) ; } }	allows this writer to be used within the closure , ensuring that it is flushed and closed before this method returns .
public static int round ( double value ) { int roundedvalue = value > _num ? ( int ) ( value + _num ) : - ( int ) ( math . abs ( value ) + _num ) ; return roundedvalue ; }	rounds a double to the next nearest integer value.
private serviceregistrar [ ] buildserviceregistrar ( ) { int k = _num ; serviceregistrar [ ] proxys = new serviceregistrar [ discoveredlocators . size ( ) ] ; iterator iter = discoveredlocators . iterator ( ) ; while ( iter . hasnext ( ) ) { locatorreg reg = ( locatorreg ) iter . next ( ) ; proxys [ k ++ ] = reg . proxy ; } return proxys ; }	from each element of the set of locatorreg objects that correspond to lookup services that have been discovered , this method extracts the serviceregistrar reference and returns all of the references in an array of serviceregistrar .
public void rewindtows ( ) { if ( nextoffset == _num ) { return ; } nextoffset -- ; while ( nextoffset > _num && ! character . iswhitespace ( s . charat ( nextoffset ) ) ) { nextoffset -- ; } this . offset = nextoffset - _num ; }	sets next offset to the next preceeding ws - - this method must not be called during parsing of jsdoc , but only for completion hint !.
private static permission [ ] flatten ( permission [ ] pa ) { list l = new arraylist ( pa . length ) ; for ( int i = _num ; i < pa . length ; i ++ ) { permission p = pa [ i ] ; if ( p instanceof grantpermission ) { l . addall ( arrays . aslist ( ( ( grantpermission ) p ) . grants ) ) ; } else { l . add ( p ) ; } } return ( permission [ ] ) l . toarray ( new permission [ l . size ( ) ] ) ; }	returns an array containing all non - grantpermission permissions in the given permission array , including those contained in nested grantpermissions in the array .
protected void startdocumentinternal ( ) throws saxexception { if ( m_needtocallstartdocument ) { super . startdocumentinternal ( ) ; m_saxhandler . startdocument ( ) ; m_needtocallstartdocument = _bool ; } }	pass callback to the sax handler.
public static boolean isanonymous ( string classname ) { int i = classname . lastindexof ( _str ) ; if ( i >= _num && ++ i < classname . length ( ) ) { while ( i < classname . length ( ) ) { if ( ! character . isdigit ( classname . charat ( i ) ) ) { return _bool ; } i ++ ; } return _bool ; } return _bool ; }	does a class name appear to designate an anonymous class ? only the name is analyzed.
string descriptor ( boolean includethis ) { stringbuilder result = new stringbuilder ( ) ; result . append ( _str ) ; if ( includethis ) { result . append ( declaringtype . name ) ; } for ( typeid t : parameters . types ) { result . append ( t . name ) ; } result . append ( _str ) ; result . append ( returntype . name ) ; return result . tostring ( ) ; }	returns a descriptor like " ( ljava / lang / class ; [ i ) ljava / lang / object ; " .
public void testsinglefile ( ) throws exception { jflexmojo mojo = newmojo ( _str ) ; mojo . execute ( ) ; file produced = getexpectedoutputfile ( mojo ) ; asserttrue ( _str + produced , produced . isfile ( ) ) ; long size = produced . length ( ) ; boolean correctsize = ( size > _num ) && ( size < _num ) ; asserttrue ( _str + size , correctsize ) ; }	tests configuration with a single input file .
public final static boolean ispotentialziparchive ( string name ) { int lastdot = name . lastindexof ( _str ) ; if ( lastdot == - _num ) { return _bool ; } if ( name . lastindexof ( file . separatorchar ) > lastdot ) { return _bool ; } int length = name . length ( ) ; int extensionlength = length - lastdot - _num ; if ( extensionlength == extension_java . length ( ) ) { for ( int i = extensionlength - _num ; i >= _num ; i -- ) { if ( character . tolowercase ( name . charat ( length - extensionlength + i ) ) != extension_java . charat ( i ) ) { break ; } if ( i == _num ) { return _bool ; } } } if ( extensionlength == extension_class . length ( ) ) { for ( int i = extensionlength - _num ; i >= _num ; i -- ) { if ( character . tolowercase ( name . charat ( length - extensionlength + i ) ) != extension_class . charat ( i ) ) { return _bool ; } } return _bool ; } return _bool ; }	returns whether the given name is potentially a zip archive file name ( it has a file extension and it is not ".
void addterm ( mapbuildertermtype type , jclass jclass , string alias ) { mapbuilderterm newterm = new mapbuilderterm ( ) ; newterm . type = type ; newterm . jclass = jclass ; newterm . alias = alias ; terms . add ( newterm ) ; }	add a term to the map builder .
@ suppresswarnings ( _str ) protected void writepath ( shape s ) { pathiterator segments = s . getpathiterator ( null ) ; double [ ] coords = new double [ _num ] ; for ( int i = _num ; ! segments . isdone ( ) ; i ++ , segments . next ( ) ) { if ( i > _num ) { write ( _str ) ; } int segmenttype = segments . currentsegment ( coords ) ; switch ( segmenttype ) { case pathiterator . seg_moveto : write ( _str , coords [ _num ] , _str , coords [ _num ] ) ; break ; case pathiterator . seg_lineto : write ( _str , coords [ _num ] , _str , coords [ _num ] ) ; break ; case pathiterator . seg_cubicto : write ( _str , coords [ _num ] , _str , coords [ _num ] , _str , coords [ _num ] , _str , coords [ _num ] , _str , coords [ _num ] , _str , coords [ _num ] ) ; break ; case pathiterator . seg_quadto : write ( _str , coords [ _num ] , _str , coords [ _num ] , _str , coords [ _num ] , _str , coords [ _num ] ) ; break ; case pathiterator . seg_close : write ( _str ) ; break ; default : throw new illegalstateexception ( _str ) ; } } }	writes the beginning of the specified shape without any closing commands .
@ override public int portremote ( ) { if ( _channel != null ) { try { socketaddress addr = _channel . getremoteaddress ( ) ; return _num ; } catch ( exception e ) { e . printstacktrace ( ) ; return _num ; } } else return _num ; }	returns the remote client ' s port .
public void adddroptarget ( droptarget target ) { mdroptargets . add ( target ) ; }	add a droptarget to the list of potential places to receive drop events .
@ override public void startelement ( final string namespaceuri , final string localname , final string qname , final attributes atts ) throws saxexception { object objecttoload = null ; if ( opennodes . size ( ) == _num ) objecttoload = rootobject ; else objecttoload = createchild ( qname , atts ) ; if ( objecttoload != null ) { if ( atts . getindex ( _str ) < _num ) objectgetsetter . set ( objecttoload , _str , qname ) ; objectgetsetter . setall ( objecttoload , atts ) ; } opennodes . push ( new stackedobject ( objecttoload ) ) ; }	call back methods used by saxloader . startelement ( ) and endelement ( ).
public final int put ( object key , int value , boolean isreplace ) { int prime = _prime ; int hash = math . abs ( system . identityhashcode ( key ) % prime ) ; object [ ] keys = _keys ; while ( _bool ) { object testkey = keys [ hash ] ; if ( testkey == null ) { keys [ hash ] = key ; _values [ hash ] = value ; _size ++ ; if ( keys . length <= _num * _size ) resize ( _num * keys . length ) ; return value ; } else if ( key != testkey ) { hash = ( hash + _num ) % prime ; continue ; } else if ( isreplace ) { int old = _values [ hash ] ; _values [ hash ] = value ; return old ; } else { return _values [ hash ] ; } } }	puts a new value in the property table with the appropriate flags.
public int addallabsent ( collection c ) { int numnew = c . size ( ) ; if ( numnew == _num ) return _num ; synchronized ( this ) { object [ ] elements = getarray ( ) ; int len = elements . length ; object [ ] temp = new object [ numnew ] ; int added = _num ; for ( iterator itr = c . iterator ( ) ; itr . hasnext ( ) ; ) { object e = itr . next ( ) ; if ( indexof ( e , elements , _num , len ) < _num && indexof ( e , temp , _num , added ) < _num ) temp [ added ++ ] = e ; } if ( added != _num ) { object [ ] newelements = new object [ len + added ] ; system . arraycopy ( elements , _num , newelements , _num , len ) ; system . arraycopy ( temp , _num , newelements , len , added ) ; setarray ( newelements ) ; } return added ; } }	appends all of the elements in the specified collection that are not already contained in this list , to the end of this list , in the order that they are returned by the specified collection ' s iterator .
protected static void registerlibrary ( ilibrarymanager externallibrarymanager , string dataverse , string libraryname ) throws exception { classloader classloader = getlibraryclassloader ( dataverse , libraryname ) ; externallibrarymanager . registerlibraryclassloader ( dataverse , libraryname , classloader ) ; }	register the library class loader with the external library manager.
public void autosize ( ) { if ( ! autoresize ) return ; }	size columns . uses mimimum column size.
public void testcase9 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = _num ; byte rbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = biginteger . one ; biginteger result = anumber . multiply ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	multiply a positive number by one .
public static string rawmd5 ( string s ) { return binl2rstr ( binl2md5 ( rstr2binl ( s ) , s . length ( ) * _num ) ) ; }	calculate the md5 of a raw string.
public boolean isquestcompleted ( final string name ) { final string info = getquest ( name , _num ) ; if ( info == null ) { return _bool ; } return info . equals ( _str ) ; }	checks whether the player has completed the given quest or not .
@ layoutlibdelegate static float ceil ( float value ) { return ( float ) math . ceil ( value ) ; }	returns the float conversion of the most negative ( i.
private final user removeuser ( string channel , string nick ) { channel = channel . tolowercase ( ) ; user user = new user ( _str , nick ) ; synchronized ( _channels ) { hashtable < user , user > users = _channels . get ( channel ) ; if ( users != null ) { return users . remove ( user ) ; } } return null ; }	remove a user from the specified channel in our memory .
public static void translatepos ( collection < graphnode > movenodes , map < graphnode , point2d > positions , translater intoregion ) { for ( graphnode node : movenodes ) { point2d location = translatenode ( node , positions , intoregion ) ; if ( null == location ) { continue ; } positions . put ( node , location ) ; } }	update positions of movenodes using the supplied translator.
public void ifpresentorelse ( longconsumer action , runnable emptyaction ) { if ( ispresent ) { action . accept ( value ) ; } else { emptyaction . run ( ) ; } }	if a value is present , performs the given action with the value , otherwise performs the given empty - based action .
public void testtobigintegerpos2 ( ) { string a = _str ; biginteger bnumber = new biginteger ( _str ) ; bigdecimal anumber = new bigdecimal ( a ) ; biginteger result = anumber . tobiginteger ( ) ; asserttrue ( _str , result . equals ( bnumber ) ) ; }	convert a positive bigdecimal to biginteger.
private string cleanuppath ( string filename ) { if ( filename == null ) { return null ; } filename = filename . replace ( _str , _str ) ; filename = filename . replace ( _str , _str ) ; if ( filename . startswith ( _str ) ) { return filename ; } if ( filename . startswith ( _str ) ) { return _str + filename ; } return _str + filename ; }	clean up the path so that is looks like " . / usr / local / file ".
public static class < ? > invocationhandlerreturntype ( class < ? > type ) { if ( type == byte . class ) return byte . class ; if ( type == char . class ) return character . class ; if ( type == double . class ) return double . class ; if ( type == float . class ) return float . class ; if ( type == int . class ) return integer . class ; if ( type == long . class ) return long . class ; if ( type == short . class ) return short . class ; if ( type == boolean . class ) return boolean . class ; return type ; }	returns the type that must be returned by the invocation handler of a dynamic proxy in order to have the dynamic proxy return the specified type ( which is assumed to be a legal member type for an annotation ) .
private static script scriptfromstring ( string scriptstring , scripttype scripttype ) { return new script ( scriptstring , scripttype ) ; }	create a dml or pydml script object based on a string .
private void finishnestedmode ( ) throws saxexception { md = ( modedata ) modedatastack . pop ( ) ; }	notification that the mode element ends .
public void addpropertychangelistener ( final propertychangelistener listener ) { propertychangesupport . addpropertychangelistener ( listener ) ; }	add the specified property change listener .
protected int skipwhitespace ( int c ) throws ioexception { while ( c == _str || c == _str ) { c = reader . read ( ) ; } return c ; }	reads characters from reader until it finds a character that is not a space or tab , and returns this last character.
public builder nocache ( ) { this . nocache = _bool ; return this ; }	don ' t accept an unvalidated cached response .
@ suppresswarnings ( _str ) public void computeclosestpoints ( ) { float centerx = contentrect . centerx ( ) ; float closestdistance = float . max_value ; for ( int i = _num ; i < pointscountwithinxrange * _num ; i += _num ) { float x = getdrawx ( xrangepoints [ i ] ) ; float distance = math . abs ( x - centerx ) ; if ( distance <= closestdistance ) { if ( distance == closestdistance ) { closestpointscount ++ ; } else { closestpointscount = _num ; } closestdistance = distance ; if ( closestpointsbuffer . length < ( closestpointscount * _num + _num ) ) { closestpointsbuffer = new float [ closestpointsbuffer . length * _num ] ; } closestpointsbuffer [ closestpointscount * _num + _num ] = xrangepoints [ i ] ; closestpointsbuffer [ closestpointscount * _num + _num ] = xrangepoints [ i + _num ] ; } } if ( pointscountwithinxrange > _num ) { closestpointscount ++ ; } }	compute closest to central line points . several points will be written to array only if they have same x values.
protected transformedstring stem ( string words ) { stringbuilder builder = new stringbuilder ( ) ; map < integer , integer > indexmap = new hashmap < > ( ) ; integer index = _num ; string content = words . tolowercase ( ) ; while ( ! content . isempty ( ) ) { indexmap . put ( builder . length ( ) , index ) ; if ( character . isalphabetic ( content . charat ( _num ) ) ) { matcher m = word_pattern . matcher ( content ) ; m . find ( ) ; string match = m . group ( ) ; charsequence stemmedmatch = stemmer . stem ( match ) ; builder . append ( stemmedmatch ) ; index += match . length ( ) ; content = content . substring ( match . length ( ) ) ; } else { builder . append ( content . substring ( _num , _num ) ) ; content = content . substring ( _num ) ; index ++ ; } } indexmap . put ( builder . length ( ) , index ) ; return new transformedstring ( words , builder . tostring ( ) , indexmap ) ; }	convert a word , or words , into their stemmed form and return it along with a mapping between the original and transformed strings.
void clear ( ) { valuenumbersunconditionallydereferenced . clear ( ) ; dereflocationsetmap . clear ( ) ; }	clear the deref set.
public string [ ] list ( ) throws remoteexception { string [ ] names ; synchronized ( bindings ) { int i = bindings . size ( ) ; names = new string [ i ] ; enumeration < string > enum_ = bindings . keys ( ) ; while ( ( -- i ) >= _num ) names [ i ] = enum_ . nextelement ( ) ; } return names ; }	returns an enumeration of the names in the registry .
public static void assertqex ( string message , solrqueryrequest req , int code ) { try { ignoreexception ( _str ) ; h . query ( req ) ; fail ( message ) ; } catch ( solrexception sex ) { assertequals ( code , sex . code ( ) ) ; } catch ( exception e2 ) { throw new runtimeexception ( _str , e2 ) ; } finally { unignoreexception ( _str ) ; } }	makes sure a query throws a solrexception with the listed response code.
public static void copyfile ( string fromfile , string tofile ) throws ioexception { copyfile ( new file ( fromfile ) , new file ( tofile ) ) ; }	helper method to copy file to a new location.
@ edu . umd . cs . findbugs . annotations . suppressfbwarnings ( value = _str , justification = _str ) public void changelocospeed ( dccthrottle t , section sec , float speed ) { if ( sec == referenced && speed == desiredspeedstep ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str ) ; } return ; } float sectionlength = sec . getactuallength ( ) ; if ( log . isdebugenabled ( ) ) { log . debug ( _str + sec . getdisplayname ( ) ) ; } if ( sec == referenced ) { distanceremaining = distanceremaining - getdistancetravelled ( _throttle . getisforward ( ) , _throttle . getspeedsetting ( ) , ( ( float ) ( system . nanotime ( ) - lasttimetimerstarted ) / _num ) ) ; sectionlength = distanceremaining ; } else { referenced = sec ; } changelocospeed ( t , sectionlength , speed ) ; }	set speed of a throttle to a speeed set by a float , using the section for the length details.
private void drawoffsets ( final graphics g ) { final int linestodraw = getnumberofvisiblerows ( ) ; final string formatstring = m_addressmode == addressmode . bit32 ? _str : _str ; final long elementsize = getelementsize ( ) ; final long baseaddress = m_model . getstartaddress ( ) == - _num ? _num : m_model . getstartaddress ( ) ; for ( int i = _num ; i < linestodraw ; i ++ ) { final int elementindex = m_firstrow + i ; final long elementaddress = baseaddress + ( elementindex * elementsize ) ; final string offsetstring = string . format ( formatstring , elementaddress ) ; if ( elementaddress == m_model . getstackpointer ( ) ) { highlightstackpointer ( g , i ) ; } if ( isenabled ( ) ) { g . setcolor ( m_fontcoloroffsets ) ; } else { g . setcolor ( m_disabledcolor != m_bgcoloroffset ? m_disabledcolor : color . white ) ; } g . drawstring ( offsetstring , padding_left - ( m_charwidth * m_firstcolumn ) , m_paddingtop + ( i * m_rowheight ) ) ; } }	draws the offsets in the offset view .
public static boolean prefixedwith ( string a , string b ) { if ( a . equals ( b ) ) { return _bool ; } return a . startswith ( b ) ; }	return true of both a and b are non - null , and b is a prefix ( but not equal to ) a .
public static string readstream ( inputstream inputstream ) throws ioexception { if ( inputstream == null ) { return null ; } bytearrayoutputstream bout = new bytearrayoutputstream ( ) ; byte [ ] buf = new byte [ _num ] ; int r ; while ( ( r = inputstream . read ( buf ) ) != - _num ) { bout . write ( buf , _num , r ) ; } return bout . tostring ( _str ) ; }	reads bytes from input stream and builds a string from them .
private instances makeheader ( ) { arraylist < attribute > fv = new arraylist < attribute > ( ) ; fv . add ( new attribute ( _str ) ) ; fv . add ( new attribute ( _str ) ) ; fv . add ( new attribute ( _str ) ) ; return new instances ( _str , fv , _num ) ; }	creates an instances object with the attributes we will be calculating .
private static icloseableiterator < ibindingset > iterator ( final irunningquery runningquery ) { final icloseableiterator < ibindingset [ ] > it1 = runningquery . iterator ( ) ; final icloseableiterator < ibindingset > it2 = new dechunkerator < ibindingset > ( it1 ) ; final icloseableiterator < ibindingset > it3 = new runningquerycloseableiterator < ibindingset > ( runningquery , it2 ) ; return it3 ; }	dechunkify the running query and monitor the sesame iterator .
public final double dooperation ( ) throws operatorfailedexception { final int dim = parameter . getdimension ( ) ; final int dim1 = mathutils . nextint ( dim ) ; int dim2 = dim1 ; while ( dim1 == dim2 ) { dim2 = mathutils . nextint ( dim ) ; } double scalar1 = parameter . getparametervalue ( dim1 ) ; double scalar2 = parameter . getparametervalue ( dim2 ) ; final double d = mathutils . nextdouble ( ) * delta * scalar1 ; scalar1 -= d ; if ( parameterweights [ dim1 ] != parameterweights [ dim2 ] ) { scalar2 += d * ( double ) parameterweights [ dim1 ] / ( double ) parameterweights [ dim2 ] ; } else { scalar2 += d ; } parameter . setparametervalue ( dim1 , scalar1 ) ; parameter . setparametervalue ( dim2 , scalar2 ) ; return math . log ( scalar2 / ( scalar1 + d ) ) ; }	change the parameter and return the hastings ratio.
@ override public final boolean isopen ( ) { return isopen . get ( ) ; }	returns true if this selector is open .
private static streamtokenizer createtokenizer ( string s ) { streamtokenizer st = new streamtokenizer ( new stringreader ( s ) ) ; st . resetsyntax ( ) ; st . wordchars ( _str , _str ) ; st . wordchars ( _str , _str ) ; st . wordchars ( _str , _str ) ; st . wordchars ( _str , _str ) ; st . wordchars ( _str , _str ) ; st . wordchars ( _str , _str ) ; st . wordchars ( _num + _num , _num ) ; st . whitespacechars ( _num , _str ) ; st . lowercasemode ( _bool ) ; st . ordinarychar ( _str ) ; st . slashslashcomments ( _bool ) ; st . slashstarcomments ( _bool ) ; return st ; }	returns tokenizer for parsing given string.
public static string removechars ( string str , string oldchars ) { int pos = indexofchars ( str , oldchars ) ; if ( pos == - _num ) { return str ; } stringbuilder buf = new stringbuilder ( ) ; int start = _num ; do { buf . append ( str . substring ( start , pos ) ) ; start = pos + _num ; pos = indexofchars ( str , oldchars , start ) ; } while ( pos != - _num ) ; if ( start < str . length ( ) ) { buf . append ( str . substring ( start ) ) ; } return buf . tostring ( ) ; }	remove any occurrances of ' oldchars ' in ' str ' . example : removechars ( " hello , world ! " , " , ! " ) returns " hello world ".
private void sortunitstomove ( final list < unit > units , final route route ) { if ( units == null || units . isempty ( ) ) { return ; } else if ( route == null ) { final exception nullrouteerror = ( new illegalargumentexception ( _str ) ) ; clientlogger . logquietly ( _str , nullrouteerror ) ; } final comparator < unit > unitcomparator ; if ( route . isunload ( ) && match . somematch ( units , matches . unitisland ) ) { unitcomparator = unitcomparator . getunloadableunitscomparator ( units , route , getunitowner ( units ) ) ; } else { unitcomparator = unitcomparator . getmovableunitscomparator ( units , route ) ; } collections . sort ( units , unitcomparator ) ; }	sort the specified units in preferred movement or unload order .
public road ( int id , string name , intersection from , intersection to , roadclass roadclass , roadlayer roadlayer ) { this . id = id ; this . name = name ; this . roadlayer = roadlayer ; points = new waypoint [ _num ] ; setintersections ( from , to ) ; this . roadclass = roadclass ; createlines ( ) ; modified = _bool ; }	create a road between two intersections.
@ override public void process ( watchedevent event ) { keeperstate eventstate = event . getstate ( ) ; eventtype eventtype = event . gettype ( ) ; log . info ( _str , eventstate , eventtype ) ; if ( eventstate == keeperstate . syncconnected ) { connectedsignal . countdown ( ) ; log . info ( _str , connectionstring ) ; } }	interface method , do things after receiving event from server watcher.
private void initproperties ( string filepropertiesname ) { readfromclasspath ( filepropertiesname ) ; path curdirpath = getfileincurrentdir ( filepropertiesname ) ; if ( files . exists ( curdirpath ) ) { try ( inputstream curfolder = files . newinputstream ( curdirpath ) ) { if ( curfolder != null ) { load ( curfolder ) ; } } catch ( exception e ) { throw new runtimeexception ( _str + filepropertiesname , e ) ; } } }	first loads properties file from class path after that from current folder.
private void resetbounds ( ) { bottomproteinid = null ; topproteinid = null ; }	helper method that sets the upper and lower bounds to null .
private string property ( string classid , string key , string instanceid ) { return prefix_ovf_prop + makepropertykey ( classid , key , instanceid ) ; }	produces a string usable as key in customproperties.
public string list ( string dir ) throws ioexception { passive ( ) ; send ( _str + dir ) ; readcode ( _num ) ; bytearrayoutputstream out = new bytearrayoutputstream ( ) ; ioutils . copyandclose ( indata , out ) ; readcode ( _num ) ; byte [ ] data = out . tobytearray ( ) ; return new string ( data ) ; }	get the directory listing ( list ) .
public static int convertpxtosp ( int pxsize ) { return math . round ( ( float ) pxsize * getdisplaydensity4fonts ( ) ) ; }	convert absolute pixels to scale dependent pixels . this scales the size by scale dependent screen density ( accessibility setting ) and the global display setting for message composition fields.
private void persistconsistencygroups ( collection < blockconsistencygroup > cgstopersist ) { if ( null != cgstopersist && ! cgstopersist . isempty ( ) ) { list < blockconsistencygroup > cgstocreate = new arraylist < blockconsistencygroup > ( ) ; list < blockconsistencygroup > cgstoupdate = new arraylist < blockconsistencygroup > ( ) ; for ( blockconsistencygroup cg : cgstopersist ) { if ( null == cg . getcreationtime ( ) ) { cgstocreate . add ( cg ) ; } else { cgstoupdate . add ( cg ) ; } } if ( ! cgstocreate . isempty ( ) ) { _dbclient . createobject ( cgstocreate ) ; } if ( ! cgstoupdate . isempty ( ) ) { _dbclient . updateobject ( cgstoupdate ) ; } } }	persist the consistencygroups in db .
public void requestpasswordchangedtime ( ) { operations . add ( passwordpolicystateoperationtype . get_password_changed_time ) ; }	returns the password changed time .
public static byte [ ] encoderegionname ( string regionname ) { byte [ ] metadata ; try { jsonobject jsonobject = new jsonobject ( ) ; jsonobject . put ( json_field_tag , regionname ) ; string json = jsonobject . tostring ( ) ; metadata = json . getbytes ( json_charset ) ; } catch ( exception e ) { log . e ( tag , _str + e . getmessage ( ) ) ; metadata = null ; } return metadata ; }	build the metadata array byte.
public boolean isvalid ( ) { boolean valid = _bool ; if ( endtime . gettime ( ) < system . currenttimemillis ( ) ) { valid = _bool ; } else if ( starttime != null ) { if ( starttime . gettime ( ) > system . currenttimemillis ( ) ) { valid = _bool ; } } else { if ( authtime . gettime ( ) > system . currenttimemillis ( ) ) { valid = _bool ; } } return valid ; }	checks if this credential is expired.
public void testgetelementsbytagnamens1 ( ) throws throwable { document doc ; document newdoc ; documenttype doctype = null ; domimplementation domimpl ; nodelist childlist ; string nullns = null ; doc = ( document ) load ( _str , builder ) ; domimpl = doc . getimplementation ( ) ; newdoc = domimpl . createdocument ( nullns , _str , doctype ) ; childlist = newdoc . getelementsbytagnamens ( _str , _str ) ; assertequals ( _str , _num , childlist . getlength ( ) ) ; }	runs the test case .
public static boolean addseparatorifneeded ( jpopupmenu popupmenu ) { final int menucomponentcount = popupmenu . getcomponentcount ( ) ; if ( menucomponentcount == _num ) { return _bool ; } final component lastmenucomponent = popupmenu . getcomponent ( menucomponentcount - _num ) ; if ( ispopupmenuseparator ( lastmenucomponent ) ) { return _bool ; } popupmenu . addseparator ( ) ; return _bool ; }	appends a separator to the end of the menu if it exists at least one non separator menu component immediately before and if there isn ' t , already , a separator at the end of the menu .
public int groupsize ( string grpname ) { int res = _num ; for ( hadoopcounter counter : cntrs . values ( ) ) { if ( grpname . equals ( counter . group ( ) ) ) res ++ ; } return res ; }	returns size of a group .
public resourcebundleenumeration ( set < string > set , enumeration < string > enumeration ) { this . set = set ; this . iterator = set . iterator ( ) ; this . enumeration = enumeration ; }	constructs a resource bundle enumeration .
public static int torgb ( colorspace colorspace , float ... components ) { float [ ] rgb = colorspace . torgb ( components ) ; if ( rgb [ _num ] < _num || rgb [ _num ] < _num || rgb [ _num ] < _num || rgb [ _num ] > _num || rgb [ _num ] > _num || rgb [ _num ] > _num ) { return _num ; } return _num | ( ( int ) ( rgb [ _num ] * _num ) << _num ) | ( ( int ) ( rgb [ _num ] * _num ) << _num ) | ( int ) ( rgb [ _num ] * _num ) ; }	returns an rgb value from color components in the specified color space .
private static void skipnames ( bytebuffer tablebuffer , int count ) { for ( int i = _num ; i < count ; ++ i ) { byteutil . forward ( tablebuffer , tablebuffer . getshort ( ) ) ; } }	skips the given number of names in the table buffer .
private logsource ( ) { }	don ' t allow others to create instances.
public object2intopenhashmap < int [ ] > supportmap ( ) { list < itemset > itemsets = learn ( ) ; object2intopenhashmap < int [ ] > confidencemap = new object2intopenhashmap < > ( itemsets . size ( ) ) ; for ( itemset itemset : itemsets ) { confidencemap . put ( itemset . items , itemset . support ) ; } return confidencemap ; }	returns a map of discovered itemsets and their support , where the support is the number of times the combination appears in the input data.
public static list < string > makefeatureidlistfromprefixed ( map < string , object > parameters ) { list < string > featureidlist = fastlist . newinstance ( ) ; if ( parameters == null ) return featureidlist ; for ( map . entry < string , object > entry : parameters . entryset ( ) ) { string parametername = entry . getkey ( ) ; if ( parametername . startswith ( _str ) ) { string productfeatureid = ( string ) entry . getvalue ( ) ; if ( utilvalidate . isnotempty ( productfeatureid ) ) { featureidlist . add ( productfeatureid ) ; } } } return featureidlist ; }	handles parameters coming in prefixed with " search_feat " where the parameter value is a productfeatureid ; meant to be used with text entry boxes or check - boxes and such.
private void updateoverscrollanimation ( final int scrolledoffset ) { if ( medgeglowleft == null || medgeglowright == null ) return ; int nextscrollposition = mcurrentx + scrolledoffset ; if ( mflingtracker == null || mflingtracker . isfinished ( ) ) { if ( nextscrollposition < _num ) { int overscroll = math . abs ( scrolledoffset ) ; medgeglowleft . onpull ( ( float ) overscroll / getrenderwidth ( ) ) ; if ( ! medgeglowright . isfinished ( ) ) { medgeglowright . onrelease ( ) ; } } else if ( nextscrollposition > mmaxx ) { int overscroll = math . abs ( scrolledoffset ) ; medgeglowright . onpull ( ( float ) overscroll / getrenderwidth ( ) ) ; if ( ! medgeglowleft . isfinished ( ) ) { medgeglowleft . onrelease ( ) ; } } } }	updates the over scroll animation based on the scrolled offset .
public void validate ( ) { final list < validationexception > exceptionlist = new arraylist < validationexception > ( ) ; validate ( exceptionlist ) ; if ( ! exceptionlist . isempty ( ) ) throw exceptionlist . get ( _num ) ; }	validates this sootclass for logical errors.
protected void installcomponents ( ) { if ( ( rendererpane = createcellrendererpane ( ) ) != null ) { tree . add ( rendererpane ) ; } }	intalls the subcomponents of the tree , which is the renderer pane .
public cactiondifferencetraces ( final jframe parent , final itracelistprovider traceprovider , final tracelist trace1 , final tracelist trace2 ) { super ( string . format ( _str , trace1 . getname ( ) , trace2 . getname ( ) ) ) ; m_parent = parent ; m_traceprovider = traceprovider ; m_trace1 = trace1 ; m_trace2 = trace2 ; }	creates a new action object .
public static void copyfile ( file fromfile , file tofile ) throws ioexception { fileinputstream fileinputstream = new fileinputstream ( fromfile ) ; fileoutputstream fileoutputstream = new fileoutputstream ( tofile ) ; int i ; byte bytes [ ] = new byte [ _num ] ; while ( ( i = fileinputstream . read ( bytes ) ) != - _num ) { fileoutputstream . write ( bytes , _num , i ) ; } fileinputstream . close ( ) ; fileoutputstream . close ( ) ; }	helper method to copy file to a new location.
public final void updatetimecontroltitle ( ) { int [ ] tmpinfo = ctrl . gettimelimit ( ) ; stringbuilder sb = new stringbuilder ( ) ; int tc = tmpinfo [ _num ] ; int mps = tmpinfo [ _num ] ; int inc = tmpinfo [ _num ] ; if ( mps > _num ) { sb . append ( mps ) ; sb . append ( _str ) ; } sb . append ( timetostring ( tc ) ) ; if ( ( inc > _num ) || ( mps <= _num ) ) { sb . append ( _str ) ; sb . append ( tmpinfo [ _num ] / _num ) ; } summarytitletext . settext ( sb . tostring ( ) ) ; }	update center field in second header line .
@ after public void after ( ) throws sqlexception { connection connection = null ; statement statement = null ; try { connection = getnewconnection ( _bool ) ; statement = connection . createstatement ( ) ; statement . executequery ( _str ) ; } finally { if ( statement != null ) { statement . close ( ) ; } if ( connection != null ) { connection . close ( ) ; } } }	takes down the table created solely for these tests .
@ action ( value = _str ) public string listworkflow ( ) { if ( wfaction != null && wfaction . equals ( collectionconstants . wf_action_approve ) ) fetchreceipts ( collectionconstants . wf_action_approve ) ; else fetchreceipts ( collectionconstants . wf_action_submit ) ; return index ; }	action that will be called from the workflow inbox . the inbox also passes the id of the clicked item which is of the form : < next - workflow - action > - servicecode - userid - counterid.
public static final list < geo > polynearpoly ( geoarray s , geoarray r , double near ) { int rlen = r . getsize ( ) ; int slen = s . getsize ( ) ; geo pl0 = r . get ( rlen - _num ) ; geo pl1 = new geo ( ) ; geo sl0 = s . get ( slen - _num ) ; geo sl1 = new geo ( ) ; list < geo > list = null ; for ( int j = _num ; j < rlen ; j ++ ) { pl1 = r . get ( j , pl1 ) ; for ( int i = _num ; i < slen ; i ++ ) { sl1 = s . get ( i , sl1 ) ; geo ret = segmentsintersectornear ( sl0 , sl1 , pl0 , pl1 , near ) ; if ( ret != null ) { if ( list == null ) { list = new linkedlist < geo > ( ) ; } list . add ( ret ) ; } sl0 = sl1 ; } pl0 = pl1 ; } return list ; }	is one region ' s boundary within ' near ' range of a region ? note : good practice is s describes a smaller area than r .
public void initparam ( object obj ) { paramobject = obj ; enumeration < abstractparampanel > en = tablepanel . elements ( ) ; abstractparampanel panel = null ; while ( en . hasmoreelements ( ) ) { panel = en . nextelement ( ) ; panel . initparam ( obj ) ; } }	initialises all panels with the given object .
public void updatetopic ( string topic , dbcontextrule rule ) { topic = stringutils . tolowerenglish ( topic ) ; rulehead head = rulemap . get ( topic ) ; if ( head == null ) { head = new rulehead ( _str , topic , rule ) ; rulemap . put ( topic , head ) ; statements . add ( head ) ; } else { head . setrule ( rule ) ; } }	update a topic with a context specific rule.
public static double log10 ( double x ) { return math . log ( x ) / log10 ; }	the base 10 logarithm of the input value.
public static int isbuttononscreen ( final string buttonkey ) { component onscreen ; try { onscreen = bubblewindow . findbutton ( buttonkey , rapidminergui . getmainframe ( ) ) ; } catch ( nullpointerexception e ) { return object_not_on_screen ; } if ( onscreen == null ) { return object_not_on_screen ; } int xposition = onscreen . getlocationonscreen ( ) . x ; int yposition = onscreen . getlocationonscreen ( ) . y ; int otherxposition = xposition + onscreen . getwidth ( ) ; int otheryposition = yposition + onscreen . getheight ( ) ; window frame = rapidminergui . getmainframe ( ) ; if ( otherxposition <= frame . getwidth ( ) && otheryposition <= frame . getheight ( ) && xposition > _num && yposition > _num ) { return object_showing_on_screen ; } else { return object_not_showing ; } }	method to get to know whether the abstractbutton with the given key is on screen.
public static boolean reachable ( inetaddress addr , int reachtimeout ) { try { return addr . isreachable ( reachtimeout ) ; } catch ( ioexception ignore ) { return _bool ; } }	checks if address can be reached using one argument inetaddress.
protected static string timestr ( long time_val , long total_time ) { boolean neg ; long ms = _num ; long sec = _num ; long percent10 ; string pad ; neg = time_val < _num ; if ( neg ) time_val = - time_val ; ms = time_val % _num ; sec = time_val / _num ; if ( sec < _num ) pad = _str ; else if ( sec < _num ) pad = _str ; else if ( sec < _num ) pad = _str ; else pad = _str ; percent10 = ( time_val * _num ) / total_time ; return ( neg ? _str : _str ) + pad + sec + _str + ( ( ms % _num ) / _num ) + ( ( ms % _num ) / _num ) + ( ms % _num ) + _str + _str + percent10 / _num + _str + percent10 % _num + _str ; }	helper routine to format a decimal based display of seconds and percentage of total time given counts of milliseconds.
public static tree rotatebyname ( tree tree ) { return new simpletree ( rotatenodebyname ( tree , tree . getroot ( ) ) ) ; }	recursive function for constructing a newick tree representation in the given buffer .
@ subscribe public void onevent ( searchinposition event ) { list < latlng > list = maphelper . getsearcharea ( event . getsteps ( ) , new latlng ( event . getposition ( ) . latitude , event . getposition ( ) . longitude ) ) ; snackme ( getstring ( r . string . toast_searching ) ) ; nianticmanager . getgyms ( event . getposition ( ) . latitude , event . getposition ( ) . longitude , _num ) ; nianticmanager . getpokestops ( event . getposition ( ) . latitude , event . getposition ( ) . longitude , _num ) ; nianticmanager . getluredpokemon ( event . getposition ( ) . latitude , event . getposition ( ) . longitude , _num ) ; for ( latlng p : list ) { nianticmanager . getcatchablepokemon ( p . latitude , p . longitude , _num ) ; } }	called whenever a use whats to search pokemons on a different position.
public void save ( onsaveloglistener listener ) { file dir = getlogdir ( ) ; if ( dir == null ) { listener . onerror ( _str + _str ) ; return ; } filewriter filewriter = null ; try { file output = new file ( dir , getlogfilename ( ) ) ; filewriter = new filewriter ( output , _bool ) ; list < logentry > entries = bufferedlogs ( ) ; for ( logentry entry : entries ) { filewriter . write ( entry . prettyprint ( ) + _str ) ; } listener . onsave ( output ) ; } catch ( ioexception e ) { listener . onerror ( e . getmessage ( ) ) ; e . printstacktrace ( ) ; } finally { if ( filewriter != null ) { try { filewriter . close ( ) ; } catch ( ioexception e ) { listener . onerror ( e . getmessage ( ) ) ; e . printstacktrace ( ) ; } } } }	save the current logs to disk .
protected storagehadomain checkadapterexistsindb ( string nativeguid ) throws ioexception { storagehadomain adapter = null ; list < storagehadomain > adapterindb = customqueryutility . getactivestoragehadomainbynativeguid ( _dbclient , nativeguid ) ; if ( adapterindb != null && ! adapterindb . isempty ( ) ) { adapter = adapterindb . get ( _num ) ; } return adapter ; }	check if adapter exists in db .
protected coordinate [ ] tocoordinatearray ( stack stack ) { coordinate [ ] coordinates = new coordinate [ stack . size ( ) ] ; for ( int i = _num ; i < stack . size ( ) ; i ++ ) { coordinate coordinate = ( coordinate ) stack . get ( i ) ; coordinates [ i ] = coordinate ; } return coordinates ; }	an alternative to stack.
private void prepareuserforranking ( user user ) { user updateduser = userrepository . findone ( user . getid ( ) , _num ) ; if ( updateduser . getimported ( ) == null || ! updateduser . getimported ( ) ) { updateduser . setimported ( _bool ) ; updateduser . setpagerank ( null ) ; updateduser . setlastpagerank ( null ) ; updateduser . setcurrentrank ( null ) ; updateduser . setpreviousrank ( null ) ; userrepository . save ( updateduser , _num ) ; } }	prepares a user to be ranked for the first time after having follower data imported , resetting the previous pageranks and preparing for a new calculation and ranking .
private static list < comment > ordercomments ( list < comment > comments ) { map < string , list < comment > > parentmap = new hashmap < > ( ) ; list < comment > rootcomments = new arraylist < > ( ) ; for ( comment c : comments ) { string parentuuid = c . parentuuid ; list < comment > l = parentmap . get ( parentuuid ) ; if ( l == null ) { l = new arraylist < > ( ) ; parentmap . put ( parentuuid , l ) ; } l . add ( c ) ; if ( parentuuid == null ) { rootcomments . add ( c ) ; } } list < comment > result = new arraylist < > ( ) ; addchildren ( parentmap , rootcomments , result ) ; return result ; }	order the comments based on their parent_uuid parent.
protected static final void lograwdiagnostic ( string msg ) { if ( diagnosticsstream != null ) { diagnosticsstream . println ( msg ) ; diagnosticsstream . flush ( ) ; } }	write the specified message to the internal logging destination .
public void initialize ( subject subject , callbackhandler callbackhandler , map < string , ? > sharedstate , map < string , ? > options ) { unauthenticatedidentity = ( string ) options . get ( _str ) ; handler = callbackhandler ; this . subject = subject ; }	initialize the login module , get options from configuration.
public boolean contains ( symbol sym ) { return _all . containskey ( sym . name ( ) ) ; }	determine if the set contains a particular symbol .
private piedata generatedatapie ( int cnt ) { arraylist < entry > entries = new arraylist < entry > ( ) ; for ( int i = _num ; i < _num ; i ++ ) { entries . add ( new entry ( ( int ) ( math . random ( ) * _num ) + _num , i ) ) ; } piedataset d = new piedataset ( entries , _str ) ; d . setslicespace ( _num ) ; d . setcolors ( colortemplate . vordiplom_colors ) ; piedata cd = new piedata ( getquarters ( ) , d ) ; return cd ; }	generates a random chartdata object with just one dataset.
public void senduserdeletenotification ( map attributes ) { try { if ( deletenotifylist != null && ! deletenotifylist . isempty ( ) ) { sendemail ( deletenotifylist , attributes , _str , _str , _str ) ; } } catch ( messagingexception e ) { if ( debug . warningenabled ( ) ) { debug . warning ( _str + _str + _str + entrydn , e ) ; } } }	the proper setuser < > notificationlist method should be called before calling this method .
public void addmapsidmapping ( databasemapping mapping ) { mapsidmappings . add ( mapping ) ; }	internal : in jpa users may specify a maps id mapping on a shared embeddable descriptor.
public int tasksize ( ) { return tasks . size ( ) ; }	number of tasks in this item .
public void addmutedip ( final string ip , final date mutetill ) { if ( isipmuted ( ip ) ) { removemutedip ( ip ) ; } timestamp mutetillts = null ; if ( mutetill != null ) { mutetillts = new timestamp ( mutetill . gettime ( ) ) ; } s_logger . fine ( _str + ip ) ; final connection con = database . getconnection ( ) ; try { final preparedstatement ps = con . preparestatement ( _str ) ; ps . setstring ( _num , ip ) ; ps . settimestamp ( _num , mutetillts ) ; ps . execute ( ) ; ps . close ( ) ; con . commit ( ) ; } catch ( final sqlexception sqle ) { if ( sqle . geterrorcode ( ) == _num ) { s_logger . info ( _str + ip + _str + sqle . getmessage ( ) ) ; return ; } s_logger . log ( level . severe , _str + ip , sqle ) ; throw new illegalstateexception ( sqle . getmessage ( ) ) ; } finally { dbutil . closeconnection ( con ) ; } }	mute the given ip.
public boolean isrslurlsigned ( string url ) { if ( url == null ) { return _bool ; } return url . endswith ( signed_rsl_url_dot_extension ) ; }	test is the url is signed .
public void removeuserlockoutentry ( string userdn ) { pwresetfailhash . remove ( userdn ) ; userwarningcount = _num ; }	removes the user dn from the fail map entry .
public void createdatabaseentitiesforbusinessobjectdatasearchtesting ( ) { businessobjectdatadaotesthelper . createbusinessobjectdataentity ( abstractservicetest . namespace , abstractservicetest . bdef_name , abstractservicetest . format_usage_code , abstractservicetest . format_file_type_code , abstractservicetest . format_version , abstractservicetest . partition_value , abstractservicetest . no_subpartition_values , abstractservicetest . data_version , abstractservicetest . latest_version_flag_set , businessobjectdatastatusentity . valid ) ; businessobjectdatadaotesthelper . createbusinessobjectdataentity ( abstractservicetest . namespace , abstractservicetest . bdef_name , abstractservicetest . format_usage_code_2 , abstractservicetest . format_file_type_code , abstractservicetest . format_version , abstractservicetest . partition_value , abstractservicetest . no_subpartition_values , abstractservicetest . data_version , abstractservicetest . latest_version_flag_set , businessobjectdatastatusentity . invalid ) ; businessobjectdatadaotesthelper . createbusinessobjectdataentity ( abstractservicetest . namespace_2 , abstractservicetest . bdef_name_2 , abstractservicetest . format_usage_code_2 , abstractservicetest . format_file_type_code , abstractservicetest . format_version_2 , abstractservicetest . partition_value , abstractservicetest . no_subpartition_values , abstractservicetest . data_version , abstractservicetest . latest_version_flag_set , businessobjectdatastatusentity . invalid ) ; businessobjectdatadaotesthelper . createbusinessobjectdataentity ( abstractservicetest . namespace_2 , abstractservicetest . bdef_name_2 , abstractservicetest . format_usage_code_2 , abstractservicetest . format_file_type_code_2 , abstractservicetest . format_version_2 , abstractservicetest . partition_value , abstractservicetest . no_subpartition_values , abstractservicetest . data_version , abstractservicetest . latest_version_flag_set , businessobjectdatastatusentity . valid ) ; }	creates database entities for business object data search testing .
@ skipvalidation @ action ( value = _str ) public string reset ( ) { if ( logger . isdebugenabled ( ) ) logger . debug ( _str + ownername + _str + zoneid + _str + wardid + _str + propertytype + _str + noticetype + _str + noticenumber + _str + noticefromdate + _str + noticetodate + _str + indexnumber + _str + housenumber ) ; ownername = _str ; zoneid = - _num ; wardid = - _num ; propertytype = _str ; noticetype = _str ; noticenumber = _str ; noticefromdate = null ; noticetodate = null ; indexnumber = _str ; housenumber = _str ; if ( logger . isdebugenabled ( ) ) logger . debug ( _str ) ; return index ; }	reset all the values.
public void checkoptionsvalid ( ) { if ( alias_ratio < _num || alias_ratio > _num ) { throw new runtimeexception ( _str ) ; } if ( null_ratio < _num || null_ratio > _num ) { throw new runtimeexception ( _str ) ; } if ( maxsize <= _num ) { throw new runtimeexception ( _str + maxsize ) ; } if ( ! literals_file . isempty ( ) && literals_level == classliteralsmode . none ) { throw new runtimeexception ( _str ) ; } }	check that the options given satisfy any specified constraints , and fail if they do not .
@ override public uuid sessionid ( ) { if ( sessionid == null ) sessionid = uuid . randomuuid ( ) ; return sessionid ; }	used to uniquely identify the session.
private void readobject ( final objectinputstream in ) throws ioexception , classnotfoundexception { in . defaultreadobject ( ) ; final calendar definingcalendar = calendar . getinstance ( timezone , locale ) ; init ( definingcalendar ) ; }	create the object after serialization.
@ override public memchunkholder < bigdatapmemallocator > createchunk ( long size , boolean autoreclaim ) { memchunkholder < bigdatapmemallocator > ret = null ; long addr = m_nvmasvc . allocate ( m_nid , size , _bool ) ; if ( ( null == addr || _num == addr ) && m_activegc ) { forcegc ( ) ; addr = m_nvmasvc . allocate ( m_nid , size , _bool ) ; } if ( null != addr && _num != addr ) { ret = new memchunkholder < bigdatapmemallocator > ( this , addr , size ) ; ret . setcollector ( m_chunkcollector ) ; if ( autoreclaim ) { m_chunkcollector . register ( ret ) ; } } return ret ; }	create a memory chunk that is managed by its holder .
public int hashcode ( ) { int result = _num ; if ( tablename != null ) { result = _num * tablename . hashcode ( ) ; } if ( repositoryname != null ) { result = _num * repositoryname . hashcode ( ) ; } return result ; }	provide a hash code that is consistent with equals for this class.
private void tostring ( stringbuilder acc , int prec , boolean expand ) { if ( this . meta != null && ! expand ) { acc . append ( this . meta ) ; return ; } boolean paren = op . getprec ( ) < prec ; if ( paren ) acc . append ( _str ) ; tostring ( acc , expand ) ; if ( paren ) acc . append ( _str ) ; }	this handles adding parens , as necessary .
public static boolean isnotnullvalue ( string s ) { return ( ( s != null ) && ! s . isempty ( ) && ! s . equals ( nullcolumnvaluegetter . getnullstr ( ) ) ) ; }	checks to see if a string value is null .
public static string removeall ( string source , char toremove ) { int toremoveindex = source . indexof ( toremove ) ; if ( toremoveindex != - _num ) { stringbuilder result = new stringbuilder ( source . length ( ) ) ; int sourceindex = _num ; while ( toremoveindex != - _num ) { result . append ( source . substring ( sourceindex , toremoveindex ) ) ; sourceindex = toremoveindex + _num ; toremoveindex = source . indexof ( toremove , sourceindex ) ; if ( toremoveindex == - _num ) { result . append ( source . substring ( sourceindex , source . length ( ) ) ) ; } } return result . tostring ( ) ; } else { return source ; } }	a fast utility method that does ' nt use regex and removes all of toremove from source .
public list < entry < e > > aslist ( ) { if ( nonnulllist == null ) { if ( array == null || array . length ( ) == _num ) { nonnulllist = collections . emptylist ( ) ; } else { list < entry < e > > list = new arraylist < > ( array . length ( ) ) ; for ( int i = _num ; i < array . length ( ) ; i ++ ) { e e = array . get ( i ) ; if ( e != null ) { list . add ( new entry < > ( i , e ) ) ; } } nonnulllist = list ; } } return nonnulllist ; }	returns the it as a non null list , with an entry wrapping each value allowing to retain its index .
public static range findcumulativerangebounds ( categorydataset dataset ) { paramchecks . nullnotpermitted ( dataset , _str ) ; boolean allitemsnull = _bool ; double minimum = _num ; double maximum = _num ; for ( int row = _num ; row < dataset . getrowcount ( ) ; row ++ ) { double runningtotal = _num ; for ( int column = _num ; column <= dataset . getcolumncount ( ) - _num ; column ++ ) { number n = dataset . getvalue ( row , column ) ; if ( n != null ) { allitemsnull = _bool ; double value = n . doublevalue ( ) ; if ( ! double . isnan ( value ) ) { runningtotal = runningtotal + value ; minimum = math . min ( minimum , runningtotal ) ; maximum = math . max ( maximum , runningtotal ) ; } } } } if ( ! allitemsnull ) { return new range ( minimum , maximum ) ; } else { return null ; } }	calculates the range of values for a dataset where each item is the running total of the items for the current series .
private void addhotkeys ( jrootpane pane ) { for ( hotkey hotkey : hotkeys ) { if ( doeshotkeyhaveaction ( hotkey ) && hotkey . type == type . regular ) { if ( pane == null ) { addhotkey ( hotkey , main . getrootpane ( ) ) ; for ( jdialog popout : popouts . keyset ( ) ) { addhotkey ( hotkey , popout . getrootpane ( ) ) ; } } else { addhotkey ( hotkey , pane ) ; } } } }	adds all regular hotkeys to the given jrootpane , or to all ( main and popouts ) if the pane is null .
static < t > replaypromise < void > allreplay ( final duration timeout , final list < promise < t > > promises ) { return allreplay ( timeout , system . currenttimemillis ( ) , promises . toarray ( new promise [ promises . size ( ) ] ) ) ; }	all promises must complete .
public void checkandsetupbootstrapinfo ( dbclient dbclient ) { if ( onstandby ) { _log . info ( _str ) ; return ; } if ( _vdclist != null && _vdclist . size ( ) > _num ) { _log . info ( _str , _vdclist . size ( ) ) ; return ; } int retryintervalsecs = dbinit_retry_interval ; boolean done = _bool ; boolean wait ; while ( ! done ) { wait = _bool ; interprocesslock lock = null ; try { lock = _coordinator . getlock ( getbootstraplockname ( ) ) ; _log . info ( _str ) ; lock . acquire ( ) ; if ( isgeodbsvc ( ) ) { insertdefaultroottenant ( dbclient ) ; } else { insertmyvdcinfo ( dbclient ) ; insertvdcversion ( dbclient ) ; insertpasswordhistory ( dbclient ) ; } done = _bool ; } catch ( exception e ) { if ( e instanceof illegalstateexception ) { throw ( illegalstateexception ) e ; } else { _log . warn ( _str , retryintervalsecs , e ) ; wait = _bool ; } } finally { if ( lock != null ) { try { lock . release ( ) ; } catch ( exception e ) { _log . error ( _str , e ) ; } } } if ( wait ) { try { thread . sleep ( retryintervalsecs * _num ) ; } catch ( interruptedexception ex ) { _log . warn ( _str , ex ) ; } } } }	init the bootstrap info , including : check and setup root tenant or my vdc info , if it doesn ' t exist.
object processexpr ( stylesheethandler handler , string uri , string name , string rawname , string value , elemtemplateelement owner ) throws org . xml . sax . saxexception { try { xpath expr = handler . createxpath ( value , owner ) ; return expr ; } catch ( transformerexception te ) { throw new org . xml . sax . saxexception ( te ) ; } }	process an attribute string of type t_expr into an xpath value .
private void checkaccess ( unixpath file , boolean checkread , boolean checkwrite ) { securitymanager sm = system . getsecuritymanager ( ) ; if ( sm != null ) { if ( checkread ) file . checkread ( ) ; if ( checkwrite ) file . checkwrite ( ) ; sm . checkpermission ( new runtimepermission ( _str ) ) ; } }	permission checks to access file.
private static spanned removeimagespanobjects ( spanned spanned ) { spannablestringbuilder builder = ( spannablestringbuilder ) spanned ; object [ ] spannedobjects = builder . getspans ( _num , builder . length ( ) , object . class ) ; for ( int i = _num ; i < spannedobjects . length ; i ++ ) { if ( spannedobjects [ i ] instanceof imagespan ) { imagespan imagespan = ( imagespan ) spannedobjects [ i ] ; builder . replace ( spanned . getspanstart ( imagespan ) , builder . getspanend ( imagespan ) , _str ) ; } } return spanned ; }	replaces all image objects in a spannable with nothing essentially removes them.
public future < string > classify ( string snippet ) { final executorservice service = executors . newsinglethreadexecutor ( ) ; return service . submit ( new classifyingtask ( snippet ) ) ; }	creates code snippet language classifying task .
public abstract byte [ ] embeddata ( byte [ ] msg , string msgfilename , byte [ ] cover , string coverfilename , string stegofilename ) throws openstegoexception ;	method to embed the message into the cover data.
public void addsetter ( int i ) { for ( scatterplotsetter setter : setterlist ) { if ( setter . getindex ( ) == i ) { return ; } } setterlist . add ( new scatterplotsetter ( i ) ) ; }	add a setter with the specified index .
@ override public synchronized void initialize ( ) { if ( ! mrootdirectory . exists ( ) ) { if ( ! mrootdirectory . mkdirs ( ) ) { loger . debug ( string . format ( _str , mrootdirectory . getabsolutepath ( ) ) ) ; } return ; } file [ ] files = mrootdirectory . listfiles ( ) ; if ( files == null ) { return ; } for ( file file : files ) { bufferedinputstream fis = null ; try { fis = new bufferedinputstream ( new fileinputstream ( file ) ) ; cacheheader entry = cacheheader . readheader ( fis ) ; entry . size = file . length ( ) ; putentry ( entry . key , entry ) ; } catch ( ioexception e ) { file . delete ( ) ; } finally { fileutils . closeio ( fis ) ; } } }	initializes the diskbasedcache by scanning for all files currently in the specified root directory.
public client ( final serversocketchannel server ) throws ioexception { try { client = server . accept ( ) ; client . configureblocking ( _bool ) ; if ( ! client . finishconnect ( ) ) throw new ioexception ( _str ) ; clientselector = selector . open ( ) ; clientkey = client . register ( clientselector , selectionkey . op_read ) ; if ( log . isinfoenabled ( ) ) log . info ( _str ) ; } catch ( ioexception ex ) { close ( ) ; throw ex ; } }	gets the client connection and open the channel in a non - blocking mode so we will read whatever is available and loop until all data has been read .
public transfer writebytes ( byte [ ] data ) throws ioexception { if ( data == null ) { writeint ( - _num ) ; } else { writeint ( data . length ) ; out . write ( data ) ; } return this ; }	write a byte array .
public static void stop ( string [ ] args ) { log . info ( _str ) ; system . exit ( _num ) ; }	stopping the service container .
public boolean add ( object o ) { if ( ! list . contains ( o ) ) { list . add ( o ) ; return _bool ; } return _bool ; }	adds the specified element to this set if it is not already present ( optional operation ) .
public static void logerror ( throwable exception , string message , object ... args ) { message = messageformat . format ( message , args ) ; log ( istatus . error , istatus . ok , message , exception ) ; }	log the specified error .
public void add ( row r ) { list . add ( r ) ; memory += r . getmemory ( ) + constants . memory_pointer ; if ( maxmemory > _num && memory > maxmemory ) { writeallrows ( ) ; } size ++ ; }	add a row to the list .
private messagelistview renderconversation ( conversationinfo convinfo , view parent ) { messagelistview list = new messagelistview ( parent . getcontext ( ) ) ; convinfo . view = list ; list . setonitemclicklistener ( messageclicklistener . getinstance ( ) ) ; messagelistadapter adapter = convinfo . adapter ; if ( adapter == null ) { adapter = new messagelistadapter ( convinfo . conv , parent . getcontext ( ) ) ; convinfo . adapter = adapter ; } list . setadapter ( adapter ) ; list . setselection ( adapter . getcount ( ) - _num ) ; return list ; }	render the given conversation and return the new view .
public static int definetag ( int ifdid , short tagid ) { return ( tagid & _num ) | ( ifdid << _num ) ; }	returns the constant representing a tag with a given tid and default ifd .
public applicationidverifier ( set < string > supportedapplicationids ) { this . supportedapplicationids = collections . unmodifiableset ( new hashset < string > ( supportedapplicationids ) ) ; }	constructs a new application id verifier with the provided set of supported application ids.
public queryresponse search ( resource resource , solrquery query ) throws solrserverexception , ioexception { string idquery = termquery ( searchfields . uri_field_name , searchfields . getresourceid ( resource ) ) ; query . setquery ( query . getquery ( ) + _str + idquery ) ; return search ( query ) ; }	evaluates the given query only for the given resource .
public static localdate todate ( string data , string modelo ) { return localdate . parse ( data , formatter ( modelo ) ) ; }	converte string em localdate indicando o formato.
public static final criterion all ( ) { return allcriterion . all ( ) ; }	creates a filter matching all messages .
public static void transform ( inputstream srcstream , outputstream deststream , inputstream stylesheetstream , string outputformat ) throws fopexception { streamsource src = new streamsource ( srcstream ) ; streamsource stylesheet = stylesheetstream == null ? null : new streamsource ( stylesheetstream ) ; fop fop = createfopinstance ( deststream , outputformat ) ; transform ( src , stylesheet , fop ) ; }	transform an xsl - fo inputstream to the specified outputstream format .
public boolean insertsym ( int type , string id , string context , string ctype , int line , int col ) { int i ; if ( type == procedurevar || type == processvar || type == parameter ) { i = findsym ( global , id , _str ) ; if ( i < symtab . size ( ) ) return _bool ; i = findsym ( id , context ) ; if ( i < symtab . size ( ) ) return _bool ; } else { i = findsym ( type , id , context ) ; if ( i < symtab . size ( ) ) return _bool ; } symtabentry se = new symtabentry ( type , id , context , ctype , line , col ) ; symtab . addelement ( se ) ; return _bool ; }	true if inserted ; false if was already in table can not insert a variable of name x if there is a global with name x or another variable in the same context with name x . /.
public static schema schemaforstructtype ( structtype structtype ) { list < string > fieldnames = lists . newarraylist ( ) ; list < string > fieldtypes = lists . newarraylist ( ) ; for ( structfield field : structtype . fields ( ) ) { fieldnames . add ( field . name ( ) ) ; datatype fieldtype = field . datatype ( ) ; if ( fieldtype . equals ( datatypes . stringtype ) ) { fieldtypes . add ( _str ) ; } else if ( fieldtype . equals ( datatypes . floattype ) ) { fieldtypes . add ( _str ) ; } else if ( fieldtype . equals ( datatypes . doubletype ) ) { fieldtypes . add ( _str ) ; } else if ( fieldtype . equals ( datatypes . integertype ) ) { fieldtypes . add ( _str ) ; } else if ( fieldtype . equals ( datatypes . longtype ) ) { fieldtypes . add ( _str ) ; } else if ( fieldtype . equals ( datatypes . booleantype ) ) { fieldtypes . add ( _str ) ; } else { throw new runtimeexception ( _str + fieldtype ) ; } } return recordutils . schemafor ( fieldnames , fieldtypes ) ; }	the equivalent avro schema for the given spark sql schema .
public jettysolrrunner startjettysolrrunner ( jettysolrrunner jetty ) throws exception { jetty . start ( _bool ) ; jettys . add ( jetty ) ; return jetty ; }	add a previously stopped node back to the cluster.
public map < cimobjectpath , set < string > > findanyslostoragegroupscanbereused ( storagesystem forprovider , storagesystem storage , string policyname , boolean associatedtoview ) throws wbemexception { closeableiterator < ciminstance > groupinstanceitr = null ; closeableiterator < cimobjectpath > volumepathitr = null ; map < cimobjectpath , set < string > > grouppaths = new concurrenthashmap < cimobjectpath , set < string > > ( ) ; try { cimobjectpath controllerconfigsvcpath = _cimpath . getcontrollerconfigsvcpath ( storage ) ; _log . info ( _str ) ; groupinstanceitr = getassociatorinstances ( forprovider , controllerconfigsvcpath , null , se_device_masking_group , null , null , ps_v3_storage_group_properties ) ; while ( groupinstanceitr . hasnext ( ) ) { ciminstance groupinstance = groupinstanceitr . next ( ) ; cimobjectpath grouppath = groupinstance . getobjectpath ( ) ; string groupname = cimpropertyfactory . getpropertyvalue ( groupinstance , cp_element_name ) ; string fastsetting = cimpropertyfactory . getpropertyvalue ( groupinstance , cp_fast_setting ) ; string groupassociatedtoview = cimpropertyfactory . getpropertyvalue ( groupinstance , cp_associated_to_view ) ; set < string > returnednativeguids = new hashset < string > ( ) ; if ( fastsetting . equals ( policyname ) && associatedtoview == boolean . parseboolean ( groupassociatedtoview ) && groupname . startswith ( constants . storage_group_prefix ) ) { _log . debug ( _str , groupname ) ; volumepathitr = getassociatornames ( forprovider , grouppath , null , cim_storage_volume , null , null ) ; while ( volumepathitr . hasnext ( ) ) { returnednativeguids . add ( getvolumenativeguid ( volumepathitr . next ( ) ) ) ; } grouppaths . put ( grouppath , returnednativeguids ) ; } } } finally { closecimiterator ( groupinstanceitr ) ; closecimiterator ( volumepathitr ) ; } return grouppaths ; }	this method is used for vmax3 storage system to find exiting storage group with a specified slo for parking volumes .
remover add ( t listener ) ;	registers a new listener .
public jclassdependency ( jclass cl , string digest ) { _classname = cl . getname ( ) ; string newdigest = getdigest ( ) ; if ( ! newdigest . equals ( digest ) ) { if ( log . isloggable ( level . fine ) ) log . fine ( _classname + _str ) ; _isdigestmodified = _bool ; } }	create a new dependency with a given digest .
public void dump ( object data , writer output ) { list < object > list = new arraylist < object > ( _num ) ; list . add ( data ) ; dumpall ( list . iterator ( ) , output , null ) ; }	serialize a java object into a yaml stream .
public void clear ( ) { final reentrantlock lock = this . lock ; lock . lock ( ) ; try { object [ ] array = queue ; int n = size ; size = _num ; for ( int i = _num ; i < n ; i ++ ) array [ i ] = null ; } finally { lock . unlock ( ) ; } }	atomically removes all of the elements from this queue.
public void addinsntohead ( insn insn ) { ssainsn newinsn = ssainsn . makefromrop ( insn , this ) ; insns . add ( getcountphiinsns ( ) , newinsn ) ; parent . oninsnadded ( newinsn ) ; }	adds an insn to the head of this basic block , just after any phi insns .
public static string encodeforurl ( string str ) { stringbuffer result = new stringbuffer ( ) ; for ( int i = _num ; i < str . length ( ) ; i ++ ) { char ch = str . charat ( i ) ; if ( ch >= _str && ch <= _str || ch >= _str && ch <= _str || ch >= _str && ch <= _str ) result . append ( ch ) ; else { switch ( ch ) { case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : result . append ( ch ) ; break ; default : result . append ( _str ) ; result . append ( hexchars [ ( ch & _num ) > > _num ] ) ; result . append ( hexchars [ ch & _num ] ) ; break ; } } } return result . tostring ( ) ; }	escapes special characters not suitable for urls with " % xx ".
public void selectobject ( multitouchobject multitouchobject , pointinfo touchpoint ) { currtouchpoint . set ( touchpoint ) ; if ( multitouchobject != null ) { mimages . remove ( multitouchobject ) ; mimages . add ( multitouchobject ) ; if ( listener != null ) { listener . onimageobjectselected ( multitouchobject ) ; } } else { if ( listener != null ) { listener . onimageobjectdropped ( ) ; } } invalidate ( ) ; }	select an object for dragging.
void verify ( ) { byte [ ] d = digest . digest ( ) ; if ( ! messagedigest . isequal ( d , base64 . decode ( hash , base64 . default ) ) ) { throw invaliddigest ( jarfile . manifest_name , name , jarname ) ; } verifiedentries . put ( name , certificates ) ; }	verifies that the digests stored in the manifest match the decrypted digests from the.
public void randomizeincomingweights ( ) { for ( neuron n : getneuronlist ( ) ) { for ( synapse s : n . getfanin ( ) ) { s . setlowerbound ( _num ) ; s . setstrength ( s . getupperbound ( ) * math . random ( ) ) ; } } }	randomize all weights coming in to this network.
public void remove ( queueevent event ) throws keeperexception , interruptedexception { timercontext time = stats . time ( dir + _str ) ; try { string path = event . getid ( ) ; string responsepath = dir + _str + response_prefix + path . substring ( path . lastindexof ( _str ) + _num ) ; if ( zookeeper . exists ( responsepath , _bool ) ) { zookeeper . setdata ( responsepath , event . getbytes ( ) , _bool ) ; } else { log . info ( _str + responsepath + _str + _str ) ; } try { zookeeper . delete ( path , - _num , _bool ) ; } catch ( keeperexception . nonodeexception ignored ) { } } finally { time . stop ( ) ; } }	remove the event and save the response into the other path .
public list < point > readpoints ( string shapefile ) { list < point > list = new arraylist < point > ( ) ; for ( simplefeature feature : shapefilereader . getallfeatures ( shapefile ) ) { geometry geo = ( geometry ) feature . getdefaultgeometry ( ) ; if ( geo instanceof point ) { point ps = ( point ) geo ; for ( int i = _num ; i < ps . getnumgeometries ( ) ; i ++ ) { point p = ( point ) ps . getgeometryn ( i ) ; list . add ( p ) ; } } else { throw new runtimeexception ( _str ) ; } } return list ; }	reads a point feature shapefile .
public string rate ( properties ctx , int windowno , gridtab mtab , gridfield mfield , object value ) { if ( value == null ) return _str ; integer currency_id = ( integer ) mtab . getvalue ( _str ) ; int c_currency_id = currency_id . intvalue ( ) ; integer conversiontype_id = ( integer ) mtab . getvalue ( _str ) ; int c_conversiontype_id = conversiontype_id . intvalue ( ) ; timestamp dateacct = ( timestamp ) mtab . getvalue ( _str ) ; if ( dateacct == null ) dateacct = new timestamp ( system . currenttimemillis ( ) ) ; int c_acctschema_id = env . getcontextasint ( ctx , windowno , _str ) ; macctschema as = macctschema . get ( ctx , c_acctschema_id ) ; int ad_client_id = env . getcontextasint ( ctx , windowno , _str ) ; int ad_org_id = env . getcontextasint ( ctx , windowno , _str ) ; bigdecimal currencyrate = mconversionrate . getrate ( c_currency_id , as . getc_currency_id ( ) , dateacct , c_conversiontype_id , ad_client_id , ad_org_id ) ; log . fine ( _str + currencyrate ) ; if ( currencyrate == null ) currencyrate = env . zero ; mtab . setvalue ( _str , currencyrate ) ; return _str ; }	journal / line - rate . set currencyrate from dateacct , c_conversiontype_id , c_currency_id.
public boolean hasalphachangedfrom ( float v ) { return ( float . compare ( alpha , v ) != _num ) ; }	convenience functions to compare against current property values.
public completablefuture < void > destroy ( ) { completablefuture < void > ret ; if ( controllerproxy != null ) { ret = controllerproxy . destroy ( ) ; controllerproxy = null ; } else { ret = new completablefuture < > ( ) ; ret . complete ( null ) ; } return ret ; }	by calling this method the mvc group will be destroyed.
@ override public request < string > logs ( projectreference projectreference , long taskid ) { list < dummyrunnerstatus > statuses = availablerunnerstatuses . get ( projectreference . name ( ) ) ; if ( statuses != null && ! statuses . isempty ( ) ) { for ( dummyrunnerstatus runnerstatus : statuses ) { if ( taskid == runnerstatus . processid ( ) ) { return new dummyrequest < > ( runnerstatus . getlog ( ) ) ; } } } return new dummyrequest < > ( null ) ; }	gets the logs of the builder with the given task id .
protected static actionresultinfo performaction ( genericvalue productpromoaction , shoppingcart cart , delegator delegator , localdispatcher dispatcher , timestamp nowtimestamp ) throws genericentityexception , cartitemmodifyexception { actionresultinfo actionresultinfo = new actionresultinfo ( ) ; performaction ( actionresultinfo , productpromoaction , cart , delegator , dispatcher , nowtimestamp ) ; return actionresultinfo ; }	returns true if the cart was changed and rules need to be re - evaluted.
private boolean containsexpression ( string tosearch , string expression ) { if ( tosearch == null ) { return _bool ; } return tosearch . equals ( expression ) || tosearch . indexof ( expression ) >= _num ; }	checks if the tosearch string contains the expression .
public void clearlisteners ( ) { listeners . clear ( ) ; }	clears the list of listeners.
private var addproperty ( varproperty property ) { if ( property . isunique ( ) ) { testuniqueproperty ( ( uniquevarproperty ) property ) ; } properties . add ( property ) ; return this ; }	add a non - unique property.
public boolean isopen ( ) { return open . get ( ) ; }	gets the status of the java process .
public void free ( long pos , int length ) { int start = getblock ( pos ) ; int blocks = getblockcount ( length ) ; set . clear ( start , start + blocks ) ; }	mark the space as free .
private void onconnectionstatuschanged ( int oldstatus , int status ) { if ( ssettingsmgr . showstatusicon ) { notificationcompat . builder builder = new notificationcompat . builder ( this ) ; builder . setwhen ( system . currenttimemillis ( ) ) ; switch ( status ) { case xmppmanager . connected : builder . setcontenttext ( getstring ( r . string . main_service_connected , getconnectionstatusaction ( ) ) ) ; builder . setsmallicon ( getimagestatus ( status_icon_green ) ) ; break ; case xmppmanager . connecting : builder . setcontenttext ( getstring ( r . string . main_service_connecting ) ) ; builder . setsmallicon ( getimagestatus ( status_icon_orange ) ) ; break ; case xmppmanager . disconnected : builder . setcontenttext ( getstring ( r . string . main_service_disconnected ) ) ; builder . setsmallicon ( getimagestatus ( status_icon_red ) ) ; break ; case xmppmanager . disconnecting : builder . setcontenttext ( getstring ( r . string . main_service_disconnecting ) ) ; builder . setsmallicon ( getimagestatus ( status_icon_orange ) ) ; break ; case xmppmanager . waiting_to_connect : case xmppmanager . waiting_for_network : builder . setcontenttext ( getstring ( r . string . main_service_waiting_to_connect ) + _str + getconnectionstatusaction ( ) ) ; builder . setsmallicon ( getimagestatus ( status_icon_blue ) ) ; break ; default : return ; } builder . setcontentintent ( spendingintentlaunchapplication ) ; builder . setcontenttitle ( tools . app_name ) ; startforeground ( notification_connection , builder . getnotification ( ) ) ; } }	updates the status about the service state ( and the status bar ).
private static file findguacamolehome ( ) { file guachome ; string desireddir = system . getproperty ( _str ) ; if ( desireddir == null ) desireddir = system . getenv ( _str ) ; if ( desireddir != null ) guachome = new file ( desireddir ) ; else guachome = new file ( system . getproperty ( _str ) , _str ) ; return guachome ; }	locates the guacamole home directory by checking , in order : the guacamole.
void waitforserverstart ( ) throws interruptedexception { started . await ( gettesttimeout ( ) , timeunit . milliseconds ) ; }	blocks the executing thread until at least one server has started .
private static void drawlefttab ( int x , int y , int w , int h , graphics2d g2 , coloruiresource color ) { double rtop = rapidlookandfeel . corner_tab_radius * _num ; g2 . setcolor ( color ) ; g2 . fill ( createlefttabshape ( x + _num , y + _num , w - _num , h , rtop , _bool ) ) ; g2 . setcolor ( colors . tab_border ) ; g2 . draw ( createlefttabshape ( x , y , w - _num , h , rtop , _bool ) ) ; }	draw a left tab at the given location and size with the given background color .
private list < int [ ] > prepareexpecteddata ( ) { list < int [ ] > indexlist = new arraylist < > ( _num ) ; int [ ] sortindex = { _num , _num , _num , _num , _num } ; int [ ] sortindexinverted = { _num , _num , _num , _num , _num } ; indexlist . add ( _num , sortindex ) ; indexlist . add ( _num , sortindexinverted ) ; return indexlist ; }	method return the list of sortindex and sortindexinverted array.
public byte [ ] readbytes ( final int count ) { int bytestoread = count ; if ( bytestoread < _num ) bytestoread = bytestream . available ( ) ; byte [ ] bytes = new byte [ bytestoread ] ; if ( currentbitindex >= _num ) { for ( int i = _num ; i < bytestoread ; i ++ ) { bytes [ i ] = ( byte ) read ( byte . size ) ; } } else { bytestream . read ( bytes , _num , bytes . length ) ; } return bytes ; }	reads a sequence of bytes from the stream .
public ssltestconfig ( ) { this ( _bool , _bool ) ; }	creates an ssltestconfig that does not use ssl or client authentication.
@ override public int hashcode ( ) { return _num + arrays . hashcode ( fields ) ; }	returns a hash code value for this object .
public static string formatpath ( list < childnumber > path ) { return path_joiner . join ( iterables . concat ( collections . singleton ( _str ) , path ) ) ; }	convert to a string path , starting with " m / ".
public static object readinvocationresult ( platformcontext ctx , binaryrawreaderex reader ) throws ignitecheckedexception { boolean success = reader . readboolean ( ) ; if ( success ) return reader . readobjectdetached ( ) ; else { boolean hasexception = reader . readboolean ( ) ; if ( hasexception ) { object nativeerr = reader . readobjectdetached ( ) ; assert nativeerr != null ; throw ctx . createnativeexception ( nativeerr ) ; } else { string errmsg = reader . readstring ( ) ; assert errmsg != null ; throw new ignitecheckedexception ( errmsg ) ; } } }	reads invocation result ( of a job / service / etc ) using a common protocol .
public final void testgenerateseedint02 ( ) { for ( int i = _num ; i < length ; i ++ ) { byte [ ] mybytes = sr . generateseed ( i ) ; assertfalse ( _str + i + _str + mybytes . length , mybytes . length != i ) ; } }	test against the " void generateseed ( int ) " method ; it checks out that number of bits returned is equal to one requested ; the check includes case for argument ' s value = = 0 ;.
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return string_thing ; case _num : return byte_thing ; case _num : return i32_thing ; case _num : return i64_thing ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
private list < string > replacedotinmustachekeys ( final list < string > mustachekeys ) { final list < string > fixedmustachekeys = new arraylist < > ( ) ; for ( string mustachekey : mustachekeys ) { fixedmustachekeys . add ( mustachekey . replace ( _str , _str ) ) ; } return fixedmustachekeys ; }	todo : trivial components does not support foo.
public static ifitsheader create ( string key ) { ifitsheader result = standard_keys . get ( key ) ; if ( result == null ) { result = new fitsheaderimpl ( key , source . unknown , hdu . any , value . any , _str ) ; } return result ; }	create a fits header key from a free string.
protected string parsepayload ( string payload ) { string json = null ; if ( payload != null ) { try { json = ( payload . indexof ( _str ) == - _num ) ? new string ( files . readallbytes ( paths . get ( payload ) ) ) : payload ; } catch ( ioexception e ) { log . fatal ( _str + payload , e ) ; system . exit ( _num ) ; } } return json ; }	parses payload argument from command line and returns the json .
boolean addentry ( policyentry pe , int index ) { if ( index < _num ) { policyentries . addelement ( pe ) ; parser . add ( pe . getgrantentry ( ) ) ; } else { policyentry origpe = policyentries . elementat ( index ) ; parser . replace ( origpe . getgrantentry ( ) , pe . getgrantentry ( ) ) ; policyentries . setelementat ( pe , index ) ; } return _bool ; }	add a grant entry to the overall policy at the specified index.
public writableraster createcompatiblewritableraster ( int w , int h ) { if ( w <= _num || h <= _num ) { throw new rasterformatexception ( _str + ( ( w <= _num ) ? _str : _str ) ) ; } samplemodel sm = samplemodel . createcompatiblesamplemodel ( w , h ) ; return new integercomponentraster ( sm , new point ( _num , _num ) ) ; }	creates a raster with the same band layout but using a different width and height , and with new zeroed data arrays .
public void testcase1 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = _num ; int bsign = _num ; byte rbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . subtract ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _num , result . signum ( ) ) ; }	subtract two positive numbers of the same length.
public static void createorcleardestinationfolder ( string path ) { file fpath = new file ( path ) ; fpath . mkdirs ( ) ; deletedirectorycontents ( path , _bool ) ; }	creates a directory with given path if it does not exist and clears the contents of the directory in case it exists .
static synchronized jmriuserinterfaceconfigurationprovider findprovider ( profile project ) { if ( providers . get ( project ) == null ) { providers . put ( project , new jmriuserinterfaceconfigurationprovider ( project ) ) ; } return providers . get ( project ) ; }	get the jmriprefererncesprovider for the specified profile .
protected static long [ ] insert ( long [ ] old , int oldsize , int pos , long x ) { long [ ] result ; if ( old != null && old . length > oldsize ) { result = old ; } else { result = new long [ oldsize + _num + copy_threshold ] ; if ( pos > _num ) { system . arraycopy ( old , _num , result , _num , pos ) ; } } if ( old != null && oldsize - pos > _num ) { system . arraycopy ( old , pos , result , pos + _num , oldsize - pos ) ; } result [ pos ] = x ; return result ; }	insert a value in an array.
private boolean discardupstreammediachunks ( int queuelength ) { if ( mediachunks . size ( ) <= queuelength ) { return _bool ; } long starttimeus = _num ; long endtimeus = mediachunks . getlast ( ) . endtimeus ; basemediachunk removed = null ; while ( mediachunks . size ( ) > queuelength ) { removed = mediachunks . removelast ( ) ; starttimeus = removed . starttimeus ; loadingfinished = _bool ; } samplequeue . discardupstreamsamples ( removed . getfirstsampleindex ( ) ) ; notifyupstreamdiscarded ( starttimeus , endtimeus ) ; return _bool ; }	discard upstream media chunks until the queue length is equal to the length specified .
public void close ( ) { animation . setrate ( - _num ) ; animation . play ( ) ; animation . setonfinished ( null ) ; }	close the popup , by default the popup will close when clicking outside the popup content and inside its container.
map < string , set < calllocationmodel > > computefilteredtaintsourcesmap ( set < calllocationmodel > sources ) { if ( ! sources . isempty ( ) ) { if ( ffilteredtaintsourcesmap != null && ! ffilteredtaintsourcesmap . isempty ( ) ) { map < string , set < calllocationmodel > > result = new treemap < string , set < calllocationmodel > > ( ) ; for ( entry < string , set < calllocationmodel > > entry : ffilteredtaintsourcesmap . entryset ( ) ) { set < calllocationmodel > filteredsources = new treeset < calllocationmodel > ( ) ; for ( calllocationmodel source : entry . getvalue ( ) ) { if ( sources . contains ( source ) ) { filteredsources . add ( source ) ; } } if ( ! filteredsources . isempty ( ) ) { string taintkind = entry . getkey ( ) ; result . put ( taintkind , filteredsources ) ; } } return result ; } } return collections . empty_map ; }	given a set of info sources , computes the set of filtered info sources using the filtering info stored in the field ffilteredtaintsourcesmap.
public static boolean contains ( string s , property expected ) { if ( s == null || s . length ( ) == _num ) { return _bool ; } int i = _num ; while ( i < s . length ( ) ) { int codepoint = character . codepointat ( s , i ) ; emoji e = map . get ( codepoint ) ; if ( e == null ) { return _bool ; } if ( ! e . is ( expected ) ) { return _bool ; } i += codepoint >= _num ? _num : _num ; } return _bool ; }	returns whether any of the characters in s has the expected properties .
public class toclass ( string codebase ) throws ioexception , classnotfoundexception { if ( name . charat ( _num ) != _str ) { return classloading . loadclass ( codebase , name , null , integrity , null ) ; } stringtokenizer st = new stringtokenizer ( name , _str ) ; string [ ] ifs = new string [ st . counttokens ( ) ] ; for ( int i = _num ; i < ifs . length ; i ++ ) { ifs [ i ] = st . nexttoken ( ) ; } return classloading . loadproxyclass ( codebase , ifs , null , integrity , null ) ; }	converts this descriptor to a class instance , loading from codebase.
public static < t > optional < t > lowestcommonancestor ( treedef . parented < t > treedef , list < t > nodes ) { if ( nodes . size ( ) == _num ) { return optional . empty ( ) ; } else { optional < t > sofar = optional . of ( nodes . get ( _num ) ) ; for ( int i = _num ; i < nodes . size ( ) && sofar . ispresent ( ) ; ++ i ) { sofar = lowestcommonancestor ( treedef , sofar . get ( ) , nodes . get ( i ) ) ; } return sofar ; } }	returns the common parent of n elements .
public void copyvaluenodestome ( entity from ) { for ( valuenode fromchild : from . getchildren ( valuenode . class ) ) { valuenode tochild = getchild ( fromchild . getname ( ) , valuenode . class ) ; tochild . setvalue ( fromchild . getvalue ( ) ) ; } }	copies the values nodes from the input entity to this object.
public static worldiconimage frompixeltransparency ( bufferedimage image ) { int imagemargintop = findfirstsolidpixelfromtop ( image ) ; int imagemarginbottom = findfirstsolidpixelfrombottom ( image ) ; int frameheight = math . max ( _num , image . getheight ( ) - imagemargintop - imagemarginbottom ) ; return new worldiconimage ( image , _num , imagemargintop , image . getwidth ( ) , frameheight ) ; }	use pixel transparency along the left edge of the icon to automatically determine the vertical frame position.
private map < string , string > checkvipdiff ( propertyinfoext localprops , propertyinforestrep rep ) { string vipaddrv4 = rep . getproperty ( _str ) ; string vipaddrv6 = rep . getproperty ( _str ) ; map < string , string > diffprops = new hashmap < string , string > ( ) ; if ( ! vipaddrv4 . equals ( localprops . getproperty ( _str ) ) ) { diffprops . put ( _str , vipaddrv4 ) ; _log . warn ( _str , vipaddrv4 , localprops . getproperty ( _str ) ) ; } if ( ! vipaddrv6 . equals ( localprops . getproperty ( _str ) ) ) { diffprops . put ( _str , vipaddrv6 ) ; _log . warn ( _str , vipaddrv6 , localprops . getproperty ( _str ) ) ; } return diffprops ; }	check if vip changed comparing locally cached vip vs vip get from controller diff.
private static double distancesq ( color a , color b ) { double rmean = ( a . getred ( ) + b . getred ( ) ) / _num / _num ; double dr = ( a . getred ( ) - b . getred ( ) ) / _num ; double dg = ( a . getgreen ( ) - b . getgreen ( ) ) / _num ; double db = ( a . getblue ( ) - b . getblue ( ) ) / _num ; double d = ( _num + rmean ) * dr * dr + _num * dg * dg + ( _num + _num - rmean ) * db * db ; return d / _num ; }	calculates the square of the distance between the two specified colors .
@ override public boolean eisset ( int featureid ) { switch ( featureid ) { case sgraphpackage . specification_element__specification : return specification_edefault == null ? specification != null : ! specification_edefault . equals ( specification ) ; } return super . eisset ( featureid ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
private static applicationtype newtype ( final string name ) throws illegalaccessexception , instantiationexception { return new applicationtype ( name , new hashmap < string , boolean > ( type_actions ) , dumbsearchindex . class , dumbsaveindex . class , dumbresourcename . class ) ; }	creates a new application type .
public int compare ( sourcefile o1 , sourcefile o2 ) { string n1 = o1 . getname ( ) ; string n2 = o2 . getname ( ) ; return n1 . compareto ( n2 ) ; }	comparator interface for sorting sourcefiles.
protected boolean processdynamicpropertynodes ( node parent , dynamicproperty property , model model ) { collection nodes = parent . getchildren ( ) ; string name = property . getname ( ) ; string state = property . getstatename ( ) ; cdatanode cdata = gettextcontent ( nodes , _bool ) ; if ( cdata != null ) { return processdynamicpropertytext ( name , cdata . image , textorigin . fromchild ( cdata . incdata ) , cdata . beginline , model , state ) ; } else { if ( ( state == null ) && model . hasproperty ( name ) ) { log ( parent , new multiplepropertyinitializererror ( name ) ) ; } object rvalue = processrvaluenodes ( property , nodes , model ) ; if ( rvalue != null ) { model . setdynamicproperty ( typetable . objecttype , name , rvalue , state , parent . beginline ) ; return _bool ; } else { return _bool ; } } }	note : nodes must not be empty.
private static < t extends psielement > boolean processchildrenoftype ( psielement element , processor < t > processor , class < t > psiclass , boolean reverseorder ) { psielement child = reverseorder ? element . getlastchild ( ) : element . getfirstchild ( ) ; while ( child != null ) { if ( psiclass . isinstance ( child ) ) { if ( ! processor . process ( ( t ) child ) ) { return _bool ; } } if ( processchildrenoftype ( child , processor , psiclass , reverseorder ) ) { return _bool ; } child = reverseorder ? child . getprevsibling ( ) : child . getnextsibling ( ) ; } return _bool ; }	walk through entire psi tree rooted at ' element ' , processing all children of the given type .
public instances generate ( ) throws exception { return generate ( _str ) ; }	generates a new dataset.
protected void loadchars ( abstractmrreply msg , datainputstream istream ) throws ioexception { int i ; for ( i = _num ; i < msg . maxsize ( ) ; i ++ ) { byte char1 = readbyteprotected ( istream ) ; if ( flushreceivechars ) { log . warn ( _str , msg . tostring ( ) ) ; msg . flush ( ) ; i = _num ; flushreceivechars = _bool ; } if ( canreceive ( ) ) { msg . setelement ( i , char1 ) ; if ( endofmessage ( msg ) ) { break ; } } else { i -- ; log . error ( _str , integer . tohexstring ( char1 ) ) ; } } }	get characters from the input source , and file a message.
public string evaluate ( associator associator , instances data ) throws exception { long starttime ; long endtime ; starttime = system . currenttimemillis ( ) ; associator . buildassociations ( data ) ; endtime = system . currenttimemillis ( ) ; m_result = new stringbuffer ( associator . tostring ( ) ) ; m_result . append ( _str ) ; m_result . append ( _str + ( ( ( double ) ( endtime - starttime ) ) / _num ) + _str ) ; m_result . append ( _str ) ; return m_result . tostring ( ) ; }	evaluates the associator with the given commandline options and returns the evaluation string .
public static integer intvalue ( string propname , integer dflt ) { string sysprop = getproperty ( propname ) ; return ( sysprop != null && ! sysprop . isempty ( ) ) ? integer . getinteger ( sysprop ) : dflt ; }	returns boolean value from system property or provided function .
private int compareversionparts ( string version1 , string version2 ) { int compare = _num ; integer v1 ; integer v2 ; try { v1 = version1 != null ? integer . parseint ( version1 ) : _num ; } catch ( numberformatexception e ) { v1 = _num ; } try { v2 = version2 != null ? integer . parseint ( version2 ) : _num ; } catch ( numberformatexception e ) { v2 = _num ; } if ( v1 > v2 ) { compare = _num ; } else if ( v1 < v2 ) { compare = - _num ; } else { compare = _num ; } return compare ; }	compare 2 version number strings.
public void presaveinit ( ) { persistentdata . clear ( ) ; for ( int i = _num ; i < getnumpoints ( ) ; i ++ ) { persistentdata . add ( getpoint ( i ) ) ; } }	initializes persistent data . initializes dataset from persistent data .
public void essential ( final consumer < oncomplete > fn ) { this . essential = fn ; if ( done ) { fn . accept ( buildoncomplete ( ) ) ; } }	called at least once on complete.
public void addlistener ( imessagelistener newlistener ) { synchronized ( listeners ) { listeners . add ( newlistener ) ; } }	add a new listener.
public void testgettype ( ) { assertequals ( _str , tbt_crl . gettype ( ) , _str ) ; }	gettype ( ) method testing.
public void addwords ( string phrase ) { if ( phrase . equals ( _str ) || phrase . equals ( _str ) ) return ; string [ ] words = spliterator ( phrase ) ; if ( words . length < _num ) return ; for ( int i = _num ; i < words . length ; i ++ ) { if ( i == _num ) { vector < string > startwords = chain . get ( _str ) ; startwords . add ( words [ i ] ) ; vector < string > suffix = chain . get ( words [ i ] ) ; if ( suffix == null ) { suffix = new vector < > ( ) ; suffix . add ( words [ i + _num ] ) ; chain . put ( words [ i ] , suffix ) ; } } else if ( i == words . length - _num ) { vector < string > endwords = chain . get ( _str ) ; endwords . add ( words [ i ] ) ; } else { vector < string > suffix = chain . get ( words [ i ] ) ; if ( suffix == null ) { suffix = new vector < > ( ) ; suffix . add ( words [ i + _num ] ) ; chain . put ( words [ i ] , suffix ) ; } else { suffix . add ( words [ i + _num ] ) ; chain . put ( words [ i ] , suffix ) ; } } } }	add words from phrase to chain.
@ hleunimplemented @ hlefunction ( nid = _num , version = _num ) public int scenetadhocmatchingabortsenddata ( @ checkargument ( _str ) int matchingid , pspnetmacaddress macaddress ) { return _num ; }	abort a data send to a matching target.
public shortbuffer put ( short [ ] src , int srcoffset , int shortcount ) { arrays . checkoffsetandcount ( src . length , srcoffset , shortcount ) ; if ( shortcount > remaining ( ) ) { throw new bufferoverflowexception ( ) ; } for ( int i = srcoffset ; i < srcoffset + shortcount ; ++ i ) { put ( src [ i ] ) ; } return this ; }	writes shorts from the given short array , starting from the specified offset , to the current position and increases the position by the number of shorts written .
public boolean handledirectory ( file directory ) { if ( debug ) { logger . fine ( _str + directory . getabsolutepath ( ) ) ; } return _bool ; }	does nothing , nothing is done for directories .
public static void choose ( int n , int [ ] results ) { int k = results . length ; for ( int i = _num ; i < k ; i ++ ) { boolean done = _bool ; while ( ! done ) { results [ i ] = random . nextint ( n ) ; done = _bool ; for ( int j = _num ; j < i ; j ++ ) { if ( results [ j ] == results [ i ] ) { done = _bool ; } } } } }	choose random numbers from 0 to n - 1.
public string printleafmodelstiptext ( ) { return _str ; }	returns the tip text for this property.
public set registerclientinterestlist ( object inputclientid , list keys , boolean updatesasinvalidates ) { long clientid = getclientidformaps ( inputclientid ) ; set keysregistered = new hashset ( keys ) ; synchronized ( interestlistlock ) { map < object , set > koi = updatesasinvalidates ? getkeysofinterestinv ( ) : getkeysofinterest ( ) ; copyonwritehashset interestlist = ( copyonwritehashset ) koi . get ( clientid ) ; if ( interestlist == null ) { interestlist = new copyonwritehashset ( ) ; koi . put ( clientid , interestlist ) ; } else { keysregistered . removeall ( interestlist . getsnapshot ( ) ) ; } interestlist . addall ( keys ) ; if ( this . region != null && this . islocalprofile ) { sendprofileoperation ( clientid , operationtype . register_keys , keys , updatesasinvalidates ) ; } } return keysregistered ; }	registers interest in a set of keys for a client.
public static list < string > topathparts ( string encodedpath ) { if ( encodedpath == null || encodedpath . length ( ) == _num ) { return null ; } list < string > result = new arraylist < string > ( ) ; int cur = _num ; boolean notdone = _bool ; while ( notdone ) { int slash = encodedpath . indexof ( _str , cur ) ; notdone = slash != - _num ; string sub ; if ( notdone ) { sub = encodedpath . substring ( cur , slash ) ; } else { sub = encodedpath . substring ( cur ) ; } result . add ( charescapers . decodeuri ( sub ) ) ; cur = slash + _num ; } return result ; }	returns the decoded path parts for the given encoded path .
@ suppresswarnings ( _str ) public < t extends point2d > t inverse ( double x , double y , t ret_val ) { if ( ret_val == null ) { ret_val = ( t ) new latlonpoint . double ( ) ; } double px = x + ul . x ; double py = - y + ul . y + oy ; if ( px > projmath . roundadjust ( world . x / _num ) ) { px = projmath . roundadjust ( world . x / _num ) ; } else if ( px < projmath . roundadjust ( - world . x / _num ) ) { px = projmath . roundadjust ( - world . x / _num ) ; } if ( py > projmath . roundadjust ( world . y / _num ) ) { py = projmath . roundadjust ( world . y / _num ) ; } else if ( py < projmath . roundadjust ( - world . y / _num ) ) { py = projmath . roundadjust ( - world . y / _num ) ; } double lat_ = normalizelatitude ( py / spps_y ) ; double lon_ = wraplongitude ( ( px / spps_x ) + centerx ) ; ret_val . setlocation ( math . todegrees ( lon_ ) , math . todegrees ( lat_ ) ) ; return ret_val ; }	inverse project x , y coordinates into a latlonpoint . < p >.
public void install ( jeditorpane c ) { c . addcaretlistener ( inputattributeupdater ) ; c . addpropertychangelistener ( inputattributeupdater ) ; caret caret = c . getcaret ( ) ; if ( caret != null ) { inputattributeupdater . updateinputattributes ( caret . getdot ( ) , caret . getmark ( ) , c ) ; } }	called when the kit is being installed into a jeditorpane .
@ override public enumeration < option > listoptions ( ) { vector < option > result = new vector < option > ( ) ; enumeration < option > enm = super . listoptions ( ) ; while ( enm . hasmoreelements ( ) ) result . add ( enm . nextelement ( ) ) ; result . addelement ( new option ( _str + stopwordstiptext ( ) + _str + _str , _str , _num , _str ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
private void enableoperationbuttons ( ) { btnor . setenabled ( _bool ) ; btnand . setenabled ( _bool ) ; btnrightparen . setenabled ( _bool ) ; }	convenience method for enabling the buttons related to filter operations for filtering ( btnand , btnor , etc ).
private double computemodifierunbounded ( final double x ) { return expmultiplier * math . exp ( - x * x / expmember ) ; }	compute the value of the modifier.
@ override public boolean onunit ( graphics g , int x , int y , int w , int h ) { fontmetrics fm = g . getfontmetrics ( ) ; int l = ( int ) ( m_x * w ) - fm . stringwidth ( m_id ) / _num ; int t = ( int ) ( m_y * h ) - fm . getheight ( ) / _num ; if ( x < l || x > l + fm . stringwidth ( m_id ) + _num || y < t || y > t + fm . getheight ( ) + fm . getdescent ( ) + _num ) { return _bool ; } return _bool ; }	call this function to determine if the point at x , y is on the unit .
public static integer tointeger ( string str ) { try { return integer . valueof ( str ) ; } catch ( exception ex ) { return null ; } }	casts string to integer or returns null if value is not integer.
private static void fillwithemptyrows ( datatable data , int count ) { while ( data . getrowcount ( ) < count ) { double [ ] emptyrow = new double [ data . getcolumncount ( ) ] ; arrays . fill ( emptyrow , _num ) ; data . add ( emptyrow ) ; } }	utility method that fills a data table with empty rows .
public void testdivisionknuth1 ( ) { byte abytes [ ] = { - _num , - _num , - _num , - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { - _num , - _num , - _num , - _num } ; int asign = _num ; int bsign = _num ; byte rbytes [ ] = { _num , - _num , - _num , - _num , - _num , - _num , - _num , - _num , _num , _num , _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . divide ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	verifies the case when borrow ! = 0 in the private divide method .
public fragmentedhandshakemessage ( byte [ ] fragmentedbytes , handshaketype type , int fragmentoffset , int messagelength , inetsocketaddress peeraddress ) { super ( peeraddress ) ; this . type = type ; this . messagelength = messagelength ; this . fragmentedbytes = arrays . copyof ( fragmentedbytes , fragmentedbytes . length ) ; setfragmentoffset ( fragmentoffset ) ; setfragmentlength ( fragmentedbytes . length ) ; }	called when fragmenting a handshake message .
private static void deleteretrycounter ( weakreference < context > weakcontext , string filename , int maxretryattempts ) { context context = null ; if ( weakcontext != null ) { context = weakcontext . get ( ) ; if ( context != null ) { sharedpreferences preferences = context . getsharedpreferences ( artisan_sdk , context . mode_private ) ; sharedpreferences . editor editor = preferences . edit ( ) ; editor . remove ( _str + filename ) ; editor . apply ( ) ; } } }	delete the retry counter if stacktrace is uploaded or retry limit is reached .
private void initializesparseslider ( ) { connectiondensityslider . setmajortickspacing ( _num ) ; connectiondensityslider . setminortickspacing ( _num ) ; connectiondensityslider . setpaintticks ( _bool ) ; hashtable < integer , jlabel > labeltable2 = new hashtable < integer , jlabel > ( ) ; labeltable2 . put ( new integer ( _num ) , new jlabel ( _str ) ) ; labeltable2 . put ( new integer ( _num ) , new jlabel ( _str ) ) ; connectiondensityslider . setlabeltable ( labeltable2 ) ; connectiondensityslider . setpaintlabels ( _bool ) ; }	initializes the sparse slider .
protected void updatetree ( documentevent event ) { updatingselection = _bool ; try { treemodel model = gettreemodel ( ) ; object root = model . getroot ( ) ; for ( int counter = model . getchildcount ( root ) - _num ; counter >= _num ; counter -- ) { updatetree ( event , ( element ) model . getchild ( root , counter ) ) ; } } finally { updatingselection = _bool ; } }	updates the tree based on the event type.
private static shape bottomedge ( bufferedimage image , generalpath path , int start ) { int lastj = _num ; point2d p1 = path . getcurrentpoint ( ) ; point2d p2 = null ; line2d line = new line2d . float ( ) ; for ( int i = start ; i < image . getwidth ( ) ; i += sample ) { boolean apointexistsonthisline = _bool ; for ( int j = image . getheight ( ) - _num ; j >= _num ; j -= sample ) { if ( ( image . getrgb ( i , j ) & _num ) != _num ) { point2d p = new point2d . float ( i , j ) ; apointexistsonthisline = _bool ; p2 = detectline ( p1 , p2 , p , line , path ) ; lastj = j ; break ; } } if ( apointexistsonthisline == _bool ) { break ; } } return rightedge ( image , path , lastj ) ; }	trace the bottom of the image.
@ formurlencoded @ post ( _str ) call < authenticationresponse > authorize ( @ fieldmap map < string , string > authmap ) ;	asynchronously obtains an oauth token .
private boolean repeatingpreview ( object tag ) { try { capturerequest . builder builder = mdevice . createcapturerequest ( cameradevice . template_preview ) ; builder . addtarget ( mpreviewsurface ) ; builder . set ( capturerequest . control_mode , camerametadata . control_mode_auto ) ; addbaselinecapturekeystorequest ( builder ) ; mcapturesession . setrepeatingrequest ( builder . build ( ) , mcapturecallback , mcamerahandler ) ; log . v ( tag , string . format ( _str , mzoomvalue ) ) ; return _bool ; } catch ( cameraaccessexception ex ) { log . e ( tag , _str , ex ) ; return _bool ; } }	request preview capture stream with af_mode_continuous_picture .
private xmlelement newelement ( string name , string value , arraylist attributes ) throws exception { return newelement ( name , value , attributes , _bool ) ; }	factory method for creating a new element with the given name , given value and given attributes.
public void mousepressed ( mouseevent e ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str + ( e . getmodifiers ( ) & mouseevent . button1_mask ) + _str + e . ispopuptrigger ( ) + _str + ( e . getmodifiers ( ) & ( mouseevent . alt_mask + mouseevent . meta_mask + mouseevent . ctrl_mask ) ) + ( _str + mouseevent . alt_mask + _str + mouseevent . meta_mask + _str + mouseevent . ctrl_mask ) ) ; } if ( e . ispopuptrigger ( ) && parentframe . isselected ( ) ) { try { _menu . show ( e . getcomponent ( ) , e . getx ( ) , e . gety ( ) ) ; } catch ( java . awt . illegalcomponentstateexception cs ) { } e . consume ( ) ; } }	if the event is the popup trigger , which is dependent on the platform , present the popup menu.
public void definefillstyle ( color [ ] colors , int [ ] ratios , transform matrix , boolean radial ) { gradientfill fill = new gradientfill ( colors , ratios , matrix , radial ) ; elements . add ( fill ) ; for ( int i = _num ; i < colors . length ; i ++ ) { if ( colors [ i ] == null ) { continue ; } if ( colors [ i ] instanceof alphacolor ) { hasalpha = _bool ; } } }	define a gradient fill.
public boolean isorphan ( sha256hash block ) { lock . lock ( ) ; try { return orphanblocks . containskey ( block ) ; } finally { lock . unlock ( ) ; } }	returns true if the given block is currently in the orphan blocks list .
protected booleanval ( boolean b ) { this . b = b ; }	creates the boolean value ( protected , use the valuefactory to create it ).
public list < volume > validatevolumes ( storagesystem storagesystem , list < volume > volumes , boolean delete , boolean remediate , valck ... checks ) { try { client = vplexcontrollerutils . getvplexapiclient ( vplexapifactory . getinstance ( ) , storagesystem , getdbclient ( ) ) ; for ( volume volume : volumes ) { try { log . info ( string . format ( _str , volume . getlabel ( ) , volume . getnativeid ( ) , volume . getid ( ) , checks . tostring ( ) ) ) ; validatevolume ( volume , delete , remediate , checks ) ; } catch ( exception ex ) { log . error ( _str + volume . getid ( ) , ex ) ; } } } catch ( exception ex ) { log . error ( _str + storagesystem . getid ( ) , ex ) ; } return remediatedvolumes ; }	validates the given volumes .
private void drawxaxismarker ( canvas canvas , double value , numberformat numberformat , int spacing ) { string marker = chartbydistance ? numberformat . format ( value ) : stringutils . formatelapsedtime ( ( long ) value ) ; rect rect = getrect ( xaxismarkerpaint , marker ) ; canvas . drawtext ( marker , getx ( value ) , topborder + effectiveheight + spacing + rect . height ( ) , xaxismarkerpaint ) ; }	draws a x axis marker .
public static < e > arraylist < e > list ( e ... elements ) { arraylist < e > list = new arraylist < e > ( ) ; for ( e element : elements ) list . add ( element ) ; return list ; }	add elements to an arraylist .
public static string encode ( arraylist < geopoint > polyline , int precision ) { stringbuilder encodedpoints = new stringbuilder ( ) ; int prev_lat = _num , prev_lng = _num ; for ( geopoint trackpoint : polyline ) { int lat = trackpoint . getlatitudee6 ( ) / precision ; int lng = trackpoint . getlongitudee6 ( ) / precision ; encodedpoints . append ( encodesignednumber ( lat - prev_lat ) ) ; encodedpoints . append ( encodesignednumber ( lng - prev_lng ) ) ; prev_lat = lat ; prev_lng = lng ; } return encodedpoints . tostring ( ) ; }	encode a polyline with google polyline encoding method.
private static boolean istextobscured ( jcomponent c , string s ) { graphics g = c . getgraphics ( ) ; fontmetrics fm = g . getfontmetrics ( c . getfont ( ) ) ; int sw = fm . stringwidth ( s ) ; return ( sw > c . getwidth ( ) ) ; }	check if any label text is obscured .
public void add ( permission permission ) { perms . put ( permission , permission ) ; }	adds the argument to the collection .
public void testallconnectedbrokernetwork ( ) throws exception { bridgebrokers ( _str , _str ) ; bridgebrokers ( _str , _str ) ; bridgebrokers ( _str , _str ) ; bridgebrokers ( _str , _str ) ; bridgebrokers ( _str , _str ) ; bridgebrokers ( _str , _str ) ; startallbrokers ( ) ; destination dest = createdestination ( _str , _bool ) ; messageconsumer clienta = createconsumer ( _str , dest ) ; messageconsumer clientb = createconsumer ( _str , dest ) ; messageconsumer clientc = createconsumer ( _str , dest ) ; thread . sleep ( _num ) ; sendmessages ( _str , dest , message_count ) ; sendmessages ( _str , dest , message_count ) ; sendmessages ( _str , dest , message_count ) ; messageidlist msgsa = getconsumermessages ( _str , clienta ) ; messageidlist msgsb = getconsumermessages ( _str , clientb ) ; messageidlist msgsc = getconsumermessages ( _str , clientc ) ; msgsa . waitformessagestoarrive ( message_count * _num ) ; msgsb . waitformessagestoarrive ( message_count * _num ) ; msgsc . waitformessagestoarrive ( message_count * _num ) ; assertequals ( message_count * _num , msgsa . getmessagecount ( ) ) ; assertequals ( message_count * _num , msgsb . getmessagecount ( ) ) ; assertequals ( message_count * _num , msgsc . getmessagecount ( ) ) ; }	brokera < - > brokerb < - > brokerc.
private int encryptedcolumnlength ( int collength ) { string str = _str ; for ( int i = _num ; i < collength ; i ++ ) { str += _str ; } str = secureengine . encrypt ( str ) ; return str . length ( ) ; }	determines the length of the encrypted column .
private cnatreeelement unifylinks ( cnatreeelement sourceelement , cnatreeelement destinationelement ) throws commandexception { for ( cnalink linkdown : sourceelement . getlinksdown ( ) ) { createlink ( destinationelement , linkdown . getdependency ( ) , linkdown . getrelationid ( ) ) ; } for ( cnalink linkup : sourceelement . getlinksup ( ) ) { createlink ( linkup . getdependant ( ) , destinationelement , linkup . getrelationid ( ) ) ; } return destinationelement ; }	copies all links from the source element to the destination element .
private boolean flushaccumulatedregion ( ) { boolean success = _bool ; if ( accumulatedx != integer . max_value ) { subregionshowable bssubregion = ( subregionshowable ) bufferstrategy ; boolean contentslost = bufferstrategy . contentslost ( ) ; if ( ! contentslost ) { bssubregion . show ( accumulatedx , accumulatedy , accumulatedmaxx , accumulatedmaxy ) ; contentslost = bufferstrategy . contentslost ( ) ; } if ( contentslost ) { if ( logger . isloggable ( platformlogger . level . finer ) ) { logger . finer ( _str ) ; } bufferinfo . setinsync ( _bool ) ; success = _bool ; } } resetaccumulated ( ) ; return success ; }	renders the bufferstrategy to the screen .
public void testbitlengthpositive1 ( ) { byte abytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , _num , _num } ; int asign = _num ; biginteger anumber = new biginteger ( asign , abytes ) ; assertequals ( _num , anumber . bitlength ( ) ) ; }	bitlength ( ) of a positive number .
public void clearpiesegments ( ) { mpiesegmentlist . clear ( ) ; }	clears the pie segments list .
public static string randomalphanumerical ( final int len ) { final stringbuilder sb = new stringbuilder ( len ) ; for ( int i = _num ; i < len ; i ++ ) { sb . append ( ab . charat ( random . nextint ( ab . length ( ) ) ) ) ; } return sb . tostring ( ) ; }	generates a random alphanumerical string of the given length . the used characters are : < br > < br > 0123456789abcdefghijklmnopqrstuvwxyz.
static int svd_imax ( int a , int b ) { return math . max ( a , b ) ; }	returns the larger of two integers.
private boolean ismimeformat ( long format , string primarytype ) { string nat = getnativeforformat ( format ) ; if ( nat == null ) { return _bool ; } try { dataflavor df = new dataflavor ( nat ) ; if ( primarytype . equals ( df . getprimarytype ( ) ) ) { return _bool ; } } catch ( exception e ) { } return _bool ; }	returns true if and only if the name of the specified format atom constitutes a valid mime type with the specified primary type .
private static string convertrelevance ( int relevance ) { stringbuilder sb = new stringbuilder ( ) ; while ( relevance > _num ) { sb . insert ( _num , reverse_char_map [ relevance % _num ] ) ; relevance = relevance / _num ; } return sb . tostring ( ) ; }	converts the relevance to a sort text.
int extractversionfromfilename ( final file file ) { final matcher matcher = versionedpattern . matcher ( file . getabsolutepath ( ) ) ; matcher . find ( ) ; return integer . parseint ( matcher . group ( _num ) ) ; }	find the version number that ' s embedded in the name of this file.
static int measurechildforcells ( view child , int cellsize , int cellsremaining , int parentheightmeasurespec , int parentheightpadding ) { final layoutparams lp = ( layoutparams ) child . getlayoutparams ( ) ; final int childheightsize = measurespec . getsize ( parentheightmeasurespec ) - parentheightpadding ; final int childheightmode = measurespec . getmode ( parentheightmeasurespec ) ; final int childheightspec = measurespec . makemeasurespec ( childheightsize , childheightmode ) ; int cellsused = _num ; if ( cellsremaining > _num ) { final int childwidthspec = measurespec . makemeasurespec ( cellsize * cellsremaining , measurespec . at_most ) ; child . measure ( childwidthspec , childheightspec ) ; final int measuredwidth = child . getmeasuredwidth ( ) ; cellsused = measuredwidth / cellsize ; if ( measuredwidth % cellsize != _num ) cellsused ++ ; } final actionmenuitemview itemview = child instanceof actionmenuitemview ? ( actionmenuitemview ) child : null ; final boolean expandable = ! lp . isoverflowbutton && itemview != null && itemview . hastext ( ) ; lp . expandable = expandable ; lp . cellsused = cellsused ; final int targetwidth = cellsused * cellsize ; child . measure ( measurespec . makemeasurespec ( targetwidth , measurespec . exactly ) , childheightspec ) ; return cellsused ; }	measure a child view to fit within cell - based formatting.
private boolean isspecializedhandleravailable ( intent intent ) { packagemanager pm = mactivity . getpackagemanager ( ) ; list < resolveinfo > handlers = pm . queryintentactivities ( intent , packagemanager . get_resolved_filter ) ; if ( handlers == null || handlers . size ( ) == _num ) { return _bool ; } for ( resolveinfo resolveinfo : handlers ) { intentfilter filter = resolveinfo . filter ; if ( filter == null ) { continue ; } if ( filter . countdataauthorities ( ) == _num && filter . countdatapaths ( ) == _num ) { continue ; } return _bool ; } return _bool ; }	search for intent handlers that are specific to this url aka , specialized apps like google maps or youtube.
private void converterror ( charbuffer buf , int line ) { string srcfilename = null ; int destline = _num ; int srcline = _num ; int srctailline = integer . max_value ; for ( int i = _num ; i < _lines . size ( ) ; i ++ ) { line map = ( line ) _lines . get ( i ) ; if ( map . _dstline <= line && line <= map . getlastdestinationline ( ) ) { srcfilename = map . _srcfilename ; destline = map . _dstline ; srcline = map . getsourceline ( line ) ; break ; } } if ( srcfilename != null ) { } else if ( _lines . size ( ) > _num ) srcfilename = ( ( line ) _lines . get ( _num ) ) . _srcfilename ; else srcfilename = _str ; buf . append ( srcfilename ) ; if ( line >= _num ) { buf . append ( _str ) ; buf . append ( srcline + ( line - destline ) ) ; } }	maps a destination line to an error location .
public static string slurpgburlnoexceptions ( url u ) { try { return slurpgburl ( u ) ; } catch ( exception e ) { e . printstacktrace ( ) ; return null ; } }	returns all the text at the given url .
public void undo ( ) { if ( ! undostack . isempty ( ) ) { undoableaction lastevent = undostack . pop ( ) ; lastevent . undo ( ) ; redostack . push ( lastevent ) ; } }	undo the last undoable action .
public pair < solrcore , solrcore > replicatetodestination ( solrcore bestsrccore , solrcore destinationcore ) throws exception { pair < solrcore , solrcore > replicationrequestpair = null ; try { solrinteractionutils . replicateindex ( destinationcore . host , destinationcore . name , bestsrccore . host , bestsrccore . name ) ; string fullreplication = _str ; string replicator = string . format ( fullreplication , destinationcore . host , solrinteractionutils . default_solr_port , destinationcore . name , bestsrccore . host , solrinteractionutils . default_solr_port , bestsrccore . name ) ; logger . info ( _str + replicator ) ; replicationrequestpair = new pair < solrcore , solrcore > ( destinationcore , bestsrccore ) ; logger . info ( _str + destinationcore . host + _str + destinationcore . name + _str + bestsrccore . host + _str + bestsrccore . name ) ; } catch ( exception e ) { logger . info ( _str + destinationcore . host + _str + bestsrccore . host ) ; if ( ! replicatorconfig . shouldskipreplicationfailures ( ) ) { throw new replicationfailureexception ( _str + destinationcore . host + _str + bestsrccore . host ) ; } } return replicationrequestpair ; }	given source and destionation cores , issue the solr replication command between them.
public static ostype calculateos ( ) { string osname = system . getproperty ( _str ) ; osname = osname . tolowercase ( locale . english ) ; if ( osname . startswith ( _str ) ) { return ostype . apple ; } if ( osname . startswith ( _str ) ) { return ostype . windows ; } if ( osname . startswith ( _str ) ) { return ostype . linux ; } if ( osname . startswith ( _str ) ) { return ostype . sun ; } return ostype . unknown ; }	calculates the current ostype.
private static int countduplicates ( stacktraceelement [ ] currentstack , stacktraceelement [ ] parentstack ) { int duplicates = _num ; int parentindex = parentstack . length ; for ( int i = currentstack . length ; -- i >= _num && -- parentindex >= _num ; ) { stacktraceelement parentframe = parentstack [ parentindex ] ; if ( parentframe . equals ( currentstack [ i ] ) ) { duplicates ++ ; } else { break ; } } return duplicates ; }	count the number of duplicate stack frames , starting from the end of the stack .
public void recycle ( ) { synchronized ( spool ) { if ( spool . size ( ) < max_pool_size ) { spool . add ( this ) ; } } }	do not call this unless you obtained this via expandablelistposition.
public final boolean exists ( ) { return config != null ; }	checks whether the configuration is loaded correctly .
@ override public synchronized void removetestsetlistener ( testsetlistener tsl ) { m_testlisteners . removeelement ( tsl ) ; }	remove a test set listener.
private boolean has_colinear ( arraylist < plapointint > corners_list , plapointint a_point ) { int count = corners_list . size ( ) ; if ( count < _num ) return _bool ; for ( int index = _num ; index < count - _num ; index ++ ) { plapointint start = corners_list . get ( index ) ; plapointint end = corners_list . get ( index + _num ) ; if ( a_point . side_of ( start , end ) != plaside . collinear ) continue ; double d_start_p = start . distance_square ( a_point ) ; double d_p_end = a_point . distance_square ( end ) ; double d_start_end = start . distance_square ( end ) ; if ( d_start_end >= d_start_p ) { if ( d_start_end >= d_p_end ) { return _bool ; } else { corners_list . set ( index , a_point ) ; return _bool ; } } else { if ( d_start_end >= d_p_end ) { corners_list . set ( index + _num , a_point ) ; return _bool ; } else { corners_list . set ( index , a_point ) ; return _bool ; } } } return _bool ; }	thest if the given point is somewhat colinear and should not be inserted note it is quite possible that the given point replaces a point already in the list.
public boolean contains ( string key ) { return myproperties . containskey ( key ) ; }	returns true if the store contains a value for the given key .
protected snmpcacheddata updatecacheddatas ( object userdata ) { final string [ ] path = jvmruntimeimpl . getlibrarypath ( userdata ) ; final long time = system . currenttimemillis ( ) ; final int len = path . length ; snmpoid indexes [ ] = new snmpoid [ len ] ; for ( int i = _num ; i < len ; i ++ ) { indexes [ i ] = new snmpoid ( i + _num ) ; } return new snmpcacheddata ( time , indexes , path ) ; }	return a table handler containing the thread indexes.
public static byte [ ] decodehex ( string hexstring ) { int length = hexstring . length ( ) ; if ( ( length & _num ) != _num ) { throw new illegalargumentexception ( _str ) ; } boolean badhex = _bool ; byte [ ] out = new byte [ length > > _num ] ; for ( int i = _num , j = _num ; j < length ; i ++ ) { int c1 = hexstring . charat ( j ++ ) ; if ( c1 > _str ) { badhex = _bool ; break ; } final byte d1 = digits [ c1 ] ; if ( d1 == - _num ) { badhex = _bool ; break ; } int c2 = hexstring . charat ( j ++ ) ; if ( c2 > _str ) { badhex = _bool ; break ; } final byte d2 = digits [ c2 ] ; if ( d2 == - _num ) { badhex = _bool ; break ; } out [ i ] = ( byte ) ( d1 << _num | d2 ) ; } if ( badhex ) { throw new illegalargumentexception ( _str + hexstring ) ; } return out ; }	quickly converts a hexadecimal string to a byte array .
public static void deleteplayer ( playeraccountdata accdata ) { if ( accdata . getdeletiondate ( ) != null ) { return ; } accdata . setdeletiondate ( new timestamp ( system . currenttimemillis ( ) + _num * _num * _num ) ) ; storedeletiontime ( accdata ) ; }	starts player deletion process if its possible.
public void testbuffered ( ) { instances icopy = new instances ( m_instances ) ; instances result = null ; try { m_filter . setinputformat ( icopy ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; fail ( _str + ex . getmessage ( ) ) ; } try { result = filter . usefilter ( icopy , m_filter ) ; assertnotnull ( result ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; fail ( _str + ex . getmessage ( ) ) ; } stringwriter sw = new stringwriter ( _num ) ; sw . write ( result . tostring ( ) ) ; asserttrue ( icopy . equalheaders ( m_instances ) ) ; assertequals ( icopy . numinstances ( ) , m_instances . numinstances ( ) ) ; instances result2 = null ; try { m_filter . setinputformat ( icopy ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; fail ( _str + ex . getmessage ( ) ) ; } try { result2 = filter . usefilter ( icopy , m_filter ) ; assertnotnull ( result2 ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; fail ( _str + ex . getmessage ( ) ) ; } asserttrue ( icopy . equalheaders ( m_instances ) ) ; assertequals ( icopy . numinstances ( ) , m_instances . numinstances ( ) ) ; asserttrue ( result . equalheaders ( result2 ) ) ; assertequals ( result . numinstances ( ) , result2 . numinstances ( ) ) ; }	test buffered operation . output instances are only collected after all instances are passed through.
private string parsecss ( final string css ) { final map < string , string > map = new hashmap < string , string > ( ) ; final stringbuffer sb = new stringbuffer ( ) ; final matcher m = pattern_variables_definition . matcher ( css ) ; while ( m . find ( ) ) { final string variablesbody = m . group ( _num ) ; map . putall ( extractvariables ( variablesbody ) ) ; m . appendreplacement ( sb , _str ) ; } m . appendtail ( sb ) ; return replacevariables ( sb . tostring ( ) , map ) ; }	parse css , find all defined variables & replace them .
private void shutdown ( ) { if ( execsvc != null ) execsvc . shutdown ( _num ) ; if ( msgexecsvc != null ) msgexecsvc . shutdownnow ( ) ; try { job . dispose ( _bool ) ; } catch ( ignitecheckedexception e ) { u . error ( log , _str , e ) ; } }	stops all executors and running tasks .
public void startcdata ( ) throws org . xml . sax . saxexception { m_incdata = _bool ; append ( m_doc . createcdatasection ( _str ) ) ; }	report the start of a cdata section .
public void addall ( list < fragment > asplits ) { splits . addall ( asplits ) ; }	adds a list of split elements .
protected synchronized int currentchunkoffset ( ) throws ioexception { long fp = backingrandomaccessfile . getfilepointer ( ) ; if ( fp < fheader . headersize ( ) ) { return - _num ; } else { fp -= fheader . headersize ( ) ; if ( fp == _num ) { return _num ; } else { return ( int ) ( ( fp % chunk_enc_size ) - chunk_iv_size ) ; } } }	indicates to which data offset within the current chunk the file pointer currently points.
protected int decodelineprefix ( pushbackinputstream astream , outputstream bstream ) throws ioexception { return ( bytesperline ( ) ) ; }	103 * this method should return , if it knows , the number of bytes 104 that will be decoded.
private static lookuplocator [ ] unmarshallocators ( objectinputstream in ) throws ioexception , classnotfoundexception { list l = new arraylist ( ) ; marshalledinstance mi ; while ( ( mi = ( marshalledinstance ) in . readobject ( ) ) != null ) { try { l . add ( ( lookuplocator ) mi . get ( _bool ) ) ; } catch ( throwable e ) { if ( e instanceof error && throwableconstants . retryable ( e ) == throwableconstants . bad_object ) { throw ( error ) e ; } logger . log ( level . warning , _str , e ) ; } } return ( lookuplocator [ ] ) l . toarray ( new lookuplocator [ l . size ( ) ] ) ; }	returns locators unmarshalled from a null - terminated list of marshalledinstances read from the given stream , logging ( but tolerating ) unmarshalling failures .
static public string numbertostring ( number n ) throws jsonexception { if ( n == null ) { throw new jsonexception ( _str ) ; } testvalidity ( n ) ; string s = n . tostring ( ) ; if ( s . indexof ( _str ) > _num && s . indexof ( _str ) < _num && s . indexof ( _str ) < _num ) { while ( s . endswith ( _str ) ) { s = s . substring ( _num , s . length ( ) - _num ) ; } if ( s . endswith ( _str ) ) { s = s . substring ( _num , s . length ( ) - _num ) ; } } return s ; }	produce a string from a number .
public int children ( ) { return children . size ( ) ; }	returns the number of child layers in this group .
public void createvvset ( string displayname ) throws exception { _log . info ( _str ) ; clientresponse clientresp = null ; string payload = _str + displayname + _str ; _log . info ( _str , uri_create_cg . tostring ( ) , payload ) ; try { clientresp = post ( uri_create_cg , payload ) ; if ( clientresp == null ) { _log . error ( _str ) ; throw new hp3parexception ( _str ) ; } else if ( clientresp . getstatus ( ) != _num ) { string errresp = getresponsedetails ( clientresp ) ; _log . error ( _str , errresp ) ; throw new hp3parexception ( errresp ) ; } else { _log . info ( _str ) ; } } catch ( exception e ) { throw e ; } finally { if ( clientresp != null ) { clientresp . close ( ) ; } _log . info ( _str ) ; } }	vv set is a hp3par term for consistency group . this deals with creation of cg , volumes will be added to the cg in create volume.
protected void connectionfailed ( channel failedchannel , ioexception cause ) { failurecause = ioexceptionsupport . create ( cause ) ; channel = failedchannel ; connected . set ( _bool ) ; handshakefuture . setfailure ( cause ) ; }	called when the transport connection failed and an error should be returned .
public void addattribute ( string uri , string localname , string rawname , string type , string value , boolean xslattribute ) throws saxexception { if ( m_elemcontext . m_starttagopen ) { ensureprefixisdeclared ( uri , rawname ) ; addattributealways ( uri , localname , rawname , type , value , _bool ) ; } }	adds the given attribute to the set of attributes , and also makes sure that the needed prefix / uri mapping is declared , but only if there is a currently open element .
private string markdownblockquote ( string value ) { return _str + value . replace ( _str , _str ) ; }	blockquotes a string in markdown format .
protected string hash ( string key ) { try { messagedigest gen = hash_generator . get ( ) ; byte [ ] keybytes = key . getbytes ( _str ) ; gen . update ( keybytes , _num , keybytes . length ) ; byte [ ] binaryhash = gen . digest ( ) ; return encoder . encodetostring ( binaryhash ) ; } catch ( exception e ) { log . warn ( _str , key , e ) ; } return null ; }	get the hash encoding of a key string .
public static boolean isinputtype ( string typestring ) { return input_types . contains ( typestring ) ; }	checks if a given type is a known input type .
public static point destination ( point point1 , double distance , double bearing , string units ) throws turfexception { double degrees2radians = math . pi / _num ; double radians2degrees = _num / math . pi ; position coordinates1 = point1 . getcoordinates ( ) ; double longitude1 = degrees2radians * coordinates1 . getlongitude ( ) ; double latitude1 = degrees2radians * coordinates1 . getlatitude ( ) ; double bearingrad = degrees2radians * bearing ; double radians = turfhelpers . distancetoradians ( distance , units ) ; double latitude2 = math . asin ( math . sin ( latitude1 ) * math . cos ( radians ) + math . cos ( latitude1 ) * math . sin ( radians ) * math . cos ( bearingrad ) ) ; double longitude2 = longitude1 + math . atan2 ( math . sin ( bearingrad ) * math . sin ( radians ) * math . cos ( latitude1 ) , math . cos ( radians ) - math . sin ( latitude1 ) * math . sin ( latitude2 ) ) ; return point . fromcoordinates ( position . fromcoordinates ( radians2degrees * longitude2 , radians2degrees * latitude2 ) ) ; }	takes a point and calculates the location of a destination point given a distance in degrees , radians , miles , or kilometers ; and bearing in degrees.
public void clear ( ) { synchronized ( mlock ) { mgraphics . clear ( ) ; mfirstgraphic = null ; } postinvalidate ( ) ; }	removes all graphics from the overlay .
@ suppresswarnings ( _str ) public nodepanel ( shadernodevariable singleout , nodepanel . nodetype type ) { super ( ) ; list < shadernodevariable > outputs = new arraylist < shadernodevariable > ( ) ; outputs . add ( singleout ) ; this . type = type ; init ( new arraylist < shadernodevariable > ( ) , outputs ) ; addkeylistener ( this ) ; toolbar = new nodetoolbar ( this ) ; }	creates new form nodepanel.
public static string stringifyexception ( throwable e ) { stringwriter stm = new stringwriter ( ) ; printwriter wrt = new printwriter ( stm ) ; e . printstacktrace ( wrt ) ; wrt . close ( ) ; return stm . tostring ( ) ; }	make a string representation of the exception .
private heronreefutils ( ) { }	this is a utility class and should not be instantiated .
public static boolean issolaris ( ) { return ( os . indexof ( _str ) >= _num ) ; }	checks if is solaris .
public double suminlinkhubscore ( page page ) { list < string > inlinks = page . getinlinks ( ) ; double hubscore = _num ; for ( int i = _num ; i < inlinks . size ( ) ; i ++ ) { page inlink = ptable . get ( inlinks . get ( i ) ) ; if ( inlink != null ) { hubscore += inlink . hub ; } else { continue ; } } return hubscore ; }	calculate the authority score of a page by summing the hub scores of that page ' s inlinks .
public shortbandedraster ( samplemodel samplemodel , databuffer databuffer , point origin ) { this ( samplemodel , databuffer , new rectangle ( origin . x , origin . y , samplemodel . getwidth ( ) , samplemodel . getheight ( ) ) , origin , null ) ; }	constructs a shortbandedraster with the given samplemodel and databuffer.
public void remapmappedtypes ( ) { clearmappedtypes ( ) ; mappossibletypes ( mitems ) ; }	forces to remap all possible types for the recyclerview.
public void initialize ( ) throws executionexception { }	this method has to be implemented and cannot throw any exception .
public int numchildren ( int row ) { int count = _num ; nextvalidrowpositions . clear ( ) ; for ( int i = _num ; i < n ; i ++ ) { board [ row ] [ i ] = _bool ; if ( valid ( row , i ) ) { count ++ ; nextvalidrowpositions . add ( i ) ; } board [ row ] [ i ] = _bool ; } return count ; }	find out how many valid children states are found by trying to add a queen to the given row.
public void testnegnegsamelength ( ) { string numa = _str ; string numb = _str ; string res = _str ; biginteger anumber = new biginteger ( numa ) ; biginteger bnumber = new biginteger ( numb ) ; biginteger result = anumber . xor ( bnumber ) ; asserttrue ( res . equals ( result . tostring ( ) ) ) ; }	xor for two negative numbers of the same length.
public static ijavasearchscope createrelatedprojectsscope ( ijavaproject project , int includemask ) throws coreexception { ijavaproject [ ] projects = getrelatedprojects ( project ) ; return searchengine . createjavasearchscope ( projects , includemask ) ; }	creates a new search scope containing all projects which reference or are referenced by the specified project .
public confirmation ( ) { this ( null , null ) ; }	creates bearer type confirmation .
public vcsrevisionnumber originalrevision ( int linenumber ) { return getlinerevisionnumber ( linenumber ) ; }	get revision number for the line .
private void checkpausedorcanceled ( state state ) throws stoprequest { if ( mservice . getcontrol ( ) == downloaderservice . control_paused ) { int status = mservice . getstatus ( ) ; switch ( status ) { case downloaderservice . status_paused_by_app : throw new stoprequest ( mservice . getstatus ( ) , _str ) ; } } }	check if the download has been paused or canceled , stopping the request appropriately if it has been .
void trace ( ) { gluseprogram ( computeprogram ) ; invprojmatrix . transformproject ( tmpvector . set ( - _num , - _num , _num ) ) ; gluniform3f ( ray00uniform , tmpvector . x , tmpvector . y , tmpvector . z ) ; invprojmatrix . transformproject ( tmpvector . set ( - _num , _num , _num ) ) ; gluniform3f ( ray01uniform , tmpvector . x , tmpvector . y , tmpvector . z ) ; invprojmatrix . transformproject ( tmpvector . set ( _num , - _num , _num ) ) ; gluniform3f ( ray10uniform , tmpvector . x , tmpvector . y , tmpvector . z ) ; invprojmatrix . transformproject ( tmpvector . set ( _num , _num , _num ) ) ; gluniform3f ( ray11uniform , tmpvector . x , tmpvector . y , tmpvector . z ) ; glbindbufferbase ( gl_shader_storage_buffer , trianglesssbobinding , ssbo ) ; glbindimagetexture ( framebufferimagebinding , raytracetexture , _num , _bool , _num , gl_write_only , gl_rgba8 ) ; int worksizex = mathroundpot ( width ) ; int worksizey = mathroundpot ( height ) ; gldispatchcompute ( worksizex / workgroupsizex , worksizey / workgroupsizey , _num ) ; glmemorybarrier ( gl_shader_image_access_barrier_bit ) ; glbindimagetexture ( framebufferimagebinding , _num , _num , _bool , _num , gl_write_only , gl_rgba8 ) ; glbindbufferbase ( gl_shader_storage_buffer , trianglesssbobinding , _num ) ; gluseprogram ( _num ) ; }	compute one frame by tracing the scene using our compute shader .
public void removeallactionfirelisteners ( ) { mactionfiredlisteners . clear ( ) ; }	remove all listeners for action fired events .
public static string millistostring ( long millis ) { boolean negative = millis < _num ; millis = math . abs ( millis ) ; millis /= _num ; int sec = ( int ) ( millis % _num ) ; millis /= _num ; int min = ( int ) ( millis % _num ) ; millis /= _num ; int hours = ( int ) millis ; string time ; decimalformat format = ( decimalformat ) numberformat . getinstance ( locale . us ) ; format . applypattern ( _str ) ; if ( millis > _num ) { time = ( negative ? _str : _str ) + hours + _str + format . format ( min ) + _str + format . format ( sec ) ; } else { time = ( negative ? _str : _str ) + min + _str + format . format ( sec ) ; } return time ; }	convert time to a string.
@ inline public static void toutf8 ( string s , bytebuffer b ) { int result_index = _num ; for ( int i = _num , n = s . length ( ) ; i < n ; ++ i ) { char c = s . charat ( i ) ; if ( ( ( ! write_pseudo_utf8 ) || ( c >= _num ) ) && ( c <= _num ) ) { b . put ( ( byte ) c ) ; } else if ( c > _num ) { b . put ( ( byte ) ( _num | ( byte ) ( c > > _num ) ) ) ; b . put ( ( byte ) ( _num | ( ( c & _num ) > > _num ) ) ) ; b . put ( ( byte ) ( _num | ( c & _num ) ) ) ; } else { b . put ( ( byte ) ( _num | ( byte ) ( c > > _num ) ) ) ; b . put ( ( byte ) ( _num | ( c & _num ) ) ) ; } } }	convert the given string into a sequence of ( pseudo - ) utf8 formatted bytes.
public copyonwritearraylist ( e [ ] tocopyin ) { setarray ( arrays . copyof ( tocopyin , tocopyin . length , object [ ] . class ) ) ; }	creates a list holding a copy of the given array .
@ override public stringbuffer format ( long number , stringbuffer toappendto , fieldposition pos ) { return toappendto . append ( getdirectioncode ( number ) ) ; }	formats a number into the specified string buffer .
public static void main ( string [ ] args ) throws exception { digestcommandlinearguments ( args ) ; boolean inheadlessmode = graphicsenvironment . isheadless ( ) ; boolean inconvertmode = isinconvertmode ( ) ; scxmlgrapheditor editor = starteditor ( inconvertmode || inheadlessmode ) ; if ( isinconvertmode ( ) ) { scxmleditoractions . convertnogui ( editor ) ; } else if ( ! inheadlessmode ) { string input = getpresetinput ( ) ; if ( ! stringutils . isemptystring ( input ) ) { openaction open = new openaction ( new file ( input ) ) ; open . actionperformed ( new actionevent ( editor , _num , _str ) ) ; } } }	main of the editor application . creates the fsmeditor that is a customgraphcomponent ( jscrollpane ) contains an instance of customgraph ( mxgraph that is mxeventsource ) ) create the interface containing the customgraphcomponent : fsmeditor ( fsmgrapheditor ( jpanel ) ).
public void testequalsunequal2 ( ) { string a = _str ; int ascale = - _num ; string b = _str ; int bscale = _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; assertfalse ( anumber . equals ( bnumber ) ) ; }	equals ( ) for unequal bigdecimals.
protected void enableretransmissiontimer ( int tickcount ) { if ( isinvitetransaction ( ) && ( this instanceof sipclienttransaction ) ) { retransmissiontimerticksleft = tickcount ; } else { retransmissiontimerticksleft = math . min ( tickcount , gettimert2 ( ) ) ; } retransmissiontimerlasttickcount = retransmissiontimerticksleft ; }	enables retransmission timer events for this transaction to begin after the number of ticks passed to this routine .
private void schedulemsgforallconsumers ( jetstreammessage msg ) { if ( logger . isdebugenabled ( ) ) logger . debug ( _str + msg . tostring ( ) ) ; eventconsumerinfo info = null ; arraylist < linkedlist < selection > > weightedlist = m_eventtopicregistry . get ( msg . gettopic ( ) ) ; if ( weightedlist != null ) { iterator < linkedlist < selection > > weighteditr = weightedlist . iterator ( ) ; while ( weighteditr . hasnext ( ) ) { linkedlist < selection > consumerlist = weighteditr . next ( ) ; iterator < selection > itr = consumerlist . iterator ( ) ; while ( itr . hasnext ( ) ) { info = ( eventconsumerinfo ) itr . next ( ) ; if ( info == null ) continue ; dispatch ( info , msg ) ; } } } else { if ( m_advisorylistener != null ) { postresendadvisory ( msg ) ; m_noconsumeradvisories . increment ( ) ; } else { m_totalmsgsdropped . increment ( ) ; m_dropsfornoconsumer . increment ( ) ; } } }	spraytoallconsumers - this method is called when the message is tagged for spraying to all consumers .
@ override public void visitdeclared ( annotateddeclaredtype declaredtype , void avoid ) { if ( pause ) { return null ; } parents . push ( declaredtype ) ; super . visitdeclared ( declaredtype , avoid ) ; parents . pop ( ) ; return null ; }	sometimes the underlying type parameters of annotatedwildcardtypes are not available on the wildcards themselves.
public class create ( ) { setusecache ( _bool ) ; return ( class ) super . create ( this ) ; }	create an interface using the current set of method signatures .
public static < t > list < t > tuple ( t ... objects ) { return collections . unmodifiablelist ( list ( objects ) ) ; }	like py . list ( ) , but returns an immutable sequence . < p > named after the same concept in python , which in turn was named after the pre - existing mathematical concept of a " tuple ".
protected static set stringarraytoset ( string [ ] strs ) { int count = strs . length ; set set = ( ( count > _num ) ? new hashset ( count ) : new hashset ( ) ) ; for ( int i = _num ; i < count ; i ++ ) { set . add ( strs [ i ] ) ; } return set ; }	method to convert a string array to a set.
public boolean authenticate ( final oddcallback < authtoken > callback ) { synchronized ( synclock ) { if ( isexpired ( ) ) { return _bool ; } if ( ! authenticating ) { authenticating = _bool ; timer = new timer ( ) ; timertask task = getpolltask ( callback ) ; timer . schedule ( task , new date ( ) , interval ) ; timertask expiredtask = getexpiredtask ( callback ) ; timer . schedule ( expiredtask , expirationdate ) ; } return _bool ; } }	if not expired then this will continue polling the server until time expires or an auth token is obtained callback.
public static void cancelnotificationsforroomid ( string accountid , string roomid ) { log . d ( log_tag , _str + accountid + _str + roomid ) ; if ( null != mactiveeventstreamservice ) { mactiveeventstreamservice . cancelnotifications ( accountid , roomid ) ; } }	cancel the push notifications for a dedicated roomid.
public static optional < playerprofile > lookup ( uuid id ) { if ( bukkit . getplayer ( id ) != null ) { return optional . of ( fromplayer ( bukkit . getplayer ( id ) ) ) ; } return lookupproperties ( id ) ; }	lookup a profile with the given uuid the reuturned player profile may or may not include properties.
static double svd_dmin ( double a , double b ) { return math . min ( a , b ) ; }	returns the smaller of two double precision numbers.
private storageport selectstorageport ( list < storageport > splist ) { collections . shuffle ( splist ) ; return splist . get ( _num ) ; }	select a storage port from a list of all ports in transport zone and its subset of ports already used for export . todo : - select ports based on load - select ports based on multipath requirement - select ports based on fault domains.
private void assimilatecontext ( nestingexception nestingexception ) { enumeration < exceptioncontext > enumexeptions = nestingexception . getexceptioncontexts ( ) ; if ( enumexeptions . hasmoreelements ( ) ) { while ( enumexeptions . hasmoreelements ( ) ) { addexceptioncontext ( enumexeptions . nextelement ( ) ) ; } nestingexception . clearcontexts ( ) ; } }	any outstanding context from the exception provided will be added to this exception.
public boolean equals ( object o ) { if ( o instanceof amidentitysubject ) { amidentitysubject subject = ( amidentitysubject ) o ; return ( subjectvalues . equals ( subject . subjectvalues ) ) ; } return ( _bool ) ; }	indicates whether some other object is " equal to " this one .
public void updatekeyinfo ( string realm , string entityname , map < string , set < string > > extvalues , map < string , set < string > > stdvalues , boolean isidp ) throws amconsoleexception { string keysize = getresult ( stdvalues , tf_key_name ) ; string algorithm = getresult ( stdvalues , tf_algorithm ) ; set < string > signingcertaliases ; set < string > encryptioncertaliases ; if ( isidp ) { encryptioncertaliases = extvalues . get ( idp_encrypt_cert_alias ) ; signingcertaliases = extvalues . get ( idp_sign_cert_alias ) ; } else { encryptioncertaliases = extvalues . get ( sp_encrypt_cert_alias ) ; signingcertaliases = extvalues . get ( sp_sign_cert_alias ) ; } int keysi = ! stringutils . isempty ( keysize ) ? integer . parseint ( keysize ) : _num ; string alg = stringutils . isempty ( algorithm ) ? xmlcipher . aes_128 : algorithm ; try { saml2metasecurityutils . updateproviderkeyinfo ( realm , entityname , signingcertaliases , _bool , isidp , alg , keysi ) ; saml2metasecurityutils . updateproviderkeyinfo ( realm , entityname , encryptioncertaliases , _bool , isidp , alg , keysi ) ; } catch ( saml2metaexception e ) { debug . warning ( _str , e ) ; throw new amconsoleexception ( geterrorstring ( e ) ) ; } }	saves the signing and encryption values for the entity .
public void updateslider ( final double p , final boolean n ) { checkwidget ( ) ; double percentage = p ; if ( step != null ) { percentage = math . round ( percentage / step ) * step ; } this . notify = n ; if ( percentage < _num ) { percentage = _num ; } else if ( percentage > _num ) { percentage = _num ; } final int usefulwidth = getclientarea ( ) . width - thumbwidth ; final int width = ( int ) math . round ( usefulwidth * percentage ) ; movethumbhorizontally ( width ) ; previousposition = percentage ; this . notify = _bool ; }	method to update current position of the slider.
@ override public boolean contains ( string identifier ) { return whitelist . contains ( identifier ) ; }	checks if an identifier is contained in this strategy .
public static final action [ ] augmentlist ( action [ ] list1 , action [ ] list2 ) { hashtable < string , action > h = new hashtable < string , action > ( ) ; for ( action a : list1 ) { string value = ( string ) a . getvalue ( action . name ) ; h . put ( ( value != null ? value : _str ) , a ) ; } for ( action a : list2 ) { string value = ( string ) a . getvalue ( action . name ) ; h . put ( ( value != null ? value : _str ) , a ) ; } action [ ] actions = new action [ h . size ( ) ] ; int index = _num ; for ( enumeration e = h . elements ( ) ; e . hasmoreelements ( ) ; ) { actions [ index ++ ] = ( action ) e . nextelement ( ) ; } return actions ; }	takes one list of commands and augments it with another list of commands.
public mvmap < k , v > openversion ( long version ) { if ( readonly ) { throw datautils . newunsupportedoperationexception ( _str + _str ) ; } datautils . checkargument ( version >= createversion , _str , version , createversion ) ; page newest = null ; page r = root ; if ( version >= r . getversion ( ) && ( version == writeversion || r . getversion ( ) >= _num || version <= createversion || store . getfilestore ( ) == null ) ) { newest = r ; } else { page last = oldroots . peekfirst ( ) ; if ( last == null || version < last . getversion ( ) ) { return store . openmapversion ( version , id , this ) ; } iterator < page > it = oldroots . iterator ( ) ; while ( it . hasnext ( ) ) { page p = it . next ( ) ; if ( p . getversion ( ) > version ) { break ; } last = p ; } newest = last ; } mvmap < k , v > m = openreadonly ( ) ; m . root = newest ; return m ; }	open an old version for the given map .
public dtmdefaultbase ( dtmmanager mgr , source source , int dtmidentity , dtmwsfilter whitespacefilter , xmlstringfactory xstringfactory , boolean doindexing , int blocksize , boolean useprevsib , boolean newnametable ) { int numblocks ; if ( blocksize <= _num ) { numblocks = default_numblocks_small ; m_dtmident = new suballocatedintvector ( _num , _num ) ; } else { numblocks = default_numblocks ; m_dtmident = new suballocatedintvector ( _num ) ; } m_exptype = new suballocatedintvector ( blocksize , numblocks ) ; m_firstch = new suballocatedintvector ( blocksize , numblocks ) ; m_nextsib = new suballocatedintvector ( blocksize , numblocks ) ; m_parent = new suballocatedintvector ( blocksize , numblocks ) ; if ( useprevsib ) m_prevsib = new suballocatedintvector ( blocksize , numblocks ) ; m_mgr = mgr ; if ( mgr instanceof dtmmanagerdefault ) m_mgrdefault = ( dtmmanagerdefault ) mgr ; m_documentbaseuri = ( null != source ) ? source . getsystemid ( ) : null ; m_dtmident . setelementat ( dtmidentity , _num ) ; m_wsfilter = whitespacefilter ; m_xstrf = xstringfactory ; m_indexing = doindexing ; if ( doindexing ) { m_expandednametable = new expandednametable ( ) ; } else { m_expandednametable = m_mgrdefault . getexpandednametable ( this ) ; } if ( null != whitespacefilter ) { m_shouldstripwhitespacestack = new boolstack ( ) ; pushshouldstripwhitespace ( _bool ) ; } }	construct a dtmdefaultbase object from a dom node .
private boolean lessthanorequal ( byte [ ] a , byte [ ] b ) { int len = math . min ( a . length , b . length ) ; for ( int i = _num ; i != len ; ++ i ) { if ( a [ i ] != b [ i ] ) { return ( a [ i ] & _num ) < ( b [ i ] & _num ) ; } } return len == a . length ; }	return true if a < = b ( arrays are assumed padded with zeros ) .
protected void clear ( ) { parts_ . clear ( ) ; }	removes all parts from the message.
public static boolean isnumber ( string s ) { try { integer . valueof ( s ) ; return _bool ; } catch ( exception e ) { return _bool ; } }	checks whether a string is a number .
private boolean isoutergstate ( ) { return mgstatestack . size ( ) == _num ; }	return true if the current gstate is the outermost gstate and therefore should not be restored .
public void testcase24 ( ) { byte rbytes [ ] = { _num } ; biginteger anumber = biginteger . one ; biginteger bnumber = biginteger . one ; biginteger result = anumber . subtract ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _num , result . signum ( ) ) ; }	subtract one from one .
void add ( supercardtoast supercardtoast ) { mlist . add ( supercardtoast ) ; }	add a supercardtoast to the list .
static public tasker create ( ) { return new tasker ( ) ; }	simple create task to get us started.
public static string concernstackstring ( blockinfo blockinfo ) { string result = _str ; for ( string stackentry : blockinfo . threadstackentries ) { if ( character . isletter ( stackentry . charat ( _num ) ) ) { string [ ] lines = stackentry . split ( blockinfo . separator ) ; for ( string line : lines ) { string keystackstring = concernstackstring ( line ) ; if ( keystackstring != null ) { return keystackstring ; } } return classsimplename ( lines [ _num ] ) ; } } return result ; }	get key stack string to show as title in ui list .
static string gravitytostring ( @ edgegravity int gravity ) { if ( ( gravity & gravity . left ) == gravity . left ) { return _str ; } if ( ( gravity & gravity . right ) == gravity . right ) { return _str ; } if ( ( gravity & gravity . bottom ) == gravity . bottom ) { return _str ; } return integer . tohexstring ( gravity ) ; }	simple gravity to string - only supports left and right for debugging output .
public void removeallrenderers ( ) { mrenderers . clear ( ) ; }	removes all renderers from the multiple renderer .
public static int writespeexheader ( byte [ ] buf , int offset , int samplerate , int mode , int channels , boolean vbr , int nframes , int packetlength ) { writestring ( buf , offset , _str ) ; writestring ( buf , offset + _num , _str ) ; system . arraycopy ( new byte [ _num ] , _num , buf , offset + _num , _num ) ; writeint ( buf , offset + _num , _num ) ; writeint ( buf , offset + _num , _num ) ; writeint ( buf , offset + _num , samplerate ) ; writeint ( buf , offset + _num , mode ) ; writeint ( buf , offset + _num , _num ) ; writeint ( buf , offset + _num , channels ) ; writeint ( buf , offset + _num , - _num ) ; writeint ( buf , offset + _num , _num << mode ) ; writeint ( buf , offset + _num , vbr ? _num : _num ) ; writeint ( buf , offset + _num , nframes ) ; writeint ( buf , offset + _num , _num ) ; writeint ( buf , offset + _num , packetlength ) ; writeint ( buf , offset + _num , _num ) ; return _num ; }	writes a speex header to the given byte array .
private static file ignitehadoopconfig ( string ignitehome ) { path path = paths . get ( ignitehome , _str , _str , _str ) ; if ( ! files . exists ( path ) ) path = paths . get ( ignitehome , _str , _str ) ; if ( files . exists ( path ) ) return path . tofile ( ) ; else return new file ( ignitehome , _str ) ; }	get ignite hadoop config directory .
protected approximationline conservativeknndistanceapproximation ( int k_max ) { int k_0 = k_max ; double y_1 = double . negative_infinity ; double y_kmax = double . negative_infinity ; for ( int i = _num ; i < getnumentries ( ) ; i ++ ) { mkcopentry entry = getentry ( i ) ; approximationline approx = entry . getconservativeknndistanceapproximation ( ) ; k_0 = math . min ( approx . getk_0 ( ) , k_0 ) ; } for ( int i = _num ; i < getnumentries ( ) ; i ++ ) { mkcopentry entry = getentry ( i ) ; approximationline approx = entry . getconservativeknndistanceapproximation ( ) ; double entry_y_1 = approx . getvalueat ( k_0 ) ; double entry_y_kmax = approx . getvalueat ( k_max ) ; if ( ! double . isinfinite ( entry_y_1 ) ) { y_1 = math . max ( entry_y_1 , y_1 ) ; } if ( ! double . isinfinite ( entry_y_kmax ) ) { y_kmax = math . max ( entry_y_kmax , y_kmax ) ; } } double m = ( y_kmax - y_1 ) / ( math . log ( k_max ) - math . log ( k_0 ) ) ; double t = y_1 - m * math . log ( k_0 ) ; return new approximationline ( k_0 , m , t ) ; }	determines and returns the conservative approximation for the knn distances of this node as the maximum of the conservative approximations of all entries .
public final boolean shares_layer ( brditem p_other ) { int max_first_layer = math . max ( first_layer ( ) , p_other . first_layer ( ) ) ; int min_last_layer = math . min ( last_layer ( ) , p_other . last_layer ( ) ) ; return max_first_layer <= min_last_layer ; }	returns true , if some shapes of this item and p_other are on the same layer .
public coapclient ( uri uri ) { this ( uri . tostring ( ) ) ; }	constructs a new coapclient that sends request to the specified uri .
private void zero ( ) throws jsonexception { if ( probe ) { log ( _num ) ; } write ( _num , _num ) ; }	output a zero bit .
public static boolean beendone ( timeunit timeunit , long amount , string tag , countchecker numberoftimes ) { long timeinmillis = timeunit . tomillis ( amount ) ; return beendone ( timeinmillis , tag , numberoftimes ) ; }	checks if a tag has been marked done within a given time span a specific number of times.
public static string normalize ( string oid ) { return oid . startswith ( _str ) ? oid . substring ( _num ) : oid ; }	removes leading " oid . " from oid string passed.
public void reset ( ) { initialize ( ) ; }	wipe out existing jamon data.
private static void addlistenersforreal ( final service service , final set < listener > existinglisteners , final listener listener , final executor executor ) { if ( ! existinglisteners . contains ( listener ) ) { existinglisteners . add ( listener ) ; service . addlistener ( listener , executor ) ; } }	adds the given listener to the service.
public void prepend ( charsequence s ) { text . insert ( _num , s ) ; }	add a string to the start of the first line of the buffer .
public static void sendresponsewithstatus ( httpservletrequest request , httpservletresponse response , printwriter out , string idpmetaalias , string idpentityid , string realm , authnrequest authnreq , string relaystate , string spentityid , string firstlevelstatuscodevalue , string secondlevelstatuscodevalue ) throws saml2exception { response res = saml2utils . geterrorresponse ( authnreq , firstlevelstatuscodevalue , secondlevelstatuscodevalue , null , idpentityid ) ; stringbuffer returnedbinding = new stringbuffer ( ) ; string acsurl = idpssoutil . getacsurl ( spentityid , realm , authnreq , request , returnedbinding ) ; string acsbinding = returnedbinding . tostring ( ) ; sendresponse ( request , response , out , acsbinding , spentityid , idpentityid , idpmetaalias , realm , relaystate , acsurl , res , null ) ; }	a convenience method to construct response with first - level and second - level status code for saml authentication requests .
public static double mean2 ( connection conn , double ... values ) { conn . getclass ( ) ; double sum = _num ; for ( double x : values ) { sum += x ; } return sum / values . length ; }	this method is called via reflection from the database .
public boolean haslongcolumninfo ( ) { return this . haslongcolumninfo ; }	does the server send back extra column info ?.
public static string domtostring ( document domdoc ) { return domtostring ( domdoc . getdocumentelement ( ) , _bool ) ; }	converts a dom to a string.
public static < t > t assertandcast ( class < ? extends t > clazz , object o ) { assertnotnull ( clazz ) ; assertnotnull ( o ) ; asserttrue ( clazz . isinstance ( o ) ) ; return clazz . cast ( o ) ; }	given a type and an object asserts that the object is non - null and an instance of the specified type.
private string createmismatchmessage ( string mismatch , migrationversion version , object applied , object resolved ) { return string . format ( _str + mismatch + _str + _str + _str , version , applied , resolved ) ; }	creates a message for a mismatch .
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return ids ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public int compareto ( object o ) { split split = ( split ) o ; bitset p = getfirstpart ( ) ; bitset q = split . getfirstpart ( ) ; int a = p . nextsetbit ( _num ) ; int b = q . nextsetbit ( _num ) ; while ( a > - _num && b > - _num ) { if ( a < b ) return - _num ; else if ( a > b ) return _num ; a = p . nextsetbit ( a + _num ) ; b = q . nextsetbit ( b + _num ) ; } if ( a < b ) return - _num ; else if ( a > b ) return _num ; p = getsecondpart ( ) ; q = split . getsecondpart ( ) ; a = p . nextsetbit ( _num ) ; b = q . nextsetbit ( _num ) ; while ( a > - _num && b > - _num ) { if ( a < b ) return - _num ; else if ( a > b ) return _num ; a = p . nextsetbit ( a + _num ) ; b = q . nextsetbit ( b + _num ) ; } if ( a < b ) return - _num ; else if ( a > b ) return _num ; else return _num ; }	compare to a split object.
public boolean ismatchingtalkgroup ( ltrnetmessage message ) { string talkgroup = message . gettalkgroupid ( ) ; if ( talkgroup != null && gettoid ( ) != null && talkgroup . contentequals ( gettoid ( ) ) ) { return _bool ; } return ismatchingtalkgroup ( message . gettalkgroupid ( ) ) ; }	checks if the message ' s talkgroup matches this call event.
public void put ( byte [ ] source , int index , int length ) { if ( mbuffer . capacity ( ) < ( mlength + length ) ) { expandbuffer ( mlength + length + additional_buffer_size ) ; } mbuffer . put ( source , index , length ) ; mlength += length ; }	add data at the current position .
public void testsetbitnegativeinside4 ( ) { string as = _str ; int number = _num ; biginteger anumber = new biginteger ( as ) ; biginteger result = anumber . setbit ( number ) ; assertequals ( as , result . tostring ( ) ) ; }	setbit ( 0 ) in the negative number of length 1 with all ones in bit representation.
public shape modeltoview ( int pos , shape a , position . bias b ) throws badlocationexception { return m_view . modeltoview ( pos , a , b ) ; }	provides a mapping from the document model coordinate space to the coordinate space of the view mapped to it .
private static int applyprecision ( int decexp , char [ ] digits , int ndigits , int prec ) { if ( prec >= ndigits || prec < _num ) { return decexp ; } if ( prec == _num ) { if ( digits [ _num ] >= _str ) { digits [ _num ] = _str ; arrays . fill ( digits , _num , ndigits , _str ) ; return decexp + _num ; } else { arrays . fill ( digits , _num , ndigits , _str ) ; return decexp ; } } int q = digits [ prec ] ; if ( q >= _str ) { int i = prec ; q = digits [ -- i ] ; if ( q == _str ) { while ( q == _str && i > _num ) { q = digits [ -- i ] ; } if ( q == _str ) { digits [ _num ] = _str ; arrays . fill ( digits , _num , ndigits , _str ) ; return decexp + _num ; } } digits [ i ] = ( char ) ( q + _num ) ; arrays . fill ( digits , i + _num , ndigits , _str ) ; } else { arrays . fill ( digits , prec , ndigits , _str ) ; } return decexp ; }	returns new decexp in case of overflow .
public void delete ( @ nonnull key key ) { final reentrantreadwritelock . writelock lock = guard . writelock ( ) ; lock . lock ( ) ; try { if ( ! readkeys . remove ( key ) ) throw new illegalargumentexception ( _str ) ; files . delete ( key . getfile ( ) ) ; } catch ( ioexception ex ) { log . log ( level . warning , _str + key . getfile ( ) , ex ) ; } finally { lock . unlock ( ) ; } }	removes the file associated with the given key .
public void writetofile ( string filename ) throws ioexception { printwriter outfile = new printwriter ( new fileoutputstream ( filename ) ) ; outfile . println ( _str ) ; outfile . println ( _str ) ; outfile . println ( _str + m_nbins ) ; outfile . println ( _str + m_min ) ; outfile . println ( _str + m_max ) ; outfile . println ( _str + m_entries ) ; outfile . println ( _str + m_underflow ) ; outfile . println ( _str + m_overflow ) ; outfile . println ( _str ) ; for ( int i = _num ; i < m_nbins ; i ++ ) { outfile . println ( i + _str + m_bincenters [ i ] + _str + m_hist [ i ] ) ; } outfile . println ( _str ) ; outfile . close ( ) ; }	save the histogram data to a file.
public void outdent ( ) { final int length = indent . length ( ) ; if ( length == _num ) { throw new illegalargumentexception ( _str ) ; } indent . delete ( length - _num , length ) ; }	reduces the current indent level by two spaces , or crashes if the indent level is zero .
public static string extractfromdatamatrix ( string code ) { if ( code . length ( ) < _num ) { return null ; } if ( code . startswith ( _str ) ) { return code . substring ( _num , _num ) ; } return null ; }	extracts a gtin from a gs1 datamatrix formatted bar code .
@ override public audioinputstream synthesiseonesection ( string festivalutt , voice voice ) throws ioexception { writerelationfiles ( festivalutt ) ; file audiofile = new file ( festivaldir . getpath ( ) + file . separator + _str ) ; string festivalvoicecmd = _str + voice . getname ( ) + _str ; audioinputstream sound = festivalsynthesise ( audiofile , festivalvoicecmd ) ; return sound ; }	process a single utterance in festival_utt text format .
public int read ( byte [ ] buffer , int offset , int length ) throws ioexception { log . finest ( _str + long . tohexstring ( getfilepointer ( ) ) + _str + length + _str ) ; return _file . read ( buffer , offset , length ) ; }	reads a block from a given location .
public static pattern createpattern ( string [ ] patterns , boolean iscasesensitive , boolean isregexsearch ) throws patternsyntaxexception { stringbuffer pattern = new stringbuffer ( ) ; for ( int i = _num ; i < patterns . length ; i ++ ) { if ( i > _num ) { pattern . append ( _str ) ; } if ( isregexsearch ) { pattern . append ( patterns [ i ] ) ; } else { asregex ( patterns [ i ] , pattern ) ; } } return createpattern ( pattern . tostring ( ) , iscasesensitive , _bool ) ; }	creates a pattern element from the pattern string which is either a reg - ex expression or in our old ' stringmatcher ' format .
public void addarc ( float latpoint , float lonpoint , int w , int h , float s , float e , linkproperties properties ) throws ioexception { linkarc . write ( latpoint , lonpoint , _num , _num , w , h , s , e , properties , link . dos ) ; }	write an arc with lat / lon placement .
public void onundeploy ( classloader ldr ) { for ( class < ? > cls : descbycls . keyset ( ) ) { if ( ldr . equals ( cls . getclassloader ( ) ) ) descbycls . remove ( cls ) ; } u . clearclasscache ( ldr ) ; }	undeployment callback invoked when class loader is being undeployed.
@ override public boolean containsclass ( string classname ) throws ioexception { boolean containsclass = _bool ; string resourcename = _str + classname . replace ( _str , _str ) + _str ; if ( getresource ( resourcename ) != null ) { containsclass = _bool ; } for ( string resource : getresources ( _str ) ) { jararchive jar = new defaultjararchive ( getresource ( resource ) ) ; if ( jar . containsclass ( classname ) ) { containsclass = _bool ; } } return containsclass ; }	returns whether a class of the specified name is contained in the web - app archive , either directly in web - inf / classes , or in one of the jars in web - inf / lib .
public tuple [ ] clearinternal ( ) { tuple [ ] t = new tuple [ gettuplecount ( ) ] ; iterator iter = tuples ( ) ; for ( int i = _num ; iter . hasnext ( ) ; ++ i ) { t [ i ] = ( tuple ) iter . next ( ) ; } m_tuples . clear ( ) ; return t ; }	clear the internal state without firing a notification .
private void ensurecapacity ( int desiredlongcount ) { if ( desiredlongcount <= bits . length ) { return ; } int newlength = math . max ( desiredlongcount , bits . length * _num ) ; long [ ] newbits = new long [ newlength ] ; system . arraycopy ( bits , _num , newbits , _num , longcount ) ; this . bits = newbits ; }	ensures that our long [ ] can hold at least 64 * desiredlongcount bits .
public boolean matches ( string query , string text ) { return text . contains ( query ) ; }	simple check if query string is a substring of a block of text .
private void findcollapsesfromexistingvertices ( list collapsedvertexindexes ) { for ( int i = _num ; i < edge . size ( ) - _num ; i ++ ) { coordinate p0 = edge . getcoordinate ( i ) ; coordinate p1 = edge . getcoordinate ( i + _num ) ; coordinate p2 = edge . getcoordinate ( i + _num ) ; if ( p0 . equals2d ( p2 ) ) { collapsedvertexindexes . add ( new integer ( i + _num ) ) ; } } }	adds nodes for any collapsed edge pairs which are pre - existing in the vertex list .
public void close ( ) throws ioexception { if ( debug . debugging ( _str ) ) { debug . output ( _str ) ; } try { if ( inputfile != null ) inputfile . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } inputfile = null ; }	closes the underlying file.
public static boolean checkpoolpropertieschanged ( set < string > existingvalue , set < string > newvalue ) { boolean propertychanged = _bool ; if ( existingvalue == null && ( newvalue != null && ! newvalue . isempty ( ) ) ) { propertychanged = _bool ; } else if ( newvalue == null && ( existingvalue != null && ! existingvalue . isempty ( ) ) ) { propertychanged = _bool ; } else if ( existingvalue != null && newvalue != null ) { if ( existingvalue . size ( ) != newvalue . size ( ) || ! ( existingvalue . containsall ( newvalue ) ) ) { propertychanged = _bool ; } } return propertychanged ; }	compares the two given sets.
public static outputstream leftshift ( outputstream self , inputstream in ) throws ioexception { byte [ ] buf = new byte [ _num ] ; while ( _bool ) { int count = in . read ( buf , _num , buf . length ) ; if ( count == - _num ) break ; if ( count == _num ) { thread . yield ( ) ; continue ; } self . write ( buf , _num , count ) ; } self . flush ( ) ; return self ; }	pipe an inputstream into an outputstream for efficient stream copying .
public static boolean gitlocalconfig ( final atomicreference < string > path ) throws ioexception { return gitlocalconfig ( environment . getcurrentdirectory ( ) , path ) ; }	gets the path to the git local configuration file based on the current working directory .
public void verify ( ) { super . verify ( ) ; assertequals ( _str , confirmed , collection ) ; assertequals ( _str , confirmed . hashcode ( ) , collection . hashcode ( ) ) ; collection set = makeconfirmedcollection ( ) ; iterator iterator = collection . iterator ( ) ; while ( iterator . hasnext ( ) ) { asserttrue ( _str , set . add ( iterator . next ( ) ) ) ; } }	provides additional verifications for sets .
public static cgpoint ccprotatebyangle ( cgpoint v , cgpoint pivot , float angle ) { cgpoint r = ccpsub ( v , pivot ) ; float t = r . x ; float cosa = ( float ) math . cos ( angle ) ; float sina = ( float ) math . sin ( angle ) ; r . x = t * cosa - r . y * sina ; r . y = t * sina + r . y * cosa ; r = ccpadd ( r , pivot ) ; return r ; }	rotates a point counter clockwise by the angle around a pivot.
private void opencontextmenu ( mouseevent e ) { if ( e . ispopuptrigger ( ) ) { collection < string > streams = new hashset < > ( ) ; int [ ] selectedrows = table . getselectedrows ( ) ; for ( int selectedrow : selectedrows ) { follower selected = followers . get ( selectedrow ) ; streams . add ( stringutil . tolowercase ( selected . name ) ) ; } if ( ! streams . isempty ( ) ) { streamscontextmenu m = new streamscontextmenu ( streams , contextmenulistener ) ; m . show ( table , e . getx ( ) , e . gety ( ) ) ; } } }	open the context menu for the given mouseevent if it is the popup trigger and rows are selected .
public static workflow . method expandvolumesmethod ( uri storage , uri pool , uri volume , long size ) { return new workflow . method ( _str , storage , pool , volume , size ) ; }	return a workflow . method for expandvolume .
void closesilently ( socket socket ) { try { socket . close ( ) ; } catch ( exception e ) { } }	close a socket , ignoring errors.
public static boolean equals ( byte [ ] array1 , byte [ ] array2 ) { if ( array1 == array2 ) return _bool ; if ( array1 == null || array2 == null || array1 . length != array2 . length ) return _bool ; for ( int i = _num ; i < array1 . length ; i ++ ) { if ( array1 [ i ] != array2 [ i ] ) return _bool ; } return _bool ; }	compares the two arrays .
private static string createidfromjndilocationifnotnull ( string jndilocation ) { string id = null ; if ( jndilocation != null ) { id = createidfromjndilocation ( jndilocation ) ; } return id ; }	return a string that can be used to name this configuration or null , if jndilocation was not specified .
protected set < node > closure ( dependencykind ... depkinds ) { boolean progress = _bool ; set < node > closure = new hashset < node > ( ) ; closure . add ( this ) ; while ( progress ) { progress = _bool ; for ( node n1 : new hashset < node > ( closure ) ) { progress = closure . addall ( n1 . getdependencies ( depkinds ) ) ; } } return closure ; }	compute closure of a give node , by recursively walking through all its dependencies ( of given kinds ).
public vector ( collection c ) { elementcount = c . size ( ) ; elementdata = new object [ ( int ) math . min ( ( elementcount * _num ) / _num , integer . max_value ) ] ; c . toarray ( elementdata ) ; }	constructs a vector containing the elements of the specified collection , in the order they are returned by the collection ' s iterator .
public static < a extends annotation > a createannotation ( class < ? extends annotation > annotationtype , annotationmember [ ] elements ) { annotationfactory factory = new annotationfactory ( annotationtype , elements ) ; return ( a ) proxy . newproxyinstance ( annotationtype . getclassloader ( ) , new class [ ] { annotationtype } , factory ) ; }	provides a new annotation instance .
public linkingmorphemes ( string ... amorphemes ) { morphemes = new arraylist < string > ( ) ; for ( string string : amorphemes ) { morphemes . add ( string ) ; } }	create a linking morphemes object from a array of morphemes.
@ override public void execute ( metrictimeseries timeseries , functionvaluemap functionvaluemap ) { if ( timeseries . size ( ) <= _num ) { functionvaluemap . add ( this , double . nan ) ; return ; } timeseries . sort ( ) ; double firstvalue = timeseries . getvalue ( _num ) ; double lastvalue = timeseries . getvalue ( timeseries . size ( ) - _num ) ; functionvaluemap . add ( this , math . abs ( firstvalue - lastvalue ) ) ; }	calculate the difference between the first and the last value of a given time series.
public static url [ ] findresourcebases ( string baseresource , classloader loader ) { arraylist < url > list = new arraylist < url > ( ) ; try { enumeration < url > urls = loader . getresources ( baseresource ) ; while ( urls . hasmoreelements ( ) ) { url url = urls . nextelement ( ) ; list . add ( findresourcebase ( url , baseresource ) ) ; } } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } return list . toarray ( new url [ list . size ( ) ] ) ; }	find the classpath urls for a specific classpath resource.
public writableraster createwritablechild ( int x , int y , int width , int height , int x0 , int y0 , int bandlist [ ] ) { if ( x < this . minx ) { throw new rasterformatexception ( _str ) ; } if ( y < this . miny ) { throw new rasterformatexception ( _str ) ; } if ( ( x + width < x ) || ( x + width > this . width + this . minx ) ) { throw new rasterformatexception ( _str ) ; } if ( ( y + height < y ) || ( y + height > this . height + this . miny ) ) { throw new rasterformatexception ( _str ) ; } samplemodel sm ; if ( bandlist != null ) sm = samplemodel . createsubsetsamplemodel ( bandlist ) ; else sm = samplemodel ; int deltax = x0 - x ; int deltay = y0 - y ; return new bytebandedraster ( sm , databuffer , new rectangle ( x0 , y0 , width , height ) , new point ( samplemodeltranslatex + deltax , samplemodeltranslatey + deltay ) , this ) ; }	creates a writable subraster given a region of the raster.
protected void moveupitem ( ) { if ( selectiontable . getselectioncount ( ) == _num ) { return ; } for ( final int index : selectiontable . getselectionindices ( ) ) { if ( index == _num ) { selectiontable . forcefocus ( ) ; return ; } } final int [ ] newselection = new int [ selectiontable . getselectioncount ( ) ] ; int newselectionindex = _num ; for ( final tableitem tableitem : selectiontable . getselection ( ) ) { final int position = selection . indexof ( tableitem . getdata ( ) ) ; swap ( position , position - _num ) ; newselection [ newselectionindex ++ ] = position - _num ; } redrawtables ( ) ; selectiontable . select ( newselection ) ; selectiontable . forcefocus ( ) ; }	move the selected item up.
protected void maybefireboundsinvalidated ( rectangle invalidatedarea ) { drawing d = getdrawing ( ) ; rectangle2d . double canvasbounds = new rectangle2d . double ( _num , _num , _num , _num ) ; if ( d . get ( canvas_width ) != null ) { canvasbounds . width += d . get ( canvas_width ) ; } if ( d . get ( canvas_height ) != null ) { canvasbounds . height += d . get ( canvas_height ) ; } if ( ! canvasbounds . contains ( invalidatedarea ) ) { fireboundsinvalidated ( invalidatedarea ) ; } }	notify all listenerlist that have registered interest for notification on this event type.
public void suspend ( string id ) { tracestate ts = tracestate . get ( ) ; if ( log . isloggable ( level . finest ) ) { log . finest ( _str + ts + _str + id ) ; } if ( ts != null ) { setexpire ( ts ) ; try { suspendedstatelock . lock ( ) ; if ( suspendedstate . containskey ( id ) && log . isloggable ( level . finest ) ) { log . finest ( _str + suspendedstate . get ( id ) + _str + id ) ; } suspendedstate . put ( id , ts ) ; tracestate . remove ( ) ; } finally { suspendedstatelock . unlock ( ) ; } } }	this method suspends any current trace state , associated with this thread , and associates it with the supplied id.
public static int hashcode ( final object obj ) { return ( obj == null ? _num : obj . hashcode ( ) ) ; }	a null - safe computation of the specified object ' s hash value.
public static int maxlevel ( ) { return levels - _num ; }	gets the highest level.
public void propertychange ( propertychangeevent evt ) { repaint ( ) ; }	react to property changes by repainting .
public static boolean removebeanorfolder ( string path ) { return removepath ( path . split ( path_separator ) , s_directory , _num ) > _num ; }	removes a bean or tree from the directory .
private void updateselection ( mode mode , projection2d proj , svgpoint p1 , svgpoint p2 ) { dbidselection selcontext = context . getselection ( ) ; hashsetmodifiabledbids selection ; if ( selcontext == null || mode == mode . replace ) { selection = dbidutil . newhashset ( ) ; } else { selection = dbidutil . newhashset ( selcontext . getselectedids ( ) ) ; } for ( dbiditer iditer = rel . iterdbids ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { double [ ] vec = proj . fastprojectdatatorenderspace ( rel . get ( iditer ) ) ; if ( vec [ _num ] >= math . min ( p1 . getx ( ) , p2 . getx ( ) ) && vec [ _num ] <= math . max ( p1 . getx ( ) , p2 . getx ( ) ) && vec [ _num ] >= math . min ( p1 . gety ( ) , p2 . gety ( ) ) && vec [ _num ] <= math . max ( p1 . gety ( ) , p2 . gety ( ) ) ) { if ( mode == mode . invert ) { if ( ! selection . contains ( iditer ) ) { selection . add ( iditer ) ; } else { selection . remove ( iditer ) ; } } else { selection . add ( iditer ) ; } } } context . setselection ( new dbidselection ( selection ) ) ; }	updates the selection in the context . < br >.
public eclipseinilauncher ( file installationroot ) throws filenotfoundexception , ioexception { filemisc . assertmacapp ( installationroot ) ; objects . requirenonnull ( installationroot ) ; eclipseini = eclipseini . parsefrom ( new file ( installationroot , filemisc . maccontentseclipse ( ) + _str ) ) ; }	wraps a directory of jars in the launcher api , and ensures the the directory contains the plugins required to run a barebones equinox instance .
public boolean canaddmember ( string realmname , string idtype , string containeridtype ) throws amconsoleexception { boolean can = _bool ; try { idtype type = idutils . gettype ( idtype ) ; set canadd = type . canaddmembers ( ) ; idtype ctype = idutils . gettype ( containeridtype ) ; can = canadd . contains ( ctype ) ; } catch ( idrepoexception e ) { debug . warning ( _str , e ) ; throw new amconsoleexception ( geterrorstring ( e ) ) ; } return can ; }	returns true of members can be added to a type .
public static double cosquick ( double angle ) { if ( use_jdk_math ) { return strict_math ? strictmath . cos ( angle ) : math . cos ( angle ) ; } return costab [ ( ( int ) ( math . abs ( angle ) * sin_cos_indexer + _num ) ) & ( sin_cos_tabs_size - _num ) ] ; }	quick cosine , with accuracy of about 1.
public void readsecurityheader ( sipresponse response ) throws payloadexception { wwwauthenticateheader wwwheader = ( wwwauthenticateheader ) response . getheader ( wwwauthenticateheader . name ) ; authenticationinfoheader infoheader = ( authenticationinfoheader ) response . getheader ( authenticationinfoheader . name ) ; if ( wwwheader != null ) { mdigest . setrealm ( wwwheader . getrealm ( ) ) ; mdigest . setopaque ( wwwheader . getopaque ( ) ) ; mdigest . setqop ( wwwheader . getqop ( ) ) ; mdigest . setnextnonce ( wwwheader . getnonce ( ) ) ; } else if ( infoheader != null ) { if ( infoheader . getnextnonce ( ) != null ) { mdigest . setnextnonce ( infoheader . getnextnonce ( ) ) ; } } }	read security header from register response.
private void layoutpanel ( ) { setborder ( borderfactory . createemptyborder ( _num , _num , _num , _num ) ) ; setlayout ( new borderlayout ( ) ) ; add ( new labelleditem ( _str , cbdistribution ) , borderlayout . north ) ; add ( cardpanel , borderlayout . center ) ; cbitemlistener . itemstatechanged ( new itemevent ( cbdistribution , itemevent . selected , cardpanel , itemevent . item_state_changed ) ) ; repaint ( ) ; revalidate ( ) ; }	lays out the panel.
@ override public int compareto ( doubledoublepair other ) { int fdiff = double . compare ( this . first , other . first ) ; if ( fdiff != _num ) { return fdiff ; } return double . compare ( this . second , other . second ) ; }	implementation of comparable interface , sorting by first then second .
private static boolean fileexists ( string filepath ) { file file = new file ( filepath ) ; return file . exists ( ) ; }	check if a file exists on device.
public static string classversiontojdk ( int version ) { return _str + integer . tostring ( version - _num ) ; }	converts a class file version number jdk string like 1.
private bitset createbitset ( final string binarystring ) { final bitset bset = new bitset ( binarystring . length ( ) ) ; boolean bittrue = _bool ; for ( int i = _num ; i < binarystring . length ( ) ; i ++ ) { if ( binarystring . charat ( i ) == _str ) { bittrue = _bool ; } else { bittrue = _bool ; } bset . set ( i , bittrue ) ; } return bset ; }	creates a bitset based on a string representation of binary digits .
public void flush ( ) { buffer . force ( ) ; }	flushes the mapped buffer to disk .
public void remove ( product product ) { try { solrdao . remove ( product . getid ( ) ) ; } catch ( ioexception | solrserverexception ex ) { logger . error ( _str + product . getidentifier ( ) + _str , ex ) ; } }	removes the given product from the index .
public void startbackgroundfetchservice ( ) { localnotification n = new localnotification ( ) ; n . setid ( background_fetch_notification_id ) ; cancellocalnotification ( background_fetch_notification_id ) ; schedulelocalnotification ( n , system . currenttimemillis ( ) + getpreferredbackgroundfetchinterval ( ) * _num , _num ) ; }	starts the background fetch service .
protected void showmodels ( boolean show , epoxymodel < ? > ... models ) { showmodels ( arrays . aslist ( models ) , show ) ; }	sets the visibility of the given models , and notifies that the items changed if the new visibility is different from the previous .
static void check ( publickey key , x509crl crl ) throws certpathvalidatorexception { x509crlimpl x509crlimpl = null ; try { x509crlimpl = x509crlimpl . toimpl ( crl ) ; } catch ( crlexception ce ) { throw new certpathvalidatorexception ( ce ) ; } algorithmid algorithmid = x509crlimpl . getsigalgid ( ) ; check ( key , algorithmid ) ; }	check the signature algorithm with the specified public key .
public void testuserdatahandlernotifiedofonlyshallowadoptions ( ) throws exception { domtostring ( document ) ; recordinghandler handler = new recordinghandler ( ) ; name . setuserdata ( _str , _str , handler ) ; name . setuserdata ( _str , _str , handler ) ; standard . setuserdata ( _str , _str , handler ) ; waffles . setuserdata ( _str , _str , handler ) ; document newdocument = builder . newdocument ( ) ; assertsame ( name , newdocument . adoptnode ( name ) ) ; assertsame ( newdocument , name . getownerdocument ( ) ) ; assertsame ( newdocument , standard . getownerdocument ( ) ) ; assertsame ( newdocument , waffles . getownerdocument ( ) ) ; set < string > expected = new hashset < string > ( ) ; expected . add ( notification ( node_adopted , _str , _str , name , null ) ) ; expected . add ( notification ( node_adopted , _str , _str , name , null ) ) ; assertequals ( expected , handler . calls ) ; }	there should be notifications for adopted node itself but none of its children.
public void reset ( ) { node_list . clear ( ) ; }	sets the stack to empty .
public string namelist ( string dir ) throws ioexception { passive ( ) ; send ( _str + dir ) ; readcode ( _num ) ; bytearrayoutputstream out = new bytearrayoutputstream ( ) ; ioutils . copyandclose ( indata , out ) ; readcode ( _num ) ; byte [ ] data = out . tobytearray ( ) ; return new string ( data ) ; }	get the directory listing ( nlst ) .
public vnxecommandresult addlunstolungroup ( string lungroupid , list < string > luns ) { lungroupmodifyparam param = new lungroupmodifyparam ( ) ; list < lunaddparam > lunadds = new arraylist < lunaddparam > ( ) ; for ( string lunid : luns ) { vnxebase lun = new vnxebase ( lunid ) ; lunaddparam lunadd = new lunaddparam ( ) ; lunadd . setlun ( lun ) ; lunadds . add ( lunadd ) ; } param . setlunadd ( lunadds ) ; lungrouprequests req = new lungrouprequests ( _khclient ) ; return req . modifylungroupsync ( lungroupid , param ) ; }	add luns to lungroup.
public static constantexpression constant ( object value , class constanttype ) { return new constantexpression ( value , constanttype . getname ( ) ) ; }	constant , use when the value is null .
public void endelement ( string uri , string localname , string qname ) throws saxexception { if ( ! ( htmlmode && ( uri . equals ( _str ) || uri . equals ( _str ) ) && ( qname . equals ( _str ) || qname . equals ( _str ) || qname . equals ( _str ) || qname . equals ( _str ) || qname . equals ( _str ) || qname . equals ( _str ) || qname . equals ( _str ) || qname . equals ( _str ) || qname . equals ( _str ) || qname . equals ( _str ) || qname . equals ( _str ) || qname . equals ( _str ) || qname . equals ( _str ) ) ) ) { write ( _str ) ; writename ( uri , localname , qname , _bool ) ; write ( _str ) ; } if ( elementlevel == _num ) { write ( _str ) ; } cdataelement = _bool ; super . endelement ( uri , localname , qname ) ; nssupport . popcontext ( ) ; elementlevel -- ; }	write an end tag.
static void findallvisiblechilds ( final viewgroup viewgroup , final list < view > ordoredchilds ) { for ( int childviewindex = _num ; childviewindex < viewgroup . getchildcount ( ) ; childviewindex ++ ) { final view childview = viewgroup . getchildat ( childviewindex ) ; if ( childview instanceof viewgroup ) { findallvisiblechilds ( ( viewgroup ) childview , ordoredchilds ) ; continue ; } if ( childview . getvisibility ( ) == view . visible ) { ordoredchilds . add ( childview ) ; } } }	helps to find recursivly all visible childs in a view group .
public boolean logmodified ( logger log ) { if ( ismodified ( ) ) { log . info ( _classname + _str ) ; return _bool ; } else return _bool ; }	returns true if the underlying resource has changed .
public string serialize ( object obj ) throws apiexception { try { if ( obj != null ) return mapper . writevalueasstring ( obj ) ; else return null ; } catch ( exception e ) { throw new apiexception ( _num , e . getmessage ( ) ) ; } }	serialize the given java object into json string .
private void initializesparseslider ( ) { sparsityslider . setmajortickspacing ( _num ) ; sparsityslider . setminortickspacing ( _num ) ; sparsityslider . setpaintticks ( _bool ) ; hashtable < integer , jlabel > labeltable2 = new hashtable < integer , jlabel > ( ) ; labeltable2 . put ( new integer ( _num ) , new jlabel ( _str ) ) ; labeltable2 . put ( new integer ( _num ) , new jlabel ( _str ) ) ; sparsityslider . setlabeltable ( labeltable2 ) ; sparsityslider . setpaintlabels ( _bool ) ; }	initializes the sparse slider .
@ override protected void autoadjustrange ( ) { plot plot = getplot ( ) ; if ( plot == null ) { return ; } if ( plot instanceof valueaxisplot ) { valueaxisplot vap = ( valueaxisplot ) plot ; range r = vap . getdatarange ( this ) ; if ( r == null ) { r = getdefaultautorange ( ) ; } double upper = r . getupperbound ( ) ; double lower = math . max ( r . getlowerbound ( ) , this . smallestvalue ) ; double range = upper - lower ; double fixedautorange = getfixedautorange ( ) ; if ( fixedautorange > _num ) { lower = math . max ( upper - fixedautorange , this . smallestvalue ) ; } else { double minrange = getautorangeminimumsize ( ) ; if ( range < minrange ) { double expand = ( minrange - range ) / _num ; upper = upper + expand ; lower = lower - expand ; } double logupper = calculatelog ( upper ) ; double loglower = calculatelog ( lower ) ; double logrange = logupper - loglower ; logupper = logupper + getuppermargin ( ) * logrange ; loglower = loglower - getlowermargin ( ) * logrange ; upper = calculatevaluenoinf ( logupper ) ; lower = calculatevaluenoinf ( loglower ) ; } setrange ( new range ( lower , upper ) , _bool , _bool ) ; } }	adjusts the axis range to match the data range that the axis is required to display .
public synchronized void add ( long value ) { long res = get ( ) + value ; lb . put ( _num , res ) ; }	adds the given value to the perf counter .
public void addivcombination ( int attackiv , int defenseiv , int staminaiv ) { int sumiv = attackiv + defenseiv + staminaiv ; int percentperfect = math . round ( sumiv / _num * _num ) ; if ( ( percentperfect < lowpercent ) || ( percentperfect == lowpercent ) && ( attackiv < lowattack ) ) { lowpercent = percentperfect ; lowattack = attackiv ; lowdefense = defenseiv ; lowstamina = staminaiv ; } if ( ( percentperfect > highpercent ) || ( percentperfect == highpercent ) && ( attackiv > highattack ) ) { highpercent = percentperfect ; highattack = attackiv ; highdefense = defenseiv ; highstamina = staminaiv ; } ivcombinations . add ( new ivcombination ( attackiv , defenseiv , staminaiv ) ) ; }	adds an iv possibility to the scan results .
@ nullable public bitmap generateiconforurl ( string url , boolean includeprivateregistries ) { if ( textutils . isempty ( url ) ) return null ; string text = geticontextforurl ( url , includeprivateregistries ) ; if ( textutils . isempty ( text ) ) return null ; return generateiconfortext ( text ) ; }	returns a bitmap representing the icon to be used for | url | .
public boolean containsprefix ( final charsequence prefix ) { return containsprefix ( prefix , _num , prefix . length ( ) ) ; }	checks if the given string is a prefix of a key in the trie .
public int compareto ( object p_other ) { if ( p_other == null ) return _num ; if ( p_other instanceof brdcomponent ) { return name . comparetoignorecase ( ( ( brdcomponent ) p_other ) . name ) ; } return _num ; }	compares 2 components by name.
public void fatal ( string message ) throws saxexception { saxparseexception spe = new saxparseexception ( message , this ) ; if ( errorhandler != null ) { errorhandler . fatalerror ( spe ) ; } throw spe ; }	reports an condition that would make the infoset incompatible with xml 1.
protected final void firepropertychange ( string propertyname , boolean oldvalue , boolean newvalue ) { propertychangesupport achangesupport = this . changesupport ; if ( achangesupport == null ) { return ; } achangesupport . firepropertychange ( propertyname , oldvalue , newvalue ) ; }	support for reporting bound property changes for boolean properties.
private iterator < bindingset > joinbindingsetentry ( map . entry < string , bindingset > entry ) { list < collection < bindingset > > matches = new arraylist < > ( ) ; if ( type == hashjointype . constant_join_var ) { if ( bindingjoinvarhash . containskey ( entry . getkey ( ) ) ) { matches . add ( bindingjoinvarhash . get ( entry . getkey ( ) ) ) ; } } else { list < string > valorders = getvalueorders ( entry . getkey ( ) ) ; for ( string s : valorders ) { if ( bindingjoinvarhash . containskey ( s ) ) { matches . add ( bindingjoinvarhash . get ( s ) ) ; } } } if ( matches . size ( ) == _num ) { return collections . emptyiterator ( ) ; } else { return new bindingsetcollectionsjoiniterator ( entry . getvalue ( ) , matches ) ; } }	this method returns an iterator which joins the given entry ' s bindingset to all bindingsets which matching the entry ' s key .
@ override public void test ( number t ) throws parameterexception { if ( t . doublevalue ( ) >= constraintvalue . doublevalue ( ) ) { throw new wrongparametervalueexception ( _str + _str + constraintvalue . tostring ( ) + _str + t . doublevalue ( ) + _str ) ; } }	checks if the number value given by the number parameter is less than the constraint value.
public void testfindusersactivedirectory ( ) throws exception { ldapmanager mgr = getldapad ( ) ; list ret = null ; andfilter filter = new andfilter ( ) ; filter . and ( new likefilter ( mgr . getusersreturningattribute ( ldapuserattributeconstants . ldap_user_attribute_given_name ) , _str ) ) ; try { ldapsearchmanagervo searchmgrvo = new ldapsearchmanagervo ( ) ; searchmgrvo . setfilter ( filter ) ; searchmgrvo . setadduserclasses ( _bool ) ; ret = mgr . findusers ( searchmgrvo ) ; } catch ( exception e ) { } assertequals ( _num , ret . size ( ) ) ; }	test de busqueda de varios usuarios para active directory.
public boolean reserve ( object object ) { reservedidslock . lock ( ) ; if ( reservedobjects . contains ( object ) ) { reservedidslock . unlock ( ) ; return _bool ; } reservedobjects . add ( object ) ; reservedidslock . unlock ( ) ; return _bool ; }	reserve an object , returning true when successfully reserved or false when the object is already reserved .
private boolean savestoredjpegimage ( string file_name , final bufferedimage image , final boolean file_name_is_path ) { if ( ! file_name_is_path ) { file_name = temp_dir + key + file_name ; } final string s = file_name . tolowercase ( ) ; if ( ! s . endswith ( _str ) && ! s . endswith ( _str ) ) { file_name += _str ; } try { defaultimagehelper . write ( image , _str , file_name ) ; tempfilenames . put ( file_name , _str ) ; } catch ( final exception e ) { logwriter . writelog ( _str + e + _str + image + _str + file_name ) ; } return _bool ; }	save buffered image as jpeg.
public static scheduledexecutorservice createscheduler ( ) { final scheduledexecutorservice scheduler = executors . newscheduledthreadpool ( _num , new daemonthreadfactory ( default_scheduler_name ) ) ; schedulers . add ( scheduler ) ; return scheduler ; }	creates a single - threaded scheduler that is registered by this class in order to shut it down later ( when it becomes necessary ) .
protected static void fail ( ) { system . exit ( _num ) ; }	exit with a process failure code .
private void printarguments ( list < expression > args , object arg ) { printer . print ( _str ) ; if ( args != null ) { for ( iterator < expression > i = args . iterator ( ) ; i . hasnext ( ) ; ) { expression e = i . next ( ) ; e . accept ( this , arg ) ; if ( i . hasnext ( ) ) { printer . print ( _str ) ; } } } printer . print ( _str ) ; }	print a list of method arguments in between parentheses .
private void calculatedelta ( double [ ] b ) { double numerator = _num ; double denominator = _num ; double sign = _num ; for ( int k = _num ; k < b . length ; k ++ ) { if ( k < mextremalindices . size ( ) ) { int extremalindex = mextremalindices . get ( k ) ; numerator += ( b [ k ] * mgrid . getdesiredresponse ( ) [ extremalindex ] ) ; denominator += b [ k ] * sign / mgrid . getweight ( ) [ extremalindex ] ; sign = - sign ; } else { mlog . error ( _str ) ; } } mdelta = numerator / denominator ; }	calculates the value of delta that represents the maximum ripple for the current set of extremal indices ( l + 2 ) implements oppenheim / schafer discrete time signal processing , 3e , 2016 , equation 114.
private void addfallbackselector ( properties settings , protocoldispatchselector ps ) { string proxy = settings . getproperty ( _str ) ; if ( proxy != null ) { ps . setfallbackselector ( proxyutil . parseproxysettings ( proxy ) ) ; } }	installs a fallback selector that is used whenever no protocol specific selector is defined .
private void readdata ( ) throws ioexception { while ( ! isclosed ) { int code = is . read ( ) ; switch ( code ) { case _str : case _str : case _str : case _str : break ; case _str : { int channel = ( is . read ( ) << _num ) + is . read ( ) ; inputready [ channel ] = _bool ; return ; } case _str : { int channel = ( is . read ( ) << _num ) + is . read ( ) ; int status = ( is . read ( ) << _num ) + is . read ( ) ; inputready [ channel ] = _bool ; return ; } case - _num : close ( ) ; return ; default : close ( ) ; return ; } } return ; }	reads data until a channel packet ' c ' or error ' e ' is received .
@ override protected boolean validateconnection ( connection conn ) { try { return ( ! conn . isclosed ( ) ) ; } catch ( sqlexception e ) { return _bool ; } }	returns true if the connection is not closed .
public pacproxyselector ( string pacurl ) { if ( pacurl == null ) { throw new nullpointerexception ( ) ; } this . pacurl = pacurl ; }	construct pacproxyselector using an automatic proxy configuration url.
public void deletealertingdefinition ( alertingdefinition alertingdefinition ) throws ioexception { string id = alertingdefinition . getid ( ) ; alertingdefinition local = existingalertingdefinitions . remove ( id ) ; if ( local != null ) { files . deleteifexists ( pathresolver . getalertingdefinitionfilepath ( local ) ) ; eventpublisher . publishevent ( new abstractalertingdefinitionevent . alertingdefinitiondeletedevent ( this , local ) ) ; } }	deletes the alerting definition .
public void addfile ( file file ) { filelist . addfirst ( file ) ; }	add the given file to the collection.
private void pullevent ( ) { final int newscrollvalue ; final int itemdimension ; final float initialmotionvalue , lastmotionvalue ; switch ( getpulltorefreshscrolldirection ( ) ) { case horizontal : initialmotionvalue = minitialmotionx ; lastmotionvalue = mlastmotionx ; break ; case vertical : default : initialmotionvalue = minitialmotiony ; lastmotionvalue = mlastmotiony ; break ; } switch ( mcurrentmode ) { case pull_from_end : newscrollvalue = math . round ( math . max ( initialmotionvalue - lastmotionvalue , _num ) / friction ) ; itemdimension = getfootersize ( ) ; break ; case pull_from_start : default : newscrollvalue = math . round ( math . min ( initialmotionvalue - lastmotionvalue , _num ) / friction ) ; itemdimension = getheadersize ( ) ; break ; } setheaderscroll ( newscrollvalue ) ; if ( newscrollvalue != _num && ! isrefreshing ( ) ) { float scale = math . abs ( newscrollvalue ) / ( float ) itemdimension ; switch ( mcurrentmode ) { case pull_from_end : mfooterlayout . onpull ( scale ) ; break ; case pull_from_start : default : mheaderlayout . onpull ( scale ) ; break ; } if ( mstate != state . pull_to_refresh && itemdimension >= math . abs ( newscrollvalue ) ) { setstate ( state . pull_to_refresh ) ; } else if ( mstate != state . release_to_refresh && itemdimension < math . abs ( newscrollvalue ) ) { setstate ( state . release_to_refresh ) ; } } }	actions a pull event.
public boolean requiresconnection ( ) { return _bool ; }	this semaphore implementation does use the database .
public static double tile2lat ( int y , int z ) { double n = math . pi - ( _num * math . pi * y ) / math . pow ( _num , z ) ; return math . todegrees ( math . atan ( math . sinh ( n ) ) ) ; }	returns the longitude for an y tile.
@ override public synchronized timeseriescollection updatecollection ( ) { return super . updatecollection ( ) ; }	run an update cycle . an update cycle consists of : - gathering raw metrics - creating a new , minimal context - applying decorators against the current and previous values - storing the collection values as the most recent capture.
public char skip ( int n ) { _pos += n ; if ( _length <= _pos ) { _pos = _string . length ( ) ; return done ; } else return _string . charat ( _pos ) ; }	skips the next n characters.
private boolean shouldinform ( localclientinfo info ) { long now = system . currenttimemillis ( ) ; if ( now < _nextallowedtime ) return _bool ; long allowed = bug_times . get ( info . getparsedbug ( ) ) ; return allowed == null || now >= allowed . longvalue ( ) ; }	determines if the bug has already been reported enough.
public void post ( runnable runnable ) { synchronized ( mqueue ) { mqueue . add ( runnable ) ; if ( mqueue . size ( ) == _num ) { schedulenextlocked ( ) ; } } }	schedule runnable to run after everything that ' s on the queue right now .
public static void clear ( ) { _clearcount ++ ; _statecount = _num ; _state = _str ; _featuremap . clear ( ) ; }	clears the internal state.
public static string tostringpretty ( jsonobject jsonobj , int level ) { stringbuffer buf = new stringbuffer ( ) ; buf . append ( _str ) ; buf . append ( fieldstostringpretty ( jsonobj , level + _num ) ) ; buf . append ( _str ) ; return buf . tostring ( ) ; }	returns a pretty printed string of the given json object , indented at the given level .
public boolean islaunchedfromjar ( ) { return ( lstjarfile . size ( ) > _num ) ; }	checks how the application was loaded : from jar or file system .
public logstream print ( double d ) { if ( ps != null ) { indent ( ) ; linebuffer . append ( d ) ; } return this ; }	writes a double value to this stream .
public static void deletedirectoryrecursively ( context context , file f , boolean onlycontent ) throws ioexception { if ( f . isdirectory ( ) ) { for ( file c : f . listfiles ( ) ) { deletedirectoryrecursively ( context , c , _bool ) ; } } if ( ! onlycontent ) { if ( ! f . delete ( ) ) { throw new ioexception ( _str + f ) ; } context . sendbroadcast ( new intent ( intent . action_media_scanner_scan_file , uri . parse ( _str + f . getabsolutepath ( ) ) ) ) ; } }	delete a directory recursively.
public static string nodesubtypetostring ( int subtype ) { string val = _str ; switch ( subtype ) { case noderepresentation . and_type : val = _str ; break ; case noderepresentation . or_type : val = _str ; break ; case noderepresentation . implies_type : val = _str ; break ; case noderepresentation . forall_type : val = _str ; break ; case noderepresentation . exists_type : val = _str ; break ; case noderepresentation . sqsub_type : val = _str ; break ; case noderepresentation . other_type : val = _str ; break ; } return val ; }	converts a noderepresentation subtype to a string.
public static void disposegraphicsconfig ( long pconfiginfo ) { oglrenderqueue rq = getinstance ( ) ; rq . lock ( ) ; try { oglcontext . setscratchsurface ( pconfiginfo ) ; renderbuffer buf = rq . getbuffer ( ) ; rq . ensurecapacityandalignment ( _num , _num ) ; buf . putint ( dispose_config ) ; buf . putlong ( pconfiginfo ) ; rq . flushnow ( ) ; } finally { rq . unlock ( ) ; } }	disposes the native memory associated with the given native graphics config info pointer on the single queue flushing thread .
private void addterm ( string term ) { integer index = termtoindex . get ( term ) ; if ( index == null ) { synchronized ( this ) { index = termtoindex . get ( term ) ; if ( index == null ) { index = integer . valueof ( termindexcounter . getandincrement ( ) ) ; termtoindex . put ( term , index ) ; } } } }	adds the term to the list of terms and gives it an index , or if the term has already been added , does nothing .
@ override public list < period > generateperiods ( datetimeunit datetimeunit ) { calendar cal = getcalendar ( ) ; boolean past = datetimeunit . getmonth ( ) >= ( getbasemonth ( ) + _num ) ; list < period > periods = lists . newarraylist ( ) ; datetimeunit = cal . minusyears ( datetimeunit , past ? _num : _num ) ; datetimeunit . setmonth ( getbasemonth ( ) + _num ) ; datetimeunit . setday ( _num ) ; calendar calendar = getcalendar ( ) ; for ( int i = _num ; i < _num ; i ++ ) { periods . add ( createperiod ( datetimeunit , cal ) ) ; datetimeunit = calendar . plusyears ( datetimeunit , _num ) ; } return periods ; }	generates financial yearly periods for the last 5 , current and next 5 financial years .
public final boolean isdragging ( ) { return dragging ; }	whether this title bar is currently being dragged .
@ override public void escape ( char [ ] buffer , int start , int length , boolean isattributevalue , writer outputwriter ) throws ioexception { for ( int i = start ; i < start + length ; i ++ ) { char ch = buffer [ i ] ; if ( ch == _str ) { outputwriter . write ( _str ) ; continue ; } if ( ch == _str ) { outputwriter . write ( _str ) ; continue ; } if ( ch == _str ) { outputwriter . write ( _str ) ; continue ; } if ( ch == _str && isattributevalue ) { outputwriter . write ( _str ) ; continue ; } if ( ch == _str && isattributevalue ) { outputwriter . write ( _str ) ; continue ; } if ( isxml11restrictedcharacter ( ch ) ) { outputwriter . write ( _str ) ; outputwriter . write ( integer . tohexstring ( ch ) ) ; outputwriter . write ( _str ) ; continue ; } outputwriter . write ( ch ) ; } }	escape restricted xml 1.
void encrypt ( bytebuffer src ) throws sslexception { if ( ! handshakecomplete ) { throw new illegalstateexception ( ) ; } if ( ! src . hasremaining ( ) ) { if ( outnetbuffer == null ) { outnetbuffer = emptybuffer ; } return ; } createoutnetbuffer ( src . remaining ( ) ) ; while ( src . hasremaining ( ) ) { sslengineresult result = sslengine . wrap ( src , outnetbuffer . buf ( ) ) ; if ( result . getstatus ( ) == sslengineresult . status . ok ) { if ( result . gethandshakestatus ( ) == sslengineresult . handshakestatus . need_task ) { dotasks ( ) ; } } else if ( result . getstatus ( ) == sslengineresult . status . buffer_overflow ) { outnetbuffer . capacity ( outnetbuffer . capacity ( ) << _num ) ; outnetbuffer . limit ( outnetbuffer . capacity ( ) ) ; } else { throw new sslexception ( _str + result . getstatus ( ) + _str + src + _str + outnetbuffer ) ; } } outnetbuffer . flip ( ) ; }	encrypt provided buffer . encrypted data returned by getoutnetbuffer ( ) .
public boolean codematches ( string querycode ) { int length = id . length ( ) ; if ( debug . debugging ( _str ) ) { debug . output ( _str + querycode + _str + id + _str + startindex + _str + length ) ; } return querycode . regionmatches ( _bool , startindex , id , _num , length ) ; }	a query method that answers of the given 15 digit code applies to this symbol part .
private static int parsenotificationid ( string id ) { try { return integer . parseint ( id ) ; } catch ( numberformatexception nfe ) { log . w ( tag , _str + id ) ; return - _num ; } }	parse the notification id from a string object .
private < t > property < t > prepare ( string key , property < t > property , t initialvalue ) { final changelistener < t > change = null ; property . setvalue ( initialvalue ) ; property . addlistener ( change ) ; change . changed ( property , null , initialvalue ) ; return property ; }	adds a listener to the specified property so that changes to it are reflected down to the source map .
protected void readtilleol ( ) throws ioexception { while ( m_tokenizer . nexttoken ( ) != streamtokenizer . tt_eol ) { } m_tokenizer . pushback ( ) ; }	reads and skips all tokens before next end of line token .
@ override public void clearanswer ( ) { datetime ldt = new datetime ( ) ; mtimepicker . setcurrenthour ( ldt . gethourofday ( ) ) ; mtimepicker . setcurrentminute ( ldt . getminuteofhour ( ) ) ; }	resets time to today .
public string readline ( ) throws ioexception { return keepcarriagereturns ? readuntilnewline ( ) : reader . readline ( ) ; }	reads the next line from the reader .
@ override public void dowork ( ) throws operatorexception { super . dowork ( ) ; runvectoroutput . deliver ( runvector ) ; }	overwrite to also return the performance ( run - ) vector.
public simpleusercontext ( authenticationprovider authprovider , string username , map < string , guacamoleconfiguration > configs ) { collection < string > connectionidentifiers = new arraylist < string > ( configs . size ( ) ) ; collection < string > connectiongroupidentifiers = collections . singleton ( root_identifier ) ; collection < connection > connections = new arraylist < connection > ( configs . size ( ) ) ; for ( map . entry < string , guacamoleconfiguration > configentry : configs . entryset ( ) ) { string identifier = configentry . getkey ( ) ; guacamoleconfiguration config = configentry . getvalue ( ) ; connection connection = new simpleconnection ( identifier , identifier , config ) ; connection . setparentidentifier ( root_identifier ) ; connections . add ( connection ) ; connectionidentifiers . add ( identifier ) ; } this . rootgroup = new simpleconnectiongroup ( root_identifier , root_identifier , connectionidentifiers , collections . < string > emptylist ( ) ) ; this . self = new simpleuser ( username , connectionidentifiers , connectiongroupidentifiers ) ; this . userdirectory = new simpleuserdirectory ( self ) ; this . connectiondirectory = new simpleconnectiondirectory ( connections ) ; this . connectiongroupdirectory = new simpleconnectiongroupdirectory ( collections . singleton ( this . rootgroup ) ) ; this . authprovider = authprovider ; }	creates a new simpleusercontext for the user with the given username which provides access to only those configurations within the given map .
public void reset ( ) { visitedget . clear ( ) ; visitedpost . clear ( ) ; for ( spiderparser parser : parsers ) { parser . removespiderparserlistener ( this ) ; } }	clears the previous process .
private static float callstaticfloatmethodv ( jnienvironment env , int classjref , int methodid , address argaddress ) throws exception { if ( tracejni ) vm . syswrite ( _str ) ; runtimeentrypoints . checkjnicountdowntogc ( ) ; try { object returnobj = jnihelpers . invokewithvararg ( methodid , argaddress , typereference . float ) ; return reflection . unwrapfloat ( returnobj ) ; } catch ( throwable unexpected ) { if ( tracejni ) unexpected . printstacktrace ( system . err ) ; env . recordexception ( unexpected ) ; return _num ; } }	callstaticfloatmethodv : invoke a static method that returns a float value.
public namedlist < object > tonamedlist ( ) { final simpleorderedmap < object > result = new simpleorderedmap < > ( ) ; for ( iterator < string > it = getparameternamesiterator ( ) ; it . hasnext ( ) ; ) { final string name = it . next ( ) ; final string [ ] values = getparams ( name ) ; if ( values . length == _num ) { result . add ( name , values [ _num ] ) ; } else { result . add ( name , values ) ; } } return result ; }	convert this to a namedlist.
private boolean isrepresentingtab ( string text ) { if ( text == null ) return _bool ; if ( isinsertingspacesfortab ( ) ) { if ( text . length ( ) == _num || text . length ( ) > getvisualtablengthpreference ( ) ) return _bool ; for ( int i = _num ; i < text . length ( ) ; i ++ ) { if ( text . charat ( i ) != _str ) return _bool ; } return _bool ; } else return text . length ( ) == _num && text . charat ( _num ) == _str ; }	tells whether the given inserted string represents hitting the tab key .
public monitorthread ( string name ) { super ( name ) ; }	creates a new schedulingthread object .
@ override public unitsrelations init ( processingenvironment env ) { elements = env . getelementutils ( ) ; m = unitsrelationstools . buildannomirrorwithdefaultprefix ( env , m . class ) ; km = unitsrelationstools . buildannomirrorwithspecificprefix ( env , m . class , prefix . kilo ) ; mm = unitsrelationstools . buildannomirrorwithspecificprefix ( env , m . class , prefix . milli ) ; m2 = unitsrelationstools . buildannomirrorwithnoprefix ( env , m2 . class ) ; km2 = unitsrelationstools . buildannomirrorwithnoprefix ( env , km2 . class ) ; mm2 = unitsrelationstools . buildannomirrorwithnoprefix ( env , mm2 . class ) ; s = unitsrelationstools . buildannomirrorwithdefaultprefix ( env , s . class ) ; h = unitsrelationstools . buildannomirrorwithnoprefix ( env , h . class ) ; mpers = unitsrelationstools . buildannomirrorwithnoprefix ( env , mpers . class ) ; kmperh = unitsrelationstools . buildannomirrorwithnoprefix ( env , kmperh . class ) ; mpers2 = unitsrelationstools . buildannomirrorwithnoprefix ( env , mpers2 . class ) ; return this ; }	constructs various annotationmirrors representing specific checker - framework provided units involved in the rules resolved in this unitsrelations implementation.
public static string [ ] tostringarray ( collection < string > collection ) { if ( collection == null ) { return null ; } return collection . toarray ( new string [ collection . size ( ) ] ) ; }	copy the given collection into a string array.
public void persist ( repositoryproxycache proxycache ) { persist ( proxycache , proxycache . getfilename ( ) ) ; }	warning : this is an i / o operation and this method is going to be performed in a different thread .
public string formatdeletenfsexportcmd ( string datamover , string path ) { stringbuilder cmd = new stringbuilder ( ) ; cmd . append ( _str ) ; cmd . append ( datamover ) ; cmd . append ( _str ) ; cmd . append ( _str ) ; cmd . append ( path ) ; return cmd . tostring ( ) ; }	create the command string for deleting file system export .
public final string matchcategories ( set < string > categories ) { if ( categories == null ) { return null ; } iterator < string > it = categories . iterator ( ) ; if ( mcategories == null ) { return it . hasnext ( ) ? it . next ( ) : null ; } while ( it . hasnext ( ) ) { final string category = it . next ( ) ; if ( ! mcategories . contains ( category ) ) { return category ; } } return null ; }	match this filter against an intent ' s categories.
@ override public void run ( ) { try { classreader reader = new classreader ( new fileinputstream ( this . classfile ) ) ; asmclassvisitor visitor = new asmclassvisitor ( this . dataprovider , this . config ) ; reader . accept ( visitor , classreader . skip_debug ) ; } catch ( exception e ) { logger . log ( level . severe , e . getmessage ( ) , e ) ; } }	main run method from runnable interface.
private void addlocationandtrackpropertychange ( ) { for ( location loc : locationmanager . getlist ( ) ) { loc . addpropertychangelistener ( this ) ; for ( track track : loc . gettracklist ( ) ) { track . addpropertychangelistener ( this ) ; schedule schedule = track . getschedule ( ) ; if ( schedule != null ) { schedule . addpropertychangelistener ( this ) ; } } } }	add property listeners for locations and tracks.
private void _schedule ( activity a , long starttime ) { if ( a . isscheduled ( ) ) { try { notifyall ( ) ; } catch ( exception e ) { } return ; } a . setstarttime ( starttime ) ; synchronized ( this ) { m_activities . add ( a ) ; a . setscheduled ( _bool ) ; if ( starttime < m_nexttime ) { m_nexttime = starttime ; notify ( ) ; } } }	schedules an activity with the manager .
void unregistercallback ( bluetoothcallback callback ) { synchronized ( mcallbacks ) { mcallbacks . remove ( callback ) ; } }	unregister to stop receiving callbacks for bluetooth events .
public void testhashcodeunequal ( ) { string a = _str ; int ascale = _num ; string b = _str ; int bscale = - _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; asserttrue ( _str , anumber . hashcode ( ) != bnumber . hashcode ( ) ) ; }	hashcode ( ) for unequal bigdecimals.
@ visiblefortesting static string escapesqlstring ( string string ) { return string . replaceall ( _str , _str ) ; }	escapes a sql string.
public static string [ ] toarray ( string arg ) { if ( arg == null ) { return new string [ _num ] ; } stringtokenizer tok = new stringtokenizer ( arg , _str ) ; string [ ] array = new string [ tok . counttokens ( ) ] ; int i = _num ; while ( tok . hasmoretokens ( ) ) { array [ i ] = tok . nexttoken ( ) ; i ++ ; } return ( array ) ; }	convert comma delimited and / or space string to array of strings.
private void appenduploadedentrytolog ( string id ) throws ioexception { filewriter writer = new filewriter ( mlogfile , _bool ) ; stringbuilder sb = new stringbuilder ( ) ; sb . append ( system . currenttimemillis ( ) / _num ) ; sb . append ( _str ) ; sb . append ( id ) ; sb . append ( _str ) ; try { writer . write ( sb . tostring ( ) ) ; } finally { writer . close ( ) ; } }	records the upload entry to a log file similar to what is done in chrome / app / breakpad_linux . cc.
private void renderleafnode ( final cnodenode treenode ) { final navinode graphnode = treenode . getnode ( ) ; if ( graphnode . isselected ( ) && graphnode . isvisible ( ) ) { setforeground ( selected_font_color ) ; } else if ( ! graphnode . isvisible ( ) ) { setforeground ( invisible_font_color ) ; } settooltiptext ( buildtooltip ( graphnode ) ) ; }	renders a leaf node .
public sector union ( double latitude , double longitude ) { if ( this . minlatitude < this . maxlatitude && this . minlongitude < this . maxlongitude ) { this . maxlatitude = math . max ( this . maxlatitude , latitude ) ; this . minlatitude = math . min ( this . minlatitude , latitude ) ; this . maxlongitude = math . max ( this . maxlongitude , longitude ) ; this . minlongitude = math . min ( this . minlongitude , longitude ) ; } else if ( ! double . isnan ( this . minlatitude ) && ! double . isnan ( this . minlongitude ) ) { this . maxlatitude = math . max ( this . minlatitude , latitude ) ; this . maxlongitude = math . max ( this . minlongitude , longitude ) ; this . minlatitude = math . min ( this . minlatitude , latitude ) ; this . minlongitude = math . min ( this . minlongitude , longitude ) ; } else { this . minlatitude = latitude ; this . minlongitude = longitude ; this . maxlatitude = double . nan ; this . maxlongitude = double . nan ; } return this ; }	sets this sector to the union of itself and a specified location .
public dauthoritykeyidentifier ( jdialog parent , publickey authoritypublickey , x500name authoritycertname , biginteger authoritycertserialnumber ) { super ( parent ) ; settitle ( res . getstring ( _str ) ) ; this . authoritypublickey = authoritypublickey ; initcomponents ( ) ; prepopulatewithauthoritycertdetails ( authoritycertname , authoritycertserialnumber ) ; }	creates a new dauthoritykeyidentifier dialog .
static void writeutf ( outputstream out , string str ) throws ioexception { for ( int i = _num , len = str . length ( ) ; i < len ; i ++ ) { int c = str . charat ( i ) ; if ( ( c >= _num ) && ( c <= _num ) ) { out . write ( c ) ; } else { if ( c > _num ) { out . write ( _num | ( ( c > > _num ) & _num ) ) ; out . write ( _num | ( ( c > > _num ) & _num ) ) ; out . write ( _num | ( ( c > > _num ) & _num ) ) ; } else { out . write ( _num | ( ( c > > _num ) & _num ) ) ; out . write ( _num | ( ( c > > _num ) & _num ) ) ; } } } }	write a utf string with a length to a stream .
public void test_getiterator ( ) { string test = _str ; try { attributedstring attrstring = new attributedstring ( test ) ; attributedcharacteriterator it = attrstring . getiterator ( ) ; assertequals ( _str , it . first ( ) , test . charat ( _num ) ) ; } catch ( exception e ) { fail ( _str + e . tostring ( ) ) ; } }	java . text . attributedstring # getiterator ( ) test of method java . text . attributedstring # getiterator ( ) .
private void handlenormalunassociated ( ) { int szssaregs = ssameth . getregcount ( ) ; for ( int ssareg = _num ; ssareg < szssaregs ; ssareg ++ ) { if ( ssaregsmapped . get ( ssareg ) ) { continue ; } registerspec ssaspec = getdefinitionspecforssareg ( ssareg ) ; if ( ssaspec == null ) continue ; int category = ssaspec . getcategory ( ) ; int ropreg = findnextunreservedropreg ( paramrangeend , category ) ; while ( ! canmapreg ( ssaspec , ropreg ) ) { ropreg = findnextunreservedropreg ( ropreg + _num , category ) ; } addmapping ( ssaspec , ropreg ) ; } }	maps all non - parameter , non - local variable registers .
public void createunderlying ( ) { if ( platform . isfxapplicationthread ( ) ) { options . createunderlying ( ) ; this . marker = new com . lynden . gmapsfx . javascript . object . marker ( options . convert ( ) ) ; } }	creates the underlying javascript peers.
private void onactionup ( motionevent event ) { if ( isdown ) { this . startx = _num ; this . starty = _num ; this . isdown = _bool ; } }	this method defines processes on motionevent . action_down.
private rectangle2d createalignedrectangle2d ( size2d dimensions , rectangle2d frame , horizontalalignment halign , verticalalignment valign ) { double x = double . nan ; double y = double . nan ; if ( halign == horizontalalignment . left ) { x = frame . getx ( ) ; } else if ( halign == horizontalalignment . center ) { x = frame . getcenterx ( ) - ( dimensions . width / _num ) ; } else if ( halign == horizontalalignment . right ) { x = frame . getmaxx ( ) - dimensions . width ; } if ( valign == verticalalignment . top ) { y = frame . gety ( ) ; } else if ( valign == verticalalignment . center ) { y = frame . getcentery ( ) - ( dimensions . height / _num ) ; } else if ( valign == verticalalignment . bottom ) { y = frame . getmaxy ( ) - dimensions . height ; } return new rectangle2d . double ( x , y , dimensions . width , dimensions . height ) ; }	creates a rectangle that is aligned to the frame .
public mailaddress ( internetaddress address ) throws addressexception { this ( address . getaddress ( ) ) ; }	constructs a mailaddress from an internetaddress , using only the email address portion ( an " addr - spec " , not " name - addr " , as defined in the rfc2822 3.
public double [ ] [ ] confusionmatrix ( ) { double [ ] [ ] newmatrix = new double [ m_confusionmatrix . length ] [ _num ] ; for ( int i = _num ; i < m_confusionmatrix . length ; i ++ ) { newmatrix [ i ] = new double [ m_confusionmatrix [ i ] . length ] ; system . arraycopy ( m_confusionmatrix [ i ] , _num , newmatrix [ i ] , _num , m_confusionmatrix [ i ] . length ) ; } return newmatrix ; }	returns a copy of the confusion matrix .
public void print ( int x ) { out . print ( x ) ; out . flush ( ) ; }	prints an integer to this output stream and flushes this output stream .
public static void beginstartingservice ( context context , intent intent ) { synchronized ( mstartingservicesync ) { if ( mstartingservice == null ) { powermanager pm = ( powermanager ) context . getsystemservice ( context . power_service ) ; mstartingservice = pm . newwakelock ( powermanager . partial_wake_lock , _str ) ; mstartingservice . setreferencecounted ( _bool ) ; } mstartingservice . acquire ( ) ; context . startservice ( intent ) ; } }	start the service to process the current event notifications , acquiring the wake lock before returning to ensure that the service will run .
public scannerexception ( errormessages message , int line ) { this ( null , errormessages . get ( message ) , message , line , - _num ) ; }	creates a new scannerexception with a message and line number .
private int findschemeseparator ( ) { return cachedssi == not_calculated ? cachedssi = uristring . indexof ( _str ) : cachedssi ; }	finds the first ' : '.
@ override public boolean test ( object receiver , string property , object [ ] args , object expectedvalue ) { if ( is_angular_cli_project_property . equals ( property ) ) { return testisangularcliproject ( receiver ) ; } return _bool ; }	tests if the receiver object is a project is a angular cli project and false otherwise .
public void refresh ( ) { label . settext ( string . valueof ( mathhelper . round ( val , _num ) ) ) ; if ( val == min ) minus . setenabled ( _bool ) ; else minus . setenabled ( _bool ) ; if ( val == max ) plus . setenabled ( _bool ) ; else plus . setenabled ( _bool ) ; if ( cb != null ) cb . callback ( val ) ; plus . repaint ( ) ; minus . repaint ( ) ; if ( progress != null ) { progress . setvalue ( val / max ) ; } }	refresh the element . this enables / disables any + or - buttons if the clamp is reached , as well as call the callback if required .
public void removecallback ( callback callback ) { mcallbacks . remove ( callback ) ; }	removes a previously added callback interface from this holder .
private boolean expectvlvresponse ( ) { boolean expected = boolean . false ; try { expected = ( boolean ) get ( expect_vlv_response ) ; } catch ( exception e ) { } return expected == null ? _bool : expected . booleanvalue ( ) ; }	check if this search result expects a vlv response control.
public void layoutcontainer ( final container parent ) { checklayout ( getmodel ( ) ) ; final insets insets = parent . getinsets ( ) ; final dimension size = parent . getsize ( ) ; final int width = size . width - ( insets . left + insets . right ) ; final int height = size . height - ( insets . top + insets . bottom ) ; final rectangle bounds = new rectangle ( insets . left , insets . top , width , height ) ; layout1 ( getmodel ( ) , bounds ) ; layout2 ( getmodel ( ) , bounds ) ; }	compute the bounds of all of the split / divider / leaf nodes in the layout model , and then set the bounds of each child component with a matching leaf node .
@ override public invocation . builder accept ( string ... mediatypes ) { clientrequestcontext . setacceptresponsetypesstr ( arrays . aslist ( mediatypes ) ) ; return this ; }	set accept media types .
public streamconsumer ( inputstream stream ) { in = new bufferedinputstream ( stream ) ; thread . start ( ) ; }	creates a streamconsumer for consuming the data from the input stream .
public static string substring ( string string , int beginindex , int length ) { if ( string == null ) { return null ; } final int endindex = beginindex + length ; if ( beginindex >= string . length ( ) ) { return empty ; } if ( endindex > string . length ( ) ) { return string . substring ( beginindex , string . length ( ) ) ; } return string . substring ( beginindex , endindex ) ; }	gets the sub string of the given string.
private static socketimpl createsocketimpl ( ) { try { return socketimplctor . newinstance ( ) ; } catch ( instantiationexception x ) { throw new assertionerror ( x ) ; } catch ( illegalaccessexception x ) { throw new assertionerror ( x ) ; } catch ( invocationtargetexception x ) { throw new assertionerror ( x ) ; } }	creates a sdp enabled socketimpl.
@ override public string encode ( ) { return name . substring ( _num , _num ) ; }	returns a parseable string representation of this componentsize .
void cancelall ( ) { synchronized ( currentrequests ) { for ( downloadrequest request : currentrequests ) { request . cancel ( ) ; } } currentrequests . clear ( ) ; }	cancel all the download .
protected void adddocs ( string index , string type , int number ) throws jsonprocessingexception { objectmapper mapper = new objectmapper ( ) ; for ( int i = _num ; i < number ; i ++ ) { index ( index , type , _str + i , mapper . writevalueasstring ( testdocument . createsimpledoc ( i ) ) ) ; } flush ( ) ; }	adds the specified number of docs to the type within index.
public void testpownegativenumtozeroexp ( ) { byte abytes [ ] = { _num , - _num , _num , _num , _num , _num , _num , - _num , - _num , _num } ; int asign = - _num ; int exp = _num ; byte rbytes [ ] = { _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . pow ( exp ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	exponentiation of a negative number to zero exponent .
public final parallelflux < t > doonerror ( consumer < ? super throwable > onerror ) { objects . requirenonnull ( onerror , _str ) ; return doonsignal ( this , null , null , onerror , null , null , null , null , null ) ; }	call the specified consumer with the exception passing through any ' rail ' .
public void simulatemethod ( sootmethod method , referencevariable thisvar , referencevariable returnvar , referencevariable params [ ] ) { string subsignature = method . getsubsignature ( ) ; if ( subsignature . equals ( _str ) ) { java_lang_system_arraycopy ( method , thisvar , returnvar , params ) ; return ; } else if ( subsignature . equals ( _str ) ) { java_lang_system_setin0 ( method , thisvar , returnvar , params ) ; return ; } else if ( subsignature . equals ( _str ) ) { java_lang_system_setout0 ( method , thisvar , returnvar , params ) ; return ; } else if ( subsignature . equals ( _str ) ) { java_lang_system_seterr0 ( method , thisvar , returnvar , params ) ; return ; } else if ( subsignature . equals ( _str ) ) { java_lang_system_initproperties ( method , thisvar , returnvar , params ) ; return ; } else if ( subsignature . equals ( _str ) ) { java_lang_system_maplibraryname ( method , thisvar , returnvar , params ) ; return ; } else if ( subsignature . equals ( _str ) ) { java_lang_system_getcallerclass ( method , thisvar , returnvar , params ) ; return ; } else { defaultmethod ( method , thisvar , returnvar , params ) ; return ; } }	implements the abstract method simulatemethod.
protected void loadvalue ( string svalue ) { try { value = long . parselong ( svalue . trim ( ) ) ; } catch ( numberformatexception nfe ) { reverttodefault ( ) ; } }	load value from property string value.
public void checkbounds ( ) { tflowbound . setenabled ( tsclipping . isselected ( ) ) ; tfupbound . setenabled ( tsclipping . isselected ( ) ) ; }	enable or disable the upper and lower bounds fields depending on state of rounding button .
public void remove ( int index ) { mcategories . remove ( index ) ; mtitles . remove ( index ) ; mvalues . remove ( index ) ; }	removes an existing value from the series .
public static boolean deletefilesanddirsrecursive ( final file directory ) { if ( directory == null || ! directory . isdirectory ( ) ) { log . e ( fileutils . class , _str ) ; return _bool ; } return deletefilesanddirs ( directory ) ; }	method deletes all files and subdirectories recursively from given directory . returns true if all files deleted false if at least one doesn ' t.
void render ( graphicscontext g , point2d viewportorigin ) { g . setglobalalpha ( life ) ; g . setglobalblendmode ( blendmode ) ; if ( image != null ) { g . save ( ) ; g . translate ( x - viewportorigin . getx ( ) , y - viewportorigin . gety ( ) ) ; g . scale ( radiusx * _num / image . getwidth ( ) , radiusy * _num / image . getheight ( ) ) ; g . drawimage ( image , _num , _num ) ; g . restore ( ) ; } else { g . setfill ( color ) ; g . filloval ( x - viewportorigin . getx ( ) , y - viewportorigin . gety ( ) , radiusx * _num , radiusy * _num ) ; } }	renders particle to g context.
public int position ( ) { return buff . position ( ) ; }	get the current position .
@ override public void write ( string str , int off , int len ) throws ioexception { final int off_plus_len = off + len ; for ( int i = off ; i < off_plus_len ; ) { char c = str . charat ( i ++ ) ; if ( c < _num ) { _bytes [ _index ] = ( byte ) c ; if ( ++ _index >= _bytes . length ) { flushbuffer ( ) ; } } else { write ( c ) ; } } }	writes a portion of a string .
public void writetonbt ( final nbttagcompound nbt ) { final nbttaglist modulesnbt = new nbttaglist ( ) ; for ( final module module : modules ) { final nbttagcompound modulenbt = new nbttagcompound ( ) ; if ( module != null ) { module . writetonbt ( modulenbt ) ; } modulesnbt . appendtag ( modulenbt ) ; } nbt . settag ( tag_modules , modulesnbt ) ; lock . ifpresent ( null ) ; lock . ifpresent ( null ) ; }	write the state of all modules and pipes to the specified nbt tag .
void sendbufferifnotempty ( ) throws ioexception { if ( buf != null && buf . position ( ) > _num ) sendbuffer ( ) ; }	send local buffer if at least something is stored there .
public void onsharedpreferencechanged ( sharedpreferences sharedpreferences , string key ) { if ( key . equals ( getstring ( r . string . pref_key_notification ) ) ) { setnotification ( sharedpreferences . getboolean ( key , _bool ) ) ; } else if ( key . equals ( getstring ( r . string . pref_key_gmail_signature ) ) ) { setgmailsignatureprefdescription ( sharedpreferences . getboolean ( key , _bool ) ) ; } else if ( key . equals ( getstring ( r . string . pref_key_sms_signature ) ) ) { setsmssignatureprefdescription ( sharedpreferences . getboolean ( key , _bool ) ) ; } }	general change monitor that can be used to call updates based on the preference that was updated .
public void initportparameters ( serialport port ) { initialized = _bool ; if ( port != null ) { cbport . setselecteditem ( port . getname ( ) ) ; cbbaudrate . setselecteditem ( string . valueof ( port . getbaudrate ( ) ) ) ; cbparity . setselectedindex ( port . getparity ( ) ) ; cbdatabits . setselectedindex ( port . getdatabits ( ) - _num ) ; cbstopbits . setselectedindex ( port . getstopbits ( ) - _num ) ; int prt = port . getflowcontrolmode ( ) ; cbprotocolrx . setselectedindex ( ( prt & serialport . flowcontrol_rtscts_in ) != _num ? _num : ( prt & serialport . flowcontrol_xonxoff_in ) != _num ? _num : _num ) ; cbprotocoltx . setselectedindex ( ( prt & serialport . flowcontrol_rtscts_out ) != _num ? _num : ( prt & serialport . flowcontrol_xonxoff_out ) != _num ? _num : _num ) ; btndsr . setselected ( port . isdsr ( ) ) ; btncts . setselected ( port . iscts ( ) ) ; btncd . setselected ( port . iscd ( ) ) ; btndtr . setselected ( port . isdtr ( ) ) ; btnrts . setselected ( port . isrts ( ) ) ; } initialized = _bool ; }	initialize all port parameters port - & gt ; dialog.
public void addpreloadentry ( gridcacheentryinfo info ) { if ( preloadentries == null ) preloadentries = new arraylist < > ( ) ; preloadentries . add ( info ) ; }	adds preload entry to lock response .
private void putoffuniform ( final player player ) { if ( uniform . ispartof ( player . getoutfit ( ) ) ) { player . returntooriginaloutfit ( ) ; } }	takes away the player ' s uniform , if the he is wearing it .
public static void movefile ( final file srcfile , final file destfile ) throws ioexception { if ( srcfile == null ) { throw new nullpointerexception ( _str ) ; } if ( destfile == null ) { throw new nullpointerexception ( _str ) ; } if ( ! srcfile . exists ( ) ) { throw new filenotfoundexception ( _str + srcfile + _str ) ; } if ( srcfile . isdirectory ( ) ) { throw new ioexception ( _str + srcfile + _str ) ; } if ( destfile . exists ( ) ) { throw new ioexception ( _str + destfile + _str ) ; } if ( destfile . isdirectory ( ) ) { throw new ioexception ( _str + destfile + _str ) ; } final boolean rename = srcfile . renameto ( destfile ) ; if ( ! rename ) { copyfile ( srcfile , destfile ) ; if ( ! srcfile . delete ( ) ) { parsefileutils . deletequietly ( destfile ) ; throw new ioexception ( _str + srcfile + _str + destfile + _str ) ; } } }	moves a file . < p > when the destination file is on another file system , do a " copy and delete " .
public synchronized scanmanagerconfig readfromfile ( ) throws ioexception { final file f = new file ( file ) ; if ( ! f . exists ( ) ) throw new ioexception ( _str + file ) ; if ( ! f . canread ( ) ) throw new ioexception ( _str + file ) ; try { return read ( f ) ; } catch ( jaxbexception x ) { final ioexception io = new ioexception ( _str + file + _str + x , x ) ; throw io ; } }	reads the configuration from the xml configuration file .
public void delete ( string name ) throws ioexception { if ( name . equalsignorecase ( issuer ) ) { names = null ; } else { throw new ioexception ( _str + _str ) ; } encodethis ( ) ; }	deletes the attribute value .
public compileclassnotfound ( exception cause ) { super ( cause . getmessage ( ) ) ; _cause = cause ; }	create a compileclassnotfound exception wrapped around a root cause .
public symgraph ( motif motif ) { this . motif = motif ; colorstorecheck = new hashset < integer > ( ) ; topmotifnodetocolor = new int [ motif . getnrmotifnodes ( ) ] ; colortobottommotifnode = new hashmap < integer , list < integer > > ( ) ; colortotopmotifnode = new hashmap < integer , list < integer > > ( ) ; arraylist < integer > list1 = new arraylist < integer > ( ) ; arraylist < integer > list2 = new arraylist < integer > ( ) ; for ( int i = _num ; i < topmotifnodetocolor . length ; i ++ ) { list1 . add ( i ) ; list2 . add ( i ) ; } colortobottommotifnode . put ( _num , list2 ) ; colortotopmotifnode . put ( _num , list1 ) ; }	create an initial opp.
public static boolean anydimensionhasitems ( collection < dimensionalobject > dimensions ) { if ( dimensions == null || dimensions . isempty ( ) ) { return _bool ; } for ( dimensionalobject dim : dimensions ) { if ( dim . hasitems ( ) ) { return _bool ; } } return _bool ; }	indicates whether at least one of the given dimenions has at least one item .
private void opencurrentandmaybenext ( final boolean opennext ) { log . info ( _str ) ; synchronized ( this ) { log . info ( _str ) ; closecursor ( ) ; if ( mplaylistlen == _num || mplaylist == null ) { return ; } stop ( _bool ) ; mplaypos = math . min ( mplaypos , mplaylist . length - _num ) ; updatecursor ( mplaylist [ mplaypos ] ) ; while ( _bool ) { if ( mcursor != null && ! mcursor . isclosed ( ) && openfile ( mediastore . audio . media . external_content_uri + _str + mcursor . getlong ( idcolidx ) ) ) { break ; } closecursor ( ) ; if ( mopenfailedcounter ++ < _num && mplaylistlen > _num ) { final int pos = getnextposition ( _bool ) ; if ( scheduleshutdownandnotifyplaystatechange ( pos ) ) return ; mplaypos = pos ; stop ( _bool ) ; mplaypos = pos ; updatecursor ( mplaylist [ mplaypos ] ) ; } else { mopenfailedcounter = _num ; log . warn ( _str ) ; scheduledelayedshutdown ( ) ; if ( missupposedtobeplaying ) { missupposedtobeplaying = _bool ; notifychange ( playstate_changed ) ; } return ; } } if ( opennext ) { setnexttrack ( ) ; } } }	called to open a new file as the current track and prepare the next for playback.
protected omnode createdtd ( ) throws omexception { throw new omexception ( _str ) ; }	method createdtd . overriding the default behaviour as a soapmessage should not have a dtd .
private ivgenerator ( ) { }	creates a new instance of ivgenerator.
private void createoverviewpage ( ) { remapoverview overview = new remapoverview ( migrationtask , getcontainer ( ) ) ; int index = addpage ( overview . getcontrol ( ) ) ; setpagetext ( index , _str ) ; tasklisteners . add ( overview ) ; }	create the overview page showing informations about the migrationtask .
public void warning2 ( final string filename , int ln , int col , object msg , string source ) { warning ( filename , ln , col , msg . tostring ( ) , source ) ; }	c : the error ( ) and warning ( ) reporting system use error codes.
public soapconnection opensoapconnection ( ) throws soapexception { return soapconnectionfactory . createconnection ( ) ; }	opens a soap connection .
public static < u , v > string printmap ( final map < u , v > map , final converter < u > keyconverter , final converter < v > valueconverter ) { final stringbuilder sb = new stringbuilder ( _str ) ; string separator = _str ; for ( final entry < u , v > entry : map . entryset ( ) ) { sb . append ( separator ) ; sb . append ( keyconverter . convert ( entry . getkey ( ) ) ) ; sb . append ( _str ) ; sb . append ( valueconverter . convert ( entry . getvalue ( ) ) ) ; separator = _str ; } sb . append ( _str ) ; return sb . tostring ( ) ; }	pretty prints a map , using the provided converters for the keys and values .
public void findandinit ( object someobj ) { if ( someobj instanceof com . bbn . openmap . mapbean ) { debug . message ( _str , _str ) ; setsourcemap ( ( mapbean ) someobj ) ; } }	called when the overviewmaphandler is added to the beancontext , and whenever an object is added to the beancontext after that.
public static double cdf ( double x , double mu , double shape ) { if ( ! ( x > _num ) ) { return _num ; } final double v0 = x / mu ; final double v1 = math . sqrt ( shape / x ) ; if ( v1 == _num ) { return v0 > _num ? _num : _num ; } double c1 = normaldistribution . standardnormalcdf ( v1 * ( v0 - _num ) ) ; double c2 = normaldistribution . standardnormalcdf ( - v1 * ( v0 + _num ) ) ; return ( c2 > _num ) ? c1 + math . exp ( _num * shape / mu ) * c2 : c1 ; }	cumulative probability density function ( cdf ) of a wald distribution .
protected void bflash ( ) throws saxexception { if ( mbuffidx >= _num ) { mhandcont . characters ( mbuff , _num , ( mbuffidx + _num ) ) ; mbuffidx = - _num ; } }	reports characters and empties the parser ' s buffer.
protected mac ( macspi macspi , provider provider , string algorithm ) { this . spi = macspi ; this . provider = provider ; this . algorithm = algorithm ; serviceiterator = null ; lock = null ; }	creates a mac object .
public static string pathtostring ( string dim , string [ ] path ) { string [ ] fullpath = new string [ _num + path . length ] ; fullpath [ _num ] = dim ; system . arraycopy ( path , _num , fullpath , _num , path . length ) ; return pathtostring ( fullpath , fullpath . length ) ; }	turns a dim + path into an encoded string .
public static cdcsession createcdcsessionviadomainauth ( string servername , string username , string userpassword ) { if ( servername == null || servername . length ( ) == _num ) { throw new illegalargumentexception ( _str ) ; } if ( username == null || username . length ( ) == _num ) { throw new illegalargumentexception ( _str ) ; } return new cdcsession ( servername , username , userpassword ) ; }	instantiates a cdcsession for a specified domain user for a specified server .
protected static dfp expinternal ( final dfp a ) { dfp y = a . getone ( ) ; dfp x = a . getone ( ) ; dfp fact = a . getone ( ) ; dfp py = new dfp ( y ) ; for ( int i = _num ; i < _num ; i ++ ) { x = x . multiply ( a ) ; fact = fact . divide ( i ) ; y = y . add ( x . multiply ( fact ) ) ; if ( y . equals ( py ) ) { break ; } py = new dfp ( y ) ; } return y ; }	computes e to the given power.
public urlconnection openconnection ( ) throws ioexception { return streamhandler . openconnection ( this ) ; }	returns a new connection to the resource referred to by this url .
public static arraylist < string [ ] > linestoarray ( arraylist < string > inline ) { arraylist < string [ ] > framesentab = new arraylist < > ( ) ; for ( int i = _num ; i < inline . size ( ) ; i ++ ) { framesentab . add ( linetoarray ( inline . get ( i ) ) ) ; } return framesentab ; }	convert arraylist of string into arraylist of string [ ] ( split with spaces ).
@ override public int la ( int i ) { int la = super . la ( i ) ; return character . tolowercase ( la ) ; }	overrides antlrstringstream lookahead for case insensitivity .
public void deselect_all ( ) { arrays . fill ( sel_array , _bool ) ; }	deselects all item types .
@ override public boolean cantransfercriticals ( int loc ) { return _bool ; }	protos can ' t transfer crits .
private void calculatesizes ( final graphics g ) { m_rowheight = getrowheight ( g ) ; m_charheight = getcharheight ( g ) ; m_charwidth = getcharacterwidth ( g ) ; }	calculates current character and row sizes .
public static iterable < gatewaymetastate . indexmetawriteinfo > resolvestatestobewritten ( immutableset < string > previouslywrittenindices , set < string > potentiallyunwrittenindices , metadata previousmetadata , metadata newmetadata ) { list < gatewaymetastate . indexmetawriteinfo > indicestowrite = new arraylist < > ( ) ; for ( string index : potentiallyunwrittenindices ) { indexmetadata newindexmetadata = newmetadata . index ( index ) ; indexmetadata previousindexmetadata = previousmetadata == null ? null : previousmetadata . index ( index ) ; string writereason = null ; if ( previouslywrittenindices . contains ( index ) == _bool || previousindexmetadata == null ) { writereason = _str ; } else if ( previousindexmetadata . getversion ( ) != newindexmetadata . getversion ( ) ) { writereason = _str + previousindexmetadata . getversion ( ) + _str + newindexmetadata . getversion ( ) + _str ; } if ( writereason != null ) { indicestowrite . add ( new gatewaymetastate . indexmetawriteinfo ( newindexmetadata , previousindexmetadata , writereason ) ) ; } } return indicestowrite ; }	loads the current meta state for each index in the new cluster state and checks if it has to be persisted.
protected double applyfunction ( double value ) { switch ( m_operator ) { case _str : return math . log ( value ) ; case _str : return math . abs ( value ) ; case _str : return math . cos ( value ) ; case _str : return math . exp ( value ) ; case _str : return math . sqrt ( value ) ; case _str : return math . floor ( value ) ; case _str : return math . ceil ( value ) ; case _str : return math . rint ( value ) ; case _str : return math . tan ( value ) ; case _str : return math . sin ( value ) ; } return double . nan ; }	apply this operator ( function ) to the supplied argument.
public remoteevent dequeue ( ) { uuid uuid = _readyevents . poll ( ) ; if ( uuid == null ) return null ; singleproducer producer = getproducer ( uuid ) ; return producer . popnextreadyevent ( ) ; }	remove and return the next event in queue.
public tcpdiscoveryvmipfinder ( ) { }	constructs new ip finder .
public invalidpropertiesformatexception ( string message ) { super ( message ) ; }	constructs an invalidpropertiesformatexception with the specified detail message .
public subcommand ( idefinition definition , resourcebundle rb , string name , list mandatoryoptions , list optionaloptions , list optionaliases , string implclassname , boolean websupport , string deprecationwarning ) throws cliexception { this . definition = definition ; this . name = name ; this . rb = rb ; this . implclassname = implclassname ; this . websupport = websupport ; this . deprecationwarning = deprecationwarning ; set shortoptions = new hashset ( ) ; parseoptions ( mandatoryoptions , this . mandatoryoptions , shortoptions ) ; parseoptions ( optionaloptions , this . optionaloptions , shortoptions ) ; parsealiases ( optionaliases ) ; }	creates a sub command object .
public static boolean canaddclassinpackageof ( class < ? > cls ) { final package beanpackage = cls . getpackage ( ) ; if ( beanpackage != null ) { if ( beanpackage . issealed ( ) ) { return _bool ; } string pname = beanpackage . getname ( ) ; if ( pname . startswith ( _str ) || pname . startswith ( _str ) ) { return _bool ; } } return _bool ; }	helper method called to check whether it is acceptable to create a new class in package that given class is part of.
public static jsontoken deserialize ( final string jwt ) throws exception { jsontokenparser parser = new jsontokenparser ( verifierproviders , new abelanatokenaudiencechecker ( backendconstants . token_issuer ) ) ; return parser . deserialize ( jwt ) ; }	deserializes the jwt signed token .
public void swapsuggestions ( final list < ? extends searchsuggestion > newsearchsuggestions ) { collections . reverse ( newsearchsuggestions ) ; swapsuggestions ( newsearchsuggestions , _bool ) ; }	clears the current suggestions and replaces it with the provided list of new suggestions .
boolean shouldanimatesearchprovidericon ( selectiontype selectiontype , boolean isshowing ) { if ( isshowing || contextualsearchfieldtrial . areextrasearchbaranimationsdisabled ( ) ) { return _bool ; } if ( selectiontype == selectiontype . tap ) { long currenttimemillis = system . currenttimemillis ( ) ; long lastanimatedtimemillis = mpreferencemanager . getcontextualsearchlastanimationtime ( ) ; if ( math . abs ( currenttimemillis - lastanimatedtimemillis ) > one_day_in_millis ) { mpreferencemanager . setcontextualsearchlastanimationtime ( currenttimemillis ) ; return _bool ; } else { return _bool ; } } else if ( selectiontype == selectiontype . long_press ) { return getpromoopencount ( ) == _num ; } return _bool ; }	the search provider icon is animated every time on long press if the user has never opened the panel before and once a day on tap .
public void waitfor ( ) { checkstarted ( ) ; try { if ( myinputprocessor != null && myprocess != null ) { myinputprocessor . process ( myprocess . getoutputstream ( ) ) ; } } finally { waitforprocess ( ) ; } }	wait for process termination.
public static string extracturifromaddress ( string addr ) { string uri = addr ; int index = addr . indexof ( _str ) ; if ( index != - _num ) { uri = addr . substring ( index + _num , addr . indexof ( _str , index ) ) ; } return uri ; }	extract the uri part of a sip address.
pbkdf2keyimpl ( pbekeyspec keyspec , string prfalgo ) throws invalidkeyspecexception { char [ ] passwd = keyspec . getpassword ( ) ; if ( passwd == null ) { this . passwd = new char [ _num ] ; } else { this . passwd = passwd . clone ( ) ; } byte [ ] passwdbytes = getpasswordbytes ( this . passwd ) ; this . salt = keyspec . getsalt ( ) ; if ( salt == null ) { throw new invalidkeyspecexception ( _str ) ; } this . itercount = keyspec . getiterationcount ( ) ; if ( itercount == _num ) { throw new invalidkeyspecexception ( _str ) ; } else if ( itercount < _num ) { throw new invalidkeyspecexception ( _str ) ; } int keylength = keyspec . getkeylength ( ) ; if ( keylength == _num ) { throw new invalidkeyspecexception ( _str ) ; } else if ( keylength < _num ) { throw new invalidkeyspecexception ( _str ) ; } try { this . prf = mac . getinstance ( prfalgo , sunjce . getinstance ( ) ) ; } catch ( nosuchalgorithmexception nsae ) { invalidkeyspecexception ike = new invalidkeyspecexception ( ) ; ike . initcause ( nsae ) ; throw ike ; } this . key = derivekey ( prf , passwdbytes , salt , itercount , keylength ) ; }	creates a pbe key from a given pbe key specification .
private static void showdirectorycreationerror ( final string directory ) { final string message = _str + _str ; final string description = cutilityfunctions . createdescription ( string . format ( _str , directory ) , new string [ ] { _str } , new string [ ] { _str , _str } ) ; navierrordialog . show ( null , message , description ) ; }	shows a error dialog in case creating a directory failed .
static byte [ ] pad ( byte [ ] data ) { int len ; if ( data . length < _num ) len = data . length ; else len = data . length % _num ; if ( len == _num ) return data ; else { byte [ ] padding = new byte [ _num - len + data . length ] ; for ( int i = padding . length - _num ; i > data . length - _num ; i -- ) { padding [ i ] = _num ; } system . arraycopy ( data , _num , padding , _num , data . length ) ; return padding ; } }	pads the data so that its length is a multiple of 8 bytes .
public void serialize ( dataoutput out ) throws ioexception { out . writeutf ( id ) ; out . writeutf ( version ) ; out . writeint ( sourcefiles . size ( ) ) ; for ( entry < string , list < revisionfile > > e : sourcefiles . entryset ( ) ) { out . writeutf ( e . getkey ( ) ) ; list < revisionfile > files = e . getvalue ( ) ; out . writeint ( files . size ( ) ) ; for ( revisionfile file : files ) { out . writeutf ( file . filename ) ; out . writelong ( file . size ) ; } } }	serialize the token data for communication between server and client .
public namedcolumnprojection ( string [ ] names , boolean include ) { m_names = new hashset ( ) ; for ( int i = _num ; i < names . length ; ++ i ) m_names . add ( names [ i ] ) ; m_include = include ; }	create a new namedcolumnprojection .
public static timeseriesdata serializableinstance ( ) { list < string > varnames = new arraylist < > ( ) ; varnames . add ( _str ) ; varnames . add ( _str ) ; return new timeseriesdata ( new tetradmatrix ( _num , _num ) , varnames ) ; }	generates a simple exemplar of this class to test serialization .
@ override public void writevertices ( final outputstream outputstream , final iterator < vertex > vertexiterator , final direction direction ) throws ioexception { final bufferedwriter writer = new bufferedwriter ( new outputstreamwriter ( outputstream ) ) ; try ( final bytearrayoutputstream baos = new bytearrayoutputstream ( ) ) { if ( wrapadjacencylist ) writer . write ( _str + graphsontokens . vertices + _str ) ; while ( vertexiterator . hasnext ( ) ) { writevertex ( baos , vertexiterator . next ( ) , direction ) ; writer . write ( new string ( baos . tobytearray ( ) ) ) ; if ( wrapadjacencylist ) { if ( vertexiterator . hasnext ( ) ) writer . write ( _str ) ; } else { writer . newline ( ) ; } baos . reset ( ) ; } if ( wrapadjacencylist ) writer . write ( _str ) ; } writer . flush ( ) ; }	writes a list of vertices in adjacency list format where vertices are written with edges from both directions.
collection < ? extends clientrequestresult > handleretrieveconfigurationsrequest ( final clientrequest configurationrequest , final session session , final destination replydestination ) { if ( configurationrequest . getrequestparameter ( ) != null ) { return configurationloader . getconfigurationreports ( configurationrequest . getrequestparameter ( ) ) ; } else { return configurationloader . getconfigurationreports ( ) ; } }	inner method which handles a request to retrieve configuration reports.
public static boolean containsclass ( @ notnull file file , string classname ) { string entrypath = classname . replace ( _str , _str ) + _str ; return containsentry ( file , entrypath ) ; }	returns true if the given.
private double sin ( double angle ) { while ( angle >= _num ) { angle -= _num ; } double value = angle / _num * math . pi ; return math . sin ( value ) ; }	gets the sinus of the angle .
public void remove ( t graphic ) { synchronized ( mlock ) { mgraphics . remove ( graphic ) ; } postinvalidate ( ) ; }	removes a graphic from the overlay .
private static void launchdebugger ( string dmlscriptstr , string fnameoptconfig , map < string , string > argvals , boolean parsepydml ) throws parseexception , ioexception , dmlruntimeexception , dmldebuggerexception , languageexception , hopsexception , lopsexception { dmldebuggerprograminfo dbprog = new dmldebuggerprograminfo ( ) ; dmlconfig conf = dmlconfig . readconfigurationfile ( fnameoptconfig ) ; configurationmanager . setglobalconfig ( conf ) ; aparserwrapper parser = aparserwrapper . createparser ( parsepydml ) ; dmlprogram prog = parser . parse ( dml_file_path_antlr_parser , dmlscriptstr , argvals ) ; dmltranslator dmlt = new dmltranslator ( prog ) ; dmlt . livevariableanalysis ( prog ) ; dmlt . validateparsetree ( prog ) ; dmlt . constructhops ( prog ) ; dmlt . rewritehopsdag ( prog ) ; dmlt . constructlops ( prog ) ; dbprog . rtprog = prog . getruntimeprogram ( conf ) ; try { inithadoopexecution ( conf ) ; dmldebugger systemmldb = new dmldebugger ( dbprog , dmlscriptstr ) ; systemmldb . runsystemmldebugger ( ) ; } finally { cleanuphadoopexecution ( conf ) ; } }	launchdebugger : launcher for dml debugger . this method should be called after execution and debug properties have been correctly set , and customized parameters have been put into _argvals.
public static final index createtestbankindexapprovedon ( ) { index lastname = new index ( _str ) ; lastname . isunique ( _bool ) ; arraylist < indexfield > fields = new arraylist < > ( _num ) ; fields . add ( new indexfield ( _str , fielddatatype . date_time ) ) ; lastname . setfields ( fields ) ; lastname . settable ( fixtures . createtestworldbanktable ( ) ) ; return lastname ; }	creates at test index for bank load approved on date.
public synchronized void accessed ( object object ) { historylist . remove ( object ) ; historylist . add ( object ) ; }	adds object to history .
public static boolean isempty ( string string ) { return string == null || string . length ( ) <= _num ; }	check string is null or empty.
@ override @ suppresswarnings ( _str ) protected void heapifyupcomparable ( int pos , object elem ) { final comparable < object > cur = ( comparable < object > ) elem ; while ( pos > _num ) { final int parent = ( pos - _num ) > > > _num ; object par = queue [ parent ] ; if ( cur . compareto ( par ) >= _num ) { break ; } queue [ pos ] = par ; index . put ( par , pos ) ; pos = parent ; } queue [ pos ] = cur ; index . put ( cur , pos ) ; }	execute a " heapify upwards " aka " siftup ".
private void updatereleaselocks ( ) throws cacheexception { if ( numlocks . addandget ( - _num ) < _num ) { throw new cacheexception ( _str ) ; } if ( evictionpolicy == evictionpolicy . lru ) { timestamp . set ( system . nanotime ( ) ) ; } else if ( evictionpolicy == evictionpolicy . lfu ) { timestamp . addandget ( _num ) ; } else if ( evictionpolicy == evictionpolicy . min_evict ) { } else { throw new cacheexception ( _str + evictionpolicy . name ( ) ) ; } }	updates the locks depending on the eviction policy selected.
public static short toshort ( char c ) { return short . valueof ( toshortvalue ( c ) ) ; }	cast a char value to a short object ( reference type ).
public static void encodedimension ( float value , byte dest [ ] , int offset ) { numericutils . inttosortablebytes ( numericutils . floattosortableint ( value ) , dest , offset ) ; }	encode single float dimension.
public long minflt ( ) { return long . parselong ( fields [ _num ] ) ; }	the number of minor faults the process has made which have not required loading a memory page from disk .
public static string tostring ( final float value ) { return float . tostring ( value ) ; }	converts the given value to the xml string value .
public void endfilterinterval ( ) { endmillis = system . currenttimemillis ( ) ; totalfiltermillis += ( endmillis - intervalstartmillis ) ; state = taskstate . other ; }	add time for a filter operation interval .
public string process ( string to_process ) { if ( to_process == null || to_process . length ( ) == _num ) return _str ; string tmp = _str ; stringtokenizer st = new stringtokenizer ( to_process , _str , _bool ) ; stringbuffer newvalue = new stringbuffer ( to_process . length ( ) + _num ) ; while ( st . hasmoretokens ( ) ) { tmp = st . nexttoken ( ) ; if ( hasattribute ( tmp ) ) newvalue . append ( ( string ) get ( tmp ) ) ; else newvalue . append ( tmp ) ; } return newvalue . tostring ( ) ; }	this method actually performs the filtering .
@ benchmark public long test2_usingforeachandmapentry ( ) throws ioexception { long i = _num ; for ( map . entry < integer , integer > pair : map . entryset ( ) ) { i += pair . getkey ( ) + pair . getvalue ( ) ; } return i ; }	2 . using foreach and map . entry.
public static final void writelistxml ( list val , string name , xmlserializer out ) throws xmlpullparserexception , java . io . ioexception { if ( val == null ) { out . starttag ( null , _str ) ; out . endtag ( null , _str ) ; return ; } out . starttag ( null , _str ) ; if ( name != null ) { out . attribute ( null , _str , name ) ; } int n = val . size ( ) ; int i = _num ; while ( i < n ) { writevaluexml ( val . get ( i ) , null , out ) ; i ++ ; } out . endtag ( null , _str ) ; }	flatten a list into an xmlserializer.
public int hashcode ( object key ) { return ( key . hashcode ( ) & _num ) % this . keytable . length ; }	return the hashcode for the key parameter.
public atomicarraybase ( e [ ] array ) { this . array = arrays . copyof ( array , array . length , object [ ] . class ) ; }	creates a new atomicarraybase with the same length as , and all elements copied from , the given array .
public void apply ( ) { setspeedmap ( ) ; setnxdata ( ) ; }	apply to classes that use this data.
public void push ( final string value ) { if ( value == null ) { mv . visitinsn ( opcodes . aconst_null ) ; } else { mv . visitldcinsn ( value ) ; } }	generates the instruction to push the given value on the stack .
public void init ( ) { m_projecttree . setselectionpath ( new treepath ( m_projecttree . getrootnode ( ) ) ) ; }	selects the root node of the project tree .
public int read ( ) throws ioexception { return is . read ( ) ; }	reads the next character .
private void displaycalendar ( ) { keynamepair pp = ( keynamepair ) fieldresource . getselecteditem ( ) ; if ( pp == null ) return ; int s_resource_id = pp . getkey ( ) ; m_massignment . sets_resource_id ( s_resource_id ) ; timestamp date = fielddate . gettimestamp ( ) ; int index = timepane . getselectedindex ( ) ; log . config ( _str + index + _str + s_resource_id + _str + date ) ; m_loading = _bool ; if ( index == _num ) dayschedule . recreate ( s_resource_id , date ) ; else if ( index == _num ) weekschedule . recreate ( s_resource_id , date ) ; else monthschedule . recreate ( s_resource_id , date ) ; m_loading = _bool ; repaint ( ) ; }	display calendar for selected resource , time ( day / week / month ) and date.
public static void assertexception ( runtimeexception exception , runnable expression , string errormessage ) { if ( verbose ) { log ( _str + exception + _str + expression + _str + errormessage + _str ) ; } try { expression . run ( ) ; } catch ( runtimeexception failure ) { if ( exception . getclass ( ) != failure . getclass ( ) ) { testutils . fail ( errormessage ) ; } return ; } testutils . fail ( errormessage ) ; }	asserts that a certain exception is raised.
public boolean isparitycorrect ( byte [ ] [ ] shards , int firstbyte , int bytecount ) { checkbuffersandsizes ( shards , firstbyte , bytecount ) ; byte [ ] [ ] tocheck = new byte [ parityshardcount ] [ ] ; system . arraycopy ( shards , datashardcount , tocheck , _num , parityshardcount ) ; return codingloop . checksomeshards ( parityrows , shards , datashardcount , tocheck , parityshardcount , firstbyte , bytecount , null ) ; }	returns true if the parity shards contain the right data .
protected void onsendsuccess ( recordbuffer < r > buffer ) { sendsuccess . incrementandget ( ) ; logger . trace ( _str , name ( ) , buffer ) ; try { checkpointer . savecheckpoint ( buffer ) ; } catch ( exception e ) { logger . error ( _str , name ( ) , buffer , e ) ; } }	this method should not raise any exceptions .
private boolean isdirty ( ) { return ! objects . equals ( inputlist . keyset ( ) , cmrrepositorymanager . getcmrrepositorydefinitions ( ) ) ; }	where there changes performed by user .
public void write ( string s , int off , int len ) { if ( text != null ) { text . append ( s . substring ( off , off + len ) ) ; if ( ( col += len ) > wrap ) println ( ) ; } else { super . write ( s , off , len ) ; flush ( ) ; } }	write a portion of a string .
public zoneset showactivezoneset ( integer vsanid ) throws networkdevicecontrollerexception { list < zoneset > zonesets = showzoneset ( vsanid , _bool , null , _bool , _bool ) ; return zonesets . isempty ( ) ? null : zonesets . get ( _num ) ; }	collect the active zoneset , and its zones , members for a specified vsan id .
private final short validatepermsplitfactor ( string splitfactor ) throws adeflowexception { short permsplitfactor = short . parseshort ( splitfactor ) ; if ( permsplitfactor <= _num || ( ( m_outerframingflow . getduration ( ) / permsplitfactor ) < milliseconds_in_one_minute ) ) { throw new adeflowexception ( _str ) ; } return permsplitfactor ; }	validation for the permanent split factor.
public static calendar tocalendar ( string datestring , string format ) { date d = parse ( datestring , format ) ; calendar cal = calendar . getinstance ( ) ; cal . settimeinmillis ( d . gettime ( ) ) ; return cal ; }	returns a calendar from a given string using the provided format .
public void testcomparetodiffsigns2 ( ) { byte abytes [ ] = { _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = - _num ; int bsign = _num ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; assertequals ( - _num , anumber . compareto ( bnumber ) ) ; }	compareto ( biginteger a ).
private static void translatecompatibilitytopaths ( rpaction action ) { if ( action . has ( equipactionconsts . base_object ) ) { list < string > path = arrays . aslist ( action . get ( equipactionconsts . base_object ) , action . get ( equipactionconsts . base_slot ) , action . get ( equipactionconsts . base_item ) ) ; action . put ( equipactionconsts . source_path , path ) ; } else { list < string > path = arrays . aslist ( action . get ( equipactionconsts . base_item ) ) ; action . put ( equipactionconsts . source_path , path ) ; } }	translate old style object reference to entity path .
public builder addmenuitem ( @ nonnull string label , @ nonnull pendingintent pendingintent ) { if ( mmenuitems == null ) mmenuitems = new arraylist < > ( ) ; bundle bundle = new bundle ( ) ; bundle . putstring ( key_menu_item_title , label ) ; bundle . putparcelable ( key_pending_intent , pendingintent ) ; mmenuitems . add ( bundle ) ; return this ; }	adds a menu item .
public sparsefloatvector ( tintfloatmap values , int dimensionality ) throws illegalargumentexception { if ( values . size ( ) > dimensionality ) { throw new illegalargumentexception ( _str ) ; } this . indexes = new int [ values . size ( ) ] ; this . values = new float [ values . size ( ) ] ; { tintfloatiterator iter = values . iterator ( ) ; for ( int i = _num ; iter . hasnext ( ) ; i ++ ) { iter . advance ( ) ; this . indexes [ i ] = iter . key ( ) ; } arrays . sort ( this . indexes ) ; } { for ( int i = _num ; i < values . size ( ) ; i ++ ) { this . values [ i ] = values . get ( this . indexes [ i ] ) ; } } this . dimensionality = dimensionality ; final int maxdim = getmaxdim ( ) ; if ( maxdim > dimensionality ) { throw new illegalargumentexception ( _str + dimensionality + _str + maxdim + _str ) ; } }	create a sparsefloatvector consisting of double values according to the specified mapping of indices and values .
public byte [ ] canonserializetobytearray ( node node ) throws exception { bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; canon . setwriter ( baos ) ; canon . notreset ( ) ; canon . canonicalizesubtree ( node ) ; return baos . tobytearray ( ) ; }	use the canonicalizer to serialize the node.
public definedmethod adddescription ( string description ) { this . description = optional . of ( description ) ; return this ; }	adds a description to this method .
public int addflattenedcolumn ( object o , int [ ] dims ) throws fitsexception { return addflattenedcolumn ( o , dims , _bool ) ; }	add a column where the data is already flattened .
public final void writetostream ( dataoutputstream dos ) throws ioexception { dos . writeutf ( event ) ; dos . writeutf ( site ) ; dos . writeutf ( date ) ; dos . writeutf ( round ) ; dos . writeutf ( white ) ; dos . writeutf ( black ) ; dos . writeutf ( textio . tofen ( startpos ) ) ; dos . writeutf ( timecontrol ) ; dos . writeutf ( whitetimecontrol ) ; dos . writeutf ( blacktimecontrol ) ; int ntags = tagpairs . size ( ) ; dos . writeint ( ntags ) ; for ( int i = _num ; i < ntags ; i ++ ) { dos . writeutf ( tagpairs . get ( i ) . tagname ) ; dos . writeutf ( tagpairs . get ( i ) . tagvalue ) ; } node . writetostream ( dos , rootnode ) ; arraylist < integer > pathfromroot = currentnode . getpathfromroot ( ) ; int pathlen = pathfromroot . size ( ) ; dos . writeint ( pathlen ) ; for ( int i = _num ; i < pathlen ; i ++ ) dos . writeint ( pathfromroot . get ( i ) ) ; }	serialize to output stream .
public void registersource ( progresssource pi ) { synchronized ( progresssourcelist ) { if ( progresssourcelist . contains ( pi ) ) return ; progresssourcelist . add ( pi ) ; } if ( progresslistenerlist . size ( ) > _num ) { arraylist < progresslistener > listeners = new arraylist < progresslistener > ( ) ; synchronized ( progresslistenerlist ) { for ( iterator < progresslistener > iter = progresslistenerlist . iterator ( ) ; iter . hasnext ( ) ; ) { listeners . add ( iter . next ( ) ) ; } } for ( iterator < progresslistener > iter = listeners . iterator ( ) ; iter . hasnext ( ) ; ) { progresslistener pl = iter . next ( ) ; progressevent pe = new progressevent ( pi , pi . geturl ( ) , pi . getmethod ( ) , pi . getcontenttype ( ) , pi . getstate ( ) , pi . getprogress ( ) , pi . getexpected ( ) ) ; pl . progressstart ( pe ) ; } } }	register progress source when progress is began .
private static map < string , string > extractkeyvaluepairs ( string props , objectname mbean ) { map < string , string > map = new linkedhashmap < string , string > ( ) ; int eq = props . indexof ( _str ) ; while ( eq != - _num ) { string key = props . substring ( _num , eq ) ; string value = mbean . getkeyproperty ( key ) ; map . put ( key , value ) ; props = props . substring ( key . length ( ) + _num + value . length ( ) ) ; if ( props . startswith ( _str ) ) { props = props . substring ( _num ) ; } eq = props . indexof ( _str ) ; } return map ; }	parses the mbean objectname comma - separated properties string and puts the individual key / value pairs into the map.
protected void paintcontentborderleftedge ( graphics g , int tabplacement , int selectedindex , int x , int y , int w , int h ) { rectangle selrect = selectedindex < _num ? null : gettabbounds ( selectedindex , calcrect ) ; g . setcolor ( selecthighlight ) ; if ( tabplacement != left || selectedindex < _num || ( selrect . x + selrect . width + _num < x ) || ( selrect . y < y || selrect . y > y + h ) ) { g . drawline ( x , y , x , y + h - _num ) ; } else { g . drawline ( x , y , x , selrect . y + _num ) ; if ( selrect . y + selrect . height < y + h - _num ) g . drawline ( x , selrect . y + selrect . height + _num , x , y + h - _num ) ; } }	paint left content border edge.
public final flux < t > sample ( duration timespan ) { return samplemillis ( timespan . tomillis ( ) ) ; }	emit latest value for every given period of time.
@ override public boolean hasvaluesdescription ( ) { return restrictionclass != null && restrictionclass != object . class ; }	this class sometimes provides a list of value descriptions .
public smbfile ( string url ) throws malformedurlexception { this ( new url ( null , url , handler . smb_handler ) ) ; }	constructs an smbfile representing a resource on an smb network such as a file or directory.
public static boolean isaudio ( string mimetype ) { if ( mimetype != null ) { if ( mimetype . startswith ( _str ) ) return _bool ; else return _bool ; } else return _bool ; }	returns true if the mime type is a standard audio mime type.
private void restorewidget ( key key , byte [ ] buffer , int datasize ) throws ioexception { if ( verbose ) log . v ( tag , _str + key . id ) ; if ( debug ) log . d ( tag , _str + buffer . length + _str + base64 . encodetostring ( buffer , _num , datasize , base64 . no_wrap ) ) ; widget widget = unpackproto ( new widget ( ) , buffer , datasize ) ; if ( debug ) log . d ( tag , _str + widget . provider ) ; if ( widget . icon . data != null ) { bitmap icon = bitmapfactory . decodebytearray ( widget . icon . data , _num , widget . icon . data . length ) ; if ( icon == null ) { log . w ( tag , _str + key . name ) ; } else { iconcache . preloadicon ( mcontext , componentname . unflattenfromstring ( widget . provider ) , icon , widget . icon . dpi ) ; } } }	read a widget from the stream.
protected int assertlineterminates ( int c ) throws ioexception , rdfparseexception { c = reader . read ( ) ; c = skipwhitespace ( c ) ; if ( c != - _num && c != _str && c != _str ) { reportfatalerror ( _str ) ; } return c ; }	verifies that there is only whitespace until the end of the line .
static private xmlevent constructevent ( int eventtype , wbxmlstreamreader stream ) throws xmlstreamexception { log . log ( level . fine , _str ) ; xmlevent event ; switch ( eventtype ) { case xmlstreamconstants . start_document : event = new wbxmlstartdocumentevent ( stream ) ; break ; case xmlstreamconstants . end_document : event = new wbxmlenddocumentevent ( stream ) ; break ; case xmlstreamconstants . start_element : event = new wbxmlstartelementevent ( stream ) ; break ; case xmlstreamconstants . end_element : event = new wbxmlendelementevent ( stream ) ; break ; case xmlstreamconstants . characters : case xmlstreamconstants . cdata : event = new wbxmlcharactersevent ( stream ) ; break ; default : throw new unsupportedoperationexception ( string . format ( _str , eventtype ) ) ; } log . log ( level . fine , _str , event ) ; return event ; }	constructs the events based on the one read from the xmlstreamwriter .
private void verifygridstate ( ) { integer rowlength = null ; int rowpos = _num ; for ( list < object > row : grid ) { if ( rowlength != null && rowlength != row . size ( ) ) { throw new illegalstateexception ( _str + rowlength + _str + row . size ( ) + _str + rowpos ) ; } rowpos ++ ; rowlength = row . size ( ) ; } }	verifies that all grid rows are of the same length .
public static string readstringandclose ( reader in , int length ) throws ioexception { try { if ( length <= _num ) { length = integer . max_value ; } int block = math . min ( constants . io_buffer_size , length ) ; stringwriter out = new stringwriter ( block ) ; copyandcloseinput ( in , out , length ) ; return out . tostring ( ) ; } finally { in . close ( ) ; } }	read a number of characters from a reader and close it .
protected void beginpath ( ) { prepdrawing ( ) ; mpsstream . println ( newpath_str ) ; mpenx = _num ; mpeny = _num ; }	called to mark the start of a new path .
private void sendtcprequest ( socket socket , string request ) throws apiexception { try { logutils . logd ( tag , _str + request ) ; bufferedwriter writer = new bufferedwriter ( new outputstreamwriter ( socket . getoutputstream ( ) ) ) ; writer . write ( request ) ; writer . flush ( ) ; } catch ( exception e ) { logutils . logw ( tag , _str , e ) ; disconnect ( ) ; throw new apiexception ( apiexception . io_exception_while_sending_request , e ) ; } }	send a tcp request.
public static string cleanstring ( string src ) { if ( src == null ) { return null ; } boolean foundbad = _bool ; final characteriterator it = new stringcharacteriterator ( src ) ; for ( char c = it . first ( ) ; c != characteriterator . done ; c = it . next ( ) ) { if ( c < ascii_printable_low || c >= ascii_printable_hi ) { foundbad = _bool ; break ; } } if ( ! foundbad ) { return src ; } final stringbuilder res = new stringbuilder ( ) ; for ( char c = it . first ( ) ; c != characteriterator . done ; c = it . next ( ) ) { if ( c < ascii_printable_low || c >= ascii_printable_hi ) { res . append ( ascii_space ) ; } else { res . append ( c ) ; } } return res . tostring ( ) ; }	returns a string based on the input string , but with all characters with ordinal values < 32 or > = 128 replaced with ' ' .
public static manuallaggraph serializableinstance ( ) { return new manuallaggraph ( manuallaggraphparams . serializableinstance ( ) ) ; }	generates a simple exemplar of this class to test serialization .
public void updateactions ( ) { string text ; action a = rtextarea . getaction ( rtextarea . undo_action ) ; if ( canundo ( ) ) { a . setenabled ( _bool ) ; text = getundopresentationname ( ) ; a . putvalue ( action . name , text ) ; a . putvalue ( action . short_description , text ) ; } else { if ( a . isenabled ( ) ) { a . setenabled ( _bool ) ; text = cantundotext ; a . putvalue ( action . name , text ) ; a . putvalue ( action . short_description , text ) ; } } a = rtextarea . getaction ( rtextarea . redo_action ) ; if ( canredo ( ) ) { a . setenabled ( _bool ) ; text = getredopresentationname ( ) ; a . putvalue ( action . name , text ) ; a . putvalue ( action . short_description , text ) ; } else { if ( a . isenabled ( ) ) { a . setenabled ( _bool ) ; text = cantredotext ; a . putvalue ( action . name , text ) ; a . putvalue ( action . short_description , text ) ; } } }	ensures that undo / redo actions are enabled appropriately and have descriptive text at all times .
public void addscrollinglistener ( onwheelscrolllistener listener ) { scrollinglisteners . add ( listener ) ; }	adds wheel scrolling listener.
public static boolean hasdependency ( mavenproject project , string groupid ) { set < artifact > artifacts = project . getartifacts ( ) ; if ( artifacts != null ) { for ( artifact artifact : artifacts ) { string scope = artifact . getscope ( ) ; if ( objects . equal ( _str , scope ) ) { continue ; } if ( objects . equal ( groupid , artifact . getgroupid ( ) ) ) { return _bool ; } } } return _bool ; }	returns true if the maven project has a dependency with the given groupid.
public contourgenerator ( url url , float modelmean , float modelstddev ) throws ioexception { this . modelmean = modelmean ; this . modelstddev = modelstddev ; list termslist = new arraylist ( ) ; string line ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( url . openstream ( ) ) ) ; line = reader . readline ( ) ; while ( line != null ) { if ( ! line . startswith ( _str ) ) { parseandadd ( termslist , line ) ; } line = reader . readline ( ) ; } terms = ( f0modelterm [ ] ) termslist . toarray ( terms ) ; reader . close ( ) ; }	creates a contourgenerator utterance processor .
public void addcomment ( string comment ) { if ( frame != null ) { chattab . addcomment ( comment ) ; } if ( tabbedpane . getselectedindex ( ) == _num ) { editortab . displaycomment ( comment ) ; } }	adds a comment to the chat window.
private void decompose ( list < object > elementpairs , list < object > printerlist , list < object > parserlist ) { int size = elementpairs . size ( ) ; for ( int i = _num ; i < size ; i += _num ) { object element = elementpairs . get ( i ) ; if ( element instanceof datetimeprinter ) { if ( element instanceof composite ) { addarraytolist ( printerlist , ( ( composite ) element ) . iprinters ) ; } else { printerlist . add ( element ) ; } } element = elementpairs . get ( i + _num ) ; if ( element instanceof datetimeparser ) { if ( element instanceof composite ) { addarraytolist ( parserlist , ( ( composite ) element ) . iparsers ) ; } else { parserlist . add ( element ) ; } } } }	processes the element pairs , putting results into the given printer and parser lists .
private string processintegertoken ( string token ) { string result = token . replaceall ( _str + groupseparator , _str ) ; boolean isnegative = _bool ; int prelen = negativeprefix . length ( ) ; if ( ( prelen > _num ) && result . startswith ( negativeprefix ) ) { isnegative = _bool ; result = result . substring ( prelen ) ; } int suflen = negativesuffix . length ( ) ; if ( ( suflen > _num ) && result . endswith ( negativesuffix ) ) { isnegative = _bool ; result = result . substring ( result . length ( ) - suflen , result . length ( ) ) ; } if ( isnegative ) result = _str + result ; return result ; }	the integer token must be stripped of prefixes , group separators , and suffixes , non ascii digits must be converted into ascii digits before parse will accept it .
public void writegraphics ( string graphicssavefile ) throws ioexception { fileoutputstream ostream = new fileoutputstream ( graphicssavefile ) ; objectoutputstream objectstream = new objectoutputstream ( ostream ) ; writegraphics ( objectstream ) ; objectstream . close ( ) ; }	write the graphics out to a file.
@ override public void addinputnode ( bnode inputnode ) { super . addinputnode ( inputnode ) ; }	adds a new ( input ) relation for the node.
public void removedependency ( taskdependency dep ) { node srcnode = mynodemap . get ( dep . getdependee ( ) ) ; node dstnode = mynodemap . get ( dep . getdependant ( ) ) ; if ( srcnode == null && dstnode == null ) { return ; } assert ( srcnode != null && dstnode != null ) : _str + dep + _str ; dependencyedge diededge = findexplicitdependency ( dep , srcnode , dstnode ) ; if ( diededge == null ) { return ; } removeedge ( diededge ) ; for ( dependencyedge edge : lists . newarraylist ( srcnode . getoutgoing ( ) ) ) { if ( edge instanceof implicitinheriteddependency ) { if ( ( ( implicitinheriteddependency ) edge ) . myexplicitdep == diededge ) { removeedge ( edge ) ; } } } firegraphchanged ( ) ; }	removes explicit dependency . also removes all inherited dependencies constructed from that one.
public vnxecommandjob modifyconsistencygroupasync ( string id , lungroupmodifyparam param ) { stringbuilder urlbld = new stringbuilder ( url_modify1 ) ; urlbld . append ( id ) ; urlbld . append ( url_modify2 ) ; _url = urlbld . tostring ( ) ; return postrequestasync ( param ) ; }	modify consistency group in async mode.
public object readremote ( ) throws ioexception { string type = readtype ( ) ; string url = readstring ( ) ; return resolveremote ( type , url ) ; }	reads a remote object .
private static jfreechart createchart ( ) { xyseries series1 = new xyseries ( _str ) ; series1 . add ( _num , _num ) ; series1 . add ( _num , _num ) ; series1 . add ( _num , _num ) ; xydataset dataset = new xyseriescollection ( series1 ) ; return chartfactory . createtimeserieschart ( _str , _str , _str , dataset , _bool , _bool , _bool ) ; }	create a horizontal bar chart with sample data in the range - 3 to + 3 .
private void dtdprolog ( ) throws saxexception , ioexception { final java . io . writer writer = m_writer ; if ( m_needtooutputdoctypedecl ) { outputdoctypedecl ( m_elemcontext . m_elementname , _bool ) ; m_needtooutputdoctypedecl = _bool ; } if ( m_indoctype ) { writer . write ( _str ) ; writer . write ( m_linesep , _num , m_lineseplen ) ; m_indoctype = _bool ; } }	a private helper method to output the.
public cacheset querysequential ( predicate ... selectors ) { checknotnull ( selectors ) ; collection < object > resultcollection = new arraylist < > ( items ) ; collection < object > filtercollection = new linkedlist < > ( ) ; collection < object > tempcollection ; int i = _num ; while ( ( i < selectors . length ) && ( resultcollection . size ( ) > _num ) ) { collectionutils . select ( resultcollection , selectors [ i ] , filtercollection ) ; tempcollection = resultcollection ; resultcollection = filtercollection ; filtercollection = tempcollection ; filtercollection . clear ( ) ; i ++ ; } return new cacheset ( resultcollection ) ; }	sequential filtering by selectors.
@ override public boolean iserrorenabled ( ) { return logger . isloggable ( level . severe ) ; }	is this logger instance enabled for level severe ?.
public static < a > settvalue < a > fromstream ( final anymvalue < stream < a > > monads ) { return of ( monads . map ( null ) ) ; }	create a sett from an anym that wraps a monad containing a stream.
public static ccbitmapfontconfiguration fntconfigloadfile ( string fntfile ) { ccbitmapfontconfiguration ret = null ; if ( configurations == null ) configurations = new hashmap < string , ccbitmapfontconfiguration > ( ) ; ret = configurations . get ( fntfile ) ; if ( ret == null ) { ret = ccbitmapfontconfiguration . configuration ( fntfile ) ; configurations . put ( fntfile , ret ) ; } return ret ; }	free function that parses a fnt file a place it on the cache.
public void addcriteria ( criteria othercriteria ) { if ( othercriteria instanceof advancedcriteria || othercriteria instanceof criterion ) { throw new illegalargumentexception ( _str + _str ) ; } map othermap = othercriteria . getvalues ( ) ; set otherkeys = othermap . keyset ( ) ; for ( iterator i = otherkeys . iterator ( ) ; i . hasnext ( ) ; ) { string field = ( string ) i . next ( ) ; object value = othermap . get ( field ) ; jsohelper . setattribute ( jsobj , field , value ) ; } }	adds the criteria from the passed criteria object .
public dnetscapesslservername ( jdialog parent , byte [ ] value ) throws ioexception { super ( parent ) ; settitle ( res . getstring ( _str ) ) ; initcomponents ( ) ; prepopulatewithvalue ( value ) ; }	creates a new dnetscapesslservername dialog .
public static eventbean [ ] resizearray ( eventbean [ ] oldarray , int newsize ) { if ( oldarray == null ) { return null ; } if ( oldarray . length == newsize ) { return oldarray ; } eventbean [ ] newarray = new eventbean [ newsize ] ; int preservelength = math . min ( oldarray . length , newsize ) ; if ( preservelength > _num ) { system . arraycopy ( oldarray , _num , newarray , _num , preservelength ) ; } return newarray ; }	resizes an array of events to a new size.
public static spannablestring spantext ( charsequence text , object ... spans ) { spannablestring spannablestring = new spannablestring ( text ) ; for ( object span : spans ) { spannablestring . setspan ( span , _num , text . length ( ) , spanned . span_exclusive_exclusive ) ; } return spannablestring ; }	sets span objects to the text.
@ suppresswarnings ( _str ) protected < t > list < t > query ( class < t > modelclass , string [ ] columns , string selection , string [ ] selectionargs , string groupby , string having , string orderby , string limit , list < associationsinfo > foreignkeyassociations ) { list < t > datalist = new arraylist < t > ( ) ; cursor cursor = null ; try { list < field > supportedfields = getsupportedfields ( modelclass . getname ( ) ) ; string tablename = gettablename ( modelclass ) ; string [ ] customizedcolumns = getcustomizedcolumns ( columns , foreignkeyassociations ) ; cursor = mdatabase . query ( tablename , customizedcolumns , selection , selectionargs , groupby , having , orderby , limit ) ; if ( cursor . movetofirst ( ) ) { sparsearray < queryinfocache > queryinfocachesparsearray = new sparsearray < queryinfocache > ( ) ; do { t modelinstance = ( t ) createinstancefromclass ( modelclass ) ; givebaseobjidvalue ( ( datasupport ) modelinstance , cursor . getlong ( cursor . getcolumnindexorthrow ( _str ) ) ) ; setvaluetomodel ( modelinstance , supportedfields , foreignkeyassociations , cursor , queryinfocachesparsearray ) ; if ( foreignkeyassociations != null ) { setassociatedmodel ( ( datasupport ) modelinstance ) ; } datalist . add ( modelinstance ) ; } while ( cursor . movetonext ( ) ) ; queryinfocachesparsearray . clear ( ) ; } return datalist ; } catch ( exception e ) { e . printstacktrace ( ) ; throw new datasupportexception ( e . getmessage ( ) ) ; } finally { if ( cursor != null ) { cursor . close ( ) ; } } }	query the table of the given model , returning a model list over the result set .
private mltresult buildqueryforfield ( string fieldname , priorityqueue < mltterm > q , booleanquery query , boolean contentstreamquery ) { list < mltterm > interestingterms = new arraylist < mltterm > ( ) ; int qterms = _num ; int maxterms = maxquerytermsperfield ; if ( maxterms <= _num ) { maxterms = integer . max_value ; } booleanquery tmpquery = new booleanquery ( ) ; double sumquaredboost = _num ; mltterm cur ; while ( ( cur = q . pop ( ) ) != null ) { query tq = null ; final term term = new term ( cur . getfieldname ( ) , cur . getword ( ) ) ; if ( ispayloadfield ( cur . getfieldname ( ) ) ) { tq = new payloadtermquery ( term , new averagepayloadfunction ( ) , _bool ) ; } else { tq = new termquery ( term ) ; } if ( boost ) { float boost = cur . getscore ( ) ; tq . setboost ( boost ) ; sumquaredboost += boost * boost ; } else { sumquaredboost += _num ; } try { tmpquery . add ( tq , booleanclause . occur . should ) ; interestingterms . add ( cur ) ; qterms ++ ; } catch ( booleanquery . toomanyclauses ignore ) { break ; } if ( qterms >= maxterms ) { break ; } } double vectorlength = math . sqrt ( sumquaredboost ) ; if ( vectorlength <= _num ) { return new mltresult ( interestingterms , query ) ; } buildboostednormalizedquery ( fieldname , tmpquery , query , vectorlength , contentstreamquery ) ; return new mltresult ( interestingterms , query ) ; }	build the more queryfromdocuments query from a priorityqueue and an initial boolean query.
@ suppresswarnings ( _str ) protected void sequentially ( consumer < marker > ... functions ) { if ( functions == null || functions . length == _num ) return ; collection < parsingexception > errors = new arraylist < > ( ) ; marker marker = tokens . mark ( ) ; for ( consumer < marker > function : functions ) { try { function . accept ( marker ) ; return ; } catch ( parsingexception e ) { errors . add ( e ) ; tokens . rewind ( marker ) ; } } parsingfailed ( marker . position ( ) , errors , _str ) ; }	try calling the supplied functions in sequence , stopping as soon as one of them succeeds .
public pidfile ( final file file ) throws filenotfoundexception { if ( ! file . exists ( ) || ! file . isfile ( ) ) { throw new filenotfoundexception ( _str + file + _str ) ; } this . pidfile = file ; }	constructs a pidfile for reading pid stored in a file .
public void addchildnode ( execnode childnode ) { childnodes . add ( childnode ) ; }	add a child node .
static private double quickselect ( idoublevector x , int k , int start , int end ) { if ( k < start || k > end ) { throw new adecoreillegalargumentexception ( _str ) ; } final int pivotindex = ( ( int ) math . random ( ) * ( end - start + _num ) ) + start ; final int pivotposition = partition ( x , start , end , pivotindex ) ; if ( pivotposition == k ) { return x . get ( k ) ; } else if ( pivotposition < k ) { return quickselect ( x , k , pivotposition + _num , end ) ; } else { return quickselect ( x , k , start , pivotposition - _num ) ; } }	quicksort like algorithm to select k ' th member.
public bayesimeditorobs ( bayesimwrapperobs bayesimwrapperobs ) { this ( bayesimwrapperobs , bayesimwrapperobs . getbayesim ( ) ) ; }	constructs a new instanted model editor from a bayes im wrapper .
private list < string > convertbytearraylisttostringvaluelist ( list < byte [ ] > dictionarybytearraylist ) { list < string > valuelist = new arraylist < > ( dictionarybytearraylist . size ( ) ) ; for ( byte [ ] value : dictionarybytearraylist ) { valuelist . add ( new string ( value , charset . forname ( carboncommonconstants . default_charset ) ) ) ; } return valuelist ; }	this method will convert list of byte array to list of string.
public filetreenode ( file parent , string name ) throws securityexception , filenotfoundexception { this ( parent . topath ( ) , name ) ; }	instantiates a new file tree node .
private list < node > possibleparents ( node x , list < node > adjx , iknowledge knowledge ) { list < node > possibleparents = new linkedlist < > ( ) ; string _x = x . getname ( ) ; for ( node z : adjx ) { string _z = z . getname ( ) ; if ( possibleparentof ( _z , _x , knowledge ) ) { possibleparents . add ( z ) ; } } return possibleparents ; }	removes from the list of nodes any that cannot be parents of x given the background knowledge .
public synchronized void remove ( abstractoption option ) { if ( options . contains ( option ) ) { int position = indexof ( option ) ; list < abstractoption > oldoptions = new arraylist < abstractoption > ( options ) ; options . remove ( option ) ; list < abstractoption > newoptions = getoptions ( ) ; option . setcollection ( null ) ; fireindexedpropertychange ( prop_options , position , oldoptions , newoptions ) ; } }	removes an abstractoption from the container.
private float [ ] calculatepointerposition ( float angle ) { float x = ( float ) ( mcolorwheelradius * math . cos ( angle ) ) ; float y = ( float ) ( mcolorwheelradius * math . sin ( angle ) ) ; return new float [ ] { x , y } ; }	calculate the pointer ' s coordinates on the color wheel using the supplied angle .
private void handleprocesserror ( jobdefinition job , process process ) throws ioexception { stringbuffer sb = new stringbuffer ( ) ; bufferedreader in = new bufferedreader ( new inputstreamreader ( process . getinputstream ( ) ) ) ; int data = _num ; while ( data != - _num && ! isinterrupted ( ) ) { data = in . read ( ) ; if ( data != - _num ) { sb . append ( ( char ) data ) ; } } logger . warn ( _str + job . cut + _str + sb . tostring ( ) ) ; }	print process console output if it died , as its logs on disks might not have been generated yet.
private void checkclassandsync ( class < ? extends ipacket > clazz ) { if ( ! registeredclasses . contains ( clazz ) ) { throw new runtimeexception ( _str + clazz + _str ) ; } while ( iscurrentlysendingsemaphor ) { thread . yield ( ) ; } iscurrentlysendingsemaphor = _bool ; }	since the crash that happens if we dont do this is complete garbage.
private static int calculatedisplayedwidth ( string string ) { final int tabwidth = default_tab_width ; int column = _num ; for ( int i = _num ; i < string . length ( ) ; i ++ ) { if ( _str == string . charat ( i ) ) { column += tabwidth - ( column % tabwidth ) ; } else { column ++ ; } } return column ; }	returns the displayed width of a string , taking in account the displayed tab width.
@ override public int read ( ) { if ( idx >= charsequence . length ( ) ) { return - _num ; } else { return charsequence . charat ( idx ++ ) ; } }	read a single character .
public void test_getclientaliases ( ) { init ( client ) ; assertnull ( manager . getclientaliases ( null , null ) ) ; assertnull ( manager . getclientaliases ( _str , null ) ) ; string [ ] resarray = manager . getclientaliases ( type_rsa , null ) ; assertnotnull ( resarray ) ; assertequals ( _num , resarray . length ) ; assertknownaliases ( resarray ) ; }	x509keymanager # getclientaliases ( string keytype , principal [ ] issuers ).
public static void println ( char x ) { out . println ( x ) ; }	prints a character to standard output and then terminates the line .
private boolean shouldpositionavataronright ( ) { final boolean isrtl = build . version . sdk_int >= build . version_codes . jelly_bean_mr1 ? getlayoutdirection ( ) == layout_direction_rtl : _bool ; final boolean assignedposition = mavatarposition == avatar_position_end ; return isrtl ? ! assignedposition : assignedposition ; }	returns true if the avatar should be positioned at the right edge of the chip.
public static void fail ( string message ) { throw new illegalstateexception ( message == null ? _str : message ) ; }	fails a test with the given message .
public void memsetbuffer ( bytebuffer buffer ) { memsetbuffer ( buffer , buffer . limit ( ) ) ; }	it will reset all the positions on the buffer to 0 , using memset .
protected list < item_type > selectfoldtestitems ( list < item_type > items , int nfolds , int fold ) { list < item_type > testitems = new arraylist < item_type > ( ) ; for ( int i = _num ; i < items . size ( ) ; ++ i ) { if ( i % nfolds == fold ) { testitems . add ( items . get ( i ) ) ; } } return testitems ; }	determines which items should be used for testing in one fold of a cross - validation.
public final charsequencetranslator with ( final charsequencetranslator ... translators ) { final charsequencetranslator [ ] newarray = new charsequencetranslator [ translators . length + _num ] ; newarray [ _num ] = this ; system . arraycopy ( translators , _num , newarray , _num , translators . length ) ; return new aggregatetranslator ( newarray ) ; }	helper method to create a merger of this translator with another set of translators.
@ override public boolean equals ( object other ) { if ( ! ( other instanceof sha256hash ) ) return _bool ; return arrays . equals ( bytes , ( ( sha256hash ) other ) . bytes ) ; }	returns true if the hashes are equal .
public config ( solrresourceloader loader , string name ) throws parserconfigurationexception , ioexception , saxexception { this ( loader , name , null , null ) ; }	builds a config from a resource name with no xpath prefix .
private static hashmap < string , field > buildfieldcache ( class < ? > cls ) { final hashmap < string , field > cache = new hashmap < > ( ) ; final list < field > fields = getallfields ( cls ) ; for ( field fld : fields ) { string name = null ; final reference refann = fld . getannotation ( reference . class ) ; if ( refann != null ) name = selectcolumnname ( refann , fld ) ; if ( name == null ) { final column colann = fld . getannotation ( column . class ) ; if ( colann != null ) name = selectcolumnname ( colann , fld ) ; } if ( name == null ) continue ; cache . put ( name , fld ) ; } return cache ; }	avoids the need to loop over fields for every column by caching them ahead of time .
public static long convertduration ( final string fromunit , final string tounit , long value ) { timeunit fromtimeunit = totimeunit ( fromunit ) ; timeunit totimeunit = totimeunit ( tounit ) ; if ( fromtimeunit != null && totimeunit != null ) { return totimeunit . convert ( value , fromtimeunit ) ; } else { throw new dssexception ( _str + fromunit + _str + tounit + _str + value + _str ) ; } }	converts the given time duration ( value ) in the given unit ( fromunit ) to given unit ( tounit ) .
public static file searchforgroovyscriptfile ( string input ) { string scriptfilename = input . trim ( ) ; file scriptfile = new file ( scriptfilename ) ; string [ ] standardextensions = { _str , _str , _str , _str } ; int i = _num ; while ( i < standardextensions . length && ! scriptfile . exists ( ) ) { scriptfile = new file ( scriptfilename + standardextensions [ i ] ) ; i ++ ; } if ( ! scriptfile . exists ( ) ) { scriptfile = new file ( scriptfilename ) ; } return scriptfile ; }	search for the script file , doesn ' t bother if it is named precisely.
public xobject execute ( xpathcontext xctxt ) throws javax . xml . transform . transformerexception { if ( xctxt . issecureprocessing ( ) ) throw new javax . xml . transform . transformerexception ( xpathmessages . createxpathmessage ( xpatherrorresources . er_extension_function_cannot_be_invoked , new object [ ] { tostring ( ) } ) ) ; xobject result ; vector argvec = new vector ( ) ; int nargs = m_argvec . size ( ) ; for ( int i = _num ; i < nargs ; i ++ ) { expression arg = ( expression ) m_argvec . elementat ( i ) ; xobject xobj = arg . execute ( xctxt ) ; xobj . allowdetachtorelease ( _bool ) ; argvec . addelement ( xobj ) ; } extensionsprovider extprovider = ( extensionsprovider ) xctxt . getownerobject ( ) ; object val = extprovider . extfunction ( this , argvec ) ; if ( null != val ) { result = xobject . create ( val , xctxt ) ; } else { result = new xnull ( ) ; } return result ; }	execute the function . the function must return a valid object .
private header createsecurityheader ( ) { return new basicheader ( _str , _str + createauth ( ) ) ; }	todo : currently the repo only supports form based authentication.
public picture ( file file ) { try { image = imageio . read ( file ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; throw new runtimeexception ( _str + file ) ; } if ( image == null ) { throw new runtimeexception ( _str + file ) ; } width = image . getwidth ( null ) ; height = image . getheight ( null ) ; filename = file . getname ( ) ; }	initializes a picture by reading in a.
static annotationstrategy strategyfor ( annotation annotation ) { checknotnull ( annotation , _str ) ; class < ? extends annotation > annotationtype = annotation . annotationtype ( ) ; ensureretainedatruntime ( annotationtype ) ; ensureisbindingannotation ( annotationtype ) ; if ( annotationtype . getdeclaredmethods ( ) . length == _num ) { return new annotationtypestrategy ( annotationtype , annotation ) ; } return new annotationinstancestrategy ( annotation ) ; }	gets the strategy for an annotation .
private void addvolumetoblockconsistencygroup ( uri cguri , volume volume ) { volume . addconsistencygroup ( cguri . tostring ( ) ) ; _dbclient . persistobject ( volume ) ; }	associates a volume with a given blockconsistencygroup uri .
public static boolean lazygaussianelimination ( final int var2eq [ ] [ ] , final long [ ] c , final int [ ] variable , final long [ ] solution ) { return lazygaussianelimination ( null , var2eq , c , variable , solution ) ; }	solves a system using lazy gaussian elimination .
public void compressmyownway ( int [ ] indexes ) { list < integer > list = new arraylist < integer > ( carboncommonconstants . constant_size_ten ) ; list < integer > map = new arraylist < integer > ( carboncommonconstants . constant_size_ten ) ; int k = _num ; int i = _num ; for ( ; i < indexes . length ; i ++ ) { if ( indexes [ i ] - indexes [ i - _num ] == _num ) { k ++ ; } else { if ( k > _num ) { map . add ( ( list . size ( ) ) ) ; list . add ( indexes [ i - k - _num ] ) ; list . add ( indexes [ i - _num ] ) ; } else { list . add ( indexes [ i - _num ] ) ; } k = _num ; } } if ( k > _num ) { map . add ( ( list . size ( ) ) ) ; list . add ( indexes [ i - k - _num ] ) ; list . add ( indexes [ i - _num ] ) ; } else { list . add ( indexes [ i - _num ] ) ; } dataaftercomp = converttoarray ( list ) ; if ( indexes . length == dataaftercomp . length ) { indexmap = new int [ _num ] ; } else { indexmap = converttoarray ( map ) ; } if ( dataaftercomp . length == _num && indexmap . length == _num ) { alreadysorted = _bool ; } }	it compresses depends up on the sequence numbers.
private void prependdecrement ( basicblock bb , ir ir ) { if ( debug ) vm . syswrite ( _str + bb + _str ) ; registeroperand use = cbsreg . copyro ( ) ; registeroperand def = use . copyu2d ( ) ; instruction inc = binary . create ( int_add , def , use , irtools . ic ( - _num ) ) ; bb . prependinstruction ( inc ) ; }	append a decrement of the global counter to the given basic block . tested in lir only !.
public void addlistener ( connectabledevicelistener listener ) { if ( ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } }	adds the connectabledevicelistener to the list of listeners for this connectabledevice to receive certain events .
private static final string tohexstring ( final byte [ ] bs ) { string hex = _str ; stringbuilder res = new stringbuilder ( ) ; for ( byte b : bs ) { res . append ( hex . charat ( ( ( b > > > _num ) & _num ) ) ) ; res . append ( hex . charat ( ( b & _num ) ) ) ; } return res . tostring ( ) ; }	convert and array of bytes to a hex string .
public double distance_to_the_left ( plalineint p_line ) { double result = integer . max_value ; for ( int index = _num ; index < border_line_count ( ) ; ++ index ) { plapointfloat curr_corner = corner_approx ( index ) ; plaside line_side = p_line . side_of ( curr_corner , _num ) ; if ( line_side == plaside . collinear ) { line_side = p_line . side_of ( corner ( index ) ) ; } if ( line_side == plaside . on_the_right ) return - _num ; result = math . min ( result , p_line . distance_signed ( curr_corner ) ) ; } return result ; }	calculates the minimal distance of p_line to this shape , assuming , that p_line is on the left of this shape .
public boolean displaytopicfromnames ( string [ ] names ) { if ( names . length == _num ) return displaytopic ( default ) ; else { stringbuffer helpname = new stringbuffer ( ) ; for ( string name : names ) { if ( helpname . length ( ) > _num ) helpname . append ( _str ) ; helpname . append ( name ) ; } return displaytopic ( helpname . tostring ( ) ) ; } }	display help for a topic.
public boolean acceptidentical ( string filepath , string filename ) { if ( filenameglob == null ) return _bool ; if ( filename != null && filename . equalsignorecase ( filenameglob ) ) return _bool ; if ( filepath != null ) { int lastunixpos = filepath . lastindexof ( _str ) ; int lastwindowspos = filepath . lastindexof ( _str ) ; int index = math . max ( lastunixpos , lastwindowspos ) ; string filename = filepath . substring ( index + _num ) ; return filename != null && filename . equalsignorecase ( filenameglob ) ; } return _bool ; }	returns true if the buffer path or name is identical to the file name glob.
private void validatenumcoresblocksort ( ) { string numcoresstr = carbonproperties . getproperty ( carboncommonconstants . num_cores_block_sort , carboncommonconstants . num_cores_block_sort_default_val ) ; try { int numcores = integer . parseint ( numcoresstr ) ; if ( numcores < carboncommonconstants . num_cores_block_sort_min_val || numcores > carboncommonconstants . num_cores_block_sort_max_val ) { logger . info ( _str + numcoresstr + _str + carboncommonconstants . num_cores_block_sort_default_val ) ; carbonproperties . setproperty ( carboncommonconstants . num_cores_block_sort , carboncommonconstants . num_cores_block_sort_default_val ) ; } } catch ( numberformatexception e ) { logger . info ( _str + numcoresstr + _str + carboncommonconstants . num_cores_block_sort_default_val ) ; carbonproperties . setproperty ( carboncommonconstants . num_cores_block_sort , carboncommonconstants . num_cores_block_sort_default_val ) ; } }	this method validates the number cores specified for mdk block sort.
public static memorymatchfragment newinstance ( ) { return new memorymatchfragment ( ) ; }	create a new instance of this fragment .
static void createfilefromresource ( string resource , resource file ) throws ioexception { createfilefromresource ( resource , file , null ) ; }	creates a file and his content froma a resurce.
public static void perspectivem ( double [ ] m , int offset , double fovy , double aspect , double znear , double zfar ) { double f = _num / math . tan ( fovy * ( math . pi / _num ) ) ; double rangereciprocal = _num / ( znear - zfar ) ; m [ offset + _num ] = f / aspect ; m [ offset + _num ] = _num ; m [ offset + _num ] = _num ; m [ offset + _num ] = _num ; m [ offset + _num ] = _num ; m [ offset + _num ] = f ; m [ offset + _num ] = _num ; m [ offset + _num ] = _num ; m [ offset + _num ] = _num ; m [ offset + _num ] = _num ; m [ offset + _num ] = ( zfar + znear ) * rangereciprocal ; m [ offset + _num ] = - _num ; m [ offset + _num ] = _num ; m [ offset + _num ] = _num ; m [ offset + _num ] = _num * zfar * znear * rangereciprocal ; m [ offset + _num ] = _num ; }	define a projection matrix in terms of a field of view angle , an aspect ratio , and z clip planes.
protected double compute ( string value ) { if ( value != null ) { try { return double . parsedouble ( value ) ; } catch ( numberformatexception e ) { if ( positive_infinity_string . equals ( value ) ) { return double . positive_infinity ; } else if ( negative_infinity_string . equals ( value ) ) { return double . negative_infinity ; } return double . nan ; } } return double . nan ; }	computes the result for one input string value .
boolean isduplicaterolecolumn ( int column ) { return duplicaterolecolumn . contains ( column ) ; }	whether the column has a role that is also used in another column .
public timestampspeechletrequestverifier ( long tolerance , timeunit unit ) { if ( tolerance < _num ) { throw new illegalargumentexception ( _str ) ; } toleranceinmilliseconds = unit . tomillis ( tolerance ) ; }	constructs a new timestamp verifier with the provided tolerance ( in the provided units ) .
public void shutdown ( ) { countdownlatch wait_l ; synchronized ( this ) { wait_l = waitshutdown ; } shutdown_ind = _bool ; try { if ( wait_l != null ) { if ( wait_l . await ( _num , timeunit . milliseconds ) ) log . info ( _str ) ; else log . warn ( _str ) ; } else { log . info ( _str ) ; } } catch ( interruptedexception int_exc ) { log . warn ( _str ) ; } }	shut down the service , waiting up to 3 seconds for the service to terminate .
void paintstrokes ( rectangle r , graphics g , int axis , int [ ] lengthpattern , color [ ] colorpattern ) { boolean xaxis = ( axis == view . x_axis ) ; int start = _num ; int end = ( xaxis ? r . width : r . height ) ; while ( start < end ) { for ( int i = _num ; i < lengthpattern . length ; i ++ ) { if ( start >= end ) { break ; } int length = lengthpattern [ i ] ; color c = colorpattern [ i ] ; if ( c != null ) { int x = r . x + ( xaxis ? start : _num ) ; int y = r . y + ( xaxis ? _num : start ) ; int width = xaxis ? length : r . width ; int height = xaxis ? r . height : length ; g . setcolor ( c ) ; g . fillrect ( x , y , width , height ) ; } start += length ; } } }	paint strokes repeatedly using the given length and color patterns .
public string fillparamwitheventattrib ( string paramdata , event event ) { if ( ! database . isopen ( ) ) { throw new illegalstateexception ( tag + _str ) ; } stringbuilder retval = new stringbuilder ( ) ; int cursor = _num ; while ( cursor < paramdata . length ( ) ) { int openbracketidx = paramdata . indexof ( _str , cursor ) ; int closebracketidx = paramdata . indexof ( _str , cursor ) ; if ( openbracketidx == - _num || closebracketidx == - _num || openbracketidx + _num >= closebracketidx ) { retval . append ( paramdata . substring ( cursor ) ) ; break ; } string attr = paramdata . substring ( openbracketidx + _num , closebracketidx ) ; string param = paramdata . substring ( openbracketidx , closebracketidx + _num ) ; string paramattr ; try { paramattr = event . getattribute ( attr ) ; } catch ( illegalargumentexception e ) { paramattr = param ; } retval . append ( paramdata . substring ( cursor , openbracketidx ) ) ; retval . append ( paramattr ) ; cursor = closebracketidx + _num ; } log . d ( _str , paramdata + _str + retval . tostring ( ) ) ; return retval . tostring ( ) ; }	this method checks the parameter data to see if it already has value or it should extract value from the event.
public static double twopow ( int power ) { if ( power <= - max_double_exponent ) { if ( power >= min_double_exponent ) { return double . longbitstodouble ( _num > > ( - ( power + max_double_exponent ) ) ) ; } else { return _num ; } } else if ( power > max_double_exponent ) { return double . positive_infinity ; } else { return double . longbitstodouble ( ( ( long ) ( power + max_double_exponent ) ) << _num ) ; } }	net . jodk . fastmath class has a typically faster version of this method , using look - up tables . returns the exact result , provided it ' s in double range , i . e . if power is in [ - 1074 , 1023 ] .
@ suppresswarnings ( _str ) public static type resolvetypevariable ( typevariable name , class declaringclass , class topclass ) { type type = resolvetypevariable ( name , declaringclass , new hashmap < > ( ) , topclass ) ; if ( type == null ) { type = object . class ; } return type ; }	given a type variable , find what it resolves to given the declaring class where type variable was found and a top class that extends the declaring class .
private resourceimpl aggregate ( resourceimpl resourcea , resourceimpl resourceb ) throws notfoundexception { final string typeid = resourcea . gettype ( ) ; final resourcetype resourcetype = getresourcetype ( typeid ) ; return resourcetype . aggregate ( resourcea , resourceb ) ; }	aggregates two resources which have the same type .
public static boolean renamefile ( string filepath , string oldfilename , string newfilename ) { if ( ( filepath == null ) || filepath . isempty ( ) || ( oldfilename == null ) || oldfilename . isempty ( ) || ( newfilename == null ) || newfilename . isempty ( ) ) { return _bool ; } file oldfile = new file ( filepath + file . separator + oldfilename ) ; file newfile = new file ( filepath + file . separator + newfilename ) ; boolean issuccessfulrename ; try { issuccessfulrename = oldfile . renameto ( newfile ) ; } catch ( exception e ) { logger . debug ( e . tostring ( ) + system . lineseparator ( ) + stacktrace . getstringfromstacktrace ( e ) ) ; issuccessfulrename = _bool ; } return issuccessfulrename ; }	this is a quiet method .
@ rpcmethod public void startimagescan ( string datastore , long scanrate , long timeout , asyncmethodcallback < host . asyncclient . start_image_scan_call > handler ) throws rpcexception { ensureclient ( ) ; startimagescanrequest request = new startimagescanrequest ( datastore ) ; if ( null != scanrate ) { request . setscan_rate ( scanrate ) ; } if ( null != timeout ) { request . settimeout ( timeout ) ; } try { logger . info ( _str , gethostip ( ) , request ) ; clientproxy . settimeout ( start_image_scan_timeout_ms ) ; clientproxy . start_image_scan ( request , handler ) ; } catch ( texception e ) { throw new rpcexception ( e . getmessage ( ) ) ; } }	this method performs an asynchronous thrift call to start an image scan on a datastore .
public static string format ( int n , string col ) { string res = padd + n ; return res . substring ( res . length ( ) - col . length ( ) ) ; }	pad a number from left .
public gitconflictexception ( string message ) { super ( message ) ; }	constrcut a new gitconflictexception based on message.
private void trace ( ) { gluseprogram ( photontraceprogram ) ; long thistime = system . nanotime ( ) ; float elapsedseconds = ( thistime - firsttime ) / _num ; gluniform1f ( timeuniform , elapsedseconds ) ; glbindbufferbase ( gl_shader_storage_buffer , boxesssbobinding , ssbo ) ; glbindbufferbase ( gl_uniform_buffer , imagesubobinding , imagehandlesubo ) ; int invocationsperdimension = photonsperframe ; int worksizex = mathroundpot ( invocationsperdimension ) ; int worksizey = mathroundpot ( invocationsperdimension ) ; if ( variablegroupsize ) { arbcomputevariablegroupsize . gldispatchcomputegroupsizearb ( worksizex / workgroupsizex , worksizey / workgroupsizey , _num , workgroupsizex , workgroupsizey , _num ) ; } else { gldispatchcompute ( worksizex / workgroupsizex , worksizey / workgroupsizey , _num ) ; } glmemorybarrier ( gl_shader_image_access_barrier_bit ) ; glbindbufferbase ( gl_shader_storage_buffer , boxesssbobinding , _num ) ; glbindbufferbase ( gl_uniform_buffer , imagesubobinding , _num ) ; gluseprogram ( _num ) ; }	trace some rays from the light .
public caption addelement ( string element ) { addelementtoregistry ( integer . tostring ( element . hashcode ( ) ) , element ) ; return ( this ) ; }	add an element to the element.
protected void doresetcurrentposition ( ) { this . currentposition = this . position ; }	method to reset the current position.
public floatbuffer put ( float [ ] src , int srcoffset , int floatcount ) { jtranscarrays . checkoffsetandcount ( src . length , srcoffset , floatcount ) ; if ( floatcount > remaining ( ) ) { throw new bufferoverflowexception ( ) ; } for ( int i = srcoffset ; i < srcoffset + floatcount ; ++ i ) { put ( src [ i ] ) ; } return this ; }	writes floats from the given float array , starting from the specified offset , to the current position and increases the position by the number of floats written .
private boolean messagechanged ( string oldmessage , string newmessage ) { return ( ( newmessage == null ) && ( oldmessage != null ) ) || ( ( newmessage != null ) && ! newmessage . equals ( oldmessage ) ) ; }	check if a message string has changed .
private multilinestring readmultiline ( orageom orageom ) { int nelem = orageom . numelements ( ) ; list geoms = new arraylist ( ) ; for ( int i = _num ; i < nelem ; i ++ ) { int etype = orageom . etype ( i ) ; if ( etype != orageom . etype . line ) break ; geoms . add ( readline ( orageom , i ) ) ; } multilinestring lines = geometryfactory . createmultilinestring ( geometryfactory . tolinestringarray ( geoms ) ) ; return lines ; }	create multilinestring as encoded by eleminfo .
public boolean iscalledmethod ( string classname , string methodname ) { if ( totestmethods . isempty ( ) ) computeinterestingclasses ( graph ) ; if ( totestmethods . contains ( classname + methodname ) ) { return _bool ; } return _bool ; }	determine if methodname of classname can be called through the target class.
public explanation idfexplain ( collectionstatistics collectionstats , termstatistics termstats [ ] ) { final long doccount = collectionstats . doccount ( ) == - _num ? collectionstats . maxdoc ( ) : collectionstats . doccount ( ) ; float idf = _num ; list < explanation > details = new arraylist < > ( ) ; for ( final termstatistics stat : termstats ) { final long df = stat . docfreq ( ) ; final float termidf = idf ( df , doccount ) ; details . add ( explanation . match ( termidf , _str + df + _str + doccount + _str ) ) ; idf += termidf ; } return explanation . match ( idf , _str , details ) ; }	computes a score factor for a phrase.
public void removearea ( final section area ) { if ( null == area ) return ; areas . remove ( area ) ; collections . sort ( areas , new sectioncomparator ( ) ) ; fireupdateevent ( section_event ) ; }	removes the given section from the list of areas.
public void testemptyrunindex ( ) { string rs = _str ; settings s = new settings ( _str ) ; s . setsecondarynamespace ( _str ) ; assertequals ( s . getint ( rs ) , _num ) ; settings . setrunindex ( _num ) ; assertequals ( s . getint ( rs ) , _num ) ; settings . setrunindex ( _num ) ; assertequals ( s . getint ( rs ) , _num ) ; settings . setrunindex ( _num ) ; assertequals ( s . getint ( rs ) , _num ) ; }	test filling empty values of run index from secondary namespace.
@ suppresswarnings ( _str ) public void connect ( final bluetoothdevice device , final ilogsession session ) { if ( mmanageddevices . contains ( device ) ) return ; mmanageddevices . add ( device ) ; blemanager < blemanagercallbacks > manager = mblemanagers . get ( device ) ; if ( manager != null ) { if ( session != null ) manager . setlogger ( session ) ; manager . connect ( device ) ; } else { mblemanagers . put ( device , manager = initializemanager ( ) ) ; manager . setgattcallbacks ( blemulticonnectprofileservice . this ) ; manager . setlogger ( session ) ; manager . connect ( device ) ; } }	adds the given device to managed and stars connecting to it.
public scannerexception ( errormessages message ) { this ( null , errormessages . get ( message ) , message , - _num , - _num ) ; }	creates a new scannerexception with a message only .
private static void formattimezone ( calendar cal , stringbuilder buf ) { timezone tz = cal . gettimezone ( ) ; if ( tz == null ) return ; int offset ; if ( tz . indaylighttime ( cal . gettime ( ) ) ) { offset = tz . getrawoffset ( ) + ( tz . usedaylighttime ( ) ? _num : _num ) ; } else { offset = tz . getrawoffset ( ) ; } if ( offset == _num ) { buf . append ( _str ) ; return ; } if ( offset >= _num ) buf . append ( _str ) ; else { buf . append ( _str ) ; offset *= - _num ; } offset /= _num * _num ; formattwodigits ( offset / _num , buf ) ; buf . append ( _str ) ; formattwodigits ( offset % _num , buf ) ; }	formats time zone specifier .
public mutablestring ( final mutablestring s ) { makecompactmutablestring ( s . length ( ) ) ; system . arraycopy ( s . array , _num , array , _num , array . length ) ; }	creates a new compact mutable string copying a given mutable string .
private void request ( ) { if ( isvisible ( ) && stream != null && ! stream . isempty ( ) ) { loading = _bool ; if ( type == type . followers ) { api . getfollowers ( stream ) ; } else if ( type == type . subscribers ) { api . getsubscribers ( stream ) ; } } }	try to request new data if the dialog is open and a stream is set .
public list < statement > mungedstyle ( ) { list < statement > st = built ( ) ; if ( includebasicentityforsubject ) { st . remove ( entitydataaboutdecl ) ; st . remove ( entitydataversiondecl ) ; st . remove ( entitydatadatemodifieddecl ) ; statement ( st , uris . entity ( ) + entity , schemadotorg . version , version ) ; statement ( st , uris . entity ( ) + entity , schemadotorg . date_modified , datemodified ) ; } st . remove ( statementtypedecl ) ; for ( extrainfo e : extrainfo ) { e . munge ( st ) ; } return st ; }	get the results in munged style .
private void writerequest ( final nextfilter nextfilter , final socksproxyrequest request , int step ) { try { iobuffer buf = null ; if ( step == socksproxyconstants . socks5_greeting_step ) { buf = encodeinitialgreetingpacket ( request ) ; } else if ( step == socksproxyconstants . socks5_auth_step ) { buf = encodeauthenticationpacket ( request ) ; if ( buf == null ) { step = socksproxyconstants . socks5_request_step ; } } if ( step == socksproxyconstants . socks5_request_step ) { buf = encodeproxyrequestpacket ( request ) ; } buf . flip ( ) ; writedata ( nextfilter , buf ) ; } catch ( exception ex ) { closesession ( _str , ex ) ; } }	encodes a socks5 request and writes it to the next filter so it can be sent to the proxy server .
public synchronized void putasint ( object key , int value ) { put ( key , new integer ( value ) ) ; }	set attribute of selected key to selected value overridden method to allow notification of process var changes.
public void close ( ) throws ioexception { if ( writer != null ) { writer . close ( ) ; } else { cb = null ; closed = _bool ; } }	close the stream , flushing it first.
private certpath buildcertpath ( x509certificate endcert ) throws certificatepathbuildingexception { certpathbuilder cpb = null ; try { cpb = certpathbuilder . getinstance ( _str ) ; } catch ( nosuchalgorithmexception e ) { throw new certificatepathbuildingexception ( _str + e . getmessage ( ) , e ) ; } pkixbuilderparameters params = createpkixbuilderparameters ( endcert ) ; certpathbuilderresult cpbresult ; try { cpbresult = cpb . build ( params ) ; } catch ( certpathbuilderexception e ) { throw new certificatepathbuildingexception ( e . getmessage ( ) , e . getcause ( ) ) ; } catch ( invalidalgorithmparameterexception e ) { throw new certificatepathbuildingexception ( e . getmessage ( ) , e ) ; } certpath cp = cpbresult . getcertpath ( ) ; return cp ; }	build and validate cert path from end certificate.
public void addconfiguration ( inputstream in ) throws smsexception , ssoexception { servicemanager sm = new servicemanager ( token ) ; document doc = smsschema . getxmldocument ( in ) ; nodelist nodes = doc . getelementsbytagname ( smsutils . service ) ; for ( int i = _num ; ( nodes != null ) && ( i < nodes . getlength ( ) ) ; i ++ ) { node servicenode = nodes . item ( i ) ; string sname = xmlutils . getnodeattributevalue ( servicenode , smsutils . name ) ; string sversion = xmlutils . getnodeattributevalue ( servicenode , smsutils . version ) ; node confignode ; if ( sname . equals ( servicename ) && ( sversion . equals ( version ) ) && ( ( confignode = xmlutils . getchildnode ( servicenode , smsutils . configuration ) ) != null ) ) { createserviceconfig . createservice ( sm , sname , sversion , confignode , null ) ; } } }	adds instances , global and organization configurations.
public static int stringtodictid ( string str ) { try { byte [ ] bytes = str . getbytes ( _str ) ; return bytesutil . readunsigned ( bytes , _num , bytes . length ) ; } catch ( unsupportedencodingexception e ) { return _num ; } }	the reverse of dictidtostring ( ) , returns integer id.
public void start ( ) throws ioexception , mqttexception { final string methodname = _str ; try { log . fine ( class_name , methodname , _str , new object [ ] { host , new integer ( port ) , new long ( contimeout * _num ) } ) ; socketaddress sockaddr = new inetsocketaddress ( host , port ) ; socket = factory . createsocket ( ) ; socket . connect ( sockaddr , contimeout * _num ) ; } catch ( connectexception ex ) { log . fine ( class_name , methodname , _str , null , ex ) ; throw new mqttexception ( mqttexception . reason_code_server_connect_error , ex ) ; } }	starts the module , by creating a tcp socket to the server .
public void callseriallyandwait ( runnable r ) { if ( isedt ( ) ) { throw new runtimeexception ( _str ) ; } runnablewrapper c = new runnablewrapper ( r , _num ) ; callserially ( c ) ; flushedt ( ) ; synchronized ( lock ) { while ( ! c . isdone ( ) ) { try { lock . wait ( _num ) ; } catch ( interruptedexception err ) { } } } }	identical to callserially with the added benefit of waiting for the runnable method to complete .
public list < contact > find ( ) { list < long > ids = new arraylist < > ( ) ; if ( innerqueries != null ) { for ( query query : innerqueries ) { ids . addall ( query . findinner ( ) ) ; } } else { if ( mimewhere . isempty ( ) ) { return find ( null ) ; } for ( map . entry < string , where > entry : mimewhere . entryset ( ) ) { ids = findids ( ids , entry . getkey ( ) , entry . getvalue ( ) ) ; } } return find ( ids ) ; }	retrieves a list of contacts that satisfy this query .
public void persistbeandata ( object bean , boolean printonly ) { persistbeantrycatch ( bean ) ; callpersistemittedkeyvalue ( printonly ) ; }	this method make bean persist depending on annotations used .
private void refill ( ) throws ioexception { offset += usablelength ; int leftover = length - usablelength ; system . arraycopy ( buffer , usablelength , buffer , _num , leftover ) ; int requested = buffer . length - leftover ; int returned = read ( input , buffer , leftover , requested ) ; length = returned < _num ? leftover : returned + leftover ; if ( returned < requested ) usablelength = length ; else { usablelength = findsafeend ( ) ; if ( usablelength < _num ) usablelength = length ; } wrapper . settext ( buffer , _num , math . max ( _num , usablelength ) ) ; iterator . settext ( wrapper ) ; }	refill the buffer , accumulating the offset and setting usablelength to the last unambiguous break position.
protected void fireinsertupdate ( documentevent evt ) { if ( tokenmarker != null ) { documentevent . elementchange ch = evt . getchange ( getdefaultrootelement ( ) ) ; if ( ch != null ) { tokenmarker . insertlines ( ch . getindex ( ) + _num , ch . getchildrenadded ( ) . length - ch . getchildrenremoved ( ) . length ) ; } } super . fireinsertupdate ( evt ) ; }	we overwrite this method to update the token marker state immediately so that any event listeners get a consistent token marker .
int pending ( ) { return pending . get ( ) ; }	number of pending operations.
private boolean isincluded ( final httpservletrequest request ) { string uri = ( string ) request . getattribute ( _str ) ; boolean includerequest = ! ( uri == null ) ; if ( includerequest && log . isdebugenabled ( ) ) { log . debug ( _str + _str , request . getrequesturl ( ) ) ; } return includerequest ; }	checks if the request uri is an include.
public void drawdomainmarker ( graphics2d g2 , contourplot plot , valueaxis domainaxis , marker marker , rectangle2d dataarea ) { if ( marker instanceof valuemarker ) { valuemarker vm = ( valuemarker ) marker ; double value = vm . getvalue ( ) ; range range = domainaxis . getrange ( ) ; if ( ! range . contains ( value ) ) { return ; } double x = domainaxis . valuetojava2d ( value , dataarea , rectangleedge . bottom ) ; line2d line = new line2d . double ( x , dataarea . getminy ( ) , x , dataarea . getmaxy ( ) ) ; paint paint = marker . getoutlinepaint ( ) ; stroke stroke = marker . getoutlinestroke ( ) ; g2 . setpaint ( paint != null ? paint : plot . default_outline_paint ) ; g2 . setstroke ( stroke != null ? stroke : plot . default_outline_stroke ) ; g2 . draw ( line ) ; } }	draws a vertical line on the chart to represent a ' range marker ' .
public void remove ( string attrname , string delvalue ) { int index = indexof ( attrname ) ; if ( index != - _num ) { attr attr = ( attr ) _attrs . get ( index ) ; attr . removevalue ( delvalue ) ; if ( attr . size ( ) == _num ) { _attrs . remove ( index ) ; } } }	remove a specified value for an attribute in the set.
private appliedmigration createappliedschemamigration ( ) { return new appliedmigration ( _num , _num , migrationversion . fromversion ( integer . tostring ( _num ) ) , _str , migrationtype . schema , _str , null , new date ( ) , _str , _num , _bool ) ; }	creates a new applied schema migration with this version .
public static string makesigalg ( string digalg , string encalg ) { digalg = digalg . replace ( _str , _str ) ; if ( encalg . equalsignorecase ( _str ) ) encalg = _str ; return digalg + _str + encalg ; }	creates a signature algorithm name from a digest algorithm name and a encryption algorithm name .
public static int indexof ( byte [ ] src , byte [ ] target , int fromidx ) { final int to = src . length - target . length + _num ; for ( int i = fromidx ; i < to ; i ++ ) { if ( src [ i ] == target [ _num ] ) { boolean equals = _bool ; for ( int j = _num , k = i + _num ; j < target . length && equals ; j ++ , k ++ ) { if ( src [ k ] != target [ j ] ) { equals = _bool ; } } if ( equals ) { return i ; } } } return - _num ; }	searches for target bytes in the source bytes .
@ override public int read ( byte [ ] buf , int offset , int length ) throws ioexception { try { if ( _channel == null ) { return - _num ; } int remaining = _readbuffer . remaining ( ) ; if ( remaining > _num ) { _readbuffer . get ( buf , offset , remaining ) ; return remaining ; } _readbuffer . clear ( ) ; int channelread = _channel . read ( _readbuffer ) ; _readbuffer . flip ( ) ; if ( channelread < _num ) return - _num ; _readbuffer . get ( buf , offset , channelread ) ; return channelread ; } catch ( interruptedioexception e ) { if ( _throwreadinterrupts ) throw e ; log . log ( level . finest , e . tostring ( ) , e ) ; } catch ( ioexception e ) { if ( _throwreadinterrupts ) throw e ; log . log ( level . finer , e . tostring ( ) , e ) ; } return - _num ; }	reads bytes from the socket .
string readutf ( byte data [ ] , int off , int len ) { int offset = off ; stringbuffer buf = new stringbuffer ( ) ; for ( int end = offset + len ; offset < end ; ) { int ch = data [ offset ++ ] & _num ; switch ( ch > > _num ) { case _num : case _num : case _num : case _num : case _num : case _num : case _num : case _num : break ; case _num : case _num : if ( offset >= len ) { return null ; } ch = ( ( ch & _num ) << _num ) | ( data [ offset ++ ] & _num ) ; break ; case _num : if ( offset + _num >= len ) { return null ; } ch = ( ( ch & _num ) << _num ) | ( ( data [ offset ++ ] & _num ) << _num ) | ( data [ offset ++ ] & _num ) ; break ; default : if ( offset + _num >= len ) { return null ; } ch = ( ( ch & _num ) << _num ) | ( data [ offset ++ ] & _num ) ; break ; } buf . append ( ( char ) ch ) ; } return buf . tostring ( ) ; }	read data bytes as a utf stream .
public turtlewriter ( outputstream out ) { this ( new outputstreamwriter ( out , charset . forname ( _str ) ) ) ; }	creates a new turtlewriter that will write to the supplied outputstream .
private char lookahead ( ) { return curcharindex < pattern . length ( ) - _num ? pattern . charat ( curcharindex + _num ) : eof ; }	returns the next character in the input pattern without advancing .
public static boolean isnumber ( string s ) { if ( s . length ( ) == _num ) { return _bool ; } for ( char c : s . tochararray ( ) ) { if ( ! character . isdigit ( c ) ) { return _bool ; } } return _bool ; }	check if this string is a decimal number .
private state ( circuitstate circuitstate , duration timeoutduration , eventcounter counter ) { this . circuitstate = circuitstate ; this . counter = counter ; if ( timeoutduration . iszero ( ) || timeoutduration . isnegative ( ) ) { timedouttimenanos = _num ; } else { timedouttimenanos = ticker . read ( ) + timeoutduration . tonanos ( ) ; } }	creates a new instance .
public void cleanup ( buttongroup bg ) { if ( bg != null ) { bg . remove ( layername ) ; } cleanup ( ) ; }	same as cleanup , except the layer name toggle button gets removed from the given button group .
public static map < metakey , string > union ( final map < metakey , string > providedmetadata , final map < metakey , string > extractedmetadata ) { final int size1 = providedmetadata != null ? providedmetadata . size ( ) : _num ; final int size2 = extractedmetadata != null ? extractedmetadata . size ( ) : _num ; if ( size1 + size2 == _num ) { return collections . emptymap ( ) ; } final map < metakey , string > result = new hashmap < > ( size1 + size2 ) ; if ( extractedmetadata != null ) { result . putall ( extractedmetadata ) ; } if ( providedmetadata != null ) { result . putall ( providedmetadata ) ; } return collections . unmodifiablemap ( result ) ; }	return an unmodifiable map of provided and extracted meta data.
public static void formatdouble ( double source , int decimals , int precision , stringbuffer target ) { int scale = ( math . abs ( source ) >= _num ) ? decimals : precision ; if ( toomanydigitsused ( source , scale ) || tooclosetoround ( source , scale ) ) { formatdoubleprecise ( source , decimals , precision , target ) ; } else { formatdoublefast ( source , decimals , precision , target ) ; } }	rounds the given source value at the given precision and writes the rounded value into the given target.
protected view createchild ( string name ) { view view = null ; if ( name . equals ( tf_parentid ) || name . equals ( tf_client_type ) ) { view = new cctextfield ( this , name , _str ) ; } else if ( name . equals ( sec_mh_common ) ) { view = new ccsecondarymasthead ( this , name ) ; } else if ( name . equals ( pgtitle ) ) { view = new ccpagetitle ( this , ptmodel , name ) ; } else if ( ptmodel . ischildsupported ( name ) ) { view = ptmodel . createchild ( this , name ) ; } else if ( name . equals ( property_attribute ) ) { view = new ampropertysheet ( this , propertysheetmodel , name ) ; } else if ( propertysheetmodel . ischildsupported ( name ) ) { view = propertysheetmodel . createchild ( this , name , getmodel ( ) ) ; } else { view = super . createchild ( name ) ; } return view ; }	creates user interface components used by this view bean .
public synchronized void draw ( final graphics2d gfx , final float x , final float y ) { if ( ! isempty ( ) ) { m_textlayout . draw ( gfx , x , y ) ; for ( final chighlighting highlighting : new arraylist < chighlighting > ( m_highlighting ) ) { final double bpx = ( x + highlighting . getstart ( ) ) - _num ; final double bpy = ( y - m_charheight ) + _num ; final double bpw = highlighting . getend ( ) + _num ; final double bph = m_charheight - _num ; drawhighlighting ( gfx , bpx , bpy , bpw , bph , highlighting . getcolor ( ) ) ; } } }	draws the line onto a graphics context .
public boolean isabstract ( ) { return modifier . isabstract ( flags ) ; }	utility method to query the modifier flags of this member .
public static file relativefile ( file f ) { if ( f . isabsolute ( ) ) { f = relativefile ( new file ( _str ) , f ) ; } return f ; }	turns the given path , if absolute , into a path relative to the vm ' s current working directory and leaves it alone otherwise.
public xmlparser ( final string namespace , final string [ ] schemas ) throws xmlexception { try { jaxbcontext jc = jaxbcontext . newinstance ( namespace ) ; marshaller = jc . createmarshaller ( ) ; marshaller . setschema ( xmlschemautils . createschema ( schemas ) ) ; unmarshaller = jc . createunmarshaller ( ) ; unmarshaller . setschema ( xmlschemautils . createschema ( schemas ) ) ; } catch ( jaxbexception e ) { throw new xmlexception ( _str + namespace , e ) ; } }	creates the xmlparser with the namespace and schema files for validation .
public string [ ] splitresourcename ( string servicetypename , string resourcename ) throws namenotfoundexception , ssoexception , policyexception { servicetype st = getservicetype ( servicetypename ) ; set prefixes = getmanagedresourcenames ( servicetypename ) ; string [ ] retval = new string [ _num ] ; if ( prefixes . isempty ( ) ) { retval [ _num ] = _str ; retval [ _num ] = resourcename ; return retval ; } iterator iter = prefixes . iterator ( ) ; string tmp = null ; resourcematch matchresult = null ; boolean foundsupermatch = _bool ; boolean foundexactmatch = _bool ; while ( iter . hasnext ( ) ) { tmp = ( string ) iter . next ( ) ; matchresult = st . compare ( resourcename , tmp ) ; if ( matchresult . equals ( resourcematch . super_resource_match ) ) { foundsupermatch = _bool ; break ; } if ( matchresult . equals ( resourcematch . exact_match ) ) { foundexactmatch = _bool ; break ; } } if ( foundsupermatch ) { retval [ _num ] = tmp ; retval [ _num ] = st . getsubresource ( resourcename , tmp ) ; return retval ; } if ( foundexactmatch ) { retval [ _num ] = tmp ; retval [ _num ] = _str ; return retval ; } retval [ _num ] = _str ; retval [ _num ] = resourcename ; return retval ; }	returns the resource prefix ( super - resource ) and the rest of the resource name ( sub - resource ).
void materialize ( ) { if ( cachefill < _num ) { return ; } double min = double . max_value , max = double . min_value ; for ( int i = _num ; i < cachefill ; i ++ ) { min = math . min ( min , cachec [ i ] ) ; max = math . max ( max , cachec [ i ] ) ; } linearscale scale = new linearscale ( min , max ) ; min = scale . getmin ( ) ; max = scale . getmax ( ) ; this . base = min ; this . max = max ; this . binsize = ( max - min ) / this . destsize ; this . data = new long [ this . destsize << _num ] ; size = destsize ; final int end = cachefill ; cachefill = - _num ; for ( int i = _num ; i < end ; i ++ ) { increment ( cachec [ i ] , cachev [ i ] ) ; } cachec = null ; cachev = null ; }	materialize the histogram from the cache .
public arrayfieldvector ( field < t > field , t [ ] v1 , t [ ] v2 ) throws mathillegalargumentexception , nullargumentexception { mathutils . checknotnull ( v1 ) ; mathutils . checknotnull ( v2 ) ; if ( v1 . length + v2 . length == _num ) { throw new mathillegalargumentexception ( localizedcoreformats . vector_must_have_at_least_one_element ) ; } data = matharrays . buildarray ( field , v1 . length + v2 . length ) ; system . arraycopy ( v1 , _num , data , _num , v1 . length ) ; system . arraycopy ( v2 , _num , data , v1 . length , v2 . length ) ; this . field = field ; }	construct a vector by appending one vector to another vector .
private void verifytargetsessionislocalorstateless ( sessionrequest req , sessionid sid ) throws sessionexception , sessionrequestexception , forwardsessionrequestexception { if ( statelesssessionmanager . containsjwt ( sid ) ) { return ; } string hostserverid = foreignsessionhandler . getcurrenthostserver ( sid ) ; if ( ! serverconfig . islocalserver ( hostserverid ) ) { try { throw new forwardsessionrequestexception ( forward ( session_service_url_service . getsessionserviceurl ( hostserverid ) , req ) ) ; } catch ( sessionexception se ) { if ( ! sessionservice . checkserverup ( hostserverid ) ) { string retryhostserverid = foreignsessionhandler . getcurrenthostserver ( sid ) ; if ( retryhostserverid . equals ( hostserverid ) ) { throw se ; } else { if ( ! serverconfig . islocalserver ( retryhostserverid ) ) { throw new forwardsessionrequestexception ( forward ( session_service_url_service . getsessionserviceurl ( hostserverid ) , req ) ) ; } } } else { throw se ; } } } if ( ! sessionservice . checksessionlocal ( sid ) ) { throw new sessionrequestexception ( sid , sessionbundle . getstring ( _str ) ) ; } }	verify that this server is the correct host for the session and the session can be found ( or recovered ) locally.
public static boolean isjavabuiltindatatype ( class clazz ) { if ( clazz == null ) { return _bool ; } class clazzboxed = getboxedtype ( clazz ) ; if ( isnumeric ( clazzboxed ) ) { return _bool ; } if ( isboolean ( clazzboxed ) ) { return _bool ; } if ( clazzboxed . equals ( string . class ) ) { return _bool ; } if ( ( clazzboxed . equals ( char . class ) ) || ( clazzboxed . equals ( character . class ) ) ) { return _bool ; } if ( clazzboxed . equals ( void . class ) ) { return _bool ; } return _bool ; }	returns true if the class passed in is a java built - in data type ( primitive or wrapper ) including string and ' null ' .
protected boolean iscontrolchar ( char ch ) { return character . isisocontrol ( ch ) && ! character . iswhitespace ( ch ) ; }	determines if the character is a control character .
public void encode ( outputstream out ) throws ioexception { deroutputstream tmp = new deroutputstream ( ) ; if ( extensionvalue == null ) { extensionid = pkixextensions . policyconstraints_id ; critical = _bool ; encodethis ( ) ; } super . encode ( tmp ) ; out . write ( tmp . tobytearray ( ) ) ; }	write the extension to the deroutputstream .
< t > list < t > onfindall ( class < t > modelclass , boolean iseager , long ... ids ) { list < t > datalist ; if ( isaffectalllines ( ids ) ) { datalist = query ( modelclass , null , null , null , null , null , _str , null , getforeignkeyassociations ( modelclass . getname ( ) , iseager ) ) ; } else { datalist = query ( modelclass , null , getwhereofidswithor ( ids ) , null , null , null , _str , null , getforeignkeyassociations ( modelclass . getname ( ) , iseager ) ) ; } return datalist ; }	the open interface for other classes in crud package to query multiple records by an id array.
public boolean iscached ( string requesturl , int maxwidth , int maxheight ) { return iscached ( requesturl , maxwidth , maxheight , scaletype . center_inside ) ; }	checks if the item is available in the cache .
public style addstyle ( string nm , style parent ) { stylecontext styles = ( stylecontext ) getattributecontext ( ) ; return styles . addstyle ( nm , parent ) ; }	adds a new style into the logical style hierarchy.
public static textwithmnemonic parsetext ( final string textwithmnemonic ) { if ( textwithmnemonic == null ) { throw new illegalargumentexception ( _str ) ; } int index = - _num ; final stringbuffer plaintext = new stringbuffer ( ) ; for ( int i = _num ; i < textwithmnemonic . length ( ) ; i ++ ) { char ch = textwithmnemonic . charat ( i ) ; if ( ch == _str ) { i ++ ; if ( i >= textwithmnemonic . length ( ) ) { break ; } ch = textwithmnemonic . charat ( i ) ; if ( ch != _str ) { index = plaintext . length ( ) ; } } plaintext . append ( ch ) ; } return new textwithmnemonic ( plaintext . tostring ( ) , index ) ; }	parses text that might contain mnemonic and returns structure which contains plain text and index of mnemonic char ( if any ).
public void checkpermissions ( namespaceentity namespaceentity , string ... requestediamrolenames ) { checkpermissions ( namespaceentity , arrays . aslist ( requestediamrolenames ) ) ; }	throws accessdeniedexception if the given namespace is not authorized to access any of the given iam role names.
private static annotatedtypemirror asoutersuper ( types types , annotatedtypefactory atypefactory , annotatedtypemirror type , annotatedtypemirror supertype ) { if ( type . getkind ( ) == typekind . declared ) { annotateddeclaredtype dt = ( annotateddeclaredtype ) type ; annotateddeclaredtype enclosingtype = dt ; typemirror supertypemirror = types . erasure ( supertype . getunderlyingtype ( ) ) ; while ( enclosingtype != null ) { typemirror enclosingtypemirror = types . erasure ( enclosingtype . getunderlyingtype ( ) ) ; if ( types . issubtype ( enclosingtypemirror , supertypemirror ) ) { dt = enclosingtype ; break ; } enclosingtype = enclosingtype . getenclosingtype ( ) ; } if ( enclosingtype == null ) { return supertype ; } return assuper ( atypefactory , dt , supertype ) ; } return assuper ( atypefactory , type , supertype ) ; }	return the base type of type or any of its outer types that starts with the given type.
public void reload ( solrcore core , solrindexsearcher searcher ) throws ioexception { log . info ( _str ) ; if ( dictionary == null && storedir != null ) { fileinputstream is = new fileinputstream ( new file ( storedir , factory . storefilename ( ) ) ) ; try { if ( lookup . load ( is ) ) { return ; } } finally { ioutils . closewhilehandlingexception ( is ) ; } log . debug ( _str ) ; } build ( core , searcher ) ; }	reloads the underlying lucene suggester.
public static string asstring ( string jsonpath , map < string , object > json ) { return pathas ( string . class , jsonpath , json ) ; }	helper function for reading a string value from a json object tree .
@ override public serverheartbeat serverdyn ( string address , int port , boolean isssl , string clusterid , string displayname ) { objects . requirenonnull ( address ) ; objects . requirenonnull ( clusterid ) ; clusterheartbeat cluster = createcluster ( clusterid ) ; serverheartbeat server = cluster . createserver ( address , port , isssl ) ; if ( displayname != null ) { server . setdisplayname ( displayname ) ; } cluster . adddynamicserver ( server ) ; return server ; }	create an external / configured server.
public void runtest ( ) throws throwable { document doc ; nodelist genderlist ; node gendernode ; characterdata enttext ; entityreference entreference ; node appendednode ; doc = ( document ) load ( _str , _bool ) ; genderlist = doc . getelementsbytagname ( _str ) ; gendernode = genderlist . item ( _num ) ; entreference = doc . createentityreference ( _str ) ; assertnotnull ( _str , entreference ) ; appendednode = gendernode . appendchild ( entreference ) ; enttext = ( characterdata ) entreference . getfirstchild ( ) ; assertnotnull ( _str , enttext ) ; { boolean success = _bool ; try { enttext . replacedata ( _num , _num , _str ) ; } catch ( domexception ex ) { success = ( ex . code == domexception . no_modification_allowed_err ) ; } asserttrue ( _str , success ) ; } }	runs the test case .
public void removeall ( ) { mparts . clear ( ) ; }	remove all of the parts .
public static boolean executableexists ( string executable ) { file directfile = new file ( executable ) ; if ( directfile . exists ( ) && directfile . canexecute ( ) ) { return _bool ; } for ( string pathstring : getsystempath ( ) ) { path path = paths . get ( pathstring ) ; if ( files . exists ( path . resolve ( executable ) ) && files . isexecutable ( path . resolve ( executable ) ) ) { return _bool ; } } return _bool ; }	check whether an executable exists , either at a specific path ( if a full path is given ) or on the path .
@ override public string tostring ( ) { stringbuilder buf = new stringbuilder ( ) ; int i = _num ; for ( pseudoop op : contents ) { buf . append ( string . format ( _str , i ++ , op ) ) ; } return buf . tostring ( ) ; }	format the p - code for this method.
private list < file > combine ( list < file > lista , list < file > listb ) { linkedhashset < file > combinedprojects = sets . newlinkedhashset ( lista ) ; combinedprojects . addall ( listb ) ; return new arraylist < > ( combinedprojects ) ; }	combine lista and listb to a single list without duplicates .
public long generatenewpingid ( ) { preferencestore prefs = getpreferencestore ( ) ; random rnd = new random ( ) ; long id = rnd . nextlong ( ) ; synchronized ( ddmspreferencestore . class ) { prefs . setvalue ( ping_id , id ) ; try { prefs . save ( ) ; } catch ( ioexception e ) { } } return id ; }	generates a new random ping id and saves it in the preference store .
public boolean isvalid ( ) { return system . currenttimemillis ( ) < creationtime + lifetime + ( lifetime / _num ) ; }	return security token validity.
public static model readfrom ( virtualfile file ) throws serverexception , forbiddenexception , ioexception { requirenonnull ( file , _str ) ; return fetchmodel ( xmltree . from ( file . getcontent ( ) ) ) ; }	reads model from given virtual file .
public boolean isvalueexistforkey ( string key ) { boolean isvalueexists ; try { string string = getstring ( key , _str ) ; isvalueexists = ! string . equalsignorecase ( _str ) ; } catch ( classcastexception e ) { try { int anint = getint ( key , _num ) ; isvalueexists = anint != _num ; } catch ( classcastexception e1 ) { try { long along = getlong ( key , _num ) ; isvalueexists = along != _num ; } catch ( classcastexception e2 ) { try { float afloat = getfloat ( key , _num ) ; isvalueexists = afloat != _num ; } catch ( classcastexception e3 ) { try { boolean aboolean = getboolean ( key , _bool ) ; isvalueexists = ! aboolean ; } catch ( exception e4 ) { isvalueexists = _bool ; e . printstacktrace ( ) ; } } } } } catch ( exception e ) { isvalueexists = _bool ; } return isvalueexists ; }	check if value exists for key .
public void updateviewport ( ) { settoortho ( _bool , virtualviewport . getwidth ( ) , virtualviewport . getheight ( ) ) ; }	this must be called in applicationlistener.
public string tostring ( ) { if ( keyusages == null ) return _str ; string usage = _str ; boolean first = _bool ; for ( objectidentifier oid : keyusages ) { if ( ! first ) { usage += _str ; } string result = map . get ( oid ) ; if ( result != null ) { usage += result ; } else { usage += oid . tostring ( ) ; } first = _bool ; } return super . tostring ( ) + _str + usage + _str ; }	return the extension as user readable string .
public static void writeboxplot ( tdoubleobjecthashmap < double [ ] > table , string file ) throws ioexception { int maxsize = _num ; tdoubleobjectiterator < double [ ] > it = table . iterator ( ) ; for ( int i = _num ; i < table . size ( ) ; i ++ ) { it . advance ( ) ; maxsize = math . max ( maxsize , it . value ( ) . length ) ; } double keys [ ] = table . keys ( ) ; arrays . sort ( keys ) ; bufferedwriter writer = new bufferedwriter ( new filewriter ( file ) ) ; for ( int k = _num ; k < keys . length ; k ++ ) { writer . write ( string . valueof ( keys [ k ] ) ) ; if ( k + _num < keys . length ) writer . write ( tab ) ; } writer . newline ( ) ; for ( int i = _num ; i < maxsize ; i ++ ) { for ( int k = _num ; k < keys . length ; k ++ ) { double [ ] list = table . get ( keys [ k ] ) ; if ( i < list . length ) { writer . write ( string . valueof ( list [ i ] ) ) ; } else { writer . write ( na ) ; } if ( k + _num < keys . length ) writer . write ( tab ) ; } writer . newline ( ) ; } writer . close ( ) ; }	writes a table with one column for each map entry.
public void testclearbitnegativeinside3 ( ) { string as = _str ; int number = _num ; biginteger anumber = new biginteger ( as ) ; biginteger result = anumber . clearbit ( number ) ; assertequals ( as , result . tostring ( ) ) ; }	clearbit ( 2 ) in the negative number with all ones in bit representation.
@ theory public void logentrieshavesameorderasindexes ( object [ ] datapoint ) { int index1 = ( int ) datapoint [ _num ] ; int index2 = ( int ) datapoint [ _num ] ; logentry first = logentries [ index1 ] ; logentry second = logentries [ index2 ] ; log . debug ( _str , index1 , index2 ) ; int result = tested . compare ( first , second ) ; int expected = integer . compare ( index1 , index2 ) ; assertthathavesamesignum ( expected , result ) ; }	the assumption here is that log entries in array were created in ascending order .
public static void copyall ( file root , file dest ) throws ioexception { if ( root . isdirectory ( ) ) { for ( file child : root . listfiles ( ) ) { file childdest = new file ( dest , child . getname ( ) ) ; if ( child . isdirectory ( ) ) { if ( ! childdest . exists ( ) && ! mkdirs ( childdest ) ) throw new ioexception ( _str + childdest . getpath ( ) ) ; copyall ( child , childdest ) ; } else { files . copy ( child . topath ( ) , childdest . topath ( ) , standardcopyoption . copy_attributes ) ; } } } else { file childdest = new file ( dest , root . getname ( ) ) ; if ( ! dest . exists ( ) && ! mkdirs ( dest ) ) throw new ioexception ( _str + dest . getpath ( ) ) ; files . copy ( root . topath ( ) , childdest . topath ( ) , standardcopyoption . copy_attributes ) ; } }	recursively copy every file / folder from root to dest.
public void paintline ( point2d pt1 , point2d pt2 ) { if ( pt1 != null && pt2 != null ) { omline cline = new omline ( pt1 . gety ( ) , pt1 . getx ( ) , pt2 . gety ( ) , pt2 . getx ( ) , omgraphic . linetype_greatcircle ) ; projection proj = themap . getprojection ( ) ; cline . generate ( proj ) ; distancelist . add ( cline ) ; } }	draw a rubberband line between two points.
public static boolean hasexportmaskforstorageandvarray ( dbclient dbclient , exportgroup exportgroup , uri storageuri ) { set < string > storageporturisassociatedwithvarrayandstoragearray = exportmaskutils . getstorageporturisassociatedwithvarrayandstoragearray ( storageuri , exportgroup . getvirtualarray ( ) , dbclient ) ; stringset maskuriset = exportgroup . getexportmasks ( ) ; if ( maskuriset != null ) { for ( string maskuristring : maskuriset ) { exportmask mask = dbclient . queryobject ( exportmask . class , uri . create ( maskuristring ) ) ; uri maskstorageuri = mask . getstoragedevice ( ) ; if ( maskstorageuri . equals ( storageuri ) ) { for ( string storageport : mask . getstorageports ( ) ) { if ( storageporturisassociatedwithvarrayandstoragearray . contains ( storageport ) ) return _bool ; } } } } return _bool ; }	for a given export group and storage system , this will check wheather there are any export mask exists in storage system which matches export group and storage ports in varray.
private void preload ( int first , boolean increasing ) { final int start ; final int end ; if ( increasing ) { start = math . max ( first , mlastend ) ; end = math . min ( first + mloadaheaditems , mitemsource . getcount ( ) ) ; } else { start = math . max ( _num , first - mloadaheaditems ) ; end = math . min ( first , mlaststart ) ; } log . v ( tag , _str + first + _str + increasing + _str + start + _str + end ) ; mlastend = end ; mlaststart = start ; if ( start == _num && end == _num ) { return ; } final list < t > items = mitemsource . getitemsinrange ( start , end ) ; if ( ! increasing ) { collections . reverse ( items ) ; } registerloadtokens ( mitemloader . preloaditems ( items ) ) ; }	initiates a pre load .
private void initrmiparameters ( ) throws exception { if ( rmihostmaster == null || rmiportmaster == null ) { file confdir = replicatorruntimeconf . locatereplicatorconfdir ( ) ; file propsfile = new file ( confdir , replicationservicemanager . config_services ) ; println ( string . format ( _str , propsfile ) ) ; tungstenproperties serviceprops = propertiesmanager . loadproperties ( propsfile ) ; if ( rmiportmaster == null ) rmiportmaster = serviceprops . getstring ( replicatorconf . rmi_port , replicatorconf . rmi_default_port , _bool ) ; if ( rmihostmaster == null ) rmihostmaster = replicationservicemanager . gethostname ( serviceprops ) ; } }	tries to load services.
public string encodekey ( final string key ) { if ( stringutils . isempty ( key ) ) { throw new illegalargumentexception ( _str ) ; } try { return hex . encodehexstring ( key . getbytes ( _str ) ) ; } catch ( unsupportedencodingexception uee ) { throw new illegalstateexception ( uee ) ; } }	encode the given key to hexadecimal .
private static void globaluniontest ( final ischemaversion schemaversion ) throws ioexception { final writer output = openoutput ( schemaversion , _str , testtype . union ) ; final hll hll = newhll ( hlltype . empty ) ; final hll emptyhll = newhll ( hlltype . empty ) ; cumulativeunionline ( output , hll , emptyhll , schemaversion ) ; for ( int i = _num ; i < _num ; i ++ ) { final hll randomhll = generaterandomhll ( ) ; cumulativeunionline ( output , hll , randomhll , schemaversion ) ; } output . flush ( ) ; output . close ( ) ; }	unions an empty accumulator with random hlls . format : cumulative union tests : - hopefully all union possibilities.
public static boolean restore ( ) { file restoreconfig = new file ( restoration_properties ) ; if ( restoreconfig . exists ( ) && restoreconfig . isfile ( ) ) { logger . info ( _str ) ; try ( fileinputstream stream = new fileinputstream ( restoreconfig ) ) { properties properties = new properties ( ) ; properties . load ( stream ) ; restoredatabase ( properties ) ; restoresolrindex ( properties ) ; } catch ( unsupportedoperationexception e ) { logger . error ( _str , e ) ; system . setproperty ( _str , _str ) ; } catch ( exception e ) { logger . fatal ( _str , e ) ; return _bool ; } finally { restoreconfig . delete ( ) ; } } return _bool ; }	restores dhus in a previous state .
public void testsetbitpositiveinside4 ( ) { byte abytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = _num ; int number = _num ; byte rbytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . setbit ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	setbit ( int n ) inside a positive number.
@ override public void writecomment ( string data ) throws xmlstreamexception { log . log ( level . fine , _str , data ) ; }	writes an xml comment with the data enclosed.
public static file fromdatauri ( string datauri , string filename ) { return file . createifsupported ( fromdatauri ( datauri ) , filename ) ; }	create a new file from the datauri string.
protected list extractdiscoveryinformation ( xrds xrds , xriidentifier identifier , resolver xriresolver ) throws discoveryexception { arraylist endpoints = new arraylist ( ) ; xrd xrd = xrds . getfinalxrd ( ) ; extractdiscoveryinformationopenid ( xriresolver , endpoints , xrd , identifier , discoveryinformation . openid2_op , _bool ) ; extractdiscoveryinformationopenid ( xriresolver , endpoints , xrd , identifier , discoveryinformation . openid2 , _bool ) ; extractdiscoveryinformationopenid ( xriresolver , endpoints , xrd , identifier , discoveryinformation . openid11 , _bool ) ; extractdiscoveryinformationopenid ( xriresolver , endpoints , xrd , identifier , discoveryinformation . openid10 , _bool ) ; if ( endpoints . size ( ) == _num ) _log . info ( _str ) ; return endpoints ; }	extracts openid discovery endpoints from a xrds discovery result for xri identifiers .
public static void clearrecentfiles ( ) { string str = programproperties . get ( recentfiles , _str ) ; if ( str . length ( ) != _num ) { programproperties . put ( recentfiles , _str ) ; notifylistchange ( recentfiles ) ; } }	clears the list of recent files.
public static boolean areequivalent ( final typereference a , final typereference b ) { return areequivalent ( a , b , _bool ) ; }	returns whether two type references refer to the same type.
private static char callstaticcharmethodv ( jnienvironment env , int classjref , int methodid , address argaddress ) throws exception { if ( tracejni ) vm . syswrite ( _str ) ; runtimeentrypoints . checkjnicountdowntogc ( ) ; try { object returnobj = jnihelpers . invokewithvararg ( methodid , argaddress , typereference . char ) ; return reflection . unwrapchar ( returnobj ) ; } catch ( throwable unexpected ) { if ( tracejni ) unexpected . printstacktrace ( system . err ) ; env . recordexception ( unexpected ) ; return _num ; } }	callstaticcharmethodv : invoke a static method that returns a char value.
private boolean initxsettingsifneeded ( final string propname ) { if ( ! loadedxsettings && ( propname . startswith ( _str ) || propname . equals ( suntoolkit . desktopfonthints ) || propname . startswith ( dndprefix ) ) ) { loadedxsettings = _bool ; if ( ! graphicsenvironment . isheadless ( ) ) { loadxsettings ( ) ; if ( desktopproperties . get ( suntoolkit . desktopfonthints ) == null ) { if ( xwm . iskde2 ( ) ) { object hint = fcmanager . getfontconfigaahint ( ) ; if ( hint != null ) { desktopproperties . put ( unixtoolkit . fontconfigaahint , hint ) ; } } desktopproperties . put ( suntoolkit . desktopfonthints , suntoolkit . getdesktopfonthints ( ) ) ; } return _bool ; } } return _bool ; }	initializes xawtxsettings if a property for a given property name is provided by xsettings and they are not initialized yet .
private void updatesortingicons ( ) { for ( sortingtype type : sortingtype . values ( ) ) { sortingdirection direction = model . getsortingdirection ( type ) ; imageicon icon ; switch ( direction ) { case descending : icon = icon_arrow_down ; break ; case ascending : icon = icon_arrow_up ; break ; case undefined : icon = null ; break ; default : icon = null ; } switch ( type ) { case name : sortinglabelattname . seticon ( icon ) ; break ; case type : sortinglabelatttype . seticon ( icon ) ; break ; case missing : sortinglabelattmissings . seticon ( icon ) ; break ; default : sortinglabelattname . seticon ( null ) ; sortinglabelatttype . seticon ( null ) ; sortinglabelattmissings . seticon ( null ) ; } } }	updates the sorting icons .
private void restoreicon ( key key , byte [ ] buffer , int datasize ) throws ioexception { if ( verbose ) log . v ( tag , _str + key . id ) ; if ( debug ) log . d ( tag , _str + buffer . length + _str + base64 . encodetostring ( buffer , _num , datasize , base64 . no_wrap ) ) ; resource res = unpackproto ( new resource ( ) , buffer , datasize ) ; if ( debug ) { log . d ( tag , _str + res . dpi + _str ) ; } bitmap icon = bitmapfactory . decodebytearray ( res . data , _num , res . data . length ) ; if ( icon == null ) { log . w ( tag , _str + key . name ) ; } if ( verbose ) log . v ( tag , _str + key . name ) ; iconcache . preloadicon ( mcontext , componentname . unflattenfromstring ( key . name ) , icon , res . dpi ) ; }	read an icon from the stream.
public boolean isexpired ( ) { return paymentdetails . hasexpires ( ) && system . currenttimemillis ( ) / _num > paymentdetails . getexpires ( ) ; }	this should always be called before attempting to call sendpayment .
public static void readbytes ( inputstream is , byte [ ] b , int offset , int len ) { if ( len == _num ) return ; try { int read = _num ; while ( read < len ) { int n = is . read ( b , offset + read , len - read ) ; if ( n < _num ) throw new pngjinputexception ( _str + n + _str + len ) ; read += n ; } } catch ( ioexception e ) { throw new pngjinputexception ( _str , e ) ; } }	guaranteed to read exactly len bytes . throws error if it can ' t.
public charactermatch ( char [ ] chars ) { assert . isnotnull ( chars ) ; assert . istrue ( chars . length > _num ) ; fchars = chars ; arrays . sort ( chars ) ; }	creates a new instance .
public void addactionlistener ( actionlistener newa ) { m_listeners . add ( newa ) ; }	add a listener interested in kowing about editor status changes.
public boolean removecontainerandcancelifnecessary ( imagecontainer container ) { mcontainers . remove ( container ) ; if ( mcontainers . size ( ) == _num ) { mrequest . cancel ( ) ; return _bool ; } return _bool ; }	detatches the bitmap container from the request and cancels the request if no one is left listening .
public static byte [ ] encode ( byte [ ] data , int off , int length ) { bytearrayoutputstream bout = new bytearrayoutputstream ( ) ; try { encoder . encode ( data , off , length , bout ) ; } catch ( exception e ) { throw new encoderexception ( _str + e . getmessage ( ) , e ) ; } return bout . tobytearray ( ) ; }	encode the input data producing a hex encoded byte array .
@ notnull public list < playernbt > createmultiplayerplayernbts ( ) { list < playernbt > result = new arraylist < playernbt > ( ) ; for ( file playerdatafile : getplayerdatafiles ( ) ) { if ( playerdatafile . isfile ( ) ) { result . add ( createplayerdataplayernbt ( getplayeruuidfromplayerdatafile ( playerdatafile ) ) ) ; } } if ( ! result . isempty ( ) ) { log . i ( _str ) ; return result ; } for ( file playersfile : getplayersfiles ( ) ) { if ( playersfile . isfile ( ) ) { result . add ( createplayersplayernbt ( getplayernamefromplayersfile ( playersfile ) ) ) ; } } if ( ! result . isempty ( ) ) { log . i ( _str ) ; return result ; } log . i ( _str ) ; return result ; }	since version 1 . 7 . 6 , minecraft stores players in the playerdata directory and uses the player uuid as filename .
private void show ( setupwindow window ) { window . handlewindowopeningevent ( ) ; _setupwindowholder . show ( window . getkey ( ) ) ; _currentwindow = window ; }	show the specified window.
private static string replacestars ( string init ) { stringbuilder builder = new stringbuilder ( ) ; char [ ] chars = init . tochararray ( ) ; for ( int i = _num ; i < chars . length ; i ++ ) { if ( chars [ i ] == _str && i == _num && chars . length > _num && chars [ i + _num ] == _str ) { builder . append ( _str ) ; i ++ ; } else if ( chars [ i ] == _str && i < ( chars . length - _num ) && i > _num && chars [ i + _num ] == _str && chars [ i - _num ] == _str ) { builder . deletecharat ( builder . length ( ) - _num ) ; builder . append ( _str ) ; } else if ( chars [ i ] == _str && i == ( chars . length - _num ) && i > _num && chars [ i - _num ] == _str ) { builder . deletecharat ( builder . length ( ) - _num ) ; builder . append ( _str ) ; } else if ( chars [ i ] == _str ) { builder . append ( _str ) ; } else { builder . append ( chars [ i ] ) ; } } return builder . tostring ( ) ; }	replaces the * characters in the string by a proper regular expression.
public void startoptiongroup ( string description ) { optiongroups . put ( optionlist . size ( ) , description ) ; }	start a new group of related command - line options .
public final void expectatleastoneresult ( resultset rs ) throws adeinternalexception , sqlexception { if ( ! rs . next ( ) ) { throw new adeinternalexception ( _str + m_sql ) ; } }	verifies given result set contains at least one row.
public sequence ( ) { this ( initial_value ) ; }	create a sequence initialised to - 1 .
public static optional < mongocredential > createcredentials ( string username , string password , string database ) { if ( ! strings . isnullorempty ( username ) && ! strings . isnullorempty ( password ) && ! strings . isnullorempty ( database ) ) { return optional . of ( mongocredential . createmongocrcredential ( username , database , password . tochararray ( ) ) ) ; } else { return optional . absent ( ) ; } }	creates a mongocredential if a username , password and database are supplied , or returns absent ( ) otherwise.
@ override public void stop ( ) { if ( executorservice != null ) { executorservice . shutdown ( ) ; } resttemplate = null ; }	stops communication with and closes all connections to the remote http server ( service ) .
public resultrecord ( directoryscannerconfig scan , action [ ] actions , file f ) { directoryscanner = scan . getname ( ) ; this . actions = actions ; date = new date ( ) ; filename = f . getabsolutepath ( ) ; }	creates a new instance of resultrecord .
private methoddoc findimplmethod ( methoddoc interfacemethod ) { string name = interfacemethod . name ( ) ; string desc = util . methoddescriptorof ( interfacemethod ) ; for ( methoddoc implmethod : implclass . methods ( ) ) { if ( name . equals ( implmethod . name ( ) ) && desc . equals ( util . methoddescriptorof ( implmethod ) ) ) { return implmethod ; } } return null ; }	returns the methoddoc for the method of this remote implementation class that implements the specified remote method of a remote interface.
protected static list < string > extractbootclasspath ( final list < string > args ) { return extractoptwithpattern ( boot_class_path_regex , _bool , args ) ; }	remove all - xbootclasspath / p : or - j - xbootclasspath / p : arguments from args and add them to the returned list.
public abstract object fromopenvalue ( object openvalue ) throws invalidobjectexception ;	< p > convert an instance of the open type into the java type .
public contourpath ( contourattrib attr , int levelindex , double [ ] x , double [ ] y ) { xarr = x ; yarr = y ; this . levelindex = levelindex ; attributes = attr ; int np = xarr . length ; if ( math . abs ( x [ _num ] - x [ np - _num ] ) < ksmallx && math . abs ( y [ _num ] - y [ np - _num ] ) < ksmally ) { closed = _bool ; x [ np - _num ] = x [ _num ] ; y [ np - _num ] = y [ _num ] ; } else closed = _bool ; }	construct a contour path or line using the given arrays of x & y values .
protected void print ( string mnemonic , string [ ] args ) { printer . print ( indent + _str ) ; writepaddedstring ( mnemonic + _str , _num ) ; if ( args != null ) { for ( int i = _num ; i < args . length ; i ++ ) { if ( i > _num ) { printer . print ( _str ) ; } printer . print ( args [ i ] ) ; } } printer . println ( ) ; }	description of the method.
@ override public void removeconnectioneventlistener ( connectioneventlistener listener ) { debugcode ( _str ) ; listeners . remove ( listener ) ; }	remove the event listener .
public boolean isdownloadable ( ) { list < string > topics = getexacttopics ( ) ; for ( string xt : topics ) if ( xt . startswith ( _str ) ) return _bool ; if ( getdefaulturls ( ) . length > _num ) { return _bool ; } return _bool ; }	returns true if there are enough pieces of information to start a download from it.
public boolean issatisfiedby ( date date ) { calendar testdatecal = calendar . getinstance ( gettimezone ( ) ) ; testdatecal . settime ( date ) ; testdatecal . set ( calendar . millisecond , _num ) ; date originaldate = testdatecal . gettime ( ) ; testdatecal . add ( calendar . second , - _num ) ; date timeafter = gettimeafter ( testdatecal . gettime ( ) ) ; return ( ( timeafter != null ) && ( timeafter . equals ( originaldate ) ) ) ; }	indicates whether the given date satisfies the cron expression.
public static vector < string > scanfordirlogs ( final string currentpath ) { if ( cfg . debug ) { check . requires ( currentpath != null , _str ) ; } file fc ; final vector < string > vector = new vector < string > ( ) ; try { fc = new file ( currentpath ) ; if ( fc . isdirectory ( ) ) { final string [ ] filelogs = fc . list ( ) ; for ( final string dir : filelogs ) { final file fdir = new file ( currentpath + dir ) ; if ( fdir . isdirectory ( ) ) { vector . addelement ( dir + _str ) ; if ( cfg . debug ) { check . log ( tag + _str + dir ) ; } } } } } catch ( final exception e ) { if ( cfg . exception ) { check . log ( e ) ; } if ( cfg . debug ) { check . log ( tag + _str + e ) ; } } if ( cfg . debug ) { check . log ( tag + _str + vector . size ( ) ) ; } return vector ; }	restituisce la lista ordinata dele dir secondo il nome .
private static arraylist < string > flattenrows ( cursor cursor , int limit ) { util . throwifnot ( limit >= _num ) ; arraylist < string > flatlist = new arraylist < > ( ) ; final int numcolumns = cursor . getcolumncount ( ) ; for ( int row = _num ; row < limit && cursor . movetonext ( ) ; row ++ ) { for ( int column = _num ; column < numcolumns ; column ++ ) { switch ( cursor . gettype ( column ) ) { case cursor . field_type_null : flatlist . add ( null ) ; break ; case cursor . field_type_integer : flatlist . add ( string . valueof ( cursor . getlong ( column ) ) ) ; break ; case cursor . field_type_float : flatlist . add ( string . valueof ( cursor . getdouble ( column ) ) ) ; break ; case cursor . field_type_blob : flatlist . add ( blobtostring ( cursor . getblob ( column ) ) ) ; break ; case cursor . field_type_string : default : flatlist . add ( cursor . getstring ( column ) ) ; break ; } } } if ( ! cursor . isafterlast ( ) ) { for ( int column = _num ; column < numcolumns ; column ++ ) { flatlist . add ( _str ) ; } } return flatlist ; }	flatten all columns and all rows of a cursor to a single array.
public void collapseallparents ( ) { if ( mdatalist != null && ! mdatalist . isempty ( ) ) { arraylist < object > expandablelistitems = getparents ( _bool ) ; if ( expandablelistitems != null && ! expandablelistitems . isempty ( ) ) { final int expandeditemsize = expandablelistitems . size ( ) ; if ( expandeditemsize > _num ) { for ( int i = _num ; i < expandeditemsize ; i ++ ) { object o = expandablelistitems . get ( i ) ; int indexof = mdatalist . indexof ( o ) ; if ( indexof >= _num ) collapselistitem ( indexof , ( baseexpandableobservable ) o , _bool ) ; } } } } }	collapses all parents in the list .
@ deprecated protected pdfformxobject drawpushbuttonappearance ( float width , float height , string text , pdffont font , int fontsize ) { return drawpushbuttonappearance ( width , height , text , font , ( float ) fontsize ) ; }	draws the appearance for a push button .
public nbttagcompound loadfile ( file savedirectory , string filename ) { return loadfile ( new file ( savedirectory , filename + _str ) ) ; }	reads nbt data from the world folder .
public boolean dnsdomainis ( string host , string domain ) { return host . endswith ( domain ) ; }	tests if an url is in a given domain .
@ suppresswarnings ( _str ) public selectionbuilder reset ( ) { mtable = null ; if ( mprojectionmap != null ) { mprojectionmap . clear ( ) ; } if ( mselection != null ) { mselection . setlength ( _num ) ; } if ( mselectionargs != null ) { mselectionargs . clear ( ) ; } return this ; }	reset any internal state , allowing this builder to be recycled .
private final synchronized enumeration < policyentry > elements ( ) { return policyentries . elements ( ) ; }	enumerate all the entries in the global policy object.
public string format ( calendar calendar , calendar smsccalendar ) { if ( calendar == null || smsccalendar == null ) { return null ; } long difftimeinmillis = calendar . gettimeinmillis ( ) - smsccalendar . gettimeinmillis ( ) ; if ( difftimeinmillis < _num ) { throw new illegalargumentexception ( _str ) ; } calendar offsetepoch = calendar . getinstance ( utctimezone ) ; offsetepoch . settimeinmillis ( difftimeinmillis ) ; int years = offsetepoch . get ( calendar . year ) - _num ; int months = offsetepoch . get ( calendar . month ) ; int days = offsetepoch . get ( calendar . day_of_month ) - _num ; int hours = offsetepoch . get ( calendar . hour_of_day ) ; int minutes = offsetepoch . get ( calendar . minute ) ; int seconds = offsetepoch . get ( calendar . second ) ; if ( years >= _num ) { throw new illegalargumentexception ( _str + years + _str ) ; } return format ( years , months , days , hours , minutes , seconds ) ; }	return the relative time from the calendar datetime against the smsc datetime .
public void testbug20685022 ( ) throws exception { if ( ! iscommunityedition ( ) ) { return ; } final properties props = new properties ( ) ; props . clear ( ) ; props . setproperty ( _str , _str ) ; props . setproperty ( _str , _str ) ; props . setproperty ( _str , _str ) ; getconnectionwithprops ( props ) ; props . clear ( ) ; props . setproperty ( _str , _str ) ; props . setproperty ( _str , _str ) ; props . setproperty ( _str , _str ) ; props . setproperty ( _str , _str ) ; props . setproperty ( _str , _str ) ; props . setproperty ( _str , _str ) ; getconnectionwithprops ( props ) ; props . clear ( ) ; props . setproperty ( _str , _str ) ; props . setproperty ( _str , _str ) ; props . setproperty ( _str , _str ) ; string truststorepath = _str ; system . setproperty ( _str , truststorepath ) ; system . setproperty ( _str , _str ) ; system . setproperty ( _str , truststorepath ) ; system . setproperty ( _str , _str ) ; getconnectionwithprops ( props ) ; }	tests fix for bug # 20685022 - ssl connection to mysql 5.
public static boolean canrun ( final file file ) { return manager . getenginebyextension ( fileutils . getfileextension ( file ) ) != null ; }	determines whether a file has the file extension of a valid script file .
public void parseelement ( string tagname , map < string , object > attrs ) { if ( canvas == null && tagname . equalsignorecase ( _str ) ) { scale = mxutils . getdouble ( attrs , _str , _num ) ; canvas = createcanvas ( attrs ) ; if ( canvas != null ) { canvas . setscale ( scale ) ; } } else if ( canvas != null ) { boolean drawlabel = _bool ; if ( tagname . equalsignorecase ( _str ) || tagname . equalsignorecase ( _str ) ) { drawvertex ( attrs ) ; drawlabel = _bool ; } else if ( tagname . equalsignorecase ( _str ) ) { drawedge ( attrs ) ; drawlabel = _bool ; } if ( drawlabel ) { drawlabel ( tagname . equalsignorecase ( _str ) , attrs ) ; } } }	parses the given element and paints it onto the canvas .
private void startprecaching ( ) { log . v ( tag , _str ) ; preparenativelibraries ( ) ; sisprecaching = _bool ; acquireprecachingwakelock ( ) ; mprecachelauncher . start ( ) ; }	begin a precache cycle .
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public wordalignmentstate ( final rule rule , final int start ) { trgpoints = new linkedlist < > ( ) ; srclength = rule . getfrench ( ) . length ; numnt = rule . getarity ( ) ; srcstart = start ; final map < integer , list < integer > > alignmentmap = rule . getalignmentmap ( ) ; final int [ ] nonterminalsourcepositions = rule . getnonterminalsourcepositions ( ) ; final int [ ] trg = rule . getenglish ( ) ; for ( int trgindex = _num ; trgindex < trg . length ; trgindex ++ ) { final alignedsourcetokens trgpoint = new alignedsourcetokens ( ) ; if ( trg [ trgindex ] >= _num ) { if ( alignmentmap . containskey ( trgindex ) ) { for ( int srcidx : alignmentmap . get ( trgindex ) ) { trgpoint . add ( srcstart + srcidx ) ; } } else { trgpoint . setnull ( ) ; } } else { trgpoint . setnonterminal ( ) ; final int absolutenonterminalsourceposition = srcstart + nonterminalsourcepositions [ math . abs ( trg [ trgindex ] ) - _num ] ; trgpoint . add ( absolutenonterminalsourceposition ) ; } trgpoints . add ( trgpoint ) ; } }	construct alignmentstate object from a virgin rule and its source span . determines if state is complete ( if no nt present ).
protected void configureimagereaderloaders ( ) { imagereaderloaders = new vector < imagereaderloader > ( ) ; imagereaderloader idl = ( imagereaderloader ) componentfactory . create ( _str ) ; if ( idl != null ) { imagereaderloaders . add ( idl ) ; } else { logger . warning ( _str ) ; } idl = ( imagereaderloader ) componentfactory . create ( _str ) ; if ( idl != null ) { imagereaderloaders . add ( idl ) ; } else { logger . warning ( _str ) ; } }	internal callback method for subclasses to use to be able to configure imagereaderloader vector with specific imagereaderloaders.
protected void handlespecialsubstitution ( string replace , string replacewith , int startpos , string description ) { if ( replace . equals ( _str ) ) { if ( replacewith . charat ( _num ) == _str ) { error ( _str , startpos , description ) ; } ignorechars = charset . parsestring ( replacewith ) ; } }	this function defines a protocol for handling substitution names that are " special , " i.
@ override public void countexample ( example example ) { double plabel ; double label = example . getvalue ( labelattribute ) ; if ( ! predictedattribute . isnominal ( ) ) { plabel = example . getvalue ( predictedattribute ) ; } else { string labels = example . getvalueasstring ( labelattribute ) ; plabel = example . getconfidence ( labels ) ; label = _num ; } double weight = _num ; if ( weightattribute != null ) { weight = example . getvalue ( weightattribute ) ; } double diff = weight * math . abs ( label - plabel ) ; deviationsum += diff ; double reldiff = math . abs ( weight * label - ( truelabelsum / examplecounter ) ) ; relativesum += reldiff ; }	calculates the error for the current example .
private void adddeclannotations ( map < string , set < annotationmirror > > declannos , element elt ) { if ( fromstubfile != null ) { set < annotationmirror > annos = declannos . get ( elementutils . getverbosename ( elt ) ) ; if ( annos == null ) { annos = annotationutils . createannotationset ( ) ; putoraddtomap ( declannos , elementutils . getverbosename ( elt ) , annos ) ; } annos . add ( fromstubfile ) ; } }	adds a declannotation to every method in the stub file .
private void inspectconditionswithbooleans ( linkedlist < psielement > objbranchconditions ) { for ( psielement objexpression : objbranchconditions ) { if ( ! ( objexpression instanceof constantreference ) ) { continue ; } if ( expressionsemanticutil . isboolean ( ( constantreference ) objexpression ) ) { holder . registerproblem ( objexpression , strproblemdescriptionbooleans , problemhighlighttype . generic_error_or_warning ) ; } } }	checks if any of conditions is boolean.
public static xcontenttype xcontenttype ( charsequence content ) { int length = content . length ( ) < guess_header_length ? content . length ( ) : guess_header_length ; if ( length == _num ) { return null ; } char first = content . charat ( _num ) ; if ( first == _str ) { return xcontenttype . json ; } if ( length > _num && first == smileconstants . header_byte_1 && content . charat ( _num ) == smileconstants . header_byte_2 && content . charat ( _num ) == smileconstants . header_byte_3 ) { return xcontenttype . smile ; } if ( length > _num && first == _str && content . charat ( _num ) == _str && content . charat ( _num ) == _str ) { return xcontenttype . yaml ; } for ( int i = _num ; i < length ; i ++ ) { char c = content . charat ( i ) ; if ( c == _str ) { return xcontenttype . json ; } if ( character . iswhitespace ( c ) == _bool ) { break ; } } return null ; }	guesses the content type based on the provided char sequence .
@ requestmapping ( value = _str , method = requestmethod . delete ) public responseentity < bookmark > deletebookmark ( @ pathvariable ( value = _str ) string username , @ pathvariable ( value = _str ) int bookmarkid ) throws bookmarknotfoundexception { optional < bookmark > optional = bookmarksrepository . findbyidanduserusername ( bookmarkid , username ) ; if ( optional . ispresent ( ) ) { bookmarksrepository . delete ( optional . get ( ) ) ; return new responseentity < > ( optional . get ( ) , httpstatus . ok ) ; } else { throw new bookmarknotfoundexception ( _str + bookmarkid ) ; } }	a method to delete a bookmark identified by id .
public static object loadinstance ( class clazz , object defaultvalue ) { try { return clazz . newinstance ( ) ; } catch ( throwable t ) { return defaultvalue ; } }	loads a class from a string classname.
public static string tojsonstring ( object value ) { final stringwriter writer = new stringwriter ( ) ; try { writejsonstring ( value , writer ) ; return writer . tostring ( ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }	convert an object to json text.
public static final < a > collectionx < a > tolazycollection ( final stream < a > stream ) { return sequtils . tolazycollection ( stream . iterator ( ) ) ; }	projects an immutable collection of this stream.
static unit valueof ( string name , boolean horizontal ) { if ( name . length ( ) == _num ) { unit defaultunit = sizes . getdefaultunit ( ) ; if ( defaultunit != null ) { return defaultunit ; } return horizontal ? dialog_units_x : dialog_units_y ; } else if ( name . equals ( _str ) ) { return pixel ; } else if ( name . equals ( _str ) ) { return horizontal ? dialog_units_x : dialog_units_y ; } else if ( name . equals ( _str ) ) { return point ; } else if ( name . equals ( _str ) ) { return inch ; } else if ( name . equals ( _str ) ) { return millimeter ; } else if ( name . equals ( _str ) ) { return centimeter ; } else { throw new illegalargumentexception ( _str + name + _str + _str ) ; } }	returns a unit that corresponds to the specified string .
public void checknumberargs ( int argnum ) throws wrongnumberargsexception { if ( ( argnum < _num ) || ( argnum > _num ) ) reportwrongnumberargs ( ) ; }	overide the superclass method to allow one or two arguments .
